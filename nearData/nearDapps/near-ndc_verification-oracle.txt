*GitHub Repository "near-ndc/verification-oracle"*

'''--- .clippy.toml ---
msrv = "1.69"

'''
'''--- .github/workflows/build_image.yml ---
on:
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    steps:
    - name: Test
      run: |
        echo ${{ env.IMAGE_NAME }}
    - name: Checkout
      uses: actions/checkout@v2
      with:
        fetch-depth: 0
    - name: Login to registry
      uses: docker/login-action@v2
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    - name: Docker meta        
      uses: docker/metadata-action@v4
      id: meta
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
    - name: Build and push
      uses: docker/build-push-action@v3
      with:
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}

'''
'''--- .github/workflows/rust.yml ---
name: Rust

on:
  pull_request:
  merge_group:

concurrency:
  group: ci-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  fmt:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - run: cargo fmt --all --check
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/cache@v3
        with:
          path: |
            ~/.cargo/registry/index
            ~/.cargo/registry/cache
            target
          key: cargo-cache-${{ hashFiles('Cargo.*') }}
      - uses: technote-space/get-diff-action@v6.1.2
        with:
          PATTERNS: |
            **/**.rs
            contracts/Cargo.lock
      - name: Clippy
        if: env.GIT_DIFF
        run: cargo clippy --release
      - name: Clippy (Tests)
        if: env.GIT_DIFF
        run: cargo clippy --tests --release
      - name: Build
        if: env.GIT_DIFF
        run: cargo build --release
      - name: Run tests
        if: env.GIT_DIFF
        run: cargo test --release

'''
'''--- Cargo.toml ---
[package]
name = "verification-oracle"
version = "0.1.0"
edition = "2021"
authors = ["Kirill QQ <zeliondragon@gmail.com>"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
tokio = { version = "1.28.2", features = ["full"] }
axum = {version = "0.6.18", features = ["headers"]}
chrono = "0.4.26"
dotenv = "0.15.0"
tracing = "0.1.37"
tracing-appender = "0.2.2"
tracing-subscriber = { version = "0.3.17", features = ["env-filter", "registry", "json"] }
tower-http = { version = "0.4.0", features = ["cors"] }
config = { version = "0.13.3", default_features = false, features = ["json"] }
log = { version = "0.4", features = ["max_level_debug", "release_max_level_warn"] }
backtrace = "0.3"
near-sdk = "4.1.1"
near-crypto = "0.17.0"
reqwest = { version = "0.11", features = ["rustls-tls", "json", "deflate"] }
thiserror = "1.0.40"
uuid = { version = "1.3.3", features = [ "v4", "fast-rng" ] }

[dev_dependencies]
assert_matches = "1.5.0"

'''
'''--- README.md ---
# verification-oracle

User verification oracle for SBT issuer.

## Prerequisites

Installed `nginx` with valid certificates for `HTTPS` protocol

## Setup

Setup `nginx` to route https `POST` requests to locally bound ports.
Default ports for `production` env is 8080 and for `staging` env is 8081.
If not default ports required to be used, those should be updated in the configuration later.

## Configuration

All default configuration is available in `config/default.json` file.
To override these settings, create a `config/local.jsom` file.

### Credentials

Use `near generate-key i-am-human-credentials --networkId mainnet` to generate new credentials.
The above command will create a file `~/.near-credentials/mainnet/i-am-human-credentials.json` with required private key.

The `private_key` property from a resulting file could be either passed with environment variable `SIGNING_KEY` or set via configuration file as:

```
  "signer": {
    "credentials": {
      "signingKey": "{{PUT_PRIVATE_KEY_HERE}}"
    }
  }
```

The public key generated in a file `~/.near-credentials/mainnet/i-am-human-credentials.json` is in wrapped format.
If the ed25519 base64 encoded public key required (e.g. for i-am-human near contract), it could be obtained after service start from
an output (search for text `ED25519 public key (base64 encoded):`)

### Verification Provider Configuration

As a verification provider we use Fractal.id <https://fractal.id/>

Provider could be configured with JSON configuration below:

```
    "verificationProvider": {
      "requestTokenUrl": "https://{{PUT_PUT_AUTH_FRACTAL_HOST_HERE}}/oauth/token",
      "requestUserUrl": "https://{{PUT_PUT_RESOURCE_FRACTAL_HOST_HERE}}/users/me",
      "clientId": "{{PUT_FRACTAL_CLIENT_ID_HERE}}",
      "clientSecret": "{{PUT_FRACTAL_CLIENT_SECRET_HERE}}"
    }
```

Configuration keys explanation:

*   `requestTokenUrl` - Url used to acquire user token with provided `authorization_code`. Host should be set using the `AUTH_DOMAIN` placeholder from `Fractal.id` docs. See more <https://docs.developer.fractal.id/production-and-staging-urls>
*   `requestUserUrl` - Url used to acquire user information by an access token. Host should be set using the `RESOURCE_DOMAIN` placeholder from `Fractal.id` docs. See more <https://docs.developer.fractal.id/production-and-staging-urls>
*   `clientId` - Client id from API info acquired after create of integration at `Fractal.id` client dashboard. See more <https://docs.developer.fractal.id/client-dashboard>
*   `clientSecret` - Client secret from API info acquired after create of integration at `Fractal.id` client dashboard. See more <https://docs.developer.fractal.id/client-dashboard>

### Google re-CAPTCHA configuration

We use re-CAPTCHA Enterprise to verify that request came from a human

Captcha client could be configured with JSON configuration below:

```
    "captcha": {
      "action": "homepage",
      "threshold": 0.5,
      "secret": "{{PUT_GOOGLE_CAPTCHA_SECRET_HERE}}
    }
```

Configuration keys explanation:

*   `action` - The page alias we want to verify captcha at, requests with `action` different from configured value will be denied
*   `threshold` - Google user's score threshold minimum to accept requests from. Score below this value will mean that user is most-likely a bot
*   `secret` - Secret required by Google to verify captcha for third-party clients

Sample of `*-secrets.json` configuration file:
```
{
    "verificationProvider": {
      "clientId": "{{SOME_CLIENT_ID_VALUE_HERE}}",
      "clientSecret": "{{SOME_CLIENT_SECRET_VALUE_HERE}}"
    },
    "signer": {
      "credentials": {
        "signingKey": "{{SOME_ED25519_BASE64_ENCODED_PRIVATE_KEY_HERE}}"
      }
    },
    "captcha": {
      "secret": "{{PUT_GOOGLE_CAPTCHA_SECRET_HERE}}
    }
}
```

## Deploy (GitHub Registry)

### Build

Use `GitHub Actions` script `.github/workflows/build_image.yml` to build images for `main` and `develop` branches to
be used accordingly for `production` and `staging` services

### Run

Pull & run docker image using docker-compose
`docker-compose pull && docker-compose --compatibility up -d`

## Deploy (Local Registry)

### Prerequisites

Prepare registry to be used with docker-compose
`docker run -d -p 5000:5000 --restart=always --name registry registry:2`

### Build

Build docker image
`docker build -t verification-oracle . &`

Tag previously built docker image
`docker tag verification-oracle:latest localhost:5000/verification-oracle`

Push built tag to registry
`docker push localhost:5000/verification-oracle:latest`

Update `docker-compose.yml` with images from local registry

### Run

Pull & run docker image using docker-compose
`docker-compose pull && docker-compose --compatibility up -d`

'''
'''--- config/default.json ---
{
  "listenAddress": "0.0.0.0:8080",
  "verificationProvider": {
    "requestTokenUrl": "https://auth.fractal.id/oauth/token",
    "requestUserUrl": "https://resource.fractal.id/users/me",
    "clientId": null,
    "clientSecret": null
  },
  "signer": {
    "credentials": null
  },
  "captcha": {
    "action": "homepage",
    "threshold": 0.5,
    "secret": null
  }
}
'''
'''--- config/production.json ---
{
  "listenAddress": "0.0.0.0:8080",
  "verificationProvider": {
    "requestTokenUrl": "https://auth.fractal.id/oauth/token",
    "requestUserUrl": "https://resource.fractal.id/users/me"
  },
  "captcha": {
    "action": "homepage",
    "threshold": 0.5,
    "secret": null
  }
}
'''
'''--- config/staging.json ---
{
  "listenAddress": "0.0.0.0:8081",
  "verificationProvider": {
    "requestTokenUrl": "https://auth.next.fractal.id/oauth/token",
    "requestUserUrl": "https://resource.next.fractal.id/users/me"
  },
  "captcha": {
    "action": "homepage",
    "threshold": 0.5,
    "secret": null
  }
}
'''
'''--- docker-compose.yml ---
version: "3.5"
services:
  verification-oracle-staging:
    image: ghcr.io/near-ndc/verification-oracle:develop
    restart: always
    command:
      - ./verification-oracle
    ports:
      - 8081:8081
    logging:
      options:
        max-size: 250m
        max-file: 3
    extra_hosts: []
    volumes:
      - type: bind
        source: /root/Projects/verification-oracle/config/staging.json
        target: /app/config/default.json
      - type: bind
        source: /root/Projects/verification-oracle/config/staging-secrets.json
        target: /app/config/local.json
    deploy:
      resources:
        limits:
          memory: 1000M
    environment:
      RUST_LOG: debug
    init: false
  verification-oracle-production:
    image: ghcr.io/near-ndc/verification-oracle:main
    restart: always
    command:
      - ./verification-oracle
    ports:
      - 8080:8080
    logging:
      options:
        max-size: 250m
        max-file: 3
    extra_hosts: []
    volumes:
      - type: bind
        source: /root/Projects/verification-oracle/config/production.json
        target: /app/config/default.json
      - type: bind
        source: /root/Projects/verification-oracle/config/production-secrets.json
        target: /app/config/local.json
    deploy:
      resources:
        limits:
          memory: 1000M
    environment:
      RUST_LOG: debug
    init: false

'''
'''--- src/captcha.rs ---
use crate::error::AppError;
use chrono::{DateTime, Utc};
use near_sdk::{serde::Deserialize, serde_json};
use reqwest::Client;

#[derive(Deserialize, Debug, Clone, Default)]
#[serde(crate = "near_sdk::serde", rename_all = "camelCase")]
pub struct CaptchaConfig {
    action: String,
    threshold: f64,
    secret: String,
}

#[derive(Clone)]
pub struct CaptchaClient {
    inner_client: Client,
    config: CaptchaConfig,
}

#[derive(Deserialize, Debug, Clone, Copy, PartialEq)]
#[serde(crate = "near_sdk::serde", rename_all = "kebab-case")]
pub enum CaptchaErrorCode {
    MissingInputSecret,
    InvalidInputSecret,
    MissingInputResponse,
    InvalidInputResponse,
    BadRequest,
    TimeoutOrDuplicate,
    #[serde(other)]
    Unknown,
}

impl Default for CaptchaErrorCode {
    fn default() -> Self {
        Self::Unknown
    }
}

#[derive(thiserror::Error, Debug)]
pub enum CaptchaError {
    #[error("Response error code: {0:?}")]
    ResponseError(CaptchaErrorCode),
    #[error("Invalid action")]
    InvalidAction,
    #[error("Request failure {0}")]
    RequestFailure(reqwest::Error),
    #[error("Request parse failure {0}")]
    ParseFailure(serde_json::Error),
}

#[derive(Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde", untagged)]
pub enum CaptchaResult {
    Success(CaptchaResponse),
    Failure(CaptchaErrorResponse),
}

#[derive(Deserialize, Debug, Clone, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct CaptchaResponse {
    success: bool,
    score: f64,
    action: String,
    #[serde(rename = "challenge_ts")]
    _challenge_ts: DateTime<Utc>,
    #[serde(rename = "hostname")]
    _hostname: String,
}

#[derive(Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct CaptchaErrorResponse {
    #[serde(rename = "error-codes")]
    error_codes: Vec<CaptchaErrorCode>,
}

impl CaptchaClient {
    pub fn new(config: CaptchaConfig) -> Result<Self, AppError> {
        let inner_client = Client::builder().pool_max_idle_per_host(0).build()?;

        Ok(Self {
            inner_client,
            config,
        })
    }

    async fn fetch_captcha(&self, token: &str) -> Result<String, CaptchaError> {
        let params: [(&str, &str); 2] = [("secret", &self.config.secret), ("response", token)];

        self.inner_client
            .post("https://www.google.com/recaptcha/api/siteverify")
            .form(&params)
            .send()
            .await
            .map_err(CaptchaError::RequestFailure)?
            .text()
            .await
            .map_err(CaptchaError::RequestFailure)
    }

    fn parse_captcha_response(&self, result: String) -> Result<CaptchaResponse, CaptchaError> {
        let captcha_res = serde_json::from_str::<CaptchaResult>(&result);
        tracing::trace!("Parsed captcha result: {captcha_res:?}");

        match captcha_res {
            Ok(CaptchaResult::Success(CaptchaResponse { success, .. })) if !success => {
                Err(CaptchaError::ResponseError(CaptchaErrorCode::BadRequest))
            }
            Ok(CaptchaResult::Success(CaptchaResponse { action, .. }))
                if action != self.config.action =>
            {
                Err(CaptchaError::InvalidAction)
            }
            Ok(CaptchaResult::Success(response)) => Ok(response),
            Ok(CaptchaResult::Failure(CaptchaErrorResponse { error_codes, .. })) => Err(
                CaptchaError::ResponseError(error_codes.first().copied().unwrap_or_default()),
            ),
            Err(e) => Err(CaptchaError::ParseFailure(e)),
        }
    }

    pub async fn verify(&self, token: &str) -> Result<bool, CaptchaError> {
        tracing::trace!("Verify captcha token `{token}`");

        let fetched = self.fetch_captcha(token).await?;

        let CaptchaResponse { score, .. } = self.parse_captcha_response(fetched)?;

        Ok(score >= self.config.threshold)
    }
}

#[cfg(test)]
mod tests {
    use super::{CaptchaClient, CaptchaConfig, CaptchaError, CaptchaErrorCode, CaptchaResponse};
    use assert_matches::assert_matches;
    use chrono::Utc;

    #[test]
    fn test_captcha_parsed() {
        let client = CaptchaClient::default();
        let now = Utc::now();

        assert_matches!(client.parse_captcha_response(format!(
                r#"{{
                    "success": true,
                    "score": 0.9,
                    "action": "homepage",
                    "challenge_ts": "{now}",
                    "hostname": "http://some_url"
                }}"#
            )),
            Ok(CaptchaResponse { score, .. }) if score == 0.9
        );
    }

    #[test]
    fn test_captcha_bad_request() {
        let client = CaptchaClient::default();
        let now = Utc::now();

        assert_matches!(
            client.parse_captcha_response(format!(
                r#"{{
                    "success": false,
                    "score": 0.0,
                    "action": "homepage",
                    "challenge_ts": "{now}",
                    "hostname": "http://some_url"
                }}"#,
            )),
            Err(CaptchaError::ResponseError(CaptchaErrorCode::BadRequest))
        );
    }

    #[test]
    fn test_captcha_invalid_action() {
        let client = CaptchaClient::default();
        let now = Utc::now();

        assert_matches!(
            client.parse_captcha_response(format!(
                r#"{{
                    "success": true,
                    "score": 0.0,
                    "action": "test",
                    "challenge_ts": "{now}",
                    "hostname": "http://some_url"
                }}"#,
            )),
            Err(CaptchaError::InvalidAction)
        );
    }

    #[test]
    fn test_captcha_error_codes() {
        struct TestCase {
            name: &'static str,
            input: &'static str,
            expected: CaptchaErrorCode,
        }
        let client = CaptchaClient::default();

        let test_cases = [
            TestCase {
                name: "Test error code missing-input-secret",
                input: r#"{
                    "success": false,
                    "error-codes": ["missing-input-secret"]
                }"#,
                expected: CaptchaErrorCode::MissingInputSecret,
            },
            TestCase {
                name: "Test error code invalid-input-secret",
                input: r#"{
                    "success": false,
                    "error-codes": ["invalid-input-secret"]
                }"#,
                expected: CaptchaErrorCode::InvalidInputSecret,
            },
            TestCase {
                name: "Test error code missing-input-response",
                input: r#"{
                    "success": false,
                    "error-codes": ["missing-input-response"]
                }"#,
                expected: CaptchaErrorCode::MissingInputResponse,
            },
            TestCase {
                name: "Test error code invalid-input-response",
                input: r#"{
                    "success": false,
                    "error-codes": ["invalid-input-response"]
                }"#,
                expected: CaptchaErrorCode::InvalidInputResponse,
            },
            TestCase {
                name: "Test error code bad-request",
                input: r#"{
                    "success": false,
                    "error-codes": ["bad-request"]
                }"#,
                expected: CaptchaErrorCode::BadRequest,
            },
            TestCase {
                name: "Test error code timeout-or-duplicate",
                input: r#"{
                    "success": false,
                    "error-codes": ["timeout-or-duplicate"]
                }"#,
                expected: CaptchaErrorCode::TimeoutOrDuplicate,
            },
            TestCase {
                name: "Test error code unknown",
                input: r#"{
                    "success": false,
                    "error-codes": ["any_unknown_error"]
                }"#,
                expected: CaptchaErrorCode::Unknown,
            },
        ];

        for TestCase {
            name,
            input,
            expected,
        } in test_cases
        {
            let result = client.parse_captcha_response(input.to_owned());
            assert_matches!(result, Err(CaptchaError::ResponseError(err_code)) if err_code == expected, "Test case `{name}` failed with result {result:?}. Expected {expected:?}");
        }
    }

    impl Default for CaptchaClient {
        fn default() -> Self {
            Self::new(CaptchaConfig {
                threshold: 0.5,
                action: "homepage".to_owned(),
                secret: String::default(),
            })
            .unwrap()
        }
    }
}

'''
'''--- src/config.rs ---
use crate::captcha::CaptchaConfig;
use crate::signer::SignerConfig;
use crate::verification_provider::VerificationProviderConfig;
use config::{self, ConfigError};
use near_sdk::serde::Deserialize;

#[derive(Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde", rename_all = "camelCase")]
pub struct AppConfig {
    pub listen_address: String,
    pub verification_provider: VerificationProviderConfig,
    pub signer: SignerConfig,
    pub captcha: CaptchaConfig,
    #[serde(default = "default_allow_named_sub_accounts")]
    pub allow_named_sub_accounts: bool,
}

pub fn load_config() -> Result<AppConfig, ConfigError> {
    config::Config::builder()
        // Load default set of configuration
        .add_source(config::File::with_name("config/default"))
        // Overlay configuration with local configuration
        .add_source(config::File::with_name("config/local").required(false))
        .build()
        .and_then(|config| config.try_deserialize())
}

fn default_allow_named_sub_accounts() -> bool {
    false
}

'''
'''--- src/error.rs ---
use axum::{http::StatusCode, response::IntoResponse, Json};
use near_sdk::serde_json::json;

#[derive(thiserror::Error, Debug)]
pub enum AppError {
    #[error("Signing error")]
    SigningError,
    #[error("User face verification were rejected")]
    FaceVerificationRejected,
    #[error("User face verification is missed")]
    FaceVerificationMissed,
    #[error("Http request timed out: {0}")]
    TimeoutError(String),
    #[error("Http request failed: {0}")]
    ReqwestError(reqwest::Error),
    #[error("JSON parse failure: {0}")]
    ParseError(#[from] near_sdk::serde_json::Error),
    #[error("Generic error: {0}")]
    Generic(String),
    #[error("Suspicious user didn't pass captcha verification")]
    SuspiciousUser,
    #[error("Not allowed named sub-account {0}")]
    NotAllowedNamedSubAccount(near_sdk::AccountId),
    #[error("Captcha error: {0}")]
    CaptchaError(#[from] crate::captcha::CaptchaError),
}

impl IntoResponse for AppError {
    fn into_response(self) -> axum::response::Response {
        let (status, err_msg) = match self {
            Self::SigningError | Self::ParseError(_) => {
                (StatusCode::INTERNAL_SERVER_ERROR, "Internal server error")
            }
            Self::FaceVerificationRejected => {
                (StatusCode::UNAUTHORIZED, "Face verification were rejected")
            }
            Self::FaceVerificationMissed => (
                StatusCode::UNAUTHORIZED,
                "Face verification weren't completed",
            ),
            Self::ReqwestError(_) | Self::Generic(_) | Self::TimeoutError(_) => {
                (StatusCode::UNAUTHORIZED, "User verification failure")
            }
            Self::CaptchaError(_) => (StatusCode::UNAUTHORIZED, "Captcha error"),
            Self::SuspiciousUser => (StatusCode::UNAUTHORIZED, "Suspicious user"),
            Self::NotAllowedNamedSubAccount(_) => (
                StatusCode::UNAUTHORIZED,
                "Allowed only implicit account id or named sub-account from .near root account",
            ),
        };
        (status, Json(json!({ "error": err_msg }))).into_response()
    }
}

impl From<String> for AppError {
    fn from(error_str: String) -> Self {
        Self::Generic(error_str)
    }
}

impl From<reqwest::Error> for AppError {
    fn from(e: reqwest::Error) -> Self {
        if e.is_timeout() {
            Self::TimeoutError(e.to_string())
        } else {
            Self::ReqwestError(e)
        }
    }
}

'''
'''--- src/main.rs ---
mod captcha;
mod config;
mod error;
mod signer;
mod utils;
mod verification_provider;

use axum::{extract::State, routing::post, Json, Router};
use captcha::CaptchaClient;
use chrono::Utc;
use error::AppError;
use near_crypto::Signature;
use near_sdk::base64::encode;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use tower_http::cors::CorsLayer;
use uuid::Uuid;

use crate::config::AppConfig;
use utils::{enable_logging, is_allowed_named_sub_account, set_heavy_panic};
use verification_provider::{
    FractalClient, FractalTokenKind, FractalUser, OAuthToken, VerificationStatus,
};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Exit on any panic in any async task
    set_heavy_panic();

    // Try load environment variables from `.env` if provided
    dotenv::dotenv().ok();

    enable_logging();
    let config = config::load_config()?;

    // Log a base64 encoded ed25519 public key to be used in smart contract for signature verification
    tracing::info!(
        "ED25519 public key (base64 encoded): {}",
        encode(
            config
                .signer
                .credentials
                .signing_key
                .public_key()
                .unwrap_as_ed25519()
                .as_ref()
        )
    );

    let addr = config
        .listen_address
        .parse()
        .expect("Can't parse socket address");

    let state = AppState::new(config.clone())?;

    let app = Router::new()
        .route("/verify", post(verify))
        .layer(CorsLayer::permissive())
        .with_state(state);

    tracing::debug!("Server listening on {}", addr);

    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await?;

    Ok(())
}

#[derive(Clone)]
pub struct AppState {
    pub config: AppConfig,
    pub client: FractalClient,
    pub captcha: CaptchaClient,
}

impl AppState {
    pub fn new(config: AppConfig) -> Result<Self, AppError> {
        Ok(Self {
            captcha: CaptchaClient::new(config.captcha.clone())?,
            client: FractalClient::create(config.verification_provider.clone())?,
            config,
        })
    }
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct VerificationReq {
    pub claimer: AccountId,
    #[serde(flatten)]
    pub fractal_token: FractalTokenKind,
}

#[derive(BorshSerialize, BorshDeserialize, Debug)]
pub struct VerifiedAccountToken {
    pub claimer: AccountId,
    pub ext_account: ExternalAccountId,
    pub timestamp: u64,
    pub verified_kyc: bool,
}

/// External account id represented as hexadecimal string
#[derive(BorshSerialize, BorshDeserialize, Debug, Clone, PartialEq)]
pub struct ExternalAccountId(String);

impl std::fmt::Display for ExternalAccountId {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl AsRef<String> for ExternalAccountId {
    fn as_ref(&self) -> &String {
        &self.0
    }
}

impl From<Uuid> for ExternalAccountId {
    fn from(value: Uuid) -> Self {
        let mut buf = [0u8; uuid::fmt::Simple::LENGTH];
        Self(value.as_simple().encode_lower(&mut buf).to_owned())
    }
}

#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde", untagged)]
pub enum VerificationResponse {
    Approved(ApprovedResponse),
    Pending(PendingResponse),
}

/// Signed response for a fractal user with approved face verification
#[derive(Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct ApprovedResponse {
    #[serde(rename = "m")]
    pub message: String,
    #[serde(rename = "sig")]
    pub signature_ed25519: String,
    #[serde(rename = "kyc")]
    pub kyc_status: VerificationStatus,
}

/// Response for a fractal user whos face verification is pending for final decision
#[derive(Serialize, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct PendingResponse {
    pub token: OAuthToken,
}

pub async fn verify(
    State(state): State<AppState>,
    Json(req): Json<VerificationReq>,
) -> Result<Json<VerificationResponse>, AppError> {
    tracing::debug!("Request: {req:?}");

    if !state.config.allow_named_sub_accounts && !is_allowed_named_sub_account(&req.claimer) {
        return Err(AppError::NotAllowedNamedSubAccount(req.claimer));
    }

    if let Some(captcha_token) = req.fractal_token.captcha() {
        match state.captcha.verify(captcha_token).await {
            Ok(true) => (),
            Ok(false) => return Err(AppError::SuspiciousUser),
            Err(e) => {
                tracing::error!(
                    "Captcha verification failure for an account `{:?}`. Error: {e:?}",
                    req.claimer
                );
                return Err(AppError::from(e));
            }
        };
    }

    let user = state.client.fetch_user(req.fractal_token).await?;

    let res = match user.fv_status {
        VerificationStatus::Approved => create_approved_response(&state.config, req.claimer, user),
        VerificationStatus::Pending => Ok(VerificationResponse::Pending(PendingResponse {
            token: user.token,
        })),
        VerificationStatus::Rejected => Err(AppError::FaceVerificationRejected),
        VerificationStatus::Unavailable => Err(AppError::FaceVerificationMissed),
    };

    tracing::debug!("Response: {res:?}");

    res.map(Json)
}

/// Creates signed json response for fractal user with approved face verification
fn create_approved_response(
    config: &AppConfig,
    claimer: AccountId,
    user: FractalUser,
) -> Result<VerificationResponse, AppError> {
    let credentials = &config.signer.credentials;
    let raw_message = VerifiedAccountToken {
        claimer,
        ext_account: user.user_id,
        timestamp: Utc::now().timestamp() as u64,
        verified_kyc: user.kyc_status == VerificationStatus::Approved,
    }
    .try_to_vec()
    .map_err(|_| AppError::SigningError)?;
    let signature = credentials.signing_key.sign(&raw_message);

    if !signature.verify(&raw_message, &credentials.signing_key.public_key()) {
        return Err(AppError::SigningError);
    }

    let raw_signature_ed25519 = match signature {
        Signature::ED25519(signature) => signature.to_bytes(),
        _ => return Err(AppError::SigningError),
    };

    let message = encode(&raw_message);
    let signature_ed25519 = encode(raw_signature_ed25519);

    Ok(VerificationResponse::Approved(ApprovedResponse {
        message,
        signature_ed25519,
        kyc_status: user.kyc_status,
    }))
}

#[cfg(test)]
mod tests {
    use crate::signer::{SignerConfig, SignerCredentials};
    use crate::*;
    use assert_matches::assert_matches;
    use chrono::Utc;
    use near_crypto::{KeyType, Signature};
    use near_sdk::base64::decode;
    use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
    use near_sdk::AccountId;
    use std::str::FromStr;
    use uuid::Uuid;

    #[test]
    fn test_approved_account_response_no_kyc() {
        let config = gen_app_config(false);

        let claimer = AccountId::new_unchecked("test.near".to_owned());
        let verified_user = FractalUser {
            user_id: Uuid::default().into(),
            token: OAuthToken {
                access_token: "some_auth_token".to_owned(),
                refresh_token: "some_refresh_token".to_owned(),
                expires_at: Utc::now(),
            },
            fv_status: VerificationStatus::Approved,
            kyc_status: VerificationStatus::Unavailable,
        };
        let approved_res =
            match create_approved_response(&config, claimer.clone(), verified_user.clone()) {
                Ok(VerificationResponse::Approved(res)) => res,
                _ => panic!("Not an approved verification"),
            };

        let credentials = &config.signer.credentials;

        let decoded_bytes = decode(&approved_res.message).unwrap();

        assert!(Signature::from_parts(
            KeyType::ED25519,
            &decode(&approved_res.signature_ed25519).unwrap()
        )
        .unwrap()
        .verify(&decoded_bytes, &credentials.signing_key.public_key()));

        let decoded_msg = VerifiedAccountToken::try_from_slice(&decoded_bytes).unwrap();

        assert_matches!(decoded_msg, VerifiedAccountToken {
            claimer: claimer_res,
            ext_account: ext_account_res,
            timestamp: _,
            verified_kyc: false,
        } if claimer_res == claimer && ext_account_res == verified_user.user_id);
    }

    #[test]
    fn test_approved_account_response_with_kyc() {
        let config = gen_app_config(false);

        let claimer = AccountId::new_unchecked("test.near".to_owned());
        let verified_user = FractalUser {
            user_id: Uuid::default().into(),
            token: OAuthToken {
                access_token: "some_auth_token".to_owned(),
                refresh_token: "some_refresh_token".to_owned(),
                expires_at: Utc::now(),
            },
            fv_status: VerificationStatus::Approved,
            kyc_status: VerificationStatus::Approved,
        };

        let approved_res =
            match create_approved_response(&config, claimer.clone(), verified_user.clone()) {
                Ok(VerificationResponse::Approved(res)) => res,
                _ => panic!("Not an approved verification"),
            };

        let credentials = &config.signer.credentials;

        let decoded_bytes = decode(&approved_res.message).unwrap();

        assert!(Signature::from_parts(
            KeyType::ED25519,
            &decode(&approved_res.signature_ed25519).unwrap()
        )
        .unwrap()
        .verify(&decoded_bytes, &credentials.signing_key.public_key()));

        let decoded_msg = VerifiedAccountToken::try_from_slice(&decoded_bytes).unwrap();

        assert_matches!(decoded_msg, VerifiedAccountToken {
            claimer: claimer_res,
            ext_account: ext_account_res,
            timestamp: _,
            verified_kyc: true,
        } if claimer_res == claimer && ext_account_res == verified_user.user_id);
    }

    #[test]
    fn test_account_id_uuid_borsh_serde() {
        let serialized = VerifiedAccountToken {
            claimer: AccountId::new_unchecked("test.near".to_owned()),
            ext_account: Uuid::from_str("f20181ba-fc0c-11ed-be56-0242ac120002")
                .unwrap()
                .into(),
            timestamp: Utc::now().timestamp() as u64,
            verified_kyc: true,
        }
        .try_to_vec()
        .unwrap();

        assert_eq!(
            VerifiedAccountToken::try_from_slice(serialized.as_slice())
                .unwrap()
                .ext_account
                .0,
            "f20181bafc0c11edbe560242ac120002"
        );
    }

    fn gen_app_config(allow_named_sub_accounts: bool) -> AppConfig {
        let signing_key = near_crypto::SecretKey::from_random(near_crypto::KeyType::ED25519);

        AppConfig {
            signer: SignerConfig {
                credentials: SignerCredentials { signing_key },
            },
            listen_address: "0.0.0.0:8080".to_owned(),
            verification_provider: Default::default(),
            captcha: Default::default(),
            allow_named_sub_accounts,
        }
    }
}

'''
'''--- src/signer.rs ---
use near_crypto::SecretKey;
use near_sdk::serde::de::{self, Error};
use near_sdk::serde::Deserialize;
use std::{env::VarError, str::FromStr};

#[derive(Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde", rename_all = "camelCase")]
pub struct SignerConfig {
    pub credentials: SignerCredentials,
}

#[derive(Debug, Clone)]
pub struct SignerCredentials {
    pub signing_key: SecretKey,
}

impl<'de> Deserialize<'de> for SignerCredentials {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: de::Deserializer<'de>,
    {
        let properties: std::collections::HashMap<String, String> =
            Deserialize::deserialize(deserializer).unwrap_or_default();

        let raw_signing_key = match std::env::var("SIGNING_KEY") {
          Err(VarError::NotPresent) => properties.get("signingKey").cloned(),
          Err(VarError::NotUnicode(invalid_data)) => {
              return Err(de::Error::custom(format!("Invalid SIGNING_KEY {:?}", invalid_data)))
          },
          Ok(value) => Some(value),
        }.ok_or_else(|| {
            D::Error::custom("Signing key should be provided either with SIGNING_KEY env variable or within configuration file")
        })?;

        let signing_key = SecretKey::from_str(&raw_signing_key).map_err(|e| {
            de::Error::custom(format!("Signing key deserialization failure. Error {e}"))
        })?;

        if !verify_signing_key(&signing_key) {
            return Err(de::Error::custom("Signing key is incorrect"));
        }

        Ok(Self { signing_key })
    }
}

fn verify_signing_key(signing_key: &SecretKey) -> bool {
    let verification_data = "verify".as_bytes();
    let sig = signing_key.sign(verification_data);
    sig.verify(verification_data, &signing_key.public_key())
}

'''
'''--- src/utils.rs ---
use crate::ExternalAccountId;
use backtrace::Backtrace;
use near_sdk::{
    serde::{de, Deserialize},
    serde_json::Value,
};
use std::str::FromStr;
use std::{panic, thread};
use tracing_subscriber::prelude::*;
use tracing_subscriber::{fmt, EnvFilter, Registry};
use uuid::Uuid;

pub fn set_heavy_panic() {
    panic::set_hook(Box::new(|panic_info| {
        let backtrace = Backtrace::new();

        if let Some(s) = panic_info.payload().downcast_ref::<&str>() {
            log::error!("Panic occurred: {:?}", s);
        }

        // Get code location
        let location = panic_info.location().unwrap();

        // Extract msg
        let msg = match panic_info.payload().downcast_ref::<&'static str>() {
            Some(s) => *s,
            None => match panic_info.payload().downcast_ref::<String>() {
                Some(s) => &s[..],
                None => "Box<Any>",
            },
        };

        let handle = thread::current();
        let thread_name = handle.name().unwrap_or("<unnamed>");

        log::error!(
            "thread '{}' panicked at '{}', {}",
            thread_name,
            location,
            msg
        );

        log::error!("{:?}", backtrace);

        std::process::exit(1)
    }));
}

/// Enables console logging and optionally file logging
pub fn enable_logging() {
    // Setup subscriber to print out logs from tracing
    let subscriber = Registry::default().with(
        fmt::Layer::default()
            // disable colored output
            .with_ansi(false)
            // Write to console
            .with_writer(std::io::stdout)
            // Filter messages based on RUST_LOG env variable
            .with_filter(EnvFilter::from_default_env()),
    );

    tracing::subscriber::set_global_default(subscriber).unwrap();
}

pub fn de_strings_joined_by_plus<'de, D, T>(deserializer: D) -> Result<Vec<T>, D::Error>
where
    D: de::Deserializer<'de>,
    T: Deserialize<'de>,
{
    let levels = String::deserialize(deserializer)?
        .split('+')
        .filter_map(|level| T::deserialize(Value::from(level)).ok())
        .collect();

    Ok(levels)
}

pub fn de_external_account_id_from_uuid<'de, D>(
    deserializer: D,
) -> Result<ExternalAccountId, D::Error>
where
    D: de::Deserializer<'de>,
{
    let uuid = Uuid::from_str(&String::deserialize(deserializer)?).map_err(|e| {
        de::Error::custom(format!(
            "Unable to deserialize external account id from uuid. Error: {e:?}"
        ))
    })?;

    Ok(uuid.into())
}

/// Checks if the provided named near account is an allowed sub-account
///
/// Requires to be an implicit account id or named sub-account from .near root
pub fn is_allowed_named_sub_account(account_id: &near_sdk::AccountId) -> bool {
    let number_of_dots = account_id.as_str().chars().fold(0, |mut acc, c| {
        if c == '.' {
            acc += 1;
        }
        acc
    });

    number_of_dots <= 1
}

#[cfg(test)]
mod tests {
    use super::is_allowed_named_sub_account;
    use near_sdk::AccountId;

    #[test]
    fn test_is_allowed_named_sub_account() {
        assert!(is_allowed_named_sub_account(&AccountId::new_unchecked(
            "28cda90838b6fa11b629747cf8173edc2d5bc010d1300d544f39cc19d4d69edb".to_owned()
        )));
        assert!(is_allowed_named_sub_account(&AccountId::new_unchecked(
            "test.near".to_owned()
        )));
        assert!(!is_allowed_named_sub_account(&AccountId::new_unchecked(
            "test1.test.near".to_owned()
        )));
    }
}

'''
'''--- src/verification_provider.rs ---
use crate::{utils, AppError, ExternalAccountId};
use chrono::{DateTime, Duration, TimeZone, Utc};
use near_sdk::{
    base64::{decode, encode},
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{
        de::{self, Deserializer},
        ser::{self, Serializer},
        Deserialize, Serialize,
    },
    serde_json,
};
use reqwest::Client;

/// Minimum time required before oauth2 token expires in minutes
static OAUTH_TOKEN_MINIMUM_LIFETIME: i64 = 5;

#[derive(Deserialize, Debug, Default, Clone)]
#[serde(crate = "near_sdk::serde", rename_all = "camelCase")]
pub struct VerificationProviderConfig {
    pub request_token_url: String,
    pub request_user_url: String,
    pub client_id: String,
    pub client_secret: String,
}

#[derive(Serialize, Deserialize, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde", untagged)]
pub enum FractalTokenKind {
    AuthorizationCode {
        code: String,
        captcha: String,
        redirect_uri: String,
    },
    OAuth {
        token: OAuthToken,
        redirect_uri: String,
    },
}

#[derive(Deserialize, Debug, PartialEq, Clone)]
#[serde(crate = "near_sdk::serde", remote = "Self")]
pub struct OAuthToken {
    pub access_token: String,
    pub refresh_token: String,
    pub expires_at: DateTime<Utc>,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct RawFractalToken {
    pub access_token: String,
    pub refresh_token: String,
    pub token_type: String,
    #[serde(flatten)]
    pub lifetime: TokenLifetime,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenLifetime {
    pub expires_in: u64,
    pub created_at: u64,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct RawFractalUser {
    #[serde(deserialize_with = "utils::de_external_account_id_from_uuid")]
    pub uid: ExternalAccountId,
    pub emails: Vec<Email>,
    pub phones: Vec<Phone>,
    pub wallets: Vec<Wallet>,
    pub verification_cases: Vec<VerificationCase>,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Email {
    pub address: String,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Phone {
    pub number: String,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Wallet {
    pub id: String,
    pub address: String,
    pub currency: String,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct VerificationCase {
    pub id: String,
    pub created_at: DateTime<Utc>,
    pub updated_at: DateTime<Utc>,
    #[serde(deserialize_with = "utils::de_strings_joined_by_plus")]
    pub level: Vec<VerificationLevel>,
    pub status: CaseStatus,
    pub credential: CredentialStatus,
    pub details: VerificationDetails,
}

#[derive(Deserialize, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde", rename_all = "lowercase")]
pub enum VerificationLevel {
    /// Face Verification
    Uniqueness,
    /// KYC (always comes with Liveness)
    Basic,
    Plus,
    Liveness,
    Selfie,
    Sow,
    Telegram,
    Twitter,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde", rename_all = "lowercase")]
pub enum CaseStatus {
    Pending,
    Contacted,
    Done,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde", rename_all = "lowercase")]
pub enum CredentialStatus {
    Pending,
    Approved,
    Rejected,
}

#[derive(Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct VerificationDetails {
    pub liveness: bool,
}

#[derive(Clone, Debug)]
pub struct FractalClient {
    inner_client: Client,
    config: VerificationProviderConfig,
}

#[derive(Debug, PartialEq, Copy, Clone, Serialize)]
#[serde(crate = "near_sdk::serde", rename_all = "lowercase")]
pub enum VerificationStatus {
    Unavailable,
    Pending,
    Approved,
    Rejected,
}

#[derive(Debug, Clone)]
pub struct FractalUser {
    pub user_id: ExternalAccountId,
    pub token: OAuthToken,
    pub fv_status: VerificationStatus,
    pub kyc_status: VerificationStatus,
}

impl FractalClient {
    pub fn create(config: VerificationProviderConfig) -> Result<Self, AppError> {
        let inner_client = Client::builder().pool_max_idle_per_host(0).build()?;

        Ok(Self {
            inner_client,
            config,
        })
    }

    pub async fn fetch_user(
        &self,
        fractal_token: FractalTokenKind,
    ) -> Result<FractalUser, AppError> {
        let mut oauth_token = match fractal_token {
            FractalTokenKind::AuthorizationCode {
                code, redirect_uri, ..
            } => self.acquire_oauth_token(&code, &redirect_uri).await?,
            FractalTokenKind::OAuth { token, .. } => token,
        };

        if oauth_token.requires_refresh() {
            oauth_token = self.refresh_oauth_token(oauth_token).await?;
        }

        tracing::trace!("Acquired user token: {oauth_token:?}");

        let fetched_res = self
            .inner_client
            .get(&self.config.request_user_url)
            .bearer_auth(&oauth_token.access_token)
            .send()
            .await?
            .json::<RawFractalUser>()
            .await
            .map_err(AppError::from);

        match fetched_res {
            Ok(mut user) => {
                tracing::debug!("Fetched raw user: {user:?}");

                Ok(FractalUser {
                    fv_status: user.get_status(&[VerificationLevel::Uniqueness]),
                    kyc_status: user
                        .get_status(&[VerificationLevel::Basic, VerificationLevel::Liveness]),
                    user_id: user.uid,
                    token: oauth_token,
                })
            }
            Err(e) => {
                tracing::error!("Unable to fetch user. Error: {:?}", e);
                Err(e)
            }
        }
    }

    async fn acquire_oauth_token(
        &self,
        code: &str,
        redirect_uri: &str,
    ) -> Result<OAuthToken, AppError> {
        let params: [(&str, &str); 5] = [
            ("client_id", &self.config.client_id),
            ("client_secret", &self.config.client_secret),
            ("code", code),
            ("grant_type", "authorization_code"),
            ("redirect_uri", redirect_uri),
        ];

        let data = self
            .inner_client
            .post(&self.config.request_token_url)
            .form(&params)
            .send()
            .await?
            .text()
            .await?;

        tracing::trace!("Acquired raw fractal token response: {data}");

        match serde_json::from_str::<RawFractalToken>(&data) {
            Ok(token) if token.token_type.as_str() == "Bearer" => Ok(OAuthToken::from(token)),
            Ok(token) => Err(format!("Unsupported token type {:?}", token).into()),
            Err(_) => Err(format!("Failed to parse token response {:?}", data).into()),
        }
    }

    async fn refresh_oauth_token(&self, oauth_token: OAuthToken) -> Result<OAuthToken, AppError> {
        tracing::trace!("Refresh for OAuthToken: {oauth_token:?}");

        let params: [(&str, &str); 4] = [
            ("client_id", &self.config.client_id),
            ("client_secret", &self.config.client_secret),
            ("refresh_token", &oauth_token.refresh_token),
            ("grant_type", "refresh_token"),
        ];

        let data = self
            .inner_client
            .post(&self.config.request_token_url)
            .form(&params)
            .send()
            .await?
            .text()
            .await?;

        match serde_json::from_str::<RawFractalToken>(&data) {
            Ok(token) if token.token_type.as_str() == "Bearer" => Ok(OAuthToken::from(token)),
            Ok(token) => Err(format!("Unsupported token type {:?}", token).into()),
            Err(_) => Err(format!("Failed to parse token response {:?}", data).into()),
        }
    }
}

impl RawFractalUser {
    fn get_status(&mut self, levels: &[VerificationLevel]) -> VerificationStatus {
        // Sort by updated_at timestamp, most recent first
        self.verification_cases
            .sort_by(|a, b| b.updated_at.cmp(&a.updated_at));

        let cases_status = self
            .verification_cases
            .iter()
            .filter_map(|case| {
                // Ignore cases other than related to requested levels
                for level in levels {
                    if !case.level.iter().any(|l| l == level) {
                        return None;
                    }
                }

                match case {
                    VerificationCase {
                        credential: CredentialStatus::Approved,
                        details: VerificationDetails { liveness: true },
                        ..
                    } => Some(VerificationStatus::Approved),
                    VerificationCase {
                        credential: CredentialStatus::Pending,
                        details: VerificationDetails { liveness: true },
                        ..
                    } => Some(VerificationStatus::Pending),
                    VerificationCase {
                        credential: CredentialStatus::Rejected,
                        details: VerificationDetails { liveness: true },
                        ..
                    } => Some(VerificationStatus::Rejected),
                    // Ignore verification cases without `liveness: true`
                    _ => None,
                }
            })
            .collect::<Vec<_>>();

        // If user has any approved case
        if cases_status
            .iter()
            .any(|status| status == &VerificationStatus::Approved)
        {
            return VerificationStatus::Approved;
        }

        // Otherwise, check the most recent result
        *cases_status
            .first()
            .unwrap_or(&VerificationStatus::Unavailable)
    }
}

impl<'de> Deserialize<'de> for OAuthToken {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        let encoded: String = Deserialize::deserialize(deserializer)?;

        let raw = decode(encoded).map_err(|e| {
            de::Error::custom(format!(
                "Failed to deserialize base64 encoded oauth token {e:?}"
            ))
        })?;

        OAuthToken::try_from_slice(&raw).map_err(|e| {
            de::Error::custom(format!(
                "Failed to deserialize borsh serialized oauth token {e:?}"
            ))
        })
    }
}

impl<'a> FractalTokenKind {
    pub fn captcha(&'a self) -> Option<&'a str> {
        match self {
            Self::AuthorizationCode { captcha, .. } => Some(captcha),
            Self::OAuth { .. } => None,
        }
    }
}

impl TokenLifetime {
    pub fn expires_at(&self) -> DateTime<Utc> {
        Utc.timestamp_nanos((self.created_at + self.expires_in) as i64 * 1_000_000_000)
    }
}

impl OAuthToken {
    pub fn requires_refresh(&self) -> bool {
        Utc::now() + Duration::minutes(OAUTH_TOKEN_MINIMUM_LIFETIME) >= self.expires_at
    }
}

impl From<RawFractalToken> for OAuthToken {
    fn from(token: RawFractalToken) -> Self {
        Self {
            access_token: token.access_token,
            refresh_token: token.refresh_token,
            expires_at: token.lifetime.expires_at(),
        }
    }
}

impl Serialize for OAuthToken {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        let raw = self
            .try_to_vec()
            .map_err(|e| ser::Error::custom(format!("Failed to serialize oauth token {e:?}")))?;
        let encoded = encode(raw);

        serializer.serialize_str(&encoded)
    }
}

impl BorshDeserialize for OAuthToken {
    fn deserialize(buf: &mut &[u8]) -> std::io::Result<Self> {
        let access_token = BorshDeserialize::deserialize(buf)?;
        let refresh_token = BorshDeserialize::deserialize(buf)?;
        let ts = BorshDeserialize::deserialize(buf)?;

        Ok(OAuthToken {
            access_token,
            refresh_token,
            expires_at: Utc.timestamp_nanos(ts),
        })
    }
}

impl BorshSerialize for OAuthToken {
    fn serialize<W: borsh::maybestd::io::Write>(
        &self,
        writer: &mut W,
    ) -> borsh::maybestd::io::Result<()> {
        let ts = self.expires_at.timestamp_nanos();
        BorshSerialize::serialize(&self.access_token, writer)?;
        BorshSerialize::serialize(&self.refresh_token, writer)?;
        BorshSerialize::serialize(&ts, writer)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use assert_matches::assert_matches;
    use chrono::{DateTime, Duration, TimeZone, Utc};
    use near_sdk::serde_json;

    #[test]
    fn test_oauth_token() {
        let expires_in = 7200;
        let now_secs = Utc::now().timestamp();
        let created_at = now_secs - expires_in; // let it expire now
        let json = format!(
            r#"{{
            "access_token": "7rgojfemuk-aq8RcA7xWxJQKv6Ux0VWJ1DQtU6178B8",
            "token_type": "bearer",
            "expires_in": {expires_in},
            "refresh_token": "thPSSHGnk3NGU5vV4V_g-Qrs47RibO9KEEhfKYEgJOw",
            "scope": "uid:read email:read",
            "created_at": {created_at}
        }}"#
        );

        let raw_token = serde_json::from_str::<RawFractalToken>(&json).unwrap();
        let mut oauth_token = OAuthToken::from(raw_token);

        assert_eq!(
            oauth_token,
            OAuthToken {
                access_token: "7rgojfemuk-aq8RcA7xWxJQKv6Ux0VWJ1DQtU6178B8".to_owned(),
                refresh_token: "thPSSHGnk3NGU5vV4V_g-Qrs47RibO9KEEhfKYEgJOw".to_owned(),
                expires_at: Utc.timestamp_opt(now_secs, 0).unwrap(),
            }
        );

        assert!(oauth_token.requires_refresh());
        oauth_token.expires_at = Utc::now() + Duration::days(1);
        assert!(!oauth_token.requires_refresh());
    }

    #[test]
    fn test_oauth_token_serde() {
        let token = FractalTokenKind::OAuth {
            redirect_uri: "https://some_url".to_owned(),
            token: OAuthToken {
                access_token: "some_auth_token".to_owned(),
                refresh_token: "some_refresh_token".to_owned(),
                expires_at: Utc::now(),
            },
        };
        let json = serde_json::to_string(&token).unwrap();
        let deserialized = serde_json::from_str::<FractalTokenKind>(&json).unwrap();
        assert_eq!(deserialized, token);
    }

    #[test]
    fn test_user_verify_uniqueness() {
        struct TestCase {
            name: &'static str,
            input: RawFractalUser,
            expected: VerificationStatus,
        }

        let test_cases = [
            TestCase {
                name: "Verify uniqueness success (single case)",
                input: gen_user(vec![
                    // finished & approved case
                    gen_verification_case(
                        Utc::now(),
                        Utc::now(),
                        VerificationLevelState::Uniqueness(
                            CaseStatus::Done,
                            CredentialStatus::Approved,
                        ),
                        true,
                    ),
                ]),
                expected: VerificationStatus::Approved,
            },
            TestCase {
                name: "Verify uniqueness success (multiple cases)",
                input: gen_user(vec![
                    // not finished case
                    gen_verification_case(
                        Utc::now() - Duration::days(2),
                        Utc::now() - Duration::days(1),
                        VerificationLevelState::Uniqueness(
                            CaseStatus::Contacted,
                            CredentialStatus::Pending,
                        ),
                        true,
                    ),
                    // finished & approved case
                    gen_verification_case(
                        Utc::now() - Duration::days(3),
                        Utc::now(),
                        VerificationLevelState::Uniqueness(
                            CaseStatus::Done,
                            CredentialStatus::Approved,
                        ),
                        true,
                    ),
                ]),
                expected: VerificationStatus::Approved,
            },
            TestCase {
                name: "Verify uniqueness failure (single case)",
                input: gen_user(vec![
                    // rejected case
                    gen_verification_case(
                        Utc::now(),
                        Utc::now(),
                        VerificationLevelState::Uniqueness(
                            CaseStatus::Done,
                            CredentialStatus::Rejected,
                        ),
                        true,
                    ),
                ]),
                expected: VerificationStatus::Rejected,
            },
            TestCase {
                name: "Verify uniqueness failure (multiple cases)",
                input: gen_user(vec![
                    // finished & rejected case
                    gen_verification_case(
                        Utc::now() - Duration::days(2),
                        Utc::now() - Duration::days(1),
                        VerificationLevelState::Uniqueness(
                            CaseStatus::Done,
                            CredentialStatus::Rejected,
                        ),
                        true,
                    ),
                    // not finished case
                    gen_verification_case(
                        Utc::now() - Duration::days(3),
                        Utc::now(),
                        VerificationLevelState::Uniqueness(
                            CaseStatus::Pending,
                            CredentialStatus::Pending,
                        ),
                        true,
                    ),
                ]),
                expected: VerificationStatus::Pending,
            },
            TestCase {
                name: "Verify uniqueness failure (w/o liveness)",
                input: gen_user(vec![
                    // finished without liveness
                    gen_verification_case(
                        Utc::now(),
                        Utc::now(),
                        VerificationLevelState::Uniqueness(
                            CaseStatus::Done,
                            CredentialStatus::Approved,
                        ),
                        false,
                    ),
                ]),
                expected: VerificationStatus::Unavailable,
            },
            TestCase {
                name: "Verify uniqueness failure (no cases)",
                input: gen_user(vec![]),
                expected: VerificationStatus::Unavailable,
            },
        ];

        for TestCase {
            name,
            mut input,
            expected,
        } in test_cases
        {
            let result = input.get_status(&[VerificationLevel::Uniqueness]);
            assert_eq!(
                result, expected,
                "Test case `{name}` failed with result {result:?}. Expected {expected:?}"
            );
        }
    }

    #[test]
    fn test_user_get_kyc_status() {
        struct TestCase {
            name: &'static str,
            input: RawFractalUser,
            expected: VerificationStatus,
        }

        let test_cases = [
            TestCase {
                name: "Verify KYC approved (single case)",
                input: gen_user(vec![
                    // approved case
                    gen_verification_case(
                        Utc::now(),
                        Utc::now(),
                        VerificationLevelState::Kyc(CaseStatus::Done, CredentialStatus::Approved),
                        true,
                    ),
                ]),
                expected: VerificationStatus::Approved,
            },
            TestCase {
                name: "Verify KYC approved (multiple cases, recently approved)",
                input: gen_user(vec![
                    // rejected case
                    gen_verification_case(
                        Utc::now() - Duration::days(2),
                        Utc::now() - Duration::days(1),
                        VerificationLevelState::Kyc(CaseStatus::Done, CredentialStatus::Rejected),
                        true,
                    ),
                    // approved case
                    gen_verification_case(
                        Utc::now() - Duration::days(3),
                        Utc::now(),
                        VerificationLevelState::Kyc(CaseStatus::Done, CredentialStatus::Approved),
                        true,
                    ),
                ]),
                expected: VerificationStatus::Approved,
            },
            TestCase {
                name: "Verify KYC pending (single case)",
                input: gen_user(vec![
                    // pending case
                    gen_verification_case(
                        Utc::now(),
                        Utc::now(),
                        VerificationLevelState::Kyc(CaseStatus::Pending, CredentialStatus::Pending),
                        true,
                    ),
                ]),
                expected: VerificationStatus::Pending,
            },
            TestCase {
                name: "Verify KYC pending (multiple cases, previously rejected)",
                input: gen_user(vec![
                    // rejected case
                    gen_verification_case(
                        Utc::now() - Duration::days(2),
                        Utc::now() - Duration::days(1),
                        VerificationLevelState::Kyc(CaseStatus::Done, CredentialStatus::Rejected),
                        true,
                    ),
                    // pending case
                    gen_verification_case(
                        Utc::now() - Duration::days(3),
                        Utc::now(),
                        VerificationLevelState::Kyc(
                            CaseStatus::Contacted,
                            CredentialStatus::Pending,
                        ),
                        true,
                    ),
                ]),
                expected: VerificationStatus::Pending,
            },
            TestCase {
                name: "Verify KYC unavailable (no cases)",
                input: gen_user(vec![]),
                expected: VerificationStatus::Unavailable,
            },
            TestCase {
                name: "Verify KYC unavailable (w/o liveness)",
                input: gen_user(vec![
                    // approved case without liveness
                    gen_verification_case(
                        Utc::now(),
                        Utc::now(),
                        VerificationLevelState::Kyc(CaseStatus::Done, CredentialStatus::Approved),
                        false,
                    ),
                ]),
                expected: VerificationStatus::Unavailable,
            },
            TestCase {
                name: "Verify KYC rejected (single case)",
                input: gen_user(vec![
                    // rejected case
                    gen_verification_case(
                        Utc::now(),
                        Utc::now(),
                        VerificationLevelState::Kyc(CaseStatus::Done, CredentialStatus::Rejected),
                        true,
                    ),
                ]),
                expected: VerificationStatus::Rejected,
            },
            TestCase {
                name: "Verify KYC rejected (multiple cases)",
                input: gen_user(vec![
                    // rejected case
                    gen_verification_case(
                        Utc::now() - Duration::days(2),
                        Utc::now() - Duration::days(1),
                        VerificationLevelState::Kyc(CaseStatus::Done, CredentialStatus::Rejected),
                        true,
                    ),
                    // pending case
                    gen_verification_case(
                        Utc::now() - Duration::days(3),
                        Utc::now(),
                        VerificationLevelState::Kyc(CaseStatus::Done, CredentialStatus::Rejected),
                        true,
                    ),
                ]),
                expected: VerificationStatus::Rejected,
            },
        ];

        for TestCase {
            name,
            mut input,
            expected,
        } in test_cases
        {
            let result = input.get_status(&[VerificationLevel::Basic, VerificationLevel::Liveness]);
            assert_eq!(
                result, expected,
                "Test case `{name}` failed with result {result:?}. Expected {expected:?}"
            );
        }
    }

    #[test]
    fn test_parse_user() {
        let user_json = r#"{
            "emails": [
              {
                "address": "test@abc.net"
              }
            ],
            "institution": null,
            "person": {
              "identification_document_front_file": "https://some_url",
              "liveness": true,
              "liveness_audit_best_file": "https://some_url",
              "liveness_audit_least_similar_file": "https://some_url",
              "liveness_audit_open_eyes_file": "https://some_url",
              "liveness_audit_quality1_file": "https://some_url",
              "liveness_audit_quality2_file": "https://some_url",
              "liveness_audit_quality3_file": "https://some_url"
            },
            "phones": [],
            "uid": "de223722-fe21-11ed-be56-0242ac120002",
            "verification_cases": [
              {
                "created_at": "2023-05-19 21:57:42 UTC",
                "credential": "approved",
                "details": {
                  "liveness": true,
                  "liveness_audit_best_file": "https://some_url",
                  "liveness_audit_least_similar_file": "https://some_url",
                  "liveness_audit_open_eyes_file": "https://some_url",
                  "liveness_audit_quality1_file": "https://some_url",
                  "liveness_audit_quality2_file": "https://some_url",
                  "liveness_audit_quality3_file": "https://some_url",
                  "identification_document_front_file": "https://some_url"
                },
                "id": "07f10ea2-fe22-11ed-be56-0242ac120002",
                "journey_completed": true,
                "level": "basic+liveness",
                "status": "done",
                "updated_at": "2023-05-24 19:59:19 UTC"
              },
              {
                "created_at": "2023-05-19 22:08:09 UTC",
                "credential": "approved",
                "details": {
                  "identification_document_front_file": null,
                  "liveness_audit_quality2_file": "https://some_url",
                  "liveness_audit_quality3_file": "https://some_url",
                  "liveness": true,
                  "liveness_audit_best_file": "https://some_url",
                  "liveness_audit_least_similar_file": "https://some_url",
                  "liveness_audit_open_eyes_file": "https://some_url",
                  "liveness_audit_quality1_file": "https://some_url"
                },
                "id": "37c01d4e-fe22-11ed-be56-0242ac120002",
                "journey_completed": true,
                "level": "uniqueness",
                "status": "done",
                "updated_at": "2023-05-19 22:09:23 UTC"
              }
            ],
            "wallets": []
        }"#;

        let parsed = serde_json::from_str::<RawFractalUser>(user_json);

        assert_matches!(parsed.as_ref(), Ok(RawFractalUser {
            uid,
            ..
        }) if uid.as_ref() == "de223722fe2111edbe560242ac120002");

        assert_matches!(parsed.unwrap().verification_cases.as_slice(), [
            VerificationCase {
                id: id0,
                credential: CredentialStatus::Approved,
                status: CaseStatus::Done,
                level: levels0,
                created_at: created_at0,
                updated_at: updated_at0,
                ..
            },
            VerificationCase {
                id: id1,
                credential: CredentialStatus::Approved,
                status: CaseStatus::Done,
                level: levels1,
                ..
            },
        ] if id0.as_str() == "07f10ea2-fe22-11ed-be56-0242ac120002" && levels0.as_slice() == [VerificationLevel::Basic, VerificationLevel::Liveness] && 
             created_at0.to_string().as_str() == "2023-05-19 21:57:42 UTC" && updated_at0.to_string().as_str() == "2023-05-24 19:59:19 UTC" &&
             id1.as_str() == "37c01d4e-fe22-11ed-be56-0242ac120002" && levels1.as_slice() == [VerificationLevel::Uniqueness]);
    }

    enum VerificationLevelState {
        Uniqueness(CaseStatus, CredentialStatus),
        Kyc(CaseStatus, CredentialStatus),
    }

    fn gen_verification_case(
        created_at: DateTime<Utc>,
        updated_at: DateTime<Utc>,
        state: VerificationLevelState,
        liveness: bool,
    ) -> VerificationCase {
        let (level, status, credential) = match state {
            VerificationLevelState::Uniqueness(status, credential) => {
                (vec![VerificationLevel::Uniqueness], status, credential)
            }
            VerificationLevelState::Kyc(status, credential) => (
                vec![VerificationLevel::Basic, VerificationLevel::Liveness],
                status,
                credential,
            ),
        };

        VerificationCase {
            id: uuid::Uuid::new_v4().to_string(),
            created_at,
            updated_at,
            level,
            status,
            credential,
            details: VerificationDetails { liveness },
        }
    }

    fn gen_user(verification_cases: Vec<VerificationCase>) -> RawFractalUser {
        RawFractalUser {
            uid: ExternalAccountId::from(uuid::Uuid::new_v4()),
            emails: vec![],
            phones: vec![],
            wallets: vec![],
            verification_cases,
        }
    }
}

'''