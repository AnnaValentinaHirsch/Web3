*GitHub Repository "ilblackdragon/near-contribute"*

'''--- Cargo.toml ---
[workspace]
members = [
  "contract",
  "seed"
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "s"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- README.md ---
# NEAR Contribute

This smart contract serves as an extension to SocialDB to maintain the entity <> contributor relations.
One can relate this to the LinkedIn graph of employment in Web2.

## Project structure

This repository contains multiple key directories, namely:

- **contract:** this is where the smart contract code lives
- **seed:** this is a script for ingesting seed data into the deployed smart contract
- **widgets:** this is where the front-end/BOS widget code lives

## Specification

The `Entity` is the core object, that augments the information in `SocialDB` with the specific context
that this AccountId represents an entity.

`EntityKind` represents what kind of entity this is:
 - Project - A Web3 project, that can exist independently of legal organizations
 - Organization - A legal organization
 - DAO - Something between a project and an organization, managed by people

Methods:

| Function | Description | Permissions |
| - | - | - |
| `set_moderator(moderator_id: AccountId)` | Sets new moderator account | Moderator |
| `set_entity(account_id: AccountId, entity: Entity)` | Sets full information about entity for given account | Moderator |
| `add_entity(account_id: AccountId, kind: EntityKind, start_date: Timestamp)` | Add new entity of given kind (project, DAO, organization) and start date. Automatically adds the creator as contributor will full permissions to edit | Anyone |
| `admin_add_entity(account_id: AccountId, founder_id: AccountId, name: String, kind: EntityKind, start_date: Timestamp)` | Adds a new entity like the previous function, but instead of using the predecessor account as founder, uses `founder_id` | Moderator |
| `get_entities(from: Option<U64>, limit: Option<U64>)` | Fetches all the entities from the state. (Optionaly paginates if params given) | Anyone |
| `get_entity(account_id: AccountId)` | Gets details about a specific entity with a given account ID | Anyone |
| `get_admin_entities(account_id: AccountId)` | Fetches all the entities that a given account ID is admin of | Anyone |
| `check_is_entity(account_id: AccountId)` | Checks if the given account ID has a entity registered to it | Anyone |
| `invite_contributor(entity_id: AccountId, contributor_id: AccountId, description: String, contribution_type: ContributionType, start_date: U64, permissions: HashSet<Permission>)` | Invites a contributor to a entity | Permission::Manager or above |
| `accept_invite(account_id: AccountId)` | Accept the invite for contributing to entity with given account ID | Contributor who the invite is sent to |
| `reject_invite(account_id: AccountId)` | Reject the invite for contributing to entity with given account ID | Contributor who the invite is sent to |
| `get_entity_invites(account_id: AccountId)` | Fetches all the invites sent by the entity with given account ID | Anyone |
| `get_contributor_invites(account_id: AccountId)` | Fetches all the invites sent to the contributor with given account ID | Anyone |
| `get_invite(entity_id: AccountId, contributor_id: AccountId)` | Gets details about a specific invite with a given entity and contributor IDs | Anyone |
| `request_contribution(entity_id: AccountId, description: String)` | Request to contribute to given entity. | Anyone |
| `register(contribution_types: HashSet<ContributionType>, skills: HashSet<String>, resume: String)` | Register as a contributor using the provided details | Anyone |
| `edit_contributor(contributor: Contributor)` | Edit your contributor profile with all the details | Anyone |
| `get_contributors()` | Fetch all the contributors stored in the state | Anyone |
| `check_is_contributor(account_id: AccountId)` | Check if the given account ID is registered as a contributor | Anyone |
| `get_contributor(account_id: AccountId)` | Get the details of a contributor with the given account ID | Anyone |
| `get_contribution_types()` | List out all the contribution types available in the contract | Anyone |
| `post_contribution_need(entity_id: AccountId, description: String, contribution_type: ContributionType)` | Create a new need for given entity with a description and type | Permission::Manager or above |
| `set_contribution_need(entity_id: AccountId, cid: String, need: ContributionNeed)` | Update a need for given entity | Permission::Manager or above |
| `get_contribution_needs()` | Fetch all contribution needs | Anyone |
| `get_entity_contribution_needs(account_id: AccountId)` | Fetch all contribution needs from the given entity | Anyone |
| `get_admin_contribution_needs(account_id: AccountId)` | Fetch all contribution needs the given account can manage | Anyone |
| `get_contribution_need(account_id: AccountId, cid: String)` | Get the details about the given need | Anyone |
| `check_if_need_proposed(account_id: AccountId, cid: String)` | Check if the given need has a proposal from the predecessor account | Anyone |
| `request_contribution(entity_id: AccountId, description: String, contribution_type: ContributionType, need: Option<String>)` | Propose a contribution to a entity as a contributor | Anyone |
| `accept_contribution(entity_id: AccountId, contributor_id: AccountId, description: Option<String>, start_date: Option<U64>)` | Accept a contribution proposal/request. (Optionaly update description and start date) | Permission::Manager or above |
| `reject_contribution(entity_id: AccountId, contributor_id: AccountId)` | Reject a contribution proposal/request | Permission::Manager or above |
| `finish_contribution(entity_id: AccountId, contributor_id: AccountId, end_date: U64)` | Mark a contribution as ended and add a end date | Permission::Manager or above |
| `get_conrtibutor_contributions(account_id: AccountId)` | Fetch all the contributions this contributor is participating in | Anyone |
| `get_entity_contributions(account_id: AccountId)` | Fetch all the contributions this entity is participating in | Anyone |
| `get_need_contributions(account_id: AccountId, cid: String)` | Fetch all contributions for the given need | Anyone |
| `get_contribution(entity_id: AccountId, contributor_id: AccountId)` | Get the details about the given contribution | Anyone |
| `get_entity_contribution_requests(account_id: AccountId)` | Fetch all the contribution requests | Anyone |
| `get_contributor_contribution_requests(account_id: AccountId)` | Get the details about the given request | Anyone |
| `get_admin_contribution_requests(account_id: AccountId)` | Fetch all the contribution requests the given account can manage | Anyone |
| `get_need_contribution_requests(account_id: AccountId, cid: String)` | Fetch all contribution requests for the given need | Anyone |
| `get_conrtibution_request(entity_id: AccountId, contributor_id: AccountId)` | Get the details about the given request | Anyone |

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build -p near-contribute --target wasm32-unknown-unknown --release
[[ ! -d "res" ]] && mkdir res
cp target/wasm32-unknown-unknown/release/near_contribute.wasm ./res/

'''
'''--- contract/Cargo.toml ---
[package]
name = "near-contribute"
version = "0.1.0"
authors = ["Illia Polosukhin <ilblackdragon@gmail.com>, Petar VujoviÄ‡ <petarvujovic98@gmail.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
cid = "0.10.1"
near-contract-standards = "4.1.1"
near-sdk = { version = "4.1.1", features = ["unstable"] }

'''
'''--- contract/src/contribution.rs ---
use cid::multihash::{Code, MultihashDigest};
use cid::Cid;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U64;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, require, serde_json, AccountId, Timestamp};
use std::collections::HashSet;

use crate::contributor::{ContributionType, VersionedContributor};
use crate::dec_serde::{option_u64_dec_format, u64_dec_format};
use crate::entity::Permission;
use crate::events::Events;
use crate::{Contract, ContractExt, MAX_DESCRIPTION_LENGTH};

/// The story/description of a contribution to an entity.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ContributionDetail {
    /// Details about this contribution.
    pub description: String,
    /// The type of this contribution.
    pub contribution_type: ContributionType,
    /// The CID of the need this is associated with (if any).
    pub need: Option<String>,
    /// The start date of the contribution.
    #[serde(with = "u64_dec_format")]
    pub start_date: Timestamp,
    /// The end date of the contribution (if not ongoing).
    #[serde(with = "option_u64_dec_format")]
    pub end_date: Option<Timestamp>,
}

/// Relation between entity and contributor. Managed by source account.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Contribution {
    // TODO: Do we want to store this in a UnorderedSet for lazy loading?
    /// Set of permissions this contributor has for the entity.
    pub permissions: HashSet<Permission>,
    /// The details of the ongoing contribution.
    pub current: ContributionDetail,
    // TODO: Do we want to keep this stored in a Vector for lazy reading?
    /// If more than one contribution was made, previous ones are in history.
    pub history: Vec<ContributionDetail>,
}

impl Contribution {
    pub fn add_detail(
        mut self,
        start_date: u64,
        contribution_detail: ContributionDetail,
        permissions: Option<HashSet<Permission>>,
    ) -> Self {
        self.current.end_date = Some(start_date);
        self.history.push(self.current);
        self.current = contribution_detail;
        self.permissions = permissions.unwrap_or(self.permissions);
        self
    }
}

/// Request to contribute.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ContributionRequest {
    /// The details of the request.
    pub description: String,
    /// The type of request this is.
    pub contribution_type: ContributionType,
    /// The CID of the need this is associated with (if any).
    pub need: Option<String>,
}

/// A need that a entity may have.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ContributionNeed {
    /// The details of the need.
    pub description: String,
    /// The type of need this is.
    pub contribution_type: ContributionType,
    /// Whether this need is currently active.
    pub active: bool,
}

/// A invite to contribute to a entity.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct ContributionInvite {
    /// The details of the invite.
    pub description: String,
    /// The type of invite this is.
    pub contribution_type: ContributionType,
    /// The set of permissions a contributor will get if they accept the invite.
    pub permissions: HashSet<Permission>,
    /// The start date of the contribution after accepting the invite.
    #[serde(with = "u64_dec_format")]
    pub start_date: Timestamp,
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum VersionedContribution {
    Current(Contribution),
}

impl From<VersionedContribution> for Contribution {
    fn from(value: VersionedContribution) -> Self {
        match value {
            VersionedContribution::Current(c) => c,
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum VersionedContributionRequest {
    Current(ContributionRequest),
}

impl From<VersionedContributionRequest> for ContributionRequest {
    fn from(value: VersionedContributionRequest) -> Self {
        match value {
            VersionedContributionRequest::Current(c) => c,
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum VersionedContributionNeed {
    Current(ContributionNeed),
}

impl From<VersionedContributionNeed> for ContributionNeed {
    fn from(value: VersionedContributionNeed) -> Self {
        match value {
            VersionedContributionNeed::Current(c) => c,
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum VersionedContributionInvite {
    Current(ContributionInvite),
}

impl From<VersionedContributionInvite> for ContributionInvite {
    fn from(value: VersionedContributionInvite) -> Self {
        match value {
            VersionedContributionInvite::Current(c) => c,
        }
    }
}

const RAW: u64 = 0x55;

/// Create a CID for a string.
pub fn create_cid(value: &str) -> String {
    let hash = Code::Sha2_256.digest(value.to_string().as_bytes());
    let cid = Cid::new_v1(RAW, hash);
    cid.to_string()
}

#[near_bindgen]
impl Contract {
    /// Create a contribution need.
    pub fn post_contribution_need(
        &mut self,
        entity_id: AccountId,
        description: String,
        contribution_type: ContributionType,
    ) {
        self.assert_manager_or_higher(&entity_id, &env::predecessor_account_id());
        let need = ContributionNeed {
            description: description.clone(),
            contribution_type: contribution_type.clone(),
            active: true,
        };
        let cid = create_cid(&serde_json::to_string(&need).unwrap());
        self.needs.insert(
            (entity_id.clone(), cid.clone()),
            VersionedContributionNeed::Current(need),
        );
        Events::PostContributionNeed {
            entity_id,
            cid,
            description,
            contribution_type,
        }
        .emit();
    }

    /// Update a contribution need.
    pub fn set_contribution_need(
        &mut self,
        entity_id: AccountId,
        cid: String,
        need: ContributionNeed,
    ) {
        self.assert_manager_or_higher(&entity_id, &env::predecessor_account_id());
        require!(
            self.needs.contains_key(&(entity_id.clone(), cid.clone())),
            "ERR_NO_CONTRIBUTION_NEED"
        );
        self.needs
            .insert((entity_id, cid), VersionedContributionNeed::Current(need));
    }

    /// User requests to contribute to a given entity.
    pub fn request_contribution(
        &mut self,
        entity_id: AccountId,
        description: String,
        contribution_type: ContributionType,
        need: Option<String>,
    ) {
        let key = (entity_id.clone(), env::predecessor_account_id());
        require!(
            description.len() < MAX_DESCRIPTION_LENGTH,
            "ERR_DESCRIPTION_TOO_LONG"
        );
        self.contributors
            .entry(env::predecessor_account_id())
            .or_insert(VersionedContributor::Current(Default::default()));
        let need = if let Some(cid) = need {
            require!(
                self.needs.contains_key(&(entity_id.clone(), cid.clone())),
                "ERR_NO_CONTRIBUTION_NEED"
            );
            Some(cid)
        } else {
            None
        };
        // TODO: Check if this account already has a contribution request for this entity? Do we
        // just overwrite or keep track of multiple requests.
        self.requests.insert(
            key,
            VersionedContributionRequest::Current(ContributionRequest {
                description: description.clone(),
                contribution_type: contribution_type.clone(),
                need,
            }),
        );
        Events::RequestContribution {
            entity_id,
            contributor_id: env::predecessor_account_id(),
            description,
            contribution_type,
        }
        .emit();
    }

    /// Entity manager (or higher) rejects a contribution request.
    pub fn reject_contribution(&mut self, entity_id: AccountId, contributor_id: AccountId) {
        self.assert_manager_or_higher(&entity_id, &env::predecessor_account_id());
        let key = (entity_id.clone(), contributor_id.clone());
        self.requests.remove(&key);
        Events::RejectContribution {
            entity_id,
            contributor_id,
        }
        .emit();
    }

    /// Entity manager (or higher) approves a contribution request.
    pub fn approve_contribution(
        &mut self,
        entity_id: AccountId,
        contributor_id: AccountId,
        description: Option<String>,
        start_date: Option<U64>,
    ) {
        self.assert_manager_or_higher(&entity_id, &env::predecessor_account_id());
        let key = (entity_id.clone(), contributor_id.clone());
        let request =
            ContributionRequest::from(self.requests.get(&key).expect("ERR_NO_REQUEST").clone());
        let description = description.unwrap_or(request.description);
        let start_date: Timestamp = start_date.unwrap_or(env::block_timestamp().into()).into();
        let contribution_detail = ContributionDetail {
            description: description.clone(),
            start_date,
            contribution_type: request.contribution_type.clone(),
            need: request.need,
            end_date: None,
        };
        self.contributors
            .entry(contributor_id.clone())
            .or_insert(VersionedContributor::Current(Default::default()));
        self.contributions
            .entry(key.clone())
            .and_modify(|v_old| {
                let old = Contribution::from(v_old.clone());
                *v_old = VersionedContribution::Current(old.add_detail(
                    start_date,
                    contribution_detail.clone(),
                    None,
                ));
            })
            .or_insert(VersionedContribution::Current(Contribution {
                permissions: HashSet::new(),
                current: contribution_detail,
                history: vec![],
            }));
        self.requests.remove(&key);
        Events::ApproveContribution {
            entity_id,
            contributor_id,
            description,
            contribution_type: request.contribution_type,
            start_date,
        }
        .emit();
    }

    /// Entity manager (or higher) marks the contribution as finished/completed.
    pub fn finish_contribution(
        &mut self,
        entity_id: AccountId,
        contributor_id: AccountId,
        end_date: U64,
    ) {
        self.assert_manager_or_higher(&entity_id, &env::predecessor_account_id());
        let key = (entity_id.clone(), contributor_id.clone());
        let mut contributor: Contribution = self
            .contributions
            .get(&key)
            .expect("ERR_NO_CONTRIBUTION")
            .clone()
            .into();
        let end_date: Timestamp = end_date.into();
        contributor.current.end_date = Some(end_date);
        self.contributions
            .insert(key, VersionedContribution::Current(contributor));
        Events::FinishContribution {
            entity_id,
            contributor_id,
            end_date,
        }
        .emit();
    }

    /// Views

    /// Get all the contributions for a single contributor.
    pub fn get_contributor_contributions(&self, account_id: AccountId) -> HashSet<AccountId> {
        self.contributions
            .into_iter()
            .filter_map(|((entity, contributor), _)| {
                (&account_id == contributor).then_some(entity.clone())
            })
            .collect()
    }

    /// Get contribution details.
    pub fn get_contribution(
        &self,
        entity_id: AccountId,
        contributor_id: AccountId,
    ) -> Option<Contribution> {
        self.contributions
            .get(&(entity_id, contributor_id))
            .map(|contribution| contribution.clone().into())
    }

    /// Get all the contributions for this entity.
    pub fn get_entity_contributions(&self, account_id: AccountId) -> HashSet<AccountId> {
        self.contributions
            .into_iter()
            .filter_map(|((entity_id, contributor_id), _)| {
                (entity_id == &account_id).then_some(contributor_id.clone())
            })
            .collect()
    }

    /// Get all contributions for a specific need.
    pub fn get_need_contributions(&self, account_id: AccountId, cid: String) -> HashSet<AccountId> {
        self.contributions
            .into_iter()
            .filter_map(|((entity_id, contributor_id), contribution)| {
                if entity_id != &account_id {
                    return None;
                }
                let contribution = Contribution::from(contribution.clone());
                (contribution.current.need == Some(cid.clone())
                    || contribution
                        .history
                        .iter()
                        .any(|detail| detail.need == Some(cid.clone())))
                .then_some(contributor_id.clone())
            })
            .collect()
    }

    /// Get contribution request details.
    pub fn get_contribution_request(
        &self,
        entity_id: AccountId,
        contributor_id: AccountId,
    ) -> Option<ContributionRequest> {
        self.requests
            .get(&(entity_id, contributor_id))
            .map(|request| request.clone().into())
    }

    /// Get all the requests this contributor sent.
    pub fn get_contributor_contribution_requests(
        &self,
        account_id: AccountId,
    ) -> HashSet<AccountId> {
        self.requests
            .into_iter()
            .filter_map(|((entity_id, contributor_id), _)| {
                (contributor_id == &account_id).then_some(entity_id.clone())
            })
            .collect()
    }

    /// Get all the requests for this entity.
    pub fn get_entity_contribution_requests(&self, account_id: AccountId) -> HashSet<AccountId> {
        self.requests
            .into_iter()
            .filter_map(|((entity_id, contributor_id), _)| {
                (entity_id == &account_id).then_some(contributor_id.clone())
            })
            .collect()
    }

    /// Get all contribution requests this account can manage.
    pub fn get_admin_contribution_requests(
        &self,
        account_id: AccountId,
    ) -> Vec<(AccountId, AccountId)> {
        self.requests
            .into_iter()
            .filter_map(|((entity_id, contributor_id), _)| {
                let Some(contribution) = self.contributions.get(&(entity_id.clone(), account_id.clone())) else {
                    return None;
                };
                let contribution = Contribution::from(contribution.clone());
                contribution.permissions.contains(&Permission::Admin)
                    .then_some((entity_id.clone(), contributor_id.clone()))
            })
            .collect()
    }

    /// Get all contribution requests for a specific need.
    pub fn get_need_contribution_requests(
        &self,
        account_id: AccountId,
        cid: String,
    ) -> HashSet<AccountId> {
        self.requests
            .into_iter()
            .filter_map(|((entity_id, contributor_id), request)| {
                (entity_id == &account_id
                    && ContributionRequest::from(request.clone()).need == Some(cid.clone()))
                .then_some(contributor_id.clone())
            })
            .collect()
    }

    /// Get all contribution needs.
    pub fn get_contribution_needs(&self) -> Vec<(AccountId, String)> {
        self.needs
            .into_iter()
            .map(|((account_id, cid), _)| (account_id.clone(), cid.clone()))
            .collect()
    }

    /// Get all contribnution needs of entity.
    pub fn get_entity_contribution_needs(&self, account_id: AccountId) -> HashSet<String> {
        self.needs
            .into_iter()
            .filter_map(|((entity_id, cid), _)| (entity_id == &account_id).then_some(cid.clone()))
            .collect()
    }

    /// Get all contribnution needs this account can manage.
    pub fn get_admin_contribution_needs(&self, account_id: AccountId) -> Vec<(AccountId, String)> {
        self.needs
            .into_iter()
            .filter_map(|((entity_id, cid), _)| {
                self.check_is_manager_or_higher(entity_id, &account_id)
                    .then_some((entity_id.clone(), cid.clone()))
            })
            .collect()
    }

    /// Get contribution need details.
    pub fn get_contribution_need(
        &self,
        account_id: AccountId,
        cid: String,
    ) -> Option<ContributionNeed> {
        self.needs
            .get(&(account_id, cid))
            .map(|need| need.clone().into())
    }

    /// Checks whether the contributor with the provided contributor ID already proposed to the
    /// need with the given entity ID and CID.
    pub fn check_if_need_proposed(
        &self,
        entity_id: AccountId,
        contributor_id: AccountId,
        cid: String,
    ) -> bool {
        self.requests.iter().any(|((e_id, c_id), c)| {
            e_id == &entity_id
                && c_id == &contributor_id
                && ContributionRequest::from(c.clone()).need == Some(cid.clone())
        })
    }
}

'''
'''--- contract/src/contributor.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{assert_one_yocto, env, near_bindgen, AccountId};
use std::collections::HashSet;

use crate::{events::Events, Contract, ContractExt};

/// Types of contributions a contributor is looking to do.
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    Clone,
)]
#[serde(crate = "near_sdk::serde")]
pub enum ContributionType {
    Development,
    Investment,
    Marketing,
    Legal,
    Other(String),
    Founding,
}

impl Default for ContributionType {
    fn default() -> Self {
        ContributionType::Other(String::new())
    }
}

/// Details of a contritbutor.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Default)]
#[serde(crate = "near_sdk::serde")]
pub struct Contributor {
    /// The types of contributions the contributor is offering.
    contribution_types: HashSet<ContributionType>,
    /// The skills the contributor has.
    skills: HashSet<String>,
    /// The resume of the contributor.
    resume: String,
    /// Whether the contributor is looking for work.
    looking_for_work: bool,
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum VersionedContributor {
    Current(Contributor),
}

impl From<VersionedContributor> for Contributor {
    fn from(value: VersionedContributor) -> Self {
        match value {
            VersionedContributor::Current(c) => c,
        }
    }
}

#[near_bindgen]
impl Contract {
    /// Register as a contributor.
    #[payable]
    pub fn register(
        &mut self,
        contribution_types: HashSet<ContributionType>,
        skills: HashSet<String>,
        resume: String,
    ) {
        assert_one_yocto();
        self.contributors.insert(
            env::predecessor_account_id(),
            VersionedContributor::Current(Contributor {
                contribution_types,
                skills,
                resume,
                looking_for_work: true,
            }),
        );
        Events::RegisterContributor {
            contributor_id: env::predecessor_account_id(),
        }
        .emit();
    }

    /// Edit contributor profile.
    pub fn edit_contributor(&mut self, contributor: Contributor) {
        self.contributors.insert(
            env::predecessor_account_id(),
            VersionedContributor::Current(contributor),
        );
    }

    /// Views

    /// Get all contributor account IDs.
    pub fn get_contributors(&self) -> HashSet<AccountId> {
        self.contributors.keys().cloned().collect()
    }

    /// Check if account is registered as contributor.
    pub fn check_is_contributor(&self, account_id: AccountId) -> bool {
        self.contributors.contains_key(&account_id)
    }

    /// Get contributor details.
    pub fn get_contributor(&self, account_id: AccountId) -> Option<Contributor> {
        self.contributors
            .get(&account_id)
            .map(|contributor| contributor.clone().into())
    }

    /// Get all contribution types.
    pub fn get_contribution_types(&self) -> Vec<ContributionType> {
        vec![
            ContributionType::Development,
            ContributionType::Investment,
            ContributionType::Marketing,
            ContributionType::Legal,
            ContributionType::Founding,
        ]
    }
}

'''
'''--- contract/src/dec_serde.rs ---
pub mod u128_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    #[allow(dead_code)]
    pub fn serialize<S>(num: &u128, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    #[allow(dead_code)]
    pub fn deserialize<'de, D>(deserializer: D) -> Result<u128, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &u64, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&num.to_string())
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<u64, D::Error>
    where
        D: Deserializer<'de>,
    {
        String::deserialize(deserializer)?
            .parse()
            .map_err(de::Error::custom)
    }
}

pub mod option_u64_dec_format {
    use near_sdk::serde::de;
    use near_sdk::serde::{Deserialize, Deserializer, Serializer};

    pub fn serialize<S>(num: &Option<u64>, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&if let Some(value) = num {
            value.to_string()
        } else {
            "".to_string()
        })
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<Option<u64>, D::Error>
    where
        D: Deserializer<'de>,
    {
        let s = String::deserialize(deserializer)?;
        if s.is_empty() {
            Ok(None)
        } else {
            s.parse::<u64>().map(Some).map_err(de::Error::custom)
        }
    }
}

'''
'''--- contract/src/entity.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U64;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, near_bindgen, AccountId, Timestamp};
use std::collections::HashSet;

use crate::contribution::{
    Contribution, ContributionDetail, ContributionInvite, VersionedContribution,
    VersionedContributionInvite,
};
use crate::contributor::{ContributionType, VersionedContributor};
use crate::dec_serde::{option_u64_dec_format, u64_dec_format};
use crate::events::Events;
use crate::{Contract, ContractExt};

/// An entity can be in different states because it can potentially have an end (through different
/// ways - legal issues, no funding...).
/// This is represented by the EntityStatus.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum EntityStatus {
    Active,
    Flagged,
}

/// An entity can take different shapes, and currently we can categorize them in these types.
#[allow(clippy::upper_case_acronyms)]
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub enum EntityKind {
    Project,
    Organization,
    DAO,
}

/// Entity is something that is beyond a single person.
/// Something that has a start and potentially an end.
/// Note, that all the basic information like name, description and social information is stored in the `socialdb`.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Entity {
    /// Name of the entity.
    name: String,
    /// Status of the entity.
    status: EntityStatus,
    /// The type of the entity.
    kind: EntityKind,
    /// The start date of the entity.
    #[serde(with = "u64_dec_format")]
    start_date: Timestamp,
    /// The end date of the entity. (optional)
    #[serde(with = "option_u64_dec_format")]
    end_date: Option<Timestamp>,
}

/// Permissions table for interaction between a contributor and an entity.
#[derive(
    BorshSerialize, BorshDeserialize, Deserialize, Serialize, PartialEq, Eq, PartialOrd, Hash, Clone,
)]
#[serde(crate = "near_sdk::serde")]
pub enum Permission {
    Admin,
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub enum VersionedEntity {
    Current(Entity),
}

impl From<VersionedEntity> for Entity {
    fn from(value: VersionedEntity) -> Self {
        match value {
            VersionedEntity::Current(e) => e,
        }
    }
}

#[near_bindgen]
impl Contract {
    /// Add new entity and user as founding contributor.
    pub fn admin_add_entity(
        &mut self,
        account_id: AccountId,
        founder_id: AccountId,
        name: String,
        kind: EntityKind,
        start_date: U64,
    ) {
        self.assert_moderator();
        self.entities.insert(
            account_id.clone(),
            VersionedEntity::Current(Entity {
                name,
                status: EntityStatus::Active,
                kind,
                start_date: start_date.into(),
                end_date: None,
            }),
        );
        self.contributors
            .entry(founder_id.clone())
            .or_insert(VersionedContributor::Current(Default::default()));
        self.contributions.insert(
            (account_id, founder_id),
            VersionedContribution::Current(Contribution {
                permissions: HashSet::from([Permission::Admin]),
                current: ContributionDetail {
                    description: "".to_string(),
                    start_date: start_date.into(),
                    contribution_type: ContributionType::Founding,
                    end_date: None,
                    need: None,
                },
                history: vec![],
            }),
        );
    }

    /// Add new entity and given user as founding contributor.
    pub fn add_entity(
        &mut self,
        account_id: AccountId,
        name: String,
        kind: EntityKind,
        start_date: U64,
    ) {
        if self.entities.contains_key(&account_id) {
            env::panic_str("ERR_ENTITY_EXISTS");
        }
        self.entities.insert(
            account_id.clone(),
            VersionedEntity::Current(Entity {
                name,
                status: EntityStatus::Active,
                kind,
                start_date: start_date.into(),
                end_date: None,
            }),
        );
        self.contributors
            .entry(env::predecessor_account_id())
            .or_insert(VersionedContributor::Current(Default::default()));
        self.contributions.insert(
            (account_id.clone(), env::predecessor_account_id()),
            VersionedContribution::Current(Contribution {
                permissions: HashSet::from([Permission::Admin]),
                current: ContributionDetail {
                    description: "".to_string(),
                    start_date: start_date.into(),
                    contribution_type: ContributionType::Founding,
                    end_date: None,
                    need: None,
                },
                history: vec![],
            }),
        );
        Events::AddEntity {
            entity_id: account_id,
        }
        .emit();
    }

    /// Moderator updates the entity details.
    pub fn set_entity(&mut self, account_id: AccountId, entity: Entity) {
        self.assert_manager_or_higher(&account_id, &env::predecessor_account_id());
        self.entities
            .insert(account_id, VersionedEntity::Current(entity));
    }

    /// Invite a user as a contributor to an entity.
    pub fn invite_contributor(
        &mut self,
        entity_id: AccountId,
        contributor_id: AccountId,
        description: String,
        contribution_type: ContributionType,
        start_date: U64,
        permissions: HashSet<Permission>,
    ) {
        if self
            .invites
            .contains_key(&(entity_id.clone(), contributor_id.clone()))
        {
            env::panic_str("ERR_INVITE_EXISTS");
        }
        self.assert_manager_or_higher(&entity_id, &env::predecessor_account_id());
        self.contributors
            .entry(contributor_id.clone())
            .or_insert(VersionedContributor::Current(Default::default()));
        self.invites.insert(
            (entity_id.clone(), contributor_id.clone()),
            VersionedContributionInvite::Current(ContributionInvite {
                permissions,
                description: description.clone(),
                contribution_type: contribution_type.clone(),
                start_date: start_date.into(),
            }),
        );
        Events::InviteContributor {
            entity_id,
            contributor_id,
            description,
            contribution_type,
            start_date: start_date.into(),
        }
        .emit()
    }

    /// Accept a contribution invite from an entity with the given account ID.
    pub fn accept_invite(&mut self, account_id: AccountId) {
        let invite = ContributionInvite::from(
            self.invites
                .remove(&(account_id.clone(), env::predecessor_account_id()))
                .expect("ERR_NO_INVITE"),
        );
        let contribution_detail = ContributionDetail {
            description: invite.description.clone(),
            contribution_type: invite.contribution_type.clone(),
            start_date: invite.start_date,
            end_date: None,
            need: None,
        };
        self.contributions
            .entry((account_id.clone(), env::predecessor_account_id()))
            .and_modify(|v_old| {
                let old = Contribution::from(v_old.clone());
                *v_old = VersionedContribution::Current(old.add_detail(
                    invite.start_date,
                    contribution_detail.clone(),
                    None,
                ));
            })
            .or_insert(VersionedContribution::Current(Contribution {
                permissions: invite.permissions.clone(),
                current: contribution_detail.clone(),
                history: vec![],
            }));
        Events::AcceptInvite {
            entity_id: account_id,
            contributor_id: env::predecessor_account_id(),
            description: invite.description,
            contribution_type: invite.contribution_type,
            start_date: invite.start_date,
        }
        .emit();
    }

    /// Reject a contribution inivte from an entity with the given account ID.
    pub fn reject_invite(&mut self, account_id: AccountId) {
        self.invites
            .remove(&(account_id, env::predecessor_account_id()))
            .expect("ERR_NO_INVITE");
    }

    /// Views

    /// List out entities. By default list all of them.
    pub fn get_entities(&self) -> HashSet<AccountId> {
        self.entities.keys().cloned().collect()
    }

    /// List out entities that account ID is admin for.
    pub fn get_admin_entities(&self, account_id: AccountId) -> HashSet<AccountId> {
        self.contributions
            .into_iter()
            .filter_map(|((entity_id, contributor_id), contribution)| {
                (contributor_id == &account_id
                    && Contribution::from(contribution.clone())
                        .permissions
                        .contains(&Permission::Admin))
                .then_some(entity_id.clone())
            })
            .collect()
    }

    /// List single entity details.
    pub fn get_entity(&self, account_id: AccountId) -> Entity {
        self.entities
            .get(&account_id)
            .expect("ERR_NO_ENTITY")
            .clone()
            .into()
    }

    /// List entity founders.
    pub fn get_founders(&self, account_id: AccountId) -> HashSet<AccountId> {
        self.contributions
            .into_iter()
            .filter_map(|((entity_id, contributor_id), contribution)| {
                (entity_id == &account_id && {
                    let contribution = Contribution::from(contribution.clone());
                    let founding_type = vec![
                        ContributionType::Founding,
                        ContributionType::Other("Founding".to_string()),
                    ];
                    founding_type.contains(&contribution.current.contribution_type)
                        || contribution
                            .history
                            .into_iter()
                            .any(|detail| founding_type.contains(&detail.contribution_type))
                })
                .then_some(contributor_id.clone())
            })
            .collect()
    }

    /// Check if account ID is an entity.
    pub fn check_is_entity(&self, account_id: AccountId) -> bool {
        self.entities.contains_key(&account_id)
    }

    /// List invites sent by entity with given account ID.
    pub fn get_entity_invites(&self, account_id: AccountId) -> HashSet<AccountId> {
        self.invites
            .into_iter()
            .filter_map(|((entity_id, contributor_id), _)| {
                (entity_id == &account_id).then_some(contributor_id.clone())
            })
            .collect()
    }

    /// List invites sent to contributor with given account ID.
    pub fn get_contributor_invites(&self, account_id: AccountId) -> HashSet<AccountId> {
        self.invites
            .into_iter()
            .filter_map(|((entity_id, contributor_id), _)| {
                (contributor_id == &account_id).then_some(entity_id.clone())
            })
            .collect()
    }

    /// Get invite details for entity and contributor with given IDs.
    pub fn get_invite(
        &self,
        entity_id: AccountId,
        contributor_id: AccountId,
    ) -> Option<ContributionInvite> {
        self.invites
            .get(&(entity_id, contributor_id))
            .map(|invite| invite.clone().into())
    }
}

'''
'''--- contract/src/events.rs ---
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, serde_json, AccountId, Timestamp};

use crate::contributor::ContributionType;
use crate::dec_serde::u64_dec_format;

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Events {
    AddEntity {
        entity_id: AccountId,
    },
    RegisterContributor {
        contributor_id: AccountId,
    },
    PostContributionNeed {
        entity_id: AccountId,
        cid: String,
        description: String,
        contribution_type: ContributionType,
    },
    RequestContribution {
        entity_id: AccountId,
        contributor_id: AccountId,
        description: String,
        contribution_type: ContributionType,
    },
    RejectContribution {
        entity_id: AccountId,
        contributor_id: AccountId,
    },
    ApproveContribution {
        entity_id: AccountId,
        contributor_id: AccountId,
        description: String,
        contribution_type: ContributionType,
        #[serde(with = "u64_dec_format")]
        start_date: Timestamp,
    },
    FinishContribution {
        entity_id: AccountId,
        contributor_id: AccountId,
        #[serde(with = "u64_dec_format")]
        end_date: Timestamp,
    },
    InviteContributor {
        entity_id: AccountId,
        contributor_id: AccountId,
        description: String,
        contribution_type: ContributionType,
        #[serde(with = "u64_dec_format")]
        start_date: Timestamp,
    },
    AcceptInvite {
        entity_id: AccountId,
        contributor_id: AccountId,
        description: String,
        contribution_type: ContributionType,
        #[serde(with = "u64_dec_format")]
        start_date: Timestamp,
    },
}

impl Events {
    pub(crate) fn emit(self) {
        env::log_str(&format!(
            "EVENT_JSON:{}",
            &serde_json::to_string(&self).unwrap()
        ));
    }
}

'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::store::UnorderedMap;
use near_sdk::{env, near_bindgen, require, sys, AccountId, BorshStorageKey, Gas, PanicOnDefault};

use crate::contribution::{
    Contribution, VersionedContribution, VersionedContributionInvite, VersionedContributionNeed,
    VersionedContributionRequest,
};
use crate::contributor::VersionedContributor;
use crate::entity::{Permission, VersionedEntity};

mod contribution;
mod contributor;
mod dec_serde;
mod entity;
mod events;

const MAX_DESCRIPTION_LENGTH: usize = 420;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKeys {
    Entities,
    Contributions,
    Requests,
    Contributors,
    Needs,
    Invites,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    moderator_id: AccountId,
    entities: UnorderedMap<AccountId, VersionedEntity>,
    contributions: UnorderedMap<(AccountId, AccountId), VersionedContribution>,
    requests: UnorderedMap<(AccountId, AccountId), VersionedContributionRequest>,
    contributors: UnorderedMap<AccountId, VersionedContributor>,
    needs: UnorderedMap<(AccountId, String), VersionedContributionNeed>,
    invites: UnorderedMap<(AccountId, AccountId), VersionedContributionInvite>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(moderator_id: AccountId) -> Self {
        Self {
            moderator_id,
            entities: UnorderedMap::new(StorageKeys::Entities),
            contributions: UnorderedMap::new(StorageKeys::Contributions),
            requests: UnorderedMap::new(StorageKeys::Requests),
            contributors: UnorderedMap::new(StorageKeys::Contributors),
            needs: UnorderedMap::new(StorageKeys::Needs),
            invites: UnorderedMap::new(StorageKeys::Invites),
        }
    }

    pub fn set_moderator(&mut self, moderator_id: AccountId) {
        self.assert_moderator();
        self.moderator_id = moderator_id;
    }

    /// Assertions.

    /// Checks if transaction was performed by moderator account.
    fn assert_moderator(&self) {
        // Errors::OnlyModerator.into()
        require!(
            self.moderator_id == env::predecessor_account_id(),
            "ERR_ONLY_MODERATOR"
        );
    }

    /// Checks if given account has permissions of a manager or higher for given entity.
    fn assert_manager_or_higher(&self, entity_id: &AccountId, account_id: &AccountId) {
        require!(
            self.check_is_manager_or_higher(entity_id, account_id),
            "ERR_NO_PERMISSION"
        );
    }

    /// Checks if given account is registered as a contributor.
    #[allow(dead_code)]
    fn assert_is_registered(&self, account_id: &AccountId) {
        require!(
            self.contributors.contains_key(account_id),
            "ERR_NOT_REGISTERED"
        );
    }

    /// Views

    /// Check if given account ID is moderator.
    pub fn check_is_moderator(&self, account_id: AccountId) -> bool {
        self.moderator_id == account_id
    }

    /// Check if given account ID is manager or higher for given entity.
    pub fn check_is_manager_or_higher(
        &self,
        entity_id: &AccountId,
        account_id: &AccountId,
    ) -> bool {
        if account_id == &self.moderator_id {
            return true;
        }
        let Some(contribution) = self.contributions.get(&(entity_id.clone(), account_id.clone())) else {
            return false;
        };
        let contribution = Contribution::from(contribution.clone());
        contribution.permissions.contains(&Permission::Admin)
    }

    /// Should only be called by this contract on migration.
    /// This is NOOP implementation. KEEP IT if you haven't changed contract state.
    /// This method is called from `upgrade()` method.
    /// For next version upgrades, change this function.
    #[init(ignore_state)]
    #[private]
    pub fn migrate() -> Self {
        let this: Contract = env::state_read().expect("Contract is not initialized.");
        this
    }
}

#[no_mangle]
pub fn upgrade() {
    env::setup_panic_hook();

    let contract: Contract = env::state_read().expect("Contract is not initialized");
    contract.assert_moderator();

    const MIGRATE_METHOD_NAME: &[u8; 7] = b"migrate";
    const UPGRADE_GAS_LEFTOVER: Gas = Gas(5_000_000_000_000);

    unsafe {
        // Load code into register 0 result from the input argument if factory call or from promise if callback.
        sys::input(0);
        // Create a promise batch to upgrade current contract with code from register 0.
        let promise_id = sys::promise_batch_create(
            env::current_account_id().as_bytes().len() as u64,
            env::current_account_id().as_bytes().as_ptr() as u64,
        );
        // Deploy the contract code from register 0.
        sys::promise_batch_action_deploy_contract(promise_id, u64::MAX, 0);
        // Call promise to migrate the state.
        // Batched together to fail upgrade if migration fails.
        sys::promise_batch_action_function_call(
            promise_id,
            MIGRATE_METHOD_NAME.len() as u64,
            MIGRATE_METHOD_NAME.as_ptr() as u64,
            0,
            0,
            0,
            (env::prepaid_gas() - env::used_gas() - UPGRADE_GAS_LEFTOVER).0,
        );
        sys::promise_return(promise_id);
    }
}

'''
'''--- dirty_deploy.sh ---
#!/bin/bash
set -e

ACCOUNT_ID=$1
export NEAR_ENV=mainnet

KEYS=$(near view-state $ACCOUNT_ID --finality final | sed -e "s/'/\"/g" | sed -e "s/key/\"key\"/g" | sed -e "s/value/\"value\"/g" | jq '[.[] | .key]' | tr -d '\n' | tr -d '[:blank:]')

near deploy $ACCOUNT_ID ./state_cleanup.wasm
near call $ACCOUNT_ID clean "{\"keys\":$KEYS}" --accountId $ACCOUNT_ID

near deploy $ACCOUNT_ID ./res/near_contribute.wasm

unset NEAR_ENV

'''
'''--- seed.sh ---
#!/bin/bash
set -e

export DATA_PATH="$1"
export KEY_PATH="$2"
export RECEIVER_ID="$3"

cargo run -p seed

unset DATA_PATH
unset KEY_PATH
unset RECEIVER_ID

'''
'''--- seed/Cargo.toml ---
[package]
name = "seed"
version = "0.1.0"
authors = ["Petar VujoviÄ‡ <petarvujovic98@gmail.com>"]
edition = "2021"

[dependencies]
chrono = "0.4.23"
csv = "1.2.0"
near-account-id = "0.16.0"
near-crypto = "0.16.0"
near-jsonrpc-client = { version = "0.5.0", features = ["any"] }
near-jsonrpc-primitives = "0.16.0"
near-primitives = "0.16.0"
serde = { version = "1.0.152", features = ["derive"] }
serde_json = "1.0.93"
tokio = { version = "1.19", features = ["full"] }

'''
'''--- seed/src/main.rs ---
use std::path::Path;

use chrono::{prelude::*, Utc};
use near_account_id::AccountId;
use near_crypto::InMemorySigner;
use near_jsonrpc_client::methods::broadcast_tx_commit::RpcBroadcastTxCommitRequest;
use near_jsonrpc_client::methods::query::{RpcQueryRequest, RpcQueryResponse};
use near_jsonrpc_client::JsonRpcClient;
use near_jsonrpc_primitives::types::query::QueryResponseKind;
use near_primitives::transaction::{Action, FunctionCallAction, Transaction};
use near_primitives::types::{BlockReference, Finality};
use near_primitives::views::AccessKeyView;
use serde::{Deserialize, Serialize};

const TGAS: u64 = 1_000_000_000_000;

#[derive(Debug, Deserialize, Clone)]
#[allow(dead_code)]
struct Record {
    timestamp: String,
    email: String,
    name: String,
    description: String,
    url: String,
    account_id: AccountId,
    founder_id: AccountId,
    github: String,
}

#[derive(Serialize)]
struct AddEntityParams {
    account_id: AccountId,
    founder_id: AccountId,
    name: String,
    kind: String,
    start_date: String,
}

impl From<Record> for AddEntityParams {
    fn from(value: Record) -> Self {
        Self {
            account_id: value.account_id,
            founder_id: value.founder_id,
            name: value.name,
            kind: "Project".to_string(),
            start_date: match Utc.datetime_from_str(&value.timestamp, "%m/%d/%Y %H:%M:%S") {
                Ok(v) => v.format("%s").to_string(),
                Err(e) => {
                    dbg!(e, value.timestamp);
                    panic!("Error parsing timestamp!")
                }
            },
        }
    }
}

fn read_entries(filename: &str) -> Vec<Record> {
    let file_contents = std::fs::read_to_string(filename).expect("Error reading file!");

    let mut reader = csv::ReaderBuilder::new()
        .has_headers(false)
        .from_reader(file_contents.as_bytes());

    reader
        .deserialize()
        .filter_map(|r| match r {
            Ok(v) => Some(v),
            Err(_) => None,
        })
        .map(|r: Record| Record {
            github: r.github.to_lowercase(),
            url: r.url.to_lowercase(),
            ..r
        })
        .map(|entry| {
            let url = if entry.url.starts_with("https://") {
                String::from(entry.url.get("https://".len()..).unwrap())
            } else if entry.url.starts_with("http://") {
                String::from(entry.url.get("http://".len()..).unwrap())
            } else {
                entry.url.clone()
            };

            let github = if entry.github.starts_with("https://github.com/") {
                String::from(entry.github.get("https://gihtub.com/".len()..).unwrap())
            } else if entry.github.starts_with("http://github.com/") {
                String::from(entry.github.get("http://gihtub.com/".len()..).unwrap())
            } else if entry.github.starts_with("github.com/") {
                String::from(entry.github.get("gihtub.com/".len()..).unwrap())
            } else {
                entry.github.clone()
            };

            let timestamp = if entry.timestamp.find('/').unwrap() < 2 {
                format!("0{}", entry.timestamp)
            } else {
                entry.timestamp.clone()
            };

            Record {
                url,
                github,
                timestamp,
                ..entry
            }
        })
        .collect()
}

fn get_signer(filename: &str) -> InMemorySigner {
    InMemorySigner::from_file(Path::new(filename)).expect("Error reading key file!")
}

fn create_action(record: &Record, gas: u64) -> Action {
    Action::FunctionCall(FunctionCallAction {
        method_name: "admin_add_entity".to_string(),
        args: serde_json::to_vec(&AddEntityParams::from(record.clone())).unwrap(),
        deposit: 0,
        gas,
    })
}

#[tokio::main]
async fn main() {
    let data_path = std::env::var("DATA_PATH").unwrap_or("./data.csv".to_string());
    let key_path = std::env::var("KEY_PATH").expect("Missing KEY_PATH!");
    let receiver_id = std::env::var("RECEIVER_ID")
        .unwrap_or("contribut3.near".to_string())
        .parse()
        .expect("Invalid RECEIVER_ID!");

    let entries = read_entries(&data_path);
    let gas = TGAS * 300 / entries.len() as u64;

    let actions = entries
        .iter()
        .map(|entry| create_action(entry, gas))
        .collect::<Vec<Action>>();

    let client = JsonRpcClient::connect("https://rpc.mainnet.near.org");

    let signer = get_signer(&key_path);

    let Ok(RpcQueryResponse {
        kind, block_hash, ..
    }) = client
        .call(RpcQueryRequest {
            block_reference: BlockReference::Finality(Finality::Final),
            request: near_primitives::views::QueryRequest::ViewAccessKey {
                account_id: signer.account_id.clone(),
                public_key: signer.public_key.clone(),
            },
        })
        .await else {
            panic!("Error querying access key!");
        };

    let QueryResponseKind::AccessKey(AccessKeyView{nonce, ..}) = kind else {
        panic!("Error querying access key!");
    };

    let signed_transaction = Transaction {
        signer_id: signer.account_id.clone(),
        public_key: signer.public_key.clone(),
        receiver_id,
        block_hash,
        actions,
        nonce: nonce + 1,
    }
    .sign(&signer);

    client
        .call(RpcBroadcastTxCommitRequest { signed_transaction })
        .await
        .expect("Error sending transaction!");
}

'''
'''--- widgets/README.md ---
## Web3 Combinator UI

'''
'''--- widgets/package-lock.json ---
{
  "name": "widgets",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "devDependencies": {
        "@types/styled-components": "^5.1.26",
        "npm-watch": "^0.11.0"
      }
    },
    "node_modules/@types/hoist-non-react-statics": {
      "version": "3.3.1",
      "resolved": "https://registry.npmjs.org/@types/hoist-non-react-statics/-/hoist-non-react-statics-3.3.1.tgz",
      "integrity": "sha512-iMIqiko6ooLrTh1joXodJK5X9xeEALT1kM5G3ZLhD3hszxBdIEd5C75U834D9mLcINgD4OyZf5uQXjkuYydWvA==",
      "dev": true,
      "dependencies": {
        "@types/react": "*",
        "hoist-non-react-statics": "^3.3.0"
      }
    },
    "node_modules/@types/prop-types": {
      "version": "15.7.5",
      "resolved": "https://registry.npmjs.org/@types/prop-types/-/prop-types-15.7.5.tgz",
      "integrity": "sha512-JCB8C6SnDoQf0cNycqd/35A7MjcnK+ZTqE7judS6o7utxUCg6imJg3QK2qzHKszlTjcj2cn+NwMB2i96ubpj7w==",
      "dev": true
    },
    "node_modules/@types/react": {
      "version": "18.0.28",
      "resolved": "https://registry.npmjs.org/@types/react/-/react-18.0.28.tgz",
      "integrity": "sha512-RD0ivG1kEztNBdoAK7lekI9M+azSnitIn85h4iOiaLjaTrMjzslhaqCGaI4IyCJ1RljWiLCEu4jyrLLgqxBTew==",
      "dev": true,
      "dependencies": {
        "@types/prop-types": "*",
        "@types/scheduler": "*",
        "csstype": "^3.0.2"
      }
    },
    "node_modules/@types/scheduler": {
      "version": "0.16.2",
      "resolved": "https://registry.npmjs.org/@types/scheduler/-/scheduler-0.16.2.tgz",
      "integrity": "sha512-hppQEBDmlwhFAXKJX2KnWLYu5yMfi91yazPb2l+lbJiwW+wdo1gNeRA+3RgNSO39WYX2euey41KEwnqesU2Jew==",
      "dev": true
    },
    "node_modules/@types/styled-components": {
      "version": "5.1.26",
      "resolved": "https://registry.npmjs.org/@types/styled-components/-/styled-components-5.1.26.tgz",
      "integrity": "sha512-KuKJ9Z6xb93uJiIyxo/+ksS7yLjS1KzG6iv5i78dhVg/X3u5t1H7juRWqVmodIdz6wGVaIApo1u01kmFRdJHVw==",
      "dev": true,
      "dependencies": {
        "@types/hoist-non-react-statics": "*",
        "@types/react": "*",
        "csstype": "^3.0.2"
      }
    },
    "node_modules/abbrev": {
      "version": "1.1.1",
      "resolved": "https://registry.npmjs.org/abbrev/-/abbrev-1.1.1.tgz",
      "integrity": "sha512-nne9/IiQ/hzIhY6pdDnbBtz7DjPTKrY00P/zvPSm5pOFkl6xuGrGnXn/VtTNNfNtAfZ9/1RtehkszU9qcTii0Q==",
      "dev": true
    },
    "node_modules/anymatch": {
      "version": "3.1.3",
      "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.3.tgz",
      "integrity": "sha512-KMReFUr0B4t+D+OBkjR3KYqvocp2XaSzO55UcB6mgQMd3KbcE+mWTyvVV7D/zsdEbNnV6acZUutkiHQXvTr1Rw==",
      "dev": true,
      "dependencies": {
        "normalize-path": "^3.0.0",
        "picomatch": "^2.0.4"
      },
      "engines": {
        "node": ">= 8"
      }
    },
    "node_modules/balanced-match": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
      "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
      "dev": true
    },
    "node_modules/binary-extensions": {
      "version": "2.2.0",
      "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz",
      "integrity": "sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA==",
      "dev": true,
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/brace-expansion": {
      "version": "1.1.11",
      "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
      "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
      "dev": true,
      "dependencies": {
        "balanced-match": "^1.0.0",
        "concat-map": "0.0.1"
      }
    },
    "node_modules/braces": {
      "version": "3.0.2",
      "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
      "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
      "dev": true,
      "dependencies": {
        "fill-range": "^7.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/chokidar": {
      "version": "3.5.3",
      "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.5.3.tgz",
      "integrity": "sha512-Dr3sfKRP6oTcjf2JmUmFJfeVMvXBdegxB0iVQ5eb2V10uFJUCAS8OByZdVAyVb8xXNz3GjjTgj9kLWsZTqE6kw==",
      "dev": true,
      "funding": [
        {
          "type": "individual",
          "url": "https://paulmillr.com/funding/"
        }
      ],
      "dependencies": {
        "anymatch": "~3.1.2",
        "braces": "~3.0.2",
        "glob-parent": "~5.1.2",
        "is-binary-path": "~2.1.0",
        "is-glob": "~4.0.1",
        "normalize-path": "~3.0.0",
        "readdirp": "~3.6.0"
      },
      "engines": {
        "node": ">= 8.10.0"
      },
      "optionalDependencies": {
        "fsevents": "~2.3.2"
      }
    },
    "node_modules/concat-map": {
      "version": "0.0.1",
      "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
      "integrity": "sha512-/Srv4dswyQNBfohGpz9o6Yb3Gz3SrUDqBH5rTuhGR7ahtlbYKnVxw2bCFMRljaA7EXHaXZ8wsHdodFvbkhKmqg==",
      "dev": true
    },
    "node_modules/csstype": {
      "version": "3.1.1",
      "resolved": "https://registry.npmjs.org/csstype/-/csstype-3.1.1.tgz",
      "integrity": "sha512-DJR/VvkAvSZW9bTouZue2sSxDwdTN92uHjqeKVm+0dAqdfNykRzQ95tay8aXMBAAPpUiq4Qcug2L7neoRh2Egw==",
      "dev": true
    },
    "node_modules/debug": {
      "version": "3.2.7",
      "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
      "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
      "dev": true,
      "dependencies": {
        "ms": "^2.1.1"
      }
    },
    "node_modules/fill-range": {
      "version": "7.0.1",
      "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
      "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
      "dev": true,
      "dependencies": {
        "to-regex-range": "^5.0.1"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/fsevents": {
      "version": "2.3.2",
      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
      "integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
      "dev": true,
      "hasInstallScript": true,
      "optional": true,
      "os": [
        "darwin"
      ],
      "engines": {
        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
      }
    },
    "node_modules/glob-parent": {
      "version": "5.1.2",
      "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
      "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
      "dev": true,
      "dependencies": {
        "is-glob": "^4.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/has-flag": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
      "integrity": "sha512-sKJf1+ceQBr4SMkvQnBDNDtf4TXpVhVGateu0t918bl30FnbE2m4vNLX+VWe/dpjlb+HugGYzW7uQXH98HPEYw==",
      "dev": true,
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/hoist-non-react-statics": {
      "version": "3.3.2",
      "resolved": "https://registry.npmjs.org/hoist-non-react-statics/-/hoist-non-react-statics-3.3.2.tgz",
      "integrity": "sha512-/gGivxi8JPKWNm/W0jSmzcMPpfpPLc3dY/6GxhX2hQ9iGj3aDfklV4ET7NjKpSinLpJ5vafa9iiGIEZg10SfBw==",
      "dev": true,
      "dependencies": {
        "react-is": "^16.7.0"
      }
    },
    "node_modules/ignore-by-default": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/ignore-by-default/-/ignore-by-default-1.0.1.tgz",
      "integrity": "sha512-Ius2VYcGNk7T90CppJqcIkS5ooHUZyIQK+ClZfMfMNFEF9VSE73Fq+906u/CWu92x4gzZMWOwfFYckPObzdEbA==",
      "dev": true
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
      "dev": true
    },
    "node_modules/is-binary-path": {
      "version": "2.1.0",
      "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
      "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
      "dev": true,
      "dependencies": {
        "binary-extensions": "^2.0.0"
      },
      "engines": {
        "node": ">=8"
      }
    },
    "node_modules/is-extglob": {
      "version": "2.1.1",
      "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
      "integrity": "sha512-SbKbANkN603Vi4jEZv49LeVJMn4yGwsbzZworEoyEiutsN3nJYdbO36zfhGJ6QEDpOZIFkDtnq5JRxmvl3jsoQ==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-glob": {
      "version": "4.0.3",
      "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
      "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
      "dev": true,
      "dependencies": {
        "is-extglob": "^2.1.1"
      },
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/is-number": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
      "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
      "dev": true,
      "engines": {
        "node": ">=0.12.0"
      }
    },
    "node_modules/minimatch": {
      "version": "3.1.2",
      "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
      "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
      "dev": true,
      "dependencies": {
        "brace-expansion": "^1.1.7"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/ms": {
      "version": "2.1.3",
      "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
      "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
      "dev": true
    },
    "node_modules/nodemon": {
      "version": "2.0.20",
      "resolved": "https://registry.npmjs.org/nodemon/-/nodemon-2.0.20.tgz",
      "integrity": "sha512-Km2mWHKKY5GzRg6i1j5OxOHQtuvVsgskLfigG25yTtbyfRGn/GNvIbRyOf1PSCKJ2aT/58TiuUsuOU5UToVViw==",
      "dev": true,
      "dependencies": {
        "chokidar": "^3.5.2",
        "debug": "^3.2.7",
        "ignore-by-default": "^1.0.1",
        "minimatch": "^3.1.2",
        "pstree.remy": "^1.1.8",
        "semver": "^5.7.1",
        "simple-update-notifier": "^1.0.7",
        "supports-color": "^5.5.0",
        "touch": "^3.1.0",
        "undefsafe": "^2.0.5"
      },
      "bin": {
        "nodemon": "bin/nodemon.js"
      },
      "engines": {
        "node": ">=8.10.0"
      },
      "funding": {
        "type": "opencollective",
        "url": "https://opencollective.com/nodemon"
      }
    },
    "node_modules/nopt": {
      "version": "1.0.10",
      "resolved": "https://registry.npmjs.org/nopt/-/nopt-1.0.10.tgz",
      "integrity": "sha512-NWmpvLSqUrgrAC9HCuxEvb+PSloHpqVu+FqcO4eeF2h5qYRhA7ev6KvelyQAKtegUbC6RypJnlEOhd8vloNKYg==",
      "dev": true,
      "dependencies": {
        "abbrev": "1"
      },
      "bin": {
        "nopt": "bin/nopt.js"
      },
      "engines": {
        "node": "*"
      }
    },
    "node_modules/normalize-path": {
      "version": "3.0.0",
      "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
      "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
      "dev": true,
      "engines": {
        "node": ">=0.10.0"
      }
    },
    "node_modules/npm-watch": {
      "version": "0.11.0",
      "resolved": "https://registry.npmjs.org/npm-watch/-/npm-watch-0.11.0.tgz",
      "integrity": "sha512-wAOd0moNX2kSA2FNvt8+7ORwYaJpQ1ZoWjUYdb1bBCxq4nkWuU0IiJa9VpVxrj5Ks+FGXQd62OC/Bjk0aSr+dg==",
      "dev": true,
      "dependencies": {
        "nodemon": "^2.0.7",
        "through2": "^4.0.2"
      },
      "bin": {
        "npm-watch": "cli.js"
      }
    },
    "node_modules/picomatch": {
      "version": "2.3.1",
      "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
      "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
      "dev": true,
      "engines": {
        "node": ">=8.6"
      },
      "funding": {
        "url": "https://github.com/sponsors/jonschlinkert"
      }
    },
    "node_modules/pstree.remy": {
      "version": "1.1.8",
      "resolved": "https://registry.npmjs.org/pstree.remy/-/pstree.remy-1.1.8.tgz",
      "integrity": "sha512-77DZwxQmxKnu3aR542U+X8FypNzbfJ+C5XQDk3uWjWxn6151aIMGthWYRXTqT1E5oJvg+ljaa2OJi+VfvCOQ8w==",
      "dev": true
    },
    "node_modules/react-is": {
      "version": "16.13.1",
      "resolved": "https://registry.npmjs.org/react-is/-/react-is-16.13.1.tgz",
      "integrity": "sha512-24e6ynE2H+OKt4kqsOvNd8kBpV65zoxbA4BVsEOB3ARVWQki/DHzaUoC5KuON/BiccDaCCTZBuOcfZs70kR8bQ==",
      "dev": true
    },
    "node_modules/readable-stream": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.0.tgz",
      "integrity": "sha512-BViHy7LKeTz4oNnkcLJ+lVSL6vpiFeX6/d3oSH8zCW7UxP2onchk+vTGB143xuFjHS3deTgkKoXXymXqymiIdA==",
      "dev": true,
      "dependencies": {
        "inherits": "^2.0.3",
        "string_decoder": "^1.1.1",
        "util-deprecate": "^1.0.1"
      },
      "engines": {
        "node": ">= 6"
      }
    },
    "node_modules/readdirp": {
      "version": "3.6.0",
      "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
      "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
      "dev": true,
      "dependencies": {
        "picomatch": "^2.2.1"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "dev": true,
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/semver": {
      "version": "5.7.1",
      "resolved": "https://registry.npmjs.org/semver/-/semver-5.7.1.tgz",
      "integrity": "sha512-sauaDf/PZdVgrLTNYHRtpXa1iRiKcaebiKQ1BJdpQlWH2lCvexQdX55snPFyK7QzpudqbCI0qXFfOasHdyNDGQ==",
      "dev": true,
      "bin": {
        "semver": "bin/semver"
      }
    },
    "node_modules/simple-update-notifier": {
      "version": "1.1.0",
      "resolved": "https://registry.npmjs.org/simple-update-notifier/-/simple-update-notifier-1.1.0.tgz",
      "integrity": "sha512-VpsrsJSUcJEseSbMHkrsrAVSdvVS5I96Qo1QAQ4FxQ9wXFcB+pjj7FB7/us9+GcgfW4ziHtYMc1J0PLczb55mg==",
      "dev": true,
      "dependencies": {
        "semver": "~7.0.0"
      },
      "engines": {
        "node": ">=8.10.0"
      }
    },
    "node_modules/simple-update-notifier/node_modules/semver": {
      "version": "7.0.0",
      "resolved": "https://registry.npmjs.org/semver/-/semver-7.0.0.tgz",
      "integrity": "sha512-+GB6zVA9LWh6zovYQLALHwv5rb2PHGlJi3lfiqIHxR0uuwCgefcOJc59v9fv1w8GbStwxuuqqAjI9NMAOOgq1A==",
      "dev": true,
      "bin": {
        "semver": "bin/semver.js"
      }
    },
    "node_modules/string_decoder": {
      "version": "1.3.0",
      "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
      "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
      "dev": true,
      "dependencies": {
        "safe-buffer": "~5.2.0"
      }
    },
    "node_modules/supports-color": {
      "version": "5.5.0",
      "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
      "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
      "dev": true,
      "dependencies": {
        "has-flag": "^3.0.0"
      },
      "engines": {
        "node": ">=4"
      }
    },
    "node_modules/through2": {
      "version": "4.0.2",
      "resolved": "https://registry.npmjs.org/through2/-/through2-4.0.2.tgz",
      "integrity": "sha512-iOqSav00cVxEEICeD7TjLB1sueEL+81Wpzp2bY17uZjZN0pWZPuo4suZ/61VujxmqSGFfgOcNuTZ85QJwNZQpw==",
      "dev": true,
      "dependencies": {
        "readable-stream": "3"
      }
    },
    "node_modules/to-regex-range": {
      "version": "5.0.1",
      "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
      "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
      "dev": true,
      "dependencies": {
        "is-number": "^7.0.0"
      },
      "engines": {
        "node": ">=8.0"
      }
    },
    "node_modules/touch": {
      "version": "3.1.0",
      "resolved": "https://registry.npmjs.org/touch/-/touch-3.1.0.tgz",
      "integrity": "sha512-WBx8Uy5TLtOSRtIq+M03/sKDrXCLHxwDcquSP2c43Le03/9serjQBIztjRz6FkJez9D/hleyAXTBGLwwZUw9lA==",
      "dev": true,
      "dependencies": {
        "nopt": "~1.0.10"
      },
      "bin": {
        "nodetouch": "bin/nodetouch.js"
      }
    },
    "node_modules/undefsafe": {
      "version": "2.0.5",
      "resolved": "https://registry.npmjs.org/undefsafe/-/undefsafe-2.0.5.tgz",
      "integrity": "sha512-WxONCrssBM8TSPRqN5EmsjVrsv4A8X12J4ArBiiayv3DyyG3ZlIg6yysuuSYdZsVz3TKcTg2fd//Ujd4CHV1iA==",
      "dev": true
    },
    "node_modules/util-deprecate": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
      "integrity": "sha512-EPD5q1uXyFxJpCrLnCc1nHnq3gOa6DZBocAIiI2TaSCA7VCJ1UJDMagCzIkXNsUYfD1daK//LTEQ8xiIbrHtcw==",
      "dev": true
    }
  }
}

'''
'''--- widgets/package.json ---
{
  "type": "module",
  "scripts": {
    "download": "near-social download contribut3.near network-config mainnet",
    "deploy": "near-social deploy contribut3.near sign-as contribut3.near network-config mainnet sign-with-access-key-file ~/.near-credentials/mainnet/contribut3.near.json send",
    "dev": "npm-watch"
  },
  "devDependencies": {
    "@types/styled-components": "^5.1.26",
    "npm-watch": "^0.11.0"
  },
  "watch": {
    "deploy": {
      "patterns": [
        "src"
      ],
      "extensions": "js,jsx"
    }
  }
}

'''
'''--- widgets/types.d.ts ---
import { StyledInterface } from "styled-components";

declare global {
  const styled: StyledInterface;
  const state: Record<string, any>;
  const context: {
    accountId: string;
    widgetSrc: string;
  };

  function useCache(
    promiseGenerator: () => Promise<any>,
    dataKey: string,
    options?: { subscribe?: boolean }
  ): null | unknown;

  function fetch(
    url: string,
    options?: {
      method?: string;
      headers?: Record<string, string>;
      body?: string;
    }
  ): null | unknown;

  function asyncFetch(
    url: string,
    options?: {
      method?: string;
      headers?: Record<string, string>;
      body?: string;
    }
  ): Promise<unknown>;

  interface Storage {
    set(key: string, value: any): void;

    get(key: string, widgetSrc?: string): null | unknown;

    privateSet(key: string, value: any): void;

    privateGet(key: string): null | unknown;
  }

  namespace Near {
    type Transaction = {
      contractName: string;
      methodName: string;
      args?: Record<string, any>;
      gas?: string | number;
      deposit?: string | number;
    };

    function view(
      contractName: string,
      methodName: string,
      args: Record<string, any>,
      finality: "final" | number,
      subscribe: boolean
    ): null | unknown;

    function asyncView(
      contractName: string,
      methodName: string,
      args?: Record<string, any>,
      finality?: "final" | number,
      subscribe?: boolean
    ): Promise<null | unknown>;

    function call(
      contractName: string,
      methodName: string,
      args?: Record<string, any>,
      gas?: string | number,
      deposit?: string | number
    ): void;
    function call(txs: Transaction | Transaction[]): void;
  }

  namespace Social {
    function get(
      patterns: string | string[],
      finality?: "final" | number,
      options?: { subscribe?: boolean; return_deleted?: boolean }
    ): null | unknown;

    function getr(
      patterns: string | string[],
      finality?: "final" | number,
      options?: { subscribe?: boolean; return_deleted?: boolean }
    ): null | unknown;

    function keys(
      patterns: string | string[],
      finality?: "final" | number,
      options?: {
        subscribe?: boolean;
        return_type?: "History" | "True" | "BlockHeight";
        return_deleted?: boolean;
        values_only?: boolean;
      }
    ): null | unknown;

    function index(
      action: string,
      key: string,
      options?: {
        accountId?: string;
        order?: "asc" | "desc";
        limit?: number;
        from?: number;
      }
    ): null | unknown;
  }

  namespace State {
    function init(state: Record<string, any>): void;

    function update(
      state: Record<string, any>,
      init?: Record<string, any>
    ): void;
  }
}

'''