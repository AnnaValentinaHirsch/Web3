*GitHub Repository "juno-labs/mars-minter"*

'''--- .vscode/settings.json ---
{
    "editor.formatOnSave": true
}
'''
'''--- README.md ---
# Mars Minter

Want to launch your own project on NEAR? Mars Minter makes it easy. Feel free to make contributions to the code.

## Steps needed to launch a project

1. Have assets/art ready (this is on you, anon)
2. Verify and Upload assets
3. Deploy contract
4. Add whitelisted users (optional)
5. Connect to your frontend minting app (this is on you, anon)

## Launch your collection:

1. Get your images and metadata json files in the same structure as that in the `example-assets` folder.
2. Create your configuration file in the structure shown in `example-mars-minter-config.json`
3. Sign up for NFT Storage API key (it's free) and get an API key from https://nft.storage/files/ to save in the `nftStorageApiKey` field within the config.
4. Run `yarn install` in the mars-minter folder.
5. Verify your assets by running the following command:

```sh
ts-node src/mars-minter-cli.ts verify_assets -d example-assets -n <size-of-nft-collection>
```

6. Upload your assets by running the following command:

```sh
ts-node src/mars-minter-cli.ts upload_assets -d example-assets -cf example-mars-minter-config.json
```

7. Install `near-cli` by following instructions from [the official near docs](https://docs.near.org/docs/tools/near-cli#installation)

8. Login to `near-cli` using your NEAR account, on which you want to deploy the NFT contract. Note - this must match with the `walletAuthority` passed in your configuration file.

```sh
NEAR_ENV=mainnet near login
```

9. Deploy the contract by running the following command:

```sh
ts-node src/mars-minter-cli.ts deploy_contract -e mainnet -cf example-mars-minter-config.json
```

10. Create your whitelist file in the structure shown in `example-whitelist-addresses.json`.

11. Whitelist addresses by running the following command:

```sh
ts-node src/mars-minter-cli.ts whitelist -e mainnet -cf example-mars-minter-config.json -wj example-whitelist-addresses.json
```

## Advanced Usages

### Adding custom media URIs

```sh
ts-node src/mars-minter-cli.ts update_media_uri -e mainnet -cf example-mars-minter-config.json -muj ./example-media-uri-list.json
```

'''
'''--- example-assets/jsons/0.json ---
{
  "title": "Near Dragon #0",
  "edition": 0,
  "description": "Dragon Nation is an exclusive collection of 3,000 Dragon NFTs on the NEAR blockchain",
  "attributes": [
    {
      "trait_type": "Background",
      "value": "Water"
    },
    {
      "trait_type": "Wings",
      "value": "Nightmare"
    },
    {
      "trait_type": "Type",
      "value": "Zombie"
    },
    {
      "trait_type": "Neck",
      "value": "Aqua Tie"
    },
    {
      "trait_type": "Mouth",
      "value": "None"
    },
    {
      "trait_type": "Ears",
      "value": "None"
    },
    {
      "trait_type": "Eyes",
      "value": "Goggle"
    },
    {
      "trait_type": "Head",
      "value": "Pirate Hat"
    }
  ]
}
'''
'''--- example-assets/jsons/1.json ---
{
  "title": "Near Dragon #1",
  "edition": 1,
  "description": "Dragon Nation is an exclusive collection of 3,000 Dragon NFTs on the NEAR blockchain",
  "attributes": [
    {
      "trait_type": "Background",
      "value": "Mauve"
    },
    {
      "trait_type": "Wings",
      "value": "None"
    },
    {
      "trait_type": "Type",
      "value": "Pink"
    },
    {
      "trait_type": "Neck",
      "value": "Silver Chain"
    },
    {
      "trait_type": "Mouth",
      "value": "None"
    },
    {
      "trait_type": "Ears",
      "value": "None"
    },
    {
      "trait_type": "Eyes",
      "value": "Blue"
    },
    {
      "trait_type": "Head",
      "value": "Tan Cowboy Hat"
    }
  ]
}
'''
'''--- example-assets/jsons/2.json ---
{
  "title": "Near Dragon #2",
  "edition": 2,
  "description": "Dragon Nation is an exclusive collection of 3,000 Dragon NFTs on the NEAR blockchain",
  "attributes": [
    {
      "trait_type": "Background",
      "value": "Dawn"
    },
    {
      "trait_type": "Wings",
      "value": "Nightmare"
    },
    {
      "trait_type": "Type",
      "value": "Green"
    },
    {
      "trait_type": "Neck",
      "value": "Gold Chain"
    },
    {
      "trait_type": "Mouth",
      "value": "None"
    },
    {
      "trait_type": "Ears",
      "value": "Topaz"
    },
    {
      "trait_type": "Eyes",
      "value": "Laser"
    },
    {
      "trait_type": "Head",
      "value": "Police Cap"
    }
  ]
}
'''
'''--- example-assets/jsons/3.json ---
{
  "title": "Near Dragon #3",
  "edition": 3,
  "description": "Dragon Nation is an exclusive collection of 3,000 Dragon NFTs on the NEAR blockchain",
  "attributes": [
    {
      "trait_type": "Background",
      "value": "Inferno"
    },
    {
      "trait_type": "Wings",
      "value": "Bat"
    },
    {
      "trait_type": "Type",
      "value": "Silver"
    },
    {
      "trait_type": "Neck",
      "value": "Aqua Tie"
    },
    {
      "trait_type": "Mouth",
      "value": "None"
    },
    {
      "trait_type": "Ears",
      "value": "None"
    },
    {
      "trait_type": "Eyes",
      "value": "Normal"
    },
    {
      "trait_type": "Head",
      "value": "Pirate Hat"
    }
  ]
}
'''
'''--- example-assets/jsons/4.json ---
{
  "title": "Near Dragon #4",
  "edition": 4,
  "description": "Dragon Nation is an exclusive collection of 3,000 Dragon NFTs on the NEAR blockchain",
  "attributes": [
    {
      "trait_type": "Background",
      "value": "Dusk"
    },
    {
      "trait_type": "Wings",
      "value": "Wyvern"
    },
    {
      "trait_type": "Type",
      "value": "Golden"
    },
    {
      "trait_type": "Neck",
      "value": "Orange Bandana"
    },
    {
      "trait_type": "Mouth",
      "value": "Vape"
    },
    {
      "trait_type": "Ears",
      "value": "Hoops"
    },
    {
      "trait_type": "Eyes",
      "value": "Normal"
    },
    {
      "trait_type": "Head",
      "value": "None"
    }
  ]
}
'''
'''--- example-mars-minter-config.json ---
{
  "nftStorageApiKey": "XXXYYYZZZZ",
  "walletAuthority": "dragonnation.near",
  "collectionName": "Near Dragon Nation",
  "symbol": "NDN",
  "description": "Dragon Nation is an exclusive collection of 3,000 Dragon NFTs on the NEAR blockchain.",
  "size": 3000,
  "costInNear": 5,
  "premintStartDate": "09 Feb 2022 20:30:00 GMT",
  "publicMintStartDate": "09 Feb 2022 21:30:00 GMT",
  "initialsPayout": {
    "c-k-s.near": 50,
    "ndragons.near": 20,
    "flyingsaucer.near": 20,
    "dragonnation.near": 10
  },
  "royaltiesPayout": {
    "flyingtrade.near": 20,
    "c-k-s.near": 20,
    "mkdrag.near": 20,
    "dragonnation.near": 40
  },
  "royaltiesPercent": 5,
  "ipfsLink": ""
}
'''
'''--- example-media-uri-list.json ---
[
    "https://bafybeib3d6p5y5ar34apenyfqeykhvg5346fgwoxyfuenqg55awknbwnpu.ipfs.nftstorage.link/",
    "https://bafybeib3d6p5y5ar34apenyfqeykhvg5346fgwoxyfuenqg55awknbwnpu.ipfs.nftstorage.link/"
]
'''
'''--- example-whitelist-addresses.json ---
{
    "flyingsaucer.near": 5,
    "c-k-s.near": 50,
    "tradefortendies.near": 100
}
'''
'''--- package.json ---
{
  "name": "cli",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@types/node": "^17.0.16",
    "typescript": "^4.5.5"
  },
  "dependencies": {
    "ajv": "^8.10.0",
    "commander": "^9.0.0",
    "dayjs": "^1.10.7",
    "fs": "^0.0.1-security",
    "loglevel": "^1.8.0",
    "near-api-js": "^0.44.2",
    "near-willem-workspaces": "^1.0.3-alpha.0",
    "nft.storage": "^6.0.0",
    "path": "^0.12.7"
  }
}
'''
'''--- src/helpers/nearUtils.ts ---
import { program } from "commander";
import dayjs from "dayjs";
import assert from "assert";
import fs from "fs";
import { Gas, NEAR } from "near-willem-workspaces";

const { keyStores, connect, transactions } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";

program.version("0.0.2");

const MARS_MINTER_WASM_PATH = "./programs/mars_minter.wasm";

const nodeUrlMap: any = {
  mainnet: "https://rpc.mainnet.near.org",
  testnet: "https://rpc.testnet.near.org",
};

export const getAccount = async (env: string, accountId: string) => {
  const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
  const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

  const config = {
    keyStore,
    networkId: env,
    nodeUrl: nodeUrlMap[env],
  };

  const near = await connect(config);
  const account = await near.account(accountId);
  return account;
};

export const deployAndInitializeMarsMinter = async (
  env: string,
  accountId: string,
  initialData: any
) => {
  const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
  const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

  const config = {
    keyStore,
    networkId: env,
    nodeUrl: nodeUrlMap[env],
  };

  const near = await connect(config);
  const account = await near.account(accountId);

  const epochNext060sec = dayjs().unix() + 60;
  const epochNext300sec = dayjs().unix() + 300;

  const accountState = await account.state();

  const { code_hash: codeHash } = accountState;

  const emptyCodeHashList = ["11111111111111111111111111111111"];

  if (emptyCodeHashList.includes(codeHash)) {
    const result = await account.signAndSendTransaction({
      receiverId: accountId,
      actions: [
        transactions.deployContract(fs.readFileSync(MARS_MINTER_WASM_PATH)),
        transactions.functionCall(
          "new_default_meta",
          initialData,
          Gas.parse("20 TGas")
        ),
      ],
    });
    console.log("Contract is deployed ðŸš€");
  } else {
    console.log("Contract is already deployed!!");
  }
};

const getCurrentWhitelistAllowance = async (
  adminAccount: any,
  contractId: string,
  accountId: string
) => {
  let currentAllowance = 0;
  try {
    currentAllowance = await adminAccount.viewFunction(
      contractId,
      "get_wl_allowance",
      {
        account_id: accountId,
      }
    );
  } catch (error) {
    // Error will be thrown for the accounts which are not whitelisted
  }

  return currentAllowance;
};

const getCurrentMediaUri = async (
  adminAccount: any,
  contractId: string,
  tokenId: string
) => {
  let mediaUri = "";
  try {
    mediaUri = await adminAccount.viewFunction(contractId, "get_token_media", {
      token_id: tokenId,
    });
  } catch (error) {
    // Error will be thrown for the accounts which are not whitelisted
  }

  return mediaUri;
};

export const whitelistAccount = async (
  adminAccount: any,
  contractId: string,
  accountId: string,
  allowance: number
) => {
  try {
    let currentAllowance = 0;

    currentAllowance = await getCurrentWhitelistAllowance(
      adminAccount,
      contractId,
      accountId
    );

    if (currentAllowance !== allowance) {
      await adminAccount.functionCall({
        contractId,
        methodName: "add_whitelist_account",
        args: { account_id: accountId, allowance },
        gas: Gas.parse("30Tgas"),
      });
    } else {
      return;
    }

    currentAllowance = await getCurrentWhitelistAllowance(
      adminAccount,
      contractId,
      accountId
    );

    assert.ok(currentAllowance === allowance);
  } catch (error) {
    console.log({
      accountId,
      error,
    });
  }
};

export const addMediaUri = async (
  adminAccount: any,
  contractId: string,
  tokenId: string,
  mediaUri: string
) => {
  try {
    let currentMediaUri = "";

    currentMediaUri = await getCurrentMediaUri(
      adminAccount,
      contractId,
      tokenId
    );

    if (currentMediaUri !== mediaUri) {
      await adminAccount.functionCall({
        contractId,
        methodName: "add_media_uri",
        args: { token_id: tokenId, uri: mediaUri },
        gas: Gas.parse("10Tgas"),
        attachedDeposit: "1",
      });
    } else {
      return;
    }

    currentMediaUri = await getCurrentMediaUri(
      adminAccount,
      contractId,
      tokenId
    );

    assert.ok(currentMediaUri === mediaUri);
  } catch (error) {
    console.log({
      tokenId,
      mediaUri,
      error,
    });
  }
};

'''
'''--- src/helpers/upload.ts ---
// @ts-nocheck
import { File, NFTStorage } from "nft.storage";
import * as fs from "fs/promises";
import * as path from "path";

declare interface File {
  _parts: any[];
}

async function iterateFiles(baseDir): Promise<typeof File[][]> {
  const images = await fs.readdir(`${baseDir}/images`);
  const files = await Promise.all(
    images.map(async (img) => {
      const id = path.basename(img, path.extname(img));
      const jsonFile = (
        await fs.readFile(`${baseDir}/jsons/${id}.json`)
      ).toString();
      return [
        new File([await fs.readFile(`${baseDir}/images/${img}`)], `${id}.png`),
        new File([jsonFile], `${id}.json`),
      ];
    })
  );
  return files;
}

export const uploadNftStorage = async (apiKey, baseDir) => {
  const initialFiles = await iterateFiles(baseDir);
  console.log("\n === Loaded assests ===");
  const client = new NFTStorage({ token: apiKey });
  console.log("\n === Initialized NFT Storage Client ===");
  return await client.storeDirectory(initialFiles.flat());
};

'''
'''--- src/helpers/verification.ts ---
// @ts-nocheck
import fs from "fs";
import Ajv from "ajv";

const ajv = new Ajv();

const metadataSchema = {
  type: "object",
  properties: {
    title: { type: "string" },
    description: { type: "string" },
    attributes: { type: "array" },
  },
  required: ["title", "description", "attributes"],
  additionalProperties: true,
};
export const verifyAssets = (imgList, jsonList, numberOfAssets, baseDir) => {
  const verifiedImgCount = imgList.filter((imgFile) => {
    return imgFile.endsWith("png") || imgFile.endsWith("jpg");
  }).length;
  const verifiedJsonCount = jsonList.filter((jsonFile) => {
    return jsonFile.endsWith("json");
  }).length;
  if (verifiedImgCount !== verifiedJsonCount) {
    throw new Error(
      `number of img files is not the same as number of json files`
    );
  }
  if (
    numberOfAssets != verifiedImgCount &&
    numberOfAssets != verifiedJsonCount
  ) {
    throw new Error(`number of assets do not match collection count`);
  }
  const randomJsonFile = jsonList[Math.floor(Math.random() * jsonList.length)];
  const sampleJsonFile = JSON.parse(
    fs.readFileSync(`${baseDir}/jsons/${randomJsonFile}`, "utf8")
  );
  const compiledSchema = ajv.compile(metadataSchema);
  const isValid = compiledSchema(sampleJsonFile);
  if (!isValid) {
    throw new Error(`metadata isn't formatted correctly`);
  }
};

// Validator for config file

const INT_0_TO_100 = "Integer between 0 to 100";

const isValidPercentage = (x) => x >= 0 && x <= 100;

const isValidPayout = (payoutObject) => {
  let totalPayout = 0;
  for (const nearAddress in payoutObject) {
    const percentage = payoutObject[nearAddress];
    if (!isValidPercentage(percentage)) {
      console.log(`Invalid percentage for ${nearAddress}`);
      return false;
    }
    totalPayout += percentage;
  }
  if (totalPayout !== 100) {
    console.log(`Total payouts should add up to 100`);
    return false;
  }
  return true;
};

ajv.addFormat(INT_0_TO_100, {
  type: "number",
  validate: isValidPercentage,
});

export const configurationSchema = {
  type: "object",
  properties: {
    walletAuthority: { type: "string" },
    collectionName: { type: "string" },
    symbol: { type: "string" },
    description: { type: "string" },
    size: { type: "number" },
    costInNear: { type: "number" },
    premintStartDate: { type: "string" },
    publicMintStartDate: { type: "string" },
    initialsPayout: { type: "object" },
    royaltiesPayout: { type: "object" },
    ipfsLink: { type: "string" },
    royaltiesPercent: { type: "number", format: INT_0_TO_100 },
  },
  required: [
    "walletAuthority",
    "collectionName",
    "symbol",
    "description",
    "size",
    "costInNear",
    "premintStartDate",
    "publicMintStartDate",
    "initialsPayout",
    "royaltiesPayout",
    "royaltiesPercent",
    "ipfsLink",
  ],
  additionalProperties: true,
};

export const validateConfigurationFile = async (config) => {
  const validate = ajv.compile(configurationSchema);
  const isValid = validate(config);
  if (!isValid) {
    console.log(
      `Configuration file is not correct: \n${validate.errors
        ?.map((error) => `${error.instancePath}: ${error.message}`)
        .join("\n")}`
    );
    return false;
  }
  // Validate payouts
  if (!isValidPayout(config.initialsPayout)) {
    console.log(`Issue in initialsPayout`);
    return false;
  }
  if (!isValidPayout(config.royaltiesPayout)) {
    console.log(`Issue in royaltiesPayout`);
    return false;
  }
  return true;
};

'''
'''--- src/mars-minter-cli.ts ---
import { program } from "commander";
import assert from "assert";
import dayjs from "dayjs";
import fs from "fs";
import { NEAR } from "near-willem-workspaces";
import path from "path";
import {
  addMediaUri,
  deployAndInitializeMarsMinter,
  getAccount,
  whitelistAccount,
} from "./helpers/nearUtils";
import { uploadNftStorage } from "./helpers/upload";
import {
  validateConfigurationFile,
  verifyAssets,
} from "./helpers/verification";

program.version("0.0.2");

// Verifies that images and json have same number of assets
// Verifies the structure of json
programCommand("verify_assets")
  .requiredOption(
    "-d, --directory <string>",
    "Path of the folder containing assets"
  )
  .requiredOption("-n, --number <number>", "Number of assets")
  .action(async (options, cmd) => {
    console.log("\n === Verifying assets ===");
    const baseDir = options.directory;
    const numberOfAssets = options.number;
    const imageDir = path.join(baseDir, "images");
    const jsonDir = path.join(baseDir, "jsons");
    const imageList = fs.readdirSync(imageDir);
    const jsonList = fs.readdirSync(jsonDir);
    verifyAssets(imageList, jsonList, numberOfAssets, baseDir);
    console.log("\n === Verifying successful ===");
    process.exit(0);
  });

// Uploads the images and jsons as a flat file structure
programCommand("upload_assets")
  .requiredOption(
    "-d, --directory <string>",
    "Path of the folder containing assets"
  )
  .requiredOption("-cf, --config <string>", "Path of the config file")
  .action(async (options: any, cmd: any) => {
    console.log("\n === Uploading assets ===");
    const baseDir = options.directory;
    let config = JSON.parse(fs.readFileSync(options.config, "utf8"));
    const { nftStorageApiKey } = config;
    config.ipfsLink = await uploadNftStorage(nftStorageApiKey, baseDir);
    fs.writeFileSync(options.config, JSON.stringify(config, null, 2));
    console.log("\n === Finished upload & saved IPFS CID ===\n");
    process.exit(0);
  });

// Deploys the contract and initializes it from the values present in config file
programCommand("deploy_contract")
  .option(
    "-e, --env <string>",
    "NEAR cluster env name. One of: mainnet, testnet",
    "testnet"
  )
  .requiredOption("-cf, --config <string>", "Path of the config file")
  .action(async (options) => {
    const { env } = options;
    const config = JSON.parse(fs.readFileSync(options.config, "utf8"));
    const isConfigValid = await validateConfigurationFile(config);
    if (!isConfigValid) {
      return;
    }
    const premintStartEpoch = dayjs(config.premintStartDate).unix();
    const publicMintStartEpoch = dayjs(config.publicMintStartDate).unix();
    const initDict = {
      owner_id: config.walletAuthority,
      name: config.collectionName,
      symbol: config.symbol,
      uri: `https://${config.ipfsLink}.ipfs.dweb.link/`,
      description: config.description,
      size: config.size,
      base_cost: NEAR.parse(`${config.costInNear} N`),
      premint_start_epoch: premintStartEpoch,
      mint_start_epoch: publicMintStartEpoch,
      royalties: {
        accounts: config.royaltiesPayout,
        percent: config.royaltiesPercent,
      },
      initial_royalties: {
        accounts: config.initialsPayout,
        percent: 100,
      },
    };

    await deployAndInitializeMarsMinter(env, config.walletAuthority, initDict);

    process.exit(0);
  });

// Whitelists the addresses
programCommand("whitelist")
  .option(
    "-e, --env <string>",
    "NEAR cluster env name. One of: mainnet, testnet",
    "testnet"
  )
  .requiredOption(
    "-wj, --wl-json <string>",
    "Path of the json file containing addresses with allocation"
  )
  .requiredOption("-cf, --config <string>", "Path of the config file")
  .action(async (options) => {
    const { env } = options;
    const config = JSON.parse(fs.readFileSync(options.config, "utf8"));
    const wlJson = JSON.parse(fs.readFileSync(options.wlJson, "utf8"));
    const { walletAuthority: contractId } = config;
    const adminAccount = await getAccount(env, contractId);
    const promiseList = Object.keys(wlJson).map(async (nearAddress) => {
      await whitelistAccount(
        adminAccount,
        contractId,
        nearAddress,
        wlJson[nearAddress]
      );
    });
    await Promise.all(promiseList);
    console.log(`Done âœ…`);
    process.exit(0);
  });

// Update media URIs
programCommand("update_media_uri")
  .option(
    "-e, --env <string>",
    "NEAR cluster env name. One of: mainnet, testnet",
    "testnet"
  )
  .requiredOption(
    "-muj, --media-uri-json <string>",
    "Path of the json file containing media URIs"
  )
  .requiredOption("-cf, --config <string>", "Path of the config file")
  .action(async (options) => {
    const { env } = options;
    const config = JSON.parse(fs.readFileSync(options.config, "utf8"));
    const mediaUriList = JSON.parse(
      fs.readFileSync(options.mediaUriJson, "utf8")
    );
    const { walletAuthority: contractId } = config;
    const adminAccount = await getAccount(env, contractId);
    assert.ok(
      mediaUriList.length === config.size,
      "Media URIs length mismatch"
    );
    const promiseList = mediaUriList.map(
      async (mediaUri: string, index: number) => {
        await addMediaUri(adminAccount, contractId, index.toString(), mediaUri);
      }
    );
    await Promise.all(promiseList);
    console.log(`Done âœ…`);
    process.exit(0);
  });

function programCommand(name: string) {
  return program.command(name);
}

program.parse(process.argv);

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    /* Visit https://aka.ms/tsconfig.json to read more about this file */

    /* Projects */
    // "incremental": true,                              /* Enable incremental compilation */
    // "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
    // "tsBuildInfoFile": "./",                          /* Specify the folder for .tsbuildinfo incremental compilation files. */
    // "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects */
    // "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
    // "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */

    /* Language and Environment */
    "target": "es2016" /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */,
    // "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
    // "jsx": "preserve",                                /* Specify what JSX code is generated. */
    // "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
    // "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
    // "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h' */
    // "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
    // "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using `jsx: react-jsx*`.` */
    // "reactNamespace": "",                             /* Specify the object invoked for `createElement`. This only applies when targeting `react` JSX emit. */
    // "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
    // "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */

    /* Modules */
    "module": "commonjs" /* Specify what module code is generated. */,
    // "rootDir": "./",                                  /* Specify the root folder within your source files. */
    // "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
    // "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
    // "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
    // "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
    // "typeRoots": [],                                  /* Specify multiple folders that act like `./node_modules/@types`. */
    // "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
    // "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
    // "resolveJsonModule": true,                        /* Enable importing .json files */
    // "noResolve": true,                                /* Disallow `import`s, `require`s or `<reference>`s from expanding the number of files TypeScript should add to a project. */

    /* JavaScript Support */
    // "allowJs": true,                                  /* Allow JavaScript files to be a part of your program. Use the `checkJS` option to get errors from these files. */
    // "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
    // "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from `node_modules`. Only applicable with `allowJs`. */

    /* Emit */
    // "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
    // "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
    // "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
    // "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
    // "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If `declaration` is true, also designates a file that bundles all .d.ts output. */
    // "outDir": "./",                                   /* Specify an output folder for all emitted files. */
    // "removeComments": true,                           /* Disable emitting comments. */
    // "noEmit": true,                                   /* Disable emitting files from a compilation. */
    // "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
    // "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types */
    // "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
    // "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
    // "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
    // "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
    // "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
    // "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
    // "newLine": "crlf",                                /* Set the newline character for emitting files. */
    // "stripInternal": true,                            /* Disable emitting declarations that have `@internal` in their JSDoc comments. */
    // "noEmitHelpers": true,                            /* Disable generating custom helper functions like `__extends` in compiled output. */
    // "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
    // "preserveConstEnums": true,                       /* Disable erasing `const enum` declarations in generated code. */
    // "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
    // "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */

    /* Interop Constraints */
    // "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
    // "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
    "esModuleInterop": true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables `allowSyntheticDefaultImports` for type compatibility. */,
    // "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
    "forceConsistentCasingInFileNames": true /* Ensure that casing is correct in imports. */,

    /* Type Checking */
    "strict": true /* Enable all strict type-checking options. */,
    // "noImplicitAny": true,                            /* Enable error reporting for expressions and declarations with an implied `any` type.. */
    // "strictNullChecks": true,                         /* When type checking, take into account `null` and `undefined`. */
    // "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
    // "strictBindCallApply": true,                      /* Check that the arguments for `bind`, `call`, and `apply` methods match the original function. */
    // "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
    // "noImplicitThis": true,                           /* Enable error reporting when `this` is given the type `any`. */
    // "useUnknownInCatchVariables": true,               /* Type catch clause variables as 'unknown' instead of 'any'. */
    // "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
    // "noUnusedLocals": true,                           /* Enable error reporting when a local variables aren't read. */
    // "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read */
    // "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
    // "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
    // "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
    // "noUncheckedIndexedAccess": true,                 /* Include 'undefined' in index signature results */
    // "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
    // "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type */
    // "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
    // "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */

    /* Completeness */
    // "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
    "skipLibCheck": true /* Skip type checking all .d.ts files. */
  }
}

'''