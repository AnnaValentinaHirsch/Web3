*GitHub Repository "Panasthetik/near-supply-chain"*

'''--- README.md ---
# near-supply-chain
Near Protocol supply chain smart contract template in Rust for order tracking and administration.

# Article / Tutorial
This will be published on Medium as a web3 tutorial.

# Adaptable
The project can be adapted to your needs on Near Protocol, if you need a supply chain type contract to track orders, or a b2b application.

'''
'''--- final_contract/Cargo.toml ---
[package]
name = "supply-chain-app"
version = "0.1.0"
authors = ["NEAR Friend <friend@example.com>"]
edition = "2018"
# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0-pre.4"
hex = "0.4.3"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- final_contract/build.bat ---
cargo build --target wasm32-unknown-unknown --release
copy target\wasm32-unknown-unknown\release\*.wasm res
'''
'''--- final_contract/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- final_contract/src/lib.rs ---
mod models;
mod utils;

use std::convert::TryInto;

use crate::{
    utils::{
        AccountId,
    },
    models::{
        Customer,
        Product,
        Order,
        OrderStatus,
        Address,

    }
};

use near_sdk::{borsh::{self, BorshDeserialize, BorshSerialize}};
#[allow(unused_imports)]
use near_sdk::{env, PromiseIndex, near_bindgen};
near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]

pub struct Contract {
    owner_id: AccountId,
    orders: Vec<Order>,
    customers: Vec<Customer>,
    products: Vec<Product>,
}

impl Default for Contract {
    fn default() -> Self {
        panic!("Contract should be initialized before usage")
    }
}

#[near_bindgen]
impl Contract{
    #[init]
    pub fn new(
        owner_id: AccountId,
    ) -> Self{
        let orders: Vec<Order> = Vec::new();
        let customers: Vec<Customer> = Vec::new();
        let products: Vec<Product> = Vec::new();
        assert!(env::state_read::<Self>().is_none(), "Already initialized");

        let mut contract = Self {
            owner_id,
            orders,
            customers,
            products,
        };

        contract

    }

    pub fn get_owner(&self) -> AccountId {
        let admin = self.owner_id.clone();
        return admin.to_string()
    }

    pub fn register(&mut self, name: String, email: String) {
        let cust_id = self.customers.len() as i32;

        self.customers.push(Customer::new(
            cust_id,
            name,
            email,
        ));
        env::log("Registration submitted successfully!".as_bytes());
    }

    pub fn get_customer_by_id(&mut self, cust_id: usize) -> AccountId {
        let signer = env::predecessor_account_id();
        let owner = self.owner_id.clone();
        let customer: &mut Customer = self.customers.get_mut(cust_id).unwrap();
        let account = customer.near_account.clone();
        assert_eq!(signer.to_string(), owner);
        return account.to_string();
    }

    pub fn get_customers(&self) -> Vec<Customer> {
        let signer = env::predecessor_account_id();
        let owner = self.owner_id.clone();
        let customers = &self.customers;
        assert_eq!(signer.to_string(), owner);
        return customers.to_vec();
    }

    pub fn add_address(&mut self, cust_id: usize, customer_name: String, street_number: String,
        city: String, state: String, zip: String) {
            let customer: &mut Customer = self.customers.get_mut(cust_id).unwrap();
            let address = Address::new(customer_name, street_number, city, state, zip);
            
            let signer = env::predecessor_account_id();
            let account = customer.near_account.clone();
            assert_eq!(signer.to_string(), account);

            customer.shipping_address.push(address);
            env::log("Address added successfully!".as_bytes());

        }

    pub fn customer_count(&mut self) -> usize {
        let signer = env::predecessor_account_id();
        let owner = self.owner_id.clone();
        assert_eq!(signer.to_string(), owner);
        return self.customers.len();
    }

    pub fn add_product(&mut self, title: String, description: String, price: u128) {
        let signer = env::predecessor_account_id();
        let owner = self.owner_id.clone();
        let prod_id = self.products.len() as i32;
        assert_eq!(signer.to_string(), owner);
        self.products.push(Product::new(
            prod_id, 
            title,
            description,
            price,

        ));
        env::log("Product added successfully!".as_bytes());
    }

    pub fn get_products(&self) -> Vec<Product> {
        let products = &self.products;
        return products.to_vec();

    }

    pub fn product_count(&mut self) -> usize {
        let signer = env::predecessor_account_id();
        let owner = self.owner_id.clone();
        assert_eq!(signer.to_string(), owner);
        return self.products.len();
    }

    pub fn get_orders_by_customer(&mut self, cust_id: usize) -> Vec<Order> {
        let customer: &mut Customer = self.customers.get_mut(cust_id).unwrap();
        let signer = env::predecessor_account_id();
        let owner = self.owner_id.clone();
        let orders = customer.orders.clone();
        assert_eq!(signer.to_string(), owner);
        return orders.to_vec();

    }

    pub fn create_order(&mut self, cust_id: usize) {
        let customer: &mut Customer = self.customers.get_mut(cust_id).unwrap();
        let order_id = customer.orders.len() as usize;
        let mut order = Order::new(order_id.try_into().unwrap());

        let signer = env::predecessor_account_id();
        let account = customer.near_account.clone();
        assert_eq!(signer.to_string(), account);

        customer.orders.push(order);
        env::log("A new empty order was created successfully!".as_bytes());
    }

    pub fn edit_order(&mut self, cust_id: usize, order_id: usize, prod_id: usize) {
        let customer: &mut Customer = self.customers.get_mut(cust_id).unwrap();
        let order: &mut Order = customer.orders.get_mut(order_id).unwrap();
        let product = self.products.get(prod_id).unwrap();
        let price = product.price;

        let signer = env::predecessor_account_id();
        let account = customer.near_account.clone();
        assert_eq!(signer.to_string(), account);

        order.status = OrderStatus::ItemsBeingAdded;
       
        order.products.push(product.clone());
        order.total_cost += price;
        env::log("Product added - order was updated successfully!".as_bytes());
    }

    pub fn get_products_in_order(&mut self, cust_id: usize, order_id: usize) -> Vec<Product> {
        let customer: &mut Customer = self.customers.get_mut(cust_id).unwrap();
        let order: &mut Order = customer.orders.get_mut(order_id).unwrap();

        let signer = env::predecessor_account_id();
        let account = customer.near_account.clone();
        assert_eq!(signer.to_string(), account);

        return order.products.clone();
    }

    pub fn cust_review_order(&mut self, cust_id: usize, order_id: usize, approval_qty: i32) -> bool {
        let customer: &mut Customer = self.customers.get_mut(cust_id).unwrap();
        let order: &mut Order = customer.orders.get_mut(order_id).unwrap();
        let products = order.products.clone();

        let signer = env::predecessor_account_id();
        let account = customer.near_account.clone();
        assert_eq!(signer.to_string(), account);

        assert_eq!(products.len().to_string(), approval_qty.to_string());
        order.status = OrderStatus::ClientOrderSubmitted;
        env::log("Order approved successfully!".as_bytes());
        true
    }

    pub fn assemble_order(&mut self, cust_id: usize, order_id: usize) -> bool {
        let customer: &mut Customer = self.customers.get_mut(cust_id).unwrap();
        let order: &mut Order = customer.orders.get_mut(order_id).unwrap();
        let signer = env::predecessor_account_id();
        let owner = self.owner_id.clone();
        assert_eq!(signer.to_string(), owner);
        order.status = OrderStatus::InAssembly;
        env::log("Assembly complete - order completed successfully!".as_bytes());
        true
    }

    pub fn verify_order_admin(&mut self, cust_id: usize, order_id: usize, verify_qty: i32) -> bool {
        let customer: &mut Customer = self.customers.get_mut(cust_id).unwrap();
        let order: &mut Order = customer.orders.get_mut(order_id).unwrap();
        let products = order.products.clone();
        let signer = env::predecessor_account_id();
        let owner = self.owner_id.clone();
        assert_eq!(signer.to_string(), owner);
        assert_eq!(products.len().to_string(), verify_qty.to_string());
        order.status = OrderStatus::Assembled;
        env::log("Order verified and approved successfully!".as_bytes());
        true
    }

    pub fn ready_to_ship(&mut self, cust_id: usize, order_id: usize, ready: bool) -> bool {
        let customer: &mut Customer = self.customers.get_mut(cust_id).unwrap();
        let order: &mut Order = customer.orders.get_mut(order_id).unwrap();
        let signer = env::predecessor_account_id();
        let owner = self.owner_id.clone();
        if order.status == OrderStatus::Assembled {
            assert_eq!(signer.to_string(), owner);
            assert_eq!(ready, true);
            order.status = OrderStatus::ReadyToShip;
        }
        env::log("Order is ready to ship - can notify customer!".as_bytes());
        true
    }
 
}

// PASTE ENTIRE TEST BLOCK HERE BELOW THESE COMMENTS.
// MAKE SURE IT IS OUTSIDE THE ABOVE CONTRACT BRACES.
// YOU CAN USE EITHER:
// bash ./test.sh
// OR
// cargo test
// AS LONG AS YOU ARE IN THE  "final_contract" DIRECTORY 
// IN YOUR TERMINAL TO RUN THE UNIT TESTS.
// THERE ARE 10 UNIT TESTS

'''
'''--- final_contract/src/models.rs ---
  
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};
use near_sdk::serde::{Deserialize, Serialize};
use std::cmp::{PartialEq};

use crate::utils::{
    AccountId,
    Timestamp,
};

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub enum Role {
    Admin,
    User,
}

#[derive(PartialEq)]
#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub enum OrderStatus {
    Created,
    ItemsBeingAdded,
    ClientOrderSubmitted,
    InAssembly,
    Assembled,
    ReadyToShip,

}

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Address {
    pub customer_name: String,
    pub street_number: String,
    pub city: String,
    pub state: String,
    pub zip: String,
}

impl Address {
    
    pub fn new(customer_name: String, street_number: String,
        city: String, state: String, zip: String) -> Self {

        Address {
            customer_name,
            street_number,
            city,
            state,
            zip,

        }
    }

    
}

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Administrator {
    id: i32,
    pub name: String,
    pub added_by: AccountId,
    pub near_account: AccountId,
    pub email: String,
    pub role: Role,

}

impl Administrator{
    
    pub fn new(id:i32, name: String, near_account: AccountId,
        email: String) -> Self {

        Administrator {
            id,
            added_by: env::signer_account_id().to_string(),
            name,
            near_account,
            email,
            role: Role::Admin,

        }
    }

    
}

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Customer {
    cust_id: i32,
    pub name: String,
    pub email: String,
    pub near_account: AccountId,
    pub shipping_address: Vec<Address>,
    pub joined: Timestamp,
    pub role: Role,
    pub orders: Vec<Order>,

}

impl Customer{
    
    pub fn new(cust_id:i32, name: String, email: String) -> Self {

        Customer {
            cust_id,
            name,
            email,
            near_account: env::signer_account_id().to_string(),
            shipping_address: vec![],
            joined: env::block_timestamp(),
            role: Role::User,
            orders: vec![],

        }
    }

    
}

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Product {
    pub prod_id: i32,
    pub title: String,
    pub description: String,
    pub price: u128,
    added_by: AccountId,
}

impl Product {
    pub fn new(prod_id:i32, title: String, description: String, price: u128) -> Self {
        
        Product {
            prod_id,
            title,
            description,
            price,
            added_by: env::signer_account_id().to_string(),

        }
    }

    
}

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Order {
    order_id: i32,
  pub creator: AccountId,
    created_at: Timestamp,
    pub products: Vec<Product>,
    pub status: OrderStatus,
    pub total_cost: u128,

}

impl Order {
    pub fn new(order_id:i32) -> Self {
        
        Order {
            order_id,
            creator: env::signer_account_id().to_string(),
            created_at: env::block_timestamp(),
            products: vec![],
            status: OrderStatus::Created,
            total_cost: 0,
        
        }
    }

}

'''
'''--- final_contract/src/utils.rs ---
  
use near_sdk::{
    env,
    PromiseResult,
};

pub type AccountId = String;

pub type Timestamp = u64;

pub fn assert_self() {
    let caller = env::predecessor_account_id();
    let current = env::current_account_id();

    assert_eq!(caller, current, "Only this contract may call itself");
}

pub fn assert_single_promise_success(){
    assert_eq!(
        env::promise_results_count(),
        1,
        "Expected exactly one promise result",
    );

    match env::promise_result(0) {
        PromiseResult::Successful(_) => return,
        _ => panic!("Expected PromiseStatus to be successful"),
    };
}
'''
'''--- final_contract/test.sh ---
#!/bin/bash
set -e

cargo test -- --nocapture
'''
'''--- starter_files/lib.rs ---
// THIS IS A TEMPLATE FOR THE MAIN NEAR SMART CONTRACT ("lib.rs") FILE.
// NOTE: YOU MUST INITIALIZE THE CONTRACT (AFTER DEPLOYMENT TO TESTNET) BEFORE USING.
// SEE INSTRUCTIONS IN THE MEDIUM ARTICLE FOR INITIALIZATION.

// CRATE IMPORT STATEMENTS ALREADY SET UP::

mod models;
mod utils;

use std::convert::TryInto;

use crate::{
    utils::{
        AccountId,
    },
    models::{
        Customer,
        Product,
        Order,
        OrderStatus,
        Address,

    }
};

// NEAR SDK STRUCTS, TRAITS ALREADY DECLARED HERE::

use near_sdk::{borsh::{self, BorshDeserialize, BorshSerialize}};
#[allow(unused_imports)]
use near_sdk::{env, PromiseIndex, near_bindgen};
near_sdk::setup_alloc!();

// THE STARTER CONTRACT STRUCTURE IS DEFINED BELOW.
// FUNCTIONS SHOULD BE ADDED BY FOLLOWING THE STEPS OUTLINED 
// BELOW AND IN THE ARTICLE::

#[near_bindgen]
#[derive(Clone, BorshDeserialize, BorshSerialize)]

pub struct Contract {
    owner_id: AccountId,
    orders: Vec<Order>,
    customers: Vec<Customer>,
    products: Vec<Product>,
}

impl Default for Contract {
    fn default() -> Self {
        panic!("Contract should be initialized before usage")
    }
}

#[near_bindgen]
impl Contract{
    #[init]
    pub fn new(
        owner_id: AccountId,
    ) -> Self{
        let orders: Vec<Order> = Vec::new();
        let customers: Vec<Customer> = Vec::new();
        let products: Vec<Product> = Vec::new();
        assert!(env::state_read::<Self>().is_none(), "Already initialized");

        let mut contract = Self {
            owner_id,
            orders,
            customers,
            products,
        };

        contract

    }

    // CONTRACT FUNCTIONS GO BELOW THIS LINE.
    // FOLLOW STEP #'S FROM THE TUTORIAL / PLACEHOLDERS NUMBERED BELOW:

}

// PASTE ENTIRE TEST BLOCK HERE BELOW THESE COMMENTS.
// MAKE SURE IT IS OUTSIDE THE ABOVE CONTRACT BRACES.
// YOU CAN USE EITHER:
// bash ./test.sh
// OR
// cargo test
// AS LONG AS YOU ARE IN THE  "final_contract" DIRECTORY 
// IN YOUR TERMINAL TO RUN THE UNIT TESTS.
'''
'''--- starter_files/models.rs ---
// THIS FILE IS FOR APPLICATION-SPECIFIC DATA STRUCTURES:
// PRIMARILY STRUCTS, IMPLEMENTATION BLOCKS AND ENUMS FOR STATE.
// YOU CAN CUSTOMIZE AS YOU SEE FIT. 

// CRATE IMPORT STATEMENTS ALREADY SET UP FOR TUTORIAL::
  
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen};
use near_sdk::serde::{Deserialize, Serialize};

use crate::utils::{
    AccountId,
    Timestamp
};

// NEAR SDK STRUCTS, TRAITS ALREADY DECLARED HERE AT THE
// TOP OF EACH STRUCT OUTLINE
// FOLLOW THE STEPS BELOW AND IN THE ARTICLE TO 
// FILL IN THE DATA FIELDS/METHODS FOR THE STRUCTS / IMPLEMENTATION BLOCKS / ENUMS::

#[derive(PartialEq)]
#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub enum OrderStatus {
  
    // PLACEHOLDER

}

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Address {

        // PLACEHOLDER
}

impl Address {
    
      // PLACEHOLDER
    
}

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Administrator {
 
        // PLACEHOLDER
}

impl Administrator{
    
    

    
}

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Customer {
 
        // PLACEHOLDER

}

impl Customer{
    
 
        // PLACEHOLDER

    
}

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Product {

        // PLACEHOLDER

}

impl Product {
    
        // PLACEHOLDER

    
}

#[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Order {

        // PLACEHOLDER
}

impl Order {
  
        // PLACEHOLDER

}

'''
'''--- starter_files/utils.rs ---
// THIS FILE IS FOR UNITS AND CONSTANTS.
// THIS INCLUDES GLOBAL TYPES (ex: AccountId, Timestamp) AND ANY CONVERSIONS (ONE_NEAR = ...).
// YOU CAN CUSTOMIZE THIS AS YOU SEE FIT.

// NEAR SDK IMPORTS

use near_sdk::{
    env,
    PromiseResult,
};

// GLOBAL TYPES:

pub type AccountId = String;

pub type Timestamp = u64;

// OPTIONAL UTILITY FUNCTIONS:

pub fn assert_self() {
    let caller = env::predecessor_account_id();
    let current = env::current_account_id();

    assert_eq!(caller, current, "Only this contract may call itself");
}

pub fn assert_single_promise_success(){
    assert_eq!(
        env::promise_results_count(),
        1,
        "Expected exactly one promise result",
    );

    match env::promise_result(0) {
        PromiseResult::Successful(_) => return,
        _ => panic!("Expected PromiseStatus to be successful"),
    };
}
'''
'''--- test_file/test.rs ---

// THIS INITIALIZES THE TESTING ENVIRONMENT
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::{testing_env, AccountId};

    fn get_context(predecessor: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.predecessor_account_id(predecessor);
        builder
    }

    //THIS TEST INITIALIZES CONTRACT AFTER DEPLOYMENT
    #[test]
    fn initialize() {
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice.clone());

        testing_env!(context.build());

        let mut contract = Contract::new(alice.to_string());

        let owner = contract.get_owner();

        assert_eq!(owner, alice.to_string());
  
    }

    //THIS TEST INITIALIZES CONTRACT AFTER DEPLOYMENT, AND
    // ALLOWS A CUSTOMER TO REGISTER
    #[test]
    fn register_user() {
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice.clone());

        testing_env!(context.build());

        let mut contract = Contract::new(alice.to_string());

        let owner = contract.get_owner();

        assert_eq!(owner, alice.to_string());

        // make note second context is "NEAR" account not testnet

        let bob = AccountId::new_unchecked("bob.near".to_string());

        contract.register(bob.to_string(), "bobjones@gmail.com".to_string());

        let customer_count = contract.get_customers().len() as usize;

        assert_eq!(customer_count, 1);

        let bob_account = contract.get_customer_by_id(0);

        assert_eq!(bob.to_string(), bob_account.to_string());

    }

    //THIS TEST INITIALIZES CONTRACT AFTER DEPLOYMENT, AND
    // ALLOWS A CUSTOMER TO REGISTER,
    // CUSTOMER ADDS THEIR SHIPPING ADDRESS
    #[test]
    fn add_address_to_profile() {
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice.clone());

        testing_env!(context.build());

        let mut contract = Contract::new(alice.to_string());

        let owner = contract.get_owner();

        assert_eq!(owner, alice.to_string());

        // make note second context is "NEAR" account not testnet

        let bob = AccountId::new_unchecked("bob.near".to_string());

        contract.register(bob.to_string(), "bobjones@gmail.com".to_string());

        let customer_count = contract.get_customers().len() as usize;

        assert_eq!(customer_count, 1);

        let new_context = get_context(bob.clone());

        testing_env!(new_context.build());

        contract.add_address(0, "Bob Jones".to_string(),
                    "111 Maple Lane".to_string(),
                    "Detroit".to_string(),
                    "Michigan".to_string(),
                    "48313".to_string());

    }

    //THIS TEST INITIALIZES CONTRACT AFTER DEPLOYMENT, AND
    // THE OWNER ADDS ONE PRODUCT TO PRODUCTS
    #[test]
    fn add_a_product_by_owner() {
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice.clone());

        testing_env!(context.build());

        let mut contract = Contract::new(alice.to_string());

        let owner = contract.get_owner();

        assert_eq!(owner, alice.to_string());

        contract.add_product("Nike Running Shoes".to_string(),
                "A great shoe for a good price".to_string(), 
                100);

        let count = contract.product_count();

        assert_eq!(count, 1);

    }

    //THIS TEST INITIALIZES CONTRACT AFTER DEPLOYMENT, AND
    // ALLOWS A CUSTOMER TO REGISTER,
    // CUSTOMER CREATES AN EMPTY ORDER
    // ORDER STATUS = "CREATED"
    #[test]
    fn create_empty_order() {
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice.clone());

        testing_env!(context.build());

        let mut contract = Contract::new(alice.to_string());

        let owner = contract.get_owner();

        assert_eq!(owner, alice.to_string());

        // make note second context is "NEAR" account not testnet

        let bob = AccountId::new_unchecked("bob.near".to_string());

        contract.register(bob.to_string(), "bobjones@gmail.com".to_string());

        let customer_count = contract.get_customers().len() as usize;

        assert_eq!(customer_count, 1);

        let new_context = get_context(bob.clone());

        testing_env!(new_context.build());

        contract.create_order(0);

        // SWITCH BACK TO FIRST CONTEXT FOR "OWNER"

        testing_env!(context.build());

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::Created, order_status);

    
    }
    
    //THIS TEST INITIALIZES CONTRACT AFTER DEPLOYMENT, AND
    // ALLOWS A CUSTOMER TO REGISTER,
    // CUSTOMER CREATES AN EMPTY ORDER
    // ORDER STATUS = "CREATED"
    // CUSTOMER ADDS A PRODUCT TO ORDER
    // ORDER STATUS ADVANCES TO "ITEMS BEING ADDED"
    #[test]
    fn add_product_to_order() {
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice.clone());

        testing_env!(context.build());

        let mut contract = Contract::new(alice.to_string());

        let owner = contract.get_owner();

        assert_eq!(owner, alice.to_string());

        contract.add_product("Nike Running Shoes".to_string(),
                "A great shoe for a good price".to_string(), 
                100);

        let count = contract.product_count();

        assert_eq!(count, 1);

        // make note second context is "NEAR" account not testnet

        let bob = AccountId::new_unchecked("bob.near".to_string());

        contract.register(bob.to_string(), "bobjones@gmail.com".to_string());

        let customer_count = contract.get_customers().len() as usize;

        assert_eq!(customer_count, 1);

        let new_context = get_context(bob.clone());

        testing_env!(new_context.build());

        contract.create_order(0);

        // Adds to the order

        contract.edit_order(0, 0, 0);

        let order_products = contract.get_products_in_order(0, 0).len() as usize;

        assert_eq!(order_products, 1);

        // SWITCH BACK TO FIRST CONTEXT FOR "OWNER"

        testing_env!(context.build());

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::ItemsBeingAdded, order_status);

    
    }

    //THIS TEST INITIALIZES CONTRACT AFTER DEPLOYMENT, AND
    // ALLOWS A CUSTOMER TO REGISTER,
    // CUSTOMER CREATES AN EMPTY ORDER
    // ORDER STATUS = "CREATED"
    // CUSTOMER ADDS A PRODUCT TO ORDER
    // ORDER STATUS ADVANCES TO "ITEMS BEING ADDED"
    // CUSTOMER FINALIZES ORDER
    // ORDER STATUS ADVANCES TO "CLIENT ORDER SUBMITTED"

    #[test]
    fn customer_finalize_order() {
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice.clone());

        testing_env!(context.build());

        let mut contract = Contract::new(alice.to_string());

        let owner = contract.get_owner();

        assert_eq!(owner, alice.to_string());

        contract.add_product("Nike Running Shoes".to_string(),
                "A great shoe for a good price".to_string(), 
                100);

        let count = contract.product_count();

        assert_eq!(count, 1);

        // make note second context is "NEAR" account not testnet

        let bob = AccountId::new_unchecked("bob.near".to_string());

        contract.register(bob.to_string(), "bobjones@gmail.com".to_string());

        let customer_count = contract.get_customers().len() as usize;

        assert_eq!(customer_count, 1);

        let new_context = get_context(bob.clone());

        testing_env!(new_context.build());

        contract.create_order(0);

        // Adds to the order

        contract.edit_order(0, 0, 0);

        let order_products = contract.get_products_in_order(0, 0).len() as usize;

        assert_eq!(order_products, 1);

        // SWITCH BACK TO FIRST CONTEXT FOR "OWNER"

        testing_env!(context.build());

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::ItemsBeingAdded, order_status);

        // SWITCH BACK TO BOB, APPROVE ORDER

        testing_env!(new_context.build());

        // CONFIRMS QTY OF PRODUCTS AS 1
        contract.cust_review_order(0, 0, 1);

        // SWITCH BACK TO FIRST CONTEXT FOR "OWNER"

        testing_env!(context.build());

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::ClientOrderSubmitted, order_status);

    
    }

    //THIS TEST INITIALIZES CONTRACT AFTER DEPLOYMENT, AND
    // ALLOWS A CUSTOMER TO REGISTER,
    // CUSTOMER CREATES AN EMPTY ORDER
    // ORDER STATUS = "CREATED"
    // CUSTOMER ADDS A PRODUCT TO ORDER
    // ORDER STATUS ADVANCES TO "ITEMS BEING ADDED"
    // CUSTOMER FINALIZES ORDER
    // ORDER STATUS ADVANCES TO "CLIENT ORDER SUBMITTED"
    // OWNER STARTS ASSEMBLING ORDER
    // ORDER STATUS ADVANCES TO "IN ASSEMBLY"
    #[test]
    fn admin_assemble_order() {
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice.clone());

        testing_env!(context.build());

        let mut contract = Contract::new(alice.to_string());

        let owner = contract.get_owner();

        assert_eq!(owner, alice.to_string());

        contract.add_product("Nike Running Shoes".to_string(),
                "A great shoe for a good price".to_string(), 
                100);

        let count = contract.product_count();

        assert_eq!(count, 1);

        // make note second context is "NEAR" account not testnet

        let bob = AccountId::new_unchecked("bob.near".to_string());

        contract.register(bob.to_string(), "bobjones@gmail.com".to_string());

        let customer_count = contract.get_customers().len() as usize;

        assert_eq!(customer_count, 1);

        let new_context = get_context(bob.clone());

        testing_env!(new_context.build());

        contract.create_order(0);

        // Adds to the order

        contract.edit_order(0, 0, 0);

        let order_products = contract.get_products_in_order(0, 0).len() as usize;

        assert_eq!(order_products, 1);

        // SWITCH BACK TO FIRST CONTEXT FOR "OWNER"

        testing_env!(context.build());

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::ItemsBeingAdded, order_status);

        // SWITCH BACK TO BOB, APPROVE ORDER

        testing_env!(new_context.build());

        // CONFIRMS QTY OF PRODUCTS AS 1
        contract.cust_review_order(0, 0, 1);

        // SWITCH BACK TO FIRST CONTEXT FOR "OWNER"

        testing_env!(context.build());

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::ClientOrderSubmitted, order_status);

        contract.assemble_order(0, 0);

        // CHECK ORDER STATUS AGAIN = "IN ASSEMBLY"

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::InAssembly, order_status);

    
    }

    //THIS TEST INITIALIZES CONTRACT AFTER DEPLOYMENT, AND
    // ALLOWS A CUSTOMER TO REGISTER,
    // CUSTOMER CREATES AN EMPTY ORDER
    // ORDER STATUS = "CREATED"
    // CUSTOMER ADDS A PRODUCT TO ORDER
    // ORDER STATUS ADVANCES TO "ITEMS BEING ADDED"
    // CUSTOMER FINALIZES ORDER
    // ORDER STATUS ADVANCES TO "CLIENT ORDER SUBMITTED"
    // OWNER STARTS ASSEMBLING ORDER
    // ORDER STATUS ADVANCES TO "IN ASSEMBLY"
    // OWNER VERIFIES ORDER
    // ORDER STATUS ADVANCES TO "ASSEMBLED"

    #[test]
    fn admin_verify_order() {
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice.clone());

        testing_env!(context.build());

        let mut contract = Contract::new(alice.to_string());

        let owner = contract.get_owner();

        assert_eq!(owner, alice.to_string());

        contract.add_product("Nike Running Shoes".to_string(),
                "A great shoe for a good price".to_string(), 
                100);

        let count = contract.product_count();

        assert_eq!(count, 1);

        // make note second context is "NEAR" account not testnet

        let bob = AccountId::new_unchecked("bob.near".to_string());

        contract.register(bob.to_string(), "bobjones@gmail.com".to_string());

        let customer_count = contract.get_customers().len() as usize;

        assert_eq!(customer_count, 1);

        let new_context = get_context(bob.clone());

        testing_env!(new_context.build());

        contract.create_order(0);

        // Adds to the order

        contract.edit_order(0, 0, 0);

        let order_products = contract.get_products_in_order(0, 0).len() as usize;

        assert_eq!(order_products, 1);

        // SWITCH BACK TO FIRST CONTEXT FOR "OWNER"

        testing_env!(context.build());

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::ItemsBeingAdded, order_status);

        // SWITCH BACK TO BOB, APPROVE ORDER

        testing_env!(new_context.build());

        // CONFIRMS QTY OF PRODUCTS AS 1
        contract.cust_review_order(0, 0, 1);

        // SWITCH BACK TO FIRST CONTEXT FOR "OWNER"

        testing_env!(context.build());

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::ClientOrderSubmitted, order_status);

        contract.assemble_order(0, 0);

        // CHECK ORDER STATUS AGAIN = "IN ASSEMBLY"

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::InAssembly, order_status);

        // ADMIN VERIFY ORDER

        contract.verify_order_admin(0, 0, 1);

        // CHECK ORDER STATUS AGAIN = "ASSEMBLED"

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::Assembled, order_status);

    
    }

    //THIS TEST INITIALIZES CONTRACT AFTER DEPLOYMENT, AND
    // ALLOWS A CUSTOMER TO REGISTER,
    // CUSTOMER CREATES AN EMPTY ORDER
    // ORDER STATUS = "CREATED"
    // CUSTOMER ADDS A PRODUCT TO ORDER
    // ORDER STATUS ADVANCES TO "ITEMS BEING ADDED"
    // CUSTOMER FINALIZES ORDER
    // ORDER STATUS ADVANCES TO "CLIENT ORDER SUBMITTED"
    // OWNER STARTS ASSEMBLING ORDER
    // ORDER STATUS ADVANCES TO "IN ASSEMBLY"
    // OWNER VERIFIES ORDER
    // ORDER STATUS ADVANCES TO "ASSEMBLED"
    // OWNER FINALIZES ORDER - READY TO SHIP
    // ORDER STATUS ADVANCES TO "READY TO SHIP"

    #[test]
    fn admin_ready_to_ship() {
        let alice = AccountId::new_unchecked("alice.testnet".to_string());
        // Set up the testing context and unit test environment
        let context = get_context(alice.clone());

        testing_env!(context.build());

        let mut contract = Contract::new(alice.to_string());

        let owner = contract.get_owner();

        assert_eq!(owner, alice.to_string());

        contract.add_product("Nike Running Shoes".to_string(),
                "A great shoe for a good price".to_string(), 
                100);

        let count = contract.product_count();

        assert_eq!(count, 1);

        // make note second context is "NEAR" account not testnet

        let bob = AccountId::new_unchecked("bob.near".to_string());

        contract.register(bob.to_string(), "bobjones@gmail.com".to_string());

        let customer_count = contract.get_customers().len() as usize;

        assert_eq!(customer_count, 1);

        let new_context = get_context(bob.clone());

        testing_env!(new_context.build());

        contract.create_order(0);

        // Adds to the order

        contract.edit_order(0, 0, 0);

        let order_products = contract.get_products_in_order(0, 0).len() as usize;

        assert_eq!(order_products, 1);

        // SWITCH BACK TO FIRST CONTEXT FOR "OWNER"

        testing_env!(context.build());

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::ItemsBeingAdded, order_status);

        // SWITCH BACK TO BOB, APPROVE ORDER

        testing_env!(new_context.build());

        // CONFIRMS QTY OF PRODUCTS AS 1
        contract.cust_review_order(0, 0, 1);

        // SWITCH BACK TO FIRST CONTEXT FOR "OWNER"

        testing_env!(context.build());

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::ClientOrderSubmitted, order_status);

        contract.assemble_order(0, 0);

        // CHECK ORDER STATUS AGAIN = "IN ASSEMBLY"

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::InAssembly, order_status);

        // ADMIN VERIFY ORDER

        contract.verify_order_admin(0, 0, 1);

        // CHECK ORDER STATUS AGAIN = "ASSEMBLED"

        let orders = contract.get_orders_by_customer(0);

        let first_order = &orders[0];

        let mut order_status = &first_order.status;

        assert_eq!(&OrderStatus::Assembled, order_status);

        // ADMIN "READY TO SHIP":

        contract.ready_to_ship(0, 0, true);

       // CHECK ORDER STATUS AGAIN = "READY TO SHIP"

       let orders = contract.get_orders_by_customer(0);

       let first_order = &orders[0];

       let mut order_status = &first_order.status;

       assert_eq!(&OrderStatus::ReadyToShip, order_status);

    
    }

    // TESTS COMPLETED - FOR ONE OWNER, ONE PRODUCT, ONE CUSTOMER, ONE ORDER.
    // FULL ORDER PROCESSING FROM "ORDER CREATED" TO "READY TO SHIP"

}

'''