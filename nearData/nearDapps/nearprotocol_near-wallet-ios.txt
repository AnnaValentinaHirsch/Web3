*GitHub Repository "nearprotocol/near-wallet-ios"*

'''--- NEARWallet/AppDelegate.swift ---
//
//  AppDelegate.swift
//  NEARWallet
//
//  Created by Vladimir Grichina on 5/22/20.
//  Copyright © 2020 NEAR Protocol. All rights reserved.
//

import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        // Override point for customization after application launch.
        return true
    }

    // MARK: UISceneSession Lifecycle

    func application(_ application: UIApplication, configurationForConnecting connectingSceneSession: UISceneSession, options: UIScene.ConnectionOptions) -> UISceneConfiguration {
        // Called when a new scene session is being created.
        // Use this method to select a configuration to create the new scene with.
        return UISceneConfiguration(name: "Default Configuration", sessionRole: connectingSceneSession.role)
    }

    func application(_ application: UIApplication, didDiscardSceneSessions sceneSessions: Set<UISceneSession>) {
        // Called when the user discards a scene session.
        // If any sessions were discarded while the application was not running, this will be called shortly after application:didFinishLaunchingWithOptions.
        // Use this method to release any resources that were specific to the discarded scenes, as they will not return.
    }

}

'''
'''--- NEARWallet/Assets.xcassets/AppIcon.appiconset/Contents.json ---
{
  "images" : [
    {
      "filename" : "40.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "60.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "20x20"
    },
    {
      "filename" : "29.png",
      "idiom" : "iphone",
      "scale" : "1x",
      "size" : "29x29"
    },
    {
      "filename" : "58.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "87.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "29x29"
    },
    {
      "filename" : "80.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "120.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "40x40"
    },
    {
      "filename" : "57.png",
      "idiom" : "iphone",
      "scale" : "1x",
      "size" : "57x57"
    },
    {
      "filename" : "114.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "57x57"
    },
    {
      "filename" : "120.png",
      "idiom" : "iphone",
      "scale" : "2x",
      "size" : "60x60"
    },
    {
      "filename" : "180.png",
      "idiom" : "iphone",
      "scale" : "3x",
      "size" : "60x60"
    },
    {
      "filename" : "20.png",
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "20x20"
    },
    {
      "filename" : "40.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "20x20"
    },
    {
      "filename" : "29.png",
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "29x29"
    },
    {
      "filename" : "58.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "29x29"
    },
    {
      "filename" : "40.png",
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "40x40"
    },
    {
      "filename" : "80.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "40x40"
    },
    {
      "filename" : "50.png",
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "50x50"
    },
    {
      "filename" : "100.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "50x50"
    },
    {
      "filename" : "72.png",
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "72x72"
    },
    {
      "filename" : "144.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "72x72"
    },
    {
      "filename" : "76.png",
      "idiom" : "ipad",
      "scale" : "1x",
      "size" : "76x76"
    },
    {
      "filename" : "152.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "76x76"
    },
    {
      "filename" : "167.png",
      "idiom" : "ipad",
      "scale" : "2x",
      "size" : "83.5x83.5"
    },
    {
      "filename" : "1024.png",
      "idiom" : "ios-marketing",
      "scale" : "1x",
      "size" : "1024x1024"
    }
  ],
  "info" : {
    "author" : "xcode",
    "version" : 1
  }
}

'''
'''--- NEARWallet/Assets.xcassets/Contents.json ---
{
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
'''
'''--- NEARWallet/SceneDelegate.swift ---
//
//  SceneDelegate.swift
//  NEARWallet
//
//  Created by Vladimir Grichina on 5/22/20.
//  Copyright © 2020 NEAR Protocol. All rights reserved.
//

import UIKit

class SceneDelegate: UIResponder, UIWindowSceneDelegate {

    var window: UIWindow?

    func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
        // Use this method to optionally configure and attach the UIWindow `window` to the provided UIWindowScene `scene`.
        // If using a storyboard, the `window` property will automatically be initialized and attached to the scene.
        // This delegate does not imply the connecting scene or session are new (see `application:configurationForConnectingSceneSession` instead).
        guard let _ = (scene as? UIWindowScene) else { return }
    }

    func sceneDidDisconnect(_ scene: UIScene) {
        // Called as the scene is being released by the system.
        // This occurs shortly after the scene enters the background, or when its session is discarded.
        // Release any resources associated with this scene that can be re-created the next time the scene connects.
        // The scene may re-connect later, as its session was not neccessarily discarded (see `application:didDiscardSceneSessions` instead).
    }

    func sceneDidBecomeActive(_ scene: UIScene) {
        // Called when the scene has moved from an inactive state to an active state.
        // Use this method to restart any tasks that were paused (or not yet started) when the scene was inactive.
    }

    func sceneWillResignActive(_ scene: UIScene) {
        // Called when the scene will move from an active state to an inactive state.
        // This may occur due to temporary interruptions (ex. an incoming phone call).
    }

    func sceneWillEnterForeground(_ scene: UIScene) {
        // Called as the scene transitions from the background to the foreground.
        // Use this method to undo the changes made on entering the background.
    }

    func sceneDidEnterBackground(_ scene: UIScene) {
        // Called as the scene transitions from the foreground to the background.
        // Use this method to save data, release shared resources, and store enough scene-specific state information
        // to restore the scene back to its current state.
    }

}

'''
'''--- NEARWallet/ViewController.swift ---
//
//  ViewController.swift
//  NEARWallet
//
//  Created by Vladimir Grichina on 5/22/20.
//  Copyright © 2020 NEAR Protocol. All rights reserved.
//

import UIKit
import WebKit
import nearclientios
import PromiseKit
import AwaitKit

extension WKWebView {
    func load(_ urlString: String) {
        if let url = URL(string: urlString) {
            let request = URLRequest(url: url)
            load(request)
        }
    }
}

//let WALLET_URL = "https://wallet.testnet.near.org"

let WALLET_URL = "https://near-wallet-pr-636.onrender.com"

class ViewController: UIViewController, WKScriptMessageHandler, WKNavigationDelegate {

    lazy var signer: Signer = {
        return InMemorySigner(keyStore: KeychainKeyStore())
    }()

    let contentController = WKUserContentController()
    lazy var webView: WKWebView = {
        self.contentController.add(self, name: "signer")
        let config = WKWebViewConfiguration()
        config.userContentController = self.contentController
        return WKWebView(frame: CGRect.zero, configuration: config)
    }()

    override func loadView() {
        self.view = webView
        webView.navigationDelegate = self

        webView.load(WALLET_URL)
    }

    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) {
        print("message.body type: \(type(of: message.body))")
        print("message: \((message.body as! NSObject).description.prefix(500))")
        if let body = message.body as? NSDictionary {
            let method = body["methodName"]! as! String
            let args = body["args"]! as! NSDictionary
            let requestId = body["requestId"]! as! NSNumber

            switch method {
            case "createKey":
                returnResult(requestId: requestId,
                             result: self.createKey(accountId: args["accountId"]! as! String,
                                                    networkId: args["networkId"]! as! String))
            case "getPublicKey":
                returnResult(requestId: requestId,
                             result: self.getPublicKey(accountId: args["accountId"]! as! String,
                                                       networkId: args["networkId"]! as! String))
            case "signMessage":
                returnResult(requestId: requestId,
                             result: self.signMessage(message: args["message"]! as! String, accountId: args["accountId"]! as! String,
                                                    networkId: args["networkId"]! as! String))

            default:
                print("unknown method: \(method)")
            }
        }
    }

    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        if let url = navigationAction.request.url {
            if navigationAction.navigationType == .linkActivated && !url.absoluteString.starts(with: WALLET_URL) {
                UIApplication.shared.open(url)
                decisionHandler(.cancel)
                return
            }
        }

        decisionHandler(.allow)
    }

    func returnResult<T>(requestId: NSNumber, result: Promise<T>) -> Void where T : Encodable {
        firstly {
            result
        }.done { resultValue in
            let encoder = JSONEncoder()
            // TODO: Handle errors and pass to JS
            if let jsonData = try? encoder.encode(resultValue) {
                if let jsonString = String(data: jsonData, encoding: .utf8) {
                    let jsCallback = "__walletCallback({ requestId: \(requestId),  result: \(jsonString)})"
                    print("jsCallback: \(jsCallback)")
                    self.webView.evaluateJavaScript(jsCallback  ) { (jsResult, jsError) in
                        print("jsResult: \(jsResult) jsError: \(jsError)")
                    }
                }
            }
        }.catch { _ in
            // TODO: Pass errors back to JS
        }
    }

    func createKey(accountId: String, networkId: String) -> Promise<String> {
        return async {
            let publicKey = try await(self.signer.createKey(accountId: accountId, networkId: networkId))
            return publicKey.toString()
        }
    }

    func getPublicKey(accountId: String, networkId: String) -> Promise<String?> {
        return async {
            if let publicKey = try await(self.signer.getPublicKey(accountId: accountId, networkId: networkId)) {
                return publicKey.toString()
            }

            return nil
        }
    }

    func signMessage(message: String, accountId: String, networkId: String) -> Promise<String> {
        return async {
            let messageData = Data(base64Encoded: message)!
            let signature = try! await(self.signer.signMessage(message: [UInt8](messageData), accountId: accountId, networkId: networkId))
            // TODO: Make sure errors (like key not available) propagated properly
            return Data(signature.signature).base64EncodedString()
        }
    }
}

'''