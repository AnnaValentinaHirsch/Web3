*GitHub Repository "Learn-NEAR-Club/ncaptcha-gravity-addon"*

'''--- Controllers/FieldsController.php ---
<?php

namespace LNCNcaptchaGravityAddon\Controllers;

use LNCNcaptchaGravityAddon\Model\Fields\NearPayableField;
use LNCNcaptchaGravityAddon\Model\Fields\NearTransactionField;
class FieldsController
{
    public function __construct()
    {
        $this->createFields();
    }
    public function createFields()
    {
        \GF_Fields::register(new NearPayableField());
        \GF_Fields::register(new NearTransactionField());
    }
}

'''
'''--- Controllers/PageConstructor.php ---
<?php

namespace LNCNcaptchaGravityAddon\Controllers;

use LNCNcaptchaGravityAddon\Model\Constructor\ConfigPage;

/**
 * Class PageConstructor
 * @package LNCNcaptchaGravityAddon
 */
class PageConstructor
{
    /**
     * pages pool
     *
     * @var array
     */
    protected array $pages = [];

    /**
     * PageConstructor constructor.
     * @param $config
     */
    public function __construct($config)
    {
        $this->pageCreator($config);
    }

    /**
     * @param $config
     */
    protected function pageCreator($config): void
    {
        $this->pages['config'] = new ConfigPage($config);
    }
}

'''
'''--- Helper/FormData.php ---
<?php

namespace LNCNcaptchaGravityAddon\Helper;

/**
 * Class FormData
 * @package LNCNearComments\Helper
 */
class FormData
{
    public static function getAllowedTagsForFormEscape(): array
    {
        $allowedAtts = [
            'align' => [],
            'min' => [],
            'max' => [],
            'step' => [],
            'class' => [],
            'type' => [],
            'id' => [],
            'dir' => [],
            'lang' => [],
            'style' => [],
            'xml:lang' => [],
            'src' => [],
            'alt' => [],
            'href' => [],
            'rel' => [],
            'rev' => [],
            'target' => [],
            'novalidate' => [],
            'value' => [],
            'name' => [],
            'tabindex' => [],
            'action' => [],
            'method' => [],
            'for' => [],
            'width' => [],
            'height' => [],
            'data' => [],
            'title' => [],
            'selected' => [],
        ];
        return [
            'h1' => $allowedAtts,
            'label' => $allowedAtts,
            'form' => $allowedAtts,
            'input' => $allowedAtts,
            'button' => $allowedAtts,
            'div' => $allowedAtts,
            'select' => $allowedAtts,
            'option' => $allowedAtts,
        ];
    }
}

'''
'''--- Helper/View.php ---
<?php

namespace LNCNcaptchaGravityAddon\Helper;

use LNCNcaptchaGravityAddon\Model\Config;

/**
 * Class View
 *
 * @package LNCNcaptchaGravityAddon\Helper
 */
class View
{
    protected static Config $config;

    /**
     * Method to render template
     *
     * WARNING do not remove  @args It's need to transfer self object, when function calls by hook.
     *
     * @param $templatePath
     * @param $args
     * @return bool
     */
    public static function view($templatePath, $args = null): bool
    {
        try {
            $error = __('You have some problems with template');
            if (!file_exists($templatePath)) {
                throw new \Exception($error);
            }
            $content = require_once($templatePath);
            if ($content != '') {
                echo wp_kses($content, FormData::getAllowedTagsForFormEscape());
                return true;
            }
            throw new \Exception($error);
        } catch (\Exception $e) {
            echo esc_html($e->getMessage());
        }
        return false;
    }

    final protected static function getConfig()
    {
        if (!self::$config) {
            self::$config = new Config();
        }
        return self::$config;
    }

    final public static function renderParts($templateName, $data = null)
    {

        $templatePath = self::getConfig()->getTemplatesPath()
            . '/frontend/template-parts/'
            . $templateName;
        try {
            $error = __('You have some problems with template');
            if (!file_exists($templatePath)) {
                throw new \Exception($error);
            }
            $content = require($templatePath);
            if ($content != '') {
                return $content;
            }
            throw new \Exception($error);
        } catch (\Exception $e) {
            return $e->getMessage();
        }
    }
}

'''
'''--- Model/Abstractions/AdminPages.php ---
<?php

namespace LNCNcaptchaGravityAddon\Model\Abstractions;

/**
 * Class AdminPages
 *
 * @package LNCNcaptchaGravityAddon\Model\Abstractions
 */
abstract class AdminPages
{
    /**
     * AdminPages constructor.
     */
    public function __construct()
    {
        add_action('admin_menu', [&$this, 'addAdminPage']);
        add_action('admin_init', [&$this, 'registerSettings']);
    }

    /**
     * Method to register settings
     *
     */
    abstract public function registerSettings();

    /**
     * Method to display settings page.
     *
     */
    abstract public function displaySettingsPage();

    /**
     * Method to add Admin page
     *
     * @return void
     */
    abstract public function addAdminPage();
}

'''
'''--- Model/Config.php ---
<?php

namespace LNCNcaptchaGravityAddon\Model;

/**
 * Class Config
 * @package LNCNcaptchaGravityAddon\Model
 */
class Config
{
    /**
     * Plugin name
     */
    const PLUGIN_NAME = 'lnc-ncaptcha-gravity-addon';

    /**
     *  Views directory const
     */
    const VIEWS_DIR = 'views';

    /**
     *  default language
     */
    const DEFAULT_LANG = 'en';

    /**
     * Templates dir const
     */
    const TEMPLATES_DIR = 'templates';

    /**
     * Plugin base path
     *
     * @var string $_basePath
     */
    private string $_basePath;

    /**
     * Path to views directory
     * @var string $_viewsPath
     */
    private string $_viewsPath;

    /**
     * Path to scripts directory
     * @var string $_scriptsPath
     */
    private string $_scriptsPath;

    /**
     * Path to templates.
     *
     * @var $_templatesPath
     */
    private string $_templatesPath;

    /**
     * @var $_config
     */
    public $config;

    /**
     * Config constructor.
     */
    public function __construct()
    {
        $this->_setPaths();
    }

    /**
     * Method to set default plugin paths for DI
     */
    private function _setPaths()
    {
        $this->_basePath = plugin_dir_path(__DIR__);
        $this->_viewsPath = self::getBasePath() . self::VIEWS_DIR;
        $this->_scriptsPath = plugin_dir_url(__DIR__) . '/public/';
        $this->_templatesPath = self::getBasePath() . self::TEMPLATES_DIR;
    }

    /**
     * Method to get plugin name
     *
     * @return string
     */
    public function getPluginName(): string
    {
        return self::PLUGIN_NAME;
    }

    /**
     * Method to get base plugin path
     *
     * @return string
     */
    public function getBasePath(): string
    {
        return $this->_basePath;
    }

    /**
     * Method to get path to template directory
     *
     * @return string
     */
    public function getViewsPath(): string
    {
        return $this->_viewsPath;
    }

    /**
     * Method to get path to scripts directory
     *
     * @return string
     */
    public function getScriptsPath(): string
    {
        return $this->_scriptsPath;
    }

    /**
     * Path to templates dir.
     *
     * @return string
     */
    public function getTemplatesPath(): string
    {
        return $this->_templatesPath;
    }

    /**
     * Method to get Default lang
     *
     * @return string
     */
    public function getDefaultLang(): string
    {
        return self::DEFAULT_LANG;
    }

    /**
     * Method to get config from file.
     *
     * @param $file
     * @param string $dir
     * @return array|mixed|object
     */
    public function getConfig($file, string $dir = '')
    {
        if ($dir != '') {
            $file = $this->getBasePath() . 'config/' . $dir . '/' . $file . '.json';
        } else {
            $file = $this->getBasePath() . 'config/' . $file . '.json';
        }
        if (file_exists($file)) {
            $this->config = json_decode(file_get_contents($file), true);
        } else {
            $this->config = [];
        }
        return $this->config;
    }
}

'''
'''--- Model/Constructor/ConfigPage.php ---
<?php

namespace LNCNcaptchaGravityAddon\Model\Constructor;

use LNCNcaptchaGravityAddon\Model\Abstractions\AdminPages;
use LNCNcaptchaGravityAddon\Helper\View;
use LNCNcaptchaGravityAddon\Model\Config;

/**
 * Class ConfigPage
 * @package LNCNcaptchaGravityAddon\Model\Constructor
 */
class ConfigPage extends AdminPages
{
    const OPTIONS_GROUP = 'lnc-n-captcha-config';
    const FILE_EXTENSION = 'php';

    private Config $config;

    public string $optionsGroup;

    public function __construct($config)
    {
        parent::__construct();
        $this->config = $config;
        $this->optionsGroup = $this->getOptionsGroup();
        $this->setUp();
    }

    public function addAdminPage(): void
    {
        add_menu_page(
            'nCaptcha config',
            'nCaptcha config',
            'manage_options',
            'n_captcha_config',
            [$this, 'displaySettingsPage']
        );
    }

    public function setUp(): void
    {
        add_filter('getLNCNCaptchaOptions', [$this, 'getOptions']);
        add_action('admin_init', [$this, 'registerSettings']);
    }

    public function getOptionsGroup(): string
    {
        return self::OPTIONS_GROUP;
    }

    public function registerSettings(): void
    {
        register_setting(
            $this->optionsGroup,
            $this->optionsGroup,
            [$this, 'validateFields']
        );
    }

    public function displaySettingsPage(): void
    {
        $path = $this->config->getTemplatesPath(). '/' . self::OPTIONS_GROUP . '.' . self::FILE_EXTENSION;
        View::view($path, $this);
    }

    public function getOptions()
    {
        return get_option($this->optionsGroup);
    }

    public function validateFields($fields): array
    {
        $validatedFields = [];

        foreach ($fields as $key => $value) {
            if ($key === 'site_owner') {
                if (!preg_match('/^.+\.near$/', $value)) {
                    add_settings_error(
                        $key,
                        'incorrect_site_owner',
                        __('Site owner should be a valid named near wallet like any.near')
                    );
                } else {
                    $validatedFields[$key] = $value;
                }
            } else {
                $validatedFields[$key] = $value;
            }
        }
        return $validatedFields;
    }
}

'''
'''--- Model/Constructor/Constructor.php ---
<?php

namespace LNCNcaptchaGravityAddon\Model\Constructor;

use LNCNcaptchaGravityAddon\Controllers\FieldsController;
use LNCNcaptchaGravityAddon\Controllers\PageConstructor;
use LNCNcaptchaGravityAddon\Model\Config;

/**
 * Init all main functionality
 *
 * Class Constructor
 * @package LNCNcaptchaGravityAddon\Model\Constructor
 */
class Constructor
{
    /**
     * Self Constructor object.
     * @var $instance
     */
    private static Constructor $instance;

    /**
     * Plugin options
     *
     * @var mixed
     */
    public static mixed $options;

    /**
     * @var Config
     */
    private Config $config;

    /**
     * protect singleton  clone
     */
    private function __clone()
    {

    }

    /**
     * Method to use native functions as methods
     *
     * @param $name
     * @param $arguments
     * @return bool|mixed
     */
    public function __call($name, $arguments)
    {
        if (function_exists($name)) {
            return call_user_func_array($name, $arguments);
        }
        return false;
    }

    /**
     * protect singleton __wakeup
     */
    public function __wakeup()
    {

    }

    private function __construct()
    {
        $this->config = new Config();
        new PageConstructor($this->config);
        self::$options = apply_filters('getLNCNCaptchaOptions', 'options');

        $this->setUpActions();
    }
    public function addFrontendStuffs(): void
    {
        $this->initFrontendControllers();
    }

    /**
     * Method to register plugin scripts
     */
    public function addScripts(): void
    {
        wp_enqueue_script(
            'lnc-n-captcha-gravity-addon',
            $this->config->getScriptsPath() . 'index.js',
            ['jquery'],
            time(),
            true
        );
    }

    protected function initFrontendControllers(): void
    {
        new FieldsController();
    }

    /**
     * Method to set up WP actions.
     */
    private function setUpActions(): void
    {
        add_action('init', [&$this, 'addFrontendStuffs']);

        if (is_admin()) {
            add_filter('gform_field_content', [$this, 'modifyTransactionView'], 10, 5);
            add_filter('gform_entries_field_value', [$this, 'modifyTransactionViewValue'], 10, 5);
        }

        if (!is_admin()) {
            add_action('init', [$this, 'addScripts']);
        }
    }

    public function modifyTransactionView($content, $field, $value, $leadID, $formID)
    {
        if ($field->type == 'nCaptcha_transaction') {
            $content = '
                        <tr>
                            <td colspan="2" class="entry-view-field-name">nCaptcha Transaction</td>
                        </tr>
                        <tr>
                            <td colspan="2" class="entry-view-field-value lastrow"><a href="https://explorer.mainnet.near.org/transactions/' . $value . '">' . $value . '</a></td>
                        </tr>';
        }

        return $content;
    }

    public function modifyTransactionViewValue($value, $formID, $fieldID, $entry)
    {
        $form = \GFAPI::get_form($formID);
        $field = \GFFormsModel::get_field($form, $fieldID);

        if ($field->type == 'nCaptcha_transaction') {
            $value = "<a href='https://explorer.mainnet.near.org/transactions/{$value}'>{$value}</a>";
        }

        return $value;
    }

    /**
     * Get self object
     *
     * @return Constructor object
     */
    public static function getInstance(): Constructor
    {
        if (empty(self::$instance)) {
            self::$instance = new self();
        }
        return self::$instance;
    }
}

'''
'''--- Model/Fields/NearPayableField.php ---
<?php

namespace LNCNcaptchaGravityAddon\Model\Fields;

use LNCNcaptchaGravityAddon\Model\Constructor\Constructor;

class NearPayableField extends \GF_Field_Hidden
{
    public $type = 'nCaptcha_field';

    public function get_form_editor_field_settings(): array
    {
        $settings = parent::get_form_editor_field_settings();

        $settings[] = [
            'nCaptchaOwner' => [
                'type' => 'text',
                'label' => esc_html__('nCaptcha Owner', 'lnc-ncaptcha-gravity-addon'),
                'name' => 'nCaptchaOwner',
                'tooltip' => esc_html__('Specify the owner of the nCaptcha field.', 'lnc-ncaptcha-gravity-addon'),
            ],
        ];

        return $settings;
    }

    public function sanitize_settings(): void
    {
        parent::sanitize_settings();
        $this->label = 'nCaptcha';
        $this->adminLabel = 'nCaptcha';
    }

    public function get_form_editor_field_title(): string
    {
        return esc_attr__('nCaptcha', 'lnc-ncaptcha-gravity-addon');
    }

    public function get_form_editor_button(): array
    {
        return [
            'group' => 'advanced_fields',
            'text' => $this->get_form_editor_field_title()
        ];
    }

    public function __construct($data = array())
    {
        parent::__construct($data);
    }

    public function get_field_input($form, $value = '', $entry = null): string
    {
        $form_id = esc_html($form['id']);
        $is_entry_detail = $this->is_entry_detail();
        $is_form_editor = $this->is_form_editor();

        $id = (int)$this->id;
        $field_id = $is_entry_detail || $is_form_editor || $form_id == 0 ? "input_$id" : 'input_' . $form_id . "_$id";

        $disabled_text = $is_form_editor ? 'disabled="disabled"' : '';

        $field_type = $is_entry_detail || $is_form_editor ? 'text' : 'hidden';
        $class_attribute = $is_entry_detail || $is_form_editor ? '' : "class='gform_hidden'";
        $required_attribute = $this->isRequired ? 'aria-required="true"' : '';
        $invalid_attribute = $this->failed_validation ? 'aria-invalid="true"' : 'aria-invalid="false"';

        $configOptions = Constructor::$options;
        $nCaptchaOwner = $configOptions['nCaptcha_owner'] ?? 'partners.learnclub.near';
        $nCaptcha = "<div id='nCaptcha-verification' data-account='{$nCaptchaOwner}' data-price='{$value}'></div>";

        $toShow = $nCaptcha;
        if (is_plugin_active('near-login/index.php') && !get_current_user_id()) {
            $nLogin = do_shortcode('[login_near_link]');
            $toShow =  $nLogin;
        }

        $input = sprintf("<input class='nCaptcha-input-field' name='input_%d' id='%s' type='$field_type' {$class_attribute} {$required_attribute} {$invalid_attribute} value='%s' %s/>", $id, $field_id, esc_attr($value), $disabled_text);
        if (is_admin()) {
            return sprintf("<div class='ginput_container ginput_container_text'>
            %s
            </div>", $input);
        }
        return "<div class='ginput_container ginput_container_text'>
                        {$toShow}
                        {$input}
                </div>";
    }

}
'''
'''--- Model/Fields/NearTransactionField.php ---
<?php

namespace LNCNcaptchaGravityAddon\Model\Fields;

class NearTransactionField extends \GF_Field_Hidden
{
    public $type = 'nCaptcha_transaction';

    function get_form_editor_field_settings(): array
    {
        return [...parent::get_form_editor_field_settings(), 'rules_setting'];
    }

    public function sanitize_settings(): void
    {
        parent::sanitize_settings();
        $this->label = 'nCaptcha Transaction';
        $this->adminLabel = 'nCaptcha Transaction';
    }

    public function get_form_editor_field_title(): string
    {
        return esc_attr__('nCaptcha Transaction', 'lnc-ncaptcha-gravity-addon');
    }

    public function get_form_editor_button(): array
    {
        return [
            'group' => 'advanced_fields',
            'text' => $this->get_form_editor_field_title()
        ];
    }
    public function __construct($data = array())
    {
        parent::__construct($data);
        add_filter('gform_validation_message', function ($message, $form) {
            if (gf_upgrade()->get_submissions_block()) {
                return $message;
            }

            foreach ($form['fields'] as $field) {
                if ($field->type == 'nCaptcha_transaction' && $field->failed_validation) {
                    return "<h2 class='gform_submission_error hide_summary'><span class='gform-icon gform-icon--close'></span>Verification with nCaptcha is failed, please try again.</h2>";
                }
            }

            return $message;
        }, 10, 2);
    }

    public function get_field_input($form, $value = '', $entry = null): string
    {
        $form_id = esc_html($form['id']);
        $is_entry_detail = $this->is_entry_detail();
        $is_form_editor = $this->is_form_editor();

        $id = (int)$this->id;
        $field_id = $is_entry_detail || $is_form_editor || $form_id == 0 ? "input_$id" : 'input_' . $form_id . "_$id";

        $disabled_text = $is_form_editor ? 'disabled="disabled"' : '';

        $field_type = $is_entry_detail || $is_form_editor ? 'text' : 'hidden';
        $class_attribute = $is_entry_detail || $is_form_editor ? '' : "class='gform_hidden'";
        $required_attribute = $this->isRequired ? 'aria-required="true"' : '';
        $invalid_attribute = $this->failed_validation ? 'aria-invalid="true"' : 'aria-invalid="false"';

        $input = sprintf("<input class='nCaptcha-transaction-field' name='input_%d' id='%s' type='$field_type' {$class_attribute} {$required_attribute} {$invalid_attribute} value='%s' %s/>", $id, $field_id, esc_attr($value), $disabled_text);

        return sprintf("<div class='ginput_container ginput_container_text'>%s</div>", $input);
    }
}
'''
'''--- composer.json ---
{
  "name": "lnc/ncaptcha-gravity-addon",
  "description": "nCaptcha",
  "license": "MIT",
  "authors": [
    {
      "name": "stevenakni",
      "email": "stevenaknidev@gmail.com"
    }
  ],
  "minimum-stability": "stable",
  "require": {
  },
  "autoload": {
    "psr-4": {
      "LNCNcaptchaGravityAddon\\": ""
    }
  }
}

'''
'''--- index.php ---
<?php
/**
 * Plugin Name: LNC nCaptcha Add-on for Gravity Forms
 * Description: LNC nCaptcha Add-on for Gravity Forms provides nCaptcha for gravity form
 * Version: 0.0.1
 * Author: LNC
 * Author URI: http://learnnear.club/
 */

use LNCNcaptchaGravityAddon\Model\Constructor\Constructor;

if (!defined('ABSPATH')) exit; // Exit if accessed directly

if (!function_exists('is_plugin_active')) {
    include_once(ABSPATH . 'wp-admin/includes/plugin.php');
}

try {
    $composerLoader = __DIR__ . '/vendor/autoload.php';
    if (file_exists($composerLoader)) {
        require_once $composerLoader;
    } else {
        throw new Exception(__('Install the composer for current work', 'lnc-ncaptcha-gravity-addon'));
    }
    if (!is_plugin_active('gravityforms/gravityforms.php')) {
        throw new Exception(__('Gravity forms plugin must be enabled'));
    }
    Constructor::getInstance();
} catch (Exception $exception) {
    deactivate_plugins('lnc-ncaptcha-gravity-addon/index.php');
    add_action('admin_notices', function () use ($exception) {
        echo '<div class="error"><p>' . esc_html($exception->getMessage()) . '</p></div>';
    });
}

$constructor = Constructor::getInstance();

'''
'''--- readme.txt ---
=== LNC nCaptcha Add-on for Gravity Forms  ===
Tags: Near, comments, nCaptcha, web3, blockchain
Requires at least: 6.0.1
Tested up to: 6.2.2
Stable tag: 0.0.1
License: GPLv2 or later
License URI: http://www.gnu.org/licenses/gpl-2.0.html

nCaptcha Gravity addon is advanced captcha system prevents spam and bots from infiltrating your site,
by integration with near web3 smart contract with nCaptcha service, integrated to you Gravity Forms plugin.

== Description ==

nCaptcha Gravity addon is a part of WordPress integration with web3 near blockchain protocol. This plugin provides a specific captcha for the gravity form
forms and approving submissions after a small tip transaction to https://explorer.mainnet.near.org/accounts/v1.ncaptcha.near smart contract. As a site owner, you can earn money with our plugin! Our unique payment system allows you to receive a portion of the payment for each captcha solved by your users. So not only will you be protecting your site, but you'll also be generating extra revenue at the same time.
Revenue is configurable on your side. So all that you need is get original gravity form and our nCaptcha addon plugin, register near wallet and install it to your site for spam protection, money earning and joining web3!

== Installation ==
1. Install core gravity form plugin from https://www.gravityforms.com/
2. (Optional) Install our core login with near plugin to synchronize user wallets with your site https://wordpress.org/plugins/near-login/. This plugin also works without this step.
2. Upload the plugin files to the `/wp-content/plugins/lnc-ncaptcha-gravity-addon` directory, or install the plugin through the WordPress plugins screen directly.
3. Activate the gravity form plugin and this plugin through the 'Plugins' screen in WordPress.
4. Provide your wallet, reward value to n_captcha_config settings
5. Create gravity form with nCaptcha and nCaptcha transaction fields
5. Join the results

== Screenshots ==

1. Fill the plugin settings nCaptcha owner - your near wallet. screenshot-1.png.
2. Create form using nCaptcha and nCaptcha transaction fields screenshot-2.png.
3. Add nCaptcha price screenshot-3.png.
4. Now nCaptcha is provided. Here is a flow: screenshot-4.png, screenshot-5.png, screenshot-6.png, screenshot-7.png, screenshot-8.png

== Important Notes ==

1. Compatibility: Our plugin has been tested and designed to work with the latest version of WordPress. It is important that you update your WordPress installation before using our plugin to ensure compatibility.
2. Dependencies: Our plugin require https://www.gravityforms.com/ to function properly. Please refer to the plugin documentation for any necessary dependencies and installation instructions.
3. Specific behavior: 70% functionality of plugin based on client javascript. So please keep in mind, that without enabled javascript nCaptcha will not protect your forms.

== Changelog ==

= 0.0.1 =
* Initial release.
'''
'''--- templates/lnc-n-captcha-config.php ---
<?php
if (!defined('ABSPATH')) exit; // Exit if accessed directly

use LNCNcaptchaGravityAddon\Model\Constructor\Constructor;

ob_start();
?>
<?php if (isset($args) && isset($args->optionsGroup)): ?>
    <?php
    $options = Constructor::$options;
    $nCaptchaOwner = $options['nCaptcha_owner'] ?? '';
    $result = get_settings_errors();
    $noticeClass = 'notice-error';
    ?>
    <div class="wrap">
        <h1><?php esc_html_e('LNC Near comments configurations', 'lnc-n-comments'); ?></h1>
        <?php if (isset($result[0]['message']) && isset($result[0]['code'])): ?>
            <?php if ($result[0]['code'] === 'settings_updated') {
                $noticeClass = 'notice-success';
            }
            ?>
            <div class="notice <?php echo esc_html($noticeClass); ?>">
                <p><?php echo esc_html($result[0]['message']); ?></p>
            </div>
        <?php endif; ?>
        <form method="post" action="options.php" class="settings-form">
            <?php settings_fields($args->optionsGroup); ?>
            <div class="form-table">
                <div class="form-group">
                    <label for="site-owner"><?php _e('nCaptcha owner'); ?></label>
                    <input type="text" id="nCaptcha-owner"
                           name="<?php echo esc_html("$args->optionsGroup[nCaptcha_owner]"); ?>"
                           value="<?php echo esc_html($nCaptchaOwner); ?>" class="regular-text"/>
                </div>
            </div>
            <div class="form-table">
                <div class="form-group">
                    <button type="submit"
                            class="button button-primary button-large"><?php _e('Save', 'lnc-ncaptcha-gravity-addon'); ?></button>
                </div>
            </div>
        </form>
    </div>
<?php endif; ?>
<?php return ob_get_clean(); ?>

'''
'''--- vendor/autoload.php ---
<?php

// autoload.php @generated by Composer

require_once __DIR__ . '/composer/autoload_real.php';

return ComposerAutoloaderInit9e9797f0af59c06a869717ef63707526::getLoader();

'''
'''--- vendor/composer/ClassLoader.php ---
<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer\Autoload;

/**
 * ClassLoader implements a PSR-0, PSR-4 and classmap class loader.
 *
 *     $loader = new \Composer\Autoload\ClassLoader();
 *
 *     // register classes with namespaces
 *     $loader->add('Symfony\Component', __DIR__.'/component');
 *     $loader->add('Symfony',           __DIR__.'/framework');
 *
 *     // activate the autoloader
 *     $loader->register();
 *
 *     // to enable searching the include path (eg. for PEAR packages)
 *     $loader->setUseIncludePath(true);
 *
 * In this example, if you try to use a class in the Symfony\Component
 * namespace or one of its children (Symfony\Component\Console for instance),
 * the autoloader will first look for the class under the component/
 * directory, and it will then fallback to the framework/ directory if not
 * found before giving up.
 *
 * This class is loosely based on the Symfony UniversalClassLoader.
 *
 * @author Fabien Potencier <fabien@symfony.com>
 * @author Jordi Boggiano <j.boggiano@seld.be>
 * @see    https://www.php-fig.org/psr/psr-0/
 * @see    https://www.php-fig.org/psr/psr-4/
 */
class ClassLoader
{
    /** @var ?string */
    private $vendorDir;

    // PSR-4
    /**
     * @var array[]
     * @psalm-var array<string, array<string, int>>
     */
    private $prefixLengthsPsr4 = array();
    /**
     * @var array[]
     * @psalm-var array<string, array<int, string>>
     */
    private $prefixDirsPsr4 = array();
    /**
     * @var array[]
     * @psalm-var array<string, string>
     */
    private $fallbackDirsPsr4 = array();

    // PSR-0
    /**
     * @var array[]
     * @psalm-var array<string, array<string, string[]>>
     */
    private $prefixesPsr0 = array();
    /**
     * @var array[]
     * @psalm-var array<string, string>
     */
    private $fallbackDirsPsr0 = array();

    /** @var bool */
    private $useIncludePath = false;

    /**
     * @var string[]
     * @psalm-var array<string, string>
     */
    private $classMap = array();

    /** @var bool */
    private $classMapAuthoritative = false;

    /**
     * @var bool[]
     * @psalm-var array<string, bool>
     */
    private $missingClasses = array();

    /** @var ?string */
    private $apcuPrefix;

    /**
     * @var self[]
     */
    private static $registeredLoaders = array();

    /**
     * @param ?string $vendorDir
     */
    public function __construct($vendorDir = null)
    {
        $this->vendorDir = $vendorDir;
    }

    /**
     * @return string[]
     */
    public function getPrefixes()
    {
        if (!empty($this->prefixesPsr0)) {
            return call_user_func_array('array_merge', array_values($this->prefixesPsr0));
        }

        return array();
    }

    /**
     * @return array[]
     * @psalm-return array<string, array<int, string>>
     */
    public function getPrefixesPsr4()
    {
        return $this->prefixDirsPsr4;
    }

    /**
     * @return array[]
     * @psalm-return array<string, string>
     */
    public function getFallbackDirs()
    {
        return $this->fallbackDirsPsr0;
    }

    /**
     * @return array[]
     * @psalm-return array<string, string>
     */
    public function getFallbackDirsPsr4()
    {
        return $this->fallbackDirsPsr4;
    }

    /**
     * @return string[] Array of classname => path
     * @psalm-return array<string, string>
     */
    public function getClassMap()
    {
        return $this->classMap;
    }

    /**
     * @param string[] $classMap Class to filename map
     * @psalm-param array<string, string> $classMap
     *
     * @return void
     */
    public function addClassMap(array $classMap)
    {
        if ($this->classMap) {
            $this->classMap = array_merge($this->classMap, $classMap);
        } else {
            $this->classMap = $classMap;
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix, either
     * appending or prepending to the ones previously set for this prefix.
     *
     * @param string          $prefix  The prefix
     * @param string[]|string $paths   The PSR-0 root directories
     * @param bool            $prepend Whether to prepend the directories
     *
     * @return void
     */
    public function add($prefix, $paths, $prepend = false)
    {
        if (!$prefix) {
            if ($prepend) {
                $this->fallbackDirsPsr0 = array_merge(
                    (array) $paths,
                    $this->fallbackDirsPsr0
                );
            } else {
                $this->fallbackDirsPsr0 = array_merge(
                    $this->fallbackDirsPsr0,
                    (array) $paths
                );
            }

            return;
        }

        $first = $prefix[0];
        if (!isset($this->prefixesPsr0[$first][$prefix])) {
            $this->prefixesPsr0[$first][$prefix] = (array) $paths;

            return;
        }
        if ($prepend) {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                (array) $paths,
                $this->prefixesPsr0[$first][$prefix]
            );
        } else {
            $this->prefixesPsr0[$first][$prefix] = array_merge(
                $this->prefixesPsr0[$first][$prefix],
                (array) $paths
            );
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace, either
     * appending or prepending to the ones previously set for this namespace.
     *
     * @param string          $prefix  The prefix/namespace, with trailing '\\'
     * @param string[]|string $paths   The PSR-4 base directories
     * @param bool            $prepend Whether to prepend the directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function addPsr4($prefix, $paths, $prepend = false)
    {
        if (!$prefix) {
            // Register directories for the root namespace.
            if ($prepend) {
                $this->fallbackDirsPsr4 = array_merge(
                    (array) $paths,
                    $this->fallbackDirsPsr4
                );
            } else {
                $this->fallbackDirsPsr4 = array_merge(
                    $this->fallbackDirsPsr4,
                    (array) $paths
                );
            }
        } elseif (!isset($this->prefixDirsPsr4[$prefix])) {
            // Register directories for a new namespace.
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = (array) $paths;
        } elseif ($prepend) {
            // Prepend directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                (array) $paths,
                $this->prefixDirsPsr4[$prefix]
            );
        } else {
            // Append directories for an already registered namespace.
            $this->prefixDirsPsr4[$prefix] = array_merge(
                $this->prefixDirsPsr4[$prefix],
                (array) $paths
            );
        }
    }

    /**
     * Registers a set of PSR-0 directories for a given prefix,
     * replacing any others previously set for this prefix.
     *
     * @param string          $prefix The prefix
     * @param string[]|string $paths  The PSR-0 base directories
     *
     * @return void
     */
    public function set($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr0 = (array) $paths;
        } else {
            $this->prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;
        }
    }

    /**
     * Registers a set of PSR-4 directories for a given namespace,
     * replacing any others previously set for this namespace.
     *
     * @param string          $prefix The prefix/namespace, with trailing '\\'
     * @param string[]|string $paths  The PSR-4 base directories
     *
     * @throws \InvalidArgumentException
     *
     * @return void
     */
    public function setPsr4($prefix, $paths)
    {
        if (!$prefix) {
            $this->fallbackDirsPsr4 = (array) $paths;
        } else {
            $length = strlen($prefix);
            if ('\\' !== $prefix[$length - 1]) {
                throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");
            }
            $this->prefixLengthsPsr4[$prefix[0]][$prefix] = $length;
            $this->prefixDirsPsr4[$prefix] = (array) $paths;
        }
    }

    /**
     * Turns on searching the include path for class files.
     *
     * @param bool $useIncludePath
     *
     * @return void
     */
    public function setUseIncludePath($useIncludePath)
    {
        $this->useIncludePath = $useIncludePath;
    }

    /**
     * Can be used to check if the autoloader uses the include path to check
     * for classes.
     *
     * @return bool
     */
    public function getUseIncludePath()
    {
        return $this->useIncludePath;
    }

    /**
     * Turns off searching the prefix and fallback directories for classes
     * that have not been registered with the class map.
     *
     * @param bool $classMapAuthoritative
     *
     * @return void
     */
    public function setClassMapAuthoritative($classMapAuthoritative)
    {
        $this->classMapAuthoritative = $classMapAuthoritative;
    }

    /**
     * Should class lookup fail if not found in the current class map?
     *
     * @return bool
     */
    public function isClassMapAuthoritative()
    {
        return $this->classMapAuthoritative;
    }

    /**
     * APCu prefix to use to cache found/not-found classes, if the extension is enabled.
     *
     * @param string|null $apcuPrefix
     *
     * @return void
     */
    public function setApcuPrefix($apcuPrefix)
    {
        $this->apcuPrefix = function_exists('apcu_fetch') && filter_var(ini_get('apc.enabled'), FILTER_VALIDATE_BOOLEAN) ? $apcuPrefix : null;
    }

    /**
     * The APCu prefix in use, or null if APCu caching is not enabled.
     *
     * @return string|null
     */
    public function getApcuPrefix()
    {
        return $this->apcuPrefix;
    }

    /**
     * Registers this instance as an autoloader.
     *
     * @param bool $prepend Whether to prepend the autoloader or not
     *
     * @return void
     */
    public function register($prepend = false)
    {
        spl_autoload_register(array($this, 'loadClass'), true, $prepend);

        if (null === $this->vendorDir) {
            return;
        }

        if ($prepend) {
            self::$registeredLoaders = array($this->vendorDir => $this) + self::$registeredLoaders;
        } else {
            unset(self::$registeredLoaders[$this->vendorDir]);
            self::$registeredLoaders[$this->vendorDir] = $this;
        }
    }

    /**
     * Unregisters this instance as an autoloader.
     *
     * @return void
     */
    public function unregister()
    {
        spl_autoload_unregister(array($this, 'loadClass'));

        if (null !== $this->vendorDir) {
            unset(self::$registeredLoaders[$this->vendorDir]);
        }
    }

    /**
     * Loads the given class or interface.
     *
     * @param  string    $class The name of the class
     * @return true|null True if loaded, null otherwise
     */
    public function loadClass($class)
    {
        if ($file = $this->findFile($class)) {
            includeFile($file);

            return true;
        }

        return null;
    }

    /**
     * Finds the path to the file where the class is defined.
     *
     * @param string $class The name of the class
     *
     * @return string|false The path if found, false otherwise
     */
    public function findFile($class)
    {
        // class map lookup
        if (isset($this->classMap[$class])) {
            return $this->classMap[$class];
        }
        if ($this->classMapAuthoritative || isset($this->missingClasses[$class])) {
            return false;
        }
        if (null !== $this->apcuPrefix) {
            $file = apcu_fetch($this->apcuPrefix.$class, $hit);
            if ($hit) {
                return $file;
            }
        }

        $file = $this->findFileWithExtension($class, '.php');

        // Search for Hack files if we are running on HHVM
        if (false === $file && defined('HHVM_VERSION')) {
            $file = $this->findFileWithExtension($class, '.hh');
        }

        if (null !== $this->apcuPrefix) {
            apcu_add($this->apcuPrefix.$class, $file);
        }

        if (false === $file) {
            // Remember that this class does not exist.
            $this->missingClasses[$class] = true;
        }

        return $file;
    }

    /**
     * Returns the currently registered loaders indexed by their corresponding vendor directories.
     *
     * @return self[]
     */
    public static function getRegisteredLoaders()
    {
        return self::$registeredLoaders;
    }

    /**
     * @param  string       $class
     * @param  string       $ext
     * @return string|false
     */
    private function findFileWithExtension($class, $ext)
    {
        // PSR-4 lookup
        $logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR) . $ext;

        $first = $class[0];
        if (isset($this->prefixLengthsPsr4[$first])) {
            $subPath = $class;
            while (false !== $lastPos = strrpos($subPath, '\\')) {
                $subPath = substr($subPath, 0, $lastPos);
                $search = $subPath . '\\';
                if (isset($this->prefixDirsPsr4[$search])) {
                    $pathEnd = DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $lastPos + 1);
                    foreach ($this->prefixDirsPsr4[$search] as $dir) {
                        if (file_exists($file = $dir . $pathEnd)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-4 fallback dirs
        foreach ($this->fallbackDirsPsr4 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) {
                return $file;
            }
        }

        // PSR-0 lookup
        if (false !== $pos = strrpos($class, '\\')) {
            // namespaced class name
            $logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1)
                . strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);
        } else {
            // PEAR-like class name
            $logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;
        }

        if (isset($this->prefixesPsr0[$first])) {
            foreach ($this->prefixesPsr0[$first] as $prefix => $dirs) {
                if (0 === strpos($class, $prefix)) {
                    foreach ($dirs as $dir) {
                        if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                            return $file;
                        }
                    }
                }
            }
        }

        // PSR-0 fallback dirs
        foreach ($this->fallbackDirsPsr0 as $dir) {
            if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) {
                return $file;
            }
        }

        // PSR-0 include paths.
        if ($this->useIncludePath && $file = stream_resolve_include_path($logicalPathPsr0)) {
            return $file;
        }

        return false;
    }
}

/**
 * Scope isolated include.
 *
 * Prevents access to $this/self from included files.
 *
 * @param  string $file
 * @return void
 * @private
 */
function includeFile($file)
{
    include $file;
}

'''
'''--- vendor/composer/InstalledVersions.php ---
<?php

/*
 * This file is part of Composer.
 *
 * (c) Nils Adermann <naderman@naderman.de>
 *     Jordi Boggiano <j.boggiano@seld.be>
 *
 * For the full copyright and license information, please view the LICENSE
 * file that was distributed with this source code.
 */

namespace Composer;

use Composer\Autoload\ClassLoader;
use Composer\Semver\VersionParser;

/**
 * This class is copied in every Composer installed project and available to all
 *
 * See also https://getcomposer.org/doc/07-runtime.md#installed-versions
 *
 * To require its presence, you can require `composer-runtime-api ^2.0`
 */
class InstalledVersions
{
    /**
     * @var mixed[]|null
     * @psalm-var array{root: array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string, type: string}, versions: array<string, array{dev_requirement: bool, pretty_version?: string, version?: string, aliases?: string[], reference?: string, replaced?: string[], provided?: string[], install_path?: string, type?: string}>}|array{}|null
     */
    private static $installed;

    /**
     * @var bool|null
     */
    private static $canGetVendors;

    /**
     * @var array[]
     * @psalm-var array<string, array{root: array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string, type: string}, versions: array<string, array{dev_requirement: bool, pretty_version?: string, version?: string, aliases?: string[], reference?: string, replaced?: string[], provided?: string[], install_path?: string, type?: string}>}>
     */
    private static $installedByVendor = array();

    /**
     * Returns a list of all package names which are present, either by being installed, replaced or provided
     *
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackages()
    {
        $packages = array();
        foreach (self::getInstalled() as $installed) {
            $packages[] = array_keys($installed['versions']);
        }

        if (1 === \count($packages)) {
            return $packages[0];
        }

        return array_keys(array_flip(\call_user_func_array('array_merge', $packages)));
    }

    /**
     * Returns a list of all package names with a specific type e.g. 'library'
     *
     * @param  string   $type
     * @return string[]
     * @psalm-return list<string>
     */
    public static function getInstalledPackagesByType($type)
    {
        $packagesByType = array();

        foreach (self::getInstalled() as $installed) {
            foreach ($installed['versions'] as $name => $package) {
                if (isset($package['type']) && $package['type'] === $type) {
                    $packagesByType[] = $name;
                }
            }
        }

        return $packagesByType;
    }

    /**
     * Checks whether the given package is installed
     *
     * This also returns true if the package name is provided or replaced by another package
     *
     * @param  string $packageName
     * @param  bool   $includeDevRequirements
     * @return bool
     */
    public static function isInstalled($packageName, $includeDevRequirements = true)
    {
        foreach (self::getInstalled() as $installed) {
            if (isset($installed['versions'][$packageName])) {
                return $includeDevRequirements || empty($installed['versions'][$packageName]['dev_requirement']);
            }
        }

        return false;
    }

    /**
     * Checks whether the given package satisfies a version constraint
     *
     * e.g. If you want to know whether version 2.3+ of package foo/bar is installed, you would call:
     *
     *   Composer\InstalledVersions::satisfies(new VersionParser, 'foo/bar', '^2.3')
     *
     * @param  VersionParser $parser      Install composer/semver to have access to this class and functionality
     * @param  string        $packageName
     * @param  string|null   $constraint  A version constraint to check for, if you pass one you have to make sure composer/semver is required by your package
     * @return bool
     */
    public static function satisfies(VersionParser $parser, $packageName, $constraint)
    {
        $constraint = $parser->parseConstraints($constraint);
        $provided = $parser->parseConstraints(self::getVersionRanges($packageName));

        return $provided->matches($constraint);
    }

    /**
     * Returns a version constraint representing all the range(s) which are installed for a given package
     *
     * It is easier to use this via isInstalled() with the $constraint argument if you need to check
     * whether a given version of a package is installed, and not just whether it exists
     *
     * @param  string $packageName
     * @return string Version constraint usable with composer/semver
     */
    public static function getVersionRanges($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            $ranges = array();
            if (isset($installed['versions'][$packageName]['pretty_version'])) {
                $ranges[] = $installed['versions'][$packageName]['pretty_version'];
            }
            if (array_key_exists('aliases', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['aliases']);
            }
            if (array_key_exists('replaced', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['replaced']);
            }
            if (array_key_exists('provided', $installed['versions'][$packageName])) {
                $ranges = array_merge($ranges, $installed['versions'][$packageName]['provided']);
            }

            return implode(' || ', $ranges);
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as version, use satisfies or getVersionRanges if you need to know if a given version is present
     */
    public static function getPrettyVersion($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['pretty_version'])) {
                return null;
            }

            return $installed['versions'][$packageName]['pretty_version'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as reference
     */
    public static function getReference($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            if (!isset($installed['versions'][$packageName]['reference'])) {
                return null;
            }

            return $installed['versions'][$packageName]['reference'];
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @param  string      $packageName
     * @return string|null If the package is being replaced or provided but is not really installed, null will be returned as install path. Packages of type metapackages also have a null install path.
     */
    public static function getInstallPath($packageName)
    {
        foreach (self::getInstalled() as $installed) {
            if (!isset($installed['versions'][$packageName])) {
                continue;
            }

            return isset($installed['versions'][$packageName]['install_path']) ? $installed['versions'][$packageName]['install_path'] : null;
        }

        throw new \OutOfBoundsException('Package "' . $packageName . '" is not installed');
    }

    /**
     * @return array
     * @psalm-return array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string, type: string}
     */
    public static function getRootPackage()
    {
        $installed = self::getInstalled();

        return $installed[0]['root'];
    }

    /**
     * Returns the raw installed.php data for custom implementations
     *
     * @deprecated Use getAllRawData() instead which returns all datasets for all autoloaders present in the process. getRawData only returns the first dataset loaded, which may not be what you expect.
     * @return array[]
     * @psalm-return array{root: array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string, type: string}, versions: array<string, array{dev_requirement: bool, pretty_version?: string, version?: string, aliases?: string[], reference?: string, replaced?: string[], provided?: string[], install_path?: string, type?: string}>}
     */
    public static function getRawData()
    {
        @trigger_error('getRawData only returns the first dataset loaded, which may not be what you expect. Use getAllRawData() instead which returns all datasets for all autoloaders present in the process.', E_USER_DEPRECATED);

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C') {
                self::$installed = include __DIR__ . '/installed.php';
            } else {
                self::$installed = array();
            }
        }

        return self::$installed;
    }

    /**
     * Returns the raw data of all installed.php which are currently loaded for custom implementations
     *
     * @return array[]
     * @psalm-return list<array{root: array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string, type: string}, versions: array<string, array{dev_requirement: bool, pretty_version?: string, version?: string, aliases?: string[], reference?: string, replaced?: string[], provided?: string[], install_path?: string, type?: string}>}>
     */
    public static function getAllRawData()
    {
        return self::getInstalled();
    }

    /**
     * Lets you reload the static array from another file
     *
     * This is only useful for complex integrations in which a project needs to use
     * this class but then also needs to execute another project's autoloader in process,
     * and wants to ensure both projects have access to their version of installed.php.
     *
     * A typical case would be PHPUnit, where it would need to make sure it reads all
     * the data it needs from this class, then call reload() with
     * `require $CWD/vendor/composer/installed.php` (or similar) as input to make sure
     * the project in which it runs can then also use this class safely, without
     * interference between PHPUnit's dependencies and the project's dependencies.
     *
     * @param  array[] $data A vendor/composer/installed.php data set
     * @return void
     *
     * @psalm-param array{root: array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string, type: string}, versions: array<string, array{dev_requirement: bool, pretty_version?: string, version?: string, aliases?: string[], reference?: string, replaced?: string[], provided?: string[], install_path?: string, type?: string}>} $data
     */
    public static function reload($data)
    {
        self::$installed = $data;
        self::$installedByVendor = array();
    }

    /**
     * @return array[]
     * @psalm-return list<array{root: array{name: string, version: string, reference: string, pretty_version: string, aliases: string[], dev: bool, install_path: string, type: string}, versions: array<string, array{dev_requirement: bool, pretty_version?: string, version?: string, aliases?: string[], reference?: string, replaced?: string[], provided?: string[], install_path?: string, type?: string}>}>
     */
    private static function getInstalled()
    {
        if (null === self::$canGetVendors) {
            self::$canGetVendors = method_exists('Composer\Autoload\ClassLoader', 'getRegisteredLoaders');
        }

        $installed = array();

        if (self::$canGetVendors) {
            foreach (ClassLoader::getRegisteredLoaders() as $vendorDir => $loader) {
                if (isset(self::$installedByVendor[$vendorDir])) {
                    $installed[] = self::$installedByVendor[$vendorDir];
                } elseif (is_file($vendorDir.'/composer/installed.php')) {
                    $installed[] = self::$installedByVendor[$vendorDir] = require $vendorDir.'/composer/installed.php';
                    if (null === self::$installed && strtr($vendorDir.'/composer', '\\', '/') === strtr(__DIR__, '\\', '/')) {
                        self::$installed = $installed[count($installed) - 1];
                    }
                }
            }
        }

        if (null === self::$installed) {
            // only require the installed.php file if this file is loaded from its dumped location,
            // and not from its source location in the composer/composer package, see https://github.com/composer/composer/issues/9937
            if (substr(__DIR__, -8, 1) !== 'C') {
                self::$installed = require __DIR__ . '/installed.php';
            } else {
                self::$installed = array();
            }
        }
        $installed[] = self::$installed;

        return $installed;
    }
}

'''
'''--- vendor/composer/autoload_classmap.php ---
<?php

// autoload_classmap.php @generated by Composer

$vendorDir = dirname(dirname(__FILE__));
$baseDir = dirname($vendorDir);

return array(
    'Composer\\InstalledVersions' => $vendorDir . '/composer/InstalledVersions.php',
);

'''
'''--- vendor/composer/autoload_namespaces.php ---
<?php

// autoload_namespaces.php @generated by Composer

$vendorDir = dirname(dirname(__FILE__));
$baseDir = dirname($vendorDir);

return array(
);

'''
'''--- vendor/composer/autoload_psr4.php ---
<?php

// autoload_psr4.php @generated by Composer

$vendorDir = dirname(dirname(__FILE__));
$baseDir = dirname($vendorDir);

return array(
    'LNCNcaptchaGravityAddon\\' => array($baseDir . '/'),
);

'''
'''--- vendor/composer/autoload_real.php ---
<?php

// autoload_real.php @generated by Composer

class ComposerAutoloaderInit9e9797f0af59c06a869717ef63707526
{
    private static $loader;

    public static function loadClassLoader($class)
    {
        if ('Composer\Autoload\ClassLoader' === $class) {
            require __DIR__ . '/ClassLoader.php';
        }
    }

    /**
     * @return \Composer\Autoload\ClassLoader
     */
    public static function getLoader()
    {
        if (null !== self::$loader) {
            return self::$loader;
        }

        spl_autoload_register(array('ComposerAutoloaderInit9e9797f0af59c06a869717ef63707526', 'loadClassLoader'), true, true);
        self::$loader = $loader = new \Composer\Autoload\ClassLoader(\dirname(\dirname(__FILE__)));
        spl_autoload_unregister(array('ComposerAutoloaderInit9e9797f0af59c06a869717ef63707526', 'loadClassLoader'));

        $useStaticLoader = PHP_VERSION_ID >= 50600 && !defined('HHVM_VERSION') && (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded());
        if ($useStaticLoader) {
            require __DIR__ . '/autoload_static.php';

            call_user_func(\Composer\Autoload\ComposerStaticInit9e9797f0af59c06a869717ef63707526::getInitializer($loader));
        } else {
            $map = require __DIR__ . '/autoload_namespaces.php';
            foreach ($map as $namespace => $path) {
                $loader->set($namespace, $path);
            }

            $map = require __DIR__ . '/autoload_psr4.php';
            foreach ($map as $namespace => $path) {
                $loader->setPsr4($namespace, $path);
            }

            $classMap = require __DIR__ . '/autoload_classmap.php';
            if ($classMap) {
                $loader->addClassMap($classMap);
            }
        }

        $loader->register(true);

        return $loader;
    }
}

'''
'''--- vendor/composer/autoload_static.php ---
<?php

// autoload_static.php @generated by Composer

namespace Composer\Autoload;

class ComposerStaticInit9e9797f0af59c06a869717ef63707526
{
    public static $prefixLengthsPsr4 = array (
        'L' => 
        array (
            'LNCNcaptchaGravityAddon\\' => 24,
        ),
    );

    public static $prefixDirsPsr4 = array (
        'LNCNcaptchaGravityAddon\\' => 
        array (
            0 => __DIR__ . '/../..' . '/',
        ),
    );

    public static $classMap = array (
        'Composer\\InstalledVersions' => __DIR__ . '/..' . '/composer/InstalledVersions.php',
    );

    public static function getInitializer(ClassLoader $loader)
    {
        return \Closure::bind(function () use ($loader) {
            $loader->prefixLengthsPsr4 = ComposerStaticInit9e9797f0af59c06a869717ef63707526::$prefixLengthsPsr4;
            $loader->prefixDirsPsr4 = ComposerStaticInit9e9797f0af59c06a869717ef63707526::$prefixDirsPsr4;
            $loader->classMap = ComposerStaticInit9e9797f0af59c06a869717ef63707526::$classMap;

        }, null, ClassLoader::class);
    }
}

'''
'''--- vendor/composer/installed.json ---
{
    "packages": [],
    "dev": true,
    "dev-package-names": []
}

'''
'''--- vendor/composer/installed.php ---
<?php return array(
    'root' => array(
        'pretty_version' => 'dev-main',
        'version' => 'dev-main',
        'type' => 'library',
        'install_path' => __DIR__ . '/../../',
        'aliases' => array(),
        'reference' => '3fb2453f18a05c9d1351cbcd112c48196e7ac2ad',
        'name' => 'lnc/ncaptcha-gravity-addon',
        'dev' => true,
    ),
    'versions' => array(
        'lnc/ncaptcha-gravity-addon' => array(
            'pretty_version' => 'dev-main',
            'version' => 'dev-main',
            'type' => 'library',
            'install_path' => __DIR__ . '/../../',
            'aliases' => array(),
            'reference' => '3fb2453f18a05c9d1351cbcd112c48196e7ac2ad',
            'dev_requirement' => false,
        ),
    ),
);

'''
'''--- webpack.config.js ---
const TerserJSPlugin = require('terser-webpack-plugin');
const path = require('path');
module.exports = {
    optimization: {
        minimizer: [new TerserJSPlugin({})],
    },
    entry: ['./app.js'],
    output: {
        path: path.resolve(__dirname, 'public'),
        filename: './index.js',
    },
    module: {
        rules: [
            {
                test: /\.m?js$/,
                exclude: /(node_modules|bower_components)/,
                use: {
                    loader: 'babel-loader',
                    options: {
                        presets: ['@babel/preset-env'],
                        plugins: ['@babel/plugin-transform-runtime']
                    }
                }
            }
        ]
    },
}
'''