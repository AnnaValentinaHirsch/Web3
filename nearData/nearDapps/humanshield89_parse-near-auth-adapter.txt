*GitHub Repository "humanshield89/parse-near-auth-adapter"*

'''--- .prettierrc.json ---
{
  "tabWidth": 2,
  "printWidth": 120
}

'''
'''--- README.md ---
# Near wallet Auth Adapter for parse server

This package allows parse users to login using their near wallets

## Install

```shell
npm i parse-near-auth-adapter
```

or if you prefer `yarn`

```shell
yarn add parse-near-auth-adapter
```

## Setup

1. Add NearAuthAdapter to your parse server options

```javascript
const { NearAuthAdapter } = require("parse-near-auth-adapter");

const parseServerApi = new ParseServer({
  ...restOfParseOptions,
  auth: {
    NearAuthAdapter: {
      module: NearAuthAdapter,
      tokenValidity: 10000, // how long a signToken is valid in milis (default 15seconds)
      connectionConfig: {
        networkId: "testnet", // if main net change this to main net
        nodeUrl: "https://rpc.testnet.near.org", // change to match network id
        walletUrl: "https://wallet.testnet.near.org", // change to match network id
        helperUrl: "https://helper.testnet.near.org", // change to match network id
        explorerUrl: "https://explorer.testnet.near.org", // change to match network id
      },
    },
  },
});
```

2. Setup Cloud code

```javascript
const { setupNearAuthAdapterCloudCode } = require("parse-near-auth-adapter");

// setup your other cloud functions
setupNearAuthAdapterCloudCode(); // this will set one cloud function used to generate tokens
```

You are all set now, you can start using it on clients

## Client side example (Linking Users)

```javascript
import * as nearAPI from "near-api-js";
import { sha256 } from "js-sha256";

// we assume you already signin to near wallet via  wallet.requestSignIn()
// we assume Parse user is already signin
const linkWallet = async () => {
  const currentWallet = {
    accountId: walletConnection.getAccountId(),
    balance: (await walletConnection.account().state()).amount,
  };
  // this means the near wallet is not connected to your website (use the near requestSignin to connect near wallet to your website)
  if (!currentWallet?.accountId) return;

  const res = await Parse.Cloud.run("getNearSignToken", { walletId: currentUser?.accountId }).catch((error) => {
    // handle error
  });
  // this is the token that needs to be signed
  const token = res?.data?.get("token");

  // get the signer from the wallet connection
  const signer = (await wallet.account()).connection.signer;
  // get the keyPar for the signer
  const key = await signer.keyStore.getKey(nearConfig.networkId, currentUser.accountId);
  // sha256 the token to prepare for signing
  const digestedToken = new Uint8Array(sha256.array(token));

  // sign using the key pair
  const signed = await key.sign(digestedToken, currentUser.accountId, nearConfig.networkId);

  // get string representation of public key
  const publicKey = key.publicKey.toString();
  // get hex representation of the signature
  const signature = Buffer.from(signed.signature).toString("hex");
  // id is the connected near wallet accountId
  const id = currentUser.accountId;

  // more details on the please visit:
  // https://docs.parseplatform.org/js/guide/#linking-users
  // The NearAuthAdapter expects this authdata
  const authData = { publicKey, signature, id, token };

  let provider;
  provider = {
    authenticate: (options) => {
      options.success(provider, { ...authData });
    },
    restoreAuthentication() {
      return true;
    },

    getAuthType() {
      return "NearAuthAdapter";
    },

    getAuthData() {
      return {
        authData: {
          ...authData,
        },
      };
    },
  };

  // get current logged in Parse User
  const user = await Parse.User.currentAsync();
  // register the provider to allow linking
  await Parse.User._registerAuthenticationProvider(provider);
  // link user with the provider
  await user.linkWith(provider.getAuthType(), authData).catch((error) => {
    // handle error
  });
  // check if linked
  user._isLinked(provider); // should be true
};
```

## Client side example (Login)

```javascript
const login = async () => {
  const currentWallet = {
    accountId: walletConnection.getAccountId(),
    balance: (await walletConnection.account().state()).amount,
  };
  // this means the near wallet is not connected to your website (use the near requestSignin to connect near wallet to your website)
  if (!currentWallet?.accountId) return;

  // call cloud function to get a fresh token
  const res = await Parse.Cloud.run("getNearSignToken", { walletId: currentUser?.accountId }).catch((error) => {
    // handle error
  });
  // this is the token that needs to be signed
  const token = res?.data?.get("token");

  // get the signer from the wallet connection
  const signer = (await wallet.account()).connection.signer;
  // get the keyPar for the signer
  const key = await signer.keyStore.getKey(nearConfig.networkId, currentUser.accountId);
  // sha256 the token to prepare for signing
  const digestedToken = new Uint8Array(sha256.array(token));

  // sign using the key pair
  const signed = await key.sign(digestedToken, currentUser.accountId, nearConfig.networkId);

  // get string representation of public key
  const publicKey = key.publicKey.toString();
  // get hex representation of the signature
  const signature = Buffer.from(signed.signature).toString("hex");
  // id is the connected near wallet accountId
  const id = currentUser.accountId;

  // more details on the please visit:
  // https://docs.parseplatform.org/js/guide/#linking-users
  // The NearAuthAdapter expects this authdata
  const authData = { publicKey, signature, id, token };

  const user = await Parse.User.LogInWith("NearAuthAdapter", {
    authData,
  }).catch((error) => {
    // handle error
    // probably no linked wallet , or signature mismatch
  });
  if (user) {
    // user is the currently logged in user
  }
};
```

## How Does it work ?

The Near Auth adapter is simple and straight forward, these are the steps

1. client requests a token (the token is a randomly generated base64Url string)
2. client hashes the token using sha256 and then sign it through the near-js-api
3. client sends to Parse Server the near accountId, publicKey as string (from the pair that signed the token), the token as string, and a hex string representation of the signature
4. Parse server will check the following and only link/login if all pass:
   - the provided publicKey is actually a valid accessKey that belongs the provided near accountID
   - The token is a valid token generated by parse server and is not older than 5 minutes
   - the signature is valid

## Licence:

Project is distributed under MIT license.

## contributions

Contributions are welcomes

## Sponsors

This adapter was made possible by [agoraneos](https://agoraneos.com/)

'''
'''--- package-lock.json ---
{
  "name": "parse-near-auth-adapter",
  "version": "0.1.0",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "name": "parse-near-auth-adapter",
      "version": "0.1.0",
      "license": "MIT",
      "dependencies": {
        "js-sha256": "^0.9.0",
        "near-api-js": "^0.45.1"
      },
      "devDependencies": {
        "prettier": "^2.5.1"
      }
    },
    "node_modules/base-x": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.9.tgz",
      "integrity": "sha512-H7JU6iBHTal1gp56aKoaa//YUxEaAOUiydvrV/pILqIHXTtqxSkATOnDA2u+jZ/61sD+L/412+7kzXRtWukhpQ==",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/bn.js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.0.tgz",
      "integrity": "sha512-D7iWRBvnZE8ecXiLj/9wbxH7Tk79fAh8IHaTNq1RWRixsS02W+5qS+iE9yq6RYl0asXx5tw0bLhmT5pIfbSquw=="
    },
    "node_modules/borsh": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.7.0.tgz",
      "integrity": "sha512-CLCsZGIBCFnPtkNnieW/a8wmreDmfUtjU2m9yHrzPXIlNbqVs0AQrSatSG6vdNYUqdc83tkQi2eHfF98ubzQLA==",
      "dependencies": {
        "bn.js": "^5.2.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      }
    },
    "node_modules/bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha512-Ok3Wdf5vOIlBrgCvTq96gBkJw+JUEzdBgyaza5HLtPm7yTHkjRy8+JzNyHF7BHa0bNWOQIp3m5YF0nnFcOIKLw==",
      "dependencies": {
        "base-x": "^3.0.2"
      }
    },
    "node_modules/capability": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
      "integrity": "sha512-rsJZYVCgXd08sPqwmaIqjAd5SUTfonV0z/gDJ8D6cN8wQphky1kkAYEqQ+hmDxTw7UihvBfjUVUSY+DBEe44jg=="
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/error-polyfill": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.3.tgz",
      "integrity": "sha512-XHJk60ufE+TG/ydwp4lilOog549iiQF2OAPhkk9DdiYWMrltz5yhDz/xnKuenNwP7gy3dsibssO5QpVhkrSzzg==",
      "dependencies": {
        "capability": "^0.2.5",
        "o3": "^1.0.3",
        "u3": "^0.1.1"
      }
    },
    "node_modules/http-errors": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.1.tgz",
      "integrity": "sha512-Kpk9Sm7NmI+RHhnj6OIWDI1d6fIoFAtFt9RLaTMRlg/8w49juAStsrBgp0Dp4OdxdVbRIeKhtCUvoi/RuAhO4g==",
      "dependencies": {
        "depd": "~1.1.2",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": ">= 1.5.0 < 2",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/http-errors/node_modules/depd": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
      "integrity": "sha512-7emPTl6Dpo6JRXOXjLRxck+FlLRX5847cLKEn00PLAgc3g2hTZZgr+e4c2v6QpSmLeFP3n5yUo7ft6avBK/5jQ==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "node_modules/mustache": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
      "integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ==",
      "bin": {
        "mustache": "bin/mustache"
      }
    },
    "node_modules/near-api-js": {
      "version": "0.45.1",
      "resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-0.45.1.tgz",
      "integrity": "sha512-QyPO/vjvMFlcMO1DCpsqzmnSqPIyHsjK1Qi4B5ZR1cJCIWMkqugDF/TDf8FVQ85pmlcYeYwfiTqKanKz+3IG0A==",
      "dependencies": {
        "bn.js": "5.2.0",
        "borsh": "^0.7.0",
        "bs58": "^4.0.0",
        "depd": "^2.0.0",
        "error-polyfill": "^0.1.3",
        "http-errors": "^1.7.2",
        "js-sha256": "^0.9.0",
        "mustache": "^4.0.0",
        "node-fetch": "^2.6.1",
        "text-encoding-utf-8": "^1.0.2",
        "tweetnacl": "^1.0.1"
      }
    },
    "node_modules/node-fetch": {
      "version": "2.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz",
      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/o3": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
      "integrity": "sha512-f+4n+vC6s4ysy7YO7O2gslWZBUu8Qj2i2OUJOvjRxQva7jVjYjB29jrr9NCjmxZQR0gzrOcv1RnqoYOeMs5VRQ==",
      "dependencies": {
        "capability": "^0.2.5"
      }
    },
    "node_modules/prettier": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/prettier/-/prettier-2.7.1.tgz",
      "integrity": "sha512-ujppO+MkdPqoVINuDFDRLClm7D78qbDt0/NR+wp5FqEZOoTNAjPHWj17QRhu7geIHJfcNhRk1XVQmF8Bp3ye+g==",
      "dev": true,
      "bin": {
        "prettier": "bin-prettier.js"
      },
      "engines": {
        "node": ">=10.13.0"
      },
      "funding": {
        "url": "https://github.com/prettier/prettier?sponsor=1"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "node_modules/statuses": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
      "integrity": "sha512-OpZ3zP+jT1PI7I8nemJX4AKmAX070ZkYPVWV/AaKTJl+tXCTGyVdC1a4SL8RUQYEwk/f34ZX8UTykN68FwrqAA==",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "node_modules/tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "node_modules/u3": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/u3/-/u3-0.1.1.tgz",
      "integrity": "sha512-+J5D5ir763y+Am/QY6hXNRlwljIeRMZMGs0cT6qqZVVzzT3X3nFPXVyPOFRMOR4kupB0T8JnCdpWdp6Q/iXn3w=="
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    }
  },
  "dependencies": {
    "base-x": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.9.tgz",
      "integrity": "sha512-H7JU6iBHTal1gp56aKoaa//YUxEaAOUiydvrV/pILqIHXTtqxSkATOnDA2u+jZ/61sD+L/412+7kzXRtWukhpQ==",
      "requires": {
        "safe-buffer": "^5.0.1"
      }
    },
    "bn.js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.0.tgz",
      "integrity": "sha512-D7iWRBvnZE8ecXiLj/9wbxH7Tk79fAh8IHaTNq1RWRixsS02W+5qS+iE9yq6RYl0asXx5tw0bLhmT5pIfbSquw=="
    },
    "borsh": {
      "version": "0.7.0",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.7.0.tgz",
      "integrity": "sha512-CLCsZGIBCFnPtkNnieW/a8wmreDmfUtjU2m9yHrzPXIlNbqVs0AQrSatSG6vdNYUqdc83tkQi2eHfF98ubzQLA==",
      "requires": {
        "bn.js": "^5.2.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      }
    },
    "bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha512-Ok3Wdf5vOIlBrgCvTq96gBkJw+JUEzdBgyaza5HLtPm7yTHkjRy8+JzNyHF7BHa0bNWOQIp3m5YF0nnFcOIKLw==",
      "requires": {
        "base-x": "^3.0.2"
      }
    },
    "capability": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
      "integrity": "sha512-rsJZYVCgXd08sPqwmaIqjAd5SUTfonV0z/gDJ8D6cN8wQphky1kkAYEqQ+hmDxTw7UihvBfjUVUSY+DBEe44jg=="
    },
    "depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw=="
    },
    "error-polyfill": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.3.tgz",
      "integrity": "sha512-XHJk60ufE+TG/ydwp4lilOog549iiQF2OAPhkk9DdiYWMrltz5yhDz/xnKuenNwP7gy3dsibssO5QpVhkrSzzg==",
      "requires": {
        "capability": "^0.2.5",
        "o3": "^1.0.3",
        "u3": "^0.1.1"
      }
    },
    "http-errors": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.1.tgz",
      "integrity": "sha512-Kpk9Sm7NmI+RHhnj6OIWDI1d6fIoFAtFt9RLaTMRlg/8w49juAStsrBgp0Dp4OdxdVbRIeKhtCUvoi/RuAhO4g==",
      "requires": {
        "depd": "~1.1.2",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": ">= 1.5.0 < 2",
        "toidentifier": "1.0.1"
      },
      "dependencies": {
        "depd": {
          "version": "1.1.2",
          "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
          "integrity": "sha512-7emPTl6Dpo6JRXOXjLRxck+FlLRX5847cLKEn00PLAgc3g2hTZZgr+e4c2v6QpSmLeFP3n5yUo7ft6avBK/5jQ=="
        }
      }
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "mustache": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
      "integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ=="
    },
    "near-api-js": {
      "version": "0.45.1",
      "resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-0.45.1.tgz",
      "integrity": "sha512-QyPO/vjvMFlcMO1DCpsqzmnSqPIyHsjK1Qi4B5ZR1cJCIWMkqugDF/TDf8FVQ85pmlcYeYwfiTqKanKz+3IG0A==",
      "requires": {
        "bn.js": "5.2.0",
        "borsh": "^0.7.0",
        "bs58": "^4.0.0",
        "depd": "^2.0.0",
        "error-polyfill": "^0.1.3",
        "http-errors": "^1.7.2",
        "js-sha256": "^0.9.0",
        "mustache": "^4.0.0",
        "node-fetch": "^2.6.1",
        "text-encoding-utf-8": "^1.0.2",
        "tweetnacl": "^1.0.1"
      }
    },
    "node-fetch": {
      "version": "2.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz",
      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
      "requires": {
        "whatwg-url": "^5.0.0"
      }
    },
    "o3": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
      "integrity": "sha512-f+4n+vC6s4ysy7YO7O2gslWZBUu8Qj2i2OUJOvjRxQva7jVjYjB29jrr9NCjmxZQR0gzrOcv1RnqoYOeMs5VRQ==",
      "requires": {
        "capability": "^0.2.5"
      }
    },
    "prettier": {
      "version": "2.7.1",
      "resolved": "https://registry.npmjs.org/prettier/-/prettier-2.7.1.tgz",
      "integrity": "sha512-ujppO+MkdPqoVINuDFDRLClm7D78qbDt0/NR+wp5FqEZOoTNAjPHWj17QRhu7geIHJfcNhRk1XVQmF8Bp3ye+g==",
      "dev": true
    },
    "safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ=="
    },
    "setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "statuses": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
      "integrity": "sha512-OpZ3zP+jT1PI7I8nemJX4AKmAX070ZkYPVWV/AaKTJl+tXCTGyVdC1a4SL8RUQYEwk/f34ZX8UTykN68FwrqAA=="
    },
    "text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA=="
    },
    "tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha512-N3WMsuqV66lT30CrXNbEjx4GEwlow3v6rr4mCcv6prnfwhS01rkgyFdjPNBYd9br7LpXV1+Emh01fHnq2Gdgrw=="
    },
    "tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "u3": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/u3/-/u3-0.1.1.tgz",
      "integrity": "sha512-+J5D5ir763y+Am/QY6hXNRlwljIeRMZMGs0cT6qqZVVzzT3X3nFPXVyPOFRMOR4kupB0T8JnCdpWdp6Q/iXn3w=="
    },
    "webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha512-2JAn3z8AR6rjK8Sm8orRC0h/bcl/DqL7tRPdGZ4I1CjdF+EaMLmYxBHyXuKL849eucPFhvBoxMsflfOb8kxaeQ=="
    },
    "whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha512-saE57nupxk6v3HY35+jzBwYa0rKSy0XR8JSxZPwgLr7ys0IBzhGviA1/TUGJLmSVqs8pb9AnvICXEuOHLprYTw==",
      "requires": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    }
  }
}

'''
'''--- package.json ---
{
  "name": "parse-near-auth-adapter",
  "version": "0.1.2",
  "description": "Allow users to authenticate with their near wallets",
  "main": "src/index.js",
  "scripts": {
    "format": "prettier --write .",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [
    "Near Network",
    "parse server",
    "auth adapter",
    "blockchain"
  ],
  "author": "Rachid Boudjelida <rachidboudjelida@gmail.com> (https://dailycode.dev)",
  "license": "MIT",
  "dependencies": {
    "js-sha256": "^0.9.0",
    "near-api-js": "^0.45.1"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/humanshield89/parse-near-auth-adapter.git"
  },
  "devDependencies": {
    "prettier": "^2.5.1"
  }
}

'''
'''--- src/index.js ---
const { Uint8ArrayFromHexString, HexStringFromUint8Array } = require("./lib/Utils");

const { NearAuthAdapter } = require("./lib/NearAuthAdapter");
const { getNearSignToken } = require("./lib/CloudCode/NearAuthCloudCode");

exports.Uint8ArrayFromHexString = Uint8ArrayFromHexString;

exports.HexStringFromUint8Array = HexStringFromUint8Array;

exports.NearAuthAdapter = NearAuthAdapter;

exports.setupNearAuthAdapterCloudCode = () => {
  Parse.Cloud.define("getNearSignToken", getNearSignToken);
};

'''
'''--- src/lib/CloudCode/NearAuthCloudCode.js ---
/**
 * @param req {Parse.Cloud.FunctionRequest}
 */
const { NearSignToken } = require("../data/NearSignToken/class");

const getNearSignToken = async (req) => {
  const { walletId } = req.params;
  if (!walletId) throw new Parse.Error();

  const obj = await NearSignToken.generateNew(walletId);

  return {
    status: "success",
    data: obj.linkedObject,
  };
};

module.exports = {
  getNearSignToken,
};

'''
'''--- src/lib/NearAuthAdapter.js ---
const nearAPI = require("near-api-js");
const { Uint8ArrayFromHexString } = require("./Utils");
const { sha256 } = require("js-sha256");
const { NearSignToken } = require("./data/NearSignToken/class");

const TOKEN_VALIDITY = 15 * 1000; // 15 seconds (in millis)

class NearAuthAdapter {
  async validateAuthData(authData, options) {
    if (!options || !options.connectionConfig)
      throw new Parse.Error(
        501,
        "NearAuthAdapter: connectionConfig is required please make sure you setup the adapter correctly"
      );

    const connectionConfig = options.connectionConfig;
    /*
     * id: walletId that signed the message
     * token: the token that was signed (get it by calling cloud code to get a nearSignToken)
     * signature: hex string representation of the signature
     * publicKey: public key as string
     */
    const { id, token, signature, publicKey } = authData;

    // check authData
    const args = [id, token, signature, publicKey];
    const argsKeys = ["id", "token", "signature", "publicKey"];
    args.forEach((arg, i) => {
      if (!arg) throw new Parse.Error(403, `NearAuthAdapter: ${argsKeys[i]} is required`);
    });

    // check if this token is valid
    const tokenObj = await NearSignToken.getTokenForWalletId(token, id);

    if (!tokenObj) throw new Parse.Error(403, "NearAuthAdapter: Invalid token provided");

    if (
      Date.now() - tokenObj.getCreatedAd().getTime() >
      (options && options.tokenValidity ? options.tokenValidity : TOKEN_VALIDITY)
    ) {
      throw new Parse.Error(403, "NearAuthAdapter: Token has expired");
    }

    // delete this token object
    await tokenObj.destroy(true);

    const myKeyStore = new nearAPI.keyStores.InMemoryKeyStore();
    const nearConnection = await nearAPI.connect({
      keyStore: myKeyStore,
      ...connectionConfig,
    });

    /**
     * Will be used to get the public keys of this account and check if the supplied public key belongs to this account
     * @type {Account}
     */
    const account = await nearConnection.account(id);

    /**
     * Used to verify the sigature
     * @type {PublicKey}
     */
    const pubKey = nearAPI.utils.PublicKey.fromString(publicKey);
    /**
     * Uint8Array representation of the signature
     * @type {Uint8Array}
     */
    const uint8ArraySignature = Uint8ArrayFromHexString(signature);

    const valid = pubKey.verify(new Uint8Array(sha256.array(token)), uint8ArraySignature);

    if (!valid) throw new Parse.Error(403, "NearAuthAdapter: signature verification failed");

    /**
     * All access keys present for this walletID
     * @type {AccessKeyInfoView[]}
     */
    const accountKeys = await account.getAccessKeys();

    // see if key is present
    const match = accountKeys.filter((k) => k.public_key === publicKey);

    // if no match throw
    if (!match || match?.length === 0) {
      throw new Parse.Error(403, "NearAuthAdapter: public key is not an assigned access key to the supplied walletId");
    }

    return Promise.resolve(true);
  }

  validateAppId(appIds, authData, options) {
    return Promise.resolve(true);
  }
}

module.exports = {
  NearAuthAdapter,
};

'''
'''--- src/lib/Utils.js ---
const Crypto = require("crypto");
/**
 * returns a hex String representation of a Uint8Array
 * @param uint8Array
 * @returns {string}
 * @constructor
 */
const HexStringFromUint8Array = (uint8Array) => Buffer.from(uint8Array).toString("hex");

/**
 * returns a Uint8Array representation of a hex string
 * @param hexString
 * @returns {Uint8Array}
 * @constructor
 */
const Uint8ArrayFromHexString = (hexString) =>
  Uint8Array.from(hexString.match(/.{1,2}/g).map((byte) => parseInt(byte, 16)));

/**
 *
 * @param object{Parse.ParseObject}
 * @return {Promise<void>}
 */
const restrictToMasterKeyOnly = async (object) => {
  const acl = new Parse.ACL();
  acl.setPublicReadAccess(false);
  acl.setPublicWriteAccess(false);
  object.setACL(acl, {});
  await object.save(null, { useMasterKey: true });
};

/**
 *
 * @param size
 * @returns {String}
 */
function generateRandomUrlBase64String(size) {
  return Crypto.randomBytes(size).toString("base64url");
}

module.exports = {
  Uint8ArrayFromHexString,
  HexStringFromUint8Array,
  restrictToMasterKeyOnly,
  generateRandomUrlBase64String,
};

'''
'''--- src/lib/data/NearSignToken/class.js ---
const { BaseObjectClass } = require("../WrappedBaseParseObj/class");
const { generateRandomUrlBase64String, restrictToMasterKeyOnly } = require("../../Utils");

class NearSignToken extends BaseObjectClass {
  static KEYS = require("./struct").NearSignNonceStruct;

  constructor(obj) {
    super(obj);
    this.keys = NearSignToken.KEYS;
  }

  getWalletId = () => this.linkedObject.get(this.keys.walletId);
  getToken = () => this.linkedObject.get(this.keys.token);

  /**
   * @param walletId{String}
   * @returns {NearSignToken}
   */
  setWalletId = (walletId) => {
    return this._set(this.keys.walletId, walletId);
  };

  /**
   * @returns {NearSignToken}
   */
  generateToken = () => {
    const token = generateRandomUrlBase64String(24);
    return this._set(this.keys.token, token);
  };

  static generateNew = async (walletId) => {
    const obj = new NearSignToken(new Parse.Object(NearSignToken.KEYS.className));
    obj.generateToken();
    obj.setWalletId(walletId);
    await obj.save(true);
    await restrictToMasterKeyOnly(obj.linkedObject);
    return obj;
  };

  static getTokenForWalletId = async (token, walletId) => {
    const query = new Parse.Query(NearSignToken.KEYS.className);
    query.equalTo(NearSignToken.KEYS.token, token);
    query.equalTo(NearSignToken.KEYS.walletId, walletId);
    const tokenObj = await query.first({ useMasterKey: true });

    return tokenObj ? new NearSignToken(tokenObj) : null;
  };
}

module.exports = {
  NearSignToken,
};

'''
'''--- src/lib/data/NearSignToken/struct.js ---
const { WrappedBaseParseObjStruct } = require("../WrappedBaseParseObj/struct");
module.exports.NearSignNonceStruct = {
  className: "NearSignToken",
  token: "token",
  walletId: "walletId",
  ...WrappedBaseParseObjStruct,
};

'''
'''--- src/lib/data/WrappedBaseParseObj/class.js ---
class BaseObjectClass {
  static KEYS = require("./struct").WrappedBaseParseObjStruct;

  /**
   *
   * @param obj{Parse.ParseObject}
   */
  constructor(obj) {
    /**
     * @type {Parse.ParseObject}
     */
    this.linkedObject = obj;
    this.keys = BaseObjectClass.KEYS;
    this.isDirty = false;
  }

  getCreatedAd = () => this.linkedObject.get(this.keys.createdAt);
  getLastModified = () => this.linkedObject.get(this.keys.lastModified);

  _set = (key, value) => {
    this.linkedObject.set(key, value, {});
    return this.setDirty();
  };

  setDirty = () => {
    this.isDirty = true;
    return this;
  };

  save = async (useMaster = true) => {
    await this.linkedObject.save(null, { useMasterKey: useMaster }, undefined);
    return this;
  };

  /**
   *
   * @param master{boolean}
   * @return {Promise<this>}
   */
  destroy = async (master = true) => {
    await this.linkedObject.destroy({ useMasterKey: master });
    return this;
  };
}

module.exports.BaseObjectClass = BaseObjectClass;

'''
'''--- src/lib/data/WrappedBaseParseObj/struct.js ---
module.exports.WrappedBaseParseObjStruct = {
  createdAt: "createdAt",
  lastModified: "lastModified",
};

'''