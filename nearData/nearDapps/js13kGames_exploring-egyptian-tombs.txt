*GitHub Repository "js13kGames/exploring-egyptian-tombs"*

'''--- GeneratingPharaohs/GeneratingPharaohs/acceptfile.php ---
<?php
if(isset($_FILES) && $_FILES['image']['error'] == 0){ // Проверяем, загрузил ли пользователь файл
$destiation_dir = dirname(__FILE__). '/pharaons' .'/'.$_FILES['image']['name']; // Директория для размещения файла
move_uploaded_file($_FILES['image']['tmp_name'], $destiation_dir ); // Перемещаем файл в желаемую директорию
echo 'File Uploaded'; // Оповещаем пользователя об успешной загрузке файла

file_put_contents(__DIR__ . '/' . 'counter.txt', (file_get_contents(__DIR__ . '/' . 'counter.txt') + 1));

}
else{
echo 'No File Uploaded'; // Оповещаем пользователя о том, что файл не был загружен
}

?>
'''
'''--- GeneratingPharaohs/GeneratingPharaohs/counter.txt ---
4945
'''
'''--- GeneratingPharaohs/GeneratingPharaohs/render.html ---
<html>
    <head>
        <style>
            body{
                background-color: black;
                margin: 0;
                overflow-x: hidden;
                overflow-y: hidden;
            }
        </style>
    </head>
    <body>
        <canvas id="canvas"></canvas>
        <script>
        
        // # prepare page
        
            const canvas = document.getElementById('canvas');
            const c = canvas.getContext('2d');
            
            
            canvas.width = innerWidth;
            canvas.height = innerHeight;
            
            
        // ---
            
            const gc = (function(cnxt)
            {
                let resultModule = {};
                
                
                let c = cnxt;
                resultModule.c = c;
                
                const coeffScaling = 1.5;
                const centerGrid = [innerWidth / 2, innerHeight / 2]; // (0; 0) position on our grid
                const leftEdge = centerGrid[0] - 100 * coeffScaling, rightEdge = centerGrid[0] + 100 * coeffScaling;
                const upEdge = centerGrid[1] + 100 * coeffScaling, downEdge = centerGrid[0] - 100 * coeffScaling;
                
                
                
                
                
                // # PRIVATE METHODS
                
                resultModule.moveTo = (x, y) =>
                {
                  
                    c.moveTo(centerGrid[0] + x * coeffScaling, centerGrid[1] - y * coeffScaling);
                    
                };
                
                resultModule.lineTo = (x, y) =>
                {
                    
                    c.lineTo(centerGrid[0] + x * coeffScaling, centerGrid[1] - y * coeffScaling);
                    
                };
                
                resultModule.bezierCurveTo = (cp1x, cp1y, cp2x, cp2y, fx, fy) => // [x, y] every argument here
                {
                    
                    c.bezierCurveTo(centerGrid[0] + cp1x * coeffScaling, centerGrid[1] - cp1y * coeffScaling, centerGrid[0] + cp2x * coeffScaling, centerGrid[1] - cp2y * coeffScaling, centerGrid[0] + fx * coeffScaling, centerGrid[1] - fy * coeffScaling);
                    
                };
                
                resultModule.quadraticCurveTo = (cp1x, cp1y, fx, fy) => // [x, y] every argument here
                {
                    
                    c.quadraticCurveTo(centerGrid[0] + cp1x * coeffScaling, centerGrid[1] - cp1y * coeffScaling, centerGrid[0] + fx * coeffScaling, centerGrid[1] - fy * coeffScaling);
                    
                };
                
                resultModule.beginPath = () => c.beginPath();
                resultModule.fill = () => c.fill();
                resultModule.stroke = () => c.stroke();
                
                
                resultModule.createRadialGradient = (x0, y0, r0, x1, y1, r1) =>
                {
                    c.createRadialGradient(centerGrid[0] + x0 * coeffScaling, centerGrid[1] - y0 * coeffScaling, r0, centerGrid[0] + x1 * coeffScaling, centerGrid[1] - y1 * coeffScaling, r1);
                };
                
                
                
                
                return resultModule;
                
            })(c);
        
        
            
            
            // gc - our grid context ( wrape under contextCanvas2D )
            
            
            
            
            
                
            // 1 layer: up body
            let widthBody = 200 + randInt(-10, +10);
            let heightTrapezoid = 20 + randInt(-3, +3);
            let downWidthBody = widthBody *  ( (75 + randInt(-5, 5) ) / 100);
            let disFromCenterToDownBody = 135 + randInt(-5, +5);
            let imageData1Layer;
            
            
            // 2 layer - cape
            let maxDistanceCape =( (95 + randInt(-7, 4) ) / 100) * widthBody;
            let widthsBetPartsCape = [0.15, 0.25, 0.20, 0.25, 0.15];
            let disBetWings = widthsBetPartsCape[2] * maxDistanceCape;
            let widthDownWings = widthsBetPartsCape[1] * maxDistanceCape * 0.8;
            let heightDownWings = ( (65 + randInt(-4, 4) ) / 100) * disFromCenterToDownBody;
            let disFromCenterToUpLineCape = 130 + randInt(-6, 6);
            let lengthUpperLine = maxDistanceCape * 0.75;
            
            
            // 3 layer - head
            let upperWidthHead = widthBody * ( (45 + randInt(-4, 4) ) / 100);
            let lowerWidthHead = upperWidthHead *  ( (40 + randInt(-15, 15) ) / 100);
            let heightHead = disFromCenterToDownBody * ( (73 + randInt(-15, 5) ) / 100);
            let heightChin = heightHead * ( (2 + randInt(-1, 2) ) / 100);
            
            // 4 layer - face
            let heightCenterLip = heightHead * ( (18 + randInt(-1, 1) ) / 100);
            let widthLips = upperWidthHead *  ( (30 + randInt(-1, 5) ) / 100);
            let heightLips = widthLips *   ( (57 + randInt(-3, 0) ) / 100);  
            
            let heightCenterEyes = heightHead * ( (70 + randInt(-2, 2) ) / 100);
            let widthEye = upperWidthHead *  ( (25 + randInt(-3, 3) ) / 100);
            let heightEye = widthEye * ( (77 + randInt(-20, 10) ) / 100);
            let disFromCenterToEye = upperWidthHead * 0.32;
            
            
            let design = randInt(0, 13);
            let cape = randInt(0, 14);
            
            
            let color = `rgb(255, ${randInt(120, 240)}, ${randInt(40, 230)})`;
            
            
            
            (async () =>
            {
            
                
            // 1 layer: up body
            {
                

                gc.beginPath();

                gc.moveTo(-(widthBody / 2), 0);
                gc.quadraticCurveTo(0, heightTrapezoid, widthBody / 2, 0);
                
                gc.lineTo(downWidthBody / 2, -disFromCenterToDownBody);
                gc.lineTo(-downWidthBody / 2, -disFromCenterToDownBody);
                gc.lineTo(-(widthBody / 2), 0);
                
                gc.c.fillStyle = color;
                gc.fill();
                
                

let loaded = false;
let img2 = new Image();
img2.onload =  function() {go()};
img2.src = `design${design}.png`;   // pattern

// MAIN CODE ---
function go() {

  // create a pattern  
  gc.c.fillStyle = gc.c.createPattern(img2, "repeat");
  
  // fill canvas with pattern
  gc.c.fill();
  
  gc.c.stroke();
  
  loaded = true;
}

                
            await new Promise(r => {
                
                (function check()
                {
                    if(loaded) r();
                    else setTimeout(check, 20);
                })();
                
            });

                gc.stroke();
                
            }
            
            
            
            // 2 layer - cape
            {

                gc.beginPath();

                gc.moveTo(0, 0);

                gc.lineTo(disBetWings / 2, 0);

                gc.lineTo(disBetWings / 2, -heightDownWings);

                gc.lineTo(disBetWings / 2 + widthDownWings, -heightDownWings);

                gc.quadraticCurveTo(disBetWings / 2 + widthsBetPartsCape[3] * maxDistanceCape, -(heightDownWings * 0.95), disBetWings / 2 + widthsBetPartsCape[3] * maxDistanceCape, 0);

                gc.lineTo(maxDistanceCape / 2, disFromCenterToUpLineCape * 0.1);

                let endPoint = [lengthUpperLine / 2, disFromCenterToUpLineCape];
                
                gc.bezierCurveTo( endPoint[0] + (maxDistanceCape - endPoint[0]) * 0.2, endPoint[1] * 0.25 , endPoint[0] + (maxDistanceCape - endPoint[0]) * 0.1, endPoint[1] * 0.75, endPoint[0], endPoint[1]);

                // sym
                endPoint = [-lengthUpperLine / 2, disFromCenterToUpLineCape];

                gc.quadraticCurveTo(0, disFromCenterToUpLineCape * 1.2, endPoint[0], endPoint[1]);

                gc.bezierCurveTo(  endPoint[0] - (maxDistanceCape + endPoint[0]) * 0.1, endPoint[1] * 0.75 , endPoint[0] - (maxDistanceCape + endPoint[0]) * 0.2, endPoint[1] * 0.25, -maxDistanceCape / 2, disFromCenterToUpLineCape * 0.1);

    

                gc.lineTo(-(disBetWings / 2 + widthsBetPartsCape[1] * maxDistanceCape), 0);

    
                gc.quadraticCurveTo(-(disBetWings / 2 + widthsBetPartsCape[3] * maxDistanceCape), -(heightDownWings * 0.95), -(disBetWings / 2 + widthDownWings), -(heightDownWings));

    
                gc.lineTo(-disBetWings / 2, -heightDownWings);

                gc.lineTo(-disBetWings / 2, 0);

                gc.lineTo(0, 0);
                
                
                
                

                
                let gradient = gc.c.createLinearGradient(20, 0, 220, 0);
                
                gradient.addColorStop(0, "blue");
                gradient.addColorStop(0.5, "blue");
                gradient.addColorStop(1, "blue");

                gc.c.fillStyle = "#ffffff";
                
                gc.fill();

let loaded = false;
let img2 = new Image();
img2.onload =  function() {go()};
img2.src = `themeCape${cape}.png`;   // pattern

// MAIN CODE ---
function go() {

  // create a pattern  
  gc.c.globalCompositeOperation = "multiply";
  gc.c.fillStyle = gc.c.createPattern(img2, "repeat-y");
  
  // fill canvas with pattern
  gc.c.fill();
  
  gc.c.stroke();
  
  loaded = true;
}

                
            await new Promise(r => {
                
                (function check()
                {
                    if(loaded) r();
                    else setTimeout(check, 20);
                })();
                
            });
                
                
                
            }
            
            
            
            
                  
                        
            // 3 layer - head
            {
    
    
    gc.beginPath();

    
    gc.moveTo(lowerWidthHead / 2, 0);

    gc.quadraticCurveTo(upperWidthHead / 2, heightChin, upperWidthHead / 2, heightHead);

    gc.quadraticCurveTo(0, heightHead * 1.04, -upperWidthHead / 2, heightHead);

    gc.quadraticCurveTo(-upperWidthHead / 2, heightChin, -lowerWidthHead / 2, 0);

    gc.quadraticCurveTo(0, -heightHead * 0.07, lowerWidthHead / 2, 0);

    
    gc.c.globalCompositeOperation = 'destination-out';

    gc.c.globalAlpha = 1;    
    gc.c.fillStyle = '#000'; 
    gc.fill();

    gc.c.globalCompositeOperation = 'source-over';

    //gc.c.fillStyle = "#ffe45c";
    
            
            
    gc.c.fillStyle = color;
            
            
    gc.c.fill();

    gc.stroke();

}
          
          
          
            // 4 - layer - face
            {

            {

    gc.beginPath();

    gc.moveTo(-widthLips / 2, heightCenterLip);

    gc.quadraticCurveTo(0, heightCenterLip - heightLips / 2, widthLips / 2, heightCenterLip);

    gc.quadraticCurveTo(0, heightCenterLip + heightLips / 3, -widthLips / 2, heightCenterLip);

    gc.quadraticCurveTo(0, heightCenterLip - heightCenterLip * 0.99, widthLips / 2, heightCenterLip);

    gc.stroke();

}

            {

    // left eye
    gc.beginPath();

    gc.moveTo(-disFromCenterToEye, heightCenterEyes);

    gc.quadraticCurveTo(-disFromCenterToEye + widthEye / 2, heightCenterEyes + 
 heightEye / 2,  -disFromCenterToEye + widthEye, heightCenterEyes);

    gc.quadraticCurveTo(-disFromCenterToEye + widthEye / 2, heightCenterEyes - heightEye / 2,  -disFromCenterToEye, heightCenterEyes);

    gc.stroke();

    // right eye
    gc.beginPath();

    gc.moveTo(disFromCenterToEye, heightCenterEyes);

    gc.quadraticCurveTo(disFromCenterToEye - widthEye / 2, heightCenterEyes + 
 heightEye / 2,  disFromCenterToEye - widthEye, heightCenterEyes);

    gc.quadraticCurveTo(disFromCenterToEye - widthEye / 2, heightCenterEyes - heightEye / 2,  disFromCenterToEye, heightCenterEyes);

    gc.stroke();
    

    
}

            }
            
            
            
            
            
            
            
            
            
            // up cape
            {

    gc.beginPath();

    gc.moveTo(upperWidthHead / 2, heightHead);
    

    gc.quadraticCurveTo( lengthUpperLine / 2, disFromCenterToUpLineCape, lengthUpperLine / 2 * 1.03, disFromCenterToUpLineCape);

    gc.quadraticCurveTo( 0, disFromCenterToUpLineCape * 1.57, -lengthUpperLine / 2 * 1.03, disFromCenterToUpLineCape);

    gc.quadraticCurveTo( -lengthUpperLine / 2, disFromCenterToUpLineCape, -upperWidthHead / 2, heightHead);

    
    gc.c.globalCompositeOperation = 'destination-out';

    gc.c.globalAlpha = 1;    
    gc.c.fillStyle = '#000'; 
    gc.fill();

    gc.c.globalCompositeOperation = 'source-over';

    gc.c.fillStyle = "#ffffff";
    gc.c.fill();

    
    
let loaded = false;
let img2 = new Image();
img2.onload =  function() {go()};
img2.src = `themeVertCape${cape}.png`;   // pattern

// MAIN CODE ---
function go() {

  // create a pattern  
  gc.c.globalCompositeOperation = "multiply";
  gc.c.fillStyle = gc.c.createPattern(img2, "repeat-y");
  
  // fill canvas with pattern
  gc.c.fill();
  
  gc.c.stroke();
  
  loaded = true;
}

                
            await new Promise(r => {
                
                (function check()
                {
                    if(loaded) r();
                    else setTimeout(check, 20);
                })();
                
            });

    gc.stroke();

    
    
}
            
            
            
            
            
            
            // save image
            let imgData = c.getImageData((innerWidth - innerHeight) / 2, 0, innerHeight, innerHeight);

            canvas.width = canvas.height = innerHeight;

            c.putImageData(imgData, 0, 0);
            
            
            let base64 = canvas.toDataURL();
            
            
            
            // sent to server
            let blob = await (await fetch(base64)).blob();
            let counter = await fetch('counter.txt').then(d => d.text()).then(t => t);
            
            let formData = new FormData();
            formData.append("image", blob, `image${counter}.png`);
            
            
            await fetch('acceptfile.php',
            {
                method: 'POST',
                body: formData
            });
            
            
            location.href = location.href;
            
            
            
            
                
            })();
            
            
            
            
            // draw curve lines with help mouse
            let mouseActions = new Array();
            {
                
                let mouseOverCanvas = false, mousePressed = false;
                
                    canvas.addEventListener('mouseover', () =>
                	{
                	    mouseOverCanvas = true;
                	});
                	canvas.addEventListener('mouseout', () =>
                	{
                	    mouseOverCanvas = false;
                	});
                	canvas.addEventListener('mousedown', () =>
                	{
                	    mousePressed = true;
                	});
                	canvas.addEventListener('mouseup', () =>
                	{
                	    mousePressed = false;
                	});
                	canvas.addEventListener('mousemove', (e) =>
                	{
                	    
                	    let action = null;
                	    
                	    mouseOverCanvas && mousePressed && (action = (e) =>
                	    {
                	        c.save();
                	        
                	        
                	        c.fillStyle = "black";
                	        c.fillRect(e.clientX, e.clientY, 1, 1);
                	        
                	        
                	        c.restore();
                	    })(e);
                	    
                	    action && mouseActions.push(() => action(e));
                	    
                	});
            }
            
            
            
            
            function randInt(min, max) { // min and max included
                return Math.floor(Math.random() * (max - min + 1) + min)
            }
            
            
        </script>
    </body>
</html>
'''
'''--- README.md ---
# Exploring_Egyptian_Tombs

Game Special For js13Games!

Nickname: Musplay
twitter: @VadimSabitov6

'''
'''--- index.html ---
<html>
    <head>
        <style>
            body{
                background-color: black;
                margin: 0;
                overflow-x: hidden;
                overflow-y: hidden;
            }
            particle {
                position: fixed;
                top: 0;
                left: 0;
                opacity: 0;
                pointer-events: none;
                background-repeat: no-repeat;
                background-size: contain;
            }
        
        .but {
	font-weight:bold;
	text-decoration:none;
	font-family:Arial;
	box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 3px 2px;
	o-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 3px 2px;
	-moz-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 3px 2px;
	-webkit-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 3px 2px;
	background:#000000;
	background:-o-linear-gradient(90deg, #000000, #000000);
	background:-moz-linear-gradient( center top, #000000 5%, #000000 100% );
	background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #000000), color-stop(1, #000000) );
	filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#000000', endColorstr='#000000');
	background:-webkit-linear-gradient(#000000, #000000);
	background:-ms-linear-gradient(#000000, #000000);
	background:linear-gradient(#000000, #000000);
	text-indent:0px;
	-moz-border-radius:25px;
	-webkit-border-radius:25px;
	border-radius:25px;
	text-align:center;
	vertical-align:middle;
	display:inline-block;
	color:#ffffff;
	text-shadow:#030405 2px 2px 0px;
	border-color:#0d1f24;
	border-width:2px;
	border-style:solid;
}

.but:active {
	box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 0 2px;
	o-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 0 2px;
	-moz-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 0 2px;
	-webkit-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 0 2px;
	position:relative;
}

.but:hover {
	background:#000000;
	background:-o-linear-gradient(90deg, #000000, #000000);
	background:-moz-linear-gradient( center top, #000000 5%, #000000 100% );
	background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #000000), color-stop(1, #000000) );
	filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#000000', endColorstr='#000000');
	background:-webkit-linear-gradient(#000000, #000000);
	background:-ms-linear-gradient(#000000, #000000);
	background:linear-gradient(#000000, #000000);
}
        </style>
    </head>
    <body>
        <table style="position: absolute;">
        <tr>
            <td>
                <div><canvas id="main" style="margin: 0; 
                cursor: url('cursor.cur'), pointer;"></canvas></div>
            </td>
            <td>
                <div>
                    <canvas id="mini" style="margin: 0;"></canvas>
                    <canvas id="textContainer" style="margin: 0;"></canvas>
                </div>
            </td>
        </tr>
        </table>
        <div id="root"></div>
        <div id="title" style='overflow-wrap: break-word; position: absolute; z-index: 5;'><span></span></div>
        <div id="description" style='overflow-wrap: break-word; position: absolute; z-index: 5;'><span></span></div>
        <div id="rewardBack" style='width: 0px; height: 0px; position: absolute; z-index: 7; background: rgb(129,130,133);
background: radial-gradient(circle, rgba(129,130,133,0.77) 1%, rgba(0,0,0,0.84) 100%);'>
        </div>
        <script src="https://js13kgames.com/src/near-api-js.js" type="text/javascript"></script>
        <script>
        const mainCanvas=document.getElementById("main"),miniCanvas=document.getElementById("mini"),textContainer=document.getElementById("textContainer"),title=document.getElementById("title"),description=document.getElementById("description"),rewardBack=document.getElementById("rewardBack"),c=mainCanvas.getContext("2d"),miniCntx=miniCanvas.getContext("2d"),MAIN_CANVAS_WIDTH=.7,MINI_CANVAS_HEIGHT=.4;let contract,account,wallet,near,nearApi;(async()=>{await a();let t=()=>{wallet.requestSignIn("js13game-vadimsab.testnet")},e=()=>{wallet.signOut(),window.location.reload()};async function n(t){console.log(t,account,contract);let e=await contract.nft_reassign_ownership({token_id:t,new_token_owner_id:account.accountId});-1!==e.indexOf("Success")?console.log(t+`owned by ${account.accountId}`):console.log("error"),console.log("Transfer Result",e)}async function i(t){let e=await contract.get_token({token_id:t});return e}async function a(){nearAPI=window.nearApi;let{keyStores:t,connect:e,WalletConnection:n}=nearAPI,i=new t.BrowserLocalStorageKeyStore;near=await e({networkId:"testnet",keyStore:i,nodeUrl:"https://rpc.testnet.near.org",walletUrl:"https://wallet.testnet.near.org",helperUrl:"https://helper.testnet.near.org",explorerUrl:"https://explorer.testnet.near.org"}),wallet=new n(near)}function l(){mainCanvas.width=.7*innerWidth,mainCanvas.height=innerHeight,c.save(),c.fillStyle="#F0D698",c.fillRect(0,0,1e9,1e9),c.restore(),miniCanvas.width=.30000000000000004*innerWidth,miniCanvas.height=.4*innerHeight,miniCntx.save(),miniCntx.fillStyle="#413D51",miniCntx.fillRect(0,0,1e9,1e9),miniCntx.restore(),textContainer.width=miniCanvas.width,textContainer.height=innerHeight-miniCanvas.height}l();{let o=!1,s=!1,r=!0,$=!0,d=!0,h=0,p=1;async function m(t){h++;let e=j(5,13);for(let a=0;a<e;a++)g(t.clientX,t.clientY,a==e-1);if(!$){await C();return}if($=!1,h>=p){h=0,p=j(5,13);let l=j(0,4),o;if(4==l&&wallet.isSignedIn()){console.log("res == 4");let s=`${100*j(1500,4900)}`;console.log(s);let r=await i(s);console.log("res",r),r&&"js13game-vadimsab.testnet"==r.owner_id&&(new Image,console.log(await n(s)),(o=await fetch(r.metadata.media).then(t=>t.blob()).catch(t=>console.log(t)))&&o?.size!=221&&await U(o,`Pharaoh Sculpture P_${s/100}`))}else l>=2&&(new Image,o=await (await fetch(`https://bafybeiakx5f4pioiexvk5xwcubw52x3cnaf4cs5yyztre5bhafu3oc5b5e.ipfs.nftstorage.link/egyptfiles/1 (${[j(0,28)]}).jpg`)).blob());await C(new Image,o)}else await C();$=!0}function g(t,e,n){let i=document.createElement("particle");document.body.appendChild(i);var a="rgba(60, 60, 60, 255)";i.style.boxShadow=`0 0 50px ${100*Math.random()/5}px ${a}`,i.style.background=a,i.style.borderRadius="50%",width=height=1e-10,i.style.width=`${width}px`,i.style.height=`${height}px`;let l=i.animate([{transform:`translate(-50%, -50%) translate(${t}px, ${e}px) rotate(0deg)`,opacity:1},{transform:`translate(-50%, -50%) translate(${t+(Math.random()-.5)*300}px, ${e+(Math.random()-.5)*300}px) rotate(${520*Math.random()}deg)`,opacity:0}],{duration:777,easing:"cubic-bezier(0, .9, .57, 1)",delay:200*Math.random()});n?l.onfinish=t=>{r=!0,f(t)}:l.onfinish=f}function f(t){t.srcElement.effect.target.remove()}(()=>{let t=0;setInterval(()=>{$?t=0:t++,t>=35&&($=!0)},100)})(),document.body.animate&&(mainCanvas.addEventListener("mouseover",()=>{o=!0}),mainCanvas.addEventListener("mouseout",()=>{o=!1}),mainCanvas.addEventListener("mousedown",()=>{s=!0}),mainCanvas.addEventListener("mouseup",()=>{s=!1}),mainCanvas.addEventListener("mousemove",t=>{o&&s&&r&&$&&d&&m(t),d=!1,setTimeout(()=>d=!0,3e3)}))}let x=function(){let t=[1,2.5],e=["rgb(255, 211, 95)","rgb(252, 217, 117)","rgb(239, 169, 94)","rgb(255, 185, 97)"],n=[.01,.02,.03,.05],i=mainCanvas.width/22,a=.95*i,l=(l,o)=>{let s=t[j(0,t.length-1)],r=e[j(0,e.length-1)],$=n[j(0,n.length-1)];return c.save(),c.fillStyle="black",c.fillRect(l,o,i*s,a),c.fillStyle=r,c.fillRect(l+$,o+$,i*s-2*$,a-2*$),c.restore(),s},o=[0,0];for(;o[0]<mainCanvas.width||o[1]<mainCanvas.height;){o[0]>mainCanvas.width&&(o[0]=0,o[1]+=a);let s=l(o[0],o[1]);o[0]+=i*s}};x();let w=miniCanvas.width>miniCanvas.height?.8*miniCanvas.height:.8*miniCanvas.width,y=w,u=(miniCanvas.width-w)/2,_=(miniCanvas.height-y)/2,C=async(t,e)=>{if(miniCntx.save(),miniCntx.fillStyle="#413D51",miniCntx.fillRect(0,0,1e9,1e9),miniCntx.restore(),miniCntx.save(),miniCntx.fillStyle="#413D59",miniCntx.fillRect(u,_,w,w),miniCntx.restore(),t instanceof Image&&e){miniCntx.save(),miniCntx.fillStyle="#413D51",miniCntx.fillRect(0,0,1e9,1e9),miniCntx.restore(),t.src=URL.createObjectURL(e);let n=!0;t.onload=function(){n=!1},await new Promise(t=>{!function e(){(n||t())&&setTimeout(e,20)}()});let i=t.width,a=t.height,l=0,o=0;i>a?(t.width=w+"px",t.height=w/i*a+"px",o=(y-t.height)/4,miniCntx.drawImage(t,u+(l||0),_+o?o:0)):(console.log(t.width,t.height,miniCanvas.height/4),l=-(2*u),miniCntx.drawImage(t,miniCanvas.height/8,miniCanvas.height/8,miniCanvas.height/4*3,miniCanvas.height/4*3)),t.remove(),URL.revokeObjectURL(t.src)}else miniCntx.save(),miniCntx.fillStyle="white",miniCntx.font=`${w/14}px serif`,miniCntx.fillText("EMPTY"+[".","..","..."][j(0,2)],2*u-w/14/1.2,_+y/2,w/2.7),miniCntx.restore()};C();let v=(t,e,n,i,a)=>{let l=document.createElement("button");return root.append(l),l.style.cssText="cursor: pointer;",l.style.left=t+"px",l.style.top=e+"px",l.style.width=n,l.style.height=i,l.style.position="absolute",l.style.fontSize=i/2+"px",l.style.zIndex=5,l.style.lineHeight=`${innerHeight/35}px`,l.setAttribute("class","but"),a&&(l.innerHTML=a),l},b=(t,e,n)=>{let i=document.createElement("div"),a=document.createElement("span");return root.append(i),i.append(a),a.style.cssText=`
                    font-family: "Lucida Console", Monaco, monospace;
                    letter-spacing: 0px;
                    word-spacing: -2px;
                    color: #000000;
                    text-decoration: none;
                    font-style: normal;
                    font-variant: normal;
                    text-transform: uppercase;`,a.innerHTML=e,a.id=n,a.style.fontSize=parseInt(t.style.height)/2+"px",a.style.color="white",i.style.left=parseInt(t.style.left)-1.05*parseInt(t.style.width)+"px",i.style.top=parseInt(t.style.top)-parseInt(t.style.height)/2+"px",i.style.position="absolute",i.style.zIndex=5,!0},I=textContainer.width,E=textContainer.height;{let S,k,L,T=0;if(T=(L=I/6)/3.5,S=innerWidth-L-.01*innerHeight,k=innerHeight-T-.01*innerHeight,wallet.isSignedIn()){let B=wallet.getAccountId();console.log("IS SIGNED IN!",B),account=await near.account(wallet._authData.accountId);let R=await account.state();console.log("STATE",R),contract=new nearAPI.Contract(account,"js13game-vadimsab.testnet",{viewMethods:["get_token"],changeMethods:["nft_reassign_ownership"],sender:account});let M;(M=v(S,k,L,T,"SIGN OUT")).onclick=e,b(M,B,"nameWallet")}else v(S,k,L,T,"SIGN IN").onclick=t}{let z,A,H,N=0;N=(H=I/6)/3.5,v(z=innerWidth-I+.01*innerHeight,A=innerHeight-N-.01*innerHeight,1.3*H,N,"OTHER WALL").onclick=x}let D=(t,e,n="rgb(250, 210, 1)")=>{title.width=.5*I,description.width=.85*I,title.children[0].style.cssText=description.children[0].style.cssText=`
                    font-family: "Lucida Console", Monaco, monospace;
                    letter-spacing: 0px;
                    word-spacing: -2px;
                    text-decoration: none;
                    font-style: normal;
                    font-variant: normal;
                    text-transform: uppercase;
                    color: ${n};`,title.children[0].fontSize=E/5+"px",description.children[0].fontSize=E/3+"px",title.children[0].innerHTML=t,description.children[0].innerHTML=e,title.height=E/14,description.height=E/2,getComputedStyle(title),getComputedStyle(description),title.style.left=innerWidth-I+(I-title.width)/2+"px",description.style.left=innerWidth-I+(I-description.width)/2+"px",title.style.top=innerHeight-E+.03*innerHeight+"px",description.style.top=parseInt(title.style.top)+title.height+.01*innerHeight+"px"};D("Wipe the walls in search of treasures!","Explore the walls of the Egyptian borders, find out the afterlife cult of this people and also find and collect sculptures of deceased pharaohs. Each such sculpture is unique, finding it first you will become the only owner of it!");let U=async(t,e)=>{let n=document.createElement("img");document.body.append(n),n.src=URL.createObjectURL(t);let i=!0;n.onload=function(){i=!1},await new Promise(t=>{!function e(){(i||t())&&setTimeout(e,20)}()}),n.style.position="absolute",n.style.zIndex=100,n.height=n.width=.5*innerHeight,n.style.left=innerWidth/2-n.width/2+"px",n.style.top=.2*innerHeight,n.id="imgRew";let a=document.createElement("div");document.body.append(a),a.id="textEl",a.style.cssText=`
                    font-family: "Lucida Console", Monaco, monospace;
                    letter-spacing: 0px;
                    word-spacing: -2px;
                    color: #000000;
                    text-decoration: none;
                    font-style: normal;
                    font-variant: normal;
                    text-transform: uppercase;
                    align: center;`,a.style.position="absolute",a.style.color="white",a.style.zIndex=100,a.style.top=.65*innerHeight+"px",a.innerHTML=`<center>Congratulations! You have found one of the Pharaoh sculptures(${e})! Now it is only yours! 
                <br><br>
                Click to continue..</center>`,a.style.fontSize=.02*innerHeight+"px",a.style.left=innerWidth/2-parseInt(getComputedStyle(a).width)/2+"px",rewardBack.style.width=innerWidth+"px",rewardBack.style.height=innerHeight+"px"};function j(t,e){return Math.floor(Math.random()*(e-t+1)+t)}rewardBack.onclick=()=>{document.getElementById("imgRew")?.remove(),document.getElementById("textEl")?.remove(),rewardBack.style.width="0px",rewardBack.style.height="0px"}})();
        </script>
    </body>
</html>
'''
'''--- indexSource.html ---
<html>
    <head>
        <style>
            body{
                background-color: black;
                margin: 0;
                overflow-x: hidden;
                overflow-y: hidden;
            }
            particle {
                position: fixed;
                top: 0;
                left: 0;
                opacity: 0;
                pointer-events: none;
                background-repeat: no-repeat;
                background-size: contain;
            }
        
        .but {
	font-weight:bold;
	text-decoration:none;
	font-family:Arial;
	box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 3px 2px;
	o-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 3px 2px;
	-moz-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 3px 2px;
	-webkit-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 3px 2px;
	background:#000000;
	background:-o-linear-gradient(90deg, #000000, #000000);
	background:-moz-linear-gradient( center top, #000000 5%, #000000 100% );
	background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #000000), color-stop(1, #000000) );
	filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#000000', endColorstr='#000000');
	background:-webkit-linear-gradient(#000000, #000000);
	background:-ms-linear-gradient(#000000, #000000);
	background:linear-gradient(#000000, #000000);
	text-indent:0px;
	-moz-border-radius:25px;
	-webkit-border-radius:25px;
	border-radius:25px;
	text-align:center;
	vertical-align:middle;
	display:inline-block;
	color:#ffffff;
	text-shadow:#030405 2px 2px 0px;
	border-color:#0d1f24;
	border-width:2px;
	border-style:solid;
}

.but:active {
	box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 0 2px;
	o-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 0 2px;
	-moz-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 0 2px;
	-webkit-box-shadow:inset #ffffff 0px 5px 8px -1px,#d6d6d6 1px 0 2px;
	position:relative;
}

.but:hover {
	background:#000000;
	background:-o-linear-gradient(90deg, #000000, #000000);
	background:-moz-linear-gradient( center top, #000000 5%, #000000 100% );
	background:-webkit-gradient( linear, left top, left bottom, color-stop(0.05, #000000), color-stop(1, #000000) );
	filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#000000', endColorstr='#000000');
	background:-webkit-linear-gradient(#000000, #000000);
	background:-ms-linear-gradient(#000000, #000000);
	background:linear-gradient(#000000, #000000);
}
        </style>
    </head>
    <body>
        <table style="position: absolute;">
        <tr>
            <td>
                <div><canvas id="main" style="margin: 0; 
                cursor: url('cursor.cur'), pointer;"></canvas></div>
            </td>
            <td>
                <div>
                    <canvas id="mini" style="margin: 0;"></canvas>
                    <canvas id="textContainer" style="margin: 0;"></canvas>
                </div>
            </td>
        </tr>
        </table>
        <div id="root"></div>
        <div id="title" style='overflow-wrap: break-word; position: absolute; z-index: 5;'><span></span></div>
        <div id="description" style='overflow-wrap: break-word; position: absolute; z-index: 5;'><span></span></div>
        <div id="rewardBack" style='width: 0px; height: 0px; position: absolute; z-index: 7; background: rgb(129,130,133);
background: radial-gradient(circle, rgba(129,130,133,0.77) 1%, rgba(0,0,0,0.84) 100%);'>
        </div>
        <script src="https://js13kgames.com/src/near-api-js.js" type="text/javascript"></script>
        <script>
        
        
        
        
        
        
            // # CONSTANTS
            const mainCanvas = document.getElementById('main');
            const miniCanvas = document.getElementById('mini');
            const textContainer = document.getElementById('textContainer');
            const title = document.getElementById('title');
            const description = document.getElementById('description');
            const rewardBack = document.getElementById('rewardBack');
            
            const c = mainCanvas.getContext('2d');
            const miniCntx = miniCanvas.getContext('2d');
            
            const MAIN_CANVAS_WIDTH = 0.70; // percents
            const MINI_CANVAS_HEIGHT = 0.40; // percents
            
            
                
let contract;
let account;
let wallet;
let near;
let nearApi;
                
        
   (async () =>
   {
            
            // ### NEAR JS  
await initNEAR();

const signIn = () => {
  wallet.requestSignIn(
    'js13game-vadimsab.testnet', // contract requesting access
  )
}

const signOut = () => {
  wallet.signOut()

  window.location.reload()
}

async function claimNFT(id) {

  console.log(id, account, contract);

  /**
   * This can be enabled if tokens show up for a given user.
   */
  const result = await contract.nft_reassign_ownership({
    token_id: id,
    new_token_owner_id: account.accountId,
  })

  if (result.indexOf('Success') !== -1) {
    console.log(id + `owned by ${account.accountId}`);
  }
  else {
    console.log('error');
  }

  console.log('Transfer Result', result)
}

async function viewNFT(id) {
  const result = await contract.get_token({
    token_id: id,
  })

  return result
}

async function initNEAR() {
  nearAPI = window.nearApi

  /**
   * USER KEYSTORE
   */
  const { keyStores, connect, WalletConnection } = nearAPI
  const keyStore = new keyStores.BrowserLocalStorageKeyStore()
  const config = {
    networkId: 'testnet',
    keyStore, // optional if not signing transactions
    nodeUrl: 'https://rpc.testnet.near.org',
    walletUrl: 'https://wallet.testnet.near.org',
    helperUrl: 'https://helper.testnet.near.org',
    explorerUrl: 'https://explorer.testnet.near.org',
  }

  near = await connect(config)

  wallet = new WalletConnection(near);
}
            
            
            
            
            
            
            
            
        
        
        
        
        
                
                
                
            // add onresize listener
            {
                // document.body.addEventListener('resize', resize);
            
                function resize()
                {
                
                    // rendering main canvas
                    mainCanvas.width = innerWidth * MAIN_CANVAS_WIDTH;
                    mainCanvas.height = innerHeight;
                    c.save();
                    c.fillStyle = '#F0D698';
                    c.fillRect(0, 0, 1e9, 1e9);
                    c.restore();
                    
                    
                    
                    // rendering mini canvas
                    miniCanvas.width = innerWidth * (1 - MAIN_CANVAS_WIDTH);
                    miniCanvas.height = innerHeight * MINI_CANVAS_HEIGHT;
                    miniCntx.save();
                    miniCntx.fillStyle = '#413D51';
                    miniCntx.fillRect(0, 0, 1e9, 1e9);
                    miniCntx.restore();
                    
                    
                    
                    // rendering text container
                    textContainer.width = miniCanvas.width;
                    textContainer.height = innerHeight - miniCanvas.height;
                
                }
                resize();
            }
            
            
            // add onmouseover listener
            {
                let mouseOverCanvas = false, mousePressed = false, prevAnimIsFinished = true, prevAsyncQuery = true, pause = true;
                let counterWash = 0, limit = 1;//randInt(5, 15);
                
                
                
                
                
                
                
            
            (() =>
            {
            let cp = 0;
            setInterval( () =>
            {
                if(!prevAsyncQuery)
                    cp++;
                else
                    cp = 0;
                    
                if(cp >= 35)
                    prevAsyncQuery = true;
                
            }, 100);
            })();
            
            
                
                
                
                
                
                
                
                
                
                async function pop (e) {
                    counterWash++;
                    let countIter = randInt(5, 13);
	                	for (let i = 0; i < countIter; i++) {
	                		createParticle(e.clientX, e.clientY, i == countIter - 1);
	                	}
	                	
	                if(!prevAsyncQuery) { await showImage(); return; }
	                
	                
                    prevAsyncQuery = false;
	                	
	                if(counterWash >= limit)
	                {
	                    counterWash = 0, limit = randInt(5, 13);
	                    
	                    
	                    let res = randInt(0, 4);
	                    let image, blob;
	                    
	                    if(res == 4 && wallet.isSignedIn())
	                    {
	                        console.log("res == 4");
	                        
	                        let idImg = `${(randInt(1500, 4900) * 100)}`;
	                        console.log(idImg);
	                        let res = await viewNFT(idImg);
	                        
	                        console.log("res", res);
	                        
	                        
	                        if(res && res.owner_id == 'js13game-vadimsab.testnet')
	                        {
	                            
	                            image = new Image();
	                            
	                            console.log( await claimNFT(idImg) );
	                            
	                            blob = await (fetch(res.metadata.media).then(rd => rd.blob()).catch(e => console.log(e)));
	                            
	                            
	                            blob && blob?.size != 221 && await showReward(blob, `Pharaoh Sculpture P_${idImg/100}`);
	                            
	                        }
	                    }
	                    else if(res >= 2)
	                    {
	                        image = new Image();
	                        
	                        blob = await (await fetch(`https://bafybeiakx5f4pioiexvk5xwcubw52x3cnaf4cs5yyztre5bhafu3oc5b5e.ipfs.nftstorage.link/egyptfiles/1 (${[randInt(0, 28)]}).jpg`)).blob();
	                    }
	                    
	                    await showImage(new Image(), blob);
	                    
	                }
	                else await showImage();
	                
	                prevAsyncQuery = true;
	                
                }
                function createParticle (x, y, isFinishedIter) {
                    
                	const particle = document.createElement('particle');
	                document.body.appendChild(particle);
	                let destinationX = (Math.random() - 0.5) * 300;
	                let destinationY = (Math.random() - 0.5) * 300;
	                let rotation = Math.random() * 520;
	                let delay = Math.random() * 200;
	                
	                	var color = `rgba(60, 60, 60, 255)`; // Цвет 
	                	particle.style.boxShadow = `0 0 50px ${(Math.random() * 100)/5}px ${color}`; // Тень
	                	particle.style.background = color;
	                	particle.style.borderRadius = '50%'; // Радиус
	                	width = height = 1e-10; // Размеры
	                	
	                particle.style.width = `${width}px`;
	                particle.style.height = `${height}px`;
	                const animation = particle.animate([
	                	{
	                		transform: `translate(-50%, -50%) translate(${x}px, ${y}px) rotate(0deg)`,
	                		opacity: 1
	                	},
	                	{
	                		transform: `translate(-50%, -50%) translate(${x + destinationX}px, ${y + destinationY}px) rotate(${rotation}deg)`,
	                		opacity: 0
	                	}
	                	], {
	                	duration: 777, // Продолжительность всех эффектов
	                	easing: 'cubic-bezier(0, .9, .57, 1)',
	                	delay: delay
	                });
	                if(isFinishedIter)
	                {
	                    animation.onfinish = (e) =>
	                    {
	                        prevAnimIsFinished = true;
	                        removeParticle(e);
	                    };
	                }
	                else
	                    animation.onfinish = removeParticle;
                }
                function removeParticle (e) {
                	e.srcElement.effect.target.remove();
                }
                
                if (document.body.animate) {
                	mainCanvas.addEventListener('mouseover', () =>
                	{
                	    mouseOverCanvas = true;
                	});
                	mainCanvas.addEventListener('mouseout', () =>
                	{
                	    mouseOverCanvas = false;
                	});
                	mainCanvas.addEventListener('mousedown', () =>
                	{
                	    mousePressed = true;
                	});
                	mainCanvas.addEventListener('mouseup', () =>
                	{
                	    mousePressed = false;
                	});
                	mainCanvas.addEventListener('mousemove', (e) =>
                	{
                	    mouseOverCanvas && mousePressed && prevAnimIsFinished && prevAsyncQuery && pause && pop(e);
                	    pause = false;
                	    setTimeout(() => pause = true, 3e3);
                	});
                }
                
                
                
            }
            
            
            // generating the bricks
            const buildWall = function(){
                let sizesBricks = [1, 2.5];
                let colorsBricks = ["rgb(255, 211, 95)", "rgb(252, 217, 117)", "rgb(239, 169, 94)", "rgb(255, 185, 97)"];
                let bordersBrick = [0.01, 0.02, 0.03, 0.05];
                const WIDTH_BRICK = mainCanvas.width / 22;
                const HEIGHT_BRICK = WIDTH_BRICK * 0.95;
                
                
                
                const generateRandomBrick = (x, y) =>
                {
                    let sizeBrick = sizesBricks[randInt(0, sizesBricks.length - 1)];
                    let colorBrick = colorsBricks[randInt(0, colorsBricks.length - 1)];
                    let borderBrick = bordersBrick[randInt(0, bordersBrick.length - 1)];
                    
                    
                    // rendering the brick
                    
                    
                    c.save();
                    
                    // border
                    c.fillStyle = 'black';
                    c.fillRect(x, y, WIDTH_BRICK * sizeBrick, HEIGHT_BRICK);
                    
                    // self brick
                    c.fillStyle = colorBrick;
                    c.fillRect(x + borderBrick, y + borderBrick, WIDTH_BRICK * sizeBrick - borderBrick * 2, HEIGHT_BRICK - borderBrick * 2);
                    
                    c.restore();
                    
                    
                    
                    
                    return sizeBrick;
                };
                
                
                let brushPos = [0, 0];
                
                while(brushPos[0] < mainCanvas.width || brushPos[1] < mainCanvas.height)
                {
                    
                    if(brushPos[0] > mainCanvas.width)
                    {
                        brushPos[0] = 0;
                        brushPos[1] += HEIGHT_BRICK;
                    }
                    
                    let size = generateRandomBrick(brushPos[0], brushPos[1]);
                    
                    brushPos[0] += WIDTH_BRICK * size;
                }
            };
            buildWall();
            
            
            
            
            
            
            
            
            
            
            
            
            
            // ### MINI WINDOW
            const WIDTH_VIEWPORT_WINDOW = miniCanvas.width > miniCanvas.height ? miniCanvas.height * 0.8 : miniCanvas.width * 0.8;
            const HEIGHT_VIEWPORT_WINDOW = WIDTH_VIEWPORT_WINDOW;
            const offsetXMiniWindow = (miniCanvas.width - WIDTH_VIEWPORT_WINDOW) / 2;
            const offsetYMiniWindow = (miniCanvas.height - HEIGHT_VIEWPORT_WINDOW) / 2;
            const showImage = async (HTMLImage, blobDataImage) =>
            {
                
                // at first to default
                miniCntx.save();
                miniCntx.fillStyle = '#413D51';
                miniCntx.fillRect(0, 0, 1e9, 1e9);
                miniCntx.restore();
                
                
                // drawing viewport
                miniCntx.save();
                miniCntx.fillStyle = '#413D59';
                miniCntx.fillRect(offsetXMiniWindow, offsetYMiniWindow, WIDTH_VIEWPORT_WINDOW, WIDTH_VIEWPORT_WINDOW);
                miniCntx.restore();
                
                
                
                // rendering photo
                if(HTMLImage instanceof Image && blobDataImage)
                {
                    
                miniCntx.save();
                miniCntx.fillStyle = '#413D51';
                miniCntx.fillRect(0, 0, 1e9, 1e9);
                miniCntx.restore();
                    
                    
                    HTMLImage.src = URL.createObjectURL(blobDataImage);
                    
                    let lock = true;
                    HTMLImage.onload = function()
                    {
                        lock = false;
                    };
                    
                    await new Promise(r =>
                    {
                        
                        (function check()
                        {
                            !lock && !r() || setTimeout(check, 20);
                        })();
                        
                    });
                    
                    let width = HTMLImage.width, height = HTMLImage.height;
                    
                    
                    let addOffsetPerX = 0, addOffsetPerY = 0;
                    
                    if(width > height)
                    {
                        
                        HTMLImage.width = WIDTH_VIEWPORT_WINDOW + 'px';
                        HTMLImage.height = WIDTH_VIEWPORT_WINDOW / width * height + 'px';
                        
                        addOffsetPerY = (HEIGHT_VIEWPORT_WINDOW - HTMLImage.height) / 4;
                        
                    
                        miniCntx.drawImage(HTMLImage, offsetXMiniWindow + (addOffsetPerX ? addOffsetPerX : 0), (offsetYMiniWindow + addOffsetPerY ? addOffsetPerY : 0));
                    }
                    else
                    {
                        console.log(HTMLImage.width, HTMLImage.height, miniCanvas.height / 4);
                        
                        addOffsetPerX = -offsetXMiniWindow * 2;
                    
                        miniCntx.drawImage(HTMLImage, miniCanvas.height / 8, miniCanvas.height / 8, miniCanvas.height / 4 * 3, miniCanvas.height / 4 * 3);
                    }
                    
                    
                    
                    
                    // release resources
                    HTMLImage.remove();
                    URL.revokeObjectURL(HTMLImage.src);
                    
                }
                else
                {
                    
                    miniCntx.save();
                    miniCntx.fillStyle = 'white';
                    miniCntx.font = `${WIDTH_VIEWPORT_WINDOW / 14}px serif`;
                    miniCntx.fillText("EMPTY" + ['.', '..', '...'][randInt(0, 2)], offsetXMiniWindow * 2 - (WIDTH_VIEWPORT_WINDOW / 14 / 1.2), offsetYMiniWindow + HEIGHT_VIEWPORT_WINDOW / 2, WIDTH_VIEWPORT_WINDOW / 2.7);
                    miniCntx.restore();
                    
                    
                }
                
            };
            showImage();
            
            
            
            
            
            
            
            
            
            
            
            
            
            // ### TEXT CONTAINER
            const generateButton = (x, y, width, height, text) =>
            {
              
                let button = document.createElement('button');
                
                root.append(button);
                
                button.style.cssText = 'cursor: pointer;';
                button.style.left = x + 'px';
                button.style.top = y + 'px';
                button.style.width = width;
                button.style.height = height;
                button.style.position = 'absolute';
                button.style.fontSize = height / 2 + 'px';
                button.style.zIndex = 5;
                button.style.lineHeight = `${innerHeight/35}px`;
                button.setAttribute('class', 'but');
                
                
                if(text)
                    button.innerHTML = text;
                
                return button;
            };
            const addText = (button, textSpan, id) =>
            {
                            
                let wrapper = document.createElement('div');            
                let text = document.createElement('span');
                root.append(wrapper);
                wrapper.append(text);
                
                text.style.cssText = `
                    font-family: "Lucida Console", Monaco, monospace;
                    letter-spacing: 0px;
                    word-spacing: -2px;
                    color: #000000;
                    text-decoration: none;
                    font-style: normal;
                    font-variant: normal;
                    text-transform: uppercase;`;
                    
                text.innerHTML = textSpan;  
                text.id = id;
                text.style.fontSize = parseInt(button.style.height) / 2  + 'px';
                text.style.color = 'white';
                        
                wrapper.style.left = parseInt(button.style.left) - parseInt(button.style.width) * 1.05 + 'px';
                wrapper.style.top = parseInt(button.style.top) - parseInt(button.style.height) / 2 /*- parseInt(button.style.height) / 4*/ + 'px';
                wrapper.style.position = 'absolute';
                wrapper.style.zIndex = 5;
                
                return true;
            }
            
            const WIDTH_TEXT_CONTAINER = textContainer.width;
            const HEIGHT_TEXT_CONTAINER = textContainer.height;
            
            
            
            // # AUTHORIZATION
            {
                // button SIGN IN/SIGN OUT
                let xButton, yButton, wButton, hButton = 0;
                
                wButton = WIDTH_TEXT_CONTAINER / 6;
                hButton = wButton / 3.5;
                
                xButton = innerWidth - wButton - innerHeight * 0.01;
                yButton = innerHeight - hButton - innerHeight * 0.01;
                
                
                

  if (wallet.isSignedIn()) {
    const acct = wallet.getAccountId()

    console.log('IS SIGNED IN!', acct);

    account = await near.account(wallet._authData.accountId)
    const response = await account.state()

    console.log('STATE', response)

    contract = new nearAPI.Contract(
      account, // the account object that is connecting
      'js13game-vadimsab.testnet',
      {
      // name of contract you're connecting to
        viewMethods: ['get_token'], // view methods do not change state but usually return a value
        changeMethods: ['nft_reassign_ownership'], // change methods modify state
        sender: account, // account object to initialize and sign transactions.
      },
    );
    
             
                
                let but;
                
                (but = generateButton( xButton, yButton, wButton, hButton, "SIGN OUT" )).onclick = signOut;
                
                
                addText(but, acct, "nameWallet");
    
    
  }
  else
    generateButton( xButton, yButton, wButton, hButton, "SIGN IN" ).onclick = signIn;
            
            }
            
            
            
            
            
            
            
            
            // # REGENERATE WALL FUNC
            {
                
                let xButton, yButton, wButton, hButton = 0;
                
                wButton = WIDTH_TEXT_CONTAINER / 6;
                hButton = wButton / 3.5;
                
                xButton = innerWidth - WIDTH_TEXT_CONTAINER + innerHeight * 0.01;
                yButton = innerHeight - hButton - innerHeight * 0.01;
                
                
                generateButton( xButton, yButton, wButton * 1.3, hButton, "OTHER WALL" ).onclick = buildWall;
                
            }
            
            
            // # TITLE and DESCRIPTION
            const setText = (titleText, descriptionText, color = "rgb(250, 210, 1)") =>
            {
              
              title.width = WIDTH_TEXT_CONTAINER * 0.5;
              description.width = WIDTH_TEXT_CONTAINER * 0.85;
              
              
              title.children[0].style.cssText = description.children[0].style.cssText = `
                    font-family: "Lucida Console", Monaco, monospace;
                    letter-spacing: 0px;
                    word-spacing: -2px;
                    text-decoration: none;
                    font-style: normal;
                    font-variant: normal;
                    text-transform: uppercase;
                    color: ${color};`;
              
              title.children[0].fontSize = HEIGHT_TEXT_CONTAINER / 5  + 'px';
              description.children[0].fontSize = HEIGHT_TEXT_CONTAINER / 3  + 'px';
              
              title.children[0].innerHTML = titleText;
              description.children[0].innerHTML = descriptionText;
              
              title.height = HEIGHT_TEXT_CONTAINER / 14;
              description.height = HEIGHT_TEXT_CONTAINER / 2;
              
              let compPropsTitle = getComputedStyle(title);
              let compPropsDescription = getComputedStyle(description);
              
              title.style.left = innerWidth - WIDTH_TEXT_CONTAINER + (WIDTH_TEXT_CONTAINER - title.width) / 2 + 'px';
              description.style.left =  innerWidth - WIDTH_TEXT_CONTAINER + (WIDTH_TEXT_CONTAINER - description.width) / 2 + 'px';
            
              title.style.top = (innerHeight - HEIGHT_TEXT_CONTAINER + innerHeight * 0.03) + 'px';
              description.style.top = parseInt(title.style.top) + title.height + innerHeight * 0.01 + 'px';
              
            };
            
            const DEF_TITLE = "Wipe the walls in search of treasures!";
            const DEF_DESCRIPTION = "Explore the walls of the Egyptian borders, find out the afterlife cult of this people and also find and collect sculptures of deceased pharaohs. Each such sculpture is unique, finding it first you will become the only owner of it!";
            setText(DEF_TITLE, DEF_DESCRIPTION);
            
            
            
            
            
            
            
            
            
            // ### REWARD VIEW
            const showReward = async (blobImageData, nameItem) =>
            {
                
                
                // img congratulation
                let HTMLImage = document.createElement('img');
                document.body.append(HTMLImage);
                
                HTMLImage.src = URL.createObjectURL(blobImageData);
                    
                    let lock = true;
                    HTMLImage.onload = function()
                    {
                        lock = false;
                    };
                    
                    await new Promise(r =>
                    {
                        
                        (function check()
                        {
                            !lock && !r() || setTimeout(check, 20);
                        })();
                        
                    });
                    
                HTMLImage.style.position = 'absolute';
                HTMLImage.style.zIndex = 100;
                HTMLImage.height = HTMLImage.width = innerHeight * 0.5;
                HTMLImage.style.left = innerWidth / 2 - HTMLImage.width / 2 + 'px';
                HTMLImage.style.top = innerHeight * 0.2;
                HTMLImage.id = "imgRew";
                    
                
                
                // text
                let textEl = document.createElement('div');
                document.body.append(textEl);
                
                textEl.id = "textEl";
                
                textEl.style.cssText = `
                    font-family: "Lucida Console", Monaco, monospace;
                    letter-spacing: 0px;
                    word-spacing: -2px;
                    color: #000000;
                    text-decoration: none;
                    font-style: normal;
                    font-variant: normal;
                    text-transform: uppercase;
                    align: center;`;
                textEl.style.position = 'absolute';
                textEl.style.color = 'white';
                textEl.style.zIndex = 100;
                textEl.style.top = innerHeight * 0.65 + 'px';
                textEl.innerHTML = `<center>Congratulations! You have found one of the Pharaoh sculptures(${nameItem})! Now it is only yours! 
                <br><br>
                Click to continue..</center>`;
                textEl.style.fontSize = innerHeight * 0.02 + 'px';
                textEl.style.left = innerWidth / 2 - parseInt(getComputedStyle(textEl).width) / 2 + 'px';
                
                
                
                
                
                // show content
                    
                
                rewardBack.style.width = innerWidth + 'px';
                rewardBack.style.height = innerHeight + 'px';
                
            };
            
            rewardBack.onclick = () =>
            {
                
                document.getElementById('imgRew')?.remove();
                document.getElementById('textEl')?.remove();
                
                rewardBack.style.width = '0px';
                rewardBack.style.height = '0px';
            };
            // showReward();
            
            
            
            
            
            
            
            
            
            
            
            
            // ### OTHER
            
            function randInt(min, max) { // min and max included
                return Math.floor(Math.random() * (max - min + 1) + min)
            }
            
            
   })();
        </script>
    </body>
</html>
'''
'''--- mintingNFT.sh ---
#!/bin/bash
for ((i=0; i < 4900; i++))
do

a='{"token_id": "'
b='00", "token_owner_id": "'$ID'", "token_metadata": { "title": "Exploring Egyptian Tombs!", "description": "js13kb - Sculptures of Pharaohs", "media": "https://bafybeihql5tj2fzwwbpgwccq54jucgtauk762wlrx6i2orxf7i3ygmug6y.ipfs.nftstorage.link/image'
c='.png", "copies": 1}}'
d="${a}${i}${b}${i}${c}"

near call $ID nft_mint "${d}" --accountId $ID --deposit 10
done

'''
'''--- nft/Cargo.toml ---
[package]
name = "non-fungible-token"
version = "1.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
'''
'''--- nft/src/lib.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_ICON: &str = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYAgMAAACdGdVrAAAADFBMVEX///8AAADXrQD/zQS4oSwKAAAAAXRSTlMAQObYZgAAAGpJREFUeAFjwA9YQ8FU1P4AIMm4+v8XIMW2//9fICUZGwuismv//ndgYFxfX/sdSG2vv3sfSO2tja0HUv///wVRf2tj7wGp7/V3v4EE62OBFEN9/d2fQO21sbEvgZT4/19LQDaEhgZgdwgAzIIqdaTqFjkAAAAASUVORK5CYII=";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Need to Find the Pharaohs - js13k Games 2022".to_string(),
                symbol: "NFTPHARAONS".to_string(),
                icon: Some(DATA_IMAGE_SVG_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: ValidAccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    /// Mint a new token with ID=`token_id` belonging to `token_owner_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint( &mut self, token_id: TokenId, token_owner_id: ValidAccountId, token_metadata: TokenMetadata) -> Token {
        self.tokens.mint(token_id, token_owner_id, Some(token_metadata))
    }

    pub fn test_get_account_tokens(& self) -> Vec<Token> {
        self.tokens.nft_tokens(std::option::Option::default(), std::option::Option::default())
    }

    pub fn nft_transfer_free(
        &mut self,
        receiver_id: ValidAccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        self.tokens.internal_transfer(&self.tokens.owner_id.clone(), receiver_id.as_ref(), &token_id, approval_id, memo);
    }

    pub fn get_token(self, token_id: TokenId) -> Option<Token> {
        return self.tokens.nft_token(token_id)
    }

    // near call $ID get_total_tokens --accountId $ID
    // Note the token account has 19 additional (Gen1, not R1) tokens
    pub fn get_total_tokens(self) -> U128 {
        self.tokens.nft_total_supply()
    }

    #[payable]
    pub fn nft_reassign_ownership(&mut self, token_id: TokenId, new_token_owner_id: ValidAccountId) -> String {
        match self.tokens.owner_by_id.get(&token_id) {
            Some(owner_id) => {
                if owner_id == "js13game-vadimsab.testnet" {
                    self.nft_transfer_free(new_token_owner_id, token_id, Some(0001), Some("Congrats on finding and claiming this Pharaoh!!".to_owned()));

                    return "Success: token was transferred to new owner.".to_owned()
                }
                else {
                    return "Failure: token has already been claimed.".to_owned()
                }
            }
            None => {
                return "Failure: could not find the requested token.".to_owned()
            }
        }
    }

    // Deploy/Test
    // ./build.sh
    // near deploy --wasmFile res/non_fungible_token.wasm --accountId $ID
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id, accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id, accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}

'''