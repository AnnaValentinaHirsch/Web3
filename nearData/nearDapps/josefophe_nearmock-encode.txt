*GitHub Repository "josefophe/nearmock-encode"*

'''--- README.md ---

## Inspiration

I have been in the education space for some years and I see the need for genuine community sharing between tutors and students for positive changes students performance using technology.  This has been my personal project for some time now how tutors can share knowledge and earn token when student access their assessments within the Near Protocol ecosystem.

## What it does. 

iMock is an decentralized app solution aimed to improve secondary school students(as a first case study), an Educational platform that enables learning at an easy pace, cost-effective and community based solution, providing seamless access to curated education assessment for students based on their curriculum. iMock is transparent in services and payment between authors/tutors and learners/students. User interface friendly, and on the blockchain (Near protocol).
    
    -  A tutor login with their near account and post their questions making a contract call and paying initial deposit of some near token(which covers gas fee and iMock storage fee)
    
    -  Students login with their near accounts, pay a token which in turns go back to the tutor (owner of the contract) they can practice the questions based on what they've learnt during the week at the end of each week making them conversant of what they learnt.

## How I built it

The contract was written in assembly script while the front was built with Typescript, chakra ui and firebase.  

## Challenges I ran into

I had a learning challenge working with server side database storage with smart contracts or web3 as I cannot write to the database without a user token from firebase to authenticate the user writing to the database. This remain a big challenge for me storing data with a near account login model. I am yet to resolve this. 

## Accomplishments that I am proud of

I was able to set up a login with near feature and authentication and smart contracts on assembly script. 

## What I learned

Building with near protocol is quite an interesting journey as there is a lot to learn about web3 technology and how it works. With near I was able to full understand deployment and web3 accounts.

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");

'''
'''--- asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "assembly/main.ts",
  "options": {
    "binaryFile": "out/main.wasm"
  }
} 

'''
'''--- contract/README.md ---
# `near-sdk-as` Starter Kit

This is a good project to use as a starting point for your AssemblyScript project.

## Samples

This repository includes a complete project structure for AssemblyScript contracts targeting the NEAR platform.

The example here is very basic.  It's a simple contract demonstrating the following concepts:
- a single contract
- the difference between `view` vs. `change` methods
- basic contract storage

There are 2 AssemblyScript contracts in this project, each in their own folder:

- **simple** in the `src/simple` folder
- **singleton** in the `src/singleton` folder

### Simple

We say that an AssemblyScript contract is written in the "simple style" when the `index.ts` file (the contract entry point) includes a series of exported functions.

In this case, all exported functions become public contract methods.

```ts
// return the string 'hello world'
export function helloWorld(): string {}

// read the given key from account (contract) storage
export function read(key: string): string {}

// write the given value at the given key to account (contract) storage
export function write(key: string, value: string): string {}

// private helper method used by read() and write() above
private storageReport(): string {}
```

### Singleton

We say that an AssemblyScript contract is written in the "singleton style" when the `index.ts` file (the contract entry point) has a single exported class (the name of the class doesn't matter) that is decorated with `@nearBindgen`.

In this case, all methods on the class become public contract methods unless marked `private`.  Also, all instance variables are stored as a serialized instance of the class under a special storage key named `STATE`.  AssemblyScript uses JSON for storage serialization (as opposed to Rust contracts which use a custom binary serialization format called borsh).

```ts
@nearBindgen
export class Contract {

  // return the string 'hello world'
  helloWorld(): string {}

  // read the given key from account (contract) storage
  read(key: string): string {}

  // write the given value at the given key to account (contract) storage
  @mutateState()
  write(key: string, value: string): string {}

  // private helper method used by read() and write() above
  private storageReport(): string {}
}
```

## Usage

### Getting started

(see below for video recordings of each of the following steps)

INSTALL `NEAR CLI` first like this: `npm i -g near-cli`

1. clone this repo to a local folder
2. run `yarn`
3. run `./scripts/1.dev-deploy.sh`
3. run `./scripts/2.use-contract.sh`
4. run `./scripts/2.use-contract.sh` (yes, run it to see changes)
5. run `./scripts/3.cleanup.sh`

### Videos

**`1.dev-deploy.sh`**

This video shows the build and deployment of the contract.

[![asciicast](https://asciinema.org/a/409575.svg)](https://asciinema.org/a/409575)

**`2.use-contract.sh`**

This video shows contract methods being called.  You should run the script twice to see the effect it has on contract state.

[![asciicast](https://asciinema.org/a/409577.svg)](https://asciinema.org/a/409577)

**`3.cleanup.sh`**

This video shows the cleanup script running.  Make sure you add the `BENEFICIARY` environment variable. The script will remind you if you forget.

```sh
export BENEFICIARY=<your-account-here>   # this account receives contract account balance
```

[![asciicast](https://asciinema.org/a/409580.svg)](https://asciinema.org/a/409580)

### Other documentation

- See `./scripts/README.md` for documentation about the scripts
- Watch this video where Willem Wyndham walks us through refactoring a simple example of a NEAR smart contract written in AssemblyScript

  https://youtu.be/QP7aveSqRPo

  ```
  There are 2 "styles" of implementing AssemblyScript NEAR contracts:
  - the contract interface can either be a collection of exported functions
  - or the contract interface can be the methods of a an exported class

  We call the second style "Singleton" because there is only one instance of the class which is serialized to the blockchain storage.  Rust contracts written for NEAR do this by default with the contract struct.

   0:00 noise (to cut)
   0:10 Welcome
   0:59 Create project starting with "npm init"
   2:20 Customize the project for AssemblyScript development
   9:25 Import the Counter example and get unit tests passing
  18:30 Adapt the Counter example to a Singleton style contract
  21:49 Refactoring unit tests to access the new methods
  24:45 Review and summary
  ```

## The file system

```sh
├── README.md                          # this file
├── as-pect.config.js                  # configuration for as-pect (AssemblyScript unit testing)
├── asconfig.json                      # configuration for AssemblyScript compiler (supports multiple contracts)
├── package.json                       # NodeJS project manifest
├── scripts
│   ├── 1.dev-deploy.sh                # helper: build and deploy contracts
│   ├── 2.use-contract.sh              # helper: call methods on ContractPromise
│   ├── 3.cleanup.sh                   # helper: delete build and deploy artifacts
│   └── README.md                      # documentation for helper scripts
├── src
│   ├── as_types.d.ts                  # AssemblyScript headers for type hints
│   ├── simple                         # Contract 1: "Simple example"
│   │   ├── __tests__
│   │   │   ├── as-pect.d.ts           # as-pect unit testing headers for type hints
│   │   │   └── index.unit.spec.ts     # unit tests for contract 1
│   │   ├── asconfig.json              # configuration for AssemblyScript compiler (one per contract)
│   │   └── assembly
│   │       └── index.ts               # contract code for contract 1
│   ├── singleton                      # Contract 2: "Singleton-style example"
│   │   ├── __tests__
│   │   │   ├── as-pect.d.ts           # as-pect unit testing headers for type hints
│   │   │   └── index.unit.spec.ts     # unit tests for contract 2
│   │   ├── asconfig.json              # configuration for AssemblyScript compiler (one per contract)
│   │   └── assembly
│   │       └── index.ts               # contract code for contract 2
│   ├── tsconfig.json                  # Typescript configuration
│   └── utils.ts                       # common contract utility functions
└── yarn.lock                          # project manifest version lock
```

You may clone this repo to get started OR create everything from scratch.

Please note that, in order to create the AssemblyScript and tests folder structure, you may use the command `asp --init` which will create the following folders and files:

```
./assembly/
./assembly/tests/
./assembly/tests/example.spec.ts
./assembly/tests/as-pect.d.ts
```

'''
'''--- contract/as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- contract/asconfig.json ---
{
  "workspaces": [
    "src/simple",
    "src/singleton"
  ]
}

'''
'''--- contract/package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  },
  "dependencies": {
    "near-bindgen-as": "^1.2.3"
  }
}

'''
'''--- contract/scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

# uncomment out the line below to deploy the other example contract
# near dev-deploy ./build/debug/simple.wasm

# comment the line below to deploy the other example contract
# near dev-deploy ./build/debug/singleton.wasm
# near dev-deploy ./build/debug/nearmock.wasm
near deploy ./build/debug/main.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
# uncomment this line for a useful hint when using the singleton style
# echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- contract/scripts/2.use-contract.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Call 'view' functions on the contract"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

near view $CONTRACT getListQuestion

# near view $CONTRACT getAuthorByQuestion(_id: 4)

# near view $CONTRACT getListQuestion

echo
echo

# near view $CONTRACT read '{"key":"some-key"}'

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Call 'change' functions on the contract"
echo ---------------------------------------------------------
echo

# the following line fails with an error because we can't write to storage without signing the message
# --> FunctionCallError(HostError(ProhibitedInView { method_name: "storage_write" }))
# near view $CONTRACT write '{"key": "some-key", "value":"some value"}'
# near call $CONTRACT write '{"key": "some-key", "value":"some value"}' --accountId $CONTRACT

echo
echo "now run this script again to see changes made by this file"
exit 0

'''
'''--- contract/scripts/3.cleanup.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Delete $CONTRACT, setting $BENEFICIARY as beneficiary"
echo ---------------------------------------------------------
echo
near delete $CONTRACT $BENEFICIARY

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
yarn clean

exit 0

'''
'''--- contract/scripts/README.md ---
## Setting up your terminal

The scripts in this folder are designed to help you demonstrate the behavior of the contract(s) in this project.

It uses the following setup:

```sh
# set your terminal up to have 2 windows, A and B like this:
┌─────────────────────────────────┬─────────────────────────────────┐
│                                 │                                 │
│                                 │                                 │
│                A                │                B                │
│                                 │                                 │
│                                 │                                 │
└─────────────────────────────────┴─────────────────────────────────┘
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  ```

- Commands

  _helper scripts_
  ```sh
  1.dev-deploy.sh                # helper: build and deploy contracts
  2.use-contract.sh              # helper: call methods on ContractPromise
  3.cleanup.sh                   # helper: delete build and deploy artifacts
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=               # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```
---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linuo-watch-command#191068)

'''
'''--- contract/src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- contract/src/nearmock/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- contract/src/nearmock/assembly/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- contract/src/nearmock/assembly/index.ts ---
/*
 * This is an example of an AssemblyScript smart contract with two simple,
 * symmetric functions:
 *
 * 1. setGreeting: accepts a greeting, such as "howdy", and records it for the
 *    user (account_id) who sent the request
 * 2. getGreeting: accepts an account_id and returns the greeting saved for it,
 *    defaulting to "Hello"
 *
 * Learn more about writing NEAR smart contracts with AssemblyScript:
 * https://docs.near.org/docs/develop/contracts/as/intro
 *
 */

import { Context, logging,context, u128, PersistentVector, ContractPromiseBatch, PersistentMap  } from 'near-sdk-as'

import { Questions} from './model';

/****************
 *   STORAGE    *
 ****************/
const QuestionVector = new PersistentVector<Questions>('QuestionVector');
const WinnerListMap = new PersistentMap<u32,Array<string>>('wlm');
const DEFAULT_REWARD: u128 = u128.from("1000000000000000000000000"); // 1 NEAR
/**
 * Adds a new question under the name of the sender's account id.\
 */
 export function addQuestionTitle(
  _questionTitle: string,
  _questionDesp: string,
  _question: string,
  _option1: string,
  _option2: string,
  _option3: string,
  _option4: string,
  _answer: i32
): void {
  let id = QuestionVector.length + 1;
  const questionTitle = new Questions(id,context.sender,_questionTitle, _questionDesp, _question, _answer,_option1, _option2, _option3, _option4,DEFAULT_REWARD);
  QuestionVector.push(questionTitle);
  logging.log("add question" + questionTitle.getQuestion());
}
/**
 * get list question
 */
export function getListQuestion(): Array<Questions> {
  const result = new Array<Questions>(QuestionVector.length);
  for (let i = 0; i < QuestionVector.length; i++) {
        result[i] = QuestionVector[i];
    }
    return result;
}

export function getAuthorByQuestion(_id: u32): string {
  return QuestionVector[_id-1].owner;
}

export function getAnswer(_id: u32): i32 {
  return QuestionVector[_id-1].answer
}

/**
 * answer the question
 */
export function answerQuestion(_quest_id: u32, _option: i32): boolean {

  let author = getAuthorByQuestion(_quest_id);
  assert(context.sender != author, "You cannot play because you are the author of the question");
  let answer = getAnswer(_quest_id);
  if (_option == answer) {
    return true;
  }
  else {
    return false;
  }
}
'''
'''--- contract/src/nearmock/assembly/model.ts ---
import { context, u128} from "near-sdk-as";
@nearBindgen
export class Questions {
  id: i32;
  owner: string;
  questionTitle: string;
  questionDesp: string;
  question: string;
  answer: i32;
  option1: string;
  option2: string;
  option3: string;
  option4: string;
  questionfee: u128;

  constructor(
    _id: i32,
    _owner: string,
    _questionTitle: string,
    _questionDesp: string,
    _question: string,
    _answer: i32,
    _option1: string,
    _option2: string,
    _option3: string,
    _option4: string,
    _questionfee: u128
  ) {
    this.id = _id;
    this.owner = _owner;
    this.questionTitle = _questionTitle;
    this.questionDesp = _questionDesp
    this.question = _question;
    this.answer = _answer;
    this.option1 = _option1;
    this.option2 = _option2;
    this.option3 = _option3;
    this.option4 = _option4;
    this.questionfee = _questionfee;
  }

  public getQuestion(): string {
    return `${this.questionTitle}`
  }

  public getChoiceDetails(): string {
    return `${this.option1}`;
  }

  public getAnswer(): i32{
    return this.answer;
  }
}

'''
'''--- contract/src/nearmock/assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ],
  "compilerOptions": {
 //     "outDir": "./dist" 
 //     "rootDir": "./src" 
      /* Experimental Options */
      "experimentalDecorators": true, 
      "emitDecoratorMetadata": true, 
      /* Advanced Options */
      "forceConsistentCasingInFileNames": true 
    }
}

'''
'''--- contract/src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- contract/src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''
'''--- next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/types/global" />

'''
'''--- next.config.js ---
module.exports = {
  crossOrigin: 'anonymous',
}

'''
'''--- package.json ---
{
  "name": "quizapp",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "dev1": "next",
    "build": "next build",
    "start": "next start"
  },
  "dependencies": {
    "@chakra-ui/icons": "^1.0.9",
    "@chakra-ui/react": "^1.4.2",
    "@emotion/react": "^11.1.5",
    "@emotion/styled": "^11.1.5",
    "axios": "^0.21.1",
    "firebase": "^8.3.2",
    "firebase-admin": "^9.6.0",
    "formik": "^2.2.6",
    "framer-motion": "^4.1.2",
    "near-api-js": "^0.44.2",
    "near-sdk-as": "^3.2.3",
    "next": "10.1.3",
    "react": "17.0.2",
    "react-dom": "17.0.2",
    "react-icons": "^4.2.0",
    "yup": "^0.32.9"
  },
  "devDependencies": {
    "@types/node": "^14.14.37",
    "@types/react": "^17.0.3",
    "@types/react-dom": "^17.0.3",
    "typescript": "^4.2.3"
  }
}

'''
'''--- public/vercel.svg ---
<svg width="283" height="64" viewBox="0 0 283 64" fill="none" 
    xmlns="http://www.w3.org/2000/svg">
    <path d="M141.04 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.46 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM248.72 16c-11.04 0-19 7.2-19 18s8.96 18 20 18c6.67 0 12.55-2.64 16.19-7.09l-7.65-4.42c-2.02 2.21-5.09 3.5-8.54 3.5-4.79 0-8.86-2.5-10.37-6.5h28.02c.22-1.12.35-2.28.35-3.5 0-10.79-7.96-17.99-19-17.99zm-9.45 14.5c1.25-3.99 4.67-6.5 9.45-6.5 4.79 0 8.21 2.51 9.45 6.5h-18.9zM200.24 34c0 6 3.92 10 10 10 4.12 0 7.21-1.87 8.8-4.92l7.68 4.43c-3.18 5.3-9.14 8.49-16.48 8.49-11.05 0-19-7.2-19-18s7.96-18 19-18c7.34 0 13.29 3.19 16.48 8.49l-7.68 4.43c-1.59-3.05-4.68-4.92-8.8-4.92-6.07 0-10 4-10 10zm82.48-29v46h-9V5h9zM36.95 0L73.9 64H0L36.95 0zm92.38 5l-27.71 48L73.91 5H84.3l17.32 30 17.32-30h10.39zm58.91 12v9.69c-1-.29-2.06-.49-3.2-.49-5.81 0-10 4-10 10V51h-9V17h9v9.2c0-5.08 5.91-9.2 13.2-9.2z" fill="#000"/>
</svg>
'''
'''--- src/config/near.config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME //|| 'josefophe.testnet'

function getConfig(env) {
    switch (env) {

        case 'production':
        case 'mainnet':
            return {
                networkId: 'mainnet',
                nodeUrl: 'https://rpc.mainnet.near.org',
                contractName: CONTRACT_NAME,
                walletUrl: 'https://wallet.near.org',
                helperUrl: 'https://helper.mainnet.near.org',
                explorerUrl: 'https://explorer.mainnet.near.org',
            }
        case 'development':
        case 'testnet':
            return {
                networkId: 'testnet',
                nodeUrl: 'https://rpc.testnet.near.org',
                contractName: CONTRACT_NAME,
                walletUrl: 'https://wallet.testnet.near.org',
                helperUrl: 'https://helper.testnet.near.org',
                explorerUrl: 'https://explorer.testnet.near.org',
            }
        case 'betanet':
            return {
                networkId: 'betanet',
                nodeUrl: 'https://rpc.betanet.near.org',
                contractName: CONTRACT_NAME,
                walletUrl: 'https://wallet.betanet.near.org',
                helperUrl: 'https://helper.betanet.near.org',
                explorerUrl: 'https://explorer.betanet.near.org',
            }
        case 'local':
            return {
                networkId: 'local',
                nodeUrl: 'http://localhost:3030',
                keyPath: `${process.env.HOME}/.near/validator_key.json`,
                walletUrl: 'http://localhost:4000/wallet',
                contractName: CONTRACT_NAME,
            }
        case 'test':
        case 'ci':
            return {
                networkId: 'shared-test',
                nodeUrl: 'https://rpc.ci-testnet.near.org',
                contractName: CONTRACT_NAME,
                masterAccount: 'test.near',
            }
        case 'ci-betanet':
            return {
                networkId: 'shared-test-staging',
                nodeUrl: 'https://rpc.ci-betanet.near.org',
                contractName: CONTRACT_NAME,
                masterAccount: 'test.near',
            }
        default:
            throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
    }
}

export default getConfig;

'''
'''--- src/lib/auth-near.js ---
import { Context, createContext, useContext, useEffect, useState } from 'react';
// Add this for near login auth
import { connect, Contract, keyStores, WalletConnection } from "near-api-js";
import getConfig from "../config/near.config";

import { addUser } from '../utils/db';
import firebase from './firebase';
// import { answerQuestion } from '../../contract/src/nearmock/assembly';

// Adding user account
/*
const formatAuthState = (user: firebase.User): isAuth => ({
  uid: user.uid,
  setAccountId: accountId
});
*/

//Add near code here

const nearConfig = getConfig("testnet");
const AppContext = createContext({});
export const useAuth = () => useContext(AppContext);

const AuthProvider = ({ children }) => {
  const [isAuth, setIsAuth] = useState(false);
  const [accountId, setAccountId] = useState(null);
  const [account, setAccount] = useState(null);
  const [mainContract, setMainContract] = useState(null);
  const [walletConnection, setWalletConnection] = useState(null);
  const [addQuestionTitle, setaddQuestionTitle] = useState(null);
  const [triedEager, setTriedEager] = useState(false);

  
  const initNear = async () => {
    const near = await connect(
      Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, nearConfig)
    );
    const walletConnection = new WalletConnection(near);
    const account = walletConnection.account();
    const contract = await new Contract(account, nearConfig.contractName, {
      viewMethods: ["get_contracts_by_owner", "get_question_contracts"],
      changeMethods: ["create_new_question_contract"],
    });

    return {
      walletConnection,
      accountId: walletConnection.getAccountId(),
      contract,
      account,
    };
  };

  const getContractQuestion = async () => {
    if (mainContract && accountId) {
      const Question = await mainContract.get_contracts_by_owner({
        owner_id: accountId,
      });
      if (Question.length > 0) {
        const _contract = await connectContract(Question[0]);
        return _contract;
      }
    }
  };

  const connectContract = async (contractName) => {
    console.log("Connecting to contract:", contractName);
    const near = await connect(
      Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, nearConfig)
    );
    const walletConnection = new WalletConnection(near);
    const account = walletConnection.account();

    const contract = await new Contract(account, contractName, {
      viewMethods: [
        "getListQuestion",
        "getAuthorByQuestion",
        "getAnswer",
        "answerQuestion"
      ],
      changeMethods: ["addQuestionTitle"],
    });

    return contract;
  };

/*

  const handleAuthChange = async (authState: firebase.User | null) => {
    if (!authState) {
      triedEager(false);
      return;
    }
    const formattedAuth = formatAuthState(authState);
    setAuth(formattedAuth);
    triedEager(false);
  };
*/

  const login = (contractName) => {
    if (!walletConnection) {
      return;
    }
    walletConnection.requestSignIn(contractName ?? nearConfig.contractName, "iMock App");
    // walletConnection.requestSignIn({
    //   contractId: nearConfig.contractName,
    //   successUrl: `${process.env.domain}/user-dashboard`,
    //   failureUrl: process.env.domain,
    // });
    // Added this features
    // const authUser = formatAuthState(response.user);
    // await addUser({ ...authUser, provider });
  };

  const logout = () => {
    walletConnection.signOut();
    window.location.replace("/");
  };

  useEffect(() => {
    if (typeof window !== "undefined") {
      initNear()
        .then(({ walletConnection, accountId, contract, account }) => {
          setWalletConnection(walletConnection);
          setMainContract(contract);
          if (walletConnection.isSignedIn()) {
            setIsAuth(true);
            setAccountId(accountId);
            setAccount(account);
          }
        })
        .finally(() => {
          setTriedEager(true);
        });
    }
  }, []);

  return (
    <AppContext.Provider
      value={{
        networkId: nearConfig.networkId,
        isAuth,
        login,
        logout,
        accountId,
        mainContract,
        account,
        connectContract,
        walletConnection,
        addQuestionTitle,
        getContractQuestion,
        triedEager,
      }}
    >
      {children}
    </AppContext.Provider>
  );
};

export default AuthProvider;

'''
'''--- src/lib/firebase-admin.ts ---
import admin from 'firebase-admin';
import { useAuth } from './auth-near';

if (!admin.apps.length) {
  admin.initializeApp({
    credential: admin.credential.cert({
      projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
      privateKey: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, '\n'),
      clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
    }),
    databaseURL: process.env.FIREBASE_DATABASE_URL,
  });
}

const db = admin.firestore();
const isAuth = useAuth();

export { db, isAuth };

'''
'''--- src/lib/firebase.ts ---
import firebase from 'firebase/app';
import 'firebase/firestore';
// import 'firebase/auth';

const firebaseConfig = {
  apiKey: process.env.NEXT_PUBLIC_FIREBASE_API_KEY,
  authDomain: process.env.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.NEXT_PUBLIC_FIREBASE_PROJECT_ID,
};

try {
  firebase.initializeApp(firebaseConfig);
} catch (err) {
  if (!/already exists/.test(err.message)) {
    console.error('Firebase initialization error', err.stack);
  }
}

export default firebase;

'''
'''--- src/pages/api/quiz/[id]/answer.ts ---
import { NextApiRequest, NextApiResponse } from 'next';
import { isAuth } from '../../../../lib/firebase-admin';
import { addAnswer as addAnswerFb } from '../../../../utils/db';

export default async (req: NextApiRequest, res: NextApiResponse) => {
  switch (req.method) {
    case 'POST':
      await addAnswer(req, res);
      break;
    default:
      res.status(405).json({ status: false, message: 'Method Not found' });
      break;
  }
};

const addAnswer = async (req: NextApiRequest, res: NextApiResponse) => {
  try {
    const user = await isAuth.verifyIdToken(req.headers.token as string);
    const data = {
      ...req.body,
      quizId: req.query.id,
      userId: user.uid,
    };
    const response = await addAnswerFb(data);
    return res
      .status(200)
      .json({ status: true, data: { answerId: response.id } });
  } catch (error) {
    return res
      .status(500)
      .json({ status: false, message: 'Something went wrong' });
  }
};

'''
'''--- src/pages/api/quiz/index.ts ---
import { NextApiRequest, NextApiResponse } from 'next';
import { isAuth } from '../../../lib/firebase-admin';
import { addQuiz as addQuizFb } from '../../../utils/db';

export default async (req: NextApiRequest, res: NextApiResponse) => {
  switch (req.method) {
    case 'POST':
      await addQuiz(req, res);
      break;
    default:
      res.status(405).json({ status: false, message: 'Method Not found' });
      break;
  }
};

const addQuiz = async (req: NextApiRequest, res: NextApiResponse) => {
  try {
    const user = await isAuth.verifyIdToken(req.headers.token as string);
    const quizData = { ...req.body, userId: user.uid };
    await addQuizFb(quizData);
    return res
      .status(200)
      .json({ status: true, message: 'Quiz added successfully...' });
  } catch (error) {
    return res
      .status(500)
      .json({ status: false, message: 'Something went wrong' });
  }
};

'''
'''--- src/utils/db.ts ---
import firebase from '../lib/firebase';

export const addUser = async (isAuthUser: any) => {
  const resp = await firebase
    .firestore()
    .collection('users')
    .doc(isAuthUser.uid as string)
    .set({ ...isAuthUser }, { merge: true });
  return resp;
};

export const addQuiz = async (quizData) => {
  let response = await firebase.firestore().collection('quiz').add(quizData);
  return response;
};

export const getAllQuiz = async () => {
  const snapshot = await firebase.firestore().collection('quiz').get();
  const quiz = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
  return quiz;
};

export const getAllUsers = async () => {
  const snapshot = await firebase.firestore().collection('users').get();
  const users = snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() }));
  return users;
}

export const getSingleQuiz = async (quizId) => {
  const snapshot = await firebase
    .firestore()
    .collection('quiz')
    .doc(String(quizId))
    .get();
  const quizData = snapshot.exists ? JSON.stringify(snapshot.data()) : null;
  return quizData;
};

export const addAnswer = async (data) => {
  const response = await firebase.firestore().collection('answer').add(data);
  return response;
};

export const getAnswer = async (answerId) => {
  const answerSnapshot = await firebase
    .firestore()
    .collection('answer')
    .doc(String(answerId))
    .get();
  let answerData = answerSnapshot.exists
    ? JSON.stringify(answerSnapshot.data())
    : null;
  return answerData;
};

'''
'''--- src/utils/service.ts ---
import axios from 'axios';
import { isAuth } from '../lib/firebase-admin';

export const addQuizApi = async (isAuth, values) => {
  try {
    const header = {
      'Content-Type': 'application/json',
      token: isAuth.token,
    };
    const resp = await axios.post('/api/quiz', values, { headers: header });
    return resp;
  } catch (error) {
    throw error;
  }
};

export const addAnswerApi = async (isAuth, quizId, values) => {
  try {
    const header = {
      'Content-Type': 'application/json',
      token: isAuth.token,
    };
    const resp = await axios.post(
      `/api/quiz/${quizId}/answer`,
      {
        questions: values,
        createdAt: new Date(),
        updatedAt: new Date(),
      },
      { headers: header }
    );
    return resp;
  } catch (error) {
    throw error;
  }
};

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": [
      "dom",
      "dom.iterable",
      "esnext"
    ],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": false,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve"
  },
  "include": [
    "next-env.d.ts",
    "**/*.ts",
    "**/*.tsx"
  ],
  "exclude": [
    "node_modules"
  ]
}

'''