*GitHub Repository "phoenixpulsar/vehicle-history-smart-contract"*

'''--- README.md ---
# `near-sdk-as` Starter Kit

This is a good project to use as a starting point for your AssemblyScript project.

## Samples

This repository includes a complete project structure for AssemblyScript contracts targeting the NEAR platform.

The example here is very basic.  It's a simple contract demonstrating the following concepts:
- a single contract
- the difference between `view` vs. `change` methods
- basic contract storage

There are 2 AssemblyScript contracts in this project, each in their own folder:

- **singleton** in the `src/singleton` folder
### Singleton

We say that an AssemblyScript contract is written in the "singleton style" when the `index.ts` file (the contract entry point) has a single exported class (the name of the class doesn't matter) that is decorated with `@nearBindgen`.

In this case, all methods on the class become public contract methods unless marked `private`.  Also, all instance variables are stored as a serialized instance of the class under a special storage key named `STATE`.  AssemblyScript uses JSON for storage serialization (as opposed to Rust contracts which use a custom binary serialization format called borsh).

```ts
@nearBindgen
export class Contract {

  // return the string 'hello world'
  helloWorld(): string {}

  // read the given key from account (contract) storage
  read(key: string): string {}

  // write the given value at the given key to account (contract) storage
  @mutateState()
  write(key: string, value: string): string {}

  // private helper method used by read() and write() above
  private storageReport(): string {}
}
```

## Usage

### Getting started

(see below for video recordings of each of the following steps)

INSTALL `NEAR CLI` first like this: `npm i -g near-cli`

1. clone this repo to a local folder
2. run `yarn`
3. run `./scripts/1.dev-deploy.sh`
3. run `./scripts/2.use-contract.sh`
4. run `./scripts/2.use-contract.sh` (yes, run it to see changes)
5. run `./scripts/3.cleanup.sh`

### Videos

**`1.dev-deploy.sh`**

This video shows the build and deployment of the contract.

[![asciicast](https://asciinema.org/a/409575.svg)](https://asciinema.org/a/409575)

**`2.use-contract.sh`**

This video shows contract methods being called.  You should run the script twice to see the effect it has on contract state.

[![asciicast](https://asciinema.org/a/409577.svg)](https://asciinema.org/a/409577)

**`3.cleanup.sh`**

This video shows the cleanup script running.  Make sure you add the `BENEFICIARY` environment variable. The script will remind you if you forget.

```sh
export BENEFICIARY=<your-account-here>   # this account receives contract account balance
```

[![asciicast](https://asciinema.org/a/409580.svg)](https://asciinema.org/a/409580)

### Other documentation

- See `./scripts/README.md` for documentation about the scripts
- Watch this video where Willem Wyndham walks us through refactoring a simple example of a NEAR smart contract written in AssemblyScript

  https://youtu.be/QP7aveSqRPo

  ```
  There are 2 "styles" of implementing AssemblyScript NEAR contracts:
  - the contract interface can either be a collection of exported functions
  - or the contract interface can be the methods of a an exported class

  We call the second style "Singleton" because there is only one instance of the class which is serialized to the blockchain storage.  Rust contracts written for NEAR do this by default with the contract struct.

   0:00 noise (to cut)
   0:10 Welcome
   0:59 Create project starting with "npm init"
   2:20 Customize the project for AssemblyScript development
   9:25 Import the Counter example and get unit tests passing
  18:30 Adapt the Counter example to a Singleton style contract
  21:49 Refactoring unit tests to access the new methods
  24:45 Review and summary
  ```

## The file system

```sh
├── README.md                          # this file
├── as-pect.config.js                  # configuration for as-pect (AssemblyScript unit testing)
├── asconfig.json                      # configuration for AssemblyScript compiler (supports multiple contracts)
├── package.json                       # NodeJS project manifest
├── scripts
│   ├── 1.dev-deploy.sh                # helper: build and deploy contracts
│   ├── 2.use-contract.sh              # helper: call methods on ContractPromise
│   ├── 3.cleanup.sh                   # helper: delete build and deploy artifacts
│   └── README.md                      # documentation for helper scripts
├── src
│   ├── as_types.d.ts                  # AssemblyScript headers for type hints
│   ├── singleton                      # Contract 2: "Singleton-style example"
│   │   ├── __tests__
│   │   │   ├── as-pect.d.ts           # as-pect unit testing headers for type hints
│   │   │   └── index.unit.spec.ts     # unit tests for contract 2
│   │   ├── asconfig.json              # configuration for AssemblyScript compiler (one per contract)
│   │   └── assembly
│   │       └── index.ts               # contract code for contract 2
│   ├── tsconfig.json                  # Typescript configuration
│   └── utils.ts                       # common contract utility functions
└── yarn.lock                          # project manifest version lock
```

You may clone this repo to get started OR create everything from scratch.

Please note that, in order to create the AssemblyScript and tests folder structure, you may use the command `asp --init` which will create the following folders and files:

```
./assembly/
./assembly/tests/
./assembly/tests/example.spec.ts
./assembly/tests/as-pect.d.ts
```

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/singleton",
    "src/vehicleGarage"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--near-sdk-as",
  "version": "0.0.1",
  "description": "Start with a basic project",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build:release

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo "(edit scripts/1.dev-deploy.sh to deploy other contract)"
echo ---------------------------------------------------------
echo

# near dev-deploy ./build/release/singleton.wasm

near dev-deploy ./build/release/vehicleGarage.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
# uncomment this line for a useful hint when using the singleton style
echo "near call \$CONTRACT init --accountId \$CONTRACT"
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/2.use-contract.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variable with contract name"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

# ------------------------------------
# Add Vehicle 
# ------------------------------------

# Uncomment lines below and run script to add Vehicle to Contract
# Signer can be any valid account, we can use OWNER or the same account CONTRACT

# echo ---------------------------------------------------------
# echo " Calling addVehicle Method"
# echo ---------------------------------------------------------
# near call $CONTRACT addVehicle '{"year":"2013",  "make": "Mini", "model": "Cooper S",  "owner": "phoenixpulsar.testnet", "dateAcquired": "Feb 01, 2015", "vehicleNotes": "Used"}' --accountId $OWNER
# near call $CONTRACT addVehicle '{"year":"2020",  "make": "Porsche", "model": "911",  "owner": "phoenixpulsar.testnet", "dateAcquired": "Mar 01, 2020", "vehicleNotes": "New"}' --accountId $OWNER
# near call $CONTRACT addVehicle '{"year":"2018",  "make": "Ford", "model": "Raptor",  "owner": "phoenixpulsar.testnet", "dateAcquired": "Oct 10, 2019", "vehicleNotes": "Used"}' --accountId $OWNER

# ------------------------------------
# Add Vehicle Service 
# ------------------------------------

# Uncomment lines below and run script to add Service (need vehicle id from above ID)

# echo ---------------------------------------------------------
# echo " Calling addService Method"
# echo ---------------------------------------------------------
# near call $CONTRACT addService '{"vehicleId": "80733686", "serviceDate": "Oct 11 2020",  "serviceNotes": "Serpentine Belt"}' --accountId $CONTRACT
# near call $CONTRACT addService '{"vehicleId": "80733696", "serviceDate": "Feb 11 2020",  "serviceNotes": "Flat Tire"}' --accountId $CONTRACT
# near call $CONTRACT addService '{"vehicleId": "80733703", "serviceDate": "Oct 11 2020",  "serviceNotes": "Change Oil"}' --accountId $CONTRACT
# near call $CONTRACT addService '{"vehicleId": "80733686", "serviceDate": "Nov 1 2015",  "serviceNotes": "Air Filter Change"}' --accountId $CONTRACT
# near call $CONTRACT addService '{"vehicleId": "80733696", "serviceDate": "Mar 1 2018",  "serviceNotes": "Detailed"}' --accountId $CONTRACT
# near call $CONTRACT addService '{"vehicleId": "80733703", "serviceDate": "Dec 1 2019",  "serviceNotes": "Check Engine Light"}' --accountId $CONTRACT
# near call $CONTRACT addService '{"vehicleId": "80733686", "serviceDate": "Sep 5 2015",  "serviceNotes": "Change Oil"}' --accountId $CONTRACT
# near call $CONTRACT addService '{"vehicleId": "80733696", "serviceDate": "Apr 8 2018",  "serviceNotes": "Clean Engine"}' --accountId $CONTRACT
# near call $CONTRACT addService '{"vehicleId": "80733703", "serviceDate": "Jul 21 2019",  "serviceNotes": "Oil Leak"}' --accountId $CONTRACT
echo
echo ---------------------------------------------------------
echo "Goodbye"
echo ---------------------------------------------------------
echo
exit 0

'''
'''--- scripts/3.cleanup.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for required environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$BENEFICIARY" ] && echo "Missing \$BENEFICIARY environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$BENEFICIARY" ] || echo "Found it! \$BENEFICIARY is set to [ $BENEFICIARY ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: Delete $CONTRACT, setting $BENEFICIARY as beneficiary"
echo ---------------------------------------------------------
echo
near delete $CONTRACT $BENEFICIARY

echo
echo ---------------------------------------------------------
echo "Step 2: Clean up project folders"
echo ---------------------------------------------------------
echo
yarn clean

exit 0

'''
'''--- scripts/README.md ---
## Setting up your terminal

The scripts in this folder are designed to help you demonstrate the behavior of the contract(s) in this project.

It uses the following setup:

```sh
# set your terminal up to have 2 windows, A and B like this:
┌─────────────────────────────────┬─────────────────────────────────┐
│                                 │                                 │
│                                 │                                 │
│                A                │                B                │
│                                 │                                 │
│                                 │                                 │
└─────────────────────────────────┴─────────────────────────────────┘
```

### Terminal **A**

*This window is used to compile, deploy and control the contract*
- Environment
  ```sh
  export CONTRACT=        # depends on deployment
  export OWNER=           # any account you control

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  # export OWNER=sherif.testnet
  ```

- Commands

  _helper scripts_
  ```sh
  1.dev-deploy.sh                # helper: build and deploy contracts
  2.use-contract.sh              # helper: call methods on ContractPromise
  3.cleanup.sh                   # helper: delete build and deploy artifacts
  ```

### Terminal **B**

*This window is used to render the contract account storage*
- Environment
  ```sh
  export CONTRACT=               # depends on deployment

  # for example
  # export CONTRACT=dev-1615190770786-2702449
  ```

- Commands
  ```sh
  # monitor contract storage using near-account-utils
  # https://github.com/near-examples/near-account-utils
  watch -d -n 1 yarn storage $CONTRACT
  ```
---

## OS Support

### Linux

- The `watch` command is supported natively on Linux
- To learn more about any of these shell commands take a look at [explainshell.com](https://explainshell.com)

### MacOS

- Consider `brew info visionmedia-watch` (or `brew install watch`)

### Windows

- Consider this article: [What is the Windows analog of the Linux watch command?](https://superuser.com/questions/191063/what-is-the-windows-analog-of-the-linuo-watch-command#191068)

'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/singleton/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/singleton/__tests__/index.unit.spec.ts ---
import { Contract } from "../assembly";

let contract: Contract

beforeEach(() => {
  contract = new Contract()
})

describe("Contract", () => {
  // VIEW method tests

  it("says hello", () => {
    expect(contract.helloWorld()).toStrictEqual("hello world")
  })

  it("reads data", () => {
    expect(contract.read("some key")).toStrictEqual("🚫 Key [ some key ] not found in storage. ( storage [ 0 bytes ] )")
  })

  // CHANGE method tests

  it("saves data to contract storage", () => {
    expect(contract.write("some-key", "some value")).toStrictEqual("✅ Data saved. ( storage [ 18 bytes ] )")
  })
})

'''
'''--- src/singleton/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/singleton/assembly/index.ts ---
import { PersistentMap, storage } from "near-sdk-core";
import { AccountId, idCreator, VehicleId, VehicleServiceId} from "../../utils";
@nearBindgen
class VehicleService {
  public id: VehicleServiceId = idCreator()
  constructor(
    public vehicleId:VehicleId, 
    public serviceDate:string, 
    public serviceNotes:string
    ) {}
}
@nearBindgen
class Vehicle {
  public id: VehicleId = idCreator()
  public serviceIds: Array<VehicleServiceId> = [] 
  
  constructor(
    public year:string,
    public make:string, 
    public model:string, 
    public owner:AccountId,
    public dateAcquired:string,
    public vehicleNotes:string
    ) { }
}

@nearBindgen
export class Contract {
  constructor(
    public vehicles: PersistentMap<VehicleId, Vehicle> = new PersistentMap<VehicleId, Vehicle>("v"),
    public vehicleServiceHistory: PersistentMap<VehicleServiceId, VehicleService> = new PersistentMap<VehicleServiceId, VehicleService>("vs"),
  ) {}

  @mutateState()
  addVehicle(
    year:string, 
    make:string,  
    model:string,  
    owner:AccountId, 
    dateAcquired:string, 
    vehicleNotes:string,
    ): void {
      let newVehicle = new Vehicle(year,make, model, owner, dateAcquired, vehicleNotes);
      this.vehicles.set(newVehicle.id, newVehicle);
    }

  @mutateState()
  addService(
    vehicleId:VehicleId,
    serviceDate:string, 
    serviceNotes:string
    ): void {
      let newVehicleService = new VehicleService(vehicleId, serviceDate, serviceNotes);
      this.vehicleServiceHistory.set(newVehicleService.id, newVehicleService);
      this.addServiceId(vehicleId, newVehicleService.id)
    }

  @mutateState()
  addServiceId(
    vehicleId:VehicleId,
    vehicleServiceId:VehicleServiceId, 
    ): void {
      let currentVehicle = this.vehicles.get(vehicleId)
      if(currentVehicle !== null){
        currentVehicle.serviceIds.push(vehicleServiceId)
        this.vehicles.set(vehicleId, currentVehicle)
      }
    } 
}
  
'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;
export type VehicleId = string;
export type VehicleServiceId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

// common keys for singlton instances and initialization
export const GARAGE_KEY = "state"

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;
export type Balance = Amount;
export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * @function idCreator
 * @return {string}
 * Creates a unique id by combining sender + block height
 */
export function idCreator(): string {
  // let title = Context.sender.substring(0, Context.sender.lastIndexOf('.'))
  // let title = Context.sender
  // let id = title + '-' + Context.blockIndex.toString()
  let id =  Context.blockIndex.toString()

  return id
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}

'''
'''--- src/vehicleGarage/asconfig.json ---
{
    "extends": "near-sdk-as/asconfig.json"
}
'''
'''--- src/vehicleGarage/assembly/index.ts ---

import { VehicleId, VehicleServiceId, AccountId, Money, Timestamp, idCreator, GARAGE_KEY } from "../../utils";
import { VehicleGarage } from "./models";

export function init(): void {
  // make asserstions here
  VehicleGarage.create_garage()
}

export function get_vehicle_garage(): VehicleGarage {
  // make asserstions here
  return VehicleGarage.get_garage()
}

export function add_vehicle(year:string, make:string,  model:string,  owner:AccountId, vehicleNotes:string, dateAcquired:string): void {
  // make asserstions here
  VehicleGarage.add_vehicle(year, make, model, owner, vehicleNotes, dateAcquired)
}

export function update_vehicle(vehicleId: VehicleId, year:string, make:string,  model:string,  owner:AccountId, vehicleNotes:string, dateAcquired:string): void {
  // make asserstions here
  VehicleGarage.update_vehicle(vehicleId, year, make, model, owner, vehicleNotes, dateAcquired)
}

export function delete_vehicle(vehicleId: VehicleId): void{
  // make asserstions here
  VehicleGarage.delete_vehicle(vehicleId)
}

export function add_vehicle_service(vehicleId:VehicleId, serviceDate:string, serviceNotes:string): void {
  // make asserstions here
  VehicleGarage.add_vehicle_service(vehicleId, serviceDate, serviceNotes)
}

export function update_vehicle_service(vehicleServiceId: VehicleServiceId, vehicleId:VehicleId, serviceDate:string, serviceNotes:string): void {
  // make asserstions here
  VehicleGarage.update_vehicle_service(vehicleServiceId, vehicleId, serviceDate, serviceNotes)
}

export function delete_vehicle_service(vehicleServiceId: VehicleServiceId):void {
  // make asserstions here
  VehicleGarage.delete_vehicle_service(vehicleServiceId)
}

'''
'''--- src/vehicleGarage/assembly/models.ts ---
import {
    context,
    storage,
    PersistentMap,
    PersistentSet
} from "near-sdk-as";

import { VehicleId, VehicleServiceId, AccountId, Timestamp, idCreator, GARAGE_KEY } from "../../utils";

@nearBindgen
export class Vehicle {

    public id: VehicleId = idCreator();
    public serviceIds: PersistentSet<VehicleServiceId> = new PersistentSet<VehicleServiceId>("s")
    created_at: Timestamp = context.blockTimestamp;

    constructor(
        public year:string,
        public make:string, 
        public model:string, 
        public owner:AccountId,
        public vehicleNotes:string,
        public dateAcquired:string,
    ) {}

}

@nearBindgen
export class VehicleService{

    public id: VehicleServiceId = idCreator();
    created_at: Timestamp = context.blockTimestamp;

    constructor(
        public vehicleId:VehicleId, 
        public serviceDate:string, 
        public serviceNotes:string
    ) {}
}

@nearBindgen
export class VehicleGarage {
    creator: AccountId = context.predecessor;
    created_at: Timestamp = context.blockTimestamp;

    static create_garage(): void{
        const garage = new VehicleGarage()
        this.set_garage(garage)
    }

    static get_garage(): VehicleGarage {
        return storage.getSome<VehicleGarage>(GARAGE_KEY)
    }

    static set_garage(garage: VehicleGarage): void{
        storage.set(GARAGE_KEY, garage)
    }

   // -------------------------------------------
   // Vehicles
   // -------------------------------------------

    static add_vehicle(year:string, make:string,  model:string,  owner:AccountId, vehicleNotes:string, dateAcquired:string): void{
        let newVehicle = new Vehicle(year,make, model, owner, dateAcquired, vehicleNotes);
        vehicles.set(newVehicle.id, newVehicle);
    }

    static update_vehicle(vehicleId:VehicleId, year:string, make:string, model:string,  owner:AccountId, vehicleNotes:string, dateAcquired:string): void{
        let currentVehicle = vehicles.get(vehicleId)
        if(currentVehicle !== null) {
            currentVehicle.year = year
            currentVehicle.make = make
            currentVehicle.model = model
            currentVehicle.owner = owner
            currentVehicle.vehicleNotes = vehicleNotes
            currentVehicle.dateAcquired = dateAcquired
            vehicles.set(vehicleId, currentVehicle)
        }
    }

    static delete_service_id_from_vehicle(vehicleId:VehicleId, vehicleServiceId: VehicleServiceId): void{
        let currentVehicle = vehicles.get(vehicleId)
        if(currentVehicle !== null){
            let serviceIds = currentVehicle.serviceIds
            serviceIds.delete(vehicleServiceId)
            vehicles.set(vehicleId, currentVehicle)
        }
    }

    static delete_vehicle(vehicleId: VehicleId): void{
        // grab all service ids
        let currentVehicle = vehicles.get(vehicleId)

        if( currentVehicle !== null){
            let vehicleServiceIds = currentVehicle.serviceIds.values()
            // delete all services from vehicle
            if(vehicleServiceIds.length){
                for (let i = 0; i < vehicleServiceIds.length; ++i) {
                    VehicleGarage.delete_vehicle_service(vehicleServiceIds[i])
                }
            }
        }

        // delete vehicle
        vehicles.delete(vehicleId)
    }

   // -------------------------------------------
   // Vehicle Services
   // -------------------------------------------

   static add_vehicle_service(vehicleId:VehicleId, serviceDate:string, serviceNotes:string): void {
        let newVehicleService = new VehicleService(vehicleId, serviceDate, serviceNotes);
        vehicleService.set(newVehicleService.id, newVehicleService);
        VehicleGarage.add_service_id(vehicleId, newVehicleService.id)
    }

    static add_service_id(vehicleId: VehicleId, vehicleServiceId: VehicleServiceId): void {
        let currentVehicle = vehicles.get(vehicleId)
        if(currentVehicle !== null) {
            currentVehicle.serviceIds.add(vehicleServiceId)
            vehicles.set(vehicleId, currentVehicle)
        }
    }

   static update_vehicle_service(vehicleServiceId: VehicleServiceId, vehicleId:VehicleId, serviceDate:string, serviceNotes:string): void {
        let currentVehicleService = vehicleService.get(vehicleServiceId)
        if(currentVehicleService !== null) {
            currentVehicleService.vehicleId = vehicleId
            currentVehicleService.serviceDate = serviceDate
            currentVehicleService.serviceNotes = serviceNotes
            vehicleService.set(vehicleServiceId, currentVehicleService)
        }
   }

   static delete_vehicle_service(vehicleServiceId: VehicleServiceId):void {
    let currentVehicleService = vehicleService.get(vehicleServiceId)
    if(currentVehicleService !== null){
        let currentVehicleId = currentVehicleService.vehicleId
        VehicleGarage.delete_service_id_from_vehicle(currentVehicleId, vehicleServiceId)
    }
       vehicleService.delete(vehicleServiceId)
   }

}

const vehicles = new PersistentMap<VehicleId, Vehicle>("v");
const vehicleService = new PersistentMap<VehicleServiceId, VehicleService>("vs");

'''