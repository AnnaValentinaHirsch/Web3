*GitHub Repository "Mycelium-Lab/crisp-lending"*

'''--- Cargo.toml ---
[package]
name = "mycelium-lab-lending"
version = "0.1.0"
authors = ["Near Inc <hello@near.org>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
serde = "0.9.0-rc2"
near-contract-standards = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- src/balance.rs ---
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_sdk::env;
use near_sdk::{collections::UnorderedMap, json_types::U128, AccountId};

use crate::errors::{BALANCE_NOT_FOUND, TOKEN_HAS_NOT_BEEN_DEPOSITED};
use crate::Contract;

pub type BalancesMap = UnorderedMap<AccountId, Balance>;
type Balance = UnorderedMap<AccountId, u128>;

pub const GAS_FOR_FT_TRANSFER: u64 = 20_000_000_000_000;

impl Contract {
    fn assert_owner() {
        assert_eq!(env::current_account_id(), env::predecessor_account_id());
    }

    pub fn deposit_ft(&mut self, account_id: &AccountId, token_in: &AccountId, amount: u128) {
        Contract::assert_owner();
        if let Some(mut balance) = self.balances_map.get(account_id) {
            let current_value = balance.get(token_in).unwrap_or(0);
            let new_value = current_value + amount;
            balance.insert(token_in, &new_value);
            self.balances_map.insert(account_id, &balance);
        } else {
            let mut balance = UnorderedMap::new(account_id.clone().into_bytes());
            balance.insert(&token_in.to_string(), &amount);
            self.balances_map.insert(account_id, &balance);
        }
    }

    pub fn balance_withdraw(&mut self, account_id: &AccountId, token: &AccountId, amount: u128) {
        Contract::assert_owner();
        if let Some(mut balance) = self.balances_map.get(account_id) {
            if let Some(current_amount) = balance.get(token) {
                let message = format!(
                    "Not enough tokens. You want to withdraw {} of {} but only have {}",
                    amount, token, current_amount
                );
                assert!(amount <= current_amount, "{}", message);
                balance.insert(token, &(current_amount - amount));
                self.balances_map.insert(account_id, &balance);
                ext_fungible_token::ft_transfer(
                    account_id.to_string(),
                    U128(amount),
                    None,
                    &token,
                    1,
                    GAS_FOR_FT_TRANSFER,
                );
                return;
            }
        }
        panic!("{}", TOKEN_HAS_NOT_BEEN_DEPOSITED);
    }

    pub fn decrease_balance(&mut self, account_id: &AccountId, token: &AccountId, amount: u128) {
        Contract::assert_owner();
        if let Some(mut balance) = self.balances_map.get(account_id) {
            if let Some(current_amount) = balance.get(token) {
                let message = format!("Not enough tokens. You want to decrease your balance on {} of {} but only have {}", amount, token, current_amount);
                assert!(amount <= current_amount, "{}", message);
                balance.insert(token, &(current_amount - amount));
                self.balances_map.insert(account_id, &balance);
            }
        } else {
            let message = format!(
                "Not enough tokens. You want to decrease your balance on {} of {} but only have {}",
                amount, token, 0
            );
            panic!("{}", message);
        }
    }

    pub fn increase_balance(&mut self, account_id: &AccountId, token: &AccountId, amount: u128) {
        Contract::assert_owner();
        if let Some(mut balance) = self.balances_map.get(account_id) {
            if let Some(current_amount) = balance.get(token) {
                balance.insert(token, &(current_amount + amount));
                self.balances_map.insert(account_id, &balance);
            } else {
                balance.insert(token, &amount);
                self.balances_map.insert(account_id, &balance);
            }
        } else {
            panic!("{}", BALANCE_NOT_FOUND);
        }
    }
}

'''
'''--- src/borrow.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::AccountId;

use crate::deposit::{BASIS_POINT_BASE, MS_IN_YEAR};

pub type BorrowId = u128;
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Borrow {
    pub asset: AccountId,
    pub amount: u128,
    pub collateral: u128,
    pub position_id: u128,
    pub health_factor: f64,
    pub last_update_timestamp: u64,
    pub apr: u16,
    pub fees: u128,
}

impl Borrow {
    pub fn update_timestamp(&mut self, current_timestamp: u64) {
        self.last_update_timestamp = current_timestamp;
    }

    pub fn calculate_fees(&self, current_timestamp: u64) -> u128 {
        let fees = (self.amount as f64)
            * Self::timestamp_difference_to_coefficient(
                current_timestamp - self.last_update_timestamp,
                self.apr,
            );
        fees.round() as u128
    }

    fn timestamp_difference_to_coefficient(timestamp_difference: u64, apr: u16) -> f64 {
        (timestamp_difference as f64 / MS_IN_YEAR as f64)
            * (1_f64 + apr as f64 / BASIS_POINT_BASE as f64)
    }

    pub fn refresh_fees(&mut self, current_timestamp: u64) {
        self.fees += self.calculate_fees(current_timestamp);
    }

    pub fn refresh_health_factor(&mut self) {
        self.health_factor = self.collateral as f64 / (self.amount as f64 + self.fees as f64);
    }

    pub fn assert_health_factor_is_above_1(&self) {
        assert!(self.health_factor >= 1.0);
    }

    pub fn assert_health_factor_is_under_1(&self) {
        assert!(self.health_factor < 1.0);
    }
}

'''
'''--- src/deposit.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    AccountId,
};

pub const MS_IN_YEAR: u64 = 31536000000;
pub const BASIS_POINT_BASE: u16 = 10000;

pub type DepositId = u128;

#[derive(BorshDeserialize, BorshSerialize, Clone)]
pub struct Deposit {
    pub owner_id: AccountId,
    pub asset: AccountId,
    pub amount: u128,
    pub timestamp: u64,
    pub last_update_timestamp: u64,
    pub apr: u16,
    pub growth: u128,
}

impl Deposit {
    pub fn update_timestamp(&mut self, current_timestamp: u64) {
        self.last_update_timestamp = current_timestamp;
    }

    pub fn calculate_growth(&self, current_timestamp: u64) -> u128 {
        let growth = (self.amount as f64)
            * Self::timestamp_difference_to_coefficient(
                current_timestamp - self.last_update_timestamp,
                self.apr,
            );
        growth.round() as u128
    }

    fn timestamp_difference_to_coefficient(timestamp_difference: u64, apr: u16) -> f64 {
        (timestamp_difference as f64 / MS_IN_YEAR as f64)
            * (1_f64 + apr as f64 / BASIS_POINT_BASE as f64)
    }

    pub fn refresh_growth(&mut self, current_timestamp: u64) {
        self.growth += self.calculate_growth(current_timestamp);
    }

    pub fn take_growth(&mut self, amount: u128) -> u128 {
        if amount > self.growth {
            let result = self.growth;
            self.growth = 0;
            result
        } else {
            self.growth -= amount;
            amount
        }
    }
}

'''
'''--- src/errors.rs ---
pub const TOKEN_HAS_NOT_BEEN_DEPOSITED: &str = "Token has not been deposited";
pub const BALANCE_NOT_FOUND: &str = "Balance not found";

'''
'''--- src/lib.rs ---
use std::collections::HashMap;

use balance::BalancesMap;
use borrow::{Borrow, BorrowId};
use deposit::{Deposit, DepositId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::UnorderedMap;
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId};
use reserve::Reserve;

mod balance;
mod borrow;
mod deposit;
mod errors;
mod reserve;
mod token_receiver;

pub const APR_DEPOSIT: u16 = 500;
pub const APR_BORROW: u16 = 1000;
pub const BORROW_RATIO: f64 = 0.8;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    pub owner_id: AccountId,
    pub locked_nfts: UnorderedMap<String, AccountId>,
    pub balances_map: BalancesMap,
    pub deposits: HashMap<DepositId, Deposit>,
    pub deposits_created_number: DepositId,
    pub reserves: UnorderedMap<AccountId, Reserve>,
    pub borrows: UnorderedMap<BorrowId, Borrow>,
    pub borrows_number: BorrowId,
}

#[near_bindgen]
impl Contract {
    pub fn new(owner_id: AccountId) -> Self {
        Contract {
            owner_id,
            locked_nfts: UnorderedMap::new(b"m"),
            balances_map: UnorderedMap::new(b"b"),
            deposits: HashMap::new(),
            deposits_created_number: 0,
            reserves: UnorderedMap::new(b"r"),
            borrows: UnorderedMap::new(b"b"),
            borrows_number: 0,
        }
    }

    #[private]
    pub fn create_reserve(&mut self, reserve_token: AccountId) {
        let reserve = Reserve::default();
        self.reserves.insert(&reserve_token, &reserve);
    }

    pub fn create_deposit(&mut self, asset: AccountId, amount: U128) {
        let account_id = env::predecessor_account_id();
        let timestamp = env::block_timestamp();
        let deposit = Deposit {
            owner_id: account_id.clone(),
            asset: asset.clone(),
            amount: amount.0,
            timestamp,
            last_update_timestamp: timestamp,
            apr: APR_DEPOSIT,
            growth: 0,
        };
        self.deposits.insert(self.deposits_created_number, deposit);
        self.deposits_created_number += 1;
        self.decrease_balance(&account_id, &asset.to_string(), amount.0);
        let mut reserve = self.reserves.get(&asset).unwrap();
        reserve.increase_deposit(amount.0);
        self.reserves.insert(&asset, &reserve);
    }

    pub fn close_deposit(&mut self, deposit_id: U128) {
        let account_id = env::predecessor_account_id();
        if let Some(deposit) = self.deposits.remove(&deposit_id.0) {
            assert_eq!(deposit.owner_id, account_id, "You do not own this deposit");
            self.increase_balance(&account_id, &deposit.asset, deposit.amount);
            self.increase_balance(&account_id, &deposit.asset, deposit.growth);
            let mut reserve = self.reserves.get(&deposit.asset).unwrap();
            reserve.decrease_deposit(deposit.amount);
            self.reserves.insert(&deposit.asset, &reserve);
        } else {
            panic!("Deposit not found");
        }
    }

    pub fn refresh_deposits_growth(&mut self) {
        let current_timestamp = env::block_timestamp();
        for (_, deposit) in &mut self.deposits {
            deposit.refresh_growth(current_timestamp);
        }
    }

    #[allow(unused_assignments)]
    pub fn take_deposit_growth(&mut self, deposit_id: U128, amount: U128) -> U128 {
        let account_id = env::predecessor_account_id();
        let mut asset: Option<AccountId> = None;
        let mut growth = 0;
        if let Some(deposit) = self.deposits.get_mut(&deposit_id.0) {
            assert_eq!(deposit.owner_id, account_id, "You do not own this deposit");
            deposit.refresh_growth(env::block_timestamp());
            growth = deposit.take_growth(amount.0);
            asset = Some(deposit.asset.clone());
        } else {
            panic!("Deposit not found");
        }
        if let Some(asset) = asset {
            self.increase_balance(&account_id, &asset, growth);
            return growth.into();
        }
        0.into()
    }

    pub fn get_account_deposits(&self, account_id: AccountId) -> HashMap<DepositId, Deposit> {
        let mut result: HashMap<DepositId, Deposit> = HashMap::new();
        for (id, deposit) in &self.deposits {
            if deposit.owner_id == account_id {
                result.insert(*id, deposit.clone());
            }
        }
        result
    }

    pub fn get_total_locked_value_in_position(&self, _position_id: u128) {}

    pub fn supply_collateral_and_borrow(&mut self, position_id: u128) {
        let account_id = env::predecessor_account_id();
        self.assert_account_owns_nft_on_lending(position_id.to_string(), &account_id);
        // 0. somehow get (amount = total_value locked, token)on position
        let collateral = 0;
        let to_borrow = (BORROW_RATIO * collateral as f64).round() as u128; // health factor 1.25
        let token = String::new();
        self.increase_balance(&account_id, &token, to_borrow);
        let mut reserve = self.reserves.get(&token).unwrap();
        reserve.borrowed += to_borrow;
        self.reserves.insert(&token, &reserve);
        let borrow = Borrow {
            asset: token,
            amount: to_borrow,
            collateral,
            position_id,
            health_factor: 1.25,
            last_update_timestamp: env::block_timestamp(),
            apr: APR_BORROW,
            fees: 0,
        };
        self.borrows.insert(&self.borrows_number, &borrow);
        self.borrows_number += 1;
    }

    pub fn return_collateral_and_repay(&mut self, borrow_id: u128) {
        let account_id = env::predecessor_account_id();
        self.assert_account_owns_nft_on_lending(borrow_id.to_string(), &account_id);
        let borrow = self.borrows.remove(&borrow_id).unwrap();
        borrow.assert_health_factor_is_above_1();
        self.increase_balance(&account_id, &borrow.asset, borrow.amount - borrow.fees);
        let mut reserve = self.reserves.get(&borrow.asset).unwrap();
        reserve.borrowed -= borrow.amount;
        self.reserves.insert(&borrow.asset, &reserve);
        // send nft back ?
    }

    pub fn get_liquidation_list(&self) -> Vec<BorrowId> {
        let mut result = Vec::new();
        for (id, borrow) in self.borrows.iter() {
            if borrow.health_factor < 1.0 {
                result.push(id);
            }
        }
        result
    }

    pub fn liquidate(&mut self, borrow_id: BorrowId, amount_in: U128, amount_out: U128) {
        if let Some(mut borrow) = self.borrows.get(&borrow_id) {
            borrow.assert_health_factor_is_under_1();
            let discount = (1.0 - borrow.health_factor) / 2.0;
            let discounted_collateral_sum = amount_out.0 * (1 - discount as u128);
            assert!(discounted_collateral_sum <= amount_in.0);
            borrow.collateral -= amount_out.0;
            borrow.amount -= amount_out.0;
            borrow.refresh_health_factor();
            borrow.assert_health_factor_is_under_1();
            self.borrows.insert(&borrow_id, &borrow);
        } else {
            panic!("Borrow not found");
        }
    }

    fn assert_account_owns_nft_on_lending(&self, token_id: String, account_id: &AccountId) {
        if let Some(owner) = self.locked_nfts.get(&token_id) {
            assert_eq!(
                &owner, account_id,
                "User did not locked this NFT on lending contract"
            );
        } else {
            panic!("User did not locked this NFT on lending contract");
        }
    }
}

'''
'''--- src/reserve.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Reserve {
    pub deposited: u128,
    pub borrowed: u128,
    pub total_liquidity: u128,
    pub liquidation_threshold: f64,
    pub loan_to_value: f64,
    pub utilization_rate: f64,
    pub target_utilization_rate: f64,
}

impl Default for Reserve {
    fn default() -> Self {
        Reserve {
            deposited: 0,
            borrowed: 0,
            total_liquidity: 0,
            liquidation_threshold: 0.0,
            loan_to_value: 0.0,
            utilization_rate: 0.0,
            target_utilization_rate: 0.0,
        }
    }
}

impl Reserve {
    pub fn increase_deposit(&mut self, amount: u128) {
        self.deposited += amount;
    }

    pub fn decrease_deposit(&mut self, amount: u128) {
        self.deposited -= amount;
    }

    pub fn calculate_liquidation_threshold(&self) -> f64 {
        0.0
    }

    pub fn refresh_utilization_rate(&mut self) {
        self.utilization_rate = match self.total_liquidity {
            0 => 0.0,
            _ => self.borrowed as f64 / self.total_liquidity as f64,
        }
    }
}

'''
'''--- src/token_receiver.rs ---
use crate::*;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_contract_standards::non_fungible_token::core::NonFungibleTokenReceiver;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{json_types::U128, near_bindgen, PromiseOrValue};

#[near_bindgen]
impl NonFungibleTokenReceiver for Contract {
    #[allow(unreachable_code)]
    #[allow(unused_variables)]
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool> {
        self.locked_nfts.insert(&token_id, &sender_id);
        PromiseOrValue::Value(true)
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    #[allow(unreachable_code)]
    #[allow(unused_variables)]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        PromiseOrValue::Value(U128(0))
    }
}

'''
'''--- tests/collaterals.rs ---
use crate::common::utils::setup_contract;

mod common;

#[test]
fn mock_test() {
    let _contract = setup_contract();
}

'''
'''--- tests/common/mod.rs ---
pub mod utils;

'''
'''--- tests/common/utils.rs ---
use mycelium_lab_lending::Contract;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::MockedBlockchain;
use near_sdk::{
    json_types::{ValidAccountId, U128},
    test_utils::{accounts, VMContextBuilder},
    testing_env,
};
use near_sdk_sim::to_yocto;

pub fn setup_contract() -> (VMContextBuilder, Contract) {
    let mut context = VMContextBuilder::new();
    testing_env!(context.predecessor_account_id(accounts(0)).build());
    let contract = Contract::new(accounts(0).to_string());
    (context, contract)
}

pub fn _deposit_tokens(
    context: &mut VMContextBuilder,
    contract: &mut Contract,
    account_id: ValidAccountId,
    token_id: ValidAccountId,
    amount: U128,
) {
    testing_env!(context
        .predecessor_account_id(token_id)
        .attached_deposit(to_yocto("1"))
        .build());
    contract.ft_on_transfer(account_id.clone(), amount, "".to_string());
}

#[allow(dead_code)]
pub fn withdraw_tokens(
    context: &mut VMContextBuilder,
    _contract: &mut Contract,
    account_id: ValidAccountId,
    _token_id: ValidAccountId,
    _amount: U128,
) {
    testing_env!(context
        .predecessor_account_id(account_id)
        .attached_deposit(to_yocto("1"))
        .build());
    // contract.withdraw(token_id.into(), amount.into());
}

'''