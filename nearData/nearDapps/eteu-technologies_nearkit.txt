*GitHub Repository "eteu-technologies/nearkit"*

'''--- .github/workflows/lint.yml ---
name: lint
on:
  push:
  pull_request:

jobs:
  golangci:
    name: "Run linter (golangci-lint)"
    runs-on: "ubuntu-latest"
    steps:
      - uses: "actions/checkout@v2"
        with:
          submodules: recursive
          ssh-key: |
            ${{ secrets.ETEU_BOT_DEPLOY_SSH_KEY }}

      - name: "Run golangci-lint"
        id: "run-linter"
        uses: "golangci/golangci-lint-action@v2"
        env:
          GOPRIVATE: "github.com/eteu-technologies/*"

'''
'''--- README.md ---
# NEARKit

[![CI](https://github.com/eteu-technologies/nearkit/actions/workflows/lint.yml/badge.svg)](https://github.com/eteu-technologies/nearkit/actions/workflows/lint.yml)
[![built with nix](https://builtwithnix.org/badge.svg)](https://builtwithnix.org)

CLI to interact with NEAR blockchain

## Running

### Using Nix

We're using Nix flakes!

`nix run github:eteu-technologies/nearkit -- --help`

### Build & run

Clone and do `go build ./cmd/nearkit`. You'll get binary named `nearkit` what you can install somewhere.

<!--
NOTE: Broken as of 2021-07-25:
go/src/github.com/eteu-technologies/near-api-go/pkg/types/balance.go:9:2: code in directory /Users/mark/go/src/github.com/eteu-technologies/golang-uint128 expects import "lukechampine.com/uint128"

### Using Go CLI

```
GO111MODULE=off go get github.com/eteu-technologies/nearkit/cmd/nearkit
GO111MODULE=off go run github.com/eteu-technologies/nearkit/cmd/nearkit
```
-->

## License

MIT

'''
'''--- cmd/nearkit/command_change.go ---
package main

import (
	"errors"

	neartypes "github.com/eteu-technologies/near-api-go/pkg/types"
	"github.com/urfave/cli/v2"
)

var changeCall = &cli.Command{
	Name:    "change",
	Aliases: []string{"call"},
	Usage:   "Calls smart contract's function",
	Flags: []cli.Flag{
		&cli.Uint64Flag{
			Name: "gas",
			EnvVars: []string{
				"NEARKIT_CALL_ATTACH_GAS",
			},
			Usage:    "Amount of gas to attach",
			Value:    neartypes.DefaultFunctionCallGas,
			Required: true,
		},
		&cli.StringFlag{
			Name: "deposit",
			EnvVars: []string{
				"NEARKIT_CALL_ATTACH_DEPOSIT",
			},
			Usage: "Amount of NEAR tokens to attach",
			Value: "0",
		},
		&cli.StringFlag{
			Name: "target-id",
			EnvVars: []string{
				"NEARKIT_TARGET_ACCOUNT_ID",
			},
			Usage:    "Account to make this call to",
			Required: true,
		},
	},
	Action: changeCallAction,
}

func changeCallAction(cctx *cli.Context) (err error) {
	return errors.New("not implemented")
}

'''
'''--- cmd/nearkit/command_deploy.go ---
package main

import (
	"crypto/sha256"
	"io/ioutil"
	"log"

	nearclient "github.com/eteu-technologies/near-api-go/pkg/client"
	nearconfig "github.com/eteu-technologies/near-api-go/pkg/config"
	nearaction "github.com/eteu-technologies/near-api-go/pkg/types/action"
	"github.com/mr-tron/base58"
	"github.com/urfave/cli/v2"
)

var deployContract = &cli.Command{
	Name:  "deploy",
	Usage: "Deploys a smart contract under specified account",
	Flags: []cli.Flag{
		&cli.PathFlag{
			Name: "wasm-file",
			EnvVars: []string{
				"NEARKIT_DEPLOY_WASM_FILE",
			},
			Aliases:  []string{"wasmFile"}, // near-cli compatibility
			Usage:    "WASM blob to deploy",
			Required: true,
		},
	},
	Action: deployContractAction,
}

func deployContractAction(cctx *cli.Context) (err error) {
	nodeURL, err := ensureNodeURL(cctx)
	if err != nil {
		return err
	}

	credential, err := ensureCredential(cctx)
	if err != nil {
		return err
	}

	wasmFile := cctx.Path("wasm-file")
	wasmBlob, err := ioutil.ReadFile(wasmFile)
	if err != nil {
		return err
	}

	codeHashRaw := sha256.Sum256(wasmBlob)
	codeHash := base58.Encode(codeHashRaw[:])

	log.Printf("Deploying '%s' (code hash: '%s') to account '%s' (network '%s')", wasmFile, codeHash, credential.AccountID, nodeURL)

	client, err := nearclient.NewClient(nodeURL)
	if err != nil {
		return err
	}

	ctx := nearclient.ContextWithKeyPair(cctx.Context, credential.PrivateKey)
	res, err := client.TransactionSendAwait(
		ctx,
		credential.AccountID,
		credential.AccountID,
		[]nearaction.Action{
			nearaction.NewDeployContract(wasmBlob),
		},
		nearclient.WithLatestBlock(),
	)
	if err != nil {
		return err
	}

	if networkInfo, ok := nearconfig.Networks[cctx.String("network-id")]; ok {
		log.Printf("%s/transactions/%s", networkInfo.ExplorerURL, res.Transaction.Hash)
	} else {
		log.Printf("%s", res.Transaction.Hash)
	}

	return
}

'''
'''--- cmd/nearkit/command_genesis.go ---
package main

import (
	"encoding/json"
	"os"

	nearclient "github.com/eteu-technologies/near-api-go/pkg/client"
	"github.com/urfave/cli/v2"
)

var genesis = &cli.Command{
	Name:  "genesis",
	Usage: "Dumps you the current genesis configuration",
	Flags: []cli.Flag{
		&cli.BoolFlag{
			Name:    "pretty",
			Aliases: []string{"pretty-print"},
			Usage:   "Whether to pretty print the JSON",
		},
	},
	Action: genesisAction,
}

func genesisAction(cctx *cli.Context) (err error) {
	nodeURL, err := ensureNodeURL(cctx)
	if err != nil {
		return err
	}

	client, err := nearclient.NewClient(nodeURL)
	if err != nil {
		return err
	}

	ctx := cctx.Context
	res, err := client.GenesisConfig(ctx)
	if err != nil {
		return err
	}

	encoder := json.NewEncoder(os.Stdout)
	encoder.SetEscapeHTML(false)
	if cctx.Bool("pretty") {
		encoder.SetIndent("", "    ")
	}

	err = encoder.Encode(res)

	return
}

'''
'''--- cmd/nearkit/command_genkey.go ---
package main

import (
	"crypto/rand"
	"encoding/json"
	"fmt"
	"os"

	nearkey "github.com/eteu-technologies/near-api-go/pkg/types/key"
	"github.com/urfave/cli/v2"
)

var genKey = &cli.Command{
	Name:  "genkey",
	Usage: "Generates ED25519 key pair, optionally with account ID",
	Flags: []cli.Flag{
		&cli.BoolFlag{
			Name:    "pretty",
			Aliases: []string{"pretty-print"},
			Usage:   "Whether to pretty print the JSON",
		},
		&cli.BoolFlag{
			Name:  "node-key",
			Usage: `Whether key is meant to use with NEAR node. Renames "private_key" to "secret_key"`,
		},
		&cli.StringFlag{
			Name:  "account",
			Usage: "Account ID to use (optional)",
		},
	},
	Action: genKeyAction,
}

func genKeyAction(cctx *cli.Context) (err error) {
	var key struct {
		AccountID  string `json:"account_id,omitempty"`
		SecretKey  string `json:"secret_key,omitempty"`
		PrivateKey string `json:"private_key,omitempty"`
		PublicKey  string `json:"public_key"`
	}

	keyPair, err := nearkey.GenerateKeyPair(nearkey.KeyTypeED25519, rand.Reader)
	if err != nil {
		err = fmt.Errorf("Failed to generate ed25519 keypair: %w", err)
		return
	}

	nodeKey := cctx.Bool("node-key")

	key.AccountID = cctx.String("account")
	if key.AccountID == "" && nodeKey {
		key.AccountID = "node"
	}

	if pk := keyPair.PrivateEncoded(); nodeKey {
		key.SecretKey = pk
	} else {
		key.PrivateKey = pk
	}
	key.PublicKey = keyPair.PublicKey.String()

	encoder := json.NewEncoder(os.Stdout)
	encoder.SetEscapeHTML(false)
	if cctx.Bool("pretty") {
		encoder.SetIndent("", "    ")
	}
	err = encoder.Encode(&key)

	return
}

'''
'''--- cmd/nearkit/command_view.go ---
package main

import (
	"errors"

	"github.com/urfave/cli/v2"
)

var viewCall = &cli.Command{
	Name:  "view",
	Usage: "Calls smart contract's view-only function",
	Flags: []cli.Flag{
		&cli.StringFlag{
			Name: "target-id",
			EnvVars: []string{
				"NEARKIT_TARGET_ACCOUNT_ID",
			},
			Usage:    "Account to make this call to",
			Required: true,
		},
	},
	Action: viewCallAction,
}

func viewCallAction(cctx *cli.Context) (err error) {
	return errors.New("not implemented")
}

'''
'''--- cmd/nearkit/common.go ---
package main

import (
	"errors"
	"fmt"
	"log"
	"os"
	"path/filepath"

	nearconfig "github.com/eteu-technologies/near-api-go/pkg/config"
	"github.com/eteu-technologies/nearkit/internal/account"
	"github.com/urfave/cli/v2"
)

func ensureAccountID(cctx *cli.Context) (accountID string, err error) {
	accountID = cctx.String("account-id")
	if accountID == "" {
		err = errors.New("account ID is not set, set it using --account-id flag")
	}
	return
}

func ensureCredential(cctx *cli.Context) (*account.Credential, error) {
	accountID, err := ensureAccountID(cctx)
	if err != nil {
		return nil, err
	}

	credentialsFile := cctx.Path("credentials-file")

	// Try resolving the credentials file
	if credentialsFile == "" {
		networkID := cctx.String("network-id")

		// Ensure credentials directory is set
		var credentialsDir string
		if credentialsDir = cctx.Path("credentials-directory"); credentialsDir == "" {
			if networkID == "" {
				return nil, errors.New("Using custom network RPC URL, cannot determine network ID and credentials path reliably. Please specify it using '--credentials-directory'")
			}

			credentialsDir = cctx.String("credentials-base-directory")
			if credentialsDir == "" {
				credentialsDir, err = os.UserHomeDir()
				if err != nil {
					return nil, fmt.Errorf("Unable to resolve home directory, try using '--credentials-base-directory'? %w", err)
				}
			}

			credentialsDir = filepath.Join(credentialsDir, ".near-credentials", networkID)
			_ = cctx.Set("credentials-directory", credentialsDir)
		}

		// Resolve the file
		credentialsFile = filepath.Join(credentialsDir, fmt.Sprintf("%s.json", accountID))
		_ = cctx.Set("credentials-file", credentialsFile)
	}

	credential, err := account.LoadCredentials(credentialsFile)
	if err != nil {
		return nil, err
	}

	return &credential, err
}

func ensureNodeURL(cctx *cli.Context) (nodeURL string, err error) {
	networkID := cctx.String("network-id")

	// Ensure network-rpc-url is set
	if !cctx.IsSet("network-rpc-url") {
		// Check if network is valid
		network, ok := nearconfig.Networks[networkID]
		if !ok {
			return nodeURL, fmt.Errorf("Invalid network %s", networkID)
		}

		nodeURL = network.NodeURL
		log.Printf("using network '%s'; rpc url '%s'", network.NetworkID, network.NodeURL)
		_ = cctx.Set("network-rpc-url", network.NodeURL)
	} else {
		// Unset networkID
		_ = cctx.Set("network-id", "")
		nodeURL = cctx.String("network-rpc-url")
	}
	return
}

'''
'''--- cmd/nearkit/main.go ---
package main

import (
	"log"
	"os"

	"github.com/urfave/cli/v2"
)

func main() {
	app := &cli.App{
		Name:  "nearkit",
		Usage: "Interact with NEAR blockchain",
		Flags: []cli.Flag{
			&cli.StringFlag{
				Name:    "network-id",
				Aliases: []string{"network"},
				EnvVars: []string{
					"NEARKIT_NETWORK_ID",
					"NEAR_ENV", // near-cli compatibility
				},
				Value: "testnet",
				Usage: "NEAR network to use",
			},
			&cli.StringFlag{
				Name: "network-rpc-url",
				EnvVars: []string{
					"NEARKIT_NETWORK_RPC_URL",
				},
				Usage: "NEAR network RPC URL",
			},
			/*
				&cli.StringFlag{
					Name:  "output-format",
					Usage: "Output format to use",
					Value: "human",
				},
			*/
			&cli.PathFlag{
				Name: "credentials-directory",
				EnvVars: []string{
					"NEARKIT_CREDENTIALS_DIRECTORY",
				},
				Usage: "Path to where credentials are stored",
			},
			&cli.PathFlag{
				Name: "credentials-base-directory",
				EnvVars: []string{
					"NEARKIT_CREDENTIALS_BASE_DIRECTORY",
				},
				Usage: "Path to substitute as home directory (~/.near-credentials)",
			},
			&cli.PathFlag{
				Name: "credentials-file",
				EnvVars: []string{
					"NEARKIT_CREDENTIALS_FILE",
				},
				Usage:       "Path to the credentials file for current action",
				DefaultText: "Will be resolved according to the network id",
			},
			&cli.StringFlag{
				Name: "account-id",
				EnvVars: []string{
					"NEARKIT_ACCOUNT_ID",
				},
				Aliases: []string{"accountId"}, // near-cli compatibility
				Usage:   "Account ID to use for transaction signing",
			},
		},
		Commands: []*cli.Command{
			deployContract,
			viewCall,
			changeCall,
			genesis,
			genKey,
		},
		Before: before,
	}

	err := app.Run(os.Args)
	if err != nil {
		log.Fatal(err)
	}
}

func before(cctx *cli.Context) (err error) {
	return
}

'''
'''--- internal/account/account.go ---
package account

import (
	"encoding/json"
	"fmt"
	"os"
)

func LoadCredentials(credentialFile string) (credential Credential, err error) {
	var cf *os.File
	if cf, err = os.Open(credentialFile); err != nil {
		return
	}
	defer cf.Close()

	if err = json.NewDecoder(cf).Decode(&credential); err != nil {
		return
	}

	if credential.PublicKey.String() != credential.PrivateKey.PublicKey.String() {
		err = fmt.Errorf("inconsistent public key, %s != %s", credential.PublicKey.String(), credential.PrivateKey.PublicKey.String())
		return
	}

	return
}

'''
'''--- internal/account/types.go ---
package account

import (
	neartypes "github.com/eteu-technologies/near-api-go/pkg/types"
	nearkey "github.com/eteu-technologies/near-api-go/pkg/types/key"
)

type Credential struct {
	AccountID  neartypes.AccountID     `json:"account_id"`
	PublicKey  nearkey.Base58PublicKey `json:"public_key"`
	PrivateKey nearkey.KeyPair         `json:"private_key"`
}

'''
'''--- vendorsha.sh ---
#!/usr/bin/env bash

nix-shell -p nix-prefetch --run "nix-prefetch '{ sha256 }: (callPackage (import ./default.nix) { }).go-modules.overrideAttrs (_: { modSha256 = sha256; })'"

'''