*GitHub Repository "near-examples/near-lake-raw-printer"*

'''--- Cargo.toml ---
[package]
name = "near-lake-raw-printer"
version = "0.1.0"
edition = "2021"
rust-version = "1.58.1"

[dependencies]
futures = "0.3.5"
itertools = "0.9.0"
tokio = { version = "1.1", features = ["sync", "time", "macros", "rt-multi-thread"] }
tokio-stream = { version = "0.1" }
tracing = "0.1.13"
tracing-subscriber = "0.2.4"
serde = { version = "1", features = ["derive"] }
serde_json = "1.0.55"

near-lake-framework = "0.4.0"

'''
'''--- README.md ---
# near-lake-raw-printer

This is a small indexer project built on top of [NEAR Lake Framework](https://github.com/near/near-lake-framework). This indexer is created to provide minimal working example of how to use the framework.

You may use it as a starting point in creating your own indexer based on NEAR Lake Framework.

## How it works

`near-lake-raw-printer` indexer connects to the NEAR Lake data source (AWS S3) and starts the block stream from the specified block height. You can adjust it for your needs in `LakeConfig` instantiating

```rust
let config = LakeConfig {
    s3_endpoint: None,
    s3_bucket_name: "near-lake-data-testnet".to_string(),
    s3_region_name: "eu-central-1".to_string(),
    start_block_height: 82800242, // want to start from the freshest
};
```

The main logic of what happens is defined in the function `handle_streamer_message`. In this indexer is just prints the observed block height and the number of shards in that block (number of included chunks).

You can write your logic in this function:

```rust
async fn handle_streamer_message(
    streamer_message: near_lake_framework::near_indexer_primitives::StreamerMessage,
) {
    eprintln!(
        "{} / shards {}",
        streamer_message.block.header.height,
        streamer_message.shards.len()
    );
}
```

Don't forget you need to provide valid AWS credentials in order to be charged by AWS for the S3 usage.

### AWS S3 Credentials
In order to be able to get objects from the AWS S3 bucket you need to provide the AWS credentials.

AWS default profile configuration with aws configure looks similar to the following:

```
~/.aws/credentials
```

```
[default]
aws_access_key_id=AKIAIOSFODNN7EXAMPLE
aws_secret_access_key=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
```

[AWS docs: Configuration and credential file settings](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html)

'''
'''--- src/main.rs ---
use futures::StreamExt;
use tracing_subscriber::EnvFilter;

use near_lake_framework::LakeConfigBuilder;

#[tokio::main]
async fn main() -> Result<(), tokio::io::Error> {
    init_tracing();

    let config = LakeConfigBuilder::default()
        .mainnet()
        .start_block_height(65772033)
        .build()
        .expect("Failed to build LakeConfig");

    let (_, stream) = near_lake_framework::streamer(config);

    let mut handlers = tokio_stream::wrappers::ReceiverStream::new(stream)
        .map(handle_streamer_message)
        .buffer_unordered(1usize);

    while let Some(_handle_message) = handlers.next().await {}

    Ok(())
}

async fn handle_streamer_message(
    streamer_message: near_lake_framework::near_indexer_primitives::StreamerMessage,
) {
    eprintln!(
        "{} / shards {}",
        streamer_message.block.header.height,
        streamer_message.shards.len()
    );
}

fn init_tracing() {
    let mut env_filter = EnvFilter::new("near_lake_framework=info");

    if let Ok(rust_log) = std::env::var("RUST_LOG") {
        if !rust_log.is_empty() {
            for directive in rust_log.split(',').filter_map(|s| match s.parse() {
                Ok(directive) => Some(directive),
                Err(err) => {
                    eprintln!("Ignoring directive `{}`: {}", s, err);
                    None
                }
            }) {
                env_filter = env_filter.add_directive(directive);
            }
        }
    }

    tracing_subscriber::fmt::Subscriber::builder()
        .with_env_filter(env_filter)
        .with_writer(std::io::stderr)
        .init();
}

'''