*GitHub Repository "keypom/keypom-js"*

'''--- .changeset/README.md ---
# Changesets

Hello and welcome! This folder has been automatically generated by `@changesets/cli`, a build tool that works
with multi-package repos, or single-package repos to help you version and publish your code. You can
find the full documentation for it [in our repository](https://github.com/changesets/changesets)

We have a quick list of common questions to get you started engaging with this project in
[our documentation](https://github.com/changesets/changesets/blob/main/docs/common-questions.md)

'''
'''--- .changeset/config.json ---
{
  "$schema": "https://unpkg.com/@changesets/config@2.3.0/schema.json",
  "changelog": "@changesets/cli/changelog",
  "commit": false,
  "fixed": [],
  "linked": [],
  "access": "public",
  "baseBranch": "main",
  "updateInternalDependencies": "patch",
  "ignore": []
}
'''
'''--- .eslintrc.base.yml ---
env:
  es6: true
  node: true
extends:
  - 'eslint:recommended'
parserOptions:
  ecmaVersion: 2018
  sourceType: module
rules:
  indent:
    - error
    - 4
    - SwitchCase: 1
  linebreak-style:
    - error
    - unix
  quotes:
    - error
    - single
  semi:
    - error
    - always
  no-console: off
globals:
  window: true
  fetch: true
  Headers: true
  document: true

'''
'''--- .eslintrc.js.yml ---
extends: './.eslintrc.base.yml'
env:
    jest: true
globals:
    jasmine: true
    window: false
    fail: true

'''
'''--- .eslintrc.ts.yml ---
extends:
  - './.eslintrc.base.yml'
  - 'plugin:@typescript-eslint/eslint-recommended'
  - 'plugin:@typescript-eslint/recommended'
parser: '@typescript-eslint/parser'

'''
'''--- .github/workflows/main.yml ---
on:
  pull_request:
    types:
      - closed

jobs:
  if_merged:
    if: github.event.pull_request.merged == true
    runs-on: ubuntu-latest
    steps:
    - name: Install Deps
      run: npm install
    - name: Build Documentation
      run: npm run build-docs && cd ..
    - name: Clone Docs Repo
      uses: actions/checkout@master
      with:
        repository: keypom/keypom-docs
        token: ${{ secrets.PAT }}
    - name: Install Deps
      run: cd keypom-docs && npm install
    - name: Build TypeDocs
      run: npm run build:typedocs
    - name: Create Pull Request
      uses: peter-evans/create-pull-request@v4.2.3
      with:
          token: ${{ secrets.PAT }}

'''
'''--- README.md ---
<p align="center">
  <a href="https://docs.keypom.xyz/">
    <picture>
      <img src="https://cloudflare-ipfs.com/ipfs/bafybeightypuoqly32gsrivh4efckhdv6wsefiynpnonlem6ts3ypgdm7e" height="128">
    </picture>
    <h1 align="center">Keypom JavaScript SDK</h1>
  </a>
</p>

<p align="center">
  <a aria-label="Made by Ben Kurrek" href="https://github.com/BenKurrek">
    <img src="https://img.shields.io/badge/MADE%20BY-Ben%20Kurrek-000000.svg?style=for-the-badge">
  </a>
  <a aria-label="Made by Matt Lockyer" href="https://github.com/mattlockyer">
    <img src="https://img.shields.io/badge/MADE%20BY-Matt%20Lockyer-000000.svg?style=for-the-badge">
  </a>
  <a aria-label="License" href="https://github.com/keypom/keypom-js/blob/main/LICENSE">
    <img alt="" src="https://img.shields.io/badge/License-GNU%20GPL-green?style=for-the-badge">
  </a>
  <a aria-label="Join the community" href="https://t.me/+OqI-cKxQU05lZDIx">
    <img alt="" src="https://img.shields.io/badge/Join%20The-community-blueviolet.svg?style=for-the-badge">
  </a>
</p>

---

> To view our Eth DENVER talk, click [here](https://youtu.be/oHj-GjFi6g4).
> To read more about the Keypom Protocol, refer to the [official GitHub repository](https://github.com/keypom/keypom#about)

# Getting Started

The Keypom SDK comes in two parts:
1. The Core SDK
2. The Keypom Wallet Selector

To get started with the Core SDK, refer to our [starting guide](https://github.com/keypom/keypom-js/tree/main/packages/core/README.md).

Similarly, a getting started guide for the Keypom Wallet Selector can be found [here](https://github.com/keypom/keypom-js/tree/main/packages/selector/README.md).

# Documentation

Visit our [documentation](https://docs.keypom.xyz/) for more information on the Keypom Protocol and the Keypom SDK.

# Contributing

First off, thanks for taking the time to contribute! Contributions are what makes the open-source community such an amazing place to learn, inspire, and create. Any contributions you make will benefit everybody else and are **greatly appreciated**.

Please try to create bug reports that are:

- _Reproducible._ Include steps to reproduce the problem.
- _Specific._ Include as much detail as possible: which version, what environment, etc.
- _Unique._ Do not duplicate existing opened issues.
- _Scoped to a Single Bug._ One bug per report.

You can use [markdownlint-cli](https://github.com/igorshubovych/markdownlint-cli) to check for common markdown style inconsistency.

# License

This project is licensed under the **GPL License**.
'''
'''--- package.json ---
{
  "name": "@keypom-js/monorepo",
  "author": "benkurrek, mattlockyer",
  "private": true,
  "engines": {
    "node": ">=16.14.0",
    "pnpm": ">=7"
  },
  "scripts": {
    "preinstall": "npx only-allow pnpm",
    "build": "turbo run build",
    "clean": "turbo run clean",
    "lint": "turbo run lint:ts",
    "lint:fix": "turbo run lint:ts:fix",
    "autoclave": "rimraf packages/**/dist && rimraf packages/**/lib && rimraf packages/**/node_modules && rimraf packages/**/coverage && rimraf packages/**/.turbo && rm -rf node_modules",
    "test": "turbo run test",
    "release": "changeset publish",
    "prepare": "husky install"
  },
  "devDependencies": {
    "@changesets/changelog-github": "^0.4.6",
    "@changesets/cli": "^2.24.4",
    "@commitlint/cli": "^17.0.3",
    "@commitlint/config-conventional": "^17.0.3",
    "@typescript-eslint/eslint-plugin": "^5.31.0",
    "@typescript-eslint/parser": "^5.31.0",
    "commitlint": "^17.0.3",
    "eslint": "^8.20.0",
    "husky": "^7.0.4",
    "rimraf": "^3.0.2",
    "turbo": "^1.4.5",
    "typescript": "^4.9.4",
    "typedoc": "^0.24.7"
  }
}

'''
'''--- packages/core/README.md ---
<p align="center">
  <a href="https://docs.keypom.xyz/">
    <picture>
      <img src="https://cloudflare-ipfs.com/ipfs/bafybeightypuoqly32gsrivh4efckhdv6wsefiynpnonlem6ts3ypgdm7e" height="128">
    </picture>
    <h1 align="center">Keypom Core SDK</h1>
  </a>
</p>

<p align="center">
  <a aria-label="Made by Ben Kurrek" href="https://github.com/BenKurrek">
    <img src="https://img.shields.io/badge/MADE%20BY-Ben%20Kurrek-000000.svg?style=for-the-badge">
  </a>
  <a aria-label="Made by Matt Lockyer" href="https://github.com/mattlockyer">
    <img src="https://img.shields.io/badge/MADE%20BY-Matt%20Lockyer-000000.svg?style=for-the-badge">
  </a>
  <a aria-label="License" href="https://github.com/keypom/keypom-js/blob/main/LICENSE">
    <img alt="" src="https://img.shields.io/badge/License-GNU%20GPL-green?style=for-the-badge">
  </a>
  <a aria-label="Join the community" href="https://t.me/+OqI-cKxQU05lZDIx">
    <img alt="" src="https://img.shields.io/badge/Join%20The-community-blueviolet.svg?style=for-the-badge">
  </a>
</p>

The core package serves as a way to interact with Keypom through a set of easy to use methods that abstract away the complexities of the protocol. The package includes ways to:
- Create drops of all kinds
- Claim drops
- Create and use trial accounts
- View information about drops and keys
- Delete drops and refund assets
- Manage user balances

# Table of Contents
- [Installation](#installation)
- [Getting Started](#getting-started)
  - [View Methods & Utility Functions Only](#view-methods--utility-functions-only)
  - [Funder Object](#funder-object)
  - [Customized KeyStore & Multiple Signers](#customized-keystore--multiple-signers)
- [Costs](#costs)
    - [Per Drop](#per-drop)
    - [Per Key](#per-key)
- [Contributing](#contributing)

---

# Installation

To install the Keypom Core SDK, run the following command:

```bash
npm install @keypom/core
# or
yarn add @keypom/core
# or
pnpm add @keypom/core
```

# Getting Started

The first thing you must *always* do when using the SDK is to call `initKeypom`. This will initialize the package state and establish a connection to the NEAR blockchain. 

By default, the SDK will create a new [InMemoryKeyStore](https://github.com/near/near-api-js/blob/master/packages/keystores/src/in_memory_key_store.ts) to sign transactions with. Thus, if you don't pass in a `funder` object, you won't be able to sign transactions and can only invoke utility and view methods. Alternatively, if you'd like to use a different keystore, you can pass in a customized `near` object to the initialization function.

With the SDK, every function that requires transactions to be signed can be carried through in 1 of two ways:
1. Passing in an [Account](https://github.com/near/near-api-js/blob/master/packages/accounts/src/account.ts) object into the function whose keys are kept in the SDK's keystore.
2. Passing in a `funder` object once during initialization whose keys will be kept in the SDK's [InMemoryKeyStore](https://github.com/near/near-api-js/blob/master/packages/keystores/src/in_memory_key_store.ts).

## View Methods & Utility Functions Only

If your only purpose is to query information from the chain or use Keypom's utility functions such as `generateKeys`, you don't need to pass in a `near` or `funder` object to `initKeypom`:

```js
await initKeypom({
    network: "testnet"
});

const keys = await generateKeys({
    numKeys: 1
})
console.log('keys: ', keys)

const dropSupply = await getKeyTotalSupply();
console.log('dropSupply: ', dropSupply)
```

## Funder Object

If you have the private key of an account that you'd like to use to sign transactions with, you can pass in a `funder` object to `initKeypom`. The private key can either be hardcoded or passed in through environment variables / secrets.

Using this method, you only need to pass the funder object once on initialization and can freely invoke any of the SDK methods moving forward. To update the funder object, you can call `updateFunder` and pass in different information.

```js
await initKeypom({
    network: "testnet",
    funder: {
        accountId: "benji_demo.testnet",
        secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
    }
});

const dropSupply = await getKeyTotalSupply();
console.log('dropSupply: ', dropSupply)

const {keys} = await createDrop({
    numKeys: 1,
    depositPerUseNEAR: 1
})
console.log('keys: ', keys)
```

## Customized KeyStore & Multiple Signers

Passing in a custom `near` object when initializing Keypom has several benefits as seen below:
- If you have multiple accounts that will be signing transactions and don't want to keep calling `updateFunder`.
- You don't want to hardcode the private key in the `funder` object.
- You have a keystore containing keys that will be used to sign transactions already in scope.

In this case, you can pass in an existing `near` object and then pass in `Account` objects when calling the SDK methods.

```js
let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  
let nearConfig = {
    networkId: NETWORK_ID,
    keyStore: keyStore,
    nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
    walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
    helperUrl: `https://helper.${NETWORK_ID}.near.org`,
    explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
};  
let near = new Near(nearConfig);

await initKeypom({
    near
});

const dropSupply = await getKeyTotalSupply();
console.log('dropSupply: ', dropSupply)

const fundingAccount = new Account(near.connection, funderAccountId);
const {keys} = await createDrop({
    account: fundingAccount,
    numKeys: 1,
    depositPerUseNEAR: 1
})
console.log('keys: ', keys)
```

# Costs

It is important to note that the Keypom contracts are 100% **FEE FREE** and will remain that way for the *forseeable future*. These contracts are a public good and are meant to inspire change in the NEAR ecosystem.

With that being said, there are several mandatory costs that must be taken into account when using Keypom. These costs are broken down into two categories: per key and per drop.

> **NOTE:** Creating an empty drop and then adding 100 keys in separate calls will incur the same cost as creating a drop with 100 keys in the same call.

## Per Drop

When creating an empty drop, there is only one cost to keep in mind regardless of the drop type:
- Storage cost (**~0.006 $NEAR** for simple drops)

## Per Key
Whenever keys are added to a drop (either when the drop is first created or at a later date), the costs are outlined below.

### Key Costs for Simple Drop

- $NEAR sent whenever the key is used (can be 0).
- Access key allowance (**~0.0187 $NEAR per use**).
- Storage for creating access key (**0.001 $NEAR**).
- Storage cost (**~0.006 $NEAR** for simple drops)

### Additional Costs for NFT Drops

Since keys aren't registered for use until **after** the contract has received the NFT, we don't know how much storage the token IDs will use on the contract. To combat this, the Keypom contract will automatically measure the storage used up for storing each token ID in the `nft_on_transfer` function and that $NEAR will be taken from the funder's balance.

### Additional Costs for FT Drops

Since accounts claiming FTs may or may not be registered on the Fungible Token contract, Keypom will automatically try to register **all** accounts. This means that the drop creators must front the cost of registering users depending on the `storage_balance_bounds` returned from the FT contract. This applies to every use for every key.

In addition, Keypom must be registered on the FT contract. If you create a FT drop and are the first person to ever do so for a specific FT contract on Keypom, Keypom will be automatically registered when the drop is created. This is a one time cost and once it is done, no other account will need to register Keypom for that specific FT contract.

### Additional Costs for FC Drops

Drop creators have a ton of customization available to them when creation Function Call drops. A cost that they might incur is the attached deposit being sent alongside the function call. Keypom will charge creators for all the attached deposits they specify.

> **NOTE:** The storage costs are dynamically calculated and will vary depending on the information you store on-chain.

# Contributing

First off, thanks for taking the time to contribute! Contributions are what makes the open-source community such an amazing place to learn, inspire, and create. Any contributions you make will benefit everybody else and are **greatly appreciated**.

Please try to create bug reports that are:

- _Reproducible._ Include steps to reproduce the problem.
- _Specific._ Include as much detail as possible: which version, what environment, etc.
- _Unique._ Do not duplicate existing opened issues.
- _Scoped to a Single Bug._ One bug per report.

You can use [markdownlint-cli](https://github.com/igorshubovych/markdownlint-cli) to check for common markdown style inconsistency.

# License

This project is licensed under the **GPL License**.
'''
'''--- packages/core/lib/index.d.ts ---
export { addToBalance, withdrawBalance } from "./lib/balances";
export { claim } from "./lib/claims";
export { createDrop, deleteDrops } from "./lib/drops";
export { 
/** @group Utility */
execute, getEnv, initKeypom, networks, accountMappingContract, supportedKeypomContracts, supportedLinkdropClaimPages, updateFunder, updateKeypomContractId } from "./lib/keypom";
export { viewAccessKeyData, generatePerUsePasswords, convertBasicTransaction, accountExists, createNFTSeries, estimateRequiredDeposit, formatLinkdropUrl, ftTransferCall, generateKeys, getFTMetadata, getNFTMetadata, getPubFromSecret, getStorageBase, hashPassword, nftTransferCall } from "./lib/keypom-utils";
export { addKeys, deleteKeys } from "./lib/keys";
export * from "./lib/sales";
export { claimTrialAccountDrop, createTrialAccountDrop } from "./lib/trial-accounts/pre-trial";
export { canExitTrial, trialCallMethod, trialSignAndSendTxns } from "./lib/trial-accounts/trial-active";
export { wrapTxnParamsForTrial, isUnclaimedTrialDrop, TRIAL_ERRORS } from "./lib/trial-accounts/utils";
export * from "./lib/types/drops";
export * from "./lib/types/fc";
export * from "./lib/types/ft";
export * from "./lib/types/general";
export * from "./lib/types/nft";
export * from "./lib/types/params";
export * from "./lib/types/protocol";
export * from "./lib/types/simple";
export * from "./lib/views";

'''
'''--- packages/core/lib/index.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TRIAL_ERRORS = exports.isUnclaimedTrialDrop = exports.wrapTxnParamsForTrial = exports.trialSignAndSendTxns = exports.trialCallMethod = exports.canExitTrial = exports.createTrialAccountDrop = exports.claimTrialAccountDrop = exports.deleteKeys = exports.addKeys = exports.nftTransferCall = exports.hashPassword = exports.getStorageBase = exports.getPubFromSecret = exports.getNFTMetadata = exports.getFTMetadata = exports.generateKeys = exports.ftTransferCall = exports.formatLinkdropUrl = exports.estimateRequiredDeposit = exports.createNFTSeries = exports.accountExists = exports.convertBasicTransaction = exports.generatePerUsePasswords = exports.viewAccessKeyData = exports.updateKeypomContractId = exports.updateFunder = exports.supportedLinkdropClaimPages = exports.supportedKeypomContracts = exports.accountMappingContract = exports.networks = exports.initKeypom = exports.getEnv = exports.execute = exports.deleteDrops = exports.createDrop = exports.claim = exports.withdrawBalance = exports.addToBalance = void 0;
var balances_1 = require("./lib/balances");
Object.defineProperty(exports, "addToBalance", { enumerable: true, get: function () { return balances_1.addToBalance; } });
Object.defineProperty(exports, "withdrawBalance", { enumerable: true, get: function () { return balances_1.withdrawBalance; } });
var claims_1 = require("./lib/claims");
Object.defineProperty(exports, "claim", { enumerable: true, get: function () { return claims_1.claim; } });
var drops_1 = require("./lib/drops");
Object.defineProperty(exports, "createDrop", { enumerable: true, get: function () { return drops_1.createDrop; } });
Object.defineProperty(exports, "deleteDrops", { enumerable: true, get: function () { return drops_1.deleteDrops; } });
var keypom_1 = require("./lib/keypom");
/** @group Utility */
Object.defineProperty(exports, "execute", { enumerable: true, get: function () { return keypom_1.execute; } });
Object.defineProperty(exports, "getEnv", { enumerable: true, get: function () { return keypom_1.getEnv; } });
Object.defineProperty(exports, "initKeypom", { enumerable: true, get: function () { return keypom_1.initKeypom; } });
Object.defineProperty(exports, "networks", { enumerable: true, get: function () { return keypom_1.networks; } });
Object.defineProperty(exports, "accountMappingContract", { enumerable: true, get: function () { return keypom_1.accountMappingContract; } });
Object.defineProperty(exports, "supportedKeypomContracts", { enumerable: true, get: function () { return keypom_1.supportedKeypomContracts; } });
Object.defineProperty(exports, "supportedLinkdropClaimPages", { enumerable: true, get: function () { return keypom_1.supportedLinkdropClaimPages; } });
Object.defineProperty(exports, "updateFunder", { enumerable: true, get: function () { return keypom_1.updateFunder; } });
Object.defineProperty(exports, "updateKeypomContractId", { enumerable: true, get: function () { return keypom_1.updateKeypomContractId; } });
var keypom_utils_1 = require("./lib/keypom-utils");
Object.defineProperty(exports, "viewAccessKeyData", { enumerable: true, get: function () { return keypom_utils_1.viewAccessKeyData; } });
Object.defineProperty(exports, "generatePerUsePasswords", { enumerable: true, get: function () { return keypom_utils_1.generatePerUsePasswords; } });
Object.defineProperty(exports, "convertBasicTransaction", { enumerable: true, get: function () { return keypom_utils_1.convertBasicTransaction; } });
Object.defineProperty(exports, "accountExists", { enumerable: true, get: function () { return keypom_utils_1.accountExists; } });
Object.defineProperty(exports, "createNFTSeries", { enumerable: true, get: function () { return keypom_utils_1.createNFTSeries; } });
Object.defineProperty(exports, "estimateRequiredDeposit", { enumerable: true, get: function () { return keypom_utils_1.estimateRequiredDeposit; } });
Object.defineProperty(exports, "formatLinkdropUrl", { enumerable: true, get: function () { return keypom_utils_1.formatLinkdropUrl; } });
Object.defineProperty(exports, "ftTransferCall", { enumerable: true, get: function () { return keypom_utils_1.ftTransferCall; } });
Object.defineProperty(exports, "generateKeys", { enumerable: true, get: function () { return keypom_utils_1.generateKeys; } });
Object.defineProperty(exports, "getFTMetadata", { enumerable: true, get: function () { return keypom_utils_1.getFTMetadata; } });
Object.defineProperty(exports, "getNFTMetadata", { enumerable: true, get: function () { return keypom_utils_1.getNFTMetadata; } });
Object.defineProperty(exports, "getPubFromSecret", { enumerable: true, get: function () { return keypom_utils_1.getPubFromSecret; } });
Object.defineProperty(exports, "getStorageBase", { enumerable: true, get: function () { return keypom_utils_1.getStorageBase; } });
Object.defineProperty(exports, "hashPassword", { enumerable: true, get: function () { return keypom_utils_1.hashPassword; } });
Object.defineProperty(exports, "nftTransferCall", { enumerable: true, get: function () { return keypom_utils_1.nftTransferCall; } });
var keys_1 = require("./lib/keys");
Object.defineProperty(exports, "addKeys", { enumerable: true, get: function () { return keys_1.addKeys; } });
Object.defineProperty(exports, "deleteKeys", { enumerable: true, get: function () { return keys_1.deleteKeys; } });
__exportStar(require("./lib/sales"), exports);
var pre_trial_1 = require("./lib/trial-accounts/pre-trial");
Object.defineProperty(exports, "claimTrialAccountDrop", { enumerable: true, get: function () { return pre_trial_1.claimTrialAccountDrop; } });
Object.defineProperty(exports, "createTrialAccountDrop", { enumerable: true, get: function () { return pre_trial_1.createTrialAccountDrop; } });
var trial_active_1 = require("./lib/trial-accounts/trial-active");
Object.defineProperty(exports, "canExitTrial", { enumerable: true, get: function () { return trial_active_1.canExitTrial; } });
Object.defineProperty(exports, "trialCallMethod", { enumerable: true, get: function () { return trial_active_1.trialCallMethod; } });
Object.defineProperty(exports, "trialSignAndSendTxns", { enumerable: true, get: function () { return trial_active_1.trialSignAndSendTxns; } });
var utils_1 = require("./lib/trial-accounts/utils");
Object.defineProperty(exports, "wrapTxnParamsForTrial", { enumerable: true, get: function () { return utils_1.wrapTxnParamsForTrial; } });
Object.defineProperty(exports, "isUnclaimedTrialDrop", { enumerable: true, get: function () { return utils_1.isUnclaimedTrialDrop; } });
Object.defineProperty(exports, "TRIAL_ERRORS", { enumerable: true, get: function () { return utils_1.TRIAL_ERRORS; } });
__exportStar(require("./lib/types/drops"), exports);
__exportStar(require("./lib/types/fc"), exports);
__exportStar(require("./lib/types/ft"), exports);
__exportStar(require("./lib/types/general"), exports);
__exportStar(require("./lib/types/nft"), exports);
__exportStar(require("./lib/types/params"), exports);
__exportStar(require("./lib/types/protocol"), exports);
__exportStar(require("./lib/types/simple"), exports);
__exportStar(require("./lib/views"), exports);

'''
'''--- packages/core/lib/lib/balances.d.ts ---
import { BrowserWalletBehaviour, Wallet } from '@near-wallet-selector/core/lib/wallet/wallet.types';
import { Account } from '@near-js/accounts';
type AnyWallet = BrowserWalletBehaviour | Wallet;
/**
 * Deposit some amount of $NEAR or yoctoNEAR$ into the Keypom contract. This amount can then be used to create drops or add keys without
 * Having to explicitly attach a deposit everytime. It can be thought of like a bank account.
 *
 * @example
 * Add 1 $NEAR to the account balance
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await addToBalance({
 *     amount: "1",
 * )};
 * ```
 * @group User Balance Functions
 */
export declare const addToBalance: ({ account, wallet, amountNear, amountYocto, successUrl, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /**
     * Amount of tokens to add but considering the decimal amount (non human-readable).
     * @example
     * Transferring one $NEAR should be passed in as "1000000000000000000000000" and NOT "1"
     */
    amountYocto?: string;
    /**
     * Human readable format for the amount of tokens to add.
     * @example
     * Example: transferring one $NEAR should be passed in as "1" and NOT "1000000000000000000000000"
     */
    amountNear?: string;
    /** When signing with a wallet, a success URl can be included that the user will be redirected to once the transaction has been successfully signed. */
    successUrl?: string;
}) => Promise<any>;
/**
 * Withdraw all the $NEAR from your balance in the Keypom contract.
 *
 * @example
 * Add 1 $NEAR to the account balance and then withdraw it
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await addToBalance({
 *     amount: "1",
 * });
 *
 * await withdrawBalance({});
 * ```
 * @group User Balance Functions
 */
export declare const withdrawBalance: ({ account, wallet, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
}) => Promise<any>;
export {};

'''
'''--- packages/core/lib/lib/balances.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.withdrawBalance = exports.addToBalance = void 0;
const checks_1 = require("./checks");
const keypom_1 = require("./keypom");
//import { Account } from "near-api-js";
const keypom_utils_1 = require("./keypom-utils");
const transactions_1 = require("@near-js/transactions");
/**
 * Deposit some amount of $NEAR or yoctoNEAR$ into the Keypom contract. This amount can then be used to create drops or add keys without
 * Having to explicitly attach a deposit everytime. It can be thought of like a bank account.
 *
 * @example
 * Add 1 $NEAR to the account balance
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await addToBalance({
 *     amount: "1",
 * )};
 * ```
 * @group User Balance Functions
 */
const addToBalance = ({ account, wallet, amountNear, amountYocto, successUrl, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { receiverId, execute, getAccount } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    const deposit = (0, keypom_utils_1.nearArgsToYocto)(amountNear, amountYocto);
    (0, checks_1.assert)(amountYocto != '0', 'Amount to add to balance cannot be 0.');
    const actions = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'add_to_balance',
            args: (0, transactions_1.stringifyJsonOrBytes)({}),
            gas: '100000000000000',
            deposit,
        },
    });
    const transactions = [
        {
            receiverId,
            actions,
        },
    ];
    return execute({ transactions, account, wallet, successUrl });
});
exports.addToBalance = addToBalance;
/**
 * Withdraw all the $NEAR from your balance in the Keypom contract.
 *
 * @example
 * Add 1 $NEAR to the account balance and then withdraw it
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await addToBalance({
 *     amount: "1",
 * });
 *
 * await withdrawBalance({});
 * ```
 * @group User Balance Functions
 */
const withdrawBalance = ({ account, wallet, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { receiverId, execute, getAccount } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    const actions = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'withdraw_from_balance',
            args: (0, transactions_1.stringifyJsonOrBytes)({}),
            gas: '100000000000000',
            deposit: '0'
        },
    });
    const transactions = [
        {
            receiverId,
            actions,
        },
    ];
    return execute({ transactions, account, wallet });
});
exports.withdrawBalance = withdrawBalance;

'''
'''--- packages/core/lib/lib/checks.d.ts ---
import { Account } from '@near-js/accounts';
import { Near } from '@near-js/wallet-account';
import { FCData } from './types/fc';
import { Funder } from './types/general';
import { ProtocolReturnedDropConfig } from './types/protocol';
export declare function isValidKeypomContract(keypomContractId: string): boolean;
export declare function isSupportedKeypomContract(keypomContractId: string): boolean;
export declare function isValidAccountObj(o: Account | undefined): o is Account;
export declare function isValidNearObject(o: Near): o is Near;
export declare function isValidFunderObject(o: Funder): o is Funder;
export declare const assert: (exp: any, m: any) => void;
export declare const assertValidDropConfig: (config?: ProtocolReturnedDropConfig) => void;
export declare const assertValidFCData: (fcData: FCData | undefined, usesPerKey: number) => void;
export declare const assertDropIdUnique: (dropId: string) => Promise<void>;

'''
'''--- packages/core/lib/lib/checks.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.assertDropIdUnique = exports.assertValidFCData = exports.assertValidDropConfig = exports.assert = exports.isValidFunderObject = exports.isValidNearObject = exports.isValidAccountObj = exports.isSupportedKeypomContract = exports.isValidKeypomContract = void 0;
const keypom_1 = require("./keypom");
function isValidKeypomContract(keypomContractId) {
    const { networkId } = (0, keypom_1.getEnv)();
    return keypom_1.supportedKeypomContracts[networkId][keypomContractId] !== undefined;
}
exports.isValidKeypomContract = isValidKeypomContract;
function isSupportedKeypomContract(keypomContractId) {
    const { networkId } = (0, keypom_1.getEnv)();
    return keypom_1.supportedKeypomContracts[networkId][keypomContractId] === true;
}
exports.isSupportedKeypomContract = isSupportedKeypomContract;
function isValidAccountObj(o) {
    if (o) {
        return (o.connection !== undefined &&
            o.accountId !== undefined);
    }
    return true;
}
exports.isValidAccountObj = isValidAccountObj;
function isValidNearObject(o) {
    return (o.connection !== undefined &&
        o.config !== undefined &&
        o.accountCreator !== undefined);
}
exports.isValidNearObject = isValidNearObject;
function isValidFunderObject(o) {
    return (o.accountId !== undefined &&
        o.secretKey !== undefined);
}
exports.isValidFunderObject = isValidFunderObject;
const assert = (exp, m) => {
    if (!exp) {
        throw new Error(m);
    }
};
exports.assert = assert;
const assertValidDropConfig = (config) => {
    var _a;
    (0, exports.assert)(((config === null || config === void 0 ? void 0 : config.uses_per_key) || 1) != 0, 'Cannot have 0 uses per key for a drop config');
    if ((_a = config === null || config === void 0 ? void 0 : config.usage) === null || _a === void 0 ? void 0 : _a.permissions) {
        (0, exports.assert)(config.usage.permissions == 'create_account_and_claim' ||
            config.usage.permissions == 'claim', 'Invalid permission type for usage. Must be \'create_account_and_claim\' or \'claim\'');
    }
    if (config === null || config === void 0 ? void 0 : config.time) {
        const currentBlockTimestamp = Date.now() * 1e6;
        if (config.time.interval != undefined) {
            (0, exports.assert)(config.time.start != undefined, 'If you want to set a claim interval, you must also set a start timestamp');
        }
        (0, exports.assert)((config.time.start || currentBlockTimestamp) >=
            currentBlockTimestamp, 'The start timestamp must be greater than the current block timestamp');
        exports.assert((config.time.end || currentBlockTimestamp) >= currentBlockTimestamp, 'The end timestamp must be greater than the current block timestamp');
        if (config.time.start != undefined && config.time.end != undefined) {
            (0, exports.assert)(config.time.start < config.time.end, 'The start timestamp must be less than the end timestamp');
        }
    }
};
exports.assertValidDropConfig = assertValidDropConfig;
const assertValidFCData = (fcData, usesPerKey) => {
    if (fcData === null || fcData === void 0 ? void 0 : fcData.methods) {
        const numMethodData = fcData.methods.length;
        if (usesPerKey == 1) {
            (0, exports.assert)(numMethodData == 1, 'Cannot have more Method Data than the number of uses per key');
        }
        else if (numMethodData > 1) {
            (0, exports.assert)(numMethodData == usesPerKey, 'Number of FCs must match number of uses per key if more than 1 is specified');
        }
        if (usesPerKey > 1 && numMethodData == 1) {
            (0, exports.assert)(fcData.methods[0] != undefined, 'cannot have a single none function call');
        }
        for (let i = 0; i < numMethodData; i++) {
            const methodsPerUse = fcData.methods[i];
            // Loop through each method in the methods per use
            if (methodsPerUse) {
                for (let j = 0; j < methodsPerUse.length; j++) {
                    const methodData = methodsPerUse[j];
                    if (methodData) {
                        (0, exports.assert)(methodData.methodName != undefined, 'Must specify a method name');
                        (0, exports.assert)(methodData.args != undefined, 'Must specify arguments for method');
                        (0, exports.assert)(typeof methodData.args == 'string', 'Arguments must be a string. If you want to pass a JSON object, stringify it first.');
                        (0, exports.assert)(methodData.receiverId != undefined, 'Must specify arguments for method');
                        (0, exports.assert)(isValidKeypomContract(methodData.receiverId) ===
                            false, 'Cannot have a keypom contract as the receiver');
                    }
                }
            }
        }
    }
};
exports.assertValidFCData = assertValidFCData;
const assertDropIdUnique = (dropId) => __awaiter(void 0, void 0, void 0, function* () {
    const { viewCall, contractId } = (0, keypom_1.getEnv)();
    try {
        const dropInfo = yield viewCall({
            contractId,
            methodName: 'get_drop_information',
            args: {
                drop_id: dropId,
            },
        });
        (0, exports.assert)(!dropInfo, `Drop with ID ${dropId} already exists. Please use a different drop ID.`);
    }
    catch (e) { }
});
exports.assertDropIdUnique = assertDropIdUnique;

'''
'''--- packages/core/lib/lib/claims.d.ts ---
import { Maybe } from './keypom';
/**
 * Allows a specific Keypom drop to be claimed via the secret key.
 *
 * @example
 * Creating a simple $NEAR drop and claiming to an existing account:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // create 1 keys with no entropy (random key)
 * const {publicKeys, secretKeys} = await generateKeys({
 * 	numKeys: 1
 * });
 *
 * // Create a simple drop with 1 $NEAR
 * await createDrop({
 * 	publicKeys,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Claim the drop to the passed in account ID
 * await claim({
 * 	secretKey: secretKeys[0],
 * 	accountId: "benjiman.testnet"
 * })
 * ```
 *
 * @example
 * Creating a simple $NEAR drop and using it to create a brand new NEAR account:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // create 2 keys with no entropy (all random). The first will be used for the drop and the second
 * // will be used as the full access key for the newly created account
 * const {publicKeys, secretKeys} = await generateKeys({
 * 	numKeys: 2
 * });
 *
 * // Create a simple drop with 1 $NEAR
 * await createDrop({
 * 	publicKeys: [publicKeys[0]],
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Claim the drop and create a new account
 * await claim({
 * 	secretKey: secretKeys[0],
 * 	newAccountId: "my-newly-creating-account.testnet",
 * 	newPublicKey: publicKeys[1]
 * })
 * ```
 *
 * @example
 * Creating a drop and adding a password to it. Generate the password using the hash function and pass it into claim the drop:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 *
 * const basePassword = "my-cool-password123";
 * // Create a simple drop with 1 $NEAR and pass in a base password to create a unique password for each use of each key
 * const {keys} = await createDrop({
 * 	numKeys: 1,
 * 	depositPerUseNEAR: 1,
 * 	basePassword
 * });
 *
 * // Create the password to pass into claim which is a hash of the basePassword, public key and whichever use we are on
 * let currentUse = 1;
 * let passwordForClaim = await hashPassword(basePassword + keys.publicKeys[0] + currentUse.toString());
 *
 * // Claim the drop to the passed in account ID and use the password we generated above.
 * await claim({
 * 	secretKey: keys.secretKeys[0],
 * 	accountId: "benjiman.testnet",
 * 	password: passwordForClaim
 * })
 * ```
 * @group Creating, And Claiming Drops
 */
export declare const claim: ({ secretKey, accountId, newAccountId, newPublicKey, password, fcArgs, }: {
    /** The private key associated with the Keypom link. This can either contain the `ed25519:` prefix or not. */
    secretKey: string;
    /** The account ID of an existing account that will be used to claim the drop. */
    accountId?: string;
    /** If passed in, a new account ID will be created and the drop will be claimed to that account. This must be an account that does not exist yet. */
    newAccountId?: string;
    /** If creating a new account, a public key must be passed in to be used as the full access key for the newly created account. */
    newPublicKey?: string;
    /** If a password is required to use the key, it can be passed in */
    password?: string;
    /** For FC drops, if `user_args_rule` is set by the funder, when claiming, custom arguments can be passed into the function. The number of args in the array need to match the number of methods being executed. */
    fcArgs?: Array<Maybe<string>>;
}) => Promise<any>;

'''
'''--- packages/core/lib/lib/claims.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.claim = void 0;
const crypto_1 = require("@near-js/crypto");
const checks_1 = require("./checks");
const transactions_1 = require("@near-js/transactions");
const keypom_1 = require("./keypom");
const keypom_utils_1 = require("./keypom-utils");
const views_1 = require("./views");
/**
 * Allows a specific Keypom drop to be claimed via the secret key.
 *
 * @example
 * Creating a simple $NEAR drop and claiming to an existing account:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // create 1 keys with no entropy (random key)
 * const {publicKeys, secretKeys} = await generateKeys({
 * 	numKeys: 1
 * });
 *
 * // Create a simple drop with 1 $NEAR
 * await createDrop({
 * 	publicKeys,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Claim the drop to the passed in account ID
 * await claim({
 * 	secretKey: secretKeys[0],
 * 	accountId: "benjiman.testnet"
 * })
 * ```
 *
 * @example
 * Creating a simple $NEAR drop and using it to create a brand new NEAR account:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // create 2 keys with no entropy (all random). The first will be used for the drop and the second
 * // will be used as the full access key for the newly created account
 * const {publicKeys, secretKeys} = await generateKeys({
 * 	numKeys: 2
 * });
 *
 * // Create a simple drop with 1 $NEAR
 * await createDrop({
 * 	publicKeys: [publicKeys[0]],
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Claim the drop and create a new account
 * await claim({
 * 	secretKey: secretKeys[0],
 * 	newAccountId: "my-newly-creating-account.testnet",
 * 	newPublicKey: publicKeys[1]
 * })
 * ```
 *
 * @example
 * Creating a drop and adding a password to it. Generate the password using the hash function and pass it into claim the drop:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 *
 * const basePassword = "my-cool-password123";
 * // Create a simple drop with 1 $NEAR and pass in a base password to create a unique password for each use of each key
 * const {keys} = await createDrop({
 * 	numKeys: 1,
 * 	depositPerUseNEAR: 1,
 * 	basePassword
 * });
 *
 * // Create the password to pass into claim which is a hash of the basePassword, public key and whichever use we are on
 * let currentUse = 1;
 * let passwordForClaim = await hashPassword(basePassword + keys.publicKeys[0] + currentUse.toString());
 *
 * // Claim the drop to the passed in account ID and use the password we generated above.
 * await claim({
 * 	secretKey: keys.secretKeys[0],
 * 	accountId: "benjiman.testnet",
 * 	password: passwordForClaim
 * })
 * ```
 * @group Creating, And Claiming Drops
 */
const claim = ({ secretKey, accountId, newAccountId, newPublicKey, password, fcArgs, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { networkId, keyStore, contractId, contractAccount, receiverId, execute, } = (0, keypom_1.getEnv)();
    const keyPair = crypto_1.KeyPair.fromString(secretKey);
    yield keyStore.setKey(networkId, contractId, keyPair);
    (0, checks_1.assert)(secretKey, 'A secretKey must be passed in.');
    (0, checks_1.assert)(!newAccountId || newPublicKey, 'If creating a new account, a newPublicKey must be passed in.');
    const dropInfo = yield (0, views_1.getDropInformation)({ secretKey });
    const attachedGas = dropInfo.required_gas;
    let curMethodData;
    if (dropInfo.fc) {
        curMethodData = yield (0, views_1.getCurMethodData)({ secretKey });
        if (curMethodData == null) {
            accountId = 'none';
        }
    }
    if (fcArgs) {
        (0, checks_1.assert)(dropInfo.fc, 'Cannot pass in fcArgs for non-FC drops.');
        (0, checks_1.assert)((curMethodData || []).length === fcArgs.length, 'The number of fcArgs must match the number of methods being executed.');
    }
    (0, checks_1.assert)(newAccountId || accountId, 'Either an accountId or newAccountId must be passed in.');
    const fcAction = newAccountId
        ? {
            methodName: 'create_account_and_claim',
            args: (0, transactions_1.stringifyJsonOrBytes)({
                new_account_id: newAccountId,
                new_public_key: newPublicKey,
                password,
                fc_args: fcArgs,
            }),
            gas: attachedGas,
            deposit: '0',
        }
        : {
            methodName: 'claim',
            args: (0, transactions_1.stringifyJsonOrBytes)({
                account_id: accountId,
                password,
                fc_args: fcArgs,
            }),
            gas: attachedGas,
            deposit: '0',
        };
    const txn = yield (0, keypom_utils_1.convertBasicTransaction)({
        txnInfo: {
            receiverId,
            signerId: contractId,
            actions: [
                {
                    enum: 'FunctionCall',
                    functionCall: fcAction,
                },
            ],
        },
        signerId: contractId,
        signerPk: keyPair.getPublicKey(),
    });
    const result = yield execute({
        transactions: [txn],
        account: contractAccount,
    });
    return result;
});
exports.claim = claim;

'''
'''--- packages/core/lib/lib/drops.d.ts ---
import { FinalExecutionOutcome } from '@near-wallet-selector/core';
import { BrowserWalletBehaviour, Wallet } from '@near-wallet-selector/core/lib/wallet/wallet.types';
import { Account } from '@near-js/accounts';
import { DropConfig } from './types/drops';
import { FCData } from './types/fc';
import { FTData } from './types/ft';
import { NFTData } from './types/nft';
import { CreateOrAddReturn } from './types/params';
import { ProtocolReturnedDrop } from './types/protocol';
import { SimpleData } from './types/simple';
type AnyWallet = BrowserWalletBehaviour | Wallet;
export declare const KEY_LIMIT = 50;
/**
 * Creates a new drop based on parameters passed in. This drop can have keys that are manually generated and passed in, or automatically generated. If they're
 * automatically generated, they can be based off a set of entropy. For NFT and FT drops, assets can automatically be sent to Keypom to register keys as part of the payload.
 * The deposit is estimated based on parameters that are passed in and the transaction can be returned instead of signed and sent to the network. This can allow you to get the
 * required deposit from the return value and use that to fund the account's Keypom balance to avoid multiple transactions being signed in the case of a drop with many keys.
 *
 * @return {Promise<CreateOrAddReturn>} Object containing: the drop ID, the responses of the execution, as well as any auto generated keys (if any).
 *
 * @example
 * Create a basic simple drop containing 10 keys each with 1 $NEAR. Each key is completely random:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create a drop with 10 completely random keys. The return value `keys` contains information about the generated keys
 * const {keys} = await createDrop({
 * 	numKeys: 10,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * console.log('public keys: ', keys.publicKeys);
 * console.log('private keys: ', keys.secretKeys);
 * ```
 *
 * @example
 * Init funder with root entropy and generate deterministic keys for a drop. Compare with manually generated keys:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. Root entropy is passed into the funder account so any generated keys
 * // Will be based off that entropy.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1",
 * 		rootEntropy: "my-global-secret-password"
 * 	}
 * });
 *
 * // Create a simple drop with 5 keys. Each key will be derived based on the rootEntropy of the funder, the drop ID, and key nonce.
 * const { keys: keysFromDrop, dropId } = await createDrop({
 * 	numKeys: 5,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Deterministically Generate the Private Keys:
 * const nonceDropIdMeta = Array.from({length: 5}, (_, i) => `${dropId}_${i}`);
 * const manualKeys = await generateKeys({
 * 	numKeys: 5,
 * 	rootEntropy: "my-global-secret-password",
 * 	metaEntropy: nonceDropIdMeta
 * })
 *
 * // Get the public and private keys from the keys generated by the drop
 * const {publicKeys, secretKeys} = keysFromDrop;
 * // Get the public and private keys from the keys that were manually generated
 * const {publicKeys: pubKeysGenerated, secretKeys: secretKeysGenerated} = manualKeys;
 * // These should match!
 * console.log('secretKeys: ', secretKeys)
 * console.log('secretKeysGenerated: ', secretKeysGenerated)
 *
 * // These should match!
 * console.log('publicKeys: ', publicKeys)
 * console.log('pubKeysGenerated: ', pubKeysGenerated)
 * ```
 *
 * @example
 * Use manually generated keys to create a drop:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Generate 10 random keys
 * const {publicKeys} = await generateKeys({
 * 	numKeys: 10
 * });
 *
 * // Create a drop using the keys that were generated. Since keys are passed in, the return value won't contain information about the keys.
 * await createDrop({
 * 	publicKeys,
 * 	depositPerUseNEAR: 1,
 * });
 * ```
 *
 * @example
 * Create a simple drop with 1 key and 1 use per key. This 1 use-key should be password protected based on a base-password:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 *
 * const basePassword = "my-cool-password123";
 * // Create a simple drop with 1 $NEAR and pass in a base password to create a unique password for each use of each key
 * const {keys} = await createDrop({
 * 	numKeys: 1,
 * 	depositPerUseNEAR: 1,
 * 	basePassword
 * });
 *
 * // Create the password to pass into claim which is a hash of the basePassword, public key and whichever use we are on
 * let currentUse = 1;
 * let passwordForClaim = await hashPassword(basePassword + keys.publicKeys[0] + currentUse.toString());
 * ```
 * @group Creating, And Claiming Drops
 */
export declare const createDrop: ({ account, wallet, dropId, numKeys, publicKeys, rootEntropy, depositPerUseNEAR, depositPerUseYocto, metadata, requiredGas, config, ftData, nftData, simpleData, fcData, basePassword, passwordProtectedUses, useBalance, returnTransactions, successUrl, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /**
     * Specify how many keys should be generated for the drop. If the funder has rootEntropy set OR rootEntropy is passed in, the keys will be
     * deterministically generated using the drop ID, key nonce, and entropy. Otherwise, each key will be generated randomly.
     * If this is not passed in, the publicKeys parameter *must* be passed in.
     */
    numKeys?: number;
    /** Pass in a custom set of publicKeys to add to the drop. If this is not passed in, keys will be generated based on the numKeys parameter. */
    publicKeys?: string[];
    /** How much $NEAR should be contained in each link. Unit in $NEAR (i.e `1` = 1 $NEAR) */
    depositPerUseNEAR?: number | string;
    /** How much $yoctoNEAR should be contained in each link. Unit in yoctoNEAR (1 yoctoNEAR = 1e-24 $NEAR) */
    depositPerUseYocto?: string;
    /** Specify a custom drop ID rather than using the incrementing nonce on the contract. */
    dropId?: string;
    /** Allows specific drop behaviors to be configured such as the number of uses each key / link will have. */
    config?: DropConfig;
    /** String of metadata to attach to the drop. This can be whatever you would like and is optional. Often this is stringified JSON. */
    metadata?: string;
    /** Allows you to overload how much gas should be attached to the transaction when the key is claimed. This should be in Gas units (1 TGas = 1000000000000). By default, 100 TGas is attached. */
    requiredGas?: string;
    /** For creating a simple drop, this contains necessary configurable information about the drop. */
    simpleData?: SimpleData;
    /** For creating a fungible token drop, this contains necessary configurable information about the drop. */
    ftData?: FTData;
    /** For creating a non-fungible token drop, this contains necessary configurable information about the drop. */
    nftData?: NFTData;
    /** For creating a function call drop, this contains necessary configurable information about the drop. */
    fcData?: FCData;
    /** Specify an entropy to use for generating keys (will overload the funder's rootEntropy if applicable). This parameter only matters if the publicKeys variable is not passed in. */
    rootEntropy?: string;
    /** For doing password protected drops, this is the base password that will be used to generate all the passwords. It will be double hashed with the public keys. If specified, by default, all key uses will have their own unique password unless passwordProtectedUses is passed in. */
    basePassword?: string;
    /** For doing password protected drops, specifies exactly which uses will be password protected. The uses are NOT zero indexed (i.e 1st use = 1). Each use will have a different, unique password generated via double hashing the base password + public key + key use. */
    passwordProtectedUses?: number[];
    /** If the account has a balance within the Keypom contract, set this to true to avoid the need to attach a deposit. If the account doesn't have enough balance, an error will throw. */
    useBalance?: boolean;
    /** If true, the transaction will be returned instead of being signed and sent. This is useful for getting the requiredDeposit from the return value without actually signing the transaction. */
    returnTransactions?: boolean;
    /** When signing with a wallet, a success URl can be included that the user will be redirected to once the transaction has been successfully signed. */
    successUrl?: string;
}) => Promise<CreateOrAddReturn>;
/**
 * Delete a set of drops and optionally withdraw any remaining balance you have on the Keypom contract.
 *
 * @example
 * Create 5 drops and delete each of them:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // loop to create 5 simple drops each with 5 more keys than the next
 * for(var i = 0; i < 5; i++) {
 * 	// create 10 keys with no entropy (all random)
 * 	const {publicKeys} = await generateKeys({
 * 		numKeys: 5 * (i+1) // First drop will have 5, then 10, then 15 etc..
 * 	});
 *
 * 	// Create the simple
 * 	await createDrop({
 * 		publicKeys,
 * 		depositPerUseNEAR: 1,
 * 	});
 * }
 *
 * let drops = await getDrops({accountId: "benji_demo.testnet"});
 * console.log('drops: ', drops)
 *
 * await deleteDrops({
 * 	drops
 * })
 *
 * 	// Get the number of drops the account has after deletion (should be zero)
 * 	const numDrops = await getDropSupply({
 * 		accountId: "benjiman.testnet"
 * });
 * console.log('numDrops: ', numDrops)
 * ```
 * @group Deleting State
 */
export declare const deleteDrops: ({ account, wallet, drops, dropIds, withdrawBalance, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** If the set of drop information for the drops you want to delete (from `getDropInformation` or `getDrops`) is already known to the client, it can be passed in instead of the drop IDs to reduce computation. */
    drops?: ProtocolReturnedDrop[];
    /** Specify a set of drop IDs to delete. */
    dropIds?: string[];
    /** Whether or not to withdraw any remaining balance on the Keypom contract. */
    withdrawBalance?: boolean;
}) => Promise<(void | FinalExecutionOutcome[])[][]>;
export {};

'''
'''--- packages/core/lib/lib/drops.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteDrops = exports.createDrop = exports.KEY_LIMIT = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const transactions_1 = require("@near-js/transactions");
const utils_1 = require("@near-js/utils");
const checks_1 = require("./checks");
const keypom_1 = require("./keypom");
const keypom_utils_1 = require("./keypom-utils");
const views_1 = require("./views");
exports.KEY_LIMIT = 50;
/**
 * Creates a new drop based on parameters passed in. This drop can have keys that are manually generated and passed in, or automatically generated. If they're
 * automatically generated, they can be based off a set of entropy. For NFT and FT drops, assets can automatically be sent to Keypom to register keys as part of the payload.
 * The deposit is estimated based on parameters that are passed in and the transaction can be returned instead of signed and sent to the network. This can allow you to get the
 * required deposit from the return value and use that to fund the account's Keypom balance to avoid multiple transactions being signed in the case of a drop with many keys.
 *
 * @return {Promise<CreateOrAddReturn>} Object containing: the drop ID, the responses of the execution, as well as any auto generated keys (if any).
 *
 * @example
 * Create a basic simple drop containing 10 keys each with 1 $NEAR. Each key is completely random:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create a drop with 10 completely random keys. The return value `keys` contains information about the generated keys
 * const {keys} = await createDrop({
 * 	numKeys: 10,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * console.log('public keys: ', keys.publicKeys);
 * console.log('private keys: ', keys.secretKeys);
 * ```
 *
 * @example
 * Init funder with root entropy and generate deterministic keys for a drop. Compare with manually generated keys:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. Root entropy is passed into the funder account so any generated keys
 * // Will be based off that entropy.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1",
 * 		rootEntropy: "my-global-secret-password"
 * 	}
 * });
 *
 * // Create a simple drop with 5 keys. Each key will be derived based on the rootEntropy of the funder, the drop ID, and key nonce.
 * const { keys: keysFromDrop, dropId } = await createDrop({
 * 	numKeys: 5,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Deterministically Generate the Private Keys:
 * const nonceDropIdMeta = Array.from({length: 5}, (_, i) => `${dropId}_${i}`);
 * const manualKeys = await generateKeys({
 * 	numKeys: 5,
 * 	rootEntropy: "my-global-secret-password",
 * 	metaEntropy: nonceDropIdMeta
 * })
 *
 * // Get the public and private keys from the keys generated by the drop
 * const {publicKeys, secretKeys} = keysFromDrop;
 * // Get the public and private keys from the keys that were manually generated
 * const {publicKeys: pubKeysGenerated, secretKeys: secretKeysGenerated} = manualKeys;
 * // These should match!
 * console.log('secretKeys: ', secretKeys)
 * console.log('secretKeysGenerated: ', secretKeysGenerated)
 *
 * // These should match!
 * console.log('publicKeys: ', publicKeys)
 * console.log('pubKeysGenerated: ', pubKeysGenerated)
 * ```
 *
 * @example
 * Use manually generated keys to create a drop:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Generate 10 random keys
 * const {publicKeys} = await generateKeys({
 * 	numKeys: 10
 * });
 *
 * // Create a drop using the keys that were generated. Since keys are passed in, the return value won't contain information about the keys.
 * await createDrop({
 * 	publicKeys,
 * 	depositPerUseNEAR: 1,
 * });
 * ```
 *
 * @example
 * Create a simple drop with 1 key and 1 use per key. This 1 use-key should be password protected based on a base-password:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 *
 * const basePassword = "my-cool-password123";
 * // Create a simple drop with 1 $NEAR and pass in a base password to create a unique password for each use of each key
 * const {keys} = await createDrop({
 * 	numKeys: 1,
 * 	depositPerUseNEAR: 1,
 * 	basePassword
 * });
 *
 * // Create the password to pass into claim which is a hash of the basePassword, public key and whichever use we are on
 * let currentUse = 1;
 * let passwordForClaim = await hashPassword(basePassword + keys.publicKeys[0] + currentUse.toString());
 * ```
 * @group Creating, And Claiming Drops
 */
const createDrop = ({ account, wallet, dropId, numKeys = 0, publicKeys, rootEntropy, depositPerUseNEAR, depositPerUseYocto, metadata, requiredGas, config = {}, ftData, nftData, simpleData = {}, fcData, basePassword, passwordProtectedUses, useBalance = false, returnTransactions = false, successUrl, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
    const { near, viewCall, gas, attachedGas, contractId, receiverId, getAccount, execute, fundingAccountDetails, } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    (0, checks_1.assert)((0, checks_1.isSupportedKeypomContract)(contractId) === true, 'Only the latest Keypom contract can be used to call this methods. Please update the contract.');
    (0, checks_1.assert)(publicKeys != undefined || numKeys != undefined, 'Must pass in either publicKeys or numKeys to create a drop.');
    /// parse args
    depositPerUseYocto = (0, keypom_utils_1.nearArgsToYocto)(depositPerUseNEAR, depositPerUseYocto);
    // Ensure that if the dropID is passed in, it's greater than 1 billion
    (0, checks_1.assert)(parseInt(dropId || '1000000000') >= 1000000000, 'All custom drop IDs must be greater than 1_000_000_000');
    if (!dropId)
        dropId = Date.now().toString();
    yield (0, checks_1.assertDropIdUnique)(dropId);
    const finalConfig = {
        uses_per_key: (config === null || config === void 0 ? void 0 : config.usesPerKey) || 1,
        time: config === null || config === void 0 ? void 0 : config.time,
        usage: {
            auto_delete_drop: ((_a = config === null || config === void 0 ? void 0 : config.usage) === null || _a === void 0 ? void 0 : _a.autoDeleteDrop) || false,
            auto_withdraw: (((_b = config === null || config === void 0 ? void 0 : config.usage) === null || _b === void 0 ? void 0 : _b.autoWithdraw) === true) || false,
            permissions: (_c = config === null || config === void 0 ? void 0 : config.usage) === null || _c === void 0 ? void 0 : _c.permissions,
            refund_deposit: (_d = config === null || config === void 0 ? void 0 : config.usage) === null || _d === void 0 ? void 0 : _d.refundDeposit,
            account_creation_fields: {
                account_id_field: (_f = (_e = config === null || config === void 0 ? void 0 : config.usage) === null || _e === void 0 ? void 0 : _e.accountCreationFields) === null || _f === void 0 ? void 0 : _f.accountIdField,
                drop_id_field: (_h = (_g = config === null || config === void 0 ? void 0 : config.usage) === null || _g === void 0 ? void 0 : _g.accountCreationFields) === null || _h === void 0 ? void 0 : _h.dropIdField,
                key_id_field: (_k = (_j = config === null || config === void 0 ? void 0 : config.usage) === null || _j === void 0 ? void 0 : _j.accountCreationFields) === null || _k === void 0 ? void 0 : _k.keyIdField,
                funder_id_field: (_m = (_l = config === null || config === void 0 ? void 0 : config.usage) === null || _l === void 0 ? void 0 : _l.accountCreationFields) === null || _m === void 0 ? void 0 : _m.funderIdField,
            },
        },
        sale: (config === null || config === void 0 ? void 0 : config.sale)
            ? {
                max_num_keys: (_o = config === null || config === void 0 ? void 0 : config.sale) === null || _o === void 0 ? void 0 : _o.maxNumKeys,
                price_per_key: ((_p = config === null || config === void 0 ? void 0 : config.sale) === null || _p === void 0 ? void 0 : _p.pricePerKeyYocto) ||
                    ((_q = config === null || config === void 0 ? void 0 : config.sale) === null || _q === void 0 ? void 0 : _q.pricePerKeyNEAR)
                    ? (0, utils_1.parseNearAmount)((_s = (_r = config === null || config === void 0 ? void 0 : config.sale) === null || _r === void 0 ? void 0 : _r.pricePerKeyNEAR) === null || _s === void 0 ? void 0 : _s.toString())
                    : undefined,
                allowlist: (_t = config === null || config === void 0 ? void 0 : config.sale) === null || _t === void 0 ? void 0 : _t.allowlist,
                blocklist: (_u = config === null || config === void 0 ? void 0 : config.sale) === null || _u === void 0 ? void 0 : _u.blocklist,
                auto_withdraw_funds: (_v = config === null || config === void 0 ? void 0 : config.sale) === null || _v === void 0 ? void 0 : _v.autoWithdrawFunds,
                start: (_w = config === null || config === void 0 ? void 0 : config.sale) === null || _w === void 0 ? void 0 : _w.start,
                end: (_x = config === null || config === void 0 ? void 0 : config.sale) === null || _x === void 0 ? void 0 : _x.end,
            }
            : undefined,
        root_account_id: config === null || config === void 0 ? void 0 : config.dropRoot,
    };
    (0, checks_1.assertValidDropConfig)(finalConfig);
    // If there are no publicKeys being passed in, we should generate our own based on the number of keys
    let keys;
    if (!publicKeys) {
        // Default root entropy is what is passed in. If there wasn't any, we should check if the funding account contains some.
        const rootEntropyUsed = rootEntropy || (fundingAccountDetails === null || fundingAccountDetails === void 0 ? void 0 : fundingAccountDetails.rootEntropy);
        // If either root entropy was passed into the function or the funder has some set, we should use that.
        if (rootEntropyUsed) {
            // Create an array of size numKeys with increasing strings from 0 -> numKeys - 1. Each element should also contain the dropId infront of the string
            const nonceDropIdMeta = Array.from({ length: numKeys }, (_, i) => `${dropId}_${i}`);
            keys = yield (0, keypom_utils_1.generateKeys)({
                numKeys,
                rootEntropy: rootEntropyUsed,
                metaEntropy: nonceDropIdMeta,
            });
        }
        else {
            // No entropy is provided so all keys should be fully random
            keys = yield (0, keypom_utils_1.generateKeys)({
                numKeys,
            });
        }
        publicKeys = keys.publicKeys;
    }
    numKeys = publicKeys.length;
    (0, checks_1.assert)(numKeys <= 100, 'Cannot add more than 100 keys at once');
    let passwords;
    if (basePassword) {
        (0, checks_1.assert)(numKeys <= 50, 'Cannot add more than 50 keys at once with passwords');
        // Generate the passwords with the base password and public keys. By default, each key will have a unique password for all of its uses unless passwordProtectedUses is passed in
        passwords = yield (0, keypom_utils_1.generatePerUsePasswords)({
            publicKeys: publicKeys,
            basePassword,
            uses: passwordProtectedUses ||
                Array.from({ length: (config === null || config === void 0 ? void 0 : config.usesPerKey) || 1 }, (_, i) => i + 1),
        });
    }
    let ftBalancePerUse;
    if (ftData) {
        ftBalancePerUse = (ftData === null || ftData === void 0 ? void 0 : ftData.absoluteAmount) || '0';
        if (ftData.amount) {
            const metadata = viewCall({
                contractId: ftData.contractId,
                methodName: 'ft_metadata',
            });
            ftBalancePerUse = (0, keypom_utils_1.parseFTAmount)(ftData.amount.toString(), metadata.decimals);
        }
    }
    (0, checks_1.assertValidFCData)(fcData, finalConfig.uses_per_key || 1);
    const createDropArgs = {
        drop_id: dropId,
        public_keys: publicKeys || [],
        deposit_per_use: depositPerUseYocto,
        config: finalConfig,
        metadata,
        required_gas: requiredGas,
        ft: (ftData === null || ftData === void 0 ? void 0 : ftData.contractId)
            ? {
                contract_id: ftData.contractId,
                sender_id: ftData.senderId,
                balance_per_use: ftBalancePerUse,
            }
            : undefined,
        nft: (nftData === null || nftData === void 0 ? void 0 : nftData.contractId)
            ? {
                contract_id: nftData.contractId,
                sender_id: nftData.senderId,
            }
            : undefined,
        fc: (fcData === null || fcData === void 0 ? void 0 : fcData.methods)
            ? {
                methods: fcData.methods.map((useMethods) => useMethods
                    ? useMethods.map((method) => {
                        const ret = {
                            receiver_id: method.receiverId,
                            method_name: method.methodName,
                            args: method.args,
                            attached_deposit: method.attachedDeposit,
                            attached_gas: method.attachedGas,
                            account_id_field: method.accountIdField,
                            drop_id_field: method.dropIdField,
                            key_id_field: method.keyIdField,
                            funder_id_field: method.funderIdField,
                            receiver_to_claimer: method.receiverToClaimer,
                            user_args_rule: method.userArgsRule,
                        };
                        return ret;
                    })
                    : undefined),
            }
            : undefined,
        simple: (simpleData === null || simpleData === void 0 ? void 0 : simpleData.lazyRegister)
            ? {
                lazy_register: simpleData.lazyRegister,
            }
            : undefined,
        passwords_per_use: passwords,
    };
    // If there is no ft data, nft data, or fc data, ensure the deposit per use is greater than 0
    if (createDropArgs.fc === undefined &&
        createDropArgs.ft === undefined &&
        createDropArgs.nft === undefined) {
        (0, checks_1.assert)(depositPerUseYocto != '0', 'Deposit per use must be greater than 0 for simple drops');
    }
    /// estimate required deposit
    const storageCalculated = (0, keypom_utils_1.getStorageBase)(createDropArgs);
    const requiredDeposit = yield (0, keypom_utils_1.estimateRequiredDeposit)({
        near: near,
        depositPerUse: depositPerUseYocto,
        numKeys,
        usesPerKey: finalConfig.uses_per_key || 1,
        attachedGas: parseInt(requiredGas || attachedGas),
        storage: storageCalculated,
        ftData,
        fcData,
    });
    let hasBalance = false;
    if (useBalance) {
        const userBal = new bn_js_1.default(yield (0, views_1.getUserBalance)({ accountId: account.accountId }));
        if (userBal.lt(new bn_js_1.default(requiredDeposit))) {
            throw new Error('Insufficient balance on Keypom to create drop. Use attached deposit instead.');
        }
        hasBalance = true;
    }
    const deposit = !hasBalance ? requiredDeposit : '0';
    let transactions = [];
    const pk = yield account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
    (0, checks_1.assert)(pk !== null, 'Could not get public key from signer. Ensure you have the key in the key store.');
    const txnInfo = {
        receiverId: receiverId,
        signerId: account.accountId,
        actions: [
            {
                enum: 'FunctionCall',
                functionCall: {
                    methodName: 'create_drop',
                    args: (0, transactions_1.stringifyJsonOrBytes)(createDropArgs),
                    gas: gas,
                    deposit,
                }
            },
        ],
    };
    transactions.push(yield (0, keypom_utils_1.convertBasicTransaction)({ txnInfo, signerId: account.accountId, signerPk: pk }));
    if ((ftData === null || ftData === void 0 ? void 0 : ftData.contractId) && (publicKeys === null || publicKeys === void 0 ? void 0 : publicKeys.length)) {
        transactions.push((yield (0, keypom_utils_1.ftTransferCall)({
            account: account,
            contractId: ftData.contractId,
            absoluteAmount: new bn_js_1.default(ftBalancePerUse)
                .mul(new bn_js_1.default(numKeys))
                .mul(new bn_js_1.default(finalConfig.uses_per_key))
                .toString(),
            dropId,
            returnTransaction: true,
        })));
    }
    const tokenIds = nftData === null || nftData === void 0 ? void 0 : nftData.tokenIds;
    if (nftData && tokenIds && (tokenIds === null || tokenIds === void 0 ? void 0 : tokenIds.length) > 0) {
        if (tokenIds.length > 2) {
            throw new Error('You can only automatically register 2 NFTs with \'createDrop\'. If you need to register more NFTs you can use the method \'nftTransferCall\' after you create the drop.');
        }
        const nftTXs = (yield (0, keypom_utils_1.nftTransferCall)({
            account: account,
            contractId: nftData.contractId,
            tokenIds,
            dropId: dropId.toString(),
            returnTransactions: true,
        }));
        transactions = transactions.concat(nftTXs);
    }
    if (returnTransactions) {
        return { keys, dropId, transactions, requiredDeposit };
    }
    const responses = yield execute({
        transactions,
        account,
        wallet,
        successUrl,
    });
    return { responses, keys, dropId, requiredDeposit };
});
exports.createDrop = createDrop;
/**
 * Delete a set of drops and optionally withdraw any remaining balance you have on the Keypom contract.
 *
 * @example
 * Create 5 drops and delete each of them:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // loop to create 5 simple drops each with 5 more keys than the next
 * for(var i = 0; i < 5; i++) {
 * 	// create 10 keys with no entropy (all random)
 * 	const {publicKeys} = await generateKeys({
 * 		numKeys: 5 * (i+1) // First drop will have 5, then 10, then 15 etc..
 * 	});
 *
 * 	// Create the simple
 * 	await createDrop({
 * 		publicKeys,
 * 		depositPerUseNEAR: 1,
 * 	});
 * }
 *
 * let drops = await getDrops({accountId: "benji_demo.testnet"});
 * console.log('drops: ', drops)
 *
 * await deleteDrops({
 * 	drops
 * })
 *
 * 	// Get the number of drops the account has after deletion (should be zero)
 * 	const numDrops = await getDropSupply({
 * 		accountId: "benjiman.testnet"
 * });
 * console.log('numDrops: ', numDrops)
 * ```
 * @group Deleting State
 */
const deleteDrops = ({ account, wallet, drops, dropIds, withdrawBalance = true, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { gas300, receiverId, execute, getAccount, contractId } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)((0, checks_1.isSupportedKeypomContract)(contractId) === true, 'Only the latest Keypom contract can be used to call this methods. Please update the contract.');
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    const pubKey = yield account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
    // If the drop information isn't passed in, we should get it from the drop IDs
    if (!drops) {
        if (!dropIds) {
            throw new Error('Must pass in either drops or dropIds');
        }
        // For each drop ID in drop IDs, get the drop information
        drops = [];
        yield Promise.all(yield dropIds.map((dropId) => __awaiter(void 0, void 0, void 0, function* () {
            drops === null || drops === void 0 ? void 0 : drops.push(yield (0, views_1.getDropInformation)({ dropId }));
        })));
    }
    const responses = yield Promise.all(drops.map(({ owner_id, drop_id, registered_uses, ft, nft }) => __awaiter(void 0, void 0, void 0, function* () {
        (0, checks_1.assert)(owner_id == account.accountId, 'Only the owner of the drop can delete drops.');
        let keySupply;
        let keys;
        const updateKeys = () => __awaiter(void 0, void 0, void 0, function* () {
            const keyPromises = [
                (() => __awaiter(void 0, void 0, void 0, function* () {
                    keySupply = yield (0, keypom_utils_1.keypomView)({
                        methodName: 'get_key_supply_for_drop',
                        args: {
                            drop_id: drop_id.toString(),
                        },
                    });
                }))(),
            ];
            keyPromises.push((() => __awaiter(void 0, void 0, void 0, function* () {
                keys = yield (0, keypom_utils_1.keypomView)({
                    methodName: 'get_keys_for_drop',
                    args: {
                        drop_id: drop_id.toString(),
                        from_index: '0',
                        limit: exports.KEY_LIMIT,
                    },
                });
            }))());
            yield Promise.all(keyPromises);
        });
        yield updateKeys();
        const responses = [];
        if (registered_uses !== 0 &&
            (ft !== undefined || nft !== undefined)) {
            const txn = yield (0, keypom_utils_1.convertBasicTransaction)({
                txnInfo: {
                    receiverId,
                    signerId: account.accountId,
                    actions: [
                        {
                            enum: 'FunctionCall',
                            functionCall: {
                                methodName: 'refund_assets',
                                args: (0, transactions_1.stringifyJsonOrBytes)({
                                    drop_id,
                                }),
                                gas: gas300,
                                deposit: '0'
                            },
                        },
                    ],
                },
                signerId: account.accountId,
                signerPk: pubKey
            });
            responses.push(...(yield execute({
                account,
                wallet,
                transactions: [txn],
            })));
        }
        const deleteKeys = () => __awaiter(void 0, void 0, void 0, function* () {
            const txn = yield (0, keypom_utils_1.convertBasicTransaction)({
                txnInfo: {
                    receiverId,
                    signerId: account.accountId,
                    actions: [
                        {
                            enum: 'FunctionCall',
                            functionCall: {
                                methodName: 'delete_keys',
                                args: (0, transactions_1.stringifyJsonOrBytes)({
                                    drop_id,
                                    public_keys: keys.map(keypom_utils_1.key2str),
                                }),
                                gas: gas300,
                                deposit: '0'
                            },
                        },
                    ],
                },
                signerId: account.accountId,
                signerPk: pubKey
            });
            responses.push(...(yield execute({
                account,
                wallet,
                transactions: [txn],
            })));
            if (keySupply > ((keys === null || keys === void 0 ? void 0 : keys.length) || 0)) {
                yield updateKeys();
                yield deleteKeys();
            }
        });
        yield deleteKeys();
        if (withdrawBalance) {
            const txn = yield (0, keypom_utils_1.convertBasicTransaction)({
                txnInfo: {
                    receiverId,
                    signerId: account.accountId,
                    actions: [
                        {
                            enum: 'FunctionCall',
                            functionCall: {
                                methodName: 'withdraw_from_balance',
                                args: (0, transactions_1.stringifyJsonOrBytes)({}),
                                gas: '50000000000000',
                                deposit: '0'
                            },
                        },
                    ],
                },
                signerId: account.accountId,
                signerPk: pubKey
            });
            responses.push(...(yield execute({
                account,
                wallet,
                transactions: [txn],
            })));
        }
        return responses;
    })));
    return responses;
});
exports.deleteDrops = deleteDrops;
// This should be done later. Very small number of drops will have lazy registrations enabled.
// /**
//  * Allows a user to register uses for a simple drop that has lazy registrations enabled. This drop can be over-registered.
//  *
//  * @param {Account=} account (OPTIONAL) If specified, the passed in account will be used to sign the txn instead of the funder account.
//  * @param {BrowserWalletBehaviour=} wallet (OPTIONAL) If using a browser wallet through wallet selector and that wallet should sign the transaction, pass it in.
//  * @param {string[]=} dropId Specify the drop ID of the drop you want to register uses on
//  *
//  * @example <caption>Create 5 drops and delete each of them</caption>
//  * ```js
//  * ```
// */
// export const registerUses = async ({
// 	account,
// 	wallet,
// 	dropId,
// 	numUses,
// 	useBalance = false,
// }: RegisterUsesParams) => {
// 	const {
// 		gas300, receiverId, execute, getAccount
// 	} = getEnv()
// 	account = await getAccount({ account, wallet });
// }

'''
'''--- packages/core/lib/lib/keypom-utils.d.ts ---
import { BrowserWalletBehaviour, Wallet } from '@near-wallet-selector/core/lib/wallet/wallet.types';
import { PasswordPerUse } from './types/drops';
import { FCData } from './types/fc';
import { FTData, FungibleTokenMetadata } from './types/ft';
import { BasicTransaction, GeneratedKeyPairs } from './types/general';
import { NonFungibleTokenMetadata, ProtocolReturnedNonFungibleTokenObject } from './types/nft';
import { CreateDropProtocolArgs } from './types/params';
import { PublicKey } from '@near-js/crypto';
import { Account, SignAndSendTransactionOptions } from '@near-js/accounts';
import { Near } from '@near-js/wallet-account';
import { FinalExecutionOutcome } from '@near-js/types';
import { Action, Transaction } from '@near-js/transactions';
type AnyWallet = BrowserWalletBehaviour | Wallet;
export declare const ATTACHED_GAS_FROM_WALLET = 100000000000000;
export declare const key2str: (v: any) => any;
/**
 * Get the public key from a given secret key.
 *
 * @param {string} secretKey - The secret key you wish to get the public key from
 *
 * @returns {Promise<string>} - The public key
 *
 * @example
 * ```js
 * const pubKey = getPubFromSecret("ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1");
 * console.log(pubKey);
 * ```
 * @group Utility
 */
export declare const getPubFromSecret: (secretKey: string) => string;
/**
 * Check whether or not a given account ID exists on the network.
 *
 * @param {string} accountId - The account ID you wish to check
 *
 * @returns {Promise<boolean>} - A boolean indicating whether or not the account exists
 *
 * @example
 * ```js
 * const accountExists = await accountExists("benji.near");
 * console.log(accountExists); // true
 * ```
 * @group Utility
 */
export declare const accountExists: (accountId: any) => Promise<boolean>;
/**
 * Get the NFT Object (metadata, owner, approval IDs etc.) for a given token ID on a given contract.
 *
 * @param {string} contractId - The contract ID of the NFT contract
 * @param {string} tokenId - The token ID of the NFT you wish to get the metadata for
 *
 * @returns {Promise<ProtocolReturnedNonFungibleTokenObject>} - The NFT Object
 *
 * @example
 * ```js
 * const nft = await getNFTMetadata({
 *     contractId: "nft.keypom.testnet",
 *     tokenId: "1"
 * });
 * console.log(nft);
 * ```
 * @group Utility
 */
export declare const getNFTMetadata: ({ contractId, tokenId, }: {
    contractId: string;
    tokenId: string;
}) => Promise<ProtocolReturnedNonFungibleTokenObject>;
/**
 * Get the FT Metadata for a given fungible token contract. This is used to display important information such as the icon for the token, decimal format etc.
 *
 * @param {string} contractId - The contract ID of the FT contract
 *
 * @returns {Promise<FungibleTokenMetadata>} - The FT Metadata
 *
 * @example
 * ```js
 * const ft = await getFTMetadata({
 *    contractId: "ft.keypom.testnet"
 * });
 * console.log(ft);
 * ```
 * @group Utility
 */
export declare const getFTMetadata: ({ contractId, }: {
    contractId: string;
}) => Promise<FungibleTokenMetadata>;
/**
 * Creates a new NFT series on the official Keypom Series contracts. This is for lazy minting NFTs as part of an FC drop.
 *
 * @example
 * Send 3 NFTs using the funder account (not passing in any accounts into the call):
 * ```js
 *	await initKeypom({
 *		// near,
 *		network: 'testnet',
 *		funder: {
 *			accountId,
 *			secretKey,
 *		}
 *	})
 *
 *	const {keys, dropId} = await createDrop({
 *		numKeys: 1,
 *		config: {
 *			usesPerKey: 100
 *		},
 *		metadata: "My Cool Drop Title!",
 *		depositPerUseNEAR: 0.5,
 *		fcData: {
 *			methods: [[
 *				{
 *					receiverId: `nft-v2.keypom.testnet`,
 *					methodName: "nft_mint",
 *					args: "",
 *					dropIdField: "mint_id",
 *					accountIdField: "receiver_id",
 *					attachedDeposit: parseNearAmount("0.1")
 *				}
 *			]]
 *		}
 *	})
 *
 *	const res = await createNFTSeries({
 *		dropId,
 *		metadata: {
 *			title: "Moon NFT!",
 *			description: "A cool NFT for the best dog in the world.",
 *			media: "bafybeibwhlfvlytmttpcofahkukuzh24ckcamklia3vimzd4vkgnydy7nq",
 *			copies: 500
 *		}
 *	});
 *	console.log('res: ', res)
 *
 *	const URLs = formatLinkdropUrl({
 *		baseUrl: "localhost:3000/claim",
 *		secretKeys: keys.secretKeys
 *	})
 *	console.log('URLs: ', URLs)
 * ```
 * @group Utility
 */
export declare const createNFTSeries: ({ account, wallet, dropId, metadata, royalty, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop that should have a series associated with it. */
    dropId: string;
    /** The metadata that all minted NFTs will have. */
    metadata: NonFungibleTokenMetadata;
    /** Any royalties associated with the series (as per official NEP-199 standard: https://github.com/near/NEPs/blob/master/neps/nep-0199.md) */
    royalty?: Map<string, number>;
}) => Promise<void | FinalExecutionOutcome[]>;
/**
 * Constructs a valid linkdrop URL for a given claim page or custom URL. To view the list of supported claim pages, see the exported `supportedLinkdropClaimPages` variable.
 *
 * @param {string | string[]} secretKeys - Either a single secret key or an array of secret keys that should be embedded in the linkdrop URLs.
 * @param {string=} claimPage - A valid reference to the claim page. See the exported `supportedLinkdropClaimPages` variable for a list of supported claim pages. If not provided, a custom base URL must be provided.
 * @param {string=} networkId - The network ID you wish to linkdrop on. If not provided, the current network that the SDK is connected to will be used.
 * @param {string=} contractId - The contract ID where the secret key belongs to. If not provided, the current contract ID that the SDK is connected to will be used.
 * @param {string=} customURL - A custom URL containing a `SECRET_KEY` string and `CONTRACT_ID` string for where to insert the secret key and contract ID. For example, a base URL of `foo.com/CONTRACT_ID#SECRET_KEY` with a contract `v2.keypom.near` and secret key `5CBLiJK21EQoB...` would result in `foo.com/v2.keypom.near#5CBLiJK21EQoB...`.
 *
 * @returns {string[]} - An array of the linkdrop URLs
 *
 * @example
 * Use the keypom claim page:
 * ```js
 * await initKeypom({
 *     network: 'testnet',
 *     funder: {
 *         accountId,
 *         secretKey,
 *     }
 * })
 *
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * const linkdropUrl = formatLinkdropUrl({
 *     claimPage: "keypom",
 *     contractId: "v2.keypom.testnet",
 *     secretKeys: keys.secretKeys[0] // Can be either the array or individual secret key string
 * })
 *
 * console.log('linkdropUrl: ', linkdropUrl)
 * ```
 * @example
 * Use a custom claim page with ONLY the secret key
 * ```js
 * await initKeypom({
 *     network: 'testnet',
 *     funder: {
 *         accountId,
 *         secretKey,
 *     }
 * })
 *
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * const linkdropUrl = formatLinkdropUrl({
 *     customURL: "foobar/SECRET_KEY/barfoo",
 *     contractId: "v2.keypom.testnet",
 *     secretKeys: keys.secretKeys[0] // Can be either the array or individual secret key string
 * })
 *
 * console.log('linkdropUrl: ', linkdropUrl)
 * ```
 * @example
 * Use a custom claim page with both the secret key and contract ID
 * ```js
 * await initKeypom({
 *     network: 'testnet',
 *     funder: {
 *         accountId,
 *         secretKey,
 *     }
 * })
 *
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * const linkdropUrl = formatLinkdropUrl({
 *     customURL: "foobar/SECRET_KEY/barfoo/CONTRACT_ID",
 *     contractId: "v2.keypom.testnet",
 *     secretKeys: keys.secretKeys[0] // Can be either the array or individual secret key string
 * })
 *
 * console.log('linkdropUrl: ', linkdropUrl)
 * ```
 * @group Utility
 */
export declare const formatLinkdropUrl: ({ claimPage, networkId, contractId, secretKeys, customURL, }: {
    claimPage?: string;
    networkId?: string;
    contractId?: string;
    secretKeys: string[] | string;
    customURL?: string;
}) => string[];
/**
 * Generate a sha256 hash of a passed in string. If the string is hex encoded, set the fromHex flag to true.
 *
 * @param {string} str - the string you wish to hash. By default, this should be utf8 encoded. If the string is hex encoded, set the fromHex flag to true.
 * @param {boolean} fromHex (OPTIONAL) - A flag that should be set if the string is hex encoded. Defaults to false.
 *
 * @returns {Promise<string>} - The resulting hash
 *
 * @example
 * Generating the required password to pass into `claim` given a base password:
 * ```js
 * 	// Create the password to pass into claim which is a hash of the basePassword, public key and whichever use we are on
 * let currentUse = 1;
 * let passwordForClaim = await hashPassword(basePassword + publicKey + currentUse.toString());
 * ```
 * @group Utility
 */
export declare const hashPassword: (str: string, fromHex?: boolean) => Promise<string>;
/**
 * Generate ed25519 KeyPairs that can be used for Keypom linkdrops, or full access keys to claimed accounts. These keys can optionally be derived from some entropy such as a root password and metadata pertaining to each key (user provided password etc.).
 * Entropy is useful for creating an onboarding experience where in order to recover a keypair, the client simply needs to provide the meta entropy (could be a user's password) and the secret root key like a UUID).
 *
 * @param {number} numKeys - The number of keys to generate
 * @param {string=} rootEntropy (OPTIONAL) - A root string that will be used as a baseline for all keys in conjunction with different metaEntropies (if provided) to deterministically generate a keypair. If not provided, the keypair will be completely random.
 * @param {string=} metaEntropy (OPTIONAL) - An array of entropies to use in conjunction with a base rootEntropy to deterministically generate the private keys. For single key generation, you can either pass in a string array with a single element, or simply
 pass in the string itself directly (not within an array).
 * @param {number=} autoMetaNonceStart (OPTIONAL) - Specify a starting index whereby the meta entropy will automatically increment by 1 for each key generated. This is to avoid having to pass in an array of meta entropy that simply increments by 1 each time.
 * This is very useful as auto key generation uses the drop ID, base password and key nonce. The drop ID and base password would be a constant and make up the root entropy and then the key nonce increments by 1 for each key generated.
 * @returns {Promise<GeneratedKeyPairs>} - An object containing an array of KeyPairs, Public Keys and Secret Keys.
 *
 * @example
 * Generating 10 unique random keypairs with no entropy:
 * ```js
 * // Generate 10 keys with no entropy (all random)
 * let keys = await generateKeys({
 *     numKeys: 10,
 * })
 *
 * let pubKey1 = keys.publicKeys[0];
 * let secretKey1 = keys.secretKeys[0];
 *
 * console.log('1st Public Key: ', pubKey1);
 * console.log('1st Secret Key: ', secretKey1)
 * ```
 *
 * @example
 * Generating 1 keypair based on entropy:
 * ```js
 * // Generate 1 key with the given entropy
 * let {publicKeys, secretKeys} = await generateKeys({
 *     numKeys: 1,
 *     rootEntropy: "my-global-password",
 *     metaEntropy: "user-password-123" // In this case, since there is only 1 key, the entropy can be an array of size 1 as well.
 * })
 *
 * let pubKey = publicKeys[0];
 * let secretKey = secretKeys[0];
 *
 * console.log('Public Key: ', pubKey);
 * console.log('Secret Key: ', secretKey)
 * ```
 *
 * @example
 * Generating 2 keypairs each with their own entropy:
 * ```js
 * // Generate 2 keys each with their own unique entropy
 * let keys = await generateKeys({
 *     numKeys: 2,
 *     rootEntropy: "my-global-password",
 *     metaEntropy: [
 *        `first-password:0`,
 *        `second-password:1`
 *    ]
 * })
 *
 * console.log('Pub Keys ', keys.publicKeys);
 * console.log('Secret Keys ', keys.secretKeys);
 * ```
 *  * @example
 * Generate 50 keys exactly how the auto key generation would in createDrop and addKeys:
 * ```js
 * const dropId = '1676913490360';
 * const basePassword = "my-password";
 * // Generate 50 keys each with their own unique entropy
 * let keys = await generateKeys({
 *     numKeys: 50,
 *     rootEntropy: `${basePassword}-${dropId}`,
 *     autoMetaNonceStart: 0
 * })
 *
 * console.log('Pub Keys ', keys.publicKeys);
 * console.log('Secret Keys ', keys.secretKeys);
 * ```
 * @group Utility
 */
export declare const generateKeys: ({ numKeys, rootEntropy, metaEntropy, autoMetaNonceStart, }: {
    /** The number of keys to generate. */
    numKeys: number;
    /** A root string that will be used as a baseline for all keys in conjunction with different metaEntropies (if provided) to deterministically generate a keypair. If not provided, the keypair will be completely random. */
    rootEntropy?: string;
    /** An array of entropies to use in conjunction with a base rootEntropy to deterministically generate the private keys. For single key generation, you can either pass in a string array with a single element, or simply
 pass in the string itself directly (not within an array). */
    metaEntropy?: string[] | string;
    autoMetaNonceStart?: number;
}) => Promise<GeneratedKeyPairs>;
export declare const keypomView: ({ methodName, args }: {
    methodName: any;
    args: any;
}) => Promise<any>;
/**
 * Query for important access key data such as the nonce, allowance, method names etc. that is stored on the NEAR protocol for a given account and public key.
 *
 * @example
 * Check if an access key belongs to a trial account
 * ```js
 * const keyInfo = await viewAccessKeyData({accountId, secretKey});
 * let keyPerms = keyInfo.permission.FunctionCall;
 * isValidTrialInfo = keyPerms.receiver_id === accountId && keyPerms.method_names.includes('execute')
 * console.log('isValidTrialInfo: ', isValidTrialInfo)
 * ```
 * @group Utility
 */
export declare const viewAccessKeyData: ({ accountId, publicKey, secretKey, }: {
    /** The account that the access key belongs to. */
    accountId: string;
    /** The secret key of the access key */
    secretKey?: string;
    /** The public key of the access key */
    publicKey?: string;
}) => Promise<any>;
/** @group Utility */
export declare const execute: ({ transactions, account, wallet, fundingAccount, successUrl, }: {
    transactions: Transaction[];
    account: Account;
    wallet?: Wallet;
    fundingAccount?: Account;
    successUrl?: string;
}) => Promise<void | FinalExecutionOutcome[] | Array<void | FinalExecutionOutcome>>;
/**
 * For FT Drops, keys need to be registered before they can be used. This is done via the `ft_transfer_call` method on the FT contract.
 * This is a convenience method to make that process easier.
 *
 * @example
 * Send FTs using the funder account (not passing in any accounts into the call):
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await ftTransferCall({
 *     contractId: "ft.keypom.testnet",
 *     amount: "1",
 *     dropId: "1231231",
 * )};
 * ```
 * @group Registering Key Uses
 */
export declare const ftTransferCall: ({ account, wallet, contractId, absoluteAmount, amount, dropId, returnTransaction, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The fungible token contract ID. */
    contractId: string;
    /** Amount of tokens to transfer but considering the decimal amount (non human-readable).
     *  Example: transferring one wNEAR should be passed in as "1000000000000000000000000" and NOT "1"
     */
    absoluteAmount?: string;
    /**
     * Human readable format for the amount of tokens to transfer.
     * Example: transferring one wNEAR should be passed in as "1" and NOT "1000000000000000000000000"
     */
    amount?: string;
    /** The drop ID to register the keys for. */
    dropId: string;
    /** If true, the transaction will be returned instead of being signed and sent. */
    returnTransaction?: boolean;
}) => Promise<Promise<void | FinalExecutionOutcome[]> | Transaction>;
/**
 * For NFT Drops, keys need to be registered before they can be used. This is done via the `nft_transfer_call` method on the NFT contract.
 * This is a convenience method to make that process easier.
 *
 * @param {Account=} account (OPTIONAL) If specified, the passed in account will be used to sign the txn instead of the funder account.
 * @param {BrowserWalletBehaviour=} wallet (OPTIONAL) If using a browser wallet through wallet selector and that wallet should sign the transaction, pass it in.
 * @param {string} contractId The non-fungible token contract ID.
 * @param {string[]} tokenIds A set of token IDs that should be sent to the Keypom contract in order to register keys.
 * @param {string} dropId The drop ID to register the keys for.
 * @param {boolean=} returnTransaction (OPTIONAL) If true, the transaction will be returned instead of being signed and sent.
 *
 * @example
 * Send 3 NFTs using the funder account (not passing in any accounts into the call):
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await nftTransferCall({
 *     contractId: "nft.keypom.testnet",
 *     tokenIds: ["1", "2", "3],
 *     dropId: "1231231",
 * )};
 * ```
 * @group Registering Key Uses
 */
export declare const nftTransferCall: ({ account, wallet, contractId, tokenIds, dropId, returnTransactions, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The non-fungible token contract ID. */
    contractId: string;
    /** A set of token IDs that should be sent to the Keypom contract in order to register keys. */
    tokenIds: string[];
    /** The drop ID to register the keys for. */
    dropId: string;
    /** If true, the transaction will be returned instead of being signed and sent. */
    returnTransactions?: boolean;
}) => Promise<Array<void | FinalExecutionOutcome[]> | Transaction[]>;
export declare const parseFTAmount: (amt: string, decimals: number) => string;
export declare const transformTransactions: (transactions: Transaction[]) => SignAndSendTransactionOptions[];
export declare const createAction: (action: Action) => Action;
/** @group Utility */
export declare const getStorageBase: ({ public_keys, deposit_per_use, drop_id, config, metadata, simple, ft, nft, fc, passwords_per_use, }: CreateDropProtocolArgs) => string;
/** Initiate the connection to the NEAR blockchain. @group Utility */
export declare const estimateRequiredDeposit: ({ near, depositPerUse, numKeys, usesPerKey, attachedGas, storage, keyStorage, fcData, ftData, }: {
    /** The NEAR connection instance used to interact with the chain. This can either the connection that the SDK uses from `getEnv` or a separate connection. */
    near: Near;
    /** How much yoctoNEAR each key will transfer upon use. */
    depositPerUse: string;
    /** How many keys are being added to the drop. */
    numKeys: number;
    /** How many uses each key has. */
    usesPerKey: number;
    /** How much Gas will be attached to each key's use. */
    attachedGas: number;
    /** The estimated storage costs (can be retrieved through `getStorageBase`). */
    storage?: string | null;
    /** How much storage an individual key uses. */
    keyStorage?: string | null;
    /** The FC data for the drop that is being created. */
    fcData?: FCData;
    /** The FT data for the drop that is being created. */
    ftData?: FTData;
}) => Promise<string>;
/**
 * Generate passwords for a set of public keys. A unique password will be created for each specified use of a public key where the use is NOT zero indexed (i.e 1st use = 1).
 * The passwords will be generated via a double hash of the base password + public key + specific use
 *
 * @param {string[]} publicKeys The public keys that will be used to generate the set of passwords
 * @param {string[]} uses An array of numbers that dictate which uses should be password protected. The 1st use of a key is 1 (NOT zero indexed).
 * @param {string=} basePassword All the passwords will be generated from this base password. It will be double hashed with the public key.
 *
 * @returns {Promise<Array<Array<PasswordPerUse>>>} An array of objects for each key where each object has a password and maps it to its specific key use.
 * @group Utility
 */
export declare function generatePerUsePasswords({ publicKeys, uses, basePassword, }: {
    publicKeys: string[];
    uses: number[];
    basePassword: string;
}): Promise<Array<Array<PasswordPerUse>>>;
export declare const snakeToCamel: (str: any) => any;
export declare const toCamel: (o: any) => any;
export declare const nearArgsToYocto: (nearAmount?: string | number, yoctoAmount?: string) => string;
export declare const convertBasicTransaction: ({ txnInfo, signerId, signerPk }: {
    txnInfo: BasicTransaction;
    signerId: string;
    signerPk: PublicKey;
}) => Promise<Transaction>;
export declare const createTransactions: ({ txnInfos, signerId, signerPk }: {
    txnInfos: BasicTransaction[];
    signerId: string;
    signerPk: PublicKey;
}) => Promise<Transaction[]>;
export {};

'''
'''--- packages/core/lib/lib/keypom-utils.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createTransactions = exports.convertBasicTransaction = exports.nearArgsToYocto = exports.toCamel = exports.snakeToCamel = exports.generatePerUsePasswords = exports.estimateRequiredDeposit = exports.getStorageBase = exports.createAction = exports.transformTransactions = exports.parseFTAmount = exports.nftTransferCall = exports.ftTransferCall = exports.execute = exports.viewAccessKeyData = exports.keypomView = exports.generateKeys = exports.hashPassword = exports.formatLinkdropUrl = exports.createNFTSeries = exports.getFTMetadata = exports.getNFTMetadata = exports.accountExists = exports.getPubFromSecret = exports.key2str = exports.ATTACHED_GAS_FROM_WALLET = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const near_seed_phrase_1 = require("near-seed-phrase");
const checks_1 = require("./checks");
const keypom_1 = require("./keypom");
const crypto_1 = require("@near-js/crypto");
const accounts_1 = require("@near-js/accounts");
const utils_1 = require("@near-js/utils");
const transactions_1 = require("@near-js/transactions");
const borsh_1 = require("borsh");
const util_1 = require("util");
let sha256Hash;
// @ts-ignore
if (typeof crypto === 'undefined') {
    const nodeCrypto = require('crypto');
    sha256Hash = (ab) => nodeCrypto.createHash('sha256').update(ab).digest();
}
else {
    // @ts-ignore
    sha256Hash = (ab) => crypto.subtle.digest('SHA-256', ab);
}
/// How much Gas each each cross contract call with cost to be converted to a receipt
const GAS_PER_CCC = 5000000000000; // 5 TGas
const RECEIPT_GAS_COST = 2500000000000; // 2.5 TGas
const YOCTO_PER_GAS = 100000000; // 100 million
exports.ATTACHED_GAS_FROM_WALLET = 100000000000000; // 100 TGas
/// How much yoctoNEAR it costs to store 1 access key
const ACCESS_KEY_STORAGE = new bn_js_1.default('1000000000000000000000');
const key2str = (v) => (typeof v === 'string' ? v : v.pk);
exports.key2str = key2str;
const hashBuf = (str, fromHex = false) => sha256Hash(Buffer.from(str, fromHex ? 'hex' : 'utf8'));
/**
 * Get the public key from a given secret key.
 *
 * @param {string} secretKey - The secret key you wish to get the public key from
 *
 * @returns {Promise<string>} - The public key
 *
 * @example
 * ```js
 * const pubKey = getPubFromSecret("ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1");
 * console.log(pubKey);
 * ```
 * @group Utility
 */
const getPubFromSecret = (secretKey) => {
    const keyPair = crypto_1.KeyPair.fromString(secretKey);
    return keyPair.getPublicKey().toString();
};
exports.getPubFromSecret = getPubFromSecret;
/**
 * Check whether or not a given account ID exists on the network.
 *
 * @param {string} accountId - The account ID you wish to check
 *
 * @returns {Promise<boolean>} - A boolean indicating whether or not the account exists
 *
 * @example
 * ```js
 * const accountExists = await accountExists("benji.near");
 * console.log(accountExists); // true
 * ```
 * @group Utility
 */
const accountExists = (accountId) => __awaiter(void 0, void 0, void 0, function* () {
    const { connection } = (0, keypom_1.getEnv)();
    try {
        const account = new accounts_1.Account(connection, accountId);
        yield account.state();
        return true;
    }
    catch (e) {
        if (!/no such file|does not exist/.test(e.toString())) {
            throw e;
        }
        return false;
    }
});
exports.accountExists = accountExists;
/**
 * Get the NFT Object (metadata, owner, approval IDs etc.) for a given token ID on a given contract.
 *
 * @param {string} contractId - The contract ID of the NFT contract
 * @param {string} tokenId - The token ID of the NFT you wish to get the metadata for
 *
 * @returns {Promise<ProtocolReturnedNonFungibleTokenObject>} - The NFT Object
 *
 * @example
 * ```js
 * const nft = await getNFTMetadata({
 *     contractId: "nft.keypom.testnet",
 *     tokenId: "1"
 * });
 * console.log(nft);
 * ```
 * @group Utility
 */
const getNFTMetadata = ({ contractId, tokenId, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { viewCall } = (0, keypom_1.getEnv)();
    const res = yield viewCall({
        contractId,
        methodName: 'nft_token',
        args: {
            token_id: tokenId,
        },
    });
    return res;
});
exports.getNFTMetadata = getNFTMetadata;
/**
 * Get the FT Metadata for a given fungible token contract. This is used to display important information such as the icon for the token, decimal format etc.
 *
 * @param {string} contractId - The contract ID of the FT contract
 *
 * @returns {Promise<FungibleTokenMetadata>} - The FT Metadata
 *
 * @example
 * ```js
 * const ft = await getFTMetadata({
 *    contractId: "ft.keypom.testnet"
 * });
 * console.log(ft);
 * ```
 * @group Utility
 */
const getFTMetadata = ({ contractId, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { viewCall } = (0, keypom_1.getEnv)();
    const res = yield viewCall({
        contractId,
        methodName: 'ft_metadata',
        args: {},
    });
    return res;
});
exports.getFTMetadata = getFTMetadata;
/**
 * Creates a new NFT series on the official Keypom Series contracts. This is for lazy minting NFTs as part of an FC drop.
 *
 * @example
 * Send 3 NFTs using the funder account (not passing in any accounts into the call):
 * ```js
 *	await initKeypom({
 *		// near,
 *		network: 'testnet',
 *		funder: {
 *			accountId,
 *			secretKey,
 *		}
 *	})
 *
 *	const {keys, dropId} = await createDrop({
 *		numKeys: 1,
 *		config: {
 *			usesPerKey: 100
 *		},
 *		metadata: "My Cool Drop Title!",
 *		depositPerUseNEAR: 0.5,
 *		fcData: {
 *			methods: [[
 *				{
 *					receiverId: `nft-v2.keypom.testnet`,
 *					methodName: "nft_mint",
 *					args: "",
 *					dropIdField: "mint_id",
 *					accountIdField: "receiver_id",
 *					attachedDeposit: parseNearAmount("0.1")
 *				}
 *			]]
 *		}
 *	})
 *
 *	const res = await createNFTSeries({
 *		dropId,
 *		metadata: {
 *			title: "Moon NFT!",
 *			description: "A cool NFT for the best dog in the world.",
 *			media: "bafybeibwhlfvlytmttpcofahkukuzh24ckcamklia3vimzd4vkgnydy7nq",
 *			copies: 500
 *		}
 *	});
 *	console.log('res: ', res)
 *
 *	const URLs = formatLinkdropUrl({
 *		baseUrl: "localhost:3000/claim",
 *		secretKeys: keys.secretKeys
 *	})
 *	console.log('URLs: ', URLs)
 * ```
 * @group Utility
 */
const createNFTSeries = ({ account, wallet, dropId, metadata, royalty, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { getAccount, networkId } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    const actualMetadata = {
        title: metadata.title,
        description: metadata.description,
        media: metadata.media,
        media_hash: metadata.mediaHash,
        copies: metadata.copies,
        issued_at: metadata.issuedAt,
        expires_at: metadata.expiresAt,
        starts_at: metadata.startsAt,
        updated_at: metadata.updatedAt,
        extra: metadata.extra,
        reference: metadata.reference,
        reference_hash: metadata.referenceHash,
    };
    const nftSeriesAccount = networkId == 'testnet' ? 'nft-v2.keypom.testnet' : 'nft-v2.keypom.near';
    const pk = yield account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
    const txnInfo = {
        receiverId: nftSeriesAccount,
        signerId: account.accountId,
        actions: [
            {
                enum: 'FunctionCall',
                functionCall: {
                    methodName: 'create_series',
                    args: (0, transactions_1.stringifyJsonOrBytes)({
                        mint_id: parseInt(dropId),
                        metadata: actualMetadata,
                        royalty,
                    }),
                    gas: '50000000000000',
                    deposit: (0, utils_1.parseNearAmount)('0.25'),
                }
            },
        ],
    };
    const transaction = yield (0, exports.convertBasicTransaction)({ txnInfo, signerId: account.accountId, signerPk: pk });
    return (0, exports.execute)({ account: account, transactions: [transaction] });
});
exports.createNFTSeries = createNFTSeries;
/**
 * Constructs a valid linkdrop URL for a given claim page or custom URL. To view the list of supported claim pages, see the exported `supportedLinkdropClaimPages` variable.
 *
 * @param {string | string[]} secretKeys - Either a single secret key or an array of secret keys that should be embedded in the linkdrop URLs.
 * @param {string=} claimPage - A valid reference to the claim page. See the exported `supportedLinkdropClaimPages` variable for a list of supported claim pages. If not provided, a custom base URL must be provided.
 * @param {string=} networkId - The network ID you wish to linkdrop on. If not provided, the current network that the SDK is connected to will be used.
 * @param {string=} contractId - The contract ID where the secret key belongs to. If not provided, the current contract ID that the SDK is connected to will be used.
 * @param {string=} customURL - A custom URL containing a `SECRET_KEY` string and `CONTRACT_ID` string for where to insert the secret key and contract ID. For example, a base URL of `foo.com/CONTRACT_ID#SECRET_KEY` with a contract `v2.keypom.near` and secret key `5CBLiJK21EQoB...` would result in `foo.com/v2.keypom.near#5CBLiJK21EQoB...`.
 *
 * @returns {string[]} - An array of the linkdrop URLs
 *
 * @example
 * Use the keypom claim page:
 * ```js
 * await initKeypom({
 *     network: 'testnet',
 *     funder: {
 *         accountId,
 *         secretKey,
 *     }
 * })
 *
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * const linkdropUrl = formatLinkdropUrl({
 *     claimPage: "keypom",
 *     contractId: "v2.keypom.testnet",
 *     secretKeys: keys.secretKeys[0] // Can be either the array or individual secret key string
 * })
 *
 * console.log('linkdropUrl: ', linkdropUrl)
 * ```
 * @example
 * Use a custom claim page with ONLY the secret key
 * ```js
 * await initKeypom({
 *     network: 'testnet',
 *     funder: {
 *         accountId,
 *         secretKey,
 *     }
 * })
 *
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * const linkdropUrl = formatLinkdropUrl({
 *     customURL: "foobar/SECRET_KEY/barfoo",
 *     contractId: "v2.keypom.testnet",
 *     secretKeys: keys.secretKeys[0] // Can be either the array or individual secret key string
 * })
 *
 * console.log('linkdropUrl: ', linkdropUrl)
 * ```
 * @example
 * Use a custom claim page with both the secret key and contract ID
 * ```js
 * await initKeypom({
 *     network: 'testnet',
 *     funder: {
 *         accountId,
 *         secretKey,
 *     }
 * })
 *
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * const linkdropUrl = formatLinkdropUrl({
 *     customURL: "foobar/SECRET_KEY/barfoo/CONTRACT_ID",
 *     contractId: "v2.keypom.testnet",
 *     secretKeys: keys.secretKeys[0] // Can be either the array or individual secret key string
 * })
 *
 * console.log('linkdropUrl: ', linkdropUrl)
 * ```
 * @group Utility
 */
const formatLinkdropUrl = ({ claimPage, networkId, contractId, secretKeys, customURL, }) => {
    const { networkId: envNetworkId, contractId: envContractId } = (0, keypom_1.getEnv)();
    networkId = networkId || envNetworkId;
    contractId = contractId || envContractId;
    (0, checks_1.assert)(secretKeys, 'Secret keys must be passed in as either an array or a single string');
    (0, checks_1.assert)(customURL ||
        Object.prototype.hasOwnProperty.call(keypom_1.supportedLinkdropClaimPages[networkId], claimPage), 'Either a custom base URL or a supported claim page must be passed in.');
    customURL =
        customURL || keypom_1.supportedLinkdropClaimPages[networkId][claimPage];
    // If the secret key is a single string, convert it to an array
    if (typeof secretKeys === 'string') {
        secretKeys = [secretKeys];
    }
    // insert the contractId and secret key into the base URL based on the CONTRACT_ID and SECRET_KEY field
    const returnedURLs = [];
    // loop through all secret keys
    secretKeys.forEach((secretKey) => {
        // insert the secret key into the base URL
        let url = customURL.replace('SECRET_KEY', secretKey);
        // insert the contract ID into the base URL
        url = url.replace('CONTRACT_ID', contractId);
        // add the URL to the array of URLs
        returnedURLs.push(url);
    });
    return returnedURLs;
};
exports.formatLinkdropUrl = formatLinkdropUrl;
/**
 * Generate a sha256 hash of a passed in string. If the string is hex encoded, set the fromHex flag to true.
 *
 * @param {string} str - the string you wish to hash. By default, this should be utf8 encoded. If the string is hex encoded, set the fromHex flag to true.
 * @param {boolean} fromHex (OPTIONAL) - A flag that should be set if the string is hex encoded. Defaults to false.
 *
 * @returns {Promise<string>} - The resulting hash
 *
 * @example
 * Generating the required password to pass into `claim` given a base password:
 * ```js
 * 	// Create the password to pass into claim which is a hash of the basePassword, public key and whichever use we are on
 * let currentUse = 1;
 * let passwordForClaim = await hashPassword(basePassword + publicKey + currentUse.toString());
 * ```
 * @group Utility
 */
const hashPassword = (str, fromHex = false) => __awaiter(void 0, void 0, void 0, function* () {
    const buf = yield hashBuf(str, fromHex);
    return Buffer.from(buf).toString('hex');
});
exports.hashPassword = hashPassword;
/**
 * Generate ed25519 KeyPairs that can be used for Keypom linkdrops, or full access keys to claimed accounts. These keys can optionally be derived from some entropy such as a root password and metadata pertaining to each key (user provided password etc.).
 * Entropy is useful for creating an onboarding experience where in order to recover a keypair, the client simply needs to provide the meta entropy (could be a user's password) and the secret root key like a UUID).
 *
 * @param {number} numKeys - The number of keys to generate
 * @param {string=} rootEntropy (OPTIONAL) - A root string that will be used as a baseline for all keys in conjunction with different metaEntropies (if provided) to deterministically generate a keypair. If not provided, the keypair will be completely random.
 * @param {string=} metaEntropy (OPTIONAL) - An array of entropies to use in conjunction with a base rootEntropy to deterministically generate the private keys. For single key generation, you can either pass in a string array with a single element, or simply
 pass in the string itself directly (not within an array).
 * @param {number=} autoMetaNonceStart (OPTIONAL) - Specify a starting index whereby the meta entropy will automatically increment by 1 for each key generated. This is to avoid having to pass in an array of meta entropy that simply increments by 1 each time.
 * This is very useful as auto key generation uses the drop ID, base password and key nonce. The drop ID and base password would be a constant and make up the root entropy and then the key nonce increments by 1 for each key generated.
 * @returns {Promise<GeneratedKeyPairs>} - An object containing an array of KeyPairs, Public Keys and Secret Keys.
 *
 * @example
 * Generating 10 unique random keypairs with no entropy:
 * ```js
 * // Generate 10 keys with no entropy (all random)
 * let keys = await generateKeys({
 *     numKeys: 10,
 * })
 *
 * let pubKey1 = keys.publicKeys[0];
 * let secretKey1 = keys.secretKeys[0];
 *
 * console.log('1st Public Key: ', pubKey1);
 * console.log('1st Secret Key: ', secretKey1)
 * ```
 *
 * @example
 * Generating 1 keypair based on entropy:
 * ```js
 * // Generate 1 key with the given entropy
 * let {publicKeys, secretKeys} = await generateKeys({
 *     numKeys: 1,
 *     rootEntropy: "my-global-password",
 *     metaEntropy: "user-password-123" // In this case, since there is only 1 key, the entropy can be an array of size 1 as well.
 * })
 *
 * let pubKey = publicKeys[0];
 * let secretKey = secretKeys[0];
 *
 * console.log('Public Key: ', pubKey);
 * console.log('Secret Key: ', secretKey)
 * ```
 *
 * @example
 * Generating 2 keypairs each with their own entropy:
 * ```js
 * // Generate 2 keys each with their own unique entropy
 * let keys = await generateKeys({
 *     numKeys: 2,
 *     rootEntropy: "my-global-password",
 *     metaEntropy: [
 *        `first-password:0`,
 *        `second-password:1`
 *    ]
 * })
 *
 * console.log('Pub Keys ', keys.publicKeys);
 * console.log('Secret Keys ', keys.secretKeys);
 * ```
 *  * @example
 * Generate 50 keys exactly how the auto key generation would in createDrop and addKeys:
 * ```js
 * const dropId = '1676913490360';
 * const basePassword = "my-password";
 * // Generate 50 keys each with their own unique entropy
 * let keys = await generateKeys({
 *     numKeys: 50,
 *     rootEntropy: `${basePassword}-${dropId}`,
 *     autoMetaNonceStart: 0
 * })
 *
 * console.log('Pub Keys ', keys.publicKeys);
 * console.log('Secret Keys ', keys.secretKeys);
 * ```
 * @group Utility
 */
const generateKeys = ({ numKeys, rootEntropy, metaEntropy, autoMetaNonceStart, }) => __awaiter(void 0, void 0, void 0, function* () {
    // If the metaEntropy provided is not an array (simply the string for 1 key), we convert it to an array of size 1 so that we can use the same logic for both cases
    if (metaEntropy && !Array.isArray(metaEntropy)) {
        metaEntropy = [metaEntropy];
    }
    // Ensure that if metaEntropy is provided, it should be the same length as the number of keys
    const numEntropy = (metaEntropy === null || metaEntropy === void 0 ? void 0 : metaEntropy.length) || numKeys;
    (0, checks_1.assert)(numEntropy == numKeys, 'You must provide the same number of meta entropy values as the number of keys');
    const keyPairs = [];
    const publicKeys = [];
    const secretKeys = [];
    if (metaEntropy === undefined && autoMetaNonceStart !== undefined) {
        metaEntropy = Array(numKeys)
            .fill(0)
            .map((_, i) => (autoMetaNonceStart + i).toString());
    }
    for (let i = 0; i < numKeys; i++) {
        if (rootEntropy) {
            const stringToHash = metaEntropy
                ? `${rootEntropy}_${metaEntropy[i]}`
                : rootEntropy;
            const hash = yield hashBuf(stringToHash);
            const { secretKey, publicKey } = (0, near_seed_phrase_1.generateSeedPhrase)(hash);
            const keyPair = crypto_1.KeyPair.fromString(secretKey);
            keyPairs.push(keyPair);
            publicKeys.push(publicKey);
            secretKeys.push(secretKey);
        }
        else {
            const keyPair = crypto_1.KeyPairEd25519.fromRandom();
            keyPairs.push(keyPair);
            publicKeys.push(keyPair.getPublicKey().toString());
            secretKeys.push(keyPair.secretKey);
        }
    }
    return {
        keyPairs,
        publicKeys,
        secretKeys,
    };
});
exports.generateKeys = generateKeys;
const keypomView = ({ methodName, args }) => __awaiter(void 0, void 0, void 0, function* () {
    const { viewCall, contractId } = (0, keypom_1.getEnv)();
    return viewCall({
        contractId,
        methodName,
        args,
    });
});
exports.keypomView = keypomView;
/**
 * Query for important access key data such as the nonce, allowance, method names etc. that is stored on the NEAR protocol for a given account and public key.
 *
 * @example
 * Check if an access key belongs to a trial account
 * ```js
 * const keyInfo = await viewAccessKeyData({accountId, secretKey});
 * let keyPerms = keyInfo.permission.FunctionCall;
 * isValidTrialInfo = keyPerms.receiver_id === accountId && keyPerms.method_names.includes('execute')
 * console.log('isValidTrialInfo: ', isValidTrialInfo)
 * ```
 * @group Utility
 */
const viewAccessKeyData = ({ accountId, publicKey, secretKey, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { near } = (0, keypom_1.getEnv)();
    const provider = near.connection.provider;
    if (secretKey) {
        publicKey = (0, exports.getPubFromSecret)(secretKey);
    }
    const res = yield provider.query({
        request_type: 'view_access_key',
        finality: 'final',
        account_id: accountId,
        public_key: publicKey,
    });
    return res;
});
exports.viewAccessKeyData = viewAccessKeyData;
/// TODO WIP: helper to remove the deposit if the user already has enough balance to cover the drop,add_keys
// export const hasDeposit = ({
//     accountId,
//     transactions,
// }) => {
//     const { contractId, viewAccount } = getEnv()
//     const totalDeposit = transactions.reduce((a, c) =>
//         a.add(c.actions.reduce((a, c) => a.add(new BN(c.deposit || '0')), new BN('0')))
//     , new BN('0'))
// 	const userBalance = viewAccount.viewFunction2({ contractId, methodName: 'get_user_balance', args: { account_id: accountId }})
//     if (new BN(userBalance.gt(totalDeposit))) {
//         transactions
//             .filter(({ receiverId }) => contractId === receiverId)
//             .forEach((tx) => tx.actions.forEach((a) => {
//                 if (/create_drop|add_keys/gi.test(a.methodName)) delete a.deposit
//             }))
//     }
// }
/** @group Utility */
const execute = ({ transactions, account, wallet, fundingAccount, successUrl, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { contractId } = (0, keypom_1.getEnv)();
    // instance of walletSelector.wallet()
    if (wallet) {
        // wallet might be Promise<Wallet> or value, either way doesn't matter
        wallet = yield wallet;
        console.log('wallet: ', wallet);
        // might be able to sign transactions with app key
        let needsRedirect = false;
        const selectorTxns = [];
        transactions.forEach((tx) => {
            const selectorActions = [];
            if (tx.receiverId !== contractId)
                needsRedirect = true;
            tx.actions.forEach((a) => {
                selectorActions.push({
                    type: 'FunctionCall',
                    params: {
                        methodName: a.functionCall.methodName,
                        args: JSON.parse(new util_1.TextDecoder().decode(a.functionCall.args)),
                        deposit: a.functionCall.deposit,
                        gas: a.functionCall.gas
                    }
                });
                const { deposit } = a.params;
                if (deposit && deposit !== '0')
                    needsRedirect = true;
            });
            selectorTxns.push({
                signerId: tx.signerId,
                receiverId: tx.receiverId,
                actions: selectorActions
            });
        });
        console.log('needsRedirect: ', needsRedirect);
        console.log('transactions: ', transactions);
        if (needsRedirect)
            return yield wallet.signAndSendTransactions({
                transactions: selectorTxns,
                callbackUrl: successUrl
            });
        // sign txs in serial without redirect
        const responses = [];
        for (const tx of transactions) {
            const selectorActions = [];
            tx.actions.forEach((a) => {
                selectorActions.push({
                    type: 'FunctionCall',
                    params: {
                        methodName: a.functionCall.methodName,
                        args: JSON.parse(new util_1.TextDecoder().decode(a.functionCall.args)),
                        deposit: a.functionCall.deposit,
                        gas: a.functionCall.gas
                    }
                });
            });
            responses.push(yield wallet.signAndSendTransaction({
                actions: selectorActions,
            }));
        }
        console.log('responses: ', responses);
        return responses;
    }
    /// instance of NEAR Account (backend usage)
    const nearAccount = account || fundingAccount;
    (0, checks_1.assert)(nearAccount, 'Call with either a NEAR Account argument \'account\' or initialize Keypom with a \'fundingAccount\'');
    return yield signAndSendTransactions(nearAccount, (0, exports.transformTransactions)(transactions));
});
exports.execute = execute;
/**
 * For FT Drops, keys need to be registered before they can be used. This is done via the `ft_transfer_call` method on the FT contract.
 * This is a convenience method to make that process easier.
 *
 * @example
 * Send FTs using the funder account (not passing in any accounts into the call):
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await ftTransferCall({
 *     contractId: "ft.keypom.testnet",
 *     amount: "1",
 *     dropId: "1231231",
 * )};
 * ```
 * @group Registering Key Uses
 */
const ftTransferCall = ({ account, wallet, contractId, absoluteAmount, amount, dropId, returnTransaction = false, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { getAccount, receiverId: keypomContractId, viewCall, } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    if (amount) {
        const metadata = yield viewCall({
            contractId,
            methodName: 'ft_metadata',
        });
        absoluteAmount = (0, exports.parseFTAmount)(amount, metadata.decimals);
    }
    const pk = yield account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
    const txnInfo = {
        receiverId: contractId,
        signerId: account.accountId,
        actions: [
            {
                enum: 'FunctionCall',
                functionCall: {
                    methodName: 'ft_transfer_call',
                    args: (0, transactions_1.stringifyJsonOrBytes)({
                        receiver_id: keypomContractId,
                        amount: absoluteAmount,
                        msg: dropId.toString(),
                    }),
                    gas: '50000000000000',
                    deposit: '1',
                }
            },
        ],
    };
    const transaction = yield (0, exports.convertBasicTransaction)({ txnInfo, signerId: account.accountId, signerPk: pk });
    if (returnTransaction)
        return transaction;
    return (0, exports.execute)({ account: account, transactions: [transaction] });
});
exports.ftTransferCall = ftTransferCall;
/**
 * For NFT Drops, keys need to be registered before they can be used. This is done via the `nft_transfer_call` method on the NFT contract.
 * This is a convenience method to make that process easier.
 *
 * @param {Account=} account (OPTIONAL) If specified, the passed in account will be used to sign the txn instead of the funder account.
 * @param {BrowserWalletBehaviour=} wallet (OPTIONAL) If using a browser wallet through wallet selector and that wallet should sign the transaction, pass it in.
 * @param {string} contractId The non-fungible token contract ID.
 * @param {string[]} tokenIds A set of token IDs that should be sent to the Keypom contract in order to register keys.
 * @param {string} dropId The drop ID to register the keys for.
 * @param {boolean=} returnTransaction (OPTIONAL) If true, the transaction will be returned instead of being signed and sent.
 *
 * @example
 * Send 3 NFTs using the funder account (not passing in any accounts into the call):
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await nftTransferCall({
 *     contractId: "nft.keypom.testnet",
 *     tokenIds: ["1", "2", "3],
 *     dropId: "1231231",
 * )};
 * ```
 * @group Registering Key Uses
 */
const nftTransferCall = ({ account, wallet, contractId, tokenIds, dropId, returnTransactions = false, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { getAccount, receiverId } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    (0, checks_1.assert)(tokenIds.length < 6, 'This method can only transfer 6 NFTs in 1 batch transaction.');
    const responses = [];
    const transactions = [];
    /// TODO batch calls in parallel where it makes sense
    for (let i = 0; i < tokenIds.length; i++) {
        const pk = yield account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
        const txnInfo = {
            receiverId: contractId,
            signerId: account.accountId,
            actions: [
                {
                    enum: 'FunctionCall',
                    functionCall: {
                        methodName: 'nft_transfer_call',
                        args: (0, transactions_1.stringifyJsonOrBytes)({
                            receiver_id: receiverId,
                            token_id: tokenIds[i],
                            msg: dropId.toString(),
                        }),
                        gas: '50000000000000',
                        deposit: '1',
                    }
                },
            ],
        };
        const transaction = yield (0, exports.convertBasicTransaction)({ txnInfo, signerId: account.accountId, signerPk: pk });
        transactions.push(transaction);
        if (returnTransactions)
            continue;
        responses.push(yield (0, exports.execute)({
            account: account,
            transactions,
        }));
    }
    return returnTransactions ? transactions : responses;
});
exports.nftTransferCall = nftTransferCall;
/// https://github.com/near/near-api-js/blob/7f16b10ece3c900aebcedf6ebc660cc9e604a242/packages/near-api-js/src/utils/format.ts#L53
const parseFTAmount = (amt, decimals) => {
    amt = amt.replace(/,/g, '').trim();
    const split = amt.split('.');
    const wholePart = split[0];
    const fracPart = split[1] || '';
    if (split.length > 2 || fracPart.length > decimals) {
        throw new Error(`Cannot parse '${amt}' as NEAR amount`);
    }
    return trimLeadingZeroes(wholePart + fracPart.padEnd(decimals, '0'));
};
exports.parseFTAmount = parseFTAmount;
const trimLeadingZeroes = (value) => {
    value = value.replace(/^0+/, '');
    if (value === '') {
        return '0';
    }
    return value;
};
/// sequentially execute all transactions
const signAndSendTransactions = (account, txs) => __awaiter(void 0, void 0, void 0, function* () {
    const responses = [];
    for (let i = 0; i < txs.length; i++) {
        // Reference: https://github.com/near/wallet-selector/blob/7f9f8598459cffb80583c2a83c387c3d5c2f4d5d/packages/my-near-wallet/src/lib/my-near-wallet.spec.ts#L31
        responses.push(yield account.signAndSendTransaction(txs[i]));
    }
    return responses;
});
const transformTransactions = (transactions) => transactions.map(({ receiverId, actions: _actions }) => {
    const actions = _actions.map((action) => (0, exports.createAction)(action));
    const txnOption = {
        receiverId: receiverId,
        actions,
    };
    return txnOption;
});
exports.transformTransactions = transformTransactions;
const createAction = (action) => {
    if (action.createAccount) {
        return transactions_1.actionCreators.createAccount();
    }
    if (action.deployContract) {
        const { code } = action.deployContract;
        return transactions_1.actionCreators.deployContract(code);
    }
    if (action.functionCall) {
        const { methodName, args, gas, deposit } = action.functionCall;
        return transactions_1.actionCreators.functionCall(methodName, args, new bn_js_1.default(gas), new bn_js_1.default(deposit));
    }
    if (action.transfer) {
        const { deposit } = action.transfer;
        return transactions_1.actionCreators.transfer(new bn_js_1.default(deposit));
    }
    if (action.stake) {
        const { stake, publicKey } = action.stake;
        return transactions_1.actionCreators.stake(new bn_js_1.default(stake), crypto_1.PublicKey.from(publicKey));
    }
    if (action.deleteKey) {
        const { publicKey } = action.deleteKey;
        return transactions_1.actionCreators.deleteKey(crypto_1.PublicKey.from(publicKey));
    }
    if (action.deleteAccount) {
        const { beneficiaryId } = action.deleteAccount;
        return transactions_1.actionCreators.deleteAccount(beneficiaryId);
    }
    throw new Error('Unknown action');
};
exports.createAction = createAction;
/** @group Utility */
const getStorageBase = ({ public_keys, deposit_per_use, drop_id, config, metadata, simple, ft, nft, fc, passwords_per_use, }) => {
    const storageCostNEARPerByte = 0.00001;
    let totalBytes = 0;
    // Get the bytes per public key, multiply it by number of keys, and add it to the total
    const bytesPerKey = Buffer.from('ed25519:88FHvWTp21tahAobQGjD8YweXGRgA7jE8TSQM6yg4Cim').length;
    const totalBytesForKeys = bytesPerKey * ((public_keys === null || public_keys === void 0 ? void 0 : public_keys.length) || 0);
    // console.log('totalBytesForKeys: ', totalBytesForKeys)
    // Bytes for the deposit per use
    const bytesForDeposit = Buffer.from(deposit_per_use.toString()).length + 40;
    // console.log('bytesForDeposit: ', bytesForDeposit)
    // Bytes for the drop ID
    const bytesForDropId = Buffer.from(drop_id || '').length + 40;
    // console.log('bytesForDropId: ', bytesForDropId)
    // Bytes for the config
    const bytesForConfig = Buffer.from(JSON.stringify(config || '')).length + 40;
    // console.log('bytesForConfig: ', bytesForConfig)
    // Bytes for the metadata. 66 comes from collection initialization
    const bytesForMetadata = Buffer.from(metadata || '').length + 66;
    // console.log('bytesForMetadata: ', bytesForMetadata)
    // Bytes for the simple data
    const bytesForSimple = Buffer.from(JSON.stringify(simple || '')).length + 40;
    // console.log('bytesForSimple: ', bytesForSimple)
    // Bytes for the FT data
    const bytesForFT = Buffer.from(JSON.stringify(ft || '')).length + 40;
    // console.log('bytesForFT: ', bytesForFT)
    // Bytes for the NFT data
    const bytesForNFT = Buffer.from(JSON.stringify(nft || '')).length + 40;
    // console.log('bytesForNFT: ', bytesForNFT)
    // Bytes for the FC data
    const bytesForFC = Buffer.from(JSON.stringify(fc || '')).length + 40;
    // console.log('bytesForFC: ', bytesForFC)
    // Bytes for the passwords per use
    // Magic numbers come from plotting SDK data against protocol data and finding the best fit
    const bytesForPasswords = Buffer.from(JSON.stringify(passwords_per_use || '')).length * 4;
    // console.log('bytesForPasswords: ', bytesForPasswords)
    totalBytes +=
        totalBytesForKeys +
            bytesForDeposit +
            bytesForDropId +
            bytesForConfig +
            bytesForMetadata +
            bytesForSimple +
            bytesForFT +
            bytesForNFT +
            bytesForFC +
            bytesForPasswords;
    // console.log('totalBytes: ', totalBytes)
    // Add a 30% buffer to the total bytes
    totalBytes = Math.round(totalBytes * 1.3);
    // console.log('totalBytes Rounded: ', totalBytes)
    let totalNEARAmount = totalBytes * storageCostNEARPerByte;
    // console.log('totalNEARAmount BEFORE: ', totalNEARAmount)
    // Accounting for protocol storage for access keys
    // Magic numbers come from plotting SDK data against protocol data and finding the best fit
    totalNEARAmount += ((public_keys === null || public_keys === void 0 ? void 0 : public_keys.length) || 0) * 0.005373134328 + 0.00376;
    // console.log('totalNEARAmount AFTER pk: ', totalNEARAmount.toString())
    // Multi use passwords need a little extra storage
    if (passwords_per_use) {
        totalNEARAmount +=
            -0.00155 * (((config === null || config === void 0 ? void 0 : config.uses_per_key) || 1) - 1) + 0.00285687;
        // console.log('totalNEARAmount AFTER pw per use conversion: ', totalNEARAmount.toString())
    }
    // Turns it into yocto
    return (0, utils_1.parseNearAmount)(totalNEARAmount.toString());
};
exports.getStorageBase = getStorageBase;
/** Initiate the connection to the NEAR blockchain. @group Utility */
const estimateRequiredDeposit = ({ near, depositPerUse, numKeys, usesPerKey, attachedGas, storage = (0, utils_1.parseNearAmount)('0.034'), keyStorage = (0, utils_1.parseNearAmount)('0.0065'), fcData, ftData, }) => __awaiter(void 0, void 0, void 0, function* () {
    const numKeysBN = new bn_js_1.default(numKeys.toString());
    const usesPerKeyBN = new bn_js_1.default(usesPerKey.toString());
    const totalRequiredStorage = new bn_js_1.default(storage).add(new bn_js_1.default(keyStorage).mul(numKeysBN));
    // console.log('totalRequiredStorage: ', totalRequiredStorage.toString())
    const actualAllowance = estimatePessimisticAllowance(attachedGas).mul(usesPerKeyBN);
    // console.log('actualAllowance: ', actualAllowance.toString())
    const totalAllowance = actualAllowance.mul(numKeysBN);
    // console.log('totalAllowance: ', totalAllowance.toString())
    const totalAccessKeyStorage = ACCESS_KEY_STORAGE.mul(numKeysBN);
    // console.log('totalAccessKeyStorage: ', totalAccessKeyStorage.toString())
    const { numNoneFcs, depositRequiredForFcDrops } = getNoneFcsAndDepositRequired(fcData, usesPerKey);
    const totalDeposits = new bn_js_1.default(depositPerUse)
        .mul(new bn_js_1.default(usesPerKey - numNoneFcs))
        .mul(numKeysBN);
    // console.log('totalDeposits: ', totalDeposits.toString())
    const totalDepositsForFc = depositRequiredForFcDrops.mul(numKeysBN);
    // console.log('totalDepositsForFc: ', totalDepositsForFc.toString())
    let requiredDeposit = totalRequiredStorage
        .add(totalAllowance)
        .add(totalAccessKeyStorage)
        .add(totalDeposits)
        .add(totalDepositsForFc);
    // console.log('requiredDeposit B4 FT costs: ', requiredDeposit.toString())
    if (ftData === null || ftData === void 0 ? void 0 : ftData.contractId) {
        const extraFtCosts = yield getFtCosts(near, numKeys, usesPerKey, ftData === null || ftData === void 0 ? void 0 : ftData.contractId);
        requiredDeposit = requiredDeposit.add(new bn_js_1.default(extraFtCosts));
        // console.log('requiredDeposit AFTER FT costs: ', requiredDeposit.toString())
    }
    return requiredDeposit.toString() || '0';
});
exports.estimateRequiredDeposit = estimateRequiredDeposit;
// Estimate the amount of allowance required for a given attached gas.
const estimatePessimisticAllowance = (attachedGas) => {
    if (typeof attachedGas !== 'number')
        attachedGas = parseInt(attachedGas);
    // Get the number of CCCs you can make with the attached GAS
    const numCCCs = Math.floor(attachedGas / GAS_PER_CCC);
    // console.log('numCCCs: ', numCCCs)
    // Get the constant used to pessimistically calculate the required allowance
    const powOutcome = Math.pow(1.03, numCCCs);
    // console.log('powOutcome: ', powOutcome)
    const requiredGas = (attachedGas + RECEIPT_GAS_COST) * powOutcome + RECEIPT_GAS_COST;
    // console.log('requiredGas: ', requiredGas)
    const requiredAllowance = new bn_js_1.default(requiredGas).mul(new bn_js_1.default(YOCTO_PER_GAS));
    // console.log('requiredAllowance: ', requiredAllowance.toString())
    return requiredAllowance;
};
// Estimate the amount of allowance required for a given attached gas.
const getNoneFcsAndDepositRequired = (fcData, usesPerKey) => {
    let depositRequiredForFcDrops = new bn_js_1.default(0);
    let numNoneFcs = 0;
    if (!fcData || Object.keys(fcData).length === 0) {
        return { numNoneFcs, depositRequiredForFcDrops };
    }
    const numMethodData = fcData.methods.length;
    // If there's one method data specified and more than 1 claim per key, that data is to be used
    // For all the claims. In this case, we need to tally all the deposits for each method in all method data.
    if (usesPerKey > 1 && numMethodData == 1) {
        const methodData = fcData.methods[0];
        // Keep track of the total attached deposit across all methods in the method data
        let attachedDeposit = new bn_js_1.default(0);
        for (let i = 0; i < ((methodData === null || methodData === void 0 ? void 0 : methodData.length) || 0); i++) {
            attachedDeposit = attachedDeposit.add(new bn_js_1.default(methodData[i].attachedDeposit));
        }
        depositRequiredForFcDrops = depositRequiredForFcDrops
            .add(new bn_js_1.default(attachedDeposit))
            .mul(new bn_js_1.default(usesPerKey));
        return {
            numNoneFcs,
            depositRequiredForFcDrops,
        };
    }
    // In the case where either there's 1 claim per key or the number of FCs is not 1,
    // We can simply loop through and manually get this data
    for (let i = 0; i < numMethodData; i++) {
        const methodData = fcData.methods[i];
        const isNoneFc = methodData == null;
        numNoneFcs += isNoneFc ? 1 : 0;
        if (!isNoneFc) {
            // Keep track of the total attached deposit across all methods in the method data
            let attachedDeposit = new bn_js_1.default(0);
            for (let j = 0; j < ((methodData === null || methodData === void 0 ? void 0 : methodData.length) || 0); j++) {
                attachedDeposit = attachedDeposit.add(new bn_js_1.default(methodData[j].attachedDeposit));
            }
            depositRequiredForFcDrops =
                depositRequiredForFcDrops.add(attachedDeposit);
        }
    }
    return {
        numNoneFcs,
        depositRequiredForFcDrops,
    };
};
// Estimate the amount of allowance required for a given attached gas.
const getFtCosts = (near, numKeys, usesPerKey, ftContract) => __awaiter(void 0, void 0, void 0, function* () {
    const viewAccount = yield near.account('foo');
    const { min } = yield viewAccount.viewFunction({
        contractId: ftContract,
        methodName: 'storage_balance_bounds',
        args: {},
    });
    // console.log('storageBalanceBounds: ', storageBalanceBounds)
    const costs = new bn_js_1.default(min)
        .mul(new bn_js_1.default(numKeys))
        .mul(new bn_js_1.default(usesPerKey))
        .add(new bn_js_1.default(min));
    // console.log('costs: ', costs.toString());
    return costs.toString() || '0';
});
/**
 * Generate passwords for a set of public keys. A unique password will be created for each specified use of a public key where the use is NOT zero indexed (i.e 1st use = 1).
 * The passwords will be generated via a double hash of the base password + public key + specific use
 *
 * @param {string[]} publicKeys The public keys that will be used to generate the set of passwords
 * @param {string[]} uses An array of numbers that dictate which uses should be password protected. The 1st use of a key is 1 (NOT zero indexed).
 * @param {string=} basePassword All the passwords will be generated from this base password. It will be double hashed with the public key.
 *
 * @returns {Promise<Array<Array<PasswordPerUse>>>} An array of objects for each key where each object has a password and maps it to its specific key use.
 * @group Utility
 */
function generatePerUsePasswords({ publicKeys, uses, basePassword, }) {
    return __awaiter(this, void 0, void 0, function* () {
        const passwords = [];
        // Loop through each pubKey to generate either the passwords
        for (let i = 0; i < publicKeys.length; i++) {
            // For each public key, we need to generate a password for each use
            const passwordsPerUse = [];
            for (let j = 0; j < uses.length; j++) {
                // First inner hash takes in utf8 and returns hash
                const innerHashBuff = yield hashBuf(basePassword + publicKeys[i] + uses[j].toString());
                const innerHash = Buffer.from(innerHashBuff).toString('hex');
                // Outer hash takes in hex and returns hex
                const outerHashBuff = yield hashBuf(innerHash, true);
                const outerHash = Buffer.from(outerHashBuff).toString('hex');
                const jsonPw = {
                    pw: outerHash,
                    key_use: uses[j],
                };
                passwordsPerUse.push(jsonPw);
            }
            passwords.push(passwordsPerUse);
        }
        return passwords;
    });
}
exports.generatePerUsePasswords = generatePerUsePasswords;
// Taken from https://stackoverflow.com/a/61375162/16441367
const snakeToCamel = (str) => str
    .toLowerCase()
    .replace(/([-_][a-z])/g, (group) => group.toUpperCase().replace('-', '').replace('_', ''));
exports.snakeToCamel = snakeToCamel;
// Taken from https://stackoverflow.com/a/26215431/16441367
const toCamel = (o) => {
    let newO, origKey, newKey, value;
    if (o instanceof Array) {
        return o.map(function (value) {
            if (typeof value === 'object') {
                value = (0, exports.toCamel)(value);
            }
            return value;
        });
    }
    else {
        newO = {};
        for (origKey in o) {
            if (Object.prototype.hasOwnProperty.call(o, origKey)) {
                newKey = (0, exports.snakeToCamel)(origKey);
                value = o[origKey];
                if (value instanceof Array ||
                    (value !== null && value.constructor === Object)) {
                    value = (0, exports.toCamel)(value);
                }
                newO[newKey] = value;
            }
        }
    }
    return newO;
};
exports.toCamel = toCamel;
const nearArgsToYocto = (nearAmount, yoctoAmount) => {
    let yoctoToReturn = yoctoAmount || '0';
    if (nearAmount) {
        yoctoToReturn = (0, utils_1.parseNearAmount)(nearAmount.toString()) || '0';
    }
    return yoctoToReturn;
};
exports.nearArgsToYocto = nearArgsToYocto;
const convertBasicTransaction = ({ txnInfo, signerId, signerPk }) => __awaiter(void 0, void 0, void 0, function* () {
    const { near } = (0, keypom_1.getEnv)();
    const account = new accounts_1.Account(near.connection, signerId);
    const { provider } = account.connection;
    const actions = txnInfo.actions.map((action) => (0, exports.createAction)(action));
    const block = yield provider.block({ finality: 'final' });
    const accessKey = yield provider.query(`access_key/${signerId}/${signerPk}`, '');
    return (0, transactions_1.createTransaction)(signerId, signerPk, txnInfo.receiverId, accessKey.nonce + 1, actions, (0, borsh_1.baseDecode)(block.header.hash));
});
exports.convertBasicTransaction = convertBasicTransaction;
const createTransactions = ({ txnInfos, signerId, signerPk }) => {
    const { near } = (0, keypom_1.getEnv)();
    return Promise.all(txnInfos.map((txnInfo, index) => __awaiter(void 0, void 0, void 0, function* () {
        const account = new accounts_1.Account(near.connection, signerId);
        const { provider } = account.connection;
        const actions = txnInfo.actions.map((action) => (0, exports.createAction)(action));
        const block = yield provider.block({ finality: 'final' });
        const accessKey = yield provider.query(`access_key/${signerId}/${signerPk}`, '');
        return (0, transactions_1.createTransaction)(signerId, signerPk, txnInfo.receiverId, accessKey.nonce + index + 1, actions, (0, borsh_1.baseDecode)(block.header.hash));
    })));
};
exports.createTransactions = createTransactions;

'''
'''--- packages/core/lib/lib/keypom.d.ts ---
import { Near } from '@near-js/wallet-account';
import { EnvVars, Funder } from './types/general';
export declare const networks: {
    mainnet: {
        networkId: string;
        viewAccountId: string;
        nodeUrl: string;
        walletUrl: string;
        helperUrl: string;
    };
    testnet: {
        networkId: string;
        viewAccountId: string;
        nodeUrl: string;
        walletUrl: string;
        helperUrl: string;
    };
    localnet: {
        networkId: string;
        viewAccountId: string;
    };
};
/**
 * List of supported Keypom contracts that can be used with the SDK.
 *
 * @group Keypom SDK Environment
 */
export declare const supportedKeypomContracts: {
    mainnet: {
        'v1.keypom.near': boolean;
        'v1-3.keypom.near': boolean;
        'v1-4.keypom.near': boolean;
        'v2.keypom.near': boolean;
    };
    testnet: {
        'v1.keypom.testnet': boolean;
        'v1-3.keypom.testnet': boolean;
        'v1-4.keypom.testnet': boolean;
        'v2.keypom.testnet': boolean;
    };
    localnet: {
        'keypom.test.near': boolean;
    };
};
/**
 * Official linkdrop claim pages for wallets and other applications
 *
 * @group Keypom SDK Environment
 */
export declare const supportedLinkdropClaimPages: {
    mainnet: {
        mynearwallet: string;
        keypom: string;
        meteor: string;
    };
    testnet: {
        mynearwallet: string;
        keypom: string;
        meteor: string;
    };
};
/**
 * Recovery mapping contracts used to keep track of trial account IDs for given public keys.
 *
 * @group Keypom SDK Environment
 */
export declare const accountMappingContract: {
    mainnet: string;
    testnet: string;
};
export type Maybe<T> = T | undefined;
declare let near: Maybe<Near>;
/**
 *
 * @returns {EnvVars} The environment variables used by the Keypom library.
 * @group Keypom SDK Environment
 */
export declare const getEnv: () => EnvVars;
/** @group Utility */
export declare const execute: (args: any) => Promise<void | import("@near-js/types").FinalExecutionOutcome[] | (void | import("@near-js/types").FinalExecutionOutcome)[]>;
/**
 * Initializes the SDK to allow for interactions with the Keypom Protocol. By default, a new NEAR connection will be established but this can be overloaded by
 * passing in an existing connection object. In either case, if a funder is passed in, the credentials will be added to the keystore to sign transactions.
 *
 * To update the funder account, refer to the `updateFunder` function. If you only wish to use view methods and not sign transactions, no funder account is needed.
 * If you wish to update the Keypom Contract ID being used, refer to the `updateKeypomContractId` function.
 *
 * @returns {Promise<Account | null>} If a funder is passed in, its account object is returned. Otherwise, it null is returned.
 *
 * @example
 * Using a pre-created NEAR connection instance with an UnencryptedFileSystemKeyStore:
 * ```js
 * const path = require("path");
 * const homedir = require("os").homedir();
 * const { KeyPair, keyStores, connect } = require("near-api-js");
 * const { initKeypom, getDrops } = require("keypom-js");
 *
 * // Establish the network we wish to work on
 * const network = "testnet";
 * // Get the location where the credentials are stored for our KeyStore
 * const CREDENTIALS_DIR = ".near-credentials";
 * const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
 * (await path).join;
 * let keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);
 *
 * // Establish the configuration for the connection
 * let nearConfig = {
 * 		networkId: network,
 * 		keyStore,
 * 		nodeUrl: `https://rpc.${network}.near.org`,
 * 		walletUrl: `https://wallet.${network}.near.org`,
 * 		helperUrl: `https://helper.${network}.near.org`,
 * 		explorerUrl: `https://explorer.${network}.near.org`,
 * };
 * // Connect to the NEAR blockchain and get the connection instance
 * let near = await connect(nearConfig);
 *
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 *		near,
 *		network
 * });
 *
 * // Get the drops for the given owner
 * const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 * ```
 *
 * @example
 * Creating an entirely new NEAR connection instance by using initKeypom and passing in a funder account:
 * ```js
 * const { initKeypom, getDrops } = require("keypom-js");
 *
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 *		network: "testnet",
 *		funder: {
 *			accountId: "benji_demo.testnet",
 *			secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *		}
 * });
 *
 * // Get the drops for the given owner
 * const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 * ```
 * @group Keypom SDK Environment
 */
export declare const initKeypom: ({ near: _near, network, funder, keypomContractId, }: {
    /** The NEAR connection instance to use. If not passed in, it will create a new one. */
    near?: Near;
    /** The network to connect to either `mainnet` or `testnet`. If a near object is passed in, this field can be omitted*/
    network?: string;
    /**
     * The account that will sign transactions to create drops and interact with the Keypom contract. This account will be added to the KeyStore if provided.
     * If rootEntropy is provided for the funder, all access keys will be derived deterministically based off this string.
     */
    funder?: Funder;
    /**
     * Instead of using the most up-to-date, default Keypom contract, you can specify a specific account ID to use. If an older version is specified, some features of the SDK might not be usable.
     */
    keypomContractId?: string;
}) => Promise<any>;
/**
 * Once the SDK is initialized, this function allows the current funder account to be updated. Having a funder is only necessary if you wish to sign transactions on the Keypom Protocol.
 *
 * @param {Funder} funder The account that will sign transactions to create drops and interact with the Keypom contract. This account will be added to the KeyStore if provided.
 * If rootEntropy is provided for the funder, all access keys will be derived deterministically based off this string.
 * @returns {Promise<Account>} The funder's account object is returned.
 *
 * @example
 * After initializing the SDK, the funder is updated.
 * ```js
 * const path = require("path");
 * const homedir = require("os").homedir();
 * const { KeyPair, keyStores, connect } = require("near-api-js");
 * const { initKeypom, updateFunder, getDrops } = require("keypom-js");
 *
 *	// Initialize the SDK for the given network and NEAR connection
 *	await initKeypom({
 *		network: "testnet",
 *	});
 *
 *	// Update the current funder account
 *	await updateFunder({
 *		funder: {
 *			accountId: "benji_demo.testnet",
 *			secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *		}
 *	})
 *
 *	// Get the drops for the given owner
 *	const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 *	console.log('dropsForOwner: ', dropsForOwner)
 *
 *	return;
 * ```
 * @group Keypom SDK Environment
 */
export declare const updateFunder: ({ funder }: {
    funder: Funder;
}) => Promise<any>;
/**
 * This allows the desired Keypom contract ID to be set. By default, the most up-to-date Keypom contract for the given network is set during initKeypom.
 *
 * @param {string} keypomContractId The account ID that should be used for the Keypom contract.
 *
 * @example
 * After initializing the SDK, the Keypom contract ID is updated.
 * ```js
 * const path = require("path");
 * const homedir = require("os").homedir();
 * const { KeyPair, keyStores, connect } = require("near-api-js");
 * const { initKeypom, updateKeypomContractId, getDrops } = require("keypom-js");
 *
 *	// Initialize the SDK for the given network and NEAR connection
 *	await initKeypom({
 *		network: "testnet",
 *	});
 *
 *	// Update the current Keypom contract ID
 *	updateKeypomContractId({
 *		keypomContractId: "v1.keypom.testnet"
 *	})
 *
 *	//Get the drops for the given owner
 *	const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 *	console.log('dropsForOwner: ', dropsForOwner)
 *
 *	return;
 * ```
 * @group Keypom SDK Environment
 */
export declare const updateKeypomContractId: ({ keypomContractId, }: {
    keypomContractId: string;
}) => any;
export {};

'''
'''--- packages/core/lib/lib/keypom.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateKeypomContractId = exports.updateFunder = exports.initKeypom = exports.execute = exports.getEnv = exports.accountMappingContract = exports.supportedLinkdropClaimPages = exports.supportedKeypomContracts = exports.networks = void 0;
const accounts_1 = require("@near-js/accounts");
const crypto_1 = require("@near-js/crypto");
const keystores_1 = require("@near-js/keystores");
const keystores_browser_1 = require("@near-js/keystores-browser");
const wallet_account_1 = require("@near-js/wallet-account");
const near_seed_phrase_1 = require("near-seed-phrase");
const checks_1 = require("./checks");
const keypom_utils_1 = require("./keypom-utils");
const gas = '200000000000000';
const gas300 = '300000000000000';
const attachedGas = '100000000000000';
exports.networks = {
    mainnet: {
        networkId: 'mainnet',
        viewAccountId: 'near',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
    },
    testnet: {
        networkId: 'testnet',
        viewAccountId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
    },
    localnet: {
        networkId: 'localnet',
        viewAccountId: 'test.near',
    },
};
/**
 * List of supported Keypom contracts that can be used with the SDK.
 *
 * @group Keypom SDK Environment
 */
exports.supportedKeypomContracts = {
    mainnet: {
        'v1.keypom.near': false,
        'v1-3.keypom.near': false,
        'v1-4.keypom.near': true,
        'v2.keypom.near': true,
    },
    testnet: {
        'v1.keypom.testnet': false,
        'v1-3.keypom.testnet': false,
        'v1-4.keypom.testnet': true,
        'v2.keypom.testnet': true,
    },
    localnet: {
        'keypom.test.near': true,
    },
};
/**
 * Official linkdrop claim pages for wallets and other applications
 *
 * @group Keypom SDK Environment
 */
exports.supportedLinkdropClaimPages = {
    mainnet: {
        mynearwallet: 'https://app.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY',
        keypom: 'https://keypom.xyz/claim/CONTRACT_ID#SECRET_KEY',
        meteor: 'https://wallet.meteorwallet.app/linkdrop/CONTRACT_ID/SECRET_KEY'
    },
    testnet: {
        mynearwallet: 'https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY',
        keypom: 'https://testnet.keypom.xyz/claim/CONTRACT_ID#SECRET_KEY',
        meteor: 'https://wallet.meteorwallet.app/linkdrop/CONTRACT_ID/SECRET_KEY'
    },
};
/**
 * Recovery mapping contracts used to keep track of trial account IDs for given public keys.
 *
 * @group Keypom SDK Environment
 */
exports.accountMappingContract = {
    mainnet: 'v1.mapping.keypom.near',
    testnet: 'v1.mapping.keypom.testnet',
};
const contractBase = 'v2.keypom';
let contractId = `${contractBase}.testnet`;
let receiverId = contractId;
let near = undefined;
let connection = undefined;
let keyStore = undefined;
let networkId = undefined;
let fundingAccount = undefined;
let fundingAccountDetails = undefined;
let contractAccount = undefined;
let viewAccount = undefined;
let viewCall = undefined;
/**
 *
 * @returns {EnvVars} The environment variables used by the Keypom library.
 * @group Keypom SDK Environment
 */
const getEnv = () => {
    (0, checks_1.assert)(near, 'Keypom uninitialized. Please call initKeypom or initKeypomContext');
    return {
        near,
        connection,
        keyStore,
        networkId,
        fundingAccount,
        contractAccount,
        viewAccount,
        fundingAccountDetails,
        gas,
        gas300,
        attachedGas,
        contractId,
        receiverId,
        getAccount,
        execute: exports.execute,
        supportedKeypomContracts: exports.supportedKeypomContracts,
        viewCall,
    };
};
exports.getEnv = getEnv;
/** @group Utility */
const execute = (args) => __awaiter(void 0, void 0, void 0, function* () { return (0, keypom_utils_1.execute)(Object.assign(Object.assign({}, args), { fundingAccount })); });
exports.execute = execute;
const getAccount = ({ account, wallet, }) => __awaiter(void 0, void 0, void 0, function* () {
    if (wallet) {
        wallet = yield wallet;
        (0, checks_1.assert)(wallet.signAndSendTransactions, 'Incorrect wallet type');
        wallet.accountId = (yield wallet.getAccounts())[0].accountId;
    }
    const returnedAccount = account || wallet || fundingAccount;
    // If neither a wallet object, account object, or funding account is provided, throw an error
    (0, checks_1.assert)(returnedAccount, 'No account provided. Either pass in an account object, wallet object, or initialize Keypom with a funding account');
    return returnedAccount;
});
/**
 * Initializes the SDK to allow for interactions with the Keypom Protocol. By default, a new NEAR connection will be established but this can be overloaded by
 * passing in an existing connection object. In either case, if a funder is passed in, the credentials will be added to the keystore to sign transactions.
 *
 * To update the funder account, refer to the `updateFunder` function. If you only wish to use view methods and not sign transactions, no funder account is needed.
 * If you wish to update the Keypom Contract ID being used, refer to the `updateKeypomContractId` function.
 *
 * @returns {Promise<Account | null>} If a funder is passed in, its account object is returned. Otherwise, it null is returned.
 *
 * @example
 * Using a pre-created NEAR connection instance with an UnencryptedFileSystemKeyStore:
 * ```js
 * const path = require("path");
 * const homedir = require("os").homedir();
 * const { KeyPair, keyStores, connect } = require("near-api-js");
 * const { initKeypom, getDrops } = require("keypom-js");
 *
 * // Establish the network we wish to work on
 * const network = "testnet";
 * // Get the location where the credentials are stored for our KeyStore
 * const CREDENTIALS_DIR = ".near-credentials";
 * const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
 * (await path).join;
 * let keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);
 *
 * // Establish the configuration for the connection
 * let nearConfig = {
 * 		networkId: network,
 * 		keyStore,
 * 		nodeUrl: `https://rpc.${network}.near.org`,
 * 		walletUrl: `https://wallet.${network}.near.org`,
 * 		helperUrl: `https://helper.${network}.near.org`,
 * 		explorerUrl: `https://explorer.${network}.near.org`,
 * };
 * // Connect to the NEAR blockchain and get the connection instance
 * let near = await connect(nearConfig);
 *
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 *		near,
 *		network
 * });
 *
 * // Get the drops for the given owner
 * const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 * ```
 *
 * @example
 * Creating an entirely new NEAR connection instance by using initKeypom and passing in a funder account:
 * ```js
 * const { initKeypom, getDrops } = require("keypom-js");
 *
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 *		network: "testnet",
 *		funder: {
 *			accountId: "benji_demo.testnet",
 *			secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *		}
 * });
 *
 * // Get the drops for the given owner
 * const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 * ```
 * @group Keypom SDK Environment
 */
const initKeypom = ({ near: _near, network, funder, keypomContractId, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    // Assert that either a near object or network is passed in
    (0, checks_1.assert)(_near || network, 'Either a NEAR connection object or network must be passed in.');
    if (network != undefined) {
        (0, checks_1.assert)(network == 'testnet' || network == 'mainnet' || 'localnet', 'Network must be either `testnet` or `mainnet` or `localnet`');
        // Assert that if network was passed in as "localnet", a near object should also be passed in
        (0, checks_1.assert)(network != 'localnet' || _near, 'If network is `localnet`, a NEAR connection object must be passed in.');
    }
    if (_near) {
        (0, checks_1.assert)((0, checks_1.isValidNearObject)(_near), 'The NEAR object passed in is not valid. Please pass in a valid NEAR object.');
        near = _near;
        keyStore = near.config.keyStore;
    }
    else {
        const networkConfig = typeof network === 'string' ? exports.networks[network] : network;
        keyStore = ((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node)
            ? new keystores_1.InMemoryKeyStore()
            : new keystores_browser_1.BrowserLocalStorageKeyStore();
        near = new wallet_account_1.Near(Object.assign(Object.assign({}, networkConfig), { keyStore }));
    }
    connection = near.connection;
    networkId = near.config.networkId;
    if (networkId === 'mainnet') {
        contractId = receiverId = `${contractBase}.near`;
    }
    if (networkId === 'localnet') {
        contractId = receiverId = 'keypom.test.near';
    }
    if (keypomContractId) {
        (0, checks_1.assert)((0, checks_1.isValidKeypomContract)(keypomContractId) === true, 'The keypom contract passed in must be an official Keypom contract for the given network.');
        if ((0, checks_1.isSupportedKeypomContract)(keypomContractId) !== true) {
            console.warn('The Keypom contract you are using is not the latest version. Most methods will be unavailable. Please use the latest contract: v1-3.keypom.near or v1-3.keypom.testnet');
        }
        contractId = receiverId = keypomContractId;
    }
    viewAccount = new accounts_1.Account(connection, exports.networks[networkId].viewAccountId);
    viewCall = viewAccount.viewFunction2 = ({ contractId, methodName, args }) => viewAccount.viewFunction({ contractId, methodName, args });
    contractAccount = new accounts_1.Account(connection, contractId);
    if (funder) {
        yield (0, exports.updateFunder)({ funder });
    }
    return null;
});
exports.initKeypom = initKeypom;
/**
 * Once the SDK is initialized, this function allows the current funder account to be updated. Having a funder is only necessary if you wish to sign transactions on the Keypom Protocol.
 *
 * @param {Funder} funder The account that will sign transactions to create drops and interact with the Keypom contract. This account will be added to the KeyStore if provided.
 * If rootEntropy is provided for the funder, all access keys will be derived deterministically based off this string.
 * @returns {Promise<Account>} The funder's account object is returned.
 *
 * @example
 * After initializing the SDK, the funder is updated.
 * ```js
 * const path = require("path");
 * const homedir = require("os").homedir();
 * const { KeyPair, keyStores, connect } = require("near-api-js");
 * const { initKeypom, updateFunder, getDrops } = require("keypom-js");
 *
 *	// Initialize the SDK for the given network and NEAR connection
 *	await initKeypom({
 *		network: "testnet",
 *	});
 *
 *	// Update the current funder account
 *	await updateFunder({
 *		funder: {
 *			accountId: "benji_demo.testnet",
 *			secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *		}
 *	})
 *
 *	// Get the drops for the given owner
 *	const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 *	console.log('dropsForOwner: ', dropsForOwner)
 *
 *	return;
 * ```
 * @group Keypom SDK Environment
 */
const updateFunder = ({ funder }) => __awaiter(void 0, void 0, void 0, function* () {
    (0, checks_1.assert)(near !== undefined, 'You must initialize the SDK via `initKeypom` before updating the funder account.');
    (0, checks_1.assert)((0, checks_1.isValidFunderObject)(funder), 'The funder object passed in is not valid. Please pass in a valid funder object.');
    (0, checks_1.assert)(funder.secretKey || funder.seedPhrase, 'The funder object passed in must have either a secretKey or seedphrase');
    const accountId = funder.accountId;
    const seedPhrase = funder.seedPhrase;
    let secretKey = funder.secretKey;
    if (seedPhrase) {
        secretKey = (0, near_seed_phrase_1.parseSeedPhrase)(seedPhrase).secretKey;
    }
    funder.fundingKeyPair = crypto_1.KeyPair.fromString(secretKey);
    yield keyStore.setKey(networkId, accountId, funder.fundingKeyPair);
    fundingAccountDetails = funder;
    fundingAccount = new accounts_1.Account(connection, accountId);
    return null;
});
exports.updateFunder = updateFunder;
/**
 * This allows the desired Keypom contract ID to be set. By default, the most up-to-date Keypom contract for the given network is set during initKeypom.
 *
 * @param {string} keypomContractId The account ID that should be used for the Keypom contract.
 *
 * @example
 * After initializing the SDK, the Keypom contract ID is updated.
 * ```js
 * const path = require("path");
 * const homedir = require("os").homedir();
 * const { KeyPair, keyStores, connect } = require("near-api-js");
 * const { initKeypom, updateKeypomContractId, getDrops } = require("keypom-js");
 *
 *	// Initialize the SDK for the given network and NEAR connection
 *	await initKeypom({
 *		network: "testnet",
 *	});
 *
 *	// Update the current Keypom contract ID
 *	updateKeypomContractId({
 *		keypomContractId: "v1.keypom.testnet"
 *	})
 *
 *	//Get the drops for the given owner
 *	const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 *	console.log('dropsForOwner: ', dropsForOwner)
 *
 *	return;
 * ```
 * @group Keypom SDK Environment
 */
const updateKeypomContractId = ({ keypomContractId, }) => {
    (0, checks_1.assert)(near !== undefined, 'You must initialize the SDK via `initKeypom` before updating the Keypom contract ID.');
    (0, checks_1.assert)((0, checks_1.isValidKeypomContract)(keypomContractId) === true, 'The keypom contract passed in must be an official Keypom contract for the given network.');
    if ((0, checks_1.isSupportedKeypomContract)(keypomContractId) !== true) {
        console.warn('The Keypom contract you are using is not the latest version. Most methods will be unavailable. Please use the latest contract: v1-3.keypom.near or v1-3.keypom.testnet');
    }
    contractId = receiverId = keypomContractId;
    contractAccount = new accounts_1.Account(connection, contractId);
    return null;
};
exports.updateKeypomContractId = updateKeypomContractId;

'''
'''--- packages/core/lib/lib/keys.d.ts ---
import { BrowserWalletBehaviour, Wallet } from '@near-wallet-selector/core/lib/wallet/wallet.types';
import { Account } from '@near-js/accounts';
import { CreateOrAddReturn } from './types/params';
import { ProtocolReturnedDrop } from './types/protocol';
type AnyWallet = BrowserWalletBehaviour | Wallet;
/**
 * Add keys that are manually generated and passed in, or automatically generated to an existing drop. If they're
 * automatically generated, they can be based off a set of entropy. For NFT and FT drops, assets can automatically be sent to Keypom to register keys as part of the payload.
 * The deposit is estimated based on parameters that are passed in and the transaction can be returned instead of signed and sent to the network. This can allow you to get the
 * required deposit from the return value and use that to fund the account's Keypom balance to avoid multiple transactions being signed in the case of a drop with many keys.
 *
 * @return {Promise<CreateOrAddReturn>} Object containing: the drop ID, the responses of the execution, as well as any auto generated keys (if any).
 *
 * @example
 * Create a basic empty simple drop and add 10 keys. Each key is completely random:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create an empty simple drop with no keys.
 * const {dropId} = await createDrop({
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Add 10 completely random keys. The return value `keys` contains information about the generated keys
 * const {keys} = await addKeys({
 * 	dropId,
 * 	numKeys: 10
 * })
 *
 * console.log('public keys: ', keys.publicKeys);
 * console.log('private keys: ', keys.secretKeys);
 * ```
 *
 * @example
 * Init funder with root entropy, create empty drop and add generate deterministic keys. Compare with manually generated keys:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. Root entropy is passed into the funder account so any generated keys
 * // Will be based off that entropy.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1",
 * 		rootEntropy: "my-global-secret-password"
 * 	}
 * });
 *
 * // Create a simple drop with no keys
 * const { dropId } = await createDrop({
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Add 5 keys to the empty simple drop. Each key will be derived based on the rootEntropy of the funder, the drop ID, and key nonce.
 * const {keys: keysFromDrop} = await addKeys({
 * 	dropId,
 * 	numKeys: 5
 * })
 *
 * // Deterministically Generate the Private Keys:
 * const nonceDropIdMeta = Array.from({length: 5}, (_, i) => `${dropId}_${i}`);
 * const manualKeys = await generateKeys({
 * 	numKeys: 5,
 * 	rootEntropy: "my-global-secret-password",
 * 	metaEntropy: nonceDropIdMeta
 * })
 *
 * // Get the public and private keys from the keys generated by addKeys
 * const {publicKeys, secretKeys} = keysFromDrop;
 * // Get the public and private keys from the keys that were manually generated
 * const {publicKeys: pubKeysGenerated, secretKeys: secretKeysGenerated} = manualKeys;
 * // These should match!
 * console.log('secretKeys: ', secretKeys)
 * console.log('secretKeysGenerated: ', secretKeysGenerated)
 *
 * // These should match!
 * console.log('publicKeys: ', publicKeys)
 * console.log('pubKeysGenerated: ', pubKeysGenerated)
 * ```
 *
 * @example
 * Create an empty drop and add manually created keys:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create an empty simple drop using the keys that were generated. Since keys are passed in, the return value won't contain information about the keys.
 * const {dropId} = await createDrop({
 * 	publicKeys,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Generate 10 random keys
 * const {publicKeys} = await generateKeys({
 * 	numKeys: 10
 * });
 *
 * // Add keys to the drop using the keys that were generated. Since keys are passed in, the return value won't contain information about the keys.
 * await addKeys({
 * 	publicKeys,
 * 	dropId
 * })
 * ```
 * @group Creating, And Claiming Drops
 */
export declare const addKeys: ({ account, wallet, dropId, drop, numKeys, publicKeys, nftTokenIds, rootEntropy, basePassword, passwordProtectedUses, extraDepositNEAR, extraDepositYocto, useBalance, returnTransactions, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /**
     * Specify how many keys should be generated for the drop. If the funder has rootEntropy set OR rootEntropy is passed in, the keys will be
     * deterministically generated using the drop ID, key nonce, and entropy. Otherwise, each key will be generated randomly.
     */
    numKeys: number;
    /** Pass in a custom set of publicKeys to add to the drop. If this is not passed in, keys will be generated based on the numKeys parameter. */
    publicKeys?: string[];
    /**  Specify the drop ID for which you want to add keys to. */
    dropId?: string;
    /** If the drop information from getDropInformation is already known to the client, it can be passed in instead of the drop ID to reduce computation. */
    drop?: ProtocolReturnedDrop;
    /**
     * If the drop type is an NFT drop, the token IDs can be passed in so that the tokens are automatically sent to the Keypom contract rather
     * than having to do two separate transactions. A maximum of 2 token IDs can be sent during the `addKeys` function. To send more token IDs in
     * order to register key uses, use the `nftTransferCall` function.
     */
    nftTokenIds?: string[];
    /** Specify an entropy to use for generating keys (will overload the funder's rootEntropy if applicable). This parameter only matters if the publicKeys variable is not passed in. */
    rootEntropy?: string;
    /** For doing password protected drops, this is the base password that will be used to generate all the passwords. It will be double hashed with the public keys. If specified, by default, all key uses will have their own unique password unless passwordProtectedUses is passed in. */
    basePassword?: string;
    /** For doing password protected drops, specifies exactly which uses will be password protected. The uses are NOT zero indexed (i.e 1st use = 1). Each use will have a different, unique password generated via double hashing the base password + public key + key use. */
    passwordProtectedUses?: number[];
    /** For Public Sales, drops might require an additional fee for adding keys. This specifies the amount of $NEAR in human readable format (i.e `1.5` = 1.5 $NEAR) */
    extraDepositNEAR?: number;
    /** For Public Sales, drops might require an additional fee for adding keys. This specifies the amount of $NEAR in yoctoNEAR (i.e `1` = 1 $yoctoNEAR = 1e-24 $NEAR) */
    extraDepositYocto?: string;
    /** If the account has a balance within the Keypom contract, set this to true to avoid the need to attach a deposit. If the account doesn't have enough balance, an error will throw. */
    useBalance?: boolean;
    /** If true, the transaction will be returned instead of being signed and sent. This is useful for getting the requiredDeposit from the return value without actually signing the transaction. */
    returnTransactions?: boolean;
}) => Promise<CreateOrAddReturn>;
/**
 * Delete a set of keys from a drop and optionally withdraw any remaining balance you have on the Keypom contract.
 *
 * @example
 * Create a drop with 5 keys and delete the first one:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create the simple drop with 5 random keys
 * const {keys, dropId} = await createDrop({
 * 	numKeys: 5,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * await deleteKeys({
 * 	dropId,
 * 	publicKeys: keys.publicKeys[0] // Can be wrapped in an array as well
 * })
 * ```
 * @group Deleting State
 */
export declare const deleteKeys: ({ account, wallet, publicKeys, dropId, withdrawBalance, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** Specify a set of public keys to delete. If deleting a single publicKey, the string can be passed in without wrapping it in an array. */
    publicKeys: string[] | string;
    /** Which drop ID do the keys belong to? */
    dropId: string;
    /** Whether or not to withdraw any remaining balance on the Keypom contract. */
    withdrawBalance?: boolean;
}) => Promise<any>;
export {};

'''
'''--- packages/core/lib/lib/keys.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteKeys = exports.addKeys = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const utils_1 = require("@near-js/utils");
const checks_1 = require("./checks");
const keypom_1 = require("./keypom");
const keypom_utils_1 = require("./keypom-utils");
const views_1 = require("./views");
const transactions_1 = require("@near-js/transactions");
/**
 * Add keys that are manually generated and passed in, or automatically generated to an existing drop. If they're
 * automatically generated, they can be based off a set of entropy. For NFT and FT drops, assets can automatically be sent to Keypom to register keys as part of the payload.
 * The deposit is estimated based on parameters that are passed in and the transaction can be returned instead of signed and sent to the network. This can allow you to get the
 * required deposit from the return value and use that to fund the account's Keypom balance to avoid multiple transactions being signed in the case of a drop with many keys.
 *
 * @return {Promise<CreateOrAddReturn>} Object containing: the drop ID, the responses of the execution, as well as any auto generated keys (if any).
 *
 * @example
 * Create a basic empty simple drop and add 10 keys. Each key is completely random:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create an empty simple drop with no keys.
 * const {dropId} = await createDrop({
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Add 10 completely random keys. The return value `keys` contains information about the generated keys
 * const {keys} = await addKeys({
 * 	dropId,
 * 	numKeys: 10
 * })
 *
 * console.log('public keys: ', keys.publicKeys);
 * console.log('private keys: ', keys.secretKeys);
 * ```
 *
 * @example
 * Init funder with root entropy, create empty drop and add generate deterministic keys. Compare with manually generated keys:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. Root entropy is passed into the funder account so any generated keys
 * // Will be based off that entropy.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1",
 * 		rootEntropy: "my-global-secret-password"
 * 	}
 * });
 *
 * // Create a simple drop with no keys
 * const { dropId } = await createDrop({
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Add 5 keys to the empty simple drop. Each key will be derived based on the rootEntropy of the funder, the drop ID, and key nonce.
 * const {keys: keysFromDrop} = await addKeys({
 * 	dropId,
 * 	numKeys: 5
 * })
 *
 * // Deterministically Generate the Private Keys:
 * const nonceDropIdMeta = Array.from({length: 5}, (_, i) => `${dropId}_${i}`);
 * const manualKeys = await generateKeys({
 * 	numKeys: 5,
 * 	rootEntropy: "my-global-secret-password",
 * 	metaEntropy: nonceDropIdMeta
 * })
 *
 * // Get the public and private keys from the keys generated by addKeys
 * const {publicKeys, secretKeys} = keysFromDrop;
 * // Get the public and private keys from the keys that were manually generated
 * const {publicKeys: pubKeysGenerated, secretKeys: secretKeysGenerated} = manualKeys;
 * // These should match!
 * console.log('secretKeys: ', secretKeys)
 * console.log('secretKeysGenerated: ', secretKeysGenerated)
 *
 * // These should match!
 * console.log('publicKeys: ', publicKeys)
 * console.log('pubKeysGenerated: ', pubKeysGenerated)
 * ```
 *
 * @example
 * Create an empty drop and add manually created keys:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create an empty simple drop using the keys that were generated. Since keys are passed in, the return value won't contain information about the keys.
 * const {dropId} = await createDrop({
 * 	publicKeys,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Generate 10 random keys
 * const {publicKeys} = await generateKeys({
 * 	numKeys: 10
 * });
 *
 * // Add keys to the drop using the keys that were generated. Since keys are passed in, the return value won't contain information about the keys.
 * await addKeys({
 * 	publicKeys,
 * 	dropId
 * })
 * ```
 * @group Creating, And Claiming Drops
 */
const addKeys = ({ account, wallet, dropId, drop, numKeys, publicKeys, nftTokenIds, rootEntropy, basePassword, passwordProtectedUses, extraDepositNEAR, extraDepositYocto, useBalance = false, returnTransactions = false, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { near, gas, contractId, receiverId, getAccount, execute, fundingAccountDetails, } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    (0, checks_1.assert)(drop || dropId, 'Either a dropId or drop object must be passed in.');
    (0, checks_1.assert)(numKeys || (publicKeys === null || publicKeys === void 0 ? void 0 : publicKeys.length), 'Either pass in publicKeys or set numKeys to a positive non-zero value.');
    (0, checks_1.assert)((0, checks_1.isSupportedKeypomContract)(contractId) === true, 'Only the latest Keypom contract can be used to call this methods. Please update the contract');
    account = yield getAccount({ account, wallet });
    const pubKey = yield account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
    const { drop_id, owner_id, required_gas, deposit_per_use, config, ft: ftData, nft: nftData, fc: fcData, next_key_id, } = drop || (yield (0, views_1.getDropInformation)({ dropId: dropId }));
    dropId = drop_id;
    const uses_per_key = (config === null || config === void 0 ? void 0 : config.uses_per_key) || 1;
    // If the contract is v1-3 or lower, just check if owner is the same as the calling account. If it's v1-4 or higher, check if the calling account has the permission to add keys.
    if (!contractId.includes('v1-4.keypom')) {
        (0, checks_1.assert)(owner_id === account.accountId, 'Calling account is not the owner of this drop.');
    }
    else {
        const canAddKeys = yield (0, views_1.canUserAddKeys)({
            accountId: account.accountId,
            dropId,
        });
        (0, checks_1.assert)(canAddKeys == true, 'Calling account does not have permission to add keys to this drop.');
    }
    // If there are no publicKeys being passed in, we should generate our own based on the number of keys
    let keys;
    if (!publicKeys) {
        // Default root entropy is what is passed in. If there wasn't any, we should check if the funding account contains some.
        const rootEntropyUsed = rootEntropy || (fundingAccountDetails === null || fundingAccountDetails === void 0 ? void 0 : fundingAccountDetails.rootEntropy);
        // If either root entropy was passed into the function or the funder has some set, we should use that.
        if (rootEntropyUsed) {
            // Create an array of size numKeys with increasing strings from next_key_id -> next_key_id + numKeys - 1. Each element should also contain the dropId infront of the string
            const nonceDropIdMeta = Array.from({ length: numKeys }, (_, i) => `${drop_id}_${next_key_id + i}`);
            keys = yield (0, keypom_utils_1.generateKeys)({
                numKeys,
                rootEntropy: rootEntropyUsed,
                metaEntropy: nonceDropIdMeta,
            });
        }
        else {
            // No entropy is provided so all keys should be fully random
            keys = yield (0, keypom_utils_1.generateKeys)({
                numKeys,
            });
        }
        publicKeys = keys.publicKeys;
    }
    numKeys = publicKeys.length;
    (0, checks_1.assert)(numKeys <= 100, 'Cannot add more than 100 keys at once');
    let passwords;
    if (basePassword) {
        (0, checks_1.assert)(numKeys <= 50, 'Cannot add more than 50 keys at once with passwords');
        // Generate the passwords with the base password and public keys. By default, each key will have a unique password for all of its uses unless passwordProtectedUses is passed in
        passwords = yield (0, keypom_utils_1.generatePerUsePasswords)({
            publicKeys: publicKeys,
            basePassword,
            uses: passwordProtectedUses ||
                Array.from({ length: uses_per_key }, (_, i) => i + 1),
        });
    }
    const camelFTData = (0, keypom_utils_1.toCamel)(ftData);
    const camelFCData = (0, keypom_utils_1.toCamel)(fcData);
    let requiredDeposit = yield (0, keypom_utils_1.estimateRequiredDeposit)({
        near: near,
        depositPerUse: deposit_per_use,
        numKeys,
        usesPerKey: uses_per_key,
        attachedGas: parseInt(required_gas),
        storage: (0, utils_1.parseNearAmount)('0.2'),
        fcData: camelFCData,
        ftData: camelFTData,
    });
    // If there is any extra deposit needed, add it to the required deposit
    extraDepositYocto = extraDepositYocto
        ? new bn_js_1.default(extraDepositYocto)
        : new bn_js_1.default('0');
    if (extraDepositNEAR) {
        extraDepositYocto = new bn_js_1.default((0, utils_1.parseNearAmount)(extraDepositNEAR.toString()));
    }
    requiredDeposit = new bn_js_1.default(requiredDeposit).add(extraDepositYocto).toString();
    let hasBalance = false;
    if (useBalance) {
        const userBal = new bn_js_1.default(yield (0, views_1.getUserBalance)({ accountId: account.accountId }));
        if (userBal.lt(new bn_js_1.default(requiredDeposit))) {
            throw new Error('Insufficient balance on Keypom to create drop. Use attached deposit instead.');
        }
        hasBalance = true;
    }
    let transactions = [];
    const txn = yield (0, keypom_utils_1.convertBasicTransaction)({
        txnInfo: {
            receiverId,
            signerId: account.accountId,
            actions: [
                {
                    enum: 'FunctionCall',
                    functionCall: {
                        methodName: 'add_keys',
                        args: (0, transactions_1.stringifyJsonOrBytes)({
                            drop_id,
                            public_keys: publicKeys,
                            passwords_per_use: passwords,
                        }),
                        gas,
                        deposit: !hasBalance ? requiredDeposit : undefined,
                    },
                },
            ],
        },
        signerId: account.accountId,
        signerPk: pubKey
    });
    transactions.push(txn);
    if (ftData === null || ftData === void 0 ? void 0 : ftData.contract_id) {
        transactions.push(yield (0, keypom_utils_1.ftTransferCall)({
            account: account,
            contractId: ftData.contract_id,
            absoluteAmount: new bn_js_1.default(ftData.balance_per_use)
                .mul(new bn_js_1.default(numKeys))
                .mul(new bn_js_1.default(uses_per_key))
                .toString(),
            dropId: drop_id,
            returnTransaction: true,
        }));
    }
    const tokenIds = nftTokenIds;
    if (nftData && tokenIds && (tokenIds === null || tokenIds === void 0 ? void 0 : tokenIds.length) > 0) {
        if (tokenIds.length > 2) {
            throw new Error('You can only automatically register 2 NFTs with \'createDrop\'. If you need to register more NFTs you can use the method \'nftTransferCall\' after you create the drop.');
        }
        const nftTXs = (yield (0, keypom_utils_1.nftTransferCall)({
            account: account,
            contractId: nftData.contract_id,
            tokenIds,
            dropId: dropId.toString(),
            returnTransactions: true,
        }));
        transactions = transactions.concat(nftTXs);
    }
    if (returnTransactions) {
        return { keys, dropId: drop_id, transactions, requiredDeposit };
    }
    const responses = yield execute({ transactions, account, wallet });
    return { responses, dropId: drop_id, keys, requiredDeposit };
});
exports.addKeys = addKeys;
/**
 * Delete a set of keys from a drop and optionally withdraw any remaining balance you have on the Keypom contract.
 *
 * @example
 * Create a drop with 5 keys and delete the first one:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create the simple drop with 5 random keys
 * const {keys, dropId} = await createDrop({
 * 	numKeys: 5,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * await deleteKeys({
 * 	dropId,
 * 	publicKeys: keys.publicKeys[0] // Can be wrapped in an array as well
 * })
 * ```
 * @group Deleting State
 */
const deleteKeys = ({ account, wallet, publicKeys, dropId, withdrawBalance = false, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { receiverId, execute, getAccount, contractId } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)((0, checks_1.isSupportedKeypomContract)(contractId) === true, 'Only the latest Keypom contract can be used to call this methods. Please update the contract');
    const { owner_id, drop_id, registered_uses, ft, nft } = yield (0, views_1.getDropInformation)({ dropId });
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    (0, checks_1.assert)(owner_id == account.accountId, 'Only the owner of the drop can delete keys.');
    const actions = [];
    if ((ft || nft) && registered_uses > 0) {
        actions.push({
            enum: 'FunctionCall',
            functionCall: {
                methodName: 'refund_assets',
                args: (0, transactions_1.stringifyJsonOrBytes)({
                    drop_id,
                }),
                gas: '100000000000000',
                deposit: '0'
            },
        });
    }
    // If the publicKeys provided is not an array (simply the string for 1 key), we convert it to an array of size 1 so that we can use the same logic for both cases
    if (publicKeys && !Array.isArray(publicKeys)) {
        publicKeys = [publicKeys];
    }
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'delete_keys',
            args: (0, transactions_1.stringifyJsonOrBytes)({
                drop_id,
                public_keys: publicKeys.map(keypom_utils_1.key2str),
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });
    if (withdrawBalance) {
        actions.push({
            enum: 'FunctionCall',
            functionCall: {
                methodName: 'withdraw_from_balance',
                args: (0, transactions_1.stringifyJsonOrBytes)({}),
                gas: '100000000000000',
                deposit: '0'
            },
        });
    }
    const transactions = [
        {
            receiverId,
            actions,
        },
    ];
    return execute({ transactions, account, wallet });
});
exports.deleteKeys = deleteKeys;

'''
'''--- packages/core/lib/lib/sales.d.ts ---
import { BrowserWalletBehaviour, Wallet } from '@near-wallet-selector/core/lib/wallet/wallet.types';
import { Account } from '@near-js/accounts';
type AnyWallet = BrowserWalletBehaviour | Wallet;
/**
 * Add a list of account IDs to a drop's sale allowlist. If the allowlist is empty, anyone can purchase keys. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 * const {dropId} = await createDrop({
 * 		numKeys: 0,
 * 		depositPerUseNEAR: 0.1,
 * 		config: {
 * 			sale: {
 * 				maxNumKeys: 2,
 * 				pricePerKeyNEAR: 1
 * 			}
 * 		}
 * 	});
 *
 * 	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 * 	t.is(canAddKeys, true);
 *
 * 	await addToSaleAllowlist({dropId, accountIds: ["barfoo.testnet"]});
 * 	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 * 	t.is(canAddKeys, false);
 *  ```
 * @group Public Sale Functions
 */
export declare const addToSaleAllowlist: ({ account, wallet, dropId, accountIds, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop */
    dropId: string;
    /** A list of account IDs that should be added to the sale allowlist */
    accountIds: string[];
}) => Promise<any>;
/**
 * Remove a list of account IDs from a drop's sale allowlist. If the allowlist is empty, anyone can purchase keys. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1,
 *				allowlist: ["foobar.testnet", "barfoo.testnet"]
 *			}
 *		}
 *	});
 *
 *	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "not_in_allowlist.testnet"});
 *	t.is(canAddKeys, false);
 *
 *	await removeFromSaleAllowlist({dropId, accountIds: ["foobar.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, false);
 *
 *	await removeFromSaleAllowlist({dropId, accountIds: ["barfoo.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *  ```
 * @group Public Sale Functions
 */
export declare const removeFromSaleAllowlist: ({ account, wallet, dropId, accountIds, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop */
    dropId: string;
    /** A list of account IDs that should be removed from the sale's allowlist */
    accountIds: string[];
}) => Promise<any>;
/**
 * Add a list of account IDs to a drop's sale blocklist. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1
 *			}
 *		}
 *	});
 *
 *	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *
 *	await addToSaleBlocklist({dropId, accountIds: ["foobar.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, false);
 *  ```
 * @group Public Sale Functions
 */
export declare const addToSaleBlocklist: ({ account, wallet, dropId, accountIds, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop */
    dropId: string;
    /** A list of account IDs that should be added to the sale blocklist */
    accountIds: string[];
}) => Promise<any>;
/**
 * Remove a list of account IDs from a drop's sale blocklist. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1,
 *				blocklist: ["foobar.testnet"]
 *			}
 *		}
 *	});
 *
 *	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, false);
 *
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "not_in_blocklist.testnet"});
 *	t.is(canAddKeys, true);
 *
 *	await removeFromSaleBlocklist({dropId, accountIds: ["foobar.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *  ```
 * @group Public Sale Functions
 */
export declare const removeFromSaleBlocklist: ({ account, wallet, dropId, accountIds, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop */
    dropId: string;
    /** A list of account IDs that should be removed from the sale's allowlist */
    accountIds: string[];
}) => Promise<any>;
/**
 * Remove a list of account IDs from a drop's sale blocklist. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1
 *			}
 *		}
 *	});
 *
 *	await updateSale({
 *		dropId,
 *		pricePerKeyNEAR: 2
 *	})
 *  ```
 *
 * @group Public Sale Functions
 */
export declare const updateSale: ({ account, wallet, dropId, maxNumKeys, pricePerKeyNEAR, pricePerKeyYocto, autoWithdrawFunds, start, end, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop */
    dropId: string;
    /** Maximum number of keys that can be added to this drop. If None, there is no max. */
    maxNumKeys?: number;
    /**
     * Amount of $NEAR that the user needs to attach (if they are not the funder) on top of costs. This amount will be
     * Automatically sent to the funder's balance. If None, the keys are free to the public.
     */
    pricePerKeyNEAR?: number;
    pricePerKeyYocto?: string;
    /**
     * Should the revenue generated be sent to the funder's account balance or
     * automatically withdrawn and sent to their NEAR wallet?
     */
    autoWithdrawFunds?: boolean;
    /**
     * Minimum block timestamp before the public sale starts. If None, keys can be added immediately
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    start?: number;
    /**
     * Block timestamp dictating the end of the public sale. If None, keys can be added indefinitely
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    end?: number;
}) => Promise<any>;
export {};

'''
'''--- packages/core/lib/lib/sales.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateSale = exports.removeFromSaleBlocklist = exports.addToSaleBlocklist = exports.removeFromSaleAllowlist = exports.addToSaleAllowlist = void 0;
// import {
// 	parseNearAmount
// } from "near-api-js/lib/utils/format";
const checks_1 = require("./checks");
const keypom_1 = require("./keypom");
const utils_1 = require("@near-js/utils");
const views_1 = require("./views");
const transactions_1 = require("@near-js/transactions");
/**
 * Add a list of account IDs to a drop's sale allowlist. If the allowlist is empty, anyone can purchase keys. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 * const {dropId} = await createDrop({
 * 		numKeys: 0,
 * 		depositPerUseNEAR: 0.1,
 * 		config: {
 * 			sale: {
 * 				maxNumKeys: 2,
 * 				pricePerKeyNEAR: 1
 * 			}
 * 		}
 * 	});
 *
 * 	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 * 	t.is(canAddKeys, true);
 *
 * 	await addToSaleAllowlist({dropId, accountIds: ["barfoo.testnet"]});
 * 	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 * 	t.is(canAddKeys, false);
 *  ```
 * @group Public Sale Functions
 */
const addToSaleAllowlist = ({ account, wallet, dropId, accountIds, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const { receiverId, execute, getAccount } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)(dropId && accountIds, 'Must pass in a drop ID and a list of account IDs to add to the sale allowlist.');
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    const dropInfo = yield (0, views_1.getDropInformation)({ dropId });
    (0, checks_1.assert)(account.accountId == dropInfo.owner_id, 'Only the owner of the drop can add accounts to the sale allowlist.');
    (0, checks_1.assert)((_a = dropInfo.config) === null || _a === void 0 ? void 0 : _a.sale, 'The drop config must have a sale in order to add accounts to the sale allowlist.');
    const actions = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'add_to_sale_allowlist',
            args: (0, transactions_1.stringifyJsonOrBytes)({
                drop_id: dropId,
                account_ids: accountIds,
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });
    const transactions = [
        {
            receiverId,
            actions,
        },
    ];
    return execute({ transactions, account, wallet });
});
exports.addToSaleAllowlist = addToSaleAllowlist;
/**
 * Remove a list of account IDs from a drop's sale allowlist. If the allowlist is empty, anyone can purchase keys. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1,
 *				allowlist: ["foobar.testnet", "barfoo.testnet"]
 *			}
 *		}
 *	});
 *
 *	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "not_in_allowlist.testnet"});
 *	t.is(canAddKeys, false);
 *
 *	await removeFromSaleAllowlist({dropId, accountIds: ["foobar.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, false);
 *
 *	await removeFromSaleAllowlist({dropId, accountIds: ["barfoo.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *  ```
 * @group Public Sale Functions
 */
const removeFromSaleAllowlist = ({ account, wallet, dropId, accountIds, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _b;
    const { receiverId, execute, getAccount } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)(dropId && accountIds, 'Must pass in a drop ID and a list of account IDs to remove from the sale allowlist.');
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    const dropInfo = yield (0, views_1.getDropInformation)({ dropId });
    (0, checks_1.assert)(account.accountId == dropInfo.owner_id, 'Only the owner of the drop can remove accounts from the sale allowlist.');
    (0, checks_1.assert)((_b = dropInfo.config) === null || _b === void 0 ? void 0 : _b.sale, 'The drop config must have a sale in order to remove accounts from the sale allowlist.');
    const actions = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'remove_from_sale_allowlist',
            args: (0, transactions_1.stringifyJsonOrBytes)({
                drop_id: dropId,
                account_ids: accountIds,
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });
    const transactions = [
        {
            receiverId,
            actions,
        },
    ];
    return execute({ transactions, account, wallet });
});
exports.removeFromSaleAllowlist = removeFromSaleAllowlist;
/**
 * Add a list of account IDs to a drop's sale blocklist. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1
 *			}
 *		}
 *	});
 *
 *	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *
 *	await addToSaleBlocklist({dropId, accountIds: ["foobar.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, false);
 *  ```
 * @group Public Sale Functions
 */
const addToSaleBlocklist = ({ account, wallet, dropId, accountIds, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _c;
    const { receiverId, execute, getAccount } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)(dropId && accountIds, 'Must pass in a drop ID and a list of account IDs to add to the sale blocklist.');
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    const dropInfo = yield (0, views_1.getDropInformation)({ dropId });
    (0, checks_1.assert)(account.accountId == dropInfo.owner_id, 'Only the owner of the drop can add accounts to the sale blocklist.');
    (0, checks_1.assert)((_c = dropInfo.config) === null || _c === void 0 ? void 0 : _c.sale, 'The drop config must have a sale in order to add accounts to the sale blocklist.');
    const actions = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'add_to_sale_blocklist',
            args: (0, transactions_1.stringifyJsonOrBytes)({
                drop_id: dropId,
                account_ids: accountIds,
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });
    const transactions = [
        {
            receiverId,
            actions,
        },
    ];
    return execute({ transactions, account, wallet });
});
exports.addToSaleBlocklist = addToSaleBlocklist;
/**
 * Remove a list of account IDs from a drop's sale blocklist. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1,
 *				blocklist: ["foobar.testnet"]
 *			}
 *		}
 *	});
 *
 *	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, false);
 *
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "not_in_blocklist.testnet"});
 *	t.is(canAddKeys, true);
 *
 *	await removeFromSaleBlocklist({dropId, accountIds: ["foobar.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *  ```
 * @group Public Sale Functions
 */
const removeFromSaleBlocklist = ({ account, wallet, dropId, accountIds, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _d;
    const { receiverId, execute, getAccount } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)(dropId && accountIds, 'Must pass in a drop ID and a list of account IDs to remove from the sale blocklist.');
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    const dropInfo = yield (0, views_1.getDropInformation)({ dropId });
    (0, checks_1.assert)(account.accountId == dropInfo.owner_id, 'Only the owner of the drop can remove accounts from the sale blocklist.');
    (0, checks_1.assert)((_d = dropInfo.config) === null || _d === void 0 ? void 0 : _d.sale, 'The drop config must have a sale in order to remove accounts from the sale blocklist.');
    const actions = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'remove_from_sale_blocklist',
            args: (0, transactions_1.stringifyJsonOrBytes)({
                drop_id: dropId,
                account_ids: accountIds,
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });
    const transactions = [
        {
            receiverId,
            actions,
        },
    ];
    return execute({ transactions, account, wallet });
});
exports.removeFromSaleBlocklist = removeFromSaleBlocklist;
/**
 * Remove a list of account IDs from a drop's sale blocklist. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1
 *			}
 *		}
 *	});
 *
 *	await updateSale({
 *		dropId,
 *		pricePerKeyNEAR: 2
 *	})
 *  ```
 *
 * @group Public Sale Functions
 */
const updateSale = ({ account, wallet, dropId, maxNumKeys, pricePerKeyNEAR, pricePerKeyYocto, autoWithdrawFunds, start, end, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _e;
    const { receiverId, execute, getAccount } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)(dropId &&
        (maxNumKeys ||
            pricePerKeyNEAR ||
            pricePerKeyYocto ||
            autoWithdrawFunds ||
            start ||
            end), 'Must pass in a drop ID and at least one of the other sale parameters to update');
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), 'Passed in account is not a valid account object.');
    account = yield getAccount({ account, wallet });
    const dropInfo = yield (0, views_1.getDropInformation)({ dropId });
    (0, checks_1.assert)(account.accountId == dropInfo.owner_id, 'Only the owner of the drop can update the sale.');
    (0, checks_1.assert)((_e = dropInfo.config) === null || _e === void 0 ? void 0 : _e.sale, 'The drop config must have a sale in order to be updated.');
    const actions = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'update_sale',
            args: (0, transactions_1.stringifyJsonOrBytes)({
                drop_id: dropId,
                max_num_keys: maxNumKeys,
                price_per_key: pricePerKeyYocto || pricePerKeyNEAR
                    ? (0, utils_1.parseNearAmount)(pricePerKeyNEAR.toString())
                    : undefined,
                auto_withdraw_funds: autoWithdrawFunds,
                start,
                end,
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });
    const transactions = [
        {
            receiverId,
            actions,
        },
    ];
    return execute({ transactions, account, wallet });
});
exports.updateSale = updateSale;

'''
'''--- packages/core/lib/lib/trial-accounts/pre-trial.d.ts ---
import { BrowserWalletBehaviour, Wallet } from "@near-wallet-selector/core/lib/wallet/wallet.types";
import { Account } from "@near-js/accounts";
import { DropConfig } from "../types/drops";
import { CreateOrAddReturn } from "../types/params";
type AnyWallet = BrowserWalletBehaviour | Wallet;
export declare const KEY_LIMIT = 50;
/**
 * Creates a new trial account drop which can be used to instantly sign users into decentralized applications that support the Keypom wallet selector plugin.
 *
 * The trial account is locked into certain behaviors depending on what is passed into `createTrialAccountDrop`. These behaviors include callable contracts, methods on
 * those contracts, the maximum amount of $NEAR that can be spent on each contract as well as an exit condition. Once the trial account has run out of funds, the only way to
 * retain any assets from the trial or continue using the account ID, is to repay the specific account ID for the amount of $NEAR specified.
 *
 * @return {Promise<CreateOrAddReturn>} Object containing: the drop ID, the responses of the execution, as well as any auto generated keys (if any).
 *
 * @example
 * Creating a trial account with any callable methods, an amount of 0.5 $NEAR and 5 keys.
 * ```js
 * const {keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}} = await createTrialAccountDrop({
 *     contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *     trialFundsNEAR: 0.5,
 *     callableContracts: ['dev-1676298343226-57701595703433'],
 *     callableMethods: ['*'],
 *     amounts: ['0.5'],
 *     numKeys: 5,
 *     config: {
 *         dropRoot: "linkdrop-beta.keypom.testnet"
 *     }
 * })
 *
 * const newAccountId = `${Date.now().toString()}.linkdrop-beta.keypom.testnet`
 * await claimTrialAccountDrop({
 *     secretKey: trialSecretKeys[0],
 *     desiredAccountId: newAccountId,
 * })
 *
 * console.log(`
 *
 * ${JSON.stringify({
 *     account_id: newAccountId,
 *     public_key: trialPublicKeys[0],
 *     private_key: trialSecretKeys[0]
 * })}
 *
 * `)
 *
 * console.log(`http://localhost:1234/keypom-url/${newAccountId}#${trialSecretKeys[0]}`)
 *
 * ```
 * @group Trial Accounts
 */
export declare const createTrialAccountDrop: ({ account, wallet, contractBytes, startingBalanceNEAR, startingBalanceYocto, callableContracts, maxAttachableNEARPerContract, maxAttachableYoctoPerContract, callableMethods, trialEndFloorNEAR, trialEndFloorYocto, repayAmountNEAR, repayAmountYocto, repayTo, dropId, config, numKeys, publicKeys, rootEntropy, metadata, useBalance, returnTransactions, successUrl, }: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** Bytes of the trial account smart contract */
    contractBytes: number[];
    /** How much $NEAR should the trial account start with? Unit in $NEAR (i.e `1` = 1 $NEAR) */
    startingBalanceNEAR?: string | number;
    /** How much $NEAR should the trial account start with? Unit in yoctoNEAR (1 yoctoNEAR = 1e-24 $NEAR) */
    startingBalanceYocto?: string;
    /** The contracts that the trial account should be able to call. */
    callableContracts: string[];
    /** The upper bound of $NEAR that trial account is able to attach to calls associated with each contract passed in. For no upper limit, pass in `*`. Units are in $NEAR (i.e `1` = 1 $NEAR). */
    maxAttachableNEARPerContract: (string | number)[];
    /** The upper bound of $yocto that trial account is able to attach to calls associated with each contract passed in. For no upper limit, pass in `*`. Units are in $yoctoNEAR (i.e `1` = 1 $yoctoNEAR). */
    maxAttachableYoctoPerContract: string[];
    /** An array that contains the list of methods that the trial account should be able to call on each respective contract. To allow any methods to be called on the receiver contract, pass in `[*]`. */
    callableMethods: string[][];
    /** Once the account has spent more than this amount (in $NEAR), the trial is over and the exit conditions must be met. */
    trialEndFloorNEAR: string | number;
    /** Once the account has spent more than this amount (in yocto), the trial is over and the exit conditions must be met. */
    trialEndFloorYocto: string;
    /** How much $NEAR should be paid back to the specified funder in order to unlock the trial account. Unit in $NEAR (i.e `1` = 1 $NEAR) */
    repayAmountNEAR?: number | string;
    /** How much $NEAR should be paid back to the specified funder in order to unlock the trial account. Unit in yoctoNEAR (1 yoctoNEAR = 1e-24 $NEAR) */
    repayAmountYocto?: string;
    /** The account that should receive the repayment of the trial account. If not specified, the drop funder will be used. */
    repayTo?: string;
    /** Specify a custom drop ID rather than using the incrementing nonce on the contract. */
    dropId?: string;
    /** Allows specific drop behaviors to be configured such as the number of uses each key / link will have. */
    config?: DropConfig;
    /**
     * Specify how many keys should be generated for the drop. If the funder has rootEntropy set OR rootEntropy is passed in, the keys will be
     * deterministically generated using the drop ID, key nonce, and entropy. Otherwise, each key will be generated randomly.
     */
    numKeys: number;
    /** Pass in a custom set of publicKeys to add to the drop. If this is not passed in, keys will be generated based on the numKeys parameter. */
    publicKeys?: string[];
    /** Specify an entropy to use for generating keys (will overload the funder's rootEntropy if applicable). This parameter only matters if the publicKeys variable is not passed in. */
    rootEntropy?: string;
    /** String of metadata to attach to the drop. This can be whatever you would like and is optional. Often this is stringified JSON. */
    metadata?: string;
    /** If the account has a balance within the Keypom contract, set this to true to avoid the need to attach a deposit. If the account doesn't have enough balance, an error will throw. */
    useBalance?: boolean;
    /** If true, the transaction will be returned instead of being signed and sent. This is useful for getting the requiredDeposit from the return value without actually signing the transaction. */
    returnTransactions?: boolean;
    /** When signing with a wallet, a success URl can be included that the user will be redirected to once the transaction has been successfully signed. */
    successUrl?: string;
}) => Promise<CreateOrAddReturn>;
/**
 * Claim a Keypom trial account drop which will create a new account, deploy and initialize the trial account contract, and setup the account with initial conditions as specified in the drop.
 *
 * @example
 * Creating a trial account with any callable methods, an amount of 0.5 $NEAR and 5 keys.
 * ```js
 * const callableContracts = [
 * 	`v1.social08.testnet`,
 * 	'guest-book.examples.keypom.testnet',
 * ]
 *
 * const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 * = await createTrialAccountDrop({
 * 	numKeys: 1,
 * 	contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 * 	startingBalanceNEAR: 0.5,
 * 	callableContracts: callableContracts,
 * 	callableMethods: ['set:grant_write_permission', '*'],
 * 	maxAttachableNEARPerContract: callableContracts.map(() => '1'),
 * 	trialEndFloorNEAR: 0.33
 * })
 *
 * const newAccountId = `${Date.now().toString()}.linkdrop-beta.keypom.testnet`
 * await claimTrialAccountDrop({
 *     secretKey: trialSecretKeys[0],
 *     desiredAccountId: newAccountId,
 * })
 *
 * console.log(`
 *
 * ${JSON.stringify({
 *     account_id: newAccountId,
 *     public_key: trialPublicKeys[0],
 *     private_key: trialSecretKeys[0]
 * })}
 *
 * `)
 *
 * console.log(`http://localhost:1234/keypom-url/${newAccountId}#${trialSecretKeys[0]}`)
 *
 * ```
 * @group Trial Accounts
 */
export declare const claimTrialAccountDrop: ({ secretKey, desiredAccountId, }: {
    /** The private key associated with the Keypom link. This can either contain the `ed25519:` prefix or not. */
    secretKey: string;
    /** The account ID that will be created for the trial */
    desiredAccountId: string;
}) => Promise<any>;
export {};

'''
'''--- packages/core/lib/lib/trial-accounts/pre-trial.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.claimTrialAccountDrop = exports.createTrialAccountDrop = exports.KEY_LIMIT = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const crypto_1 = require("@near-js/crypto");
const transactions_1 = require("@near-js/transactions");
const utils_1 = require("@near-js/utils");
const checks_1 = require("../checks");
const keypom_1 = require("../keypom");
const keypom_utils_1 = require("../keypom-utils");
const views_1 = require("../views");
const utils_2 = require("./utils");
exports.KEY_LIMIT = 50;
/**
 * Creates a new trial account drop which can be used to instantly sign users into decentralized applications that support the Keypom wallet selector plugin.
 *
 * The trial account is locked into certain behaviors depending on what is passed into `createTrialAccountDrop`. These behaviors include callable contracts, methods on
 * those contracts, the maximum amount of $NEAR that can be spent on each contract as well as an exit condition. Once the trial account has run out of funds, the only way to
 * retain any assets from the trial or continue using the account ID, is to repay the specific account ID for the amount of $NEAR specified.
 *
 * @return {Promise<CreateOrAddReturn>} Object containing: the drop ID, the responses of the execution, as well as any auto generated keys (if any).
 *
 * @example
 * Creating a trial account with any callable methods, an amount of 0.5 $NEAR and 5 keys.
 * ```js
 * const {keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}} = await createTrialAccountDrop({
 *     contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *     trialFundsNEAR: 0.5,
 *     callableContracts: ['dev-1676298343226-57701595703433'],
 *     callableMethods: ['*'],
 *     amounts: ['0.5'],
 *     numKeys: 5,
 *     config: {
 *         dropRoot: "linkdrop-beta.keypom.testnet"
 *     }
 * })
 *
 * const newAccountId = `${Date.now().toString()}.linkdrop-beta.keypom.testnet`
 * await claimTrialAccountDrop({
 *     secretKey: trialSecretKeys[0],
 *     desiredAccountId: newAccountId,
 * })
 *
 * console.log(`
 *
 * ${JSON.stringify({
 *     account_id: newAccountId,
 *     public_key: trialPublicKeys[0],
 *     private_key: trialSecretKeys[0]
 * })}
 *
 * `)
 *
 * console.log(`http://localhost:1234/keypom-url/${newAccountId}#${trialSecretKeys[0]}`)
 *
 * ```
 * @group Trial Accounts
 */
const createTrialAccountDrop = ({ account, wallet, contractBytes, startingBalanceNEAR, startingBalanceYocto, callableContracts, maxAttachableNEARPerContract, maxAttachableYoctoPerContract, callableMethods, trialEndFloorNEAR, trialEndFloorYocto, repayAmountNEAR, repayAmountYocto, repayTo, dropId, config = {}, numKeys = 0, publicKeys, rootEntropy, metadata, useBalance = false, returnTransactions = false, successUrl, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
    const { near, networkId, gas, attachedGas, contractId, receiverId, getAccount, execute, fundingAccountDetails, } = (0, keypom_1.getEnv)();
    (0, checks_1.assert)((0, checks_1.isValidAccountObj)(account), "Passed in account is not a valid account object.");
    account = yield getAccount({ account, wallet });
    (0, checks_1.assert)((0, checks_1.isSupportedKeypomContract)(contractId) === true, "Only the latest Keypom contract can be used to call this methods. Please update the contract.");
    // Ensure that if the dropID is passed in, it's greater than 1 billion
    (0, checks_1.assert)(parseInt(dropId || "1000000000") >= 1000000000, "All custom drop IDs must be greater than 1_000_000_000");
    if (!dropId)
        dropId = Date.now().toString();
    // Ensure that the length of the callable methods, contracts, and max attachable deposit per contract are all the same
    (0, checks_1.assert)(callableMethods.length === callableContracts.length &&
        callableMethods.length ===
            (maxAttachableNEARPerContract || maxAttachableYoctoPerContract)
                .length, "The length of the callable methods, contracts, and max attachable deposit per contract must all be the same.");
    yield (0, checks_1.assertDropIdUnique)(dropId);
    const finalConfig = {
        uses_per_key: (config === null || config === void 0 ? void 0 : config.usesPerKey) || 1,
        time: config === null || config === void 0 ? void 0 : config.time,
        usage: {
            auto_delete_drop: ((_a = config === null || config === void 0 ? void 0 : config.usage) === null || _a === void 0 ? void 0 : _a.autoDeleteDrop) || false,
            auto_withdraw: ((_b = config === null || config === void 0 ? void 0 : config.usage) === null || _b === void 0 ? void 0 : _b.autoWithdraw) || true,
            permissions: (_c = config === null || config === void 0 ? void 0 : config.usage) === null || _c === void 0 ? void 0 : _c.permissions,
            refund_deposit: (_d = config === null || config === void 0 ? void 0 : config.usage) === null || _d === void 0 ? void 0 : _d.refundDeposit,
        },
        sale: (config === null || config === void 0 ? void 0 : config.sale)
            ? {
                max_num_keys: (_e = config === null || config === void 0 ? void 0 : config.sale) === null || _e === void 0 ? void 0 : _e.maxNumKeys,
                price_per_key: ((_f = config === null || config === void 0 ? void 0 : config.sale) === null || _f === void 0 ? void 0 : _f.pricePerKeyYocto) ||
                    ((_g = config === null || config === void 0 ? void 0 : config.sale) === null || _g === void 0 ? void 0 : _g.pricePerKeyNEAR)
                    ? (0, utils_1.parseNearAmount)((_j = (_h = config === null || config === void 0 ? void 0 : config.sale) === null || _h === void 0 ? void 0 : _h.pricePerKeyNEAR) === null || _j === void 0 ? void 0 : _j.toString())
                    : undefined,
                allowlist: (_k = config === null || config === void 0 ? void 0 : config.sale) === null || _k === void 0 ? void 0 : _k.allowlist,
                blocklist: (_l = config === null || config === void 0 ? void 0 : config.sale) === null || _l === void 0 ? void 0 : _l.blocklist,
                auto_withdraw_funds: (_m = config === null || config === void 0 ? void 0 : config.sale) === null || _m === void 0 ? void 0 : _m.autoWithdrawFunds,
                start: (_o = config === null || config === void 0 ? void 0 : config.sale) === null || _o === void 0 ? void 0 : _o.start,
                end: (_p = config === null || config === void 0 ? void 0 : config.sale) === null || _p === void 0 ? void 0 : _p.end,
            }
            : undefined,
        root_account_id: config === null || config === void 0 ? void 0 : config.dropRoot,
    };
    (0, checks_1.assertValidDropConfig)(finalConfig);
    // If there are no publicKeys being passed in, we should generate our own based on the number of keys
    if (!publicKeys) {
        var keys;
        // Default root entropy is what is passed in. If there wasn't any, we should check if the funding account contains some.
        const rootEntropyUsed = rootEntropy || (fundingAccountDetails === null || fundingAccountDetails === void 0 ? void 0 : fundingAccountDetails.rootEntropy);
        // If either root entropy was passed into the function or the funder has some set, we should use that.
        if (rootEntropyUsed) {
            // Create an array of size numKeys with increasing strings from 0 -> numKeys - 1. Each element should also contain the dropId infront of the string
            const nonceDropIdMeta = Array.from({ length: numKeys }, (_, i) => `${dropId}_${i}`);
            keys = yield (0, keypom_utils_1.generateKeys)({
                numKeys,
                rootEntropy: rootEntropyUsed,
                metaEntropy: nonceDropIdMeta,
            });
        }
        else {
            // No entropy is provided so all keys should be fully random
            keys = yield (0, keypom_utils_1.generateKeys)({
                numKeys,
            });
        }
        publicKeys = keys.publicKeys;
    }
    numKeys = publicKeys.length;
    /// parse args
    startingBalanceYocto = (0, keypom_utils_1.nearArgsToYocto)(startingBalanceNEAR, startingBalanceYocto);
    repayAmountYocto = (0, keypom_utils_1.nearArgsToYocto)(repayAmountNEAR, repayAmountYocto);
    trialEndFloorYocto = (0, keypom_utils_1.nearArgsToYocto)(trialEndFloorNEAR, trialEndFloorYocto);
    // If max attachable deposit per contract in NEAR is passed in, loop through and convert to yocto
    if (maxAttachableNEARPerContract) {
        maxAttachableYoctoPerContract = maxAttachableNEARPerContract.map((deposit) => {
            if (deposit == "*")
                return "*";
            return (0, utils_1.parseNearAmount)(deposit.toString()) || "0";
        });
    }
    // If !maxAttachableYoctoPerContract, create an array of the same size as callableMethods and fill it with "*"
    if (!maxAttachableYoctoPerContract)
        maxAttachableYoctoPerContract = Array(callableMethods.length).fill("*");
    const rootReceiverId = (_q = finalConfig.root_account_id) !== null && _q !== void 0 ? _q : (networkId == "testnet" ? "testnet" : "near");
    // Account Mapping Contract Changes
    callableContracts.push(keypom_1.accountMappingContract[networkId]);
    maxAttachableYoctoPerContract.push((0, utils_1.parseNearAmount)("0.002"));
    callableMethods.push(["set"]);
    // Take the storage cost into consideration for the attached deposit and trial end floor
    const storageCost = (0, utils_1.parseNearAmount)("0.3");
    const attachedDeposit = new bn_js_1.default(startingBalanceYocto)
        .add(new bn_js_1.default(storageCost))
        .toString();
    trialEndFloorYocto = new bn_js_1.default(attachedDeposit)
        .sub(new bn_js_1.default(trialEndFloorYocto))
        .toString();
    // Generate the proper args for setup:
    let actualContracts = callableContracts.join(",");
    let actualAmounts = maxAttachableYoctoPerContract.join(",");
    let actualMethods = callableMethods
        .map((method) => method.join(":"))
        .join(",");
    const createDropArgs = {
        drop_id: dropId,
        public_keys: publicKeys || [],
        deposit_per_use: "0",
        config: finalConfig,
        metadata,
        required_gas: "150000000000000",
        fc: {
            methods: [
                [
                    {
                        receiver_id: rootReceiverId,
                        method_name: "create_account_advanced",
                        //@ts-ignore
                        attached_deposit: attachedDeposit,
                        args: JSON.stringify({
                            new_account_id: "INSERT_NEW_ACCOUNT",
                            options: {
                                contract_bytes: contractBytes,
                                limited_access_keys: [
                                    {
                                        public_key: "INSERT_TRIAL_PUBLIC_KEY",
                                        allowance: "0",
                                        receiver_id: "INSERT_NEW_ACCOUNT",
                                        method_names: "execute,create_account_and_claim",
                                    },
                                ],
                            },
                        }),
                        user_args_rule: "UserPreferred",
                    },
                    {
                        receiver_id: "",
                        method_name: "setup",
                        //@ts-ignore
                        attached_deposit: "0",
                        args: JSON.stringify((0, utils_2.wrapTxnParamsForTrial)({
                            contracts: actualContracts,
                            amounts: actualAmounts,
                            methods: actualMethods,
                            funder: repayTo || account.accountId,
                            repay: repayAmountYocto,
                            floor: trialEndFloorYocto,
                        })),
                        receiver_to_claimer: true,
                    },
                ],
            ],
        },
    };
    const fcData = {
        methods: [
            [
                {
                    receiverId: rootReceiverId,
                    methodName: "create_account_advanced",
                    //@ts-ignore
                    attachedDeposit,
                    args: JSON.stringify({
                        new_account_id: "INSERT_NEW_ACCOUNT",
                        options: {
                            contract_bytes: contractBytes,
                            limited_access_keys: [
                                {
                                    public_key: "INSERT_TRIAL_PUBLIC_KEY",
                                    allowance: "0",
                                    receiver_id: "INSERT_NEW_ACCOUNT",
                                    method_names: "execute,create_account_and_claim",
                                },
                            ],
                        },
                    }),
                    userArgsRule: "UserPreferred",
                },
                {
                    receiverId: "",
                    methodName: "setup",
                    //@ts-ignore
                    attachedDeposit: "0",
                    args: JSON.stringify((0, utils_2.wrapTxnParamsForTrial)({
                        contracts: actualContracts,
                        amounts: actualAmounts,
                        methods: actualMethods,
                        funder: repayTo || account.accountId,
                        repay: repayAmountYocto,
                        floor: trialEndFloorYocto,
                    })),
                    receiverToClaimer: true,
                },
            ],
        ],
    };
    /// estimate required deposit
    const storageCalculated = (0, keypom_utils_1.getStorageBase)(createDropArgs);
    let requiredDeposit = yield (0, keypom_utils_1.estimateRequiredDeposit)({
        near: near,
        depositPerUse: "0",
        numKeys,
        usesPerKey: finalConfig.uses_per_key || 1,
        attachedGas: parseInt(attachedGas),
        storage: storageCalculated,
        fcData,
    });
    var hasBalance = false;
    if (useBalance) {
        let userBal = yield (0, views_1.getUserBalance)({ accountId: account.accountId });
        if (userBal < requiredDeposit) {
            throw new Error(`Insufficient balance on Keypom to create drop. Use attached deposit instead.`);
        }
        hasBalance = true;
    }
    const deposit = !hasBalance ? requiredDeposit : "0";
    const pk = yield account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
    const txnInfo = {
        receiverId,
        signerId: account.accountId,
        actions: [
            {
                enum: "FunctionCall",
                functionCall: {
                    methodName: "create_drop",
                    args: (0, transactions_1.stringifyJsonOrBytes)(createDropArgs),
                    gas: gas,
                    deposit,
                }
            },
        ],
    };
    const transactions = [yield (0, keypom_utils_1.convertBasicTransaction)({ txnInfo, signerId: account.accountId, signerPk: pk })];
    if (returnTransactions) {
        return { keys, dropId, transactions, requiredDeposit };
    }
    let responses = yield execute({
        transactions,
        account,
        wallet,
        successUrl,
    });
    return { responses, keys, dropId, requiredDeposit };
});
exports.createTrialAccountDrop = createTrialAccountDrop;
/**
 * Claim a Keypom trial account drop which will create a new account, deploy and initialize the trial account contract, and setup the account with initial conditions as specified in the drop.
 *
 * @example
 * Creating a trial account with any callable methods, an amount of 0.5 $NEAR and 5 keys.
 * ```js
 * const callableContracts = [
 * 	`v1.social08.testnet`,
 * 	'guest-book.examples.keypom.testnet',
 * ]
 *
 * const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 * = await createTrialAccountDrop({
 * 	numKeys: 1,
 * 	contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 * 	startingBalanceNEAR: 0.5,
 * 	callableContracts: callableContracts,
 * 	callableMethods: ['set:grant_write_permission', '*'],
 * 	maxAttachableNEARPerContract: callableContracts.map(() => '1'),
 * 	trialEndFloorNEAR: 0.33
 * })
 *
 * const newAccountId = `${Date.now().toString()}.linkdrop-beta.keypom.testnet`
 * await claimTrialAccountDrop({
 *     secretKey: trialSecretKeys[0],
 *     desiredAccountId: newAccountId,
 * })
 *
 * console.log(`
 *
 * ${JSON.stringify({
 *     account_id: newAccountId,
 *     public_key: trialPublicKeys[0],
 *     private_key: trialSecretKeys[0]
 * })}
 *
 * `)
 *
 * console.log(`http://localhost:1234/keypom-url/${newAccountId}#${trialSecretKeys[0]}`)
 *
 * ```
 * @group Trial Accounts
 */
const claimTrialAccountDrop = ({ secretKey, desiredAccountId, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { networkId, keyStore, contractId, contractAccount, receiverId, execute } = (0, keypom_1.getEnv)();
    const keyPair = crypto_1.KeyPair.fromString(secretKey);
    const pubKey = keyPair.getPublicKey().toString();
    yield keyStore.setKey(networkId, contractId, keyPair);
    const dropInfo = yield (0, views_1.getDropInformation)({ secretKey });
    (0, checks_1.assert)(dropInfo.fc !== undefined, "drop must be a trial account drop");
    const attachedGas = dropInfo.required_gas;
    let userFcArgs = {
        INSERT_NEW_ACCOUNT: desiredAccountId,
        INSERT_TRIAL_PUBLIC_KEY: pubKey,
    };
    const txn = yield (0, keypom_utils_1.convertBasicTransaction)({
        txnInfo: {
            receiverId,
            signerId: receiverId,
            actions: [
                {
                    enum: "FunctionCall",
                    functionCall: {
                        methodName: "claim",
                        args: (0, transactions_1.stringifyJsonOrBytes)({
                            account_id: desiredAccountId,
                            fc_args: [JSON.stringify(userFcArgs), null],
                        }),
                        gas: attachedGas,
                        deposit: '0',
                    }
                },
            ],
        },
        signerId: receiverId,
        signerPk: keyPair.getPublicKey(),
    });
    const transactions = [txn];
    const result = yield execute({ transactions, account: contractAccount });
    return result;
});
exports.claimTrialAccountDrop = claimTrialAccountDrop;

'''
'''--- packages/core/lib/lib/trial-accounts/trial-active.d.ts ---
import { FinalExecutionOutcome, Transaction } from "@near-wallet-selector/core";
/**
 * Execute a transaction that can contain multiple actions using a trial account. If the trial account is in the exit state, this will throw an error. Similarly, if any action
 * cannot be executed by the trial account (e.g. the attached deposit exceeds the trial account's restrictions), this will throw an error.
 *
 * @returns {Promise<FinalExecutionOutcome[]>} The outcomes of the transactions
 *
 * @example
 * Use a Trial Account to min2
 * ```js
 * await initKeypom({
 *        // near,
 *        network: 'testnet',
 *        funder: {
 *            accountId: fundingAccountId,
 *            secretKey: fundingAccountSecretKey,
 *        }
 *    });
 *
 *    const callableContracts = [
 *        `nft.examples.testnet`
 *    ]
 *
 *    const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 *    = await createTrialAccountDrop({
 *        numKeys: 1,
 *        contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *        startingBalanceNEAR: 0.5,
 *        callableContracts: callableContracts,
 *        callableMethods: ['*'],
 *        maxAttachableNEARPerContract: [1],
 *        trialEndFloorNEAR: 0.33 + 0.3
 *    })
 *
 *    const desiredAccountId = `${dropId}-keypom.testnet`
 *    const trialSecretKey = trialSecretKeys[0]
 *    await claimTrialAccountDrop({
 *        desiredAccountId,
 *        secretKey: trialSecretKeys[0],
 *    })
 *
 *    console.log('desiredAccountId: ', desiredAccountId)
 *    console.log(`trialSecretKey: ${JSON.stringify(trialSecretKey)}`)
 *    const txns = [{
 *        receiverId: callableContracts[0],
 *        actions: [
 *            {
 *                type: 'FunctionCall',
 *                params: {
 *                    methodName: 'nft_mint',
 *                    args: {
 *                        token_id: 'tokenId-keypom-1',
 *                        receiver_id: 'foo.testnet',
 *                        metadata: {
 *                            title: 'test1',
 *                            description: 'test1',
 *                            media: 'test1',
 *                        }
 *                    },
 *                    gas: '30000000000000',
 *                    deposit: parseNearAmount('0.1')
 *                },
 *            },
 *            {
 *                type: 'FunctionCall',
 *                params: {
 *                    methodName: 'nft_mint',
 *                    args: {
 *                        token_id: 'tokenId-keypom-2',
 *                        receiver_id: 'foo.testnet',
 *                        metadata: {
 *                            title: 'test2',
 *                            description: 'test2',
 *                            media: 'test2',
 *                        }
 *                    },
 *                    gas: '30000000000000',
 *                    deposit: parseNearAmount('0.1')
 *                },
 *            },
 *        ],
 *    }];
 *
 *    await trialSignAndSendTxns({
 *        trialAccountId: desiredAccountId,
 *        trialAccountSecretKey: trialSecretKey,
 *        txns
 *    })
 * ```
 *
 * @group Trial Accounts
 */
export declare const trialSignAndSendTxns: ({ trialAccountId, trialAccountSecretKey, txns, }: {
    /** The trial account ID to use */
    trialAccountId: string;
    /** The trial account secret key to use */
    trialAccountSecretKey: string;
    /** The transactions to execute */
    txns: Transaction[];
}) => Promise<FinalExecutionOutcome[]>;
/**
 * Execute a method using a trial account. If the trial account is in the exit state, this will throw an error. Similarly, if the given method data
 * cannot be executed by the trial account (e.g. the attached deposit exceeds the trial account's restrictions), this will throw an error.
 *
 * @returns {Promise<FinalExecutionOutcome[]>} The outcome of the transaction
 *
 * @example
 * Using a trial account to mint a new NFT:
 * ```js
 *     await initKeypom({
 *		network: 'testnet',
 *		funder: {
 *			accountId: fundingAccountId,
 *			secretKey: fundingAccountSecretKey,
 *		}
 *	});
 *
 *    const callableContracts = [
 *        `nft.examples.testnet`
 *    ]
 *
 *    const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 *    = await createTrialAccountDrop({
 *        numKeys: 1,
 *        contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *        startingBalanceNEAR: 0.5,
 *        callableContracts: callableContracts,
 *        callableMethods: ['*'],
 *        maxAttachableNEARPerContract: [1],
 *        trialEndFloorNEAR: 0.33 + 0.3
 *    })
 *
 *    const desiredAccountId = `${dropId}-keypom.testnet`
 *    const trialSecretKey = trialSecretKeys[0]
 *    await claimTrialAccountDrop({
 *        desiredAccountId,
 *        secretKey: trialSecretKeys[0],
 *    })
 *
 *    console.log('desiredAccountId: ', desiredAccountId)
 *    console.log(`trialSecretKey: ${JSON.stringify(trialSecretKey)}`)
 *
 *    await trialCallMethod({
 *        trialAccountId: desiredAccountId,
 *        trialAccountSecretKey: trialSecretKey,
 *        contractId: callableContracts[0],
 *        methodName: 'nft_mint',
 *        args: {
 *            token_id: 'asdkasldkjasdlkajsldajsldaskjd',
 *            receiver_id: 'foo.testnet',
 *            metadata: {
 *                title: 'test',
 *                description: 'test',
 *                media: 'test',
 *            }
 *        },
 *        attachedDeposit: parseNearAmount('0.1'),
 *        attachedGas: '30000000000000',
 *    })
 * ```
 * @group Trial Accounts
 */
export declare const trialCallMethod: ({ trialAccountId, trialAccountSecretKey, contractId, methodName, args, attachedGas, attachedDeposit, }: {
    /** The account ID of the trial account */
    trialAccountId: string;
    /** The secret key of the trial account */
    trialAccountSecretKey: string;
    /** The contract ID of the contract to call */
    contractId: string;
    /** The method name to call */
    methodName: string;
    /** The arguments to pass to the method */
    args: Object;
    /** The amount of gas to attach to the transaction */
    attachedGas: string;
    /** The amount of NEAR to attach to the transaction */
    attachedDeposit: string;
}) => Promise<FinalExecutionOutcome[]>;
/**
 * Check whether a trial account is able to exit their trial state and become a fully fledged normal account.
 *
 * @example
 * Create a trial account and check whether it can immediately exit
 * ```js
 *     await initKeypom({
 *        // near,
 *        network: 'testnet',
 *        funder: {
 *            accountId: fundingAccountId,
 *            secretKey: fundingAccountSecretKey,
 *        }
 *    });
 *
 *    const callableContracts = [
 *        `nft.examples.testnet`
 *    ]
 *
 *    const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 *    = await createTrialAccountDrop({
 *        numKeys: 1,
 *        contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *        startingBalanceNEAR: 0.5,
 *        callableContracts: callableContracts,
 *        callableMethods: ['*'],
 *        maxAttachableNEARPerContract: [1],
 *        trialEndFloorNEAR: 0.33 + 0.3
 *    })
 *
 *    const desiredAccountId = `${dropId}-keypom.testnet`
 *    const trialSecretKey = trialSecretKeys[0]
 *    await claimTrialAccountDrop({
 *        desiredAccountId,
 *        secretKey: trialSecretKey
 *    })
 *
 *    const canExitTrial = await keypom.canExitTrial({
 *        trialAccountId: desiredAccountId
 *    })
 *    console.log('canExitTrial: ', canExitTrial)
 *	```
 *
 * @group Trial Accounts
 */
export declare const canExitTrial: ({ trialAccountId, }: {
    /** The account ID of the trial account */
    trialAccountId: string;
}) => Promise<boolean>;

'''
'''--- packages/core/lib/lib/trial-accounts/trial-active.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.canExitTrial = exports.trialCallMethod = exports.trialSignAndSendTxns = void 0;
//import { KeyPair } from "near-api-js";
const keypom_1 = require("../keypom");
const keypom_utils_1 = require("../keypom-utils");
const utils_1 = require("./utils");
const crypto_1 = require("@near-js/crypto");
const transactions_1 = require("@near-js/transactions");
/**
 * Execute a transaction that can contain multiple actions using a trial account. If the trial account is in the exit state, this will throw an error. Similarly, if any action
 * cannot be executed by the trial account (e.g. the attached deposit exceeds the trial account's restrictions), this will throw an error.
 *
 * @returns {Promise<FinalExecutionOutcome[]>} The outcomes of the transactions
 *
 * @example
 * Use a Trial Account to min2
 * ```js
 * await initKeypom({
 *        // near,
 *        network: 'testnet',
 *        funder: {
 *            accountId: fundingAccountId,
 *            secretKey: fundingAccountSecretKey,
 *        }
 *    });
 *
 *    const callableContracts = [
 *        `nft.examples.testnet`
 *    ]
 *
 *    const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 *    = await createTrialAccountDrop({
 *        numKeys: 1,
 *        contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *        startingBalanceNEAR: 0.5,
 *        callableContracts: callableContracts,
 *        callableMethods: ['*'],
 *        maxAttachableNEARPerContract: [1],
 *        trialEndFloorNEAR: 0.33 + 0.3
 *    })
 *
 *    const desiredAccountId = `${dropId}-keypom.testnet`
 *    const trialSecretKey = trialSecretKeys[0]
 *    await claimTrialAccountDrop({
 *        desiredAccountId,
 *        secretKey: trialSecretKeys[0],
 *    })
 *
 *    console.log('desiredAccountId: ', desiredAccountId)
 *    console.log(`trialSecretKey: ${JSON.stringify(trialSecretKey)}`)
 *    const txns = [{
 *        receiverId: callableContracts[0],
 *        actions: [
 *            {
 *                type: 'FunctionCall',
 *                params: {
 *                    methodName: 'nft_mint',
 *                    args: {
 *                        token_id: 'tokenId-keypom-1',
 *                        receiver_id: 'foo.testnet',
 *                        metadata: {
 *                            title: 'test1',
 *                            description: 'test1',
 *                            media: 'test1',
 *                        }
 *                    },
 *                    gas: '30000000000000',
 *                    deposit: parseNearAmount('0.1')
 *                },
 *            },
 *            {
 *                type: 'FunctionCall',
 *                params: {
 *                    methodName: 'nft_mint',
 *                    args: {
 *                        token_id: 'tokenId-keypom-2',
 *                        receiver_id: 'foo.testnet',
 *                        metadata: {
 *                            title: 'test2',
 *                            description: 'test2',
 *                            media: 'test2',
 *                        }
 *                    },
 *                    gas: '30000000000000',
 *                    deposit: parseNearAmount('0.1')
 *                },
 *            },
 *        ],
 *    }];
 *
 *    await trialSignAndSendTxns({
 *        trialAccountId: desiredAccountId,
 *        trialAccountSecretKey: trialSecretKey,
 *        txns
 *    })
 * ```
 *
 * @group Trial Accounts
 */
const trialSignAndSendTxns = ({ trialAccountId, trialAccountSecretKey, txns, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { near, keyStore, networkId } = (0, keypom_1.getEnv)();
    const exitExpected = yield (0, exports.canExitTrial)({ trialAccountId });
    if (exitExpected == true) {
        throw utils_1.TRIAL_ERRORS.EXIT_EXPECTED;
    }
    const { methodDataToValidate, executeArgs, totalAttachedYocto, totalGasForTxns, } = yield (0, utils_1.generateExecuteArgs)({ desiredTxns: txns });
    const isValidTxn = yield (0, utils_1.validateDesiredMethods)({
        methodData: methodDataToValidate,
        trialAccountId,
    });
    console.log("isValidTxn: ", isValidTxn);
    if (isValidTxn == false) {
        throw utils_1.TRIAL_ERRORS.INVALID_ACTION;
    }
    const hasBal = yield (0, utils_1.hasEnoughBalance)({
        trialAccountId,
        totalAttachedYocto,
        totalGasForTxns,
    });
    if (hasBal == false) {
        throw utils_1.TRIAL_ERRORS.INSUFFICIENT_BALANCE;
    }
    const trialKeyPair = crypto_1.KeyPair.fromString(trialAccountSecretKey);
    const pubKey = trialKeyPair.getPublicKey();
    yield keyStore.setKey(networkId, trialAccountId, trialKeyPair);
    const account = yield near.account(trialAccountId);
    const gasToAttach = (0, utils_1.estimateTrialGas)({ executeArgs });
    const transformedTransactions = yield (0, keypom_utils_1.createTransactions)({
        signerId: trialAccountId,
        signerPk: pubKey,
        txnInfos: [
            {
                receiverId: account.accountId,
                signerId: trialAccountId,
                actions: [
                    {
                        enum: "FunctionCall",
                        functionCall: {
                            methodName: "execute",
                            args: (0, transactions_1.stringifyJsonOrBytes)(executeArgs),
                            gas: gasToAttach,
                            deposit: '0',
                        }
                    },
                ],
            },
        ],
    });
    console.log("debugging");
    console.log("transformedTransactions: ", transformedTransactions);
    const promises = transformedTransactions.map((tx) => account.signAndSendTransaction(tx));
    return (yield Promise.all(promises));
});
exports.trialSignAndSendTxns = trialSignAndSendTxns;
/**
 * Execute a method using a trial account. If the trial account is in the exit state, this will throw an error. Similarly, if the given method data
 * cannot be executed by the trial account (e.g. the attached deposit exceeds the trial account's restrictions), this will throw an error.
 *
 * @returns {Promise<FinalExecutionOutcome[]>} The outcome of the transaction
 *
 * @example
 * Using a trial account to mint a new NFT:
 * ```js
 *     await initKeypom({
 *		network: 'testnet',
 *		funder: {
 *			accountId: fundingAccountId,
 *			secretKey: fundingAccountSecretKey,
 *		}
 *	});
 *
 *    const callableContracts = [
 *        `nft.examples.testnet`
 *    ]
 *
 *    const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 *    = await createTrialAccountDrop({
 *        numKeys: 1,
 *        contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *        startingBalanceNEAR: 0.5,
 *        callableContracts: callableContracts,
 *        callableMethods: ['*'],
 *        maxAttachableNEARPerContract: [1],
 *        trialEndFloorNEAR: 0.33 + 0.3
 *    })
 *
 *    const desiredAccountId = `${dropId}-keypom.testnet`
 *    const trialSecretKey = trialSecretKeys[0]
 *    await claimTrialAccountDrop({
 *        desiredAccountId,
 *        secretKey: trialSecretKeys[0],
 *    })
 *
 *    console.log('desiredAccountId: ', desiredAccountId)
 *    console.log(`trialSecretKey: ${JSON.stringify(trialSecretKey)}`)
 *
 *    await trialCallMethod({
 *        trialAccountId: desiredAccountId,
 *        trialAccountSecretKey: trialSecretKey,
 *        contractId: callableContracts[0],
 *        methodName: 'nft_mint',
 *        args: {
 *            token_id: 'asdkasldkjasdlkajsldajsldaskjd',
 *            receiver_id: 'foo.testnet',
 *            metadata: {
 *                title: 'test',
 *                description: 'test',
 *                media: 'test',
 *            }
 *        },
 *        attachedDeposit: parseNearAmount('0.1'),
 *        attachedGas: '30000000000000',
 *    })
 * ```
 * @group Trial Accounts
 */
const trialCallMethod = ({ trialAccountId, trialAccountSecretKey, contractId, methodName, args, attachedGas, attachedDeposit, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { near, keyStore, networkId } = (0, keypom_1.getEnv)();
    const exitExpected = yield (0, exports.canExitTrial)({ trialAccountId });
    if (exitExpected == true) {
        throw utils_1.TRIAL_ERRORS.EXIT_EXPECTED;
    }
    const trialKeyPair = crypto_1.KeyPair.fromString(trialAccountSecretKey);
    const pubKey = trialKeyPair.getPublicKey();
    yield keyStore.setKey(networkId, trialAccountId, trialKeyPair);
    const account = yield near.account(trialAccountId);
    const txns = [{
            signerId: trialAccountId,
            receiverId: contractId,
            actions: [
                {
                    type: 'FunctionCall',
                    params: {
                        methodName,
                        args,
                        gas: attachedGas,
                        deposit: attachedDeposit
                    },
                },
            ],
        }];
    console.log(`txns: ${JSON.stringify(txns)}`);
    const { methodDataToValidate, executeArgs, totalAttachedYocto, totalGasForTxns, } = yield (0, utils_1.generateExecuteArgs)({ desiredTxns: txns });
    const isValidTxn = yield (0, utils_1.validateDesiredMethods)({
        methodData: methodDataToValidate,
        trialAccountId,
    });
    console.log("isValidTxn: ", isValidTxn);
    if (isValidTxn == false) {
        throw utils_1.TRIAL_ERRORS.INVALID_ACTION;
    }
    const hasBal = yield (0, utils_1.hasEnoughBalance)({
        trialAccountId,
        totalAttachedYocto,
        totalGasForTxns,
    });
    if (hasBal == false) {
        throw utils_1.TRIAL_ERRORS.INSUFFICIENT_BALANCE;
    }
    const gasToAttach = (0, utils_1.estimateTrialGas)({ executeArgs });
    const transformedTransactions = yield (0, keypom_utils_1.createTransactions)({
        signerId: trialAccountId,
        signerPk: pubKey,
        txnInfos: [
            {
                receiverId: account.accountId,
                signerId: trialAccountId,
                actions: [
                    {
                        enum: "FunctionCall",
                        functionCall: {
                            methodName: "execute",
                            args: (0, transactions_1.stringifyJsonOrBytes)(executeArgs),
                            gas: gasToAttach,
                            deposit: '0',
                        }
                    },
                ],
            },
        ],
    });
    console.log("debugging");
    console.log("transformedTransactions: ", transformedTransactions);
    const promises = transformedTransactions.map((tx) => account.signAndSendTransaction(tx));
    return (yield Promise.all(promises));
});
exports.trialCallMethod = trialCallMethod;
/**
 * Check whether a trial account is able to exit their trial state and become a fully fledged normal account.
 *
 * @example
 * Create a trial account and check whether it can immediately exit
 * ```js
 *     await initKeypom({
 *        // near,
 *        network: 'testnet',
 *        funder: {
 *            accountId: fundingAccountId,
 *            secretKey: fundingAccountSecretKey,
 *        }
 *    });
 *
 *    const callableContracts = [
 *        `nft.examples.testnet`
 *    ]
 *
 *    const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 *    = await createTrialAccountDrop({
 *        numKeys: 1,
 *        contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *        startingBalanceNEAR: 0.5,
 *        callableContracts: callableContracts,
 *        callableMethods: ['*'],
 *        maxAttachableNEARPerContract: [1],
 *        trialEndFloorNEAR: 0.33 + 0.3
 *    })
 *
 *    const desiredAccountId = `${dropId}-keypom.testnet`
 *    const trialSecretKey = trialSecretKeys[0]
 *    await claimTrialAccountDrop({
 *        desiredAccountId,
 *        secretKey: trialSecretKey
 *    })
 *
 *    const canExitTrial = await keypom.canExitTrial({
 *        trialAccountId: desiredAccountId
 *    })
 *    console.log('canExitTrial: ', canExitTrial)
 *	```
 *
 * @group Trial Accounts
 */
const canExitTrial = ({ trialAccountId, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { viewCall } = (0, keypom_1.getEnv)();
    try {
        const keyInfo = yield viewCall({
            contractId: trialAccountId,
            methodName: "get_key_information",
            args: {},
        });
        console.log(`keyInfo: `, keyInfo);
        const rules = yield viewCall({
            contractId: trialAccountId,
            methodName: "get_rules",
            args: {},
        });
        console.log("rules: ", rules);
        return keyInfo.trial_data.exit == true;
    }
    catch (e) {
        console.log("error: ", e);
    }
    return false;
});
exports.canExitTrial = canExitTrial;

'''
'''--- packages/core/lib/lib/trial-accounts/utils.d.ts ---
import { Transaction } from "@near-wallet-selector/core";
export declare const TRIAL_ERRORS: {
    EXIT_EXPECTED: string;
    INVALID_ACTION: string;
    INSUFFICIENT_BALANCE: string;
};
export declare const validateDesiredMethods: ({ methodData, trialAccountId, }: {
    methodData: {
        receiverId: string;
        methodName: string;
        deposit: string;
    }[];
    trialAccountId: string;
}) => Promise<boolean>;
export declare const wrapTxnParamsForTrial: (params: any, newParams?: {}) => {};
export declare const generateExecuteArgs: ({ desiredTxns, }: {
    /** The transactions to execute */
    desiredTxns: Transaction[];
}) => {
    totalAttachedYocto: any;
    totalGasForTxns: any;
    executeArgs: any;
    methodDataToValidate: any;
};
export declare const estimateTrialGas: ({ executeArgs, }: {
    executeArgs: {
        transactions: {
            "|kR|": string;
            /** The actions to execute */
            actions: {
                /** The type of action to execute */
                "|kA|": "FunctionCall";
                /** The parameters for the action */
                params: {
                    /** The method name to execute */
                    "|kP|methodName": string;
                    /** The arguments to pass to the method */
                    "|kP|args": string;
                    /** The amount of gas to attach to the transaction */
                    "|kP|gas": string;
                    /** The amount of NEAR to attach to the transaction */
                    "|kP|deposit": string;
                };
            }[];
        }[];
    };
}) => any;
export declare const isUnclaimedTrialDrop: ({ keypomContractId, secretKey }: {
    keypomContractId: any;
    secretKey: any;
}) => Promise<boolean>;
export declare const hasEnoughBalance: ({ trialAccountId, totalGasForTxns, totalAttachedYocto, }: {
    trialAccountId: string;
    totalGasForTxns: string;
    totalAttachedYocto: string;
}) => Promise<any>;

'''
'''--- packages/core/lib/lib/trial-accounts/utils.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.hasEnoughBalance = exports.isUnclaimedTrialDrop = exports.estimateTrialGas = exports.generateExecuteArgs = exports.wrapTxnParamsForTrial = exports.validateDesiredMethods = exports.TRIAL_ERRORS = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const keypom_1 = require("../keypom");
const views_1 = require("../views");
const accounts_1 = require("@near-js/accounts");
// helpers for keypom account contract args
const RECEIVER_HEADER = "|kR|";
const ACTION_HEADER = "|kA|";
const PARAM_START = "|kP|";
const PARAM_STOP = "|kS|";
exports.TRIAL_ERRORS = {
    EXIT_EXPECTED: "exit",
    INVALID_ACTION: "invalid_action",
    INSUFFICIENT_BALANCE: "insufficient_balance",
};
const validateDesiredMethods = ({ methodData, trialAccountId, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { viewCall } = (0, keypom_1.getEnv)();
    let validInfo = {};
    try {
        const rules = yield viewCall({
            contractId: trialAccountId,
            methodName: "get_rules",
            args: {},
        });
        let contracts = rules.contracts.split(",");
        let amounts = rules.amounts.split(",");
        let methods = rules.methods.split(",");
        for (let i = 0; i < contracts.length; i++) {
            validInfo[contracts[i]] = {
                maxDeposit: amounts[i],
                allowableMethods: methods[i] == "*" ? "*" : methods[i].split(":"),
            };
        }
    }
    catch (e) {
        console.log("error: ", e);
    }
    console.log("validInfo after view calls: ", validInfo);
    // Loop through each transaction in the array
    for (let i = 0; i < methodData.length; i++) {
        const method = methodData[i];
        console.log("method: ", method);
        const validInfoForReceiver = validInfo[method.receiverId];
        console.log("validInfoForReceiver: ", validInfoForReceiver);
        // Check if the contractId is valid
        if (!validInfoForReceiver) {
            console.log("!validInfo[transaction.receiverId]: ", !validInfo[method.receiverId]);
            return false;
        }
        // Check if the method name is valid
        if (validInfoForReceiver.allowableMethods != "*" &&
            !validInfoForReceiver.allowableMethods.includes(method.methodName)) {
            console.log("!validInfo[transaction.receiverId].allowableMethods.includes(transaction.methodName): ", !validInfo[method.receiverId].allowableMethods.includes(method.methodName));
            return false;
        }
        // Check if the deposit is valid
        if (validInfoForReceiver.maxDeposit != "*" &&
            new bn_js_1.default(method.deposit).gt(new bn_js_1.default(validInfoForReceiver.maxDeposit))) {
            console.log("new BN(transaction.deposit).gt(new BN(validInfo[transaction.receiverId].maxDeposit)): ", new bn_js_1.default(method.deposit).gt(new bn_js_1.default(validInfo[method.receiverId].maxDeposit)));
            return false;
        }
    }
    return true;
});
exports.validateDesiredMethods = validateDesiredMethods;
const wrapTxnParamsForTrial = (params, newParams = {}) => {
    Object.entries(params).forEach(([k, v]) => {
        if (k === "args" && typeof v !== "string") {
            v = JSON.stringify(v);
        }
        if (Array.isArray(v))
            v = v.join();
        newParams[PARAM_START + k] = v + PARAM_STOP;
    });
    return newParams;
};
exports.wrapTxnParamsForTrial = wrapTxnParamsForTrial;
const generateExecuteArgs = ({ desiredTxns, }) => {
    const methodDataToValidate = [];
    let totalGasBN = new bn_js_1.default(0);
    let totalDepositsBN = new bn_js_1.default(0);
    const executeArgs = {
        transactions: [],
    };
    desiredTxns.forEach((tx) => {
        const newTx = {};
        newTx[RECEIVER_HEADER] = tx.receiverId;
        newTx.actions = [];
        console.log("newTx: ", newTx);
        tx.actions.forEach((action) => {
            console.log('action: ', action);
            if (action.type !== "FunctionCall") {
                throw new Error("Only FunctionCall actions are supported");
            }
            methodDataToValidate.push({
                receiverId: tx.receiverId,
                methodName: action.params.methodName,
                deposit: action.params.deposit
            });
            totalGasBN = totalGasBN.add(new bn_js_1.default(action.params.gas));
            totalDepositsBN = totalDepositsBN.add(new bn_js_1.default(action.params.deposit));
            const newAction = {};
            console.log('newAction 1: ', newAction);
            newAction[ACTION_HEADER] = action.type;
            console.log('newAction 2: ', newAction);
            newAction.params = (0, exports.wrapTxnParamsForTrial)(action.params);
            console.log('newAction 3: ', newAction);
            newTx.actions.push(newAction);
        });
        executeArgs.transactions.push(newTx);
    });
    return {
        totalAttachedYocto: totalDepositsBN.toString(),
        totalGasForTxns: totalGasBN.toString(),
        executeArgs,
        methodDataToValidate,
    };
};
exports.generateExecuteArgs = generateExecuteArgs;
const estimateTrialGas = ({ executeArgs, }) => {
    let transactions = executeArgs.transactions;
    let incomingGas = new bn_js_1.default("0");
    let numActions = 0;
    try {
        for (let i = 0; i < transactions.length; i++) {
            let transaction = transactions[i];
            console.log("transaction in gas loop: ", transaction);
            for (let j = 0; j < transaction.actions.length; j++) {
                let action = transaction.actions[j];
                console.log("action in gas loop: ", action);
                let gasToAdd = action.params["|kP|gas"]
                    .split(`|kS|`)[0]
                    .toString();
                console.log("gasToAdd: ", gasToAdd);
                incomingGas = incomingGas.add(new bn_js_1.default(gasToAdd));
                numActions += 1;
            }
        }
    }
    catch (e) {
        numActions = 1;
        console.log("e: ", e);
        incomingGas = new bn_js_1.default(`300000000000000`);
    }
    console.log("incomingGas: ", incomingGas.toString());
    // Take 15 TGas as a base for loading rules as well as 20 TGas for the callback.
    // For each action, add 15 TGas on top of that and then add the final incoming gas on top.
    let gasToAttach = new bn_js_1.default("15000000000000") // Loading rules
        .add(new bn_js_1.default("20000000000000")) // Callback
        .add(new bn_js_1.default("15000000000000").mul(new bn_js_1.default(numActions))) // Actions
        .add(incomingGas)
        .toString(); // Incoming gas
    // check if the gas to attach is over 300 TGas and if it is, clamp it
    if (new bn_js_1.default(gasToAttach).gt(new bn_js_1.default("300000000000000"))) {
        console.log("gas to attach is over 300 TGas. Clamping it");
        gasToAttach = "300000000000000";
    }
    return gasToAttach;
};
exports.estimateTrialGas = estimateTrialGas;
const isUnclaimedTrialDrop = ({ keypomContractId, secretKey }) => __awaiter(void 0, void 0, void 0, function* () {
    console.log("accountId is valid keypom contract ", keypomContractId);
    const keyInfo = yield (0, views_1.getKeyInformation)({
        secretKey,
    });
    console.log("keyInfo: ", keyInfo);
    if (keyInfo !== null) {
        return true;
    }
    return false;
});
exports.isUnclaimedTrialDrop = isUnclaimedTrialDrop;
const hasEnoughBalance = ({ trialAccountId, totalGasForTxns, totalAttachedYocto, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { near } = (0, keypom_1.getEnv)();
    const trialAccountObj = new accounts_1.Account(near.connection, trialAccountId);
    const accountState = yield trialAccountObj.state();
    const storageCostPerByte = new bn_js_1.default("10000000000000000000");
    const totalStorage = new bn_js_1.default(accountState.storage_usage).mul(storageCostPerByte);
    let availAmount = new bn_js_1.default(accountState.amount).sub(totalStorage);
    const yoctoPerGas = 100000000;
    let gasCost = new bn_js_1.default(totalGasForTxns).mul(new bn_js_1.default(yoctoPerGas));
    let totalCost = gasCost.add(new bn_js_1.default(totalAttachedYocto));
    return availAmount.gte(totalCost);
});
exports.hasEnoughBalance = hasEnoughBalance;

'''
'''--- packages/core/lib/lib/types/drops.d.ts ---
import { FCData } from "./fc";
import { FTData } from "./ft";
import { NFTData } from "./nft";
import { SimpleData } from "./simple";
/**
 * Important information returned in many view calls regarding a specific access key.
 */
export interface KeyInfo {
    /** Drop ID for the specific drop that the key belongs to. */
    dropId: string;
    /** Public key for this access key. */
    publicKey: string;
    /** Which use is the key currently on? For single-use keys, this is always 1.  */
    curKeyUse: number;
    /** How many uses this key has left before it's deleted.  */
    remainingUses: number;
    /** At what timestamp was the key last used? Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC. */
    lastUsed: number;
    /** How much allowance does the key have left (measured in $yoctoNEAR). When the key is deleted, this is refunded to the funder's balance. */
    allowance: number;
    /** The unique ID associated to this key. IDs are *not* unique across drops but they are unique for any key in the drop. */
    keyId: number;
}
/**
 * Information related to a specific drop.
 */
export interface Drop {
    /** Drop ID for this specific drop. */
    dropId: string;
    /** Which account created this drop. */
    ownerId: string;
    /** How much $yoctoNEAR will be transferred anytime a key is used that is part of this drop. */
    depositPerUse: string;
    /** For simple drops, there are specific, optional configurations. */
    simple?: SimpleData;
    /** For NFT drops, important information such as the token IDs, or contract need to be stored. */
    nft?: NFTData;
    /** For Fungible Token drops, important information such as the amount of tokens to transfer, or contract need to be stored. */
    ft?: FTData;
    /** For Function-Call drops, important information needs to be stored such as which methods, the attached deposit, args etc. */
    fc?: FCData;
    /** All drops regardless of their type can have a suite of configurations such as how many uses each key has or how often a key can be used. */
    config?: DropConfig;
    /** Any extra information about the drop can be stored as metadata. This is up to the drop creator and can be stringified JSON, or any other string. */
    metadata?: string;
    /** How many key uses are registered for this drop? This is only applicable to simple drops with lazy registrations, FT drops, and NFT drops. */
    registeredUses: number;
    /** In order to use an access key that's part of this drop, how much Gas *needs* to be attached to the call? */
    requiredGas: string;
    /** What is the next unique ID that will be given to the next access key added to this drop. */
    nextKeyId: number;
}
/**
 * Configurable options for any drop regardless of type.
 */
export interface DropConfig {
    /** How many uses can each key have before it's deleted. If this isn't specified, it defaults to 1 use per key. */
    usesPerKey?: number;
    /** Any information related to time-based configurations such as a starting date for keys etc. */
    time?: TimeConfig;
    /** Any information related to how access keys are used such as which methods they can call or whether an empty drop should be automatically deleted etc.*/
    usage?: UsageConfig;
    /** Any information related to primary market sales for access keys added to this drop.*/
    sale?: PublicSaleConfig;
    /** Override the global root account that all created sub-accounts will have (currently `near` or `testnet`). This allows users to drops that have a custom root.
     * For example, Fayyr could specify a root of `fayyr.near` By which all sub-accounts will then be `ACCOUNT.fayyr.near`.
     * It's important to note that this root account *MUST* have a smart contract deployed that has a method `create_account`.
     */
    dropRoot?: string;
}
/**
 * Within the config, there are configurable options related to timing such as how often a key can be used.
 */
export interface TimeConfig {
    /**
     * Minimum block timestamp before keys can be used. If this isn't specified, keys can be used immediately.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    start?: number;
    /**
     * Block timestamp that keys must be used before. If this isn't specified, keys can be used indefinitely.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    end?: number;
    /**
     * Amount of time that *must* pass in between each key use. If this isn't specified, there is no delay between key uses.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    throttle?: number;
    /**
     * Interval of time after the `start_timestamp` that must pass before a key can be used. If multiple intervals pass, the key can be used multiple times.
     * This has nothing to do With the throttle timestamp. It only pertains to the start timestamp and the current timestamp. The last_used timestamp is not taken into account.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    interval?: number;
}
/**
 * Within the config, there are configurable options related to how keys can be used. What permissions they have, whether an empty drop should be automatically deleted etc.
 */
export interface UsageConfig {
    /**
     * Specify which methods can be called by the access key (either `claim` or `create_account_and_claim`). If this isn't specified, both methods can be called.
     */
    permissions?: string;
    /**
     * If the method `claim` is called rather than `create_account_and_claim`, should the `deposit_per_use` be refunded to the owner's balance?
     * If this isn't specified, it defaults to false.
     */
    refundDeposit?: boolean;
    /**
     * When a key is used and deleted, if it results in the drop being empty, should the drop automatically be deleted? If this isn't specified, it defaults to false.
     */
    autoDeleteDrop?: boolean;
    /**
     * When the last key in this drop is used, in the case where `autoDeleteDrop` is set to true and the drop is the owner's last, should their balance be automatically withdrawn? If this isn't specified, it defaults to false.
     */
    autoWithdraw?: boolean;
    /** When calling `create_account` on the root account, which keypom args should be attached to the payload. */
    accountCreationFields?: {
        /**
         * Specifies what field Keypom should auto-inject the account that claimed the drop's ID into when calling the `create_account` function.
         */
        accountIdField?: string;
        /**
         * Specifies what field Keypom should auto-inject the drop's ID into when calling the `create_account` function.
         */
        dropIdField?: string;
        /**
         * Specifies what field Keypom should auto-inject the key's ID into when calling the `create_account` function.
         */
        keyIdField?: string;
        /**
         * Specifies what field Keypom should auto-inject the drop funder's account ID into when calling the `create_account` function.
         */
        funderIdField?: string;
    };
}
/**
 * Within the config, there are configurable options related to how keys can be sold and a funder can potentially make a profit.
 */
export interface PublicSaleConfig {
    /** Maximum number of keys that can be added to this drop. If None, there is no max. */
    maxNumKeys?: number;
    /**
     * Amount of $NEAR that the user needs to attach (if they are not the funder) on top of costs. This amount will be
     * Automatically sent to the funder's balance. If None, the keys are free to the public.
     */
    pricePerKeyNEAR?: number;
    pricePerKeyYocto?: string;
    /** Which accounts are allowed to add keys? If the allowlist is empty, anyone that is not in the blocklist can add keys. */
    allowlist?: string[];
    /** Which accounts are NOT allowed to add keys? */
    blocklist?: string[];
    /**
     * Should the revenue generated be sent to the funder's account balance or
     * automatically withdrawn and sent to their NEAR wallet?
     */
    autoWithdrawFunds?: boolean;
    /**
     * Minimum block timestamp before the public sale starts. If None, keys can be added immediately
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    start?: number;
    /**
     * Block timestamp dictating the end of the public sale. If None, keys can be added indefinitely
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    end?: number;
}
/**
 * Keeps track of the password for a given key use. This should be passed in as an array for each key that has passwords.
 */
export interface PasswordPerUse {
    /** The password for this given use */
    pw: string;
    /** Which use does the password belong to? These uses are *NOT* zero-indexed so the first use corresponds to `1` not `0`. */
    key_use: number;
}

'''
'''--- packages/core/lib/lib/types/drops.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

'''
'''--- packages/core/lib/lib/types/fc.d.ts ---
import { Maybe } from "../keypom";
/**
 * Outlines the information needed for any given method as part of a Function-Call drop.
 * Each individual key use can have an array of Methods that can be called.
 */
export interface Method {
    /**
     * The account ID that the contract is deployed to that the method will be called on.
     */
    receiverId: string;
    /**
     * The method that should be invoked on the `receiverId`'s contract.
     */
    methodName: string;
    /**
     * What arguments should be passed to the method. This should be in stringified JSON.
     */
    args: string;
    /**
     * How much yoctoNEAR should be attached to the call.
     */
    attachedDeposit: string;
    /**
     * How much gas to attach to this method call. If none, all the gas is split between the parallel method calls in a given claim.
     * If this is specified, the key can ONLY be used to call `claim` and no `deposit_per_use` can be specified. This leads the key to act like a method calling proxy instead of a linkdrop.
     */
    attachedGas?: string;
    /**
     * Specifies what field Keypom should auto-inject the account that claimed the drop's ID into when calling the function.
     * As an example, if the methodName was `nft_mint` and it expected a field `receiver_id` to be passed in, indicating who should receive the token, then the `accountIdField` would be `receiver_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    accountIdField?: string;
    /**
     * Specifies what field Keypom should auto-inject the drops ID into when calling the function.
     * As an example, if an NFT contract expected the Keypom drop ID to be passed in as the field `keypom_drop_id` in order to gate access to who can mint NFTs, then the `dropIdField` would be `keypom_drop_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    dropIdField?: string;
    /**
     * Specifies what field Keypom should auto-inject the key's ID into when calling the function.
     * As an example, if an NFT contract wanted to gate only users with an odd key ID to be able to mint an NFT and their parameter was called `keypom_key_id`, then the `keyIdField` would be `keypom_key_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    keyIdField?: string;
    /**
     * Specifies what field Keypom should auto-inject the drop funder's account ID into when calling the function.
     * As an example, if an NFT contract wanted to gate only users that had a key coming from a specific funder's drops, it could expect a field called `keypom_funder_id` and the `funderIdField` would be `keypom_funder_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    funderIdField?: string;
    /**
     * If set to true, the claiming account ID will be the receiver ID of the method call.
     * This receiver must be a valid account and non-malicious (cannot be set to the keypom contract)
     **/
    receiverToClaimer?: boolean;
    /**
     * What permissions does the user have when providing custom arguments to the function call?
     * By default, the user cannot provide any custom arguments
     */
    userArgsRule?: "AllUser" | "FunderPreferred" | "UserPreferred";
}
/**
 * Information pertaining to all Function-Call drops. This should be passed in if the drop will be a Function-Call drop.
 */
export interface FCData {
    /**
     * The top level array indicates a different set of methods that can be called for every key use. It is possible that for a given key use, no methods are called thus acting as a "free" key use whereby the use is reflected on-chain but no assets are transferred.
     * If a given key use does not have an undefined set of methods, when it is used, all the methods in the set will be called.
     */
    methods: Array<Maybe<Array<Method>>>;
}

'''
'''--- packages/core/lib/lib/types/fc.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

'''
'''--- packages/core/lib/lib/types/ft.d.ts ---
/**
 * Information pertaining to all Fungible-Token drops. This should be passed in if the drop will be used to transfer any fungible tokens.
 */
export interface FTData {
    /**
     * Which contract do the FTs belong to?
     */
    contractId: string;
    /**
     * By default, anyone can fund your drop with FTs. This field allows you to set a specific account ID that will be locked into sending the FTs.
     */
    senderId?: string;
    /**
     * Human readable format for the amount of tokens to transfer everytime the FT key is used.
     * Example: transferring one wNEAR should be passed in as "1" and NOT "1000000000000000000000000"
     */
    amount?: string;
    /**
     * Amount of tokens to transfer but considering the decimal amount.
     * Example: transferring one wNEAR should be passed in as "1000000000000000000000000" and NOT "1"
     */
    absoluteAmount?: string;
}
/**
 * General structure of Fungible Token Metadata as per official NEP-148 standard (https://github.com/near/NEPs/blob/master/neps/nep-0148.md).
 */
export interface FungibleTokenMetadata {
    /** A string. Should be ft-1.0.0 to indicate that a Fungible Token contract adheres to the current versions of this Metadata and the Fungible Token Core specs. This will allow consumers of the Fungible Token to know if they support the features of a given contract. */
    spec: string;
    /** The human-readable name of the token. */
    name: string;
    /** The abbreviation, like wETH or AMPL. */
    symbol: string;
    /** Used in frontends to show the proper significant digits of a token. This concept is explained well in this OpenZeppelin post (https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals). */
    decimals: number;
    /**
     * A small image associated with this token. Must be a data URL, to help consumers display it quickly while protecting user data.
     * Recommendation: use optimized SVG, which can result in high-resolution images with only 100s of bytes of storage cost.
     * (Note that these storage costs are incurred to the token owner/deployer, but that querying these icons is a very cheap & cacheable read operation for all consumers of the contract and the RPC nodes that serve the data.)
     * Recommendation: create icons that will work well with both light-mode and dark-mode websites by either using middle-tone color schemes, or by embedding media queries in the SVG.
     */
    icon?: string;
    /** A link to a valid JSON file containing various keys offering supplementary details on the token. Example: /ipfs/QmdmQXB2mzChmMeKY47C43LxUdg1NDJ5MWcKMKxDu7RgQm, https://example.com/token.json, etc. If the information given in this document conflicts with the on-chain attributes, the values in reference shall be considered the source of truth. */
    reference?: string;
    /** The base64-encoded sha256 hash of the JSON file contained in the reference field. This is to guard against off-chain tampering. */
    reference_hash?: string;
}

'''
'''--- packages/core/lib/lib/types/ft.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

'''
'''--- packages/core/lib/lib/types/general.d.ts ---
import { Connection } from "@near-js/accounts";
import { KeyPair } from "@near-js/crypto";
import { KeyStore } from "@near-js/keystores";
import { Action } from "@near-js/transactions";
import { Near } from "@near-js/wallet-account";
import { Account } from "@near-wallet-selector/core";
export type NearKeyPair = KeyPair;
/**
 * For each generated KeyPair (either through `createDrop`, `addKeys` or `generateKeys`), the public and private keys are returned.
 * In addition, the actual KeyPair objects are returned as well.
 */
export interface GeneratedKeyPairs {
    /** Actual KeyPair objects that can be used to sign messages, verify signatures, and get the public and private keys */
    keyPairs: NearKeyPair[];
    /** Set of public keys that were generated */
    publicKeys: string[];
    /** Set of private keys that were generated */
    secretKeys: string[];
}
/**
 * Outlines how the structure of the *funder* object should be passed into `initKeypom` or `updateFunder`. This contains important information such as the
 * secret key, account ID and any root entropy associated with the account.
 *
 * @throws if neither `secretKey` or `seedPhrase` are provided. One of these need to be passed in.
 */
export interface Funder {
    /** The account ID of the funder that will be used to sign transactions. */
    accountId: string;
    /** A valid private key associated with the funder's account. This can be function-call or full access (depending on what limitations and security measures are in place). */
    secretKey?: string;
    /** 12 word seedphrase that can be used to derive the `secretKey`. If this is present, it will override the passed in `secretKey`. */
    seedPhrase?: string;
    /**
     * When interacting with the SDK, there are several places where KeyPairs can be generated automatically rather than you having to pass them in.
     * For example, during `createDrop` and `addKeys`, if `publicKeys` isn't passed in, the SDK will generate `numKeys` number of keys automatically.
     * These generated keys can either be completely random or deterministically generated based off some entropy. If `rootEntropy` is provided, all the
     * keys that are auto-generated will be based off this entropy.
     */
    rootEntropy?: string;
    /** @internal */
    fundingKeyPair?: NearKeyPair;
}
/**
 * Important context that is used throughout the SDK. This is generated when `initKeypom` is called and can be retrieved by calling `useKeypom`.
 * All parameters will start off as undefined until the Keypom SDK is initialized.
 */
export interface EnvVars {
    /** The specific NEAR object that contains important information such as the KeyStore and connection. This is used to interact with the chain and can either be manually passed in or will be automatically created during `initKeypom` */
    near?: Near;
    /** The connection instance that is part of the NEAR object */
    connection?: Connection;
    /** Which type of KeyStore is used when locating keys and signing transactions throughout the SDK (In Memory, Unencrypted FileStore etc.)  */
    keyStore?: KeyStore;
    /** What network is the SDK using (`testnet` or `mainnet`)  */
    networkId?: string;
    /** The NEAR Account object for the Funder  */
    fundingAccount?: Account;
    /** The details for the funder such as any `rootEntropy` or their `secretKey` etc. */
    fundingAccountDetails?: Funder;
    /** The NEAR Account object for the Keypom contract being used. This lets you know the account ID for the contract and can be used to sign transactions for claiming linkdrops. */
    contractAccount?: Account;
    /** @internal */
    viewAccount?: any;
    /** The default amount of Gas that will be attached to transactions (200 TGas). */
    gas?: string;
    /** The max amount of Gas that will be attached to transactions (300 TGas). */
    gas300?: string;
    /** The amount of Gas that will be attached to the `claim` and `create_account_and_claim` functions for claiming linkdrops (100 TGas). */
    attachedGas?: string;
    /** The account ID where the Keypom contract is deployed to. */
    contractId?: string;
    /** @internal */
    receiverId?: string;
    /** @internal */
    error?: string;
    /** @internal */
    getAccount?: any;
    /** @internal */
    execute?: any;
    /** Object containing the supported Keypom contracts for both mainnet and testnet */
    supportedKeypomContracts?: {
        mainnet: {};
        testnet: {};
    };
    /** Function that allows you to invoke a view method. This takes in a `receiverId`, `methodName`, and `args`. */
    viewCall?: any;
}
/**
 * Information returned from `getContractSourceMetadata` about the deployed Keypom contract. This is part of [NEP-330](https://nomicon.io/Standards/SourceMetadata) and
 * can allow you to view exactly what code is deployed to the contract.
 */
export interface ContractSourceMetadata {
    /** Versioning used by the Keypom developers to indicate which version of the contract is deployed. */
    version: string;
    /** Link to the specific commit and code on GitHub that is deployed to the Keypom account */
    link: string;
}
export interface BasicTransaction {
    receiverId: string;
    signerId: string;
    actions: Action[];
}

'''
'''--- packages/core/lib/lib/types/general.js ---
"use strict";
//import { Account, Connection, Near } from "near-api-js";
//import { KeyStore } from "near-api-js/lib/key_stores";
//import { KeyPair } from "near-api-js/lib/utils";
Object.defineProperty(exports, "__esModule", { value: true });

'''
'''--- packages/core/lib/lib/types/nft.d.ts ---
/**
 * General structure of a Non-Fungible Token drop. This should be passed into `createDrop` if you wish to have an NFT drop.
 */
export interface NFTData {
    /** The account ID that the NFT contract is deployed to. This contract is where all the NFTs for the specific drop must come from. */
    contractId: string;
    /** By default, anyone can fund your drop with NFTs. This field allows you to set a specific account ID that will be locked into sending the NFTs. */
    senderId?: string;
    /**
     * If there are any token IDs that you wish to be automatically sent to the Keypom contract in order to register keys as part of `createDrop`, specify them here.
     * A maximum of 2 token IDs can be sent as part of the transaction. If you wish to register more keys by sending more NFTs, you must do this in a separate call by invoking
     * the `nftTransferCall` method separately.
     */
    tokenIds?: string[];
}
/**
 * General structure of a Non-Fungible Token object as per official NEP-171 standard (https://github.com/near/NEPs/blob/master/neps/nep-0171.md).
 */
export interface ProtocolReturnedNonFungibleTokenObject {
    /** String ID for the token */
    token_id: string;
    /** Account ID of the owner */
    owner_id: string;
    /** Metadata for the token */
    metadata?: ProtocolReturnedNonFungibleTokenMetadata;
    /** Map of account IDs to approval IDs as per official NEP-178 standard (https://github.com/near/NEPs/blob/master/neps/nep-0178.md). */
    approved_account_ids?: Map<string, number>;
    /** A mapping of NEAR accounts to the amount each should be paid out as per official NEP-199 standard (https://github.com/near/NEPs/blob/master/neps/nep-0199.md). */
    royalty?: Map<string, number>;
}
/**
 * General structure of Non-Fungible Token Metadata as per official NEP-177 standard (https://github.com/near/NEPs/blob/master/neps/nep-0177.md).
 */
export interface ProtocolReturnedNonFungibleTokenMetadata {
    /** ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055" */
    title?: string;
    /** free-form description */
    description?: string;
    /** URL to associated media, preferably to decentralized, content-addressed storage */
    media?: string;
    /** Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included. */
    media_hash?: string;
    /** number of copies of this set of metadata in existence when token was minted. */
    copies?: number;
    /** When token was issued or minted, Unix epoch in milliseconds */
    issued_at?: number;
    /** When token expires, Unix epoch in milliseconds */
    expires_at?: number;
    /** When token starts being valid, Unix epoch in milliseconds */
    starts_at?: number;
    /** When token was last updated, Unix epoch in milliseconds */
    updated_at?: number;
    /** anything extra the NFT wants to store on-chain. Can be stringified JSON. */
    extra?: string;
    /** URL to an off-chain JSON file with more info. */
    reference?: string;
    /** Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included. */
    reference_hash?: string;
}
/**
 * General structure of Non-Fungible Token Metadata (in camelCase) as per official NEP-177 standard (https://github.com/near/NEPs/blob/master/neps/nep-0177.md).
 */
export interface NonFungibleTokenMetadata {
    /** ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055" */
    title?: string;
    /** free-form description */
    description?: string;
    /** URL to associated media, preferably to decentralized, content-addressed storage */
    media?: string;
    /** Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included. */
    mediaHash?: string;
    /** number of copies of this set of metadata in existence when token was minted. */
    copies?: number;
    /** When token was issued or minted, Unix epoch in milliseconds */
    issuedAt?: number;
    /** When token expires, Unix epoch in milliseconds */
    expiresAt?: number;
    /** When token starts being valid, Unix epoch in milliseconds */
    startsAt?: number;
    /** When token was last updated, Unix epoch in milliseconds */
    updatedAt?: number;
    /** anything extra the NFT wants to store on-chain. Can be stringified JSON. */
    extra?: string;
    /** URL to an off-chain JSON file with more info. */
    reference?: string;
    /** Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included. */
    referenceHash?: string;
}

'''
'''--- packages/core/lib/lib/types/nft.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

'''
'''--- packages/core/lib/lib/types/params.d.ts ---
import { BrowserWalletBehaviour, Wallet } from "@near-wallet-selector/core/lib/wallet/wallet.types";
import { Maybe } from "../keypom";
import { PasswordPerUse } from "./drops";
import { GeneratedKeyPairs } from "./general";
import { ProtocolReturnedDropConfig, ProtocolReturnedFCData, ProtocolReturnedFTData, ProtocolReturnedNFTData, ProtocolReturnedSimpleData } from "./protocol";
import { Account } from "@near-js/accounts";
import { Transaction } from "@near-js/transactions";
export type AnyWallet = BrowserWalletBehaviour | Wallet | Promise<Wallet>;
/**
 * Information returned when creating a drop or adding keys via `createDrop` and `addKeys` respectively.
 */
export interface CreateOrAddReturn {
    /** The responses to any transactions that were signed and sent to the network. */
    responses?: any;
    /** Information about the transactions if `returnTransactions` is specified in the arguments. This will result in the information being returned instead of signed and sent.  */
    transactions?: Transaction[];
    /** The required deposit that should be attached to the transaction. */
    requiredDeposit?: string;
    /** Any keys that were automatically generated. */
    keys?: GeneratedKeyPairs;
    /** The drop ID for the drop that is being interacted with. */
    dropId: string;
}
/**
 * @ignore
 */
export interface RegisterUsesParams {
    account?: Account;
    wallet?: AnyWallet;
    dropId: string;
    numUses: number;
    useBalance?: boolean;
}
/** @internal */
export interface CreateDropProtocolArgs {
    public_keys?: string[];
    deposit_per_use: string;
    drop_id?: string;
    config?: ProtocolReturnedDropConfig;
    metadata?: string;
    required_gas?: string;
    simple?: ProtocolReturnedSimpleData;
    ft?: ProtocolReturnedFTData;
    nft?: ProtocolReturnedNFTData;
    fc?: ProtocolReturnedFCData;
    passwords_per_use?: Array<Maybe<Array<PasswordPerUse>>>;
}

'''
'''--- packages/core/lib/lib/types/params.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

'''
'''--- packages/core/lib/lib/types/protocol.d.ts ---
import { Maybe } from "../keypom";
/**
 * Key information returned from the Protocol. This interface is exactly the same as the `KeyInfo`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedKeyInfo {
    /** Drop ID for the specific drop that the key belongs to. */
    drop_id: string;
    /** Public key for this access key. */
    public_key: string;
    /** Which use is the key currently on? For single-use keys, this is always 1.  */
    cur_key_use: number;
    /** How many uses this key has left before it's deleted.  */
    remaining_uses: number;
    /** At what timestamp was the key last used? Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC. */
    last_used: number;
    /** How much allowance does the key have left (measured in $yoctoNEAR). When the key is deleted, this is refunded to the funder's balance. */
    allowance: number;
    /** The unique ID associated to this key. IDs are *not* unique across drops but they are unique for any key in the drop. */
    key_id: number;
}
/**
 * Drop information returned from the Protocol. This interface is exactly the same as the `Drop`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedDrop {
    /** Drop ID for this specific drop. */
    drop_id: string;
    /** Which account created this drop. */
    owner_id: string;
    /** How much $yoctoNEAR will be transferred anytime a key is used that is part of this drop. */
    deposit_per_use: string;
    /** For simple drops, there are specific, optional configurations. */
    simple?: ProtocolReturnedSimpleData;
    /** For NFT drops, important information such as the token IDs, or contract need to be stored. */
    nft?: ProtocolReturnedNFTData;
    /** For Fungible Token drops, important information such as the amount of tokens to transfer, or contract need to be stored. */
    ft?: ProtocolReturnedFTData;
    /** For Function-Call drops, important information needs to be stored such as which methods, the attached deposit, args etc. */
    fc?: ProtocolReturnedFCData;
    /** All drops regardless of their type can have a suite of configurations such as how many uses each key has or how often a key can be used. */
    config?: ProtocolReturnedDropConfig;
    /** Any extra information about the drop can be stored as metadata. This is up to the drop creator and can be stringified JSON, or any other string. */
    metadata?: string;
    /** How many key uses are registered for this drop? This is only applicable to simple drops with lazy registrations, FT drops, and NFT drops. */
    registered_uses: number;
    /** In order to use an access key that's part of this drop, how much Gas *needs* to be attached to the call? */
    required_gas: string;
    /** What is the next unique ID that will be given to the next access key added to this drop. */
    next_key_id: number;
    /** If calling `getDrops` or `getDropInformation` and `withKeys` is passed in as true, an extra view call will be done to get a set of keys that are currently on the drop. */
    keys?: ProtocolReturnedKeyInfo[];
}
/**
 * Drop config returned from the Protocol. This interface is exactly the same as the `DropConfig`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedDropConfig {
    /** How many uses can each key have before it's deleted. If this isn't specified, it defaults to 1 use per key. */
    uses_per_key?: number;
    /** Any information related to time-based configurations such as a starting date for keys etc. */
    time?: ProtocolReturnedTimeConfig;
    /** Any information related to how access keys are used such as which methods they can call or whether an empty drop should be automatically deleted etc.*/
    usage?: ProtocolReturnedUsageConfig;
    sale?: ProtocolReturnedPublicSaleConfig;
    /**
     * Override the global root account that all created sub-accounts will have (currently `near` or `testnet`). This allows users to drops that have a custom root.
     * For example, Fayyr could specify a root of `fayyr.near` By which all sub-accounts will then be `ACCOUNT.fayyr.near`.
     * It's important to note that this root account *MUST* have a smart contract deployed that has a method `create_account`.
     */
    root_account_id?: string;
}
/**
 * Time Config information returned from the Protocol. This interface is exactly the same as the `TimeConfig`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedTimeConfig {
    /**
     * Minimum block timestamp before keys can be used. If this isn't specified, keys can be used immediately.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    start?: number;
    /**
     * Block timestamp that keys must be used before. If this isn't specified, keys can be used indefinitely.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    end?: number;
    /**
     * Amount of time that *must* pass in between each key use. If this isn't specified, there is no delay between key uses.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    throttle?: number;
    /**
     * Interval of time after the `start_timestamp` that must pass before a key can be used. If multiple intervals pass, the key can be used multiple times.
     * This has nothing to do With the throttle timestamp. It only pertains to the start timestamp and the current timestamp. The last_used timestamp is not taken into account.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    interval?: number;
}
/**
 * Usage Config information returned from the Protocol. This interface is exactly the same as the `UsageConfig`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedUsageConfig {
    /**
     * Specify which methods can be called by the access key (either `claim` or `create_account_and_claim`). If this isn't specified, both methods can be called.
     */
    permissions?: string;
    /**
     * If the method `claim` is called rather than `create_account_and_claim`, should the `deposit_per_use` be refunded to the owner's balance?
     * If this isn't specified, it defaults to false.
     */
    refund_deposit?: boolean;
    /**
     * When a key is used and deleted, if it results in the drop being empty, should the drop automatically be deleted? If this isn't specified, it defaults to false.
     */
    auto_delete_drop?: boolean;
    /**
     * In the case where `autoDeleteDrop` is set to true and the drop is the owner's last, should their balance be automatically withdrawn? If this isn't specified, it defaults to false.
     */
    auto_withdraw?: boolean;
    /** When calling `create_account` on the root account, which keypom args should be attached to the payload. */
    account_creation_fields?: {
        /**
         * Specifies what field Keypom should auto-inject the account that claimed the drop's ID into when calling the `create_account` function.
         */
        account_id_field?: string;
        /**
         * Specifies what field Keypom should auto-inject the drop's ID into when calling the `create_account` function.
         */
        drop_id_field?: string;
        /**
         * Specifies what field Keypom should auto-inject the key's ID into when calling the `create_account` function.
         */
        key_id_field?: string;
        /**
         * Specifies what field Keypom should auto-inject the drop funder's account ID into when calling the `create_account` function.
         */
        funder_id_field?: string;
    };
}
/**
 * Within the config, there are configurable options related to how keys can be sold and a funder can potentially make a profit.
 */
export interface ProtocolReturnedPublicSaleConfig {
    /** Maximum number of keys that can be added to this drop. If None, there is no max. */
    max_num_keys?: number;
    /**
     * Amount of $NEAR that the user needs to attach (if they are not the funder) on top of costs. This amount will be
     * Automatically sent to the funder's balance. If None, the keys are free to the public.
     */
    price_per_key?: string;
    /** Which accounts are allowed to add keys? If the allowlist is empty, anyone that is not in the blocklist can add keys. */
    allowlist?: string[];
    /** Which accounts are NOT allowed to add keys? */
    blocklist?: string[];
    /**
     * Should the revenue generated be sent to the funder's account balance or
     * automatically withdrawn and sent to their NEAR wallet?
     */
    auto_withdraw_funds?: boolean;
    /**
     * Minimum block timestamp before the public sale starts. If None, keys can be added immediately
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    start?: number;
    /**
     * Block timestamp dictating the end of the public sale. If None, keys can be added indefinitely
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    end?: number;
}
export interface ProtocolReturnedSimpleData {
    lazy_register?: boolean;
}
/**
 * NFT Data information returned from the Protocol. This interface is exactly the same as the `NFTData`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedNFTData {
    /** The account ID that the NFT contract is deployed to. This contract is where all the NFTs for the specific drop must come from. */
    contract_id: string;
    /** By default, anyone can fund your drop with NFTs. This field allows you to set a specific account ID that will be locked into sending the NFTs. */
    sender_id?: string;
}
/**
 * FT Data returned from the Protocol. This interface is exactly the same as the `FTData`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedFTData {
    /**
     * Which contract do the FTs belong to?
     */
    contract_id: string;
    /**
     * By default, anyone can fund your drop with FTs. This field allows you to set a specific account ID that will be locked into sending the FTs.
     */
    sender_id?: string;
    /**
     * Amount of tokens to transfer but considering the decimal amount.
     * Example: transferring one wNEAR should be passed in as "1000000000000000000000000" and NOT "1"
     */
    balance_per_use?: string;
}
/**
 * Method information returned from the Protocol. This interface is exactly the same as the `Method`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedMethod {
    /**
     * The account ID that the contract is deployed to that the method will be called on.
     */
    receiver_id: string;
    /**
     * The method that should be invoked on the `receiverId`'s contract.
     */
    method_name: string;
    /**
     * What arguments should be passed to the method. This should be in stringified JSON.
     */
    args: string;
    /**
     * How much yoctoNEAR should be attached to the call.
     */
    attached_deposit: string;
    /**
     * How much gas to attach to this method call. If none, all the gas is split between the parallel method calls in a given claim.
     * If this is specified, the key can ONLY be used to call `claim` and no `deposit_per_use` can be specified. This leads the key to act like a method calling proxy instead of a linkdrop.
     */
    attached_gas?: string;
    /**
     * Specifies what field Keypom should auto-inject the account that claimed the drop's ID into when calling the function.
     * As an example, if the methodName was `nft_mint` and it expected a field `receiver_id` to be passed in, indicating who should receive the token, then the `accountIdField` would be `receiver_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    account_id_field?: string;
    /**
     * Specifies what field Keypom should auto-inject the drops ID into when calling the function.
     * As an example, if an NFT contract expected the Keypom drop ID to be passed in as the field `keypom_drop_id` in order to gate access to who can mint NFTs, then the `dropIdField` would be `keypom_drop_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    drop_id_field?: string;
    /**
     * Specifies what field Keypom should auto-inject the key's ID into when calling the function.
     * As an example, if an NFT contract wanted to gate only users with an odd key ID to be able to mint an NFT and their parameter was called `keypom_key_id`, then the `keyIdField` would be `keypom_key_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    key_id_field?: string;
    /**
     * Specifies what field Keypom should auto-inject the funder's account ID into when calling the function.
     * As an example, if an NFT contract wanted to gate only users with an odd key ID to be able to mint an NFT and their parameter was called `keypom_key_id`, then the `keyIdField` would be `keypom_key_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    funder_id_field?: string;
    /**
     * If set to true, the claiming account ID will be the receiver ID of the method call.
     * This receiver must be a valid account and non-malicious (cannot be set to the keypom contract)
     **/
    receiver_to_claimer?: boolean;
    /**
     * What permissions does the user have when providing custom arguments to the function call?
     * By default, the user cannot provide any custom arguments
     */
    user_args_rule?: "AllUser" | "FunderPreferred" | "UserPreferred";
}
/**
 * FC Data returned from the Protocol. This interface is exactly the same as the `FCData`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedFCData {
    /**
     * The top level array indicates a different set of methods that can be called for every key use. It is possible that for a given key use, no methods are called thus acting as a "free" key use whereby the use is reflected on-chain but no assets are transferred.
     * If a given key use does not have an undefined set of methods, when it is used, all the methods in the set will be called.
     */
    methods: Array<Maybe<Array<ProtocolReturnedMethod>>>;
}

'''
'''--- packages/core/lib/lib/types/protocol.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

'''
'''--- packages/core/lib/lib/types/simple.d.ts ---
/**
 * Specific configurable information for Simple drops.
 */
export interface SimpleData {
    /** If this is set to true, keys can be created and registered AFTER they've been created (for simple and FC drops only). */
    lazyRegister?: boolean;
}

'''
'''--- packages/core/lib/lib/types/simple.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

'''
'''--- packages/core/lib/lib/views.d.ts ---
import { Maybe } from './keypom';
import { ContractSourceMetadata } from './types/general';
import { ProtocolReturnedDrop, ProtocolReturnedKeyInfo, ProtocolReturnedMethod } from './types/protocol';
/**
 * Returns the balance associated a with given public key. If only the secret key is known, this can be passed in instead. This is used by the NEAR wallet to display the amount of the linkdrop
 *
 * @param {string=} publicKey The public key that contains a balance
 * @param {string=} secretKey The secret key corresponding to the public key
 *
 * @returns {Promise<string>} The amount of yoctoNEAR that is contained within the key
 *
 * @example
 * Create a 1 $NEAR linkdrop and query for its balance:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the amount of yoctoNEAR contained within the key
 * const keyBalance = await getKeyBalance({
 *     publicKey: keys.publicKeys[0]
 * })
 *
 * console.log('keyBalance: ', keyBalance)
 * ```
 * @group View Functions
 */
export declare const getKeyBalance: ({ publicKey, secretKey, }: {
    publicKey?: string;
    secretKey?: string;
}) => Promise<string>;
/**
 * Query for the total supply of keys currently on the Keypom contract
 *
 * @returns {Promise<number>} The amount of keys.
 *
 * @example
 * Query for the key supply on the `v1.keypom.testnet` contract:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls
 * await initKeypom({
 *     network: "testnet",
 *     keypomContractId: "v1.keypom.testnet"
 * });
 *
 * // Query for the number of keys on the contract
 * const numKeys = await getKeyTotalSupply();
 *
 * console.log('numKeys: ', numKeys)
 * ```
 * @group View Functions
 */
export declare const getKeyTotalSupply: () => Promise<number>;
/**
 * Paginate through all active keys on the contract and return a vector of key info.
 *
 * @param {string= | number=} __namedParameters.start (OPTIONAL) Where to start paginating through keys.
 * @param {number=} __namedParameters.limit (OPTIONAL) How many keys to paginate through.
 *
 * @returns {Promise<Array<KeyInfo>>} Vector of KeyInfo.
 *
 * @example
 * Query for first 50 keys on the `v1.keypom.testnet` contract:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls
 * await initKeypom({
 *     network: "testnet",
 *     keypomContractId: "v1.keypom.testnet"
 * });
 *
 * // Query for the first 50 keys on the contract
 * const keyInfo = await getKeys({
 *   start: 0,
 *   limit: 50
 * });
 *
 * console.log('keyInfo: ', keyInfo)
 * ```
 * @group View Functions
 */
export declare const getKeys: ({ start, limit, }: {
    start?: string | number;
    limit?: number;
}) => Promise<Array<ProtocolReturnedKeyInfo>>;
/**
 * Returns the KeyInfo corresponding to a specific public key
 *
 * @param {string=} publicKey the public key to get information for.
 * @param {string=} secretKey The secret key corresponding to the public key
 *
 * @returns {Promise<KeyInfo>} Key information struct for that specific key.
 *
 * @example
 * Create a drop and query for the key information:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key information for the key that was created
 * const keyInfo = await getKeyInformation({
 *     publicKey: keys.publicKeys[0]
 * })
 *
 * console.log('keyInfo: ', keyInfo)
 * ```
 * @group View Functions
 */
export declare const getKeyInformation: ({ publicKey, secretKey, }: {
    publicKey?: string;
    secretKey?: string;
}) => Promise<ProtocolReturnedKeyInfo>;
/**
 * Returns a vector of KeyInfo corresponding to a set of public keys passed in.
 *
 * @param {string[]=} publicKeys Array of public keys to get information about
 * @param {string[]=} secretKeys Array of the secret keys corresponding to the public keys
 *
 * @returns {Promise<Array<KeyInfo>>} Array of Key information structs for the keys passed in
 *
 * @example
 * Create a drop and query for the key information for all keys created:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 5 keys automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 5,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key information for the key that was created
 * const keyInfos = await getKeyInformationBatch({
 *     publicKeys: keys.publicKeys
 * })
 *
 * console.log('keyInfos: ', keyInfos)
 * ```
 * @group View Functions
 */
export declare const getKeyInformationBatch: ({ publicKeys, secretKeys, }: {
    publicKeys?: string[];
    secretKeys?: string[];
}) => Promise<Array<ProtocolReturnedKeyInfo>>;
/**
 * Get information about a specific drop by passing in either a drop ID, public key, or secret key.
 *
 * @param {string=} dropId (OPTIONAL) The drop ID for the specific drop that you want to get information about.
 * @param {string=} publicKey (OPTIONAL) A valid public key that is part of a drop.
 * @param {string=} secretKey (OPTIONAL) The secret key corresponding to a valid public key that is part of a drop.
 * @param {boolean=} withKeys (OPTIONAL) Whether or not to include key information for the first 50 keys in each drop.
 *
 * @returns {Drop} Drop information which may or may not have a keys field of type `KeyInfo` depending on if withKeys is specified as true.
 *
 * @example
 * Create a simple drop and retrieve information about it:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {dropId} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the drop information and also return the key information as well
 * const dropInfo = await getDropInformation({
 *     dropId,
 *     withKeys: true
 * })
 *
 * console.log('dropInfo: ', dropInfo)
 * ```
 *
 * @example
 * Create a simple drop and get the drop information based on a public key and then the secret key:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the drop information and also return the key information as well
 * let dropInfo = await getDropInformation({
 * 	   publicKey: keys.publicKeys[0],
 *     withKeys: true
 * })
 *
 * console.log('dropInfo via public key: ', dropInfo)
 *
 * // Query for the drop information and also return the key information as well
 * dropInfo = await getDropInformation({
 * 	   secretKey: keys.secretKeys[0],
 *     withKeys: true
 * })
 *
 * console.log('dropInfo via secret key: ', dropInfo)
 * ```
 * @group View Functions
 */
export declare const getDropInformation: ({ dropId, secretKey, publicKey, withKeys, }: {
    dropId?: string;
    secretKey?: string;
    publicKey?: string;
    withKeys?: boolean;
}) => Promise<ProtocolReturnedDrop>;
/**
 * Returns the total supply of active keys for a given drop
 *
 * @param {string} dropId The drop ID for the specific drop that you want to get information about.
 *
 * @returns {Promise<number>} Number of active keys
 *
 * @example
 * Create a drop with 5 keys and query for the key supply:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 5 keys automatically created. That key will be completely random since there is no entropy.
 * const {keys, dropId} = await createDrop({
 *     numKeys: 5,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key supply for the drop that was created
 * const keySupply = await getKeySupplyForDrop({
 *     dropId
 * })
 *
 * console.log('keySupply: ', keySupply)
 * ```
 * @group View Functions
 */
export declare const getKeySupplyForDrop: ({ dropId, }: {
    dropId: string;
}) => Promise<number>;
/**
 * Paginate through all keys in a specific drop, returning an array of KeyInfo.
 *
 * @param {string} dropId The drop ID for the specific drop that you want to get information about.
 * @param {string= | number=} start (OPTIONAL) Where to start paginating through keys.
 * @param {number=} limit (OPTIONAL) How many keys to paginate through.
 *
 * @returns {Promise<Array<KeyInfo>>} Vector of KeyInfo objects returned from pagination
 *
 * @example
 * Create a drop with 5 keys and return all the key info objects:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 5 keys automatically created. That key will be completely random since there is no entropy.
 * const {dropId} = await createDrop({
 *     numKeys: 5,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key supply for the drop that was created
 * const keyInfos = await getKeysForDrop({
 *     dropId
 * })
 *
 * console.log('keyInfos: ', keyInfos)
 * ```
 * @group View Functions
 */
export declare const getKeysForDrop: ({ dropId, start, limit, }: {
    dropId: string;
    start?: string | number;
    limit?: number;
}) => Promise<Array<ProtocolReturnedKeyInfo>>;
/**
 * Returns the total supply of active drops for a given account ID
 *
 * @param {string} accountId The account that the drops belong to.
 *
 * @returns {Promise<number>} Amount of drops
 *
 * @example
 * Create a drop and check how many the owner has:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with no keys
 * await createDrop({
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the amount of drops owned by the account
 * const dropSupply = await getDropSupplyForOwner({
 *     accountId: "benji_demo.testnet"
 * })
 *
 * console.log('dropSupply: ', dropSupply)
 * ```
 * @group View Functions
 */
export declare const getDropSupplyForOwner: ({ accountId, }: {
    accountId: string;
}) => Promise<number>;
/**
 * Paginate through drops owned by an account. If specified, information for the first 50 keys in each drop can be returned as well.
 *
 * @param {string} accountId The funding account that the drops belong to.
 * @param {string= | number=} start (OPTIONAL) Where to start paginating through drops.
 * @param {number=} limit (OPTIONAL) How many drops to paginate through.
 * @param {boolean=} withKeys (OPTIONAL) Whether or not to include key information for the first 50 keys in each drop.
 *
 * @example
 * Get drop information for the last 5 drops owned by a given account:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * 	network: "testnet",
 * });
 *
 * // Get the number of drops the account has.
 * const numDrops = await getDropSupply({
 * 	accountId: "benjiman.testnet"
 * });
 *
 * // Query for drop information for the last 5 drops and their respective keys
 * const dropsAndKeys = await getDrops({
 * 	accountId: "benjiman.testnet",
 * 	start: numDrops - 5,
 * 	withKeys: true
 * })
 *
 * console.log('dropsAndKeys: ', dropsAndKeys)
 * ```
 * @group View Functions
 */
export declare const getDrops: ({ accountId, start, limit, withKeys, }: {
    /** The funding account that the drops belong to. */
    accountId: string;
    /** Where to start paginating through drops. */
    start: string | number;
    /** How many drops to paginate through. */
    limit: number;
    /** Whether or not to include key information for the first 50 keys in each drop. */
    withKeys: boolean;
}) => Promise<ProtocolReturnedDrop[]>;
/**
 * Return the total supply of token IDs for a given NFT drop.
 *
 * @param {string} dropId The drop ID that the tokens belong to.
 *
 * @returns {Promise<number>} The amount of token IDs on the drop
 *
 * @example
 * Query for the supply of tokens on a specific drop:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for the amount of token IDs on the drop
 * const tokenSupply = await getNftSupplyForDrop({
 *   dropId: "1669840629120"
 * })
 *
 * console.log('tokenSupply: ', tokenSupply)
 * ```
 * @group View Functions
 */
export declare const getNftSupplyForDrop: ({ dropId, }: {
    dropId: string;
}) => Promise<number>;
/**
 * Paginate through token IDs in an NFT drop to return a vector of token IDs.
 *
 * @param {string} dropId The drop ID that the tokens belong to.
 * @param {string= | number=} start (OPTIONAL) Where to start paginating from.
 * @param {number=} limit (OPTIONAL) How many token IDs to paginate through.
 *
 * @returns {Promise<Array<string>>} Vector of token IDs
 *
 * @example
 * Query for a list of token IDs on a specific drop:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for a set of token IDs on the drop
 * const tokenList = await getNftTokenIDsForDrop({
 *   dropId: "1669840629120"
 * })
 *
 * console.log('tokenList: ', tokenList)
 * ```
 * @group View Functions
 */
export declare const getNftTokenIDsForDrop: ({ dropId, start, limit, }: {
    dropId: string;
    start?: string | number;
    limit?: number;
}) => Promise<Array<string>>;
/**
 * Query for a user's current balance on the Keypom contract
 *
 * @param {string} accountId The account ID of the user to retrieve the balance for.
 *
 * @returns {string} The user's current balance
 *
 * @example
 * Query for a user's current balance on the Keypom contract:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for the drop information for a specific drop
 * const userBal = await getUserBalance({
 * accountId: "benjiman.testnet",
 * })
 *
 * console.log('userBal: ', userBal)
 * ```
 * @group View Functions
 */
export declare const getUserBalance: ({ accountId, }: {
    accountId: string;
}) => Promise<string>;
/**
 * Query for the current method data for a given key. This pertains to FC drops and the current method data is either null or an array of methods that will be invoked when the key is claimed next.
 *
 * @param {string=} secretKey (OPTIONAL) The secret key of the key to retrieve the method data for. If no secret key is passed in, the public key must be passed in.
 * @param {string=} publicKey (OPTIONAL) The public key of the key to retrieve the method data for. If no public key is passed in, the secret key must be passed in.
 * @param {number=} keyUse (OPTIONAL) Pass in a specific key use (*NOT* zero indexed) to retrieve the method data for. If no key use is passed in, the method data for the current key use will be returned.
 *
 * @returns {Promise<Maybe<Array<ProtocolReturnedMethod>>>} The current method data for the key
 *
 * @example
 * ```js
 * const fcData = {
 * 	methods: [
 * 		null,
 * 		[
 * 			{
 * 				methodName: "nft_token",
 * 				receiverId: "nft.examples.testnet",
 * 				args: JSON.stringify({
 * 					token_id: "1"
 * 				}),
 * 				attachedDeposit: "0"
 * 			},
 * 			{
 * 				methodName: "nft_token",
 * 				receiverId: "nft.examples.testnet",
 * 				args: JSON.stringify({
 * 					token_id: "2"
 * 				}),
 * 				attachedDeposit: "0"
 * 			}
 * 		],
 * 		null
 * 	]
 * }
 *
 * const {keys: {publicKeys, secretKeys}} = await createDrop({
 * 	numKeys: 1,
 * 	depositPerUseNEAR: 0,
 * 	fcData,
 * 	config: {
 * 		usesPerKey: 3
 * 	}
 * });
 * const secretKey = secretKeys[0];
 *
 * let curMethodData = await getCurMethodData({secretKey});
 * console.log('curMethodData (first): ', curMethodData)
 * t.is(curMethodData, null);
 *
 * 	curMethodData = await getCurMethodData({secretKey, keyUse: 1});
 *	t.is(curMethodData, null);
 *	curMethodData = await getCurMethodData({secretKey, keyUse: 2});
 *	t.true(curMethodData != null);
 *	curMethodData = await getCurMethodData({secretKey, keyUse: 3});
 *	t.is(curMethodData, null);
 *
 * await claim({secretKey, accountId: 'foobar'})
 * curMethodData = await getCurMethodData({secretKey});
 * t.true(curMethodData != null);
 *
 * await claim({secretKey, accountId: 'foobar'})
 * curMethodData = await getCurMethodData({secretKey});
 * console.log('curMethodData (third): ', curMethodData)
 * t.is(curMethodData, null);
 * ```
 * @group View Functions
 */
export declare const getCurMethodData: ({ secretKey, publicKey, keyUse, }: {
    secretKey?: string;
    publicKey?: string;
    keyUse?: number;
}) => Promise<Maybe<Array<ProtocolReturnedMethod>>>;
/**
 * Check if a given user can add keys to a drop. The only case where a user *other than the funder* could add keys is if the drop has a public sale running.
 *
 * @param {string} dropId The drop ID to check if the user can add keys to
 * @param {string} accountId The account ID of the user to check if they can add keys to the drop
 *
 * @returns {Promise<boolean>} Whether or not the user can add keys to the drop
 *
 * @example
 * ```js
 * await createDrop({
 * 	numKeys: 0,
 * 	depositPerUseNEAR: 0,
 * 	config: {
 * 		sale: {
 * 			maxNumKeys: 2,
 * 			pricePerKeyNEAR: 1
 * 		}
 * 	}
 * });
 *
 * const canAddKeys = await canUserAddKeys({accountId: "foobar.testnet"});
 * t.is(canAddKeys, true);
 * ```
 *
 * @group View Functions
 */
export declare const canUserAddKeys: ({ dropId, accountId, }: {
    dropId: string;
    accountId: string;
}) => Promise<boolean>;
/**
 * Returns the source metadata for the Keypom contract that the SDK has been initialized on. This includes valuable information
 * such as which specific version the contract is on and link to exactly which GitHub commit is deployed.
 *
 * @returns {ContractSourceMetadata} The contract's source metadata
 *
 * @example
 * Query for the current Keypom contract's source metadata:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for the Keypom contract's source metadata
 * const metadata = await getContractSourceMetadata();
 *
 * console.log('metadata: ', metadata)
 * ```
 * @group View Functions
 */
export declare const getContractSourceMetadata: () => Promise<ContractSourceMetadata>;

'''
'''--- packages/core/lib/lib/views.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getContractSourceMetadata = exports.canUserAddKeys = exports.getCurMethodData = exports.getUserBalance = exports.getNftTokenIDsForDrop = exports.getNftSupplyForDrop = exports.getDrops = exports.getDropSupplyForOwner = exports.getKeysForDrop = exports.getKeySupplyForDrop = exports.getDropInformation = exports.getKeyInformationBatch = exports.getKeyInformation = exports.getKeys = exports.getKeyTotalSupply = exports.getKeyBalance = void 0;
const checks_1 = require("./checks");
const drops_1 = require("./drops");
const keypom_1 = require("./keypom");
const keypom_utils_1 = require("./keypom-utils");
/**
 * Returns the balance associated a with given public key. If only the secret key is known, this can be passed in instead. This is used by the NEAR wallet to display the amount of the linkdrop
 *
 * @param {string=} publicKey The public key that contains a balance
 * @param {string=} secretKey The secret key corresponding to the public key
 *
 * @returns {Promise<string>} The amount of yoctoNEAR that is contained within the key
 *
 * @example
 * Create a 1 $NEAR linkdrop and query for its balance:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the amount of yoctoNEAR contained within the key
 * const keyBalance = await getKeyBalance({
 *     publicKey: keys.publicKeys[0]
 * })
 *
 * console.log('keyBalance: ', keyBalance)
 * ```
 * @group View Functions
 */
const getKeyBalance = ({ publicKey, secretKey, }) => __awaiter(void 0, void 0, void 0, function* () {
    // Assert that either a secretKey or public key is passed in
    (0, checks_1.assert)(secretKey || publicKey, 'Must pass in either a publicKey or a secretKey');
    if (secretKey) {
        publicKey = (0, keypom_utils_1.getPubFromSecret)(secretKey);
    }
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_key_balance',
        args: {
            key: publicKey,
        },
    });
});
exports.getKeyBalance = getKeyBalance;
/**
 * Query for the total supply of keys currently on the Keypom contract
 *
 * @returns {Promise<number>} The amount of keys.
 *
 * @example
 * Query for the key supply on the `v1.keypom.testnet` contract:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls
 * await initKeypom({
 *     network: "testnet",
 *     keypomContractId: "v1.keypom.testnet"
 * });
 *
 * // Query for the number of keys on the contract
 * const numKeys = await getKeyTotalSupply();
 *
 * console.log('numKeys: ', numKeys)
 * ```
 * @group View Functions
 */
const getKeyTotalSupply = () => __awaiter(void 0, void 0, void 0, function* () {
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_key_total_supply',
        args: {},
    });
});
exports.getKeyTotalSupply = getKeyTotalSupply;
/**
 * Paginate through all active keys on the contract and return a vector of key info.
 *
 * @param {string= | number=} __namedParameters.start (OPTIONAL) Where to start paginating through keys.
 * @param {number=} __namedParameters.limit (OPTIONAL) How many keys to paginate through.
 *
 * @returns {Promise<Array<KeyInfo>>} Vector of KeyInfo.
 *
 * @example
 * Query for first 50 keys on the `v1.keypom.testnet` contract:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls
 * await initKeypom({
 *     network: "testnet",
 *     keypomContractId: "v1.keypom.testnet"
 * });
 *
 * // Query for the first 50 keys on the contract
 * const keyInfo = await getKeys({
 *   start: 0,
 *   limit: 50
 * });
 *
 * console.log('keyInfo: ', keyInfo)
 * ```
 * @group View Functions
 */
const getKeys = ({ start, limit, }) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_keys',
        args: {
            from_index: start === null || start === void 0 ? void 0 : start.toString(),
            limit,
        },
    });
});
exports.getKeys = getKeys;
/**
 * Returns the KeyInfo corresponding to a specific public key
 *
 * @param {string=} publicKey the public key to get information for.
 * @param {string=} secretKey The secret key corresponding to the public key
 *
 * @returns {Promise<KeyInfo>} Key information struct for that specific key.
 *
 * @example
 * Create a drop and query for the key information:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key information for the key that was created
 * const keyInfo = await getKeyInformation({
 *     publicKey: keys.publicKeys[0]
 * })
 *
 * console.log('keyInfo: ', keyInfo)
 * ```
 * @group View Functions
 */
const getKeyInformation = ({ publicKey, secretKey, }) => __awaiter(void 0, void 0, void 0, function* () {
    // Assert that either a secretKey or public key is passed in
    (0, checks_1.assert)(secretKey || publicKey, 'Must pass in either a publicKey or a secretKey');
    if (secretKey) {
        publicKey = (0, keypom_utils_1.getPubFromSecret)(secretKey);
    }
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_key_information',
        args: {
            key: publicKey,
        },
    });
});
exports.getKeyInformation = getKeyInformation;
/**
 * Returns a vector of KeyInfo corresponding to a set of public keys passed in.
 *
 * @param {string[]=} publicKeys Array of public keys to get information about
 * @param {string[]=} secretKeys Array of the secret keys corresponding to the public keys
 *
 * @returns {Promise<Array<KeyInfo>>} Array of Key information structs for the keys passed in
 *
 * @example
 * Create a drop and query for the key information for all keys created:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 5 keys automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 5,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key information for the key that was created
 * const keyInfos = await getKeyInformationBatch({
 *     publicKeys: keys.publicKeys
 * })
 *
 * console.log('keyInfos: ', keyInfos)
 * ```
 * @group View Functions
 */
const getKeyInformationBatch = ({ publicKeys, secretKeys, }) => __awaiter(void 0, void 0, void 0, function* () {
    // Assert that either secretKeys or public keys are passed in
    (0, checks_1.assert)(secretKeys || publicKeys, 'Must pass in either publicKeys or secretKeys');
    if (secretKeys) {
        // Map the secret keys into public keys by calling getPubFromSecret
        publicKeys = secretKeys.map((secretKey) => {
            return (0, keypom_utils_1.getPubFromSecret)(secretKey);
        });
    }
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_key_information_batch',
        args: {
            keys: publicKeys,
        },
    });
});
exports.getKeyInformationBatch = getKeyInformationBatch;
/**
 * Get information about a specific drop by passing in either a drop ID, public key, or secret key.
 *
 * @param {string=} dropId (OPTIONAL) The drop ID for the specific drop that you want to get information about.
 * @param {string=} publicKey (OPTIONAL) A valid public key that is part of a drop.
 * @param {string=} secretKey (OPTIONAL) The secret key corresponding to a valid public key that is part of a drop.
 * @param {boolean=} withKeys (OPTIONAL) Whether or not to include key information for the first 50 keys in each drop.
 *
 * @returns {Drop} Drop information which may or may not have a keys field of type `KeyInfo` depending on if withKeys is specified as true.
 *
 * @example
 * Create a simple drop and retrieve information about it:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {dropId} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the drop information and also return the key information as well
 * const dropInfo = await getDropInformation({
 *     dropId,
 *     withKeys: true
 * })
 *
 * console.log('dropInfo: ', dropInfo)
 * ```
 *
 * @example
 * Create a simple drop and get the drop information based on a public key and then the secret key:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the drop information and also return the key information as well
 * let dropInfo = await getDropInformation({
 * 	   publicKey: keys.publicKeys[0],
 *     withKeys: true
 * })
 *
 * console.log('dropInfo via public key: ', dropInfo)
 *
 * // Query for the drop information and also return the key information as well
 * dropInfo = await getDropInformation({
 * 	   secretKey: keys.secretKeys[0],
 *     withKeys: true
 * })
 *
 * console.log('dropInfo via secret key: ', dropInfo)
 * ```
 * @group View Functions
 */
const getDropInformation = ({ dropId, secretKey, publicKey, withKeys = false, }) => __awaiter(void 0, void 0, void 0, function* () {
    const { contractId, viewCall } = (0, keypom_1.getEnv)();
    // Assert that either a dropId or a secretKey is passed in
    (0, checks_1.assert)(dropId || secretKey || publicKey, 'Must pass in either a dropId, publicKey or a secretKey to getDropInformation');
    if (secretKey) {
        publicKey = (0, keypom_utils_1.getPubFromSecret)(secretKey);
    }
    const dropInfo = yield viewCall({
        contractId,
        methodName: 'get_drop_information',
        args: {
            drop_id: dropId,
            key: publicKey,
        },
    });
    if (withKeys) {
        dropInfo.keys = yield (0, keypom_utils_1.keypomView)({
            methodName: 'get_keys_for_drop',
            args: {
                drop_id: dropInfo.drop_id,
                from_index: '0',
                limit: drops_1.KEY_LIMIT,
            },
        });
    }
    return dropInfo;
});
exports.getDropInformation = getDropInformation;
/**
 * Returns the total supply of active keys for a given drop
 *
 * @param {string} dropId The drop ID for the specific drop that you want to get information about.
 *
 * @returns {Promise<number>} Number of active keys
 *
 * @example
 * Create a drop with 5 keys and query for the key supply:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 5 keys automatically created. That key will be completely random since there is no entropy.
 * const {keys, dropId} = await createDrop({
 *     numKeys: 5,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key supply for the drop that was created
 * const keySupply = await getKeySupplyForDrop({
 *     dropId
 * })
 *
 * console.log('keySupply: ', keySupply)
 * ```
 * @group View Functions
 */
const getKeySupplyForDrop = ({ dropId, }) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_key_supply_for_drop',
        args: {
            drop_id: dropId,
        },
    });
});
exports.getKeySupplyForDrop = getKeySupplyForDrop;
/**
 * Paginate through all keys in a specific drop, returning an array of KeyInfo.
 *
 * @param {string} dropId The drop ID for the specific drop that you want to get information about.
 * @param {string= | number=} start (OPTIONAL) Where to start paginating through keys.
 * @param {number=} limit (OPTIONAL) How many keys to paginate through.
 *
 * @returns {Promise<Array<KeyInfo>>} Vector of KeyInfo objects returned from pagination
 *
 * @example
 * Create a drop with 5 keys and return all the key info objects:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 5 keys automatically created. That key will be completely random since there is no entropy.
 * const {dropId} = await createDrop({
 *     numKeys: 5,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key supply for the drop that was created
 * const keyInfos = await getKeysForDrop({
 *     dropId
 * })
 *
 * console.log('keyInfos: ', keyInfos)
 * ```
 * @group View Functions
 */
const getKeysForDrop = ({ dropId, start, limit, }) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_keys_for_drop',
        args: {
            drop_id: dropId,
            from_index: start === null || start === void 0 ? void 0 : start.toString(),
            limit,
        },
    });
});
exports.getKeysForDrop = getKeysForDrop;
/**
 * Returns the total supply of active drops for a given account ID
 *
 * @param {string} accountId The account that the drops belong to.
 *
 * @returns {Promise<number>} Amount of drops
 *
 * @example
 * Create a drop and check how many the owner has:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with no keys
 * await createDrop({
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the amount of drops owned by the account
 * const dropSupply = await getDropSupplyForOwner({
 *     accountId: "benji_demo.testnet"
 * })
 *
 * console.log('dropSupply: ', dropSupply)
 * ```
 * @group View Functions
 */
const getDropSupplyForOwner = ({ accountId, }) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_drop_supply_for_owner',
        args: {
            account_id: accountId,
        },
    });
});
exports.getDropSupplyForOwner = getDropSupplyForOwner;
/**
 * Paginate through drops owned by an account. If specified, information for the first 50 keys in each drop can be returned as well.
 *
 * @param {string} accountId The funding account that the drops belong to.
 * @param {string= | number=} start (OPTIONAL) Where to start paginating through drops.
 * @param {number=} limit (OPTIONAL) How many drops to paginate through.
 * @param {boolean=} withKeys (OPTIONAL) Whether or not to include key information for the first 50 keys in each drop.
 *
 * @example
 * Get drop information for the last 5 drops owned by a given account:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * 	network: "testnet",
 * });
 *
 * // Get the number of drops the account has.
 * const numDrops = await getDropSupply({
 * 	accountId: "benjiman.testnet"
 * });
 *
 * // Query for drop information for the last 5 drops and their respective keys
 * const dropsAndKeys = await getDrops({
 * 	accountId: "benjiman.testnet",
 * 	start: numDrops - 5,
 * 	withKeys: true
 * })
 *
 * console.log('dropsAndKeys: ', dropsAndKeys)
 * ```
 * @group View Functions
 */
const getDrops = ({ accountId, start, limit, withKeys = false, }) => __awaiter(void 0, void 0, void 0, function* () {
    const drops = yield (0, keypom_utils_1.keypomView)({
        methodName: 'get_drops_for_owner',
        args: {
            account_id: accountId,
            from_index: start ? start.toString() : undefined,
            limit: limit ? limit : undefined,
        },
    });
    if (withKeys) {
        (0, checks_1.assert)(drops.length <= 20, 'Too many RPC requests in parallel. Use \'limit\' arg 20 or less.');
        yield Promise.all(drops.map((drop, i) => __awaiter(void 0, void 0, void 0, function* () {
            const { drop_id } = drop;
            drop.keys = yield (0, keypom_utils_1.keypomView)({
                methodName: 'get_keys_for_drop',
                args: {
                    drop_id,
                    from_index: '0',
                    limit: drops_1.KEY_LIMIT,
                },
            });
        })));
    }
    return drops;
});
exports.getDrops = getDrops;
/**
 * Return the total supply of token IDs for a given NFT drop.
 *
 * @param {string} dropId The drop ID that the tokens belong to.
 *
 * @returns {Promise<number>} The amount of token IDs on the drop
 *
 * @example
 * Query for the supply of tokens on a specific drop:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for the amount of token IDs on the drop
 * const tokenSupply = await getNftSupplyForDrop({
 *   dropId: "1669840629120"
 * })
 *
 * console.log('tokenSupply: ', tokenSupply)
 * ```
 * @group View Functions
 */
const getNftSupplyForDrop = ({ dropId, }) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_nft_supply_for_drop',
        args: {
            drop_id: dropId,
        },
    });
});
exports.getNftSupplyForDrop = getNftSupplyForDrop;
/**
 * Paginate through token IDs in an NFT drop to return a vector of token IDs.
 *
 * @param {string} dropId The drop ID that the tokens belong to.
 * @param {string= | number=} start (OPTIONAL) Where to start paginating from.
 * @param {number=} limit (OPTIONAL) How many token IDs to paginate through.
 *
 * @returns {Promise<Array<string>>} Vector of token IDs
 *
 * @example
 * Query for a list of token IDs on a specific drop:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for a set of token IDs on the drop
 * const tokenList = await getNftTokenIDsForDrop({
 *   dropId: "1669840629120"
 * })
 *
 * console.log('tokenList: ', tokenList)
 * ```
 * @group View Functions
 */
const getNftTokenIDsForDrop = ({ dropId, start, limit, }) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_nft_token_ids_for_drop',
        args: {
            drop_id: dropId,
            from_index: start,
            limit,
        },
    });
});
exports.getNftTokenIDsForDrop = getNftTokenIDsForDrop;
/**
 * Query for a user's current balance on the Keypom contract
 *
 * @param {string} accountId The account ID of the user to retrieve the balance for.
 *
 * @returns {string} The user's current balance
 *
 * @example
 * Query for a user's current balance on the Keypom contract:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for the drop information for a specific drop
 * const userBal = await getUserBalance({
 * accountId: "benjiman.testnet",
 * })
 *
 * console.log('userBal: ', userBal)
 * ```
 * @group View Functions
 */
const getUserBalance = ({ accountId, }) => __awaiter(void 0, void 0, void 0, function* () {
    return (0, keypom_utils_1.keypomView)({
        methodName: 'get_user_balance',
        args: {
            account_id: accountId,
        },
    });
});
exports.getUserBalance = getUserBalance;
/**
 * Query for the current method data for a given key. This pertains to FC drops and the current method data is either null or an array of methods that will be invoked when the key is claimed next.
 *
 * @param {string=} secretKey (OPTIONAL) The secret key of the key to retrieve the method data for. If no secret key is passed in, the public key must be passed in.
 * @param {string=} publicKey (OPTIONAL) The public key of the key to retrieve the method data for. If no public key is passed in, the secret key must be passed in.
 * @param {number=} keyUse (OPTIONAL) Pass in a specific key use (*NOT* zero indexed) to retrieve the method data for. If no key use is passed in, the method data for the current key use will be returned.
 *
 * @returns {Promise<Maybe<Array<ProtocolReturnedMethod>>>} The current method data for the key
 *
 * @example
 * ```js
 * const fcData = {
 * 	methods: [
 * 		null,
 * 		[
 * 			{
 * 				methodName: "nft_token",
 * 				receiverId: "nft.examples.testnet",
 * 				args: JSON.stringify({
 * 					token_id: "1"
 * 				}),
 * 				attachedDeposit: "0"
 * 			},
 * 			{
 * 				methodName: "nft_token",
 * 				receiverId: "nft.examples.testnet",
 * 				args: JSON.stringify({
 * 					token_id: "2"
 * 				}),
 * 				attachedDeposit: "0"
 * 			}
 * 		],
 * 		null
 * 	]
 * }
 *
 * const {keys: {publicKeys, secretKeys}} = await createDrop({
 * 	numKeys: 1,
 * 	depositPerUseNEAR: 0,
 * 	fcData,
 * 	config: {
 * 		usesPerKey: 3
 * 	}
 * });
 * const secretKey = secretKeys[0];
 *
 * let curMethodData = await getCurMethodData({secretKey});
 * console.log('curMethodData (first): ', curMethodData)
 * t.is(curMethodData, null);
 *
 * 	curMethodData = await getCurMethodData({secretKey, keyUse: 1});
 *	t.is(curMethodData, null);
 *	curMethodData = await getCurMethodData({secretKey, keyUse: 2});
 *	t.true(curMethodData != null);
 *	curMethodData = await getCurMethodData({secretKey, keyUse: 3});
 *	t.is(curMethodData, null);
 *
 * await claim({secretKey, accountId: 'foobar'})
 * curMethodData = await getCurMethodData({secretKey});
 * t.true(curMethodData != null);
 *
 * await claim({secretKey, accountId: 'foobar'})
 * curMethodData = await getCurMethodData({secretKey});
 * console.log('curMethodData (third): ', curMethodData)
 * t.is(curMethodData, null);
 * ```
 * @group View Functions
 */
const getCurMethodData = ({ secretKey, publicKey, keyUse, }) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    const keyInfo = yield (0, exports.getKeyInformation)({ publicKey, secretKey });
    const dropInfo = yield (0, exports.getDropInformation)({ publicKey, secretKey });
    (0, checks_1.assert)(dropInfo.fc, 'No FC drop found');
    const methodDataArray = dropInfo.fc.methods;
    let startingIdx = methodDataArray.length > 1
        ? (((_a = dropInfo.config) === null || _a === void 0 ? void 0 : _a.uses_per_key) || 1) - keyInfo.remaining_uses
        : 0;
    if (keyUse) {
        (0, checks_1.assert)(keyUse > 0 && keyUse <= methodDataArray.length, 'Invalid key use passed in - out of bounds');
        startingIdx = keyUse - 1;
    }
    return methodDataArray[startingIdx];
});
exports.getCurMethodData = getCurMethodData;
/**
 * Check if a given user can add keys to a drop. The only case where a user *other than the funder* could add keys is if the drop has a public sale running.
 *
 * @param {string} dropId The drop ID to check if the user can add keys to
 * @param {string} accountId The account ID of the user to check if they can add keys to the drop
 *
 * @returns {Promise<boolean>} Whether or not the user can add keys to the drop
 *
 * @example
 * ```js
 * await createDrop({
 * 	numKeys: 0,
 * 	depositPerUseNEAR: 0,
 * 	config: {
 * 		sale: {
 * 			maxNumKeys: 2,
 * 			pricePerKeyNEAR: 1
 * 		}
 * 	}
 * });
 *
 * const canAddKeys = await canUserAddKeys({accountId: "foobar.testnet"});
 * t.is(canAddKeys, true);
 * ```
 *
 * @group View Functions
 */
const canUserAddKeys = ({ dropId, accountId, }) => __awaiter(void 0, void 0, void 0, function* () {
    (0, checks_1.assert)(dropId && accountId, 'Must pass in a drop ID and account ID');
    const canAddKeys = yield (0, keypom_utils_1.keypomView)({
        methodName: 'can_user_add_keys',
        args: {
            drop_id: dropId,
            account_id: accountId,
        },
    });
    return canAddKeys;
});
exports.canUserAddKeys = canUserAddKeys;
/**
 * Returns the source metadata for the Keypom contract that the SDK has been initialized on. This includes valuable information
 * such as which specific version the contract is on and link to exactly which GitHub commit is deployed.
 *
 * @returns {ContractSourceMetadata} The contract's source metadata
 *
 * @example
 * Query for the current Keypom contract's source metadata:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for the Keypom contract's source metadata
 * const metadata = await getContractSourceMetadata();
 *
 * console.log('metadata: ', metadata)
 * ```
 * @group View Functions
 */
const getContractSourceMetadata = () => __awaiter(void 0, void 0, void 0, function* () {
    return (0, keypom_utils_1.keypomView)({
        methodName: 'contract_source_metadata',
        args: {},
    });
});
exports.getContractSourceMetadata = getContractSourceMetadata;

'''
'''--- packages/core/package.json ---
{
  "name": "@keypom/core",
  "version": "1.0.2",
  "description": "Core library for interacting with the Keypom Protocol",
  "main": "lib/index.js",
  "scripts": {
    "preinstall": "npx only-allow pnpm",
    "build": "pnpm compile",
    "compile": "tsc -p tsconfig.json",
    "lint:js": "eslint -c ../../.eslintrc.js.yml src/**/*.js --no-eslintrc",
    "lint:js:fix": "eslint -c ../../.eslintrc.js.yml src/**/*.js --no-eslintrc --fix",
    "lint:ts": "eslint -c ../../.eslintrc.ts.yml src/**/*.ts --no-eslintrc",
    "lint:ts:fix": "eslint -c ../../.eslintrc.ts.yml src/**/*.ts --no-eslintrc --fix",
    
    "test": "yarn test:main && yarn test:trial-accounts && yarn test:drop-creation && yarn test:dummy-creation",
    "test:drop-creation": "yarn build && yarn ava:drop-creation",
    "test:dummy-creation": "yarn build && yarn ava:dummy-creation",
    "ava:drop-creation": "ava test/creation.test.js -vs --timeout=5m",
    "ava:dummy-creation": "ava test/dummy-creation.test.js -vs --timeout=5m",

    "build-docs": "npx typedoc --options typedoc.json"
  },
  "author": "benkurrek, mattlockyer",
  "license": "MIT",
  "dependencies": {
    "@near-wallet-selector/core": "^8.0.3",
    "bn.js": "^5.2.1",
    "borsh": "^0.7.0",
    "near-seed-phrase": "^0.2.0",
    "util": "^0.12.5"
  },
  "ava": {
    "require": [
      "dotenv/config"
    ]
  },
  "devDependencies": {
    "@near-js/accounts": "^0.1.3",
    "@near-js/crypto": "^0.0.4",
    "@near-js/keystores": "^0.0.4",
    "@near-js/keystores-browser": "^0.0.4",
    "@near-js/keystores-node": "^0.0.4",
    "@near-js/transactions": "^0.2.0",
    "@near-js/types": "^0.0.4",
    "@near-js/utils": "^0.0.4",
    "@near-js/wallet-account": "^0.0.6",
    "eslint": "^8.39.0",
    "ava": "^4.3.3",
    "typedoc": "^0.23.24",
    "typescript": "^4.8.4"
  },
  "peerDependencies": {
    "@near-js/accounts": "^0.1.3",
    "@near-js/crypto": "^0.0.4",
    "@near-js/keystores": "^0.0.4",
    "@near-js/keystores-browser": "^0.0.4",
    "@near-js/transactions": "^0.2.0",
    "@near-js/types": "^0.0.4",
    "@near-js/utils": "^0.0.4",
    "@near-js/wallet-account": "^0.0.6"
  },
  "files": [
    "lib"
  ]
}

'''
'''--- packages/core/src/index.ts ---
export { addToBalance, withdrawBalance } from "./lib/balances";
export { claim } from "./lib/claims";
export { createDrop, deleteDrops } from "./lib/drops";
export {
	/** @group Utility */
	execute, getEnv, initKeypom, networks, accountMappingContract, supportedKeypomContracts, supportedLinkdropClaimPages, updateFunder, updateKeypomContractId
} from "./lib/keypom";
export {
	viewAccessKeyData, generatePerUsePasswords, convertBasicTransaction, accountExists, createNFTSeries, estimateRequiredDeposit, formatLinkdropUrl, ftTransferCall, generateKeys, getFTMetadata, getNFTMetadata, getPubFromSecret, getStorageBase, hashPassword, nftTransferCall
} from "./lib/keypom-utils";
export { addKeys, deleteKeys } from "./lib/keys";
export * from "./lib/sales";
export {
	claimTrialAccountDrop, createTrialAccountDrop
} from "./lib/trial-accounts/pre-trial";
export {
	canExitTrial, trialCallMethod, trialSignAndSendTxns
} from "./lib/trial-accounts/trial-active";
export { wrapTxnParamsForTrial, isUnclaimedTrialDrop, TRIAL_ERRORS } from "./lib/trial-accounts/utils";
export * from "./lib/types/drops";
export * from "./lib/types/fc";
export * from "./lib/types/ft";
export * from "./lib/types/general";
export * from "./lib/types/nft";
export * from "./lib/types/params";
export * from "./lib/types/protocol";
export * from "./lib/types/simple";
export * from "./lib/views";

'''
'''--- packages/core/src/lib/balances.ts ---
import { assert, isValidAccountObj } from './checks';
import { getEnv } from './keypom';

import {
    BrowserWalletBehaviour,
    Wallet,
} from '@near-wallet-selector/core/lib/wallet/wallet.types';
//import { Account } from "near-api-js";
import { nearArgsToYocto } from './keypom-utils';
import { Account } from '@near-js/accounts';
import { Action, stringifyJsonOrBytes } from '@near-js/transactions';

type AnyWallet = BrowserWalletBehaviour | Wallet;

/**
 * Deposit some amount of $NEAR or yoctoNEAR$ into the Keypom contract. This amount can then be used to create drops or add keys without
 * Having to explicitly attach a deposit everytime. It can be thought of like a bank account.
 *
 * @example
 * Add 1 $NEAR to the account balance
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await addToBalance({
 *     amount: "1",
 * )};
 * ```
 * @group User Balance Functions
 */
export const addToBalance = async ({
    account,
    wallet,
    amountNear,
    amountYocto,
    successUrl,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /**
     * Amount of tokens to add but considering the decimal amount (non human-readable).
     * @example
     * Transferring one $NEAR should be passed in as "1000000000000000000000000" and NOT "1"
     */
    amountYocto?: string;
    /**
     * Human readable format for the amount of tokens to add.
     * @example
     * Example: transferring one $NEAR should be passed in as "1" and NOT "1000000000000000000000000"
     */
    amountNear?: string;
    /** When signing with a wallet, a success URl can be included that the user will be redirected to once the transaction has been successfully signed. */
    successUrl?: string;
}) => {
    const { receiverId, execute, getAccount } = getEnv();

    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    const deposit = nearArgsToYocto(amountNear, amountYocto);
    assert(amountYocto != '0', 'Amount to add to balance cannot be 0.');

    const actions: Action[] = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'add_to_balance',
            args: stringifyJsonOrBytes({}),
            gas: '100000000000000',
            deposit,
        },
    });

    const transactions: any[] = [
        {
            receiverId,
            actions,
        },
    ];

    return execute({ transactions, account, wallet, successUrl });
};

/**
 * Withdraw all the $NEAR from your balance in the Keypom contract.
 *
 * @example
 * Add 1 $NEAR to the account balance and then withdraw it
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await addToBalance({
 *     amount: "1",
 * });
 *
 * await withdrawBalance({});
 * ```
 * @group User Balance Functions
 */
export const withdrawBalance = async ({
    account,
    wallet,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
}) => {
    const { receiverId, execute, getAccount } = getEnv();

    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    const actions: Action[] = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'withdraw_from_balance',
            args: stringifyJsonOrBytes({}),
            gas: '100000000000000',
            deposit: '0'
        },
    });

    const transactions: any[] = [
        {
            receiverId,
            actions,
        },
    ];

    return execute({ transactions, account, wallet });
};

'''
'''--- packages/core/src/lib/checks.ts ---
//import { Account, Near } from "near-api-js";
import { Account } from '@near-js/accounts';
import { Near } from '@near-js/wallet-account';
import { getEnv, supportedKeypomContracts } from './keypom';
import { FCData } from './types/fc';
import { Funder } from './types/general';
import { ProtocolReturnedDropConfig } from './types/protocol';

export function isValidKeypomContract(keypomContractId: string) {
    const { networkId } = getEnv();
    return supportedKeypomContracts[networkId!][keypomContractId] !== undefined;
}

export function isSupportedKeypomContract(keypomContractId: string) {
    const { networkId } = getEnv();
    return supportedKeypomContracts[networkId!][keypomContractId] === true;
}

export function isValidAccountObj(o: Account | undefined): o is Account {
    if (o) {
        return (
            (o as Account).connection !== undefined &&
            (o as Account).accountId !== undefined
        );
    }

    return true;
}

export function isValidNearObject(o: Near): o is Near {
    return (
        (o as Near).connection !== undefined &&
        (o as Near).config !== undefined &&
        (o as Near).accountCreator !== undefined
    );
}

export function isValidFunderObject(o: Funder): o is Funder {
    return (
        (o as Funder).accountId !== undefined &&
        (o as Funder).secretKey !== undefined
    );
}

export const assert = (exp, m) => {
    if (!exp) {
        throw new Error(m);
    }
};

export const assertValidDropConfig = (config?: ProtocolReturnedDropConfig) => {
    assert(
        (config?.uses_per_key || 1) != 0,
        'Cannot have 0 uses per key for a drop config'
    );

    if (config?.usage?.permissions) {
        assert(
            config.usage.permissions == 'create_account_and_claim' ||
                config.usage.permissions == 'claim',
            'Invalid permission type for usage. Must be \'create_account_and_claim\' or \'claim\''
        );
    }

    if (config?.time) {
        const currentBlockTimestamp = Date.now() * 1e6;
        if(config.time.interval != undefined){
            assert(
                config.time.start != undefined,
                'If you want to set a claim interval, you must also set a start timestamp'
            );
        }
        assert(
            (config.time.start || currentBlockTimestamp) >=
                currentBlockTimestamp,
            'The start timestamp must be greater than the current block timestamp'
        );
        assert!(
            (config.time.end || currentBlockTimestamp) >= currentBlockTimestamp,
            'The end timestamp must be greater than the current block timestamp'
        );

        if (config.time.start != undefined && config.time.end != undefined) {
            assert(
                config.time.start < config.time.end,
                'The start timestamp must be less than the end timestamp'
            );
        }
    }
};

export const assertValidFCData = (
    fcData: FCData | undefined,
    usesPerKey: number
) => {
    if (fcData?.methods) {
        const numMethodData = fcData.methods.length;

        if (usesPerKey == 1) {
            assert(
                numMethodData == 1,
                'Cannot have more Method Data than the number of uses per key'
            );
        } else if (numMethodData > 1) {
            assert(
                numMethodData == usesPerKey,
                'Number of FCs must match number of uses per key if more than 1 is specified'
            );
        }

        if (usesPerKey > 1 && numMethodData == 1) {
            assert(
                fcData.methods[0] != undefined,
                'cannot have a single none function call'
            );
        }

        for (let i = 0; i < numMethodData; i++) {
            const methodsPerUse = fcData.methods[i];
            // Loop through each method in the methods per use
            if (methodsPerUse) {
                for (let j = 0; j < methodsPerUse.length; j++) {
                    const methodData = methodsPerUse[j];
                    if (methodData) {
                        assert(
                            methodData.methodName != undefined,
                            'Must specify a method name'
                        );
                        assert(
                            methodData.args != undefined,
                            'Must specify arguments for method'
                        );
                        assert(
                            typeof methodData.args == 'string',
                            'Arguments must be a string. If you want to pass a JSON object, stringify it first.'
                        );
                        assert(
                            methodData.receiverId != undefined,
                            'Must specify arguments for method'
                        );
                        assert(
                            isValidKeypomContract(methodData.receiverId) ===
                                false,
                            'Cannot have a keypom contract as the receiver'
                        );
                    }
                }
            }
        }
    }
};

export const assertDropIdUnique = async (dropId: string) => {
    const { viewCall, contractId } = getEnv();

    try {
        const dropInfo = await viewCall({
            contractId,
            methodName: 'get_drop_information',
            args: {
                drop_id: dropId,
            },
        });
        assert(
            !dropInfo,
            `Drop with ID ${dropId} already exists. Please use a different drop ID.`
        );
    } catch (e) {}
};

'''
'''--- packages/core/src/lib/claims.ts ---
import { KeyPair } from '@near-js/crypto';
import { assert } from './checks';

import { stringifyJsonOrBytes } from '@near-js/transactions';
import { getEnv, Maybe } from './keypom';
import { convertBasicTransaction } from './keypom-utils';
import { getCurMethodData, getDropInformation } from './views';

/**
 * Allows a specific Keypom drop to be claimed via the secret key.
 *
 * @example
 * Creating a simple $NEAR drop and claiming to an existing account:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // create 1 keys with no entropy (random key)
 * const {publicKeys, secretKeys} = await generateKeys({
 * 	numKeys: 1
 * });
 *
 * // Create a simple drop with 1 $NEAR
 * await createDrop({
 * 	publicKeys,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Claim the drop to the passed in account ID
 * await claim({
 * 	secretKey: secretKeys[0],
 * 	accountId: "benjiman.testnet"
 * })
 * ```
 *
 * @example
 * Creating a simple $NEAR drop and using it to create a brand new NEAR account:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // create 2 keys with no entropy (all random). The first will be used for the drop and the second
 * // will be used as the full access key for the newly created account
 * const {publicKeys, secretKeys} = await generateKeys({
 * 	numKeys: 2
 * });
 *
 * // Create a simple drop with 1 $NEAR
 * await createDrop({
 * 	publicKeys: [publicKeys[0]],
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Claim the drop and create a new account
 * await claim({
 * 	secretKey: secretKeys[0],
 * 	newAccountId: "my-newly-creating-account.testnet",
 * 	newPublicKey: publicKeys[1]
 * })
 * ```
 *
 * @example
 * Creating a drop and adding a password to it. Generate the password using the hash function and pass it into claim the drop:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 *
 * const basePassword = "my-cool-password123";
 * // Create a simple drop with 1 $NEAR and pass in a base password to create a unique password for each use of each key
 * const {keys} = await createDrop({
 * 	numKeys: 1,
 * 	depositPerUseNEAR: 1,
 * 	basePassword
 * });
 *
 * // Create the password to pass into claim which is a hash of the basePassword, public key and whichever use we are on
 * let currentUse = 1;
 * let passwordForClaim = await hashPassword(basePassword + keys.publicKeys[0] + currentUse.toString());
 *
 * // Claim the drop to the passed in account ID and use the password we generated above.
 * await claim({
 * 	secretKey: keys.secretKeys[0],
 * 	accountId: "benjiman.testnet",
 * 	password: passwordForClaim
 * })
 * ```
 * @group Creating, And Claiming Drops
 */
export const claim = async ({
    secretKey,
    accountId,
    newAccountId,
    newPublicKey,
    password,
    fcArgs,
}: {
    /** The private key associated with the Keypom link. This can either contain the `ed25519:` prefix or not. */
    secretKey: string;
    /** The account ID of an existing account that will be used to claim the drop. */
    accountId?: string;
    /** If passed in, a new account ID will be created and the drop will be claimed to that account. This must be an account that does not exist yet. */
    newAccountId?: string;
    /** If creating a new account, a public key must be passed in to be used as the full access key for the newly created account. */
    newPublicKey?: string;
    /** If a password is required to use the key, it can be passed in */
    password?: string;
    /** For FC drops, if `user_args_rule` is set by the funder, when claiming, custom arguments can be passed into the function. The number of args in the array need to match the number of methods being executed. */
    fcArgs?: Array<Maybe<string>>;
}) => {
    const {
        networkId,
        keyStore,
        contractId,
        contractAccount,
        receiverId,
        execute,
    } = getEnv();

    const keyPair = KeyPair.fromString(secretKey);
    await keyStore!.setKey(networkId!, contractId!, keyPair);

    assert(secretKey, 'A secretKey must be passed in.');
    assert(
        !newAccountId || newPublicKey,
        'If creating a new account, a newPublicKey must be passed in.'
    );

    const dropInfo = await getDropInformation({ secretKey });
    const attachedGas = dropInfo.required_gas;

    let curMethodData;
    if (dropInfo.fc) {
        curMethodData = await getCurMethodData({ secretKey });
        if (curMethodData == null) {
            accountId = 'none';
        }
    }

    if (fcArgs) {
        assert(dropInfo.fc, 'Cannot pass in fcArgs for non-FC drops.');
        assert(
            (curMethodData || []).length === fcArgs.length,
            'The number of fcArgs must match the number of methods being executed.'
        );
    }

    assert(
        newAccountId || accountId,
        'Either an accountId or newAccountId must be passed in.'
    );

    const fcAction = newAccountId
        ? {
            methodName: 'create_account_and_claim',
            args: stringifyJsonOrBytes({
                new_account_id: newAccountId,
                new_public_key: newPublicKey,
                password,
                fc_args: fcArgs,
            }),
            gas: attachedGas,
            deposit: '0',
        }
        : {
            methodName: 'claim',
            args: stringifyJsonOrBytes({
                account_id: accountId,
                password,
                fc_args: fcArgs,
            }),
            gas: attachedGas,
            deposit: '0',
        };

    const txn = await convertBasicTransaction({
        txnInfo: {
            receiverId,
            signerId: contractId,
            actions: [
                {
                    enum: 'FunctionCall',
                    functionCall: fcAction,
                },
            ],
        },
        signerId: contractId,
        signerPk: keyPair.getPublicKey(),
    });

    const result = await execute({
        transactions: [txn],
        account: contractAccount,
    });

    return result;
};

'''
'''--- packages/core/src/lib/drops.ts ---
import BN from 'bn.js';
//import * as nearAPI from "near-api-js";

import { FinalExecutionOutcome } from '@near-wallet-selector/core';
import {
    BrowserWalletBehaviour,
    Wallet
} from '@near-wallet-selector/core/lib/wallet/wallet.types';
//import { Account } from "near-api-js";
import { Account } from '@near-js/accounts';
import { Transaction, stringifyJsonOrBytes } from '@near-js/transactions';
import { parseNearAmount } from '@near-js/utils';
import {
    assert,
    assertDropIdUnique,
    assertValidDropConfig,
    assertValidFCData,
    isSupportedKeypomContract,
    isValidAccountObj
} from './checks';
import { getEnv } from './keypom';
import {
    convertBasicTransaction,
    estimateRequiredDeposit,
    ftTransferCall,
    generateKeys,
    generatePerUsePasswords,
    getStorageBase,
    key2str,
    keypomView,
    nearArgsToYocto,
    nftTransferCall,
    parseFTAmount
} from './keypom-utils';
import { DropConfig } from './types/drops';
import { FCData } from './types/fc';
import { FTData } from './types/ft';
import { BasicTransaction } from './types/general';
import { NFTData } from './types/nft';
import { CreateDropProtocolArgs, CreateOrAddReturn } from './types/params';
import {
    ProtocolReturnedDrop,
    ProtocolReturnedDropConfig,
    ProtocolReturnedMethod
} from './types/protocol';
import { SimpleData } from './types/simple';
import { getDropInformation, getUserBalance } from './views';

type AnyWallet = BrowserWalletBehaviour | Wallet;
export const KEY_LIMIT = 50;

/**
 * Creates a new drop based on parameters passed in. This drop can have keys that are manually generated and passed in, or automatically generated. If they're
 * automatically generated, they can be based off a set of entropy. For NFT and FT drops, assets can automatically be sent to Keypom to register keys as part of the payload.
 * The deposit is estimated based on parameters that are passed in and the transaction can be returned instead of signed and sent to the network. This can allow you to get the
 * required deposit from the return value and use that to fund the account's Keypom balance to avoid multiple transactions being signed in the case of a drop with many keys.
 *
 * @return {Promise<CreateOrAddReturn>} Object containing: the drop ID, the responses of the execution, as well as any auto generated keys (if any).
 *
 * @example
 * Create a basic simple drop containing 10 keys each with 1 $NEAR. Each key is completely random:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create a drop with 10 completely random keys. The return value `keys` contains information about the generated keys
 * const {keys} = await createDrop({
 * 	numKeys: 10,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * console.log('public keys: ', keys.publicKeys);
 * console.log('private keys: ', keys.secretKeys);
 * ```
 *
 * @example
 * Init funder with root entropy and generate deterministic keys for a drop. Compare with manually generated keys:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. Root entropy is passed into the funder account so any generated keys
 * // Will be based off that entropy.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1",
 * 		rootEntropy: "my-global-secret-password"
 * 	}
 * });
 *
 * // Create a simple drop with 5 keys. Each key will be derived based on the rootEntropy of the funder, the drop ID, and key nonce.
 * const { keys: keysFromDrop, dropId } = await createDrop({
 * 	numKeys: 5,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Deterministically Generate the Private Keys:
 * const nonceDropIdMeta = Array.from({length: 5}, (_, i) => `${dropId}_${i}`);
 * const manualKeys = await generateKeys({
 * 	numKeys: 5,
 * 	rootEntropy: "my-global-secret-password",
 * 	metaEntropy: nonceDropIdMeta
 * })
 *
 * // Get the public and private keys from the keys generated by the drop
 * const {publicKeys, secretKeys} = keysFromDrop;
 * // Get the public and private keys from the keys that were manually generated
 * const {publicKeys: pubKeysGenerated, secretKeys: secretKeysGenerated} = manualKeys;
 * // These should match!
 * console.log('secretKeys: ', secretKeys)
 * console.log('secretKeysGenerated: ', secretKeysGenerated)
 *
 * // These should match!
 * console.log('publicKeys: ', publicKeys)
 * console.log('pubKeysGenerated: ', pubKeysGenerated)
 * ```
 *
 * @example
 * Use manually generated keys to create a drop:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Generate 10 random keys
 * const {publicKeys} = await generateKeys({
 * 	numKeys: 10
 * });
 *
 * // Create a drop using the keys that were generated. Since keys are passed in, the return value won't contain information about the keys.
 * await createDrop({
 * 	publicKeys,
 * 	depositPerUseNEAR: 1,
 * });
 * ```
 *
 * @example
 * Create a simple drop with 1 key and 1 use per key. This 1 use-key should be password protected based on a base-password:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 *
 * const basePassword = "my-cool-password123";
 * // Create a simple drop with 1 $NEAR and pass in a base password to create a unique password for each use of each key
 * const {keys} = await createDrop({
 * 	numKeys: 1,
 * 	depositPerUseNEAR: 1,
 * 	basePassword
 * });
 *
 * // Create the password to pass into claim which is a hash of the basePassword, public key and whichever use we are on
 * let currentUse = 1;
 * let passwordForClaim = await hashPassword(basePassword + keys.publicKeys[0] + currentUse.toString());
 * ```
 * @group Creating, And Claiming Drops
 */
export const createDrop = async ({
    account,
    wallet,
    dropId,
    numKeys = 0,
    publicKeys,
    rootEntropy,
    depositPerUseNEAR,
    depositPerUseYocto,
    metadata,
    requiredGas,
    config = {},
    ftData,
    nftData,
    simpleData = {},
    fcData,
    basePassword,
    passwordProtectedUses,
    useBalance = false,
    returnTransactions = false,
    successUrl,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /**
     * Specify how many keys should be generated for the drop. If the funder has rootEntropy set OR rootEntropy is passed in, the keys will be
     * deterministically generated using the drop ID, key nonce, and entropy. Otherwise, each key will be generated randomly.
     * If this is not passed in, the publicKeys parameter *must* be passed in.
     */
    numKeys?: number;
    /** Pass in a custom set of publicKeys to add to the drop. If this is not passed in, keys will be generated based on the numKeys parameter. */
    publicKeys?: string[];
    /** How much $NEAR should be contained in each link. Unit in $NEAR (i.e `1` = 1 $NEAR) */
    depositPerUseNEAR?: number | string;
    /** How much $yoctoNEAR should be contained in each link. Unit in yoctoNEAR (1 yoctoNEAR = 1e-24 $NEAR) */
    depositPerUseYocto?: string;
    /** Specify a custom drop ID rather than using the incrementing nonce on the contract. */
    dropId?: string;
    /** Allows specific drop behaviors to be configured such as the number of uses each key / link will have. */
    config?: DropConfig;
    /** String of metadata to attach to the drop. This can be whatever you would like and is optional. Often this is stringified JSON. */
    metadata?: string;
    /** Allows you to overload how much gas should be attached to the transaction when the key is claimed. This should be in Gas units (1 TGas = 1000000000000). By default, 100 TGas is attached. */
    requiredGas?: string;
    /** For creating a simple drop, this contains necessary configurable information about the drop. */
    simpleData?: SimpleData;
    /** For creating a fungible token drop, this contains necessary configurable information about the drop. */
    ftData?: FTData;
    /** For creating a non-fungible token drop, this contains necessary configurable information about the drop. */
    nftData?: NFTData;
    /** For creating a function call drop, this contains necessary configurable information about the drop. */
    fcData?: FCData;
    /** Specify an entropy to use for generating keys (will overload the funder's rootEntropy if applicable). This parameter only matters if the publicKeys variable is not passed in. */
    rootEntropy?: string;
    /** For doing password protected drops, this is the base password that will be used to generate all the passwords. It will be double hashed with the public keys. If specified, by default, all key uses will have their own unique password unless passwordProtectedUses is passed in. */
    basePassword?: string;
    /** For doing password protected drops, specifies exactly which uses will be password protected. The uses are NOT zero indexed (i.e 1st use = 1). Each use will have a different, unique password generated via double hashing the base password + public key + key use. */
    passwordProtectedUses?: number[];
    /** If the account has a balance within the Keypom contract, set this to true to avoid the need to attach a deposit. If the account doesn't have enough balance, an error will throw. */
    useBalance?: boolean;
    /** If true, the transaction will be returned instead of being signed and sent. This is useful for getting the requiredDeposit from the return value without actually signing the transaction. */
    returnTransactions?: boolean;
    /** When signing with a wallet, a success URl can be included that the user will be redirected to once the transaction has been successfully signed. */
    successUrl?: string;
}): Promise<CreateOrAddReturn> => {
    const {
        near,
        viewCall,
        gas,
        attachedGas,
        contractId,
        receiverId,
        getAccount,
        execute,
        fundingAccountDetails,
    } = getEnv();

    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });
    assert(
        isSupportedKeypomContract(contractId!) === true,
        'Only the latest Keypom contract can be used to call this methods. Please update the contract.'
    );
    assert(
        publicKeys != undefined || numKeys != undefined,
        'Must pass in either publicKeys or numKeys to create a drop.'
    );

    /// parse args
    depositPerUseYocto = nearArgsToYocto(depositPerUseNEAR, depositPerUseYocto);

    // Ensure that if the dropID is passed in, it's greater than 1 billion
    assert(
        parseInt(dropId || '1000000000') >= 1000000000,
        'All custom drop IDs must be greater than 1_000_000_000'
    );
    if (!dropId) dropId = Date.now().toString();

    await assertDropIdUnique(dropId);

    const finalConfig: ProtocolReturnedDropConfig = {
        uses_per_key: config?.usesPerKey || 1,
        time: config?.time,
        usage: {
            auto_delete_drop: config?.usage?.autoDeleteDrop || false,
            auto_withdraw: (config?.usage?.autoWithdraw === true) || false,
            permissions: config?.usage?.permissions,
            refund_deposit: config?.usage?.refundDeposit,
            account_creation_fields: {
                account_id_field:
                    config?.usage?.accountCreationFields?.accountIdField,
                drop_id_field:
                    config?.usage?.accountCreationFields?.dropIdField,
                key_id_field: config?.usage?.accountCreationFields?.keyIdField,
                funder_id_field:
                    config?.usage?.accountCreationFields?.funderIdField,
            },
        },
        sale: config?.sale
            ? {
                max_num_keys: config?.sale?.maxNumKeys,
                price_per_key:
                      config?.sale?.pricePerKeyYocto ||
                      config?.sale?.pricePerKeyNEAR
                          ? parseNearAmount(
                              config?.sale?.pricePerKeyNEAR?.toString()
                          )!
                          : undefined,
                allowlist: config?.sale?.allowlist,
                blocklist: config?.sale?.blocklist,
                auto_withdraw_funds: config?.sale?.autoWithdrawFunds,
                start: config?.sale?.start,
                end: config?.sale?.end,
            }
            : undefined,
        root_account_id: config?.dropRoot,
    };

    assertValidDropConfig(finalConfig);

    // If there are no publicKeys being passed in, we should generate our own based on the number of keys
    let keys;
    if (!publicKeys) {
        // Default root entropy is what is passed in. If there wasn't any, we should check if the funding account contains some.
        const rootEntropyUsed =
        rootEntropy || fundingAccountDetails?.rootEntropy;
        // If either root entropy was passed into the function or the funder has some set, we should use that.
        if (rootEntropyUsed) {
            // Create an array of size numKeys with increasing strings from 0 -> numKeys - 1. Each element should also contain the dropId infront of the string
            const nonceDropIdMeta = Array.from(
                { length: numKeys },
                (_, i) => `${dropId}_${i}`
            );
            keys = await generateKeys({
                numKeys,
                rootEntropy: rootEntropyUsed,
                metaEntropy: nonceDropIdMeta,
            });
        } else {
            // No entropy is provided so all keys should be fully random
            keys = await generateKeys({
                numKeys,
            });
        }

        publicKeys = keys.publicKeys;
    }

    numKeys = publicKeys!.length;
    assert(numKeys <= 100, 'Cannot add more than 100 keys at once');
    let passwords;
    if (basePassword) {
        assert(numKeys <= 50, 'Cannot add more than 50 keys at once with passwords');

        // Generate the passwords with the base password and public keys. By default, each key will have a unique password for all of its uses unless passwordProtectedUses is passed in
        passwords = await generatePerUsePasswords({
            publicKeys: publicKeys!,
            basePassword,
            uses:
                passwordProtectedUses ||
                Array.from(
                    { length: config?.usesPerKey || 1 },
                    (_, i) => i + 1
                ),
        });
    }

    let ftBalancePerUse;
    if (ftData) {
        ftBalancePerUse = ftData?.absoluteAmount || '0';

        if (ftData.amount) {
            const metadata = viewCall({
                contractId: ftData.contractId,
                methodName: 'ft_metadata',
            });
            ftBalancePerUse = parseFTAmount(
                ftData.amount.toString(),
                metadata.decimals
            );
        }
    }

    assertValidFCData(
        fcData,
        finalConfig.uses_per_key || 1
    );

    const createDropArgs: CreateDropProtocolArgs = {
        drop_id: dropId,
        public_keys: publicKeys || [],
        deposit_per_use: depositPerUseYocto,
        config: finalConfig,
        metadata,
        required_gas: requiredGas,
        ft: ftData?.contractId
            ? {
                contract_id: ftData.contractId,
                sender_id: ftData.senderId,
                balance_per_use: ftBalancePerUse!,
            }
            : undefined,
        nft: nftData?.contractId
            ? {
                contract_id: nftData.contractId,
                sender_id: nftData.senderId,
            }
            : undefined,
        fc: fcData?.methods
            ? {
                methods: fcData.methods.map((useMethods) =>
                    useMethods
                        ? useMethods.map((method) => {
                            const ret: ProtocolReturnedMethod = {
                                receiver_id: method.receiverId,
                                method_name: method.methodName,
                                args: method.args,
                                attached_deposit: method.attachedDeposit,
                                attached_gas: method.attachedGas,
                                account_id_field: method.accountIdField,
                                drop_id_field: method.dropIdField,
                                key_id_field: method.keyIdField,
                                funder_id_field: method.funderIdField,
                                receiver_to_claimer:
                                        method.receiverToClaimer,
                                user_args_rule: method.userArgsRule,
                            };
                            return ret;
                        })
                        : undefined
                ),
            }
            : undefined,
        simple: simpleData?.lazyRegister
            ? {
                lazy_register: simpleData.lazyRegister,
            }
            : undefined,
        passwords_per_use: passwords,
    };

    // If there is no ft data, nft data, or fc data, ensure the deposit per use is greater than 0
    if (
        createDropArgs.fc === undefined &&
        createDropArgs.ft === undefined &&
        createDropArgs.nft === undefined
    ) {
        assert(
            depositPerUseYocto != '0',
            'Deposit per use must be greater than 0 for simple drops'
        );
    }

    /// estimate required deposit
    const storageCalculated = getStorageBase(createDropArgs);
    const requiredDeposit = await estimateRequiredDeposit({
        near: near!,
        depositPerUse: depositPerUseYocto,
        numKeys,
        usesPerKey: finalConfig.uses_per_key || 1,
        attachedGas: parseInt(requiredGas || attachedGas!),
        storage: storageCalculated,
        ftData,
        fcData,
    });

    let hasBalance = false;
    if (useBalance) {
        const userBal = new BN(
            await getUserBalance({ accountId: account!.accountId })
        );
        if (userBal.lt(new BN(requiredDeposit))) {
            throw new Error(
                'Insufficient balance on Keypom to create drop. Use attached deposit instead.'
            );
        }

        hasBalance = true;
    }

    const deposit = !hasBalance ? requiredDeposit : '0';

    let transactions: Transaction[] = [];
    const pk = await account.connection.signer.getPublicKey(
        account.accountId,
        account.connection.networkId
    );

    assert(pk !== null, 'Could not get public key from signer. Ensure you have the key in the key store.')
        
    const txnInfo: BasicTransaction = {
        receiverId: receiverId!,
        signerId: account!.accountId, // We know this is not undefined since getAccount throws
        actions: [
            {
                enum: 'FunctionCall',
                functionCall: {
                    methodName: 'create_drop',
                    args: stringifyJsonOrBytes(createDropArgs),
                    gas: gas!,
                    deposit,
                }
            },
        ],
    };

    transactions.push(await convertBasicTransaction({txnInfo, signerId: account!.accountId, signerPk: pk}));

    if (ftData?.contractId && publicKeys?.length) {
        transactions.push(
            (await ftTransferCall({
                account: account!,
                contractId: ftData.contractId,
                absoluteAmount: new BN(ftBalancePerUse!)
                    .mul(new BN(numKeys))
                    .mul(new BN(finalConfig.uses_per_key))
                    .toString(),
                dropId,
                returnTransaction: true,
            })) as Transaction
        );
    }

    const tokenIds = nftData?.tokenIds;
    if (nftData && tokenIds && tokenIds?.length > 0) {
        if (tokenIds.length > 2) {
            throw new Error(
                'You can only automatically register 2 NFTs with \'createDrop\'. If you need to register more NFTs you can use the method \'nftTransferCall\' after you create the drop.'
            );
        }
        const nftTXs = (await nftTransferCall({
            account: account!,
            contractId: nftData.contractId as string,
            tokenIds,
            dropId: dropId.toString(),
            returnTransactions: true,
        })) as Transaction[];
        transactions = transactions.concat(nftTXs);
    }

    if (returnTransactions) {
        return { keys, dropId, transactions, requiredDeposit };
    }

    const responses = await execute({
        transactions,
        account,
        wallet,
        successUrl,
    });

    return { responses, keys, dropId, requiredDeposit };
};

/**
 * Delete a set of drops and optionally withdraw any remaining balance you have on the Keypom contract.
 *
 * @example
 * Create 5 drops and delete each of them:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // loop to create 5 simple drops each with 5 more keys than the next
 * for(var i = 0; i < 5; i++) {
 * 	// create 10 keys with no entropy (all random)
 * 	const {publicKeys} = await generateKeys({
 * 		numKeys: 5 * (i+1) // First drop will have 5, then 10, then 15 etc..
 * 	});
 *
 * 	// Create the simple
 * 	await createDrop({
 * 		publicKeys,
 * 		depositPerUseNEAR: 1,
 * 	});
 * }
 *
 * let drops = await getDrops({accountId: "benji_demo.testnet"});
 * console.log('drops: ', drops)
 *
 * await deleteDrops({
 * 	drops
 * })
 *
 * 	// Get the number of drops the account has after deletion (should be zero)
 * 	const numDrops = await getDropSupply({
 * 		accountId: "benjiman.testnet"
 * });
 * console.log('numDrops: ', numDrops)
 * ```
 * @group Deleting State
 */
export const deleteDrops = async ({
    account,
    wallet,
    drops,
    dropIds,
    withdrawBalance = true,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** If the set of drop information for the drops you want to delete (from `getDropInformation` or `getDrops`) is already known to the client, it can be passed in instead of the drop IDs to reduce computation. */
    drops?: ProtocolReturnedDrop[];
    /** Specify a set of drop IDs to delete. */
    dropIds?: string[];
    /** Whether or not to withdraw any remaining balance on the Keypom contract. */
    withdrawBalance?: boolean;
}) => {
    const { gas300, receiverId, execute, getAccount, contractId } =
        getEnv();

    assert(
        isSupportedKeypomContract(contractId!) === true,
        'Only the latest Keypom contract can be used to call this methods. Please update the contract.'
    );

    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });
    const pubKey = await account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);

    // If the drop information isn't passed in, we should get it from the drop IDs
    if (!drops) {
        if (!dropIds) {
            throw new Error('Must pass in either drops or dropIds');
        }

        // For each drop ID in drop IDs, get the drop information
        drops = [];
        await Promise.all(
            await dropIds.map(async (dropId) => {
                drops?.push(await getDropInformation({ dropId }));
            })
        );
    }

    const responses = await Promise.all(
        drops!.map(async ({ owner_id, drop_id, registered_uses, ft, nft }) => {
            assert(
                owner_id == account!.accountId,
                'Only the owner of the drop can delete drops.'
            );

            let keySupply;
            let keys;

            const updateKeys = async () => {
                const keyPromises = [
                    (async () => {
                        keySupply = await keypomView({
                            methodName: 'get_key_supply_for_drop',
                            args: {
                                drop_id: drop_id.toString(),
                            },
                        });
                    })(),
                ];

                keyPromises.push(
                    (async () => {
                        keys = await keypomView({
                            methodName: 'get_keys_for_drop',
                            args: {
                                drop_id: drop_id.toString(),
                                from_index: '0',
                                limit: KEY_LIMIT,
                            },
                        });
                    })()
                );

                await Promise.all(keyPromises);
            };
            await updateKeys();

            const responses: Array<void | FinalExecutionOutcome[]> = [];

            if (
                registered_uses !== 0 &&
                (ft !== undefined || nft !== undefined)
            ) {
                const txn = await convertBasicTransaction({
                    txnInfo: {
                        receiverId,
                        signerId: account!.accountId,
                        actions: [
                            {
                                enum: 'FunctionCall',
                                functionCall: {
                                    methodName: 'refund_assets',
                                    args: stringifyJsonOrBytes({
                                        drop_id,
                                    }),
                                    gas: gas300,
                                    deposit: '0'
                                },
                            },
                        ],
                    },
                    signerId: account!.accountId,
                    signerPk: pubKey
                });

                responses.push(
                    ...(await execute({
                        account,
                        wallet,
                        transactions: [txn],
                    }))
                );
            }

            const deleteKeys = async () => {
                const txn = await convertBasicTransaction({
                    txnInfo: {
                        receiverId,
                        signerId: account!.accountId,
                        actions: [
                            {
                                enum: 'FunctionCall',
                                functionCall: {
                                    methodName: 'delete_keys',
                                    args: stringifyJsonOrBytes({
                                        drop_id,
                                        public_keys: keys!.map(key2str),
                                    }),
                                    gas: gas300,
                                    deposit: '0'
                                },
                            },
                        ],
                    },
                    signerId: account!.accountId,
                    signerPk: pubKey
                });

                responses.push(
                    ...(await execute({
                        account,
                        wallet,
                        transactions: [txn],
                    }))
                );

                if (keySupply > (keys?.length || 0)) {
                    await updateKeys();
                    await deleteKeys();
                }
            };
            await deleteKeys();

            if (withdrawBalance) {
                const txn = await convertBasicTransaction({
                    txnInfo: {
                        receiverId,
                        signerId: account!.accountId,
                        actions: [
                            {
                                enum: 'FunctionCall',
                                functionCall: {
                                    methodName: 'withdraw_from_balance',
                                    args: stringifyJsonOrBytes({}),
                                    gas: '50000000000000',
                                    deposit: '0'
                                },
                            },
                        ],
                    },
                    signerId: account!.accountId,
                    signerPk: pubKey
                });

                responses.push(
                    ...(await execute({
                        account,
                        wallet,
                        transactions: [txn],
                    }))
                );
            }

            return responses;
        })
    );

    return responses;
};

// This should be done later. Very small number of drops will have lazy registrations enabled.
// /**
//  * Allows a user to register uses for a simple drop that has lazy registrations enabled. This drop can be over-registered.
//  *
//  * @param {Account=} account (OPTIONAL) If specified, the passed in account will be used to sign the txn instead of the funder account.
//  * @param {BrowserWalletBehaviour=} wallet (OPTIONAL) If using a browser wallet through wallet selector and that wallet should sign the transaction, pass it in.
//  * @param {string[]=} dropId Specify the drop ID of the drop you want to register uses on
//  *
//  * @example <caption>Create 5 drops and delete each of them</caption>
//  * ```js
//  * ```
// */
// export const registerUses = async ({
// 	account,
// 	wallet,
// 	dropId,
// 	numUses,
// 	useBalance = false,
// }: RegisterUsesParams) => {
// 	const {
// 		gas300, receiverId, execute, getAccount
// 	} = getEnv()

// 	account = await getAccount({ account, wallet });
// }

'''
'''--- packages/core/src/lib/keypom-utils.ts ---
import {
    BrowserWalletBehaviour,
    Wallet
} from '@near-wallet-selector/core/lib/wallet/wallet.types';
import BN from 'bn.js';
import { generateSeedPhrase } from 'near-seed-phrase';
import { assert, isValidAccountObj } from './checks';
import { getEnv, supportedLinkdropClaimPages } from './keypom';
import { PasswordPerUse } from './types/drops';
import { FCData } from './types/fc';
import { FTData, FungibleTokenMetadata } from './types/ft';
import { BasicTransaction, GeneratedKeyPairs, NearKeyPair } from './types/general';
import {
    NonFungibleTokenMetadata,
    ProtocolReturnedNonFungibleTokenMetadata,
    ProtocolReturnedNonFungibleTokenObject
} from './types/nft';
import { CreateDropProtocolArgs } from './types/params';
import { KeyPair, KeyPairEd25519, PublicKey } from '@near-js/crypto';
import { Account, SignAndSendTransactionOptions } from '@near-js/accounts';
import { parseNearAmount } from '@near-js/utils';
import { Near } from '@near-js/wallet-account';
import { FinalExecutionOutcome } from '@near-js/types';
import { actionCreators, Action, Transaction, stringifyJsonOrBytes, createTransaction } from '@near-js/transactions';
import { baseDecode } from 'borsh';
import { TextDecoder } from 'util';

type AnyWallet = BrowserWalletBehaviour | Wallet;

let sha256Hash;
// @ts-ignore
if (typeof crypto === 'undefined') {
    const nodeCrypto = require('crypto');
    sha256Hash = (ab) => nodeCrypto.createHash('sha256').update(ab).digest();
} else {
    // @ts-ignore
    sha256Hash = (ab) => crypto.subtle.digest('SHA-256', ab);
}

/// How much Gas each each cross contract call with cost to be converted to a receipt
const GAS_PER_CCC = 5000000000000; // 5 TGas
const RECEIPT_GAS_COST = 2500000000000; // 2.5 TGas
const YOCTO_PER_GAS = 100000000; // 100 million
export const ATTACHED_GAS_FROM_WALLET = 100000000000000; // 100 TGas

/// How much yoctoNEAR it costs to store 1 access key
const ACCESS_KEY_STORAGE: BN = new BN('1000000000000000000000');

export const key2str = (v) => (typeof v === 'string' ? v : v.pk);

const hashBuf = (str: string, fromHex = false): Promise<ArrayBuffer> =>
    sha256Hash(Buffer.from(str, fromHex ? 'hex' : 'utf8'));

/**
 * Get the public key from a given secret key.
 *
 * @param {string} secretKey - The secret key you wish to get the public key from
 *
 * @returns {Promise<string>} - The public key
 *
 * @example
 * ```js
 * const pubKey = getPubFromSecret("ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1");
 * console.log(pubKey);
 * ```
 * @group Utility
 */
export const getPubFromSecret = (secretKey: string): string => {
    const keyPair = KeyPair.fromString(secretKey);
    return keyPair.getPublicKey().toString();
};

/**
 * Check whether or not a given account ID exists on the network.
 *
 * @param {string} accountId - The account ID you wish to check
 *
 * @returns {Promise<boolean>} - A boolean indicating whether or not the account exists
 *
 * @example
 * ```js
 * const accountExists = await accountExists("benji.near");
 * console.log(accountExists); // true
 * ```
 * @group Utility
 */
export const accountExists = async (accountId): Promise<boolean> => {
    const { connection } = getEnv();

    try {
        const account = new Account(connection!, accountId);
        await account.state();
        return true;
    } catch (e) {
        if (!/no such file|does not exist/.test((e as any).toString())) {
            throw e;
        }
        return false;
    }
};

/**
 * Get the NFT Object (metadata, owner, approval IDs etc.) for a given token ID on a given contract.
 *
 * @param {string} contractId - The contract ID of the NFT contract
 * @param {string} tokenId - The token ID of the NFT you wish to get the metadata for
 *
 * @returns {Promise<ProtocolReturnedNonFungibleTokenObject>} - The NFT Object
 *
 * @example
 * ```js
 * const nft = await getNFTMetadata({
 *     contractId: "nft.keypom.testnet",
 *     tokenId: "1"
 * });
 * console.log(nft);
 * ```
 * @group Utility
 */
export const getNFTMetadata = async ({
    contractId,
    tokenId,
}: {
    contractId: string;
    tokenId: string;
}): Promise<ProtocolReturnedNonFungibleTokenObject> => {
    const { viewCall } = getEnv();

    const res: ProtocolReturnedNonFungibleTokenObject = await viewCall({
        contractId,
        methodName: 'nft_token',
        args: {
            token_id: tokenId,
        },
    });

    return res;
};

/**
 * Get the FT Metadata for a given fungible token contract. This is used to display important information such as the icon for the token, decimal format etc.
 *
 * @param {string} contractId - The contract ID of the FT contract
 *
 * @returns {Promise<FungibleTokenMetadata>} - The FT Metadata
 *
 * @example
 * ```js
 * const ft = await getFTMetadata({
 *    contractId: "ft.keypom.testnet"
 * });
 * console.log(ft);
 * ```
 * @group Utility
 */
export const getFTMetadata = async ({
    contractId,
}: {
    contractId: string;
}): Promise<FungibleTokenMetadata> => {
    const { viewCall } = getEnv();

    const res: FungibleTokenMetadata = await viewCall({
        contractId,
        methodName: 'ft_metadata',
        args: {},
    });

    return res;
};

/**
 * Creates a new NFT series on the official Keypom Series contracts. This is for lazy minting NFTs as part of an FC drop.
 *
 * @example
 * Send 3 NFTs using the funder account (not passing in any accounts into the call):
 * ```js
 *	await initKeypom({
 *		// near,
 *		network: 'testnet',
 *		funder: {
 *			accountId,
 *			secretKey,
 *		}
 *	})
 *
 *	const {keys, dropId} = await createDrop({
 *		numKeys: 1,
 *		config: {
 *			usesPerKey: 100
 *		},
 *		metadata: "My Cool Drop Title!",
 *		depositPerUseNEAR: 0.5,
 *		fcData: {
 *			methods: [[
 *				{
 *					receiverId: `nft-v2.keypom.testnet`,
 *					methodName: "nft_mint",
 *					args: "",
 *					dropIdField: "mint_id",
 *					accountIdField: "receiver_id",
 *					attachedDeposit: parseNearAmount("0.1")
 *				}
 *			]]
 *		}
 *	})
 *
 *	const res = await createNFTSeries({
 *		dropId,
 *		metadata: {
 *			title: "Moon NFT!",
 *			description: "A cool NFT for the best dog in the world.",
 *			media: "bafybeibwhlfvlytmttpcofahkukuzh24ckcamklia3vimzd4vkgnydy7nq",
 *			copies: 500
 *		}
 *	});
 *	console.log('res: ', res)
 *
 *	const URLs = formatLinkdropUrl({
 *		baseUrl: "localhost:3000/claim",
 *		secretKeys: keys.secretKeys
 *	})
 *	console.log('URLs: ', URLs)
 * ```
 * @group Utility
 */
export const createNFTSeries = async ({
    account,
    wallet,
    dropId,
    metadata,
    royalty,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop that should have a series associated with it. */
    dropId: string;
    /** The metadata that all minted NFTs will have. */
    metadata: NonFungibleTokenMetadata;
    /** Any royalties associated with the series (as per official NEP-199 standard: https://github.com/near/NEPs/blob/master/neps/nep-0199.md) */
    royalty?: Map<string, number>;
}): Promise<void | FinalExecutionOutcome[]> => {
    const { getAccount, networkId } = getEnv();
    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    const actualMetadata: ProtocolReturnedNonFungibleTokenMetadata = {
        title: metadata.title,
        description: metadata.description,
        media: metadata.media,
        media_hash: metadata.mediaHash,
        copies: metadata.copies,
        issued_at: metadata.issuedAt,
        expires_at: metadata.expiresAt,
        starts_at: metadata.startsAt,
        updated_at: metadata.updatedAt,
        extra: metadata.extra,
        reference: metadata.reference,
        reference_hash: metadata.referenceHash,
    };

    const nftSeriesAccount =
        networkId == 'testnet' ? 'nft-v2.keypom.testnet' : 'nft-v2.keypom.near';

    const pk = await account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
    const txnInfo: BasicTransaction = {
        receiverId: nftSeriesAccount,
        signerId: account!.accountId, // We know this is not undefined since getAccount throws
        actions: [
            {
                enum: 'FunctionCall',
                functionCall: {
                    methodName: 'create_series',
                    args: stringifyJsonOrBytes({
                        mint_id: parseInt(dropId),
                        metadata: actualMetadata,
                        royalty,
                    }),
                    gas: '50000000000000',
                    deposit: parseNearAmount('0.25')!,
                }
            },
        ],
    };

    const transaction = await convertBasicTransaction({txnInfo, signerId: account!.accountId, signerPk: pk});

    return execute({ account: account!, transactions: [transaction] }) as Promise<
        void | FinalExecutionOutcome[]
    >;
};

/**
 * Constructs a valid linkdrop URL for a given claim page or custom URL. To view the list of supported claim pages, see the exported `supportedLinkdropClaimPages` variable.
 *
 * @param {string | string[]} secretKeys - Either a single secret key or an array of secret keys that should be embedded in the linkdrop URLs.
 * @param {string=} claimPage - A valid reference to the claim page. See the exported `supportedLinkdropClaimPages` variable for a list of supported claim pages. If not provided, a custom base URL must be provided.
 * @param {string=} networkId - The network ID you wish to linkdrop on. If not provided, the current network that the SDK is connected to will be used.
 * @param {string=} contractId - The contract ID where the secret key belongs to. If not provided, the current contract ID that the SDK is connected to will be used.
 * @param {string=} customURL - A custom URL containing a `SECRET_KEY` string and `CONTRACT_ID` string for where to insert the secret key and contract ID. For example, a base URL of `foo.com/CONTRACT_ID#SECRET_KEY` with a contract `v2.keypom.near` and secret key `5CBLiJK21EQoB...` would result in `foo.com/v2.keypom.near#5CBLiJK21EQoB...`.
 *
 * @returns {string[]} - An array of the linkdrop URLs
 *
 * @example
 * Use the keypom claim page:
 * ```js
 * await initKeypom({
 *     network: 'testnet',
 *     funder: {
 *         accountId,
 *         secretKey,
 *     }
 * })
 *
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * const linkdropUrl = formatLinkdropUrl({
 *     claimPage: "keypom",
 *     contractId: "v2.keypom.testnet",
 *     secretKeys: keys.secretKeys[0] // Can be either the array or individual secret key string
 * })
 *
 * console.log('linkdropUrl: ', linkdropUrl)
 * ```
 * @example
 * Use a custom claim page with ONLY the secret key
 * ```js
 * await initKeypom({
 *     network: 'testnet',
 *     funder: {
 *         accountId,
 *         secretKey,
 *     }
 * })
 *
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * const linkdropUrl = formatLinkdropUrl({
 *     customURL: "foobar/SECRET_KEY/barfoo",
 *     contractId: "v2.keypom.testnet",
 *     secretKeys: keys.secretKeys[0] // Can be either the array or individual secret key string
 * })
 *
 * console.log('linkdropUrl: ', linkdropUrl)
 * ```
 * @example
 * Use a custom claim page with both the secret key and contract ID
 * ```js
 * await initKeypom({
 *     network: 'testnet',
 *     funder: {
 *         accountId,
 *         secretKey,
 *     }
 * })
 *
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * const linkdropUrl = formatLinkdropUrl({
 *     customURL: "foobar/SECRET_KEY/barfoo/CONTRACT_ID",
 *     contractId: "v2.keypom.testnet",
 *     secretKeys: keys.secretKeys[0] // Can be either the array or individual secret key string
 * })
 *
 * console.log('linkdropUrl: ', linkdropUrl)
 * ```
 * @group Utility
 */
export const formatLinkdropUrl = ({
    claimPage,
    networkId,
    contractId,
    secretKeys,
    customURL,
}: {
    claimPage?: string;
    networkId?: string;
    contractId?: string;
    secretKeys: string[] | string;
    customURL?: string;
}): string[] => {
    const { networkId: envNetworkId, contractId: envContractId } = getEnv();
    networkId = networkId || envNetworkId;
    contractId = contractId || envContractId;

    assert(
        secretKeys,
        'Secret keys must be passed in as either an array or a single string'
    );

    assert(
        customURL ||
        Object.prototype.hasOwnProperty.call(supportedLinkdropClaimPages[networkId!], claimPage),
        'Either a custom base URL or a supported claim page must be passed in.'
    );
    customURL =
        customURL || supportedLinkdropClaimPages[networkId!][claimPage!];

    // If the secret key is a single string, convert it to an array
    if (typeof secretKeys === 'string') {
        secretKeys = [secretKeys];
    }

    // insert the contractId and secret key into the base URL based on the CONTRACT_ID and SECRET_KEY field
    const returnedURLs: Array<string> = [];
    // loop through all secret keys
    secretKeys.forEach((secretKey) => {
        // insert the secret key into the base URL
        let url = customURL!.replace('SECRET_KEY', secretKey);
        // insert the contract ID into the base URL
        url = url.replace('CONTRACT_ID', contractId!);
        // add the URL to the array of URLs
        returnedURLs.push(url);
    });

    return returnedURLs;
};

/**
 * Generate a sha256 hash of a passed in string. If the string is hex encoded, set the fromHex flag to true.
 *
 * @param {string} str - the string you wish to hash. By default, this should be utf8 encoded. If the string is hex encoded, set the fromHex flag to true.
 * @param {boolean} fromHex (OPTIONAL) - A flag that should be set if the string is hex encoded. Defaults to false.
 *
 * @returns {Promise<string>} - The resulting hash
 *
 * @example
 * Generating the required password to pass into `claim` given a base password:
 * ```js
 * 	// Create the password to pass into claim which is a hash of the basePassword, public key and whichever use we are on
 * let currentUse = 1;
 * let passwordForClaim = await hashPassword(basePassword + publicKey + currentUse.toString());
 * ```
 * @group Utility
 */
export const hashPassword = async (
    str: string,
    fromHex = false
): Promise<string> => {
    const buf = await hashBuf(str, fromHex);
    return Buffer.from(buf).toString('hex');
};

/**
 * Generate ed25519 KeyPairs that can be used for Keypom linkdrops, or full access keys to claimed accounts. These keys can optionally be derived from some entropy such as a root password and metadata pertaining to each key (user provided password etc.). 
 * Entropy is useful for creating an onboarding experience where in order to recover a keypair, the client simply needs to provide the meta entropy (could be a user's password) and the secret root key like a UUID).
 * 
 * @param {number} numKeys - The number of keys to generate
 * @param {string=} rootEntropy (OPTIONAL) - A root string that will be used as a baseline for all keys in conjunction with different metaEntropies (if provided) to deterministically generate a keypair. If not provided, the keypair will be completely random.
 * @param {string=} metaEntropy (OPTIONAL) - An array of entropies to use in conjunction with a base rootEntropy to deterministically generate the private keys. For single key generation, you can either pass in a string array with a single element, or simply 
 pass in the string itself directly (not within an array).
 * @param {number=} autoMetaNonceStart (OPTIONAL) - Specify a starting index whereby the meta entropy will automatically increment by 1 for each key generated. This is to avoid having to pass in an array of meta entropy that simply increments by 1 each time.
 * This is very useful as auto key generation uses the drop ID, base password and key nonce. The drop ID and base password would be a constant and make up the root entropy and then the key nonce increments by 1 for each key generated.
 * @returns {Promise<GeneratedKeyPairs>} - An object containing an array of KeyPairs, Public Keys and Secret Keys.
 * 
 * @example
 * Generating 10 unique random keypairs with no entropy:
 * ```js
 * // Generate 10 keys with no entropy (all random)
 * let keys = await generateKeys({
 *     numKeys: 10,
 * })
 * 
 * let pubKey1 = keys.publicKeys[0];
 * let secretKey1 = keys.secretKeys[0];
 * 
 * console.log('1st Public Key: ', pubKey1);
 * console.log('1st Secret Key: ', secretKey1)
 * ```
 * 
 * @example
 * Generating 1 keypair based on entropy:
 * ```js
 * // Generate 1 key with the given entropy
 * let {publicKeys, secretKeys} = await generateKeys({
 *     numKeys: 1,
 *     rootEntropy: "my-global-password",
 *     metaEntropy: "user-password-123" // In this case, since there is only 1 key, the entropy can be an array of size 1 as well.
 * })
 * 
 * let pubKey = publicKeys[0];
 * let secretKey = secretKeys[0];
 * 
 * console.log('Public Key: ', pubKey);
 * console.log('Secret Key: ', secretKey)
 * ```
 * 
 * @example 
 * Generating 2 keypairs each with their own entropy:
 * ```js
 * // Generate 2 keys each with their own unique entropy
 * let keys = await generateKeys({
 *     numKeys: 2,
 *     rootEntropy: "my-global-password",
 *     metaEntropy: [
 *        `first-password:0`,
 *        `second-password:1`
 *    ]
 * })
 * 
 * console.log('Pub Keys ', keys.publicKeys);
 * console.log('Secret Keys ', keys.secretKeys);
 * ```
 *  * @example 
 * Generate 50 keys exactly how the auto key generation would in createDrop and addKeys:
 * ```js
 * const dropId = '1676913490360';
 * const basePassword = "my-password";
 * // Generate 50 keys each with their own unique entropy
 * let keys = await generateKeys({
 *     numKeys: 50,
 *     rootEntropy: `${basePassword}-${dropId}`,
 *     autoMetaNonceStart: 0
 * })
 * 
 * console.log('Pub Keys ', keys.publicKeys);
 * console.log('Secret Keys ', keys.secretKeys);
 * ```
 * @group Utility
 */
export const generateKeys = async ({
    numKeys,
    rootEntropy,
    metaEntropy,
    autoMetaNonceStart,
}: {
    /** The number of keys to generate. */
    numKeys: number;
    /** A root string that will be used as a baseline for all keys in conjunction with different metaEntropies (if provided) to deterministically generate a keypair. If not provided, the keypair will be completely random. */
    rootEntropy?: string;
    /** An array of entropies to use in conjunction with a base rootEntropy to deterministically generate the private keys. For single key generation, you can either pass in a string array with a single element, or simply 
 pass in the string itself directly (not within an array). */
    metaEntropy?: string[] | string;
    autoMetaNonceStart?: number;
}): Promise<GeneratedKeyPairs> => {
    // If the metaEntropy provided is not an array (simply the string for 1 key), we convert it to an array of size 1 so that we can use the same logic for both cases
    if (metaEntropy && !Array.isArray(metaEntropy)) {
        metaEntropy = [metaEntropy];
    }

    // Ensure that if metaEntropy is provided, it should be the same length as the number of keys
    const numEntropy = metaEntropy?.length || numKeys;
    assert(
        numEntropy == numKeys,
        'You must provide the same number of meta entropy values as the number of keys'
    );

    const keyPairs: NearKeyPair[] = [];
    const publicKeys: string[] = [];
    const secretKeys: string[] = [];

    if (metaEntropy === undefined && autoMetaNonceStart !== undefined) {
        metaEntropy = Array(numKeys)
            .fill(0)
            .map((_, i) => (autoMetaNonceStart + i).toString());
    }

    for (let i = 0; i < numKeys; i++) {
        if (rootEntropy) {
            const stringToHash = metaEntropy
                ? `${rootEntropy}_${metaEntropy[i]}`
                : rootEntropy;
            const hash: ArrayBuffer = await hashBuf(stringToHash);

            const { secretKey, publicKey } = generateSeedPhrase(hash);
            const keyPair = KeyPair.fromString(secretKey);
            keyPairs.push(keyPair);
            publicKeys.push(publicKey);
            secretKeys.push(secretKey);
        } else {
            const keyPair = KeyPairEd25519.fromRandom();
            keyPairs.push(keyPair);
            publicKeys.push(keyPair.getPublicKey().toString());
            secretKeys.push(keyPair.secretKey);
        }
    }

    return {
        keyPairs,
        publicKeys,
        secretKeys,
    };
};

export const keypomView = async ({ methodName, args }) => {
    const { viewCall, contractId } = getEnv();

    return viewCall({
        contractId,
        methodName,
        args,
    });
};

/**
 * Query for important access key data such as the nonce, allowance, method names etc. that is stored on the NEAR protocol for a given account and public key.
 *
 * @example
 * Check if an access key belongs to a trial account
 * ```js
 * const keyInfo = await viewAccessKeyData({accountId, secretKey});
 * let keyPerms = keyInfo.permission.FunctionCall;
 * isValidTrialInfo = keyPerms.receiver_id === accountId && keyPerms.method_names.includes('execute')
 * console.log('isValidTrialInfo: ', isValidTrialInfo)
 * ```
 * @group Utility
 */
export const viewAccessKeyData = async ({
    accountId,
    publicKey,
    secretKey,
}: {
    /** The account that the access key belongs to. */
    accountId: string;
    /** The secret key of the access key */
    secretKey?: string;
    /** The public key of the access key */
    publicKey?: string;
}) => {
    const { near } = getEnv();

    const provider = near!.connection.provider;

    if (secretKey) {
        publicKey = getPubFromSecret(secretKey);
    }

    const res: any = await provider.query({
        request_type: 'view_access_key',
        finality: 'final',
        account_id: accountId,
        public_key: publicKey!,
    });

    return res;
};

/// TODO WIP: helper to remove the deposit if the user already has enough balance to cover the drop,add_keys
// export const hasDeposit = ({
//     accountId,
//     transactions,
// }) => {
//     const { contractId, viewAccount } = getEnv()

//     const totalDeposit = transactions.reduce((a, c) =>
//         a.add(c.actions.reduce((a, c) => a.add(new BN(c.deposit || '0')), new BN('0')))
//     , new BN('0'))

// 	const userBalance = viewAccount.viewFunction2({ contractId, methodName: 'get_user_balance', args: { account_id: accountId }})

//     if (new BN(userBalance.gt(totalDeposit))) {
//         transactions
//             .filter(({ receiverId }) => contractId === receiverId)
//             .forEach((tx) => tx.actions.forEach((a) => {
//                 if (/create_drop|add_keys/gi.test(a.methodName)) delete a.deposit
//             }))
//     }
// }

/** @group Utility */
export const execute = async ({
    transactions,
    account,
    wallet,
    fundingAccount,
    successUrl,
}: {
    transactions: Transaction[];
    account: Account;
    wallet?: Wallet;
    fundingAccount?: Account;
    successUrl?: string;
}): Promise<
    void | FinalExecutionOutcome[] | Array<void | FinalExecutionOutcome>
> => {
    const { contractId } = getEnv();

    // instance of walletSelector.wallet()
    if (wallet) {
        // wallet might be Promise<Wallet> or value, either way doesn't matter
        wallet = await wallet;
        console.log('wallet: ', wallet);
        // might be able to sign transactions with app key
        let needsRedirect = false;
        const selectorTxns = [];
        transactions.forEach((tx) => {
            const selectorActions = [];
            
            if (tx.receiverId !== contractId) needsRedirect = true;
            tx.actions.forEach((a) => {
                selectorActions.push({
                    type: 'FunctionCall',
                    params: {   
                        methodName: a.functionCall.methodName,
                        args: JSON.parse(new TextDecoder().decode(a.functionCall.args)),
                        deposit: a.functionCall.deposit,
                        gas: a.functionCall.gas
                    }
                });
                const { deposit } = (a as any).params;
                if (deposit && deposit !== '0') needsRedirect = true;
            });

            selectorTxns.push({
                signerId: tx.signerId,
                receiverId: tx.receiverId,
                actions: selectorActions
            });
        });

        console.log('needsRedirect: ', needsRedirect);
        console.log('transactions: ', transactions);

        if (needsRedirect)
            return await wallet.signAndSendTransactions({
                transactions: selectorTxns,
                callbackUrl: successUrl
            });
        // sign txs in serial without redirect
        const responses: Array<void | FinalExecutionOutcome> = [];
        for (const tx of transactions) {
            const selectorActions = [];
            tx.actions.forEach((a) => {
                selectorActions.push({
                    type: 'FunctionCall',
                    params: {   
                        methodName: a.functionCall.methodName,
                        args: JSON.parse(new TextDecoder().decode(a.functionCall.args)),
                        deposit: a.functionCall.deposit,
                        gas: a.functionCall.gas
                    }
                });
            });

            responses.push(
                await wallet.signAndSendTransaction({
                    actions: selectorActions,
                })
            );
        }
        console.log('responses: ', responses);
        return responses;
    }

    /// instance of NEAR Account (backend usage)
    const nearAccount = account || fundingAccount;
    assert(
        nearAccount,
        'Call with either a NEAR Account argument \'account\' or initialize Keypom with a \'fundingAccount\''
    );

    return await signAndSendTransactions(
        nearAccount,
        transformTransactions(<Transaction[]>transactions)
    );
};

/**
 * For FT Drops, keys need to be registered before they can be used. This is done via the `ft_transfer_call` method on the FT contract.
 * This is a convenience method to make that process easier.
 *
 * @example
 * Send FTs using the funder account (not passing in any accounts into the call):
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await ftTransferCall({
 *     contractId: "ft.keypom.testnet",
 *     amount: "1",
 *     dropId: "1231231",
 * )};
 * ```
 * @group Registering Key Uses
 */
export const ftTransferCall = async ({
    account,
    wallet,
    contractId,
    absoluteAmount,
    amount,
    dropId,
    returnTransaction = false,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The fungible token contract ID. */
    contractId: string;
    /** Amount of tokens to transfer but considering the decimal amount (non human-readable).
     *  Example: transferring one wNEAR should be passed in as "1000000000000000000000000" and NOT "1"
     */
    absoluteAmount?: string;
    /**
     * Human readable format for the amount of tokens to transfer.
     * Example: transferring one wNEAR should be passed in as "1" and NOT "1000000000000000000000000"
     */
    amount?: string;
    /** The drop ID to register the keys for. */
    dropId: string;
    /** If true, the transaction will be returned instead of being signed and sent. */
    returnTransaction?: boolean;
}): Promise<Promise<void | FinalExecutionOutcome[]> | Transaction> => {
    const {
        getAccount,
        receiverId: keypomContractId,
        viewCall,
    } = getEnv();
    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    if (amount) {
        const metadata = await viewCall({
            contractId,
            methodName: 'ft_metadata',
        });

        absoluteAmount = parseFTAmount(amount, metadata.decimals);
    }

    const pk = await account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
    const txnInfo: BasicTransaction = {
        receiverId: contractId,
        signerId: account!.accountId, // We know this is not undefined since getAccount throws
        actions: [
            {
                enum: 'FunctionCall',
                functionCall: {
                    methodName: 'ft_transfer_call',
                    args: stringifyJsonOrBytes({
                        receiver_id: keypomContractId,
                        amount: absoluteAmount,
                        msg: dropId.toString(),
                    }),
                    gas: '50000000000000',
                    deposit: '1',
                }
            },
        ],
    };

    const transaction = await convertBasicTransaction({txnInfo, signerId: account!.accountId, signerPk: pk});

    if (returnTransaction) return transaction;
    return execute({ account: account!, transactions: [transaction] }) as Promise<
        void | FinalExecutionOutcome[]
    >;
};

/**
 * For NFT Drops, keys need to be registered before they can be used. This is done via the `nft_transfer_call` method on the NFT contract.
 * This is a convenience method to make that process easier.
 *
 * @param {Account=} account (OPTIONAL) If specified, the passed in account will be used to sign the txn instead of the funder account.
 * @param {BrowserWalletBehaviour=} wallet (OPTIONAL) If using a browser wallet through wallet selector and that wallet should sign the transaction, pass it in.
 * @param {string} contractId The non-fungible token contract ID.
 * @param {string[]} tokenIds A set of token IDs that should be sent to the Keypom contract in order to register keys.
 * @param {string} dropId The drop ID to register the keys for.
 * @param {boolean=} returnTransaction (OPTIONAL) If true, the transaction will be returned instead of being signed and sent.
 *
 * @example
 * Send 3 NFTs using the funder account (not passing in any accounts into the call):
 * ```js
 * // Initialize the SDK on testnet
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * await nftTransferCall({
 *     contractId: "nft.keypom.testnet",
 *     tokenIds: ["1", "2", "3],
 *     dropId: "1231231",
 * )};
 * ```
 * @group Registering Key Uses
 */
export const nftTransferCall = async ({
    account,
    wallet,
    contractId,
    tokenIds,
    dropId,
    returnTransactions = false,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The non-fungible token contract ID. */
    contractId: string;
    /** A set of token IDs that should be sent to the Keypom contract in order to register keys. */
    tokenIds: string[];
    /** The drop ID to register the keys for. */
    dropId: string;
    /** If true, the transaction will be returned instead of being signed and sent. */
    returnTransactions?: boolean;
}): Promise<Array<void | FinalExecutionOutcome[]> | Transaction[]> => {
    const { getAccount, receiverId } = getEnv();
    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    assert(
        tokenIds.length < 6,
        'This method can only transfer 6 NFTs in 1 batch transaction.'
    );

    const responses: Array<FinalExecutionOutcome[]> = [];

    const transactions: Transaction[] = [];

    /// TODO batch calls in parallel where it makes sense
    for (let i = 0; i < tokenIds.length; i++) {
        const pk = await account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
        const txnInfo: BasicTransaction = {
            receiverId: contractId,
            signerId: account!.accountId, // We know this is not undefined since getAccount throws
            actions: [
                {
                    enum: 'FunctionCall',
                    functionCall: {
                        methodName: 'nft_transfer_call',
                        args: stringifyJsonOrBytes({
                            receiver_id: receiverId,
                            token_id: tokenIds[i],
                            msg: dropId.toString(),
                        }),
                        gas: '50000000000000',
                        deposit: '1',
                    }
                },
            ],
        };

        const transaction = await convertBasicTransaction({txnInfo, signerId: account!.accountId, signerPk: pk});

        transactions.push(transaction);
        if (returnTransactions) continue;

        responses.push(
            <FinalExecutionOutcome[]>await execute({
                account: account!,
                transactions,
            })
        );
    }
    return returnTransactions ? transactions : responses;
};

/// https://github.com/near/near-api-js/blob/7f16b10ece3c900aebcedf6ebc660cc9e604a242/packages/near-api-js/src/utils/format.ts#L53
export const parseFTAmount = (amt: string, decimals: number): string => {
    amt = amt.replace(/,/g, '').trim();
    const split = amt.split('.');
    const wholePart = split[0];
    const fracPart = split[1] || '';
    if (split.length > 2 || fracPart.length > decimals) {
        throw new Error(`Cannot parse '${amt}' as NEAR amount`);
    }
    return trimLeadingZeroes(wholePart + fracPart.padEnd(decimals, '0'));
};

const trimLeadingZeroes = (value: string): string => {
    value = value.replace(/^0+/, '');
    if (value === '') {
        return '0';
    }
    return value;
};

/// sequentially execute all transactions
const signAndSendTransactions = async (
    account: Account,
    txs: SignAndSendTransactionOptions[]
): Promise<FinalExecutionOutcome[]> => {
    const responses: FinalExecutionOutcome[] = [];
    for (let i = 0; i < txs.length; i++) {
        // Reference: https://github.com/near/wallet-selector/blob/7f9f8598459cffb80583c2a83c387c3d5c2f4d5d/packages/my-near-wallet/src/lib/my-near-wallet.spec.ts#L31
        responses.push(await account.signAndSendTransaction(txs[i]));
    }
    return responses;
};

export const transformTransactions = (
    transactions: Transaction[]
): SignAndSendTransactionOptions[] =>
    transactions.map(({ receiverId, actions: _actions }) => {
        const actions = _actions.map((action) => createAction(action));
        const txnOption: SignAndSendTransactionOptions = {
            receiverId: receiverId as string,
            actions,
        };
        return txnOption;
    });

export const createAction = (action: Action): Action => {
    if (action.createAccount) {
        return actionCreators.createAccount();
    }

    if (action.deployContract) {
        const { code } = action.deployContract;
        return actionCreators.deployContract(code);
    }

    if (action.functionCall) {
        const { methodName, args, gas, deposit } = action.functionCall;
        return actionCreators.functionCall(
            methodName,
            args,
            new BN(gas),
            new BN(deposit)
        );
    }

    if (action.transfer) {
        const { deposit } = action.transfer;
        return actionCreators.transfer(new BN(deposit));
    }

    if (action.stake) {
        const { stake, publicKey } = action.stake;
        return actionCreators.stake(
            new BN(stake),
            PublicKey.from(publicKey)
        );
    }

    if (action.deleteKey) {
        const { publicKey } = action.deleteKey;
        return actionCreators.deleteKey(PublicKey.from(publicKey));
    }

    if (action.deleteAccount) {
        const { beneficiaryId } = action.deleteAccount;
        return actionCreators.deleteAccount(beneficiaryId);
    }

    throw new Error('Unknown action');
};

/** @group Utility */
export const getStorageBase = ({
    public_keys,
    deposit_per_use,
    drop_id,
    config,
    metadata,
    simple,
    ft,
    nft,
    fc,
    passwords_per_use,
}: CreateDropProtocolArgs) => {
    const storageCostNEARPerByte = 0.00001;
    let totalBytes = 0;

    // Get the bytes per public key, multiply it by number of keys, and add it to the total
    const bytesPerKey = Buffer.from(
        'ed25519:88FHvWTp21tahAobQGjD8YweXGRgA7jE8TSQM6yg4Cim'
    ).length;
    const totalBytesForKeys = bytesPerKey * (public_keys?.length || 0);
    // console.log('totalBytesForKeys: ', totalBytesForKeys)
    // Bytes for the deposit per use
    const bytesForDeposit = Buffer.from(deposit_per_use.toString()).length + 40;
    // console.log('bytesForDeposit: ', bytesForDeposit)
    // Bytes for the drop ID
    const bytesForDropId = Buffer.from(drop_id || '').length + 40;
    // console.log('bytesForDropId: ', bytesForDropId)
    // Bytes for the config
    const bytesForConfig = Buffer.from(JSON.stringify(config || '')).length + 40;
    // console.log('bytesForConfig: ', bytesForConfig)
    // Bytes for the metadata. 66 comes from collection initialization
    const bytesForMetadata = Buffer.from(metadata || '').length + 66;
    // console.log('bytesForMetadata: ', bytesForMetadata)
    // Bytes for the simple data
    const bytesForSimple = Buffer.from(JSON.stringify(simple || '')).length + 40;
    // console.log('bytesForSimple: ', bytesForSimple)
    // Bytes for the FT data
    const bytesForFT = Buffer.from(JSON.stringify(ft || '')).length + 40;
    // console.log('bytesForFT: ', bytesForFT)
    // Bytes for the NFT data
    const bytesForNFT = Buffer.from(JSON.stringify(nft || '')).length + 40;
    // console.log('bytesForNFT: ', bytesForNFT)
    // Bytes for the FC data
    const bytesForFC = Buffer.from(JSON.stringify(fc || '')).length + 40;
    // console.log('bytesForFC: ', bytesForFC)

    // Bytes for the passwords per use
    // Magic numbers come from plotting SDK data against protocol data and finding the best fit
    const bytesForPasswords =
        Buffer.from(JSON.stringify(passwords_per_use || '')).length * 4;

    // console.log('bytesForPasswords: ', bytesForPasswords)
    totalBytes +=
        totalBytesForKeys +
        bytesForDeposit +
        bytesForDropId +
        bytesForConfig +
        bytesForMetadata +
        bytesForSimple +
        bytesForFT +
        bytesForNFT +
        bytesForFC +
        bytesForPasswords;

    // console.log('totalBytes: ', totalBytes)

    // Add a 30% buffer to the total bytes
    totalBytes = Math.round(totalBytes * 1.3);
    // console.log('totalBytes Rounded: ', totalBytes)

    let totalNEARAmount = totalBytes * storageCostNEARPerByte;
    // console.log('totalNEARAmount BEFORE: ', totalNEARAmount)
    // Accounting for protocol storage for access keys
    // Magic numbers come from plotting SDK data against protocol data and finding the best fit
    totalNEARAmount += (public_keys?.length || 0) * 0.005373134328 + 0.00376;
    // console.log('totalNEARAmount AFTER pk: ', totalNEARAmount.toString())

    // Multi use passwords need a little extra storage
    if (passwords_per_use) {
        totalNEARAmount +=
            -0.00155 * ((config?.uses_per_key || 1) - 1) + 0.00285687;
        // console.log('totalNEARAmount AFTER pw per use conversion: ', totalNEARAmount.toString())
    }

    // Turns it into yocto
    return parseNearAmount(totalNEARAmount.toString());
};

/** Initiate the connection to the NEAR blockchain. @group Utility */
export const estimateRequiredDeposit = async ({
    near,
    depositPerUse,
    numKeys,
    usesPerKey,
    attachedGas,
    storage = parseNearAmount('0.034'),
    keyStorage = parseNearAmount('0.0065'),
    fcData,
    ftData,
}: {
    /** The NEAR connection instance used to interact with the chain. This can either the connection that the SDK uses from `getEnv` or a separate connection. */
    near: Near;
    /** How much yoctoNEAR each key will transfer upon use. */
    depositPerUse: string;
    /** How many keys are being added to the drop. */
    numKeys: number;
    /** How many uses each key has. */
    usesPerKey: number;
    /** How much Gas will be attached to each key's use. */
    attachedGas: number;
    /** The estimated storage costs (can be retrieved through `getStorageBase`). */
    storage?: string | null;
    /** How much storage an individual key uses. */
    keyStorage?: string | null;
    /** The FC data for the drop that is being created. */
    fcData?: FCData;
    /** The FT data for the drop that is being created. */
    ftData?: FTData;
}): Promise<string> => {
    const numKeysBN: BN = new BN(numKeys.toString());
    const usesPerKeyBN: BN = new BN(usesPerKey.toString());

    const totalRequiredStorage = new BN(storage).add(
        new BN(keyStorage).mul(numKeysBN)
    );
    // console.log('totalRequiredStorage: ', totalRequiredStorage.toString())

    const actualAllowance =
        estimatePessimisticAllowance(attachedGas).mul(usesPerKeyBN);
    // console.log('actualAllowance: ', actualAllowance.toString())

    const totalAllowance: BN = actualAllowance.mul(numKeysBN);
    // console.log('totalAllowance: ', totalAllowance.toString())

    const totalAccessKeyStorage: BN = ACCESS_KEY_STORAGE.mul(numKeysBN);
    // console.log('totalAccessKeyStorage: ', totalAccessKeyStorage.toString())

    const { numNoneFcs, depositRequiredForFcDrops } =
        getNoneFcsAndDepositRequired(fcData, usesPerKey);

    const totalDeposits = new BN(depositPerUse)
        .mul(new BN(usesPerKey - numNoneFcs))
        .mul(numKeysBN);
    // console.log('totalDeposits: ', totalDeposits.toString())

    const totalDepositsForFc = depositRequiredForFcDrops.mul(numKeysBN);

    // console.log('totalDepositsForFc: ', totalDepositsForFc.toString())

    let requiredDeposit: BN = totalRequiredStorage
        .add(totalAllowance)
        .add(totalAccessKeyStorage)
        .add(totalDeposits)
        .add(totalDepositsForFc);

    // console.log('requiredDeposit B4 FT costs: ', requiredDeposit.toString())

    if (ftData?.contractId) {
        const extraFtCosts = await getFtCosts(
            near,
            numKeys,
            usesPerKey,
            ftData?.contractId
        );
        requiredDeposit = requiredDeposit.add(new BN(extraFtCosts));

        // console.log('requiredDeposit AFTER FT costs: ', requiredDeposit.toString())
    }

    return requiredDeposit.toString() || '0';
};

// Estimate the amount of allowance required for a given attached gas.
const estimatePessimisticAllowance = (attachedGas: number): BN => {
    if (typeof attachedGas !== 'number') attachedGas = parseInt(attachedGas);
    // Get the number of CCCs you can make with the attached GAS
    const numCCCs = Math.floor(attachedGas / GAS_PER_CCC);
    // console.log('numCCCs: ', numCCCs)
    // Get the constant used to pessimistically calculate the required allowance
    const powOutcome = Math.pow(1.03, numCCCs);
    // console.log('powOutcome: ', powOutcome)

    const requiredGas =
        (attachedGas + RECEIPT_GAS_COST) * powOutcome + RECEIPT_GAS_COST;
    // console.log('requiredGas: ', requiredGas)
    const requiredAllowance: BN = new BN(requiredGas).mul(new BN(YOCTO_PER_GAS));
    // console.log('requiredAllowance: ', requiredAllowance.toString())
    return requiredAllowance;
};

// Estimate the amount of allowance required for a given attached gas.
const getNoneFcsAndDepositRequired = (
    fcData: FCData | undefined,
    usesPerKey: number
) => {
    let depositRequiredForFcDrops = new BN(0);
    let numNoneFcs = 0;
    if (!fcData || Object.keys(fcData).length === 0) {
        return { numNoneFcs, depositRequiredForFcDrops };
    }

    const numMethodData = fcData.methods.length;

    // If there's one method data specified and more than 1 claim per key, that data is to be used
    // For all the claims. In this case, we need to tally all the deposits for each method in all method data.
    if (usesPerKey > 1 && numMethodData == 1) {
        const methodData = fcData.methods[0];

        // Keep track of the total attached deposit across all methods in the method data
        let attachedDeposit = new BN(0);
        for (let i = 0; i < (methodData?.length || 0); i++) {
            attachedDeposit = attachedDeposit.add(
                new BN(methodData![i].attachedDeposit)
            );
        }

        depositRequiredForFcDrops = depositRequiredForFcDrops
            .add(new BN(attachedDeposit))
            .mul(new BN(usesPerKey));

        return {
            numNoneFcs,
            depositRequiredForFcDrops,
        };
    }
    // In the case where either there's 1 claim per key or the number of FCs is not 1,
    // We can simply loop through and manually get this data
    for (let i = 0; i < numMethodData; i++) {
        const methodData = fcData.methods[i];
        const isNoneFc = methodData == null;
        numNoneFcs += isNoneFc ? 1 : 0;

        if (!isNoneFc) {
            // Keep track of the total attached deposit across all methods in the method data
            let attachedDeposit = new BN(0);
            for (let j = 0; j < (methodData?.length || 0); j++) {
                attachedDeposit = attachedDeposit.add(
                    new BN(methodData![j].attachedDeposit)
                );
            }

            depositRequiredForFcDrops =
                depositRequiredForFcDrops.add(attachedDeposit);
        }
    }

    return {
        numNoneFcs,
        depositRequiredForFcDrops,
    };
};

// Estimate the amount of allowance required for a given attached gas.
const getFtCosts = async (
    near: Near,
    numKeys: number,
    usesPerKey: number,
    ftContract: string
): Promise<string> => {
    const viewAccount = await near.account('foo');
    const { min } = await viewAccount.viewFunction({
        contractId: ftContract,
        methodName: 'storage_balance_bounds',
        args: {},
    });
    // console.log('storageBalanceBounds: ', storageBalanceBounds)
    const costs: BN = new BN(min)
        .mul(new BN(numKeys))
        .mul(new BN(usesPerKey))
        .add(new BN(min));
    // console.log('costs: ', costs.toString());
    return costs.toString() || '0';
};

/**
 * Generate passwords for a set of public keys. A unique password will be created for each specified use of a public key where the use is NOT zero indexed (i.e 1st use = 1).
 * The passwords will be generated via a double hash of the base password + public key + specific use
 *
 * @param {string[]} publicKeys The public keys that will be used to generate the set of passwords
 * @param {string[]} uses An array of numbers that dictate which uses should be password protected. The 1st use of a key is 1 (NOT zero indexed).
 * @param {string=} basePassword All the passwords will be generated from this base password. It will be double hashed with the public key.
 *
 * @returns {Promise<Array<Array<PasswordPerUse>>>} An array of objects for each key where each object has a password and maps it to its specific key use.
 * @group Utility
 */
export async function generatePerUsePasswords({
    publicKeys,
    uses,
    basePassword,
}: {
    publicKeys: string[];
    uses: number[];
    basePassword: string;
}): Promise<Array<Array<PasswordPerUse>>> {
    const passwords: Array<Array<PasswordPerUse>> = [];

    // Loop through each pubKey to generate either the passwords
    for (let i = 0; i < publicKeys.length; i++) {
        // For each public key, we need to generate a password for each use
        const passwordsPerUse: Array<{ pw: string; key_use: number }> = [];
        for (let j = 0; j < uses.length; j++) {
            // First inner hash takes in utf8 and returns hash
            const innerHashBuff = await hashBuf(
                basePassword + publicKeys[i] + uses[j].toString()
            );
            const innerHash = Buffer.from(innerHashBuff).toString('hex');

            // Outer hash takes in hex and returns hex
            const outerHashBuff = await hashBuf(innerHash, true);
            const outerHash = Buffer.from(outerHashBuff).toString('hex');

            const jsonPw = {
                pw: outerHash,
                key_use: uses[j],
            };
            passwordsPerUse.push(jsonPw);
        }
        passwords.push(passwordsPerUse);
    }

    return passwords;
}

// Taken from https://stackoverflow.com/a/61375162/16441367
export const snakeToCamel = (str) =>
    str
        .toLowerCase()
        .replace(/([-_][a-z])/g, (group) =>
            group.toUpperCase().replace('-', '').replace('_', '')
        );

// Taken from https://stackoverflow.com/a/26215431/16441367
export const toCamel = (o) => {
    let newO, origKey, newKey, value;
    if (o instanceof Array) {
        return o.map(function (value) {
            if (typeof value === 'object') {
                value = toCamel(value);
            }
            return value;
        });
    } else {
        newO = {};
        for (origKey in o) {
            if (Object.prototype.hasOwnProperty.call(o, origKey)) {
                newKey = snakeToCamel(origKey);
                value = o[origKey];
                if (
                    value instanceof Array ||
                    (value !== null && value.constructor === Object)
                ) {
                    value = toCamel(value);
                }
                newO[newKey] = value;
            }
        }
    }
    return newO;
};

export const nearArgsToYocto = (
    nearAmount?: string | number,
    yoctoAmount?: string
) => {
    let yoctoToReturn: string = yoctoAmount || '0';
    if (nearAmount) {
        yoctoToReturn = parseNearAmount(nearAmount.toString()) || '0';
    }

    return yoctoToReturn;
};

export const convertBasicTransaction = async ({ 
    txnInfo, 
    signerId, 
    signerPk 
}: {
    txnInfo: BasicTransaction;
    signerId: string;
    signerPk: PublicKey;
}) => {
    const { near } = getEnv();
    const account = new Account(near!.connection, signerId);
    const { provider } = account.connection;

    const actions = txnInfo.actions.map((action) =>
        createAction(action)
    );

    const block = await provider.block({ finality: 'final' });

    const accessKey: any = await provider.query(
        `access_key/${signerId}/${signerPk}`,
        ''
    );

    return createTransaction(signerId, signerPk, txnInfo.receiverId, accessKey.nonce + 1, actions, baseDecode(block.header.hash));
};

export const createTransactions = ({ 
    txnInfos, 
    signerId, 
    signerPk 
}: {
    txnInfos: BasicTransaction[];
    signerId: string;
    signerPk: PublicKey;
}) => {
    const { near } = getEnv();

    return Promise.all(
        txnInfos.map(async (txnInfo, index) => {
            const account = new Account(near!.connection, signerId);
            const { provider } = account.connection;

            const actions = txnInfo.actions.map((action) =>
                createAction(action)
            );

            const block = await provider.block({ finality: 'final' });

            const accessKey: any = await provider.query(
                `access_key/${signerId}/${signerPk}`,
                ''
            );

            return createTransaction(signerId, signerPk, txnInfo.receiverId, accessKey.nonce + index + 1, actions, baseDecode(block.header.hash));
        })
    );
};

'''
'''--- packages/core/src/lib/keypom.ts ---
import { Account, Connection } from '@near-js/accounts';
import { KeyPair } from '@near-js/crypto';
import { KeyStore, InMemoryKeyStore } from '@near-js/keystores';
import { BrowserLocalStorageKeyStore } from '@near-js/keystores-browser';
import { Near } from '@near-js/wallet-account';
import { parseSeedPhrase } from 'near-seed-phrase';
import {
    assert,
    isSupportedKeypomContract,
    isValidFunderObject,
    isValidKeypomContract,
    isValidNearObject
} from './checks';
import { execute as _execute } from './keypom-utils';
import { EnvVars, Funder } from './types/general';

type KeypomWallet = {
    accountId: string;
    signAndSendTransactions: any;
};

const gas = '200000000000000';
const gas300 = '300000000000000';
const attachedGas = '100000000000000';
export const networks = {
    mainnet: {
        networkId: 'mainnet',
        viewAccountId: 'near',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org',
    },
    testnet: {
        networkId: 'testnet',
        viewAccountId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org',
    },
    localnet: {
        networkId: 'localnet',
        viewAccountId: 'test.near',
    },
};

/**
 * List of supported Keypom contracts that can be used with the SDK.
 * 
 * @group Keypom SDK Environment
 */
export const supportedKeypomContracts = {
    mainnet: {
        'v1.keypom.near': false,
        'v1-3.keypom.near': false,
        'v1-4.keypom.near': true,
        'v2.keypom.near': true,
    },
    testnet: {
        'v1.keypom.testnet': false,
        'v1-3.keypom.testnet': false,
        'v1-4.keypom.testnet': true,
        'v2.keypom.testnet': true,
    },
    localnet: {
        'keypom.test.near': true,
    },
};

/**
 * Official linkdrop claim pages for wallets and other applications
 * 
 * @group Keypom SDK Environment
 */
export const supportedLinkdropClaimPages = {
    mainnet: {
        mynearwallet: 'https://app.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY',
        keypom: 'https://keypom.xyz/claim/CONTRACT_ID#SECRET_KEY',
        meteor: 'https://wallet.meteorwallet.app/linkdrop/CONTRACT_ID/SECRET_KEY'
    },
    testnet: {
        mynearwallet:
            'https://testnet.mynearwallet.com/linkdrop/CONTRACT_ID/SECRET_KEY',
        keypom: 'https://testnet.keypom.xyz/claim/CONTRACT_ID#SECRET_KEY',
        meteor: 'https://wallet.meteorwallet.app/linkdrop/CONTRACT_ID/SECRET_KEY'
    },
};

/**
 * Recovery mapping contracts used to keep track of trial account IDs for given public keys.
 * 
 * @group Keypom SDK Environment
 */
export const accountMappingContract = {
    mainnet: 'v1.mapping.keypom.near',
    testnet: 'v1.mapping.keypom.testnet',
};

const contractBase = 'v2.keypom';
let contractId = `${contractBase}.testnet`;
let receiverId = contractId;

export type Maybe<T> = T | undefined;

let near: Maybe<Near> = undefined;
let connection: Maybe<Connection> = undefined;
let keyStore: Maybe<KeyStore> = undefined;
let networkId: Maybe<string> = undefined;
let fundingAccount: Maybe<Account> = undefined;
let fundingAccountDetails: Maybe<Funder> = undefined;
let contractAccount: Maybe<Account> = undefined;
let viewAccount: any = undefined;
let viewCall: any = undefined;

/**
 *
 * @returns {EnvVars} The environment variables used by the Keypom library.
 * @group Keypom SDK Environment
 */
export const getEnv = (): EnvVars => {
    assert(
        near,
        'Keypom uninitialized. Please call initKeypom or initKeypomContext'
    );

    return {
        near,
        connection,
        keyStore,
        networkId,
        fundingAccount,
        contractAccount,
        viewAccount,
        fundingAccountDetails,
        gas,
        gas300,
        attachedGas,
        contractId,
        receiverId,
        getAccount,
        execute,
        supportedKeypomContracts,
        viewCall,
    };
};

/** @group Utility */
export const execute = async (args) => _execute({ ...args, fundingAccount });

const getAccount = async ({
    account,
    wallet,
}: {
    account: Account;
    wallet: any;
}): Promise<Account | KeypomWallet> => {
    if (wallet) {
        wallet = await wallet;
        assert(wallet.signAndSendTransactions, 'Incorrect wallet type');
        wallet.accountId = (await wallet.getAccounts())[0].accountId;
    }

    const returnedAccount = account || wallet || fundingAccount;

    // If neither a wallet object, account object, or funding account is provided, throw an error
    assert(
        returnedAccount,
        'No account provided. Either pass in an account object, wallet object, or initialize Keypom with a funding account'
    );

    return returnedAccount;
};

/**
 * Initializes the SDK to allow for interactions with the Keypom Protocol. By default, a new NEAR connection will be established but this can be overloaded by
 * passing in an existing connection object. In either case, if a funder is passed in, the credentials will be added to the keystore to sign transactions.
 *
 * To update the funder account, refer to the `updateFunder` function. If you only wish to use view methods and not sign transactions, no funder account is needed.
 * If you wish to update the Keypom Contract ID being used, refer to the `updateKeypomContractId` function.
 *
 * @returns {Promise<Account | null>} If a funder is passed in, its account object is returned. Otherwise, it null is returned.
 *
 * @example
 * Using a pre-created NEAR connection instance with an UnencryptedFileSystemKeyStore:
 * ```js
 * const path = require("path");
 * const homedir = require("os").homedir();
 * const { KeyPair, keyStores, connect } = require("near-api-js");
 * const { initKeypom, getDrops } = require("keypom-js");
 *
 * // Establish the network we wish to work on
 * const network = "testnet";
 * // Get the location where the credentials are stored for our KeyStore
 * const CREDENTIALS_DIR = ".near-credentials";
 * const credentialsPath = (await path).join(homedir, CREDENTIALS_DIR);
 * (await path).join;
 * let keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);
 *
 * // Establish the configuration for the connection
 * let nearConfig = {
 * 		networkId: network,
 * 		keyStore,
 * 		nodeUrl: `https://rpc.${network}.near.org`,
 * 		walletUrl: `https://wallet.${network}.near.org`,
 * 		helperUrl: `https://helper.${network}.near.org`,
 * 		explorerUrl: `https://explorer.${network}.near.org`,
 * };
 * // Connect to the NEAR blockchain and get the connection instance
 * let near = await connect(nearConfig);
 *
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 *		near,
 *		network
 * });
 *
 * // Get the drops for the given owner
 * const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 * ```
 *
 * @example
 * Creating an entirely new NEAR connection instance by using initKeypom and passing in a funder account:
 * ```js
 * const { initKeypom, getDrops } = require("keypom-js");
 *
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 *		network: "testnet",
 *		funder: {
 *			accountId: "benji_demo.testnet",
 *			secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *		}
 * });
 *
 * // Get the drops for the given owner
 * const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 * ```
 * @group Keypom SDK Environment
 */
export const initKeypom = async ({
    near: _near,
    network,
    funder,
    keypomContractId,
}: {
    /** The NEAR connection instance to use. If not passed in, it will create a new one. */
    near?: Near;
    /** The network to connect to either `mainnet` or `testnet`. If a near object is passed in, this field can be omitted*/
    network?: string;
    /**
     * The account that will sign transactions to create drops and interact with the Keypom contract. This account will be added to the KeyStore if provided.
     * If rootEntropy is provided for the funder, all access keys will be derived deterministically based off this string.
     */
    funder?: Funder;
    /**
     * Instead of using the most up-to-date, default Keypom contract, you can specify a specific account ID to use. If an older version is specified, some features of the SDK might not be usable.
     */
    keypomContractId?: string;
}) => {
    // Assert that either a near object or network is passed in
    assert(
        _near || network,
        'Either a NEAR connection object or network must be passed in.'
    );

    if (network != undefined) {
        assert(
            network == 'testnet' || network == 'mainnet' || 'localnet',
            'Network must be either `testnet` or `mainnet` or `localnet`'
        );
        // Assert that if network was passed in as "localnet", a near object should also be passed in
        assert(
            network != 'localnet' || _near,
            'If network is `localnet`, a NEAR connection object must be passed in.'
        );
    }

    if (_near) {
        assert(
            isValidNearObject(_near),
            'The NEAR object passed in is not valid. Please pass in a valid NEAR object.'
        );
        near = _near;
        keyStore = near.config.keyStore;
    } else {
        const networkConfig =
            typeof network === 'string' ? networks[network] : network;
        keyStore = process?.versions?.node
            ? new InMemoryKeyStore()
            : new BrowserLocalStorageKeyStore();
        near = new Near({
            ...networkConfig,
            keyStore,
        });
    }

    connection = near.connection;
    networkId = near.config.networkId;

    if (networkId === 'mainnet') {
        contractId = receiverId = `${contractBase}.near`;
    }
    if (networkId === 'localnet') {
        contractId = receiverId = 'keypom.test.near';
    }

    if (keypomContractId) {
        assert(
            isValidKeypomContract(keypomContractId) === true,
            'The keypom contract passed in must be an official Keypom contract for the given network.'
        );
        if (isSupportedKeypomContract(keypomContractId) !== true) {
            console.warn(
                'The Keypom contract you are using is not the latest version. Most methods will be unavailable. Please use the latest contract: v1-3.keypom.near or v1-3.keypom.testnet'
            );
        }

        contractId = receiverId = keypomContractId;
    }

    viewAccount = new Account(connection, networks[networkId!].viewAccountId);
    viewCall = viewAccount.viewFunction2 = ({ contractId, methodName, args }) =>
        viewAccount!.viewFunction({ contractId, methodName, args });

    contractAccount = new Account(connection, contractId);

    if (funder) {
        await updateFunder({ funder });
    }

    return null;
};

/**
 * Once the SDK is initialized, this function allows the current funder account to be updated. Having a funder is only necessary if you wish to sign transactions on the Keypom Protocol.
 *
 * @param {Funder} funder The account that will sign transactions to create drops and interact with the Keypom contract. This account will be added to the KeyStore if provided.
 * If rootEntropy is provided for the funder, all access keys will be derived deterministically based off this string.
 * @returns {Promise<Account>} The funder's account object is returned.
 *
 * @example
 * After initializing the SDK, the funder is updated.
 * ```js
 * const path = require("path");
 * const homedir = require("os").homedir();
 * const { KeyPair, keyStores, connect } = require("near-api-js");
 * const { initKeypom, updateFunder, getDrops } = require("keypom-js");
 *
 *	// Initialize the SDK for the given network and NEAR connection
 *	await initKeypom({
 *		network: "testnet",
 *	});
 *
 *	// Update the current funder account
 *	await updateFunder({
 *		funder: {
 *			accountId: "benji_demo.testnet",
 *			secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *		}
 *	})
 *
 *	// Get the drops for the given owner
 *	const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 *	console.log('dropsForOwner: ', dropsForOwner)
 *
 *	return;
 * ```
 * @group Keypom SDK Environment
 */
export const updateFunder = async ({ funder }: { funder: Funder }) => {
    assert(
        near !== undefined,
        'You must initialize the SDK via `initKeypom` before updating the funder account.'
    );
    assert(
        isValidFunderObject(funder),
        'The funder object passed in is not valid. Please pass in a valid funder object.'
    );
    assert(
        funder.secretKey || funder.seedPhrase,
        'The funder object passed in must have either a secretKey or seedphrase'
    );

    const accountId = funder.accountId;
    const seedPhrase = funder.seedPhrase;
    let secretKey = funder.secretKey;
    
    if (seedPhrase) {
        secretKey = parseSeedPhrase(seedPhrase).secretKey;
    }
    funder.fundingKeyPair = KeyPair.fromString(secretKey!);
    await keyStore!.setKey(networkId!, accountId, funder.fundingKeyPair);

    fundingAccountDetails = funder;
    fundingAccount = new Account(connection!, accountId);

    return null;
};

/**
 * This allows the desired Keypom contract ID to be set. By default, the most up-to-date Keypom contract for the given network is set during initKeypom.
 *
 * @param {string} keypomContractId The account ID that should be used for the Keypom contract.
 *
 * @example
 * After initializing the SDK, the Keypom contract ID is updated.
 * ```js
 * const path = require("path");
 * const homedir = require("os").homedir();
 * const { KeyPair, keyStores, connect } = require("near-api-js");
 * const { initKeypom, updateKeypomContractId, getDrops } = require("keypom-js");
 *
 *	// Initialize the SDK for the given network and NEAR connection
 *	await initKeypom({
 *		network: "testnet",
 *	});
 *
 *	// Update the current Keypom contract ID
 *	updateKeypomContractId({
 *		keypomContractId: "v1.keypom.testnet"
 *	})
 *
 *	//Get the drops for the given owner
 *	const dropsForOwner = await getDrops({accountId: "benjiman.testnet"});
 *	console.log('dropsForOwner: ', dropsForOwner)
 *
 *	return;
 * ```
 * @group Keypom SDK Environment
 */
export const updateKeypomContractId = ({
    keypomContractId,
}: {
    keypomContractId: string;
}) => {
    assert(
        near !== undefined,
        'You must initialize the SDK via `initKeypom` before updating the Keypom contract ID.'
    );
    assert(
        isValidKeypomContract(keypomContractId) === true,
        'The keypom contract passed in must be an official Keypom contract for the given network.'
    );
    if (isSupportedKeypomContract(keypomContractId) !== true) {
        console.warn(
            'The Keypom contract you are using is not the latest version. Most methods will be unavailable. Please use the latest contract: v1-3.keypom.near or v1-3.keypom.testnet'
        );
    }

    contractId = receiverId = keypomContractId;
    contractAccount = new Account(connection!, contractId);
    return null;
};

'''
'''--- packages/core/src/lib/keys.ts ---
import BN from 'bn.js';
//import * as nearAPI from "near-api-js";
// const {
//     utils: {
//         format: { parseNearAmount },
//     },
// } = nearAPI;

import {
    BrowserWalletBehaviour,
    Wallet
} from '@near-wallet-selector/core/lib/wallet/wallet.types';
//import { Account } from "near-api-js";
import { Account } from '@near-js/accounts';
import { parseNearAmount } from '@near-js/utils';
import { assert, isSupportedKeypomContract, isValidAccountObj } from './checks';
import { getEnv } from './keypom';
import {
    convertBasicTransaction,
    estimateRequiredDeposit,
    ftTransferCall,
    generateKeys,
    generatePerUsePasswords,
    key2str, nftTransferCall,
    toCamel
} from './keypom-utils';
import { CreateOrAddReturn } from './types/params';
import { ProtocolReturnedDrop } from './types/protocol';
import { canUserAddKeys, getDropInformation, getUserBalance } from './views';
import { Action, Transaction, stringifyJsonOrBytes } from '@near-js/transactions';

type AnyWallet = BrowserWalletBehaviour | Wallet;

/**
 * Add keys that are manually generated and passed in, or automatically generated to an existing drop. If they're
 * automatically generated, they can be based off a set of entropy. For NFT and FT drops, assets can automatically be sent to Keypom to register keys as part of the payload.
 * The deposit is estimated based on parameters that are passed in and the transaction can be returned instead of signed and sent to the network. This can allow you to get the
 * required deposit from the return value and use that to fund the account's Keypom balance to avoid multiple transactions being signed in the case of a drop with many keys.
 *
 * @return {Promise<CreateOrAddReturn>} Object containing: the drop ID, the responses of the execution, as well as any auto generated keys (if any).
 *
 * @example
 * Create a basic empty simple drop and add 10 keys. Each key is completely random:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create an empty simple drop with no keys.
 * const {dropId} = await createDrop({
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Add 10 completely random keys. The return value `keys` contains information about the generated keys
 * const {keys} = await addKeys({
 * 	dropId,
 * 	numKeys: 10
 * })
 *
 * console.log('public keys: ', keys.publicKeys);
 * console.log('private keys: ', keys.secretKeys);
 * ```
 *
 * @example
 * Init funder with root entropy, create empty drop and add generate deterministic keys. Compare with manually generated keys:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. Root entropy is passed into the funder account so any generated keys
 * // Will be based off that entropy.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1",
 * 		rootEntropy: "my-global-secret-password"
 * 	}
 * });
 *
 * // Create a simple drop with no keys
 * const { dropId } = await createDrop({
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Add 5 keys to the empty simple drop. Each key will be derived based on the rootEntropy of the funder, the drop ID, and key nonce.
 * const {keys: keysFromDrop} = await addKeys({
 * 	dropId,
 * 	numKeys: 5
 * })
 *
 * // Deterministically Generate the Private Keys:
 * const nonceDropIdMeta = Array.from({length: 5}, (_, i) => `${dropId}_${i}`);
 * const manualKeys = await generateKeys({
 * 	numKeys: 5,
 * 	rootEntropy: "my-global-secret-password",
 * 	metaEntropy: nonceDropIdMeta
 * })
 *
 * // Get the public and private keys from the keys generated by addKeys
 * const {publicKeys, secretKeys} = keysFromDrop;
 * // Get the public and private keys from the keys that were manually generated
 * const {publicKeys: pubKeysGenerated, secretKeys: secretKeysGenerated} = manualKeys;
 * // These should match!
 * console.log('secretKeys: ', secretKeys)
 * console.log('secretKeysGenerated: ', secretKeysGenerated)
 *
 * // These should match!
 * console.log('publicKeys: ', publicKeys)
 * console.log('pubKeysGenerated: ', pubKeysGenerated)
 * ```
 *
 * @example
 * Create an empty drop and add manually created keys:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection. No entropy passed in so any auto generated keys will
 * // be completely random unless otherwise overwritten.
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create an empty simple drop using the keys that were generated. Since keys are passed in, the return value won't contain information about the keys.
 * const {dropId} = await createDrop({
 * 	publicKeys,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * // Generate 10 random keys
 * const {publicKeys} = await generateKeys({
 * 	numKeys: 10
 * });
 *
 * // Add keys to the drop using the keys that were generated. Since keys are passed in, the return value won't contain information about the keys.
 * await addKeys({
 * 	publicKeys,
 * 	dropId
 * })
 * ```
 * @group Creating, And Claiming Drops
 */
export const addKeys = async ({
    account,
    wallet,
    dropId,
    drop,
    numKeys,
    publicKeys,
    nftTokenIds,
    rootEntropy,
    basePassword,
    passwordProtectedUses,
    extraDepositNEAR,
    extraDepositYocto,
    useBalance = false,
    returnTransactions = false,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /**
     * Specify how many keys should be generated for the drop. If the funder has rootEntropy set OR rootEntropy is passed in, the keys will be
     * deterministically generated using the drop ID, key nonce, and entropy. Otherwise, each key will be generated randomly.
     */
    numKeys: number;
    /** Pass in a custom set of publicKeys to add to the drop. If this is not passed in, keys will be generated based on the numKeys parameter. */
    publicKeys?: string[];
    /**  Specify the drop ID for which you want to add keys to. */
    dropId?: string;
    /** If the drop information from getDropInformation is already known to the client, it can be passed in instead of the drop ID to reduce computation. */
    drop?: ProtocolReturnedDrop;
    /**
     * If the drop type is an NFT drop, the token IDs can be passed in so that the tokens are automatically sent to the Keypom contract rather
     * than having to do two separate transactions. A maximum of 2 token IDs can be sent during the `addKeys` function. To send more token IDs in
     * order to register key uses, use the `nftTransferCall` function.
     */
    nftTokenIds?: string[];
    /** Specify an entropy to use for generating keys (will overload the funder's rootEntropy if applicable). This parameter only matters if the publicKeys variable is not passed in. */
    rootEntropy?: string;
    /** For doing password protected drops, this is the base password that will be used to generate all the passwords. It will be double hashed with the public keys. If specified, by default, all key uses will have their own unique password unless passwordProtectedUses is passed in. */
    basePassword?: string;
    /** For doing password protected drops, specifies exactly which uses will be password protected. The uses are NOT zero indexed (i.e 1st use = 1). Each use will have a different, unique password generated via double hashing the base password + public key + key use. */
    passwordProtectedUses?: number[];
    /** For Public Sales, drops might require an additional fee for adding keys. This specifies the amount of $NEAR in human readable format (i.e `1.5` = 1.5 $NEAR) */
    extraDepositNEAR?: number;
    /** For Public Sales, drops might require an additional fee for adding keys. This specifies the amount of $NEAR in yoctoNEAR (i.e `1` = 1 $yoctoNEAR = 1e-24 $NEAR) */
    extraDepositYocto?: string;
    /** If the account has a balance within the Keypom contract, set this to true to avoid the need to attach a deposit. If the account doesn't have enough balance, an error will throw. */
    useBalance?: boolean;
    /** If true, the transaction will be returned instead of being signed and sent. This is useful for getting the requiredDeposit from the return value without actually signing the transaction. */
    returnTransactions?: boolean;
}): Promise<CreateOrAddReturn> => {
    const {
        near,
        gas,
        contractId,
        receiverId,
        getAccount,
        execute,
        fundingAccountDetails,
    } = getEnv();

    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );

    assert(drop || dropId, 'Either a dropId or drop object must be passed in.');
    assert(
        numKeys || publicKeys?.length,
        'Either pass in publicKeys or set numKeys to a positive non-zero value.'
    );
    assert(
        isSupportedKeypomContract(contractId!) === true,
        'Only the latest Keypom contract can be used to call this methods. Please update the contract'
    );

    account = await getAccount({ account, wallet });
    const pubKey = await account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);

    const {
        drop_id,
        owner_id,
        required_gas,
        deposit_per_use,
        config,
        ft: ftData,
        nft: nftData,
        fc: fcData,
        next_key_id,
    } = drop || (await getDropInformation({ dropId: dropId! }));
    dropId = drop_id;

    const uses_per_key = config?.uses_per_key || 1;

    // If the contract is v1-3 or lower, just check if owner is the same as the calling account. If it's v1-4 or higher, check if the calling account has the permission to add keys.
    if (!contractId!.includes('v1-4.keypom')) {
        assert(
            owner_id === account!.accountId,
            'Calling account is not the owner of this drop.'
        );
    } else {
        const canAddKeys = await canUserAddKeys({
            accountId: account!.accountId,
            dropId,
        });
        assert(
            canAddKeys == true,
            'Calling account does not have permission to add keys to this drop.'
        );
    }

    // If there are no publicKeys being passed in, we should generate our own based on the number of keys
    let keys;
    if (!publicKeys) {

        // Default root entropy is what is passed in. If there wasn't any, we should check if the funding account contains some.
        const rootEntropyUsed =
            rootEntropy || fundingAccountDetails?.rootEntropy;
        // If either root entropy was passed into the function or the funder has some set, we should use that.
        if (rootEntropyUsed) {
            // Create an array of size numKeys with increasing strings from next_key_id -> next_key_id + numKeys - 1. Each element should also contain the dropId infront of the string
            const nonceDropIdMeta = Array.from(
                { length: numKeys },
                (_, i) => `${drop_id}_${next_key_id + i}`
            );
            keys = await generateKeys({
                numKeys,
                rootEntropy: rootEntropyUsed,
                metaEntropy: nonceDropIdMeta,
            });
        } else {
            // No entropy is provided so all keys should be fully random
            keys = await generateKeys({
                numKeys,
            });
        }

        publicKeys = keys.publicKeys;
    }

    numKeys = publicKeys!.length;
    assert(numKeys <= 100, 'Cannot add more than 100 keys at once');
    let passwords;
    if (basePassword) {
        assert(numKeys <= 50, 'Cannot add more than 50 keys at once with passwords');

        // Generate the passwords with the base password and public keys. By default, each key will have a unique password for all of its uses unless passwordProtectedUses is passed in
        passwords = await generatePerUsePasswords({
            publicKeys: publicKeys!,
            basePassword,
            uses:
                passwordProtectedUses ||
                Array.from({ length: uses_per_key }, (_, i) => i + 1),
        });
    }

    const camelFTData = toCamel(ftData);
    const camelFCData = toCamel(fcData);

    let requiredDeposit = await estimateRequiredDeposit({
        near: near!,
        depositPerUse: deposit_per_use,
        numKeys,
        usesPerKey: uses_per_key,
        attachedGas: parseInt(required_gas),
        storage: parseNearAmount('0.2') as string,
        fcData: camelFCData,
        ftData: camelFTData,
    });

    // If there is any extra deposit needed, add it to the required deposit
    extraDepositYocto = extraDepositYocto
        ? new BN(extraDepositYocto)
        : new BN('0');
    if (extraDepositNEAR) {
        extraDepositYocto = new BN(
            parseNearAmount(extraDepositNEAR.toString())
        );
    }
    requiredDeposit = new BN(requiredDeposit).add(extraDepositYocto).toString();

    let hasBalance = false;
    if (useBalance) {
        const userBal = new BN(
            await getUserBalance({ accountId: account!.accountId })
        );
        if (userBal.lt(new BN(requiredDeposit))) {
            throw new Error(
                'Insufficient balance on Keypom to create drop. Use attached deposit instead.'
            );
        }

        hasBalance = true;
    }

    let transactions: Transaction[] = [];

    const txn = await convertBasicTransaction({
        txnInfo: {
            receiverId,
            signerId: account!.accountId,
            actions: [
                {
                    enum: 'FunctionCall',
                    functionCall: {
                        methodName: 'add_keys',
                        args: stringifyJsonOrBytes({
                            drop_id,
                            public_keys: publicKeys,
                            passwords_per_use: passwords,
                        }),
                        gas,
                        deposit: !hasBalance ? requiredDeposit : undefined,
                    },
                },
            ],
        },
        signerId: account!.accountId,
        signerPk: pubKey
    });

    transactions.push(txn);

    if (ftData?.contract_id) {
        transactions.push(
            await ftTransferCall({
                account: account!,
                contractId: ftData.contract_id,
                absoluteAmount: new BN(ftData.balance_per_use!)
                    .mul(new BN(numKeys))
                    .mul(new BN(uses_per_key))
                    .toString(),
                dropId: drop_id,
                returnTransaction: true,
            }) as Transaction
        );
    }

    const tokenIds = nftTokenIds;
    if (nftData && tokenIds && tokenIds?.length > 0) {
        if (tokenIds.length > 2) {
            throw new Error(
                'You can only automatically register 2 NFTs with \'createDrop\'. If you need to register more NFTs you can use the method \'nftTransferCall\' after you create the drop.'
            );
        }
        const nftTXs = (await nftTransferCall({
            account: account!,
            contractId: nftData.contract_id,
            tokenIds,
            dropId: dropId!.toString(),
            returnTransactions: true,
        })) as Transaction[];
        transactions = transactions.concat(nftTXs);
    }

    if (returnTransactions) {
        return { keys, dropId: drop_id, transactions, requiredDeposit };
    }

    const responses = await execute({ transactions, account, wallet });

    return { responses, dropId: drop_id, keys, requiredDeposit };
};

/**
 * Delete a set of keys from a drop and optionally withdraw any remaining balance you have on the Keypom contract.
 *
 * @example
 * Create a drop with 5 keys and delete the first one:
 * ```js
 * // Initialize the SDK for the given network and NEAR connection
 * await initKeypom({
 * 	network: "testnet",
 * 	funder: {
 * 		accountId: "benji_demo.testnet",
 * 		secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 * 	}
 * });
 *
 * // Create the simple drop with 5 random keys
 * const {keys, dropId} = await createDrop({
 * 	numKeys: 5,
 * 	depositPerUseNEAR: 1,
 * });
 *
 * await deleteKeys({
 * 	dropId,
 * 	publicKeys: keys.publicKeys[0] // Can be wrapped in an array as well
 * })
 * ```
 * @group Deleting State
 */
export const deleteKeys = async ({
    account,
    wallet,
    publicKeys,
    dropId,
    withdrawBalance = false,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** Specify a set of public keys to delete. If deleting a single publicKey, the string can be passed in without wrapping it in an array. */
    publicKeys: string[] | string;
    /** Which drop ID do the keys belong to? */
    dropId: string;
    /** Whether or not to withdraw any remaining balance on the Keypom contract. */
    withdrawBalance?: boolean;
}) => {
    const { receiverId, execute, getAccount, contractId } = getEnv();
    assert(
        isSupportedKeypomContract(contractId!) === true,
        'Only the latest Keypom contract can be used to call this methods. Please update the contract'
    );

    const { owner_id, drop_id, registered_uses, ft, nft } =
        await getDropInformation({ dropId });

    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    assert(
        owner_id == account!.accountId,
        'Only the owner of the drop can delete keys.'
    );

    const actions: Action[] = [];
    if ((ft || nft) && registered_uses > 0) {
        actions.push({
            enum: 'FunctionCall',
            functionCall: {
                methodName: 'refund_assets',
                args: stringifyJsonOrBytes({
                    drop_id,
                }),
                gas: '100000000000000',
                deposit: '0'
            },
        });
    }

    // If the publicKeys provided is not an array (simply the string for 1 key), we convert it to an array of size 1 so that we can use the same logic for both cases
    if (publicKeys && !Array.isArray(publicKeys)) {
        publicKeys = [publicKeys];
    }

    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'delete_keys',
            args: stringifyJsonOrBytes({
                drop_id,
                public_keys: (publicKeys as string[]).map(key2str),
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });

    if (withdrawBalance) {
        actions.push({
            enum: 'FunctionCall',
            functionCall: {
                methodName: 'withdraw_from_balance',
                args: stringifyJsonOrBytes({}),
                gas: '100000000000000',
                deposit: '0'
            },
        });
    }

    const transactions: any[] = [
        {
            receiverId,
            actions,
        },
    ];

    return execute({ transactions, account, wallet });
};

'''
'''--- packages/core/src/lib/sales.ts ---
// import {
// 	parseNearAmount
// } from "near-api-js/lib/utils/format";
import { assert, isValidAccountObj } from './checks';
import { getEnv } from './keypom';

import {
    BrowserWalletBehaviour,
    Wallet
} from '@near-wallet-selector/core/lib/wallet/wallet.types';
//import { Account } from "near-api-js";
import { Account } from '@near-js/accounts';
import { parseNearAmount } from '@near-js/utils';
import { getDropInformation } from './views';
import { Action, stringifyJsonOrBytes } from '@near-js/transactions';

type AnyWallet = BrowserWalletBehaviour | Wallet;

/**
 * Add a list of account IDs to a drop's sale allowlist. If the allowlist is empty, anyone can purchase keys. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 * const {dropId} = await createDrop({
 * 		numKeys: 0,
 * 		depositPerUseNEAR: 0.1,
 * 		config: {
 * 			sale: {
 * 				maxNumKeys: 2,
 * 				pricePerKeyNEAR: 1
 * 			}
 * 		}
 * 	});
 *
 * 	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 * 	t.is(canAddKeys, true);
 *
 * 	await addToSaleAllowlist({dropId, accountIds: ["barfoo.testnet"]});
 * 	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 * 	t.is(canAddKeys, false);
 *  ```
 * @group Public Sale Functions
 */
export const addToSaleAllowlist = async ({
    account,
    wallet,
    dropId,
    accountIds,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop */
    dropId: string;
    /** A list of account IDs that should be added to the sale allowlist */
    accountIds: string[];
}) => {
    const { receiverId, execute, getAccount } = getEnv();

    assert(
        dropId && accountIds,
        'Must pass in a drop ID and a list of account IDs to add to the sale allowlist.'
    );
    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    const dropInfo = await getDropInformation({ dropId });
    assert(
        account!.accountId == dropInfo.owner_id,
        'Only the owner of the drop can add accounts to the sale allowlist.'
    );
    assert(
        dropInfo.config?.sale,
        'The drop config must have a sale in order to add accounts to the sale allowlist.'
    );

    const actions: Action[] = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'add_to_sale_allowlist',
            args: stringifyJsonOrBytes({
                drop_id: dropId,
                account_ids: accountIds,
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });

    const transactions: any[] = [
        {
            receiverId,
            actions,
        },
    ];

    return execute({ transactions, account, wallet });
};

/**
 * Remove a list of account IDs from a drop's sale allowlist. If the allowlist is empty, anyone can purchase keys. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1,
 *				allowlist: ["foobar.testnet", "barfoo.testnet"]
 *			}
 *		}
 *	});
 *
 *	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "not_in_allowlist.testnet"});
 *	t.is(canAddKeys, false);
 *
 *	await removeFromSaleAllowlist({dropId, accountIds: ["foobar.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, false);
 *
 *	await removeFromSaleAllowlist({dropId, accountIds: ["barfoo.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *  ```
 * @group Public Sale Functions
 */
export const removeFromSaleAllowlist = async ({
    account,
    wallet,
    dropId,
    accountIds,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop */
    dropId: string;
    /** A list of account IDs that should be removed from the sale's allowlist */
    accountIds: string[];
}) => {
    const { receiverId, execute, getAccount } = getEnv();

    assert(
        dropId && accountIds,
        'Must pass in a drop ID and a list of account IDs to remove from the sale allowlist.'
    );
    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    const dropInfo = await getDropInformation({ dropId });
    assert(
        account!.accountId == dropInfo.owner_id,
        'Only the owner of the drop can remove accounts from the sale allowlist.'
    );
    assert(
        dropInfo.config?.sale,
        'The drop config must have a sale in order to remove accounts from the sale allowlist.'
    );

    const actions: Action[] = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'remove_from_sale_allowlist',
            args: stringifyJsonOrBytes({
                drop_id: dropId,
                account_ids: accountIds,
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });

    const transactions: any[] = [
        {
            receiverId,
            actions,
        },
    ];

    return execute({ transactions, account, wallet });
};

/**
 * Add a list of account IDs to a drop's sale blocklist. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1
 *			}
 *		}
 *	});
 *
 *	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *
 *	await addToSaleBlocklist({dropId, accountIds: ["foobar.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, false);
 *  ```
 * @group Public Sale Functions
 */
export const addToSaleBlocklist = async ({
    account,
    wallet,
    dropId,
    accountIds,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop */
    dropId: string;
    /** A list of account IDs that should be added to the sale blocklist */
    accountIds: string[];
}) => {
    const { receiverId, execute, getAccount } = getEnv();

    assert(
        dropId && accountIds,
        'Must pass in a drop ID and a list of account IDs to add to the sale blocklist.'
    );
    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    const dropInfo = await getDropInformation({ dropId });
    assert(
        account!.accountId == dropInfo.owner_id,
        'Only the owner of the drop can add accounts to the sale blocklist.'
    );
    assert(
        dropInfo.config?.sale,
        'The drop config must have a sale in order to add accounts to the sale blocklist.'
    );

    const actions: Action[] = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'add_to_sale_blocklist',
            args: stringifyJsonOrBytes({
                drop_id: dropId,
                account_ids: accountIds,
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });

    const transactions: any[] = [
        {
            receiverId,
            actions,
        },
    ];

    return execute({ transactions, account, wallet });
};

/**
 * Remove a list of account IDs from a drop's sale blocklist. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1,
 *				blocklist: ["foobar.testnet"]
 *			}
 *		}
 *	});
 *
 *	let canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, false);
 *
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "not_in_blocklist.testnet"});
 *	t.is(canAddKeys, true);
 *
 *	await removeFromSaleBlocklist({dropId, accountIds: ["foobar.testnet"]});
 *	canAddKeys = await canUserAddKeys({dropId, accountId: "foobar.testnet"});
 *	t.is(canAddKeys, true);
 *  ```
 * @group Public Sale Functions
 */
export const removeFromSaleBlocklist = async ({
    account,
    wallet,
    dropId,
    accountIds,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop */
    dropId: string;
    /** A list of account IDs that should be removed from the sale's allowlist */
    accountIds: string[];
}) => {
    const { receiverId, execute, getAccount } = getEnv();

    assert(
        dropId && accountIds,
        'Must pass in a drop ID and a list of account IDs to remove from the sale blocklist.'
    );
    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    const dropInfo = await getDropInformation({ dropId });
    assert(
        account!.accountId == dropInfo.owner_id,
        'Only the owner of the drop can remove accounts from the sale blocklist.'
    );
    assert(
        dropInfo.config?.sale,
        'The drop config must have a sale in order to remove accounts from the sale blocklist.'
    );

    const actions: Action[] = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'remove_from_sale_blocklist',
            args: stringifyJsonOrBytes({
                drop_id: dropId,
                account_ids: accountIds,
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });

    const transactions: any[] = [
        {
            receiverId,
            actions,
        },
    ];

    return execute({ transactions, account, wallet });
};

/**
 * Remove a list of account IDs from a drop's sale blocklist. The sale object must exist in the drop's config for this to go through.
 *
 * @example
 * ```js
 *	const {dropId} = await createDrop({
 *		numKeys: 0,
 *		depositPerUseNEAR: 0.1,
 *		config: {
 *			sale: {
 *				maxNumKeys: 2,
 *				pricePerKeyNEAR: 1
 *			}
 *		}
 *	});
 *
 *	await updateSale({
 *		dropId,
 *		pricePerKeyNEAR: 2
 *	})
 *  ```
 *
 * @group Public Sale Functions
 */
export const updateSale = async ({
    account,
    wallet,
    dropId,
    maxNumKeys,
    pricePerKeyNEAR,
    pricePerKeyYocto,
    autoWithdrawFunds,
    start,
    end,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** The drop ID for the drop */
    dropId: string;
    /** Maximum number of keys that can be added to this drop. If None, there is no max. */
    maxNumKeys?: number;
    /**
     * Amount of $NEAR that the user needs to attach (if they are not the funder) on top of costs. This amount will be
     * Automatically sent to the funder's balance. If None, the keys are free to the public.
     */
    pricePerKeyNEAR?: number;
    pricePerKeyYocto?: string;
    /**
     * Should the revenue generated be sent to the funder's account balance or
     * automatically withdrawn and sent to their NEAR wallet?
     */
    autoWithdrawFunds?: boolean;
    /**
     * Minimum block timestamp before the public sale starts. If None, keys can be added immediately
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    start?: number;
    /**
     * Block timestamp dictating the end of the public sale. If None, keys can be added indefinitely
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    end?: number;
}) => {
    const { receiverId, execute, getAccount } = getEnv();

    assert(
        dropId &&
            (maxNumKeys ||
                pricePerKeyNEAR ||
                pricePerKeyYocto ||
                autoWithdrawFunds ||
                start ||
                end),
        'Must pass in a drop ID and at least one of the other sale parameters to update'
    );
    assert(
        isValidAccountObj(account),
        'Passed in account is not a valid account object.'
    );
    account = await getAccount({ account, wallet });

    const dropInfo = await getDropInformation({ dropId });
    assert(
        account!.accountId == dropInfo.owner_id,
        'Only the owner of the drop can update the sale.'
    );
    assert(
        dropInfo.config?.sale,
        'The drop config must have a sale in order to be updated.'
    );

    const actions: Action[] = [];
    actions.push({
        enum: 'FunctionCall',
        functionCall: {
            methodName: 'update_sale',
            args: stringifyJsonOrBytes({
                drop_id: dropId,
                max_num_keys: maxNumKeys,
                price_per_key:
                    pricePerKeyYocto || pricePerKeyNEAR
                        ? parseNearAmount(pricePerKeyNEAR!.toString())
                        : undefined,
                auto_withdraw_funds: autoWithdrawFunds,
                start,
                end,
            }),
            gas: '100000000000000',
            deposit: '0'
        },
    });

    const transactions: any[] = [
        {
            receiverId,
            actions,
        },
    ];

    return execute({ transactions, account, wallet });
};

'''
'''--- packages/core/src/lib/trial-accounts/pre-trial.ts ---
import {
    BrowserWalletBehaviour,
    Wallet,
} from "@near-wallet-selector/core/lib/wallet/wallet.types";
import BN from "bn.js";
import { Account } from "@near-js/accounts";
import { KeyPair } from "@near-js/crypto";
import { Transaction, stringifyJsonOrBytes } from "@near-js/transactions";
import { parseNearAmount } from "@near-js/utils";
import {
    assert,
    assertDropIdUnique,
    assertValidDropConfig,
    isSupportedKeypomContract,
    isValidAccountObj,
} from "../checks";
import { accountMappingContract, getEnv } from "../keypom";
import {
    convertBasicTransaction,
    estimateRequiredDeposit,
    generateKeys,
    getStorageBase,
    nearArgsToYocto,
} from "../keypom-utils";
import { DropConfig } from "../types/drops";
import { FCData } from "../types/fc";
import { BasicTransaction } from "../types/general";
import { CreateDropProtocolArgs, CreateOrAddReturn } from "../types/params";
import { ProtocolReturnedDropConfig } from "../types/protocol";
import { getDropInformation, getUserBalance } from "../views";
import { wrapTxnParamsForTrial } from "./utils";

type AnyWallet = BrowserWalletBehaviour | Wallet;
export const KEY_LIMIT = 50;

/**
 * Creates a new trial account drop which can be used to instantly sign users into decentralized applications that support the Keypom wallet selector plugin.
 *
 * The trial account is locked into certain behaviors depending on what is passed into `createTrialAccountDrop`. These behaviors include callable contracts, methods on
 * those contracts, the maximum amount of $NEAR that can be spent on each contract as well as an exit condition. Once the trial account has run out of funds, the only way to
 * retain any assets from the trial or continue using the account ID, is to repay the specific account ID for the amount of $NEAR specified.
 *
 * @return {Promise<CreateOrAddReturn>} Object containing: the drop ID, the responses of the execution, as well as any auto generated keys (if any).
 *
 * @example
 * Creating a trial account with any callable methods, an amount of 0.5 $NEAR and 5 keys.
 * ```js
 * const {keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}} = await createTrialAccountDrop({
 *     contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *     trialFundsNEAR: 0.5,
 *     callableContracts: ['dev-1676298343226-57701595703433'],
 *     callableMethods: ['*'],
 *     amounts: ['0.5'],
 *     numKeys: 5,
 *     config: {
 *         dropRoot: "linkdrop-beta.keypom.testnet"
 *     }
 * })
 *
 * const newAccountId = `${Date.now().toString()}.linkdrop-beta.keypom.testnet`
 * await claimTrialAccountDrop({
 *     secretKey: trialSecretKeys[0],
 *     desiredAccountId: newAccountId,
 * })
 *
 * console.log(`
 *
 * ${JSON.stringify({
 *     account_id: newAccountId,
 *     public_key: trialPublicKeys[0],
 *     private_key: trialSecretKeys[0]
 * })}
 *
 * `)
 *
 * console.log(`http://localhost:1234/keypom-url/${newAccountId}#${trialSecretKeys[0]}`)
 *
 * ```
 * @group Trial Accounts
 */
export const createTrialAccountDrop = async ({
    account,
    wallet,
    contractBytes,
    startingBalanceNEAR,
    startingBalanceYocto,
    callableContracts,
    maxAttachableNEARPerContract,
    maxAttachableYoctoPerContract,
    callableMethods,
    trialEndFloorNEAR,
    trialEndFloorYocto,
    repayAmountNEAR,
    repayAmountYocto,
    repayTo,
    dropId,
    config = {},
    numKeys = 0,
    publicKeys,
    rootEntropy,
    metadata,
    useBalance = false,
    returnTransactions = false,
    successUrl,
}: {
    /** Account object that if passed in, will be used to sign the txn instead of the funder account. */
    account?: Account;
    /** If using a browser wallet through wallet selector and that wallet should sign the transaction, pass in the object. */
    wallet?: AnyWallet;
    /** Bytes of the trial account smart contract */
    contractBytes: number[];
    /** How much $NEAR should the trial account start with? Unit in $NEAR (i.e `1` = 1 $NEAR) */
    startingBalanceNEAR?: string | number;
    /** How much $NEAR should the trial account start with? Unit in yoctoNEAR (1 yoctoNEAR = 1e-24 $NEAR) */
    startingBalanceYocto?: string;
    /** The contracts that the trial account should be able to call. */
    callableContracts: string[];
    /** The upper bound of $NEAR that trial account is able to attach to calls associated with each contract passed in. For no upper limit, pass in `*`. Units are in $NEAR (i.e `1` = 1 $NEAR). */
    maxAttachableNEARPerContract?: (string | number)[];
    /** The upper bound of $yocto that trial account is able to attach to calls associated with each contract passed in. For no upper limit, pass in `*`. Units are in $yoctoNEAR (i.e `1` = 1 $yoctoNEAR). */
    maxAttachableYoctoPerContract?: string[];
    /** An array that contains the list of methods that the trial account should be able to call on each respective contract. To allow any methods to be called on the receiver contract, pass in `[*]`. */
    callableMethods?: string[][];
    /** Once the account has spent more than this amount (in $NEAR), the trial is over and the exit conditions must be met. */
    trialEndFloorNEAR?: string | number;
    /** Once the account has spent more than this amount (in yocto), the trial is over and the exit conditions must be met. */
    trialEndFloorYocto?: string;
    /** How much $NEAR should be paid back to the specified funder in order to unlock the trial account. Unit in $NEAR (i.e `1` = 1 $NEAR) */
    repayAmountNEAR?: number | string;
    /** How much $NEAR should be paid back to the specified funder in order to unlock the trial account. Unit in yoctoNEAR (1 yoctoNEAR = 1e-24 $NEAR) */
    repayAmountYocto?: string;
    /** The account that should receive the repayment of the trial account. If not specified, the drop funder will be used. */
    repayTo?: string;
    /** Specify a custom drop ID rather than using the incrementing nonce on the contract. */
    dropId?: string;
    /** Allows specific drop behaviors to be configured such as the number of uses each key / link will have. */
    config?: DropConfig;
    /**
     * Specify how many keys should be generated for the drop. If the funder has rootEntropy set OR rootEntropy is passed in, the keys will be
     * deterministically generated using the drop ID, key nonce, and entropy. Otherwise, each key will be generated randomly.
     */
    numKeys: number;
    /** Pass in a custom set of publicKeys to add to the drop. If this is not passed in, keys will be generated based on the numKeys parameter. */
    publicKeys?: string[];
    /** Specify an entropy to use for generating keys (will overload the funder's rootEntropy if applicable). This parameter only matters if the publicKeys variable is not passed in. */
    rootEntropy?: string;
    /** String of metadata to attach to the drop. This can be whatever you would like and is optional. Often this is stringified JSON. */
    metadata?: string;
    /** If the account has a balance within the Keypom contract, set this to true to avoid the need to attach a deposit. If the account doesn't have enough balance, an error will throw. */
    useBalance?: boolean;
    /** If true, the transaction will be returned instead of being signed and sent. This is useful for getting the requiredDeposit from the return value without actually signing the transaction. */
    returnTransactions?: boolean;
    /** When signing with a wallet, a success URl can be included that the user will be redirected to once the transaction has been successfully signed. */
    successUrl?: string;
}): Promise<CreateOrAddReturn> => {
    const {
        near,
        networkId,
        gas,
        attachedGas,
        contractId,
        receiverId,
        getAccount,
        execute,
        fundingAccountDetails,
    } = getEnv();

    assert(
        isValidAccountObj(account),
        "Passed in account is not a valid account object."
    );
    account = await getAccount({ account, wallet });
    assert(
        isSupportedKeypomContract(contractId!) === true,
        "Only the latest Keypom contract can be used to call this methods. Please update the contract."
    );

    // Ensure that if the dropID is passed in, it's greater than 1 billion
    assert(
        parseInt(dropId || "1000000000") >= 1000000000,
        "All custom drop IDs must be greater than 1_000_000_000"
    );
    if (!dropId) dropId = Date.now().toString();

    if (!callableMethods) {
        callableMethods = new Array(callableContracts.length).fill(['*']);
    }
 
    if (!maxAttachableNEARPerContract && !maxAttachableYoctoPerContract) {
        maxAttachableYoctoPerContract = new Array(callableMethods.length).fill('0');
    }

    if (!trialEndFloorNEAR && !trialEndFloorYocto) {
        trialEndFloorYocto = '0';
    }

    // Ensure that the length of the callable methods, contracts, and max attachable deposit per contract are all the same
    assert(
        callableMethods.length === callableContracts.length &&
            callableMethods.length ===
                (maxAttachableNEARPerContract || maxAttachableYoctoPerContract)
                    .length,
        "The length of the callable methods, contracts, and max attachable deposit per contract must all be the same."
    );

    await assertDropIdUnique(dropId);

    const finalConfig: ProtocolReturnedDropConfig = {
        uses_per_key: config?.usesPerKey || 1,
        time: config?.time,
        usage: {
            auto_delete_drop: config?.usage?.autoDeleteDrop || false,
            auto_withdraw: config?.usage?.autoWithdraw || true,
            permissions: config?.usage?.permissions,
            refund_deposit: config?.usage?.refundDeposit,
        },
        sale: config?.sale
            ? {
                  max_num_keys: config?.sale?.maxNumKeys,
                  price_per_key:
                      config?.sale?.pricePerKeyYocto ||
                      config?.sale?.pricePerKeyNEAR
                          ? parseNearAmount(
                                config?.sale?.pricePerKeyNEAR?.toString()
                            )!
                          : undefined,
                  allowlist: config?.sale?.allowlist,
                  blocklist: config?.sale?.blocklist,
                  auto_withdraw_funds: config?.sale?.autoWithdrawFunds,
                  start: config?.sale?.start,
                  end: config?.sale?.end,
              }
            : undefined,
        root_account_id: config?.dropRoot,
    };

    assertValidDropConfig(finalConfig);

    // If there are no publicKeys being passed in, we should generate our own based on the number of keys
    if (!publicKeys) {
        var keys;

        // Default root entropy is what is passed in. If there wasn't any, we should check if the funding account contains some.
        const rootEntropyUsed =
            rootEntropy || fundingAccountDetails?.rootEntropy;
        // If either root entropy was passed into the function or the funder has some set, we should use that.
        if (rootEntropyUsed) {
            // Create an array of size numKeys with increasing strings from 0 -> numKeys - 1. Each element should also contain the dropId infront of the string
            const nonceDropIdMeta = Array.from(
                { length: numKeys },
                (_, i) => `${dropId}_${i}`
            );
            keys = await generateKeys({
                numKeys,
                rootEntropy: rootEntropyUsed,
                metaEntropy: nonceDropIdMeta,
            });
        } else {
            // No entropy is provided so all keys should be fully random
            keys = await generateKeys({
                numKeys,
            });
        }

        publicKeys = keys.publicKeys;
    }

    numKeys = publicKeys!.length;

    /// parse args
    startingBalanceYocto = nearArgsToYocto(
        startingBalanceNEAR,
        startingBalanceYocto
    );
    repayAmountYocto = nearArgsToYocto(repayAmountNEAR, repayAmountYocto);
    trialEndFloorYocto = nearArgsToYocto(trialEndFloorNEAR, trialEndFloorYocto);

    // If max attachable deposit per contract in NEAR is passed in, loop through and convert to yocto
    if (maxAttachableNEARPerContract) {
        maxAttachableYoctoPerContract = maxAttachableNEARPerContract.map(
            (deposit) => {
                if (deposit == "*") return "*";
                return parseNearAmount(deposit.toString()) || "0";
            }
        );
    }
    // If !maxAttachableYoctoPerContract, create an array of the same size as callableMethods and fill it with "*"
    if (!maxAttachableYoctoPerContract)
        maxAttachableYoctoPerContract = Array(callableMethods.length).fill("*");

    const rootReceiverId =
        finalConfig.root_account_id ??
        (networkId == "testnet" ? "testnet" : "near");

    // Account Mapping Contract Changes
    callableContracts.push(accountMappingContract[networkId!]);
    maxAttachableYoctoPerContract.push(parseNearAmount("0.002")!);
    callableMethods.push(["set"]);

    // Take the storage cost into consideration for the attached deposit and trial end floor
    const storageCost = parseNearAmount("0.3")!;
    const attachedDeposit = new BN(startingBalanceYocto)
        .add(new BN(storageCost))
        .toString();
    trialEndFloorYocto = new BN(attachedDeposit)
        .sub(new BN(trialEndFloorYocto))
        .toString();

    // Generate the proper args for setup:
    let actualContracts = callableContracts.join(",");
    let actualAmounts = maxAttachableYoctoPerContract.join(",");
    let actualMethods = callableMethods
        .map((method) => method.join(":"))
        .join(",");

    const createDropArgs: CreateDropProtocolArgs = {
        drop_id: dropId,
        public_keys: publicKeys || [],
        deposit_per_use: "0",
        config: finalConfig,
        metadata,
        required_gas: "150000000000000",
        fc: {
            methods: [
                [
                    {
                        receiver_id: rootReceiverId,
                        method_name: "create_account_advanced",
                        //@ts-ignore
                        attached_deposit: attachedDeposit,
                        args: JSON.stringify({
                            new_account_id: "INSERT_NEW_ACCOUNT",
                            options: {
                                contract_bytes: contractBytes,
                                limited_access_keys: [
                                    {
                                        public_key: "INSERT_TRIAL_PUBLIC_KEY",
                                        allowance: "0",
                                        receiver_id: "INSERT_NEW_ACCOUNT",
                                        method_names:
                                            "execute,create_account_and_claim",
                                    },
                                ],
                            },
                        }),
                        user_args_rule: "UserPreferred",
                    },
                    {
                        receiver_id: "",
                        method_name: "setup",
                        //@ts-ignore
                        attached_deposit: "0",
                        args: JSON.stringify(
                            wrapTxnParamsForTrial({
                                contracts: actualContracts,
                                amounts: actualAmounts,
                                methods: actualMethods,
                                funder: repayTo || account!.accountId,
                                repay: repayAmountYocto,
                                floor: trialEndFloorYocto,
                            })
                        ),
                        receiver_to_claimer: true,
                    },
                ],
            ],
        },
    };

    const fcData: FCData = {
        methods: [
            [
                {
                    receiverId: rootReceiverId,
                    methodName: "create_account_advanced",
                    //@ts-ignore
                    attachedDeposit,
                    args: JSON.stringify({
                        new_account_id: "INSERT_NEW_ACCOUNT",
                        options: {
                            contract_bytes: contractBytes,
                            limited_access_keys: [
                                {
                                    public_key: "INSERT_TRIAL_PUBLIC_KEY",
                                    allowance: "0",
                                    receiver_id: "INSERT_NEW_ACCOUNT",
                                    method_names:
                                        "execute,create_account_and_claim",
                                },
                            ],
                        },
                    }),
                    userArgsRule: "UserPreferred",
                },
                {
                    receiverId: "",
                    methodName: "setup",
                    //@ts-ignore
                    attachedDeposit: "0",
                    args: JSON.stringify(
                        wrapTxnParamsForTrial({
                            contracts: actualContracts,
                            amounts: actualAmounts,
                            methods: actualMethods,
                            funder: repayTo || account!.accountId,
                            repay: repayAmountYocto,
                            floor: trialEndFloorYocto,
                        })
                    ),
                    receiverToClaimer: true,
                },
            ],
        ],
    };

    /// estimate required deposit
    const storageCalculated = getStorageBase(createDropArgs);
    let requiredDeposit = await estimateRequiredDeposit({
        near: near!,
        depositPerUse: "0",
        numKeys,
        usesPerKey: finalConfig.uses_per_key || 1,
        attachedGas: parseInt(attachedGas!),
        storage: storageCalculated,
        fcData,
    });

    var hasBalance = false;
    if (useBalance) {
        let userBal = await getUserBalance({ accountId: account!.accountId });
        if (userBal < requiredDeposit) {
            throw new Error(
                `Insufficient balance on Keypom to create drop. Use attached deposit instead.`
            );
        }

        hasBalance = true;
    }

    const deposit = !hasBalance ? requiredDeposit : "0";

    const pk = await account.connection.signer.getPublicKey(account.accountId, account.connection.networkId);
    const txnInfo: BasicTransaction = {
        receiverId,
        signerId: account!.accountId, // We know this is not undefined since getAccount throws
        actions: [
            {
                enum: "FunctionCall",
                functionCall: {
                    methodName: "create_drop",
                    args: stringifyJsonOrBytes(createDropArgs),
                    gas: gas!,
                    deposit,
                }
            },
        ],
    }
    const transactions = [await convertBasicTransaction({txnInfo, signerId: account!.accountId, signerPk: pk})];

    if (returnTransactions) {
        return { keys, dropId, transactions, requiredDeposit };
    }

    let responses = await execute({
        transactions,
        account,
        wallet,
        successUrl,
    });

    return { responses, keys, dropId, requiredDeposit };
};

/**
 * Claim a Keypom trial account drop which will create a new account, deploy and initialize the trial account contract, and setup the account with initial conditions as specified in the drop.
 *
 * @example
 * Creating a trial account with any callable methods, an amount of 0.5 $NEAR and 5 keys.
 * ```js
 * const callableContracts = [
 * 	`v1.social08.testnet`,
 * 	'guest-book.examples.keypom.testnet',
 * ]
 *
 * const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 * = await createTrialAccountDrop({
 * 	numKeys: 1,
 * 	contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 * 	startingBalanceNEAR: 0.5,
 * 	callableContracts: callableContracts,
 * 	callableMethods: ['set:grant_write_permission', '*'],
 * 	maxAttachableNEARPerContract: callableContracts.map(() => '1'),
 * 	trialEndFloorNEAR: 0.33
 * })
 *
 * const newAccountId = `${Date.now().toString()}.linkdrop-beta.keypom.testnet`
 * await claimTrialAccountDrop({
 *     secretKey: trialSecretKeys[0],
 *     desiredAccountId: newAccountId,
 * })
 *
 * console.log(`
 *
 * ${JSON.stringify({
 *     account_id: newAccountId,
 *     public_key: trialPublicKeys[0],
 *     private_key: trialSecretKeys[0]
 * })}
 *
 * `)
 *
 * console.log(`http://localhost:1234/keypom-url/${newAccountId}#${trialSecretKeys[0]}`)
 *
 * ```
 * @group Trial Accounts
 */
export const claimTrialAccountDrop = async ({
    secretKey,
    desiredAccountId,
}: {
    /** The private key associated with the Keypom link. This can either contain the `ed25519:` prefix or not. */
    secretKey: string;
    /** The account ID that will be created for the trial */
    desiredAccountId: string;
}) => {
    const {
        networkId,
        keyStore,
        contractId,
        contractAccount,
        receiverId,
        execute
    } = getEnv();

    const keyPair = KeyPair.fromString(secretKey);
    const pubKey = keyPair.getPublicKey().toString();
    await keyStore!.setKey(networkId!, contractId!, keyPair);

    const dropInfo = await getDropInformation({ secretKey });
    assert(dropInfo.fc !== undefined, "drop must be a trial account drop");
    const attachedGas = dropInfo.required_gas;

    let userFcArgs = {
        INSERT_NEW_ACCOUNT: desiredAccountId,
        INSERT_TRIAL_PUBLIC_KEY: pubKey,
    };
 
    const txn = await convertBasicTransaction({
        txnInfo: {
            receiverId,
            signerId: receiverId,
            actions: [
                {
                    enum: "FunctionCall",
                    functionCall: {
                        methodName: "claim",
                        args: stringifyJsonOrBytes({
                            account_id: desiredAccountId,
                            fc_args: [JSON.stringify(userFcArgs), null],
                        }),
                        gas: attachedGas,
                        deposit: '0',
                    }
                },
            ],
        },
        signerId: receiverId,
        signerPk: keyPair.getPublicKey(),
    })

    const transactions: Transaction[] = [txn];

    const result = await execute({ transactions, account: contractAccount });

    return result;
};

'''
'''--- packages/core/src/lib/trial-accounts/trial-active.ts ---
import { FinalExecutionOutcome, Transaction } from "@near-wallet-selector/core";
//import { KeyPair } from "near-api-js";
import { getEnv } from "../keypom";
import { createTransactions } from "../keypom-utils";
import {
	estimateTrialGas,
	generateExecuteArgs,
	hasEnoughBalance,
	TRIAL_ERRORS,
	validateDesiredMethods
} from "./utils";
import { KeyPair } from "@near-js/crypto";
import { stringifyJsonOrBytes } from "@near-js/transactions";

/**
 * Execute a transaction that can contain multiple actions using a trial account. If the trial account is in the exit state, this will throw an error. Similarly, if any action
 * cannot be executed by the trial account (e.g. the attached deposit exceeds the trial account's restrictions), this will throw an error.
 *
 * @returns {Promise<FinalExecutionOutcome[]>} The outcomes of the transactions
 *
 * @example
 * Use a Trial Account to min2
 * ```js
 * await initKeypom({
 *        // near,
 *        network: 'testnet',
 *        funder: {
 *            accountId: fundingAccountId,
 *            secretKey: fundingAccountSecretKey,
 *        }
 *    });
 *
 *    const callableContracts = [
 *        `nft.examples.testnet`
 *    ]
 *
 *    const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 *    = await createTrialAccountDrop({
 *        numKeys: 1,
 *        contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *        startingBalanceNEAR: 0.5,
 *        callableContracts: callableContracts,
 *        callableMethods: ['*'],
 *        maxAttachableNEARPerContract: [1],
 *        trialEndFloorNEAR: 0.33 + 0.3
 *    })
 *
 *    const desiredAccountId = `${dropId}-keypom.testnet`
 *    const trialSecretKey = trialSecretKeys[0]
 *    await claimTrialAccountDrop({
 *        desiredAccountId,
 *        secretKey: trialSecretKeys[0],
 *    })
 *
 *    console.log('desiredAccountId: ', desiredAccountId)
 *    console.log(`trialSecretKey: ${JSON.stringify(trialSecretKey)}`)
 *    const txns = [{
 *        receiverId: callableContracts[0],
 *        actions: [
 *            {
 *                type: 'FunctionCall',
 *                params: {
 *                    methodName: 'nft_mint',
 *                    args: {
 *                        token_id: 'tokenId-keypom-1',
 *                        receiver_id: 'foo.testnet',
 *                        metadata: {
 *                            title: 'test1',
 *                            description: 'test1',
 *                            media: 'test1',
 *                        }
 *                    },
 *                    gas: '30000000000000',
 *                    deposit: parseNearAmount('0.1')
 *                },
 *            },
 *            {
 *                type: 'FunctionCall',
 *                params: {
 *                    methodName: 'nft_mint',
 *                    args: {
 *                        token_id: 'tokenId-keypom-2',
 *                        receiver_id: 'foo.testnet',
 *                        metadata: {
 *                            title: 'test2',
 *                            description: 'test2',
 *                            media: 'test2',
 *                        }
 *                    },
 *                    gas: '30000000000000',
 *                    deposit: parseNearAmount('0.1')
 *                },
 *            },
 *        ],
 *    }];
 *
 *    await trialSignAndSendTxns({
 *        trialAccountId: desiredAccountId,
 *        trialAccountSecretKey: trialSecretKey,
 *        txns
 *    })
 * ```
 *
 * @group Trial Accounts
 */
export const trialSignAndSendTxns = async ({
    trialAccountId,
    trialAccountSecretKey,
    txns,
}: {
    /** The trial account ID to use */
    trialAccountId: string;
    /** The trial account secret key to use */
    trialAccountSecretKey: string;
    /** The transactions to execute */
    txns: Transaction[];
}): Promise<FinalExecutionOutcome[]> => {
    const { near, keyStore, networkId } = getEnv();
    const exitExpected = await canExitTrial({ trialAccountId });
    if (exitExpected == true) {
        throw TRIAL_ERRORS.EXIT_EXPECTED;
    }

    const {
        methodDataToValidate,
        executeArgs,
        totalAttachedYocto,
        totalGasForTxns,
    } = await generateExecuteArgs({ desiredTxns: txns });

    const isValidTxn = await validateDesiredMethods({
        methodData: methodDataToValidate,
        trialAccountId,
    });
    console.log("isValidTxn: ", isValidTxn);

    if (isValidTxn == false) {
        throw TRIAL_ERRORS.INVALID_ACTION;
    }

    const hasBal = await hasEnoughBalance({
        trialAccountId,
        totalAttachedYocto,
        totalGasForTxns,
    });
    if (hasBal == false) {
        throw TRIAL_ERRORS.INSUFFICIENT_BALANCE;
    }

    const trialKeyPair = KeyPair.fromString(trialAccountSecretKey);
    const pubKey = trialKeyPair.getPublicKey();
    await keyStore!.setKey(networkId!, trialAccountId, trialKeyPair);
    const account = await near!.account(trialAccountId);

    const gasToAttach = estimateTrialGas({ executeArgs });
    const transformedTransactions = await createTransactions({
        signerId: trialAccountId,
        signerPk: pubKey,
        txnInfos: [
            {
                receiverId: account.accountId,
                signerId: trialAccountId,
                actions: [
                    {
                        enum: "FunctionCall",
                        functionCall: {
                            methodName: "execute",
                            args: stringifyJsonOrBytes(executeArgs),
                            gas: gasToAttach,
                            deposit: '0',
                        }
                    },
                ],
            },
        ],
    });
    console.log("debugging");
    console.log("transformedTransactions: ", transformedTransactions);

    const promises = transformedTransactions.map((tx) =>
        (account as any).signAndSendTransaction(tx)
    );
    return (await Promise.all(promises)) as FinalExecutionOutcome[];
};

/**
 * Execute a method using a trial account. If the trial account is in the exit state, this will throw an error. Similarly, if the given method data
 * cannot be executed by the trial account (e.g. the attached deposit exceeds the trial account's restrictions), this will throw an error.
 *
 * @returns {Promise<FinalExecutionOutcome[]>} The outcome of the transaction
 *
 * @example
 * Using a trial account to mint a new NFT:
 * ```js
 *     await initKeypom({
 *		network: 'testnet',
 *		funder: {
 *			accountId: fundingAccountId,
 *			secretKey: fundingAccountSecretKey,
 *		}
 *	});
 *
 *    const callableContracts = [
 *        `nft.examples.testnet`
 *    ]
 *
 *    const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 *    = await createTrialAccountDrop({
 *        numKeys: 1,
 *        contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *        startingBalanceNEAR: 0.5,
 *        callableContracts: callableContracts,
 *        callableMethods: ['*'],
 *        maxAttachableNEARPerContract: [1],
 *        trialEndFloorNEAR: 0.33 + 0.3
 *    })
 *
 *    const desiredAccountId = `${dropId}-keypom.testnet`
 *    const trialSecretKey = trialSecretKeys[0]
 *    await claimTrialAccountDrop({
 *        desiredAccountId,
 *        secretKey: trialSecretKeys[0],
 *    })
 *
 *    console.log('desiredAccountId: ', desiredAccountId)
 *    console.log(`trialSecretKey: ${JSON.stringify(trialSecretKey)}`)
 *
 *    await trialCallMethod({
 *        trialAccountId: desiredAccountId,
 *        trialAccountSecretKey: trialSecretKey,
 *        contractId: callableContracts[0],
 *        methodName: 'nft_mint',
 *        args: {
 *            token_id: 'asdkasldkjasdlkajsldajsldaskjd',
 *            receiver_id: 'foo.testnet',
 *            metadata: {
 *                title: 'test',
 *                description: 'test',
 *                media: 'test',
 *            }
 *        },
 *        attachedDeposit: parseNearAmount('0.1'),
 *        attachedGas: '30000000000000',
 *    })
 * ```
 * @group Trial Accounts
 */
export const trialCallMethod = async ({
    trialAccountId,
    trialAccountSecretKey,
    contractId,
    methodName,
    args,
    attachedGas,
    attachedDeposit,
}: {
    /** The account ID of the trial account */
    trialAccountId: string;
    /** The secret key of the trial account */
    trialAccountSecretKey: string;
    /** The contract ID of the contract to call */
    contractId: string;
    /** The method name to call */
    methodName: string;
    /** The arguments to pass to the method */
    args: Object;
    /** The amount of gas to attach to the transaction */
    attachedGas: string;
    /** The amount of NEAR to attach to the transaction */
    attachedDeposit: string;
}) => {
    const { near, keyStore, networkId } = getEnv();
    const exitExpected = await canExitTrial({ trialAccountId });
    if (exitExpected == true) {
        throw TRIAL_ERRORS.EXIT_EXPECTED;
    }

    const trialKeyPair = KeyPair.fromString(trialAccountSecretKey);
    const pubKey = trialKeyPair.getPublicKey();
    await keyStore!.setKey(networkId!, trialAccountId, trialKeyPair);
    const account = await near!.account(trialAccountId);

    const txns: Transaction[] = [{
        signerId: trialAccountId,
		receiverId: contractId,
		actions: [
			{
				type: 'FunctionCall',
				params: {
					methodName,
					args,
					gas: attachedGas,
					deposit: attachedDeposit
				},
			},
		],
	}];

    console.log(`txns: ${JSON.stringify(txns)}`);

    const {
        methodDataToValidate,
        executeArgs,
        totalAttachedYocto,
        totalGasForTxns,
    } = await generateExecuteArgs({ desiredTxns: txns });

    const isValidTxn = await validateDesiredMethods({
        methodData: methodDataToValidate,
        trialAccountId,
    });
    console.log("isValidTxn: ", isValidTxn);

    if (isValidTxn == false) {
        throw TRIAL_ERRORS.INVALID_ACTION;
    }

    const hasBal = await hasEnoughBalance({
        trialAccountId,
        totalAttachedYocto,
        totalGasForTxns,
    });
    if (hasBal == false) {
        throw TRIAL_ERRORS.INSUFFICIENT_BALANCE;
    }

    const gasToAttach = estimateTrialGas({ executeArgs });
    const transformedTransactions = await createTransactions({
        signerId: trialAccountId,
        signerPk: pubKey,
        txnInfos: [
            {
                receiverId: account.accountId,
                signerId: trialAccountId,
                actions: [
                    {
                        enum: "FunctionCall",
                        functionCall: {
                            methodName: "execute",
                            args: stringifyJsonOrBytes(executeArgs),
                            gas: gasToAttach,
                            deposit: '0',
                        }
                    },
                ],
            },
        ],
    });
    console.log("debugging");
    console.log("transformedTransactions: ", transformedTransactions);

    const promises = transformedTransactions.map((tx) =>
        (account as any).signAndSendTransaction(tx)
    );
    return (await Promise.all(promises)) as FinalExecutionOutcome[];
};

/**
 * Check whether a trial account is able to exit their trial state and become a fully fledged normal account.
 *
 * @example
 * Create a trial account and check whether it can immediately exit
 * ```js
 *     await initKeypom({
 *        // near,
 *        network: 'testnet',
 *        funder: {
 *            accountId: fundingAccountId,
 *            secretKey: fundingAccountSecretKey,
 *        }
 *    });
 *
 *    const callableContracts = [
 *        `nft.examples.testnet`
 *    ]
 *
 *    const {dropId, keys: {secretKeys: trialSecretKeys, publicKeys: trialPublicKeys}}
 *    = await createTrialAccountDrop({
 *        numKeys: 1,
 *        contractBytes: [...readFileSync('./test/ext-wasm/trial-accounts.wasm')],
 *        startingBalanceNEAR: 0.5,
 *        callableContracts: callableContracts,
 *        callableMethods: ['*'],
 *        maxAttachableNEARPerContract: [1],
 *        trialEndFloorNEAR: 0.33 + 0.3
 *    })
 *
 *    const desiredAccountId = `${dropId}-keypom.testnet`
 *    const trialSecretKey = trialSecretKeys[0]
 *    await claimTrialAccountDrop({
 *        desiredAccountId,
 *        secretKey: trialSecretKey
 *    })
 *
 *    const canExitTrial = await keypom.canExitTrial({
 *        trialAccountId: desiredAccountId
 *    })
 *    console.log('canExitTrial: ', canExitTrial)
 *	```
 *
 * @group Trial Accounts
 */
export const canExitTrial = async ({
    trialAccountId,
}: {
    /** The account ID of the trial account */
    trialAccountId: string;
}) => {
    const { viewCall } = getEnv();

    try {
        const keyInfo = await viewCall({
            contractId: trialAccountId,
            methodName: "get_key_information",
            args: {},
        });
        console.log(`keyInfo: `, keyInfo);

        const rules = await viewCall({
            contractId: trialAccountId,
            methodName: "get_rules",
            args: {},
        });
        console.log("rules: ", rules);

        return keyInfo.trial_data.exit == true;
    } catch (e: any) {
        console.log("error: ", e);
    }

    return false;
};

'''
'''--- packages/core/src/lib/trial-accounts/utils.ts ---
import BN from "bn.js";
import { Transaction } from "@near-wallet-selector/core";
import { getEnv } from "../keypom";
import { getKeyInformation } from "../views";
import { Account } from "@near-js/accounts";

// helpers for keypom account contract args
const RECEIVER_HEADER = "|kR|";
const ACTION_HEADER = "|kA|";
const PARAM_START = "|kP|";
const PARAM_STOP = "|kS|";

export const TRIAL_ERRORS = {
    EXIT_EXPECTED: "exit",
    INVALID_ACTION: "invalid_action",
    INSUFFICIENT_BALANCE: "insufficient_balance",
};

export const validateDesiredMethods = async ({
    methodData,
    trialAccountId,
}: {
    methodData: {
        receiverId: string;
        methodName: string;
        deposit: string;
    }[];
    trialAccountId: string;
}) => {
    const { viewCall } = getEnv();

    let validInfo = {};
    try {
        const rules = await viewCall({
            contractId: trialAccountId,
            methodName: "get_rules",
            args: {},
        });
        let contracts = rules.contracts.split(",");
        let amounts = rules.amounts.split(",");
        let methods = rules.methods.split(",");

        for (let i = 0; i < contracts.length; i++) {
            validInfo[contracts[i]] = {
                maxDeposit: amounts[i],
                allowableMethods:
                    methods[i] == "*" ? "*" : methods[i].split(":"),
            };
        }
    } catch (e: any) {
        console.log("error: ", e);
    }
    console.log("validInfo after view calls: ", validInfo);

    // Loop through each transaction in the array
    for (let i = 0; i < methodData.length; i++) {
        const method = methodData[i];
        console.log("method: ", method);

        const validInfoForReceiver = validInfo[method.receiverId];
        console.log("validInfoForReceiver: ", validInfoForReceiver);
        // Check if the contractId is valid
        if (!validInfoForReceiver) {
            console.log(
                "!validInfo[transaction.receiverId]: ",
                !validInfo[method.receiverId]
            );
            return false;
        }

        // Check if the method name is valid
        if (
            validInfoForReceiver.allowableMethods != "*" &&
            !validInfoForReceiver.allowableMethods.includes(method.methodName)
        ) {
            console.log(
                "!validInfo[transaction.receiverId].allowableMethods.includes(transaction.methodName): ",
                !validInfo[method.receiverId].allowableMethods.includes(
                    method.methodName
                )
            );
            return false;
        }

        // Check if the deposit is valid
        if (
            validInfoForReceiver.maxDeposit != "*" &&
            new BN(method.deposit).gt(new BN(validInfoForReceiver.maxDeposit))
        ) {
            console.log(
                "new BN(transaction.deposit).gt(new BN(validInfo[transaction.receiverId].maxDeposit)): ",
                new BN(method.deposit).gt(
                    new BN(validInfo[method.receiverId].maxDeposit)
                )
            );
            return false;
        }
    }

    return true;
};

export const wrapTxnParamsForTrial = (params, newParams = {}) => {
    Object.entries(params).forEach(([k, v]) => {
        if (k === "args" && typeof v !== "string") {
            v = JSON.stringify(v);
        }
        if (Array.isArray(v)) v = v.join();
        newParams[PARAM_START + k] = v + PARAM_STOP;
    });
    return newParams;
};

export const generateExecuteArgs = ({
    desiredTxns,
}: {
    /** The transactions to execute */
    desiredTxns: Transaction[];
}) => {
    const methodDataToValidate: any = [];
    let totalGasBN = new BN(0);
    let totalDepositsBN = new BN(0);
    const executeArgs: any = {
        transactions: [],
    };

    desiredTxns.forEach((tx) => {
        const newTx: any = {};
        newTx[RECEIVER_HEADER] =  tx.receiverId;
        newTx.actions = [];
        console.log("newTx: ", newTx);

        tx.actions.forEach((action) => {
            console.log('action: ', action)
            if (action.type !== "FunctionCall") {
                throw new Error("Only FunctionCall actions are supported");
            }
            
            methodDataToValidate.push({
                receiverId: tx.receiverId,
                methodName: action.params.methodName,
                deposit: action.params.deposit
            })
			totalGasBN = totalGasBN.add(new BN(action.params.gas))
			totalDepositsBN = totalDepositsBN.add(new BN(action.params.deposit))

            const newAction: any = {}
            console.log('newAction 1: ', newAction)
            newAction[ACTION_HEADER] = action.type
            console.log('newAction 2: ', newAction)
            newAction.params = wrapTxnParamsForTrial(action.params)
            console.log('newAction 3: ', newAction)
            newTx.actions.push(newAction)
        })
        executeArgs.transactions.push(newTx);
    });
    return {
        totalAttachedYocto: totalDepositsBN.toString(),
        totalGasForTxns: totalGasBN.toString(),
        executeArgs,
        methodDataToValidate,
    };
};

export const estimateTrialGas = ({
    executeArgs,
}: {
    executeArgs: {
        transactions: {
            "|kR|": string;
            /** The actions to execute */
            actions: {
                /** The type of action to execute */
                "|kA|": "FunctionCall";
                /** The parameters for the action */
                params: {
                    /** The method name to execute */
                    "|kP|methodName": string;
                    /** The arguments to pass to the method */
                    "|kP|args": string;
                    /** The amount of gas to attach to the transaction */
                    "|kP|gas": string;
                    /** The amount of NEAR to attach to the transaction */
                    "|kP|deposit": string;
                };
            }[];
        }[];
    };
}) => {
    let transactions = executeArgs.transactions;
    let incomingGas = new BN("0");
    let numActions = 0;
    try {
        for (let i = 0; i < transactions.length; i++) {
            let transaction = transactions[i];
            console.log("transaction in gas loop: ", transaction);
            for (let j = 0; j < transaction.actions.length; j++) {
                let action = transaction.actions[j];
                console.log("action in gas loop: ", action);
                let gasToAdd = action.params["|kP|gas"]
                    .split(`|kS|`)[0]
                    .toString();
                console.log("gasToAdd: ", gasToAdd);
                incomingGas = incomingGas.add(new BN(gasToAdd));
                numActions += 1;
            }
        }
    } catch (e) {
        numActions = 1;
        console.log("e: ", e);
        incomingGas = new BN(`300000000000000`);
    }

    console.log("incomingGas: ", incomingGas.toString());
    // Take 15 TGas as a base for loading rules as well as 20 TGas for the callback.
    // For each action, add 15 TGas on top of that and then add the final incoming gas on top.
    let gasToAttach = new BN("15000000000000") // Loading rules
        .add(new BN("20000000000000")) // Callback
        .add(new BN("15000000000000").mul(new BN(numActions))) // Actions
        .add(incomingGas)
        .toString(); // Incoming gas

    // check if the gas to attach is over 300 TGas and if it is, clamp it
    if (new BN(gasToAttach).gt(new BN("300000000000000"))) {
        console.log("gas to attach is over 300 TGas. Clamping it");
        gasToAttach = "300000000000000";
    }

    return gasToAttach;
};

export const isUnclaimedTrialDrop = async ({ keypomContractId, secretKey }) => {
    console.log("accountId is valid keypom contract ", keypomContractId);
    const keyInfo = await getKeyInformation({
        secretKey,
    });
    console.log("keyInfo: ", keyInfo);

    if (keyInfo !== null) {
        return true;
    }

    return false;
};

export const hasEnoughBalance = async ({
    trialAccountId,
    totalGasForTxns,
    totalAttachedYocto,
}: {
    trialAccountId: string;
    totalGasForTxns: string;
    totalAttachedYocto: string;
}) => {
    const { near } = getEnv();

    const trialAccountObj = new Account(near!.connection, trialAccountId);
    const accountState = await trialAccountObj.state();

    const storageCostPerByte = new BN("10000000000000000000");
    const totalStorage = new BN(accountState.storage_usage).mul(
        storageCostPerByte
    );
    let availAmount = new BN(accountState.amount).sub(totalStorage);

    const yoctoPerGas = 100000000;
    let gasCost = new BN(totalGasForTxns).mul(new BN(yoctoPerGas));
    let totalCost = gasCost.add(new BN(totalAttachedYocto));

    return availAmount.gte(totalCost);
};

'''
'''--- packages/core/src/lib/types/drops.ts ---
import { FCData } from "./fc";
import { FTData } from "./ft";
import { NFTData } from "./nft";
import { SimpleData } from "./simple";

/**
 * Important information returned in many view calls regarding a specific access key.
 */
export interface KeyInfo {
    /** Drop ID for the specific drop that the key belongs to. */
    dropId: string;
    /** Public key for this access key. */
    publicKey: string;

    /** Which use is the key currently on? For single-use keys, this is always 1.  */
    curKeyUse: number;

    /** How many uses this key has left before it's deleted.  */
    remainingUses: number;

    /** At what timestamp was the key last used? Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC. */
    lastUsed: number;

    /** How much allowance does the key have left (measured in $yoctoNEAR). When the key is deleted, this is refunded to the funder's balance. */
    allowance: number;

    /** The unique ID associated to this key. IDs are *not* unique across drops but they are unique for any key in the drop. */
    keyId: number;
}

/**
 * Information related to a specific drop.
 */
export interface Drop {
    /** Drop ID for this specific drop. */
    dropId: string;
    /** Which account created this drop. */
    ownerId: string;
    /** How much $yoctoNEAR will be transferred anytime a key is used that is part of this drop. */
    depositPerUse: string;
    /** For simple drops, there are specific, optional configurations. */
    simple?: SimpleData;
    /** For NFT drops, important information such as the token IDs, or contract need to be stored. */
    nft?: NFTData;
    /** For Fungible Token drops, important information such as the amount of tokens to transfer, or contract need to be stored. */
    ft?: FTData;
    /** For Function-Call drops, important information needs to be stored such as which methods, the attached deposit, args etc. */
    fc?: FCData;
    /** All drops regardless of their type can have a suite of configurations such as how many uses each key has or how often a key can be used. */
    config?: DropConfig;
    /** Any extra information about the drop can be stored as metadata. This is up to the drop creator and can be stringified JSON, or any other string. */
    metadata?: string;
    /** How many key uses are registered for this drop? This is only applicable to simple drops with lazy registrations, FT drops, and NFT drops. */
    registeredUses: number;
    /** In order to use an access key that's part of this drop, how much Gas *needs* to be attached to the call? */
    requiredGas: string;
    /** What is the next unique ID that will be given to the next access key added to this drop. */
    nextKeyId: number;
}

/**
 * Configurable options for any drop regardless of type.
 */
export interface DropConfig {
    /** How many uses can each key have before it's deleted. If this isn't specified, it defaults to 1 use per key. */
    usesPerKey?: number;

    /** Any information related to time-based configurations such as a starting date for keys etc. */
    time?: TimeConfig;

    /** Any information related to how access keys are used such as which methods they can call or whether an empty drop should be automatically deleted etc.*/
    usage?: UsageConfig;

    /** Any information related to primary market sales for access keys added to this drop.*/
    sale?: PublicSaleConfig;

    /** Override the global root account that all created sub-accounts will have (currently `near` or `testnet`). This allows users to drops that have a custom root.
     * For example, Fayyr could specify a root of `fayyr.near` By which all sub-accounts will then be `ACCOUNT.fayyr.near`.
     * It's important to note that this root account *MUST* have a smart contract deployed that has a method `create_account`.
     */
    dropRoot?: string;
}

/**
 * Within the config, there are configurable options related to timing such as how often a key can be used.
 */
export interface TimeConfig {
    /**
     * Minimum block timestamp before keys can be used. If this isn't specified, keys can be used immediately.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    start?: number;

    /**
     * Block timestamp that keys must be used before. If this isn't specified, keys can be used indefinitely.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    end?: number;

    /**
     * Amount of time that *must* pass in between each key use. If this isn't specified, there is no delay between key uses.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    throttle?: number;

    /**
     * Interval of time after the `start_timestamp` that must pass before a key can be used. If multiple intervals pass, the key can be used multiple times.
     * This has nothing to do With the throttle timestamp. It only pertains to the start timestamp and the current timestamp. The last_used timestamp is not taken into account.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    interval?: number;
}

/**
 * Within the config, there are configurable options related to how keys can be used. What permissions they have, whether an empty drop should be automatically deleted etc.
 */
export interface UsageConfig {
    /**
     * Specify which methods can be called by the access key (either `claim` or `create_account_and_claim`). If this isn't specified, both methods can be called.
     */
    permissions?: string;
    /**
     * If the method `claim` is called rather than `create_account_and_claim`, should the `deposit_per_use` be refunded to the owner's balance?
     * If this isn't specified, it defaults to false.
     */
    refundDeposit?: boolean;
    /**
     * When a key is used and deleted, if it results in the drop being empty, should the drop automatically be deleted? If this isn't specified, it defaults to false.
     */
    autoDeleteDrop?: boolean;
    /**
     * When the last key in this drop is used, in the case where `autoDeleteDrop` is set to true and the drop is the owner's last, should their balance be automatically withdrawn? If this isn't specified, it defaults to false.
     */
    autoWithdraw?: boolean;
    /** When calling `create_account` on the root account, which keypom args should be attached to the payload. */
    accountCreationFields?: {
        /**
         * Specifies what field Keypom should auto-inject the account that claimed the drop's ID into when calling the `create_account` function.
         */
        accountIdField?: string;
        /**
         * Specifies what field Keypom should auto-inject the drop's ID into when calling the `create_account` function.
         */
        dropIdField?: string;
        /**
         * Specifies what field Keypom should auto-inject the key's ID into when calling the `create_account` function.
         */
        keyIdField?: string;
        /**
         * Specifies what field Keypom should auto-inject the drop funder's account ID into when calling the `create_account` function.
         */
        funderIdField?: string;
    };
}

/**
 * Within the config, there are configurable options related to how keys can be sold and a funder can potentially make a profit.
 */
export interface PublicSaleConfig {
    /** Maximum number of keys that can be added to this drop. If None, there is no max. */
    maxNumKeys?: number;
    /**
     * Amount of $NEAR that the user needs to attach (if they are not the funder) on top of costs. This amount will be
     * Automatically sent to the funder's balance. If None, the keys are free to the public.
     */
    pricePerKeyNEAR?: number;
    pricePerKeyYocto?: string;
    /** Which accounts are allowed to add keys? If the allowlist is empty, anyone that is not in the blocklist can add keys. */
    allowlist?: string[];
    /** Which accounts are NOT allowed to add keys? */
    blocklist?: string[];
    /**
     * Should the revenue generated be sent to the funder's account balance or
     * automatically withdrawn and sent to their NEAR wallet?
     */
    autoWithdrawFunds?: boolean;
    /**
     * Minimum block timestamp before the public sale starts. If None, keys can be added immediately
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    start?: number;
    /**
     * Block timestamp dictating the end of the public sale. If None, keys can be added indefinitely
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    end?: number;
}

/**
 * Keeps track of the password for a given key use. This should be passed in as an array for each key that has passwords.
 */
export interface PasswordPerUse {
    /** The password for this given use */
    pw: string;
    /** Which use does the password belong to? These uses are *NOT* zero-indexed so the first use corresponds to `1` not `0`. */
    key_use: number;
}

'''
'''--- packages/core/src/lib/types/fc.ts ---
import { Maybe } from "../keypom";

/**
 * Outlines the information needed for any given method as part of a Function-Call drop.
 * Each individual key use can have an array of Methods that can be called.
 */
export interface Method {
    /**
     * The account ID that the contract is deployed to that the method will be called on.
     */
    receiverId: string;
    /**
     * The method that should be invoked on the `receiverId`'s contract.
     */
    methodName: string;
    /**
     * What arguments should be passed to the method. This should be in stringified JSON.
     */
    args: string;
    /**
     * How much yoctoNEAR should be attached to the call.
     */
    attachedDeposit: string;
    /**
     * How much gas to attach to this method call. If none, all the gas is split between the parallel method calls in a given claim.
     * If this is specified, the key can ONLY be used to call `claim` and no `deposit_per_use` can be specified. This leads the key to act like a method calling proxy instead of a linkdrop.
     */
    attachedGas?: string;
    /**
     * Specifies what field Keypom should auto-inject the account that claimed the drop's ID into when calling the function.
     * As an example, if the methodName was `nft_mint` and it expected a field `receiver_id` to be passed in, indicating who should receive the token, then the `accountIdField` would be `receiver_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    accountIdField?: string;
    /**
     * Specifies what field Keypom should auto-inject the drops ID into when calling the function.
     * As an example, if an NFT contract expected the Keypom drop ID to be passed in as the field `keypom_drop_id` in order to gate access to who can mint NFTs, then the `dropIdField` would be `keypom_drop_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    dropIdField?: string;
    /**
     * Specifies what field Keypom should auto-inject the key's ID into when calling the function.
     * As an example, if an NFT contract wanted to gate only users with an odd key ID to be able to mint an NFT and their parameter was called `keypom_key_id`, then the `keyIdField` would be `keypom_key_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    keyIdField?: string;
    /**
     * Specifies what field Keypom should auto-inject the drop funder's account ID into when calling the function.
     * As an example, if an NFT contract wanted to gate only users that had a key coming from a specific funder's drops, it could expect a field called `keypom_funder_id` and the `funderIdField` would be `keypom_funder_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    funderIdField?: string;
    /**
     * If set to true, the claiming account ID will be the receiver ID of the method call.
     * This receiver must be a valid account and non-malicious (cannot be set to the keypom contract)
     **/
    receiverToClaimer?: boolean;
    /**
     * What permissions does the user have when providing custom arguments to the function call?
     * By default, the user cannot provide any custom arguments
     */
    userArgsRule?: "AllUser" | "FunderPreferred" | "UserPreferred";
}

/**
 * Information pertaining to all Function-Call drops. This should be passed in if the drop will be a Function-Call drop.
 */
export interface FCData {
    /**
     * The top level array indicates a different set of methods that can be called for every key use. It is possible that for a given key use, no methods are called thus acting as a "free" key use whereby the use is reflected on-chain but no assets are transferred.
     * If a given key use does not have an undefined set of methods, when it is used, all the methods in the set will be called.
     */
    methods: Array<Maybe<Array<Method>>>;
}

'''
'''--- packages/core/src/lib/types/ft.ts ---
/**
 * Information pertaining to all Fungible-Token drops. This should be passed in if the drop will be used to transfer any fungible tokens.
 */
export interface FTData {
    /**
     * Which contract do the FTs belong to?
     */
    contractId: string;
    /**
     * By default, anyone can fund your drop with FTs. This field allows you to set a specific account ID that will be locked into sending the FTs.
     */
    senderId?: string;
    /**
     * Human readable format for the amount of tokens to transfer everytime the FT key is used.
     * Example: transferring one wNEAR should be passed in as "1" and NOT "1000000000000000000000000"
     */
    amount?: string;
    /**
     * Amount of tokens to transfer but considering the decimal amount.
     * Example: transferring one wNEAR should be passed in as "1000000000000000000000000" and NOT "1"
     */
    absoluteAmount?: string;
}

/**
 * General structure of Fungible Token Metadata as per official NEP-148 standard (https://github.com/near/NEPs/blob/master/neps/nep-0148.md).
 */
export interface FungibleTokenMetadata {
    /** A string. Should be ft-1.0.0 to indicate that a Fungible Token contract adheres to the current versions of this Metadata and the Fungible Token Core specs. This will allow consumers of the Fungible Token to know if they support the features of a given contract. */
    spec: string;
    /** The human-readable name of the token. */
    name: string;
    /** The abbreviation, like wETH or AMPL. */
    symbol: string;
    /** Used in frontends to show the proper significant digits of a token. This concept is explained well in this OpenZeppelin post (https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals). */
    decimals: number;
    /**
     * A small image associated with this token. Must be a data URL, to help consumers display it quickly while protecting user data.
     * Recommendation: use optimized SVG, which can result in high-resolution images with only 100s of bytes of storage cost.
     * (Note that these storage costs are incurred to the token owner/deployer, but that querying these icons is a very cheap & cacheable read operation for all consumers of the contract and the RPC nodes that serve the data.)
     * Recommendation: create icons that will work well with both light-mode and dark-mode websites by either using middle-tone color schemes, or by embedding media queries in the SVG.
     */
    icon?: string;
    /** A link to a valid JSON file containing various keys offering supplementary details on the token. Example: /ipfs/QmdmQXB2mzChmMeKY47C43LxUdg1NDJ5MWcKMKxDu7RgQm, https://example.com/token.json, etc. If the information given in this document conflicts with the on-chain attributes, the values in reference shall be considered the source of truth. */
    reference?: string;
    /** The base64-encoded sha256 hash of the JSON file contained in the reference field. This is to guard against off-chain tampering. */
    reference_hash?: string;
}

'''
'''--- packages/core/src/lib/types/general.ts ---
//import { Account, Connection, Near } from "near-api-js";
//import { KeyStore } from "near-api-js/lib/key_stores";
//import { KeyPair } from "near-api-js/lib/utils";

import { Connection } from "@near-js/accounts";
import { KeyPair } from "@near-js/crypto";
import { KeyStore } from "@near-js/keystores";
import { Action } from "@near-js/transactions";
import { Near } from "@near-js/wallet-account";
import { Account } from "@near-wallet-selector/core";

export type NearKeyPair = KeyPair;

/**
 * For each generated KeyPair (either through `createDrop`, `addKeys` or `generateKeys`), the public and private keys are returned.
 * In addition, the actual KeyPair objects are returned as well.
 */
export interface GeneratedKeyPairs {
    /** Actual KeyPair objects that can be used to sign messages, verify signatures, and get the public and private keys */
    keyPairs: NearKeyPair[];
    /** Set of public keys that were generated */
    publicKeys: string[];
    /** Set of private keys that were generated */
    secretKeys: string[];
}

/**
 * Outlines how the structure of the *funder* object should be passed into `initKeypom` or `updateFunder`. This contains important information such as the
 * secret key, account ID and any root entropy associated with the account.
 *
 * @throws if neither `secretKey` or `seedPhrase` are provided. One of these need to be passed in.
 */
export interface Funder {
    /** The account ID of the funder that will be used to sign transactions. */
    accountId: string;
    /** A valid private key associated with the funder's account. This can be function-call or full access (depending on what limitations and security measures are in place). */
    secretKey?: string;
    /** 12 word seedphrase that can be used to derive the `secretKey`. If this is present, it will override the passed in `secretKey`. */
    seedPhrase?: string;
    /**
     * When interacting with the SDK, there are several places where KeyPairs can be generated automatically rather than you having to pass them in.
     * For example, during `createDrop` and `addKeys`, if `publicKeys` isn't passed in, the SDK will generate `numKeys` number of keys automatically.
     * These generated keys can either be completely random or deterministically generated based off some entropy. If `rootEntropy` is provided, all the
     * keys that are auto-generated will be based off this entropy.
     */
    rootEntropy?: string;
    /** @internal */
    fundingKeyPair?: NearKeyPair;
}

/**
 * Important context that is used throughout the SDK. This is generated when `initKeypom` is called and can be retrieved by calling `useKeypom`.
 * All parameters will start off as undefined until the Keypom SDK is initialized.
 */
export interface EnvVars {
    /** The specific NEAR object that contains important information such as the KeyStore and connection. This is used to interact with the chain and can either be manually passed in or will be automatically created during `initKeypom` */
    near?: Near;
    /** The connection instance that is part of the NEAR object */
    connection?: Connection;
    /** Which type of KeyStore is used when locating keys and signing transactions throughout the SDK (In Memory, Unencrypted FileStore etc.)  */
    keyStore?: KeyStore;
    /** What network is the SDK using (`testnet` or `mainnet`)  */
    networkId?: string;
    /** The NEAR Account object for the Funder  */
    fundingAccount?: Account;
    /** The details for the funder such as any `rootEntropy` or their `secretKey` etc. */
    fundingAccountDetails?: Funder;
    /** The NEAR Account object for the Keypom contract being used. This lets you know the account ID for the contract and can be used to sign transactions for claiming linkdrops. */
    contractAccount?: Account;
    /** @internal */
    viewAccount?: any;
    /** The default amount of Gas that will be attached to transactions (200 TGas). */
    gas?: string;
    /** The max amount of Gas that will be attached to transactions (300 TGas). */
    gas300?: string;
    /** The amount of Gas that will be attached to the `claim` and `create_account_and_claim` functions for claiming linkdrops (100 TGas). */
    attachedGas?: string;
    /** The account ID where the Keypom contract is deployed to. */
    contractId?: string;
    /** @internal */
    receiverId?: string;
    /** @internal */
    error?: string;
    /** @internal */
    getAccount?: any;
    /** @internal */
    execute?: any;
    /** Object containing the supported Keypom contracts for both mainnet and testnet */
    supportedKeypomContracts?: { mainnet: {}; testnet: {} };
    /** Function that allows you to invoke a view method. This takes in a `receiverId`, `methodName`, and `args`. */
    viewCall?: any;
}

/**
 * Information returned from `getContractSourceMetadata` about the deployed Keypom contract. This is part of [NEP-330](https://nomicon.io/Standards/SourceMetadata) and
 * can allow you to view exactly what code is deployed to the contract.
 */
export interface ContractSourceMetadata {
    /** Versioning used by the Keypom developers to indicate which version of the contract is deployed. */
    version: string;
    /** Link to the specific commit and code on GitHub that is deployed to the Keypom account */
    link: string;
}

export interface BasicTransaction {
    receiverId: string;
    signerId: string;
    actions: Action[];
}
'''
'''--- packages/core/src/lib/types/nft.ts ---
/**
 * General structure of a Non-Fungible Token drop. This should be passed into `createDrop` if you wish to have an NFT drop.
 */
export interface NFTData {
    /** The account ID that the NFT contract is deployed to. This contract is where all the NFTs for the specific drop must come from. */
    contractId: string;
    /** By default, anyone can fund your drop with NFTs. This field allows you to set a specific account ID that will be locked into sending the NFTs. */
    senderId?: string;
    /**
     * If there are any token IDs that you wish to be automatically sent to the Keypom contract in order to register keys as part of `createDrop`, specify them here.
     * A maximum of 2 token IDs can be sent as part of the transaction. If you wish to register more keys by sending more NFTs, you must do this in a separate call by invoking
     * the `nftTransferCall` method separately.
     */
    tokenIds?: string[];
}

/**
 * General structure of a Non-Fungible Token object as per official NEP-171 standard (https://github.com/near/NEPs/blob/master/neps/nep-0171.md).
 */
export interface ProtocolReturnedNonFungibleTokenObject {
    /** String ID for the token */
    token_id: string;
    /** Account ID of the owner */
    owner_id: string;
    /** Metadata for the token */
    metadata?: ProtocolReturnedNonFungibleTokenMetadata;
    /** Map of account IDs to approval IDs as per official NEP-178 standard (https://github.com/near/NEPs/blob/master/neps/nep-0178.md). */
    approved_account_ids?: Map<string, number>;
    /** A mapping of NEAR accounts to the amount each should be paid out as per official NEP-199 standard (https://github.com/near/NEPs/blob/master/neps/nep-0199.md). */
    royalty?: Map<string, number>;
}

/**
 * General structure of Non-Fungible Token Metadata as per official NEP-177 standard (https://github.com/near/NEPs/blob/master/neps/nep-0177.md).
 */
export interface ProtocolReturnedNonFungibleTokenMetadata {
    /** ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055" */
    title?: string;
    /** free-form description */
    description?: string;
    /** URL to associated media, preferably to decentralized, content-addressed storage */
    media?: string;
    /** Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included. */
    media_hash?: string;
    /** number of copies of this set of metadata in existence when token was minted. */
    copies?: number;
    /** When token was issued or minted, Unix epoch in milliseconds */
    issued_at?: number;
    /** When token expires, Unix epoch in milliseconds */
    expires_at?: number;
    /** When token starts being valid, Unix epoch in milliseconds */
    starts_at?: number;
    /** When token was last updated, Unix epoch in milliseconds */
    updated_at?: number;
    /** anything extra the NFT wants to store on-chain. Can be stringified JSON. */
    extra?: string;
    /** URL to an off-chain JSON file with more info. */
    reference?: string;
    /** Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included. */
    reference_hash?: string;
}

/**
 * General structure of Non-Fungible Token Metadata (in camelCase) as per official NEP-177 standard (https://github.com/near/NEPs/blob/master/neps/nep-0177.md).
 */
export interface NonFungibleTokenMetadata {
    /** ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055" */
    title?: string;
    /** free-form description */
    description?: string;
    /** URL to associated media, preferably to decentralized, content-addressed storage */
    media?: string;
    /** Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included. */
    mediaHash?: string;
    /** number of copies of this set of metadata in existence when token was minted. */
    copies?: number;
    /** When token was issued or minted, Unix epoch in milliseconds */
    issuedAt?: number;
    /** When token expires, Unix epoch in milliseconds */
    expiresAt?: number;
    /** When token starts being valid, Unix epoch in milliseconds */
    startsAt?: number;
    /** When token was last updated, Unix epoch in milliseconds */
    updatedAt?: number;
    /** anything extra the NFT wants to store on-chain. Can be stringified JSON. */
    extra?: string;
    /** URL to an off-chain JSON file with more info. */
    reference?: string;
    /** Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included. */
    referenceHash?: string;
}

'''
'''--- packages/core/src/lib/types/params.ts ---
import {
    BrowserWalletBehaviour,
    Wallet,
} from "@near-wallet-selector/core/lib/wallet/wallet.types";
//import { Account } from "near-api-js";
import { Maybe } from "../keypom";
import { PasswordPerUse } from "./drops";
import { GeneratedKeyPairs } from "./general";
import {
    ProtocolReturnedDropConfig,
    ProtocolReturnedFCData,
    ProtocolReturnedFTData,
    ProtocolReturnedNFTData,
    ProtocolReturnedSimpleData,
} from "./protocol";
import { Account } from "@near-js/accounts";
import { Transaction } from "@near-js/transactions";

export type AnyWallet = BrowserWalletBehaviour | Wallet | Promise<Wallet>;

/**
 * Information returned when creating a drop or adding keys via `createDrop` and `addKeys` respectively.
 */
export interface CreateOrAddReturn {
    /** The responses to any transactions that were signed and sent to the network. */
    responses?: any;
    /** Information about the transactions if `returnTransactions` is specified in the arguments. This will result in the information being returned instead of signed and sent.  */
    transactions?: Transaction[];
    /** The required deposit that should be attached to the transaction. */
    requiredDeposit?: string;
    /** Any keys that were automatically generated. */
    keys?: GeneratedKeyPairs;
    /** The drop ID for the drop that is being interacted with. */
    dropId: string;
}

/**
 * @ignore
 */
export interface RegisterUsesParams {
    account?: Account;
    wallet?: AnyWallet;
    dropId: string;
    numUses: number;
    useBalance?: boolean;
}

/** @internal */
export interface CreateDropProtocolArgs {
    public_keys?: string[];
    deposit_per_use: string;

    drop_id?: string;
    config?: ProtocolReturnedDropConfig;
    metadata?: string;
    required_gas?: string;
    simple?: ProtocolReturnedSimpleData;
    ft?: ProtocolReturnedFTData;
    nft?: ProtocolReturnedNFTData;
    fc?: ProtocolReturnedFCData;
    passwords_per_use?: Array<Maybe<Array<PasswordPerUse>>>;
}

'''
'''--- packages/core/src/lib/types/protocol.ts ---
import { Maybe } from "../keypom";

/**
 * Key information returned from the Protocol. This interface is exactly the same as the `KeyInfo`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedKeyInfo {
    /** Drop ID for the specific drop that the key belongs to. */
    drop_id: string;
    /** Public key for this access key. */
    public_key: string;

    /** Which use is the key currently on? For single-use keys, this is always 1.  */
    cur_key_use: number;

    /** How many uses this key has left before it's deleted.  */
    remaining_uses: number;

    /** At what timestamp was the key last used? Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC. */
    last_used: number;

    /** How much allowance does the key have left (measured in $yoctoNEAR). When the key is deleted, this is refunded to the funder's balance. */
    allowance: number;

    /** The unique ID associated to this key. IDs are *not* unique across drops but they are unique for any key in the drop. */
    key_id: number;
}

/**
 * Drop information returned from the Protocol. This interface is exactly the same as the `Drop`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedDrop {
    /** Drop ID for this specific drop. */
    drop_id: string;
    /** Which account created this drop. */
    owner_id: string;
    /** How much $yoctoNEAR will be transferred anytime a key is used that is part of this drop. */
    deposit_per_use: string;
    /** For simple drops, there are specific, optional configurations. */
    simple?: ProtocolReturnedSimpleData;
    /** For NFT drops, important information such as the token IDs, or contract need to be stored. */
    nft?: ProtocolReturnedNFTData;
    /** For Fungible Token drops, important information such as the amount of tokens to transfer, or contract need to be stored. */
    ft?: ProtocolReturnedFTData;
    /** For Function-Call drops, important information needs to be stored such as which methods, the attached deposit, args etc. */
    fc?: ProtocolReturnedFCData;
    /** All drops regardless of their type can have a suite of configurations such as how many uses each key has or how often a key can be used. */
    config?: ProtocolReturnedDropConfig;
    /** Any extra information about the drop can be stored as metadata. This is up to the drop creator and can be stringified JSON, or any other string. */
    metadata?: string;
    /** How many key uses are registered for this drop? This is only applicable to simple drops with lazy registrations, FT drops, and NFT drops. */
    registered_uses: number;
    /** In order to use an access key that's part of this drop, how much Gas *needs* to be attached to the call? */
    required_gas: string;
    /** What is the next unique ID that will be given to the next access key added to this drop. */
    next_key_id: number;
    /** If calling `getDrops` or `getDropInformation` and `withKeys` is passed in as true, an extra view call will be done to get a set of keys that are currently on the drop. */
    keys?: ProtocolReturnedKeyInfo[];
}

/**
 * Drop config returned from the Protocol. This interface is exactly the same as the `DropConfig`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedDropConfig {
    /** How many uses can each key have before it's deleted. If this isn't specified, it defaults to 1 use per key. */
    uses_per_key?: number;

    /** Any information related to time-based configurations such as a starting date for keys etc. */
    time?: ProtocolReturnedTimeConfig;

    /** Any information related to how access keys are used such as which methods they can call or whether an empty drop should be automatically deleted etc.*/
    usage?: ProtocolReturnedUsageConfig;

    sale?: ProtocolReturnedPublicSaleConfig;

    /**
     * Override the global root account that all created sub-accounts will have (currently `near` or `testnet`). This allows users to drops that have a custom root.
     * For example, Fayyr could specify a root of `fayyr.near` By which all sub-accounts will then be `ACCOUNT.fayyr.near`.
     * It's important to note that this root account *MUST* have a smart contract deployed that has a method `create_account`.
     */
    root_account_id?: string;
}

/**
 * Time Config information returned from the Protocol. This interface is exactly the same as the `TimeConfig`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedTimeConfig {
    /**
     * Minimum block timestamp before keys can be used. If this isn't specified, keys can be used immediately.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    start?: number;

    /**
     * Block timestamp that keys must be used before. If this isn't specified, keys can be used indefinitely.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    end?: number;

    /**
     * Amount of time that *must* pass in between each key use. If this isn't specified, there is no delay between key uses.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    throttle?: number;

    /**
     * Interval of time after the `start_timestamp` that must pass before a key can be used. If multiple intervals pass, the key can be used multiple times.
     * This has nothing to do With the throttle timestamp. It only pertains to the start timestamp and the current timestamp. The last_used timestamp is not taken into account.
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    interval?: number;
}

/**
 * Usage Config information returned from the Protocol. This interface is exactly the same as the `UsageConfig`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedUsageConfig {
    /**
     * Specify which methods can be called by the access key (either `claim` or `create_account_and_claim`). If this isn't specified, both methods can be called.
     */
    permissions?: string;
    /**
     * If the method `claim` is called rather than `create_account_and_claim`, should the `deposit_per_use` be refunded to the owner's balance?
     * If this isn't specified, it defaults to false.
     */
    refund_deposit?: boolean;
    /**
     * When a key is used and deleted, if it results in the drop being empty, should the drop automatically be deleted? If this isn't specified, it defaults to false.
     */
    auto_delete_drop?: boolean;
    /**
     * In the case where `autoDeleteDrop` is set to true and the drop is the owner's last, should their balance be automatically withdrawn? If this isn't specified, it defaults to false.
     */
    auto_withdraw?: boolean;

    /** When calling `create_account` on the root account, which keypom args should be attached to the payload. */
    account_creation_fields?: {
        /**
         * Specifies what field Keypom should auto-inject the account that claimed the drop's ID into when calling the `create_account` function.
         */
        account_id_field?: string;
        /**
         * Specifies what field Keypom should auto-inject the drop's ID into when calling the `create_account` function.
         */
        drop_id_field?: string;
        /**
         * Specifies what field Keypom should auto-inject the key's ID into when calling the `create_account` function.
         */
        key_id_field?: string;
        /**
         * Specifies what field Keypom should auto-inject the drop funder's account ID into when calling the `create_account` function.
         */
        funder_id_field?: string;
    };
}

/**
 * Within the config, there are configurable options related to how keys can be sold and a funder can potentially make a profit.
 */
export interface ProtocolReturnedPublicSaleConfig {
    /** Maximum number of keys that can be added to this drop. If None, there is no max. */
    max_num_keys?: number;
    /**
     * Amount of $NEAR that the user needs to attach (if they are not the funder) on top of costs. This amount will be
     * Automatically sent to the funder's balance. If None, the keys are free to the public.
     */
    price_per_key?: string;
    /** Which accounts are allowed to add keys? If the allowlist is empty, anyone that is not in the blocklist can add keys. */
    allowlist?: string[];
    /** Which accounts are NOT allowed to add keys? */
    blocklist?: string[];
    /**
     * Should the revenue generated be sent to the funder's account balance or
     * automatically withdrawn and sent to their NEAR wallet?
     */
    auto_withdraw_funds?: boolean;
    /**
     * Minimum block timestamp before the public sale starts. If None, keys can be added immediately
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    start?: number;
    /**
     * Block timestamp dictating the end of the public sale. If None, keys can be added indefinitely
     * Measured in number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
     */
    end?: number;
}

export interface ProtocolReturnedSimpleData {
    // If this is set to true, keys can be created and registered AFTER they've been created (for simple and FC drops only).
    lazy_register?: boolean;
}

/**
 * NFT Data information returned from the Protocol. This interface is exactly the same as the `NFTData`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedNFTData {
    /** The account ID that the NFT contract is deployed to. This contract is where all the NFTs for the specific drop must come from. */
    contract_id: string;
    /** By default, anyone can fund your drop with NFTs. This field allows you to set a specific account ID that will be locked into sending the NFTs. */
    sender_id?: string;
}

/**
 * FT Data returned from the Protocol. This interface is exactly the same as the `FTData`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedFTData {
    /**
     * Which contract do the FTs belong to?
     */
    contract_id: string;
    /**
     * By default, anyone can fund your drop with FTs. This field allows you to set a specific account ID that will be locked into sending the FTs.
     */
    sender_id?: string;
    /**
     * Amount of tokens to transfer but considering the decimal amount.
     * Example: transferring one wNEAR should be passed in as "1000000000000000000000000" and NOT "1"
     */
    balance_per_use?: string;
}

/**
 * Method information returned from the Protocol. This interface is exactly the same as the `Method`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedMethod {
    /**
     * The account ID that the contract is deployed to that the method will be called on.
     */
    receiver_id: string;
    /**
     * The method that should be invoked on the `receiverId`'s contract.
     */
    method_name: string;
    /**
     * What arguments should be passed to the method. This should be in stringified JSON.
     */
    args: string;
    /**
     * How much yoctoNEAR should be attached to the call.
     */
    attached_deposit: string;
    /**
     * How much gas to attach to this method call. If none, all the gas is split between the parallel method calls in a given claim.
     * If this is specified, the key can ONLY be used to call `claim` and no `deposit_per_use` can be specified. This leads the key to act like a method calling proxy instead of a linkdrop.
     */
    attached_gas?: string;
    /**
     * Specifies what field Keypom should auto-inject the account that claimed the drop's ID into when calling the function.
     * As an example, if the methodName was `nft_mint` and it expected a field `receiver_id` to be passed in, indicating who should receive the token, then the `accountIdField` would be `receiver_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    account_id_field?: string;
    /**
     * Specifies what field Keypom should auto-inject the drops ID into when calling the function.
     * As an example, if an NFT contract expected the Keypom drop ID to be passed in as the field `keypom_drop_id` in order to gate access to who can mint NFTs, then the `dropIdField` would be `keypom_drop_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    drop_id_field?: string;
    /**
     * Specifies what field Keypom should auto-inject the key's ID into when calling the function.
     * As an example, if an NFT contract wanted to gate only users with an odd key ID to be able to mint an NFT and their parameter was called `keypom_key_id`, then the `keyIdField` would be `keypom_key_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    key_id_field?: string;
    /**
     * Specifies what field Keypom should auto-inject the funder's account ID into when calling the function.
     * As an example, if an NFT contract wanted to gate only users with an odd key ID to be able to mint an NFT and their parameter was called `keypom_key_id`, then the `keyIdField` would be `keypom_key_id`.
     * To insert into nested objects, use periods to separate. For example, to insert into args.metadata.field, you would specify "metadata.field"
     */
    funder_id_field?: string;
    /**
     * If set to true, the claiming account ID will be the receiver ID of the method call.
     * This receiver must be a valid account and non-malicious (cannot be set to the keypom contract)
     **/
    receiver_to_claimer?: boolean;
    /**
     * What permissions does the user have when providing custom arguments to the function call?
     * By default, the user cannot provide any custom arguments
     */
    user_args_rule?: "AllUser" | "FunderPreferred" | "UserPreferred";
}

/**
 * FC Data returned from the Protocol. This interface is exactly the same as the `FCData`, except all the fields are
 * snake cased instead of camel cased due to what the Protocol returns.
 */
export interface ProtocolReturnedFCData {
    /**
     * The top level array indicates a different set of methods that can be called for every key use. It is possible that for a given key use, no methods are called thus acting as a "free" key use whereby the use is reflected on-chain but no assets are transferred.
     * If a given key use does not have an undefined set of methods, when it is used, all the methods in the set will be called.
     */
    methods: Array<Maybe<Array<ProtocolReturnedMethod>>>;
}

'''
'''--- packages/core/src/lib/types/simple.ts ---
/**
 * Specific configurable information for Simple drops.
 */
export interface SimpleData {
    /** If this is set to true, keys can be created and registered AFTER they've been created (for simple and FC drops only). */
    lazyRegister?: boolean;
}

'''
'''--- packages/core/src/lib/views.ts ---
import { assert } from './checks';
import { KEY_LIMIT } from './drops';
import { getEnv, Maybe } from './keypom';
import { getPubFromSecret, keypomView } from './keypom-utils';
import { ContractSourceMetadata } from './types/general';
import {
    ProtocolReturnedDrop,
    ProtocolReturnedKeyInfo,
    ProtocolReturnedMethod
} from './types/protocol';

/**
 * Returns the balance associated a with given public key. If only the secret key is known, this can be passed in instead. This is used by the NEAR wallet to display the amount of the linkdrop
 *
 * @param {string=} publicKey The public key that contains a balance
 * @param {string=} secretKey The secret key corresponding to the public key
 *
 * @returns {Promise<string>} The amount of yoctoNEAR that is contained within the key
 *
 * @example
 * Create a 1 $NEAR linkdrop and query for its balance:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the amount of yoctoNEAR contained within the key
 * const keyBalance = await getKeyBalance({
 *     publicKey: keys.publicKeys[0]
 * })
 *
 * console.log('keyBalance: ', keyBalance)
 * ```
 * @group View Functions
 */
export const getKeyBalance = async ({
    publicKey,
    secretKey,
}: {
    publicKey?: string;
    secretKey?: string;
}): Promise<string> => {
    // Assert that either a secretKey or public key is passed in
    assert(
        secretKey || publicKey,
        'Must pass in either a publicKey or a secretKey'
    );
    if (secretKey) {
        publicKey = getPubFromSecret(secretKey);
    }

    return keypomView({
        methodName: 'get_key_balance',
        args: {
            key: publicKey,
        },
    });
};

/**
 * Query for the total supply of keys currently on the Keypom contract
 *
 * @returns {Promise<number>} The amount of keys.
 *
 * @example
 * Query for the key supply on the `v1.keypom.testnet` contract:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls
 * await initKeypom({
 *     network: "testnet",
 *     keypomContractId: "v1.keypom.testnet"
 * });
 *
 * // Query for the number of keys on the contract
 * const numKeys = await getKeyTotalSupply();
 *
 * console.log('numKeys: ', numKeys)
 * ```
 * @group View Functions
 */
export const getKeyTotalSupply = async (): Promise<number> => {
    return keypomView({
        methodName: 'get_key_total_supply',
        args: {},
    });
};

/**
 * Paginate through all active keys on the contract and return a vector of key info.
 *
 * @param {string= | number=} __namedParameters.start (OPTIONAL) Where to start paginating through keys.
 * @param {number=} __namedParameters.limit (OPTIONAL) How many keys to paginate through.
 *
 * @returns {Promise<Array<KeyInfo>>} Vector of KeyInfo.
 *
 * @example
 * Query for first 50 keys on the `v1.keypom.testnet` contract:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls
 * await initKeypom({
 *     network: "testnet",
 *     keypomContractId: "v1.keypom.testnet"
 * });
 *
 * // Query for the first 50 keys on the contract
 * const keyInfo = await getKeys({
 *   start: 0,
 *   limit: 50
 * });
 *
 * console.log('keyInfo: ', keyInfo)
 * ```
 * @group View Functions
 */
export const getKeys = async ({
    start,
    limit,
}: {
    start?: string | number;
    limit?: number;
}): Promise<Array<ProtocolReturnedKeyInfo>> => {
    return keypomView({
        methodName: 'get_keys',
        args: {
            from_index: start?.toString(),
            limit,
        },
    });
};

/**
 * Returns the KeyInfo corresponding to a specific public key
 *
 * @param {string=} publicKey the public key to get information for.
 * @param {string=} secretKey The secret key corresponding to the public key
 *
 * @returns {Promise<KeyInfo>} Key information struct for that specific key.
 *
 * @example
 * Create a drop and query for the key information:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key information for the key that was created
 * const keyInfo = await getKeyInformation({
 *     publicKey: keys.publicKeys[0]
 * })
 *
 * console.log('keyInfo: ', keyInfo)
 * ```
 * @group View Functions
 */
export const getKeyInformation = async ({
    publicKey,
    secretKey,
}: {
    publicKey?: string;
    secretKey?: string;
}): Promise<ProtocolReturnedKeyInfo> => {
    // Assert that either a secretKey or public key is passed in
    assert(
        secretKey || publicKey,
        'Must pass in either a publicKey or a secretKey'
    );
    if (secretKey) {
        publicKey = getPubFromSecret(secretKey);
    }

    return keypomView({
        methodName: 'get_key_information',
        args: {
            key: publicKey,
        },
    });
};

/**
 * Returns a vector of KeyInfo corresponding to a set of public keys passed in.
 *
 * @param {string[]=} publicKeys Array of public keys to get information about
 * @param {string[]=} secretKeys Array of the secret keys corresponding to the public keys
 *
 * @returns {Promise<Array<KeyInfo>>} Array of Key information structs for the keys passed in
 *
 * @example
 * Create a drop and query for the key information for all keys created:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 5 keys automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 5,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key information for the key that was created
 * const keyInfos = await getKeyInformationBatch({
 *     publicKeys: keys.publicKeys
 * })
 *
 * console.log('keyInfos: ', keyInfos)
 * ```
 * @group View Functions
 */
export const getKeyInformationBatch = async ({
    publicKeys,
    secretKeys,
}: {
    publicKeys?: string[];
    secretKeys?: string[];
}): Promise<Array<ProtocolReturnedKeyInfo>> => {
    // Assert that either secretKeys or public keys are passed in
    assert(
        secretKeys || publicKeys,
        'Must pass in either publicKeys or secretKeys'
    );
    if (secretKeys) {
        // Map the secret keys into public keys by calling getPubFromSecret
        publicKeys = secretKeys.map((secretKey) => {
            return getPubFromSecret(secretKey);
        });
    }

    return keypomView({
        methodName: 'get_key_information_batch',
        args: {
            keys: publicKeys,
        },
    });
};

/**
 * Get information about a specific drop by passing in either a drop ID, public key, or secret key.
 *
 * @param {string=} dropId (OPTIONAL) The drop ID for the specific drop that you want to get information about.
 * @param {string=} publicKey (OPTIONAL) A valid public key that is part of a drop.
 * @param {string=} secretKey (OPTIONAL) The secret key corresponding to a valid public key that is part of a drop.
 * @param {boolean=} withKeys (OPTIONAL) Whether or not to include key information for the first 50 keys in each drop.
 *
 * @returns {Drop} Drop information which may or may not have a keys field of type `KeyInfo` depending on if withKeys is specified as true.
 *
 * @example
 * Create a simple drop and retrieve information about it:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {dropId} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the drop information and also return the key information as well
 * const dropInfo = await getDropInformation({
 *     dropId,
 *     withKeys: true
 * })
 *
 * console.log('dropInfo: ', dropInfo)
 * ```
 *
 * @example
 * Create a simple drop and get the drop information based on a public key and then the secret key:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 1 key automatically created. That key will be completely random since there is no entropy.
 * const {keys} = await createDrop({
 *     numKeys: 1,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the drop information and also return the key information as well
 * let dropInfo = await getDropInformation({
 * 	   publicKey: keys.publicKeys[0],
 *     withKeys: true
 * })
 *
 * console.log('dropInfo via public key: ', dropInfo)
 *
 * // Query for the drop information and also return the key information as well
 * dropInfo = await getDropInformation({
 * 	   secretKey: keys.secretKeys[0],
 *     withKeys: true
 * })
 *
 * console.log('dropInfo via secret key: ', dropInfo)
 * ```
 * @group View Functions
 */
export const getDropInformation = async ({
    dropId,
    secretKey,
    publicKey,
    withKeys = false,
}: {
    dropId?: string;
    secretKey?: string;
    publicKey?: string;
    withKeys?: boolean;
}): Promise<ProtocolReturnedDrop> => {
    const { contractId, viewCall } = getEnv();

    // Assert that either a dropId or a secretKey is passed in
    assert(
        dropId || secretKey || publicKey,
        'Must pass in either a dropId, publicKey or a secretKey to getDropInformation'
    );

    if (secretKey) {
        publicKey = getPubFromSecret(secretKey);
    }

    const dropInfo = await viewCall({
        contractId,
        methodName: 'get_drop_information',
        args: {
            drop_id: dropId,
            key: publicKey,
        },
    });

    if (withKeys) {
        dropInfo.keys = await keypomView({
            methodName: 'get_keys_for_drop',
            args: {
                drop_id: dropInfo.drop_id,
                from_index: '0',
                limit: KEY_LIMIT,
            },
        });
    }

    return dropInfo;
};

/**
 * Returns the total supply of active keys for a given drop
 *
 * @param {string} dropId The drop ID for the specific drop that you want to get information about.
 *
 * @returns {Promise<number>} Number of active keys
 *
 * @example
 * Create a drop with 5 keys and query for the key supply:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 5 keys automatically created. That key will be completely random since there is no entropy.
 * const {keys, dropId} = await createDrop({
 *     numKeys: 5,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key supply for the drop that was created
 * const keySupply = await getKeySupplyForDrop({
 *     dropId
 * })
 *
 * console.log('keySupply: ', keySupply)
 * ```
 * @group View Functions
 */
export const getKeySupplyForDrop = async ({
    dropId,
}: {
    dropId: string;
}): Promise<number> => {
    return keypomView({
        methodName: 'get_key_supply_for_drop',
        args: {
            drop_id: dropId,
        },
    });
};

/**
 * Paginate through all keys in a specific drop, returning an array of KeyInfo.
 *
 * @param {string} dropId The drop ID for the specific drop that you want to get information about.
 * @param {string= | number=} start (OPTIONAL) Where to start paginating through keys.
 * @param {number=} limit (OPTIONAL) How many keys to paginate through.
 *
 * @returns {Promise<Array<KeyInfo>>} Vector of KeyInfo objects returned from pagination
 *
 * @example
 * Create a drop with 5 keys and return all the key info objects:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with 5 keys automatically created. That key will be completely random since there is no entropy.
 * const {dropId} = await createDrop({
 *     numKeys: 5,
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the key supply for the drop that was created
 * const keyInfos = await getKeysForDrop({
 *     dropId
 * })
 *
 * console.log('keyInfos: ', keyInfos)
 * ```
 * @group View Functions
 */
export const getKeysForDrop = async ({
    dropId,
    start,
    limit,
}: {
    dropId: string;
    start?: string | number;
    limit?: number;
}): Promise<Array<ProtocolReturnedKeyInfo>> => {
    return keypomView({
        methodName: 'get_keys_for_drop',
        args: {
            drop_id: dropId,
            from_index: start?.toString(),
            limit,
        },
    });
};

/**
 * Returns the total supply of active drops for a given account ID
 *
 * @param {string} accountId The account that the drops belong to.
 *
 * @returns {Promise<number>} Amount of drops
 *
 * @example
 * Create a drop and check how many the owner has:
 * ```js
 * // Initialize the SDK on testnet.
 * await initKeypom({
 *     network: "testnet",
 *     funder: {
 *         accountId: "benji_demo.testnet",
 *         secretKey: "ed25519:5yARProkcALbxaSQ66aYZMSBPWL9uPBmkoQGjV3oi2ddQDMh1teMAbz7jqNV9oVyMy7kZNREjYvWPqjcA6LW9Jb1"
 *     }
 * });
 *
 * // Create a drop with no keys
 * await createDrop({
 *     depositPerUseNEAR: 1
 * });
 *
 * // Query for the amount of drops owned by the account
 * const dropSupply = await getDropSupplyForOwner({
 *     accountId: "benji_demo.testnet"
 * })
 *
 * console.log('dropSupply: ', dropSupply)
 * ```
 * @group View Functions
 */
export const getDropSupplyForOwner = async ({
    accountId,
}: {
    accountId: string;
}): Promise<number> => {
    return keypomView({
        methodName: 'get_drop_supply_for_owner',
        args: {
            account_id: accountId,
        },
    });
};

/**
 * Paginate through drops owned by an account. If specified, information for the first 50 keys in each drop can be returned as well.
 *
 * @param {string} accountId The funding account that the drops belong to.
 * @param {string= | number=} start (OPTIONAL) Where to start paginating through drops.
 * @param {number=} limit (OPTIONAL) How many drops to paginate through.
 * @param {boolean=} withKeys (OPTIONAL) Whether or not to include key information for the first 50 keys in each drop.
 *
 * @example
 * Get drop information for the last 5 drops owned by a given account:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * 	network: "testnet",
 * });
 *
 * // Get the number of drops the account has.
 * const numDrops = await getDropSupply({
 * 	accountId: "benjiman.testnet"
 * });
 *
 * // Query for drop information for the last 5 drops and their respective keys
 * const dropsAndKeys = await getDrops({
 * 	accountId: "benjiman.testnet",
 * 	start: numDrops - 5,
 * 	withKeys: true
 * })
 *
 * console.log('dropsAndKeys: ', dropsAndKeys)
 * ```
 * @group View Functions
 */
export const getDrops = async ({
    accountId,
    start,
    limit,
    withKeys = false,
}: {
    /** The funding account that the drops belong to. */
    accountId: string;
    /** Where to start paginating through drops. */
    start: string | number;
    /** How many drops to paginate through. */
    limit: number;
    /** Whether or not to include key information for the first 50 keys in each drop. */
    withKeys: boolean;
}): Promise<ProtocolReturnedDrop[]> => {
    const drops = await keypomView({
        methodName: 'get_drops_for_owner',
        args: {
            account_id: accountId,
            from_index: start ? start.toString() : undefined,
            limit: limit ? limit : undefined,
        },
    });

    if (withKeys) {
        assert(
            drops.length <= 20,
            'Too many RPC requests in parallel. Use \'limit\' arg 20 or less.'
        );

        await Promise.all(
            drops.map(async (drop, i) => {
                const { drop_id } = drop;
                drop.keys = await keypomView({
                    methodName: 'get_keys_for_drop',
                    args: {
                        drop_id,
                        from_index: '0',
                        limit: KEY_LIMIT,
                    },
                });
            })
        );
    }

    return drops;
};

/**
 * Return the total supply of token IDs for a given NFT drop.
 *
 * @param {string} dropId The drop ID that the tokens belong to.
 *
 * @returns {Promise<number>} The amount of token IDs on the drop
 *
 * @example
 * Query for the supply of tokens on a specific drop:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for the amount of token IDs on the drop
 * const tokenSupply = await getNftSupplyForDrop({
 *   dropId: "1669840629120"
 * })
 *
 * console.log('tokenSupply: ', tokenSupply)
 * ```
 * @group View Functions
 */
export const getNftSupplyForDrop = async ({
    dropId,
}: {
    dropId: string;
}): Promise<number> => {
    return keypomView({
        methodName: 'get_nft_supply_for_drop',
        args: {
            drop_id: dropId,
        },
    });
};

/**
 * Paginate through token IDs in an NFT drop to return a vector of token IDs.
 *
 * @param {string} dropId The drop ID that the tokens belong to.
 * @param {string= | number=} start (OPTIONAL) Where to start paginating from.
 * @param {number=} limit (OPTIONAL) How many token IDs to paginate through.
 *
 * @returns {Promise<Array<string>>} Vector of token IDs
 *
 * @example
 * Query for a list of token IDs on a specific drop:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for a set of token IDs on the drop
 * const tokenList = await getNftTokenIDsForDrop({
 *   dropId: "1669840629120"
 * })
 *
 * console.log('tokenList: ', tokenList)
 * ```
 * @group View Functions
 */
export const getNftTokenIDsForDrop = async ({
    dropId,
    start,
    limit,
}: {
    dropId: string;
    start?: string | number;
    limit?: number;
}): Promise<Array<string>> => {
    return keypomView({
        methodName: 'get_nft_token_ids_for_drop',
        args: {
            drop_id: dropId,
            from_index: start,
            limit,
        },
    });
};

/**
 * Query for a user's current balance on the Keypom contract
 *
 * @param {string} accountId The account ID of the user to retrieve the balance for.
 *
 * @returns {string} The user's current balance
 *
 * @example
 * Query for a user's current balance on the Keypom contract:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for the drop information for a specific drop
 * const userBal = await getUserBalance({
 * accountId: "benjiman.testnet",
 * })
 *
 * console.log('userBal: ', userBal)
 * ```
 * @group View Functions
 */
export const getUserBalance = async ({
    accountId,
}: {
    accountId: string;
}): Promise<string> => {
    return keypomView({
        methodName: 'get_user_balance',
        args: {
            account_id: accountId,
        },
    });
};

/**
 * Query for the current method data for a given key. This pertains to FC drops and the current method data is either null or an array of methods that will be invoked when the key is claimed next.
 *
 * @param {string=} secretKey (OPTIONAL) The secret key of the key to retrieve the method data for. If no secret key is passed in, the public key must be passed in.
 * @param {string=} publicKey (OPTIONAL) The public key of the key to retrieve the method data for. If no public key is passed in, the secret key must be passed in.
 * @param {number=} keyUse (OPTIONAL) Pass in a specific key use (*NOT* zero indexed) to retrieve the method data for. If no key use is passed in, the method data for the current key use will be returned.
 *
 * @returns {Promise<Maybe<Array<ProtocolReturnedMethod>>>} The current method data for the key
 *
 * @example
 * ```js
 * const fcData = {
 * 	methods: [
 * 		null,
 * 		[
 * 			{
 * 				methodName: "nft_token",
 * 				receiverId: "nft.examples.testnet",
 * 				args: JSON.stringify({
 * 					token_id: "1"
 * 				}),
 * 				attachedDeposit: "0"
 * 			},
 * 			{
 * 				methodName: "nft_token",
 * 				receiverId: "nft.examples.testnet",
 * 				args: JSON.stringify({
 * 					token_id: "2"
 * 				}),
 * 				attachedDeposit: "0"
 * 			}
 * 		],
 * 		null
 * 	]
 * }
 *
 * const {keys: {publicKeys, secretKeys}} = await createDrop({
 * 	numKeys: 1,
 * 	depositPerUseNEAR: 0,
 * 	fcData,
 * 	config: {
 * 		usesPerKey: 3
 * 	}
 * });
 * const secretKey = secretKeys[0];
 *
 * let curMethodData = await getCurMethodData({secretKey});
 * console.log('curMethodData (first): ', curMethodData)
 * t.is(curMethodData, null);
 *
 * 	curMethodData = await getCurMethodData({secretKey, keyUse: 1});
 *	t.is(curMethodData, null);
 *	curMethodData = await getCurMethodData({secretKey, keyUse: 2});
 *	t.true(curMethodData != null);
 *	curMethodData = await getCurMethodData({secretKey, keyUse: 3});
 *	t.is(curMethodData, null);
 *
 * await claim({secretKey, accountId: 'foobar'})
 * curMethodData = await getCurMethodData({secretKey});
 * t.true(curMethodData != null);
 *
 * await claim({secretKey, accountId: 'foobar'})
 * curMethodData = await getCurMethodData({secretKey});
 * console.log('curMethodData (third): ', curMethodData)
 * t.is(curMethodData, null);
 * ```
 * @group View Functions
 */
export const getCurMethodData = async ({
    secretKey,
    publicKey,
    keyUse,
}: {
    secretKey?: string;
    publicKey?: string;
    keyUse?: number;
}): Promise<Maybe<Array<ProtocolReturnedMethod>>> => {
    const keyInfo = await getKeyInformation({ publicKey, secretKey });
    const dropInfo = await getDropInformation({ publicKey, secretKey });

    assert(dropInfo.fc, 'No FC drop found');
    const methodDataArray = dropInfo.fc!.methods;
    let startingIdx =
        methodDataArray.length > 1
            ? (dropInfo.config?.uses_per_key || 1) - keyInfo.remaining_uses
            : 0;

    if (keyUse) {
        assert(
            keyUse > 0 && keyUse <= methodDataArray.length,
            'Invalid key use passed in - out of bounds'
        );
        startingIdx = keyUse - 1;
    }

    return methodDataArray[startingIdx];
};

/**
 * Check if a given user can add keys to a drop. The only case where a user *other than the funder* could add keys is if the drop has a public sale running.
 *
 * @param {string} dropId The drop ID to check if the user can add keys to
 * @param {string} accountId The account ID of the user to check if they can add keys to the drop
 *
 * @returns {Promise<boolean>} Whether or not the user can add keys to the drop
 *
 * @example
 * ```js
 * await createDrop({
 * 	numKeys: 0,
 * 	depositPerUseNEAR: 0,
 * 	config: {
 * 		sale: {
 * 			maxNumKeys: 2,
 * 			pricePerKeyNEAR: 1
 * 		}
 * 	}
 * });
 *
 * const canAddKeys = await canUserAddKeys({accountId: "foobar.testnet"});
 * t.is(canAddKeys, true);
 * ```
 *
 * @group View Functions
 */
export const canUserAddKeys = async ({
    dropId,
    accountId,
}: {
    dropId: string;
    accountId: string;
}): Promise<boolean> => {
    assert(dropId && accountId, 'Must pass in a drop ID and account ID');

    const canAddKeys: boolean = await keypomView({
        methodName: 'can_user_add_keys',
        args: {
            drop_id: dropId,
            account_id: accountId,
        },
    });

    return canAddKeys;
};

/**
 * Returns the source metadata for the Keypom contract that the SDK has been initialized on. This includes valuable information
 * such as which specific version the contract is on and link to exactly which GitHub commit is deployed.
 *
 * @returns {ContractSourceMetadata} The contract's source metadata
 *
 * @example
 * Query for the current Keypom contract's source metadata:
 * ```js
 * // Initialize the SDK on testnet. No funder is passed in since we're only doing view calls.
 * await initKeypom({
 * network: "testnet",
 * });
 *
 * // Query for the Keypom contract's source metadata
 * const metadata = await getContractSourceMetadata();
 *
 * console.log('metadata: ', metadata)
 * ```
 * @group View Functions
 */
export const getContractSourceMetadata =
    async (): Promise<ContractSourceMetadata> => {
        return keypomView({
            methodName: 'contract_source_metadata',
            args: {},
        });
    };

'''
'''--- packages/core/test/creation.test.js ---
const path = require('path');
const homedir = require('os').homedir();
const { writeFile, mkdir, readFile } = require('fs/promises');
const test = require('ava');
const BN = require('bn.js');
const { getUserBalance, getCurMethodData, canUserAddKeys, addToSaleAllowlist, removeFromSaleAllowlist, addToSaleBlocklist, removeFromSaleBlocklist, updateSale, getDropSupplyForOwner } = require('../lib');
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { connect, Near } = require("@near-js/wallet-account");

const keypom = require('../lib');
const { Account } = require('@near-js/accounts');
const { parseNearAmount } = require('@near-js/utils');
const {
    execute,
    initKeypom,
    getEnv,
    createDrop,
    getDrops,
    claim,
    deleteKeys,
    deleteDrops,
    addKeys,
    generateKeys,
    withdrawBalance,
    addToBalance
} = keypom;

const NETWORK_ID = 'testnet';
const funderAccountId = 'benjiman.testnet';
const viewAccountId = NETWORK_ID == 'mainnet' ? 'near' : 'testnet';

/// all tests
let fundingAccount;
test('init', async (t) => {
    // Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = '.near-credentials';
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    fundingAccount = new Account(near.connection, funderAccountId);

    await initKeypom({
        near
    });

    t.true(true);
});

test('token drop', async (t) => {
    const wallets = ['mynearwallet', 'herewallet'];
    const dropName = 'My Cool Drop Name';
    const depositPerUseNEAR = 1;
    const numKeys = 1;
    const usesPerKey = 1;
    const masterKey = 'MASTER_KEY';

    const {dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 0,
        config: {
            usesPerKey,
            usage: {
                autoDeleteDrop: true,
                autoWithdraw: true,
            }
        },
        metadata: JSON.stringify({
            dropName,
            wallets
        }),
        depositPerUseNEAR,
    });

    let allSecretKeys = [];
    // Loop through in intervals of 50 until numKeys is reached
    let keysAdded = 0;
    while (keysAdded < numKeys) {
        const keysToAdd = Math.min(50, numKeys - keysAdded);
        const {secretKeys, publicKeys} = await generateKeys({
            numKeys: keysToAdd,
            rootEntropy: `${masterKey}-${dropId}`,
            autoMetaNonceStart: keysAdded
        });
        await addKeys({
            account: fundingAccount,
            dropId,
            publicKeys
        });
        keysAdded += keysToAdd;

        allSecretKeys = allSecretKeys.concat(secretKeys);
    }

    const {contractId} = getEnv();

    const baseUrl = NETWORK_ID === 'testnet' ? 'https://testnet.keypom-airfoil.pages.dev/claim' : 'https://keypom.xyz/claim';
    
    const secretKeysStripped = allSecretKeys.map((sk) => `${baseUrl}/${contractId}/${sk.split(':')[1]}`);

    let stringToWrite = '';
    // Loop through each secret key
    var i = 0;
    for (const sk of secretKeysStripped) {
        stringToWrite += sk + '\n';
        i++;
    }

    await writeFile(path.resolve(__dirname, 'token_links.json'), stringToWrite);
    
    t.true(true);
});

test('NFT drop', async (t) => {
	const wallets = ["mynearwallet", "herewallet"];
    const dropName = "My Cool Drop Name";
    const depositPerUseNEAR = 0.1;
    const numKeys = 50;
    const usesPerKey = 1;
    const masterKey = "MASTER_KEY";
    
    const nftTitle = "Moon NFT!";
    const nftDescription = "A cool NFT for the best dog in the world.";
    const nftMediaIPFSHash = "bafybeibwhlfvlytmttpcofahkukuzh24ckcamklia3vimzd4vkgnydy7nq";

    const {dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 0,
        metadata: JSON.stringify({
            dropName,
            wallets
        }),
        config: {
            usesPerKey
        },
        depositPerUseNEAR,
        fcData: {
            methods: [[
                {
                    receiverId: `nft-v2.keypom.${viewAccountId}`,
                    methodName: "nft_mint",
                    args: "",
                    dropIdField: "mint_id",
                    accountIdField: "receiver_id",
                    attachedDeposit: parseNearAmount("0.008")
                }
            ]]
        }
    })

    let allSecretKeys = [];
    // Loop through in intervals of 50 until numKeys is reached
    let keysAdded = 0;
    while (keysAdded < numKeys) {
        const keysToAdd = Math.min(50, numKeys - keysAdded);
        const {secretKeys, publicKeys} = await generateKeys({
            numKeys: keysToAdd,
            rootEntropy: `${masterKey}-${dropId}`,
            autoMetaNonceStart: keysAdded
        })
        await addKeys({
            account: fundingAccount,
            dropId,
            publicKeys
        })
        keysAdded += keysToAdd;

        allSecretKeys = allSecretKeys.concat(secretKeys);
    }

    await keypom.createNFTSeries({
        account: fundingAccount,
        dropId,
        metadata: {
            title: nftTitle,
            description: nftDescription,
            media: nftMediaIPFSHash
        }
    });

    const {contractId} = getEnv();

    const baseUrl = NETWORK_ID === "testnet" ? `https://testnet.keypom-airfoil.pages.dev/claim` : `https://keypom.xyz/claim`

    const secretKeysStripped = allSecretKeys.map((sk) => `${baseUrl}/${contractId}#${sk.split(":")[1]}`)

    let stringToWrite = ""
    // Loop through each secret key
    var i = 0;
    for (const sk of secretKeysStripped) {
        stringToWrite += sk + "\n";
        i++;
    }

    await writeFile(path.resolve(__dirname, `nft_links.json`), stringToWrite);

	t.true(true);
});

test('Ticket drops', async (t) => {
	const wallets = ["mynearwallet", "herewallet"];
    const dropName = "My Cool Drop Name";
    const depositPerUseNEAR = 0.1;
    const numKeys = 50;
    const usesPerKey = 3;
    const masterKey = "MASTER_KEY";
    
    const eventPassword = "event-password";
    const nftTitle = "Moon NFT!";
    const nftDescription = "A cool NFT for the best dog in the world.";
    const nftMediaIPFSHash = "bafybeibwhlfvlytmttpcofahkukuzh24ckcamklia3vimzd4vkgnydy7nq";

    const {dropId} = await createDrop({
        account: fundingAccount,
        numKeys: 0,
        metadata: JSON.stringify({
            dropName,
            wallets
        }),
        config: {
            usesPerKey
        },
        depositPerUseNEAR,
        fcData: {
            methods: [
                null,
                null,
                [
                    {
                        receiverId: `nft-v2.keypom.${viewAccountId}`,
                        methodName: "nft_mint",
                        args: "",
                        dropIdField: "mint_id",
                        accountIdField: "receiver_id",
                        attachedDeposit: parseNearAmount("0.008")
                    }
                ]
            ]
        }
    })

    let allSecretKeys = [];
    // Loop through in intervals of 50 until numKeys is reached
    let keysAdded = 0;
    while (keysAdded < numKeys) {
        const keysToAdd = Math.min(50, numKeys - keysAdded);
        const {secretKeys, publicKeys} = await generateKeys({
            numKeys: keysToAdd,
            rootEntropy: `${masterKey}-${dropId}`,
            autoMetaNonceStart: keysAdded
        })
        await addKeys({
            account: fundingAccount,
            dropId,
            publicKeys,
            basePassword: eventPassword,
            passwordProtectedUses: [2]
        })
        keysAdded += keysToAdd;

        allSecretKeys = allSecretKeys.concat(secretKeys);
    }

    await keypom.createNFTSeries({
        account: fundingAccount,
        dropId,
        metadata: {
            title: nftTitle,
            description: nftDescription,
            media: nftMediaIPFSHash
        }
    });

    const {contractId} = getEnv();

    const baseUrl = NETWORK_ID === "testnet" ? `https://testnet.keypom-airfoil.pages.dev/claim` : `https://keypom.xyz/claim`

    const secretKeysStripped = allSecretKeys.map((sk) => `${baseUrl}/${contractId}#${sk.split(":")[1]}`)

    let stringToWrite = ""
    // Loop through each secret key
    var i = 0;
    for (const sk of secretKeysStripped) {
        stringToWrite += sk + "\n";
        i++;
    }

    await writeFile(path.resolve(__dirname, `ticket_links.json`), stringToWrite);

	t.true(true);
});
'''
'''--- packages/core/test/dummy-creation.test.js ---
const test = require('ava');
const BN = require('bn.js');
const nearAPI = require('near-api-js');
const { getUserBalance, getCurMethodData, canUserAddKeys, addToSaleAllowlist, removeFromSaleAllowlist, addToSaleBlocklist, removeFromSaleBlocklist, updateSale, getDropSupplyForOwner } = require('../lib');
const {
    Near,
    KeyPair,
    utils: { format: {
        parseNearAmount
    } },
    keyStores: { InMemoryKeyStore },
} = nearAPI;

const keypom = require('../lib');
const {
    execute,
    initKeypom,
    getEnv,
    createDrop,
    getDrops,
    claim,
    deleteKeys,
    deleteDrops,
    addKeys,
    generateKeys,
    withdrawBalance,
    addToBalance
} = keypom;

/// funding account
const accountId = process.env.TEST_ACCOUNT_ID;
const secretKey = process.env.TEST_ACCOUNT_PRVKEY;
const testKeyPair = KeyPair.fromString(secretKey);

const NUM_KEYS = 10;
const keyPairs = {
    simple: [],
    ft: [],
    nft: [],
    fc: [],
};

console.log('accountId', accountId);

/// mocking browser for tests

const _ls = {};
window = {
    localStorage: {
        getItem: (k) => _ls[k],
        setItem: (k, v) => _ls[k] = v,
        removeItem: (k) => delete _ls[k],
    },
};
localStorage = window.localStorage;

/// for testing of init NEAR here and pass in to initKeypom
const networks = {
    mainnet: {
        networkId: 'mainnet',
        viewAccountId: 'near',
        nodeUrl: 'https://rpc.mainnet.near.org',
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
    },
    testnet: {
        networkId: 'testnet',
        viewAccountId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
    }
};
const network = 'testnet';
const networkConfig = typeof network === 'string' ? networks[network] : network;
const keyStore = new InMemoryKeyStore();
const near = new Near({
    ...networkConfig,
    deps: { keyStore },
});

/// all tests
let fundingAccount, drops;
test('init', async (t) => {
    await initKeypom({
        // near,
        network: 'testnet',
        funder: {
            accountId,
            secretKey,
        }
    });
	
    const {keys} = await createDrop({
        numKeys: 1,
        depositPerUseNEAR: 5000
    });

    console.log('Funder Secret Keys: ', keys);

    const newAccountId = `dummy-account-${Date.now()}.testnet`;
    const autoImportLink = `https://wallet.testnet.near.org/auto-import-secret-key#${newAccountId}/ed25519:${keys.secretKeys[0]}`;
    console.log('autoImportLink: ', autoImportLink);
	
    await claim({
        secretKey: keys.secretKeys[0],
        newAccountId,
        newPublicKey: keys.publicKeys[0]
    });

    await keypom.updateFunder({funder: {accountId: newAccountId, secretKey: keys.secretKeys[0]}});

    const { fundingAccount: keypomFundingAccount } = getEnv();
    fundingAccount = keypomFundingAccount;

    console.log('fundingAccount', keypomFundingAccount);

    t.true(true);
});

const tokenDropInfo = {
    25: 'Default Token Drop Title',
    26: ' ',
    27: '😃',
    28: 'This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated.',
    29: 's',
    30: 'This is a duplicate drop title',
    31: 'This is a duplicate drop title',
    32: 'This is a duplicate drop title',
    33: 'This is a duplicate drop title',
    0: 'This drop has zero keys',
    1000: 'This drop has a TON of keys',
    10: 'This drop has an even amount of keys',
    11: 'This drop has an odd number of keys',
    197: `Ascii art                    | 
	____________    __ -+-  ____________ 
	\_____     /   /_ \ |   \     _____/
	\_____    \____/  \____/    _____/
	\_____                    _____/
	\___________  ___________/
	/____\``,
};

const availableWallets = ['wallet.near.org', 'mynearwallet', 'herewallet'];

test('token drops', async (t) => {
    // Loop through entries in tokenDropInfo
    for (const [numKeys, dropName] of Object.entries(tokenDropInfo)) {
        // Randomly get 1, 2, or 3 wallets from the available wallets as an array
        const wallets = availableWallets.sort(() => Math.random() - 0.5).slice(0, Math.floor(Math.random() * 3) + 1);
		
        const {dropId} = await createDrop({
            numKeys: 0,
            metadata: JSON.stringify({
                dropName,
                wallets
            }),
            depositPerUseNEAR: 0.1
        });

        // Loop through in intervals of 50 until numKeys is reached
        let keysAdded = 0;
        while (keysAdded < numKeys) {
            const keysToAdd = Math.min(50, numKeys - keysAdded);
            const {publicKeys} = await generateKeys({
                numKeys: keysToAdd,
                rootEntropy: `MASTER_KEY-${dropId}`,
                autoMetaNonceStart: keysAdded
            });
            await addKeys({
                dropId,
                publicKeys
            });
            keysAdded += keysToAdd;
        }
    }

    const lastDropId = Date.now().toString();
    const {secretKeys, publicKeys} = await generateKeys({
        numKeys: 27,
        rootEntropy: `MASTER_KEY-${lastDropId}`,
        autoMetaNonceStart: 0
    });
    await createDrop({
        dropId: lastDropId,
        publicKeys,
        metadata: JSON.stringify({
            dropName: 'this drop has keys claimed',
            wallets: ['wallet.near.org']
        }),
        depositPerUseNEAR: 0.1
    });

    // Claim 15 random keys out of the 27
    const keysToClaim = secretKeys.sort(() => Math.random() - 0.5).slice(0, 15);
    for (const key of keysToClaim) {
        await claim({
            secretKey: key,
            accountId: 'benjiman.testnet'
        });
    }

    t.true(true);
});

const nftMedias = [
    'bafkreiat3ajmzexcc2pifxctcvsryztyqolytyr5dkgfw24pus7untxypu',
    'bafybeibwhlfvlytmttpcofahkukuzh24ckcamklia3vimzd4vkgnydy7nq',
    'bafkreia3m663c6kgzopsoyqkwmurufee6gxxlb4u7j573ej2ubnqd2q7ya',
    'bafkreifgjnfpzjpfijndodzqw262z2xrec3qjfut5nyoekbysozwwpqakq',
    'bafkreiaadsk6v5nygmgiwz2lfukdpa2mqdlsoq5lhnjibjjxsatwcfflzq',
    'bafybeiax2n6wtil67a6w5qcdm4jwnnxb34ujy2ldgbbanpaoudv7jvgizu',
    'bafkreifuuae4uzclz5futlfqrq43aqk6peb26er6dz7nhrserr6f7zqrqy',
    'bafybeiblargpzhwxgmbzzci6n6oubfhcw33cdqb4uqx62sxrvf5biwcszi',
    'bafkreif2n2mjkn62c3mbcb2jh5fncdxxnqybe4cfm3hubuwsmvtid74nrm',
    'bafybeie5rnsvy7oapjugh4vmw3hsod5w5cpamqblnokb45osnaypqf7bmm',
    'bafkreihphjw5exvg7tlrwhlgpaebmvpxya7tijglnn5virevjrsucxrxiu',
    'bafybeihnb36l3xvpehkwpszthta4ic6bygjkyckp5cffxvszbcltzyjcwi',
    'bafkreifczwmdq7zam4cpdf7sfx4n64ywcskwddgd6tn7cjwidmisjapqfy',
    'bafybeifnhwtbsdle3veww24imskadutiedwf6euama4toe6oix54mvhtrq',
    'bafybeiabyn6bqxahnwdxy4hpug5gseprep3zg4dedkrvjploebg7ih7uhq'
];

const nftDescriptions = [
    ' ',
    'Default NFT Metadata Description',
    'This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated, This is a really long description that is repeated',
    's',
    '😃',
    `Ascii art                    | 
	____________    __ -+-  ____________ 
	\_____     /   /_ \ |   \     _____/
	\_____    \____/  \____/    _____/
	\_____                    _____/
	\___________  ___________/
	/____\``
];

const nftTitles = [
    ' ',
    'Default NFT Metadata Title',
    'This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated, This is a really long NFT title that is repeated',
    's',
    '😃',
    `Ascii art                    | 
	____________    __ -+-  ____________ 
	\_____     /   /_ \ |   \     _____/
	\_____    \____/  \____/    _____/
	\_____                    _____/
	\___________  ___________/
	/____\``
];

const nftDropInfo = {
    25: 'Default NFT Drop Title',
    26: ' ',
    27: '😃',
    28: 'This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated. This is a really long title that is repeated.',
    29: 's',
    30: 'This is a duplicate drop title',
    31: 'This is a duplicate drop title',
    32: 'This is a duplicate drop title',
    33: 'This is a duplicate drop title',
    0: 'This drop has zero keys',
    1000: 'This drop has a TON of keys',
    10: 'This drop has an even amount of keys',
    11: 'This drop has an odd number of keys',
    197: `Ascii art                    | 
	____________    __ -+-  ____________ 
	\_____     /   /_ \ |   \     _____/
	\_____    \____/  \____/    _____/
	\_____                    _____/
	\___________  ___________/
	/____\``,
};

test('NFT drops', async (t) => {
    // Loop through entries in nftDropInfo
    for (const [numKeys, dropName] of Object.entries(nftDropInfo)) {
        // Randomly get 1, 2, or 3 wallets from the available wallets as an array
        const wallets = availableWallets.sort(() => Math.random() - 0.5).slice(0, Math.floor(Math.random() * 3) + 1);
		
        const {dropId} = await createDrop({
            numKeys: 0,
            metadata: JSON.stringify({
                dropName,
                wallets
            }),
            depositPerUseNEAR: 0.1,
            fcData: {
                methods: [[
                    {
                        receiverId: 'nft-v2.keypom.testnet',
                        methodName: 'nft_mint',
                        args: '',
                        dropIdField: 'mint_id',
                        accountIdField: 'receiver_id',
                        attachedDeposit: parseNearAmount('0.1')
                    }
                ]]
            }
        });

        // Loop through in intervals of 50 until numKeys is reached
        let keysAdded = 0;
        while (keysAdded < numKeys) {
            const keysToAdd = Math.min(50, numKeys - keysAdded);
            const {publicKeys} = await generateKeys({
                numKeys: keysToAdd,
                rootEntropy: `MASTER_KEY-${dropId}`,
                autoMetaNonceStart: keysAdded
            });
            await addKeys({
                dropId,
                publicKeys
            });
            keysAdded += keysToAdd;
        }

        // Pick a random title
        const title = nftTitles[Math.floor(Math.random() * nftTitles.length)];
        // Pick a random description
        const description = nftDescriptions[Math.floor(Math.random() * nftDescriptions.length)];
        // Pick a random media
        const media = nftMedias[Math.floor(Math.random() * nftMedias.length)];

        const res = await keypom.createNFTSeries({
            dropId,
            metadata: {
                title,
                description,
                media
            }
        });
    }

    const lastDropId = Date.now().toString();
    const {secretKeys, publicKeys} = await generateKeys({
        numKeys: 27,
        rootEntropy: `MASTER_KEY-${lastDropId}`,
        autoMetaNonceStart: 0
    });
    await createDrop({
        dropId: lastDropId,
        publicKeys,
        metadata: JSON.stringify({
            dropName: 'this drop has keys claimed',
            wallets: ['wallet.near.org']
        }),
        depositPerUseNEAR: 0.1,
        fcData: {
            methods: [[
                {
                    receiverId: 'nft-v2.keypom.testnet',
                    methodName: 'nft_mint',
                    args: '',
                    dropIdField: 'mint_id',
                    accountIdField: 'receiver_id',
                    attachedDeposit: parseNearAmount('0.1')
                }
            ]]
        }
    });

    // Pick a random title
    const title = nftTitles[Math.floor(Math.random() * nftTitles.length)];
    // Pick a random description
    const description = nftDescriptions[Math.floor(Math.random() * nftDescriptions.length)];
    // Pick a random media
    const media = nftMedias[Math.floor(Math.random() * nftMedias.length)];

    const res = await keypom.createNFTSeries({
        lastDropId,
        metadata: {
            title,
            description,
            media
        }
    });

    // Claim 15 random keys out of the 27
    const keysToClaim = secretKeys.sort(() => Math.random() - 0.5).slice(0, 15);
    for (const key of keysToClaim) {
        await claim({
            secretKey: key,
            accountId: 'benjiman.testnet'
        });
    }

    t.true(true);
});

test('Ticket drops', async (t) => {
    // Loop through entries in nftDropInfo
    for (const [numKeys, dropName] of Object.entries(nftDropInfo)) {
        // Randomly get 1, 2, or 3 wallets from the available wallets as an array
        const wallets = availableWallets.sort(() => Math.random() - 0.5).slice(0, Math.floor(Math.random() * 3) + 1);
		
        const {dropId} = await createDrop({
            numKeys: 0,
            config: {
                usesPerKey: 3
            },
            metadata: JSON.stringify({
                dropName,
                wallets
            }),
            depositPerUseNEAR: 0.1,
            basePassword: 'event-password',
            passwordProtectedUses: [2],
            fcData: {
                methods: [
                    null,
                    null,
                    [
                        {
                            receiverId: 'nft-v2.keypom.testnet',
                            methodName: 'nft_mint',
                            args: '',
                            dropIdField: 'mint_id',
                            accountIdField: 'receiver_id',
                            attachedDeposit: parseNearAmount('0.1')
                        }
                    ]
                ]
            }
        });

        // Loop through in intervals of 50 until numKeys is reached
        let keysAdded = 0;
        while (keysAdded < numKeys) {
            const keysToAdd = Math.min(50, numKeys - keysAdded);
            const {publicKeys} = await generateKeys({
                numKeys: keysToAdd,
                rootEntropy: `MASTER_KEY-${dropId}`,
                autoMetaNonceStart: keysAdded
            });
            await addKeys({
                dropId,
                publicKeys,
                basePassword: 'event-password',
                passwordProtectedUses: [2],
            });
            keysAdded += keysToAdd;
        }

        // Pick a random title
        const title = nftTitles[Math.floor(Math.random() * nftTitles.length)];
        // Pick a random description
        const description = nftDescriptions[Math.floor(Math.random() * nftDescriptions.length)];
        // Pick a random media
        const media = nftMedias[Math.floor(Math.random() * nftMedias.length)];

        const res = await keypom.createNFTSeries({
            dropId,
            metadata: {
                title,
                description,
                media
            }
        });
    }

    const lastDropId = Date.now().toString();
    const {secretKeys, publicKeys} = await generateKeys({
        numKeys: 27,
        rootEntropy: `MASTER_KEY-${lastDropId}`,
        autoMetaNonceStart: 0
    });
    await createDrop({
        dropId: lastDropId,
        publicKeys,
        config: {
            usesPerKey: 3
        },
        metadata: JSON.stringify({
            dropName: 'this drop has keys claimed',
            wallets: ['wallet.near.org']
        }),
        depositPerUseNEAR: 0.1,
        basePassword: 'event-password',
        passwordProtectedUses: [2],
        fcData: {
            methods: [
                null,
                null,
                [
                    {
                        receiverId: 'nft-v2.keypom.testnet',
                        methodName: 'nft_mint',
                        args: '',
                        dropIdField: 'mint_id',
                        accountIdField: 'receiver_id',
                        attachedDeposit: parseNearAmount('0.1')
                    }
                ]
            ]
        }
    });

    // Pick a random title
    const title = nftTitles[Math.floor(Math.random() * nftTitles.length)];
    // Pick a random description
    const description = nftDescriptions[Math.floor(Math.random() * nftDescriptions.length)];
    // Pick a random media
    const media = nftMedias[Math.floor(Math.random() * nftMedias.length)];

    const res = await keypom.createNFTSeries({
        lastDropId,
        metadata: {
            title,
            description,
            media
        }
    });

    // Claim 15 random keys out of the 27
    const keysToClaim = secretKeys.sort(() => Math.random() - 0.5).slice(0, 25);
    for (const key of keysToClaim) {
        await claim({
            secretKey: key,
            accountId: 'benjiman.testnet'
        });
    }

    t.true(true);
});

test('Final Output', async (t) => {
    const { fundingAccount: keypomFundingAccount } = getEnv();

    const supplyForOwner = await getDropSupplyForOwner({accountId: keypomFundingAccount.accountId});
    console.log('supplyForOwner: ', supplyForOwner);

    // Paginate through all drops owned by the account starting at index 0 with a limit of 10 drops per call all the way until supply is reached
    let index = 0;
    let supply = 0;
    while (supply < supplyForOwner) {
        const drops = await getDrops({accountId: keypomFundingAccount.accountId, index, limit: 10});
        console.log(`idx: ${index} supply: ${supply} - Drops for owner: `, drops);
        supply += drops.length;
        index += 10;
    }

    console.log('fundingAccount', keypomFundingAccount);

    t.true(true);
});
'''
'''--- packages/core/tsconfig.json ---
{
    "extends": "../../tsconfig.node.json",
    "compilerOptions": {
        "preserveSymlinks": false,
        "outDir": "./lib",
    },
    "files": [
        "src/index.ts"
    ],
    "types": ["node"]
}

'''
'''--- packages/core/typedoc.json ---
{
  "$schema": "https://typedoc.org/schema.json",
  "entryPoints": ["./src/index.ts"],
  "out": "docs"
}
'''
'''--- packages/selector/README.md ---
<p align="center">
  <a href="https://docs.keypom.xyz/">
    <picture>
      <img src="https://cloudflare-ipfs.com/ipfs/bafybeightypuoqly32gsrivh4efckhdv6wsefiynpnonlem6ts3ypgdm7e" height="128">
    </picture>
    <h1 align="center">Keypom Wallet Selector</h1>
  </a>
</p>

<p align="center">
  <a aria-label="Made by Ben Kurrek" href="https://github.com/BenKurrek">
    <img src="https://img.shields.io/badge/MADE%20BY-Ben%20Kurrek-000000.svg?style=for-the-badge">
  </a>
  <a aria-label="Made by Matt Lockyer" href="https://github.com/mattlockyer">
    <img src="https://img.shields.io/badge/MADE%20BY-Matt%20Lockyer-000000.svg?style=for-the-badge">
  </a>
  <a aria-label="License" href="https://github.com/keypom/keypom-js/blob/main/LICENSE">
    <img alt="" src="https://img.shields.io/badge/License-GNU%20GPL-green?style=for-the-badge">
  </a>
  <a aria-label="Join the community" href="https://t.me/+OqI-cKxQU05lZDIx">
    <img alt="" src="https://img.shields.io/badge/Join%20The-community-blueviolet.svg?style=for-the-badge">
  </a>
</p>

The Keypom Wallet Selector is a package that allows apps to be fully compatible with both trial accounts and instant sign in experiences. See the following demos for examples of the user experience.
- Instant Sign-In [Demo](https://www.youtube.com/watch?v=p_NOcYbRlJw&feature=youtu.be)
- Trial Account [Demo](https://www.youtube.com/watch?v=p_NOcYbRlJw)

# Table of Contents
- [Installation](#installation)
- [Getting Started](#getting-started)
    - [Setup Keypom Parameters](#setup-keypom-parameters)
- [Keypom Trial Accounts](#keypom-trial-accounts)
    - [Trial Account Specs](#trial-account-specs)
    - [Modal Options](#modal-options)
    - [Example Trial Account Integration](#example-trial-account-integration)
- [Keypom Instant Sign In Experiences](#keypom-instant-sign-in-experiences)
    - [Instant Sign In Specs](#instant-sign-in-specs)
- [Contributing](#contributing)

---

# Installation

To install the Keypom Wallet Selector, run the following command:

```bash
npm install @keypom/selector
# or
yarn add @keypom/selector
# or
pnpm add @keypom/selector
```

# Getting Started

Most apps on NEAR should be compatible with the official [wallet selector](https://github.com/near/wallet-selector) to enable sign-in and sending transactions. For this reason, the Keypom selector has been made to fully support any app that uses the wallet selector.

To get started, navigate to the app's `setupWalletSelector` code where the selector is initialized. Here, you can specify which wallet modules your app should support. Simply add Keypom's `setupKeypom` function to the list of modules and you're good to go!

```js
const selector = await setupWalletSelector({
  network: "testnet",
  modules: [
    setupMyNearWallet(),
    ...
    setupSender(),
    setupKeypom(PARAMS)
  ],
});
```

## Setup Keypom Parameters

`setupKeypom` is the core of the Keypom wallet selector and is the only function you should know about. There are a ton of customizable features that you can make use of to tailor the user experience to your app's needs. At its core, the setup function takes the following parameters:

- `networkId`: Either `testnet` or `mainnet`.
- `signInContractId`: Which contract will be used to sign in users.
- `trialAccountSpecs`: If specified, trial accounts will be supported on the app. These specifications outline two aspects:
    1. How the URL should be constructed for the app to trigger the trial account sign in flow.
    2. Customizable options for the trial account modals including *all* the text such as titles, descriptions, buttons, placeholders etc. In addition, you can specify exactly which off-boarding wallets you'd like to support.
- `instantSignInSpecs`: If specified, trial accounts will be supported on the app. The instant sign in specs dictate how the URL should be constructed for the app to trigger the instant sign in flow.

### IPFS Customizations

For apps that wish to customize the Keypom parameters on a per page basis or even a per user basis, they can make use of IPFS CIDs. By adding a `?cid=` parameter to the URL, Keypom will fetch the parameters from the specified CID. The contents on IPFS must be JSON that match the Keypom parameters:

```json
{
  "networkId": "testnet", // Or "mainnet",
  "signInContractId": CONTRACT_ID,
  "trialAccountSpecs": {
    "url": "vandeley_industries.com/trial-sign-in/ACCOUNT_ID#SECRET_KEY",
    "modalOptions": KEYPOM_OPTIONS
  },
  "instantSignInSpecs": {
    "url": "vandeley_industries.com/instant-sign-in/ACCOUNT_ID#SECRET_KEY"
  }
}
```

An example CID can be found below:
```
bafkreidneri4ffymscahjprlapg4j62yleli73ncwdmopnkxpgczpusqn4
```

# Keypom Trial Accounts

Keypom Trial Accounts are an exciting new opportunity for Web3 apps to seamlessly onboard users whether they’re completely new to crypto or seasoned veterans. With the click of a link, users require no software, wallet setup, wallet connection, and are *instantly signed into apps* with their trial account, ready to make on-chain transactions. Unlike most other onboarding mechanisms, the entire experience can be embedded *directly in the app* to increase user retention and is entirely on-chain.

This technology is perfect for dApps of all sizes ranging from small indie to large enterprise applications.

- Trial Account [Demo](https://www.youtube.com/watch?v=p_NOcYbRlJw)

In order to support trial accounts, your app must have the `setupKeypom` function embedded within the wallet selector with the `trialAccountSpecs` parameter specified.

## Trial Account Specs

The trial account specifications allows the Keypom wallet selector to support trial accounts on your app. In order to trigger the sign in flow, the user must be on the correct URL. This URL is specified in the specifications as a string and should look like this:

```js
https://near.org/#trial-url/ACCOUNT_ID/SECRET_KEY
```

The URL *must* have the `ACCOUNT_ID` and `SECRET_KEY` placeholders.

As an example, if you wanted your trial users to sign in once they reached `https://near.org/#trial-url/`, and you wanted the account and secret key to be separated using `/`, your specs should look like this:

```js
trialAccountSpecs: {
    url: "https://near.org/#trial-url/ACCOUNT_ID/SECRET_KEY",
}
```

Alternatively, you could swap the `/` delimiter with a `#` instead:

```js
trialAccountSpecs: {
    url: "https://near.org/#trial-url/ACCOUNT_ID#SECRET_KEY",
}
```

> **NOTE:** The account ID must come first and the secret key must follow the delimiter. For unclaimed trial account linkdrops, the account ID will be the Keypom contract. For claimed trial account linkdrops, the account ID will be the account ID chosen by the user.

## Modal Options

The second field in the trial account specs is the `modalOptions`. This contains all the customizable options for the trial account modals as well as the wallets you want to support for user offboarding.

```js
export interface ModalCustomizations {
  wallets: OffboardingWallet[];
  theme?: Theme;
  beginTrial?: BeginTrialCustomizations,
  trialOver?: TrialOverCustomizations,
  invalidAction?: InvalidActionCustomizations,
  insufficientBalance?: InsufficientBalanceCustomizations,
}
```

#### Wallets

The only required field is `wallets`. This should be a list of valid domains that support trial account offboarding. Each of the wallets in the list will be displayed as a button once the trial is over.

```js
export interface OffboardingWallet {
  name: string;
  description: string;
  iconUrl: string;
  redirectUrl: string;
}
```

For each wallet, you can specify a name to display, a description, an image (in the form of a URL), and where to redirect the user to once the button is clicked. The redirect URL follows the same format as the trial account URL and should look like this:

```js
https://app.mynearwallet.com/linkdrop/ACCOUNT_ID/SECRET_KEY
```

The URL *must* have the `ACCOUNT_ID` and `SECRET_KEY` placeholders.

### Theme And CSS

The modal used by Keypom uses the same CSS as the official wallet selector modal behind the scenes. To learn how to customize the theme to match your app, see the selector's [documentation](https://github.com/near/wallet-selector/tree/main/packages/modal-ui#react--vue).

If you only wish to change the theme between light and dark mode, you can pass in a `theme` field in the modal options. This field should be either `light` or `dark`.

### Modal Text 

In addition to the modal style, you have complete control over the text that is displayed at each stage of the claiming process. To see the default text, see the [Default Text](#modal-default-text) section.

For the trial account creation process, there are currently 3 modals that can be customized:

1. Landing page: what the user sees when they first click the link

```bash
landing?: {
    title?: string;
    body?: string;
    fieldPlaceholder?: string;
    buttonText?: string;
    subText?: {
        landing?: string;
        invalidAccountId?: string;
        accountIdTaken?: string;
        accountIdAvailable?: string;
    }
},
```

2. Claiming: while the account is being created:
```bash
claiming?: {
    title?: string;
    body?: string;
},  
```

3. Claimed: once the account has been created:
```bash
claimed?: {
    title?: string;
    body?: string;
    buttonText?: string;
}
```

The next stage that can be customized is what the user sees once their trial is over and they need to choose a wallet to offboard to.

```bash
trialOver?: {
    mainBody?: {
        title?: string;
        body?: string;
        imageOne?: {
            title: string;
            body: string;
        },
        imageTwo?: {
            title: string;
            body: string;
        },
        button?: {
            url?: string;
            newTab?: boolean;
            text?: string;
        }
    },
    offboardingOptions?: {
        title?: string;
    }
}
```

You can change the titles, descriptions, button text / behaviour and more to tailor the experience to your app. Finally, you can change the text for when the user tries to perform an invalid action, or tries to spend more $NEAR than the account has available.

## Example Trial Account Integration

In the following example, you'll see how the trial account flow can be fully integrated into an application. The app has the domain `https://example.com` and the trial account modals should show up once the user lands on `https://example.com/trial-accounts`. In addition, the app doesn't want to expose the secret key in their analytics so they'll separate the account ID and secret key using a `#` instead of a `/`.

The app will also support MyNEARWallet offboarding and will change the default text for the landing modal when the trial begins.

```js
const NETWORK_ID = "testnet";
const CONTRACT_ID = "example.near";

export const KEYPOM_OPTIONS = {
  beginTrial: {
    landing: {
      title: "Welcome To My Cool Example App!",
    },
  },
  wallets: [
    {
      name: "MyNEARWallet",
      description: "Secure your account with a Seed Phrase",
      redirectUrl: "https://testnet.mynearwallet.com/linkdrop/ACCOUNT_ID/SECRET_KEY",
      iconUrl: "INSERT_ICON_URL_HERE"
    },
  ]
}

const selector = await setupWalletSelector({
  network: NETWORK_ID,
  modules: [
    setupMyNearWallet(),
    ...
    setupSender(),
    setupKeypom({ 
        networkId: NETWORK_ID, 
        signInContractId: CONTRACT_ID,
        trialAccountSpecs: {
            url: "https://example.com/trial-accounts/ACCOUNT_ID#SECRET_KEY",
            modalOptions: KEYPOM_OPTIONS
        }
    })
  ],
});
```

# Keypom Instant Sign In Experiences

Instant sign in experiences are a great way to reduce friction for users signing into applications. Currently, the sign in flow for a new user is as follows:
1. User creates an account.
2. They navigate to an application.
3. Sign-in is clicked.
4. The wallet selector modal is opened and the user needs to scroll to find their wallet.
5. The user clicks their wallet and is redirected to the wallet's website to approve a transaction.
6. The user is redirected back to the app and is signed in.

As NEAR pushes to abstract the crypto complexities and jargon away from the end user, this current approach is not scalable. Not only is there a huge amount of clicks and redirects which leads to a loss in conversion, but the user is also expected to know which wallet they own. This is a huge barrier to entry as often times, the wallet logic will be abstracted from the user as seen with SWEAT.

The flow that Keypom offers is as follows:
1. User creates an account.
2. User clicks discovers an application from their wallet.
3. User is instantly signed in and can start using the application.

This flow is much more seamless and removes all the redirects and wallet selector modal friction.

- Instant Sign-In [Demo](https://www.youtube.com/watch?v=p_NOcYbRlJw&feature=youtu.be)

In order to support instant sign in, your app must have the `setupKeypom` function embedded within the wallet selector with the `instantSignInSpecs` parameter specified.

## Instant Sign In Specs

The instant sign in specifications allows the Keypom wallet selector to support instant sign on experiences for your app. In order to trigger the sign in flow, the user must be on the correct URL. This URL is specified in the specifications as a string and should look like this:

```js
https://near.org/#trial-url/ACCOUNT_ID/SECRET_KEY/MODULE_ID
```

The URL *must* have the `ACCOUNT_ID`, `SECRET_KEY`, and `MODULE_ID` placeholders.

Behind the scenes, Keypom will take the secret key and use it to sign transactions on behalf of the account whenever they perform an action. Since this key is limited access, there needs to be a way to approve any transaction that requires full access. This is why the `MODULE_ID` field is present. This is the ID of the wallet that the user will be redirected to in order to approve any full access key required transactions.

Currently, Keypom supports:
- MyNEARWallet: `my-near-wallet`,
- NEAR Wallet: `near-wallet`,
- SWEAT Wallet: `sweat-wallet`

As an example, if you wanted to support instant sign in for users once they reached `https://near.org/#instant-url/`, and you wanted the account and secret key to be separated using `#`, but the module ID and secret key to be separated by `/`, your specs should look like this:

```js
instantSignInSpecs: {
    url: "https://near.org/#instant-url/ACCOUNT_ID#SECRET_KEY/MODULE_ID",
}
```

> **NOTE:** The account ID must come first followed by the secret key and then finally the module ID.

The wallet selector would then look as follows.

```js
const selector = await setupWalletSelector({
  network: NETWORK_ID,
  modules: [
    setupMyNearWallet(),
    ...
    setupSender(),
    setupKeypom({ 
        networkId: NETWORK_ID, 
        signInContractId: CONTRACT_ID,
        instantSignInSpecs: {
            url: "https://near.org/#instant-url/ACCOUNT_ID#SECRET_KEY/MODULE_ID"
        }
    })
  ],
});
```

From this point onwards, any app or wallet could create a limited access key for the contract that your app is using and then redirect the user to your instant sign in URL. An example could be that that account `benjiman.near` wants to use the `near.org` app and the contract being used there is `social.near`. Benji came from MyNEARWallet and so the URL would be:

```
https://near.org/#instant-url/benjiman.near#3C6rhKRWLFmho9bQo32EUmk9Ldx47paRSMUdaoR551EtcaNSPziave55HJosi71tfWSRQjjRrL4exfaBi9o7XKUG/my-near-wallet
```

At this point, Benji would be instantly signed into `near.org` and can start using the app. If anything requires a full access key, he would be redirected to MyNEARWallet to approve the transaction and come back.

# Contributing

First off, thanks for taking the time to contribute! Contributions are what makes the open-source community such an amazing place to learn, inspire, and create. Any contributions you make will benefit everybody else and are **greatly appreciated**.

Please try to create bug reports that are:

- _Reproducible._ Include steps to reproduce the problem.
- _Specific._ Include as much detail as possible: which version, what environment, etc.
- _Unique._ Do not duplicate existing opened issues.
- _Scoped to a Single Bug._ One bug per report.

You can use [markdownlint-cli](https://github.com/igorshubovych/markdownlint-cli) to check for common markdown style inconsistency.

# License

This project is licensed under the **GPL License**.
'''
'''--- packages/selector/lib/core/ext_wallets.d.ts ---
import { Near } from '@near-js/wallet-account';
import { FinalExecutionOutcome, Transaction as wsTransaction } from '@near-wallet-selector/core';
export declare const SUPPORTED_EXT_WALLET_DATA: {
    testnet: {
        "near-wallet": {
            baseUrl: string;
        };
        "my-near-wallet": {
            baseUrl: string;
        };
        "sweat-wallet": {};
    };
    mainnet: {
        "near-wallet": {
            baseUrl: string;
        };
        "my-near-wallet": {
            baseUrl: string;
        };
        "sweat-wallet": {};
    };
};
/**
 * Information to send NEAR wallet for signing transactions and redirecting the browser back to the calling application
 */
interface RequestSignTransactionsOptions {
    /** list of transactions to sign */
    transactions: wsTransaction[];
    moduleId: string;
    accountId: string;
    secretKey: string;
    near: Near;
}
/**
 * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.
 */
export declare const extSignAndSendTransactions: ({ transactions, moduleId, accountId, secretKey, near }: RequestSignTransactionsOptions) => Promise<FinalExecutionOutcome[]>;
export declare const nearWalletFAKSigning: (transactions: any, networkId: any, moduleId: any) => void;
export {};

'''
'''--- packages/selector/lib/core/ext_wallets.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.nearWalletFAKSigning = exports.extSignAndSendTransactions = exports.SUPPORTED_EXT_WALLET_DATA = void 0;
var core_1 = require("@keypom/core");
var accounts_1 = require("@near-js/accounts");
var crypto_1 = require("@near-js/crypto");
var transactions_1 = require("@near-js/transactions");
var borsh_1 = require("borsh");
var selector_utils_1 = require("../utils/selector-utils");
var types_1 = require("./types");
exports.SUPPORTED_EXT_WALLET_DATA = {
    "testnet": {
        "near-wallet": {
            baseUrl: "https://wallet.testnet.near.org",
        },
        "my-near-wallet": {
            baseUrl: "https://testnet.mynearwallet.com",
        },
        "sweat-wallet": {}
    },
    "mainnet": {
        "near-wallet": {
            baseUrl: "https://wallet.near.org",
        },
        "my-near-wallet": {
            baseUrl: "https://app.mynearwallet.com",
        },
        "sweat-wallet": {}
    }
};
/**
 * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.
 */
var extSignAndSendTransactions = function (_a) {
    var transactions = _a.transactions, moduleId = _a.moduleId, accountId = _a.accountId, secretKey = _a.secretKey, near = _a.near;
    return __awaiter(void 0, void 0, void 0, function () {
        var fakRequiredTxns, responses, account, i, txn, mappedActions, pk, transaction, accessKey, canExecuteTxn, _b, _c, e_1;
        return __generator(this, function (_d) {
            switch (_d.label) {
                case 0:
                    fakRequiredTxns = [];
                    responses = [];
                    account = new accounts_1.Account(near.connection, accountId);
                    i = 0;
                    _d.label = 1;
                case 1:
                    if (!(i < transactions.length)) return [3 /*break*/, 11];
                    txn = transactions[i];
                    mappedActions = txn.actions.map(function (a) {
                        var fcAction = a;
                        return transactions_1.actionCreators.functionCall(fcAction.params.methodName, (0, transactions_1.stringifyJsonOrBytes)(fcAction.params.args), fcAction.params.gas, fcAction.params.deposit);
                    });
                    pk = crypto_1.PublicKey.from((0, core_1.getPubFromSecret)(secretKey));
                    return [4 /*yield*/, (0, core_1.convertBasicTransaction)({
                            txnInfo: {
                                receiverId: txn.receiverId,
                                signerId: txn.signerId,
                                actions: mappedActions
                            },
                            signerId: accountId,
                            signerPk: pk,
                        })];
                case 2:
                    transaction = _d.sent();
                    return [4 /*yield*/, near.connection.provider.query("access_key/".concat(accountId, "/").concat(pk), '')];
                case 3:
                    accessKey = _d.sent();
                    return [4 /*yield*/, (0, selector_utils_1.keyHasPermissionForTransaction)(accessKey, txn.receiverId, mappedActions)];
                case 4:
                    canExecuteTxn = _d.sent();
                    if (!canExecuteTxn) return [3 /*break*/, 9];
                    _d.label = 5;
                case 5:
                    _d.trys.push([5, 7, , 8]);
                    _c = (_b = responses).push;
                    return [4 /*yield*/, account.signAndSendTransaction(transaction)];
                case 6:
                    _c.apply(_b, [_d.sent()]);
                    return [3 /*break*/, 8];
                case 7:
                    e_1 = _d.sent();
                    fakRequiredTxns.push(transaction);
                    return [3 /*break*/, 8];
                case 8: return [3 /*break*/, 10];
                case 9:
                    fakRequiredTxns.push(transaction);
                    _d.label = 10;
                case 10:
                    i++;
                    return [3 /*break*/, 1];
                case 11:
                    if (fakRequiredTxns.length > 0) {
                        switch (moduleId) {
                            case 'my-near-wallet':
                            case 'near-wallet':
                                (0, exports.nearWalletFAKSigning)(fakRequiredTxns, near.config.networkId, moduleId);
                                break;
                            case 'sweat-wallet':
                                console.warn('Sweat wallet does not support FAK signing yet');
                                return [2 /*return*/, [types_1.FAILED_EXECUTION_OUTCOME]];
                            default:
                                console.warn('Unsupported wallet module: ', moduleId);
                                return [2 /*return*/, [types_1.FAILED_EXECUTION_OUTCOME]];
                        }
                    }
                    return [2 /*return*/, responses];
            }
        });
    });
};
exports.extSignAndSendTransactions = extSignAndSendTransactions;
var nearWalletFAKSigning = function (transactions, networkId, moduleId) {
    var currentUrl = new URL(window.location.href);
    var baseUrl = exports.SUPPORTED_EXT_WALLET_DATA[networkId][moduleId].baseUrl;
    var newUrl = new URL('sign', baseUrl);
    newUrl.searchParams.set('transactions', transactions
        .map(function (transaction) { return (0, borsh_1.serialize)(transactions_1.SCHEMA, transaction); })
        .map(function (serialized) { return Buffer.from(serialized).toString('base64'); })
        .join(','));
    newUrl.searchParams.set('callbackUrl', currentUrl.href);
    window.location.assign(newUrl.toString());
};
exports.nearWalletFAKSigning = nearWalletFAKSigning;

'''
'''--- packages/selector/lib/core/setup.d.ts ---
import type { WalletModuleFactory } from '@near-wallet-selector/core';
import { KeypomParams, KeypomWalletInstant } from './types';
export declare function setupKeypom({ trialAccountSpecs, instantSignInSpecs, networkId, signInContractId }: KeypomParams): WalletModuleFactory<KeypomWalletInstant>;

'''
'''--- packages/selector/lib/core/setup.js ---
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupKeypom = void 0;
var modal_types_1 = require("../modal/src/lib/modal.types");
var types_1 = require("./types");
var wallet_1 = require("./wallet");
var Keypom = function (_a) {
    var store = _a.store, logger = _a.logger, keypomWallet = _a.keypomWallet;
    return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_b) {
            // return the wallet interface for wallet-selector
            return [2 /*return*/, {
                    get networkId() {
                        return keypomWallet.near.connection.networkId;
                    },
                    getContractId: function () {
                        return keypomWallet.getContractId();
                    },
                    // async getAccount() {
                    // 	return keypomWallet.getAccount();
                    // },
                    showModal: function (modalType) {
                        if (modalType === void 0) { modalType = { id: modal_types_1.MODAL_TYPE_IDS.TRIAL_OVER }; }
                        keypomWallet.showModal(modalType);
                    },
                    getAccounts: function () {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                logger.log('Keypom:account');
                                return [2 /*return*/, keypomWallet.getAccounts()];
                            });
                        });
                    },
                    switchAccount: function (id) {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, keypomWallet.switchAccount(id)];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            });
                        });
                    },
                    getAccountId: function () {
                        logger.log('Keypom:getAccountId');
                        return keypomWallet.getAccountId();
                    },
                    isSignedIn: function () {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        logger.log('Keypom:isSignedIn');
                                        return [4 /*yield*/, keypomWallet.isSignedIn()];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            });
                        });
                    },
                    getAvailableBalance: function () {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        logger.log('Keypom:isSignedIn');
                                        return [4 /*yield*/, keypomWallet.getAvailableBalance()];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            });
                        });
                    },
                    verifyOwner: function () {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                throw Error('KeypomWallet:verifyOwner is deprecated');
                            });
                        });
                    },
                    signIn: function () {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        logger.log('Keypom:signIn');
                                        return [4 /*yield*/, keypomWallet.signIn()];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            });
                        });
                    },
                    signOut: function () {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        logger.log('Keypom:signOut');
                                        return [4 /*yield*/, keypomWallet.signOut()];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            });
                        });
                    },
                    signAndSendTransaction: function (params) {
                        return __awaiter(this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, keypomWallet.signAndSendTransaction(params)];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            });
                        });
                    },
                    signAndSendTransactions: function (params) {
                        return __awaiter(this, void 0, void 0, function () {
                            var transactions;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0:
                                        transactions = params.transactions.map(function (tx) {
                                            return __assign(__assign({}, tx), { signerId: tx.signerId || keypomWallet.getAccountId() });
                                        });
                                        logger.log('Keypom:signAndSendTransactions', params);
                                        return [4 /*yield*/, keypomWallet.signAndSendTransactions({ transactions: transactions })];
                                    case 1: return [2 /*return*/, _a.sent()];
                                }
                            });
                        });
                    },
                }];
        });
    });
};
function setupKeypom(_a) {
    var _this = this;
    var trialAccountSpecs = _a.trialAccountSpecs, instantSignInSpecs = _a.instantSignInSpecs, networkId = _a.networkId, signInContractId = _a.signInContractId;
    return function () { return __awaiter(_this, void 0, void 0, function () {
        var keypomWallet, shouldSignIn;
        var _this = this;
        return __generator(this, function (_a) {
            // Ensure that the passed in arguments are of type KeypomParams
            if (!(0, types_1.isKeypomParams)({ signInContractId: signInContractId, networkId: networkId, trialAccountSpecs: trialAccountSpecs, instantSignInSpecs: instantSignInSpecs })) {
                console.warn('KeypomWallet: Invalid KeypomParams passed in. Please check the docs for the correct format.');
                return [2 /*return*/, null];
            }
            if (!signInContractId || !networkId || !(instantSignInSpecs || trialAccountSpecs)) {
                console.warn('KeypomWallet: signInContractId, networkId and either instant sign in specs or trial account specs are required to use the KeypomWallet.');
                return [2 /*return*/, null];
            }
            if (trialAccountSpecs && !(trialAccountSpecs.url.includes('ACCOUNT_ID') || trialAccountSpecs.url.includes('SECRET_KEY'))) {
                console.warn('KeypomWallet: trial account specs must include ACCOUNT_ID and SECRET_KEY in url');
                return [2 /*return*/, null];
            }
            if (instantSignInSpecs && !(instantSignInSpecs.url.includes('ACCOUNT_ID') || instantSignInSpecs.url.includes('SECRET_KEY'))) {
                console.warn('KeypomWallet: trial account specs must include ACCOUNT_ID');
                return [2 /*return*/, null];
            }
            keypomWallet = new wallet_1.KeypomWallet({
                signInContractId: signInContractId,
                networkId: networkId,
                trialAccountSpecs: trialAccountSpecs,
                instantSignInSpecs: instantSignInSpecs
            });
            shouldSignIn = keypomWallet.checkValidTrialInfo();
            console.log('shouldSignIn: ', shouldSignIn);
            return [2 /*return*/, {
                    id: types_1.KEYPOM_MODULE_ID,
                    type: 'instant-link',
                    metadata: {
                        name: 'Keypom Account',
                        description: null,
                        iconUrl: '',
                        deprecated: false,
                        available: true,
                        contractId: signInContractId,
                        runOnStartup: shouldSignIn,
                    },
                    init: function (config) { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            return [2 /*return*/, Keypom(__assign(__assign({}, config), { keypomWallet: keypomWallet }))];
                        });
                    }); },
                }];
        });
    }); };
}
exports.setupKeypom = setupKeypom;

'''
'''--- packages/selector/lib/core/types.d.ts ---
import { InstantLinkWallet, NetworkId } from '@near-wallet-selector/core';
import BN from 'bn.js';
import { KeypomWallet } from './wallet';
import { FinalExecutionOutcome } from '@near-js/types';
import { ModalCustomizations } from '../modal/src';
export declare const FAILED_EXECUTION_OUTCOME: FinalExecutionOutcome;
export declare const KEYPOM_MODULE_ID = "keypom";
export interface InternalInstantSignInSpecs extends InstantSignInSpecs {
    moduleId?: string;
    baseUrl?: string;
    delimiter?: string;
    moduleDelimiter?: string;
}
export interface InternalTrialSignInSpecs extends TrialSignInSpecs {
    isMappingAccount: boolean;
    baseUrl?: string;
    delimiter?: string;
}
export interface InstantSignInSpecs {
    url: string;
}
export interface TrialSignInSpecs {
    url: string;
    modalOptions: ModalCustomizations;
}
export interface SignInOptions {
    contractId?: string;
    allowance?: string;
    methodNames?: string[];
}
export interface KeypomInitializeOptions {
    keypomWallet: KeypomWallet;
}
export interface KeypomParams {
    networkId: NetworkId;
    signInContractId: string;
    trialAccountSpecs?: TrialSignInSpecs;
    instantSignInSpecs?: InstantSignInSpecs;
}
export declare const isTrialSignInSpecs: (obj: any) => obj is TrialSignInSpecs;
export declare const isInstantSignInSpecs: (obj: any) => obj is InstantSignInSpecs;
export declare const isKeypomParams: (obj: any) => obj is KeypomParams;
export type KeypomWalletInstant = InstantLinkWallet & {
    networkId: string;
    getContractId(): string;
    switchAccount(id: string): Promise<void>;
    getAccountId(): string;
    isSignedIn: () => Promise<boolean>;
    getAvailableBalance: () => Promise<BN>;
    showModal(): any;
};

'''
'''--- packages/selector/lib/core/types.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isKeypomParams = exports.isInstantSignInSpecs = exports.isTrialSignInSpecs = exports.KEYPOM_MODULE_ID = exports.FAILED_EXECUTION_OUTCOME = void 0;
exports.FAILED_EXECUTION_OUTCOME = {
    status: {
        Failure: {
            error_message: 'Invalid Trial Action',
            error_type: 'keypom-trial-error'
        }
    },
    transaction: {},
    transaction_outcome: {
        id: '',
        outcome: {
            logs: [],
            receipt_ids: [],
            tokens_burnt: '0',
            executor_id: '',
            gas_burnt: 0,
            status: {
                Failure: {
                    error_message: 'Invalid Trial Action',
                    error_type: 'keypom-trial-error'
                }
            },
        }
    },
    receipts_outcome: [{
            id: '',
            outcome: {
                logs: [],
                receipt_ids: [],
                gas_burnt: 0,
                tokens_burnt: '0',
                executor_id: '',
                status: {
                    Failure: {
                        error_message: 'Invalid Trial Action',
                        error_type: 'keypom-trial-error'
                    }
                },
            }
        }]
};
exports.KEYPOM_MODULE_ID = 'keypom';
var isTrialSignInSpecs = function (obj) {
    return typeof obj === 'object' && obj !== null &&
        obj.hasOwnProperty('url') && typeof obj.url === 'string' &&
        obj.hasOwnProperty('modalOptions') && typeof obj.modalOptions === 'object' && obj.modalOptions !== null;
};
exports.isTrialSignInSpecs = isTrialSignInSpecs;
var isInstantSignInSpecs = function (obj) {
    return typeof obj === 'object' && obj !== null &&
        obj.hasOwnProperty('url') && typeof obj.url === 'string';
};
exports.isInstantSignInSpecs = isInstantSignInSpecs;
var isKeypomParams = function (obj) {
    return typeof obj === 'object' && obj !== null &&
        obj.hasOwnProperty('networkId') && (obj.networkId === 'testnet' || obj.networkId === 'mainnet') &&
        obj.hasOwnProperty('signInContractId') && typeof obj.signInContractId === 'string' &&
        (obj.hasOwnProperty('trialAccountSpecs') || obj.hasOwnProperty('instantSignInSpecs')) &&
        (!obj.hasOwnProperty('trialAccountSpecs') || (0, exports.isTrialSignInSpecs)(obj.trialAccountSpecs)) &&
        (!obj.hasOwnProperty('instantSignInSpecs') || (0, exports.isInstantSignInSpecs)(obj.instantSignInSpecs));
};
exports.isKeypomParams = isKeypomParams;

'''
'''--- packages/selector/lib/core/wallet.d.ts ---
import { Account } from '@near-js/accounts';
import { BrowserLocalStorageKeyStore } from '@near-js/keystores-browser';
import { FinalExecutionOutcome } from '@near-js/types';
import { Near } from '@near-js/wallet-account';
import { InstantLinkWalletBehaviour, Transaction } from '@near-wallet-selector/core';
import BN from 'bn.js';
import { KeypomTrialModal } from '../modal/src';
import { InstantSignInSpecs, InternalInstantSignInSpecs, InternalTrialSignInSpecs, TrialSignInSpecs } from './types';
export declare class KeypomWallet implements InstantLinkWalletBehaviour {
    accountId?: string;
    secretKey?: string;
    moduleId?: string;
    signInContractId: string;
    near: Near;
    keyStore: BrowserLocalStorageKeyStore;
    trialAccountSpecs?: InternalTrialSignInSpecs;
    instantSignInSpecs?: InternalInstantSignInSpecs;
    modal?: KeypomTrialModal;
    constructor({ signInContractId, networkId, trialAccountSpecs, instantSignInSpecs, }: {
        signInContractId: string;
        networkId: string;
        trialAccountSpecs?: TrialSignInSpecs;
        instantSignInSpecs?: InstantSignInSpecs;
    });
    getContractId(): string;
    getAccountId(): string;
    isSignedIn(): Promise<boolean>;
    signInTrialAccount(accountId: any, secretKey: any): Promise<Account[]>;
    signInInstantAccount(accountId: any, secretKey: any, moduleId: any): Promise<Account[]>;
    signIn(): Promise<Account[]>;
    signOut(): Promise<void>;
    signAndSendTransaction(params: any): Promise<FinalExecutionOutcome>;
    signAndSendTransactions(params: {
        transactions: Transaction[];
    }): Promise<FinalExecutionOutcome[]>;
    showModal: (modalType?: {
        id: string;
    }) => void;
    checkValidTrialInfo: () => boolean;
    verifyOwner(): Promise<void>;
    getAvailableBalance(id?: string): Promise<BN>;
    getAccounts(): Promise<Account[]>;
    switchAccount(id: string): Promise<void>;
    private internalSignIn;
    private assertSignedIn;
    private setSpecsFromKeypomParams;
}

'''
'''--- packages/selector/lib/core/wallet.js ---
"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeypomWallet = void 0;
var core_1 = require("@keypom/core");
var accounts_1 = require("@near-js/accounts");
var crypto_1 = require("@near-js/crypto");
var keystores_browser_1 = require("@near-js/keystores-browser");
var wallet_account_1 = require("@near-js/wallet-account");
var bn_js_1 = __importDefault(require("bn.js"));
var src_1 = require("../modal/src");
var modal_types_1 = require("../modal/src/lib/modal.types");
var selector_utils_1 = require("../utils/selector-utils");
var ext_wallets_1 = require("./ext_wallets");
var types_1 = require("./types");
var TRIAL_URL_REGEX = new RegExp("(.*)ACCOUNT_ID(.*)SECRET_KEY");
var INSTANT_URL_REGEX = new RegExp("(.*)ACCOUNT_ID(.*)SECRET_KEY(.*)MODULE_ID");
var KeypomWallet = /** @class */ (function () {
    function KeypomWallet(_a) {
        var signInContractId = _a.signInContractId, networkId = _a.networkId, trialAccountSpecs = _a.trialAccountSpecs, instantSignInSpecs = _a.instantSignInSpecs;
        var _this = this;
        this.showModal = function (modalType) {
            if (modalType === void 0) { modalType = { id: modal_types_1.MODAL_TYPE_IDS.TRIAL_OVER }; }
            console.log('modalType for show modal: ', modalType);
            _this.modal.show(modalType);
        };
        this.checkValidTrialInfo = function () {
            var _a, _b;
            var instantSignInData = ((_a = _this.instantSignInSpecs) === null || _a === void 0 ? void 0 : _a.baseUrl) !== undefined ? (0, selector_utils_1.parseInstantSignInUrl)(_this.instantSignInSpecs) : undefined;
            var trialData = ((_b = _this.trialAccountSpecs) === null || _b === void 0 ? void 0 : _b.baseUrl) !== undefined ? (0, selector_utils_1.parseTrialUrl)(_this.trialAccountSpecs) : undefined;
            var isCIDPresent = window.location.href.split("?cid=").length > 1;
            return instantSignInData !== undefined || trialData !== undefined || (0, selector_utils_1.getLocalStorageKeypomEnv)() !== null || isCIDPresent;
        };
        console.log('Initializing Keypom');
        this.signInContractId = signInContractId;
        this.keyStore = new keystores_browser_1.BrowserLocalStorageKeyStore();
        this.near = new wallet_account_1.Near(__assign(__assign({}, core_1.networks[networkId]), { deps: { keyStore: this.keyStore } }));
        // Only setup the modal if the CID is not present (as to not set it up twice).
        // In the case that the CID is present, it will be setup in `signIn()`
        var isCIDPresent = window.location.href.split("?cid=").length > 1;
        this.setSpecsFromKeypomParams({ trialAccountSpecs: trialAccountSpecs, instantSignInSpecs: instantSignInSpecs, shouldSetupModal: !isCIDPresent });
    }
    KeypomWallet.prototype.getContractId = function () {
        return this.signInContractId;
    };
    KeypomWallet.prototype.getAccountId = function () {
        this.assertSignedIn();
        return this.accountId;
    };
    KeypomWallet.prototype.isSignedIn = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, this.accountId !== undefined && this.accountId !== null];
            });
        });
    };
    KeypomWallet.prototype.signInTrialAccount = function (accountId, secretKey) {
        return __awaiter(this, void 0, void 0, function () {
            var isOriginalLink, isUnclaimed, e_1, keyInfo, keyPerms, isAdding, e_2;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        isOriginalLink = (0, selector_utils_1.updateKeypomContractIfValid)(accountId);
                        console.log('isOriginalLink: ', isOriginalLink);
                        if (!isOriginalLink) return [3 /*break*/, 7];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 6, , 7]);
                        return [4 /*yield*/, (0, core_1.isUnclaimedTrialDrop)({ keypomContractId: accountId, secretKey: secretKey })];
                    case 2:
                        isUnclaimed = _a.sent();
                        console.log('isUnclaimed: ', isUnclaimed);
                        if (!(isUnclaimed === true)) return [3 /*break*/, 3];
                        this.modal.show({
                            id: modal_types_1.MODAL_TYPE_IDS.BEGIN_TRIAL,
                            meta: {
                                secretKey: secretKey,
                                redirectUrlBase: this.trialAccountSpecs.baseUrl,
                                delimiter: this.trialAccountSpecs.delimiter,
                            }
                        });
                        return [2 /*return*/, []];
                    case 3:
                        // If the drop is claimed, we should attempt to recover the drop
                        console.log('DROP IS CLAIMED. RECOVERY TODO');
                        return [4 /*yield*/, (0, selector_utils_1.getAccountFromMap)(secretKey)];
                    case 4:
                        accountId = _a.sent();
                        _a.label = 5;
                    case 5: return [3 /*break*/, 7];
                    case 6:
                        e_1 = _a.sent();
                        console.log('e checking if drop is from keypom: ', e_1);
                        return [3 /*break*/, 7];
                    case 7:
                        _a.trys.push([7, 11, , 12]);
                        return [4 /*yield*/, (0, core_1.viewAccessKeyData)({ accountId: accountId, secretKey: secretKey })];
                    case 8:
                        keyInfo = _a.sent();
                        keyPerms = keyInfo.permission.FunctionCall;
                        if (!(keyPerms.receiver_id === accountId && keyPerms.method_names.includes('execute'))) return [3 /*break*/, 10];
                        return [4 /*yield*/, (0, selector_utils_1.addUserToMappingContract)(accountId, secretKey)];
                    case 9:
                        isAdding = _a.sent();
                        if (isAdding) {
                            this.trialAccountSpecs.isMappingAccount = true;
                        }
                        return [2 /*return*/, this.internalSignIn(accountId, secretKey, types_1.KEYPOM_MODULE_ID)];
                    case 10: return [3 /*break*/, 12];
                    case 11:
                        e_2 = _a.sent();
                        console.log('e: ', e_2);
                        return [3 /*break*/, 12];
                    case 12: 
                    // Invalid local storage info so return nothing
                    return [2 /*return*/, []];
                }
            });
        });
    };
    KeypomWallet.prototype.signInInstantAccount = function (accountId, secretKey, moduleId) {
        return __awaiter(this, void 0, void 0, function () {
            var account, allKeys, pk_1, keyInfoView, e_3;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 2, , 3]);
                        account = new accounts_1.Account(this.near.connection, accountId);
                        return [4 /*yield*/, account.getAccessKeys()];
                    case 1:
                        allKeys = _a.sent();
                        pk_1 = (0, core_1.getPubFromSecret)(secretKey);
                        keyInfoView = allKeys.find(function (_a) {
                            var public_key = _a.public_key;
                            return public_key === pk_1;
                        });
                        if (keyInfoView) {
                            return [2 /*return*/, this.internalSignIn(accountId, secretKey, moduleId)];
                        }
                        return [3 /*break*/, 3];
                    case 2:
                        e_3 = _a.sent();
                        console.log('e: ', e_3);
                        return [3 /*break*/, 3];
                    case 3: return [2 /*return*/, []];
                }
            });
        });
    };
    KeypomWallet.prototype.signIn = function () {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function () {
            var ipfsData, instantSignInData, trialData, curEnvData, _c, accountId, secretKey, moduleId;
            return __generator(this, function (_d) {
                switch (_d.label) {
                    case 0: return [4 /*yield*/, (0, core_1.initKeypom)({
                            network: this.near.connection.networkId
                        })];
                    case 1:
                        _d.sent();
                        return [4 /*yield*/, (0, selector_utils_1.parseIPFSDataFromURL)()];
                    case 2:
                        ipfsData = _d.sent();
                        if (ipfsData !== undefined) {
                            this.setSpecsFromKeypomParams({
                                trialAccountSpecs: ipfsData.trialAccountSpecs,
                                instantSignInSpecs: ipfsData.instantSignInSpecs,
                                shouldSetupModal: true
                            });
                        }
                        instantSignInData = ((_a = this.instantSignInSpecs) === null || _a === void 0 ? void 0 : _a.baseUrl) !== undefined ? (0, selector_utils_1.parseInstantSignInUrl)(this.instantSignInSpecs) : undefined;
                        console.log('instantSignInData: ', instantSignInData);
                        if (instantSignInData !== undefined) {
                            if (ext_wallets_1.SUPPORTED_EXT_WALLET_DATA[this.near.connection.networkId][instantSignInData.moduleId] === undefined) {
                                console.warn("Module ID ".concat(instantSignInData.moduleId, " is not supported on ").concat(this.near.connection.networkId, "."));
                                return [2 /*return*/, []];
                            }
                            return [2 /*return*/, this.signInInstantAccount(instantSignInData.accountId, instantSignInData.secretKey, instantSignInData.moduleId)];
                        }
                        trialData = ((_b = this.trialAccountSpecs) === null || _b === void 0 ? void 0 : _b.baseUrl) !== undefined ? (0, selector_utils_1.parseTrialUrl)(this.trialAccountSpecs) : undefined;
                        console.log('trialData: ', trialData);
                        if (trialData !== undefined) {
                            return [2 /*return*/, this.signInTrialAccount(trialData.accountId, trialData.secretKey)];
                        }
                        curEnvData = (0, selector_utils_1.getLocalStorageKeypomEnv)();
                        // If there is any data in local storage, default to that otherwise return empty array
                        if (curEnvData !== null) {
                            _c = JSON.parse(curEnvData), accountId = _c.accountId, secretKey = _c.secretKey, moduleId = _c.moduleId;
                            return [2 /*return*/, this.internalSignIn(accountId, secretKey, moduleId)];
                        }
                        return [2 /*return*/, []];
                }
            });
        });
    };
    KeypomWallet.prototype.signOut = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (this.accountId === undefined || this.accountId === null) {
                            throw new Error('Wallet is already signed out');
                        }
                        this.accountId = this.secretKey = this.moduleId = undefined;
                        return [4 /*yield*/, this.keyStore.removeKey(this.near.connection.networkId, this.accountId)];
                    case 1:
                        _a.sent();
                        localStorage.removeItem("".concat(selector_utils_1.KEYPOM_LOCAL_STORAGE_KEY, ":envData"));
                        return [2 /*return*/];
                }
            });
        });
    };
    KeypomWallet.prototype.signAndSendTransaction = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var receiverId, actions, res, e_4;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.assertSignedIn();
                        console.log('sign and send txn params: ', params);
                        receiverId = params.receiverId, actions = params.actions;
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        return [4 /*yield*/, this.signAndSendTransactions({
                                transactions: [
                                    {
                                        signerId: this.accountId,
                                        receiverId: receiverId,
                                        actions: actions,
                                    },
                                ],
                            })];
                    case 2:
                        res = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_4 = _a.sent();
                        /// user cancelled or near network error
                        console.warn(e_4);
                        return [3 /*break*/, 4];
                    case 4: return [2 /*return*/, res[0]];
                }
            });
        });
    };
    KeypomWallet.prototype.signAndSendTransactions = function (params) {
        return __awaiter(this, void 0, void 0, function () {
            var transactions, res, e_5;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.log('sign and send txns params inner: ', params);
                        this.assertSignedIn();
                        transactions = params.transactions;
                        res = [];
                        if (!(this.moduleId === types_1.KEYPOM_MODULE_ID)) return [3 /*break*/, 5];
                        _a.label = 1;
                    case 1:
                        _a.trys.push([1, 3, , 4]);
                        if (!this.trialAccountSpecs.isMappingAccount) {
                            (0, selector_utils_1.addUserToMappingContract)(this.accountId, this.secretKey);
                        }
                        return [4 /*yield*/, (0, core_1.trialSignAndSendTxns)({
                                trialAccountId: this.accountId,
                                trialAccountSecretKey: this.secretKey,
                                txns: transactions
                            })];
                    case 2:
                        res = _a.sent();
                        return [3 /*break*/, 4];
                    case 3:
                        e_5 = _a.sent();
                        console.log("e: ".concat(JSON.stringify(e_5)));
                        switch (e_5) {
                            case core_1.TRIAL_ERRORS.EXIT_EXPECTED: {
                                this.modal.show({
                                    id: modal_types_1.MODAL_TYPE_IDS.TRIAL_OVER,
                                    meta: {
                                        accountId: this.accountId,
                                        secretKey: this.secretKey
                                    }
                                });
                                break;
                            }
                            case core_1.TRIAL_ERRORS.INVALID_ACTION: {
                                this.modal.show({ id: modal_types_1.MODAL_TYPE_IDS.ACTION_ERROR });
                                break;
                            }
                            case core_1.TRIAL_ERRORS.INSUFFICIENT_BALANCE: {
                                this.modal.show({ id: modal_types_1.MODAL_TYPE_IDS.INSUFFICIENT_BALANCE });
                                break;
                            }
                            default: {
                                console.log('Unidentified error when signing txn: ', e_5);
                                break;
                            }
                        }
                        return [2 /*return*/, [types_1.FAILED_EXECUTION_OUTCOME]];
                    case 4: return [3 /*break*/, 7];
                    case 5: return [4 /*yield*/, (0, ext_wallets_1.extSignAndSendTransactions)({
                            transactions: transactions,
                            moduleId: this.moduleId,
                            accountId: this.accountId,
                            secretKey: this.secretKey,
                            near: this.near
                        })];
                    case 6: return [2 /*return*/, _a.sent()];
                    case 7:
                        console.log('res sign & send txn: ', res);
                        return [2 /*return*/, res];
                }
            });
        });
    };
    KeypomWallet.prototype.verifyOwner = function () {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                throw Error('KeypomWallet:verifyOwner is deprecated');
            });
        });
    };
    KeypomWallet.prototype.getAvailableBalance = function (id) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                // TODO: get access key allowance
                return [2 /*return*/, new bn_js_1.default(0)];
            });
        });
    };
    KeypomWallet.prototype.getAccounts = function () {
        return __awaiter(this, void 0, void 0, function () {
            var accountObj;
            return __generator(this, function (_a) {
                if (this.accountId != undefined && this.accountId != null) {
                    accountObj = new accounts_1.Account(this.near.connection, this.accountId);
                    return [2 /*return*/, [accountObj]];
                }
                return [2 /*return*/, []];
            });
        });
    };
    KeypomWallet.prototype.switchAccount = function (id) {
        return __awaiter(this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/];
            });
        });
    };
    KeypomWallet.prototype.internalSignIn = function (accountId, secretKey, moduleId) {
        return __awaiter(this, void 0, void 0, function () {
            var dataToWrite, accountObj;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        console.log("internalSignIn accountId ".concat(accountId, " secretKey ").concat(secretKey, " moduleId ").concat(moduleId));
                        this.accountId = accountId;
                        this.secretKey = secretKey;
                        this.moduleId = moduleId;
                        dataToWrite = {
                            accountId: accountId,
                            secretKey: secretKey,
                            moduleId: moduleId
                        };
                        (0, selector_utils_1.setLocalStorageKeypomEnv)(dataToWrite);
                        return [4 /*yield*/, this.keyStore.setKey(this.near.connection.networkId, accountId, crypto_1.KeyPair.fromString(secretKey))];
                    case 1:
                        _a.sent();
                        accountObj = new accounts_1.Account(this.near.connection, accountId);
                        return [2 /*return*/, [accountObj]];
                }
            });
        });
    };
    KeypomWallet.prototype.assertSignedIn = function () {
        if (!this.accountId) {
            throw new Error('Wallet not signed in');
        }
    };
    KeypomWallet.prototype.setSpecsFromKeypomParams = function (_a) {
        var trialAccountSpecs = _a.trialAccountSpecs, instantSignInSpecs = _a.instantSignInSpecs, shouldSetupModal = _a.shouldSetupModal;
        var trialSpecs = undefined;
        if (trialAccountSpecs !== undefined) {
            // Get the base URL and delimiter by splitting the URL using ACCOUNT_ID and SECRET_KEY
            var matches = trialAccountSpecs.url.match(TRIAL_URL_REGEX);
            var baseUrl = matches === null || matches === void 0 ? void 0 : matches[1];
            var delimiter = matches === null || matches === void 0 ? void 0 : matches[2];
            trialSpecs = __assign(__assign({}, trialAccountSpecs), { isMappingAccount: false, baseUrl: baseUrl, delimiter: delimiter });
            if (shouldSetupModal) {
                this.modal = (0, src_1.setupModal)(trialAccountSpecs.modalOptions);
            }
        }
        this.trialAccountSpecs = trialSpecs;
        var instantSpecs = undefined;
        if (instantSignInSpecs !== undefined) {
            // Get the base URL and delimiter by splitting the URL using ACCOUNT_ID and SECRET_KEY
            var matches = instantSignInSpecs.url.match(INSTANT_URL_REGEX);
            var baseUrl = matches === null || matches === void 0 ? void 0 : matches[1];
            var delimiter = matches === null || matches === void 0 ? void 0 : matches[2];
            var moduleDelimiter = matches === null || matches === void 0 ? void 0 : matches[3];
            instantSpecs = __assign(__assign({}, instantSignInSpecs), { baseUrl: baseUrl, delimiter: delimiter, moduleDelimiter: moduleDelimiter });
        }
        this.instantSignInSpecs = instantSpecs;
    };
    return KeypomWallet;
}());
exports.KeypomWallet = KeypomWallet;

'''
'''--- packages/selector/lib/index.d.ts ---
export type { KeypomWallet } from './core/wallet';
export { setupKeypom } from './core/setup';

'''
'''--- packages/selector/lib/index.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupKeypom = void 0;
var setup_1 = require("./core/setup");
Object.defineProperty(exports, "setupKeypom", { enumerable: true, get: function () { return setup_1.setupKeypom; } });

'''
'''--- packages/selector/lib/modal/src/index.d.ts ---
export { setupModal } from './lib/modal';
export type { KeypomTrialModal, ModalCustomizations, Theme } from './lib/modal.types';

'''
'''--- packages/selector/lib/modal/src/index.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupModal = void 0;
var modal_1 = require("./lib/modal");
Object.defineProperty(exports, "setupModal", { enumerable: true, get: function () { return modal_1.setupModal; } });

'''
'''--- packages/selector/lib/modal/src/lib/components/BeginTrial.d.ts ---
import React from "react";
import { BeginTrialCustomizations } from "../modal.types";
/**
 * regex for the body of an account not including TLA and not allowing subaccount
 */
export declare const accountAddressPatternNoSubaccount: RegExp;
interface BeginTrialProps {
    customizations?: BeginTrialCustomizations;
    secretKey: string;
    redirectUrlBase: string;
    delimiter: string;
    hide: () => void;
}
export declare const BeginTrial: React.FC<BeginTrialProps>;
export {};

'''
'''--- packages/selector/lib/modal/src/lib/components/BeginTrial.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.BeginTrial = exports.accountAddressPatternNoSubaccount = void 0;
var react_1 = __importStar(require("react"));
var modal_types_1 = require("../modal.types");
var MainBody_1 = require("./MainBody");
var core_1 = require("@keypom/core");
/**
 * regex for the body of an account not including TLA and not allowing subaccount
 */
exports.accountAddressPatternNoSubaccount = /^([a-z\d]+[-_])*[a-z\d]+$/;
var BeginTrial = function (_a) {
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    var hide = _a.hide, secretKey = _a.secretKey, redirectUrlBase = _a.redirectUrlBase, delimiter = _a.delimiter, customizations = _a.customizations;
    var _o = (0, react_1.useState)(""), userInput = _o[0], setUserInput = _o[1];
    var _p = (0, react_1.useState)(""), accountId = _p[0], setAccountId = _p[1];
    var _q = (0, react_1.useState)(false), isClaimingTrial = _q[0], setIsClaimingTrial = _q[1];
    var _r = (0, react_1.useState)(false), dropClaimed = _r[0], setDropClaimed = _r[1];
    var _s = (0, react_1.useState)("grey"), borderColor = _s[0], setBorderColor = _s[1];
    var _t = (0, react_1.useState)(((_c = (_b = customizations === null || customizations === void 0 ? void 0 : customizations.landing) === null || _b === void 0 ? void 0 : _b.subText) === null || _c === void 0 ? void 0 : _c.landing) ||
        modal_types_1.MODAL_DEFAULTS.beginTrial.landing.subText.landing), messageText = _t[0], setMessageText = _t[1];
    var networkId = (0, core_1.getEnv)().networkId;
    var accountIdSuffix = networkId == "testnet" ? "testnet" : "near";
    var handleChangeInput = function (e) { return __awaiter(void 0, void 0, void 0, function () {
        var userInput, actualAccountId, isValid, exists;
        var _a, _b, _c, _d;
        return __generator(this, function (_e) {
            switch (_e.label) {
                case 0:
                    userInput = e.target.value.toLowerCase();
                    setUserInput(userInput);
                    actualAccountId = "".concat(userInput, ".").concat(accountIdSuffix);
                    setAccountId(actualAccountId);
                    if (!userInput.length) {
                        setMessageText(((_b = (_a = customizations === null || customizations === void 0 ? void 0 : customizations.landing) === null || _a === void 0 ? void 0 : _a.subText) === null || _b === void 0 ? void 0 : _b.landing) ||
                            modal_types_1.MODAL_DEFAULTS.beginTrial.landing.subText.landing);
                        setBorderColor("grey");
                        return [2 /*return*/];
                    }
                    isValid = exports.accountAddressPatternNoSubaccount.test(userInput);
                    if (!isValid) {
                        setMessageText(((_d = (_c = customizations === null || customizations === void 0 ? void 0 : customizations.landing) === null || _c === void 0 ? void 0 : _c.subText) === null || _d === void 0 ? void 0 : _d.invalidAccountId) ||
                            modal_types_1.MODAL_DEFAULTS.beginTrial.landing.subText.invalidAccountId);
                        setBorderColor("red");
                        return [2 /*return*/];
                    }
                    return [4 /*yield*/, (0, core_1.accountExists)(actualAccountId)];
                case 1:
                    exists = _e.sent();
                    if (exists) {
                        setMessageText("".concat(actualAccountId, " is taken, try something else."));
                        setBorderColor("red");
                        return [2 /*return*/];
                    }
                    setMessageText("".concat(actualAccountId, " is available!"));
                    setBorderColor("green");
                    return [2 /*return*/];
            }
        });
    }); };
    var handleSubmit = function (event) { return __awaiter(void 0, void 0, void 0, function () {
        var curMethodData, fcArgs, userFcArgs;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    event.preventDefault();
                    if (borderColor === "red")
                        return [2 /*return*/];
                    setIsClaimingTrial(true);
                    return [4 /*yield*/, (0, core_1.getCurMethodData)({ secretKey: secretKey })];
                case 1:
                    curMethodData = _a.sent();
                    console.log("curMethodData: ", curMethodData);
                    fcArgs = Array(curMethodData.length).fill(null);
                    userFcArgs = {
                        INSERT_NEW_ACCOUNT: accountId,
                        INSERT_TRIAL_PUBLIC_KEY: (0, core_1.getPubFromSecret)(secretKey),
                    };
                    fcArgs[0] = JSON.stringify(userFcArgs);
                    return [4 /*yield*/, (0, core_1.claim)({ accountId: accountId, secretKey: secretKey, fcArgs: fcArgs })];
                case 2:
                    _a.sent();
                    setIsClaimingTrial(false);
                    setDropClaimed(true);
                    return [2 /*return*/];
            }
        });
    }); };
    // Landing modal - drop isn't claimed and we're not in the process of claiming
    if (!dropClaimed && !isClaimingTrial) {
        return (react_1.default.createElement("div", { className: "nws-modal", style: { width: "100%", height: "auto", maxWidth: "500px" } },
            react_1.default.createElement("div", { className: "modal-right", style: { width: "100%" } },
                react_1.default.createElement(MainBody_1.MainBody, { title: ((_d = customizations === null || customizations === void 0 ? void 0 : customizations.landing) === null || _d === void 0 ? void 0 : _d.title) ||
                        modal_types_1.MODAL_DEFAULTS.beginTrial.landing.title, body: ((_e = customizations === null || customizations === void 0 ? void 0 : customizations.landing) === null || _e === void 0 ? void 0 : _e.body) ||
                        modal_types_1.MODAL_DEFAULTS.beginTrial.landing.body, imageOne: null, imageTwo: null, button: null, onCloseModal: function () { return hide(); } }),
                react_1.default.createElement("div", { style: {
                        position: "relative",
                    } },
                    react_1.default.createElement("div", { style: {
                            display: "flex",
                            alignItems: "center",
                        } },
                        react_1.default.createElement("input", { type: "text", value: userInput, onChange: handleChangeInput, placeholder: ((_f = customizations === null || customizations === void 0 ? void 0 : customizations.landing) === null || _f === void 0 ? void 0 : _f.fieldPlaceholder) ||
                                modal_types_1.MODAL_DEFAULTS.beginTrial.landing.fieldPlaceholder, style: {
                                width: "100%",
                                padding: "8px",
                                border: "1px solid",
                                borderRadius: "8px",
                                marginRight: "8px",
                                borderColor: borderColor,
                            } }),
                        react_1.default.createElement("span", null,
                            ".",
                            accountIdSuffix)),
                    react_1.default.createElement("div", { style: {
                            position: "absolute",
                            top: "42px",
                            left: 0,
                            color: borderColor,
                        } },
                        react_1.default.createElement("sub", null, messageText))),
                react_1.default.createElement("div", { style: { marginBottom: "32px" } }),
                react_1.default.createElement("div", { className: "nws-modal-body wallet-info-wrapper what-wallet-hide " },
                    react_1.default.createElement("button", { disabled: borderColor === "red", className: "middleButton", onClick: handleSubmit, style: {
                            width: "100%",
                            padding: "8px",
                            borderRadius: "8px",
                        } }, ((_g = customizations === null || customizations === void 0 ? void 0 : customizations.landing) === null || _g === void 0 ? void 0 : _g.buttonText) ||
                        modal_types_1.MODAL_DEFAULTS.beginTrial.landing.buttonText)))));
    }
    // Claiming modal - drop is not claimed and we're in the process of claiming
    if (isClaimingTrial) {
        return (react_1.default.createElement("div", { className: "nws-modal", style: { width: "100%", height: "auto", maxWidth: "500px" } },
            react_1.default.createElement("div", { className: "modal-right", style: { width: "100%" } },
                react_1.default.createElement(MainBody_1.MainBody, { title: ((_h = customizations === null || customizations === void 0 ? void 0 : customizations.claiming) === null || _h === void 0 ? void 0 : _h.title) ||
                        modal_types_1.MODAL_DEFAULTS.beginTrial.claiming.title, body: ((_j = customizations === null || customizations === void 0 ? void 0 : customizations.claiming) === null || _j === void 0 ? void 0 : _j.body) ||
                        modal_types_1.MODAL_DEFAULTS.beginTrial.claiming.body, imageOne: null, imageTwo: null, button: null, onCloseModal: function () { return console.log("cant close... claiming."); } }))));
    }
    // Drop was claimed
    return (react_1.default.createElement("div", { className: "nws-modal", style: { width: "100%", height: "auto", maxWidth: "500px" } },
        react_1.default.createElement("div", { className: "modal-right", style: { width: "100%" } },
            react_1.default.createElement(MainBody_1.MainBody, { title: ((_k = customizations === null || customizations === void 0 ? void 0 : customizations.claimed) === null || _k === void 0 ? void 0 : _k.title) ||
                    modal_types_1.MODAL_DEFAULTS.beginTrial.claimed.title, body: ((_l = customizations === null || customizations === void 0 ? void 0 : customizations.claimed) === null || _l === void 0 ? void 0 : _l.body) ||
                    modal_types_1.MODAL_DEFAULTS.beginTrial.claimed.body, imageOne: null, imageTwo: null, button: null, onCloseModal: function () {
                    window.location.replace("".concat(redirectUrlBase).concat(accountId).concat(delimiter).concat(secretKey));
                    window.location.reload();
                } }),
            react_1.default.createElement("div", { className: "nws-modal-body wallet-info-wrapper what-wallet-hide " },
                react_1.default.createElement("button", { className: "middleButton", onClick: function () {
                        window.location.replace("".concat(redirectUrlBase).concat(accountId).concat(delimiter).concat(secretKey));
                        window.location.reload();
                    }, style: {
                        width: "100%",
                        padding: "8px",
                        borderRadius: "8px",
                    } }, ((_m = customizations === null || customizations === void 0 ? void 0 : customizations.claimed) === null || _m === void 0 ? void 0 : _m.buttonText) ||
                    modal_types_1.MODAL_DEFAULTS.beginTrial.claimed.buttonText)))));
};
exports.BeginTrial = BeginTrial;

'''
'''--- packages/selector/lib/modal/src/lib/components/CloseModalButton.d.ts ---
import React from "react";
interface CloseModalButtonProps {
    onClick: () => void;
}
export declare const CloseModalButton: React.FC<CloseModalButtonProps>;
export {};

'''
'''--- packages/selector/lib/modal/src/lib/components/CloseModalButton.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CloseModalButton = void 0;
var react_1 = __importDefault(require("react"));
var CloseModalButton = function (_a) {
    var onClick = _a.onClick;
    return (react_1.default.createElement("button", { onClick: onClick, className: "close-button" },
        react_1.default.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", height: "24", viewBox: "0 0 24 24", width: "24", fill: "#C1C1C1" },
            react_1.default.createElement("path", { d: "M0 0h24v24H0z", fill: "none" }),
            react_1.default.createElement("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }))));
};
exports.CloseModalButton = CloseModalButton;

'''
'''--- packages/selector/lib/modal/src/lib/components/InsufficientBalance.d.ts ---
import React from "react";
import { InsufficientBalanceCustomizations } from "../modal.types";
interface InsufficientBalanceProps {
    customizations?: InsufficientBalanceCustomizations;
    hide: () => void;
}
export declare const InsufficientBalance: React.FC<InsufficientBalanceProps>;
export {};

'''
'''--- packages/selector/lib/modal/src/lib/components/InsufficientBalance.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InsufficientBalance = void 0;
var react_1 = __importDefault(require("react"));
var modal_types_1 = require("../modal.types");
var MainBody_1 = require("./MainBody");
var InsufficientBalance = function (_a) {
    var customizations = _a.customizations, hide = _a.hide;
    return (react_1.default.createElement("div", { className: "nws-modal", style: { width: "70%", height: "27%" } },
        react_1.default.createElement("div", { className: "modal-right", style: { width: "100%" } },
            react_1.default.createElement(MainBody_1.MainBody, { title: (customizations === null || customizations === void 0 ? void 0 : customizations.title) || modal_types_1.MODAL_DEFAULTS.insufficientBalance.title, body: (customizations === null || customizations === void 0 ? void 0 : customizations.body) || modal_types_1.MODAL_DEFAULTS.insufficientBalance.body, imageOne: null, imageTwo: null, button: null, onCloseModal: function () { return hide(); } }))));
};
exports.InsufficientBalance = InsufficientBalance;

'''
'''--- packages/selector/lib/modal/src/lib/components/InvalidActions.d.ts ---
import React from "react";
import { InvalidActionCustomizations } from "../modal.types";
interface InvalidActionsProps {
    customizations?: InvalidActionCustomizations;
    hide: () => void;
}
export declare const InvalidActions: React.FC<InvalidActionsProps>;
export {};

'''
'''--- packages/selector/lib/modal/src/lib/components/InvalidActions.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.InvalidActions = void 0;
var react_1 = __importDefault(require("react"));
var modal_types_1 = require("../modal.types");
var MainBody_1 = require("./MainBody");
var InvalidActions = function (_a) {
    var customizations = _a.customizations, hide = _a.hide;
    return (react_1.default.createElement("div", { className: "nws-modal", style: { width: "70%", height: "27%" } },
        react_1.default.createElement("div", { className: "modal-right", style: { width: "100%" } },
            react_1.default.createElement(MainBody_1.MainBody, { title: (customizations === null || customizations === void 0 ? void 0 : customizations.title) || modal_types_1.MODAL_DEFAULTS.invalidAction.title, body: (customizations === null || customizations === void 0 ? void 0 : customizations.body) || modal_types_1.MODAL_DEFAULTS.invalidAction.body, imageOne: null, imageTwo: null, button: null, onCloseModal: function () { return hide(); } }))));
};
exports.InvalidActions = InvalidActions;

'''
'''--- packages/selector/lib/modal/src/lib/components/KeypomModal.d.ts ---
import React from "react";
import { ModalType, ModalCustomizations } from "../modal.types";
interface ModalProps {
    options: ModalCustomizations;
    modalType: ModalType;
    visible: boolean;
    hide: () => void;
}
export declare const KeypomModal: React.FC<ModalProps>;
export {};

'''
'''--- packages/selector/lib/modal/src/lib/components/KeypomModal.js ---
"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.KeypomModal = void 0;
var react_1 = __importStar(require("react"));
var handleModalType_1 = require("../handleModalType");
var modal_types_1 = require("../modal.types");
var getThemeClass = function (theme) {
    switch (theme) {
        case "dark":
            return "dark-theme";
        case "light":
            return "light-theme";
        default:
            return "";
    }
};
var KeypomModal = function (_a) {
    var options = _a.options, modalType = _a.modalType, visible = _a.visible, hide = _a.hide;
    (0, react_1.useEffect)(function () {
        var close = function (e) {
            if (e.key === "Escape" && modalType.id !== modal_types_1.MODAL_TYPE_IDS.BEGIN_TRIAL) {
                hide();
            }
        };
        window.addEventListener("keydown", close);
        return function () { return window.removeEventListener("keydown", close); };
    }, [hide]);
    if (!visible) {
        return null;
    }
    return (react_1.default.createElement("div", { className: "nws-modal-wrapper ".concat(getThemeClass(options.theme), " ").concat(visible ? "open" : "") },
        react_1.default.createElement("div", { className: "nws-modal-overlay", onClick: function () {
                if (modalType.id !== modal_types_1.MODAL_TYPE_IDS.BEGIN_TRIAL) {
                    hide();
                }
            } }),
        (0, handleModalType_1.renderModalType)(modalType, options, hide)));
};
exports.KeypomModal = KeypomModal;

'''
'''--- packages/selector/lib/modal/src/lib/components/MainBody.d.ts ---
import React from "react";
import { MainBodyButton, MainBodyImage } from "../modal.types";
interface MainBodyProps {
    title: string;
    body: string;
    imageOne: MainBodyImage | null;
    imageTwo: MainBodyImage | null;
    button: MainBodyButton | null;
    onCloseModal: () => void;
}
export declare const MainBody: React.FC<MainBodyProps>;
export {};

'''
'''--- packages/selector/lib/modal/src/lib/components/MainBody.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.MainBody = void 0;
var react_1 = __importDefault(require("react"));
var CloseModalButton_1 = require("./CloseModalButton");
var MainBody = function (_a) {
    var title = _a.title, body = _a.body, imageOne = _a.imageOne, imageTwo = _a.imageTwo, button = _a.button, onCloseModal = _a.onCloseModal;
    return (react_1.default.createElement("div", { className: "wallet-home-wrapper" },
        react_1.default.createElement("div", { className: "nws-modal-header-wrapper" },
            react_1.default.createElement("div", { className: "nws-modal-header" },
                react_1.default.createElement("h3", { className: "middleTitle" }, title),
                react_1.default.createElement(CloseModalButton_1.CloseModalButton, { onClick: onCloseModal }))),
        react_1.default.createElement(react_1.default.Fragment, null,
            react_1.default.createElement("div", { className: "content-side" },
                react_1.default.createElement("p", null, body)),
            react_1.default.createElement("div", null,
                imageOne && (react_1.default.createElement("div", { className: "wallet-what" },
                    react_1.default.createElement("div", { className: "icon-side" },
                        react_1.default.createElement("svg", { width: "40", height: "40", viewBox: "0 0 40 40", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                            react_1.default.createElement("path", { d: "M33.5 1.83325L30.1666 5.16658M17.4818 17.8514C19.1406 19.5103 20.1666 21.8019 20.1666 24.3333C20.1666 29.3959 16.0626 33.4999 11 33.4999C5.93735 33.4999 1.8333 29.3959 1.8333 24.3333C1.8333 19.2706 5.93735 15.1666 11 15.1666C13.5313 15.1666 15.8229 16.1926 17.4818 17.8514ZM17.4818 17.8514L24.3333 10.9999M24.3333 10.9999L29.3333 15.9999L35.1666 10.1666L30.1666 5.16658M24.3333 10.9999L30.1666 5.16658", stroke: "currentColor", strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round" }))),
                    react_1.default.createElement("div", { className: "content-side" },
                        react_1.default.createElement("h3", null, imageOne.title),
                        react_1.default.createElement("p", null, imageOne.body)))),
                imageTwo && (react_1.default.createElement("div", { className: "wallet-what" },
                    react_1.default.createElement("div", { className: "icon-side" },
                        react_1.default.createElement("svg", { width: "40", height: "41", viewBox: "0 0 40 41", fill: "none", xmlns: "http://www.w3.org/2000/svg" },
                            react_1.default.createElement("circle", { cx: "28.3333", cy: "23.8333", r: "1.66667", fill: "currentColor" }),
                            react_1.default.createElement("path", { d: "M35 12.1667H7C5.89543 12.1667 5 11.2712 5 10.1667V7.5C5 6.39543 5.89543 5.5 7 5.5H31.6667", stroke: "currentColor", strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round" }),
                            react_1.default.createElement("path", { d: "M35 12.1667V35.5H7C5.89543 35.5 5 34.6046 5 33.5V8.83334", stroke: "currentColor", strokeWidth: "3", strokeLinecap: "round", strokeLinejoin: "round" }))),
                    react_1.default.createElement("div", { className: "content-side" },
                        react_1.default.createElement("h3", null, imageTwo.title),
                        react_1.default.createElement("p", null, imageTwo.body)))),
                button && (react_1.default.createElement("button", { className: "middleButton", onClick: function () {
                        if (button.newTab) {
                            window.open(button.url, "_blank");
                        }
                        else {
                            window.location.replace(button.url || "https://keypom.xyz/");
                            window.location.reload();
                        }
                    } }, button.text || "Next Steps"))))));
};
exports.MainBody = MainBody;

'''
'''--- packages/selector/lib/modal/src/lib/components/OffboardingWallets.d.ts ---
import React from "react";
import { OffboardingWallet, OffboardingWalletCustomizations } from "../modal.types";
interface OffboardingWalletsProps {
    customizations?: OffboardingWalletCustomizations;
    wallets: OffboardingWallet[];
    accountId: string;
    secretKey: string;
}
export declare const OffboardingWallets: React.FC<OffboardingWalletsProps>;
export {};

'''
'''--- packages/selector/lib/modal/src/lib/components/OffboardingWallets.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.OffboardingWallets = void 0;
var react_1 = __importDefault(require("react"));
var modal_types_1 = require("../modal.types");
var OffboardingWallets = function (_a) {
    var customizations = _a.customizations, wallets = _a.wallets, accountId = _a.accountId, secretKey = _a.secretKey;
    function renderOptionsList(walletsToRender) {
        return walletsToRender.reduce(function (result, wallet, index) {
            var name = wallet.name, description = wallet.description, iconUrl = wallet.iconUrl, redirectUrl = wallet.redirectUrl;
            var mapObj = {
                ACCOUNT_ID: accountId,
                SECRET_KEY: secretKey
            };
            var url = redirectUrl.replace(/\b(?:SECRET_KEY|ACCOUNT_ID)\b/gi, function (matched) { return mapObj[matched]; });
            result.push(react_1.default.createElement("li", { tabIndex: 0, className: "single-wallet sidebar ".concat(wallet.name), key: wallet.name, onClick: function () {
                    window.open(url, "_blank");
                } },
                react_1.default.createElement("div", { className: "icon" },
                    react_1.default.createElement("img", { src: iconUrl, alt: name })),
                react_1.default.createElement("div", { className: "content" },
                    react_1.default.createElement("div", { className: "title" }, name),
                    react_1.default.createElement("div", { className: "description" }, description))));
            return result;
        }, []);
    }
    return (react_1.default.createElement("div", null,
        react_1.default.createElement("div", { className: "modal-left-title" },
            react_1.default.createElement("h2", null, (customizations === null || customizations === void 0 ? void 0 : customizations.title) ||
                modal_types_1.MODAL_DEFAULTS.trialOver.offboardingOptions.title)),
        react_1.default.createElement("div", { className: "wallet-options-wrapper" },
            react_1.default.createElement("div", { className: "options-list" }, renderOptionsList(wallets)))));
};
exports.OffboardingWallets = OffboardingWallets;

'''
'''--- packages/selector/lib/modal/src/lib/components/TrialOver.d.ts ---
import React from "react";
import { OffboardingWallet, TrialOverCustomizations } from "../modal.types";
interface TrialOverProps {
    accountId: string;
    secretKey: string;
    wallets: OffboardingWallet[];
    hide: () => void;
    customizations?: TrialOverCustomizations;
}
export declare const TrialOver: React.FC<TrialOverProps>;
export {};

'''
'''--- packages/selector/lib/modal/src/lib/components/TrialOver.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.TrialOver = void 0;
var react_1 = __importDefault(require("react"));
var modal_types_1 = require("../modal.types");
var MainBody_1 = require("./MainBody");
var OffboardingWallets_1 = require("./OffboardingWallets");
var TrialOver = function (_a) {
    var _b, _c, _d, _e;
    var wallets = _a.wallets, accountId = _a.accountId, secretKey = _a.secretKey, customizations = _a.customizations, hide = _a.hide;
    return (react_1.default.createElement("div", { className: "nws-modal" },
        react_1.default.createElement("div", { className: "modal-left" },
            react_1.default.createElement(OffboardingWallets_1.OffboardingWallets, { customizations: customizations === null || customizations === void 0 ? void 0 : customizations.offboardingOptions, wallets: wallets, accountId: accountId, secretKey: secretKey })),
        react_1.default.createElement("div", { className: "modal-right" },
            react_1.default.createElement("div", { className: "nws-modal-body" },
                react_1.default.createElement(MainBody_1.MainBody, { title: ((_b = customizations === null || customizations === void 0 ? void 0 : customizations.mainBody) === null || _b === void 0 ? void 0 : _b.title) ||
                        modal_types_1.MODAL_DEFAULTS.trialOver.mainBody.title, body: ((_c = customizations === null || customizations === void 0 ? void 0 : customizations.mainBody) === null || _c === void 0 ? void 0 : _c.body) ||
                        modal_types_1.MODAL_DEFAULTS.trialOver.mainBody.body, imageOne: ((_d = customizations === null || customizations === void 0 ? void 0 : customizations.mainBody) === null || _d === void 0 ? void 0 : _d.imageOne) ||
                        modal_types_1.MODAL_DEFAULTS.trialOver.mainBody.imageOne, imageTwo: ((_e = customizations === null || customizations === void 0 ? void 0 : customizations.mainBody) === null || _e === void 0 ? void 0 : _e.imageTwo) ||
                        modal_types_1.MODAL_DEFAULTS.trialOver.mainBody.imageTwo, button: null, onCloseModal: function () { return hide(); } })))));
};
exports.TrialOver = TrialOver;

'''
'''--- packages/selector/lib/modal/src/lib/handleModalType.d.ts ---
/// <reference types="react" />
import { ModalCustomizations, ModalType } from "./modal.types";
export declare const renderModalType: (modalType: ModalType, options: ModalCustomizations, hide: () => void) => JSX.Element | null;

'''
'''--- packages/selector/lib/modal/src/lib/handleModalType.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderModalType = void 0;
var react_1 = __importDefault(require("react"));
var BeginTrial_1 = require("./components/BeginTrial");
var InsufficientBalance_1 = require("./components/InsufficientBalance");
var InvalidActions_1 = require("./components/InvalidActions");
var TrialOver_1 = require("./components/TrialOver");
var modal_types_1 = require("./modal.types");
var renderModalType = function (modalType, options, hide) {
    switch (modalType.id) {
        case modal_types_1.MODAL_TYPE_IDS.TRIAL_OVER:
            return (react_1.default.createElement(TrialOver_1.TrialOver, { accountId: modalType.meta.accountId, secretKey: modalType.meta.secretKey, wallets: options.wallets, customizations: options.trialOver, hide: hide }));
        case modal_types_1.MODAL_TYPE_IDS.ACTION_ERROR:
            return (react_1.default.createElement(InvalidActions_1.InvalidActions, { hide: hide, customizations: options.invalidAction }));
        case modal_types_1.MODAL_TYPE_IDS.INSUFFICIENT_BALANCE:
            return (react_1.default.createElement(InsufficientBalance_1.InsufficientBalance, { hide: hide, customizations: options.insufficientBalance }));
        case modal_types_1.MODAL_TYPE_IDS.BEGIN_TRIAL:
            return (react_1.default.createElement(BeginTrial_1.BeginTrial, { hide: hide, secretKey: modalType.meta.secretKey, redirectUrlBase: modalType.meta.redirectUrlBase, delimiter: modalType.meta.delimiter, customizations: options.beginTrial }));
        default:
            return null;
    }
};
exports.renderModalType = renderModalType;

'''
'''--- packages/selector/lib/modal/src/lib/modal.d.ts ---
import { KeypomTrialModal, ModalCustomizations } from "./modal.types";
export declare const setupModal: (options: ModalCustomizations) => KeypomTrialModal;

'''
'''--- packages/selector/lib/modal/src/lib/modal.js ---
"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.setupModal = void 0;
var react_1 = __importDefault(require("react"));
var client_1 = require("react-dom/client");
var KeypomModal_1 = require("./components/KeypomModal");
var modal_types_1 = require("./modal.types");
var MODAL_ELEMENT_ID = "near-wallet-selector-modal";
var modalInstance = null;
var setupModal = function (options) {
    var el = document.createElement("div");
    el.id = MODAL_ELEMENT_ID;
    if (!document.getElementById(MODAL_ELEMENT_ID)) {
        document.body.appendChild(el);
    }
    var container = document.getElementById(MODAL_ELEMENT_ID);
    var root = (0, client_1.createRoot)(container);
    var render = function (visible, modalType) {
        if (visible === void 0) { visible = false; }
        if (modalType === void 0) { modalType = { id: modal_types_1.MODAL_TYPE_IDS.TRIAL_OVER }; }
        root.render(react_1.default.createElement(KeypomModal_1.KeypomModal, { options: options, modalType: modalType, visible: visible, hide: function () { return render(false); } }));
    };
    if (!modalInstance) {
        modalInstance = {
            show: function (modalType) {
                render(true, modalType);
            },
            hide: function () {
                render(false);
            }
        };
    }
    return modalInstance;
};
exports.setupModal = setupModal;

'''
'''--- packages/selector/lib/modal/src/lib/modal.types.d.ts ---
export type Theme = 'dark' | 'light' | 'auto';
export interface ModalCustomizations {
    wallets: OffboardingWallet[];
    theme?: Theme;
    beginTrial?: BeginTrialCustomizations;
    trialOver?: TrialOverCustomizations;
    invalidAction?: InvalidActionCustomizations;
    insufficientBalance?: InsufficientBalanceCustomizations;
}
export interface BeginTrialCustomizations {
    landing?: {
        title?: string;
        body?: string;
        fieldPlaceholder?: string;
        buttonText?: string;
        subText?: {
            landing?: string;
            invalidAccountId?: string;
            accountIdTaken?: string;
            accountIdAvailable?: string;
        };
    };
    claiming?: {
        title?: string;
        body?: string;
    };
    claimed?: {
        title?: string;
        body?: string;
        buttonText?: string;
    };
}
export interface TrialOverCustomizations {
    mainBody?: MainBodyCustomizations;
    offboardingOptions?: OffboardingWalletCustomizations;
}
export interface MainBodyCustomizations {
    title?: string;
    body?: string;
    imageOne?: MainBodyImage;
    imageTwo?: MainBodyImage;
    button?: MainBodyButton;
}
export interface OffboardingWalletCustomizations {
    title?: string;
}
export interface InvalidActionCustomizations {
    title?: string;
    body?: string;
}
export interface InsufficientBalanceCustomizations {
    title?: string;
    body?: string;
}
export interface OffboardingWallet {
    name: string;
    description: string;
    iconUrl: string;
    redirectUrl: string;
}
export interface MainBodyImage {
    title: string;
    body: string;
}
export interface MainBodyButton {
    url?: string;
    newTab?: boolean;
    text?: string;
}
export interface KeypomTrialModal {
    show(modalType?: ModalType): void;
    hide(): void;
}
export interface ModalType {
    id: string;
    meta?: any;
}
export declare const MODAL_TYPE_IDS: {
    BEGIN_TRIAL: string;
    TRIAL_OVER: string;
    ACTION_ERROR: string;
    INSUFFICIENT_BALANCE: string;
};
export declare const MODAL_DEFAULTS: {
    beginTrial: {
        landing: {
            title: string;
            body: string;
            fieldPlaceholder: string;
            buttonText: string;
            subText: {
                landing: string;
                invalidAccountId: string;
            };
        };
        claiming: {
            title: string;
            body: string;
        };
        claimed: {
            title: string;
            body: string;
            buttonText: string;
        };
    };
    trialOver: {
        mainBody: {
            title: string;
            body: string;
            imageOne: {
                title: string;
                body: string;
            };
            imageTwo: {
                title: string;
                body: string;
            };
        };
        offboardingOptions: {
            title: string;
        };
    };
    invalidAction: {
        title: string;
        body: string;
    };
    insufficientBalance: {
        title: string;
        body: string;
    };
};

'''
'''--- packages/selector/lib/modal/src/lib/modal.types.js ---
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MODAL_DEFAULTS = exports.MODAL_TYPE_IDS = void 0;
exports.MODAL_TYPE_IDS = {
    BEGIN_TRIAL: 'begin-trial',
    TRIAL_OVER: 'trial-over',
    ACTION_ERROR: 'action-error',
    INSUFFICIENT_BALANCE: 'insufficient-balance'
};
exports.MODAL_DEFAULTS = {
    beginTrial: {
        landing: {
            title: 'Create an Account',
            body: 'To start, enter a username.',
            fieldPlaceholder: 'Account Name',
            buttonText: 'Create',
            subText: {
                landing: 'Customize your account name.',
                invalidAccountId: 'Invalid Character in Account Name.'
            }
        },
        claiming: {
            title: 'Creating Account',
            body: 'Your account is being created. Please wait...',
        },
        claimed: {
            title: 'You\'re all set!🎉',
            body: 'Your account has been successfully created.',
            buttonText: 'Continue to app'
        }
    },
    trialOver: {
        mainBody: {
            title: 'Your trial has ended',
            body: 'Choose a wallet provider and onboard fully into the NEAR ecosystem.',
            imageOne: {
                title: 'Secure Your Digital Assets',
                body: 'Now that your trial is over, secure your account with an official wallet provider!'
            },
            imageTwo: {
                title: 'Log In to Any NEAR App',
                body: 'Once your account is secured, you can use any app on NEAR!'
            }
        },
        offboardingOptions: {
            title: 'Choose a Wallet',
        }
    },
    invalidAction: {
        title: 'Invalid Action',
        body: 'Your trial does not allow you to perform this action. For more information, please contact the site administrator.'
    },
    insufficientBalance: {
        title: 'Insufficient Balance',
        body: 'Your account does not have enough balance for the action you are trying to perform. Please try again with a different action. For more information, please contact the site administrator.'
    }
};

'''
'''--- packages/selector/lib/utils/selector-utils.d.ts ---
import { InternalInstantSignInSpecs, InternalTrialSignInSpecs } from '../core/types';
import { Action } from '@near-js/transactions';
import { KeypomParams } from '../core/types';
export declare const KEYPOM_LOCAL_STORAGE_KEY = "keypom-wallet-selector";
export declare const getLocalStorageKeypomEnv: () => string | null;
export declare const setLocalStorageKeypomEnv: (jsonData: any) => void;
export declare const getAccountFromMap: (secretKey: any) => Promise<any>;
/**
 * Check if given access key allows the function call or method attempted in transaction
 * @param accessKey Array of \{access_key: AccessKey, public_key: PublicKey\} items
 * @param receiverId The NEAR account attempting to have access
 * @param actions The action(s) needed to be checked for access
 */
export declare const keyHasPermissionForTransaction: (accessKey: any, receiverId: string, actions: Action[]) => Promise<boolean>;
export declare const parseIPFSDataFromURL: () => Promise<KeypomParams | undefined>;
export declare const addUserToMappingContract: (accountId: any, secretKey: any) => Promise<boolean>;
export declare const updateKeypomContractIfValid: (keypomContractId: any) => boolean;
export declare const parseTrialUrl: (trialSpecs: InternalTrialSignInSpecs) => {
    accountId: string;
    secretKey: string;
} | undefined;
export declare const parseInstantSignInUrl: (instantSignInSpecs: InternalInstantSignInSpecs) => {
    accountId: string;
    secretKey: string;
    moduleId: string;
} | undefined;

'''
'''--- packages/selector/lib/utils/selector-utils.js ---
"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseInstantSignInUrl = exports.parseTrialUrl = exports.updateKeypomContractIfValid = exports.addUserToMappingContract = exports.parseIPFSDataFromURL = exports.keyHasPermissionForTransaction = exports.getAccountFromMap = exports.setLocalStorageKeypomEnv = exports.getLocalStorageKeypomEnv = exports.KEYPOM_LOCAL_STORAGE_KEY = void 0;
var core_1 = require("@keypom/core");
var utils_1 = require("@near-js/utils");
var types_1 = require("../core/types");
exports.KEYPOM_LOCAL_STORAGE_KEY = 'keypom-wallet-selector';
var getLocalStorageKeypomEnv = function () {
    var localStorageDataJson = localStorage.getItem("".concat(exports.KEYPOM_LOCAL_STORAGE_KEY, ":envData"));
    return localStorageDataJson;
};
exports.getLocalStorageKeypomEnv = getLocalStorageKeypomEnv;
var setLocalStorageKeypomEnv = function (jsonData) {
    var dataToWrite = JSON.stringify(jsonData);
    localStorage.setItem("".concat(exports.KEYPOM_LOCAL_STORAGE_KEY, ":envData"), dataToWrite);
};
exports.setLocalStorageKeypomEnv = setLocalStorageKeypomEnv;
var getAccountFromMap = function (secretKey) { return __awaiter(void 0, void 0, void 0, function () {
    var viewCall, pk, accountId;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                viewCall = (0, core_1.getEnv)().viewCall;
                pk = (0, core_1.getPubFromSecret)(secretKey);
                return [4 /*yield*/, viewCall({
                        contractId: core_1.accountMappingContract[(0, core_1.getEnv)().networkId],
                        methodName: 'get_account_id',
                        args: { pk: pk }
                    })];
            case 1:
                accountId = _a.sent();
                console.log('accountId found from map: ', accountId);
                return [2 /*return*/, accountId];
        }
    });
}); };
exports.getAccountFromMap = getAccountFromMap;
/**
 * Check if given access key allows the function call or method attempted in transaction
 * @param accessKey Array of \{access_key: AccessKey, public_key: PublicKey\} items
 * @param receiverId The NEAR account attempting to have access
 * @param actions The action(s) needed to be checked for access
 */
var keyHasPermissionForTransaction = function (accessKey, receiverId, actions) { return __awaiter(void 0, void 0, void 0, function () {
    var permission, _a, allowedReceiverId, allowedMethods, allowed, _i, actions_1, action, functionCall;
    return __generator(this, function (_b) {
        console.log('accessKey: ', accessKey);
        permission = accessKey.permission;
        if (permission === 'FullAccess') {
            return [2 /*return*/, true];
        }
        if (permission.FunctionCall) {
            _a = permission.FunctionCall, allowedReceiverId = _a.receiver_id, allowedMethods = _a.method_names;
            if (allowedReceiverId === receiverId) {
                allowed = true;
                for (_i = 0, actions_1 = actions; _i < actions_1.length; _i++) {
                    action = actions_1[_i];
                    functionCall = action.functionCall;
                    if (!(functionCall && (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?
                        (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName)))) {
                        allowed = false;
                        break;
                    }
                }
                return [2 /*return*/, allowed];
            }
        }
        return [2 /*return*/, false];
    });
}); };
exports.keyHasPermissionForTransaction = keyHasPermissionForTransaction;
var parseIPFSDataFromURL = function () { return __awaiter(void 0, void 0, void 0, function () {
    var split, cid, response, data;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                split = window.location.href.split("?cid=");
                if (!(split.length > 1)) return [3 /*break*/, 3];
                cid = split[1];
                console.log("found CID in URL: ", cid);
                return [4 /*yield*/, fetch("https://cloudflare-ipfs.com/ipfs/".concat(cid))];
            case 1:
                response = _a.sent();
                return [4 /*yield*/, response.json()];
            case 2:
                data = _a.sent();
                if ((0, types_1.isKeypomParams)(data)) {
                    console.log('Successfully parsed Keypom params from URL.');
                    return [2 /*return*/, data];
                }
                console.log('data can not be cast to Keypom params: ', data);
                _a.label = 3;
            case 3: return [2 /*return*/];
        }
    });
}); };
exports.parseIPFSDataFromURL = parseIPFSDataFromURL;
var addUserToMappingContract = function (accountId, secretKey) { return __awaiter(void 0, void 0, void 0, function () {
    var accountIdFromMapping;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, (0, exports.getAccountFromMap)(secretKey)];
            case 1:
                accountIdFromMapping = _a.sent();
                if (accountIdFromMapping !== accountId) {
                    console.log("No Account ID found from mapping contract: ".concat(JSON.stringify(accountIdFromMapping), " Adding now."));
                    (0, core_1.trialCallMethod)({
                        trialAccountId: accountId,
                        trialAccountSecretKey: secretKey,
                        contractId: core_1.accountMappingContract[(0, core_1.getEnv)().networkId],
                        methodName: 'set',
                        args: {},
                        attachedDeposit: (0, utils_1.parseNearAmount)('0.002'),
                        attachedGas: '10000000000000'
                    });
                }
                return [2 /*return*/, accountIdFromMapping !== accountId];
        }
    });
}); };
exports.addUserToMappingContract = addUserToMappingContract;
var isValidKeypomContract = function (keypomContractId) {
    var networkId = (0, core_1.getEnv)().networkId;
    return core_1.supportedKeypomContracts[networkId][keypomContractId] !== undefined;
};
var updateKeypomContractIfValid = function (keypomContractId) {
    if (isValidKeypomContract(keypomContractId) === true) {
        (0, core_1.updateKeypomContractId)({
            keypomContractId: keypomContractId
        });
        return true;
    }
    return false;
};
exports.updateKeypomContractIfValid = updateKeypomContractIfValid;
var parseTrialUrl = function (trialSpecs) {
    var baseUrl = trialSpecs.baseUrl, delimiter = trialSpecs.delimiter;
    console.log("Parse trial URL with base: ".concat(baseUrl, " and delim: ").concat(delimiter));
    // remove everything after ?cid= in the URL if it's present
    var split = window.location.href.split("?cid=")[0].split(baseUrl);
    if (split.length !== 2) {
        return;
    }
    var trialInfo = split[1];
    var _a = trialInfo.split(delimiter), accountId = _a[0], secretKey = _a[1];
    if (!accountId || !secretKey) {
        return;
    }
    return {
        accountId: accountId,
        secretKey: secretKey
    };
};
exports.parseTrialUrl = parseTrialUrl;
var parseInstantSignInUrl = function (instantSignInSpecs) {
    var baseUrl = instantSignInSpecs.baseUrl, delimiter = instantSignInSpecs.delimiter, moduleDelimiter = instantSignInSpecs.moduleDelimiter;
    console.log("Parse instant sign in URL with base: ".concat(baseUrl, " delim: ").concat(delimiter, " and module delim: ").concat(moduleDelimiter));
    // remove everything after ?cid= in the URL if it's present
    var split = window.location.href.split("?cid=")[0].split(baseUrl);
    if (split.length !== 2) {
        return;
    }
    var signInInfo = split[1];
    // Get the account ID, secret key, and module ID based on the two delimiters `delimiter` and `moduleDelimiter`
    var regex = new RegExp("(.*)".concat(delimiter, "(.*)").concat(moduleDelimiter, "(.*)"));
    var matches = signInInfo.match(regex);
    var accountId = matches === null || matches === void 0 ? void 0 : matches[1];
    var secretKey = matches === null || matches === void 0 ? void 0 : matches[2];
    var moduleId = matches === null || matches === void 0 ? void 0 : matches[3];
    if (!accountId || !secretKey || !moduleId) {
        return;
    }
    return {
        accountId: accountId,
        secretKey: secretKey,
        moduleId: moduleId
    };
};
exports.parseInstantSignInUrl = parseInstantSignInUrl;

'''
'''--- packages/selector/package.json ---
{
  "name": "@keypom/selector",
  "version": "1.2.0",
  "description": "Wallet selector plugin for the Keypom SDK",
  "main": "lib/index.js",
  "scripts": {
    "preinstall": "npx only-allow pnpm",
    "build": "pnpm compile",
    "compile": "tsc -p tsconfig.json",
    "lint:js": "eslint -c ../../.eslintrc.js.yml src/**/*.js --no-eslintrc",
    "lint:js:fix": "eslint -c ../../.eslintrc.js.yml src/**/*.js --no-eslintrc --fix",
    "lint:ts": "eslint -c ../../.eslintrc.ts.yml src/**/*.ts --no-eslintrc",
    "lint:ts:fix": "eslint -c ../../.eslintrc.ts.yml src/**/*.ts --no-eslintrc --fix",

    "create:trial-accounts": "yarn build && node test/trial-accounts.ts",
    "create:instant-sign-in": "yarn build && node test/instant-sign-in.ts",

    "build-docs": "npx typedoc --options typedoc.json"
  },
  "author": "benkurrek, mattlockyer",
  "license": "MIT",
  "dependencies": {
    "@keypom/core": "workspace:*",
    "bn.js": "^5.2.1",
    "borsh": "^0.7.0"
  },
  "ava": {
    "require": [
      "dotenv/config"
    ]
  },
  "devDependencies": {
    "typedoc": "^0.23.24",
    "typescript": "^4.8.4",
    "ava": "^4.3.3",
    "@near-js/accounts": "^0.1.3",
    "@near-js/crypto": "^0.0.4",
    "@near-js/transactions": "^0.2.0",
    "@near-js/types": "^0.0.4",
    "@near-js/wallet-account": "^0.0.6",
    "@near-js/utils": "^0.0.4",
    "@near-js/keystores-browser": "^0.0.4",
    "@near-wallet-selector/core": "^8.0.3",
    "react": "^18.2.0",
    "react-dom": "18.2.0",
    "@types/react": "^18.0.26"
  },
  "peerDependencies": {
    "@near-js/accounts": "^0.1.3",
    "@near-js/crypto": "^0.0.4",
    "@near-js/types": "^0.0.4",
    "@near-js/transactions": "^0.2.0",
    "@near-js/wallet-account": "^0.0.6",
    "@near-js/utils": "^0.0.4",
    "@near-js/keystores-browser": "^0.0.4",
    "@near-js/keystores-node": "^0.0.4",
    "@near-wallet-selector/core": "^8.0.3",
    "react": "^18.2.0",
    "react-dom": "18.2.0",
    "@types/react": "^18.0.26"
  },
  "files": [
    "lib"
  ]
}

'''
'''--- packages/selector/src/core/ext_wallets.ts ---
import { convertBasicTransaction, getPubFromSecret } from '@keypom/core';
import { Account } from '@near-js/accounts';
import { PublicKey } from '@near-js/crypto';
import { SCHEMA, Transaction, actionCreators, stringifyJsonOrBytes } from '@near-js/transactions';
import { Near } from '@near-js/wallet-account';
import { FinalExecutionOutcome, FunctionCallAction, Transaction as wsTransaction } from '@near-wallet-selector/core';
import { serialize } from 'borsh';
import { keyHasPermissionForTransaction } from '../utils/selector-utils';
import { FAILED_EXECUTION_OUTCOME } from './types';

export const SUPPORTED_EXT_WALLET_DATA = {
    "testnet": {
        "near-wallet": {
            baseUrl: "https://wallet.testnet.near.org",
        },
        "my-near-wallet": {
            baseUrl: "https://testnet.mynearwallet.com",
        },
        "sweat-wallet": {
        }
    },
    "mainnet": {
        "near-wallet": {
            baseUrl: "https://wallet.near.org",
        },
        "my-near-wallet": {
            baseUrl: "https://app.mynearwallet.com",
        },
        "sweat-wallet": {
        }
    }
};

/**
 * Information to send NEAR wallet for signing transactions and redirecting the browser back to the calling application
 */
interface RequestSignTransactionsOptions {
    /** list of transactions to sign */
    transactions: wsTransaction[];

    moduleId: string;
    accountId: string;
    secretKey: string;
    near: Near;
}

/**
 * Requests the user to quickly sign for a transaction or batch of transactions by redirecting to the NEAR wallet.
 */
export const extSignAndSendTransactions = async ({ transactions, moduleId, accountId, secretKey, near }: RequestSignTransactionsOptions) => {
    let fakRequiredTxns: Transaction[] = [];
    let responses: FinalExecutionOutcome[] = [];

    const account = new Account(near.connection, accountId!);
    for (let i = 0; i < transactions.length; i++) {
        let txn = transactions[i];

        let mappedActions = txn.actions.map((a) => {
            const fcAction = a as FunctionCallAction
            return actionCreators.functionCall(
                fcAction.params.methodName,
                stringifyJsonOrBytes(fcAction.params.args),
                fcAction.params.gas,
                fcAction.params.deposit,
            )
        })

        const pk = PublicKey.from(getPubFromSecret(secretKey));

       const transaction = await convertBasicTransaction({
            txnInfo: {
                receiverId: txn.receiverId,
                signerId: txn.signerId,
                actions: mappedActions
            },
            signerId: accountId,
            signerPk: pk,
        })

        const accessKey: any = await near.connection.provider.query(
            `access_key/${accountId}/${pk}`,
            ''
        );

        const canExecuteTxn = await keyHasPermissionForTransaction(accessKey, txn.receiverId, mappedActions);

        if (canExecuteTxn) {
            try {
                responses.push(await account.signAndSendTransaction(transaction));
            } catch (e: any) {
                fakRequiredTxns.push(transaction);
            }
        } else {
            fakRequiredTxns.push(transaction);
        }
    }

    if(fakRequiredTxns.length > 0) {
        switch (moduleId) {
            case 'my-near-wallet':
            case 'near-wallet':
                nearWalletFAKSigning(fakRequiredTxns, near.config.networkId, moduleId)
                break;
            case 'sweat-wallet':
                console.warn('Sweat wallet does not support FAK signing yet')
                return [FAILED_EXECUTION_OUTCOME]
            default:
                console.warn('Unsupported wallet module: ', moduleId)
                return [FAILED_EXECUTION_OUTCOME]
        }
    }

    return responses;
}

export const nearWalletFAKSigning = (transactions, networkId, moduleId) => {
    const currentUrl = new URL(window.location.href);
    const baseUrl = SUPPORTED_EXT_WALLET_DATA[networkId][moduleId].baseUrl;
    const newUrl = new URL('sign', baseUrl);

    newUrl.searchParams.set('transactions', transactions
        .map(transaction => serialize(SCHEMA, transaction))
        .map(serialized => Buffer.from(serialized).toString('base64'))
        .join(','));
    newUrl.searchParams.set('callbackUrl', currentUrl.href);

    window.location.assign(newUrl.toString());
}
'''
'''--- packages/selector/src/core/setup.ts ---
import type {
    Transaction,
    WalletBehaviourFactory, WalletModuleFactory
} from '@near-wallet-selector/core';
import { MODAL_TYPE_IDS } from '../modal/src/lib/modal.types';
import { KEYPOM_MODULE_ID, KeypomParams, KeypomWalletInstant, isKeypomParams } from './types';
import { KeypomWallet } from './wallet';

interface KeypomInitializeOptions {
	keypomWallet: KeypomWallet;
}

const Keypom: WalletBehaviourFactory<
	KeypomWalletInstant,
	KeypomInitializeOptions
> = async ({ store, logger, keypomWallet }) => {
    // return the wallet interface for wallet-selector
    return {
        get networkId() {
            return keypomWallet.near.connection.networkId;
        },
        getContractId() {
            return keypomWallet.getContractId();
        },

        // async getAccount() {
        // 	return keypomWallet.getAccount();
        // },

        showModal(modalType = {id: MODAL_TYPE_IDS.TRIAL_OVER}) {
            keypomWallet.showModal(modalType);
        },

        async getAccounts() {
            logger.log('Keypom:account');
            return keypomWallet.getAccounts();
        },

        async switchAccount(id: string) {
            return await keypomWallet.switchAccount(id);
        },

        getAccountId() {
            logger.log('Keypom:getAccountId');
            return keypomWallet.getAccountId();
        },

        async isSignedIn() {
            logger.log('Keypom:isSignedIn');
            return await keypomWallet.isSignedIn();
        },

        async getAvailableBalance() {
            logger.log('Keypom:isSignedIn');
            return await keypomWallet.getAvailableBalance();
        },

        async verifyOwner() {
            throw Error('KeypomWallet:verifyOwner is deprecated');
        },

        async signIn() {
            logger.log('Keypom:signIn');
            return await keypomWallet.signIn();
        },

        async signOut() {
            logger.log('Keypom:signOut');
            return await keypomWallet.signOut();
        },

        async signAndSendTransaction(params) {
            return await keypomWallet.signAndSendTransaction(params);
        },

        async signAndSendTransactions(params) {
            // Convert the params to Array<Transaction>

            const transactions: Transaction[] = params.transactions.map((tx) => {
                return {
                    ...tx,
                    signerId: tx.signerId || keypomWallet.getAccountId(),
                };
            });

            logger.log('Keypom:signAndSendTransactions', params);
            return await keypomWallet.signAndSendTransactions({transactions});
        },
    };
};

export function setupKeypom({
    trialAccountSpecs,
    instantSignInSpecs,
    networkId,
    signInContractId
}: KeypomParams): WalletModuleFactory<KeypomWalletInstant> {
    return async () => {
        // Ensure that the passed in arguments are of type KeypomParams
        if (!isKeypomParams({signInContractId, networkId, trialAccountSpecs, instantSignInSpecs})) {
            console.warn('KeypomWallet: Invalid KeypomParams passed in. Please check the docs for the correct format.');
            return null;
        }

        if (!signInContractId || !networkId || !(instantSignInSpecs || trialAccountSpecs)) {
            console.warn('KeypomWallet: signInContractId, networkId and either instant sign in specs or trial account specs are required to use the KeypomWallet.');
            return null;
        }

        if (trialAccountSpecs && !(trialAccountSpecs.url.includes('ACCOUNT_ID') || trialAccountSpecs.url.includes('SECRET_KEY'))) {
            console.warn('KeypomWallet: trial account specs must include ACCOUNT_ID and SECRET_KEY in url');
            return null;
        }

        if (instantSignInSpecs && !(instantSignInSpecs.url.includes('ACCOUNT_ID') || instantSignInSpecs.url.includes('SECRET_KEY'))) {
            console.warn('KeypomWallet: trial account specs must include ACCOUNT_ID');
            return null;
        }
		
        const keypomWallet = new KeypomWallet({
            signInContractId,
            networkId,
            trialAccountSpecs,
            instantSignInSpecs
        });

        // CHECK URL / LOCAL STORAGE TO SEE IF A TRIAL ACCOUNT SHOULD BE SIGNED IN
        const shouldSignIn = keypomWallet.checkValidTrialInfo();
        console.log('shouldSignIn: ', shouldSignIn);

        return {
            id: KEYPOM_MODULE_ID,
            type: 'instant-link',
            metadata: {
                name: 'Keypom Account',
                description: null,
                iconUrl: '',
                deprecated: false,
                available: true,
                contractId: signInContractId,
                runOnStartup: shouldSignIn,
            },
            init: async (config) =>
                Keypom({
                    ...config,
                    keypomWallet,
                }),
        };
    };
}

'''
'''--- packages/selector/src/core/types.ts ---
import { InstantLinkWallet, NetworkId, Transaction } from '@near-wallet-selector/core';
import BN from 'bn.js';
import { KeypomWallet } from './wallet';
import { FinalExecutionOutcome } from '@near-js/types';
import { ModalCustomizations } from '../modal/src';

export const FAILED_EXECUTION_OUTCOME: FinalExecutionOutcome = {
    status: {
        Failure: {
            error_message: 'Invalid Trial Action',
            error_type: 'keypom-trial-error'
        }
    },
    transaction: {},
    transaction_outcome: {
        id: '',
        outcome: {
            logs: [],
            receipt_ids: [],
            tokens_burnt: '0',
            executor_id: '',
            gas_burnt: 0,
            status: {
                Failure: {
                    error_message: 'Invalid Trial Action',
                    error_type: 'keypom-trial-error'
                }
            },
        }
    },
    receipts_outcome: [{
        id: '',
        outcome: {
            logs: [],
            receipt_ids: [],
            gas_burnt: 0,
            tokens_burnt: '0',
            executor_id: '',
            status: {
                Failure: {
                    error_message: 'Invalid Trial Action',
                    error_type: 'keypom-trial-error'
                }
            },
        }
    }]
};

export const KEYPOM_MODULE_ID = 'keypom';

export interface InternalInstantSignInSpecs extends InstantSignInSpecs {
    moduleId?: string;
    baseUrl?: string;
    delimiter?: string;
    moduleDelimiter?: string;
}

export interface InternalTrialSignInSpecs extends TrialSignInSpecs {
    isMappingAccount: boolean;
    baseUrl?: string;
    delimiter?: string;
}

export interface InstantSignInSpecs {
    url: string;
}

export interface TrialSignInSpecs {
    url: string;
    modalOptions: ModalCustomizations;
}

export interface SignInOptions {
    contractId?: string;
    allowance?: string;
    methodNames?: string[];
}

export interface KeypomInitializeOptions {
    keypomWallet: KeypomWallet
}

export interface KeypomParams {
    networkId: NetworkId;
    signInContractId: string;
    trialAccountSpecs?: TrialSignInSpecs,
    instantSignInSpecs?: InstantSignInSpecs,
}

export const isTrialSignInSpecs = (obj: any): obj is TrialSignInSpecs =>
    typeof obj === 'object' && obj !== null &&
    obj.hasOwnProperty('url') && typeof obj.url === 'string' &&
    obj.hasOwnProperty('modalOptions') && typeof obj.modalOptions === 'object' && obj.modalOptions !== null;

export const isInstantSignInSpecs = (obj: any): obj is InstantSignInSpecs =>
    typeof obj === 'object' && obj !== null &&
    obj.hasOwnProperty('url') && typeof obj.url === 'string';

export const isKeypomParams = (obj: any): obj is KeypomParams =>
    typeof obj === 'object' && obj !== null &&
    obj.hasOwnProperty('networkId') && (obj.networkId === 'testnet' || obj.networkId === 'mainnet') &&
    obj.hasOwnProperty('signInContractId') && typeof obj.signInContractId === 'string' &&
    (obj.hasOwnProperty('trialAccountSpecs') || obj.hasOwnProperty('instantSignInSpecs')) &&
    (!obj.hasOwnProperty('trialAccountSpecs') || isTrialSignInSpecs(obj.trialAccountSpecs)) &&
    (!obj.hasOwnProperty('instantSignInSpecs') || isInstantSignInSpecs(obj.instantSignInSpecs));

export type KeypomWalletInstant = InstantLinkWallet & {
    networkId: string;
    getContractId(): string;
    switchAccount(id: string): Promise<void>;
    getAccountId(): string;
    isSignedIn: () => Promise<boolean>;
    getAvailableBalance: () => Promise<BN>;
    showModal();
};
'''
'''--- packages/selector/src/core/wallet.ts ---
import { TRIAL_ERRORS, getPubFromSecret, initKeypom, isUnclaimedTrialDrop, networks, trialSignAndSendTxns, viewAccessKeyData } from '@keypom/core';
import { Account } from '@near-js/accounts';
import { KeyPair } from '@near-js/crypto';
import { BrowserLocalStorageKeyStore } from '@near-js/keystores-browser';
import { FinalExecutionOutcome } from '@near-js/types';
import { Near } from '@near-js/wallet-account';
import { InstantLinkWalletBehaviour, Transaction } from '@near-wallet-selector/core';
import BN from 'bn.js';
import { KeypomTrialModal, setupModal } from '../modal/src';
import { MODAL_TYPE_IDS, ModalCustomizations } from '../modal/src/lib/modal.types';
import { KEYPOM_LOCAL_STORAGE_KEY, addUserToMappingContract, getAccountFromMap, getCidFromUrl, getLocalStorageKeypomEnv, parseIPFSDataFromURL, parseInstantSignInUrl, parseTrialUrl, setLocalStorageKeypomEnv, updateKeypomContractIfValid } from '../utils/selector-utils';
import { SUPPORTED_EXT_WALLET_DATA, extSignAndSendTransactions } from './ext_wallets';
import { FAILED_EXECUTION_OUTCOME, InstantSignInSpecs, InternalInstantSignInSpecs, InternalTrialSignInSpecs, KEYPOM_MODULE_ID, KeypomParams, TrialSignInSpecs } from './types';

const TRIAL_URL_REGEX = new RegExp(`(.*)ACCOUNT_ID(.*)SECRET_KEY`);
const INSTANT_URL_REGEX = new RegExp(`(.*)ACCOUNT_ID(.*)SECRET_KEY(.*)MODULE_ID`);

export class KeypomWallet implements InstantLinkWalletBehaviour {
    accountId?: string;
    secretKey?: string;
    moduleId?: string;

    signInContractId: string;
    
    near: Near;
    keyStore: BrowserLocalStorageKeyStore;

    trialAccountSpecs?: InternalTrialSignInSpecs;
    instantSignInSpecs?: InternalInstantSignInSpecs;

    modal?: KeypomTrialModal;

    public constructor({
        signInContractId,
        networkId,
        trialAccountSpecs,
        instantSignInSpecs,
    }: {
        signInContractId: string;
        networkId: string;
        trialAccountSpecs?: TrialSignInSpecs;
        instantSignInSpecs?: InstantSignInSpecs;
    }) {
        console.log('Initializing Keypom');
        this.signInContractId = signInContractId;

        this.keyStore = new BrowserLocalStorageKeyStore();
        this.near = new Near({
            ...networks[networkId],
            deps: { keyStore: this.keyStore },
        });

        // Only setup the modal if the CID is not present (as to not set it up twice).
        // In the case that the CID is present, it will be setup in `signIn()`
        let isCIDPresent = window.location.href.split("?cid=").length > 1;
        this.setSpecsFromKeypomParams({trialAccountSpecs, instantSignInSpecs, shouldSetupModal: !isCIDPresent});
    }

    getContractId(): string {
        return this.signInContractId;
    }

    getAccountId(): string {
        this.assertSignedIn();
        return this.accountId!;
    }

    async isSignedIn() {
        return this.accountId !== undefined && this.accountId !== null;
    }

    async signInTrialAccount(accountId, secretKey): Promise<Account[]> {
        // Check if this is an existing keypom drop that is claimable (case 1)
        const isOriginalLink = updateKeypomContractIfValid(accountId);
        console.log('isOriginalLink: ', isOriginalLink);
        
        // If the drop is from keypom, it is either unclaimed or claimed
        if (isOriginalLink) {
            try {
                const isUnclaimed = await isUnclaimedTrialDrop({keypomContractId: accountId, secretKey});
                console.log('isUnclaimed: ', isUnclaimed);
                
                // If the drop is unclaimed, we should show the unclaimed drop modal
                if (isUnclaimed === true) {
                    const cid = getCidFromUrl();
                    console.log('cid: ', cid)
                    let meta = {
                        secretKey,
                        redirectUrlBase: this.trialAccountSpecs!.baseUrl,
                        delimiter: this.trialAccountSpecs!.delimiter,
                        includedCid: cid == null ? undefined : cid
                    }
                    console.log('meta: ', meta)

                    this.modal!.show({
                        id: MODAL_TYPE_IDS.BEGIN_TRIAL,
                        meta
                    });
                    return [];
                } else {
                    // If the drop is claimed, we should attempt to recover the drop
                    console.log('DROP IS CLAIMED. RECOVERY TODO');
                    accountId = await getAccountFromMap(secretKey);
                }
            } catch(e) {
                console.log('e checking if drop is from keypom: ', e);
            }
        }
        
        // Check if the account ID and secret key are valid and sign in accordingly
        try {
            const keyInfo = await viewAccessKeyData({accountId, secretKey});

            const keyPerms = keyInfo.permission.FunctionCall;
            // Check if accountKeys's length is 1 and it has a `public_key` field
            if (keyPerms.receiver_id === accountId && keyPerms.method_names.includes('execute')) {
                // Check if the account exists in the mapping contract. If they do, don't do anything. If they
                // Don't, add them to the mapping contract
                const isAdding = await addUserToMappingContract(accountId, secretKey);
                
                if (isAdding) {
                    this.trialAccountSpecs!.isMappingAccount = true;
                }
                return this.internalSignIn(accountId, secretKey, KEYPOM_MODULE_ID);
            }
        } catch (e) {
            console.log('e: ', e);
        }

        // Invalid local storage info so return nothing
        return [];
    }

    async signInInstantAccount(accountId, secretKey, moduleId): Promise<Account[]> {
         // Check if the account ID and secret key are valid and sign in accordingly
         try {
            const account = new Account(this.near.connection, accountId);
            const allKeys = await account.getAccessKeys();
            const pk = getPubFromSecret(secretKey);

            const keyInfoView = allKeys.find(({public_key}) => public_key === pk);

            if (keyInfoView) {
                return this.internalSignIn(accountId, secretKey, moduleId);
            }
        } catch (e) {
            console.log('e: ', e);
        }

        return [];
    }

    async signIn(): Promise<Account[]> {        
        await initKeypom({
            network: this.near.connection.networkId
        });

        // If there is IPFS data in the URL, use that for the specs
        let ipfsData = await parseIPFSDataFromURL();
        if (ipfsData !== undefined) {
            this.setSpecsFromKeypomParams({
                trialAccountSpecs: ipfsData.trialAccountSpecs, 
                instantSignInSpecs: ipfsData.instantSignInSpecs,
                shouldSetupModal: true
            });
        }

        let instantSignInData = this.instantSignInSpecs?.baseUrl !== undefined ? parseInstantSignInUrl(this.instantSignInSpecs) : undefined;
        console.log('instantSignInData: ', instantSignInData)
        if (instantSignInData !== undefined) {
            if (SUPPORTED_EXT_WALLET_DATA[this.near.connection.networkId!][instantSignInData.moduleId] === undefined) {
                console.warn(`Module ID ${instantSignInData.moduleId} is not supported on ${this.near.connection.networkId}.`)
                return [];
            }
            
            return this.signInInstantAccount(instantSignInData.accountId, instantSignInData.secretKey, instantSignInData.moduleId);
        }
        
        let trialData = this.trialAccountSpecs?.baseUrl !== undefined ? parseTrialUrl(this.trialAccountSpecs) : undefined;
        console.log('trialData: ', trialData)
        if (trialData !== undefined) {
            return this.signInTrialAccount(trialData.accountId, trialData.secretKey);
        }

        // If the URL doesn't match the instant sign in or the trial data, resort to local storage.
        const curEnvData = getLocalStorageKeypomEnv();

        // If there is any data in local storage, default to that otherwise return empty array
        if (curEnvData !== null) {
            const { accountId, secretKey, moduleId } = JSON.parse(curEnvData);
            return this.internalSignIn(accountId, secretKey, moduleId);
        }

        return [];
    }

    async signOut() {
        if (this.accountId === undefined || this.accountId === null) {
            throw new Error('Wallet is already signed out');
        }

        this.accountId = this.secretKey = this.moduleId = undefined;
        await this.keyStore.removeKey(this.near.connection.networkId, this.accountId!);
        localStorage.removeItem(`${KEYPOM_LOCAL_STORAGE_KEY}:envData`);
    }

    async signAndSendTransaction(params) {
        this.assertSignedIn();
        console.log('sign and send txn params: ', params);
        const { receiverId, actions } = params;

        let res;
        try {
            res = await this.signAndSendTransactions({
                transactions: [
                    {
                        signerId: this.accountId!,
                        receiverId,
                        actions,
                    },
                ],
            });
        } catch (e) {
            /// user cancelled or near network error
            console.warn(e);
        }

        return res[0] as FinalExecutionOutcome;
    }

    async signAndSendTransactions(params: {transactions: Transaction[]}) {
        console.log('sign and send txns params inner: ', params);
        this.assertSignedIn();
        const { transactions } = params;

        let res: FinalExecutionOutcome[] = [];
        if (this.moduleId === KEYPOM_MODULE_ID) {
            try {
                if (!this.trialAccountSpecs!.isMappingAccount) {
                    addUserToMappingContract(this.accountId!, this.secretKey!);
                }
                res = await trialSignAndSendTxns({
                    trialAccountId: this.accountId!,
                    trialAccountSecretKey: this.secretKey!,
                    txns: transactions
                });
            } catch(e) {
                console.log(`e: ${JSON.stringify(e)}`);
                switch (e) {
                    case TRIAL_ERRORS.EXIT_EXPECTED: {
                        this.modal!.show({
                            id: MODAL_TYPE_IDS.TRIAL_OVER, 
                            meta: {
                                accountId: this.accountId!,
                                secretKey: this.secretKey!
                            }
                        });
                        break;
                    }
                    case TRIAL_ERRORS.INVALID_ACTION: {
                        this.modal!.show({id: MODAL_TYPE_IDS.ACTION_ERROR});
                        break;
                    }
                    case TRIAL_ERRORS.INSUFFICIENT_BALANCE: {
                        this.modal!.show({id: MODAL_TYPE_IDS.INSUFFICIENT_BALANCE});
                        break;
                    }
                    default: {
                        console.log('Unidentified error when signing txn: ', e);
                        break;
                    }
                }
                return [FAILED_EXECUTION_OUTCOME];
            }
        } else {
            return await extSignAndSendTransactions({
                transactions,
                moduleId: this.moduleId!,
                accountId: this.accountId!,
                secretKey: this.secretKey!,
                near: this.near
            })
        }
        console.log('res sign & send txn: ', res)
        return res;
    }

    public showModal = (modalType = {id: MODAL_TYPE_IDS.TRIAL_OVER}) => {
        console.log('modalType for show modal: ', modalType);
        this.modal!.show(modalType);
    };

    public checkValidTrialInfo = () => {
        let instantSignInData = this.instantSignInSpecs?.baseUrl !== undefined ? parseInstantSignInUrl(this.instantSignInSpecs) : undefined;
        let trialData = this.trialAccountSpecs?.baseUrl !== undefined ? parseTrialUrl(this.trialAccountSpecs) : undefined;
        let isCIDPresent = window.location.href.split("?cid=").length > 1;

        return instantSignInData !== undefined || trialData !== undefined || getLocalStorageKeypomEnv() !== null || isCIDPresent;
    };

    async verifyOwner() {
        throw Error(
            'KeypomWallet:verifyOwner is deprecated'
        );
    }

    async getAvailableBalance(id?: string): Promise<BN> {
        // TODO: get access key allowance
        return new BN(0);
    }

    async getAccounts(): Promise<Account[]> {
        if (this.accountId != undefined && this.accountId != null) {
            const accountObj = new Account(this.near.connection, this.accountId!);
            return [accountObj];
        }

        return [];
    }

    async switchAccount(id: string) {
        // TODO:  maybe?
    }

    private async internalSignIn (accountId, secretKey, moduleId) {
        console.log(`internalSignIn accountId ${accountId} secretKey ${secretKey} moduleId ${moduleId}`);
        this.accountId = accountId;
        this.secretKey = secretKey;
        this.moduleId = moduleId

        const dataToWrite = {
            accountId,
            secretKey,
            moduleId
        };
        setLocalStorageKeypomEnv(dataToWrite);
        await this.keyStore.setKey(this.near.connection.networkId, accountId, KeyPair.fromString(secretKey));

        const accountObj = new Account(this.near.connection, accountId);
        return [accountObj];
    }

    private assertSignedIn() {
        if (!this.accountId) {
            throw new Error('Wallet not signed in');
        }
    }

    private setSpecsFromKeypomParams({ trialAccountSpecs, instantSignInSpecs, shouldSetupModal}: { trialAccountSpecs?: TrialSignInSpecs, instantSignInSpecs?: InstantSignInSpecs, shouldSetupModal: boolean }) {
        let trialSpecs: InternalTrialSignInSpecs | undefined = undefined;
        if (trialAccountSpecs !== undefined) {
            // Get the base URL and delimiter by splitting the URL using ACCOUNT_ID and SECRET_KEY
            const matches = trialAccountSpecs.url.match(TRIAL_URL_REGEX);
            const baseUrl = matches?.[1]!;
            const delimiter = matches?.[2]!;

            trialSpecs = {
                ...trialAccountSpecs,
                isMappingAccount: false,
                baseUrl,
                delimiter
            }

            if (shouldSetupModal) {
                this.modal = setupModal(trialAccountSpecs!.modalOptions);
            }
        }
        this.trialAccountSpecs = trialSpecs;

        let instantSpecs: InternalInstantSignInSpecs | undefined = undefined;
        if (instantSignInSpecs !== undefined) {
            // Get the base URL and delimiter by splitting the URL using ACCOUNT_ID and SECRET_KEY
            const matches = instantSignInSpecs.url.match(INSTANT_URL_REGEX);
            const baseUrl = matches?.[1]!;
            const delimiter = matches?.[2]!;
            const moduleDelimiter = matches?.[3]!;

            instantSpecs = {
                ...instantSignInSpecs,
                baseUrl,
                delimiter,
                moduleDelimiter
            }
        }

        this.instantSignInSpecs = instantSpecs;
    }
}
'''
'''--- packages/selector/src/index.ts ---
export type { KeypomWallet } from './core/wallet';
export { setupKeypom } from './core/setup';
'''
'''--- packages/selector/src/modal/src/index.ts ---
export { setupModal } from './lib/modal';

export type {
    KeypomTrialModal,
    ModalCustomizations,
    Theme
} from './lib/modal.types';

'''
'''--- packages/selector/src/modal/src/lib/modal.types.ts ---
export type Theme = 'dark' | 'light' | 'auto';

export interface ModalCustomizations {
  wallets: OffboardingWallet[];
  theme?: Theme;
  beginTrial?: BeginTrialCustomizations,
  trialOver?: TrialOverCustomizations,
  invalidAction?: InvalidActionCustomizations,
  insufficientBalance?: InsufficientBalanceCustomizations,
}

export interface BeginTrialCustomizations {
  landing?: {
    title?: string;
    body?: string;
    fieldPlaceholder?: string;
    buttonText?: string;
    subText?: {
      landing?: string;
      invalidAccountId?: string;
      accountIdTaken?: string;
      accountIdAvailable?: string;
    }
  },
  claiming?: {
      title?: string;
      body?: string;
  },
  claimed?: {
      title?: string;
      body?: string;
      buttonText?: string;
  }
}

export interface TrialOverCustomizations {
  mainBody?: MainBodyCustomizations,
  offboardingOptions?: OffboardingWalletCustomizations
}

export interface MainBodyCustomizations {
  title?: string;
  body?: string;
  imageOne?: MainBodyImage,
  imageTwo?: MainBodyImage,
  button?: MainBodyButton
}

export interface OffboardingWalletCustomizations {
  title?: string;
}

export interface InvalidActionCustomizations {
  title?: string;
  body?: string;
}

export interface InsufficientBalanceCustomizations {
  title?: string;
  body?: string;
}

export interface OffboardingWallet {
  name: string;
  description: string;
  iconUrl: string;
  redirectUrl: string;
}

export interface MainBodyImage {
  title: string;
  body: string;
}

export interface MainBodyButton {
  url?: string;
  newTab?: boolean;
  text?: string;
}

export interface KeypomTrialModal {
  show(modalType?: ModalType): void;
  hide(): void;
}

export interface ModalType {
  id: string;
  meta?: any;
}

export const MODAL_TYPE_IDS = {
    BEGIN_TRIAL: 'begin-trial',
    TRIAL_OVER: 'trial-over',
    ACTION_ERROR: 'action-error',
    INSUFFICIENT_BALANCE: 'insufficient-balance'
};

export const MODAL_DEFAULTS = {
    beginTrial: {
        landing: {
            title: 'Create an Account',
            body: 'To start, enter a username.',
            fieldPlaceholder: 'Account Name',
            buttonText: 'Create',
            subText: {
                landing: 'Customize your account name.',
                invalidAccountId: 'Invalid Character in Account Name.'
            }
        },
        claiming: {
            title: 'Creating Account',
            body: 'Your account is being created. Please wait...',
        },
        claimed: {
            title: 'You\'re all set!🎉',
            body: 'Your account has been successfully created.',
            buttonText: 'Continue to app'
        }
    },
    trialOver: {
        mainBody: {
            title: 'Your trial has ended',
            body: 'Choose a wallet provider and onboard fully into the NEAR ecosystem.',
            imageOne: {
                title: 'Secure Your Digital Assets',
                body: 'Now that your trial is over, secure your account with an official wallet provider!'
            },
            imageTwo: {
                title: 'Log In to Any NEAR App',
                body: 'Once your account is secured, you can use any app on NEAR!'
            }
        },
        offboardingOptions: {
            title: 'Choose a Wallet',
        }
    },
    invalidAction: {
        title: 'Invalid Action',
        body: 'Your trial does not allow you to perform this action. For more information, please contact the site administrator.'
    },
    insufficientBalance: {
        title: 'Insufficient Balance',
        body: 'Your account does not have enough balance for the action you are trying to perform. Please try again with a different action. For more information, please contact the site administrator.'
    }
};

'''
'''--- packages/selector/src/utils/selector-utils.ts ---
import { accountMappingContract, getEnv, getPubFromSecret, supportedKeypomContracts, trialCallMethod, updateKeypomContractId } from '@keypom/core';
import { parseNearAmount } from '@near-js/utils';
import { InstantSignInSpecs, InternalInstantSignInSpecs, InternalTrialSignInSpecs, TrialSignInSpecs, isKeypomParams } from '../core/types';
import { Action } from '@near-js/transactions';
import { KeypomParams } from '../core/types';

export const KEYPOM_LOCAL_STORAGE_KEY = 'keypom-wallet-selector';

export const getLocalStorageKeypomEnv = () => {
    const localStorageDataJson = localStorage.getItem(`${KEYPOM_LOCAL_STORAGE_KEY}:envData`);
    return localStorageDataJson;
};

export const setLocalStorageKeypomEnv = (jsonData) => {
    const dataToWrite = JSON.stringify(jsonData);

    localStorage.setItem(`${KEYPOM_LOCAL_STORAGE_KEY}:envData`, dataToWrite);
};

export const getAccountFromMap = async (secretKey) => {
    const {viewCall} = getEnv();
    const pk = getPubFromSecret(secretKey);

    const accountId = await viewCall({
        contractId: accountMappingContract[getEnv().networkId!],
        methodName: 'get_account_id',
        args: {pk}
    });
    console.log('accountId found from map: ', accountId);
	
    return accountId;
};

/**
 * Check if given access key allows the function call or method attempted in transaction
 * @param accessKey Array of \{access_key: AccessKey, public_key: PublicKey\} items
 * @param receiverId The NEAR account attempting to have access
 * @param actions The action(s) needed to be checked for access
 */
export const keyHasPermissionForTransaction = async (accessKey, receiverId: string, actions: Action[]): Promise<boolean> => {
    console.log('accessKey: ', accessKey)
    const { permission } = accessKey;
    if (permission === 'FullAccess') {
        return true;
    }

    if (permission.FunctionCall) {
        const { receiver_id: allowedReceiverId, method_names: allowedMethods } = permission.FunctionCall;
        if (allowedReceiverId === receiverId) {
            let allowed = true;
            
            for (const action of actions) {
                const { functionCall } = action;
                if (!(functionCall && (!functionCall.deposit || functionCall.deposit.toString() === '0') && // TODO: Should support charging amount smaller than allowance?
                    (allowedMethods.length === 0 || allowedMethods.includes(functionCall.methodName)))) {
                    allowed = false;
                    break;
                }
            }

            return allowed;
        }
    }

    return false;
}

export const getCidFromUrl = () => {
    let split = window.location.href.split("?cid=");

    if (split.length > 1) {
        const cid = split[1];
        console.log("found CID in URL: ", cid);
        return cid;
    }

    return null;
}

export const parseIPFSDataFromURL = async () => {
    const cid = getCidFromUrl();

    if (cid != null) {
        const response = await fetch(`https://cloudflare-ipfs.com/ipfs/${cid}`);
        const data = await response.json();

        if (isKeypomParams(data)) {
            console.log('Successfully parsed Keypom params from URL: ', data);
            return data;
        } else {
            console.log('data can not be cast to Keypom params: ', data);
        }
    } else {
        console.log('no cid found in URL');
    }

    return;
};

export const addUserToMappingContract = async (accountId, secretKey) => {
    const accountIdFromMapping = await getAccountFromMap(secretKey);

    if (accountIdFromMapping !== accountId) {
        console.log(`No Account ID found from mapping contract: ${JSON.stringify(accountIdFromMapping)} Adding now.`);
        trialCallMethod({
            trialAccountId: accountId,
            trialAccountSecretKey: secretKey,
            contractId: accountMappingContract[getEnv().networkId!],
            methodName: 'set',
            args: {},
            attachedDeposit: parseNearAmount('0.002')!,
            attachedGas: '10000000000000'
        });
    }

    return accountIdFromMapping !== accountId;
};

const isValidKeypomContract = (keypomContractId: string) => {
    const { networkId } = getEnv();
    return supportedKeypomContracts[networkId!][keypomContractId] !== undefined;
};

export const updateKeypomContractIfValid = (keypomContractId) => {
    if (isValidKeypomContract(keypomContractId) === true) {
        updateKeypomContractId({
            keypomContractId
        });

        return true;
    }

    return false;
};

export const parseTrialUrl = (trialSpecs: InternalTrialSignInSpecs) => {
    const {baseUrl, delimiter} = trialSpecs;
    console.log(`Parse trial URL with base: ${baseUrl} and delim: ${delimiter}`);

    // remove everything after ?cid= in the URL if it's present
    const split = window.location.href.split("?cid=")[0].split(baseUrl!);

    if (split.length !== 2) {
        return;
    }

    const trialInfo = split[1];
    const [accountId, secretKey] = trialInfo.split(delimiter!);

    if (!accountId || !secretKey) {
        return;
    }

    return {
        accountId,
        secretKey
    };
};

export const parseInstantSignInUrl = (instantSignInSpecs: InternalInstantSignInSpecs) => {
    const {baseUrl, delimiter, moduleDelimiter} = instantSignInSpecs;

    console.log(`Parse instant sign in URL with base: ${baseUrl} delim: ${delimiter} and module delim: ${moduleDelimiter}`);

    // remove everything after ?cid= in the URL if it's present
    const split = window.location.href.split("?cid=")[0].split(baseUrl!);

    if (split.length !== 2) {
        return;
    }

    const signInInfo = split[1];

    // Get the account ID, secret key, and module ID based on the two delimiters `delimiter` and `moduleDelimiter`
    const regex = new RegExp(`(.*)${delimiter}(.*)${moduleDelimiter}(.*)`);
    const matches = signInInfo.match(regex);
    const accountId = matches?.[1];
    const secretKey = matches?.[2];
    const moduleId = matches?.[3];

    if (!accountId || !secretKey || !moduleId) {
        return;
    }

    return {
        accountId,
        secretKey,
        moduleId
    };
};
'''
'''--- packages/selector/test/instant-sign-in.ts ---
const path = require("path");
const homedir = require("os").homedir();
const { readFileSync } = require('fs');
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require('@near-js/accounts');
const { connect, Near } = require("@near-js/wallet-account");
const { initKeypom, createTrialAccountDrop, generateKeys,claimTrialAccountDrop, getEnv } = require('@keypom/core');
const { parseNearAmount } = require('@near-js/utils');

const accountId = 'benjiman.testnet';
const NETWORK_ID = 'testnet';
const instances = {
    guestBook: {
        url:  "http://localhost:1234/instant-url#ACCOUNT_ID/SECRET_KEY/MODULE_ID",
        moduleId: 'my-near-wallet',
        contract: 'guest-book.examples.keypom.testnet',
        allowance: parseNearAmount('0.1'),
        numLinks: 1
    },
    discovery: {
        url: "http://localhost:3000/#instant-url/ACCOUNT_ID/SECRET_KEY/MODULE_ID",
        moduleId: 'my-near-wallet',
        contract: 'v1.social08.testnet',
        allowance: parseNearAmount('0.1'),
        numLinks: 1
    }
}

async function createInstantSignIn() {
	// Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = '.near-credentials';
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const accountObj = new Account(near.connection, accountId);

	// Initialize the SDK and point it to the custom NEAR object that was created.
    await initKeypom({
		near,
		network: NETWORK_ID
	});

    // Loop through each key in the instances object and get the value's numLinks property
    for (const [key, value] of Object.entries(instances)) {
        console.log(`\n\n`)

        let numKeys = value.numLinks;
        const {secretKeys, publicKeys} = await generateKeys({numKeys});

        for (const publicKey of publicKeys) {
            await accountObj.addKey(publicKey, value.contract, '', value.allowance);
        }

        let returnedURLs = [];
         // loop through all secret keys
         secretKeys.forEach((secretKey) => {
            // insert the secret key into the base URL
            let url = value.url.replace('SECRET_KEY', secretKey);
            url = url.replace('ACCOUNT_ID', accountId);
            url = url.replace('MODULE_ID', value.moduleId);

            // add the URL to the array of URLs
            returnedURLs.push(url);
        });

        console.log(`${key}:`)
        console.log(returnedURLs.join('\n'));
    }

    console.log(`\n\n`)
}

createInstantSignIn();
'''
'''--- packages/selector/test/trial-accounts.ts ---
const path = require("path");
const homedir = require("os").homedir();
const { readFileSync } = require('fs');
const { UnencryptedFileSystemKeyStore } = require("@near-js/keystores-node");
const { Account } = require('@near-js/accounts');
const { connect, Near } = require("@near-js/wallet-account");
const { initKeypom, createTrialAccountDrop, generateKeys,claimTrialAccountDrop, getEnv } = require('@keypom/core');
const { parseNearAmount } = require('@near-js/utils');

const funderAccountId = 'benjiman.testnet';
const NETWORK_ID = 'testnet';
// What URLs should be returned
const instances = {
    guestBook: "http://localhost:1234/trial-url#ACCOUNT_ID/SECRET_KEY",
    discovery: "http://localhost:3000/#trial-url/ACCOUNT_ID/SECRET_KEY"

}
// What contracts can the trial account call?
const callableContracts = [
    'guest-book.examples.keypom.testnet',
    'v1.social08.testnet'
]
// What is the maximum amount of $NEAR that can be attached to a call for each callable contract?
const maxAttachableNEARPerContract = [
    '1',
    '1'
]
// What methods can the trial account call?
const callableMethods = [
    ['*'],
    ['*']
]
// How much $NEAR should be made available to the trial account when it's created?
const startingBalanceNEAR = 0.5;
// Once the trial account has spent this much $NEAR, the trial will be over.
const trialEndFloorNEAR = 0.01;

const numKeys = 1;
const claimTrialAccounts = false;
const includedCID; // = "bafkreidneri4ffymscahjprlapg4j62yleli73ncwdmopnkxpgczpusqn4"

async function createTrialAccount() {
	// Initiate connection to the NEAR blockchain.
    const CREDENTIALS_DIR = '.near-credentials';
    const credentialsPath =  path.join(homedir, CREDENTIALS_DIR);

    let keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);  

    let nearConfig = {
        networkId: NETWORK_ID,
        keyStore: keyStore,
        nodeUrl: `https://rpc.${NETWORK_ID}.near.org`,
        walletUrl: `https://wallet.${NETWORK_ID}.near.org`,
        helperUrl: `https://helper.${NETWORK_ID}.near.org`,
        explorerUrl: `https://explorer.${NETWORK_ID}.near.org`,
    };  

    let near = new Near(nearConfig);
    const fundingAccount = new Account(near.connection, funderAccountId);

	// Initialize the SDK and point it to the custom NEAR object that was created.
    await initKeypom({
		near,
		network: NETWORK_ID
	});

    const wasmDirectory = `${require('path').resolve(__dirname, '.')}/ext-wasm/trial-accounts.wasm`
    const {keys: {secretKeys}, dropId} = await createTrialAccountDrop({
		account: fundingAccount,
        numKeys,
        contractBytes: [...readFileSync(wasmDirectory)],
        startingBalanceNEAR,
        callableContracts,
        callableMethods,
        maxAttachableNEARPerContract,
        trialEndFloorNEAR
    })

    let accountIds = [];
    if (claimTrialAccounts !== false) {
        let incr = 0;
        for (const secretKey of secretKeys) {
            const newAccountId = `trial-drop-${dropId}_num-${incr}.testnet`
            accountIds.push(newAccountId);

            await claimTrialAccountDrop({
                secretKey,
                desiredAccountId: newAccountId
            })
            incr += 1;
        }
    }

    const {contractId: keypomContractId} = getEnv();
    // Loop through the instances
    for (const [key, value] of Object.entries(instances)) {
        console.log(`\n\n`)
        // insert the contractId and secret key into the base URL based on the CONTRACT_ID and SECRET_KEY field
        const returnedURLs = [];

        let incr = 0;
        // loop through all secret keys
        secretKeys.forEach((secretKey) => {
            // insert the secret key into the base URL
            let url = value.replace('SECRET_KEY', secretKey);

            if (claimTrialAccounts !== false) {
                // insert the contract ID into the base URL
                url = url.replace('ACCOUNT_ID', accountIds[incr]);
            } else {
                // insert the contract ID into the base URL
                url = url.replace('ACCOUNT_ID', keypomContractId);
            }

            if (includedCID !== undefined) {
                url = url + `?cid=${includedCID}`
            }
            // add the URL to the array of URLs
            returnedURLs.push(url);
            incr += 1;
        });

        console.log(`${key}:`)
        console.log(returnedURLs.join('\n'));
    }

    console.log(`\n\n`)
}

createTrialAccount();
'''
'''--- packages/selector/tsconfig.json ---
{
	"include": [
		"src/**/*"
	],
	"exclude": [
		"node_modules"
	],
	"compilerOptions": {
		"jsx": "react",
		/* Visit https://aka.ms/tsconfig to read more about this file */
		"incremental": true, /* Enable incremental compilation */
		"target": "es5", /* Specify ECMAScript target version: */
		"declaration": true, /* Concatenate & emit output to single file.*/
		"outDir": "lib", /* Redirect output to the directory. */
		/* Projects */
		// "incremental": true,                              /* Save .tsbuildinfo files to allow for incremental compilation of projects. */
		// "composite": true,                                /* Enable constraints that allow a TypeScript project to be used with project references. */
		// "tsBuildInfoFile": "./.tsbuildinfo",              /* Specify the path to .tsbuildinfo incremental compilation file. */
		// "disableSourceOfProjectReferenceRedirect": true,  /* Disable preferring source files instead of declaration files when referencing composite projects. */
		// "disableSolutionSearching": true,                 /* Opt a project out of multi-project reference checking when editing. */
		// "disableReferencedProjectLoad": true,             /* Reduce the number of projects loaded automatically by TypeScript. */
		/* Language and Environment */ /* Set the JavaScript language version for emitted JavaScript and include compatible library declarations. */
		// "lib": [],                                        /* Specify a set of bundled library declaration files that describe the target runtime environment. */
		// "jsx": "preserve",                                /* Specify what JSX code is generated. */
		// "experimentalDecorators": true,                   /* Enable experimental support for TC39 stage 2 draft decorators. */
		// "emitDecoratorMetadata": true,                    /* Emit design-type metadata for decorated declarations in source files. */
		// "jsxFactory": "",                                 /* Specify the JSX factory function used when targeting React JSX emit, e.g. 'React.createElement' or 'h'. */
		// "jsxFragmentFactory": "",                         /* Specify the JSX Fragment reference used for fragments when targeting React JSX emit e.g. 'React.Fragment' or 'Fragment'. */
		// "jsxImportSource": "",                            /* Specify module specifier used to import the JSX factory functions when using 'jsx: react-jsx*'. */
		// "reactNamespace": "",                             /* Specify the object invoked for 'createElement'. This only applies when targeting 'react' JSX emit. */
		// "noLib": true,                                    /* Disable including any library files, including the default lib.d.ts. */
		// "useDefineForClassFields": true,                  /* Emit ECMAScript-standard-compliant class fields. */
		// "moduleDetection": "auto",                        /* Control what method is used to detect module-format JS files. */
		/* Modules */
		"module": "commonjs", /* Specify what module code is generated. */
		// "rootDir": "./src",                                  /* Specify the root folder within your source files. */
		// "moduleResolution": "node",                       /* Specify how TypeScript looks up a file from a given module specifier. */
		// "baseUrl": "./",                                  /* Specify the base directory to resolve non-relative module names. */
		// "paths": {},                                      /* Specify a set of entries that re-map imports to additional lookup locations. */
		// "rootDirs": [],                                   /* Allow multiple folders to be treated as one when resolving modules. */
		// "typeRoots": [],                                  /* Specify multiple folders that act like './node_modules/@types'. */
		// "types": [],                                      /* Specify type package names to be included without being referenced in a source file. */
		// "allowUmdGlobalAccess": true,                     /* Allow accessing UMD globals from modules. */
		// "moduleSuffixes": [],                             /* List of file name suffixes to search when resolving a module. */
		// "resolveJsonModule": true,                        /* Enable importing .json files. */
		// "noResolve": true,                                /* Disallow 'import's, 'require's or '<reference>'s from expanding the number of files TypeScript should add to a project. */
		/* JavaScript Support */
		"allowJs": true, /* Allow JavaScript files to be a part of your program. Use the 'checkJS' option to get errors from these files. */
		// "checkJs": true,                                  /* Enable error reporting in type-checked JavaScript files. */
		// "maxNodeModuleJsDepth": 1,                        /* Specify the maximum folder depth used for checking JavaScript files from 'node_modules'. Only applicable with 'allowJs'. */
		/* Emit */
		// "declaration": true,                              /* Generate .d.ts files from TypeScript and JavaScript files in your project. */
		// "declarationMap": true,                           /* Create sourcemaps for d.ts files. */
		// "emitDeclarationOnly": true,                      /* Only output d.ts files and not JavaScript files. */
		// "sourceMap": true,                                /* Create source map files for emitted JavaScript files. */
		// "outFile": "./",                                  /* Specify a file that bundles all outputs into one JavaScript file. If 'declaration' is true, also designates a file that bundles all .d.ts output. */
		// "outDir": "./",                                   /* Specify an output folder for all emitted files. */
		// "removeComments": true,                           /* Disable emitting comments. */
		// "noEmit": true,                                   /* Disable emitting files from a compilation. */
		// "importHelpers": true,                            /* Allow importing helper functions from tslib once per project, instead of including them per-file. */
		// "importsNotUsedAsValues": "remove",               /* Specify emit/checking behavior for imports that are only used for types. */
		// "downlevelIteration": true,                       /* Emit more compliant, but verbose and less performant JavaScript for iteration. */
		// "sourceRoot": "",                                 /* Specify the root path for debuggers to find the reference source code. */
		// "mapRoot": "",                                    /* Specify the location where debugger should locate map files instead of generated locations. */
		// "inlineSourceMap": true,                          /* Include sourcemap files inside the emitted JavaScript. */
		// "inlineSources": true,                            /* Include source code in the sourcemaps inside the emitted JavaScript. */
		// "emitBOM": true,                                  /* Emit a UTF-8 Byte Order Mark (BOM) in the beginning of output files. */
		// "newLine": "crlf",                                /* Set the newline character for emitting files. */
		// "stripInternal": true,                            /* Disable emitting declarations that have '@internal' in their JSDoc comments. */
		// "noEmitHelpers": true,                            /* Disable generating custom helper functions like '__extends' in compiled output. */
		// "noEmitOnError": true,                            /* Disable emitting files if any type checking errors are reported. */
		// "preserveConstEnums": true,                       /* Disable erasing 'const enum' declarations in generated code. */
		// "declarationDir": "./",                           /* Specify the output directory for generated declaration files. */
		// "preserveValueImports": true,                     /* Preserve unused imported values in the JavaScript output that would otherwise be removed. */
		/* Interop Constraints */
		// "isolatedModules": true,                          /* Ensure that each file can be safely transpiled without relying on other imports. */
		// "allowSyntheticDefaultImports": true,             /* Allow 'import x from y' when a module doesn't have a default export. */
		"esModuleInterop": true, /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables 'allowSyntheticDefaultImports' for type compatibility. */
		// "preserveSymlinks": true,                         /* Disable resolving symlinks to their realpath. This correlates to the same flag in node. */
		"forceConsistentCasingInFileNames": true, /* Ensure that casing is correct in imports. */
		/* Type Checking */
		"strict": true, /* Enable all strict type-checking options. */
		"noImplicitAny": false, /* Enable error reporting for expressions and declarations with an implied 'any' type. */
		// "strictNullChecks": true,                         /* When type checking, take into account 'null' and 'undefined'. */
		// "strictFunctionTypes": true,                      /* When assigning functions, check to ensure parameters and the return values are subtype-compatible. */
		// "strictBindCallApply": true,                      /* Check that the arguments for 'bind', 'call', and 'apply' methods match the original function. */
		// "strictPropertyInitialization": true,             /* Check for class properties that are declared but not set in the constructor. */
		// "noImplicitThis": true,                           /* Enable error reporting when 'this' is given the type 'any'. */
		// "useUnknownInCatchVariables": true,               /* Default catch clause variables as 'unknown' instead of 'any'. */
		// "alwaysStrict": true,                             /* Ensure 'use strict' is always emitted. */
		// "noUnusedLocals": true,                           /* Enable error reporting when local variables aren't read. */
		// "noUnusedParameters": true,                       /* Raise an error when a function parameter isn't read. */
		// "exactOptionalPropertyTypes": true,               /* Interpret optional property types as written, rather than adding 'undefined'. */
		// "noImplicitReturns": true,                        /* Enable error reporting for codepaths that do not explicitly return in a function. */
		// "noFallthroughCasesInSwitch": true,               /* Enable error reporting for fallthrough cases in switch statements. */
		// "noUncheckedIndexedAccess": true,                 /* Add 'undefined' to a type when accessed using an index. */
		// "noImplicitOverride": true,                       /* Ensure overriding members in derived classes are marked with an override modifier. */
		// "noPropertyAccessFromIndexSignature": true,       /* Enforces using indexed accessors for keys declared using an indexed type. */
		// "allowUnusedLabels": true,                        /* Disable error reporting for unused labels. */
		// "allowUnreachableCode": true,                     /* Disable error reporting for unreachable code. */
		/* Completeness */
		// "skipDefaultLibCheck": true,                      /* Skip type checking .d.ts files that are included with TypeScript. */
		"skipLibCheck": true /* Skip type checking all .d.ts files. */
	}
}
'''
'''--- packages/selector/typedoc.json ---
{
  "$schema": "https://typedoc.org/schema.json",
  "entryPoints": ["./src/index.ts"],
  "out": "docs"
}
'''
'''--- tsconfig.base.json ---
{
    "compilerOptions": {
        "esModuleInterop": true,
        "module": "commonjs",
        "target": "es2015",
        "moduleResolution": "node",
        "alwaysStrict": true,
        "declaration": true,
        "preserveSymlinks": true,
        "preserveWatchOutput": true,
        "pretty": false,
        "forceConsistentCasingInFileNames": true,
        "noFallthroughCasesInSwitch": true,
        "noImplicitAny": false,
        "noImplicitReturns": true,
        "noUnusedLocals": true,
        "experimentalDecorators": true,
        "resolveJsonModule": true
        // "types": ["node"]
    }
}

'''
'''--- tsconfig.browser.json ---
{
    "extends": "./tsconfig.base.json",
    "compilerOptions": {
        "lib": [
            "es2015",
            "esnext",
            "dom"
        ],
    }
}

'''
'''--- tsconfig.node.json ---
{
    "extends": "./tsconfig.base.json",
    "compilerOptions": {
        "lib": [
            "es2015",
            "esnext"
        ],
    }
}

'''
'''--- turbo.json ---
{
  "$schema": "https://turborepo.org/schema.json",
  "pipeline": {
    "build": {
      "dependsOn": ["^build"],
      "inputs": ["src/**/*.ts", "test/**/*.js"],
      "outputs": ["dist/**", "lib/**"]
    },
    "test": {
      /* TODO remove once near-api-js tests are removed or packages/accounts/tests gets its own set of keys */
      "dependsOn": ["^test"],
      "inputs": ["src/**/*.ts", "test/**/*.js"]
    },
    "lint": {
      "inputs": ["src/**/*.ts", "test/**/*.js"],
      "outputs": []
    },
    "lint:js": {
      "inputs": ["test/**/*.js"],
      "outputs": []
    },
    "lint:js:fix": {
      "inputs": ["test/**/*.js"],
      "outputs": []
    },
    "lint:ts": {
        "inputs": ["src/**/*.ts"],
        "outputs": []
    },
    "lint:ts:fix": {
        "inputs": ["src/**/*.ts"],
        "outputs": []
    },
    "clean": {
      "outputs": [],
      "cache": false
    }
  }
}

'''