*GitHub Repository "Learn-NEAR/NCD--near-merge-data"*

'''--- .cargo/audit.toml ---
[advisories]
# warn for categories of informational advisories
informational_warnings = [
    "unmaintained",
    "unsound",
]

[target]
arch = "wasm32"

'''
'''--- .cargo/config.toml ---
[build]
rustflags = ["-C", "link-arg=-s"]

'''
'''--- .github/workflows/contract.yml ---
on: [push]

name: contract

jobs:

  fmt:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          components: rustfmt
          profile: minimal
          override: true
      - uses: actions-rs/cargo@v1
        with:
          command: fmt
          args: --all -- --check

  clippy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          components: clippy
          profile: minimal
          override: true
      - uses: actions-rs/clippy-check@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          args: --all-targets

  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/audit-check@v1
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions-rs/toolchain@v1
        with:
          target: wasm32-unknown-unknown
          toolchain: stable
          profile: minimal
          override: true
      - run: make test-contract

'''
'''--- Cargo.toml ---
[package]
name = "merge-data"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]
test = true
doctest = false
bench = false
doc = false

[dev-dependencies]
near-sdk-sim = "3.1.0"

[dependencies]
near-sdk = "3.1.0"
hex = "0.4.3"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- readme.md ---
<div align="center">
  <h1><code>near-merge-data</code></h1>
  <p>
    <strong>Implementation payable check data (imitation via sort) on NEAR Protocol</strong>
  </p>
</div>

## Feature

1. Input parameters — arrays, at least 2
2. Sorting options for arrays: ascending (`true`), descending (`false`), do not sort (`undefined`)
3. Make sure that all arrays are not empty — otherwise throw an error
4. Check that attached deposit is not zero — otherwise it throws an error
5. Sort each array separately — depending on the input sort parameter
6. Merge arrays according to their order of passing in function parameters
7. Transfer funds in the amount of 1 yocto per array to the one who called the contract (predecessor)
8. Return the resulting array
9. Test coverage (unit, integration)

## Usage

```shell
accountId=ilyar.testnet
contractName="merge-data.ilyar.testnet"
near --accountId $accountId --amount 0.25 call $contractName merge '{"data": [[102, 111], [98, 97, 114]]}'
near --accountId $accountId --amount 0.25 call $contractName merge '{"data": [[102, 111], [98, 97, 114]], "sort": true}'
near --accountId $accountId --amount 0.25 call $contractName merge '{"data": [[102, 111], [98, 97, 114]], "sort": false}'
```

## Develop

```shell
make fix 
make qa
make build
make clean
```

### Run CI local

Installation [act](https://github.com/nektos/act):
```shell
brew install act
```

Setup env vars:
```shell
echo "GITHUB_TOKEN=%GITHUB_TOKEN%" | tee .secrets
```

Run
```shell
act --help
```

## Deploy test

```shell
accountId=ilyar.testnet
make build
near dev-deploy
contractName=$(cat neardev/dev-account)
near state $contractName
near delete $contractName $accountId
near clean
```

## Deploy

```shell
make qa
make build
export NEAR_ENV=testnet
accountId=ilyar.testnet
contractName="merge-data.$accountId"
near create-account --masterAccount $accountId $contractName 
near deploy $contractName
contractName=$(cat neardev/dev-account)
near state $contractName
```

'''
'''--- src/lib.rs ---
use near_sdk::borsh;
use near_sdk::borsh::BorshDeserialize;
use near_sdk::borsh::BorshSerialize;
use near_sdk::collections::LookupSet;
use near_sdk::env;
use near_sdk::near_bindgen;
use near_sdk::setup_alloc;
use near_sdk::BorshStorageKey;
use near_sdk::{Balance, Promise};

setup_alloc!();

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Hash,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct MergeData {
    hash_set: LookupSet<String>,
}

impl Default for MergeData {
    fn default() -> Self {
        Self {
            hash_set: LookupSet::new(StorageKey::Hash),
        }
    }
}

fn is_empty(data: &[Vec<u8>]) -> bool {
    if data.is_empty() || data.len() < 2 {
        return true;
    }
    for item in data {
        if item.is_empty() {
            return true;
        }
    }
    false
}

#[near_bindgen]
impl MergeData {
    /// ```bash
    /// near view mergeData.YOU.testnet merge {"data": [[102, 111, 111], [102, 111, 111]]}'
    /// ```
    #[payable]
    pub fn merge(&mut self, data: Vec<Vec<u8>>, sort: Option<bool>) -> Vec<u8> {
        let amount = data.len() as Balance;
        if is_empty(&data) {
            env::panic(b"Given empty data")
        }
        let deposit = env::attached_deposit();
        if deposit == 0 {
            env::panic(b"Given empty deposit")
        }
        let mut result = vec![];
        for mut item in data {
            if sort != None {
                item.sort_unstable();
                if sort == Some(false) {
                    item.reverse()
                }
            }
            result.append(&mut item);
        }
        let checksum = hex::encode(env::sha256(&result));
        if self.hash_set.contains(&checksum) {
            return result;
        }
        if !self.hash_set.insert(&checksum) {
            env::panic(b"Failed to save checksum");
        }
        let account_id = env::predecessor_account_id();
        Promise::new(account_id).transfer(amount);
        result
    }
}

#[cfg(test)]
mod unit {
    use super::*;
    use near_sdk::test_utils::accounts;
    use near_sdk::test_utils::VMContextBuilder;
    use near_sdk::testing_env;
    use near_sdk::MockedBlockchain;

    fn context() -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder.signer_account_id(accounts(0));
        builder
    }

    #[test]
    #[should_panic(expected = "Given empty data")]
    fn merge_empty_data() {
        testing_env!(context().build());
        let mut contract = MergeData::default();
        contract.merge(vec![], None);
    }

    #[test]
    #[should_panic(expected = "Given empty deposit")]
    fn merge_empty_deposit() {
        testing_env!(context().build());
        let mut contract = MergeData::default();
        contract.merge(vec![vec![1], vec![2]], None);
    }

    #[test]
    fn merge_sort_none() {
        testing_env!(context().attached_deposit(1).build());
        let mut contract = MergeData::default();
        let actual = contract.merge(vec![vec![2, 1, 3], vec![4, 3, 5]], None);
        assert_eq!(vec![2, 1, 3, 4, 3, 5], actual);
    }

    #[test]
    fn merge_sort_asc() {
        testing_env!(context().attached_deposit(1).build());
        let mut contract = MergeData::default();
        let actual = contract.merge(vec![vec![2, 1, 3], vec![4, 3, 5]], Some(true));
        assert_eq!(vec![1, 2, 3, 3, 4, 5], actual);
    }

    #[test]
    fn merge_sort_desc() {
        testing_env!(context().attached_deposit(1).build());
        let mut contract = MergeData::default();
        let actual = contract.merge(vec![vec![2, 1, 3], vec![4, 3, 5]], Some(false));
        assert_eq!(vec![3, 2, 1, 5, 4, 3], actual);
    }
}

'''
'''--- tests/integration/main.rs ---
mod merge_test;
mod utils;

'''
'''--- tests/integration/merge_test.rs ---
use near_sdk::serde_json::json;
use near_sdk_sim::to_yocto;
use near_sdk_sim::DEFAULT_GAS;

use crate::utils::init;
use crate::utils::print_burnt;
use crate::utils::to_gas;

#[test]
fn empty_data() {
    let (root, contract, _alice) = init();
    let result = root.call(
        contract.account_id(),
        "merge",
        &[].to_vec(),
        DEFAULT_GAS,
        0, // deposit
    );
    print_burnt(&result);
    assert_eq!(result.promise_errors().len(), 1);
    assert!(result.gas_burnt() <= to_gas("2.7"));
    assert!(result.tokens_burnt() <= to_yocto("0.0003"));
}

#[test]
fn empty_deposit() {
    let (root, contract, _alice) = init();
    let result = root.call(
        contract.account_id(),
        "merge",
        &json!({
            "data": [[1], [2]]
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS,
        0, // deposit
    );
    print_burnt(&result);
    assert_eq!(result.promise_errors().len(), 1);
    assert!(result.gas_burnt() <= to_gas("2.7"));
    assert!(result.tokens_burnt() <= to_yocto("0.0003"));
}

#[test]
fn merge() {
    let (root, contract, _alice) = init();
    let result = root.call(
        contract.account_id(),
        "merge",
        &json!({
            "data": [[2], [1]]
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS,
        1, // deposit
    );
    let actual: Vec<u8> = result.unwrap_json();
    assert_eq!(vec![2, 1], actual);
    print_burnt(&result);
    assert!(result.gas_burnt() <= to_gas("3.3"));
    assert!(result.tokens_burnt() <= to_yocto("0.0004"));
}

'''
'''--- tests/integration/utils.rs ---
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    CONTRACT_WASM_BYTES => "out/main.wasm",
}

use near_sdk_sim::init_simulator;
use near_sdk_sim::to_yocto;
use near_sdk_sim::ExecutionResult;
use near_sdk_sim::UserAccount;
use near_sdk_sim::STORAGE_AMOUNT;

const CONTRACT_ID: &str = "contract";

pub fn init() -> (UserAccount, UserAccount, UserAccount) {
    // Use `None` for default genesis configuration; more info below
    let root = init_simulator(None);

    let contract = root.deploy(
        &CONTRACT_WASM_BYTES,
        CONTRACT_ID.to_string(),
        STORAGE_AMOUNT, // attached deposit
    );

    let alice = root.create_user(
        "alice".to_string(),
        to_yocto("100"), // initial balance
    );

    (root, contract, alice)
}

pub fn print_burnt(result: &ExecutionResult) {
    println!(
        "burnt tokens: {:.05}Ⓝ gas: {:.02} TeraGas",
        (result.tokens_burnt()) as f64 / 1e24,
        (result.gas_burnt()) as f64 / 1e12,
    );
}

pub fn to_gas(tera_gas: &str) -> u64 {
    let part: Vec<_> = tera_gas.split('.').collect();
    let number = part[0].parse::<u64>().unwrap() * u64::pow(10, 12);
    if part.len() > 1 {
        let power = part[1].len() as u32;
        let mantissa = part[1].parse::<u64>().unwrap() * u64::pow(10, 12 - power);
        number + mantissa
    } else {
        number
    }
}

'''