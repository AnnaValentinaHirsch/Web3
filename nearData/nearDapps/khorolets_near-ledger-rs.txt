*GitHub Repository "khorolets/near-ledger-rs"*

'''--- .github/workflows/rust.yml ---
name: Rust

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always

jobs:
  check:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
    - name: apt-get update
      run: sudo apt-get update
    - name: Install libudev
      run: sudo apt-get -y install libudev-dev libsystemd-dev
    - name: Check
      run: cargo check --verbose --examples
    # this compiles doc examples
    - name: test
      run: cargo test

'''
'''--- Cargo.toml ---
[package]
name = "near-ledger"
version = "0.5.0"
edition = "2018"
authors = ["Bohdan Khorolets <b@khorolets.com>"]
description = "Transport library to integrate with NEAR Ledger app"
repository = "https://github.com/khorolets/near-ledger-rs/"
license = "GPL-3.0-or-later"
keywords = ["ledger", "nearprotocol"]

[[example]]
name = "get_version"

[[example]]
name = "get_public_key_display"
path = "examples/get_public_key/display.rs"

[[example]]
name = "get_public_key_silent"
path = "examples/get_public_key/silent.rs"

[[example]]
name = "get_wallet_id"
path = "examples/get_wallet_id.rs"

[[example]]
name = "sign_transfer"
path = "examples/sign_transaction/transfer.rs"

[[example]]
name = "sign_create_account"
path = "examples/sign_transaction/create_account.rs"

[[example]]
name = "sign_delete_account_short"
path = "examples/sign_transaction/delete_account_short.rs"

[[example]]
name = "sign_delete_account_long"
path = "examples/sign_transaction/delete_account_long.rs"

[[example]]
name = "sign_delete_key_ed25519"
path = "examples/sign_transaction/delete_key_ed25519.rs"

[[example]]
name = "sign_delete_key_secp256k1"
path = "examples/sign_transaction/delete_key_secp256k1.rs"

[[example]]
name = "sign_stake"
path = "examples/sign_transaction/stake.rs"

[[example]]
name = "sign_add_key_fullaccess"
path = "examples/sign_transaction/add_key_fullaccess.rs"

[[example]]
name = "sign_add_key_functioncall"
path = "examples/sign_transaction/add_key_functioncall.rs"

[[example]]
name = "sign_deploy_contract"
path = "examples/sign_transaction/deploy_contract.rs"

[[example]]
name = "sign_functioncall_str"
path = "examples/sign_transaction/functioncall_str.rs"

[[example]]
name = "sign_functioncall_bin"
path = "examples/sign_transaction/functioncall_bin.rs"

[[example]]
name = "sign_functioncall_str_parse_err"
path = "examples/sign_transaction/functioncall_str_parse_err.rs"

[[example]]
name = "sign_batch_all_actions"
path = "examples/sign_transaction/batch_all_actions.rs"

[[example]]
name = "sign_nep_413_message"
path = "examples/sign_nep_413_message.rs"

[[example]]
name = "sign_nep_366_delegate_action"
path = "examples/sign_nep_366_delegate_action.rs"

[dependencies]
ed25519-dalek = { version = "1" }
ledger-transport = "0.10.0"
ledger-transport-hid = "0.10.0"
ledger-apdu = "0.10.0"
slip10 = "0.4.3"
log = "0.4.20"
hex = "0.4.3"
near-primitives-core = "0.20.0"
near-primitives = "0.20.0"

[dev-dependencies]
env_logger = "0.10.0"
near-crypto = "0.20.0"
near-primitives = "0.20.0"
near-account-id = { version = "1.0.0", features = ["internal_unstable"]}

'''
'''--- README.md ---
# near-ledger-rs

[![Rust](https://github.com/khorolets/near-ledger-rs/actions/workflows/rust.yml/badge.svg?branch=main)](https://github.com/khorolets/near-ledger-rs/actions/workflows/rust.yml)
[![](http://meritbadge.herokuapp.com/near-ledger)](https://crates.io/crates/near-ledger)
[![]( https://docs.rs/near-ledger/badge.svg)]( https://docs.rs/near-ledger/)

It is NEAR <-> Ledger transport

Provides a set of commands that can be executed to communicate with NEAR App installed on Ledger device:

* Read PublicKey from Ledger device by HD Path
* Sign a Transaction

## Examples

### Get PublicKey from Ledger

```rust
use near_ledger::get_public_key;
use slip10::BIP32Path;
use std::str::FromStr;

let hd_path = BIP32Path::from_str("44'/397'/0'/0'/1'").unwrap();
let public_key = get_public_key(hd_path).unwrap();
println!("{:#?}", public_key);
```

#### Trick

To convert the answer into `near_crypto::PublicKey` do:

```rust
let public_key = near_crypto::PublicKey::ED25519(
    near_crypto::ED25519PublicKey::from(
        public_key.to_bytes(),
    )
);
```

### How to sign a transaction

```rust
use near_ledger::{sign_transaction, SignTarget};
use near_primitives::borsh::BorshSerialize;
use slip10::BIP32Path;
use std::str::FromStr;

let hd_path = BIP32Path::from_str("44'/397'/0'/0'/1'").unwrap();
let borsh_transaction = near_unsigned_transaction.try_to_vec().unwrap();
let signature = sign_transaction(SignTarget::BorshUnsignedTx(borsh_transaction), hd_path).unwrap();
println!("{:#?}", signature);
```

#### Trick

To convert the answer into `near_crypto::Signature` do:

```rust
let signature = near_crypto::Signature::from_parts(near_crypto::KeyType::ED25519, &signature)
    .expect("Signature is not expected to fail on deserialization");
```

## Executable examples

### Get version

```bash
RUST_LOG=info cargo run --example get_version
```

### Get PublicKey from Ledger

#### Display

```bash
RUST_LOG=info cargo run --example get_public_key_display
```
#### Silent

```bash
RUST_LOG=info cargo run --example get_public_key_silent
```

### Get WalletID from Ledger

```bash
RUST_LOG=info cargo run --example get_wallet_id
```
### Sign a transaction

#### Transfer

```bash
RUST_LOG=info cargo run --example sign_transfer
```

#### Other

```bash
export RUST_LOG=info
cargo run --example sign_create_account
cargo run --example sign_delete_account_short
cargo run --example sign_delete_account_long
cargo run --example sign_delete_key_ed25519
cargo run --example sign_delete_key_secp256k1
cargo run --example sign_stake
cargo run --example sign_add_key_fullaccess
cargo run --example sign_add_key_functioncall
cargo run --example sign_deploy_contract
cargo run --example sign_functioncall_str
cargo run --example sign_functioncall_bin
cargo run --example sign_functioncall_str_parse_err
cargo run --example sign_batch_all_actions
```

### Sign a NEP-413 message

```bash
RUST_LOG=info cargo run --example sign_nep_413_message
```

### Sign a NEP-366 delegate action

```bash
RUST_LOG=info cargo run --example sign_nep_366_delegate_action
```

'''
'''--- SECURITY.md ---
# Security Policy

## Supported Versions

Use this section to tell people about which versions of your project are
currently being supported with security updates.

| Version | Supported          |
| ------- | ------------------ |
| 5.1.x   | :white_check_mark: |
| 5.0.x   | :x:                |
| 4.0.x   | :white_check_mark: |
| < 4.0   | :x:                |

## Reporting a Vulnerability

Use this section to tell people how to report a vulnerability.

Tell them where to go, how often they can expect to get an update on a
reported vulnerability, what to expect if the vulnerability is accepted or
declined, etc.

'''
'''--- examples/common/lib.rs ---
#![allow(unused)]
use std::str::FromStr;

use ed25519_dalek::Signature;
use ed25519_dalek::Verifier;
use near_ledger::NEARLedgerError;
use near_primitives_core::{borsh, borsh::BorshSerialize, hash::CryptoHash, types::AccountId};
use slip10::BIP32Path;

use near_crypto::SecretKey;
use near_primitives::transaction::{DeployContractAction, FunctionCallAction};

pub fn display_pub_key(public_key: ed25519_dalek::PublicKey) {
    log::info!("---");
    log::info!("Public key:");
    log::info!("{:?}", public_key);
    log::info!("{:<10} : {}", "hex", hex::encode(public_key));
    log::info!(
        "{:<10} : {}",
        "base58",
        near_crypto::PublicKey::ED25519(
            near_crypto::ED25519PublicKey::from(public_key.to_bytes(),)
        )
    );
    log::info!("---");
}

pub fn tx_template(
    ledger_pub_key: ed25519_dalek::PublicKey,
) -> near_primitives::transaction::Transaction {
    let public_key = near_crypto::PublicKey::ED25519(near_crypto::ED25519PublicKey::from(
        ledger_pub_key.to_bytes(),
    ));
    let block_hash = "Cb3vKNiF3MUuVoqfjuEFCgSNPT79pbuVfXXd2RxDXc5E"
        .parse::<CryptoHash>()
        .unwrap();

    let signer_account_str = hex::encode(&ledger_pub_key.to_bytes());
    let receiver_account_str = "dc7e34eecec3096a4a661e10932834f801149c49dba9b93322f6d9de18047f9c";

    near_primitives::transaction::Transaction {
        public_key,
        block_hash,
        nonce: 103595482000005,
        signer_id: AccountId::from_str(&signer_account_str).unwrap(),
        receiver_id: AccountId::from_str(receiver_account_str).unwrap(),
        actions: vec![],
    }
}

fn derive_secp256k1_public_key(public_key: &ed25519_dalek::PublicKey) -> near_crypto::PublicKey {
    let sk = SecretKey::from_seed(
        near_crypto::KeyType::SECP256K1,
        &format!("{:?}", public_key),
    );
    sk.public_key()
}

#[allow(deprecated)]
pub fn batch_of_all_types_of_actions(
    ledger_pub_key: ed25519_dalek::PublicKey,
) -> Vec<near_primitives::transaction::Action> {
    let create_account = near_primitives::transaction::Action::CreateAccount(
        near_primitives::transaction::CreateAccountAction {},
    );

    let delete_account = near_primitives::transaction::Action::DeleteAccount(
        near_primitives::transaction::DeleteAccountAction {
            beneficiary_id: AccountId::new_unvalidated(
                "dc7e34eecec3096a4a661e10932834f801149c49dba9b93322f6d9de18047f9c1b11b3b31673033936ad07bddc01f9da27d974811e480fb197c799e23480a489".to_string()),
        },
    );

    let delete_key_ed25519 = {
        let sk = SecretKey::from_seed(
            near_crypto::KeyType::ED25519,
            &format!("{:?}", ledger_pub_key),
        );
        let public_key_ed = sk.public_key();
        near_primitives::transaction::Action::DeleteKey(Box::new(
            near_primitives::transaction::DeleteKeyAction {
                public_key: public_key_ed,
            },
        ))
    };

    let delete_key_secp256k1 = near_primitives::transaction::Action::DeleteKey(Box::new(
        near_primitives::transaction::DeleteKeyAction {
            public_key: derive_secp256k1_public_key(&ledger_pub_key),
        },
    ));

    let stake = near_primitives::transaction::Action::Stake(Box::new(
        near_primitives::transaction::StakeAction {
            stake: 1157130000000000000000000, // 1.15713 NEAR,
            public_key: derive_secp256k1_public_key(&ledger_pub_key),
        },
    ));

    let add_key_fullaccess = near_primitives::transaction::Action::AddKey(Box::new(
        near_primitives::transaction::AddKeyAction {
            public_key: derive_secp256k1_public_key(&ledger_pub_key),
            access_key: near_primitives_core::account::AccessKey {
                nonce: 127127127127,
                permission: near_primitives_core::account::AccessKeyPermission::FullAccess,
            },
        },
    ));

    let add_key_function_call = {
        let permission = {
            let method_names = vec![
                "first_method",
                "saturating_add_signed",
                "iterator_chain_to_do_multiple_instances_of_an_operation_that_can_fail",
                "from_residual",
                "from_output",
                "unwrap_err_unchecked",
                "try_reserve_exact",
                "first_method",
                "saturating_add_signed",
                "iterator_chain_to_do_multiple_instances_of_an_operation_that_can_fail",
            ]
            .into_iter()
            .map(Into::into)
            .collect::<Vec<_>>();
            near_primitives_core::account::FunctionCallPermission {
                    allowance: Some(150000000000000000000),
                    receiver_id:
                    "dc7e34eecec3096a4a661e10932834f801149c49dba9b93322f6d9de18047f9c1b11b3b31673033936ad07bddc01f9da27d974811e480fb197c799e23480a489".into(),
                    method_names,
                }
        };
        near_primitives::transaction::Action::AddKey(Box::new(
            near_primitives::transaction::AddKeyAction {
                public_key: derive_secp256k1_public_key(&ledger_pub_key),
                access_key: near_primitives_core::account::AccessKey {
                    nonce: 127127127127,
                    permission: near_primitives_core::account::AccessKeyPermission::FunctionCall(
                        permission,
                    ),
                },
            },
        ))
    };

    let transfer = near_primitives::transaction::Action::Transfer(
        near_primitives::transaction::TransferAction {
            deposit: 150000000000000000000000, // 0.15 NEAR
        },
    );

    let deploy_contract = {
        let code = core::iter::repeat(42u8).take(30).collect::<Vec<_>>();

        let code_hash = CryptoHash::hash_bytes(&code);
        log::info!("Contract code hash: {:?}", code_hash);
        near_primitives::transaction::Action::DeployContract(DeployContractAction { code })
    };

    let function_call_str_args = {
        let args_str = r#"{"previous_vesting_schedule_with_salt":{"vesting_schedule":{"start_timestamp":"1577919600000000000","cliff_timestamp":"1609455600000000000","end_timestamp":"1704150000000000000"},"salt":"7bc709c22801118b743fae3866edb4dea1630a97ab9cd67e993428b94a0f397a"}, "vesting_schedule_with_salt":{"vesting_schedule":{"start_timestamp":"1577919600000000000","cliff_timestamp":"1609455600000000000","end_timestamp":"1704150000000000000"},"salt":"7bc709c22801118b743fae3866edb4dea1630a97ab9cd67e993428b94a0f397aababab"}}"#;

        let f_call = FunctionCallAction {
            method_name: "saturating_add_signed".to_string(),
            args: args_str.as_bytes().to_vec(),
            gas: 127127122121,
            deposit: 150000000000000000000000, // 0.15 NEAR,
        };
        near_primitives::transaction::Action::FunctionCall(Box::new(f_call))
    };

    let function_call_binary_args = {
        let args_binary = hex::decode("204f6e206f6c646572207465726d696e616c732c2074686520756e64657273636f726520636f646520697320646973706c617965642061732061206c6566740a202020202020206172726f772c2063616c6c6564206261636b6172726f772c2074686520636172657420697320646973706c6179656420617320616e2075702d6172726f770a20202020202020616e642074686520766572746963616c2062617220686173206120686f6c6520696e20746865206d6964646c652e0a0a2020202020202055707065726361736520616e64206c6f77657263617365206368617261637465727320646966666572206279206a757374206f6e652062697420616e64207468650a20202020202020415343494920636861726163746572203220646966666572732066726f6d2074686520646f75626c652071756f7465206279206a757374206f6e65206269742c0a20202020202020746f6f2e202054686174206d616465206974206d7563682065617369657220746f20656e636f64652063686172616374657273206d656368616e6963616c6c790a202020202020206f7220776974682061206e6f6e2d6d6963726f636f6e74726f6c6c65722d626173656420656c656374726f6e6963206b6579626f61726420616e6420746861740a2020202020202070616972696e672077617320666f756e64206f6e206f6c642074656c6574797065732e0a").unwrap();

        let f_call = FunctionCallAction {
            method_name: "saturating_add_signed".to_string(),
            args: args_binary,
            gas: 127127122121,
            deposit: 150000000000000000000000, // 0.15 NEAR,
        };
        near_primitives::transaction::Action::FunctionCall(Box::new(f_call))
    };

    let function_call_binary_args_after_parse_error = {
        let mut bytes = vec![];
        bytes.push(123u8);

        bytes.extend((0..255).into_iter().collect::<Vec<_>>());

        let f_call = FunctionCallAction {
            method_name: "saturating_add_signed".to_string(),
            args: bytes,
            gas: 127127122121,
            deposit: 150000000000000000000000, // 0.15 NEAR,
        };

        near_primitives::transaction::Action::FunctionCall(Box::new(f_call))
    };

    vec![
        create_account,
        delete_account,
        delete_key_ed25519,
        delete_key_secp256k1,
        stake,
        add_key_fullaccess,
        add_key_function_call,
        transfer,
        deploy_contract,
        function_call_str_args,
        function_call_binary_args,
        function_call_binary_args_after_parse_error,
    ]
}

pub fn serialize_and_display_tx(transaction: near_primitives::transaction::Transaction) -> Vec<u8> {
    log::info!("---");
    log::info!("Transaction:");
    log::info!("{:#?}", transaction);
    let bytes =
        borsh::to_vec(&transaction).expect("Transaction is not expected to fail on serialization");
    log::info!("transaction byte array length: {}", bytes.len());
    log::info!("---");
    bytes
}
pub fn display_signature(signature_bytes: Vec<u8>) -> ed25519_dalek::Signature {
    log::info!("---");
    log::info!("Signature:");
    let signature = Signature::from_bytes(&signature_bytes).unwrap();

    let signature_near =
        near_crypto::Signature::from_parts(near_crypto::KeyType::ED25519, &signature_bytes)
            .expect("Signature is not expected to fail on deserialization");
    log::info!("{:<20} : {}", "signature (hex)", signature);
    log::info!("{:<20} : {}", "signature (base58)", signature_near);
    signature
}

pub fn display_and_verify_signature(
    msg: Vec<u8>,
    signature_bytes: Vec<u8>,
    public_key: ed25519_dalek::PublicKey,
) {
    let signature = display_signature(signature_bytes);
    assert!(public_key
        .verify(&CryptoHash::hash_bytes(&msg).as_ref(), &signature)
        .is_ok());
    log::info!("---");
}

pub fn get_key_sign_and_verify_flow<F>(f_transaction: F) -> Result<(), NEARLedgerError>
where
    F: FnOnce(ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction,
{
    env_logger::builder().init();
    let hd_path = BIP32Path::from_str("44'/397'/0'/0'/1'").unwrap();

    let ledger_pub_key = near_ledger::get_public_key_with_display_flag(hd_path.clone(), false)?;
    display_pub_key(ledger_pub_key);

    let unsigned_transaction = f_transaction(ledger_pub_key);

    let bytes = serialize_and_display_tx(unsigned_transaction);
    let signature_bytes = near_ledger::sign_transaction(bytes.clone(), hd_path)?;

    display_and_verify_signature(bytes, signature_bytes, ledger_pub_key);

    Ok(())
}

'''
'''--- examples/get_public_key/display.rs ---
use std::str::FromStr;

use near_ledger::{get_public_key_with_display_flag, NEARLedgerError};
use slip10::BIP32Path;

#[path = "../common/lib.rs"]
mod common;

fn main() -> Result<(), NEARLedgerError> {
    env_logger::builder().init();
    let hd_path = BIP32Path::from_str("44'/397'/0'/0'/1'").unwrap();

    let public_key = get_public_key_with_display_flag(hd_path, true)?;

    common::display_pub_key(public_key);

    Ok(())
}

'''
'''--- examples/get_public_key/silent.rs ---
use std::str::FromStr;

use near_ledger::{get_public_key_with_display_flag, NEARLedgerError};
use slip10::BIP32Path;

#[path = "../common/lib.rs"]
mod common;

fn main() -> Result<(), NEARLedgerError> {
    env_logger::builder().init();
    let hd_path = BIP32Path::from_str("44'/397'/0'/0'/1'").unwrap();

    let public_key = get_public_key_with_display_flag(hd_path, false)?;

    common::display_pub_key(public_key);

    Ok(())
}

'''
'''--- examples/get_version.rs ---
use env_logger;
use near_ledger::{get_version, NEARLedgerError};

fn main() -> Result<(), NEARLedgerError> {
    env_logger::builder().init();

    let version = get_version()?;

    log::info!("{:#?}", version);
    Ok(())
}

'''
'''--- examples/get_wallet_id.rs ---
use std::str::FromStr;

use near_ledger::{get_wallet_id, NEARLedgerError};
use slip10::BIP32Path;

#[path = "./common/lib.rs"]
mod common;

fn main() -> Result<(), NEARLedgerError> {
    env_logger::builder().init();
    let hd_path = BIP32Path::from_str("44'/397'/0'/0'/1'").unwrap();

    let public_key = get_wallet_id(hd_path)?;

    common::display_pub_key(public_key);

    Ok(())
}

'''
'''--- examples/sign_nep_366_delegate_action.rs ---
use std::{convert::TryInto, str::FromStr};

use near_account_id::AccountId;
use near_crypto::Signature;
use near_ledger::NEARLedgerError;
use near_primitives::action::delegate::{DelegateAction, SignedDelegateAction};
use slip10::BIP32Path;

use crate::common::display_pub_key;

#[path = "./common/lib.rs"]
mod common;

fn main() -> Result<(), NEARLedgerError> {
    env_logger::builder().init();

    let hd_path = BIP32Path::from_str("44'/397'/0'/0'/1'").unwrap();
    let ledger_pub_key = near_ledger::get_public_key_with_display_flag(hd_path.clone(), false)?;
    display_pub_key(ledger_pub_key);

    let sender_id = AccountId::from_str("bob.near").unwrap();

    let actions = common::batch_of_all_types_of_actions(ledger_pub_key)
        .into_iter()
        .map(|action| action.try_into().unwrap())
        .collect::<Vec<_>>();

    let ledger_pub_key = near_crypto::PublicKey::ED25519(near_crypto::ED25519PublicKey::from(
        ledger_pub_key.to_bytes(),
    ));

    let delegate_action = DelegateAction {
        sender_id,
        receiver_id: AccountId::from_str("alice.near").unwrap(),
        actions,
        nonce: 127127122121,
        max_block_height: 100500,
        public_key: ledger_pub_key,
    };

    let signature_bytes =
        near_ledger::sign_message_nep366_delegate_action(&delegate_action, hd_path)?;

    let signature = Signature::from_parts(near_crypto::KeyType::ED25519, &signature_bytes).unwrap();

    let signed_delegate = SignedDelegateAction {
        delegate_action,
        signature,
    };
    log::info!("{:#?}", signed_delegate);
    assert!(signed_delegate.verify());

    common::display_signature(signature_bytes);
    Ok(())
}

'''
'''--- examples/sign_nep_413_message.rs ---
use std::str::FromStr;

use ed25519_dalek::Signature;
use ed25519_dalek::Verifier;
use near_ledger::{NEARLedgerError, NEP413Payload};
use near_primitives::signable_message::{MessageDiscriminant, SignableMessage};
use near_primitives_core::{borsh, hash::CryptoHash};
use slip10::BIP32Path;

use crate::common::display_pub_key;

#[path = "./common/lib.rs"]
mod common;

pub fn display_and_verify_signature(
    msg: &NEP413Payload,
    signature_bytes: Vec<u8>,
    public_key: ed25519_dalek::PublicKey,
) {
    log::info!("---");
    log::info!("Signature:");
    let signature = Signature::from_bytes(&signature_bytes).unwrap();

    let msg_discriminant = MessageDiscriminant::new_off_chain(413).unwrap();
    let signable_message = SignableMessage {
        discriminant: msg_discriminant,
        msg,
    };

    let hash = CryptoHash::hash_bytes(&borsh::to_vec(&signable_message).unwrap());

    let signature_near =
        near_crypto::Signature::from_parts(near_crypto::KeyType::ED25519, &signature_bytes)
            .expect("Signature is not expected to fail on deserialization");
    log::info!("{:<20} : {}", "signature (hex)", signature);
    log::info!("{:<20} : {}", "signature (base58)", signature_near);

    assert!(public_key.verify(&hash.as_ref(), &signature).is_ok());
    log::info!("---");
}

fn main() -> Result<(), NEARLedgerError> {
    env_logger::builder().init();

    let hd_path = BIP32Path::from_str("44'/397'/0'/0'/1'").unwrap();
    let public_key = near_ledger::get_public_key_with_display_flag(hd_path.clone(), false)?;
    display_pub_key(public_key);

    let msg = NEP413Payload {
        messsage: "Makes it possible to authenticate users without having to add new access keys. This will improve UX, save money and will not increase the on-chain storage of the users' accounts./Makes it possible to authenticate users without having to add new access keys. This will improve UX, save money and will not increase the on-chain storage of the users' accounts./Makes it possible to authenticate users without having to add new access keys. This will improve UX, save money and will not increase the on-chain storage of the users' accounts.".to_string(),
        nonce: [42; 32],
        recipient: "alice.near".to_string(),
        callback_url: Some("myapp.com/callback".to_string()) 
    };

    let signature_bytes = near_ledger::sign_message_nep413(&msg, hd_path)?;

    display_and_verify_signature(&msg, signature_bytes, public_key);

    Ok(())
}

'''
'''--- examples/sign_transaction/add_key_fullaccess.rs ---
use near_crypto::SecretKey;
use near_ledger::NEARLedgerError;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key.clone());
    let sk = SecretKey::from_seed(
        near_crypto::KeyType::SECP256K1,
        &format!("{:?}", ledger_pub_key),
    );
    let public_key = sk.public_key();
    tx.actions = vec![near_primitives::transaction::Action::AddKey(Box::new(
        near_primitives::transaction::AddKeyAction {
            public_key,
            access_key: near_primitives_core::account::AccessKey {
                nonce: 127127127127,
                permission: near_primitives_core::account::AccessKeyPermission::FullAccess,
            },
        },
    ))];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- examples/sign_transaction/add_key_functioncall.rs ---
use near_crypto::SecretKey;
use near_ledger::NEARLedgerError;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key.clone());
    let sk = SecretKey::from_seed(
        near_crypto::KeyType::SECP256K1,
        &format!("{:?}", ledger_pub_key),
    );
    let public_key = sk.public_key();
    let method_names = vec![
        "first_method",
        "saturating_add_signed",
        "iterator_chain_to_do_multiple_instances_of_an_operation_that_can_fail",
        "from_residual",
        "from_output",
        "unwrap_err_unchecked",
        "try_reserve_exact",
        "first_method",
        "saturating_add_signed",
        "iterator_chain_to_do_multiple_instances_of_an_operation_that_can_fail",
    ]
    .into_iter()
    .map(Into::into)
    .collect::<Vec<_>>();

    let permission = near_primitives_core::account::FunctionCallPermission {
        allowance: Some(150000000000000000000),
        receiver_id:
        "dc7e34eecec3096a4a661e10932834f801149c49dba9b93322f6d9de18047f9c1b11b3b31673033936ad07bddc01f9da27d974811e480fb197c799e23480a489".into(),
        method_names,
    };

    tx.actions = vec![near_primitives::transaction::Action::AddKey(Box::new(
        near_primitives::transaction::AddKeyAction {
            public_key,
            access_key: near_primitives_core::account::AccessKey {
                nonce: 127127127127,
                permission: near_primitives_core::account::AccessKeyPermission::FunctionCall(
                    permission,
                ),
            },
        },
    ))];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- examples/sign_transaction/batch_all_actions.rs ---
use near_ledger::NEARLedgerError;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key.clone());
    tx.actions = common::batch_of_all_types_of_actions(ledger_pub_key);
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- examples/sign_transaction/create_account.rs ---
use near_ledger::NEARLedgerError;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key);
    tx.actions = vec![near_primitives::transaction::Action::CreateAccount(
        near_primitives::transaction::CreateAccountAction {},
    )];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- examples/sign_transaction/delete_account_long.rs ---
use near_account_id::AccountId;
use near_ledger::NEARLedgerError;

#[path = "../common/lib.rs"]
mod common;

#[allow(deprecated)]
fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key);
    tx.actions = vec![near_primitives::transaction::Action::DeleteAccount(
        near_primitives::transaction::DeleteAccountAction {
            beneficiary_id: AccountId::new_unvalidated(
                "dc7e34eecec3096a4a661e10932834f801149c49dba9b93322f6d9de18047f9c1b11b3b31673033936ad07bddc01f9da27d974811e480fb197c799e23480a489".to_string()),
        },
    )];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- examples/sign_transaction/delete_account_short.rs ---
use std::str::FromStr;

use near_account_id::AccountId;
use near_ledger::NEARLedgerError;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key);
    tx.actions = vec![near_primitives::transaction::Action::DeleteAccount(
        near_primitives::transaction::DeleteAccountAction {
            beneficiary_id: AccountId::from_str("bob.near").unwrap(),
        },
    )];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- examples/sign_transaction/delete_key_ed25519.rs ---
use near_crypto::SecretKey;
use near_ledger::NEARLedgerError;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key.clone());
    let sk = SecretKey::from_seed(
        near_crypto::KeyType::ED25519,
        &format!("{:?}", ledger_pub_key),
    );
    let public_key = sk.public_key();
    tx.actions = vec![near_primitives::transaction::Action::DeleteKey(Box::new(
        near_primitives::transaction::DeleteKeyAction { public_key },
    ))];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- examples/sign_transaction/delete_key_secp256k1.rs ---
use near_crypto::SecretKey;
use near_ledger::NEARLedgerError;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key.clone());
    let sk = SecretKey::from_seed(
        near_crypto::KeyType::SECP256K1,
        &format!("{:?}", ledger_pub_key),
    );
    let public_key = sk.public_key();
    tx.actions = vec![near_primitives::transaction::Action::DeleteKey(Box::new(
        near_primitives::transaction::DeleteKeyAction { public_key },
    ))];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- examples/sign_transaction/deploy_contract.rs ---
use near_ledger::NEARLedgerError;
use near_primitives::transaction::DeployContractAction;
use near_primitives_core::hash::CryptoHash;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key);

    let code = core::iter::repeat(42u8).take(3000).collect::<Vec<_>>();

    let code_hash = CryptoHash::hash_bytes(&code);
    log::info!("Contract code hash: {:?}", code_hash);
    tx.actions = vec![near_primitives::transaction::Action::DeployContract(
        DeployContractAction { code },
    )];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- examples/sign_transaction/functioncall_bin.rs ---
use near_ledger::NEARLedgerError;
use near_primitives::transaction::FunctionCallAction;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key.clone());

    let args = hex::decode("204f6e206f6c646572207465726d696e616c732c2074686520756e64657273636f726520636f646520697320646973706c617965642061732061206c6566740a202020202020206172726f772c2063616c6c6564206261636b6172726f772c2074686520636172657420697320646973706c6179656420617320616e2075702d6172726f770a20202020202020616e642074686520766572746963616c2062617220686173206120686f6c6520696e20746865206d6964646c652e0a0a2020202020202055707065726361736520616e64206c6f77657263617365206368617261637465727320646966666572206279206a757374206f6e652062697420616e64207468650a20202020202020415343494920636861726163746572203220646966666572732066726f6d2074686520646f75626c652071756f7465206279206a757374206f6e65206269742c0a20202020202020746f6f2e202054686174206d616465206974206d7563682065617369657220746f20656e636f64652063686172616374657273206d656368616e6963616c6c790a202020202020206f7220776974682061206e6f6e2d6d6963726f636f6e74726f6c6c65722d626173656420656c656374726f6e6963206b6579626f61726420616e6420746861740a2020202020202070616972696e672077617320666f756e64206f6e206f6c642074656c6574797065732e0a").unwrap();

    let f_call = FunctionCallAction {
        method_name: "saturating_add_signed".to_string(),
        args,
        gas: 127127122121,
        deposit: 150000000000000000000000, // 0.15 NEAR,
    };

    tx.actions = vec![near_primitives::transaction::Action::FunctionCall(
        Box::new(f_call),
    )];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)?;
    Ok(())
}

'''
'''--- examples/sign_transaction/functioncall_str.rs ---
use near_ledger::NEARLedgerError;
use near_primitives::transaction::FunctionCallAction;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key.clone());

    let args = r#"{"previous_vesting_schedule_with_salt":{"vesting_schedule":{"start_timestamp":"1577919600000000000","cliff_timestamp":"1609455600000000000","end_timestamp":"1704150000000000000"},"salt":"7bc709c22801118b743fae3866edb4dea1630a97ab9cd67e993428b94a0f397a"}, "vesting_schedule_with_salt":{"vesting_schedule":{"start_timestamp":"1577919600000000000","cliff_timestamp":"1609455600000000000","end_timestamp":"1704150000000000000"},"salt":"7bc709c22801118b743fae3866edb4dea1630a97ab9cd67e993428b94a0f397a"}}"#;

    let f_call = FunctionCallAction {
        method_name: "saturating_add_signed".to_string(),
        args: args.as_bytes().to_vec(),
        gas: 127127122121,
        deposit: 150000000000000000000000, // 0.15 NEAR,
    };

    tx.actions = vec![near_primitives::transaction::Action::FunctionCall(
        Box::new(f_call),
    )];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)?;
    Ok(())
}

'''
'''--- examples/sign_transaction/functioncall_str_parse_err.rs ---
use near_ledger::NEARLedgerError;
use near_primitives::transaction::FunctionCallAction;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key.clone());

    let mut bytes = vec![];
    bytes.push(123u8);

    bytes.extend((0..255).into_iter().collect::<Vec<_>>());

    let f_call = FunctionCallAction {
        method_name: "saturating_add_signed".to_string(),
        args: bytes,
        gas: 127127122121,
        deposit: 150000000000000000000000, // 0.15 NEAR,
    };

    tx.actions = vec![near_primitives::transaction::Action::FunctionCall(
        Box::new(f_call),
    )];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)?;
    Ok(())
}

'''
'''--- examples/sign_transaction/stake.rs ---
use near_crypto::SecretKey;
use near_ledger::NEARLedgerError;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key.clone());
    let sk = SecretKey::from_seed(
        near_crypto::KeyType::SECP256K1,
        &format!("{:?}", ledger_pub_key),
    );
    let public_key = sk.public_key();
    tx.actions = vec![near_primitives::transaction::Action::Stake(Box::new(
        near_primitives::transaction::StakeAction {
            stake: 1157130000000000000000000, // 1.15713 NEAR,
            public_key,
        },
    ))];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- examples/sign_transaction/transfer.rs ---
use near_ledger::NEARLedgerError;

#[path = "../common/lib.rs"]
mod common;

fn tx(ledger_pub_key: ed25519_dalek::PublicKey) -> near_primitives::transaction::Transaction {
    let mut tx = common::tx_template(ledger_pub_key);
    tx.actions = vec![near_primitives::transaction::Action::Transfer(
        near_primitives::transaction::TransferAction {
            deposit: 150000000000000000000000, // 0.15 NEAR
        },
    )];
    tx
}

fn main() -> Result<(), NEARLedgerError> {
    common::get_key_sign_and_verify_flow(tx)
}

'''
'''--- src/lib.rs ---
//! NEAR <-> Ledger transport
//!
//! Provides a set of commands that can be executed to communicate with NEAR App installed on Ledger device:
//! - Read PublicKey from Ledger device by HD Path
//! - Sign a Transaction
use ledger_transport::APDUCommand;
use ledger_transport_hid::{
    hidapi::{HidApi, HidError},
    LedgerHIDError, TransportNativeHID,
};
use near_primitives::action::delegate::DelegateAction;
use near_primitives_core::borsh::{self, BorshSerialize};

const CLA: u8 = 0x80; // Instruction class
const INS_GET_PUBLIC_KEY: u8 = 4; // Instruction code to get public key
const INS_GET_WALLET_ID: u8 = 0x05; // Get Wallet ID
const INS_GET_VERSION: u8 = 6; // Instruction code to get app version from the Ledger
const INS_SIGN_TRANSACTION: u8 = 2; // Instruction code to sign a transaction on the Ledger
const INS_SIGN_NEP413_MESSAGE: u8 = 7; // Instruction code to sign a nep-413 message with Ledger
const INS_SIGN_NEP366_DELEGATE_ACTION: u8 = 8; // Instruction code to sign a nep-413 message with Ledger
const NETWORK_ID: u8 = 'W' as u8; // Instruction parameter 2
const RETURN_CODE_OK: u16 = 36864; // APDUAnswer.retcode which means success from Ledger
const CHUNK_SIZE: usize = 250; // Chunk size to be sent to Ledger

/// Alias of `Vec<u8>`. The goal is naming to help understand what the bytes to deal with
pub type BorshSerializedUnsignedTransaction = Vec<u8>;

const P1_GET_PUB_DISPLAY: u8 = 0;
const P1_GET_PUB_SILENT: u8 = 1;

const P1_SIGN_NORMAL: u8 = 0;
const P1_SIGN_NORMAL_LAST_CHUNK: u8 = 0x80;

/// Alias of `Vec<u8>`. The goal is naming to help understand what the bytes to deal with
pub type NEARLedgerAppVersion = Vec<u8>;
/// Alias of `Vec<u8>`. The goal is naming to help understand what the bytes to deal with
pub type SignatureBytes = Vec<u8>;

#[derive(Debug)]
pub enum NEARLedgerError {
    /// Error occuring on init of hidapid and getting current devices list
    HidApiError(HidError),
    /// Error occuring on creating a new hid transport, connecting to first ledger device found  
    LedgerHidError(LedgerHIDError),
    /// Error occurred while exchanging with Ledger device
    APDUExchangeError(String),
    /// Error with transport
    LedgerHIDError(LedgerHIDError),
}

/// Converts BIP32Path into bytes (`Vec<u8>`)
fn hd_path_to_bytes(hd_path: &slip10::BIP32Path) -> Vec<u8> {
    (0..hd_path.depth())
        .map(|index| {
            let value = *hd_path.index(index).unwrap();
            value.to_be_bytes()
        })
        .flatten()
        .collect::<Vec<u8>>()
}

#[inline(always)]
fn log_command(index: usize, is_last_chunk: bool, command: &APDUCommand<Vec<u8>>) {
    log::info!(
        "APDU  in{}: {}",
        if is_last_chunk {
            " (last)".to_string()
        } else {
            format!(" ({})", index)
        },
        hex::encode(&command.serialize())
    );
}

/// Get the version of NEAR App installed on Ledger
///
/// # Returns
///
/// * A `Result` whose `Ok` value is an `NEARLedgerAppVersion` (just a `Vec<u8>` for now, where first value is a major version, second is a minor and the last is the path)
///  and whose `Err` value is a `NEARLedgerError` containing an error which occurred.
pub fn get_version() -> Result<NEARLedgerAppVersion, NEARLedgerError> {
    //! Something
    // instantiate the connection to Ledger
    // will return an error if Ledger is not connected
    let transport = get_transport()?;
    let command = APDUCommand {
        cla: CLA,
        ins: INS_GET_VERSION,
        p1: 0, // Instruction parameter 1 (offset)
        p2: 0,
        data: vec![],
    };

    log::info!("APDU  in: {}", hex::encode(&command.serialize()));

    match transport.exchange(&command) {
        Ok(response) => {
            log::info!(
                "APDU out: {}\nAPDU ret code: {:x}",
                hex::encode(response.apdu_data()),
                response.retcode(),
            );
            // Ok means we successfully exchanged with the Ledger
            // but doesn't mean our request succeeded
            // we need to check it based on `response.retcode`
            if response.retcode() == RETURN_CODE_OK {
                return Ok(response.data().to_vec());
            } else {
                let retcode = response.retcode();

                let error_string = format!("Ledger APDU retcode: 0x{:X}", retcode);
                return Err(NEARLedgerError::APDUExchangeError(error_string));
            }
        }
        Err(err) => return Err(NEARLedgerError::LedgerHIDError(err)),
    };
}

/// Gets PublicKey from the Ledger on the given `hd_path`
///
/// # Inputs
/// * `hd_path` - seed phrase hd path `slip10::BIP32Path` for which PublicKey to look
///
/// # Returns
///
/// * A `Result` whose `Ok` value is an `ed25519_dalek::PublicKey` and whose `Err` value is a
///   `NEARLedgerError` containing an error which
///   occurred.
///
/// # Examples
///
/// ```no_run
/// use near_ledger::get_public_key;
/// use slip10::BIP32Path;
/// use std::str::FromStr;
///
/// # fn main() {
/// let hd_path = BIP32Path::from_str("44'/397'/0'/0'/1'").unwrap();
/// let public_key = get_public_key(hd_path).unwrap();
/// println!("{:#?}", public_key);
/// # }
/// ```
///
/// # Trick
///
/// To convert the answer into `near_crypto::PublicKey` do:
///
/// ```
/// # let public_key_bytes = [10u8; 32];
/// # let public_key = ed25519_dalek::PublicKey::from_bytes(&public_key_bytes).unwrap();
/// let public_key = near_crypto::PublicKey::ED25519(
///     near_crypto::ED25519PublicKey::from(
///         public_key.to_bytes(),
///     )
/// );
/// ```
pub fn get_public_key(
    hd_path: slip10::BIP32Path,
) -> Result<ed25519_dalek::PublicKey, NEARLedgerError> {
    get_public_key_with_display_flag(hd_path, true)
}

pub fn get_public_key_with_display_flag(
    hd_path: slip10::BIP32Path,
    display_and_confirm: bool,
) -> Result<ed25519_dalek::PublicKey, NEARLedgerError> {
    // instantiate the connection to Ledger
    // will return an error if Ledger is not connected
    let transport = get_transport()?;

    // hd_path must be converted into bytes to be sent as `data` to the Ledger
    let hd_path_bytes = hd_path_to_bytes(&hd_path);

    let p1 = if display_and_confirm {
        P1_GET_PUB_DISPLAY
    } else {
        P1_GET_PUB_SILENT
    };

    let command = APDUCommand {
        cla: CLA,
        ins: INS_GET_PUBLIC_KEY,
        p1, // Instruction parameter 1 (offset)
        p2: NETWORK_ID,
        data: hd_path_bytes,
    };
    log::info!("APDU  in: {}", hex::encode(&command.serialize()));

    match transport.exchange(&command) {
        Ok(response) => {
            log::info!(
                "APDU out: {}\nAPDU ret code: {:x}",
                hex::encode(response.apdu_data()),
                response.retcode(),
            );
            // Ok means we successfully exchanged with the Ledger
            // but doesn't mean our request succeeded
            // we need to check it based on `response.retcode`
            if response.retcode() == RETURN_CODE_OK {
                return Ok(ed25519_dalek::PublicKey::from_bytes(&response.data()).unwrap());
            } else {
                let retcode = response.retcode();

                let error_string = format!("Ledger APDU retcode: 0x{:X}", retcode);
                return Err(NEARLedgerError::APDUExchangeError(error_string));
            }
        }
        Err(err) => return Err(NEARLedgerError::LedgerHIDError(err)),
    };
}

pub fn get_wallet_id(
    hd_path: slip10::BIP32Path,
) -> Result<ed25519_dalek::PublicKey, NEARLedgerError> {
    // instantiate the connection to Ledger
    // will return an error if Ledger is not connected
    let transport = get_transport()?;

    // hd_path must be converted into bytes to be sent as `data` to the Ledger
    let hd_path_bytes = hd_path_to_bytes(&hd_path);

    let command = APDUCommand {
        cla: CLA,
        ins: INS_GET_WALLET_ID,
        p1: 0, // Instruction parameter 1 (offset)
        p2: NETWORK_ID,
        data: hd_path_bytes,
    };
    log::info!("APDU  in: {}", hex::encode(&command.serialize()));

    match transport.exchange(&command) {
        Ok(response) => {
            log::info!(
                "APDU out: {}\nAPDU ret code: {:x}",
                hex::encode(response.apdu_data()),
                response.retcode(),
            );
            // Ok means we successfully exchanged with the Ledger
            // but doesn't mean our request succeeded
            // we need to check it based on `response.retcode`
            if response.retcode() == RETURN_CODE_OK {
                return Ok(ed25519_dalek::PublicKey::from_bytes(&response.data()).unwrap());
            } else {
                let retcode = response.retcode();

                let error_string = format!("Ledger APDU retcode: 0x{:X}", retcode);
                return Err(NEARLedgerError::APDUExchangeError(error_string));
            }
        }
        Err(err) => return Err(NEARLedgerError::LedgerHIDError(err)),
    };
}

fn get_transport() -> Result<TransportNativeHID, NEARLedgerError> {
    // instantiate the connection to Ledger
    // will return an error if Ledger is not connected
    let hidapi = HidApi::new().map_err(NEARLedgerError::HidApiError)?;
    TransportNativeHID::new(&hidapi).map_err(NEARLedgerError::LedgerHidError)
}

/// Sign the transaction. Transaction should be [borsh serialized](https://github.com/near/borsh-rs) `Vec<u8>`
///
/// # Inputs
/// * `unsigned_transaction_borsh_serializer` - unsigned transaction `near_primitives::transaction::Transaction`
/// which is serialized with `BorshSerializer` and basically is just `Vec<u8>`
/// * `seed_phrase_hd_path` - seed phrase hd path `slip10::BIP32Path` with which to sign
///
/// # Returns
///
/// * A `Result` whose `Ok` value is an `Signature` (bytes) and whose `Err` value is a
/// `NEARLedgerError` containing an error which occurred.
///
/// # Examples
///
/// ```no_run
/// use near_ledger::sign_transaction;
/// use near_primitives::{borsh, borsh::BorshSerialize};
/// use slip10::BIP32Path;
/// use std::str::FromStr;
///
/// # fn main() {
/// # let near_unsigned_transaction = [10; 250];
/// let hd_path = BIP32Path::from_str("44'/397'/0'/0'/1'").unwrap();
/// let borsh_transaction = borsh::to_vec(&near_unsigned_transaction).unwrap();
/// let signature = sign_transaction(borsh_transaction, hd_path).unwrap();
/// println!("{:#?}", signature);
/// # }
/// ```
///
/// # Trick
///
/// To convert the answer into `near_crypto::Signature` do:
///
/// ```
/// # let signature = [10; 64].to_vec();
/// let signature = near_crypto::Signature::from_parts(near_crypto::KeyType::ED25519, &signature)
///     .expect("Signature is not expected to fail on deserialization");
/// ```
pub fn sign_transaction(
    unsigned_tx: BorshSerializedUnsignedTransaction,
    seed_phrase_hd_path: slip10::BIP32Path,
) -> Result<SignatureBytes, NEARLedgerError> {
    let transport = get_transport()?;
    // seed_phrase_hd_path must be converted into bytes to be sent as `data` to the Ledger
    let hd_path_bytes = hd_path_to_bytes(&seed_phrase_hd_path);

    let mut data: Vec<u8> = vec![];
    data.extend(hd_path_bytes);
    data.extend(&unsigned_tx);

    let chunks = data.chunks(CHUNK_SIZE);
    let chunks_count = chunks.len();

    for (i, chunk) in chunks.enumerate() {
        let is_last_chunk = chunks_count == i + 1;
        let command = APDUCommand {
            cla: CLA,
            ins: INS_SIGN_TRANSACTION,
            p1: if is_last_chunk {
                P1_SIGN_NORMAL_LAST_CHUNK
            } else {
                P1_SIGN_NORMAL
            }, // Instruction parameter 1 (offset)
            p2: NETWORK_ID,
            data: chunk.to_vec(),
        };
        log_command(i, is_last_chunk, &command);
        match transport.exchange(&command) {
            Ok(response) => {
                log::info!(
                    "APDU out: {}\nAPDU ret code: {:x}",
                    hex::encode(response.apdu_data()),
                    response.retcode(),
                );
                // Ok means we successfully exchanged with the Ledger
                // but doesn't mean our request succeeded
                // we need to check it based on `response.retcode`
                if response.retcode() == RETURN_CODE_OK {
                    if is_last_chunk {
                        return Ok(response.data().to_vec());
                    }
                } else {
                    let retcode = response.retcode();

                    let error_string = format!("Ledger APDU retcode: 0x{:X}", retcode);
                    return Err(NEARLedgerError::APDUExchangeError(error_string));
                }
            }
            Err(err) => return Err(NEARLedgerError::LedgerHIDError(err)),
        };
    }
    Err(NEARLedgerError::APDUExchangeError(
        "Unable to process request".to_owned(),
    ))
}

#[derive(Debug, BorshSerialize)]
#[borsh(crate = "near_primitives_core::borsh")]
pub struct NEP413Payload {
    pub messsage: String,
    pub nonce: [u8; 32],
    pub recipient: String,
    pub callback_url: Option<String>,
}

pub fn sign_message_nep413(
    payload: &NEP413Payload,
    seed_phrase_hd_path: slip10::BIP32Path,
) -> Result<SignatureBytes, NEARLedgerError> {
    let transport = get_transport()?;
    // seed_phrase_hd_path must be converted into bytes to be sent as `data` to the Ledger
    let hd_path_bytes = hd_path_to_bytes(&seed_phrase_hd_path);

    let mut data: Vec<u8> = vec![];
    data.extend(hd_path_bytes);
    data.extend_from_slice(&borsh::to_vec(payload).unwrap());

    let chunks = data.chunks(CHUNK_SIZE);
    let chunks_count = chunks.len();

    for (i, chunk) in chunks.enumerate() {
        let is_last_chunk = chunks_count == i + 1;
        let command = APDUCommand {
            cla: CLA,
            ins: INS_SIGN_NEP413_MESSAGE,
            p1: if is_last_chunk {
                P1_SIGN_NORMAL_LAST_CHUNK
            } else {
                P1_SIGN_NORMAL
            }, // Instruction parameter 1 (offset)
            p2: NETWORK_ID,
            data: chunk.to_vec(),
        };
        log_command(i, is_last_chunk, &command);
        match transport.exchange(&command) {
            Ok(response) => {
                log::info!(
                    "APDU out: {}\nAPDU ret code: {:x}",
                    hex::encode(response.apdu_data()),
                    response.retcode(),
                );
                // Ok means we successfully exchanged with the Ledger
                // but doesn't mean our request succeeded
                // we need to check it based on `response.retcode`
                if response.retcode() == RETURN_CODE_OK {
                    if is_last_chunk {
                        return Ok(response.data().to_vec());
                    }
                } else {
                    let retcode = response.retcode();

                    let error_string = format!("Ledger APDU retcode: 0x{:X}", retcode);
                    return Err(NEARLedgerError::APDUExchangeError(error_string));
                }
            }
            Err(err) => return Err(NEARLedgerError::LedgerHIDError(err)),
        };
    }
    Err(NEARLedgerError::APDUExchangeError(
        "Unable to process request".to_owned(),
    ))
}

pub fn sign_message_nep366_delegate_action(
    payload: &DelegateAction,
    seed_phrase_hd_path: slip10::BIP32Path,
) -> Result<SignatureBytes, NEARLedgerError> {
    let transport = get_transport()?;
    // seed_phrase_hd_path must be converted into bytes to be sent as `data` to the Ledger
    let hd_path_bytes = hd_path_to_bytes(&seed_phrase_hd_path);

    let mut data: Vec<u8> = vec![];
    data.extend(hd_path_bytes);
    data.extend_from_slice(&borsh::to_vec(payload).unwrap());

    let chunks = data.chunks(CHUNK_SIZE);
    let chunks_count = chunks.len();

    for (i, chunk) in chunks.enumerate() {
        let is_last_chunk = chunks_count == i + 1;
        let command = APDUCommand {
            cla: CLA,
            ins: INS_SIGN_NEP366_DELEGATE_ACTION,
            p1: if is_last_chunk {
                P1_SIGN_NORMAL_LAST_CHUNK
            } else {
                P1_SIGN_NORMAL
            }, // Instruction parameter 1 (offset)
            p2: NETWORK_ID,
            data: chunk.to_vec(),
        };
        log_command(i, is_last_chunk, &command);
        match transport.exchange(&command) {
            Ok(response) => {
                log::info!(
                    "APDU out: {}\nAPDU ret code: {:x}",
                    hex::encode(response.apdu_data()),
                    response.retcode(),
                );
                // Ok means we successfully exchanged with the Ledger
                // but doesn't mean our request succeeded
                // we need to check it based on `response.retcode`
                if response.retcode() == RETURN_CODE_OK {
                    if is_last_chunk {
                        return Ok(response.data().to_vec());
                    }
                } else {
                    let retcode = response.retcode();

                    let error_string = format!("Ledger APDU retcode: 0x{:X}", retcode);
                    return Err(NEARLedgerError::APDUExchangeError(error_string));
                }
            }
            Err(err) => return Err(NEARLedgerError::LedgerHIDError(err)),
        };
    }
    Err(NEARLedgerError::APDUExchangeError(
        "Unable to process request".to_owned(),
    ))
}

'''