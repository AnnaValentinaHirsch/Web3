*GitHub Repository "oysterpack/oysterpack-smart-near"*

'''--- .idea/misc.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectPlainTextFileTypeManager">
    <file url="file://$PROJECT_DIR$/near/oysterpack-smart-stake/neardev/dev-account" />
  </component>
</project>
'''
'''--- .idea/modules.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="ProjectModuleManager">
    <modules>
      <module fileurl="file://$PROJECT_DIR$/.idea/oysterpack-smart.iml" filepath="$PROJECT_DIR$/.idea/oysterpack-smart.iml" />
    </modules>
  </component>
</project>
'''
'''--- .idea/runConfigurations/Test_FT.xml ---
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Test FT" type="CargoCommandRunConfiguration" factoryName="Cargo Command">
    <option name="command" value="test  --lib &quot;&quot;" />
    <option name="workingDirectory" value="file://$PROJECT_DIR$/near/oysterpack-smart-fungible-token" />
    <option name="channel" value="DEFAULT" />
    <option name="requiredFeatures" value="true" />
    <option name="allFeatures" value="false" />
    <option name="emulateTerminal" value="false" />
    <option name="backtrace" value="SHORT" />
    <envs />
    <option name="isRedirectInput" value="false" />
    <option name="redirectInputPath" value="" />
    <method v="2">
      <option name="CARGO.BUILD_TASK_PROVIDER" enabled="true" />
    </method>
  </configuration>
</component>
'''
'''--- .idea/runConfigurations/Test_Stake_Contract.xml ---
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Test Stake Contract" type="CargoCommandRunConfiguration" factoryName="Cargo Command">
    <option name="command" value="test  --lib &quot;&quot;" />
    <option name="workingDirectory" value="file://$PROJECT_DIR$/near/oysterpack-smart-stake" />
    <option name="channel" value="STABLE" />
    <option name="requiredFeatures" value="true" />
    <option name="allFeatures" value="false" />
    <option name="emulateTerminal" value="false" />
    <option name="backtrace" value="SHORT" />
    <envs />
    <option name="isRedirectInput" value="false" />
    <option name="redirectInputPath" value="" />
    <method v="2">
      <option name="CARGO.BUILD_TASK_PROVIDER" enabled="true" />
    </method>
  </configuration>
</component>
'''
'''--- .idea/runConfigurations/Test_Staking_Pool.xml ---
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Test Staking Pool" type="CargoCommandRunConfiguration" factoryName="Cargo Command">
    <option name="command" value="test  --lib &quot;&quot;" />
    <option name="workingDirectory" value="file://$PROJECT_DIR$/near/oysterpack-smart-staking-pool" />
    <option name="channel" value="STABLE" />
    <option name="requiredFeatures" value="true" />
    <option name="allFeatures" value="false" />
    <option name="emulateTerminal" value="false" />
    <option name="backtrace" value="SHORT" />
    <envs />
    <option name="isRedirectInput" value="false" />
    <option name="redirectInputPath" value="" />
    <method v="2">
      <option name="CARGO.BUILD_TASK_PROVIDER" enabled="true" />
    </method>
  </configuration>
</component>
'''
'''--- .idea/runConfigurations/Test_account_management.xml ---
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Test account-management" type="CargoCommandRunConfiguration" factoryName="Cargo Command">
    <option name="command" value="test --jobs 1  --package oysterpack-smart-account-management --lib &quot;&quot;" />
    <option name="workingDirectory" value="file://$PROJECT_DIR$/near/oysterpack-smart-account-management" />
    <option name="channel" value="DEFAULT" />
    <option name="requiredFeatures" value="true" />
    <option name="allFeatures" value="false" />
    <option name="emulateTerminal" value="false" />
    <option name="backtrace" value="SHORT" />
    <envs />
    <option name="isRedirectInput" value="false" />
    <option name="redirectInputPath" value="" />
    <method v="2">
      <option name="CARGO.BUILD_TASK_PROVIDER" enabled="true" />
    </method>
  </configuration>
</component>
'''
'''--- .idea/runConfigurations/Test_contract.xml ---
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Test contract" type="CargoCommandRunConfiguration" factoryName="Cargo Command">
    <option name="command" value="test --package oysterpack-smart-contract --lib &quot;&quot; " />
    <option name="workingDirectory" value="file://$PROJECT_DIR$/near/oysterpack-smart-account-management" />
    <option name="channel" value="DEFAULT" />
    <option name="requiredFeatures" value="true" />
    <option name="allFeatures" value="false" />
    <option name="emulateTerminal" value="false" />
    <option name="backtrace" value="SHORT" />
    <envs />
    <option name="isRedirectInput" value="false" />
    <option name="redirectInputPath" value="" />
    <method v="2">
      <option name="CARGO.BUILD_TASK_PROVIDER" enabled="true" />
    </method>
  </configuration>
</component>
'''
'''--- .idea/runConfigurations/Test_near.xml ---
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Test near" type="CargoCommandRunConfiguration" factoryName="Cargo Command">
    <option name="command" value="test --package oysterpack-smart-near --lib &quot;&quot;" />
    <option name="workingDirectory" value="file://$PROJECT_DIR$/near/oysterpack-smart-near" />
    <option name="channel" value="DEFAULT" />
    <option name="requiredFeatures" value="true" />
    <option name="allFeatures" value="false" />
    <option name="emulateTerminal" value="false" />
    <option name="backtrace" value="SHORT" />
    <envs />
    <option name="isRedirectInput" value="false" />
    <option name="redirectInputPath" value="" />
    <method v="2">
      <option name="CARGO.BUILD_TASK_PROVIDER" enabled="true" />
    </method>
  </configuration>
</component>
'''
'''--- .idea/runConfigurations/Test_workspace_with_coverage.xml ---
<component name="ProjectRunConfigurationManager">
  <configuration default="false" name="Test workspace with coverage" type="CargoCommandRunConfiguration" factoryName="Cargo Command">
    <option name="command" value="test --workspace" />
    <option name="workingDirectory" value="file://$PROJECT_DIR$/near" />
    <option name="channel" value="NIGHTLY" />
    <option name="requiredFeatures" value="true" />
    <option name="allFeatures" value="false" />
    <option name="emulateTerminal" value="false" />
    <option name="backtrace" value="SHORT" />
    <envs />
    <option name="isRedirectInput" value="false" />
    <option name="redirectInputPath" value="" />
    <method v="2">
      <option name="CARGO.BUILD_TASK_PROVIDER" enabled="true" />
    </method>
  </configuration>
</component>
'''
'''--- .idea/vcs.xml ---
<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="VcsDirectoryMappings">
    <mapping directory="$PROJECT_DIR$" vcs="Git" />
  </component>
</project>
'''
'''--- README.md ---
# OysterPack SMART - It's Time to Put a STAKE in the Ground!
The **vision** is to build a suite of financial services for the everyday person on the NEAR blockchain anchored on staking 
and contract transaction fees.

The **mission** is to build the best staking solutions, products, and services on the NEAR blockchain. 

# OysterPack SMART NEAR Components
Build ***SMARTER***, ***FASTER***, and ***BETTER*** on the [NEAR][1] platform using ***OysterPack SMART*** NEAR components.
 
### NEAR Core Contract Components
- Contract Ownership
- Contract Metrics
- Contract Operator
- Contract Sale

### NEAR Standard Components
- Account Management
- Fungible Token
    
### NEAR Staking Components
- Staking Pool

# OysterPack SMART NEAR Contracts
- STAKE Pool
- STAKE Pool Factory

## How to support the project
You can help support the project by contributing **NEAR** to [***oysterpack.near***][2]

[1]: https://near.org/
[2]: https://wallet.near.org/send-money
'''
'''--- docs/DEV.md ---
## Workspace setup
```shell
# used for project build
cargo install --force cargo-make

# required to get test code coverage working in CLion
cargo install --force grcov
```

## How To Build Project 
- [cargo-make][1] is used to manage the project builds

## NEAR References
- [staking-pool][4]

## References
- [toml][2]
- [cargo-make docs][3]

## Articles
- [composition over inheritance][5]

## Tools
- https://regexr.com/

[1]: https://crates.io/crates/cargo-make
[2]: https://toml.io/en/v1.0.0
[3]: https://sagiegurari.github.io/cargo-make
[4]: https://github.com/near/core-contracts/tree/master/staking-pool#staking-pool-contract-guarantees-and-invariants
[5]: https://www.reddit.com/r/rust/comments/372mqw/how_do_i_composition_over_inheritance/
'''
'''--- docs/guildnet.md ---
- https://wallet.openshards.io/
- https://explorer.guildnet.near.org/nodes/online-nodes
- https://near-guildnet.github.io/open-shards-faucet/

## How to configure NEAR CLI to point to GuildNet
```shell
near --nodeUrl https://rpc.openshards.io/ --walletUrl https://wallet.openshards.io/ --networkId guildnet

alias near-guildnet='near --nodeUrl https://rpc.openshards.io/ --walletUrl https://wallet.openshards.io/ --networkId guildnet'
```

## OysterPack STAKE Pool - Basic APIs to Get Started
```shell
# register account
CONTRACT=pearl.stake-v1.oysterpack.guildnet
ACCOUNT=oysterpack.guildnet

# Storage Management APIs - used to register the account with the STAKE pool contract
# - see https://nomicon.io/Standards/StorageManagement.html for more info

# NOTE: all amounts specified in --args are specified in yocto units:
# 1 NEAR = 1000000000000000000000000 yoctoNEAR

# registers the account - actual cost is 0.00393 NEAR and rest will be refunded 
near-guildnet call $CONTRACT storage_deposit --accountId $ACCOUNT --args '{"registration_only":true}' --amount 1

# stakes the attached deposit + any account storage available balance
near-guildnet call $CONTRACT ops_stake --accountId $ACCOUNT --amount 1

# unstakes specified amount
near-guildnet call $CONTRACT ops_unstake --accountId $ACCOUNT --args '{"amount":"1000000000000000000000000"}'
# unstakes all
near-guildnet call $CONTRACT ops_unstake --accountId $ACCOUNT

# withdraws specified amount from unstaked available balance
near-guildnet call $CONTRACT ops_stake_withdraw --accountId $ACCOUNT --args '{"amount":"1000000000000000000000000"}'
# withdraws all unstaked available balance
near-guildnet call $CONTRACT ops_stake_withdraw --accountId $ACCOUNT

# used to check the pool status: Online/Offline
near-guildnet view $CONTRACT ops_stake_status
# returns balances that the pool manages
near-guildnet view $CONTRACT ops_stake_pool_balances
near-guildnet view $CONTRACT ops_stake_fees
near-guildnet view $CONTRACT ops_stake_public_key
# returns the current NEAR value for 1 STAKE
near-guildnet view $CONTRACT ops_stake_token_value 
# returns the current NEAR value for the specified amount of STAKE
near-guildnet view $CONTRACT ops_stake_token_value --args '{"amount":"5000000000000000000000000"}'
```
'''
'''--- docs/stake-near-cli-guildnet.md ---
```shell
CONTRACT_NAME=pearl.stake-v1.oysterpack.guildnet
echo $CONTRACT_NAME

ACCOUNT=oysterpack.guildnet

# DELETE contract and reclaim funds
# near-guildnet delete $CONTRACT_NAME oysterpack.guildnet
```

## Account Storage Usage
```shell
near-guildnet view $CONTRACT_NAME ops_storage_usage_bounds
near-guildnet view $CONTRACT_NAME ops_storage_usage --args '{"account_id":"oysterpack.guildnet"}'
```

## Storage Management
```shell
near-guildnet view $CONTRACT_NAME storage_balance_bounds
near-guildnet view $CONTRACT_NAME storage_balance_of --args '{"account_id":"oysterpack.guildnet"}'

near-guildnet call $CONTRACT_NAME storage_deposit --accountId alfio-zappala-oysterpack.guildnet --amount 0.00393
near-guildnet call $CONTRACT_NAME storage_deposit --args '{"account_id":"oysterpack-2.testnet", "registration_only":true}' --accountId oysterpack.guildnet --amount 1
near-guildnet call $CONTRACT_NAME storage_deposit --args '{"registration_only":true}' --accountId oysterpack-2.testnet --amount 1

near-guildnet call $CONTRACT_NAME storage_withdraw --accountId oysterpack-2.testnet --amount 0.000000000000000000000001
near-guildnet call $CONTRACT_NAME storage_withdraw --accountId oysterpack-2.testnet --args '{"amount":"1000"}' --amount 0.000000000000000000000001

near-guildnet call $CONTRACT_NAME storage_unregister --accountId oysterpack-2.testnet --amount 0.000000000000000000000001
near-guildnet call $CONTRACT_NAME storage_unregister --args '{"force":true}' --accountId oysterpack-2.testnet --amount 0.000000000000000000000001
```

## Permissions Management
```shell
near-guildnet view $CONTRACT_NAME ops_permissions_is_admin --args '{"account_id":"oysterpack.guildnet"}'
near-guildnet view $CONTRACT_NAME ops_permissions_is_operator --args '{"account_id":"oysterpack.guildnet"}'
near-guildnet view $CONTRACT_NAME ops_permissions --args '{"account_id":"oysterpack.guildnet"}'
near-guildnet view $CONTRACT_NAME ops_permissions_granted --args '{"account_id":"oysterpack.guildnet"}'

near-guildnet call $CONTRACT_NAME ops_permissions_grant_admin --args '{"account_id":"oysterpack-2.testnet"}' --accountId oysterpack.guildnet
near-guildnet call $CONTRACT_NAME ops_permissions_grant_operator --args '{"account_id":"oysterpack-2.testnet"}' --accountId oysterpack.guildnet
near-guildnet call $CONTRACT_NAME ops_permissions_grant_permissions --args '{"account_id":"oysterpack-2.testnet", "permissions": [0]}' --accountId oysterpack.guildnet

near-guildnet call $CONTRACT_NAME ops_permissions_revoke_admin --args '{"account_id":"oysterpack-2.testnet"}' --accountId oysterpack.guildnet
near-guildnet call $CONTRACT_NAME ops_permissions_revoke_operator --args '{"account_id":"oysterpack-2.testnet"}' --accountId oysterpack.guildnet
near-guildnet call $CONTRACT_NAME ops_permissions_revoke_all --args '{"account_id":"oysterpack-2.testnet"}' --accountId oysterpack.guildnet
near-guildnet call $CONTRACT_NAME ops_permissions_revoke_permissions --args '{"account_id":"oysterpack-2.testnet", "permissions": [0]}' --accountId oysterpack.guildnet

near-guildnet view $CONTRACT_NAME ops_permissions_contract_permissions
```

## Contract Metrics
```shell
near-guildnet view $CONTRACT_NAME ops_metrics
near-guildnet view $CONTRACT_NAME ops_metrics_near_balances
near-guildnet view $CONTRACT_NAME ops_metrics_accounts
near-guildnet view $CONTRACT_NAME ops_metrics_total_registered_accounts
near-guildnet view $CONTRACT_NAME ops_metrics_contract_storage_usage
near-guildnet view $CONTRACT_NAME ops_metrics_storage_usage_costs
```

## Fungible Token
```shell
near-guildnet view $CONTRACT_NAME ft_total_supply

near-guildnet view $CONTRACT_NAME ft_balance_of --args '{"account_id":"oysterpack.guildnet"}'
near-guildnet view $CONTRACT_NAME ft_balance_of --args '{"account_id":"oysterpack-2.testnet"}'

near-guildnet call $CONTRACT_NAME ft_transfer --args '{"receiver_id":"dev-1618770943926-8326158","amount":"1000000000000000000000000000"}' --accountId oysterpack.guildnet --amount 0.000000000000000000000001

near-guildnet call $CONTRACT_NAME ft_transfer_call --args '{"receiver_id":"dev-1618770943926-8326158","amount":"1000000000000000000000000000","msg":""}' --accountId oysterpack.guildnet --amount 0.000000000000000000000001
```

## Fungible Token Operator
```shell
near-guildnet view $CONTRACT_NAME ft_operator_transfer_callback_gas

near-guildnet call $CONTRACT_NAME ft_operator_command --accountId oysterpack.guildnet --args '{"command":OperatorCommand}'
pub enum OperatorCommand {
    SetIcon(Icon),
    ClearIcon,
    SetReference(Reference, Hash),
    ClearReference,
    SetTransferCallbackGas(TGas),
}
```

### Fungible Token Metadata
```shell
near-guildnet view $CONTRACT_NAME ft_metadata
```

## Staking Pool
```shell
near-guildnet view $CONTRACT_NAME ops_stake_status
near-guildnet view $CONTRACT_NAME ops_stake_pool_balances
near-guildnet view $CONTRACT_NAME ops_stake_fees
near-guildnet view $CONTRACT_NAME ops_stake_public_key
near-guildnet view $CONTRACT_NAME ops_stake_token_value
near-guildnet view $CONTRACT_NAME ops_stake_token_value --args '{"amount":"5000000000000000000000000"}'
near-guildnet call $CONTRACT_NAME ops_stake_token_value_with_earnings --account_id oysterpack.guildnet

near-guildnet view $CONTRACT_NAME ops_stake_balance --args '{"account_id":"alfio-zappala-oysterpack.guildnet"}'

near-guildnet call $CONTRACT_NAME ops_stake --accountId oysterpack.guildnet
near-guildnet call $CONTRACT_NAME ops_stake --accountId alfio-zappala-oysterpack.guildnet --amount 0.1
near-guildnet call $CONTRACT_NAME ops_stake --accountId oysterpack.guildnet --amount 75000

near-guildnet call $CONTRACT_NAME ops_unstake --accountId alfio-zappala-oysterpack.guildnet --args '{"amount":"1000000000000000000000000"}'

near-guildnet call $CONTRACT_NAME ops_restake --accountId alfio-zappala-oysterpack.guildnet
near-guildnet call $CONTRACT_NAME ops_restake --accountId alfio-zappala-oysterpack.guildnet -args '{"amount":"100000000000000000000000"}'

near-guildnet call $CONTRACT_NAME ops_stake_withdraw --accountId alfio-zappala-oysterpack.guildnet 
near-guildnet call $CONTRACT_NAME ops_stake_withdraw --accountId alfio-zappala-oysterpack.guildnet -args '{"amount":"100000000000000000000000"}'

near-guildnet call $CONTRACT_NAME ops_stake_transfer --accountId oysterpack.guildnet --args '{"receiver_id":"alfio-zappala-oysterpack.guildnet","amount":"1000000000000000000000000"}' --amount 0.000000000000000000000001
```

### Staking Pool Operator
```shell
near-guildnet call $CONTRACT_NAME ops_stake_operator_command --args '{"command":"StartStaking"}' --accountId oysterpack.guildnet

near-guildnet call $CONTRACT_NAME ops_stake_operator_command --args '{"command":"StopStaking"}' --accountId oysterpack.guildnet

near-guildnet call $CONTRACT_NAME ops_stake_operator_command --args '{"command":{"UpdateFees":{"staking_fee":1,"earnings_fee":50}}}' --accountId $oysterpack.guildnet
```

## Staking Pool Treasury
```shell
near-guildnet call $CONTRACT_NAME ops_stake_treasury_deposit --accountId oysterpack.guildnet --amount 10

near-guildnet call $CONTRACT_NAME ops_stake_treasury_distribution --accountId oysterpack.guildnet --amount 10

near-guildnet call $CONTRACT_NAME ops_stake_treasury_transfer_to_owner --accountId oysterpack.guildnet --args '{"amount":"1000000000000000000000000"}'
```

### STAKE Pool Factory
```shell
near-guildnet call $CONTRACT_NAME deploy --accountId oysterpack.guildnet --amount 6 --gas 300000000000000 --args \
'{"stake_symbol":"PEARL","stake_public_key":"ed25519:GTi3gtSio5ZYYKTT8WVovqJEob6KqdmkTi8KqGSfwqdm","earnings_fee":50,"staking_fee":1}'

# guildnet
near-guildnet call stake-v1.oysterpack.guildnet deploy --accountId oysterpack.guildnet --amount 6 --gas 300000000000000 --args \
'{"stake_symbol":"PEARL","stake_public_key":"ed25519:67qRSN1Cnkx6y7e21bJq3f7vEg89PSjxRBN57mY2dReg","earnings_fee":50,"staking_fee":1}'
```

#   1000000000000000000000000     - 1 NEAR
# 0.0003930000000000000000000

# 1000000000000                   - 1 TGas
# 

Apr 29 19:13:18 validator neard[1122]: Apr 29 19:13:18.487  INFO stats: #18216849 Downloading headers 29.98% (6160534)  18/18/40 peers ⬇ 385.8kiB/s ⬆ 0.4kiB/s 0.00 bps 0 gas/s CPU: 41%, Mem: 545.1 MiB
Apr 29 19:13:28 validator neard[1122]: Apr 29 19:13:28.491  INFO stats: #18216849 Downloading headers 30.00% (6159016)  18/18/40 peers ⬇ 364.8kiB/s ⬆ 0.4kiB/s 0.00 bps 0 gas/s CPU: 22%, Mem: 545.1 MiB
Apr 29 19:13:38 validator neard[1122]: Apr 29 19:13:38.495  INFO stats: #18216849 Downloading headers 30.02% (6156982)  18/18/40 peers ⬇ 366.3kiB/s ⬆ 0.4kiB/s 0.00 bps 0 gas/s CPU: 42%, Mem: 545.1 MiB

'''
'''--- docs/stake-near-cli.md ---
```shell
cd near/oysterpack-smart-stake
# set `CONTRACT_NAME` env var
. ./neardev/dev-account.env
echo $CONTRACT_NAME

ACCOUNT=oysterpack.testnet

# DELETE contract and reclaim funds
# near delete $CONTRACT_NAME oysterpack.testnet
```

## Account Storage Usage
```shell
near view $CONTRACT_NAME ops_storage_usage_bounds
near view $CONTRACT_NAME ops_storage_usage --args '{"account_id":"oysterpack.testnet"}'
```

## Storage Management
```shell
near view $CONTRACT_NAME storage_balance_bounds
near view $CONTRACT_NAME storage_balance_of --args '{"account_id":"oysterpack.testnet"}'

near call $CONTRACT_NAME storage_deposit --accountId alfio-zappala-oysterpack.testnet --amount 0.00393
near call $CONTRACT_NAME storage_deposit --args '{"account_id":"oysterpack-2.testnet", "registration_only":true}' --accountId oysterpack.testnet --amount 1
near call $CONTRACT_NAME storage_deposit --args '{"registration_only":true}' --accountId oysterpack-2.testnet --amount 1

near call $CONTRACT_NAME storage_withdraw --accountId oysterpack-2.testnet --amount 0.000000000000000000000001
near call $CONTRACT_NAME storage_withdraw --accountId oysterpack-2.testnet --args '{"amount":"1000"}' --amount 0.000000000000000000000001

near call $CONTRACT_NAME storage_unregister --accountId oysterpack-2.testnet --amount 0.000000000000000000000001
near call $CONTRACT_NAME storage_unregister --args '{"force":true}' --accountId oysterpack-2.testnet --amount 0.000000000000000000000001
```

## Permissions Management
```shell
near view $CONTRACT_NAME ops_permissions_is_admin --args '{"account_id":"oysterpack.testnet"}'
near view $CONTRACT_NAME ops_permissions_is_operator --args '{"account_id":"oysterpack.testnet"}'
near view $CONTRACT_NAME ops_permissions --args '{"account_id":"oysterpack.testnet"}'
near view $CONTRACT_NAME ops_permissions_granted --args '{"account_id":"oysterpack.testnet"}'

near call $CONTRACT_NAME ops_permissions_grant_admin --args '{"account_id":"oysterpack-2.testnet"}' --accountId oysterpack.testnet
near call $CONTRACT_NAME ops_permissions_grant_operator --args '{"account_id":"oysterpack-2.testnet"}' --accountId oysterpack.testnet
near call $CONTRACT_NAME ops_permissions_grant_permissions --args '{"account_id":"oysterpack-2.testnet", "permissions": [0]}' --accountId oysterpack.testnet

near call $CONTRACT_NAME ops_permissions_revoke_admin --args '{"account_id":"oysterpack-2.testnet"}' --accountId oysterpack.testnet
near call $CONTRACT_NAME ops_permissions_revoke_operator --args '{"account_id":"oysterpack-2.testnet"}' --accountId oysterpack.testnet
near call $CONTRACT_NAME ops_permissions_revoke_all --args '{"account_id":"oysterpack-2.testnet"}' --accountId oysterpack.testnet
near call $CONTRACT_NAME ops_permissions_revoke_permissions --args '{"account_id":"oysterpack-2.testnet", "permissions": [0]}' --accountId oysterpack.testnet

near view $CONTRACT_NAME ops_permissions_contract_permissions
```

## Contract Ownership
```shell
near view $CONTRACT_NAME ops_owner
near view $CONTRACT_NAME ops_owner_balance

# Returns the prospective owner that the transfer is waiting on for finalization.
near view $CONTRACT_NAME ops_owner_prospective

near call $CONTRACT_NAME ops_owner_transfer --args '{"new_owner":"oysterpack-2.testnet"}' --accountId oysterpack.testnet  --amount 0.000000000000000000000001
near call $CONTRACT_NAME ops_owner_cancel_transfer --accountId oysterpack.testnet  --amount 0.000000000000000000000001
near call $CONTRACT_NAME ops_owner_finalize_transfer --accountId oysterpack.testnet  --amount 0.000000000000000000000001

near call $CONTRACT_NAME
```

## Contract Metrics
```shell
near view $CONTRACT_NAME ops_metrics
near view $CONTRACT_NAME ops_metrics_near_balances
near view $CONTRACT_NAME ops_metrics_accounts
near view $CONTRACT_NAME ops_metrics_total_registered_accounts
near view $CONTRACT_NAME ops_metrics_contract_storage_usage
near view $CONTRACT_NAME ops_metrics_storage_usage_costs
```

## Fungible Token
```shell
near view $CONTRACT_NAME ft_total_supply

near view $CONTRACT_NAME ft_balance_of --args '{"account_id":"oysterpack.testnet"}'
near view $CONTRACT_NAME ft_balance_of --args '{"account_id":"oysterpack-2.testnet"}'

near call $CONTRACT_NAME ft_transfer --args '{"receiver_id":"dev-1618770943926-8326158","amount":"1000000000000000000000000000"}' --accountId oysterpack.testnet --amount 0.000000000000000000000001

near call $CONTRACT_NAME ft_transfer_call --args '{"receiver_id":"dev-1618770943926-8326158","amount":"1000000000000000000000000000","msg":""}' --accountId oysterpack.testnet --amount 0.000000000000000000000001
```

## Fungible Token Operator
```shell
near view $CONTRACT_NAME ft_operator_transfer_callback_gas

near call $CONTRACT_NAME ft_operator_command --accountId oysterpack.testnet --args '{"command":OperatorCommand}'
pub enum OperatorCommand {
    SetIcon(Icon),
    ClearIcon,
    SetReference(Reference, Hash),
    ClearReference,
    SetTransferCallbackGas(TGas),
}
```

### Fungible Token Metadata
```shell
near view $CONTRACT_NAME ft_metadata
```

## Staking Pool
```shell
near view $CONTRACT_NAME ops_stake_status
near view $CONTRACT_NAME ops_stake_pool_balances
near view $CONTRACT_NAME ops_stake_fees
near view $CONTRACT_NAME ops_stake_public_key
near view $CONTRACT_NAME ops_stake_token_value
near view $CONTRACT_NAME ops_stake_token_value --args '{"amount":"5000000000000000000000000"}'
near call $CONTRACT_NAME ops_stake_token_value_with_earnings --account_id oysterpack.testnet

near view $CONTRACT_NAME ops_stake_balance --args '{"account_id":"alfio-zappala-oysterpack.testnet"}'

near call $CONTRACT_NAME ops_stake --accountId oysterpack.testnet
near call $CONTRACT_NAME ops_stake --accountId alfio-zappala-oysterpack.testnet --amount 0.1
near call $CONTRACT_NAME ops_stake --accountId oysterpack.testnet --amount 1

near call $CONTRACT_NAME ops_unstake --accountId alfio-zappala-oysterpack.testnet --args '{"amount":"1000000000000000000000000"}'

near call $CONTRACT_NAME ops_restake --accountId alfio-zappala-oysterpack.testnet
near call $CONTRACT_NAME ops_restake --accountId alfio-zappala-oysterpack.testnet -args '{"amount":"100000000000000000000000"}'

near call $CONTRACT_NAME ops_stake_withdraw --accountId alfio-zappala-oysterpack.testnet 
near call $CONTRACT_NAME ops_stake_withdraw --accountId alfio-zappala-oysterpack.testnet -args '{"amount":"100000000000000000000000"}'

near call $CONTRACT_NAME ops_stake_transfer --accountId oysterpack.testnet --args '{"receiver_id":"alfio-zappala-oysterpack.testnet","amount":"1000000000000000000000000"}' --amount 0.000000000000000000000001
```

### Staking Pool Operator
```shell
near call $CONTRACT_NAME ops_stake_operator_command --args '{"command":"StartStaking"}' --accountId oysterpack.testnet

near call $CONTRACT_NAME ops_stake_operator_command --args '{"command":"StopStaking"}' --accountId oysterpack.testnet

near call $CONTRACT_NAME ops_stake_operator_command --args '{"command":{"UpdateFees":{"staking_fee":1,"earnings_fee":50}}}' --accountId $oysterpack.testnet
```

## Staking Pool Treasury
```shell
near call $CONTRACT_NAME ops_stake_treasury_deposit --accountId oysterpack.testnet --amount 10

near call $CONTRACT_NAME ops_stake_treasury_distribution --accountId oysterpack.testnet --amount 10

near call $CONTRACT_NAME ops_stake_treasury_transfer_to_owner --accountId oysterpack.testnet --args '{"amount":"1000000000000000000000000"}'
```

### STAKE Pool Factory
```shell
near call $CONTRACT_NAME deploy --accountId oysterpack.testnet --amount 6 --gas 300000000000000 --args \
'{"stake_symbol":"PEARL","stake_public_key":"ed25519:GTi3gtSio5ZYYKTT8WVovqJEob6KqdmkTi8KqGSfwqdm","earnings_fee":50,"staking_fee":1}'

# guildnet
near-guildnet call stake-v1.oysterpack.guildnet deploy --accountId oysterpack.guildnet --amount 6 --gas 300000000000000 --args \
'{"stake_symbol":"PEARL","stake_public_key":"ed25519:67qRSN1Cnkx6y7e21bJq3f7vEg89PSjxRBN57mY2dReg","earnings_fee":50,"staking_fee":1}'
```

#   1000000000000000000000000     - 1 NEAR
# 0.0003930000000000000000000

# 1000000000000                   - 1 TGas
# 

Apr 29 19:13:18 validator neard[1122]: Apr 29 19:13:18.487  INFO stats: #18216849 Downloading headers 29.98% (6160534)  18/18/40 peers ⬇ 385.8kiB/s ⬆ 0.4kiB/s 0.00 bps 0 gas/s CPU: 41%, Mem: 545.1 MiB
Apr 29 19:13:28 validator neard[1122]: Apr 29 19:13:28.491  INFO stats: #18216849 Downloading headers 30.00% (6159016)  18/18/40 peers ⬇ 364.8kiB/s ⬆ 0.4kiB/s 0.00 bps 0 gas/s CPU: 22%, Mem: 545.1 MiB
Apr 29 19:13:38 validator neard[1122]: Apr 29 19:13:38.495  INFO stats: #18216849 Downloading headers 30.02% (6156982)  18/18/40 peers ⬇ 366.3kiB/s ⬆ 0.4kiB/s 0.00 bps 0 gas/s CPU: 42%, Mem: 545.1 MiB

'''
'''--- docs/validator.md ---
## Running a Validator Node on testnet
- https://docs.near.org/docs/validator/staking
```shell
STAKING_POOL=dev-1618770943926-8326158
NEARCORE=~/Documents/projects/github/near/nearcore

nearup run testnet --binary-path $NEARCORE/target/release --account-id $STAKING_POOL
```

## Running a Validator Node on mainnet
- https://docs.near.org/docs/validator/deploy-on-mainnet
```shell
git clone https://github.com/near/nearcore.git
export NEAR_RELEASE_VERSION=$(curl -s https://github.com/near/nearcore/releases/latest | tr '/" ' '\n' | grep "[0-9]\.[0-9]*\.[0-9]" | head -n 1)
echo $NEAR_RELEASE_VERSION
cd nearcore
git checkout -b $NEAR_RELEASE_VERSION
cargo build -p neard --release

target/release/neard init --chain-id="mainnet" --account-id=<YOUR_STAKING_POOL_ID>
target/release/neard run
```

## Initializing the STAKE contract
```shell
cd near/oysterpack-smart-stake
# set `CONTRACT_NAME` env var
. ./neardev/dev-account.env
echo $CONTRACT_NAME
near call $CONTRACT_NAME deploy --accountId oysterpack.testnet --args '{"stake_public_key":"ed25519:AC1pVDXsE8sZiLAqLTDa3sD8DH74U5yUDaYKWeBwwyJj"}'
```

## Setting up the validator node
- https://www.digitalocean.com/community/tutorials/how-to-configure-ssh-key-based-authentication-on-a-linux-server

### Digital Ocean - GuildNet
- droplet: oysterpack-validator-guildnet-1
```shell
iptables -t nat -A PREROUTING -p tcp --dport 24567 -j DNAT --to-destination 10.195.213.223:24567
lxc config device add validator port24567 proxy listen=tcp:0.0.0.0:25567 connect=tcp:127.0.0.1:24567
```

'''
'''--- near/.cargo/config.toml ---
[build]
rustflags = ["-C", "link-args=-s"]
'''
'''--- near/Cargo.toml ---
[workspace]
members = ["oysterpack-smart-*"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = 0
panic = "abort"
overflow-checks = true

[profile.release.package."*"]
codegen-units = 1
opt-level = "z"
debug = 0
overflow-checks = true
'''
'''--- near/Makefile.toml ---
env_files = ["./testnet.env"]

[env]
CARGO_MAKE_EXTEND_WORKSPACE_MAKEFILE = true

[tasks.doc]
command = "cargo"
args = ["doc", "--no-deps"]

[tasks.near-login]
workspace = false
command = "near"
args = ["login", "--network_id", "${NEAR_ENV}", "--account_id", "${NEAR_MASTER_ACCOUNT}", "--useLedgerKey"]

[tasks.new-lib]
workspace = false
command = "cargo"
args = ["new", "--lib", "oysterpack-smart-${@}"]

'''
'''--- near/oysterpack-smart-account-management/Cargo.toml ---
[package]
name = "oysterpack-smart-account-management"
version = "0.1.0"
authors = ["oysterpack.inc <oysterpack.inc@gmail.com>"]
edition = "2018"

[dependencies]
oysterpack-smart-near = { path = "../oysterpack-smart-near" }
lazy_static = "1.4.0"

[dev-dependencies]
oysterpack-smart-near-test = { path = "../oysterpack-smart-near-test" }
enumflags2 = "0.7.1"
'''
'''--- near/oysterpack-smart-account-management/Makefile.toml ---
extend = "../Makefile.toml"
'''
'''--- near/oysterpack-smart-account-management/README.md ---

'''
'''--- near/oysterpack-smart-account-management/src/components.rs ---
pub mod account_management;
pub mod account_repository;
pub(crate) mod account_storage_usage;

'''
'''--- near/oysterpack-smart-account-management/src/components/account_management.rs ---
//! [`AccountManagementComponent`]
//! - constructor: [`AccountManagementComponent::new`]
//!   - [`ContractPermissions`]
//! - deployment: [`AccountManagementComponent::deploy`]
//!   - config: [`AccountManagementComponentConfig`]

use crate::*;
use oysterpack_smart_near::near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    env,
    json_types::ValidAccountId,
    Promise,
};
use oysterpack_smart_near::{
    asserts::{assert_min_near_attached, assert_yocto_near_attached},
    domain::YoctoNear,
    eventbus, ErrCode, ErrorConst,
};
use std::{fmt::Debug, ops::Deref};

use crate::components::account_repository::AccountRepositoryComponent;
use crate::components::account_storage_usage::AccountStorageUsageComponent;
use oysterpack_smart_near::asserts::{assert_account_not_predecessor, ERR_INVALID};
use oysterpack_smart_near::component::Deploy;
use oysterpack_smart_near::domain::StorageUsage;
use std::collections::HashMap;
use std::marker::PhantomData;

pub const ERR_INSUFFICIENT_STORAGE_BALANCE: ErrorConst = ErrorConst(
    ErrCode("INSUFFICIENT_STORAGE_BALANCE"),
    "account's available storage balance is insufficient to satisfy request",
);

/// Core account management component implements the following interfaces:
/// 1. [`AccountRepository`]
/// 2. [`StorageManagement`] - NEP-145
/// 3. [`AccountStorageUsage`]
/// 4. [`PermissionsManagement`]
///
/// ## Deployment
/// - [`AccountManagementComponent::deploy`]
/// - [`AccountManagementComponentConfig`]
///
/// ## Constructor
/// - [AccountManagementComponent::new]
pub struct AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    contract_permissions: ContractPermissions,
    account_repository: AccountRepositoryComponent<T>,

    _phantom_data: PhantomData<T>,
}

impl<T> Default for AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn default() -> Self {
        Self::new(Default::default())
    }
}

impl<T> AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    pub fn new(contract_permissions: ContractPermissions) -> Self {
        AccountMetrics::register_account_storage_event_handler();
        Self {
            contract_permissions,
            account_repository: Default::default(),
            _phantom_data: Default::default(),
        }
    }
}

impl<T> AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    /// helper method used to measure the amount of storage needed to store the specified data.
    pub fn measure_storage_usage(account_data: T) -> StorageUsage {
        let mut account_manager: Self = Self::new(Default::default());

        // seeds the storage required to store metrics
        {
            let account_id = "1953717115592535419708657925195464285";
            account_manager.delete_account(account_id);
            account_manager.create_account(account_id, 0.into(), Some(account_data.clone()));
            account_manager.delete_account(account_id);
        }

        let account_id = "1953718041838591893489340663938715635";
        account_manager.delete_account(account_id);
        let initial_storage_usage = env::storage_usage();
        let (mut account, _data) =
            account_manager.create_account(account_id, 0.into(), Some(account_data));
        account.grant_operator();
        account.save();
        let storage_usage = env::storage_usage() - initial_storage_usage;

        // clean up storage
        account_manager.delete_account(account_id);
        // ensure all data is cleaned up
        assert_eq!(initial_storage_usage, env::storage_usage());

        storage_usage.into()
    }

    pub fn account_metrics() -> AccountMetrics {
        AccountMetrics::load()
    }

    /// if the account is not registered, then the contract will register the account and pay for its
    /// storage
    pub fn get_or_register_account(account_id: &str) -> AccountNearDataObject {
        AccountNearDataObject::load(account_id).unwrap_or_else(|| {
            // register the account
            {
                AccountMetrics::register_account_storage_event_handler();
                let storage_balance_bounds: StorageBalanceBounds = AccountStorageUsageComponent
                    .ops_storage_usage_bounds()
                    .into();
                let account = AccountNearDataObject::new(account_id, storage_balance_bounds.min);
                let storage_balance = account.storage_balance(storage_balance_bounds.min);
                account.save();
                eventbus::post(&AccountStorageEvent::Registered(storage_balance));
            }
            // the account storage usage is updated by the storage event handler - thus the object state
            // becomes stale, and we need to return a fresh updated instance from storage
            AccountNearDataObject::registered_account(account_id)
        })
    }

    pub fn register_account_if_not_exists(account_id: &str) {
        if !AccountNearDataObject::exists(account_id) {
            AccountMetrics::register_account_storage_event_handler();
            let storage_balance_bounds: StorageBalanceBounds = AccountStorageUsageComponent
                .ops_storage_usage_bounds()
                .into();
            let account = AccountNearDataObject::new(account_id, storage_balance_bounds.min);
            let storage_balance = account.storage_balance(storage_balance_bounds.min);
            account.save();
            eventbus::post(&AccountStorageEvent::Registered(storage_balance));
        }
    }
}

impl<T> Deploy for AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    type Config = AccountManagementComponentConfig;

    fn deploy(config: Self::Config) {
        // configure storage usage bounds
        {
            let mut storage_usage_bounds =
                config
                    .storage_usage_bounds
                    .unwrap_or_else(|| StorageUsageBounds {
                        min: Self::measure_storage_usage(Default::default()),
                        max: None,
                    });

            let storage_usage_bounds =
                config
                    .component_account_storage_mins
                    .map_or(storage_usage_bounds, |funcs| {
                        let account_storage_min: StorageUsage = funcs
                            .iter()
                            .fold(storage_usage_bounds.min, |sum, f| (sum + f()));
                        storage_usage_bounds.min = account_storage_min;
                        storage_usage_bounds
                    });

            AccountStorageUsageComponent::deploy(storage_usage_bounds);
        }

        // create admin account
        {
            let mut account = Self::get_or_register_account(config.admin_account.as_ref().as_str());
            account.grant_admin();
            account.save();
        }
    }
}

/// [`AccountManagementComponent::deploy`] deployment config
pub struct AccountManagementComponentConfig {
    /// if not specified then the default min will be measured and max will be unbounded
    pub storage_usage_bounds: Option<StorageUsageBounds>,

    /// components that manage account data must register functions that provide min account storage requirements
    pub component_account_storage_mins: Option<Vec<fn() -> StorageUsage>>,

    /// required to seed the contract with an admin account
    /// - storage usage costs will be paid for by the contract owner - normally the initial admin
    ///   account will be the contract owner
    pub admin_account: ValidAccountId,
}

impl AccountManagementComponentConfig {
    pub fn new(admin_account: ValidAccountId) -> Self {
        Self {
            admin_account,
            storage_usage_bounds: None,
            component_account_storage_mins: None,
        }
    }
}

impl<T> AccountRepository<T> for AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn create_account(
        &mut self,
        account_id: &str,
        near_balance: YoctoNear,
        data: Option<T>,
    ) -> Account<T> {
        self.account_repository
            .create_account(account_id, near_balance, data)
    }

    fn load_account(&self, account_id: &str) -> Option<Account<T>> {
        self.account_repository.load_account(account_id)
    }

    fn load_account_data(&self, account_id: &str) -> Option<AccountDataObject<T>> {
        self.account_repository.load_account_data(account_id)
    }

    fn load_account_near_data(&self, account_id: &str) -> Option<AccountNearDataObject> {
        self.account_repository.load_account_near_data(account_id)
    }

    fn registered_account(&self, account_id: &str) -> Account<T> {
        self.account_repository.registered_account(account_id)
    }

    fn registered_account_near_data(&self, account_id: &str) -> AccountNearDataObject {
        self.account_repository
            .registered_account_near_data(account_id)
    }

    fn registered_account_data(&self, account_id: &str) -> AccountDataObject<T> {
        self.account_repository.registered_account_data(account_id)
    }

    fn account_exists(&self, account_id: &str) -> bool {
        self.account_repository.account_exists(account_id)
    }

    fn delete_account(&mut self, account_id: &str) {
        self.account_repository.delete_account(account_id)
    }
}

/// exposes [`AccountStorageUsage`] interface on the component
impl<T> AccountStorageUsage for AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn ops_storage_usage_bounds(&self) -> StorageUsageBounds {
        AccountStorageUsageComponent.ops_storage_usage_bounds()
    }

    fn ops_storage_usage(&self, account_id: ValidAccountId) -> Option<StorageUsage> {
        AccountStorageUsageComponent.ops_storage_usage(account_id)
    }
}

impl<T> StorageManagement for AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default + 'static,
{
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        // if the account ID is not specified, then deposit is for the predecessor account ID
        let account_id = account_id.map_or_else(env::predecessor_account_id, |account_id| {
            account_id.as_ref().clone()
        });

        let storage_balance_bounds = self.storage_balance_bounds();

        let registration_only = registration_only.unwrap_or(false);
        if registration_only {
            assert_min_near_attached(storage_balance_bounds.min);
        }
        let deposit: YoctoNear = env::attached_deposit().into();

        let account: AccountNearDataObject = match self.load_account_near_data(&account_id) {
            Some(mut account) => {
                if registration_only {
                    // refund the full deposit
                    send_refund(deposit.value());
                } else {
                    if let Some(max) = storage_balance_bounds.max {
                        self.deposit_with_max_bound(
                            &mut account,
                            Deposit(deposit),
                            MaxStorageBalance(max),
                        )
                    } else {
                        self.deposit(&mut account, deposit)
                    }
                }
                account
            }
            None => self.register_account(&account_id, deposit, registration_only),
        };

        account.storage_balance(storage_balance_bounds.min)
    }

    fn storage_withdraw(&mut self, amount: Option<YoctoNear>) -> StorageBalance {
        assert_yocto_near_attached();

        let account_id = env::predecessor_account_id();
        let mut account = self.registered_account_near_data(&account_id);
        let storage_balance_bounds = self.storage_balance_bounds();
        let account_available_balance = account
            .storage_balance(storage_balance_bounds.min)
            .available;
        match amount {
            Some(amount) => {
                if amount > YoctoNear::ZERO {
                    ERR_INSUFFICIENT_STORAGE_BALANCE.assert(|| account_available_balance >= amount);
                    send_refund(amount + 1);
                    account.decr_near_balance(amount);
                    account.save();
                }
            }
            None => {
                // withdraw the total available balance
                if account_available_balance > YoctoNear::ZERO {
                    send_refund(account_available_balance + 1);
                    account.decr_near_balance(account_available_balance);
                    account.save();
                }
            }
        }

        account.storage_balance(storage_balance_bounds.min)
    }

    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        assert_yocto_near_attached();
        let account_id = env::predecessor_account_id();
        self.load_account_near_data(&account_id)
            .map_or(false, |account| {
                let account_near_balance = account.near_balance();
                eventbus::post(&StorageManagementEvent::PreUnregister {
                    account_id: account_id.clone(),
                    force: force.unwrap_or(false),
                });
                self.delete_account(&account_id);
                eventbus::post(&AccountStorageEvent::Unregistered(account_near_balance));
                send_refund(account_near_balance + 1);
                true
            })
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        AccountStorageUsageComponent
            .ops_storage_usage_bounds()
            .into()
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        self.load_account_near_data(account_id.as_ref())
            .map(|account| account.storage_balance(self.storage_balance_bounds().min))
    }
}

impl<T> PermissionsManagement for AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default + 'static,
{
    fn ops_permissions_is_admin(&self, account_id: ValidAccountId) -> bool {
        self.load_account_near_data(account_id.as_ref())
            .map_or(false, |account| account.is_admin())
    }

    fn ops_permissions_grant_admin(&mut self, account_id: ValidAccountId) {
        assert_account_not_predecessor(account_id.as_ref());
        self.assert_predecessor_is_admin();

        let mut account = self.registered_account_near_data(account_id.as_ref());
        if !account.is_admin() {
            account.grant_admin();
            account.save();
            LOG_EVENT_PERMISSIONS_GRANT.log("admin")
        }
    }

    fn ops_permissions_revoke_admin(&mut self, account_id: ValidAccountId) {
        assert_account_not_predecessor(account_id.as_ref());
        self.assert_predecessor_is_admin();

        let mut account = self.registered_account_near_data(account_id.as_ref());
        if account.is_admin() {
            account.revoke_admin();
            Self::clear_permissions_if_has_no_permissions(&mut account);
            account.save();
            LOG_EVENT_PERMISSIONS_REVOKE.log("admin")
        }
    }

    fn ops_permissions_is_operator(&self, account_id: ValidAccountId) -> bool {
        self.load_account_near_data(account_id.as_ref())
            .map_or(false, |account| account.is_operator())
    }

    fn ops_permissions_grant_operator(&mut self, account_id: ValidAccountId) {
        assert_account_not_predecessor(account_id.as_ref());
        self.assert_predecessor_is_admin();

        let mut account = self.registered_account_near_data(account_id.as_ref());
        if !account.is_operator() {
            account.grant_operator();
            account.save();
            LOG_EVENT_PERMISSIONS_GRANT.log("operator")
        }
    }

    fn ops_permissions_revoke_operator(&mut self, account_id: ValidAccountId) {
        assert_account_not_predecessor(account_id.as_ref());
        self.assert_predecessor_is_admin();

        let mut account = self.registered_account_near_data(account_id.as_ref());
        if account.is_operator() {
            account.revoke_operator();
            Self::clear_permissions_if_has_no_permissions(&mut account);
            account.save();
            LOG_EVENT_PERMISSIONS_REVOKE.log("operator")
        }
    }

    fn ops_permissions_grant(&mut self, account_id: ValidAccountId, permissions: Permissions) {
        self.assert_contract_supports_permissions(permissions);
        assert_account_not_predecessor(account_id.as_ref());
        self.assert_predecessor_is_admin();

        let mut account = self.registered_account_near_data(account_id.as_ref());
        if !account.contains_permissions(permissions) {
            account.grant(permissions);
            account.save();
            LOG_EVENT_PERMISSIONS_GRANT.log(format!(
                "{:?}",
                self.contract_permissions.permission_names(permissions)
            ));
        }
    }

    fn ops_permissions_grant_permissions(
        &mut self,
        account_id: ValidAccountId,
        permissions: Vec<u8>,
    ) {
        let permissions = permissions
            .iter()
            .fold(0_u64, |permissions, perm_bit| permissions | 1 << *perm_bit);
        self.ops_permissions_grant(account_id, permissions.into());
    }

    fn ops_permissions_revoke(&mut self, account_id: ValidAccountId, permissions: Permissions) {
        self.assert_contract_supports_permissions(permissions);
        assert_account_not_predecessor(account_id.as_ref());
        self.assert_predecessor_is_admin();

        let mut account = self.registered_account_near_data(account_id.as_ref());
        if account.permissions().is_some() {
            account.revoke(permissions);
            Self::clear_permissions_if_has_no_permissions(&mut account);
            account.save();
            LOG_EVENT_PERMISSIONS_REVOKE.log(format!(
                "{:?}",
                self.contract_permissions.permission_names(permissions)
            ));
        }
    }

    fn ops_permissions_revoke_permissions(
        &mut self,
        account_id: ValidAccountId,
        permissions: Vec<u8>,
    ) {
        let permissions = permissions
            .iter()
            .fold(0_u64, |permissions, perm_bit| permissions | 1 << perm_bit);
        self.ops_permissions_revoke(account_id, permissions.into());
    }

    fn ops_permissions_revoke_all(&mut self, account_id: ValidAccountId) {
        assert_account_not_predecessor(account_id.as_ref());
        self.assert_predecessor_is_admin();
        let mut account = self.registered_account_near_data(account_id.as_ref());
        if account.permissions().is_some() {
            account.revoke_all();
            account.save();
            LOG_EVENT_PERMISSIONS_REVOKE.log("all permissions were revoked");
        }
    }

    fn ops_permissions_contains(
        &self,
        account_id: ValidAccountId,
        permissions: Permissions,
    ) -> bool {
        self.load_account_near_data(account_id.as_ref())
            .map_or(false, |account| account.contains_permissions(permissions))
    }

    fn ops_permissions(&self, account_id: ValidAccountId) -> Option<Permissions> {
        self.load_account_near_data(account_id.as_ref())
            .map(|account| account.permissions())
            .flatten()
    }

    fn ops_permissions_granted(&self, account_id: ValidAccountId) -> Option<HashMap<u8, String>> {
        self.ops_permissions(account_id).map(|perms| {
            let mut account_perms = HashMap::with_capacity(self.contract_permissions.0.len() + 2);
            for (perm_bit, name) in self.contract_permissions.0.iter() {
                if perms.contains(1 << *perm_bit) {
                    account_perms.insert(*perm_bit, name.to_string());
                }
            }
            if perms.contains(Permissions::ADMIN) {
                account_perms.insert(63, "admin".to_string());
            }
            if perms.contains(Permissions::OPERATOR) {
                account_perms.insert(62, "operator".to_string());
            }

            account_perms
        })
    }

    fn ops_permissions_contract_permissions(&self) -> Option<HashMap<u8, String>> {
        if self.contract_permissions.0.is_empty() {
            return None;
        }
        let mut perms = HashMap::with_capacity(self.contract_permissions.0.len());
        for (k, value) in self.contract_permissions.0.iter() {
            perms.insert(*k, value.to_string());
        }
        Some(perms)
    }
}

impl<T> AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default + 'static,
{
    pub fn register_account(
        &mut self,
        account_id: &str,
        deposit: YoctoNear,
        registration_only: bool,
    ) -> AccountNearDataObject {
        let storage_balance_bounds = self.storage_balance_bounds();
        let deposit = Self::initial_deposit(deposit, registration_only, storage_balance_bounds);
        let (account, _data) = self.create_account(account_id, deposit, None);
        eventbus::post(&AccountStorageEvent::Registered(
            account.storage_balance(storage_balance_bounds.min),
        ));
        account
    }

    pub fn permission_by_name(&self, name: &str) -> Option<Permission> {
        if self.contract_permissions.0.is_empty() {
            return None;
        }
        for (k, v) in self.contract_permissions.0.iter() {
            if name == *v {
                return Some(1_u64 << *k);
            }
        }
        None
    }
}

/// helper functions
impl<T> AccountManagementComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default + 'static,
{
    fn clear_permissions_if_has_no_permissions(account: &mut AccountNearData) {
        if let Some(permissions) = account.permissions() {
            if !permissions.has_permissions() {
                account.revoke_all(); // sets permissions to NONE - frees up some storage
            }
        }
    }

    fn assert_contract_supports_permissions(&self, permissions: Permissions) {
        ERR_INVALID.assert(
            || self.contract_permissions.is_supported(permissions),
            || "contract does not support specified permissions",
        );
    }

    fn assert_predecessor_is_admin(&self) {
        let admin = self.registered_account_near_data(env::predecessor_account_id().as_str());
        ERR_NOT_AUTHORIZED.assert(|| admin.is_admin());
    }

    /// refunds deposit amount that is above the max allowed storage balance
    fn deposit_with_max_bound(
        &self,
        account: &mut AccountNearDataObject,
        deposit: Deposit,
        max: MaxStorageBalance,
    ) {
        if account.near_balance() < *max {
            let max_allowed_deposit = *max - account.near_balance();
            let deposit = if *deposit > max_allowed_deposit {
                // refund amount over the upper bound
                send_refund(*deposit - max_allowed_deposit);
                max_allowed_deposit
            } else {
                *deposit
            };

            self.deposit(account, deposit);
        } else {
            // account storage balance is already at max limit - thus refund the full deposit amount
            send_refund(deposit.value());
        }
    }

    fn deposit(&self, account: &mut AccountNearDataObject, deposit: YoctoNear) {
        account.incr_near_balance(deposit);
        account.save();
    }

    fn initial_deposit(
        deposit: YoctoNear,
        registration_only: bool,
        storage_balance_bounds: StorageBalanceBounds,
    ) -> YoctoNear {
        assert_min_near_attached(storage_balance_bounds.min);
        if registration_only {
            // only take the min required and refund the rest
            let refund_amount = deposit - storage_balance_bounds.min;
            if *refund_amount > 0 {
                send_refund(refund_amount);
            }
            storage_balance_bounds.min
        } else {
            // refund deposit that is over the max allowed
            storage_balance_bounds.max.map_or(deposit, |max| {
                if deposit > max {
                    let refund_amount = deposit - max;
                    send_refund(refund_amount);
                    max
                } else {
                    deposit
                }
            })
        }
    }
}

/// refund is always sent back to the predecessor account ID
fn send_refund<Amount: Into<YoctoNear>>(amount: Amount) {
    Promise::new(env::predecessor_account_id()).transfer(amount.into().value());
}

struct Deposit(YoctoNear);

impl Deref for Deposit {
    type Target = YoctoNear;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

struct MaxStorageBalance(YoctoNear);

impl Deref for MaxStorageBalance {
    type Target = YoctoNear;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near::near_sdk::*;
    use oysterpack_smart_near_test::*;

    pub type AccountManager = AccountManagementComponent<()>;
    const ADMIN: &str = "admin";
    const ACCOUNT: &str = "bob";

    fn deploy(
        account_id: &str,
        config: Option<AccountManagementComponentConfig>,
    ) -> (VMContext, AccountManager) {
        let ctx = new_context(account_id);
        testing_env!(ctx.clone());

        AccountManager::deploy(config.unwrap_or_else(|| AccountManagementComponentConfig {
            storage_usage_bounds: Some(StorageUsageBounds {
                min: 1000.into(),
                max: None,
            }),
            component_account_storage_mins: None,
            admin_account: to_valid_account_id(ADMIN),
        }));

        (ctx, AccountManager::new(Default::default()))
    }

    #[test]
    fn get_or_register_account() {
        let (ctx, _account_manager) = deploy(ACCOUNT, None);
        testing_env!(ctx.clone());
        let _alice = AccountManager::get_or_register_account("alice");
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(logs, vec![
            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(97)",
            "[INFO] [ACCOUNT_STORAGE_CHANGED] Registered(StorageBalance { total: YoctoNear(10000000000000000000000), available: YoctoNear(0) })",
        ]);

        testing_env!(ctx.clone());
        let _alice = AccountManager::get_or_register_account("alice");
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert!(logs.is_empty());
    }

    #[test]
    fn register_account_if_not_exists() {
        let (ctx, _account_manager) = deploy(ACCOUNT, None);
        testing_env!(ctx.clone());
        AccountManager::register_account_if_not_exists("alice");
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(logs, vec![
            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(97)",
            "[INFO] [ACCOUNT_STORAGE_CHANGED] Registered(StorageBalance { total: YoctoNear(10000000000000000000000), available: YoctoNear(0) })",
        ]);

        testing_env!(ctx.clone());
        AccountManager::register_account_if_not_exists("alice");
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert!(logs.is_empty());
    }
}

#[cfg(test)]
mod tests_service {
    use super::*;
    use crate::StorageUsageBounds;
    use oysterpack_smart_near::near_sdk;
    use oysterpack_smart_near_test::*;

    pub type AccountManager = AccountManagementComponent<()>;

    fn comp_account_storage_min() -> StorageUsage {
        1000.into()
    }

    #[test]
    fn deploy_and_use_module() {
        // Arrange
        let account_id = "bob";
        let ctx = new_context(account_id);
        testing_env!(ctx);

        // Act
        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: Some(StorageUsageBounds {
                min: 1000.into(),
                max: None,
            }),
            component_account_storage_mins: Some(vec![comp_account_storage_min]),
            admin_account: to_valid_account_id("owner"),
        });

        let service: AccountManager = AccountManager::new(Default::default());
        let storage_balance_bounds = service.storage_balance_bounds();
        assert_eq!(
            storage_balance_bounds.min,
            (env::storage_byte_cost() * 2000).into()
        );
        assert!(storage_balance_bounds.max.is_none());

        let _storage_usage_bounds = service.storage_balance_of(to_valid_account_id(account_id));
    }
}

#[cfg(test)]
mod tests_storage_management {
    use super::*;
    use crate::{AccountMetrics, StorageUsageBounds};
    use oysterpack_smart_near::domain::StorageUsage;
    use oysterpack_smart_near::near_sdk;
    use oysterpack_smart_near_test::*;

    const STORAGE_USAGE_BOUNDS: StorageUsageBounds = StorageUsageBounds {
        min: StorageUsage(1000),
        max: None,
    };

    fn storage_balance_min() -> YoctoNear {
        (STORAGE_USAGE_BOUNDS.min.value() as u128 * env::STORAGE_PRICE_PER_BYTE).into()
    }

    const PREDECESSOR_ACCOUNT_ID: &str = "alice";

    fn run_test<F>(
        storage_usage_bounds: StorageUsageBounds,
        account_id: Option<&str>,
        registration_only: Option<bool>,
        deposit: YoctoNear,
        already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
        test: F,
    ) where
        F: FnOnce(AccountManagementComponent<()>, StorageBalance),
    {
        let mut ctx = new_context(PREDECESSOR_ACCOUNT_ID);
        testing_env!(ctx.clone());

        AccountMetrics::register_account_storage_event_handler();
        AccountMetrics::reset();

        AccountStorageUsageComponent::deploy(storage_usage_bounds);

        let mut service: AccountManagementComponent<()> =
            AccountManagementComponent::new(Default::default());
        let storage_balance_bounds = service.storage_balance_bounds();
        println!("storage_balance_bounds = {:?}", storage_balance_bounds);

        if already_registered {
            ctx.attached_deposit = storage_balance_bounds.min.value();
            testing_env!(ctx.clone());
            let storage_balance = service.storage_deposit(
                Some(to_valid_account_id(
                    account_id.unwrap_or(PREDECESSOR_ACCOUNT_ID),
                )),
                Some(true),
            );
            println!("registered account: {:?}", storage_balance);
        }

        ctx.attached_deposit = deposit.value();
        println!("deposit amount = {}", ctx.attached_deposit);
        testing_env!(ctx.clone());

        let storage_balance =
            service.storage_deposit(account_id.map(to_valid_account_id), registration_only);
        println!("storage_balance after deposit = {:?}", storage_balance);

        test(service, storage_balance);
    }

    #[cfg(test)]
    mod tests_storage_deposit {
        use super::*;

        type AccountManager = AccountManagementComponent<()>;

        #[cfg(test)]
        mod self_registration_only {
            use super::*;

            fn run_test<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    STORAGE_USAGE_BOUNDS,
                    None,
                    Some(true),
                    deposit,
                    already_registered,
                    test,
                );
            }

            #[test]
            fn unknown_account_with_exact_storage_deposit() {
                run_test(
                    storage_balance_min(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment() {
                run_test(
                    (storage_balance_min().value() * 3).into(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        // Assert
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert account was registered
                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());

                        // Assert overpayment was refunded
                        let receipts = deserialize_receipts();
                        assert_eq!(receipts.len(), 1);
                        let receipt = &receipts[0];
                        assert_eq!(&receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                        let action = &receipt.actions[0];
                        match action {
                            Action::Transfer(action) => {
                                assert_eq!(
                                    action.deposit,
                                    service.storage_balance_bounds().min.value() * 2
                                );
                            }
                            _ => panic!("expected Transfer"),
                        }
                    },
                );
            }

            #[test]
            fn already_registered() {
                run_test(
                    storage_balance_min(),
                    true,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert the deposit was refunded
                        let receipts = deserialize_receipts();
                        assert_eq!(receipts.len(), 1);
                        let receipt = &receipts[0];
                        assert_eq!(&receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                        let action = &receipt.actions[0];
                        match action {
                            Action::Transfer(action) => {
                                assert_eq!(action.deposit, storage_balance_min().value());
                            }
                            _ => panic!("expected Transfer"),
                        }
                    },
                );
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached() {
                run_test(0.into(), false, |_service, _storage_balance| {});
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached_already_registered() {
                run_test(0.into(), true, |_service, _storage_balance| {});
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn one_deposit_attached_already_registered() {
                run_test(1.into(), true, |_service, _storage_balance| {});
            }
        }

        #[cfg(test)]
        mod self_registration_only_with_max_bound_set {
            use super::*;

            const STORAGE_USAGE_BOUNDS: StorageUsageBounds = StorageUsageBounds {
                min: StorageUsage(1000),
                max: Some(StorageUsage(2000)),
            };

            fn storage_balance_min() -> YoctoNear {
                (STORAGE_USAGE_BOUNDS.min.value() as u128 * env::STORAGE_PRICE_PER_BYTE).into()
            }

            fn run_test<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    STORAGE_USAGE_BOUNDS,
                    None,
                    Some(true),
                    deposit,
                    already_registered,
                    test,
                );
            }

            #[test]
            fn unknown_account_with_exact_storage_deposit() {
                run_test(
                    storage_balance_min(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment() {
                run_test(
                    (storage_balance_min().value() * 3).into(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        // Assert
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert account was registered
                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());

                        // Assert overpayment was refunded
                        let receipts = deserialize_receipts();
                        assert_eq!(receipts.len(), 1);
                        let receipt = &receipts[0];
                        assert_eq!(&receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                        let action = &receipt.actions[0];
                        match action {
                            Action::Transfer(action) => {
                                assert_eq!(
                                    action.deposit,
                                    service.storage_balance_bounds().min.value() * 2
                                );
                            }
                            _ => panic!("expected Transfer"),
                        }
                    },
                );
            }

            #[test]
            fn already_registered() {
                run_test(
                    storage_balance_min(),
                    true,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert the deposit was refunded
                        let receipts = deserialize_receipts();
                        assert_eq!(receipts.len(), 1);
                        let receipt = &receipts[0];
                        assert_eq!(&receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                        let action = &receipt.actions[0];
                        match action {
                            Action::Transfer(action) => {
                                assert_eq!(action.deposit, storage_balance_min().value());
                            }
                            _ => panic!("expected Transfer"),
                        }
                    },
                );
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached() {
                run_test(0.into(), false, |_service, _storage_balance| {});
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached_already_registered() {
                run_test(0.into(), true, |_service, _storage_balance| {});
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn one_deposit_attached_already_registered() {
                run_test(1.into(), true, |_service, _storage_balance| {});
            }
        }

        #[cfg(test)]
        mod other_registration_only {
            use super::*;

            const ACCOUNT_ID: &str = "alfio";

            fn run_test<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    STORAGE_USAGE_BOUNDS,
                    Some(ACCOUNT_ID),
                    Some(true),
                    deposit,
                    already_registered,
                    test,
                );
            }

            #[test]
            fn unknown_account_with_exact_storage_deposit() {
                run_test(
                    storage_balance_min(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        let account = service.registered_account_near_data(ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment() {
                run_test(
                    (storage_balance_min().value() * 3).into(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        // Assert
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert account was registered
                        let account = service.registered_account_near_data(ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());

                        // Assert overpayment was refunded
                        let receipts = deserialize_receipts();
                        assert_eq!(receipts.len(), 1);
                        let receipt = &receipts[0];
                        assert_eq!(&receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                        let action = &receipt.actions[0];
                        match action {
                            Action::Transfer(action) => {
                                assert_eq!(
                                    action.deposit,
                                    service.storage_balance_bounds().min.value() * 2
                                );
                            }
                            _ => panic!("expected Transfer"),
                        }
                    },
                );
            }

            #[test]
            fn already_registered() {
                run_test(
                    storage_balance_min(),
                    true,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert the deposit was refunded
                        let receipts = deserialize_receipts();
                        assert_eq!(receipts.len(), 1);
                        let receipt = &receipts[0];
                        assert_eq!(&receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                        let action = &receipt.actions[0];
                        match action {
                            Action::Transfer(action) => {
                                assert_eq!(action.deposit, storage_balance_min().value());
                            }
                            _ => panic!("expected Transfer"),
                        }
                    },
                );
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached() {
                run_test(0.into(), false, |_service, _storage_balance| {});
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached_already_registered() {
                run_test(0.into(), true, |_service, _storage_balance| {});
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn one_deposit_attached_already_registered() {
                run_test(1.into(), true, |_service, _storage_balance| {});
            }
        }

        #[cfg(test)]
        mod self_deposit_with_implied_registration_only_false {
            use super::*;
            use oysterpack_smart_near::YOCTO;

            fn run_test<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    STORAGE_USAGE_BOUNDS,
                    None,
                    None,
                    deposit,
                    already_registered,
                    test,
                );
            }

            fn run_test_with_storage_balance_bounds<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                storage_usage_bounds: StorageUsageBounds,
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    storage_usage_bounds,
                    None,
                    None,
                    deposit,
                    already_registered,
                    test,
                );
            }

            #[test]
            fn unknown_account_with_exact_storage_deposit() {
                run_test(
                    storage_balance_min(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment() {
                let deposit_amount: YoctoNear = (storage_balance_min().value() * 3).into();
                run_test(
                    deposit_amount,
                    false,
                    |service, storage_balance: StorageBalance| {
                        // Assert
                        assert_eq!(storage_balance.total, deposit_amount);
                        assert_eq!(
                            storage_balance.available,
                            (service.storage_balance_bounds().min.value() * 2).into()
                        );

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert account was registered
                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), deposit_amount);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment_above_max_bound() {
                let deposit_amount: YoctoNear = (storage_balance_min().value() * 3).into();
                run_test_with_storage_balance_bounds(
                    deposit_amount,
                    false,
                    StorageUsageBounds {
                        min: STORAGE_USAGE_BOUNDS.min,
                        max: Some((STORAGE_USAGE_BOUNDS.min.value() * 2).into()),
                    },
                    |service, storage_balance: StorageBalance| {
                        let storage_balance_bounds = service.storage_balance_bounds();
                        // Assert
                        assert_eq!(storage_balance.total, storage_balance_bounds.max.unwrap());
                        assert_eq!(storage_balance.available, storage_balance_bounds.min);

                        // Assert account NEAR balance was persisted
                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert account was registered
                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), storage_balance_bounds.max.unwrap());

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());

                        let receipts = deserialize_receipts();
                        let receipt = &receipts[0];
                        assert_eq!(receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                        match &receipt.actions[0] {
                            Action::Transfer(transfer) => {
                                assert_eq!(transfer.deposit, storage_balance_bounds.min.value());
                            }
                            _ => panic!("expected Transfer action"),
                        }
                    },
                );
            }

            #[test]
            fn deposit_with_account_already_maxed_out() {
                // Arrange
                let account = "alfio";
                let mut ctx = new_context(account);
                testing_env!(ctx.clone());

                AccountManagementComponent::<()>::deploy(AccountManagementComponentConfig {
                    storage_usage_bounds: Some(StorageUsageBounds {
                        min: 1000.into(),
                        max: Some(2000.into()),
                    }),
                    admin_account: to_valid_account_id("admin"),
                    component_account_storage_mins: None,
                });

                let mut service = AccountManagementComponent::<()>::new(Default::default());

                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                let storage_balance_1 = service.storage_deposit(None, None);
                testing_env!(ctx.clone());
                let storage_balance_2 = service.storage_deposit(None, None);
                assert_eq!(storage_balance_1, storage_balance_2);
                assert_eq!(
                    storage_balance_1.total,
                    service.storage_balance_bounds().max.unwrap()
                );
                let receipts = deserialize_receipts();
                assert_eq!(&receipts[0].receiver_id, account);
                match &receipts[0].actions[0] {
                    Action::Transfer(transfer) => assert_eq!(transfer.deposit, YOCTO),
                    _ => panic!("expected TransferAction"),
                }
            }

            #[test]
            fn already_registered() {
                run_test(
                    storage_balance_min(),
                    true,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(
                            storage_balance.total.value(),
                            service.storage_balance_bounds().min.value() * 2
                        );
                        assert_eq!(
                            storage_balance.available,
                            service.storage_balance_bounds().min
                        );

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);
                    },
                );
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached() {
                run_test(0.into(), false, |_service, _storage_balance| {});
            }

            #[test]
            fn zero_deposit_attached_already_registered() {
                run_test(0.into(), true, |service, storage_balance| {
                    let storage_balance_bounds = service.storage_balance_bounds();
                    assert_eq!(storage_balance.total, storage_balance_bounds.min);
                    assert_eq!(storage_balance.available, 0.into());
                });
            }

            #[test]
            fn one_deposit_attached_already_registered() {
                run_test(1.into(), true, |service, storage_balance| {
                    let storage_balance_bounds = service.storage_balance_bounds();
                    assert_eq!(
                        storage_balance.total.value(),
                        storage_balance_bounds.min.value() + 1
                    );
                    assert_eq!(storage_balance.available, 1.into());

                    // Assert account NEAR balance was persisted
                    let storage_balance_2 = service
                        .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                        .unwrap();
                    assert_eq!(storage_balance, storage_balance_2);
                });
            }
        }

        #[cfg(test)]
        mod self_deposit_with_implied_registration_only_false_with_max_bound_set {
            use super::*;

            const STORAGE_USAGE_BOUNDS: StorageUsageBounds = StorageUsageBounds {
                min: StorageUsage(1000),
                max: Some(StorageUsage(1500)),
            };

            fn storage_balance_min() -> YoctoNear {
                (STORAGE_USAGE_BOUNDS.min.value() as u128 * env::STORAGE_PRICE_PER_BYTE).into()
            }

            fn storage_balance_max() -> YoctoNear {
                (STORAGE_USAGE_BOUNDS.max.unwrap().value() as u128 * env::STORAGE_PRICE_PER_BYTE)
                    .into()
            }

            fn run_test<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    STORAGE_USAGE_BOUNDS,
                    None,
                    None,
                    deposit,
                    already_registered,
                    test,
                );
            }

            fn run_test_with_storage_balance_bounds<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                storage_usage_bounds: StorageUsageBounds,
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    storage_usage_bounds,
                    None,
                    None,
                    deposit,
                    already_registered,
                    test,
                );
            }

            #[test]
            fn unknown_account_with_exact_storage_deposit() {
                run_test(
                    storage_balance_min(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment() {
                let deposit_amount: YoctoNear = (storage_balance_min().value() * 3).into();
                run_test(
                    deposit_amount,
                    false,
                    |service, storage_balance: StorageBalance| {
                        // Assert
                        assert_eq!(storage_balance.total, storage_balance_max());
                        assert_eq!(
                            storage_balance.available,
                            storage_balance_max() - storage_balance_min()
                        );

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert account was registered
                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), storage_balance_max());

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment_above_max_bound() {
                let deposit_amount: YoctoNear = (storage_balance_min().value() * 3).into();
                run_test_with_storage_balance_bounds(
                    deposit_amount,
                    false,
                    StorageUsageBounds {
                        min: STORAGE_USAGE_BOUNDS.min,
                        max: Some((STORAGE_USAGE_BOUNDS.min.value() * 2).into()),
                    },
                    |service, storage_balance: StorageBalance| {
                        let storage_balance_bounds = service.storage_balance_bounds();
                        // Assert
                        assert_eq!(storage_balance.total, storage_balance_bounds.max.unwrap());
                        assert_eq!(storage_balance.available, storage_balance_bounds.min);

                        // Assert account NEAR balance was persisted
                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert account was registered
                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), storage_balance_bounds.max.unwrap());

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());

                        let receipts = deserialize_receipts();
                        let receipt = &receipts[0];
                        assert_eq!(receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                        match &receipt.actions[0] {
                            Action::Transfer(transfer) => {
                                assert_eq!(transfer.deposit, storage_balance_bounds.min.value());
                            }
                            _ => panic!("expected Transfer action"),
                        }
                    },
                );
            }

            #[test]
            fn already_registered() {
                run_test(
                    storage_balance_min(),
                    true,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, storage_balance_max());
                        assert_eq!(
                            storage_balance.available,
                            storage_balance_max() - storage_balance_min()
                        );

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);
                    },
                );
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached() {
                run_test(0.into(), false, |_service, _storage_balance| {});
            }

            #[test]
            fn zero_deposit_attached_already_registered() {
                run_test(0.into(), true, |service, storage_balance| {
                    let storage_balance_bounds = service.storage_balance_bounds();
                    assert_eq!(storage_balance.total, storage_balance_bounds.min);
                    assert_eq!(storage_balance.available, 0.into());
                });
            }

            #[test]
            fn one_deposit_attached_already_registered() {
                run_test(1.into(), true, |service, storage_balance| {
                    let storage_balance_bounds = service.storage_balance_bounds();
                    assert_eq!(
                        storage_balance.total.value(),
                        storage_balance_bounds.min.value() + 1
                    );
                    assert_eq!(storage_balance.available, 1.into());

                    // Assert account NEAR balance was persisted
                    let storage_balance_2 = service
                        .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                        .unwrap();
                    assert_eq!(storage_balance, storage_balance_2);
                });
            }
        }

        #[cfg(test)]
        mod deposit_for_account_with_implied_registration_only_false {
            use super::*;

            const ACCOUNT_ID: &str = "alfio.near";

            fn run_test<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    STORAGE_USAGE_BOUNDS,
                    Some(ACCOUNT_ID),
                    None,
                    deposit,
                    already_registered,
                    test,
                );
            }

            fn run_test_with_storage_balance_bounds<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                storage_usage_bounds: StorageUsageBounds,
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    storage_usage_bounds,
                    Some(ACCOUNT_ID),
                    None,
                    deposit,
                    already_registered,
                    test,
                );
            }

            #[test]
            fn unknown_account_with_exact_storage_deposit() {
                run_test(
                    storage_balance_min(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        let account = service.registered_account_near_data(ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment() {
                let deposit_amount: YoctoNear = (storage_balance_min().value() * 3).into();
                run_test(
                    deposit_amount,
                    false,
                    |service, storage_balance: StorageBalance| {
                        // Assert
                        assert_eq!(storage_balance.total, deposit_amount);
                        assert_eq!(
                            storage_balance.available,
                            (service.storage_balance_bounds().min.value() * 2).into()
                        );

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert account was registered
                        let account = service.registered_account_near_data(ACCOUNT_ID);
                        assert_eq!(account.near_balance(), deposit_amount);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment_above_max_bound() {
                let deposit_amount: YoctoNear = (storage_balance_min().value() * 3).into();
                run_test_with_storage_balance_bounds(
                    deposit_amount,
                    false,
                    StorageUsageBounds {
                        min: STORAGE_USAGE_BOUNDS.min,
                        max: Some((STORAGE_USAGE_BOUNDS.min.value() * 2).into()),
                    },
                    |service, storage_balance: StorageBalance| {
                        let storage_balance_bounds = service.storage_balance_bounds();
                        // Assert
                        assert_eq!(storage_balance.total, storage_balance_bounds.max.unwrap());
                        assert_eq!(storage_balance.available, storage_balance_bounds.min);

                        // Assert account NEAR balance was persisted
                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);

                        // Assert account was registered
                        let account = service.registered_account_near_data(ACCOUNT_ID);
                        assert_eq!(account.near_balance(), storage_balance_bounds.max.unwrap());

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());

                        let receipts = deserialize_receipts();
                        let receipt = &receipts[0];
                        assert_eq!(receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                        match &receipt.actions[0] {
                            Action::Transfer(transfer) => {
                                assert_eq!(transfer.deposit, storage_balance_bounds.min.value());
                            }
                            _ => panic!("expected Transfer action"),
                        }
                    },
                );
            }

            #[test]
            fn already_registered() {
                run_test(
                    storage_balance_min(),
                    true,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(
                            storage_balance.total.value(),
                            service.storage_balance_bounds().min.value() * 2
                        );
                        assert_eq!(
                            storage_balance.available,
                            service.storage_balance_bounds().min
                        );

                        let storage_balance_2 = service
                            .storage_balance_of(to_valid_account_id(ACCOUNT_ID))
                            .unwrap();
                        assert_eq!(storage_balance, storage_balance_2);
                    },
                );
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached() {
                run_test(0.into(), false, |_service, _storage_balance| {});
            }

            #[test]
            fn zero_deposit_attached_already_registered() {
                run_test(0.into(), true, |service, storage_balance| {
                    let storage_balance_bounds = service.storage_balance_bounds();
                    assert_eq!(storage_balance.total, storage_balance_bounds.min);
                    assert_eq!(storage_balance.available, 0.into());
                });
            }

            #[test]
            fn one_deposit_attached_already_registered() {
                run_test(1.into(), true, |service, storage_balance| {
                    let storage_balance_bounds = service.storage_balance_bounds();
                    assert_eq!(
                        storage_balance.total.value(),
                        storage_balance_bounds.min.value() + 1
                    );
                    assert_eq!(storage_balance.available, 1.into());

                    // Assert account NEAR balance was persisted
                    let storage_balance_2 = service
                        .storage_balance_of(to_valid_account_id(ACCOUNT_ID))
                        .unwrap();
                    assert_eq!(storage_balance, storage_balance_2);
                });
            }
        }

        #[cfg(test)]
        mod self_deposit_with_registration_only_false {
            use super::*;

            fn run_test<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    STORAGE_USAGE_BOUNDS,
                    None,
                    Some(false),
                    deposit,
                    already_registered,
                    test,
                );
            }

            #[test]
            fn unknown_account_with_exact_storage_deposit() {
                run_test(
                    storage_balance_min(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment() {
                let deposit_amount: YoctoNear = (storage_balance_min().value() * 3).into();
                run_test(
                    deposit_amount,
                    false,
                    |service, storage_balance: StorageBalance| {
                        // Assert
                        assert_eq!(storage_balance.total, deposit_amount);
                        assert_eq!(
                            storage_balance.available,
                            (service.storage_balance_bounds().min.value() * 2).into()
                        );

                        // Assert account was registered
                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        assert_eq!(account.near_balance(), deposit_amount);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn already_registered() {
                run_test(
                    storage_balance_min(),
                    true,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(
                            storage_balance.total.value(),
                            service.storage_balance_bounds().min.value() * 2
                        );
                        assert_eq!(
                            storage_balance.available,
                            service.storage_balance_bounds().min
                        );

                        let account = service.registered_account_near_data(PREDECESSOR_ACCOUNT_ID);
                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached() {
                run_test(0.into(), false, |_service, _storage_balance| {});
            }

            #[test]
            fn zero_deposit_attached_already_registered() {
                run_test(0.into(), true, |service, storage_balance| {
                    let storage_balance_bounds = service.storage_balance_bounds();
                    assert_eq!(storage_balance.total, storage_balance_bounds.min);
                    assert_eq!(storage_balance.available, 0.into());
                });
            }

            #[test]
            fn one_deposit_attached_already_registered() {
                run_test(1.into(), true, |service, storage_balance| {
                    let storage_balance_bounds = service.storage_balance_bounds();
                    assert_eq!(
                        storage_balance.total.value(),
                        storage_balance_bounds.min.value() + 1
                    );
                    assert_eq!(storage_balance.available, 1.into());
                });
            }
        }

        #[cfg(test)]
        mod deposit_for_other_with_registration_only_false {
            use super::*;

            const ACCOUNT_ID: &str = "alfio.near";

            fn run_test<F>(
                deposit: YoctoNear,
                already_registered: bool, // if true, then the account ID will be registered before hand using storage balance min
                test: F,
            ) where
                F: FnOnce(AccountManagementComponent<()>, StorageBalance),
            {
                super::run_test(
                    STORAGE_USAGE_BOUNDS,
                    Some(ACCOUNT_ID),
                    Some(false),
                    deposit,
                    already_registered,
                    test,
                );
            }

            #[test]
            fn unknown_account_with_exact_storage_deposit() {
                run_test(
                    storage_balance_min(),
                    false,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(storage_balance.total, service.storage_balance_bounds().min);
                        assert_eq!(storage_balance.available, 0.into());

                        let account = service.registered_account_near_data(ACCOUNT_ID);
                        assert_eq!(account.near_balance(), service.storage_balance_bounds().min);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn unknown_account_with_over_payment() {
                let deposit_amount: YoctoNear = (storage_balance_min().value() * 3).into();
                run_test(
                    deposit_amount,
                    false,
                    |service, storage_balance: StorageBalance| {
                        // Assert
                        assert_eq!(storage_balance.total, deposit_amount);
                        assert_eq!(
                            storage_balance.available,
                            (service.storage_balance_bounds().min.value() * 2).into()
                        );

                        // Assert account was registered
                        let account = service.registered_account_near_data(ACCOUNT_ID);
                        assert_eq!(account.near_balance(), deposit_amount);

                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            fn already_registered() {
                run_test(
                    storage_balance_min(),
                    true,
                    |service, storage_balance: StorageBalance| {
                        assert_eq!(
                            storage_balance.total.value(),
                            service.storage_balance_bounds().min.value() * 2
                        );
                        assert_eq!(
                            storage_balance.available,
                            service.storage_balance_bounds().min
                        );

                        let account = service.registered_account_near_data(ACCOUNT_ID);
                        // AccountStorageEvent:Registered event should have been published to update stats
                        let account_stats = AccountManager::account_metrics();
                        assert_eq!(account_stats.total_registered_accounts, 1.into());
                        assert_eq!(account_stats.total_near_balance, account.near_balance());
                    },
                );
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT]")]
            fn zero_deposit_attached() {
                run_test(0.into(), false, |_service, _storage_balance| {});
            }

            #[test]
            fn zero_deposit_attached_already_registered() {
                run_test(0.into(), true, |service, storage_balance| {
                    let storage_balance_bounds = service.storage_balance_bounds();
                    assert_eq!(storage_balance.total, storage_balance_bounds.min);
                    assert_eq!(storage_balance.available, 0.into());
                });
            }

            #[test]
            fn one_deposit_attached_already_registered() {
                run_test(1.into(), true, |service, storage_balance| {
                    let storage_balance_bounds = service.storage_balance_bounds();
                    assert_eq!(
                        storage_balance.total.value(),
                        storage_balance_bounds.min.value() + 1
                    );
                    assert_eq!(storage_balance.available, 1.into());
                });
            }
        }
    }

    #[cfg(test)]
    mod test_storage_withdraw {
        use super::*;

        pub type AccountManager = AccountManagementComponent<()>;

        fn run_test<F>(
            storage_usage_bounds: StorageUsageBounds,
            deposit: YoctoNear,
            withdraw_deposit: YoctoNear,
            withdrawal: Option<YoctoNear>,
            test: F,
        ) where
            F: FnOnce(AccountManagementComponent<()>, StorageBalance),
        {
            let mut ctx = new_context(PREDECESSOR_ACCOUNT_ID);
            testing_env!(ctx.clone());

            AccountMetrics::register_account_storage_event_handler();
            AccountMetrics::reset();

            AccountStorageUsageComponent::deploy(storage_usage_bounds);

            let mut service: AccountManagementComponent<()> =
                AccountManagementComponent::new(Default::default());

            if deposit.value() > 0 {
                ctx.attached_deposit = deposit.value();
                testing_env!(ctx.clone());
                service.storage_deposit(None, None);
            }

            ctx.attached_deposit = withdraw_deposit.value();
            testing_env!(ctx.clone());
            let storage_balance = service.storage_withdraw(withdrawal);
            test(service, storage_balance);
        }

        #[test]
        fn withdraw_amount_success() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                storage_balance_min() * 2,
                1.into(),
                Some(storage_balance_min() / 2),
                |service, storage_balance| {
                    assert_eq!(
                        storage_balance.total,
                        storage_balance_min() + (storage_balance_min() / 2).value()
                    );
                    assert_eq!(storage_balance.available, storage_balance_min() / 2);

                    // Assert account NEAR balance was persisted
                    let storage_balance_2 = service
                        .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                        .unwrap();
                    assert_eq!(storage_balance, storage_balance_2);

                    // check refund was sent
                    let receipts = deserialize_receipts();
                    let receipt = &receipts[0];
                    assert_eq!(&receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                    let action = &receipt.actions[0];
                    match action {
                        Action::Transfer(transfer) => {
                            assert_eq!(transfer.deposit, storage_balance_min().value() / 2 + 1);
                        }
                        _ => panic!("expected TransferAction"),
                    }

                    // check account stats
                    let stats = AccountManager::account_metrics();
                    assert_eq!(stats.total_near_balance, storage_balance.total);
                },
            );
        }

        #[test]
        fn withdraw_all_available_balance_success() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                storage_balance_min() * 2,
                1.into(),
                None,
                |service, storage_balance| {
                    assert_eq!(storage_balance.total, storage_balance_min());
                    assert_eq!(storage_balance.available, 0.into());

                    // Assert account NEAR balance was persisted
                    let storage_balance_2 = service
                        .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                        .unwrap();
                    assert_eq!(storage_balance, storage_balance_2);

                    // check refund was sent
                    let receipts = deserialize_receipts();
                    let receipt = &receipts[0];
                    assert_eq!(&receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                    let action = &receipt.actions[0];
                    match action {
                        Action::Transfer(transfer) => {
                            assert_eq!(transfer.deposit, storage_balance_min().value() + 1);
                        }
                        _ => panic!("expected TransferAction"),
                    }

                    // check account stats
                    let stats = AccountManager::account_metrics();
                    assert_eq!(stats.total_near_balance, storage_balance.total);
                },
            );
        }

        #[test]
        fn withdraw_zero() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                storage_balance_min() * 2,
                1.into(),
                Some(0.into()),
                |service, storage_balance| {
                    assert_eq!(storage_balance.total, storage_balance_min() * 2);
                    assert_eq!(storage_balance.available, storage_balance_min());

                    // Assert account NEAR balance was persisted
                    let storage_balance_2 = service
                        .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                        .unwrap();
                    assert_eq!(storage_balance, storage_balance_2);

                    // check refund was sent
                    let receipts = deserialize_receipts();
                    assert!(receipts.is_empty());

                    // check account stats
                    let stats = AccountManager::account_metrics();
                    assert_eq!(stats.total_near_balance, storage_balance.total);
                },
            );
        }

        #[test]
        #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
        fn no_attached_deposit() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                storage_balance_min() * 2,
                0.into(),
                Some(0.into()),
                |_service, _storage_balance| {},
            );
        }

        #[test]
        #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
        fn two_yoctonear_attached() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                storage_balance_min() * 2,
                2.into(),
                Some(0.into()),
                |_service, _storage_balance| {},
            );
        }

        #[test]
        #[should_panic(expected = "[ERR] [INSUFFICIENT_STORAGE_BALANCE]")]
        fn insufficient_funds() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                storage_balance_min(),
                1.into(),
                Some(1.into()),
                |_service, _storage_balance| {},
            );
        }

        #[test]
        #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
        fn account_not_registered() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                0.into(),
                1.into(),
                Some(0.into()),
                |_service, _storage_balance| {},
            );
        }
    }

    #[cfg(test)]
    mod test_storage_unregister_with_default_unregister_delegate {
        use super::*;

        pub type AccountManager = AccountManagementComponent<()>;

        fn run_test<F>(
            storage_usage_bounds: StorageUsageBounds,
            deposit: YoctoNear,
            unregister_deposit: YoctoNear,
            force: Option<bool>,
            test: F,
        ) where
            F: FnOnce(AccountManagementComponent<()>, bool),
        {
            let mut ctx = new_context(PREDECESSOR_ACCOUNT_ID);
            testing_env!(ctx.clone());

            AccountMetrics::register_account_storage_event_handler();
            AccountMetrics::reset();
            StorageManagementEvent::clear_event_handlers();

            AccountStorageUsageComponent::deploy(storage_usage_bounds);

            let mut service: AccountManagementComponent<()> =
                AccountManagementComponent::new(Default::default());

            if deposit.value() > 0 {
                ctx.attached_deposit = deposit.value();
                testing_env!(ctx.clone());
                service.storage_deposit(None, None);
            }

            ctx.attached_deposit = unregister_deposit.value();
            testing_env!(ctx.clone());
            StorageManagementEvent::clear_event_handlers();
            let result = service.storage_unregister(force);
            test(service, result);
        }

        #[test]
        fn unregister_force_none_success() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                storage_balance_min() * 2,
                1.into(),
                None,
                |service, unregistered| {
                    assert!(unregistered);

                    // Assert account NEAR balance was persisted
                    let storage_balance =
                        service.storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID));
                    assert!(storage_balance.is_none());

                    // check refund was sent
                    let receipts = deserialize_receipts();
                    let receipt = &receipts[0];
                    assert_eq!(&receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                    let action = &receipt.actions[0];
                    match action {
                        Action::Transfer(transfer) => {
                            assert_eq!(transfer.deposit, storage_balance_min().value() * 2 + 1);
                        }
                        _ => panic!("expected TransferAction"),
                    }

                    // check account stats
                    let stats = AccountManager::account_metrics();
                    assert_eq!(stats.total_registered_accounts, 0.into());
                    assert_eq!(stats.total_near_balance, 0.into());
                    assert_eq!(stats.total_storage_usage, 0.into());

                    assert!(service
                        .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                        .is_none());
                },
            );
        }

        #[test]
        fn unregister_force_success() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                storage_balance_min() * 2,
                1.into(),
                Some(true),
                |service, unregistered| {
                    assert!(unregistered);

                    // Assert account NEAR balance was persisted
                    let storage_balance =
                        service.storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID));
                    assert!(storage_balance.is_none());

                    // check refund was sent
                    let receipts = deserialize_receipts();
                    let receipt = &receipts[0];
                    assert_eq!(&receipt.receiver_id, PREDECESSOR_ACCOUNT_ID);
                    let action = &receipt.actions[0];
                    match action {
                        Action::Transfer(transfer) => {
                            assert_eq!(transfer.deposit, storage_balance_min().value() * 2 + 1);
                        }
                        _ => panic!("expected TransferAction"),
                    }

                    // check account stats
                    let stats = AccountManager::account_metrics();
                    assert_eq!(stats.total_registered_accounts, 0.into());
                    assert_eq!(stats.total_near_balance, 0.into());
                    assert_eq!(stats.total_storage_usage, 0.into());

                    assert!(service
                        .storage_balance_of(to_valid_account_id(PREDECESSOR_ACCOUNT_ID))
                        .is_none());
                },
            );
        }

        #[test]
        #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
        fn no_attached_deposit() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                storage_balance_min() * 2,
                0.into(),
                None,
                |_service, _storage_balance| {},
            );
        }

        #[test]
        #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
        fn two_yoctonear_attached() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                storage_balance_min() * 2,
                2.into(),
                None,
                |_service, _storage_balance| {},
            );
        }

        #[test]
        fn account_not_registered() {
            run_test(
                STORAGE_USAGE_BOUNDS,
                0.into(),
                1.into(),
                None,
                |_service, unregistered| assert!(!unregistered),
            );
        }
    }

    #[cfg(test)]
    mod test_storage_unregister {
        use super::*;
        use oysterpack_smart_near::YOCTO;

        pub type AccountManager = AccountManagementComponent<()>;

        fn on_unregister_panic(event: &StorageManagementEvent) {
            match event {
                StorageManagementEvent::PreUnregister { force, .. } => {
                    println!("force = {}", force);
                    ERR_CODE_UNREGISTER_FAILURE.assert(|| *force, || "BOOM");
                }
                _ => {}
            }
        }

        #[test]
        #[should_panic(expected = "[ERR] [UNREGISTER_FAILURE]")]
        fn unregister_panics() {
            // Arrange
            let account = "alfio";
            let mut ctx = new_context(account);
            testing_env!(ctx.clone());

            AccountManager::deploy(AccountManagementComponentConfig {
                admin_account: to_valid_account_id("admin"),
                storage_usage_bounds: Some(StorageUsageBounds {
                    min: 1000.into(),
                    max: None,
                }),
                component_account_storage_mins: None,
            });

            let mut service = AccountManager::new(Default::default());
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            service.storage_deposit(None, None);

            // Act
            ctx.attached_deposit = 1;
            testing_env!(ctx.clone());
            eventbus::register(on_unregister_panic);
            service.storage_unregister(None);
        }

        #[test]
        fn force_unregister_panics() {
            // Arrange
            let account = "alfio";
            let mut ctx = new_context(account);
            testing_env!(ctx.clone());

            AccountManager::deploy(AccountManagementComponentConfig {
                storage_usage_bounds: Some(StorageUsageBounds {
                    min: 1000.into(),
                    max: None,
                }),
                admin_account: to_valid_account_id("admin"),
                component_account_storage_mins: None,
            });
            eventbus::register(on_unregister_panic);

            let mut service = AccountManager::new(Default::default());
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            service.storage_deposit(None, None);

            // Act
            ctx.attached_deposit = 1;
            testing_env!(ctx.clone());
            service.storage_unregister(Some(true));
            assert!(service
                .storage_balance_of(to_valid_account_id(account))
                .is_none());
        }
    }
}

#[cfg(test)]
mod tests_account_storage_usage {
    use super::*;
    use oysterpack_smart_near::near_sdk;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    type AccountManager = AccountManagementComponent<()>;

    #[test]
    fn test() {
        let account = "alfio";
        let mut ctx = new_context(account);
        testing_env!(ctx.clone());

        let storage_usage_bounds = StorageUsageBounds {
            min: AccountManager::measure_storage_usage(()),
            max: None,
        };
        println!("measured storage_usage_bounds = {:?}", storage_usage_bounds);
        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: Some(storage_usage_bounds),
            admin_account: to_valid_account_id("admin"),
            component_account_storage_mins: None,
        });

        let mut service = AccountManager::new(Default::default());
        assert_eq!(storage_usage_bounds, service.ops_storage_usage_bounds());

        assert!(service
            .storage_balance_of(to_valid_account_id(account))
            .is_none());

        ctx.attached_deposit = YOCTO;
        testing_env!(ctx.clone());
        let storage_balance = service.storage_deposit(None, None);
        assert_eq!(
            service
                .storage_balance_of(to_valid_account_id(account))
                .unwrap(),
            storage_balance
        );
        let storage_usage = service
            .ops_storage_usage(to_valid_account_id(account))
            .unwrap();
        assert_eq!(
            storage_usage,
            service
                .registered_account_near_data(account)
                .storage_usage()
        );
    }
}

#[cfg(test)]
mod tests_account_metrics {
    use super::*;
    use oysterpack_smart_near::near_sdk::{self, test_utils};
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    type AccountManager = AccountManagementComponent<()>;

    #[test]
    fn test() {
        StorageManagementEvent::clear_event_handlers();
        // Arrange - 0 accounts register
        let account = "alfio";
        let mut ctx = new_context(account);
        testing_env!(ctx.clone());

        let metrics = AccountManager::account_metrics();
        println!("{:?}", metrics);
        let storage_usage_bounds = StorageUsageBounds {
            min: AccountManager::measure_storage_usage(()),
            max: None,
        };
        let metrics = AccountManager::account_metrics();
        println!("{:?}", metrics);
        println!("measured storage_usage_bounds = {:?}", storage_usage_bounds);

        let metrics = AccountManager::account_metrics();
        println!("before deploy: {:?}", metrics);
        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: Some(storage_usage_bounds),
            admin_account: to_valid_account_id("admin"),
            component_account_storage_mins: None,
        });
        let metrics = AccountManager::account_metrics();
        println!("after deploy: {:?}", metrics);
        println!("{:#?}", test_utils::get_logs());

        let mut service = AccountManager::new(Default::default());
        let admin_account = service.registered_account_near_data("admin");
        // Act
        let metrics = AccountManager::account_metrics();
        println!("{:?}", metrics);
        // Assert
        assert_eq!(metrics.total_registered_accounts.value(), 1);
        assert_eq!(metrics.total_near_balance, admin_account.near_balance());
        assert_eq!(metrics.total_storage_usage, admin_account.storage_usage());

        // Arrange - register account
        ctx.attached_deposit = YOCTO;
        testing_env!(ctx.clone());
        let storage_balance = service.storage_deposit(None, None);
        let account_data = service.load_account_data(account);
        assert!(account_data.is_none());
        let mut account_data: AccountDataObject<()> = AccountDataObject::new(account, ());
        account_data.save();
        let mut account_near_data = service.registered_account_near_data(account);
        account_near_data.grant_operator();
        account_near_data.save();

        // Act
        let metrics = AccountManager::account_metrics();
        // Assert
        assert_eq!(metrics.total_registered_accounts.value(), 2);
        assert_eq!(
            metrics.total_near_balance,
            storage_balance.total + admin_account.near_balance()
        );
        assert_eq!(
            metrics.total_storage_usage,
            storage_usage_bounds.min + admin_account.storage_usage()
        );

        // Arrange - deposit more funds
        ctx.attached_deposit = YOCTO;
        testing_env!(ctx.clone());
        let storage_balance = service.storage_deposit(None, None);
        // Act
        let metrics = AccountManager::account_metrics();
        // Assert
        assert_eq!(metrics.total_registered_accounts.value(), 2);
        assert_eq!(
            metrics.total_near_balance,
            storage_balance.total + admin_account.near_balance()
        );
        assert_eq!(
            metrics.total_storage_usage,
            storage_usage_bounds.min + admin_account.storage_usage()
        );

        // Arrange - register another account
        ctx.attached_deposit = YOCTO;
        testing_env!(ctx.clone());
        let bob_storage_balance = service.storage_deposit(Some(to_valid_account_id("bob")), None);
        let mut account_data: AccountDataObject<()> = AccountDataObject::new("bob", ());
        account_data.save();
        let mut account_near_data = service.registered_account_near_data("bob");
        account_near_data.grant_operator();
        account_near_data.save();
        // Act
        let metrics = AccountManager::account_metrics();
        // Assert
        assert_eq!(metrics.total_registered_accounts.value(), 3);
        assert_eq!(
            metrics.total_near_balance,
            storage_balance.total + bob_storage_balance.total + admin_account.near_balance()
        );
        assert_eq!(
            metrics.total_storage_usage.value(),
            (storage_usage_bounds.min.value() * 2) + admin_account.storage_usage().value()
        );

        // Arrange - unregister account
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        StorageManagementEvent::clear_event_handlers();
        service.storage_unregister(None);
        // Act
        let metrics = AccountManager::account_metrics();
        // Assert
        assert_eq!(metrics.total_registered_accounts.value(), 2);
        assert_eq!(
            metrics.total_near_balance,
            bob_storage_balance.total + admin_account.near_balance()
        );
        assert_eq!(
            metrics.total_storage_usage,
            storage_usage_bounds.min + admin_account.storage_usage()
        );
    }
}

#[cfg(test)]
mod test_permission_management {
    use super::*;
    use oysterpack_smart_near::near_sdk;
    use oysterpack_smart_near::near_sdk::{test_utils, VMContext};
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;
    use std::convert::TryInto;

    type AccountManager = AccountManagementComponent<()>;

    const PREDECESSOR_ACCOUNT: &str = "predecessor";

    const PERM_0: u64 = 1 << 0;
    const PERM_1: u64 = 1 << 1;
    const PERMISSIONS: [(u8, &'static str); 2] = [(0, "perm_0"), (1, "perm_1")];

    fn permissions() -> ContractPermissions {
        let perms: Vec<(u8, &'static str)> = PERMISSIONS.try_into().unwrap();
        perms.into()
    }

    /// if admin is true, then the predecessor account is granted admin permission.
    fn test<F>(admin: bool, permissions: ContractPermissions, f: F)
    where
        F: FnOnce(VMContext, AccountManager),
    {
        let mut ctx = new_context(PREDECESSOR_ACCOUNT);
        ctx.predecessor_account_id = PREDECESSOR_ACCOUNT.to_string();
        testing_env!(ctx.clone());

        let storage_usage_bounds = StorageUsageBounds {
            min: AccountManager::measure_storage_usage(()),
            max: None,
        };
        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: Some(storage_usage_bounds),
            admin_account: to_valid_account_id("admin"),
            component_account_storage_mins: None,
        });

        let mut account_manager = AccountManager::new(permissions);

        {
            let mut ctx = ctx.clone();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx);
            account_manager.storage_deposit(None, None);
        }

        if admin {
            let mut account = account_manager.registered_account_near_data(PREDECESSOR_ACCOUNT);
            account.grant_admin();
            account.save();
        }

        f(ctx, account_manager);
    }

    #[cfg(test)]
    mod as_admin {
        use super::*;

        #[cfg(test)]
        mod ops_permissions_is_admin {
            use super::*;

            #[test]
            fn basic_grants_revokes() {
                test(true, permissions(), |mut ctx, mut account_manager| {
                    // Arrange
                    let bob = "bob";
                    ctx.predecessor_account_id = bob.to_string();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, None);

                    ctx.predecessor_account_id = PREDECESSOR_ACCOUNT.to_string();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());

                    // account with admin permission implies all permissions
                    assert!(account_manager
                        .ops_permissions_is_operator(to_valid_account_id(PREDECESSOR_ACCOUNT)));
                    assert!(account_manager.ops_permissions_contains(
                        to_valid_account_id(PREDECESSOR_ACCOUNT),
                        PERM_0.into()
                    ));
                    let accounts_perms = account_manager
                        .ops_permissions_granted(to_valid_account_id(PREDECESSOR_ACCOUNT))
                        .unwrap();
                    assert_eq!(accounts_perms.len(), 1);
                    assert_eq!(accounts_perms.get(&63).unwrap(), "admin");

                    // grant admin
                    account_manager.ops_permissions_grant_admin(to_valid_account_id(bob));
                    assert!(account_manager.ops_permissions_is_admin(to_valid_account_id(bob)));
                    assert!(account_manager.ops_permissions_is_operator(to_valid_account_id(bob)));
                    assert!(account_manager
                        .ops_permissions_contains(to_valid_account_id(bob), PERM_0.into()));

                    // revoke admin
                    account_manager.ops_permissions_revoke_admin(to_valid_account_id(bob));
                    assert!(!account_manager.ops_permissions_is_admin(to_valid_account_id(bob)));
                    assert!(!account_manager.ops_permissions_is_operator(to_valid_account_id(bob)));
                    let accounts_perms =
                        account_manager.ops_permissions_granted(to_valid_account_id(bob));
                    println!("accounts_perms = {:?}", accounts_perms);
                    assert!(accounts_perms.is_none());

                    // grant operator
                    account_manager.ops_permissions_grant_operator(to_valid_account_id(bob));
                    assert!(account_manager.ops_permissions_is_operator(to_valid_account_id(bob)));
                    assert!(!account_manager.ops_permissions_is_admin(to_valid_account_id(bob)));
                    let accounts_perms = account_manager
                        .ops_permissions_granted(to_valid_account_id(bob))
                        .unwrap();
                    assert_eq!(accounts_perms.len(), 1);
                    assert_eq!(accounts_perms.get(&62).unwrap(), "operator");

                    // revoke operator
                    account_manager.ops_permissions_revoke_operator(to_valid_account_id(bob));
                    assert!(!account_manager.ops_permissions_is_operator(to_valid_account_id(bob)));

                    // grant permissions
                    account_manager
                        .ops_permissions_grant(to_valid_account_id(bob), (PERM_0 | PERM_1).into());
                    assert!(account_manager
                        .ops_permissions_contains(to_valid_account_id(bob), PERM_0.into()));
                    assert!(account_manager
                        .ops_permissions_contains(to_valid_account_id(bob), PERM_1.into()));
                    assert!(account_manager.ops_permissions_contains(
                        to_valid_account_id(bob),
                        (PERM_0 | PERM_1).into()
                    ));
                    let accounts_perms = account_manager
                        .ops_permissions_granted(to_valid_account_id(bob))
                        .unwrap();
                    assert_eq!(accounts_perms.len(), 2);
                    assert_eq!(accounts_perms.get(&0).unwrap(), "perm_0");
                    assert_eq!(accounts_perms.get(&1).unwrap(), "perm_1");

                    // revoke permissions
                    account_manager.ops_permissions_revoke(to_valid_account_id(bob), PERM_0.into());
                    assert!(!account_manager
                        .ops_permissions_contains(to_valid_account_id(bob), PERM_0.into()));
                    assert!(account_manager
                        .ops_permissions_contains(to_valid_account_id(bob), PERM_1.into()));
                    assert!(!account_manager.ops_permissions_contains(
                        to_valid_account_id(bob),
                        (PERM_0 | PERM_1).into()
                    ));

                    account_manager.ops_permissions_revoke(to_valid_account_id(bob), PERM_1.into());
                    assert!(!account_manager
                        .ops_permissions_contains(to_valid_account_id(bob), PERM_0.into()));
                    assert!(!account_manager
                        .ops_permissions_contains(to_valid_account_id(bob), PERM_1.into()));
                    assert!(!account_manager.ops_permissions_contains(
                        to_valid_account_id(bob),
                        (PERM_0 | PERM_1).into()
                    ));

                    // grant permissions
                    account_manager
                        .ops_permissions_grant(to_valid_account_id(bob), (PERM_0 | PERM_1).into());
                    account_manager.ops_permissions_grant_operator(to_valid_account_id(bob));
                    assert!(account_manager
                        .ops_permissions_contains(to_valid_account_id(bob), PERM_0.into()));
                    assert!(account_manager
                        .ops_permissions_contains(to_valid_account_id(bob), PERM_1.into()));
                    assert!(account_manager.ops_permissions_contains(
                        to_valid_account_id(bob),
                        (PERM_0 | PERM_1).into()
                    ));
                    assert!(account_manager.ops_permissions_is_operator(to_valid_account_id(bob)));
                    let accounts_perms = account_manager
                        .ops_permissions_granted(to_valid_account_id(bob))
                        .unwrap();
                    assert_eq!(accounts_perms.len(), 3);
                    assert_eq!(accounts_perms.get(&0).unwrap(), "perm_0");
                    assert_eq!(accounts_perms.get(&1).unwrap(), "perm_1");
                    assert_eq!(accounts_perms.get(&62).unwrap(), "operator");

                    // revoke all permissions
                    account_manager.ops_permissions_revoke_all(to_valid_account_id(bob));
                    assert!(account_manager
                        .ops_permissions(to_valid_account_id(bob))
                        .is_none());
                    assert!(account_manager
                        .ops_permissions_granted(to_valid_account_id(bob))
                        .is_none());

                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                });
            }

            #[test]
            fn account_not_registered() {
                test(true, Default::default(), |_ctx, account_manager| {
                    assert!(!account_manager.ops_permissions_is_admin(to_valid_account_id("bob")));
                    assert!(
                        !account_manager.ops_permissions_is_operator(to_valid_account_id("bob"))
                    );
                    assert!(!account_manager
                        .ops_permissions_contains(to_valid_account_id("bob"), (1 << 10).into()));
                    assert!(account_manager
                        .ops_permissions(to_valid_account_id("bob"))
                        .is_none());
                });
            }

            #[cfg(test)]
            mod grant_to_self {
                use super::*;

                #[test]
                #[should_panic(
                    expected = "[ERR] [INVALID] `account_id` cannot be the same as the predecessor account ID"
                )]
                fn grant_admin_to_self() {
                    test(true, Default::default(), |_ctx, mut account_manager| {
                        account_manager
                            .ops_permissions_grant_admin(to_valid_account_id(PREDECESSOR_ACCOUNT));
                    });
                }

                #[test]
                #[should_panic(
                    expected = "[ERR] [INVALID] `account_id` cannot be the same as the predecessor account ID"
                )]
                fn grant_operator_to_self() {
                    test(true, Default::default(), |_ctx, mut account_manager| {
                        account_manager.ops_permissions_grant_operator(to_valid_account_id(
                            PREDECESSOR_ACCOUNT,
                        ));
                    });
                }

                #[test]
                #[should_panic(
                    expected = "[ERR] [INVALID] `account_id` cannot be the same as the predecessor account ID"
                )]
                fn grant_to_self() {
                    test(true, permissions(), |_ctx, mut account_manager| {
                        account_manager.ops_permissions_grant(
                            to_valid_account_id(PREDECESSOR_ACCOUNT),
                            PERM_0.into(),
                        );
                    });
                }

                #[test]
                #[should_panic(
                    expected = "[ERR] [INVALID] `account_id` cannot be the same as the predecessor account ID"
                )]
                fn revoke_admin_to_self() {
                    test(true, Default::default(), |_ctx, mut account_manager| {
                        account_manager
                            .ops_permissions_revoke_admin(to_valid_account_id(PREDECESSOR_ACCOUNT));
                    });
                }

                #[test]
                #[should_panic(
                    expected = "[ERR] [INVALID] `account_id` cannot be the same as the predecessor account ID"
                )]
                fn revoke_operator_to_self() {
                    test(true, Default::default(), |_ctx, mut account_manager| {
                        account_manager.ops_permissions_revoke_operator(to_valid_account_id(
                            PREDECESSOR_ACCOUNT,
                        ));
                    });
                }

                #[test]
                #[should_panic(
                    expected = "[ERR] [INVALID] `account_id` cannot be the same as the predecessor account ID"
                )]
                fn revoke_to_self() {
                    test(true, permissions(), |_ctx, mut account_manager| {
                        account_manager.ops_permissions_revoke(
                            to_valid_account_id(PREDECESSOR_ACCOUNT),
                            PERM_0.into(),
                        );
                    });
                }

                #[test]
                #[should_panic(
                    expected = "[ERR] [INVALID] `account_id` cannot be the same as the predecessor account ID"
                )]
                fn revoke_all_to_self() {
                    test(true, permissions(), |_ctx, mut account_manager| {
                        account_manager
                            .ops_permissions_revoke_all(to_valid_account_id(PREDECESSOR_ACCOUNT));
                    });
                }
            }

            #[cfg(test)]
            mod test_log_events {
                use super::*;

                #[test]
                fn grant_revoke_admin() {
                    test(true, permissions(), |ctx, mut account_manager| {
                        // Arrange
                        let bob = "bob";
                        {
                            // register account
                            let mut ctx = ctx.clone();
                            ctx.attached_deposit = YOCTO;
                            testing_env!(ctx.clone());
                            account_manager
                                .storage_deposit(Some(to_valid_account_id(bob)), Some(true));
                        }

                        // Act - grant
                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_grant_admin(to_valid_account_id(bob));
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs.len(), 2);
                        assert_eq!(
                            &logs[0],
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(8)"
                        );
                        assert_eq!(&logs[1], "[INFO] [PERMISSIONS_GRANT] admin");

                        // Act - grant admin again to user should have no effect
                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_grant_admin(to_valid_account_id(bob));
                        let logs = test_utils::get_logs();
                        assert!(logs.is_empty());

                        // Act - revoke
                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_revoke_admin(to_valid_account_id(bob));
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs.len(), 2);
                        assert_eq!(
                            &logs[0],
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-8)"
                        );
                        assert_eq!(&logs[1], "[INFO] [PERMISSIONS_REVOKE] admin");

                        // Act - revoke again
                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_revoke_admin(to_valid_account_id(bob));
                        let logs = test_utils::get_logs();
                        assert!(logs.is_empty());
                    });
                }

                #[test]
                fn grant_revoke_operator() {
                    test(true, permissions(), |ctx, mut account_manager| {
                        // Arrange
                        let bob = "bob";
                        {
                            // register account
                            let mut ctx = ctx.clone();
                            ctx.attached_deposit = YOCTO;
                            testing_env!(ctx.clone());
                            account_manager
                                .storage_deposit(Some(to_valid_account_id(bob)), Some(true));
                        }

                        // Act - grant
                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_grant_operator(to_valid_account_id(bob));
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs.len(), 2);
                        assert_eq!(
                            &logs[0],
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(8)"
                        );
                        assert_eq!(&logs[1], "[INFO] [PERMISSIONS_GRANT] operator");

                        // Act - grant admin again to user should have no effect
                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_grant_operator(to_valid_account_id(bob));
                        let logs = test_utils::get_logs();
                        assert!(logs.is_empty());

                        // Act - revoke
                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_revoke_operator(to_valid_account_id(bob));
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs.len(), 2);
                        assert_eq!(
                            &logs[0],
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-8)"
                        );
                        assert_eq!(&logs[1], "[INFO] [PERMISSIONS_REVOKE] operator");

                        // Act - revoke again
                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_revoke_operator(to_valid_account_id(bob));
                        let logs = test_utils::get_logs();
                        assert!(logs.is_empty());
                    });
                }

                #[test]
                fn grant_revoke_contract_permissions() {
                    test(true, permissions(), |ctx, mut account_manager| {
                        // Arrange
                        let bob = "bob";
                        {
                            // register account
                            let mut ctx = ctx.clone();
                            ctx.attached_deposit = YOCTO;
                            testing_env!(ctx.clone());
                            account_manager
                                .storage_deposit(Some(to_valid_account_id(bob)), Some(true));
                        }

                        // Act - grant
                        testing_env!(ctx.clone());
                        account_manager
                            .ops_permissions_grant(to_valid_account_id(bob), PERM_0.into());
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs.len(), 2);
                        assert_eq!(
                            &logs[0],
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(8)"
                        );
                        assert_eq!(&logs[1], "[INFO] [PERMISSIONS_GRANT] [\"perm_0\"]");

                        // Act - grant admin again to user should have no effect
                        testing_env!(ctx.clone());
                        account_manager
                            .ops_permissions_grant(to_valid_account_id(bob), PERM_0.into());
                        let logs = test_utils::get_logs();
                        assert!(logs.is_empty());

                        testing_env!(ctx.clone());
                        account_manager
                            .ops_permissions_grant(to_valid_account_id(bob), PERM_1.into());
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs.len(), 1);
                        assert_eq!(&logs[0], "[INFO] [PERMISSIONS_GRANT] [\"perm_1\"]");

                        // Act - revoke
                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_revoke(
                            to_valid_account_id(bob),
                            (PERM_0 | PERM_1).into(),
                        );
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs.len(), 2);
                        assert_eq!(
                            &logs[0],
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-8)"
                        );
                        assert_eq!(
                            &logs[1],
                            "[INFO] [PERMISSIONS_REVOKE] [\"perm_0\", \"perm_1\"]"
                        );

                        // Act - revoke again
                        testing_env!(ctx.clone());
                        account_manager
                            .ops_permissions_revoke(to_valid_account_id(bob), PERM_0.into());
                        let logs = test_utils::get_logs();
                        assert!(logs.is_empty());

                        // Act - grant
                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_grant(
                            to_valid_account_id(bob),
                            (PERM_0 | PERM_1).into(),
                        );

                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_revoke_all(to_valid_account_id(bob));
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs.len(), 2);
                        assert_eq!(
                            &logs[0],
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-8)"
                        );
                        assert_eq!(
                            &logs[1],
                            "[INFO] [PERMISSIONS_REVOKE] all permissions were revoked"
                        );

                        testing_env!(ctx.clone());
                        account_manager.ops_permissions_grant_permissions(
                            to_valid_account_id(bob),
                            vec![0, 1],
                        );
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs.len(), 2);
                        assert_eq!(
                            &logs[1],
                            "[INFO] [PERMISSIONS_GRANT] [\"perm_0\", \"perm_1\"]"
                        );

                        account_manager.ops_permissions_revoke_permissions(
                            to_valid_account_id(bob),
                            vec![0, 1],
                        );
                        assert!(account_manager
                            .ops_permissions(to_valid_account_id(bob))
                            .is_none());
                    });
                }
            }
        }
    }

    #[cfg(test)]
    mod not_as_admin {
        use super::*;

        #[test]
        #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
        fn grant_admin() {
            test(false, Default::default(), |_ctx, mut account_manager| {
                account_manager.ops_permissions_grant_admin(to_valid_account_id("bob"));
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
        fn grant_operator() {
            test(false, Default::default(), |_ctx, mut account_manager| {
                account_manager.ops_permissions_grant_operator(to_valid_account_id("bob"));
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
        fn grant() {
            test(false, permissions(), |_ctx, mut account_manager| {
                account_manager.ops_permissions_grant(to_valid_account_id("bob"), (1 << 1).into());
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
        fn revoke_admin() {
            test(false, Default::default(), |_ctx, mut account_manager| {
                account_manager.ops_permissions_revoke_admin(to_valid_account_id("bob"));
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
        fn revoke_operator() {
            test(false, Default::default(), |_ctx, mut account_manager| {
                account_manager.ops_permissions_revoke_operator(to_valid_account_id("bob"));
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
        fn revoke() {
            test(false, permissions(), |_ctx, mut account_manager| {
                account_manager.ops_permissions_revoke(to_valid_account_id("bob"), (1 << 1).into());
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
        fn revoke_all() {
            test(false, permissions(), |_ctx, mut account_manager| {
                account_manager.ops_permissions_revoke_all(to_valid_account_id("bob"));
            });
        }
    }

    #[cfg(test)]
    mod contract_permission_bits {
        use super::*;

        #[test]
        fn no_contract_permissions() {
            test(false, Default::default(), |_, account_manager| {
                assert!(account_manager
                    .ops_permissions_contract_permissions()
                    .is_none());
            });
        }

        #[test]
        fn with_contract_permissions() {
            test(false, permissions(), |_, account_manager| {
                let permissions = account_manager
                    .ops_permissions_contract_permissions()
                    .unwrap();
                assert_eq!(permissions.len(), 2);
                assert_eq!(permissions.get(&0).unwrap(), "perm_0");
                assert_eq!(permissions.get(&1).unwrap(), "perm_1");

                for (k, v) in permissions {
                    assert_eq!(account_manager.permission_by_name(&v).unwrap(), 1 << k);
                }
            });
        }
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/components/account_repository.rs ---
use crate::*;
use oysterpack_smart_near::domain::YoctoNear;
use oysterpack_smart_near::near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use std::fmt::Debug;
use std::marker::PhantomData;

#[derive(Clone, Copy, Default)]
pub struct AccountRepositoryComponent<T>(PhantomData<T>);

impl<T> AccountRepository<T> for AccountRepositoryComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn create_account(
        &mut self,
        account_id: &str,
        near_balance: YoctoNear,
        data: Option<T>,
    ) -> Account<T> {
        ERR_ACCOUNT_ALREADY_REGISTERED.assert(|| !AccountNearDataObject::exists(account_id));

        let near_data = AccountNearDataObject::new(account_id, near_balance);
        near_data.save();

        match data {
            Some(data) => {
                let mut data = AccountDataObject::<T>::new(account_id, data);
                data.save();
                (near_data, Some(data))
            }
            None => (near_data, None),
        }
    }

    fn load_account(&self, account_id: &str) -> Option<Account<T>> {
        self.load_account_near_data(account_id)
            .map(|near_data| (near_data, self.load_account_data(account_id)))
    }

    fn load_account_data(&self, account_id: &str) -> Option<AccountDataObject<T>> {
        AccountDataObject::<T>::load(account_id)
    }

    fn load_account_near_data(&self, account_id: &str) -> Option<AccountNearDataObject> {
        AccountNearDataObject::load(account_id)
    }

    fn registered_account(&self, account_id: &str) -> Account<T> {
        let account = self.load_account(account_id);
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| account.is_some());
        account.unwrap()
    }

    fn registered_account_near_data(&self, account_id: &str) -> AccountNearDataObject {
        let account = self.load_account_near_data(account_id);
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| account.is_some());
        account.unwrap()
    }

    fn registered_account_data(&self, account_id: &str) -> AccountDataObject<T> {
        match self.load_account_data(account_id) {
            None => {
                ERR_ACCOUNT_ALREADY_REGISTERED.assert(|| AccountNearDataObject::exists(account_id));
                AccountDataObject::new(account_id, Default::default())
            }
            Some(account_data) => account_data,
        }
    }

    fn account_exists(&self, account_id: &str) -> bool {
        AccountNearDataObject::exists(account_id)
    }

    fn delete_account(&mut self, account_id: &str) {
        if let Some((near_data, data)) = self.load_account(account_id) {
            near_data.delete();
            if let Some(data) = data {
                data.delete();
            }
        }
    }
}

#[cfg(test)]
mod tests_account_repository {
    use super::*;
    use oysterpack_smart_near::near_sdk;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;
    use std::ops::Deref;

    type Accounts = AccountRepositoryComponent<String>;

    #[test]
    fn crud() {
        let account = "alfio";
        let ctx = new_context(account);
        testing_env!(ctx);

        let mut accounts = Accounts::default();
        let service: &mut dyn AccountRepository<String> = &mut accounts;
        assert!(service.load_account(account).is_none());
        assert!(service.load_account_near_data(account).is_none());
        assert!(service.load_account_near_data(account).is_none());

        let (account_near_data, account_data) = service.create_account(account, YOCTO.into(), None);
        assert!(account_data.is_none());
        assert_eq!(account_near_data.near_balance(), YOCTO.into());

        let mut account_data = AccountDataObject::<String>::new(account, "data".to_string());
        account_data.save();

        let (account_near_data, account_data) = service.load_account(account).unwrap();
        assert_eq!(account_data.as_ref().unwrap().deref().as_str(), "data");
        assert_eq!(account_near_data.near_balance(), YOCTO.into());

        let (account_near_data2, account_data2) = service.registered_account(account);
        assert_eq!(account_near_data, account_near_data2);
        assert_eq!(
            account_data.as_ref().unwrap(),
            account_data2.as_ref().unwrap()
        );

        assert_eq!(
            account_near_data2,
            service.registered_account_near_data(account)
        );
        assert_eq!(
            account_data2.unwrap(),
            service.registered_account_data(account)
        );

        assert!(service.account_exists(account));
        service.delete_account(account);
        assert!(!service.account_exists(account));

        service.delete_account(account);
        assert!(!service.account_exists(account));
    }

    #[test]
    #[should_panic(expected = "[ERR] [ACCOUNT_ALREADY_REGISTERED]")]
    fn create_account_already_exists() {
        let account = "alfio";
        let ctx = new_context(account);
        testing_env!(ctx);

        let mut accounts = Accounts::default();
        let service: &mut dyn AccountRepository<String> = &mut accounts;

        service.create_account(account, YOCTO.into(), None);
        service.create_account(account, YOCTO.into(), None);
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/components/account_storage_usage.rs ---
use oysterpack_smart_near::domain::StorageUsage;
use oysterpack_smart_near::near_sdk::json_types::ValidAccountId;

use crate::{AccountNearDataObject, AccountStorageUsage, StorageUsageBounds};
use oysterpack_smart_near::component::{Component, Deploy};

#[derive(Default)]
pub(crate) struct AccountStorageUsageComponent;

impl AccountStorageUsage for AccountStorageUsageComponent {
    fn ops_storage_usage_bounds(&self) -> StorageUsageBounds {
        *Self::load_state().expect("requires deployment")
    }

    fn ops_storage_usage(&self, account_id: ValidAccountId) -> Option<StorageUsage> {
        AccountNearDataObject::load(account_id.as_ref().as_str())
            .map(|account| account.storage_usage())
    }
}

impl Component for AccountStorageUsageComponent {
    type State = StorageUsageBounds;

    const STATE_KEY: u128 = 1952475351321611295376996018476025471;
}

impl Deploy for AccountStorageUsageComponent {
    type Config = StorageUsageBounds;

    fn deploy(config: Self::Config) {
        let state = Self::new_state(config);
        state.save();
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/domain.rs ---
pub use account_data::*;
pub use account_metrics::*;
pub use account_near_data::*;
pub use account_storage_event::*;
pub use contract_permissions::*;
pub use oysterpack_smart_near::domain::AccountIdHash;
pub use permissions::*;
pub use storage_balance::*;
pub use storage_balance_bounds::*;
pub use storage_management_event::*;
pub use storage_usage_bounds::*;

mod account_data;
mod account_metrics;
mod account_near_data;
mod account_storage_event;
mod contract_permissions;
mod permissions;
mod storage_balance;
mod storage_balance_bounds;
mod storage_management_event;
mod storage_usage_bounds;

'''
'''--- near/oysterpack-smart-account-management/src/domain/account_data.rs ---
use oysterpack_smart_near::data::Object;
use oysterpack_smart_near::{eventbus, Hash};

use oysterpack_smart_near::near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    env,
};

use crate::{AccountIdHash, AccountStorageEvent};
use std::fmt::Debug;
use std::ops::{Deref, DerefMut};

type DAO<T> = Object<AccountIdHash, T>;

/// Generic persistent account data
///
/// ## Notes
/// - keeps track of its own storage usage, i.e., emits [`AccountStorageEvent::StorageUsageChanged`]
///   events when the object is saved or deleted
/// - any account storage usage that is outside of this Account object must be tracked externally
#[derive(Clone, Debug, PartialEq)]
pub struct AccountDataObject<T>(DAO<T>)
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default;

impl<T> AccountDataObject<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    /// Creates a new in memory account object
    /// - its storage usage will be initialized to the serialized object byte size, but this won't
    ///   match the actual storage usage when the object is saved because there is overhead
    pub fn new(account_id: &str, data: T) -> Self {
        let key = Hash::from(account_id);
        Self(DAO::<T>::new(AccountIdHash(key), data))
    }

    /// tries to load the account from storage
    pub fn load(account_id: &str) -> Option<Self> {
        let key = Hash::from(account_id);
        DAO::load(&AccountIdHash(key)).map(|account| Self(account))
    }

    pub fn exists(account_id: &str) -> bool {
        let key = Hash::from(account_id);
        DAO::<T>::exists(&AccountIdHash(key))
    }

    /// tracks storage usage changes - emits [`AccountStorageEvent::StorageUsageChanged`] event
    pub fn save(&mut self) {
        let storage_usage_before_save = env::storage_usage();
        self.0.save();
        let storage_usage_after_save = env::storage_usage();
        if storage_usage_after_save == storage_usage_before_save {
            return;
        }
        let event = if storage_usage_after_save > storage_usage_before_save {
            let storage_usage_change = storage_usage_after_save - storage_usage_before_save;
            AccountStorageEvent::StorageUsageChanged(
                self.key().clone(),
                storage_usage_change.into(),
            )
        } else {
            let storage_usage_change = storage_usage_before_save - storage_usage_after_save;
            AccountStorageEvent::StorageUsageChanged(
                self.key().clone(),
                (storage_usage_change as i64 * -1).into(),
            )
        };
        eventbus::post(&event);
    }

    /// tracks storage usage - emits [`AccountStorageEvent::StorageUsageChanged`] event
    pub fn delete(self) -> bool {
        let key = self.key().clone();
        let storage_usage_before_save = env::storage_usage();
        let result = self.0.delete();
        let storage_usage_deleted = storage_usage_before_save - env::storage_usage();
        if storage_usage_deleted > 0 {
            eventbus::post(&AccountStorageEvent::StorageUsageChanged(
                key,
                (storage_usage_deleted as i64 * -1).into(),
            ))
        }
        result
    }
}

impl<T> Deref for AccountDataObject<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    type Target = DAO<T>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl<T> DerefMut for AccountDataObject<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near_test::*;

    type ContractAccount = AccountDataObject<String>;

    #[test]
    fn account_crud() {
        // Arrange
        let account_id = "bob.near";
        let context = new_context(account_id);
        testing_env!(context);

        // Assert
        assert!(ContractAccount::load(account_id).is_none());

        // Act - create account
        let mut account = ContractAccount::new(account_id, "data".to_string());
        account.save();

        // Act - load account from storage
        let mut account2 = ContractAccount::load(account_id).unwrap();
        assert_eq!(account, account2);
        println!("{:?}", *account);

        // Act - update account data
        let data = &mut account2;
        println!("{:?}", data);
        data.make_ascii_uppercase();
        println!("{:?}", data);
        account2.save();

        // Assert - update was persisted
        let account3 = ContractAccount::load(account_id).unwrap();
        {
            assert_eq!(account3, account2);
            assert_eq!(account3.as_str(), "DATA");
        }

        // Act - delete account
        assert!(account3.delete());
        assert!(!ContractAccount::exists(account_id));
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/domain/account_metrics.rs ---
use crate::AccountStorageEvent;
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};

use crate::AccountNearDataObject;
use lazy_static::lazy_static;
use oysterpack_smart_near::{
    data::{numbers::U128, Object},
    domain::{StorageUsage, YoctoNear},
    eventbus,
};
use std::sync::Mutex;

/// Account metrics
#[derive(
    BorshSerialize, BorshDeserialize, Deserialize, Serialize, Copy, Clone, Debug, PartialEq, Default,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct AccountMetrics {
    pub total_registered_accounts: U128,
    pub total_near_balance: YoctoNear,
    pub total_storage_usage: StorageUsage,
}

lazy_static! {
    static ref ACCOUNT_STORAGE_EVENT_HANDLER_REGISTERED: Mutex<bool> = Mutex::new(false);
}

const ACCOUNT_METRICS_KEY: u128 = 1952364736129901845182088441739779955;
type DAO = Object<u128, AccountMetrics>;

impl AccountMetrics {
    pub fn load() -> AccountMetrics {
        let stats = DAO::load(&ACCOUNT_METRICS_KEY)
            .unwrap_or_else(|| DAO::new(ACCOUNT_METRICS_KEY, AccountMetrics::default()));
        *stats
    }

    fn save(&self) {
        DAO::new(ACCOUNT_METRICS_KEY, *self).save();
    }

    #[cfg(test)]
    pub(crate) fn reset() {
        let mut stats = AccountMetrics::load();
        stats.total_storage_usage = 0.into();
        stats.total_near_balance = 0.into();
        stats.total_registered_accounts = 0.into();
        stats.save();
    }

    /// can be safely called multiple times and will only register the event handler once
    pub(crate) fn register_account_storage_event_handler() {
        let mut registered = ACCOUNT_STORAGE_EVENT_HANDLER_REGISTERED.lock().unwrap();
        if !*registered {
            eventbus::register(AccountMetrics::on_account_storage_event);
            *registered = true;
        }
    }

    fn on_account_storage_event(event: &AccountStorageEvent) {
        event.log();

        let mut stats = AccountMetrics::load();

        match *event {
            AccountStorageEvent::Registered(storage_balance) => {
                stats.total_registered_accounts = stats
                    .total_registered_accounts
                    .checked_add(1)
                    .expect("total_registered_accounts overflow")
                    .into();

                stats.total_near_balance = stats
                    .total_near_balance
                    .checked_add(storage_balance.total.value())
                    .expect("total_near_balance overflow")
                    .into();
            }

            AccountStorageEvent::Deposit(amount) => {
                stats.total_near_balance = stats
                    .total_near_balance
                    .checked_add(amount.value())
                    .expect("total_near_balance overflow")
                    .into();
            }
            AccountStorageEvent::Withdrawal(amount) => {
                stats.total_near_balance = stats
                    .total_near_balance
                    .checked_sub(amount.value())
                    .expect("total_near_balance overflow")
                    .into();
            }
            AccountStorageEvent::StorageUsageChanged(account_id_hash, change) => {
                if change.value() != 0 {
                    if change.is_positive() {
                        stats.total_storage_usage = stats
                            .total_storage_usage
                            .checked_add(change.value() as u64)
                            .expect("total_storage_usage overflow")
                            .into();
                    } else {
                        stats.total_storage_usage = stats
                            .total_storage_usage
                            .checked_sub(change.value().abs() as u64)
                            .expect("total_storage_usage overflow")
                            .into();
                    }

                    if let Some(mut account) = AccountNearDataObject::load(account_id_hash) {
                        if change.is_positive() {
                            account.incr_storage_usage((change.value() as u64).into())
                        } else {
                            account.decr_storage_usage((change.value().abs() as u64).into())
                        }
                        account.save();
                    }
                }
            }

            AccountStorageEvent::Unregistered(account_near_balance) => {
                stats.total_registered_accounts = stats
                    .total_registered_accounts
                    .checked_sub(1)
                    .expect("total_registered_accounts overflow")
                    .into();

                stats.total_near_balance = stats
                    .total_near_balance
                    .checked_sub(account_near_balance.value())
                    .expect("total_near_balance overflow")
                    .into();
            }
        }

        stats.save();
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::StorageBalance;
    use near_sdk::test_utils;
    use oysterpack_smart_near::domain::StorageUsageChange;
    use oysterpack_smart_near::*;
    use oysterpack_smart_near_test::*;

    #[test]
    fn on_account_storage_event() {
        // Arrange
        let account_id = "bob.near";
        let context = new_context(account_id);
        testing_env!(context);

        AccountMetrics::register_account_storage_event_handler();

        let stats = AccountMetrics::load();
        assert_eq!(stats.total_registered_accounts, 0.into());
        assert_eq!(stats.total_near_balance, 0.into());
        assert_eq!(stats.total_storage_usage, 0.into());

        let account = AccountNearDataObject::new(account_id, YoctoNear::ZERO);
        account.save();

        // Act - account registered
        let storage_balance = StorageBalance {
            total: YOCTO.into(),
            available: 0.into(),
        };
        eventbus::post(&AccountStorageEvent::Registered(storage_balance));

        let account = AccountNearDataObject::load(account_id).unwrap();

        // Assert
        let stats = AccountMetrics::load();
        assert_eq!(stats.total_registered_accounts, 1.into());
        assert_eq!(stats.total_near_balance, YOCTO.into());
        assert_eq!(stats.total_storage_usage, account.storage_usage());

        // Act - deposit
        eventbus::post(&AccountStorageEvent::Deposit(YOCTO.into()));

        // Assert
        let stats = AccountMetrics::load();
        assert_eq!(stats.total_registered_accounts, 1.into());
        assert_eq!(stats.total_near_balance, (2 * YOCTO).into());
        assert_eq!(stats.total_storage_usage, account.storage_usage());

        // Act - withdraw
        eventbus::post(&AccountStorageEvent::Withdrawal(YOCTO.into()));

        // Assert
        let stats = AccountMetrics::load();
        assert_eq!(stats.total_registered_accounts, 1.into());
        assert_eq!(stats.total_near_balance, YOCTO.into());
        assert_eq!(stats.total_storage_usage, account.storage_usage());
        let initial_account_storage_usage = account.storage_usage();

        // Act - storage usage increase
        eventbus::post(&AccountStorageEvent::StorageUsageChanged(
            account.key().account_id_hash(),
            1000_u64.into(),
        ));

        // Assert
        let stats = AccountMetrics::load();
        assert_eq!(stats.total_registered_accounts, 1.into());
        assert_eq!(stats.total_near_balance, YOCTO.into());
        assert_eq!(
            stats.total_storage_usage,
            account.storage_usage() + 1000.into()
        );

        let account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(
            account.storage_usage(),
            initial_account_storage_usage + 1000.into()
        );

        // Act - storage usage decrease
        eventbus::post(&AccountStorageEvent::StorageUsageChanged(
            account.key().account_id_hash(),
            StorageUsageChange(-1000),
        ));
        let account = AccountNearDataObject::load(account_id).unwrap();

        // Assert
        let stats = AccountMetrics::load();
        assert_eq!(stats.total_registered_accounts, 1.into());
        assert_eq!(stats.total_near_balance, YOCTO.into());
        assert_eq!(stats.total_storage_usage, account.storage_usage());

        let account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(account.storage_usage(), initial_account_storage_usage);

        // Act - account unregistered
        eventbus::post(&AccountStorageEvent::Unregistered(YOCTO.into()));

        // Assert
        let stats = AccountMetrics::load();
        assert_eq!(stats.total_registered_accounts, 0.into());

        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(logs.len(), 7);
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/domain/account_near_data.rs ---
use crate::{
    AccountIdHash, AccountStorageEvent, Permissions, StorageBalance, ERR_ACCOUNT_NOT_REGISTERED,
};
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
};
use oysterpack_smart_near::{
    data::Object,
    domain::{StorageUsage, YoctoNear},
    eventbus, Hash,
};
use std::ops::{Deref, DerefMut};

type DAO = Object<AccountNearDataHash, AccountNearData>;

/// Persistent account NEAR related data
#[derive(Clone, Debug, PartialEq)]
pub struct AccountNearDataObject(DAO);

impl AccountNearDataObject {
    /// Creates a new in memory account object
    /// - its storage usage will be initialized to the serialized object byte size, but this won't
    ///   match the actual storage usage when the object is saved because there is overhead
    pub fn new(account_id: &str, near_balance: YoctoNear) -> Self {
        let object = DAO::new(
            account_id.into(),
            AccountNearData::new(near_balance, 0.into()),
        );
        Self(object)
    }

    /// tries to load the account from storage
    pub fn load<ID>(account_id: ID) -> Option<Self>
    where
        ID: Into<AccountNearDataHash>,
    {
        DAO::load(&account_id.into()).map(|object| Self(object))
    }

    /// ## Panics
    /// if the account is not registered
    pub fn registered_account<ID>(account_id: ID) -> Self
    where
        ID: Into<AccountNearDataHash>,
    {
        Self::load(account_id).unwrap_or_else(|| {
            ERR_ACCOUNT_NOT_REGISTERED.panic();
            unreachable!()
        })
    }

    pub fn exists<ID>(account_id: ID) -> bool
    where
        ID: Into<AccountNearDataHash>,
    {
        DAO::exists(&account_id.into())
    }

    pub fn save(&self) {
        let storage_usage_before_save = env::storage_usage();
        self.0.save();
        let storage_usage_after_save = env::storage_usage();
        if storage_usage_after_save == storage_usage_before_save {
            return;
        }
        let event = if storage_usage_after_save > storage_usage_before_save {
            let storage_usage_change = storage_usage_after_save - storage_usage_before_save;
            AccountStorageEvent::StorageUsageChanged(self.key().0, storage_usage_change.into())
        } else {
            let storage_usage_change = storage_usage_before_save - storage_usage_after_save;
            AccountStorageEvent::StorageUsageChanged(
                self.key().0,
                (storage_usage_change as i64 * -1).into(),
            )
        };
        eventbus::post(&event);
    }

    /// tracks storage usage - emits [`AccountStorageEvent::StorageUsageChanged`]
    pub fn delete(self) -> bool {
        let key = self.key().0;
        let storage_usage_before_save = env::storage_usage();
        let result = self.0.delete();
        let storage_usage_deleted = storage_usage_before_save - env::storage_usage();
        if storage_usage_deleted > 0 {
            eventbus::post(&AccountStorageEvent::StorageUsageChanged(
                key,
                (storage_usage_deleted as i64 * -1).into(),
            ))
        }
        result
    }
}

impl Deref for AccountNearDataObject {
    type Target = Object<AccountNearDataHash, AccountNearData>;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for AccountNearDataObject {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

/// Provides the basic fields that all accounts need:
/// - [`AccountNearData::near_balance`] - all accounts must pay for their own storage and thus need a NEAR balance
/// - [`AccountNearData::storage_usage`] - used to track account storage usage
/// - [`AccountNearData::permissions`] - many contracts will require access control. bitflags provides
///   the ability to support up to 64 roles / permission bits. The first 62 permission bits are available
///   for the contract. The last 2 permission bits are reserved by:
///   - [`crate::Permissions::ADMIN`]
///   - [`crate::Permissions::OPERATOR`]
#[derive(BorshSerialize, BorshDeserialize, Clone, Copy, Debug, PartialEq)]
pub struct AccountNearData {
    near_balance: YoctoNear,
    storage_usage: StorageUsage,
    permissions: Option<Permissions>,
}

impl AccountNearData {
    /// constructor
    pub fn new(near_balance: YoctoNear, storage_usage: StorageUsage) -> Self {
        Self {
            near_balance,
            storage_usage,
            permissions: None,
        }
    }

    pub fn near_balance(&self) -> YoctoNear {
        self.near_balance
    }

    pub fn storage_usage(&self) -> StorageUsage {
        self.storage_usage
    }

    pub fn permissions(&self) -> Option<Permissions> {
        self.permissions
    }

    pub fn storage_balance(&self, required_min_storage_balance: YoctoNear) -> StorageBalance {
        StorageBalance {
            total: self.near_balance,
            available: (self.near_balance.value() - required_min_storage_balance.value()).into(),
        }
    }

    /// Posts [`AccountStorageEvent::Deposit`] event
    ///
    /// ## Panics
    /// if overflow occurs
    pub fn incr_near_balance(&mut self, amount: YoctoNear) {
        if *amount == 0 {
            return;
        }
        *self.near_balance = self.near_balance.checked_add(*amount).unwrap();
        eventbus::post(&AccountStorageEvent::Deposit(amount));
    }

    /// Posts [`AccountStorageEvent::Withdrawal`] event
    ///
    /// ## Panics
    /// if overflow occurs
    pub fn decr_near_balance(&mut self, amount: YoctoNear) {
        if *amount == 0 {
            return;
        }
        *self.near_balance = self.near_balance.checked_sub(amount.value()).unwrap();
        eventbus::post(&AccountStorageEvent::Withdrawal(amount));
    }

    /// - if change was positive then it posts [`AccountStorageEvent::Deposit`] event
    /// - if change was negative, then it posts  [`AccountStorageEvent::Withdrawal`] event
    pub fn set_near_balance(&mut self, amount: YoctoNear) {
        if self.near_balance > amount {
            eventbus::post(&AccountStorageEvent::Withdrawal(self.near_balance - amount));
        } else if amount > self.near_balance {
            eventbus::post(&AccountStorageEvent::Deposit(amount - self.near_balance));
        }
        *self.near_balance = amount.value();
    }

    /// ## Panics
    /// if overflow occurs
    pub(crate) fn incr_storage_usage(&mut self, amount: StorageUsage) {
        *self.storage_usage = self.storage_usage.checked_add(amount.value()).unwrap();
    }

    /// ## Panics
    /// if overflow occurs
    pub(crate) fn decr_storage_usage(&mut self, amount: StorageUsage) {
        *self.storage_usage = self.storage_usage.checked_sub(amount.value()).unwrap();
    }

    pub fn set_permissions(&mut self, permissions: Permissions) {
        self.permissions = Some(permissions)
    }

    pub fn is_admin(&self) -> bool {
        self.permissions.map_or(false, |permissions| {
            permissions.contains(Permissions::ADMIN)
        })
    }

    pub fn grant_admin(&mut self) {
        let mut permissions = self.permissions.take().unwrap_or_else(Default::default);
        permissions.grant(Permissions::ADMIN);
        self.permissions = Some(permissions);
    }

    pub fn revoke_admin(&mut self) {
        if let Some(mut permissions) = self.permissions.take() {
            permissions.revoke(Permissions::ADMIN);
            self.permissions = Some(permissions);
        }
    }

    pub fn is_operator(&self) -> bool {
        self.permissions.map_or(false, |permissions| {
            permissions.contains(Permissions::OPERATOR) || permissions.contains(Permissions::ADMIN)
        })
    }

    pub fn grant_operator(&mut self) {
        let mut permissions = self.permissions.take().unwrap_or_else(Default::default);
        permissions.grant(Permissions::OPERATOR);
        self.permissions = Some(permissions);
    }

    pub fn revoke_operator(&mut self) {
        if let Some(mut permissions) = self.permissions.take() {
            permissions.revoke(Permissions::OPERATOR);
            self.permissions = Some(permissions);
        }
    }

    pub fn grant(&mut self, access: Permissions) {
        let mut permissions = self.permissions.take().unwrap_or_else(Default::default);
        permissions.grant(access);
        self.permissions = Some(permissions);
    }

    pub fn revoke(&mut self, access: Permissions) {
        if let Some(mut permissions) = self.permissions.take() {
            permissions.revoke(access);
            if permissions.has_permissions() {
                self.permissions = Some(permissions);
            } else {
                self.permissions = None;
            }
        }
    }

    pub fn revoke_all(&mut self) {
        self.permissions = None;
    }

    /// returns true if the account has all of the specified permissions
    pub fn contains_permissions(&self, permissions: Permissions) -> bool {
        self.permissions.map_or(false, |perms| {
            perms.contains(permissions) || perms.contains(Permissions::ADMIN)
        })
    }
}

type AccountNearDataKey = u128;

/// Used as key to store [`AccountNearData`] - defined on [`AccountNearDataObject`]
#[derive(BorshSerialize, BorshDeserialize, Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AccountNearDataHash(AccountIdHash, AccountNearDataKey);

impl AccountNearDataHash {
    const ACCOUNT_NEAR_DATA_KEY: u128 = 1953035509579102406775126588391115273;

    pub fn account_id_hash(&self) -> AccountIdHash {
        self.0
    }
}

impl From<AccountIdHash> for AccountNearDataHash {
    fn from(hash: AccountIdHash) -> Self {
        Self(hash, Self::ACCOUNT_NEAR_DATA_KEY)
    }
}

impl From<&str> for AccountNearDataHash {
    fn from(account_id: &str) -> Self {
        AccountIdHash(Hash::from(account_id)).into()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near::domain::YoctoNear;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    #[test]
    fn bitflags() {
        let mut account = AccountNearData::new(YoctoNear::ZERO, 0.into());

        assert!(!account.is_admin());
        account.grant_admin();
        assert!(account.is_admin());
        account.revoke_admin();
        assert!(!account.is_admin());

        assert!(!account.is_operator());
        account.grant_operator();
        assert!(account.is_operator());
        account.revoke_operator();
        assert!(!account.is_operator());
    }

    #[test]
    fn update_near_balance() {
        // Arrange
        let account_id = "bob.near";
        let context = new_context(account_id);
        testing_env!(context);

        let mut account = AccountNearDataObject::new(account_id.into(), YoctoNear::ZERO);

        // Act - incr near balance
        account.incr_near_balance(YOCTO.into());
        account.save();

        // Assert
        let mut account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(account.near_balance(), YOCTO.into());

        // Act - dec near balance
        account.decr_near_balance(YOCTO.into());
        account.save();

        // Assert
        let mut account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(account.near_balance(), YoctoNear::ZERO);

        // Act - set near balance
        account.set_near_balance((2 * YOCTO).into());
        account.save();

        // Assert
        let account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(account.near_balance(), (2 * YOCTO).into());
    }

    #[test]
    fn update_storage_usage() {
        // Arrange
        let account_id = "bob.near";
        let context = new_context(account_id);
        testing_env!(context);

        let mut account = AccountNearDataObject::new(account_id.into(), YoctoNear::ZERO);
        account.save();
        let initial_storage_usage = account.storage_usage;

        // Act - incr near balance
        account.incr_storage_usage(1000.into());
        account.save();

        // Assert
        let mut account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(
            account.storage_usage(),
            (initial_storage_usage.value() + 1000).into()
        );

        // Act - dec
        account.decr_storage_usage(1000.into());
        account.save();

        // Assert
        let mut account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(account.storage_usage(), initial_storage_usage);

        // Act - incr near balance
        account.incr_storage_usage(2000.into());
        account.save();

        // Assert
        let mut account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(account.storage_usage(), 2000.into());

        // Act - update near balance
        account.incr_storage_usage(1000_u64.into());
        account.save();

        // Assert
        let mut account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(account.storage_usage(), 3000.into());

        // Act - update near balance
        account.decr_storage_usage(1000_u64.into());
        account.save();

        // Assert
        let mut account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(account.storage_usage(), 2000.into());

        // Act - update near balance
        account.incr_storage_usage(0_u64.into());
        account.save();

        // Act - update near balance
        account.decr_storage_usage(0_u64.into());
        account.save();

        // Assert
        let account = AccountNearDataObject::load(account_id).unwrap();
        assert_eq!(account.storage_usage(), 2000.into());
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/domain/account_storage_event.rs ---
use crate::{AccountIdHash, StorageBalance};
use lazy_static::lazy_static;
use oysterpack_smart_near::domain::StorageUsageChange;
use oysterpack_smart_near::{domain::YoctoNear, eventbus::*, Level, LogEvent};
use std::fmt::{self, Display, Formatter};
use std::sync::Mutex;

/// Account storage related events
#[derive(Debug, PartialEq, Clone, Copy)]
pub enum AccountStorageEvent {
    /// an account was registered
    Registered(StorageBalance),
    // an account made a deposit
    Deposit(YoctoNear),
    /// an account made a withdrawal from its storage available balance
    Withdrawal(YoctoNear),
    /// account storage usage changed
    StorageUsageChanged(AccountIdHash, StorageUsageChange),
    /// an account was unregistered
    /// - its NEAR balance was refunded
    Unregistered(YoctoNear),
}

impl Display for AccountStorageEvent {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            AccountStorageEvent::StorageUsageChanged(_, change) => write!(f, "{:?}", change),
            _ => write!(f, "{:?}", self),
        }
    }
}

/// log event for [`AccountStorageEvent`]
pub const LOG_EVENT_ACCOUNT_STORAGE_CHANGED: LogEvent =
    LogEvent(Level::INFO, "ACCOUNT_STORAGE_CHANGED");

impl AccountStorageEvent {
    pub fn log(&self) {
        LOG_EVENT_ACCOUNT_STORAGE_CHANGED.log(self.to_string());
    }
}

lazy_static! {
    static ref EVENT_HANDLERS: Mutex<EventHandlers<AccountStorageEvent>> =
        Mutex::new(EventHandlers::new());
}

impl Event for AccountStorageEvent {
    fn handlers<F>(f: F)
    where
        F: FnOnce(&EventHandlers<Self>),
    {
        match EVENT_HANDLERS.lock() {
            Ok(guard) => f(&*guard),
            Err(poisoned) => f(&*poisoned.into_inner()),
        };
    }

    fn handlers_mut<F>(f: F)
    where
        F: FnOnce(&mut EventHandlers<Self>),
    {
        match EVENT_HANDLERS.lock() {
            Ok(mut guard) => f(&mut *guard),
            Err(poisoned) => f(&mut *poisoned.into_inner()),
        };
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/domain/contract_permissions.rs ---
use crate::Permissions;
use oysterpack_smart_near::asserts::ERR_INVALID;
use oysterpack_smart_near::Error;
use std::collections::{HashMap, HashSet};

#[derive(Debug, Clone, Default, PartialEq)]
pub struct ContractPermissions(pub HashMap<u8, &'static str>);

impl ContractPermissions {
    /// retains permission bits that are in the range 0-61
    /// - 62 -> operator
    /// - 63 -> admin
    ///
    /// ## Panics
    /// - if permission names are not unique
    /// - if permission bits >= 62 were specified
    pub fn new(permissions: HashMap<u8, &'static str>) -> Self {
        let invalid_permissions: Vec<u8> = permissions
            .iter()
            .filter_map(|(k, _)| if *k >= 62_u8 { Some(*k) } else { None })
            .collect();
        assert!(
            invalid_permissions.is_empty(),
            "invalid permission bits were specified - the valid range is [0-61]"
        );
        let names: HashSet<_> = permissions.values().collect();
        ERR_INVALID.assert(
            || names.len() == permissions.len(),
            || "permission names must be unique",
        );
        Self(permissions)
    }

    pub fn is_supported(&self, permissions: Permissions) -> bool {
        if self.0.is_empty() {
            return false;
        }

        let supported_perms = self
            .0
            .keys()
            .fold(0_u64, |supported_perms, perm| supported_perms | 1 << *perm);
        Permissions(supported_perms.into()).contains(permissions)
    }

    /// permissions will be returned as sorted
    pub fn permission_names(&self, permissions: Permissions) -> Vec<String> {
        if self.0.is_empty() {
            return vec![];
        }
        let mut labels = self
            .0
            .keys()
            .filter(|perm| permissions.contains(1_u64 << *perm))
            .fold(vec![], |mut labels, perm| {
                labels.push(self.0.get(perm).as_ref().unwrap().to_string());
                labels
            });
        labels.sort();
        labels
    }

    /// unfolds the individual permissions from the specified `permissions` set. For example, if
    /// `permissions` has 5 permission bits set, then the 5 permissions will be extracted and returned.
    pub fn unfold_permissions(&self, permissions: Permissions) -> Vec<Permissions> {
        if self.0.is_empty() {
            return vec![];
        }
        let mut perms = self
            .0
            .keys()
            .filter(|perm| permissions.contains(1_u64 << *perm))
            .fold(vec![], |mut perms, perm| {
                perms.push((1 << *perm).into());
                perms
            });
        perms.sort();
        perms
    }

    /// folds together the specified permissions specified by name into a [`Permissions']
    pub fn fold_permissions(&self, permissions: Vec<String>) -> Result<Permissions, Error<String>> {
        if permissions.is_empty() {
            return Ok(0.into());
        }

        if self.0.is_empty() {
            return Err(ERR_INVALID.error("contract has no permissions".to_string()));
        }

        let contract_perms: HashSet<String> =
            self.0.values().map(|perm| perm.to_string()).collect();
        let mut invalid_perms: Vec<String> = permissions
            .iter()
            .filter(|perm| {
                // let perm = perm.to_string();
                !contract_perms.contains(perm.as_str())
            })
            .map(|perm| perm.to_string())
            .collect();
        if !invalid_perms.is_empty() {
            invalid_perms.sort();
            invalid_perms.dedup();
            return Err(ERR_INVALID.error(format!(
                "contract does not support specified permissions: {:?}",
                invalid_perms
            )));
        }
        let perms = self.0.iter().fold(HashMap::new(), |mut perms, (k, v)| {
            perms.insert(v.to_string(), *k);
            perms
        });
        let permissions: u64 = permissions.iter().fold(0_64, |permissions, perm| {
            permissions | 1 << *perms.get(perm).unwrap()
        });
        Ok(permissions.into())
    }
}

/// [`ContractPermissions`] can be constructed by specifying (permission_bit, permission_label) mappings:
///
/// ```rust
/// use oysterpack_smart_account_management::ContractPermissions;
/// let contract_permissions: ContractPermissions = vec![
///     (0, "PERM_0"),
///     (1, "PERM_1"),
///     (2, "PERM_2"),
/// ].into();
/// ```
///
/// ## Panics
/// - if any permission bits >= 62
impl From<Vec<(u8, &'static str)>> for ContractPermissions {
    fn from(values: Vec<(u8, &'static str)>) -> Self {
        let mut permissions = values
            .iter()
            .fold(HashMap::new(), |mut permissions, entry| {
                ERR_INVALID.assert(
                    || entry.0 < 62,
                    || "invalid permission bit - valid range is [0-61]",
                );
                permissions.insert(entry.0, entry.1);
                permissions
            });
        permissions.shrink_to_fit();
        ERR_INVALID.assert(
            || permissions.len() == values.len(),
            || "duplicate permission bits were specified",
        );
        ContractPermissions::new(permissions)
    }
}

#[cfg(test)]
mod test_contract_permissions {
    use super::*;
    use crate::Permission;
    use oysterpack_smart_near::near_sdk::test_utils;

    #[test]
    fn contract_permissions() {
        let contract_permissions = ContractPermissions::default();
        assert!(!contract_permissions.is_supported((1 << 15).into()));
        assert!(!contract_permissions.is_supported((1 << 0).into()));
        assert!(contract_permissions
            .permission_names((1 << 15).into())
            .is_empty());

        const MINTER: Permission = 1 << 10;
        const BURNER: Permission = 1 << 20;
        let mut perms = HashMap::new();
        perms.insert(10, "minter");
        perms.insert(20, "burner");
        let contract_permissions = ContractPermissions(perms);

        assert!(!contract_permissions.is_supported((1 << 15).into()));
        assert!(contract_permissions.is_supported((1 << 10).into()));
        assert!(contract_permissions.is_supported(((1 << 10) | (1 << 20)).into()));
        assert!(!contract_permissions.is_supported(((1 << 10) | (1 << 15)).into()));

        let labels = contract_permissions.permission_names(((1 << 10) | (1 << 20)).into());
        println!("{:?}", labels);
        assert_eq!(labels.len(), 2);
        assert!(labels.contains(&"minter".to_string()));
        assert!(labels.contains(&"burner".to_string()));

        let labels =
            contract_permissions.permission_names(((1 << 10) | (1 << 20) | (1 << 15)).into());
        assert_eq!(labels.len(), 2);
        assert!(labels.contains(&"minter".to_string()));
        assert!(labels.contains(&"burner".to_string()));

        let perms = contract_permissions.unfold_permissions((MINTER | BURNER).into());
        assert_eq!(perms.len(), 2);
        assert!(perms.contains(&MINTER.into()));
        assert!(perms.contains(&BURNER.into()));
    }

    #[test]
    #[should_panic(expected = "[ERR] [INVALID] invalid permission bit - valid range is [0-61]")]
    fn create_with_invalid_bits() {
        test_utils::test_env::setup();
        let _contract_permissions: ContractPermissions = vec![(62_u8, "invalid")].into();
    }

    #[test]
    #[should_panic(expected = "[ERR] [INVALID] duplicate permission bits were specified")]
    fn create_with_duplicate_bits() {
        test_utils::test_env::setup();
        let _contract_permissions: ContractPermissions = vec![(1, "1"), (1, "1")].into();
    }

    #[test]
    #[should_panic(expected = "[ERR] [INVALID] permission names must be unique")]
    fn create_with_duplicate_perm_names() {
        test_utils::test_env::setup();
        let _contract_permissions: ContractPermissions = vec![(1, "1"), (2, "1")].into();
    }

    #[test]
    fn fold_permissions() {
        test_utils::test_env::setup();
        let contract_permissions: ContractPermissions = vec![(1, "1"), (2, "2"), (3, "3")].into();
        assert_eq!(
            contract_permissions.fold_permissions(vec![]).unwrap(),
            0.into()
        );
        let perm_123 = contract_permissions
            .fold_permissions(vec![
                "1".to_string(),
                "2".to_string(),
                "3".to_string(),
                "3".to_string(),
            ])
            .unwrap();
        assert_eq!(
            contract_permissions.unfold_permissions(perm_123),
            vec![(1 << 1).into(), (1 << 2).into(), (1 << 3).into()]
        );
    }

    #[test]
    fn fold_permissions_with_no_contract_perms() {
        test_utils::test_env::setup();
        let contract_permissions: ContractPermissions = vec![].into();
        match contract_permissions.fold_permissions(vec![
            "1".to_string(),
            "3".to_string(),
            "2".to_string(),
        ]) {
            Ok(_) => panic!("should have failed"),
            Err(err) => {
                assert_eq!(err.0, ERR_INVALID);
                assert_eq!(err.1, "contract has no permissions");
            }
        }
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/domain/permissions.rs ---
use oysterpack_smart_near::data::numbers::U64;
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};
use std::fmt::{self, Debug, Display, Formatter};
use std::ops::{Deref, DerefMut};

pub type Permission = u64;

/// Permissions are modeled as bitflags.
///
/// By default the account supports 64 bits, i.e., permissions, which should be enough to cover most
/// use cases.
///
/// ## Example on how to construct permission bits
/// ```rust
/// use oysterpack_smart_account_management::Permissions;
/// pub const PERMISSION_MINTER: u64 = 1 << 0;
/// pub const PERMISSION_BURNER: u64 = 1 << 1;
/// let permission: Permissions = (PERMISSION_MINTER | PERMISSION_BURNER).into();
/// ```
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    Clone,
    Copy,
    Debug,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Hash,
    Default,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct Permissions(pub U64);

impl Deref for Permissions {
    type Target = u64;

    fn deref(&self) -> &Self::Target {
        self.0.deref()
    }
}

impl DerefMut for Permissions {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.0.deref_mut()
    }
}

impl From<u64> for Permissions {
    fn from(amount: u64) -> Self {
        Permissions(amount.into())
    }
}

impl Display for Permissions {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        std::fmt::Display::fmt(&self.0, f)
    }
}

impl Permissions {
    /// admin permission
    pub const ADMIN: Permission = 1 << 63;
    /// operator permission
    pub const OPERATOR: Permission = 1 << 62;

    pub fn grant<T: Into<Permissions>>(&mut self, permissions: T) {
        *self.0 |= *permissions.into();
    }

    pub fn revoke<T: Into<Permissions>>(&mut self, permissions: T) {
        *self.0 &= !*permissions.into();
    }

    pub fn revoke_all(&mut self) {
        *self.0 = 0
    }

    /// returns true if all permission bitflags are set
    pub fn contains<T: Into<Permissions>>(&self, permissions: T) -> bool {
        let permissions = permissions.into();
        (*self.0 & *permissions) == *permissions
    }

    /// return true if any permission bits are set
    pub fn has_permissions(&self) -> bool {
        *self.0 != 0
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test() {
        let mut perms = Permissions::default();
        assert!(!perms.has_permissions());

        perms.grant(1 << 15);
        assert!(perms.has_permissions());
        assert!(perms.contains(1 << 15));
        assert!(!perms.contains(1 << 14));
        assert!(!perms.contains(1 << 16));

        perms.grant(1 << 20);
        assert!(perms.has_permissions());
        assert!(perms.contains(1 << 15));
        assert!(perms.contains(1 << 20));

        perms.grant(1 << 50);
        assert!(perms.has_permissions());
        assert!(perms.contains(1 << 15));
        assert!(perms.contains(1 << 20));
        assert!(perms.contains(1 << 50));

        perms.revoke(1 << 50);
        assert!(perms.has_permissions());
        assert!(perms.contains(1 << 15));
        assert!(perms.contains(1 << 20));
        assert!(!perms.contains(1 << 50));

        perms.revoke_all();
        assert!(!perms.has_permissions());
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/domain/storage_balance.rs ---
use oysterpack_smart_near::{
    domain::YoctoNear,
    near_sdk::serde::{Deserialize, Serialize},
};

/// Tracks account storage balance
#[derive(Serialize, Deserialize, Debug, PartialEq, Clone, Copy, Default)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct StorageBalance {
    /// total NEAR funds that is purposed to pay for account storage
    pub total: YoctoNear,
    /// the amount of NEAR funds that are available for withdrawal from the account's storage balance
    pub available: YoctoNear,
}

'''
'''--- near/oysterpack-smart-account-management/src/domain/storage_balance_bounds.rs ---
use crate::StorageUsageBounds;
use oysterpack_smart_near::{
    domain::YoctoNear,
    near_sdk::{
        borsh::{self, BorshDeserialize, BorshSerialize},
        env,
        serde::{Deserialize, Serialize},
    },
};

/// Defines storage balance bounds for the contract
#[derive(
    BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, PartialEq, Clone, Copy,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct StorageBalanceBounds {
    /// the minimum balance that must be maintained for storage by the account on the contract
    /// - it is the amount of tokens required to start using this contract at all, e.g., to register with the contract
    pub min: YoctoNear,
    /// the maximum storage balance that is permitted
    ///
    /// A contract may implement `max` equal to `min` if it only charges for initial registration,
    /// and does not adjust per-user storage over time. A contract which implements `max` must
    /// refund deposits that would increase a user's storage balance beyond this amount.
    pub max: Option<YoctoNear>,
}

impl From<StorageUsageBounds> for StorageBalanceBounds {
    fn from(bounds: StorageUsageBounds) -> Self {
        let storage_byte_cost = env::storage_byte_cost();
        Self {
            min: (storage_byte_cost * bounds.min.value() as u128).into(),
            max: bounds
                .max
                .map(|max| (storage_byte_cost * max.value() as u128).into()),
        }
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/domain/storage_management_event.rs ---
use lazy_static::lazy_static;
use oysterpack_smart_near::eventbus::*;
use oysterpack_smart_near::near_sdk::AccountId;
use std::fmt::{self, Display, Formatter};
use std::sync::Mutex;

/// Account storage related events
#[derive(Debug, PartialEq, Clone)]
pub enum StorageManagementEvent {
    /// Invoked before funds are withdrawn. This provides a hook to update balances before the withdrawal.
    ///
    /// ## Use Case
    /// Account may have funds that are locked and managed externally by other components. For example,
    /// when unstaked NEAR balances become unlocked, then they should be made available for withdrawal.
    PreWithdraw(AccountId),
    /// Invoked before the account is unregistered. It provides a hook for other components to run
    /// component specific business logic to unregister the account.
    ///
    /// The hook is responsible for:
    /// - if `force=false`, panic if the account cannot be deleted because of contract specific
    ///   business logic, e.g., for FT, the account cannot unregister if it has a token balance
    /// - delete any account data outside of the [`crate::AccountNearDataObject`] and [`crate::AccountDataObject`] objects
    /// - apply any component specific business logic
    ///
    /// After all hooks are run, the [AccountManagementComponent][1] will be responsible for
    /// - sending account NEAR balance refund
    /// - publishing events
    /// - deleting [`crate::AccountNearDataObject`] and [`crate::AccountDataObject`] objects from contract storage
    ///
    /// ## NOTES
    ///- the predecessor account is being unregistered
    /// - hooks should use [`crate::ERR_CODE_UNREGISTER_FAILURE`] for failures
    ///
    /// [1]: crate::components::account_management::AccountManagementComponent
    PreUnregister { account_id: AccountId, force: bool },
}

impl Display for StorageManagementEvent {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match self {
            _ => write!(f, "{:?}", self),
        }
    }
}

lazy_static! {
    static ref EVENT_HANDLERS: Mutex<EventHandlers<StorageManagementEvent>> =
        Mutex::new(EventHandlers::new());
}

impl Event for StorageManagementEvent {
    fn handlers<F>(f: F)
    where
        F: FnOnce(&EventHandlers<Self>),
    {
        match EVENT_HANDLERS.lock() {
            Ok(guard) => f(&*guard),
            Err(poisoned) => f(&*poisoned.into_inner()),
        };
    }

    fn handlers_mut<F>(f: F)
    where
        F: FnOnce(&mut EventHandlers<Self>),
    {
        match EVENT_HANDLERS.lock() {
            Ok(mut guard) => f(&mut *guard),
            Err(poisoned) => f(&mut *poisoned.into_inner()),
        };
    }
}

impl StorageManagementEvent {
    pub fn clear_event_handlers() {
        match EVENT_HANDLERS.lock() {
            Ok(mut guard) => guard.clear(),
            Err(poisoned) => poisoned.into_inner().clear(),
        };
    }
}

'''
'''--- near/oysterpack-smart-account-management/src/domain/storage_usage_bounds.rs ---
use oysterpack_smart_near::{
    domain::StorageUsage,
    near_sdk::{
        borsh::{self, BorshDeserialize, BorshSerialize},
        serde::{Deserialize, Serialize},
    },
};

/// Used to configure account storage usage
#[derive(
    BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, PartialEq, Clone, Copy,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct StorageUsageBounds {
    /// the minimum storage that is required for the account on the contract
    pub min: StorageUsage,
    /// max storage that the contract is allowed to have on the contract
    pub max: Option<StorageUsage>,
}

'''
'''--- near/oysterpack-smart-account-management/src/interface.rs ---
pub use account_repository::*;
pub use contract::*;

mod account_repository;
pub mod contract;

'''
'''--- near/oysterpack-smart-account-management/src/interface/account_repository.rs ---
use crate::AccountNearDataObject;
use crate::{AccountDataObject, ERR_NOT_AUTHORIZED};
use oysterpack_smart_near::near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    env,
};
use oysterpack_smart_near::{domain::YoctoNear, ErrCode, ErrorConst};
use std::fmt::Debug;

pub type Account<T> = (AccountNearDataObject, Option<AccountDataObject<T>>);

/// Provides account data access, i.e., CRUD
pub trait AccountRepository<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    /// Creates a new account.
    ///
    /// - tracks storage usage - emits [`crate::AccountStorageEvent::StorageUsageChanged`]
    ///
    /// # Panics
    /// if the account already is registered
    fn create_account(
        &mut self,
        account_id: &str,
        near_balance: YoctoNear,
        data: Option<T>,
    ) -> Account<T>;

    /// tries to load the account from storage
    fn load_account(&self, account_id: &str) -> Option<Account<T>>;

    /// tries to load the account data from storage
    fn load_account_data(&self, account_id: &str) -> Option<AccountDataObject<T>>;

    /// tries to load the account NEAR data from storage
    fn load_account_near_data(&self, account_id: &str) -> Option<AccountNearDataObject>;

    /// Looks up the account for the specified registered account ID.
    ///
    /// ## Panics
    /// if the account is not registered
    fn registered_account(&self, account_id: &str) -> Account<T>;

    /// Looks up the account NEAR data for the specified registered account ID.
    ///
    /// ## Panics
    /// if the account is not registered
    fn registered_account_near_data(&self, account_id: &str) -> AccountNearDataObject;

    /// If the account is registered but has no data, then a default instance will be created and
    /// returned.
    ///
    /// ## Panics
    /// if the account is not registered
    fn registered_account_data(&self, account_id: &str) -> AccountDataObject<T>;

    fn account_exists(&self, account_id: &str) -> bool;

    /// Deletes [AccountNearDataObject] and [AccountDataObject] for the specified  account ID
    /// - tracks storage usage - emits [`crate::AccountStorageEvent::StorageUsageChanged`]
    fn delete_account(&mut self, account_id: &str);

    /// asserts that the predecessor account ID is registered and has operator permission
    fn assert_operator(&self) -> AccountNearDataObject {
        let account = self.registered_account_near_data(env::predecessor_account_id().as_str());
        ERR_NOT_AUTHORIZED.assert(|| account.is_operator());
        account
    }

    /// asserts that the predecessor account ID is registered and has admin permission
    fn assert_admin(&self) -> AccountNearDataObject {
        let account = self.registered_account_near_data(env::predecessor_account_id().as_str());
        ERR_NOT_AUTHORIZED.assert(|| account.is_admin());
        account
    }
}

pub const ERR_ACCOUNT_NOT_REGISTERED: ErrorConst = ErrorConst(
    ErrCode("ACCOUNT_NOT_REGISTERED"),
    "account is not registered",
);

pub const ERR_ACCOUNT_ALREADY_REGISTERED: ErrorConst = ErrorConst(
    ErrCode("ACCOUNT_ALREADY_REGISTERED"),
    "account is already registered",
);

'''
'''--- near/oysterpack-smart-account-management/src/interface/contract.rs ---
//! Contract Interfaces

pub use access_control::*;
pub use account_storage_usage::*;
pub use storage_management::*;

mod access_control;
mod account_storage_usage;
mod storage_management;

'''
'''--- near/oysterpack-smart-account-management/src/interface/contract/access_control.rs ---
use crate::Permissions;
use oysterpack_smart_near::near_sdk::json_types::ValidAccountId;
use oysterpack_smart_near::{ErrCode, ErrorConst, Level, LogEvent};
use std::collections::HashMap;

/// # **Contract Interface**: Permissions Management API
///
/// ## Notes
/// - admins have full access
pub trait PermissionsManagement {
    fn ops_permissions_is_admin(&self, account_id: ValidAccountId) -> bool;

    /// Is restricted to admins
    ///
    /// ## Panics
    /// - if predecessor account is not owner or admin
    /// - if `account_id` is not registered
    fn ops_permissions_grant_admin(&mut self, account_id: ValidAccountId);

    /// Is restricted to admins
    ///
    /// ## Panics
    /// - if predecessor account is not owner or admin
    /// - if `account_id` is not registered
    fn ops_permissions_revoke_admin(&mut self, account_id: ValidAccountId);

    /// contract owner is admin by default
    fn ops_permissions_is_operator(&self, account_id: ValidAccountId) -> bool;

    /// Is restricted to admins
    ///
    /// ## Panics
    /// - if predecessor account is not owner or admin
    /// - if `account_id` is not registered
    fn ops_permissions_grant_operator(&mut self, account_id: ValidAccountId);

    /// Is restricted to admins
    ///
    /// ## Panics
    /// - if predecessor account is not owner or admin
    /// - if `account_id` is not registered
    fn ops_permissions_revoke_operator(&mut self, account_id: ValidAccountId);

    /// Is restricted to admins.
    ///
    /// [`crate::Permissions::ADMIN`] and [`crate::Permissions::OPERATOR`] can not be granted - explicit grant functions
    /// must be used.
    ///
    /// ## Panics
    /// - if predecessor account is not owner or admin
    /// - if `account_id` is not registered
    /// - if permissions are not supported by the contract
    fn ops_permissions_grant(&mut self, account_id: ValidAccountId, permissions: Permissions);

    /// Is restricted to admins.
    ///
    /// [`crate::Permissions::ADMIN`] and [`crate::Permissions::OPERATOR`] can not be granted - explicit grant functions
    /// must be used.
    ///
    /// ## Args
    /// - permissions - array of permission bits
    ///
    /// ## Panics
    /// - if predecessor account is not owner or admin
    /// - if `account_id` is not registered
    /// - if permissions are not supported by the contract
    fn ops_permissions_grant_permissions(
        &mut self,
        account_id: ValidAccountId,
        permissions: Vec<u8>,
    );

    /// Is restricted to admins
    ///
    /// ## Panics
    /// - if predecessor account is not owner or admin
    /// - if `account_id` is not registered
    /// - if permissions are not supported by the contract
    fn ops_permissions_revoke(&mut self, account_id: ValidAccountId, permissions: Permissions);

    /// Is restricted to admins
    ///
    /// ## Panics
    /// - if predecessor account is not owner or admin
    /// - if `account_id` is not registered
    /// - if permissions are not supported by the contract
    fn ops_permissions_revoke_permissions(
        &mut self,
        account_id: ValidAccountId,
        permissions: Vec<u8>,
    );

    /// Is restricted to admins
    ///
    /// ## Panics
    /// - if predecessor account is not owner or admin
    /// - if `account_id` is not registered
    fn ops_permissions_revoke_all(&mut self, account_id: ValidAccountId);

    /// returns true if the account has all of the specified permissions
    fn ops_permissions_contains(
        &self,
        account_id: ValidAccountId,
        permissions: Permissions,
    ) -> bool;

    /// returns the account's permissions
    /// - returns None if the account is not registered
    fn ops_permissions(&self, account_id: ValidAccountId) -> Option<Permissions>;

    fn ops_permissions_granted(&self, account_id: ValidAccountId) -> Option<HashMap<u8, String>>;

    /// lists the permission bits that are supported by the contract with a human friendly name
    /// - [`crate::Permissions::ADMIN`] and [`crate::Permissions::OPERATOR`] are excluded
    fn ops_permissions_contract_permissions(&self) -> Option<HashMap<u8, String>>;
}

pub const ERR_NOT_AUTHORIZED: ErrorConst = ErrorConst(
    ErrCode("NOT_AUTHORIZED"),
    "account is not authorized to perform the requested action",
);

pub const LOG_EVENT_PERMISSIONS_GRANT: LogEvent = LogEvent(Level::INFO, "PERMISSIONS_GRANT");
pub const LOG_EVENT_PERMISSIONS_REVOKE: LogEvent = LogEvent(Level::INFO, "PERMISSIONS_REVOKE");

'''
'''--- near/oysterpack-smart-account-management/src/interface/contract/account_storage_usage.rs ---
use crate::StorageUsageBounds;
use oysterpack_smart_near::domain::StorageUsage;
use oysterpack_smart_near::near_sdk::json_types::ValidAccountId;

/// # **Contract Interface**: Account Storage Usage API
///
/// Used to lookup account storage usage info   
pub trait AccountStorageUsage {
    /// returns the account storage use bounds set by the contract
    ///
    /// NOTE: [`crate::StorageBalanceBounds`] derives from this
    fn ops_storage_usage_bounds(&self) -> StorageUsageBounds;

    /// Returns the account storage usage in bytes
    ///
    /// Returns None if the account is not registered
    fn ops_storage_usage(&self, account_id: ValidAccountId) -> Option<StorageUsage>;
}

'''
'''--- near/oysterpack-smart-account-management/src/interface/contract/storage_management.rs ---
use crate::{StorageBalance, StorageBalanceBounds};
use oysterpack_smart_near::domain::YoctoNear;
use oysterpack_smart_near::near_sdk::json_types::ValidAccountId;
use oysterpack_smart_near::ErrCode;

/// # **Contract Interface**: [Account Storage API][3]
///
/// [Storage staking][1] is an issue that needs to be addressed by any multi-user contract that allocates storage for the
/// user on the blockchain. Storage staking costs are the most expensive costs to consider for the contract on NEAR. If storage
/// costs are not managed properly, then they can [break the bank][2] for the contract.
///
/// On NEAR, the contract is responsible to pay for its long term persistent storage. Thus, multi-user contracts should be
/// designed to pass on storage costs to its user accounts. The account storage API provides the following:
/// 1. It enables accounts to lookup the minimum required account storage balance for the initial deposit in order to be able
///    to use the contract.
/// 2. It enables accounts to deposit NEAR funds into the contract to pay for storage for either itself or on behalf of another
///    account. The initial deposit for the account must be at least the minimum amount required by the contract.
/// 3. Account storage total and available balance can be looked up. The amount required to pay for the account's storage usage
///    will be locked up in the contract. Any storage balance above storage staking costs is available for withdrawal.
///
/// [1]: https://docs.near.org/docs/concepts/storage#how-much-does-it-cost
/// [2]: https://docs.near.org/docs/concepts/storage#the-million-cheap-data-additions-attack
/// [3]: https://nomicon.io/Standards/StorageManagement.html
pub trait StorageManagement {
    /// Used by accounts to deposit funds to pay for account storage staking fees.
    ///
    /// This function supports 2 deposit modes:
    /// 1. **self deposit** (`account_id` is not specified): predecessor account is used as the account
    /// 2. **third party deposit** (`account_id` is valid NEAR account ID):  the function caller is
    ///    depositing NEAR funds for the specified `account_id`
    ///    
    /// - If this is the initial deposit for the account, then the deposit must be enough to cover the
    ///   minimum required balance.
    /// - If the attached deposit is more than the required minimum balance, then the funds are credited
    ///   to the account storage available balance.
    /// - If `registration_only=true`, contract MUST refund above the minimum balance if the account
    ///   wasn't registered and refund full deposit if already registered.
    ///  - Any attached deposit in excess of `storage_balance_bounds.max` must be refunded to predecessor account.
    ///
    /// ## Example Use Cases
    ///  1. In order for the account to hold tokens, the account must first have enough NEAR funds
    ///     deposited into the token contract to pay for the account's storage staking fees. The account
    ///     can deposit NEAR funds for itself into the token contract, or another contract might have
    ///     deposited NEAR funds into the token contract on the account's behalf to pay for the account's
    ///     storage staking fees.
    ///  2. Account's may use the blockchain to store data that grows over time. The account can use
    ///     this API to deposit additional funds to pay for additional account storage usage growth.
    ///
    /// ## Arguments
    /// - `account_id` - defaults to predecessor account ID
    /// - `registration_only` - defaults to false
    ///
    /// ## Returns
    /// The account's updated storage balance.
    ///
    /// ## Panics
    /// - If the attached deposit is less than the minimum required account storage fee on the initial deposit.
    /// - If `account_id` is not a valid NEAR account ID
    ///
    /// `#[payable]`
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /// Used to withdraw NEAR from the predecessor account's storage available balance.
    /// If amount is not specified, then all of the account's storage available balance will be withdrawn.
    ///
    /// - The attached yoctoNEAR will be refunded with the withdrawal transfer.
    /// - The account is required to attach exactly 1 yoctoNEAR to the function call to prevent
    ///   restricted function-call access-key call.
    /// - If the withdrawal amount is zero, then the 1 yoctoNEAR attached deposit is not refunded
    ///   because it would cost more to send the refund
    ///
    /// ## Arguments
    /// - `amount` - the amount to withdraw from the account's storage available balance expressed in yoctoNEAR
    ///amount: Option<YoctoNear>
    /// ## Returns
    /// The account's updated storage balance.
    ///
    /// ## Panics
    /// - If the attached deposit does not equal 1 yoctoNEAR
    /// - If the account is not registered
    /// - If the specified withdrawal amount is greater than the account's available storage balance
    ///
    /// `#[payable]`
    fn storage_withdraw(&mut self, amount: Option<YoctoNear>) -> StorageBalance;

    /// Unregisters the predecessor account and returns the storage NEAR deposit.
    ///
    /// If `force=true` the function SHOULD ignore existing account data, such as non-zero balances
    /// on an FT contract (that is, it should burn such balances), and close the account.
    /// Otherwise, it MUST panic if caller has existing account data, such as a positive registered
    /// balance (eg token holdings) or if the contract doesn't support forced unregistration.
    ///
    /// **NOTE**: function requires exactly 1 yoctoNEAR attached balance to prevent restricted function-call
    /// access-key call (UX wallet security)
    ///
    /// ## Returns
    /// - true if the account was successfully unregistered
    /// - false indicates that the account is not registered with the contract
    ///
    /// ## Panics
    /// - if exactly 1 yoctoNEAR is not attached
    ///
    /// `#[payable]`
    fn storage_unregister(&mut self, force: Option<bool>) -> bool;

    /// Returns minimum and maximum allowed balance amounts to interact with this contract.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    /// Used to lookup the account storage balance for the specified account.
    ///
    /// Returns None if the account is not registered with the contract
    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance>;
}

pub const ERR_CODE_UNREGISTER_FAILURE: ErrCode = ErrCode("UNREGISTER_FAILURE");

'''
'''--- near/oysterpack-smart-account-management/src/lib.rs ---
//! Provides account management support for NEAR smart contracts

pub mod components;
mod domain;
mod interface;

pub use domain::*;
pub use interface::*;

'''
'''--- near/oysterpack-smart-account-management/tests/enum_flags_test.rs ---
use enumflags2::{bitflags, make_bitflags, BitFlags};

#[bitflags]
#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq)]
enum Test {
    A = 0b0001,
    B = 0b0010,
    C, // unspecified variants pick unused bits automatically
    D = 0b1000,
}

#[test]
fn test() {
    let a_b: BitFlags<Test> = Test::A | Test::B;
    let a_c = Test::A | Test::C;
    let b_c_d = make_bitflags!(Test::{B | C | D});

    let bits: u8 = a_b.bits();
    println!("a_b {}", bits);
    println!("a_c {:?}", a_c);
    println!("b_c_d {}", b_c_d.bits());

    let bit_flags: BitFlags<Test> = BitFlags::from_bits(14).unwrap();
    assert_eq!(b_c_d, bit_flags);
    let bit_flags: BitFlags<Test> =
        BitFlags::from_bits(1).unwrap() | BitFlags::from_bits(2).unwrap();
    assert_eq!(a_b, bit_flags);

    let x: u8 = 0b0001 | 0b0010;
    assert_eq!(0b0011, x);
}

'''
'''--- near/oysterpack-smart-account-management/tests/quick_test.rs ---
#[test]
fn test() {}

'''
'''--- near/oysterpack-smart-account-management/tests/serde_json_test.rs ---
use oysterpack_smart_near::near_sdk::{
    serde::Deserialize,
    serde_json::{self, *},
};

#[derive(Deserialize, Debug)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
struct User {
    fingerprint: String,
    location: String,
}

#[test]
fn test() {
    // The type of `j` is `serde_json::Value`
    let j = json!({
        "fingerprint": "0xF9BA143B95FF6D82",
        "location": "Menlo Park, CA",
        "age": 2
    });

    let u: User = serde_json::from_value(j).unwrap();
    println!("{:#?}", u);
}

'''
'''--- near/oysterpack-smart-contract/Cargo.toml ---
[package]
name = "oysterpack-smart-contract"
version = "0.1.0"
authors = ["oysterpack.inc <oysterpack.inc@gmail.com>"]
edition = "2018"

[dependencies]
oysterpack-smart-near = { path = "../oysterpack-smart-near" }
oysterpack-smart-account-management = { path = "../oysterpack-smart-account-management" }
lazy_static = "1.4.0"

[dev-dependencies]
oysterpack-smart-near-test = { path = "../oysterpack-smart-near-test" }
enumflags2 = "0.7.1"
'''
'''--- near/oysterpack-smart-contract/Makefile.toml ---
extend = "../Makefile.toml"
'''
'''--- near/oysterpack-smart-contract/README.md ---

'''
'''--- near/oysterpack-smart-contract/src/components.rs ---
pub mod contract_metrics;
pub mod contract_operator;
pub mod contract_ownership;
pub mod contract_sale;

'''
'''--- near/oysterpack-smart-contract/src/components/contract_metrics.rs ---
//! [`ContractMetricsComponent`]

use crate::{ContractMetrics, ContractMetricsSnapshot};
use crate::{ContractNearBalances, ContractStorageUsage, ContractStorageUsageCosts};
use oysterpack_smart_account_management::AccountMetrics;
use oysterpack_smart_near::data::numbers::U128;
use oysterpack_smart_near::domain::BlockTime;

pub struct ContractMetricsComponent;

impl ContractMetrics for ContractMetricsComponent {
    fn ops_metrics_total_registered_accounts(&self) -> U128 {
        self.ops_metrics_accounts().total_registered_accounts
    }

    fn ops_metrics_contract_storage_usage(&self) -> ContractStorageUsage {
        let account_metrics = self.ops_metrics_accounts();
        ContractStorageUsage::new(account_metrics.total_storage_usage)
    }

    fn ops_metrics_near_balances(&self) -> ContractNearBalances {
        let account_metrics = self.ops_metrics_accounts();
        let near_balances = ContractNearBalances::load_near_balances();
        let near_balances = if near_balances.is_empty() {
            None
        } else {
            Some(near_balances)
        };
        ContractNearBalances::new(account_metrics.total_near_balance, near_balances)
    }

    fn ops_metrics_storage_usage_costs(&self) -> ContractStorageUsageCosts {
        self.ops_metrics_contract_storage_usage().into()
    }

    fn ops_metrics(&self) -> ContractMetricsSnapshot {
        let storage_usage = self.ops_metrics_contract_storage_usage();
        ContractMetricsSnapshot {
            block_time: BlockTime::from_env(),
            total_registered_accounts: self.ops_metrics_total_registered_accounts(),
            storage_usage,
            near_balances: self.ops_metrics_near_balances(),
            storage_usage_costs: storage_usage.into(),
        }
    }

    fn ops_metrics_accounts(&self) -> AccountMetrics {
        AccountMetrics::load()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::env;
    use oysterpack_smart_account_management::components::account_management::{
        AccountManagementComponent, AccountManagementComponentConfig,
    };
    use oysterpack_smart_account_management::{
        AccountRepository, StorageManagement, StorageUsageBounds,
    };
    use oysterpack_smart_near::component::*;
    use oysterpack_smart_near::domain::YoctoNear;
    use oysterpack_smart_near::near_sdk::VMContext;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    pub type AccountManager = AccountManagementComponent<()>;

    const ADMIN: &str = "admin";

    fn deploy_account_service() {
        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: Some(StorageUsageBounds {
                min: 1000.into(),
                max: None,
            }),
            admin_account: to_valid_account_id(ADMIN),
            component_account_storage_mins: None,
        });
    }

    const ACCOUNT: &str = "bob";

    fn run_test<F>(test: F)
    where
        F: FnOnce(VMContext, AccountManager),
    {
        // Arrange
        let ctx = new_context(ACCOUNT);
        testing_env!(ctx.clone());

        // Act
        deploy_account_service();

        test(ctx, AccountManager::default());
    }

    #[test]
    fn total_registered_accounts() {
        run_test(|mut ctx, mut account_manager| {
            // Assert - no accounts registered
            assert_eq!(
                ContractMetricsComponent.ops_metrics_total_registered_accounts(),
                1.into()
            );

            // Arrange - register an account
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, None);

            // Assert
            assert_eq!(
                ContractMetricsComponent.ops_metrics_total_registered_accounts(),
                2.into()
            );
        });
    }

    #[test]
    fn storage_usage() {
        run_test(|mut ctx, mut account_manager| {
            // Act - no accounts registered besides admin
            let admin = account_manager.registered_account_near_data(ADMIN);
            let storage_usage = ContractMetricsComponent.ops_metrics_contract_storage_usage();
            println!("{:?}", storage_usage);
            assert_eq!(storage_usage.accounts(), admin.storage_usage());

            // Arrange - register an account
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, None);

            let account = account_manager.registered_account_near_data(ACCOUNT);

            // Act
            let storage_usage = ContractMetricsComponent.ops_metrics_contract_storage_usage();
            println!("{:?}", storage_usage);
            // Assert
            assert_eq!(
                storage_usage.accounts(),
                account.storage_usage() + admin.storage_usage()
            );

            let storage_usage_costs = ContractMetricsComponent.ops_metrics_storage_usage_costs();
            assert_eq!(storage_usage_costs, storage_usage.into());
        });
    }

    #[test]
    fn near_balances() {
        run_test(|mut ctx, mut account_manager| {
            // Act - no accounts registered besides admin
            let admin = account_manager.registered_account_near_data(ADMIN);
            let balances1 = ContractMetricsComponent.ops_metrics_near_balances();
            println!("{:#?}", balances1);
            assert_eq!(balances1.total(), env::account_balance().into());
            assert_eq!(
                balances1.owner(),
                (env::account_balance() - admin.near_balance().value()).into()
            );
            assert!(balances1.balances().is_none());
            assert_eq!(balances1.accounts(), admin.near_balance());
            assert_eq!(balances1.total(), balances1.owner() + balances1.accounts());

            // Arrange - register an account
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, None);

            // Act
            let balances2 = ContractMetricsComponent.ops_metrics_near_balances();
            println!("{:?}", balances2);
            // Assert
            assert_eq!(balances2.total(), env::account_balance().into());
            assert_eq!(balances2.owner(), balances1.owner());
            assert!(balances2.balances().is_none());
            assert_eq!(
                balances2.accounts(),
                admin.near_balance() + YoctoNear(YOCTO)
            );
            assert_eq!(balances2.total(), balances2.owner() + balances2.accounts());
        });
    }

    #[test]
    fn metrics() {
        run_test(|mut ctx, mut account_manager| {
            let metrics = ContractMetricsComponent.ops_metrics();
            println!("{:#?}", metrics);

            // Arrange - register an account
            ctx.attached_deposit = YOCTO;
            ctx.block_timestamp = 1;
            ctx.block_index = 2;
            ctx.epoch_height = 3;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, None);

            let metrics = ContractMetricsComponent.ops_metrics();
            println!("{:#?}", metrics);
            assert_eq!(metrics.block_time.timestamp.value(), 1);
            assert_eq!(metrics.block_time.height.value(), 2);
            assert_eq!(metrics.block_time.epoch.value(), 3);
        });
    }
}

'''
'''--- near/oysterpack-smart-contract/src/components/contract_operator.rs ---
//! [`ContractOperatorComponent`]

use crate::contract::contract_operator::CONTRACT_LOCKED_STORAGE_BALANCE;
use crate::interface::contract::contract_operator::ContractOperator;
use crate::{ContractNearBalances, ContractOwnerObject, ContractOwnershipAccountIdsObject};
use oysterpack_smart_account_management::components::account_management::AccountManagementComponent;
use oysterpack_smart_account_management::AccountRepository;
use oysterpack_smart_near::{
    domain::StorageUsage,
    near_sdk::{
        borsh::{BorshDeserialize, BorshSerialize},
        env,
    },
};
use std::fmt::Debug;

pub struct ContractOperatorComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    account_manager: AccountManagementComponent<T>,
}

impl<T> ContractOperatorComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    pub fn new(account_manager: AccountManagementComponent<T>) -> Self {
        Self { account_manager }
    }
}

impl<T> ContractOperator for ContractOperatorComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn ops_operator_lock_storage_balance(&mut self, storage_usage: StorageUsage) {
        self.account_manager.assert_operator();
        let storage_use_cost = env::storage_byte_cost() * *storage_usage as u128;
        ContractNearBalances::set_balance(CONTRACT_LOCKED_STORAGE_BALANCE, storage_use_cost.into());
    }

    fn ops_owner_grant_admin(&mut self) {
        ContractOwnerObject::assert_owner_access();
        let account_ids = ContractOwnershipAccountIdsObject::load();

        let mut account =
            AccountManagementComponent::<T>::get_or_register_account(&account_ids.owner);
        account.grant_admin();
        account.save();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::components::contract_metrics::ContractMetricsComponent;
    use crate::components::contract_ownership::ContractOwnershipComponent;
    use crate::ContractMetrics;
    use oysterpack_smart_account_management::components::account_management::AccountManagementComponentConfig;
    use oysterpack_smart_account_management::{PermissionsManagement, StorageManagement};
    use oysterpack_smart_near::component::Deploy;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    type AccountManager = AccountManagementComponent<()>;

    #[test]
    fn lock_storage_balance() {
        // Arrange
        let operator = "bob";
        let ctx = new_context(operator);
        testing_env!(ctx.clone());

        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: None,
            component_account_storage_mins: None,
            admin_account: to_valid_account_id(operator),
        });

        let mut operator = ContractOperatorComponent::new(AccountManager::default());

        // act
        testing_env!(ctx.clone());
        operator.ops_operator_lock_storage_balance(1024.into());

        let contract_balances = ContractMetricsComponent
            .ops_metrics_near_balances()
            .balances()
            .unwrap();
        assert_eq!(
            **contract_balances
                .get(&CONTRACT_LOCKED_STORAGE_BALANCE)
                .unwrap(),
            1024 * env::storage_byte_cost()
        );

        operator.ops_operator_lock_storage_balance(0.into());
        let contract_balances = ContractMetricsComponent
            .ops_metrics_near_balances()
            .balances();
        assert!(contract_balances.is_none());
    }

    #[test]
    #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
    fn with_unregistered_account() {
        // Arrange
        let operator = "bob";
        let mut ctx = new_context(operator);
        testing_env!(ctx.clone());

        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: None,
            component_account_storage_mins: None,
            admin_account: to_valid_account_id(operator),
        });

        let mut operator = ContractOperatorComponent::new(AccountManager::default());

        // act
        ctx.predecessor_account_id = "not_registered".to_string();
        testing_env!(ctx.clone());
        operator.ops_operator_lock_storage_balance(1024.into());
    }

    #[test]
    #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
    fn with_not_operator() {
        // Arrange
        let account = "bob";
        let mut ctx = new_context(account);
        testing_env!(ctx.clone());

        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: None,
            component_account_storage_mins: None,
            admin_account: to_valid_account_id("owner"),
        });

        let mut operator = ContractOperatorComponent::new(AccountManager::default());

        {
            let mut ctx = ctx.clone();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx);
            operator.account_manager.storage_deposit(None, Some(true));
        }

        // act
        ctx.predecessor_account_id = account.to_string();
        testing_env!(ctx.clone());
        operator.ops_operator_lock_storage_balance(1024.into());
    }

    #[test]
    fn grant_admin_to_owner_self() {
        // Arrange
        let account = "bob";
        let mut ctx = new_context(account);
        testing_env!(ctx.clone());

        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: None,
            component_account_storage_mins: None,
            admin_account: to_valid_account_id("bob"),
        });

        ContractOwnershipComponent::deploy(to_valid_account_id("owner"));

        let mut operator = ContractOperatorComponent::new(AccountManager::default());
        assert!(!operator
            .account_manager
            .ops_permissions_is_admin(to_valid_account_id("owner")));

        ctx.predecessor_account_id = "owner".to_string();
        testing_env!(ctx.clone());
        operator.ops_owner_grant_admin();
        assert!(operator
            .account_manager
            .ops_permissions_is_admin(to_valid_account_id("owner")));
    }

    #[test]
    #[should_panic(expected = "[ERR] [OWNER_ACCESS_REQUIRED]")]
    fn grant_admin_to_owner_self_not_as_owner() {
        // Arrange
        let account = "bob";
        let mut ctx = new_context(account);
        testing_env!(ctx.clone());

        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: None,
            component_account_storage_mins: None,
            admin_account: to_valid_account_id("bob"),
        });

        ContractOwnershipComponent::deploy(to_valid_account_id("owner"));

        let mut operator = ContractOperatorComponent::new(AccountManager::default());

        ctx.predecessor_account_id = "bob".to_string();
        testing_env!(ctx.clone());
        operator.ops_owner_grant_admin();
    }
}

'''
'''--- near/oysterpack-smart-contract/src/components/contract_ownership.rs ---
//! [`ContractOwnershipComponent`]
//! - deployment: [`ContractOwnershipComponent::deploy`]
//!   - config: `ValidAccountId` - owner account ID

use crate::components::contract_metrics::ContractMetricsComponent;
use crate::components::contract_sale::ContractSaleComponent;
use crate::{
    ContractMetrics, ContractOwnerNearBalance, ContractOwnerObject, ContractOwnership,
    ContractOwnershipAccountIdsObject, ERR_OWNER_BALANCE_OVERDRAW,
    LOG_EVENT_CONTRACT_SALE_CANCELLED, LOG_EVENT_CONTRACT_TRANSFER_CANCELLED,
    LOG_EVENT_CONTRACT_TRANSFER_FINALIZED, LOG_EVENT_CONTRACT_TRANSFER_INITIATED,
};
use oysterpack_smart_near::asserts::{
    assert_request, assert_yocto_near_attached, ERR_CODE_BAD_REQUEST,
};
use oysterpack_smart_near::component::Deploy;
use oysterpack_smart_near::domain::{AccountIdHash, YoctoNear};
use oysterpack_smart_near::near_sdk::json_types::ValidAccountId;
use oysterpack_smart_near::near_sdk::{env, AccountId, Promise};

pub struct ContractOwnershipComponent;

impl Deploy for ContractOwnershipComponent {
    /// owner account ID
    type Config = ValidAccountId;

    fn deploy(owner: Self::Config) {
        ContractOwnerObject::initialize_contract(owner);
    }
}

impl ContractOwnership for ContractOwnershipComponent {
    fn ops_owner(&self) -> AccountId {
        let account_ids = ContractOwnershipAccountIdsObject::load();
        account_ids.owner.clone()
    }

    fn ops_owner_balance(&self) -> ContractOwnerNearBalance {
        let near_balances = ContractMetricsComponent.ops_metrics_near_balances();
        let storage_usage_costs = ContractMetricsComponent.ops_metrics_storage_usage_costs();
        let available = near_balances
            .owner()
            .saturating_sub(storage_usage_costs.owner().value())
            .into();
        ContractOwnerNearBalance {
            total: near_balances.owner(),
            available,
        }
    }

    fn ops_owner_prospective(&self) -> Option<AccountId> {
        let account_ids = ContractOwnershipAccountIdsObject::load();
        account_ids.prospective_owner.as_ref().cloned()
    }

    fn ops_owner_transfer(&mut self, new_owner: ValidAccountId) {
        assert_yocto_near_attached();

        let mut owner = ContractOwnerObject::assert_owner_access();
        assert_request(
            || new_owner.as_ref() != env::predecessor_account_id().as_str(),
            || "you cannot transfer to yourself",
        );
        let new_owner_account_id_hash: AccountIdHash = new_owner.as_ref().as_str().into();
        let current_prospective_owner_account_id_hash =
            owner.prospective_owner_account_id_hash.as_ref().cloned();

        let mut update_prospective_owner = || {
            let mut account_ids = ContractOwnershipAccountIdsObject::load();
            account_ids.prospective_owner = Some(new_owner.as_ref().to_string());
            account_ids.save();

            owner.prospective_owner_account_id_hash = Some(new_owner_account_id_hash);
            if owner.sale_price.take().is_some() {
                LOG_EVENT_CONTRACT_SALE_CANCELLED
                    .log("contract ownership transfer is being initiated");
            }
            if owner.bid.is_some() {
                let mut account_ids = ContractOwnershipAccountIdsObject::load();
                ContractSaleComponent::cancel_bid(
                    &mut owner,
                    &mut account_ids,
                    "contract ownership transfer has been initiated",
                );
                account_ids.save();
            }

            LOG_EVENT_CONTRACT_TRANSFER_INITIATED.log(new_owner.as_ref());
            owner.save();
        };

        match current_prospective_owner_account_id_hash {
            None => update_prospective_owner(),
            Some(prospective_owner_account_id_hash) => {
                if prospective_owner_account_id_hash != new_owner_account_id_hash {
                    update_prospective_owner()
                }
            }
        }
    }

    fn ops_owner_cancel_transfer(&mut self) {
        assert_yocto_near_attached();

        let mut owner = ContractOwnerObject::assert_current_or_prospective_owner_access();
        if owner.prospective_owner_account_id_hash.take().is_some() {
            owner.save();

            let mut account_ids = ContractOwnershipAccountIdsObject::load();
            account_ids.prospective_owner.take();
            account_ids.save();

            LOG_EVENT_CONTRACT_TRANSFER_CANCELLED.log("");
        }
    }

    fn ops_owner_finalize_transfer(&mut self) {
        assert_yocto_near_attached();

        let mut owner = ContractOwnerObject::assert_prospective_owner_access();
        let mut account_ids = ContractOwnershipAccountIdsObject::load();

        // finalize
        owner.account_id_hash = env::predecessor_account_id().into();
        owner.prospective_owner_account_id_hash.take();

        account_ids.owner = env::predecessor_account_id();
        account_ids.prospective_owner.take();

        owner.save();
        account_ids.save();

        LOG_EVENT_CONTRACT_TRANSFER_FINALIZED.log("");
    }

    fn ops_owner_withdraw_balance(
        &mut self,
        amount: Option<YoctoNear>,
    ) -> ContractOwnerNearBalance {
        assert_yocto_near_attached();
        ContractOwnerObject::assert_owner_access();

        let mut owner_balance = self.ops_owner_balance();
        let amount = match amount {
            None => owner_balance.available,
            Some(amount) => {
                ERR_CODE_BAD_REQUEST.assert(
                    || amount > YoctoNear::ZERO,
                    || "withdraw amount cannot be zero",
                );
                ERR_OWNER_BALANCE_OVERDRAW.assert(|| owner_balance.available >= amount);
                amount
            }
        };

        let account_ids = ContractOwnershipAccountIdsObject::load();
        Promise::new(account_ids.owner.clone()).transfer(amount.value() + 1);

        owner_balance.total -= amount + 1;
        owner_balance.available -= amount;
        owner_balance
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near::domain::YoctoNear;
    use oysterpack_smart_near_test::*;

    #[test]
    fn basic_ownership_workflow() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        // Set alfio as owner at deployment
        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));
        // Assert
        assert_eq!(alfio, ContractOwnershipComponent.ops_owner().as_str());
        assert!(ContractOwnershipComponent.ops_owner_prospective().is_none());
        let owner_balance = ContractOwnershipComponent.ops_owner_balance();
        println!("{:?}", owner_balance);

        // Act - initiate transfer
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));
        // Assert
        assert_eq!(
            bob,
            ContractOwnershipComponent
                .ops_owner_prospective()
                .unwrap()
                .as_str()
        );
        let owner_balance = ContractOwnershipComponent.ops_owner_balance();
        println!("{:?}", owner_balance);

        // Act - initiate same transfer again
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));
        // Assert - should have no effect
        assert_eq!(
            bob,
            ContractOwnershipComponent
                .ops_owner_prospective()
                .unwrap()
                .as_str()
        );
        let owner_balance = ContractOwnershipComponent.ops_owner_balance();
        println!("{:?}", owner_balance);

        // Act - cancel the transfer
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_cancel_transfer();
        // Assert
        assert_eq!(alfio, ContractOwnershipComponent.ops_owner().as_str());
        assert!(ContractOwnershipComponent.ops_owner_prospective().is_none());
        let owner_balance = ContractOwnershipComponent.ops_owner_balance();
        println!("{:?}", owner_balance);

        // Act - withdraw all owner available balance
        // Act - cancel the transfer
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        let owner_balance = ContractOwnershipComponent.ops_owner_withdraw_balance(None);
        println!("after withdrawal: {:?}", owner_balance);
        // Assert
        assert_eq!(owner_balance.available, YoctoNear::ZERO);
        assert_eq!(
            owner_balance,
            ContractOwnershipComponent.ops_owner_balance()
        );

        // Act - initiate transfer again
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));
        // Assert
        assert_eq!(
            bob,
            ContractOwnershipComponent
                .ops_owner_prospective()
                .unwrap()
                .as_str()
        );
        let owner_balance = ContractOwnershipComponent.ops_owner_balance();
        println!("{:?}", owner_balance);

        // Act - prospective owner cancels transfer
        ctx.predecessor_account_id = bob.to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_cancel_transfer();
        // Assert
        assert_eq!(alfio, ContractOwnershipComponent.ops_owner().as_str());
        assert!(ContractOwnershipComponent.ops_owner_prospective().is_none());
        let owner_balance = ContractOwnershipComponent.ops_owner_balance();
        println!("{:?}", owner_balance);

        // Act - initiate transfer again
        ctx.predecessor_account_id = alfio.to_string();
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));
        // Assert
        assert_eq!(
            bob,
            ContractOwnershipComponent
                .ops_owner_prospective()
                .unwrap()
                .as_str()
        );
        let owner_balance = ContractOwnershipComponent.ops_owner_balance();
        println!("{:?}", owner_balance);

        // Act - finalize the transfer
        ctx.predecessor_account_id = bob.to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_finalize_transfer();
        // Assert
        // Assert
        assert_eq!(bob, ContractOwnershipComponent.ops_owner().as_str());
        assert!(ContractOwnershipComponent.ops_owner_prospective().is_none());
        let owner_balance = ContractOwnershipComponent.ops_owner_balance();
        println!("{:?}", owner_balance);
    }
}

#[cfg(test)]
mod tests_transfer_ownership {
    use super::*;
    use crate::ContractSale;
    use near_sdk::test_utils;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    #[test]
    fn change_transfer_recipient() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id("bob"));

        // Act
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id("alice"));
        // Assert
        assert_eq!(
            ContractOwnershipComponent.ops_owner_prospective().unwrap(),
            "alice".to_string()
        );
    }

    #[test]
    fn while_contract_is_for_sale() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell((1000 * YOCTO).into());
        assert!(ContractSaleComponent.ops_contract_sale_price().is_some());

        // Act
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id("bob"));
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        assert_eq!(
            ContractOwnershipComponent
                .ops_owner_prospective()
                .unwrap()
                .as_str(),
            "bob"
        );
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(
            &logs[0],
            "[INFO] [CONTRACT_FOR_SALE] 1000000000000000000000000000"
        );
        assert!(&logs[1].starts_with("[INFO] [CONTRACT_SALE_CANCELLED]"));
        assert_eq!(&logs[2], "[INFO] [CONTRACT_TRANSFER_INITIATED] bob");
    }

    #[test]
    fn while_contract_has_bid() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = YOCTO;
        ctx.predecessor_account_id = "bob".to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);
        assert!(ContractSaleComponent.ops_contract_bid().is_some());

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = alfio.to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id("bob"));
        assert!(ContractSaleComponent.ops_contract_bid().is_none());
        assert_eq!(
            ContractOwnershipComponent
                .ops_owner_prospective()
                .unwrap()
                .as_str(),
            "bob"
        );
        let receipts = deserialize_receipts();
        assert_eq!("bob", &receipts[0].receiver_id);
        let action = &receipts[0].actions[0];
        match action {
            Action::Transfer(transfer) => {
                assert_eq!(YOCTO, transfer.deposit);
            }
            _ => panic!("expected TransferAction"),
        }
    }

    #[test]
    fn while_contract_for_sale_with_bid() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell((1000 * YOCTO).into());
        assert!(ContractSaleComponent.ops_contract_sale_price().is_some());

        ctx.attached_deposit = YOCTO;
        ctx.predecessor_account_id = "bob".to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);
        assert!(ContractSaleComponent.ops_contract_bid().is_some());

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = alfio.to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id("bob"));
        assert!(ContractSaleComponent.ops_contract_bid().is_none());
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        assert_eq!(
            ContractOwnershipComponent
                .ops_owner_prospective()
                .unwrap()
                .as_str(),
            "bob"
        );
        let receipts = deserialize_receipts();
        assert_eq!("bob", &receipts[0].receiver_id);
        let action = &receipts[0].actions[0];
        match action {
            Action::Transfer(transfer) => {
                assert_eq!(YOCTO, transfer.deposit);
            }
            _ => panic!("expected TransferAction"),
        }
    }

    #[test]
    #[should_panic(expected = "[ERR] [OWNER_ACCESS_REQUIRED]")]
    fn not_owner() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = "bob".to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(alfio));
    }

    #[test]
    #[should_panic(expected = "[ERR] [BAD_REQUEST]")]
    fn transfer_to_self_owner() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(alfio));
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn zero_deposit_attached() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 0;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id("bob"));
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn two_deposit_attached() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 2;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id("bob"));
    }
}

#[cfg(test)]
mod tests_finalize_transfer_ownership {
    use super::*;
    use near_sdk::test_utils;
    use oysterpack_smart_near_test::*;

    #[test]
    fn finalize_transfer() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));

        // Act
        ctx.predecessor_account_id = bob.to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_finalize_transfer();

        // Assert
        assert_eq!(ContractOwnershipComponent.ops_owner().as_str(), bob);
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert!(&logs[0].starts_with("[INFO] [CONTRACT_TRANSFER_FINALIZED]"));
    }

    #[test]
    #[should_panic(expected = "[ERR] [PROSPECTIVE_OWNER_ACCESS_REQUIRED]")]
    fn not_prospective_owner() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));

        // Act
        ctx.predecessor_account_id = "alice".to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_finalize_transfer();
    }

    #[test]
    #[should_panic(expected = "[ERR] [CONTRACT_OWNER_TRANSFER_NOT_INITIATED]")]
    fn no_transfer_in_progress() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = "alice".to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_finalize_transfer();
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn zero_deposit_attached() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));

        // Act
        ctx.attached_deposit = 0;
        ctx.predecessor_account_id = bob.to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_finalize_transfer();
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn two_yoctonear_deposit_attached() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));

        // Act
        ctx.attached_deposit = 2;
        ctx.predecessor_account_id = bob.to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_finalize_transfer();
    }
}

#[cfg(test)]
mod tests_cancel_ownership_transfer {
    use super::*;
    use near_sdk::test_utils;
    use oysterpack_smart_near_test::*;

    #[test]
    fn cancelled_by_owner() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));

        // Act
        ContractOwnershipComponent.ops_owner_cancel_transfer();
        // Assert
        assert!(ContractOwnershipComponent.ops_owner_prospective().is_none());
        assert!(ContractOwnershipAccountIdsObject::load()
            .prospective_owner
            .is_none());
        let logs = test_utils::get_logs();
        assert_eq!(&logs[0], "[INFO] [CONTRACT_TRANSFER_INITIATED] bob");
        assert_eq!(&logs[1], "[INFO] [CONTRACT_TRANSFER_CANCELLED] ")
    }

    #[test]
    fn cancelled_by_prospective_owner() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = bob.to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_cancel_transfer();
        // Assert
        assert!(ContractOwnershipComponent.ops_owner_prospective().is_none());
        assert!(ContractOwnershipAccountIdsObject::load()
            .prospective_owner
            .is_none());
        let logs = test_utils::get_logs();
        assert_eq!(&logs[0], "[INFO] [CONTRACT_TRANSFER_CANCELLED] ")
    }

    #[test]
    fn cancelled_by_owner_with_no_transfer_initiated() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_cancel_transfer();
        // Assert
        let logs = test_utils::get_logs();
        assert!(logs.is_empty());
    }

    #[test]
    #[should_panic(expected = "[ERR] [CURRENT_OR_PROSPECTIVE_OWNER_ACCESS_REQUIRED]")]
    fn cancelled_by_non_owner_with_no_transfer_initiated() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = "bob".to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_cancel_transfer();
        // Assert
        let logs = test_utils::get_logs();
        assert!(logs.is_empty());
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn cancelled_by_owner_with_zero_deposit() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));

        // Act
        ctx.attached_deposit = 0;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_cancel_transfer();
        // Assert
        assert!(ContractOwnershipComponent.ops_owner_prospective().is_none());
        assert!(ContractOwnershipAccountIdsObject::load()
            .prospective_owner
            .is_none());
        let logs = test_utils::get_logs();
        assert_eq!(&logs[0], "[INFO] [CONTRACT_TRANSFER_CANCELLED] ")
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn cancelled_by_owner_with_1_deposit() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));

        // Act
        ctx.attached_deposit = 2;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_cancel_transfer();
        // Assert
        assert!(ContractOwnershipComponent.ops_owner_prospective().is_none());
        assert!(ContractOwnershipAccountIdsObject::load()
            .prospective_owner
            .is_none());
        let logs = test_utils::get_logs();
        assert_eq!(&logs[0], "[INFO] [CONTRACT_TRANSFER_CANCELLED] ")
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn cancelled_by_prospective_owner_with_zero_deposit() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));

        // Act
        ctx.attached_deposit = 0;
        ctx.predecessor_account_id = bob.to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_cancel_transfer();
        // Assert
        assert!(ContractOwnershipComponent.ops_owner_prospective().is_none());
        assert!(ContractOwnershipAccountIdsObject::load()
            .prospective_owner
            .is_none());
        let logs = test_utils::get_logs();
        assert_eq!(&logs[0], "[INFO] [CONTRACT_TRANSFER_CANCELLED] ")
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn cancelled_by_prospective_owner_with_2_deposit() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(bob));

        // Act
        ctx.attached_deposit = 2;
        ctx.predecessor_account_id = bob.to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_cancel_transfer();
        // Assert
        assert!(ContractOwnershipComponent.ops_owner_prospective().is_none());
        assert!(ContractOwnershipAccountIdsObject::load()
            .prospective_owner
            .is_none());
        let logs = test_utils::get_logs();
        assert_eq!(&logs[0], "[INFO] [CONTRACT_TRANSFER_CANCELLED] ")
    }
}

#[cfg(test)]
mod owner_balance {
    use super::*;
    use oysterpack_smart_near::domain::YoctoNear;
    use oysterpack_smart_near_test::*;

    #[test]
    fn withdraw_all_available_balance() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        let owner_balance_1 = ContractOwnershipComponent.ops_owner_balance();
        assert!(owner_balance_1.available > YoctoNear::ZERO);
        // Act
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        let owner_balance_2 = ContractOwnershipComponent.ops_owner_withdraw_balance(None);
        assert_eq!(owner_balance_2.available, YoctoNear::ZERO);
        let receipts = deserialize_receipts();
        assert_eq!(
            &receipts[0].receiver_id,
            ContractOwnershipComponent.ops_owner().as_str()
        );
        match &receipts[0].actions[0] {
            Action::Transfer(transfer) => {
                // available balance is bit higher than the initial balance because of transaction rewards
                assert!(transfer.deposit > owner_balance_1.available.value() + 1);
            }
            _ => panic!("expected TransferAction"),
        }
    }

    #[test]
    fn withdraw_partial_available_balance() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        let initial_balance = ContractOwnershipComponent.ops_owner_balance();
        let amount = initial_balance.available.value() / 2;
        let owner_balance =
            ContractOwnershipComponent.ops_owner_withdraw_balance(Some(amount.into()));
        assert!(owner_balance.available < initial_balance.available);
        let receipts = deserialize_receipts();
        assert_eq!(
            &receipts[0].receiver_id,
            ContractOwnershipComponent.ops_owner().as_str()
        );
        match &receipts[0].actions[0] {
            Action::Transfer(transfer) => {
                // available balance is bit higher than the initial balance because of transaction rewards
                assert_eq!(transfer.deposit, amount + 1);
            }
            _ => panic!("expected TransferAction"),
        }
    }

    #[test]
    #[should_panic(expected = "[ERR] [OWNER_BALANCE_OVERDRAW]")]
    fn over_withdraw_partial_available_balance() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        let initial_balance = ContractOwnershipComponent.ops_owner_balance();
        let amount = initial_balance.available.value() + 1;
        ContractOwnershipComponent.ops_owner_withdraw_balance(Some(amount.into()));
    }

    #[test]
    #[should_panic(expected = "[ERR] [BAD_REQUEST] withdraw amount cannot be zero")]
    fn zero_withdraw_partial_available_balance() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_withdraw_balance(Some(YoctoNear::ZERO));
    }

    #[test]
    #[should_panic(expected = "[ERR] [OWNER_ACCESS_REQUIRED]")]
    fn withdraw_partial_available_balance_as_non_owner() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = "bob".to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_withdraw_balance(Some(100.into()));
    }

    #[test]
    #[should_panic(expected = "[ERR] [OWNER_ACCESS_REQUIRED]")]
    fn withdraw_all_available_balance_as_non_owner() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = "bob".to_string();
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_withdraw_balance(None);
    }

    #[test]
    #[should_panic(
        expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED] exactly 1 yoctoNEAR must be attached"
    )]
    fn withdraw_all_available_balance_zero_deposit_attached() {
        // Arrange
        let alfio = "alfio";
        let ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_withdraw_balance(None);
    }

    #[test]
    #[should_panic(
        expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED] exactly 1 yoctoNEAR must be attached"
    )]
    fn withdraw_all_available_balance_2_deposit_attached() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 2;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_withdraw_balance(None);
    }

    #[test]
    #[should_panic(
        expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED] exactly 1 yoctoNEAR must be attached"
    )]
    fn withdraw_partial_available_balance_zero_deposit_attached() {
        // Arrange
        let alfio = "alfio";
        let ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_withdraw_balance(Some(100.into()));
    }

    #[test]
    #[should_panic(
        expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED] exactly 1 yoctoNEAR must be attached"
    )]
    fn withdraw_partial_available_balance_2_deposit_attached() {
        // Arrange
        let alfio = "alfio";
        let mut ctx = new_context(alfio);
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ctx.attached_deposit = 2;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_withdraw_balance(Some(100.into()));
    }
}

'''
'''--- near/oysterpack-smart-contract/src/components/contract_sale.rs ---
//! [`ContractSaleComponent`]

use crate::components::contract_ownership::ContractOwnershipComponent;
use crate::{ContractBid, ContractSale};
use crate::{
    ContractBuyerBid, ContractOwner, ContractOwnerObject, ContractOwnership,
    ContractOwnershipAccountIdsObject, ERR_ACCESS_DENIED_MUST_BE_BUYER, ERR_CONTRACT_BID_TOO_LOW,
    ERR_CONTRACT_SALE_NOT_ALLOWED, ERR_CONTRACT_SALE_PRICE_MUST_NOT_BE_ZERO, ERR_NO_ACTIVE_BID,
    ERR_OWNER_CANNOT_BUY_CONTRACT, LOG_EVENT_CONTRACT_BID_CANCELLED,
    LOG_EVENT_CONTRACT_BID_EXPIRATION_CHANGE, LOG_EVENT_CONTRACT_BID_LOWERED,
    LOG_EVENT_CONTRACT_BID_PLACED, LOG_EVENT_CONTRACT_BID_RAISED, LOG_EVENT_CONTRACT_FOR_SALE,
    LOG_EVENT_CONTRACT_SALE_CANCELLED, LOG_EVENT_CONTRACT_SOLD,
};
use oysterpack_smart_near::asserts::{assert_near_attached, ERR_CODE_BAD_REQUEST};
use oysterpack_smart_near::domain::ExpirationSetting;
use oysterpack_smart_near::near_sdk::{env, Promise};
use oysterpack_smart_near::{
    asserts::assert_yocto_near_attached,
    domain::{Expiration, YoctoNear},
    LogEvent,
};

pub struct ContractSaleComponent;

impl ContractSale for ContractSaleComponent {
    fn ops_contract_sale_price(&self) -> Option<YoctoNear> {
        ContractOwnerObject::load().contract_sale_price()
    }

    fn ops_contract_bid(&self) -> Option<ContractBuyerBid> {
        ContractOwnerObject::load()
            .bid()
            .map(|bid| bid.1)
            .map(|bid| {
                let account_ids = ContractOwnershipAccountIdsObject::load();
                ContractBuyerBid {
                    buyer: account_ids
                        .buyer
                        .as_ref()
                        .cloned()
                        .expect("BUG: contract_bid(): expected buyer"),
                    bid,
                }
            })
    }

    fn ops_contract_sell(&mut self, price: YoctoNear) {
        let mut contract_owner = Self::validate_sell_contract_request(price);
        match contract_owner.bid() {
            None => match contract_owner.sale_price {
                Some(current_price) if price == current_price => return,
                _ => {
                    contract_owner.sale_price = Some(price);
                    LOG_EVENT_CONTRACT_FOR_SALE.log(price);
                }
            },
            Some((_buyer, bid)) => {
                if bid.expired() {
                    let mut account_ids = ContractOwnershipAccountIdsObject::load();
                    Self::cancel_bid(&mut contract_owner, &mut account_ids, "bid expired");
                    account_ids.save();

                    contract_owner.sale_price = Some(price);
                    LOG_EVENT_CONTRACT_FOR_SALE.log(price);
                } else if bid.amount >= price {
                    let mut account_ids = ContractOwnershipAccountIdsObject::load();
                    Self::execute_contract_sale(&mut contract_owner, &mut account_ids);
                    account_ids.save();
                } else {
                    contract_owner.sale_price = Some(price);
                    LOG_EVENT_CONTRACT_FOR_SALE.log(price);
                }
            }
        }
        contract_owner.save();
    }

    fn ops_contract_cancel_sale(&mut self) {
        assert_yocto_near_attached();
        let mut contract_owner = ContractOwnerObject::assert_owner_access();
        if contract_owner.sale_price.take().is_some() {
            contract_owner.save();
            LOG_EVENT_CONTRACT_SALE_CANCELLED.log("");
        }
    }

    fn ops_contract_buy(&mut self, expiration: Option<ExpirationSetting>) {
        assert_near_attached("contract bid cannot be zero");
        let expiration = Self::assert_not_expired(expiration);

        let mut account_ids = ContractOwnershipAccountIdsObject::load();
        ERR_OWNER_CANNOT_BUY_CONTRACT.assert(|| env::predecessor_account_id() != account_ids.owner);
        let mut owner = ContractOwnerObject::load();
        ERR_CONTRACT_SALE_NOT_ALLOWED.assert(
            || !owner.transfer_initiated(),
            || "bid cannot be placed while contract ownership is being transferred",
        );

        let bid = YoctoNear(env::attached_deposit());
        match owner.bid.map(|(_, bid)| bid) {
            None => Self::place_bid(&mut owner, &mut account_ids, bid, expiration),
            Some(current_bid) => {
                ERR_CONTRACT_BID_TOO_LOW
                    .assert(|| bid > current_bid.amount || current_bid.expired());
                Self::cancel_bid(&mut owner, &mut account_ids, "higher bid has been placed");
                Self::place_bid(&mut owner, &mut account_ids, bid, expiration);
            }
        }

        owner.save();
        account_ids.save();
    }

    fn ops_contract_raise_bid(&mut self, expiration: Option<ExpirationSetting>) -> ContractBid {
        assert_near_attached("bid raise cannot be zero");
        Self::assert_not_expired(expiration);

        let mut owner = ContractOwnerObject::load();
        let bid = match owner.bid {
            None => {
                ERR_NO_ACTIVE_BID.panic();
                unreachable!()
            }
            Some((buyer_account_id_hash, mut bid)) => {
                ERR_ACCESS_DENIED_MUST_BE_BUYER
                    .assert(|| buyer_account_id_hash == env::predecessor_account_id().into());
                bid.assert_not_expired();

                let amount = env::attached_deposit().into();
                ContractBid::incr_near_balance(amount);

                bid.amount += amount;
                bid.update_expiration(expiration);
                owner.bid = Some((buyer_account_id_hash, bid));

                if let Some(contract_sale_price) = owner.sale_price {
                    if bid.amount >= contract_sale_price {
                        let mut account_ids = ContractOwnershipAccountIdsObject::load();
                        Self::execute_contract_sale(&mut owner, &mut account_ids);
                        account_ids.save();
                    } else {
                        Self::log_bid_raised(bid);
                    }
                } else {
                    Self::log_bid_raised(bid);
                }
                bid
            }
        };

        owner.save();
        bid
    }

    fn ops_contract_lower_bid(
        &mut self,
        amount: YoctoNear,
        expiration: Option<ExpirationSetting>,
    ) -> ContractBid {
        assert_yocto_near_attached();
        Self::assert_not_expired(expiration);
        ERR_CODE_BAD_REQUEST.assert(|| amount > YoctoNear::ZERO, || "amount cannot be zero");

        let mut owner = ContractOwnerObject::load();
        let bid = match owner.bid {
            None => {
                ERR_NO_ACTIVE_BID.panic();
                unreachable!()
            }
            Some((buyer_account_id_hash, mut bid)) => {
                bid.assert_not_expired();
                ERR_ACCESS_DENIED_MUST_BE_BUYER
                    .assert(|| buyer_account_id_hash == env::predecessor_account_id().into());

                bid.amount = bid.amount.saturating_sub(amount.value()).into();
                ERR_CODE_BAD_REQUEST
                    .assert(|| bid.amount > YoctoNear::ZERO, || "bid cannot be zero");
                bid.update_expiration(expiration);

                ContractBid::decr_near_balance(amount);
                Self::log_bid_lowered(bid);

                owner.bid = Some((buyer_account_id_hash, bid));
                bid
            }
        };

        owner.save();
        Promise::new(env::predecessor_account_id()).transfer(amount.value() + 1);
        bid
    }

    fn ops_contract_update_bid_expiration(&mut self, expiration: ExpirationSetting) {
        assert_yocto_near_attached();
        let expiration: Expiration = expiration.into();
        ERR_CODE_BAD_REQUEST.assert(
            || !expiration.expired(),
            || "expiration cannot be set to expired",
        );

        let mut owner = ContractOwnerObject::load();
        match owner.bid {
            None => ERR_NO_ACTIVE_BID.panic(),
            Some((buyer_account_id_hash, mut bid)) => {
                ERR_ACCESS_DENIED_MUST_BE_BUYER
                    .assert(|| buyer_account_id_hash == env::predecessor_account_id().into());

                bid.expiration = Some(expiration);
                owner.bid = Some((buyer_account_id_hash, bid));
                Self::log_bid_event(LOG_EVENT_CONTRACT_BID_EXPIRATION_CHANGE, bid);
            }
        }

        owner.save();
    }

    fn ops_contract_clear_bid_expiration(&mut self) {
        assert_yocto_near_attached();

        let mut owner = ContractOwnerObject::load();
        match owner.bid {
            None => ERR_NO_ACTIVE_BID.panic(),
            Some((buyer_account_id_hash, mut bid)) => {
                ERR_ACCESS_DENIED_MUST_BE_BUYER
                    .assert(|| buyer_account_id_hash == env::predecessor_account_id().into());

                bid.expiration = None;
                owner.bid = Some((buyer_account_id_hash, bid));
                Self::log_bid_event(LOG_EVENT_CONTRACT_BID_EXPIRATION_CHANGE, bid);
            }
        }

        owner.save();
    }

    fn ops_contract_cancel_bid(&mut self) {
        assert_yocto_near_attached();

        let mut owner = ContractOwnerObject::load();
        if owner.bid.is_none() {
            return;
        }

        let mut account_ids = ContractOwnershipAccountIdsObject::load();
        ERR_ACCESS_DENIED_MUST_BE_BUYER
            .assert(|| account_ids.buyer == Some(env::predecessor_account_id()));

        Self::cancel_bid(&mut owner, &mut account_ids, "");

        owner.save();
        account_ids.save();
    }
}

impl ContractSaleComponent {
    fn assert_not_expired(expiration: Option<ExpirationSetting>) -> Option<Expiration> {
        expiration.map(|expiration| {
            let expiration: Expiration = expiration.into();
            ERR_CODE_BAD_REQUEST.assert(
                || !expiration.expired(),
                || "expiration cannot be set to expired",
            );
            expiration
        })
    }

    fn log_bid_event(event: LogEvent, bid: ContractBid) {
        match bid.expiration {
            None => event.log(format!("bid: {}", bid.amount)),
            Some(expiration) => LOG_EVENT_CONTRACT_BID_PLACED
                .log(format!("bid: {} | expiration: {}", bid.amount, expiration)),
        }
    }

    fn log_bid_placed(bid: ContractBid) {
        Self::log_bid_event(LOG_EVENT_CONTRACT_BID_PLACED, bid);
    }

    fn log_bid_raised(bid: ContractBid) {
        Self::log_bid_event(LOG_EVENT_CONTRACT_BID_RAISED, bid);
    }

    fn log_bid_lowered(bid: ContractBid) {
        Self::log_bid_event(LOG_EVENT_CONTRACT_BID_LOWERED, bid);
    }

    /// 1. clears the current bid
    /// 2. refunds the bid amount back to the buyer
    pub(crate) fn cancel_bid(
        owner: &mut ContractOwnerObject,
        account_ids: &mut ContractOwnershipAccountIdsObject,
        msg: &str,
    ) -> ContractBid {
        ContractBid::clear_near_balance();
        let (_, bid) = owner.bid.take().expect("BUG: cancel_bid(): expected bid");
        let buyer = account_ids
            .buyer
            .take()
            .expect("BUG: cancel_bid(): expected buyer");
        Promise::new(buyer).transfer(bid.amount.value());
        LOG_EVENT_CONTRACT_BID_CANCELLED.log(msg);
        bid
    }

    // fn cancel_losing_bid(
    //     owner: &mut ContractOwnerObject,
    //     account_ids: &mut ContractOwnershipAccountIdsObject,
    // ) {
    //     let bid = Self::cancel_bid(owner, account_ids);
    //     if bid.expired() {
    //         LOG_EVENT_CONTRACT_BID_EXPIRED.log("bid expired");
    //     } else {
    //         LOG_EVENT_CONTRACT_BID_LOST.log("higher bid was placed");
    //     }
    // }

    fn place_bid(
        owner: &mut ContractOwnerObject,
        account_ids: &mut ContractOwnershipAccountIdsObject,
        amount: YoctoNear,
        expiration: Option<Expiration>,
    ) {
        account_ids.buyer = Some(env::predecessor_account_id());
        let bid = ContractBid { amount, expiration };
        owner.bid = Some((env::predecessor_account_id().into(), bid));
        ContractBid::set_near_balance(amount);

        if let Some(sale_price) = owner.sale_price {
            if amount >= sale_price {
                Self::execute_contract_sale(owner, account_ids);
                return;
            }
        }

        Self::log_bid_placed(bid);
    }

    fn validate_sell_contract_request(price: YoctoNear) -> ContractOwnerObject {
        assert_yocto_near_attached();
        let contract_owner = ContractOwnerObject::assert_owner_access();
        ERR_CONTRACT_SALE_NOT_ALLOWED.assert(
            || !contract_owner.transfer_initiated(),
            || "contract cannot be sold after transfer process has been started",
        );
        ERR_CONTRACT_SALE_PRICE_MUST_NOT_BE_ZERO.assert(|| price > YoctoNear::ZERO);
        contract_owner
    }

    /// 1. clear the NEAR bid balance, which effectively transfers the bid balance to the owner balance
    /// 2. transfer the owner's NEAR funds out to the owner's account
    /// 3. update the `contract_owner` object
    ///    - set the new owner
    ///    - clear the bid
    ///    - clear the sale price
    /// 4. update the ['ContractOwnershipAccountIds`] object
    ///    - set the new owner account ID
    ///    - clear the buyer account ID
    /// 5. log event: LOG_EVENT_CONTRACT_SOLD
    fn execute_contract_sale(
        owner: &mut ContractOwner,
        account_ids: &mut ContractOwnershipAccountIdsObject,
    ) {
        ContractBid::clear_near_balance();

        // transfer the owner's NEAR funds out to the owner's account
        let owner_balance = ContractOwnershipComponent.ops_owner_balance();
        Promise::new(account_ids.owner.clone()).transfer(owner_balance.available.value());

        // update the contract owner
        let (buyer_account_id_hash, bid) = owner
            .bid
            .take()
            .expect("BUG: execute_contract_sale(): expected bid");
        owner.account_id_hash = buyer_account_id_hash;
        owner.sale_price.take();
        account_ids.owner = account_ids
            .buyer
            .take()
            .expect("BUG: execute_contract_sale(): expected buyer");

        LOG_EVENT_CONTRACT_SOLD.log(format!(
            "buyer={}, price={}",
            &account_ids.owner, bid.amount
        ));
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::components::contract_ownership::ContractOwnershipComponent;
    use crate::ContractOwnership;
    use near_sdk::test_utils;
    use oysterpack_smart_near::component::*;
    use oysterpack_smart_near::domain::ExpirationDuration;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    #[test]
    fn contract_sale_basic_workflow() {
        // Arrange
        let alfio = "alfio";
        let bob = "bob";

        let mut ctx = new_context(alfio);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        let mut service = ContractSaleComponent;
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        // should be harmless to call by the owner - should have no effect
        service.ops_contract_cancel_sale();
        assert!(ContractSaleComponent.ops_contract_bid().is_none());
        // should have no effect and should be harmless to call when there is no bid
        service.ops_contract_cancel_bid();

        // Act - Bob will submit a bid to buy the contract
        ctx.predecessor_account_id = bob.to_string();
        ctx.attached_deposit = 1000;
        testing_env!(ctx.clone());
        service.ops_contract_buy(None);
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.buyer.as_str(), bob);
        assert_eq!(bid.bid.amount.value(), 1000);
        assert_eq!(ContractBid::near_balance(), bid.bid.amount);
        assert!(bid.bid.expiration.is_none());

        // Act - Bob raises the bid
        testing_env!(ctx.clone());
        service.ops_contract_raise_bid(None);
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.buyer.as_str(), bob);
        assert_eq!(bid.bid.amount.value(), 2000);
        assert_eq!(ContractBid::near_balance(), bid.bid.amount);
        assert!(bid.bid.expiration.is_none());

        // Act - Bob raises the bid and updates expiration
        testing_env!(ctx.clone());
        service.ops_contract_raise_bid(None);
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.buyer.as_str(), bob);
        assert_eq!(bid.bid.amount.value(), 3000);
        assert_eq!(ContractBid::near_balance(), bid.bid.amount);
        assert!(bid.bid.expiration.is_none());

        // Act - Bob sets an expiration
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        service.ops_contract_update_bid_expiration(ExpirationSetting::Relative(
            ExpirationDuration::Epochs(10),
        ));
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.buyer.as_str(), bob);
        assert_eq!(bid.bid.amount.value(), 3000);
        assert_eq!(ContractBid::near_balance(), bid.bid.amount);
        assert_eq!(
            bid.bid.expiration,
            Some(ExpirationSetting::Relative(ExpirationDuration::Epochs(10),).into())
        );

        // Act - Bob clears the expiration
        testing_env!(ctx.clone());
        service.ops_contract_clear_bid_expiration();
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.buyer.as_str(), bob);
        assert_eq!(bid.bid.amount.value(), 3000);
        assert_eq!(ContractBid::near_balance(), bid.bid.amount);
        assert!(bid.bid.expiration.is_none());

        // Act - Bob lowers the bid
        testing_env!(ctx.clone());
        service.ops_contract_lower_bid(1000.into(), None);
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.buyer.as_str(), bob);
        assert_eq!(bid.bid.amount.value(), 2000);
        assert_eq!(ContractBid::near_balance(), bid.bid.amount);
        assert!(bid.bid.expiration.is_none());
        let receipts = deserialize_receipts();
        let action = &receipts[0].actions[0];
        match action {
            Action::Transfer(transfer) => {
                assert_eq!(transfer.deposit, 1001);
            }
            _ => panic!("expected TransferAction"),
        }

        // Act - owner sells contract
        ctx.predecessor_account_id = alfio.to_string();
        testing_env!(ctx.clone());
        service.ops_contract_sell(YOCTO.into());
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(
            ContractSaleComponent.ops_contract_sale_price(),
            Some(YOCTO.into())
        );
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.buyer.as_str(), bob);
        assert_eq!(bid.bid.amount.value(), 2000);
        assert_eq!(ContractBid::near_balance(), bid.bid.amount);
        assert!(bid.bid.expiration.is_none());

        // Act - owner cancels sale
        testing_env!(ctx.clone());
        service.ops_contract_cancel_sale();
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.buyer.as_str(), bob);
        assert_eq!(bid.bid.amount.value(), 2000);
        assert_eq!(ContractBid::near_balance(), bid.bid.amount);
        assert!(bid.bid.expiration.is_none());

        // Act - buyer cancels bid
        ctx.predecessor_account_id = ContractSaleComponent
            .ops_contract_bid()
            .unwrap()
            .buyer
            .clone();
        testing_env!(ctx.clone());
        service.ops_contract_cancel_bid();
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        assert!(ContractSaleComponent.ops_contract_bid().is_none());
        assert_eq!(ContractBid::near_balance(), YoctoNear::ZERO);

        // Act - owner sells contract
        ctx.predecessor_account_id = alfio.to_string();
        testing_env!(ctx.clone());
        service.ops_contract_sell(YOCTO.into());
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(
            ContractSaleComponent.ops_contract_sale_price(),
            Some(YOCTO.into())
        );

        // Act - Bob will submit a bid high enough to buy the contract
        ctx.predecessor_account_id = bob.to_string();
        ctx.attached_deposit = YOCTO;
        testing_env!(ctx.clone());
        let previous_owner = ContractOwnershipComponent.ops_owner();
        let owner_balance = ContractOwnershipComponent.ops_owner_balance();
        service.ops_contract_buy(None);
        // Assert
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(ContractOwnershipComponent.ops_owner().as_str(), bob);
        assert_eq!(ContractBid::near_balance(), YoctoNear::ZERO);
        let receipts = deserialize_receipts();
        assert_eq!(&previous_owner, &receipts[0].receiver_id.as_str());
        let action = &receipts[0].actions[0];
        match action {
            Action::Transfer(transfer) => {
                assert_eq!(transfer.deposit, owner_balance.available.value());
            }
            _ => panic!("expected TransferAction"),
        }
    }
}

#[cfg(test)]
mod tests_sell_contract {
    use super::*;
    use crate::components::contract_ownership::ContractOwnershipComponent;
    use near_sdk::test_utils;
    use oysterpack_smart_near::component::*;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    #[test]
    fn new_sale_no_bid() {
        // Arrange
        let alfio = "alfio";

        let mut ctx = new_context(alfio);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
        // Assert
        assert_eq!(
            ContractSaleComponent.ops_contract_sale_price(),
            Some(YOCTO.into())
        );
        let logs = test_utils::get_logs();

        assert_eq!(
            &logs[0],
            LOG_EVENT_CONTRACT_FOR_SALE.message(YOCTO).as_str()
        );
    }

    #[test]
    fn update_sale_no_bid() {
        // Arrange
        let alfio = "alfio";

        let mut ctx = new_context(alfio);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
        ContractSaleComponent.ops_contract_sell((2 * YOCTO).into());
        // Assert
        assert_eq!(
            ContractSaleComponent.ops_contract_sale_price(),
            Some((2 * YOCTO).into())
        );
        let logs = test_utils::get_logs();

        assert_eq!(
            &logs[0],
            LOG_EVENT_CONTRACT_FOR_SALE.message(YOCTO).as_str()
        );
        assert_eq!(
            &logs[1],
            LOG_EVENT_CONTRACT_FOR_SALE.message(2 * YOCTO).as_str()
        );
    }

    #[test]
    fn update_sale_with_same_price_no_bid() {
        // Arrange
        let alfio = "alfio";

        let mut ctx = new_context(alfio);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(alfio));

        // Act
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
        // Assert
        assert_eq!(
            ContractSaleComponent.ops_contract_sale_price(),
            Some(YOCTO.into())
        );
        let logs = test_utils::get_logs();
        assert_eq!(
            &logs[0],
            LOG_EVENT_CONTRACT_FOR_SALE.message(YOCTO).as_str()
        );
        assert_eq!(logs.len(), 1);
    }

    #[test]
    fn new_sale_lower_bid() {
        // Arrange
        let owner = "alfio";
        let buyer = "bob";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));
        ctx.attached_deposit = 100;
        ctx.predecessor_account_id = buyer.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = owner.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
        // Assert
        assert_eq!(
            ContractSaleComponent.ops_contract_sale_price(),
            Some(YOCTO.into())
        );
        let logs = test_utils::get_logs();

        assert_eq!(
            &logs[0],
            LOG_EVENT_CONTRACT_FOR_SALE.message(YOCTO).as_str()
        );
    }

    #[test]
    fn new_sale_matching_bid() {
        // Arrange
        let owner = "alfio";
        let buyer = "bob";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));
        ctx.attached_deposit = YOCTO;
        ctx.predecessor_account_id = buyer.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = owner.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
        // Assert
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        assert!(ContractSaleComponent.ops_contract_bid().is_none());
        assert!(ContractOwnershipAccountIdsObject::load().buyer.is_none());
        assert_eq!(ContractOwnershipComponent.ops_owner(), buyer.to_string());

        let logs = test_utils::get_logs();

        assert_eq!(
            &logs[0],
            LOG_EVENT_CONTRACT_SOLD
                .message(format!("buyer={}, price={}", buyer, YOCTO))
                .as_str()
        );
    }

    #[test]
    fn new_sale_higher_bid() {
        // Arrange
        let owner = "alfio";
        let buyer = "bob";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));
        ctx.attached_deposit = 2 * YOCTO;
        ctx.predecessor_account_id = buyer.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = owner.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
        // Assert
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        assert!(ContractSaleComponent.ops_contract_bid().is_none());
        assert!(ContractOwnershipAccountIdsObject::load().buyer.is_none());
        assert_eq!(ContractOwnershipComponent.ops_owner(), buyer.to_string());

        let logs = test_utils::get_logs();

        assert_eq!(
            &logs[0],
            LOG_EVENT_CONTRACT_SOLD
                .message(format!("buyer={}, price={}", buyer, 2 * YOCTO))
                .as_str()
        );
    }

    #[test]
    fn new_sale_expired_bid() {
        // Arrange
        let owner = "alfio";
        let buyer = "bob";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));
        ctx.attached_deposit = 2 * YOCTO;
        ctx.predecessor_account_id = buyer.to_string();
        ctx.epoch_height = 100;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(Some(ExpirationSetting::Absolute(
            Expiration::Epoch(200.into()),
        )));

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = owner.to_string();
        ctx.epoch_height = 201;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
        // Assert
        assert_eq!(
            ContractSaleComponent.ops_contract_sale_price(),
            Some(YOCTO.into())
        );
        assert!(ContractSaleComponent.ops_contract_bid().is_none());
        assert!(ContractOwnershipAccountIdsObject::load().buyer.is_none());
        assert_eq!(ContractOwnershipComponent.ops_owner(), owner.to_string());

        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(
            &logs[0],
            LOG_EVENT_CONTRACT_BID_CANCELLED
                .message("bid expired")
                .as_str()
        );
        assert_eq!(
            &logs[1],
            LOG_EVENT_CONTRACT_FOR_SALE.message(YOCTO).as_str()
        );
    }

    #[test]
    fn updated_sale_matching_bid() {
        // Arrange
        let owner = "alfio";
        let buyer = "bob";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));
        ctx.attached_deposit = YOCTO;
        ctx.predecessor_account_id = buyer.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = owner.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell((5 * YOCTO).into());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
        // Assert
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        assert!(ContractSaleComponent.ops_contract_bid().is_none());
        assert!(ContractOwnershipAccountIdsObject::load().buyer.is_none());
        assert_eq!(ContractOwnershipComponent.ops_owner(), buyer.to_string());

        let logs = test_utils::get_logs();

        assert_eq!(
            &logs[0],
            LOG_EVENT_CONTRACT_FOR_SALE.message(5 * YOCTO).as_str()
        );
        assert_eq!(
            &logs[1],
            LOG_EVENT_CONTRACT_SOLD
                .message(format!("buyer={}, price={}", buyer, YOCTO))
                .as_str()
        );
    }

    #[test]
    fn update_sale_higher_bid() {
        // Arrange
        let owner = "alfio";
        let buyer = "bob";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));
        ctx.attached_deposit = 2 * YOCTO;
        ctx.predecessor_account_id = buyer.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = owner.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell((5 * YOCTO).into());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
        // Assert
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        assert!(ContractSaleComponent.ops_contract_bid().is_none());
        assert!(ContractOwnershipAccountIdsObject::load().buyer.is_none());
        assert_eq!(ContractOwnershipComponent.ops_owner(), buyer.to_string());

        let logs = test_utils::get_logs();

        assert_eq!(
            &logs[0],
            LOG_EVENT_CONTRACT_FOR_SALE.message(5 * YOCTO).as_str()
        );
        assert_eq!(
            &logs[1],
            LOG_EVENT_CONTRACT_SOLD
                .message(format!("buyer={}, price={}", buyer, 2 * YOCTO))
                .as_str()
        );
    }

    #[test]
    #[should_panic(
        expected = "[ERR] [CONTRACT_SALE_NOT_ALLOWED] contract cannot be sold after transfer process has been started"
    )]
    fn transfer_ownership_initiated() {
        // Arrange
        let owner = "alfio";
        let buyer = "bob";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(buyer));

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = owner.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
    }

    #[test]
    #[should_panic(expected = "[ERR] [OWNER_ACCESS_REQUIRED]")]
    fn not_owner() {
        // Arrange
        let owner = "alfio";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));

        // Act
        ctx.attached_deposit = 1;
        ctx.predecessor_account_id = "bob".to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn zero_deposit() {
        // Arrange
        let owner = "alfio";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));

        // Act
        ctx.attached_deposit = 0;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn two_deposit() {
        // Arrange
        let owner = "alfio";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));

        // Act
        ctx.attached_deposit = 2;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());
    }

    #[test]
    #[should_panic(expected = "[ERR] [CONTRACT_SALE_PRICE_MUST_NOT_BE_ZERO]")]
    fn zero_sale_price() {
        // Arrange
        let owner = "alfio";

        let mut ctx = new_context(owner);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(owner));

        // Act
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(YoctoNear::ZERO);
    }
}

#[cfg(test)]
mod tests_buy_contract {
    use super::*;
    use crate::components::contract_ownership::ContractOwnershipComponent;
    use near_sdk::{test_utils, VMContext};
    use oysterpack_smart_near::component::*;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    const OWNER: &str = "owner";
    const BUYER_1: &str = "buyer1";
    const BUYER_2: &str = "buyer2";

    fn arrange(sale_price: Option<YoctoNear>, bid: Option<ContractBuyerBid>) -> VMContext {
        let ctx = new_context(OWNER);
        {
            let mut ctx = ctx.clone();
            ctx.attached_deposit = 1;
            testing_env!(ctx.clone());

            ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));
            if let Some(sale_price) = sale_price {
                ContractSaleComponent.ops_contract_sell(sale_price);
            }

            if let Some(bid) = bid {
                ctx.predecessor_account_id = bid.buyer;
                ctx.attached_deposit = bid.bid.amount.value();
                testing_env!(ctx.clone());
                ContractSaleComponent
                    .ops_contract_buy(bid.bid.expiration.as_ref().cloned().map(Into::into));
            }
        }
        assert_eq!(ContractOwnershipComponent.ops_owner(), OWNER.to_string());
        ctx
    }

    #[test]
    #[should_panic(expected = "[ERR] [NEAR_DEPOSIT_REQUIRED]")]
    fn zero_yocto_near_attached() {
        let mut ctx = new_context(OWNER);
        ctx.attached_deposit = 0;
        ctx.predecessor_account_id = BUYER_1.to_string();
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);
    }

    #[test]
    fn higher_sale_price_and_lower_prior_bid_() {
        let mut ctx = arrange(
            None,
            Some(ContractBuyerBid {
                buyer: BUYER_2.to_string(),
                bid: ContractBid {
                    amount: 1000.into(),
                    expiration: None,
                },
            }),
        );

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(YOCTO.into());

        ctx.predecessor_account_id = BUYER_1.to_string();
        ctx.attached_deposit = 1001;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.buyer, ctx.predecessor_account_id);
        assert_eq!(bid.bid.amount, ctx.attached_deposit.into());

        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(
            logs,
            vec![
                LOG_EVENT_CONTRACT_BID_CANCELLED.message("higher bid has been placed"),
                LOG_EVENT_CONTRACT_BID_PLACED.message("bid: 1001")
            ]
        );

        let receipts = deserialize_receipts();
        assert_eq!(&receipts[0].receiver_id, BUYER_2);
        match &receipts[0].actions[0] {
            Action::Transfer(transfer) => assert_eq!(transfer.deposit, 1000),
            _ => panic!("expected TransferAction"),
        }
    }

    #[test]
    #[should_panic(expected = "[ERR] [CONTRACT_SALE_NOT_ALLOWED]")]
    fn with_contract_transfer_initiated() {
        let mut ctx = arrange(None, None);

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractOwnershipComponent.ops_owner_transfer(to_valid_account_id(BUYER_2));

        ctx.predecessor_account_id = BUYER_1.to_string();
        ctx.attached_deposit = 10000;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);
    }

    #[cfg(test)]
    mod no_sale_no_bid {
        use super::*;
        use oysterpack_smart_near::domain::ExpirationDuration;

        #[test]
        fn no_expiration() {
            let mut ctx = arrange(None, None);

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = 100;
            testing_env!(ctx.clone());
            ContractSaleComponent.ops_contract_buy(None);

            let bid = ContractSaleComponent.ops_contract_bid().unwrap();
            assert_eq!(bid.buyer, BUYER_1.to_string());
            assert_eq!(bid.bid.amount, 100.into());
            assert!(bid.bid.expiration.is_none());

            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                &logs[0],
                LOG_EVENT_CONTRACT_BID_PLACED.message("bid: 100").as_str()
            );
        }

        #[test]
        fn with_future_expiration() {
            let mut ctx = arrange(None, None);

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = 100;
            ctx.epoch_height = 10;
            testing_env!(ctx.clone());
            let expiration = Expiration::Epoch(20.into());
            ContractSaleComponent.ops_contract_buy(Some(expiration.into()));

            let bid = ContractSaleComponent.ops_contract_bid().unwrap();
            assert_eq!(bid.buyer, BUYER_1.to_string());
            assert_eq!(bid.bid.amount, 100.into());
            assert_eq!(bid.bid.expiration.unwrap(), expiration);

            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                &logs[0],
                LOG_EVENT_CONTRACT_BID_PLACED
                    .message("bid: 100 | expiration: EpochHeight(20)")
                    .as_str()
            );
        }

        #[test]
        fn with_future_relative_expiration() {
            let mut ctx = arrange(None, None);

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = 100;
            ctx.epoch_height = 10;
            testing_env!(ctx.clone());
            let expiration = Expiration::Epoch(20.into());
            ContractSaleComponent.ops_contract_buy(Some(ExpirationSetting::Relative(
                ExpirationDuration::Epochs(10),
            )));

            let bid = ContractSaleComponent.ops_contract_bid().unwrap();
            assert_eq!(bid.buyer, BUYER_1.to_string());
            assert_eq!(bid.bid.amount, 100.into());
            assert_eq!(bid.bid.expiration.unwrap(), expiration);

            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                &logs[0],
                LOG_EVENT_CONTRACT_BID_PLACED
                    .message("bid: 100 | expiration: EpochHeight(20)")
                    .as_str()
            );
        }

        #[test]
        #[should_panic(expected = "[ERR] [BAD_REQUEST] expiration cannot be set to expired")]
        fn with_expired_bid() {
            let mut ctx = arrange(None, None);

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = 100;
            ctx.epoch_height = 10;
            testing_env!(ctx.clone());
            let expiration = Expiration::Epoch(5.into());
            ContractSaleComponent.ops_contract_buy(Some(expiration.into()));
        }
    }

    #[cfg(test)]
    mod with_sale_no_bid {
        use super::*;
        use oysterpack_smart_near::YOCTO;

        #[test]
        fn higher_sale_price() {
            let mut ctx = arrange(Some(1000.into()), None);

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = 100;
            testing_env!(ctx.clone());
            ContractSaleComponent.ops_contract_buy(None);

            let bid = ContractSaleComponent.ops_contract_bid().unwrap();
            assert_eq!(bid.buyer, BUYER_1.to_string());
            assert_eq!(bid.bid.amount, 100.into());
            assert!(bid.bid.expiration.is_none());

            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                &logs[0],
                LOG_EVENT_CONTRACT_BID_PLACED.message("bid: 100").as_str()
            );
        }

        #[test]
        fn with_matching_sale_price() {
            let mut ctx = arrange(Some((YOCTO * 1_000_000).into()), None);

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = YOCTO * 1_000_000;
            testing_env!(ctx.clone());
            ContractSaleComponent.ops_contract_buy(None);
            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                &logs[0],
                LOG_EVENT_CONTRACT_SOLD
                    .message("buyer=buyer1, price=1000000000000000000000000000000")
                    .as_str()
            );
            assert_eq!(ContractOwnershipComponent.ops_owner(), BUYER_1.to_string());
            assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
            assert!(ContractSaleComponent.ops_contract_bid().is_none());

            let receipts = deserialize_receipts();
            assert_eq!(&receipts[0].receiver_id, OWNER);
            match &receipts[0].actions[0] {
                Action::Transfer(transfer) => assert!(transfer.deposit > ctx.attached_deposit),
                _ => panic!("expected TransferAction"),
            }
        }

        #[test]
        fn with_lower_sale_price() {
            let mut ctx = arrange(Some(100.into()), None);

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = YOCTO * 1_000_000;
            testing_env!(ctx.clone());
            ContractSaleComponent.ops_contract_buy(None);
            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                &logs[0],
                LOG_EVENT_CONTRACT_SOLD
                    .message("buyer=buyer1, price=1000000000000000000000000000000")
                    .as_str()
            );
            assert_eq!(ContractOwnershipComponent.ops_owner(), BUYER_1.to_string());
            assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
            assert!(ContractSaleComponent.ops_contract_bid().is_none());

            let receipts = deserialize_receipts();
            assert_eq!(&receipts[0].receiver_id, OWNER);
            match &receipts[0].actions[0] {
                Action::Transfer(transfer) => assert!(transfer.deposit > ctx.attached_deposit),
                _ => panic!("expected TransferAction"),
            }
        }
    }

    #[cfg(test)]
    mod no_sale_with_bid {
        use super::*;
        use oysterpack_smart_near::domain::ExpirationDuration;

        #[test]
        #[should_panic(expected = "[ERR] [CONTRACT_BID_NOT_ATTACHED]")]
        fn higher_prior_bid() {
            let mut ctx = arrange(
                None,
                Some(ContractBuyerBid {
                    buyer: BUYER_2.to_string(),
                    bid: ContractBid {
                        amount: 1000.into(),
                        expiration: None,
                    },
                }),
            );

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = 999;
            testing_env!(ctx.clone());
            ContractSaleComponent.ops_contract_buy(None);
        }

        #[test]
        fn higher_prior_expired_bid() {
            testing_env!(new_context(OWNER));
            let mut ctx = arrange(
                None,
                Some(ContractBuyerBid {
                    buyer: BUYER_2.to_string(),
                    bid: ContractBid {
                        amount: 1000.into(),
                        expiration: Some(
                            ExpirationSetting::Relative(ExpirationDuration::Epochs(10)).into(),
                        ),
                    },
                }),
            );

            let bid = ContractSaleComponent.ops_contract_bid().unwrap();

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = 999;
            if let Some(Expiration::Epoch(epoch)) = bid.bid.expiration {
                ctx.epoch_height = epoch.value() + 1; // expires the bid
            }
            testing_env!(ctx.clone());
            ContractSaleComponent.ops_contract_buy(None);
            let bid = ContractSaleComponent.ops_contract_bid().unwrap();
            assert_eq!(bid.buyer, ctx.predecessor_account_id);
            assert_eq!(bid.bid.amount, ctx.attached_deposit.into());

            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                logs,
                vec![
                    LOG_EVENT_CONTRACT_BID_CANCELLED.message("higher bid has been placed"),
                    LOG_EVENT_CONTRACT_BID_PLACED.message("bid: 999")
                ]
            );

            let receipts = deserialize_receipts();
            assert_eq!(&receipts[0].receiver_id, BUYER_2);
            match &receipts[0].actions[0] {
                Action::Transfer(transfer) => assert_eq!(transfer.deposit, 1000),
                _ => panic!("expected TransferAction"),
            }
        }

        #[test]
        #[should_panic(expected = "[ERR] [CONTRACT_BID_NOT_ATTACHED]")]
        fn matching_prior_bid() {
            let mut ctx = arrange(
                None,
                Some(ContractBuyerBid {
                    buyer: BUYER_2.to_string(),
                    bid: ContractBid {
                        amount: 1000.into(),
                        expiration: None,
                    },
                }),
            );

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = 999;
            testing_env!(ctx.clone());
            ContractSaleComponent.ops_contract_buy(None);
        }

        #[test]
        fn lower_prior_bid() {
            let mut ctx = arrange(
                None,
                Some(ContractBuyerBid {
                    buyer: BUYER_2.to_string(),
                    bid: ContractBid {
                        amount: 1000.into(),
                        expiration: None,
                    },
                }),
            );

            ctx.predecessor_account_id = BUYER_1.to_string();
            ctx.attached_deposit = 1001;
            testing_env!(ctx.clone());
            ContractSaleComponent.ops_contract_buy(None);
            let bid = ContractSaleComponent.ops_contract_bid().unwrap();
            assert_eq!(bid.buyer, ctx.predecessor_account_id);
            assert_eq!(bid.bid.amount, ctx.attached_deposit.into());

            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                logs,
                vec![
                    LOG_EVENT_CONTRACT_BID_CANCELLED.message("higher bid has been placed"),
                    LOG_EVENT_CONTRACT_BID_PLACED.message("bid: 1001")
                ]
            );

            let receipts = deserialize_receipts();
            assert_eq!(&receipts[0].receiver_id, BUYER_2);
            match &receipts[0].actions[0] {
                Action::Transfer(transfer) => assert_eq!(transfer.deposit, 1000),
                _ => panic!("expected TransferAction"),
            }
        }
    }
}

#[cfg(test)]
mod tests_cancel_contract_sale {
    use super::*;
    use near_sdk::test_utils;
    use oysterpack_smart_near::component::*;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    const OWNER: &str = "owner";

    #[test]
    fn cancel_prior_sale() {
        // Arrange
        let mut ctx = new_context(OWNER);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ContractSaleComponent.ops_contract_sell(YOCTO.into());

        // Act
        ContractSaleComponent.ops_contract_cancel_sale();

        // Assert
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(
            logs,
            vec![
                LOG_EVENT_CONTRACT_FOR_SALE.message(YOCTO),
                LOG_EVENT_CONTRACT_SALE_CANCELLED.message("")
            ]
        );
    }

    #[test]
    fn no_prior_sale() {
        // Arrange
        let mut ctx = new_context(OWNER);
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());

        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        // Act
        ContractSaleComponent.ops_contract_cancel_sale();

        // Assert
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        let logs = test_utils::get_logs();
        assert!(logs.is_empty());
    }
}

#[cfg(test)]
mod tests_raise_contract_bid {
    use super::*;
    use oysterpack_smart_near::component::*;
    use oysterpack_smart_near::domain::ExpirationDuration;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    const OWNER: &str = "owner";
    const BUYER: &str = "buyer";

    #[test]
    #[should_panic(expected = "[ERR] [NO_ACTIVE_BID]")]
    fn no_prior_bid() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = YOCTO;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_raise_bid(None);
    }

    #[test]
    #[should_panic(expected = "[ERR] [ACCESS_DENIED_MUST_BE_BUYER]")]
    fn not_current_bidder() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = "BUYER2".to_string();
        ctx.attached_deposit = YOCTO;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_raise_bid(None);
    }

    #[test]
    #[should_panic(
        expected = "[ERR] [NEAR_DEPOSIT_REQUIRED] NEAR deposit is required - bid raise cannot be zero"
    )]
    fn with_zero_deposit_attached() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1000;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.attached_deposit = 0;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_raise_bid(None);
    }

    #[test]
    fn prexisting_bid_with_no_sale_price() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1000;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.attached_deposit = 500;
        testing_env!(ctx.clone());
        // Act
        let raised_bid = ContractSaleComponent.ops_contract_raise_bid(None);

        // Assert
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.bid.amount, 1500.into());
        assert_eq!(raised_bid, bid.bid);
    }

    #[test]
    fn prexisting_bid_and_raise_triggers_buy() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1000;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = OWNER.to_string();
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(1500.into());

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 500;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_raise_bid(None);

        // Assert
        assert!(ContractSaleComponent.ops_contract_bid().is_none());
        assert!(ContractSaleComponent.ops_contract_sale_price().is_none());
        assert_eq!(
            ContractOwnershipComponent.ops_owner(),
            ctx.predecessor_account_id
        );
    }

    #[test]
    fn prexisting_bid_with_higher_sale_price() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1000;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = OWNER.to_string();
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_sell(2500.into());

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 500;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_raise_bid(None);

        // Assert
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.bid.amount, 1500.into());
    }

    #[test]
    fn prexisting_bid_with_expiration() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1000;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.attached_deposit = 500;
        ctx.epoch_height = 10;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_raise_bid(Some(ExpirationSetting::Relative(
            ExpirationDuration::Epochs(10),
        )));

        // Assert
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.bid.amount, 1500.into());
        match bid.bid.expiration.unwrap() {
            Expiration::Epoch(epoch) => assert_eq!(epoch, 20.into()),
            _ => panic!("expected Expiration::Epoch"),
        }
    }

    #[test]
    fn prexisting_bid_with_prior_expiration_set() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1000;
        ctx.epoch_height = 10;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(Some(ExpirationSetting::Relative(
            ExpirationDuration::Epochs(10),
        )));

        ctx.attached_deposit = 500;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_raise_bid(None);

        // Assert
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.bid.amount, 1500.into());
        match bid.bid.expiration.unwrap() {
            Expiration::Epoch(epoch) => assert_eq!(epoch, 20.into()),
            _ => panic!("expected Expiration::Epoch"),
        }
    }

    #[test]
    #[should_panic(expected = "[ERR] [BID_IS_EXPIRED]")]
    fn bid_expired() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1000;
        ctx.epoch_height = 10;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(Some(ExpirationSetting::Relative(
            ExpirationDuration::Epochs(10),
        )));

        ctx.attached_deposit = 500;
        ctx.epoch_height = 100;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_raise_bid(None);
    }
}

#[cfg(test)]
mod tests_lower_contract_bid {
    use super::*;
    use oysterpack_smart_near::component::*;
    use oysterpack_smart_near::domain::ExpirationDuration;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    const OWNER: &str = "owner";
    const BUYER: &str = "buyer";

    #[test]
    fn lowered() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        // Act
        let lowered_bid = ContractSaleComponent.ops_contract_lower_bid(YOCTO.into(), None);

        // Assert
        assert_eq!(
            ContractSaleComponent.ops_contract_bid().unwrap().bid.amount,
            (9 * YOCTO).into()
        );
        assert_eq!(
            lowered_bid,
            ContractSaleComponent.ops_contract_bid().unwrap().bid
        );
    }

    #[test]
    fn lowered_with_new_expiration() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.attached_deposit = 1;
        ctx.block_index = 10;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_lower_bid(
            YOCTO.into(),
            Some(ExpirationSetting::Relative(ExpirationDuration::Blocks(10))),
        );

        // Assert
        assert_eq!(
            ContractSaleComponent.ops_contract_bid().unwrap().bid.amount,
            (9 * YOCTO).into()
        );
        match ContractSaleComponent
            .ops_contract_bid()
            .unwrap()
            .bid
            .expiration
            .unwrap()
        {
            Expiration::Block(block) => assert_eq!(block, 20.into()),
            _ => panic!("expected expiration on block"),
        }
    }

    #[test]
    #[should_panic(expected = "[ERR] [NO_ACTIVE_BID]")]
    fn no_bid() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_lower_bid(YOCTO.into(), None);
    }

    #[test]
    #[should_panic(expected = "[ERR] [BID_IS_EXPIRED]")]
    fn prior_bid_expired() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = YOCTO;
        ctx.epoch_height = 5;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_buy(Some(ExpirationSetting::Absolute(
            Expiration::Epoch(10.into()),
        )));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1;
        ctx.epoch_height = 11;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_lower_bid(100.into(), None);
    }

    #[test]
    #[should_panic(expected = "[ERR] [BAD_REQUEST] expiration cannot be set to expired")]
    fn with_expired_expiration() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = YOCTO;
        ctx.epoch_height = 5;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1;
        ctx.epoch_height = 11;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_lower_bid(
            100.into(),
            Some(ExpirationSetting::Absolute(Expiration::Epoch(10.into()))),
        );
    }

    #[test]
    #[should_panic(expected = "[ERR] [ACCESS_DENIED_MUST_BE_BUYER]")]
    fn not_buyer() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = "OTHER".to_string();
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_lower_bid(YOCTO.into(), None);
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn zero_deposit() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 0;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_lower_bid(YOCTO.into(), None);
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn two_deposit() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 2;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_lower_bid(YOCTO.into(), None);
    }

    #[test]
    #[should_panic(expected = "[ERR] [BAD_REQUEST] bid cannot be zero")]
    fn lower_to_zero() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_lower_bid((10 * YOCTO).into(), None);
    }

    #[test]
    #[should_panic(expected = "[ERR] [BAD_REQUEST] bid cannot be zero")]
    fn overflow() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_lower_bid((11 * YOCTO).into(), None);
    }
}

#[cfg(test)]
mod tests_contract_bid_expiration {
    use super::*;
    use oysterpack_smart_near::component::*;
    use oysterpack_smart_near::domain::ExpirationDuration;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    const OWNER: &str = "owner";
    const BUYER: &str = "buyer";

    #[test]
    fn update() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.attached_deposit = 1;
        ctx.block_timestamp = 100;
        testing_env!(ctx.clone());
        // Act
        let expiration = ExpirationSetting::Relative(ExpirationDuration::Seconds(60));
        ContractSaleComponent.ops_contract_update_bid_expiration(expiration);

        // Assert
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert_eq!(bid.bid.expiration, Some(expiration.into()));
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn update_zero_deposit() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.attached_deposit = 0;
        ctx.block_timestamp = 100;
        testing_env!(ctx.clone());
        // Act
        let expiration = ExpirationSetting::Relative(ExpirationDuration::Seconds(60));
        ContractSaleComponent.ops_contract_update_bid_expiration(expiration);
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn update_two_deposit() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.attached_deposit = 2;
        ctx.block_timestamp = 100;
        testing_env!(ctx.clone());
        // Act
        let expiration = ExpirationSetting::Relative(ExpirationDuration::Seconds(60));
        ContractSaleComponent.ops_contract_update_bid_expiration(expiration);
    }

    #[test]
    #[should_panic(expected = "[ERR] [ACCESS_DENIED_MUST_BE_BUYER]")]
    fn update_not_buyer() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = "OTHER".to_string();
        ctx.attached_deposit = 1;
        ctx.block_timestamp = 100;
        testing_env!(ctx.clone());
        // Act
        let expiration = ExpirationSetting::Relative(ExpirationDuration::Seconds(60));
        ContractSaleComponent.ops_contract_update_bid_expiration(expiration);
    }

    #[test]
    #[should_panic(expected = "[ERR] [BAD_REQUEST] expiration cannot be set to expired")]
    fn update_with_expired_setting() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        ContractSaleComponent.ops_contract_buy(None);

        ctx.predecessor_account_id = "OTHER".to_string();
        ctx.attached_deposit = 1;
        ctx.block_timestamp = 100;
        testing_env!(ctx.clone());
        // Act
        let expiration = ExpirationSetting::Absolute(Expiration::Timestamp(60.into()));
        ContractSaleComponent.ops_contract_update_bid_expiration(expiration);
    }

    #[test]
    fn clear() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        let expiration = ExpirationSetting::Relative(ExpirationDuration::Seconds(60));
        ContractSaleComponent.ops_contract_buy(Some(expiration));

        ctx.attached_deposit = 1;
        ctx.block_timestamp = 100;
        testing_env!(ctx.clone());
        // Act

        ContractSaleComponent.ops_contract_clear_bid_expiration();

        // Assert
        let bid = ContractSaleComponent.ops_contract_bid().unwrap();
        assert!(bid.bid.expiration.is_none());
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn clear_zero_deposit() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        let expiration = ExpirationSetting::Relative(ExpirationDuration::Seconds(60));
        ContractSaleComponent.ops_contract_buy(Some(expiration));

        ctx.attached_deposit = 0;
        ctx.block_timestamp = 100;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_clear_bid_expiration();
    }

    #[test]
    #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
    fn clear_two_deposit() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        let expiration = ExpirationSetting::Relative(ExpirationDuration::Seconds(60));
        ContractSaleComponent.ops_contract_buy(Some(expiration));

        ctx.attached_deposit = 2;
        ctx.block_timestamp = 100;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_clear_bid_expiration();
    }

    #[test]
    #[should_panic(expected = "[ERR] [ACCESS_DENIED_MUST_BE_BUYER]")]
    fn clear_not_buyer() {
        // Arrange
        let mut ctx = new_context(OWNER);
        testing_env!(ctx.clone());
        ContractOwnershipComponent::deploy(to_valid_account_id(OWNER));

        ctx.predecessor_account_id = BUYER.to_string();
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx.clone());
        let expiration = ExpirationSetting::Relative(ExpirationDuration::Seconds(60));
        ContractSaleComponent.ops_contract_buy(Some(expiration));

        ctx.predecessor_account_id = "BUYER2".to_string();
        ctx.attached_deposit = 1;
        ctx.block_timestamp = 100;
        testing_env!(ctx.clone());
        // Act
        ContractSaleComponent.ops_contract_clear_bid_expiration();
    }
}

'''
'''--- near/oysterpack-smart-contract/src/domain.rs ---
pub use contract_bid::*;
pub use contract_near_balances::*;
pub use contract_owner::*;
pub use contract_storage_usage::*;
pub use contract_storage_usage_costs::*;

mod contract_bid;
mod contract_near_balances;
mod contract_owner;
mod contract_storage_usage;
mod contract_storage_usage_costs;

'''
'''--- near/oysterpack-smart-contract/src/domain/contract_bid.rs ---
use crate::{BalanceId, ContractNearBalances, ERR_BID_IS_EXPIRED};
use oysterpack_smart_near::domain::{Expiration, ExpirationSetting, YoctoNear};
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};

#[derive(
    BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy, Debug, PartialEq,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct ContractBid {
    pub amount: YoctoNear,
    pub expiration: Option<Expiration>,
}

impl ContractBid {
    pub fn expired(&self) -> bool {
        self.expiration
            .map_or(false, |expiration| expiration.expired())
    }

    pub fn assert_not_expired(&self) {
        ERR_BID_IS_EXPIRED.assert(|| !self.expired());
    }

    /// ## Panics
    /// if bid becomes expired
    pub(crate) fn update_expiration(&mut self, expiration: Option<ExpirationSetting>) {
        if let Some(expiration) = expiration {
            let expiration: Expiration = expiration.into();
            ERR_BID_IS_EXPIRED.assert(|| !expiration.expired());
            self.expiration = Some(expiration);
        }
    }

    /// Used to track the contract bid on the contract NEAR balance
    pub const CONTRACT_BID_BALANCE_ID: BalanceId = BalanceId(255);

    pub fn near_balance() -> YoctoNear {
        ContractNearBalances::near_balance(Self::CONTRACT_BID_BALANCE_ID)
    }

    pub(crate) fn set_near_balance(bid: YoctoNear) {
        ContractNearBalances::set_balance(Self::CONTRACT_BID_BALANCE_ID, bid);
    }

    pub(crate) fn incr_near_balance(amount: YoctoNear) {
        ContractNearBalances::incr_balance(Self::CONTRACT_BID_BALANCE_ID, amount);
    }

    pub(crate) fn decr_near_balance(amount: YoctoNear) {
        ContractNearBalances::decr_balance(Self::CONTRACT_BID_BALANCE_ID, amount);
    }

    pub(crate) fn clear_near_balance() {
        ContractNearBalances::clear_balance(Self::CONTRACT_BID_BALANCE_ID);
    }
}

'''
'''--- near/oysterpack-smart-contract/src/domain/contract_near_balances.rs ---
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    serde::{Deserialize, Serialize},
};
use oysterpack_smart_near::{data::Object, domain::YoctoNear};
use std::{collections::HashMap, ops::Deref};

/// Balance ID is used to track separate NEAR balances
/// - use ULID to generate unique IDs to avoid collisions between components
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Deserialize,
    Serialize,
    Clone,
    Copy,
    Debug,
    PartialOrd,
    PartialEq,
    Eq,
    Hash,
    Default,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct BalanceId(pub u128);

/// used to track NEAR balances that are outside registered accounts - examples
/// - liquidity
/// - profit sharing fund
pub type NearBalances = HashMap<BalanceId, YoctoNear>;

/// Provides a breakdown of the contract's NEAR balances
#[derive(
    BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone, Debug, PartialEq, Default,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct ContractNearBalances {
    total: YoctoNear,
    accounts: YoctoNear,
    balances: Option<NearBalances>,
    owner: YoctoNear,
    locked: YoctoNear,
}

impl ContractNearBalances {
    pub fn new(accounts: YoctoNear, balances: Option<NearBalances>) -> Self {
        let locked: YoctoNear = env::account_locked_balance().into();
        let total: YoctoNear = locked + env::account_balance();

        let total_contract_near_balances: YoctoNear =
            balances.as_ref().map_or(YoctoNear::ZERO, |balances| {
                balances
                    .values()
                    .map(|balance| balance.value())
                    .sum::<u128>()
                    .into()
            });

        let owner = total - accounts - total_contract_near_balances;

        Self {
            total,
            accounts,
            balances,
            owner,
            locked,
        }
    }

    pub fn total(&self) -> YoctoNear {
        self.total
    }

    pub fn accounts(&self) -> YoctoNear {
        self.accounts
    }

    /// NEAR balances that are not owned by registered accounts and not by the contract owner, e.g.,
    /// - liquidity pools
    /// - batched funds, e.g., STAKE batches
    /// - profit sharing funds
    pub fn balances(&self) -> Option<NearBalances> {
        self.balances.as_ref().map(|balances| balances.clone())
    }

    /// returns portion of total contract NEAR balance that is owned by the contract owner, which is
    /// computed as: `total - locked - accounts - balances`
    pub fn owner(&self) -> YoctoNear {
        self.owner
    }

    /// balance locked for validator staking
    pub fn locked(&self) -> YoctoNear {
        self.locked
    }
}

const NEAR_BALANCES_KEY: u128 = 1953121181530803691069739592144632957;

type DAO = Object<u128, NearBalances>;

impl ContractNearBalances {
    pub fn load_near_balances() -> NearBalances {
        DAO::load(&NEAR_BALANCES_KEY)
            .map_or_else(NearBalances::new, |object| object.deref().clone())
    }

    pub fn near_balance(id: BalanceId) -> YoctoNear {
        DAO::load(&NEAR_BALANCES_KEY).map_or(YoctoNear::ZERO, |object| {
            object.get(&id).cloned().unwrap_or(YoctoNear::ZERO)
        })
    }

    /// Increments the balance by the specified amount and returns the updated balance
    pub fn incr_balance(id: BalanceId, amount: YoctoNear) -> YoctoNear {
        let mut balances = DAO::load(&NEAR_BALANCES_KEY)
            .unwrap_or_else(|| DAO::new(NEAR_BALANCES_KEY, NearBalances::new()));
        let mut balance = balances.get(&id).cloned().unwrap_or(YoctoNear::ZERO);
        balance += amount;
        balances.insert(id, balance);
        balances.save();
        balance
    }

    /// Decrements the balance by the specified amount and returns the updated balance
    pub fn decr_balance(id: BalanceId, amount: YoctoNear) -> YoctoNear {
        let mut balances = DAO::load(&NEAR_BALANCES_KEY)
            .unwrap_or_else(|| DAO::new(NEAR_BALANCES_KEY, NearBalances::new()));
        let mut balance = balances.get(&id).cloned().unwrap_or(YoctoNear::ZERO);
        balance -= amount;
        if balance == YoctoNear::ZERO {
            balances.remove(&id);
        } else {
            balances.insert(id, balance);
        }
        balances.save();
        balance
    }

    /// Sets the balance to the specified amount and returns the updated balance
    pub fn set_balance(id: BalanceId, amount: YoctoNear) {
        let mut balances = DAO::load(&NEAR_BALANCES_KEY)
            .unwrap_or_else(|| DAO::new(NEAR_BALANCES_KEY, NearBalances::new()));
        if amount == YoctoNear::ZERO {
            balances.remove(&id);
        } else {
            balances.insert(id, amount);
        }
        balances.save();
    }

    /// Clears the balance and removes the record from storage
    pub fn clear_balance(id: BalanceId) {
        let mut balances = DAO::load(&NEAR_BALANCES_KEY)
            .unwrap_or_else(|| DAO::new(NEAR_BALANCES_KEY, NearBalances::new()));
        balances.remove(&id);
        balances.save();
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near::near_sdk::test_utils::test_env;
    use oysterpack_smart_near::YOCTO;

    const LIQUIDITY_BALANCE_ID: BalanceId = BalanceId(0);
    const EARNINGS_BALANCE_ID: BalanceId = BalanceId(1);

    #[test]
    fn contract_near_balances() {
        // Arrange
        test_env::setup();

        let balances = ContractNearBalances::load_near_balances();
        assert!(balances.is_empty());

        // Act - increment balances
        ContractNearBalances::incr_balance(LIQUIDITY_BALANCE_ID, YOCTO.into());
        ContractNearBalances::incr_balance(LIQUIDITY_BALANCE_ID, YOCTO.into());
        ContractNearBalances::incr_balance(LIQUIDITY_BALANCE_ID, YOCTO.into());
        ContractNearBalances::incr_balance(EARNINGS_BALANCE_ID, (2 * YOCTO).into());

        // Assert
        let balances = ContractNearBalances::load_near_balances();
        assert_eq!(balances.len(), 2);
        assert_eq!(
            balances.get(&LIQUIDITY_BALANCE_ID).unwrap().value(),
            3 * YOCTO
        );
        assert_eq!(
            balances.get(&EARNINGS_BALANCE_ID).unwrap().value(),
            2 * YOCTO
        );

        // Act - decrement balances
        ContractNearBalances::decr_balance(LIQUIDITY_BALANCE_ID, YOCTO.into());
        ContractNearBalances::decr_balance(EARNINGS_BALANCE_ID, YOCTO.into());

        // Assert
        let balances = ContractNearBalances::load_near_balances();
        assert_eq!(balances.len(), 2);
        assert_eq!(
            balances.get(&LIQUIDITY_BALANCE_ID).unwrap().value(),
            2 * YOCTO
        );
        assert_eq!(balances.get(&EARNINGS_BALANCE_ID).unwrap().value(), YOCTO);

        // Act - decrement balances
        ContractNearBalances::set_balance(LIQUIDITY_BALANCE_ID, (10 * YOCTO).into());
        ContractNearBalances::set_balance(EARNINGS_BALANCE_ID, (20 * YOCTO).into());

        // Assert
        let balances = ContractNearBalances::load_near_balances();
        assert_eq!(balances.len(), 2);
        assert_eq!(
            balances.get(&LIQUIDITY_BALANCE_ID).unwrap().value(),
            10 * YOCTO
        );
        assert_eq!(
            balances.get(&EARNINGS_BALANCE_ID).unwrap().value(),
            20 * YOCTO
        );

        // Act - decrement balances
        ContractNearBalances::clear_balance(LIQUIDITY_BALANCE_ID);

        // Assert
        let balances = ContractNearBalances::load_near_balances();
        assert_eq!(balances.len(), 1);
        assert!(!balances.contains_key(&LIQUIDITY_BALANCE_ID));
        assert_eq!(
            balances.get(&EARNINGS_BALANCE_ID).unwrap().value(),
            20 * YOCTO
        );
    }
}

'''
'''--- near/oysterpack-smart-contract/src/domain/contract_owner.rs ---
use crate::{
    ContractBid, ERR_CONTRACT_OWNER_TRANSFER_NOT_INITIATED,
    ERR_CURRENT_OR_PROSPECTIVE_OWNER_ACCESS_REQUIRED, ERR_OWNER_ACCESS_REQUIRED,
    ERR_PROSPECTIVE_OWNER_ACCESS_REQUIRED,
};
use oysterpack_smart_near::domain::{AccountIdHash, YoctoNear};
use oysterpack_smart_near::near_sdk::json_types::ValidAccountId;
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env, AccountId,
};
use oysterpack_smart_near::{data::Object, ErrCode, ErrorConst};
use std::ops::{Deref, DerefMut};

/// Indicates that an attempt was made to initialize the contract with a different owner.
///
/// A contract can only be initialized, i.e., seeded, with the contract owner once after the contract
/// is deployed.
/// - see [`ContractOwnerObject::initialize_contract`]
pub const ERR_CONTRACT_OWNER_ALREADY_INITIALIZED: ErrorConst = ErrorConst(
    ErrCode("CONTRACT_OWNER_ALREADY_INITIALIZED"),
    "contract owner is already initialized with a different owner",
);

const CONTRACT_OWNER_KEY: u128 = 1952995667402400813184690843862547707;

type DAO = Object<u128, ContractOwner>;

pub struct ContractOwnerObject(DAO);

impl ContractOwnerObject {
    pub fn load() -> Self {
        Self(DAO::load(&CONTRACT_OWNER_KEY).unwrap())
    }

    /// Used to initialize the contract with the specified owner.
    ///
    /// ## Panics
    /// if the contract owner has already been initialized with a different owner
    pub fn initialize_contract(account_id: ValidAccountId) {
        let owner = DAO::new(CONTRACT_OWNER_KEY, ContractOwner::new(account_id.clone()));
        match DAO::load(&CONTRACT_OWNER_KEY) {
            Some(current_owner) => {
                ERR_CONTRACT_OWNER_ALREADY_INITIALIZED.assert(|| current_owner == owner)
            }
            None => {
                owner.save();
                let account_ids = ContractOwnershipAccountIds {
                    owner: account_id.as_ref().clone(),
                    prospective_owner: None,
                    buyer: None,
                };
                Object::new(CONTRACT_ACCOUNT_IDS_KEY, account_ids).save();
            }
        }
    }

    /// asserts that the predecessor account ID is the owner
    pub fn assert_owner_access() -> Self {
        let owner = Self::load();
        ERR_OWNER_ACCESS_REQUIRED.assert(|| {
            owner.account_id_hash() == AccountIdHash::from(env::predecessor_account_id())
        });
        owner
    }

    /// returns true if the predecessor account is the owner
    pub fn is_owner() -> bool {
        let owner = Self::load();
        owner.account_id_hash() == AccountIdHash::from(env::predecessor_account_id().as_str())
    }

    /// asserts that a contract transfer is in progress and the predecessor account ID is the
    /// prospective owner
    pub fn assert_prospective_owner_access() -> Self {
        let owner = Self::load();
        ERR_CONTRACT_OWNER_TRANSFER_NOT_INITIATED
            .assert(|| owner.prospective_owner_account_id_hash.is_some());
        ERR_PROSPECTIVE_OWNER_ACCESS_REQUIRED.assert(|| {
            owner
                .prospective_owner_account_id_hash()
                .map_or(false, |account_id_hash| {
                    account_id_hash == AccountIdHash::from(env::predecessor_account_id())
                })
        });
        owner
    }

    /// asserts that the predecessor account ID is the current or prospective owner
    pub fn assert_current_or_prospective_owner_access() -> Self {
        let owner = Self::load();
        ERR_CURRENT_OR_PROSPECTIVE_OWNER_ACCESS_REQUIRED.assert(|| {
            owner.account_id_hash() == AccountIdHash::from(env::predecessor_account_id())
                || owner
                    .prospective_owner_account_id_hash()
                    .map_or(false, |account_id_hash| {
                        account_id_hash == AccountIdHash::from(env::predecessor_account_id())
                    })
        });
        owner
    }
}

impl Deref for ContractOwnerObject {
    type Target = DAO;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for ContractOwnerObject {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

/// Every contract has an owner
#[derive(BorshSerialize, BorshDeserialize, Clone, Copy, Debug, PartialEq)]
pub struct ContractOwner {
    pub(crate) account_id_hash: AccountIdHash,

    pub(crate) prospective_owner_account_id_hash: Option<AccountIdHash>,

    pub(crate) sale_price: Option<YoctoNear>,
    pub(crate) bid: Option<(AccountIdHash, ContractBid)>,
}

impl ContractOwner {
    pub fn new(account_id: ValidAccountId) -> Self {
        Self {
            account_id_hash: account_id.into(),
            prospective_owner_account_id_hash: None,
            sale_price: None,
            bid: None,
        }
    }

    pub fn account_id_hash(&self) -> AccountIdHash {
        self.account_id_hash
    }

    pub fn prospective_owner_account_id_hash(&self) -> Option<AccountIdHash> {
        self.prospective_owner_account_id_hash
    }

    /// if true, then it means that the transfer is awaiting finalization from the prospective owner
    pub fn transfer_initiated(&self) -> bool {
        self.prospective_owner_account_id_hash.is_some()
    }

    pub fn contract_sale_price(&self) -> Option<YoctoNear> {
        self.sale_price.as_ref().cloned()
    }

    pub fn bid(&self) -> Option<(AccountIdHash, ContractBid)> {
        self.bid.as_ref().cloned()
    }
}

const CONTRACT_ACCOUNT_IDS_KEY: u128 = 1953243214138465698448969404106238471;

type ContractOwnershipAccountIdsDAO = Object<u128, ContractOwnershipAccountIds>;

pub(crate) struct ContractOwnershipAccountIdsObject(ContractOwnershipAccountIdsDAO);

impl ContractOwnershipAccountIdsObject {
    pub fn load() -> Self {
        Self(ContractOwnershipAccountIdsDAO::load(&CONTRACT_ACCOUNT_IDS_KEY).unwrap())
    }
}

impl Deref for ContractOwnershipAccountIdsObject {
    type Target = ContractOwnershipAccountIdsDAO;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for ContractOwnershipAccountIdsObject {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

/// The contract ownership account IDs are being stored separately to avoid heap allocations when
/// using [`ContractOwner`], which enables it to be used by value vs by ref.
///
/// We need the account IDs to be able to transfer NEAR funds to the accounts
#[derive(BorshSerialize, BorshDeserialize, Clone, PartialEq, Debug)]
pub(crate) struct ContractOwnershipAccountIds {
    pub owner: AccountId,
    pub prospective_owner: Option<AccountId>,
    pub buyer: Option<AccountId>,
}

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near_test::*;

    #[test]
    fn is_not_owner() {
        let account = "bob";
        let ctx = new_context(account);

        testing_env!(ctx.clone());
        ContractOwnerObject::initialize_contract(to_valid_account_id("alice"));
        assert!(!ContractOwnerObject::is_owner());
    }

    #[test]
    fn is_owner() {
        let account = "bob";
        let ctx = new_context(account);

        testing_env!(ctx.clone());
        ContractOwnerObject::initialize_contract(to_valid_account_id(account));
        assert!(ContractOwnerObject::is_owner());
    }
}

'''
'''--- near/oysterpack-smart-contract/src/domain/contract_storage_usage.rs ---
use crate::ContractStorageUsageCosts;
use oysterpack_smart_near::domain::StorageUsage;
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};

/// Reports a breakdown of contract storage usage
#[derive(
    BorshSerialize, BorshDeserialize, Deserialize, Serialize, Copy, Clone, Debug, PartialEq, Default,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct ContractStorageUsage {
    total: StorageUsage,
    accounts: StorageUsage,
}

impl ContractStorageUsage {
    pub fn new(accounts: StorageUsage) -> Self {
        Self {
            total: StorageUsage::from_env(),
            accounts,
        }
    }

    /// total contract storage usage
    pub fn total(&self) -> StorageUsage {
        self.total
    }

    /// storage usage that is owned by all accounts registered with the contract
    pub fn accounts(&self) -> StorageUsage {
        self.accounts
    }

    /// returns the storage usage that the contract owner is responsible to pay for
    pub fn owner(&self) -> StorageUsage {
        self.total - self.accounts
    }

    pub fn costs(&self) -> ContractStorageUsageCosts {
        ContractStorageUsageCosts::from(*self)
    }
}

'''
'''--- near/oysterpack-smart-contract/src/domain/contract_storage_usage_costs.rs ---
use crate::ContractStorageUsage;
use oysterpack_smart_near::domain::YoctoNear;
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    serde::{Deserialize, Serialize},
};

/// Reports a breakdown of contract storage usage staking costs
#[derive(
    BorshSerialize, BorshDeserialize, Deserialize, Serialize, Copy, Clone, Debug, PartialEq, Default,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct ContractStorageUsageCosts {
    total: YoctoNear,
    accounts: YoctoNear,
    owner: YoctoNear,
}

impl ContractStorageUsageCosts {
    pub fn new(accounts: YoctoNear) -> Self {
        let total: YoctoNear = env::account_balance().into();
        Self {
            total,
            accounts,
            owner: total - accounts,
        }
    }

    /// total contract storage usage
    pub fn total(&self) -> YoctoNear {
        self.total
    }

    /// storage usage that is owned by all accounts registered with the contract
    pub fn accounts(&self) -> YoctoNear {
        self.accounts
    }

    /// returns the storage usage that the contract owner is responsible to pay for
    pub fn owner(&self) -> YoctoNear {
        self.owner
    }
}

impl From<ContractStorageUsage> for ContractStorageUsageCosts {
    fn from(storage_usage: ContractStorageUsage) -> Self {
        Self {
            total: storage_usage.total().cost(),
            accounts: storage_usage.accounts().cost(),
            owner: storage_usage.owner().cost(),
        }
    }
}

'''
'''--- near/oysterpack-smart-contract/src/interface.rs ---
pub use contract::contract_metrics::*;
pub use contract::contract_operator::*;
pub use contract::contract_ownership::*;
pub use contract::contract_sale::*;

pub mod contract;

'''
'''--- near/oysterpack-smart-contract/src/interface/contract.rs ---
//! Contract Interfaces
pub mod contract_metrics;
pub mod contract_operator;
pub mod contract_ownership;
pub mod contract_sale;

'''
'''--- near/oysterpack-smart-contract/src/interface/contract/contract_metrics.rs ---
use crate::{ContractNearBalances, ContractStorageUsage, ContractStorageUsageCosts};
use oysterpack_smart_account_management::AccountMetrics;
use oysterpack_smart_near::data::numbers::U128;
use oysterpack_smart_near::domain::BlockTime;
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};

/// # **Contract Interface**: Contract Metrics API
/// Provides metrics that track storage usage and NEAR balances
pub trait ContractMetrics {
    fn ops_metrics_total_registered_accounts(&self) -> U128;

    fn ops_metrics_contract_storage_usage(&self) -> ContractStorageUsage;

    fn ops_metrics_near_balances(&self) -> ContractNearBalances;

    fn ops_metrics_storage_usage_costs(&self) -> ContractStorageUsageCosts;

    fn ops_metrics(&self) -> ContractMetricsSnapshot;

    fn ops_metrics_accounts(&self) -> AccountMetrics;
}

/// Provides a point in time metrics snapshot
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone, Debug, PartialEq)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct ContractMetricsSnapshot {
    pub block_time: BlockTime,
    pub total_registered_accounts: U128,
    pub storage_usage: ContractStorageUsage,
    pub near_balances: ContractNearBalances,
    pub storage_usage_costs: ContractStorageUsageCosts,
}

'''
'''--- near/oysterpack-smart-contract/src/interface/contract/contract_operator.rs ---
use crate::BalanceId;
use oysterpack_smart_near::domain::StorageUsage;

pub trait ContractOperator {
    /// Locks a portion of the contract's balance to reserve to pay for contract storage usage.
    ///
    /// The main use case is to lock enough contract balance to ensure the contract has enough balance to
    /// operate, i.e., pay for contract storage. This would prevent the contract owner from withdrawing
    /// all of his available balance, which might break the contract.
    ///
    /// setting the storage usage to zero, effectively unlocks the storage balance
    ///
    /// ## Panics
    /// - requires operator permission
    fn ops_operator_lock_storage_balance(&mut self, storage_usage: StorageUsage);

    /// Allows the owner to grants admin permission himself
    ///
    /// The owner should always be able to have admin access. If the admin permission was revoked
    /// from the owner, then this enables the owner to grant admin to himself.
    ///
    /// ## Panics
    /// If not invoked by the owner account
    fn ops_owner_grant_admin(&mut self);
}

/// used by ['ContractOwnership::ops_owner_lock_balance`]
pub const CONTRACT_LOCKED_STORAGE_BALANCE: BalanceId =
    BalanceId(1955299460766524333040021403508226880);

'''
'''--- near/oysterpack-smart-contract/src/interface/contract/contract_ownership.rs ---
use oysterpack_smart_near::domain::YoctoNear;
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    json_types::ValidAccountId,
    serde::{Deserialize, Serialize},
    AccountId,
};
use oysterpack_smart_near::{ErrCode, ErrorConst, Level, LogEvent};

/// # **Contract Interface**: Contract Ownership API
/// Every contract has an owner
pub trait ContractOwnership {
    /// returns the contract owner account ID
    fn ops_owner(&self) -> AccountId;

    /// Returns how much of the contract's NEAR balance is owned by the contract owner and what amount
    /// is available for withdrawal.
    ///
    /// The owner must retain enough NEAR deposit on the contract to cover storage costs that are
    /// the contract's responsibility to pay for, i.e., excluding account storage.
    fn ops_owner_balance(&self) -> ContractOwnerNearBalance;

    /// Returns the prospective owner that the transfer is waiting on for finalization.
    ///
    /// Returns None if there is no ownership transfer in progress.
    fn ops_owner_prospective(&self) -> Option<AccountId>;

    /// Initiates the workflow to transfer contract ownership.
    ///
    /// The ownership transfer is not finalized until the new owner finalizes the transfer.
    /// This avoids transferring transferring contract ownership to a non-existent account ID.
    ///
    /// ## NOTES
    /// - any open contract sale is cancelled
    /// - any active bid is cancelled
    ///
    /// ## Log Event
    /// [`LOG_EVENT_CONTRACT_TRANSFER_INITIATED`]
    ///
    /// ## Panics
    /// - `ERR_OWNER_ACCESS_REQUIRED` - if the predecessor account is not the owner account
    /// - `ERR_YOCTONEAR_DEPOSIT_REQUIRED` - if 1 yoctoNEAR is not attached
    /// - if the new owner account ID is not valid
    ///
    /// `#[payable]` - requires exactly 1 yoctoNEAR to be attached
    fn ops_owner_transfer(&mut self, new_owner: ValidAccountId);

    /// Enables the transfer to be cancelled before it is finalized.
    ///
    /// The transfer can only be cancelled by both the current owner and the prospective owner.
    ///
    /// ## Log Event
    /// [`LOG_EVENT_CONTRACT_TRANSFER_CANCELLED`]
    ///
    /// ## Panics
    /// - `ERR_CURRENT_OR_PROSPECTIVE_OWNER_ACCESS_REQUIRED` - if the predecessor account is not the current or prospective owner account
    /// - `ERR_YOCTONEAR_DEPOSIT_REQUIRED` - if 1 yoctoNEAR is not attached
    ///
    /// `#[payable]` - requires exactly 1 yoctoNEAR to be attached
    fn ops_owner_cancel_transfer(&mut self);

    /// Used to finalize the contract transfer to the new prospective owner
    ///
    /// ## Notes
    /// This effectively transfers any owner balance to the new owner. The owner can withdraw
    /// from its available balance before the transfer is finalized.
    ///
    /// ## Log Event
    /// [`LOG_EVENT_CONTRACT_TRANSFER_FINALIZED`]
    ///
    /// ## Panics
    /// - `ERR_PROSPECTIVE_OWNER_ACCESS_REQUIRED` - if the predecessor ID is not the new prospective owner
    /// - `ERR_CONTRACT_OWNER_TRANSFER_NOT_INITIATED` - if there is no contract ownership transfer in progress
    /// - `ERR_YOCTONEAR_DEPOSIT_REQUIRED` - if 1 yoctoNEAR is not attached
    ///
    /// `#[payable]` - requires exactly 1 yoctoNEAR to be attached
    fn ops_owner_finalize_transfer(&mut self);

    /// Used by the contract owner to withdraw from the contract owner's available balance.
    ///
    /// If `amount` is None, then all available balance is withdrawn.
    ///
    /// Returns the updated contract owner NEAR balance.
    ///
    /// ## Panics
    /// - `ERR_OWNER_ACCESS_REQUIRED` - if the predecessor account is not the owner account
    /// - `ERR_YOCTONEAR_DEPOSIT_REQUIRED` - if 1 yoctoNEAR is not attached
    /// - `ERR_OWNER_BALANCE_OVERDRAW` - if there are insufficient funds to fulfill the request
    /// - `ERR_CODE_BAD_REQUEST` - if specified amount is zero
    ///
    /// `#[payable]` - requires exactly 1 yoctoNEAR to be attached
    fn ops_owner_withdraw_balance(&mut self, amount: Option<YoctoNear>)
        -> ContractOwnerNearBalance;
}

/// log event for [`ContractOwnership::ops_owner_transfer`]
pub const LOG_EVENT_CONTRACT_TRANSFER_INITIATED: LogEvent =
    LogEvent(Level::INFO, "CONTRACT_TRANSFER_INITIATED");

/// log event for [`ContractOwnership::ops_owner_cancel_transfer`]
pub const LOG_EVENT_CONTRACT_TRANSFER_CANCELLED: LogEvent =
    LogEvent(Level::INFO, "CONTRACT_TRANSFER_CANCELLED");

/// log event for [`ContractOwnership::ops_owner_finalize_transfer`]
pub const LOG_EVENT_CONTRACT_TRANSFER_FINALIZED: LogEvent =
    LogEvent(Level::INFO, "CONTRACT_TRANSFER_FINALIZED");

/// Contract owner total and available balance
#[derive(
    BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone, Debug, PartialEq, Default,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct ContractOwnerNearBalance {
    pub total: YoctoNear,
    pub available: YoctoNear,
}

/// Indicates access was denied because owner access was required
pub const ERR_OWNER_ACCESS_REQUIRED: ErrorConst = ErrorConst(
    ErrCode("OWNER_ACCESS_REQUIRED"),
    "action requires owner access",
);

/// Indicates access was denied because prospective owner access was required
pub const ERR_PROSPECTIVE_OWNER_ACCESS_REQUIRED: ErrorConst = ErrorConst(
    ErrCode("PROSPECTIVE_OWNER_ACCESS_REQUIRED"),
    "action requires prospective owner access",
);

pub const ERR_CONTRACT_OWNER_TRANSFER_NOT_INITIATED: ErrorConst = ErrorConst(
    ErrCode("CONTRACT_OWNER_TRANSFER_NOT_INITIATED"),
    "contract ownership transfer has not been initiated",
);

/// Indicates access was denied because current or prospective owner access was required
pub const ERR_CURRENT_OR_PROSPECTIVE_OWNER_ACCESS_REQUIRED: ErrorConst = ErrorConst(
    ErrCode("CURRENT_OR_PROSPECTIVE_OWNER_ACCESS_REQUIRED"),
    "action requires current or prospective owner access",
);

pub const ERR_OWNER_BALANCE_OVERDRAW: ErrorConst = ErrorConst(
    ErrCode("OWNER_BALANCE_OVERDRAW"),
    "owner balance is insufficient to fulfill withdrawal",
);

'''
'''--- near/oysterpack-smart-contract/src/interface/contract/contract_sale.rs ---
use crate::ContractBid;
use oysterpack_smart_near::domain::{ExpirationSetting, YoctoNear};
use oysterpack_smart_near::near_sdk::{
    serde::{Deserialize, Serialize},
    AccountId,
};
use oysterpack_smart_near::{ErrCode, ErrorConst, Level, LogEvent};

/// # **Contract Interface**: Contract Sale API
/// Enables the contract to be transferred to a new owner via a sale.
///
/// When the sale transaction is executed, the sale amount will be released to the current owner and
/// all of the owner's balance will be transferred out of the contract to the owner's NEAR account.
///
/// TODO: enable buyers to pay with STAKE
pub trait ContractSale {
    /// Returns None if the contract is not listed for sale
    fn ops_contract_sale_price(&self) -> Option<YoctoNear>;

    /// Returns None if there is no current bid on the contract
    fn ops_contract_bid(&self) -> Option<ContractBuyerBid>;

    /// Puts up the contract for sale for the specified sale price.
    ///
    /// - If the contract is already for sale, then the sale price is updated to the new price.
    /// - If there already is a higher bid price, then the contract is sold for the bid price.
    /// - If the current bid is expired, then the bid is cancelled
    ///
    /// ## Log Events
    /// - [`LOG_EVENT_CONTRACT_FOR_SALE`]
    /// - [`LOG_EVENT_CONTRACT_BID_CANCELLED`] - if current bid has expired
    /// = [`LOG_EVENT_CONTRACT_SOLD`] - if the current bid is >= the sale price
    ///
    /// ## Panics
    /// - if the predecessor account is not the owner account
    /// - if 1 yoctoNEAR is not attached
    /// - if `price` is zero
    /// - if contract transfer is in progress
    ///
    /// `#[payable]` - requires exactly 1 yoctoNEAR to be attached
    fn ops_contract_sell(&mut self, price: YoctoNear);

    /// Takes the contract off the market for selling.
    ///
    /// If the contract is not currently up for sale, then there is no effect.
    ///
    /// ## Panics
    /// - if the predecessor account is not the owner account
    /// - if 1 yoctoNEAR is not attached
    ///
    /// `#[payable]` - requires exactly 1 yoctoNEAR to be attached
    fn ops_contract_cancel_sale(&mut self);

    /// Places an order to buy the contract for the specified bid.
    ///
    /// - If there is no current sale price set, then this places a bid on the contract.
    /// - If the bid is greater than or equal to the sale price, then the contract is sold at the
    ///   bid price.
    /// - The buyer may set an optional expiration on the bid
    /// - If there was a previous lower bid in effect, then that buy order will be automatically
    ///   cancelled and the funds will be transferred back to the buyer's registered contract account.
    ///
    /// ## Log Events
    /// - [`LOG_EVENT_CONTRACT_BID_PLACED`]
    ///
    /// ## Panics
    /// - if no deposit is attached - at lease 1 yoctoNEAR must be attached
    /// - if the submitted bid price is not higher than the current bid price
    ///
    /// `#[payable]`
    fn ops_contract_buy(&mut self, expiration: Option<ExpirationSetting>);

    /// Enables the buyer to raise the contract bid and update the expiration.
    ///
    /// ## Panics
    /// - if there is no current bid
    /// - if predecessor ID is not the current buyer
    /// - if no deposit is attached - at lease 1 yoctoNEAR must be attached
    ///
    /// `#[payable]`
    fn ops_contract_raise_bid(&mut self, expiration: Option<ExpirationSetting>) -> ContractBid;

    /// Enables the buyer to lower the contract bid by the specified amount and update the expiration.
    ///
    /// The amount will be refunded back to the buyer + the 1 yoctoNEAR attached deposit
    ///
    /// ## Panics
    /// - if there is no current bid
    /// - if predecessor ID is not the current buyer
    /// - if the current bid is <= amount
    /// - if 1 yoctoNEAR deposit is not attached
    ///
    /// `#[payable]` - requires exactly 1 yoctoNEAR to be attached
    fn ops_contract_lower_bid(
        &mut self,
        amount: YoctoNear,
        expiration: Option<ExpirationSetting>,
    ) -> ContractBid;

    /// Enables the buyer to update the expiration.
    ///
    /// ## Panics
    /// - if there is no current bid
    /// - if predecessor ID is not the current buyer
    /// - if 1 yoctoNEAR deposit is not attached
    ///
    /// `#[payable]` - requires exactly 1 yoctoNEAR to be attached
    fn ops_contract_update_bid_expiration(&mut self, expiration: ExpirationSetting);

    /// Enables the buyer to clear the expiration.
    ///
    /// ## Panics
    /// - if there is no current bid
    /// - if predecessor ID is not the current buyer
    /// - if 1 yoctoNEAR deposit is not attached
    ///
    /// `#[payable]` - requires exactly 1 yoctoNEAR to be attached
    fn ops_contract_clear_bid_expiration(&mut self);

    /// Cancels the buy order and withdraws the bid amount.
    ///
    /// ## Panics
    /// - if the predecessor account is not the current buyer
    /// - if 1 yoctoNEAR is not attached
    ///
    /// `#[payable]` - requires exactly 1 yoctoNEAR to be attached
    fn ops_contract_cancel_bid(&mut self);
}

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct ContractBuyerBid {
    pub buyer: AccountId,
    pub bid: ContractBid,
}

/// event gets logged each time the sale price is changed
pub const LOG_EVENT_CONTRACT_FOR_SALE: LogEvent = LogEvent(Level::INFO, "CONTRACT_FOR_SALE");

pub const LOG_EVENT_CONTRACT_SALE_CANCELLED: LogEvent =
    LogEvent(Level::INFO, "CONTRACT_SALE_CANCELLED");

pub const LOG_EVENT_CONTRACT_BID_PLACED: LogEvent = LogEvent(Level::INFO, "CONTRACT_BID_PLACED");

pub const LOG_EVENT_CONTRACT_BID_RAISED: LogEvent = LogEvent(Level::INFO, "CONTRACT_BID_RAISED");

pub const LOG_EVENT_CONTRACT_BID_LOWERED: LogEvent = LogEvent(Level::INFO, "CONTRACT_BID_LOWERED");

pub const LOG_EVENT_CONTRACT_BID_EXPIRATION_CHANGE: LogEvent =
    LogEvent(Level::INFO, "CONTRACT_BID_EXPIRATION_CHANGE");

pub const LOG_EVENT_CONTRACT_BID_CANCELLED: LogEvent =
    LogEvent(Level::INFO, "CONTRACT_BID_CANCELLED");

pub const LOG_EVENT_CONTRACT_SOLD: LogEvent = LogEvent(Level::INFO, "CONTRACT_SOLD");

/// Indicates access was denied because owner access was required
pub const ERR_CONTRACT_SALE_PRICE_MUST_NOT_BE_ZERO: ErrorConst = ErrorConst(
    ErrCode("CONTRACT_SALE_PRICE_MUST_NOT_BE_ZERO"),
    "contract sale price must not be zero",
);

/// Indicates the bid was too low, i.e., a higher bid has already been placed
pub const ERR_CONTRACT_BID_TOO_LOW: ErrorConst = ErrorConst(
    ErrCode("CONTRACT_BID_NOT_ATTACHED"),
    "contract bid is too low - for your bid to be accepted, you must submit a bid that is higher than the current bid",
);

/// Indicates access was denied because owner access was required
pub const ERR_CONTRACT_SALE_NOT_ALLOWED: ErrCode = ErrCode("CONTRACT_SALE_NOT_ALLOWED");

/// The owner cannot submit a bid to buy the contract
pub const ERR_OWNER_CANNOT_BUY_CONTRACT: ErrorConst = ErrorConst(
    ErrCode("OWNER_CANNOT_BUY_CONTRACT"),
    "owner cannot submit a bid to buy the contract",
);

pub const ERR_NO_ACTIVE_BID: ErrorConst =
    ErrorConst(ErrCode("NO_ACTIVE_BID"), "there is no current active bid");

pub const ERR_ACCESS_DENIED_MUST_BE_BUYER: ErrorConst = ErrorConst(
    ErrCode("ACCESS_DENIED_MUST_BE_BUYER"),
    "action is restricted to current buyer",
);

pub const ERR_BID_IS_EXPIRED: ErrorConst = ErrorConst(ErrCode("BID_IS_EXPIRED"), "bid is expired");

'''
'''--- near/oysterpack-smart-contract/src/lib.rs ---
pub mod components;
mod domain;
mod interface;

pub use domain::*;
pub use interface::*;

'''
'''--- near/oysterpack-smart-contract/tests/quick_test.rs ---

'''
'''--- near/oysterpack-smart-fungible-token/Cargo.toml ---
[package]
name = "oysterpack-smart-fungible-token"
version = "0.1.0"
authors = ["oysterpack.inc <oysterpack.inc@gmail.com>"]
edition = "2018"

[dependencies]
oysterpack-smart-near = { path = "../oysterpack-smart-near" }
oysterpack-smart-account-management = { path = "../oysterpack-smart-account-management" }

[dev-dependencies]
oysterpack-smart-near-test = { path = "../oysterpack-smart-near-test" }
'''
'''--- near/oysterpack-smart-fungible-token/Makefile.toml ---
extend = "../Makefile.toml"
'''
'''--- near/oysterpack-smart-fungible-token/README.md ---

'''
'''--- near/oysterpack-smart-fungible-token/src/components.rs ---
pub mod fungible_token;

'''
'''--- near/oysterpack-smart-fungible-token/src/components/fungible_token.rs ---
//! [`FungibleTokenComponent`]
//! - constructor: [`FungibleTokenComponent::new`]
//!   - [`AccountManagementComponent`]
//! - deployment: [`FungibleTokenComponent::deploy`]
//!   - config: [`FungibleTokenConfig`]
//! - use [`FungibleTokenComponent::register_storage_management_event_handler`]  to register event
//!   handler for [`StorageManagementEvent::PreUnregister`] which integrates with [`AccountManagementComponent`]

use crate::{
    contract::operator::{FungibleTokenOperator, OperatorCommand},
    FungibleToken, FungibleTokenMetadataProvider, Memo, Metadata, ResolveTransferCall, TokenAmount,
    TokenService, TransferCallMessage, ERR_CODE_FT_RESOLVE_TRANSFER, LOG_EVENT_FT_BURN,
    LOG_EVENT_FT_LOCK, LOG_EVENT_FT_MINT, LOG_EVENT_FT_TRANSFER,
    LOG_EVENT_FT_TRANSFER_CALL_FAILURE, LOG_EVENT_FT_TRANSFER_CALL_PARTIAL_REFUND,
    LOG_EVENT_FT_TRANSFER_CALL_RECEIVER_DEBIT, LOG_EVENT_FT_TRANSFER_CALL_REFUND_NOT_APPLIED,
    LOG_EVENT_FT_TRANSFER_CALL_SENDER_CREDIT, LOG_EVENT_FT_UNLOCK,
};
use oysterpack_smart_account_management::{
    components::account_management::AccountManagementComponent, AccountRepository,
    AccountStorageEvent, StorageManagementEvent, ERR_ACCOUNT_NOT_REGISTERED,
    ERR_CODE_UNREGISTER_FAILURE,
};
use oysterpack_smart_near::eventbus::{self, post};
use oysterpack_smart_near::near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    env,
    json_types::ValidAccountId,
    serde::{Deserialize, Serialize},
    serde_json, AccountId, Promise, PromiseResult,
};
use oysterpack_smart_near::{
    asserts::{
        assert_yocto_near_attached, ERR_CODE_BAD_REQUEST, ERR_INSUFFICIENT_FUNDS, ERR_INVALID,
    },
    lazy_static::lazy_static,
    {component::Deploy, data::Object, to_valid_account_id, Hash, TERA},
};
use oysterpack_smart_near::{
    component::ManagesAccountData,
    domain::{ActionType, ByteLen, Gas, SenderIsReceiver, StorageUsage, TGas, TransactionResource},
};

use std::{fmt::Debug, ops::Deref, ops::DerefMut, sync::Mutex};

pub struct FungibleTokenComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    account_manager: AccountManagementComponent<T>,
}

impl<T> FungibleTokenComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    pub fn new(account_manager: AccountManagementComponent<T>) -> Self {
        Self { account_manager }
    }
}

impl<T> Deploy for FungibleTokenComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    type Config = FungibleTokenConfig;

    fn deploy(config: Self::Config) {
        MetadataObject::new(METADATA_KEY, config.metadata.clone()).save();
        TokenSupply::new(TOKEN_SUPPLY, config.token_supply).save();
    }
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct FungibleTokenConfig {
    pub metadata: Metadata,
    /// initial token supply
    pub token_supply: u128,
}

impl<T> FungibleToken for FungibleTokenComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn ft_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        amount: TokenAmount,
        memo: Option<Memo>,
    ) {
        assert_yocto_near_attached();
        ERR_CODE_BAD_REQUEST.assert(|| *amount > 0, || "transfer amount cannot be zero");

        let sender_id = &env::predecessor_account_id();
        ERR_CODE_BAD_REQUEST.assert(
            || sender_id != receiver_id.as_ref(),
            || "sender and receiver cannot be the same",
        );

        ERR_ACCOUNT_NOT_REGISTERED.assert_with_message(
            || self.account_manager.account_exists(sender_id),
            || "sender account is not registered",
        );
        ERR_ACCOUNT_NOT_REGISTERED.assert_with_message(
            || self.account_manager.account_exists(receiver_id.as_ref()),
            || "receiver account is not registered",
        );

        let sender_balance = self.ft_balance_of(to_valid_account_id(sender_id));
        ERR_INSUFFICIENT_FUNDS.assert(|| *sender_balance >= *amount);

        // transfer the tokens
        AccountFTBalance::set_balance(sender_id, *sender_balance - *amount);
        let receiver_balance = self.ft_balance_of(receiver_id.clone());
        AccountFTBalance::set_balance(receiver_id.as_ref(), *receiver_balance + *amount);

        if let Some(memo) = memo {
            LOG_EVENT_FT_TRANSFER.log(memo);
        }
    }

    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: TokenAmount,
        memo: Option<Memo>,
        msg: TransferCallMessage,
    ) -> Promise {
        self.ft_transfer(receiver_id.clone(), amount, memo);

        self.create_promise_transfer_receiver_ft_on_transfer(
            &env::predecessor_account_id(),
            receiver_id.as_ref(),
            amount,
            msg,
        )
    }

    fn ft_total_supply(&self) -> TokenAmount {
        TokenSupply::load(&TOKEN_SUPPLY).map_or(0.into(), |amount| (*amount).into())
    }

    fn ft_balance_of(&self, account_id: ValidAccountId) -> TokenAmount {
        AccountFTBalance::balance_of(account_id.as_ref())
    }
}

impl<T> FungibleTokenOperator for FungibleTokenComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn ft_operator_command(&mut self, command: OperatorCommand) {
        self.account_manager.assert_operator();
        let mut metadata = MetadataObject::load(&METADATA_KEY).unwrap();
        match command {
            OperatorCommand::SetIcon(icon) => metadata.icon = Some(icon),
            OperatorCommand::ClearIcon => metadata.icon = None,
            OperatorCommand::SetReference(reference, hash) => {
                metadata.reference = Some(reference);
                metadata.reference_hash = Some(hash);
            }
            OperatorCommand::ClearReference => {
                metadata.reference = None;
                metadata.reference_hash = None;
            }
            OperatorCommand::SetTransferCallbackGas(gas) => set_transfer_callback_gas(gas),
        }
        metadata.save();
    }

    fn ft_operator_transfer_callback_gas(&self) -> Gas {
        transfer_callback_gas()
    }
}

const TRANSFER_CALLBACK_GAS_KEY: u128 = 195443795528357944121615941514104351048;
type TransferCallbackGas = Object<u128, Gas>;

fn transfer_callback_gas() -> Gas {
    TransferCallbackGas::load(&TRANSFER_CALLBACK_GAS_KEY)
        .map_or_else(|| (5 * TERA).into(), |gas| *gas)
}

fn set_transfer_callback_gas(gas: TGas) {
    ERR_INVALID.assert(|| gas.value() > 0, || "transfer callback TGas must be > 0");
    let gas = TransferCallbackGas::new(TRANSFER_CALLBACK_GAS_KEY, gas.into());
    gas.save();
}

impl<T> TokenService for FungibleTokenComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn ft_mint(&mut self, account_id: &str, amount: TokenAmount) -> TokenAmount {
        ERR_INVALID.assert(|| *amount > 0, || "mint amount cannot be zero");
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| self.account_manager.account_exists(account_id));

        let mut ft_balance = AccountFTBalance::get(account_id);
        *ft_balance += *amount;
        ft_balance.save(account_id);

        let mut token_supply = token_supply();
        *token_supply += *amount;
        token_supply.save();

        LOG_EVENT_FT_MINT.log(format!("account: {}, amount: {}", account_id, amount));
        (*ft_balance).into()
    }

    fn ft_burn(&mut self, account_id: &str, amount: TokenAmount) -> TokenAmount {
        ERR_INVALID.assert(|| *amount > 0, || "burn amount cannot be zero");
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| self.account_manager.account_exists(account_id));

        let mut ft_balance = AccountFTBalance::load(account_id).unwrap();
        let (available, locked) = *ft_balance.0;
        ERR_INVALID.assert(
            || (available + locked) >= *amount,
            || "account has insufficient funds",
        );
        *ft_balance.0 = (available + locked - *amount, locked.saturating_sub(*amount));
        ft_balance.save(account_id);

        burn_tokens(*amount);
        LOG_EVENT_FT_BURN.log(format!("account: {}, amount: {}", account_id, amount));
        (*ft_balance).into()
    }

    fn ft_burn_all(&mut self, account_id: &str) {
        if let Some(mut ft_balance) = AccountFTBalance::load(account_id) {
            let (available, locked) = *ft_balance.0;
            *ft_balance.0 = (0, 0);
            ft_balance.save(account_id);

            let amount = available + locked;
            burn_tokens(amount);
            LOG_EVENT_FT_BURN.log(format!("account: {}, amount: {}", account_id, amount));
        }
    }

    fn ft_lock(&mut self, account_id: &str, amount: TokenAmount) {
        ERR_INVALID.assert(|| *amount > 0, || "lock amount cannot be zero");
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| self.account_manager.account_exists(account_id));

        if let Some(mut ft_balance) = AccountFTBalance::load(account_id) {
            let (available, locked) = *ft_balance.0;
            ERR_INSUFFICIENT_FUNDS.assert(|| available >= *amount);
            *ft_balance.0 = (available - *amount, locked + *amount);
            ft_balance.0.save();

            LOG_EVENT_FT_LOCK.log(format!("account: {}, amount: {}", account_id, amount));
        } else {
            ERR_INSUFFICIENT_FUNDS.panic();
        }
    }

    fn ft_lock_all(&mut self, account_id: &str) {
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| self.account_manager.account_exists(account_id));

        if let Some(mut ft_balance) = AccountFTBalance::load(account_id) {
            let (available, locked) = *ft_balance.0;
            if available > 0 {
                *ft_balance.0 = (0, available + locked);
                ft_balance.0.save();

                LOG_EVENT_FT_LOCK.log(format!("account: {}, amount: {}", account_id, available));
            }
        }
    }

    fn ft_unlock(&mut self, account_id: &str, amount: TokenAmount) {
        ERR_INVALID.assert(|| *amount > 0, || "unlock amount cannot be zero");
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| self.account_manager.account_exists(account_id));

        if let Some(mut ft_balance) = AccountFTBalance::load(account_id) {
            let (available, locked) = *ft_balance.0;
            ERR_INSUFFICIENT_FUNDS.assert(|| locked >= *amount);
            *ft_balance.0 = (available + *amount, locked - *amount);
            ft_balance.0.save();

            LOG_EVENT_FT_UNLOCK.log(format!("account: {}, amount: {}", account_id, amount));
        }
    }

    fn ft_unlock_all(&mut self, account_id: &str) {
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| self.account_manager.account_exists(account_id));

        if let Some(mut ft_balance) = AccountFTBalance::load(account_id) {
            let (available, locked) = *ft_balance.0;
            if locked > 0 {
                *ft_balance.0 = (available + locked, 0);
                ft_balance.0.save();

                LOG_EVENT_FT_UNLOCK.log(format!("account: {}, amount: {}", account_id, locked));
            }
        }
    }

    fn ft_locked_balance(&mut self, account_id: &str) -> Option<TokenAmount> {
        AccountFTBalance::load(account_id).map(|balance| (*balance.0).1.into())
    }
}

impl<T> ManagesAccountData for FungibleTokenComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn account_storage_min() -> StorageUsage {
        let account_id = "19544499980228477895959808916967586760";
        let initial_storage = env::storage_usage();
        AccountFTBalance::set_balance(account_id, 1);
        let account_storage_usage = env::storage_usage() - initial_storage;
        AccountFTBalance::set_balance(account_id, 0);
        account_storage_usage.into()
    }
}

impl<T> FungibleTokenComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn create_promise_transfer_receiver_ft_on_transfer(
        &self,
        sender_id: &str,
        receiver_id: &str,
        amount: TokenAmount,
        msg: TransferCallMessage,
    ) -> Promise {
        let ft_on_transfer = b"ft_on_transfer".to_vec();
        let ft_on_transfer_args = serde_json::to_vec(&OnTransferArgs {
            sender_id: env::predecessor_account_id(),
            amount,
            msg,
        })
        .expect("");
        let ft_on_transfer_bytes: u64 = (ft_on_transfer.len() + ft_on_transfer_args.len()) as u64;

        let ft_resolve_transfer_call = b"ft_resolve_transfer_call".to_vec();
        let ft_resolve_transfer_call_args = serde_json::to_vec(&ResolveTransferArgs {
            sender_id: sender_id.to_string(),
            receiver_id: receiver_id.to_string(),
            amount,
        })
        .expect("");
        let ft_resolve_transfer_call_bytes: u64 =
            (ft_resolve_transfer_call.len() + ft_resolve_transfer_call_args.len()) as u64;

        // compute how much gas is needed to complete this call and the resolve transfer callback
        // and then give the rest of the gas to the transfer receiver call
        let ft_on_transfer_receipt_action_cost = {
            let action_receipt = TransactionResource::ActionReceipt(SenderIsReceiver(false));
            let func_call_action = TransactionResource::Action(ActionType::FunctionCall(
                SenderIsReceiver(false),
                ByteLen(ft_on_transfer_bytes),
            ));
            Gas::compute(vec![(action_receipt, 1), (func_call_action, 1)])
        };
        let ft_resolve_transfer_call_receipt_action_cost = {
            let action_receipt = TransactionResource::ActionReceipt(SenderIsReceiver(true));
            let func_call_action = TransactionResource::Action(ActionType::FunctionCall(
                SenderIsReceiver(true),
                ByteLen(ft_resolve_transfer_call_bytes),
            ));
            // byte len for transfer amount is set to 100 because even though the underlying type
            // is u128, it is marshalled as a string. Thus the number of bytes will vary depending on
            // the amount value - we'll pick 100 to be conservative.
            let data_receipt =
                TransactionResource::DataReceipt(SenderIsReceiver(false), ByteLen(100));
            Gas::compute(vec![
                (action_receipt, 1),
                (func_call_action, 1),
                (data_receipt, 1),
            ])
        };
        let ft_on_transfer_gas = env::prepaid_gas()
            - env::used_gas()
            - transfer_callback_gas().value()
            - ft_on_transfer_receipt_action_cost.value()
            - ft_resolve_transfer_call_receipt_action_cost.value()
            - 5 * TERA; // to complete this call;

        // create the function call chain
        {
            let ft_transfer_call = Promise::new(receiver_id.to_string()).function_call(
                ft_on_transfer,
                ft_on_transfer_args,
                0,
                ft_on_transfer_gas,
            );
            let ft_resolve_transfer_call = Promise::new(env::current_account_id()).function_call(
                ft_resolve_transfer_call,
                ft_resolve_transfer_call_args,
                0,
                transfer_callback_gas().value(),
            );
            ft_transfer_call.then(ft_resolve_transfer_call)
        }
    }

    /// Used to register an event handler hook to handle account unregistrations
    ///
    /// can be safely called multiple times and will only register the event handler once
    pub fn register_storage_management_event_handler() {
        let mut registered = STORAGE_MANAGEMENT_EVENT_HANDLER_REGISTERED.lock().unwrap();
        if !*registered {
            eventbus::register(Self::on_unregister_account);
            *registered = true;
        }
    }

    /// EventHandler must be registered to handle [`StorageManagementEvent::PreUnregister`] events
    ///
    /// When an account is forced unregistered, any tokens it owned will be burned, which reduces the total
    /// token supply.
    fn on_unregister_account(event: &StorageManagementEvent) {
        if let StorageManagementEvent::PreUnregister { force, .. } = event {
            let account_id = &env::predecessor_account_id();
            if let Some(ft_balance) = AccountFTBalance::load(&account_id) {
                ERR_CODE_UNREGISTER_FAILURE
                    .assert(|| *force, || "account has non-zero token balance");
                let amount = *ft_balance;
                AccountFTBalance::set_balance(account_id, 0);
                burn_tokens(amount);
                LOG_EVENT_FT_BURN.log(format!(
                    "account forced unregistered with token balance: account: account: {}, amount: {}",
                    account_id, amount
                ));
            }
        }
    }
}

lazy_static! {
    static ref STORAGE_MANAGEMENT_EVENT_HANDLER_REGISTERED: Mutex<bool> = Mutex::new(false);
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct OnTransferArgs {
    sender_id: AccountId,
    amount: TokenAmount,
    msg: TransferCallMessage,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct ResolveTransferArgs {
    sender_id: AccountId,
    receiver_id: AccountId,
    amount: TokenAmount,
}

const TOKEN_SUPPLY: u128 = 1953830723745925743018307013370321490;
type TokenSupply = Object<u128, u128>;
fn token_supply() -> TokenSupply {
    TokenSupply::load(&TOKEN_SUPPLY).unwrap()
}

fn burn_tokens(amount: u128) {
    let mut supply = token_supply();
    *supply -= amount;
    supply.save();
}

const METADATA_KEY: u128 = 19538272703993902201263844658248351047;
type MetadataObject = Object<u128, Metadata>;

impl<T> FungibleTokenMetadataProvider for FungibleTokenComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn ft_metadata(&self) -> Metadata {
        MetadataObject::load(&METADATA_KEY).unwrap().deref().clone()
    }
}

impl<T> ResolveTransferCall for FungibleTokenComponent<T>
where
    T: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Default,
{
    fn ft_resolve_transfer_call(
        &mut self,
        sender_id: ValidAccountId,
        receiver_id: ValidAccountId,
        amount: TokenAmount,
    ) -> TokenAmount {
        // Get the refund amount from the `ft_on_transfer` call result.
        let refund_amount = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(value) => {
                match serde_json::from_slice::<TokenAmount>(&value) {
                    Ok(refund_amount) => {
                        if refund_amount > amount {
                            ERR_CODE_FT_RESOLVE_TRANSFER
                            .error("refund amount was greater than the transfer amount - full transfer amount will be refunded")
                            .log();
                            amount
                        } else {
                            refund_amount
                        }
                    }
                    Err(_) => {
                        ERR_CODE_FT_RESOLVE_TRANSFER
                            .error(
                                "failed to deserialize refund amount - no refund will be applied",
                            )
                            .log();
                        0.into()
                    }
                }
            }
            PromiseResult::Failed => {
                LOG_EVENT_FT_TRANSFER_CALL_FAILURE.log("full transfer amount will be refunded");
                amount
            }
        };

        if *refund_amount == 0 {
            return amount;
        }

        // try to refund the refund amount from the receiver back to the sender
        let refund_amount = if let Some(mut receiver_account_balance) =
            AccountFTBalance::load(receiver_id.as_ref())
        {
            let refund_amount = if *receiver_account_balance < *refund_amount {
                LOG_EVENT_FT_TRANSFER_CALL_PARTIAL_REFUND.log(
                    "partial refund will be applied because receiver account has insufficient fund",
                );
                *receiver_account_balance
            } else {
                *refund_amount
            };
            *receiver_account_balance -= refund_amount;
            receiver_account_balance.save(receiver_id.as_ref());

            LOG_EVENT_FT_TRANSFER_CALL_RECEIVER_DEBIT.log(refund_amount);

            match AccountFTBalance::load(sender_id.as_ref()) {
                Some(mut sender_account_balance) => {
                    *sender_account_balance += refund_amount;
                    sender_account_balance.save(sender_id.as_ref());
                    LOG_EVENT_FT_TRANSFER_CALL_SENDER_CREDIT.log(refund_amount);
                }
                None => {
                    // - if balance is zero, then storage was cleaned up
                    // - the sender account most likely still exists, but might have been unregistered
                    //   while the transfer call workflow was in flight
                    if self.account_manager.account_exists(sender_id.as_ref()) {
                        AccountFTBalance::set_balance(sender_id.as_ref(), refund_amount);
                        LOG_EVENT_FT_TRANSFER_CALL_SENDER_CREDIT.log(refund_amount);
                    } else {
                        burn_tokens(refund_amount);
                        LOG_EVENT_FT_BURN.log(format!(
                            "sender account is not registered: {}",
                            refund_amount
                        ));
                    }
                }
            }
            refund_amount.into()
        } else {
            if self.account_manager.account_exists(receiver_id.as_ref()) {
                // this could happen if:
                // - the receiver account transferred out the tokens while this transfer call workflow
                //   was in flight
                // - there is a bug in the receiver contract
                // - the receiver contract is acting maliciously
                LOG_EVENT_FT_TRANSFER_CALL_REFUND_NOT_APPLIED
                    .log("receiver account has zero balance");
            } else {
                // if the receiver account is no longer registered then the refund amount of tokens
                // will be handled when the account unregistered
                // - the account will not be allowed to unregister with a non-zero token balance,
                //   otherwise if forced, the tokens will be burned
                LOG_EVENT_FT_TRANSFER_CALL_REFUND_NOT_APPLIED
                    .log("receiver account not registered");
            }
            0.into()
        };

        amount - refund_amount
    }
}

const FT_ACCOUNT_KEY: u128 = 1953845438124731969041175284518648060;
type TokenBalance = u128;
type LockedTokenBalance = u128;
type AccountFTBalanceObject = Object<Hash, (TokenBalance, LockedTokenBalance)>;
struct AccountFTBalance(AccountFTBalanceObject);

impl AccountFTBalance {
    fn ft_account_id_hash(account_id: &str) -> Hash {
        Hash::from((account_id, FT_ACCOUNT_KEY))
    }

    fn load(account_id: &str) -> Option<AccountFTBalance> {
        let account_hash_id = AccountFTBalance::ft_account_id_hash(account_id);
        AccountFTBalanceObject::load(&account_hash_id).map(Self)
    }

    fn get(account_id: &str) -> AccountFTBalance {
        Self::load(account_id).unwrap_or_else(|| {
            Self(AccountFTBalanceObject::new(
                Self::ft_account_id_hash(account_id),
                (0, 0),
            ))
        })
    }

    fn balance_of(account_id: &str) -> TokenAmount {
        Self::load(account_id).map_or(0.into(), |balance| (*balance).into())
    }

    fn save(&self, account_id: &str) {
        if *self.0 == (0, 0) {
            let initial_storage_usage = env::storage_usage();
            AccountFTBalanceObject::delete_by_key(self.0.key());
            let storage_usage_change = initial_storage_usage - env::storage_usage();
            if storage_usage_change > 0 {
                post(&AccountStorageEvent::StorageUsageChanged(
                    account_id.into(),
                    (storage_usage_change as i64 * -1).into(),
                ));
            }
        } else {
            let initial_storage_usage = env::storage_usage();
            self.0.save();
            let storage_usage_change = env::storage_usage() - initial_storage_usage;
            if storage_usage_change > 0 {
                post(&AccountStorageEvent::StorageUsageChanged(
                    account_id.into(),
                    storage_usage_change.into(),
                ));
            }
        }
    }

    /// tracks storage
    /// - if balance is set to zero, then the balance record will be deleted from storage
    fn set_balance(account_id: &str, balance: u128) {
        let account_hash_id = Self::ft_account_id_hash(account_id);
        match AccountFTBalanceObject::load(&account_hash_id) {
            None => {
                if balance == 0 {
                    return;
                }
                let initial_storage_usage = env::storage_usage();
                AccountFTBalanceObject::new(account_hash_id, (balance, 0)).save();
                let storage_usage_change = env::storage_usage() - initial_storage_usage;
                post(&AccountStorageEvent::StorageUsageChanged(
                    account_id.into(),
                    storage_usage_change.into(),
                ));
            }
            Some(mut account_balance) => {
                if balance == 0 {
                    let initial_storage_usage = env::storage_usage();
                    account_balance.delete();
                    let storage_usage_change = initial_storage_usage - env::storage_usage();
                    post(&AccountStorageEvent::StorageUsageChanged(
                        account_id.into(),
                        (storage_usage_change as i64 * -1).into(),
                    ));
                } else {
                    *account_balance = (balance, (*account_balance).1);
                    account_balance.save();
                }
            }
        }
    }
}

impl Deref for AccountFTBalance {
    type Target = TokenBalance;

    fn deref(&self) -> &Self::Target {
        let (balance, _) = self.0.deref();
        balance
    }
}

impl DerefMut for AccountFTBalance {
    fn deref_mut(&mut self) -> &mut Self::Target {
        let (balance, _) = self.0.deref_mut();
        balance
    }
}

#[cfg(test)]
mod tests_fungible_token {
    use super::*;
    use crate::FungibleToken;
    use crate::*;
    use near_sdk::{test_utils, VMContext};
    use oysterpack_smart_account_management::components::account_management::AccountManagementComponentConfig;
    use oysterpack_smart_account_management::StorageManagement;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    type AccountDataType = ();
    type AccountManager = AccountManagementComponent<AccountDataType>;
    type STAKE = FungibleTokenComponent<AccountDataType>;

    const ADMIN: &str = "admin";

    fn deploy_comps() {
        AccountManager::deploy(AccountManagementComponentConfig::new(to_valid_account_id(
            ADMIN,
        )));

        STAKE::deploy(FungibleTokenConfig {
            metadata: Metadata {
                spec: FT_METADATA_SPEC.into(),
                name: "STAKE".into(),
                symbol: "STAKE".into(),
                icon: None,
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
            token_supply: YOCTO,
        });
    }

    #[test]
    fn basic_workflow() {
        // Arrange
        let sender = "sender";
        let receiver = "receiver";
        let mut ctx = new_context(sender);
        testing_env!(ctx.clone());

        deploy_comps();

        let mut account_manager = AccountManager::default();

        // register accounts
        {
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, None);

            ctx.attached_deposit = YOCTO;
            ctx.predecessor_account_id = receiver.to_string();
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, None);
        }

        let mut stake = STAKE::new(account_manager);
        // mint some new stake for the sender
        AccountFTBalance::set_balance(sender, 100);

        // Act
        ctx.predecessor_account_id = sender.to_string();
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        stake.ft_transfer(to_valid_account_id(receiver), 50.into(), None);
        stake.ft_transfer(
            to_valid_account_id(receiver),
            50.into(),
            Some("memo".into()),
        );
        assert_eq!(*stake.ft_balance_of(to_valid_account_id(sender)), 0);
        assert_eq!(*stake.ft_balance_of(to_valid_account_id(receiver)), 100);

        ctx.predecessor_account_id = receiver.to_string();
        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        stake.ft_transfer_call(to_valid_account_id(sender), 50.into(), None, "msg".into());

        let receipts = deserialize_receipts();
        assert_eq!(receipts.len(), 2);

        ctx.predecessor_account_id = receiver.to_string();
        ctx.attached_deposit = 0;
        testing_env_with_promise_results(
            ctx.clone(),
            vec![PromiseResult::Successful(
                serde_json::to_vec(&TokenAmount::from(10)).unwrap(),
            )],
        );
        stake.ft_resolve_transfer_call(
            to_valid_account_id(sender),
            to_valid_account_id(receiver),
            50.into(),
        );
        let logs = test_utils::get_logs();
        println!("logs: {:#?}", logs);

        assert_eq!(stake.ft_balance_of(to_valid_account_id(sender)), 60.into());
        assert_eq!(
            stake.ft_balance_of(to_valid_account_id(receiver)),
            40.into()
        );
    }

    const SENDER: &str = "sender";
    const RECEIVER: &str = "receiver";

    /// - if the balances are Some then register them and mint tokens for them
    fn run_test<F>(
        sender_balance: Option<TokenAmount>,
        receiver_balance: Option<TokenAmount>,
        test: F,
    ) where
        F: FnOnce(VMContext, STAKE),
    {
        // Arrange
        let ctx = new_context(SENDER);
        testing_env!(ctx.clone());

        deploy_comps();

        let account_manager = AccountManager::default();

        let mut stake = STAKE::new(account_manager);

        // register accounts
        {
            let mut account_manager = AccountManager::default();

            if let Some(balance) = sender_balance {
                let mut ctx = ctx.clone();
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = account_manager.storage_balance_bounds().min.value();
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                if *balance > 0 {
                    stake.ft_mint(SENDER, balance);
                }
            }

            if let Some(balance) = receiver_balance {
                let mut ctx = ctx.clone();
                ctx.predecessor_account_id = RECEIVER.to_string();
                ctx.attached_deposit = account_manager.storage_balance_bounds().min.value();
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                if *balance > 0 {
                    stake.ft_mint(RECEIVER, balance);
                }
            }
        }

        test(ctx, stake);
    }

    #[cfg(test)]
    mod test_ft_transfer {
        use super::*;

        #[test]
        fn valid_transfer_with_no_memo() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer(to_valid_account_id(RECEIVER), 400.into(), None);

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 600.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    400.into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(
                    &logs[0],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)"
                );
            });
        }

        #[test]
        fn valid_transfer_full_amount() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer(to_valid_account_id(RECEIVER), 1000.into(), None);

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 0.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    1000.into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    &logs[0],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)" // caused by sender debit zeroing FT balance
                );
                assert_eq!(
                    &logs[1],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)" // caused by receiver credit
                );
            });
        }

        #[test]
        fn valid_transfer_with_memo() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer(
                    to_valid_account_id(RECEIVER),
                    400.into(),
                    Some(Memo("memo".to_string())),
                );

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 600.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    400.into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 2);
                assert_eq!(
                    &logs[0],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)"
                );
                assert_eq!(&logs[1], "[INFO] [FT_TRANSFER] memo");
            });
        }

        #[test]
        #[should_panic(
            expected = "[ERR] [ACCOUNT_NOT_REGISTERED] sender account is not registered"
        )]
        fn sender_not_registered() {
            run_test(None, Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer(
                    to_valid_account_id(RECEIVER),
                    400.into(),
                    Some(Memo("memo".to_string())),
                );
            });
        }

        #[test]
        #[should_panic(
            expected = "[ERR] [ACCOUNT_NOT_REGISTERED] receiver account is not registered"
        )]
        fn receiver_not_registered() {
            run_test(Some(1000.into()), None, |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer(
                    to_valid_account_id(RECEIVER),
                    400.into(),
                    Some(Memo("memo".to_string())),
                );
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [BAD_REQUEST] sender and receiver cannot be the same")]
        fn sender_is_receiver() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer(
                    to_valid_account_id(SENDER),
                    400.into(),
                    Some(Memo("memo".to_string())),
                );
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
        fn yocto_not_attached() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                stake.ft_transfer(
                    to_valid_account_id(RECEIVER),
                    400.into(),
                    Some(Memo("memo".to_string())),
                );
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [BAD_REQUEST] transfer amount cannot be zero")]
        fn zero_transfer_amount() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer(
                    to_valid_account_id(RECEIVER),
                    0.into(),
                    Some(Memo("memo".to_string())),
                );
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
        fn insufficient_funds() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer(
                    to_valid_account_id(RECEIVER),
                    1001.into(),
                    Some(Memo("memo".to_string())),
                );
            });
        }
    }

    #[cfg(test)]
    mod test_ft_transfer_call {
        use super::*;

        #[test]
        fn valid_transfer_with_no_memo() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer_call(
                    to_valid_account_id(RECEIVER),
                    400.into(),
                    None,
                    TransferCallMessage("msg".to_string()),
                );

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 600.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    400.into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(
                    &logs[0],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)"
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, RECEIVER);
                    assert_eq!(receipt.actions.len(), 1);
                    let action = &receipt.actions[0];
                    match action {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ft_on_transfer");
                            assert_eq!(action.deposit, 0);
                            let args: OnTransferArgs =
                                serde_json::from_str(action.args.as_str()).unwrap();
                            assert_eq!(args.sender_id, SENDER);
                            assert_eq!(args.amount, 400.into());
                            assert_eq!(args.msg, TransferCallMessage("msg".to_string()));
                        }
                        _ => panic!("expected FunctionCall action"),
                    }
                }

                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    let action = &receipt.actions[0];
                    match action {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ft_resolve_transfer_call");
                            assert_eq!(action.deposit, 0);
                            let args: ResolveTransferArgs =
                                serde_json::from_str(action.args.as_str()).unwrap();
                            assert_eq!(args.sender_id, SENDER);
                            assert_eq!(args.amount, 400.into());
                            assert_eq!(args.receiver_id, RECEIVER);
                            assert_eq!(action.gas, transfer_callback_gas().value());
                        }
                        _ => panic!("expected FunctionCall action"),
                    }
                }
            });
        }

        #[test]
        fn valid_transfer_full_amount_with_no_memo() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer_call(
                    to_valid_account_id(RECEIVER),
                    1000.into(),
                    None,
                    TransferCallMessage("msg".to_string()),
                );

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 0.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    1000.into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 2);
                assert_eq!(
                    &logs[0],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)"
                );
                assert_eq!(
                    &logs[1],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)"
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, RECEIVER);
                    assert_eq!(receipt.actions.len(), 1);
                    let action = &receipt.actions[0];
                    match action {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ft_on_transfer");
                            assert_eq!(action.deposit, 0);
                            let args: OnTransferArgs =
                                serde_json::from_str(action.args.as_str()).unwrap();
                            assert_eq!(args.sender_id, SENDER);
                            assert_eq!(args.amount, 1000.into());
                            assert_eq!(args.msg, TransferCallMessage("msg".to_string()));
                        }
                        _ => panic!("expected FunctionCall action"),
                    }
                }

                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    let action = &receipt.actions[0];
                    match action {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ft_resolve_transfer_call");
                            assert_eq!(action.deposit, 0);
                            let args: ResolveTransferArgs =
                                serde_json::from_str(action.args.as_str()).unwrap();
                            assert_eq!(args.sender_id, SENDER);
                            assert_eq!(args.amount, 1000.into());
                            assert_eq!(args.receiver_id, RECEIVER);
                            assert_eq!(action.gas, transfer_callback_gas().value());
                        }
                        _ => panic!("expected FunctionCall action"),
                    }
                }
            });
        }

        #[test]
        fn valid_transfer_with_memo() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer_call(
                    to_valid_account_id(RECEIVER),
                    400.into(),
                    Some(Memo("memo".to_string())),
                    TransferCallMessage("msg".to_string()),
                );

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 600.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    400.into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 2);
                assert_eq!(
                    &logs[0],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)"
                );
                assert_eq!(&logs[1], "[INFO] [FT_TRANSFER] memo");

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, RECEIVER);
                    assert_eq!(receipt.actions.len(), 1);
                    let action = &receipt.actions[0];
                    match action {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ft_on_transfer");
                            assert_eq!(action.deposit, 0);
                            let args: OnTransferArgs =
                                serde_json::from_str(action.args.as_str()).unwrap();
                            assert_eq!(args.sender_id, SENDER);
                            assert_eq!(args.amount, 400.into());
                            assert_eq!(args.msg, TransferCallMessage("msg".to_string()));
                        }
                        _ => panic!("expected FunctionCall action"),
                    }
                }

                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    let action = &receipt.actions[0];
                    match action {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ft_resolve_transfer_call");
                            assert_eq!(action.deposit, 0);
                            let args: ResolveTransferArgs =
                                serde_json::from_str(action.args.as_str()).unwrap();
                            assert_eq!(args.sender_id, SENDER);
                            assert_eq!(args.amount, 400.into());
                            assert_eq!(args.receiver_id, RECEIVER);
                            assert_eq!(action.gas, transfer_callback_gas().value());
                        }
                        _ => panic!("expected FunctionCall action"),
                    }
                }
            });
        }

        #[test]
        #[should_panic(
            expected = "[ERR] [ACCOUNT_NOT_REGISTERED] sender account is not registered"
        )]
        fn sender_not_registered() {
            run_test(None, Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer_call(
                    to_valid_account_id(RECEIVER),
                    400.into(),
                    Some(Memo("memo".to_string())),
                    TransferCallMessage("msg".to_string()),
                );
            });
        }

        #[test]
        #[should_panic(
            expected = "[ERR] [ACCOUNT_NOT_REGISTERED] receiver account is not registered"
        )]
        fn receiver_not_registered() {
            run_test(Some(1000.into()), None, |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer_call(
                    to_valid_account_id(RECEIVER),
                    400.into(),
                    Some(Memo("memo".to_string())),
                    TransferCallMessage("msg".to_string()),
                );
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [BAD_REQUEST] sender and receiver cannot be the same")]
        fn sender_is_receiver() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer_call(
                    to_valid_account_id(SENDER),
                    400.into(),
                    Some(Memo("memo".to_string())),
                    TransferCallMessage("msg".to_string()),
                );
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED]")]
        fn yocto_not_attached() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                stake.ft_transfer_call(
                    to_valid_account_id(RECEIVER),
                    400.into(),
                    Some(Memo("memo".to_string())),
                    TransferCallMessage("msg".to_string()),
                );
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [BAD_REQUEST] transfer amount cannot be zero")]
        fn zero_transfer_amount() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer_call(
                    to_valid_account_id(RECEIVER),
                    0.into(),
                    Some(Memo("memo".to_string())),
                    TransferCallMessage("msg".to_string()),
                );
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
        fn insufficient_funds() {
            run_test(Some(1000.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = SENDER.to_string();
                ctx.attached_deposit = 1;
                testing_env!(ctx.clone());
                stake.ft_transfer_call(
                    to_valid_account_id(RECEIVER),
                    1001.into(),
                    Some(Memo("memo".to_string())),
                    TransferCallMessage("msg".to_string()),
                );
            });
        }
    }

    #[cfg(test)]
    mod test_resolve_transfer_call {
        use super::*;

        #[test]
        fn zero_refund() {
            run_test(None, Some(1000.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let refund_amount = TokenAmount(0.into());
                let refund_amount_bytes = serde_json::to_vec(&refund_amount).unwrap();
                testing_env_with_promise_results(
                    ctx,
                    vec![PromiseResult::Successful(refund_amount_bytes)],
                );
                stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    TokenAmount(500.into()),
                );

                let logs = test_utils::get_logs();
                assert!(logs.is_empty());
            });
        }

        #[test]
        fn full_refund_sender_with_zero_balance() {
            run_test(Some(0.into()), Some(1000.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let refund_amount = TokenAmount(500.into());
                let refund_amount_bytes = serde_json::to_vec(&refund_amount).unwrap();
                testing_env_with_promise_results(
                    ctx,
                    vec![PromiseResult::Successful(refund_amount_bytes)],
                );
                let actual_used_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    refund_amount,
                );
                assert_eq!(actual_used_amount, 0.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 3);
                assert_eq!(&logs[0], "[INFO] [FT_TRANSFER_CALL_RECEIVER_DEBIT] 500");
                assert_eq!(
                    &logs[1],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)"
                );
                assert_eq!(&logs[2], "[INFO] [FT_TRANSFER_CALL_SENDER_CREDIT] 500");

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 500.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    500.into()
                );
            });
        }

        #[test]
        fn full_refund_sender_with_non_zero_balance() {
            run_test(Some(100.into()), Some(1000.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let refund_amount = TokenAmount(500.into());
                let refund_amount_bytes = serde_json::to_vec(&refund_amount).unwrap();
                testing_env_with_promise_results(
                    ctx,
                    vec![PromiseResult::Successful(refund_amount_bytes)],
                );
                let actual_used_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    refund_amount,
                );
                assert_eq!(actual_used_amount, 0.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 2);
                assert_eq!(&logs[0], "[INFO] [FT_TRANSFER_CALL_RECEIVER_DEBIT] 500");
                assert_eq!(&logs[1], "[INFO] [FT_TRANSFER_CALL_SENDER_CREDIT] 500");

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 600.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    500.into()
                );
            });
        }

        #[test]
        fn partial_refund_with_sender_zero_balance() {
            run_test(Some(0.into()), Some(1000.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let transfer_amount = TokenAmount(500.into());
                let refund_amount = TokenAmount(100.into());
                let refund_amount_bytes = serde_json::to_vec(&refund_amount).unwrap();
                testing_env_with_promise_results(
                    ctx,
                    vec![PromiseResult::Successful(refund_amount_bytes)],
                );
                let actual_used_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    transfer_amount,
                );
                assert_eq!(actual_used_amount, transfer_amount - refund_amount);

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 3);
                assert_eq!(&logs[0], "[INFO] [FT_TRANSFER_CALL_RECEIVER_DEBIT] 100");
                assert_eq!(
                    &logs[1],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)"
                );
                assert_eq!(&logs[2], "[INFO] [FT_TRANSFER_CALL_SENDER_CREDIT] 100");

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 100.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    900.into()
                );
            });
        }

        #[test]
        fn over_refund() {
            run_test(Some(100.into()), Some(1000.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let transfer_amount = TokenAmount(500.into());
                let refund_amount = TokenAmount(1000.into());
                let refund_amount_bytes = serde_json::to_vec(&refund_amount).unwrap();
                testing_env_with_promise_results(
                    ctx,
                    vec![PromiseResult::Successful(refund_amount_bytes)],
                );
                let actual_used_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    transfer_amount,
                );
                assert_eq!(actual_used_amount, 0.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 3);
                assert_eq!(&logs[0], "[ERR] [FT_RESOLVE_TRANSFER] refund amount was greater than the transfer amount - full transfer amount will be refunded");
                assert_eq!(&logs[1], "[INFO] [FT_TRANSFER_CALL_RECEIVER_DEBIT] 500");
                assert_eq!(&logs[2], "[INFO] [FT_TRANSFER_CALL_SENDER_CREDIT] 500");

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 600.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    500.into()
                );
            });
        }

        #[test]
        fn deserialization_failure() {
            run_test(Some(100.into()), Some(1000.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let transfer_amount = TokenAmount(500.into());
                testing_env_with_promise_results(ctx, vec![PromiseResult::Successful(vec![])]);
                let actual_refund_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    transfer_amount,
                );
                assert_eq!(actual_refund_amount, 500.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(&logs[0], "[ERR] [FT_RESOLVE_TRANSFER] failed to deserialize refund amount - no refund will be applied");

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 100.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    1000.into()
                );
            });
        }

        #[test]
        fn transfer_call_promise_failed() {
            run_test(Some(100.into()), Some(1000.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let transfer_amount = TokenAmount(500.into());
                testing_env_with_promise_results(ctx, vec![PromiseResult::Failed]);
                let actual_used_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    transfer_amount,
                );
                assert_eq!(actual_used_amount, 0.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 3);
                assert_eq!(
                    &logs[0],
                    "[WARN] [FT_TRANSFER_CALL_FAILURE] full transfer amount will be refunded"
                );
                assert_eq!(&logs[1], "[INFO] [FT_TRANSFER_CALL_RECEIVER_DEBIT] 500");
                assert_eq!(&logs[2], "[INFO] [FT_TRANSFER_CALL_SENDER_CREDIT] 500");

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 600.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    500.into()
                );
            });
        }

        #[test]
        fn transfer_call_promise_failed_and_receiver_not_registered() {
            run_test(Some(100.into()), None, |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let transfer_amount = TokenAmount(500.into());
                testing_env_with_promise_results(ctx, vec![PromiseResult::Failed]);
                let actual_used_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    transfer_amount,
                );
                assert_eq!(actual_used_amount, transfer_amount);

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 2);
                assert_eq!(
                    &logs[0],
                    "[WARN] [FT_TRANSFER_CALL_FAILURE] full transfer amount will be refunded"
                );
                assert_eq!(
                    &logs[1],
                    "[WARN] [FT_TRANSFER_CALL_REFUND_NOT_APPLIED] receiver account not registered"
                );

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 100.into());
                assert_eq!(stake.ft_balance_of(to_valid_account_id(RECEIVER)), 0.into());
            });
        }

        #[test]
        fn refund_specified_with_receiver_not_registered() {
            run_test(Some(100.into()), None, |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let transfer_amount = TokenAmount(500.into());
                let refund_amount = TokenAmount(100.into());
                let refund_amount_bytes = serde_json::to_vec(&refund_amount).unwrap();
                testing_env_with_promise_results(
                    ctx,
                    vec![PromiseResult::Successful(refund_amount_bytes)],
                );
                let actual_transfer_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    transfer_amount,
                );
                assert_eq!(actual_transfer_amount, transfer_amount);

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(
                    &logs[0],
                    "[WARN] [FT_TRANSFER_CALL_REFUND_NOT_APPLIED] receiver account not registered"
                );

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 100.into());
                assert_eq!(stake.ft_balance_of(to_valid_account_id(RECEIVER)), 0.into());
            });
        }

        #[test]
        fn refund_specified_with_receiver_having_insufficient_funds() {
            run_test(Some(100.into()), Some(100.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let transfer_amount = TokenAmount(500.into());
                let refund_amount = TokenAmount(200.into());
                let refund_amount_bytes = serde_json::to_vec(&refund_amount).unwrap();
                testing_env_with_promise_results(
                    ctx,
                    vec![PromiseResult::Successful(refund_amount_bytes)],
                );
                let actual_used_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    transfer_amount,
                );
                assert_eq!(actual_used_amount, 400.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 4);
                assert_eq!(
                    &logs[0],
                    "[WARN] [FT_TRANSFER_CALL_PARTIAL_REFUND] partial refund will be applied because receiver account has insufficient fund"
                );
                assert_eq!(
                    &logs[1],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)"
                );
                assert_eq!(&logs[2], "[INFO] [FT_TRANSFER_CALL_RECEIVER_DEBIT] 100");
                assert_eq!(&logs[3], "[INFO] [FT_TRANSFER_CALL_SENDER_CREDIT] 100");

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 200.into());
                assert_eq!(stake.ft_balance_of(to_valid_account_id(RECEIVER)), 0.into());
            });
        }

        #[test]
        fn refund_specified_receiver_having_zero_balance() {
            run_test(Some(100.into()), Some(0.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let transfer_amount = TokenAmount(500.into());
                let refund_amount = TokenAmount(200.into());
                let refund_amount_bytes = serde_json::to_vec(&refund_amount).unwrap();
                testing_env_with_promise_results(
                    ctx,
                    vec![PromiseResult::Successful(refund_amount_bytes)],
                );
                let actual_used_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    transfer_amount,
                );
                assert_eq!(actual_used_amount, transfer_amount);

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(
                    &logs[0],
                    "[WARN] [FT_TRANSFER_CALL_REFUND_NOT_APPLIED] receiver account has zero balance"
                );

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 100.into());
                assert_eq!(stake.ft_balance_of(to_valid_account_id(RECEIVER)), 0.into());
            });
        }

        #[test]
        fn refund_specified_sender_not_registered() {
            run_test(None, Some(1000.into()), |mut ctx, mut stake| {
                ctx.predecessor_account_id = ctx.current_account_id.clone();
                let transfer_amount = TokenAmount(500.into());
                let refund_amount = TokenAmount(200.into());
                let refund_amount_bytes = serde_json::to_vec(&refund_amount).unwrap();
                testing_env_with_promise_results(
                    ctx,
                    vec![PromiseResult::Successful(refund_amount_bytes)],
                );
                let initial_token_supply = stake.ft_total_supply();
                let actual_used_amount = stake.ft_resolve_transfer_call(
                    to_valid_account_id(SENDER),
                    to_valid_account_id(RECEIVER),
                    transfer_amount,
                );
                assert_eq!(actual_used_amount, transfer_amount - refund_amount);

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 2);
                assert_eq!(&logs[0], "[INFO] [FT_TRANSFER_CALL_RECEIVER_DEBIT] 200");
                assert_eq!(
                    &logs[1],
                    "[INFO] [FT_BURN] sender account is not registered: 200"
                );

                assert_eq!(stake.ft_balance_of(to_valid_account_id(SENDER)), 0.into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(RECEIVER)),
                    800.into()
                );
                // Assert token supply is reduced when tokens are burned
                assert_eq!(
                    stake.ft_total_supply(),
                    (*initial_token_supply - 200).into()
                );
            });
        }
    }
}

#[cfg(test)]
mod tests_operator {
    use super::*;
    use crate::*;
    use near_sdk::VMContext;
    use oysterpack_smart_account_management::components::account_management::AccountManagementComponentConfig;
    use oysterpack_smart_account_management::{PermissionsManagement, StorageManagement};
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    type AccountDataType = ();
    type AccountManager = AccountManagementComponent<AccountDataType>;
    type STAKE = FungibleTokenComponent<AccountDataType>;

    const ADMIN: &str = "admin";

    fn deploy_comps() {
        AccountManager::deploy(AccountManagementComponentConfig::new(to_valid_account_id(
            ADMIN,
        )));

        STAKE::deploy(FungibleTokenConfig {
            metadata: Metadata {
                spec: FT_METADATA_SPEC.into(),
                name: "STAKE".into(),
                symbol: "STAKE".into(),
                icon: None,
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
            token_supply: YOCTO,
        });
    }

    #[test]
    fn operator_commands() {
        // Arrange
        let operator = "operator";
        let mut ctx = new_context(operator);
        testing_env!(ctx.clone());

        deploy_comps();

        let mut account_manager = AccountManager::default();

        // register operator account
        {
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, None);

            ctx.attached_deposit = 0;
            ctx.predecessor_account_id = ADMIN.to_string();
            testing_env!(ctx.clone());
            account_manager.ops_permissions_grant_operator(to_valid_account_id(operator));
        }

        let mut stake = STAKE::new(account_manager);

        fn run_operator_commands(mut ctx: VMContext, stake: &mut STAKE, account_id: &str) {
            // Act
            ctx.predecessor_account_id = account_id.to_string();
            testing_env!(ctx.clone());
            let icon = Icon("data://image/svg+xml,<svg></svg>".to_string());
            let command = OperatorCommand::SetIcon(icon.clone());
            println!("{}", serde_json::to_string(&command).unwrap());
            stake.ft_operator_command(command);
            // Assert
            let metadata = stake.ft_metadata();
            assert_eq!(metadata.icon, Some(icon));

            // Act
            ctx.predecessor_account_id = account_id.to_string();
            testing_env!(ctx.clone());
            let reference = Reference("http://stake.json".to_string());
            let hash = Hash::from("reference");
            let command = OperatorCommand::SetReference(reference.clone(), hash);
            println!("{}", serde_json::to_string(&command).unwrap());
            stake.ft_operator_command(command);
            // Assert
            let metadata = stake.ft_metadata();
            assert_eq!(metadata.reference, Some(reference));
            assert_eq!(metadata.reference_hash, Some(hash));

            // Act
            ctx.predecessor_account_id = account_id.to_string();
            testing_env!(ctx.clone());
            let command = OperatorCommand::ClearIcon;
            println!("{}", serde_json::to_string(&command).unwrap());
            stake.ft_operator_command(command);
            // Assert
            let metadata = stake.ft_metadata();
            assert!(metadata.icon.is_none());

            // Act
            ctx.predecessor_account_id = account_id.to_string();
            testing_env!(ctx.clone());
            let command = OperatorCommand::ClearReference;
            println!("{}", serde_json::to_string(&command).unwrap());
            stake.ft_operator_command(command);
            // Assert
            let metadata = stake.ft_metadata();
            assert!(metadata.reference.is_none());
            assert!(metadata.reference_hash.is_none());

            // Act
            ctx.predecessor_account_id = account_id.to_string();
            testing_env!(ctx.clone());
            let command = OperatorCommand::SetTransferCallbackGas(TGas(15));
            println!("{}", serde_json::to_string(&command).unwrap());
            stake.ft_operator_command(command);
            // Assert
            assert_eq!(stake.ft_operator_transfer_callback_gas(), TGas(15).into());
        }

        run_operator_commands(ctx.clone(), &mut stake, ADMIN);
        run_operator_commands(ctx.clone(), &mut stake, operator);
    }

    #[test]
    #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
    fn operator_commands_as_not_operator() {
        // Arrange
        let account = "account";
        let mut ctx = new_context(account);
        testing_env!(ctx.clone());

        deploy_comps();

        let mut account_manager = AccountManager::default();

        // register normal account with no permissions
        {
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, None);
        }

        let mut stake = STAKE::new(account_manager);
        stake.ft_operator_command(OperatorCommand::ClearReference);
    }

    #[test]
    #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
    fn operator_commands_with_unregistered_account() {
        // Arrange
        let account = "account";
        let ctx = new_context(account);
        testing_env!(ctx);

        deploy_comps();

        let account_manager = AccountManager::default();

        let mut stake = STAKE::new(account_manager);
        stake.ft_operator_command(OperatorCommand::ClearReference);
    }
}

#[cfg(test)]
mod tests_token_service {
    use super::*;

    use crate::*;
    use near_sdk::{test_utils, VMContext};
    use oysterpack_smart_account_management::components::account_management::AccountManagementComponentConfig;
    use oysterpack_smart_account_management::StorageManagement;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    type AccountDataType = ();
    type AccountManager = AccountManagementComponent<AccountDataType>;
    type STAKE = FungibleTokenComponent<AccountDataType>;

    const ADMIN: &str = "admin";

    fn deploy_comps() {
        AccountManager::deploy(AccountManagementComponentConfig::new(to_valid_account_id(
            ADMIN,
        )));

        STAKE::deploy(FungibleTokenConfig {
            metadata: Metadata {
                spec: FT_METADATA_SPEC.into(),
                name: "STAKE".into(),
                symbol: "STAKE".into(),
                icon: None,
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
            token_supply: YOCTO,
        });
    }

    const ACCOUNT: &str = "bob";

    /// - if the balances are Some then register them and mint tokens for them
    fn run_test<F>(account_balance: Option<TokenAmount>, test: F)
    where
        F: FnOnce(VMContext, STAKE),
    {
        // Arrange
        let ctx = new_context(ACCOUNT);
        testing_env!(ctx.clone());

        deploy_comps();

        let account_manager = AccountManager::default();

        let mut stake = STAKE::new(account_manager);

        // register accounts
        {
            let mut account_manager = AccountManager::default();

            if let Some(balance) = account_balance {
                let mut ctx = ctx.clone();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = account_manager.storage_balance_bounds().min.value();
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                if *balance > 0 {
                    stake.ft_mint(ACCOUNT, balance);
                }
            }
        }

        test(ctx, stake);
    }

    #[cfg(test)]
    mod tests_mint {
        use super::*;

        #[test]
        fn account_registered_with_zero_token_balance() {
            run_test(Some(0.into()), |ctx, mut stake| {
                testing_env!(ctx);
                let initial_token_supply = stake.ft_total_supply();
                stake.ft_mint(ACCOUNT, 1000.into());
                assert_eq!(
                    stake.ft_total_supply(),
                    (*initial_token_supply + 1000).into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 2);
                assert_eq!(
                    &logs[0],
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)"
                );
                assert_eq!(&logs[1], "[INFO] [FT_MINT] account: bob, amount: 1000");

                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(ACCOUNT)),
                    1000.into()
                );
            });
        }

        #[test]
        fn account_registered_with_token_balance() {
            run_test(Some(1000.into()), |ctx, mut stake| {
                testing_env!(ctx);
                let initial_token_supply = stake.ft_total_supply();
                stake.ft_mint(ACCOUNT, 1000.into());
                assert_eq!(
                    stake.ft_total_supply(),
                    (*initial_token_supply + 1000).into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(&logs[0], "[INFO] [FT_MINT] account: bob, amount: 1000");

                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(ACCOUNT)),
                    2000.into()
                );
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
        fn account_not_registered() {
            run_test(None, |ctx, mut stake| {
                testing_env!(ctx);
                stake.ft_mint(ACCOUNT, 1000.into());
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [INVALID] mint amount cannot be zero")]
        fn zero_amount() {
            run_test(Some(1000.into()), |ctx, mut stake| {
                testing_env!(ctx);
                stake.ft_mint(ACCOUNT, 0.into());
            });
        }
    }

    #[cfg(test)]
    mod tests_burn {
        use super::*;

        #[test]
        fn burn_account_partial_balance() {
            run_test(Some(10000.into()), |ctx, mut stake| {
                testing_env!(ctx);
                let initial_token_supply = stake.ft_total_supply();
                stake.ft_burn(ACCOUNT, 1000.into());
                assert_eq!(
                    stake.ft_total_supply(),
                    (*initial_token_supply - 1000).into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(&logs[0], "[INFO] [FT_BURN] account: bob, amount: 1000");

                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(ACCOUNT)),
                    9000.into()
                );
            });
        }

        #[test]
        fn burn_account_partial_balance_with_locked_balance() {
            run_test(Some(10000.into()), |ctx, mut stake| {
                testing_env!(ctx.clone());
                stake.ft_lock(ACCOUNT, 500.into());

                testing_env!(ctx.clone());
                let initial_token_supply = stake.ft_total_supply();
                stake.ft_burn(ACCOUNT, 1000.into());
                assert_eq!(
                    stake.ft_total_supply(),
                    (*initial_token_supply - 1000).into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(&logs[0], "[INFO] [FT_BURN] account: bob, amount: 1000");

                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(ACCOUNT)),
                    9000.into()
                );
            });
        }

        #[test]
        fn burn_account_full_balance() {
            run_test(Some(10000.into()), |ctx, mut stake| {
                testing_env!(ctx);
                let initial_token_supply = stake.ft_total_supply();
                stake.ft_burn(ACCOUNT, 10000.into());
                assert_eq!(
                    stake.ft_total_supply(),
                    (*initial_token_supply - 10000).into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)",
                        "[INFO] [FT_BURN] account: bob, amount: 10000",
                    ]
                );

                assert_eq!(stake.ft_balance_of(to_valid_account_id(ACCOUNT)), 0.into());
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
        fn account_not_registered() {
            run_test(None, |_ctx, mut stake| {
                stake.ft_burn(ACCOUNT, 10000.into());
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [INVALID] burn amount cannot be zero")]
        fn burn_zero_amount() {
            run_test(Some(1000.into()), |_ctx, mut stake| {
                stake.ft_burn(ACCOUNT, 0.into());
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [INVALID] account has insufficient funds")]
        fn account_has_insufficient_funds() {
            run_test(Some(1.into()), |_ctx, mut stake| {
                stake.ft_burn(ACCOUNT, 10000.into());
            });
        }
    }

    #[cfg(test)]
    mod tests_burn_all {
        use super::*;

        #[test]
        fn account_registered_with_balance() {
            run_test(Some(10000.into()), |ctx, mut stake| {
                testing_env!(ctx);
                let initial_token_supply = stake.ft_total_supply();
                stake.ft_burn_all(ACCOUNT);
                assert_eq!(
                    stake.ft_total_supply(),
                    (*initial_token_supply - 10000).into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)",
                        "[INFO] [FT_BURN] account: bob, amount: 10000",
                    ]
                );

                assert_eq!(stake.ft_balance_of(to_valid_account_id(ACCOUNT)), 0.into());
            });
        }

        #[test]
        fn account_registered_with_zero_balance() {
            run_test(Some(0.into()), |ctx, mut stake| {
                testing_env!(ctx);
                let initial_token_supply = stake.ft_total_supply();
                stake.ft_burn_all(ACCOUNT);
                assert_eq!(stake.ft_total_supply(), initial_token_supply);

                let logs = test_utils::get_logs();
                assert!(logs.is_empty());

                assert_eq!(stake.ft_balance_of(to_valid_account_id(ACCOUNT)), 0.into());
            });
        }

        #[test]
        fn account_not_registered() {
            run_test(Some(0.into()), |ctx, mut stake| {
                testing_env!(ctx);
                let initial_token_supply = stake.ft_total_supply();
                stake.ft_burn_all("doesnotexist");
                assert_eq!(stake.ft_total_supply(), initial_token_supply);

                let logs = test_utils::get_logs();
                assert!(logs.is_empty());

                assert_eq!(stake.ft_balance_of(to_valid_account_id(ACCOUNT)), 0.into());
            });
        }
    }

    #[cfg(test)]
    mod tests_lock_unlock {
        use super::*;

        #[test]
        fn with_balance() {
            run_test(Some(1000.into()), |ctx, mut stake| {
                // Arrange
                testing_env!(ctx.clone());
                let initial_token_supply = stake.ft_total_supply();

                // Act
                testing_env!(ctx.clone());
                stake.ft_lock(ACCOUNT, 400.into());
                // Assert
                assert_eq!(stake.ft_total_supply(), (*initial_token_supply).into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(ACCOUNT)),
                    600.into()
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(&logs[0], "[INFO] [FT_LOCK] account: bob, amount: 400");

                assert_eq!(stake.ft_locked_balance(ACCOUNT).unwrap(), 400.into());

                // Act
                testing_env!(ctx.clone());
                stake.ft_lock(ACCOUNT, 600.into());
                // Assert
                assert_eq!(stake.ft_total_supply(), (*initial_token_supply).into());
                assert_eq!(stake.ft_balance_of(to_valid_account_id(ACCOUNT)), 0.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(&logs[0], "[INFO] [FT_LOCK] account: bob, amount: 600");

                assert_eq!(stake.ft_locked_balance(ACCOUNT).unwrap(), 1000.into());

                // Act
                testing_env!(ctx.clone());
                stake.ft_unlock(ACCOUNT, 600.into());
                // Assert
                assert_eq!(stake.ft_total_supply(), (*initial_token_supply).into());
                assert_eq!(
                    stake.ft_balance_of(to_valid_account_id(ACCOUNT)),
                    600.into()
                );
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(&logs[0], "[INFO] [FT_UNLOCK] account: bob, amount: 600");

                assert_eq!(stake.ft_locked_balance(ACCOUNT).unwrap(), 400.into());

                // Act
                testing_env!(ctx.clone());
                stake.ft_lock_all(ACCOUNT);

                assert_eq!(stake.ft_balance_of(to_valid_account_id(ACCOUNT)), 0.into());
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs.len(), 1);
                assert_eq!(&logs[0], "[INFO] [FT_LOCK] account: bob, amount: 600");

                assert_eq!(stake.ft_locked_balance(ACCOUNT).unwrap(), 1000.into());
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
        fn with_insufficient_balance() {
            run_test(Some(0.into()), |ctx, mut stake| {
                // Arrange
                testing_env!(ctx.clone());
                stake.ft_mint(ACCOUNT, 1000.into());

                // Act
                testing_env!(ctx);
                stake.ft_lock(ACCOUNT, 1400.into());
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
        fn with_zero_balance() {
            run_test(Some(0.into()), |ctx, mut stake| {
                // Act
                testing_env!(ctx);
                stake.ft_lock(ACCOUNT, 400.into());
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
        fn account_not_registered() {
            run_test(None, |ctx, mut stake| {
                testing_env!(ctx);
                stake.ft_lock(ACCOUNT, 1000.into());
            });
        }

        #[test]
        #[should_panic(expected = "[ERR] [INVALID] lock amount cannot be zero")]
        fn zero_amount() {
            run_test(Some(1000.into()), |ctx, mut stake| {
                testing_env!(ctx);
                stake.ft_lock(ACCOUNT, 0.into());
            });
        }
    }
}

'''
'''--- near/oysterpack-smart-fungible-token/src/domain.rs ---
mod memo;
mod metadata;
mod token_amount;
mod transfer_call_message;

pub use memo::*;
pub use metadata::*;
pub use token_amount::*;
pub use transfer_call_message::*;

'''
'''--- near/oysterpack-smart-fungible-token/src/domain/memo.rs ---
use oysterpack_smart_near::near_sdk::serde::{Deserialize, Serialize};
use std::fmt::{self, Display, Formatter};
use std::ops::Deref;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct Memo(pub String);

impl Deref for Memo {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<&str> for Memo {
    fn from(memo: &str) -> Self {
        Self(memo.to_string())
    }
}

impl From<String> for Memo {
    fn from(memo: String) -> Self {
        Self(memo)
    }
}

impl Display for Memo {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

'''
'''--- near/oysterpack-smart-fungible-token/src/domain/metadata.rs ---
use crate::FT_METADATA_SPEC;
use oysterpack_smart_near::asserts::ERR_INVALID;
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};
use oysterpack_smart_near::Hash;
use std::fmt::{self, Display, Formatter};
use std::ops::Deref;

/// The following fields are immutable once the FT contract is deployed:
/// - [`Metadata::spec`]
/// - [`Metadata::name`]
/// - [`Metadata::symbol`]
/// - [`Metadata::decimals`]
///
/// The following fields can be updated by the contract owner or accounts that have the admin permission:
/// - [`Metadata::icon`]
/// - [`Metadata::reference`]
/// - [`Metadata::reference_hash`]
///
/// NOTE: how optional metadata is stored off-chain is out of scope
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct Metadata {
    pub spec: Spec,
    pub name: Name,
    pub symbol: Symbol,
    pub decimals: u8,

    pub icon: Option<Icon>,
    pub reference: Option<Reference>,
    /// sha256 hash of the JSON file contained in the reference field. This is to guard against off-chain tampering.
    pub reference_hash: Option<Hash>,
}

impl Metadata {
    pub fn assert_valid(&self) {
        ERR_INVALID.assert(
            || FT_METADATA_SPEC == self.spec.0,
            || format!("`spec` must be `{}`", FT_METADATA_SPEC),
        );

        ERR_INVALID.assert(
            || {
                self.reference.is_some() == self.reference_hash.is_some()
            },
            || "if one of `reference` and `reference_hash` is specified, then both must be specified",
        );
    }
}

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct Spec(pub String);

impl Deref for Spec {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<&str> for Spec {
    fn from(memo: &str) -> Self {
        Self(memo.to_string())
    }
}

impl From<String> for Spec {
    fn from(memo: String) -> Self {
        Self(memo)
    }
}

impl Display for Spec {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct Name(pub String);

impl Deref for Name {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<&str> for Name {
    fn from(memo: &str) -> Self {
        Self(memo.to_string())
    }
}

impl From<String> for Name {
    fn from(memo: String) -> Self {
        Self(memo)
    }
}

impl Display for Name {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct Symbol(pub String);

impl Deref for Symbol {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<&str> for Symbol {
    fn from(memo: &str) -> Self {
        Self(memo.to_string())
    }
}

impl From<String> for Symbol {
    fn from(memo: String) -> Self {
        Self(memo)
    }
}

impl Display for Symbol {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

/// A small image associated with this token.
/// Must be a data URL, to help consumers display it quickly while protecting user data.
///
/// ### Recommendations
/// - use optimized SVG, which can result in high-resolution images with only 100s of bytes of storage cost.
///   - Note that these storage costs are incurred to the token owner/deployer, but that querying these
///     icons is a very cheap & cacheable read operation for all consumers of the contract and the RPC
///     nodes that serve the data.
/// - create icons that will work well with both light-mode and dark-mode websites by either using
/// middle-tone color schemes, or by embedding media queries in the SVG.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct Icon(pub String);

impl Deref for Icon {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<&str> for Icon {
    fn from(memo: &str) -> Self {
        Self(memo.to_string())
    }
}

impl From<String> for Icon {
    fn from(memo: String) -> Self {
        Self(memo)
    }
}

impl Display for Icon {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

/// A link to a valid JSON file containing various keys offering supplementary details on the token.
/// Example: "/ipfs/QmdmQXB2mzChmMeKY47C43LxUdg1NDJ5MWcKMKxDu7RgQm", "https://example.com/token.json", etc.
///
///
/// If the information given in this document conflicts with the on-chain attributes, then the values
/// in reference shall be considered the source of truth.
#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize, PartialEq, Debug)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct Reference(pub String);

impl Deref for Reference {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<&str> for Reference {
    fn from(memo: &str) -> Self {
        Self(memo.to_string())
    }
}

impl From<String> for Reference {
    fn from(memo: String) -> Self {
        Self(memo)
    }
}

impl Display for Reference {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

'''
'''--- near/oysterpack-smart-fungible-token/src/domain/token_amount.rs ---
use oysterpack_smart_near::data::numbers::U128;
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};
use std::fmt::{self, Display, Formatter};
use std::ops::{Add, AddAssign, Deref, DerefMut, Sub, SubAssign};

#[derive(
    BorshDeserialize,
    BorshSerialize,
    Serialize,
    Deserialize,
    Debug,
    Clone,
    Copy,
    PartialEq,
    Eq,
    PartialOrd,
    Ord,
    Default,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct TokenAmount(pub U128);

impl TokenAmount {
    pub const ZERO: TokenAmount = TokenAmount(U128(0));
}

impl Deref for TokenAmount {
    type Target = u128;

    fn deref(&self) -> &Self::Target {
        self.0.deref()
    }
}

impl DerefMut for TokenAmount {
    fn deref_mut(&mut self) -> &mut Self::Target {
        self.0.deref_mut()
    }
}

impl From<u128> for TokenAmount {
    fn from(amount: u128) -> Self {
        TokenAmount(amount.into())
    }
}

impl Display for TokenAmount {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Sub<TokenAmount> for TokenAmount {
    type Output = TokenAmount;

    fn sub(self, rhs: TokenAmount) -> Self::Output {
        (*self - *rhs).into()
    }
}

impl SubAssign<TokenAmount> for TokenAmount {
    fn sub_assign(&mut self, rhs: TokenAmount) {
        **self -= *rhs;
    }
}

impl Add<TokenAmount> for TokenAmount {
    type Output = TokenAmount;

    fn add(self, rhs: TokenAmount) -> Self::Output {
        (*self + *rhs).into()
    }
}

impl AddAssign<TokenAmount> for TokenAmount {
    fn add_assign(&mut self, rhs: TokenAmount) {
        **self += *rhs;
    }
}

'''
'''--- near/oysterpack-smart-fungible-token/src/domain/transfer_call_message.rs ---
use oysterpack_smart_near::near_sdk::serde::{Deserialize, Serialize};
use std::fmt::{self, Display, Formatter};
use std::ops::Deref;

#[derive(Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct TransferCallMessage(pub String);

impl Deref for TransferCallMessage {
    type Target = str;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl From<&str> for TransferCallMessage {
    fn from(memo: &str) -> Self {
        Self(memo.to_string())
    }
}

impl From<String> for TransferCallMessage {
    fn from(memo: String) -> Self {
        Self(memo)
    }
}

impl Display for TransferCallMessage {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

'''
'''--- near/oysterpack-smart-fungible-token/src/interface.rs ---
pub use contract::fungible_token::*;
pub use contract::metadata::*;
pub use contract::operator::*;
pub use token_service::*;

pub mod contract;
mod token_service;

'''
'''--- near/oysterpack-smart-fungible-token/src/interface/contract.rs ---
//! Contract Interfaces

pub mod fungible_token;
pub mod metadata;
pub mod operator;

'''
'''--- near/oysterpack-smart-fungible-token/src/interface/contract/fungible_token.rs ---
use crate::*;
use oysterpack_smart_near::near_sdk::json_types::ValidAccountId;
use oysterpack_smart_near::near_sdk::{Promise, PromiseOrValue};
use oysterpack_smart_near::{ErrCode, Level, LogEvent};

/// # **Contract Interface**: [Fungible Token Core API][1]
///
/// The core standard supports the following features:
/// - [simple token transfers](FungibleToken::ft_transfer)
/// - [token transfers between contracts](FungibleToken::ft_transfer_call)
/// - accounting for [total token supply](FungibleToken::ft_total_supply) and
///   [account balances](FungibleToken::ft_balance_of)
///
/// ### Security
/// Requirement for accept attached deposits (#\[payable\])
/// Due to the nature of function-call permission access keys on NEAR protocol, the method that
/// requires an attached deposit can't be called by the restricted access key. If the token contract
/// requires an attached deposit of at least 1 yoctoNEAR on transfer methods, then the function-call
/// restricted access key will not be able to call them without going through the wallet confirmation.
/// This prevents some attacks like fishing through an authorization to a token contract.
///
/// This 1 yoctoNEAR is enforced by this standard.
///
/// ### Transfer Call Refunds
/// If the receiver contract is malicious or incorrectly implemented, then the receiver's promise
/// result may be invalid and the required balance may not be available on the receiver's account.
/// In this case the refund can't be provided provided to the sender. This is prevented by #122
/// standard that locks funds into a temporary vault and prevents receiver from overspending the
/// funds and later retuning invalid value. But if this flaw exist in this standard, it's not an
/// issue for the sender account. It only affects the transfer amount and the receiver's account
/// balance. The receiver can't overspend tokens from the sender outside of sent amount, so this
/// standard must be considered as safe as #122
///
/// [1]: https://nomicon.io/Standards/Tokens/FungibleTokenCore.html
pub trait FungibleToken: ResolveTransferCall {
    /// Enables simple transfer between accounts.
    ///
    /// - Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// - Both accounts must be registered with the contract for transfer to succeed.
    /// - Sender account is required to attach exactly 1 yoctoNEAR to the function call - see security
    ///   section of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer - unsigned integer in string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    ///
    /// ## Log Events
    /// - [`LOG_EVENT_FT_TRANSFER`] - if there is a memo
    ///
    /// ## NOTES
    /// The 1 yoctoNEAR that is attached is not credited to the sender account because crediting the
    /// 1 yoctoNEAR will cost the sender more in gas than the 1 yoctoNEAR.
    ///
    /// ## Panics
    /// - if the attached deposit does not equal 1 yoctoNEAR
    /// - if either sender or receiver accounts are not registered
    /// - if amount is zero
    /// - if the sender account has insufficient funds to fulfill the request
    ///
    /// #\[payable\]
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: TokenAmount, memo: Option<Memo>);

    /// Transfer to a contract with a callback.
    ///
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`
    /// account. Then calls [`TransferReceiver::ft_on_transfer`] method on `receiver_id` contract
    /// and attaches a callback to resolve this transfer.
    ///
    /// [TransferReceiver::ft_on_transfer] method  must return the amount of tokens unused by
    /// the receiver contract, the remaining tokens must be refunded to the `predecessor_account_id`
    /// by the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to [`TransferReceiver::ft_on_transfer`]
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount
    ///   must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower
    ///   than the required refund amount, the remaining balance must be refunded.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed.
    /// Sender must attach exactly 1 yoctoNEAR - see security section of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer - unsigned integer in string representation.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    ///
    /// Returns a promise to resolve transfer call which will return the used amount - [`ResolveTransferCall`]
    ///
    /// ## Panics
    /// - if the attached deposit is not exactly 1 yoctoNEAR
    /// - if either sender or receiver accounts are not registered
    /// - if amount is zero
    /// - if the sender account has insufficient funds to fulfill the transfer request
    ///
    /// #\[payable\]
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: TokenAmount,
        memo: Option<Memo>,
        msg: TransferCallMessage,
    ) -> Promise;

    fn ft_total_supply(&self) -> TokenAmount;

    /// If the account doesn't exist, then zero is returned.
    fn ft_balance_of(&self, account_id: ValidAccountId) -> TokenAmount;
}

/// # **Contract Interface**: [Fungible Token Transfer Call Resolver API][1]
/// Private callback on fungible token contract to resolve transfer as part of the token transfer call
/// workflow - see [`FungibleToken::ft_transfer_call`]
///
/// [1]: https://nomicon.io/Standards/Tokens/FungibleTokenCore.html
pub trait ResolveTransferCall {
    /// Callback to resolve transfer.
    /// Private method (`env::predecessor_account_id == env::current_account_id`).
    ///
    /// Called after the receiver handles the transfer call and returns unused token amount.
    ///
    /// This method must get `unused_amount` from the receiver's promise result and refund the
    /// `unused_amount` from the receiver's account back to the `sender_id` account.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `receiver_id` - the account ID of the receiver contract.
    /// - `amount` - the amount of tokens that were transferred to receiver's account.
    ///
    /// Promise result data dependency (`unused_amount`):
    /// - the amount of tokens that were unused by receiver's contract.
    /// - Received from `on_ft_receive`
    /// - `unused_amount` must be `U128` in range from `0` to `amount`. All other invalid values
    ///   are considered to be equal to be the total transfer amount.
    ///
    /// Returns amount that was actually refunded, which ultimately derives from the amount that was
    /// debited from the receiver account.
    /// - **NOTE**: The actual refund amount may be less then the requested refund amount. If the actual
    ///   refund amount is less than expected, then it could mean:
    ///   - the receiver account transferred out the tokens while this transfer call workflow was in flight
    ///   - there is a bug in the receiver contract
    ///   - the receiver contract is acting maliciously
    ///
    /// The callback should be designed to never panic.
    /// - if the `sender_id` is not registered, then refunded tokens will be burned
    /// - if the `receiver_id` is not registered, then the contract should be able to handle it
    ///
    /// #\[private\]
    fn ft_resolve_transfer_call(
        &mut self,
        sender_id: ValidAccountId,
        receiver_id: ValidAccountId,
        amount: TokenAmount,
    ) -> TokenAmount;
}

pub const LOG_EVENT_FT_TRANSFER: LogEvent = LogEvent(Level::INFO, "FT_TRANSFER");

pub const LOG_EVENT_FT_TRANSFER_CALL_FAILURE: LogEvent =
    LogEvent(Level::WARN, "FT_TRANSFER_CALL_FAILURE");

pub const LOG_EVENT_FT_TRANSFER_CALL_PARTIAL_REFUND: LogEvent =
    LogEvent(Level::WARN, "FT_TRANSFER_CALL_PARTIAL_REFUND");

pub const LOG_EVENT_FT_TRANSFER_CALL_RECEIVER_DEBIT: LogEvent =
    LogEvent(Level::INFO, "FT_TRANSFER_CALL_RECEIVER_DEBIT");

pub const LOG_EVENT_FT_TRANSFER_CALL_SENDER_CREDIT: LogEvent =
    LogEvent(Level::INFO, "FT_TRANSFER_CALL_SENDER_CREDIT");

pub const LOG_EVENT_FT_TRANSFER_CALL_REFUND_NOT_APPLIED: LogEvent =
    LogEvent(Level::WARN, "FT_TRANSFER_CALL_REFUND_NOT_APPLIED");

pub const ERR_CODE_FT_RESOLVE_TRANSFER: ErrCode = ErrCode("FT_RESOLVE_TRANSFER");

/// # **Contract Interface**: [Fungible Token Transfer Call Receiver API][1]
/// Contracts that want to receive token transfers as part of the transfer call workflow should
/// implement this interface - see [`FungibleToken::ft_transfer_call`]
///
/// [1]: https://nomicon.io/Standards/Tokens/FungibleTokenCore.html
pub trait TransferReceiver {
    /// Callback to receive tokens.
    ///
    /// Called by fungible token contract `env::predecessor_account_id` after `transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are not used/accepted by this contract from
    /// the transferred amount, e.g.:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of tokens that were not used and should be refunded back to the sender.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: TokenAmount,
        msg: TransferCallMessage,
    ) -> PromiseOrValue<TokenAmount>;
}

'''
'''--- near/oysterpack-smart-fungible-token/src/interface/contract/metadata.rs ---
use crate::Metadata;

pub const FT_METADATA_SPEC: &'static str = "ft-1.0.0";

/// # **Contract Interface**: [Fungible Token Metadata API][1]
///
/// [1]: https://nomicon.io/Standards/Tokens/FungibleTokenMetadata.html
pub trait FungibleTokenMetadataProvider {
    fn ft_metadata(&self) -> Metadata;
}

'''
'''--- near/oysterpack-smart-fungible-token/src/interface/contract/operator.rs ---
use crate::{Icon, Reference};
use oysterpack_smart_near::domain::{Gas, TGas};
use oysterpack_smart_near::near_sdk::serde::{Deserialize, Serialize};
use oysterpack_smart_near::Hash;

/// # **Contract Interface**: Fungible Token Operator API
pub trait FungibleTokenOperator {
    /// Executes the specified operator command
    ///
    /// ## Panics
    /// - if predecessor account is not registered
    /// - if predecessor account is not authorized - requires operator permission
    fn ft_operator_command(&mut self, command: OperatorCommand);

    /// returns the amount of gas configured for the resolve transfer callback
    fn ft_operator_transfer_callback_gas(&self) -> Gas;
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub enum OperatorCommand {
    SetIcon(Icon),
    ClearIcon,
    SetReference(Reference, Hash),
    ClearReference,
    SetTransferCallbackGas(TGas),
}

'''
'''--- near/oysterpack-smart-fungible-token/src/interface/token_service.rs ---
use crate::TokenAmount;
use oysterpack_smart_near::{Level, LogEvent};

/// Provides basic functions to operate the fungible token.
pub trait TokenService {
    /// Mints new tokens and credits them to the specified account ID, which increases the total supply.
    /// - logs [`LOG_EVENT_FT_MINT`]
    ///
    /// Returns updated token balance
    ///
    /// **Use Case:** STAKE tokens are minted when NEAR is staked.
    ///
    /// ## Panics
    /// - if the account is not registered
    /// - if amount is zero
    fn ft_mint(&mut self, account_id: &str, amount: TokenAmount) -> TokenAmount;

    /// Debits tokens from the specified account ID and burns them, which decreases the total supply.
    /// - logs [`LOG_EVENT_FT_BURN`]
    ///
    /// Returns updated token balance
    ///
    /// **Use Case:** STAKE tokens are burned when they are unstaked and converted back to NEAR.
    ///
    /// ## Notes
    /// - burns locked tokens first
    ///
    /// ## Panics
    /// - if the account is not registered
    /// - if amount is zero
    fn ft_burn(&mut self, account_id: &str, amount: TokenAmount) -> TokenAmount;

    /// Attempts to burn the account's total token balance.
    /// - logs [`LOG_EVENT_FT_BURN`]
    fn ft_burn_all(&mut self, account_id: &str);

    /// Locks the specified number of tokens on the specified account.
    /// - logs [`LOG_EVENT_FT_LOCK`]
    ///
    /// The account owns the tokens but they cannot be transferred while locked.
    ///
    /// ## Panics
    /// - if the account is not registered
    /// - if amount is zero
    fn ft_lock(&mut self, account_id: &str, amount: TokenAmount);

    /// convenience method that locks the remaining available balance
    fn ft_lock_all(&mut self, account_id: &str);

    /// Unlocks the specified amount of tokens and makes them available for transfers
    /// - logs [`LOG_EVENT_FT_UNLOCK`]
    ///
    ///
    /// ## Panics
    /// - if the account is not registered
    /// - if amount is zero
    fn ft_unlock(&mut self, account_id: &str, amount: TokenAmount);

    /// Attempts to unlock the account's total locked token balance.
    /// - logs [`LOG_EVENT_FT_UNLOCK`]
    ///
    /// ## Panics
    /// - if the account is not registered
    fn ft_unlock_all(&mut self, account_id: &str);

    /// Returns the accounts locked balance or None if the account is not registered.
    fn ft_locked_balance(&mut self, account_id: &str) -> Option<TokenAmount>;
}

pub const LOG_EVENT_FT_MINT: LogEvent = LogEvent(Level::INFO, "FT_MINT");
pub const LOG_EVENT_FT_BURN: LogEvent = LogEvent(Level::INFO, "FT_BURN");

pub const LOG_EVENT_FT_LOCK: LogEvent = LogEvent(Level::INFO, "FT_LOCK");
pub const LOG_EVENT_FT_UNLOCK: LogEvent = LogEvent(Level::INFO, "FT_UNLOCK");

'''
'''--- near/oysterpack-smart-fungible-token/src/lib.rs ---
pub mod components;
mod domain;
mod interface;

pub use domain::*;
pub use interface::*;

'''
'''--- near/oysterpack-smart-near-test/Cargo.toml ---
[package]
name = "oysterpack-smart-near-test"
version = "0.1.0"
authors = ["oysterpack.inc <2zP6OaymGZhJTHFvQMzp6Ze>"]
edition = "2018"

[dependencies]
near-sdk = "3"
near-vm-logic = "3"
oysterpack-smart-near = {path = "../oysterpack-smart-near"}
'''
'''--- near/oysterpack-smart-near-test/Makefile.toml ---
extend = "../Makefile.toml"
'''
'''--- near/oysterpack-smart-near-test/README.md ---

'''
'''--- near/oysterpack-smart-near-test/src/lib.rs ---
use near_sdk::{
    env,
    serde::{Deserialize, Serialize},
    serde_json,
    test_utils::{get_created_receipts, VMContextBuilder},
    AccountId, Balance, Gas, PromiseResult, VMContext,
};
use oysterpack_smart_near::YOCTO;

pub use near_sdk::{self, testing_env, MockedBlockchain};
pub use near_vm_logic;
pub use oysterpack_smart_near::to_valid_account_id;

pub const DEFAULT_CONTRACT_ACCOUNT_ID: &str = "contract.near";

pub const DEFAULT_CONTRACT_ACCOUNT_BALANCE: u128 = 10000 * YOCTO;

/// Creates a new NEAR test context.
/// - `predecessor_account_id` is also used as the `signer_account_id`
/// - `account_balance` is set to 10000 NEAR
pub fn new_context(predecessor_account_id: &str) -> VMContext {
    VMContextBuilder::new()
        .current_account_id(to_valid_account_id(&DEFAULT_CONTRACT_ACCOUNT_ID))
        .signer_account_id(to_valid_account_id(&predecessor_account_id))
        .predecessor_account_id(to_valid_account_id(&predecessor_account_id))
        .account_balance(DEFAULT_CONTRACT_ACCOUNT_BALANCE)
        .build()
}

/// Used to inject `PromiseResult`s into the NEAR runtime test environment. This enables callbacks
/// to be unit tested.
pub fn testing_env_with_promise_results(context: VMContext, promise_results: Vec<PromiseResult>) {
    assert!(
        !promise_results.is_empty(),
        "promise_results must not be empty"
    );
    let storage = env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        promise_results,
        storage,
        Default::default(),
        Default::default(),
    )));
}

/// injects a successful promise result into the NEAR runtime testing env
pub fn testing_env_with_promise_result_success(context: VMContext) {
    testing_env_with_promise_results(context, vec![PromiseResult::Successful(vec![0])]);
}

/// injects a failed promise result into the NEAR runtime testing env
pub fn testing_env_with_promise_result_failure(context: VMContext) {
    testing_env_with_promise_results(context, vec![PromiseResult::Failed]);
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Receipt {
    pub receiver_id: String,
    pub receipt_indices: Vec<usize>,
    pub actions: Vec<Action>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum Action {
    CreateAccount,
    DeployContract(DeployContractAction),
    FunctionCall(FunctionCallAction),
    Transfer(TransferAction),
    Stake(StakeAction),
    AddKeyWithFullAccess(AddKeyWithFullAccessAction),
    AddKeyWithFunctionCall(AddKeyWithFunctionCallAction),
    DeleteKey(DeleteKeyAction),
    DeleteAccount(DeleteAccountAction),
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct DeployContractAction {
    pub code: Vec<u8>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct FunctionCallAction {
    pub method_name: String,
    pub args: String,
    pub gas: Gas,
    pub deposit: Balance,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct TransferAction {
    pub deposit: Balance,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct StakeAction {
    pub stake: Balance,
    pub public_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct AddKeyWithFullAccessAction {
    pub public_key: String,
    pub nonce: u64,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct AddKeyWithFunctionCallAction {
    pub public_key: String,
    pub nonce: u64,
    pub allowance: Option<Balance>,
    pub receiver_id: AccountId,
    pub method_names: Vec<Vec<u8>>,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct DeleteKeyAction {
    pub public_key: String,
}

#[derive(Serialize, Deserialize, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct DeleteAccountAction {
    pub beneficiary_id: AccountId,
}

pub fn deserialize_receipts() -> Vec<Receipt> {
    get_created_receipts()
        .iter()
        .map(|receipt| {
            let json = serde_json::to_string_pretty(receipt).unwrap();
            println!("{}", json);
            let receipt: Receipt = serde_json::from_str(&json).unwrap();
            receipt
        })
        .collect()
}

pub fn get_receipts() -> Vec<Receipt> {
    get_created_receipts()
        .iter()
        .map(|receipt| {
            let json = serde_json::to_string_pretty(receipt).unwrap();
            let receipt: Receipt = serde_json::from_str(&json).unwrap();
            receipt
        })
        .collect()
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::test_env::bob;
    use near_sdk::{env, testing_env, MockedBlockchain};

    #[test]
    fn inject_promise_results() {
        // Arrange
        let context = new_context(&bob());
        testing_env!(context.clone());

        // Act
        testing_env_with_promise_results(
            context.clone(),
            vec![
                PromiseResult::Successful(vec![1, 2, 3]),
                PromiseResult::Failed,
            ],
        );

        // Assert
        assert_eq!(env::promise_results_count(), 2);
    }

    #[test]
    fn promise_result_success() {
        // Arrange
        let context = new_context(&bob());
        testing_env!(context.clone());

        // Act;
        testing_env_with_promise_result_success(context);

        // Assert
        assert_eq!(env::promise_results_count(), 1);
        match env::promise_result(0) {
            PromiseResult::Successful(_) => println!("promise result was success"),
            _ => panic!("expected PromiseResult::Successful"),
        }
    }

    #[test]
    fn promise_result_failure() {
        // Arrange
        let context = new_context(&bob());
        testing_env!(context.clone());

        // Act;
        testing_env_with_promise_result_failure(context);

        // Assert
        assert_eq!(env::promise_results_count(), 1);
        match env::promise_result(0) {
            PromiseResult::Failed => println!("promise result failed"),
            _ => panic!("expected PromiseResult::Failed"),
        }
    }
}

'''
'''--- near/oysterpack-smart-near/Cargo.toml ---
[package]
name = "oysterpack-smart-near"
version = "0.1.0"
authors = ["OysterPack Inc <oysterpack.inc@gmail.com>"]
edition = "2018"

[dependencies]
near-sdk = "3"
uint = { version = "0.9.0", default-features = false }
base64 = "0.13.0"
lazy_static = "1.4.0"

[dev-dependencies]
oysterpack-smart-near-test = { path = "../oysterpack-smart-near-test" }
regex = "1.4.3"

'''
'''--- near/oysterpack-smart-near/Makefile.toml ---
extend = "../Makefile.toml"
'''
'''--- near/oysterpack-smart-near/README.md ---

'''
'''--- near/oysterpack-smart-near/src/component.rs ---
//! Defines standard component related interfaces

mod component;
mod deploy;
mod manages_account_data;

pub use component::*;
pub use deploy::*;
pub use manages_account_data::*;

'''
'''--- near/oysterpack-smart-near/src/component/component.rs ---
//! This package provides a standard for building reusable smart contract stateful components
//!
//! ## Component Design
//! - Component declares it state type and defines a u128 based storage key
//!   - recommendation is to use ULID to generate the storage key
//! - Each component is responsible for managing its own state. This means when the component state
//!   changes it is the component's responsibility to save it to storage.
//! - [`crate::component::Deploy`] - defines a pattern to standardize component deployment

use crate::data::Object;
use near_sdk::borsh::{BorshDeserialize, BorshSerialize};
use std::fmt::Debug;

/// Defines abstraction for a stateful component
pub trait Component {
    type State: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq;

    /// Used to to store the service state to blockchain storage
    /// - it is recommended to generate a ULID for the key to avoid collisions
    const STATE_KEY: u128;

    /// loads the service state from storage using the key defined by [`state_key`]()
    fn load_state() -> Option<ComponentState<Self::State>> {
        ComponentState::<Self::State>::load(&Self::STATE_KEY)
    }

    /// creates new in-memory state, i.e., the state is not persisted to storage
    fn new_state(state: Self::State) -> ComponentState<Self::State> {
        ComponentState::<Self::State>::new(Self::STATE_KEY, state)
    }
}

/// service state type
pub type ComponentState<T> = Object<u128, T>;

#[cfg(test)]
mod tests {
    use super::*;
    use crate::component::Deploy;
    use lazy_static::lazy_static;
    use oysterpack_smart_near_test::*;
    use std::ops::DerefMut;
    use std::sync::Mutex;

    lazy_static! {
        static ref FOO: Mutex<Foo> = Mutex::new(Foo::new());
    }

    type FooState = ComponentState<u128>;
    struct Foo {
        state: FooState,
    }

    impl Component for Foo {
        type State = u128;

        const STATE_KEY: u128 = 1952470210719526730429153601986271427;
    }

    impl Foo {
        fn new() -> Self {
            let state = Foo::load_state().unwrap_or(Foo::new_state(0));
            Self { state }
        }
    }

    impl Deploy for Foo {
        type Config = u128;

        fn deploy(config: Self::Config) {
            let state = Self::new_state(config);
            state.save();
        }
    }

    #[test]
    fn service() {
        // Arrange
        let ctx = new_context("bob");
        testing_env!(ctx);

        Foo::deploy(0);

        // Act
        {
            let foo = FOO.lock().unwrap();
            assert_eq!(*foo.state, 0);
        }

        {
            let mut foo = FOO.lock().unwrap();
            *foo.state.deref_mut() = 1_u128;
            foo.state.save();
        }

        {
            let foo = FOO.lock().unwrap();
            assert_eq!(*foo.state, 1);
        }
    }
}

'''
'''--- near/oysterpack-smart-near/src/component/deploy.rs ---
use crate::{Level, LogEvent};

/// Provides standard interface pattern for contracts to use at deployment time to run component
/// related deployment code.
///
/// For example, components may require config to initialize its persistent state.
pub trait Deploy {
    type Config;

    /// invoked when the contract is first deployed
    /// - main use case is to initialize any service state
    fn deploy(config: Self::Config);
}

pub const LOG_EVENT_DEPLOYMENT: LogEvent = LogEvent(Level::INFO, "DEPLOYMENT");

'''
'''--- near/oysterpack-smart-near/src/component/manages_account_data.rs ---
use crate::domain::StorageUsage;

/// Components that manage account data must implement this trait.
/// When the contract is deployed this is used to set the minimum storage required for the account
/// to register.
pub trait ManagesAccountData {
    /// returns the minimum account storage required by this component
    fn account_storage_min() -> StorageUsage;
}

'''
'''--- near/oysterpack-smart-near/src/core.rs ---
pub mod asserts;
mod errors;
pub mod eventbus;
mod hash;
mod log_events;
mod promise;

pub use errors::*;
pub use hash::*;
pub use log_events::*;
pub use promise::*;

use near_sdk::json_types::ValidAccountId;

/// YOCTO = 10^24
pub const YOCTO: u128 = 1_000_000_000_000_000_000_000_000;

/// TERA = 10^12
pub const TERA: u64 = 1_000_000_000_000;

use std::convert::TryFrom;

/// Panics if `account_id` is not valid
pub fn to_valid_account_id(account_id: &str) -> ValidAccountId {
    match ValidAccountId::try_from(account_id) {
        Ok(account_id) => account_id,
        Err(_) => {
            ERR_INVALID_ACCOUNT_ID.panic_with_message(account_id);
            unreachable!();
        }
    }
}

pub const ERR_INVALID_ACCOUNT_ID: ErrorConst = ErrorConst(ErrCode("INVALID_ACCOUNT_ID"), "");

'''
'''--- near/oysterpack-smart-near/src/core/asserts.rs ---
use crate::domain::YoctoNear;
use crate::{ErrCode, ErrorConst};
use near_sdk::env;
use std::fmt::Display;

pub const ERR_CODE_BAD_REQUEST: ErrCode = ErrCode("BAD_REQUEST");

/// meant to be used for triggering generic data validation failures
pub const ERR_INVALID: ErrCode = ErrCode("INVALID");

pub const ERR_ILLEGAL_STATE: ErrCode = ErrCode("ILLEGAL_STATE");

pub const ERR_CODE_INSUFFICIENT_NEAR_DEPOSIT: ErrCode = ErrCode("INSUFFICIENT_NEAR_DEPOSIT");

pub const ERR_YOCTONEAR_DEPOSIT_REQUIRED: ErrorConst = ErrorConst(
    ErrCode("YOCTONEAR_DEPOSIT_REQUIRED"),
    "exactly 1 yoctoNEAR must be attached",
);

pub const ERR_NEAR_DEPOSIT_REQUIRED: ErrorConst =
    ErrorConst(ErrCode("NEAR_DEPOSIT_REQUIRED"), "NEAR deposit is required");

pub const ERR_INSUFFICIENT_FUNDS: ErrorConst = ErrorConst(
    ErrCode("INSUFFICIENT_FUNDS"),
    "account has insufficient funds to fulfill request",
);

pub fn assert_request<F, Msg, MsgF>(check: F, msg: MsgF)
where
    F: FnOnce() -> bool,
    Msg: Display,
    MsgF: FnOnce() -> Msg,
{
    ERR_CODE_BAD_REQUEST.assert(check, msg);
}

/// used to protect functions that transfer value against FCAK calls
pub fn assert_yocto_near_attached() {
    if env::attached_deposit() != 1 {
        env::panic(ERR_YOCTONEAR_DEPOSIT_REQUIRED.to_string().as_bytes())
    }
}

/// used to protect functions that transfer value against FCAK calls
pub fn assert_min_near_attached(min: YoctoNear) {
    assert!(
        env::attached_deposit() >= *min,
        "{} attached NEAR amount is insufficient - minimum required amount is: {} yoctoNEAR",
        ERR_CODE_INSUFFICIENT_NEAR_DEPOSIT,
        min
    )
}

pub fn assert_near_attached<Msg: Display>(msg: Msg) {
    assert!(
        env::attached_deposit() > 0,
        "{} - {}",
        ERR_NEAR_DEPOSIT_REQUIRED,
        msg
    )
}

pub fn assert_account_not_predecessor(account_id: &str) {
    ERR_INVALID.assert(
        || env::predecessor_account_id().as_str() != account_id,
        || "`account_id` cannot be the same as the predecessor account ID",
    );
}

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near_test::*;

    #[test]
    fn assert_yocto_near_attached_check_passes() {
        let mut ctx = new_context("bob");
        ctx.attached_deposit = 1;
        testing_env!(ctx);

        assert_yocto_near_attached();
    }

    #[test]
    #[should_panic(
        expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED] exactly 1 yoctoNEAR must be attached"
    )]
    fn assert_yocto_near_attached_with_zero_deposit() {
        let ctx = new_context("bob");
        testing_env!(ctx);

        assert_yocto_near_attached();
    }

    #[test]
    #[should_panic(
        expected = "[ERR] [YOCTONEAR_DEPOSIT_REQUIRED] exactly 1 yoctoNEAR must be attached"
    )]
    fn assert_yocto_near_attached_with_2_deposit() {
        let mut ctx = new_context("bob");
        ctx.attached_deposit = 2;
        testing_env!(ctx);

        assert_yocto_near_attached();
    }

    #[test]
    fn assert_min_near_attached_check_passes() {
        let mut ctx = new_context("bob");
        ctx.attached_deposit = 100;
        testing_env!(ctx);

        assert_min_near_attached(100.into());
        assert_min_near_attached(50.into());
    }

    #[test]
    #[should_panic(
        expected = "[ERR] [INSUFFICIENT_NEAR_DEPOSIT] attached NEAR amount is insufficient - minimum required amount is: 200 yoctoNEAR"
    )]
    fn assert_min_near_attached_insufficient_depoist() {
        let mut ctx = new_context("bob");
        ctx.attached_deposit = 199;
        testing_env!(ctx);

        assert_min_near_attached(200.into());
    }
}

'''
'''--- near/oysterpack-smart-near/src/core/errors.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    serde::{Deserialize, Serialize},
};
use std::fmt::{self, Display, Formatter};

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct ErrCode(pub &'static str);

impl Display for ErrCode {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "[ERR] [{}]", self.0)
    }
}

impl ErrCode {
    /// constructs an [`Error`] using this [`ErrCode`] and the specified message
    pub fn error<Msg: Display>(&self, msg: Msg) -> Error<Msg> {
        Error(*self, msg)
    }

    pub fn assert<F, Msg, MsgF>(&self, check: F, msg: MsgF)
    where
        F: FnOnce() -> bool,
        Msg: Display,
        MsgF: FnOnce() -> Msg,
    {
        if !check() {
            self.error(msg()).panic();
        }
    }

    pub fn log<Msg: Display>(&self, msg: Msg) {
        self.error(msg).log()
    }
}

#[derive(Debug, Clone, PartialEq)]
pub struct Error<Msg>(pub ErrCode, pub Msg)
where
    Msg: Display;

impl<Msg> Display for Error<Msg>
where
    Msg: Display,
{
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{} {}", self.0, self.1)
    }
}

impl<Msg> Error<Msg>
where
    Msg: Display,
{
    pub fn panic(&self) {
        env::panic(self.to_string().as_bytes())
    }

    pub fn log(&self) {
        env::log(self.to_string().as_bytes())
    }
}

impl<Msg, T> Into<Result<T, Err>> for Error<Msg>
where
    Msg: Display,
{
    fn into(self) -> Result<T, Err> {
        Err(Err {
            code: self.0 .0.to_string(),
            msg: self.1.to_string(),
        })
    }
}

/// Error that can be defined as a constant, i.e., the error message is constant
#[derive(Debug, Clone, Copy, PartialEq)]
pub struct ErrorConst(pub ErrCode, pub &'static str);

impl Display for ErrorConst {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{} {}", self.0, self.1)
    }
}

impl ErrorConst {
    pub fn panic(&self) {
        env::panic(self.to_string().as_bytes())
    }

    pub fn panic_with_message<Msg: Display>(&self, msg: Msg) {
        self.0.error(msg).panic()
    }

    pub fn assert<F>(&self, check: F)
    where
        F: FnOnce() -> bool,
    {
        if !check() {
            self.panic();
        }
    }

    /// uses the supplied message instead of the preset message
    pub fn assert_with_message<F, MsgF, Msg>(&self, check: F, msg: MsgF)
    where
        F: FnOnce() -> bool,
        MsgF: FnOnce() -> Msg,
        Msg: Display,
    {
        self.0.assert(check, msg)
    }

    pub fn log(&self) {
        env::log(self.to_string().as_bytes());
    }
}

#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Debug, Clone, Eq, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub struct Err {
    pub code: String,
    pub msg: String,
}

impl Display for Err {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "[ERR] [{}] {}", self.code, self.msg)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near_test::*;
    use regex::Regex;

    #[test]
    fn error_display() {
        const ERR: ErrCode = ErrCode("INVALID_ACCOUNT_ID");

        println!("{}", Error(ERR, "BOOM".to_string()));
        println!("{}", ErrorConst(ERR, "BOOM"));
        println!("{}", ERR.error("BOOM"));
    }

    #[test]
    fn err_display_format() {
        let err_fmt_regex = Regex::new(r"\[ERR] \[\w+] \w+").unwrap();

        const ERR: ErrCode = ErrCode("INVALID_ACCOUNT_ID");
        let err = ERR.error("BOOM");
        println!("{}", ERR.error("BOOM"));

        assert!(err_fmt_regex.is_match(&err.to_string()));
    }

    #[test]
    #[should_panic(expected = "BOOM")]
    fn error_panic() {
        let context = new_context("bob");
        testing_env!(context);

        const ERR_CODE: ErrCode = ErrCode("INVALID_ACCOUNT_ID");
        let err: Error<String> = ERR_CODE.error("BOOM".to_string());
        err.panic();
    }

    #[test]
    #[should_panic(expected = "BOOM")]
    fn error_const_panic() {
        let context = new_context("bob");
        testing_env!(context);

        const ERR_CODE: ErrCode = ErrCode("INVALID_ACCOUNT_ID");
        const ERR: ErrorConst = ErrorConst(ERR_CODE, "BOOM");
        ERR.panic();
    }

    #[test]
    #[should_panic(expected = "BOOM")]
    fn error_code_assert() {
        let context = new_context("bob");
        testing_env!(context);

        const ERR: ErrCode = ErrCode("INVALID_ACCOUNT_ID");

        ERR.assert(|| false, || "BOOM");
    }

    #[test]
    fn into_result() {
        const ERR: ErrCode = ErrCode("INVALID_ACCOUNT_ID");
        fn foo() -> Result<u128, Err> {
            ERR.error("invalid").into()
        }

        match foo() {
            Ok(_) => panic!("expected Err"),
            Err(err) => println!("{}", err),
        }
    }
}

'''
'''--- near/oysterpack-smart-near/src/core/eventbus.rs ---
//! Provides support for an eventbus for stateless [`EventHandler`] functions

/// Every [`Event`] type manages its own handlers
pub trait Event {
    /// enables access to the [`EventHandlers`] for this event type
    /// - used to get access to registered handlers
    fn handlers<F>(f: F)
    where
        F: FnOnce(&EventHandlers<Self>);

    /// enables mutable access to the [`EventHandlers`] for this event type
    /// - used to register handlers for this event type
    fn handlers_mut<F>(f: F)
    where
        F: FnOnce(&mut EventHandlers<Self>);
}

/// post event and run registered event handlers
pub fn post<T>(event: &T)
where
    T: Event,
{
    T::handlers(|x| x.post(event))
}

/// registers an event handler
pub fn register<T>(f: EventHandler<T>)
where
    T: Event,
{
    T::handlers_mut(|x| x.register_handler(f))
}

/// stateless event handler function
pub type EventHandler<T> = fn(&T);

/// Used to store registered event handlers
pub struct EventHandlers<T: Event + ?Sized>(Vec<EventHandler<T>>);

impl<T: Event + ?Sized> EventHandlers<T> {
    pub fn new() -> EventHandlers<T> {
        EventHandlers(vec![])
    }

    fn register_handler(&mut self, f: fn(&T)) {
        self.0.push(f);
    }

    #[inline]
    fn post(&self, event: &T) {
        self.0.iter().for_each(|f| f(event))
    }

    pub fn clear(&mut self) {
        self.0.clear();
    }

    pub fn len(&self) -> usize {
        self.0.len()
    }
}

#[cfg(test)]
mod test {
    use super::*;

    use lazy_static::lazy_static;
    use std::sync::Mutex;

    #[derive(Debug)]
    struct CountEvent(i32);

    #[derive(Debug)]
    struct StringEvent(String);

    type CountEventHandlers = EventHandlers<CountEvent>;
    type StringEventHandlers = EventHandlers<StringEvent>;

    fn create_count_handlers() -> CountEventHandlers {
        EventHandlers::new()
    }

    fn create_string_event_handlers() -> StringEventHandlers {
        EventHandlers::new()
    }

    // define events
    lazy_static! {
        static ref COUNT_EVENTS: Mutex<CountEventHandlers> = Mutex::new(create_count_handlers());
        static ref STRING_EVENTS: Mutex<StringEventHandlers> =
            Mutex::new(create_string_event_handlers());
    }

    // TODO: create macro for this boilerplate code
    impl Event for CountEvent {
        fn handlers<F>(f: F)
        where
            F: FnOnce(&EventHandlers<Self>),
        {
            f(&*COUNT_EVENTS.lock().unwrap())
        }

        fn handlers_mut<F>(f: F)
        where
            F: FnOnce(&mut EventHandlers<Self>),
        {
            f(&mut *COUNT_EVENTS.lock().unwrap())
        }
    }

    impl Event for StringEvent {
        fn handlers<F>(f: F)
        where
            F: FnOnce(&EventHandlers<Self>),
        {
            f(&*STRING_EVENTS.lock().unwrap())
        }

        fn handlers_mut<F>(f: F)
        where
            F: FnOnce(&mut EventHandlers<Self>),
        {
            f(&mut *STRING_EVENTS.lock().unwrap())
        }
    }

    fn count_event_handler_1(e: &CountEvent) {
        println!("count_event_handler_1 {:?}", e);
    }

    fn count_event_handler_2(e: &CountEvent) {
        println!("count_event_handler_2 {:?}", e);
    }

    fn string_event_handler(e: &StringEvent) {
        println!("string_event_handler {:?}", e);
    }

    #[test]
    fn eventbus() {
        register(count_event_handler_1);
        register(string_event_handler);
        post(&CountEvent(1));

        register(count_event_handler_2);
        post(&CountEvent(2));
        post(&CountEvent(3));

        post(&StringEvent("hello".to_string()));
    }
}

'''
'''--- near/oysterpack-smart-near/src/core/hash.rs ---
use crate::ErrCode;
use near_sdk::json_types::ValidAccountId;
use near_sdk::serde::{self, de, Deserialize, Deserializer, Serialize, Serializer};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
};
use std::convert::TryInto;

/// sha256 hashed data
/// - JSON serialization format is Base64 encoded bytes
///
/// The main use case is to use Hash to hash keys for NEAR Trie storage, which provides the following
/// benefits
/// - keys are evenly distributed
/// - key size is constant 32 bytes
#[derive(
    BorshDeserialize,
    BorshSerialize,
    Clone,
    Copy,
    PartialEq,
    Eq,
    Hash,
    Debug,
    Ord,
    PartialOrd,
    Default,
)]
pub struct Hash(pub [u8; Hash::LENGTH]);

impl Hash {
    pub const LENGTH: usize = 32;
}

impl From<[u8; Hash::LENGTH]> for Hash {
    fn from(value: [u8; Hash::LENGTH]) -> Self {
        Self(value)
    }
}

impl From<&[u8]> for Hash {
    fn from(value: &[u8]) -> Self {
        assert!(!value.is_empty(), "value must not be empty");
        let hash = env::sha256(value);
        Self(hash.try_into().unwrap())
    }
}

impl From<u128> for Hash {
    fn from(value: u128) -> Self {
        Hash::from(u128_to_bytes(value).as_ref())
    }
}

impl From<&str> for Hash {
    fn from(value: &str) -> Self {
        Hash::from(value.as_bytes())
    }
}

impl From<ValidAccountId> for Hash {
    fn from(account_id: ValidAccountId) -> Self {
        let hash = env::sha256(account_id.as_ref().as_bytes());
        Self(hash.try_into().unwrap())
    }
}

impl From<&ValidAccountId> for Hash {
    fn from(account_id: &ValidAccountId) -> Self {
        let hash = env::sha256(account_id.as_ref().as_bytes());
        Self(hash.try_into().unwrap())
    }
}

/// Use Case: used as object attribute key
/// - (object_id, attribute_id)
/// - where ULID should be used for attribute_id to avoid collisions
impl From<(&str, u128)> for Hash {
    fn from((k1, k2): (&str, u128)) -> Self {
        Hash::from((k1.as_bytes(), k2))
    }
}

/// Use Case: used as object attribute key
/// - (object_id, attribute_id)
/// - where ULID should be used for attribute_id to avoid collisions
impl From<(ValidAccountId, u128)> for Hash {
    fn from((k1, k2): (ValidAccountId, u128)) -> Self {
        Hash::from((k1.as_ref().as_bytes(), k2))
    }
}

/// Use Case: used as object attribute key
/// - (object_id, attribute_id)
/// - where ULID should be used for attribute_id to avoid collisions
impl From<(&ValidAccountId, u128)> for Hash {
    fn from((k1, k2): (&ValidAccountId, u128)) -> Self {
        Hash::from((k1.as_ref().as_bytes(), k2))
    }
}

/// Use Case: used as object attribute key
/// - (object_id, attribute_id)
/// - where ULID should be used for attribute_id to avoid collisions
impl From<(&[u8], u128)> for Hash {
    fn from((k1, k2): (&[u8], u128)) -> Self {
        assert!(!k1.is_empty(), "k1 must not be empty");
        let ulid_bytes: [u8; 16] = u128_to_bytes(k2);
        let key: Vec<u8> = [k1, &ulid_bytes].concat();
        Hash::from(key.as_slice())
    }
}

/// use case for using compound key
impl From<(&[u8], &[u8])> for Hash {
    fn from((k1, k2): (&[u8], &[u8])) -> Self {
        assert!(!k1.is_empty(), "k1 must not be empty");
        assert!(!k2.is_empty(), "k2 must not be empty");
        let key: Vec<u8> = [k1, k2].concat();
        Hash::from(key.as_slice())
    }
}

fn u128_to_bytes(value: u128) -> [u8; 16] {
    [
        ((value >> 120) & 0xFF) as u8,
        ((value >> 112) & 0xFF) as u8,
        ((value >> 104) & 0xFF) as u8,
        ((value >> 96) & 0xFF) as u8,
        ((value >> 88) & 0xFF) as u8,
        ((value >> 80) & 0xFF) as u8,
        ((value >> 72) & 0xFF) as u8,
        ((value >> 64) & 0xFF) as u8,
        ((value >> 56) & 0xFF) as u8,
        ((value >> 48) & 0xFF) as u8,
        ((value >> 40) & 0xFF) as u8,
        ((value >> 32) & 0xFF) as u8,
        ((value >> 24) & 0xFF) as u8,
        ((value >> 16) & 0xFF) as u8,
        ((value >> 8) & 0xFF) as u8,
        (value & 0xFF) as u8,
    ]
}

impl Serialize for Hash {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&base64::encode(&self.0))
    }
}

impl<'de> Deserialize<'de> for Hash {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        let s: String = serde::Deserialize::deserialize(deserializer)?;
        base64::decode(&s)
            .map_err(|err| de::Error::custom(ERR_INVALID_HASH.error(err.to_string())))
            .map(|hash| {
                ERR_INVALID_HASH.assert(
                    || hash.len() == Hash::LENGTH,
                    || "hash length must be 32 bytes",
                );
                Self(
                    hash.try_into()
                        .map_err(|_err| ERR_INVALID_HASH.error(""))
                        .unwrap(),
                )
            })
    }
}

/// Error is used when trying to deserialize HASH from JSON
pub const ERR_INVALID_HASH: ErrCode = ErrCode("INVALID_HASH");

#[cfg(test)]
mod test {
    use super::*;
    use near_sdk::{serde_json, test_utils::test_env};

    #[test]
    fn serde_json() {
        test_env::setup();
        let data = "Alfio Zappala II";
        let hash = Hash::from(data.as_bytes());

        let json = serde_json::to_string(&hash).unwrap();
        println!("json hash: {}", json);
        let hash2: Hash = serde_json::from_str(&json).unwrap();
        assert_eq!(hash, hash2);
    }

    #[test]
    #[should_panic(expected = "[ERR] [INVALID_HASH] hash length must be 32 bytes")]
    fn serde_json_33_char_string() {
        test_env::setup();
        let data = "Alfio Zappala II";
        let hash = Hash::from(data.as_bytes());

        let json = serde_json::to_string(&hash).unwrap();
        let invalid_hash = format!("\"{}", json.split_at(33).0);
        let invalid_hash = format!("{}a\"", invalid_hash);
        println!("{}", invalid_hash);
        let _hash: Hash = serde_json::from_str(&invalid_hash).unwrap();
    }

    #[test]
    #[should_panic(expected = "[ERR] [INVALID_HASH] Invalid last symbol 115")]
    fn serde_json_31_char_string() {
        test_env::setup();
        let data = "Alfio Zappala II";
        let hash = Hash::from(data.as_bytes());

        let json = serde_json::to_string(&hash).unwrap();
        println!("{}", json);
        let invalid_hash = format!("\"{}", json.split_at(2).1);
        println!("{}", invalid_hash);
        let _hash: Hash = serde_json::from_str(&invalid_hash).unwrap();
    }

    #[test]
    fn hash_from_string() {
        test_env::setup();
        let data = "Alfio Zappala";
        let hash = Hash::from(data);
        let hash2 = Hash::from(data);
        assert_eq!(hash, hash2);
    }

    #[test]
    #[should_panic(expected = "value must not be empty")]
    fn hash_from_empty_string() {
        test_env::setup();
        Hash::from("");
    }

    #[test]
    fn hash_from_bytes() {
        test_env::setup();
        let data = "Alfio Zappala II";
        let hash = Hash::from(data.as_bytes());
        let hash2 = Hash::from(data.as_bytes());
        assert_eq!(hash, hash2);
    }

    #[test]
    #[should_panic(expected = "value must not be empty")]
    fn hash_from_empty_bytes() {
        test_env::setup();
        Hash::from("".as_bytes());
    }

    #[test]
    fn from_object_attribute() {
        test_env::setup();

        let object_id = "object_id";
        let attribute_id: u128 = 1952096956452045446682821566586971355;
        assert_eq!(
            Hash::from((object_id, attribute_id)),
            Hash::from((object_id, attribute_id))
        );

        let attribute_id = b"a";
        assert_eq!(
            Hash::from((object_id.as_bytes(), attribute_id.as_ref())),
            Hash::from((object_id.as_bytes(), attribute_id.as_ref()))
        );
    }
}

'''
'''--- near/oysterpack-smart-near/src/core/log_events.rs ---
use near_sdk::env;
use std::fmt::{self, Debug, Display, Formatter};

#[derive(Debug, Clone, Copy, PartialEq)]
pub enum Level {
    INFO,
    WARN,
}

pub type LogEventName = &'static str;

#[derive(Debug, Clone, Copy, PartialEq)]
pub struct LogEvent(pub Level, pub LogEventName);

impl Display for LogEvent {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "[{:?}] [{}]", self.0, self.1)
    }
}

impl LogEvent {
    pub fn log<Msg>(&self, msg: Msg)
    where
        Msg: Display,
    {
        env::log(self.message(msg).as_bytes());
    }

    pub fn message<Msg>(&self, msg: Msg) -> String
    where
        Msg: Display,
    {
        format!("{} {}", self, msg)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::test_utils::{get_logs, test_env};

    #[test]
    fn event_display() {
        test_env::setup();
        LogEvent(Level::INFO, "FOO").log("message");
        println!("{:#?}", get_logs());
    }
}

'''
'''--- near/oysterpack-smart-near/src/core/promise.rs ---
use crate::domain::{Gas, YoctoNear};
use near_sdk::{borsh::BorshSerialize, env, serde::Serialize, serde_json, Promise};

pub fn borsh_function_call<Args>(
    account_id: &str,
    method: &str,
    args: Option<Args>,
    deposit: YoctoNear,
    gas: Gas,
) -> Promise
where
    Args: BorshSerialize,
{
    Promise::new(account_id.to_string()).function_call(
        method.as_bytes().to_vec(),
        args.map_or_else(|| vec![], |args| args.try_to_vec().unwrap()),
        *deposit,
        *gas,
    )
}

pub fn borsh_function_callback<Args>(
    method: &str,
    args: Option<Args>,
    deposit: YoctoNear,
    gas: Gas,
) -> Promise
where
    Args: BorshSerialize,
{
    borsh_function_call(&env::predecessor_account_id(), method, args, deposit, gas)
}

pub fn json_function_call<Args>(
    account_id: &str,
    method: &str,
    args: Option<Args>,
    deposit: YoctoNear,
    gas: Gas,
) -> Promise
where
    Args: Serialize,
{
    Promise::new(account_id.to_string()).function_call(
        method.as_bytes().to_vec(),
        args.map_or_else(|| vec![], |args| serde_json::to_vec(&args).unwrap()),
        *deposit,
        *gas,
    )
}

pub fn json_function_callback<Args>(
    method: &str,
    args: Option<Args>,
    deposit: YoctoNear,
    gas: Gas,
) -> Promise
where
    Args: Serialize,
{
    json_function_call(&env::current_account_id(), method, args, deposit, gas)
}

'''
'''--- near/oysterpack-smart-near/src/data.rs ---
//! Provides support to work with data stored on the NEAR blockchain

pub mod numbers;
mod object;

pub use object::*;

'''
'''--- near/oysterpack-smart-near/src/data/numbers.rs ---
mod n_u128;
mod n_u256;
mod n_u64;

pub use n_u128::*;
pub use n_u256::*;
pub use n_u64::*;

'''
'''--- near/oysterpack-smart-near/src/data/numbers/n_u128.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{
        de::{self, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    },
    serde_json,
};
use std::ops::{Add, AddAssign, Div, Mul, Sub, SubAssign};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

pub const U128_ZERO: U128 = U128(0);

/// Borsh and JSON serializable u128
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
    Default,
    Hash,
)]
pub struct U128(pub u128);

impl U128 {
    pub fn value(&self) -> u128 {
        self.0
    }
}

impl From<u128> for U128 {
    fn from(value: u128) -> Self {
        Self(value)
    }
}

impl Deref for U128 {
    type Target = u128;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for U128 {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Add<u128> for U128 {
    type Output = Self;

    fn add(self, rhs: u128) -> Self::Output {
        (self.0 + rhs).into()
    }
}

impl AddAssign<u128> for U128 {
    fn add_assign(&mut self, rhs: u128) {
        self.0 += rhs;
    }
}

impl Sub<u128> for U128 {
    type Output = Self;

    fn sub(self, rhs: u128) -> Self::Output {
        (self.0 - rhs).into()
    }
}

impl SubAssign<u128> for U128 {
    fn sub_assign(&mut self, rhs: u128) {
        self.0 -= rhs;
    }
}

impl Mul<u128> for U128 {
    type Output = Self;

    fn mul(self, rhs: u128) -> Self::Output {
        (self.0 * rhs).into()
    }
}

impl Div<u128> for U128 {
    type Output = Self;

    fn div(self, rhs: u128) -> Self::Output {
        (self.0 / rhs).into()
    }
}

impl Display for U128 {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Serialize for U128 {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let value = self.0.to_string();
        serializer.serialize_str(&value)
    }
}

impl<'de> Deserialize<'de> for U128 {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(U128Visitor)
    }
}

struct U128Visitor;

impl<'de> Visitor<'de> for U128Visitor {
    type Value = U128;

    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
        formatter.write_str("u128 serialized as string")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let value: u128 = serde_json::from_str(v)
            .map_err(|_| de::Error::custom("JSON parsing failed for U128"))?;
        Ok(U128(value))
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        self.visit_str(&v)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::YOCTO;

    #[test]
    fn json_serialization() {
        let amount = U128::from(YOCTO);
        let amount_as_json = serde_json::to_string(&amount).unwrap();
        println!("{}", amount_as_json);

        let amount2: U128 = serde_json::from_str(&amount_as_json).unwrap();
        assert_eq!(amount, amount2);
    }
}

'''
'''--- near/oysterpack-smart-near/src/data/numbers/n_u256.rs ---
use uint::construct_uint;

construct_uint! {
    pub struct U256(4);
}

'''
'''--- near/oysterpack-smart-near/src/data/numbers/n_u64.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{
        de::{self, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    },
    serde_json,
};
use std::ops::{Add, AddAssign, Div, Mul, Sub, SubAssign};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

pub const U64_ZERO: U64 = U64(0);

/// Borsh and JSON serializable u64
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
    Default,
    Hash,
)]
pub struct U64(pub u64);

impl U64 {
    pub fn value(&self) -> u64 {
        self.0
    }
}

impl From<u64> for U64 {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

impl Deref for U64 {
    type Target = u64;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for U64 {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Add<u64> for U64 {
    type Output = Self;

    fn add(self, rhs: u64) -> Self::Output {
        (self.0 + rhs).into()
    }
}

impl AddAssign<u64> for U64 {
    fn add_assign(&mut self, rhs: u64) {
        self.0 += rhs;
    }
}

impl Sub<u64> for U64 {
    type Output = Self;

    fn sub(self, rhs: u64) -> Self::Output {
        (self.0 - rhs).into()
    }
}

impl SubAssign<u64> for U64 {
    fn sub_assign(&mut self, rhs: u64) {
        self.0 -= rhs;
    }
}

impl Mul<u64> for U64 {
    type Output = Self;

    fn mul(self, rhs: u64) -> Self::Output {
        (self.0 * rhs).into()
    }
}

impl Div<u64> for U64 {
    type Output = Self;

    fn div(self, rhs: u64) -> Self::Output {
        (self.0 / rhs).into()
    }
}

impl Display for U64 {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Serialize for U64 {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let value = self.0.to_string();
        serializer.serialize_str(&value)
    }
}

impl<'de> Deserialize<'de> for U64 {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(U128Visitor)
    }
}

struct U128Visitor;

impl<'de> Visitor<'de> for U128Visitor {
    type Value = U64;

    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
        formatter.write_str("u64 serialized as string")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let value: u64 = serde_json::from_str(v)
            .map_err(|_| de::Error::custom("JSON parsing failed for U128"))?;
        Ok(U64(value))
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        self.visit_str(&v)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::TERA;

    #[test]
    fn json_serialization() {
        let amount = U64::from(TERA);
        let amount_as_json = serde_json::to_string(&amount).unwrap();
        println!("{}", amount_as_json);

        let amount2: U64 = serde_json::from_str(&amount_as_json).unwrap();
        assert_eq!(amount, amount2);
    }
}

'''
'''--- near/oysterpack-smart-near/src/data/object.rs ---
//! Provides abstraction for object storage on the NEAR blockchain

use near_sdk::{
    borsh::{BorshDeserialize, BorshSerialize},
    env,
};
use std::ops::{Deref, DerefMut};
use std::{fmt::Debug, hash::Hash};

/// Object supports persistence to NEAR blockchain storage, i.e., on the Trie
#[derive(Clone, Debug, PartialEq)]
pub struct Object<K, V>(K, V)
where
    K: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Hash,
    V: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq;

impl<K, V> Object<K, V>
where
    K: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Hash,
    V: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq,
{
    /// Object is created in memory, i.e., it is not persisted to storage.
    /// - use [`Object::save`] to persist the object to storage on the NEAR blockchain
    pub fn new(key: K, value: V) -> Self {
        Self(key, value)
    }

    pub fn key(&self) -> &K {
        &self.0
    }

    pub fn exists(key: &K) -> bool {
        object_exists(key)
    }

    /// Tries to load the object from storage using the specified key.
    ///
    /// ## Panics
    /// if Borsh deserialization fails - which should never happen, but if it does then it means
    /// there is a bug
    /// - either in borsh (unlikely), or an object of a different type was stored with the same key
    pub fn load(key: &K) -> Option<Self> {
        let key_bytes = object_serialize_key(key);
        env::storage_read(&key_bytes)
            .map(|value| V::try_from_slice(&value).unwrap())
            .map(|value| Object(key.clone(), value))
    }

    /// Saves the object to persistent storage on the NEAR blockchain
    /// - will overwrite any other object with the same key - if your use case requires that there
    ///   shouldn't be a pre-existing value, then  use [`Object::exists`] before saving the object
    pub fn save(&self) {
        let key = object_serialize_key(&self.0);
        let value = self.1.try_to_vec().unwrap();
        env::storage_write(&key, &value);
    }

    /// Deletes the object from storage and consumes the object
    ///
    /// Returns true if the object existed.
    pub fn delete(self) -> bool {
        Self::delete_by_key(&self.0)
    }

    /// Removes the value stored under the given key.
    /// If key-value existed returns `true`, otherwise `false`.
    pub fn delete_by_key(key: &K) -> bool {
        let key = object_serialize_key(key);
        env::storage_remove(&key)
    }
}

impl<K, V> Deref for Object<K, V>
where
    K: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Hash,
    V: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq,
{
    type Target = V;

    fn deref(&self) -> &Self::Target {
        &self.1
    }
}

impl<K, V> DerefMut for Object<K, V>
where
    K: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq + Hash,
    V: BorshSerialize + BorshDeserialize + Clone + Debug + PartialEq,
{
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.1
    }
}

/// Used to check if the object is persisted to contract storage on the NEAR blockchain.
///
/// ## Panics
/// if `key` fails to serialize, but this is expected to never happen, unless there is a bug in borsh
pub fn object_exists<K: BorshSerialize>(key: &K) -> bool {
    let key = object_serialize_key(key);
    env::storage_has_key(&key)
}

/// Serializes the key using Borsh and then applies sha256 hash.
/// - Keys are always hashed before storing to ensure even distribution and const size.
///
/// ## Notes
/// - depends on NEAR provided `env::sha256()`
///
/// ## Panics
/// if data fails to serialize, but this is expected to never happen, unless there is a bug in borsh
fn object_serialize_key<K: BorshSerialize>(key: &K) -> Vec<u8> {
    let bytes = key.try_to_vec().unwrap();
    env::sha256(&bytes)
}

#[cfg(test)]
mod test {
    use super::*;
    use oysterpack_smart_near_test::*;

    type Data = Object<u128, u128>;

    #[test]
    fn crud() {
        // Arrange
        let context = new_context("bob");
        testing_env!(context);

        let data = Data::new(1, 2);

        // Assert
        assert!(!object_exists(data.key()));

        // Act - save the object
        data.save();
        assert!(object_exists(data.key()));

        let mut data2 = Data::load(data.key()).unwrap();
        assert_eq!(data, data2);

        // change the value and then save it
        *data2 = 3_u128;
        assert_eq!(*data2, 3);
        data2.save();

        let data3 = Data::load(data.key()).unwrap();
        assert_eq!(data3, data2);

        // delete from storage
        assert!(data3.delete());
        assert!(Data::load(data.key()).is_none())
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain.rs ---
//! NEAR typesafe domain model
//! - all domain objects support Borsh and JSON serialization

mod account_id_hash;
mod basis_points;
mod block_height;
mod block_time;
mod block_timestamp;
mod epoch_height;
mod expiration;
mod gas;
mod public_key;
mod storage_usage;
mod storage_usage_change;
mod tgas;
mod yocto_near;

pub use account_id_hash::*;
pub use basis_points::*;
pub use block_height::*;
pub use block_time::*;
pub use block_timestamp::*;
pub use epoch_height::*;
pub use expiration::*;
pub use gas::*;
pub use public_key::*;
pub use storage_usage::*;
pub use storage_usage_change::*;
pub use tgas::*;
pub use yocto_near::*;

'''
'''--- near/oysterpack-smart-near/src/domain/account_id_hash.rs ---
use crate::Hash;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::ValidAccountId;
use near_sdk::{
    base64,
    serde::{self, de::Error, Deserialize, Deserializer, Serialize, Serializer},
};
use std::convert::TryInto;

#[derive(BorshSerialize, BorshDeserialize, Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub struct AccountIdHash(pub Hash);

impl AccountIdHash {
    pub fn hash(&self) -> Hash {
        self.0
    }
}

impl From<&str> for AccountIdHash {
    fn from(account_id: &str) -> Self {
        Self(account_id.into())
    }
}

impl From<String> for AccountIdHash {
    fn from(account_id: String) -> Self {
        Self(account_id.as_str().into())
    }
}

impl From<&ValidAccountId> for AccountIdHash {
    fn from(account_id: &ValidAccountId) -> Self {
        Self(account_id.as_ref().as_str().into())
    }
}

impl From<ValidAccountId> for AccountIdHash {
    fn from(account_id: ValidAccountId) -> Self {
        Self(account_id.as_ref().as_str().into())
    }
}

impl Serialize for AccountIdHash {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&base64::encode(&self.0 .0))
    }
}

impl<'de> Deserialize<'de> for AccountIdHash {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        let s: String = serde::Deserialize::deserialize(deserializer)?;
        base64::decode(&s)
            .map_err(|err| Error::custom(err.to_string()))
            .map(|bytes| Self(Hash(bytes.try_into().unwrap())))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::{serde_json, test_utils::test_env};

    #[test]
    fn borsh() {
        test_env::setup();

        let hash = AccountIdHash::from("bob");
        let bytes = hash.try_to_vec().unwrap();

        let hash2 = AccountIdHash::try_from_slice(&bytes).unwrap();
        assert_eq!(hash, hash2);
    }

    #[test]
    fn json() {
        test_env::setup();

        let hash = AccountIdHash::from("bob");
        let json = serde_json::to_string(&hash).unwrap();
        println!("{}", json);

        let hash2: AccountIdHash = serde_json::from_str(&json).unwrap();
        assert_eq!(hash, hash2);
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/basis_points.rs ---
use crate::data::numbers::U256;
use crate::domain::YoctoNear;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};
use std::ops::{Add, AddAssign, Mul};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

/// Basis points (BPS) refers to a common unit of measure for interest rates and other percentages in finance.
/// One basis point is equal to 1/100th of 1%, or 0.01%, or 0.0001, and is used to denote the
/// percentage change in a financial instrument. The relationship between percentage changes and
/// basis points can be summarized as follows: 1% change = 100 basis points and 0.01% = 1 basis point.
/// Basis points are typically expressed in the abbreviations "bp," "bps," or "bips."
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
    Default,
    Hash,
)]
#[serde(crate = "near_sdk::serde")]
pub struct BasisPoints(pub u16);

impl BasisPoints {
    pub const ZERO: BasisPoints = BasisPoints(0);

    pub fn value(&self) -> u16 {
        self.0
    }

    pub fn of_rounded_down(&self, amount: YoctoNear) -> YoctoNear {
        *self * amount
    }

    pub fn of_rounded_up(&self, amount: YoctoNear) -> YoctoNear {
        ((U256::from(*amount) * U256::from(self.0) + U256::from(9999)) / U256::from(10000))
            .as_u128()
            .into()
    }
}

impl From<u16> for BasisPoints {
    fn from(value: u16) -> Self {
        Self(value)
    }
}

impl Deref for BasisPoints {
    type Target = u16;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for BasisPoints {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Display for BasisPoints {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl<T: Into<YoctoNear>> Mul<T> for BasisPoints {
    type Output = YoctoNear;

    /// result is rounded down
    fn mul(self, rhs: T) -> Self::Output {
        (U256::from(*rhs.into()) * U256::from(*self) / U256::from(10000))
            .as_u128()
            .into()
    }
}

impl Mul<BasisPoints> for YoctoNear {
    type Output = YoctoNear;

    /// result is rounded down
    fn mul(self, rhs: BasisPoints) -> Self::Output {
        (U256::from(*rhs) * U256::from(*self) / U256::from(10000))
            .as_u128()
            .into()
    }
}

impl Add for BasisPoints {
    type Output = Self;

    fn add(self, rhs: BasisPoints) -> Self::Output {
        (*self + *rhs).into()
    }
}

impl AddAssign for BasisPoints {
    fn add_assign(&mut self, rhs: Self) {
        **self += *rhs;
    }
}

impl Add<u16> for BasisPoints {
    type Output = Self;

    fn add(self, rhs: u16) -> Self::Output {
        (*self + rhs).into()
    }
}

impl AddAssign<u16> for BasisPoints {
    fn add_assign(&mut self, rhs: u16) {
        **self += rhs;
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn yocto_near_bps() {
        let amount = YoctoNear::from(10001);
        let bps = BasisPoints::from(50);
        let value = amount * bps;
        assert_eq!(value, 50.into());
        assert_eq!(value, bps.of_rounded_down(amount));
        assert_eq!(bps.of_rounded_up(amount), 51.into());
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/block_height.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    serde::{
        de::{self, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    },
    serde_json,
};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
    Default,
    Hash,
)]
pub struct BlockHeight(pub u64);

impl BlockHeight {
    pub fn from_env() -> Self {
        Self(env::block_index())
    }

    pub fn value(&self) -> u64 {
        self.0
    }
}

impl From<u64> for BlockHeight {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

impl Deref for BlockHeight {
    type Target = u64;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for BlockHeight {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Display for BlockHeight {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Serialize for BlockHeight {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let value = self.0.to_string();
        serializer.serialize_str(&value)
    }
}

impl<'de> Deserialize<'de> for BlockHeight {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(YoctoNearVisitor)
    }
}

struct YoctoNearVisitor;

impl<'de> Visitor<'de> for YoctoNearVisitor {
    type Value = BlockHeight;

    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
        formatter.write_str("u64 serialized as string")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let value: u64 = serde_json::from_str(v)
            .map_err(|_| de::Error::custom("JSON parsing failed for YoctoNear"))?;
        Ok(BlockHeight(value))
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        self.visit_str(&v)
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/block_time.rs ---
use crate::domain::{BlockHeight, BlockTimestamp, EpochHeight};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};

#[derive(
    BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone, Copy, Debug, PartialEq, Hash,
)]
#[serde(crate = "near_sdk::serde")]
pub struct BlockTime {
    pub timestamp: BlockTimestamp,
    pub height: BlockHeight,
    pub epoch: EpochHeight,
}

impl BlockTime {
    pub fn from_env() -> Self {
        Self {
            timestamp: BlockTimestamp::from_env(),
            height: BlockHeight::from_env(),
            epoch: EpochHeight::from_env(),
        }
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/block_timestamp.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    serde::{
        de::{self, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    },
    serde_json,
};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

/// Current block timestamp, i.e, number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
    Default,
    Hash,
)]
pub struct BlockTimestamp(pub u64);

impl BlockTimestamp {
    pub fn from_env() -> Self {
        Self(env::block_timestamp())
    }

    pub fn value(&self) -> u64 {
        self.0
    }
}

impl From<u64> for BlockTimestamp {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

impl Deref for BlockTimestamp {
    type Target = u64;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for BlockTimestamp {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Display for BlockTimestamp {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Serialize for BlockTimestamp {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let value = self.0.to_string();
        serializer.serialize_str(&value)
    }
}

impl<'de> Deserialize<'de> for BlockTimestamp {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(YoctoNearVisitor)
    }
}

struct YoctoNearVisitor;

impl<'de> Visitor<'de> for YoctoNearVisitor {
    type Value = BlockTimestamp;

    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
        formatter.write_str("u64 serialized as string")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let value: u64 = serde_json::from_str(v)
            .map_err(|_| de::Error::custom("JSON parsing failed for YoctoNear"))?;
        Ok(BlockTimestamp(value))
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        self.visit_str(&v)
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/epoch_height.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    serde::{
        de::{self, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    },
    serde_json,
};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
    Default,
    Hash,
)]
pub struct EpochHeight(pub u64);

impl EpochHeight {
    pub fn from_env() -> Self {
        Self(env::epoch_height())
    }

    pub fn value(&self) -> u64 {
        self.0
    }
}

impl From<u64> for EpochHeight {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

impl Deref for EpochHeight {
    type Target = u64;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for EpochHeight {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Display for EpochHeight {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Serialize for EpochHeight {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let value = self.0.to_string();
        serializer.serialize_str(&value)
    }
}

impl<'de> Deserialize<'de> for EpochHeight {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(YoctoNearVisitor)
    }
}

struct YoctoNearVisitor;

impl<'de> Visitor<'de> for YoctoNearVisitor {
    type Value = EpochHeight;

    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
        formatter.write_str("u64 serialized as string")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let value: u64 = serde_json::from_str(v)
            .map_err(|_| de::Error::custom("JSON parsing failed for YoctoNear"))?;
        Ok(EpochHeight(value))
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        self.visit_str(&v)
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/expiration.rs ---
use crate::domain::{BlockHeight, BlockTimestamp, EpochHeight};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    serde::{Deserialize, Serialize},
};
use std::fmt::{self, Display, Formatter};

/// Expiration can be set on the epoch, block, or timestamp.
///
/// The time is considered expired if the current time is after the specified expiration.
/// Current block timestamp, i.e, number of non-leap-nanoseconds since January 1, 1970 0:00:00 UTC.
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
)]
#[serde(crate = "near_sdk::serde")]
pub enum Expiration {
    Epoch(EpochHeight),
    Block(BlockHeight),
    Timestamp(BlockTimestamp),
}

impl Expiration {
    pub fn expired(&self) -> bool {
        match *self {
            Expiration::Epoch(epoch) => env::epoch_height() > epoch.value(),
            Expiration::Block(block) => env::block_index() > block.value(),
            Expiration::Timestamp(timestamp) => env::block_timestamp() > timestamp.value(),
        }
    }
}

impl Display for Expiration {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        match *self {
            Expiration::Epoch(expiration) => write!(f, "{:?}", expiration),
            Expiration::Block(expiration) => write!(f, "{:?}", expiration),
            Expiration::Timestamp(expiration) => write!(f, "{:?}", expiration),
        }
    }
}

impl From<ExpirationDuration> for Expiration {
    fn from(duration: ExpirationDuration) -> Self {
        match duration {
            ExpirationDuration::Epochs(duration) => {
                Expiration::Epoch((env::epoch_height() + duration as u64).into())
            }
            ExpirationDuration::Blocks(duration) => {
                Expiration::Block((env::block_index() + duration as u64).into())
            }
            ExpirationDuration::Seconds(duration) => Expiration::Timestamp(
                (env::block_timestamp() + (1_000_000_000 * duration as u64)).into(),
            ),
        }
    }
}

impl From<ExpirationSetting> for Expiration {
    fn from(settings: ExpirationSetting) -> Self {
        match settings {
            ExpirationSetting::Absolute(settings) => settings,
            ExpirationSetting::Relative(settings) => settings.into(),
        }
    }
}

impl From<Expiration> for ExpirationSetting {
    fn from(expiration: Expiration) -> Self {
        ExpirationSetting::Absolute(expiration)
    }
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
)]
#[serde(crate = "near_sdk::serde")]
pub enum ExpirationDuration {
    Epochs(u32),
    Blocks(u32),
    Seconds(u32),
}

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Serialize,
    Deserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
)]
#[serde(crate = "near_sdk::serde")]
pub enum ExpirationSetting {
    Absolute(Expiration),
    Relative(ExpirationDuration),
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::serde_json;
    use oysterpack_smart_near_test::*;

    #[test]
    fn epoch_expiration() {
        let mut ctx = new_context("bob");

        ctx.epoch_height = 1000;
        testing_env!(ctx.clone());

        assert!(!Expiration::Epoch(1000.into()).expired());
        assert!(Expiration::Epoch(999.into()).expired());

        println!(
            "{}",
            serde_json::to_string(&Expiration::Epoch(1000.into())).unwrap()
        );
    }

    #[test]
    fn block_expiration() {
        let mut ctx = new_context("bob");

        ctx.block_index = 1000;
        testing_env!(ctx.clone());

        assert!(!Expiration::Block(1000.into()).expired());
        assert!(Expiration::Block(999.into()).expired());

        println!(
            "{}",
            serde_json::to_string(&Expiration::Block(1000.into())).unwrap()
        );
    }

    #[test]
    fn timestamp_expiration() {
        let mut ctx = new_context("bob");

        ctx.block_timestamp = 1000;
        testing_env!(ctx.clone());

        assert!(!Expiration::Timestamp(1000.into()).expired());
        assert!(Expiration::Timestamp(999.into()).expired());

        println!(
            "{}",
            serde_json::to_string(&Expiration::Timestamp(1000.into())).unwrap()
        );
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/gas.rs ---
use crate::domain::TGas;
use crate::TERA;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{
        de::{self, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    },
    serde_json, RuntimeFeesConfig,
};
use std::ops::{Add, AddAssign, Sub, SubAssign};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

/// provides support to also [compute][`Gas::compute`] runtime gas costs
#[derive(
    BorshSerialize, BorshDeserialize, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Default,
)]
pub struct Gas(pub u64);

pub type TransactionResourceCount = u8;

impl Gas {
    pub const ZERO: Gas = Gas(0);

    pub fn value(&self) -> u64 {
        self.0
    }

    /// compute the runtime cost for the transaction resource
    pub fn compute(costs: Vec<(TransactionResource, TransactionResourceCount)>) -> Gas {
        let runtime_fees = RuntimeFeesConfig::default();
        costs
            .iter()
            .fold(0_u64, |gas_cost, (cost, count)| {
                assert!(*count > 0, "transaction resource count must not be zero");
                let cost = match cost {
                    TransactionResource::ActionReceipt(SenderIsReceiver(sir)) => {
                        let fee = &runtime_fees.action_receipt_creation_config;
                        fee.send_fee(*sir) + fee.execution
                    }
                    TransactionResource::DataReceipt(SenderIsReceiver(sir), ByteLen(len)) => {
                        let fee = &runtime_fees.data_receipt_creation_config.cost_per_byte;
                        let cost_per_byte = fee.send_fee(*sir) + fee.execution;

                        let fee = &runtime_fees.data_receipt_creation_config.base_cost;
                        let base_cost = fee.send_fee(*sir) + fee.execution;

                        base_cost + (cost_per_byte * len)
                    }
                    TransactionResource::Action(action) => match action {
                        ActionType::CreateAccount => {
                            let fee = &runtime_fees.action_creation_config.create_account_cost;
                            fee.send_not_sir + fee.execution
                        }
                        ActionType::DeployContract(ByteLen(len)) => {
                            let fee = &runtime_fees
                                .action_creation_config
                                .deploy_contract_cost_per_byte;
                            let cost_per_byte = fee.send_not_sir + fee.execution;

                            let fee = &runtime_fees.action_creation_config.deploy_contract_cost;
                            let base_cost = fee.send_not_sir + fee.execution;

                            base_cost + (cost_per_byte * len)
                        }
                        ActionType::FunctionCall(SenderIsReceiver(sir), ByteLen(len)) => {
                            let fee = &runtime_fees
                                .action_creation_config
                                .function_call_cost_per_byte;
                            let cost_per_byte = fee.send_fee(*sir) + fee.execution;

                            let fee = &runtime_fees.action_creation_config.function_call_cost;
                            let base_cost = fee.send_fee(*sir) + fee.execution;

                            base_cost + (cost_per_byte * len)
                        }
                        ActionType::Transfer => {
                            let fee = &runtime_fees.action_creation_config.transfer_cost;
                            fee.send_not_sir + fee.execution
                        }
                        ActionType::Stake(SenderIsReceiver(sir)) => {
                            let fee = &runtime_fees.action_creation_config.stake_cost;
                            fee.send_fee(*sir) + fee.execution
                        }
                        ActionType::AccessKeyCreation(
                            SenderIsReceiver(sir),
                            key_type,
                            ByteLen(len),
                        ) => {
                            let fee = &runtime_fees.action_creation_config.add_key_cost;
                            match key_type {
                                AccessKeyType::FullAccess => {
                                    let fee = &fee.full_access_cost;
                                    fee.send_fee(*sir) + fee.execution
                                }
                                AccessKeyType::FunctionCall => {
                                    let per_byte_fee = &fee.function_call_cost_per_byte;
                                    let cost_per_byte =
                                        per_byte_fee.send_fee(*sir) + per_byte_fee.execution;

                                    let base_fee = &fee.function_call_cost;
                                    let base_cost = base_fee.send_fee(*sir) + base_fee.execution;

                                    base_cost + (cost_per_byte * len)
                                }
                            }
                        }
                        ActionType::DeleteKey(SenderIsReceiver(sir)) => {
                            let fee = &runtime_fees.action_creation_config.delete_key_cost;
                            fee.send_fee(*sir) + fee.execution
                        }
                        ActionType::DeleteAccount(SenderIsReceiver(sir)) => {
                            let fee = &runtime_fees.action_creation_config.delete_account_cost;
                            fee.send_fee(*sir) + fee.execution
                        }
                    },
                };
                gas_cost + (cost * *count as u64)
            })
            .into()
    }
}

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum TransactionResource {
    ActionReceipt(SenderIsReceiver),
    DataReceipt(SenderIsReceiver, ByteLen),
    Action(ActionType),
}

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum ActionType {
    CreateAccount,
    DeployContract(ByteLen),
    FunctionCall(SenderIsReceiver, ByteLen),
    Transfer,
    Stake(SenderIsReceiver),
    AccessKeyCreation(SenderIsReceiver, AccessKeyType, ByteLen),
    DeleteKey(SenderIsReceiver),
    DeleteAccount(SenderIsReceiver),
}

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub struct SenderIsReceiver(pub bool);

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub struct ByteLen(pub u64);

#[derive(Debug, Clone, Copy, Eq, PartialEq)]
pub enum AccessKeyType {
    FullAccess,
    FunctionCall,
}

impl From<TGas> for Gas {
    fn from(gas: TGas) -> Self {
        Self(gas.0 * TERA)
    }
}

impl From<u64> for Gas {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

impl Deref for Gas {
    type Target = u64;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for Gas {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Add<Gas> for Gas {
    type Output = Self;

    fn add(self, rhs: Gas) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl AddAssign<Gas> for Gas {
    fn add_assign(&mut self, rhs: Gas) {
        self.0 += rhs.0
    }
}

impl Sub<Gas> for Gas {
    type Output = Self;

    fn sub(self, rhs: Gas) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl SubAssign<Gas> for Gas {
    fn sub_assign(&mut self, rhs: Gas) {
        self.0 -= rhs.0
    }
}

impl Add<TGas> for Gas {
    type Output = Self;

    fn add(self, rhs: TGas) -> Self::Output {
        self + Gas::from(rhs)
    }
}

impl AddAssign<TGas> for Gas {
    fn add_assign(&mut self, rhs: TGas) {
        *self += Gas::from(rhs)
    }
}

impl Sub<TGas> for Gas {
    type Output = Self;

    fn sub(self, rhs: TGas) -> Self::Output {
        self - Gas::from(rhs)
    }
}

impl SubAssign<TGas> for Gas {
    fn sub_assign(&mut self, rhs: TGas) {
        *self -= Gas::from(rhs)
    }
}

impl Display for Gas {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Serialize for Gas {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let value = self.0.to_string();
        serializer.serialize_str(&value)
    }
}

impl<'de> Deserialize<'de> for Gas {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(GasVisitor)
    }
}

struct GasVisitor;

impl<'de> Visitor<'de> for GasVisitor {
    type Value = Gas;

    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
        formatter.write_str("u64 serialized as string")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let value: u64 = serde_json::from_str(v)
            .map_err(|_| de::Error::custom("JSON parsing failed for YoctoNear"))?;
        Ok(Gas(value))
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        self.visit_str(&v)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::TERA;
    use near_sdk::test_utils::test_env;

    #[test]
    fn json_serialization() {
        let amount = Gas::from(100);
        let amount_as_json = serde_json::to_string(&amount).unwrap();
        println!("{}", amount_as_json);

        let amount2: Gas = serde_json::from_str(&amount_as_json).unwrap();
        assert_eq!(amount, amount2);
    }

    #[test]
    fn compute_gas() {
        test_env::setup();

        let func_call_receipt = TransactionResource::ActionReceipt(SenderIsReceiver(false));
        let func_call_action = TransactionResource::Action(ActionType::FunctionCall(
            SenderIsReceiver(false),
            ByteLen(100),
        ));
        let data_receipt = TransactionResource::DataReceipt(SenderIsReceiver(false), ByteLen(100));
        let gas = Gas::compute(vec![
            (func_call_receipt, 1),
            (func_call_action, 1),
            (data_receipt, 2),
        ]);
        println!("gas = {}", gas);
        println!("gas = {} rem {}", *gas / TERA, *gas % TERA);
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/public_key.rs ---
use crate::asserts::ERR_INVALID;
use crate::Error;
use near_sdk::json_types::Base58PublicKey;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Deserializer, Serialize, Serializer},
};
use std::fmt::{Debug, Formatter};
use std::{
    convert::{TryFrom, TryInto},
    fmt::{self, Display},
};

#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, PartialEq, Eq, Hash)]
pub enum PublicKey {
    ED25519([u8; 32]),
    SECP256K1(([u8; 32], [u8; 32])),
}

impl Serialize for PublicKey {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let key = Base58PublicKey::from(*self);
        Serialize::serialize(&key, serializer)
    }
}

impl<'de> Deserialize<'de> for PublicKey {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        let key: Base58PublicKey = Deserialize::deserialize(deserializer)?;
        Ok(key.into())
    }
}

impl TryFrom<&[u8]> for PublicKey {
    type Error = Error<String>;

    fn try_from(value: &[u8]) -> Result<Self, Self::Error> {
        match value.len() {
            33 if value[0] == 0 => Ok(Self::ED25519((&value[1..]).try_into().unwrap())),
            65 if value[0] == 1 => Ok(Self::SECP256K1((
                (&value[1..33]).try_into().unwrap(),
                (&value[33..]).try_into().unwrap(),
            ))),
            _ => Err(ERR_INVALID.error("invalid public key".to_string())),
        }
    }
}

impl From<PublicKey> for Vec<u8> {
    fn from(key: PublicKey) -> Self {
        match key {
            PublicKey::ED25519(k) => {
                let mut key = Vec::with_capacity(33);
                key.push(0);
                for b in k.iter() {
                    key.push(*b);
                }
                key
            }
            PublicKey::SECP256K1((k1, k2)) => {
                let mut key = Vec::with_capacity(65);
                key.push(1);
                for b in k1.iter() {
                    key.push(*b);
                }
                for b in k2.iter() {
                    key.push(*b);
                }
                key
            }
        }
    }
}

impl From<Base58PublicKey> for PublicKey {
    fn from(key: Base58PublicKey) -> Self {
        key.0.as_slice().try_into().unwrap()
    }
}

impl From<PublicKey> for Base58PublicKey {
    fn from(key: PublicKey) -> Self {
        Self(key.into())
    }
}

impl Display for PublicKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        let key = Base58PublicKey::from(*self);
        let s: String = (&key).try_into().map_err(|_| fmt::Error)?;
        Display::fmt(&s, f)
    }
}

impl Debug for PublicKey {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        Display::fmt(&self, f)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::serde_json;

    #[test]
    fn from_vec_ed25519() {
        let key = [0_u8; 33];

        let key: PublicKey = key[..].try_into().unwrap();
        println!("{}", key);
        match key {
            PublicKey::ED25519(_) => {}
            PublicKey::SECP256K1(_) => panic!("expected ED25519"),
        }
    }

    #[test]
    fn from_vec_secp256k1() {
        let key = [1_u8; 65];

        let key: PublicKey = key[..].try_into().unwrap();
        println!("{}", key);
        match key {
            PublicKey::ED25519(_) => panic!("expected ED25519"),
            PublicKey::SECP256K1(_) => {}
        }
    }

    #[test]
    fn json_serde() {
        let key = [1_u8; 65];
        let key: PublicKey = key[..].try_into().unwrap();

        let json = serde_json::to_string(&key).unwrap();
        println!("json: {}", json);
        let key2: PublicKey = serde_json::from_str(&json).unwrap();
        assert_eq!(key, key2);
    }

    #[test]
    fn into_base58() {
        let key = [1_u8; 65];
        let key: PublicKey = key[..].try_into().unwrap();

        let base58_key: Base58PublicKey = key.into();
        println!("{}", serde_json::to_string(&base58_key).unwrap());

        let base58_key2: Base58PublicKey =
            serde_json::from_str(serde_json::to_string(&base58_key).unwrap().as_str()).unwrap();

        assert_eq!(base58_key, base58_key2);
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/storage_usage.rs ---
use crate::domain::YoctoNear;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    serde::{
        de::{self, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    },
    serde_json,
};
use std::ops::{Add, AddAssign, Sub, SubAssign};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

#[derive(
    BorshSerialize, BorshDeserialize, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Default,
)]
pub struct StorageUsage(pub u64);

impl StorageUsage {
    pub fn value(&self) -> u64 {
        self.0
    }

    /// returns storage usage staking costs
    ///
    /// ## Notes
    /// the storage byte cost is retrieved from the NEAR runtime env
    ///
    /// ## Panics
    /// if the NEAR runtime env is not available
    pub fn cost(&self) -> YoctoNear {
        (self.0 as u128 * env::storage_byte_cost()).into()
    }

    pub fn from_env() -> Self {
        Self(env::storage_usage())
    }
}

impl From<u64> for StorageUsage {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

impl Deref for StorageUsage {
    type Target = u64;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for StorageUsage {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Add<StorageUsage> for StorageUsage {
    type Output = Self;

    fn add(self, rhs: StorageUsage) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl AddAssign<StorageUsage> for StorageUsage {
    fn add_assign(&mut self, rhs: StorageUsage) {
        self.0 += rhs.0
    }
}

impl Sub<StorageUsage> for StorageUsage {
    type Output = Self;

    fn sub(self, rhs: StorageUsage) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl SubAssign<StorageUsage> for StorageUsage {
    fn sub_assign(&mut self, rhs: StorageUsage) {
        self.0 -= rhs.0
    }
}

impl Display for StorageUsage {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Serialize for StorageUsage {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let value = self.0.to_string();
        serializer.serialize_str(&value)
    }
}

impl<'de> Deserialize<'de> for StorageUsage {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(YoctoNearVisitor)
    }
}

struct YoctoNearVisitor;

impl<'de> Visitor<'de> for YoctoNearVisitor {
    type Value = StorageUsage;

    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
        formatter.write_str("u64 serialized as string")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let value: u64 = serde_json::from_str(v)
            .map_err(|_| de::Error::custom("JSON parsing failed for YoctoNear"))?;
        Ok(StorageUsage(value))
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        self.visit_str(&v)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use near_sdk::test_utils::test_env;

    #[test]
    fn json_serialization() {
        let amount = StorageUsage::from(100);
        let amount_as_json = serde_json::to_string(&amount).unwrap();
        println!("{}", amount_as_json);

        let amount2: StorageUsage = serde_json::from_str(&amount_as_json).unwrap();
        assert_eq!(amount, amount2);
    }

    #[test]
    fn cost() {
        test_env::setup();

        let storage_byte_cost = env::storage_byte_cost();
        let storage_usage = StorageUsage::from(100);
        assert_eq!(
            storage_usage.cost().value(),
            storage_byte_cost * storage_usage.value() as u128
        );
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/storage_usage_change.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{
        de::{self, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    },
    serde_json,
};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

#[derive(
    BorshSerialize, BorshDeserialize, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Default,
)]
pub struct StorageUsageChange(pub i64);

impl StorageUsageChange {
    pub fn value(&self) -> i64 {
        self.0
    }
}

impl From<i64> for StorageUsageChange {
    fn from(value: i64) -> Self {
        Self(value)
    }
}

impl From<u64> for StorageUsageChange {
    fn from(value: u64) -> Self {
        Self(value as i64)
    }
}

impl Deref for StorageUsageChange {
    type Target = i64;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for StorageUsageChange {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Display for StorageUsageChange {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Serialize for StorageUsageChange {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let value = self.0.to_string();
        serializer.serialize_str(&value)
    }
}

impl<'de> Deserialize<'de> for StorageUsageChange {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(YoctoNearVisitor)
    }
}

struct YoctoNearVisitor;

impl<'de> Visitor<'de> for YoctoNearVisitor {
    type Value = StorageUsageChange;

    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
        formatter.write_str("i64 serialized as string")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let value: i64 = serde_json::from_str(v)
            .map_err(|_| de::Error::custom("JSON parsing failed for YoctoNear"))?;
        Ok(StorageUsageChange(value))
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        self.visit_str(&v)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn json_serialization() {
        let amount = StorageUsageChange::from(100_u64);
        let amount_as_json = serde_json::to_string(&amount).unwrap();
        println!("{}", amount_as_json);

        let amount2: StorageUsageChange = serde_json::from_str(&amount_as_json).unwrap();
        assert_eq!(amount, amount2);
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/tgas.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{
        de::{self, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    },
    serde_json,
};
use std::ops::{Add, AddAssign, Sub, SubAssign};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

/// TeraGas
#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
    Default,
    Hash,
)]
pub struct TGas(pub u64);

impl TGas {
    pub fn value(&self) -> u64 {
        self.0
    }
}

impl From<u64> for TGas {
    fn from(value: u64) -> Self {
        Self(value)
    }
}

impl Deref for TGas {
    type Target = u64;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for TGas {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Add<TGas> for TGas {
    type Output = Self;

    fn add(self, rhs: TGas) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl AddAssign<TGas> for TGas {
    fn add_assign(&mut self, rhs: TGas) {
        self.0 += rhs.0
    }
}

impl Sub<TGas> for TGas {
    type Output = Self;

    fn sub(self, rhs: TGas) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl SubAssign<TGas> for TGas {
    fn sub_assign(&mut self, rhs: TGas) {
        self.0 -= rhs.0
    }
}

impl Display for TGas {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Serialize for TGas {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let value = self.0.to_string();
        serializer.serialize_str(&value)
    }
}

impl<'de> Deserialize<'de> for TGas {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(YoctoNearVisitor)
    }
}

struct YoctoNearVisitor;

impl<'de> Visitor<'de> for YoctoNearVisitor {
    type Value = TGas;

    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
        formatter.write_str("u64 serialized as string")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let value: u64 = serde_json::from_str(v)
            .map_err(|_| de::Error::custom("JSON parsing failed for YoctoNear"))?;
        Ok(TGas(value))
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        self.visit_str(&v)
    }
}

#[cfg(test)]
mod test {
    use super::*;

    #[test]
    fn json_serialization() {
        let amount = TGas::from(100);
        let amount_as_json = serde_json::to_string(&amount).unwrap();
        println!("{}", amount_as_json);

        let amount2: TGas = serde_json::from_str(&amount_as_json).unwrap();
        assert_eq!(amount, amount2);
    }
}

'''
'''--- near/oysterpack-smart-near/src/domain/yocto_near.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{
        de::{self, Visitor},
        Deserialize, Deserializer, Serialize, Serializer,
    },
    serde_json,
};
use std::iter::Sum;
use std::ops::{Add, AddAssign, Div, Mul, Sub, SubAssign};
use std::{
    fmt::{self, Display, Formatter},
    ops::{Deref, DerefMut},
};

#[derive(
    BorshSerialize,
    BorshDeserialize,
    Debug,
    Clone,
    Copy,
    Eq,
    PartialEq,
    Ord,
    PartialOrd,
    Default,
    Hash,
)]
pub struct YoctoNear(pub u128);

impl YoctoNear {
    pub const ZERO: YoctoNear = YoctoNear(0);

    pub fn value(&self) -> u128 {
        self.0
    }
}

impl From<u128> for YoctoNear {
    fn from(value: u128) -> Self {
        Self(value)
    }
}

impl Deref for YoctoNear {
    type Target = u128;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for YoctoNear {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Add<YoctoNear> for YoctoNear {
    type Output = Self;

    fn add(self, rhs: YoctoNear) -> Self::Output {
        (self.0 + rhs.0).into()
    }
}

impl AddAssign<YoctoNear> for YoctoNear {
    fn add_assign(&mut self, rhs: YoctoNear) {
        self.0 += rhs.0;
    }
}

impl Sub<YoctoNear> for YoctoNear {
    type Output = Self;

    fn sub(self, rhs: YoctoNear) -> Self::Output {
        (self.0 - rhs.0).into()
    }
}

impl SubAssign<YoctoNear> for YoctoNear {
    fn sub_assign(&mut self, rhs: YoctoNear) {
        self.0 -= rhs.0;
    }
}

impl Add<u128> for YoctoNear {
    type Output = Self;

    fn add(self, rhs: u128) -> Self::Output {
        (self.0 + rhs).into()
    }
}

impl AddAssign<u128> for YoctoNear {
    fn add_assign(&mut self, rhs: u128) {
        self.0 += rhs;
    }
}

impl Sub<u128> for YoctoNear {
    type Output = Self;

    fn sub(self, rhs: u128) -> Self::Output {
        (self.0 - rhs).into()
    }
}

impl SubAssign<u128> for YoctoNear {
    fn sub_assign(&mut self, rhs: u128) {
        self.0 -= rhs;
    }
}

impl Mul<u128> for YoctoNear {
    type Output = Self;

    fn mul(self, rhs: u128) -> Self::Output {
        (self.0 * rhs).into()
    }
}

impl Div<u128> for YoctoNear {
    type Output = Self;

    fn div(self, rhs: u128) -> Self::Output {
        (self.0 / rhs).into()
    }
}

impl Sum for YoctoNear {
    fn sum<I: Iterator<Item = Self>>(iter: I) -> Self {
        iter.map(|value| value.0).sum::<u128>().into()
    }
}

impl Display for YoctoNear {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl Serialize for YoctoNear {
    fn serialize<S>(&self, serializer: S) -> Result<<S as Serializer>::Ok, <S as Serializer>::Error>
    where
        S: Serializer,
    {
        let value = self.0.to_string();
        serializer.serialize_str(&value)
    }
}

impl<'de> Deserialize<'de> for YoctoNear {
    fn deserialize<D>(deserializer: D) -> Result<Self, <D as Deserializer<'de>>::Error>
    where
        D: Deserializer<'de>,
    {
        deserializer.deserialize_str(YoctoNearVisitor)
    }
}

struct YoctoNearVisitor;

impl<'de> Visitor<'de> for YoctoNearVisitor {
    type Value = YoctoNear;

    fn expecting(&self, formatter: &mut Formatter) -> fmt::Result {
        formatter.write_str("u128 serialized as string")
    }

    fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        let value: u128 = serde_json::from_str(v)
            .map_err(|_| de::Error::custom("JSON parsing failed for YoctoNear"))?;
        Ok(YoctoNear(value))
    }

    fn visit_string<E>(self, v: String) -> Result<Self::Value, E>
    where
        E: de::Error,
    {
        self.visit_str(&v)
    }
}

#[cfg(test)]
mod test {
    use super::*;
    use crate::YOCTO;

    #[test]
    fn json_serialization() {
        let amount = YoctoNear::from(YOCTO);
        let amount_as_json = serde_json::to_string(&amount).unwrap();
        println!("{}", amount_as_json);

        let amount2: YoctoNear = serde_json::from_str(&amount_as_json).unwrap();
        assert_eq!(amount, amount2);
    }
}

'''
'''--- near/oysterpack-smart-near/src/lib.rs ---
//! Provides support for building OysterPack SMART NEAR smart contracts.

pub use crate::core::*;

pub mod component;
mod core;
pub mod data;
pub mod domain;

pub use lazy_static;
pub use near_sdk;

'''
'''--- near/oysterpack-smart-near/tests/quick_test.rs ---
#[test]
fn test() {}

'''
'''--- near/oysterpack-smart-stake-factory/Cargo.toml ---
[package]
name = "oysterpack-smart-stake-factory"
version = "0.1.0"
authors = ["oysterpack.inc <2zP6OaymGZhJTHFvQMzp6Ze>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
oysterpack-smart-near = {path = "../oysterpack-smart-near"}

near-sdk = "3"

[dev-dependencies]
oysterpack-smart-near-test = {path = "../oysterpack-smart-near-test"}
'''
'''--- near/oysterpack-smart-stake-factory/Makefile.toml ---
env_files = ["./neardev/dev-account.env"]

extend = "../Makefile.toml"

[env]
PACKAGE = "oysterpack_smart_stake_factory"

[tasks.build-wasm]
private = true
command = "cargo"
    args = ["build", "--target", "wasm32-unknown-unknown", "--release"]

[tasks.build-release]
description = "Optimizes the wasm file for small size"
category = "Build"
command = "wasm-opt"
args = ["../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm", "-Oz", "-o", "../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm"]
dependencies = ["build-wasm"]

[tasks.twiggy]
description = "https://rustwasm.github.io/twiggy/index.html"
command = "twiggy"
args = ["top", "-n", "10","../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm" ]

[tasks.wasm-ls]
script_runner = "@duckscript"
script = '''
ls -la ../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm
'''

[tasks.near-dev-deploy]
command = "near"
args = ["dev-deploy", "../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm"]
dependencies = ["build-release"]

[tasks.near-testnet-deploy]
command = "near"
args = ["deploy", "--accountId", "stake-v1.oysterpack.testnet", "--wasmFile", "../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm"]
dependencies = ["build-release"]

[tasks.near-guildnet-deploy]
command = "near"
args = [
    "deploy", "--accountId", "stake-v1.oysterpack.guildnet", "--wasmFile", "../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm",
    "--nodeUrl", "https://rpc.openshards.io/", "--walletUrl", "https://wallet.openshards.io/", "--networkId", "guildnet",
]
dependencies = ["build-release"]

[tasks.near-state]
command = "near"
args = ["state", "${CONTRACT_NAME}"]

[tasks.near-deploy-init]
script_runner = "@duckscript"
script = '''
export NEAR_ENV=${NEAR_ENV}
'''
'''
'''--- near/oysterpack-smart-stake-factory/README.md ---

'''
'''--- near/oysterpack-smart-stake-factory/src/lib.rs ---
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env, is_promise_success,
    json_types::ValidAccountId,
    near_bindgen,
    serde::{Deserialize, Serialize},
    AccountId, PanicOnDefault, Promise,
};
use oysterpack_smart_near::asserts::ERR_INVALID;
use oysterpack_smart_near::domain::{
    ActionType, Gas, SenderIsReceiver, TGas, TransactionResource, YoctoNear,
};
use oysterpack_smart_near::{
    domain::{BasisPoints, PublicKey},
    json_function_callback, to_valid_account_id, ErrCode, Level, LogEvent, TERA, YOCTO,
};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract;

pub const ERR_INSUFFICIENT_ATTACHED_DEPOSIT: ErrCode = ErrCode("INSUFFICIENT_ATTACHED_DEPOSIT");
pub const ERR_STAKE_POOL_DEPLOY_FAILURE: ErrCode = ErrCode("STAKE_POOL_DEPLOY_FAILURE");

pub const LOG_EVENT_STAKE_POOL_DEPLOY_SUCCESS: LogEvent =
    LogEvent(Level::INFO, "STAKE_POOL_DEPLOY_SUCCESS");

/// conservatively overestimated
const STAKE_DEPLOY_GAS: Gas = Gas(100 * TERA);

#[near_bindgen]
impl Contract {
    #[init]
    pub fn init() -> Self {
        Self
    }

    /// Used to deploy an instance of the STAKE pool contract as child contract using the following
    /// naming convention: `{stake_symbol}.{env::current_account_id}`
    ///
    /// ## Args
    /// - stake_symbol - will be used to create the child account ID, which will also be used as the STAKE FT symbol
    /// - stake_public_key - public key that binds the STAKE pool to the validator node
    /// - owner - STAKE pool owner
    /// - staking_fee - default is 0 BPS
    /// - earnings_fee - default is 100 BPS
    #[payable]
    pub fn deploy(
        stake_symbol: String,
        stake_public_key: PublicKey,
        owner: Option<ValidAccountId>,
        staking_fee: Option<BasisPoints>,
        earnings_fee: Option<BasisPoints>,
    ) -> Promise {
        let stake_pool_account_id = {
            let stake_pool_account_id = format!(
                "{}.{}",
                stake_symbol.to_lowercase(),
                env::current_account_id()
            );
            to_valid_account_id(&stake_pool_account_id)
        };

        let stake_contract_wasm_bytes = {
            let stake_contract_wasm_bytes = Self::stake_contract_wasm_bytes();
            let contract_storage_costs =
                stake_contract_wasm_bytes.len() as u128 * env::storage_byte_cost();
            // an extra NEAR is used to pay for contract operational storage costs
            let min_required_deposit = contract_storage_costs + YOCTO;
            ERR_INSUFFICIENT_ATTACHED_DEPOSIT.assert(
                || env::attached_deposit() >= min_required_deposit,
                || format!("No enough deposit was attached for deploying the STAKE pool contract. Min required attached deposit is {} yoctoNEAR", min_required_deposit),
            );
            stake_contract_wasm_bytes
        };

        let deploy = Promise::new(stake_pool_account_id.as_ref().clone())
            .create_account()
            .transfer(env::attached_deposit())
            .deploy_contract(stake_contract_wasm_bytes)
            .function_call(
                b"deploy".to_vec(),
                near_sdk::serde_json::to_vec(&StakePoolDeployArgs {
                    stake_public_key,
                    owner: owner.or(Some(to_valid_account_id(&env::predecessor_account_id()))),
                    staking_fee,
                    earnings_fee,
                    stake_symbol: Some(stake_symbol),
                })
                .unwrap(),
                0,
                *STAKE_DEPLOY_GAS,
            );
        let finalize = json_function_callback(
            "on_deploy",
            Some(OnDeployArgs {
                account_id: env::predecessor_account_id(),
                deposit: env::attached_deposit().into(),
            }),
            YoctoNear::ZERO,
            Self::callback_gas(),
        );
        deploy.then(finalize)
    }

    #[private]
    pub fn on_deploy(&mut self, account_id: AccountId, deposit: YoctoNear) {
        if is_promise_success() {
            LOG_EVENT_STAKE_POOL_DEPLOY_SUCCESS.log("");
        } else {
            ERR_STAKE_POOL_DEPLOY_FAILURE.log("");
            Promise::new(account_id).transfer(*deposit);
        }
    }
}

impl Contract {
    fn stake_contract_wasm_bytes() -> Vec<u8> {
        include_bytes!("../../target/wasm32-unknown-unknown/release/oysterpack_smart_stake.wasm")
            .to_vec()
    }

    fn callback_gas() -> Gas {
        const REMAINING_COMPUTE: Gas = Gas(100 * TERA);
        let gas =
            (env::prepaid_gas() - env::used_gas() - *STAKE_DEPLOY_GAS - *REMAINING_COMPUTE).into();

        let min_callback_gas = {
            const RECEIPT: TransactionResource =
                TransactionResource::ActionReceipt(SenderIsReceiver(false));
            const TRANSFER: TransactionResource = TransactionResource::Action(ActionType::Transfer);
            const COMPUTE: TGas = TGas(10); // conservatively overestimated
            Gas::compute(vec![
                (RECEIPT, 1), // transfer
                (TRANSFER, 1),
            ]) + COMPUTE
        };
        ERR_INVALID.assert(
            || gas >= min_callback_gas,
            || {
                let min_required_gas = env::used_gas() + *min_callback_gas + *REMAINING_COMPUTE;
                format!(
                    "not enough gas was attached - min required gas is {} TGas",
                    min_required_gas / TERA + 1 // round up 1 TGas
                )
            },
        );
        gas
    }
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
struct StakePoolDeployArgs {
    stake_public_key: PublicKey,
    owner: Option<ValidAccountId>,
    staking_fee: Option<BasisPoints>,
    earnings_fee: Option<BasisPoints>,
    stake_symbol: Option<String>,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
struct OnDeployArgs {
    account_id: AccountId,
    deposit: YoctoNear,
}

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near_test::{
        near_sdk::{serde_json, test_utils},
        *,
    };

    fn staking_public_key() -> PublicKey {
        serde_json::from_str("\"ed25519:GTi3gtSio5ZYYKTT8WVovqJEob6KqdmkTi8KqGSfwqdm\"").unwrap()
    }

    #[test]
    fn load_stake_contract_wasm_file() {
        let stake_contract_wasm_bytes = Contract::stake_contract_wasm_bytes();

        println!(
            "stake_contract_wasm_bytes.len() = {}",
            stake_contract_wasm_bytes.len()
        );
    }

    #[test]
    fn deploy() {
        let mut ctx = new_context("bob");
        ctx.prepaid_gas = 300 * TERA;
        ctx.attached_deposit = 10 * YOCTO;
        testing_env!(ctx);
        let staking_fee = Some(BasisPoints(10));
        let earnings_fee = Some(BasisPoints(50));
        Contract::deploy(
            "PEARL".to_string(),
            staking_public_key(),
            None,
            staking_fee,
            earnings_fee,
        );

        let receipts = get_receipts();
        assert_eq!(receipts.len(), 2);
        {
            let receipt = &receipts[0];
            assert_eq!(
                receipt.receiver_id,
                format!("pearl.{}", env::current_account_id())
            );
            assert_eq!(receipt.actions.len(), 4);
            {
                let action = &receipt.actions[0];
                match action {
                    Action::CreateAccount => {}
                    _ => panic!("expected CreateAccount"),
                }
            }
            {
                let action = &receipt.actions[1];
                match action {
                    Action::Transfer(action) => {
                        assert_eq!(action.deposit, env::attached_deposit());
                    }
                    _ => panic!("expected Transfer"),
                }
            }
            {
                let action = &receipt.actions[2];
                match action {
                    Action::DeployContract(action) => {
                        println!("code len() = {}", action.code.len());
                    }
                    _ => panic!("expected DeployContract"),
                }
            }
            {
                let action = &receipt.actions[3];
                match action {
                    Action::FunctionCall(action) => {
                        assert_eq!(action.method_name, "deploy");
                        let args: StakePoolDeployArgs = serde_json::from_str(&action.args).unwrap();
                        assert_eq!(args.stake_symbol.unwrap(), "PEARL");
                        assert_eq!(
                            args.owner.unwrap(),
                            to_valid_account_id(env::predecessor_account_id().as_str())
                        );
                        assert_eq!(args.stake_public_key, staking_public_key());
                        assert_eq!(args.staking_fee, staking_fee);
                        assert_eq!(args.earnings_fee, earnings_fee);

                        assert_eq!(action.gas, *STAKE_DEPLOY_GAS);
                    }
                    _ => panic!("expected FunctionCall"),
                }
            }
        }
        {
            let receipt = &receipts[1];
            assert_eq!(receipt.actions.len(), 1);
            assert_eq!(receipt.receiver_id, env::current_account_id());
            match &receipt.actions[0] {
                Action::FunctionCall(action) => {
                    assert_eq!(action.method_name, "on_deploy");
                    let args: OnDeployArgs = serde_json::from_str(&action.args).unwrap();
                    assert_eq!(args.account_id, env::predecessor_account_id());
                    assert_eq!(args.deposit, env::attached_deposit().into());
                }
                _ => panic!("expected FunctionCall"),
            }
        }
    }

    #[test]
    fn on_deploy_success() {
        let mut ctx = new_context("bob");
        testing_env!(ctx.clone());

        ctx.predecessor_account_id = ctx.current_account_id.clone();
        testing_env_with_promise_result_success(ctx.clone());

        Contract.on_deploy("bob".to_string(), (10 * YOCTO).into());

        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(logs, vec!["[INFO] [STAKE_POOL_DEPLOY_SUCCESS] ",]);
    }

    #[test]
    fn on_deploy_failure() {
        let mut ctx = new_context("bob");
        testing_env!(ctx.clone());

        ctx.predecessor_account_id = ctx.current_account_id.clone();
        testing_env_with_promise_result_failure(ctx.clone());

        Contract.on_deploy("bob".to_string(), (10 * YOCTO).into());

        let logs = test_utils::get_logs();
        println!("{:#?}", logs);
        assert_eq!(logs, vec!["[ERR] [STAKE_POOL_DEPLOY_FAILURE] ",]);

        let receipts = deserialize_receipts();
        assert_eq!(receipts.len(), 1);
        let receipt = &receipts[0];
        assert_eq!(receipt.receiver_id, "bob");
        assert_eq!(receipt.actions.len(), 1);
        match &receipt.actions[0] {
            Action::Transfer(action) => {
                assert_eq!(action.deposit, 10 * YOCTO);
            }
            _ => panic!("expected transfer"),
        }
    }

    #[test]
    fn serialize_deserialize_deploy_args() {
        let stake_public_key =
            serde_json::from_str("\"ed25519:GTi3gtSio5ZYYKTT8WVovqJEob6KqdmkTi8KqGSfwqdm\"")
                .unwrap();
        let args = DeployArgs {
            stake_symbol: "PEARL".to_string(),
            stake_public_key,
            owner: None,
            staking_fee: None,
            earnings_fee: None,
        };

        let json = serde_json::to_string(&args).unwrap();
        println!("{}", json);

        let json = r#"{"stake_symbol":"PEARL","stake_public_key":"ed25519:GTi3gtSio5ZYYKTT8WVovqJEob6KqdmkTi8KqGSfwqdm"}"#;
        let args2: DeployArgs = serde_json::from_str(&json).unwrap();
        assert_eq!(args2, args);
    }

    #[derive(Serialize, Deserialize, Eq, PartialEq, Debug)]
    #[serde(crate = "near_sdk::serde")]
    struct DeployArgs {
        stake_symbol: String,
        stake_public_key: PublicKey,
        owner: Option<ValidAccountId>,
        staking_fee: Option<BasisPoints>,
        earnings_fee: Option<BasisPoints>,
    }
}

'''
'''--- near/oysterpack-smart-stake/Cargo.toml ---
[package]
name = "oysterpack-smart-stake"
version = "0.1.0"
authors = ["OysterPack Inc <oysterpack.inc@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
oysterpack-smart-near = {path = "../oysterpack-smart-near"}
oysterpack-smart-contract = {path = "../oysterpack-smart-contract"}
oysterpack-smart-account-management = {path = "../oysterpack-smart-account-management"}
oysterpack-smart-fungible-token = {path = "../oysterpack-smart-fungible-token"}
oysterpack-smart-staking-pool = {path = "../oysterpack-smart-staking-pool"}

near-sdk = "3"

[dev-dependencies]
oysterpack-smart-near-test = {path = "../oysterpack-smart-near-test"}
'''
'''--- near/oysterpack-smart-stake/Makefile.toml ---
env_files = ["./neardev/dev-account.env"]

extend = "../Makefile.toml"

[env]
PACKAGE = "oysterpack_smart_stake"

[tasks.build-wasm]
private = true
command = "cargo"
    args = ["build", "--target", "wasm32-unknown-unknown", "--release"]

[tasks.build-release]
description = "Optimizes the wasm file for small size"
category = "Build"
command = "wasm-opt"
args = ["../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm", "-Oz", "-o", "../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm"]
dependencies = ["build-wasm"]

[tasks.twiggy]
description = "https://rustwasm.github.io/twiggy/index.html"
command = "twiggy"
args = ["top", "-n", "10","../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm" ]

[tasks.wasm-ls]
script_runner = "@duckscript"
script = '''
ls -la ../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm
'''

[tasks.near-dev-deploy]
command = "near"
args = ["dev-deploy", "../target/wasm32-unknown-unknown/release/${PACKAGE}.wasm"]
dependencies = ["build-release"]

[tasks.near-state]
command = "near"
args = ["state", "${CONTRACT_NAME}"]

[tasks.near-deploy-init]
script_runner = "@duckscript"
script = '''
export NEAR_ENV=${NEAR_ENV}
'''
'''
'''--- near/oysterpack-smart-stake/README.md ---

'''
'''--- near/oysterpack-smart-stake/src/access_control.rs ---
use crate::*;
use near_sdk::json_types::ValidAccountId;
use oysterpack_smart_account_management::{Permissions, PermissionsManagement};
use std::collections::HashMap;

#[near_bindgen]
impl PermissionsManagement for Contract {
    fn ops_permissions_is_admin(&self, account_id: ValidAccountId) -> bool {
        Self::account_manager().ops_permissions_is_admin(account_id)
    }

    fn ops_permissions_grant_admin(&mut self, account_id: ValidAccountId) {
        Self::account_manager().ops_permissions_grant_admin(account_id);
    }

    fn ops_permissions_revoke_admin(&mut self, account_id: ValidAccountId) {
        Self::account_manager().ops_permissions_revoke_admin(account_id);
    }

    fn ops_permissions_is_operator(&self, account_id: ValidAccountId) -> bool {
        Self::account_manager().ops_permissions_is_operator(account_id)
    }

    fn ops_permissions_grant_operator(&mut self, account_id: ValidAccountId) {
        Self::account_manager().ops_permissions_grant_operator(account_id);
    }

    fn ops_permissions_revoke_operator(&mut self, account_id: ValidAccountId) {
        Self::account_manager().ops_permissions_revoke_operator(account_id);
    }

    fn ops_permissions_grant(&mut self, account_id: ValidAccountId, permissions: Permissions) {
        Self::account_manager().ops_permissions_grant(account_id, permissions);
    }

    fn ops_permissions_grant_permissions(
        &mut self,
        account_id: ValidAccountId,
        permissions: Vec<u8>,
    ) {
        Self::account_manager().ops_permissions_grant_permissions(account_id, permissions);
    }

    fn ops_permissions_revoke(&mut self, account_id: ValidAccountId, permissions: Permissions) {
        Self::account_manager().ops_permissions_revoke(account_id, permissions);
    }

    fn ops_permissions_revoke_permissions(
        &mut self,
        account_id: ValidAccountId,
        permissions: Vec<u8>,
    ) {
        Self::account_manager().ops_permissions_revoke_permissions(account_id, permissions);
    }

    fn ops_permissions_revoke_all(&mut self, account_id: ValidAccountId) {
        Self::account_manager().ops_permissions_revoke_all(account_id);
    }

    fn ops_permissions_contains(
        &self,
        account_id: ValidAccountId,
        permissions: Permissions,
    ) -> bool {
        Self::account_manager().ops_permissions_contains(account_id, permissions)
    }

    fn ops_permissions(&self, account_id: ValidAccountId) -> Option<Permissions> {
        Self::account_manager().ops_permissions(account_id)
    }

    fn ops_permissions_granted(&self, account_id: ValidAccountId) -> Option<HashMap<u8, String>> {
        Self::account_manager().ops_permissions_granted(account_id)
    }

    fn ops_permissions_contract_permissions(&self) -> Option<HashMap<u8, String>> {
        Self::account_manager().ops_permissions_contract_permissions()
    }
}

'''
'''--- near/oysterpack-smart-stake/src/account_storage_usage.rs ---
use crate::*;
use near_sdk::json_types::ValidAccountId;
use oysterpack_smart_account_management::AccountStorageUsage;
use oysterpack_smart_near::domain::StorageUsage;

#[near_bindgen]
impl AccountStorageUsage for Contract {
    fn ops_storage_usage_bounds(&self) -> StorageUsageBounds {
        Self::account_manager().ops_storage_usage_bounds()
    }

    fn ops_storage_usage(&self, account_id: ValidAccountId) -> Option<StorageUsage> {
        Self::account_manager().ops_storage_usage(account_id)
    }
}

'''
'''--- near/oysterpack-smart-stake/src/components.rs ---
use crate::*;
use oysterpack_smart_account_management::components::account_management::AccountManagementComponent;
use oysterpack_smart_account_management::ContractPermissions;
use oysterpack_smart_contract::components::contract_operator::ContractOperatorComponent;
use oysterpack_smart_staking_pool::components::staking_pool::StakingPoolComponent;
use oysterpack_smart_staking_pool::{StakeAccountData, PERMISSION_TREASURER};
use std::collections::HashMap;

pub type AccountData = StakeAccountData;

pub type AccountManager = AccountManagementComponent<AccountData>;

pub type StakeFungibleToken = FungibleTokenComponent<AccountData>;

pub type ContractOperator = ContractOperatorComponent<AccountData>;

impl Contract {
    pub(crate) fn account_manager() -> AccountManager {
        StakeFungibleToken::register_storage_management_event_handler();

        let contract_permissions = {
            let mut permissions = HashMap::with_capacity(1);
            permissions.insert(0, PERMISSION_TREASURER);
            ContractPermissions(permissions)
        };

        AccountManager::new(contract_permissions)
    }

    pub(crate) fn ft_stake() -> StakeFungibleToken {
        StakeFungibleToken::new(Self::account_manager())
    }

    pub(crate) fn contract_operator() -> ContractOperator {
        ContractOperator::new(Self::account_manager())
    }

    pub(crate) fn staking_pool() -> StakingPoolComponent {
        StakingPoolComponent::new(Self::account_manager(), Self::ft_stake())
    }
}

'''
'''--- near/oysterpack-smart-stake/src/contract_metrics.rs ---
use crate::*;
use oysterpack_smart_account_management::AccountMetrics;
use oysterpack_smart_contract::components::contract_metrics::ContractMetricsComponent;
use oysterpack_smart_contract::{
    ContractMetrics, ContractMetricsSnapshot, ContractNearBalances, ContractStorageUsage,
    ContractStorageUsageCosts,
};
use oysterpack_smart_near::data::numbers::U128;

#[near_bindgen]
impl ContractMetrics for Contract {
    fn ops_metrics_total_registered_accounts(&self) -> U128 {
        ContractMetricsComponent.ops_metrics_total_registered_accounts()
    }

    fn ops_metrics_contract_storage_usage(&self) -> ContractStorageUsage {
        ContractMetricsComponent.ops_metrics_contract_storage_usage()
    }

    fn ops_metrics_near_balances(&self) -> ContractNearBalances {
        ContractMetricsComponent.ops_metrics_near_balances()
    }

    fn ops_metrics_storage_usage_costs(&self) -> ContractStorageUsageCosts {
        ContractMetricsComponent.ops_metrics_storage_usage_costs()
    }

    fn ops_metrics(&self) -> ContractMetricsSnapshot {
        ContractMetricsComponent.ops_metrics()
    }

    fn ops_metrics_accounts(&self) -> AccountMetrics {
        ContractMetricsComponent.ops_metrics_accounts()
    }
}

'''
'''--- near/oysterpack-smart-stake/src/contract_operator.rs ---
use crate::*;
use oysterpack_smart_contract::ContractOperator;
use oysterpack_smart_near::{domain::StorageUsage, near_sdk::near_bindgen};

#[near_bindgen]
impl ContractOperator for Contract {
    fn ops_operator_lock_storage_balance(&mut self, storage_usage: StorageUsage) {
        Self::contract_operator().ops_operator_lock_storage_balance(storage_usage);
    }

    fn ops_owner_grant_admin(&mut self) {
        Self::contract_operator().ops_owner_grant_admin();
    }
}

'''
'''--- near/oysterpack-smart-stake/src/contract_ownership.rs ---
use crate::*;
use near_sdk::{near_bindgen, AccountId};
use oysterpack_smart_contract::{ContractOwnerNearBalance, ContractOwnership};
use oysterpack_smart_near::domain::YoctoNear;

#[near_bindgen]
impl ContractOwnership for Contract {
    fn ops_owner(&self) -> AccountId {
        ContractOwnershipComponent.ops_owner()
    }

    fn ops_owner_balance(&self) -> ContractOwnerNearBalance {
        ContractOwnershipComponent.ops_owner_balance()
    }

    fn ops_owner_prospective(&self) -> Option<AccountId> {
        ContractOwnershipComponent.ops_owner_prospective()
    }

    #[payable]
    fn ops_owner_transfer(&mut self, new_owner: ValidAccountId) {
        ContractOwnershipComponent.ops_owner_transfer(new_owner)
    }

    #[payable]
    fn ops_owner_cancel_transfer(&mut self) {
        ContractOwnershipComponent.ops_owner_cancel_transfer()
    }

    #[payable]
    fn ops_owner_finalize_transfer(&mut self) {
        ContractOwnershipComponent.ops_owner_finalize_transfer()
    }

    #[payable]
    fn ops_owner_withdraw_balance(
        &mut self,
        amount: Option<YoctoNear>,
    ) -> ContractOwnerNearBalance {
        ContractOwnershipComponent.ops_owner_withdraw_balance(amount)
    }
}

'''
'''--- near/oysterpack-smart-stake/src/fungible_token.rs ---
use crate::*;
use oysterpack_smart_fungible_token::{
    FungibleToken, FungibleTokenMetadataProvider, FungibleTokenOperator, Memo, Metadata,
    OperatorCommand, ResolveTransferCall, TokenAmount, TransferCallMessage,
};
use oysterpack_smart_near::domain::Gas;
use oysterpack_smart_near::near_sdk::Promise;

#[near_bindgen]
impl FungibleToken for Contract {
    #[payable]
    fn ft_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        amount: TokenAmount,
        memo: Option<Memo>,
    ) {
        Self::ft_stake().ft_transfer(receiver_id, amount, memo)
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: TokenAmount,
        memo: Option<Memo>,
        msg: TransferCallMessage,
    ) -> Promise {
        Self::ft_stake().ft_transfer_call(receiver_id, amount, memo, msg)
    }

    fn ft_total_supply(&self) -> TokenAmount {
        Self::ft_stake().ft_total_supply()
    }

    fn ft_balance_of(&self, account_id: ValidAccountId) -> TokenAmount {
        Self::ft_stake().ft_balance_of(account_id)
    }
}

#[near_bindgen]
impl ResolveTransferCall for Contract {
    #[private]
    fn ft_resolve_transfer_call(
        &mut self,
        sender_id: ValidAccountId,
        receiver_id: ValidAccountId,
        amount: TokenAmount,
    ) -> TokenAmount {
        Self::ft_stake().ft_resolve_transfer_call(sender_id, receiver_id, amount)
    }
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> Metadata {
        Self::ft_stake().ft_metadata()
    }
}

#[near_bindgen]
impl FungibleTokenOperator for Contract {
    fn ft_operator_command(&mut self, command: OperatorCommand) {
        Self::ft_stake().ft_operator_command(command)
    }

    fn ft_operator_transfer_callback_gas(&self) -> Gas {
        Self::ft_stake().ft_operator_transfer_callback_gas()
    }
}

'''
'''--- near/oysterpack-smart-stake/src/lib.rs ---
mod access_control;
mod account_storage_usage;
mod components;
mod contract_metrics;
mod contract_operator;
mod contract_ownership;
mod fungible_token;
mod staking_pool;
mod storage_management;

use components::*;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    json_types::ValidAccountId,
    near_bindgen, serde_json, PanicOnDefault,
};
use oysterpack_smart_account_management::{
    components::account_management::AccountManagementComponentConfig, AccountRepository,
    StorageUsageBounds,
};
use oysterpack_smart_contract::{
    components::contract_ownership::ContractOwnershipComponent, ContractOwnership,
};
use oysterpack_smart_contract::{ContractNearBalances, CONTRACT_LOCKED_STORAGE_BALANCE};
use oysterpack_smart_fungible_token::components::fungible_token::{
    FungibleTokenComponent, FungibleTokenConfig,
};
use oysterpack_smart_fungible_token::*;
use oysterpack_smart_near::component::LOG_EVENT_DEPLOYMENT;
use oysterpack_smart_near::domain::BasisPoints;
use oysterpack_smart_near::{
    component::{Deploy, ManagesAccountData},
    domain::PublicKey,
};
use oysterpack_smart_staking_pool::components::staking_pool::{
    StakingPoolComponent, StakingPoolComponentConfig,
};
use std::convert::TryInto;

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract;

#[near_bindgen]
impl Contract {
    /// If owner is not specified, then predecessor Account ID will be set as the contract owner.
    /// - owner account is granted admin permission
    /// - default fees: staking fee = 0 BPS, earnings fee = 100 BPS
    /// - STAKE FT symbol defaults to the first part of the contract account ID and uppercased, e.g. if the contract
    ///   account ID is "pearl.stake-v1.oysterpack.near", then the symbol will be "PEARL"
    #[init]
    pub fn deploy(
        stake_public_key: PublicKey,
        owner: Option<ValidAccountId>,
        staking_fee: Option<BasisPoints>,
        earnings_fee: Option<BasisPoints>,
        stake_symbol: Option<String>,
    ) -> Self {
        let owner = owner.unwrap_or_else(|| env::predecessor_account_id().try_into().unwrap());
        ContractOwnershipComponent::deploy(owner.clone());
        LOG_EVENT_DEPLOYMENT.log("ContractOwnershipComponent");

        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: None,
            admin_account: owner.clone(),
            component_account_storage_mins: Some(vec![StakeFungibleToken::account_storage_min]),
        });
        LOG_EVENT_DEPLOYMENT.log("AccountManagementComponent");

        // transfer any contract balance to the owner - minus the contract operational balance
        {
            // lock balance for contract operational storage balance
            ContractNearBalances::set_balance(
                CONTRACT_LOCKED_STORAGE_BALANCE,
                (env::storage_byte_cost() * 10000).into(),
            );

            LOG_EVENT_DEPLOYMENT.log("locked balance for 10K contract storage");

            let account_manager = Self::account_manager();
            let mut owner_account = account_manager.registered_account_near_data(owner.as_ref());
            let owner_balance = ContractOwnershipComponent.ops_owner_balance().available;
            owner_account.incr_near_balance(owner_balance);
            owner_account.save();

            LOG_EVENT_DEPLOYMENT.log(format!("owner balance = {}", owner_balance));
        }

        let stake_symbol = stake_symbol.unwrap_or_else(|| {
            let contract_account_id = env::current_account_id();
            match contract_account_id.as_str().find('.') {
                Some(index) => contract_account_id[0..index].to_string(),
                None => contract_account_id,
            }
        });

        let stake_metadata = Metadata {
            spec: Spec(FT_METADATA_SPEC.to_string()),
            name: Name::from("STAKE"),
            symbol: Symbol(stake_symbol.to_uppercase()),
            decimals: 24,
            icon: None,
            reference: None,
            reference_hash: None,
        };
        StakeFungibleToken::deploy(FungibleTokenConfig {
            metadata: stake_metadata.clone(),
            token_supply: 0,
        });
        LOG_EVENT_DEPLOYMENT.log(format!(
            "FungibleTokenComponent {}",
            serde_json::to_string_pretty(&stake_metadata).unwrap()
        ));

        StakingPoolComponent::deploy(StakingPoolComponentConfig {
            stake_public_key,
            staking_fee: staking_fee.or(Some(0.into())),
            earnings_fee: earnings_fee.or(Some(100.into())),
        });
        LOG_EVENT_DEPLOYMENT.log("StakingPoolComponent");

        Self
    }
}

#[cfg(test)]
mod tests {

    #[test]
    fn parsing_stake_symbol_from_account_id() {
        let contract_account_id = "dev-123".to_string();
        let symbol = match contract_account_id.as_str().find('.') {
            Some(index) => contract_account_id[0..index].to_string(),
            None => contract_account_id.clone(),
        };
        assert_eq!(symbol, contract_account_id);

        let contract_account_id = "stake.stake-v1.oysterpack".to_string();
        let symbol = match contract_account_id.as_str().find('.') {
            Some(index) => contract_account_id[0..index].to_string(),
            None => contract_account_id.clone(),
        };
        assert_eq!(symbol, "stake");
    }
}

'''
'''--- near/oysterpack-smart-stake/src/staking_pool.rs ---
use crate::*;
use near_sdk::near_bindgen;
use oysterpack_smart_near::domain::YoctoNear;
use oysterpack_smart_near::near_sdk::{AccountId, Promise, PromiseOrValue};
use oysterpack_smart_staking_pool::{
    Fees, NearStakingPool, NearStakingPoolAccount, StakeAccountBalances, StakeActionCallbacks,
    StakingPool, StakingPoolBalances, StakingPoolOperator, StakingPoolOperatorCommand, Status,
    Treasury,
};

#[near_bindgen]
impl StakingPool for Contract {
    fn ops_stake_balance(&self, account_id: ValidAccountId) -> Option<StakeAccountBalances> {
        Self::staking_pool().ops_stake_balance(account_id)
    }

    #[payable]
    fn ops_stake(&mut self) -> PromiseOrValue<StakeAccountBalances> {
        Self::staking_pool().ops_stake()
    }

    fn ops_unstake(&mut self, amount: Option<YoctoNear>) -> PromiseOrValue<StakeAccountBalances> {
        Self::staking_pool().ops_unstake(amount)
    }

    fn ops_restake(&mut self, amount: Option<YoctoNear>) -> PromiseOrValue<StakeAccountBalances> {
        Self::staking_pool().ops_restake(amount)
    }

    fn ops_stake_withdraw(&mut self, amount: Option<YoctoNear>) -> StakeAccountBalances {
        Self::staking_pool().ops_stake_withdraw(amount)
    }

    #[payable]
    fn ops_stake_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        amount: YoctoNear,
        memo: Option<Memo>,
    ) -> TokenAmount {
        Self::staking_pool().ops_stake_transfer(receiver_id, amount, memo)
    }

    #[payable]
    fn ops_stake_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: YoctoNear,
        memo: Option<Memo>,
        msg: TransferCallMessage,
    ) -> Promise {
        Self::staking_pool().ops_stake_transfer_call(receiver_id, amount, memo, msg)
    }

    fn ops_stake_token_value(&self, amount: Option<TokenAmount>) -> YoctoNear {
        Self::staking_pool().ops_stake_token_value(amount)
    }

    fn ops_stake_token_value_with_earnings(&mut self, amount: Option<TokenAmount>) -> YoctoNear {
        Self::staking_pool().ops_stake_token_value_with_earnings(amount)
    }

    fn ops_stake_status(&self) -> Status {
        Self::staking_pool().ops_stake_status()
    }

    fn ops_stake_pool_balances(&self) -> StakingPoolBalances {
        Self::staking_pool().ops_stake_pool_balances()
    }

    fn ops_stake_fees(&self) -> Fees {
        Self::staking_pool().ops_stake_fees()
    }

    fn ops_stake_public_key(&self) -> PublicKey {
        Self::staking_pool().ops_stake_public_key()
    }
}

#[near_bindgen]
impl NearStakingPool for Contract {
    fn get_account_staked_balance(&self, account_id: ValidAccountId) -> YoctoNear {
        Self::staking_pool().get_account_staked_balance(account_id)
    }

    fn get_account_unstaked_balance(&self, account_id: ValidAccountId) -> YoctoNear {
        Self::staking_pool().get_account_unstaked_balance(account_id)
    }

    fn is_account_unstaked_balance_available(&self, account_id: ValidAccountId) -> bool {
        Self::staking_pool().is_account_unstaked_balance_available(account_id)
    }

    fn get_account_total_balance(&self, account_id: ValidAccountId) -> YoctoNear {
        Self::staking_pool().get_account_total_balance(account_id)
    }

    fn get_account(&self, account_id: ValidAccountId) -> NearStakingPoolAccount {
        Self::staking_pool().get_account(account_id)
    }

    #[payable]
    fn deposit(&mut self) {
        Self::staking_pool().deposit();
    }

    #[payable]
    fn deposit_and_stake(&mut self) {
        Self::staking_pool().deposit_and_stake();
    }

    fn withdraw(&mut self, amount: YoctoNear) {
        Self::staking_pool().withdraw(amount);
    }

    fn withdraw_all(&mut self) {
        Self::staking_pool().withdraw_all();
    }

    fn stake(&mut self, amount: YoctoNear) {
        Self::staking_pool().stake(amount);
    }

    fn unstake(&mut self, amount: YoctoNear) {
        Self::staking_pool().unstake(amount);
    }

    fn unstake_all(&mut self) {
        Self::staking_pool().unstake_all();
    }
}

#[near_bindgen]
impl StakeActionCallbacks for Contract {
    #[private]
    fn ops_stake_finalize(&mut self, account_id: AccountId) -> StakeAccountBalances {
        Self::staking_pool().ops_stake_finalize(account_id)
    }

    #[private]
    fn ops_stake_start_finalize(&mut self) {
        Self::staking_pool().ops_stake_start_finalize();
    }

    #[private]
    fn ops_stake_stop_finalize(&mut self) {
        Self::staking_pool().ops_stake_stop_finalize()
    }
}

#[near_bindgen]
impl StakingPoolOperator for Contract {
    fn ops_stake_operator_command(&mut self, command: StakingPoolOperatorCommand) {
        Self::staking_pool().ops_stake_operator_command(command);
    }
}

#[near_bindgen]
impl Treasury for Contract {
    #[payable]
    fn ops_stake_treasury_deposit(&mut self) -> PromiseOrValue<StakeAccountBalances> {
        Self::staking_pool().ops_stake_treasury_deposit()
    }

    #[payable]
    fn ops_stake_treasury_distribution(&mut self) {
        Self::staking_pool().ops_stake_treasury_distribution();
    }

    fn ops_stake_treasury_transfer_to_owner(&mut self, amount: Option<YoctoNear>) {
        Self::staking_pool().ops_stake_treasury_transfer_to_owner(amount);
    }

    fn ops_stake_grant_treasurer(&mut self, account_id: ValidAccountId) {
        Self::staking_pool().ops_stake_grant_treasurer(account_id);
    }

    fn ops_stake_revoke_treasurer(&mut self, account_id: ValidAccountId) {
        Self::staking_pool().ops_stake_revoke_treasurer(account_id);
    }

    fn ops_stake_is_treasurer(&mut self, account_id: ValidAccountId) -> bool {
        Self::staking_pool().ops_stake_is_treasurer(account_id)
    }
}

#[near_bindgen]
impl TransferReceiver for Contract {
    #[private]
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: TokenAmount,
        msg: TransferCallMessage,
    ) -> PromiseOrValue<TokenAmount> {
        Self::staking_pool().ft_on_transfer(sender_id, amount, msg)
    }
}

'''
'''--- near/oysterpack-smart-stake/src/storage_management.rs ---
use crate::*;

use near_sdk::json_types::ValidAccountId;
use near_sdk::near_bindgen;
use oysterpack_smart_account_management::StorageBalance;
use oysterpack_smart_account_management::{StorageBalanceBounds, StorageManagement};
use oysterpack_smart_near::domain::YoctoNear;

#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        Self::account_manager().storage_deposit(account_id, registration_only)
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<YoctoNear>) -> StorageBalance {
        Self::account_manager().storage_withdraw(amount)
    }

    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        Self::account_manager().storage_unregister(force)
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        Self::account_manager().storage_balance_bounds()
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        Self::account_manager().storage_balance_of(account_id)
    }
}

'''
'''--- near/oysterpack-smart-staking-pool/Cargo.toml ---
[package]
name = "oysterpack-smart-staking-pool"
version = "0.1.0"
authors = ["oysterpack.inc <oysterpack.inc@gmail.com>"]
edition = "2018"

[dependencies]
oysterpack-smart-near = { path = "../oysterpack-smart-near" }
oysterpack-smart-account-management = { path = "../oysterpack-smart-account-management" }
oysterpack-smart-contract = { path = "../oysterpack-smart-contract" }
oysterpack-smart-fungible-token = { path = "../oysterpack-smart-fungible-token" }

[dev-dependencies]
oysterpack-smart-near-test = { path = "../oysterpack-smart-near-test" }
bs58 = "0.4.0"

'''
'''--- near/oysterpack-smart-staking-pool/Makefile.toml ---
extend = "../Makefile.toml"
'''
'''--- near/oysterpack-smart-staking-pool/README.md ---

'''
'''--- near/oysterpack-smart-staking-pool/src/components.rs ---
pub mod staking_pool;

'''
'''--- near/oysterpack-smart-staking-pool/src/components/staking_pool.rs ---
use crate::{
    Fees, NearStakingPool, NearStakingPoolAccount, OfflineReason, StakeAccountBalances,
    StakeAccountData, StakeActionCallbacks, StakedBalance, StakingPool, StakingPoolBalances,
    StakingPoolOperator, StakingPoolOperatorCommand, Status, Treasury,
    ERR_STAKED_BALANCE_TOO_LOW_TO_UNSTAKE, ERR_STAKE_ACTION_FAILED, LOG_EVENT_EARNINGS,
    LOG_EVENT_LIQUIDITY, LOG_EVENT_NOT_ENOUGH_TO_STAKE, LOG_EVENT_STAKE, LOG_EVENT_STATUS_OFFLINE,
    LOG_EVENT_STATUS_ONLINE, LOG_EVENT_TREASURY_DEPOSIT, LOG_EVENT_TREASURY_DIVIDEND,
    LOG_EVENT_UNSTAKE, MAX_FEE, PERMISSION_TREASURER,
};
use oysterpack_smart_account_management::{
    components::account_management::AccountManagementComponent, AccountDataObject, AccountMetrics,
    AccountRepository, Permission, PermissionsManagement, StorageManagement,
    ERR_ACCOUNT_NOT_REGISTERED, ERR_NOT_AUTHORIZED,
};
use oysterpack_smart_contract::{
    components::contract_ownership::ContractOwnershipComponent, BalanceId, ContractNearBalances,
    ContractOwnership,
};
use oysterpack_smart_fungible_token::{
    components::fungible_token::FungibleTokenComponent, FungibleToken, Memo, TokenAmount,
    TokenService, TransferCallMessage, TransferReceiver,
};
use oysterpack_smart_near::domain::TGas;
use oysterpack_smart_near::{
    asserts::{ERR_ILLEGAL_STATE, ERR_INSUFFICIENT_FUNDS, ERR_INVALID, ERR_NEAR_DEPOSIT_REQUIRED},
    component::{Component, ComponentState, Deploy},
    data::numbers::U256,
    domain::{
        ActionType, BasisPoints, ByteLen, Gas, PublicKey, SenderIsReceiver, TransactionResource,
        YoctoNear,
    },
    json_function_callback,
    near_sdk::{
        borsh::{self, BorshDeserialize, BorshSerialize},
        env, is_promise_success,
        json_types::ValidAccountId,
        serde::{Deserialize, Serialize},
        AccountId, Promise, PromiseOrValue,
    },
    to_valid_account_id, TERA, YOCTO,
};
use std::cmp::min;

pub type AccountManager = AccountManagementComponent<StakeAccountData>;
pub type StakeFungibleToken = FungibleTokenComponent<StakeAccountData>;

/// Staking Pool Component
///
/// ## Deployment
/// - permissions: [`crate::PERMISSION_TREASURER`];
pub struct StakingPoolComponent {
    account_manager: AccountManager,
    stake_token: StakeFungibleToken,
}

impl StakingPoolComponent {
    pub fn new(
        account_manager: AccountManagementComponent<StakeAccountData>,
        stake: StakeFungibleToken,
    ) -> Self {
        Self {
            account_manager,
            stake_token: stake,
        }
    }
}

impl Component for StakingPoolComponent {
    type State = State;
    const STATE_KEY: u128 = 1954854625400732566949949714395710108;
}

#[derive(
    BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy, PartialEq, Debug,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct State {
    /// validator public key used for staking
    pub stake_public_key: PublicKey,
    /// fee charged when staking funds
    pub staking_fee: BasisPoints,
    /// fee charged based on earnings
    pub earnings_fee: BasisPoints,

    pub status: Status,

    /// used to check if staking rewards were earned
    pub last_contract_managed_total_balance: YoctoNear,

    /// NEAR deposited into the treasury is staked and stake earnings are used to boost the
    /// staking pool yield
    /// - this is used to track the treasury STAKE NEAR value
    /// - if it changes before staking fees are deposited, then it means the treasury received
    ///   staking rewards. The staking rewards will be burned before depositing the staking fee
    pub treasury_balance: YoctoNear,
}

impl State {
    pub const TOTAL_STAKED_BALANCE: BalanceId = BalanceId(1956973021105502521442959170292258855);

    /// unstaked funds are locked for 4 epochs
    /// - we need to track unstaked funds that is owned by accounts separate from the account NEAR balances
    /// - accounts will need to withdraw unstaked balances against this balance in combination with
    /// [`Self::UNSTAKED_LIQUIDITY_POOL`]
    pub const TOTAL_UNSTAKED_BALANCE: BalanceId = BalanceId(1955705469859818043123742456310621056);
    /// provides liquidity for withdrawing unstaked funds that are still locked
    /// - liquidity is added automatically when funds are staked and there are unstaked funds pending
    ///   withdrawal
    /// - when liquidity is added, funds are debited from [`Self::TOTAL_UNSTAKED_BALANCE`] and credited
    ///   to this balance
    pub const UNSTAKED_LIQUIDITY_POOL: BalanceId = BalanceId(1955784487678443851622222785149485288);

    /// returns the total balance that is currently managed by the contract for staking
    /// - this is used to compute staking rewards that are earned - since this balance is completely
    ///  managed by the contract, then if the balance increases, then we know rewards have been earned
    /// - account storage balances are excluded from the equation
    fn contract_managed_total_balance() -> YoctoNear {
        let total_contract_balance: YoctoNear =
            (env::account_balance() + env::account_locked_balance() - env::attached_deposit())
                .into();
        total_contract_balance - AccountMetrics::load().total_near_balance
    }

    /// excludes
    /// attached deposit because this should only be called in view mode on the contract
    /// - `env::attached_deposit` is illegal to call in view mode
    pub(crate) fn contract_managed_total_balance_in_view_mode() -> YoctoNear {
        let total_contract_balance: YoctoNear =
            (env::account_balance() + env::account_locked_balance()).into();
        total_contract_balance - AccountMetrics::load().total_near_balance
    }

    /// returns any earnings that have been received since the last time we checked - but excludes
    /// attached deposit because this should only be called in view mode on the contract
    /// - `env::attached_deposit` is illegal to call in view mode
    fn check_for_earnings_in_view_mode(&self) -> YoctoNear {
        State::contract_managed_total_balance_in_view_mode()
            .saturating_sub(*self.last_contract_managed_total_balance)
            .into()
    }

    pub(crate) fn total_staked_balance() -> YoctoNear {
        ContractNearBalances::near_balance(Self::TOTAL_STAKED_BALANCE)
    }

    fn incr_total_staked_balance(amount: YoctoNear) {
        ContractNearBalances::incr_balance(Self::TOTAL_STAKED_BALANCE, amount);
    }

    fn decr_total_staked_balance(amount: YoctoNear) {
        ContractNearBalances::decr_balance(Self::TOTAL_STAKED_BALANCE, amount);
    }

    pub(crate) fn total_unstaked_balance() -> YoctoNear {
        ContractNearBalances::near_balance(Self::TOTAL_UNSTAKED_BALANCE)
    }

    fn incr_total_unstaked_balance(amount: YoctoNear) {
        ContractNearBalances::incr_balance(Self::TOTAL_UNSTAKED_BALANCE, amount);
    }

    /// first tries to apply the debit against [`Self::UNSTAKED_LIQUIDITY_POOL`] and then against
    /// [`Self::TOTAL_UNSTAKED_BALANCE`]
    fn decr_total_unstaked_balance(mut amount: YoctoNear) {
        let liquidity = Self::liquidity();
        if liquidity > YoctoNear::ZERO {
            if amount <= liquidity {
                let total_liquidity =
                    ContractNearBalances::decr_balance(Self::UNSTAKED_LIQUIDITY_POOL, amount);
                LOG_EVENT_LIQUIDITY
                    .log(format!("removed={}, total={}", liquidity, total_liquidity));
                return;
            }
            amount -= liquidity;
            ContractNearBalances::clear_balance(Self::UNSTAKED_LIQUIDITY_POOL);
            LOG_EVENT_LIQUIDITY.log(format!("removed={}, total=0", liquidity));
            if amount > YoctoNear::ZERO {
                ContractNearBalances::decr_balance(Self::TOTAL_UNSTAKED_BALANCE, amount);
            }
        } else {
            ContractNearBalances::decr_balance(Self::TOTAL_UNSTAKED_BALANCE, amount);
        }
    }

    /// If there are unstaked funds awaiting withdrawal, then transfer the specified amount to the
    /// liquidity pool
    fn add_liquidity(amount: YoctoNear) {
        if amount == YoctoNear::ZERO {
            return;
        }

        let total_unstaked_balance =
            ContractNearBalances::near_balance(Self::TOTAL_UNSTAKED_BALANCE);
        if total_unstaked_balance == YoctoNear::ZERO {
            return;
        }

        let liquidity = min(amount, total_unstaked_balance);
        ContractNearBalances::decr_balance(Self::TOTAL_UNSTAKED_BALANCE, liquidity);
        let total_liquidity =
            ContractNearBalances::incr_balance(Self::UNSTAKED_LIQUIDITY_POOL, liquidity);
        LOG_EVENT_LIQUIDITY.log(format!("added={}, total={}", liquidity, total_liquidity));
    }

    pub(crate) fn liquidity() -> YoctoNear {
        ContractNearBalances::near_balance(Self::UNSTAKED_LIQUIDITY_POOL)
    }
}

impl Deploy for StakingPoolComponent {
    type Config = StakingPoolComponentConfig;

    /// default settings:
    /// - staking fee = 80 BPS (0.8%)
    /// - the staking pool is deployed as stopped, i.e., in order to start staking, the pool will
    ///   need to be explicitly started after deployment
    fn deploy(config: Self::Config) {
        // the contract account serves as the treasury account
        // we need to register an account with storage management in order to deposit STAKE into the
        // treasury
        let treasury = env::current_account_id();
        AccountManager::register_account_if_not_exists(&treasury);

        let state = State {
            stake_public_key: config.stake_public_key,
            status: Status::Offline(OfflineReason::Stopped),
            staking_fee: config.staking_fee.unwrap_or(80.into()),
            earnings_fee: config.earnings_fee.unwrap_or(0.into()),
            treasury_balance: YoctoNear::ZERO,
            last_contract_managed_total_balance: State::contract_managed_total_balance(),
        };
        let state = Self::new_state(state);
        state.save();
    }
}

#[derive(
    BorshSerialize, BorshDeserialize, Serialize, Deserialize, Debug, Clone, Copy, PartialEq,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct StakingPoolComponentConfig {
    pub stake_public_key: PublicKey,
    pub staking_fee: Option<BasisPoints>,
    pub earnings_fee: Option<BasisPoints>,
}

impl StakingPool for StakingPoolComponent {
    fn ops_stake_balance(&self, account_id: ValidAccountId) -> Option<StakeAccountBalances> {
        self.account_manager
            .storage_balance_of(account_id.clone())
            .map(|storage_balance| {
                let staked = {
                    let token_balance = self.stake_token.ft_balance_of(account_id.clone());
                    if token_balance == TokenAmount::ZERO {
                        None
                    } else {
                        Some(StakedBalance {
                            stake: token_balance,
                            near_value: self.ops_stake_token_value(Some(token_balance)),
                        })
                    }
                };

                let unstaked = self
                    .account_manager
                    .load_account_data(account_id.as_ref())
                    .map(|data| {
                        if data.unstaked_balances.total() == YoctoNear::ZERO {
                            None
                        } else {
                            Some(data.unstaked_balances.into())
                        }
                    })
                    .flatten();

                StakeAccountBalances {
                    storage_balance,
                    staked,
                    unstaked,
                }
            })
    }

    fn ops_stake(&mut self) -> PromiseOrValue<StakeAccountBalances> {
        let account_id = env::predecessor_account_id();
        let mut account = self
            .account_manager
            .registered_account_near_data(&account_id);

        self.state_with_updated_earnings();

        // stake the account's total available storage balance + attached deposit
        let (near_amount, stake_token_amount) = {
            let account_storage_available_balance = account
                .storage_balance(self.account_manager.storage_balance_bounds().min)
                .available;
            account.decr_near_balance(account_storage_available_balance);

            let near = account_storage_available_balance + env::attached_deposit();
            ERR_NEAR_DEPOSIT_REQUIRED.assert_with_message(
                || near > YoctoNear::ZERO,
                || "deposit NEAR into storage balance or attach NEAR deposit",
            );
            let (stake, remainder) = self.near_to_stake(near);
            account.incr_near_balance(remainder);
            account.save();

            (near - remainder, stake)
        };

        if near_amount == YoctoNear::ZERO {
            // INVARIANT CHECK: if `near_amount` is zero, then `stake_token_amount` should be zero
            assert_eq!(stake_token_amount, TokenAmount::ZERO);
            // NOTE: any attached deposit be deposited into the account's storage balance - this, there
            // is no need to panic
            LOG_EVENT_NOT_ENOUGH_TO_STAKE.log("");
            return self.registered_stake_account_balance(&account_id);
        }

        State::add_liquidity(near_amount);
        self.stake(&account_id, near_amount, stake_token_amount)
    }

    fn ops_unstake(&mut self, amount: Option<YoctoNear>) -> PromiseOrValue<StakeAccountBalances> {
        let account_id = env::predecessor_account_id();
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| self.account_manager.account_exists(&account_id));

        let state = self.state_with_updated_earnings();

        let stake_balance = self
            .stake_token
            .ft_balance_of(to_valid_account_id(&account_id));
        if stake_balance == TokenAmount::ZERO {
            if amount.is_none() {
                return self.registered_stake_account_balance(&account_id);
            }
            ERR_INSUFFICIENT_FUNDS.panic_with_message("STAKE balance is zero");
            unreachable!()
        }
        let stake_near_value = self.stake_near_value_rounded_down(stake_balance);
        let (near_amount, stake_token_amount) = match amount {
            None => (stake_near_value, stake_balance), // unstake all
            Some(near_amount) => {
                ERR_INSUFFICIENT_FUNDS.assert(|| stake_near_value >= near_amount);
                // we round up the number of STAKE tokens to ensure that we never overdraw from the
                // staked balance - this is more than compensated for by transaction fee earnings
                let stake_token_amount = self.near_stake_value_rounded_up(near_amount);
                ERR_STAKED_BALANCE_TOO_LOW_TO_UNSTAKE
                    .assert(|| stake_balance >= stake_token_amount);
                (near_amount, stake_token_amount)
            }
        };

        LOG_EVENT_UNSTAKE.log(format!(
            "near_amount={}, stake_token_amount={}",
            near_amount, stake_token_amount
        ));

        State::decr_total_staked_balance(near_amount);
        State::incr_total_unstaked_balance(near_amount);
        self.stake_token.ft_burn(&account_id, stake_token_amount);
        let burned_near_value = self.ops_stake_token_value(Some(stake_token_amount));
        let rounding_diff = burned_near_value.saturating_sub(*near_amount);
        self.credit_account_unstaked_balance(&account_id, near_amount + rounding_diff);

        match state.status {
            Status::Online => {
                let promise = Self::create_stake_workflow(state.stake_public_key, &account_id);
                PromiseOrValue::Promise(promise)
            }
            Status::Offline(_) => {
                LOG_EVENT_STATUS_OFFLINE.log("");
                self.registered_stake_account_balance(&account_id)
            }
        }
    }

    fn ops_restake(&mut self, amount: Option<YoctoNear>) -> PromiseOrValue<StakeAccountBalances> {
        let account_id = env::predecessor_account_id();
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| self.account_manager.account_exists(&account_id));

        self.state_with_updated_earnings();

        match self.account_manager.load_account_data(&account_id) {
            // account has no unstaked funds to restake
            None => match amount {
                None => self.registered_stake_account_balance(&account_id),
                Some(_) => {
                    ERR_INSUFFICIENT_FUNDS.panic();
                    unreachable!()
                }
            },
            Some(mut account) => {
                let (near_amount, stake_token_amount) = {
                    let near = amount.unwrap_or_else(|| account.unstaked_balances.total());
                    let (stake, remainder) = self.near_to_stake(near);
                    let stake_near_value = near - remainder;
                    account
                        .unstaked_balances
                        .debit_for_restaking(stake_near_value);
                    account.save();
                    State::decr_total_unstaked_balance(stake_near_value);
                    (stake_near_value, stake)
                };
                // NOTE: restaking does not add liquidity because no new funds are being deposited
                self.stake(&account_id, near_amount, stake_token_amount)
            }
        }
    }

    fn ops_stake_withdraw(&mut self, amount: Option<YoctoNear>) -> StakeAccountBalances {
        let account_id = env::predecessor_account_id();
        ERR_ACCOUNT_NOT_REGISTERED.assert(|| self.account_manager.account_exists(&account_id));

        fn debit_available_balance(
            mut unstaked_balances: AccountDataObject<StakeAccountData>,
            amount: YoctoNear,
        ) {
            unstaked_balances
                .unstaked_balances
                .debit_available_balance(amount);
            if unstaked_balances.unstaked_balances.total() == YoctoNear::ZERO {
                unstaked_balances.delete();
            } else {
                unstaked_balances.save();
            }
            State::decr_total_unstaked_balance(amount);
            // debit contract managed total balance
            {
                let mut state = StakingPoolComponent::state();
                state.last_contract_managed_total_balance -= amount;
                state.save();
            }

            Promise::new(env::predecessor_account_id()).transfer(*amount);
        }

        // earnings are updated to ensure updated balances are returned
        self.state_with_updated_earnings();

        match amount {
            // withdraw all available
            None => {
                if let Some(mut account_staked_data) =
                    self.account_manager.load_account_data(&account_id)
                {
                    account_staked_data.unstaked_balances.apply_liquidity();
                    let amount = account_staked_data.unstaked_balances.available();
                    if amount > YoctoNear::ZERO {
                        debit_available_balance(account_staked_data, amount);
                    }
                }
            }
            // withdraw specified amount
            Some(amount) => {
                ERR_INVALID.assert(|| amount > YoctoNear::ZERO, || "amount must be > 0");
                match self.account_manager.load_account_data(&account_id) {
                    Some(mut unstaked_balances) => {
                        unstaked_balances.unstaked_balances.apply_liquidity();
                        debit_available_balance(unstaked_balances, amount);
                    }
                    None => ERR_INSUFFICIENT_FUNDS.panic(),
                }
            }
        }

        self.ops_stake_balance(to_valid_account_id(&account_id))
            .unwrap()
    }

    fn ops_stake_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        amount: YoctoNear,
        memo: Option<Memo>,
    ) -> TokenAmount {
        self.state_with_updated_earnings();
        let stake_value = self.near_stake_value_rounded_up(amount);
        self.stake_token.ft_transfer(receiver_id, stake_value, memo);
        stake_value
    }

    fn ops_stake_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: YoctoNear,
        memo: Option<Memo>,
        msg: TransferCallMessage,
    ) -> Promise {
        self.state_with_updated_earnings();
        let stake_value = self.near_stake_value_rounded_up(amount);
        self.stake_token
            .ft_transfer_call(receiver_id, stake_value, memo, msg)
    }

    fn ops_stake_token_value(&self, amount: Option<TokenAmount>) -> YoctoNear {
        self.compute_stake_near_value_rounded_down(
            amount.unwrap_or(YOCTO.into()),
            State::total_staked_balance() + Self::state().check_for_earnings_in_view_mode(),
        )
    }

    fn ops_stake_token_value_with_earnings(&mut self, amount: Option<TokenAmount>) -> YoctoNear {
        self.state_with_updated_earnings();
        self.stake_near_value_rounded_down(amount.unwrap_or(YOCTO.into()))
    }

    fn ops_stake_status(&self) -> Status {
        Self::state().status
    }

    fn ops_stake_pool_balances(&self) -> StakingPoolBalances {
        StakingPoolBalances::new(
            *StakingPoolComponent::state(),
            self.stake_token.ft_total_supply(),
        )
    }

    fn ops_stake_fees(&self) -> Fees {
        let state = Self::state();
        Fees {
            staking_fee: state.staking_fee,
            earnings_fee: state.earnings_fee,
        }
    }

    fn ops_stake_public_key(&self) -> PublicKey {
        Self::state().stake_public_key
    }
}

impl NearStakingPool for StakingPoolComponent {
    fn get_account_staked_balance(&self, account_id: ValidAccountId) -> YoctoNear {
        self.ops_stake_balance(account_id)
            .map_or(YoctoNear::ZERO, |balance| {
                balance
                    .staked
                    .map_or(YoctoNear::ZERO, |balance| balance.near_value)
            })
    }

    fn get_account_unstaked_balance(&self, account_id: ValidAccountId) -> YoctoNear {
        self.ops_stake_balance(account_id)
            .map_or(YoctoNear::ZERO, |balance| {
                let unstaked = balance
                    .unstaked
                    .map_or(YoctoNear::ZERO, |balance| balance.total);
                unstaked + balance.storage_balance.available
            })
    }

    fn is_account_unstaked_balance_available(&self, account_id: ValidAccountId) -> bool {
        self.ops_stake_balance(account_id).map_or(true, |balance| {
            balance
                .unstaked
                .map_or(true, |balance| balance.total == balance.available)
        })
    }

    fn get_account_total_balance(&self, account_id: ValidAccountId) -> YoctoNear {
        self.ops_stake_balance(account_id)
            .map_or(YoctoNear::ZERO, |balance| {
                let staked = balance
                    .staked
                    .map_or(YoctoNear::ZERO, |balance| balance.near_value);
                let unstaked = balance
                    .unstaked
                    .map_or(YoctoNear::ZERO, |balance| balance.total);
                staked + unstaked + balance.storage_balance.available
            })
    }

    fn get_account(&self, account_id: ValidAccountId) -> NearStakingPoolAccount {
        self.ops_stake_balance(account_id.clone()).map_or(
            NearStakingPoolAccount {
                account_id: account_id.as_ref().to_string(),
                unstaked_balance: YoctoNear::ZERO,
                staked_balance: YoctoNear::ZERO,
                can_withdraw: true,
            },
            |balance| NearStakingPoolAccount {
                account_id: account_id.as_ref().to_string(),
                unstaked_balance: balance
                    .unstaked
                    .as_ref()
                    .map_or(YoctoNear::ZERO, |balance| balance.total)
                    + balance.storage_balance.available,
                staked_balance: balance
                    .staked
                    .map_or(YoctoNear::ZERO, |balance| balance.near_value),
                can_withdraw: balance
                    .unstaked
                    .map_or(true, |balance| balance.total == balance.available),
            },
        )
    }

    fn deposit(&mut self) {
        self.account_manager.storage_deposit(None, None);
    }

    fn deposit_and_stake(&mut self) {
        self.ops_stake();
    }

    fn withdraw(&mut self, amount: YoctoNear) {
        self.ops_stake_withdraw(Some(amount));
    }

    fn withdraw_all(&mut self) {
        self.ops_stake_withdraw(None);
    }

    fn stake(&mut self, amount: YoctoNear) {
        ERR_INVALID.assert(|| amount > YoctoNear::ZERO, || "amount must be > 0");
        let (mut near_account, account_data) = self
            .account_manager
            .registered_account(&env::predecessor_account_id());
        match account_data {
            Some(mut data) => {
                if data.unstaked_balances.total() < amount {
                    ERR_INSUFFICIENT_FUNDS.assert(|| {
                        data.unstaked_balances.total()
                            + near_account
                                .storage_balance(self.account_manager.storage_balance_bounds().min)
                                .available
                            >= amount
                    });

                    let storage_balance = amount - data.unstaked_balances.total();
                    near_account.decr_near_balance(storage_balance);
                    near_account.save();

                    data.unstaked_balances.credit_unstaked(storage_balance);
                    data.save();
                    State::incr_total_unstaked_balance(storage_balance);
                }
            }
            None => {
                ERR_INSUFFICIENT_FUNDS.assert(|| {
                    near_account
                        .storage_balance(self.account_manager.storage_balance_bounds().min)
                        .available
                        >= amount
                });

                near_account.decr_near_balance(amount);
                near_account.save();

                self.credit_account_unstaked_balance(&env::predecessor_account_id(), amount);
                State::incr_total_unstaked_balance(amount);
            }
        }
        self.ops_restake(Some(amount));
    }

    fn unstake(&mut self, amount: YoctoNear) {
        self.ops_unstake(Some(amount));
    }

    fn unstake_all(&mut self) {
        self.ops_unstake(None);
    }
}

impl StakingPoolOperator for StakingPoolComponent {
    fn ops_stake_operator_command(&mut self, command: StakingPoolOperatorCommand) {
        self.account_manager.assert_operator();

        match command {
            StakingPoolOperatorCommand::StopStaking => Self::stop_staking(OfflineReason::Stopped),
            StakingPoolOperatorCommand::StartStaking => self.start_staking(),
            StakingPoolOperatorCommand::UpdatePublicKey(public_key) => {
                Self::update_public_key(public_key)
            }
            StakingPoolOperatorCommand::UpdateFees(fees) => Self::update_staking_fees(fees),
        }
    }
}

impl StakingPoolComponent {
    /// we always try to stop, even if the pool is already offline
    /// - for example, if the staking public key is invalid, then the stake action would fail
    fn stop_staking(reason: OfflineReason) {
        if let OfflineReason::StakeActionFailed = reason {
            ERR_STAKE_ACTION_FAILED.log("");
        }

        // update status to offline
        let mut state = Self::state();
        if state.status.is_online() {
            state.status = Status::Offline(reason);
            state.save();
            LOG_EVENT_STATUS_OFFLINE.log(reason);
        } else {
            LOG_EVENT_STATUS_OFFLINE.log(format!("{} - but was already offline", reason));
        }

        // unstake all
        if env::account_locked_balance() > 0 {
            Promise::new(env::current_account_id())
                .stake(0, state.stake_public_key.into())
                .then(json_function_callback(
                    "ops_stake_stop_finalize",
                    Option::<()>::None,
                    YoctoNear::ZERO,
                    Self::compute_callback_gas(
                        Gas(5 * TERA),
                        Self::staking_workflow_receipts_gas(),
                    ),
                ));
        }
    }

    fn start_staking(&mut self) {
        let mut state = self.state_with_updated_earnings();
        if let Status::Offline(_) = state.status {
            // update status
            state.status = Status::Online;
            state.save();

            LOG_EVENT_STATUS_ONLINE.log("");

            // stake
            let total_staked_balance = State::total_staked_balance();
            if total_staked_balance > YoctoNear::ZERO {
                Promise::new(env::current_account_id())
                    .stake(*total_staked_balance, state.stake_public_key.into())
                    .then(json_function_callback(
                        "ops_stake_start_finalize",
                        Option::<()>::None,
                        YoctoNear::ZERO,
                        Self::callback_gas_with_check_for_enough_gas(),
                    ));
            }
        } else {
            LOG_EVENT_STATUS_ONLINE.log("already online");
        }
    }

    fn update_public_key(public_key: PublicKey) {
        let mut state = Self::state();
        ERR_ILLEGAL_STATE.assert(
            || !state.status.is_online(),
            || "staking pool must be offline to update the staking public key",
        );
        state.stake_public_key = public_key;
        state.save();
    }

    fn update_staking_fees(fees: Fees) {
        ERR_INVALID.assert(
            || fees.staking_fee <= MAX_FEE,
            || "max staking fee is 1000 BPS (10%)",
        );
        ERR_INVALID.assert(
            || fees.earnings_fee <= MAX_FEE,
            || "max earnings fee is 1000 BPS (10%)",
        );
        ERR_INVALID.assert(
            || *fees.staking_fee > 0 || *fees.earnings_fee > 0,
            || "min fee is 1 BPS (0.01%) for at least 1 fee type",
        );
        let mut state = Self::state();
        state.staking_fee = fees.staking_fee;
        state.earnings_fee = fees.earnings_fee;
        state.save();
    }
}

impl StakeActionCallbacks for StakingPoolComponent {
    fn ops_stake_finalize(&mut self, account_id: AccountId) -> StakeAccountBalances {
        // we get the balance here first because if the stake action fails, then we want to minimize
        // the amount of work done after the promise workflow is created to stop staking because
        // the gas supplied to the callback takes the rest of the gas minus 5 TGas to compete this call
        let balance = self
            .ops_stake_balance(to_valid_account_id(&account_id))
            .unwrap();

        if Self::state().status.is_online() && !is_promise_success() {
            Self::stop_staking(OfflineReason::StakeActionFailed);
        }

        balance
    }

    fn ops_stake_start_finalize(&mut self) {
        if is_promise_success() {
            LOG_EVENT_STATUS_ONLINE.log("staked");
        } else {
            Self::stop_staking(OfflineReason::StakeActionFailed);
        }
    }

    fn ops_stake_stop_finalize(&mut self) {
        if is_promise_success() {
            LOG_EVENT_STATUS_OFFLINE.log("all NEAR has been unstaked");
        } else {
            ERR_STAKE_ACTION_FAILED.log("failed to unstake when trying to stop staking pool");
        }
    }
}

impl Treasury for StakingPoolComponent {
    fn ops_stake_treasury_deposit(&mut self) -> PromiseOrValue<StakeAccountBalances> {
        let deposit = YoctoNear::from(env::attached_deposit());
        ERR_NEAR_DEPOSIT_REQUIRED.assert(|| deposit > YoctoNear::ZERO);

        let mut state = self.state_with_updated_earnings();
        let stake = self.near_stake_value_rounded_down(deposit);
        state.treasury_balance += deposit;
        state.save();

        State::add_liquidity(deposit);
        self.stake(&env::current_account_id(), deposit, stake)
    }

    fn ops_stake_treasury_distribution(&mut self) {
        let deposit = YoctoNear::from(env::attached_deposit());
        let total_staked_balance_before_earnings = State::total_staked_balance();
        let state = self.state_with_updated_earnings();
        if deposit > YoctoNear::ZERO {
            State::add_liquidity(deposit);
            self.stake(&env::current_account_id(), deposit, TokenAmount::ZERO);
        } else if state.status.is_online() {
            if State::total_staked_balance() > total_staked_balance_before_earnings {
                Self::create_stake_workflow(state.stake_public_key, &env::current_account_id());
            }
        }
    }

    fn ops_stake_treasury_transfer_to_owner(&mut self, amount: Option<YoctoNear>) {
        let owner_account_id = ContractOwnershipComponent.ops_owner();
        ERR_NOT_AUTHORIZED.assert(|| {
            let account_id = env::predecessor_account_id();
            if owner_account_id == account_id {
                return true;
            }
            let account = self
                .account_manager
                .registered_account_near_data(&account_id);
            account.contains_permissions(self.treasurer_permission().into())
        });

        AccountManager::register_account_if_not_exists(&owner_account_id);

        let mut state = self.state_with_updated_earnings();

        let treasury_account = env::current_account_id();
        let (amount, stake) = {
            let treasury_balance = self
                .stake_token
                .ft_balance_of(to_valid_account_id(&treasury_account));
            if treasury_balance == TokenAmount::ZERO {
                return;
            }

            let treasury_near_balance = self.stake_near_value_rounded_down(treasury_balance);
            let amount = match amount {
                None => treasury_near_balance,
                Some(amount) => {
                    ERR_INSUFFICIENT_FUNDS.assert(|| treasury_near_balance >= amount);
                    amount
                }
            };
            let stake = self.near_stake_value_rounded_up(amount);
            (amount, min(treasury_balance, stake))
        };

        // transfer STAKE from treasury to owner account
        {
            self.stake_token.ft_burn(&treasury_account, stake);
            self.stake_token.ft_mint(&owner_account_id, stake);
        }

        // debit from the treasury balance
        {
            state.treasury_balance -= amount;
            state.save();
        }
    }

    fn ops_stake_grant_treasurer(&mut self, account_id: ValidAccountId) {
        self.account_manager
            .ops_permissions_grant(account_id, self.treasurer_permission().into());
    }

    fn ops_stake_revoke_treasurer(&mut self, account_id: ValidAccountId) {
        self.account_manager
            .ops_permissions_revoke(account_id, self.treasurer_permission().into());
    }

    fn ops_stake_is_treasurer(&mut self, account_id: ValidAccountId) -> bool {
        self.account_manager
            .load_account_near_data(account_id.as_ref())
            .map_or(false, |account| {
                account.contains_permissions(self.treasurer_permission().into())
            })
    }
}

impl TransferReceiver for StakingPoolComponent {
    /// updates the treasury balance
    ///
    /// ## Panics
    /// If not called as self, i.e., by the STAKE pool contract
    fn ft_on_transfer(
        &mut self,
        _sender_id: ValidAccountId,
        _amount: TokenAmount,
        _msg: TransferCallMessage,
    ) -> PromiseOrValue<TokenAmount> {
        ERR_NOT_AUTHORIZED.assert_with_message(
            || env::predecessor_account_id() == env::current_account_id(),
            || "this method can only be invoked by the STAKE pool contract internally",
        );
        let mut state = self.state_with_updated_earnings();
        let treasury_stake_balance = self
            .stake_token
            .ft_balance_of(to_valid_account_id(&env::current_account_id()));
        state.treasury_balance = self.stake_near_value_rounded_down(treasury_stake_balance);
        state.save();
        LOG_EVENT_TREASURY_DEPOSIT.log(format!("treasury balance = {}", state.treasury_balance));
        PromiseOrValue::Value(TokenAmount::ZERO)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
struct StakeActionCallbackArgs {
    account_id: AccountId,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
struct ResumeFinalizeCallbackArgs {
    pub total_staked_balance: YoctoNear,
}

// staking related methods
impl StakingPoolComponent {
    /// Stakes the NEAR and mints the corresponding STAKE for the account
    ///
    /// ## Args
    /// - `near_amount` - new funds that are being staked
    /// - `stake_token_amount` - the amount of tokens that will be minted
    fn stake(
        &mut self,
        account_id: &str,
        near_amount: YoctoNear,
        stake_token_amount: TokenAmount,
    ) -> PromiseOrValue<StakeAccountBalances> {
        if near_amount == YoctoNear::ZERO {
            // INVARIANT CHECK: if `near_amount` is zero, then `stake_token_amount` should be zero
            assert_eq!(stake_token_amount, TokenAmount::ZERO);
            // NOTE: any attached deposit be deposited into the account's storage balance - this, there
            // is no need to panic
            LOG_EVENT_NOT_ENOUGH_TO_STAKE.log("");
            return self.registered_stake_account_balance(account_id);
        }

        LOG_EVENT_STAKE.log(format!(
            "near_amount={}, stake_token_amount={}",
            near_amount, stake_token_amount
        ));

        let state =
            self.process_stake_transaction_finances(account_id, near_amount, stake_token_amount);

        match state.status {
            Status::Online => PromiseOrValue::Promise(Self::create_stake_workflow(
                state.stake_public_key,
                account_id,
            )),
            Status::Offline(_) => {
                LOG_EVENT_STATUS_OFFLINE.log("");
                self.registered_stake_account_balance(account_id)
            }
        }
    }
}

impl StakingPoolComponent {
    /// invokes `Self::compute_callback_gas`, but also checks that enough gas is attached for the
    /// callback
    fn callback_gas_with_check_for_enough_gas() -> Gas {
        let staking_workflow_receipts_gas = Self::staking_workflow_receipts_gas();
        let gas: Gas = Self::compute_callback_gas(Gas(5 * TERA), staking_workflow_receipts_gas);

        // make sure there is enough gas for the callback
        // - because of NEAR's async nature, if there is not enough gas, then this transaction will
        //   commit its state, but the callback will fail - thus its better to fail fast and let
        //   the user know to retry with more gas
        const CALLBACK_COMPUTE_GAS: TGas = TGas(10);
        let min_callback_gas = staking_workflow_receipts_gas + CALLBACK_COMPUTE_GAS;
        ERR_INVALID.assert(
            || gas >= min_callback_gas,
            || {
                let min_required_gas = env::used_gas()
                    + *staking_workflow_receipts_gas
                    + *TGas(5) // gas required to complete this call
                    + *min_callback_gas;
                format!(
                    "not enough gas was attached - min required gas is {} TGas",
                    min_required_gas / TERA + 1 // round up 1 TGas
                )
            },
        );

        gas
    }

    /// computes how much gas will be required to complete this call given the remaining compute
    /// and receipts this call will create
    ///
    /// ## Args
    /// `gas_for_remaining_compute` - how much compute gas is needed for the remaining work in this call
    /// `gas_for_receipts` - how much gas is required to create any remaining receipts
    fn compute_callback_gas(gas_for_remaining_compute: Gas, gas_for_receipts: Gas) -> Gas {
        (env::prepaid_gas() - env::used_gas() - *gas_for_receipts - *gas_for_remaining_compute)
            .into()
    }

    fn staking_workflow_receipts_gas() -> Gas {
        const RECEIPT: TransactionResource =
            TransactionResource::ActionReceipt(SenderIsReceiver(true));
        const STAKE_ACTION: TransactionResource =
            TransactionResource::Action(ActionType::Stake(SenderIsReceiver(true)));
        const FUNC_CALL: TransactionResource = TransactionResource::Action(
            ActionType::FunctionCall(SenderIsReceiver(true), ByteLen(512)),
        );
        const DATA_RECEIPT: TransactionResource =
            TransactionResource::DataReceipt(SenderIsReceiver(true), ByteLen(200));
        Gas::compute(vec![
            (RECEIPT, 2), // stake action + callback
            (STAKE_ACTION, 1),
            (FUNC_CALL, 1),
            (DATA_RECEIPT, 1),
        ])
    }

    fn treasurer_permission(&self) -> Permission {
        self.account_manager
            .permission_by_name(PERMISSION_TREASURER)
            .unwrap()
    }

    fn treasury_stake_balance(&self) -> (TokenAmount, YoctoNear) {
        let treasury_stake_balance = self
            .stake_token
            .ft_balance_of(to_valid_account_id(&env::current_account_id()));
        let treasury_near_value = self.stake_near_value_rounded_down(treasury_stake_balance);
        (treasury_stake_balance, treasury_near_value)
    }

    /// - credit total staked balance and contract managed total balance with the staked amount
    /// - mints STAKE on the account for amount staked
    /// - collects staking fee
    ///
    /// Returns the updated state after saving it to storage.
    fn process_stake_transaction_finances(
        &mut self,
        account_id: &str,
        amount: YoctoNear,
        stake_token_amount: TokenAmount,
    ) -> ComponentState<State> {
        let mut state = Self::state();
        State::incr_total_staked_balance(amount);
        state.last_contract_managed_total_balance += amount;

        // stake_token_amount will be ZERO if this is a funds distribution
        // - see [`Treasury::ops_stake_treasury_distribution`]
        if stake_token_amount > TokenAmount::ZERO {
            self.stake_token.ft_mint(&account_id, stake_token_amount);
        }

        // collect staking fee - treasury and owner accounts do not get charged staking fees
        let owner_id = ContractOwnershipComponent.ops_owner();
        if stake_token_amount > TokenAmount::ZERO
            && state.staking_fee > BasisPoints::ZERO
            && account_id != &env::current_account_id()
            && account_id != &owner_id
        {
            let staking_fee = self.near_stake_value_rounded_down(amount * state.staking_fee);
            if staking_fee > TokenAmount::ZERO {
                self.stake_token.ft_burn(&account_id, staking_fee);
                self.stake_token.ft_mint(&owner_id, staking_fee);
            }
        }

        state.save();
        state
    }

    fn registered_stake_account_balance(
        &self,
        account_id: &str,
    ) -> PromiseOrValue<StakeAccountBalances> {
        PromiseOrValue::Value(
            self.ops_stake_balance(to_valid_account_id(account_id))
                .unwrap(),
        )
    }

    pub(crate) fn state() -> ComponentState<State> {
        Self::load_state().expect("component has not been deployed")
    }

    pub(crate) fn state_with_updated_earnings(&mut self) -> ComponentState<State> {
        /// returns the current treasury balance after paying the dividend - which means the treasury
        /// NEAR value still increases overtime because after paying the dividend, STAKE value goes up
        /// and the new treasury balance is based on the new STAKE value
        fn pay_treasury_dividend(
            this: &mut StakingPoolComponent,
            treasury_balance: YoctoNear,
        ) -> YoctoNear {
            let (treasury_stake_balance, current_treasury_near_value) =
                this.treasury_stake_balance();
            if treasury_balance == YoctoNear::ZERO {
                // then this seeds the treasury balance
                return current_treasury_near_value;
            }

            let treasury_staking_earnings = current_treasury_near_value
                .saturating_sub(*treasury_balance)
                .into();
            let treasury_staking_earnings_stake_value =
                this.near_stake_value_rounded_down(treasury_staking_earnings);
            if treasury_staking_earnings_stake_value == TokenAmount::ZERO {
                return current_treasury_near_value;
            }

            this.stake_token.ft_burn(
                &env::current_account_id(),
                treasury_staking_earnings_stake_value,
            );
            LOG_EVENT_TREASURY_DIVIDEND.log(format!(
                "{} yoctoNEAR / {} yoctoSTAKE",
                treasury_staking_earnings, treasury_staking_earnings_stake_value
            ));
            this.stake_near_value_rounded_down(
                treasury_stake_balance - treasury_staking_earnings_stake_value,
            )
        }

        let mut state = Self::state();

        // If there are no stakers,i.e., STAKE total supply is zero, then earnings will not be
        // staked in this staking transaction - earnings will be staked in the next transaction.
        // - the reason we do this is because when computing token values, a zero token supply
        //   effectively resets the token value 1:1 for STAKE:NEAR
        if self.stake_token.ft_total_supply() == TokenAmount::ZERO {
            return state;
        }

        let contract_managed_total_balance = State::contract_managed_total_balance();
        let earnings: YoctoNear = contract_managed_total_balance
            .saturating_sub(*state.last_contract_managed_total_balance)
            .into();
        let owner_earnings = if earnings > YoctoNear::ZERO {
            LOG_EVENT_EARNINGS.log(earnings);

            if state.earnings_fee > BasisPoints::ZERO {
                let owner_earnings = state.earnings_fee * earnings;
                // distributes earnings minus owner earnings
                State::incr_total_staked_balance(earnings - owner_earnings);
                owner_earnings
            } else {
                State::incr_total_staked_balance(earnings);
                YoctoNear::ZERO
            }
        } else {
            YoctoNear::ZERO
        };

        state.last_contract_managed_total_balance = contract_managed_total_balance;
        state.treasury_balance = pay_treasury_dividend(self, state.treasury_balance);

        // mint owner earnings only after rest of earnings are first distributed
        if owner_earnings > YoctoNear::ZERO {
            // NOTE: because of rounding down, there might be some earnings that can't be converted
            // into STAKE, which will end up being distributed into the pool
            let owner_stake_earnings = self.near_stake_value_rounded_down(owner_earnings);
            if owner_stake_earnings > TokenAmount::ZERO {
                let owner_id = ContractOwnershipComponent.ops_owner();
                self.stake_token.ft_mint(&owner_id, owner_stake_earnings);
            }
            State::incr_total_staked_balance(owner_earnings);
        }

        state.save();
        state
    }

    fn credit_account_unstaked_balance(&self, account_id: &str, amount: YoctoNear) {
        let mut account = self.account_manager.registered_account_data(&account_id);
        account.unstaked_balances.credit_unstaked(amount);
        account.save();
    }

    fn create_stake_workflow(stake_public_key: PublicKey, account_id: &str) -> Promise {
        let stake = Promise::new(env::current_account_id())
            .stake(*State::total_staked_balance(), stake_public_key.into());
        let finalize = json_function_callback(
            "ops_stake_finalize",
            Some(StakeActionCallbackArgs {
                account_id: account_id.to_string(),
            }),
            YoctoNear::ZERO,
            Self::callback_gas_with_check_for_enough_gas(),
        );
        stake.then(finalize)
    }

    fn stake_near_value_rounded_down(&self, stake: TokenAmount) -> YoctoNear {
        self.compute_stake_near_value_rounded_down(stake, State::total_staked_balance())
    }

    fn compute_stake_near_value_rounded_down(
        &self,
        stake: TokenAmount,
        total_staked_near_balance: YoctoNear,
    ) -> YoctoNear {
        if *stake == 0 {
            return YoctoNear::ZERO;
        }

        let ft_total_supply = *self.stake_token.ft_total_supply();
        if ft_total_supply == 0 {
            return (*stake).into();
        }

        (U256::from(*total_staked_near_balance) * U256::from(*stake) / U256::from(ft_total_supply))
            .as_u128()
            .into()
    }

    /// converts the specified NEAR amount to STAKE and returns the STAKE equivalent and any NEAR
    /// remainder that could not be converted into STAKE because of rounding
    ///
    /// ## Notes
    /// because of rounding down we need to convert the STAKE value back to NEAR, which ensures that
    /// the account will not be short changed when they unstake
    fn near_to_stake(&self, amount: YoctoNear) -> (TokenAmount, YoctoNear) {
        let stake = self.near_stake_value_rounded_down(amount);
        let stake_near_value = self.stake_near_value_rounded_down(stake);
        (stake, amount - stake_near_value)
    }

    fn near_stake_value_rounded_down(&self, amount: YoctoNear) -> TokenAmount {
        if amount == YoctoNear::ZERO {
            return TokenAmount::ZERO;
        }

        let ft_total_supply = *self.stake_token.ft_total_supply();
        if ft_total_supply == 0 {
            return (*amount).into();
        }

        let total_staked_balance = *State::total_staked_balance();

        (U256::from(ft_total_supply) * U256::from(*amount) / U256::from(total_staked_balance))
            .as_u128()
            .into()
    }

    fn near_stake_value_rounded_up(&self, amount: YoctoNear) -> TokenAmount {
        if amount == YoctoNear::ZERO {
            return TokenAmount::ZERO;
        }

        let ft_total_supply = *self.stake_token.ft_total_supply();
        if ft_total_supply == 0 {
            return amount.value().into();
        }

        let total_staked_balance = *State::total_staked_balance();

        ((U256::from(ft_total_supply) * U256::from(*amount) + U256::from(total_staked_balance - 1))
            / U256::from(total_staked_balance))
        .as_u128()
        .into()
    }
}

#[cfg(test)]
mod tests_staking_pool {
    use super::*;
    use crate::*;
    use oysterpack_smart_account_management::{
        components::account_management::{
            AccountManagementComponent, AccountManagementComponentConfig,
        },
        ContractPermissions,
    };
    use oysterpack_smart_contract::{
        components::contract_operator::ContractOperatorComponent, ContractOperator,
    };
    use oysterpack_smart_fungible_token::components::fungible_token::FungibleTokenConfig;
    use oysterpack_smart_fungible_token::{
        components::fungible_token::FungibleTokenComponent, FungibleToken, Metadata, Name, Spec,
        Symbol, FT_METADATA_SPEC,
    };
    use oysterpack_smart_near::{
        component::*,
        near_sdk::{env, serde_json, test_utils},
        *,
    };
    use oysterpack_smart_near_test::*;
    use std::collections::HashMap;
    use std::convert::*;

    pub type AccountManager = AccountManagementComponent<StakeAccountData>;

    pub type StakeFungibleToken = FungibleTokenComponent<StakeAccountData>;

    const OWNER: &str = "owner";
    const ACCOUNT: &str = "bob";

    pub fn deploy_stake_contract(stake_public_key: PublicKey) {
        let owner = to_valid_account_id(&env::predecessor_account_id());
        ContractOwnershipComponent::deploy(owner.clone());

        AccountManager::deploy(AccountManagementComponentConfig {
            storage_usage_bounds: None,
            admin_account: owner.clone(),
            component_account_storage_mins: Some(vec![StakeFungibleToken::account_storage_min]),
        });

        // transfer any contract balance to the owner - minus the contract operational balance
        {
            contract_operator().ops_operator_lock_storage_balance(10000.into());
            let account_manager = account_manager();
            let mut owner_account = account_manager.registered_account_near_data(owner.as_ref());
            owner_account
                .incr_near_balance(ContractOwnershipComponent.ops_owner_balance().available);
            owner_account.save();
        }

        StakeFungibleToken::deploy(FungibleTokenConfig {
            metadata: Metadata {
                spec: Spec(FT_METADATA_SPEC.to_string()),
                name: Name("STAKE".to_string()),
                symbol: Symbol("STAKE".to_string()),
                decimals: 24,
                icon: None,
                reference: None,
                reference_hash: None,
            },
            token_supply: 0,
        });

        StakingPoolComponent::deploy(StakingPoolComponentConfig {
            stake_public_key,
            staking_fee: None,
            earnings_fee: None,
        });

        println!("STAKE contract has been deployed");
    }

    fn account_manager() -> AccountManager {
        StakeFungibleToken::register_storage_management_event_handler();

        let contract_permissions = {
            let mut permissions = HashMap::with_capacity(1);
            permissions.insert(0, PERMISSION_TREASURER);
            ContractPermissions(permissions)
        };

        AccountManager::new(contract_permissions)
    }

    fn ft_stake() -> StakeFungibleToken {
        StakeFungibleToken::new(account_manager())
    }

    fn contract_operator() -> ContractOperatorComponent<StakeAccountData> {
        ContractOperatorComponent::new(account_manager())
    }

    fn staking_pool() -> StakingPoolComponent {
        StakingPoolComponent::new(account_manager(), ft_stake())
    }

    fn staking_public_key() -> PublicKey {
        serde_json::from_str("\"ed25519:GTi3gtSio5ZYYKTT8WVovqJEob6KqdmkTi8KqGSfwqdm\"").unwrap()
    }

    fn log_contract_managed_total_balance(msg: &str) {
        let total_contract_balance: YoctoNear =
            (env::account_balance() + env::account_locked_balance() - env::attached_deposit())
                .into();
        println!(
            r#"### contract_managed_total_balance - {}
env::account_balance()                          {}
env::account_locked_balance()                   {}
env::attached_deposit()                         {}
AccountMetrics::load().total_near_balance       {}      
--------------------------------------------------
contract_managed_total_balance                  {}
last_contract_managed_total_balance             {}
**************************************************"#,
            msg,
            env::account_balance(),
            env::account_locked_balance(),
            env::attached_deposit(),
            AccountMetrics::load().total_near_balance,
            total_contract_balance - AccountMetrics::load().total_near_balance,
            StakingPoolComponent::state().last_contract_managed_total_balance,
        );
    }

    #[cfg(test)]
    mod tests_offline {
        use super::*;

        #[cfg(test)]
        mod tests_stake {
            use super::*;

            #[test]
            fn earnings_received_through_account_balance_increase_with_zero_total_stake_supply() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                let ft_stake = ft_stake();

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // simulate earnings received by increasing account balance
                const EARNINGS: YoctoNear = YoctoNear(YOCTO);
                ctx.account_balance = env::account_balance() + *EARNINGS;
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());

                // even there are earnings that have accumulated, because there are no stakers, then
                // we expect the STAKE token value to be 1:1
                assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());
                // Act
                let balances = if let PromiseOrValue::Value(balances) = staking_pool.ops_stake() {
                    balances
                } else {
                    panic!("expected value")
                };
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: bob, amount: 1000000000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 8000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: owner, amount: 8000000000000000000000",
                    "[WARN] [STATUS_OFFLINE] ",
                ]);
                println!("{}", serde_json::to_string_pretty(&balances).unwrap());
                assert_eq!(
                    *balances.staked.as_ref().unwrap().stake,
                    992000000000000000000000
                );
                // when FT total supply is zero, then earnings are held and not staked
                // earnings will be staked on the next staking action
                assert_eq!(
                    *balances.staked.as_ref().unwrap().near_value,
                    1984000000000000000000000
                );
                // STAKE token value is 2 NEAR because of the earnings that have not yet been staked
                assert_eq!(staking_pool.ops_stake_token_value(None), (2 * YOCTO).into());
                assert_eq!(ft_stake.ft_total_supply(), YOCTO.into());
                println!(
                    "owner stake balances = {}",
                    serde_json::to_string_pretty(
                        &staking_pool.ops_stake_balance(to_valid_account_id(OWNER))
                    )
                    .unwrap()
                );
                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                ctx.account_balance = env::account_balance() + *EARNINGS;
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                assert_eq!(staking_pool.ops_stake_token_value(None), (3 * YOCTO).into());

                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                // Act - simulate more earnings on next stake
                let balances = if let PromiseOrValue::Value(balances) = staking_pool.ops_stake() {
                    balances
                } else {
                    panic!("expected Value")
                };

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [EARNINGS] 2000000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1))",
                    "[INFO] [STAKE] near_amount=999999999999999999999999, stake_token_amount=333333333333333333333333",
                    "[INFO] [FT_MINT] account: bob, amount: 333333333333333333333333",
                    "[INFO] [FT_BURN] account: bob, amount: 2666666666666666666666",
                    "[INFO] [FT_MINT] account: owner, amount: 2666666666666666666666",
                    "[WARN] [STATUS_OFFLINE] ",
                ]);

                {
                    println!(
                        "account {}",
                        serde_json::to_string_pretty(&balances).unwrap()
                    );

                    assert_eq!(
                        *balances.staked.as_ref().unwrap().stake,
                        1322666666666666666666667
                    );
                    assert_eq!(
                        *balances.staked.as_ref().unwrap().near_value,
                        3968000000000000000000001
                    );
                }

                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());

                // Assert - account STAKE NEAR balances sum up to the total staked balance
                {
                    let owner_stake_balances = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    println!(
                        "owner_stake_balances {}",
                        serde_json::to_string_pretty(&owner_stake_balances).unwrap()
                    );
                    let stake_pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "stake_pool_balances {}",
                        serde_json::to_string_pretty(&stake_pool_balances).unwrap()
                    );
                    assert_eq!(
                        stake_pool_balances.total_staked,
                        balances.staked.as_ref().unwrap().near_value
                            + owner_stake_balances.staked.as_ref().unwrap().near_value
                    );
                }

                {
                    let stake_token_value = staking_pool.ops_stake_token_value(None);
                    println!("stake_token_value = {}", stake_token_value);
                    let stake_total_supply = ft_stake.ft_total_supply();
                    println!("ft_total_supply = {}", stake_total_supply);
                    let owner_stake_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    println!(
                        "owner stake balances = {}",
                        serde_json::to_string_pretty(&owner_stake_balance).unwrap()
                    );
                    let stake_pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&stake_pool_balances).unwrap()
                    );
                    // since all earnings are staked, then the total STAKE supply value should match
                    // the total staked balance
                    assert_eq!(
                        staking_pool.ops_stake_token_value(Some(stake_total_supply)),
                        stake_pool_balances.total_staked,
                    );
                }

                {
                    ctx.account_balance = env::account_balance();
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = 0;
                    ctx.is_view = true;
                    testing_env!(ctx.clone());
                    assert_eq!(staking_pool.ops_stake_token_value(None), (3 * YOCTO).into());
                }
            }

            #[test]
            fn with_attached_deposit() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let contract_managed_total_balance = State::contract_managed_total_balance();

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                let ft_stake = ft_stake();

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // assert that there was no net change to contract_managed_total_balance
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    contract_managed_total_balance,
                    State::contract_managed_total_balance()
                );

                assert_eq!(
                    account_manager
                        .storage_balance_of(to_valid_account_id(ACCOUNT))
                        .unwrap()
                        .available,
                    YoctoNear::ZERO
                );

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balances) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);

                    println!("{}", serde_json::to_string_pretty(&balances).unwrap());
                    let staking_fee = staking_pool.ops_stake_fees().staking_fee
                        * staking_pool.ops_stake_token_value(None);
                    assert!(balances.unstaked.is_none());
                    match balances.staked.as_ref() {
                        Some(stake) => {
                            assert_eq!(stake.stake, (YOCTO - *staking_fee).into());
                            assert_eq!(stake.near_value, (YOCTO - *staking_fee).into());
                        }
                        None => panic!("expected staked balance"),
                    }

                    assert_eq!(
                        balances,
                        staking_pool
                            .ops_stake_balance(to_valid_account_id(ACCOUNT))
                            .unwrap()
                    );

                    // Assert
                    assert_eq!(logs, vec![
                        "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: bob, amount: 1000000000000000000000000",
                        "[INFO] [FT_BURN] account: bob, amount: 8000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: owner, amount: 8000000000000000000000",
                        "[WARN] [STATUS_OFFLINE] ",
                    ]);
                    let staking_fee = staking_pool.ops_stake_fees().staking_fee * YOCTO;
                    assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());
                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(ACCOUNT)),
                        (YOCTO - *staking_fee).into()
                    );
                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(OWNER)),
                        (*staking_fee).into()
                    );
                    let state = StakingPoolComponent::state();
                    println!("{:#?}", *state);
                    assert_eq!(State::total_staked_balance(), YOCTO.into());
                    assert_eq!(state.treasury_balance, YoctoNear::ZERO);

                    log_contract_managed_total_balance("after staking");

                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    assert_eq!(
                        contract_managed_total_balance + YOCTO,
                        State::contract_managed_total_balance()
                    );
                    let stake_pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&stake_pool_balances).unwrap()
                    );
                    assert_eq!(stake_pool_balances.treasury_balance, YoctoNear::ZERO);
                    assert_eq!(stake_pool_balances.total_staked, YOCTO.into());
                    assert_eq!(stake_pool_balances.total_unstaked, YoctoNear::ZERO);
                    assert_eq!(stake_pool_balances.unstaked_liquidity, YoctoNear::ZERO);
                } else {
                    panic!("expected value")
                }
            }

            #[test]
            fn with_zero_attached_deposit_and_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let contract_managed_total_balance = State::contract_managed_total_balance();

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                let ft_stake = ft_stake();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // assert that there was no net change to contract_managed_total_balance
                ctx.account_balance = env::account_balance() + YOCTO;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    contract_managed_total_balance,
                    State::contract_managed_total_balance()
                );

                assert_eq!(
                    account_manager
                        .storage_balance_of(to_valid_account_id(ACCOUNT))
                        .unwrap()
                        .available,
                    YOCTO.into()
                );

                log_contract_managed_total_balance("before staking");
                assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balances) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);

                    println!("{}", serde_json::to_string_pretty(&balances).unwrap());
                    let staking_fee = staking_pool.ops_stake_fees().staking_fee * YOCTO;
                    assert!(balances.unstaked.is_none());
                    match balances.staked.as_ref() {
                        Some(stake) => {
                            assert_eq!(stake.stake, (YOCTO - *staking_fee).into());
                            assert_eq!(stake.near_value, (YOCTO - *staking_fee).into());
                        }
                        None => panic!("expected staked balance"),
                    }

                    assert_eq!(
                        balances,
                        staking_pool
                            .ops_stake_balance(to_valid_account_id(ACCOUNT))
                            .unwrap()
                    );

                    // Assert
                    assert_eq!(logs, vec![
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(1000000000000000000000000))",
                        "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: bob, amount: 1000000000000000000000000",
                        "[INFO] [FT_BURN] account: bob, amount: 8000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: owner, amount: 8000000000000000000000",
                        "[WARN] [STATUS_OFFLINE] ",
                    ]);
                    let staking_fee = staking_pool.ops_stake_fees().staking_fee * YOCTO;
                    assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());
                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(ACCOUNT)),
                        (YOCTO - *staking_fee).into()
                    );
                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(OWNER)),
                        (*staking_fee).into()
                    );
                    let state = StakingPoolComponent::state();
                    println!("{:#?}", *state);
                    assert_eq!(State::total_staked_balance(), YOCTO.into());
                    assert_eq!(state.treasury_balance, YoctoNear::ZERO);

                    log_contract_managed_total_balance("after staking");

                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    assert_eq!(
                        contract_managed_total_balance + YOCTO,
                        State::contract_managed_total_balance()
                    );
                    let stake_pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&stake_pool_balances).unwrap()
                    );
                    assert_eq!(stake_pool_balances.treasury_balance, YoctoNear::ZERO);
                    assert_eq!(stake_pool_balances.total_staked, YOCTO.into());
                    assert_eq!(stake_pool_balances.total_unstaked, YoctoNear::ZERO);
                    assert_eq!(stake_pool_balances.unstaked_liquidity, YoctoNear::ZERO);
                } else {
                    panic!("expected value")
                }
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn with_unregistered_account() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_stake();
            }

            #[test]
            #[should_panic(
                expected = "[ERR] [NEAR_DEPOSIT_REQUIRED] deposit NEAR into storage balance or attach NEAR deposit"
            )]
            fn registered_account_with_zero_storage_available_balance_and_zero_attached_deposit() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // Act
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx);
                staking_pool.ops_stake();
            }

            #[test]
            fn stake_amount_too_low_too_stake() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + (2 * YOCTO);
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());

                assert_eq!(staking_pool.ops_stake_token_value(None), (3 * YOCTO).into());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                assert_eq!(staking_pool.ops_stake_token_value(None), (3 * YOCTO).into());
                assert_eq!(
                    *staking_pool.ops_stake_pool_balances().total_staked,
                    (5 * YOCTO) - 2
                );
                println!(
                    "ops_stake_token_value = {}",
                    staking_pool.ops_stake_token_value(None)
                );
                assert_eq!(
                    staking_pool
                        .ops_stake_balance(to_valid_account_id(ACCOUNT))
                        .unwrap()
                        .storage_balance
                        .available,
                    2.into()
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balances) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(
                        logs,
                        vec![
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(2))",
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(2))",
                            "[INFO] [NOT_ENOUGH_TO_STAKE] ",
                        ]
                    );

                    assert_eq!(balances.storage_balance.available, 2.into());
                } else {
                    panic!("expected value")
                }
            }

            #[test]
            fn stake_when_liquidity_needed() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 10 * YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());

                let total_staked_balance = staking_pool.ops_stake_pool_balances().total_staked;
                assert_eq!(total_staked_balance, (10 * YOCTO).into());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() - *total_staked_balance;
                ctx.account_locked_balance = *total_staked_balance;
                ctx.attached_deposit = 0;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                staking_pool.ops_unstake(None);
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = 5 * YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [LIQUIDITY] added=5000000000000000000000000, total=5000000000000000000000000",
                    "[INFO] [STAKE] near_amount=5000000000000000000000000, stake_token_amount=5000000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: bob, amount: 5000000000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 40000000000000000000000",
                    "[INFO] [FT_MINT] account: owner, amount: 40000000000000000000000",
                    "[WARN] [STATUS_OFFLINE] ",
                ]);

                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                assert_eq!(pool_balances.unstaked_liquidity, (5 * YOCTO).into());
            }

            #[test]
            fn stake_with_treasury_balance() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // stake 10 NEAR
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 10 * YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                assert_eq!(
                    pool_balances,
                    serde_json::from_str(
                        r#"{
  "total_staked": "10000000000000000000000000",
  "total_stake_supply": "10000000000000000000000000",
  "total_unstaked": "0",
  "unstaked_liquidity": "0",
  "treasury_balance": "0",
  "current_contract_managed_total_balance": "13172980000000000000000000",
  "last_contract_managed_total_balance": "13172980000000000000000000",
  "earnings": "0"
}"#
                    )
                    .unwrap()
                );

                // transfer STAKE from the owner to the treasurys
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 1;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                let owner_balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(OWNER))
                    .unwrap();
                staking_pool.ops_stake_transfer_call(
                    to_valid_account_id(&env::current_account_id()),
                    owner_balance.staked.as_ref().unwrap().near_value,
                    None,
                    "".into(),
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                // the staking pool will not become aware of the new STAKE that the owner transferred
                // over until a stake transaction is processed - thus the current treasury balance
                // should still be zero
                assert_eq!(pool_balances.treasury_balance, YoctoNear::ZERO);
                // confirms that the STAKE was transferred from the owner to the treasury STAKE account
                assert_eq!(
                    staking_pool
                        .ops_stake_balance(to_valid_account_id(&env::current_account_id()))
                        .unwrap()
                        .staked
                        .unwrap()
                        .stake,
                    owner_balance.staked.as_ref().unwrap().stake
                );

                // stake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    // 1 yoctoNEAR was earned from the 1 yoctoNEAR attached deposit from the FT transfer
                    "[INFO] [EARNINGS] 1",
                    // the STAKE NEAR value has increased but because of rounding, 1 yoctoNEAR could
                    // be staked and is deposited into the storage balance
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1))",                    
                    "[INFO] [STAKE] near_amount=999999999999999999999999, stake_token_amount=999999999999999999999999",
                    "[INFO] [FT_MINT] account: bob, amount: 999999999999999999999999",
                    "[INFO] [FT_BURN] account: bob, amount: 7999999999999999999998",
                    "[INFO] [FT_MINT] account: owner, amount: 7999999999999999999998",
                    "[WARN] [STATUS_OFFLINE] ",
                ]);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                // funds that were transferred over from the owner FT account now are picked up
                // by the treasury
                assert_eq!(
                    pool_balances.treasury_balance,
                    owner_balance.staked.as_ref().unwrap().near_value
                );

                println!(
                    "stake_token_value = {}",
                    staking_pool.ops_stake_token_value(None)
                );
                // the 1 yoctoNEAR that was earned was too low to affect the STAKE NEAR value because
                // the returned value is rounded down
                assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());

                // Act - with no new earnings
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    // the 1 NEAR + 1 yoctoNEAR from the account's storage available balance was staked
                    // but because the STAKE NEAR value is slightly higher than 1, 1 yoctoNEAR could
                    // not be staked because of rounding and is returned back to the account storage balance
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(1))",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1))",
                    "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                    "[INFO] [FT_MINT] account: bob, amount: 1000000000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 7999999999999999999999",
                    "[INFO] [FT_MINT] account: owner, amount: 7999999999999999999999",
                    "[WARN] [STATUS_OFFLINE] ",
                ]);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());

                // Act - stake again with no new earning
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(1))",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1))",
                    "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                    "[INFO] [FT_MINT] account: bob, amount: 1000000000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 7999999999999999999999",
                    "[INFO] [FT_MINT] account: owner, amount: 7999999999999999999999",
                    "[WARN] [STATUS_OFFLINE] ",
                ]);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                assert_eq!(
                    pool_balances,
                    serde_json::from_str(
                        r#"{
  "total_staked": "13000000000000000000000000",
  "total_stake_supply": "12999999999999999999999999",
  "total_unstaked": "0",
  "unstaked_liquidity": "0",
  "treasury_balance": "80000000000000000000000",
  "current_contract_managed_total_balance": "16172980000000000000000000",
  "last_contract_managed_total_balance": "16172980000000000000000000",
  "earnings": "0"
}"#
                    )
                    .unwrap()
                );

                let treasury_balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(&env::current_account_id()))
                    .unwrap();
                println!(
                    "treasury balance: {}",
                    serde_json::to_string_pretty(&treasury_balance).unwrap()
                );
                assert_eq!(
                    *treasury_balance.staked.as_ref().unwrap().stake,
                    *(staking_pool.ops_stake_fees().staking_fee * (10 * YOCTO))
                );
                assert_eq!(
                    treasury_balance.staked.as_ref().unwrap().near_value,
                    staking_pool.ops_stake_fees().staking_fee * (10 * YOCTO)
                );

                // Act - stake again - with new earnings - 0.1 NEAR
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + (YOCTO / 10);
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [EARNINGS] 100000000000000000000000",
                    "[INFO] [FT_BURN] account: contract.near, amount: 610687022900763358778",
                    "[INFO] [TREASURY_DIVIDEND] 615384615384615384615 yoctoNEAR / 610687022900763358778 yoctoSTAKE",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(1))",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1))",
                    "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=992319794883748033331391",
                    "[INFO] [FT_MINT] account: bob, amount: 992319794883748033331391",
                    "[INFO] [FT_BURN] account: bob, amount: 7938558359069984266651",
                    "[INFO] [FT_MINT] account: owner, amount: 7938558359069984266651",
                    "[WARN] [STATUS_OFFLINE] ",
                ]);

                let pool_balances_after_dividend_payout = staking_pool.ops_stake_pool_balances();
                println!(
                    "pool_balances_after_dividend_payout {}",
                    serde_json::to_string_pretty(&pool_balances_after_dividend_payout).unwrap()
                );
                // treasury balance is slight increased because after the treasury dividend is burned
                // the STAKE value increases
                assert_eq!(
                    pool_balances_after_dividend_payout,
                    serde_json::from_str(
                        r#"{
  "total_staked": "14100000000000000000000000",
  "total_stake_supply": "13991709107860847269972612",
  "total_unstaked": "0",
  "unstaked_liquidity": "0",
  "treasury_balance": "80003758250534376247857",
  "current_contract_managed_total_balance": "17272980000000000000000000",
  "last_contract_managed_total_balance": "17272980000000000000000000",
  "earnings": "0"
}"#
                    )
                    .unwrap()
                );

                let treasury_balance_after_dividend_paid = staking_pool
                    .ops_stake_balance(to_valid_account_id(&env::current_account_id()))
                    .unwrap();
                println!(
                    "treasury balance: {}",
                    serde_json::to_string_pretty(&treasury_balance_after_dividend_paid).unwrap()
                );
                assert_eq!(
                    *treasury_balance_after_dividend_paid
                        .staked
                        .as_ref()
                        .unwrap()
                        .stake,
                    *treasury_balance.staked.as_ref().unwrap().stake - 610687022900763358778
                );
                assert_eq!(
                    treasury_balance_after_dividend_paid,
                    serde_json::from_str(
                        r#"{
  "storage_balance": {
    "total": "3930000000000000000000",
    "available": "0"
  },
  "staked": {
    "stake": "79389312977099236641222",
    "near_value": "80003758250534376247857"
  },
  "unstaked": null
}"#
                    )
                    .unwrap()
                );
            }

            #[test]
            fn as_owner() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let contract_managed_total_balance = State::contract_managed_total_balance();

                let mut staking_pool = staking_pool();

                let ft_stake = ft_stake();

                ctx.account_balance = env::account_balance();
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let owner_balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(OWNER))
                    .unwrap();

                // Act
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    panic!("expected promise");
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                // no staking fee should be charged to the owner
                assert_eq!(logs, vec![
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(9996819160000000000000000000))",
                    "[INFO] [STAKE] near_amount=9997819160000000000000000000, stake_token_amount=9997819160000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: owner, amount: 9997819160000000000000000000",
                    "[WARN] [STATUS_OFFLINE] ",
                ]);

                let pool_balances = staking_pool.ops_stake_pool_balances();
                assert_eq!(
                    pool_balances.total_staked,
                    owner_balance.storage_balance.available + YOCTO
                );

                // Assert
                assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());
                assert_eq!(
                    *ft_stake.ft_balance_of(to_valid_account_id(OWNER)),
                    *(owner_balance.storage_balance.available + YOCTO)
                );
                let state = StakingPoolComponent::state();
                println!("{:#?}", *state);
                assert_eq!(state.treasury_balance, YoctoNear::ZERO);

                log_contract_managed_total_balance("after staking");

                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    contract_managed_total_balance
                        + owner_balance.storage_balance.available
                        + YOCTO,
                    State::contract_managed_total_balance()
                );
                let stake_pool_balances = staking_pool.ops_stake_pool_balances();
                println!(
                    "{}",
                    serde_json::to_string_pretty(&stake_pool_balances).unwrap()
                );
                assert_eq!(stake_pool_balances.treasury_balance, YoctoNear::ZERO);
                assert_eq!(
                    stake_pool_balances.total_staked,
                    staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .as_ref()
                        .unwrap()
                        .staked
                        .as_ref()
                        .unwrap()
                        .near_value
                );
                assert_eq!(stake_pool_balances.total_unstaked, YoctoNear::ZERO);
                assert_eq!(stake_pool_balances.unstaked_liquidity, YoctoNear::ZERO);
            }
        }

        #[cfg(test)]
        mod tests_unstake {
            use super::*;

            #[test]
            fn unstake_partial() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balances) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);

                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "pool_balances before unstaking: {}",
                        serde_json::to_string_pretty(&pool_balances).unwrap()
                    );

                    let staked_balance = balances.staked.as_ref().unwrap().near_value;

                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    if let PromiseOrValue::Value(balances_after_unstaking) =
                        staking_pool.ops_unstake(Some((*staked_balance / 4).into()))
                    {
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs, vec![
                            "[INFO] [UNSTAKE] near_amount=248000000000000000000000, stake_token_amount=248000000000000000000000",
                            "[INFO] [FT_BURN] account: bob, amount: 248000000000000000000000",
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)",
                            "[WARN] [STATUS_OFFLINE] ",
                        ]);

                        println!(
                            "account balances_after_unstaking: {}",
                            serde_json::to_string_pretty(&balances_after_unstaking).unwrap()
                        );
                        assert_eq!(
                            balances_after_unstaking.unstaked.as_ref().unwrap().total,
                            staked_balance / 4
                        );
                        assert_eq!(
                            balances_after_unstaking
                                .unstaked
                                .as_ref()
                                .unwrap()
                                .available,
                            YoctoNear::ZERO
                        );

                        let pool_balances = staking_pool.ops_stake_pool_balances();
                        println!(
                            "pool_balances: {}",
                            serde_json::to_string_pretty(&pool_balances).unwrap()
                        );
                        assert_eq!(
                            pool_balances.total_staked,
                            balances_after_unstaking.staked.as_ref().unwrap().near_value
                                + staking_pool
                                    .ops_stake_balance(to_valid_account_id(OWNER))
                                    .unwrap()
                                    .staked
                                    .unwrap()
                                    .near_value
                        );
                        assert_eq!(
                            pool_balances.total_unstaked,
                            balances_after_unstaking.unstaked.as_ref().unwrap().total
                        );
                    } else {
                        panic!("expected value")
                    }
                } else {
                    panic!("expected value")
                }
            }

            #[test]
            fn unstake_all() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balances) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);

                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "pool_balances before unstaking: {}",
                        serde_json::to_string_pretty(&pool_balances).unwrap()
                    );

                    let staked_balance = balances.staked.as_ref().unwrap().near_value;

                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    if let PromiseOrValue::Value(balances_after_unstaking) =
                        staking_pool.ops_unstake(None)
                    {
                        let logs = test_utils::get_logs();
                        println!("{:#?}", logs);
                        assert_eq!(logs, vec![
                            "[INFO] [UNSTAKE] near_amount=992000000000000000000000, stake_token_amount=992000000000000000000000",
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)",
                            "[INFO] [FT_BURN] account: bob, amount: 992000000000000000000000",
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)",
                            "[WARN] [STATUS_OFFLINE] ",
                        ]);

                        println!(
                            "account balances_after_unstaking: {}",
                            serde_json::to_string_pretty(&balances_after_unstaking).unwrap()
                        );
                        assert_eq!(
                            balances_after_unstaking.unstaked.as_ref().unwrap().total,
                            staked_balance
                        );
                        assert_eq!(
                            balances_after_unstaking
                                .unstaked
                                .as_ref()
                                .unwrap()
                                .available,
                            YoctoNear::ZERO
                        );

                        let pool_balances = staking_pool.ops_stake_pool_balances();
                        println!(
                            "pool_balances: {}",
                            serde_json::to_string_pretty(&pool_balances).unwrap()
                        );
                        assert_eq!(
                            pool_balances.total_staked,
                            staking_pool
                                .ops_stake_balance(to_valid_account_id(OWNER))
                                .unwrap()
                                .staked
                                .unwrap()
                                .near_value
                        );
                        assert_eq!(
                            pool_balances.total_unstaked,
                            balances_after_unstaking.unstaked.as_ref().unwrap().total
                        );
                    } else {
                        panic!("expected value")
                    }
                } else {
                    panic!("expected value")
                }
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn account_not_registered() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx);
                staking_pool.ops_unstake(None);
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS] STAKE balance is zero")]
            fn zero_stake_balance_and_unstake_specified_amount() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx);
                staking_pool.ops_unstake(Some(YOCTO.into()));
            }

            #[test]
            fn zero_stake_balance_and_unstake_all() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // Act
                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx);
                if let PromiseOrValue::Value(balances) = staking_pool.ops_unstake(None) {
                    assert!(balances.staked.is_none());
                } else {
                    panic!("expected value")
                }
            }

            #[test]
            fn unstake_with_earnings_received() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // stake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                let staked_balance =
                    if let PromiseOrValue::Value(balance) = staking_pool.ops_stake() {
                        let staking_fee = staking_pool.ops_stake_fees().staking_fee * YOCTO;
                        assert_eq!(
                            balance.staked.as_ref().unwrap().near_value,
                            (YOCTO - *staking_fee).into()
                        );
                        balance
                    } else {
                        panic!("expected value")
                    };
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Act
                const EARNINGS: YoctoNear = YoctoNear(YOCTO);
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + *EARNINGS;
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balance) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(logs, vec![
                        "[INFO] [EARNINGS] 1000000000000000000000000",
                        "[INFO] [UNSTAKE] near_amount=1984000000000000000000000, stake_token_amount=992000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)",
                        "[INFO] [FT_BURN] account: bob, amount: 992000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)",
                        "[WARN] [STATUS_OFFLINE] ",
                    ]);

                    let unstaked_near_value = staking_pool
                        .ops_stake_token_value(Some(staked_balance.staked.as_ref().unwrap().stake));
                    assert_eq!(
                        balance.unstaked.as_ref().unwrap().total,
                        unstaked_near_value
                    );
                } else {
                    panic!("expected value")
                }
            }

            #[test]
            fn unstake_with_dividend_received() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // stake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                let staked_balance =
                    if let PromiseOrValue::Value(balance) = staking_pool.ops_stake() {
                        let staking_fee = staking_pool.ops_stake_fees().staking_fee * YOCTO;
                        assert_eq!(
                            balance.staked.as_ref().unwrap().near_value,
                            (YOCTO - *staking_fee).into()
                        );
                        balance
                    } else {
                        panic!("expected value")
                    };
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // deposit into treasury
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_treasury_deposit();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Act
                const EARNINGS: YoctoNear = YoctoNear(YOCTO);
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + *EARNINGS;
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balance) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(logs, vec![
                        "[INFO] [EARNINGS] 1000000000000000000000000",
                        "[INFO] [FT_BURN] account: contract.near, amount: 333333333333333333333333",
                        "[INFO] [TREASURY_DIVIDEND] 500000000000000000000000 yoctoNEAR / 333333333333333333333333 yoctoSTAKE",
                        "[INFO] [UNSTAKE] near_amount=1785599999999999999999999, stake_token_amount=992000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)",
                        "[INFO] [FT_BURN] account: bob, amount: 992000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)",
                        "[WARN] [STATUS_OFFLINE] ",
                    ]);

                    println!("{}", serde_json::to_string_pretty(&balance).unwrap());
                    let unstaked_near_value = staking_pool
                        .ops_stake_token_value(Some(staked_balance.staked.as_ref().unwrap().stake));
                    assert_eq!(
                        balance.unstaked.as_ref().unwrap().total
                            + balance.storage_balance.available,
                        unstaked_near_value
                    );
                } else {
                    panic!("expected value")
                }
            }
        }

        #[cfg(test)]
        mod tests_withdraw {
            use super::*;

            #[test]
            fn withdraw_some() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();
                let state_before_withdrawal = StakingPoolComponent::state();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(Some((1000).into()));

                // Assert
                assert!(test_utils::get_logs().is_empty());

                assert_eq!(
                    balances.unstaked.as_ref().unwrap().total,
                    balances_before_withdrawal.unstaked.as_ref().unwrap().total - 1000
                );

                let state = StakingPoolComponent::state();
                assert_eq!(
                    state.last_contract_managed_total_balance,
                    state_before_withdrawal.last_contract_managed_total_balance - 1000,
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(action.deposit, 1000);
                    }
                    _ => panic!("expected transfer action"),
                }
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
            fn withdraw_some_with_zero_unstaked() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_withdraw(Some((1000).into()));
            }

            #[test]
            fn withdraw_available_using_liquidity() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                State::add_liquidity((YOCTO / 2).into());
                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec!["[INFO] [LIQUIDITY] removed=500000000000000000000000, total=0",]
                );

                assert_eq!(
                    balances.unstaked.as_ref().unwrap().total,
                    balances_before_withdrawal.unstaked.as_ref().unwrap().total - (YOCTO / 2)
                );
                assert_eq!(
                    balances.unstaked.as_ref().unwrap().available,
                    YoctoNear::ZERO
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(action.deposit, (YOCTO / 2));
                    }
                    _ => panic!("expected transfer action"),
                }
            }

            #[test]
            fn withdraw_available_using_full_liquidity() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // staking adds liquidity
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = *balances_before_withdrawal.unstaked.as_ref().unwrap().total;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                // Act
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-184)",
                        "[INFO] [LIQUIDITY] removed=992000000000000000000000, total=0",
                    ]
                );

                assert!(balances.unstaked.is_none(),);

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(action.deposit, 992000000000000000000000);
                    }
                    _ => panic!("expected transfer action"),
                }
            }

            #[test]
            fn withdraw_available_using_up_all_liquidity() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register accounts
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = "alice".to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // stake storage deposit
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // Add liquidity
                ctx.predecessor_account_id = "alice".to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO / 2;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Act
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-184)",
                        "[INFO] [LIQUIDITY] removed=500000000000000000000000, total=0",
                    ]
                );

                assert!(balances.unstaked.is_none());

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(action.deposit, 992000000000000000000000);
                    }
                    _ => panic!("expected transfer action"),
                }
            }

            #[test]
            fn withdraw_all() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec!["[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-184)",]
                );

                assert!(balances.unstaked.is_none());

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(
                            action.deposit,
                            *balances_before_withdrawal.unstaked.as_ref().unwrap().total
                        );
                    }
                    _ => panic!("expected transfer action"),
                }
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED] ")]
            fn withdraw_all_not_registered() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_stake_withdraw(None);
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED] ")]
            fn withdraw_some_not_registered() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_stake_withdraw(Some(YOCTO.into()));
            }

            #[test]
            fn withdraw_all_with_zero_unstaked_funds() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                assert!(test_utils::get_logs().is_empty());

                assert_eq!(balances_before_withdrawal, balances);
                assert!(deserialize_receipts().is_empty());
            }

            #[test]
            fn withdraw_all_with_zero_stake_funds() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                assert!(test_utils::get_logs().is_empty());

                assert_eq!(balances_before_withdrawal, balances);
                assert!(deserialize_receipts().is_empty());
            }

            #[test]
            #[should_panic(expected = "[ERR] [INVALID] amount must be > 0")]
            fn withdraw_some_specifying_zero() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_withdraw(Some(YoctoNear::ZERO));
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS] ")]
            fn withdraw_some_insufficient_funds() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_withdraw(Some(
                    balances_before_withdrawal.unstaked.as_ref().unwrap().total + 1,
                ));
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS] ")]
            fn withdraw_some_but_funds_not_available() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 3;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_withdraw(Some(
                    balances_before_withdrawal.unstaked.as_ref().unwrap().total,
                ));
            }

            #[test]
            fn withdraw_some_with_earnings_received() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake 1/2
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(Some((YOCTO / 2).into()))
                {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();
                let state_before_withdrawal = StakingPoolComponent::state();

                // Act
                ctx.account_balance = env::account_balance() + (YOCTO / 2);
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(Some((1000).into()));

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec!["[INFO] [EARNINGS] 500000000000000000000000",]);

                assert_eq!(
                    balances.unstaked.as_ref().unwrap().total,
                    balances_before_withdrawal.unstaked.as_ref().unwrap().total - 1000
                );

                let state = StakingPoolComponent::state();
                assert_eq!(
                    state.last_contract_managed_total_balance,
                    state_before_withdrawal.last_contract_managed_total_balance - 1000
                        + (YOCTO / 2),
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(action.deposit, 1000);
                    }
                    _ => panic!("expected transfer action"),
                }
            }
        }

        #[cfg(test)]
        mod tests_restake {
            use super::*;

            #[test]
            fn restake_partial() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balances_before_restaking = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balances) =
                    staking_pool.ops_restake(Some((1000).into()))
                {
                    // Assert
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(
                        logs,
                        vec![
                            "[INFO] [STAKE] near_amount=1000, stake_token_amount=1000",
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                            "[INFO] [FT_MINT] account: bob, amount: 1000",
                            "[INFO] [FT_BURN] account: bob, amount: 8",
                            "[INFO] [FT_MINT] account: owner, amount: 8",
                            "[WARN] [STATUS_OFFLINE] ",
                        ]
                    );

                    println!("{}", serde_json::to_string_pretty(&balances).unwrap());
                    assert_eq!(
                        balances.unstaked.as_ref().unwrap().total,
                        balances_before_restaking.unstaked.as_ref().unwrap().total - 1000
                    );
                    let staking_fee = staking_pool.ops_stake_fees().staking_fee * 1000;
                    assert_eq!(
                        balances.staked.as_ref().unwrap().near_value,
                        (1000 - *staking_fee).into()
                    );
                } else {
                    panic!("expected Value")
                }
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
            fn restake_partial_with_zero_unstaked_balance() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_restake(Some(YOCTO.into()));
            }

            #[test]
            fn restake_all() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balance_before_restaking = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balances) = staking_pool.ops_restake(None) {
                    // Assert
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(
                        logs,
                        vec![
                            "[INFO] [STAKE] near_amount=992000000000000000000000, stake_token_amount=992000000000000000000000",
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                            "[INFO] [FT_MINT] account: bob, amount: 992000000000000000000000",
                            "[INFO] [FT_BURN] account: bob, amount: 7936000000000000000000",
                            "[INFO] [FT_MINT] account: owner, amount: 7936000000000000000000",
                            "[WARN] [STATUS_OFFLINE] ",
                        ]
                    );

                    println!("{}", serde_json::to_string_pretty(&balances).unwrap());
                    assert!(balances.unstaked.is_none());
                    let staking_fee = staking_pool.ops_stake_fees().staking_fee
                        * balance_before_restaking.unstaked.as_ref().unwrap().total;
                    assert_eq!(
                        balances.staked.as_ref().unwrap().near_value,
                        balance_before_restaking.unstaked.as_ref().unwrap().total - staking_fee
                    );
                } else {
                    panic!("expected Value")
                }
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn restake_all_with_unregistered_account() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_restake(None);
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn restake_some_with_unregistered_account() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_restake(Some(YOCTO.into()));
            }

            #[test]
            fn restake_all_with_earnings_received() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // stake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());

                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    panic!("expected value")
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Unstake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value")
                }

                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                println!(
                    "{}",
                    serde_json::to_string_pretty(
                        &staking_pool.ops_stake_balance(to_valid_account_id(ACCOUNT))
                    )
                    .unwrap()
                );

                let earnings: YoctoNear = staking_pool.ops_stake_pool_balances().total_staked;
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + *earnings;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                // Act
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balance) = staking_pool.ops_restake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(logs, vec![
                        "[INFO] [EARNINGS] 8000000000000000000000",
                        "[INFO] [STAKE] near_amount=992000000000000000000000, stake_token_amount=496000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: bob, amount: 496000000000000000000000",
                        "[INFO] [FT_BURN] account: bob, amount: 3968000000000000000000",
                        "[INFO] [FT_MINT] account: owner, amount: 3968000000000000000000",
                        "[WARN] [STATUS_OFFLINE] ",
                    ]);

                    println!("{}", serde_json::to_string_pretty(&balance).unwrap());
                } else {
                    panic!("expected value")
                }
            }

            #[test]
            fn restake_all_after_withdrawing_half_with_earnings_received() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // stake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());

                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    panic!("expected value")
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Unstake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value")
                }

                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balance = staking_pool.ops_stake_balance(to_valid_account_id(ACCOUNT));
                println!("{}", serde_json::to_string_pretty(&balance).unwrap());

                // Withdraw 1/2
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_withdraw(Some(
                    balance.as_ref().unwrap().unstaked.as_ref().unwrap().total / 2,
                ));

                let earnings: YoctoNear = staking_pool.ops_stake_pool_balances().total_staked;
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + *earnings;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                // Act

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balance) = staking_pool.ops_restake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(logs, vec![
                        "[INFO] [EARNINGS] 8000000000000000000000",
                        "[INFO] [STAKE] near_amount=496000000000000000000000, stake_token_amount=248000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: bob, amount: 248000000000000000000000",
                        "[INFO] [FT_BURN] account: bob, amount: 1984000000000000000000",
                        "[INFO] [FT_MINT] account: owner, amount: 1984000000000000000000",
                        "[WARN] [STATUS_OFFLINE] ",
                    ]);

                    println!("{}", serde_json::to_string_pretty(&balance).unwrap());
                } else {
                    panic!("expected value")
                }
            }
        }

        #[test]
        fn ops_stake_token_value_with_updated_earnings() {
            // Arrange
            let mut ctx = new_context(ACCOUNT);
            ctx.predecessor_account_id = OWNER.to_string();
            testing_env!(ctx.clone());

            deploy_stake_contract(staking_public_key());

            let mut account_manager = account_manager();
            let mut staking_pool = staking_pool();
            assert!(!staking_pool.ops_stake_status().is_online());

            // register account
            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, Some(true));

            assert_eq!(
                staking_pool.ops_stake_token_value_with_earnings(None),
                YOCTO.into()
            );
            assert_eq!(
                staking_pool.ops_stake_token_value_with_earnings(None),
                staking_pool.ops_stake_token_value(None)
            );

            // stake
            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());

            staking_pool.ops_stake();

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 0;
            testing_env!(ctx.clone());

            assert_eq!(
                staking_pool.ops_stake_token_value_with_earnings(None),
                YOCTO.into()
            );
            assert_eq!(
                staking_pool.ops_stake_token_value_with_earnings(None),
                staking_pool.ops_stake_token_value(None)
            );

            // simulate earnings
            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance() + YOCTO;
            ctx.attached_deposit = 0;
            testing_env!(ctx.clone());

            assert_eq!(
                staking_pool.ops_stake_token_value_with_earnings(None),
                (2 * YOCTO).into()
            );

            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(logs, vec!["[INFO] [EARNINGS] 1000000000000000000000000",]);
        }
    }

    #[cfg(test)]
    mod tests_online {
        use super::*;

        #[cfg(test)]
        mod tests_stake {
            use super::*;

            #[test]
            fn with_attached_deposit() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let contract_managed_total_balance = State::contract_managed_total_balance();

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                let ft_stake = ft_stake();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // assert that there was no net change to contract_managed_total_balance
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    contract_managed_total_balance,
                    State::contract_managed_total_balance()
                );

                assert_eq!(
                    account_manager
                        .storage_balance_of(to_valid_account_id(ACCOUNT))
                        .unwrap()
                        .available,
                    YoctoNear::ZERO
                );

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise");
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::Stake(action) => {
                            assert_eq!(
                                action.stake,
                                *staking_pool.ops_stake_pool_balances().total_staked
                            );

                            assert_eq!(
                                action.public_key,
                                "1".to_string()
                                    + staking_pool
                                        .ops_stake_public_key()
                                        .to_string()
                                        .split(":")
                                        .last()
                                        .unwrap()
                            );
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ops_stake_finalize");
                            let args: StakeActionCallbackArgs =
                                serde_json::from_str(&action.args).unwrap();
                            assert_eq!(args.account_id, ACCOUNT);
                            assert_eq!(action.deposit, 0);
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }

                // Assert
                assert_eq!(logs, vec![
                    "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: bob, amount: 1000000000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 8000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: owner, amount: 8000000000000000000000",
                ]);
                let staking_fee = staking_pool.ops_stake_fees().staking_fee * YOCTO;
                assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());
                assert_eq!(
                    ft_stake.ft_balance_of(to_valid_account_id(ACCOUNT)),
                    (YOCTO - *staking_fee).into()
                );
                assert_eq!(
                    ft_stake.ft_balance_of(to_valid_account_id(OWNER)),
                    (*staking_fee).into()
                );
                let state = StakingPoolComponent::state();
                println!("{:#?}", *state);
                assert_eq!(State::total_staked_balance(), YOCTO.into());
                assert_eq!(state.treasury_balance, YoctoNear::ZERO);

                log_contract_managed_total_balance("after staking");

                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    contract_managed_total_balance + YOCTO,
                    State::contract_managed_total_balance()
                );
                let stake_pool_balances = staking_pool.ops_stake_pool_balances();
                println!(
                    "{}",
                    serde_json::to_string_pretty(&stake_pool_balances).unwrap()
                );
                assert_eq!(stake_pool_balances.treasury_balance, YoctoNear::ZERO);
                assert_eq!(stake_pool_balances.total_staked, YOCTO.into());
                assert_eq!(stake_pool_balances.total_unstaked, YoctoNear::ZERO);
                assert_eq!(stake_pool_balances.unstaked_liquidity, YoctoNear::ZERO);
            }

            #[test]
            fn with_zero_attached_deposit_and_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let contract_managed_total_balance = State::contract_managed_total_balance();

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                let ft_stake = ft_stake();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // assert that there was no net change to contract_managed_total_balance
                ctx.account_balance = env::account_balance() + YOCTO;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    contract_managed_total_balance,
                    State::contract_managed_total_balance()
                );

                assert_eq!(
                    account_manager
                        .storage_balance_of(to_valid_account_id(ACCOUNT))
                        .unwrap()
                        .available,
                    YOCTO.into()
                );

                log_contract_managed_total_balance("before staking");
                assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);

                    let staking_fee = staking_pool.ops_stake_fees().staking_fee * YOCTO;

                    let balances = staking_pool
                        .ops_stake_balance(to_valid_account_id(ACCOUNT))
                        .unwrap();
                    assert!(balances.unstaked.is_none());
                    match balances.staked.as_ref() {
                        Some(stake) => {
                            assert_eq!(stake.stake, (YOCTO - *staking_fee).into());
                            assert_eq!(stake.near_value, (YOCTO - *staking_fee).into());
                        }
                        None => panic!("expected staked balance"),
                    }

                    // Assert
                    assert_eq!(logs, vec![
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(1000000000000000000000000))",
                        "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: bob, amount: 1000000000000000000000000",
                        "[INFO] [FT_BURN] account: bob, amount: 8000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: owner, amount: 8000000000000000000000",
                    ]);
                    let staking_fee = staking_pool.ops_stake_fees().staking_fee * YOCTO;
                    assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());
                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(ACCOUNT)),
                        (YOCTO - *staking_fee).into()
                    );
                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(OWNER)),
                        (*staking_fee).into()
                    );
                    let state = StakingPoolComponent::state();
                    println!("{:#?}", *state);
                    assert_eq!(State::total_staked_balance(), YOCTO.into());
                    assert_eq!(state.treasury_balance, YoctoNear::ZERO);

                    log_contract_managed_total_balance("after staking");

                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    assert_eq!(
                        contract_managed_total_balance + YOCTO,
                        State::contract_managed_total_balance()
                    );
                    let stake_pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&stake_pool_balances).unwrap()
                    );
                    assert_eq!(stake_pool_balances.treasury_balance, YoctoNear::ZERO);
                    assert_eq!(stake_pool_balances.total_staked, YOCTO.into());
                    assert_eq!(stake_pool_balances.total_unstaked, YoctoNear::ZERO);
                    assert_eq!(stake_pool_balances.unstaked_liquidity, YoctoNear::ZERO);
                } else {
                    panic!("expected Promise")
                }
            }

            #[test]
            fn earnings_received_through_account_balance_increase_with_zero_total_stake_supply() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                let ft_stake = ft_stake();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // simulate earnings received by increasing account balance
                const EARNINGS: YoctoNear = YoctoNear(YOCTO);
                ctx.account_balance = env::account_balance() + *EARNINGS;
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());

                // even there are earnings that have accumulated, because there are no stakers, then
                // we expect the STAKE token value to be 1:1
                assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());
                // Act
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise")
                }
                let balances = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: bob, amount: 1000000000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 8000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: owner, amount: 8000000000000000000000",
                ]);
                println!("{}", serde_json::to_string_pretty(&balances).unwrap());
                assert_eq!(
                    *balances.staked.as_ref().unwrap().stake,
                    992000000000000000000000
                );
                // when FT total supply is zero, then earnings are held and not staked
                // earnings will be staked on the next staking action
                assert_eq!(
                    *balances.staked.as_ref().unwrap().near_value,
                    1984000000000000000000000
                );
                // STAKE token value is 2 NEAR because of the earnings that have not yet been staked
                assert_eq!(staking_pool.ops_stake_token_value(None), (2 * YOCTO).into());
                assert_eq!(ft_stake.ft_total_supply(), YOCTO.into());
                println!(
                    "owner stake balances = {}",
                    serde_json::to_string_pretty(
                        &staking_pool.ops_stake_balance(to_valid_account_id(OWNER))
                    )
                    .unwrap()
                );
                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                ctx.account_balance = env::account_balance() + *EARNINGS;
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                assert_eq!(staking_pool.ops_stake_token_value(None), (3 * YOCTO).into());

                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                // Act - simulate more earnings on next stake
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise")
                }
                let balances = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [EARNINGS] 2000000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1))",
                    "[INFO] [STAKE] near_amount=999999999999999999999999, stake_token_amount=333333333333333333333333",
                    "[INFO] [FT_MINT] account: bob, amount: 333333333333333333333333",
                    "[INFO] [FT_BURN] account: bob, amount: 2666666666666666666666",
                    "[INFO] [FT_MINT] account: owner, amount: 2666666666666666666666",
                ]);

                {
                    println!(
                        "account {}",
                        serde_json::to_string_pretty(&balances).unwrap()
                    );

                    assert_eq!(
                        *balances.staked.as_ref().unwrap().stake,
                        1322666666666666666666667
                    );
                    assert_eq!(
                        *balances.staked.as_ref().unwrap().near_value,
                        3968000000000000000000001
                    );
                    // because the STAKE:NEAR value is 1:3, then 1 yoctoNEAR could not be staked
                    assert_eq!(balances.storage_balance.available, 1.into());
                }

                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());

                // Assert - account STAKE NEAR balances sum up to the total staked balance
                {
                    let owner_stake_balances = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    println!(
                        "owner_stake_balances {}",
                        serde_json::to_string_pretty(&owner_stake_balances).unwrap()
                    );
                    let stake_pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "stake_pool_balances {}",
                        serde_json::to_string_pretty(&stake_pool_balances).unwrap()
                    );
                    assert_eq!(
                        stake_pool_balances.total_staked,
                        balances.staked.as_ref().unwrap().near_value
                            + owner_stake_balances.staked.as_ref().unwrap().near_value
                    );
                }

                {
                    let stake_token_value = staking_pool.ops_stake_token_value(None);
                    println!("stake_token_value = {}", stake_token_value);
                    let stake_total_supply = ft_stake.ft_total_supply();
                    println!("ft_total_supply = {}", stake_total_supply);
                    let owner_stake_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    println!(
                        "owner stake balances = {}",
                        serde_json::to_string_pretty(&owner_stake_balance).unwrap()
                    );
                    let stake_pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "{}",
                        serde_json::to_string_pretty(&stake_pool_balances).unwrap()
                    );
                    // since all earnings are staked, then the total STAKE supply value should match
                    // the total staked balance
                    assert_eq!(
                        staking_pool.ops_stake_token_value(Some(stake_total_supply)),
                        stake_pool_balances.total_staked,
                    );
                }

                {
                    ctx.account_balance = env::account_balance();
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = 0;
                    ctx.is_view = true;
                    testing_env!(ctx.clone());
                    assert_eq!(staking_pool.ops_stake_token_value(None), (3 * YOCTO).into());
                }
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn with_unregistered_account() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_stake();
            }

            #[test]
            #[should_panic(
                expected = "[ERR] [NEAR_DEPOSIT_REQUIRED] deposit NEAR into storage balance or attach NEAR deposit"
            )]
            fn registered_account_with_zero_storage_available_balance_and_zero_attached_deposit() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // Act
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx);
                staking_pool.ops_stake();
            }

            #[test]
            fn stake_amount_too_low_too_stake() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + (2 * YOCTO);
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());

                assert_eq!(staking_pool.ops_stake_token_value(None), (3 * YOCTO).into());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                assert_eq!(staking_pool.ops_stake_token_value(None), (3 * YOCTO).into());
                assert_eq!(
                    *staking_pool.ops_stake_pool_balances().total_staked,
                    (5 * YOCTO) - 2
                );
                println!(
                    "ops_stake_token_value = {}",
                    staking_pool.ops_stake_token_value(None)
                );
                assert_eq!(
                    staking_pool
                        .ops_stake_balance(to_valid_account_id(ACCOUNT))
                        .unwrap()
                        .storage_balance
                        .available,
                    2.into()
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(balances) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(
                        logs,
                        vec![
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(2))",
                            "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(2))",
                            "[INFO] [NOT_ENOUGH_TO_STAKE] ",
                        ]
                    );

                    assert_eq!(balances.storage_balance.available, 2.into());
                } else {
                    panic!("expected value")
                }
            }

            #[test]
            fn stake_when_liquidity_needed() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 10 * YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());

                let total_staked_balance = staking_pool.ops_stake_pool_balances().total_staked;
                assert_eq!(total_staked_balance, (10 * YOCTO).into());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() - *total_staked_balance;
                ctx.account_locked_balance = *total_staked_balance;
                ctx.attached_deposit = 0;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                staking_pool.ops_unstake(None);
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = 5 * YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [LIQUIDITY] added=5000000000000000000000000, total=5000000000000000000000000",
                    "[INFO] [STAKE] near_amount=5000000000000000000000000, stake_token_amount=5000000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: bob, amount: 5000000000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 40000000000000000000000",
                    "[INFO] [FT_MINT] account: owner, amount: 40000000000000000000000",
                ]);

                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                assert_eq!(pool_balances.unstaked_liquidity, (5 * YOCTO).into());
            }

            #[test]
            fn stake_with_treasury_balance() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 10 * YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                assert_eq!(
                    pool_balances,
                    serde_json::from_str(
                        r#"{
  "total_staked": "10000000000000000000000000",
  "total_stake_supply": "10000000000000000000000000",
  "total_unstaked": "0",
  "unstaked_liquidity": "0",
  "treasury_balance": "0",
  "current_contract_managed_total_balance": "13172980000000000000000000",
  "last_contract_managed_total_balance": "13172980000000000000000000",
  "earnings": "0"
}"#
                    )
                    .unwrap()
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() - *pool_balances.total_staked;
                ctx.account_locked_balance = *pool_balances.total_staked;
                ctx.attached_deposit = 1;
                ctx.is_view = false;
                testing_env!(ctx.clone());

                let owner_balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(OWNER))
                    .unwrap();
                staking_pool.ops_stake_transfer_call(
                    to_valid_account_id(&env::current_account_id()),
                    owner_balance.staked.as_ref().unwrap().near_value,
                    None,
                    "".into(),
                );

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                assert_eq!(pool_balances.treasury_balance, YoctoNear::ZERO);
                assert_eq!(
                    staking_pool
                        .ops_stake_balance(to_valid_account_id(&env::current_account_id()))
                        .unwrap()
                        .staked
                        .unwrap()
                        .stake,
                    owner_balance.staked.as_ref().unwrap().stake
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [EARNINGS] 1",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1))",
                    "[INFO] [STAKE] near_amount=999999999999999999999999, stake_token_amount=999999999999999999999999",
                    "[INFO] [FT_MINT] account: bob, amount: 999999999999999999999999",
                    "[INFO] [FT_BURN] account: bob, amount: 7999999999999999999998",
                    "[INFO] [FT_MINT] account: owner, amount: 7999999999999999999998",
                ]);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                // funds that were transferred over from the owner FT account now are picked up
                // by the treasury
                assert_eq!(
                    pool_balances.treasury_balance,
                    owner_balance.staked.as_ref().unwrap().near_value
                );

                println!(
                    "stake_token_value = {}",
                    staking_pool.ops_stake_token_value(None)
                );

                // Act
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(1))",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1))",
                    "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                    "[INFO] [FT_MINT] account: bob, amount: 1000000000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 7999999999999999999999",
                    "[INFO] [FT_MINT] account: owner, amount: 7999999999999999999999",
                ]);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());

                // Act - stake again
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = 0;
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                assert_eq!(
                    pool_balances,
                    serde_json::from_str(
                        r#"{
  "total_staked": "13000000000000000000000000",
  "total_stake_supply": "12999999999999999999999999",
  "total_unstaked": "0",
  "unstaked_liquidity": "0",
  "treasury_balance": "80000000000000000000000",
  "current_contract_managed_total_balance": "16172980000000000000000000",
  "last_contract_managed_total_balance": "16172980000000000000000000",
  "earnings": "0"
}"#
                    )
                    .unwrap()
                );

                let treasury_balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(&env::current_account_id()))
                    .unwrap();
                println!(
                    "treasury balance: {}",
                    serde_json::to_string_pretty(&treasury_balance).unwrap()
                );

                // Act - stake again - simulate earnings
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + (YOCTO / 10);
                ctx.account_locked_balance = env::account_locked_balance();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [EARNINGS] 100000000000000000000000",
                    "[INFO] [FT_BURN] account: contract.near, amount: 610687022900763358778",
                    "[INFO] [TREASURY_DIVIDEND] 615384615384615384615 yoctoNEAR / 610687022900763358778 yoctoSTAKE",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(1))",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1))",
                    "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=992319794883748033331391",
                    "[INFO] [FT_MINT] account: bob, amount: 992319794883748033331391",
                    "[INFO] [FT_BURN] account: bob, amount: 7938558359069984266651",
                    "[INFO] [FT_MINT] account: owner, amount: 7938558359069984266651",
                ]);

                let pool_balances_after_dividend_payout = staking_pool.ops_stake_pool_balances();
                println!(
                    "{}",
                    serde_json::to_string_pretty(&pool_balances_after_dividend_payout).unwrap()
                );
                let treasury_balance_after_dividend_paid = staking_pool
                    .ops_stake_balance(to_valid_account_id(&env::current_account_id()))
                    .unwrap();
                println!(
                    "treasury balance: {}",
                    serde_json::to_string_pretty(&treasury_balance_after_dividend_paid).unwrap()
                );
                assert_eq!(
                    *treasury_balance_after_dividend_paid
                        .staked
                        .as_ref()
                        .unwrap()
                        .stake,
                    *treasury_balance.staked.as_ref().unwrap().stake - 610687022900763358778
                );
                assert_eq!(
                    treasury_balance_after_dividend_paid,
                    serde_json::from_str(
                        r#"{
  "storage_balance": {
    "total": "3930000000000000000000",
    "available": "0"
  },
  "staked": {
    "stake": "79389312977099236641222",
    "near_value": "80003758250534376247857"
  },
  "unstaked": null
}"#
                    )
                    .unwrap()
                );
            }

            #[test]
            fn as_owner() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let contract_managed_total_balance = State::contract_managed_total_balance();

                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                let ft_stake = ft_stake();

                ctx.account_balance = env::account_balance();
                ctx.is_view = true;
                testing_env!(ctx.clone());
                let owner_balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(OWNER))
                    .unwrap();

                // Act
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                ctx.is_view = false;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise");
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(9996819160000000000000000000))",
                    "[INFO] [STAKE] near_amount=9997819160000000000000000000, stake_token_amount=9997819160000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: owner, amount: 9997819160000000000000000000",
                ]);

                let pool_balances = staking_pool.ops_stake_pool_balances();
                assert_eq!(
                    pool_balances.total_staked,
                    owner_balance.storage_balance.available + YOCTO
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::Stake(action) => {
                            assert_eq!(
                                action.stake,
                                *staking_pool.ops_stake_pool_balances().total_staked
                            );

                            assert_eq!(
                                action.public_key,
                                "1".to_string()
                                    + staking_pool
                                        .ops_stake_public_key()
                                        .to_string()
                                        .split(":")
                                        .last()
                                        .unwrap()
                            );
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ops_stake_finalize");
                            let args: StakeActionCallbackArgs =
                                serde_json::from_str(&action.args).unwrap();
                            assert_eq!(args.account_id, OWNER);
                            assert_eq!(action.deposit, 0);
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }

                // Assert
                assert_eq!(staking_pool.ops_stake_token_value(None), YOCTO.into());
                assert_eq!(
                    *ft_stake.ft_balance_of(to_valid_account_id(OWNER)),
                    *(owner_balance.storage_balance.available + YOCTO)
                );
                let state = StakingPoolComponent::state();
                println!("{:#?}", *state);
                assert_eq!(state.treasury_balance, YoctoNear::ZERO);

                log_contract_managed_total_balance("after staking");

                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    contract_managed_total_balance
                        + owner_balance.storage_balance.available
                        + YOCTO,
                    State::contract_managed_total_balance()
                );
                let stake_pool_balances = staking_pool.ops_stake_pool_balances();
                println!(
                    "{}",
                    serde_json::to_string_pretty(&stake_pool_balances).unwrap()
                );
                assert_eq!(stake_pool_balances.treasury_balance, YoctoNear::ZERO);
                assert_eq!(
                    stake_pool_balances.total_staked,
                    staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .as_ref()
                        .unwrap()
                        .staked
                        .as_ref()
                        .unwrap()
                        .near_value
                );
                assert_eq!(stake_pool_balances.total_unstaked, YoctoNear::ZERO);
                assert_eq!(stake_pool_balances.unstaked_liquidity, YoctoNear::ZERO);
            }
        }

        #[cfg(test)]
        mod tests_unstake {
            use super::*;

            #[test]
            fn unstake_partial() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);

                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "pool_balances before unstaking: {}",
                        serde_json::to_string_pretty(&pool_balances).unwrap()
                    );
                } else {
                    panic!("expected promise")
                }

                let balances = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();
                let staked_balance = balances.staked.as_ref().unwrap().near_value;

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) =
                    staking_pool.ops_unstake(Some((*staked_balance / 4).into()))
                {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(logs, vec![
                        "[INFO] [UNSTAKE] near_amount=248000000000000000000000, stake_token_amount=248000000000000000000000",
                        "[INFO] [FT_BURN] account: bob, amount: 248000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)",
                    ]);

                    let balances_after_unstaking = staking_pool
                        .ops_stake_balance(to_valid_account_id(ACCOUNT))
                        .unwrap();
                    println!(
                        "account balances_after_unstaking: {}",
                        serde_json::to_string_pretty(&balances_after_unstaking).unwrap()
                    );
                    assert_eq!(
                        balances_after_unstaking.unstaked.as_ref().unwrap().total,
                        staked_balance / 4
                    );
                    assert_eq!(
                        balances_after_unstaking
                            .unstaked
                            .as_ref()
                            .unwrap()
                            .available,
                        YoctoNear::ZERO
                    );

                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!(
                        "pool_balances: {}",
                        serde_json::to_string_pretty(&pool_balances).unwrap()
                    );
                    assert_eq!(
                        pool_balances.total_staked,
                        balances_after_unstaking.staked.as_ref().unwrap().near_value
                            + staking_pool
                                .ops_stake_balance(to_valid_account_id(OWNER))
                                .unwrap()
                                .staked
                                .unwrap()
                                .near_value
                    );
                    assert_eq!(
                        pool_balances.total_unstaked,
                        balances_after_unstaking.unstaked.as_ref().unwrap().total
                    );
                } else {
                    panic!("expected value")
                }

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::Stake(action) => {
                            assert_eq!(
                                action.stake,
                                *staking_pool.ops_stake_pool_balances().total_staked
                            );

                            assert_eq!(
                                action.public_key,
                                "1".to_string()
                                    + staking_pool
                                        .ops_stake_public_key()
                                        .to_string()
                                        .split(":")
                                        .last()
                                        .unwrap()
                            );
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ops_stake_finalize");
                            let args: StakeActionCallbackArgs =
                                serde_json::from_str(&action.args).unwrap();
                            assert_eq!(args.account_id, ACCOUNT);
                            assert_eq!(action.deposit, 0);
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
            }

            #[test]
            fn unstake_all() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected value")
                }

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!(
                    "pool_balances before unstaking: {}",
                    serde_json::to_string_pretty(&pool_balances).unwrap()
                );

                let balances = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();
                let staked_balance = balances.staked.as_ref().unwrap().near_value;

                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    panic!("expected Promise")
                }

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [UNSTAKE] near_amount=992000000000000000000000, stake_token_amount=992000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)",
                    "[INFO] [FT_BURN] account: bob, amount: 992000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)",
                ]);

                let balances_after_unstaking = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();
                println!(
                    "account balances_after_unstaking: {}",
                    serde_json::to_string_pretty(&balances_after_unstaking).unwrap()
                );
                assert_eq!(
                    balances_after_unstaking.unstaked.as_ref().unwrap().total,
                    staked_balance
                );
                assert_eq!(
                    balances_after_unstaking
                        .unstaked
                        .as_ref()
                        .unwrap()
                        .available,
                    YoctoNear::ZERO
                );

                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!(
                    "pool_balances: {}",
                    serde_json::to_string_pretty(&pool_balances).unwrap()
                );
                assert_eq!(
                    pool_balances.total_staked,
                    staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap()
                        .staked
                        .unwrap()
                        .near_value
                );
                assert_eq!(
                    pool_balances.total_unstaked,
                    balances_after_unstaking.unstaked.as_ref().unwrap().total
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::Stake(action) => {
                            assert_eq!(
                                action.stake,
                                *staking_pool.ops_stake_pool_balances().total_staked
                            );

                            assert_eq!(
                                action.public_key,
                                "1".to_string()
                                    + staking_pool
                                        .ops_stake_public_key()
                                        .to_string()
                                        .split(":")
                                        .last()
                                        .unwrap()
                            );
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ops_stake_finalize");
                            let args: StakeActionCallbackArgs =
                                serde_json::from_str(&action.args).unwrap();
                            assert_eq!(args.account_id, ACCOUNT);
                            assert_eq!(action.deposit, 0);
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn account_not_registered() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx);
                staking_pool.ops_unstake(None);
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS] STAKE balance is zero")]
            fn zero_stake_balance_and_unstake_specified_amount() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx);
                staking_pool.ops_unstake(Some(YOCTO.into()));
            }

            #[test]
            fn zero_stake_balance_and_unstake_all() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // Act
                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx);
                if let PromiseOrValue::Value(balances) = staking_pool.ops_unstake(None) {
                    assert!(balances.staked.is_none());
                } else {
                    panic!("expected value")
                }
            }

            #[test]
            fn unstake_with_earnings_received() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // stake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());

                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise")
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() - *EARNINGS;
                ctx.account_locked_balance = *EARNINGS;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let staked_balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                let staking_fee = staking_pool.ops_stake_fees().staking_fee * YOCTO;
                assert_eq!(
                    staked_balance.staked.as_ref().unwrap().near_value,
                    (YOCTO - *staking_fee).into()
                );

                // Act
                const EARNINGS: YoctoNear = YoctoNear(YOCTO);
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + *EARNINGS;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    panic!("expected promise")
                }

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [EARNINGS] 1000000000000000000000000",
                    "[INFO] [UNSTAKE] near_amount=1984000000000000000000000, stake_token_amount=992000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)",
                    "[INFO] [FT_BURN] account: bob, amount: 992000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)",
                ]);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() - *EARNINGS;
                ctx.account_locked_balance = *EARNINGS;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                let unstaked_near_value = staking_pool
                    .ops_stake_token_value(Some(staked_balance.staked.as_ref().unwrap().stake));
                assert_eq!(
                    balance.unstaked.as_ref().unwrap().total,
                    unstaked_near_value
                );
            }

            #[test]
            fn unstake_with_dividend_received() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // stake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise")
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() - *EARNINGS;
                ctx.account_locked_balance = *EARNINGS;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let staked_balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                let staking_fee = staking_pool.ops_stake_fees().staking_fee * YOCTO;
                assert_eq!(
                    staked_balance.staked.as_ref().unwrap().near_value,
                    (YOCTO - *staking_fee).into()
                );

                // deposit into treasury
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_treasury_deposit();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Act
                const EARNINGS: YoctoNear = YoctoNear(YOCTO);
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + *EARNINGS;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    panic!("expected promise")
                }

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [EARNINGS] 1000000000000000000000000",
                    "[INFO] [FT_BURN] account: contract.near, amount: 333333333333333333333333",
                    "[INFO] [TREASURY_DIVIDEND] 500000000000000000000000 yoctoNEAR / 333333333333333333333333 yoctoSTAKE",
                    "[INFO] [UNSTAKE] near_amount=1785599999999999999999999, stake_token_amount=992000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)",
                    "[INFO] [FT_BURN] account: bob, amount: 992000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)",
                ]);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() - *EARNINGS;
                ctx.account_locked_balance = *EARNINGS;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                println!("{}", serde_json::to_string_pretty(&balance).unwrap());
                let unstaked_near_value = staking_pool
                    .ops_stake_token_value(Some(staked_balance.staked.as_ref().unwrap().stake));
                assert_eq!(
                    balance.unstaked.as_ref().unwrap().total + balance.storage_balance.available,
                    unstaked_near_value
                );
            }
        }

        #[cfg(test)]
        mod tests_withdraw {
            use super::*;

            #[test]
            fn withdraw_partial() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected Promise");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected Promise");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(Some((1000).into()));

                // Assert
                assert!(test_utils::get_logs().is_empty());

                assert_eq!(
                    balances.unstaked.as_ref().unwrap().total,
                    balances_before_withdrawal.unstaked.as_ref().unwrap().total - 1000
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(action.deposit, 1000);
                    }
                    _ => panic!("expected transfer action"),
                }
            }

            #[test]
            fn withdraw_all() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected Promise");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected Promise");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec!["[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-184)",]
                );

                assert!(balances.unstaked.is_none());

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(
                            action.deposit,
                            *balances_before_withdrawal.unstaked.as_ref().unwrap().total
                        );
                    }
                    _ => panic!("expected transfer action"),
                }
            }

            #[test]
            fn withdraw_available_using_liquidity() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    panic!("expected promise");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                State::add_liquidity((YOCTO / 2).into());
                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec!["[INFO] [LIQUIDITY] removed=500000000000000000000000, total=0",]
                );

                assert_eq!(
                    balances.unstaked.as_ref().unwrap().total,
                    balances_before_withdrawal.unstaked.as_ref().unwrap().total - (YOCTO / 2)
                );
                assert_eq!(
                    balances.unstaked.as_ref().unwrap().available,
                    YoctoNear::ZERO
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(action.deposit, (YOCTO / 2));
                    }
                    _ => panic!("expected transfer action"),
                }
            }

            #[test]
            fn withdraw_available_using_full_liquidity() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    panic!("expected Promise");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // staking adds liquidity
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = *balances_before_withdrawal.unstaked.as_ref().unwrap().total;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                // Act
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-184)",
                        "[INFO] [LIQUIDITY] removed=992000000000000000000000, total=0",
                    ]
                );

                assert!(balances.unstaked.is_none(),);

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(action.deposit, 992000000000000000000000);
                    }
                    _ => panic!("expected transfer action"),
                }
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED] ")]
            fn withdraw_all_not_registered() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_stake_withdraw(None);
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED] ")]
            fn withdraw_some_not_registered() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_stake_withdraw(Some(YOCTO.into()));
            }

            #[test]
            fn withdraw_all_with_zero_unstaked_funds() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                assert!(test_utils::get_logs().is_empty());

                assert_eq!(balances_before_withdrawal, balances);
                assert!(deserialize_receipts().is_empty());
            }

            #[test]
            fn withdraw_all_with_zero_stake_funds() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(None);

                // Assert
                assert!(test_utils::get_logs().is_empty());

                assert_eq!(balances_before_withdrawal, balances);
                assert!(deserialize_receipts().is_empty());
            }

            #[test]
            #[should_panic(expected = "[ERR] [INVALID] amount must be > 0")]
            fn withdraw_some_specifying_zero() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    panic!("expected promise");
                }

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_withdraw(Some(YoctoNear::ZERO));
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS] ")]
            fn withdraw_some_insufficient_funds() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected Promise");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    panic!("expected Promise");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_withdraw(Some(
                    balances_before_withdrawal.unstaked.as_ref().unwrap().total + 1,
                ));
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS] ")]
            fn withdraw_some_but_funds_not_available() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    panic!("expected promise");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 3;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_withdraw(Some(
                    balances_before_withdrawal.unstaked.as_ref().unwrap().total,
                ));
            }

            #[test]
            fn withdraw_some_with_earnings_received() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                // unstake 1/2
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(Some((YOCTO / 2).into()))
                {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected value");
                }

                let balances_before_withdrawal = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();
                let state_before_withdrawal = StakingPoolComponent::state();

                // Act
                ctx.account_balance = env::account_balance() + (YOCTO / 2);
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let balances = staking_pool.ops_stake_withdraw(Some((1000).into()));

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec!["[INFO] [EARNINGS] 500000000000000000000000",]);

                assert_eq!(
                    balances.unstaked.as_ref().unwrap().total,
                    balances_before_withdrawal.unstaked.as_ref().unwrap().total - 1000
                );

                let state = StakingPoolComponent::state();
                assert_eq!(
                    state.last_contract_managed_total_balance,
                    state_before_withdrawal.last_contract_managed_total_balance - 1000
                        + (YOCTO / 2),
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
                match &receipts[0].actions[0] {
                    Action::Transfer(action) => {
                        assert_eq!(action.deposit, 1000);
                    }
                    _ => panic!("expected transfer action"),
                }
            }
        }

        #[cfg(test)]
        mod tests_restake {
            use super::*;

            #[test]
            fn restake_partial() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected Promise");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected Promise");
                }

                let balances_before_restaking = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_restake(Some((1000).into())) {
                    panic!("expected Promise")
                }

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [STAKE] near_amount=1000, stake_token_amount=1000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: bob, amount: 1000",
                        "[INFO] [FT_BURN] account: bob, amount: 8",
                        "[INFO] [FT_MINT] account: owner, amount: 8",
                    ]
                );

                let balances = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();
                println!("{}", serde_json::to_string_pretty(&balances).unwrap());
                assert_eq!(
                    balances.unstaked.as_ref().unwrap().total,
                    balances_before_restaking.unstaked.as_ref().unwrap().total - 1000
                );
                let staking_fee = staking_pool.ops_stake_fees().staking_fee * 1000;
                assert_eq!(
                    balances.staked.as_ref().unwrap().near_value,
                    (1000 - *staking_fee).into()
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::Stake(action) => {
                            assert_eq!(
                                action.stake,
                                *staking_pool.ops_stake_pool_balances().total_staked
                            );

                            assert_eq!(
                                action.public_key,
                                "1".to_string()
                                    + staking_pool
                                        .ops_stake_public_key()
                                        .to_string()
                                        .split(":")
                                        .last()
                                        .unwrap()
                            );
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ops_stake_finalize");
                            let args: StakeActionCallbackArgs =
                                serde_json::from_str(&action.args).unwrap();
                            assert_eq!(args.account_id, ACCOUNT);
                            assert_eq!(action.deposit, 0);
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
            }

            #[test]
            fn restake_all() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.account_balance = env::account_balance();
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));
                account_manager.storage_deposit(None, Some(false));

                // stake storage deposit
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected Promise");
                }

                // unstake all
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_unstake(None) {
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                } else {
                    panic!("expected Promise");
                }

                let balance_before_restaking = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();

                // Act
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_restake(None) {
                    panic!("expected Promise")
                }

                // Assert
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [STAKE] near_amount=992000000000000000000000, stake_token_amount=992000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: bob, amount: 992000000000000000000000",
                        "[INFO] [FT_BURN] account: bob, amount: 7936000000000000000000",
                        "[INFO] [FT_MINT] account: owner, amount: 7936000000000000000000",
                    ]
                );

                let balances = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();
                println!("{}", serde_json::to_string_pretty(&balances).unwrap());
                assert!(balances.unstaked.is_none());
                let staking_fee = staking_pool.ops_stake_fees().staking_fee
                    * balance_before_restaking.unstaked.as_ref().unwrap().total;
                assert_eq!(
                    balances.staked.as_ref().unwrap().near_value,
                    balance_before_restaking.unstaked.as_ref().unwrap().total - staking_fee
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::Stake(action) => {
                            assert_eq!(
                                action.stake,
                                *staking_pool.ops_stake_pool_balances().total_staked
                            );

                            assert_eq!(
                                action.public_key,
                                "1".to_string()
                                    + staking_pool
                                        .ops_stake_public_key()
                                        .to_string()
                                        .split(":")
                                        .last()
                                        .unwrap()
                            );
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ops_stake_finalize");
                            let args: StakeActionCallbackArgs =
                                serde_json::from_str(&action.args).unwrap();
                            assert_eq!(args.account_id, ACCOUNT);
                            assert_eq!(action.deposit, 0);
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn restake_all_with_unregistered_account() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_restake(None);
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn restake_some_with_unregistered_account() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                ctx.account_balance = env::account_balance();
                testing_env!(ctx);
                staking_pool.ops_restake(Some(YOCTO.into()));
            }

            #[test]
            fn restake_all_with_earnings_received() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // stake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());

                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise")
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Unstake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    panic!("expected promise")
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                println!(
                    "{}",
                    serde_json::to_string_pretty(
                        &staking_pool.ops_stake_balance(to_valid_account_id(ACCOUNT))
                    )
                    .unwrap()
                );

                let earnings: YoctoNear = staking_pool.ops_stake_pool_balances().total_staked;
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + *earnings;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                // Act
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_restake(None) {
                    panic!("expected value")
                }
                let balance = staking_pool.ops_stake_balance(to_valid_account_id(ACCOUNT));
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [EARNINGS] 8000000000000000000000",
                    "[INFO] [STAKE] near_amount=992000000000000000000000, stake_token_amount=496000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: bob, amount: 496000000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 3968000000000000000000",
                    "[INFO] [FT_MINT] account: owner, amount: 3968000000000000000000",
                ]);

                println!("{}", serde_json::to_string_pretty(&balance).unwrap());
            }

            #[test]
            fn restake_all_after_withdrawing_half_with_earnings_received() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();
                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // stake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());

                if let PromiseOrValue::Value(_) = staking_pool.ops_stake() {
                    panic!("expected promise")
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Unstake
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_unstake(None) {
                    panic!("expected promise")
                }

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balance = staking_pool.ops_stake_balance(to_valid_account_id(ACCOUNT));
                println!("{}", serde_json::to_string_pretty(&balance).unwrap());

                // Withdraw 1/2
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_withdraw(Some(
                    balance.as_ref().unwrap().unstaked.as_ref().unwrap().total / 2,
                ));

                let earnings: YoctoNear = staking_pool.ops_stake_pool_balances().total_staked;
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance() + *earnings;
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                println!(
                    "{}",
                    serde_json::to_string_pretty(&staking_pool.ops_stake_pool_balances()).unwrap()
                );

                // Act

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Value(_) = staking_pool.ops_restake(None) {
                    panic!("expected value")
                }
                let balance = staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [EARNINGS] 8000000000000000000000",
                    "[INFO] [STAKE] near_amount=496000000000000000000000, stake_token_amount=248000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: bob, amount: 248000000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 1984000000000000000000",
                    "[INFO] [FT_MINT] account: owner, amount: 1984000000000000000000",
                ]);

                println!("{}", serde_json::to_string_pretty(&balance).unwrap());
            }
        }
    }

    #[cfg(test)]
    mod tests_callbacks {
        use super::*;

        #[cfg(test)]
        mod tests_stake_callback {
            use super::*;

            mod tests_online {
                use super::*;

                #[test]
                fn promise_success_with_zero_earnings() {
                    // Arrange
                    let mut ctx = new_context(ACCOUNT);
                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());

                    let mut account_manager = account_manager();
                    let mut staking_pool = staking_pool();

                    // start staking
                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());
                    staking_pool
                        .ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                    assert!(staking_pool.ops_stake_status().is_online());

                    // register account
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, Some(true));

                    // stake
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake();

                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);

                    let receipts = deserialize_receipts();
                    match &receipts[1].actions[0] {
                        Action::FunctionCall(action) => {
                            let args: StakeActionCallbackArgs =
                                serde_json::from_str(&action.args).unwrap();

                            ctx.predecessor_account_id = (&receipts[1]).receiver_id.to_string();
                            ctx.account_balance = env::account_balance()
                                - *staking_pool.ops_stake_pool_balances().total_staked;
                            ctx.account_locked_balance =
                                *staking_pool.ops_stake_pool_balances().total_staked;
                            testing_env_with_promise_result_success(ctx.clone());
                            let state_before_callback = staking_pool.state_with_updated_earnings();
                            let balances = staking_pool.ops_stake_finalize(args.account_id.clone());
                            println!("{}", serde_json::to_string_pretty(&balances).unwrap());
                            assert_eq!(
                                balances,
                                staking_pool
                                    .ops_stake_balance(to_valid_account_id(&args.account_id))
                                    .unwrap()
                            );
                            let state_after_callback = staking_pool.state_with_updated_earnings();
                            assert_eq!(
                                state_before_callback.last_contract_managed_total_balance,
                                state_after_callback.last_contract_managed_total_balance
                            );
                        }
                        _ => panic!("expected function call"),
                    }
                }

                #[test]
                fn promise_failure() {
                    // Arrange
                    let mut ctx = new_context(ACCOUNT);
                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());

                    let mut account_manager = account_manager();
                    let mut staking_pool = staking_pool();

                    // start staking
                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());
                    staking_pool
                        .ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                    assert!(staking_pool.ops_stake_status().is_online());

                    // register account
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, Some(true));

                    // stake
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake();

                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);

                    let receipts = deserialize_receipts();
                    match &receipts[1].actions[0] {
                        Action::FunctionCall(action) => {
                            let args: StakeActionCallbackArgs =
                                serde_json::from_str(&action.args).unwrap();

                            ctx.predecessor_account_id = (&receipts[1]).receiver_id.to_string();
                            ctx.account_balance = env::account_balance()
                                - *staking_pool.ops_stake_pool_balances().total_staked;
                            ctx.account_locked_balance =
                                *staking_pool.ops_stake_pool_balances().total_staked;
                            testing_env_with_promise_result_failure(ctx.clone());
                            let state_before_callback = staking_pool.state_with_updated_earnings();
                            let balances = staking_pool.ops_stake_finalize(args.account_id.clone());
                            println!("{}", serde_json::to_string_pretty(&balances).unwrap());
                            assert_eq!(
                                balances,
                                staking_pool
                                    .ops_stake_balance(to_valid_account_id(&args.account_id))
                                    .unwrap()
                            );
                            let state_after_callback = staking_pool.state_with_updated_earnings();
                            assert_eq!(
                                state_before_callback.last_contract_managed_total_balance,
                                state_after_callback.last_contract_managed_total_balance
                            );

                            let receipts = deserialize_receipts();
                            assert_eq!(receipts.len(), 2);
                            {
                                let receipt = &receipts[0];
                                assert_eq!(receipt.receiver_id, env::current_account_id());
                                assert_eq!(receipt.actions.len(), 1);
                                match &receipt.actions[0] {
                                    Action::Stake(action) => {
                                        assert_eq!(action.stake, 0);

                                        assert_eq!(
                                            action.public_key,
                                            "1".to_string()
                                                + staking_pool
                                                    .ops_stake_public_key()
                                                    .to_string()
                                                    .split(":")
                                                    .last()
                                                    .unwrap()
                                        );
                                    }
                                    _ => panic!("expected StakeAction"),
                                }
                            }
                            {
                                let receipt = &receipts[1];
                                assert_eq!(receipt.receiver_id, env::current_account_id());
                                assert_eq!(receipt.actions.len(), 1);
                                match &receipt.actions[0] {
                                    Action::FunctionCall(action) => {
                                        assert_eq!(action.method_name, "ops_stake_stop_finalize");
                                        assert!(action.args.is_empty());
                                        assert_eq!(action.deposit, 0);
                                    }
                                    _ => panic!("expected StakeAction"),
                                }
                            }
                        }
                        _ => panic!("expected function call"),
                    }
                }
            }
        }

        #[cfg(test)]
        mod tests_start_finalize_callback {
            use super::*;

            #[test]
            fn promise_success() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // Act
                ctx.predecessor_account_id = env::current_account_id();
                testing_env_with_promise_result_success(ctx.clone());
                staking_pool.ops_stake_start_finalize();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec!["[INFO] [STATUS_ONLINE] staked"])
            }

            #[test]
            fn promise_failure_with_zero_staked_balance() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // Act
                ctx.predecessor_account_id = env::current_account_id();
                testing_env_with_promise_result_failure(ctx.clone());
                staking_pool.ops_stake_start_finalize();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[ERR] [STAKE_ACTION_FAILED] ",
                        "[WARN] [STATUS_OFFLINE] StakeActionFailed",
                    ]
                );

                assert!(deserialize_receipts().is_empty());
            }

            #[test]
            fn promise_failure_with_non_zero_staked_balance() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_treasury_deposit();
                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());

                // Act
                ctx.predecessor_account_id = env::current_account_id();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = *pool_balances.total_staked;
                ctx.attached_deposit = 0;
                testing_env_with_promise_result_failure(ctx.clone());
                staking_pool.ops_stake_start_finalize();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[ERR] [STAKE_ACTION_FAILED] ",
                        "[WARN] [STATUS_OFFLINE] StakeActionFailed",
                    ]
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    match &receipt.actions[0] {
                        Action::Stake(action) => {
                            assert_eq!(action.stake, 0);
                        }
                        _ => panic!("expected stake action"),
                    }
                }
                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    match &receipt.actions[0] {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ops_stake_stop_finalize");
                        }
                        _ => panic!("expected stake action"),
                    }
                }
            }
        }

        #[cfg(test)]
        mod tests_stop_finalize_callback {
            use super::*;

            #[test]
            fn promise_success() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();

                // Act
                ctx.predecessor_account_id = env::current_account_id();
                testing_env_with_promise_result_success(ctx.clone());
                staking_pool.ops_stake_stop_finalize();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec!["[WARN] [STATUS_OFFLINE] all NEAR has been unstaked"]
                )
            }

            #[test]
            fn promise_failure() {
                // Arrange
                let mut ctx = new_context(ACCOUNT);
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // Act
                ctx.predecessor_account_id = env::current_account_id();
                testing_env_with_promise_result_failure(ctx.clone());
                staking_pool.ops_stake_stop_finalize();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[ERR] [STAKE_ACTION_FAILED] failed to unstake when trying to stop staking pool",
                    ]
                );
            }
        }
    }

    #[cfg(test)]
    mod tests_operator_commands {
        use super::*;

        #[cfg(test)]
        mod tests_start_staking {
            use super::*;

            #[test]
            #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
            fn not_as_operator() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn account_not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
            }

            #[test]
            fn initial_startup_with_zero_staked() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec!["[INFO] [STATUS_ONLINE] ",]);

                let pool_balances = staking_pool.ops_stake_pool_balances();
                println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                assert_eq!(pool_balances.total_staked, YoctoNear::ZERO);
                assert_eq!(pool_balances.total_unstaked, YoctoNear::ZERO);
                assert_eq!(pool_balances.unstaked_liquidity, YoctoNear::ZERO);
                assert_eq!(pool_balances.treasury_balance, YoctoNear::ZERO);

                assert!(deserialize_receipts().is_empty());
            }

            #[test]
            fn startup_with_non_zero_staked_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let contract_managed_total_balance = State::contract_managed_total_balance();

                let mut account_manager = account_manager();
                let mut staking_pool = staking_pool();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                // assert that there was no net change to contract_managed_total_balance
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    contract_managed_total_balance,
                    State::contract_managed_total_balance()
                );

                assert_eq!(
                    account_manager
                        .storage_balance_of(to_valid_account_id(ACCOUNT))
                        .unwrap()
                        .available,
                    YoctoNear::ZERO
                );

                // stake
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    panic!("expected Value");
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Act - start staking
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);

                // Assert
                assert!(staking_pool.ops_stake_status().is_online());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec!["[INFO] [STATUS_ONLINE] ",]);

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::Stake(action) => {
                            assert_eq!(
                                action.stake,
                                *staking_pool.ops_stake_pool_balances().total_staked
                            );

                            assert_eq!(
                                action.public_key,
                                "1".to_string()
                                    + staking_pool
                                        .ops_stake_public_key()
                                        .to_string()
                                        .split(":")
                                        .last()
                                        .unwrap()
                            );
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ops_stake_start_finalize");
                            assert!(action.args.is_empty());
                            assert_eq!(action.deposit, 0);
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
            }

            #[test]
            fn start_while_already_started() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // stake
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                if let PromiseOrValue::Promise(_) = staking_pool.ops_stake() {
                    panic!("expected Value");
                }
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Act - start staking 2x
                for i in 0..2 {
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());
                    staking_pool
                        .ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);

                    let receipts = deserialize_receipts();
                    if i == 1 {
                        assert_eq!(logs, vec!["[INFO] [STATUS_ONLINE] already online",]);
                        assert!(receipts.is_empty());
                    }
                }

                assert!(staking_pool.ops_stake_status().is_online());
            }
        }

        #[cfg(test)]
        mod tests_stop_staking {
            use super::*;

            #[test]
            #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
            fn not_as_operator() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StopStaking);
            }

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn account_not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StopStaking);
            }

            #[test]
            fn start_then_stop_with_zero_staked_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // Act - stop staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StopStaking);
                assert!(!staking_pool.ops_stake_status().is_online());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec!["[WARN] [STATUS_OFFLINE] Stopped",]);

                assert!(deserialize_receipts().is_empty());
            }

            #[test]
            fn start_then_stop_with_nonzero_staked_balance_and_nonzero_locked_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // stake
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = *staking_pool.ops_stake_pool_balances().total_staked;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StopStaking);
                assert!(!staking_pool.ops_stake_status().is_online());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec!["[WARN] [STATUS_OFFLINE] Stopped",]);

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::Stake(action) => {
                            assert_eq!(action.stake, 0);

                            assert_eq!(
                                action.public_key,
                                "1".to_string()
                                    + staking_pool
                                        .ops_stake_public_key()
                                        .to_string()
                                        .split(":")
                                        .last()
                                        .unwrap()
                            );
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ops_stake_stop_finalize");
                            assert!(action.args.is_empty());
                            assert_eq!(action.deposit, 0);
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
            }

            #[test]
            fn start_then_stop_with_nonzero_staked_balance_and_zero_locked_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // stake
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // Act
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = 0;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StopStaking);

                // Assert
                assert!(!staking_pool.ops_stake_status().is_online());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec!["[WARN] [STATUS_OFFLINE] Stopped",]);

                assert!(deserialize_receipts().is_empty());
            }

            #[test]
            fn already_stopped_with_nonzero_locked_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                assert!(!staking_pool.ops_stake_status().is_online());

                // start staking
                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                assert!(staking_pool.ops_stake_status().is_online());

                // stake
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                // stop staking
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = *staking_pool.ops_stake_pool_balances().total_staked;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StopStaking);
                assert!(!staking_pool.ops_stake_status().is_online());
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(deserialize_receipts().len(), 2);

                // Act
                ctx.predecessor_account_id = OWNER.to_string();
                ctx.account_balance = env::account_balance();
                ctx.account_locked_balance = *staking_pool.ops_stake_pool_balances().total_staked;
                testing_env!(ctx.clone());
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StopStaking);

                // Assert
                assert!(!staking_pool.ops_stake_status().is_online());
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec!["[WARN] [STATUS_OFFLINE] Stopped - but was already offline",]
                );

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 2);
                {
                    let receipt = &receipts[0];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::Stake(action) => {
                            assert_eq!(action.stake, 0);

                            assert_eq!(
                                action.public_key,
                                "1".to_string()
                                    + staking_pool
                                        .ops_stake_public_key()
                                        .to_string()
                                        .split(":")
                                        .last()
                                        .unwrap()
                            );
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
                {
                    let receipt = &receipts[1];
                    assert_eq!(receipt.receiver_id, env::current_account_id());
                    assert_eq!(receipt.actions.len(), 1);
                    match &receipt.actions[0] {
                        Action::FunctionCall(action) => {
                            assert_eq!(action.method_name, "ops_stake_stop_finalize");
                            assert!(action.args.is_empty());
                            assert_eq!(action.deposit, 0);
                        }
                        _ => panic!("expected StakeAction"),
                    }
                }
            }
        }

        #[cfg(test)]
        mod tests_update_public_key {
            use super::*;

            #[test]
            fn update_public_key_when_pool_offline() {
                let pk1: PublicKey = serde_json::from_str(
                    r#""ed25519:AC1pVDXsE8sZiLAqLTDa3sD8DH74U5yUDaYKWeBwwyJj""#,
                )
                .unwrap();

                let pk2: PublicKey = serde_json::from_str(
                    r#""ed25519:AC1pVDXsE8sZiLAqLTDa3sD8DH74U5yUDaYKWeBwwyJp""#,
                )
                .unwrap();

                // Arrange
                let ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();

                testing_env!(ctx.clone());
                staking_pool
                    .ops_stake_operator_command(StakingPoolOperatorCommand::UpdatePublicKey(pk1));
                assert_eq!(staking_pool.ops_stake_public_key(), pk1);

                testing_env!(ctx.clone());
                staking_pool
                    .ops_stake_operator_command(StakingPoolOperatorCommand::UpdatePublicKey(pk2));
                assert_eq!(staking_pool.ops_stake_public_key(), pk2);
            }

            #[test]
            #[should_panic(
                expected = "[ERR] [ILLEGAL_STATE] staking pool must be offline to update the staking public key"
            )]
            fn update_public_key_when_pool_online() {
                let pk1: PublicKey = serde_json::from_str(
                    r#""ed25519:AC1pVDXsE8sZiLAqLTDa3sD8DH74U5yUDaYKWeBwwyJj""#,
                )
                .unwrap();

                // Arrange
                let ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);

                testing_env!(ctx.clone());
                staking_pool
                    .ops_stake_operator_command(StakingPoolOperatorCommand::UpdatePublicKey(pk1));
            }
        }

        #[cfg(test)]
        mod tests_update_staking_fee {
            use super::*;

            #[test]
            fn update_fee() {
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                let mut staking_pool = staking_pool();
                let mut fees = staking_pool.ops_stake_fees();
                fees.staking_fee += 1;
                staking_pool
                    .ops_stake_operator_command(StakingPoolOperatorCommand::UpdateFees(fees));
                assert_eq!(
                    *staking_pool.ops_stake_fees().staking_fee,
                    *fees.staking_fee
                );

                fees.staking_fee = MAX_FEE;
                staking_pool
                    .ops_stake_operator_command(StakingPoolOperatorCommand::UpdateFees(fees));
                assert_eq!(staking_pool.ops_stake_fees().staking_fee, MAX_FEE);
            }

            #[test]
            #[should_panic(expected = "[ERR] [INVALID] max staking fee is 1000 BPS (10%)")]
            fn update_fee_above_max() {
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                let mut staking_pool = staking_pool();
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::UpdateFees(
                    Fees {
                        staking_fee: (*MAX_FEE + 1).into(),
                        earnings_fee: 0.into(),
                    },
                ));
            }

            #[test]
            #[should_panic(
                expected = "[ERR] [INVALID] min fee is 1 BPS (0.01%) for at least 1 fee type"
            )]
            fn update_fee_to_zero() {
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = OWNER.to_string();
                testing_env!(ctx.clone());

                let mut staking_pool = staking_pool();
                staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::UpdateFees(
                    Fees {
                        earnings_fee: 0.into(),
                        staking_fee: 0.into(),
                    },
                ));
            }
        }
    }

    #[cfg(test)]
    mod tests_treasury {
        use super::*;

        #[cfg(test)]
        mod tests_online {
            use super::*;

            #[cfg(test)]
            mod tests_deposit {
                use super::*;

                #[test]
                fn nonzero_attached_deposit() {
                    // Arrange
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());

                    let mut staking_pool = staking_pool();

                    // start staking
                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());
                    staking_pool
                        .ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                    assert!(staking_pool.ops_stake_status().is_online());

                    let ft_stake = ft_stake();
                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(&env::current_account_id())),
                        TokenAmount::ZERO
                    );
                    let state = StakingPoolComponent::state();
                    assert_eq!(state.treasury_balance, YoctoNear::ZERO);

                    // Act
                    {
                        ctx.predecessor_account_id = ACCOUNT.to_string();
                        ctx.attached_deposit = YOCTO;
                        ctx.account_balance = env::account_balance();
                        testing_env!(ctx.clone());
                        if let PromiseOrValue::Value(_) = staking_pool.ops_stake_treasury_deposit()
                        {
                            panic!("expected Promise")
                        }
                    }

                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(logs, vec![
                        "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: contract.near, amount: 1000000000000000000000000",
                    ]);

                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(&env::current_account_id())),
                        YOCTO.into()
                    );

                    let state = StakingPoolComponent::state();
                    assert_eq!(state.treasury_balance, YOCTO.into());

                    let receipts = deserialize_receipts();
                    assert_eq!(receipts.len(), 2);
                    {
                        let receipt = &receipts[0];
                        assert_eq!(receipt.receiver_id, env::current_account_id());
                        assert_eq!(receipt.actions.len(), 1);
                        match &receipt.actions[0] {
                            Action::Stake(action) => {
                                assert_eq!(
                                    action.stake,
                                    *staking_pool.ops_stake_pool_balances().total_staked
                                );

                                assert_eq!(
                                    action.public_key,
                                    "1".to_string()
                                        + staking_pool
                                            .ops_stake_public_key()
                                            .to_string()
                                            .split(":")
                                            .last()
                                            .unwrap()
                                );
                            }
                            _ => panic!("expected StakeAction"),
                        }
                    }
                    {
                        let receipt = &receipts[1];
                        assert_eq!(receipt.receiver_id, env::current_account_id());
                        assert_eq!(receipt.actions.len(), 1);
                        match &receipt.actions[0] {
                            Action::FunctionCall(action) => {
                                assert_eq!(action.method_name, "ops_stake_finalize");
                                let args: StakeActionCallbackArgs =
                                    serde_json::from_str(&action.args).unwrap();
                                assert_eq!(args.account_id, env::current_account_id());
                                assert_eq!(action.deposit, 0);
                            }
                            _ => panic!("expected StakeAction"),
                        }
                    }

                    // Act - deposit again
                    {
                        ctx.predecessor_account_id = ACCOUNT.to_string();
                        ctx.attached_deposit = YOCTO;
                        ctx.account_balance = env::account_balance();
                        testing_env!(ctx.clone());
                        if let PromiseOrValue::Value(_) = staking_pool.ops_stake_treasury_deposit()
                        {
                            panic!("expected Promise")
                        }
                    }

                    // Assert
                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(logs, vec![
                        "[INFO] [STAKE] near_amount=1000000000000000000000000, stake_token_amount=1000000000000000000000000",
                        "[INFO] [FT_MINT] account: contract.near, amount: 1000000000000000000000000",
                    ]);

                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(&env::current_account_id())),
                        (2 * YOCTO).into()
                    );

                    let state = StakingPoolComponent::state();
                    assert_eq!(state.treasury_balance, (2 * YOCTO).into());

                    assert_eq!(
                        *staking_pool.ops_stake_pool_balances().total_staked,
                        2 * YOCTO
                    );

                    let receipts = deserialize_receipts();
                    assert_eq!(receipts.len(), 2);
                    {
                        let receipt = &receipts[0];
                        assert_eq!(receipt.receiver_id, env::current_account_id());
                        assert_eq!(receipt.actions.len(), 1);
                        match &receipt.actions[0] {
                            Action::Stake(action) => {
                                assert_eq!(
                                    action.stake,
                                    *staking_pool.ops_stake_pool_balances().total_staked
                                );

                                assert_eq!(
                                    action.public_key,
                                    "1".to_string()
                                        + staking_pool
                                            .ops_stake_public_key()
                                            .to_string()
                                            .split(":")
                                            .last()
                                            .unwrap()
                                );
                            }
                            _ => panic!("expected StakeAction"),
                        }
                    }
                    {
                        let receipt = &receipts[1];
                        assert_eq!(receipt.receiver_id, env::current_account_id());
                        assert_eq!(receipt.actions.len(), 1);
                        match &receipt.actions[0] {
                            Action::FunctionCall(action) => {
                                assert_eq!(action.method_name, "ops_stake_finalize");
                                let args: StakeActionCallbackArgs =
                                    serde_json::from_str(&action.args).unwrap();
                                assert_eq!(args.account_id, env::current_account_id());
                                assert_eq!(action.deposit, 0);
                            }
                            _ => panic!("expected StakeAction"),
                        }
                    }
                }

                #[test]
                #[should_panic(expected = "[ERR] [NEAR_DEPOSIT_REQUIRED] ")]
                fn zero_attached_deposit() {
                    // Arrange
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());

                    let mut staking_pool = staking_pool();

                    // Act
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = 0;
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_deposit();
                }
            }

            #[cfg(test)]
            mod tests_distribution {
                use super::*;

                #[test]
                fn nonzero_attached_deposit() {
                    // Arrange
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());

                    let mut staking_pool = staking_pool();

                    // start staking
                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());
                    staking_pool
                        .ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                    assert!(staking_pool.ops_stake_status().is_online());

                    let ft_stake = ft_stake();
                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(&env::current_account_id())),
                        TokenAmount::ZERO
                    );

                    // Act
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = YOCTO;
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_distribution();

                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);

                    assert_eq!(
                        ft_stake.ft_balance_of(to_valid_account_id(&env::current_account_id())),
                        TokenAmount::ZERO
                    );

                    let receipts = deserialize_receipts();
                    assert_eq!(receipts.len(), 2);
                    {
                        let receipt = &receipts[0];
                        assert_eq!(receipt.receiver_id, env::current_account_id());
                        assert_eq!(receipt.actions.len(), 1);
                        match &receipt.actions[0] {
                            Action::Stake(action) => {
                                assert_eq!(
                                    action.stake,
                                    *staking_pool.ops_stake_pool_balances().total_staked
                                );

                                assert_eq!(
                                    action.public_key,
                                    "1".to_string()
                                        + staking_pool
                                            .ops_stake_public_key()
                                            .to_string()
                                            .split(":")
                                            .last()
                                            .unwrap()
                                );
                            }
                            _ => panic!("expected StakeAction"),
                        }
                    }
                    {
                        let receipt = &receipts[1];
                        assert_eq!(receipt.receiver_id, env::current_account_id());
                        assert_eq!(receipt.actions.len(), 1);
                        match &receipt.actions[0] {
                            Action::FunctionCall(action) => {
                                assert_eq!(action.method_name, "ops_stake_finalize");
                                let args: StakeActionCallbackArgs =
                                    serde_json::from_str(&action.args).unwrap();
                                assert_eq!(args.account_id, env::current_account_id());
                                assert_eq!(action.deposit, 0);
                            }
                            _ => panic!("expected StakeAction"),
                        }
                    }
                }

                #[test]
                fn zero_attached_deposit_with_earnings_with_zero_total_supply() {
                    // Arrange
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();

                    // start staking
                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());
                    staking_pool
                        .ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                    assert!(staking_pool.ops_stake_status().is_online());

                    // Act
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = 0;
                    ctx.account_balance = env::account_balance() + YOCTO;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_distribution();

                    // Assert - when STAKE total supply is zero, then earnings are not distribute and
                    // we expect no stake action
                    assert!(test_utils::get_logs().is_empty());
                    assert!(deserialize_receipts().is_empty());
                }

                #[test]
                fn zero_attached_deposit_with_earnings_with_nonzero_total_supply() {
                    // Arrange
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();

                    // start staking
                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());
                    staking_pool
                        .ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                    assert!(staking_pool.ops_stake_status().is_online());

                    // register account
                    let mut account_manager = account_manager();
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = YOCTO;
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, None);

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = YOCTO;
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake();

                    // Act
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = 0;
                    ctx.account_balance = env::account_balance() + YOCTO;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_distribution();

                    let logs = test_utils::get_logs();
                    println!("{:#?}", logs);
                    assert_eq!(logs, vec!["[INFO] [EARNINGS] 1000000000000000000000000",]);

                    let receipts = deserialize_receipts();
                    assert_eq!(receipts.len(), 2);
                    {
                        let receipt = &receipts[0];
                        assert_eq!(receipt.receiver_id, env::current_account_id());
                        match &receipt.actions[0] {
                            Action::Stake(action) => {
                                assert_eq!(action.stake, *State::total_staked_balance());
                            }
                            _ => panic!("expected Stake"),
                        }
                    }
                    {
                        let receipt = &receipts[1];
                        assert_eq!(receipt.receiver_id, env::current_account_id());
                        match &receipt.actions[0] {
                            Action::FunctionCall(action) => {
                                assert_eq!(action.method_name, "ops_stake_finalize");
                                let args: StakeActionCallbackArgs =
                                    serde_json::from_str(&action.args).unwrap();
                                assert_eq!(args.account_id, env::current_account_id());
                            }
                            _ => panic!("expected FunctionCall"),
                        }
                    }
                }

                #[test]
                fn zero_attached_deposit_with_zero_earnings_with_nonzero_total_supply() {
                    // Arrange
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();

                    // start staking
                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());
                    staking_pool
                        .ops_stake_operator_command(StakingPoolOperatorCommand::StartStaking);
                    assert!(staking_pool.ops_stake_status().is_online());

                    // register account
                    let mut account_manager = account_manager();
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = YOCTO;
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, None);

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = YOCTO;
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake();

                    // Act
                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = 0;
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_distribution();

                    assert!(test_utils::get_logs().is_empty());
                    assert!(deserialize_receipts().is_empty());
                }
            }

            #[cfg(test)]
            mod tests_transfer_to_owner {
                use super::*;

                #[test]
                #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
                fn not_registered() {
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_transfer_to_owner(None);
                }

                #[test]
                #[should_panic(expected = "[ERR] [NOT_AUTHORIZED]")]
                fn not_authorized() {
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();
                    let mut account_manager = account_manager();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, None);

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_transfer_to_owner(None);
                }

                #[test]
                fn as_treasurer_transfer_all_with_empty_treasury() {
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();
                    let mut account_manager = account_manager();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, None);

                    ctx.predecessor_account_id = OWNER.to_string();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_grant_treasurer(to_valid_account_id(ACCOUNT));

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_transfer_to_owner(None);
                }

                #[test]
                fn as_owner_transfer_all_with_empty_treasury() {
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();

                    ctx.predecessor_account_id = OWNER.to_string();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_transfer_to_owner(None);
                }

                #[test]
                fn as_treasurer_transfer_all() {
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();
                    let mut account_manager = account_manager();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, None);

                    ctx.predecessor_account_id = OWNER.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_grant_treasurer(to_valid_account_id(ACCOUNT));

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_deposit();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                    assert_eq!(pool_balances.treasury_balance, YOCTO.into());
                    let owner_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    assert!(owner_balance.staked.is_none());

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_transfer_to_owner(None);

                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                    assert_eq!(pool_balances.treasury_balance, YoctoNear::ZERO);
                    let owner_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    assert_eq!(owner_balance.staked.as_ref().unwrap().stake, YOCTO.into());
                }

                #[test]
                fn as_treasurer_transfer_some() {
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();
                    let mut account_manager = account_manager();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, None);

                    ctx.predecessor_account_id = OWNER.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_grant_treasurer(to_valid_account_id(ACCOUNT));

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_deposit();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                    assert_eq!(pool_balances.treasury_balance, YOCTO.into());
                    let owner_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    assert!(owner_balance.staked.is_none());

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_transfer_to_owner(Some((YOCTO / 4).into()));

                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                    assert_eq!(pool_balances.treasury_balance, (YOCTO * 3 / 4).into());
                    let owner_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    assert_eq!(
                        owner_balance.staked.as_ref().unwrap().stake,
                        (YOCTO / 4).into()
                    );
                }

                #[test]
                fn as_owner_transfer_all() {
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();
                    let mut account_manager = account_manager();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, None);

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_deposit();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                    assert_eq!(pool_balances.treasury_balance, YOCTO.into());
                    let owner_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    assert!(owner_balance.staked.is_none());

                    ctx.predecessor_account_id = OWNER.to_string();
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_transfer_to_owner(None);

                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                    assert_eq!(pool_balances.treasury_balance, YoctoNear::ZERO);
                    let owner_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    assert_eq!(owner_balance.staked.as_ref().unwrap().stake, YOCTO.into());
                }

                #[test]
                fn as_owner_transfer_some() {
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();
                    let mut account_manager = account_manager();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, None);

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_deposit();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                    assert_eq!(pool_balances.treasury_balance, YOCTO.into());
                    let owner_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    assert!(owner_balance.staked.is_none());

                    ctx.predecessor_account_id = OWNER.to_string();
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_transfer_to_owner(Some((YOCTO / 4).into()));

                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                    assert_eq!(pool_balances.treasury_balance, (YOCTO * 3 / 4).into());
                    let owner_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    assert_eq!(
                        owner_balance.staked.as_ref().unwrap().stake,
                        (YOCTO / 4).into()
                    );
                }

                #[test]
                #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
                fn as_owner_transfer_some_insufficient_funds() {
                    let mut ctx = new_context(OWNER);
                    testing_env!(ctx.clone());

                    deploy_stake_contract(staking_public_key());
                    let mut staking_pool = staking_pool();
                    let mut account_manager = account_manager();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    account_manager.storage_deposit(None, None);

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = YOCTO;
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_deposit();

                    ctx.predecessor_account_id = ACCOUNT.to_string();
                    ctx.account_balance = env::account_balance();
                    ctx.attached_deposit = 0;
                    testing_env!(ctx.clone());
                    let pool_balances = staking_pool.ops_stake_pool_balances();
                    println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
                    assert_eq!(pool_balances.treasury_balance, YOCTO.into());
                    let owner_balance = staking_pool
                        .ops_stake_balance(to_valid_account_id(OWNER))
                        .unwrap();
                    assert!(owner_balance.staked.is_none());

                    ctx.predecessor_account_id = OWNER.to_string();
                    ctx.account_balance = env::account_balance();
                    testing_env!(ctx.clone());
                    staking_pool.ops_stake_treasury_transfer_to_owner(Some((YOCTO + 1).into()));
                }
            }

            #[test]
            fn treasurer_access_control() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());
                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = OWNER.to_string();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert!(!staking_pool.ops_stake_is_treasurer(to_valid_account_id(ACCOUNT)));

                staking_pool.ops_stake_grant_treasurer(to_valid_account_id(ACCOUNT));
                assert!(staking_pool.ops_stake_is_treasurer(to_valid_account_id(ACCOUNT)));

                staking_pool.ops_stake_revoke_treasurer(to_valid_account_id(ACCOUNT));
                assert!(!staking_pool.ops_stake_is_treasurer(to_valid_account_id(ACCOUNT)));
            }
        }
    }

    #[cfg(test)]
    mod tests_ft_transfer {
        use super::*;

        #[test]
        fn transfer_with_earnings_received() {
            // Arrange
            let mut ctx = new_context(OWNER);
            testing_env!(ctx.clone());

            deploy_stake_contract(staking_public_key());

            let mut staking_pool = staking_pool();
            let mut account_manager = account_manager();

            // register account
            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, Some(true));

            // register account
            ctx.predecessor_account_id = "alice".to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, Some(true));

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            let initial_balance = if let PromiseOrValue::Value(balance) = staking_pool.ops_stake() {
                balance
            } else {
                panic!("expected vale")
            };

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance() + YOCTO;
            ctx.attached_deposit = 1;
            testing_env!(ctx.clone());
            let transfer_amount =
                staking_pool.ops_stake_transfer(to_valid_account_id("alice"), YOCTO.into(), None);

            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                logs,
                vec![
                    "[INFO] [EARNINGS] 1000000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                ]
            );

            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 0;
            ctx.is_view = true;
            testing_env!(ctx.clone());

            println!("transfer_amount={}", transfer_amount);
            assert_eq!(
                staking_pool.ops_stake_token_value(Some(transfer_amount)),
                YOCTO.into()
            );

            assert_eq!(
                staking_pool
                    .stake_token
                    .ft_balance_of(to_valid_account_id("alice")),
                transfer_amount
            );

            assert_eq!(
                staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .as_ref()
                    .unwrap()
                    .staked
                    .as_ref()
                    .unwrap()
                    .stake
                    + transfer_amount,
                initial_balance.staked.as_ref().unwrap().stake
            )
        }

        #[test]
        fn ft_transfer() {
            // Arrange
            let mut ctx = new_context(OWNER);
            testing_env!(ctx.clone());

            deploy_stake_contract(staking_public_key());

            let mut staking_pool = staking_pool();
            let mut account_manager = account_manager();
            let mut ft_stake = ft_stake();

            // register account
            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, Some(true));

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 10 * YOCTO;
            testing_env!(ctx.clone());
            staking_pool.ops_stake();

            // Act - transfer 1 STAKE to treasury
            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 1;
            testing_env!(ctx.clone());
            ft_stake.ft_transfer(
                to_valid_account_id(env::current_account_id().as_str()),
                YOCTO.into(),
                None,
            );

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 0;
            testing_env!(ctx.clone());

            let pool_balances = staking_pool.ops_stake_pool_balances();
            println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
            assert_eq!(pool_balances.treasury_balance, YoctoNear::ZERO);

            let stake_account_balances = staking_pool
                .ops_stake_balance(to_valid_account_id(env::current_account_id().as_str()))
                .unwrap();
            assert_eq!(
                stake_account_balances.staked.as_ref().unwrap().stake,
                YOCTO.into()
            );

            // process earnings
            staking_pool.ops_stake_token_value_with_earnings(None);

            // Assert - earnings have now been deposited into the treasury for the dividend
            let pool_balances = staking_pool.ops_stake_pool_balances();
            println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
            assert_eq!(
                pool_balances.treasury_balance,
                stake_account_balances.staked.as_ref().unwrap().near_value
            );

            // Act - transfer another 1 STAKE to treasury
            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 1;
            testing_env!(ctx.clone());
            ft_stake.ft_transfer(
                to_valid_account_id(env::current_account_id().as_str()),
                YOCTO.into(),
                None,
            );

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 0;
            testing_env!(ctx.clone());

            let pool_balances = staking_pool.ops_stake_pool_balances();
            println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());

            // process earnings
            staking_pool.ops_stake_token_value_with_earnings(None);

            // Assert - 2nd transfer was treated as a distribution, i.e., transferred STAKE was burned
            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(logs, vec![
                "[INFO] [EARNINGS] 1",
                "[INFO] [FT_BURN] account: contract.near, amount: 999999999999999999999999",
                "[INFO] [TREASURY_DIVIDEND] 1000000000000000000000000 yoctoNEAR / 999999999999999999999999 yoctoSTAKE",
            ]);

            let pool_balances = staking_pool.ops_stake_pool_balances();
            println!("{}", serde_json::to_string_pretty(&pool_balances).unwrap());
            assert_eq!(
                pool_balances,
                serde_json::from_str(
                    r#"{
  "total_staked": "10000000000000000000000002",
  "total_stake_supply": "9000000000000000000000001",
  "total_unstaked": "0",
  "unstaked_liquidity": "0",
  "treasury_balance": "1111111111111111111111112",
  "current_contract_managed_total_balance": "13172980000000000000000002",
  "last_contract_managed_total_balance": "13172980000000000000000002",
  "earnings": "0"
}"#
                )
                .unwrap()
            );

            let treasury_stake_account = staking_pool
                .ops_stake_balance(to_valid_account_id(env::current_account_id().as_str()))
                .unwrap();
            assert_eq!(
                treasury_stake_account,
                serde_json::from_str(
                    r#"{
  "storage_balance": {
    "total": "3930000000000000000000",
    "available": "0"
  },
  "staked": {
    "stake": "1000000000000000000000001",
    "near_value": "1111111111111111111111112"
  },
  "unstaked": null
}"#
                )
                .unwrap()
            );
        }

        #[test]
        fn transfer_call_with_earnings_received() {
            // Arrange
            let mut ctx = new_context(OWNER);
            testing_env!(ctx.clone());

            deploy_stake_contract(staking_public_key());

            let mut staking_pool = staking_pool();
            let mut account_manager = account_manager();

            // register account
            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, Some(true));

            // register account
            ctx.predecessor_account_id = "alice".to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, Some(true));

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            let initial_balance = if let PromiseOrValue::Value(balance) = staking_pool.ops_stake() {
                balance
            } else {
                panic!("expected vale")
            };

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance() + YOCTO;
            ctx.attached_deposit = 1;
            testing_env!(ctx.clone());
            staking_pool.ops_stake_transfer_call(
                to_valid_account_id("alice"),
                YOCTO.into(),
                None,
                TransferCallMessage("".to_string()),
            );

            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                logs,
                vec![
                    "[INFO] [EARNINGS] 1000000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                ]
            );

            let receipts = deserialize_receipts();
            assert_eq!(receipts.len(), 2);

            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 0;
            ctx.is_view = true;
            testing_env!(ctx.clone());

            let transfer_amount = TokenAmount::from(YOCTO / 2);
            assert_eq!(
                staking_pool.ops_stake_token_value(Some(transfer_amount)),
                YOCTO.into()
            );

            assert_eq!(
                staking_pool
                    .stake_token
                    .ft_balance_of(to_valid_account_id("alice")),
                transfer_amount
            );

            assert_eq!(
                staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .as_ref()
                    .unwrap()
                    .staked
                    .as_ref()
                    .unwrap()
                    .stake
                    + transfer_amount,
                initial_balance.staked.as_ref().unwrap().stake
            );
        }

        #[test]
        fn ft_on_transfer() {
            // Arrange
            let mut ctx = new_context(OWNER);
            testing_env!(ctx.clone());

            deploy_stake_contract(staking_public_key());

            let mut staking_pool = staking_pool();
            let mut account_manager = account_manager();

            // register account
            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, Some(true));

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 10 * YOCTO;
            testing_env!(ctx.clone());
            staking_pool.ops_stake();

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 1;
            testing_env!(ctx.clone());
            let msg = TransferCallMessage("".to_string());
            staking_pool.ops_stake_transfer_call(
                to_valid_account_id(&env::current_account_id()),
                YOCTO.into(),
                None,
                msg.clone(),
            );

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 0;
            testing_env!(ctx.clone());
            assert_eq!(
                staking_pool.ops_stake_pool_balances().treasury_balance,
                YoctoNear::ZERO
            );

            ctx.predecessor_account_id = env::current_account_id();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 0;
            testing_env!(ctx.clone());
            if let PromiseOrValue::Value(refund) =
                staking_pool.ft_on_transfer(to_valid_account_id(ACCOUNT), YOCTO.into(), msg)
            {
                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [EARNINGS] 1",
                        "[INFO] [TREASURY_DEPOSIT] treasury balance = 1000000000000000000000000",
                    ]
                );

                assert_eq!(refund, TokenAmount::ZERO);

                assert_eq!(
                    staking_pool.ops_stake_pool_balances().treasury_balance,
                    YOCTO.into()
                );
            } else {
                panic!("expected value");
            }
        }

        #[test]
        #[should_panic(
            expected = "[ERR] [NOT_AUTHORIZED] this method can only be invoked by the STAKE pool contract internally"
        )]
        fn ft_on_transfer_not_invoked_by_self() {
            // Arrange
            let ctx = new_context(OWNER);
            testing_env!(ctx.clone());

            deploy_stake_contract(staking_public_key());

            let mut staking_pool = staking_pool();
            staking_pool.ft_on_transfer(
                to_valid_account_id(ACCOUNT),
                YOCTO.into(),
                TransferCallMessage("".to_string()),
            );
        }
    }

    #[cfg(test)]
    mod tests_fees {
        use super::*;

        #[test]
        fn with_zero_staking_fee_nonzero_earnings_fee_with_zero_stake_supply() {
            let mut ctx = new_context(OWNER);
            testing_env!(ctx.clone());

            deploy_stake_contract(staking_public_key());
            let mut staking_pool = staking_pool();

            staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::UpdateFees(Fees {
                staking_fee: 0.into(),
                earnings_fee: 100.into(),
            }));

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance() + YOCTO;
            ctx.attached_deposit = 0;
            testing_env!(ctx.clone());
            let stake_token_value = staking_pool.ops_stake_token_value_with_earnings(None);

            // Assert - no earnings are distributed
            assert!(test_utils::get_logs().is_empty());

            assert_eq!(stake_token_value, YOCTO.into());
        }

        #[test]
        fn with_zero_staking_fee_nonzero_earnings_fee_with_some_stake_supply() {
            let mut ctx = new_context(OWNER);
            testing_env!(ctx.clone());

            deploy_stake_contract(staking_public_key());
            let mut staking_pool = staking_pool();
            let mut account_manager = account_manager();

            staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::UpdateFees(Fees {
                staking_fee: 0.into(),
                earnings_fee: 100.into(),
            }));

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = YOCTO;
            testing_env!(ctx.clone());
            account_manager.storage_deposit(None, None);

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            ctx.attached_deposit = 0;
            testing_env!(ctx.clone());
            staking_pool.ops_stake();

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance() + YOCTO;
            testing_env!(ctx.clone());
            let stake_token_value = staking_pool.ops_stake_token_value_with_earnings(None);
            println!("stake_token_value = {}", stake_token_value);

            // Assert
            let logs = test_utils::get_logs();
            println!("{:#?}", logs);
            assert_eq!(
                logs,
                vec![
                    "[INFO] [EARNINGS] 1000000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: owner, amount: 5015281435196141122921",
                ]
            );

            ctx.predecessor_account_id = ACCOUNT.to_string();
            ctx.account_balance = env::account_balance();
            testing_env!(ctx.clone());
            let owner_earnings = staking_pool.ops_stake_fees().earnings_fee * YOCTO;
            let (_owner_earnings, remainder) = staking_pool.near_to_stake(owner_earnings);
            assert_eq!(
                staking_pool
                    .ops_stake_balance(to_valid_account_id(OWNER))
                    .as_ref()
                    .unwrap()
                    .staked
                    .as_ref()
                    .unwrap()
                    .near_value,
                owner_earnings - remainder
            );
        }

        #[test]
        #[should_panic(expected = "[ERR] [INVALID] max earnings fee is 1000 BPS (10%)")]
        fn update_to_above_max_earnings_fee() {
            let ctx = new_context(OWNER);
            testing_env!(ctx.clone());

            deploy_stake_contract(staking_public_key());
            let mut staking_pool = staking_pool();

            staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::UpdateFees(Fees {
                staking_fee: 0.into(),
                earnings_fee: MAX_FEE + 1,
            }));
        }

        #[test]
        #[should_panic(
            expected = "[ERR] [INVALID] min fee is 1 BPS (0.01%) for at least 1 fee type"
        )]
        fn update_to_zero_fees() {
            let ctx = new_context(OWNER);
            testing_env!(ctx.clone());

            deploy_stake_contract(staking_public_key());
            let mut staking_pool = staking_pool();

            staking_pool.ops_stake_operator_command(StakingPoolOperatorCommand::UpdateFees(Fees {
                staking_fee: 0.into(),
                earnings_fee: 0.into(),
            }));
        }
    }

    #[cfg(test)]
    mod test_near_staking_pool_interface {
        use super::*;

        #[cfg(test)]
        mod tests_get_account_staked_balance {
            use super::*;

            #[test]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let staking_pool = staking_pool();
                assert_eq!(
                    staking_pool.get_account_staked_balance(to_valid_account_id(ACCOUNT)),
                    YoctoNear::ZERO,
                );
            }

            #[test]
            fn with_zero_staked() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account_staked_balance(to_valid_account_id(ACCOUNT)),
                    YoctoNear::ZERO,
                );
            }

            #[test]
            fn with_nonzero_staked() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                let balance = if let PromiseOrValue::Value(balance) = staking_pool.ops_stake() {
                    balance
                } else {
                    panic!("expected value");
                };

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account_staked_balance(to_valid_account_id(ACCOUNT)),
                    balance.staked.as_ref().unwrap().near_value,
                );
            }
        }

        #[cfg(test)]
        mod tests_get_account_unstaked_balance {
            use super::*;

            #[test]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let staking_pool = staking_pool();
                assert_eq!(
                    staking_pool.get_account_unstaked_balance(to_valid_account_id(ACCOUNT)),
                    YoctoNear::ZERO,
                );
            }

            #[test]
            fn with_zero_unstaked_zero_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account_unstaked_balance(to_valid_account_id(ACCOUNT)),
                    YoctoNear::ZERO,
                );
            }

            #[test]
            fn with_zero_unstaked_with_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account_unstaked_balance(to_valid_account_id(ACCOUNT)),
                    account_manager
                        .storage_balance_of(to_valid_account_id(ACCOUNT))
                        .unwrap()
                        .available
                );
            }

            #[test]
            fn with_nonzero_unstaked() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balance = if let PromiseOrValue::Value(balance) = staking_pool.ops_unstake(None)
                {
                    balance
                } else {
                    panic!("expected value");
                };

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account_unstaked_balance(to_valid_account_id(ACCOUNT)),
                    balance.unstaked.unwrap().total,
                );
            }
        }

        #[cfg(test)]
        mod tests_is_account_unstaked_balance_available {
            use super::*;

            #[test]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let staking_pool = staking_pool();
                assert!(staking_pool
                    .is_account_unstaked_balance_available(to_valid_account_id(ACCOUNT)),);
            }

            #[test]
            fn with_zero_unstaked_zero_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                assert!(staking_pool
                    .is_account_unstaked_balance_available(to_valid_account_id(ACCOUNT)),);
            }

            #[test]
            fn with_zero_unstaked_with_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                assert!(staking_pool
                    .is_account_unstaked_balance_available(to_valid_account_id(ACCOUNT)),);
            }

            #[test]
            fn with_nonzero_unstaked() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool.ops_unstake(None);

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert!(!staking_pool
                    .is_account_unstaked_balance_available(to_valid_account_id(ACCOUNT)),);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                assert!(staking_pool
                    .is_account_unstaked_balance_available(to_valid_account_id(ACCOUNT)),);
            }
        }

        #[cfg(test)]
        mod tests_get_account_total_balance {
            use super::*;
            use oysterpack_smart_near::near_sdk::PromiseOrValue;

            #[test]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let staking_pool = staking_pool();
                assert_eq!(
                    staking_pool.get_account_total_balance(to_valid_account_id(ACCOUNT)),
                    YoctoNear::ZERO
                );
            }

            #[test]
            fn with_zero_unstaked_zero_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account_total_balance(to_valid_account_id(ACCOUNT)),
                    YoctoNear::ZERO
                );
            }

            #[test]
            fn with_zero_unstaked_with_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account_total_balance(to_valid_account_id(ACCOUNT)),
                    account_manager
                        .storage_balance_of(to_valid_account_id(ACCOUNT))
                        .unwrap()
                        .available
                );
            }

            #[test]
            fn with_nonzero_balances() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balance = if let PromiseOrValue::Value(balance) =
                    staking_pool.ops_unstake(Some(1000.into()))
                {
                    balance
                } else {
                    panic!("expected value");
                };

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account_total_balance(to_valid_account_id(ACCOUNT)),
                    balance.staked.as_ref().unwrap().near_value
                        + balance.unstaked.as_ref().unwrap().total
                        + balance.storage_balance.available
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account_total_balance(to_valid_account_id(ACCOUNT)),
                    balance.staked.unwrap().near_value
                        + balance.unstaked.unwrap().total
                        + balance.storage_balance.available
                );
            }
        }

        #[cfg(test)]
        mod tests_get_account {
            use super::*;
            use oysterpack_smart_near::near_sdk::PromiseOrValue;

            #[test]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let staking_pool = staking_pool();
                assert_eq!(
                    staking_pool.get_account(to_valid_account_id(ACCOUNT)),
                    NearStakingPoolAccount {
                        account_id: ACCOUNT.to_string(),
                        unstaked_balance: YoctoNear::ZERO,
                        staked_balance: YoctoNear::ZERO,
                        can_withdraw: true
                    }
                );
            }

            #[test]
            fn with_zero_unstaked_zero_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account(to_valid_account_id(ACCOUNT)),
                    NearStakingPoolAccount {
                        account_id: ACCOUNT.to_string(),
                        unstaked_balance: YoctoNear::ZERO,
                        staked_balance: YoctoNear::ZERO,
                        can_withdraw: true
                    }
                );
            }

            #[test]
            fn with_zero_unstaked_with_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account(to_valid_account_id(ACCOUNT)),
                    NearStakingPoolAccount {
                        account_id: ACCOUNT.to_string(),
                        unstaked_balance: account_manager
                            .storage_balance_of(to_valid_account_id(ACCOUNT))
                            .unwrap()
                            .available,
                        staked_balance: YoctoNear::ZERO,
                        can_withdraw: true
                    }
                );
            }

            #[test]
            fn with_nonzero_balances() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let balance = if let PromiseOrValue::Value(balance) =
                    staking_pool.ops_unstake(Some(1000.into()))
                {
                    balance
                } else {
                    panic!("expected value");
                };

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account(to_valid_account_id(ACCOUNT)),
                    NearStakingPoolAccount {
                        account_id: ACCOUNT.to_string(),
                        unstaked_balance: balance.unstaked.as_ref().unwrap().total
                            + balance.storage_balance.available,
                        staked_balance: balance.staked.as_ref().unwrap().near_value,
                        can_withdraw: false
                    }
                );

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                assert_eq!(
                    staking_pool.get_account(to_valid_account_id(ACCOUNT)),
                    NearStakingPoolAccount {
                        account_id: ACCOUNT.to_string(),
                        unstaked_balance: balance.unstaked.as_ref().unwrap().total
                            + balance.storage_balance.available,
                        staked_balance: balance.staked.as_ref().unwrap().near_value,
                        can_withdraw: true
                    }
                );
            }
        }

        #[cfg(test)]
        mod tests_deposit {
            use super::*;

            #[test]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                let mut staking_pool = staking_pool();
                staking_pool.deposit();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(97)",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Registered(StorageBalance { total: YoctoNear(1000000000000000000000000), available: YoctoNear(996070000000000000000000) })",
                ]);

                let account_manager = account_manager();
                assert!(account_manager
                    .storage_balance_of(to_valid_account_id(ACCOUNT))
                    .is_some());
            }
        }

        #[cfg(test)]
        mod tests_deposit_and_stake {
            use super::*;

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                let mut staking_pool = staking_pool();
                staking_pool.deposit_and_stake();
            }

            #[test]
            fn registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                let mut staking_pool = staking_pool();
                staking_pool.deposit();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(97)",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Registered(StorageBalance { total: YoctoNear(1000000000000000000000000), available: YoctoNear(996070000000000000000000) })",
                ]);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.deposit_and_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(logs, vec![
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(996070000000000000000000))",
                    "[INFO] [STAKE] near_amount=1996070000000000000000000, stake_token_amount=1996070000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: bob, amount: 1996070000000000000000000",
                    "[INFO] [FT_BURN] account: bob, amount: 15968560000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                    "[INFO] [FT_MINT] account: owner, amount: 15968560000000000000000",
                    "[WARN] [STATUS_OFFLINE] ",
                ]);
            }
        }

        #[cfg(test)]
        mod tests_withdraw {
            use super::*;

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let mut staking_pool = staking_pool();
                staking_pool.withdraw(1000.into());
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
            fn with_zero_unstaked_zero_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                staking_pool.withdraw(1000.into());
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
            fn with_zero_unstaked_with_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                staking_pool.withdraw(1000.into());
            }

            #[test]
            fn with_nonzero_balances() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool.ops_unstake(Some(1000.into()));

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                staking_pool.withdraw(1000.into());

                assert!(staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap()
                    .unstaked
                    .is_none());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
            }
        }

        #[cfg(test)]
        mod tests_withdraw_all {
            use super::*;

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let mut staking_pool = staking_pool();
                staking_pool.withdraw_all();
            }

            #[test]
            fn with_zero_unstaked_zero_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                staking_pool.withdraw_all();

                let receipts = deserialize_receipts();
                assert!(receipts.is_empty());
            }

            #[test]
            fn with_zero_unstaked_with_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                staking_pool.withdraw_all();

                let receipts = deserialize_receipts();
                assert!(receipts.is_empty());
            }

            #[test]
            fn with_nonzero_balances() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut staking_pool = staking_pool();
                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool.ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool.ops_unstake(Some(1000.into()));

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                staking_pool.withdraw_all();

                assert!(staking_pool
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap()
                    .unstaked
                    .is_none());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                let receipts = deserialize_receipts();
                assert_eq!(receipts.len(), 1);
            }
        }

        #[cfg(test)]
        mod tests_stake {
            use super::*;

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let mut staking_pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                staking_pool.stake(1000.into());
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
            fn with_zero_unstaked_zero_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let mut staking_pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                staking_pool.stake(1000.into());
            }

            #[test]
            fn with_zero_unstaked_with_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let mut staking_pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                staking_pool.stake(1000.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(1000))",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)",
                        "[INFO] [STAKE] near_amount=1000, stake_token_amount=1000",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: bob, amount: 1000",
                        "[INFO] [FT_BURN] account: bob, amount: 8",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)",
                        "[INFO] [FT_MINT] account: owner, amount: 8",
                        "[WARN] [STATUS_OFFLINE] ",
                    ]
                );
            }

            #[test]
            fn with_nonzero_balances() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool().ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool().ops_unstake(Some(1000.into()));

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let mut pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                pool.stake(1000.into());

                assert!(staking_pool()
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap()
                    .unstaked
                    .is_none());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
            }
        }

        #[cfg(test)]
        mod tests_unstake {
            use super::*;

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let mut staking_pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                staking_pool.unstake(1000.into());
            }

            #[test]
            #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
            fn with_zero_unstaked_zero_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let mut staking_pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                staking_pool.unstake(1000.into());
            }

            #[test]
            fn with_zero_unstaked_with_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let mut staking_pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                staking_pool.stake(1000.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool.unstake(500.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [UNSTAKE] near_amount=500, stake_token_amount=500",
                        "[INFO] [FT_BURN] account: bob, amount: 500",
                        "[WARN] [STATUS_OFFLINE] ",
                    ]
                );
            }

            #[test]
            fn with_nonzero_balances() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool().ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool().ops_unstake(Some(1000.into()));

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.epoch_height = env::epoch_height() + 4;
                testing_env!(ctx.clone());
                let mut pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                pool.stake(1000.into());

                assert!(staking_pool()
                    .ops_stake_balance(to_valid_account_id(ACCOUNT))
                    .unwrap()
                    .unstaked
                    .is_none());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
            }
        }

        #[cfg(test)]
        mod tests_unstake_all {
            use super::*;

            #[test]
            #[should_panic(expected = "[ERR] [ACCOUNT_NOT_REGISTERED]")]
            fn not_registered() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let mut staking_pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                staking_pool.unstake_all();
            }

            #[test]
            fn with_zero_unstaked_zero_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                testing_env!(ctx.clone());
                let mut staking_pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                staking_pool.unstake_all();
            }

            #[test]
            fn with_zero_unstaked_with_storage_available_balance() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, None);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                let mut staking_pool: Box<dyn NearStakingPool> = Box::new(staking_pool());
                staking_pool.stake(1000.into());

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool.unstake_all();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);
                assert_eq!(
                    logs,
                    vec![
                        "[INFO] [UNSTAKE] near_amount=992, stake_token_amount=992",
                        "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)",
                        "[INFO] [FT_BURN] account: bob, amount: 992",
                        "[WARN] [STATUS_OFFLINE] ",
                    ]
                );
            }

            #[test]
            fn with_nonzero_balances() {
                // Arrange
                let mut ctx = new_context(OWNER);
                testing_env!(ctx.clone());

                deploy_stake_contract(staking_public_key());

                let mut account_manager = account_manager();

                // register account
                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                account_manager.storage_deposit(None, Some(true));

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = YOCTO;
                testing_env!(ctx.clone());
                staking_pool().ops_stake();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                ctx.predecessor_account_id = ACCOUNT.to_string();
                ctx.account_balance = env::account_balance();
                ctx.attached_deposit = 0;
                testing_env!(ctx.clone());
                staking_pool().unstake_all();

                let logs = test_utils::get_logs();
                println!("{:#?}", logs);

                assert_eq!(logs, vec![
                    "[INFO] [UNSTAKE] near_amount=992000000000000000000000, stake_token_amount=992000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)",
                    "[INFO] [FT_BURN] account: bob, amount: 992000000000000000000000",
                    "[INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)",
                    "[WARN] [STATUS_OFFLINE] ",
                ]);
            }
        }
    }
}

'''
'''--- near/oysterpack-smart-staking-pool/src/domain.rs ---
mod fees;
mod stake_account;
mod stake_account_balances;
mod staking_pool_balances;
mod status;
mod unstaked_balances;

pub use fees::*;
pub use stake_account::*;
pub use stake_account_balances::*;
pub use staking_pool_balances::*;
pub use status::*;
pub use unstaked_balances::*;

'''
'''--- near/oysterpack-smart-staking-pool/src/domain/fees.rs ---
use oysterpack_smart_near::domain::BasisPoints;
use oysterpack_smart_near::near_sdk::serde::{Deserialize, Serialize};

#[derive(Serialize, Deserialize, Debug, Clone, Copy, PartialEq, Default)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct Fees {
    /// fee charged when staking funds
    pub staking_fee: BasisPoints,
    /// fee charged based on earnings - this aligns the owner's financial interests and incentives with the stakers
    pub earnings_fee: BasisPoints,
}

'''
'''--- near/oysterpack-smart-staking-pool/src/domain/stake_account.rs ---
use crate::UnstakedBalances;
use oysterpack_smart_near::near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, PartialEq, Default)]
pub struct StakeAccountData {
    pub unstaked_balances: UnstakedBalances,
}

'''
'''--- near/oysterpack-smart-staking-pool/src/domain/stake_account_balances.rs ---
use crate::UnstakedBalances;
use oysterpack_smart_account_management::StorageBalance;
use oysterpack_smart_fungible_token::TokenAmount;
use oysterpack_smart_near::domain::{EpochHeight, YoctoNear};
use oysterpack_smart_near::near_sdk::serde::{Deserialize, Serialize};
use std::collections::BTreeMap;

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Default)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct StakeAccountBalances {
    /// account storage available balance will be staked
    pub storage_balance: StorageBalance,
    pub staked: Option<StakedBalance>,
    // unstaked funds that are pending withdrawal
    pub unstaked: Option<UnstakedBalance>,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Default)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct StakedBalance {
    pub stake: TokenAmount,
    /// how much the STAKE balance is currently worth in NEAR
    pub near_value: YoctoNear,
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, Default)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct UnstakedBalance {
    pub total: YoctoNear,
    pub available: YoctoNear,
    pub locked: Option<BTreeMap<EpochHeight, YoctoNear>>,
}

impl From<UnstakedBalances> for UnstakedBalance {
    fn from(mut balance: UnstakedBalances) -> Self {
        balance.unlock();
        Self {
            total: balance.total(),
            available: balance.available(),
            locked: balance.locked(),
        }
    }
}

'''
'''--- near/oysterpack-smart-staking-pool/src/domain/staking_pool_balances.rs ---
use crate::components::staking_pool::State;
use oysterpack_smart_fungible_token::TokenAmount;
use oysterpack_smart_near::{
    domain::YoctoNear,
    near_sdk::serde::{Deserialize, Serialize},
};

/// Staking Pool Contract NEAR Balances
#[derive(Serialize, Deserialize, Debug, Clone, Copy, Eq, PartialEq)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct StakingPoolBalances {
    /// total NEAR funds that have been staked and confirmed
    pub total_staked: YoctoNear,

    pub total_stake_supply: TokenAmount,

    /// total unstaked funds that have not yet been withdrawn
    /// - includes locked and unlocked funds
    /// - excludes [`StakingPoolBalances::unstaked_liquidity`]
    pub total_unstaked: YoctoNear,
    /// unstaked funds that can be withdrawn from liquidity added by staking
    pub unstaked_liquidity: YoctoNear,

    /// used to track the treasury STAKE NEAR value
    /// - staking rewards earned by the treasury are distributed as dividends
    /// - balance gets updated when funds are staked
    pub treasury_balance: YoctoNear,

    pub current_contract_managed_total_balance: YoctoNear,
    /// used to track transaction fee earnings
    /// - transaction gas earnings are staked into the pool, which effectively increases STAKE value
    pub last_contract_managed_total_balance: YoctoNear,
    /// [`StakingPoolBalances::last_contract_managed_total_balance`] - [`StakingPoolBalances::current_contract_managed_total_balance`]
    /// staking earnings + transaction fee earnings
    pub earnings: YoctoNear,
}

impl StakingPoolBalances {
    pub(crate) fn new(state: State, total_stake_supply: TokenAmount) -> Self {
        let current_contract_managed_total_balance =
            State::contract_managed_total_balance_in_view_mode();
        Self {
            total_staked: State::total_staked_balance(),
            total_stake_supply,
            total_unstaked: State::total_unstaked_balance(),
            unstaked_liquidity: State::liquidity(),
            treasury_balance: state.treasury_balance,

            current_contract_managed_total_balance,
            last_contract_managed_total_balance: state.last_contract_managed_total_balance,
            earnings: current_contract_managed_total_balance
                .saturating_sub(*state.last_contract_managed_total_balance)
                .into(),
        }
    }
}

'''
'''--- near/oysterpack-smart-staking-pool/src/domain/status.rs ---
use oysterpack_smart_near::near_sdk::serde::export::Formatter;
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    serde::{Deserialize, Serialize},
};
use std::fmt::{self, Debug, Display};

#[derive(
    BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy, PartialEq, Eq, Debug,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub enum Status {
    /// While offline, accounts can still stake, but the funds are held until are held until the
    /// staking pool goes online
    /// - when the pool goes back online, then the staked funds are staked
    Offline(OfflineReason),
    /// the pool is actively staking
    Online,
}

impl Status {
    pub fn is_online(&self) -> bool {
        match self {
            Status::Offline(_) => false,
            Status::Online => true,
        }
    }
}

#[derive(
    BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Copy, PartialEq, Eq, Debug,
)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub enum OfflineReason {
    Stopped,
    StakeActionFailed,
}

impl Display for OfflineReason {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        Debug::fmt(self, f)
    }
}

'''
'''--- near/oysterpack-smart-staking-pool/src/domain/unstaked_balances.rs ---
use crate::components::staking_pool::State;
use oysterpack_smart_near::asserts::ERR_INSUFFICIENT_FUNDS;
use oysterpack_smart_near::domain::{EpochHeight, YoctoNear};
use oysterpack_smart_near::near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
};
use std::cmp::Ordering;
use std::collections::BTreeMap;

/// unstaked NEAR is locked for 4 epochs before being able to be withdrawn
/// https://github.com/near/nearcore/blob/037954e087fd5c8a65598ede502495530c73f835/chain/epoch_manager/src/lib.rs#L815
const EPOCHS_LOCKED: usize = 4;

#[derive(BorshDeserialize, BorshSerialize, Debug, Clone, Copy, PartialEq, Default)]
pub struct UnstakedBalances {
    available: YoctoNear,
    locked: [(EpochHeight, YoctoNear); EPOCHS_LOCKED],
}

impl UnstakedBalances {
    pub fn total(&self) -> YoctoNear {
        self.available + self.locked_balance()
    }

    pub fn available(&self) -> YoctoNear {
        self.available
    }

    pub fn locked_balance(&self) -> YoctoNear {
        self.locked
            .iter()
            .fold(YoctoNear::ZERO, |total, (_, amount)| total + *amount)
    }

    pub fn locked(&self) -> Option<BTreeMap<EpochHeight, YoctoNear>> {
        let result: BTreeMap<EpochHeight, YoctoNear> =
            self.locked
                .iter()
                .fold(BTreeMap::new(), |mut result, (epoch, amount)| {
                    if *amount > YoctoNear::ZERO {
                        result.insert(*epoch, *amount);
                    }
                    result
                });
        if result.is_empty() {
            None
        } else {
            Some(result)
        }
    }

    pub(crate) fn unlock(&mut self) {
        let current_epoch: EpochHeight = env::epoch_height().into();

        for i in 0..EPOCHS_LOCKED {
            let (epoch, balance) = self.locked[i];
            if balance > YoctoNear::ZERO {
                if epoch <= current_epoch {
                    self.available += balance;
                    self.locked[i] = Default::default();
                }
            }
        }
    }

    /// If there are locked balances then try to use liquidity to unlock the funds for withdrawal.
    ///
    /// returns the amount of liquidity that was applied
    pub(crate) fn apply_liquidity(&mut self) -> YoctoNear {
        self.unlock();
        let locked_balance = self.locked_balance();
        if locked_balance == YoctoNear::ZERO {
            return YoctoNear::ZERO;
        }

        let liquidity = State::liquidity();
        if liquidity == YoctoNear::ZERO {
            return YoctoNear::ZERO;
        }

        if liquidity >= locked_balance {
            self.available = self.total();
            for i in 0..EPOCHS_LOCKED {
                self.locked[i] = Default::default();
            }
            return locked_balance;
        }

        self.available += liquidity;
        self.debit_from_locked(liquidity);
        liquidity
    }

    /// adds the unstaked balance and locks it up for 4 epochs
    pub(crate) fn credit_unstaked(&mut self, amount: YoctoNear) {
        self.unlock();
        let available_on: EpochHeight = (env::epoch_height() + EPOCHS_LOCKED as u64).into();
        for i in 0..EPOCHS_LOCKED {
            let (epoch, balance) = self.locked[i];
            if balance > YoctoNear::ZERO {
                if epoch == available_on {
                    self.locked[i] = (epoch, balance + amount);
                    return;
                }
            }
        }

        for i in 0..EPOCHS_LOCKED {
            if self.locked[i].1 == YoctoNear::ZERO {
                self.locked[i] = (available_on, amount);
                return;
            }
        }

        unreachable!()
    }

    fn sort_locked(&mut self) {
        self.locked.sort_by(|left, right| {
            if left.1 == YoctoNear::ZERO && right.1 == YoctoNear::ZERO {
                return Ordering::Equal;
            }
            if left.1 > YoctoNear::ZERO && right.1 == YoctoNear::ZERO {
                return Ordering::Less;
            }
            if left.1 == YoctoNear::ZERO && right.1 > YoctoNear::ZERO {
                return Ordering::Greater;
            }
            left.0.cmp(&right.0)
        });
    }

    /// tries to debit the specified amount from the available balance.
    ///
    /// ## NOTES
    /// - locked balances are checked if they have become available
    ///
    /// ## Panics
    /// if there are insufficient funds
    pub(crate) fn debit_available_balance(&mut self, amount: YoctoNear) {
        self.unlock();
        ERR_INSUFFICIENT_FUNDS.assert(|| self.available >= amount);
        self.available -= amount;
    }

    pub(crate) fn debit_for_restaking(&mut self, amount: YoctoNear) {
        let total = self.total();
        ERR_INSUFFICIENT_FUNDS.assert(|| total >= amount);

        if total == self.available {
            self.available -= amount;
            return;
        }

        let remainder = self.debit_from_locked(amount);
        self.available -= remainder;
    }

    fn debit_from_locked(&mut self, mut amount: YoctoNear) -> YoctoNear {
        self.sort_locked();

        // take from the most recent unstaked balances
        for i in (0..EPOCHS_LOCKED).rev() {
            let (available_on, unstaked) = self.locked[i];
            if unstaked > YoctoNear::ZERO {
                if unstaked <= amount {
                    amount -= unstaked;
                    self.locked[i] = Default::default();
                } else {
                    self.locked[i] = (available_on, unstaked - amount);
                    return YoctoNear::ZERO;
                }

                if amount == YoctoNear::ZERO {
                    return YoctoNear::ZERO;
                }
            }
        }

        return amount;
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near::domain::YoctoNear;
    use oysterpack_smart_near::YOCTO;
    use oysterpack_smart_near_test::*;

    #[test]
    fn unlock() {
        let mut ctx = new_context("bob");

        ctx.epoch_height = 100;
        testing_env!(ctx.clone());

        let mut unstaked_balances = UnstakedBalances::default();
        unstaked_balances.credit_unstaked(YOCTO.into());
        unstaked_balances.credit_unstaked(YOCTO.into());

        assert_eq!(unstaked_balances.available, YoctoNear::ZERO);
        let expected_available_on: EpochHeight = (ctx.epoch_height + EPOCHS_LOCKED as u64).into();
        assert_eq!(
            *unstaked_balances
                .locked()
                .unwrap()
                .get(&expected_available_on)
                .unwrap(),
            YoctoNear(2 * YOCTO)
        );
        assert_eq!(*unstaked_balances.total(), 2 * YOCTO);

        ctx.epoch_height = 101;
        testing_env!(ctx.clone());
        unstaked_balances.credit_unstaked(YOCTO.into());
        assert_eq!(unstaked_balances.available, YoctoNear::ZERO);
        assert_eq!(
            *unstaked_balances
                .locked()
                .unwrap()
                .get(&expected_available_on)
                .unwrap(),
            YoctoNear(2 * YOCTO)
        );
        let expected_available_on: EpochHeight = (ctx.epoch_height + EPOCHS_LOCKED as u64).into();
        assert_eq!(
            *unstaked_balances
                .locked()
                .unwrap()
                .get(&expected_available_on)
                .unwrap(),
            YoctoNear(YOCTO)
        );
        assert_eq!(*unstaked_balances.total(), 3 * YOCTO);

        ctx.epoch_height = 104;
        testing_env!(ctx.clone());
        unstaked_balances.unlock();
        assert_eq!(*unstaked_balances.total(), 3 * YOCTO);
        assert_eq!(*unstaked_balances.available(), 2 * YOCTO);

        ctx.epoch_height = 105;
        testing_env!(ctx.clone());
        unstaked_balances.unlock();
        assert_eq!(*unstaked_balances.total(), 3 * YOCTO);
        assert_eq!(*unstaked_balances.available(), 3 * YOCTO);

        println!("{:?}", unstaked_balances);
    }

    #[test]
    fn debit_for_restaking() {
        let mut ctx = new_context("bob");

        ctx.epoch_height = 100;
        testing_env!(ctx.clone());
        let mut unstaked_balances = UnstakedBalances::default();
        unstaked_balances.credit_unstaked(YOCTO.into());

        ctx.epoch_height = 101;
        testing_env!(ctx.clone());
        unstaked_balances.credit_unstaked(YOCTO.into());

        ctx.epoch_height = 103;
        testing_env!(ctx.clone());
        unstaked_balances.credit_unstaked(YOCTO.into());

        ctx.epoch_height = 104;
        testing_env!(ctx.clone());
        unstaked_balances.credit_unstaked(YOCTO.into());

        ctx.epoch_height = 106;
        testing_env!(ctx.clone());
        unstaked_balances.credit_unstaked(YOCTO.into());

        unstaked_balances.sort_locked();

        assert_eq!(
            unstaked_balances,
            UnstakedBalances {
                available: (2 * YOCTO).into(),
                locked: [
                    (107.into(), YOCTO.into()),
                    (108.into(), YOCTO.into()),
                    (110.into(), YOCTO.into()),
                    Default::default()
                ]
            }
        );

        unstaked_balances.debit_for_restaking(1000.into());
        assert_eq!(
            unstaked_balances,
            UnstakedBalances {
                available: (2 * YOCTO).into(),
                locked: [
                    (107.into(), YOCTO.into()),
                    (108.into(), YOCTO.into()),
                    (110.into(), (YOCTO - 1000).into()),
                    Default::default()
                ]
            }
        );

        unstaked_balances.debit_for_restaking(YOCTO.into());
        assert_eq!(
            unstaked_balances,
            UnstakedBalances {
                available: (2 * YOCTO).into(),
                locked: [
                    (107.into(), YOCTO.into()),
                    (108.into(), (YOCTO - 1000).into()),
                    Default::default(),
                    Default::default()
                ]
            }
        );

        unstaked_balances.debit_for_restaking((2 * YOCTO).into());
        assert_eq!(
            unstaked_balances,
            UnstakedBalances {
                available: ((2 * YOCTO) - 1000).into(),
                locked: Default::default()
            }
        );

        unstaked_balances.debit_for_restaking(YOCTO.into());
        assert_eq!(
            unstaked_balances,
            UnstakedBalances {
                available: (YOCTO - 1000).into(),
                locked: Default::default()
            }
        );
    }

    #[test]
    #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
    fn debit_for_restaking_with_insufficient_funds() {
        let mut ctx = new_context("bob");

        ctx.epoch_height = 100;
        testing_env!(ctx.clone());
        let mut unstaked_balances = UnstakedBalances::default();
        unstaked_balances.credit_unstaked(YOCTO.into());

        unstaked_balances.debit_for_restaking((2 * YOCTO).into());
    }

    #[test]
    fn debit_available_balance() {
        let mut ctx = new_context("bob");

        ctx.epoch_height = 100;
        testing_env!(ctx.clone());
        let mut unstaked_balances = UnstakedBalances::default();
        unstaked_balances.credit_unstaked(YOCTO.into());
        assert_eq!(unstaked_balances.total(), YOCTO.into());

        ctx.epoch_height = 104;
        testing_env!(ctx.clone());
        unstaked_balances.debit_available_balance(YOCTO.into());
        assert_eq!(unstaked_balances.total(), YoctoNear::ZERO);
    }

    #[test]
    #[should_panic(expected = "[ERR] [INSUFFICIENT_FUNDS]")]
    fn debit_available_balance_insufficient_funds() {
        let mut ctx = new_context("bob");

        ctx.epoch_height = 100;
        testing_env!(ctx.clone());
        let mut unstaked_balances = UnstakedBalances::default();
        unstaked_balances.credit_unstaked(YOCTO.into());
        assert_eq!(unstaked_balances.total(), YOCTO.into());

        unstaked_balances.debit_available_balance(YOCTO.into());
    }
}

'''
'''--- near/oysterpack-smart-staking-pool/src/interface.rs ---
pub use contract::near_staking_pool::*;
pub use contract::operator::*;
pub use contract::stake_action_callbacks::*;
pub use contract::staking_pool::*;
pub use contract::treasury::*;

pub mod contract;

'''
'''--- near/oysterpack-smart-staking-pool/src/interface/contract.rs ---
pub mod near_staking_pool;
pub mod operator;
pub mod stake_action_callbacks;
pub mod staking_pool;
pub mod treasury;

'''
'''--- near/oysterpack-smart-staking-pool/src/interface/contract/near_staking_pool.rs ---
use oysterpack_smart_near::domain::YoctoNear;
use oysterpack_smart_near::near_sdk::AccountId;
use oysterpack_smart_near::near_sdk::{
    json_types::ValidAccountId,
    serde::{Deserialize, Serialize},
};

/// NEAR Staking Pool interface adapter
/// - https://github.com/near/core-contracts/tree/master/staking-pool
pub trait NearStakingPool {
    /// Returns the account's staked NEAR balance
    /// - If the account is not registered then zero is returned.
    fn get_account_staked_balance(&self, account_id: ValidAccountId) -> YoctoNear;

    /// Returns total unstaked plus account storage available balance
    /// - If the account is not registered then zero is returned.
    fn get_account_unstaked_balance(&self, account_id: ValidAccountId) -> YoctoNear;

    /// If account is not registered or has zero unstaked, then true is returned
    fn is_account_unstaked_balance_available(&self, account_id: ValidAccountId) -> bool;

    fn get_account_total_balance(&self, account_id: ValidAccountId) -> YoctoNear;

    fn get_account(&self, account_id: ValidAccountId) -> NearStakingPoolAccount;

    /// delegates to `StorageManagement::storage_deposit(None, None)`
    fn deposit(&mut self);

    /// delegates to `StakingPool::ops_stake()`
    fn deposit_and_stake(&mut self);

    fn withdraw(&mut self, amount: YoctoNear);

    fn withdraw_all(&mut self);

    /// restakes unstaked balance and includes account storage available balance
    fn stake(&mut self, amount: YoctoNear);

    fn unstake(&mut self, amount: YoctoNear);

    fn unstake_all(&mut self);
}

/// Represents an account structure readable by humans.
#[derive(Serialize, Deserialize, Eq, PartialEq, Debug)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub struct NearStakingPoolAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: YoctoNear,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: YoctoNear,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
}

'''
'''--- near/oysterpack-smart-staking-pool/src/interface/contract/operator.rs ---
use crate::Fees;
use oysterpack_smart_near::domain::{BasisPoints, PublicKey};
use oysterpack_smart_near::near_sdk::serde::{Deserialize, Serialize};

/// # **Contract Interface**: Staking Pool Operator API
pub trait StakingPoolOperator {
    /// Executes the specified operator command
    ///
    /// ## Panics
    /// - if predecessor account is not registered
    /// - if predecessor account is not authorized - requires operator permission
    fn ops_stake_operator_command(&mut self, command: StakingPoolOperatorCommand);
}

#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
#[serde(crate = "oysterpack_smart_near::near_sdk::serde")]
pub enum StakingPoolOperatorCommand {
    StopStaking,
    StartStaking,

    /// the staking pool public key can only be changed while the staking pool is offline
    UpdatePublicKey(PublicKey),
    /// max fee is 1000 BPS (10%)
    UpdateFees(Fees),
}

/// 10%
pub const MAX_FEE: BasisPoints = BasisPoints(1000);

#[cfg(test)]
mod tests {
    use super::*;
    use oysterpack_smart_near_test::near_sdk::serde_json;

    #[test]
    fn json_serialization() {
        println!(
            "{}",
            serde_json::to_string_pretty(&StakingPoolOperatorCommand::StartStaking).unwrap()
        );
        println!(
            "{}",
            serde_json::to_string(&StakingPoolOperatorCommand::UpdateFees(Fees {
                staking_fee: 1.into(),
                earnings_fee: 50.into()
            }))
            .unwrap()
        );
        println!(
            "{}",
            serde_json::to_string(&StakingPoolOperatorCommand::UpdatePublicKey(
                serde_json::from_str(r#""ed25519:GTi3gtSio5ZYYKTT8WVovqJEob6KqdmkTi8KqGSfwqdm""#)
                    .unwrap()
            ))
            .unwrap()
        );
    }
}

'''
'''--- near/oysterpack-smart-staking-pool/src/interface/contract/stake_action_callbacks.rs ---
use crate::StakeAccountBalances;
use oysterpack_smart_near::near_sdk::AccountId;
use oysterpack_smart_near::ErrCode;

/// # **Contract Interface**: Private Staking Pool Callbacks
pub trait StakeActionCallbacks {
    /// Finalizes the stake action when funds are staked
    ///
    /// If the stake action failed, then the contract will fully unstake and go offline.
    ///
    /// `#[private]`
    fn ops_stake_finalize(&mut self, account_id: AccountId) -> StakeAccountBalances;

    /// invoked when the staking pool is brought back online and staking is resumed
    /// - the callback ensures that the retaking succeeded
    ///
    /// `#[private]`
    fn ops_stake_start_finalize(&mut self);

    /// invoked when the staking pool is taken offline and all NEAR is unstaked
    /// - the callback ensures that the unstaking succeeded
    ///
    /// `#[private]`
    fn ops_stake_stop_finalize(&mut self);
}

pub const ERR_STAKE_ACTION_FAILED: ErrCode = ErrCode("STAKE_ACTION_FAILED");

'''
'''--- near/oysterpack-smart-staking-pool/src/interface/contract/staking_pool.rs ---
use crate::{Fees, StakeAccountBalances, StakingPoolBalances, StakingPoolOperator};
use crate::{Status, Treasury};
use oysterpack_smart_fungible_token::{Memo, TokenAmount, TransferCallMessage};
use oysterpack_smart_near::domain::{PublicKey, YoctoNear};
use oysterpack_smart_near::near_sdk::json_types::ValidAccountId;
use oysterpack_smart_near::near_sdk::{Promise, PromiseOrValue};
use oysterpack_smart_near::{ErrCode, ErrorConst, Level, LogEvent};

/// # **Contract Interface**: Staking Pool API
///
/// Staking pools enable accounts to delegate NEAR to stake with a validator. The main benefits of using
/// this staking pool are:
/// 1. STAKE fungible token is provided for staked NEAR. This enables staked NEAR value to be transferred
///    while still being staked.
/// 2. Unstaked NEAR is locked for 4 epochs before it becomes available to be withdrawn, but is tracked
///    per epoch. Thus, more funds can be unstaked without affecting funds that were unstaked in previous
///    epochs. Compare this to the NEAR provided staking pool, where each time you unstake, it resets
///    the lockup period to 4 epochs for the total unstaked NEAR balance. For example, if 100 NEAR is
///    unstaked in EPOCH 1 and 10 NEAR is unstaked in EPOCH 3. Then 100 NEAR is available for
///    withdrawal in EPOCH 5 and 10 NEAR in EPOCH 7. In the current NEAR provided staking pool
///    implementation, unstaking in the 10 NEAR in EPOCH 3 would reset the lock period for the total
///    unstaked, i.e., you would not be able to withdraw the 100 NEAR that was unstaked in EPOCH 1
///    until EPOCH 7.
/// 3. Staking adds liquidity for withdrawing unstaked NEAR that is locked on a first come, first
///    withdraw basis.
/// 4. More flexible commercial model supporting 2 types of fees that can be combined
///    - staking fee - upfront 1 time fee that is charged based on percentage of NEAR staked
///      - defaults to 80 BPS (0.8%)
///    - earnings fee - charged as a percentage of earnings
///      - default to 0 BPS
/// 5. Profit sharing through dividends
///    - staking rewards earned by the treasury are distributed as dividends by burning STAKE tokens,
///      which boosts the yield, i.e., STAKE token value
///    - dividends are paid out on each staking/unstaking/withdrawal event, i.e., if the treasury
///      has received staking rewards since the last staking, then the STAKE token equivalent will be burned
/// 6. Earnings revenue distributions
///    - earnings can be distributed via ['Treasury::ops_stake_treasury_distribution']
///
/// The staking pool is integrated with the storage management API:
/// - accounts must be registered with the contract in order to stake
/// - when staking, the account's available storage balance will be staked in addition to the
///   attached deposit
///
/// The staking pool is integrated with fungible token API to support treasury deposits:
/// - STAKE received through direct transfers are treated as treasury distributions. The next time
///   funds are staked, the funds will be distributed as a treasury dividend.
/// - STAKE received through transfer calls are treated as treasury deposits, i.e., the treasury
///   balance will be updated to reflect the deposit.
///
pub trait StakingPool: Treasury + StakingPoolOperator {
    /// Consolidates the account's storage balance with the STAKE token balance
    ///
    /// Returns None if the account is not registered with the contract
    fn ops_stake_balance(&self, account_id: ValidAccountId) -> Option<StakeAccountBalances>;

    /// Used to stake NEAR for the predecessor's account.
    ///
    /// Any attached deposit will be fully staked in addition to any available account storage balance.
    ///
    /// Returns the account's updated stake account balance after the contract's stake action completes
    ///
    /// ## NOTES
    /// - When NEAR is staked, STAKE tokens are minted. Because values are rounded down, only the actual
    ///   STAKE NEAR value is minted. The remainder is credited to the account's storage balance. The
    ///   algorithm is:
    ///    1. NEAR stake amount = attached deposit + account storage available balance
    ///    2. compute the  NEAR stake amount in STAKE
    ///    3. convert the STAKE back to NEAR
    ///    4. STAKE NEAR value is staked
    ///    5. remainder is credited to the account's storage balance
    /// - When NEAR is staked, it is first converted to STAKE and rounded down. Thus, based on the current
    ///   exchange ratio, a minimum amount of NEAR is required to stake. If there is not enough to stake
    ///   then the funds will be transferred over to the account's storage balance.
    ///   - [`LOG_EVENT_NOT_ENOUGH_TO_STAKE`] event will be logged
    /// - the NEAR stake action is async - thus, balances will not be updated until the stake action
    ///   has completed
    /// - if there was no attached deposit and zero available storage balance, then the current balances
    ///   are simply returned
    ///
    /// ## Panics
    /// - if the account is not registered
    ///
    /// `#[payable]`
    fn ops_stake(&mut self) -> PromiseOrValue<StakeAccountBalances>;

    /// Used to unstake staked NEAR.
    ///
    /// If amount is not specified, then the full staked balance will be unstaked.
    ///
    /// ## Notes
    /// - If unstaking all, i.e., `amount` is None, then a zero staked balance is fine. However, if
    ///   an `amount` is specified, then the method will panic if there are insufficient staked funds
    ///   to fulfill the request
    ///
    /// ## Panics
    /// - if account is not registered
    /// - if there are insufficient staked funds to fulfill the request to unstake the specified amount
    fn ops_unstake(&mut self, amount: Option<YoctoNear>) -> PromiseOrValue<StakeAccountBalances>;

    /// Re-stakes unstaked funds
    ///
    /// If amount is not specified, then the full unstaked balance will be re-staked.
    ///
    /// ## Notes
    /// - If unstaking all, i.e., `amount` is None, then a zero staked balance is fine. However, if
    ///   an `amount` is specified, then the method will panic if there are insufficient staked funds
    ///   to fulfill the request
    /// - the actual NEAR amount restaked might be less than the requested specified amount because
    ///   of rounding when converting the restake NEAR amount to STAKE - check balances to confirm
    ///   the actual amount restaked
    ///
    /// ## Panics
    /// - if account is not registered
    /// - if there are insufficient funds to fulfill the request
    fn ops_restake(&mut self, amount: Option<YoctoNear>) -> PromiseOrValue<StakeAccountBalances>;

    /// Withdraws unstaked NEAR that is not locked.
    ///
    /// If no amount is specified, then all available unstaked NEAR will be withdrawn.
    ///
    /// ## Panics
    /// - if account is not registered
    /// - if there are insufficient funds to fulfill the request
    fn ops_stake_withdraw(&mut self, amount: Option<YoctoNear>) -> StakeAccountBalances;

    /// converts the specified NEAR amount to STAKE and transfers the funds to the specified receiver
    /// account
    /// - proxies [`oysterpack_smart_fungible_token::FungibleToken::ft_transfer`] as a convenience
    ///   method that enables the staker to transfer STAKE by specifying the transfer amount in NEAR vs in STAKE
    /// - returns the amount of STAKE tokens that were transferred based on the current STAKE token value
    ///
    /// ## NOTES
    /// - earnings are applied before the transfer
    ///
    /// `#[payable]`
    fn ops_stake_transfer(
        &mut self,
        receiver_id: ValidAccountId,
        amount: YoctoNear,
        memo: Option<Memo>,
    ) -> TokenAmount;

    /// converts the specified NEAR amount to STAKE and transfers the funds to the specified receiver
    /// account via the FT transfer call mechanism
    /// - proxies [`oysterpack_smart_fungible_token::FungibleToken::ft_transfer_call`] a convenience
    ///   method that enables the staker to transfer STAKE by specifying the transfer amount in NEAR vs in STAKE
    /// - returns the amount of STAKE tokens that were transferred
    ///
    /// ## NOTES
    /// - earnings are applied before the transfer
    ///
    /// `#[payable]`
    fn ops_stake_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: YoctoNear,
        memo: Option<Memo>,
        msg: TransferCallMessage,
    ) -> Promise;

    /// returns the current NEAR value for the specified amount
    /// - if no amount is specified, then the value for 1 STAKE token will be returned
    /// - value includes estimated earnings minus dividend payouts
    /// - if you need the most accurate STAKE token value, then use `[Self::ops_stake_token_value_with_updated_earnings`],
    ///   which is not a view method
    fn ops_stake_token_value(&self, amount: Option<TokenAmount>) -> YoctoNear;

    /// Collects earnings and pays dividend before computing and returning the STAKE token value.
    ///
    /// To avoid gas fees to get a STAKE token estimate minus dividends you can use [`Self::`ops_stake_token_value].
    ///
    /// ## NOTES
    /// Calling this consecutive times should return an increasing STAKE token value because the
    /// transaction gas fees earned from this call are applied on the next.
    fn ops_stake_token_value_with_earnings(&mut self, amount: Option<TokenAmount>) -> YoctoNear;

    fn ops_stake_status(&self) -> Status;

    fn ops_stake_pool_balances(&self) -> StakingPoolBalances;

    fn ops_stake_fees(&self) -> Fees;

    fn ops_stake_public_key(&self) -> PublicKey;
}

pub const LOG_EVENT_STATUS_ONLINE: LogEvent = LogEvent(Level::INFO, "STATUS_ONLINE");
pub const LOG_EVENT_STATUS_OFFLINE: LogEvent = LogEvent(Level::WARN, "STATUS_OFFLINE");

pub const LOG_EVENT_NOT_ENOUGH_TO_STAKE: LogEvent = LogEvent(Level::INFO, "NOT_ENOUGH_TO_STAKE");

pub const LOG_EVENT_STAKE: LogEvent = LogEvent(Level::INFO, "STAKE");
pub const LOG_EVENT_UNSTAKE: LogEvent = LogEvent(Level::INFO, "UNSTAKE");

pub const LOG_EVENT_TREASURY_DIVIDEND: LogEvent = LogEvent(Level::INFO, "TREASURY_DIVIDEND");
pub const LOG_EVENT_TREASURY_DEPOSIT: LogEvent = LogEvent(Level::INFO, "TREASURY_DEPOSIT");
pub const LOG_EVENT_EARNINGS: LogEvent = LogEvent(Level::INFO, "EARNINGS");

pub const LOG_EVENT_LIQUIDITY: LogEvent = LogEvent(Level::INFO, "LIQUIDITY");

pub const ERR_STAKED_BALANCE_TOO_LOW_TO_UNSTAKE: ErrorConst =
    ErrorConst(ErrCode("STAKED_BALANCE_TOO_LOW_TO_UNSTAKE"), "");

'''
'''--- near/oysterpack-smart-staking-pool/src/interface/contract/treasury.rs ---
use crate::StakeAccountBalances;
use oysterpack_smart_near::domain::YoctoNear;
use oysterpack_smart_near::near_sdk::json_types::ValidAccountId;
use oysterpack_smart_near::near_sdk::PromiseOrValue;

/// # **Contract Interface**: Staking Pool Treasury API
pub trait Treasury {
    /// Deposits any attached deposit into the treasury.
    /// This will effectively stake the deposit and mint STAKE for the treasury.
    ///
    /// This enables external sources of revenue to be deposited into the treasury.
    ///
    /// ## Notes
    /// - The entire deposit is staked. When minting STAKE, the conversion from NEAR -> STAKE is rounded
    ///   down. Thus, the NEAR deposit remainder will also get staked, effectively distributing the
    ///   funds to the current stakers.
    ///
    /// ## Panics
    /// if no deposit is attached
    ///
    /// `#[payable]`
    fn ops_stake_treasury_deposit(&mut self) -> PromiseOrValue<StakeAccountBalances>;

    /// Deposits and stakes any attached deposit, which effectively distributes the funds to all current
    /// STAKE owners. As a side effect this will also boost the dividend yield.
    ///
    /// This enables external sources of revenue to be distributed to STAKE owners.
    ///
    /// ## Notes
    /// - An alternative way to make a distribution is to transfer STAKE to the treasury account
    ///   directly, i.e., via the [`oysterpack_smart_fungible_token::FungibleToken::ft_transfer`] API
    /// - if no deposit is made, then any collected earnings will simply be staked
    ///
    /// `#[payable]`
    fn ops_stake_treasury_distribution(&mut self);

    /// Transfers the specified amount from the treasury to the contract owners account
    /// - if no amount is specified, then the total treasury balance is transferred to the owner's account
    ///
    /// ## Notes
    /// - dividend is paid out before transfer
    ///
    /// ## Panics
    /// - requires [`PERMISSION_TREASURER`] permission or the owner
    /// - if there are insufficient funds   
    fn ops_stake_treasury_transfer_to_owner(&mut self, amount: Option<YoctoNear>);

    /// grants treasurer permission to specified account
    ///
    /// ## Panics
    /// - if not invoked by admin
    /// - if specified account is not registered
    fn ops_stake_grant_treasurer(&mut self, account_id: ValidAccountId);

    /// revokes treasurer permission to specified account
    ///
    /// ## Panics
    /// - if not invoked by admin
    /// - if specified account is not registered
    fn ops_stake_revoke_treasurer(&mut self, account_id: ValidAccountId);

    /// revokes treasurer permission to specified account
    fn ops_stake_is_treasurer(&mut self, account_id: ValidAccountId) -> bool;
}

pub const PERMISSION_TREASURER: &str = "treasurer";

'''
'''--- near/oysterpack-smart-staking-pool/src/lib.rs ---
pub mod components;
mod domain;
mod interface;

pub use domain::*;
pub use interface::*;

'''
'''--- near/oysterpack-smart-staking-pool/tests/quick_test.rs ---
#[test]
fn quick_test() {
    let left: u128 = 992366412213740458015268;
    let right: u128 = 992319794883748033331391;

    if left > right {
        println!(
            r#"
  {:0>30} 
- {:0>30}
  {:0>30}"#,
            left,
            right,
            left - right
        );
    } else {
        println!(
            r#"
  {:0>30} 
- {:0>30}
  {:0>30}"#,
            left,
            right,
            right - left
        );
    }
}

'''
'''--- near/oysterpack-smart-tools/Cargo.toml ---
[package]
name = "oysterpack-smart-tools"
version = "0.1.0"
authors = ["oysterpack.inc <2zP6OaymGZhJTHFvQMzp6Ze>"]
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
rusty_ulid = "0.10.1"
'''
'''--- near/oysterpack-smart-tools/README.md ---

'''
'''--- near/oysterpack-smart-tools/src/bin/ulid.rs ---
use rusty_ulid::Ulid;

fn main() {
    let ulid = Ulid::generate();
    println!("{}", ulid);
    let ulid_u128: u128 = ulid.into();
    println!("{}", ulid_u128);
}

'''
'''--- near/oysterpack-smart-tools/src/main.rs ---
fn main() {
    println!("Hello, world!");
}

'''
'''--- near/testnet.env ---
NEAR_MASTER_ACCOUNT = "oysterpack.testnet"
NEAR_ENV = "testnet"
'''