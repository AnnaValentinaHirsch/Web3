*GitHub Repository "open-web-academy/thegraph"*

'''--- README.md ---
# NCAR The Graph Example

En este apartado encontrar치s toda la informaci칩n necesaria para la implementaic칩n de un nodo de The Graph que permita indexar la informaci칩n generada por un contrato inteligente.

https://ow-academy.notion.site/Creaci-n-de-un-nodo-en-The-Graph-9ac3f2c4745c479c8c629901e580439b

'''
'''--- generated/schema.ts ---
// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.

import {
  TypedMap,
  Entity,
  Value,
  ValueKind,
  store,
  Bytes,
  BigInt,
  BigDecimal
} from "@graphprotocol/graph-ts";

export class Product extends Entity {
  constructor(id: string) {
    super();
    this.set("id", Value.fromString(id));

    this.set("name", Value.fromString(""));
    this.set("price", Value.fromBigInt(BigInt.zero()));
    this.set("stock", Value.fromBigInt(BigInt.zero()));
    this.set("enabled", Value.fromBoolean(false));
  }

  save(): void {
    let id = this.get("id");
    assert(id != null, "Cannot save Product entity without an ID");
    if (id) {
      assert(
        id.kind == ValueKind.STRING,
        "Cannot save Product entity with non-string ID. " +
          'Considering using .toHex() to convert the "id" to a string.'
      );
      store.set("Product", id.toString(), this);
    }
  }

  static load(id: string): Product | null {
    return changetype<Product | null>(store.get("Product", id));
  }

  get id(): string {
    let value = this.get("id");
    return value!.toString();
  }

  set id(value: string) {
    this.set("id", Value.fromString(value));
  }

  get name(): string {
    let value = this.get("name");
    return value!.toString();
  }

  set name(value: string) {
    this.set("name", Value.fromString(value));
  }

  get price(): BigInt {
    let value = this.get("price");
    return value!.toBigInt();
  }

  set price(value: BigInt) {
    this.set("price", Value.fromBigInt(value));
  }

  get stock(): BigInt {
    let value = this.get("stock");
    return value!.toBigInt();
  }

  set stock(value: BigInt) {
    this.set("stock", Value.fromBigInt(value));
  }

  get enabled(): boolean {
    let value = this.get("enabled");
    return value!.toBoolean();
  }

  set enabled(value: boolean) {
    this.set("enabled", Value.fromBoolean(value));
  }
}

'''
'''--- package.json ---
{
  "name": "Ejemplo",
  "license": "UNLICENSED",
  "scripts": {
    "codegen": "graph codegen",
    "build": "graph build",
    "deploy": "graph deploy --node https://api.thegraph.com/deploy/ LuisDaniel2166/Ejemplo",
    "create-local": "graph create --node http://localhost:8020/ LuisDaniel2166/Ejemplo",
    "remove-local": "graph remove --node http://localhost:8020/ LuisDaniel2166/Ejemplo",
    "deploy-local": "graph deploy --node http://localhost:8020/ --ipfs http://localhost:5001 LuisDaniel2166/Ejemplo"
  },
  "dependencies": {
    "@graphprotocol/graph-cli": "0.26.0",
    "@graphprotocol/graph-ts": "0.24.1"
  }
}

'''
'''--- src/mapping.ts ---
import { near, BigInt, json, JSONValueKind, log } from "@graphprotocol/graph-ts"
import { Product } from "../generated/schema"

export function handleReceipt(receipt: near.ReceiptWithOutcome): void {
  const actions = receipt.receipt.actions;
  for (let i = 0; i < actions.length; i++) {
    handleAction(
      actions[i],
      receipt.receipt,
      receipt.block.header,
      receipt.outcome,
      receipt.receipt.signerPublicKey
    );
  }
}

function handleAction(
  action: near.ActionValue,
  receipt: near.ActionReceipt,
  blockHeader: near.BlockHeader,
  outcome: near.ExecutionOutcome,
  publicKey: near.PublicKey,

): void {
  
  if (action.kind !== near.ActionKind.FUNCTION_CALL) {
    log.info("Early return: {}", ["Not a function call"]);
    return;
  }

  const functionCall = action.toFunctionCall();

  if(functionCall.methodName == "set_products"){
    log.info('Entro a agregar productos',[])
    //Obtencion del dato bruto del contrato
    let jsonData = outcome.logs[0]
    //Conversion del dato del contrato a JSON
    let parsedJSON = json.fromString(jsonData)
    let address = ""
    let name = ""
    let price = ""
    let stock = ""
    let enabled = true
    //Verificacion si el JSON es formato Objeto
    if(parsedJSON.kind == JSONValueKind.OBJECT){
      let entry = parsedJSON.toObject()
      //Recorrido de los diferentes valores en el JSON
      for(let i = 0;i < entry.entries.length; i++){
        let key = entry.entries[i].key.toString()
        log.info('key:{}',[key])
        //Asignacion de los valores del JSON
        switch(true){
          case key == 'address':
            address = entry.entries[i].value.toString()
            break
          case key == 'name':
            name = entry.entries[i].value.toString()
            break
          case key == 'price':
            price = entry.entries[i].value.toI64().toString()
            break
          case key == 'stock':
            stock = entry.entries[i].value.toI64().toString()
            break
          case key == 'enabled':
            enabled =  entry.entries[i].value.toBool()
            break
        }
      }
    }
    //Declaracion de la nueva entidad
    let product = new Product(address)
    //Asignacion de valores a la entidad
    product.name = name
    product.price = BigInt.fromString(price)
    product.stock = BigInt.fromString(stock)
    product.enabled = enabled
    //Se guardan los cambios en la entidad
    product.save()
    log.info('Se guardo el producto',[])
  }

  if(functionCall.methodName == "delete_products"){
    log.info('Entro a agregar productos',[])
    //Obtencion del dato bruto del contrato
    let jsonData = outcome.logs[0]
    //Conversion del dato del contrato a JSON
    let parsedJSON = json.fromString(jsonData)
    let address = ""
    let name = ""
    let price = ""
    let stock = ""
    let enabled = true
    //Verificacion si el JSON es formato Objeto
    if(parsedJSON.kind == JSONValueKind.OBJECT){
      let entry = parsedJSON.toObject()
      //Recorrido de los diferentes valores en el JSON
      for(let i = 0;i < entry.entries.length; i++){
        let key = entry.entries[i].key.toString()
        log.info('key:{}',[key])
        //Asignacion de los valores del JSON
        switch(true){
          case key == 'address':
            address = entry.entries[i].value.toString()
            break
          case key == 'name':
            name = entry.entries[i].value.toString()
            break
          case key == 'price':
            price = entry.entries[i].value.toI64().toString()
            break
          case key == 'stock':
            stock = entry.entries[i].value.toI64().toString()
            break
          case key == 'enabled':
            enabled =  entry.entries[i].value.toBool()
            break
        }
      }
    }
    //Busqueda de la entidad ya guardada
    let product = Product.load(address)
    //Verificacion de si la entidad existe
    if(product == null){
      //Si no existe se crea la entidad con la informacion de la transaccion
      product = new Product(address)
      product.name = name
      product.price = BigInt.fromString(price)
      product.stock = BigInt.fromString(stock)
      product.enabled = enabled
    }
    //Se actualiza el dato a modificar
    product.enabled = false
    product.save()
    log.info('Se modifico el producto',[])
  }
}
'''
'''--- tsconfig.json ---
{
  "extends": "@graphprotocol/graph-ts/types/tsconfig.base.json",
  "include": ["src"]
}

'''