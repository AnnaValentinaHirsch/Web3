*GitHub Repository "noemk2/enviar_recivir_rs"*

'''--- Cargo.toml ---
[package]
name = "holamundo_rs"
version = "0.1.0"
authors = ["joi.near"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

#[profile.release]
#codegen-units = 1
## Tell `rustc` to optimize for small code size.
#opt-level = "z"
#lto = true
#debug = false
#panic = "abort"

#[workspace]
#members = []

'''
'''--- README.md ---
Hola mundo en near con Rust 
==================

Introducci√≥n a holamundo en near (Rust)
==================

 un holamundo en near protocol, este contrato te perminte:
 
 1. print "Hello world" 
 2. print "Hello " + $USER
 

üë®‚Äçüíª Instalaci√≥n en local
===========

Para correr este proyecto en local debes seguir los siguientes pasos:

Paso 1: Pre - Requisitos
------------------------------
1. Aseg√∫rese de tener todos los [prequisitos para compilar en rust] (Install Rustup , Add wasm target to your toolchain)
3. Crear un test near account [NEAR test account]
4. Instalar el NEAR CLI globally: [near-cli] es una interfaz de linea de comando (CLI) para interacturar con NEAR blockchain

    yarn install --global near-cli

Step 2: Configura tu NEAR CLI
-------------------------------

Configura tu near-cli para autorizar su cuenta de prueba creada recientemente:

    near login
    
Step 3: Clonar Repositorio
-------------------------------    

Este comando nos permite clonar el repositorio de nuestro proyecto 

```bash
git clone https://github.com/noemk2/holamundo_rs.git
```

Una vez que hayas descargado el repositorio, asegurate de ejecutar los comandos dentro del repositorio descargado. Puedes hacerlo con
```bash
cd holamundo_rs/
```

Step 4: Realiza el BUILD para implementaci√≥n de desarrollo de contrato inteligente 
------------------------------------------------------------------------------------

Instalar dependencias 

```bash
cargo check
```

Cree el c√≥digo de contrato inteligente e implemente el servidor de desarrollo local: 
```bash
sh build.sh
```

Cree la variable local $CONTRACT_NAME (permite guardar tu contrato temporal en una variable facil de recordar)
```bash
source ./neardev/dev-account.env
```

¬°Felicitaciones, ahora tendr√° un entorno de desarrollo local ejecut√°ndose en NEAR TestNet!

‚úèÔ∏è Comando  view : request estatico
-----------------------------------------------

Permite imprimir "Hello world" 

Para Linux:
```bash
near view $CONTRACT_NAME hello_world --account-id <username>.testnet
```

‚úèÔ∏è Comando  call : request dinamico
--------------------------------------------

Permite imprimir "Hello " + <username> .testnet  

Para Linux :
```bash
near call $CONTRACT_NAME hello --account-id <username>.testnet
```

ü§ñ Test 
==================

Las pruebas son parte del desarrollo, luego, para ejecutar las pruebas en el contrato inteligente , debe ejecutar el siguiente comando:

```bash
 cargo test -- --nocapture  
```

==============================================

  [create-near-app]: https://github.com/near/create-near-app
  [prequisitos para compilar en rust]: https://github.com/near/near-sdk-rs#pre-requisites
  [NEAR accounts]: https://docs.near.org/docs/concepts/account
  [NEAR Wallet]: https://wallet.testnet.near.org/
  [near-cli]: https://github.com/near/near-cli
  [NEAR test account]: https://docs.near.org/docs/develop/basics/create-account#creating-a-testnet-account

'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

if [ ! -d ./res ]; then
    mkdir ./res
fi

cp target/wasm32-unknown-unknown/release/*.wasm ./res/
near dev-deploy --wasm_file ./res/*.wasm

'''
'''--- src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
//use near_sdk::AccountId;
use near_sdk::Promise;
use near_sdk::{env, near_bindgen};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract {}

#[near_bindgen]
impl Contract {
    pub fn pagar(&self) -> &str {
        let account_id = env::signer_account_id().to_string();
        let amount: u128 = 1_000_000_000_000_000_000_000_000; // 1 $NEAR as yoctoNEAR

        //let account_id: AccountId = account_id.parse().unwrap();
        Promise::new(account_id).transfer(amount);

        return "pagado... en rs";
    }

    pub fn hello_world(&self) -> &str {
        return "Hello world";
    }

    pub fn hello(&self) -> String {
        let account_id = env::signer_account_id();
        return "Hello ".to_owned() + &account_id.to_string();
    }
}

//test

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    fn get_context(input: Vec<u8>, is_view: bool) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "robert.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: "jane.testnet".to_string(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    #[test]
    fn hello_world() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let contract = Contract {};
        assert_eq!("Hello world", contract.hello_world());
    }

    #[test]
    fn hello() {
        let context = get_context(vec![], false);
        testing_env!(context);
        let contract = Contract {};
        let account_id = env::signer_account_id();
        assert_eq!(
            "Hello ".to_owned() + &account_id.to_string(),
            contract.hello()
        );
    }
}

'''