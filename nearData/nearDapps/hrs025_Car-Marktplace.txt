*GitHub Repository "hrs025/Car-Marktplace"*

'''--- README.md ---
# Near-Car
# Near-Car

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/sample"
  ]
}

'''
'''--- package.json ---
{
  "name": "starter--assemblyscript",
  "version": "0.0.1",
  "description": "Starter project for writing AssemblyScript contracts for NEAR Protocol",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test:unit'",
    "asp": "asp --verbose --nologo",
    "test:unit": "yarn asp -f unit.spec",
    "build": "asb --target debug",
    "build:release": "asb",
    "test": "yarn build:release && yarn test:unit && yarn test:simulate",
    "test:simulate": "cargo test -- --nocapture",
    "clean": "rm -rf ./build && rm -rf ./neardev && rm -rf ./target"
  },
  "keywords": [],
  "author": "hello@near.org",
  "license": "ISC",
  "devDependencies": {},
  "dependencies": {
    "near-sdk-as": "^3.0.0"
  }
}

'''
'''--- scripts/1.init.sh ---
#!/usr/bin/env bash

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable"
[ -z "$OWNER" ] && echo "Missing \$OWNER environment variable"

echo "deleting $CONTRACT and setting $OWNER as beneficiary"
echo
near delete $CONTRACT $OWNER

echo --------------------------------------------
echo
echo "cleaning up the /neardev folder"
echo
rm -rf ./neardev

# exit on first error after this point to avoid redeploying with successful build
set -e

echo --------------------------------------------
echo
echo "rebuilding the contract (release build)"
echo
yarn build:release

echo --------------------------------------------
echo
echo "redeploying the contract"
echo
near dev-deploy ./build/release/sample.wasm

echo --------------------------------------------
echo run the following commands
echo
echo 'export CONTRACT=__new_contract_account_id__'
echo
echo

exit 0

'''
'''--- scripts/2.run.sh ---
#echo 'Call create() function to add new cars to the contract'

near call $CONTRACT create '{"age":5,"carModel":"Hyundaii20", "kilometer":200, "forSale":"false", "price":"22000000000000"}' --accountId hrs069.testnet

#echo 'call getAll() function to view all stored cars on the contract'

near call $CONTRACT getAll --accountId $OWNER --gas 300000000000000 --amount 3

#echo 'call getForSale() function to view for sale cars stored on the contract'

near call $CONTRACT getForSale --accountId $OWNER --gas 300000000000000 --amount 3

#echo 'call getOffset() function to view part of cars stored on the contract'

near call $CONTRACT getOffset '{"offset":'$1', "limit": '$2'}' --accountId $OWNER --gas 300000000000000 --amount 3

#echo 'call getById() function to view car by id on the contract'

near call $CONTRACT getById '{"id":'$1'}' --accountId $OWNER

#echo 'Call updateById() function to update car details on the contract'

near call $CONTRACT updateById '{"id":'$1',"update":'$2'}' --accountId $OWNER

#echo 'Call deleteById() function to update car details on the contract'

near call $CONTRACT deleteById '{"id":'$1'}' --accountId $OWNER

#echo 'Call buy() function to buying car and transfer amount of price buying price should be higher or equal of sell price of car details on the contract'

near call $CONTRACT buy '{"id":'$1',"buyingPrice":"'$2'" }' --accountId $3 #3=buyer
'''
'''--- src/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/sample/__tests__/index.unit.spec.ts ---

'''
'''--- src/sample/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- src/sample/assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/sample/assembly/index.ts ---
import { Car } from "./model";
import { Money } from "./utils";

export function create(age:u8, carModel: string, kilometer:u8, forSale:string, price:Money): Car {
  return Car.addCar(age, carModel, kilometer, forSale, price);
}

export function getAll(): Car[] {
  return Car.getcars();
}

export function getOffset(offset:u32, limit:u32): Car[] { 
  return Car.getcarsOffset(offset,limit);
}

export function getForSale(): Car[] {
  return Car.getcarsForSale();
}

export function getById(id:u32): Car {
  return Car.getCarById(id);
}

export function updateById(id:u32, update:Car): Car {
  return Car.updateCarByid(id, update);
}

export function deleteById (id:u32): void {
  Car.deleteCarById(id);
}

export function deleteOwnerAll (): void {
   Car.deleteOwnerAllcars();
}

export function deleteAll (): void {
  Car.deleteAllcars();
}

export function buy (id:u32, buyingPrice:Money) : Car {
  return Car.buyCar(id, buyingPrice);
} 
'''
'''--- src/sample/assembly/model.ts ---
import { PersistentUnorderedMap, math, u128, context, PersistentSet, RNG, storage, logging, ContractPromiseBatch} from "near-sdk-as";
import { AccountId, Balance, Money } from "./utils";

const random =new RNG<u32>(100,1000);

export const cars = new PersistentUnorderedMap<u32, Car>("car");

export const carID = new PersistentSet<u32>("carID");

storage.set<AccountId>("accountId", context.sender);

@nearBindgen
export class Car {
  id: u32;
  age:u8;
  carModel:string;
  kilometer: u8;
  forSale:string;
  price: Money;
  owner: string;  
  

  constructor(age:u8, carModel: string, kilometer:u8, forSale:string, price:Money ) {   
    this.id = math.hash32<string>(((random.next()).toString())+carModel);
    this.age=age;
    this.carModel=carModel;
    this.kilometer = kilometer;
    this.forSale = forSale;
    this.price=price;
    this.owner= context.sender;

  }

  static addCar(age:u8, carModel: string, kilometer:u8, forSale:string, price:Money): Car {
    
    assert(price>u128.Zero , 'Car price must be bigger than zero.');
    
    const car = new Car(age, carModel, kilometer, forSale, price);

    carID.add(car.id);
    cars.set(car.id, car);

    logging.log(carModel + `Create Success. Created Owner is ${storage.getSome<AccountId>("accountId")}`);
    return car;
  }

  static getcars(): Car[] {
    let offset= 0;
    let limit=cars.length;
  
    return cars.values(offset, offset + limit);
  }

  static getcarsOffset(offset:u32, limit:u32): Car[] {     
      return cars.values(offset, offset + limit);  
  }

  static getCarById(id:u32): Car{
    return cars.getSome(id);
  }

  static getcarsForSale(): Car[]{
    const listForSale: Car[]=new Array<Car>();
    const Ids: u32[] = carID.values(); 

    for(let i=0; i<Ids.length; i++){
      if(this.getCarById(Ids[i]).forSale=='true') {  
       listForSale.push(this.getCarById(Ids[i]));
      }
    }

    return listForSale;
  }

  static updateCarByid(id:u32, update:Car):Car{
    
    const Car= this.getCarById(id);
   
    assert(Car.owner==context.sender,`You are not owner of this Car.You can not update Car details.Created Owner is not ${storage.getSome<AccountId>("accountId")}`);
    
    
    Car.age=update.age ? update.age : Car.age;
    Car.kilometer=update.kilometer ? update.kilometer : Car.kilometer;
    Car.price=update.price && update.price > u128.Zero ? update.price : Car.price;
    Car.forSale=update.forSale ? update.forSale : Car.forSale;
    
    cars.set(id,Car);

    return Car;
  }

static deleteCarById(id:u32):void{

const Car= this.getCarById(id);

assert(Car.owner==context.sender,'You are not owner of this Car.You can not delete it.');

cars.delete(id);
carID.delete(id);
}

static deleteOwnerAllcars(): void {
  const Ids: u32[] = carID.values(); 
  for(let i=0; i<Ids.length; i++){
    if(this.getCarById(Ids[i]).owner==context.sender) {
      
     
      cars.delete(Ids[i]);
      carID.delete(Ids[i]);

    }
  }
  }
  

static deleteAllcars():void{
  cars.clear();
  carID.clear();
  }

 static buyCar(id:u32, buyingPrice:Money) : Car {

    const buyer=context.sender;
    const buyerAccountBalance: Balance= context.accountBalance;
    const Car=this.getCarById(id);
    const CarOwner= Car.owner;

    assert(buyerAccountBalance >= Car.price,`Your account balance is not enought to buy this Car. Check your account and add more money to ${storage.getSome<AccountId>("accountId")}`);
      
    assert(buyingPrice >= Car.price, 'You should offer equal to sale price or more to buy this Car');

    assert(buyer != CarOwner, 'You are already owner of Car you can not buy your Car higher price');
    
    assert(Car.forSale == 'true','Car is not for sale');
    
    ContractPromiseBatch.create(CarOwner).transfer(buyingPrice);

    Car.owner=buyer;
    Car.forSale='false';
    Car.price=buyingPrice;
    cars.set(id,Car);

    return Car;
  }
  
}
'''
'''--- src/sample/assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- src/sample/assembly/utils.ts ---
import { u128, Context, ContractPromise } from "near-sdk-as";

export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

/**
 * Function to assert that the contract has called itself
 */
export function assert_self(): void {
  const caller = Context.predecessor
  const self = Context.contractName
  assert(caller == self, "Only this contract may call itself");
}

export function assert_single_promise_success(): void {
  const x = ContractPromise.getResults()
  assert(x.length == 1, "Expected exactly one promise result")
  assert(x[0].succeeded, "Expected PromiseStatus to be successful")
}
'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { u128 } from "near-sdk-as";

/**
 * == TYPES ====================================================================
 */

/**
 * Account IDs in NEAR are just strings.
 */
export type AccountId = string;

/**
 * Gas is u64
 */
export type Gas = u64;

/**
 * Amounts, Balances, and Money in NEAR is are u128.
 */

export type Amount = u128;

export type Balance = Amount;

export type Money = Amount;

/**
 * Timestamp in NEAR is a number.
 */
export type Timestamp = u64;

/**
 * == CONSTANTS ================================================================
 *
 * ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)
 * XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"
 * MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking
 *
 * TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this
 *  could end up being much higher
 */

export const ONE_NEAR = u128.from("1000000000000000000000000");
export const XCC_GAS: Gas = 20_000_000_000_000;
export const MIN_ACCOUNT_BALANCE: u128 = u128.mul(ONE_NEAR, u128.from(3));

/**
 * == FUNCTIONS ================================================================
 */

/**
 * @function asNEAR
 * @param amount {u128} - Yocto Ⓝ token quantity as an unsigned 128-bit integer
 * @returns {string}    - Amount in NEAR, as a string
 *
 * @example
 *
 *    asNEAR(7000000000000000000000000)
 *    // => '7'
 */
export function asNEAR(amount: u128): string {
  return u128.div(amount, ONE_NEAR).toString();
}

/**
 * @function toYocto
 * @param amount {number} - Integer to convert
 * @returns {u128}        - Amount in yocto Ⓝ as an unsigned 128-bit integer
 *
 * @example
 *
 *    toYocto(7)
 *    // => 7000000000000000000000000
 */
export function toYocto(amount: number): u128 {
  return u128.mul(ONE_NEAR, u128.from(amount))
}

'''