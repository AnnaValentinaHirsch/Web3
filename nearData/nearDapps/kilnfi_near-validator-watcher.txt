*GitHub Repository "kilnfi/near-validator-watcher"*

'''--- .github/release-drafter.yml ---
name-template: 'v$RESOLVED_VERSION'
tag-template: 'v$RESOLVED_VERSION'
change-template: '* $TITLE (#$NUMBER) by @$AUTHOR'
template: |
  $CHANGES

  **Full Changelog**: https://github.com/$OWNER/$REPOSITORY/compare/$PREVIOUS_TAG...v$RESOLVED_VERSION

sort-direction: ascending

categories:
  - title: '‚ö†Ô∏è BREAKING CHANGES'
    label: 'breaking'
  - title: 'üí´ Features'
    label: 'feature'
  - title: 'üõ†Ô∏è Bug fixes'
    label: 'fix'
  - title: 'üïπÔ∏è Others'
    label: 'chore'

version-resolver:
  # Major is not meant to be used at the moment.
  # Should be used with label breaking in the future.
  major:
    labels:
      - 'major'
  minor:
    labels:
      - 'breaking'
      - 'feature'
      - 'chore'
  patch:
    labels:
      - 'fix'

exclude-labels:
  - 'skip-changelog'

autolabeler:
  - label: 'breaking'
    title:
      - '/!:/i'
  - label: 'chore'
    title:
      - '/^chore/i'
  - label: 'fix'
    title:
      - '/^fix/i'
  - label: 'feature'
    title:
      - '/^feat/i'

'''
'''--- README.md ---
# Near Validator Watcher

[![License](https://img.shields.io/badge/license-MIT-blue)](https://opensource.org/licenses/MIT)

**Near Validator Watcher** is a Prometheus exporter to help you monitor missed blocks & chunks of your validator.

![Near Validator Watcher Grafana Dashboard (Prometheus Exporter)](assets/near-validator-watcher-grafana-dashboard.jpg)

## ‚ú® Usage

Example on mainnet using the default RPC endpoint.

### Via compiled binary

Compiled binary can be found on the [Releases page](https://github.com/kilnfi/near-validator-watcher/releases).

```bash
near-validator-watcher \
  --node https://rpc.mainnet.near.org \
  --validator kiln-1.poolv1.near
```

### Via Docker

Latest Docker image can be found on the [Packages page](https://github.com/kilnfi/near-validator-watcher/pkgs/container/near-validator-watcher).

```bash
docker run --rm ghcr.io/kilnfi/near-validator-watcher:latest \
  --node https://rpc.mainnet.near.org \
  --validator kiln-1.poolv1.near
```

### Available options

```
near-validator-watcher --help

NAME:
   near-validator-watcher - NEAR validators monitoring tool

USAGE:
   near-validator-watcher [global options] command [command options] [arguments...]

COMMANDS:
   help, h  Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --http-addr value                        http server address (default: ":8080")
   --log-level value                        log level (debug, info, warn, error) (default: "info")
   --namespace value                        prefix for Prometheus metrics (default: "near_validator_watcher")
   --no-color                               disable colored output (default: false)
   --node value                             rpc node endpoint to connect to (default: "https://rpc.mainnet.near.org")
   --refresh-rate value                     how often to call the rpc endpoint (default: 10s)
   --validator value [ --validator value ]  validator pool id to track
   --help, -h                               show help
   --version, -v                            print the version
```

## ‚ùáÔ∏è Endpoints

- `/metrics` exposed Prometheus metrics (see next section)
- `/ready` responds OK when the node is synced
- `/live` responds OK as soon as server is up & running correctly

## üìä Prometheus metrics

All metrics are by default prefixed by `near_validator_watcher` but this can be changed through options.

Metrics (without prefix)    | Description
----------------------------|-------------------------------------------------------------------------
`block_number`              | The number of most recent block
`chain_id`                  | Near chain id
`current_proposals_stake`   | Current proposals
`epoch_length`              | Near epoch length as specified in the protocol
`epoch_start_height`        | Near epoch start height
`next_validator_stake`      | The next validators
`prev_epoch_kickout`        | Near previous epoch kicked out validators
`protocol_version`          | Current protocol version deployed to the blockchain
`seat_price`                | Validator seat price
`sync_state`                | Sync state
`validator_blocks_expected` | Current amount of validator expected blocks
`validator_blocks_produced` | Current amount of validator produced blocks
`validator_chunks_expected` | Current amount of validator expected chunks
`validator_chunks_produced` | Current amount of validator produced chunks
`validator_rank`            | Current rank of validator based on stake
`validator_slashed`         | Validators slashed
`validator_stake`           | Current amount of validator stake
`version_build`             | The Near node version build

## üìÉ License

[MIT License](LICENSE).

'''
'''--- main.go ---
package main

import (
	"context"
	"errors"
	"os"

	"github.com/kilnfi/near-validator-watcher/pkg/app"
	"github.com/sirupsen/logrus"
	"github.com/urfave/cli/v2"
)

var Version = "v0.0.0-dev" // generated at build time

func main() {
	app := &cli.App{
		Name:    "near-validator-watcher",
		Usage:   "NEAR validators monitoring tool",
		Flags:   app.Flags,
		Action:  app.RunFunc,
		Version: Version,
	}

	if err := app.Run(os.Args); err != nil && !errors.Is(err, context.Canceled) {
		logrus.WithError(err).Fatal("application failed")
	}
}

'''
'''--- pkg/app/flags.go ---
package app

import (
	"time"

	"github.com/urfave/cli/v2"
)

var Flags = []cli.Flag{
	&cli.StringFlag{
		Name:  "http-addr",
		Usage: "http server address",
		Value: ":8080",
	},
	&cli.StringFlag{
		Name:  "log-level",
		Usage: "log level (debug, info, warn, error)",
		Value: "info",
	},
	&cli.StringFlag{
		Name:  "namespace",
		Usage: "prefix for Prometheus metrics",
		Value: "near_validator_watcher",
	},
	&cli.BoolFlag{
		Name:  "no-color",
		Usage: "disable colored output",
	},
	&cli.StringFlag{
		Name:  "node",
		Usage: "rpc node endpoint to connect to",
		Value: "https://rpc.mainnet.near.org",
	},
	&cli.DurationFlag{
		Name:  "refresh-rate",
		Usage: "how often to call the rpc endpoint",
		Value: 10 * time.Second,
	},
	&cli.StringSliceFlag{
		Name:  "validator",
		Usage: "validator pool id to track",
	},
}

'''
'''--- pkg/app/http.go ---
package app

import (
	"context"
	"fmt"
	"net/http"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

type Probe func() bool

var upProbe Probe = func() bool { return true }

type HTTPServer struct {
	*http.Server
}

type HTTPMuxOption func(*http.ServeMux)

func withProbe(path string, probe Probe) HTTPMuxOption {
	return func(mux *http.ServeMux) {
		mux.HandleFunc(path, probeHandler(probe))
	}
}

func WithReadyProbe(probe Probe) HTTPMuxOption {
	return withProbe("/ready", probe)
}

func WithLiveProbe(probe Probe) HTTPMuxOption {
	return withProbe("/live", probe)
}

func WithMetrics(registry *prometheus.Registry) HTTPMuxOption {
	return func(mux *http.ServeMux) {
		mux.Handle("/metrics", promhttp.HandlerFor(registry, promhttp.HandlerOpts{}))
	}
}

func NewHTTPServer(addr string, options ...HTTPMuxOption) *HTTPServer {
	mux := http.NewServeMux()
	server := &HTTPServer{
		Server: &http.Server{
			Addr:    addr,
			Handler: mux,
		},
	}

	for _, option := range options {
		option(mux)
	}

	return server
}

func (s *HTTPServer) Run() error {
	return s.listenAndServe()
}

func (s *HTTPServer) Shutdown(ctx context.Context) error {
	return s.Server.Shutdown(ctx)
}

func (s *HTTPServer) listenAndServe() error {
	err := s.Server.ListenAndServe()

	if err != nil && err != http.ErrServerClosed {
		return fmt.Errorf("failed starting HTTP server: %w", err)
	}

	return nil
}

func probeHandler(probe Probe) http.HandlerFunc {
	return func(w http.ResponseWriter, r *http.Request) {
		if probe() {
			w.WriteHeader(http.StatusNoContent)
		} else {
			w.WriteHeader(http.StatusServiceUnavailable)
		}
	}
}

'''
'''--- pkg/app/run.go ---
package app

import (
	"context"
	"os"
	"os/signal"
	"syscall"
	"time"

	"github.com/fatih/color"
	"github.com/kilnfi/near-validator-watcher/pkg/metrics"
	"github.com/kilnfi/near-validator-watcher/pkg/near"
	"github.com/kilnfi/near-validator-watcher/pkg/watcher"
	"github.com/prometheus/client_golang/prometheus"
	"github.com/sirupsen/logrus"
	"github.com/urfave/cli/v2"
	"golang.org/x/sync/errgroup"
)

func RunFunc(cCtx *cli.Context) error {
	var (
		ctx = cCtx.Context

		// Config flags
		httpAddr    = cCtx.String("http-addr")
		logLevel    = cCtx.String("log-level")
		namespace   = cCtx.String("namespace")
		noColor     = cCtx.Bool("no-color")
		node        = cCtx.String("node")
		refreshRate = cCtx.Duration("refresh-rate")
		validators  = cCtx.StringSlice("validator")
	)

	//
	// Setup
	//
	// Logger setup
	logrus.SetOutput(os.Stdout)
	logrus.SetLevel(logLevelFromString(logLevel))
	logrus.SetFormatter(&logrus.TextFormatter{
		DisableColors: noColor,
	})

	// Disable colored output if requested
	color.NoColor = noColor

	// Handle signals via context
	ctx, stop := signal.NotifyContext(ctx, os.Interrupt, syscall.SIGINT, syscall.SIGTERM)
	defer stop()

	// Create errgroup to manage all goroutines
	errg, ctx := errgroup.WithContext(ctx)

	//
	// Validator Watcher
	//
	logrus.Infof("connecting to node %s", node)

	client := near.NewClient(node)

	registry := prometheus.NewRegistry()
	metrics := metrics.New(namespace)
	metrics.Register(registry)

	watcher := watcher.New(client, metrics, &watcher.Config{
		Writer:          os.Stdout,
		TrackedAccounts: validators,
		RefreshRate:     refreshRate,
	})
	errg.Go(func() error {
		return watcher.Start(ctx)
	})

	//
	// HTTP server
	//
	logrus.Infof("starting HTTP server on %s", httpAddr)
	readyProbe := watcher.IsSynced
	httpServer := NewHTTPServer(
		httpAddr,
		WithReadyProbe(readyProbe),
		WithLiveProbe(upProbe),
		WithMetrics(registry),
	)
	errg.Go(func() error {
		return httpServer.Run()
	})

	//
	// Wait for context to be cancelled (via signals or error from errgroup)
	//
	<-ctx.Done()
	logrus.Info("shutting down")

	//
	// Stop all watchers and exporter
	//
	ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
	defer cancel()

	if err := httpServer.Shutdown(ctx); err != nil {
		logrus.WithError(err).Errorf("failed to stop http server")
	}

	// Wait for all goroutines to finish
	return errg.Wait()
}

'''
'''--- pkg/app/utils.go ---
package app

import "github.com/sirupsen/logrus"

func logLevelFromString(level string) logrus.Level {
	switch level {
	case "debug":
		return logrus.DebugLevel
	case "info":
		return logrus.InfoLevel
	case "warn":
		return logrus.WarnLevel
	case "error":
		return logrus.ErrorLevel
	default:
		return logrus.InfoLevel
	}
}

'''
'''--- pkg/metrics/metrics.go ---
package metrics

import (
	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/collectors"
)

type Metrics struct {
	BlockNumber             prometheus.Gauge
	ChainID                 *prometheus.GaugeVec
	CurrentProposals        *prometheus.GaugeVec
	EpochLength             prometheus.Gauge
	EpochStartHeight        prometheus.Gauge
	NextValidatorStake      *prometheus.GaugeVec
	PrevEpochKickout        *prometheus.GaugeVec
	ProtocolVersion         prometheus.Gauge
	SeatPrice               prometheus.Gauge
	SyncingDesc             prometheus.Gauge
	ValidatorExpectedBlocks *prometheus.GaugeVec
	ValidatorExpectedChunks *prometheus.GaugeVec
	ValidatorProducedBlocks *prometheus.GaugeVec
	ValidatorProducedChunks *prometheus.GaugeVec
	ValidatorSlashed        *prometheus.GaugeVec
	ValidatorStake          *prometheus.GaugeVec
	ValidatorRank           *prometheus.GaugeVec
	VersionBuild            *prometheus.GaugeVec
}

func New(namespace string) *Metrics {
	return &Metrics{
		BlockNumber: prometheus.NewGauge(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "block_number",
			Help:      "The number of most recent block",
		}),
		ChainID: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "chain_id",
			Help:      "Near chain id"},
			[]string{"chain_id"},
		),
		CurrentProposals: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "current_proposals_stake",
			Help:      "Current proposals"},
			[]string{"account_id", "public_key", "epoch_start_height", "tracked"},
		),
		EpochLength: prometheus.NewGauge(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "epoch_length",
			Help:      "Near epoch length as specified in the protocol",
		}),
		EpochStartHeight: prometheus.NewGauge(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "epoch_start_height",
			Help:      "Near epoch start height",
		}),
		NextValidatorStake: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "next_validator_stake",
			Help:      "The next validators"},
			[]string{"account_id", "public_key", "epoch_start_height", "tracked"},
		),
		PrevEpochKickout: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "prev_epoch_kickout",
			Help:      "Near previous epoch kicked out validators"},
			[]string{"account_id", "reason", "epoch_start_height", "tracked"},
		),
		ProtocolVersion: prometheus.NewGauge(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "protocol_version",
			Help:      "Current protocol version deployed to the blockchain",
		}),
		SeatPrice: prometheus.NewGauge(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "seat_price",
			Help:      "Validator seat price",
		}),
		SyncingDesc: prometheus.NewGauge(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "sync_state",
			Help:      "Sync state",
		}),
		ValidatorExpectedBlocks: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "validator_blocks_expected",
			Help:      "Current amount of validator expected blocks"},
			[]string{"account_id", "public_key", "epoch_start_height", "tracked"},
		),
		ValidatorExpectedChunks: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "validator_chunks_expected",
			Help:      "Current amount of validator expected chunks"},
			[]string{"account_id", "public_key", "epoch_start_height", "tracked"},
		),
		ValidatorProducedBlocks: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "validator_blocks_produced",
			Help:      "Current amount of validator produced blocks"},
			[]string{"account_id", "public_key", "epoch_start_height", "tracked"},
		),
		ValidatorProducedChunks: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "validator_chunks_produced",
			Help:      "Current amount of validator produced chunks"},
			[]string{"account_id", "public_key", "epoch_start_height", "tracked"},
		),
		ValidatorSlashed: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "validator_slashed",
			Help:      "Validators slashed"},
			[]string{"account_id", "public_key", "epoch_start_height", "tracked"},
		),
		ValidatorStake: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "validator_stake",
			Help:      "Current amount of validator stake"},
			[]string{"account_id", "public_key", "epoch_start_height", "tracked"},
		),
		ValidatorRank: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "validator_rank",
			Help:      "Current rank of validator based on stake"},
			[]string{"account_id", "public_key", "epoch_start_height", "tracked"},
		),
		VersionBuild: prometheus.NewGaugeVec(prometheus.GaugeOpts{
			Namespace: namespace,
			Name:      "version_build",
			Help:      "The Near node version build"},
			[]string{"version", "build"},
		),
	}
}

func (m *Metrics) Register(reg prometheus.Registerer) {
	reg.MustRegister(collectors.NewProcessCollector(collectors.ProcessCollectorOpts{}))
	reg.MustRegister(collectors.NewGoCollector())

	reg.MustRegister(m.BlockNumber)
	reg.MustRegister(m.ChainID)
	reg.MustRegister(m.CurrentProposals)
	reg.MustRegister(m.EpochLength)
	reg.MustRegister(m.EpochStartHeight)
	reg.MustRegister(m.NextValidatorStake)
	reg.MustRegister(m.PrevEpochKickout)
	reg.MustRegister(m.ProtocolVersion)
	reg.MustRegister(m.SeatPrice)
	reg.MustRegister(m.SyncingDesc)
	reg.MustRegister(m.ValidatorExpectedBlocks)
	reg.MustRegister(m.ValidatorExpectedChunks)
	reg.MustRegister(m.ValidatorProducedBlocks)
	reg.MustRegister(m.ValidatorProducedChunks)
	reg.MustRegister(m.ValidatorSlashed)
	reg.MustRegister(m.ValidatorStake)
	reg.MustRegister(m.ValidatorRank)
	reg.MustRegister(m.VersionBuild)
}

'''
'''--- pkg/metrics/utils.go ---
package metrics

import "hash/fnv"

func BoolToFloat64(b bool) float64 {
	if b {
		return 1
	}
	return 0
}

func StringToFloat64(s string) float64 {
	h := fnv.New32a()
	h.Write([]byte(s))
	return float64(h.Sum32())
}

'''
'''--- pkg/metrics/utils_test.go ---
package metrics

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestBoolToFloat64(t *testing.T) {
	assert.Equal(t, float64(1), BoolToFloat64(true))
	assert.Equal(t, float64(0), BoolToFloat64(false))
}

func TestStringToFloat64(t *testing.T) {
	assert.NotEqual(t, float64(0), StringToFloat64("foobar"))
}

'''
'''--- pkg/near/block.go ---
package near

import "context"

type BlockRequest struct {
	Finality string      `json:"finality,omitempty"`
	BlockID  interface{} `json:"block_id,omitempty"`
}

type BlockResponse struct {
	Author string `json:"author"`
	Header struct {
		Height                int           `json:"height"`
		EpochID               string        `json:"epoch_id"`
		NextEpochID           string        `json:"next_epoch_id"`
		Hash                  string        `json:"hash"`
		PrevHash              string        `json:"prev_hash"`
		PrevStateRoot         string        `json:"prev_state_root"`
		ChunkReceiptsRoot     string        `json:"chunk_receipts_root"`
		ChunkHeadersRoot      string        `json:"chunk_headers_root"`
		ChunkTxRoot           string        `json:"chunk_tx_root"`
		OutcomeRoot           string        `json:"outcome_root"`
		ChunksIncluded        int           `json:"chunks_included"`
		ChallengesRoot        string        `json:"challenges_root"`
		Timestamp             int64         `json:"timestamp"`
		TimestampNanosec      string        `json:"timestamp_nanosec"`
		RandomValue           string        `json:"random_value"`
		ValidatorProposals    []interface{} `json:"validator_proposals"`
		ChunkMask             []bool        `json:"chunk_mask"`
		GasPrice              string        `json:"gas_price"`
		RentPaid              string        `json:"rent_paid"`
		ValidatorReward       string        `json:"validator_reward"`
		TotalSupply           string        `json:"total_supply"`
		ChallengesResult      []interface{} `json:"challenges_result"`
		LastFinalBlock        string        `json:"last_final_block"`
		LastDsFinalBlock      string        `json:"last_ds_final_block"`
		NextBpHash            string        `json:"next_bp_hash"`
		BlockMerkleRoot       string        `json:"block_merkle_root"`
		Approvals             []interface{} `json:"approvals"`
		Signature             string        `json:"signature"`
		LatestProtocolVersion int           `json:"latest_protocol_version"`
	} `json:"header"`
	Chunks []struct {
		ChunkHash            string        `json:"chunk_hash"`
		PrevBlockHash        string        `json:"prev_block_hash"`
		OutcomeRoot          string        `json:"outcome_root"`
		PrevStateRoot        string        `json:"prev_state_root"`
		EncodedMerkleRoot    string        `json:"encoded_merkle_root"`
		EncodedLength        int           `json:"encoded_length"`
		HeightCreated        int           `json:"height_created"`
		HeightIncluded       int           `json:"height_included"`
		ShardID              int           `json:"shard_id"`
		GasUsed              int           `json:"gas_used"`
		GasLimit             int64         `json:"gas_limit"`
		RentPaid             string        `json:"rent_paid"`
		ValidatorReward      string        `json:"validator_reward"`
		BalanceBurnt         string        `json:"balance_burnt"`
		OutgoingReceiptsRoot string        `json:"outgoing_receipts_root"`
		TxRoot               string        `json:"tx_root"`
		ValidatorProposals   []interface{} `json:"validator_proposals"`
		Signature            string        `json:"signature"`
	} `json:"chunks"`
}

func (c *Client) Block(ctx context.Context, blockID uint64) (BlockResponse, error) {
	var req BlockRequest
	var resp BlockResponse

	req.BlockID = blockID
	err := c.call(ctx, "block", req, &resp)
	return resp, err
}

'''
'''--- pkg/near/call_function.go ---
package near

import (
	"context"
)

// CallFunctionResponse holds information about the result of a function call.
type CallFunctionResponse struct {
	QueryResponse
	Logs   []string `json:"logs"`
	Result []byte   `json:"result"`
}

func (c *Client) CallFunction(
	ctx context.Context,
	accountID string,
	methodName string,
	opts ...QueryOption,
) (CallFunctionResponse, error) {
	var resp CallFunctionResponse
	req, err := NewQueryRequest("call_function", accountID, methodName, opts...)
	if err != nil {
		return resp, err
	}
	err = c.call(ctx, "query", req, &resp)
	return resp, err
}

'''
'''--- pkg/near/client.go ---
package near

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
)

type Client struct {
	httpClient *http.Client
	Endpoint   string
}

type Payload struct {
	JsonRPC string      `json:"jsonrpc"`
	Id      string      `json:"id"`
	Method  string      `json:"method"`
	Params  interface{} `json:"params"`
}

type Response struct {
	JsonRPC string          `json:"jsonrpc"`
	Id      string          `json:"id"`
	Result  json.RawMessage `json:"result"`
	Error   struct {
		Name    string `json:"name"`
		Code    int    `json:"code"`
		Message string `json:"message"`
		Data    string `json:"data"`
		Cause   struct {
			Info interface{} `json:"info"`
			Name string      `json:"name"`
		} `json:"cause"`
	} `json:"error"`
}

type Option func(*Client)

func WithHTTPClient(httpClient *http.Client) Option {
	return func(c *Client) {
		c.httpClient = httpClient
	}
}

func NewClient(endpoint string, options ...Option) *Client {
	client := &Client{
		Endpoint:   endpoint,
		httpClient: &http.Client{},
	}

	for _, option := range options {
		option(client)
	}

	return client
}

func (c *Client) Request(ctx context.Context, method string, params interface{}) (*Response, error) {
	payload, err := json.Marshal(map[string]string{
		"query": method,
	})
	if err != nil {
		log.Println(err)
	}

	if params != "" {
		p := Payload{
			JsonRPC: "2.0",
			Id:      "near_exporter",
			Method:  method,
			Params:  params,
		}

		payload, err = json.Marshal(p)
		if err != nil {
			log.Println(err)
		}
	}

	req, err := http.NewRequestWithContext(ctx, "POST", c.Endpoint, bytes.NewBuffer(payload))
	req.Header.Set("Content-Type", "application/json")
	if err != nil {
		return nil, err
	}

	r, err := c.httpClient.Do(req)
	if err != nil {
		return nil, err
	}
	defer r.Body.Close()

	body, err := ioutil.ReadAll(r.Body)
	if err != nil {
		return nil, err
	}

	var resp *Response
	err = json.Unmarshal(body, &resp)

	if err != nil {
		return nil, err
	}

	return resp, nil
}

func (c *Client) call(ctx context.Context, method string, params interface{}, result interface{}) error {
	resp, err := c.Request(ctx, method, params)
	if err != nil {
		return err
	}

	if resp.Error.Name != "" {
		return fmt.Errorf(
			"jsonrpc error(%d): %s %s",
			resp.Error.Code,
			resp.Error.Name,
			resp.Error.Message,
		)
	}

	err = json.Unmarshal(resp.Result, &result)
	if err != nil {
		return err
	}

	return nil
}

'''
'''--- pkg/near/protocol_config.go ---
package near

import (
	"context"
	"time"
)

type ProtocolConfigResponse struct {
	ProtocolVersion                 int       `json:"protocol_version"`
	GenesisTime                     time.Time `json:"genesis_time"`
	ChainID                         string    `json:"chain_id"`
	GenesisHeight                   int       `json:"genesis_height"`
	NumBlockProducerSeats           int       `json:"num_block_producer_seats"`
	NumBlockProducerSeatsPerShard   []int     `json:"num_block_producer_seats_per_shard"`
	AvgHiddenValidatorSeatsPerShard []int     `json:"avg_hidden_validator_seats_per_shard"`
	DynamicResharding               bool      `json:"dynamic_resharding"`
	ProtocolUpgradeStakeThreshold   []int     `json:"protocol_upgrade_stake_threshold"`
	EpochLength                     int       `json:"epoch_length"`
	GasLimit                        int64     `json:"gas_limit"`
	MinGasPrice                     string    `json:"min_gas_price"`
	MaxGasPrice                     string    `json:"max_gas_price"`
	BlockProducerKickoutThreshold   int       `json:"block_producer_kickout_threshold"`
	ChunkProducerKickoutThreshold   int       `json:"chunk_producer_kickout_threshold"`
	OnlineMinThreshold              []int     `json:"online_min_threshold"`
	OnlineMaxThreshold              []int     `json:"online_max_threshold"`
	GasPriceAdjustmentRate          []int     `json:"gas_price_adjustment_rate"`
	RuntimeConfig                   struct {
		StorageAmountPerByte string `json:"storage_amount_per_byte"`
		TransactionCosts     struct {
			ActionReceiptCreationConfig struct {
				SendSir    int64 `json:"send_sir"`
				SendNotSir int64 `json:"send_not_sir"`
				Execution  int64 `json:"execution"`
			} `json:"action_receipt_creation_config"`
			DataReceiptCreationConfig struct {
				BaseCost struct {
					SendSir    int64 `json:"send_sir"`
					SendNotSir int64 `json:"send_not_sir"`
					Execution  int64 `json:"execution"`
				} `json:"base_cost"`
				CostPerByte struct {
					SendSir    int `json:"send_sir"`
					SendNotSir int `json:"send_not_sir"`
					Execution  int `json:"execution"`
				} `json:"cost_per_byte"`
			} `json:"data_receipt_creation_config"`
			ActionCreationConfig struct {
				CreateAccountCost struct {
					SendSir    int64 `json:"send_sir"`
					SendNotSir int64 `json:"send_not_sir"`
					Execution  int64 `json:"execution"`
				} `json:"create_account_cost"`
				DeployContractCost struct {
					SendSir    int64 `json:"send_sir"`
					SendNotSir int64 `json:"send_not_sir"`
					Execution  int64 `json:"execution"`
				} `json:"deploy_contract_cost"`
				DeployContractCostPerByte struct {
					SendSir    int `json:"send_sir"`
					SendNotSir int `json:"send_not_sir"`
					Execution  int `json:"execution"`
				} `json:"deploy_contract_cost_per_byte"`
				FunctionCallCost struct {
					SendSir    int64 `json:"send_sir"`
					SendNotSir int64 `json:"send_not_sir"`
					Execution  int64 `json:"execution"`
				} `json:"function_call_cost"`
				FunctionCallCostPerByte struct {
					SendSir    int `json:"send_sir"`
					SendNotSir int `json:"send_not_sir"`
					Execution  int `json:"execution"`
				} `json:"function_call_cost_per_byte"`
				TransferCost struct {
					SendSir    int64 `json:"send_sir"`
					SendNotSir int64 `json:"send_not_sir"`
					Execution  int64 `json:"execution"`
				} `json:"transfer_cost"`
				StakeCost struct {
					SendSir    int64 `json:"send_sir"`
					SendNotSir int64 `json:"send_not_sir"`
					Execution  int64 `json:"execution"`
				} `json:"stake_cost"`
				AddKeyCost struct {
					FullAccessCost struct {
						SendSir    int64 `json:"send_sir"`
						SendNotSir int64 `json:"send_not_sir"`
						Execution  int64 `json:"execution"`
					} `json:"full_access_cost"`
					FunctionCallCost struct {
						SendSir    int64 `json:"send_sir"`
						SendNotSir int64 `json:"send_not_sir"`
						Execution  int64 `json:"execution"`
					} `json:"function_call_cost"`
					FunctionCallCostPerByte struct {
						SendSir    int `json:"send_sir"`
						SendNotSir int `json:"send_not_sir"`
						Execution  int `json:"execution"`
					} `json:"function_call_cost_per_byte"`
				} `json:"add_key_cost"`
				DeleteKeyCost struct {
					SendSir    int64 `json:"send_sir"`
					SendNotSir int64 `json:"send_not_sir"`
					Execution  int64 `json:"execution"`
				} `json:"delete_key_cost"`
				DeleteAccountCost struct {
					SendSir    int64 `json:"send_sir"`
					SendNotSir int64 `json:"send_not_sir"`
					Execution  int64 `json:"execution"`
				} `json:"delete_account_cost"`
			} `json:"action_creation_config"`
			StorageUsageConfig struct {
				NumBytesAccount     int `json:"num_bytes_account"`
				NumExtraBytesRecord int `json:"num_extra_bytes_record"`
			} `json:"storage_usage_config"`
			BurntGasReward                    []int `json:"burnt_gas_reward"`
			PessimisticGasPriceInflationRatio []int `json:"pessimistic_gas_price_inflation_ratio"`
		} `json:"transaction_costs"`
		WasmConfig struct {
			ExtCosts struct {
				Base                        int   `json:"base"`
				ContractCompileBase         int   `json:"contract_compile_base"`
				ContractCompileBytes        int   `json:"contract_compile_bytes"`
				ReadMemoryBase              int64 `json:"read_memory_base"`
				ReadMemoryByte              int   `json:"read_memory_byte"`
				WriteMemoryBase             int64 `json:"write_memory_base"`
				WriteMemoryByte             int   `json:"write_memory_byte"`
				ReadRegisterBase            int64 `json:"read_register_base"`
				ReadRegisterByte            int   `json:"read_register_byte"`
				WriteRegisterBase           int64 `json:"write_register_base"`
				WriteRegisterByte           int   `json:"write_register_byte"`
				Utf8DecodingBase            int64 `json:"utf8_decoding_base"`
				Utf8DecodingByte            int   `json:"utf8_decoding_byte"`
				Utf16DecodingBase           int64 `json:"utf16_decoding_base"`
				Utf16DecodingByte           int   `json:"utf16_decoding_byte"`
				Sha256Base                  int64 `json:"sha256_base"`
				Sha256Byte                  int   `json:"sha256_byte"`
				Keccak256Base               int64 `json:"keccak256_base"`
				Keccak256Byte               int   `json:"keccak256_byte"`
				Keccak512Base               int64 `json:"keccak512_base"`
				Keccak512Byte               int   `json:"keccak512_byte"`
				Ripemd160Base               int   `json:"ripemd160_base"`
				Ripemd160Block              int   `json:"ripemd160_block"`
				EcrecoverBase               int64 `json:"ecrecover_base"`
				LogBase                     int64 `json:"log_base"`
				LogByte                     int   `json:"log_byte"`
				StorageWriteBase            int64 `json:"storage_write_base"`
				StorageWriteKeyByte         int   `json:"storage_write_key_byte"`
				StorageWriteValueByte       int   `json:"storage_write_value_byte"`
				StorageWriteEvictedByte     int   `json:"storage_write_evicted_byte"`
				StorageReadBase             int64 `json:"storage_read_base"`
				StorageReadKeyByte          int   `json:"storage_read_key_byte"`
				StorageReadValueByte        int   `json:"storage_read_value_byte"`
				StorageRemoveBase           int64 `json:"storage_remove_base"`
				StorageRemoveKeyByte        int   `json:"storage_remove_key_byte"`
				StorageRemoveRetValueByte   int   `json:"storage_remove_ret_value_byte"`
				StorageHasKeyBase           int64 `json:"storage_has_key_base"`
				StorageHasKeyByte           int   `json:"storage_has_key_byte"`
				StorageIterCreatePrefixBase int   `json:"storage_iter_create_prefix_base"`
				StorageIterCreatePrefixByte int   `json:"storage_iter_create_prefix_byte"`
				StorageIterCreateRangeBase  int   `json:"storage_iter_create_range_base"`
				StorageIterCreateFromByte   int   `json:"storage_iter_create_from_byte"`
				StorageIterCreateToByte     int   `json:"storage_iter_create_to_byte"`
				StorageIterNextBase         int   `json:"storage_iter_next_base"`
				StorageIterNextKeyByte      int   `json:"storage_iter_next_key_byte"`
				StorageIterNextValueByte    int   `json:"storage_iter_next_value_byte"`
				TouchingTrieNode            int64 `json:"touching_trie_node"`
				PromiseAndBase              int   `json:"promise_and_base"`
				PromiseAndPerPromise        int   `json:"promise_and_per_promise"`
				PromiseReturn               int   `json:"promise_return"`
				ValidatorStakeBase          int64 `json:"validator_stake_base"`
				ValidatorTotalStakeBase     int64 `json:"validator_total_stake_base"`
			} `json:"ext_costs"`
			GrowMemCost   int `json:"grow_mem_cost"`
			RegularOpCost int `json:"regular_op_cost"`
			LimitConfig   struct {
				MaxGasBurnt                      int64 `json:"max_gas_burnt"`
				MaxStackHeight                   int   `json:"max_stack_height"`
				StackLimiterVersion              int   `json:"stack_limiter_version"`
				InitialMemoryPages               int   `json:"initial_memory_pages"`
				MaxMemoryPages                   int   `json:"max_memory_pages"`
				RegistersMemoryLimit             int   `json:"registers_memory_limit"`
				MaxRegisterSize                  int   `json:"max_register_size"`
				MaxNumberRegisters               int   `json:"max_number_registers"`
				MaxNumberLogs                    int   `json:"max_number_logs"`
				MaxTotalLogLength                int   `json:"max_total_log_length"`
				MaxTotalPrepaidGas               int64 `json:"max_total_prepaid_gas"`
				MaxActionsPerReceipt             int   `json:"max_actions_per_receipt"`
				MaxNumberBytesMethodNames        int   `json:"max_number_bytes_method_names"`
				MaxLengthMethodName              int   `json:"max_length_method_name"`
				MaxArgumentsLength               int   `json:"max_arguments_length"`
				MaxLengthReturnedData            int   `json:"max_length_returned_data"`
				MaxContractSize                  int   `json:"max_contract_size"`
				MaxTransactionSize               int   `json:"max_transaction_size"`
				MaxLengthStorageKey              int   `json:"max_length_storage_key"`
				MaxLengthStorageValue            int   `json:"max_length_storage_value"`
				MaxPromisesPerFunctionCallAction int   `json:"max_promises_per_function_call_action"`
				MaxNumberInputDataDependencies   int   `json:"max_number_input_data_dependencies"`
				MaxFunctionsNumberPerContract    int   `json:"max_functions_number_per_contract"`
			} `json:"limit_config"`
		} `json:"wasm_config"`
		AccountCreationConfig struct {
			MinAllowedTopLevelAccountLength int    `json:"min_allowed_top_level_account_length"`
			RegistrarAccountID              string `json:"registrar_account_id"`
		} `json:"account_creation_config"`
	} `json:"runtime_config"`
	TransactionValidityPeriod int    `json:"transaction_validity_period"`
	ProtocolRewardRate        []int  `json:"protocol_reward_rate"`
	MaxInflationRate          []int  `json:"max_inflation_rate"`
	NumBlocksPerYear          int    `json:"num_blocks_per_year"`
	ProtocolTreasuryAccount   string `json:"protocol_treasury_account"`
	FishermenThreshold        string `json:"fishermen_threshold"`
	MinimumStakeDivisor       int    `json:"minimum_stake_divisor"`
}

func (c *Client) ProtocolConfig(ctx context.Context) (ProtocolConfigResponse, error) {
	var resp ProtocolConfigResponse
	err := c.call(ctx, "EXPERIMENTAL_protocol_config", map[string]string{"finality": "final"}, &resp)
	return resp, err
}

'''
'''--- pkg/near/query.go ---
package near

import (
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
)

// QueryRequest is used for RPC query requests.
type QueryRequest struct {
	RequestType  string      `json:"request_type"`
	Finality     string      `json:"finality,omitempty"`
	BlockID      interface{} `json:"block_id,omitempty"`
	AccountID    string      `json:"account_id,omitempty"`
	PrefixBase64 string      `json:"prefix_base64"`
	MethodName   string      `json:"method_name,omitempty"`
	ArgsBase64   string      `json:"args_base64"`
	PublicKey    string      `json:"public_key,omitempty"`
}

func NewQueryRequest(requestType, accountID, methodName string, opts ...QueryOption) (QueryRequest, error) {
	req := QueryRequest{
		RequestType: requestType,
		AccountID:   accountID,
		MethodName:  methodName,
	}

	for _, opt := range opts {
		if err := opt(&req); err != nil {
			return req, err
		}
	}
	return req, nil
}

// QueryResponse is a base type used for responses to query requests.
type QueryResponse struct {
	BlockHash   string `json:"block_hash"`
	BlockHeight int    `json:"block_height"`
	// TODO: this property is undocumented, but appears in some API responses. Is this the right place for it?
	Error string `json:"error"`
}

// QueryOption controls the behavior when calling CallFunction.
type QueryOption func(*QueryRequest) error

// QueryWithFinality specifies the finality to be used when calling the function.
func QueryWithFinality(finality string) QueryOption {
	return func(qr *QueryRequest) error {
		qr.Finality = finality
		return nil
	}
}

// QueryWithBlockHeight specifies the block height to call the function for.
func QueryWithBlockHeight(blockHeight int64) QueryOption {
	return func(qr *QueryRequest) error {
		qr.BlockID = blockHeight
		return nil
	}
}

// QueryWithBlockHash specifies the block hash to call the function for.
func QueryWithBlockHash(blockHash string) QueryOption {
	return func(qr *QueryRequest) error {
		qr.BlockID = blockHash
		return nil
	}
}

// QueryWithArgs specified the args to call the function with.
// Should be a JSON encodable object.
func QueryWithArgs(args interface{}) QueryOption {
	return func(qr *QueryRequest) error {
		if args == nil {
			args = make(map[string]interface{})
		}
		bytes, err := json.Marshal(args)
		if err != nil {
			return err
		}
		qr.ArgsBase64 = base64.StdEncoding.EncodeToString(bytes)
		return nil
	}
}

func (c *Client) Query(ctx context.Context, req QueryRequest, resp interface{}) error {
	if req.BlockID == nil && req.Finality == "" {
		return fmt.Errorf("missing block_id or finality")
	}
	if req.BlockID != nil && req.Finality != "" {
		return fmt.Errorf("you can't use both block_id and finality")
	}
	return c.call(ctx, "query", req, &resp)
}

'''
'''--- pkg/near/status.go ---
package near

import "context"

type StatusResponse struct {
	ChainID               string `json:"chain_id"`
	LatestProtocolVersion int    `json:"latest_protocol_version"`
	ProtocolVersion       int    `json:"protocol_version"`
	RpcAddr               string `json:"rpc_addr"`
	SyncInfo              struct {
		EarliestBlockHash   string `json:"earliest_block_hash"`
		EarliestBlockHeight uint64 `json:"earliest_block_height"`
		EarliestBlockTime   string `json:"earliest_block_time"`
		LatestBlockHash     string `json:"latest_block_hash"`
		LatestBlockHeight   uint64 `json:"latest_block_height"`
		LatestStateRoot     string `json:"latest_state_root"`
		LatestBlockTime     string `json:"latest_block_time"`
		Syncing             bool   `json:"syncing"`
	} `json:"sync_info"`
	//Validators []string `json:"validators"`
	Version struct {
		Version string `json:"version"`
		Build   string `json:"build"`
	} `json:"version"`
}

func (c *Client) Status(ctx context.Context) (StatusResponse, error) {
	var resp StatusResponse
	err := c.call(ctx, "status", nil, &resp)
	return resp, err
}

'''
'''--- pkg/near/testutils/server.go ---
package testutils

import (
	"net/http"
	"net/http/httptest"
)

type ExpectedResponse struct {
	StatusCode int
	Body       []byte
}

func (r *ExpectedResponse) ExpectResponse(statusCode int, body string) {
	r.StatusCode = statusCode
	r.Body = []byte(body)
}

func NewServer(resp *ExpectedResponse) *httptest.Server {
	return httptest.NewServer(http.HandlerFunc(func(res http.ResponseWriter, req *http.Request) {
		res.WriteHeader(resp.StatusCode)
		res.Write(resp.Body)
	}))
}

'''
'''--- pkg/near/tx.go ---
package near

import "context"

type TxResponse struct {
	ReceiptsOutcome []struct {
		BlockHash string `json:"block_hash"`
		ID        string `json:"id"`
		Outcome   struct {
			ExecutorID string   `json:"executor_id"`
			GasBurnt   int64    `json:"gas_burnt"`
			Logs       []string `json:"logs"`
			Metadata   struct {
				GasProfile []struct {
					Cost         string `json:"cost"`
					CostCategory string `json:"cost_category"`
					GasUsed      string `json:"gas_used"`
				} `json:"gas_profile"`
				Version int `json:"version"`
			} `json:"metadata"`
			ReceiptIds []string `json:"receipt_ids"`
			Status     struct {
				SuccessValue string `json:"SuccessValue"`
			} `json:"status"`
			TokensBurnt string `json:"tokens_burnt"`
		} `json:"outcome"`
		Proof []struct {
			Direction string `json:"direction"`
			Hash      string `json:"hash"`
		} `json:"proof"`
	} `json:"receipts_outcome"`
	Status struct {
		SuccessValue string `json:"SuccessValue"`
	} `json:"status"`
	Transaction struct {
		Actions []struct {
			FunctionCall struct {
				Args       string `json:"args"`
				Deposit    string `json:"deposit"`
				Gas        int64  `json:"gas"`
				MethodName string `json:"method_name"`
			} `json:"FunctionCall"`
		} `json:"actions"`
		Hash       string `json:"hash"`
		Nonce      int64  `json:"nonce"`
		PublicKey  string `json:"public_key"`
		ReceiverID string `json:"receiver_id"`
		Signature  string `json:"signature"`
		SignerID   string `json:"signer_id"`
	} `json:"transaction"`
	TransactionOutcome struct {
		BlockHash string `json:"block_hash"`
		ID        string `json:"id"`
		Outcome   struct {
			ExecutorID string        `json:"executor_id"`
			GasBurnt   int64         `json:"gas_burnt"`
			Logs       []interface{} `json:"logs"`
			Metadata   struct {
				GasProfile interface{} `json:"gas_profile"`
				Version    int         `json:"version"`
			} `json:"metadata"`
			ReceiptIds []string `json:"receipt_ids"`
			Status     struct {
				SuccessReceiptID string `json:"SuccessReceiptId"`
			} `json:"status"`
			TokensBurnt string `json:"tokens_burnt"`
		} `json:"outcome"`
		Proof []struct {
			Direction string `json:"direction"`
			Hash      string `json:"hash"`
		} `json:"proof"`
	} `json:"transaction_outcome"`
}

func (c *Client) Tx(ctx context.Context, params interface{}) (TxResponse, error) {
	var resp TxResponse
	err := c.call(ctx, "tx", params, &resp)
	return resp, err
}

'''
'''--- pkg/near/validators.go ---
package near

import (
	"context"

	"github.com/shopspring/decimal"
)

type ValidatorsResponse struct {
	CurrentValidators []struct {
		Validator
		IsSlashed         bool  `json:"is_slashed"`
		Shards            []int `json:"shards"`
		NumProducedBlocks int64 `json:"num_produced_blocks"`
		NumExpectedBlocks int64 `json:"num_expected_blocks"`
		NumProducedChunks int64 `json:"num_produced_chunks"`
		NumExpectedChunks int64 `json:"num_expected_chunks"`
	} `json:"current_validators"`
	NextValidators []struct {
		Validator
		Shards []int `json:"shards"`
	} `json:"next_validators"`
	CurrentProposals []struct {
		Validator
		StakeStructVersion string `json:"validator_stake_struct_version"`
	} `json:"current_proposals"`
	EpochStartHeight int64 `json:"epoch_start_height"`
	EpochHeight      int64 `json:"epoch_height"`
	PrevEpochKickOut []struct {
		AccountId string      `json:"account_id"`
		Reason    interface{} `json:"reason"`
	} `json:"prev_epoch_kickout"`
}

type Validator struct {
	AccountId string          `json:"account_id"`
	PublicKey string          `json:"public_key"`
	Stake     decimal.Decimal `json:"stake"`
}

func (c *Client) Validators(ctx context.Context, params interface{}) (ValidatorsResponse, error) {
	var resp ValidatorsResponse
	err := c.call(ctx, "validators", params, &resp)
	return resp, err
}

'''
'''--- pkg/watcher/config.go ---
package watcher

import (
	"io"
	"time"
)

type Config struct {
	TrackedAccounts []string
	RefreshRate     time.Duration
	Writer          io.Writer
}

'''
'''--- pkg/watcher/utils.go ---
package watcher

import (
	"fmt"
	"strings"
)

func prettyPrintFloat(f float64) string {
	if f == float64(int(f)) {
		return fmt.Sprintf("%.0f", f)
	}
	return fmt.Sprintf("%.2f", f)
}

func prettyPrintAccountID(accountID string) string {
	return trimPoolSuffix(
		accountID,
		".pool.f863973.m0",
		".poolv1.near",
		".pool.near",
	)
}

func trimPoolSuffix(accountID string, suffixes ...string) string {
	for _, suffix := range suffixes {
		if strings.HasSuffix(accountID, suffix) {
			return strings.TrimSuffix(accountID, suffix)
		}
	}
	return accountID
}

'''
'''--- pkg/watcher/utils_test.go ---
package watcher

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestPrettyPrintFloat(t *testing.T) {
	assert.Equal(t, "100", prettyPrintFloat(100))
	assert.Equal(t, "99.42", prettyPrintFloat(99.42098176))
}

func TestPrettyPrintAccountID(t *testing.T) {
	assert.Equal(t, "foo", prettyPrintAccountID("foo.poolv1.near"))
	assert.Equal(t, "foo", prettyPrintAccountID("foo.pool.near"))
	assert.Equal(t, "foo", prettyPrintAccountID("foo.pool.f863973.m0"))
}

'''
'''--- pkg/watcher/watcher.go ---
package watcher

import (
	"context"
	"encoding/json"
	"fmt"
	"sort"
	"strconv"
	"strings"
	"sync/atomic"
	"time"

	"github.com/avast/retry-go/v4"
	"github.com/fatih/color"
	"github.com/kilnfi/near-validator-watcher/pkg/metrics"
	"github.com/kilnfi/near-validator-watcher/pkg/near"
	"github.com/shopspring/decimal"
	"github.com/sirupsen/logrus"
)

var yoctoUnit = decimal.NewFromInt(10).Pow(decimal.NewFromInt(24))

type Watcher struct {
	config  *Config
	client  *near.Client
	metrics *metrics.Metrics

	isSynced atomic.Bool
}

func New(client *near.Client, metrics *metrics.Metrics, config *Config) *Watcher {
	return &Watcher{
		config:  config,
		client:  client,
		metrics: metrics,
	}
}

func (w *Watcher) IsSynced() bool {
	return w.isSynced.Load()
}

func (w *Watcher) Start(ctx context.Context) error {
	ticker := time.NewTicker(w.config.RefreshRate)

	for {
		retryOpts := []retry.Option{
			retry.Context(ctx),
			retry.Delay(1 * time.Second),
			retry.Attempts(3),
			retry.OnRetry(func(n uint, err error) {
				logrus.WithError(err).Error("failed to collect data, retrying...")
			}),
		}

		retry.Do(func() error {
			return w.collectData(ctx)
		}, retryOpts...)

		select {
		case <-ctx.Done():
			return nil
		case <-ticker.C:
			continue
		}
	}
}

func (w *Watcher) collectData(ctx context.Context) error {
	status, err := w.collectStatus(ctx)
	if err != nil {
		return err
	}
	validators, err := w.collectValidators(ctx)
	if err != nil {
		return err
	}
	_, err = w.collectProtocolConfig(ctx)
	if err != nil {
		return err
	}

	w.printStatusLine(status, validators)

	return nil
}

func (w *Watcher) collectProtocolConfig(ctx context.Context) (near.ProtocolConfigResponse, error) {
	logrus.Debug("collect protocol config")

	config, err := w.client.ProtocolConfig(ctx)
	if err != nil {
		return config, err
	}

	w.metrics.EpochLength.Set(float64(config.EpochLength))
	w.metrics.ProtocolVersion.Set(float64(config.ProtocolVersion))

	return config, nil
}

func (w *Watcher) collectStatus(ctx context.Context) (near.StatusResponse, error) {
	logrus.Debug("collect status")

	status, err := w.client.Status(ctx)
	if err != nil {
		return status, fmt.Errorf("failed to get status: %w", err)
	}

	w.isSynced.Store(!status.SyncInfo.Syncing)

	w.metrics.BlockNumber.Set(float64(status.SyncInfo.LatestBlockHeight))
	w.metrics.ChainID.WithLabelValues(status.ChainID).Set(metrics.StringToFloat64(status.ChainID))
	w.metrics.SyncingDesc.Set(metrics.BoolToFloat64(status.SyncInfo.Syncing))
	w.metrics.VersionBuild.WithLabelValues(status.Version.Version, status.Version.Build).Set(metrics.StringToFloat64(status.Version.Build))

	return status, nil
}

func (w *Watcher) collectValidators(ctx context.Context) (near.ValidatorsResponse, error) {
	logrus.Debug("collect validators")

	validators, err := w.client.Validators(ctx, "latest")
	if err != nil {
		return validators, err
	}

	// Reset labeled gauge vec
	w.metrics.ValidatorExpectedBlocks.Reset()
	w.metrics.ValidatorExpectedChunks.Reset()
	w.metrics.ValidatorProducedBlocks.Reset()
	w.metrics.ValidatorProducedChunks.Reset()
	w.metrics.ValidatorSlashed.Reset()
	w.metrics.ValidatorStake.Reset()
	w.metrics.ValidatorRank.Reset()
	w.metrics.NextValidatorStake.Reset()
	w.metrics.CurrentProposals.Reset()
	w.metrics.PrevEpochKickout.Reset()

	labelEpochStartHeight := strconv.FormatInt(validators.EpochStartHeight, 10)

	w.metrics.EpochStartHeight.Set(float64(validators.EpochStartHeight))

	var seatPrice float64

	// Sort validators by stake to be able to calculate their rank
	rankedValidator := validators.CurrentValidators
	sort.SliceStable(rankedValidator, func(i, j int) bool {
		return rankedValidator[i].Stake.GreaterThan(rankedValidator[j].Stake)
	})

	for i, v := range rankedValidator {
		labels := []string{v.AccountId, v.PublicKey, labelEpochStartHeight, w.isTracked(v.AccountId)}

		w.metrics.ValidatorRank.
			WithLabelValues(v.AccountId, v.PublicKey, labelEpochStartHeight, w.isTracked(v.AccountId)).
			Set(float64(i + 1))

		w.metrics.ValidatorExpectedBlocks.WithLabelValues(labels...).Set(float64(v.NumExpectedBlocks))
		w.metrics.ValidatorExpectedChunks.WithLabelValues(labels...).Set(float64(v.NumExpectedChunks))
		w.metrics.ValidatorProducedBlocks.WithLabelValues(labels...).Set(float64(v.NumProducedBlocks))
		w.metrics.ValidatorProducedChunks.WithLabelValues(labels...).Set(float64(v.NumProducedChunks))

		w.metrics.ValidatorSlashed.WithLabelValues(labels...).Set(metrics.BoolToFloat64(v.IsSlashed))
		w.metrics.ValidatorStake.WithLabelValues(labels...).Set(v.Stake.Div(yoctoUnit).InexactFloat64())

		t := v.Stake.Div(yoctoUnit).InexactFloat64()
		if seatPrice == 0 {
			seatPrice = t
		}
		if seatPrice > t {
			seatPrice = t
		}
	}

	w.metrics.SeatPrice.Set(seatPrice)

	for _, v := range validators.NextValidators {
		w.metrics.NextValidatorStake.
			WithLabelValues(v.AccountId, v.PublicKey, labelEpochStartHeight, w.isTracked(v.AccountId)).
			Set(v.Stake.Div(yoctoUnit).InexactFloat64())
	}

	for _, v := range validators.CurrentProposals {
		w.metrics.CurrentProposals.
			WithLabelValues(v.AccountId, v.PublicKey, labelEpochStartHeight, w.isTracked(v.AccountId)).
			Set(v.Stake.Div(yoctoUnit).InexactFloat64())
	}

	for _, v := range validators.PrevEpochKickOut {
		reason, _ := json.Marshal(v.Reason)

		w.metrics.PrevEpochKickout.
			WithLabelValues(v.AccountId, string(reason), labelEpochStartHeight, w.isTracked(v.AccountId)).
			Set(1)
	}

	return validators, nil
}

func (w *Watcher) isTracked(accountId string) string {
	for _, t := range w.config.TrackedAccounts {
		if accountId == t {
			return "1"
		}
	}
	return "0"
}

func (w *Watcher) printStatusLine(status near.StatusResponse, validators near.ValidatorsResponse) {
	validatorStatus := make([]string, 0)
	for _, account := range w.config.TrackedAccounts {
		for _, validator := range validators.CurrentValidators {
			if validator.AccountId != account {
				continue
			}

			var (
				status               = "‚úÖ"
				uptimeBlocks float64 = 100
				uptimeChunks float64 = 100
			)

			if validator.NumExpectedBlocks > 0 {
				uptimeBlocks = 100 * float64(validator.NumProducedBlocks) / float64(validator.NumExpectedBlocks)
			}
			if validator.NumExpectedChunks > 0 {
				uptimeChunks = 100 * float64(validator.NumProducedChunks) / float64(validator.NumExpectedChunks)
			}
			if uptimeBlocks < 90 || uptimeChunks < 90 {
				status = "‚ùå"
			}

			validatorStatus = append(validatorStatus,
				fmt.Sprintf("%s %s (%s%%, %s%%)",
					status,
					prettyPrintAccountID(validator.AccountId),
					prettyPrintFloat(uptimeBlocks),
					prettyPrintFloat(uptimeChunks),
				),
			)
		}
	}

	fmt.Fprintln(
		w.config.Writer,
		color.YellowString(fmt.Sprintf("#%d (%d)", status.SyncInfo.LatestBlockHeight, validators.EpochHeight)),
		color.CyanString(fmt.Sprintf("%d validators", len(validators.CurrentValidators))),
		strings.Join(validatorStatus, " "),
	)
}

'''
'''--- pkg/watcher/watcher_test.go ---
package watcher

import (
	"context"
	"testing"

	"github.com/kilnfi/near-validator-watcher/pkg/metrics"
	"github.com/kilnfi/near-validator-watcher/pkg/near"
	"github.com/kilnfi/near-validator-watcher/pkg/near/testutils"
	"github.com/prometheus/client_golang/prometheus/testutil"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestWatcher(t *testing.T) {
	var (
		ctx     = context.Background()
		resp    = testutils.ExpectedResponse{}
		server  = testutils.NewServer(&resp)
		client  = near.NewClient(server.URL)
		metrics = metrics.New("near_validator_watcher")
		watcher = New(client, metrics, &Config{
			TrackedAccounts: []string{"kiln.pool.f863973.m0"},
		})
	)

	defer server.Close()

	t.Run("Collect Protocol Config", func(t *testing.T) {
		resp.ExpectResponse(200, `
			{
				"id": "dontcare",
				"jsonrpc": "2.0",
				"result": {
					"epoch_length": 43200,
					"protocol_version": 63
				}
		}`)

		_, err := watcher.collectProtocolConfig(ctx)
		require.NoError(t, err)

		assert.Equal(t, float64(43200), testutil.ToFloat64(metrics.EpochLength))
		assert.Equal(t, float64(63), testutil.ToFloat64(metrics.ProtocolVersion))
	})

	t.Run("Collect Status", func(t *testing.T) {
		resp.ExpectResponse(200, `
			{
				"id": "dontcare",
				"jsonrpc": "2.0",
				"result": {
						"chain_id": "testnet",
						"latest_protocol_version": 63,
						"node_key": null,
						"node_public_key": "ed25519:38wj5FVhH5AEUgEPHzcTwc5X7UgwiVQVNqRrrdGu7Bg1",
						"protocol_version": 63,
						"rpc_addr": "127.0.0.1:4040",
						"sync_info": {
								"earliest_block_hash": "4GSGamHhRFXuZxruqUKMz87PxCuwMtN6Dbtmem6QsbJT",
								"earliest_block_height": 142045749,
								"earliest_block_time": "2023-10-17T00:36:29.465562502Z",
								"epoch_id": "CpAZXf3iXAVys8dgB49CWDsi3fzUNWny6w4J78VaADPc",
								"epoch_start_height": 142256359,
								"latest_block_hash": "4N5XL5zR9527vDnoCUEVcBEQMTqRepmfmgwQGrkyrjEM",
								"latest_block_height": 142259035,
								"latest_block_time": "2023-10-18T13:35:36.417320147Z",
								"latest_state_root": "B1do4VKdgL8CToXMd5E4fc56drSEaWqwXRyeSS9bUKY5",
								"syncing": false
						},
						"uptime_sec": 2236367,
						"validator_account_id": null,
						"validator_public_key": null,
						"validators": [
								{
										"account_id": "test1.poolv1.near",
										"is_slashed": false
								},
								{
										"account_id": "test2.poolv1.near",
										"is_slashed": false
								}
						],
						"version": {
								"build": "1.36.0-rc.1",
								"rustc_version": "1.71.0",
								"version": "1.36.0-rc.1"
						}
				}
		}`)

		_, err := watcher.collectStatus(ctx)
		require.NoError(t, err)

		assert.Equal(t, true, watcher.IsSynced())

		assert.Equal(t, float64(142259035), testutil.ToFloat64(metrics.BlockNumber))
		assert.NotEqual(t, float64(0), testutil.ToFloat64(metrics.ChainID.WithLabelValues("testnet")))
	})

	t.Run("Collect Validators", func(t *testing.T) {
		resp.ExpectResponse(200, `
			{
				"id": "dontcare",
				"jsonrpc": "2.0",
				"result": {
						"current_fishermen": [],
						"current_proposals": [
								{
										"account_id": "aurora.pool.f863973.m0",
										"public_key": "ed25519:9c7mczZpNzJz98V1sDeGybfD4gMybP4JKHotH8RrrHTm",
										"stake": "17289725999534933301348791102920",
										"validator_stake_struct_version": "V1"
								},
								{
										"account_id": "chorus-one.pool.f863973.m0",
										"public_key": "ed25519:6LFwyEEsqhuDxorWfsKcPPs324zLWTaoqk4o6RDXN7Qc",
										"stake": "2478635435253716013709224719804",
										"validator_stake_struct_version": "V1"
								},
								{
										"account_id": "kiln.pool.f863973.m0",
										"public_key": "ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W",
										"stake": "6739683523640860052948489127116",
										"validator_stake_struct_version": "V1"
								},
								{
										"account_id": "ni.pool.f863973.m0",
										"public_key": "ed25519:GfCfFkLk2twbAWdsS3tr7C2eaiHN3znSfbshS5e8NqBS",
										"stake": "2842038361242433260299812278899",
										"validator_stake_struct_version": "V1"
								},
								{
										"account_id": "stakely_v2.pool.f863973.m0",
										"public_key": "ed25519:7BanKZKGvFjK5Yy83gfJ71vPhqRwsDDyVHrV2FMJCUWr",
										"stake": "5050537292623241655006223011598",
										"validator_stake_struct_version": "V1"
								}
						],
						"current_validators": [
								{
										"account_id": "node1",
										"is_slashed": false,
										"num_expected_blocks": 640,
										"num_expected_chunks": 2527,
										"num_expected_chunks_per_shard": [
												2527
										],
										"num_produced_blocks": 640,
										"num_produced_chunks": 2527,
										"num_produced_chunks_per_shard": [
												2527
										],
										"public_key": "ed25519:6DSjZ8mvsRZDvFqFxo8tCKePG96omXW7eVYVSySmDk8e",
										"shards": [
												0
										],
										"stake": "47604850844179868792335153947376"
								},
								{
										"account_id": "node2",
										"is_slashed": false,
										"num_expected_blocks": 662,
										"num_expected_chunks": 2593,
										"num_expected_chunks_per_shard": [
												2593
										],
										"num_produced_blocks": 662,
										"num_produced_chunks": 2593,
										"num_produced_chunks_per_shard": [
												2593
										],
										"public_key": "ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5",
										"shards": [
												1
										],
										"stake": "47595986932991225292162473028453"
								},
								{
										"account_id": "node3",
										"is_slashed": false,
										"num_expected_blocks": 650,
										"num_expected_chunks": 2593,
										"num_expected_chunks_per_shard": [
												2593
										],
										"num_produced_blocks": 650,
										"num_produced_chunks": 2593,
										"num_produced_chunks_per_shard": [
												2593
										],
										"public_key": "ed25519:ydgzeXHJ5Xyt7M1gXLxqLBW1Ejx6scNV5Nx2pxFM8su",
										"shards": [
												2
										],
										"stake": "47558522874659976267803051885615"
								},
								{
										"account_id": "kiln.pool.f863973.m0",
										"is_slashed": false,
										"num_expected_blocks": 92,
										"num_expected_chunks": 392,
										"num_expected_chunks_per_shard": [
												392
										],
										"num_produced_blocks": 91,
										"num_produced_chunks": 391,
										"num_produced_chunks_per_shard": [
												391
										],
										"public_key": "ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W",
										"shards": [
												0
										],
										"stake": "6736422258840329637507414885764"
								},
								{
										"account_id": "stakely_v2.pool.f863973.m0",
										"is_slashed": false,
										"num_expected_blocks": 58,
										"num_expected_chunks": 294,
										"num_expected_chunks_per_shard": [
												294
										],
										"num_produced_blocks": 58,
										"num_produced_chunks": 294,
										"num_produced_chunks_per_shard": [
												294
										],
										"public_key": "ed25519:7BanKZKGvFjK5Yy83gfJ71vPhqRwsDDyVHrV2FMJCUWr",
										"shards": [
												0
										],
										"stake": "5048850744401447176504014136424"
								}
						],
						"epoch_height": 2312,
						"epoch_start_height": 142256359,
						"next_fishermen": [],
						"next_validators": [
								{
										"account_id": "node1",
										"public_key": "ed25519:6DSjZ8mvsRZDvFqFxo8tCKePG96omXW7eVYVSySmDk8e",
										"shards": [
												0
										],
										"stake": "47620752994974369049510359713578"
								},
								{
										"account_id": "node2",
										"public_key": "ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5",
										"shards": [
												1
										],
										"stake": "47611886122842673501102298433476"
								},
								{
										"account_id": "node3",
										"public_key": "ed25519:ydgzeXHJ5Xyt7M1gXLxqLBW1Ejx6scNV5Nx2pxFM8su",
										"shards": [
												2
										],
										"stake": "47574409549839192701171919246504"
								},
								{
										"account_id": "kiln.pool.f863973.m0",
										"public_key": "ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W",
										"shards": [
												0
										],
										"stake": "6739683523438532957632289127116"
								},
								{
										"account_id": "stakely_v2.pool.f863973.m0",
										"public_key": "ed25519:7BanKZKGvFjK5Yy83gfJ71vPhqRwsDDyVHrV2FMJCUWr",
										"shards": [
												0
										],
										"stake": "5050537292472590301154723011598"
								}
						],
						"prev_epoch_kickout": [
								{
										"account_id": "example1.pool.f863973.m0",
										"reason": {
												"NotEnoughBlocks": {
														"expected": 16,
														"produced": 0
												}
										}
								},
								{
										"account_id": "example2.pool.f863973.m0",
										"reason": {
												"NotEnoughBlocks": {
														"expected": 63,
														"produced": 0
												}
										}
								}
						]
				}
		}`)

		_, err := watcher.collectValidators(ctx)
		require.NoError(t, err)

		assert.Equal(t, float64(142256359), testutil.ToFloat64(metrics.EpochStartHeight))
		assert.Equal(t, float64(5048850.744401447176504014136424), testutil.ToFloat64(metrics.SeatPrice))

		// ValidatorRank
		assert.Equal(t, 5, testutil.CollectAndCount(metrics.ValidatorRank))
		assert.Equal(t, float64(2), testutil.ToFloat64(metrics.ValidatorRank.WithLabelValues(
			"node2",
			`ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5`,
			"142256359",
			"0",
		)))
		assert.Equal(t, float64(4), testutil.ToFloat64(metrics.ValidatorRank.WithLabelValues(
			"kiln.pool.f863973.m0",
			`ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W`,
			"142256359",
			"1",
		)))

		// ExpectedBlocks
		assert.Equal(t, 5, testutil.CollectAndCount(metrics.ValidatorExpectedBlocks))
		assert.Equal(t, float64(662), testutil.ToFloat64(metrics.ValidatorExpectedBlocks.WithLabelValues(
			"node2",
			`ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5`,
			"142256359",
			"0",
		)))
		assert.Equal(t, float64(92), testutil.ToFloat64(metrics.ValidatorExpectedBlocks.WithLabelValues(
			"kiln.pool.f863973.m0",
			`ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W`,
			"142256359",
			"1",
		)))

		// ProducedBlocks
		assert.Equal(t, 5, testutil.CollectAndCount(metrics.ValidatorProducedBlocks))
		assert.Equal(t, float64(662), testutil.ToFloat64(metrics.ValidatorProducedBlocks.WithLabelValues(
			"node2",
			`ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5`,
			"142256359",
			"0",
		)))
		assert.Equal(t, float64(91), testutil.ToFloat64(metrics.ValidatorProducedBlocks.WithLabelValues(
			"kiln.pool.f863973.m0",
			`ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W`,
			"142256359",
			"1",
		)))

		// ExpectedChunks
		assert.Equal(t, 5, testutil.CollectAndCount(metrics.ValidatorExpectedChunks))
		assert.Equal(t, float64(2593), testutil.ToFloat64(metrics.ValidatorExpectedChunks.WithLabelValues(
			"node2",
			`ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5`,
			"142256359",
			"0",
		)))
		assert.Equal(t, float64(392), testutil.ToFloat64(metrics.ValidatorExpectedChunks.WithLabelValues(
			"kiln.pool.f863973.m0",
			`ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W`,
			"142256359",
			"1",
		)))

		// ProducedChunks
		assert.Equal(t, 5, testutil.CollectAndCount(metrics.ValidatorProducedChunks))
		assert.Equal(t, float64(2593), testutil.ToFloat64(metrics.ValidatorProducedChunks.WithLabelValues(
			"node2",
			`ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5`,
			"142256359",
			"0",
		)))
		assert.Equal(t, float64(391), testutil.ToFloat64(metrics.ValidatorProducedChunks.WithLabelValues(
			"kiln.pool.f863973.m0",
			`ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W`,
			"142256359",
			"1",
		)))

		// Slashed
		assert.Equal(t, 5, testutil.CollectAndCount(metrics.ValidatorSlashed))
		assert.Equal(t, float64(0), testutil.ToFloat64(metrics.ValidatorSlashed.WithLabelValues(
			"node2",
			`ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5`,
			"142256359",
			"0",
		)))
		assert.Equal(t, float64(0), testutil.ToFloat64(metrics.ValidatorSlashed.WithLabelValues(
			"kiln.pool.f863973.m0",
			`ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W`,
			"142256359",
			"1",
		)))

		// Stake
		assert.Equal(t, 5, testutil.CollectAndCount(metrics.ValidatorStake))
		assert.Equal(t, float64(47595986.932991225292162473028453), testutil.ToFloat64(metrics.ValidatorStake.WithLabelValues(
			"node2",
			`ed25519:GkDv7nSMS3xcqA45cpMvFmfV1o4fRF6zYo1JRR6mNqg5`,
			"142256359",
			"0",
		)))
		assert.Equal(t, float64(6736422.258840329637507414885764), testutil.ToFloat64(metrics.ValidatorStake.WithLabelValues(
			"kiln.pool.f863973.m0",
			`ed25519:Bq8fe1eUgDRexX2CYDMhMMQBiN13j8vTAVFyTNhEfh1W`,
			"142256359",
			"1",
		)))

		// assert.Equal(t, float64(43200), testutil.ToFloat64(metrics.NextValidatorStake))
		// assert.Equal(t, float64(43200), testutil.ToFloat64(metrics.CurrentProposals))

		assert.Equal(t, 2, testutil.CollectAndCount(metrics.PrevEpochKickout))
		assert.Equal(t, float64(1), testutil.ToFloat64(metrics.PrevEpochKickout.WithLabelValues(
			"example1.pool.f863973.m0",
			`{"NotEnoughBlocks":{"expected":16,"produced":0}}`,
			"142256359",
			"0",
		)))
		assert.Equal(t, float64(1), testutil.ToFloat64(metrics.PrevEpochKickout.WithLabelValues(
			"example2.pool.f863973.m0",
			`{"NotEnoughBlocks":{"expected":63,"produced":0}}`,
			"142256359",
			"0",
		)))
	})
}

'''