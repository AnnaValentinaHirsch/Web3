*GitHub Repository "lawcia/near-code-mentor"*

'''--- README.md ---
# NEAR Smart Contract - Code Mentor
Website allows women to create amd receive code reviews. Get rewarded in NEAR.

Backend is hosted on the NEAR testnet 

Frontend is hosted on Netlify https://near-code-mentor.netlify.app/

## Tech
- rust
- react
- near js api

## Smart Contract

change to contract directory

```cd contract```

Login to near

```near login```

**Replace YOUR_ACCOUNT with your real account**

Create a sub account

```
near create-account code_mentor.YOUR_ACCOUNT.testnet --masterAccount YOUR_ACCOUNT.testnet
```

Deploy the contract

```
near deploy code_mentor.YOUR_ACCOUNT.testnet --wasmFile target/wasm32-unknown-unknown/release/code_mentor.wasm
```

Make a submission

params:

question - explain the problem you are trying to solve and what you need help with

language - this the coding language pick either (javascript, python, rust, or java)

code - this is the code snippet

```
near call code_mentor.code_mentor.testnet submit_code '{"submission_id": "1",
"submission_meta": {
    "language": "python",
    "code": "def hello():",
    "question": "help",
    "updated": "2022-07-17T08:31:58.933Z"
},
"account_id": "YOUR_ACCOUNT.testnet"
}' --accountId YOUR_ACCOUNT.testnet --amount 0.1
```

Get submissions for account

```
near call code_mentor.code_mentor.testnet submissions_for_account '"account_id": "YOUR_ACCOUNT.testnet"' --accountId code_mentor.testnet 
```

Get submissions to review

```
near call code_mentor.YOUR_ACCOUNT.testnet get_submissions_to_review '"account_id": "YOUR_ACCOUNT.testnet"' --accountId YOUR_ACCOUNT.testnet 
```

Submit a comment

```
near call code_mentor.YOUR_ACCOUNT.testnet submit_comment '{
    "comment_id": "1",
    "submission_id": "1",
"comment_meta": {
    "text": "OK",
    "updated": "2022-07-17T08:31:58.933Z"
},
"account_id": "YOUR_ACCOUNT.testnet"
}' --accountId YOUR_ACCOUNT.testnet
```

Delete sub account

```
near delete code_mentor.YOUR_ACCOUNT.testnet YOUR_ACCOUNT.testnet
```

## Frontend

Scripts

```yarn install```

```yarn start```

```yarn build```

'''
'''--- contract/Cargo.toml ---
[package]
name = "code_mentor"
version = "0.1.0"
authors = ["CodeMentor"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "=4.0.0-pre.4"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contract/build.sh ---
#!/bin/bash
set -e && RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release && mkdir -p ../out && cp target/wasm32-unknown-unknown/release/*.wasm ../out/main.wasm
'''
'''--- contract/src/internal.rs ---
use crate::*;

//refund the initial deposit based on the amount of storage that was used up
pub(crate) fn refund_deposit(storage_used: u64) {
    //get how much it would cost to store the information
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    //get the attached deposit
    let attached_deposit = env::attached_deposit();

    //make sure that the attached deposit is greater than or equal to the required cost
    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );

    //get the refund amount from the attached deposit - required cost
    let refund = attached_deposit - required_cost;

    //if the refund is greater than 1 yocto NEAR, we refund the predecessor that amount
    if refund > 1 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

pub(crate) fn reward_user(storage_used: u64, account_id: AccountId) {
    let required_cost = env::storage_byte_cost() * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();
    assert!(
        required_cost <= attached_deposit,
        "Must attach {} yoctoNEAR to cover storage",
        required_cost,
    );
    let reward = attached_deposit - required_cost + 5;
    Promise::new(account_id).transfer(reward);
}
'''
'''--- contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::{
    env, near_bindgen, AccountId, Balance, Promise,
};
use near_sdk::serde::{Deserialize, Serialize};

use crate::internal::*;

mod internal;

pub type SubmissionId = String;
pub type CommentId = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Submission {
    pub language: String,         
    pub code: String,           
    pub question: String,
    pub account: AccountId,
    pub updated: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct SubmissionMeta {
    pub language: String,         
    pub code: String,           
    pub question: String,
    pub updated: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Comment {
    pub text: String,
    pub account: AccountId,
    pub updated: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct CommentMeta {
    pub text: String,
    pub updated: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken{
    pub id: SubmissionId,
    pub submission: Submission,
    pub comments: Vec<Comment>,
}

// add the following attributes to prepare your code for serialization and invocation on the blockchain
// More built-in Rust attributes here: https://doc.rust-lang.org/reference/attributes.html#built-in-attributes-index
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    // See more data types at https://doc.rust-lang.org/book/ch03-02-data-types.html
    pub submissions_per_account: UnorderedMap<AccountId, UnorderedSet<SubmissionId>>,

    pub submissions_by_id: LookupMap<SubmissionId, Submission>,

    pub comments_per_submission: LookupMap<SubmissionId, UnorderedSet<CommentId>>,

    pub comments_by_id: LookupMap<CommentId, Comment>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    SubmissionsPerAccount,
    SubmissionsById,
    CommentsPerSubmission,
    CommentsById,
}

impl Default for Contract {
    fn default() -> Self{
        Self {
            submissions_per_account: UnorderedMap::new(StorageKey::SubmissionsPerAccount.try_to_vec().unwrap()),

            submissions_by_id: LookupMap::new(StorageKey::SubmissionsById.try_to_vec().unwrap()),

            comments_per_submission: LookupMap::new(StorageKey::CommentsPerSubmission.try_to_vec().unwrap()),

            comments_by_id: LookupMap::new(StorageKey::CommentsById.try_to_vec().unwrap()),
        }
    }
}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn submit_code(
        &mut self,
        submission_id: SubmissionId,
        submission_meta: SubmissionMeta,
        account_id: AccountId,
    ) {
        let initial_storage_usage = env::storage_usage();

        let signer_account_id = env::signer_account_id();

        assert!(account_id == signer_account_id, 
        "Signer account ID should match account_id in payload");

        let submission = Submission {
            language: submission_meta.language,         
            code: submission_meta.code,           
            question: submission_meta.question,
            updated: submission_meta.updated,
            account: account_id.clone(),
        };

        assert!(
            self.submissions_by_id.insert(&submission_id, &submission).is_none(),
            "Submission already exists"
        );

        // get the set of submissions for the given account
        let mut submissions_set = self.submissions_per_account.get(&account_id).unwrap_or_else(|| {
            // if the account doesn't have any submissions, we create a new unordered set
            UnorderedSet::new(
                StorageKey::SubmissionsPerAccount.try_to_vec()
                .unwrap(),
            )
        });

        // we insert the submission ID into the set
        submissions_set.insert(&submission_id);

        // we insert that set for the given account ID. 
        self.submissions_per_account.insert(&account_id, &submissions_set);

        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        // refund any excess storage if the user attached too much. Panic if they didn't attach enough to cover the required.
        refund_deposit(required_storage_in_bytes);
    }
    
    #[payable]
    pub fn submit_comment(
        &mut self,
        comment_id: CommentId,
        comment_meta: CommentMeta,
        submission_id: SubmissionId,
        account_id: AccountId,
    ) {
        let signer_account_id = env::signer_account_id();

        let initial_storage_usage = env::storage_usage();

        assert!(account_id == signer_account_id, 
            "Signer account ID should match account_id in payload");    

        let comment = Comment {
            text: comment_meta.text,
            account: account_id.clone(),
            updated: comment_meta.updated,
        };

        assert!(
            self.comments_by_id.insert(&comment_id, &comment).is_none(),
            "Comment already exists"
        );

        // get the set of comments for the given account
        let mut comments_set = self.comments_per_submission.get(&submission_id).unwrap_or_else(|| {
            // if the submission doesn't have any comments, we create a new unordered set
            UnorderedSet::new(
                StorageKey::CommentsPerSubmission.try_to_vec()
                .unwrap(),
            )
        });

        comments_set.insert(&comment_id);

        self.comments_per_submission.insert(&submission_id, &comments_set);

        let required_storage_in_bytes = env::storage_usage() - initial_storage_usage;

        reward_user(required_storage_in_bytes, account_id);
    }

    pub fn submissions_for_account(
        &self,
        account_id: AccountId,
    ) -> Vec<JsonToken> {
        let submissions = self.get_submission_by_account_id(account_id);

        return submissions
    }

    fn get_submission_by_account_id(
        &self,
        account_id: AccountId,
    ) -> Vec<JsonToken> {
        let submissions_for_owner_set = self.submissions_per_account.get(&account_id);

        let submissions = if let Some(submissions_for_owner_set) = submissions_for_owner_set {
            submissions_for_owner_set
        } else {
            return vec![];
        };

        // iterate through the keys vector
        return submissions.iter()
            .map(|submission_id| self.get_submission_by_id(submission_id.clone()).unwrap())
            .collect()
    }

    fn get_submission_by_id(&self, submission_id: SubmissionId) -> Option<JsonToken> {
 
        if let Some(submission) = self.submissions_by_id.get(&submission_id) {

            let comments_for_submission_set = self.comments_per_submission.get(&submission_id);

            let comments = if let Some(comments_for_submission_set) = comments_for_submission_set {
                comments_for_submission_set
            } else {
                UnorderedSet::new(
                    StorageKey::CommentsPerSubmission.try_to_vec()
                    .unwrap(),
                )
            };

            let comments_json = comments.iter()
            .map(|comment_id| self.get_comment_by_id(comment_id.clone()).unwrap())
            .collect();

            Some(JsonToken {
                id: submission_id,
                submission,
                comments: comments_json
            })
        } else { 
            None
        }
    }

    fn get_comment_by_id(&self, comment_id: CommentId) -> Option<Comment> {
         if let Some(comment) = self.comments_by_id.get(&comment_id) {
            Some(comment)
        } else {
            None
        }
    }

    pub fn get_submissions_to_review(
        &self,
        account_id: AccountId,
    ) -> Vec<JsonToken> {
        let keys = self.submissions_per_account.keys_as_vector();

        let mut submissions = Vec::new();

        let account_ids: Vec<AccountId> = keys.iter()
        .filter(|acc| acc != &account_id).collect();
        
        for acc_id in &account_ids {
            let mut submission = self.get_submission_by_account_id(acc_id.clone());
            submissions.append(&mut submission);
        }

        submissions
    }
}
'''
'''--- package.json ---
{
  "name": "near-match-me",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "bn.js": "^5.2.1",
    "buffer": "^6.0.3",
    "file-loader": "^6.2.0",
    "html-webpack-plugin": "^5.5.0",
    "near-api-js": "^0.45.1",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "react-scripts": "^5.0.1",
    "react-toastify": "^9.0.5",
    "uuid": "^8.3.2",
    "webpack": "^5.73.0"
  },
  "devDependencies": {
    "@babel/core": "^7.18.6",
    "@babel/plugin-proposal-class-properties": "^7.18.6",
    "@babel/preset-env": "^7.18.6",
    "@babel/preset-react": "^7.18.6",
    "babel-loader": "^8.2.5",
    "css-loader": "^6.7.1",
    "style-loader": "^3.3.1",
    "webpack-cli": "^4.10.0",
    "webpack-dev-server": "^4.9.3"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- public/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png" />
    <link rel="manifest" href="/site.webmanifest" />
    <title>Code Mentor</title>
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-0evHe/X+R7YkIZDRvuzKMRqM+OrBnVFBL6DOitfPri4tjfHxaWutUpFmBp4vmVor"
      crossorigin="anonymous"
    />
  </head>
  <body>
    <div id="root">
      <div id="content">
        <div id="app"></div>
      </div>
      <footer>
        <a href="https://www.freepik.com/vectors/character-presentation"
          >Character presentation vector created by katemangostar -
          www.freepik.com</a
        >
      </footer>
    </div>
    <script
      src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0-beta1/dist/js/bootstrap.bundle.min.js"
      integrity="sha384-pprn3073KE6tl6bjs2QrFaJGz5/SUsLqktiwsUTF55Jfv3qYSDhgCecCxMW52nD2"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/ace.js"
      type="text/javascript"
      charset="utf-8"
    ></script>
  </body>
</html>

'''
'''--- src/App.js ---
import React from "react"

import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

import "./app.css";
import femaleOfficeWorkers from "./1.jpg";
import Login from "./Login";
import Feeds from "./Feeds";

const App = () => {

  return (
    <>
      <div className="app">
        <h1 className="title">Code Mentor</h1>
        {window?.walletConnection?.isSignedIn() ? (
          <Feeds />
        ) : (
          <>
            <h2>
              This is a platform for women to get code reviews from mentors in Tech.
            </h2>
            <Login />
          </>
        )}
      </div>
      <div>
        <img
          className="title-image"
          src={femaleOfficeWorkers}
          alt="female office workers"
        />
      </div>
      <ToastContainer />
    </>
  );
};
export default App;

'''
'''--- src/AskQuestion.js ---
import React, { useState, useEffect } from "react";
import { toast } from "react-toastify";

import { FormField, VIEWS } from "./helpers";
import { submitCode } from "./near/helpers";

const AskQuestion = ({ view, setView }) => {
    const [ language, setLanguage ] = useState("javascript");
    const [ question, setQuestion ] = useState("");
    const [ editor, setEditor] = useState(null);
    const editorId = "editor"

    useEffect(() => {
        if (view === VIEWS.ASK_QUESTION) {
            const initEditor = ace.edit("editor");
            initEditor.setTheme("ace/theme/monokai");
            initEditor.session.setMode(`ace/mode/${language}`);
            setEditor(initEditor);
        }
    }, [view])

    if (view !== VIEWS.ASK_QUESTION) {
        return null
    }

    const options = [{
        value: "javascript",
        textContent: "JavaScript"
    },
    {
        value: "rust",
        textContent: "Rust"
    },
    {
        value: "python",
        textContent: "Python"
    },
    {
        value: "java",
        textContent: "Java"
    }
    ]

    const handleSelect = (e) => {
        const value = e.target.value;
        setLanguage(value);
        editor.session.setMode(`ace/mode/${value}`);

    }

    const handleTextChange = (e) => {
        setQuestion(e.target.value);
    }

    const handleSubmit = (e) => {
        e.preventDefault();
        const code = editor.getValue();
        if (!language || !code || !question) {
            toast.info("Please enter your code")
            return
        }
        submitCode({
            language,
            code,
            question
        }).then(() => {
            toast.success("Wow so easy!");
            setView(VIEWS.DEFAULT);
        }).catch((e) => {
            console.error(e)
            toast.error("Something went wrong! Please try again later")

        })
    }

    return <div>
        <form onSubmit={handleSubmit}>
            <FormField id="language" type="select" labelText="Enter the programming language" extra={{
                options,
                onChange: handleSelect
            }} />
            <FormField id="question" type="textarea" labelText="Please explain the problem, and what you'd like help with" extra={{
                onChange: handleTextChange
            }}/>
            <FormField id={editorId} type="editor" labelText="Enter your code" />
            <button className="btn btn-success" type="submit">Submit</button>
            <hr />
            <small>Each submission costs 1 NEAR</small>
        </form>
    </div>
};

export default AskQuestion;
'''
'''--- src/Feeds.js ---
import React, { useState } from "react"
import AskQuestion from "./AskQuestion"
import "./feeds.css"
import { VIEWS } from "./helpers"
import ReviewQuestion from "./ReviewQuestion"
import ViewMySubmissions from "./ViewMySubmissions"

const Feeds = () => {
    const [view, setView] = useState(VIEWS.DEFAULT)

    const account = window.walletConnection.getAccountId()

    const logout = () => {
        window?.walletConnection?.signOut();
        window.location.replace(window.location.origin + window.location.pathname);
    }

    return <div>
        <div className="prompt-div">
            <p className="welcome-message">Welcome <span>{account}</span>!</p>
            <p>What would you like to do?</p>
            <button className="btn btn-primary" onClick={() => setView(VIEWS.ASK_QUESTION)}>Get Coding Help</button>
            <button className="btn btn-secondary" onClick={() => setView(VIEWS.REVIEW_QUESTION)}>Review Code</button>
            <button className="btn btn-info" onClick={() => setView(VIEWS.VIEW_MY_SUBMISSIONS)}>See Your Submissions</button>
            <button className="btn btn-warning" onClick={logout}>Logout</button>
        </div>
        <AskQuestion view={view} setView={setView} />
        <ReviewQuestion view={view} setView={setView} />
        <ViewMySubmissions view={view} setView={setView} />
    </div>
}

export default Feeds
'''
'''--- src/Loading.js ---
import React from "react"

const Loading = () => {
    return <div className="d-flex justify-content-center">
            <div className="spinner-border" role="status" />
        </div>
}

export default Loading;
'''
'''--- src/Login.js ---
import React from "react"

import { SMART_CONTRACT } from "./near/config";

const Login = () => {
  return (
    <>
      <h3>Please login to your NEAR account to continue.</h3>
      <button
        className="btn btn-success"
        onClick={() => window.walletConnection.requestSignIn(SMART_CONTRACT)}
      >
        Login
      </button>
    </>
  );
};

export default Login;

'''
'''--- src/ReviewQuestion.js ---
import React from "react";

import { VIEWS } from "./helpers";
import { getSubmissionsToReview } from "./near/helpers";
import Submissions from "./Submissions";

const ReviewQuestion = ({ view }) => {
  return (
    <Submissions
      view={view}
      correctView={VIEWS.REVIEW_QUESTION}
      title="Review Code"
      fetchFunction={getSubmissionsToReview}
      enableReviews={true}
    />
  );
};

export default ReviewQuestion;

'''
'''--- src/Submission.js ---
import React, { useState } from "react";
import { toast } from "react-toastify";
import { Button, FormField } from "./helpers";
import { submitComment } from "./near/helpers";

const Submission = ({
  item: {
    comments,
    id,
    submission: { account, language, question, updated },
  },
  enableReviews,
}) => {
  const [review, setReview] = useState("");

  const getDate = (date) => {
    try {
      return new Date(date).toLocaleString();
    } catch (_e) {
      return "Unknown";
    }
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    submitComment({
      text: review,
      submissionId: id,
    })
      .then(() => {
        toast.success("Comment submitted");
      })
      .catch((err) => {
        console.error(err);
        toast.error("Something went wrong. Pleas try again later");
      });
  };

  const handleChange = (e) => {
    setReview(e.target.value);
  };

  return (
    <div className="card">
      <div className="card-body">
        <h5 className="card-title">{language}</h5>
        <h6 className="card-subtitle mb-2 text-muted">By {account}</h6>
        <h6 className="card-subtitle mb-2 text-muted">
          Submitted at {getDate(updated)}
        </h6>
        <p className="card-text">{question}</p>
        <div className="editor-wrapper">
          <div id={id} className="editor"></div>
        </div>
      </div>
      {enableReviews && (
        <>
          <div className="card-header">Add Your Comment</div>
          <div className="card-body">
            <form onSubmit={handleSubmit}>
              <FormField
                type="textarea"
                labelText="Enter text"
                extra={{ onChange: handleChange }}
              />
              <button type="submit" className="btn btn-primary">
                Submit Comment
              </button>
              <hr />
              <small>Get rewarded in NEAR</small>
            </form>
          </div>
        </>
      )}
      <div className="card-header">Comments</div>
      <ul className="list-group list-group-flush">
        {comments?.length ? (
          <>
            {comments.map((comment, index) => (
              <li key={index} className="list-group-item">
                <p className="help">
                  From <span>{comment.account}</span> at{" "}
                  {getDate(comment.updated)}
                </p>
                <p>{comment.text}</p>
              </li>
            ))}
          </>
        ) : (
          <li className="list-group-item">Nobody has commented</li>
        )}
      </ul>
    </div>
  );
};

export default Submission;

'''
'''--- src/Submissions.js ---
import React, { useState, useEffect } from "react";

import { toast } from "react-toastify";

import { gatherEditorSettings, setEditorSettings } from "./helpers";
import Loading from "./Loading";

import Submission from "./Submission";

const Submissions = ({ view, correctView, title, enableReviews, fetchFunction }) => {
    const [isLoading, setIsLoading] = useState(false);
    const [submissions, setSubmissions] = useState([])

    useEffect(() => {
        if (view === correctView) {
            setIsLoading(true)
            fetchFunction()
                .then((res) => {
                    const subs = [...res].sort((a, b) => b.submission.updated.localeCompare(a.submission.updated))
                    setIsLoading(false)
                    setSubmissions(subs)
                })
                .catch((e) => {
                    setIsLoading(false)
                    toast.error("Could not get submissions. Please try again later.")
                })
        }

    }, [view])

    useEffect(() => {
        if (view === correctView) {
            const settings = gatherEditorSettings(submissions)
            setEditorSettings(settings)
        }

    }, [view, submissions])

    if (view !== correctView) {
        return null
    }

    return <div>
        <h2 className="h2">{title}</h2>
        {isLoading && <Loading />}
        {submissions?.length ? submissions.map((submission) => (
            <Submission key={submission.id} item={submission} enableReviews={enableReviews} />
        )) : <div className="card">
            <div className="card-body">
                No Results Found
            </div>
        </div>}
    </div>
};

export default Submissions;
'''
'''--- src/ViewMySubmissions.js ---
import React from "react";

import { VIEWS } from "./helpers";

import { getMySubmissions } from "./near/helpers";
import Submissions from "./Submissions";

const ViewMySubmissions = ({ view }) => {
  return (
    <Submissions
      view={view}
      correctView={VIEWS.VIEW_MY_SUBMISSIONS}
      title="My Submissions"
      fetchFunction={getMySubmissions}
      enableReviews={false}
    />
  );
};

export default ViewMySubmissions;
'''
'''--- src/app.css ---
#content {
    margin: 20px 30px;
    padding-bottom: 2.5rem;
}

.title-image {
    width: 100%;
    aspect-ratio: auto;
    margin: 20px 0px;
}

.title, small {
    color: #198754;
}
'''
'''--- src/feeds.css ---
.welcome-message {
    font-size: 1.7rem;
    margin: 20px 0px 8px;
}

.welcome-message span {
    font-weight: bold;
}

section {
    height: 100vh;
}

.prompt-div button:not(:last-of-type) {
    margin-right: 20px;
}

.prompt-div {
    margin-bottom: 50px;
}

.hide {
    display: none;
}

.show {
    display: block;
}

#editor { 
    width: 100%;
    height: 500px;
}

.editor-wrapper {
    position: relative;
    height: 300px;
}

.editor {
    width: 100%;
    height: 300px;
    display: flex;
    position: absolute;
    z-index: 100;
}

.review-item {
    border: 2px solid #cccccc;
    border-radius: 8px;
    padding: 20px;
}

.help {
    margin: 0px;
    font-size: 0.9rem;
}

.help span {
    font-weight: bold;
}

.card {
    margin: 20px 0px;
}
'''
'''--- src/helpers.js ---
import React from "react";

export const FormField = ({ id, labelText, type = "text", extra = {} }) => {
    return <div className="mb-3">
        <Label htmlFor={id} textContent={labelText} />
        {type === "editor" ? <Editor id={id} /> : <Input id={id} type={type} extra={extra} />}
    </div>
}

export const Label = ({ htmlFor, textContent }) => {
    return <label htmlFor={htmlFor} className="form-label">{textContent}</label>
}

export const Input = ({id, type, extra: { options, onChange }}) => {
    const className = "form-control"
    if (type === "select") {
        return <select id={id} className={className} onChange={onChange}>
            {options?.map((item) => {
                return <option key={item.value} value={item.value}>{item.textContent}</option>
            })}
        </select>
    }

    if (type === "textarea") {
        return <textarea className={className} id={id} rows="4" maxLength="2000" onChange={onChange} required/>
    }

    return <input type={type} className={className} id={id} onChange={onChange} required/>
}

export const Editor = ({ id }) => {
    return <div id={id}></div>
}

export const setEditorSettings = (settings) => {
    settings?.forEach(({ id, language, code }) => {
        const editor = ace.edit(id);
        editor.setTheme("ace/theme/monokai");
        editor.session.setMode(`ace/mode/${language}`);
        editor.setReadOnly(true);
        editor.setValue(code)
    })
}

export const gatherEditorSettings = (submissions) => {
    return submissions.map(({ id, submission: { code, language }}) => ({
        id,
        language: language || "text",
        code
    }))
}

export const VIEWS = {
    ASK_QUESTION: "ASK_QUESTION",
    REVIEW_QUESTION: "REVIEW_QUESTION",
    VIEW_MY_SUBMISSIONS: "VIEW_MY_SUBMISSIONS",
    DEFAULT: ""
}
'''
'''--- src/index.css ---
#root {
    position: relative;
    min-height: 100vh;
}
  
footer {
    position: absolute;
    bottom: 0;
    width: 100%;
    height: 2.5rem;
}

footer a {
    color: gainsboro;
}

'''
'''--- src/index.js ---
import React from "react"
import ReactDOM from "react-dom/client"
import App from "./App"
import { Buffer } from "buffer"
import * as near from "./near/config"

import "./index.css"

window.Buffer = Buffer;

const root = ReactDOM.createRoot(
    document.getElementById("app")
);
root.render(
    <React.StrictMode>
        <App />
    </React.StrictMode>
);

'''
'''--- src/near/config.js ---
import * as nearApi from "near-api-js";

export const config = {
    networkId: "default",
    nodeUrl: "https://rpc.testnet.near.org",
    walletUrl: "https://wallet.testnet.near.org",
    helperUrl: "https://helper.testnet.near.org",
    headers: {

    },
    deps: {
        keyStore: new nearApi.keyStores.BrowserLocalStorageKeyStore(),
    },
};

(async function () {
    window.near = await nearApi.connect(config);
    window.walletConnection = new nearApi.WalletConnection(window.near, APP_KEY_PREFIX);
})(window);

export const SMART_CONTRACT = process.env.REACT_APP_SMART_CONTRACT || "code_mentor.code_mentor.testnet";
export const APP_KEY_PREFIX = "code_mentor";

'''
'''--- src/near/helpers.js ---
import { v4 as uuidv4 } from 'uuid';
import { Contract } from "near-api-js";
import { BN } from "bn.js";

import { SMART_CONTRACT } from './config';

export const initContract = () => {
    const account = window.walletConnection.getAccountId();

    let contract;

    if (!window.contractSettings?.[account]) {
        contract = new Contract(
            window.walletConnection.account(),
            SMART_CONTRACT,
            {
                viewMethods: ["submissions_for_account", "get_submissions_to_review"],
                changeMethods: ["submit_code", "submit_comment"],
            }
        );
        window.contractSettings = { account: contract };
    } else {
        contract = window.contractSettings[account];
    }

    return contract;
};

export const submitCode = async ({ language, code, question }) => {
    const account = window.walletConnection.getAccountId();
    const contract = initContract();
    return contract.submit_code({
        submission_id: uuidv4(),
        submission_meta: {
            language,
            code,
            question,
            updated: new Date().toISOString()
        },
        account_id: account
    },
        300000000000000,
        new BN("1000000000000000000000000")
    )
}

export const getMySubmissions = async () => {
    const account = window.walletConnection.getAccountId();
    const contract = initContract();
    return contract.submissions_for_account({
        account_id: account
    });
}

export const getSubmissionsToReview = async () => {
    const account = window.walletConnection.getAccountId();
    const contract = initContract();
    return contract.get_submissions_to_review({
        account_id: account
    });
}

export const submitComment = async ({ text, submissionId }) => {
    const account = window.walletConnection.getAccountId();
    const contract = initContract();
    return contract.submit_comment({
        submission_id: submissionId,
        comment_id: uuidv4(),
        comment_meta: {
            text,
            updated: new Date().toISOString()
        },
        account_id: account
    },
        300000000000000,
        new BN("1000000000000000000000000")
    )
}

'''