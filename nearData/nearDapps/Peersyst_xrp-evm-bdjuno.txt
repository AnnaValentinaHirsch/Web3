*GitHub Repository "Peersyst/xrp-evm-bdjuno"*

'''--- .docs/messages/README.md ---
# Messages JSON formats
This folder contains the example of all messages JSON contents that can be found inside a transaction's `msgs` field.

**Note**. The contained messages are only related to the Cosmos SDK. Each custom chain, however, can define its own messages types containing arbitrary data.

### Index
- [x/bank](bank.md)
- [x/crisis](crisis.md)
- [x/distribution](distribution.md)
- [x/gov](gov.md)
- [x/slashing](slashing.md)
- [x/staking](staking.md)
'''
'''--- .docs/messages/bank.md ---
# x/bank

## MsgSend

```json
{
  "@type": "/cosmos.bank.v1beta1.MsgSend",
  "from_address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "to_address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "amount": [
    {
      "denom": "udaric",
      "amount": "1000"
    }
  ]
}
```

## MsgMultiSend

```json
{
  "@type": "/cosmos.bank.v1beta1.MsgMultiSend",
  "inputs": [
    {
      "address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
      "coins": [
        {
          "denom": "udaric",
          "amount": "1000"
        }
      ]
    }
  ],
  "outputs": [
    {
      "address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
      "coins": [
        {
          "denom": "udaric",
          "amount": "1000"
        }
      ]
    }
  ]
}
```

'''
'''--- .docs/messages/crisis.md ---
# x/crisis

## MsgVerifyInvariant

```json
{
  "@type": "/cosmos.crisis.v1beta1.MsgVerifyInvariant",
  "sender": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "invariant_module_name": "distribution",
  "invariant_route": "module-account"
}
```
'''
'''--- .docs/messages/distribution.md ---
# x/distribution

## MsgFundCommunityPool

```json
{
  "@type": "/cosmos.distribution.v1beta1.MsgFundCommunityPool",
  "amount": [
    {
      "denom": "udaric",
      "amount": "1000"
    }
  ],
  "depositor": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu"
}
```

## MsgSetWithdrawAddress

```json
{
  "@type": "/cosmos.distribution.v1beta1.MsgSetWithdrawAddress",
  "delegator_address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "withdraw_address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu"
}
```

## MsgWithdrawDelegatorReward

```json
{
  "@type": "/cosmos.distribution.v1beta1.MsgWithdrawDelegatorReward",
  "delegator_address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "validator_address": "desmosvaloper13yp2fq3tslq6mmtq4628q38xzj75ethz8j43kw"
}
```
'''
'''--- .docs/messages/gov.md ---
# x/gov

## MsgSubmitProposal

The `MsgSubsmitProposal` allows to submit a governance proposal.

There are various types of proposals that can be submitted. What distinguishes between one or another is the value of
the `content.@type` field. Following you can find the most common ones.

**Note**. Each chain can define its own proposal types.

### TextProposal

```json
{
  "@type": "/cosmos.gov.v1beta1.MsgSubmitProposal",
  "content": {
    "@type": "/cosmos.gov.v1beta1.TextProposal",
    "title": "test software upgrade proposal",
    "description": "something about the proposal here"
  },
  "initial_deposit": [
    {
      "denom": "udaric",
      "amount": "20000000"
    }
  ],
  "proposer": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu"
}
```

### SoftwareUpgradeProposal

```json
{
  "@type": "/cosmos.gov.v1beta1.MsgSubmitProposal",
  "content": {
    "@type": "/cosmos.upgrade.v1beta1.SoftwareUpgradeProposal",
    "title": "test software upgrade proposal",
    "description": "something about the proposal here",
    "plan": {
      "name": "test",
      "time": "0001-01-01T00:00:00Z",
      "height": "50",
      "info": "",
      "upgraded_client_state": null
    }
  },
  "initial_deposit": [
    {
      "denom": "udaric",
      "amount": "20000000"
    }
  ],
  "proposer": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu"
}
```

### ParameterChangeProposal

```json
{
  "@type": "/cosmos.gov.v1beta1.MsgSubmitProposal",
  "content": {
    "@type": "/cosmos.params.v1beta1.ParameterChangeProposal",
    "title": "Param change proposal",
    "description": "This is a param change proposal",
    "changes": [
      {
        "subspace": "staking",
        "key": "max_validators",
        "value": "200"
      }
    ]
  },
  "initial_deposit": [
    {
      "denom": "udaric",
      "amount": "20000000"
    }
  ],
  "proposer": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu"
}
```

### CommunityPoolSpendProposal

```json
{
  "@type": "/cosmos.gov.v1beta1.MsgSubmitProposal",
  "content": {
    "@type": "/cosmos.distribution.v1beta1.CommunityPoolSpendProposal",
    "title": "Community spend proposal",
    "description": "This is a community spend proposal",
    "recipient": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
    "amount": [
      {
        "denom": "udaric",
        "amount": "20000000"
      }
    ]
  },
  "initial_deposit": [
    {
      "denom": "udaric",
      "amount": "20000000"
    }
  ],
  "proposer": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu"
}
```

## MsgDeposit

```json
{
  "@type": "/cosmos.gov.v1beta1.MsgDeposit",
  "proposal_id": "1",
  "depositor": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "amount": [
    {
      "denom": "udaric",
      "amount": "100"
    }
  ]
}
```

## MsgVote

```json
{
  "@type": "/cosmos.gov.v1beta1.MsgVote",
  "proposal_id": "1",
  "voter": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "option": "VOTE_OPTION_YES"
}
```

'''
'''--- .docs/messages/slashing.md ---
# x/slashing

## MsgUnjail

```json
{
  "@type": "/cosmos.slashing.v1beta1.MsgUnjail",
  "validator_addr": "desmosvaloper13yp2fq3tslq6mmtq4628q38xzj75ethz8j43kw"
}
```
'''
'''--- .docs/messages/staking.md ---
# x/staking

## MsgCreateValidator

```json
{
  "@type": "/cosmos.staking.v1beta1.MsgCreateValidator",
  "description": {
    "moniker": "Validator moniker",
    "identity": "",
    "website": "",
    "security_contact": "",
    "details": ""
  },
  "commission": {
    "rate": "0.100000000000000000",
    "max_rate": "0.200000000000000000",
    "max_change_rate": "0.010000000000000000"
  },
  "min_self_delegation": "1",
  "delegator_address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "validator_address": "desmosvaloper13yp2fq3tslq6mmtq4628q38xzj75ethz8j43kw",
  "pubkey": {
    "@type": "/cosmos.crypto.ed25519.PubKey",
    "key": "1pk2pQfffJGLUqoOKQpHz1qnil0ymzYPEdSMufr1vTw="
  },
  "value": {
    "denom": "udaric",
    "amount": "1000000"
  }
}
```

## MsgDelegate

```json
{
  "@type": "/cosmos.staking.v1beta1.MsgDelegate",
  "delegator_address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "validator_address": "desmosvaloper13yp2fq3tslq6mmtq4628q38xzj75ethz8j43kw",
  "amount": {
    "denom": "udaric",
    "amount": "1000"
  }
}
```

## MsgEditValidator

```json
{
  "@type": "/cosmos.staking.v1beta1.MsgEditValidator",
  "description": {
    "moniker": "New moniker",
    "identity": "[do-not-modify]",
    "website": "[do-not-modify]",
    "security_contact": "[do-not-modify]",
    "details": "[do-not-modify]"
  },
  "validator_address": "desmosvaloper13yp2fq3tslq6mmtq4628q38xzj75ethz8j43kw",
  "commission_rate": null,
  "min_self_delegation": null
}
```

## MsgRedelegate

```json
{
  "@type": "/cosmos.staking.v1beta1.MsgBeginRedelegate",
  "delegator_address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "validator_src_address": "desmosvaloper13yp2fq3tslq6mmtq4628q38xzj75ethz8j43kw",
  "validator_dst_address": "desmosvaloper13yp2fq3tslq6mmtq4628q38xzj75ethz8j43kw",
  "amount": {
    "denom": "udaric",
    "amount": "1000"
  }
}
```

## MsgUndelegate

```json
{
  "@type": "/cosmos.staking.v1beta1.MsgUndelegate",
  "delegator_address": "desmos13yp2fq3tslq6mmtq4628q38xzj75ethzela9uu",
  "validator_address": "desmosvaloper13yp2fq3tslq6mmtq4628q38xzj75ethz8j43kw",
  "amount": {
    "denom": "udaric",
    "amount": "1000"
  }
}
```
'''
'''--- .github/ISSUE_TEMPLATE/bug_report.md ---
---
name: Bug report
about: Create a report to help us improve
title: ''
labels: 'kind/bug'
assignees: 'MonikaCat'

---
<!-- < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < ☺ 
v                            ✰  Thanks for opening an issue! ✰    
v    Before smashing the submit button please review the template.
v    Please also ensure that this is not a duplicate issue :)  
☺ > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > >  --> 

## Bug description
<!-- A clear and concise description of what the bug is. -->

## Steps to reproduce
<!-- Steps to reproduce the bug --> 

## Expected behavior
<!-- A clear and concise description of what you expected to happen. -->

'''
'''--- .github/ISSUE_TEMPLATE/feature_request.md ---
---
name: Feature request
about: Suggest an idea for this project
title: ''
labels: 'kind/new-feature'
assignees: ''

---
<!-- < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < < ☺ 
v                            ✰  Thanks for opening an issue! ✰    
v    Before smashing the submit button please review the template.
v    Word of caution: poorly thought-out proposals may be rejected 
v                     without deliberation 
☺ > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > > >  --> 

## Feature description 
<!-- A clear and concise description of what the problem is. Ex. I'm always frustrated when [...] -->

## Implementation proposal
<!-- A clear and concise description of what you would want to happen. -->

'''
'''--- .github/PULL_REQUEST_TEMPLATE.md ---
## Description

Closes: #XXXX

<!-- Add a description of the changes that this PR introduces and the files that
are the most critical to review. -->

---

### Author Checklist

*All items are required. Please add a note to the item if the item is not applicable and
please add links to any relevant follow up issues.*

I have...

- [ ] included the correct [type prefix](https://github.com/commitizen/conventional-commit-types/blob/v3.0.0/index.json) in the PR title
- [ ] added `!` to the type prefix if API or client breaking change
- [ ] targeted the correct branch
- [ ] provided a link to the relevant issue or specification
- [ ] added a changelog entry to `CHANGELOG.md`
- [ ] included comments for [documenting Go code](https://blog.golang.org/godoc)
- [ ] updated the relevant documentation or specification
- [ ] reviewed "Files changed" and left comments if necessary
- [ ] confirmed all CI checks have passed

### Reviewers Checklist

*All items are required. Please add a note if the item is not applicable and please add
your handle next to the items reviewed if you only reviewed selected items.*

I have...

- [ ] confirmed the correct [type prefix](https://github.com/commitizen/conventional-commit-types/blob/v3.0.0/index.json) in the PR title
- [ ] confirmed `!` in the type prefix if API or client breaking change
- [ ] confirmed all author checklist items have been addressed
- [ ] reviewed API design and naming
- [ ] reviewed documentation is accurate
- [ ] reviewed tests and test coverage
- [ ] manually tested (if applicable)
'''
'''--- .github/dependabot.yml ---
version: 2
updates:
  - package-ecosystem: github-actions
    directory: "/"
    schedule:
      interval: daily
    open-pull-requests-limit: 10
  - package-ecosystem: gomod
    directory: "/"
    schedule:
      interval: daily
    open-pull-requests-limit: 10
    reviewers:
      - MonikaCat
    labels:
      - automerge
      - dependencies
'''
'''--- .github/workflows/docker-build.yml ---
name: docker-build

on:
  push:
    branches:
      - chains/*/*

jobs:
  docker:
    runs-on: ubuntu-latest
    steps:
      -
        name: Checkout
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - 
        name: Set bdjuno chain_name
        shell: bash
        run: echo "CHAIN_NAME=$(echo ${GITHUB_REF#refs/heads/} | sed 's/\//_/g')" >> $GITHUB_ENV
      -
        name: Set bdjuno version
        shell: bash
        run: echo "GITHUB_VERSION=$(git describe --tags)" >> $GITHUB_ENV
      -
        name: Prepare tags
        id: prep
        run: |
          DOCKER_IMAGE=${{ secrets.DOCKERHUB_BDJUNO_REPO }}
          CHAIN_NAME="${{env.CHAIN_NAME}}"
          VERSION="${{env.GITHUB_VERSION}}"
          TAGS="${DOCKER_IMAGE}:${CHAIN_NAME}-${VERSION}"
          echo ::set-output name=version::${VERSION}
          echo ::set-output name=tags::${TAGS}
          echo ::set-output name=created::$(date -u +'%Y-%m-%dT%H:%M:%SZ')
      - name: Determine Dockerfile to use
        run: |
          if [[ -f Dockerfile.cosmwasm ]]; then
            export DOCKERFILE=Dockerfile.cosmwasm
          else
            export DOCKERFILE=Dockerfile.default
          fi
          echo "DOCKERFILE=${DOCKERFILE}" >> $GITHUB_ENV
      -
        name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
      -
        name: Login to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}
      -
        name: Build and push
        uses: docker/build-push-action@v4
        with:
          context: .
          file: "./${{ env.DOCKERFILE }}"
          push: true
          tags: ${{ steps.prep.outputs.tags }}

'''
'''--- .github/workflows/lint-pr.yml ---
name: "Lint PR"

on:
  pull_request_target:
    types:
      - opened
      - edited
      - synchronize

jobs:
  main:
    runs-on: ubuntu-latest
    steps:
      - uses: amannn/action-semantic-pull-request@v5.2.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
'''
'''--- .github/workflows/lint.yml ---
name: Lint
# Lint runs golangci-lint over the entire Desmos repository.
# This workflow is run on every pull request and push to master.
# The `golangci` will pass without running if no *.{go, mod, sum} files have been changed.
on:
  pull_request:
  push:
    branches:
      - master

jobs:
  GolangCI:
    name: golangci-lint
    runs-on: ubuntu-latest
    timeout-minutes: 6
    steps:
      - uses: actions/checkout@v3
      - uses: technote-space/get-diff-action@v6.1.2
        with:
          SUFFIX_FILTER: |
            .go
            .mod
            .sum
      - uses: golangci/golangci-lint-action@v3.6.0
        with:
          version: v1.51.1
          args: --timeout 10m
          github-token: ${{ secrets.GITHUB_TOKEN }}
        if: "env.GIT_DIFF != ''"

'''
'''--- .github/workflows/test.yml ---
name: Tests
# Tests / Code Coverage workflow runs unit tests and uploads a code coverage report.
# This workflow is run on pushes to master & every Pull Requests where a .go, .mod, .sum have been changed.
on:
  pull_request:
  push:
    branches:
      - master

jobs:
  Cleanup-runs:
    runs-on: ubuntu-latest
    steps:
      - uses: rokroskar/workflow-run-cleanup-action@master
        env:
          GITHUB_TOKEN: "${{ secrets.GITHUB_TOKEN }}"
    if: "!startsWith(github.ref, 'refs/tags/') && github.ref != 'refs/heads/master'"

  Unit-tests:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout
        uses: actions/checkout@v3
      - name: Setup Go
        uses: actions/setup-go@v4
        with:
          go-version: "1.20"
      - name: Test & Create coverage report
        run: make install test-unit stop-docker-test
      - name: Upload cove coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage.txt

'''
'''--- .mergify.yml ---
queue_rules:
  - name: default
    conditions:
      - or:
        - base~=cosmos/
        - base~=chains/

pull_request_rules:
  - name: automerge with label automerge and branch protection passing
    conditions:
      - "#approved-reviews-by>0"
      - label=automerge
    actions:
      queue:
        name: default
        method: squash
        commit_message_template: >
          {{ title }} (#{{ number }})
          
          {{ body }}

'''
'''--- CHANGELOG.md ---
## Unreleased
### Changes

#### CI
- ([\#508](https://github.com/forbole/bdjuno/pull/508)) Upgrade workflow golangci version to v1.50.1

#### Parse Command
- ([\#492](https://github.com/forbole/bdjuno/pull/492)) Add parse command for periodic tasks: `x/bank` total supply, `x/distribution` community pool, `x/mint` inflation, `pricefeed` token price and price history, `x/staking` staking pool

#### Upgrade Module
- ([\#467](https://github.com/forbole/bdjuno/pull/467)) Store software upgrade plan and refresh data at upgrade height

#### Staking Module
- ([\#443](https://github.com/forbole/bdjuno/pull/443)) Remove tombstone status from staking module(already stored in slashing module)
- ([\#455](https://github.com/forbole/bdjuno/pull/455)) Added `unbonding_tokens` and `staked_not_bonded_tokens` values to staking pool table
- ([\#536](https://github.com/forbole/bdjuno/pull/536) Fix `PoolSnapshot` tokens type from  `sdk.Int` to `sdkmath.Int`

#### Gov Module
- ([\#461](https://github.com/forbole/bdjuno/pull/461)) Parse `x/gov` genesis with `genesisDoc.InitialHeight` instead of the hard-coded height 1
- ([\#465](https://github.com/forbole/bdjuno/pull/465)) Get open proposal ids in deposit or voting period by block time instead of current time
- ([\#489](https://github.com/forbole/bdjuno/pull/489)) Remove block height foreign key from proposal_vote and proposal_deposit tables and add column timestamp
- ([\#499](https://github.com/forbole/bdjuno/pull/499)) Check if proposal has passed voting end time before marking it invalid
- ([\#523](https://github.com/forbole/bdjuno/pull/523)) Update proposal snapshots handling on block

#### Daily refetch
- ([\#454](https://github.com/forbole/bdjuno/pull/454)) Added `daily refetch` module to refetch missing blocks every day

#### Hasura
- ([\#473](https://github.com/forbole/bdjuno/pull/473)) Improved Hasura permissions
- ([\#491](https://github.com/forbole/bdjuno/pull/491)) Add host address to Hasura actions

### Dependencies
- ([\#462](https://github.com/forbole/bdjuno/pull/462)) Updated Juno to `v3.4.0`
- ([\#542](https://github.com/forbole/bdjuno/pull/542)) Updated Juno to `v4.1.0`,  BDJuno to `v4` and Golang version to `1.19`

## Version v3.2.0
### Changes
#### Mint module
- ([\#432](https://github.com/forbole/bdjuno/pull/432)) Update inflation rate when mint param change proposal is passed

#### Gov module
- ([\#401](https://github.com/forbole/bdjuno/pull/401)) Update the proposal status to the latest in `bdjuno parse gov proposal [id]` command
- ([\#430](https://github.com/forbole/bdjuno/pull/430)) Update the proposals that have invalid status but can still be in voting or deposit periods 

### Dependencies
- ([\#440](https://github.com/forbole/bdjuno/pull/440)) Updated Juno to `v3.3.0`

## Version v3.1.0
### Dependencies
- Updated Juno to `v3.2.0`

### Changes 
#### Hasura
- ([\#395](https://github.com/forbole/bdjuno/pull/395)) Remove time label from Hasura Prometheus monitoring

#### Bank module
- ([\#410](https://github.com/forbole/bdjuno/pull/410)) Change total supply query from only 1 page to all pages

## Version v3.0.1
### Dependencies
- Updated Juno to `v3.1.1`

## Version v3.0.0
### Notes
This version introduces breaking changes to `transaction` and `message` PostgreSQL tables. It implements PostgreSQL table partitioning to fix slow data retrieval from database that stores large amount of transactions and messages. Read more details about [migrating to v3.0.0](https://docs.bigdipper.live/cosmos-based/parser/migrations/v2.0.0)

### New features 
#### CLI
- ([\#356](https://github.com/forbole/bdjuno/pull/356)) Implemented `migrate` command to perform easy migration to higher BDJuno versions
- ([\#356](https://github.com/forbole/bdjuno/pull/356)) Updated `parse-genesis` command to parse genesis file without accessing the node

#### Database
- ([\#356](https://github.com/forbole/bdjuno/pull/356)) Added PostgreSQL table partition to `transaction` and `message` table
- ([\#356](https://github.com/forbole/bdjuno/pull/356)) Created new `messages_by_address` function

### Changes 
#### Hasura
- ([\#377](https://github.com/forbole/bdjuno/pull/377)) Updated Hasura metadata
- ([\#381](https://github.com/forbole/bdjuno/pull/381)) Hasura actions are now a module 

### Dependencies
- ([\#356](https://github.com/forbole/bdjuno/pull/356)) Updated Juno to `v3.0.0`

## Version v2.0.0
### Notes
This version introduces breaking changes to certain address-specific data that is no longer periodically parsed from the node and stored in the database. Instead, the data is now obtained directly from the node when needed using Hasura Actions. Read more details about [migrating to v2.0.0](https://docs.bigdipper.live/cosmos-based/parser/migrations/v2.0.0)

### New features
#### CLI
- ([\#257](https://github.com/forbole/bdjuno/pull/257)) Added `parse-genesis` command to parse the genesis file
- ([\#228](https://github.com/forbole/bdjuno/pull/228)) ([\#248](https://github.com/forbole/bdjuno/pull/248)) Added `fix` command:
  - `auth`: fix vesting accounts details
  - `blocks`: fix missing blocks and transactions from given start height
  - `gov`: fix proposal with given proposal ID  
  - `staking`: fix validators info at the latest height  

#### Hasura Actions
- ([\#329](https://github.com/forbole/bdjuno/pull/329)) Implemented Hasura Actions service to replace periodic queries. If you are using GraphQL queries on your application, you should updated the old queries to use the below new actions instead.  
  Here's a list of data acquired through Hasura Actions:
    - Of a certain address/delegator:
      - Account balance (`action_account_balance`)
      - Delegation rewards (`action_delegation_reward`)
      - Delegator withdraw address (`action_delegator_withdraw_address`)
      - Delegations (`action_delegation`)
      - Total delegations amount (`action_delegation_total`)
      - Unbonding delegations (`action_unbonding_delegation`)
      - Total unbonding delegations amount (`action_unbonding_delegation_total`)
      - Redelegations (`action_redelegation`)
    - Of a certain validator:
      - Commission amount (`action_validator_commission_amount`)
      - Delegations to this validator (`action_validator_delegations`)
      - Redelegations from this validator (`action_validator_redelegations_from`)
      - Unbonding delegations (`action_validator_unbonding_delegations`)
- ([\#352](https://github.com/forbole/bdjuno/pull/352)) Added prometheus monitoring to hasura actions

#### Local node support
- Added the support for `node.type = "local"` for parsing a static local node without the usage gRPC queries: [config reference](https://docs.bigdipper.live/cosmos-based/parser/config/config#node).

#### Modules
- ([\#232](https://github.com/forbole/bdjuno/pull/232)) Updated the `x/auth` module support to handle and store `vesting accounts` and `vesting periods` inside the database. 
- ([\#276](https://github.com/forbole/bdjuno/pull/276)) Added the support for the `x/feegrant` module (v0.44.x)

### Changes 

#### CLI
- ([\#351](https://github.com/forbole/bdjuno/pull/351)) Fixed version display for `bdjuno version` cmd 

#### Database
- ([\#300](https://github.com/forbole/bdjuno/pull/300)) Changed `bonded_tokens` and `not_bonded_tokens` type inside `staking_pool` table  to `TEXT` to avoid value overflow
- ([\#275](https://github.com/forbole/bdjuno/pull/275)) Added `tombstoned` column inside `validator_status` table
- ([\#232](https://github.com/forbole/bdjuno/pull/232)) Added `vesting_account` and `vesting_period` table
- ([\#276](https://github.com/forbole/bdjuno/pull/276)) Added `fee_grant_allowance` table (v0.44.x)

#### Modules
- ([\#353](https://github.com/forbole/bdjuno/pull/353)) Removed the support for the `history` module

'''
'''--- README.md ---
# BDJuno
[![GitHub Workflow Status](https://img.shields.io/github/workflow/status/forbole/bdjuno/Tests)](https://github.com/forbole/bdjuno/actions?query=workflow%3ATests)
[![Go Report Card](https://goreportcard.com/badge/github.com/forbole/bdjuno)](https://goreportcard.com/report/github.com/forbole/bdjuno)
![Codecov branch](https://img.shields.io/codecov/c/github/forbole/bdjuno/cosmos/v0.40.x)

BDJuno (shorthand for BigDipper Juno) is the [Juno](https://github.com/forbole/juno) implementation
for [BigDipper](https://github.com/forbole/big-dipper).

It extends the custom Juno behavior by adding different handlers and custom operations to make it easier for BigDipper
showing the data inside the UI.

All the chains' data that are queried from the RPC and gRPC endpoints are stored inside
a [PostgreSQL](https://www.postgresql.org/) database on top of which [GraphQL](https://graphql.org/) APIs can then be
created using [Hasura](https://hasura.io/).

## Usage
To know how to setup and run BDJuno, please refer to
the [docs website](https://docs.bigdipper.live/cosmos-based/parser/overview/).

## Testing
If you want to test the code, you can do so by running

```shell
$ make test-unit
```

**Note**: Requires [Docker](https://docker.com).

This will:
1. Create a Docker container running a PostgreSQL database.
2. Run all the tests using that database as support.

'''
'''--- Requirements.md ---
# Requirements of BDjuno
The BDjuno is working as a backend for Big Dipper. The followings are the features currently supported in Big Dipper in the backend which BDjuno should adapt.

## On every block
### Done by Juno by default
- [x] Parsing all blocks
- [x] Parsing all transactions
- [x] Store validator set of the block

### Custom BDJuno implementations
- [x] Update missed block records
- [x] Read the latest consensus state
- [x] [x/auth] Store vesting accounts and vesting periods details
- [x] [x/distribution] Update community pool
- [x] [x/feegrant] Store feegrant allowance details
- [x] [x/gov] Get gov proposals, deposits and votes
- [x] [x/gov] Calculate the tally result
- [x] [x/mint] Update the inflation
- [x] [x/slashing] Get validators signing info
- [x] [x/staking] Update validator information 
- [x] [x/staking] Calculate validator voting power percentage 
- [x] [x/staking] Update the total staked tokens 
- [x] [x/staking] Update the double sign evidences
- [x] [x/supply] Update the total supply

### Achievable using GraphQL APIs
- [x] Calculate the average block time

### Achievable using Hasura Actions
Address/Delegator related data:
- [x] Get account balance
- [x] Get delegations
- [x] Get total delegations amount
- [x] Get delegation rewards
- [x] Get unbonding delegations
- [x] Get total unbonding delegations amount
- [x] Get redelegations
- [x] Get delegator withdraw address

Validator related data:
- [x] Get commission amount
- [x] Get validator delegations
- [x] Get validator redelegations
- [x] Get validator unbonding delegations

## On intervals
- [x] [x/bank] Get total supply (per 10 mins)
- [x] [x/distribution] Get community pool (per hour)
- [x] [x/mint] Get inflation (per day)
- [x] [x/pricefeed] Get token price and marketcap (per 2 minutes, per hour)
- [x] [x/staking] Calculate average delegation ratio (per hour, per day) *
- [x] [x/staking] Calculate voting power distribution (per hour) *

\* These should be doable using the `average` method inside GraphQL

## Not on Big Dipper now but we are considering to add

- [ ] All wallets activities
- [ ] Alert on events: 
   - [ ] Proposal creation
   - [ ] Slashing
   - [ ] Huge delegation
   - [ ] Validator low uptime
   - [ ] Huge undelegation
   - [ ] Proposal start voting 
   - [ ] Proposal voting ends
- [ ] Validators rating
   - [ ] Self-delegation
   - [ ] Uptime
   - [ ] Ever slashed
   - [ ] Gov participation
   - [ ] Community contributions
   - [ ] Number of delegators

'''
'''--- cmd/bdjuno/main.go ---
package main

import (
	"github.com/cosmos/cosmos-sdk/types/module"
	"github.com/forbole/juno/v5/cmd"
	initcmd "github.com/forbole/juno/v5/cmd/init"
	parsetypes "github.com/forbole/juno/v5/cmd/parse/types"
	startcmd "github.com/forbole/juno/v5/cmd/start"
	"github.com/forbole/juno/v5/modules/messages"

	migratecmd "github.com/forbole/bdjuno/v5/cmd/migrate"
	parsecmd "github.com/forbole/bdjuno/v5/cmd/parse"

	"github.com/forbole/bdjuno/v5/types/config"

	"cosmossdk.io/simapp"
	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules"
)

func main() {
	initCfg := initcmd.NewConfig().
		WithConfigCreator(config.Creator)

	parseCfg := parsetypes.NewConfig().
		WithDBBuilder(database.Builder).
		WithEncodingConfigBuilder(config.MakeEncodingConfig(getBasicManagers())).
		WithRegistrar(modules.NewRegistrar(getAddressesParser()))

	cfg := cmd.NewConfig("bdjuno").
		WithInitConfig(initCfg).
		WithParseConfig(parseCfg)

	// Run the command
	rootCmd := cmd.RootCmd(cfg.GetName())

	rootCmd.AddCommand(
		cmd.VersionCmd(),
		initcmd.NewInitCmd(cfg.GetInitConfig()),
		parsecmd.NewParseCmd(cfg.GetParseConfig()),
		migratecmd.NewMigrateCmd(cfg.GetName(), cfg.GetParseConfig()),
		startcmd.NewStartCmd(cfg.GetParseConfig()),
	)

	executor := cmd.PrepareRootCmd(cfg.GetName(), rootCmd)
	err := executor.Execute()
	if err != nil {
		panic(err)
	}
}

// getBasicManagers returns the various basic managers that are used to register the encoding to
// support custom messages.
// This should be edited by custom implementations if needed.
func getBasicManagers() []module.BasicManager {
	return []module.BasicManager{
		simapp.ModuleBasics,
	}
}

// getAddressesParser returns the messages parser that should be used to get the users involved in
// a specific message.
// This should be edited by custom implementations if needed.
func getAddressesParser() messages.MessageAddressesParser {
	return messages.JoinMessageParsers(
		messages.CosmosMessageAddressesParser,
	)
}

'''
'''--- cmd/migrate/cmd.go ---
package migrate

import (
	"fmt"
	"os"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/spf13/cobra"

	v3 "github.com/forbole/bdjuno/v5/cmd/migrate/v3"
)

type Migrator func(parseCfg *parsecmdtypes.Config) error

var (
	migrations = map[string]Migrator{
		"v3": v3.RunMigration,
	}
)

func getVersions() []string {
	var versions []string
	for key := range migrations {
		versions = append(versions, key)
	}
	return versions
}

// NewMigrateCmd returns the Cobra command allowing to migrate config and tables to v3 version
func NewMigrateCmd(appName string, parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "migrate [to-version]",
		Short: "Perform the migrations from the current version to the specified one",
		Long: `Migrates all the necessary things (config file, database, etc) from the current version to the new one.
Note that migrations must be performed in order: to migrate from vX to vX+2 you need to do vX -> vX+1 and then vX+1 -> vX+2. 
`,
		Example: fmt.Sprintf("%s migrate v3", appName),
		Args:    cobra.RangeArgs(0, 1),
		RunE: func(cmd *cobra.Command, args []string) error {
			cmd.SetOut(os.Stdout)
			if len(args) == 0 {
				cmd.Println("Please specify a version to migrate to. Available versions:")
				for _, version := range getVersions() {
					cmd.Println("-", version)
				}
				return nil
			}

			version := args[0]
			migrator, ok := migrations[version]
			if !ok {
				return fmt.Errorf("migration for version %s not found", version)
			}

			return migrator(parseConfig)
		},
	}
}

'''
'''--- cmd/migrate/v1/config.go ---
package v1

import (
	"github.com/pelletier/go-toml"
)

type TomlConfig struct {
	PricefeedConfig    *PricefeedConfig    `toml:"pricefeed"`
	DistributionConfig *DistributionConfig `toml:"distribution"`
}

func ParseConfig(bz []byte) (TomlConfig, error) {
	var tomlCfg TomlConfig
	err := toml.Unmarshal(bz, &tomlCfg)
	if err != nil {
		return TomlConfig{}, err
	}

	return TomlConfig{
		PricefeedConfig:    tomlCfg.PricefeedConfig,
		DistributionConfig: tomlCfg.DistributionConfig,
	}, nil
}

type PricefeedConfig struct {
	Tokens []Token `toml:"tokens"`
}

type Token struct {
	Name  string      `toml:"name"`
	Units []TokenUnit `toml:"units"`
}

type TokenUnit struct {
	Denom    string   `toml:"denom"`
	Exponent int      `toml:"exponent"`
	Aliases  []string `toml:"aliases"`
	PriceID  string   `toml:"price_id"`
}

type DistributionConfig struct {
	DistributionFrequency int64 `toml:"distribution_frequency"`
}

'''
'''--- cmd/migrate/v3/migrate.go ---
package v3

import (
	"fmt"
	"os"

	"github.com/forbole/bdjuno/v5/modules/actions"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"

	"gopkg.in/yaml.v3"

	junov4 "github.com/forbole/juno/v5/cmd/migrate/v4"
	"github.com/forbole/juno/v5/types/config"
)

// RunMigration runs the migrations from v2 to v3
func RunMigration(parseConfig *parsecmdtypes.Config) error {
	// Run Juno migration
	err := junov4.RunMigration(parseConfig)
	if err != nil {
		return err
	}

	// Migrate the config
	cfg, err := migrateConfig()
	if err != nil {
		return fmt.Errorf("error while migrating config: %s", err)
	}

	// Refresh the global configuration
	err = parsecmdtypes.UpdatedGlobalCfg(parseConfig)
	if err != nil {
		return err
	}

	bz, err := yaml.Marshal(&cfg)
	if err != nil {
		return fmt.Errorf("error while serializing config: %s", err)
	}

	err = os.WriteFile(config.GetConfigFilePath(), bz, 0600)
	if err != nil {
		return fmt.Errorf("error while writing v3 config: %s", err)
	}

	return nil
}

func migrateConfig() (Config, error) {
	cfg, err := GetConfig()
	if err != nil {
		return Config{}, fmt.Errorf("error while reading v2 config: %s", err)
	}

	// Enable the actions module if not enabled
	if !cfg.Chain.IsModuleEnabled(actions.ModuleName) {
		cfg.Chain.Modules = append(cfg.Chain.Modules, actions.ModuleName)
	}

	if cfg.Actions == nil {
		cfg.Actions = actions.NewConfig("127.0.0.1", 3000, nil)
	}

	return cfg, nil
}

'''
'''--- cmd/migrate/v3/types.go ---
package v3

import (
	v3 "github.com/forbole/juno/v5/cmd/migrate/v3"

	"github.com/forbole/bdjuno/v5/modules/actions"
)

type Config struct {
	v3.Config `yaml:"-,inline"`

	// The following are there to support modules which config are present if they are enabled

	Actions *actions.Config `yaml:"actions"`
}

'''
'''--- cmd/migrate/v3/utils.go ---
package v3

import (
	"fmt"
	"os"
	"path"

	"github.com/forbole/juno/v5/types/config"
	"gopkg.in/yaml.v3"
)

// GetConfig returns the configuration reading it from the config.yaml file present inside the home directory
func GetConfig() (Config, error) {
	file := path.Join(config.HomePath, "config.yaml")

	// Make sure the path exists
	if _, err := os.Stat(file); os.IsNotExist(err) {
		return Config{}, fmt.Errorf("config file does not exist")
	}

	bz, err := os.ReadFile(file)
	if err != nil {
		return Config{}, fmt.Errorf("error while reading config files: %s", err)
	}

	var cfg Config
	err = yaml.Unmarshal(bz, &cfg)
	return cfg, err
}

'''
'''--- cmd/parse/auth/cmd.go ---
package auth

import (
	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/spf13/cobra"
)

// NewAuthCmd returns the Cobra command that allows to fix all the things related to the x/auth module
func NewAuthCmd(parseCfg *parsecmdtypes.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "auth",
		Short: "Fix things related to the x/auth module",
	}

	cmd.AddCommand(
		vestingCmd(parseCfg),
	)

	return cmd
}

'''
'''--- cmd/parse/auth/vesting.go ---
package auth

import (
	"encoding/json"
	"fmt"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/forbole/juno/v5/types/config"
	"github.com/spf13/cobra"

	"github.com/forbole/bdjuno/v5/database"
	authutils "github.com/forbole/bdjuno/v5/modules/auth"
	"github.com/forbole/bdjuno/v5/utils"
)

// vestingCmd returns a Cobra command that allows to fix the vesting data for the accounts
func vestingCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "vesting-accounts",
		Short: "Fix the vesting accounts stored by removing duplicated vesting periods",
		RunE: func(cmd *cobra.Command, args []string) error {
			parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parseConfig)
			if err != nil {
				return err
			}

			// Get the database
			db := database.Cast(parseCtx.Database)

			// Get the genesis
			genesis, err := utils.ReadGenesis(config.Cfg, parseCtx.Node)
			if err != nil {
				return fmt.Errorf("error while reading the genesis: %s", err)
			}

			var appState map[string]json.RawMessage
			if err := json.Unmarshal(genesis.AppState, &appState); err != nil {
				return fmt.Errorf("error unmarshalling genesis doc: %s", err)
			}

			vestingAccounts, err := authutils.GetGenesisVestingAccounts(appState, parseCtx.EncodingConfig.Codec)
			if err != nil {
				return fmt.Errorf("error while gestting vesting accounts: %s", err)
			}

			err = db.SaveVestingAccounts(vestingAccounts)
			if err != nil {
				return fmt.Errorf("error while storing vesting accounts: %s", err)
			}

			return nil
		},
	}
}

'''
'''--- cmd/parse/bank/cmd.go ---
package bank

import (
	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/spf13/cobra"
)

// NewBankCmd returns the Cobra command allowing to fix various things related to the x/bank module
func NewBankCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "bank",
		Short: "Fix things related to the x/bank module",
	}

	cmd.AddCommand(
		supplyCmd(parseConfig),
	)

	return cmd
}

'''
'''--- cmd/parse/bank/supply.go ---
package bank

import (
	"fmt"

	modulestypes "github.com/forbole/bdjuno/v5/modules/types"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/forbole/juno/v5/types/config"
	"github.com/spf13/cobra"

	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules/bank"
)

// supplyCmd returns the Cobra command allowing to refresh x/bank total supply
func supplyCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "supply",
		Short: "Refresh total supply",
		RunE: func(cmd *cobra.Command, args []string) error {
			parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parseConfig)
			if err != nil {
				return err
			}

			sources, err := modulestypes.BuildSources(config.Cfg.Node, parseCtx.EncodingConfig)
			if err != nil {
				return err
			}

			// Get the database
			db := database.Cast(parseCtx.Database)

			// Build bank module
			bankModule := bank.NewModule(nil, sources.BankSource, parseCtx.EncodingConfig.Codec, db)

			err = bankModule.UpdateSupply()
			if err != nil {
				return fmt.Errorf("error while getting latest bank supply: %s", err)
			}

			return nil
		},
	}
}

'''
'''--- cmd/parse/distribution/cmd.go ---
package distribution

import (
	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/spf13/cobra"
)

// NewDistributionCmd returns the Cobra command allowing to fix various things related to the x/distribution module
func NewDistributionCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "distribution",
		Short: "Fix things related to the x/distribution module",
	}

	cmd.AddCommand(
		communityPoolCmd(parseConfig),
	)

	return cmd
}

'''
'''--- cmd/parse/distribution/communitypool.go ---
package distribution

import (
	"fmt"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/forbole/juno/v5/types/config"
	"github.com/spf13/cobra"

	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules/distribution"
	modulestypes "github.com/forbole/bdjuno/v5/modules/types"
)

// communityPoolCmd returns the Cobra command allowing to refresh community pool
func communityPoolCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "community-pool",
		Short: "Refresh community pool",
		RunE: func(cmd *cobra.Command, args []string) error {
			parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parseConfig)
			if err != nil {
				return err
			}

			sources, err := modulestypes.BuildSources(config.Cfg.Node, parseCtx.EncodingConfig)
			if err != nil {
				return err
			}

			// Get the database
			db := database.Cast(parseCtx.Database)

			// Build distribution module
			distrModule := distribution.NewModule(sources.DistrSource, parseCtx.EncodingConfig.Codec, db)

			err = distrModule.GetLatestCommunityPool()
			if err != nil {
				return fmt.Errorf("error while updating community pool: %s", err)
			}

			return nil
		},
	}
}

'''
'''--- cmd/parse/feegrant/allowance.go ---
package feegrant

import (
	"encoding/hex"
	"fmt"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/forbole/juno/v5/types/config"

	"github.com/forbole/bdjuno/v5/modules/feegrant"
	"github.com/forbole/bdjuno/v5/utils"

	"github.com/spf13/cobra"

	"github.com/forbole/bdjuno/v5/database"

	"sort"

	tmctypes "github.com/cometbft/cometbft/rpc/core/types"

	feegranttypes "github.com/cosmos/cosmos-sdk/x/feegrant"
	"github.com/rs/zerolog/log"
)

// allowanceCmd returns the Cobra command allowing to fix all things related to fee grant allowance
func allowanceCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "allowance",
		Short: "Fix granted and revoked allowances to the latest height",
		RunE: func(cmd *cobra.Command, args []string) error {
			parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parseConfig)
			if err != nil {
				return err
			}

			// Get the database
			db := database.Cast(parseCtx.Database)

			// Build feegrant module
			feegrantModule := feegrant.NewModule(parseCtx.EncodingConfig.Codec, db)

			// Get the accounts
			// Collect all the transactions
			var txs []*tmctypes.ResultTx

			// Get all the MsgGrantAllowance txs
			query := fmt.Sprintf("message.action='%s'", feegranttypes.EventTypeSetFeeGrant)
			grantAllowanceTxs, err := utils.QueryTxs(parseCtx.Node, query)
			if err != nil {
				return err
			}
			txs = append(txs, grantAllowanceTxs...)

			// Get all the MsgRevokeAllowance txs
			query = fmt.Sprintf("message.action='%s'", feegranttypes.EventTypeRevokeFeeGrant)
			revokeAllowanceTxs, err := utils.QueryTxs(parseCtx.Node, query)
			if err != nil {
				return err
			}
			txs = append(txs, revokeAllowanceTxs...)

			// Sort the txs based on their ascending height
			sort.Slice(txs, func(i, j int) bool {
				return txs[i].Height < txs[j].Height
			})

			for _, tx := range txs {
				log.Debug().Int64("height", tx.Height).Msg("parsing transaction")
				transaction, err := parseCtx.Node.Tx(hex.EncodeToString(tx.Tx.Hash()))
				if err != nil {
					return err
				}

				// Handle only the MsgGrantAllowance and MsgRevokeAllowance instances
				for index, msg := range transaction.GetMsgs() {
					_, isMsgGrantAllowance := msg.(*feegranttypes.MsgGrantAllowance)
					_, isMsgRevokeAllowance := msg.(*feegranttypes.MsgRevokeAllowance)

					if !isMsgGrantAllowance && !isMsgRevokeAllowance {
						continue
					}

					err = feegrantModule.HandleMsg(index, msg, transaction)
					if err != nil {
						return fmt.Errorf("error while handling feegrant module message: %s", err)
					}
				}
			}

			return nil
		},
	}
}

'''
'''--- cmd/parse/feegrant/cmd.go ---
package feegrant

import (
	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/spf13/cobra"
)

// NewFeegrantCmd returns the Cobra command that allows to fix all the things related to the x/feegrant module
func NewFeegrantCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "feegrant",
		Short: "Fix things related to the x/feegrant module",
	}

	cmd.AddCommand(
		allowanceCmd(parseConfig),
	)

	return cmd
}

'''
'''--- cmd/parse/gov/cmd.go ---
package gov

import (
	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/spf13/cobra"
)

// NewGovCmd returns the Cobra command allowing to fix various things related to the x/gov module
func NewGovCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "gov",
		Short: "Fix things related to the x/gov module",
	}

	cmd.AddCommand(
		proposalCmd(parseConfig),
	)

	return cmd
}

'''
'''--- cmd/parse/gov/proposal.go ---
package gov

import (
	"encoding/hex"
	"fmt"
	"strconv"
	"time"

	modulestypes "github.com/forbole/bdjuno/v5/modules/types"
	"github.com/rs/zerolog/log"

	govtypesv1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1"
	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"
	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules/distribution"
	"github.com/forbole/bdjuno/v5/modules/gov"
	"github.com/forbole/bdjuno/v5/modules/mint"
	"github.com/forbole/bdjuno/v5/modules/slashing"
	"github.com/forbole/bdjuno/v5/modules/staking"
	"github.com/forbole/bdjuno/v5/utils"
	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/forbole/juno/v5/parser"
	"github.com/forbole/juno/v5/types/config"
	"github.com/spf13/cobra"
)

// proposalCmd returns the Cobra command allowing to fix all things related to a proposal
func proposalCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "proposal [id]",
		Short: "Get the description, votes and everything related to a proposal given its id",
		RunE: func(cmd *cobra.Command, args []string) error {
			proposalID, err := strconv.ParseUint(args[0], 10, 64)
			if err != nil {
				return err
			}

			parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parseConfig)
			if err != nil {
				return err
			}

			sources, err := modulestypes.BuildSources(config.Cfg.Node, parseCtx.EncodingConfig)
			if err != nil {
				return err
			}

			// Get the database
			db := database.Cast(parseCtx.Database)

			// Build expected modules of gov modules for handleParamChangeProposal
			distrModule := distribution.NewModule(sources.DistrSource, parseCtx.EncodingConfig.Codec, db)
			mintModule := mint.NewModule(sources.MintSource, parseCtx.EncodingConfig.Codec, db)
			slashingModule := slashing.NewModule(sources.SlashingSource, parseCtx.EncodingConfig.Codec, db)
			stakingModule := staking.NewModule(sources.StakingSource, parseCtx.EncodingConfig.Codec, db)

			// Build the gov module
			govModule := gov.NewModule(sources.GovSource, nil, distrModule, mintModule, slashingModule, stakingModule, parseCtx.EncodingConfig.Codec, db)

			err = refreshProposalDetails(parseCtx, proposalID, govModule)
			if err != nil {
				return err
			}

			err = refreshProposalDeposits(parseCtx, proposalID, govModule)
			if err != nil {
				return err
			}

			err = refreshProposalVotes(parseCtx, proposalID, govModule)
			if err != nil {
				return err
			}

			// Update the proposal to the latest status
			height, err := parseCtx.Node.LatestHeight()
			if err != nil {
				return fmt.Errorf("error while getting chain latest block height: %s", err)
			}

			err = govModule.UpdateProposal(height, time.Now(), proposalID)
			if err != nil {
				return err
			}

			return nil
		},
	}
}

func refreshProposalDetails(parseCtx *parser.Context, proposalID uint64, govModule *gov.Module) error {
	log.Debug().Msg("refreshing proposal details")

	// Get the tx that created the proposal
	txs, err := utils.QueryTxs(parseCtx.Node, fmt.Sprintf("submit_proposal.proposal_id=%d", proposalID))
	if err != nil {
		return err
	}

	if len(txs) > 1 {
		return fmt.Errorf("expecting only one create proposal transaction, found %d", len(txs))
	}

	if len(txs) == 0 {
		fmt.Printf("error: couldn't find submit proposal tx info")
		return nil
	}

	// Get the tx details
	tx, err := parseCtx.Node.Tx(hex.EncodeToString(txs[0].Tx.Hash()))
	if err != nil {
		return err
	}

	// Handle the MsgSubmitProposal messages
	for index, msg := range tx.GetMsgs() {
		if _, ok := msg.(*govtypesv1beta1.MsgSubmitProposal); !ok {
			continue
		}

		err = govModule.HandleMsg(index, msg, tx)
		if err != nil {
			return fmt.Errorf("error while handling MsgSubmitProposal: %s", err)
		}
	}

	return nil
}

func refreshProposalDeposits(parseCtx *parser.Context, proposalID uint64, govModule *gov.Module) error {
	log.Debug().Msg("refreshing proposal deposits")

	// Get the tx that deposited to the proposal
	txs, err := utils.QueryTxs(parseCtx.Node, fmt.Sprintf("proposal_deposit.proposal_id=%d", proposalID))
	if err != nil {
		return err
	}

	for _, tx := range txs {
		// Get the tx details
		junoTx, err := parseCtx.Node.Tx(hex.EncodeToString(tx.Tx.Hash()))
		if err != nil {
			return err
		}

		// Handle the MsgDeposit messages
		for index, msg := range junoTx.GetMsgs() {
			if _, ok := msg.(*govtypesv1.MsgDeposit); !ok {
				continue
			}

			err = govModule.HandleMsg(index, msg, junoTx)
			if err != nil {
				return fmt.Errorf("error while handling MsgDeposit: %s", err)
			}
		}
	}

	return nil
}

func refreshProposalVotes(parseCtx *parser.Context, proposalID uint64, govModule *gov.Module) error {
	log.Debug().Msg("refreshing proposal votes")

	// Get the tx that voted the proposal
	txs, err := utils.QueryTxs(parseCtx.Node, fmt.Sprintf("proposal_vote.proposal_id=%d", proposalID))
	if err != nil {
		return err
	}

	for _, tx := range txs {
		// Get the tx details
		junoTx, err := parseCtx.Node.Tx(hex.EncodeToString(tx.Tx.Hash()))
		if err != nil {
			return err
		}

		// Handle the MsgVote messages
		for index, msg := range junoTx.GetMsgs() {
			if _, ok := msg.(*govtypesv1.MsgVote); !ok {
				continue
			}

			err = govModule.HandleMsg(index, msg, junoTx)
			if err != nil {
				return fmt.Errorf("error while handling MsgVote: %s", err)
			}
		}
	}

	return nil
}

'''
'''--- cmd/parse/mint/cmd.go ---
package mint

import (
	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/spf13/cobra"
)

// NewMintCmd returns the Cobra command allowing to fix various things related to the x/mint module
func NewMintCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "mint",
		Short: "Fix things related to the x/mint module",
	}

	cmd.AddCommand(
		inflationCmd(parseConfig),
	)

	return cmd
}

'''
'''--- cmd/parse/mint/inflation.go ---
package mint

import (
	"fmt"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/forbole/juno/v5/types/config"
	"github.com/spf13/cobra"

	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules/mint"
	modulestypes "github.com/forbole/bdjuno/v5/modules/types"
)

// inflationCmd returns the Cobra command allowing to refresh x/mint inflation
func inflationCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "inflation",
		Short: "Refresh inflation",
		RunE: func(cmd *cobra.Command, args []string) error {
			parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parseConfig)
			if err != nil {
				return err
			}

			sources, err := modulestypes.BuildSources(config.Cfg.Node, parseCtx.EncodingConfig)
			if err != nil {
				return err
			}

			// Get the database
			db := database.Cast(parseCtx.Database)

			// Build mint module
			mintModule := mint.NewModule(sources.MintSource, parseCtx.EncodingConfig.Codec, db)

			err = mintModule.UpdateInflation()
			if err != nil {
				return fmt.Errorf("error while updating inflation: %s", err)
			}

			return nil
		},
	}
}

'''
'''--- cmd/parse/parse.go ---
package parse

import (
	parse "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/spf13/cobra"

	parseblocks "github.com/forbole/juno/v5/cmd/parse/blocks"

	parsegenesis "github.com/forbole/juno/v5/cmd/parse/genesis"

	parseauth "github.com/forbole/bdjuno/v5/cmd/parse/auth"
	parsebank "github.com/forbole/bdjuno/v5/cmd/parse/bank"
	parsedistribution "github.com/forbole/bdjuno/v5/cmd/parse/distribution"
	parsefeegrant "github.com/forbole/bdjuno/v5/cmd/parse/feegrant"
	parsegov "github.com/forbole/bdjuno/v5/cmd/parse/gov"
	parsemint "github.com/forbole/bdjuno/v5/cmd/parse/mint"
	parsepricefeed "github.com/forbole/bdjuno/v5/cmd/parse/pricefeed"
	parsestaking "github.com/forbole/bdjuno/v5/cmd/parse/staking"
	parsetransaction "github.com/forbole/juno/v5/cmd/parse/transactions"
)

// NewParseCmd returns the Cobra command allowing to parse some chain data without having to re-sync the whole database
func NewParseCmd(parseCfg *parse.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:               "parse",
		Short:             "Parse some data without the need to re-syncing the whole database from scratch",
		PersistentPreRunE: runPersistentPreRuns(parse.ReadConfigPreRunE(parseCfg)),
	}

	cmd.AddCommand(
		parseauth.NewAuthCmd(parseCfg),
		parsebank.NewBankCmd(parseCfg),
		parseblocks.NewBlocksCmd(parseCfg),
		parsedistribution.NewDistributionCmd(parseCfg),
		parsefeegrant.NewFeegrantCmd(parseCfg),
		parsegenesis.NewGenesisCmd(parseCfg),
		parsegov.NewGovCmd(parseCfg),
		parsemint.NewMintCmd(parseCfg),
		parsepricefeed.NewPricefeedCmd(parseCfg),
		parsestaking.NewStakingCmd(parseCfg),
		parsetransaction.NewTransactionsCmd(parseCfg),
	)

	return cmd
}

func runPersistentPreRuns(preRun func(_ *cobra.Command, _ []string) error) func(_ *cobra.Command, _ []string) error {
	return func(cmd *cobra.Command, args []string) error {
		if root := cmd.Root(); root != nil {
			if root.PersistentPreRunE != nil {
				err := root.PersistentPreRunE(root, args)
				if err != nil {
					return err
				}
			}
		}

		return preRun(cmd, args)
	}
}

'''
'''--- cmd/parse/pricefeed/cmd.go ---
package pricefeed

import (
	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/spf13/cobra"
)

// NewPricefeedCmd returns the Cobra command allowing to refresh pricefeed
func NewPricefeedCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "pricefeed",
		Short: "Fix things related to the pricefeed module",
	}

	cmd.AddCommand(
		priceCmd(parseConfig),
		priceHistoryCmd(parseConfig),
	)

	return cmd
}

'''
'''--- cmd/parse/pricefeed/price.go ---
package pricefeed

import (
	"fmt"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/forbole/juno/v5/types/config"
	"github.com/spf13/cobra"

	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules/pricefeed"
)

// priceCmd returns the Cobra command allowing to refresh token price
func priceCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "price",
		Short: "Refresh token price",
		RunE: func(cmd *cobra.Command, args []string) error {
			parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parseConfig)
			if err != nil {
				return err
			}

			// Get the database
			db := database.Cast(parseCtx.Database)

			// Build pricefeed module
			pricefeedModule := pricefeed.NewModule(config.Cfg, parseCtx.EncodingConfig.Codec, db)

			err = pricefeedModule.RunAdditionalOperations()
			if err != nil {
				return fmt.Errorf("error while storing tokens: %s", err)
			}

			err = pricefeedModule.UpdatePrice()
			if err != nil {
				return fmt.Errorf("error while updating price: %s", err)
			}

			return nil
		},
	}
}

'''
'''--- cmd/parse/pricefeed/pricehistory.go ---
package pricefeed

import (
	"fmt"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/forbole/juno/v5/types/config"
	"github.com/spf13/cobra"

	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules/pricefeed"
)

// priceHistoryCmd returns the Cobra command allowing to store token price history
func priceHistoryCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "history",
		Short: "Store token price history",
		RunE: func(cmd *cobra.Command, args []string) error {
			parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parseConfig)
			if err != nil {
				return err
			}

			// Get the database
			db := database.Cast(parseCtx.Database)

			// Build pricefeed module
			pricefeedModule := pricefeed.NewModule(config.Cfg, parseCtx.EncodingConfig.Codec, db)

			err = pricefeedModule.RunAdditionalOperations()
			if err != nil {
				return fmt.Errorf("error while storing tokens: %s", err)
			}

			err = pricefeedModule.UpdatePricesHistory()
			if err != nil {
				return fmt.Errorf("error while updating price history: %s", err)
			}

			return nil
		},
	}
}

'''
'''--- cmd/parse/staking/cmd.go ---
package staking

import (
	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/spf13/cobra"
)

// NewStakingCmd returns the Cobra command that allows to fix all the things related to the x/staking module
func NewStakingCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	cmd := &cobra.Command{
		Use:   "staking",
		Short: "Fix things related to the x/staking module",
	}

	cmd.AddCommand(
		poolCmd(parseConfig),
		validatorsCmd(parseConfig),
	)

	return cmd
}

'''
'''--- cmd/parse/staking/staking.go ---
package staking

import (
	"fmt"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/forbole/juno/v5/types/config"
	"github.com/spf13/cobra"

	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules/staking"
	modulestypes "github.com/forbole/bdjuno/v5/modules/types"
)

// poolCmd returns the Cobra command allowing to refresh x/staking pool
func poolCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "pool",
		Short: "Refresh staking pool",
		RunE: func(cmd *cobra.Command, args []string) error {
			parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parseConfig)
			if err != nil {
				return err
			}

			sources, err := modulestypes.BuildSources(config.Cfg.Node, parseCtx.EncodingConfig)
			if err != nil {
				return err
			}

			// Get the database
			db := database.Cast(parseCtx.Database)

			// Build staking module
			stakingModule := staking.NewModule(sources.StakingSource, parseCtx.EncodingConfig.Codec, db)

			err = stakingModule.UpdateStakingPool()
			if err != nil {
				return fmt.Errorf("error while updating staking pool: %s", err)
			}

			return nil
		},
	}
}

'''
'''--- cmd/parse/staking/validators.go ---
package staking

import (
	"fmt"

	modulestypes "github.com/forbole/bdjuno/v5/modules/types"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
	"github.com/forbole/juno/v5/types/config"
	"github.com/spf13/cobra"

	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules/staking"
)

// validatorsCmd returns a Cobra command that allows to fix the validator infos for all validators.
func validatorsCmd(parseConfig *parsecmdtypes.Config) *cobra.Command {
	return &cobra.Command{
		Use:   "validators",
		Short: "Fix the information about validators taking them from the latest known height",
		RunE: func(cmd *cobra.Command, args []string) error {
			parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parseConfig)
			if err != nil {
				return err
			}

			sources, err := modulestypes.BuildSources(config.Cfg.Node, parseCtx.EncodingConfig)
			if err != nil {
				return err
			}

			// Get the database
			db := database.Cast(parseCtx.Database)

			// Build the staking module
			stakingModule := staking.NewModule(sources.StakingSource, parseCtx.EncodingConfig.Codec, db)

			// Get latest height
			height, err := parseCtx.Node.LatestHeight()
			if err != nil {
				return fmt.Errorf("error while getting latest block height: %s", err)
			}

			err = stakingModule.RefreshAllValidatorInfos(height)
			if err != nil {
				return fmt.Errorf("error while refreshing all validators infos: %s", err)
			}

			return nil
		},
	}
}

'''
'''--- database/auth.go ---
package database

import (
	"fmt"
	"time"

	"github.com/cosmos/cosmos-sdk/x/auth/vesting/exported"
	vestingtypes "github.com/cosmos/cosmos-sdk/x/auth/vesting/types"
	"github.com/cosmos/gogoproto/proto"
	"github.com/lib/pq"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
	dbutils "github.com/forbole/bdjuno/v5/database/utils"

	"github.com/forbole/bdjuno/v5/types"
)

// SaveAccounts saves the given accounts inside the database
func (db *Db) SaveAccounts(accounts []types.Account) error {
	paramsNumber := 1
	slices := dbutils.SplitAccounts(accounts, paramsNumber)

	for _, accounts := range slices {
		if len(accounts) == 0 {
			continue
		}

		// Store up-to-date data
		err := db.saveAccounts(paramsNumber, accounts)
		if err != nil {
			return fmt.Errorf("error while storing accounts: %s", err)
		}
	}

	return nil
}

func (db *Db) saveAccounts(paramsNumber int, accounts []types.Account) error {
	if len(accounts) == 0 {
		return nil
	}

	stmt := `INSERT INTO account (address) VALUES `
	var params []interface{}

	for i, account := range accounts {
		ai := i * paramsNumber
		stmt += fmt.Sprintf("($%d),", ai+1)
		params = append(params, account.Address)
	}

	stmt = stmt[:len(stmt)-1]
	stmt += " ON CONFLICT DO NOTHING"
	_, err := db.SQL.Exec(stmt, params...)
	if err != nil {
		return fmt.Errorf("error while storing accounts: %s", err)
	}

	return nil
}

// SaveVestingAccounts saves the given vesting accounts inside the database
func (db *Db) SaveVestingAccounts(vestingAccounts []exported.VestingAccount) error {
	if len(vestingAccounts) == 0 {
		return nil
	}

	for _, account := range vestingAccounts {
		switch vestingAccount := account.(type) {
		case *vestingtypes.ContinuousVestingAccount, *vestingtypes.DelayedVestingAccount:
			_, err := db.storeVestingAccount(account)
			if err != nil {
				return err
			}

		case *vestingtypes.PeriodicVestingAccount:
			vestingAccountRowID, err := db.storeVestingAccount(account)
			if err != nil {
				return err
			}
			err = db.storeVestingPeriods(vestingAccountRowID, vestingAccount.VestingPeriods)
			if err != nil {
				return err
			}
		}
	}

	return nil
}

func (db *Db) storeVestingAccount(account exported.VestingAccount) (int, error) {
	stmt := `
	INSERT INTO vesting_account (type, address, original_vesting, end_time, start_time) 
	VALUES ($1, $2, $3, $4, $5)
	ON CONFLICT (address) DO UPDATE 
		SET original_vesting = excluded.original_vesting, 
			end_time = excluded.end_time, 
			start_time = excluded.start_time
			RETURNING id `

	var vestingAccountRowID int
	err := db.SQL.QueryRow(stmt,
		proto.MessageName(account),
		account.GetAddress().String(),
		pq.Array(dbtypes.NewDbCoins(account.GetOriginalVesting())),
		time.Unix(account.GetEndTime(), 0),
		time.Unix(account.GetStartTime(), 0),
	).Scan(&vestingAccountRowID)

	if err != nil {
		return vestingAccountRowID, fmt.Errorf("error while saving Vesting Account of type %v: %s", proto.MessageName(account), err)
	}

	return vestingAccountRowID, nil
}

func (db *Db) StoreBaseVestingAccountFromMsg(bva *vestingtypes.BaseVestingAccount, txTimestamp time.Time) error {
	stmt := `
	INSERT INTO vesting_account (type, address, original_vesting, start_time, end_time) 
	VALUES ($1, $2, $3, $4, $5)
	ON CONFLICT (address) DO UPDATE 
		SET type = excluded.type,
			original_vesting = excluded.original_vesting, 
			start_time = excluded.start_time, 
			end_time = excluded.end_time`

	_, err := db.SQL.Exec(stmt,
		proto.MessageName(bva),
		bva.GetAddress().String(),
		pq.Array(dbtypes.NewDbCoins(bva.OriginalVesting)),
		txTimestamp,
		time.Unix(bva.EndTime, 0))
	if err != nil {
		return fmt.Errorf("error while storing vesting account: %s", err)
	}
	return nil
}

// storeVestingPeriods handles storing the vesting periods of PeriodicVestingAccount type
func (db *Db) storeVestingPeriods(id int, vestingPeriods []vestingtypes.Period) error {
	// Delete already existing periods
	stmt := `DELETE FROM vesting_period WHERE vesting_account_id = $1`
	_, err := db.SQL.Exec(stmt, id)
	if err != nil {
		return fmt.Errorf("error while deleting vesting period: %s", err)
	}

	// Store the new periods
	stmt = `
INSERT INTO vesting_period (vesting_account_id, period_order, length, amount) 
VALUES `

	var params []interface{}
	for i, period := range vestingPeriods {
		ai := i * 4
		stmt += fmt.Sprintf("($%d,$%d,$%d,$%d),", ai+1, ai+2, ai+3, ai+4)

		order := i
		amount := pq.Array(dbtypes.NewDbCoins(period.Amount))
		params = append(params, id, order, period.Length, amount)
	}
	stmt = stmt[:len(stmt)-1]

	_, err = db.SQL.Exec(stmt, params...)
	if err != nil {
		return fmt.Errorf("error while saving vesting periods: %s", err)
	}

	return nil
}

// GetAccounts returns all the accounts that are currently stored inside the database.
func (db *Db) GetAccounts() ([]string, error) {
	var rows []string
	err := db.Sqlx.Select(&rows, `SELECT address FROM account`)
	return rows, err
}

'''
'''--- database/auth_test.go ---
package database_test

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	authttypes "github.com/cosmos/cosmos-sdk/x/auth/types"

	"github.com/forbole/bdjuno/v5/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
)

func (suite *DbTestSuite) TestSaveAccount() {
	address, err := sdk.AccAddressFromBech32("cosmos140xsjjg6pwkjp0xjz8zru7ytha60l5aee9nlf7")
	suite.Require().NoError(err)

	account := authttypes.NewBaseAccountWithAddress(address)

	// ------------------------------
	// --- Save the data
	// ------------------------------

	err = suite.database.SaveAccounts([]types.Account{types.NewAccount(account.Address)})
	suite.Require().NoError(err)

	err = suite.database.SaveAccounts([]types.Account{types.NewAccount(account.Address)})
	suite.Require().NoError(err, "double account insertion should not insert and returns no error")

	// ------------------------------
	// --- Verify the data
	// ------------------------------

	// Accounts row
	var accountRows []dbtypes.AccountRow
	err = suite.database.Sqlx.Select(&accountRows, `SELECT * FROM account`)
	suite.Require().NoError(err)
	suite.Require().Len(accountRows, 1, "account table should contain only one row")

	expectedAccountRow := dbtypes.NewAccountRow("cosmos140xsjjg6pwkjp0xjz8zru7ytha60l5aee9nlf7")
	suite.Require().True(expectedAccountRow.Equal(accountRows[0]))
}

func (suite *DbTestSuite) TestBigDipperDb_GetAccounts() {
	// Insert the data
	queries := []string{
		`INSERT INTO account (address) VALUES ('cosmos1ltzt0z992ke6qgmtjxtygwzn36km4cy6cqdknt')`,
		`INSERT INTO account (address) VALUES ('cosmos1re6zjpyczs0w7flrl6uacl0r4teqtyg62crjsn')`,
		`INSERT INTO account (address) VALUES ('cosmos1eg47ue0l85lzkfgc4leske6hcah8cz3qajpjy2')`,
		`INSERT INTO account (address) VALUES ('cosmos1495ghynrns8sxfnw8mj887pgh0c9z6c4lqkzme')`,
		`INSERT INTO account (address) VALUES ('cosmos18fzr6adp3gjw43xu62vfhg248lepfwpf0pj2dm')`,
	}

	for _, query := range queries {
		_, err := suite.database.SQL.Exec(query)
		suite.Require().NoError(err)
	}

	// Get the data
	accounts, err := suite.database.GetAccounts()
	suite.Require().NoError(err)

	// Verify the get
	expectedAccs := []string{
		"cosmos1ltzt0z992ke6qgmtjxtygwzn36km4cy6cqdknt",
		"cosmos1re6zjpyczs0w7flrl6uacl0r4teqtyg62crjsn",
		"cosmos1eg47ue0l85lzkfgc4leske6hcah8cz3qajpjy2",
		"cosmos1495ghynrns8sxfnw8mj887pgh0c9z6c4lqkzme",
		"cosmos18fzr6adp3gjw43xu62vfhg248lepfwpf0pj2dm",
	}

	for index, acc := range expectedAccs {
		suite.Require().Equal(acc, accounts[index])
	}
}

'''
'''--- database/bank.go ---
package database

import (
	"fmt"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/lib/pq"
)

// SaveSupply allows to save for the given height the given total amount of coins
func (db *Db) SaveSupply(coins sdk.Coins, height int64) error {
	query := `
INSERT INTO supply (coins, height) 
VALUES ($1, $2) 
ON CONFLICT (one_row_id) DO UPDATE 
    SET coins = excluded.coins,
    	height = excluded.height
WHERE supply.height <= excluded.height`

	_, err := db.SQL.Exec(query, pq.Array(dbtypes.NewDbCoins(coins)), height)
	if err != nil {
		return fmt.Errorf("error while storing supply: %s", err)
	}

	return nil
}

'''
'''--- database/bank_test.go ---
package database_test

import (
	sdk "github.com/cosmos/cosmos-sdk/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"

	bddbtypes "github.com/forbole/bdjuno/v5/database/types"
)

func (suite *DbTestSuite) TestBigDipperDb_SaveSupply() {
	// Save the data
	original := sdk.NewCoins(
		sdk.NewCoin("desmos", sdk.NewInt(10000)),
		sdk.NewCoin("uatom", sdk.NewInt(15)),
	)
	err := suite.database.SaveSupply(original, 10)
	suite.Require().NoError(err)

	// Verify the data
	expected := bddbtypes.NewSupplyRow(dbtypes.NewDbCoins(original), 10)

	var rows []bddbtypes.SupplyRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM supply`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "supply table should contain only one row")
	suite.Require().True(expected.Equals(rows[0]))

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with a lower height
	coins := sdk.NewCoins(
		sdk.NewCoin("desmos", sdk.NewInt(10000)),
		sdk.NewCoin("uatom", sdk.NewInt(15)),
	)
	err = suite.database.SaveSupply(coins, 9)
	suite.Require().NoError(err)

	// Verify the data
	rows = []bddbtypes.SupplyRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM supply`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "supply table should contain only one row")
	suite.Require().True(expected.Equals(rows[0]))

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with same height
	coins = sdk.NewCoins(sdk.NewCoin("uakash", sdk.NewInt(10)))
	err = suite.database.SaveSupply(coins, 10)
	suite.Require().NoError(err)

	// Verify the data
	expected = bddbtypes.NewSupplyRow(dbtypes.NewDbCoins(coins), 10)

	rows = []bddbtypes.SupplyRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM supply`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "supply table should contain only one row")
	suite.Require().True(expected.Equals(rows[0]))

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with higher height
	coins = sdk.NewCoins(sdk.NewCoin("btc", sdk.NewInt(10)))
	err = suite.database.SaveSupply(coins, 20)
	suite.Require().NoError(err)

	// Verify the data
	expected = bddbtypes.NewSupplyRow(dbtypes.NewDbCoins(coins), 20)

	rows = []bddbtypes.SupplyRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM supply`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "supply table should contain only one row")
	suite.Require().True(expected.Equals(rows[0]))
}

'''
'''--- database/consensus.go ---
package database

import (
	"fmt"
	"time"

	"github.com/forbole/bdjuno/v5/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
)

// GetLastBlock returns the last block stored inside the database based on the heights
func (db *Db) GetLastBlock() (*dbtypes.BlockRow, error) {
	stmt := `SELECT * FROM block ORDER BY height DESC LIMIT 1`

	var blocks []dbtypes.BlockRow
	if err := db.Sqlx.Select(&blocks, stmt); err != nil {
		return nil, err
	}

	if len(blocks) == 0 {
		return nil, fmt.Errorf("cannot get block, no blocks saved")
	}

	return &blocks[0], nil
}

// GetLastBlockHeight returns the last block height stored inside the database
func (db *Db) GetLastBlockHeight() (int64, error) {
	stmt := `SELECT height FROM block ORDER BY height DESC LIMIT 1`

	var heights []int64
	if err := db.Sqlx.Select(&heights, stmt); err != nil {
		return 0, err
	}

	if len(heights) == 0 {
		return 0, nil
	}

	return heights[0], nil
}

// -------------------------------------------------------------------------------------------------------------------

// getBlockHeightTime retrieves the block at the specific time
func (db *Db) getBlockHeightTime(pastTime time.Time) (dbtypes.BlockRow, error) {
	stmt := `SELECT * FROM block WHERE block.timestamp <= $1 ORDER BY block.timestamp DESC LIMIT 1;`

	var val []dbtypes.BlockRow
	if err := db.Sqlx.Select(&val, stmt, pastTime); err != nil {
		return dbtypes.BlockRow{}, err
	}

	if len(val) == 0 {
		return dbtypes.BlockRow{}, fmt.Errorf("cannot get block time, no blocks saved")
	}

	return val[0], nil
}

// GetBlockHeightTimeMinuteAgo return block height and time that a block proposals
// about a minute ago from input date
func (db *Db) GetBlockHeightTimeMinuteAgo(now time.Time) (dbtypes.BlockRow, error) {
	pastTime := now.Add(time.Minute * -1)
	return db.getBlockHeightTime(pastTime)
}

// GetBlockHeightTimeHourAgo return block height and time that a block proposals
// about a hour ago from input date
func (db *Db) GetBlockHeightTimeHourAgo(now time.Time) (dbtypes.BlockRow, error) {
	pastTime := now.Add(time.Hour * -1)
	return db.getBlockHeightTime(pastTime)
}

// GetBlockHeightTimeDayAgo return block height and time that a block proposals
// about a day (24hour) ago from input date
func (db *Db) GetBlockHeightTimeDayAgo(now time.Time) (dbtypes.BlockRow, error) {
	pastTime := now.Add(time.Hour * -24)
	return db.getBlockHeightTime(pastTime)
}

// -------------------------------------------------------------------------------------------------------------------

// SaveAverageBlockTimePerMin save the average block time in average_block_time_per_minute table
func (db *Db) SaveAverageBlockTimePerMin(averageTime float64, height int64) error {
	stmt := `
INSERT INTO average_block_time_per_minute(average_time, height) 
VALUES ($1, $2) 
ON CONFLICT (one_row_id) DO UPDATE 
    SET average_time = excluded.average_time, 
        height = excluded.height
WHERE average_block_time_per_minute.height <= excluded.height`

	_, err := db.Sqlx.Exec(stmt, averageTime, height)
	if err != nil {
		return fmt.Errorf("error while storing average block time per minute: %s", err)
	}

	return nil
}

// SaveAverageBlockTimePerHour save the average block time in average_block_time_per_hour table
func (db *Db) SaveAverageBlockTimePerHour(averageTime float64, height int64) error {
	stmt := `
INSERT INTO average_block_time_per_hour(average_time, height) 
VALUES ($1, $2) 
ON CONFLICT (one_row_id) DO UPDATE 
    SET average_time = excluded.average_time,
        height = excluded.height
WHERE average_block_time_per_hour.height <= excluded.height`

	_, err := db.Sqlx.Exec(stmt, averageTime, height)
	if err != nil {
		return fmt.Errorf("error while storing average block time per hour: %s", err)
	}

	return nil
}

// SaveAverageBlockTimePerDay save the average block time in average_block_time_per_day table
func (db *Db) SaveAverageBlockTimePerDay(averageTime float64, height int64) error {
	stmt := `
INSERT INTO average_block_time_per_day(average_time, height) 
VALUES ($1, $2)
ON CONFLICT (one_row_id) DO UPDATE 
    SET average_time = excluded.average_time,
        height = excluded.height
WHERE average_block_time_per_day.height <= excluded.height`

	_, err := db.Sqlx.Exec(stmt, averageTime, height)
	if err != nil {
		return fmt.Errorf("error while storing average block time per day: %s", err)
	}

	return nil
}

// SaveAverageBlockTimeGenesis save the average block time in average_block_time_from_genesis table
func (db *Db) SaveAverageBlockTimeGenesis(averageTime float64, height int64) error {
	stmt := `
INSERT INTO average_block_time_from_genesis(average_time ,height) 
VALUES ($1, $2) 
ON CONFLICT (one_row_id) DO UPDATE 
    SET average_time = excluded.average_time, 
        height = excluded.height
WHERE average_block_time_from_genesis.height <= excluded.height`

	_, err := db.Sqlx.Exec(stmt, averageTime, height)
	if err != nil {
		return fmt.Errorf("error while storing average block time since genesis: %s", err)
	}

	return nil
}

// -------------------------------------------------------------------------------------------------------------------

// SaveGenesis save the given genesis data
func (db *Db) SaveGenesis(genesis *types.Genesis) error {
	stmt := `
INSERT INTO genesis(time, chain_id, initial_height) 
VALUES ($1, $2, $3) ON CONFLICT (one_row_id) DO UPDATE 
    SET time = excluded.time,
        initial_height = excluded.initial_height,
        chain_id = excluded.chain_id`

	_, err := db.Sqlx.Exec(stmt, genesis.Time, genesis.ChainID, genesis.InitialHeight)
	if err != nil {
		return fmt.Errorf("error while storing genesis: %s", err)
	}

	return nil
}

// GetGenesis returns the genesis information stored inside the database
func (db *Db) GetGenesis() (*types.Genesis, error) {
	var rows []*dbtypes.GenesisRow
	err := db.Sqlx.Select(&rows, `SELECT * FROM genesis;`)
	if err != nil {
		return nil, err
	}

	if len(rows) == 0 {
		return nil, fmt.Errorf("no rows inside the genesis table")
	}

	row := rows[0]
	return types.NewGenesis(row.ChainID, row.Time, row.InitialHeight), nil
}

'''
'''--- database/consensus_test.go ---
package database_test

import (
	time "time"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
	"github.com/forbole/bdjuno/v5/types"
)

func (suite *DbTestSuite) TestSaveConsensus_GetBlockHeightTimeMinuteAgo() {
	timeAgo, err := time.Parse(time.RFC3339, "2020-01-01T15:00:00Z")
	suite.Require().NoError(err)

	var height int64 = 1000

	_, err = suite.database.SQL.Exec(`INSERT INTO validator (consensus_address, consensus_pubkey) 
	VALUES ('desmosvalcons1mxrd5cyjgpx5vfgltrdufq9wq4ynwc799ndrg8', 'cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8')`)
	suite.Require().NoError(err)

	_, err = suite.database.SQL.Exec(`INSERT INTO block(height, hash, num_txs, total_gas, proposer_address, timestamp)
	VALUES ($1, '5EF85F2251F656BA0FBFED9AEFCBC44A9CCBCFD8B96897E74426E07229D2ADE0', '0', '0', 'desmosvalcons1mxrd5cyjgpx5vfgltrdufq9wq4ynwc799ndrg8', $2)`, height, timeAgo)
	suite.Require().NoError(err)

	timeNow := timeAgo.Add(time.Minute)
	result, err := suite.database.GetBlockHeightTimeMinuteAgo(timeNow)
	suite.Require().NoError(err)

	suite.Require().True(result.Timestamp.Equal(timeAgo))
	suite.Require().Equal(height, result.Height)
}

func (suite *DbTestSuite) TestSaveConsensus_GetBlockHeightTimeHourAgo() {
	timeAgo, err := time.Parse(time.RFC3339, "2020-01-01T15:00:00Z")
	suite.Require().NoError(err)

	var height int64 = 1000
	_, err = suite.database.SQL.Exec(`INSERT INTO validator (consensus_address, consensus_pubkey) 
	VALUES ('desmosvalcons1mxrd5cyjgpx5vfgltrdufq9wq4ynwc799ndrg8', 'cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8')`)
	suite.Require().NoError(err)

	_, err = suite.database.SQL.Exec(`INSERT INTO block(height, hash, num_txs, total_gas, proposer_address, timestamp)
	VALUES ($1, '5EF85F2251F656BA0FBFED9AEFCBC44A9CCBCFD8B96897E74426E07229D2ADE0', '0', '0', 'desmosvalcons1mxrd5cyjgpx5vfgltrdufq9wq4ynwc799ndrg8', $2)`, height, timeAgo)
	suite.Require().NoError(err)

	timeNow := timeAgo.Add(time.Hour)
	result, err := suite.database.GetBlockHeightTimeHourAgo(timeNow)
	suite.Require().NoError(err)

	suite.Require().True(result.Timestamp.Equal(timeAgo))
	suite.Require().Equal(height, result.Height)
}

func (suite *DbTestSuite) TestSaveConsensus_GetBlockHeightTimeDayAgo() {
	timeAgo, err := time.Parse(time.RFC3339, "2020-01-01T15:00:00Z")
	suite.Require().NoError(err)

	var height int64 = 1000

	_, err = suite.database.SQL.Exec(`INSERT INTO validator (consensus_address, consensus_pubkey) 
	VALUES ('desmosvalcons1mxrd5cyjgpx5vfgltrdufq9wq4ynwc799ndrg8', 'cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8')`)
	suite.Require().NoError(err)

	_, err = suite.database.SQL.Exec(`INSERT INTO block(height, hash, num_txs, total_gas, proposer_address, timestamp)
	VALUES ($1, '5EF85F2251F656BA0FBFED9AEFCBC44A9CCBCFD8B96897E74426E07229D2ADE0', '0', '0', 'desmosvalcons1mxrd5cyjgpx5vfgltrdufq9wq4ynwc799ndrg8', $2)`, height, timeAgo)
	suite.Require().NoError(err)

	timeNow := timeAgo.Add(time.Hour * 24)
	result, err := suite.database.GetBlockHeightTimeDayAgo(timeNow)
	suite.Require().NoError(err)

	suite.Require().True(result.Timestamp.Equal(timeAgo))
	suite.Require().Equal(height, result.Height)
}

func (suite *DbTestSuite) TestSaveConsensus_SaveAverageBlockTimePerMin() {
	// Save the data
	err := suite.database.SaveAverageBlockTimePerMin(5.05, 10)
	suite.Require().NoError(err)

	original := dbtypes.NewAverageTimeRow(5.05, 10)

	// Verify the data
	var rows []dbtypes.AverageTimeRow
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_minute")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(original))

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with a lower height
	err = suite.database.SaveAverageBlockTimePerMin(6, 9)
	suite.Require().NoError(err)

	// Verify the data
	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_minute")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(original), "updating with a lower height should not change the data")

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with the same height
	err = suite.database.SaveAverageBlockTimePerMin(10, 10)
	suite.Require().NoError(err)

	// Verify the data
	expected := dbtypes.NewAverageTimeRow(10, 10)

	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_minute")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with same height should change the data")

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with a higher height
	err = suite.database.SaveAverageBlockTimePerMin(20, 15)
	suite.Require().NoError(err)

	// Verify the data
	expected = dbtypes.NewAverageTimeRow(20, 15)

	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_minute")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with higher height should change the data")
}

func (suite *DbTestSuite) TestSaveConsensus_SaveAverageBlockTimePerHour() {
	// Save the data
	err := suite.database.SaveAverageBlockTimePerHour(5.05, 10)
	suite.Require().NoError(err)

	original := dbtypes.NewAverageTimeRow(5.05, 10)

	// Verify the data
	var rows []dbtypes.AverageTimeRow
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_hour")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(original))

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with a lower height
	err = suite.database.SaveAverageBlockTimePerHour(6, 9)
	suite.Require().NoError(err)

	// Verify the data
	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_hour")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(original), "updating with a lower height should not change the data")

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with the same height
	err = suite.database.SaveAverageBlockTimePerHour(10, 10)
	suite.Require().NoError(err)

	// Verify the data
	expected := dbtypes.NewAverageTimeRow(10, 10)

	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_hour")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with same height should change the data")

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with a higher height
	err = suite.database.SaveAverageBlockTimePerHour(20, 15)
	suite.Require().NoError(err)

	// Verify the data
	expected = dbtypes.NewAverageTimeRow(20, 15)

	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_hour")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with higher height should change the data")
}

func (suite *DbTestSuite) TestSaveConsensus_SaveAverageBlockTimePerDay() {
	// Save the data
	err := suite.database.SaveAverageBlockTimePerDay(5.05, 10)
	suite.Require().NoError(err)

	original := dbtypes.NewAverageTimeRow(5.05, 10)

	// Verify the data
	var rows []dbtypes.AverageTimeRow
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_day")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(original))

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with a lower height
	err = suite.database.SaveAverageBlockTimePerDay(6, 9)
	suite.Require().NoError(err)

	// Verify the data
	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_day")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(original), "updating with a lower height should not change the data")

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with the same height
	err = suite.database.SaveAverageBlockTimePerDay(10, 10)
	suite.Require().NoError(err)

	// Verify the data
	expected := dbtypes.NewAverageTimeRow(10, 10)

	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_day")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with same height should change the data")

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with a higher height
	err = suite.database.SaveAverageBlockTimePerDay(20, 15)
	suite.Require().NoError(err)

	// Verify the data
	expected = dbtypes.NewAverageTimeRow(20, 15)

	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_per_day")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with higher height should change the data")
}

func (suite *DbTestSuite) TestSaveConsensus_SaveAverageBlockTimeGenesis() {
	// Save the data
	err := suite.database.SaveAverageBlockTimeGenesis(5.05, 10)
	suite.Require().NoError(err)

	original := dbtypes.NewAverageTimeRow(5.05, 10)

	// Verify the data
	var rows []dbtypes.AverageTimeRow
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_from_genesis")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(original))

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with a lower height
	err = suite.database.SaveAverageBlockTimeGenesis(6, 9)
	suite.Require().NoError(err)

	// Verify the data
	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_from_genesis")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(original), "updating with a lower height should not change the data")

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with the same height
	err = suite.database.SaveAverageBlockTimeGenesis(10, 10)
	suite.Require().NoError(err)

	// Verify the data
	expected := dbtypes.NewAverageTimeRow(10, 10)

	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_from_genesis")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with same height should change the data")

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with a higher height
	err = suite.database.SaveAverageBlockTimeGenesis(20, 15)
	suite.Require().NoError(err)

	// Verify the data
	expected = dbtypes.NewAverageTimeRow(20, 15)

	rows = []dbtypes.AverageTimeRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM average_block_time_from_genesis")
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with higher height should change the data")
}

func (suite *DbTestSuite) TestSaveConsensus_SaveGenesisData() {
	err := suite.database.SaveGenesis(types.NewGenesis(
		"testnet-1",
		time.Date(2020, 1, 02, 15, 00, 00, 000, time.UTC),
		0,
	))
	suite.Require().NoError(err)

	// Should have only one row
	err = suite.database.SaveGenesis(types.NewGenesis(
		"testnet-2",
		time.Date(2020, 1, 1, 15, 00, 00, 000, time.UTC),
		0,
	))

	var rows []*dbtypes.GenesisRow
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM genesis")
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(dbtypes.NewGenesisRow(
		"testnet-2",
		time.Date(2020, 1, 1, 15, 00, 00, 000, time.UTC),
		0,
	)))
}

func (suite *DbTestSuite) TestSaveConsensus_GetGenesis() {
	_, err := suite.database.Sqlx.Exec(
		`INSERT INTO genesis(chain_id, time, initial_height) VALUES ($1, $2, $3)`,
		"testnet-1",
		time.Date(2020, 1, 1, 15, 00, 00, 000, time.UTC),
		0,
	)

	genesis, err := suite.database.GetGenesis()
	suite.Require().NoError(err)
	suite.Require().True(genesis.Equal(types.NewGenesis(
		"testnet-1",
		time.Date(2020, 1, 1, 15, 00, 00, 000, time.UTC),
		0,
	)))
}

'''
'''--- database/daily_refetch.go ---
package database

// GetMissingBlocks returns an array of missing blocks from one day ago
func (db *Db) GetMissingBlocks(startHeight, endHeight int64) []int64 {
	var result []int64
	stmt := `SELECT generate_series($1::int,$2::int) EXCEPT SELECT height FROM block ORDER BY 1;`
	err := db.Sqlx.Select(&result, stmt, startHeight, endHeight)
	if err != nil {
		return nil
	}

	if len(result) == 0 {
		return nil
	}

	return result
}

'''
'''--- database/database.go ---
package database

import (
	"fmt"

	db "github.com/forbole/juno/v5/database"
	"github.com/forbole/juno/v5/database/postgresql"
	"github.com/jmoiron/sqlx"
)

var _ db.Database = &Db{}

// Db represents a PostgreSQL database with expanded features.
// so that it can properly store custom BigDipper-related data.
type Db struct {
	*postgresql.Database
	Sqlx *sqlx.DB
}

// Builder allows to create a new Db instance implementing the db.Builder type
func Builder(ctx *db.Context) (db.Database, error) {
	database, err := postgresql.Builder(ctx)
	if err != nil {
		return nil, err
	}

	psqlDb, ok := (database).(*postgresql.Database)
	if !ok {
		return nil, fmt.Errorf("invalid configuration database, must be PostgreSQL")
	}

	return &Db{
		Database: psqlDb,
		Sqlx:     sqlx.NewDb(psqlDb.SQL.DB, "postgresql"),
	}, nil
}

// Cast allows to cast the given db to a Db instance
func Cast(db db.Database) *Db {
	bdDatabase, ok := db.(*Db)
	if !ok {
		panic(fmt.Errorf("given database instance is not a Db"))
	}
	return bdDatabase
}

'''
'''--- database/database_test.go ---
package database_test

import (
	"os"
	"path"
	"path/filepath"
	"regexp"
	"strings"
	"testing"
	"time"

	dbconfig "github.com/forbole/juno/v5/database/config"
	"github.com/forbole/juno/v5/logging"

	junodb "github.com/forbole/juno/v5/database"

	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/types"

	juno "github.com/forbole/juno/v5/types"

	tmversion "github.com/cometbft/cometbft/proto/tendermint/version"
	tmctypes "github.com/cometbft/cometbft/rpc/core/types"
	tmtypes "github.com/cometbft/cometbft/types"
	sdk "github.com/cosmos/cosmos-sdk/types"

	simappparams "cosmossdk.io/simapp/params"
	"github.com/stretchr/testify/suite"

	_ "github.com/proullon/ramsql/driver"
)

func TestDatabaseTestSuite(t *testing.T) {
	suite.Run(t, new(DbTestSuite))
}

type DbTestSuite struct {
	suite.Suite

	database *database.Db
}

func (suite *DbTestSuite) SetupTest() {
	// Create the codec
	codec := simappparams.MakeTestEncodingConfig()

	// Build the database
	dbCfg := dbconfig.NewDatabaseConfig(
		"postgresql://bdjuno:password@localhost:6433/bdjuno?sslmode=disable&search_path=public",
		"",
		"",
		"",
		"",
		-1,
		-1,
		100000,
		100,
	)
	db, err := database.Builder(junodb.NewContext(dbCfg, &codec, logging.DefaultLogger()))
	suite.Require().NoError(err)

	bigDipperDb, ok := (db).(*database.Db)
	suite.Require().True(ok)

	// Delete the public schema
	_, err = bigDipperDb.SQL.Exec(`DROP SCHEMA public CASCADE;`)
	suite.Require().NoError(err)

	// Re-create the schema
	_, err = bigDipperDb.SQL.Exec(`CREATE SCHEMA public;`)
	suite.Require().NoError(err)

	dirPath := path.Join(".", "schema")
	dir, err := os.ReadDir(dirPath)
	suite.Require().NoError(err)

	for _, fileInfo := range dir {
		file, err := os.ReadFile(filepath.Join(dirPath, fileInfo.Name()))
		suite.Require().NoError(err)

		commentsRegExp := regexp.MustCompile(`/\*.*\*/`)
		requests := strings.Split(string(file), ";")
		for _, request := range requests {
			_, err := bigDipperDb.SQL.Exec(commentsRegExp.ReplaceAllString(request, ""))
			suite.Require().NoError(err)
		}
	}

	suite.database = bigDipperDb
}

// getBlock builds, stores and returns a block for the provided height
func (suite *DbTestSuite) getBlock(height int64) *juno.Block {
	validator := suite.getValidator(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
	)

	addr, err := sdk.ConsAddressFromBech32(validator.GetConsAddr())
	suite.Require().NoError(err)

	tmBlock := &tmctypes.ResultBlock{
		BlockID: tmtypes.BlockID{},
		Block: &tmtypes.Block{
			Header: tmtypes.Header{
				Version:            tmversion.Consensus{},
				ChainID:            "",
				Height:             height,
				Time:               time.Now(),
				LastBlockID:        tmtypes.BlockID{},
				LastCommitHash:     nil,
				DataHash:           nil,
				ValidatorsHash:     []byte("hash"),
				NextValidatorsHash: nil,
				ConsensusHash:      nil,
				AppHash:            nil,
				LastResultsHash:    nil,
				EvidenceHash:       nil,
				ProposerAddress:    tmtypes.Address(addr.Bytes()),
			},
			Data:     tmtypes.Data{},
			Evidence: tmtypes.EvidenceData{},
			LastCommit: &tmtypes.Commit{
				Height:     height - 1,
				Round:      1,
				BlockID:    tmtypes.BlockID{},
				Signatures: nil,
			},
		},
	}

	block := juno.NewBlockFromTmBlock(tmBlock, 10000)
	err = suite.database.SaveBlock(block)
	suite.Require().NoError(err)
	return block
}

// getValidator stores inside the database a validator having the given
// consensus address, validator address and validator public key
func (suite *DbTestSuite) getValidator(consAddr, valAddr, pubkey string) types.Validator {
	selfDelegation := suite.getAccount("cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs")

	maxRate := sdk.NewDec(10)
	maxChangeRate := sdk.NewDec(20)

	validator := types.NewValidator(
		consAddr,
		valAddr,
		pubkey,
		selfDelegation.String(),
		&maxChangeRate,
		&maxRate,
		1,
	)
	err := suite.database.SaveValidatorData(validator)
	suite.Require().NoError(err)

	return validator
}

// getAccount saves inside the database an account having the given address
func (suite *DbTestSuite) getAccount(addr string) sdk.AccAddress {
	delegator, err := sdk.AccAddressFromBech32(addr)
	suite.Require().NoError(err)

	_, err = suite.database.SQL.Exec(`INSERT INTO account (address) VALUES ($1) ON CONFLICT DO NOTHING`, delegator.String())
	suite.Require().NoError(err)

	return delegator
}

'''
'''--- database/distribution.go ---
package database

import (
	"encoding/json"
	"fmt"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"

	"github.com/forbole/bdjuno/v5/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/lib/pq"
)

// SaveCommunityPool allows to save for the given height the given total amount of coins
func (db *Db) SaveCommunityPool(coin sdk.DecCoins, height int64) error {
	query := `
INSERT INTO community_pool(coins, height) 
VALUES ($1, $2) 
ON CONFLICT (one_row_id) DO UPDATE 
    SET coins = excluded.coins,
        height = excluded.height
WHERE community_pool.height <= excluded.height`
	_, err := db.SQL.Exec(query, pq.Array(dbtypes.NewDbDecCoins(coin)), height)
	if err != nil {
		return fmt.Errorf("error while storing community pool: %s", err)
	}

	return nil
}

// -------------------------------------------------------------------------------------------------------------------

// SaveDistributionParams allows to store the given distribution parameters inside the database
func (db *Db) SaveDistributionParams(params *types.DistributionParams) error {
	paramsBz, err := json.Marshal(&params.Params)
	if err != nil {
		return fmt.Errorf("error while marshaling params: %s", err)
	}

	stmt := `
INSERT INTO distribution_params (params, height) 
VALUES ($1, $2)
ON CONFLICT (one_row_id) DO UPDATE 
    SET params = excluded.params,
      	height = excluded.height
WHERE distribution_params.height <= excluded.height`
	_, err = db.SQL.Exec(stmt, string(paramsBz), params.Height)
	if err != nil {
		return fmt.Errorf("error while storing distribution params: %s", err)
	}

	return nil
}

'''
'''--- database/distribution_test.go ---
package database_test

import (
	"encoding/json"

	sdk "github.com/cosmos/cosmos-sdk/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"

	"github.com/forbole/bdjuno/v5/types"

	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
	bddbtypes "github.com/forbole/bdjuno/v5/database/types"
)

func (suite *DbTestSuite) TestBigDipperDb_SaveCommunityPool() {
	// Save data
	original := sdk.NewDecCoins(sdk.NewDecCoin("uatom", sdk.NewInt(100)))
	err := suite.database.SaveCommunityPool(original, 10)
	suite.Require().NoError(err)

	// Verify data
	expected := bddbtypes.NewCommunityPoolRow(dbtypes.NewDbDecCoins(original), 10)
	var rows []bddbtypes.CommunityPoolRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM community_pool`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "community_pool table should contain only one row")
	suite.Require().True(expected.Equals(rows[0]))

	// ---------------------------------------------------------------------------------------------------------------

	// Try updating with lower height
	coins := sdk.NewDecCoins(sdk.NewDecCoin("uatom", sdk.NewInt(50)))
	err = suite.database.SaveCommunityPool(coins, 5)
	suite.Require().NoError(err)

	// Verify data
	expected = bddbtypes.NewCommunityPoolRow(dbtypes.NewDbDecCoins(original), 10)
	rows = []bddbtypes.CommunityPoolRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM community_pool`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "community_pool table should contain only one row")
	suite.Require().True(expected.Equals(rows[0]), "updating with lower height should not modify the data")

	// ---------------------------------------------------------------------------------------------------------------

	// Try updating with equal height
	coins = sdk.NewDecCoins(sdk.NewDecCoin("uatom", sdk.NewInt(120)))
	err = suite.database.SaveCommunityPool(coins, 10)
	suite.Require().NoError(err)

	// Verify data
	expected = bddbtypes.NewCommunityPoolRow(dbtypes.NewDbDecCoins(coins), 10)
	rows = []bddbtypes.CommunityPoolRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM community_pool`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "community_pool table should contain only one row")
	suite.Require().True(expected.Equals(rows[0]), "updating with same height should modify the data")

	// ---------------------------------------------------------------------------------------------------------------

	// Try updating with higher height
	coins = sdk.NewDecCoins(sdk.NewDecCoin("uatom", sdk.NewInt(200)))
	err = suite.database.SaveCommunityPool(coins, 11)
	suite.Require().NoError(err)

	// Verify data
	expected = bddbtypes.NewCommunityPoolRow(dbtypes.NewDbDecCoins(coins), 11)
	rows = []bddbtypes.CommunityPoolRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM community_pool`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "community_pool table should contain only one row")
	suite.Require().True(expected.Equals(rows[0]), "updating with higher height should modify the data")
}

func (suite *DbTestSuite) TestBigDipperDb_SaveDistributionParams() {
	distrParams := distrtypes.Params{
		CommunityTax:        sdk.NewDecWithPrec(2, 2),
		BaseProposerReward:  sdk.NewDecWithPrec(1, 2),
		BonusProposerReward: sdk.NewDecWithPrec(4, 2),
		WithdrawAddrEnabled: true,
	}
	err := suite.database.SaveDistributionParams(types.NewDistributionParams(distrParams, 10))
	suite.Require().NoError(err)

	var rows []dbtypes.DistributionParamsRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM distribution_params`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)

	var stored distrtypes.Params
	err = json.Unmarshal([]byte(rows[0].Params), &stored)
	suite.Require().NoError(err)
	suite.Require().Equal(distrParams, stored)
	suite.Require().Equal(int64(10), rows[0].Height)
}

'''
'''--- database/feegrant.go ---
package database

import (
	"fmt"

	"github.com/cosmos/cosmos-sdk/codec"

	"github.com/forbole/bdjuno/v5/types"
)

// SaveFeeGrantAllowance allows to store the fee grant allowances for the given block height
func (db *Db) SaveFeeGrantAllowance(allowance types.FeeGrant) error {
	// Store the accounts
	var accounts []types.Account
	accounts = append(accounts, types.NewAccount(allowance.Granter), types.NewAccount(allowance.Grantee))
	err := db.SaveAccounts(accounts)
	if err != nil {
		return fmt.Errorf("error while storing fee grant allowance accounts: %s", err)
	}

	stmt := `
INSERT INTO fee_grant_allowance(grantee_address, granter_address, allowance, height) 
VALUES ($1, $2, $3, $4) 
ON CONFLICT ON CONSTRAINT unique_fee_grant_allowance DO UPDATE 
    SET allowance = excluded.allowance,
        height = excluded.height
WHERE fee_grant_allowance.height <= excluded.height`

	allowanceJSON, err := codec.ProtoMarshalJSON(allowance.Allowance, nil)
	if err != nil {
		return fmt.Errorf("error while marshaling grant allowance: %s", err)
	}

	_, err = db.SQL.Exec(stmt, allowance.Grantee, allowance.Granter, allowanceJSON, allowance.Height)
	if err != nil {
		return fmt.Errorf("error while saving fee grant allowance: %s", err)
	}

	return nil
}

// DeleteFeeGrantAllowance removes the fee grant allowance data from the database
func (db *Db) DeleteFeeGrantAllowance(allowance types.GrantRemoval) error {
	stmt := `DELETE FROM fee_grant_allowance WHERE grantee_address = $1 AND granter_address = $2 AND height <= $3`
	_, err := db.SQL.Exec(stmt, allowance.Grantee, allowance.Granter, allowance.Height)

	if err != nil {
		return fmt.Errorf("error while deleting grant allowance: %s", err)
	}
	return nil
}

'''
'''--- database/feegrant_test.go ---
package database_test

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	feegranttypes "github.com/cosmos/cosmos-sdk/x/feegrant"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
	"github.com/forbole/bdjuno/v5/types"
)

func (suite *DbTestSuite) TestBigDipperDb_SaveFeeGrantAllowance() {
	allowance := &feegranttypes.BasicAllowance{SpendLimit: nil, Expiration: nil}
	granter, err := sdk.AccAddressFromBech32("cosmos1ltzt0z992ke6qgmtjxtygwzn36km4cy6cqdknt")
	suite.Require().NoError(err)

	grantee, err := sdk.AccAddressFromBech32("cosmos1re6zjpyczs0w7flrl6uacl0r4teqtyg62crjsn")
	suite.Require().NoError(err)

	feeGrant, err := feegranttypes.NewGrant(granter, grantee, allowance)
	suite.Require().NoError(err)

	// Store the allowance
	err = suite.database.SaveFeeGrantAllowance(types.NewFeeGrant(feeGrant, 121622))
	suite.Require().NoError(err)

	// Test double insertion
	err = suite.database.SaveFeeGrantAllowance(types.NewFeeGrant(feeGrant, 121622))
	suite.Require().NoError(err, "storing existing grant allowance should return no error")

	// Verify the data
	var rows []dbtypes.FeeAllowanceRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM fee_grant_allowance`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().Equal(rows[0].Granter, granter.String())
	suite.Require().Equal(rows[0].Grantee, grantee.String())
	suite.Require().Equal(rows[0].Height, int64(121622))

}

func (suite *DbTestSuite) TestBigDipperDb_RemoveFeeGrantAllowance() {
	allowance := &feegranttypes.BasicAllowance{SpendLimit: nil, Expiration: nil}
	granter, err := sdk.AccAddressFromBech32("cosmos1ltzt0z992ke6qgmtjxtygwzn36km4cy6cqdknt")
	suite.Require().NoError(err)

	grantee, err := sdk.AccAddressFromBech32("cosmos1re6zjpyczs0w7flrl6uacl0r4teqtyg62crjsn")
	suite.Require().NoError(err)

	feeGrant, err := feegranttypes.NewGrant(granter, grantee, allowance)
	suite.Require().NoError(err)

	err = suite.database.SaveFeeGrantAllowance(types.NewFeeGrant(feeGrant, 121622))
	suite.Require().NoError(err)

	// Delete the data
	err = suite.database.DeleteFeeGrantAllowance(types.NewGrantRemoval(
		"cosmos1re6zjpyczs0w7flrl6uacl0r4teqtyg62crjsn",
		"cosmos1ltzt0z992ke6qgmtjxtygwzn36km4cy6cqdknt",
		122222,
	))
	suite.Require().NoError(err)

	// verify the data
	var count int
	err = suite.database.SQL.QueryRow(`SELECT COUNT(*) FROM fee_grant_allowance`).Scan(&count)
	suite.Require().NoError(err)
	suite.Require().Equal(0, count)
}

'''
'''--- database/gov.go ---
package database

import (
	"encoding/json"
	"fmt"
	"time"

	"github.com/cosmos/cosmos-sdk/codec"
	codectypes "github.com/cosmos/cosmos-sdk/codec/types"
	govtypesv1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1"
	"github.com/cosmos/gogoproto/proto"

	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"
	upgradetypes "github.com/cosmos/cosmos-sdk/x/upgrade/types"
	dbtypes "github.com/forbole/bdjuno/v5/database/types"
	"github.com/forbole/bdjuno/v5/types"
	"github.com/lib/pq"
)

// SaveGovParams saves the given x/gov parameters inside the database
func (db *Db) SaveGovParams(params *types.GovParams) error {

	depositParamsBz, err := json.Marshal(&params.DepositParams)
	if err != nil {
		return fmt.Errorf("error while marshaling deposit params: %s", err)
	}

	votingParamsBz, err := json.Marshal(&params.VotingParams)
	if err != nil {
		return fmt.Errorf("error while marshaling voting params: %s", err)
	}

	tallyingParams, err := json.Marshal(&params.TallyParams)
	if err != nil {
		return fmt.Errorf("error while marshaling tally params: %s", err)
	}

	stmt := `
INSERT INTO gov_params(deposit_params, voting_params, tally_params, height)
VALUES ($1, $2, $3, $4)
ON CONFLICT (one_row_id) DO UPDATE
	SET deposit_params = excluded.deposit_params,
  		voting_params = excluded.voting_params,
		tally_params = excluded.tally_params,
		height = excluded.height
WHERE gov_params.height <= excluded.height`
	_, err = db.SQL.Exec(stmt, string(depositParamsBz), string(votingParamsBz), string(tallyingParams), params.Height)
	if err != nil {
		return fmt.Errorf("error while storing gov params: %s", err)
	}

	return nil
}

// SaveGenesisGovParams saves the genesis x/gov parameters inside the database
func (db *Db) SaveGenesisGovParams(params *types.GenesisGovParams) error {

	depositParamsBz, err := json.Marshal(&params.DepositParams)
	if err != nil {
		return fmt.Errorf("error while marshaling genesis deposit params: %s", err)
	}

	votingParamsBz, err := json.Marshal(&params.VotingParams)
	if err != nil {
		return fmt.Errorf("error while marshaling genesis voting params: %s", err)
	}

	tallyingParams, err := json.Marshal(&params.TallyParams)
	if err != nil {
		return fmt.Errorf("error while marshaling genesis tally params: %s", err)
	}

	stmt := `
INSERT INTO gov_params(deposit_params, voting_params, tally_params, height)
VALUES ($1, $2, $3, $4)
ON CONFLICT (one_row_id) DO UPDATE
	SET deposit_params = excluded.deposit_params,
  		voting_params = excluded.voting_params,
		tally_params = excluded.tally_params,
		height = excluded.height
WHERE gov_params.height <= excluded.height`
	_, err = db.SQL.Exec(stmt, string(depositParamsBz), string(votingParamsBz), string(tallyingParams), params.Height)
	if err != nil {
		return fmt.Errorf("error while storing genesis gov params: %s", err)
	}

	return nil
}

// GetGovParams returns the most recent governance parameters
func (db *Db) GetGovParams() (*types.GovParams, error) {
	var rows []dbtypes.GovParamsRow
	err := db.Sqlx.Select(&rows, `SELECT * FROM gov_params`)
	if err != nil {
		return nil, err
	}

	if len(rows) == 0 {
		return nil, nil
	}

	row := rows[0]

	var depositParams types.DepositParams
	err = json.Unmarshal([]byte(row.DepositParams), &depositParams)
	if err != nil {
		return nil, err
	}

	var votingParams types.VotingParams
	err = json.Unmarshal([]byte(row.VotingParams), &votingParams)
	if err != nil {
		return nil, err
	}

	var tallyParams types.TallyParams
	err = json.Unmarshal([]byte(row.TallyParams), &tallyParams)
	if err != nil {
		return nil, err
	}

	return types.NewGovParams(
		votingParams, depositParams, tallyParams,
		row.Height,
	), nil
}

// --------------------------------------------------------------------------------------------------------------------

// SaveProposals allows to save for the given height the given total amount of coins
func (db *Db) SaveProposals(proposals []types.Proposal) error {
	if len(proposals) == 0 {
		return nil
	}

	var accounts []types.Account

	proposalsQuery := `
INSERT INTO proposal(
	id, title, description, content, proposer_address, proposal_route, proposal_type, status,
    submit_time, deposit_end_time, voting_start_time, voting_end_time
) VALUES`
	var proposalsParams []interface{}

	for i, proposal := range proposals {
		// Prepare the account query
		accounts = append(accounts, types.NewAccount(proposal.Proposer))

		// Prepare the proposal query
		vi := i * 12
		proposalsQuery += fmt.Sprintf("($%d,$%d,$%d,$%d,$%d,$%d,$%d,$%d,$%d,$%d,$%d,$%d),",
			vi+1, vi+2, vi+3, vi+4, vi+5, vi+6, vi+7, vi+8, vi+9, vi+10, vi+11, vi+12)

		// Encode the content properly
		protoContent, ok := proposal.Content.(proto.Message)
		if !ok {
			return fmt.Errorf("invalid proposal content types: %T", proposal.Content)
		}

		anyContent, err := codectypes.NewAnyWithValue(protoContent)
		if err != nil {
			return fmt.Errorf("error while wrapping proposal proto content: %s", err)
		}

		var protoCodec codec.ProtoCodec
		contentBz, err := protoCodec.MarshalJSON(anyContent)
		if err != nil {
			return fmt.Errorf("error while marshaling proposal content: %s", err)
		}

		proposalsParams = append(proposalsParams,
			proposal.ProposalID,
			proposal.Content.GetTitle(),
			proposal.Content.GetDescription(),
			string(contentBz),
			proposal.Proposer,
			proposal.ProposalRoute,
			proposal.ProposalType,
			proposal.Status,
			proposal.SubmitTime,
			proposal.DepositEndTime,
			proposal.VotingStartTime,
			proposal.VotingEndTime,
		)
	}

	// Store the accounts
	err := db.SaveAccounts(accounts)
	if err != nil {
		return fmt.Errorf("error while storing proposers accounts: %s", err)
	}

	// Store the proposals
	proposalsQuery = proposalsQuery[:len(proposalsQuery)-1] // Remove trailing ","
	proposalsQuery += " ON CONFLICT DO NOTHING"
	_, err = db.SQL.Exec(proposalsQuery, proposalsParams...)
	if err != nil {
		return fmt.Errorf("error while storing proposals: %s", err)
	}

	return nil
}

// GetProposal returns the proposal with the given id, or nil if not found
func (db *Db) GetProposal(id uint64) (types.Proposal, error) {
	var rows []*dbtypes.ProposalRow
	err := db.SQL.Select(&rows, `SELECT * FROM proposal WHERE id = $1`, id)
	if err != nil {
		return types.Proposal{}, err
	}

	if len(rows) == 0 {
		return types.Proposal{}, nil
	}

	row := rows[0]

	var contentAny codectypes.Any
	err = db.Cdc.UnmarshalJSON([]byte(row.Content), &contentAny)
	if err != nil {
		return types.Proposal{}, err
	}

	var content govtypesv1beta1.Content
	err = db.Cdc.UnpackAny(&contentAny, &content)
	if err != nil {
		return types.Proposal{}, err
	}

	proposal := types.NewProposal(
		row.ProposalID,
		row.ProposalRoute,
		row.ProposalType,
		content,
		row.Status,
		row.SubmitTime,
		row.DepositEndTime,
		row.VotingStartTime,
		row.VotingEndTime,
		row.Proposer,
	)
	return proposal, nil
}

// GetOpenProposalsIds returns all the ids of the proposals that are in deposit or voting period at the given block time
func (db *Db) GetOpenProposalsIds(blockTime time.Time) ([]uint64, error) {
	var ids []uint64
	stmt := `SELECT id FROM proposal WHERE status = $1 OR status = $2`
	err := db.Sqlx.Select(&ids, stmt, govtypesv1.StatusDepositPeriod.String(), govtypesv1.StatusVotingPeriod.String())
	if err != nil {
		return ids, err
	}

	// Get also the invalid status proposals due to gRPC failure but still are in deposit period or voting period
	var idsInvalid []uint64
	stmt = `SELECT id FROM proposal WHERE status = $1 AND (voting_end_time > $2 OR deposit_end_time > $2)`
	err = db.Sqlx.Select(&idsInvalid, stmt, types.ProposalStatusInvalid, blockTime)
	ids = append(ids, idsInvalid...)

	return ids, err
}

// --------------------------------------------------------------------------------------------------------------------

// UpdateProposal updates a proposal stored inside the database
func (db *Db) UpdateProposal(update types.ProposalUpdate) error {
	query := `UPDATE proposal SET status = $1, voting_start_time = $2, voting_end_time = $3 where id = $4`
	_, err := db.SQL.Exec(query,
		update.Status,
		update.VotingStartTime,
		update.VotingEndTime,
		update.ProposalID,
	)
	if err != nil {
		return fmt.Errorf("error while updating proposal: %s", err)
	}

	return nil
}

// SaveDeposits allows to save multiple deposits
func (db *Db) SaveDeposits(deposits []types.Deposit) error {
	if len(deposits) == 0 {
		return nil
	}

	query := `INSERT INTO proposal_deposit (proposal_id, depositor_address, amount, timestamp, height) VALUES `
	var param []interface{}
	var accounts []types.Account
	for i, deposit := range deposits {
		vi := i * 5
		query += fmt.Sprintf("($%d,$%d,$%d,$%d,$%d),", vi+1, vi+2, vi+3, vi+4, vi+5)
		param = append(param, deposit.ProposalID,
			deposit.Depositor,
			pq.Array(dbtypes.NewDbCoins(deposit.Amount)),
			deposit.Timestamp,
			deposit.Height,
		)
		accounts = append(accounts, types.NewAccount(deposit.Depositor))
	}

	// Store the depositor account
	err := db.SaveAccounts(accounts)
	if err != nil {
		return fmt.Errorf("error while storing depositor account: %s", err)
	}

	query = query[:len(query)-1] // Remove trailing ","
	query += `
ON CONFLICT ON CONSTRAINT unique_deposit DO UPDATE
	SET amount = excluded.amount,
		timestamp = excluded.timestamp,
		height = excluded.height
WHERE proposal_deposit.height <= excluded.height`
	_, err = db.SQL.Exec(query, param...)
	if err != nil {
		return fmt.Errorf("error while storing deposits: %s", err)
	}

	return nil
}

// --------------------------------------------------------------------------------------------------------------------

// SaveVote allows to save for the given height and the message vote
func (db *Db) SaveVote(vote types.Vote) error {
	query := `
INSERT INTO proposal_vote (proposal_id, voter_address, option, timestamp, height)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT ON CONSTRAINT unique_vote DO UPDATE
	SET option = excluded.option,
		timestamp = excluded.timestamp,
		height = excluded.height
WHERE proposal_vote.height <= excluded.height`

	// Store the voter account
	err := db.SaveAccounts([]types.Account{types.NewAccount(vote.Voter)})
	if err != nil {
		return fmt.Errorf("error while storing voter account: %s", err)
	}

	_, err = db.SQL.Exec(query, vote.ProposalID, vote.Voter, vote.Option.String(), vote.Timestamp, vote.Height)
	if err != nil {
		return fmt.Errorf("error while storing vote: %s", err)
	}

	return nil
}

// SaveTallyResults allows to save for the given height the given total amount of coins
func (db *Db) SaveTallyResults(tallys []types.TallyResult) error {
	if len(tallys) == 0 {
		return nil
	}

	query := `INSERT INTO proposal_tally_result(proposal_id, yes, abstain, no, no_with_veto, height) VALUES`

	var param []interface{}
	for i, tally := range tallys {
		vi := i * 6
		query += fmt.Sprintf("($%d,$%d,$%d,$%d,$%d,$%d),", vi+1, vi+2, vi+3, vi+4, vi+5, vi+6)
		param = append(param, tally.ProposalID,
			tally.Yes,
			tally.Abstain,
			tally.No,
			tally.NoWithVeto,
			tally.Height,
		)
	}

	query = query[:len(query)-1] // Remove trailing ","
	query += `
ON CONFLICT ON CONSTRAINT unique_tally_result DO UPDATE
	SET yes = excluded.yes,
	    abstain = excluded.abstain,
	    no = excluded.no,
	    no_with_veto = excluded.no_with_veto,
	    height = excluded.height
WHERE proposal_tally_result.height <= excluded.height`
	_, err := db.SQL.Exec(query, param...)
	if err != nil {
		return fmt.Errorf("error while storing tally result: %s", err)
	}

	return nil
}

// --------------------------------------------------------------------------------------------------------------------

// SaveProposalStakingPoolSnapshot allows to save the given snapshot of the staking pool
func (db *Db) SaveProposalStakingPoolSnapshot(snapshot types.ProposalStakingPoolSnapshot) error {
	stmt := `
INSERT INTO proposal_staking_pool_snapshot (proposal_id, bonded_tokens, not_bonded_tokens, height)
VALUES ($1, $2, $3, $4)
ON CONFLICT ON CONSTRAINT unique_staking_pool_snapshot DO UPDATE SET
	proposal_id = excluded.proposal_id,
    bonded_tokens = excluded.bonded_tokens,
	not_bonded_tokens = excluded.not_bonded_tokens,
	height = excluded.height
WHERE proposal_staking_pool_snapshot.height <= excluded.height`

	_, err := db.SQL.Exec(stmt,
		snapshot.ProposalID, snapshot.Pool.BondedTokens.String(), snapshot.Pool.NotBondedTokens.String(), snapshot.Pool.Height)
	if err != nil {
		return fmt.Errorf("error while storing proposal staking pool snapshot: %s", err)
	}

	return nil
}

// SaveProposalValidatorsStatusesSnapshots allows to save the given validator statuses snapshots
func (db *Db) SaveProposalValidatorsStatusesSnapshots(snapshots []types.ProposalValidatorStatusSnapshot) error {
	if len(snapshots) == 0 {
		return nil
	}

	stmt := `
INSERT INTO proposal_validator_status_snapshot(proposal_id, validator_address, voting_power, status, jailed, height)
VALUES `

	var args []interface{}
	for i, snapshot := range snapshots {
		si := i * 6

		stmt += fmt.Sprintf("($%d,$%d,$%d,$%d,$%d,$%d),", si+1, si+2, si+3, si+4, si+5, si+6)
		args = append(args,
			snapshot.ProposalID, snapshot.ValidatorConsAddress, snapshot.ValidatorVotingPower,
			snapshot.ValidatorStatus, snapshot.ValidatorJailed, snapshot.Height)
	}

	stmt = stmt[:len(stmt)-1]
	stmt += `
ON CONFLICT ON CONSTRAINT unique_validator_status_snapshot DO UPDATE
	SET proposal_id = excluded.proposal_id,
		validator_address = excluded.validator_address,
		voting_power = excluded.voting_power,
		status = excluded.status,
		jailed = excluded.jailed,
		height = excluded.height
WHERE proposal_validator_status_snapshot.height <= excluded.height`
	_, err := db.SQL.Exec(stmt, args...)
	if err != nil {
		return fmt.Errorf("error while storing proposal validator statuses snapshot: %s", err)
	}

	return nil
}

// SaveSoftwareUpgradePlan allows to save the given software upgrade plan with its proposal id
func (db *Db) SaveSoftwareUpgradePlan(proposalID uint64, plan upgradetypes.Plan, height int64) error {

	stmt := `
INSERT INTO software_upgrade_plan(proposal_id, plan_name, upgrade_height, info, height)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (proposal_id) DO UPDATE SET
	plan_name = excluded.plan_name,
	upgrade_height = excluded.upgrade_height,
	info = excluded.info,
	height = excluded.height
WHERE software_upgrade_plan.height <= excluded.height`

	_, err := db.SQL.Exec(stmt,
		proposalID, plan.Name, plan.Height, plan.Info, height)
	if err != nil {
		return fmt.Errorf("error while storing software upgrade plan: %s", err)
	}

	return nil
}

// DeleteSoftwareUpgradePlan allows to delete a SoftwareUpgradePlan with proposal ID
func (db *Db) DeleteSoftwareUpgradePlan(proposalID uint64) error {
	stmt := `DELETE FROM software_upgrade_plan WHERE proposal_id = $1`

	_, err := db.SQL.Exec(stmt, proposalID)
	if err != nil {
		return fmt.Errorf("error while deleting software upgrade plan: %s", err)
	}

	return nil
}

// CheckSoftwareUpgradePlan returns true if an upgrade is scheduled at the given height
func (db *Db) CheckSoftwareUpgradePlan(upgradeHeight int64) (bool, error) {
	var exist bool

	stmt := `SELECT EXISTS (SELECT 1 FROM software_upgrade_plan WHERE upgrade_height=$1)`
	err := db.SQL.QueryRow(stmt, upgradeHeight).Scan(&exist)
	if err != nil {
		return exist, fmt.Errorf("error while checking software upgrade plan existence: %s", err)
	}

	return exist, nil
}

// TruncateSoftwareUpgradePlan delete software upgrade plans once the upgrade height passed
func (db *Db) TruncateSoftwareUpgradePlan(height int64) error {
	stmt := `DELETE FROM software_upgrade_plan WHERE upgrade_height <= $1`

	_, err := db.SQL.Exec(stmt, height)
	if err != nil {
		return fmt.Errorf("error while deleting software upgrade plan: %s", err)
	}

	return nil
}

'''
'''--- database/gov_test.go ---
package database_test

import (
	"fmt"
	"time"

	"github.com/cosmos/cosmos-sdk/codec"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	upgradetypes "github.com/cosmos/cosmos-sdk/x/upgrade/types"
	"github.com/cosmos/gogoproto/proto"

	codectypes "github.com/cosmos/cosmos-sdk/codec/types"

	"github.com/forbole/bdjuno/v5/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	govtypesv1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1"
	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
)

func (suite *DbTestSuite) TestBigDipperDb_SaveGovParams() {
	votingPeriod := time.Duration(int64(300000))
	maxDepositPeriod := time.Duration(int64(300000000000))
	votingParams := govtypesv1.NewVotingParams(&votingPeriod)
	tallyParams := govtypesv1.NewTallyParams("10", "10", "10")
	depositParams := govtypesv1.NewDepositParams(sdk.NewCoins(sdk.NewCoin("uatom", sdk.NewInt(10))), &maxDepositPeriod)
	original := types.NewGovParams(types.NewVotingParams(&votingParams), types.NewDepositParam(&depositParams), types.NewTallyParams(&tallyParams), 10)

	err := suite.database.SaveGovParams(original)
	suite.Require().NoError(err)

	stored, err := suite.database.GetGovParams()
	suite.Require().NoError(err)
	suite.Require().Equal(original, stored)

	// ----------------------------------------------------------------------------------------------------------------
	// Try updating with a lower height
	depositParams = govtypesv1.NewDepositParams(sdk.NewCoins(sdk.NewCoin("uatom", sdk.NewInt(1000))), &maxDepositPeriod)
	updated := types.NewGovParams(types.NewVotingParams(&votingParams), types.NewDepositParam(&depositParams), types.NewTallyParams(&tallyParams), 9)

	err = suite.database.SaveGovParams(updated)
	suite.Require().NoError(err)

	stored, err = suite.database.GetGovParams()
	suite.Require().NoError(err)
	suite.Require().Equal(original, stored)

	// ----------------------------------------------------------------------------------------------------------------
	// Try updating with the same height	depositParams = govtypesv1.NewDepositParams(sdk.NewCoins(sdk.NewCoin("uatom", sdk.NewInt(1000))), time.Minute*5)
	updated = types.NewGovParams(types.NewVotingParams(&votingParams), types.NewDepositParam(&depositParams), types.NewTallyParams(&tallyParams), 10)

	err = suite.database.SaveGovParams(updated)
	suite.Require().NoError(err)

	stored, err = suite.database.GetGovParams()
	suite.Require().NoError(err)
	suite.Require().Equal(updated, stored)

	// ----------------------------------------------------------------------------------------------------------------
	// Try updating with a higher height
	tallyParams = govtypesv1.NewTallyParams("100", "100", "100")
	depositParams = govtypesv1.NewDepositParams(sdk.NewCoins(sdk.NewCoin("udesmos", sdk.NewInt(10000))), &maxDepositPeriod)
	updated = types.NewGovParams(types.NewVotingParams(&votingParams), types.NewDepositParam(&depositParams), types.NewTallyParams(&tallyParams), 11)

	err = suite.database.SaveGovParams(updated)
	suite.Require().NoError(err)

	stored, err = suite.database.GetGovParams()
	suite.Require().NoError(err)
	suite.Require().Equal(updated, stored)
}

// -------------------------------------------------------------------------------------------------------------------

func (suite *DbTestSuite) getProposalRow(id int) types.Proposal {
	proposer := suite.getAccount("cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs")

	title := fmt.Sprintf("title%d", id)
	description := fmt.Sprintf("description%d", id)
	proposalRoute := fmt.Sprintf("proposalRoute%d", id)
	proposalType := fmt.Sprintf("proposalType%d", id)

	proposal := types.NewProposal(
		uint64(id),
		proposalRoute,
		proposalType,
		govtypesv1beta1.NewTextProposal(title, description),
		govtypesv1.StatusPassed.String(),
		time.Date(2020, 1, 1, 00, 00, 00, 000, time.UTC),
		time.Date(2020, 1, 1, 01, 00, 00, 000, time.UTC),
		time.Date(2020, 1, 1, 02, 00, 00, 000, time.UTC),
		time.Date(2020, 1, 1, 03, 00, 00, 000, time.UTC),
		proposer.String(),
	)

	err := suite.database.SaveProposals([]types.Proposal{proposal})
	suite.Require().NoError(err)

	return proposal
}

func (suite *DbTestSuite) encodeProposalContent(content govtypesv1beta1.Content) string {
	protoContent, ok := content.(proto.Message)
	suite.Require().True(ok)

	anyContent, err := codectypes.NewAnyWithValue(protoContent)
	suite.Require().NoError(err)

	// contentBz, err := suite.database.Cdc.MarshalJSON(anyContent)
	var protoCodec codec.ProtoCodec
	contentBz, err := protoCodec.MarshalJSON(anyContent)
	suite.Require().NoError(err)

	return string(contentBz)
}

func (suite *DbTestSuite) TestBigDipperDb_SaveProposals() {
	proposer1 := suite.getAccount("cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs")
	proposer2 := suite.getAccount("cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a")

	content1 := govtypesv1beta1.NewTextProposal("title", "description")
	content2 := govtypesv1beta1.NewTextProposal("title1", "description1")

	input := []types.Proposal{
		types.NewProposal(
			1,
			"proposalRoute",
			"proposalType",
			content1,
			govtypesv1.StatusDepositPeriod.String(),
			time.Date(2020, 1, 1, 00, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 01, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 02, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 03, 00, 00, 000, time.UTC),
			proposer1.String(),
		),
		types.NewProposal(
			2,
			"proposalRoute1",
			"proposalType1",
			content2,
			govtypesv1.StatusPassed.String(),
			time.Date(2020, 1, 2, 00, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 01, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 02, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 03, 00, 00, 000, time.UTC),
			proposer2.String(),
		),
	}

	err := suite.database.SaveProposals(input)
	suite.Require().NoError(err)

	var proposalRow []dbtypes.ProposalRow
	err = suite.database.Sqlx.Select(&proposalRow, `SELECT * FROM proposal ORDER BY id`)
	suite.Require().NoError(err)

	expected := []dbtypes.ProposalRow{
		dbtypes.NewProposalRow(
			1,
			"proposalRoute",
			"proposalType",
			"title",
			"description",
			suite.encodeProposalContent(content1),
			time.Date(2020, 1, 1, 00, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 01, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 02, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 03, 00, 00, 000, time.UTC),
			proposer1.String(),
			govtypesv1.StatusDepositPeriod.String(),
		),
		dbtypes.NewProposalRow(
			2,
			"proposalRoute1",
			"proposalType1",
			"title1",
			"description1",
			suite.encodeProposalContent(content2),
			time.Date(2020, 1, 2, 00, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 01, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 02, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 03, 00, 00, 000, time.UTC),
			proposer2.String(),
			govtypesv1.StatusPassed.String(),
		),
	}
	for i, expect := range expected {
		suite.Require().True(proposalRow[i].Equals(expect))
	}
}

func (suite *DbTestSuite) TestBigDipperDb_GetProposal() {
	content := govtypesv1beta1.NewTextProposal("title", "description")
	proposer := suite.getAccount("cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs")
	proposal := types.NewProposal(
		1,
		"proposalRoute",
		"proposalType",
		content,
		govtypesv1.StatusDepositPeriod.String(),
		time.Date(2020, 1, 1, 00, 00, 00, 000, time.UTC),
		time.Date(2020, 1, 1, 01, 00, 00, 000, time.UTC),
		time.Date(2020, 1, 1, 02, 00, 00, 000, time.UTC),
		time.Date(2020, 1, 1, 03, 00, 00, 000, time.UTC),
		proposer.String(),
	)
	input := []types.Proposal{proposal}

	err := suite.database.SaveProposals(input)
	suite.Require().NoError(err)

	var rows []dbtypes.ProposalRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM proposal`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)

}

func (suite *DbTestSuite) TestBigDipperDb_GetOpenProposalsIds() {
	proposer1 := suite.getAccount("cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs")
	proposer2 := suite.getAccount("cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a")

	content1 := govtypesv1beta1.NewTextProposal("title", "description")
	content2 := govtypesv1beta1.NewTextProposal("title1", "description1")

	invalidProposal := types.NewProposal(
		6,
		"proposalRoute1",
		"proposalType1",
		content2,
		types.ProposalStatusInvalid,
		time.Date(2020, 1, 2, 00, 00, 00, 000, time.UTC),
		time.Date(2020, 1, 2, 01, 00, 00, 000, time.UTC),
		time.Date(2020, 1, 2, 02, 00, 00, 000, time.UTC),
		time.Date(2020, 1, 2, 03, 00, 00, 000, time.UTC),
		proposer2.String(),
	)

	input := []types.Proposal{
		types.NewProposal(
			1,
			"proposalRoute",
			"proposalType",
			content1,
			govtypesv1.StatusVotingPeriod.String(),
			time.Date(2020, 1, 1, 00, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 01, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 02, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 03, 00, 00, 000, time.UTC),
			proposer1.String(),
		),
		types.NewProposal(
			2,
			"proposalRoute",
			"proposalType",
			content1,
			govtypesv1.StatusDepositPeriod.String(),
			time.Date(2020, 1, 1, 00, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 01, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 02, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 1, 03, 00, 00, 000, time.UTC),
			proposer1.String(),
		),
		types.NewProposal(
			3,
			"proposalRoute1",
			"proposalType1",
			content2,
			govtypesv1.StatusPassed.String(),
			time.Date(2020, 1, 2, 00, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 01, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 02, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 03, 00, 00, 000, time.UTC),
			proposer2.String(),
		),
		types.NewProposal(
			5,
			"proposalRoute1",
			"proposalType1",
			content2,
			govtypesv1.StatusRejected.String(),
			time.Date(2020, 1, 2, 00, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 01, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 02, 00, 00, 000, time.UTC),
			time.Date(2020, 1, 2, 03, 00, 00, 000, time.UTC),
			proposer2.String(),
		),
		invalidProposal,
	}

	err := suite.database.SaveProposals(input)
	suite.Require().NoError(err)

	timeBeforeDepositEnd := invalidProposal.DepositEndTime.Add(-1 * time.Hour)
	ids, err := suite.database.GetOpenProposalsIds(timeBeforeDepositEnd)
	suite.Require().NoError(err)
	suite.Require().Equal([]uint64{1, 2, 6}, ids)
}

func (suite *DbTestSuite) TestBigDipperDb_UpdateProposal() {
	proposal := suite.getProposalRow(1)
	proposer, err := sdk.AccAddressFromBech32(proposal.Proposer)
	suite.Require().NoError(err)

	timestamp1 := time.Date(2020, 1, 1, 00, 00, 00, 000, time.UTC)
	timestamp2 := time.Date(2020, 1, 1, 01, 00, 00, 000, time.UTC)

	update := types.NewProposalUpdate(
		proposal.ProposalID,
		govtypesv1.StatusPassed.String(),
		timestamp1,
		timestamp2,
	)

	err = suite.database.UpdateProposal(update)
	suite.Require().NoError(err)

	expected := dbtypes.NewProposalRow(
		proposal.ProposalID,
		proposal.ProposalRoute,
		proposal.ProposalType,
		proposal.Content.GetTitle(),
		proposal.Content.GetDescription(),
		suite.encodeProposalContent(proposal.Content),
		proposal.SubmitTime,
		proposal.DepositEndTime,
		timestamp1,
		timestamp2,
		proposer.String(),
		govtypesv1.StatusPassed.String(),
	)

	var result []dbtypes.ProposalRow
	err = suite.database.SQL.Select(&result, `SELECT * FROM proposal`)
	suite.Require().NoError(err)
	suite.Require().Len(result, 1)
	for _, r := range result {
		suite.Require().True(expected.Equals(r))
	}
}

// -------------------------------------------------------------------------------------------------------------------

func (suite *DbTestSuite) TestBigDipperDb_SaveDeposits() {
	_ = suite.getBlock(9)
	_ = suite.getBlock(10)
	_ = suite.getBlock(11)

	proposal := suite.getProposalRow(1)

	depositor := suite.getAccount("cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs")
	amount := sdk.NewCoins(sdk.NewCoin("desmos", sdk.NewInt(10000)))

	depositor2 := suite.getAccount("cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a")
	amount2 := sdk.NewCoins(sdk.NewCoin("desmos", sdk.NewInt(30000)))

	depositor3 := suite.getAccount("cosmos1gyds87lg3m52hex9yqta2mtwzw89pfukx3jl7g")
	amount3 := sdk.NewCoins(sdk.NewCoin("desmos", sdk.NewInt(50000)))

	timestamp1 := time.Date(2020, 1, 1, 15, 00, 00, 000, time.UTC)
	timestamp2 := time.Date(2020, 1, 1, 16, 00, 00, 000, time.UTC)
	timestamp3 := time.Date(2020, 1, 1, 17, 00, 00, 000, time.UTC)

	deposit := []types.Deposit{
		types.NewDeposit(proposal.ProposalID, depositor.String(), amount, timestamp1, 10),
		types.NewDeposit(proposal.ProposalID, depositor2.String(), amount2, timestamp2, 10),
		types.NewDeposit(proposal.ProposalID, depositor3.String(), amount3, timestamp3, 10),
	}

	err := suite.database.SaveDeposits(deposit)
	suite.Require().NoError(err)

	expected := []dbtypes.DepositRow{
		dbtypes.NewDepositRow(1, depositor.String(), dbtypes.NewDbCoins(amount), timestamp1, 10),
		dbtypes.NewDepositRow(1, depositor2.String(), dbtypes.NewDbCoins(amount2), timestamp2, 10),
		dbtypes.NewDepositRow(1, depositor3.String(), dbtypes.NewDbCoins(amount3), timestamp3, 10),
	}
	var result []dbtypes.DepositRow
	err = suite.database.Sqlx.Select(&result, `SELECT * FROM proposal_deposit`)
	suite.Require().NoError(err)
	for i, r := range result {
		suite.Require().True(expected[i].Equals(r))
	}

	// ----------------------------------------------------------------------------------------------------------------
	// Update values

	amount = sdk.NewCoins(sdk.NewCoin("desmos", sdk.NewInt(10)))
	amount2 = sdk.NewCoins(sdk.NewCoin("desmos", sdk.NewInt(20)))
	amount3 = sdk.NewCoins(sdk.NewCoin("desmos", sdk.NewInt(30)))

	deposit = []types.Deposit{
		types.NewDeposit(proposal.ProposalID, depositor.String(), amount, timestamp1, 9),
		types.NewDeposit(proposal.ProposalID, depositor2.String(), amount2, timestamp2, 10),
		types.NewDeposit(proposal.ProposalID, depositor3.String(), amount3, timestamp3, 11),
	}

	err = suite.database.SaveDeposits(deposit)
	suite.Require().NoError(err)

	expected = []dbtypes.DepositRow{
		dbtypes.NewDepositRow(1, depositor.String(), dbtypes.NewDbCoins(
			sdk.NewCoins(sdk.NewCoin("desmos", sdk.NewInt(10000)))), timestamp1, 10),
		dbtypes.NewDepositRow(1, depositor2.String(), dbtypes.NewDbCoins(amount2), timestamp2, 10),
		dbtypes.NewDepositRow(1, depositor3.String(), dbtypes.NewDbCoins(amount3), timestamp3, 11),
	}

	result = []dbtypes.DepositRow{}
	err = suite.database.SQL.Select(&result, `SELECT * FROM proposal_deposit`)
	suite.Require().NoError(err)
	for i, r := range result {
		suite.Require().True(expected[i].Equals(r))
	}
}

// -------------------------------------------------------------------------------------------------------------------

func (suite *DbTestSuite) TestBigDipperDb_SaveVote() {
	_ = suite.getBlock(0)
	_ = suite.getBlock(1)
	_ = suite.getBlock(2)

	proposal := suite.getProposalRow(1)
	voter := suite.getAccount("cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs")

	timestamp := time.Date(2020, 1, 1, 15, 00, 00, 000, time.UTC)

	vote := types.NewVote(1, voter.String(), govtypesv1.OptionYes, timestamp, 1)
	err := suite.database.SaveVote(vote)
	suite.Require().NoError(err)

	expected := dbtypes.NewVoteRow(int64(proposal.ProposalID), voter.String(), govtypesv1.OptionYes.String(), timestamp, 1)

	var result []dbtypes.VoteRow
	err = suite.database.SQL.Select(&result, `SELECT * FROM proposal_vote`)
	suite.Require().NoError(err)
	suite.Require().Len(result, 1)
	suite.Require().True(expected.Equals(result[0]))

	// Update with lower height should not change option
	vote = types.NewVote(1, voter.String(), govtypesv1.OptionNo, timestamp, 0)
	err = suite.database.SaveVote(vote)
	suite.Require().NoError(err)

	result = []dbtypes.VoteRow{}
	err = suite.database.SQL.Select(&result, `SELECT * FROM proposal_vote`)
	suite.Require().NoError(err)
	suite.Require().Len(result, 1)
	suite.Require().True(expected.Equals(result[0]))

	// Update with same height should change option
	vote = types.NewVote(1, voter.String(), govtypesv1.OptionAbstain, timestamp, 1)
	err = suite.database.SaveVote(vote)
	suite.Require().NoError(err)

	expected = dbtypes.NewVoteRow(int64(proposal.ProposalID), voter.String(), govtypesv1.OptionAbstain.String(), timestamp, 1)

	result = []dbtypes.VoteRow{}
	err = suite.database.Sqlx.Select(&result, `SELECT * FROM proposal_vote`)
	suite.Require().NoError(err)
	suite.Require().Len(result, 1)
	suite.Require().True(expected.Equals(result[0]))

	// Update with higher height should change option
	vote = types.NewVote(1, voter.String(), govtypesv1.OptionNoWithVeto, timestamp, 2)
	err = suite.database.SaveVote(vote)
	suite.Require().NoError(err)

	expected = dbtypes.NewVoteRow(int64(proposal.ProposalID), voter.String(), govtypesv1.OptionNoWithVeto.String(), timestamp, 2)

	result = []dbtypes.VoteRow{}
	err = suite.database.Sqlx.Select(&result, `SELECT * FROM proposal_vote`)
	suite.Require().NoError(err)
	suite.Require().Len(result, 1)
	suite.Require().True(expected.Equals(result[0]))
}

func (suite *DbTestSuite) TestBigDipperDb_SaveTallyResults() {
	suite.getProposalRow(1)
	suite.getProposalRow(2)
	suite.getProposalRow(3)

	// Store the data
	err := suite.database.SaveTallyResults([]types.TallyResult{
		types.NewTallyResult(1, "1", "1", "1", "1", 2),
		types.NewTallyResult(2, "2", "2", "2", "2", 2),
		types.NewTallyResult(3, "3", "3", "3", "3", 2),
	})
	suite.Require().NoError(err)

	// Verify the data
	var result []dbtypes.TallyResultRow
	err = suite.database.Sqlx.Select(&result, `SELECT * FROM proposal_tally_result`)
	suite.Require().NoError(err)

	expected := []dbtypes.TallyResultRow{
		dbtypes.NewTallyResultRow(1, "1", "1", "1", "1", 2),
		dbtypes.NewTallyResultRow(2, "2", "2", "2", "2", 2),
		dbtypes.NewTallyResultRow(3, "3", "3", "3", "3", 2),
	}
	for i, r := range result {
		suite.Require().True(r.Equals(expected[i]))
	}

	// ----------------------------------------------------------------------------------------------------------------
	// Update the data
	err = suite.database.SaveTallyResults([]types.TallyResult{
		types.NewTallyResult(1, "10", "10", "10", "10", 1),
		types.NewTallyResult(2, "20", "20", "20", "20", 2),
		types.NewTallyResult(3, "30", "30", "30", "30", 3),
	})
	suite.Require().NoError(err)

	// Verify the data
	result = []dbtypes.TallyResultRow{}
	err = suite.database.Sqlx.Select(&result, `SELECT * FROM proposal_tally_result`)
	suite.Require().NoError(err)

	expected = []dbtypes.TallyResultRow{
		dbtypes.NewTallyResultRow(1, "1", "1", "1", "1", 2),
		dbtypes.NewTallyResultRow(2, "20", "20", "20", "20", 2),
		dbtypes.NewTallyResultRow(3, "30", "30", "30", "30", 3),
	}
	for i, r := range result {
		suite.Require().True(r.Equals(expected[i]))
	}
}

// -------------------------------------------------------------------------------------------------------------------

func (suite *DbTestSuite) TestBigDipperDb_SaveProposalStakingPoolSnapshot() {
	_ = suite.getBlock(9)
	_ = suite.getBlock(10)
	_ = suite.getBlock(11)
	_ = suite.getProposalRow(1)

	// ----------------------------------------------------------------------------------------------------------------
	// Save snapshot

	snapshot := types.NewProposalStakingPoolSnapshot(1, types.NewPoolSnapshot(
		sdk.NewInt(100),
		sdk.NewInt(200),
		10,
	))
	err := suite.database.SaveProposalStakingPoolSnapshot(snapshot)
	suite.Require().NoError(err)

	var rows []dbtypes.ProposalStakingPoolSnapshotRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM proposal_staking_pool_snapshot`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().Equal(rows[0], dbtypes.NewProposalStakingPoolSnapshotRow(
		1,
		100,
		200,
		10,
	))

	// ----------------------------------------------------------------------------------------------------------------
	// Update with lower height

	err = suite.database.SaveProposalStakingPoolSnapshot(types.NewProposalStakingPoolSnapshot(1, types.NewPoolSnapshot(
		sdk.NewInt(200),
		sdk.NewInt(500),
		9,
	)))
	suite.Require().NoError(err)

	rows = []dbtypes.ProposalStakingPoolSnapshotRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM proposal_staking_pool_snapshot`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().Equal(rows[0], dbtypes.NewProposalStakingPoolSnapshotRow(
		1,
		100,
		200,
		10,
	))

	// ----------------------------------------------------------------------------------------------------------------
	// Update with same height

	err = suite.database.SaveProposalStakingPoolSnapshot(types.NewProposalStakingPoolSnapshot(1, types.NewPoolSnapshot(
		sdk.NewInt(500),
		sdk.NewInt(1000),
		10,
	)))
	suite.Require().NoError(err)

	rows = []dbtypes.ProposalStakingPoolSnapshotRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM proposal_staking_pool_snapshot`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().Equal(rows[0], dbtypes.NewProposalStakingPoolSnapshotRow(
		1,
		500,
		1000,
		10,
	))

	// ----------------------------------------------------------------------------------------------------------------
	// Update with higher height

	err = suite.database.SaveProposalStakingPoolSnapshot(types.NewProposalStakingPoolSnapshot(1, types.NewPoolSnapshot(
		sdk.NewInt(1000),
		sdk.NewInt(2000),
		11,
	)))
	suite.Require().NoError(err)

	rows = []dbtypes.ProposalStakingPoolSnapshotRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM proposal_staking_pool_snapshot`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().Equal(rows[0], dbtypes.NewProposalStakingPoolSnapshotRow(
		1,
		1000,
		2000,
		11,
	))
}

func (suite *DbTestSuite) TestBigDipperDb_SaveProposalValidatorsStatusesSnapshots() {
	_ = suite.getBlock(9)
	_ = suite.getBlock(10)
	_ = suite.getBlock(11)
	_ = suite.getProposalRow(1)

	validator1 := suite.getValidator(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
	)
	validator2 := suite.getValidator(
		"cosmosvalcons1rtst6se0nfgjy362v33jt5d05crgdyhfvvvvay",
		"cosmosvaloper1jlr62guqwrwkdt4m3y00zh2rrsamhjf9num5xr",
		"cosmosvalconspub1zcjduepq5e8w7t7k9pwfewgrwy8vn6cghk0x49chx64vt0054yl4wwsmjgrqfackxm",
	)

	// ----------------------------------------------------------------------------------------------------------------
	// Save snapshots

	var snapshots = []types.ProposalValidatorStatusSnapshot{
		types.NewProposalValidatorStatusSnapshot(
			1,
			validator1.GetConsAddr(),
			100,
			int(stakingtypes.Bonded),
			false,
			10,
		),
		types.NewProposalValidatorStatusSnapshot(
			1,
			validator2.GetConsAddr(),
			100,
			int(stakingtypes.Unbonding),
			true,
			10,
		),
	}
	err := suite.database.SaveProposalValidatorsStatusesSnapshots(snapshots)
	suite.Require().NoError(err)

	var rows []dbtypes.ProposalValidatorVotingPowerSnapshotRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM proposal_validator_status_snapshot`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 2)
	suite.Require().Equal(rows, []dbtypes.ProposalValidatorVotingPowerSnapshotRow{
		dbtypes.NewProposalValidatorVotingPowerSnapshotRow(
			1,
			1,
			validator1.GetConsAddr(),
			100,
			3,
			false,
			10,
		),
		dbtypes.NewProposalValidatorVotingPowerSnapshotRow(
			2,
			1,
			validator2.GetConsAddr(),
			100,
			2,
			true,
			10,
		),
	})

	// ----------------------------------------------------------------------------------------------------------------
	// Update snapshots with lower height

	snapshots = []types.ProposalValidatorStatusSnapshot{
		types.NewProposalValidatorStatusSnapshot(
			1,
			validator1.GetConsAddr(),
			10,
			int(stakingtypes.Bonded),
			true,
			9,
		),
		types.NewProposalValidatorStatusSnapshot(
			1,
			validator2.GetConsAddr(),
			700,
			int(stakingtypes.Unbonding),
			true,
			9,
		),
	}
	err = suite.database.SaveProposalValidatorsStatusesSnapshots(snapshots)
	suite.Require().NoError(err)

	rows = []dbtypes.ProposalValidatorVotingPowerSnapshotRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM proposal_validator_status_snapshot`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 2)
	suite.Require().Equal(rows, []dbtypes.ProposalValidatorVotingPowerSnapshotRow{
		dbtypes.NewProposalValidatorVotingPowerSnapshotRow(
			1,
			1,
			validator1.GetConsAddr(),
			100,
			3,
			false,
			10,
		),
		dbtypes.NewProposalValidatorVotingPowerSnapshotRow(
			2,
			1,
			validator2.GetConsAddr(),
			100,
			2,
			true,
			10,
		),
	})

	// ----------------------------------------------------------------------------------------------------------------
	// Update snapshots with same height

	snapshots = []types.ProposalValidatorStatusSnapshot{
		types.NewProposalValidatorStatusSnapshot(
			1,
			validator1.GetConsAddr(),
			10,
			int(stakingtypes.Bonded),
			true,
			10,
		),
		types.NewProposalValidatorStatusSnapshot(
			1,
			validator2.GetConsAddr(),
			700,
			int(stakingtypes.Unbonding),
			true,
			10,
		),
	}
	err = suite.database.SaveProposalValidatorsStatusesSnapshots(snapshots)
	suite.Require().NoError(err)

	rows = []dbtypes.ProposalValidatorVotingPowerSnapshotRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM proposal_validator_status_snapshot`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 2)
	suite.Require().Equal(rows, []dbtypes.ProposalValidatorVotingPowerSnapshotRow{
		dbtypes.NewProposalValidatorVotingPowerSnapshotRow(
			1,
			1,
			validator1.GetConsAddr(),
			10,
			3,
			true,
			10,
		),
		dbtypes.NewProposalValidatorVotingPowerSnapshotRow(
			2,
			1,
			validator2.GetConsAddr(),
			700,
			2,
			true,
			10,
		),
	})

	// ----------------------------------------------------------------------------------------------------------------
	// Update snapshots with higher height

	snapshots = []types.ProposalValidatorStatusSnapshot{
		types.NewProposalValidatorStatusSnapshot(
			1,
			validator1.GetConsAddr(),
			100000,
			int(stakingtypes.Unspecified),
			false,
			11,
		),
		types.NewProposalValidatorStatusSnapshot(
			1,
			validator2.GetConsAddr(),
			700000,
			int(stakingtypes.Unbonded),
			false,
			11,
		),
	}
	err = suite.database.SaveProposalValidatorsStatusesSnapshots(snapshots)
	suite.Require().NoError(err)

	rows = []dbtypes.ProposalValidatorVotingPowerSnapshotRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM proposal_validator_status_snapshot`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 2)
	suite.Require().Equal(rows, []dbtypes.ProposalValidatorVotingPowerSnapshotRow{
		dbtypes.NewProposalValidatorVotingPowerSnapshotRow(
			1,
			1,
			validator1.GetConsAddr(),
			100000,
			0,
			false,
			11,
		),
		dbtypes.NewProposalValidatorVotingPowerSnapshotRow(
			2,
			1,
			validator2.GetConsAddr(),
			700000,
			1,
			false,
			11,
		),
	})
}

func (suite *DbTestSuite) TestBigDipperDb_SaveSoftwareUpgradePlan() {
	_ = suite.getProposalRow(1)

	// ----------------------------------------------------------------------------------------------------------------
	// Save software upgrade plan at height 10 with upgrade height at 100
	var plan = upgradetypes.Plan{
		Name:   "name",
		Height: 100,
		Info:   "info",
	}

	err := suite.database.SaveSoftwareUpgradePlan(1, plan, 10)
	suite.Require().NoError(err)

	var rows []dbtypes.SoftwareUpgradePlanRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM software_upgrade_plan`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().Equal(rows, []dbtypes.SoftwareUpgradePlanRow{
		dbtypes.NewSoftwareUpgradePlanRow(1, plan.Name, plan.Height, plan.Info, 10),
	})

	// ----------------------------------------------------------------------------------------------------------------
	// Update software upgrade plan with lower height
	planEdit1 := upgradetypes.Plan{
		Name:   "name_edit_1",
		Height: 101,
		Info:   "info_edit_1",
	}

	err = suite.database.SaveSoftwareUpgradePlan(1, planEdit1, 9)
	suite.Require().NoError(err)

	rows = []dbtypes.SoftwareUpgradePlanRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM software_upgrade_plan`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().Equal(rows, []dbtypes.SoftwareUpgradePlanRow{
		dbtypes.NewSoftwareUpgradePlanRow(1, plan.Name, plan.Height, plan.Info, 10),
	})

	// ----------------------------------------------------------------------------------------------------------------
	// Update software upgrade plan with same height
	planEdit2 := upgradetypes.Plan{
		Name:   "name_edit_2",
		Height: 102,
		Info:   "info_edit_2",
	}

	err = suite.database.SaveSoftwareUpgradePlan(1, planEdit2, 10)
	suite.Require().NoError(err)

	rows = []dbtypes.SoftwareUpgradePlanRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM software_upgrade_plan`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().Equal(rows, []dbtypes.SoftwareUpgradePlanRow{
		dbtypes.NewSoftwareUpgradePlanRow(1, planEdit2.Name, planEdit2.Height, planEdit2.Info, 10),
	})

	// ----------------------------------------------------------------------------------------------------------------
	// Update software upgrade plan with higher height
	planEdit3 := upgradetypes.Plan{
		Name:   "name_edit_3",
		Height: 103,
		Info:   "info_edit_3",
	}

	err = suite.database.SaveSoftwareUpgradePlan(1, planEdit3, 11)
	suite.Require().NoError(err)

	rows = []dbtypes.SoftwareUpgradePlanRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM software_upgrade_plan`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().Equal(rows, []dbtypes.SoftwareUpgradePlanRow{
		dbtypes.NewSoftwareUpgradePlanRow(1, planEdit3.Name, planEdit3.Height, planEdit3.Info, 11),
	})
}

func (suite *DbTestSuite) TestBigDipperDb_DeleteSoftwareUpgradePlan() {
	_ = suite.getProposalRow(1)

	// Save software upgrade plan at height 10 with upgrade height at 100
	var plan = upgradetypes.Plan{
		Name:   "name",
		Height: 100,
		Info:   "info",
	}

	err := suite.database.SaveSoftwareUpgradePlan(1, plan, 10)
	suite.Require().NoError(err)

	// Delete software upgrade plan
	err = suite.database.DeleteSoftwareUpgradePlan(1)
	suite.Require().NoError(err)

	var rows []dbtypes.SoftwareUpgradePlanRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM software_upgrade_plan`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 0)

}

func (suite *DbTestSuite) TestBigDipperDb_CheckSoftwareUpgradePlan() {
	_ = suite.getProposalRow(1)

	// Save software upgrade plan at height 10 with upgrade height at 100
	var plan = upgradetypes.Plan{
		Name: "name",
		// the Height here is the upgrade height
		Height: 100,
		Info:   "info",
	}

	err := suite.database.SaveSoftwareUpgradePlan(1, plan, 10)
	suite.Require().NoError(err)

	// Check software upgrade plan at existing height
	exist, err := suite.database.CheckSoftwareUpgradePlan(100)
	suite.Require().NoError(err)
	suite.Require().Equal(true, exist)

	// Check software upgrade plan at non-existing height
	exist, err = suite.database.CheckSoftwareUpgradePlan(11)
	suite.Require().NoError(err)
	suite.Require().Equal(false, exist)
}

'''
'''--- database/mint.go ---
package database

import (
	"encoding/json"
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"

	"github.com/forbole/bdjuno/v5/types"
)

// SaveInflation allows to store the inflation for the given block height as well as timestamp
func (db *Db) SaveInflation(inflation sdk.Dec, height int64) error {
	stmt := `
INSERT INTO inflation (value, height) 
VALUES ($1, $2) 
ON CONFLICT (one_row_id) DO UPDATE 
    SET value = excluded.value, 
        height = excluded.height 
WHERE inflation.height <= excluded.height`

	_, err := db.SQL.Exec(stmt, inflation.String(), height)
	if err != nil {
		return fmt.Errorf("error while storing inflation: %s", err)
	}

	return nil
}

// SaveMintParams allows to store the given params inside the database
func (db *Db) SaveMintParams(params *types.MintParams) error {
	paramsBz, err := json.Marshal(&params.Params)
	if err != nil {
		return fmt.Errorf("error while marshaling mint params: %s", err)
	}

	stmt := `
INSERT INTO mint_params (params, height) 
VALUES ($1, $2)
ON CONFLICT (one_row_id) DO UPDATE 
    SET params = excluded.params,
        height = excluded.height
WHERE mint_params.height <= excluded.height`

	_, err = db.SQL.Exec(stmt, string(paramsBz), params.Height)
	if err != nil {
		return fmt.Errorf("error while storing mint params: %s", err)
	}

	return nil
}

'''
'''--- database/mint_test.go ---
package database_test

import (
	"encoding/json"

	sdk "github.com/cosmos/cosmos-sdk/types"
	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"

	"github.com/forbole/bdjuno/v5/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
)

func (suite *DbTestSuite) TestBigDipperDb_SaveInflation() {

	// Save the data
	err := suite.database.SaveInflation(sdk.NewDecWithPrec(10050, 2), 100)
	suite.Require().NoError(err)

	// Verify the data
	var rows []dbtypes.InflationRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM inflation`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "no duplicated inflation rows should be inserted")

	expected := dbtypes.NewInflationRow(100.50, 100)
	suite.Require().True(expected.Equal(rows[0]))

	// ---------------------------------------------------------------------------------------------------------------

	// Try updating with lower height
	err = suite.database.SaveInflation(sdk.NewDecWithPrec(20000, 2), 90)
	suite.Require().NoError(err, "double inflation insertion should return no error")

	// Verify the data
	rows = []dbtypes.InflationRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM inflation`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "no duplicated inflation rows should be inserted")

	expected = dbtypes.NewInflationRow(100.50, 100)
	suite.Require().True(expected.Equal(rows[0]), "data should not change with lower height")

	// ---------------------------------------------------------------------------------------------------------------

	// Try updating with same height
	err = suite.database.SaveInflation(sdk.NewDecWithPrec(30000, 2), 100)
	suite.Require().NoError(err, "double inflation insertion should return no error")

	// Verify the data
	rows = []dbtypes.InflationRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM inflation`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "no duplicated inflation rows should be inserted")

	expected = dbtypes.NewInflationRow(300.00, 100)
	suite.Require().True(expected.Equal(rows[0]), "data should change with same height")

	// ---------------------------------------------------------------------------------------------------------------

	// Try updating with higher height
	err = suite.database.SaveInflation(sdk.NewDecWithPrec(40000, 2), 110)
	suite.Require().NoError(err, "double inflation insertion should return no error")

	// Verify the data
	rows = []dbtypes.InflationRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM inflation`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1, "no duplicated inflation rows should be inserted")

	expected = dbtypes.NewInflationRow(400.00, 110)
	suite.Require().True(expected.Equal(rows[0]), "data should change with higher height")
}

func (suite *DbTestSuite) TestBigDipperDb_SaveMintParams() {
	mintParams := minttypes.NewParams(
		"udaric",
		sdk.NewDecWithPrec(4, 1),
		sdk.NewDecWithPrec(8, 1),
		sdk.NewDecWithPrec(4, 1),
		sdk.NewDecWithPrec(8, 1),
		5006000,
	)
	err := suite.database.SaveMintParams(types.NewMintParams(mintParams, 10))
	suite.Require().NoError(err)

	var rows []dbtypes.MintParamsRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM mint_params`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)

	var storedParams minttypes.Params
	err = json.Unmarshal([]byte(rows[0].Params), &storedParams)
	suite.Require().NoError(err)
	suite.Require().Equal(mintParams, storedParams)
	suite.Require().Equal(int64(10), rows[0].Height)
}

'''
'''--- database/pricefeed.go ---
package database

import (
	"fmt"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"

	"github.com/forbole/bdjuno/v5/types"

	"github.com/lib/pq"
)

// GetTokensPriceID returns the slice of price ids for all tokens stored in db
func (db *Db) GetTokensPriceID() ([]string, error) {
	query := `SELECT * FROM token_unit`

	var dbUnits []dbtypes.TokenUnitRow
	err := db.Sqlx.Select(&dbUnits, query)
	if err != nil {
		return nil, err
	}

	var units []string
	for _, unit := range dbUnits {
		if unit.PriceID.String != "" {
			units = append(units, unit.PriceID.String)
		}
	}

	return units, nil
}

// --------------------------------------------------------------------------------------------------------------------

// SaveToken allows to save the given token details
func (db *Db) SaveToken(token types.Token) error {
	query := `INSERT INTO token (name) VALUES ($1) ON CONFLICT DO NOTHING`
	_, err := db.SQL.Exec(query, token.Name)
	if err != nil {
		return err
	}

	query = `INSERT INTO token_unit (token_name, denom, exponent, aliases, price_id) VALUES `
	var params []interface{}

	for i, unit := range token.Units {
		ui := i * 5
		query += fmt.Sprintf("($%d,$%d,$%d,$%d,$%d),", ui+1, ui+2, ui+3, ui+4, ui+5)
		params = append(params, token.Name, unit.Denom, unit.Exponent, pq.StringArray(unit.Aliases),
			dbtypes.ToNullString(unit.PriceID))
	}

	query = query[:len(query)-1] // Remove trailing ","
	query += " ON CONFLICT DO NOTHING"
	_, err = db.SQL.Exec(query, params...)
	if err != nil {
		return fmt.Errorf("error while saving token: %s", err)
	}

	return nil
}

// --------------------------------------------------------------------------------------------------------------------

// SaveTokensPrices allows to save the given prices as the most updated ones
func (db *Db) SaveTokensPrices(prices []types.TokenPrice) error {
	if len(prices) == 0 {
		return nil
	}

	query := `INSERT INTO token_price (unit_name, price, market_cap, timestamp) VALUES`
	var param []interface{}

	for i, ticker := range prices {
		vi := i * 4
		query += fmt.Sprintf("($%d,$%d,$%d,$%d),", vi+1, vi+2, vi+3, vi+4)
		param = append(param, ticker.UnitName, ticker.Price, ticker.MarketCap, ticker.Timestamp)
	}

	query = query[:len(query)-1] // Remove trailing ","
	query += `
ON CONFLICT (unit_name) DO UPDATE 
	SET price = excluded.price,
	    market_cap = excluded.market_cap,
	    timestamp = excluded.timestamp
WHERE token_price.timestamp <= excluded.timestamp`

	_, err := db.SQL.Exec(query, param...)
	if err != nil {
		return fmt.Errorf("error while saving tokens prices: %s", err)
	}

	return nil
}

// SaveTokenPricesHistory stores the given prices as historic ones
func (db *Db) SaveTokenPricesHistory(prices []types.TokenPrice) error {
	if len(prices) == 0 {
		return nil
	}

	query := `INSERT INTO token_price_history (unit_name, price, market_cap, timestamp) VALUES`
	var param []interface{}

	for i, ticker := range prices {
		vi := i * 4
		query += fmt.Sprintf("($%d,$%d,$%d,$%d),", vi+1, vi+2, vi+3, vi+4)
		param = append(param, ticker.UnitName, ticker.Price, ticker.MarketCap, ticker.Timestamp)
	}

	query = query[:len(query)-1] // Remove trailing ","
	query += `
ON CONFLICT ON CONSTRAINT unique_price_for_timestamp DO UPDATE 
	SET price = excluded.price,
	    market_cap = excluded.market_cap`

	_, err := db.SQL.Exec(query, param...)
	if err != nil {
		return fmt.Errorf("error while storing tokens price history: %s", err)
	}

	return nil
}

'''
'''--- database/pricefeed_test.go ---
package database_test

import (
	"fmt"
	"time"

	"github.com/forbole/bdjuno/v5/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
)

func (suite *DbTestSuite) insertToken(name string) {
	query := fmt.Sprintf(
		`INSERT INTO token (name) VALUES ('%s')`, name)
	_, err := suite.database.SQL.Query(query)
	suite.Require().NoError(err)

	query = fmt.Sprintf(
		`INSERT INTO token_unit (token_name, denom, exponent, price_id) VALUES ('%[1]s', 'u%[1]s', 0, 'u%[1]s'), ('%[1]s', 'm%[1]s', 3, 'm%[1]s'), ('%[1]s', '%[1]s', 6, '%[1]s')`,
		name)
	_, err = suite.database.SQL.Query(query)
	suite.Require().NoError(err)
}

func (suite *DbTestSuite) Test_GetTokensPriceID() {
	suite.insertToken("desmos")
	suite.insertToken("daric")

	units, err := suite.database.GetTokensPriceID()
	suite.Require().NoError(err)

	var expected = []string{"udesmos", "mdesmos", "desmos", "udaric", "mdaric", "daric"}

	suite.Require().Len(units, len(expected))
	for _, name := range expected {
		suite.Require().Contains(units, name)
	}
}

func (suite *DbTestSuite) TestBigDipperDb_SaveTokenPrice() {
	suite.insertToken("desmos")
	suite.insertToken("atom")

	// Save data
	tickers := []types.TokenPrice{
		types.NewTokenPrice(
			"desmos",
			100.01,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		types.NewTokenPrice(
			"atom",
			200.01,
			20,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
	}
	err := suite.database.SaveTokensPrices(tickers)
	suite.Require().NoError(err)

	// Verify data
	expected := []dbtypes.TokenPriceRow{
		dbtypes.NewTokenPriceRow(
			"desmos",
			100.01,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		dbtypes.NewTokenPriceRow(
			"atom",
			200.01,
			20,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
	}

	var rows []dbtypes.TokenPriceRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM token_price`)
	suite.Require().NoError(err)
	for i, row := range rows {
		suite.Require().True(expected[i].Equals(row))
	}

	// Update data
	tickers = []types.TokenPrice{
		types.NewTokenPrice(
			"desmos",
			100.01,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		types.NewTokenPrice(
			"atom",
			1,
			20,
			time.Date(2020, 10, 10, 15, 05, 00, 000, time.UTC),
		),
	}
	err = suite.database.SaveTokensPrices(tickers)
	suite.Require().NoError(err)

	// Verify data
	expected = []dbtypes.TokenPriceRow{
		dbtypes.NewTokenPriceRow(
			"desmos",
			100.01,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		dbtypes.NewTokenPriceRow(
			"atom",
			1,
			20,
			time.Date(2020, 10, 10, 15, 05, 00, 000, time.UTC),
		),
	}

	rows = []dbtypes.TokenPriceRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM token_price ORDER BY timestamp`)
	suite.Require().NoError(err)
	for i, row := range rows {
		suite.Require().True(expected[i].Equals(row))
	}
}

func (suite *DbTestSuite) TestBigDipperDb_SaveTokenPriceHistory() {
	suite.insertToken("desmos")
	suite.insertToken("atom")

	// Save data
	tickers := []types.TokenPrice{
		types.NewTokenPrice(
			"desmos",
			100.01,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		types.NewTokenPrice(
			"desmos",
			200.01,
			20,
			time.Date(2020, 10, 10, 15, 02, 00, 000, time.UTC),
		),
		types.NewTokenPrice(
			"atom",
			1,
			20,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		types.NewTokenPrice(
			"atom",
			1,
			20,
			time.Date(2020, 10, 10, 15, 02, 00, 000, time.UTC),
		),
	}
	err := suite.database.SaveTokenPricesHistory(tickers)
	suite.Require().NoError(err)

	// Verify data
	expected := []dbtypes.TokenPriceRow{
		dbtypes.NewTokenPriceRow(
			"desmos",
			100.01,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		dbtypes.NewTokenPriceRow(
			"desmos",
			200.01,
			20,
			time.Date(2020, 10, 10, 15, 02, 00, 000, time.UTC),
		),
		dbtypes.NewTokenPriceRow(
			"atom",
			1,
			20,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		dbtypes.NewTokenPriceRow(
			"atom",
			1,
			20,
			time.Date(2020, 10, 10, 15, 02, 00, 000, time.UTC),
		),
	}

	var rows []dbtypes.TokenPriceRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM token_price_history`)
	suite.Require().NoError(err)

	for i, row := range rows {
		suite.Require().True(expected[i].Equals(row))
	}

	// Update data
	tickers = []types.TokenPrice{
		types.NewTokenPrice(
			"desmos",
			100.01,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		types.NewTokenPrice(
			"desmos",
			300.01,
			20,
			time.Date(2020, 10, 10, 15, 02, 00, 000, time.UTC),
		),
		types.NewTokenPrice(
			"atom",
			1,
			20,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		types.NewTokenPrice(
			"atom",
			10,
			20,
			time.Date(2020, 10, 10, 15, 02, 00, 000, time.UTC),
		),
	}
	err = suite.database.SaveTokenPricesHistory(tickers)
	suite.Require().NoError(err)

	// Verify data
	expected = []dbtypes.TokenPriceRow{
		dbtypes.NewTokenPriceRow(
			"desmos",
			100.01,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		dbtypes.NewTokenPriceRow(
			"atom",
			1,
			20,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
		),
		dbtypes.NewTokenPriceRow(
			"desmos",
			300.01,
			20,
			time.Date(2020, 10, 10, 15, 02, 00, 000, time.UTC),
		),

		dbtypes.NewTokenPriceRow(
			"atom",
			10,
			20,
			time.Date(2020, 10, 10, 15, 02, 00, 000, time.UTC),
		),
	}

	rows = []dbtypes.TokenPriceRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM token_price_history ORDER BY timestamp`)
	suite.Require().NoError(err)

	for i, row := range rows {
		suite.Require().True(expected[i].Equals(row))
	}
}

'''
'''--- database/pruning.go ---
package database

import "fmt"

// Prune implements db.PruningDb
func (db *Db) Prune(height int64) error {
	// Prune default tables
	err := db.Database.Prune(height)
	if err != nil {
		return fmt.Errorf("error while pruning db: %s", err)
	}

	// Prune modules
	err = db.pruneBank(height)
	if err != nil {
		return fmt.Errorf("error while pruning bank: %s", err)
	}

	err = db.pruneStaking(height)
	if err != nil {
		return fmt.Errorf("error while pruning staking: %s", err)
	}

	err = db.pruneMint(height)
	if err != nil {
		return fmt.Errorf("error while pruning mint: %s", err)
	}

	err = db.pruneDistribution(height)
	if err != nil {
		return fmt.Errorf("error while pruning distribution: %s", err)
	}

	err = db.pruneSlashing(height)
	if err != nil {
		return fmt.Errorf("error while pruning slashing: %s", err)
	}

	return nil
}

func (db *Db) pruneBank(height int64) error {
	_, err := db.SQL.Exec(`DELETE FROM supply WHERE height = $1`, height)
	if err != nil {
		return fmt.Errorf("error while pruning supply: %s", err)
	}
	return nil
}

func (db *Db) pruneStaking(height int64) error {
	_, err := db.SQL.Exec(`DELETE FROM staking_pool WHERE height = $1`, height)
	if err != nil {
		return fmt.Errorf("error while pruning staking pool: %s", err)
	}

	_, err = db.SQL.Exec(`DELETE FROM validator_commission WHERE height = $1`, height)
	if err != nil {
		return fmt.Errorf("error while pruning validator commission: %s", err)
	}

	_, err = db.SQL.Exec(`DELETE FROM validator_voting_power WHERE height = $1`, height)
	if err != nil {
		return fmt.Errorf("error while pruning validator voting power: %s", err)
	}

	_, err = db.SQL.Exec(`DELETE FROM validator_status WHERE height = $1`, height)
	if err != nil {
		return fmt.Errorf("error while pruning validator status: %s", err)
	}

	_, err = db.SQL.Exec(`DELETE FROM double_sign_vote WHERE height = $1`, height)
	if err != nil {
		return fmt.Errorf("error while pruning double sign votes: %s", err)
	}

	_, err = db.SQL.Exec(`DELETE FROM double_sign_evidence WHERE height = $1`, height)
	if err != nil {
		return fmt.Errorf("error while pruning double sign evidence: %s", err)
	}

	return nil
}

func (db *Db) pruneMint(height int64) error {
	_, err := db.SQL.Exec(`DELETE FROM inflation WHERE height = $1`, height)
	return fmt.Errorf("error while pruning inflation: %s", err)
}

func (db *Db) pruneDistribution(height int64) error {
	_, err := db.SQL.Exec(`DELETE FROM community_pool WHERE height = $1`, height)
	if err != nil {
		return fmt.Errorf("error while pruning community pool: %s", err)
	}

	return nil
}

func (db *Db) pruneSlashing(height int64) error {
	_, err := db.SQL.Exec(`DELETE FROM validator_signing_info WHERE height = $1`, height)
	if err != nil {
		return fmt.Errorf("error while pruning validator signing info: %s", err)
	}

	_, err = db.SQL.Exec(`DELETE FROM slashing_params WHERE height = $1`, height)
	if err != nil {
		return fmt.Errorf("error while pruning slashing params: %s", err)
	}

	return nil
}

'''
'''--- database/schema/00-cosmos.sql ---
CREATE TABLE validator
(
    consensus_address TEXT NOT NULL PRIMARY KEY, /* Validator consensus address */
    consensus_pubkey  TEXT NOT NULL UNIQUE /* Validator consensus public key */
);

CREATE TABLE pre_commit
(
    validator_address TEXT                        NOT NULL REFERENCES validator (consensus_address),
    height            BIGINT                      NOT NULL,
    timestamp         TIMESTAMP WITHOUT TIME ZONE NOT NULL,
    voting_power      BIGINT                      NOT NULL,
    proposer_priority BIGINT                      NOT NULL,
    UNIQUE (validator_address, timestamp)
);
CREATE INDEX pre_commit_validator_address_index ON pre_commit (validator_address);
CREATE INDEX pre_commit_height_index ON pre_commit (height);

CREATE TABLE block
(
    height           BIGINT  UNIQUE PRIMARY KEY,
    hash             TEXT    NOT NULL UNIQUE,
    num_txs          INTEGER DEFAULT 0,
    total_gas        BIGINT  DEFAULT 0,
    proposer_address TEXT REFERENCES validator (consensus_address),
    timestamp        TIMESTAMP WITHOUT TIME ZONE NOT NULL
);
CREATE INDEX block_height_index ON block (height);
CREATE INDEX block_hash_index ON block (hash);
CREATE INDEX block_proposer_address_index ON block (proposer_address);
ALTER TABLE block
    SET (
        autovacuum_vacuum_scale_factor = 0,
        autovacuum_analyze_scale_factor = 0,
        autovacuum_vacuum_threshold = 10000,
        autovacuum_analyze_threshold = 10000
        );

CREATE TABLE transaction
(
    hash         TEXT    NOT NULL,
    height       BIGINT  NOT NULL REFERENCES block (height),
    success      BOOLEAN NOT NULL,

    /* Body */
    messages     JSONB   NOT NULL DEFAULT '[]'::JSONB,
    memo         TEXT,
    signatures   TEXT[]  NOT NULL,

    /* AuthInfo */
    signer_infos JSONB   NOT NULL DEFAULT '[]'::JSONB,
    fee          JSONB   NOT NULL DEFAULT '{}'::JSONB,

    /* Tx response */
    gas_wanted   BIGINT           DEFAULT 0,
    gas_used     BIGINT           DEFAULT 0,
    raw_log      TEXT,
    logs         JSONB,

    /* PSQL partition */
    partition_id BIGINT  NOT NULL DEFAULT 0,

    CONSTRAINT unique_tx UNIQUE (hash, partition_id)
)PARTITION BY LIST(partition_id);
CREATE INDEX transaction_hash_index ON transaction (hash);
CREATE INDEX transaction_height_index ON transaction (height);
CREATE INDEX transaction_partition_id_index ON transaction (partition_id);

CREATE TABLE message
(
    transaction_hash            TEXT   NOT NULL,
    index                       BIGINT NOT NULL,
    type                        TEXT   NOT NULL,
    value                       JSONB  NOT NULL,
    involved_accounts_addresses TEXT[] NOT NULL,

    /* PSQL partition */
    partition_id                BIGINT NOT NULL DEFAULT 0,
    height                      BIGINT NOT NULL,
    FOREIGN KEY (transaction_hash, partition_id) REFERENCES transaction (hash, partition_id),
    CONSTRAINT unique_message_per_tx UNIQUE (transaction_hash, index, partition_id)
)PARTITION BY LIST(partition_id);
CREATE INDEX message_transaction_hash_index ON message (transaction_hash);
CREATE INDEX message_type_index ON message (type);
CREATE INDEX message_involved_accounts_index ON message USING GIN(involved_accounts_addresses);

/**
 * This function is used to find all the utils that involve any of the given addresses and have
 * type that is one of the specified types.
 */
CREATE FUNCTION messages_by_address(
    addresses TEXT[],
    types TEXT[],
    "limit" BIGINT = 100,
    "offset" BIGINT = 0)
    RETURNS SETOF message AS
$$
SELECT * FROM message
WHERE (cardinality(types) = 0 OR type = ANY (types))
  AND addresses && involved_accounts_addresses
ORDER BY height DESC LIMIT "limit" OFFSET "offset"
$$ LANGUAGE sql STABLE;

CREATE TABLE pruning
(
    last_pruned_height BIGINT NOT NULL
);
'''
'''--- database/schema/01-auth.sql ---
CREATE TABLE account
(
    address TEXT NOT NULL PRIMARY KEY
);

/* ---- Moved from bank.sql for vesting account usage ---- */
CREATE TYPE COIN AS
(
    denom  TEXT,
    amount TEXT
);

/* ---- AUTH/ VESTING ACCOUNT ---- */
CREATE TABLE vesting_account
(
    id                  SERIAL                          PRIMARY KEY NOT NULL,
    type                TEXT                            NOT NULL,
    address             TEXT                            NOT NULL REFERENCES account (address),
    original_vesting    COIN[]                          NOT NULL DEFAULT '{}',
    end_time            TIMESTAMP WITHOUT TIME ZONE     NOT NULL,
    start_time          TIMESTAMP WITHOUT TIME ZONE
);
/* ---- start_time can be empty on DelayedVestingAccount ---- */

CREATE UNIQUE INDEX vesting_account_address_idx ON vesting_account (address);

CREATE TABLE vesting_period
(
    vesting_account_id  BIGINT  NOT NULL REFERENCES vesting_account (id),
    period_order        BIGINT  NOT NULL,
    length              BIGINT  NOT NULL,
    amount              COIN[]  NOT NULL DEFAULT '{}'
);
'''
'''--- database/schema/02-bank.sql ---
/* ---- SUPPLY ---- */

CREATE TABLE supply
(
    one_row_id BOOLEAN NOT NULL DEFAULT TRUE PRIMARY KEY,
    coins      COIN[]  NOT NULL,
    height     BIGINT  NOT NULL,
    CHECK (one_row_id)
);
CREATE INDEX supply_height_index ON supply (height);
'''
'''--- database/schema/03-staking.sql ---
/* ---- PARAMS ---- */

CREATE TABLE staking_params
(
    one_row_id BOOLEAN NOT NULL DEFAULT TRUE PRIMARY KEY,
    params     JSONB   NOT NULL,
    height     BIGINT  NOT NULL,
    CHECK (one_row_id)
);
CREATE INDEX staking_params_height_index ON staking_params (height);

/* ---- POOL ---- */

CREATE TABLE staking_pool
(
    one_row_id               BOOLEAN NOT NULL DEFAULT TRUE PRIMARY KEY,
    bonded_tokens            TEXT    NOT NULL,
    not_bonded_tokens        TEXT    NOT NULL,
    unbonding_tokens         TEXT    NOT NULL,
    staked_not_bonded_tokens TEXT    NOT NULL,
    height                   BIGINT  NOT NULL,
    CHECK (one_row_id)
);
CREATE INDEX staking_pool_height_index ON staking_pool (height);

/* ---- VALIDATORS INFO ---- */

CREATE TABLE validator_info
(
    consensus_address     TEXT   NOT NULL UNIQUE PRIMARY KEY REFERENCES validator (consensus_address),
    operator_address      TEXT   NOT NULL UNIQUE,
    self_delegate_address TEXT REFERENCES account (address),
    max_change_rate       TEXT   NOT NULL,
    max_rate              TEXT   NOT NULL,
    height                BIGINT NOT NULL
);
CREATE INDEX validator_info_operator_address_index ON validator_info (operator_address);
CREATE INDEX validator_info_self_delegate_address_index ON validator_info (self_delegate_address);

CREATE TABLE validator_description
(
    validator_address TEXT   NOT NULL REFERENCES validator (consensus_address) PRIMARY KEY,
    moniker           TEXT,
    identity          TEXT,
    avatar_url        TEXT,
    website           TEXT,
    security_contact  TEXT,
    details           TEXT,
    height            BIGINT NOT NULL
);
CREATE INDEX validator_description_height_index ON validator_description (height);

CREATE TABLE validator_commission
(
    validator_address   TEXT    NOT NULL REFERENCES validator (consensus_address) PRIMARY KEY,
    commission          DECIMAL NOT NULL,
    min_self_delegation BIGINT  NOT NULL,
    height              BIGINT  NOT NULL
);
CREATE INDEX validator_commission_height_index ON validator_commission (height);

CREATE TABLE validator_voting_power
(
    validator_address TEXT   NOT NULL REFERENCES validator (consensus_address) PRIMARY KEY,
    voting_power      BIGINT NOT NULL,
    height            BIGINT NOT NULL REFERENCES block (height)
);
CREATE INDEX validator_voting_power_height_index ON validator_voting_power (height);

CREATE TABLE validator_status
(
    validator_address TEXT    NOT NULL REFERENCES validator (consensus_address) PRIMARY KEY,
    status            INT     NOT NULL,
    jailed            BOOLEAN NOT NULL,
    height            BIGINT  NOT NULL
);
CREATE INDEX validator_status_height_index ON validator_status (height);

/* ---- DOUBLE SIGN EVIDENCE ---- */

/*
 * This holds the votes that is the evidence of a double sign.
 * It should be updated on a BLOCK basis when a double sign occurs.
 */
CREATE TABLE double_sign_vote
(
    id                SERIAL PRIMARY KEY,
    type              SMALLINT NOT NULL,
    height            BIGINT   NOT NULL,
    round             INT      NOT NULL,
    block_id          TEXT     NOT NULL,
    validator_address TEXT     NOT NULL REFERENCES validator (consensus_address),
    validator_index   INT      NOT NULL,
    signature         TEXT     NOT NULL,
    UNIQUE (block_id, validator_address)
);
CREATE INDEX double_sign_vote_validator_address_index ON double_sign_vote (validator_address);
CREATE INDEX double_sign_vote_height_index ON double_sign_vote (height);

/*
 * This holds the double sign evidences.
 * It should be updated on a on BLOCK basis.
 */
CREATE TABLE double_sign_evidence
(
    height    BIGINT NOT NULL,
    vote_a_id BIGINT NOT NULL REFERENCES double_sign_vote (id),
    vote_b_id BIGINT NOT NULL REFERENCES double_sign_vote (id)
);
CREATE INDEX double_sign_evidence_height_index ON double_sign_evidence (height);
'''
'''--- database/schema/04-consensus.sql ---
CREATE TABLE genesis
(
    one_row_id     BOOL      NOT NULL DEFAULT TRUE PRIMARY KEY,
    chain_id       TEXT      NOT NULL,
    time           TIMESTAMP NOT NULL,
    initial_height BIGINT    NOT NULL,
    CHECK (one_row_id)
);

CREATE TABLE average_block_time_per_minute
(
    one_row_id   BOOL    NOT NULL DEFAULT TRUE PRIMARY KEY,
    average_time DECIMAL NOT NULL,
    height       BIGINT  NOT NULL,
    CHECK (one_row_id)
);
CREATE INDEX average_block_time_per_minute_height_index ON average_block_time_per_minute (height);

CREATE TABLE average_block_time_per_hour
(
    one_row_id   BOOL    NOT NULL DEFAULT TRUE PRIMARY KEY,
    average_time DECIMAL NOT NULL,
    height       BIGINT  NOT NULL,
    CHECK (one_row_id)
);
CREATE INDEX average_block_time_per_hour_height_index ON average_block_time_per_hour (height);

CREATE TABLE average_block_time_per_day
(
    one_row_id   BOOL    NOT NULL DEFAULT TRUE PRIMARY KEY,
    average_time DECIMAL NOT NULL,
    height       BIGINT  NOT NULL,
    CHECK (one_row_id)
);
CREATE INDEX average_block_time_per_day_height_index ON average_block_time_per_day (height);

CREATE TABLE average_block_time_from_genesis
(
    one_row_id   BOOL    NOT NULL DEFAULT TRUE PRIMARY KEY,
    average_time DECIMAL NOT NULL,
    height       BIGINT  NOT NULL,
    CHECK (one_row_id)
);
CREATE INDEX average_block_time_from_genesis_height_index ON average_block_time_from_genesis (height);

'''
'''--- database/schema/05-mint.sql ---
/* ---- PARAMS ---- */

CREATE TABLE mint_params
(
    one_row_id BOOLEAN NOT NULL DEFAULT TRUE PRIMARY KEY,
    params     JSONB   NOT NULL,
    height     BIGINT  NOT NULL,
    CHECK (one_row_id)
);

/* ---- INFLATION ---- */

CREATE TABLE inflation
(
    one_row_id bool PRIMARY KEY DEFAULT TRUE,
    value      DECIMAL NOT NULL,
    height     BIGINT  NOT NULL,
    CONSTRAINT one_row_uni CHECK (one_row_id)
);
CREATE INDEX inflation_height_index ON inflation (height);
'''
'''--- database/schema/06-distribution.sql ---
CREATE TYPE DEC_COIN AS
(
    denom  TEXT,
    amount TEXT
);

/* ---- PARAMS ---- */

CREATE TABLE distribution_params
(
    one_row_id BOOLEAN NOT NULL DEFAULT TRUE PRIMARY KEY,
    params     JSONB   NOT NULL,
    height     BIGINT  NOT NULL,
    CHECK (one_row_id)
);
CREATE INDEX distribution_params_height_index ON distribution_params (height);

/* ---- COMMUNITY POOL ---- */

CREATE TABLE community_pool
(
    one_row_id bool PRIMARY KEY DEFAULT TRUE,
    coins      DEC_COIN[] NOT NULL,
    height     BIGINT     NOT NULL,
    CONSTRAINT one_row_uni CHECK (one_row_id)
);
CREATE INDEX community_pool_height_index ON community_pool (height);

'''
'''--- database/schema/07-pricefeed.sql ---
/* ---- TOKENS ---- */

CREATE TABLE token
(
    name TEXT NOT NULL UNIQUE
);

CREATE TABLE token_unit
(
    token_name TEXT NOT NULL REFERENCES token (name),
    denom      TEXT NOT NULL UNIQUE,
    exponent   INT  NOT NULL,
    aliases    TEXT[],
    price_id   TEXT
);

/* ---- TOKEN PRICES ---- */

CREATE TABLE token_price
(
    /* Needed for the below token_price function to work properly */
    id         SERIAL                      NOT NULL PRIMARY KEY,

    unit_name  TEXT                        NOT NULL REFERENCES token_unit (denom) UNIQUE,
    price      DECIMAL                     NOT NULL,
    market_cap BIGINT                      NOT NULL,
    timestamp  TIMESTAMP WITHOUT TIME ZONE NOT NULL
);
CREATE INDEX token_price_timestamp_index ON token_price (timestamp);

CREATE TABLE token_price_history
(
    id         SERIAL                      NOT NULL PRIMARY KEY,
    unit_name  TEXT                        NOT NULL REFERENCES token_unit (denom),
    price      DECIMAL                     NOT NULL,
    market_cap BIGINT                      NOT NULL,
    timestamp  TIMESTAMP WITHOUT TIME ZONE NOT NULL,
    CONSTRAINT unique_price_for_timestamp UNIQUE (unit_name, timestamp)
);
CREATE INDEX token_price_history_timestamp_index ON token_price_history (timestamp);

'''
'''--- database/schema/08-gov.sql ---
CREATE TABLE gov_params
(
    one_row_id     BOOLEAN NOT NULL DEFAULT TRUE PRIMARY KEY,
    deposit_params JSONB   NOT NULL,
    voting_params  JSONB   NOT NULL,
    tally_params   JSONB   NOT NULL,
    height         BIGINT  NOT NULL,
    CHECK (one_row_id)
);

CREATE TABLE proposal
(
    id                INTEGER   NOT NULL PRIMARY KEY,
    title             TEXT      NOT NULL,
    description       TEXT      NOT NULL,
    content           JSONB     NOT NULL,
    proposal_route    TEXT      NOT NULL,
    proposal_type     TEXT      NOT NULL,
    submit_time       TIMESTAMP NOT NULL,
    deposit_end_time  TIMESTAMP,
    voting_start_time TIMESTAMP,
    voting_end_time   TIMESTAMP,
    proposer_address  TEXT      NOT NULL REFERENCES account (address),
    status            TEXT
);
CREATE INDEX proposal_proposer_address_index ON proposal (proposer_address);

CREATE TABLE proposal_deposit
(
    proposal_id       INTEGER NOT NULL REFERENCES proposal (id),
    depositor_address TEXT             REFERENCES account (address),
    amount            COIN[],
    timestamp         TIMESTAMP,
    height            BIGINT  NOT NULL,
    CONSTRAINT unique_deposit UNIQUE (proposal_id, depositor_address)
);
CREATE INDEX proposal_deposit_proposal_id_index ON proposal_deposit (proposal_id);
CREATE INDEX proposal_deposit_depositor_address_index ON proposal_deposit (depositor_address);
CREATE INDEX proposal_deposit_depositor_height_index ON proposal_deposit (height);

CREATE TABLE proposal_vote
(
    proposal_id   INTEGER NOT NULL REFERENCES proposal (id),
    voter_address TEXT    NOT NULL REFERENCES account (address),
    option        TEXT    NOT NULL,
    timestamp     TIMESTAMP,
    height        BIGINT  NOT NULL,
    CONSTRAINT unique_vote UNIQUE (proposal_id, voter_address)
);
CREATE INDEX proposal_vote_proposal_id_index ON proposal_vote (proposal_id);
CREATE INDEX proposal_vote_voter_address_index ON proposal_vote (voter_address);
CREATE INDEX proposal_vote_height_index ON proposal_vote (height);

CREATE TABLE proposal_tally_result
(
    proposal_id  INTEGER REFERENCES proposal (id) PRIMARY KEY,
    yes          TEXT NOT NULL,
    abstain      TEXT NOT NULL,
    no           TEXT NOT NULL,
    no_with_veto TEXT NOT NULL,
    height       BIGINT NOT NULL,
    CONSTRAINT unique_tally_result UNIQUE (proposal_id)
);
CREATE INDEX proposal_tally_result_proposal_id_index ON proposal_tally_result (proposal_id);
CREATE INDEX proposal_tally_result_height_index ON proposal_tally_result (height);

CREATE TABLE proposal_staking_pool_snapshot
(
    proposal_id       INTEGER REFERENCES proposal (id) PRIMARY KEY,
    bonded_tokens     TEXT   NOT NULL,
    not_bonded_tokens TEXT   NOT NULL,
    height            BIGINT NOT NULL,
    CONSTRAINT unique_staking_pool_snapshot UNIQUE (proposal_id)
);
CREATE INDEX proposal_staking_pool_snapshot_proposal_id_index ON proposal_staking_pool_snapshot (proposal_id);

CREATE TABLE proposal_validator_status_snapshot
(
    id                SERIAL PRIMARY KEY NOT NULL,
    proposal_id       INTEGER REFERENCES proposal (id),
    validator_address TEXT               NOT NULL REFERENCES validator (consensus_address),
    voting_power      BIGINT             NOT NULL,
    status            INT                NOT NULL,
    jailed            BOOLEAN            NOT NULL,
    height            BIGINT             NOT NULL,
    CONSTRAINT unique_validator_status_snapshot UNIQUE (proposal_id, validator_address)
);
CREATE INDEX proposal_validator_status_snapshot_proposal_id_index ON proposal_validator_status_snapshot (proposal_id);
CREATE INDEX proposal_validator_status_snapshot_validator_address_index ON proposal_validator_status_snapshot (validator_address);
'''
'''--- database/schema/09-modules.sql ---
CREATE TABLE modules
(
    module_name TEXT NOT NULL UNIQUE PRIMARY KEY
);
'''
'''--- database/schema/10-slashing.sql ---
CREATE TABLE validator_signing_info
(
    validator_address     TEXT                        NOT NULL PRIMARY KEY,
    start_height          BIGINT                      NOT NULL,
    index_offset          BIGINT                      NOT NULL,
    jailed_until          TIMESTAMP WITHOUT TIME ZONE NOT NULL,
    tombstoned            BOOLEAN                     NOT NULL,
    missed_blocks_counter BIGINT                      NOT NULL,
    height                BIGINT                      NOT NULL
);
CREATE INDEX validator_signing_info_height_index ON validator_signing_info (height);

CREATE TABLE slashing_params
(
    one_row_id BOOLEAN NOT NULL DEFAULT TRUE PRIMARY KEY,
    params     JSONB   NOT NULL,
    height     BIGINT  NOT NULL,
    CHECK (one_row_id)
);
CREATE INDEX slashing_params_height_index ON slashing_params (height);
'''
'''--- database/schema/11-feegrant.sql ---
CREATE TABLE fee_grant_allowance
(
    id                 SERIAL      NOT NULL PRIMARY KEY,
    grantee_address    TEXT        NOT NULL REFERENCES account (address),
    granter_address    TEXT        NOT NULL REFERENCES account (address),
    allowance          JSONB       NOT NULL DEFAULT '{}'::JSONB,
    height             BIGINT      NOT NULL,
    CONSTRAINT unique_fee_grant_allowance UNIQUE(grantee_address, granter_address) 
);
CREATE INDEX fee_grant_allowance_height_index ON fee_grant_allowance (height);

'''
'''--- database/schema/12-upgrade.sql ---
CREATE TABLE software_upgrade_plan
(
    proposal_id     INTEGER REFERENCES proposal (id) UNIQUE,
    plan_name       TEXT        NOT NULL,
    upgrade_height  BIGINT      NOT NULL,
    info            TEXT        NOT NULL,
    height          BIGINT      NOT NULL
);
CREATE INDEX software_upgrade_plan_proposal_id_index ON software_upgrade_plan (proposal_id);
CREATE INDEX software_upgrade_plan_height_index ON software_upgrade_plan (height);

'''
'''--- database/slashing.go ---
package database

import (
	"encoding/json"
	"fmt"

	"github.com/forbole/bdjuno/v5/types"
)

// SaveValidatorsSigningInfos saves the given infos inside the database
func (db *Db) SaveValidatorsSigningInfos(infos []types.ValidatorSigningInfo) error {
	if len(infos) == 0 {
		return nil
	}

	stmt := `
INSERT INTO validator_signing_info 
    (validator_address, start_height, index_offset, jailed_until, tombstoned, missed_blocks_counter, height)
VALUES `
	var args []interface{}

	for i, info := range infos {
		ii := i * 7

		stmt += fmt.Sprintf("($%d, $%d, $%d, $%d, $%d, $%d, $%d),", ii+1, ii+2, ii+3, ii+4, ii+5, ii+6, ii+7)
		args = append(args,
			info.ValidatorAddress, info.StartHeight, info.IndexOffset, info.JailedUntil, info.Tombstoned,
			info.MissedBlocksCounter, info.Height,
		)
	}

	stmt = stmt[:len(stmt)-1] // Remove trailing ","
	stmt += `
ON CONFLICT (validator_address) DO UPDATE 
	SET validator_address = excluded.validator_address,
		start_height = excluded.start_height,
		index_offset = excluded.index_offset,
		jailed_until = excluded.jailed_until,
		tombstoned = excluded.tombstoned,
		missed_blocks_counter = excluded.missed_blocks_counter,
		height = excluded.height
WHERE validator_signing_info.height <= excluded.height`

	_, err := db.SQL.Exec(stmt, args...)
	if err != nil {
		return fmt.Errorf("error while storing validators signing infos: %s", err)
	}

	return nil
}

// SaveSlashingParams saves the slashing params for the given height
func (db *Db) SaveSlashingParams(params *types.SlashingParams) error {
	paramsBz, err := json.Marshal(&params.Params)
	if err != nil {
		return err
	}

	stmt := `
INSERT INTO slashing_params (params, height) 
VALUES ($1, $2)
ON CONFLICT (one_row_id) DO UPDATE 
    SET params = excluded.params, 
        height = excluded.height
WHERE slashing_params.height <= excluded.height`

	_, err = db.SQL.Exec(stmt, string(paramsBz), params.Height)
	if err != nil {
		return fmt.Errorf("error while storing slashing params: %s", err)
	}

	return nil
}

'''
'''--- database/slashing_test.go ---
package database_test

import (
	"encoding/json"
	"time"

	"github.com/forbole/bdjuno/v5/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
)

func (suite *DbTestSuite) TestBigDipperDb_ValidatorSigningInfo() {
	validator1 := suite.getValidator(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
	)
	validator2 := suite.getValidator(
		"cosmosvalcons1rtst6se0nfgjy362v33jt5d05crgdyhfvvvvay",
		"cosmosvaloper1jlr62guqwrwkdt4m3y00zh2rrsamhjf9num5xr",
		"cosmosvalconspub1zcjduepq5e8w7t7k9pwfewgrwy8vn6cghk0x49chx64vt0054yl4wwsmjgrqfackxm",
	)

	// Save the data
	infos := []types.ValidatorSigningInfo{
		types.NewValidatorSigningInfo(
			validator1.GetConsAddr(),
			10,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
			true,
			10,
			10,
		),
		types.NewValidatorSigningInfo(
			validator2.GetConsAddr(),
			10,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
			true,
			10,
			10,
		),
	}
	err := suite.database.SaveValidatorsSigningInfos(infos)
	suite.Require().NoError(err)

	// Verify the data
	expected := []dbtypes.ValidatorSigningInfoRow{
		dbtypes.NewValidatorSigningInfoRow(
			validator1.GetConsAddr(),
			10,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
			true,
			10,
			10,
		),
		dbtypes.NewValidatorSigningInfoRow(
			validator2.GetConsAddr(),
			10,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
			true,
			10,
			10,
		),
	}

	var rows []dbtypes.ValidatorSigningInfoRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM validator_signing_info`)
	suite.Require().NoError(err)

	for i, row := range rows {
		suite.Require().True(expected[i].Equal(row))
	}

	// ----------------------------------------------------------------------------------------------------------------

	// Update the data
	infos = []types.ValidatorSigningInfo{
		types.NewValidatorSigningInfo(
			validator1.GetConsAddr(),
			100,
			10000,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
			true,
			70,
			9,
		),
		types.NewValidatorSigningInfo(
			validator2.GetConsAddr(),
			10,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
			false,
			11,
			11,
		),
	}
	err = suite.database.SaveValidatorsSigningInfos(infos)
	suite.Require().NoError(err)

	// Verify the data
	expected = []dbtypes.ValidatorSigningInfoRow{
		dbtypes.NewValidatorSigningInfoRow(
			validator1.GetConsAddr(),
			10,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
			true,
			10,
			10,
		),
		dbtypes.NewValidatorSigningInfoRow(
			validator2.GetConsAddr(),
			10,
			10,
			time.Date(2020, 10, 10, 15, 00, 00, 000, time.UTC),
			false,
			11,
			11,
		),
	}

	rows = []dbtypes.ValidatorSigningInfoRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM validator_signing_info`)
	suite.Require().NoError(err)

	for i, row := range rows {
		suite.Require().True(expected[i].Equal(row))
	}
}

func (suite *DbTestSuite) TestBigDipperDb_SaveSlashingParams() {
	// Save data
	slashingParams := slashingtypes.Params{
		SignedBlocksWindow:      10,
		MinSignedPerWindow:      sdk.NewDecWithPrec(100, 2),
		DowntimeJailDuration:    10000,
		SlashFractionDoubleSign: sdk.NewDecWithPrec(100, 2),
		SlashFractionDowntime:   sdk.NewDecWithPrec(100, 4),
	}
	params := types.NewSlashingParams(slashingParams, 10)
	err := suite.database.SaveSlashingParams(params)
	suite.Require().NoError(err)

	// Verify data
	var rows []dbtypes.SlashingParamsRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM slashing_params`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)

	var stored slashingtypes.Params
	err = json.Unmarshal([]byte(rows[0].Params), &stored)
	suite.Require().NoError(err)
	suite.Require().Equal(slashingParams, stored)

	// --- Try updating with a lower height ---
	err = suite.database.SaveSlashingParams(types.NewSlashingParams(
		slashingtypes.Params{
			SignedBlocksWindow:      5,
			MinSignedPerWindow:      sdk.NewDecWithPrec(50, 2),
			DowntimeJailDuration:    10000,
			SlashFractionDoubleSign: sdk.NewDecWithPrec(50, 2),
			SlashFractionDowntime:   sdk.NewDecWithPrec(50, 4),
		},
		9,
	))
	suite.Require().NoError(err)

	rows = []dbtypes.SlashingParamsRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM slashing_params`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)

	err = json.Unmarshal([]byte(rows[0].Params), &stored)
	suite.Require().NoError(err)
	suite.Require().Equal(slashingParams, stored)

	// Try updating with same height
	slashingParams = slashingtypes.Params{
		SignedBlocksWindow:      5,
		MinSignedPerWindow:      sdk.NewDecWithPrec(50, 2),
		DowntimeJailDuration:    10000,
		SlashFractionDoubleSign: sdk.NewDecWithPrec(50, 2),
		SlashFractionDowntime:   sdk.NewDecWithPrec(50, 4),
	}
	err = suite.database.SaveSlashingParams(types.NewSlashingParams(slashingParams, 10))
	suite.Require().NoError(err)

	rows = []dbtypes.SlashingParamsRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM slashing_params`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)

	err = json.Unmarshal([]byte(rows[0].Params), &stored)
	suite.Require().NoError(err)
	suite.Require().Equal(slashingParams, stored)

	// Try updating with higher height
	slashingParams = slashingtypes.Params{
		SignedBlocksWindow:      6,
		MinSignedPerWindow:      sdk.NewDecWithPrec(60, 2),
		DowntimeJailDuration:    10000,
		SlashFractionDoubleSign: sdk.NewDecWithPrec(60, 2),
		SlashFractionDowntime:   sdk.NewDecWithPrec(60, 4),
	}
	err = suite.database.SaveSlashingParams(types.NewSlashingParams(slashingParams, 11))
	suite.Require().NoError(err)

	rows = []dbtypes.SlashingParamsRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM slashing_params`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)

	err = json.Unmarshal([]byte(rows[0].Params), &stored)
	suite.Require().NoError(err)
	suite.Require().Equal(slashingParams, stored)
}

'''
'''--- database/staking_params.go ---
package database

import (
	"encoding/json"
	"fmt"

	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
	"github.com/forbole/bdjuno/v5/types"
)

// SaveStakingParams allows to store the given params into the database
func (db *Db) SaveStakingParams(params types.StakingParams) error {
	paramsBz, err := json.Marshal(&params.Params)
	if err != nil {
		return fmt.Errorf("error while marshaling staking params: %s", err)
	}

	stmt := `
INSERT INTO staking_params (params, height) 
VALUES ($1, $2)
ON CONFLICT (one_row_id) DO UPDATE 
    SET params = excluded.params,
        height = excluded.height
WHERE staking_params.height <= excluded.height`

	_, err = db.SQL.Exec(stmt, string(paramsBz), params.Height)
	if err != nil {
		return fmt.Errorf("error while storing staking params: %s", err)
	}

	return nil
}

// GetStakingParams returns the types.StakingParams instance containing the current params
func (db *Db) GetStakingParams() (*types.StakingParams, error) {
	var rows []dbtypes.StakingParamsRow
	stmt := `SELECT * FROM staking_params LIMIT 1`
	err := db.Sqlx.Select(&rows, stmt)
	if err != nil {
		return nil, err
	}

	if len(rows) == 0 {
		return nil, fmt.Errorf("no staking params found")
	}

	var stakingParams stakingtypes.Params
	err = json.Unmarshal([]byte(rows[0].Params), &stakingParams)
	if err != nil {
		return nil, err
	}

	return &types.StakingParams{
		Params: stakingParams,
		Height: rows[0].Height,
	}, nil
}

'''
'''--- database/staking_params_test.go ---
package database_test

import (
	"encoding/json"
	"time"

	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	dbtypes "github.com/forbole/bdjuno/v5/database/types"
	"github.com/forbole/bdjuno/v5/types"
)

func (suite *DbTestSuite) TestSaveStakingParams() {
	stakingParams := stakingtypes.NewParams(
		time.Duration(259200000000000),
		200,
		7,
		10000,
		"uatom",
		sdk.NewDec(1),
	)
	err := suite.database.SaveStakingParams(types.NewStakingParams(stakingParams, 10))
	suite.Require().NoError(err)

	var rows []dbtypes.StakingParamsRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM staking_params`)
	suite.Require().NoError(err)

	suite.Require().Len(rows, 1)

	var stored stakingtypes.Params
	err = json.Unmarshal([]byte(rows[0].Params), &stored)
	suite.Require().NoError(err)
	suite.Require().Equal(stakingParams, stored)
}

func (suite *DbTestSuite) TestGetStakingParams() {
	stakingParams := stakingtypes.NewParams(
		259200000000000,
		200,
		7,
		10000,
		"uatom",
		sdk.NewDec(1),
	)

	paramsBz, err := json.Marshal(&stakingParams)
	suite.Require().NoError(err)

	_, err = suite.database.SQL.Exec(
		`INSERT INTO staking_params (params, height) VALUES ($1, $2)`,
		string(paramsBz), 10,
	)
	suite.Require().NoError(err)

	params, err := suite.database.GetStakingParams()
	suite.Require().NoError(err)

	suite.Require().Equal(&types.StakingParams{
		Params: stakingParams,
		Height: 10,
	}, params)
}

'''
'''--- database/staking_pool.go ---
package database

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/types"
)

// SaveStakingPool allows to save for the given height the given stakingtypes pool
func (db *Db) SaveStakingPool(pool *types.Pool) error {
	stmt := `
INSERT INTO staking_pool (bonded_tokens, not_bonded_tokens, unbonding_tokens, staked_not_bonded_tokens, height) 
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (one_row_id) DO UPDATE 
    SET bonded_tokens = excluded.bonded_tokens, 
        not_bonded_tokens = excluded.not_bonded_tokens, 
		unbonding_tokens = excluded.unbonding_tokens,
		staked_not_bonded_tokens = excluded.staked_not_bonded_tokens,
        height = excluded.height
WHERE staking_pool.height <= excluded.height`

	_, err := db.SQL.Exec(stmt,
		pool.BondedTokens.String(),
		pool.NotBondedTokens.String(),
		pool.UnbondingTokens.String(),
		pool.StakedNotBondedTokens.String(),
		pool.Height)
	if err != nil {
		return fmt.Errorf("error while storing staking pool: %s", err)
	}

	return nil
}

'''
'''--- database/staking_pool_test.go ---
package database_test

import (
	sdk "github.com/cosmos/cosmos-sdk/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
	"github.com/forbole/bdjuno/v5/types"
)

func (suite *DbTestSuite) TestBigDipperDb_SaveStakingPool() {
	// Save the data
	original := types.NewPool(sdk.NewInt(50), sdk.NewInt(100), sdk.NewInt(5), sdk.NewInt(1), 10)
	err := suite.database.SaveStakingPool(original)
	suite.Require().NoError(err)

	// Verify the data
	expected := dbtypes.NewStakingPoolRow(50, 100, 5, 1, 10)

	var rows []dbtypes.StakingPoolRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM staking_pool`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected))

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating using a lower height
	pool := types.NewPool(sdk.NewInt(1), sdk.NewInt(1), sdk.NewInt(1), sdk.NewInt(1), 8)
	err = suite.database.SaveStakingPool(pool)
	suite.Require().NoError(err)

	// Verify the data
	rows = []dbtypes.StakingPoolRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM staking_pool`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with a lower height should not modify the data")

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with the same height
	pool = types.NewPool(sdk.NewInt(1), sdk.NewInt(1), sdk.NewInt(1), sdk.NewInt(1), 10)
	err = suite.database.SaveStakingPool(pool)
	suite.Require().NoError(err)

	// Verify the data
	expected = dbtypes.NewStakingPoolRow(1, 1, 1, 1, 10)

	rows = []dbtypes.StakingPoolRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM staking_pool`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with a lower height should not modify the data")

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with a higher height
	pool = types.NewPool(sdk.NewInt(1000000), sdk.NewInt(1000000), sdk.NewInt(20), sdk.NewInt(15), 20)
	err = suite.database.SaveStakingPool(pool)
	suite.Require().NoError(err)

	// Verify the data
	expected = dbtypes.NewStakingPoolRow(1000000, 1000000, 20, 15, 20)

	rows = []dbtypes.StakingPoolRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM staking_pool`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, 1)
	suite.Require().True(rows[0].Equal(expected), "updating with a lower height should not modify the data")
}

'''
'''--- database/staking_validators.go ---
package database

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
)

// SaveValidatorData saves properly the information about the given validator.
func (db *Db) SaveValidatorData(validator types.Validator) error {
	return db.SaveValidatorsData([]types.Validator{validator})
}

// SaveValidatorsData allows the bulk saving of a list of validators.
func (db *Db) SaveValidatorsData(validators []types.Validator) error {
	if len(validators) == 0 {
		return nil
	}

	selfDelegationAccQuery := `
INSERT INTO account (address) VALUES `
	var selfDelegationParam []interface{}

	validatorQuery := `
INSERT INTO validator (consensus_address, consensus_pubkey) VALUES `
	var validatorParams []interface{}

	validatorInfoQuery := `
INSERT INTO validator_info (consensus_address, operator_address, self_delegate_address, max_change_rate, max_rate, height) 
VALUES `
	var validatorInfoParams []interface{}

	for i, validator := range validators {
		vp := i * 2 // Starting position for validator params
		vi := i * 6 // Starting position for validator info params

		selfDelegationAccQuery += fmt.Sprintf("($%d),", i+1)
		selfDelegationParam = append(selfDelegationParam,
			validator.GetSelfDelegateAddress())

		validatorQuery += fmt.Sprintf("($%d,$%d),", vp+1, vp+2)
		validatorParams = append(validatorParams,
			validator.GetConsAddr(), validator.GetConsPubKey())

		validatorInfoQuery += fmt.Sprintf("($%d,$%d,$%d,$%d,$%d,$%d),", vi+1, vi+2, vi+3, vi+4, vi+5, vi+6)
		validatorInfoParams = append(validatorInfoParams,
			validator.GetConsAddr(), validator.GetOperator(), validator.GetSelfDelegateAddress(),
			validator.GetMaxChangeRate().String(), validator.GetMaxRate().String(), validator.GetHeight(),
		)
	}

	selfDelegationAccQuery = selfDelegationAccQuery[:len(selfDelegationAccQuery)-1] // Remove trailing ","
	selfDelegationAccQuery += " ON CONFLICT DO NOTHING"
	_, err := db.SQL.Exec(selfDelegationAccQuery, selfDelegationParam...)
	if err != nil {
		return fmt.Errorf("error while storing accounts: %s", err)
	}

	validatorQuery = validatorQuery[:len(validatorQuery)-1] // Remove trailing ","
	validatorQuery += " ON CONFLICT DO NOTHING"
	_, err = db.SQL.Exec(validatorQuery, validatorParams...)
	if err != nil {
		return fmt.Errorf("error while storing valdiators: %s", err)
	}

	validatorInfoQuery = validatorInfoQuery[:len(validatorInfoQuery)-1] // Remove the trailing ","
	validatorInfoQuery += `
ON CONFLICT (consensus_address) DO UPDATE 
	SET consensus_address = excluded.consensus_address,
		operator_address = excluded.operator_address,
		self_delegate_address = excluded.self_delegate_address,
		max_change_rate = excluded.max_change_rate,
		max_rate = excluded.max_rate,
		height = excluded.height
WHERE validator_info.height <= excluded.height`
	_, err = db.SQL.Exec(validatorInfoQuery, validatorInfoParams...)
	if err != nil {
		return fmt.Errorf("error while storing validator infos: %s", err)
	}

	return nil
}

// GetValidatorConsensusAddress returns the consensus address of the validator having the given operator address
func (db *Db) GetValidatorConsensusAddress(address string) (sdk.ConsAddress, error) {
	var result []string
	stmt := `SELECT consensus_address FROM validator_info WHERE operator_address = $1`
	err := db.Sqlx.Select(&result, stmt, address)
	if err != nil {
		return nil, err
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("cannot find the consensus address of validator having operator address %s", address)
	}

	return sdk.ConsAddressFromBech32(result[0])
}

// GetValidatorOperatorAddress returns the operator address of the validator having the given consensus address
func (db *Db) GetValidatorOperatorAddress(consAddr string) (sdk.ValAddress, error) {
	var result []string
	stmt := `SELECT operator_address FROM validator_info WHERE consensus_address = $1`
	err := db.Sqlx.Select(&result, stmt, consAddr)
	if err != nil {
		return nil, err
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("cannot find the operator address of validator having consensus address %s", consAddr)
	}

	return sdk.ValAddressFromBech32(result[0])

}

// GetValidator returns the validator having the given address.
// If no validator for such address can be found, an error is returned instead.
func (db *Db) GetValidator(valAddress string) (types.Validator, error) {
	var result []dbtypes.ValidatorData
	stmt := `
SELECT validator.consensus_address, 
       validator.consensus_pubkey, 
       validator_info.operator_address, 
       validator_info.max_change_rate, 
       validator_info.max_rate,
       validator_info.self_delegate_address
FROM validator INNER JOIN validator_info ON validator.consensus_address=validator_info.consensus_address 
WHERE validator_info.operator_address = $1`

	err := db.Sqlx.Select(&result, stmt, valAddress)
	if err != nil {
		return nil, err
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("no validator with validator address %s could be found", valAddress)
	}

	return result[0], nil
}

// GetValidators returns all the validators that are currently stored inside the database.
func (db *Db) GetValidators() ([]types.Validator, error) {
	sqlStmt := `
SELECT DISTINCT ON (validator.consensus_address) 
	validator.consensus_address, 
    validator.consensus_pubkey,
    validator_info.operator_address,
    validator_info.self_delegate_address,                                             
    validator_info.max_rate,
    validator_info.max_change_rate,
    validator_info.height
FROM validator 
INNER JOIN validator_info 
    ON validator.consensus_address = validator_info.consensus_address
ORDER BY validator.consensus_address`

	var rows []dbtypes.ValidatorData
	err := db.Sqlx.Select(&rows, sqlStmt)
	if err != nil {
		return nil, err
	}

	var data = make([]types.Validator, len(rows))
	for index, row := range rows {
		data[index] = row
	}

	return data, nil
}

// GetValidatorBySelfDelegateAddress returns the validator having the given address as the self_delegate_address,
// or an error if such validator cannot be found.
func (db *Db) GetValidatorBySelfDelegateAddress(address string) (types.Validator, error) {
	var result []dbtypes.ValidatorData
	stmt := `
SELECT validator.consensus_address, 
       validator.consensus_pubkey, 
       validator_info.operator_address, 
       validator_info.max_change_rate, 
       validator_info.max_rate,
       validator_info.self_delegate_address
FROM validator INNER JOIN validator_info ON validator.consensus_address=validator_info.consensus_address 
WHERE validator_info.self_delegate_address = $1`

	err := db.Sqlx.Select(&result, stmt, address)
	if err != nil {
		return nil, err
	}

	if len(result) == 0 {
		return nil, fmt.Errorf("no validator with self delegate address %s could be found", address)
	}

	return result[0], nil
}

// --------------------------------------------------------------------------------------------------------------------

// SaveValidatorDescription save a single validator description.
// It assumes that the delegator address is already present inside the
// proper database table.
// TIP: To store the validator data call SaveValidatorData.
func (db *Db) SaveValidatorDescription(description types.ValidatorDescription) error {
	consAddr, err := db.GetValidatorConsensusAddress(description.OperatorAddress)
	if err != nil {
		return err
	}

	des, err := description.Description.EnsureLength()
	if err != nil {
		return err
	}

	// Update the existing description with this one, if one is already present
	var avatarURL = description.AvatarURL
	if existing, found := db.getValidatorDescription(consAddr); found {
		des, err = existing.Description.UpdateDescription(des)
		if err != nil {
			return err
		}

		if description.AvatarURL == stakingtypes.DoNotModifyDesc {
			avatarURL = existing.AvatarURL
		}
	}

	// Insert the description
	stmt := `
INSERT INTO validator_description (
	validator_address, moniker, identity, avatar_url, website, security_contact, details, height
)
VALUES($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (validator_address) DO UPDATE
    SET moniker = excluded.moniker, 
        identity = excluded.identity, 
        avatar_url = excluded.avatar_url,
        website = excluded.website, 
        security_contact = excluded.security_contact, 
        details = excluded.details,
        height = excluded.height
WHERE validator_description.height <= excluded.height`

	_, err = db.SQL.Exec(stmt,
		dbtypes.ToNullString(consAddr.String()),
		dbtypes.ToNullString(des.Moniker),
		dbtypes.ToNullString(des.Identity),
		dbtypes.ToNullString(avatarURL),
		dbtypes.ToNullString(des.Website),
		dbtypes.ToNullString(des.SecurityContact),
		dbtypes.ToNullString(des.Details),
		description.Height,
	)
	if err != nil {
		return fmt.Errorf("error while storing validator description: %s", err)
	}

	return nil
}

// getValidatorDescription returns the description of the validator having the given address.
// If no description could be found, returns false instead
func (db *Db) getValidatorDescription(address sdk.ConsAddress) (*types.ValidatorDescription, bool) {
	var result []dbtypes.ValidatorDescriptionRow
	stmt := `SELECT * FROM validator_description WHERE validator_description.validator_address = $1`

	err := db.Sqlx.Select(&result, stmt, address.String())
	if err != nil {
		return nil, false
	}

	if len(result) == 0 {
		return nil, false
	}

	row := result[0]
	description := types.NewValidatorDescription(
		row.ValAddress,
		stakingtypes.NewDescription(
			dbtypes.ToString(row.Moniker),
			dbtypes.ToString(row.Identity),
			dbtypes.ToString(row.Website),
			dbtypes.ToString(row.SecurityContact),
			dbtypes.ToString(row.Details),
		),
		dbtypes.ToString(row.AvatarURL),
		row.Height,
	)
	return &description, true
}

// --------------------------------------------------------------------------------------------------------------------

// SaveValidatorCommission saves a single validator commission.
// It assumes that the delegator address is already present inside the
// proper database table.
// TIP: To store the validator data call SaveValidatorData.
func (db *Db) SaveValidatorCommission(data types.ValidatorCommission) error {
	if data.MinSelfDelegation == nil && data.Commission == nil {
		// Nothing to update
		return nil
	}

	consAddr, err := db.GetValidatorConsensusAddress(data.ValAddress)
	if err != nil {
		return err
	}

	// Get the existing data, if any
	var commission, minSelfDelegation string
	if existing, found := db.getValidatorCommission(consAddr); found {
		if existing.Commission.Valid {
			commission = existing.Commission.String
		}
		if existing.MinSelfDelegation.Valid {
			minSelfDelegation = existing.MinSelfDelegation.String
		}
	}

	// Replace the existing with the current one
	if data.Commission != nil {
		commission = data.Commission.String()
	}
	if data.MinSelfDelegation != nil {
		minSelfDelegation = data.MinSelfDelegation.String()
	}

	// Update the current value
	stmt := `
INSERT INTO validator_commission (validator_address, commission, min_self_delegation, height) 
VALUES ($1, $2, $3, $4)
ON CONFLICT (validator_address) DO UPDATE 
    SET commission = excluded.commission, 
        min_self_delegation = excluded.min_self_delegation,
        height = excluded.height
WHERE validator_commission.height <= excluded.height`
	_, err = db.SQL.Exec(stmt, consAddr.String(), commission, minSelfDelegation, data.Height)
	if err != nil {
		return fmt.Errorf("error while storing validator commission: %s", err)
	}

	return nil
}

// getValidatorCommission returns the commissions of the validator having the given address.
// If no commissions could be found, returns false instead
func (db *Db) getValidatorCommission(address sdk.ConsAddress) (*dbtypes.ValidatorCommissionRow, bool) {
	var rows []dbtypes.ValidatorCommissionRow
	stmt := `SELECT * FROM validator_commission WHERE validator_address = $1`
	err := db.Sqlx.Select(&rows, stmt, address.String())
	if err != nil || len(rows) == 0 {
		return nil, false
	}

	return &rows[0], true
}

// --------------------------------------------------------------------------------------------------------------------

// SaveValidatorsVotingPowers saves the given validator voting powers.
// It assumes that the delegator address is already present inside the
// proper database table.
// TIP: To store the validator data call SaveValidatorData.
func (db *Db) SaveValidatorsVotingPowers(entries []types.ValidatorVotingPower) error {
	if len(entries) == 0 {
		return nil
	}

	stmt := `INSERT INTO validator_voting_power (validator_address, voting_power, height) VALUES `
	var params []interface{}

	for i, entry := range entries {
		pi := i * 3
		stmt += fmt.Sprintf("($%d,$%d,$%d),", pi+1, pi+2, pi+3)
		params = append(params, entry.ConsensusAddress, entry.VotingPower, entry.Height)
	}

	stmt = stmt[:len(stmt)-1]
	stmt += `
ON CONFLICT (validator_address) DO UPDATE 
	SET voting_power = excluded.voting_power, 
		height = excluded.height
WHERE validator_voting_power.height <= excluded.height`

	_, err := db.SQL.Exec(stmt, params...)
	if err != nil {
		return fmt.Errorf("error while storing validators voting power: %s", err)
	}

	return nil
}

// --------------------------------------------------------------------------------------------------------------------

// SaveValidatorsStatuses save validator jail and status in the given height and timestamp
func (db *Db) SaveValidatorsStatuses(statuses []types.ValidatorStatus) error {
	if len(statuses) == 0 {
		return nil
	}

	validatorStmt := `INSERT INTO validator (consensus_address, consensus_pubkey) VALUES`
	var valParams []interface{}

	statusStmt := `INSERT INTO validator_status (validator_address, status, jailed, height) VALUES `
	var statusParams []interface{}

	for i, status := range statuses {
		vi := i * 2
		validatorStmt += fmt.Sprintf("($%d, $%d),", vi+1, vi+2)
		valParams = append(valParams, status.ConsensusAddress, status.ConsensusPubKey)

		si := i * 4
		statusStmt += fmt.Sprintf("($%d,$%d,$%d,$%d),", si+1, si+2, si+3, si+4)
		statusParams = append(statusParams, status.ConsensusAddress, status.Status, status.Jailed, status.Height)
	}

	validatorStmt = validatorStmt[:len(validatorStmt)-1]
	validatorStmt += "ON CONFLICT DO NOTHING"
	_, err := db.SQL.Exec(validatorStmt, valParams...)
	if err != nil {
		return fmt.Errorf("error while storing validators: %s", err)
	}

	statusStmt = statusStmt[:len(statusStmt)-1]
	statusStmt += `
ON CONFLICT (validator_address) DO UPDATE 
	SET status = excluded.status,
	    jailed = excluded.jailed,
	    height = excluded.height
WHERE validator_status.height <= excluded.height`
	_, err = db.SQL.Exec(statusStmt, statusParams...)
	if err != nil {
		return fmt.Errorf("error while stroring validators statuses: %s", err)
	}

	return nil
}

// saveDoubleSignVote saves the given vote inside the database, returning the row id
func (db *Db) saveDoubleSignVote(vote types.DoubleSignVote) (int64, error) {
	stmt := `
INSERT INTO double_sign_vote 
    (type, height, round, block_id, validator_address, validator_index, signature) 
VALUES ($1, $2, $3, $4, $5, $6, $7) ON CONFLICT DO NOTHING RETURNING id`

	var id int64
	err := db.SQL.QueryRow(stmt,
		vote.Type, vote.Height, vote.Round, vote.BlockID, vote.ValidatorAddress, vote.ValidatorIndex, vote.Signature,
	).Scan(&id)
	return id, err
}

// SaveDoubleSignEvidence saves the given double sign evidence inside the proper tables
func (db *Db) SaveDoubleSignEvidence(evidence types.DoubleSignEvidence) error {
	voteA, err := db.saveDoubleSignVote(evidence.VoteA)
	if err != nil {
		return fmt.Errorf("error while storing double sign vote: %s", err)
	}

	voteB, err := db.saveDoubleSignVote(evidence.VoteB)
	if err != nil {
		return fmt.Errorf("error while storing double sign vote: %s", err)
	}

	stmt := `
INSERT INTO double_sign_evidence (height, vote_a_id, vote_b_id) 
VALUES ($1, $2, $3) ON CONFLICT DO NOTHING`
	_, err = db.SQL.Exec(stmt, evidence.Height, voteA, voteB)
	if err != nil {
		return fmt.Errorf("error while storing double sign evidence: %s", err)
	}

	return nil
}

'''
'''--- database/staking_validators_test.go ---
package database_test

import (
	tmtypes "github.com/tendermint/tendermint/proto/tendermint/types"

	"github.com/forbole/bdjuno/v5/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"

	dbtypes "github.com/forbole/bdjuno/v5/database/types"
)

func newDecPts(value int64, prec int64) *sdk.Dec {
	dec := sdk.NewDecWithPrec(value, prec)
	return &dec
}

func newIntPtr(value int64) *sdk.Int {
	val := sdk.NewInt(value)
	return &val
}

// -----------------------------------------------------------

func (suite *DbTestSuite) TestSaveValidator() {
	expectedMaxRate := sdk.NewDec(int64(1))
	expectedMaxChangeRate := sdk.NewDec(int64(2))

	suite.getAccount("cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs")
	validator := dbtypes.NewValidatorData(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
		"cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs",
		"1",
		"2",
		1,
	)

	// First inserting
	err := suite.database.SaveValidatorData(validator)

	// Test double inserting
	err = suite.database.SaveValidatorData(validator)
	suite.Require().NoError(err, "inserting the same validator info twice should return no error")

	// Verify the data
	var valRows []dbtypes.ValidatorRow
	err = suite.database.Sqlx.Select(&valRows, `SELECT * FROM validator`)
	suite.Require().Len(valRows, 1)
	suite.Require().True(valRows[0].Equal(dbtypes.NewValidatorRow(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
	)))

	var valInfoRows []dbtypes.ValidatorInfoRow
	err = suite.database.Sqlx.Select(&valInfoRows, `SELECT * FROM validator_info`)
	suite.Require().Len(valInfoRows, 1)
	suite.Require().True(valInfoRows[0].Equal(dbtypes.NewValidatorInfoRow(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		"cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs",
		expectedMaxRate.String(),
		expectedMaxChangeRate.String(),
		1,
	)))
}

func (suite *DbTestSuite) TestSaveValidators() {
	suite.getAccount("cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs")
	suite.getAccount("cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a")

	// Insert the data
	validators := []types.Validator{
		dbtypes.NewValidatorData(
			"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
			"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
			"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
			"cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs",
			"1",
			"2",
			10,
		),
		dbtypes.NewValidatorData(
			"cosmosvalcons1qq92t2l4jz5pt67tmts8ptl4p0jhr6utx5xa8y",
			"cosmosvaloper1000ya26q2cmh399q4c5aaacd9lmmdqp90kw2jn",
			"cosmosvalconspub1zcjduepqe93asg05nlnj30ej2pe3r8rkeryyuflhtfw3clqjphxn4j3u27msrr63nk",
			"cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a",
			"1",
			"2",
			10,
		),
	}
	err := suite.database.SaveValidatorsData(validators)
	suite.Require().NoError(err)

	// Verify the data
	expected := []dbtypes.ValidatorInfoRow{
		dbtypes.NewValidatorInfoRow(
			"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
			"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
			"cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs",
			sdk.NewDec(int64(1)).String(),
			sdk.NewDec(int64(2)).String(),
			10,
		),
		dbtypes.NewValidatorInfoRow(
			"cosmosvalcons1qq92t2l4jz5pt67tmts8ptl4p0jhr6utx5xa8y",
			"cosmosvaloper1000ya26q2cmh399q4c5aaacd9lmmdqp90kw2jn",
			"cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a",
			sdk.NewDec(int64(1)).String(),
			sdk.NewDec(int64(2)).String(),
			10,
		),
	}

	var validatorRows []dbtypes.ValidatorRow
	err = suite.database.Sqlx.Select(&validatorRows, `SELECT * FROM validator`)
	suite.Require().NoError(err)
	suite.Require().Len(validatorRows, 2)

	var validatorInfoRows []dbtypes.ValidatorInfoRow
	err = suite.database.Sqlx.Select(&validatorInfoRows, `SELECT * FROM validator_info`)
	suite.Require().NoError(err)
	suite.Require().Len(validatorInfoRows, 2)

	for index, v := range validatorRows {
		w := validators[index]
		suite.Require().Equal(v.ConsAddress, w.GetConsAddr())
		suite.Require().Equal(v.ConsPubKey, w.GetConsPubKey())

		wInfo := validatorInfoRows[index]
		suite.Require().True(wInfo.Equal(expected[index]))
	}

	// --------------------------------------------------------------------------------------------------------------

	// Update the data
	validators = []types.Validator{
		dbtypes.NewValidatorData(
			"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
			"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
			"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
			"cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs",
			"100",
			"200",
			9,
		),
		dbtypes.NewValidatorData(
			"cosmosvalcons1qq92t2l4jz5pt67tmts8ptl4p0jhr6utx5xa8y",
			"cosmosvaloper1000ya26q2cmh399q4c5aaacd9lmmdqp90kw2jn",
			"cosmosvalconspub1zcjduepqe93asg05nlnj30ej2pe3r8rkeryyuflhtfw3clqjphxn4j3u27msrr63nk",
			"cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a",
			"10",
			"5",
			11,
		),
	}
	err = suite.database.SaveValidatorsData(validators)
	suite.Require().NoError(err)

	// Verify the data
	expected = []dbtypes.ValidatorInfoRow{
		dbtypes.NewValidatorInfoRow(
			"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
			"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
			"cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs",
			sdk.NewDec(int64(1)).String(),
			sdk.NewDec(int64(2)).String(),
			10,
		),
		dbtypes.NewValidatorInfoRow(
			"cosmosvalcons1qq92t2l4jz5pt67tmts8ptl4p0jhr6utx5xa8y",
			"cosmosvaloper1000ya26q2cmh399q4c5aaacd9lmmdqp90kw2jn",
			"cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a",
			sdk.NewDec(int64(10)).String(),
			sdk.NewDec(int64(5)).String(),
			11,
		),
	}

	validatorRows = []dbtypes.ValidatorRow{}
	err = suite.database.Sqlx.Select(&validatorRows, `SELECT * FROM validator`)
	suite.Require().NoError(err)
	suite.Require().Len(validatorRows, 2)

	validatorInfoRows = []dbtypes.ValidatorInfoRow{}
	err = suite.database.Sqlx.Select(&validatorInfoRows, `SELECT * FROM validator_info`)
	suite.Require().NoError(err)
	suite.Require().Len(validatorInfoRows, 2)

	for index, v := range validatorRows {
		w := validators[index]
		suite.Require().Equal(v.ConsAddress, w.GetConsAddr())
		suite.Require().Equal(v.ConsPubKey, w.GetConsPubKey())

		wInfo := validatorInfoRows[index]
		suite.Require().True(wInfo.Equal(expected[index]))
	}
}

func (suite *DbTestSuite) TestGetValidator() {
	var i int64 = 1
	var ii int64 = 2
	maxRate := sdk.NewDec(i)
	maxChangeRate := sdk.NewDec(ii)
	suite.getAccount("cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a")
	// Insert test data
	_, err := suite.database.SQL.Exec(`
INSERT INTO validator (consensus_address, consensus_pubkey) 
VALUES ('cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl', 
        'cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8')`)
	suite.Require().NoError(err)

	_, err = suite.database.SQL.Exec(`
INSERT INTO validator_info (consensus_address, operator_address,self_delegate_address,max_change_rate,max_rate,height) 
VALUES ('cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl',
        'cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl',
        'cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a',
        '2','1', '1')`)
	suite.Require().NoError(err)

	// Get the data
	validator, err := suite.database.GetValidator("cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl")
	suite.Require().NoError(err)
	suite.Require().Equal(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		validator.GetConsAddr(),
	)
	suite.Require().Equal(
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		validator.GetOperator(),
	)
	suite.Require().Equal(
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
		validator.GetConsPubKey(),
	)

	suite.Require().Equal("cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a", validator.GetSelfDelegateAddress())
	suite.Require().True(validator.GetMaxChangeRate().Equal(maxChangeRate))
	suite.Require().True(validator.GetMaxRate().Equal(maxRate))

}

func (suite *DbTestSuite) TestGetValidators() {
	suite.getAccount("cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs")
	suite.getAccount("cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a")
	// Inser the test data
	queries := []string{
		`INSERT INTO validator (consensus_address, consensus_pubkey) VALUES ('cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl', 'cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8')`,
		`INSERT INTO validator (consensus_address, consensus_pubkey) VALUES ('cosmosvalcons1qq92t2l4jz5pt67tmts8ptl4p0jhr6utx5xa8y', 'cosmosvalconspub1zcjduepqe93asg05nlnj30ej2pe3r8rkeryyuflhtfw3clqjphxn4j3u27msrr63nk')`,
		`INSERT INTO validator_info (consensus_address, operator_address,self_delegate_address,max_rate,max_change_rate,height) VALUES ('cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl', 'cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl','cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs','1','2',1)`,
		`INSERT INTO validator_info (consensus_address, operator_address,self_delegate_address,max_rate,max_change_rate,height) VALUES ('cosmosvalcons1qq92t2l4jz5pt67tmts8ptl4p0jhr6utx5xa8y', 'cosmosvaloper1000ya26q2cmh399q4c5aaacd9lmmdqp90kw2jn','cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a','1','2',1)`,
	}

	for _, query := range queries {
		_, err := suite.database.SQL.Exec(query)
		suite.Require().NoError(err)
	}

	// Get the data
	data, err := suite.database.GetValidators()
	suite.Require().NoError(err)

	// Verify
	expected := []dbtypes.ValidatorData{
		dbtypes.NewValidatorData(
			"cosmosvalcons1qq92t2l4jz5pt67tmts8ptl4p0jhr6utx5xa8y",
			"cosmosvaloper1000ya26q2cmh399q4c5aaacd9lmmdqp90kw2jn",
			"cosmosvalconspub1zcjduepqe93asg05nlnj30ej2pe3r8rkeryyuflhtfw3clqjphxn4j3u27msrr63nk",
			"cosmos184ma3twcfjqef6k95ne8w2hk80x2kah7vcwy4a",
			"1",
			"2",
			1,
		),
		dbtypes.NewValidatorData(
			"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
			"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
			"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
			"cosmos1z4hfrxvlgl4s8u4n5ngjcw8kdqrcv43599amxs",
			"1",
			"2",
			1,
		),
	}

	suite.Require().Len(data, len(expected))
	for index, validator := range data {
		suite.Require().Equal(expected[index], validator)
	}
}

// -----------------------------------------------------------

func (suite *DbTestSuite) TestSaveValidatorDescription() {
	validator := suite.getValidator(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
	)

	// Save the data
	description := types.NewValidatorDescription(
		validator.GetOperator(),
		stakingtypes.NewDescription(
			"moniker",
			"identity",
			"",
			"securityContact",
			"details",
		),
		"avatar-url",
		10,
	)
	err := suite.database.SaveValidatorDescription(description)
	suite.Require().NoError(err)

	// Verify the data
	expected := []dbtypes.ValidatorDescriptionRow{
		dbtypes.NewValidatorDescriptionRow(
			validator.GetConsAddr(),
			"moniker",
			"identity",
			"avatar-url",
			"",
			"securityContact",
			"details",
			10,
		),
	}

	var rows []dbtypes.ValidatorDescriptionRow
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM validator_description")
	suite.Require().NoError(err)
	suite.Require().Len(rows, len(expected))

	for index, expected := range expected {
		suite.Require().True(expected.Equals(rows[index]))
	}

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with lower height
	description = types.NewValidatorDescription(
		validator.GetOperator(),
		stakingtypes.NewDescription("moniker", "", "", "", ""),
		"lower-avatar-url",
		9,
	)
	err = suite.database.SaveValidatorDescription(description)
	suite.Require().NoError(err)

	// Verify the data
	rows = []dbtypes.ValidatorDescriptionRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM validator_description")
	suite.Require().NoError(err)
	suite.Require().Len(rows, len(expected))

	for index, expected := range expected {
		suite.Require().True(expected.Equals(rows[index]))
	}

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with same height
	description = types.NewValidatorDescription(
		validator.GetOperator(),
		stakingtypes.NewDescription("moniker", "", "", "", ""),
		"new-avatar-url",
		10,
	)
	err = suite.database.SaveValidatorDescription(description)
	suite.Require().NoError(err)

	// Verify the data
	expected = []dbtypes.ValidatorDescriptionRow{
		dbtypes.NewValidatorDescriptionRow(
			validator.GetConsAddr(),
			"moniker",
			"",
			"new-avatar-url",
			"",
			"",
			"",
			10,
		),
	}

	rows = []dbtypes.ValidatorDescriptionRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM validator_description")
	suite.Require().NoError(err)
	suite.Require().Len(rows, len(expected))

	for index, expected := range expected {
		suite.Require().True(expected.Equals(rows[index]))
	}

	// ----------------------------------------------------------------------------------------------------------------

	// Try updating with higher height
	description = types.NewValidatorDescription(
		validator.GetOperator(),
		stakingtypes.NewDescription("moniker", "higher-identity", "higher-website", "", ""),
		"higher-avatar-url",
		11,
	)
	err = suite.database.SaveValidatorDescription(description)
	suite.Require().NoError(err)

	// Verify the data
	expected = []dbtypes.ValidatorDescriptionRow{
		dbtypes.NewValidatorDescriptionRow(
			validator.GetConsAddr(),
			"moniker",
			"higher-identity",
			"higher-avatar-url",
			"higher-website",
			"",
			"",
			11,
		),
	}

	rows = []dbtypes.ValidatorDescriptionRow{}
	err = suite.database.Sqlx.Select(&rows, "SELECT * FROM validator_description")
	suite.Require().NoError(err)
	suite.Require().Len(rows, len(expected))

	for index, expected := range expected {
		suite.Require().True(expected.Equals(rows[index]))
	}
}

// -----------------------------------------------------------

func (suite *DbTestSuite) TestSaveValidatorCommission() {
	validator := suite.getValidator(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
	)

	// Save the data
	err := suite.database.SaveValidatorCommission(types.NewValidatorCommission(
		validator.GetOperator(),
		newDecPts(11, 3),
		newIntPtr(12),
		10,
	))
	suite.Require().NoError(err)

	// Verify the data
	expected := []dbtypes.ValidatorCommissionRow{
		dbtypes.NewValidatorCommissionRow(
			validator.GetConsAddr(),
			"0.011000000000000000",
			"12",
			10,
		),
	}

	var rows []dbtypes.ValidatorCommissionRow
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM validator_commission`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, len(expected))

	for index, expected := range expected {
		suite.Require().True(expected.Equal(rows[index]))
	}

	// -------------------------------------------------------------------------------------------------------------

	// Try updating with a lowe height
	err = suite.database.SaveValidatorCommission(types.NewValidatorCommission(
		validator.GetOperator(),
		newDecPts(50, 3),
		newIntPtr(100),
		9,
	))
	suite.Require().NoError(err)

	// Verify the data
	rows = []dbtypes.ValidatorCommissionRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM validator_commission`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, len(expected))

	for index, expected := range expected {
		suite.Require().True(expected.Equal(rows[index]))
	}

	// -------------------------------------------------------------------------------------------------------------

	// Try updating with the same height
	err = suite.database.SaveValidatorCommission(types.NewValidatorCommission(
		validator.GetOperator(),
		newDecPts(50, 3),
		newIntPtr(100),
		10,
	))
	suite.Require().NoError(err)

	// Verify the data
	expected = []dbtypes.ValidatorCommissionRow{
		dbtypes.NewValidatorCommissionRow(
			validator.GetConsAddr(),
			"0.050000000000000000",
			"100",
			10,
		),
	}

	rows = []dbtypes.ValidatorCommissionRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM validator_commission`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, len(expected))

	for index, expected := range expected {
		suite.Require().True(expected.Equal(rows[index]))
	}

	// -------------------------------------------------------------------------------------------------------------

	// Try updating with a higher height
	err = suite.database.SaveValidatorCommission(types.NewValidatorCommission(
		validator.GetOperator(),
		newDecPts(70, 2),
		newIntPtr(200),
		11,
	))
	suite.Require().NoError(err)

	// Verify the data
	expected = []dbtypes.ValidatorCommissionRow{
		dbtypes.NewValidatorCommissionRow(
			validator.GetConsAddr(),
			"0.700000000000000000",
			"200",
			11,
		),
	}

	rows = []dbtypes.ValidatorCommissionRow{}
	err = suite.database.Sqlx.Select(&rows, `SELECT * FROM validator_commission`)
	suite.Require().NoError(err)
	suite.Require().Len(rows, len(expected))

	for index, expected := range expected {
		suite.Require().True(expected.Equal(rows[index]))
	}
}

// -----------------------------------------------------------

func (suite *DbTestSuite) TestSaveValidatorsVotingPowers() {
	_ = suite.getBlock(9)
	_ = suite.getBlock(10)
	_ = suite.getBlock(11)

	validator1 := suite.getValidator(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
	)
	validator2 := suite.getValidator(
		"cosmosvalcons1qq92t2l4jz5pt67tmts8ptl4p0jhr6utx5xa8y",
		"cosmosvaloper1000ya26q2cmh399q4c5aaacd9lmmdqp90kw2jn",
		"cosmosvalconspub1zcjduepqe93asg05nlnj30ej2pe3r8rkeryyuflhtfw3clqjphxn4j3u27msrr63nk",
	)

	// Save data
	err := suite.database.SaveValidatorsVotingPowers([]types.ValidatorVotingPower{
		types.NewValidatorVotingPower(validator1.GetConsAddr(), 1000, 10),
		types.NewValidatorVotingPower(validator2.GetConsAddr(), 2000, 10),
	})
	suite.Require().NoError(err)

	// Verify the data
	expected := []dbtypes.ValidatorVotingPowerRow{
		dbtypes.NewValidatorVotingPowerRow(validator1.GetConsAddr(), 1000, 10),
		dbtypes.NewValidatorVotingPowerRow(validator2.GetConsAddr(), 2000, 10),
	}

	var result []dbtypes.ValidatorVotingPowerRow
	err = suite.database.Sqlx.Select(&result, "SELECT * FROM validator_voting_power")
	suite.Require().NoError(err)

	for index, row := range result {
		suite.Require().True(row.Equal(expected[index]))
	}

	// Update the data
	err = suite.database.SaveValidatorsVotingPowers([]types.ValidatorVotingPower{
		types.NewValidatorVotingPower(validator1.GetConsAddr(), 5, 9),
		types.NewValidatorVotingPower(validator2.GetConsAddr(), 10, 11),
	})
	suite.Require().NoError(err)

	// Verify the data
	expected = []dbtypes.ValidatorVotingPowerRow{
		dbtypes.NewValidatorVotingPowerRow(validator1.GetConsAddr(), 1000, 10),
		dbtypes.NewValidatorVotingPowerRow(validator2.GetConsAddr(), 10, 11),
	}

	result = []dbtypes.ValidatorVotingPowerRow{}
	err = suite.database.Sqlx.Select(&result, "SELECT * FROM validator_voting_power")
	suite.Require().NoError(err)

	for index, row := range result {
		suite.Require().True(row.Equal(expected[index]))
	}
}

// -----------------------------------------------------------

func (suite *DbTestSuite) TestSaveValidatorStatus() {
	validator1 := suite.getValidator(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
	)
	validator2 := suite.getValidator(
		"cosmosvalcons1qq92t2l4jz5pt67tmts8ptl4p0jhr6utx5xa8y",
		"cosmosvaloper1000ya26q2cmh399q4c5aaacd9lmmdqp90kw2jn",
		"cosmosvalconspub1zcjduepqe93asg05nlnj30ej2pe3r8rkeryyuflhtfw3clqjphxn4j3u27msrr63nk",
	)

	// Save the data
	err := suite.database.SaveValidatorsStatuses([]types.ValidatorStatus{
		types.NewValidatorStatus(
			validator1.GetConsAddr(),
			validator1.GetConsPubKey(),
			1,
			false,
			10,
		),
		types.NewValidatorStatus(
			validator2.GetConsAddr(),
			validator2.GetConsPubKey(),
			2,
			true,
			10,
		),
	})
	suite.Require().NoError(err)

	// Verify the data
	var stored []dbtypes.ValidatorStatusRow
	err = suite.database.Sqlx.Select(&stored, "SELECT * FROM validator_status")
	suite.Require().NoError(err)

	expected := []dbtypes.ValidatorStatusRow{
		dbtypes.NewValidatorStatusRow(
			1,
			false,
			validator1.GetConsAddr(),
			10,
		),
		dbtypes.NewValidatorStatusRow(
			2,
			true,
			validator2.GetConsAddr(),
			10,
		),
	}
	suite.Require().Len(stored, len(expected))
	for index, stored := range stored {
		suite.Require().True(stored.Equal(expected[index]))
	}

	// Update the data
	err = suite.database.SaveValidatorsStatuses([]types.ValidatorStatus{
		types.NewValidatorStatus(
			validator1.GetConsAddr(),
			validator1.GetConsPubKey(),
			3,
			true,
			9,
		),
		types.NewValidatorStatus(
			validator2.GetConsAddr(),
			validator2.GetConsPubKey(),
			3,
			true,
			11,
		),
	})
	suite.Require().NoError(err)

	// Verify the data
	stored = []dbtypes.ValidatorStatusRow{}
	err = suite.database.Sqlx.Select(&stored, "SELECT * FROM validator_status")
	suite.Require().NoError(err)

	expected = []dbtypes.ValidatorStatusRow{
		dbtypes.NewValidatorStatusRow(
			1,
			false,
			validator1.GetConsAddr(),
			10,
		),
		dbtypes.NewValidatorStatusRow(
			3,
			true,
			validator2.GetConsAddr(),
			11,
		),
	}
	suite.Require().Len(stored, len(expected))
	for index, stored := range stored {
		suite.Require().True(stored.Equal(expected[index]))
	}
}

// --------------------------------------------------------------------------------------------------------------------

func (suite *DbTestSuite) TestSaveDoubleVoteEvidence() {
	// Insert the validator
	validator := suite.getValidator(
		"cosmosvalcons1qqqqrezrl53hujmpdch6d805ac75n220ku09rl",
		"cosmosvaloper1rcp29q3hpd246n6qak7jluqep4v006cdsc2kkl",
		"cosmosvalconspub1zcjduepq7mft6gfls57a0a42d7uhx656cckhfvtrlmw744jv4q0mvlv0dypskehfk8",
	)

	// Insert data
	evidence := types.NewDoubleSignEvidence(
		10,
		types.NewDoubleSignVote(
			int(tmtypes.PrevoteType),
			10,
			1,
			"A42C9492F5DE01BFA6117137102C3EF909F1A46C2F56915F542D12AC2D0A5BCA",
			validator.GetConsAddr(),
			1,
			"1qwPQjPrc7DH7+f6YAE3fOkq6phDAJ60dEyhmcZ7dx2ZgGvi9DbVLsn4leYqRNA/63ZeeH5kVly8zI1jCh4iBg==",
		),
		types.NewDoubleSignVote(
			int(tmtypes.PrevoteType),
			10,
			1,
			"418A20D12F45FC9340BE0CD2EDB0FFA1E4316176B8CE11E123EF6CBED23C8423",
			validator.GetConsAddr(),
			1,
			"A5m7SVuvZ8YNXcUfBKLgkeV+Vy5ea+7rPfzlbkEvHOPPce6B7A2CwOIbCmPSVMKUarUdta+HiyTV+IELaOYyDA==",
		),
	)
	err := suite.database.SaveDoubleSignEvidence(evidence)
	suite.Require().NoError(err)

	// Verify insertion
	var evidenceRows []dbtypes.DoubleSignEvidenceRow
	err = suite.database.Sqlx.Select(&evidenceRows, "SELECT * FROM double_sign_evidence")
	suite.Require().NoError(err)
	suite.Require().Len(evidenceRows, 1)
	suite.Require().Equal(dbtypes.NewDoubleSignEvidenceRow(10, 1, 2), evidenceRows[0])

	expectVotes := []dbtypes.DoubleSignVoteRow{
		dbtypes.NewDoubleSignVoteRow(
			1,
			int(tmtypes.PrevoteType),
			10,
			1,
			"A42C9492F5DE01BFA6117137102C3EF909F1A46C2F56915F542D12AC2D0A5BCA",
			validator.GetConsAddr(),
			1,
			"1qwPQjPrc7DH7+f6YAE3fOkq6phDAJ60dEyhmcZ7dx2ZgGvi9DbVLsn4leYqRNA/63ZeeH5kVly8zI1jCh4iBg==",
		),
		dbtypes.NewDoubleSignVoteRow(
			2,
			int(tmtypes.PrevoteType),
			10,
			1,
			"418A20D12F45FC9340BE0CD2EDB0FFA1E4316176B8CE11E123EF6CBED23C8423",
			validator.GetConsAddr(),
			1,
			"A5m7SVuvZ8YNXcUfBKLgkeV+Vy5ea+7rPfzlbkEvHOPPce6B7A2CwOIbCmPSVMKUarUdta+HiyTV+IELaOYyDA==",
		),
	}

	var votesRows []dbtypes.DoubleSignVoteRow
	err = suite.database.Sqlx.Select(&votesRows, "SELECT * FROM double_sign_vote")
	suite.Require().NoError(err)

	suite.Require().Len(votesRows, len(expectVotes))
	for index, row := range votesRows {
		suite.Require().True(expectVotes[index].Equal(row))
	}
}

'''
'''--- database/types/auth.go ---
package types

// AccountRow represents a single row inside the account table
type AccountRow struct {
	Address string `db:"address"`
}

// NewAccountRow allows to easily build a new AccountRow
func NewAccountRow(address string) AccountRow {
	return AccountRow{
		Address: address,
	}
}

// Equal tells whether a and b contain the same data
func (a AccountRow) Equal(b AccountRow) bool {
	return a.Address == b.Address
}

'''
'''--- database/types/coins.go ---
package types

import (
	"database/sql"
	"database/sql/driver"
	"fmt"
	"strings"

	sdk "github.com/cosmos/cosmos-sdk/types"
)

func ToString(value sql.NullString) string {
	if value.Valid {
		return value.String
	}
	return ""
}

func ToNullString(value string) sql.NullString {
	value = strings.TrimSpace(value)
	return sql.NullString{
		Valid:  value != "",
		String: value,
	}
}

func RemoveEmpty(s []string) []string {
	var r []string
	for _, str := range s {
		if str != "" {
			r = append(r, str)
		}
	}
	return r
}

// _________________________________________________________

// DbCoin represents the information stored inside the database about a single coin
type DbCoin struct {
	Denom  string
	Amount string
}

// NewDbCoin builds a DbCoin starting from an SDK Coin
func NewDbCoin(coin sdk.Coin) DbCoin {
	return DbCoin{
		Denom:  coin.Denom,
		Amount: coin.Amount.String(),
	}
}

// Equal tells whether coin and d represent the same coin with the same amount
func (coin DbCoin) Equal(d DbCoin) bool {
	return coin.Denom == d.Denom && coin.Amount == d.Amount
}

// Value implements driver.Valuer
func (coin *DbCoin) Value() (driver.Value, error) {
	return fmt.Sprintf("(%s,%s)", coin.Denom, coin.Amount), nil
}

// Scan implements sql.Scanner
func (coin *DbCoin) Scan(src interface{}) error {
	strValue := string(src.([]byte))
	strValue = strings.ReplaceAll(strValue, `"`, "")
	strValue = strings.ReplaceAll(strValue, "{", "")
	strValue = strings.ReplaceAll(strValue, "}", "")
	strValue = strings.ReplaceAll(strValue, "(", "")
	strValue = strings.ReplaceAll(strValue, ")", "")

	values := strings.Split(strValue, ",")

	*coin = DbCoin{Denom: values[0], Amount: values[1]}
	return nil
}

// ToCoin converts this DbCoin to sdk.Coin
func (coin DbCoin) ToCoin() sdk.Coin {
	amount, _ := sdk.NewIntFromString(coin.Amount)
	return sdk.NewCoin(coin.Denom, amount)
}

// _________________________________________________________

// DbCoins represents an array of coins
type DbCoins []*DbCoin

// NewDbCoins build a new DbCoins object starting from an array of coins
func NewDbCoins(coins sdk.Coins) DbCoins {
	dbCoins := make([]*DbCoin, 0)
	for _, coin := range coins {
		dbCoins = append(dbCoins, &DbCoin{Amount: coin.Amount.String(), Denom: coin.Denom})
	}
	return dbCoins
}

// Equal tells whether c and d contain the same items in the same order
func (coins DbCoins) Equal(d *DbCoins) bool {
	if d == nil {
		return false
	}

	if len(coins) != len(*d) {
		return false
	}

	for index, coin := range coins {
		if !coin.Equal(*(*d)[index]) {
			return false
		}
	}

	return true
}

// Scan implements sql.Scanner
func (coins *DbCoins) Scan(src interface{}) error {
	strValue := string(src.([]byte))
	strValue = strings.ReplaceAll(strValue, `"`, "")
	strValue = strings.ReplaceAll(strValue, "{", "")
	strValue = strings.ReplaceAll(strValue, "}", "")
	strValue = strings.ReplaceAll(strValue, "),(", ") (")
	strValue = strings.ReplaceAll(strValue, "(", "")
	strValue = strings.ReplaceAll(strValue, ")", "")

	values := RemoveEmpty(strings.Split(strValue, " "))

	coinsV := make(DbCoins, len(values))
	for index, value := range values {
		v := strings.Split(value, ",") // Split the values

		coin := DbCoin{Denom: v[0], Amount: v[1]}
		coinsV[index] = &coin
	}

	*coins = coinsV
	return nil
}

// ToCoins converts this DbCoins to sdk.Coins
func (coins DbCoins) ToCoins() sdk.Coins {
	var sdkCoins = make([]sdk.Coin, len(coins))
	for index := range coins {
		sdkCoins[index] = coins[index].ToCoin()
	}
	return sdkCoins
}

// --------------------------------------------------------------------------------------------------------------------

// DbDecCoin represents the information stored inside the database about a single coin
type DbDecCoin struct {
	Denom  string
	Amount string
}

// NewDbDecCoin builds a DbDecCoin starting from an SDK Coin
func NewDbDecCoin(coin sdk.DecCoin) DbDecCoin {
	return DbDecCoin{
		Denom:  coin.Denom,
		Amount: coin.Amount.String(),
	}
}

// Equal tells whether coin and d represent the same coin with the same amount
func (coin DbDecCoin) Equal(d DbDecCoin) bool {
	return coin.Denom == d.Denom && coin.Amount == d.Amount
}

// Value implements driver.Valuer
func (coin *DbDecCoin) Value() (driver.Value, error) {
	return fmt.Sprintf("(%s,%s)", coin.Denom, coin.Amount), nil
}

// Scan implements sql.Scanner
func (coin *DbDecCoin) Scan(src interface{}) error {
	strValue := string(src.([]byte))
	strValue = strings.ReplaceAll(strValue, `"`, "")
	strValue = strings.ReplaceAll(strValue, "{", "")
	strValue = strings.ReplaceAll(strValue, "}", "")
	strValue = strings.ReplaceAll(strValue, "(", "")
	strValue = strings.ReplaceAll(strValue, ")", "")

	values := strings.Split(strValue, ",")
	*coin = DbDecCoin{Denom: values[0], Amount: values[1]}
	return nil
}

// ToDecCoin converts this DbDecCoin to sdk.DecCoin
func (coin DbDecCoin) ToDecCoin() sdk.DecCoin {
	amount, _ := sdk.NewDecFromStr(coin.Amount)
	return sdk.NewDecCoinFromDec(coin.Denom, amount)
}

// _________________________________________________________

// DbDecCoins represents an array of coins
type DbDecCoins []*DbDecCoin

// NewDbDecCoins build a new DbDecCoins object starting from an array of coins
func NewDbDecCoins(coins sdk.DecCoins) DbDecCoins {
	DbDecCoins := make([]*DbDecCoin, 0)
	for _, coin := range coins {
		DbDecCoins = append(DbDecCoins, &DbDecCoin{Amount: coin.Amount.String(), Denom: coin.Denom})
	}
	return DbDecCoins
}

// Equal tells whether c and d contain the same items in the same order
func (coins DbDecCoins) Equal(d *DbDecCoins) bool {
	if d == nil {
		return false
	}

	if len(coins) != len(*d) {
		return false
	}

	for index, coin := range coins {
		if !coin.Equal(*(*d)[index]) {
			return false
		}
	}

	return true
}

// Scan implements sql.Scanner
func (coins *DbDecCoins) Scan(src interface{}) error {
	strValue := string(src.([]byte))
	strValue = strings.ReplaceAll(strValue, `"`, "")
	strValue = strings.ReplaceAll(strValue, "{", "")
	strValue = strings.ReplaceAll(strValue, "}", "")
	strValue = strings.ReplaceAll(strValue, "),(", ") (")
	strValue = strings.ReplaceAll(strValue, "(", "")
	strValue = strings.ReplaceAll(strValue, ")", "")

	values := RemoveEmpty(strings.Split(strValue, " "))

	coinsV := make(DbDecCoins, len(values))
	for index, value := range values {
		v := strings.Split(value, ",") // Split the values

		coin := DbDecCoin{Denom: v[0], Amount: v[1]}
		coinsV[index] = &coin
	}

	*coins = coinsV
	return nil
}

// ToDecCoins converts this DbDecCoins to sdk.DecCoins
func (coins DbDecCoins) ToDecCoins() sdk.DecCoins {
	var sdkCoins = make([]sdk.DecCoin, len(coins))
	for index := range coins {
		sdkCoins[index] = coins[index].ToDecCoin()
	}
	return sdkCoins
}

'''
'''--- database/types/consensus.go ---
package types

import (
	"database/sql"
	"time"
)

type GenesisRow struct {
	OneRowID      bool      `db:"one_row_id"`
	ChainID       string    `db:"chain_id"`
	Time          time.Time `db:"time"`
	InitialHeight int64     `db:"initial_height"`
}

func NewGenesisRow(chainID string, time time.Time, initialHeight int64) GenesisRow {
	return GenesisRow{
		OneRowID:      true,
		ChainID:       chainID,
		Time:          time,
		InitialHeight: initialHeight,
	}
}

func (r GenesisRow) Equal(s GenesisRow) bool {
	return r.Time.Equal(s.Time) &&
		r.ChainID == s.ChainID &&
		r.InitialHeight == s.InitialHeight
}

// -------------------------------------------------------------------------------------------------------------------

// ConsensusRow represents a single row inside the consensus table
type ConsensusRow struct {
	Step     string `db:"step"`
	Height   int64  `db:"height"`
	Round    int32  `db:"round"`
	OneRowID bool   `db:"one_row_id"`
}

// NewConsensusRow allows to build a new ConsensusRow instance
func NewConsensusRow(height int64, round int32, step string) ConsensusRow {
	return ConsensusRow{
		OneRowID: true,
		Height:   height,
		Round:    round,
		Step:     step,
	}
}

// Equal tells whether r and s contain the same data
func (r ConsensusRow) Equal(s ConsensusRow) bool {
	return r.Height == s.Height &&
		r.Round == s.Round &&
		r.Step == s.Step
}

// AverageTimeRow is the average block time each minute/hour/day
type AverageTimeRow struct {
	OneRowID    bool    `db:"one_row_id"`
	AverageTime float64 `db:"average_time"`
	Height      int64   `db:"height"`
}

func NewAverageTimeRow(averageTime float64, height int64) AverageTimeRow {
	return AverageTimeRow{
		OneRowID:    true,
		AverageTime: averageTime,
		Height:      height,
	}
}

// Equal return true if two AverageTimeRow are true
func (r AverageTimeRow) Equal(s AverageTimeRow) bool {
	return r.AverageTime == s.AverageTime &&
		r.Height == s.Height
}

// -------------------------------------------------------------------------------------------------------------------

// BlockRow represents a single block row stored inside the database
type BlockRow struct {
	Height          int64          `db:"height"`
	Hash            string         `db:"hash"`
	TxNum           int64          `db:"num_txs"`
	TotalGas        int64          `db:"total_gas"`
	ProposerAddress sql.NullString `db:"proposer_address"`
	PreCommitsNum   int64          `db:"pre_commits"`
	Timestamp       time.Time      `db:"timestamp"`
}

'''
'''--- database/types/distribution.go ---
package types

// DistributionParamsRow represents a single row inside the distribution_params table
type DistributionParamsRow struct {
	OneRowID bool   `db:"one_row_id"`
	Params   string `db:"params"`
	Height   int64  `db:"height"`
}

// -------------------------------------------------------------------------------------------------------------------

// CommunityPoolRow represents a single row inside the total_supply table
type CommunityPoolRow struct {
	OneRowID bool        `db:"one_row_id"`
	Coins    *DbDecCoins `db:"coins"`
	Height   int64       `db:"height"`
}

// NewCommunityPoolRow allows to easily create a new CommunityPoolRow
func NewCommunityPoolRow(coins DbDecCoins, height int64) CommunityPoolRow {
	return CommunityPoolRow{
		OneRowID: true,
		Coins:    &coins,
		Height:   height,
	}
}

// Equals return true if one CommunityPoolRow representing the same row as the original one
func (v CommunityPoolRow) Equals(w CommunityPoolRow) bool {
	return v.Coins.Equal(w.Coins) &&
		v.Height == w.Height
}

'''
'''--- database/types/feegrant.go ---
package types

// FeeAllowanceRow represents a single row inside the fee_grant_allowance table
type FeeAllowanceRow struct {
	ID        uint64 `db:"id"`
	Grantee   string `db:"grantee_address"`
	Granter   string `db:"granter_address"`
	Allowance string `db:"allowance"`
	Height    int64  `db:"height"`
}

'''
'''--- database/types/gov.go ---
package types

import (
	"time"
)

// GovParamsRow represents a single row of the "gov_params" table
type GovParamsRow struct {
	OneRowID      bool   `db:"one_row_id"`
	DepositParams string `db:"deposit_params"`
	VotingParams  string `db:"voting_params"`
	TallyParams   string `db:"tally_params"`
	Height        int64  `db:"height"`
}

// --------------------------------------------------------------------------------------------------------------------

// ProposalRow represents a single row inside the proposal table
type ProposalRow struct {
	Title           string    `db:"title"`
	Description     string    `db:"description"`
	Content         string    `db:"content"`
	ProposalRoute   string    `db:"proposal_route"`
	ProposalType    string    `db:"proposal_type"`
	ProposalID      uint64    `db:"id"`
	SubmitTime      time.Time `db:"submit_time"`
	DepositEndTime  time.Time `db:"deposit_end_time"`
	VotingStartTime time.Time `db:"voting_start_time"`
	VotingEndTime   time.Time `db:"voting_end_time"`
	Proposer        string    `db:"proposer_address"`
	Status          string    `db:"status"`
}

// NewProposalRow allows to easily create a new ProposalRow
func NewProposalRow(
	proposalID uint64,
	proposalRoute string,
	proposalType string,
	title string,
	description string,
	content string,
	submitTime time.Time,
	depositEndTime time.Time,
	votingStartTime time.Time,
	votingEndTime time.Time,
	proposer string,
	status string,
) ProposalRow {
	return ProposalRow{
		Title:           title,
		Description:     description,
		Content:         content,
		ProposalRoute:   proposalRoute,
		ProposalType:    proposalType,
		ProposalID:      proposalID,
		SubmitTime:      submitTime,
		DepositEndTime:  depositEndTime,
		VotingStartTime: votingStartTime,
		VotingEndTime:   votingEndTime,
		Proposer:        proposer,
		Status:          status,
	}
}

// Equals return true if two ProposalRow are the same
func (w ProposalRow) Equals(v ProposalRow) bool {
	return w.Title == v.Title &&
		w.Description == v.Description &&
		w.ProposalRoute == v.ProposalRoute &&
		w.ProposalType == v.ProposalType &&
		w.ProposalID == v.ProposalID &&
		w.SubmitTime.Equal(v.SubmitTime) &&
		w.DepositEndTime.Equal(v.DepositEndTime) &&
		w.VotingStartTime.Equal(v.VotingStartTime) &&
		w.VotingEndTime.Equal(v.VotingEndTime) &&
		w.Proposer == v.Proposer &&
		w.Status == v.Status
}

// TallyResultRow represents a single row inside the tally_result table
type TallyResultRow struct {
	ProposalID int64  `db:"proposal_id"`
	Yes        string `db:"yes"`
	Abstain    string `db:"abstain"`
	No         string `db:"no"`
	NoWithVeto string `db:"no_with_veto"`
	Height     int64  `db:"height"`
}

// NewTallyResultRow return a new TallyResultRow instance
func NewTallyResultRow(
	proposalID int64,
	yes string,
	abstain string,
	no string,
	noWithVeto string,
	height int64,
) TallyResultRow {
	return TallyResultRow{
		ProposalID: proposalID,
		Yes:        yes,
		Abstain:    abstain,
		No:         no,
		NoWithVeto: noWithVeto,
		Height:     height,
	}
}

// Equals return true if two TallyResultRow are the same
func (w TallyResultRow) Equals(v TallyResultRow) bool {
	return w.ProposalID == v.ProposalID &&
		w.Yes == v.Yes &&
		w.Abstain == v.Abstain &&
		w.No == v.No &&
		w.NoWithVeto == v.NoWithVeto &&
		w.Height == v.Height
}

// VoteRow represents a single row inside the vote table
type VoteRow struct {
	ProposalID int64     `db:"proposal_id"`
	Voter      string    `db:"voter_address"`
	Option     string    `db:"option"`
	Timestamp  time.Time `db:"timestamp"`
	Height     int64     `db:"height"`
}

// NewVoteRow allows to easily create a new VoteRow
func NewVoteRow(
	proposalID int64,
	voter string,
	option string,
	timestamp time.Time,
	height int64,
) VoteRow {
	return VoteRow{
		ProposalID: proposalID,
		Voter:      voter,
		Option:     option,
		Timestamp:  timestamp,
		Height:     height,
	}
}

// Equals return true if two VoteRow are the same
func (w VoteRow) Equals(v VoteRow) bool {
	return w.ProposalID == v.ProposalID &&
		w.Voter == v.Voter &&
		w.Option == v.Option &&
		w.Timestamp.Equal(v.Timestamp) &&
		w.Height == v.Height
}

// DepositRow represents a single row inside the deposit table
type DepositRow struct {
	ProposalID int64     `db:"proposal_id"`
	Depositor  string    `db:"depositor_address"`
	Amount     DbCoins   `db:"amount"`
	Timestamp  time.Time `db:"timestamp"`
	Height     int64     `db:"height"`
}

// NewDepositRow allows to easily create a new NewDepositRow
func NewDepositRow(
	proposalID int64,
	depositor string,
	amount DbCoins,
	timestamp time.Time,
	height int64,
) DepositRow {
	return DepositRow{
		ProposalID: proposalID,
		Depositor:  depositor,
		Amount:     amount,
		Timestamp:  timestamp,
		Height:     height,
	}
}

// Equals return true if two VoteDepositRow are the same
func (w DepositRow) Equals(v DepositRow) bool {
	return w.ProposalID == v.ProposalID &&
		w.Depositor == v.Depositor &&
		w.Amount.Equal(&v.Amount) &&
		w.Timestamp.Equal(v.Timestamp) &&
		w.Height == v.Height
}

// --------------------------------------------------------------------------------------------------------------------

type ProposalStakingPoolSnapshotRow struct {
	ProposalID      uint64 `db:"proposal_id"`
	BondedTokens    int64  `db:"bonded_tokens"`
	NotBondedTokens int64  `db:"not_bonded_tokens"`
	Height          int64  `db:"height"`
}

func NewProposalStakingPoolSnapshotRow(proposalID uint64, bondedTokens, notBondedTokens, height int64) ProposalStakingPoolSnapshotRow {
	return ProposalStakingPoolSnapshotRow{
		ProposalID:      proposalID,
		BondedTokens:    bondedTokens,
		NotBondedTokens: notBondedTokens,
		Height:          height,
	}
}

// --------------------------------------------------------------------------------------------------------------------

type ProposalValidatorVotingPowerSnapshotRow struct {
	ID               int64  `db:"id"`
	ProposalID       int64  `db:"proposal_id"`
	ValidatorAddress string `db:"validator_address"`
	VotingPower      int64  `db:"voting_power"`
	Status           int    `db:"status"`
	Jailed           bool   `db:"jailed"`
	Height           int64  `db:"height"`
}

func NewProposalValidatorVotingPowerSnapshotRow(
	id int64, proposalID int64, validatorAddr string, votingPower int64, status int, jailed bool, height int64,
) ProposalValidatorVotingPowerSnapshotRow {
	return ProposalValidatorVotingPowerSnapshotRow{
		ID:               id,
		ProposalID:       proposalID,
		ValidatorAddress: validatorAddr,
		VotingPower:      votingPower,
		Status:           status,
		Jailed:           jailed,
		Height:           height,
	}
}

'''
'''--- database/types/mint.go ---
package types

// InflationRow represents a single row inside the inflation table
type InflationRow struct {
	OneRowID bool    `db:"one_row_id"`
	Value    float64 `db:"value"`
	Height   int64   `db:"height"`
}

// NewInflationRow builds a new InflationRows instance
func NewInflationRow(value float64, height int64) InflationRow {
	return InflationRow{
		OneRowID: true,
		Value:    value,
		Height:   height,
	}
}

// Equal reports whether i and j represent the same table rows.
func (i InflationRow) Equal(j InflationRow) bool {
	return i.Value == j.Value &&
		i.Height == j.Height
}

// --------------------------------------------------------------------------------------------------------------------

// MintParamsRow represents a single row inside the mint_params table
type MintParamsRow struct {
	OneRowID bool   `db:"one_row_id"`
	Params   string `db:"params"`
	Height   int64  `db:"height"`
}

// NewMintParamsRow builds a new MintParamsRow instance
func NewMintParamsRow(
	params string, height int64,
) MintParamsRow {
	return MintParamsRow{
		OneRowID: true,
		Params:   params,
		Height:   height,
	}
}

// Equal reports whether m and n represent the same table rows.
func (m MintParamsRow) Equal(n MintParamsRow) bool {
	return m.Params == n.Params &&
		m.Height == n.Height
}

'''
'''--- database/types/pricefeed.go ---
package types

import (
	"database/sql"
	"time"

	"github.com/lib/pq"
)

type TokenUnitRow struct {
	TokenName string         `db:"token_name"`
	Denom     string         `db:"denom"`
	Exponent  int            `db:"exponent"`
	Aliases   pq.StringArray `db:"aliases"`
	PriceID   sql.NullString `db:"price_id"`
}

type TokenRow struct {
	Name       string `db:"name"`
	TradedUnit string `db:"traded_unit"`
}

// --------------------------------------------------------------------------------------------------------------------

// TokenPriceRow represent a row of the table token_price in the database
type TokenPriceRow struct {
	ID        string    `db:"id"`
	Name      string    `db:"unit_name"`
	Price     float64   `db:"price"`
	MarketCap int64     `db:"market_cap"`
	Timestamp time.Time `db:"timestamp"`
}

// NewTokenPriceRow allows to easily create a new NewTokenPriceRow
func NewTokenPriceRow(name string, currentPrice float64, marketCap int64, timestamp time.Time) TokenPriceRow {
	return TokenPriceRow{
		Name:      name,
		Price:     currentPrice,
		MarketCap: marketCap,
		Timestamp: timestamp,
	}
}

// Equals return true if u and v represent the same row
func (u TokenPriceRow) Equals(v TokenPriceRow) bool {
	return u.Name == v.Name &&
		u.Price == v.Price &&
		u.MarketCap == v.MarketCap &&
		u.Timestamp.Equal(v.Timestamp)
}

'''
'''--- database/types/slashing.go ---
package types

import "time"

// ValidatorSigningInfoRow represents a single row of the validator_signing_info table
type ValidatorSigningInfoRow struct {
	ValidatorAddress    string    `db:"validator_address"`
	StartHeight         int64     `db:"start_height"`
	IndexOffset         int64     `db:"index_offset"`
	JailedUntil         time.Time `db:"jailed_until"`
	Tombstoned          bool      `db:"tombstoned"`
	MissedBlocksCounter int64     `db:"missed_blocks_counter"`
	Height              int64     `db:"height"`
}

// Equal tells whether v and w represent the same rows
func (v ValidatorSigningInfoRow) Equal(w ValidatorSigningInfoRow) bool {
	return v.ValidatorAddress == w.ValidatorAddress &&
		v.StartHeight == w.StartHeight &&
		v.IndexOffset == w.IndexOffset &&
		v.JailedUntil.Equal(w.JailedUntil) &&
		v.Tombstoned == w.Tombstoned &&
		v.MissedBlocksCounter == w.MissedBlocksCounter &&
		v.Height == w.Height
}

// NewValidatorSigningInfoRow allows to build a new ValidatorSigningInfoRow
func NewValidatorSigningInfoRow(
	validatorAddress string,
	startHeight int64,
	indexOffset int64,
	jailedUntil time.Time,
	tombstoned bool,
	missedBlocksCounter int64,
	height int64,
) ValidatorSigningInfoRow {
	return ValidatorSigningInfoRow{
		ValidatorAddress:    validatorAddress,
		StartHeight:         startHeight,
		IndexOffset:         indexOffset,
		JailedUntil:         jailedUntil,
		Tombstoned:          tombstoned,
		MissedBlocksCounter: missedBlocksCounter,
		Height:              height,
	}
}

// -------------------------------------------------------------------------------------------------------------------

// SlashingParamsRow represents a single row inside the slashing_params table
type SlashingParamsRow struct {
	OneRowID bool   `db:"one_row_id"`
	Params   string `db:"params"`
	Height   int64  `db:"height"`
}

// NewSlashingParamsRow allows to create a new instance SlashingParamsRow
func NewSlashingParamsRow(params string, height int64) SlashingParamsRow {
	return SlashingParamsRow{
		OneRowID: true,
		Params:   params,
		Height:   height,
	}
}

'''
'''--- database/types/staking_params.go ---
package types

// StakingParamsRow represents a single row inside the staking_params table
type StakingParamsRow struct {
	OneRowID bool   `db:"one_row_id"`
	Params   string `db:"params"`
	Height   int64  `db:"height"`
}

'''
'''--- database/types/staking_pool.go ---
package types

// StakingPoolRow represents a single row inside the staking_pool table
type StakingPoolRow struct {
	OneRowID              bool  `db:"one_row_id"`
	BondedTokens          int64 `db:"bonded_tokens"`
	NotBondedTokens       int64 `db:"not_bonded_tokens"`
	UnbondingTokens       int64 `db:"unbonding_tokens"`
	StakedNotBondedTokens int64 `db:"staked_not_bonded_tokens"`
	Height                int64 `db:"height"`
}

// NewStakingPoolRow allows to easily create a new StakingPoolRow
func NewStakingPoolRow(bondedTokens, notBondedTokens, unbondingTokens, stakedNotBondedTokens int64, height int64) StakingPoolRow {
	return StakingPoolRow{
		OneRowID:              true,
		BondedTokens:          bondedTokens,
		NotBondedTokens:       notBondedTokens,
		UnbondingTokens:       unbondingTokens,
		StakedNotBondedTokens: stakedNotBondedTokens,
		Height:                height,
	}
}

// Equal allows to tells whether r and as represent the same rows
func (r StakingPoolRow) Equal(s StakingPoolRow) bool {
	return r.BondedTokens == s.BondedTokens &&
		r.NotBondedTokens == s.NotBondedTokens &&
		r.UnbondingTokens == s.UnbondingTokens &&
		r.StakedNotBondedTokens == s.StakedNotBondedTokens &&
		r.Height == s.Height
}

'''
'''--- database/types/staking_validators.go ---
package types

import (
	"database/sql"
	"strconv"

	sdk "github.com/cosmos/cosmos-sdk/types"
)

// ValidatorData contains all the data of a single validator.
// It implements types.Validator interface
type ValidatorData struct {
	ConsAddress         string `db:"consensus_address"`
	ValAddress          string `db:"operator_address"`
	ConsPubKey          string `db:"consensus_pubkey"`
	SelfDelegateAddress string `db:"self_delegate_address"`
	MaxRate             string `db:"max_rate"`
	MaxChangeRate       string `db:"max_change_rate"`
	Height              int64  `db:"height"`
}

// NewValidatorData allows to build a new ValidatorData
func NewValidatorData(
	consAddress, valAddress, consPubKey, selfDelegateAddress, maxRate, maxChangeRate string, height int64,
) ValidatorData {
	return ValidatorData{
		ConsAddress:         consAddress,
		ValAddress:          valAddress,
		ConsPubKey:          consPubKey,
		SelfDelegateAddress: selfDelegateAddress,
		MaxRate:             maxRate,
		MaxChangeRate:       maxChangeRate,
		Height:              height,
	}
}

// GetConsAddr implements types.Validator
func (v ValidatorData) GetConsAddr() string {
	return v.ConsAddress
}

// GetConsPubKey implements types.Validator
func (v ValidatorData) GetConsPubKey() string {
	return v.ConsPubKey
}

// GetOperator implements types.Validator
func (v ValidatorData) GetOperator() string {
	return v.ValAddress
}

// GetSelfDelegateAddress implements types.Validator
func (v ValidatorData) GetSelfDelegateAddress() string {
	return v.SelfDelegateAddress
}

// GetMaxChangeRate implements types.Validator
func (v ValidatorData) GetMaxChangeRate() *sdk.Dec {
	n, err := strconv.ParseInt(v.MaxChangeRate, 10, 64)
	if err != nil {
		panic(err)
	}
	result := sdk.NewDec(n)
	return &result
}

// GetMaxRate implements types.Validator
func (v ValidatorData) GetMaxRate() *sdk.Dec {
	n, err := strconv.ParseInt(v.MaxRate, 10, 64)
	if err != nil {
		panic(err)
	}
	result := sdk.NewDec(n)
	return &result
}

// GetHeight implements types.Validator
func (v ValidatorData) GetHeight() int64 {
	return v.Height
}

// ________________________________________________

// ValidatorRow represents a single row of the validator table
type ValidatorRow struct {
	ConsAddress string `db:"consensus_address"`
	ConsPubKey  string `db:"consensus_pubkey"`
}

// NewValidatorRow returns a new ValidatorRow
func NewValidatorRow(consAddress, consPubKey string) ValidatorRow {
	return ValidatorRow{
		ConsAddress: consAddress,
		ConsPubKey:  consPubKey,
	}
}

// Equal tells whether v and w contain the same data
func (v ValidatorRow) Equal(w ValidatorRow) bool {
	return v.ConsAddress == w.ConsAddress &&
		v.ConsPubKey == w.ConsPubKey
}

// ________________________________________________

// ValidatorInfoRow represents a single row of the validator_info table
type ValidatorInfoRow struct {
	ConsAddress         string `db:"consensus_address"`
	ValAddress          string `db:"operator_address"`
	SelfDelegateAddress string `db:"self_delegate_address"`
	MaxChangeRate       string `db:"max_change_rate"`
	MaxRate             string `db:"max_rate"`
	Height              int64  `db:"height"`
}

// NewValidatorInfoRow allows to build a new ValidatorInfoRow
func NewValidatorInfoRow(
	consAddress, valAddress, selfDelegateAddress, maxRate, maxChangeRate string, height int64,
) ValidatorInfoRow {
	return ValidatorInfoRow{
		ConsAddress:         consAddress,
		ValAddress:          valAddress,
		SelfDelegateAddress: selfDelegateAddress,
		MaxChangeRate:       maxChangeRate,
		MaxRate:             maxRate,
		Height:              height,
	}
}

// Equal tells whether v and w represent the same rows
func (v ValidatorInfoRow) Equal(w ValidatorInfoRow) bool {
	return v.ConsAddress == w.ConsAddress &&
		v.ValAddress == w.ValAddress &&
		v.SelfDelegateAddress == w.SelfDelegateAddress &&
		v.MaxRate == w.MaxRate &&
		v.MaxChangeRate == w.MaxChangeRate &&
		v.Height == w.Height
}

// --------------------------------------------------------------------------------------------------------------------

// ValidatorDescriptionRow represent a row in validator_description
type ValidatorDescriptionRow struct {
	ValAddress      string         `db:"validator_address"`
	Moniker         sql.NullString `db:"moniker"`
	Identity        sql.NullString `db:"identity"`
	AvatarURL       sql.NullString `db:"avatar_url"`
	Website         sql.NullString `db:"website"`
	SecurityContact sql.NullString `db:"security_contact"`
	Details         sql.NullString `db:"details"`
	Height          int64          `db:"height"`
}

// NewValidatorDescriptionRow return a row representing data structure in validator_description
func NewValidatorDescriptionRow(
	valAddress, moniker, identity, avatarURL, website, securityContact, details string, height int64,
) ValidatorDescriptionRow {
	return ValidatorDescriptionRow{
		ValAddress:      valAddress,
		Moniker:         ToNullString(moniker),
		Identity:        ToNullString(identity),
		AvatarURL:       ToNullString(avatarURL),
		Website:         ToNullString(website),
		SecurityContact: ToNullString(securityContact),
		Details:         ToNullString(details),
		Height:          height,
	}
}

// Equals return true if two ValidatorDescriptionRow are equal
func (w ValidatorDescriptionRow) Equals(v ValidatorDescriptionRow) bool {
	return v.ValAddress == w.ValAddress &&
		v.Moniker == w.Moniker &&
		v.Identity == w.Identity &&
		v.Website == w.Website &&
		v.SecurityContact == w.SecurityContact &&
		v.Details == w.Details &&
		v.Height == w.Height
}

// ________________________________________________

// ValidatorCommissionRow represents a single row of the validator_commission database table
type ValidatorCommissionRow struct {
	OperatorAddress   string         `db:"validator_address"`
	Commission        sql.NullString `db:"commission"`
	MinSelfDelegation sql.NullString `db:"min_self_delegation"`
	Height            int64          `db:"height"`
}

// NewValidatorCommissionRow allows to easily build a new ValidatorCommissionRow instance
func NewValidatorCommissionRow(
	operatorAddress string, commission string, minSelfDelegation string, height int64,
) ValidatorCommissionRow {
	return ValidatorCommissionRow{
		OperatorAddress:   operatorAddress,
		Commission:        ToNullString(commission),
		MinSelfDelegation: ToNullString(minSelfDelegation),
		Height:            height,
	}
}

// Equal tells whether v and w represent the same rows
func (v ValidatorCommissionRow) Equal(w ValidatorCommissionRow) bool {
	return v.OperatorAddress == w.OperatorAddress &&
		v.Commission == w.Commission &&
		v.MinSelfDelegation == w.MinSelfDelegation &&
		v.Height == w.Height
}

// ________________________________________________

// ValidatorVotingPowerRow represents a single row of the validator_voting_power database table
type ValidatorVotingPowerRow struct {
	ValidatorAddress string `db:"validator_address"`
	VotingPower      int64  `db:"voting_power"`
	Height           int64  `db:"height"`
}

// NewValidatorVotingPowerRow allows to easily build a new ValidatorVotingPowerRow instance
func NewValidatorVotingPowerRow(address string, votingPower int64, height int64) ValidatorVotingPowerRow {
	return ValidatorVotingPowerRow{
		ValidatorAddress: address,
		VotingPower:      votingPower,
		Height:           height,
	}
}

// Equal tells whether v and w represent the same rows
func (v ValidatorVotingPowerRow) Equal(w ValidatorVotingPowerRow) bool {
	return v.ValidatorAddress == w.ValidatorAddress &&
		v.VotingPower == w.VotingPower &&
		v.Height == w.Height
}

// ________________________________________________

// ValidatorStatusRow represents a single row of the validator_status table
type ValidatorStatusRow struct {
	Status      int    `db:"status"`
	Jailed      bool   `db:"jailed"`
	ConsAddress string `db:"validator_address"`
	Height      int64  `db:"height"`
}

// NewValidatorStatusRow builds a new ValidatorStatusRow
func NewValidatorStatusRow(status int, jailed bool, consAddess string, height int64) ValidatorStatusRow {
	return ValidatorStatusRow{
		Status:      status,
		Jailed:      jailed,
		ConsAddress: consAddess,
		Height:      height,
	}
}

// Equal tells whether v and w contain the same data
func (v ValidatorStatusRow) Equal(w ValidatorStatusRow) bool {
	return v.Status == w.Status &&
		v.Jailed == w.Jailed &&
		v.ConsAddress == w.ConsAddress &&
		v.Height == w.Height
}

//--------------------------------------------------------

// DoubleSignVoteRow represents a single row of the double_sign_vote table
type DoubleSignVoteRow struct {
	ID               int64  `db:"id"`
	VoteType         int    `db:"type"`
	Height           int64  `db:"height"`
	Round            int    `db:"round"`
	BlockID          string `db:"block_id"`
	ValidatorAddress string `db:"validator_address"`
	ValidatorIndex   int    `db:"validator_index"`
	Signature        string `db:"signature"`
}

// NewDoubleSignVoteRow allows to build a new NewDoubleSignVoteRow
func NewDoubleSignVoteRow(
	id int64,
	voteType int,
	height int64,
	round int,
	blockID string,
	validatorAddress string,
	validatorIndex int,
	signature string,
) DoubleSignVoteRow {
	return DoubleSignVoteRow{
		ID:               id,
		VoteType:         voteType,
		Height:           height,
		Round:            round,
		BlockID:          blockID,
		ValidatorAddress: validatorAddress,
		ValidatorIndex:   validatorIndex,
		Signature:        signature,
	}
}

// Equal tells whether v and w represent the same rows
func (v DoubleSignVoteRow) Equal(w DoubleSignVoteRow) bool {
	return v.ID == w.ID &&
		v.VoteType == w.VoteType &&
		v.Height == w.Height &&
		v.Round == w.Round &&
		v.BlockID == w.BlockID &&
		v.ValidatorAddress == w.ValidatorAddress &&
		v.ValidatorIndex == w.ValidatorIndex &&
		v.Signature == w.Signature
}

//--------------------------------------------------------

// DoubleSignEvidenceRow represents a single row of the double_sign_evidence table
type DoubleSignEvidenceRow struct {
	Height  int64 `db:"height"`
	VoteAID int64 `db:"vote_a_id"`
	VoteBID int64 `db:"vote_b_id"`
}

// NewDoubleSignEvidenceRow allows to build a new NewDoubleSignEvidenceRow
func NewDoubleSignEvidenceRow(height int64, voteAID int64, voteBID int64) DoubleSignEvidenceRow {
	return DoubleSignEvidenceRow{
		Height:  height,
		VoteAID: voteAID,
		VoteBID: voteBID,
	}
}

// Equal tells whether v and w represent the same rows
func (v DoubleSignEvidenceRow) Equal(w DoubleSignEvidenceRow) bool {
	return v.VoteAID == w.VoteAID &&
		v.VoteBID == w.VoteBID &&
		v.Height == w.Height
}

'''
'''--- database/types/supply.go ---
package types

// SupplyRow represents a single row inside the "supply" table
type SupplyRow struct {
	OneRowID bool     `db:"one_row_id"`
	Coins    *DbCoins `db:"coins"`
	Height   int64    `db:"height"`
}

// NewSupplyRow allows to easily create a new NewSupplyRow
func NewSupplyRow(coins DbCoins, height int64) SupplyRow {
	return SupplyRow{
		OneRowID: true,
		Coins:    &coins,
		Height:   height,
	}
}

// Equals return true if one totalSupplyRow representing the same row as the original one
func (v SupplyRow) Equals(w SupplyRow) bool {
	return v.Coins.Equal(w.Coins) &&
		v.Height == w.Height
}

'''
'''--- database/types/upgrade.go ---
package types

type SoftwareUpgradePlanRow struct {
	ProposalID    uint64 `db:"proposal_id"`
	PlanName      string `db:"plan_name"`
	UpgradeHeight int64  `db:"upgrade_height"`
	Info          string `db:"info"`
	Height        int64  `db:"height"`
}

func NewSoftwareUpgradePlanRow(
	proposalID uint64, planName string, upgradeHeight int64, info string, height int64,
) SoftwareUpgradePlanRow {
	return SoftwareUpgradePlanRow{
		ProposalID:    proposalID,
		PlanName:      planName,
		UpgradeHeight: upgradeHeight,
		Info:          info,
		Height:        height,
	}
}

'''
'''--- database/types/utils.go ---
package types

// ModuleRow represents a single row inside the modules table
type ModuleRow struct {
	Module string `db:"module_name"`
}

// Equal return true if two moduleRow is equal
func (v ModuleRow) Equal(w ModuleRow) bool {
	return v.Module == w.Module
}

// ModuleRows represent an array of ModulerRow
type ModuleRows []*ModuleRow

// NewModuleRows return a new instance of ModuleRows
func NewModuleRows(names []string) ModuleRows {
	rows := make([]*ModuleRow, 0)
	for _, name := range names {
		rows = append(rows, &ModuleRow{Module: name})
	}
	return rows
}

// Equal return true if two ModulesRow is equal
func (v ModuleRows) Equal(w *ModuleRows) bool {
	if w == nil {
		return false
	}

	if len(v) != len(*w) {
		return false
	}

	for index, val := range v {
		if !val.Equal(*(*w)[index]) {
			return false
		}
	}
	return true
}

'''
'''--- database/utils.go ---
package database

import (
	"fmt"
)

// InsertEnableModules allows to save enabled module into the database
func (db *Db) InsertEnableModules(modules []string) error {
	if len(modules) == 0 {
		return nil
	}

	// Remove existing modules
	stmt := "DELETE FROM modules WHERE TRUE"
	_, err := db.SQL.Exec(stmt)
	if err != nil {
		return fmt.Errorf("error while deleting modules: %s", err)
	}

	if len(modules) == 0 {
		return nil
	}

	var values []interface{}
	stmt = `INSERT INTO modules (module_name) VALUES`
	for key, value := range modules {
		stmt += fmt.Sprintf("($%d),", key+1)
		values = append(values, value)
	}
	stmt = stmt[:len(stmt)-1] // remove tailing ","
	stmt += " ON CONFLICT DO NOTHING"
	_, err = db.SQL.Exec(stmt, values...)
	if err != nil {
		return fmt.Errorf("error while storing modules: %s", err)
	}

	return nil
}

'''
'''--- database/utils/bank.go ---
package utils

import "github.com/forbole/bdjuno/v5/types"

const (
	maxPostgreSQLParams = 65535
)

func SplitAccounts(accounts []types.Account, paramsNumber int) [][]types.Account {
	maxBalancesPerSlice := maxPostgreSQLParams / paramsNumber
	slices := make([][]types.Account, len(accounts)/maxBalancesPerSlice+1)

	sliceIndex := 0
	for index, account := range accounts {
		slices[sliceIndex] = append(slices[sliceIndex], account)

		if index > 0 && index%(maxBalancesPerSlice-1) == 0 {
			sliceIndex++
		}
	}

	return slices
}

'''
'''--- database/utils_test.go ---
package database_test

import (
	"github.com/forbole/bdjuno/v5/database/types"
)

func (suite *DbTestSuite) TestBigDipperDb_InsertEnableModules() {
	modules := []string{"auth", "bank", "consensus", "distribution", "gov", "mint", "pricefeed", "staking", "supply"}
	err := suite.database.InsertEnableModules(modules)
	suite.Require().NoError(err)

	var results types.ModuleRows
	err = suite.database.Sqlx.Select(&results, "SELECT * FROM modules")
	suite.Require().NoError(err)

	expected := types.NewModuleRows(modules)
	suite.Require().True(results.Equal(&expected))

}

'''
'''--- docker-compose.yml ---
version: '3.6'
services:
  hasura:
    image: hasura/graphql-engine:v2.0.4
    ports:
    - "8080:8080"
    restart: always
    environment:
      ## this env var can be used to add the above postgres database to Hasura as a data source. this can be removed/updated based on your needs
      HASURA_GRAPHQL_DATABASE_URL: postgres://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/${POSTGRES_DB}
      ## enable the console served by server
      HASURA_GRAPHQL_ENABLE_CONSOLE: "true" # set to "false" to disable console
      ## enable debugging mode. It is recommended to disable this in production
      HASURA_GRAPHQL_DEV_MODE: "true"
      HASURA_GRAPHQL_ENABLED_LOG_TYPES: startup, http-log, webhook-log, websocket-log, query-log
      ## uncomment next line to set an admin secret
      # HASURA_GRAPHQL_ADMIN_SECRET: myadminsecretkey
  bdjuno:
    build:
      context: .
      dockerfile: Dockerfile
    restart: always
    command: bdjuno parse --home /bdjuno/.bdjuno
    volumes:
      ## Modify first path to match configuration file.
      - /bdjuno/.bdjuno:/bdjuno/.bdjuno

'''
'''--- modules/actions/config.go ---
package actions

import (
	"github.com/forbole/juno/v5/node/remote"
	"gopkg.in/yaml.v3"
)

// Config contains the configuration about the actions module
type Config struct {
	Host string          `yaml:"host"`
	Port uint            `yaml:"port"`
	Node *remote.Details `yaml:"node,omitempty"`
}

// NewConfig returns a new Config instance
func NewConfig(host string, port uint, remoteDetails *remote.Details) *Config {
	return &Config{
		Host: host,
		Port: port,
		Node: remoteDetails,
	}
}

// DefaultConfig returns the default configuration
func DefaultConfig() *Config {
	return &Config{
		Host: "127.0.0.1",
		Port: 3000,
		Node: nil,
	}
}

func ParseConfig(bz []byte) (*Config, error) {
	type T struct {
		Config *Config `yaml:"actions"`
	}
	var cfg T
	err := yaml.Unmarshal(bz, &cfg)

	if cfg.Config == nil {
		return DefaultConfig(), nil
	}

	return cfg.Config, err
}

'''
'''--- modules/actions/handle_additional_operations.go ---
package actions

import (
	"os"
	"os/signal"
	"sync"
	"syscall"

	"github.com/forbole/bdjuno/v5/modules/actions/handlers"
	actionstypes "github.com/forbole/bdjuno/v5/modules/actions/types"
)

var (
	waitGroup sync.WaitGroup
)

func (m *Module) RunAdditionalOperations() error {
	// Build the worker
	context := actionstypes.NewContext(m.node, m.sources)
	worker := actionstypes.NewActionsWorker(context)

	// Register the endpoints

	// -- Bank --
	worker.RegisterHandler("/account_balance", handlers.AccountBalanceHandler)

	// -- Distribution --
	worker.RegisterHandler("/delegation_reward", handlers.DelegationRewardHandler)
	worker.RegisterHandler("/delegator_withdraw_address", handlers.DelegatorWithdrawAddressHandler)
	worker.RegisterHandler("/validator_commission_amount", handlers.ValidatorCommissionAmountHandler)

	// -- Staking Delegator --
	worker.RegisterHandler("/delegation", handlers.DelegationHandler)
	worker.RegisterHandler("/delegation_total", handlers.TotalDelegationAmountHandler)
	worker.RegisterHandler("/unbonding_delegation", handlers.UnbondingDelegationsHandler)
	worker.RegisterHandler("/unbonding_delegation_total", handlers.UnbondingDelegationsTotal)
	worker.RegisterHandler("/redelegation", handlers.RedelegationHandler)

	// -- Staking Validator --
	worker.RegisterHandler("/validator_delegations", handlers.ValidatorDelegation)
	worker.RegisterHandler("/validator_redelegations_from", handlers.ValidatorRedelegationsFromHandler)
	worker.RegisterHandler("/validator_unbonding_delegations", handlers.ValidatorUnbondingDelegationsHandler)

	// Listen for and trap any OS signal to gracefully shutdown and exit
	m.trapSignal()

	// Start the worker
	waitGroup.Add(1)
	go worker.Start(m.cfg.Host, m.cfg.Port)

	// Block main process (signal capture will call WaitGroup's Done)
	waitGroup.Wait()
	return nil
}

// trapSignal will listen for any OS signal and invoke Done on the main
// WaitGroup allowing the main process to gracefully exit.
func (m *Module) trapSignal() {
	var sigCh = make(chan os.Signal, 1)

	signal.Notify(sigCh, syscall.SIGTERM)
	signal.Notify(sigCh, syscall.SIGINT)

	go func() {
		defer m.node.Stop()
		defer waitGroup.Done()
	}()
}

'''
'''--- modules/actions/handlers/account_balance.go ---
package handlers

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	"github.com/rs/zerolog/log"
)

func AccountBalanceHandler(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Int64("height", payload.Input.Height).
		Msg("executing account balance action")

	height, err := ctx.GetHeight(payload)
	if err != nil {
		return nil, err
	}

	balance, err := ctx.Sources.BankSource.GetAccountBalance(payload.GetAddress(), height)
	if err != nil {
		return nil, fmt.Errorf("error while getting account balance: %s", err)
	}

	return types.Balance{
		Coins: types.ConvertCoins(balance),
	}, nil
}

'''
'''--- modules/actions/handlers/delegation.go ---
package handlers

import (
	"fmt"
	"strings"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	"google.golang.org/grpc/codes"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/rs/zerolog/log"
)

func DelegationHandler(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("action", "delegations").
		Str("address", payload.GetAddress()).
		Msg("executing delegations action")

	height, err := ctx.GetHeight(payload)
	if err != nil {
		return nil, err
	}

	// Get delegator's total rewards
	res, err := ctx.Sources.StakingSource.GetDelegationsWithPagination(height, payload.GetAddress(), payload.GetPagination())
	if err != nil {
		// For stargate only, returns without throwing error if delegator delegations are not found on the chain
		if strings.Contains(err.Error(), codes.NotFound.String()) {
			return err, nil
		}
		return err, fmt.Errorf("error while getting delegator delegations: %s", err)
	}

	delegations := make([]types.Delegation, len(res.DelegationResponses))
	for index, del := range res.DelegationResponses {
		delegations[index] = types.Delegation{
			DelegatorAddress: del.Delegation.DelegatorAddress,
			ValidatorAddress: del.Delegation.ValidatorAddress,
			Coins:            types.ConvertCoins([]sdk.Coin{del.Balance}),
		}
	}

	return types.DelegationResponse{
		Delegations: delegations,
		Pagination:  res.Pagination,
	}, nil
}

'''
'''--- modules/actions/handlers/delegation_total.go ---
package handlers

import (
	"fmt"
	"strings"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/rs/zerolog/log"
	"google.golang.org/grpc/codes"
)

func TotalDelegationAmountHandler(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Int64("height", payload.Input.Height).
		Msg("executing total delegation amount action")

	height, err := ctx.GetHeight(payload)
	if err != nil {
		return nil, err
	}

	// Get all  delegations for given delegator address
	delegationList, err := ctx.Sources.StakingSource.GetDelegationsWithPagination(height, payload.GetAddress(), nil)
	if err != nil {
		// For stargate only, returns without throwing error if delegator delegations are not found on the chain
		if strings.Contains(err.Error(), codes.NotFound.String()) {
			return err, nil
		}
		return err, fmt.Errorf("error while getting delegator delegations: %s", err)
	}

	var coinObject sdk.Coins

	// Add up total value of delegations
	for _, eachDelegation := range delegationList.DelegationResponses {
		for index, eachCoin := range coinObject {
			if eachCoin.Denom == eachDelegation.Balance.Denom {
				coinObject[index].Amount = coinObject[index].Amount.Add(eachDelegation.Balance.Amount)
			}
			if eachCoin.Denom != eachDelegation.Balance.Denom {
				coinObject = append(coinObject, sdk.NewCoin(eachDelegation.Balance.Denom, eachDelegation.Balance.Amount))
			}
		}
		if coinObject == nil {
			coinObject = append(coinObject, sdk.NewCoin(eachDelegation.Balance.Denom, eachDelegation.Balance.Amount))
		}
	}

	return types.Balance{
		Coins: types.ConvertCoins(coinObject),
	}, nil
}

'''
'''--- modules/actions/handlers/delegator_reward.go ---
package handlers

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	"github.com/rs/zerolog/log"
)

func DelegationRewardHandler(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Int64("height", payload.Input.Height).
		Msg("executing delegation rewards action")

	height, err := ctx.GetHeight(payload)
	if err != nil {
		return nil, err
	}

	// Get delegator's total rewards
	rewards, err := ctx.Sources.DistrSource.DelegatorTotalRewards(payload.GetAddress(), height)
	if err != nil {
		return nil, fmt.Errorf("error while getting delegator total rewards: %s", err)
	}

	delegationRewards := make([]types.DelegationReward, len(rewards))
	for index, rew := range rewards {
		delegationRewards[index] = types.DelegationReward{
			Coins:            types.ConvertDecCoins(rew.Reward),
			ValidatorAddress: rew.ValidatorAddress,
		}
	}

	return delegationRewards, nil
}

'''
'''--- modules/actions/handlers/delegator_withdraw_address.go ---
package handlers

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	"github.com/rs/zerolog/log"
)

func DelegatorWithdrawAddressHandler(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Msg("executing delegator withdraw address action")

	// Get latest node height
	height, err := ctx.GetHeight(nil)
	if err != nil {
		return nil, err
	}

	// Get delegator's total rewards
	withdrawAddress, err := ctx.Sources.DistrSource.DelegatorWithdrawAddress(payload.GetAddress(), height)
	if err != nil {
		return nil, fmt.Errorf("error while getting delegator withdraw address: %s", err)
	}

	return types.Address{
		Address: withdrawAddress,
	}, nil
}

'''
'''--- modules/actions/handlers/redelegation.go ---
package handlers

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/rs/zerolog/log"
)

func RedelegationHandler(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Int64("height", payload.Input.Height).
		Msg("executing redelegations action")

	height, err := ctx.GetHeight(payload)
	if err != nil {
		return nil, err
	}

	// Get delegator's redelegations
	redelegations, err := ctx.Sources.StakingSource.GetRedelegations(height, &stakingtypes.QueryRedelegationsRequest{
		DelegatorAddr: payload.GetAddress(),
		Pagination:    payload.GetPagination(),
	})
	if err != nil {
		return nil, fmt.Errorf("error while getting delegator redelegations: %s", err)
	}

	redelegationsList := make([]types.Redelegation, len(redelegations.RedelegationResponses))
	for index, del := range redelegations.RedelegationResponses {
		redelegationsList[index] = types.Redelegation{
			DelegatorAddress:    del.Redelegation.DelegatorAddress,
			ValidatorSrcAddress: del.Redelegation.ValidatorSrcAddress,
			ValidatorDstAddress: del.Redelegation.ValidatorDstAddress,
		}

		RedelegationEntriesList := make([]types.RedelegationEntry, len(del.Entries))
		for indexEntry, entry := range del.Entries {
			RedelegationEntriesList[indexEntry] = types.RedelegationEntry{
				CompletionTime: entry.RedelegationEntry.CompletionTime,
				Balance:        entry.Balance,
			}
		}

		redelegationsList[index].RedelegationEntries = RedelegationEntriesList
	}

	return types.RedelegationResponse{
		Redelegations: redelegationsList,
		Pagination:    redelegations.Pagination,
	}, nil
}

'''
'''--- modules/actions/handlers/unbonding_delegation_total.go ---
package handlers

import (
	"fmt"
	"math/big"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	"github.com/rs/zerolog/log"
)

func UnbondingDelegationsTotal(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Int64("height", payload.Input.Height).
		Msg("executing unbonding delegation total action")

	height, err := ctx.GetHeight(payload)
	if err != nil {
		return nil, err
	}

	// Get all unbonding delegations for given delegator address
	unbondingDelegations, err := ctx.Sources.StakingSource.GetUnbondingDelegations(height, payload.GetAddress(), nil)
	if err != nil {
		return nil, fmt.Errorf("error while getting delegator unbonding delegations: %s", err)
	}

	// Get the bond denom type
	params, err := ctx.Sources.StakingSource.GetParams(height)
	if err != nil {
		return nil, fmt.Errorf("error while getting bond denom type: %s", err)
	}

	// Add up total value of unbonding delegations
	var totalAmount = big.NewInt(0)
	for _, eachUnbondingDelegation := range unbondingDelegations.UnbondingResponses {
		for _, entry := range eachUnbondingDelegation.Entries {
			totalAmount = totalAmount.Add(totalAmount, entry.Balance.BigInt())
		}
	}

	return types.Balance{
		Coins: []types.Coin{
			{
				Denom:  params.BondDenom,
				Amount: totalAmount.String(),
			},
		},
	}, nil
}

'''
'''--- modules/actions/handlers/unbonding_delegations.go ---
package handlers

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	"github.com/rs/zerolog/log"
)

func UnbondingDelegationsHandler(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Int64("height", payload.Input.Height).
		Msg("executing unbonding delegations action")

	height, err := ctx.GetHeight(payload)
	if err != nil {
		return nil, err
	}

	// Get all unbonding delegations for given delegator address
	unbondingDelegations, err := ctx.Sources.StakingSource.GetUnbondingDelegations(height, payload.GetAddress(), payload.GetPagination())
	if err != nil {
		return nil, fmt.Errorf("error while getting delegator unbonding delegations: %s", err)
	}

	unbondingDelegationsList := make([]types.UnbondingDelegation, len(unbondingDelegations.UnbondingResponses))
	for index, del := range unbondingDelegations.UnbondingResponses {
		unbondingDelegationsList[index] = types.UnbondingDelegation{
			DelegatorAddress: del.DelegatorAddress,
			ValidatorAddress: del.ValidatorAddress,
			Entries:          del.Entries,
		}
	}

	return types.UnbondingDelegationResponse{
		UnbondingDelegations: unbondingDelegationsList,
		Pagination:           unbondingDelegations.Pagination,
	}, nil
}

'''
'''--- modules/actions/handlers/validator_commission.go ---
package handlers

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	"github.com/rs/zerolog/log"
)

func ValidatorCommissionAmountHandler(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Int64("height", payload.Input.Height).
		Msg("executing validator commission action")

	// Get latest node height
	height, err := ctx.GetHeight(nil)
	if err != nil {
		return nil, err
	}

	// Get validator total commission value
	commission, err := ctx.Sources.DistrSource.ValidatorCommission(payload.GetAddress(), height)
	if err != nil {
		return nil, fmt.Errorf("error while getting validator commission: %s", err)
	}

	return types.ValidatorCommissionAmount{
		Coins: types.ConvertDecCoins(commission),
	}, nil
}

'''
'''--- modules/actions/handlers/validator_delegation.go ---
package handlers

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/rs/zerolog/log"
)

func ValidatorDelegation(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Int64("height", payload.Input.Height).
		Msg("executing validator delegation action")

	// Get latest node height
	height, err := ctx.GetHeight(payload)
	if err != nil {
		return nil, err
	}

	// Get validator's total delegations
	res, err := ctx.Sources.StakingSource.GetValidatorDelegationsWithPagination(height, payload.GetAddress(), payload.GetPagination())
	if err != nil {
		return nil, fmt.Errorf("error while getting validator delegations: %s", err)
	}

	delegations := make([]types.Delegation, len(res.DelegationResponses))
	for index, del := range res.DelegationResponses {
		delegations[index] = types.Delegation{
			DelegatorAddress: del.Delegation.DelegatorAddress,
			ValidatorAddress: del.Delegation.ValidatorAddress,
			Coins:            types.ConvertCoins([]sdk.Coin{del.Balance}),
		}
	}

	return types.DelegationResponse{
		Delegations: delegations,
		Pagination:  res.Pagination,
	}, nil
}

'''
'''--- modules/actions/handlers/validator_redelegations_from.go ---
package handlers

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/rs/zerolog/log"
)

func ValidatorRedelegationsFromHandler(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Int64("height", payload.Input.Height).
		Msg("executing validator redelegation action")

	height, err := ctx.GetHeight(payload)
	if err != nil {
		return nil, err
	}

	// Get redelegations from a source validator address
	redelegations, err := ctx.Sources.StakingSource.GetRedelegations(height, &stakingtypes.QueryRedelegationsRequest{
		SrcValidatorAddr: payload.GetAddress(),
		Pagination:       payload.GetPagination(),
	})
	if err != nil {
		return nil, fmt.Errorf("error while getting redelegations from validator: %s", err)
	}

	redelegationsList := make([]types.Redelegation, len(redelegations.RedelegationResponses))
	for index, del := range redelegations.RedelegationResponses {
		redelegationsList[index] = types.Redelegation{
			DelegatorAddress:    del.Redelegation.DelegatorAddress,
			ValidatorSrcAddress: del.Redelegation.ValidatorSrcAddress,
			ValidatorDstAddress: del.Redelegation.ValidatorDstAddress,
		}

		RedelegationEntriesList := make([]types.RedelegationEntry, len(del.Entries))
		for indexEntry, entry := range del.Entries {
			RedelegationEntriesList[indexEntry] = types.RedelegationEntry{
				CompletionTime: entry.RedelegationEntry.CompletionTime,
				Balance:        entry.Balance,
			}
		}
		redelegationsList[index].RedelegationEntries = RedelegationEntriesList
	}

	return types.RedelegationResponse{
		Redelegations: redelegationsList,
		Pagination:    redelegations.Pagination,
	}, nil
}

'''
'''--- modules/actions/handlers/validator_unbonding_delegations.go ---
package handlers

import (
	"fmt"

	"github.com/forbole/bdjuno/v5/modules/actions/types"

	"github.com/rs/zerolog/log"
)

func ValidatorUnbondingDelegationsHandler(ctx *types.Context, payload *types.Payload) (interface{}, error) {
	log.Debug().Str("address", payload.GetAddress()).
		Int64("height", payload.Input.Height).
		Msg("executing validator unbonding delegations action")

	// Get latest node height
	height, err := ctx.GetHeight(payload)
	if err != nil {
		return nil, err
	}

	// Get all unbonding delegations from the given validator opr address
	unbondingDelegations, err := ctx.Sources.StakingSource.GetUnbondingDelegationsFromValidator(
		height,
		payload.GetAddress(),
		payload.GetPagination(),
	)
	if err != nil {
		return nil, fmt.Errorf("error while getting all unbonding delegations from validator %s: %s",
			payload.GetAddress(), err)
	}

	unbondingDelegationsList := make([]types.UnbondingDelegation, len(unbondingDelegations.UnbondingResponses))
	for index, del := range unbondingDelegations.UnbondingResponses {
		unbondingDelegationsList[index] = types.UnbondingDelegation{
			DelegatorAddress: del.DelegatorAddress,
			ValidatorAddress: del.ValidatorAddress,
			Entries:          del.Entries,
		}
	}

	return types.UnbondingDelegationResponse{
		UnbondingDelegations: unbondingDelegationsList,
		Pagination:           unbondingDelegations.Pagination,
	}, nil
}

'''
'''--- modules/actions/logging/prometheus.go ---
package logging

import (
	"github.com/prometheus/client_golang/prometheus"
)

// ActionResponseTime represents the Telemetry counter used to classify each executed action by response time
var ActionResponseTime = prometheus.NewHistogramVec(
	prometheus.HistogramOpts{
		Name:    "bdjuno_action_response_time",
		Help:    "Time it has taken to execute an action",
		Buckets: []float64{0.5, 1, 2, 3, 4, 5},
	}, []string{"path"})

// ActionCounter represents the Telemetry counter used to track the total number of actions executed
var ActionCounter = prometheus.NewCounterVec(
	prometheus.CounterOpts{
		Name: "bdjuno_actions_total_count",
		Help: "Total number of actions executed.",
	}, []string{"path", "http_status_code"})

// ActionErrorCounter represents the Telemetry counter used to track the number of action's errors emitted
var ActionErrorCounter = prometheus.NewCounterVec(
	prometheus.CounterOpts{
		Name: "bdjuno_actions_error_count",
		Help: "Total number of errors emitted.",
	}, []string{"path", "http_status_code"},
)

func init() {
	err := prometheus.Register(ActionResponseTime)
	if err != nil {
		panic(err)
	}

	err = prometheus.Register(ActionCounter)
	if err != nil {
		panic(err)
	}

	err = prometheus.Register(ActionErrorCounter)
	if err != nil {
		panic(err)
	}
}

'''
'''--- modules/actions/logging/utils.go ---
package logging

import (
	"fmt"
	"net/http"
	"time"
)

func SuccessCounter(path string) {
	ActionCounter.WithLabelValues(path, fmt.Sprintf("%d", http.StatusOK)).Inc()
}

func ErrorCounter(path string) {
	ActionErrorCounter.WithLabelValues(path, fmt.Sprintf("%d", http.StatusInternalServerError)).Inc()
}

func ReponseTimeBuckets(path string, start time.Time) {
	ActionResponseTime.WithLabelValues(path).
		Observe(time.Since(start).Seconds())
}

'''
'''--- modules/actions/module.go ---
package actions

import (
	"cosmossdk.io/simapp/params"
	"github.com/forbole/juno/v5/modules"
	"github.com/forbole/juno/v5/node"
	"github.com/forbole/juno/v5/node/builder"
	nodeconfig "github.com/forbole/juno/v5/node/config"
	"github.com/forbole/juno/v5/types/config"

	modulestypes "github.com/forbole/bdjuno/v5/modules/types"
)

const (
	ModuleName = "actions"
)

var (
	_ modules.Module                     = &Module{}
	_ modules.AdditionalOperationsModule = &Module{}
)

type Module struct {
	cfg     *Config
	node    node.Node
	sources *modulestypes.Sources
}

func NewModule(cfg config.Config, encodingConfig *params.EncodingConfig) *Module {
	bz, err := cfg.GetBytes()
	if err != nil {
		panic(err)
	}

	actionsCfg, err := ParseConfig(bz)
	if err != nil {
		panic(err)
	}

	nodeCfg := cfg.Node
	if actionsCfg.Node != nil {
		nodeCfg = nodeconfig.NewConfig(nodeconfig.TypeRemote, actionsCfg.Node)
	}

	// Build the node
	junoNode, err := builder.BuildNode(nodeCfg, encodingConfig)
	if err != nil {
		panic(err)
	}

	// Build the sources
	sources, err := modulestypes.BuildSources(nodeCfg, encodingConfig)
	if err != nil {
		panic(err)
	}

	return &Module{
		cfg:     actionsCfg,
		node:    junoNode,
		sources: sources,
	}
}

func (m *Module) Name() string {
	return ModuleName
}

'''
'''--- modules/actions/types/handler.go ---
package types

import (
	"fmt"

	"github.com/forbole/juno/v5/node"

	modulestypes "github.com/forbole/bdjuno/v5/modules/types"
)

// Context contains the data about a Hasura actions worker execution
type Context struct {
	node    node.Node
	Sources *modulestypes.Sources
}

// NewContext returns a new Context instance
func NewContext(node node.Node, sources *modulestypes.Sources) *Context {
	return &Context{
		node:    node,
		Sources: sources,
	}
}

// GetHeight uses the lastest height when the input height is empty from graphql request
func (c *Context) GetHeight(payload *Payload) (int64, error) {
	if payload == nil || payload.Input.Height == 0 {
		latestHeight, err := c.node.LatestHeight()
		if err != nil {
			return 0, fmt.Errorf("error while getting chain latest block height: %s", err)
		}
		return latestHeight, nil
	}

	return payload.Input.Height, nil
}

// ActionHandler represents a Hasura action request handler.
// It returns an interface to be returned to the called, or an error if something is wrong
type ActionHandler = func(context *Context, payload *Payload) (interface{}, error)

'''
'''--- modules/actions/types/payload.go ---
package types

import "github.com/cosmos/cosmos-sdk/types/query"

// Payload contains the payload data that is sent from Hasura
type Payload struct {
	SessionVariables map[string]interface{} `json:"session_variables"`
	Input            PayloadArgs            `json:"input"`
}

// GetAddress returns the address associated with this payload, if any
func (p *Payload) GetAddress() string {
	return p.Input.Address
}

// GetPagination returns the pagination asasociated with this payload, if any
func (p *Payload) GetPagination() *query.PageRequest {
	return &query.PageRequest{
		Offset:     p.Input.Offset,
		Limit:      p.Input.Limit,
		CountTotal: p.Input.CountTotal,
	}
}

type PayloadArgs struct {
	Address    string `json:"address"`
	Height     int64  `json:"height"`
	Offset     uint64 `json:"offset"`
	Limit      uint64 `json:"limit"`
	CountTotal bool   `json:"count_total"`
}

'''
'''--- modules/actions/types/response.go ---
package types

import (
	"time"

	sdkmath "cosmossdk.io/math"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/query"
	stakingtype "github.com/cosmos/cosmos-sdk/x/staking/types"
)

type Coin struct {
	Amount string `json:"amount"`
	Denom  string `json:"denom"`
}

func ConvertCoins(coins sdk.Coins) []Coin {
	amount := make([]Coin, 0)
	for _, coin := range coins {
		amount = append(amount, Coin{Amount: coin.Amount.String(), Denom: coin.Denom})
	}
	return amount
}

func ConvertDecCoins(coins sdk.DecCoins) []Coin {
	amount := make([]Coin, 0)
	for _, coin := range coins {
		amount = append(amount, Coin{Amount: coin.Amount.String(), Denom: coin.Denom})
	}
	return amount
}

// ========================= Withdraw Address Response =========================

type Address struct {
	Address string `json:"address"`
}

// ========================= Account Balance Response =========================

type Balance struct {
	Coins []Coin `json:"coins"`
}

// ========================= Delegation Response =========================

type DelegationResponse struct {
	Delegations []Delegation        `json:"delegations"`
	Pagination  *query.PageResponse `json:"pagination"`
}

type Delegation struct {
	DelegatorAddress string `json:"delegator_address"`
	ValidatorAddress string `json:"validator_address"`
	Coins            []Coin `json:"coins"`
}

// ========================= Delegation Reward Response =========================

type DelegationReward struct {
	Coins            []Coin `json:"coins"`
	ValidatorAddress string `json:"validator_address"`
}

// ========================= Validator Commission Response =========================

type ValidatorCommissionAmount struct {
	Coins []Coin `json:"coins"`
}

// ========================= Unbonding Delegation Response =========================

type UnbondingDelegationResponse struct {
	UnbondingDelegations []UnbondingDelegation `json:"unbonding_delegations"`
	Pagination           *query.PageResponse   `json:"pagination"`
}

type UnbondingDelegation struct {
	DelegatorAddress string                                 `json:"delegator_address"`
	ValidatorAddress string                                 `json:"validator_address"`
	Entries          []stakingtype.UnbondingDelegationEntry `json:"entries"`
}

// ========================= Redelegation Response =========================

type RedelegationResponse struct {
	Redelegations []Redelegation      `json:"redelegations"`
	Pagination    *query.PageResponse `json:"pagination"`
}

type Redelegation struct {
	DelegatorAddress    string              `json:"delegator_address"`
	ValidatorSrcAddress string              `json:"validator_src_address"`
	ValidatorDstAddress string              `json:"validator_dst_address"`
	RedelegationEntries []RedelegationEntry `json:"entries"`
}

type RedelegationEntry struct {
	CompletionTime time.Time   `json:"completion_time"`
	Balance        sdkmath.Int `json:"balance"`
}

'''
'''--- modules/actions/types/utils.go ---
package types

type GraphQLError struct {
	Message string `json:"message"`
}

'''
'''--- modules/actions/types/worker.go ---
package types

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"github.com/forbole/bdjuno/v5/modules/actions/logging"

	"github.com/rs/zerolog/log"
)

// ActionsWorker represents the worker that is used to handle Hasura actions queries
type ActionsWorker struct {
	mux     *http.ServeMux
	context *Context
}

// NewActionsWorker returns a new ActionsWorker instance
func NewActionsWorker(context *Context) *ActionsWorker {
	return &ActionsWorker{
		mux:     http.NewServeMux(),
		context: context,
	}
}

// RegisterHandler registers the provided handler to be used on each call to the provided path
func (w *ActionsWorker) RegisterHandler(path string, handler ActionHandler) {
	log.Debug().Str("action", path).Msg("registering actions handler")
	w.mux.HandleFunc(path, func(writer http.ResponseWriter, request *http.Request) {
		start := time.Now()

		// Set the content type
		writer.Header().Set("Content-Type", "application/json")

		// Read the body
		reqBody, err := io.ReadAll(request.Body)
		if err != nil {
			http.Error(writer, "invalid payload", http.StatusBadRequest)
			return
		}
		defer request.Body.Close()

		// Get the actions payload
		var payload Payload
		err = json.Unmarshal(reqBody, &payload)
		if err != nil {
			http.Error(writer, "invalid payload: failed to unmarshal json", http.StatusInternalServerError)
			return
		}

		// Handle the request
		res, err := handler(w.context, &payload)
		if err != nil {
			logging.ErrorCounter(path)
			w.handleError(writer, path, err)
			return
		}

		// Marshal the response
		data, err := json.Marshal(res)
		if err != nil {
			logging.ErrorCounter(path)
			w.handleError(writer, path, err)
			return
		}

		// Prometheus
		logging.SuccessCounter(path)
		logging.ReponseTimeBuckets(path, start)

		// Write the response
		writer.Write(data)
	})
}

// handleError allows to handle the given error by writing it to the provided writer
func (w *ActionsWorker) handleError(writer http.ResponseWriter, path string, err error) {
	log.Error().Str("action", path).
		Err(err).Msg("error while executing action")

	errorObject := GraphQLError{
		Message: err.Error(),
	}
	errorBody, err := json.Marshal(errorObject)
	if err != nil {
		panic(err)
	}

	writer.WriteHeader(http.StatusBadRequest)
	writer.Write(errorBody)
}

// Start starts the worker
func (w *ActionsWorker) Start(host string, port uint) {
	server := &http.Server{
		Addr:              fmt.Sprintf("%s:%d", host, port),
		Handler:           w.mux,
		ReadHeaderTimeout: 3 * time.Second,
	}

	err := server.ListenAndServe()

	if err != nil {
		panic(err)
	}
}

'''
'''--- modules/auth/auth_accounts.go ---
package auth

import (
	"encoding/json"

	"github.com/cosmos/cosmos-sdk/codec"
	authttypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/types"
)

// GetGenesisAccounts parses the given appState and returns the genesis accounts
func GetGenesisAccounts(appState map[string]json.RawMessage, cdc codec.Codec) ([]types.Account, error) {
	var authState authttypes.GenesisState
	if err := cdc.UnmarshalJSON(appState[authttypes.ModuleName], &authState); err != nil {
		return nil, err
	}

	// Store the accounts
	accounts := make([]types.Account, len(authState.Accounts))
	for index, account := range authState.Accounts {
		var accountI authttypes.AccountI
		err := cdc.UnpackAny(account, &accountI)
		if err != nil {
			return nil, err
		}

		accounts[index] = types.NewAccount(accountI.GetAddress().String())
	}

	return accounts, nil
}

// --------------------------------------------------------------------------------------------------------------------

// GetAccounts returns the account data for the given addresses
func GetAccounts(height int64, addresses []string) []types.Account {
	log.Debug().Str("module", "auth").Str("operation", "accounts").Msg("getting accounts data")

	// Get all the accounts information
	var accounts = make([]types.Account, len(addresses))
	for index, address := range addresses {
		accounts[index] = types.NewAccount(address)
	}

	return accounts
}

// RefreshAccounts takes the given addresses and for each one queries the chain
// retrieving the account data and stores it inside the database.
func (m *Module) RefreshAccounts(height int64, addresses []string) error {
	accounts := GetAccounts(height, addresses)
	return m.db.SaveAccounts(accounts)
}

'''
'''--- modules/auth/auth_vesting_accounts.go ---
package auth

import (
	"encoding/json"

	"github.com/cosmos/cosmos-sdk/codec"
	authttypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	"github.com/cosmos/cosmos-sdk/x/auth/vesting/exported"
)

// GetGenesisVestingAccounts parses the given appState and returns the genesis vesting accounts
func GetGenesisVestingAccounts(appState map[string]json.RawMessage, cdc codec.Codec) ([]exported.VestingAccount, error) {
	var authState authttypes.GenesisState
	if err := cdc.UnmarshalJSON(appState[authttypes.ModuleName], &authState); err != nil {
		return nil, err
	}

	// Build vestingAccounts Array
	var vestingAccounts []exported.VestingAccount
	for _, account := range authState.Accounts {
		var accountI authttypes.AccountI
		err := cdc.UnpackAny(account, &accountI)
		if err != nil {
			return nil, err
		}

		vestingAccount, ok := accountI.(exported.VestingAccount)
		if !ok {
			continue
		}
		vestingAccounts = append(vestingAccounts, vestingAccount)
	}

	return vestingAccounts, nil
}

'''
'''--- modules/auth/handle_genesis.go ---
package auth

import (
	"encoding/json"
	"fmt"

	tmtypes "github.com/cometbft/cometbft/types"

	"github.com/rs/zerolog/log"
)

// HandleGenesis implements modules.GenesisModule
func (m *Module) HandleGenesis(_ *tmtypes.GenesisDoc, appState map[string]json.RawMessage) error {
	log.Debug().Str("module", "auth").Msg("parsing genesis")

	accounts, err := GetGenesisAccounts(appState, m.cdc)
	if err != nil {
		return fmt.Errorf("error while getting genesis accounts: %s", err)
	}
	err = m.db.SaveAccounts(accounts)
	if err != nil {
		return fmt.Errorf("error while storing genesis accounts: %s", err)
	}

	vestingAccounts, err := GetGenesisVestingAccounts(appState, m.cdc)
	if err != nil {
		return fmt.Errorf("error while getting genesis vesting accounts: %s", err)
	}
	err = m.db.SaveVestingAccounts(vestingAccounts)
	if err != nil {
		return fmt.Errorf("error while storing genesis vesting accounts: %s", err)
	}

	return nil
}

'''
'''--- modules/auth/handle_msg.go ---
package auth

import (
	"fmt"
	"time"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/gogoproto/proto"
	juno "github.com/forbole/juno/v5/types"
	"github.com/rs/zerolog/log"

	authttypes "github.com/cosmos/cosmos-sdk/x/auth/types"
	vestingtypes "github.com/cosmos/cosmos-sdk/x/auth/vesting/types"

	"github.com/forbole/bdjuno/v5/modules/utils"
	"github.com/forbole/bdjuno/v5/types"
)

// HandleMsg implements modules.MessageModule
func (m *Module) HandleMsg(_ int, msg sdk.Msg, tx *juno.Tx) error {
	addresses, err := m.messagesParser(m.cdc, msg)
	if err != nil {
		log.Error().Str("module", "auth").Err(err).
			Str("operation", "refresh account").
			Msgf("error while refreshing accounts after message of type %s", proto.MessageName(msg))
	}

	if cosmosMsg, ok := msg.(*vestingtypes.MsgCreateVestingAccount); ok {
		// Store tx timestamp as start_time of the created vesting account
		timestamp, err := time.Parse(time.RFC3339, tx.Timestamp)
		if err != nil {
			return fmt.Errorf("error while parsing time: %s", err)
		}

		err = m.handleMsgCreateVestingAccount(cosmosMsg, timestamp)
		if err != nil {
			return fmt.Errorf("error while handling MsgCreateVestingAccount %s", err)
		}
	}

	return m.RefreshAccounts(tx.Height, utils.FilterNonAccountAddresses(addresses))
}

func (m *Module) handleMsgCreateVestingAccount(msg *vestingtypes.MsgCreateVestingAccount, txTimestamp time.Time) error {

	accAddress, err := sdk.AccAddressFromBech32(msg.ToAddress)
	if err != nil {
		return fmt.Errorf("error while converting account address %s", err)
	}

	// store account in database
	err = m.db.SaveAccounts([]types.Account{types.NewAccount(accAddress.String())})
	if err != nil {
		return fmt.Errorf("error while storing vesting account: %s", err)
	}

	bva := vestingtypes.NewBaseVestingAccount(
		authttypes.NewBaseAccountWithAddress(accAddress), msg.Amount, msg.EndTime,
	)
	err = m.db.StoreBaseVestingAccountFromMsg(bva, txTimestamp)
	if err != nil {
		return fmt.Errorf("error while storing base vesting account from msg %s", err)
	}
	return nil
}

'''
'''--- modules/auth/module.go ---
package auth

import (
	"github.com/cosmos/cosmos-sdk/codec"

	"github.com/forbole/bdjuno/v5/database"

	"github.com/forbole/juno/v5/modules"
	"github.com/forbole/juno/v5/modules/messages"
)

var (
	_ modules.Module        = &Module{}
	_ modules.GenesisModule = &Module{}
	_ modules.MessageModule = &Module{}
)

// Module represents the x/auth module
type Module struct {
	cdc            codec.Codec
	db             *database.Db
	messagesParser messages.MessageAddressesParser
}

// NewModule builds a new Module instance
func NewModule(messagesParser messages.MessageAddressesParser, cdc codec.Codec, db *database.Db) *Module {
	return &Module{
		messagesParser: messagesParser,
		cdc:            cdc,
		db:             db,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "auth"
}

'''
'''--- modules/bank/handle_periodic_operations.go ---
package bank

import (
	"fmt"

	"github.com/go-co-op/gocron"
	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/modules/utils"
)

// RegisterPeriodicOperations implements modules.Module
func (m *Module) RegisterPeriodicOperations(scheduler *gocron.Scheduler) error {
	log.Debug().Str("module", "bank").Msg("setting up periodic tasks")

	if _, err := scheduler.Every(10).Minutes().Do(func() {
		utils.WatchMethod(m.UpdateSupply)
	}); err != nil {
		return fmt.Errorf("error while setting up bank periodic operation: %s", err)
	}

	return nil
}

// UpdateSupply updates the supply of all the tokens
func (m *Module) UpdateSupply() error {
	log.Trace().Str("module", "bank").Str("operation", "total supply").
		Msg("updating total supply")

	height, err := m.db.GetLastBlockHeight()
	if err != nil {
		return fmt.Errorf("error while getting latest block height: %s", err)
	}

	supply, err := m.keeper.GetSupply(height)
	if err != nil {
		return err
	}

	return m.db.SaveSupply(supply, height)
}

'''
'''--- modules/bank/module.go ---
package bank

import (
	"github.com/cosmos/cosmos-sdk/codec"

	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules/bank/source"

	junomessages "github.com/forbole/juno/v5/modules/messages"

	"github.com/forbole/juno/v5/modules"
)

var (
	_ modules.Module                   = &Module{}
	_ modules.PeriodicOperationsModule = &Module{}
)

// Module represents the x/bank module
type Module struct {
	cdc codec.Codec
	db  *database.Db

	messageParser junomessages.MessageAddressesParser
	keeper        source.Source
}

// NewModule returns a new Module instance
func NewModule(
	messageParser junomessages.MessageAddressesParser, keeper source.Source, cdc codec.Codec, db *database.Db,
) *Module {
	return &Module{
		cdc:           cdc,
		db:            db,
		messageParser: messageParser,
		keeper:        keeper,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "bank"
}

'''
'''--- modules/bank/source/local/source.go ---
package local

import (
	"fmt"

	"github.com/cosmos/cosmos-sdk/types/query"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/forbole/juno/v5/node/local"

	"github.com/forbole/bdjuno/v5/modules/bank/source"
	"github.com/forbole/bdjuno/v5/types"
)

var (
	_ source.Source = &Source{}
)

// Source represents the implementation of the bank keeper that works on a local node
type Source struct {
	*local.Source
	q banktypes.QueryServer
}

// NewSource builds a new Source instance
func NewSource(source *local.Source, bk banktypes.QueryServer) *Source {
	return &Source{
		Source: source,
		q:      bk,
	}
}

// GetBalances implements keeper.Source
func (s Source) GetBalances(addresses []string, height int64) ([]types.AccountBalance, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	var balances []types.AccountBalance
	for _, address := range addresses {
		res, err := s.q.AllBalances(sdk.WrapSDKContext(ctx), &banktypes.QueryAllBalancesRequest{Address: address})
		if err != nil {
			return nil, err
		}

		balances = append(balances, types.NewAccountBalance(address, res.Balances, height))
	}

	return balances, nil
}

// GetSupply implements bankkeeper.Source
func (s Source) GetSupply(height int64) (sdk.Coins, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	var coins []sdk.Coin
	var nextKey []byte
	var stop = false
	for !stop {
		res, err := s.q.TotalSupply(
			sdk.WrapSDKContext(ctx),
			&banktypes.QueryTotalSupplyRequest{
				Pagination: &query.PageRequest{
					Key:   nextKey,
					Limit: 100, // Query 100 supplies at time
				},
			})
		if err != nil {
			return nil, fmt.Errorf("error while getting total supply: %s", err)
		}

		nextKey = res.Pagination.NextKey
		stop = len(res.Pagination.NextKey) == 0
		coins = append(coins, res.Supply...)
	}

	return coins, nil
}

// GetAccountBalances implements bankkeeper.Source
func (s Source) GetAccountBalance(address string, height int64) ([]sdk.Coin, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	balRes, err := s.q.AllBalances(sdk.WrapSDKContext(ctx), &banktypes.QueryAllBalancesRequest{Address: address})
	if err != nil {
		return nil, fmt.Errorf("error while getting all balances: %s", err)
	}

	return balRes.Balances, nil
}

'''
'''--- modules/bank/source/remote/source.go ---
package remote

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/query"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
	"github.com/forbole/juno/v5/node/remote"

	bankkeeper "github.com/forbole/bdjuno/v5/modules/bank/source"
	"github.com/forbole/bdjuno/v5/types"
)

var (
	_ bankkeeper.Source = &Source{}
)

type Source struct {
	*remote.Source
	bankClient banktypes.QueryClient
}

// NewSource builds a new Source instance
func NewSource(source *remote.Source, bankClient banktypes.QueryClient) *Source {
	return &Source{
		Source:     source,
		bankClient: bankClient,
	}
}

// GetBalances implements bankkeeper.Source
func (s Source) GetBalances(addresses []string, height int64) ([]types.AccountBalance, error) {
	ctx := remote.GetHeightRequestContext(s.Ctx, height)

	var balances []types.AccountBalance
	for _, address := range addresses {
		balRes, err := s.bankClient.AllBalances(ctx, &banktypes.QueryAllBalancesRequest{Address: address})
		if err != nil {
			return nil, fmt.Errorf("error while getting all balances: %s", err)
		}

		balances = append(balances, types.NewAccountBalance(
			address,
			balRes.Balances,
			height,
		))
	}

	return balances, nil
}

// GetSupply implements bankkeeper.Source
func (s Source) GetSupply(height int64) (sdk.Coins, error) {
	ctx := remote.GetHeightRequestContext(s.Ctx, height)

	var coins []sdk.Coin
	var nextKey []byte
	var stop = false
	for !stop {
		res, err := s.bankClient.TotalSupply(
			ctx,
			&banktypes.QueryTotalSupplyRequest{
				Pagination: &query.PageRequest{
					Key:   nextKey,
					Limit: 100, // Query 100 supplies at time
				},
			})
		if err != nil {
			return nil, fmt.Errorf("error while getting total supply: %s", err)
		}

		nextKey = res.Pagination.NextKey
		stop = len(res.Pagination.NextKey) == 0
		coins = append(coins, res.Supply...)
	}

	return coins, nil
}

'''
'''--- modules/bank/source/remote/source_actions.go ---
package remote

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"

	"github.com/forbole/bdjuno/v5/utils"
)

// GetAccountBalances implements bankkeeper.Source
func (s Source) GetAccountBalance(address string, height int64) ([]sdk.Coin, error) {

	// Get account balance at certain height
	ctx := utils.GetHeightRequestContext(s.Ctx, height)
	balRes, err := s.bankClient.AllBalances(ctx, &banktypes.QueryAllBalancesRequest{Address: address})
	if err != nil {
		return nil, fmt.Errorf("error while getting all balances: %s", err)
	}

	return balRes.Balances, nil
}

'''
'''--- modules/bank/source/source.go ---
package source

import (
	sdk "github.com/cosmos/cosmos-sdk/types"

	"github.com/forbole/bdjuno/v5/types"
)

type Source interface {
	GetBalances(addresses []string, height int64) ([]types.AccountBalance, error)
	GetSupply(height int64) (sdk.Coins, error)

	// -- For hasura action --
	GetAccountBalance(address string, height int64) ([]sdk.Coin, error)
}

'''
'''--- modules/consensus/handle_block.go ---
package consensus

import (
	"fmt"

	"github.com/forbole/juno/v5/types"

	"github.com/rs/zerolog/log"

	tmctypes "github.com/cometbft/cometbft/rpc/core/types"
)

// HandleBlock implements modules.Module
func (m *Module) HandleBlock(
	b *tmctypes.ResultBlock, _ *tmctypes.ResultBlockResults, _ []*types.Tx, _ *tmctypes.ResultValidators,
) error {
	err := m.updateBlockTimeFromGenesis(b)
	if err != nil {
		log.Error().Str("module", "consensus").Int64("height", b.Block.Height).
			Err(err).Msg("error while updating block time from genesis")
	}

	return nil
}

// updateBlockTimeFromGenesis insert average block time from genesis
func (m *Module) updateBlockTimeFromGenesis(block *tmctypes.ResultBlock) error {
	log.Trace().Str("module", "consensus").Int64("height", block.Block.Height).
		Msg("updating block time from genesis")

	genesis, err := m.db.GetGenesis()
	if err != nil {
		return fmt.Errorf("error while getting genesis: %s", err)
	}
	if genesis == nil {
		return fmt.Errorf("genesis table is empty")
	}

	// Skip if the genesis does not exist
	if genesis == nil {
		return nil
	}

	newBlockTime := block.Block.Time.Sub(genesis.Time).Seconds() / float64(block.Block.Height-genesis.InitialHeight)
	return m.db.SaveAverageBlockTimeGenesis(newBlockTime, block.Block.Height)
}

'''
'''--- modules/consensus/handle_genesis.go ---
package consensus

import (
	"encoding/json"
	"fmt"

	"github.com/forbole/bdjuno/v5/types"

	tmtypes "github.com/cometbft/cometbft/types"
	"github.com/rs/zerolog/log"
)

// HandleGenesis implements modules.Module
func (m *Module) HandleGenesis(doc *tmtypes.GenesisDoc, _ map[string]json.RawMessage) error {
	log.Debug().Str("module", "consensus").Msg("parsing genesis")

	// Save the genesis time
	err := m.db.SaveGenesis(types.NewGenesis(doc.ChainID, doc.GenesisTime, doc.InitialHeight))
	if err != nil {
		return fmt.Errorf("error while storing genesis time: %s", err)
	}

	return nil
}

'''
'''--- modules/consensus/handle_periodic_operations.go ---
package consensus

import (
	"fmt"

	"github.com/go-co-op/gocron"
	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/modules/utils"
)

// RegisterPeriodicOperations implements modules.Module
func (m *Module) RegisterPeriodicOperations(scheduler *gocron.Scheduler) error {
	log.Debug().Str("module", "consensus").Msg("setting up periodic tasks")

	if _, err := scheduler.Every(1).Minute().Do(func() {
		utils.WatchMethod(m.updateBlockTimeInMinute)
	}); err != nil {
		return fmt.Errorf("error while setting up consensus periodic operation: %s", err)
	}

	if _, err := scheduler.Every(1).Hour().Do(func() {
		utils.WatchMethod(m.updateBlockTimeInHour)
	}); err != nil {
		return fmt.Errorf("error while setting up consensus periodic operation: %s", err)
	}

	if _, err := scheduler.Every(1).Day().Do(func() {
		utils.WatchMethod(m.updateBlockTimeInDay)
	}); err != nil {
		return fmt.Errorf("error while setting up consensus periodic operation: %s", err)
	}

	return nil
}

// updateBlockTimeInMinute insert average block time in the latest minute
func (m *Module) updateBlockTimeInMinute() error {
	log.Trace().Str("module", "consensus").Str("operation", "block time").
		Msg("updating block time in minutes")

	block, err := m.db.GetLastBlock()
	if err != nil {
		return fmt.Errorf("error while getting last block: %s", err)
	}

	genesis, err := m.db.GetGenesis()
	if err != nil {
		return fmt.Errorf("error while getting genesis: %s", err)
	}

	// Skip if the genesis does not exist
	if genesis == nil {
		return nil
	}

	// Check if the chain has been created at least a minute ago
	if block.Timestamp.Sub(genesis.Time).Minutes() < 0 {
		return nil
	}

	minute, err := m.db.GetBlockHeightTimeMinuteAgo(block.Timestamp)
	if err != nil {
		return fmt.Errorf("error while gettting block height a minute ago: %s", err)
	}
	newBlockTime := block.Timestamp.Sub(minute.Timestamp).Seconds() / float64(block.Height-minute.Height)

	return m.db.SaveAverageBlockTimePerMin(newBlockTime, block.Height)
}

// updateBlockTimeInHour insert average block time in the latest hour
func (m *Module) updateBlockTimeInHour() error {
	log.Trace().Str("module", "consensus").Str("operation", "block time").
		Msg("updating block time in hours")

	block, err := m.db.GetLastBlock()
	if err != nil {
		return fmt.Errorf("error while getting last block: %s", err)
	}

	genesis, err := m.db.GetGenesis()
	if err != nil {
		return fmt.Errorf("error while getting genesis: %s", err)
	}

	// Skip if the genesis does not exist
	if genesis == nil {
		return nil
	}

	// Check if the chain has been created at least an hour ago
	if block.Timestamp.Sub(genesis.Time).Hours() < 0 {
		return nil
	}

	hour, err := m.db.GetBlockHeightTimeHourAgo(block.Timestamp)
	if err != nil {
		return fmt.Errorf("error while getting block height an hour ago: %s", err)
	}
	newBlockTime := block.Timestamp.Sub(hour.Timestamp).Seconds() / float64(block.Height-hour.Height)

	return m.db.SaveAverageBlockTimePerHour(newBlockTime, block.Height)
}

// updateBlockTimeInDay insert average block time in the latest minute
func (m *Module) updateBlockTimeInDay() error {
	log.Trace().Str("module", "consensus").Str("operation", "block time").
		Msg("updating block time in days")

	block, err := m.db.GetLastBlock()
	if err != nil {
		return fmt.Errorf("error while getting last block: %s", err)
	}

	genesis, err := m.db.GetGenesis()
	if err != nil {
		return fmt.Errorf("error while getting genesis: %s", err)
	}

	// Skip if the genesis does not exist
	if genesis == nil {
		return nil
	}

	// Check if the chain has been created at least a days ago
	if block.Timestamp.Sub(genesis.Time).Hours() < 24 {
		return nil
	}

	day, err := m.db.GetBlockHeightTimeDayAgo(block.Timestamp)
	if err != nil {
		return fmt.Errorf("error while getting block time a day ago: %s", err)
	}
	newBlockTime := block.Timestamp.Sub(day.Timestamp).Seconds() / float64(block.Height-day.Height)

	return m.db.SaveAverageBlockTimePerDay(newBlockTime, block.Height)
}

'''
'''--- modules/consensus/module.go ---
package consensus

import (
	"github.com/forbole/bdjuno/v5/database"

	"github.com/forbole/juno/v5/modules"
)

var (
	_ modules.Module                   = &Module{}
	_ modules.PeriodicOperationsModule = &Module{}
	_ modules.GenesisModule            = &Module{}
	_ modules.BlockModule              = &Module{}
)

// Module implements the consensus utils
type Module struct {
	db *database.Db
}

// NewModule builds a new Module instance
func NewModule(db *database.Db) *Module {
	return &Module{
		db: db,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "consensus"
}

'''
'''--- modules/daily_refetch/handle_periodic_operations.go ---
package daily_refetch

import (
	"fmt"
	"time"

	"github.com/forbole/juno/v5/parser"
	"github.com/forbole/juno/v5/types/config"

	"github.com/go-co-op/gocron"
	"github.com/rs/zerolog/log"

	parsecmdtypes "github.com/forbole/juno/v5/cmd/parse/types"
)

func (m *Module) RegisterPeriodicOperations(scheduler *gocron.Scheduler) error {
	log.Debug().Str("module", "daily refetch").Msg("setting up periodic tasks")

	// Setup a cron job to run every midnight
	if _, err := scheduler.Every(1).Day().At("00:00").Do(func() {
		m.refetchMissingBlocks()
	}); err != nil {
		return fmt.Errorf("error while setting up daily refetch periodic operation: %s", err)
	}

	return nil
}

// refetchMissingBlocks checks for missing blocks from one day ago and refetches them
func (m *Module) refetchMissingBlocks() error {
	log.Trace().Str("module", "daily refetch").Str("refetching", "blocks").
		Msg("refetching missing blocks")

	latestBlock, err := m.node.LatestHeight()
	if err != nil {
		return fmt.Errorf("error while getting latest block: %s", err)
	}

	blockHeightDayAgo, err := m.database.GetBlockHeightTimeDayAgo(time.Now())
	if err != nil {
		return fmt.Errorf("error while getting block height from a day ago: %s", err)
	}
	var startHeight = blockHeightDayAgo.Height

	missingBlocks := m.database.GetMissingBlocks(startHeight, latestBlock)

	// return if no blocks are missing
	if len(missingBlocks) == 0 {
		return nil
	}

	parseCtx, err := parsecmdtypes.GetParserContext(config.Cfg, parsecmdtypes.NewConfig())
	if err != nil {
		return err
	}

	workerCtx := parser.NewContext(parseCtx.EncodingConfig, parseCtx.Node, parseCtx.Database, parseCtx.Logger, parseCtx.Modules)
	worker := parser.NewWorker(workerCtx, nil, 0)

	log.Info().Int64("start height", startHeight).Int64("end height", latestBlock).
		Msg("getting missing blocks and transactions from a day ago")
	for _, block := range missingBlocks {
		err = worker.Process(block)
		if err != nil {
			return fmt.Errorf("error while re-fetching block %d: %s", block, err)
		}
	}

	return nil

}

'''
'''--- modules/daily_refetch/module.go ---
package daily_refetch

import (
	"github.com/forbole/juno/v5/node"

	bdjunodb "github.com/forbole/bdjuno/v5/database"

	"github.com/forbole/juno/v5/modules"
)

var (
	_ modules.Module                   = &Module{}
	_ modules.PeriodicOperationsModule = &Module{}
)

type Module struct {
	node     node.Node
	database *bdjunodb.Db
}

// NewModule builds a new Module instance
func NewModule(
	node node.Node,
	database *bdjunodb.Db,
) *Module {
	return &Module{
		node:     node,
		database: database,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "daily refetch"
}

'''
'''--- modules/distribution/handle_genesis.go ---
package distribution

import (
	"encoding/json"
	"fmt"

	tmtypes "github.com/cometbft/cometbft/types"

	"github.com/forbole/bdjuno/v5/types"

	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
	"github.com/rs/zerolog/log"
)

// HandleGenesis implements modules.Module
func (m *Module) HandleGenesis(doc *tmtypes.GenesisDoc, appState map[string]json.RawMessage) error {
	log.Debug().Str("module", "distribution").Msg("parsing genesis")

	// Read the genesis state
	var genState distrtypes.GenesisState
	err := m.cdc.UnmarshalJSON(appState[distrtypes.ModuleName], &genState)
	if err != nil {
		return fmt.Errorf("error while reading distribution genesis data: %s", err)
	}

	// Save the params
	err = m.db.SaveDistributionParams(types.NewDistributionParams(genState.Params, doc.InitialHeight))
	if err != nil {
		return fmt.Errorf("error while storing genesis distribution params: %s", err)
	}

	return nil
}

'''
'''--- modules/distribution/handle_msg.go ---
package distribution

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	juno "github.com/forbole/juno/v5/types"

	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
)

// HandleMsg implements modules.MessageModule
func (m *Module) HandleMsg(_ int, msg sdk.Msg, tx *juno.Tx) error {
	if len(tx.Logs) == 0 {
		return nil
	}

	if _, ok := msg.(*distrtypes.MsgFundCommunityPool); ok {
		return m.updateCommunityPool(tx.Height)
	}
	return nil
}

'''
'''--- modules/distribution/handle_periodic_operations.go ---
package distribution

import (
	"fmt"

	"github.com/go-co-op/gocron"
	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/modules/utils"
)

// RegisterPeriodicOperations implements modules.PeriodicOperationsModule
func (m *Module) RegisterPeriodicOperations(scheduler *gocron.Scheduler) error {
	log.Debug().Str("module", "distribution").Msg("setting up periodic tasks")

	// Update the community pool every 1 hour
	if _, err := scheduler.Every(1).Hour().Do(func() {
		utils.WatchMethod(m.GetLatestCommunityPool)
	}); err != nil {
		return fmt.Errorf("error while scheduling distribution peridic operation: %s", err)
	}

	return nil
}

// GetLatestCommunityPool gets the latest community pool from the chain and stores inside the database
func (m *Module) GetLatestCommunityPool() error {
	height, err := m.db.GetLastBlockHeight()
	if err != nil {
		return fmt.Errorf("error while getting latest block height: %s", err)
	}

	return m.updateCommunityPool(height)
}

'''
'''--- modules/distribution/module.go ---
package distribution

import (
	"github.com/cosmos/cosmos-sdk/codec"

	distrsource "github.com/forbole/bdjuno/v5/modules/distribution/source"

	"github.com/forbole/juno/v5/modules"

	"github.com/forbole/bdjuno/v5/database"
)

var (
	_ modules.Module                   = &Module{}
	_ modules.GenesisModule            = &Module{}
	_ modules.PeriodicOperationsModule = &Module{}
	_ modules.MessageModule            = &Module{}
)

// Module represents the x/distr module
type Module struct {
	cdc    codec.Codec
	db     *database.Db
	source distrsource.Source
}

// NewModule returns a new Module instance
func NewModule(source distrsource.Source, cdc codec.Codec, db *database.Db) *Module {
	return &Module{
		cdc:    cdc,
		db:     db,
		source: source,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "distribution"
}

'''
'''--- modules/distribution/source/local/source.go ---
package local

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
	"github.com/forbole/juno/v5/node/local"

	distrsource "github.com/forbole/bdjuno/v5/modules/distribution/source"
)

var (
	_ distrsource.Source = &Source{}
)

// Source implements distrsource.Source reading the data from a local node
type Source struct {
	*local.Source
	q distrtypes.QueryServer
}

func NewSource(source *local.Source, keeper distrtypes.QueryServer) *Source {
	return &Source{
		Source: source,
		q:      keeper,
	}
}

// ValidatorCommission implements distrsource.Source
func (s Source) ValidatorCommission(valOperAddr string, height int64) (sdk.DecCoins, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.ValidatorCommission(
		sdk.WrapSDKContext(ctx),
		&distrtypes.QueryValidatorCommissionRequest{ValidatorAddress: valOperAddr},
	)
	if err != nil {
		return nil, err
	}

	return res.Commission.Commission, nil
}

// DelegatorTotalRewards implements distrsource.Source
func (s Source) DelegatorTotalRewards(delegator string, height int64) ([]distrtypes.DelegationDelegatorReward, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.DelegationTotalRewards(
		sdk.WrapSDKContext(ctx),
		&distrtypes.QueryDelegationTotalRewardsRequest{DelegatorAddress: delegator},
	)
	if err != nil {
		return nil, err
	}

	return res.Rewards, nil
}

// DelegatorWithdrawAddress implements distrsource.Source
func (s Source) DelegatorWithdrawAddress(delegator string, height int64) (string, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return "", fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.DelegatorWithdrawAddress(
		sdk.WrapSDKContext(ctx),
		&distrtypes.QueryDelegatorWithdrawAddressRequest{DelegatorAddress: delegator},
	)
	if err != nil {
		return "", err
	}

	return res.WithdrawAddress, nil
}

// CommunityPool implements distrsource.Source
func (s Source) CommunityPool(height int64) (sdk.DecCoins, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.CommunityPool(sdk.WrapSDKContext(ctx), &distrtypes.QueryCommunityPoolRequest{})
	if err != nil {
		return nil, err
	}

	return res.Pool, nil
}

// Params implements distrsource.Source
func (s Source) Params(height int64) (distrtypes.Params, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return distrtypes.Params{}, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.Params(sdk.WrapSDKContext(ctx), &distrtypes.QueryParamsRequest{})
	if err != nil {
		return distrtypes.Params{}, err
	}

	return res.Params, nil
}

'''
'''--- modules/distribution/source/remote/source.go ---
package remote

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
	"github.com/forbole/juno/v5/node/remote"

	distrsource "github.com/forbole/bdjuno/v5/modules/distribution/source"
)

var (
	_ distrsource.Source = &Source{}
)

// Source implements distrsource.Source querying the data from a remote node
type Source struct {
	*remote.Source
	distrClient distrtypes.QueryClient
}

// NewSource returns a new Source instace
func NewSource(source *remote.Source, distrClient distrtypes.QueryClient) *Source {
	return &Source{
		Source:      source,
		distrClient: distrClient,
	}
}

// CommunityPool implements distrsource.Source
func (s Source) CommunityPool(height int64) (sdk.DecCoins, error) {
	res, err := s.distrClient.CommunityPool(
		remote.GetHeightRequestContext(s.Ctx, height),
		&distrtypes.QueryCommunityPoolRequest{},
	)
	if err != nil {
		return nil, err
	}

	return res.Pool, nil
}

// Params implements distrsource.Source
func (s Source) Params(height int64) (distrtypes.Params, error) {
	res, err := s.distrClient.Params(
		remote.GetHeightRequestContext(s.Ctx, height),
		&distrtypes.QueryParamsRequest{},
	)
	if err != nil {
		return distrtypes.Params{}, err
	}

	return res.Params, nil
}

'''
'''--- modules/distribution/source/remote/source_actions.go ---
package remote

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
	"github.com/forbole/juno/v5/node/remote"

	"github.com/forbole/bdjuno/v5/utils"
)

// DelegatorTotalRewards implements distrsource.Source
func (s Source) DelegatorTotalRewards(delegator string, height int64) ([]distrtypes.DelegationDelegatorReward, error) {
	ctx := utils.GetHeightRequestContext(s.Ctx, height)
	res, err := s.distrClient.DelegationTotalRewards(
		ctx,
		&distrtypes.QueryDelegationTotalRewardsRequest{DelegatorAddress: delegator},
	)
	if err != nil {
		return nil, fmt.Errorf("error while getting delegation total rewards for for delegator %s at height %v: %s", delegator, height, err)
	}

	return res.Rewards, nil
}

// DelegatorWithdrawAddress implements distrsource.Source
func (s Source) DelegatorWithdrawAddress(delegator string, height int64) (string, error) {
	res, err := s.distrClient.DelegatorWithdrawAddress(
		remote.GetHeightRequestContext(s.Ctx, height),
		&distrtypes.QueryDelegatorWithdrawAddressRequest{DelegatorAddress: delegator},
	)
	if err != nil {
		return "", err
	}

	return res.WithdrawAddress, nil
}

// ValidatorCommission implements distrsource.Source
func (s Source) ValidatorCommission(valOperAddr string, height int64) (sdk.DecCoins, error) {
	res, err := s.distrClient.ValidatorCommission(
		remote.GetHeightRequestContext(s.Ctx, height),
		&distrtypes.QueryValidatorCommissionRequest{ValidatorAddress: valOperAddr},
	)
	if err != nil {
		return nil, err
	}

	return res.Commission.Commission, nil
}

'''
'''--- modules/distribution/source/source.go ---
package source

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
)

type Source interface {
	ValidatorCommission(valOperAddr string, height int64) (sdk.DecCoins, error)
	DelegatorTotalRewards(delegator string, height int64) ([]distrtypes.DelegationDelegatorReward, error)
	DelegatorWithdrawAddress(delegator string, height int64) (string, error)
	CommunityPool(height int64) (sdk.DecCoins, error)
	Params(height int64) (distrtypes.Params, error)
}

'''
'''--- modules/distribution/utils_community_pool.go ---
package distribution

import (
	"fmt"

	"github.com/rs/zerolog/log"
)

// updateCommunityPool fetch total amount of coins in the system from RPC and store it into database
func (m *Module) updateCommunityPool(height int64) error {
	log.Debug().Str("module", "distribution").Int64("height", height).Msg("getting community pool")

	pool, err := m.source.CommunityPool(height)
	if err != nil {
		return fmt.Errorf("error while getting comminity pool: %s", err)
	}

	// Store the pool into the database
	return m.db.SaveCommunityPool(pool, height)
}

'''
'''--- modules/distribution/utils_params.go ---
package distribution

import (
	"fmt"

	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/types"
)

// UpdateParams gets the updated params and stores them inside the database
func (m *Module) UpdateParams(height int64) error {
	log.Debug().Str("module", "distribution").Int64("height", height).
		Msg("updating params")

	params, err := m.source.Params(height)
	if err != nil {
		return fmt.Errorf("error while getting params: %s", err)
	}

	return m.db.SaveDistributionParams(types.NewDistributionParams(params, height))

}

'''
'''--- modules/feegrant/handle_block.go ---
package feegrant

import (
	"fmt"

	abci "github.com/cometbft/cometbft/abci/types"

	feegranttypes "github.com/cosmos/cosmos-sdk/x/feegrant"
	juno "github.com/forbole/juno/v5/types"

	tmctypes "github.com/cometbft/cometbft/rpc/core/types"
	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/types"
)

// HandleBlock implements BlockModule
func (m *Module) HandleBlock(
	block *tmctypes.ResultBlock, res *tmctypes.ResultBlockResults, _ []*juno.Tx, _ *tmctypes.ResultValidators,
) error {

	// Remove expired fee grant allowances
	err := m.removeExpiredFeeGrantAllowances(block.Block.Height, res.EndBlockEvents)
	if err != nil {
		fmt.Printf("Error when removing expired fee grant allowance, error: %s", err)
	}
	return nil
}

// removeExpiredFeeGrantAllowances removes fee grant allowances in database that have expired
func (m *Module) removeExpiredFeeGrantAllowances(height int64, events []abci.Event) error {
	log.Debug().Str("module", "feegrant").Int64("height", height).
		Msg("updating expired fee grant allowances")

	events = juno.FindEventsByType(events, feegranttypes.EventTypeRevokeFeeGrant)

	for _, event := range events {
		granterAddress, err := juno.FindAttributeByKey(event, feegranttypes.AttributeKeyGranter)
		if err != nil {
			return fmt.Errorf("error while getting fee grant granter address: %s", err)
		}
		granteeAddress, err := juno.FindAttributeByKey(event, feegranttypes.AttributeKeyGrantee)
		if err != nil {
			return fmt.Errorf("error while getting fee grant grantee address: %s", err)
		}
		err = m.db.DeleteFeeGrantAllowance(types.NewGrantRemoval(granteeAddress.Value, granterAddress.Value, height))
		if err != nil {
			return fmt.Errorf("error while deleting fee grant allowance: %s", err)

		}
	}
	return nil

}

'''
'''--- modules/feegrant/handle_msg.go ---
package feegrant

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	feegranttypes "github.com/cosmos/cosmos-sdk/x/feegrant"
	juno "github.com/forbole/juno/v5/types"

	"github.com/forbole/bdjuno/v5/types"
)

// HandleMsg implements modules.MessageModule
func (m *Module) HandleMsg(_ int, msg sdk.Msg, tx *juno.Tx) error {
	if len(tx.Logs) == 0 {
		return nil
	}

	switch cosmosMsg := msg.(type) {
	case *feegranttypes.MsgGrantAllowance:
		return m.HandleMsgGrantAllowance(tx, cosmosMsg)
	case *feegranttypes.MsgRevokeAllowance:
		return m.HandleMsgRevokeAllowance(tx, cosmosMsg)
	}

	return nil
}

// HandleMsgGrantAllowance allows to properly handle a MsgGrantAllowance
func (m *Module) HandleMsgGrantAllowance(tx *juno.Tx, msg *feegranttypes.MsgGrantAllowance) error {
	allowance, err := msg.GetFeeAllowanceI()
	if err != nil {
		return fmt.Errorf("error while getting fee allowance: %s", err)
	}
	granter, err := sdk.AccAddressFromBech32(msg.Granter)
	if err != nil {
		return fmt.Errorf("error while parsing granter address: %s", err)
	}
	grantee, err := sdk.AccAddressFromBech32(msg.Grantee)
	if err != nil {
		return fmt.Errorf("error while parsing grantee address: %s", err)
	}
	feeGrant, err := feegranttypes.NewGrant(granter, grantee, allowance)
	if err != nil {
		return fmt.Errorf("error while getting new grant allowance: %s", err)
	}
	return m.db.SaveFeeGrantAllowance(types.NewFeeGrant(feeGrant, tx.Height))
}

// HandleMsgRevokeAllowance allows to properly handle a MsgRevokeAllowance
func (m *Module) HandleMsgRevokeAllowance(tx *juno.Tx, msg *feegranttypes.MsgRevokeAllowance) error {
	return m.db.DeleteFeeGrantAllowance(types.NewGrantRemoval(msg.Grantee, msg.Granter, tx.Height))
}

'''
'''--- modules/feegrant/module.go ---
package feegrant

import (
	"github.com/cosmos/cosmos-sdk/codec"

	"github.com/forbole/bdjuno/v5/database"

	"github.com/forbole/juno/v5/modules"
)

var (
	_ modules.BlockModule   = &Module{}
	_ modules.Module        = &Module{}
	_ modules.MessageModule = &Module{}
)

// Module represent x/feegrant module
type Module struct {
	cdc codec.Codec
	db  *database.Db
}

// NewModule returns a new Module instance
func NewModule(cdc codec.Codec, db *database.Db) *Module {
	return &Module{
		cdc: cdc,
		db:  db,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "feegrant"
}

'''
'''--- modules/gov/expected_modules.go ---
package gov

import (
	tmctypes "github.com/cometbft/cometbft/rpc/core/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"

	"github.com/forbole/bdjuno/v5/types"
)

type AuthModule interface {
	RefreshAccounts(height int64, addresses []string) error
}

type DistrModule interface {
	UpdateParams(height int64) error
}

type MintModule interface {
	UpdateParams(height int64) error
	UpdateInflation() error
}

type SlashingModule interface {
	UpdateParams(height int64) error
}

type StakingModule interface {
	GetStakingPool(height int64) (*types.Pool, error)
	GetStakingPoolSnapshot(height int64) (*types.PoolSnapshot, error)
	GetValidatorsWithStatus(height int64, status string) ([]stakingtypes.Validator, []types.Validator, error)
	GetValidatorsVotingPowers(height int64, vals *tmctypes.ResultValidators) ([]types.ValidatorVotingPower, error)
	GetValidatorsStatuses(height int64, validators []stakingtypes.Validator) ([]types.ValidatorStatus, error)
	UpdateParams(height int64) error
}

'''
'''--- modules/gov/handle_block.go ---
package gov

import (
	"fmt"
	"time"

	juno "github.com/forbole/juno/v5/types"

	tmctypes "github.com/cometbft/cometbft/rpc/core/types"

	"github.com/rs/zerolog/log"
)

// HandleBlock implements modules.BlockModule
func (m *Module) HandleBlock(
	b *tmctypes.ResultBlock, _ *tmctypes.ResultBlockResults, _ []*juno.Tx, vals *tmctypes.ResultValidators,
) error {
	err := m.updateProposals(b.Block.Height, b.Block.Time, vals)
	if err != nil {
		log.Error().Str("module", "gov").Int64("height", b.Block.Height).
			Err(err).Msg("error while updating proposals")
	}
	return nil
}

// updateProposals updates the proposals
func (m *Module) updateProposals(height int64, blockTime time.Time, blockVals *tmctypes.ResultValidators) error {
	ids, err := m.db.GetOpenProposalsIds(blockTime)
	if err != nil {
		log.Error().Err(err).Str("module", "gov").Msg("error while getting open ids")
	}

	for _, id := range ids {
		err = m.UpdateProposal(height, blockTime, id)
		if err != nil {
			return fmt.Errorf("error while updating proposal: %s", err)
		}

		err = m.UpdateProposalValidatorStatusesSnapshot(height, blockVals, id)
		if err != nil {
			return fmt.Errorf("error while updating proposal validator statuses snapshots: %s", err)
		}

		err = m.UpdateProposalStakingPoolSnapshot(height, blockVals, id)
		if err != nil {
			return fmt.Errorf("error while updating proposal validator statuses snapshots: %s", err)
		}
	}
	return nil
}

'''
'''--- modules/gov/handle_genesis.go ---
package gov

import (
	"encoding/json"
	"fmt"

	tmtypes "github.com/cometbft/cometbft/types"

	"github.com/forbole/bdjuno/v5/types"

	gov "github.com/cosmos/cosmos-sdk/x/gov/types"
	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"
	"github.com/rs/zerolog/log"
)

// HandleGenesis implements modules.Module
func (m *Module) HandleGenesis(doc *tmtypes.GenesisDoc, appState map[string]json.RawMessage) error {
	log.Debug().Str("module", "gov").Msg("parsing genesis")

	// Read the genesis state
	var genStatev1beta1 govtypesv1beta1.GenesisState
	err := m.cdc.UnmarshalJSON(appState[gov.ModuleName], &genStatev1beta1)
	if err != nil {
		return fmt.Errorf("error while reading gov genesis data: %s", err)
	}

	// Save the proposals
	err = m.saveGenesisProposals(genStatev1beta1.Proposals, doc)
	if err != nil {
		return fmt.Errorf("error while storing genesis governance proposals: %s", err)
	}

	// Save the params
	err = m.db.SaveGenesisGovParams(types.NewGenesisGovParams(
		types.NewGenesisVotingParams(&genStatev1beta1.VotingParams),
		types.NewGenesisDepositParam(&genStatev1beta1.DepositParams),
		types.NewGenesisTallyParams(&genStatev1beta1.TallyParams),
		doc.InitialHeight,
	))
	if err != nil {
		return fmt.Errorf("error while storing genesis governance params: %s", err)
	}

	return nil
}

// saveGenesisProposals save proposals from genesis file
func (m *Module) saveGenesisProposals(slice govtypesv1beta1.Proposals, genDoc *tmtypes.GenesisDoc) error {
	proposals := make([]types.Proposal, len(slice))
	tallyResults := make([]types.TallyResult, len(slice))
	deposits := make([]types.Deposit, len(slice))

	for index, proposal := range slice {
		// Since it's not possible to get the proposer, set it to nil
		proposals[index] = types.NewProposal(
			proposal.ProposalId,
			proposal.ProposalRoute(),
			proposal.ProposalType(),
			proposal.GetContent(),
			proposal.Status.String(),
			proposal.SubmitTime,
			proposal.DepositEndTime,
			proposal.VotingStartTime,
			proposal.VotingEndTime,
			"",
		)

		tallyResults[index] = types.NewTallyResult(
			proposal.ProposalId,
			proposal.FinalTallyResult.Yes.String(),
			proposal.FinalTallyResult.Abstain.String(),
			proposal.FinalTallyResult.No.String(),
			proposal.FinalTallyResult.NoWithVeto.String(),
			genDoc.InitialHeight,
		)

		deposits[index] = types.NewDeposit(
			proposal.ProposalId,
			"",
			proposal.TotalDeposit,
			genDoc.GenesisTime,
			genDoc.InitialHeight,
		)
	}

	// Save the proposals
	err := m.db.SaveProposals(proposals)
	if err != nil {
		return err
	}

	// Save the deposits
	err = m.db.SaveDeposits(deposits)
	if err != nil {
		return err
	}

	// Save the tally results
	return m.db.SaveTallyResults(tallyResults)
}

'''
'''--- modules/gov/handle_msg.go ---
package gov

import (
	"fmt"
	"time"

	"strconv"

	"github.com/forbole/bdjuno/v5/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	govtypesv1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1"

	gov "github.com/cosmos/cosmos-sdk/x/gov/types"
	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"
	juno "github.com/forbole/juno/v5/types"
)

// HandleMsg implements modules.MessageModule
func (m *Module) HandleMsg(index int, msg sdk.Msg, tx *juno.Tx) error {
	if len(tx.Logs) == 0 {
		return nil
	}

	switch cosmosMsg := msg.(type) {
	case *govtypesv1beta1.MsgSubmitProposal:
		return m.handleMsgSubmitProposal(tx, index, cosmosMsg)

	case *govtypesv1.MsgDeposit:
		return m.handleMsgDeposit(tx, cosmosMsg)

	case *govtypesv1.MsgVote:
		return m.handleMsgVote(tx, cosmosMsg)
	}

	return nil
}

// handleMsgSubmitProposal allows to properly handle a handleMsgSubmitProposal
func (m *Module) handleMsgSubmitProposal(tx *juno.Tx, index int, msg *govtypesv1beta1.MsgSubmitProposal) error {
	// Get the proposal id
	event, err := tx.FindEventByType(index, gov.EventTypeSubmitProposal)
	if err != nil {
		return fmt.Errorf("error while searching for EventTypeSubmitProposal: %s", err)
	}

	id, err := tx.FindAttributeByKey(event, gov.AttributeKeyProposalID)
	if err != nil {
		return fmt.Errorf("error while searching for AttributeKeyProposalID: %s", err)
	}

	proposalID, err := strconv.ParseUint(id, 10, 64)
	if err != nil {
		return fmt.Errorf("error while parsing proposal id: %s", err)
	}

	// Get the proposal
	proposal, err := m.source.Proposal(tx.Height, proposalID)
	if err != nil {
		return fmt.Errorf("error while getting proposal: %s", err)
	}

	// Store the proposal
	proposalObj := types.NewProposal(
		proposal.ProposalId,
		msg.GetContent().ProposalRoute(),
		msg.GetContent().ProposalType(),
		msg.GetContent(),
		proposal.Status.String(),
		proposal.SubmitTime,
		proposal.DepositEndTime,
		proposal.VotingStartTime,
		proposal.VotingEndTime,
		msg.Proposer,
	)

	err = m.db.SaveProposals([]types.Proposal{proposalObj})
	if err != nil {
		return err
	}

	txTimestamp, err := time.Parse(time.RFC3339, tx.Timestamp)
	if err != nil {
		return fmt.Errorf("error while parsing time: %s", err)
	}

	// Store the deposit
	deposit := types.NewDeposit(proposal.ProposalId, msg.Proposer, msg.InitialDeposit, txTimestamp, tx.Height)
	return m.db.SaveDeposits([]types.Deposit{deposit})
}

// handleMsgDeposit allows to properly handle a handleMsgDeposit
func (m *Module) handleMsgDeposit(tx *juno.Tx, msg *govtypesv1.MsgDeposit) error {
	deposit, err := m.source.ProposalDeposit(tx.Height, msg.ProposalId, msg.Depositor)
	if err != nil {
		return fmt.Errorf("error while getting proposal deposit: %s", err)
	}
	txTimestamp, err := time.Parse(time.RFC3339, tx.Timestamp)
	if err != nil {
		return fmt.Errorf("error while parsing time: %s", err)
	}

	return m.db.SaveDeposits([]types.Deposit{
		types.NewDeposit(msg.ProposalId, msg.Depositor, deposit.Amount, txTimestamp, tx.Height),
	})
}

// handleMsgVote allows to properly handle a handleMsgVote
func (m *Module) handleMsgVote(tx *juno.Tx, msg *govtypesv1.MsgVote) error {
	txTimestamp, err := time.Parse(time.RFC3339, tx.Timestamp)
	if err != nil {
		return fmt.Errorf("error while parsing time: %s", err)
	}

	vote := types.NewVote(msg.ProposalId, msg.Voter, msg.Option, txTimestamp, tx.Height)

	return m.db.SaveVote(vote)
}

'''
'''--- modules/gov/module.go ---
package gov

import (
	"github.com/cosmos/cosmos-sdk/codec"

	"github.com/forbole/bdjuno/v5/database"

	govsource "github.com/forbole/bdjuno/v5/modules/gov/source"

	"github.com/forbole/juno/v5/modules"
)

var (
	_ modules.Module        = &Module{}
	_ modules.GenesisModule = &Module{}
	_ modules.BlockModule   = &Module{}
	_ modules.MessageModule = &Module{}
)

// Module represent x/gov module
type Module struct {
	cdc            codec.Codec
	db             *database.Db
	source         govsource.Source
	authModule     AuthModule
	distrModule    DistrModule
	mintModule     MintModule
	slashingModule SlashingModule
	stakingModule  StakingModule
}

// NewModule returns a new Module instance
func NewModule(
	source govsource.Source,
	authModule AuthModule,
	distrModule DistrModule,
	mintModule MintModule,
	slashingModule SlashingModule,
	stakingModule StakingModule,
	cdc codec.Codec,
	db *database.Db,
) *Module {
	return &Module{
		cdc:            cdc,
		source:         source,
		authModule:     authModule,
		distrModule:    distrModule,
		mintModule:     mintModule,
		slashingModule: slashingModule,
		stakingModule:  stakingModule,
		db:             db,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "gov"
}

'''
'''--- modules/gov/source/local/source.go ---
package local

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	govtypesv1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1"
	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"

	"github.com/forbole/juno/v5/node/local"

	govsource "github.com/forbole/bdjuno/v5/modules/gov/source"
)

var (
	_ govsource.Source = &Source{}
)

// Source implements govsource.Source by using a local node
type Source struct {
	*local.Source
	q        govtypesv1.QueryServer
	qv1beta1 govtypesv1beta1.QueryClient
}

// NewSource returns a new Source instance
func NewSource(source *local.Source, govKeeper govtypesv1.QueryServer, govKeeperv1beta1 govtypesv1beta1.QueryClient) *Source {
	return &Source{
		Source:   source,
		q:        govKeeper,
		qv1beta1: govKeeperv1beta1,
	}
}

// Proposal implements govsource.Source
func (s Source) Proposal(height int64, id uint64) (govtypesv1beta1.Proposal, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return govtypesv1beta1.Proposal{}, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.qv1beta1.Proposal(sdk.WrapSDKContext(ctx), &govtypesv1beta1.QueryProposalRequest{ProposalId: id})
	if err != nil {
		return govtypesv1beta1.Proposal{}, err
	}

	return res.Proposal, nil
}

// ProposalDeposit implements govsource.Source
func (s Source) ProposalDeposit(height int64, id uint64, depositor string) (*govtypesv1.Deposit, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.Deposit(sdk.WrapSDKContext(ctx), &govtypesv1.QueryDepositRequest{ProposalId: id, Depositor: depositor})
	if err != nil {
		return nil, err
	}

	return res.Deposit, nil
}

// TallyResult implements govsource.Source
func (s Source) TallyResult(height int64, proposalID uint64) (*govtypesv1.TallyResult, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.TallyResult(sdk.WrapSDKContext(ctx), &govtypesv1.QueryTallyResultRequest{ProposalId: proposalID})
	if err != nil {
		return nil, err
	}

	return res.Tally, nil
}

// DepositParams implements govsource.Source
func (s Source) DepositParams(height int64) (*govtypesv1.DepositParams, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.Params(sdk.WrapSDKContext(ctx), &govtypesv1.QueryParamsRequest{ParamsType: govtypesv1.ParamDeposit})
	if err != nil {
		return nil, err
	}

	return res.DepositParams, nil
}

// VotingParams implements govsource.Source
func (s Source) VotingParams(height int64) (*govtypesv1.VotingParams, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.Params(sdk.WrapSDKContext(ctx), &govtypesv1.QueryParamsRequest{ParamsType: govtypesv1.ParamVoting})
	if err != nil {
		return nil, err
	}

	return res.VotingParams, nil
}

// TallyParams implements govsource.Source
func (s Source) TallyParams(height int64) (*govtypesv1.TallyParams, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.Params(sdk.WrapSDKContext(ctx), &govtypesv1.QueryParamsRequest{ParamsType: govtypesv1.ParamTallying})
	if err != nil {
		return nil, err
	}

	return res.TallyParams, nil
}

'''
'''--- modules/gov/source/remote/source.go ---
package remote

import (
	govtypesv1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1"
	"github.com/forbole/juno/v5/node/remote"

	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"
	govsource "github.com/forbole/bdjuno/v5/modules/gov/source"
)

var (
	_ govsource.Source = &Source{}
)

// Source implements govsource.Source using a remote node
type Source struct {
	*remote.Source
	govClient        govtypesv1.QueryClient
	govClientv1beta1 govtypesv1beta1.QueryClient
}

// NewSource returns a new Source implementation
func NewSource(source *remote.Source, govClient govtypesv1.QueryClient, govClientv1beta1 govtypesv1beta1.QueryClient) *Source {
	return &Source{
		Source:           source,
		govClient:        govClient,
		govClientv1beta1: govClientv1beta1,
	}
}

// Proposal implements govsource.Source
func (s Source) Proposal(height int64, id uint64) (govtypesv1beta1.Proposal, error) {
	res, err := s.govClientv1beta1.Proposal(
		remote.GetHeightRequestContext(s.Ctx, height),
		&govtypesv1beta1.QueryProposalRequest{ProposalId: id},
	)
	if err != nil {
		return govtypesv1beta1.Proposal{}, err
	}

	return res.Proposal, err
}

// ProposalDeposit implements govsource.Source
func (s Source) ProposalDeposit(height int64, id uint64, depositor string) (*govtypesv1.Deposit, error) {
	res, err := s.govClient.Deposit(
		remote.GetHeightRequestContext(s.Ctx, height),
		&govtypesv1.QueryDepositRequest{ProposalId: id, Depositor: depositor},
	)
	if err != nil {
		return nil, err
	}

	return res.Deposit, nil
}

// TallyResult implements govsource.Source
func (s Source) TallyResult(height int64, proposalID uint64) (*govtypesv1.TallyResult, error) {
	res, err := s.govClient.TallyResult(
		remote.GetHeightRequestContext(s.Ctx, height),
		&govtypesv1.QueryTallyResultRequest{ProposalId: proposalID},
	)
	if err != nil {
		return nil, err
	}

	return res.Tally, nil
}

// DepositParams implements govsource.Source
func (s Source) DepositParams(height int64) (*govtypesv1.DepositParams, error) {
	res, err := s.govClient.Params(
		remote.GetHeightRequestContext(s.Ctx, height),
		&govtypesv1.QueryParamsRequest{ParamsType: govtypesv1.ParamDeposit},
	)
	if err != nil {
		return nil, err
	}

	return res.DepositParams, nil
}

// VotingParams implements govsource.Source
func (s Source) VotingParams(height int64) (*govtypesv1.VotingParams, error) {
	res, err := s.govClient.Params(
		remote.GetHeightRequestContext(s.Ctx, height),
		&govtypesv1.QueryParamsRequest{ParamsType: govtypesv1.ParamVoting},
	)
	if err != nil {
		return nil, err
	}

	return res.VotingParams, nil
}

// TallyParams implements govsource.Source
func (s Source) TallyParams(height int64) (*govtypesv1.TallyParams, error) {
	res, err := s.govClient.Params(
		remote.GetHeightRequestContext(s.Ctx, height),
		&govtypesv1.QueryParamsRequest{ParamsType: govtypesv1.ParamTallying},
	)
	if err != nil {
		return nil, err
	}

	return res.TallyParams, nil
}

'''
'''--- modules/gov/source/source.go ---
package source

import (
	govtypesv1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1"
	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"
)

type Source interface {
	Proposal(height int64, id uint64) (govtypesv1beta1.Proposal, error)
	ProposalDeposit(height int64, id uint64, depositor string) (*govtypesv1.Deposit, error)
	TallyResult(height int64, proposalID uint64) (*govtypesv1.TallyResult, error)
	DepositParams(height int64) (*govtypesv1.DepositParams, error)
	VotingParams(height int64) (*govtypesv1.VotingParams, error)
	TallyParams(height int64) (*govtypesv1.TallyParams, error)
}

'''
'''--- modules/gov/utils_params.go ---
package gov

import (
	"fmt"

	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/types"
)

// UpdateParams updates the governance parameters for the given height
func (m *Module) UpdateParams(height int64) error {
	log.Debug().Str("module", "gov").Int64("height", height).
		Msg("updating params")

	depositParams, err := m.source.DepositParams(height)
	if err != nil {
		return fmt.Errorf("error while getting gov deposit params: %s", err)
	}

	votingParams, err := m.source.VotingParams(height)
	if err != nil {
		return fmt.Errorf("error while getting gov voting params: %s", err)
	}

	tallyParams, err := m.source.TallyParams(height)
	if err != nil {
		return fmt.Errorf("error while getting gov tally params: %s", err)
	}

	return m.db.SaveGovParams(types.NewGovParams(
		types.NewVotingParams(votingParams),
		types.NewDepositParam(depositParams),
		types.NewTallyParams(tallyParams),
		height,
	))
}

'''
'''--- modules/gov/utils_proposal.go ---
package gov

import (
	"fmt"
	"strings"
	"time"

	codec "github.com/cosmos/cosmos-sdk/codec"
	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
	proposaltypes "github.com/cosmos/cosmos-sdk/x/params/types/proposal"
	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	upgradetypes "github.com/cosmos/cosmos-sdk/x/upgrade/types"
	"google.golang.org/grpc/codes"

	tmctypes "github.com/cometbft/cometbft/rpc/core/types"

	"github.com/forbole/bdjuno/v5/types"

	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"

	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"

	gov "github.com/cosmos/cosmos-sdk/x/gov/types"
)

func (m *Module) UpdateProposal(height int64, blockTime time.Time, id uint64) error {
	// Get the proposal
	proposal, err := m.source.Proposal(height, id)
	if err != nil {
		// Check if proposal exist on the chain
		if strings.Contains(err.Error(), codes.NotFound.String()) && strings.Contains(err.Error(), "doesn't exist") {
			// Handle case when a proposal is deleted from the chain (did not pass deposit period)
			return m.updateDeletedProposalStatus(id)
		}

		return fmt.Errorf("error while getting proposal: %s", err)
	}

	err = m.updateProposalStatus(proposal)
	if err != nil {
		return fmt.Errorf("error while updating proposal status: %s", err)
	}

	err = m.updateProposalTallyResult(proposal)
	if err != nil {
		return fmt.Errorf("error while updating proposal tally result: %s", err)
	}

	err = m.updateAccounts(proposal)
	if err != nil {
		return fmt.Errorf("error while updating account: %s", err)
	}

	err = m.handlePassedProposal(proposal, height)
	if err != nil {
		return fmt.Errorf("error while handling passed proposals: %s", err)
	}

	return nil
}

func (m *Module) UpdateProposalValidatorStatusesSnapshot(height int64, blockVals *tmctypes.ResultValidators, id uint64) error {
	err := m.updateProposalValidatorStatusesSnapshot(height, id, blockVals)
	if err != nil {
		return fmt.Errorf("error while updating proposal validator statuses snapshot: %s", err)
	}

	return nil
}

func (m *Module) UpdateProposalStakingPoolSnapshot(height int64, blockVals *tmctypes.ResultValidators, id uint64) error {
	err := m.updateProposalStakingPoolSnapshot(height, id)
	if err != nil {
		return fmt.Errorf("error while updating proposal staking pool snapshot: %s", err)
	}

	return nil
}

// updateDeletedProposalStatus updates the proposal having the given id by setting its status
// to the one that represents a deleted proposal
func (m *Module) updateDeletedProposalStatus(id uint64) error {
	stored, err := m.db.GetProposal(id)
	if err != nil {
		return err
	}

	return m.db.UpdateProposal(
		types.NewProposalUpdate(
			stored.ProposalID,
			types.ProposalStatusInvalid,
			stored.VotingStartTime,
			stored.VotingEndTime,
		),
	)
}

// handleParamChangeProposal updates params to the corresponding modules if a ParamChangeProposal has passed
func (m *Module) handleParamChangeProposal(height int64, paramChangeProposal *proposaltypes.ParameterChangeProposal) (err error) {
	for _, change := range paramChangeProposal.Changes {
		// Update the params for corresponding modules
		switch change.Subspace {
		case distrtypes.ModuleName:
			err = m.distrModule.UpdateParams(height)
			if err != nil {
				return fmt.Errorf("error while updating ParamChangeProposal %s params : %s", distrtypes.ModuleName, err)
			}
		case gov.ModuleName:
			err = m.UpdateParams(height)
			if err != nil {
				return fmt.Errorf("error while updating ParamChangeProposal %s params : %s", gov.ModuleName, err)
			}
		case minttypes.ModuleName:
			err = m.mintModule.UpdateParams(height)
			if err != nil {
				return fmt.Errorf("error while updating ParamChangeProposal %s params : %s", minttypes.ModuleName, err)
			}

			// Update the inflation
			err = m.mintModule.UpdateInflation()
			if err != nil {
				return fmt.Errorf("error while updating inflation with ParamChangeProposal: %s", err)
			}
		case slashingtypes.ModuleName:
			err = m.slashingModule.UpdateParams(height)
			if err != nil {
				return fmt.Errorf("error while updating ParamChangeProposal %s params : %s", slashingtypes.ModuleName, err)
			}
		case stakingtypes.ModuleName:
			err = m.stakingModule.UpdateParams(height)
			if err != nil {
				return fmt.Errorf("error while updating ParamChangeProposal %s params : %s", stakingtypes.ModuleName, err)
			}
		}
	}
	return nil
}

// updateProposalStatus updates the given proposal status
func (m *Module) updateProposalStatus(proposal govtypesv1beta1.Proposal) error {
	return m.db.UpdateProposal(
		types.NewProposalUpdate(
			proposal.ProposalId,
			proposal.Status.String(),
			proposal.VotingStartTime,
			proposal.VotingEndTime,
		),
	)
}

// updateProposalTallyResult updates the tally result associated with the given proposal
func (m *Module) updateProposalTallyResult(proposal govtypesv1beta1.Proposal) error {
	height, err := m.db.GetLastBlockHeight()
	if err != nil {
		return err
	}

	result, err := m.source.TallyResult(height, proposal.ProposalId)
	if err != nil {
		return fmt.Errorf("error while getting tally result: %s", err)
	}

	return m.db.SaveTallyResults([]types.TallyResult{
		types.NewTallyResult(
			proposal.ProposalId,
			result.YesCount,
			result.AbstainCount,
			result.NoCount,
			result.NoWithVetoCount,
			height,
		),
	})
}

// updateAccounts updates any account that might be involved in the proposal (eg. fund community recipient)
func (m *Module) updateAccounts(proposal govtypesv1beta1.Proposal) error {
	content, ok := proposal.Content.GetCachedValue().(*distrtypes.CommunityPoolSpendProposal)
	if ok {
		height, err := m.db.GetLastBlockHeight()
		if err != nil {
			return fmt.Errorf("error while getting last block height: %s", err)
		}

		addresses := []string{content.Recipient}

		err = m.authModule.RefreshAccounts(height, addresses)
		if err != nil {
			return err
		}

		return nil
	}
	return nil
}

// updateProposalStakingPoolSnapshot updates the staking pool snapshot associated with the gov
// proposal having the provided id
func (m *Module) updateProposalStakingPoolSnapshot(height int64, proposalID uint64) error {
	pool, err := m.stakingModule.GetStakingPoolSnapshot(height)
	if err != nil {
		return fmt.Errorf("error while getting staking pool: %s", err)
	}

	return m.db.SaveProposalStakingPoolSnapshot(
		types.NewProposalStakingPoolSnapshot(proposalID, pool),
	)
}

// updateProposalValidatorStatusesSnapshot updates the snapshots of the various validators for
// the proposal having the given id
func (m *Module) updateProposalValidatorStatusesSnapshot(
	height int64, proposalID uint64, blockVals *tmctypes.ResultValidators,
) error {
	validators, _, err := m.stakingModule.GetValidatorsWithStatus(height, stakingtypes.Bonded.String())
	if err != nil {
		return fmt.Errorf("error while getting validators with bonded status: %s", err)
	}

	votingPowers, err := m.stakingModule.GetValidatorsVotingPowers(height, blockVals)
	if err != nil {
		return fmt.Errorf("error while getting validators voting powers: %s", err)
	}

	statuses, err := m.stakingModule.GetValidatorsStatuses(height, validators)
	if err != nil {
		return fmt.Errorf("error while getting validator statuses: %s", err)
	}

	var snapshots = make([]types.ProposalValidatorStatusSnapshot, len(validators))
	for index, validator := range validators {
		consAddr, err := validator.GetConsAddr()
		if err != nil {
			return err
		}

		status, err := findStatus(consAddr.String(), statuses)
		if err != nil {
			return fmt.Errorf("error while searching for status: %s", err)
		}

		votingPower, err := findVotingPower(consAddr.String(), votingPowers)
		if err != nil {
			return fmt.Errorf("error while searching for voting power: %s", err)
		}

		snapshots[index] = types.NewProposalValidatorStatusSnapshot(
			proposalID,
			consAddr.String(),
			votingPower.VotingPower,
			status.Status,
			status.Jailed,
			height,
		)
	}

	return m.db.SaveProposalValidatorsStatusesSnapshots(snapshots)
}

func findVotingPower(consAddr string, powers []types.ValidatorVotingPower) (types.ValidatorVotingPower, error) {
	for _, votingPower := range powers {
		if votingPower.ConsensusAddress == consAddr {
			return votingPower, nil
		}
	}
	return types.ValidatorVotingPower{}, fmt.Errorf("voting power not found for validator with consensus address %s", consAddr)
}

func findStatus(consAddr string, statuses []types.ValidatorStatus) (types.ValidatorStatus, error) {
	for _, status := range statuses {
		if status.ConsensusAddress == consAddr {
			return status, nil
		}
	}
	return types.ValidatorStatus{}, fmt.Errorf("cannot find status for validator with consensus address %s", consAddr)
}

func (m *Module) handlePassedProposal(proposal govtypesv1beta1.Proposal, height int64) error {
	if proposal.Status != govtypesv1beta1.StatusPassed {
		// If proposal status is not passed, do nothing
		return nil
	}

	// Unpack proposal
	var content govtypesv1beta1.Content
	var protoCodec codec.ProtoCodec
	err := protoCodec.UnpackAny(proposal.Content, &content)
	if err != nil {
		return fmt.Errorf("error while handling ParamChangeProposal: %s", err)
	}

	switch p := content.(type) {
	case *proposaltypes.ParameterChangeProposal:
		// Update params while ParameterChangeProposal passed
		err = m.handleParamChangeProposal(height, p)
		if err != nil {
			return fmt.Errorf("error while updating params from ParamChangeProposal: %s", err)
		}
	case *upgradetypes.SoftwareUpgradeProposal:
		// Store software upgrade plan while SoftwareUpgradeProposal passed
		err = m.db.SaveSoftwareUpgradePlan(proposal.ProposalId, p.Plan, height)
		if err != nil {
			return fmt.Errorf("error while storing software upgrade plan: %s", err)
		}
	case *upgradetypes.CancelSoftwareUpgradeProposal:
		// Delete software upgrade plan while CancelSoftwareUpgradeProposal passed
		err = m.db.DeleteSoftwareUpgradePlan(proposal.ProposalId)
		if err != nil {
			return fmt.Errorf("error while deleting software upgrade plan: %s", err)
		}
	}
	return nil
}

'''
'''--- modules/mint/handle_genesis.go ---
package mint

import (
	"encoding/json"
	"fmt"

	tmtypes "github.com/cometbft/cometbft/types"

	"github.com/forbole/bdjuno/v5/types"

	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
	"github.com/rs/zerolog/log"
)

// HandleGenesis implements modules.Module
func (m *Module) HandleGenesis(doc *tmtypes.GenesisDoc, appState map[string]json.RawMessage) error {
	log.Debug().Str("module", "mint").Msg("parsing genesis")

	// Read the genesis state
	var genState minttypes.GenesisState
	err := m.cdc.UnmarshalJSON(appState[minttypes.ModuleName], &genState)
	if err != nil {
		return fmt.Errorf("error while reading mint genesis data: %s", err)
	}

	// Save the params
	err = m.db.SaveMintParams(types.NewMintParams(genState.Params, doc.InitialHeight))
	if err != nil {
		return fmt.Errorf("error while storing genesis mint params: %s", err)
	}

	return nil
}

'''
'''--- modules/mint/handle_periodic_operations.go ---
package mint

import (
	"github.com/forbole/bdjuno/v5/modules/utils"

	"github.com/go-co-op/gocron"
	"github.com/rs/zerolog/log"
)

// RegisterPeriodicOperations implements modules.PeriodicOperationsModule
func (m *Module) RegisterPeriodicOperations(scheduler *gocron.Scheduler) error {
	log.Debug().Str("module", "mint").Msg("setting up periodic tasks")

	// Setup a cron job to run every midnight
	if _, err := scheduler.Every(1).Day().At("00:00").Do(func() {
		utils.WatchMethod(m.UpdateInflation)
	}); err != nil {
		return err
	}

	return nil
}

// updateInflation fetches from the REST APIs the latest value for the
// inflation, and saves it inside the database.
func (m *Module) UpdateInflation() error {
	log.Debug().
		Str("module", "mint").
		Str("operation", "inflation").
		Msg("getting inflation data")

	height, err := m.db.GetLastBlockHeight()
	if err != nil {
		return err
	}

	// Get the inflation
	inflation, err := m.source.GetInflation(height)
	if err != nil {
		return err
	}

	return m.db.SaveInflation(inflation, height)
}

'''
'''--- modules/mint/module.go ---
package mint

import (
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/forbole/juno/v5/modules"

	"github.com/forbole/bdjuno/v5/database"
	mintsource "github.com/forbole/bdjuno/v5/modules/mint/source"
)

var (
	_ modules.Module                   = &Module{}
	_ modules.GenesisModule            = &Module{}
	_ modules.PeriodicOperationsModule = &Module{}
)

// Module represent database/mint module
type Module struct {
	cdc    codec.Codec
	db     *database.Db
	source mintsource.Source
}

// NewModule returns a new Module instance
func NewModule(source mintsource.Source, cdc codec.Codec, db *database.Db) *Module {
	return &Module{
		cdc:    cdc,
		db:     db,
		source: source,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "mint"
}

'''
'''--- modules/mint/source/local/source.go ---
package local

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
	"github.com/forbole/juno/v5/node/local"

	mintsource "github.com/forbole/bdjuno/v5/modules/mint/source"
)

var (
	_ mintsource.Source = &Source{}
)

// Source implements mintsource.Source using a local node
type Source struct {
	*local.Source
	querier minttypes.QueryServer
}

// NewSource returns a new Source instace
func NewSource(source *local.Source, querier minttypes.QueryServer) *Source {
	return &Source{
		Source:  source,
		querier: querier,
	}
}

// GetInflation implements mintsource.Source
func (s Source) GetInflation(height int64) (sdk.Dec, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return sdk.Dec{}, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.querier.Inflation(sdk.WrapSDKContext(ctx), &minttypes.QueryInflationRequest{})
	if err != nil {
		return sdk.Dec{}, err
	}

	return res.Inflation, nil
}

// Params implements mintsource.Source
func (s Source) Params(height int64) (minttypes.Params, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return minttypes.Params{}, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.querier.Params(sdk.WrapSDKContext(ctx), &minttypes.QueryParamsRequest{})
	if err != nil {
		return minttypes.Params{}, err
	}

	return res.Params, nil
}

'''
'''--- modules/mint/source/remote/source.go ---
package remote

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
	"github.com/forbole/juno/v5/node/remote"

	mintsource "github.com/forbole/bdjuno/v5/modules/mint/source"
)

var (
	_ mintsource.Source = &Source{}
)

// Source implements mintsource.Source using a remote node
type Source struct {
	*remote.Source
	querier minttypes.QueryClient
}

// NewSource returns a new Source instance
func NewSource(source *remote.Source, querier minttypes.QueryClient) *Source {
	return &Source{
		Source:  source,
		querier: querier,
	}
}

// GetInflation implements mintsource.Source
func (s Source) GetInflation(height int64) (sdk.Dec, error) {
	res, err := s.querier.Inflation(remote.GetHeightRequestContext(s.Ctx, height), &minttypes.QueryInflationRequest{})
	if err != nil {
		return sdk.Dec{}, err
	}

	return res.Inflation, nil
}

// Params implements mintsource.Source
func (s Source) Params(height int64) (minttypes.Params, error) {
	res, err := s.querier.Params(remote.GetHeightRequestContext(s.Ctx, height), &minttypes.QueryParamsRequest{})
	if err != nil {
		return minttypes.Params{}, nil
	}

	return res.Params, nil
}

'''
'''--- modules/mint/source/source.go ---
package source

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
)

type Source interface {
	GetInflation(height int64) (sdk.Dec, error)
	Params(height int64) (minttypes.Params, error)
}

'''
'''--- modules/mint/utils_params.go ---
package mint

import (
	"fmt"

	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/types"
)

// UpdateParams gets the updated params and stores them inside the database
func (m *Module) UpdateParams(height int64) error {
	log.Debug().Str("module", "mint").Int64("height", height).
		Msg("updating params")

	params, err := m.source.Params(height)
	if err != nil {
		return fmt.Errorf("error while getting params: %s", err)
	}

	return m.db.SaveMintParams(types.NewMintParams(params, height))

}

'''
'''--- modules/modules/handle_additional_operations.go ---
package modules

// RunAdditionalOperations implements AdditionalOperationsModule
func (m *Module) RunAdditionalOperations() error {
	return m.db.InsertEnableModules(m.cfg.Modules)
}

'''
'''--- modules/modules/module.go ---
package modules

import (
	"github.com/forbole/juno/v5/modules"
	"github.com/forbole/juno/v5/types/config"

	"github.com/forbole/bdjuno/v5/database"
)

var (
	_ modules.Module                     = &Module{}
	_ modules.AdditionalOperationsModule = &Module{}
)

type Module struct {
	cfg config.ChainConfig
	db  *database.Db
}

// NewModule returns a new Module instance
func NewModule(cfg config.ChainConfig, db *database.Db) *Module {
	return &Module{
		cfg: cfg,
		db:  db,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "modules"
}

'''
'''--- modules/pricefeed/coingecko/apis.go ---
package coingecko

import (
	"encoding/json"
	"fmt"
	"io"
	"math"
	"net/http"
	"strings"

	"github.com/forbole/bdjuno/v5/types"
)

// GetCoinsList allows to fetch from the remote APIs the list of all the supported tokens
func GetCoinsList() (coins Tokens, err error) {
	err = queryCoinGecko("/coins/list", &coins)
	return coins, err
}

// GetTokensPrices queries the remote APIs to get the token prices of all the tokens having the given ids
func GetTokensPrices(ids []string) ([]types.TokenPrice, error) {
	var prices []MarketTicker
	query := fmt.Sprintf("/coins/markets?vs_currency=usd&ids=%s", strings.Join(ids, ","))
	err := queryCoinGecko(query, &prices)
	if err != nil {
		return nil, err
	}

	return ConvertCoingeckoPrices(prices), nil
}

func ConvertCoingeckoPrices(prices []MarketTicker) []types.TokenPrice {
	tokenPrices := make([]types.TokenPrice, len(prices))
	for i, price := range prices {
		tokenPrices[i] = types.NewTokenPrice(
			price.Symbol,
			price.CurrentPrice,
			int64(math.Trunc(price.MarketCap)),
			price.LastUpdated,
		)
	}
	return tokenPrices
}

// queryCoinGecko queries the CoinGecko APIs for the given endpoint
func queryCoinGecko(endpoint string, ptr interface{}) error {
	resp, err := http.Get("https://api.coingecko.com/api/v3" + endpoint)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	bz, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("error while reading response body: %s", err)
	}

	err = json.Unmarshal(bz, &ptr)
	if err != nil {
		return fmt.Errorf("error while unmarshaling response body: %s", err)
	}

	return nil
}

'''
'''--- modules/pricefeed/coingecko/apis_test.go ---
package coingecko_test

import (
	"encoding/json"
	"testing"

	"github.com/stretchr/testify/require"

	"github.com/forbole/bdjuno/v5/modules/pricefeed/coingecko"
)

func TestConvertCoingeckoPrices(t *testing.T) {
	result := `
[
	{
	   "id":"cosmos",
	   "symbol":"atom",
	   "name":"Cosmos",
	   "image":"https://assets.coingecko.com/coins/images/1481/large/cosmos_hub.png?1555657960",
	   "current_price":31.16,
	   "market_cap":8809250407,
	   "market_cap_rank":21,
	   "fully_diluted_valuation":null,
	   "total_volume":2121320957,
	   "high_24h":36.58,
	   "low_24h":28.95,
	   "price_change_24h":2.0,
	   "price_change_percentage_24h":6.87504,
	   "market_cap_change_24h":702667080,
	   "market_cap_change_percentage_24h":8.66786,
	   "circulating_supply":279080458.802741,
	   "total_supply":null,
	   "max_supply":null,
	   "ath":36.58,
	   "ath_change_percentage":-13.6991,
	   "ath_date":"2021-09-13T00:15:37.723Z",
	   "atl":1.16,
	   "atl_change_percentage":2621.02411,
	   "atl_date":"2020-03-13T02:27:44.591Z",
	   "roi":{
		  "times":310.6319088856543,
		  "currency":"usd",
		  "percentage":31063.19088856543
	   },
	   "last_updated":"2021-09-13T08:48:15.930Z"
	},
	{
	   "id":"bitcanna",
	   "symbol":"bcna",
	   "name":"BitCanna",
	   "image":"https://assets.coingecko.com/coins/images/4716/large/bcna.png?1547040016",
	   "current_price":0.03998645,
	   "market_cap":0.0,
	   "market_cap_rank":null,
	   "fully_diluted_valuation":null,
	   "total_volume":186.04,
	   "high_24h":0.082037,
	   "low_24h":0.03733862,
	   "price_change_24h":-0.042050606106,
	   "price_change_percentage_24h":-51.25806,
	   "market_cap_change_24h":0.0,
	   "market_cap_change_percentage_24h":0.0,
	   "circulating_supply":0.0,
	   "total_supply":397427654.089788,
	   "max_supply":null,
	   "ath":0.922537,
	   "ath_change_percentage":-95.6656,
	   "ath_date":"2020-02-06T22:44:34.222Z",
	   "atl":0.00216099,
	   "atl_change_percentage":1750.37612,
	   "atl_date":"2020-01-01T11:24:08.916Z",
	   "roi":{
		  "times":-0.6667795841096327,
		  "currency":"usd",
		  "percentage":-66.67795841096327
	   },
	   "last_updated":"2021-09-13T07:08:54.093Z"
	},
	{
	   "id":"bitcoin",
	   "symbol":"btc",
	   "name":"Bitcoin",
	   "image":"https://assets.coingecko.com/coins/images/1/large/bitcoin.png?1547033579",
	   "current_price":44397,
	   "market_cap":836648999243,
	   "market_cap_rank":1,
	   "fully_diluted_valuation":933832354264,
	   "total_volume":30593030219,
	   "high_24h":46494,
	   "low_24h":44313,
	   "price_change_24h":-1735.169587249417,
	   "price_change_percentage_24h":-3.76128,
	   "market_cap_change_24h":-30612716244.69995,
	   "market_cap_change_percentage_24h":-3.52981,
	   "circulating_supply":18814543,
	   "total_supply":21000000,
	   "max_supply":21000000,
	   "ath":64805,
	   "ath_change_percentage":-30.97016,
	   "ath_date":"2021-04-14T11:54:46.763Z",
	   "atl":67.81,
	   "atl_change_percentage":65871.47051,
	   "atl_date":"2013-07-06T00:00:00.000Z",
	   "roi":null,
	   "last_updated":"2021-09-13T08:56:15.583Z"
	}
]
`

	var apisPrices []coingecko.MarketTicker
	err := json.Unmarshal([]byte(result), &apisPrices)
	require.NoError(t, err)

	prices := coingecko.ConvertCoingeckoPrices(apisPrices)
	require.Equal(t, int64(8809250407), prices[0].MarketCap)
	require.Equal(t, int64(0), prices[1].MarketCap)
	require.Equal(t, int64(836648999243), prices[2].MarketCap)
}

'''
'''--- modules/pricefeed/coingecko/types.go ---
package coingecko

import "time"

// Token contains the information of a single token
type Token struct {
	ID     string `json:"id"`
	Symbol string `json:"symbol"`
	Name   string `json:"name"`
}

// Tokens represents a list of Token objects
type Tokens []Token

// MarketTicker contains the current market data for a single token
type MarketTicker struct {
	Symbol       string    `json:"symbol"`
	CurrentPrice float64   `json:"current_price"`
	MarketCap    float64   `json:"market_cap"`
	LastUpdated  time.Time `json:"last_updated"`
}

// MarketTickers is an array of MarketTicker
type MarketTickers []MarketTicker

'''
'''--- modules/pricefeed/config.go ---
package pricefeed

import (
	"gopkg.in/yaml.v3"

	"github.com/forbole/bdjuno/v5/types"
)

// Config contains the configuration about the pricefeed module
type Config struct {
	Tokens []types.Token `yaml:"tokens"`
}

// NewConfig returns a new Config instance
func NewConfig(tokens []types.Token) *Config {
	return &Config{
		Tokens: tokens,
	}
}

func ParseConfig(bz []byte) (*Config, error) {
	type T struct {
		Config *Config `yaml:"pricefeed"`
	}
	var cfg T
	err := yaml.Unmarshal(bz, &cfg)
	return cfg.Config, err
}

'''
'''--- modules/pricefeed/handle_additional_operations.go ---
package pricefeed

import (
	"fmt"
	"time"

	"github.com/forbole/bdjuno/v5/types"

	"github.com/rs/zerolog/log"
)

// RunAdditionalOperations implements modules.AdditionalOperationsModule
func (m *Module) RunAdditionalOperations() error {
	err := m.checkConfig()
	if err != nil {
		return err
	}

	return m.storeTokens()
}

// checkConfig checks if the module config is valid
func (m *Module) checkConfig() error {
	if m.cfg == nil {
		return fmt.Errorf("pricefeed config is not set but module is enabled")
	}

	return nil
}

// storeTokens stores the tokens defined inside the given configuration into the database
func (m *Module) storeTokens() error {
	log.Debug().Str("module", "pricefeed").Msg("storing tokens")

	var prices []types.TokenPrice
	for _, coin := range m.cfg.Tokens {
		// Save the coin as a token with its units
		err := m.db.SaveToken(coin)
		if err != nil {
			return fmt.Errorf("error while saving token: %s", err)
		}

		// Create the price entry
		for _, unit := range coin.Units {
			// Skip units with empty price ids
			if unit.PriceID == "" {
				continue
			}

			prices = append(prices, types.NewTokenPrice(unit.Denom, 0, 0, time.Time{}))
		}
	}

	err := m.db.SaveTokensPrices(prices)
	if err != nil {
		return fmt.Errorf("error while storing token prices: %s", err)
	}

	return nil
}

'''
'''--- modules/pricefeed/handle_periodic_operations.go ---
package pricefeed

import (
	"fmt"
	"time"

	"github.com/go-co-op/gocron"
	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/types"

	"github.com/forbole/bdjuno/v5/modules/pricefeed/coingecko"
	"github.com/forbole/bdjuno/v5/modules/utils"
)

// RegisterPeriodicOperations implements modules.PeriodicOperationsModule
func (m *Module) RegisterPeriodicOperations(scheduler *gocron.Scheduler) error {
	log.Debug().Str("module", "pricefeed").Msg("setting up periodic tasks")

	// Fetch the token prices every 2 mins
	if _, err := scheduler.Every(2).Minutes().Do(func() {
		utils.WatchMethod(m.UpdatePrice)
	}); err != nil {
		return fmt.Errorf("error while setting up pricefeed period operations: %s", err)
	}

	// Update the historical token prices every 1 hour
	if _, err := scheduler.Every(1).Hour().Do(func() {
		utils.WatchMethod(m.UpdatePricesHistory)
	}); err != nil {
		return fmt.Errorf("error while setting up history period operations: %s", err)
	}

	return nil
}

// getTokenPrices allows to get the most up-to-date token prices
func (m *Module) getTokenPrices() ([]types.TokenPrice, error) {
	// Get the list of tokens price id
	ids, err := m.db.GetTokensPriceID()
	if err != nil {
		return nil, fmt.Errorf("error while getting tokens price id: %s", err)
	}

	if len(ids) == 0 {
		log.Debug().Str("module", "pricefeed").Msg("no traded tokens price id found")
		return nil, nil
	}

	// Get the tokens prices
	prices, err := coingecko.GetTokensPrices(ids)
	if err != nil {
		return nil, fmt.Errorf("error while getting tokens prices: %s", err)
	}

	return prices, nil
}

// UpdatePrice fetches the total amount of coins in the system from RPC and stores it in database
func (m *Module) UpdatePrice() error {
	log.Debug().
		Str("module", "pricefeed").
		Str("operation", "pricefeed").
		Msg("updating token price and market cap")

	prices, err := m.getTokenPrices()
	if err != nil {
		return err
	}

	// Save the token prices
	err = m.db.SaveTokensPrices(prices)
	if err != nil {
		return fmt.Errorf("error while saving token prices: %s", err)
	}

	return nil

}

// UpdatePricesHistory fetches total amount of coins in the system from RPC
// and stores historical perice data inside the database
func (m *Module) UpdatePricesHistory() error {
	log.Debug().
		Str("module", "pricefeed").
		Str("operation", "pricefeed").
		Msg("updating token price and market cap history")

	prices, err := m.getTokenPrices()
	if err != nil {
		return err
	}

	// Normally, the last updated value reflects the time when the price was last updated.
	// If price hasn't changed, the returned timestamp will be the same as one hour ago, and it will not
	// be stored in db as it will be a duplicated value.
	// To fix this, we set each price timestamp to be the same as other ones.
	timestamp := time.Now()
	for _, price := range prices {
		price.Timestamp = timestamp
	}

	err = m.db.SaveTokenPricesHistory(prices)
	if err != nil {
		return fmt.Errorf("error while saving token prices history: %s", err)
	}

	return nil
}

'''
'''--- modules/pricefeed/module.go ---
package pricefeed

import (
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/forbole/juno/v5/types/config"

	"github.com/forbole/bdjuno/v5/database"

	"github.com/forbole/juno/v5/modules"
)

var (
	_ modules.Module                     = &Module{}
	_ modules.AdditionalOperationsModule = &Module{}
	_ modules.PeriodicOperationsModule   = &Module{}
)

// Module represents the module that allows to get the token prices
type Module struct {
	cfg *Config
	cdc codec.Codec
	db  *database.Db
}

// NewModule returns a new Module instance
func NewModule(cfg config.Config, cdc codec.Codec, db *database.Db) *Module {
	bz, err := cfg.GetBytes()
	if err != nil {
		panic(err)
	}

	pricefeedCfg, err := ParseConfig(bz)
	if err != nil {
		panic(err)
	}

	return &Module{
		cfg: pricefeedCfg,
		cdc: cdc,
		db:  db,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "pricefeed"
}

'''
'''--- modules/registrar.go ---
package modules

import (
	"github.com/forbole/bdjuno/v5/modules/actions"
	"github.com/forbole/bdjuno/v5/modules/types"

	"github.com/forbole/juno/v5/modules/pruning"
	"github.com/forbole/juno/v5/modules/telemetry"

	"github.com/forbole/bdjuno/v5/modules/slashing"

	"github.com/cosmos/cosmos-sdk/codec"
	sdk "github.com/cosmos/cosmos-sdk/types"
	jmodules "github.com/forbole/juno/v5/modules"
	"github.com/forbole/juno/v5/modules/messages"
	"github.com/forbole/juno/v5/modules/registrar"

	"github.com/forbole/bdjuno/v5/utils"

	"github.com/forbole/bdjuno/v5/database"
	"github.com/forbole/bdjuno/v5/modules/auth"
	"github.com/forbole/bdjuno/v5/modules/bank"
	"github.com/forbole/bdjuno/v5/modules/consensus"
	"github.com/forbole/bdjuno/v5/modules/distribution"
	"github.com/forbole/bdjuno/v5/modules/feegrant"

	dailyrefetch "github.com/forbole/bdjuno/v5/modules/daily_refetch"
	"github.com/forbole/bdjuno/v5/modules/gov"
	"github.com/forbole/bdjuno/v5/modules/mint"
	"github.com/forbole/bdjuno/v5/modules/modules"
	"github.com/forbole/bdjuno/v5/modules/pricefeed"
	"github.com/forbole/bdjuno/v5/modules/staking"
	"github.com/forbole/bdjuno/v5/modules/upgrade"
)

// UniqueAddressesParser returns a wrapper around the given parser that removes all duplicated addresses
func UniqueAddressesParser(parser messages.MessageAddressesParser) messages.MessageAddressesParser {
	return func(cdc codec.Codec, msg sdk.Msg) ([]string, error) {
		addresses, err := parser(cdc, msg)
		if err != nil {
			return nil, err
		}

		return utils.RemoveDuplicateValues(addresses), nil
	}
}

// --------------------------------------------------------------------------------------------------------------------

var (
	_ registrar.Registrar = &Registrar{}
)

// Registrar represents the modules.Registrar that allows to register all modules that are supported by BigDipper
type Registrar struct {
	parser messages.MessageAddressesParser
}

// NewRegistrar allows to build a new Registrar instance
func NewRegistrar(parser messages.MessageAddressesParser) *Registrar {
	return &Registrar{
		parser: UniqueAddressesParser(parser),
	}
}

// BuildModules implements modules.Registrar
func (r *Registrar) BuildModules(ctx registrar.Context) jmodules.Modules {
	cdc := ctx.EncodingConfig.Codec
	db := database.Cast(ctx.Database)

	sources, err := types.BuildSources(ctx.JunoConfig.Node, ctx.EncodingConfig)
	if err != nil {
		panic(err)
	}

	actionsModule := actions.NewModule(ctx.JunoConfig, ctx.EncodingConfig)
	authModule := auth.NewModule(r.parser, cdc, db)
	bankModule := bank.NewModule(r.parser, sources.BankSource, cdc, db)
	consensusModule := consensus.NewModule(db)
	dailyRefetchModule := dailyrefetch.NewModule(ctx.Proxy, db)
	distrModule := distribution.NewModule(sources.DistrSource, cdc, db)
	feegrantModule := feegrant.NewModule(cdc, db)
	mintModule := mint.NewModule(sources.MintSource, cdc, db)
	slashingModule := slashing.NewModule(sources.SlashingSource, cdc, db)
	stakingModule := staking.NewModule(sources.StakingSource, cdc, db)
	govModule := gov.NewModule(sources.GovSource, authModule, distrModule, mintModule, slashingModule, stakingModule, cdc, db)
	upgradeModule := upgrade.NewModule(db, stakingModule)

	return []jmodules.Module{
		messages.NewModule(r.parser, cdc, ctx.Database),
		telemetry.NewModule(ctx.JunoConfig),
		pruning.NewModule(ctx.JunoConfig, db, ctx.Logger),

		actionsModule,
		authModule,
		bankModule,
		consensusModule,
		dailyRefetchModule,
		distrModule,
		feegrantModule,
		govModule,
		mintModule,
		modules.NewModule(ctx.JunoConfig.Chain, db),
		pricefeed.NewModule(ctx.JunoConfig, cdc, db),
		slashingModule,
		stakingModule,
		upgradeModule,
	}
}

'''
'''--- modules/slashing/handle_block.go ---
package slashing

import (
	"fmt"

	juno "github.com/forbole/juno/v5/types"

	tmctypes "github.com/cometbft/cometbft/rpc/core/types"
	"github.com/rs/zerolog/log"
)

// HandleBlock implements BlockModule
func (m *Module) HandleBlock(
	block *tmctypes.ResultBlock, results *tmctypes.ResultBlockResults, _ []*juno.Tx, _ *tmctypes.ResultValidators,
) error {
	// Update the signing infos
	err := m.updateSigningInfo(block.Block.Height)
	if err != nil {
		return fmt.Errorf("error while updating signing info: %s", err)
	}

	return nil
}

// updateSigningInfo reads from the LCD the current staking pool and stores its value inside the database
func (m *Module) updateSigningInfo(height int64) error {
	log.Debug().Str("module", "slashing").Int64("height", height).Msg("updating signing info")

	signingInfos, err := m.getSigningInfos(height)
	if err != nil {
		return err
	}

	return m.db.SaveValidatorsSigningInfos(signingInfos)
}

'''
'''--- modules/slashing/handle_genesis.go ---
package slashing

import (
	"encoding/json"
	"fmt"

	tmtypes "github.com/cometbft/cometbft/types"

	"github.com/forbole/bdjuno/v5/types"

	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
	"github.com/rs/zerolog/log"
)

// HandleGenesis implements modules.Module
func (m *Module) HandleGenesis(doc *tmtypes.GenesisDoc, appState map[string]json.RawMessage) error {
	log.Debug().Str("module", "slashing").Msg("parsing genesis")

	// Read the genesis state
	var genState slashingtypes.GenesisState
	err := m.cdc.UnmarshalJSON(appState[slashingtypes.ModuleName], &genState)
	if err != nil {
		return fmt.Errorf("error while reading mint genesis data: %s", err)
	}

	// Save the params
	err = m.db.SaveSlashingParams(types.NewSlashingParams(genState.Params, doc.InitialHeight))
	if err != nil {
		return fmt.Errorf("error while storing genesis slashing params: %s", err)
	}

	return nil
}

'''
'''--- modules/slashing/module.go ---
package slashing

import (
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/forbole/juno/v5/modules"

	"github.com/forbole/bdjuno/v5/database"
	slashingsource "github.com/forbole/bdjuno/v5/modules/slashing/source"
)

var (
	_ modules.Module        = &Module{}
	_ modules.GenesisModule = &Module{}
	_ modules.BlockModule   = &Module{}
)

// Module represent x/slashing module
type Module struct {
	cdc    codec.Codec
	db     *database.Db
	source slashingsource.Source
}

// NewModule returns a new Module instance
func NewModule(source slashingsource.Source, cdc codec.Codec, db *database.Db) *Module {
	return &Module{
		cdc:    cdc,
		db:     db,
		source: source,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "slashing"
}

'''
'''--- modules/slashing/source/local/source.go ---
package local

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/query"
	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
	"github.com/forbole/juno/v5/node/local"

	slashingsource "github.com/forbole/bdjuno/v5/modules/slashing/source"
)

var (
	_ slashingsource.Source = &Source{}
)

// Source implements slashingsource.Source using a local node
type Source struct {
	*local.Source
	querier slashingtypes.QueryServer
}

// NewSource implements a new Source instance
func NewSource(source *local.Source, querier slashingtypes.QueryServer) *Source {
	return &Source{
		Source:  source,
		querier: querier,
	}
}

// GetSigningInfos implements slashingsource.Source
func (s Source) GetSigningInfos(height int64) ([]slashingtypes.ValidatorSigningInfo, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	var signingInfos []slashingtypes.ValidatorSigningInfo
	var nextKey []byte
	var stop = false
	for !stop {
		res, err := s.querier.SigningInfos(
			sdk.WrapSDKContext(ctx),
			&slashingtypes.QuerySigningInfosRequest{
				Pagination: &query.PageRequest{
					Key:   nextKey,
					Limit: 1000, // Query 1000 signing infos at a time
				},
			},
		)
		if err != nil {
			return nil, err
		}

		nextKey = res.Pagination.NextKey
		stop = len(res.Pagination.NextKey) == 0
		signingInfos = append(signingInfos, res.Info...)
	}

	return signingInfos, nil
}

// GetParams implements slashingsource.Source
func (s Source) GetParams(height int64) (slashingtypes.Params, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return slashingtypes.Params{}, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.querier.Params(sdk.WrapSDKContext(ctx), &slashingtypes.QueryParamsRequest{})
	if err != nil {
		return slashingtypes.Params{}, nil
	}

	return res.Params, nil
}

// GetSigningInfo implements slashingsource.GetSigningInfo
func (s Source) GetSigningInfo(height int64, consAddr sdk.ConsAddress) (slashingtypes.ValidatorSigningInfo, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return slashingtypes.ValidatorSigningInfo{}, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.querier.SigningInfo(
		sdk.WrapSDKContext(ctx),
		&slashingtypes.QuerySigningInfoRequest{
			ConsAddress: consAddr.String(),
		},
	)

	if err != nil {
		return slashingtypes.ValidatorSigningInfo{}, err
	}

	return res.ValSigningInfo, nil
}

'''
'''--- modules/slashing/source/remote/source.go ---
package remote

import (
	sdk "github.com/cosmos/cosmos-sdk/types"

	"github.com/cosmos/cosmos-sdk/types/query"
	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
	"github.com/forbole/juno/v5/node/remote"

	slashingsource "github.com/forbole/bdjuno/v5/modules/slashing/source"
)

var (
	_ slashingsource.Source = &Source{}
)

// Source implements slashingsource.Source using a remote node
type Source struct {
	*remote.Source
	querier slashingtypes.QueryClient
}

// NewSource returns a new Source implementation
func NewSource(source *remote.Source, querier slashingtypes.QueryClient) *Source {
	return &Source{
		Source:  source,
		querier: querier,
	}
}

// GetSigningInfos implements slashingsource.Source
func (s Source) GetSigningInfos(height int64) ([]slashingtypes.ValidatorSigningInfo, error) {
	ctx := remote.GetHeightRequestContext(s.Ctx, height)

	var signingInfos []slashingtypes.ValidatorSigningInfo
	var nextKey []byte
	var stop = false
	for !stop {
		res, err := s.querier.SigningInfos(
			ctx,
			&slashingtypes.QuerySigningInfosRequest{
				Pagination: &query.PageRequest{
					Key:   nextKey,
					Limit: 1000, // Query 1000 signing infos at a time
				},
			},
		)
		if err != nil {
			return nil, err
		}

		nextKey = res.Pagination.NextKey
		stop = len(res.Pagination.NextKey) == 0
		signingInfos = append(signingInfos, res.Info...)
	}

	return signingInfos, nil
}

// GetParams implements slashingsource.Source
func (s Source) GetParams(height int64) (slashingtypes.Params, error) {
	res, err := s.querier.Params(remote.GetHeightRequestContext(s.Ctx, height), &slashingtypes.QueryParamsRequest{})
	if err != nil {
		return slashingtypes.Params{}, nil
	}

	return res.Params, nil
}

// GetSigningInfo implements slashingsource.GetSigningInfo
func (s Source) GetSigningInfo(height int64, consAddr sdk.ConsAddress) (slashingtypes.ValidatorSigningInfo, error) {
	res, err := s.querier.SigningInfo(
		s.Ctx,
		&slashingtypes.QuerySigningInfoRequest{
			ConsAddress: consAddr.String(),
		},
	)

	if err != nil {
		return slashingtypes.ValidatorSigningInfo{}, err
	}
	return res.ValSigningInfo, nil
}

'''
'''--- modules/slashing/source/source.go ---
package source

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
)

type Source interface {
	GetSigningInfo(height int64, consAddr sdk.ConsAddress) (slashingtypes.ValidatorSigningInfo, error)
	GetSigningInfos(height int64) ([]slashingtypes.ValidatorSigningInfo, error)
	GetParams(height int64) (slashingtypes.Params, error)
}

'''
'''--- modules/slashing/utils_params.go ---
package slashing

import (
	"fmt"

	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/types"
)

// UpdateParams gets the slashing params for the given height, and stores them inside the database
func (m *Module) UpdateParams(height int64) error {
	log.Debug().Str("module", "slashing").Int64("height", height).Msg("updating params")

	params, err := m.source.GetParams(height)
	if err != nil {
		return fmt.Errorf("error while getting params: %s", err)
	}

	return m.db.SaveSlashingParams(types.NewSlashingParams(params, height))

}

'''
'''--- modules/slashing/utils_signing_info.go ---
package slashing

import (
	sdk "github.com/cosmos/cosmos-sdk/types"

	"github.com/forbole/bdjuno/v5/types"
)

func (m *Module) getSigningInfos(height int64) ([]types.ValidatorSigningInfo, error) {
	signingInfos, err := m.source.GetSigningInfos(height)
	if err != nil {
		return nil, err
	}

	infos := make([]types.ValidatorSigningInfo, len(signingInfos))
	for index, info := range signingInfos {
		infos[index] = types.NewValidatorSigningInfo(
			info.Address,
			info.StartHeight,
			info.IndexOffset,
			info.JailedUntil,
			info.Tombstoned,
			info.MissedBlocksCounter,
			height,
		)
	}

	return infos, nil
}

// GetSigningInfo returns the signing info for the validator having the given consensus address at the specified height
func (m *Module) GetSigningInfo(height int64, consAddr sdk.ConsAddress) (types.ValidatorSigningInfo, error) {
	info, err := m.source.GetSigningInfo(height, consAddr)
	if err != nil {
		return types.ValidatorSigningInfo{}, err
	}

	signingInfo := types.NewValidatorSigningInfo(
		info.Address,
		info.StartHeight,
		info.IndexOffset,
		info.JailedUntil,
		info.Tombstoned,
		info.MissedBlocksCounter,
		height,
	)

	return signingInfo, nil
}

'''
'''--- modules/staking/handle_block.go ---
package staking

import (
	"encoding/hex"
	"fmt"

	"github.com/forbole/bdjuno/v5/types"

	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	juno "github.com/forbole/juno/v5/types"

	tmctypes "github.com/cometbft/cometbft/rpc/core/types"
	tmtypes "github.com/cometbft/cometbft/types"
	"github.com/rs/zerolog/log"
)

// HandleBlock implements BlockModule
func (m *Module) HandleBlock(
	block *tmctypes.ResultBlock, res *tmctypes.ResultBlockResults, _ []*juno.Tx, vals *tmctypes.ResultValidators,
) error {
	// Update the validators
	validators, err := m.updateValidators(block.Block.Height)
	if err != nil {
		return fmt.Errorf("error while updating validators: %s", err)
	}

	// Update the voting powers
	go m.updateValidatorVotingPower(block.Block.Height, vals)

	// Update the validators statuses
	go m.updateValidatorsStatus(block.Block.Height, validators)

	// Updated the double sign evidences
	go m.updateDoubleSignEvidence(block.Block.Height, block.Block.Evidence.Evidence)

	return nil
}

// updateValidatorsStatus updates all validators' statuses
func (m *Module) updateValidatorsStatus(height int64, validators []stakingtypes.Validator) {
	log.Debug().Str("module", "staking").Int64("height", height).
		Msg("updating validators statuses")

	statuses, err := m.GetValidatorsStatuses(height, validators)
	if err != nil {
		log.Error().Str("module", "staking").Err(err).
			Int64("height", height).
			Send()
		return
	}

	err = m.db.SaveValidatorsStatuses(statuses)
	if err != nil {
		log.Error().Str("module", "staking").Err(err).
			Int64("height", height).
			Msg("error while saving validators statuses")
	}
}

// updateValidatorVotingPower fetches and stores into the database all the current validators' voting powers
func (m *Module) updateValidatorVotingPower(height int64, vals *tmctypes.ResultValidators) {
	log.Debug().Str("module", "staking").Int64("height", height).
		Msg("updating validators voting powers")

	// Get the voting powers
	votingPowers, err := m.GetValidatorsVotingPowers(height, vals)
	if err != nil {
		log.Error().Str("module", "staking").Err(err).Int64("height", height).
			Msg("error while getting validators voting powers")
		return
	}

	// Save all the voting powers
	err = m.db.SaveValidatorsVotingPowers(votingPowers)
	if err != nil {
		log.Error().Str("module", "staking").Err(err).Int64("height", height).
			Msg("error while saving validators voting powers")
	}
}

// updateDoubleSignEvidence updates the double sign evidence of all validators
func (m *Module) updateDoubleSignEvidence(height int64, evidenceList tmtypes.EvidenceList) {
	log.Debug().Str("module", "staking").Int64("height", height).
		Msg("updating double sign evidence")

	for _, ev := range evidenceList {
		dve, ok := ev.(*tmtypes.DuplicateVoteEvidence)
		if !ok {
			continue
		}

		evidence := types.NewDoubleSignEvidence(
			height,
			types.NewDoubleSignVote(
				int(dve.VoteA.Type),
				dve.VoteA.Height,
				dve.VoteA.Round,
				dve.VoteA.BlockID.String(),
				juno.ConvertValidatorAddressToBech32String(dve.VoteA.ValidatorAddress),
				dve.VoteA.ValidatorIndex,
				hex.EncodeToString(dve.VoteA.Signature),
			),
			types.NewDoubleSignVote(
				int(dve.VoteB.Type),
				dve.VoteB.Height,
				dve.VoteB.Round,
				dve.VoteB.BlockID.String(),
				juno.ConvertValidatorAddressToBech32String(dve.VoteB.ValidatorAddress),
				dve.VoteB.ValidatorIndex,
				hex.EncodeToString(dve.VoteB.Signature),
			),
		)

		err := m.db.SaveDoubleSignEvidence(evidence)
		if err != nil {
			log.Error().Str("module", "staking").Err(err).Int64("height", height).
				Msg("error while saving double sign evidence")
			return
		}

	}
}

'''
'''--- modules/staking/handle_genesis.go ---
package staking

import (
	"encoding/json"
	"fmt"

	"github.com/cosmos/cosmos-sdk/types/tx"

	"github.com/forbole/bdjuno/v5/types"

	tmtypes "github.com/cometbft/cometbft/types"

	genutiltypes "github.com/cosmos/cosmos-sdk/x/genutil/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"

	"github.com/rs/zerolog/log"
)

// HandleGenesis implements GenesisModule
func (m *Module) HandleGenesis(doc *tmtypes.GenesisDoc, appState map[string]json.RawMessage) error {
	log.Debug().Str("module", "staking").Msg("parsing genesis")

	// Read the genesis state
	var genState stakingtypes.GenesisState
	err := m.cdc.UnmarshalJSON(appState[stakingtypes.ModuleName], &genState)
	if err != nil {
		return fmt.Errorf("error while unmarshaling staking state: %s", err)
	}

	// Save the params
	err = m.db.SaveStakingParams(types.NewStakingParams(genState.Params, doc.InitialHeight))
	if err != nil {
		return fmt.Errorf("error while storing genesis staking params: %s", err)
	}

	// Parse genesis transactions
	err = m.parseGenesisTransactions(doc, appState)
	if err != nil {
		return fmt.Errorf("error while storing genesis transactions: %s", err)
	}

	// Save the validators
	err = m.saveValidators(doc, genState.Validators)
	if err != nil {
		return fmt.Errorf("error while storing staking genesis validators: %s", err)
	}

	// Save the description
	err = m.saveValidatorDescription(doc, genState.Validators)
	if err != nil {
		return fmt.Errorf("error while storing staking genesis validator descriptions: %s", err)
	}

	err = m.saveValidatorsCommissions(doc.InitialHeight, genState.Validators)
	if err != nil {
		return fmt.Errorf("error while storing staking genesis validators commissions: %s", err)
	}

	return nil
}

func (m *Module) parseGenesisTransactions(doc *tmtypes.GenesisDoc, appState map[string]json.RawMessage) error {
	var genUtilState genutiltypes.GenesisState
	err := m.cdc.UnmarshalJSON(appState[genutiltypes.ModuleName], &genUtilState)
	if err != nil {
		return fmt.Errorf("error while unmarhsaling genutil state: %s", err)
	}

	for _, genTxBz := range genUtilState.GetGenTxs() {
		// Unmarshal the transaction
		var genTx tx.Tx
		err = m.cdc.UnmarshalJSON(genTxBz, &genTx)
		if err != nil {
			return fmt.Errorf("error while unmashasling genesis tx: %s", err)
		}

		for _, msg := range genTx.GetMsgs() {
			// Handle the message properly
			createValMsg, ok := msg.(*stakingtypes.MsgCreateValidator)
			if !ok {
				continue
			}

			err = m.StoreValidatorsFromMsgCreateValidator(doc.InitialHeight, createValMsg)
			if err != nil {
				return fmt.Errorf("error while storing validators from MsgCreateValidator: %s", err)
			}
		}

	}

	return nil
}

// --------------------------------------------------------------------------------------------------------------------

// saveValidators stores the validators data present inside the given genesis state
func (m *Module) saveValidators(doc *tmtypes.GenesisDoc, validators stakingtypes.Validators) error {
	vals := make([]types.Validator, len(validators))
	for i, val := range validators {
		validator, err := m.convertValidator(doc.InitialHeight, val)
		if err != nil {
			return err
		}

		vals[i] = validator
	}

	return m.db.SaveValidatorsData(vals)
}

// saveValidatorDescription saves the description for the given validators
func (m *Module) saveValidatorDescription(doc *tmtypes.GenesisDoc, validators stakingtypes.Validators) error {
	for _, account := range validators {
		description := m.convertValidatorDescription(
			doc.InitialHeight,
			account.OperatorAddress,
			account.Description,
		)

		err := m.db.SaveValidatorDescription(description)
		if err != nil {
			return err
		}
	}

	return nil
}

// --------------------------------------------------------------------------------------------------------------------

// saveValidatorsCommissions save the initial commission for each validator
func (m *Module) saveValidatorsCommissions(height int64, validators stakingtypes.Validators) error {
	for _, account := range validators {
		err := m.db.SaveValidatorCommission(types.NewValidatorCommission(
			account.OperatorAddress,
			&account.Commission.Rate,
			&account.MinSelfDelegation,
			height,
		))
		if err != nil {
			return err
		}
	}

	return nil
}

'''
'''--- modules/staking/handle_msg.go ---
package staking

import (
	"fmt"

	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"

	sdk "github.com/cosmos/cosmos-sdk/types"
	juno "github.com/forbole/juno/v5/types"
)

// HandleMsg implements MessageModule
func (m *Module) HandleMsg(index int, msg sdk.Msg, tx *juno.Tx) error {
	if len(tx.Logs) == 0 {
		return nil
	}

	switch cosmosMsg := msg.(type) {
	case *stakingtypes.MsgCreateValidator:
		return m.handleMsgCreateValidator(tx.Height, cosmosMsg)

	case *stakingtypes.MsgEditValidator:
		return m.handleEditValidator(tx.Height, cosmosMsg)
	}

	return nil
}

// ---------------------------------------------------------------------------------------------------------------------

// handleMsgCreateValidator handles properly a MsgCreateValidator instance by
// saving into the database all the data associated to such validator
func (m *Module) handleMsgCreateValidator(height int64, msg *stakingtypes.MsgCreateValidator) error {
	err := m.RefreshValidatorInfos(height, msg.ValidatorAddress)
	if err != nil {
		return fmt.Errorf("error while refreshing validator from MsgCreateValidator: %s", err)
	}
	return nil
}

// handleEditValidator handles MsgEditValidator utils, updating the validator info
func (m *Module) handleEditValidator(height int64, msg *stakingtypes.MsgEditValidator) error {
	err := m.RefreshValidatorInfos(height, msg.ValidatorAddress)
	if err != nil {
		return fmt.Errorf("error while refreshing validator from MsgEditValidator: %s", err)
	}

	return nil
}

'''
'''--- modules/staking/handle_periodic_operations.go ---
package staking

import (
	"fmt"

	"github.com/go-co-op/gocron"
	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/modules/utils"
)

// RegisterPeriodicOperations implements modules.PeriodicOperationsModule
func (m *Module) RegisterPeriodicOperations(scheduler *gocron.Scheduler) error {
	log.Debug().Str("module", "staking").Msg("setting up periodic tasks")

	// Update the staking pool every 5 mins
	if _, err := scheduler.Every(5).Minutes().Do(func() {
		utils.WatchMethod(m.UpdateStakingPool)
	}); err != nil {
		return fmt.Errorf("error while scheduling staking pool periodic operation: %s", err)
	}

	return nil
}

// UpdateStakingPool reads from the LCD the current staking pool and stores its value inside the database
func (m *Module) UpdateStakingPool() error {
	height, err := m.db.GetLastBlockHeight()
	if err != nil {
		return fmt.Errorf("error while getting latest block height: %s", err)
	}
	log.Debug().Str("module", "staking").Int64("height", height).
		Msg("updating staking pool")

	pool, err := m.GetStakingPool(height)
	if err != nil {
		return fmt.Errorf("error while getting staking pool: %s", err)

	}

	err = m.db.SaveStakingPool(pool)
	if err != nil {
		return fmt.Errorf("error while saving staking pool: %s", err)

	}

	return nil
}

'''
'''--- modules/staking/keybase/apis.go ---
package keybase

import (
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

// GetAvatarURL returns the avatar URL from the given identity.
// If no identity is found, it returns an empty string instead.
func GetAvatarURL(identity string) (string, error) {
	if len(identity) < 16 {
		return "", nil
	}

	var response IdentityQueryResponse
	endpoint := fmt.Sprintf("/user/lookup.json?key_suffix=%[1]s&fields=basics&fields=pictures", identity)
	err := queryKeyBase(endpoint, &response)
	if err != nil {
		return "", fmt.Errorf("error while querying keybase: %s", err)
	}

	// The server responded with an error
	if response.Status.Code != 0 {
		return "", fmt.Errorf("response code not valid: %s", response.Status.ErrDesc)
	}

	// No images found
	if len(response.Objects) == 0 {
		return "", nil
	}

	// Either the pictures do not exist, or the primary one does not exist, or the URL is empty
	data := response.Objects[0]
	if data.Pictures == nil || data.Pictures.Primary == nil || len(data.Pictures.Primary.URL) == 0 {
		return "", nil
	}

	// The picture URL is found
	return data.Pictures.Primary.URL, nil
}

// queryKeyBase queries the Keybase APIs for the given endpoint, and de-serializes
// the response as a JSON object inside the given ptr
func queryKeyBase(endpoint string, ptr interface{}) error {
	resp, err := http.Get("https://keybase.io/_/api/1.0" + endpoint)
	if err != nil {
		return fmt.Errorf("error while querying keybase APIs: %s", err)
	}

	defer resp.Body.Close()

	bz, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("error while reading response body: %s", err)
	}

	err = json.Unmarshal(bz, &ptr)
	if err != nil {
		return fmt.Errorf("error while unmarshaling response body: %s", err)
	}

	return nil
}

'''
'''--- modules/staking/keybase/types.go ---
package keybase

// QueryStatus contains the details of the status of a request
type QueryStatus struct {
	Code    int64  `json:"code"`
	Name    string `json:"name"`
	ErrDesc string `json:"desc"`
}

// IdentityQueryResponse represents the response to an identity query
type IdentityQueryResponse struct {
	Status  QueryStatus      `json:"status"`
	Objects []AccountDetails `json:"them"`
}

// AccountDetails contains the data of a single account details
type AccountDetails struct {
	ID       string           `json:"id"`
	Pictures *AccountPictures `json:"pictures"`
}

// AccountPictures contains the info of an account's pictures
type AccountPictures struct {
	Primary *Picture `json:"primary"`
}

// Picture contains the info of a single picture
type Picture struct {
	URL string `json:"url"`
}

'''
'''--- modules/staking/module.go ---
package staking

import (
	"github.com/cosmos/cosmos-sdk/codec"
	"github.com/forbole/juno/v5/modules"

	"github.com/forbole/bdjuno/v5/database"
	stakingsource "github.com/forbole/bdjuno/v5/modules/staking/source"
)

var (
	_ modules.Module                   = &Module{}
	_ modules.GenesisModule            = &Module{}
	_ modules.BlockModule              = &Module{}
	_ modules.MessageModule            = &Module{}
	_ modules.PeriodicOperationsModule = &Module{}
)

// Module represents the x/staking module
type Module struct {
	cdc    codec.Codec
	db     *database.Db
	source stakingsource.Source
}

// NewModule returns a new Module instance
func NewModule(
	source stakingsource.Source, cdc codec.Codec, db *database.Db,
) *Module {
	return &Module{
		cdc:    cdc,
		db:     db,
		source: source,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "staking"
}

'''
'''--- modules/staking/source/local/source.go ---
package local

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/query"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/forbole/juno/v5/node/local"

	stakingsource "github.com/forbole/bdjuno/v5/modules/staking/source"
)

var (
	_ stakingsource.Source = &Source{}
)

// Source implements stakingsource.Source using a local node
type Source struct {
	*local.Source
	q stakingtypes.QueryServer
}

// NewSource returns a new Source instance
func NewSource(source *local.Source, querier stakingtypes.QueryServer) *Source {
	return &Source{
		Source: source,
		q:      querier,
	}
}

// GetValidator implements stakingsource.Source
func (s Source) GetValidator(height int64, valOper string) (stakingtypes.Validator, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return stakingtypes.Validator{}, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.Validator(sdk.WrapSDKContext(ctx), &stakingtypes.QueryValidatorRequest{ValidatorAddr: valOper})
	if err != nil {
		return stakingtypes.Validator{}, fmt.Errorf("error while reading validator: %s", err)
	}

	return res.Validator, nil
}

// GetDelegationsWithPagination implements stakingsource.Source
func (s Source) GetDelegationsWithPagination(height int64, delegator string, pagination *query.PageRequest) (*stakingtypes.QueryDelegatorDelegationsResponse, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.DelegatorDelegations(
		sdk.WrapSDKContext(ctx),
		&stakingtypes.QueryDelegatorDelegationsRequest{
			DelegatorAddr: delegator,
			Pagination: &query.PageRequest{
				Limit:      pagination.GetLimit(),
				Offset:     pagination.GetOffset(),
				CountTotal: pagination.GetCountTotal(),
			},
		},
	)
	if err != nil {
		return nil, err
	}

	return res, nil
}

// GetRedelegations implements stakingsource.Source
func (s Source) GetRedelegations(height int64, request *stakingtypes.QueryRedelegationsRequest) (*stakingtypes.QueryRedelegationsResponse, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	redelegations, err := s.q.Redelegations(sdk.WrapSDKContext(ctx), request)
	if err != nil {
		return nil, err
	}

	return redelegations, nil
}

// GetValidatorsWithStatus implements stakingsource.Source
func (s Source) GetValidatorsWithStatus(height int64, status string) ([]stakingtypes.Validator, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	var validators []stakingtypes.Validator
	var nextKey []byte
	var stop = false
	for !stop {
		res, err := s.q.Validators(
			sdk.WrapSDKContext(ctx),
			&stakingtypes.QueryValidatorsRequest{
				Status: status,
				Pagination: &query.PageRequest{
					Key:   nextKey,
					Limit: 100, // Query 100 validators at time
				},
			},
		)
		if err != nil {
			return nil, err
		}

		nextKey = res.Pagination.NextKey
		stop = len(res.Pagination.NextKey) == 0
		validators = append(validators, res.Validators...)
	}

	return validators, nil
}

// GetPool implements stakingsource.Source
func (s Source) GetPool(height int64) (stakingtypes.Pool, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return stakingtypes.Pool{}, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.Pool(
		sdk.WrapSDKContext(ctx),
		&stakingtypes.QueryPoolRequest{},
	)
	if err != nil {
		return stakingtypes.Pool{}, err
	}

	return res.Pool, nil
}

// GetParams implements stakingsource.Source
func (s Source) GetParams(height int64) (stakingtypes.Params, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return stakingtypes.Params{}, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.Params(
		sdk.WrapSDKContext(ctx),
		&stakingtypes.QueryParamsRequest{},
	)
	if err != nil {
		return stakingtypes.Params{}, nil
	}

	return res.Params, nil
}

// GetUnbondingDelegations implements stakingsource.Source
func (s Source) GetUnbondingDelegations(height int64, delegator string, pagination *query.PageRequest) (*stakingtypes.QueryDelegatorUnbondingDelegationsResponse, error) {

	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	unbondingDelegations, err := s.q.DelegatorUnbondingDelegations(
		sdk.WrapSDKContext(ctx),
		&stakingtypes.QueryDelegatorUnbondingDelegationsRequest{
			DelegatorAddr: delegator,
			Pagination: &query.PageRequest{
				Limit:      pagination.GetLimit(),
				Offset:     pagination.GetOffset(),
				CountTotal: pagination.GetCountTotal(),
			},
		},
	)
	if err != nil {
		return nil, err
	}

	return unbondingDelegations, nil

}

// GetValidatorDelegationsWithPagination implements stakingsource.Source
func (s Source) GetValidatorDelegationsWithPagination(
	height int64, validator string, pagination *query.PageRequest,
) (*stakingtypes.QueryValidatorDelegationsResponse, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	res, err := s.q.ValidatorDelegations(
		sdk.WrapSDKContext(ctx),
		&stakingtypes.QueryValidatorDelegationsRequest{
			ValidatorAddr: validator,
			Pagination:    pagination,
		},
	)
	if err != nil {
		return nil, err
	}

	return res, nil
}

// GetUnbondingDelegationsFromValidator implements stakingsource.Source
func (s Source) GetUnbondingDelegationsFromValidator(
	height int64, validator string, pagination *query.PageRequest,
) (*stakingtypes.QueryValidatorUnbondingDelegationsResponse, error) {
	ctx, err := s.LoadHeight(height)
	if err != nil {
		return nil, fmt.Errorf("error while loading height: %s", err)
	}

	unbondingDelegations, err := s.q.ValidatorUnbondingDelegations(
		sdk.WrapSDKContext(ctx),
		&stakingtypes.QueryValidatorUnbondingDelegationsRequest{
			ValidatorAddr: validator,
			Pagination:    pagination,
		},
	)
	if err != nil {
		return nil, err
	}

	return unbondingDelegations, nil
}

'''
'''--- modules/staking/source/remote/source.go ---
package remote

import (
	"fmt"

	"github.com/cosmos/cosmos-sdk/types/query"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/forbole/juno/v5/node/remote"

	stakingsource "github.com/forbole/bdjuno/v5/modules/staking/source"
)

var (
	_ stakingsource.Source = &Source{}
)

// Source implements stakingsource.Source using a remote node
type Source struct {
	*remote.Source
	stakingClient stakingtypes.QueryClient
}

// NewSource returns a new Source instance
func NewSource(source *remote.Source, stakingClient stakingtypes.QueryClient) *Source {
	return &Source{
		Source:        source,
		stakingClient: stakingClient,
	}
}

// GetValidator implements stakingsource.Source
func (s Source) GetValidator(height int64, valOper string) (stakingtypes.Validator, error) {
	res, err := s.stakingClient.Validator(
		remote.GetHeightRequestContext(s.Ctx, height),
		&stakingtypes.QueryValidatorRequest{ValidatorAddr: valOper},
	)
	if err != nil {
		return stakingtypes.Validator{}, fmt.Errorf("error while getting validator: %s", err)
	}

	return res.Validator, nil
}

// GetValidatorsWithStatus implements stakingsource.Source
func (s Source) GetValidatorsWithStatus(height int64, status string) ([]stakingtypes.Validator, error) {
	ctx := remote.GetHeightRequestContext(s.Ctx, height)

	var validators []stakingtypes.Validator
	var nextKey []byte
	var stop = false
	for !stop {
		res, err := s.stakingClient.Validators(
			ctx,
			&stakingtypes.QueryValidatorsRequest{
				Status: status,
				Pagination: &query.PageRequest{
					Key:   nextKey,
					Limit: 100, // Query 100 validators at time
				},
			},
		)
		if err != nil {
			return nil, err
		}

		nextKey = res.Pagination.NextKey
		stop = len(res.Pagination.NextKey) == 0
		validators = append(validators, res.Validators...)
	}

	return validators, nil
}

// GetPool implements stakingsource.Source
func (s Source) GetPool(height int64) (stakingtypes.Pool, error) {
	res, err := s.stakingClient.Pool(remote.GetHeightRequestContext(s.Ctx, height), &stakingtypes.QueryPoolRequest{})
	if err != nil {
		return stakingtypes.Pool{}, err
	}

	return res.Pool, nil
}

// GetParams implements stakingsource.Source
func (s Source) GetParams(height int64) (stakingtypes.Params, error) {
	res, err := s.stakingClient.Params(remote.GetHeightRequestContext(s.Ctx, height), &stakingtypes.QueryParamsRequest{})
	if err != nil {
		return stakingtypes.Params{}, err
	}

	return res.Params, nil
}

'''
'''--- modules/staking/source/remote/source_actions.go ---
package remote

import (
	"github.com/cosmos/cosmos-sdk/types/query"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/forbole/juno/v5/node/remote"

	"github.com/forbole/bdjuno/v5/utils"
)

// GetDelegationsWithPagination implements stakingsource.Source
func (s Source) GetDelegationsWithPagination(
	height int64, delegator string, pagination *query.PageRequest,
) (*stakingtypes.QueryDelegatorDelegationsResponse, error) {
	ctx := utils.GetHeightRequestContext(s.Ctx, height)
	res, err := s.stakingClient.DelegatorDelegations(
		ctx,
		&stakingtypes.QueryDelegatorDelegationsRequest{
			DelegatorAddr: delegator,
			Pagination:    pagination,
		},
	)
	if err != nil {
		return nil, err
	}

	return res, nil
}

// GetUnbondingDelegations implements stakingsource.Source
func (s Source) GetUnbondingDelegations(height int64, delegator string, pagination *query.PageRequest) (*stakingtypes.QueryDelegatorUnbondingDelegationsResponse, error) {
	ctx := utils.GetHeightRequestContext(s.Ctx, height)

	unbondingDelegations, err := s.stakingClient.DelegatorUnbondingDelegations(
		ctx,
		&stakingtypes.QueryDelegatorUnbondingDelegationsRequest{
			DelegatorAddr: delegator,
			Pagination:    pagination,
		},
	)
	if err != nil {
		return nil, err
	}

	return unbondingDelegations, nil
}

// GetRedelegations implements stakingsource.Source
func (s Source) GetRedelegations(height int64, request *stakingtypes.QueryRedelegationsRequest) (*stakingtypes.QueryRedelegationsResponse, error) {
	ctx := utils.GetHeightRequestContext(s.Ctx, height)

	redelegations, err := s.stakingClient.Redelegations(ctx, request)
	if err != nil {
		return nil, err
	}
	return redelegations, nil
}

// GetValidatorDelegationsWithPagination implements stakingsource.Source
func (s Source) GetValidatorDelegationsWithPagination(
	height int64, validator string, pagination *query.PageRequest,
) (*stakingtypes.QueryValidatorDelegationsResponse, error) {

	res, err := s.stakingClient.ValidatorDelegations(
		remote.GetHeightRequestContext(s.Ctx, height),
		&stakingtypes.QueryValidatorDelegationsRequest{
			ValidatorAddr: validator,
			Pagination:    pagination,
		},
	)
	if err != nil {
		return nil, err
	}

	return res, nil
}

// GetUnbondingDelegationsFromValidator implements stakingsource.Source
func (s Source) GetUnbondingDelegationsFromValidator(
	height int64, validator string, pagination *query.PageRequest,
) (*stakingtypes.QueryValidatorUnbondingDelegationsResponse, error) {

	unbondingDelegations, err := s.stakingClient.ValidatorUnbondingDelegations(
		remote.GetHeightRequestContext(s.Ctx, height),
		&stakingtypes.QueryValidatorUnbondingDelegationsRequest{
			ValidatorAddr: validator,
			Pagination:    pagination,
		},
	)
	if err != nil {
		return nil, err
	}

	return unbondingDelegations, nil
}

'''
'''--- modules/staking/source/source.go ---
package source

import (
	"github.com/cosmos/cosmos-sdk/types/query"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
)

type Source interface {
	GetValidator(height int64, valOper string) (stakingtypes.Validator, error)
	GetValidatorsWithStatus(height int64, status string) ([]stakingtypes.Validator, error)
	GetDelegationsWithPagination(height int64, delegator string, pagination *query.PageRequest) (*stakingtypes.QueryDelegatorDelegationsResponse, error)
	GetRedelegations(height int64, request *stakingtypes.QueryRedelegationsRequest) (*stakingtypes.QueryRedelegationsResponse, error)
	GetPool(height int64) (stakingtypes.Pool, error)
	GetParams(height int64) (stakingtypes.Params, error)
	GetUnbondingDelegations(height int64, delegator string, pagination *query.PageRequest) (*stakingtypes.QueryDelegatorUnbondingDelegationsResponse, error)
	GetValidatorDelegationsWithPagination(height int64, validator string, pagination *query.PageRequest) (*stakingtypes.QueryValidatorDelegationsResponse, error)
	GetUnbondingDelegationsFromValidator(height int64, validator string, pagination *query.PageRequest) (*stakingtypes.QueryValidatorUnbondingDelegationsResponse, error)
}

'''
'''--- modules/staking/utils_gentx.go ---
package staking

import (
	"fmt"

	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"

	"github.com/forbole/bdjuno/v5/modules/staking/keybase"
	"github.com/forbole/bdjuno/v5/types"
)

// StoreValidatorFromMsgCreateValidator handles properly a MsgCreateValidator instance by
// saving into the database all the data associated to such validator
func (m *Module) StoreValidatorsFromMsgCreateValidator(height int64, msg *stakingtypes.MsgCreateValidator) error {
	var pubKey cryptotypes.PubKey
	err := m.cdc.UnpackAny(msg.Pubkey, &pubKey)
	if err != nil {
		return fmt.Errorf("error while unpacking pub key: %s", err)
	}
	avatarURL, err := keybase.GetAvatarURL(msg.Description.Identity)
	if err != nil {
		return fmt.Errorf("error while getting Avatar URL: %s", err)
	}

	// Save the validators
	err = m.db.SaveValidatorData(
		types.NewValidator(
			sdk.ConsAddress(pubKey.Address()).String(),
			msg.ValidatorAddress, pubKey.String(),
			msg.DelegatorAddress,
			&msg.Commission.MaxChangeRate,
			&msg.Commission.MaxRate,
			height,
		),
	)
	if err != nil {
		return err
	}

	// Save the descriptions
	err = m.db.SaveValidatorDescription(
		types.NewValidatorDescription(
			msg.ValidatorAddress,
			msg.Description,
			avatarURL,
			height,
		),
	)
	if err != nil {
		return err
	}

	// Save the commissions
	err = m.db.SaveValidatorCommission(
		types.NewValidatorCommission(
			msg.ValidatorAddress,
			&msg.Commission.Rate,
			&msg.MinSelfDelegation,
			height,
		),
	)
	if err != nil {
		return err
	}

	return nil
}

'''
'''--- modules/staking/utils_params.go ---
package staking

import (
	"fmt"

	"github.com/rs/zerolog/log"

	"github.com/forbole/bdjuno/v5/types"
)

// UpdateParams gets the updated params and stores them inside the database
func (m *Module) UpdateParams(height int64) error {
	log.Debug().Str("module", "staking").Int64("height", height).
		Msg("updating params")

	params, err := m.source.GetParams(height)
	if err != nil {
		return fmt.Errorf("error while getting params: %s", err)
	}

	return m.db.SaveStakingParams(types.NewStakingParams(params, height))
}

'''
'''--- modules/staking/utils_staking_pool.go ---
package staking

import (
	"fmt"

	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/query"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/forbole/bdjuno/v5/types"
)

func (m *Module) GetStakingPool(height int64) (*types.Pool, error) {
	pool, err := m.source.GetPool(height)
	if err != nil {
		return nil, fmt.Errorf("error while getting staking pool: %s", err)
	}

	validatorsList, err := m.db.GetValidators()
	if err != nil {
		return nil, fmt.Errorf("error while getting validators list: %s", err)
	}

	var unbondingTokens = sdk.NewInt(0)

	for _, validator := range validatorsList {
		// get list of all unbonding delegations for each validator
		unbondingDelegations := m.getTotalUnbondingDelegationsFromValidator(height, validator.GetOperator())
		if len(unbondingDelegations) > 0 {
			// calculate total value of unbonding tokens
			for _, unbonding := range unbondingDelegations {
				for _, entry := range unbonding.Entries {
					unbondingTokens = unbondingTokens.Add(entry.Balance)
				}
			}
		}

	}

	// calculate total value of staked tokens that are not bonded
	stakedNotBondedTokens := pool.NotBondedTokens.Sub(unbondingTokens)

	return types.NewPool(pool.BondedTokens, pool.NotBondedTokens, unbondingTokens, stakedNotBondedTokens, height), nil
}

func (m *Module) GetStakingPoolSnapshot(height int64) (*types.PoolSnapshot, error) {
	pool, err := m.source.GetPool(height)
	if err != nil {
		return nil, fmt.Errorf("error while getting staking pool snapshot: %s", err)
	}

	return types.NewPoolSnapshot(pool.BondedTokens, pool.NotBondedTokens, height), nil
}

func (m *Module) getTotalUnbondingDelegationsFromValidator(height int64, valOperatorAddress string) []stakingtypes.UnbondingDelegation {
	var unbondingDelegations []stakingtypes.UnbondingDelegation
	var nextKey []byte
	var stop = false
	for !stop {
		res, err := m.source.GetUnbondingDelegationsFromValidator(height,
			valOperatorAddress,
			&query.PageRequest{Key: nextKey},
		)
		if err != nil {
			return []stakingtypes.UnbondingDelegation{}
		}

		nextKey = res.Pagination.NextKey
		stop = len(res.Pagination.NextKey) == 0
		unbondingDelegations = append(unbondingDelegations, res.UnbondingResponses...)
	}
	return unbondingDelegations
}

'''
'''--- modules/staking/utils_validators.go ---
package staking

import (
	"fmt"

	tmctypes "github.com/cometbft/cometbft/rpc/core/types"
	juno "github.com/forbole/juno/v5/types"

	"github.com/forbole/bdjuno/v5/modules/staking/keybase"
	"github.com/forbole/bdjuno/v5/types"

	"github.com/rs/zerolog/log"

	cryptotypes "github.com/cosmos/cosmos-sdk/crypto/types"
	sdk "github.com/cosmos/cosmos-sdk/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
)

// getValidatorConsPubKey returns the consensus public key of the given validator
func (m *Module) getValidatorConsPubKey(validator stakingtypes.Validator) (cryptotypes.PubKey, error) {
	var pubKey cryptotypes.PubKey
	err := m.cdc.UnpackAny(validator.ConsensusPubkey, &pubKey)
	return pubKey, err
}

// getValidatorConsAddr returns the consensus address of the given validator
func (m *Module) getValidatorConsAddr(validator stakingtypes.Validator) (sdk.ConsAddress, error) {
	pubKey, err := m.getValidatorConsPubKey(validator)
	if err != nil {
		return nil, fmt.Errorf("error while getting validator consensus pub key: %s", err)
	}

	return sdk.ConsAddress(pubKey.Address()), err
}

// ---------------------------------------------------------------------------------------------------------------------

// ConvertValidator converts the given staking validator into a BDJuno validator
func (m *Module) convertValidator(height int64, validator stakingtypes.Validator) (types.Validator, error) {
	consAddr, err := m.getValidatorConsAddr(validator)
	if err != nil {
		return nil, fmt.Errorf("error while getting validator consensus address: %s", err)
	}

	consPubKey, err := m.getValidatorConsPubKey(validator)
	if err != nil {
		return nil, fmt.Errorf("error while getting validator consensus pub key: %s", err)
	}

	return types.NewValidator(
		consAddr.String(),
		validator.OperatorAddress,
		consPubKey.String(),
		sdk.AccAddress(validator.GetOperator()).String(),
		&validator.Commission.MaxChangeRate,
		&validator.Commission.MaxRate,
		height,
	), nil
}

// convertValidatorDescription returns a new types.ValidatorDescription object by fetching the avatar URL
// using the Keybase APIs
func (m *Module) convertValidatorDescription(
	height int64, opAddr string, description stakingtypes.Description,
) types.ValidatorDescription {
	var avatarURL string

	if description.Identity == stakingtypes.DoNotModifyDesc {
		avatarURL = stakingtypes.DoNotModifyDesc
	} else {
		url, err := keybase.GetAvatarURL(description.Identity)
		if err != nil {
			url = ""
		}
		avatarURL = url
	}

	return types.NewValidatorDescription(opAddr, description, avatarURL, height)
}

// --------------------------------------------------------------------------------------------------------------------

// RefreshAllValidatorInfos refreshes the info of all the validators at the given height
func (m *Module) RefreshAllValidatorInfos(height int64) error {
	// Get all validators
	validators, err := m.source.GetValidatorsWithStatus(height, "")
	if err != nil {
		return fmt.Errorf("error while getting validators: %s", err)
	}

	// Refresh each validator
	for _, validator := range validators {
		err = m.RefreshValidatorInfos(height, validator.OperatorAddress)
		if err != nil {
			return fmt.Errorf("error while refreshing validator: %s", err)
		}
	}

	return nil
}

// RefreshValidatorInfos refreshes the info for the validator with the given operator address at the provided height
func (m *Module) RefreshValidatorInfos(height int64, valOper string) error {
	stakingValidator, err := m.source.GetValidator(height, valOper)
	if err != nil {
		return err
	}

	validator, err := m.convertValidator(height, stakingValidator)
	if err != nil {
		return fmt.Errorf("error while converting validator: %s", err)
	}

	desc := m.convertValidatorDescription(height, stakingValidator.OperatorAddress, stakingValidator.Description)

	// Save the validator
	err = m.db.SaveValidatorsData([]types.Validator{validator})
	if err != nil {
		return err
	}

	// Save the description
	err = m.db.SaveValidatorDescription(desc)
	if err != nil {
		return err
	}

	// Save the commission
	return m.db.SaveValidatorCommission(types.NewValidatorCommission(
		stakingValidator.OperatorAddress,
		&stakingValidator.Commission.Rate,
		&stakingValidator.MinSelfDelegation,
		height,
	))
}

// GetValidatorsWithStatus returns the list of all the validators having the given status at the given height
func (m *Module) GetValidatorsWithStatus(height int64, status string) ([]stakingtypes.Validator, []types.Validator, error) {
	validators, err := m.source.GetValidatorsWithStatus(height, status)
	if err != nil {
		return nil, nil, err
	}

	var vals = make([]types.Validator, len(validators))
	for index, val := range validators {
		validator, err := m.convertValidator(height, val)
		if err != nil {
			return nil, nil, fmt.Errorf("error while converting validator: %s", err)
		}

		vals[index] = validator
	}

	return validators, vals, nil
}

// getValidators returns the validators list at the given height
func (m *Module) getValidators(height int64) ([]stakingtypes.Validator, []types.Validator, error) {
	return m.GetValidatorsWithStatus(height, "")
}

// updateValidators updates the list of validators that are present at the given height
func (m *Module) updateValidators(height int64) ([]stakingtypes.Validator, error) {
	log.Debug().Str("module", "staking").Int64("height", height).
		Msg("updating validators")

	vals, validators, err := m.getValidators(height)
	if err != nil {
		return nil, fmt.Errorf("error while getting validator: %s", err)
	}

	err = m.db.SaveValidatorsData(validators)
	if err != nil {
		return nil, err
	}

	return vals, err
}

// --------------------------------------------------------------------------------------------------------------------

func (m *Module) GetValidatorsStatuses(height int64, validators []stakingtypes.Validator) ([]types.ValidatorStatus, error) {
	statuses := make([]types.ValidatorStatus, len(validators))
	for index, validator := range validators {
		consAddr, err := m.getValidatorConsAddr(validator)
		if err != nil {
			return nil, fmt.Errorf("error while getting validator consensus address: %s", err)
		}

		consPubKey, err := m.getValidatorConsPubKey(validator)
		if err != nil {
			return nil, fmt.Errorf("error while getting validator consensus public key: %s", err)
		}

		statuses[index] = types.NewValidatorStatus(
			consAddr.String(),
			consPubKey.String(),
			int(validator.GetStatus()),
			validator.IsJailed(),
			height,
		)
	}

	return statuses, nil
}

func (m *Module) GetValidatorsVotingPowers(height int64, vals *tmctypes.ResultValidators) ([]types.ValidatorVotingPower, error) {
	stakingVals, _, err := m.getValidators(height)
	if err != nil {
		return nil, err
	}

	votingPowers := make([]types.ValidatorVotingPower, len(stakingVals))
	for index, validator := range stakingVals {
		// Get the validator consensus address
		consAddr, err := validator.GetConsAddr()
		if err != nil {
			return nil, err
		}

		// Find the voting power of this validator
		var votingPower int64 = 0
		for _, blockVal := range vals.Validators {
			blockValConsAddr := juno.ConvertValidatorAddressToBech32String(blockVal.Address)
			if blockValConsAddr == consAddr.String() {
				votingPower = blockVal.VotingPower
			}
		}

		if found, _ := m.db.HasValidator(consAddr.String()); !found {
			continue
		}

		votingPowers[index] = types.NewValidatorVotingPower(consAddr.String(), votingPower, height)
	}

	return votingPowers, nil
}

'''
'''--- modules/types/sources.go ---
package types

import (
	"fmt"
	"os"

	"github.com/cometbft/cometbft/libs/log"

	"cosmossdk.io/simapp"
	"cosmossdk.io/simapp/params"
	"github.com/forbole/juno/v5/node/remote"

	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
	govtypesv1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1"
	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"
	minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"
	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
	stakingkeeper "github.com/cosmos/cosmos-sdk/x/staking/keeper"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
	"github.com/forbole/juno/v5/node/local"

	nodeconfig "github.com/forbole/juno/v5/node/config"

	banksource "github.com/forbole/bdjuno/v5/modules/bank/source"
	localbanksource "github.com/forbole/bdjuno/v5/modules/bank/source/local"
	remotebanksource "github.com/forbole/bdjuno/v5/modules/bank/source/remote"
	distrsource "github.com/forbole/bdjuno/v5/modules/distribution/source"
	remotedistrsource "github.com/forbole/bdjuno/v5/modules/distribution/source/remote"
	govsource "github.com/forbole/bdjuno/v5/modules/gov/source"
	localgovsource "github.com/forbole/bdjuno/v5/modules/gov/source/local"
	remotegovsource "github.com/forbole/bdjuno/v5/modules/gov/source/remote"
	mintsource "github.com/forbole/bdjuno/v5/modules/mint/source"
	localmintsource "github.com/forbole/bdjuno/v5/modules/mint/source/local"
	remotemintsource "github.com/forbole/bdjuno/v5/modules/mint/source/remote"
	slashingsource "github.com/forbole/bdjuno/v5/modules/slashing/source"
	localslashingsource "github.com/forbole/bdjuno/v5/modules/slashing/source/local"
	remoteslashingsource "github.com/forbole/bdjuno/v5/modules/slashing/source/remote"
	stakingsource "github.com/forbole/bdjuno/v5/modules/staking/source"
	localstakingsource "github.com/forbole/bdjuno/v5/modules/staking/source/local"
	remotestakingsource "github.com/forbole/bdjuno/v5/modules/staking/source/remote"
)

type Sources struct {
	BankSource     banksource.Source
	DistrSource    distrsource.Source
	GovSource      govsource.Source
	MintSource     mintsource.Source
	SlashingSource slashingsource.Source
	StakingSource  stakingsource.Source
}

func BuildSources(nodeCfg nodeconfig.Config, encodingConfig *params.EncodingConfig) (*Sources, error) {
	switch cfg := nodeCfg.Details.(type) {
	case *remote.Details:
		return buildRemoteSources(cfg)
	case *local.Details:
		return buildLocalSources(cfg, encodingConfig)

	default:
		return nil, fmt.Errorf("invalid configuration type: %T", cfg)
	}
}

func buildLocalSources(cfg *local.Details, encodingConfig *params.EncodingConfig) (*Sources, error) {
	source, err := local.NewSource(cfg.Home, encodingConfig)
	if err != nil {
		return nil, err
	}

	app := simapp.NewSimApp(
		log.NewTMLogger(log.NewSyncWriter(os.Stdout)), source.StoreDB, nil, true, nil, nil,
	)

	sources := &Sources{
		BankSource: localbanksource.NewSource(source, banktypes.QueryServer(app.BankKeeper)),
		// DistrSource:    localdistrsource.NewSource(source, distrtypes.QueryServer(app.DistrKeeper)),
		GovSource:      localgovsource.NewSource(source, govtypesv1.QueryServer(app.GovKeeper), nil),
		MintSource:     localmintsource.NewSource(source, minttypes.QueryServer(app.MintKeeper)),
		SlashingSource: localslashingsource.NewSource(source, slashingtypes.QueryServer(app.SlashingKeeper)),
		StakingSource:  localstakingsource.NewSource(source, stakingkeeper.Querier{Keeper: app.StakingKeeper}),
	}

	// Mount and initialize the stores
	err = source.MountKVStores(app, "keys")
	if err != nil {
		return nil, err
	}

	err = source.MountTransientStores(app, "tkeys")
	if err != nil {
		return nil, err
	}

	err = source.MountMemoryStores(app, "memKeys")
	if err != nil {
		return nil, err
	}

	err = source.InitStores()
	if err != nil {
		return nil, err
	}

	return sources, nil
}

func buildRemoteSources(cfg *remote.Details) (*Sources, error) {
	source, err := remote.NewSource(cfg.GRPC)
	if err != nil {
		return nil, fmt.Errorf("error while creating remote source: %s", err)
	}

	return &Sources{
		BankSource:     remotebanksource.NewSource(source, banktypes.NewQueryClient(source.GrpcConn)),
		DistrSource:    remotedistrsource.NewSource(source, distrtypes.NewQueryClient(source.GrpcConn)),
		GovSource:      remotegovsource.NewSource(source, govtypesv1.NewQueryClient(source.GrpcConn), govtypesv1beta1.NewQueryClient(source.GrpcConn)),
		MintSource:     remotemintsource.NewSource(source, minttypes.NewQueryClient(source.GrpcConn)),
		SlashingSource: remoteslashingsource.NewSource(source, slashingtypes.NewQueryClient(source.GrpcConn)),
		StakingSource:  remotestakingsource.NewSource(source, stakingtypes.NewQueryClient(source.GrpcConn)),
	}, nil
}

'''
'''--- modules/upgrade/expected_modules.go ---
package upgrade

type StakingModule interface {
	RefreshAllValidatorInfos(height int64) error
}

'''
'''--- modules/upgrade/handle_block.go ---
package upgrade

import (
	"fmt"

	"github.com/forbole/juno/v5/types"

	tmctypes "github.com/cometbft/cometbft/rpc/core/types"
)

// HandleBlock implements modules.Module
func (m *Module) HandleBlock(
	b *tmctypes.ResultBlock, _ *tmctypes.ResultBlockResults, _ []*types.Tx, _ *tmctypes.ResultValidators,
) error {
	err := m.refreshDataUponSoftwareUpgrade(b.Block.Height)
	if err != nil {
		return fmt.Errorf("error while refreshing data upon software upgrade: %s", err)
	}

	return nil
}

func (m *Module) refreshDataUponSoftwareUpgrade(height int64) error {
	exist, err := m.db.CheckSoftwareUpgradePlan(height)
	if err != nil {
		return fmt.Errorf("error while checking software upgrade plan existence: %s", err)
	}
	if !exist {
		return nil
	}

	// Refresh validator infos
	err = m.stakingModule.RefreshAllValidatorInfos(height)
	if err != nil {
		return fmt.Errorf("error while refreshing validator infos upon software upgrade: %s", err)
	}

	// Delete plan after refreshing data
	err = m.db.TruncateSoftwareUpgradePlan(height)
	if err != nil {
		return fmt.Errorf("error while truncating software upgrade plan: %s", err)
	}

	return nil
}

'''
'''--- modules/upgrade/module.go ---
package upgrade

import (
	"github.com/forbole/bdjuno/v5/database"

	"github.com/forbole/juno/v5/modules"
)

var (
	_ modules.Module      = &Module{}
	_ modules.BlockModule = &Module{}
)

// Module represents the x/upgrade module
type Module struct {
	db            *database.Db
	stakingModule StakingModule
}

// NewModule builds a new Module instance
func NewModule(db *database.Db, stakingModule StakingModule) *Module {
	return &Module{
		stakingModule: stakingModule,
		db:            db,
	}
}

// Name implements modules.Module
func (m *Module) Name() string {
	return "upgrade"
}

'''
'''--- modules/utils/addresses.go ---
package utils

import sdk "github.com/cosmos/cosmos-sdk/types"

// FilterNonAccountAddresses filters all the non-account addresses from the given slice of addresses, returning a new
// slice containing only account addresses.
func FilterNonAccountAddresses(addresses []string) []string {
	// Filter using only the account addresses as the MessageAddressesParser might return also validator addresses
	var accountAddresses []string
	for _, address := range addresses {
		_, err := sdk.AccAddressFromBech32(address)
		if err == nil {
			accountAddresses = append(accountAddresses, address)
		}
	}
	return accountAddresses
}

'''
'''--- modules/utils/addresses_test.go ---
package utils_test

import (
	"testing"

	"github.com/forbole/bdjuno/v5/modules/utils"

	"github.com/stretchr/testify/require"
)

func TestFilterNonAccountAddresses(t *testing.T) {
	addresses := []string{
		"cosmos1hafptm4zxy5nw8rd2pxyg83c5ls2v62tstzuv2",
		"cosmosvaloper1hafptm4zxy5nw8rd2pxyg83c5ls2v62t4lkfqe",
	}

	filtered := utils.FilterNonAccountAddresses(addresses)
	require.Equal(t, []string{
		"cosmos1hafptm4zxy5nw8rd2pxyg83c5ls2v62tstzuv2",
	}, filtered)
}

'''
'''--- modules/utils/errors.go ---
package utils

import (
	"github.com/rs/zerolog/log"
)

// WatchMethod allows to watch for a method that returns an error.
// It executes the given method in a goroutine, logging any error that might raise.
func WatchMethod(method func() error) {
	go func() {
		err := method()
		if err != nil {
			log.Error().Err(err).Send()
		}
	}()
}

'''
'''--- types/auth.go ---
package types

// Account represents a chain account
type Account struct {
	Address string
}

// NewAccount builds a new Account instance
func NewAccount(address string) Account {
	return Account{
		Address: address,
	}
}

'''
'''--- types/bank.go ---
package types

import sdk "github.com/cosmos/cosmos-sdk/types"

// AccountBalance represents the balance of an account at a given height
type AccountBalance struct {
	Address string
	Balance sdk.Coins
	Height  int64
}

// NewAccountBalance allows to build a new AccountBalance instance
func NewAccountBalance(address string, balance sdk.Coins, height int64) AccountBalance {
	return AccountBalance{
		Address: address,
		Balance: balance,
		Height:  height,
	}
}

'''
'''--- types/config/config.go ---
package config

import (
	initcmd "github.com/forbole/juno/v5/cmd/init"
	junoconfig "github.com/forbole/juno/v5/types/config"
	"github.com/spf13/cobra"
	"gopkg.in/yaml.v3"

	"github.com/forbole/bdjuno/v5/modules/actions"
)

// Config represents the BDJuno configuration
type Config struct {
	JunoConfig    junoconfig.Config `yaml:"-,inline"`
	ActionsConfig *actions.Config   `yaml:"actions"`
}

// NewConfig returns a new Config instance
func NewConfig(junoCfg junoconfig.Config, actionsCfg *actions.Config) Config {
	return Config{
		JunoConfig:    junoCfg,
		ActionsConfig: actionsCfg,
	}
}

// GetBytes implements WritableConfig
func (c Config) GetBytes() ([]byte, error) {
	return yaml.Marshal(&c)
}

// Creator represents a configuration creator
func Creator(_ *cobra.Command) initcmd.WritableConfig {
	return NewConfig(junoconfig.DefaultConfig(), actions.DefaultConfig())
}

'''
'''--- types/config/encoding.go ---
package config

import (
	"cosmossdk.io/simapp/params"
	"github.com/cosmos/cosmos-sdk/std"
	"github.com/cosmos/cosmos-sdk/types/module"
)

// MakeEncodingConfig creates an EncodingConfig to properly handle all the messages
func MakeEncodingConfig(managers []module.BasicManager) func() params.EncodingConfig {
	return func() params.EncodingConfig {
		encodingConfig := params.MakeTestEncodingConfig()
		std.RegisterLegacyAminoCodec(encodingConfig.Amino)
		std.RegisterInterfaces(encodingConfig.InterfaceRegistry)
		manager := mergeBasicManagers(managers)
		manager.RegisterLegacyAminoCodec(encodingConfig.Amino)
		manager.RegisterInterfaces(encodingConfig.InterfaceRegistry)
		return encodingConfig
	}
}

// mergeBasicManagers merges the given managers into a single module.BasicManager
func mergeBasicManagers(managers []module.BasicManager) module.BasicManager {
	var union = module.BasicManager{}
	for _, manager := range managers {
		for k, v := range manager {
			union[k] = v
		}
	}
	return union
}

'''
'''--- types/consensus.go ---
package types

import "time"

// Genesis contains the useful information about the genesis
type Genesis struct {
	ChainID       string
	Time          time.Time
	InitialHeight int64
}

// NewGenesis allows to build a new Genesis instance
func NewGenesis(chainID string, startTime time.Time, initialHeight int64) *Genesis {
	return &Genesis{
		ChainID:       chainID,
		Time:          startTime,
		InitialHeight: initialHeight,
	}
}

// Equal returns true iff g and other contain the same data
func (g *Genesis) Equal(other *Genesis) bool {
	return g.ChainID == other.ChainID &&
		g.Time.Equal(other.Time) &&
		g.InitialHeight == other.InitialHeight
}

// ------------------------------------------------------------------------------------------------------------------

// ConsensusEvent represents a consensus event
type ConsensusEvent struct {
	Height int64  `json:"height"`
	Round  int32  `json:"round"`
	Step   string `json:"step"`
}

// NewConsensusEvent allows to easily build a new ConsensusEvent object
func NewConsensusEvent(height int64, round int32, step string) *ConsensusEvent {
	return &ConsensusEvent{
		Height: height,
		Round:  round,
		Step:   step,
	}
}

// Equal tells whether c and other contain the same data
func (c ConsensusEvent) Equal(other ConsensusEvent) bool {
	return c.Height == other.Height &&
		c.Round == other.Round &&
		c.Step == other.Step
}

'''
'''--- types/distribution.go ---
package types

import (
	distrtypes "github.com/cosmos/cosmos-sdk/x/distribution/types"
)

// DistributionParams represents the parameters of the x/distribution module
type DistributionParams struct {
	distrtypes.Params
	Height int64
}

// NewDistributionParams allows to build a new DistributionParams instance
func NewDistributionParams(params distrtypes.Params, height int64) *DistributionParams {
	return &DistributionParams{
		Params: params,
		Height: height,
	}
}

'''
'''--- types/feegrant.go ---
package types

import feegranttypes "github.com/cosmos/cosmos-sdk/x/feegrant"

// FeeGrant represents the x/feegrant module
type FeeGrant struct {
	feegranttypes.Grant
	Height int64
}

// NewFeeGrant allows to build a new FeeGrant instance
func NewFeeGrant(feegrant feegranttypes.Grant, height int64) FeeGrant {
	return FeeGrant{
		feegrant,
		height,
	}
}

type GrantRemoval struct {
	Grantee string
	Granter string
	Height  int64
}

// NewGrantRemoval allows to build a new GrantRemoval instance
func NewGrantRemoval(grantee string, granter string, height int64) GrantRemoval {
	return GrantRemoval{
		grantee,
		granter,
		height,
	}
}

'''
'''--- types/gov.go ---
package types

import (
	"time"

	sdk "github.com/cosmos/cosmos-sdk/types"

	govtypesv1beta1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1beta1"

	govtypesv1 "github.com/cosmos/cosmos-sdk/x/gov/types/v1"
)

const (
	ProposalStatusInvalid = "PROPOSAL_STATUS_INVALID"
)

// DepositParams contains the data of the deposit parameters of the x/gov module
type DepositParams struct {
	MinDeposit       sdk.Coins `json:"min_deposit,omitempty" yaml:"min_deposit"`
	MaxDepositPeriod int64     `json:"max_deposit_period,omitempty" yaml:"max_deposit_period"`
}

// NewDepositParam allows to build a new DepositParams
func NewDepositParam(d *govtypesv1.DepositParams) DepositParams {
	return DepositParams{
		MinDeposit:       d.MinDeposit,
		MaxDepositPeriod: d.MaxDepositPeriod.Nanoseconds(),
	}
}

// NewGenesisDepositParam allows to build a new DepositParams
func NewGenesisDepositParam(d *govtypesv1beta1.DepositParams) DepositParams {
	return DepositParams{
		MinDeposit:       d.MinDeposit,
		MaxDepositPeriod: d.MaxDepositPeriod.Nanoseconds(),
	}
}

// VotingParams contains the voting parameters of the x/gov module
type VotingParams struct {
	VotingPeriod int64 `json:"voting_period,omitempty" yaml:"voting_period"`
}

// NewVotingParams allows to build a new VotingParams instance
func NewVotingParams(v *govtypesv1.VotingParams) VotingParams {
	return VotingParams{
		VotingPeriod: v.VotingPeriod.Nanoseconds(),
	}
}

// NewGenesisVotingParams allows to build a new VotingParams instance
func NewGenesisVotingParams(v *govtypesv1beta1.VotingParams) VotingParams {
	return VotingParams{
		VotingPeriod: v.VotingPeriod.Nanoseconds(),
	}
}

// GovParams contains the data of the x/gov module parameters
type GovParams struct {
	DepositParams DepositParams `json:"deposit_params" yaml:"deposit_params"`
	VotingParams  VotingParams  `json:"voting_params" yaml:"voting_params"`
	TallyParams   TallyParams   `json:"tally_params" yaml:"tally_params"`
	Height        int64         `json:"height" ymal:"height"`
}

// GenesisGovParams contains the data of the x/gov module parameters
type GenesisGovParams struct {
	DepositParams DepositParams      `json:"deposit_params" yaml:"deposit_params"`
	VotingParams  VotingParams       `json:"voting_params" yaml:"voting_params"`
	TallyParams   GenesisTallyParams `json:"tally_params" yaml:"tally_params"`
	Height        int64              `json:"height" ymal:"height"`
}

// TallyParams contains the tally parameters of the x/gov module
type TallyParams struct {
	Quorum        string `json:"quorum,omitempty"`
	Threshold     string `json:"threshold,omitempty"`
	VetoThreshold string `json:"veto_threshold,omitempty" yaml:"veto_threshold"`
}

// GenesisTallyParams contains genesis tally parameters of the x/gov module
type GenesisTallyParams struct {
	Quorum        sdk.Dec `json:"quorum,omitempty"`
	Threshold     sdk.Dec `json:"threshold,omitempty"`
	VetoThreshold sdk.Dec `json:"veto_threshold,omitempty" yaml:"veto_threshold"`
}

// NewTallyParams allows to build a new TallyParams instance
func NewTallyParams(t *govtypesv1.TallyParams) TallyParams {
	return TallyParams{
		Quorum:        t.Quorum,
		Threshold:     t.Threshold,
		VetoThreshold: t.VetoThreshold,
	}
}

// NewGenesisTallyParams allows to build a new GenesisTallyParams instance
func NewGenesisTallyParams(t *govtypesv1beta1.TallyParams) GenesisTallyParams {
	return GenesisTallyParams{
		Quorum:        t.Quorum,
		Threshold:     t.Threshold,
		VetoThreshold: t.VetoThreshold,
	}
}

// NewGovParams allows to build a new GovParams instance
func NewGovParams(votingParams VotingParams, depositParams DepositParams, tallyParams TallyParams, height int64) *GovParams {
	return &GovParams{
		DepositParams: depositParams,
		VotingParams:  votingParams,
		TallyParams:   tallyParams,
		Height:        height,
	}
}

// NewGenesisGovParams allows to build a new GenesisGovParams instance
func NewGenesisGovParams(votingParams VotingParams, depositParams DepositParams, tallyParams GenesisTallyParams, height int64) *GenesisGovParams {
	return &GenesisGovParams{
		DepositParams: depositParams,
		VotingParams:  votingParams,
		TallyParams:   tallyParams,
		Height:        height,
	}
}

// --------------------------------------------------------------------------------------------------------------------

// Proposal represents a single governance proposal
type Proposal struct {
	ProposalRoute   string
	ProposalType    string
	ProposalID      uint64
	Content         govtypesv1beta1.Content
	Status          string
	SubmitTime      time.Time
	DepositEndTime  time.Time
	VotingStartTime time.Time
	VotingEndTime   time.Time
	Proposer        string
}

// NewProposal return a new Proposal instance
func NewProposal(
	proposalID uint64,
	proposalRoute string,
	proposalType string,
	content govtypesv1beta1.Content,
	status string,
	submitTime time.Time,
	depositEndTime time.Time,
	votingStartTime time.Time,
	votingEndTime time.Time,
	proposer string,
) Proposal {
	return Proposal{
		Content:         content,
		ProposalRoute:   proposalRoute,
		ProposalType:    proposalType,
		ProposalID:      proposalID,
		Status:          status,
		SubmitTime:      submitTime,
		DepositEndTime:  depositEndTime,
		VotingStartTime: votingStartTime,
		VotingEndTime:   votingEndTime,
		Proposer:        proposer,
	}
}

// Equal tells whether p and other contain the same data
func (p Proposal) Equal(other Proposal) bool {
	return p.ProposalRoute == other.ProposalRoute &&
		p.ProposalType == other.ProposalType &&
		p.ProposalID == other.ProposalID &&
		p.Content.String() == other.Content.String() &&
		p.Status == other.Status &&
		p.SubmitTime.Equal(other.SubmitTime) &&
		p.DepositEndTime.Equal(other.DepositEndTime) &&
		p.VotingStartTime.Equal(other.VotingStartTime) &&
		p.VotingEndTime.Equal(other.VotingEndTime) &&
		p.Proposer == other.Proposer
}

// ProposalUpdate contains the data that should be used when updating a governance proposal
type ProposalUpdate struct {
	ProposalID      uint64
	Status          string
	VotingStartTime time.Time
	VotingEndTime   time.Time
}

// NewProposalUpdate allows to build a new ProposalUpdate instance
func NewProposalUpdate(
	proposalID uint64, status string, votingStartTime, votingEndTime time.Time,
) ProposalUpdate {
	return ProposalUpdate{
		ProposalID:      proposalID,
		Status:          status,
		VotingStartTime: votingStartTime,
		VotingEndTime:   votingEndTime,
	}
}

// -------------------------------------------------------------------------------------------------------------------

// Deposit contains the data of a single deposit made towards a proposal
type Deposit struct {
	ProposalID uint64
	Depositor  string
	Amount     sdk.Coins
	Timestamp  time.Time
	Height     int64
}

// NewDeposit return a new Deposit instance
func NewDeposit(
	proposalID uint64,
	depositor string,
	amount sdk.Coins,
	timestamp time.Time,
	height int64,
) Deposit {
	return Deposit{
		ProposalID: proposalID,
		Depositor:  depositor,
		Amount:     amount,
		Timestamp:  timestamp,
		Height:     height,
	}
}

// -------------------------------------------------------------------------------------------------------------------

// Vote contains the data of a single proposal vote
type Vote struct {
	ProposalID uint64
	Voter      string
	Option     govtypesv1.VoteOption
	Timestamp  time.Time
	Height     int64
}

// NewVote return a new Vote instance
func NewVote(
	proposalID uint64,
	voter string,
	option govtypesv1.VoteOption,
	timestamp time.Time,
	height int64,
) Vote {
	return Vote{
		ProposalID: proposalID,
		Voter:      voter,
		Option:     option,
		Timestamp:  timestamp,
		Height:     height,
	}
}

// -------------------------------------------------------------------------------------------------------------------

// TallyResult contains the data about the final results of a proposal
type TallyResult struct {
	ProposalID uint64
	Yes        string
	Abstain    string
	No         string
	NoWithVeto string
	Height     int64
}

// NewTallyResult return a new TallyResult instance
func NewTallyResult(
	proposalID uint64,
	yes string,
	abstain string,
	no string,
	noWithVeto string,
	height int64,
) TallyResult {
	return TallyResult{
		ProposalID: proposalID,
		Yes:        yes,
		Abstain:    abstain,
		No:         no,
		NoWithVeto: noWithVeto,
		Height:     height,
	}
}

// -------------------------------------------------------------------------------------------------------------------

// ProposalStakingPoolSnapshot contains the data about a single staking pool snapshot to be associated with a proposal
type ProposalStakingPoolSnapshot struct {
	ProposalID uint64
	Pool       *PoolSnapshot
}

// NewProposalStakingPoolSnapshot returns a new ProposalStakingPoolSnapshot instance
func NewProposalStakingPoolSnapshot(proposalID uint64, pool *PoolSnapshot) ProposalStakingPoolSnapshot {
	return ProposalStakingPoolSnapshot{
		ProposalID: proposalID,
		Pool:       pool,
	}
}

// -------------------------------------------------------------------------------------------------------------------

// ProposalValidatorStatusSnapshot represents a single snapshot of the status of a validator associated
// with a single proposal
type ProposalValidatorStatusSnapshot struct {
	ProposalID           uint64
	ValidatorConsAddress string
	ValidatorVotingPower int64
	ValidatorStatus      int
	ValidatorJailed      bool
	Height               int64
}

// NewProposalValidatorStatusSnapshot returns a new ProposalValidatorStatusSnapshot instance
func NewProposalValidatorStatusSnapshot(
	proposalID uint64,
	validatorConsAddr string,
	validatorVotingPower int64,
	validatorStatus int,
	validatorJailed bool,
	height int64,
) ProposalValidatorStatusSnapshot {
	return ProposalValidatorStatusSnapshot{
		ProposalID:           proposalID,
		ValidatorStatus:      validatorStatus,
		ValidatorConsAddress: validatorConsAddr,
		ValidatorVotingPower: validatorVotingPower,
		ValidatorJailed:      validatorJailed,
		Height:               height,
	}
}

'''
'''--- types/mint.go ---
package types

import minttypes "github.com/cosmos/cosmos-sdk/x/mint/types"

// MintParams represents the x/mint parameters
type MintParams struct {
	minttypes.Params
	Height int64
}

// NewMintParams allows to build a new MintParams instance
func NewMintParams(params minttypes.Params, height int64) *MintParams {
	return &MintParams{
		Params: params,
		Height: height,
	}
}

'''
'''--- types/pricefeed.go ---
package types

import "time"

// Token represents a valid token inside the chain
type Token struct {
	Name  string      `yaml:"name"`
	Units []TokenUnit `yaml:"units"`
}

func NewToken(name string, units []TokenUnit) Token {
	return Token{
		Name:  name,
		Units: units,
	}
}

// TokenUnit represents a unit of a token
type TokenUnit struct {
	Denom    string   `yaml:"denom"`
	Exponent int      `yaml:"exponent"`
	Aliases  []string `yaml:"aliases,omitempty"`
	PriceID  string   `yaml:"price_id,omitempty"`
}

func NewTokenUnit(denom string, exponent int, aliases []string, priceID string) TokenUnit {
	return TokenUnit{
		Denom:    denom,
		Exponent: exponent,
		Aliases:  aliases,
		PriceID:  priceID,
	}
}

// TokenPrice represents the price at a given moment in time of a token unit
type TokenPrice struct {
	UnitName  string
	Price     float64
	MarketCap int64
	Timestamp time.Time
}

// NewTokenPrice returns a new TokenPrice instance containing the given data
func NewTokenPrice(unitName string, price float64, marketCap int64, timestamp time.Time) TokenPrice {
	return TokenPrice{
		UnitName:  unitName,
		Price:     price,
		MarketCap: marketCap,
		Timestamp: timestamp,
	}
}

'''
'''--- types/slashing.go ---
package types

import (
	"time"

	slashingtypes "github.com/cosmos/cosmos-sdk/x/slashing/types"
)

// ValidatorSigningInfo contains the signing info of a validator at a given height
type ValidatorSigningInfo struct {
	ValidatorAddress    string
	StartHeight         int64
	IndexOffset         int64
	JailedUntil         time.Time
	Tombstoned          bool
	MissedBlocksCounter int64
	Height              int64
}

// Equal tells whether v and w represent the same rows
func (v ValidatorSigningInfo) Equal(w ValidatorSigningInfo) bool {
	return v.ValidatorAddress == w.ValidatorAddress &&
		v.StartHeight == w.StartHeight &&
		v.IndexOffset == w.IndexOffset &&
		v.JailedUntil.Equal(w.JailedUntil) &&
		v.Tombstoned == w.Tombstoned &&
		v.MissedBlocksCounter == w.MissedBlocksCounter &&
		v.Height == w.Height
}

// ValidatorSigningInfo allows to build a new ValidatorSigningInfo
func NewValidatorSigningInfo(
	validatorAddress string,
	startHeight int64,
	indexOffset int64,
	jailedUntil time.Time,
	tombstoned bool,
	missedBlocksCounter int64,
	height int64,
) ValidatorSigningInfo {
	return ValidatorSigningInfo{
		ValidatorAddress:    validatorAddress,
		StartHeight:         startHeight,
		IndexOffset:         indexOffset,
		JailedUntil:         jailedUntil,
		Tombstoned:          tombstoned,
		MissedBlocksCounter: missedBlocksCounter,
		Height:              height,
	}
}

// --------------------------------------------------------------------------------------------------------------------

// SlashingParams represents the parameters of the slashing module at a given height
type SlashingParams struct {
	slashingtypes.Params
	Height int64
}

// NewSlashingParams allows to build a new SlashingParams instance
func NewSlashingParams(params slashingtypes.Params, height int64) *SlashingParams {
	return &SlashingParams{
		Params: params,
		Height: height,
	}
}

'''
'''--- types/staking_double_vote.go ---
package types

// DoubleSignEvidence represent a double sign evidence on each tendermint block
type DoubleSignEvidence struct {
	VoteA  DoubleSignVote
	VoteB  DoubleSignVote
	Height int64
}

// NewDoubleSignEvidence return a new DoubleSignEvidence object
func NewDoubleSignEvidence(height int64, voteA DoubleSignVote, voteB DoubleSignVote) DoubleSignEvidence {
	return DoubleSignEvidence{
		VoteA:  voteA,
		VoteB:  voteB,
		Height: height,
	}
}

// DoubleSignVote represents a double vote which is included inside a DoubleSignEvidence
type DoubleSignVote struct {
	BlockID          string
	ValidatorAddress string
	Signature        string
	Type             int
	Height           int64
	Round            int32
	ValidatorIndex   int32
}

// NewDoubleSignVote allows to create a new DoubleSignVote instance
func NewDoubleSignVote(
	roundType int,
	height int64,
	round int32,
	blockID string,
	validatorAddress string,
	validatorIndex int32,
	signature string,
) DoubleSignVote {
	return DoubleSignVote{
		Type:             roundType,
		Height:           height,
		Round:            round,
		BlockID:          blockID,
		ValidatorAddress: validatorAddress,
		ValidatorIndex:   validatorIndex,
		Signature:        signature,
	}
}

'''
'''--- types/staking_pool_params.go ---
package types

import (
	sdkmath "cosmossdk.io/math"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
)

// Pool contains the data of the staking pool at the given height
type Pool struct {
	BondedTokens          sdkmath.Int
	NotBondedTokens       sdkmath.Int
	UnbondingTokens       sdkmath.Int
	StakedNotBondedTokens sdkmath.Int
	Height                int64
}

// NewPool allows to build a new Pool instance
func NewPool(bondedTokens, notBondedTokens, unbondingTokens, stakedNotBondedTokens sdkmath.Int, height int64) *Pool {
	return &Pool{
		BondedTokens:          bondedTokens,
		NotBondedTokens:       notBondedTokens,
		UnbondingTokens:       unbondingTokens,
		StakedNotBondedTokens: stakedNotBondedTokens,
		Height:                height,
	}
}

// PoolSnapshot contains the data of the staking pool snapshot at the given height
type PoolSnapshot struct {
	BondedTokens    sdkmath.Int
	NotBondedTokens sdkmath.Int
	Height          int64
}

// NewPoolSnapshot allows to build a new PoolSnapshot instance
func NewPoolSnapshot(bondedTokens, notBondedTokens sdkmath.Int, height int64) *PoolSnapshot {
	return &PoolSnapshot{
		BondedTokens:    bondedTokens,
		NotBondedTokens: notBondedTokens,
		Height:          height,
	}
}

// --------------------------------------------------------------------------------------------------------------------

// StakingParams represents the parameters of the x/staking module
type StakingParams struct {
	stakingtypes.Params
	Height int64
}

// NewStakingParams returns a new StakingParams instance
func NewStakingParams(params stakingtypes.Params, height int64) StakingParams {
	return StakingParams{
		Params: params,
		Height: height,
	}
}

'''
'''--- types/staking_validator.go ---
package types

import (
	sdk "github.com/cosmos/cosmos-sdk/types"
	stakingtypes "github.com/cosmos/cosmos-sdk/x/staking/types"
)

// Validator represents a single validator.
// This is defined as an interface so that we can use the SDK types
// as well as database types properly.
type Validator interface {
	GetConsAddr() string
	GetConsPubKey() string
	GetOperator() string
	GetSelfDelegateAddress() string
	GetMaxChangeRate() *sdk.Dec
	GetMaxRate() *sdk.Dec
	GetHeight() int64
}

// validator allows to easily implement the Validator interface
type validator struct {
	ConsensusAddr       string
	ConsPubKey          string
	OperatorAddr        string
	SelfDelegateAddress string
	MaxChangeRate       *sdk.Dec
	MaxRate             *sdk.Dec
	Height              int64
}

// NewValidator allows to build a new Validator implementation having the given data
func NewValidator(
	consAddr string, opAddr string, consPubKey string,
	selfDelegateAddress string, maxChangeRate *sdk.Dec,
	maxRate *sdk.Dec, height int64,
) Validator {
	return validator{
		ConsensusAddr:       consAddr,
		ConsPubKey:          consPubKey,
		OperatorAddr:        opAddr,
		SelfDelegateAddress: selfDelegateAddress,
		MaxChangeRate:       maxChangeRate,
		MaxRate:             maxRate,
		Height:              height,
	}
}

// GetConsAddr implements the Validator interface
func (v validator) GetConsAddr() string {
	return v.ConsensusAddr
}

// GetConsPubKey implements the Validator interface
func (v validator) GetConsPubKey() string {
	return v.ConsPubKey
}

func (v validator) GetOperator() string {
	return v.OperatorAddr
}

func (v validator) GetSelfDelegateAddress() string {
	return v.SelfDelegateAddress
}

func (v validator) GetMaxChangeRate() *sdk.Dec {
	return v.MaxChangeRate
}

func (v validator) GetMaxRate() *sdk.Dec {
	return v.MaxRate
}

func (v validator) GetHeight() int64 {
	return v.Height
}

// --------------------------------------------------------------------------------------------------------------------

// ValidatorDescription contains the description of a validator
// and timestamp do the description get changed
type ValidatorDescription struct {
	OperatorAddress string
	Description     stakingtypes.Description
	AvatarURL       string // URL of the avatar to be used. Will be [do-no-modify] if it shouldn't be edited
	Height          int64
}

// NewValidatorDescription return a new ValidatorDescription object
func NewValidatorDescription(
	opAddr string, description stakingtypes.Description, avatarURL string, height int64,
) ValidatorDescription {
	return ValidatorDescription{
		OperatorAddress: opAddr,
		Description:     description,
		AvatarURL:       avatarURL,
		Height:          height,
	}
}

// ----------------------------------------------------------------------------------------------------------

// ValidatorCommission contains the data of a validator commission at a given height
type ValidatorCommission struct {
	ValAddress        string
	Commission        *sdk.Dec
	MinSelfDelegation *sdk.Int
	Height            int64
}

// NewValidatorCommission return a new validator commission instance
func NewValidatorCommission(
	valAddress string, rate *sdk.Dec, minSelfDelegation *sdk.Int, height int64,
) ValidatorCommission {
	return ValidatorCommission{
		ValAddress:        valAddress,
		Commission:        rate,
		MinSelfDelegation: minSelfDelegation,
		Height:            height,
	}
}

//--------------------------------------------

// ValidatorVotingPower represents the voting power of a validator at a specific block height
type ValidatorVotingPower struct {
	ConsensusAddress string
	VotingPower      int64
	Height           int64
}

// NewValidatorVotingPower creates a new ValidatorVotingPower
func NewValidatorVotingPower(address string, votingPower int64, height int64) ValidatorVotingPower {
	return ValidatorVotingPower{
		ConsensusAddress: address,
		VotingPower:      votingPower,
		Height:           height,
	}
}

//--------------------------------------------------------

// ValidatorStatus represents the current state for the specified validator at the specific height
type ValidatorStatus struct {
	ConsensusAddress string
	ConsensusPubKey  string
	Status           int
	Jailed           bool
	Height           int64
}

// NewValidatorStatus creates a new ValidatorVotingPower
func NewValidatorStatus(valConsAddr, pubKey string, status int, jailed bool, height int64) ValidatorStatus {
	return ValidatorStatus{
		ConsensusAddress: valConsAddr,
		ConsensusPubKey:  pubKey,
		Status:           status,
		Jailed:           jailed,
		Height:           height,
	}
}

//---------------------------------------------------------------

'''
'''--- utils/genesis.go ---
package utils

import (
	"fmt"

	tmjson "github.com/cometbft/cometbft/libs/json"
	tmos "github.com/cometbft/cometbft/libs/os"
	tmtypes "github.com/cometbft/cometbft/types"
	"github.com/forbole/juno/v5/node"
	"github.com/forbole/juno/v5/types/config"
)

// ReadGenesis reads the genesis data based on the given config
func ReadGenesis(config config.Config, node node.Node) (*tmtypes.GenesisDoc, error) {
	if config.Parser.GenesisFilePath != "" {
		return readGenesisFromFilePath(config.Parser.GenesisFilePath)
	}

	return readGenesisFromNode(node)
}

func readGenesisFromFilePath(path string) (*tmtypes.GenesisDoc, error) {
	bz, err := tmos.ReadFile(path)
	if err != nil {
		return nil, fmt.Errorf("failed to read genesis file: %s", err)
	}

	var genDoc tmtypes.GenesisDoc
	err = tmjson.Unmarshal(bz, &genDoc)
	if err != nil {
		return nil, fmt.Errorf("failed to unmarshal genesis doc: %s", err)
	}

	return &genDoc, nil
}

func readGenesisFromNode(node node.Node) (*tmtypes.GenesisDoc, error) {
	response, err := node.Genesis()
	if err != nil {
		return nil, fmt.Errorf("failed to get genesis: %s", err)
	}

	return response.Genesis, nil
}

'''
'''--- utils/node.go ---
package utils

import (
	"fmt"

	coretypes "github.com/cometbft/cometbft/rpc/core/types"
	"github.com/forbole/juno/v5/node"
)

// QueryTxs queries all the transactions from the given node corresponding to the given query
func QueryTxs(node node.Node, query string) ([]*coretypes.ResultTx, error) {
	var txs []*coretypes.ResultTx

	var page = 1
	var perPage = 100
	var stop = false
	for !stop {
		result, err := node.TxSearch(query, &page, &perPage, "")
		if err != nil {
			return nil, fmt.Errorf("error while running tx search: %s", err)
		}

		page++
		txs = append(txs, result.Txs...)
		stop = len(txs) == result.TotalCount
	}

	return txs, nil
}

'''
'''--- utils/utils.go ---
package utils

import (
	"context"
	"strconv"

	grpctypes "github.com/cosmos/cosmos-sdk/types/grpc"
	"google.golang.org/grpc/metadata"
)

// RemoveDuplicateValues removes the duplicated values from the given slice
func RemoveDuplicateValues(slice []string) []string {
	keys := make(map[string]bool)
	var list []string

	for _, entry := range slice {
		if _, value := keys[entry]; !value {
			keys[entry] = true
			list = append(list, entry)
		}
	}
	return list
}

// GetHeightRequestContext adds the height to the context for queries
func GetHeightRequestContext(context context.Context, height int64) context.Context {
	return metadata.AppendToOutgoingContext(
		context,
		grpctypes.GRPCBlockHeightHeader,
		strconv.FormatInt(height, 10),
	)
}

'''