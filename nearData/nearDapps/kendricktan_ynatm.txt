*GitHub Repository "kendricktan/ynatm"*

'''--- .circleci/check_npm_version.sh ---
#!/bin/bash

set -o verbose
set -v

# https://stackoverflow.com/a/29394504/4634583
# Compare semvar easily (this support 3 fields at most)
function ver { printf "%03d%03d%03d" $(echo "$1" | tr '.' ' '); }

PUBLISHED_PACKAGE_VER=$(npm view ynatm version)
CURRENT_PACKAGE_VER=$(node -p "require('./package.json').version")

if [[ $((10#$(ver $CURRENT_PACKAGE_VER))) -le $((10#$(ver $PUBLISHED_PACKAGE_VER))) ]]; then
  echo "Invalid package version"
  exit 1
fi
'''
'''--- .circleci/config.yml ---
version: 2
jobs:
  test:
    docker:
      - image: circleci/node:12.16.1
      - image: ethereum/client-go:v1.9.14
        entrypoint: /bin/sh
        command: -c "yes '' | geth --dev --dev.period 15 --http --http.addr '0.0.0.0' --http.port 8545 --http.api 'eth,net,web3,account,admin,personal' --unlock '0' --allow-insecure-unlock"
    steps:
      - checkout
      - run: |
          yarn install
          yarn test

  publishDryRun:
    docker:
      - image: circleci/node:lts
    steps:
      - checkout
      - run:
          name: Check Package Version Valid on NPM
          command: ./.circleci/check_npm_version.sh

  publish:
    docker:
      - image: circleci/node:lts
    steps:
      - checkout
      - run:
          name: Authenticate with registry
          command: echo "//registry.npmjs.org/:_authToken=$npm_TOKEN" > ~/.npmrc
      - run:
          name: Publish package
          command: |
            # Sometimes we just wanna update the readme file
            if ./.circleci/check_npm_version.sh; then
                npm publish --ignore-scripts --access public
            fi

workflows:
  version: 2
  test-publish:
    jobs:
      - test
      - publishDryRun:
          requires:
            - test
          filters:
            branches:
              ignore:
                - master
      - publish:
          requires:
            - test
          filters:
            branches:
              only:
                - master

'''
'''--- README.md ---
# You Need A Transaction Manager (YNATM)

[![circleci](https://badgen.net/circleci/github/kendricktan/ynatm)](https://app.circleci.com/pipelines/github/kendricktan/ynatm)
[![npm](https://badgen.net/npm/v/ynatm)](https://www.npmjs.com/package/ynatm)

**(For Ethereum)**

With the recent spike in gas prices, you can't just send a 1 GWEI gas price for your Ethereum tx and hope that it will get mined.

This small module helps you guarantee that your transaction gets mined within a reasonable time frame, by bumping up the gas price (up till a threshold) until your transaction gets mined.

## Examples

### Quickstart

```bash
npm install ynatm
```

```javascript
const ynatm = require("ynatm");

const nonce = provider.getTransactionCount(SENDER_ADDRESS);

const txOptions = {
  from: SENDER_ADDRESS,
  to: RECIPIENT_ADDRESS,
  nonce
}

const tx = await ynatm.send({
  sendTransactionFunction: (gasPrice) =>
    wallet.sendTransaction({ ...txOptions, gasPrice }),
  minGasPrice: ynatm.toGwei(1),
  maxGasPrice: ynatm.toGwei(20),
  gasPriceScalingFunction: ynatm.LINEAR(5), // Scales by 5 GWEI in gasPrice between each try
  delay: 15000, // Waits 15 second between each try
});
```

### Contract Interaction

Since `ynatm` is framework agnostic, you can also use it for contract interaction like so:

```javascript
const ynatm = require("ynatm");

const nonce = provider.getTransactionCount(SENDER_ADDRESS);
const options = {
  from: SENDER_ADDRESS,
  nonce,
}

const ethersSendContractFunction = (gasPrice) => {
  const tx = MyContract.functionName(params, { ...options, gasPrice });
  const txRecp = await tx.wait(1); // wait for 1 confirmations
  return txRecp;
};

const web3SendContractFunction = (gasPrice) => {
  // Web3 by default waits for the receipt
  return MyContract.methods.functionName(params).send({ ...options, gasPrice });
};

const tx = await ynatm.send({
  sendTransactionFunction: ethersSendContractFunction, // or web3SendContractFunction
  minGasPrice: ynatm.toGwei(1),
  maxGasPrice: ynatm.toGwei(20),
  gasPriceScalingFunction: ynatm.LINEAR(5), // Scales by 5 GWEI in gasPrice between each try
  delay: 15000, // Waits 15 second between each try
});
```

### Custom `gasPriceScalingFunction`

You can define your own `gasPriceScalingFunction`, which takes in a destructured object containing the following keys:
- `x`: X'th number of try
- `y`: Current gasPrice
- `c`: Constant, `minGasPrice`

```javascript
const customGasScalingFunction = ({ x, y, c }) => {
  return ...
}
```

### Immediate Error Handling with `rejectImmediatelyOnCondition`

The expected behavior when the transaction manager hits an error is to:

1. Check if the error meets the condition specified in `rejectImmediatelyOnCondition` (Defaults to checking for reverts)
   - If the condition is met, all future transactions are cancelled the the promise is rejected
2. Checks to see if all the transactions have failed
   - If all transactions have failed, reject the last error
3. Keep trying

That means that if you're queued up 5 invalid transactions, all 5 of them will need to fail before you can thrown an error.

If you'd like to speed up the process and immediately throw an error when the first invalid transaction is thrown matches a certain criteria, you can do so by overriding the `rejectImmediatelyOnCondition` like so:

```javascript
const ynatm = require("ynatm");

const rejectOnTheseMessages = (err) => {
  const errMsg = err.toString().toLowerCase();

  const conditions = ["revert", "gas", "nonce", "invalid"];

  for (const i of conditions) {
    if (errMsg.includes(i)) {
      return true;
    }
  }

  return false;
};

const nonce = await provider.getTransactionCount(SENDER_ADDRESS);

const tx = {
  from: SENDER_ADDRESS,
  to: RECIPIENT_ADDRESS,
  nonce,
  data: '0x'
}

await ynatm.send({
  sendTransactionFunction: (gasPrice) => wallet.sendTransaction({ ...tx, gasPrice }),
  minGasPrice: ynatm.toGwei(1),
  maxGasPrice: ynatm.toGwei(20),
  gasPriceScalingFunction: ynatm.LINEAR(5),
  delay: 15000,
  rejectImmediatelyOnCondition: rejectOnTheseMessages,
});
```

## Testing

```bash
# Terminal 1
yes '' | geth --dev --dev.period 15 --http --http.addr '0.0.0.0' --http.port 8545 --http.api 'eth,net,web3,account,admin,personal' --unlock '0' --allow-insecure-unlock

# Terminal 2
yarn test
```

If you don't have `geth` installed locally, you can also use `docker`

```bash
# Terminal 1
docker run -p 127.0.0.1:8545:8545/tcp --entrypoint /bin/sh ethereum/client-go:v1.9.14 -c "yes '' | geth --dev --dev.period 15 --http --http.addr '0.0.0.0' --http.port 8545 --http.api 'eth,net,web3,account,admin,personal' --unlock '0' --allow-insecure-unlock"

# Terminal 2
yarn test
```

'''
'''--- index.js ---
const Promise = require("bluebird");

// GWEI = 1e9
const GWEI = Math.pow(10, 9);
const MAX_INT32 = ~(1 << 31)

const toGwei = (x) => x * GWEI;

const EXPONENTIAL = (base = 2, inGwei = true) => ({ x }) => {
  let p = Math.pow(base, x);
  if (inGwei) {
    p = toGwei(p);
  }
  return x + p;
};

const LINEAR = (slope = 1, inGwei = true) => ({ x, c }) => {
  let p = slope * x;
  if (inGwei) {
    p = toGwei(p);
  }
  return c + p;
};

const DOUBLES = ({ y }) => {
  return y * 2;
};

// The default behaviour of an overflow of the timeout value
// passed to `setTimeout` will result it being set to 1.
const sanitizeTimeout = (timeout) => {
  if (timeout > MAX_INT32) {
    console.log(
      `WARNING: Timeout larger than max supported timeout size.
                    ${timeout} set to ${MAX_INT32}.
          `
    );
    return MAX_INT32;
  }
  return timeout;
}

// Returns a list of gasPrices, based on the scaling function
const getGasPriceVariations = ({
  minGasPrice,
  maxGasPrice,
  gasPriceScalingFunction,
}) => {
  // Calculates a sequence of gasPrices
  let i = 0;
  let curGasPrice = minGasPrice;
  let gasPrices = [];

  // Warning for the user on their gasPrice if their first
  // Increment is < 1e-6 (because of the GWEI conversion)
  const firstGasPriceDelta =
    gasPriceScalingFunction(minGasPrice, 1) - minGasPrice;
  if (firstGasPriceDelta / minGasPrice < 1e-6) {
    console.log(
      `WARNING: GasPrice is scaling very slowly. Might take a while.
                Double check the supplied gasPriceScalingFunction.
                If you're using a custom function, make sure to use toGwei.
      `
    );
  }

  for (;;) {
    if (curGasPrice > maxGasPrice) break;
    gasPrices = gasPrices.concat(curGasPrice);
    curGasPrice = gasPriceScalingFunction({
      y: curGasPrice,
      x: ++i,
      c: minGasPrice,
    });
  }

  return gasPrices;
};

// Immediately rejects the promise if it contains the "revert" keyword
const rejectOnRevert = (e) => {
  return e.toString().toLowerCase().includes("revert");
};

/**
 * Gradually keeps trying a transaction with an incremental amount of gas
 * while keeping the same nonce.
 *
 * @param {Function} sendTransactionFunction:
 *   Function that accepts a gasPrice, and uses that gasPrice to send another tx
 *   e.g. (gasPrice) => wallet.sendTranscation({ ...tx, gasPrice })
 *        (gasPrice) => web3.eth.sendTransaction(tx, { from: sender, gasPrice })
 * @param {number} minGasPrice:
 *   Minimum gasPrice to start with
 * @param {number} masGasPrice:
 *   Maximum allowed gasPrice
 * @param {number} delay:
 *   Delay before retrying transaction with a higher gasPrice (ms)
 * @param {Function} rejectImmediatelyOnCondition:
 *   If an error occurs and matches some condition. Throws the error immediately
 *   and stops attempting to retry the proceeding transactions.
 *   By default, it'll stop immediately stop if the error contains the string "revert"
 */
const send = async ({
  sendTransactionFunction,
  minGasPrice,
  maxGasPrice,
  gasPriceScalingFunction = LINEAR(5),
  delay = 60000,
  rejectImmediatelyOnCondition = rejectOnRevert,
}) => {
  // Make sure its an int
  minGasPrice = parseInt(minGasPrice);

  // Defaults to 2x minGasPrice
  if (!maxGasPrice) {
    maxGasPrice = 2 * minGasPrice;
  } else {
    maxGasPrice = parseInt(maxGasPrice);
  }

  // List of varying gasPrices
  const gasPrices = getGasPriceVariations({
    minGasPrice,
    maxGasPrice,
    gasPriceScalingFunction,
  });

  const promise = new Promise((resolve, reject) => {
    // List of timeout Ids
    let timeoutIds = [];
    let failedTxs = [];

    // After waiting (N + 1) * delay seconds, throw an error
    const finalTimeoutId = setTimeout(() => {
      reject(new Error("Transaction taking too long!"));
    }, sanitizeTimeout((gasPrices.length + 1) * delay));
    timeoutIds.push(finalTimeoutId);

    // For each signed transactions
    for (const [i, gasPrice] of gasPrices.entries()) {
      // Async function to wait for transaction
      const waitForTx = async () => {
        try {
          const tx = await sendTransactionFunction(gasPrice);

          // Clear other timeouts
          for (const tid of timeoutIds) {
            clearTimeout(tid);
          }

          resolve(tx);
        } catch (e) {
          failedTxs.push(e);

          // Reject if either we have retried all possible gasPrices
          // Or if some condition is met
          if (
            failedTxs.length >= gasPrices.length ||
            rejectImmediatelyOnCondition(e)
          ) {
            for (const tid of timeoutIds) {
              clearTimeout(tid);
            }
            reject(e);
          }
        }
      };

      // Attempt to send the signed transaction after <x> delay
      const timeoutId = setTimeout(waitForTx, sanitizeTimeout(i * delay));
      timeoutIds.push(timeoutId);
    }
  });

  return promise;
};

module.exports = {
  send,
  toGwei,
  EXPONENTIAL,
  LINEAR,
  DOUBLES,
};

'''
'''--- package.json ---
{
  "name": "ynatm",
  "version": "0.2.2",
  "description": "You Need A Transaction Manager (YNATM)",
  "main": "index.js",
  "repository": "git@github.com:kendricktan/ynatm.git",
  "author": "Kendrick Tan <kendricktan0814@gmail.com>",
  "license": "MIT",
  "scripts": {
    "test": "jest tests --forceExit"
  },
  "dependencies": {
    "bluebird": "^3.7.2"
  },
  "devDependencies": {
    "eslint": "^7.5.0",
    "eslint-plugin-jest": "^23.19.0",
    "ethers": "^5.0.7",
    "jest": "^26.1.0",
    "jest-serial-runner": "^1.1.0",
    "web3": "^1.2.11"
  },
  "eslintConfig": {
    "plugins": [
      "jest"
    ],
    "extends": [
      "eslint:recommended"
    ],
    "parserOptions": {
      "ecmaVersion": 2018
    },
    "env": {
      "es6": true,
      "node": true,
      "jest/globals": true
    }
  },
  "jest": {
    "testEnvironment": "node",
    "testTimeout": 120000,
    "runner": "jest-serial-runner"
  }
}

'''
'''--- tests/common.js ---
const expectGtBN = (aBN, bBN) => {
  if (!aBN.gt(bBN)) {
    throw new Error(
      `Expected ${aBN.toString()} to be greater than ${bBN.toString()}`
    );
  }
};

const expectEqBN = (aBN, bBN) => {
  if (!aBN.eq(bBN)) {
    throw new Error(
      `Expected ${aBN.toString()} to be equal to ${bBN.toString()}`
    );
  }
};

const sleep = (ms) => {
  return new Promise((resolve) => setTimeout(resolve, ms));
};

module.exports = {
  PROVIDER_URL: "http://localhost:8545",
  expectEqBN,
  expectGtBN,
  sleep,
};

'''
'''--- tests/contracts/StateMachine.json ---
{
  "abi": [
    {
      "inputs": [],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "uint256",
          "name": "_state",
          "type": "uint256"
        }
      ],
      "name": "setState",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "function"
    },
    {
      "inputs": [],
      "name": "state",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "bytecode": "60806040526000805534801561001457600080fd5b5060e1806100236000396000f3fe6080604052348015600f57600080fd5b506004361060325760003560e01c8063a9e966b7146037578063c19d93fb146076575b600080fd5b606060048036036020811015604b57600080fd5b81019080803590602001909291905050506092565b6040518082815260200191505060405180910390f35b607c60a5565b6040518082815260200191505060405180910390f35b6000816000819055506000549050919050565b6000548156fea2646970667358221220757673c1d5f467e16d5ed6b417d980eb1bb164ed63c156aa8aa5a3c6d883484f64736f6c63430006060033"
}
'''
'''--- tests/ethers.test.js ---
const ynatm = require("..");
const ethers = require("ethers");

const { expectGtBN, expectEqBN, PROVIDER_URL } = require("./common");
const { abi, bytecode } = require("./contracts/StateMachine.json");

const provider = new ethers.providers.JsonRpcProvider(PROVIDER_URL);
const signer = provider.getSigner();

let signerAddress;
let StateMachine;

beforeAll(async function () {
  // Gets signer address
  signerAddress = await signer.getAddress();

  // Deploys the token contract and gets related interface
  const Factory = new ethers.ContractFactory(abi, bytecode, signer);
  StateMachine = await Factory.deploy();
  const { transactionHash } = await StateMachine.deployTransaction.wait();

  // Waits for 2 confirmations
  await provider.waitForTransaction(transactionHash, 1, 120000);
});

test("simple override", async function () {
  const nonce = await provider.getTransactionCount(signerAddress);
  const initialGasPrice = ynatm.toGwei(1);

  const transaction = {
    from: signerAddress,
    to: signerAddress,
    data: "0x",
    nonce,
    gasLimit: 21000,
    gasPrice: initialGasPrice,
  };

  // Ignore if transaction fails
  signer.sendTransaction(transaction).catch(() => {});

  // Send a bunch of transactions to override and overprice previous tx
  const tx = await ynatm.send({
    sendTransactionFunction: (gasPrice) =>
      signer.sendTransaction({ ...transaction, gasPrice }),
    minGasPrice: initialGasPrice + ynatm.toGwei(1),
    maxGasPrice: ynatm.toGwei(50),
    gasPriceScalingFunction: ynatm.LINEAR(1),
    delay: 1000,
  });
  const { transactionHash } = await tx.wait();

  await provider.waitForTransaction(transactionHash, 1, 120000);

  const { gasPrice } = await provider.getTransaction(transactionHash);

  // Make sure the final gasPrice is > minGasPrice
  expectGtBN(gasPrice, ethers.BigNumber.from(initialGasPrice));
});

test("contract data override", async function () {
  const nonce = await provider.getTransactionCount(signerAddress);

  const initialGasPrice = ynatm.toGwei(1);
  const initialState = ethers.utils.parseEther("10");
  const overrideState = ethers.utils.parseEther("100");

  const options = {
    from: signerAddress,
    nonce,
    gasLimit: 100000,
    gasPrice: initialGasPrice,
  };

  // Ignore if transaction fails
  StateMachine.setState(initialState, options).catch(() => {});

  const tx = await ynatm.send({
    sendTransactionFunction: (gasPrice) =>
      StateMachine.setState(overrideState, { ...options, gasPrice }),
    minGasPrice: initialGasPrice + ynatm.toGwei(1),
    maxGasPrice: ynatm.toGwei(50),
    gasPriceScalingFunction: ynatm.LINEAR(1),
    delay: 1000,
  });
  const { transactionHash } = await tx.wait();

  await provider.waitForTransaction(transactionHash, 1, 120000);

  const finalState = await StateMachine.state();
  expectEqBN(finalState, overrideState);
});

test(`does not retry on revert`, async function () {
  const nonce = await provider.getTransactionCount(signerAddress);
  const transaction = {
    from: signerAddress,
    to: ethers.constants.AddressZero,
    nonce,
    data: "0x1111111111111111",
    value: ethers.utils.parseEther("1"),
    gasLimit: 100000,
  };

  expect(
    ynatm.send({
      sendTransactionFunction: (gasPrice) =>
        signer.sendTransaction({ ...transaction, gasPrice }),
      minGasPrice: ynatm.toGwei(1),
      maxGasPrice: ynatm.toGwei(2),
      gasPriceScalingFunction: ynatm.LINEAR(1),
      delay: 120000,
    })
  ).rejects.toThrow("revert");
});

test(`throws on all errors`, async function () {
  // Make sure this isn't the first tx as its using nonce of 0
  const transaction = {
    from: signerAddress,
    to: signerAddress,
    nonce: 0,
    value: ethers.utils.parseEther("1"),
    gasLimit: 100000,
  };

  expect(
    ynatm.send({
      transaction,
      sendTransactionFunction: (gasPrice) =>
        signer.sendTransaction({ ...transaction, gasPrice }),
      minGasPrice: ynatm.toGwei(1),
      maxGasPrice: ynatm.toGwei(2),
      gasPriceScalingFunction: ynatm.LINEAR(1),
      delay: 120000,
      rejectImmediatelyOnCondition: () => true,
    })
  ).rejects.toThrow("nonce");
});

'''
'''--- tests/web3.test.js ---
const ynatm = require("..");
const Web3 = require("web3");
const { BigNumber } = require("ethers");

const { abi, bytecode } = require("./contracts/StateMachine.json");
const { expectEqBN, expectGtBN, PROVIDER_URL } = require("./common");

const web3 = new Web3(PROVIDER_URL, null, { transactionConfirmationBlocks: 1 });

let StateMachine;
let signerAddress;

beforeAll(async function () {
  const accounts = await web3.eth.getAccounts();

  // Gets signer address
  signerAddress = accounts[0];

  // Deploys the token contract and gets related interface
  const Factory = new web3.eth.Contract(abi);
  StateMachine = await Factory.deploy({
    from: signerAddress,
    data: `0x${bytecode}`,
  }).send({ from: signerAddress });
});

test("simple override", async function () {
  const nonce = await web3.eth.getTransactionCount(signerAddress);
  const initialGasPrice = ynatm.toGwei(1);

  const transaction = {
    from: signerAddress,
    to: signerAddress,
    data: "0x",
    nonce,
    gas: 21000,
    gasPrice: initialGasPrice,
  };

  // Ignore if transaction fails
  web3.eth.sendTransaction(transaction).catch(() => {});

  // Send a bunch of transactions to override and overprice previous tx
  const { transactionHash } = await ynatm.send({
    sendTransactionFunction: (gasPrice) =>
      web3.eth.sendTransaction(
        { ...transaction, gasPrice },
        (err) => new Error(err)
      ),
    minGasPrice: initialGasPrice + ynatm.toGwei(1),
    maxGasPrice: ynatm.toGwei(50),
    gasPriceScalingFunction: ynatm.LINEAR(1),
    delay: 1000,
  });
  const { gasPrice } = await web3.eth.getTransaction(transactionHash);

  expectGtBN(BigNumber.from(gasPrice), BigNumber.from(initialGasPrice));
});

test("contract data override", async function () {
  const nonce = await web3.eth.getTransactionCount(signerAddress);

  const initialGasPrice = ynatm.toGwei(1);
  const initialState = web3.utils.toWei("10");

  const overrideState = web3.utils.toWei("100");

  const options = {
    from: signerAddress,
    nonce,
    gas: 100000,
    gasPrice: initialGasPrice,
  };

  // Ignore if transaction fails
  StateMachine.methods
    .setState(initialState)
    .send(options)
    .catch(() => {});

  await ynatm.send({
    sendTransactionFunction: (gasPrice) =>
      StateMachine.methods
        .setState(overrideState)
        .send({ ...options, gasPrice }),
    minGasPrice: initialGasPrice + ynatm.toGwei(1),
    maxGasPrice: ynatm.toGwei(50),
    gasPriceScalingFunction: ynatm.LINEAR(1),
    delay: 1000,
  });

  const finalState = await StateMachine.methods.state().call();
  expectEqBN(
    BigNumber.from(finalState),
    BigNumber.from(overrideState.toString())
  );
});

'''