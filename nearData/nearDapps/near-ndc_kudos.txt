*GitHub Repository "near-ndc/kudos"*

'''--- .github/workflows/rust.yml ---
name: Rust

on:
  pull_request:
    branches: [master, main]
  merge_group:
  push:
    branches: ["master"]

concurrency:
  group: ci-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - uses: technote-space/get-diff-action@v6.1.2
        with:
          PATTERNS: |
            **/**.rs
            contracts/Cargo.lock
      - name: Install Rust
        if: env.GIT_DIFF
        uses: actions-rs/toolchain@v1
        with:
          toolchain: 1.69.0
          override: true
          components: rustfmt, clippy
    
      - name: Install wasm32 toolchain
        if: env.GIT_DIFF
        run: rustup target add wasm32-unknown-unknown
      - name: Clippy
        if: env.GIT_DIFF
        run: cargo clippy
      - name: Run tests
        if: env.GIT_DIFF
        run: cargo test --verbose

'''
'''--- Cargo.toml ---
[package]
name = "kudos-contract"
version = "0.1.0"
edition = "2021"
authors = ["Kirill QQ <zeliondragon@gmail.com>"]

[lib]
crate-type = ["cdylib", "lib"]

[dependencies]
near-sdk = { version = "4.1.1", features = [] }
near-contract-standards = "4.1.1"
cid = "0.10.1"

[dev-dependencies]
assert_matches = "1.5.0"
workspaces = { version = "0.7.0", features = ["unstable"] }
near-sandbox-utils = "0.6.2"
near-units = "0.2.0"
tokio = { version = "1.29.1", features = ["full"] }
anyhow = "1.0.72"

'''
'''--- README.md ---
# kudos
Kudos contract for NDC

## Setup [Testnet]

1. Build conrtact
```
RUSTFLAGS='-C link-arg=-s' cargo build --all --target wasm32-unknown-unknown --release
```
2. Init contract
```
near call $CONRTACT_ID init '{"iah_registry": "registry-unstable.i-am-human.testnet"}' --accountId rubycoptest.testnet
near call $CONRTACT_ID set_external_db '{"external_db_id": "v1.social08.testnet"}' --accountId rubycoptest.testnet --amount 5
```
3. Deploy it on testnet
```
near dev-deploy target/wasm32-unknown-unknown/release/kudos_contract.wasm
```

## Public methods

### Give kudos

Allows caller to grant kudos to a receiver NEAR account

#### Requirements

User must be human verified (should have minted and valid i-am-human SBT)
Minimum gas required: 67 TGas (300 TGas recommended)
Deposit required: 0.1 Ⓝ

#### Interface

```
give_kudos(receiver_id, message, icon_cid, hashtags): kudos id

- receiver_id: user's NEAR account id who should be granted with kudos
- message: followed commentary message text to the kudos granted. By default limits to 1000 characters
- icon_cid: optional valid CID for icon (image) at ipfs
- hashtags: optional array of user-specified tags (limited to 32 characters by default, and allows to use only alphanumeric characters, underscores and gyphens). By default maximum allowed number of hashtags is 10
```

#### Output

Returns unique kudos identifier or panics with an error message

Example JSON written to SocialDB:
```
{
  "kudos.near": {
    "kudos": {
      "some_user.near": {
        "1": {
          "created_at": "1689976833613",
          "sender_id": "alex.near",
          "kind": "k",
          "message": "that user is awesome",
          "icon": "bafybeigrf2dwtpjkiovnigysyto3d55opf6qkdikx6d65onrqnfzwgdkfa",
          "upvotes": {},
          "comments": {},
          "tags": "[\"firstkudos\",\"awesomework\"]",
        }
      }
    },
    "hashtags": {
      "firstkudos": {
        "1": "alex.near"
      },
      "awesomework": {
        "1": "alex.near"
      }
    }
  }
}
```

### Upvote kudos

Allows caller to upvote kudos by unique id granted to a receiver NEAR account

#### Requirements

User must be human verified (should have minted and valid i-am-human SBT)
Caller can't be a NEAR account which granted kudos
Caller can't be a receiver NEAR account
Caller could upvote specified kudos only once
Minimum gas required: 92 TGas (300 TGas recommended)
Deposit required: 0.004 Ⓝ

#### Interface

```
upvote_kudos(receiver_id, kudos_id): timestamp

- receiver_id: user's NEAR account id whos unique kudos should be upvoted
- kudos_id: unique kudos identified granted to a receiver NEAR account
```

#### Output

Returns stringified timestamp of block when kudos was upvoted or panics with an error message

Example JSON written to SocialDB:
```
{
  "kudos.near": {
    "kudos": {
      "some_user.near": {
        "1": {
          "upvotes": {
            "bob.near": ""
          }
        }
      }
    }
  }
}
```

### Leave commentary message to kudos

Allows caller to leave a commentary message to kudos by unique id granted to a receiver NEAR account

#### Requirements

User must be human verified (should have minted and valid i-am-human SBT)
User can't leave a comment for his kudos, but it can reply to other comments
Minimum gas required: 92 TGas (300 TGas recommended)
Deposit required: 0.017 Ⓝ

#### Interface

```
leave_comment(receiver_id, kudos_id, parent_comment_id, message): commentary id

- receiver_id: user's NEAR account id whos unique kudos should be upvoted
- kudos_id: unique kudos identified granted to a receiver NEAR account
- parent_comment_id: optional parent commentary id which this new comment is a reply for. By default, if not specified, every commentary relates to kudos id
- message: followed commentary message text to the kudos. By default limits to 1000 characters
```

#### Output

Returns unique commentary identifier or panics with an error message

Example JSON written to SocialDB:
```
{
  "kudos.near": {
    "kudos": {
      "some_user.near": {
        "1": {
          "comments": {
            "2": "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicyI6InVzZXIubmVhciIsInQiOiIxMjM0NTY3ODkwIn0="
          }
        }
      }
    }
  }
}
```

### Exchange upvoted kudos for ProofOfKudos SBT

Allows caller to exchange his upvoted kudos by unique id for a ProofOfKudos SBT

#### Requirements

User must be human verified (should have minted and valid i-am-human SBT)
Caller should be granted with kudos by provided unique identifier
Caller can exchange his upvoted kudos only once
Kudos should have minimum required number of upvotes. By default is 3 upvotes
Minimum gas required: 87 TGas (300 TGas recommended)
Deposit required: 0.008 Ⓝ

#### Interface

```
exchange_kudos_for_sbt(kudos_id): array of minted SBTs

- kudos_id: unique kudos identified granted to a caller NEAR account
```

#### Output

Returns an array of minted ProofOfKudos SBTs in exchange for kudos or panics with an error message

'''
'''--- clippy.toml ---
too-many-arguments-threshold = 10
'''
'''--- src/callbacks/common.rs ---
use crate::{Contract, ContractExt};
use near_sdk::{env, near_bindgen};

#[near_bindgen]
impl Contract {
    #[private]
    pub fn on_failure(&mut self, error: String) {
        env::panic_str(&error)
    }
}

'''
'''--- src/callbacks/exchange_kudos_for_sbt.rs ---
use super::utils::parse_kudos_and_verify_if_allowed_to_exchange;
use crate::consts::*;
use crate::external_db::ext_db;
use crate::registry::{ext_sbtreg, TokenId};
use crate::settings::Settings;
use crate::types::KudosId;
use crate::utils::*;
use crate::{Contract, ContractExt};
use near_sdk::json_types::U128;
use near_sdk::serde_json::Value;
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseError, PromiseOrValue};

#[near_bindgen]
impl Contract {
    #[private]
    pub fn acquire_number_of_upvotes(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        kudos_id: KudosId,
        #[callback_result] callback_result: Result<Vec<(AccountId, Vec<TokenId>)>, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let result = callback_result
            .map_err(|e| format!("IAHRegistry::is_human() call failure: {e:?}"))
            .and_then(|tokens| {
                if tokens.is_empty() {
                    return Err("IAHRegistry::is_human() returns result: Not a human".to_owned());
                }

                let receiver_id = env::signer_account_id();
                let root_id = env::current_account_id();
                let kudos_upvotes_path =
                    build_kudos_upvotes_path(&root_id, &receiver_id, &kudos_id);
                let acquire_upvotes_req = [&kudos_upvotes_path, "/*"].concat();
                let kudos_kind_path = build_kudos_kind_path(&root_id, &receiver_id, &kudos_id);

                let upvotes_acquired_callback_gas = KUDOS_UPVOTES_ACQUIRED_CALLBACK_GAS
                    + PROOF_OF_KUDOS_SBT_MINT_GAS
                    + PROOF_OF_KUDOS_SBT_MINT_CALLBACK_GAS
                    + FAILURE_CALLBACK_GAS;

                let acquire_upvotes_gas = env::prepaid_gas()
                    - (ACQUIRE_NUMBER_OF_UPVOTES_RESERVED_GAS + upvotes_acquired_callback_gas);

                Ok(ext_db::ext(external_db_id)
                    .with_static_gas(acquire_upvotes_gas)
                    .get(vec![acquire_upvotes_req, kudos_kind_path.clone()], None)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(upvotes_acquired_callback_gas)
                            .on_kudos_upvotes_acquired(
                                predecessor_account_id.clone(),
                                attached_deposit.into(),
                                kudos_id,
                                kudos_upvotes_path,
                                kudos_kind_path,
                            ),
                    ))
            });

        result.unwrap_or_else(|e| {
            Promise::new(predecessor_account_id)
                .transfer(attached_deposit)
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(FAILURE_CALLBACK_GAS)
                        .on_failure(e),
                )
        })
    }

    #[private]
    pub fn on_kudos_upvotes_acquired(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        kudos_id: KudosId,
        kudos_upvotes_path: String,
        kudos_kind_path: String,
        #[callback_result] kudos_result: Result<Value, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;
        let settings = Settings::from(&self.settings);

        match parse_kudos_and_verify_if_allowed_to_exchange(
            kudos_result,
            kudos_upvotes_path,
            kudos_kind_path,
            settings.min_number_of_upvotes_to_exchange_kudos as usize,
        )
        .and_then(|_| {
            let issued_at = env::block_timestamp_ms();
            let expires_at = settings.acquire_pok_sbt_expire_at_ts(issued_at)?;

            Ok(build_pok_sbt_metadata(issued_at, expires_at))
        }) {
            Ok(metadata) => {
                self.exchanged_kudos.insert(kudos_id.clone());

                ext_sbtreg::ext(self.iah_registry.clone())
                    .with_attached_deposit(PROOF_OF_KUDOS_SBT_MINT_COST)
                    .with_static_gas(PROOF_OF_KUDOS_SBT_MINT_GAS)
                    .sbt_mint(vec![(env::signer_account_id(), vec![metadata])])
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(
                                PROOF_OF_KUDOS_SBT_MINT_CALLBACK_GAS + FAILURE_CALLBACK_GAS,
                            )
                            .on_pok_sbt_mint(
                                predecessor_account_id,
                                attached_deposit.into(),
                                kudos_id,
                            ),
                    )
            }
            Err(e) => {
                // Return leave comment deposit back to sender if failed
                Promise::new(predecessor_account_id)
                    .transfer(attached_deposit)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(FAILURE_CALLBACK_GAS)
                            .on_failure(e),
                    )
            }
        }
    }

    #[private]
    #[handle_result]
    pub fn on_pok_sbt_mint(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        kudos_id: KudosId,
        #[callback_result] callback_result: Result<Vec<u64>, PromiseError>,
    ) -> Result<PromiseOrValue<Vec<u64>>, &'static str> {
        let attached_deposit = attached_deposit.0;

        match callback_result {
            Ok(minted_tokens_ids) if minted_tokens_ids.is_empty() => {
                // If IAHRegistry contract succeeds but returns an empty tokens list,
                // we treat is an unexpected failure and panic. No user deposit returns for this case.
                Err("IAHRegistry::sbt_mint() responses with an empty tokens array")
            }
            Ok(minted_tokens_ids) => Ok(PromiseOrValue::Value(minted_tokens_ids)),
            Err(e) => {
                // If tokens weren't minted, remove kudos from exchanged table
                self.exchanged_kudos.remove(&kudos_id);

                // Return deposit back to sender if IAHRegistry::sbt_mint fails
                Ok(Promise::new(predecessor_account_id)
                    .transfer(attached_deposit)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(FAILURE_CALLBACK_GAS)
                            .on_failure(format!("IAHRegistry::sbt_mint() call failure: {:?}", e)),
                    )
                    .into())
            }
        }
    }
}

'''
'''--- src/callbacks/give_kudos.rs ---
use crate::external_db::ext_db;
use crate::registry::TokenId;
use crate::types::KudosId;
use crate::{consts::*, Hashtag, KudosKind};
use crate::{utils::*, WrappedCid};
use crate::{Contract, ContractExt};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseError, PromiseOrValue};

#[near_bindgen]
impl Contract {
    #[private]
    pub fn save_kudos(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        receiver_id: AccountId,
        kind: KudosKind,
        message: String,
        icon_cid: Option<WrappedCid>,
        hashtags: Option<Vec<Hashtag>>,
        #[callback_result] callback_result: Result<Vec<(AccountId, Vec<TokenId>)>, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let result = callback_result
            .map_err(|e| format!("IAHRegistry::is_human() call failure: {e:?}"))
            .and_then(|tokens| {
                if tokens.is_empty() {
                    return Err("IAHRegistry::is_human() returns result: Not a human".to_owned());
                }

                let sender_id = env::signer_account_id();
                let root_id = env::current_account_id();
                let created_at = env::block_timestamp_ms();
                let kudos_id = KudosId::from(self.last_incremental_id.inc());
                let kudos_json = build_give_kudos_request(
                    &root_id,
                    &sender_id,
                    &receiver_id,
                    &kudos_id,
                    created_at,
                    kind,
                    &message,
                    icon_cid.as_ref(),
                    hashtags.as_deref(),
                )?;

                let save_kudos_gas = env::prepaid_gas()
                    - (SAVE_KUDOS_RESERVED_GAS + KUDOS_SAVED_CALLBACK_GAS + FAILURE_CALLBACK_GAS);

                Ok(ext_db::ext(external_db_id)
                    .with_static_gas(save_kudos_gas)
                    .with_attached_deposit(attached_deposit)
                    .set(kudos_json)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(KUDOS_SAVED_CALLBACK_GAS + FAILURE_CALLBACK_GAS)
                            .on_kudos_saved(
                                predecessor_account_id.clone(),
                                attached_deposit.into(),
                                kudos_id,
                            ),
                    ))
            });

        result.unwrap_or_else(|e| {
            Promise::new(predecessor_account_id)
                .transfer(attached_deposit)
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(FAILURE_CALLBACK_GAS)
                        .on_failure(e),
                )
        })
    }

    #[private]
    pub fn on_kudos_saved(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        kudos_id: KudosId,
        #[callback_result] callback_result: Result<(), PromiseError>,
    ) -> PromiseOrValue<KudosId> {
        let attached_deposit = attached_deposit.0;

        match callback_result {
            Ok(_) => PromiseOrValue::Value(kudos_id),
            Err(e) => {
                // Return deposit back to sender if NEAR SocialDb write failure
                Promise::new(predecessor_account_id)
                    .transfer(attached_deposit)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(FAILURE_CALLBACK_GAS)
                            .on_failure(format!("SocialDB::set() call failure: {e:?}")),
                    )
                    .into()
            }
        }
    }
}

'''
'''--- src/callbacks/leave_comment.rs ---
use crate::external_db::ext_db;
use crate::registry::TokenId;
use crate::types::{CommentId, KudosId};
use crate::utils::*;
use crate::{consts::*, EncodedCommentary};
use crate::{Contract, ContractExt};
use near_sdk::json_types::U128;
use near_sdk::serde_json::Value;
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseError, PromiseOrValue};

#[near_bindgen]
impl Contract {
    #[private]
    pub fn acquire_kudos_info(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        receiver_id: AccountId,
        kudos_id: KudosId,
        parent_comment_id: Option<CommentId>,
        comment: EncodedCommentary,
        #[callback_result] callback_result: Result<Vec<(AccountId, Vec<TokenId>)>, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let result = callback_result
            .map_err(|e| format!("IAHRegistry::is_human() call failure: {e:?}"))
            .and_then(|tokens| {
                if tokens.is_empty() {
                    return Err("IAHRegistry::is_human() returns result: Not a human".to_owned());
                }

                let root_id = env::current_account_id();
                let comment_id = CommentId::from(self.last_incremental_id.inc());
                let leave_comment_req = build_leave_comment_request(
                    &root_id,
                    &receiver_id,
                    &kudos_id,
                    &comment_id,
                    &comment,
                )?;
                let get_kudos_by_id_req =
                    build_get_kudos_by_id_request(&root_id, &receiver_id, &kudos_id);
                let mut get_req = vec![get_kudos_by_id_req.clone()];

                if let Some(comment_id) = parent_comment_id.as_ref() {
                    get_req.push(build_get_kudos_comment_by_id_request(
                        &root_id,
                        &receiver_id,
                        &kudos_id,
                        comment_id,
                    ));
                }

                // Compute minimum required gas and split the remaining gas by two equal parts for
                // NEAR Social db subsequent calls
                let get_kudos_by_id_gas = (env::prepaid_gas()
                    - (ACQUIRE_KUDOS_INFO_RESERVED_GAS
                        + KUDOS_INFO_ACQUIRED_CALLBACK_GAS
                        + KUDOS_COMMENT_SAVED_CALLBACK_GAS
                        + FAILURE_CALLBACK_GAS))
                    / 2;
                let get_kudos_by_id_callback_gas = get_kudos_by_id_gas
                    + KUDOS_INFO_ACQUIRED_CALLBACK_GAS
                    + KUDOS_COMMENT_SAVED_CALLBACK_GAS
                    + FAILURE_CALLBACK_GAS;

                Ok(ext_db::ext(external_db_id.clone())
                    .with_static_gas(get_kudos_by_id_gas)
                    .get(get_req, None)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(get_kudos_by_id_callback_gas)
                            .on_kudos_info_acquired(
                                predecessor_account_id.clone(),
                                attached_deposit.into(),
                                external_db_id,
                                get_kudos_by_id_req,
                                leave_comment_req,
                                parent_comment_id,
                                comment_id,
                            ),
                    ))
            });

        result.unwrap_or_else(|e| {
            Promise::new(predecessor_account_id)
                .transfer(attached_deposit)
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(FAILURE_CALLBACK_GAS)
                        .on_failure(e),
                )
        })
    }

    #[private]
    pub fn on_kudos_info_acquired(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        get_kudos_by_id_req: String,
        leave_comment_req: Value,
        parent_comment_id: Option<CommentId>,
        comment_id: CommentId,
        #[callback_result] callback_result: Result<Value, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let Err(e) = callback_result
            .map_err(|e| {
                format!(
                    "SocialDB::get({get_kudos_by_id_req}) call failure: {e:?}"
                )
            })
            .and_then(|mut kudos_by_id_res| {
                if let Some(comment_id) = parent_comment_id.as_ref() {
                    // We do not verify if extracted base64-encoded commentary is valid, we assume 
                    // that data stored in social db is not corrupted.
                    let _ = extract_kudos_encoded_comment_by_id_from_response(&get_kudos_by_id_req, comment_id, &mut kudos_by_id_res)
                        .ok_or_else(|| {
                            "Unable to verify parent commentary id".to_owned()
                        })?;
                }

                extract_kudos_id_sender_from_response(&get_kudos_by_id_req, &mut kudos_by_id_res)
                    .ok_or_else(|| {
                        "Unable to acquire a Kudos sender account id".to_owned()
                    })
            }) else {
                let gas_left = env::prepaid_gas()
                    - (KUDOS_INFO_ACQUIRED_CALLBACK_GAS + KUDOS_COMMENT_SAVED_CALLBACK_GAS + FAILURE_CALLBACK_GAS);

                return ext_db::ext(external_db_id)
                    .with_attached_deposit(attached_deposit)
                    .with_static_gas(gas_left)
                    .set(leave_comment_req)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(KUDOS_COMMENT_SAVED_CALLBACK_GAS + FAILURE_CALLBACK_GAS)
                            .on_commentary_saved(
                                predecessor_account_id,
                                attached_deposit.into(),
                                comment_id,
                            ),
                    );
            };

        // Return leave comment deposit back to sender if failed
        Promise::new(predecessor_account_id)
            .transfer(attached_deposit)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(FAILURE_CALLBACK_GAS)
                    .on_failure(e),
            )
    }

    #[private]
    pub fn on_commentary_saved(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        comment_id: CommentId,
        #[callback_result] callback_result: Result<(), PromiseError>,
    ) -> PromiseOrValue<CommentId> {
        let attached_deposit = attached_deposit.0;

        match callback_result {
            Ok(_) => PromiseOrValue::Value(comment_id),
            Err(e) => {
                // Return deposit back to sender if NEAR SocialDb write failure
                Promise::new(predecessor_account_id)
                    .transfer(attached_deposit)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(FAILURE_CALLBACK_GAS)
                            .on_failure(format!("SocialDB::set() call failure: {e:?}")),
                    )
                    .into()
            }
        }
    }
}

'''
'''--- src/callbacks/mod.rs ---
mod common;
mod exchange_kudos_for_sbt;
mod give_kudos;
mod leave_comment;
mod upvote_kudos;
mod utils;

'''
'''--- src/callbacks/upvote_kudos.rs ---
use crate::consts::*;
use crate::external_db::ext_db;
use crate::registry::TokenId;
use crate::types::KudosId;
use crate::utils::*;
use crate::{Contract, ContractExt};
use near_sdk::json_types::U128;
use near_sdk::json_types::U64;
use near_sdk::serde_json::Value;
use near_sdk::{env, near_bindgen, AccountId, Promise, PromiseError, PromiseOrValue};

#[near_bindgen]
impl Contract {
    #[private]
    pub fn acquire_kudos_sender(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        receiver_id: AccountId,
        kudos_id: KudosId,
        #[callback_result] callback_result: Result<Vec<(AccountId, Vec<TokenId>)>, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let result = callback_result
            .map_err(|e| format!("IAHRegistry::is_human() call failure: {e:?}"))
            .and_then(|tokens| {
                if tokens.is_empty() {
                    return Err("IAHRegistry::is_human() returns result: Not a human".to_owned());
                }

                let root_id = env::current_account_id();
                let sender_id = env::signer_account_id();
                let upvote_kudos_req =
                    build_upvote_kudos_request(&root_id, &sender_id, &receiver_id, &kudos_id)?;
                let get_kudos_by_id_req =
                    build_get_kudos_by_id_request(&root_id, &receiver_id, &kudos_id);

                // Compute minimum required gas and split the remaining gas by two equal parts for
                // NEAR Social db subsequent calls
                let get_kudos_by_id_gas = (env::prepaid_gas()
                    - (ACQUIRE_KUDOS_SENDER_RESERVED_GAS
                        + KUDOS_SENDER_ACQUIRED_CALLBACK_GAS
                        + KUDOS_UPVOTE_SAVED_CALLBACK_GAS
                        + FAILURE_CALLBACK_GAS))
                    / 2;
                let get_kudos_by_id_callback_gas = get_kudos_by_id_gas
                    + KUDOS_SENDER_ACQUIRED_CALLBACK_GAS
                    + KUDOS_UPVOTE_SAVED_CALLBACK_GAS
                    + FAILURE_CALLBACK_GAS;

                Ok(ext_db::ext(external_db_id.clone())
                    .with_static_gas(get_kudos_by_id_gas)
                    .get(vec![get_kudos_by_id_req.clone()], None)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(get_kudos_by_id_callback_gas)
                            .on_kudos_sender_acquired(
                                predecessor_account_id.clone(),
                                attached_deposit.into(),
                                external_db_id,
                                get_kudos_by_id_req,
                                upvote_kudos_req,
                            ),
                    ))
            });

        result.unwrap_or_else(|e| {
            Promise::new(predecessor_account_id)
                .transfer(attached_deposit)
                .then(
                    Self::ext(env::current_account_id())
                        .with_static_gas(FAILURE_CALLBACK_GAS)
                        .on_failure(e),
                )
        })
    }

    #[private]
    pub fn on_kudos_sender_acquired(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        external_db_id: AccountId,
        get_kudos_by_id_req: String,
        upvote_kudos_req: Value,
        #[callback_result] callback_result: Result<Value, PromiseError>,
    ) -> Promise {
        let attached_deposit = attached_deposit.0;

        let Err(e) = callback_result
            .map_err(|e| format!("SocialDB::get({get_kudos_by_id_req}) call failure: {e:?}"))
            .and_then(|mut kudos_by_id_res| {
                match extract_kudos_id_sender_from_response(&get_kudos_by_id_req, &mut kudos_by_id_res) {
                    Some(sender_id) if sender_id == env::signer_account_id() => {
                        Err("User is not eligible to upvote this kudos".to_owned())
                    }
                    Some(_) => Ok(()),
                    None => Err("Unable to acquire a Kudos sender account id".to_owned())
                }
            }) else {
                let gas_left = env::prepaid_gas()
                    - (KUDOS_SENDER_ACQUIRED_CALLBACK_GAS
                        + KUDOS_UPVOTE_SAVED_CALLBACK_GAS
                        + FAILURE_CALLBACK_GAS);

                return ext_db::ext(external_db_id)
                    .with_attached_deposit(attached_deposit)
                    .with_static_gas(gas_left)
                    .set(upvote_kudos_req)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(KUDOS_UPVOTE_SAVED_CALLBACK_GAS + FAILURE_CALLBACK_GAS)
                            .on_kudos_upvote_saved(
                                predecessor_account_id,
                                attached_deposit.into(),
                            ),
                    );
            };

        // Return upvote kudos deposit back to sender if failed
        Promise::new(predecessor_account_id)
            .transfer(attached_deposit)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(FAILURE_CALLBACK_GAS)
                    .on_failure(e),
            )
    }

    #[private]
    pub fn on_kudos_upvote_saved(
        &mut self,
        predecessor_account_id: AccountId,
        attached_deposit: U128,
        #[callback_result] callback_result: Result<(), PromiseError>,
    ) -> PromiseOrValue<U64> {
        let attached_deposit = attached_deposit.0;

        match callback_result {
            Ok(_) => PromiseOrValue::Value(env::block_timestamp_ms().into()),
            Err(e) => {
                // Return deposit back to sender if NEAR SocialDb write failure
                Promise::new(predecessor_account_id)
                    .transfer(attached_deposit)
                    .then(
                        Self::ext(env::current_account_id())
                            .with_static_gas(FAILURE_CALLBACK_GAS)
                            .on_failure(format!("SocialDB::set() call failure: {e:?}")),
                    )
                    .into()
            }
        }
    }
}

'''
'''--- src/callbacks/utils.rs ---
use crate::{utils::*, KudosKind};
use near_sdk::serde_json::{self, Value};
use near_sdk::{AccountId, PromiseError};
use std::collections::HashMap;

pub fn parse_kudos_and_verify_if_allowed_to_exchange(
    res: Result<Value, PromiseError>,
    kudos_upvotes_path: String,
    kudos_kind_path: String,
    required_min_number_of_upvotes: usize,
) -> Result<(), String> {
    let mut kudos_json = res.map_err(|e| {
        format!("SocialDB::get({kudos_upvotes_path}/*,{kudos_kind_path}) call failure: {e:?}")
    })?;

    let kudos_kind = match remove_key_from_json(&mut kudos_json, &kudos_kind_path) {
        Some(kudos_kind_raw) => serde_json::from_value::<KudosKind>(kudos_kind_raw.clone())
            .map_err(|e| format!("Failed to parse kudos kind type `{kudos_kind_raw:?}`: {e:?}"))?,
        None => KudosKind::Kudos,
    };

    if kudos_kind == KudosKind::Ding {
        return Err("Dings can't be exchanged".to_owned());
    }

    let upvotes_raw = remove_key_from_json(&mut kudos_json, &kudos_upvotes_path)
        .ok_or_else(|| format!("No upvotes found for kudos: {kudos_json:?}"))?;

    let upvoters = serde_json::from_value::<HashMap<AccountId, Value>>(upvotes_raw.clone())
        .map_err(|e| format!("Failed to parse kudos upvotes data `{upvotes_raw:?}`: {e:?}"))?;

    let number_of_upvotes = upvoters.keys().len();

    if number_of_upvotes < required_min_number_of_upvotes {
        Err(format!(
            "Minimum required number ({}) of upvotes has not been reached",
            required_min_number_of_upvotes
        ))
    } else {
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::{build_kudos_kind_path, build_kudos_upvotes_path};
    use crate::{IncrementalUniqueId, KudosId};
    use near_sdk::serde_json::json;
    use near_sdk::test_utils::accounts;

    #[test]
    fn test_parse_kudos_and_verify_upvotes() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let kudos_id = KudosId::from(IncrementalUniqueId::default().next());
        let receiver_id = accounts(0);
        let kudos_upvotes_path = build_kudos_upvotes_path(&root_id, &receiver_id, &kudos_id);
        let kudos_kind_path = build_kudos_kind_path(&root_id, &receiver_id, &kudos_id);

        struct TestCase<'a> {
            name: &'a str,
            input: Result<Value, PromiseError>,
            output: &'a str,
        }

        let test_cases = [
            TestCase {
                name: "Dings exchange",
                input: Ok(json!({
                    "kudos.near": {
                      "kudos": {
                        "alice": {
                          "1": {
                            "kind": "d",
                            "upvotes": {}
                          }
                        }
                      }
                    }
                })),
                output: "Dings can't be exchanged",
            },
            TestCase {
                name: "Minimum upvotes requirement",
                input: Ok(json!({
                    "kudos.near": {
                      "kudos": {
                        "alice": {
                          "1": {
                            "kind": "k",
                            "upvotes": {}
                          }
                        }
                      }
                    }
                })),
                output: "Minimum required number (3) of upvotes has not been reached",
            },
            TestCase {
                name: "Upvotes parse failure",
                input: Ok(json!({
                    "kudos.near": {
                      "kudos": {
                        "alice": {
                          "1": {
                            "upvotes": "invalid_data"
                          }
                        }
                      }
                    }
                })),
                output: "Failed to parse kudos upvotes data `String(\"invalid_data\")`: Error(\"invalid type: string \\\"invalid_data\\\", expected a map\", line: 0, column: 0)",
            },
            TestCase {
                name: "Unknown kudos kind",
                input: Ok(json!({
                    "kudos.near": {
                      "kudos": {
                        "alice": {
                          "1": {
                            "kind": "unknown",
                            "upvotes": {}
                          }
                        }
                      }
                    }
                })),
                output: "Failed to parse kudos kind type `String(\"unknown\")`: Error(\"unknown variant `unknown`, expected `k` or `d`\", line: 0, column: 0)",
            },
            TestCase {
                name: "Invalid response",
                input: Ok(json!({})),
                output: "No upvotes found for kudos: Object {}",
            },
            TestCase {
                name: "Promise error",
                input: Err(near_sdk::PromiseError::Failed),
                output: "SocialDB::get(kudos.near/kudos/alice/1/upvotes/*,kudos.near/kudos/alice/1/kind) call failure: Failed",
            },
        ];

        for test_case in test_cases {
            assert_eq!(
                parse_kudos_and_verify_if_allowed_to_exchange(
                    test_case.input,
                    kudos_upvotes_path.clone(),
                    kudos_kind_path.clone(),
                    3
                )
                .unwrap_err()
                .as_str(),
                test_case.output,
                "Test case `{} failure`",
                test_case.name
            );
        }
    }
}

'''
'''--- src/consts.rs ---
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::{Balance, Gas, StorageUsage};

pub(crate) const U64_STORAGE: StorageUsage = 8;
pub(crate) const U8_STORAGE: StorageUsage = 1;

/// Every contract storage key/value entry always uses 40 bytes when stored via `env::storage_write`
/// - key len as u64,
/// - key ptr as u64,
/// - value len as u64,
/// - value ptr as u64,
/// - register as u64
pub(crate) const STORAGE_ENTRY: StorageUsage = 5 * U64_STORAGE;

/// enum::StorageKey size [1 byte]
const ENUM_STORAGE_KEY: StorageUsage = U8_STORAGE;

/// Internal class id of ProofOfKudos SBT used by i-am-human-registry for this smart contract
pub const PROOF_OF_KUDOS_SBT_CLASS_ID: u64 = 1;

/// Required Ⓝ deposit to mint ProofOfKudos SBT by i-am-human-registry smart contract
///
/// This value should be updated if mentioned contract will require different amount of deposit
pub const PROOF_OF_KUDOS_SBT_MINT_COST: Balance = 9_000_000_000_000_000_000_000;

/// Required storage to memorise exchanged [`KudosId`] in [`LookupSet`] of this smart contract storage
///
/// The [`KudosId`] is represented by [`u64`] value which is serialized to 8 bytes plus [`STORAGE_ENTRY`] required
/// to store anything in contract storage
pub const EXCHANGE_KUDOS_STORAGE: StorageUsage = STORAGE_ENTRY + ENUM_STORAGE_KEY + U64_STORAGE;

/// Deposit required to exchange upvoted Kudos for ProofOfKudos SBT
///
/// This value includes a storage amount required to memorise exchanged [`KudosId`] and
/// the minting cost of a ProofOfKudos SBT by i-am-human-registry smart contract. This value
/// should be changed if any of the above will be changed
pub const EXCHANGE_KUDOS_COST: Balance =
    EXCHANGE_KUDOS_STORAGE as Balance * STORAGE_PRICE_PER_BYTE + PROOF_OF_KUDOS_SBT_MINT_COST;

/// Required storage for this contract registered as user at SocialDB to grant write permission to IAH Registry contract
///
/// This value was pre-computed by using maximum (64 characters) account id length for IAH Registry and this contracts.
pub const SOCIAL_DB_GRANT_WRITE_PERMISSION_COST: Balance = 3_100_000_000_000_000_000_000;

/// Deposit required to give kudos to user.
///
/// The computed deposit amount is based on a case when user with maximum account name length (64 characters)
/// grants kudos with maximum provided commentary text length (1000 escaped ascii characters),
/// icon CID for ipfs and maximum number of allowed hashtags (10) with a hashtag of maximum
/// text length (limited to 32 characters, and allows to use only alphanumeric ascii characters, underscores and gyphens)
/// to a user with maximum account name length (64 characters). The exact value of this computation is 0.0961 Ⓝ and
/// it is rounded to 0.1 Ⓝ. This value should be recomputed if the above restrications will be changed.
pub const GIVE_KUDOS_COST: Balance = 100_000_000_000_000_000_000_000; // 0.1 Ⓝ (0.09802)

/// Deposit required to leave a commentary message for kudos
///
/// The computed deposit amount is based on a case when user with maximum account name length (64 characters)
/// leaves a commentary message text with maximum length (1000 escaped ascii characters)
/// to a user with maximum account name length (64 characters). The exact value of this computation when
/// no parent commentary id provided is 0.01653 Ⓝ and it is rounded to 0.017 Ⓝ. This value should be recomputed
/// if the above restrications will be changed.
pub const LEAVE_COMMENT_COST: Balance = 17_000_000_000_000_000_000_000; // 0.017 Ⓝ (0.01653 when no parent commentary id)

/// Deposit required to upvote kudos
///
/// The computed deposit amount is based on a case when user with maximum account name length (64 characters)
/// upvotes kudos. The exact value of this computation is 0.00311 Ⓝ and it is rounded to 0.004 Ⓝ.
/// This value should be recomputed if the above restrications will be changed.
pub const UPVOTE_KUDOS_COST: Balance = 4_000_000_000_000_000_000_000; // 0.004 Ⓝ (0.00311)

/// Gas reserved for final failure callback which panics if one of the callback fails.
pub const FAILURE_CALLBACK_GAS: Gas = Gas(5 * Gas::ONE_TERA.0);

/// Gas required for a [`save_kudos`](kudos_contract::callbacks::give_kudos::ContractExt::save_kudos) callback
pub const SAVE_KUDOS_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_kudos_saved`](kudos_contract::callbacks::give_kudos::ContractExt::on_kudos_saved) callback
pub const KUDOS_SAVED_CALLBACK_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas reserved to a public method [`give_kudos`](kudos_contract::public::Contract::give_kudos)
pub const GIVE_KUDOS_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);

/// Gas required for a [`acquire_kudos_sender`](kudos_contract::callbacks::upvote_kudos::ContractExt::acquire_kudos_sender) callback
pub const ACQUIRE_KUDOS_SENDER_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_kudos_sender_acquired`](kudos_contract::callbacks::upvote_kudos::ContractExt::on_kudos_sender_acquired) callback
pub const KUDOS_SENDER_ACQUIRED_CALLBACK_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_kudos_upvote_saved`](kudos_contract::callbacks::upvote_kudos::ContractExt::on_kudos_upvote_saved) callback
pub const KUDOS_UPVOTE_SAVED_CALLBACK_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas reserved to a public method [`upvote_kudos`](kudos_contract::public::Contract::upvote_kudos)
pub const UPVOTE_KUDOS_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);

/// Gas required for a [`acquire_kudos_info`](kudos_contract::callbacks::leave_comment::ContractExt::acquire_kudos_info) callback
pub const ACQUIRE_KUDOS_INFO_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_kudos_info_acquired`](kudos_contract::callbacks::leave_comment::ContractExt::on_kudos_info_acquired) callback
pub const KUDOS_INFO_ACQUIRED_CALLBACK_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_commentary_saved`](kudos_contract::callbacks::leave_comment::ContractExt::on_commentary_saved) callback
pub const KUDOS_COMMENT_SAVED_CALLBACK_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas reserved to a public method [`leave_comment`](kudos_contract::public::Contract::leave_comment)
pub const LEAVE_COMMENT_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);

/// Gas required for a [`acquire_number_of_upvotes`](kudos_contract::callbacks::exchange_kudos_for_sbt::ContractExt::acquire_number_of_upvotes) callback
pub const ACQUIRE_NUMBER_OF_UPVOTES_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
/// Gas required for a [`on_kudos_upvotes_acquired`](kudos_contract::callbacks::exchange_kudos_for_sbt::ContractExt::on_kudos_upvotes_acquired) callback
pub const KUDOS_UPVOTES_ACQUIRED_CALLBACK_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas required for a [`sbt_mint`](kudos_contract::registry::ExtSbtRegistry::sbt_mint) cross contract call
pub const PROOF_OF_KUDOS_SBT_MINT_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas required for a [`on_pok_sbt_mint`](kudos_contract::callbacks::exchange_kudos_for_sbt::ContractExt::on_pok_sbt_mint) callback
pub const PROOF_OF_KUDOS_SBT_MINT_CALLBACK_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);
/// Gas reserved to a public method [`exchange_kudos_for_sbt`](kudos_contract::public::Contract::exchange_kudos_for_sbt)
pub const EXCHANGE_KUDOS_FOR_SBT_RESERVED_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);

/// Gas required minimum for `get` and `set` methods of NEAR social db smart contract.
///
/// All remainder gas will be passed additionally for these calls.
pub const SOCIAL_DB_REQUEST_MIN_RESERVED_GAS: Gas = Gas(10 * Gas::ONE_TERA.0);

'''
'''--- src/contract.rs ---
use crate::external_db::ext_db;
use crate::misc::RunningState;
use crate::settings::{Settings, SettingsView, VSettings};
use crate::types::{KudosId, StorageKey};
use crate::utils::build_initial_json_for_socialdb;
use crate::IncrementalUniqueId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::store::LookupSet;
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, PanicOnDefault, Promise, PromiseError,
    ONE_YOCTO,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// A valid [`AccountId`] which represents a contract's owner/admin
    pub(crate) owner_id: AccountId,
    /// Contract's state [`RunningState`], e.g. running, paused
    pub(crate) running_state: RunningState,
    /// Last unique incremenetal identifier [`IncrementalUniqueId`] used to get next incremented unique [`KudosId`] and [`CommentId`]
    pub(crate) last_incremental_id: IncrementalUniqueId,
    /// A valid [`AccountId`] of NEAR social db smart contract, should be set by calling `set_external_db` method.
    /// Used to store and read saved kudos information.
    pub(crate) external_db_id: Option<AccountId>,
    /// A valid [`AccountId`] of i-am-human-registry smart contract, set during a contract initialization.
    /// Used to check for humanity and to exchange upvoted kudos for a ProofOfKudos SBT
    pub(crate) iah_registry: AccountId,
    /// Upgradable [`VSettings`] for this smart contract, which represents some configurable settings,
    /// e.g. max commentary message length, etc.
    pub(crate) settings: VSettings,
    /// [`LookupSet`] of unique [`KudosId`] to memorise exchanged kudos for ProofOfKudos SBT.
    /// Used to guarantee upvotes kudos to be exchanged only once.
    pub(crate) exchanged_kudos: LookupSet<KudosId>,
}

#[near_bindgen]
impl Contract {
    /// Initializes contract with default values, allows to set a valid [`AccountId`] as an owner of a contract initially.
    /// Requires a valid [`AccountId`] for i-am-human-registry smart contract.
    #[init]
    pub fn init(owner_id: Option<AccountId>, iah_registry: AccountId) -> Self {
        Self {
            owner_id: owner_id.unwrap_or_else(env::predecessor_account_id),
            running_state: RunningState::Running,
            last_incremental_id: IncrementalUniqueId::default(),
            external_db_id: None,
            iah_registry,
            settings: Settings::default().into(),
            exchanged_kudos: LookupSet::new(StorageKey::Kudos),
        }
    }

    /// Replaces [`AccountId`] of i-am-human-registry smart contract which is used to verify humanity and
    /// to exchange kudos for ProofOfKudos SBT. Restricted to be used only by an owner/admin of this contract.
    #[payable]
    #[handle_result]
    pub fn update_iah_registry(&mut self, iah_registry: AccountId) -> Result<Promise, String> {
        self.assert_owner();

        let external_db_id = self.external_db_id()?.clone();

        self.grant_write_permission(external_db_id, iah_registry, env::attached_deposit())
    }

    /// Sets [`AccoundId`] of NEAR social db smart contract as an external storage for kudos.
    /// Restricted to be used only by an owner/admin of this contract.
    #[payable]
    #[handle_result]
    pub fn set_external_db(&mut self, external_db_id: AccountId) -> Result<Promise, &'static str> {
        self.assert_owner();
        // Do not allow to change SocialDB address, because there is no data migration possible.
        // It should be initialized only once.
        require!(
            self.external_db_id.is_none(),
            "External database already set"
        );

        let root_id = env::current_account_id();
        let initial_json = build_initial_json_for_socialdb(&root_id)?;

        // This will require a minimum amount of deposit to register a user for Kudos contract.
        // Minimum amount of deposit required could be priorly acquired by calling a view method
        // `storage_balance_bounds` to Social-Db contract and one yocto additionally should be added
        // to request `grant_write_permission` method
        Ok(ext_db::ext(external_db_id.clone())
            .with_attached_deposit(env::attached_deposit() - ONE_YOCTO)
            .set(initial_json)
            .then(Self::ext(env::current_account_id()).on_ext_db_init(external_db_id, ONE_YOCTO)))
    }

    /// Public view method to read current settings [`SettingsView`] of this contract
    pub fn view_settings(&self) -> SettingsView {
        Settings::from(&self.settings).into()
    }

    /// Updates specified settings [`SettingsView`] for this smart contract.
    /// Restricted to be used only by an owner/admin of this contract.
    #[payable]
    pub fn update_settings(&mut self, settings_json: SettingsView) {
        self.assert_owner();

        self.settings = self.settings.apply_changes(settings_json);
    }

    /// Internal helper method to grant write permission to IAH Registry
    ///
    /// Write permissions required to be able to use `IAHRegistry::is_human_call`, because SocialDB checks for a predecessor_id.
    ///
    /// ATTENTION: `is_human_call` is not being used by this smart contract right now, but we still want to be able
    /// to use it in future, so the code below is necessary.
    fn grant_write_permission(
        &mut self,
        external_db_id: AccountId,
        iah_registry: AccountId,
        deposit: Balance,
    ) -> Result<Promise, String> {
        Ok(ext_db::ext(external_db_id.clone())
            .with_attached_deposit(deposit)
            .grant_write_permission(
                Some(iah_registry.clone()),
                None,
                vec![format!("{}", env::current_account_id())],
            )
            .then(
                Self::ext(env::current_account_id())
                    .on_ext_db_write_permission_granted(external_db_id, iah_registry),
            ))
    }

    #[private]
    #[handle_result]
    pub fn on_ext_db_init(
        &mut self,
        external_db_id: AccountId,
        deposit: Balance,
        #[callback_result] callback_result: Result<(), PromiseError>,
    ) -> Result<Promise, String> {
        callback_result.map_err(|e| format!("SocialDB::set() call failure: {:?}", e))?;

        self.grant_write_permission(external_db_id, self.iah_registry.clone(), deposit)
    }

    #[private]
    #[handle_result]
    pub fn on_ext_db_write_permission_granted(
        &mut self,
        external_db_id: AccountId,
        iah_registry: AccountId,
        #[callback_result] callback_result: Result<(), PromiseError>,
    ) -> Result<(), String> {
        callback_result.map_err(|e| {
            format!(
                "SocialDB::grant_write_permission(`{iah_registry}`) call failure: {:?}",
                e
            )
        })?;

        self.iah_registry = iah_registry;
        self.external_db_id = Some(external_db_id);

        Ok(())
    }
}

impl Contract {
    /// Check and panic if contract state [`RunningState`] is not set to [`RunningState::Running`]
    pub(crate) fn assert_contract_running(&self) {
        require!(
            self.running_state == RunningState::Running,
            "Contract paused"
        );
    }

    /// Asserts if the caller is not an owner/admin of this contract
    pub(crate) fn assert_owner(&self) {
        require!(self.is_owner(&env::predecessor_account_id()), "Not allowed");
    }

    /// Return [`bool`] which represents if [`AccountId`] is an owner/admin of this contract or not
    pub(crate) fn is_owner(&self, account_id: &AccountId) -> bool {
        account_id == &self.owner_id
    }

    /// Return [`AccountId`] of NEAR social db smart contract used by this contract or an error if not set
    pub(crate) fn external_db_id(&self) -> Result<&AccountId, &'static str> {
        self.external_db_id.as_ref().ok_or("External db is not set")
    }
}

'''
'''--- src/external_db.rs ---
use near_sdk::serde::Serialize;
use near_sdk::serde_json::Value;
use near_sdk::{ext_contract, AccountId, Promise, PromiseOrValue, PublicKey};

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct GetOptions {
    pub with_block_height: Option<bool>,
    pub with_node_id: Option<bool>,
    pub return_deleted: Option<bool>,
}

#[allow(unused)]
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub enum KeysReturnType {
    True,
    BlockHeight,
    NodeId,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct KeysOptions {
    pub return_type: Option<KeysReturnType>,
    pub return_deleted: Option<bool>,
}

#[ext_contract(ext_db)]
pub trait DatabaseProvider {
    fn set(&mut self, data: Value) -> Result<Promise, &'static str>;

    fn get(&self, keys: Vec<String>, options: Option<GetOptions>) -> PromiseOrValue<Value>;

    fn keys(&self, keys: Vec<String>, options: Option<KeysOptions>) -> PromiseOrValue<Value>;

    fn grant_write_permission(
        &mut self,
        predecessor_id: Option<AccountId>,
        public_key: Option<PublicKey>,
        keys: Vec<String>,
    ) -> Result<Promise, &'static str>;
}

'''
'''--- src/lib.rs ---
mod callbacks;
mod consts;
mod contract;
mod external_db;
mod misc;
mod public;
pub mod registry;
mod settings;
#[cfg(test)]
pub mod tests;
mod types;
pub mod utils;

pub use consts::*;
pub use contract::*;
pub use types::*;

'''
'''--- src/misc.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

/// This type represents this contract state
///
/// Public methods are available only while this contract is in [`Running`](RunningState::Running) state
#[derive(BorshDeserialize, BorshSerialize, PartialEq)]
pub enum RunningState {
    Running,
    Paused,
}

'''
'''--- src/public.rs ---
use crate::registry::{ext_sbtreg, IS_HUMAN_GAS};
use crate::settings::Settings;
use crate::types::{Commentary, KudosId, KudosKind, WrappedCid};
use crate::{consts::*, CommentId, EncodedCommentary};
use crate::{utils::*, GIVE_KUDOS_COST};
use crate::{Contract, ContractExt};
use near_sdk::serde_json::Value;
use near_sdk::{env, near_bindgen, require, AccountId, Promise};

#[near_bindgen]
impl Contract {
    /// Allows caller to exchange kudos associated with [`KudosId`] for ProofOfKudos SBT.
    /// Caller should have a valid i-am-human SBT. Every unique [`KudosId`] could be exchanged only once and
    /// only if it has sufficient amount of upvotes. Calls `sbt_mint` of i-am-human-registry contract.
    #[payable]
    #[handle_result]
    pub fn exchange_kudos_for_sbt(&mut self, kudos_id: KudosId) -> Result<Promise, &'static str> {
        self.assert_contract_running();

        let minimum_gas_requirement = EXCHANGE_KUDOS_FOR_SBT_RESERVED_GAS
            + IS_HUMAN_GAS
            + ACQUIRE_NUMBER_OF_UPVOTES_RESERVED_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_UPVOTES_ACQUIRED_CALLBACK_GAS
            + PROOF_OF_KUDOS_SBT_MINT_GAS
            + PROOF_OF_KUDOS_SBT_MINT_CALLBACK_GAS
            + FAILURE_CALLBACK_GAS;
        require!(
            env::prepaid_gas() >= minimum_gas_requirement,
            display_gas_requirement_in_tgas(minimum_gas_requirement)
        );

        let attached_deposit = env::attached_deposit();
        require!(
            attached_deposit == EXCHANGE_KUDOS_COST,
            &display_deposit_requirement_in_near(EXCHANGE_KUDOS_COST)
        );

        if self.exchanged_kudos.contains(&kudos_id) {
            return Err("Kudos is already exchanged");
        }

        let predecessor_account_id = env::predecessor_account_id();
        let external_db_id = self.external_db_id()?.clone();

        let gas_remaining = env::prepaid_gas()
            - (env::used_gas() + IS_HUMAN_GAS + EXCHANGE_KUDOS_FOR_SBT_RESERVED_GAS);

        Ok(ext_sbtreg::ext(self.iah_registry.clone())
            .with_static_gas(IS_HUMAN_GAS)
            .is_human(env::signer_account_id())
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(gas_remaining)
                    .acquire_number_of_upvotes(
                        predecessor_account_id,
                        attached_deposit.into(),
                        external_db_id,
                        kudos_id,
                    ),
            ))
    }

    /// Allows caller to leave a commentary message [`String`] to a kudos associated with [`KudosId`]
    /// for a user by [`AccountId`]. Caller should have a valid i-am-human SBT and can't leave
    /// commentary message for his own kudos.
    #[payable]
    #[handle_result]
    pub fn leave_comment(
        &mut self,
        receiver_id: AccountId,
        kudos_id: KudosId,
        parent_comment_id: Option<CommentId>,
        message: String,
    ) -> Result<Promise, String> {
        self.assert_contract_running();

        let predecessor_account_id = env::predecessor_account_id();
        let sender_id = env::signer_account_id();

        let minimum_gas_requirement = LEAVE_COMMENT_RESERVED_GAS
            + IS_HUMAN_GAS
            + ACQUIRE_KUDOS_INFO_RESERVED_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_INFO_ACQUIRED_CALLBACK_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_COMMENT_SAVED_CALLBACK_GAS
            + FAILURE_CALLBACK_GAS;
        require!(
            env::prepaid_gas() >= minimum_gas_requirement,
            display_gas_requirement_in_tgas(minimum_gas_requirement)
        );

        let attached_deposit = env::attached_deposit();
        require!(
            attached_deposit == LEAVE_COMMENT_COST,
            &display_deposit_requirement_in_near(LEAVE_COMMENT_COST)
        );

        if message.len() > Settings::from(&self.settings).commentary_message_max_length  as usize {
            return Err("Message max length exceeded".to_string());
        }
        let external_db_id = self.external_db_id()?.clone();
        let comment = EncodedCommentary::try_from(&Commentary {
            sender_id: &sender_id,
            message: &Value::String(message),
            timestamp: env::block_timestamp_ms().into(),
            parent_comment_id: parent_comment_id.as_ref(),
        })?;

        let gas_remaining =
            env::prepaid_gas() - (env::used_gas() + IS_HUMAN_GAS + LEAVE_COMMENT_RESERVED_GAS);

        Ok(ext_sbtreg::ext(self.iah_registry.clone())
            .with_static_gas(IS_HUMAN_GAS)
            .is_human(env::signer_account_id())
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(gas_remaining)
                    .acquire_kudos_info(
                        predecessor_account_id,
                        attached_deposit.into(),
                        external_db_id,
                        receiver_id,
                        kudos_id,
                        parent_comment_id,
                        comment,
                    ),
            ))
    }

    /// Allows caller to upvote kudos associated with [`KudosId`] for a user by [`AccountId`].
    /// Caller should have a valid i-am-human SBT and can't upvote his own kudos.
    #[payable]
    #[handle_result]
    pub fn upvote_kudos(
        &mut self,
        receiver_id: AccountId,
        kudos_id: KudosId,
    ) -> Result<Promise, &'static str> {
        self.assert_contract_running();

        let predecessor_account_id = env::predecessor_account_id();
        let sender_id = env::signer_account_id();
        require!(
            receiver_id != sender_id,
            "User is not eligible to upvote this kudos"
        );

        let minimum_gas_requirement = UPVOTE_KUDOS_RESERVED_GAS
            + IS_HUMAN_GAS
            + ACQUIRE_KUDOS_SENDER_RESERVED_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_SENDER_ACQUIRED_CALLBACK_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_UPVOTE_SAVED_CALLBACK_GAS
            + FAILURE_CALLBACK_GAS;
        require!(
            env::prepaid_gas() >= minimum_gas_requirement,
            display_gas_requirement_in_tgas(minimum_gas_requirement)
        );

        let attached_deposit = env::attached_deposit();
        require!(
            attached_deposit == UPVOTE_KUDOS_COST,
            &display_deposit_requirement_in_near(UPVOTE_KUDOS_COST)
        );

        let external_db_id = self.external_db_id()?.clone();
        let gas_remaining =
            env::prepaid_gas() - (env::used_gas() + IS_HUMAN_GAS + UPVOTE_KUDOS_RESERVED_GAS);

        Ok(ext_sbtreg::ext(self.iah_registry.clone())
            .with_static_gas(IS_HUMAN_GAS)
            .is_human(env::signer_account_id())
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(gas_remaining)
                    .acquire_kudos_sender(
                        predecessor_account_id,
                        attached_deposit.into(),
                        external_db_id,
                        receiver_id,
                        kudos_id,
                    ),
            ))
    }

    /// Allows caller to give kudos for a user by [`AccountId`].
    /// Caller should have a valid i-am-human SBT and can't give kudos to himself.
    /// Hashtags is an array of [`String`] for which only alphanumeric characters, underscores and gyphens are allowed to use.
    #[payable]
    #[handle_result]
    pub fn give_kudos(
        &mut self,
        receiver_id: AccountId,
        kind: Option<KudosKind>,
        message: String,
        icon_cid: Option<WrappedCid>,
        hashtags: Option<Vec<String>>,
    ) -> Result<Promise, &'static str> {
        self.assert_contract_running();

        let predecessor_account_id = env::predecessor_account_id();
        let sender_id = env::signer_account_id();
        require!(
            receiver_id != sender_id,
            "User is not eligible to upvote this kudos"
        );

        let minimum_gas_requirement = GIVE_KUDOS_RESERVED_GAS
            + IS_HUMAN_GAS
            + SAVE_KUDOS_RESERVED_GAS
            + SOCIAL_DB_REQUEST_MIN_RESERVED_GAS
            + KUDOS_SAVED_CALLBACK_GAS
            + FAILURE_CALLBACK_GAS;
        require!(
            env::prepaid_gas() >= minimum_gas_requirement,
            display_gas_requirement_in_tgas(minimum_gas_requirement)
        );

        let attached_deposit = env::attached_deposit();
        require!(
            attached_deposit == GIVE_KUDOS_COST,
            &display_deposit_requirement_in_near(GIVE_KUDOS_COST)
        );

        let settings = Settings::from(&self.settings);
        let kind = kind.unwrap_or_default();
        let hashtags = settings.validate_hashtags(hashtags.as_deref())?;
        if message.len() > Settings::from(&self.settings).commentary_message_max_length  as usize {
            return Err("Message max length exceeded");
        }

        let external_db_id = self.external_db_id()?.clone();

        let gas_remaining =
            env::prepaid_gas() - (env::used_gas() + IS_HUMAN_GAS + GIVE_KUDOS_RESERVED_GAS);

        Ok(ext_sbtreg::ext(self.iah_registry.clone())
            .with_static_gas(IS_HUMAN_GAS)
            .is_human(sender_id)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(gas_remaining)
                    .save_kudos(
                        predecessor_account_id,
                        attached_deposit.into(),
                        external_db_id,
                        receiver_id,
                        kind,
                        message,
                        icon_cid,
                        hashtags,
                    ),
            ))
    }
}

'''
'''--- src/registry.rs ---
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{ext_contract, AccountId, Gas, Promise};

pub type TokenId = u64;

pub const IS_HUMAN_GAS: Gas = Gas(12 * Gas::ONE_TERA.0);

/// TokenMetadata defines attributes for each SBT token.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub class: u64,                          // token class
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OwnedToken {
    pub token: u64,
    pub metadata: TokenMetadata,
}

#[ext_contract(ext_sbtreg)]
pub trait ExtSbtRegistry {
    /*
    fn is_human_call(
        &mut self,
        account: AccountId,
        ctr: AccountId,
        function: String,
        args: Base64VecU8,
    ) -> PromiseOrValue<bool>;
    */

    fn is_human(&self, account: AccountId) -> Vec<(AccountId, Vec<TokenId>)>;

    fn sbt_mint(&mut self, token_spec: Vec<(AccountId, Vec<TokenMetadata>)>) -> Promise;
}

'''
'''--- src/settings.rs ---
use crate::utils::opt_default;
use crate::Hashtag;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

/// Settings for this contract
#[derive(BorshDeserialize, BorshSerialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub struct Settings {
    pub commentary_message_max_length: u16,
    pub max_number_of_hashtags_per_kudos: u8,
    pub hashtag_text_max_length: u8,
    pub min_number_of_upvotes_to_exchange_kudos: u8,
    pub pok_sbt_ttl: u64,
}

#[derive(BorshDeserialize, BorshSerialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub enum VSettings {
    // Add old versions here, keep ordering, the oldest on top, most recent at bottom
    // e.g. V0(SettingsV0),
    Current(Settings), // most recent version
}

/// View JSON serializable representation of `Settings` data struct
#[derive(Default, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde", rename_all = "camelCase")]
pub struct SettingsView {
    #[serde(default = "opt_default", skip_serializing_if = "Option::is_none")]
    pub commentary_message_max_length: Option<u16>,
    #[serde(default = "opt_default", skip_serializing_if = "Option::is_none")]
    pub max_number_of_hashtags_per_kudos: Option<u8>,
    #[serde(default = "opt_default", skip_serializing_if = "Option::is_none")]
    pub hashtag_text_max_length: Option<u8>,
    #[serde(default = "opt_default", skip_serializing_if = "Option::is_none")]
    pub min_number_of_upvotes_to_exchange_kudos: Option<u8>,
    #[serde(default = "opt_default", skip_serializing_if = "Option::is_none")]
    pub pok_sbt_ttl: Option<u64>,
}

impl Settings {
    /// Apply optionally provided changes to settings
    fn apply_changes(mut self, settings_json: SettingsView) -> Self {
        if let Some(commentary_message_max_length) = settings_json.commentary_message_max_length {
            self.commentary_message_max_length = commentary_message_max_length;
        }

        if let Some(max_number_of_hashtags_per_kudos) =
            settings_json.max_number_of_hashtags_per_kudos
        {
            self.max_number_of_hashtags_per_kudos = max_number_of_hashtags_per_kudos;
        }

        if let Some(hashtag_text_max_length) = settings_json.hashtag_text_max_length {
            self.hashtag_text_max_length = hashtag_text_max_length;
        }

        if let Some(min_number_of_upvotes_to_exchange_kudos) =
            settings_json.min_number_of_upvotes_to_exchange_kudos
        {
            self.min_number_of_upvotes_to_exchange_kudos = min_number_of_upvotes_to_exchange_kudos;
        }

        if let Some(pok_sbt_ttl) = settings_json.pok_sbt_ttl {
            self.pok_sbt_ttl = pok_sbt_ttl;
        }

        self
    }

    /// Validate and convert array slice of [String] to an array of [Hashtag]
    pub(crate) fn validate_hashtags(
        &self,
        hashtags: Option<&[String]>,
    ) -> Result<Option<Vec<Hashtag>>, &'static str> {
        let Some(hashtags) = hashtags else { return Ok(None) };

        if hashtags.len() > self.max_number_of_hashtags_per_kudos as usize {
            return Err("Maximum number of hashtags per Kudos exceeded");
        }

        hashtags
            .iter()
            .map(|ht_text| Hashtag::new(ht_text, self.hashtag_text_max_length as usize))
            .collect::<Result<Vec<_>, _>>()
            .map(Some)
    }

    pub(crate) fn acquire_pok_sbt_expire_at_ts(&self, issued_at: u64) -> Result<u64, &'static str> {
        issued_at
            .checked_add(self.pok_sbt_ttl)
            .ok_or("ProofOfKudos SBT expiration date overflow")
    }
}

impl VSettings {
    /// Helper function to migrate settings to the current version and apply changes
    pub(crate) fn apply_changes(&self, settings_json: SettingsView) -> Self {
        Settings::from(self).apply_changes(settings_json).into()
    }
}

fn default_commentary_message_max_length() -> u16 {
    1000
}

fn default_max_number_of_hashtags_per_kudos() -> u8 {
    10
}

fn default_hashtag_text_max_length() -> u8 {
    32
}

fn default_min_number_of_upvotes_to_exchange_kudos() -> u8 {
    3
}

fn default_pok_sbt_ttl() -> u64 {
    365 * 86_400_000
}

impl Default for Settings {
    fn default() -> Self {
        Self {
            commentary_message_max_length: default_commentary_message_max_length(),
            max_number_of_hashtags_per_kudos: default_max_number_of_hashtags_per_kudos(),
            hashtag_text_max_length: default_hashtag_text_max_length(),
            min_number_of_upvotes_to_exchange_kudos:
                default_min_number_of_upvotes_to_exchange_kudos(),
            pok_sbt_ttl: default_pok_sbt_ttl(),
        }
    }
}

impl From<&VSettings> for Settings {
    fn from(v_settings: &VSettings) -> Self {
        match v_settings {
            VSettings::Current(settings) => settings.clone(),
            // TODO: add any migration stuff below
            // e.g. VSettings::V0(settings_v0) => Settings::from(settings_v0),
        }
    }
}

// TODO: impl From<&OLD_VERSION_STRUCT> for CURRENT_VERSION_STRUCT
// e.g. impl From<&SettingsV0> for Settings

impl From<Settings> for VSettings {
    fn from(settings: Settings) -> Self {
        Self::Current(settings)
    }
}

impl From<Settings> for SettingsView {
    fn from(settings: Settings) -> Self {
        Self {
            commentary_message_max_length: Some(settings.commentary_message_max_length),
            max_number_of_hashtags_per_kudos: Some(settings.max_number_of_hashtags_per_kudos),
            hashtag_text_max_length: Some(settings.hashtag_text_max_length),
            min_number_of_upvotes_to_exchange_kudos: Some(
                settings.min_number_of_upvotes_to_exchange_kudos,
            ),
            pok_sbt_ttl: Some(settings.pok_sbt_ttl),
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::{settings::Settings, Hashtag};
    use assert_matches::assert_matches;

    #[test]
    fn test_validate_hashtags() {
        let settings = Settings::default();
        assert_matches!(settings.validate_hashtags(None), Ok(None));
        assert_matches!(settings.validate_hashtags(Some(&[])), Ok(_));
        assert_eq!(
            settings.validate_hashtags(Some(vec!["abc".to_owned(), "1Def".to_owned()].as_slice())),
            Ok(Some(vec![
                Hashtag::new_unchecked("abc"),
                Hashtag::new_unchecked("1Def")
            ]))
        );
        assert_matches!(
            settings.validate_hashtags(Some(vec!["abc".to_owned(), "@ABC".to_owned()].as_slice())),
            Err(_)
        );
        assert_matches!(
            settings.validate_hashtags(Some(vec!["a".repeat(33)].as_slice())),
            Err(_)
        );
    }
}

'''
'''--- src/tests/mod.rs ---
mod tests_exchange_kudos_for_sbt;
mod utils;

'''
'''--- src/tests/tests_exchange_kudos_for_sbt.rs ---
use crate::consts::{EXCHANGE_KUDOS_COST, EXCHANGE_KUDOS_STORAGE};
use crate::tests::utils::{build_default_context, promise_or_value_result_into_result, MAX_GAS};
use crate::utils::{build_kudos_kind_path, build_kudos_upvotes_path};
use crate::{Contract, IncrementalUniqueId, KudosId, PROOF_OF_KUDOS_SBT_MINT_COST};
use near_sdk::borsh::BorshSerialize;
use near_sdk::serde_json::json;
use near_sdk::test_utils::accounts;
use near_sdk::{
    env, testing_env, AccountId, Gas, PromiseError, PromiseResult, RuntimeFeesConfig, VMConfig,
};
use std::collections::HashMap;

#[test]
fn test_required_storage_to_exchange_kudos() {
    testing_env!(build_default_context(accounts(0), None, Some(Gas::ONE_TERA)).build());

    let mut kudos_contract = Contract::init(
        Some(accounts(0)),
        AccountId::new_unchecked("iah_registry.near".to_owned()),
    );

    let initial_storage = env::storage_usage();
    kudos_contract
        .exchanged_kudos
        .insert(IncrementalUniqueId::default().next().into());
    assert_eq!(
        env::storage_usage() - initial_storage,
        EXCHANGE_KUDOS_STORAGE
    );
}

#[test]
fn test_required_deposit_to_exchange_kudos() -> anyhow::Result<()> {
    let contract_id = AccountId::new_unchecked("kudos.near".to_owned());
    testing_env!(
        build_default_context(contract_id.clone(), None, Some(MAX_GAS),)
            .attached_deposit(EXCHANGE_KUDOS_COST)
            .prepaid_gas(MAX_GAS)
            .build(),
        VMConfig::test(),
        RuntimeFeesConfig::test(),
        HashMap::default(),
        vec![PromiseResult::Successful(vec![1u64].try_to_vec().unwrap())],
    );

    let initial_balance = env::account_balance();
    let mut kudos_contract = Contract::init(
        Some(contract_id.clone()),
        AccountId::new_unchecked("iah_registry.near".to_owned()),
    );

    let kudos_id = KudosId::from(IncrementalUniqueId::default().next());
    let receiver_id = accounts(0);
    let sender_id = accounts(1);
    let kudos_upvotes_path = build_kudos_upvotes_path(&contract_id, &receiver_id, &kudos_id);
    let kudos_kind_path = build_kudos_kind_path(&contract_id, &receiver_id, &kudos_id);
    kudos_contract.on_kudos_upvotes_acquired(
        sender_id.clone(),
        EXCHANGE_KUDOS_COST.into(),
        kudos_id.clone(),
        kudos_upvotes_path.clone(),
        kudos_kind_path.clone(),
        Ok(json!({
            "kudos.near": {
              "kudos": {
                "alice": {
                  "1": {
                    "kind": "k",
                    "upvotes": {
                      "charlie": "",
                      "danny": "",
                      "eugene": ""
                    }
                  }
                }
              }
            }
        })),
    );
    // There is no way to verify if callback failed or not, because it never panics and
    // calls another failure callback in case of failure. So we verify balance change,
    // if we get full refund then it's an error, otherwise we attach `PROOF_OF_KUDOS_SBT_MINT_COST`
    // to next XCC
    let used_deposit = initial_balance - env::account_balance();
    assert_eq!(used_deposit, PROOF_OF_KUDOS_SBT_MINT_COST);

    let initial_balance = env::account_balance();
    kudos_contract.on_kudos_upvotes_acquired(
        sender_id.clone(),
        EXCHANGE_KUDOS_COST.into(),
        kudos_id.clone(),
        kudos_upvotes_path.clone(),
        kudos_kind_path.clone(),
        Ok(json!({
            "kudos.near": {
              "kudos": {
                "alice": {
                  "1": {
                    "upvotes": {}
                  }
                }
              }
            }
        })),
    );
    // Not enough upvotes, full attached deposit returned
    let transferred_deposit = initial_balance - env::account_balance();
    assert_eq!(transferred_deposit, EXCHANGE_KUDOS_COST);

    let initial_balance = env::account_balance();
    kudos_contract.on_kudos_upvotes_acquired(
        sender_id,
        EXCHANGE_KUDOS_COST.into(),
        kudos_id,
        kudos_upvotes_path,
        kudos_kind_path,
        Ok(json!({
            "kudos.near": {
              "kudos": {
                "alice": {
                  "1": {
                    "kind": "d",
                    "upvotes": {
                      "charlie": "",
                      "danny": "",
                      "eugene": ""
                    }
                  }
                }
              }
            }
        })),
    );
    // Ding kind couldn't be exchanged, full attached deposit returned
    let transferred_deposit = initial_balance - env::account_balance();
    assert_eq!(transferred_deposit, EXCHANGE_KUDOS_COST);

    Ok(())
}

#[test]
fn test_on_pok_sbt_mint() {
    let contract_id = AccountId::new_unchecked("kudos.near".to_owned());
    let context = build_default_context(contract_id.clone(), None, Some(MAX_GAS))
        .attached_deposit(EXCHANGE_KUDOS_COST)
        .build();

    let mut kudos_contract = Contract::init(
        Some(contract_id),
        AccountId::new_unchecked("iah_registry.near".to_owned()),
    );

    let sender_id = accounts(0);
    let kudos_id = KudosId::from(IncrementalUniqueId::default().next());

    struct TestCase<'a> {
        name: &'a str,
        input: Result<Vec<u64>, PromiseError>,
        output: Result<String, String>,
    }

    let test_cases = [
        TestCase {
            name: "SBT mint successful",
            input: Ok(vec![1u64]),
            output: Ok("[1]".to_owned()),
        },
        TestCase {
            name: "SBT mint failure",
            input: Ok(vec![]),
            output: Err("IAHRegistry::sbt_mint() responses with an empty tokens array".to_owned()),
        },
        TestCase {
            name: "Promise error",
            input: Err(near_sdk::PromiseError::Failed),
            output: Ok("Promise".to_owned()),
        },
    ];

    for test_case in test_cases {
        testing_env!(context.clone());

        assert_eq!(
            promise_or_value_result_into_result(kudos_contract.on_pok_sbt_mint(
                sender_id.clone(),
                EXCHANGE_KUDOS_COST.into(),
                kudos_id.clone(),
                test_case.input
            )),
            test_case.output,
            "Test case `{} failure`",
            test_case.name
        );
    }
}

'''
'''--- src/tests/utils.rs ---
use near_sdk::PromiseOrValue;
use near_sdk::{test_utils::VMContextBuilder, AccountId, Balance, Gas};

pub const MAX_GAS: Gas = Gas(300_000_000_000_000);

pub fn build_default_context(
    predecessor_account_id: AccountId,
    deposit: Option<Balance>,
    prepaid_gas: Option<Gas>,
) -> VMContextBuilder {
    let mut builder = VMContextBuilder::new();
    builder
        .signer_account_id(predecessor_account_id.clone())
        .predecessor_account_id(predecessor_account_id)
        .prepaid_gas(prepaid_gas.unwrap_or(MAX_GAS))
        .attached_deposit(deposit.unwrap_or_default());
    builder
}

pub fn promise_or_value_result_into_result<T: std::fmt::Debug>(
    value: Result<PromiseOrValue<T>, &'static str>,
) -> Result<String, String> {
    match value {
        Ok(PromiseOrValue::Promise(_)) => Ok("Promise".to_owned()),
        Ok(PromiseOrValue::Value(res)) => Ok(format!("{res:?}")),
        Err(e) => Err(e.to_owned()),
    }
}

'''
'''--- src/types.rs ---
use cid::Cid;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U64;
use near_sdk::serde::{self, de, Deserialize, Deserializer, Serialize, Serializer};
use near_sdk::serde_json::Value;
use near_sdk::{serde_json, AccountId, BorshStorageKey};
use std::fmt::Display;
use std::hash::{Hash, Hasher};
use std::str::FromStr;

/// This type represents a unique incremental identifier
#[derive(BorshDeserialize, BorshSerialize)]
pub struct IncrementalUniqueId(U64);

impl IncrementalUniqueId {
    /// Return [`u64`] representation of this [`IncrementalUniqueId`]
    pub fn as_u64(&self) -> u64 {
        self.0 .0
    }

    /// Increment self-stored value and returns self-reference
    pub fn inc(&mut self) -> &Self {
        self.0 = self.next().0;
        self
    }

    /// Compute the next identifier
    pub fn next(&self) -> Self {
        Self((self.as_u64() + 1).into())
    }
}

impl Default for IncrementalUniqueId {
    fn default() -> Self {
        Self(0.into())
    }
}

/// This type represents a unique identifier of the kudos.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct KudosId(U64);

impl From<IncrementalUniqueId> for KudosId {
    fn from(value: IncrementalUniqueId) -> Self {
        Self(value.0)
    }
}

impl From<&IncrementalUniqueId> for KudosId {
    fn from(value: &IncrementalUniqueId) -> Self {
        Self(value.0)
    }
}

impl Display for KudosId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self.0 .0, f)
    }
}

/// This type represents a unique identifier of the commentary message.
#[derive(Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Eq, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct CommentId(U64);

impl CommentId {
    /// Creates [`CommentId`] from identifier without guarantee for validness & uniqueness
    #[cfg(not(target_arch = "wasm32"))]
    pub fn new_unchecked(id: u64) -> Self {
        Self(id.into())
    }
}

impl Hash for CommentId {
    fn hash<H: Hasher>(&self, state: &mut H) {
        self.0 .0.hash(state);
    }
}

impl From<IncrementalUniqueId> for CommentId {
    fn from(value: IncrementalUniqueId) -> Self {
        Self(value.0)
    }
}

impl From<&IncrementalUniqueId> for CommentId {
    fn from(value: &IncrementalUniqueId) -> Self {
        Self(value.0)
    }
}

impl Display for CommentId {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self.0 .0, f)
    }
}

/// The type of storage key used as key prefix in contract storage
#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    Kudos,
}

/// Commentary message data struct which serializes to base64-encoded [`String`] for subsequent store in NEAR social db
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
pub struct Commentary<'a> {
    /// A message with escaped characters to guarantee safety of stringification
    pub message: &'a Value,
    /// A valid [`AccountId`] of a message sender
    pub sender_id: &'a AccountId,
    /// The timestamp in milliseconds when commentary message were prepared
    pub timestamp: U64,
    /// Parent commentary id which were replied
    pub parent_comment_id: Option<&'a CommentId>,
}

/// Raw commentary message data struct which serializes to [`Value`](near_sdk::serde_json::Value)
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct CommentaryRaw<'a> {
    /// A message with escaped characters to guarantee safety of stringification
    #[serde(rename = "m")]
    pub message: &'a Value,
    /// A valid [`AccountId`] of a message sender
    #[serde(rename = "s")]
    pub sender_id: &'a AccountId,
    /// The timestamp in milliseconds when commentary message were prepared
    #[serde(rename = "t")]
    pub timestamp: U64,
    /// Parent commentary id which were replied
    #[serde(rename = "p", skip_serializing_if = "Option::is_none")]
    pub parent_comment_id: Option<&'a CommentId>,
}

impl Serialize for Commentary<'_> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: near_sdk::serde::Serializer,
    {
        let encoded = near_sdk::base64::encode(
            serde_json::to_string(&CommentaryRaw {
                message: self.message,
                sender_id: self.sender_id,
                timestamp: self.timestamp,
                parent_comment_id: self.parent_comment_id,
            })
            .map_err(near_sdk::serde::ser::Error::custom)?,
        );

        serializer.serialize_str(&encoded)
    }
}

/// This type represents a [`String`] for which only ascii alphanumeric characters, underscores and gyphens are allowed to use
#[derive(Deserialize, Serialize, Ord, PartialOrd, PartialEq, Eq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct Hashtag(String);

impl Hashtag {
    /// Create [`Hashtag`] from ascii ref string, verify maximum length and check for allowed characters
    pub fn new(hashtag: &str, max_lenth: usize) -> Result<Self, &'static str> {
        if hashtag.len() > max_lenth {
            return Err("Hashtag max text length exceeded");
        }

        if hashtag.contains(|c: char| !c.is_ascii_alphanumeric() && !matches!(c, '_' | '-')) {
            return Err(
                "Only alphanumeric characters, underscores and gyphens are allowed for hashtag",
            );
        }

        Ok(Self(hashtag.to_owned()))
    }

    /// Creates [`Hashtag`] from ref string without length and characters check
    #[cfg(not(target_arch = "wasm32"))]
    pub fn new_unchecked(hashtag: &str) -> Self {
        Self(hashtag.to_owned())
    }
}

/// This type represents a JSON [`String`] view of [`Commentary`]
#[derive(Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct EncodedCommentary(String);

impl EncodedCommentary {
    pub fn as_str(&self) -> &str {
        self.0.as_str()
    }

    /// Creates [`EncodedCommentary`] from [`String`] without verification if it can be deserialized
    #[cfg(not(target_arch = "wasm32"))]
    pub fn new_unchecked(encoded: String) -> Self {
        Self(encoded)
    }
}

impl TryFrom<&Commentary<'_>> for EncodedCommentary {
    type Error = String;

    fn try_from(value: &Commentary<'_>) -> Result<Self, Self::Error> {
        serde_json::to_value(value)
            .and_then(|val| {
                val.as_str()
                    .map(|s| Self(s.to_owned()))
                    .ok_or(serde::ser::Error::custom("Not a string"))
            })
            .map_err(|e| format!("Unable to encode commentary: {e}"))
    }
}

impl Display for EncodedCommentary {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        Display::fmt(&self.0, f)
    }
}

/// This type represents a wrapped serializable version of [`Cid`]
pub struct WrappedCid(Cid);

impl WrappedCid {
    /// Creates [`WrappedCid`] from ref string
    pub fn new(cid: &str) -> Result<Self, &'static str> {
        if cid.len() > 64 {
            return Err("Cid is too long");
        }
        Cid::from_str(cid)
            .map_err(|_| "Not a valid Cid")
            .map(WrappedCid)
    }
}

impl Display for WrappedCid {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl<'de> Deserialize<'de> for WrappedCid {
    fn deserialize<D>(deserializer: D) -> Result<WrappedCid, D::Error>
    where
        D: Deserializer<'de>,
    {
        let cid_text = <String as Deserialize>::deserialize(deserializer)?;

        Cid::from_str(&cid_text)
            .map(WrappedCid)
            .map_err(|e| de::Error::custom(format!("Failed to deserialize CID: {e:?}")))
    }
}

impl Serialize for WrappedCid {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        serializer.serialize_str(&self.0.to_string())
    }
}

/// The type of a kudos given
///
/// [`Kudos`](KudosKind::Kudos) represents a positive kudos, while [`Ding`](KudosKind::Ding) represents a negative one
#[derive(Serialize, Deserialize, Default, PartialEq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug))]
#[serde(crate = "near_sdk::serde")]
pub enum KudosKind {
    #[default]
    #[serde(rename = "k")]
    Kudos,
    #[serde(rename = "d")]
    Ding,
}

impl Display for KudosKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let kind = match self {
            Self::Kudos => "k",
            Self::Ding => "d",
        };

        write!(f, "{kind}")
    }
}

#[cfg(test)]
mod tests {
    use crate::{CommentId, Commentary, EncodedCommentary, Hashtag, WrappedCid};
    use near_sdk::json_types::U64;
    use near_sdk::AccountId;
    use near_sdk::serde_json::Value;

    #[test]
    fn test_commentary_encoding() {
        let comment = EncodedCommentary::try_from(&Commentary {
            sender_id: &AccountId::new_unchecked("user.near".to_owned()),
            message: &Value::String("commentary test".to_string()),
            timestamp: U64(1234567890),
            parent_comment_id: None,
        })
        .unwrap();
        assert_eq!(
            comment.as_str(),
            "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicyI6InVzZXIubmVhciIsInQiOiIxMjM0NTY3ODkwIn0="
        );

        let comment = EncodedCommentary::try_from(&Commentary {
            sender_id: &AccountId::new_unchecked("user.near".to_owned()),
            message: &Value::String("commentary test".to_string()),
            timestamp: U64(1234567890),
            parent_comment_id: Some(&CommentId::new_unchecked(1u64)),
        })
        .unwrap();
        assert_eq!(
            comment.as_str(),
            "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicyI6InVzZXIubmVhciIsInQiOiIxMjM0NTY3ODkwIiwicCI6IjEifQ=="
        );
    }

    #[test]
    fn test_hashtag_from_str() {
        assert!(Hashtag::new("validhashtag", 32).is_ok());
        assert!(Hashtag::new("val1dhAshta9", 32).is_ok());
        assert!(Hashtag::new("va-li-d_hashtag", 32).is_ok());
        assert!(Hashtag::new("invalid+hashtag", 32).is_err());
        assert!(Hashtag::new("invalidha$ht@g", 32).is_err());
        assert!(Hashtag::new("toolonghashtag", 8).is_err());
    }

    #[test]
    fn test_wrapped_cid() {
        assert!(WrappedCid::new("invalid_cid").is_err());
        // Verify V1 CID
        assert_eq!(
            WrappedCid::new("bafkreieq5jui4j25lacwomsqgjeswwl3y5zcdrresptwgmfylxo2depppq")
                .unwrap()
                .to_string()
                .as_str(),
            "bafkreieq5jui4j25lacwomsqgjeswwl3y5zcdrresptwgmfylxo2depppq"
        );
        // Verify V0 CID
        assert_eq!(
            &format!(
                "{}",
                WrappedCid::new("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n").unwrap()
            ),
            "QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n"
        );
    }
}

'''
'''--- src/utils.rs ---
use crate::consts::PROOF_OF_KUDOS_SBT_CLASS_ID;
use crate::registry::TokenMetadata;
use crate::types::KudosId;
use crate::{CommentId, EncodedCommentary, Hashtag, KudosKind, WrappedCid};
use near_sdk::env::STORAGE_PRICE_PER_BYTE;
use near_sdk::serde_json::{self, Value};
use near_sdk::{AccountId, Balance, Gas};

/// Return initial object as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// {
///   "kudos.near": {
///     "kudos": {},
///     "hashtags": {}
///   }
/// }
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for all public methods
pub fn build_initial_json_for_socialdb(root_id: &AccountId) -> Result<Value, &'static str> {
    serde_json::from_str::<Value>(&format!(
        r#"{{
          "{root_id}": {{
            "kudos": {{}},
            "hashtags": {{}}
          }}
        }}"#
    ))
    .map_err(|_| "Internal serialization error")
}

/// Return hashtags relationship to kudos and it's owner as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// {
///   "lovendc": {
///     "1": "ndc.near",
///     ...
///   },
///   ...
/// }
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for public method [`give_kudos`](kudos_contract::public::Contract::give_kudos)
pub fn build_hashtags(
    receiver_id: &AccountId,
    kudos_id: &KudosId,
    hashtags: Option<&[Hashtag]>,
) -> Result<String, &'static str> {
    hashtags
        .map(|hashtags| {
            hashtags
                .iter()
                .map(|ht| {
                    serde_json::from_str::<Value>(&format!(
                        r#"{{
                          "{kudos_id}": "{receiver_id}"
                        }}"#
                    ))
                    .map(|v| (ht, v))
                })
                .collect::<Result<std::collections::BTreeMap<_, _>, _>>()
                .and_then(|map| serde_json::to_string(&map))
                .map_err(|_| "Internal serialization error")
        })
        .unwrap_or_else(|| Ok("{}".to_owned()))
}

/// Return hashtags array as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// [
///   "nearcommunity",
///   "ndckudos",
///   ...
/// ]
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for public method [`give_kudos`](kudos_contract::public::Contract::give_kudos)
pub fn hashtags_to_json_array(hashtags: &[Hashtag]) -> Result<String, &'static str> {
    serde_json::to_string(&hashtags)
        .map(|s| s.escape_default().to_string())
        .map_err(|_| "Internal hashtags serialization error")
}

/// Return kudos object as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// {
///   "kudos.near": {
///     "kudos": {
///       "some_user.near": {
///         "1": {
///           "created_at": "1689976833613",
///           "sender_id": "alex.near",
///           "kind": "k",
///           "message": "that user is awesome",
///           "icon": "bafybeigrf2dwtpjkiovnigysyto3d55opf6qkdikx6d65onrqnfzwgdkfa",
///           "upvotes": {},
///           "comments": {},
///           "tags": "[\"firstkudos\",\"awesomework\"]",
///         }
///       }
///     },
///     "hashtags": {
///       "firstkudos": {
///         "1": "alex.near"
///       },
///       "awesomework": {
///         "1": "alex.near"
///       }
///     }
///   }
/// }
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for public method [`give_kudos`](kudos_contract::public::Contract::give_kudos)
pub fn build_give_kudos_request(
    root_id: &AccountId,
    sender_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
    created_at: u64,
    kind: KudosKind,
    message: &str,
    icon_cid: Option<&WrappedCid>,
    hashtags: Option<&[Hashtag]>,
) -> Result<Value, &'static str> {
    let hashtags_as_array_json = hashtags_to_json_array(hashtags.unwrap_or(&[]))?;
    let hashtags_with_kudos = build_hashtags(receiver_id, kudos_id, hashtags)?;
    let icon_cid = icon_cid.map(|cid| cid.to_string()).unwrap_or_default();

    let mes = near_sdk::serde_json::Value::String(message.to_string());
    serde_json::from_str::<Value>(&format!(
        r#"{{
          "{root_id}": {{
            "kudos": {{
              "{receiver_id}": {{
                "{kudos_id}": {{
                  "created_at": "{created_at}",
                  "sender_id": "{sender_id}",
                  "kind": "{kind}",
                  "message": {mes},
                  "icon": "{icon_cid}",
                  "upvotes": {{}},
                  "comments": {{}},
                  "tags": "{hashtags_as_array_json}"
                }}
              }}
            }},
            "hashtags": {hashtags_with_kudos}
          }}
        }}"#
    ))
    .map_err(|e| {
        println!("{e:?}");
        "Internal serialization error"
    })
}

/// Return upvotes for kudos object as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// {
///   "kudos.near": {
///     "kudos": {
///       "some_user.near": {
///         "1": {
///           "upvotes": {
///             "bob.near": ""
///           }
///         }
///       }
///     }
///   }
/// }
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for public method [`upvote_kudos`](kudos_contract::public::Contract::upvote_kudos)
pub fn build_upvote_kudos_request(
    root_id: &AccountId,
    sender_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
) -> Result<Value, &'static str> {
    serde_json::from_str::<Value>(&format!(
        r#"{{
          "{root_id}": {{
            "kudos": {{
              "{receiver_id}": {{
                "{kudos_id}": {{
                  "upvotes": {{
                    "{sender_id}": ""
                  }}
                }}
              }}
            }}
          }}
        }}"#
    ))
    .map_err(|_| "Internal serialization error")
}

/// Return base64-encoded commentary for kudos object as JSON [`String`] which will be stored in NEAR social db
///
/// Example of JSON output:
/// ```json
/// {
///   "kudos.near": {
///     "kudos": {
///       "some_user.near": {
///         "1": {
///           "comments": {
///             "2": "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicyI6InVzZXIubmVhciIsInQiOiIxMjM0NTY3ODkwIn0="
///           }
///         }
///       }
///     }
///   }
/// }
/// ```
///
/// ATTENTION: Changing this JSON output will require contract refactoring and re-computation
/// of deposit requirement for public method [`leave_comment`](kudos_contract::public::Contract::leave_comment)
pub fn build_leave_comment_request(
    root_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
    comment_id: &CommentId,
    comment: &EncodedCommentary,
) -> Result<Value, &'static str> {
    let comment = comment.as_str();
    let json = format!(
        r#"{{
          "{root_id}": {{
            "kudos": {{
              "{receiver_id}": {{
                "{kudos_id}": {{
                  "comments": {{
                    "{comment_id}": "{comment}"
                  }}
                }}
              }}
            }}
          }}
        }}"#
    );
    serde_json::from_str::<Value>(&json).map_err(|_| "Internal serialization error")
}

/// Return [`String`] path to a stored kudos JSON with unique [`KudosId`] for a valid [`AccountId`]
/// used to query from NEAR social db.
///
/// Example of query: "kudos.near/kudos/alex.near/1/*"
pub fn build_get_kudos_by_id_request(
    root_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
) -> String {
    format!("{root_id}/kudos/{receiver_id}/{kudos_id}/*")
}

/// Return [`String`] path to a stored kudos base64-encoded comment with unique [`KudosId`] and [`CommentId`]
/// for a valid [`AccountId`] used to query from NEAR social db.
///
/// Example of query: "kudos.near/kudos/alex.near/1/comments/2"
pub fn build_get_kudos_comment_by_id_request(
    root_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
    comment_id: &CommentId,
) -> String {
    format!("{root_id}/kudos/{receiver_id}/{kudos_id}/comments/{comment_id}")
}

/// Return [`String`] path to a stored upvotes information JSON with unique [`KudosId`] for a valid [`AccountId`]
/// used to query from NEAR social db.
///
/// Example of query: "kudos.near/kudos/alex.near/1/upvotes"
pub fn build_kudos_upvotes_path(
    root_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
) -> String {
    format!("{root_id}/kudos/{receiver_id}/{kudos_id}/upvotes")
}

/// Return [`String`] path to a stored kudos kind type with unique [`KudosId`] for a valid [`AccountId`]
/// used to query from NEAR social db.
///
/// Example of query: "kudos.near/kudos/bob.near/1/kind"
pub fn build_kudos_kind_path(
    root_id: &AccountId,
    receiver_id: &AccountId,
    kudos_id: &KudosId,
) -> String {
    format!("{root_id}/kudos/{receiver_id}/{kudos_id}/kind")
}

/// Return [`TokenMetadata`] used as an argument for call [`sbt_mint`](kudos_contract::registry::ExtSbtRegistry::sbt_mint)
/// to mint ProofOfKudos SBT
pub fn build_pok_sbt_metadata(issued_at: u64, expires_at: u64) -> TokenMetadata {
    TokenMetadata {
        class: PROOF_OF_KUDOS_SBT_CLASS_ID,
        issued_at: Some(issued_at),
        expires_at: Some(expires_at),
        reference: None,
        reference_hash: None,
    }
}

/// Extract sender [`AccountId`] from stored kudos JSON acquired from NEAR social db
pub fn extract_kudos_id_sender_from_response(req: &str, res: &mut Value) -> Option<AccountId> {
    remove_key_from_json(res, &req.replace('*', "sender_id"))
        .and_then(|val| serde_json::from_value::<AccountId>(val).ok())
}

/// Extract kudos base64-encoded comment [`EncodedCommentary`] by [`CommentId`] from stored kudos JSON acquired from NEAR social db
pub fn extract_kudos_encoded_comment_by_id_from_response(
    req: &str,
    comment_id: &CommentId,
    res: &mut Value,
) -> Option<EncodedCommentary> {
    remove_key_from_json(res, &req.replace('*', &format!("comments/{comment_id}")))
        .and_then(|val| serde_json::from_value::<EncodedCommentary>(val).ok())
}

/// Remove and return (if removed) [`serde_json::Value`] by key name [`str`] from JSON [`serde_json::Value`]
///
/// # Example:
/// ```
/// use kudos_contract::utils::remove_key_from_json;
/// use near_sdk::serde_json;
///
/// let mut initial_value = serde_json::json!({
///   "key1": {
///     "key2": {
///       "key3": {
///         "key4": "value"
///       }
///     }
///   }
/// });
/// let removed_value = remove_key_from_json(&mut initial_value, "key1/key2/key3");
/// assert_eq!(
///     initial_value,
///     serde_json::json!({
///       "key1": {
///         "key2": {}
///       }
///     })
/// );
/// assert_eq!(
///     removed_value,
///     Some(serde_json::json!({
///       "key4": "value"
///     }))
/// );
/// ```
pub fn remove_key_from_json(json: &mut Value, key: &str) -> Option<Value> {
    let mut json = Some(json);
    let mut keys = key.split('/').peekable();

    while let Some(key) = keys.next() {
        match json {
            Some(Value::Object(obj)) if keys.peek().is_none() => {
                return obj.remove(key);
            }
            Some(Value::Object(obj)) => json = obj.get_mut(key),
            _ => break,
        }
    }

    None
}

/// Checks if provided value of type T is equal to T::default()
// pub(crate) fn is_default<T: Default + PartialEq>(t: &T) -> bool {
//     t == &T::default()
// }

pub(crate) fn opt_default<T>() -> Option<T> {
    Option::<T>::None
}

/// Return [`String`] message which represents human-readable attached TGas requirements for a call
pub(crate) fn display_gas_requirement_in_tgas(gas: Gas) -> String {
    format!(
        "Requires minimum amount of attached gas {} TGas",
        gas.0 / Gas::ONE_TERA.0
    )
}

/// Return [`String`] message which represents human-readable attached Ⓝ deposit requirements for a call
pub(crate) fn display_deposit_requirement_in_near(value: Balance) -> String {
    format!(
        "Requires exact amount of attached deposit {} NEAR",
        (value / STORAGE_PRICE_PER_BYTE) as f64 / 100_000f64
    )
}

/// Return [`String`] which represents human-readable Ⓝ amount
pub fn display_deposit_in_near(value: Balance) -> String {
    format!(
        "{} NEAR",
        (value / STORAGE_PRICE_PER_BYTE) as f64 / 100_000f64
    )
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::EncodedCommentary;
    use crate::{types::IncrementalUniqueId, Commentary};
    use near_sdk::json_types::U64;
    use near_sdk::serde_json::json;
    use near_units::parse_near;

    #[test]
    fn test_build_initial_json_for_socialdb() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());

        let json_text = super::build_initial_json_for_socialdb(&root_id).unwrap();
        assert_eq!(
            json_text,
            json!({
                "kudos.near": {
                  "kudos": {},
                  "hashtags": {}
                }
            })
        )
    }

    #[test]
    fn test_build_hashtags() {
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let next_kudos_id = KudosId::from(IncrementalUniqueId::default().next());

        let json_text = super::build_hashtags(
            &receiver_id,
            &next_kudos_id,
            Some(&[Hashtag::new("hashtaga", 32).unwrap(),
                Hashtag::new("hashtagb", 32).unwrap(),
                Hashtag::new("hashtagc", 32).unwrap()]),
        )
        .unwrap();

        assert_eq!(
            json_text,
            r#"{"hashtaga":{"1":"test2.near"},"hashtagb":{"1":"test2.near"},"hashtagc":{"1":"test2.near"}}"#
        );
    }

    #[test]
    fn test_hashtags_to_json_array() {
        assert_eq!(
            hashtags_to_json_array(&[
                Hashtag::new("a1", 32).unwrap(),
                Hashtag::new("b1", 32).unwrap(),
                Hashtag::new("c1", 32).unwrap(),
            ])
            .unwrap(),
            r#"[\"a1\",\"b1\",\"c1\"]"#
        );
        assert_eq!(hashtags_to_json_array(&[]).unwrap(), r#"[]"#);
    }

    #[test]
    fn test_build_kudos_request() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let sender_id = AccountId::new_unchecked("test1.near".to_owned());
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let next_kudos_id = KudosId::from(IncrementalUniqueId::default().next());
        //let message = EscapedMessage::new(r#""a","b":{"t":"multi\nline"},"#, 1000).unwrap();
        let message = r#""a","b":{"t":"multi\nline"},"#;
        let icon_cid =
            WrappedCid::new("bafybeigrf2dwtpjkiovnigysyto3d55opf6qkdikx6d65onrqnfzwgdkfa").unwrap();

        let json_text = serde_json::to_string(
            &super::build_give_kudos_request(
                &root_id,
                &sender_id,
                &receiver_id,
                &next_kudos_id,
                1234567890u64,
                KudosKind::Kudos,
                message,
                Some(&icon_cid),
                Some(&[
                    Hashtag::new("abc", 32).unwrap(),
                    Hashtag::new("def", 32).unwrap(),
                ]),
            )
            .unwrap(),
        )
        .unwrap();

        assert_eq!(
            json_text,
            r#"{"kudos.near":{"hashtags":{"abc":{"1":"test2.near"},"def":{"1":"test2.near"}},"kudos":{"test2.near":{"1":{"comments":{},"created_at":"1234567890","icon":"bafybeigrf2dwtpjkiovnigysyto3d55opf6qkdikx6d65onrqnfzwgdkfa","kind":"k","message":"\"a\",\"b\":{\"t\":\"multi\\nline\"},","sender_id":"test1.near","tags":"[\"abc\",\"def\"]","upvotes":{}}}}}}"#
        );

        let json_text = serde_json::to_string(
            &super::build_give_kudos_request(
                &root_id,
                &sender_id,
                &receiver_id,
                &next_kudos_id,
                1234567890u64,
                KudosKind::Ding,
                message,
                None,
                Some(&[
                    Hashtag::new("abc", 32).unwrap(),
                    Hashtag::new("def", 32).unwrap(),
                ]),
            )
            .unwrap(),
        )
        .unwrap();

        assert_eq!(
            json_text,
            r#"{"kudos.near":{"hashtags":{"abc":{"1":"test2.near"},"def":{"1":"test2.near"}},"kudos":{"test2.near":{"1":{"comments":{},"created_at":"1234567890","icon":"","kind":"d","message":"\"a\",\"b\":{\"t\":\"multi\\nline\"},","sender_id":"test1.near","tags":"[\"abc\",\"def\"]","upvotes":{}}}}}}"#
        );
    }

    #[test]
    fn test_build_upvote_kudos_request() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let sender_id = AccountId::new_unchecked("test1.near".to_owned());
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let next_kudos_id = KudosId::from(IncrementalUniqueId::default().next());

        let json_text = serde_json::to_string(
            &super::build_upvote_kudos_request(&root_id, &sender_id, &receiver_id, &next_kudos_id)
                .unwrap(),
        )
        .unwrap();

        assert_eq!(
            json_text,
            r#"{"kudos.near":{"kudos":{"test2.near":{"1":{"upvotes":{"test1.near":""}}}}}}"#
        );
    }

    #[test]
    fn test_build_leave_comment_request() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let sender_id = AccountId::new_unchecked("test1.near".to_owned());
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let mut unique_id = IncrementalUniqueId::default();
        let kudos_id = KudosId::from(unique_id.inc());
        let comment_id = CommentId::from(unique_id.inc());

        let json_text = serde_json::to_string(
            &super::build_leave_comment_request(
                &root_id,
                &receiver_id,
                &kudos_id,
                &comment_id,
                &EncodedCommentary::try_from(&Commentary {
                    sender_id: &sender_id,
                    message: &Value::String("some commentary text".to_string()),
                    timestamp: U64(1234567890),
                    parent_comment_id: None,
                })
                .unwrap(),
            )
            .unwrap(),
        )
        .unwrap();

        assert_eq!(
            json_text,
            r#"{"kudos.near":{"kudos":{"test2.near":{"1":{"comments":{"2":"eyJtIjoic29tZSBjb21tZW50YXJ5IHRleHQiLCJzIjoidGVzdDEubmVhciIsInQiOiIxMjM0NTY3ODkwIn0="}}}}}}"#
        );
    }

    #[test]
    fn test_build_get_kudos_by_id_request() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let next_kudos_id = KudosId::from(IncrementalUniqueId::default().next());
        assert_eq!(
            &super::build_get_kudos_by_id_request(&root_id, &receiver_id, &next_kudos_id),
            "kudos.near/kudos/test2.near/1/*"
        );
    }

    #[test]
    fn test_build_get_kudos_comment_by_id_request() {
        let root_id = AccountId::new_unchecked("kudos.near".to_owned());
        let receiver_id = AccountId::new_unchecked("test2.near".to_owned());
        let mut id = IncrementalUniqueId::default();
        let next_kudos_id = KudosId::from(id.inc());
        let next_comment_id = CommentId::from(id.inc());
        assert_eq!(
            &super::build_get_kudos_comment_by_id_request(
                &root_id,
                &receiver_id,
                &next_kudos_id,
                &next_comment_id
            ),
            "kudos.near/kudos/test2.near/1/comments/2"
        );
    }

    #[test]
    fn test_extract_kudos_id_sender_from_response() {
        // valid kudos response
        assert_eq!(
            super::extract_kudos_id_sender_from_response(
                "test.near/kudos/user1.near/1/*",
                &mut json!({
                    "test.near": {
                      "kudos": {
                        "user1.near": {
                          "1": {
                            "sender_id": "user2.near"
                          }
                        }
                      }
                    }
                })
            ),
            Some(AccountId::new_unchecked("user2.near".to_owned()))
        );
        // invalid kudos response
        assert!(super::extract_kudos_id_sender_from_response(
            "test.near/kudos/user1.near/1/*",
            &mut json!({
                "test.near": {
                  "kudos": {
                    "user1.near": {
                      "1": {}
                    }
                  }
                }
            })
        )
        .is_none());
        // different kudos root id
        assert!(super::extract_kudos_id_sender_from_response(
            "test.near/kudos/user1.near/1/*",
            &mut json!({
                "test1.near": {
                  "kudos": {
                    "user1.near": {
                      "1": {
                        "sender_id": "user2.near"
                      }
                    }
                  }
                }
            })
        )
        .is_none());
        // no response
        assert!(super::extract_kudos_id_sender_from_response(
            "test.near/kudos/user1.near/1/*",
            &mut json!({})
        )
        .is_none());
    }

    #[test]
    fn test_extract_kudos_encoded_comment_by_id_from_response() {
        // valid kudos base64-encoded comment response
        assert_eq!(
            super::extract_kudos_encoded_comment_by_id_from_response(
                "test.near/kudos/user1.near/1/*",
                &CommentId::new_unchecked(2),
                &mut json!({
                    "test.near": {
                      "kudos": {
                        "user1.near": {
                          "1": {
                            "comments": {
                              "2": "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicCI6IjEiLCJzIjoidXNlci5uZWFyIiwidCI6IjEyMzQ1Njc4OTAifQ"
                            }
                          }
                        }
                      }
                    }
                })
            ),
            Some(EncodedCommentary::new_unchecked("eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicCI6IjEiLCJzIjoidXNlci5uZWFyIiwidCI6IjEyMzQ1Njc4OTAifQ".to_owned()))
        );
        // invalid kudos base64-encoded comment response
        assert!(super::extract_kudos_encoded_comment_by_id_from_response(
            "test.near/kudos/user1.near/1/*",
            &CommentId::new_unchecked(2),
            &mut json!({
                "test.near": {
                  "kudos": {
                    "user1.near": {
                      "1": {
                        "comments": {}
                      }
                    }
                  }
                }
            })
        )
        .is_none());
        // different parent commentary id
        assert!(super::extract_kudos_encoded_comment_by_id_from_response(
            "test.near/kudos/user1.near/1/*",
            &CommentId::new_unchecked(3),
            &mut json!({
                "test.near": {
                  "kudos": {
                    "user1.near": {
                      "1": {
                        "comments": {
                          "2": "eyJtIjoiY29tbWVudGFyeSB0ZXN0IiwicCI6IjEiLCJzIjoidXNlci5uZWFyIiwidCI6IjEyMzQ1Njc4OTAifQ"
                        }
                      }
                    }
                  }
                }
            })
        )
        .is_none());
    }

    #[test]
    fn test_remove_key_from_json() {
        let mut json = json!({
            "abc": "test",
            "remove_me": "test2",
            "test": {
                "remove_me": "test3",
                "test1": {
                    "remove_me": "test4"
                }
            }
        });

        // key not exist or nothing to remove
        assert!(remove_key_from_json(&mut json, "").is_none());
        assert!(remove_key_from_json(&mut json, "testtest").is_none());
        assert!(remove_key_from_json(&mut json, "test_abc/test_def").is_none());
        assert_eq!(
            json.to_string(),
            r#"{"abc":"test","remove_me":"test2","test":{"remove_me":"test3","test1":{"remove_me":"test4"}}}"#
        );
        // remove key from root
        assert_eq!(
            remove_key_from_json(&mut json, "remove_me"),
            Some(json!("test2"))
        );
        assert_eq!(
            json.to_string(),
            r#"{"abc":"test","test":{"remove_me":"test3","test1":{"remove_me":"test4"}}}"#
        );
        // remove nested key
        assert_eq!(
            remove_key_from_json(&mut json, "test/remove_me"),
            Some(json!("test3"))
        );
        assert_eq!(
            json.to_string(),
            r#"{"abc":"test","test":{"test1":{"remove_me":"test4"}}}"#
        );
        // remove deeply nested key
        assert_eq!(
            remove_key_from_json(&mut json, "test/test1/remove_me"),
            Some(json!("test4"))
        );
        assert_eq!(json.to_string(), r#"{"abc":"test","test":{"test1":{}}}"#);
    }

    #[test]
    fn test_display_deposit_requirement_in_near() {
        assert_eq!(
            display_deposit_requirement_in_near(parse_near!("0.0005 NEAR")).as_str(),
            "Requires exact amount of attached deposit 0.0005 NEAR"
        );
        assert_eq!(
            display_deposit_requirement_in_near(parse_near!("0.00051 NEAR")).as_str(),
            "Requires exact amount of attached deposit 0.00051 NEAR"
        );
        assert_eq!(
            display_deposit_requirement_in_near(parse_near!("0.000553 NEAR")).as_str(),
            "Requires exact amount of attached deposit 0.00055 NEAR"
        );
    }
}

'''
'''--- tests/test_kudos.rs ---
mod types;
mod utils;
mod workspaces;

use crate::types::*;
use crate::utils::*;
use crate::workspaces::{build_contract, gen_user_account, get_block_timestamp, transfer_near};
use kudos_contract::WrappedCid;
use kudos_contract::{utils::*, CommentId};
use kudos_contract::{Commentary, PROOF_OF_KUDOS_SBT_CLASS_ID};
use near_sdk::serde_json::{self, json, Value};
use near_sdk::AccountId;
use near_units::parse_near;
use std::collections::{BTreeMap, HashMap};

#[tokio::test]
async fn test_give_kudos() -> anyhow::Result<()> {
    let worker_mainnet = ::workspaces::mainnet_archival().await?;
    let near_social_id = "social.near".parse()?;
    let worker = ::workspaces::sandbox().await?;

    let admin_account = worker.root_account()?;

    // Setup NEAR Social-DB contract
    let near_social = worker
        .import_contract(&near_social_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(94_000_000)
        .transact()
        .await?;
    let _ = near_social
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = near_social
        .call("set_status")
        .args_json(json!({"status": "Live"}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Initialize NDC i-am-human registry contract
    let iah_registry_id = "registry.i-am-human.near".parse()?;
    let iah_registry = worker
        .import_contract(&iah_registry_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(95_309_837)
        .transact()
        .await?;
    let _ = iah_registry
        .call("new")
        .args_json(json!({
          "authority": admin_account.id(),
          "iah_issuer": admin_account.id(),
          "iah_classes": [1]
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": admin_account.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Setup NDC Kudos Contract
    let kudos_contract = build_contract(
        &worker,
        "./",
        "init",
        json!({ "iah_registry": iah_registry_id }),
    )
    .await?;

    set_external_db(
        kudos_contract.id(),
        kudos_contract.as_account(),
        &near_social,
    )
    .await?;

    // Register users' accounts
    let user1_account = gen_user_account(&worker, "user1.test.near").await?;
    let _ = transfer_near(&worker, user1_account.id(), parse_near!("50 N")).await?;

    let user2_account = gen_user_account(&worker, "user2.test.near").await?;
    let _ = transfer_near(&worker, user2_account.id(), parse_near!("50 N")).await?;

    let user3_account = gen_user_account(&worker, "user3.test.near").await?;
    let _ = transfer_near(&worker, user3_account.id(), parse_near!("50 N")).await?;

    let now_ms = get_block_timestamp(&worker).await? / 1_000_000;

    // Mint FV SBT for users & verify
    let minted_tokens: Vec<u64> = mint_fv_sbt(
        &iah_registry_id,
        &admin_account,
        &[user1_account.id(), user2_account.id(), user3_account.id()],
        now_ms,
        now_ms + 86_400_000,
    )
    .await?;
    assert!(verify_is_human(
        &iah_registry_id,
        admin_account.id(),
        &[&user1_account, &user2_account, &user3_account],
        &minted_tokens
    )
    .await
    .is_ok());

    // User1 gives kudos to User2
    let hashtags = (0..3).map(|n| format!("ht_{n}")).collect::<Vec<_>>();
    let kudos_message = "test\",\n\"a\":{\"b\":\"test2\"},\"c\":\"msg";
    let kudos_id = give_kudos(
        kudos_contract.id(),
        &user1_account,
        user2_account.id(),
        kudos_message,
        Some(
            &WrappedCid::new("bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku")
                .unwrap(),
        ),
        hashtags.iter().map(|s| s.as_str()).collect(),
    )
    .await?;

    let get_kudos_by_id_req = build_get_kudos_by_id_request(
        &AccountId::new_unchecked(kudos_contract.id().to_string()),
        &AccountId::new_unchecked(user2_account.id().to_string()),
        &kudos_id,
    );

    let hashtags_req = format!("{}/hashtags/**", kudos_contract.id());

    // Verify kudos on NEAR Social-DB contract
    let mut kudos_data: near_sdk::serde_json::Value = user2_account
        .view(&near_social_id, "get")
        .args_json(json!({ "keys": [get_kudos_by_id_req, hashtags_req] }))
        .await?
        .json()?;
    // remove `created_at` nested key to be able compare with static stringified json and verify that removed key were exist
    assert!(remove_key_from_json(
        &mut kudos_data,
        &get_kudos_by_id_req.replace('*', "created_at")
    )
    .is_some());
    let extracted_hashtags = remove_key_from_json(
        &mut kudos_data,
        &format!("{}/hashtags", kudos_contract.id()),
    )
    .and_then(|val| serde_json::from_value::<BTreeMap<String, Value>>(val).ok())
    .map(|map| map.keys().cloned().collect::<Vec<_>>());
    assert_eq!(extracted_hashtags, Some(hashtags.clone()));

    let escaped_kudos_message = kudos_message.escape_default().to_string();
    assert_eq!(
        kudos_data.to_string(),
        format!(
            r#"{{"{}":{{"kudos":{{"{}":{{"{kudos_id}":{{"icon":"bafybeihdwdcefgh4dqkjv67uzcmw7ojee6xedzdetojuzjevtenxquvyku","kind":"k","message":"{escaped_kudos_message}","sender_id":"{}","tags":"{}"}}}}}}}}}}"#,
            kudos_contract.id(),
            user2_account.id(),
            user1_account.id(),
            serde_json::to_string(&hashtags)
                .unwrap()
                .escape_default(),
        )
    );

    // User3 upvotes kudos given to User2 by User1
    let _ = upvote_kudos(
        kudos_contract.id(),
        &user3_account,
        user2_account.id(),
        &kudos_id,
    )
    .await?;

    // Verify upvoted kudos on NEAR Social-DB contract
    let mut kudos_data: near_sdk::serde_json::Value = user2_account
        .view(&near_social_id, "get")
        .args_json(json!({
            "keys": [get_kudos_by_id_req.replace('*', "upvotes/**")]
        }))
        .await?
        .json()?;

    // remove `/upvotes` nested key and check for it's value, which should contain User3 who upvoted kudos
    let upvotes_json = remove_key_from_json(
        &mut kudos_data,
        &get_kudos_by_id_req.replace('*', "upvotes"),
    )
    .unwrap()
    .to_string();
    assert_eq!(upvotes_json, format!(r#"{{"{}":""}}"#, user3_account.id()));

    // User3 leaves a comment to kudos given to User2 by User1
    let comment1_id = leave_comment(
        kudos_contract.id(),
        &user3_account,
        user2_account.id(),
        &kudos_id,
        None,
        "amazing",
    )
    .await?;

    // User2 leaves a reply to a comment from User3
    let comment2_id = leave_comment(
        kudos_contract.id(),
        &user2_account,
        user2_account.id(),
        &kudos_id,
        Some(comment1_id.clone()),
        "wow",
    )
    .await?;

    // User3 leaves a reply to a comment from User2
    let comment3_id = leave_comment(
        kudos_contract.id(),
        &user3_account,
        user2_account.id(),
        &kudos_id,
        Some(comment2_id.clone()),
        "you are the best",
    )
    .await?;

    // User3 fails to leave a reply to an invalid comment id
    let err = leave_comment(
        kudos_contract.id(),
        &user3_account,
        user2_account.id(),
        &kudos_id,
        Some(CommentId::new_unchecked(123456789)),
        "failure",
    )
    .await
    .unwrap_err();
    assert_eq!(
        &err.to_string(),
        r#"Leave comment failure: Action #0: ExecutionError("Smart contract panicked: Unable to verify parent commentary id")"#
    );

    // Verify comment left for kudos on NEAR Social-DB contract
    let mut kudos_data: near_sdk::serde_json::Value = user2_account
        .view(&near_social_id, "get")
        .args_json(json!({
            "keys": [get_kudos_by_id_req.replace('*', "comments/**")]
        }))
        .await?
        .json()?;

    // remove `/comments` nested key and check for it's value, which should contain User3 who left a comment and a message for kudos
    let comments_json = remove_key_from_json(
        &mut kudos_data,
        &get_kudos_by_id_req.replace('*', "comments"),
    )
    .unwrap();
    let comments =
        serde_json::from_value::<HashMap<CommentId, CommentaryOwned>>(comments_json).unwrap();

    // verify first comment
    let comment = Commentary::from(comments.get(&comment1_id).unwrap());
    assert_eq!(
        comment.sender_id.as_str(),
        user3_account
            .id()
            .parse::<near_sdk::AccountId>()
            .unwrap()
            .as_str()
    );
    assert_eq!(comment.message, "amazing");

    // verify a reply comment
    let comment = Commentary::from(comments.get(&comment2_id).unwrap());
    assert_eq!(
        comment.sender_id.as_str(),
        user2_account
            .id()
            .parse::<near_sdk::AccountId>()
            .unwrap()
            .as_str()
    );
    assert_eq!(comment.message, "wow");
    assert_eq!(comment.parent_comment_id, Some(&comment1_id));

    // verify a reply comment
    let comment = Commentary::from(comments.get(&comment3_id).unwrap());
    assert_eq!(
        comment.sender_id.as_str(),
        user3_account
            .id()
            .parse::<near_sdk::AccountId>()
            .unwrap()
            .as_str()
    );
    assert_eq!(comment.message, "you are the best");
    assert_eq!(comment.parent_comment_id, Some(&comment2_id));

    Ok(())
}

#[tokio::test]
async fn test_mint_proof_of_kudos_sbt() -> anyhow::Result<()> {
    let worker_mainnet = ::workspaces::mainnet_archival().await?;
    let near_social_id = "social.near".parse()?;
    let worker = ::workspaces::sandbox().await?;

    let admin_account = worker.root_account()?;
    let iah_registry_id = "registry.i-am-human.near".parse()?;

    // Setup NEAR Social-DB contract
    let near_social = worker
        .import_contract(&near_social_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(94_000_000)
        .transact()
        .await?;
    let _ = near_social
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = near_social
        .call("set_status")
        .args_json(json!({"status": "Live"}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Setup NDC Kudos Contract
    let kudos_contract = build_contract(
        &worker,
        "./",
        "init",
        json!({ "iah_registry": iah_registry_id }),
    )
    .await?;

    set_external_db(
        kudos_contract.id(),
        kudos_contract.as_account(),
        &near_social,
    )
    .await?;

    // Initialize NDC i-am-human registry contract
    let iah_registry = worker
        .import_contract(&iah_registry_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(95_309_837)
        .transact()
        .await?;
    let _ = iah_registry
        .call("new")
        .args_json(json!({
          "authority": admin_account.id(),
          "iah_issuer": admin_account.id(),
          "iah_classes": [1]
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": admin_account.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    // Set Kudos contract as an SBT issuer
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": kudos_contract.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Register users' accounts
    let user1_account = gen_user_account(&worker, "user1.test.near").await?;
    let _ = transfer_near(&worker, user1_account.id(), parse_near!("10 N")).await?;

    let user2_account = gen_user_account(&worker, "user2.test.near").await?;
    let _ = transfer_near(&worker, user2_account.id(), parse_near!("10 N")).await?;
    let user3_account = gen_user_account(&worker, "user3.test.near").await?;
    let _ = transfer_near(&worker, user3_account.id(), parse_near!("10 N")).await?;

    let user4_account = gen_user_account(&worker, "user4.test.near").await?;
    let _ = transfer_near(&worker, user4_account.id(), parse_near!("10 N")).await?;

    let user5_account = gen_user_account(&worker, "user5.test.near").await?;
    let _ = transfer_near(&worker, user5_account.id(), parse_near!("10 N")).await?;

    let now_ms = get_block_timestamp(&worker).await? / 1_000_000;

    // Mint FV SBT for users
    let _ = mint_fv_sbt(
        &iah_registry_id,
        &admin_account,
        &[user1_account.id(),
            user2_account.id(),
            user3_account.id(),
            user4_account.id(),
            user5_account.id()],
        now_ms,
        now_ms + 86_400_000,
    )
    .await?;

    // User2 gives kudos to User1
    let kudos_id = give_kudos(
        kudos_contract.id(),
        &user2_account,
        user1_account.id(),
        "blablabla sdfsdfsd\nfsdfsdfs 🚀\n😎✨",
        None,
        vec!["ht-a", "ht_b"],
    )
    .await?;

    // User3 upvotes kudos for User1
    let _ = upvote_kudos(
        kudos_contract.id(),
        &user3_account,
        user1_account.id(),
        &kudos_id,
    )
    .await?;

    // User4 upvotes kudos for User1
    let _ = upvote_kudos(
        kudos_contract.id(),
        &user4_account,
        user1_account.id(),
        &kudos_id,
    )
    .await?;

    // User5 upvotes kudos for User1
    let _ = upvote_kudos(
        kudos_contract.id(),
        &user5_account,
        user1_account.id(),
        &kudos_id,
    )
    .await?;

    // User1 exchanges his Kudos for ProofOfKudos SBT
    let tokens_ids = exchange_kudos_for_sbt(kudos_contract.id(), &user1_account, &kudos_id).await?;
    assert_eq!(tokens_ids, vec![PROOF_OF_KUDOS_SBT_CLASS_ID]);

    verify_kudos_sbt_tokens_by_owner(
        &iah_registry_id,
        kudos_contract.id(),
        &user1_account,
        &tokens_ids,
    )
    .await?;

    Ok(())
}

#[tokio::test]
async fn test_mass_give_kudos() -> anyhow::Result<()> {
    let worker_mainnet = ::workspaces::mainnet_archival().await?;
    let near_social_id = "social.near".parse()?;
    let worker = ::workspaces::sandbox().await?;

    let admin_account = worker.root_account()?;

    // Setup NEAR Social-DB contract
    let near_social = worker
        .import_contract(&near_social_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(94_000_000)
        .transact()
        .await?;
    let _ = near_social
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = near_social
        .call("set_status")
        .args_json(json!({"status": "Live"}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Initialize NDC i-am-human registry contract
    let iah_registry_id = "registry.i-am-human.near".parse()?;
    let iah_registry = worker
        .import_contract(&iah_registry_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(95_309_837)
        .transact()
        .await?;
    let _ = iah_registry
        .call("new")
        .args_json(json!({
          "authority": admin_account.id(),
          "iah_issuer": admin_account.id(),
          "iah_classes": [1]
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": admin_account.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Setup NDC Kudos Contract
    let kudos_contract = build_contract(
        &worker,
        "./",
        "init",
        json!({ "iah_registry": iah_registry_id }),
    )
    .await?;

    set_external_db(
        kudos_contract.id(),
        kudos_contract.as_account(),
        &near_social,
    )
    .await?;

    // Register users' accounts
    let number_of_users: usize = 5;
    let mut users_accounts = Vec::with_capacity(number_of_users);

    for i in 0..number_of_users {
        let user_account = gen_user_account(&worker, &format!("user{}.test.near", &i)).await?;
        let _ = transfer_near(&worker, user_account.id(), parse_near!("5 N")).await?;
        users_accounts.push(user_account);
    }

    let now_ms = get_block_timestamp(&worker).await? / 1_000_000;

    // Mint FV SBT for users & verify
    let _ = mint_fv_sbt(
        &iah_registry_id,
        &admin_account,
        &users_accounts
            .iter()
            .map(|user| user.id())
            .collect::<Vec<_>>(),
        now_ms,
        now_ms + 86_400_000,
    )
    .await?;

    let mut kudos = vec![];

    for user_account in &users_accounts[1..] {
        // UserX gives kudos to User1
        let hashtags = (0..3).map(|n| format!("ht{n}")).collect::<Vec<_>>();
        let kudos_message = "amazing message".repeat(32);
        let kudos_id = give_kudos(
            kudos_contract.id(),
            user_account,
            users_accounts.first().unwrap().id(),
            &kudos_message,
            None,
            hashtags.iter().map(|s| s.as_str()).collect(),
        )
        .await?;
        kudos.push(kudos_id);
    }

    for (user_account, kudos_id) in users_accounts[1..].iter().rev().zip(&kudos) {
        println!("{} upvotes kudos {}", user_account.id(), kudos_id);
        // UserX upvotes kudos of User1
        let _ = upvote_kudos(
            kudos_contract.id(),
            user_account,
            users_accounts.first().unwrap().id(),
            kudos_id,
        )
        .await?;
    }

    Ok(())
}

'''
'''--- tests/test_required_deposit.rs ---
mod types;
mod utils;
mod workspaces;

use crate::utils::*;
use crate::workspaces::{build_contract, gen_user_account, get_block_timestamp, transfer_near};
use kudos_contract::{utils::*, WrappedCid};
use kudos_contract::{GIVE_KUDOS_COST, LEAVE_COMMENT_COST, UPVOTE_KUDOS_COST};
use near_sdk::serde_json::json;
use near_units::parse_near;

#[tokio::test]
async fn test_required_deposit() -> anyhow::Result<()> {
    let worker_mainnet = ::workspaces::mainnet_archival().await?;
    let near_social_id = "social.near".parse()?;
    let worker = ::workspaces::sandbox().await?;

    let admin_account = worker.root_account()?;

    // Setup NEAR Social-DB contract
    let near_social = worker
        .import_contract(&near_social_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(94_000_000)
        .transact()
        .await?;
    let _ = near_social
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = near_social
        .call("set_status")
        .args_json(json!({"status": "Live"}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Initialize NDC i-am-human registry contract
    let iah_registry_id = "registry.i-am-human.near".parse()?;
    let iah_registry = worker
        .import_contract(&iah_registry_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(95_309_837)
        .transact()
        .await?;
    let _ = iah_registry
        .call("new")
        .args_json(json!({
          "authority": admin_account.id(),
          "iah_issuer": admin_account.id(),
          "iah_classes": [1]
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": admin_account.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Setup NDC Kudos Contract
    let kudos_contract = build_contract(
        &worker,
        "./",
        "init",
        json!({ "iah_registry": iah_registry_id, "owner_id": admin_account.id() }),
    )
    .await?;

    set_external_db(kudos_contract.id(), &admin_account, &near_social).await?;

    // Register users' accounts
    let test1_account =
        gen_user_account(&worker, &[&"a".repeat(54), ".test.near"].concat()).await?;
    let _ = transfer_near(&worker, test1_account.id(), parse_near!("10 N")).await?;
    let test2_account =
        gen_user_account(&worker, &[&"b".repeat(54), ".test.near"].concat()).await?;
    let _ = transfer_near(&worker, test2_account.id(), parse_near!("10 N")).await?;
    let test3_account =
        gen_user_account(&worker, &[&"c".repeat(54), ".test.near"].concat()).await?;
    let _ = transfer_near(&worker, test3_account.id(), parse_near!("10 N")).await?;

    let now_ms = get_block_timestamp(&worker).await? / 1_000_000;

    // Mint FV SBT for users & verify
    let minted_tokens = mint_fv_sbt(
        &iah_registry_id,
        &admin_account,
        &[test1_account.id(), test2_account.id(), test3_account.id()],
        now_ms,
        now_ms + 86_400_000,
    )
    .await?;
    assert!(verify_is_human(
        &iah_registry_id,
        admin_account.id(),
        &[&test1_account, &test2_account, &test3_account],
        &minted_tokens
    )
    .await
    .is_ok());

    let hashtags = (0..10)
        .map(|n| format!("{}{n}", "a".repeat(31)))
        .collect::<Vec<_>>();
    let kudos_text = "a".repeat(1000);

    // Give kudos
    let Some(balance_1) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let kudos_id = give_kudos(
        kudos_contract.id(),
        &test1_account,
        test2_account.id(),
        &kudos_text,
        Some(
            WrappedCid::new("bafybeigdyrzt5sfp7udm7hu76uh7y26nf3efuylqabf3oclgtqy55fbzdi").unwrap(),
        )
        .as_ref(),
        hashtags.iter().map(|s| s.as_str()).collect(),
    )
    .await?;

    let Some(balance_2) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let consumed =
        (balance_2.total.0 - balance_2.available.0) - (balance_1.total.0 - balance_1.available.0);
    assert!(
        consumed <= GIVE_KUDOS_COST,
        "`give_kudos` call should cost at least {} Ⓝ",
        display_deposit_in_near(consumed)
    );

    // Leave comment (no parent)
    let Some(balance_1) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let comment_id = leave_comment(
        kudos_contract.id(),
        &test1_account,
        test2_account.id(),
        &kudos_id,
        None,
        &kudos_text,
    )
    .await?;

    let Some(balance_2) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let consumed =
        (balance_2.total.0 - balance_2.available.0) - (balance_1.total.0 - balance_1.available.0);
    assert!(
        consumed <= LEAVE_COMMENT_COST,
        "`leave_comment` call should cost at least {} Ⓝ",
        display_deposit_in_near(consumed)
    );

    // Leave comment (with parent)
    let Some(balance_1) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let _ = leave_comment(
        kudos_contract.id(),
        &test1_account,
        test2_account.id(),
        &kudos_id,
        Some(comment_id),
        &kudos_text,
    )
    .await?;

    let Some(balance_2) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let consumed =
        (balance_2.total.0 - balance_2.available.0) - (balance_1.total.0 - balance_1.available.0);
    println!("{}", display_deposit_in_near(consumed));
    assert!(
        consumed <= LEAVE_COMMENT_COST,
        "`leave_comment` call should cost at least {} Ⓝ",
        display_deposit_in_near(consumed)
    );

    // Upvote kudos
    let Some(balance_1) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let _ = upvote_kudos(
        kudos_contract.id(),
        &test3_account,
        test2_account.id(),
        &kudos_id,
    )
    .await?;

    let Some(balance_2) = storage_balance_of(&near_social_id, kudos_contract.as_account()).await? else {
        anyhow::bail!("Kudos contract wasn't properly initialized at SocialDB!")
    };

    let consumed =
        (balance_2.total.0 - balance_2.available.0) - (balance_1.total.0 - balance_1.available.0);
    assert!(
        consumed <= UPVOTE_KUDOS_COST,
        "`upvote_kudos` call should cost at least {} Ⓝ",
        display_deposit_in_near(consumed)
    );

    Ok(())
}

'''
'''--- tests/test_social_db.rs ---
mod types;
mod utils;
mod workspaces;

use crate::utils::*;
use crate::workspaces::{build_contract, gen_user_account, transfer_near};
use kudos_contract::utils::*;
use kudos_contract::SOCIAL_DB_GRANT_WRITE_PERMISSION_COST;
use near_contract_standards::storage_management::{StorageBalance, StorageBalanceBounds};
use near_sdk::json_types::U128;
use near_sdk::serde_json::{self, json, Value};
use near_sdk::ONE_YOCTO;
use near_units::parse_near;

#[tokio::test]
async fn test_social_db_required_deposit() -> anyhow::Result<()> {
    let worker_mainnet = ::workspaces::mainnet_archival().await?;
    let near_social_id = "social.near".parse()?;
    let worker = ::workspaces::sandbox().await?;

    let admin_account = worker.root_account()?;

    // Setup NEAR Social-DB contract
    let near_social = worker
        .import_contract(&near_social_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(94_000_000)
        .transact()
        .await?;
    let _ = near_social
        .call("new")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = near_social
        .call("set_status")
        .args_json(json!({"status": "Live"}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Initialize NDC i-am-human registry contract
    let iah_registry_id = "registry.i-am-human.near".parse()?;
    let iah_registry = worker
        .import_contract(&iah_registry_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .block_height(95_309_837)
        .transact()
        .await?;
    let _ = iah_registry
        .call("new")
        .args_json(json!({
          "authority": admin_account.id(),
          "iah_issuer": admin_account.id(),
          "iah_classes": [1]
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let _ = admin_account
        .call(&iah_registry_id, "admin_add_sbt_issuer")
        .args_json(json!({
          "issuer": admin_account.id()
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    // Setup NDC Kudos Contract
    let kudos_contract = build_contract(
        &worker,
        "./",
        "init",
        json!({ "iah_registry": iah_registry_id, "owner_id": admin_account.id() }),
    )
    .await?;

    let social_db_balance_bounds: StorageBalanceBounds = near_social
        .view("storage_balance_bounds")
        .args_json(json!({}))
        .await?
        .json()?;

    let contract_with_max_name =
        gen_user_account(&worker, &[&"y".repeat(54), ".test.near"].concat()).await?;
    let initial_json = serde_json::from_str::<Value>(&format!(
        r#"{{
          "{}": {{
            "kudos": {{}},
            "hashtags": {{}}
          }}
        }}"#,
        contract_with_max_name.id()
    ))?;
    let _ = contract_with_max_name
        .call(&near_social_id, "set")
        .args_json(json!({ "data": initial_json }))
        .deposit(social_db_balance_bounds.min.0)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let StorageBalance {
        total: U128(total_before),
        available: U128(available_before),
    } = storage_balance_of(&near_social_id, &contract_with_max_name)
        .await?
        .unwrap();

    let grant_permissions_for =
        gen_user_account(&worker, &[&"z".repeat(54), ".test.near"].concat()).await?;

    let _ = contract_with_max_name
        .call(&near_social_id, "grant_write_permission")
        .args_json(json!({
          "predecessor_id": grant_permissions_for.id(),
          "keys": vec![format!("{}", contract_with_max_name.id())]
        }))
        .deposit(ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let StorageBalance {
        total: U128(total_after),
        available: U128(available_after),
    } = storage_balance_of(&near_social_id, &contract_with_max_name)
        .await?
        .unwrap();

    assert_eq!(
        total_before + ONE_YOCTO,
        total_after,
        "Initital total deposit before & after `SocialDB::grant_write_permission` call should diff only by 1 yocto!"
    );

    let required_deposit_for_grant_write_permission = available_before - available_after;
    assert!(
        required_deposit_for_grant_write_permission <= SOCIAL_DB_GRANT_WRITE_PERMISSION_COST,
        "Pre-computed deposit requirements for `SocialDB::grant_write_permission` call is less than required ({} < {})!",
        display_deposit_in_near(SOCIAL_DB_GRANT_WRITE_PERMISSION_COST),
        display_deposit_in_near(required_deposit_for_grant_write_permission)
    );

    set_external_db(kudos_contract.id(), &admin_account, &near_social).await?;

    let StorageBalance {
        total: U128(kudos_contract_total),
        available: U128(kudos_contract_available),
    } = storage_balance_of(&near_social_id, kudos_contract.as_account())
        .await?
        .unwrap();

    assert_eq!(
        kudos_contract_total, total_after,
        "Kudos contract initialized at SocialDB initially deposits incorrect amount!"
    );
    assert!(
        kudos_contract_available >= available_after,
        "Kudos contract initialized at SocialDB uses storage more than expected (available: {}, expected: {})!",
        display_deposit_in_near(kudos_contract_available),
        display_deposit_in_near(available_after),
    );

    let fake_iah_registry =
        gen_user_account(&worker, &[&"x".repeat(54), ".test.near"].concat()).await?;
    let _ = transfer_near(&worker, fake_iah_registry.id(), parse_near!("5 N")).await?;

    update_iah_registry(kudos_contract.id(), &admin_account, fake_iah_registry.id()).await?;

    let StorageBalance {
        total: U128(kudos_contract_total_after_iah_update),
        available: U128(kudos_contract_available_after_iah_update),
    } = storage_balance_of(&near_social_id, kudos_contract.as_account())
        .await?
        .unwrap();

    assert!(
        kudos_contract_total <= kudos_contract_total_after_iah_update,
        "Kudos contract initialized at SocialDB total storage deposit can't be less than before call `update_iah_registry` method!"
    );
    assert!(
        kudos_contract_available <= kudos_contract_available_after_iah_update,
        "Kudos contract initialized at SocialDB available storage deposit can't be less than before call `update_iah_registry` method ({} < {})!",
        display_deposit_in_near(kudos_contract_available_after_iah_update),
        display_deposit_in_near(kudos_contract_available),
    );

    // Check that permission were granted
    let updated_data = serde_json::from_str::<Value>(&format!(
        r#"{{
          "{}": {{
            "test": "test_value"
          }}
        }}"#,
        kudos_contract.id()
    ))?;
    let _ = fake_iah_registry
        .call(&near_social_id, "set")
        .args_json(json!({ "data": updated_data }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    Ok(())
}

'''
'''--- tests/types.rs ---
use kudos_contract::{CommentId, Commentary};
use near_sdk::json_types::U64;
use near_sdk::serde::{self, Deserialize};
use near_sdk::serde_json::Value;
use near_sdk::{serde_json, AccountId};

#[derive(Debug, PartialEq)]
pub struct CommentaryOwned {
    pub message: Value,
    pub sender_id: AccountId,
    pub timestamp: U64,
    pub parent_comment_id: Option<CommentId>,
}

impl<'a> From<&'a CommentaryOwned> for Commentary<'a> {
    fn from(value: &'a CommentaryOwned) -> Self {
        Self {
            message: &value.message,
            sender_id: &value.sender_id,
            timestamp: value.timestamp,
            parent_comment_id: value.parent_comment_id.as_ref(),
        }
    }
}

impl<'de> Deserialize<'de> for CommentaryOwned {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let encoded = <String as Deserialize>::deserialize(deserializer)?;

        let raw = near_sdk::base64::decode(&encoded).map_err(|e| {
            serde::de::Error::custom(format!(
                "Unable to deserialize commentary from base64 encoded data: {encoded}. {e:?}"
            ))
        })?;

        serde_json::from_slice::<serde_json::Value>(&raw)
            .map_err(|e| {
                serde::de::Error::custom(format!(
                    "Unable to deserialize commentary json from decoded data: {encoded}. {e:?}"
                ))
            })?
            .as_object_mut()
            .and_then(|map| {
                let message = map
                    .remove("m")
                    .and_then(|v| serde_json::from_value::<String>(v).ok())?;
                let sender_id = map
                    .remove("s")
                    .and_then(|v| serde_json::from_value::<AccountId>(v).ok())?;
                let timestamp = map
                    .remove("t")
                    .and_then(|v| serde_json::from_value::<U64>(v).ok())?;
                let parent_comment_id = map
                    .remove("p")
                    .and_then(|v| serde_json::from_value::<CommentId>(v).ok());

                Some(Self {
                    sender_id,
                    message: Value::String(message),
                    timestamp,
                    parent_comment_id,
                })
            })
            .ok_or_else(|| serde::de::Error::custom("Failure to deserialize commentary from json"))
    }
}

'''
'''--- tests/utils.rs ---
use anyhow::anyhow;
use kudos_contract::registry::{OwnedToken, TokenMetadata};
use kudos_contract::{
    CommentId, KudosId, WrappedCid, EXCHANGE_KUDOS_COST, GIVE_KUDOS_COST, LEAVE_COMMENT_COST,
    PROOF_OF_KUDOS_SBT_MINT_COST, SOCIAL_DB_GRANT_WRITE_PERMISSION_COST, UPVOTE_KUDOS_COST,
};
use near_contract_standards::storage_management::{StorageBalance, StorageBalanceBounds};
use near_sdk::json_types::U64;
use near_sdk::serde_json::json;
use near_sdk::{AccountId, ONE_YOCTO};
use workspaces::result::ExecutionOutcome;

pub async fn mint_fv_sbt(
    iah_registry_id: &workspaces::AccountId,
    issuer: &workspaces::Account,
    receivers: &[&workspaces::AccountId],
    issued_at: u64,  // SBT issued at in millis
    expires_at: u64, // SBT expires at in millis
) -> anyhow::Result<Vec<u64>> {
    let res = issuer
        .call(iah_registry_id, "sbt_mint")
        .args_json(json!({
          "token_spec": receivers.iter().map(|receiver_id| (receiver_id, [
              TokenMetadata {
                  class: 1, // FV SBT
                  issued_at: Some(issued_at),
                  expires_at: Some(expires_at),
                  reference: None,
                  reference_hash: None,
              }
            ])
            ).collect::<Vec<_>>()
        }))
        .deposit(PROOF_OF_KUDOS_SBT_MINT_COST * receivers.len() as u128)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Mint FV SBT failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        });

    res.and_then(|res| {
        println!("gas burnt: {}", res.total_gas_burnt);
        res.json().map_err(|e| {
            anyhow::Error::msg(format!(
                "Failed to deserialize sbt_mint response: {e:?}. Receipts: {:?}",
                res.receipt_outcomes()
            ))
        })
    })
}

pub async fn verify_is_human(
    iah_registry_id: &workspaces::AccountId,
    issuer_id: &workspaces::AccountId,
    users_accounts: &[&workspaces::Account],
    tokens: &Vec<u64>,
) -> anyhow::Result<()> {
    for (i, &user_account) in users_accounts.iter().enumerate() {
        let res = user_account
            .view(iah_registry_id, "is_human")
            .args_json(json!({
              "account": user_account.id()
            }))
            .await?
            .json::<Vec<(AccountId, Vec<u64>)>>()?;

        match res.first() {
            Some((issuer_id_result, tokens_result))
                if issuer_id_result.as_str() != issuer_id.as_str()
                    && tokens_result[0] != tokens[i] =>
            {
                return Err(anyhow::Error::msg(format!(
                    "User `{}` not verified",
                    user_account.id()
                )));
            }
            _ => (),
        };
    }

    Ok(())
}

pub async fn verify_kudos_sbt_tokens_by_owner(
    iah_registry_id: &workspaces::AccountId,
    issuer_id: &workspaces::AccountId,
    owner: &workspaces::Account,
    tokens_ids: &[u64],
) -> anyhow::Result<()> {
    let res = owner
        .view(iah_registry_id, "sbt_tokens_by_owner")
        .args_json(json!({
          "account": owner.id(),
          "issuer": issuer_id,
        }))
        .await?
        .json::<Vec<(AccountId, Vec<OwnedToken>)>>()?;

    match res.first() {
        Some((issuer_id_result, tokens_result))
            if issuer_id_result.as_str() != issuer_id.as_str()
                && compare_slices(
                    &tokens_result
                        .iter()
                        .map(|token_res| token_res.token)
                        .collect::<Vec<_>>(),
                    tokens_ids,
                ) =>
        {
            Err(anyhow::Error::msg(format!(
                "User `{}` do not have ProofOfKudos SBT",
                owner.id()
            )))
        }
        _ => Ok(()),
    }
}

pub async fn give_kudos(
    kudos_contract_id: &workspaces::AccountId,
    sender: &workspaces::Account,
    receiver_id: &workspaces::AccountId,
    message: &str,
    icon_cid: Option<&WrappedCid>,
    hashtags: Vec<&str>,
) -> anyhow::Result<KudosId> {
    let res = sender
        .call(kudos_contract_id, "give_kudos")
        .args_json(json!({
            "receiver_id": receiver_id,
            "message": message,
            "hashtags": hashtags,
            "icon_cid": icon_cid
        }))
        .deposit(GIVE_KUDOS_COST)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Give kudos failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        });

    res.and_then(|res| {
        println!("gas burnt: {}", res.total_gas_burnt);
        res.json().map_err(|e| {
            anyhow::Error::msg(format!(
                "Failed to deserialize give kudos response: {e:?}. Receipts: {:?}",
                res.receipt_outcomes()
            ))
        })
    })
}

pub async fn upvote_kudos(
    kudos_contract_id: &workspaces::AccountId,
    sender: &workspaces::Account,
    receiver_id: &workspaces::AccountId,
    kudos_id: &KudosId,
) -> anyhow::Result<U64> {
    let res = sender
        .call(kudos_contract_id, "upvote_kudos")
        .args_json(json!({
            "receiver_id": receiver_id,
            "kudos_id": kudos_id,
        }))
        .deposit(UPVOTE_KUDOS_COST)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Upvote kudos failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        });

    res.and_then(|res| {
        println!("gas burnt: {}", res.total_gas_burnt);
        res.json().map_err(|e| {
            anyhow::Error::msg(format!(
                "Failed to deserialize upvote kudos response: {e:?}. Receipts: {:?}",
                res.receipt_outcomes()
            ))
        })
    })
}

pub async fn leave_comment(
    kudos_contract_id: &workspaces::AccountId,
    sender: &workspaces::Account,
    receiver_id: &workspaces::AccountId,
    kudos_id: &KudosId,
    parent_comment_id: Option<CommentId>,
    message: &str,
) -> anyhow::Result<CommentId> {
    let res = sender
        .call(kudos_contract_id, "leave_comment")
        .args_json(json!({
            "receiver_id": receiver_id,
            "kudos_id": kudos_id,
            "parent_comment_id": parent_comment_id,
            "message": message,
        }))
        .deposit(LEAVE_COMMENT_COST)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Leave comment failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        });

    res.and_then(|res| {
        println!("gas burnt: {}", res.total_gas_burnt);
        res.json().map_err(|e| {
            anyhow::Error::msg(format!(
                "Failed to deserialize leave comment response: {e:?}. Receipts: {:?}",
                res.receipt_outcomes()
            ))
        })
    })
}

pub async fn exchange_kudos_for_sbt(
    kudos_contract_id: &workspaces::AccountId,
    requestor: &workspaces::Account,
    kudos_id: &KudosId,
) -> anyhow::Result<Vec<u64>> {
    let res = requestor
        .call(kudos_contract_id, "exchange_kudos_for_sbt")
        .args_json(json!({
            "kudos_id": kudos_id,
        }))
        .deposit(EXCHANGE_KUDOS_COST)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Exchange kudos failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        });

    res.and_then(|res| {
        res.json().map_err(|e| {
            anyhow::Error::msg(format!(
                "Failed to deserialize exchange kudos response: {e:?}. Receipts: {:?}",
                res.receipt_outcomes()
            ))
        })
    })
}

pub async fn set_external_db(
    kudos_contract_id: &workspaces::AccountId,
    owner: &workspaces::Account,
    near_social: &workspaces::Contract,
) -> anyhow::Result<()> {
    let balance_bounds: StorageBalanceBounds = near_social
        .view("storage_balance_bounds")
        .args_json(json!({}))
        .await?
        .json()?;

    let _ = owner
        .call(kudos_contract_id, "set_external_db")
        .args_json(json!({
            "external_db_id": near_social.id()
        }))
        .deposit(balance_bounds.min.0 + ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Set external database failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        })?;

    Ok(())
}

pub async fn update_iah_registry(
    kudos_contract_id: &workspaces::AccountId,
    owner: &workspaces::Account,
    iah_registry: &workspaces::AccountId,
) -> anyhow::Result<()> {
    let _ = owner
        .call(kudos_contract_id, "update_iah_registry")
        .args_json(json!({ "iah_registry": iah_registry }))
        .deposit(SOCIAL_DB_GRANT_WRITE_PERMISSION_COST)
        .max_gas()
        .transact()
        .await?
        .into_result()
        .map_err(|e| {
            anyhow::Error::msg(format!(
                "Update IAH registry failure: {:?}",
                extract_error(e.outcomes().into_iter())
            ))
        })?;

    Ok(())
}

pub async fn storage_balance_of(
    contract_id: &workspaces::AccountId,
    user: &workspaces::Account,
) -> anyhow::Result<Option<StorageBalance>> {
    user.view(contract_id, "storage_balance_of")
        .args_json(json!({
          "account_id": user.id()
        }))
        .await?
        .json()
        .map_err(|e| {
            anyhow::Error::msg(format!("Storage balance of `{}` failure: {e:?}", user.id(),))
        })
}

// TODO: pass iterators instead
fn compare_slices<T: PartialEq>(sl1: &[T], sl2: &[T]) -> bool {
    let count = sl1
        .iter()
        .zip(sl2)
        .filter(|&(item1, item2)| item1 == item2)
        .count();

    count == sl1.len() && count == sl2.len()
}

pub fn extract_error<'a, I>(mut outcomes: I) -> anyhow::Error
where
    I: Iterator<Item = &'a ExecutionOutcome>,
{
    outcomes
        .find(|&outcome| outcome.is_failure())
        //.and_then(|outcome| outcome.clone().into_result().err())
        .map(|outcome| {
            outcome
                .clone()
                .into_result()
                .map_err(|e| anyhow!(e.into_inner().unwrap()))
                .unwrap_err()
        })
        .unwrap()
}

'''
'''--- tests/workspaces.rs ---
use std::str::FromStr;
use workspaces::network::{NetworkClient, NetworkInfo, Sandbox};
use workspaces::result::ExecutionSuccess;
use workspaces::{
    types::{Balance, KeyType, SecretKey},
    Account, Contract, DevNetwork, Worker,
};

// Generate user sub-account
pub async fn gen_user_account<T>(worker: &Worker<T>, account_id: &str) -> anyhow::Result<Account>
where
    T: DevNetwork + Send + Sync,
{
    let id = workspaces::AccountId::from_str(account_id)?;
    let sk = SecretKey::from_random(KeyType::ED25519);

    let account = worker.create_tla(id, sk).await?.into_result()?;

    Ok(account)
}

pub async fn transfer_near(
    worker: &Worker<Sandbox>,
    account_id: &workspaces::AccountId,
    deposit: Balance,
) -> anyhow::Result<ExecutionSuccess> {
    Ok(worker
        .root_account()?
        .transfer_near(account_id, deposit)
        .await?
        .into_result()?)
}

// Build contract from sources and initialize it
pub async fn build_contract<T>(
    worker: &Worker<T>,
    project_path: &str,
    init_method: &str,
    args: near_sdk::serde_json::Value,
) -> anyhow::Result<Contract>
where
    T: NetworkInfo + NetworkClient + DevNetwork + Send + Sync,
{
    let wasm = workspaces::compile_project(project_path).await?;

    let (id, sk) = worker.dev_generate().await;

    let contract = worker
        .create_tla_and_deploy(id.clone(), sk, &wasm)
        .await?
        .into_result()?;

    // initialize contract
    let _ = contract
        .call(init_method)
        .args_json(args)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    Ok(contract)
}

// Load already built contract and initialize it
pub async fn load_contract<T>(
    worker: &Worker<T>,
    contract_path: &str,
    init_method: &str,
    args: near_sdk::serde_json::Value,
) -> anyhow::Result<Contract>
where
    T: NetworkInfo + NetworkClient + DevNetwork + Send + Sync,
{
    let wasm = std::fs::read(contract_path)?;
    let (id, sk) = worker.dev_generate().await;

    let contract = worker
        .create_tla_and_deploy(id, sk, &wasm)
        .await?
        .into_result()?;

    // initialize contract
    let _ = contract
        .call(init_method)
        .args_json(args)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    Ok(contract)
}

// Get current block timestamp
pub async fn get_block_timestamp<T>(worker: &Worker<T>) -> anyhow::Result<u64>
where
    T: NetworkClient + Send + Sync,
{
    Ok(worker.view_block().await?.timestamp())
}

'''