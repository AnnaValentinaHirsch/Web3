*GitHub Repository "NEARFoundation/events-platform"*

'''--- .gitpod.yml ---
tasks:
  - init: npm dev
    command: npm run dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- README.md ---
Near Events
==================

This app was initialized with [create-near-app]

Quick Start
===========

If you haven't installed dependencies during setup:

    yarn

Build and deploy your contract to *Mainnet*:

    NEAR_ENV=mainnet near login
    yarn build
    NEAR_ENV=mainnet deploy --accountId YOUR_ACCOUNT_ID_ON_MAINNET --wasmFile contract/build/events.wasm

Exploring The Code
==================

1. The smart-contract code lives in the `/contract` folder. See the README there for
   more info. In blockchain apps, the smart contract is the "backend" of your app.
2. The near.social code lives in the `/near.social` folder.
3. Test your contract: `yarn test`, this will run the tests in the `integration-tests` directory.

Development
===========

0. Adjust Environment Variables in `near.social/.env` file
1. Run the local development environment:

    NEAR_ENV=mainnet yarn start

This will start the local near.social dev-server which will automatically redeploy your widgets on near.social mainnet when you change the code in the `widgets` folder.

## Features

1. Automatic redeployment:
    Widgets will automatically be redeployed on near.social when you change the code in the `widgets` folder.
2. Automatic widget registration:
    Widgets will be named after the folder they are in, so if you want to deploy a widget called `my-widget`, you should
    create a file called `component.jsx` in the `widgets` folder. Nested folders will be flattened, so if you
    you create a file called `my-widget/component.jsx`, the widget will be named `my-widget__component` on near.social.
3. env var substitution:
    You can use environment variables in your widget code. For example, any occurence of `{{ env.MY_VAR  }}` will be replaced with
    the value of the `MY_VAR` environment variable from an .env file. .env files are loaded from the `widgets` folder
    and from the widget file's context. For example, if you have a file called `widgets/my-widget/.env`
    and a file called `widgets/my-widget/component.jsx`, the .env file will be loaded for the `component.jsx` file.
    This works recursively, so if you have a file called `widgets/.env` and a file called `widgets/my-widget/nested/component.jsx`,
    the .env file will also be loaded for the `component.jsx` file. Only the topmost .env file will be loaded for each widget file.
    If you want a widget to have its own .env file, you can create a folder for it and put the .env file in that folder. For example,
    if you have a file called `widgets/my-widget/component.jsx` and a file called `widgets/my-widget/component/.env`,
    the .env file will be loaded for the `component.jsx` file, but not for any other widget files except for child widget files in the
    `component` folder.
4. Speed
    Widgets will be deployed on near.social as soon as you change the code in the `widgets` folder. This means that you can
    develop your widgets locally and deploy them on near.social as soon as you're ready.
5. App-like structure
   Widgets following this structure will have access to common components and utilities:
    1. Widgets can render child widgets by referencing their names (e.g. `renderComponent('some_widget.child.another', {})`).
    2. Widgets can within layouts (e.g. `renderComponent('some_widget.child.another', {}, 'container')`).
    3. Router with methods for navigating between pages (e.g. `push('some_widget')` and `pop()`).
    4. Shared Components (e.g. `props.__engine.Components.Button`).
    5. Overlays/Modals via layouts (e.g. `renderComponent('some_widget.child.another', {}, 'modal')`). This is useful for
       widgets that need to render a modal on top of the current page.

## Structure

1. `widgets` folder:
    This folder contains all the widgets that will be deployed on near.social. Each widget should be in its own folder.
    The folder name will be used as the widget name. For example, if you have a file called `widgets/my-widget/component.jsx`,
    the widget will be named `my-widget__component` on near.social. Nested folders will be flattened, so if you
    you create a file called `my-widget/parent/component.jsx`, the widget will be named `my-widget__parent__component` on near.social.
2. `widgets/.env` file:
    This file contains environment variables that will be used for all widgets. You can override these variables in the
    widget's .env file.
3. *TODO*: automatic upload of widget metadata
   1. - [ ] read metadata file from disc
   2. - [ ] check if image files from metadata file exist on ipfs
   3. - [ ] upload images from metadata file to ipfs
   4. - [ ] set metadata file for widget

## Open TODOs

- [ ] refactor layouting mechanism to be able to register layouts from within the component. This enables us to use to save the state of the router in the Storage, Currently callbacks like onClick cannot be saved to Storage, which causes the state of the router to be lost when the page is refreshed.
- [ ] metadata support for widgets (not a pressing issue, can be done in the web-ui)
- [ ] purging of all widgets of a user

Later:

- [ ] VSCode extension for widget development (live preview, mocking of widgets)

Deploy
======

Every smart contract in NEAR has its [own associated account][NEAR accounts].
When you run `yarn deploy`, your smart contract gets deployed to the live NEAR *TestNet* with a temporary dev account.
When you're ready to make it permanent, here's how:

Step 0: Install the `near-cli` (optional)
-------------------------------------

[near-cli] is a command line interface (CLI) for interacting with the NEAR blockchain. It was installed to the local
`node_modules` folder when you ran `yarn`, but for best ergonomics, you may want to install it globally:

    yarn global add near-cli

Or, if you'd rather use the locally-installed version, you can prefix all `near` commands with `yarn`

Ensure that it's installed with `near --version` (or `yarn near --version`)

Step 1: Create an account for the contract
------------------------------------------

Each account on NEAR can have at most one contract deployed to it. If you've already created an account such as
`your-name.testnet`, you can deploy your contract to `near-blank-project.your-name.testnet`. Assuming you've
already created an account on [NEAR Wallet], here's how to create `near-blank-project.your-name.testnet`:

1. Authorize NEAR CLI following the commands it gives you:

      near login

2. Create a subaccount (replace `YOUR-NAME` below with your actual account name):

      near create-account near-blank-project.YOUR-NAME.testnet --masterAccount YOUR-NAME.testnet

Step 2: Deploy the contract
---------------------------

Use the CLI to deploy the contract to TestNet with your account ID.
Replace `PATH_TO_WASM_FILE` with the `wasm` that was generated in the `contract` build directory.

    near deploy --accountId near-blank-project.YOUR-NAME.testnet --wasmFile PATH_TO_WASM_FILE

-----------------------------------------------

Troubleshooting
===============

On Windows, if you're seeing an error containing `EPERM` it may be related to spaces in your path. Please see
[this issue](https://github.com/zkat/npx/issues/209) for more details.

  [create-near-app]: https://github.com/near/create-near-app
  [NEAR accounts]: https://docs.near.org/concepts/basics/account
  [NEAR Wallet]: https://wallet.testnet.near.org/
  [near-cli]: https://github.com/near/near-cli

'''
'''--- contract/README.md ---
# Events platform smart contract

# Quickstart

1. Make sure you have installed [node.js](https://nodejs.org/en/download/package-manager/) >= 16.
2. Install the [`NEAR CLI`](https://github.com/near/near-cli#setup)

<br />

## 1. Build and Deploy the Contract

You can automatically compile and deploy the contract in the NEAR testnet by running:

```bash
yarn run deploy
```

Once finished, check the `neardev/dev-account` file to find the address in which the contract was deployed:

```bash
cat ./neardev/dev-account
# e.g. dev-1659899566943-21539992274727
```

<br />

## 2. Create an event

`create_event` changes the contract's state, so it is a `call` method.

`Call` methods can only be invoked using a NEAR account since the account needs to pay GAS for the transaction.

```bash
# Use near-cli to create a new event
near call <dev-account> create_event '{"name":"test","type":"irl","category":"test","status":"published","description":"test","start_date":"2023-01-11T14:54:06.652Z","end_date":"2023-01-12T14:54:06.652Z","location":"here","image":[],"links":[]}' --accountId <dev-account> --deposit 1
```

**Tip:** If you would like to call `create_event` using your account, first login into NEAR using:

```bash
# Use near-cli to login your NEAR account
near login
```

and then use the logged account to sign the transaction: `--accountId <your-account>`.

<br />

## 3. Get an existing event

`get_event` does not change the contract state, it only reads it so it is a `view` method.

`View` methods can be called for **free** by anyone, even people **without a NEAR account**!

```bash
# Use near-cli to get an existing event
near view <dev-account> get_event '{"event_id":"test"}'
```

<br />

## 4. Get all existing events

`get_all_events` does not change the contract state, it only reads it so it is a `view` method.

```bash
# Use near-cli to get all existing events
near view <dev-account> get_all_events '{}'
```

<br />

## 5. Get all events created by a specified account ID

`get_all_events_by_account` does not change the contract state, it only reads it so it is a `view` method.

```bash
# Use near-cli to get all existing events
near view <dev-account> get_all_events_by_account '{"account_id":"<dev-account>"}'
```

<br />

## 6. Update an existing event

`update_event` changes the contract's state, so it is a `call` method.

```bash
# Use near-cli to update an existing event
near call <dev-account> update_event '{"event_id":"test","event":{"description":"test2"}}' --accountId <dev-account>
```

**Note:** Keep in mind that if you created the event with your account you will also have to update it using the same account.

<br />

## 7. Delete an existing event

`remove_event` changes the contract's state, so it is a `call` method.

```bash
# Use near-cli to delete an existing event
near call <dev-account> remove_event '{"event_id":"test"}' --accountId <dev-account>
```

**Note:** Keep in mind that if you created the event with your account you will also have to delete it using the same account.

'''
'''--- contract/build.sh ---
#!/bin/sh

echo ">> Building contract"

near-sdk-js build src/contract.ts build/events.wasm

'''
'''--- contract/deploy-prod.sh ---
#!/bin/sh

./build.sh

if [ $? -ne 0 ]; then
  echo ">> Error building contract"
  exit 1
fi

echo ">> Deploying contract"

# https://docs.near.org/tools/near-cli#near-dev-deploy
near deploy --accountId nearevents.testnet --wasmFile build/events.wasm

'''
'''--- contract/deploy.sh ---
#!/bin/sh

./build.sh

if [ $? -ne 0 ]; then
  echo ">> Error building contract"
  exit 1
fi

echo ">> Deploying contract"

# https://docs.near.org/tools/near-cli#near-dev-deploy
near dev-deploy --wasmFile build/events.wasm

'''
'''--- contract/package.json ---
{
  "name": "near_events_contract",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "type": "module",
  "scripts": {
    "build": "./build.sh",
    "deploy": "./deploy.sh",
    "test": "echo use integration-tests"
  },
  "dependencies": {
    "near-cli": "^3.4.0",
    "near-sdk-js": "0.6.0"
  },
  "devDependencies": {
    "typescript": "^4.7.4",
    "ts-morph": "^16.0.0"
  }
}

'''
'''--- contract/src/contract.ts ---
// Find all our documentation at https://docs.near.org
import {
  NearBindgen,
  near,
  call,
  bytes,
  view,
  UnorderedMap,
  Vector,
  NearPromise,
  assert,
} from "near-sdk-js";
import { AccountId } from "near-sdk-js/lib/types";
import { EventListsMap } from "./helpers";
import { NotRequested } from "./types";
import {
  type Event,
  type CreateEvent,
  type UpdateEvent,
  type EventListEventEntry,
  type PermissionType,
  type EventListApiResponse,
  type EventListEventEntryApiResponse,
} from "./types";
import {
  type EventList,
  type CreateEventList,
  type UpdateEventList,
} from "./types";

const FOURTY_TGAS = BigInt("40000000000000");
const NO_DEPOSIT = BigInt(0);

@NearBindgen({})
export class HelloNear {
  events: UnorderedMap<Event> = new UnorderedMap("e");
  event_lists: EventListsMap = new EventListsMap("l");

  /**
   * Get event details for an existing event.
   */
  @view({})
  get_event({ event_id }: { event_id: string }): Event {
    return this.events.get(event_id);
  }

  /**
   * Get the latest event for an account.
   */
  @view({})
  get_latest_event({ account_id }: { account_id: string }): Event {
    return this.get_all_events_by_account({ account_id }).sort((a, b) => {
      return Number(b.created_at) - Number(a.created_at);
    })[0];
  }

  /**
   * Check if an event exists.
   */
  @view({})
  has_event({ event_id }: { event_id: string }): Boolean {
    return this.events.get(event_id) !== null;
  }

  /**
   * Create a new event.
   */
  @call({ payableFunction: true })
  create_event(createEvent: CreateEvent): NearPromise {
    // We want to charge the user for storing an event in our contract.
    // This means we need to calculate how much they have to pay, so we
    // keep track of our current storage usage.
    const oldStorageUsage = near.storageUsage();
    const owner_account_id = near.signerAccountId();

    const uuid = genUUID();

    const event = <Event>{
      ...createEvent,
      id: uuid,
      owner_account_id,
      created_at: now(),
      last_updated_at: now(),
      start_date: new Date(createEvent.start_date),
      end_date: new Date(createEvent.end_date),
    };

    // Store the event in the events map.
    this.events.set(uuid, event);

    // We check how much storage was taken up by the creation and how
    // much NEAR was deposited.
    const newStorageUsage = near.storageUsage();
    const storageUsedByCall = newStorageUsage - oldStorageUsage;
    const priceOfUsedStorage = storageUsedByCall * near.storageByteCost();
    const attachedDeposit = near.attachedDeposit();

    // If there wasn't enough NEAR deposited we remove the change and
    // throw an error.
    if (attachedDeposit < priceOfUsedStorage) {
      this.events.remove(uuid);

      depositMissingError("event", priceOfUsedStorage);
    }

    // If there was a sufficient amount deposited, we refund any surplus.
    const refundAmount = attachedDeposit - priceOfUsedStorage;

    // We return a promise that will return the event to the user.
    const returnEventPromise = NearPromise.new(
      near.currentAccountId()
    ).functionCall(
      "return_event",
      JSON.stringify({ event_id: uuid }),
      NO_DEPOSIT,
      FOURTY_TGAS
    );

    if (refundAmount > 0) {
      return NearPromise.new(owner_account_id)
        .transfer(refundAmount)
        .then(returnEventPromise);
    }
    return returnEventPromise;
  }

  @call({ privateFunction: true })
  return_event(args: { event_id: string }): Event {
    return this.events.get(args.event_id);
  }

  /**
   * Get event details for all events.
   */
  @view({})
  get_all_events(): Event[] {
    return this.events.toArray().map(([, event]) => event);
  }

  /**
   * Get event details for all events created by a passed in account ID.
   */
  @view({})
  get_all_events_by_account({
    account_id,
  }: {
    account_id: AccountId;
  }): Event[] {
    return this.get_all_events().filter(
      (event) => event.owner_account_id === account_id
    );
  }

  /**
   * Update an existing event.
   */
  @call({ payableFunction: true })
  update_event({
    event_id,
    event,
  }: {
    event_id: string;
    event: Partial<UpdateEvent>;
  }): NearPromise {
    // First we check if there is an event with the specified ID.
    const currentEvent = this.events.get(event_id);

    assert(currentEvent, `The event with id: ${event_id} does not exist!`);

    // Then we check if the signer of the transaction is the owner of the event.
    const signerAccountId = near.signerAccountId();

    assert(
      signerAccountId === currentEvent.owner_account_id,
      "You do not have permission to edit this event!"
    );

    // We keep track of used storage again.
    const oldStorageUsage = near.storageUsage();

    // We update the storage to reflect the update.
    this.events.set(event_id, {
      ...currentEvent,
      ...event,
      start_date: new Date(event.start_date || currentEvent.start_date),
      end_date: new Date(event.end_date || currentEvent.end_date),
      last_updated_at: now(),
    });

    // Then we get the storage change - in this case it might be negative as the update
    // might take up less bytes then the previous version.
    const newStorageUsage = near.storageUsage();
    const storageUsedByCall = newStorageUsage - oldStorageUsage;
    const priceOfUsedStorage = storageUsedByCall * near.storageByteCost();
    const attachedDeposit = near.attachedDeposit();

    // If the attached deposit wasn't enough to cover for the change, we revert
    // the change and throw an error.
    if (attachedDeposit < priceOfUsedStorage) {
      this.events.set(event_id, currentEvent);

      depositMissingError("event", priceOfUsedStorage);
    }

    // We refund the signer if need be.
    const refundAmount = attachedDeposit - priceOfUsedStorage;

    const returnEventPromise = NearPromise.new(
      near.currentAccountId()
    ).functionCall(
      "return_event",
      JSON.stringify({ event_id }),
      NO_DEPOSIT,
      FOURTY_TGAS
    );

    if (refundAmount > 0) {
      return NearPromise.new(signerAccountId)
        .transfer(refundAmount)
        .then(returnEventPromise);
    }
    return returnEventPromise;
  }

  /**
   * Remove an event.
   */
  @call({})
  remove_event({ event_id }: { event_id: string }): NearPromise {
    // We check if the event exists.
    const currentEvent = this.events.get(event_id);

    assert(currentEvent, `The event with id: ${event_id} does not exist!`);

    // We check that the signer is the owner of the event.
    const signerAccountId = near.signerAccountId();

    assert(
      signerAccountId === currentEvent.owner_account_id,
      "You do not have permission to edit this event!"
    );

    // We keep track of the storage usage.
    const oldStorageUsage = near.storageUsage();

    // Then we remove the event.
    this.events.remove(event_id);

    // Finally we refund the signer with the amount of freed up space for
    // removing the event from storage.
    const newStorageUsage = near.storageUsage();
    const storageFreedByCall = newStorageUsage - oldStorageUsage;
    const priceOfFreedStorage = storageFreedByCall * near.storageByteCost();

    // Note: the params are swapped
    return refundDifference(priceOfFreedStorage, BigInt(0));
  }

  /**
   * Get all event lists.
   * @returns EventList[]
   */
  @view({})
  get_all_event_lists(): EventListApiResponse[] {
    return this.event_lists
      .toArray()
      .map(([, event_list]) => event_list)
      .map(
        (event_list) =>
          <EventListApiResponse>{
            ...event_list,
            has_events: event_list.events.length > 0,
            event_count: event_list.events.length,
            events: { too_expensive: true },
          }
      );
  }

  /**
   * Get all event lists for a given account.
   * @param account_id the account id
   * @returns EventList[]
   */
  @view({})
  get_all_event_lists_by_account({
    account_id,
  }: {
    account_id: AccountId;
  }): EventListApiResponse[] {
    return this.get_all_event_lists().filter(
      (event_list) => event_list.owner_account_id === account_id
    );
  }

  /**
   * Get a single event list.
   * @param event_list_id the event list id
   * @returns EventList | undefined
   */
  @view({})
  get_event_list({
    event_list_id,
    include_events,
  }: {
    event_list_id: string;
    include_events?: boolean;
  }): EventListApiResponse | null {
    const event_list = this.event_lists.get(event_list_id);
    if (!event_list) {
      return null;
    }
    return <EventListApiResponse>{
      ...event_list,
      has_events: event_list.events.length > 0,
      event_count: event_list.events.length,
      events: include_events
        ? this.get_events_in_event_list({ event_list_id })
        : <NotRequested>{},
    };
  }

  /**
   * Get if the event list exists.
   * @param event_list_id the event list id
   * @returns boolean
   */
  @view({})
  has_event_list({ event_list_id }: { event_list_id: string }): boolean {
    return this.event_lists.has(event_list_id);
  }

  /**
   * Create a new event list.
   * @param createEventList
   * @returns NearPromise
   */
  @call({ payableFunction: true })
  create_event_list(createEventList: CreateEventList): NearPromise {
    // We want to charge the user for storing an event in our contract.
    // This means we need to calculate how much they have to pay, so we
    // keep track of our current storage usage.
    const oldStorageUsage = near.storageUsage();
    const owner_account_id = near.signerAccountId();

    const uuid = genUUID();

    const eventList = <EventList>{
      ...createEventList,
      id: uuid,
      owner_account_id,
      created_at: now(),
      last_updated_at: now(),
      permissions: <UnorderedMap<{ permissions: PermissionType[] }>>(
        new UnorderedMap("p")
      ),
      events: <Vector<EventListEventEntry>>new Vector("v"),
    };

    // Store the event in the events map.
    this.event_lists.set(uuid, eventList);

    // We check how much storage was taken up by the creation and how
    // much NEAR was deposited.
    const newStorageUsage = near.storageUsage();
    const storageUsedByCall = newStorageUsage - oldStorageUsage;
    const priceOfUsedStorage = storageUsedByCall * near.storageByteCost();
    const attachedDeposit = near.attachedDeposit();

    // If there wasn't enough NEAR deposited we remove the change and
    // throw an error.
    if (attachedDeposit < priceOfUsedStorage) {
      this.event_lists.remove(uuid);

      depositMissingError("event_list", priceOfUsedStorage);
    }

    // If there was a sufficient amount deposited, we refund any surplus.
    const refundAmount = attachedDeposit - priceOfUsedStorage;

    // We return a promise that will return the event to the user.
    const returnEventListPromise = NearPromise.new(
      near.currentAccountId()
    ).functionCall(
      "return_event_list_api_response",
      JSON.stringify({ event_list_id: uuid }),
      NO_DEPOSIT,
      FOURTY_TGAS
    );

    if (refundAmount > 0) {
      return NearPromise.new(owner_account_id)
        .transfer(refundAmount)
        .then(returnEventListPromise);
    }
    return returnEventListPromise;
  }

  /**
   * private function to return an event list.
   * used as private callback
   */
  @call({ privateFunction: true })
  return_event_list_api_response(args: {
    event_list_id: string;
  }): EventListApiResponse {
    const list = this.event_lists.get(args.event_list_id);

    return <EventListApiResponse>{
      id: list.id,
      name: list.name,
      description: list.description,
      owner_account_id: list.owner_account_id,
      created_at: list.created_at,
      last_updated_at: list.last_updated_at,
      has_events: list.events.length > 0,
      event_count: list.events.length,
    };
  }

  /**
   * Update an event list.
   * @param event_list_id The ID of the event list to update.
   * @param event_list The new event list data.
   * @returns The updated event list.
   */
  @call({ payableFunction: true })
  update_event_list({
    event_list_id,
    event_list,
  }: {
    event_list_id: string;
    event_list: Partial<UpdateEventList>;
  }): NearPromise {
    // First we check if there is an event_list with the specified ID.
    const currentEventList = this.event_lists.get(event_list_id);

    assert(
      currentEventList,
      `The event_list with id: ${event_list_id} does not exist!`
    );

    // Temporary: We check if the signer of the transaction is the owner of the event_list.
    const signerAccountId = near.signerAccountId();

    // TODO: check if signer is owner or has permission to edit instead
    assert(
      signerAccountId === currentEventList.owner_account_id,
      "You do not have permission to edit this event_list!"
    );

    // We keep track of used storage again.
    const oldStorageUsage = near.storageUsage();

    // We update the storage to reflect the update.
    this.event_lists.set(event_list_id, {
      ...currentEventList,
      ...event_list,
      last_updated_at: now(),
    });

    // Then we get the storage change - in this case it might be negative as the update
    // might take up less bytes then the previous version.
    const newStorageUsage = near.storageUsage();
    const storageUsedByCall = newStorageUsage - oldStorageUsage;
    const priceOfUsedStorage = storageUsedByCall * near.storageByteCost();
    const attachedDeposit = near.attachedDeposit();

    // If the attached deposit wasn't enough to cover for the change, we revert
    // the change and throw an error.
    if (attachedDeposit < priceOfUsedStorage) {
      this.event_lists.set(event_list_id, currentEventList);

      depositMissingError("event_list", priceOfUsedStorage);
    }

    // We refund the signer if need be.
    const refundAmount = attachedDeposit - priceOfUsedStorage;

    const returnEventListPromise = NearPromise.new(
      near.currentAccountId()
    ).functionCall(
      "return_event_list_api_response",
      JSON.stringify({ event_list_id }),
      NO_DEPOSIT,
      FOURTY_TGAS
    );

    if (refundAmount > 0) {
      return NearPromise.new(signerAccountId)
        .transfer(refundAmount)
        .then(returnEventListPromise);
    }
    return returnEventListPromise;
  }

  /**
   * Remove an event list.
   * @param event_list_id The ID of the event list to delete.
   */
  @call({ payableFunction: true })
  remove_event_list({ event_list_id }: { event_list_id: string }): NearPromise {
    // First we check if there is an event_list with the specified ID.
    const currentEventList = this.event_lists.get(event_list_id);

    assert(
      currentEventList,
      `The event_list with id: ${event_list_id} does not exist!`
    );

    // Temporary: We check if the signer of the transaction is the owner of the event_list.
    const signerAccountId = near.signerAccountId();

    // TODO: check if signer is owner or has permission to edit instead
    assert(
      signerAccountId === currentEventList.owner_account_id,
      "You do not have permission to delete this event_list!"
    );

    // We keep track of used storage again.
    const oldStorageUsage = near.storageUsage();

    // We delete the event list.
    this.event_lists.remove(event_list_id);

    // Finally we refund the signer with the amount of freed up space for
    // removing the event from storage.
    const newStorageUsage = near.storageUsage();
    const storageFreedByCall = newStorageUsage - oldStorageUsage;
    const priceOfFreedStorage = storageFreedByCall * near.storageByteCost();

    // Note: the params are swapped
    return refundDifference(priceOfFreedStorage, BigInt(0));
  }

  /**
   * Add an event to an event list.
   * @param event_list_id The ID of the event list to add the event to.
   * @param event_id The ID of the event to add.
   */
  @call({ payableFunction: true })
  add_event_to_event_list({
    event_list_id,
    event_id,
    position,
  }: {
    event_list_id: string;
    event_id: string;
    position: number;
  }): NearPromise {
    // First we check if there is an event_list with the specified ID.
    const currentEventList = this.event_lists.get(event_list_id);
    assert(
      currentEventList,
      `The event_list with id: ${event_list_id} does not exist!`
    );

    // Then we check if there is an event with the specified ID.
    const currentEvent = this.events.get(event_id);
    assert(currentEvent, `The event with id: ${event_id} does not exist!`);

    // Temporary: We check if the signer of the transaction is the owner of the event_list.
    const signerAccountId = near.signerAccountId();

    // TODO: check if signer is owner or has permission to add events instead
    assert(
      signerAccountId === currentEventList.owner_account_id,
      "You do not have permission to add events to this event_list!"
    );

    // check if event is already in event list
    const eventInEventList = currentEventList.events.toArray().find((event) => {
      return event.event_id === event_id;
    });
    assert(
      !eventInEventList,
      `The event with id: ${event_id} is already in the event list with id: ${event_list_id}!`
    );

    // We keep track of used storage again.
    const oldStorageUsage = near.storageUsage();

    // We add the event to the event list.
    // `events.push()` manipulates the original vector
    // so we need to create a copy of the vector first.
    // clone Vector
    const newEvents = <Vector<EventListEventEntry>>(
      new Vector(currentEventList.events.prefix)
    );
    const reorderedEvents = buildOrderedEventEntryList(
      currentEventList.events.toArray(),
      {
        event_id,
        position,
        last_updated_at: now(),
        added_by: signerAccountId,
        last_updated_by: signerAccountId,
      },
      signerAccountId,
      position
    );
    newEvents.extend(reorderedEvents);

    // We update the event_list in storage.
    this.event_lists.set(event_list_id, {
      ...currentEventList,
      events: newEvents,
    });

    // Then we get the storage change - in this case it might be negative as the update
    // might take up less bytes then the previous version.
    const newStorageUsage = near.storageUsage();

    const storageUsedByCall = newStorageUsage - oldStorageUsage;
    const priceOfUsedStorage = storageUsedByCall * near.storageByteCost();
    const attachedDeposit = near.attachedDeposit();

    // If the attached deposit wasn't enough to cover for the change, we revert
    // the change and throw an error.
    if (attachedDeposit < priceOfUsedStorage) {
      this.event_lists.set(event_list_id, {
        ...currentEventList,
        // set to original value
        events: currentEventList.events,
      });

      depositMissingError("new event in the event_list", priceOfUsedStorage);
    }

    return refundDifference(attachedDeposit, priceOfUsedStorage);
  }

  /**
   * Check if an event is in an event list.
   * @param event_list_id The ID of the event list to check.
   * @param event_id The ID of the event to check.
   * @returns True if the event is in the event list, false otherwise.
   */
  @view({})
  is_event_in_event_list({
    event_list_id,
    event_id,
  }: {
    event_list_id: string;
    event_id: string;
  }): boolean {
    // Then we check if there is an event with the specified ID.
    if (!this.has_event({ event_id })) {
      return false;
    }
    // First we check if there is an event_list with the specified ID.
    const currentEventList = this.event_lists.get(event_list_id);
    if (!currentEventList) {
      return false;
    }

    // check
    return currentEventList.events.toArray().some((event) => {
      return event.event_id === event_id;
    });
  }

  /**
   * Get the position of an event in an event list.
   * @param event_list_id The ID of the event list to check.
   * @param event_id The ID of the event to check.
   * @returns The position of the event in the event list.
   */
  @view({})
  get_event_position_in_event_list({
    event_list_id,
    event_id,
  }: {
    event_list_id: string;
    event_id: string;
  }): number {
    // First we check if there is an event_list with the specified ID.
    const currentEventList = this.event_lists.get(event_list_id);
    assert(
      currentEventList,
      `The event_list with id: ${event_list_id} does not exist!`
    );

    // Then we check if there is an event with the specified ID.
    const currentEvent = this.events.get(event_id);
    assert(currentEvent, `The event with id: ${event_id} does not exist!`);

    // check
    const eventInEventList = currentEventList.events.toArray().find((event) => {
      return event.event_id === event_id;
    });
    assert(
      eventInEventList,
      `The event with id: ${event_id} is not in the event list with id: ${event_list_id}!`
    );

    return eventInEventList.position;
  }

  /**
   * Get the events in an event list.
   * @param event_list_id The ID of the event list to get the events from.
   * @returns The events in the event list.
   * @note This method is not paginated.
   * @note This method is not sorted.
   */
  @view({})
  get_events_in_event_list({
    event_list_id,
  }: {
    event_list_id: string;
  }): EventListEventEntryApiResponse[] {
    // First we check if there is an event_list with the specified ID.
    const currentEventList = this.event_lists.get(event_list_id);
    assert(
      currentEventList,
      `The event_list with id: ${event_list_id} does not exist!`
    );

    // @petar
    // not sure about this method of getting the events.
    // this.events.get() in a loop may be expensive since it performs
    // multiple storage reads?
    return currentEventList.events.toArray().map((eventEntry) => {
      return <EventListEventEntryApiResponse>{
        position: eventEntry.position,
        added_by: eventEntry.added_by,
        last_updated_by: eventEntry.last_updated_by,
        last_updated_at: eventEntry.last_updated_at,
        event: { ...this.events.get(eventEntry.event_id) },
      };
    });
  }

  /**
   * Remove an event from an event list.
   * @param event_list_id The ID of the event list to remove the event from.
   * @param event_id The ID of the event to remove.
   */
  @call({ payableFunction: true })
  remove_event_from_event_list({
    event_list_id,
    event_id,
  }: {
    event_list_id: string;
    event_id: string;
  }): NearPromise {
    // First we check if there is an event_list with the specified ID.
    const currentEventList = this.event_lists.get(event_list_id);
    assert(
      currentEventList,
      `The event_list with id: ${event_list_id} does not exist!`
    );

    // Then we check if there is an event with the specified ID.
    const currentEvent = this.events.get(event_id);
    assert(currentEvent, `The event with id: ${event_id} does not exist!`);

    // Temporary: We check if the signer of the transaction is the owner of the event_list.
    const signerAccountId = near.signerAccountId();

    // TODO: check if signer is owner or has permission to add events instead
    assert(
      signerAccountId === currentEventList.owner_account_id,
      "You do not have permission to add events to this event_list!"
    );

    // check if event is in event list
    const isEventInEventList = this.is_event_in_event_list({
      event_list_id,
      event_id,
    });
    assert(
      isEventInEventList,
      `The event with id: ${event_id} is not in the event list with id: ${event_list_id}!`
    );

    // We keep track of used storage again.
    const oldStorageUsage = near.storageUsage();

    // We remove the event from the event list.
    // `events.splice()` manipulates the original vector
    // so we need to create a copy of the vector first.
    // clone Vector
    const newEvents = <Vector<EventListEventEntry>>(
      new Vector(currentEventList.events.prefix)
    );

    // find event position in event list, remove it and fill gaps in positions
    const oldEvents = currentEventList.events.toArray();
    const position = oldEvents.findIndex(
      (event) => event.event_id === event_id
    );
    oldEvents.splice(position, 1);
    newEvents.extend(fillGapsInEventEntryList(oldEvents, signerAccountId));

    // We update the event_list in storage.
    this.event_lists.set(event_list_id, {
      ...currentEventList,
      events: newEvents,
    });

    // Then we get the storage change - in this case it might be negative as the update
    // might take up less bytes then the previous version.
    const newStorageUsage = near.storageUsage();

    const storageUsedByCall = newStorageUsage - oldStorageUsage;
    const priceOfUsedStorage = storageUsedByCall * near.storageByteCost();
    const attachedDeposit = near.attachedDeposit();

    // If the attached deposit wasn't enough to cover for the change, we revert
    // the change and throw an error. This can happen if the event_list is very large and
    // the accountId is a long string and is removing an event from the event_list in front
    // as it updates the last_updated_by field when reordering the events.
    if (attachedDeposit < priceOfUsedStorage) {
      this.event_lists.set(event_list_id, {
        ...currentEventList,
        // set to original value
        events: currentEventList.events,
      });

      depositMissingError("event_list", priceOfUsedStorage);
    }

    return refundDifference(attachedDeposit, priceOfUsedStorage);
  }
}

/**
 * Helper function to refund the difference between the attached deposit and the cost of the entity.
 * @param attachedDeposit The attached deposit.
 * @param priceOfUsedStorage The cost of the entity.
 * @returns A promise that resolves to the refund.
 */
function refundDifference(
  attachedDeposit: bigint,
  priceOfUsedStorage: bigint
): NearPromise {
  if (attachedDeposit > priceOfUsedStorage) {
    const signerAccountId = near.signerAccountId();
    return NearPromise.new(signerAccountId).transfer(
      attachedDeposit - priceOfUsedStorage
    );
  }
}

/**
 * Helper function to throw an error if the attached deposit is not enough to cover for the cost of the entity.
 * @param entity The entity that is being stored.
 * @param cost The cost of the entity.
 * throws Error
 */
function depositMissingError(entity: string, cost: bigint) {
  const attachedDeposit = near.attachedDeposit();
  assert(
    false,
    `
You haven't attached enough NEAR to pay for the cost of the ${entity} you are storing.
You attached: ${attachedDeposit}
The cost was: ${cost}
You must attach an additional: ${attachedDeposit - cost} YoctoNEAR
`
  );
}

/**
 *
 * @param arr
 * @param newEvent
 * @param signerAccountId
 * @param position
 * @returns Array of events with updated positions and new event added
 */

function buildOrderedEventEntryList(
  arr: Array<EventListEventEntry>,
  newEvent: EventListEventEntry,
  signerAccountId: AccountId,
  position: number
) {
  // we need to update the position of all events after the new event
  // and update who and when updated the event
  const newEvents = arr.map((event) => {
    if (event.position >= position) {
      return {
        ...event,
        position: event.position + 1,
        last_updated_at: now(),
        last_updated_by: signerAccountId,
      };
    }
    return { ...event };
  });

  newEvents.push(newEvent);

  return fillGapsInEventEntryList(newEvents, signerAccountId);
}

/**
 * Helper function to fill the gaps in the positions of the events.
 * @param arr The array of events.
 * @param signerAccountId The accountId of the signer.
 * @returns Array of events with updated positions.
 */
function fillGapsInEventEntryList(
  arr: Array<EventListEventEntry>,
  signerAccountId: AccountId
): Array<EventListEventEntry> {
  return arr
    .sort((a, b) => a.position - b.position)
    .map((event, index) => {
      if (event.position !== index) {
        return {
          ...event,
          position: index,
          last_updated_at: now(),
          last_updated_by: signerAccountId,
        };
      }
      return { ...event };
    });
}

/**
 * @returns {string} A random string.
 */
function genUUID(): string {
  return bytes(near.randomSeed())
    .split("")
    .map((c) => {
      return c.charCodeAt(0).toString(16);
    })
    .join("");
}

/**
 * @returns {Date} The current date.
 */
function now() {
  return new Date(Number(near.blockTimestamp()) / 1000000);
}

'''
'''--- contract/src/helpers.ts ---
import { assert, near, UnorderedMap, Vector } from "near-sdk-js";
import {
  type EventList,
  type PermissionType,
  type EventListEventEntry,
} from "./types";

const dummyEventList = {
  id: "",
  owner_account_id: "",
  name: "",
  description: "",
  created_at: new Date(),
  last_updated_at: new Date(),
  events: new Vector("") as unknown as Vector<EventListEventEntry>,
  permissions: new UnorderedMap("perms") as unknown as UnorderedMap<{
    permissions: PermissionType[];
  }>,
} satisfies EventList;

/**
 * Check if given value implements the EventList type.
 *
 * @param value - A value to be checked for compatibility with the EventList type.
 */
const checkIsEventList = (value: unknown): value is EventList => {
  if (typeof value !== "object") {
    return false;
  }

  const all_keys_present =
    Object.keys(dummyEventList).every((key) => key in value) &&
    Object.keys(value).every((key) => key in dummyEventList);

  if (!all_keys_present) {
    return false;
  }

  return true;
};

/**
 * Reconstructor for the EventList type.
 *
 * @param value - The value to be used to reconstruct into an EventList.
 */
export const eventListReconstructor = (value: unknown): EventList => {
  assert(
    checkIsEventList(value),
    `Value: ${value} cannot be reconstructed into EventList`
  );

  return {
    id: value.id,
    owner_account_id: value.owner_account_id,
    name: value.name,
    description: value.description,
    created_at: new Date(value.created_at),
    last_updated_at: new Date(value.last_updated_at),
    permissions: UnorderedMap.reconstruct(value.permissions),
    events: Vector.reconstruct(value.events),
  };
};

/**
 * A wrapper around the base UnorderedMap collection to make basic actions
 * more ergonomic by passing the required eventListReconstructor to the
 * appropriate methods.
 */
export class EventListsMap {
  map: UnorderedMap<EventList>;

  /**
   * @param prefix - The byte prefix to use when storing elements inside this collection.
   */
  constructor(prefix: string) {
    this.map = new UnorderedMap(prefix);
  }

  /**
   * The number of elements stored in the collection.
   */
  get length(): number {
    return this.map.length;
  }

  /**
   * Checks whether the collection is empty.
   */
  isEmpty(): boolean {
    return this.map.isEmpty();
  }

  /**
   * Get the data stored at the provided key.
   *
   * @param key - The key at which to look for the data.
   */
  get(key: string): EventList {
    return this.map.get(key, { reconstructor: eventListReconstructor });
  }

  /**
   * Store a new value at the provided key.
   *
   * @param key - The key at which to store in the collection.
   * @param value - The value to store in the collection.
   */
  set(key: string, value: EventList): EventList {
    return this.map.set(key, value);
  }

  /**
   * Removes and retrieves the element with the provided key.
   *
   * @param key - The key at which to remove data.
   */
  remove(key: string): EventList {
    return this.map.remove(key, { reconstructor: eventListReconstructor });
  }

  /**
   * Determine if the collection contains a value with the provided key.
   */
  has(key: string): boolean {
    return this.map.toArray().some(([k]) => k === key);
  }

  /**
   * Remove all of the elements stored within the collection.
   */
  clear(): void {
    return this.map.clear();
  }

  /**
   * Return a JavaScript array of the data stored within the collection.
   *
   * @param options - Options for retrieving and storing the data.
   */
  toArray(): [string, EventList][] {
    return this.map.toArray({ reconstructor: eventListReconstructor });
  }

  /**
   * Extends the current collection with the passed in array of key-value pairs.
   *
   * @param keyValuePairs - The key-value pairs to extend the collection with.
   */
  extend(keyValuePairs: [string, EventList][]): void {
    this.map.extend(keyValuePairs);
  }

  /**
   * Serialize the collection.
   */
  serialize(): string {
    return this.map.serialize();
  }

  /**
   * Converts the deserialized data from storage to a JavaScript instance of the collection.
   *
   * @param data - The deserialized data to create an instance from.
   */
  static reconstruct(data: EventListsMap): EventListsMap {
    const map = new EventListsMap(data.map.prefix);

    map.map = UnorderedMap.reconstruct(data.map);

    return map;
  }
}

'''
'''--- contract/src/types.ts ---
import { Vector, UnorderedMap } from "near-sdk-js";
import { AccountId } from "near-sdk-js/lib/types";

type ObjectValues<Object> = Object[keyof Object];

export const EventTypes = {
  virtual: "virtual",
  irl: "irl",
  mixed: "mixed",
} as const;

/**
 * Type of event.
 */
type EventType = ObjectValues<typeof EventTypes>;

export const EventStatuses = {
  draft: "draft",
  published: "published",
  cancelled: "cancelled",
} as const;

/**
 * Status of event.
 */
type EventStatus = ObjectValues<typeof EventStatuses>;

export const ImageTypes = {
  banner: "banner",
  tile: "tile",
} as const;

/**
 * Type of image.
 */
type ImageType = ObjectValues<typeof ImageTypes>;

export const LinkTypes = {
  register: "register",
  tickets: "tickets",
  join_stream: "join_stream",
} as const;

/**
 * Type of link.
 */
type LinkType = ObjectValues<typeof LinkTypes>;

/**
 * An object representing the Event and all its detials.
 */
export type Event = {
  id: string;
  owner_account_id: AccountId;
  created_at: Date;
  last_updated_at: Date;
  name: string;
  type: EventType;
  category: string;
  status: EventStatus;
  description: string;
  start_date: Date;
  end_date: Date;
  location: string;
  images: {
    url: string;
    type: ImageType;
  }[];
  links: {
    text: string;
    type: LinkType;
    url: string;
  }[];
  liked_by: string[];
};

/**
 * Data needed for event creation.
 */
export type CreateEvent = Pick<
  Event,
  | "name"
  | "type"
  | "category"
  | "status"
  | "start_date"
  | "end_date"
  | "location"
  | "images"
  | "links"
  | "description"
>;

/**
 * Data accepted for event update.
 */
export type UpdateEvent = Partial<CreateEvent>;

export const PermissionTypes = {
  add_list_entry: "add_list_entry",
  remove_list_entry: "remove_list_entry",
  change_list: "change_list",
} as const;

/**
 * Type of permission.
 */
export type PermissionType = ObjectValues<typeof PermissionTypes>;

export type EventListEventEntry = {
  event_id: string;
  last_updated_at: Date;
  added_by: AccountId;
  position: number;
  last_updated_by: AccountId;
};

/**
 * An object representing an EventList and all its details.
 */
export type EventList = {
  id: string;
  owner_account_id: AccountId;
  name: string;
  description: string;
  created_at: Date;
  last_updated_at: Date;

  permissions: UnorderedMap<{ permissions: PermissionType[] }>;
  events: Vector<EventListEventEntry>;
};

/**
 * Data needed for event list creation.
 */
export type CreateEventList = Pick<EventList, "name" | "description">;

/**
 * Data accepted for event update.
 */
export type UpdateEventList = Partial<CreateEventList>;

export type EventListApiResponse = {
  id: string;
  name: string;
  description: string;
  created_at: Date;
  last_updated_at: Date;
  owner_account_id: AccountId;
  has_events: boolean;
  event_count: number;
  events: EventListEventEntryApiResponse[] | NotRequested | TooExpensive;
};

export type NotRequested = { not_requested: true };
export type TooExpensive = { too_expensive: true };

export type EventListEventEntryApiResponse = {
  event: Event;
  last_updated_at: Date;
  added_by: AccountId;
  position: number;
  last_updated_by: AccountId;
};

'''
'''--- contract/tsconfig.json ---
{
  "compilerOptions": {
    "experimentalDecorators": true,
    "target": "ES2020",
    "moduleResolution": "node",
    "noEmit": true
  },
  "exclude": [
    "node_modules"
  ]
}

'''
'''--- integration-tests/package.json ---
{
  "name": "ava-testing",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "test": "ava"
  },
  "devDependencies": {
    "@types/bn.js": "^5.1.0",
    "@types/node": "^18.6.2",
    "ava": "^4.2.0",
    "near-workspaces": "^3.2.1",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2"
  },
  "dependencies": {}
}

'''
'''--- integration-tests/src/_setup.ts ---
import { Worker, NearAccount } from "near-workspaces";
import anyTest, { TestFn } from "ava";

export const THREE_HUNDRED_TGAS = "300000000000000";
export { ONE_NEAR } from "near-workspaces";

export const test = anyTest as TestFn<{
  worker: Worker;
  accounts: Record<string, NearAccount>;
}>;

test.beforeEach(async (t) => {
  // Init the worker and start a Sandbox server
  const worker = await Worker.init();

  // Deploy contract
  const root = worker.rootAccount;
  const contract = await root.createSubAccount("test-account");
  // Get wasm file path from package.json test script in folder above
  await contract.deploy(process.argv[2]);

  // Save state for test runs, it is unique for each test
  t.context.worker = worker;
  t.context.accounts = { root, contract };
});

test.afterEach.always(async (t) => {
  // Stop Sandbox server
  await t.context.worker.tearDown().catch((error) => {
    console.log("Failed to stop the Sandbox:", error);
  });
});

'''
'''--- integration-tests/src/event_lists.ava.ts ---
import { NearAccount } from "near-workspaces";

import {
  Event,
  EventList,
  CreateEvent,
  EventListApiResponse,
} from "../../contract/src/types";
import { test, THREE_HUNDRED_TGAS, ONE_NEAR } from "./_setup";
import { EventListEventEntryApiResponse } from "../../contract/src/types";

async function createEvent(
  contract: NearAccount,
  executingUser?: NearAccount
): Promise<Event> {
  const now = new Date().toISOString();

  const executingAccount = executingUser || contract;

  return <Event>await executingAccount.call(
    contract,
    "create_event",
    {
      name: "test",
      type: "irl",
      category: "test",
      status: "published",
      description: "test",
      start_date: now,
      end_date: now,
      location: "here",
      images: [],
      links: [],
    },
    {
      attachedDeposit: ONE_NEAR,
      gas: THREE_HUNDRED_TGAS,
    }
  );
}

async function createEventList(
  contract: NearAccount,
  executingUser?: NearAccount
): Promise<EventList> {
  const executingAccount = executingUser || contract;
  return <EventList>await executingAccount.call(
    contract,
    "create_event_list",
    {
      name: "test",
      description: "test 2",
    },
    {
      attachedDeposit: ONE_NEAR,
      gas: THREE_HUNDRED_TGAS,
    }
  );
}

async function addEventToEventList(
  contract: NearAccount,
  event_id: string,
  event_list_id: string
): Promise<void> {
  return <void>await contract.call(
    contract,
    "add_event_to_event_list",
    {
      event_id,
      event_list_id,
    },
    {
      attachedDeposit: ONE_NEAR,
      gas: THREE_HUNDRED_TGAS,
    }
  );
}

async function getEventList(
  contract: NearAccount,
  event_list_id: string
): Promise<EventList | null> {
  return <EventList | null>(
    await contract.view("get_event_list", { event_list_id: event_list_id })
  );
}

async function createEventAndList(
  contract: NearAccount
): Promise<{ event: Event; event_list: EventList }> {
  const { id: event_list_id } = <EventList>await createEventList(contract);
  const event = <Event>await createEvent(contract);
  await addEventToEventList(contract, event.id, event_list_id);
  const event_list = <EventList>await getEventList(contract, event_list_id);
  return { event, event_list };
}

async function getEvent(
  contract: NearAccount,
  event_id: string
): Promise<Event> {
  return <Event>await contract.view("get_event", { event_id: event_id });
}

async function removeEventFromEventList(
  contract: NearAccount,
  event_id: string,
  event_list_id: string
): Promise<void> {
  return <void>await contract.call(
    contract,
    "remove_event_from_event_list",
    {
      event_id,
      event_list_id,
    },
    {
      attachedDeposit: ONE_NEAR,
      gas: THREE_HUNDRED_TGAS,
    }
  );
}

async function createAccount(
  root: NearAccount,
  name: string
): Promise<NearAccount> {
  return <NearAccount>await root.createSubAccount(name);
}

async function getEventsFromList(
  contract: NearAccount,
  event_list_id: string
): Promise<EventListEventEntryApiResponse[]> {
  return (await (<EventListApiResponse>await contract.view("get_event_list", {
    event_list_id: event_list_id,
    include_events: true,
  }))).events as unknown as EventListEventEntryApiResponse[];
}

test("create a event_list and get it from the contract", async (t) => {
  const { contract } = t.context.accounts;

  const now = new Date().toISOString();

  const { id: event_list_id } = <EventListApiResponse>await contract.call(
    contract,
    "create_event_list",
    {
      name: "test",
      description: "test 2",
    },
    {
      attachedDeposit: ONE_NEAR,
      gas: THREE_HUNDRED_TGAS,
    }
  );

  const event_list = <EventListApiResponse>(
    await contract.view("get_event_list", { event_list_id: event_list_id })
  );

  const comparable = { ...event_list };
  delete (comparable as any).created_at;
  delete (comparable as any).last_updated_at;
  delete (comparable as any).permissions;
  delete (comparable as any).events;

  // this will for now fail
  t.deepEqual(comparable, {
    name: "test",
    description: "test 2",
    id: event_list_id,
    owner_account_id: contract.accountId,
    event_count: 0,
    has_events: false,
  });

  // compare created_at and last_updated_at are in range of +- 10 seconds
  const created_at = new Date(event_list.created_at);
  const last_updated_at = new Date(event_list.last_updated_at);
  const nowTime = new Date(now).getTime();
  t.true(created_at.getTime() - nowTime < 10000);
  t.true(last_updated_at.getTime() - nowTime < 10000);
});

test("create a event_list and add event to it", async (t) => {
  const { contract } = t.context.accounts;

  const now = new Date().toISOString();

  const { event, event_list } = <{ event: Event; event_list: EventList }>(
    await createEventAndList(contract)
  );

  const events = await getEventsFromList(contract, event_list.id);

  const comparable = {
    ...events[0],
  };

  delete (comparable as any).last_updated_at;

  t.deepEqual(comparable, {
    event: event,
    added_by: contract.accountId,
    last_updated_by: contract.accountId,
    position: 0,
  });

  // compare  last_updated_at are in range of +- 10 seconds
  const last_updated_at = new Date(events[0].last_updated_at);
  const nowTime = new Date(now).getTime();
  t.true(last_updated_at.getTime() - nowTime < 10000);
});

test("create a event_list add event and remove event", async (t) => {
  const { contract } = t.context.accounts;

  const { event, event_list } = await createEventAndList(contract);

  await removeEventFromEventList(contract, event.id, event_list.id);

  const events = await getEventsFromList(contract, event_list.id);

  t.deepEqual(events, []);
});

test("can get eventList by any user", async (t) => {
  const { contract: listOwner, root } = t.context.accounts;
  const otherAccount = await createAccount(root, "other");

  const { event, event_list } = await createEventAndList(listOwner);

  const events = await getEventsFromList(listOwner, event_list.id);

  const comparable = {
    ...events[0],
  };

  delete (comparable as any).last_updated_at;

  t.deepEqual(comparable, {
    event: event,
    position: 0,
    added_by: listOwner.accountId,
    last_updated_by: listOwner.accountId,
  });
});

test("cannot add the same event twice", async (t) => {
  const { contract } = t.context.accounts;

  const { event, event_list } = await createEventAndList(contract);

  await t.throwsAsync(
    async () => {
      await addEventToEventList(contract, event.id, event_list.id).catch(
        (e) => {
          if (e.message.includes("is already in the event list with id")) {
            throw new Error("ERR_EVENT_ALREADY_IN_EVENT_LIST");
          }
          throw e;
        }
      );
    },
    {
      message: "ERR_EVENT_ALREADY_IN_EVENT_LIST",
    }
  );
});

test("cannot remove event that is not in the event list", async (t) => {
  const { contract } = t.context.accounts;

  const { event, event_list } = await createEventAndList(contract);

  await t.throwsAsync(
    async () => {
      await removeEventFromEventList(contract, "non_el", event_list.id).catch(
        (e) => {
          if (e.message.includes("The event with id: non_el does not exist!")) {
            throw new Error("ERR_EVENT_NOT_IN_EVENT_LIST");
          }
          throw e;
        }
      );
    },
    {
      message: "ERR_EVENT_NOT_IN_EVENT_LIST",
    }
  );
});

test("cannot add event to non existing event list", async (t) => {
  const { contract } = t.context.accounts;

  const event = await createEvent(contract);

  await t.throwsAsync(
    async () => {
      await addEventToEventList(contract, event.id, "non_evl").catch((e) => {
        if (
          e.message.includes("The event_list with id: non_evl does not exist!")
        ) {
          throw new Error("ERR_EVENT_LIST_NOT_FOUND");
        }
        throw e;
      });
    },
    {
      message: "ERR_EVENT_LIST_NOT_FOUND",
    }
  );
});

test("cannot remove event from non existing event list", async (t) => {
  const { contract } = t.context.accounts;

  const event = await createEvent(contract);

  await t.throwsAsync(
    async () => {
      await removeEventFromEventList(contract, event.id, "non_evl").catch(
        (e) => {
          if (
            e.message.includes("The event_list with id: non_evl does not exist")
          ) {
            throw new Error("ERR_EVENT_LIST_NOT_FOUND");
          }
          throw e;
        }
      );
    },
    {
      message: "ERR_EVENT_LIST_NOT_FOUND",
    }
  );
});

test("cannot get non existing event list", async (t) => {
  const { contract } = t.context.accounts;

  const el = await getEventList(contract, "non_evl");

  t.is(el, null);
});

test("can add events created by any user", async (t) => {
  const { contract: listOwner, root } = t.context.accounts;
  const otherAccount = await createAccount(root, "other");
  const event = await createEvent(listOwner, otherAccount);
  const el = await createEventList(listOwner);

  await addEventToEventList(listOwner, event.id, el.id);

  const events = await getEventsFromList(listOwner, el.id);

  const comparable = {
    ...events[0],
  };

  delete (comparable as any).last_updated_at;

  t.deepEqual(comparable, {
    event: event,
    position: 0,
    added_by: listOwner.accountId,
    last_updated_by: listOwner.accountId,
  });
});

test("can remove events created by any user", async (t) => {
  const { contract: listOwner, root } = t.context.accounts;
  const otherAccount = await createAccount(root, "other");
  const event = await createEvent(listOwner, otherAccount);
  const event_list = await createEventList(listOwner);

  await addEventToEventList(listOwner, event.id, event_list.id);

  await removeEventFromEventList(listOwner, event.id, event_list.id);

  const events = await getEventsFromList(listOwner, event_list.id);

  t.deepEqual(events, []);
});

'''
'''--- integration-tests/src/events.ava.ts ---
import { Event } from "../../contract/src/types";
import { test, ONE_NEAR, THREE_HUNDRED_TGAS } from "./_setup";

test("create a new event and get it from the contract", async (t) => {
  const { contract } = t.context.accounts;

  const now = new Date().toISOString();

  const { id: event_id } = <Event>await contract.call(
    contract,
    "create_event",
    {
      name: "test",
      type: "irl",
      category: "test",
      status: "published",
      description: "test",
      start_date: now,
      end_date: now,
      location: "here",
      images: [],
      links: [],
    },
    {
      attachedDeposit: ONE_NEAR,
      gas: THREE_HUNDRED_TGAS,
    }
  );

  const event = <Event>await contract.view("get_event", { event_id: event_id });

  const comparable = { ...event };
  delete (comparable as any).created_at;
  delete (comparable as any).last_updated_at;

  t.deepEqual(comparable, {
    name: "test",
    type: "irl",
    category: "test",
    status: "published",
    description: "test",
    start_date: now,
    end_date: now,
    owner_account_id: contract.accountId,
    id: event_id,
    location: "here",
    images: [],
    links: [],
  });

  // compare created_at and last_updated_at are in range of +- 10 seconds
  const created_at = new Date(event.created_at);
  const last_updated_at = new Date(event.last_updated_at);
  const nowTime = new Date(now).getTime();

  t.true(created_at.getTime() - nowTime < 10000);
  t.true(last_updated_at.getTime() - nowTime < 10000);
});

test("create a new event and get all the events from the contract", async (t) => {
  const { contract } = t.context.accounts;
  const evt = <Event>await contract.call(
    contract,
    "create_event",
    {
      name: "test",
      type: "irl",
      category: "test",
      status: "published",
      description: "test",
      start_date: "2023-01-11T14:54:06.652Z",
      end_date: "2023-01-12T14:54:06.652Z",
      location: "here",
      images: [],
      links: [],
    },
    {
      attachedDeposit: ONE_NEAR,
      gas: THREE_HUNDRED_TGAS,
    }
  );

  const events = await contract.view("get_all_events", {});

  t.deepEqual(events, [evt]);
});

test("create a new event and delete it", async (t) => {
  const { contract } = t.context.accounts;
  const { id: event_id } = <Event>await contract.call(
    contract,
    "create_event",
    {
      name: "test",
      type: "irl",
      category: "test",
      status: "published",
      description: "test",
      start_date: "2023-01-11T14:54:06.652Z",
      end_date: "2023-01-12T14:54:06.652Z",
      location: "here",
      images: [],
      links: [],
    },
    {
      attachedDeposit: ONE_NEAR,
      gas: THREE_HUNDRED_TGAS,
    }
  );

  await contract.call(contract, "remove_event", { event_id });

  const event = await contract.view("get_event", { event_id });

  t.falsy(event);
});

test("create a new event and update the description", async (t) => {
  const { contract } = t.context.accounts;
  const { id: event_id } = <Event>await contract.call(
    contract,
    "create_event",
    {
      name: "test",
      type: "irl",
      category: "test",
      status: "published",
      description: "test",
      start_date: "2023-01-11T14:54:06.652Z",
      end_date: "2023-01-12T14:54:06.652Z",
      location: "here",
      images: [],
      links: [],
    },
    { attachedDeposit: ONE_NEAR, gas: THREE_HUNDRED_TGAS }
  );

  const updatedEvent = <Event>await contract.call(
    contract,
    "update_event",
    {
      event_id: event_id,
      event: { description: "test2" },
    },
    { attachedDeposit: ONE_NEAR, gas: THREE_HUNDRED_TGAS }
  );

  const updatedEventFromApi = <Event>await contract.view("get_event", {
    event_id: event_id,
  });

  t.deepEqual(updatedEvent, updatedEventFromApi);
});

'''
'''--- near.social/.env ---
PATH_TO_NEAR_CLI=./node_modules/.bin/near
SOCIAL_CONTRACT=social.near
ENV_FILE_PATH=.env
SRC_DIR=widgets
# change this to your account name
ACCOUNT_ON_SOCIAL=events_v2.near
'''
'''--- near.social/.eslintrc.json ---
{
  "extends": [
    "eslint:recommended",
    "plugin:import/errors",
    "plugin:react/recommended",
    "plugin:jsx-a11y/recommended"
  ],
  "plugins": [
    "prettier",
    "react",
    "import",
    "jsx-a11y"
  ],
  "globals": {
    "Social": true,
    "State": true,
    "Near": true,
    "context": true,
    "props": true,
    "state": true,
    "CommitButton": true,
    "IpfsImageUpload": true,
    "Widget": true,
    "Markdown": true,
    "styled": true
  },
  "rules": {
    "react/react-in-jsx-scope": 0,
    "react/prop-types": 0,
    "indent": [
      "error",
      2,
      {
        "SwitchCase": 1
      }
    ],
    "linebreak-style": 1,
    "quotes": [
      "error",
      "single"
    ],
    "accessor-pairs": "error",
    "array-callback-return": "error",
    "block-scoped-var": "error",
    "class-methods-use-this": "error",
    // complexity: ["error", 2],  // can be enabled on new projects. too hard to refactor on older projects
    // complexity: ["warn", 4],
    "consistent-return": "error",
    "curly": "error", // maybe need to disable because of prettier
    "default-case": "error",
    "default-param-last": [
      "error"
    ],
    "dot-notation": "error",
    "eqeqeq": "error",
    "for-direction": "error",
    "getter-return": "error",
    "grouped-accessor-pairs": "error",
    "guard-for-in": "error",
    "init-declarations": [
      "error",
      "always"
    ],
    "max-classes-per-file": [
      "error",
      1
    ],
    "no-alert": "error",
    "no-async-promise-executor": "error", // preference
    "no-await-in-loop": "error",
    "no-caller": "error",
    "no-case-declarations": "error",
    "no-compare-neg-zero": "error",
    "no-cond-assign": "error",
    "no-constant-condition": "error",
    "no-constructor-return": "error",
    "no-control-regex": "error",
    // "no-debugger": "error", // preference
    "no-delete-var": "error",
    "no-div-regex": "error",
    "no-dupe-args": "error",
    "no-dupe-else-if": "error",
    "no-dupe-keys": "error",
    "no-duplicate-case": "error",
    "no-else-return": "error",
    "no-empty": "error",
    "no-empty-character-class": "error",
    "no-empty-function": "error",
    "no-empty-pattern": "error",
    "no-eq-null": "error",
    "no-eval": "error",
    "no-ex-assign": "error",
    "no-extend-native": "error",
    "no-extra-bind": "error",
    "no-extra-boolean-cast": "error",
    "no-extra-label": "error",
    "no-extra-semi": "error", // maybe conflicts with prettier
    "no-fallthrough": "error",
    "no-floating-decimal": "error",
    "no-func-assign": "error",
    "no-global-assign": "error",
    "no-implicit-coercion": "error",
    "no-implicit-globals": "error",
    "no-implied-eval": "error",
    "no-import-assign": "error",
    "no-inner-declarations": "error",
    "no-invalid-regexp": "error",
    "no-invalid-this": "error",
    "no-iterator": "error",
    "no-label-var": "error",
    "no-labels": "error",
    "no-lone-blocks": "error",
    "no-loop-func": "error",
    "no-loss-of-precision": "error",
    "no-magic-numbers": [
      "error",
      {
        "ignore": [
          -1,
          0,
          1,
          2,
          4,
          100,
          1000,
          1024
        ]
      }
    ],
    "no-misleading-character-class": "error",
    "no-new": "error",
    "no-new-func": "error",
    "no-new-wrappers": "error",
    "no-nonoctal-decimal-escape": "error",
    "no-obj-calls": "error",
    "no-octal": "error",
    "no-octal-escape": "error",
    "no-param-reassign": "error",
    "no-promise-executor-return": "error", // enable in new projects
    "no-proto": "error",
    "no-prototype-builtins": "error",
    "no-redeclare": "error",
    "no-regex-spaces": "error",
    "no-return-assign": "error",
    "no-script-url": "error",
    "no-self-assign": "error",
    "no-self-compare": "error",
    "no-sequences": "error",
    "no-setter-return": "error",
    "no-shadow": "error",
    "no-shadow-restricted-names": "error",
    "no-sparse-arrays": "error",
    "no-template-curly-in-string": "error",
    "no-throw-literal": "error",
    "no-undef": "error",
    "no-undef-init": "error",
    "no-undefined": "off",
    "no-unmodified-loop-condition": "error",
    "no-unreachable": "error",
    "no-unreachable-loop": "error",
    "no-unsafe-finally": "error",
    "no-unsafe-negation": "error",
    "no-unsafe-optional-chaining": "error",
    "no-unused-expressions": "error",
    "no-unused-labels": "error",
    "no-unused-vars": "error",
    "no-use-before-define": [
      "error",
      {
        "functions": false,
        "classes": true
      }
    ],
    "no-useless-backreference": "error",
    "no-useless-call": "error",
    "no-useless-catch": "error",
    "no-useless-concat": "error",
    "no-useless-escape": "error",
    "no-useless-return": "error",
    "no-void": "error",
    "no-with": "error",
    "prefer-named-capture-group": "error",
    "prefer-promise-reject-errors": "error",
    "prefer-regex-literals": "error",
    "prettier/prettier": [
      "error"
    ],
    "radix": [
      "error",
      "always"
    ],
    "require-atomic-updates": "error",
    "require-await": "error",
    "require-unicode-regexp": "error",
    "use-isnan": "error",
    "valid-typeof": "error",
    "vars-on-top": "error",
    "wrap-iife": [
      "error",
      "inside"
    ],
    "yoda": "error"
  },
  "parserOptions": {
    "ecmaVersion": 2022,
    "ecmaFeatures": {
      "jsx": true,
      "globalReturn": true
    }
  },
  "env": {
    "es6": true,
    "browser": true,
    "node": true
  },
  "settings": {
    "react": {
      "version": "detect"
    }
  }
}
'''
'''--- near.social/.prettierrc.js ---
'use strict';

// https://prettier.io/docs/en/options.html

module.exports = {
  singleQuote: true,
  tabWidth: 2, // default: 2
  tabs: false, // default: false
  semi: true, // default: true
  trailingComma: 'es5', // default: 'es5'
  bracketSpacing: true, // default: 'true'
  arrowParens: 'always', // default: 'always'
};

'''
'''--- near.social/deploy.js ---
#!/usr/bin/env node

const { deployWidget, SRC_DIR } = require('./shared');
const { join } = require('path');
const { readdirSync } = require('fs');

function deployAll(dir) {
  const files = readdirSync(dir, { withFileTypes: true });

  files.forEach((file) => {
    const path = join(dir, file.name);

    if (file.isDirectory()) {
      return deployAll(path);
    }

    // skip unless isFile
    if (!file.isFile()) {
      return null;
    }

    // skip if not jsx file
    if (!path.endsWith('.jsx')) {
      return [];
    }

    deployWidget(path, false);
    return true;
  });
}

deployAll(join(__dirname, SRC_DIR));

'''
'''--- near.social/dev.js ---
#!/usr/bin/env node

const { deployWidget, SRC_DIR } = require('./shared');

const nodemon = require('nodemon');
const chokidar = require('chokidar');

// setup chokidar and nodemon
const obj = {};
obj.watch = [];
obj.watch.push(SRC_DIR);
obj.exec = 'echo "Watching for changes ..."';
obj.ext = 'jsx';
obj.delay = '20';
obj.verbose = true;

chokidar.watch(obj.watch).on('all', (event, path) => {
  console.log(event, path);
  if (event === 'add' || event === 'change') {
    deployWidget(path);
  }
});

nodemon(obj);

'''
'''--- near.social/package.json ---
{
  "name": "my-near-app",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "dev": "node dev.js",
    "build": "TODO",
    "deploy": "node deploy.js",
    "lint": "eslint \"widgets/**/*.{js|ts|jsx}\"",
    "lint:fix": "eslint \"widgets/**/*.{js|ts|jsx}\" --fix"
  },
  "devDependencies": {
    "eslint": "^8.31.0",
    "eslint-plugin-import": "^2.27.4",
    "eslint-plugin-jsx-a11y": "^6.7.1",
    "eslint-plugin-react": "^7.32.0",
    "near-cli": "^3.4.0",
    "near-sdk-js": "0.6.0",
    "ts-morph": "^16.0.0"
  },
  "dependencies": {
    "chokidar": "^3.5.3",
    "dotenv": "^16.0.3",
    "nodemon": "^2.0.20"
  },
  "browserslist": {}
}

'''
'''--- near.social/shared.js ---
#!/usr/bin/env node
const { parsed } = require('dotenv').config({ path: './.env' });

const PATH_TO_NEAR_CLI = parsed.PATH_TO_NEAR_CLI;
const SOCIAL_CONTRACT = parsed.SOCIAL_CONTRACT;
const ACCOUNT_ON_SOCIAL = parsed.ACCOUNT_ON_SOCIAL;
const ENV_FILE_PATH = parsed.ENV_FILE_PATH;
const SRC_DIR = parsed.SRC_DIR;

/// /////////////////////////// DO NOT EDIT BELOW THIS LINE /////////////////////////////

const EXT_JSX = '.jsx';

const { spawnSync } = require('child_process');
const { readFileSync, existsSync } = require('fs');

// setup chokidar and nodemon
const obj = {};
obj.watch = [];
obj.watch.push(SRC_DIR);
obj.exec = 'echo "Watching for changes ..."';
obj.ext = 'jsx';
obj.delay = '20';
obj.verbose = true;

// skip the first deploy
const didDeploy = {};

// traverse path upwards, up to SRC_DIR, looking for .env file
// returns env object
function fetchEnv(path) {
  let envPath = null;
  const parts = (path.replace(EXT_JSX, '') + '/')
    .replace(`${__dirname}/`, '')
    .replace(`${SRC_DIR}/`, '')
    .split('/');

  // tries to find .env file in parent directories
  // for file `file.jsx` will match: .env and file/.env and file.env
  for (let i = 0; i < parts.length; i += 1) {
    const tryPathDir =
      [SRC_DIR, ...parts.slice(0, i)].join('/') + `/${ENV_FILE_PATH}`;
    if (existsSync(tryPathDir)) {
      envPath = tryPathDir;
    }
    const tryPathFile =
      [SRC_DIR, ...parts.slice(0, i)].join('/') + `${ENV_FILE_PATH}`;
    if (existsSync(tryPathFile)) {
      envPath = tryPathFile;
    }
  }

  // TODO: merge env from local file
  if (!envPath) {
    return {};
  }

  const content = readFileSync(envPath, 'utf8');
  const env = content.split('\n').reduce((acc, line) => {
    const [key, value] = line.split('=');
    acc[key] = value;
    return acc;
  }, {});

  return env;
}

// loads file contents and replaces `{{ env.KEY }}` with env.KEY value
// TODO: minify fileContent before deploying to save gas and storage
function loadFileAsTemplate(env, path) {
  const content = readFileSync(path, 'utf8');
  return Object.entries(env).reduce((acc, [key, value]) => {
    const regexString = `\\{\\{\\s+env\\.${key}\\s+\\}\\}`;
    return acc.replace(new RegExp(regexString, 'gu'), value);
  }, content);
}

// builds contract args for set method of contract
function buildContractArgs(widgetName, fileContent) {
  return {
    data: {
      [ACCOUNT_ON_SOCIAL]: {
        widget: {
          [widgetName]: {
            '': fileContent,
            // TODO: metadata from env?
            // metadata: {
            //   title: 'My widget',
            //   description: 'My widget description',
            // },
          },
        },
      },
    },
  };
}

function buildWidgetName(path) {
  return path
    .replace(`${__dirname}`, '')
    .replace(`${SRC_DIR}/`, '')
    .replace(EXT_JSX, '')
    .replace(/^\//u, '')
    .replace(/\//gu, '__');
}

// deploys widget to social contract
function deployWidget(path, skipFirstDeploy = true) {
  if (skipFirstDeploy && !didDeploy[path]) {
    didDeploy[path] = 1;
    return;
  }

  if (!path.endsWith(EXT_JSX)) {
    return;
  }

  const widgetName = buildWidgetName(path);
  const env = fetchEnv(path);

  const fileContent = loadFileAsTemplate(env, path);
  const contractArgs = buildContractArgs(widgetName, fileContent);

  // TODO: determine if we need to deploy or not by comparing fileContent with current state of contract
  // NOTE: we must also check updated metadata, but maybe can do this in a separate call

  const args = [
    'call',
    SOCIAL_CONTRACT,
    'set',
    '--deposit',
    '0.001',
    '--accountId',
    ACCOUNT_ON_SOCIAL,
    '--args',
    JSON.stringify(contractArgs, null, 4),
  ];

  const timeInMillis = new Date().getTime();
  console.log(`  |> Deploying ${widgetName}...`);

  const deploy = spawnSync(PATH_TO_NEAR_CLI, args, {
    cwd: __dirname,
  });

  if (deploy.status === 0) {
    console.log(
      `  |> Successfully deployed ${widgetName} in ${
        new Date().getTime() - timeInMillis
      }`
    );
    // console.log(deploy.stdout.toString('utf8'));
  } else {
    console.log(`  |> Can not deploy ${widgetName}`);
    throw new Error('Can not deploy');
  }
}

module.exports = {
  PATH_TO_NEAR_CLI,
  SOCIAL_CONTRACT,
  ACCOUNT_ON_SOCIAL,
  ENV_FILE_PATH,
  SRC_DIR,
  EXT_JSX,

  deployWidget,
};

'''
'''--- near.social/widgets/app/.env ---
APP_OWNER=events_v2.near
VERSION=0.3.0
'''
'''--- near.social/widgets/events/.env ---
EVENTS_CONTRACT=events_v2.near
APP_OWNER=events_v2.near
APP_NAME=events
'''
'''--- package.json ---
{
  "name": "events-platform",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "cd near.social && yarn dev",
    "deploy": "yarn deploy:contract",
    "deploy:prod": "yarn deploy:prod && yarn deploy:near.social",
    "deploy:contract": "cd contract && yarn deploy",
    "deploy:near.social": "cd near.social && yarn deploy",
    "build": "yarn build:contract",
    "build:contract": "cd contract && yarn build",
    "test": "yarn test:unit && yarn test:integration",
    "test:unit": "cd contract && yarn test",
    "test:integration": "cd integration-tests && yarn test -- -- \"./contract/build/events.wasm\"",
    "postinstall": "cd integration-tests && yarn install && cd .. && cd contract && yarn install && cd .. && cd near.social && yarn install"
  },
  "devDependencies": {
    "eslint-config-prettier": "^8.6.0",
    "eslint-plugin-prettier": "^4.2.1",
    "near-cli": "^3.3.0",
    "prettier": "^2.8.2"
  },
  "dependencies": {}
}

'''