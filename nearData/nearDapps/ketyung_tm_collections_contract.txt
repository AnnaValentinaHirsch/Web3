*GitHub Repository "ketyung/tm_collections_contract"*

'''--- Cargo.toml ---
[package]
name = "tm_collections_contract"
version = "0.1.0"
edition = "2021"
authors = ["Christopher Chee <ketyung@techchee.com>"]

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.0.0"
uint = { version = "0.9.3", default-features = false }
near-contract-standards = "4.0.0"
tm-collections-models = { version = "0.1.0", path = "../tm_collections_models" }
itertools = "0.8.0"

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []
'''
'''--- LICENSE.md ---
MIT License

Copyright (c) 2022 Christopher Ket Yung Chee

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

'''
'''--- build.sh ---
#!/bin/sh

echo ">> Building contract"

rustup target add wasm32-unknown-unknown
cargo build --all --target wasm32-unknown-unknown --release
'''
'''--- readme.md ---
## Smart contract for ticket collection
The smart contract for storing & handling ticket collection for TicketMaker.
https://ticketmaker.xyz

## License 
MIT License
Copyright (c) 2022 Christopher Ket Yung Chee. See [License](https://github.com/ketyung/tm_collections_contract/blob/master/LICENSE.md) for details

'''
'''--- src/collections_manage.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

    pub (crate) fn panic_if_its_not_allowed_caller(&self) {

        let uw_allowed_callers = self.allowed_callers.clone().unwrap();

        if !uw_allowed_callers.contains(&env::predecessor_account_id()) {
            env::panic_str(format!("@{} Error : Caller {} is NOT allowed",
            env::current_account_id(),
            env::predecessor_account_id()).as_str());
        }
    }
}

#[near_bindgen]
impl Contract {

    pub fn create_collection (&mut self, 
        acc_id : AccountId,     
        title : String, 
        symbol : String,
        icon : Option<String>,
        base_uri : Option<String>,
        description : Option<String>,
        category : Option<String>,
        total_tickets : Option<u64>,
        tickets_sold : Option<u64>,
        ticket_types : Option<Vec<TicketType>>,
        attributes : Option<Vec<Attribute>>,
        template_type : Option<TicketTemplate>,
        contract_id : Option<AccountId>) {

        // use allowed caller check
        self.panic_if_its_not_allowed_caller();

        self.internal_create_collection(
        acc_id, title, symbol, icon, 
        base_uri, description, category, 
        total_tickets,tickets_sold,
        ticket_types, attributes, 
        template_type, contract_id);

        self.date_updated = Some(env::block_timestamp());
    
    }

    

}

#[near_bindgen]
impl Contract {

    pub (crate) fn internal_create_collection (&mut self, 
        acc_id : AccountId,     
        title : String, 
        symbol : String,
        icon : Option<String>,
        base_uri : Option<String>,

        description : Option<String>,
        category : Option<String>,
        total_tickets : Option<u64>,
        tickets_sold : Option<u64>,

        ticket_types : Option<Vec<TicketType>>,
        attributes : Option<Vec<Attribute>>,
        template_type : Option<TicketTemplate>,
        contract_id : Option<AccountId>) {
    
        
        let collection_id = CollectionId {
            owner : acc_id.clone(),
            symbol : symbol.clone(), 
            title : title.clone(),
        };

        if self.collections.get(&collection_id).is_some() {
            env::panic_str(format!("The collection {} for {} already exists",title,acc_id).as_str())
        }

        let collection = Collection {
            title : title,
            description : description,
            category : category, 
            icon : icon, 
            base_uri : base_uri, 
            total_tickets : total_tickets,
            tickets_sold : tickets_sold,
            symbol : symbol,
            owner : acc_id,
            contract_id : contract_id, 
            ticket_types : ticket_types, 
            attributes : attributes,
            ticket_template_type: template_type, 
            date_updated : Some(env::block_timestamp()),
        };

        self.collections.insert(&collection_id, &collection);
    }

       

 
}

#[near_bindgen]
impl Contract {

    pub fn update_collection (&mut self, 
        collection_id : CollectionId,
        update_collection_data :CollectionDataForUpdate) {

        self.panic_if_its_not_allowed_caller();

        let collection = self.collections.get(&collection_id);

        if collection.is_none() {
            env::panic_str(format!("The collection {} for {} does NOT exist",
            collection_id.title,collection_id.owner).as_str())
        }

        let mut uw_collection = collection.unwrap();

        // when the collection is ready for sale
        // only certain information is allowed to be updated
        let is_ready_for_sale = Self::is_collection_ready_for_sale(
            uw_collection.attributes.clone());

        // only update when the specified property is not none 
        if !is_ready_for_sale && update_collection_data.icon.is_some() {
            uw_collection.icon = update_collection_data.icon;
        }

        if update_collection_data.description.is_some() {
            uw_collection.description = update_collection_data.description;
        }

        if !is_ready_for_sale && update_collection_data.ticket_types.is_some() {
            uw_collection.ticket_types = update_collection_data.ticket_types;
        }

        if !is_ready_for_sale && update_collection_data.total_tickets.is_some() {
            uw_collection.total_tickets = update_collection_data.total_tickets;
        }

        if update_collection_data.attributes.is_some() {

            if uw_collection.attributes.is_none() {

                if is_ready_for_sale {

                    if update_collection_data.attributes.is_some() {

                        uw_collection.attributes = 
                        Some(Self::filter_attributes_for_ready_for_sale(
                            update_collection_data.attributes.unwrap()));
                    }
                  
                }
                else {
                    uw_collection.attributes = update_collection_data.attributes;
                }
            }
            else {

                let mut uw_attribs = uw_collection.attributes.clone().unwrap();
                let mut uw_upd_attribs = update_collection_data.attributes.unwrap();

                if is_ready_for_sale {
                    uw_upd_attribs = Self::filter_attributes_for_ready_for_sale(uw_upd_attribs);
                }

                for attrb in uw_upd_attribs {

                    if !uw_attribs.contains(&attrb){
                        uw_attribs.push(attrb);
                    }
                    else {

                        let index = uw_attribs.iter().position(|a| *a == attrb).unwrap();
                        uw_attribs[index] = attrb;
                    }
                }

                uw_collection.attributes = Some(uw_attribs);

            }
        }

        if !is_ready_for_sale && update_collection_data.ticket_template_type.is_some() {
            uw_collection.ticket_template_type = update_collection_data.ticket_template_type;
        }

        if update_collection_data.category.is_some() {
            uw_collection.category = update_collection_data.category;
        }

        uw_collection.date_updated = Some(env::block_timestamp());
        
        self.collections.remove(&collection_id);
        self.collections.insert(&collection_id, &uw_collection);

        self.date_updated = Some(env::block_timestamp());
    
    
    }

    /*
    The function that filters out the attributes that are allowed
    to add or update when the status is ready for sale
    */
    fn filter_attributes_for_ready_for_sale(attributes : Vec<Attribute>) -> Vec<Attribute>{

        attributes.into_iter()
        .filter(|a| a.name == AttributeType::SalesPageTemplate ||
        a.name == AttributeType::Status || a.name == AttributeType::Twitter
        || a.name == AttributeType::BuyerRequiredToSignUp
        || a.name == AttributeType::Facebook || a.name == AttributeType::Facebook)
        .collect::<Vec<Attribute>>()
    
    }

    fn is_collection_ready_for_sale(collection_attributes : Option<Vec<Attribute>>) -> bool {

        let ready_for_sale = Attribute {
            name : AttributeType::Status,
            value : "R".to_string(),
        };

        if collection_attributes.is_some() {

            let uw_attribs = collection_attributes.unwrap();

            let index = uw_attribs.iter().position(|a| *a == ready_for_sale);
            if index.is_some() {
    
                return uw_attribs[index.unwrap()].value == "R".to_string();
            }
    
        }

       
        false 
    }
}

#[near_bindgen]
impl Contract {

    pub (crate) fn pad_left_with_zero(value : &str, width : usize) -> String {

        format!("{:0>1$}", value, width)
    }

    pub fn gen_next_ticket_number (&mut self, collection_id : CollectionId,
    width : Option<usize>) -> Option<String> {

        self.panic_if_its_not_allowed_caller();

        let coll = self.collections.get(&collection_id);

        let mut a_width : usize = 5 ;

        if width.is_some() {
            a_width = width.unwrap();
        }

        let mut next_ticket_no = String::from("01");

        if coll.is_some() {

            let mut uw_collection = coll.unwrap();

            if uw_collection.attributes.is_none() {
            
                let attbs : Vec<Attribute> = vec![Attribute{name : AttributeType::NextTicketNumber,
                value : "1".to_string()}];

                next_ticket_no = Self::pad_left_with_zero ("1", a_width);
            
                uw_collection.attributes = Some(attbs);
            }
            else {

                let mut uw_attribs = uw_collection.attributes.unwrap();

                let starting_no = Self::get_ticket_starting_number(uw_attribs.clone());
                
                let attrb = Attribute{name : AttributeType::NextTicketNumber,
                    value : format!("{}", 1 + starting_no)};

                let index = uw_attribs.iter().position(|a| *a == attrb);
                if index.is_some() {

                    let mut a = uw_attribs[index.unwrap()].clone();
                    let mut current_no : u32 = a.value.parse::<u32>().expect("Failed to parse into interger");
                    
                    
                    if current_no == 0 {
                        current_no += starting_no;
                    }

                    current_no+=1;

                    a.value = format!("{}", current_no);
                  
                    next_ticket_no = Self::pad_left_with_zero(a.value.as_str(), a_width);
            
                    uw_attribs[index.unwrap()] = a;
                }
                else {

                    uw_attribs.push(attrb);
                    next_ticket_no = Self::pad_left_with_zero("1", a_width);
            
                }

                uw_collection.attributes = Some(uw_attribs);
          
            }

            self.collections.remove(&collection_id);
            self.collections.insert(&collection_id, &uw_collection);
    
            self.date_updated = Some(env::block_timestamp());
        

        }

        return Some(next_ticket_no);
    }

    fn get_ticket_starting_number (collection_attributes : Vec<Attribute>) -> u32 {

        let attrb = Attribute{name : AttributeType::TicketStartingNumber,
            value : "0".to_string()};

        let index = collection_attributes.iter().position(|a| *a == attrb);
        if index.is_some() {
            let a = collection_attributes.get(index.unwrap()).unwrap();
            let n = a.value.parse::<u32>().expect("Failed to parse into interger");
            return n;
        }   

        0

    }
 
}
'''
'''--- src/collections_view.rs ---
use crate::*;
use itertools::Itertools;

#[near_bindgen]
impl Contract {

    pub fn get_all_collections(&self,  offset : Option<usize>, limit : Option<usize>) -> Vec<Collection>{

        self.collections.values_as_vector().iter()
        .skip(offset.unwrap_or(0))
        .take(limit.unwrap_or(10))
        .collect::<Vec<Collection>>()

    }

    pub fn get_collections_of (&self, account_id : AccountId,
        offset : Option<usize>, limit : Option<usize>) -> Vec<Collection>{

        self.collections.values_as_vector().iter()
        .filter(|c| c.owner == account_id)
        .sorted_by(|a, b| Ord::cmp(&b.date_updated, &a.date_updated))
        .skip(offset.unwrap_or(0))
        .take(limit.unwrap_or(10))
        .collect::<Vec<Collection>>()
    }

    pub fn get_collections_by (&self, category : String,
        offset : Option<usize>, limit : Option<usize>) -> Vec<Collection>{

        self.collections.values_as_vector().iter()
        .filter(|c| c.category == Some(category.clone()))
        .skip(offset.unwrap_or(0))
        .take(limit.unwrap_or(10))
        .collect::<Vec<Collection>>()
    }

    pub fn get_collection (&self, collection_id : CollectionId) -> Option<Collection> {

        self.collections.get(&collection_id)
    }

    pub fn get_next_ticket_number (&self, collection_id : CollectionId, width : Option<usize>) -> Option<String> {

        let coll = self.collections.get(&collection_id);

        if coll.is_some() {

            let uw_collection = coll.unwrap();
            let attribs = uw_collection.attributes;

            if attribs.is_some() {

                let uw_attribs = attribs.unwrap();
                let attrb = Attribute{name : AttributeType::NextTicketNumber,
                    value : "1".to_string()};

                let index = uw_attribs.iter().position(|a| *a == attrb);
                if index.is_some() {

                    let a = uw_attribs[index.unwrap()].clone();
                   
                    return Some(Self::pad_left_with_zero(a.value.as_str(),width.unwrap_or(5)));
                }

            }

            
        }

        None 
    }

}

'''
'''--- src/ext.rs ---
use crate::*;

pub const TGAS: u64 = 1_000_000_000_000;
pub const NO_DEPOSIT: u128 = 0;
pub const XCC_SUCCESS: u64 = 1;

// Validator interface, for cross-contract calls
#[ext_contract(nft_contract)]
trait NftContract {

    fn nft_mint (token_id: TokenId,receiver_id: AccountId,
    token_metadata: TokenMetadata) -> Token;

    fn nft_tokens_for_owner(account_id: AccountId,
        from_index: Option<near_sdk::json_types::U128>,
        limit: Option<u64>) -> Vec<Token>;

}

#[ext_contract(ticket_mints_contract)]
trait TicketMintsRecord {

    fn insert_ticket_mint(collection_id : CollectionId, token_id : TokenId,
        mint_by : AccountId, price : Option<u128>, ticket_type : Option<String>);

}
'''
'''--- src/lib.rs ---
pub mod collections_manage;
pub mod collections_view;
pub mod ext;
pub mod ticket_mint;
mod tests;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, env,ext_contract, BorshStorageKey, AccountId, Gas, Promise  };
use near_sdk::collections::{UnorderedMap};
use tm_collections_models::models::*;
use near_contract_standards::non_fungible_token::metadata::TokenMetadata;
use near_contract_standards::non_fungible_token::{Token, TokenId};

const NEAR: u128 = 1000_000_000_000_000_000_000_000;

#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    
    CollectionStorageKey,
}

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Contract {
    
    collections : UnorderedMap<CollectionId, Collection>,

    allowed_callers : Option<Vec<AccountId>>,

    ticket_mints_contract_id : Option<AccountId>, 

    date_updated : Option<u64>, 

}

// Define the default, which automatically initializes the contract
impl Default for Contract{

    fn default() -> Self{
        Self{
            collections : UnorderedMap::new(StorageKey::CollectionStorageKey),
            allowed_callers : None, ticket_mints_contract_id : None, 
            date_updated : Some(env::block_timestamp()),
        }
    }
}

#[near_bindgen]
impl Contract {

    #[allow(dead_code)]
    pub (crate) fn test_init() -> Self {
        assert!(!env::state_exists(), "Already initialized");
        
        Self{ collections :  UnorderedMap::new(StorageKey::CollectionStorageKey),  
            allowed_callers : None, ticket_mints_contract_id : None,    
            date_updated : Some(env::block_timestamp())}
    }

}

#[near_bindgen]
impl Contract {

    #[init]
    #[private] // Public - but only callable by env::current_account_id()
    pub fn init(allowed_callers : Vec<AccountId>, ticket_mints_contract_id : AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        
        let s = Self{ collections :  UnorderedMap::new(StorageKey::CollectionStorageKey),  
            allowed_callers : Some(allowed_callers.clone()),    
            ticket_mints_contract_id : Some(ticket_mints_contract_id.clone()), 
            date_updated : Some(env::block_timestamp())};

        env::log_str(format!("Contract {} has been initialized with allowed callers {:?} & {}",
        env::current_account_id(),
        allowed_callers, ticket_mints_contract_id).as_str());

        return s ;
    }
}

'''
'''--- src/tests.rs ---
#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    // use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, AccountId};
    use crate::*;
    
    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    // cargo test test_create_collections -- --show-output
    #[test]
    fn test_create_collections() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());

        let mut _contract = Contract::test_init();

        let acc_id0 = accounts(0);
            
        _contract.internal_create_collection(acc_id0.clone(),
        "Test Collection 01".to_string(), 
        "TC01".to_string(), Some("http://img.io/img/kslsj3".to_string()), None, 
        Some("This is an collection for selling 5000 NFT tickets".to_string()),
        Some("Event Ticket".to_string()),
        None, None, None, Some(vec![Attribute{
            name : AttributeType::StartDate,
            value : "2022-10-20".to_string(),
        }, Attribute{
            name : AttributeType::EndDate,
            value : "2022-10-21".to_string(),
        }]), None, None );

        _contract.internal_create_collection(acc_id0.clone(),
        "Test Collection 02".to_string(), 
        "TC02".to_string(), None, None, 
        Some("This is an collection for selling 250 NFT tickets".to_string()),
        Some("Concert Ticket".to_string()),
        None, None, None, Some(vec![Attribute{name : AttributeType::MaxTicketPerWallet,
            value : "1".to_string()}]), None, None );

        
        let collections = _contract.get_collections_of(acc_id0.clone(), None, None);

        for (pos, e) in collections.iter().enumerate() {
            println!("{} - Collection {:?} : {:?}, icon:{:?} attribs: {:?}", (pos + 1), e.title, 
            e.description.clone().unwrap_or("None".to_string()), 
            e.icon.clone().unwrap_or("No.icon".to_string()),
            e.attributes);
        }

        println!("\n");
    
        let collections = _contract.get_collections_by("Concert Ticket".to_string(), None, None);

        println!("Collection of Concert Ticket:");
        for (pos, e) in collections.iter().enumerate() {
            println!("{} - Collection By Cat {:?} : {:?}, icon:{:?} attribs: {:?}", (pos + 1), e.title, 
            e.description.clone().unwrap_or("None".to_string()), 
            e.icon.clone().unwrap_or("No.icon".to_string()),
            e.attributes);
        }

        let update_collection_id = CollectionId {
            owner : acc_id0.clone(),
            title : "Test Collection 02".to_string(), 
            symbol: "TC02".to_string()

        };

        _contract.update_collection(update_collection_id.clone(),
            CollectionDataForUpdate {

                icon : None, 
                description: Some("The Test Collection 02 which contains 500 NFTs".to_string()),
                base_uri : None,
                total_tickets : Some(500),
                attributes : None,
                ticket_template_type : None,
                category : None,
                ticket_types : Some(vec![TicketType {
                    ticket_type : "Standard".to_string(),
                    price : 23500,
                    color_code : Some("#236".to_string()), 
                },TicketType {
                    ticket_type : "Premium".to_string(),
                    price : 33500,
                    color_code : Some("#950".to_string()), 
                }]),
            }
        );

        let col = _contract.get_collection(update_collection_id).unwrap();

        println!("\nObtained.coll::title:{}, descr: {:?}, ticket_types :{:?}", col.title,
        col.description, col.ticket_types);

        testing_env!(context.is_view(true).build());

    }

    // cargo test test_pad_left_with_zero -- --show-output
    #[test]
    fn test_pad_left_with_zero() {
    
        let p = Contract::pad_left_with_zero("2",6);
        println!("p is {};", p);

        let p = Contract::pad_left_with_zero("223",9);
        println!("p is {};", p);
      
        let p = Contract::pad_left_with_zero("x223",7);
        println!("p is {};", p);
      
        let p = Contract::pad_left_with_zero("2123",17);
        println!("p is {};", p);
      
    }

  
 
}
'''
'''--- src/ticket_mint.rs ---
use crate::*;
use crate::ext::*;
use near_sdk::json_types::Base64VecU8;
use near_sdk::PromiseError;

const MIN_STORAGE_COST_FOR_MINT : u128 = 10000_000_000_000_000_000_000;

//7600_000_000_000_000_000_000;

#[near_bindgen]
impl Contract {

    #[payable]
    pub fn ticket_mint (&mut self, 
    collection_id : CollectionId, 
    token_id : TokenId, ticket_image : String,
    ticket_type : Option<TicketType>,
    extra  : Option<String>,
    ref_hash : Option<String>) {
        
        self.panic_if_its_not_allowed_caller();

        let coll =  self.collections.get(&collection_id.clone());
        if coll.is_none () {
            env::panic_str(format!("Collection {:?} not found",collection_id.clone()).as_str());
        }

        let uw_coll = coll.unwrap();

        if uw_coll.tickets_sold.unwrap_or(0) >= uw_coll.total_tickets.unwrap_or(0) {
            env::panic_str("Tickets are sold out!");
        } 

        let tprice = Self::obtain_ticket_price_in_near(uw_coll.ticket_types.clone(), ticket_type.clone());

        let min_attached_deposit = tprice + MIN_STORAGE_COST_FOR_MINT;

        if env::attached_deposit() < min_attached_deposit  {
            env::panic_str(format!("Attached deposit {} is less than ticket price {}",
            env::attached_deposit(),min_attached_deposit).as_str());
        }

        self.mint_if_not_exceeded_mtpw(uw_coll, token_id, ticket_image,
        ticket_type, extra, ref_hash, tprice, env::signer_account_id());

    }
}

#[near_bindgen]
impl Contract {

    fn get_max_ticket_per_wallet(&self, collection : &Collection) -> Attribute{

        let attributes = collection.attributes.clone();

        let mut max_ticket_pw_attrib = Attribute {
            name : AttributeType::MaxTicketPerWallet, value : format!("{}", 
            collection.total_tickets.unwrap_or(10000))
        };

        if attributes.is_some() {

            let uw_attrbs = attributes.unwrap(); 
            let index =  uw_attrbs.iter().position(|a| *a == max_ticket_pw_attrib);

            if index.is_some() {
                let attrb = uw_attrbs.get(index.unwrap());
                max_ticket_pw_attrib.value = attrb.unwrap().clone().value;
            }
        }
        
        max_ticket_pw_attrib
    }

    fn mint_if_not_exceeded_mtpw(&mut self, 
        collection : Collection, 
        token_id : TokenId, 
        ticket_image : String,
        ticket_type : Option<TicketType>,
        extra  : Option<String>,
        ref_hash : Option<String>,
        ticket_price : u128, 
        mint_by : AccountId) {

      
        let max_ticket_pw_attrib = self.get_max_ticket_per_wallet(&collection);

        nft_contract::ext(collection.contract_id.clone().unwrap())
        .with_static_gas(Gas(5*TGAS))
        .nft_tokens_for_owner(env::signer_account_id(), None, None)
        .then( 
            Self::ext(env::current_account_id())
            .with_static_gas(Gas(5*TGAS))
            .after_obtain_nft_count_callback(
                collection, token_id, ticket_image, ticket_type,
                extra, ref_hash,
                max_ticket_pw_attrib, ticket_price, mint_by)
        );

    }

    #[private] // Public - but only callable by env::current_account_id()
    pub fn after_obtain_nft_count_callback(&mut self, 
        collection : Collection, 
        token_id : TokenId, 
        ticket_image : String,
        ticket_type : Option<TicketType>,
        extra  : Option<String>,
        ref_hash : Option<String>,
        max_ticket_per_wallet : Attribute,
        ticket_price : u128, mint_by : AccountId,
        #[callback_result] call_result: Result<Vec<Token>, PromiseError> ){

        if call_result.is_err() {

            // refund the ticket price to the minter/buyer on error
            Promise::new(mint_by.clone()).transfer(ticket_price).as_return();
            env::log_str(format!("Buyer/minter {} has been refunded with {}",mint_by, ticket_price).as_str());
            env::panic_str(format!("Error at after_obtain_nft_count_callback {:?}", call_result).as_str());
            
        }

        let res : Vec<Token> = call_result.unwrap();

        if res.len() >= max_ticket_per_wallet.value.parse::<usize>().unwrap() {

            env::panic_str("Has exceeed the number of tickets per wallet!");
        } 

        let token_meta = Self::create_token_metadata(
            format!("Ticket {}", token_id),
            collection.title.clone(),Some(ticket_image), 
            ref_hash, 
            extra);

        nft_contract::ext(collection.contract_id.clone().unwrap())
        .with_static_gas(Gas(5*TGAS))
        .with_attached_deposit(MIN_STORAGE_COST_FOR_MINT)
        .nft_mint(token_id.clone(), env::signer_account_id(), token_meta)
        .then( 
            Self::ext(env::current_account_id())
            .with_static_gas(Gas(5*TGAS))
            .after_mint_callback(collection, ticket_price,ticket_type.unwrap().ticket_type, 
            token_id, env::signer_account_id())
        );

    
    }

}

#[near_bindgen]
impl Contract {

    #[private] // Public - but only callable by env::current_account_id()
    pub fn after_mint_callback(&mut self, collection : Collection, 
        ticket_price : u128, ticket_type : String, 
        token_id : TokenId, mint_by : AccountId,
        #[callback_result] call_result: Result<Token, PromiseError> ){

        let mut m_collection = collection;

        if call_result.is_err() {

            // refund the ticket price to the minter/buyer on error
            Promise::new(mint_by.clone()).transfer(ticket_price).as_return();

            env::log_str(format!("Buyer/minter {} has been refunded with {}",mint_by, ticket_price).as_str());

            env::panic_str(format!("Error at after_mint_callback {:?}", call_result).as_str());
        }    

        env::log_str(format!("Minted token is {:?}", call_result).as_str());

        env::log_str(format!("Going to pay owner {} with {}", m_collection.owner.clone(),
        ticket_price).as_str());
        
        Promise::new(m_collection.owner.clone()).transfer(ticket_price).as_return();

        let collection_id = CollectionId {
            owner : m_collection.owner.clone(),
            symbol : m_collection.symbol.clone(),
            title : m_collection.title.clone(),
        };

        // record ticket sales
        if self.ticket_mints_contract_id.is_some() {

            ticket_mints_contract::ext(self.ticket_mints_contract_id.clone().unwrap())
            .with_static_gas(Gas(5*TGAS))
            .insert_ticket_mint(collection_id.clone(), token_id,mint_by,Some(ticket_price),
            Some(ticket_type)).as_return();
        }

        if m_collection.tickets_sold.is_some() {

            m_collection.tickets_sold = Some(m_collection.tickets_sold.unwrap() + 1);
        }
        else {

            m_collection.tickets_sold = Some(1);
        }

        self.collections.remove(&collection_id);

        self.collections.insert(&collection_id, &m_collection);
    
    }

}

#[near_bindgen]
impl Contract {

    fn obtain_ticket_price_in_near(ticket_types : Option<Vec<TicketType>>, ticket_type : Option<TicketType>) -> u128{

        
        if ticket_type.is_some() {

            if ticket_types.is_some() {

                let tt = ticket_type.unwrap();
                if !ticket_types.unwrap().contains(&tt) {
                    env::panic_str(format!("Invalid ticket type {:?}",tt).as_str());
                }

                return  (((tt.price as f64) / 1000.00) * (NEAR as f64)) as u128;

            }
            else {
                env::panic_str("Invalid ticket type!");
            }
        }
        else {

            if ticket_types.is_some() {

                let uw_ticket_types = ticket_types.unwrap();

                let tt = uw_ticket_types.first().unwrap();

                return (((tt.price as f64) / 1000.00) * (NEAR as f64)) as u128;

            }
            else {

                env::panic_str("No tickets type defined!");
            }
        }

    }

    fn create_token_metadata(
        ticket_title : String, collection_title : String, 
        media : Option<String>, 
        ref_hash : Option<String>,
        extra : Option<String>) -> TokenMetadata{

        let mut reference_hash : Option<Base64VecU8> = None;

        if ref_hash.is_some(){

            reference_hash = Some(Base64VecU8::from(
                ref_hash.unwrap().as_bytes().to_vec()));
        }

        TokenMetadata {
            title: Some(ticket_title.clone()),
            description: Some(format!("{} of {}", ticket_title, collection_title)),
            media: media,
            media_hash: None,
            copies: Some(1u64),
            issued_at: Some(format!("{}", env::block_timestamp())) ,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: extra,
            reference: None,
            reference_hash: reference_hash,
        }
    }

}

'''
'''--- term_tests1.txt ---
// To deploy contract
near deploy --accountId test_tm_collections_contract.testnet --wasmFile target/wasm32-unknown-unknown/release/tm_collections_contract.wasm 

// Delete account
near delete test_tm_collections_contract.testnet ketyung.testnet

 // To initialize the contract 
near call test_tm_collections_contract.testnet init '{"allowed_callers":["test_tm_users_contract.testnet"], "ticket_mints_contract_id":"test_tm_ticket_mints_contract.testnet"}' --accountId test_tm_collections_contract.testnet

// To view all collections
near view test_tm_collections_contract.testnet get_all_collections

// To view a collection by the specified owner
near view test_tm_collections_contract.testnet get_collections_of '{"account_id":"ketyung.testnet"}'

// To view a collection 
near view test_tm_collections_contract.testnet get_collection '{"collection_id":{"title":"Test NFT Collection 030", "symbol":"TCN030", "owner":"ketyung.testnet"}}'

// To mint a ticket
near call test_tm_collections_contract.testnet ticket_mint '{"collection_id":{"title":"Test NFT Collection 030", "symbol":"TCN030", "owner":"ketyung.testnet"}, "token_id":"00004", "ticket_image":"https://i.ytimg.com/vi/-PaEGleBEIk/maxresdefault.jpg"}' --deposit 1.358  --gas 300000000000000 --accountId peipei007.testnet

// To remove all attributes of a collection
near call test_tm_collections_contract.testnet remove_collection_attributes '{"collection_id":{"title":"Test NFT Collection 030", "symbol":"TCN030", "owner":"ketyung.testnet"}}'  --accountId test_tm_collections_contract.testnet

// To get next ticket number 
near call test_tm_collections_contract.testnet get_next_ticket_number '{"collection_id":{"title":"Test NFT Collection 030", "symbol":"TCN030", "owner":"ketyung.testnet"}}' --accountId peipei007.testnet

'''