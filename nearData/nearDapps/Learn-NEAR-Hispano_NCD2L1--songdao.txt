*GitHub Repository "Learn-NEAR-Hispano/NCD2L1--songdao"*

'''--- README.md ---
# songdao
Getting Started
To create a new NEAR project with default settings, you just need one command

Using npm's npx:

npx create-near-app [options] new-awesome-project
Or, if you prefer yarn:

yarn create near-app [options] new-awesome-project
Without any options, this will create a project with a vanilla JavaScript frontend and an AssemblyScript smart contract

Other options:

--frontend=react â€“ use React for your frontend template
--contract=rust â€“ use Rust for your smart contract
Develop your own Dapp
Follow the instructions in the README.md in the project you just created! ðŸš€

Getting Help
Check out our documentation or chat with us on Discord. We'd love to hear from you!

Contributing
To make changes to create-near-app itself:

clone the repository (Windows users, use git clone -c core.symlinks=true)
in your terminal, enter one of the folders inside templates, such as templates/vanilla
now you can run yarn to install dependencies and yarn dev to run the local development server, just like you can in a new app created with create-near-app
about commit messages
create-near-app uses semantic versioning and auto-generates nice release notes & a changelog all based off of the commits. We do this by enforcing Conventional Commits. In general the pattern mostly looks like this:

type(scope?): subject  #scope is optional; multiple scopes are supported (current delimiter options: "/", "\" and ",")
Real world examples can look like this:

chore: run tests with GitHub Actions

fix(server): send cors headers

feat(blog): add comment section
If your change should show up in release notes as a feature, use feat:. If it should show up as a fix, use fix:. Otherwise, you probably want refactor: or chore:. More info

Deploy
If you want to deploy a new version, you will need two prerequisites:

Get publish-access to the NPM package
Get write-access to the GitHub repository
Obtain a personal access token (it only needs the "repo" scope).
Make sure the token is available as an environment variable called GITHUB_TOKEN
Then run one script:

yarn release
Or just release-it

'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />

'''
'''--- assembly/__tests__/example.spec.ts ---
import { makePostSong, getPostSongs, vote, makeExtendedPostSong } from '../../assembly';
import { storage, Context, runtime_api, VMContext, logging } from "near-sdk-as";

const someContract = "somecontract.testnet"
const wcom = 'wcom.testnet';
const allcharmian = "allcharmian.testnet"
const chiles = "chiles.testnet"
const elote = "elote.testnet"
const smartio = "smartio.testnet"

describe("PostSong", () => {

    beforeEach(() => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)
    });

    itThrows("disallow make PostSong on behalf", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(someContract)
        makePostSong("test PostSong")
    });

    it("should create PostSong", () => {
        var song = makePostSong("test PostSong");
        expect(song.id).toStrictEqual(0)
        expect(getPostSongs('me').length).toStrictEqual(1);    
        expect(getPostSongs('').length).toStrictEqual(0);
        expect(getPostSongs('me')[0].song.name).toStrictEqual(allcharmian);
        log("PostSong created by: " + getPostSongs('me')[0].song.name);    
    });

    it("should create two PostSongs by the same creator", () => {
        var song1 = makePostSong("test PostSong");
        expect(song1.id).toStrictEqual(0)
        var song2 = makePostSong("test PostSong 2");
        expect(song2.id).toStrictEqual(1)
        expect(getPostSongs('me').length).toStrictEqual(2);    
        expect(getPostSongs('').length).toStrictEqual(0);
        log("total PostSongs created: " + "by " + allcharmian + ": " + getPostSongs('me').length.toString());
        log("total PostSongs created: " + "by others " + ": " + getPostSongs('').length.toString());
    });

    it("should create two PostSongs by different creators", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makePostSong("allcharmian's PostSong");
        expect(song1.song.name).toStrictEqual(allcharmian);
        expect(getPostSongs('me').length).toStrictEqual(1);    
        expect(getPostSongs('').length).toStrictEqual(0);    

        VMContext.setSigner_account_id(chiles)
        VMContext.setPredecessor_account_id(chiles)

        var song2 = makePostSong("chiles's PostSong");
        expect(song2.song.name).toStrictEqual(chiles);
        expect(getPostSongs('me').length).toStrictEqual(1);    
        expect(getPostSongs('').length).toStrictEqual(1);    

        VMContext.setSigner_account_id(elote)
        VMContext.setPredecessor_account_id(elote)

        expect(getPostSongs('me').length).toStrictEqual(0);    
        expect(getPostSongs('').length).toStrictEqual(2);    
    });

    itThrows("should disallow to vote for own public PostSong", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makePostSong("allcharmian's PostSong");
        vote(song1.id, true);
    });

    it("should allow to vote for other's public PostSong", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makePostSong("allcharmian's PostSong");

        VMContext.setSigner_account_id(chiles)
        VMContext.setPredecessor_account_id(chiles)

        song1 = vote(song1.id, true);
        expect(song1.song.vote_like).toStrictEqual(1);
        expect(song1.song.vote_dislike).toStrictEqual(0);

        song1 = vote(song1.id, true);
        expect(song1.song.vote_like).toStrictEqual(1);
        expect(song1.song.vote_dislike).toStrictEqual(0);

        song1 = vote(song1.id, false);
        expect(song1.song.vote_like).toStrictEqual(0);
        expect(song1.song.vote_dislike).toStrictEqual(1);

        VMContext.setSigner_account_id(elote)
        VMContext.setPredecessor_account_id(elote)

        song1 = vote(song1.id, false);
        expect(song1.song.vote_like).toStrictEqual(0);
        expect(song1.song.vote_dislike).toStrictEqual(2);

        song1 = vote(song1.id, false);
        expect(song1.song.vote_like).toStrictEqual(0);
        expect(song1.song.vote_dislike).toStrictEqual(2);
    });

    itThrows("should disallow PostSong creation with invalid viewers", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makeExtendedPostSong("allcharmian's PostSong", ["blablabla"], []);
        vote(song1.id, true);
    });

    itThrows("should disallow PostSong creation with invalid voters", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makeExtendedPostSong("allcharmian's PostSong", [], ["blablabla"]);
        vote(song1.id, true);
    });

    itThrows("should create private PostSong with no voters", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makeExtendedPostSong("allcharmian's PostSong", [chiles], []);
        vote(song1.id, true);
    });

    itThrows("should disallow to vote for own private PostSong if not in voters list", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makeExtendedPostSong("allcharmian's PostSong", [chiles], []);
        vote(song1.id, true);
    });

    it("should allow to vote for own private PostSong if in voters list", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makeExtendedPostSong("allcharmian's PostSong", [chiles, allcharmian], [allcharmian]);
        vote(song1.id, true);
    });

    itThrows("should disallow to vote for other's private PostSong if not in voters list", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makeExtendedPostSong("allcharmian's PostSong", [chiles, allcharmian], [chiles]);

        VMContext.setSigner_account_id(elote)
        VMContext.setPredecessor_account_id(elote)

        vote(song1.id, true);
    });

    it("should allow to vote for other's private PostSong if in voters list", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makeExtendedPostSong("allcharmian's PostSong", [chiles, allcharmian], [chiles]);

        VMContext.setSigner_account_id(chiles)
        VMContext.setPredecessor_account_id(chiles)

        vote(song1.id, true);
    });

    it("should return only private PostSongs where in viewers list", () => {
        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var song1 = makeExtendedPostSong("allcharmian's PostSong", [chiles], [chiles, allcharmian, smartio]);
        expect(song1.song.canView.has(chiles)).toStrictEqual(true);
        expect(song1.song.canView.has(allcharmian)).toStrictEqual(true);
        expect(song1.song.canVote.has(chiles)).toStrictEqual(true);
        expect(song1.song.canVote.has(allcharmian)).toStrictEqual(true);

        VMContext.setSigner_account_id(elote)
        VMContext.setPredecessor_account_id(elote)

        var elotessongs = getPostSongs("others");
        expect(elotessongs.length).toStrictEqual(0)

        VMContext.setSigner_account_id(chiles)
        VMContext.setPredecessor_account_id(chiles)

        var chilesssongs = getPostSongs("others");
        expect(chilesssongs.length).toStrictEqual(1)

        VMContext.setSigner_account_id(allcharmian)
        VMContext.setPredecessor_account_id(allcharmian)

        var allcharmianssongs = getPostSongs("others");
        expect(allcharmianssongs.length).toStrictEqual(1)

        VMContext.setSigner_account_id(smartio)
        VMContext.setPredecessor_account_id(smartio)

        var smartiossongs = getPostSongs("others");
        expect(smartiossongs.length).toStrictEqual(1)
    });

});
'''
'''--- assembly/classes.ts ---
import { Context, PersistentMap, PersistentVector } from "near-sdk-as";

export enum Vote {
    like,
    dislike
}
// clase de foundear cancion
/*
export class found{
  who: string;
  amount: u64;
}
 */

export class PostSong {
    name: string; //name
    vote_like: u64 = 0;
    vote_dislike: u64 = 0;
    time_song: u64 = 0;
    votes: Map<string, Vote> = new Map<string, Vote>();
    canView: Set<string> = new Set<string>();
    canVote: Set<string> = new Set<string>();
  
    constructor(public what: string) {
      this.name = Context.sender;
    }
  }

export class Returnedsong {
    constructor(public id: i32, public song: PostSong) {
    }    
}
export const songs = new PersistentVector<PostSong>("p");

'''
'''--- assembly/index.ts ---
import { Context, env, logging, PersistentMap, PersistentVector, storage } from 'near-sdk-as'
import { PostSong, Returnedsong, Vote, songs } from './classes';

 export function getPostSongs(target: string): Returnedsong[] {
  assert(Context.predecessor == Context.sender)

  const result = new Array<Returnedsong>()
  const forMe = (target == 'me')
  // logging.log('getsongs: sender = ' + Context.sender + ', target = ' + target + ', forMe = ' + forMe.toString())

  for(let i = 0; i < songs.length; ++i) {
    // logging.log('getsongs: song = ' + songs[i].who + ', songs[i].who === Context.sender = ' + (songs[i].who == Context.sender).toString())

    let song = songs[i]
    if(forMe == true) {
      if(song.name == Context.sender)
        result.push(new Returnedsong(i, song))
    } else {
      var isPublicNotMinesong = song.canView.size == 0 && song.name != Context.sender
      var canViewsong = (isPublicNotMinesong ? true : song.canView.has(Context.sender))

      if(canViewsong)
        result.push(new Returnedsong(i, song))
    }
  }
  return result;
 }

export function vote(songId: i32, value: boolean) : Returnedsong {
  assert(Context.predecessor == Context.sender)
  assert(songId >= 0 && songId < songs.length)

  logging.log('vote: sender = ' + Context.sender + ', songId = ' + songId.toString() + ', value = ' + value.toString() + ', total songs = ' + songs.length.toString())
  let song = songs[songId];

  let isPublicsong = song.canVote.size == 0
  let isAllowedToVote = isPublicsong ? (song.name != Context.sender) : song.canVote.has(Context.sender)
  assert(isAllowedToVote)

  let newVote = value == true ? Vote.like : Vote.dislike
  if(song.votes.has(Context.predecessor)) {
    logging.log('vote: re-vote...')

    let voteValue = song.votes.get(Context.predecessor);
    logging.log('voteValue = ' + voteValue.toString())

    if(newVote != voteValue) {
      logging.log('value != voteValue')

      song.votes.set(Context.predecessor, newVote);
      if(voteValue == Vote.like) {
        logging.log('re-vote to dislike')

        song.vote_like -= 1
        song.vote_dislike += 1 
      } else {
        logging.log('re-vote to like')

        song.vote_like += 1
        song.vote_dislike -= 1
      }
    } 
    else 
    {
      logging.log('value = voteValue = ' + value.toString())
    }
  } else {
    logging.log('vote: new vote...')

    song.votes.set(Context.predecessor, newVote);
    if(value == true) {
      logging.log('vote to like')
      song.vote_like += 1
    } else {
      logging.log('vote to dislike')
      song.vote_dislike += 1
    }
  }

  logging.log('vote: replacing songId ' + songId.toString() + ' with song = '
   + song.vote_like.toString() + "/" + song.vote_dislike.toString())

  songs.replace(songId, song);
  return new Returnedsong(songId, songs[songId])
}

export function makeExtendedPostSong(what: string, viewers: string[], voters: string[]) : Returnedsong {
  assert(Context.predecessor == Context.sender)

  var song = new PostSong(what)
  for(let i = 0; i < viewers.length; ++i) {
    let viewer = viewers[i];
    assert(env.isValidAccountID(viewer), "viewer account is invalid")

    logging.log('adding viewer: ' + viewer)
    song.canView.add(viewer)
  }

  for(let i = 0; i < voters.length; ++i) {
    let voter = voters[i];
    assert(env.isValidAccountID(voter), "voter account is invalid")

    logging.log('adding voter: ' + voter)
    song.canVote.add(voter)

    // all voters are viewers too, otherwise how can they vote?
    logging.log('adding voter to viewers: ' + voter)
    song.canView.add(voter)
  }

  songs.push(song);
  return new Returnedsong(songs.length - 1, songs[songs.length - 1])
}

export function makePostSong(what: string) : Returnedsong {
  assert(Context.predecessor == Context.sender)

  songs.push(new PostSong(what));
  return new Returnedsong(songs.length - 1, songs[songs.length - 1])
}

// debug only 
export function clearAll(): void {
  assert(Context.predecessor == Context.sender)

  while(songs.length !== 0)
    songs.pop();
}

'''
'''--- assembly/tsconfig.json ---
{
    "extends": "assemblyscript/std/assembly.json"
}
'''