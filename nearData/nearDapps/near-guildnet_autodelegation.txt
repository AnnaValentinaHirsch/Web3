*GitHub Repository "near-guildnet/autodelegation"*

'''--- Readme.md ---
NODE SCRIPT FOR NEAR DELEGATION

npx node delegate --network <network_id>

example: npx node delegate --network shardnet

network_id: The name of near chain. \n example --network shardnet or testnet

*transactions json and scoreboard csv file save in ../stats
*key file is loaded from ./key if wanna to change, replace credentialsPath with following code.

<!-- const homedir = require("os").homedir();
const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR); -->
'''
'''--- auto-delegate-with-seat/Readme.md ---
NODE SCRIPT FOR NEAR DELEGATION TO POOL ID GET FROM PULL ID

npx node pool_delegate.js --poolId <poolId>

example: npx node pool_delegate.js --poolId 108

poolId: The Id number of pull request changed POOL_ID. \n example --poolId 108

<!-- const homedir = require("os").homedir();
const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR); -->
'''
'''--- auto-delegate-with-seat/key/shardnet/autodelegate.shardnet.near.json ---
{"account_id":"autodelegate.shardnet.near","public_key":"ed25519:2xRCLq2wpTgdoFG6MyUAwBTTk8EbytAJnogqy6Bpt2VN","private_key":"ed25519:2qdvrnHvTeC22U6eTAGAVB7eFVTSBm7cbZfZs3kiLYy6QpN1QMhXNrU9dHHq1r9WaBNTRzsrP6w3pmK367uergXz"}
'''
'''--- auto-delegate-with-seat/log.txt ---

'''
'''--- auto-delegate-with-seat/package.json ---
{
  "name": "price",
  "title": "price_update",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@actions/github": "^5.0.3",
    "@octokit/auth-app": "^4.0.5",
    "@octokit/auth-token": "^3.0.1",
    "@octokit/rest": "^19.0.4",
    "args": "^5.0.3",
    "axios": "^0.27.2",
    "express": "^4.18.1",
    "fast-csv": "^4.3.6",
    "make-runnable": "^1.3.10",
    "near-api-js": "^0.44.2",
    "node-cron": "^3.0.2",
    "node-html-parser": "^5.4.2-0"
  }
}

'''
'''--- auto-delegate-with-seat/pool_delegate.js ---
const nearAPI = require('near-api-js');
const { validators } = require('near-api-js');
const args = require("args");
const axios = require('axios');
const fs = require("fs");
const HTMLParser = require('node-html-parser');
const cron = require('node-cron');
const {Octokit} = require("@octokit/rest");

const credentialsPath = "/home/shardnet/near-delegation/key";

// const credentialsPath = "./key";
const TEST_ACCOUNT = "autodelegate";
const network = "shardnet";
const NEAR_RPC_URL = process.env.NEAR_RPC_URL || `https://rpc.shardnet.near.org`;
const TOKEN = "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";
const TITLE = "Update draft-delegation.md";
const DIR = "/home/shardnet/auto-delegate-with-seat";
// const TITLE = "Add new pool juju_pool";

const get_pull_id = async() => {
  const octokit = new Octokit({
    auth: TOKEN,
    timeZone: 'Europe/Amsterdam',
    baseUrl: 'https://api.github.com',
  })
  
  const response = await octokit.request("GET /repos/{owner}/{repo}/pulls", {
    owner: 'near',
    repo: 'stakewars-iii',
  });
  
  const pulls = response.data;

  for(let i = 0; i < pulls.length; i++) {
    const pull = pulls[pulls.length - i - 1];
    if(pull.title == TITLE)
    {
      const pull_id_lastest = fs.readFileSync(`${DIR}/pull_id.txt`).toString();
      if(parseInt(pull.number) > parseInt(pull_id_lastest))
      {
        console.log(pull.number, pull_id_lastest);
        near_delegation(pull.number);
        fs.writeFileSync(`${DIR}/pull_id.txt`, pull.number.toString());
      }
    }
  }
}

const near_delegation = async(pull_id) => {
    const returns = await axios.get(`https://github.com/near/stakewars-iii/pull/${pull_id}/files`);
    var root = HTMLParser.parse(returns.data);
    var spans = root.getElementsByTagName("span");
    var pool_id = "";
    spans.forEach(span => {
        if(span.rawAttrs == `class='blob-code-inner blob-code-marker js-code-nav-pass ' data-code-marker="+"`)
        {
            if(span.childNodes.length >= 3)
            {
                if(span.childNodes[0].rawText == "POOL_ID: " && span.childNodes[1].childNodes.length >= 1)
                {
                    pool_id += span.childNodes[1].childNodes[0].rawText;
                    pool_id += span.childNodes[2].rawText;
                }
            }
            console.log(pool_id);
        }
    });

    const result = await get_validators();
    if(result)
    {
        let SeatPrice = validators.findSeatPrice(result.current_validators, result.numSeats);
        console.log(parseInt(SeatPrice) / Math.pow(10, 24));
        await delegate(pool_id, (parseInt(SeatPrice) / Math.pow(10, 24)) + 10);
    }
}

const get_validators = async() => {
    const { data } = await axios.post(NEAR_RPC_URL, {
        jsonrpc: "2.0",
        id: "dontcare",
        method: "validators",
        params: [null],
      });
      if (
        !data ||
        (!data.error && (!data.result || !data.result.epoch_start_height))
      ) {
        throw Error(`Unknown API response: ${data}`);
      }

    return data.result;
}

const delegate = async (pool_account, amount) => {
  const logs = fs.readFileSync(`${DIR}/log.txt`); 
    const { connect } = nearAPI;
    const config = {
      networkId: network,
      keyStore: new nearAPI.keyStores.UnencryptedFileSystemKeyStore(credentialsPath),
      nodeUrl: `https://rpc.${network}.near.org`,
      walletUrl: `https://wallet.${network}.near.org`,
      helperUrl: `https://helper.${network}.near.org`,
      explorerUrl: `https://explorer.${network}.near.org`,
    };

    // connect to NEAR
    const near = await connect(config);
    const account = await near.account(`${TEST_ACCOUNT}.${network}.near`);

    try{
        const contract = new nearAPI.Contract(
            account, // the account object that is connecting
            pool_account,
            {
              // name of contract you're connecting to
              changeMethods: ["deposit_and_stake"], // change methods modify state
              sender: account, // account object to initialize and sign transactions.
            }
          );
    
        // console.log(contract);
        const gasBigInt = BigInt(30_000_000_000_000);  // `10n` also works
        const gas = Number(gasBigInt);
     
        const depositAmount = nearAPI.utils.format.parseNearAmount(amount.toString());
        const result = await contract.deposit_and_stake(
            {},
            gas,
            depositAmount
        );
        logs += `deposit to ${pool_account} ${amount} NEAR successfully: ${result}\n\n`
        console.log(`deposit successfully: \n${result}`);
    } catch(error) {
        logs += `deposit to ${pool_account} ${amount} NEAR failed: ${result}\n\n`
        console.log(`deposit failed: ${error}`);
    }

    fs.writeFileSync(`${DIR}/log.txt`, logs);
}

// cron.schedule('0 0 * * *', () => {
//   get_pull_id();
//   console.log('running a task everyday');
// });

get_pull_id();
'''
'''--- auto-delegate-with-seat/pull_id.txt ---
0
'''
'''--- near-delegation/Readme.md ---
NODE SCRIPT FOR NEAR DELEGATION

npx node delegate --network <network_id>

example: npx node delegate --network shardnet

network_id: The name of near chain. \n example --network shardnet or testnet

*transactions json and scoreboard csv file save in ../stats
*key file is loaded from ./key if wanna to change, replace credentialsPath with following code.

<!-- const homedir = require("os").homedir();
const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR); -->
'''
'''--- near-delegation/collect.js ---
const axios = require("axios");
const fs = require("fs");
const process = require("process");
const args = require("args");

const NEAR_RPC_URL = process.env.NEAR_RPC_URL || `https://archival-rpc.shardnet.near.org`;

async function getValidators(url, blockHeight) {
  const { data } = await axios.post(url, {
    jsonrpc: "2.0",
    id: "dontcare",
    method: "validators",
    params: [blockHeight],
  });
  if (
    !data ||
    (!data.error && (!data.result || !data.result.epoch_start_height))
  ) {
    throw Error(`Unknown API response: ${data}`);
  }
  return data;
}

async function getEpochStart(url, blockHeight) {
  try {
    const response = await getValidators(url, blockHeight || null);
    if (response.error) {
      //console.log(response.error);
      throw Error(response.error);
    }
    console.log('response.result', JSON.stringify(response.result));
    const { epoch_start_height: epochStartHeight } = response.result;
    return epochStartHeight;
  } catch (error) {
    console.log("error: ", error);
    throw error;
  }
}

async function fetchValidationStats(url, blockHeight, findEpoch) {
  if (!blockHeight) {
    blockHeight = (await getEpochStart(url)) - 1;
  }
  if (findEpoch && blockHeight) {
    blockHeight = (await getEpochStart(url, blockHeight)) - 1;
  }
  while (true) {
    console.log(
      "Trying to fetch validation stats for the block #",
      blockHeight
    );
    const currentValidators = await getValidators(url, blockHeight);
    if (currentValidators.result) {
      return {
        blockHeight,
        validators: currentValidators.result.current_validators,
      };
    }
    --blockHeight;
  }
}

function writeFile({ blockHeight, validators }) {
  const jsonData = JSON.stringify(validators, null, 2);
  try {
    fs.mkdirSync("stats");
  } catch {}
  fs.writeFileSync(`stats/${blockHeight}.json`, jsonData);
  console.log("Saved validation stats as of block #", blockHeight);
}

async function fetchValidationStats(url, blockHeight, findEpoch) {
    if (!blockHeight) {
      blockHeight = (await getEpochStart(url)) - 1;
    }
    if (findEpoch && blockHeight) {
      blockHeight = (await getEpochStart(url, blockHeight)) - 1;
    }
    while (true) {
      console.log(
        "Trying to fetch validation stats for the block #",
        blockHeight
      );
      const currentValidators = await getValidators(url, blockHeight);
      if (currentValidators.result) {
        return {
          blockHeight,
          validators: currentValidators.result.current_validators,
        };
      }
      --blockHeight;
    }
  }

  async function getEpochStart(url, blockHeight) {
    try {
      const response = await getValidators(url, blockHeight || null);
      if (response.error) {
        //console.log(response.error);
        throw Error(response.error);
      }
      console.log('response.result', JSON.stringify(response.result));
      const { epoch_start_height: epochStartHeight } = response.result;
      return epochStartHeight;
    } catch (error) {
      console.log("error: ", error);
      throw error;
    }
  }
  
const fetchHistoricalValidationStats = async (url, blockHeight) => 
{
  while (true) {
    const validationStats = await fetchValidationStats(url, blockHeight);
    writeFile(validationStats);
    blockHeight = (await getEpochStart(url, validationStats.blockHeight)) - 1;
  }
}

// args
//   .option('block_height', 'The block height to retrieve historical data, you can also use "b". \n example: --block_height 24042142')
//   .option('find_epoch', 'Used in conjunction with block_height, will look for epoch data, you can also use "f". \n example: --find_epoch')

// const flags = args.parse(process.argv)

// if (flags.blockHeight) {
//   console.log(`Starting historical on block # ${flags.blockHeight}`);
// }

// fetchValidationStats(NEAR_RPC_URL, flags.blockHeight, flags.findEpoch).then(writeFile);
// fetchHistoricalValidationStats(NEAR_RPC_URL);

// const delayInterval = setInterval(sendData, 2000);

// module.exports = fetchHistoricalValidationStats;
'''
'''--- near-delegation/delegate.js ---
const nearAPI = require('near-api-js')
const path = require('path')
const fs = require("fs");
const fastCsv = require("fast-csv");
const args = require("args");
const axios = require('axios');
const saveValidatorsScoreCSV = require("./scoreboard");

// const homedir = require("os").homedir();
// const CREDENTIALS_DIR = ".near-credentials";
// const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const credentialsPath = "/home/shardnet/near-delegation/key";

const statsFolder = "/home/shardnet/stats";
const TEST_ACCOUNT = "autodelegate";
var DEPOSIT_AMOUNT = "0.1";

const UPTIME_LIMIT = 60;
const COL_CHUNK = 3;

var CURRENT_STAKE_AMOUNT_LIMIT = 0;
var current_validators = [];

const near_delegation = async(network, amount, limit) => {
    console.log("Start save validation stats");
    if(!network) network = "shardnet";
    if(amount) DEPOSIT_AMOUNT = parseInt(amount);
    if(limit) CURRENT_STAKE_AMOUNT_LIMIT = parseInt(limit);

    await saveValidatorsScoreCSV(statsFolder).then((result) => {
        read_csv(network, amount);
    });
}

const read_csv = async (network) => {
    var data = [];
    var pool_accounts = [];

    var row_index = 0;
    const options = {
        objectMode: true,
        delimiter: ",",
        quote: null,
        renameHeaders: false,
    };
    const date = new Date();
    const readableStream = fs.createReadStream(statsFolder + `/validators_scoreboard_${date.getFullYear()}-${date.getUTCMonth() + 1}-${date.getUTCDate()}.csv`);
    
    fastCsv
    .parseStream(readableStream, options)
    .on("error", (error) => {
        console.log(error);
    })
    .on("data", (row) => {
        if(row_index > 0) data.push(row);
        row_index++;
    })
    .on("end", async() => {
        data.forEach(element => {
            if(element[COL_CHUNK] > UPTIME_LIMIT){
                pool_accounts.push(element[0].toString().replace('"', '').replace('"', ''));
            }
        });

        console.log(pool_accounts);
        await delegate(pool_accounts, DEPOSIT_AMOUNT, network);
    });
}

const delegate = async (pool_accounts, amount, network) => {
    var logs = 'Deposit failed for :\n';
    current_validators = await get_validators(network);
    console.log(current_validators);
    const date = new Date();
    // console.log("credentialsPath", credentialsPath);
    const { connect } = nearAPI;
    const config = {
      networkId: network,
      keyStore: new nearAPI.keyStores.UnencryptedFileSystemKeyStore(credentialsPath),
      nodeUrl: `https://rpc.${network}.near.org`,
      walletUrl: `https://wallet.${network}.near.org`,
      helperUrl: `https://helper.${network}.near.org`,
      explorerUrl: `https://explorer.${network}.near.org`,
    };

    // connect to NEAR
    const near = await connect(config);
    const account = await near.account(`${TEST_ACCOUNT}.${network}.near`);

    for(let i = 0; i< pool_accounts.length; i++)
    {
        var current_stake = 0;
        for(let l = 0; l < current_validators.length; l++)
        {
            if(current_validators[l].account_id == pool_accounts[i])
            {
                current_stake = current_validators[l].stake
            }
        }
        
        console.log(`${pool_accounts[i]} current stake amount ${current_stake}`);

        if(CURRENT_STAKE_AMOUNT_LIMIT == 0 || 
            CURRENT_STAKE_AMOUNT_LIMIT > 0 && current_stake < CURRENT_STAKE_AMOUNT_LIMIT * Math.pow(10, 24))
        {
            try{
                const contract = new nearAPI.Contract(
                    account, // the account object that is connecting
                    pool_accounts[i],
                    {
                      // name of contract you're connecting to
                      changeMethods: ["deposit_and_stake"], // change methods modify state
                      sender: account, // account object to initialize and sign transactions.
                    }
                  );
            
                // console.log(contract);
                const gasBigInt = BigInt(30_000_000_000_000);  // `10n` also works
                const gas = Number(gasBigInt);
             
                const depositAmount = nearAPI.utils.format.parseNearAmount(amount.toString());
                const result = await contract.deposit_and_stake(
                    {},
                    gas,
                    depositAmount
                );
                console.log(`deposit successfully to ${pool_accounts[i]}: \n${result}`);
            } catch(error) {
                console.log(`deposit failed to ${pool_accounts[i]}.`);
                logs += pool_accounts[i] + '\n';
            }
        }
    }

    fs.writeFileSync(
        path.join("/home/shardnet/near-delegation/log", `logs_${date.getFullYear()}-${date.getUTCMonth() + 1}-${date.getUTCDate()}.csv`),
        logs
      );
}

const get_validators = async(network) => {
    const { data } = await axios.post(`https://rpc.${network}.near.org`, {
        jsonrpc: "2.0",
        id: "dontcare",
        method: "validators",
        params: [null],
      });
      if (
        !data ||
        (!data.error && (!data.result || !data.result.epoch_start_height))
      ) {
        throw Error(`Unknown API response: ${data}`);
      }

    return data.result.current_validators;
}

args
  .option('network', 'Used in check rpc, example shardnet or testnet, you can also use "f". \n example: --network')
  .option('amount', 'Delegation amount. \n example: --amount')
  .option('limit', 'Limit current stake amount. \n example: --limit')

const flags = args.parse(process.argv)

near_delegation(flags.network, flags.amount, flags.limit);
'''
'''--- near-delegation/key/shardnet/autodelegate.shardnet.near.json ---
{"account_id":"autodelegate.shardnet.near","public_key":"ed25519:2xRCLq2wpTgdoFG6MyUAwBTTk8EbytAJnogqy6Bpt2VN","private_key":"ed25519:2qdvrnHvTeC22U6eTAGAVB7eFVTSBm7cbZfZs3kiLYy6QpN1QMhXNrU9dHHq1r9WaBNTRzsrP6w3pmK367uergXz"}
'''
'''--- near-delegation/package.json ---
{
  "name": "price",
  "title": "price_update",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "author": "",
  "license": "ISC",
  "dependencies": {
    "args": "^5.0.3",
    "axios": "^0.27.2",
    "express": "^4.18.1",
    "fast-csv": "^4.3.6",
    "make-runnable": "^1.3.10",
    "near-api-js": "^0.44.2"
  }
}

'''
'''--- near-delegation/scoreboard.js ---
const fs = require("fs");
const path = require("path");

const filterNodes = [
  "boot1.near",
  "boot2.near",
  "boot3.near",
  "boot4.near",
];

const LAST_EPOCHS = 80;

async function getAllNodes(statsFolder) {
  const dir = await fs.promises.opendir(statsFolder);
  const validatorsIds = new Set();

  for await (const statsFile of dir) {
    if (!statsFile.isFile() || !statsFile.name.match(/^\d+\.json/)) {
      continue;
    }

    // Get all validators from files
    const epochValidatorsStats = JSON
      .parse(fs.readFileSync(path.join(statsFolder, statsFile.name)))
      .filter(epochValidatorStats => !filterNodes.includes(epochValidatorStats.account_id));

    for (const epochValidatorStats of epochValidatorsStats) {
      validatorsIds.add(epochValidatorStats.account_id)
    }
  }

  return Array.from(validatorsIds).sort();
}

async function getValidatorsCreationDate(statsFolder) {
  const dir = await fs.promises.opendir(statsFolder);

  const creationDates = new Map();

  for await (const statsFile of dir) {
    if (!statsFile.isFile() || !statsFile.name.match(/^\d+\.json/)) {
      continue;
    }

    // Calculate validators in epoch (epoch block stats)
    const epochValidatorsStats = JSON
      .parse(fs.readFileSync(path.join(statsFolder, statsFile.name)))
      .filter(epochValidatorStats => !filterNodes.includes(epochValidatorStats.account_id));

    const fileStat = fs.statSync(path.join(statsFolder, statsFile.name));
    const fileModificationDate = fileStat.mtimeMs;
    // const fileModificationDate = new Date(fileStat.mtimeMs);

    for (const epochValidatorStats of epochValidatorsStats) {
      const accountId = epochValidatorStats.account_id;

      if (!creationDates.has(accountId) || fileModificationDate < creationDates.get(accountId)) {
        creationDates.set(accountId, fileModificationDate);
      }
    }
  }
  
  return creationDates;
  // return Array.from(creationDates).sort();
}

async function aggregateValidatorsScoreboard(statsFolder, nodesWhitelist, nodesCreation) {
  var count = 0;
  const dir = await fs.promises.opendir(statsFolder);

  const validatorsStatsOrder = new Map();
  for await (const statsFile of dir)
  {
    if (!statsFile.isFile() || !statsFile.name.match(/^\d+\.json/)) {
      continue;
    }

    // Calculate validators in epoch (epoch block stats)
    const epochValidatorsStats = JSON
    .parse(fs.readFileSync(path.join(statsFolder, statsFile.name)))
    .filter(epochValidatorStats => !filterNodes.includes(epochValidatorStats.account_id));
  
    const fileStat = fs.statSync(path.join(statsFolder, statsFile.name));
    const fileModificationTs = fileStat.mtimeMs;

    validatorsStatsOrder.set(fileModificationTs, statsFile.name);
  }

  var sort = Array.from(validatorsStatsOrder).sort();
  const validatorsStats = new Map();
  for(var index = 0; index < sort.length; index++)
  {
    var statfileName = sort[sort.length - index - 1][1];
        if(count >= LAST_EPOCHS) break;

    // Calculate validators in epoch (epoch block stats)
    const epochValidatorsStats = JSON
      .parse(fs.readFileSync(path.join(statsFolder, statfileName)))
      .filter(epochValidatorStats => !filterNodes.includes(epochValidatorStats.account_id));

    const fileStat = fs.statSync(path.join(statsFolder, statfileName));
    const fileModificationTs = fileStat.mtimeMs;

    console.log(`Reading ${count + 1}th file, fileModificationTs: ${fileModificationTs}`)

    for (const epochValidatorStats of epochValidatorsStats) {
      const validatorStats = validatorsStats.get(epochValidatorStats.account_id);
      const num_produced_blocks =
        epochValidatorStats.num_produced_blocks + ((validatorStats || {}).num_produced_blocks || 0);
      const num_expected_blocks =
        epochValidatorStats.num_expected_blocks + ((validatorStats || {}).num_expected_blocks || 0);
      const num_produced_chunks =
        epochValidatorStats.num_produced_chunks + ((validatorStats || {}).num_produced_chunks || 0);
      const num_expected_chunks =
        epochValidatorStats.num_expected_chunks + ((validatorStats || {}).num_expected_chunks || 0);
      const num_missed_epochs = ((validatorStats || {}).num_missed_epochs || 0);
      const num_validated_epochs = (epochValidatorStats.num_produced_chunks > 0) ? 1 + ((validatorStats || {}).num_validated_epochs || 0) : ((validatorStats || {}).num_validated_epochs || 0);
      const num_total_epochs = 1 + ((validatorStats || {}).num_validated_epochs || 0);

      let percentEpochMissed = ((validatorStats || {}).num_missed_epochs >= (validatorStats || {}).num_total_epochs) ? 0 : ((validatorStats || {}).num_validated_epochs === (validatorStats || {}).num_total_epochs) ? 1 : ( (validatorStats || {}).num_missed_epochs / (validatorStats || {}).num_total_epochs)

      const percent_chunks_produced = (((validatorStats || {}).num_produced_chunks / (validatorStats || {}).num_expected_chunks) * percentEpochMissed * 100).toFixed(2)

      validatorsStats.set(
        epochValidatorStats.account_id,
          { num_produced_blocks, num_expected_blocks, num_produced_chunks, num_expected_chunks, percent_chunks_produced, num_missed_epochs, num_validated_epochs, num_total_epochs }
      );
    }

    // Calculate validators not in epoch (missed epoch)
    const validatorsInEpoch = epochValidatorsStats.map(validator => validator.account_id);
    const validatorsNotInEpoch = nodesWhitelist.filter(accountId => !validatorsInEpoch.includes(accountId));
    const validatorsInEpoch2 = nodesWhitelist.filter(accountId => validatorsInEpoch.includes(accountId));

    for (const validatorNotInEpochId of validatorsNotInEpoch) {
      const validatorStats = validatorsStats.get(validatorNotInEpochId);

      let numMissedEpochs = (validatorStats || {}).num_missed_epochs || 0

      if (fileModificationTs >= nodesCreation.get(validatorNotInEpochId)) {
        numMissedEpochs++;
      }

      validatorsStats.set(validatorNotInEpochId, {
        num_produced_blocks: ((validatorStats || {}).num_produced_blocks || 0),
        num_expected_blocks: ((validatorStats || {}).num_expected_blocks || 0),
        num_produced_chunks: ((validatorStats || {}).num_produced_chunks || 0),
        num_expected_chunks: ((validatorStats || {}).num_expected_chunks || 0),
        num_missed_epochs: numMissedEpochs,
        num_validated_epochs: ((validatorStats || {}).num_validated_epochs || 0),
        num_total_epochs: ((validatorStats || {}).num_validated_epochs + numMissedEpochs || 0)
      });
    }

    count++;
  }

  const validatorsScoreboard = [...validatorsStats.entries()];
  validatorsScoreboard.sort(([_1, validatorStats1], [_2, validatorStats2]) =>
    validatorStats2.percent_chunks_produced - validatorStats1.percent_chunks_produced
  );

  const date = new Date();

  fs.writeFileSync(
    path.join(statsFolder, `validators_scoreboard_${date.getFullYear()}-${date.getUTCMonth() + 1}-${date.getUTCDate()}.json`),
    JSON.stringify(
      validatorsScoreboard.map(
        ([account_id, { num_produced_blocks, num_expected_blocks, num_produced_chunks, num_expected_chunks, percent_chunks_produced, num_missed_epochs, num_validated_epochs }]) => (
          { account_id, num_expected_blocks, num_produced_blocks, num_produced_chunks, num_expected_chunks, percent_chunks_produced, num_missed_epochs, num_validated_epochs }
        )
      ),
      null,
      2
    )
  );

  let validatorsScoreboardCsv =
    "ACCOUNT,CHUNKS PRODUCED,CHUNKS EXPECTED,%CHUNKS ONLINE,BLOCKS PRODUCED,BLOCKS EXPECTED,%BLOCKS ONLINE,MISSED EPOCHS,VALIDATED EPOCHS,TOTAL EPOCHS\n";

  for (const [account_id, validatorStats] of validatorsScoreboard) {

    const totalEpochs = (validatorStats.num_total_epochs < (validatorStats.num_validated_epochs  + validatorStats.num_missed_epochs)) ? validatorStats.num_validated_epochs  + validatorStats.num_missed_epochs : validatorStats.num_total_epochs
    let percentEpochMissed = (validatorStats.num_missed_epochs >= totalEpochs) ? 0 : (validatorStats.num_validated_epochs === totalEpochs) ? 1 : (validatorStats.num_validated_epochs / totalEpochs)
    const percentChunksOnline = ( (validatorStats.num_produced_chunks / validatorStats.num_expected_chunks) * percentEpochMissed * 100).toFixed(2)

    validatorsStats.set(account_id, {
      num_produced_blocks: ((validatorStats || {}).num_produced_blocks || 0),
      num_expected_blocks: ((validatorStats || {}).num_expected_blocks || 0),
      percent_chunks_online: (percentChunksOnline === 'NaN') ? 0 : parseFloat(percentChunksOnline),
      num_produced_chunks: ((validatorStats || {}).num_produced_chunks || 0),
      num_expected_chunks: ((validatorStats || {}).num_expected_chunks || 0),
      num_missed_epochs: ((validatorStats || {}).num_missed_epochs || 0),
      num_validated_epochs: ((validatorStats || {}).num_validated_epochs || 0),
      num_total_epochs: totalEpochs
    });
  }

  const validatorsScoreboard1 = [...validatorsStats.entries()];
  validatorsScoreboard1.sort(([_1, validatorStats1], [_2, validatorStats2]) =>
    validatorStats2.percent_chunks_online - validatorStats1.percent_chunks_online
  );

  for (const [account_id, validatorStats] of validatorsScoreboard1) {
    let totalEpochs = validatorStats.num_total_epochs
    let percentEpochMissed = (validatorStats.num_missed_epochs >= totalEpochs) ? 0 : (validatorStats.num_validated_epochs === totalEpochs) ? 1 : (validatorStats.num_validated_epochs / totalEpochs)

    validatorsScoreboardCsv += `"${account_id}",${validatorStats.num_produced_chunks},${validatorStats.num_expected_chunks},${validatorStats.percent_chunks_online},${validatorStats.num_produced_blocks},${validatorStats.num_expected_blocks},${( (validatorStats.num_produced_blocks / validatorStats.num_expected_blocks) * percentEpochMissed * 100).toFixed(2)},${validatorStats.num_missed_epochs},${validatorStats.num_validated_epochs},${totalEpochs}\n`;
  }

  fs.writeFileSync(
    path.join(statsFolder, `validators_scoreboard_${date.getFullYear()}-${date.getUTCMonth() + 1}-${date.getUTCDate()}.csv`),
    validatorsScoreboardCsv
  );
}

async function saveValidatorsScoreCSV(statsFolder) {
    // Main script
    console.log('Starting');
    console.log('Fetching validators list...');

    await getAllNodes(statsFolder)
    .then(async(nodes) => {
        console.log('Aggregating validators data...');
        await getValidatorsCreationDate(statsFolder)
        .then(async(nodesCreation) => {
            await aggregateValidatorsScoreboard(statsFolder, nodes, nodesCreation).catch(console.error);
            console.log('End');
        })
        .catch(console.error);
    })
    .catch(error => {
        console.log('Failed!!!');
        console.error(error);
    })

    return true;
}

module.exports = saveValidatorsScoreCSV;
'''
'''--- near-delegation/unstake.js ---
const nearAPI = require('near-api-js')
const path = require('path')
const fs = require("fs");
const fastCsv = require("fast-csv");
const args = require("args");

// const homedir = require("os").homedir();
// const CREDENTIALS_DIR = ".near-credentials";
// const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const credentialsPath = "/home/shardnet/near-delegation/key";

const statsFolder = "/home/shardnet/stats";
const TEST_ACCOUNT = "autodelegate";
var DEPOSIT_AMOUNT = "0.1";

const UPTIME_LIMIT = 60;
const COL_CHUNK = 3;

const near_unstake = async (network, amount) => {
    if(!network) network = "shardnet";
    if(amount) DEPOSIT_AMOUNT = parseInt(amount);

    var data = [];
    var pool_accounts = [];

    var row_index = 0;
    const options = {
        objectMode: true,
        delimiter: ",",
        quote: null,
        renameHeaders: false,
    };
    const date = new Date();
    // const readableStream = fs.createReadStream(statsFolder + `/validators_scoreboard_${date.getFullYear()}-${date.getUTCMonth() + 1}-${date.getUTCDate()}.csv`);
    const readableStream = fs.createReadStream(`./unstake_list.csv`);
    
    fastCsv
    .parseStream(readableStream, options)
    .on("error", (error) => {
        console.log(error);
    })
    .on("data", (row) => {
        if(row_index > 0) data.push(row);
        row_index++;
    })
    .on("end", async() => {
        data.forEach(element => {
            pool_accounts.push(element[0].toString().replace('"', '').replace('"', ''));
        });

        console.log(pool_accounts);
        await unstake(pool_accounts, DEPOSIT_AMOUNT, network);
    });
}

const unstake = async (pool_accounts, amount, network) => {
    const { connect } = nearAPI;
    const date = new Date();
    var logs = "";
    const config = {
      networkId: network,
      keyStore: new nearAPI.keyStores.UnencryptedFileSystemKeyStore(credentialsPath),
      nodeUrl: `https://rpc.${network}.near.org`,
      walletUrl: `https://wallet.${network}.near.org`,
      helperUrl: `https://helper.${network}.near.org`,
      explorerUrl: `https://explorer.${network}.near.org`,
    };

    // connect to NEAR
    const near = await connect(config);
    const account = await near.account(`${TEST_ACCOUNT}.${network}.near`);

    for(let i = 0; i< pool_accounts.length; i++)
    {
        try{
            const contract = new nearAPI.Contract(
                account, // the account object that is connecting
                pool_accounts[i],
                {
                  // name of contract you're connecting to
                  changeMethods: ["unstake"], // change methods modify state
                  sender: account, // account object to initialize and sign transactions.
                }
              );
        
            // console.log(contract);
            const gasBigInt = BigInt(30_000_000_000_000);  // `10n` also works
            const gas = Number(gasBigInt);
         
            const depositAmount = nearAPI.utils.format.parseNearAmount(amount.toString());
            const result = await contract.unstake(
                {
                    "amount": depositAmount
                },
                gas,
            );
            console.log(`unstake successfully: \n${result}`);
            logs += `unstake successfully for ${pool_accounts[i]}\n`;
        } catch(error) {
            console.log(`unstake failed.`);
            logs += `unstake failed for ${pool_accounts[i]}: \n${error}`; + '\n';
        }

        fs.writeFileSync(
            path.join("/home/shardnet/near-delegation/log", `unstake_logs_${date.getFullYear()}-${date.getUTCMonth() + 1}-${date.getUTCDate()}.csv`),
            logs
          );
    }
}

args
  .option('network', 'Used in check rpc, example shardnet or testnet, you can also use "f". \n example: --network')
  .option('amount', 'Delegation amount. \n example: --amount')

const flags = args.parse(process.argv)

near_unstake(flags.network, flags.amount);
'''