*GitHub Repository "hack-a-chain-software/near-tipping-bot"*

'''--- .eslintrc.js ---
module.exports = {
  env: {
    browser: true,
    es2021: true,
  },
  globals: {
    process: true,
  },
  extends: [
    "eslint:recommended",
    "plugin:react/recommended",
    "plugin:@typescript-eslint/recommended",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    ecmaFeatures: {
      jsx: true,
    },
    ecmaVersion: "latest",
    sourceType: "module",
  },
  plugins: ["react", "@typescript-eslint"],
  rules: {
    "react/prop-types": "off",
    "react/react-in-jsx-scope": "off",
    "no-extra-boolean-cast": "off",
    "react/no-children-prop": "off",
    "@typescript-eslint/ban-ts-comment": "off",
    "@typescript-eslint/no-non-null-assertion": "off",
  },
};

'''
'''--- .github/ISSUE_TEMPLATE/bug-report.yml ---
name: Bug Report
description: File a bug report
title: "[Bug]: "
labels: ["bug"]
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out this bug report!
  - type: textarea
    id: what-happened
    attributes:
      label: What happened?
      description: Also tell us, what did you expect to happen?
      placeholder: Tell us what you see!
      value: "A bug happened!"
    validations:
      required: true
  - type: textarea
    id: repo-steps
    attributes:
      label: How to reproduce the bug?
      description: Please explain how to reproduce the bug
      placeholder: Tell us how to repo the bug!
      value: |
        1. Go to '...'
        2. Click on '...'
        3. Scroll down to '...'
        4. See error
    validations:
      required: true
  - type: "checkboxes"
    id: browsers
    attributes:
      label: What browsers are you seeing the problem on?
      options:
        - label: Firefox
        - label: Chrome
        - label: Safari
        - label: Microsoft Edge
  - type: checkboxes
    id: devices
    attributes:
      label: What device type(s) did you see the problem on?
      options:
        - label: "Desktop"
        - label: "Mobile"
        - label: "Tablet"
  - type: checkboxes
    id: operating-system
    attributes:
      label: "What operating system(s) did you see the problem on?"
      options:
        - label: "macOS"
        - label: "Windows"
        - label: "Linux"
  - type: textarea
    id: additional
    attributes:
      label: Additional information
      description: Use this section to provide any additional information you may have like screenshots, logs, notes, video links, etc...

'''
'''--- .github/ISSUE_TEMPLATE/feature-creation.yml ---
name: "Feature request"
description: "File a Feature request"
title: "[Feature]: "
labels: ["enhancement"]
body:
  - type: markdown
    attributes:
      value: |
        Thanks for taking the time to fill out a feature request!
  - type: textarea
    id: context
    attributes:
      label: Context / Background / How This Idea Came To Fruition
      description: Please provide some context around your idea
    validations:
      required: true
  - type: textarea
    id: problem
    attributes:
      label: Problem / Opportunity
      description: What are we trying to solve/improve with this feature?
    validations:
      required: true
  - type: textarea
    id: solution
    attributes:
      label: Proposed Solution / How It Can Be Improved
      description: What will your feature / enhancement look like?  (i.e frontend changes should have accompanying screenshots around the solution)
    validations:
      required: true
  - type: textarea
    id: testing
    attributes:
      label: Testing the changes
      description: Please provide a high level description of how you'll verify your changes work and won't break existing functionality?
    validations:
      required: true
  - type: textarea
    id: additional
    attributes:
      label: Additional Information
      description: Please provide any additional information around your request here

'''
'''--- .github/PULL_REQUEST_TEMPLATE.md ---
### What does it do?

### Any helpful background information?

### Any new dependencies? Why were they added?

### Relevant screenshots/gifs

### Does it close any issues?

Closes #...
'''
'''--- .github/workflows/CI.yml ---
name: CI

on: pull_request

concurrency:
  group: ci-${{ github.ref }}
  cancel-in-progress: true

jobs:
  cypress-install:
    runs-on: ubuntu-latest
    container:
      image: cypress/browsers:node18.12.0-chrome103-ff107
      options: --user 1001 # READ: https://github.com/cypress-io/github-action/issues/446
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18.12.1
          cache: 'yarn'

      - name: Output Yarn cache directory
        id: yarn-cache-dir
        run: echo "dir=$(yarn cache dir)" >> $GITHUB_OUTPUT

      - name: Cache Yarn install
        uses: actions/cache@v3
        with:
          path: ${{ steps.yarn-cache-dir.outputs.dir }}
          key: ${{ runner.os }}-yarn-${{ hashFiles('**/yarn.lock') }}
          restore-keys: |
            ${{ runner.os }}-yarn-

      - name: Cypress install
        uses: cypress-io/github-action@v4
        with:
          browser: chrome
          runTests: false
          install-command: yarn
          build: yarn front build

      - name: Save build folder
        uses: actions/upload-artifact@v3
        with:
          name: build
          path: ./packages/front/dist
          if-no-files-found: error

'''
'''--- .github/workflows/vercel_deploy.yml ---
name: Vercel Deploy
env:
  VERCEL_ORG_ID: ${{ secrets.VERCEL_ORG_ID }}
  VERCEL_PROJECT_ID: ${{ secrets.VERCEL_PROJECT_ID }}
  VITE_CONTRACT: ${{ secrets.BOT_CONTRACT }}
  VITE_NEAR_NETWORK: ${{ secrets.NEAR_NETWORK }}
on:
  push:
    branches:
      - main

jobs:
  full_deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: 18.12.1
          cache: 'yarn'

      - name: Install Vercel CLI
        run: npm install --global vercel@canary

      - name: Install Yarn Globally
        run: npm install -g yarn

      - name: Installing Dependencies
        run: yarn

      - name: Pull vercel setup
        run: vercel pull --yes --token=${{ secrets.VERCEL_TOKEN }}

      - name: Build Project Artifacts
        run: vercel build --prod --token=${{ secrets.VERCEL_TOKEN }}

      - name: Deploy Project Artifacts to Vercel
        run: >
          vercel
          deploy
          --prebuilt
          --prod
          --token=${{ secrets.VERCEL_TOKEN }}

'''
'''--- .husky/commit-msg.sh ---
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

yarn commitlint --edit $1 && yarn lint-staged
'''
'''--- LICENSE.md ---
MIT License

Copyright (c) 2018 LFSCamargo

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

'''
'''--- commitlint.config.js ---
module.exports = { extends: ["@commitlint/config-conventional"] };

'''
'''--- cypress.config.ts ---
import { defineConfig } from "cypress";

export default defineConfig({
  e2e: {
    setupNodeEvents(on, config) {
      // implement node event listeners here
    },
    video: false,
    baseUrl: "http://localhost:3000/",
  },
});

'''
'''--- cypress/e2e/base.cy.ts ---
describe("home", () => {
  beforeEach(function () {
    cy.visit("/");
  });

  it("passes", () => {
    cy.get("body", { log: true });
  });
});

'''
'''--- cypress/fixtures/example.json ---
{
  "name": "Using fixtures to represent data",
  "email": "hello@cypress.io",
  "body": "Fixtures are a great way to mock data for responses to routes"
}

'''
'''--- cypress/support/commands.ts ---
/// <reference types="cypress" />
// ***********************************************
// This example commands.ts shows you how to
// create various custom commands and overwrite
// existing commands.
//
// For more comprehensive examples of custom
// commands please read more here:
// https://on.cypress.io/custom-commands
// ***********************************************
//
//
// -- This is a parent command --
// Cypress.Commands.add('login', (email, password) => { ... })
//
//
// -- This is a child command --
// Cypress.Commands.add('drag', { prevSubject: 'element'}, (subject, options) => { ... })
//
//
// -- This is a dual command --
// Cypress.Commands.add('dismiss', { prevSubject: 'optional'}, (subject, options) => { ... })
//
//
// -- This will overwrite an existing command --
// Cypress.Commands.overwrite('visit', (originalFn, url, options) => { ... })
//
// declare global {
//   namespace Cypress {
//     interface Chainable {
//       login(email: string, password: string): Chainable<void>
//       drag(subject: string, options?: Partial<TypeOptions>): Chainable<Element>
//       dismiss(subject: string, options?: Partial<TypeOptions>): Chainable<Element>
//       visit(originalFn: CommandOriginalFn, url: string, options: Partial<VisitOptions>): Chainable<Element>
//     }
//   }
// }

'''
'''--- cypress/support/e2e.ts ---
// ***********************************************************
// This example support/e2e.ts is processed and
// loaded automatically before your test files.
//
// This is a great place to put global configuration and
// behavior that modifies Cypress.
//
// You can change the location of this file or turn off
// automatically serving support files with the
// 'supportFile' configuration option.
//
// You can read more here:
// https://on.cypress.io/configuration
// ***********************************************************

// Import commands.js using ES2015 syntax:
import "./commands";

// Alternatively you can use CommonJS syntax:
// require('./commands')

'''
'''--- docker-compose.yml ---
services:
  db:
    image: postgres:14.5-bullseye
    user: postgres
    ports:
      - "5432:5432"
    environment:
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - NTB_PASSWORD=${NTB_PASSWORD}
    volumes:
      - pg_data:/var/lib/postgresql/data
      - ./packages/db/src/init.sh:/docker-entrypoint-initdb.d/init.sh
    networks:
      - ntb

volumes:
  pg_data:

networks:
  ntb: {}

'''
'''--- format_rust.sh ---
if ! command -v cargo &> /dev/null
then
    echo "The required package cargo could not be found aborting. Please install rust"
    exit

else
  cd packages/contracts && cargo fmt --all && cd ..
fi
'''
'''--- package.json ---
{
  "name": "near.monorepo",
  "version": "1.0.0",
  "description": "Near Contract and React Monorepo",
  "private": true,
  "scripts": {
    "postinstall": "yarn husky install",
    "front": "yarn workspace @near/front",
    "bot": "yarn workspace @near/bot",
    "db": "yarn workspace @near/db",
    "contracts": "yarn workspace @near/contracts"
  },
  "engines": {
    "yarn": ">=1.22.0 <2.0.0",
    "node": ">=17.5.0"
  },
  "lint-staged": {
    "*.{ts,tsx}": [
      "yarn prettier --config .prettierrc --write"
    ],
    "*.{js,jsx}": [
      "yarn prettier --config .prettierrc --write"
    ],
    "*.rs": [
      "sh ./format_rust.sh"
    ]
  },
  "husky": {
    "hooks": {
      "pre-commit": "yarn lint-staged"
    }
  },
  "workspaces": {
    "packages": [
      "packages/*"
    ],
    "nohoist": [
      "**/tailwindcss",
      "**/tailwindcss/**",
      "**/postcss",
      "**/postcss/**",
      "**/autoprefixer",
      "**/autoprefixer/**"
    ]
  },
  "license": "MIT",
  "devDependencies": {
    "@commitlint/cli": "^16.0.1",
    "@commitlint/config-conventional": "^16.0.0",
    "@types/jest": "^27.5.0",
    "@typescript-eslint/eslint-plugin": "^5.22.0",
    "@typescript-eslint/parser": "^5.22.0",
    "cypress": "^10.6.0",
    "eslint": "^8.15.0",
    "eslint-plugin-react": "^7.29.4",
    "husky": "^8.0.1",
    "lint-staged": "^12.4.1",
    "nodemon": "^2.0.15",
    "prettier": "^2.6.2"
  },
  "dependencies": {
    "react-router-hash-link": "^2.4.3"
  }
}

'''
'''--- packages/bot/deploy-commands.js ---
require("dotenv").config();

const fs = require("node:fs");
const { REST, Routes } = require("discord.js");

const commands = [];

const commandFiles = fs
  .readdirSync("./src/commands")
  .filter((file) => file.endsWith(".js"));

for (const file of commandFiles) {
  const command = require(`./src/commands/${file}`);
  commands.push(command.data.toJSON());
}

const rest = new REST({ version: "9" }).setToken(process.env.BOT_TOKEN);

// rest.get(Routes.applicationGuildCommands(clientId, guildId))
//     .then(data => {
//         const promises = [];
//         for (const command of data) {
//             const deleteUrl = `${Routes.applicationGuildCommands(clientId, guildId)}/${command.id}`;
//             promises.push(rest.delete(deleteUrl));
//         }
//         return Promise.all(promises);
//     });

// console.log('delete commands');

// rest.get(Routes.applicationCommands(clientId))
//     .then(data => {
//         const promises = [];
//         for (const command of data) {
//             const deleteUrl = `${Routes.applicationCommands(clientId)}/${command.id}`;
//             promises.push(rest.delete(deleteUrl));
//         }
//         return Promise.all(promises);
//     });

// console.log('delete commands');

(async () => {
  try {
    console.log("Started refreshing application (/) commands.");

    await rest.put(
      //To deploy global commands, adjust the route in the script to .applicationCommands(clientId).

      Routes.applicationCommands(process.env.CLIENT_ID),
      //Routes.applicationGuildCommands(clientId, guildId),
      { body: commands }
    );

    console.log("Successfully reloaded application (/) commands.");
  } catch (error) {
    console.error(error);
  }
})();

'''
'''--- packages/bot/index.js ---
require("dotenv").config();

const http = require("http");
const { Client, GatewayIntentBits, Collection } = require("discord.js");
const { postgraphile } = require("postgraphile");
const { PgMutationUpsertPlugin } = require("postgraphile-upsert-plugin");

const { initializeHandlers } = require("./src/handlers");

// Receives a production configuration and a fallback, and returns the adequate on based on NODE_ENV
function envConfig(prod, dev) {
  return process.env.NODE_ENV == "production" ? prod : dev;
}

function setupGraphqlServer() {
  const postgraphileHandler = postgraphile(process.env.DATABASE_URL, "public", {
    watchPg: true,
    graphiql: true,
    enhanceGraphiql: true,
    dynamicJson: true,
    simpleCollections: "omit",
    appendPlugins: [PgMutationUpsertPlugin],
    handleErrors: (errors) => console.error(errors),
  });

  return http
    .createServer(postgraphileHandler)
    .listen(process.env.GRAPHQL_PORT);
}

async function setupDiscordClient() {
  const client = new Client({
    intents: [GatewayIntentBits.Guilds, GatewayIntentBits.GuildMembers],
  });

  client.commands = new Collection();
  client.aliases = new Collection();

  await initializeHandlers(client);

  await client.login(process.env.BOT_TOKEN);
}

async function main() {
  setupGraphqlServer();

  await setupDiscordClient();
}

main();

'''
'''--- packages/bot/package.json ---
{
  "name": "@near/bot",
  "version": "1.0.0",
  "main": "index.js",
  "license": "MIT",
  "scripts": {
    "dev": "node index.js",
    "start": "node index.js"
  },
  "dependencies": {
    "@apollo/client": "^3.7.1",
    "@graphile-contrib/pg-simplify-inflector": "^6.1.0",
    "big.js": "^6.2.1",
    "discord.js": "^14.6.0",
    "dotenv": "^16.0.3",
    "graphql": "^15.8.0",
    "lodash": "^4.17.21",
    "near-api-js": "^1.1.0",
    "node-fetch": "2",
    "postgraphile": "^4.12.12",
    "postgraphile-upsert-plugin": "^3.2.0"
  }
}

'''
'''--- packages/bot/src/commands/commands.js ---
const { SlashCommandBuilder, EmbedBuilder } = require("discord.js");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("commands")
    .setDescription("Bot commands"),

  async execute(interaction) {
    let commands = interaction.client.commands;
    const embed = new EmbedBuilder()
      .setTitle("Bot commands")
      .setColor("Random");

    commands.forEach((command) => {
      embed.addFields({
        name: `Command: /${command.data.name}`,
        value: `Description: ${command.data.description}`,
      });
    });

    interaction.reply({ embeds: [embed], ephemeral: true });
  },
};

'''
'''--- packages/bot/src/commands/feedback.js ---
const { SlashCommandBuilder, EmbedBuilder } = require("discord.js");
const sendFeedback = require("../graphql/mutations/sendFeedback");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("feedback")
    .setDescription("Send a feedback")
    .addStringOption((option) =>
      option
        .setName("feedback")
        .setDescription("Send a feedback")
        .setRequired(true)
    ),

  async execute(interaction) {
    const { user } = interaction;

    const serverId = interaction.member.guild.id;

    const feedback = interaction.options.getString("feedback");

    const message = new EmbedBuilder()
      .setTitle("Feedback")
      .setDescription(feedback)
      .setFooter({
        text: user.tag,
        iconURL: user.displayAvatarURL({ format: "png" }),
      })
      .setColor("Random");

    await sendFeedback(user.id, serverId, user.username, feedback);

    await interaction.client.guilds.cache
      .get(process.env.SERVER_ID)
      .channels.cache.get(process.env.FEEDBACK_CHANNEL_ID)
      .send({ embeds: [message] });

    await interaction.reply({
      content: "Your feedback has been sent",
      ephemeral: true,
    });
  },
};

'''
'''--- packages/bot/src/commands/help.js ---
const { SlashCommandBuilder } = require("discord.js");
const findCommandHelp = require("../graphql/queries/findCommandHelp");
const listHelps = require("../graphql/queries/listHelps");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("help")
    .setDescription("Choose a command to see its tutorial")
    .addStringOption((option) =>
      option
        .setName("command")
        .setDescription("Choose the command you would like to see the tutorial")
        .setRequired(true)
        .setAutocomplete(true)
    ),

  async autocomplete(interaction) {
    const focusedValue = interaction.options.getFocused();

    const helpCommands = await listHelps();

    const filtered = helpCommands.filter(({ command }) =>
      command.toLowerCase().includes(focusedValue.toLowerCase())
    );

    await interaction.respond(
      filtered.map(({ command }) => ({
        name: command,
        value: command,
      }))
    );
  },

  async execute(interaction) {
    const commandName = interaction.options.getString("command");

    const command = await findCommandHelp(commandName);

    if (!command) {
      await interaction.reply({
        content:
          "That command is unavalible. Please, pick one of the help listed on this server",
        ephemeral: true,
      });
      return;
    }

    await interaction.reply({ content: command.message, ephemeral: true });
  },
};

'''
'''--- packages/bot/src/commands/helpInstall.js ---
const isEmpty = require("lodash/isEmpty");
const {
  SlashCommandBuilder,
  EmbedBuilder,
  PermissionFlagsBits,
} = require("discord.js");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("helpinstall")
    .setDescription("How to configure the bot.")
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

  async execute(interaction) {
    const embed = new EmbedBuilder().setTitle("Welcome").setColor("Random")
      .setDescription(`
        Thank you for installing me, the best tipping bot on NEAR!

        For everything to work properly, please, follow these steps:
        1) First, use the /register command to register the bot on this server.
        2) Second, use the /addtoken command to choose which tokens to make available on your server.

        Done! Now the I'm installed at your server! Every time you wish to add a new token, just use the /addtoken command again!

        For more information about the commands, please, use /help!
      `);

    await interaction.reply({ embeds: [embed], ephemeral: true });
  },
};

'''
'''--- packages/bot/src/commands/insertServerToken.js ---
const { SlashCommandBuilder, PermissionFlagsBits } = require("discord.js");
const listTokens = require("../graphql/queries/listTokens");
const insertServerToken = require("../graphql/mutations/insertServerToken");
const findDuplicatePkError = require("../utils/findDuplicatePkError");
const findServerNotRegistered = require("../utils/findServerNotRegisteredError");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("addtoken")
    .setDescription(
      "Add a token into the server to make it available for transfers"
    )
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)
    .addStringOption((options) =>
      options
        .setName("token")
        .setDescription("Choice one token")
        .setAutocomplete(true)
        .setRequired(true)
    ),

  async autocomplete(interaction) {
    const focusedValue = interaction.options.getFocused();

    const tokens = await listTokens();

    const filtered = tokens.filter(({ metadata }) => {
      const { name = "", symbol = "" } = metadata || {};

      const focusedLowerCase = focusedValue.toLowerCase();

      return (
        name.toLowerCase().includes(focusedLowerCase) ||
        symbol.toLowerCase().includes(focusedLowerCase)
      );
    });

    await interaction.respond(
      filtered.map((token) => ({ name: token.metadata.name, value: token.id }))
    );
  },

  async execute(interaction) {
    const { user: username } = interaction;
    const tokenId = interaction.options.getString("token");

    const serverId = interaction.member.guild.id;

    try {
      await insertServerToken(serverId, tokenId);

      await interaction.reply({
        content: `Hey ${username}, the token has been added to your server`,
        ephemeral: true,
      });
    } catch ({ graphQLErrors }) {
      if (findDuplicatePkError(graphQLErrors)) {
        await interaction.reply({
          content: "This token has already been added to the server",
          ephemeral: true,
        });
        return;
      }
      if (findServerNotRegistered(graphQLErrors)) {
        await interaction.reply({
          content:
            "This server has not yet been registered or this token not registered on server. Use the /register command to register your server or choice a token registered!",
          ephemeral: true,
        });
        return;
      }
      await interaction.reply({
        content: `Internal error, if you think this is a bug, please contact developers: ${graphQLErrors}`,
        ephemeral: true,
      });
    }
  },
};

'''
'''--- packages/bot/src/commands/lastServerTips.js ---
const { SlashCommandBuilder, EmbedBuilder } = require("discord.js");
const { formatDecimals } = require("../utils/formatDecimals");
const { viewFunction } = require("../utils/viewFunction");
const listServerTokens = require("../graphql/queries/listServerTokens");
const isEmpty = require("lodash/isEmpty");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("lastservertips")
    .setDescription("Check out the latest transactions made on the server"),

  async execute(interaction) {
    const serverId = interaction.member.guild.id;

    const lastServerTips = await viewFunction("view_last_server_tips", {
      server: serverId,
    });

    const tokens = await listServerTokens(serverId);

    await interaction.member.guild.members.fetch();

    if (isEmpty(lastServerTips)) {
      await interaction.reply({
        context: "No transactions so far",
        ephemeral: true,
      });

      return;
    }
    const embed = new EmbedBuilder()
      .setTitle("Last server tips")
      .setColor("Random");

    lastServerTips.forEach(async ({ sender, receiver, coin, amount }) => {
      const userSender = interaction.member.guild.members.cache.find(
        (member) => member.user.id === sender
      );
      const userReceiver = interaction.member.guild.members.cache.find(
        (member) => member.user.id === receiver
      );

      const token = tokens.find(({ id }) => {
        if (coin === "$NEAR") {
          return id === "near";
        }
        return id === coin;
      });

      if (!token) {
        await interaction.reply({
          content: "Choose a token that is on the token list",
          ephemeral: true,
        });

        return;
      }

      if (!userSender || !userReceiver) {
        embed.addFields({
          name: userSender
            ? `Sender: ${userSender.user.tag}\nCoin: ${
                token.metadata.name
              }\nAmount: ${formatDecimals(amount, token.metadata.decimals)}\n${
                userReceiver
                  ? `Receiver: ${userReceiver.user.username}`
                  : "Receiver: User deleted or is not part of this server"
              }`
            : "Sender: User deleted or is not part of this server",
          value: "-------------------------------------------------------",
        });
        return;
      }

      embed.addFields({
        name: `Sender: ${
          userSender.user.username
        }\nCoin: ${coin}\nAmount: ${formatDecimals(
          amount,
          token.metadata.decimals
        )}\nReceiver: ${userReceiver.user.username}`,
        value: "-------------------------------------------------------",
      });
    });

    await interaction.reply({ embeds: [embed], ephemeral: true });
  },
};

'''
'''--- packages/bot/src/commands/listServerTokens.js ---
const isEmpty = require("lodash/isEmpty");
const { SlashCommandBuilder, EmbedBuilder } = require("discord.js");
const listServerTokens = require("../graphql/queries/listServerTokens");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("alltokens")
    .setDescription("List all server tokens"),

  async execute(interaction) {
    const { id } = interaction.member.guild;

    const tokens = await listServerTokens(id);

    const embed = new EmbedBuilder()
      .setTitle("All Server Tokens")
      .setColor("Random");

    tokens.forEach((token) =>
      embed.addFields({ name: token.metadata.name, value: token.id })
    );

    if (isEmpty(tokens)) {
      embed.setDescription(
        "Your server has no tokens. Please use /addtoken to add new token"
      );
    }

    await interaction.reply({ embeds: [embed], ephemeral: true });
  },
};

'''
'''--- packages/bot/src/commands/newToken.js ---
const {
  SlashCommandBuilder,
  ModalBuilder,
  TextInputBuilder,
  ActionRowBuilder,
  TextInputStyle,
} = require("discord.js");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("newtoken")
    .setDescription("Request to add a new token to the list"),

  async execute(interaction) {
    const modal = new ModalBuilder()
      .setCustomId("requestTokenModal")
      .setTitle("Request a new token");

    const tokenInput = new TextInputBuilder()
      .setCustomId("tokenName")
      .setLabel("Which token do you want ?")
      .setPlaceholder("Ethereum")
      .setRequired(true)
      .setMinLength(2)
      .setStyle(TextInputStyle.Short);

    const addressInput = new TextInputBuilder()
      .setCustomId("address")
      .setLabel("Which address near ?")
      .setPlaceholder("Near address")
      .setRequired(true)
      .setMinLength(2)
      .setStyle(TextInputStyle.Short);

    const firstActionRow = new ActionRowBuilder().addComponents(tokenInput);
    const secondActionRow = new ActionRowBuilder().addComponents(addressInput);

    modal.addComponents(firstActionRow, secondActionRow);

    await interaction.showModal(modal);
  },
};

'''
'''--- packages/bot/src/commands/ranking.js ---
const { SlashCommandBuilder, EmbedBuilder } = require("discord.js");
const { viewFunction } = require("../utils/viewFunction");
const { formatDecimals } = require("../utils/formatDecimals");
const listServerTokens = require("../graphql/queries/listServerTokens");
const isEmpty = require("lodash/isEmpty");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("ranking")
    .setDescription("Check out the donation leaderbord in the server by token")
    .addStringOption((option) =>
      option
        .setName("token")
        .setDescription("Choose the token you want to see the ranking")
        .setRequired(true)
        .setAutocomplete(true)
    ),

  async autocomplete(interaction) {
    const serverId = interaction.member.guild.id;

    const tokens = await listServerTokens(serverId);

    const focusedValue = interaction.options.getFocused();

    const filtered = tokens.filter((choice) => {
      const { name = "", symbol = "" } = choice?.metadata || {};

      const focusedLowerCase = focusedValue.toLowerCase();

      return (
        name.toLowerCase().includes(focusedLowerCase) ||
        symbol.toLowerCase().includes(focusedLowerCase)
      );
    });

    await interaction.respond(
      filtered.map((token) => ({ name: token.metadata.name, value: token.id }))
    );
  },

  async execute(interaction) {
    const serverId = interaction.member.guild.id;
    const coin = interaction.options.getString("token");
    const tokens = await listServerTokens(serverId);

    await interaction.member.guild.members.fetch();

    const ranking = await viewFunction("view_ranking", {
      server: serverId,
      coin: coin === "near" ? "$NEAR" : coin,
    });

    const token = tokens.find(({ id }) => {
      if (coin === "$NEAR") {
        return id === "near";
      }
      return id === coin;
    });

    if (!token) {
      await interaction.reply({
        content: "Choose a token that is on the token list",
        ephemeral: true,
      });

      return;
    }

    if (isEmpty(ranking)) {
      await interaction.reply({
        content: "No transactions so far",
        ephemeral: true,
      });

      return;
    }

    const embed = new EmbedBuilder()
      .setTitle(`Ranking of ${token.metadata.name}`)
      .setColor("Random");

    ranking.forEach(({ user, amount }) => {
      const account = interaction.member.guild.members.cache.find(
        (member) => member.user.id === user
      );

      embed.addFields({
        name: account
          ? `User: ${account.user.tag}\nAmount: ${formatDecimals(
              amount,
              token.metadata.decimals
            )}`
          : `User: User deleted or is not part of this server\nAmount: ${formatDecimals(
              amount,
              token.metadata.decimals
            )}`,
        value: "--------------------------------------",
      });
    });

    await interaction.reply({ embeds: [embed] });
  },
};

'''
'''--- packages/bot/src/commands/register.js ---
const { SlashCommandBuilder, PermissionFlagsBits } = require("discord.js");
const insertServer = require("../graphql/mutations/insertServer");
const findDuplicatePkError = require("../utils/findDuplicatePkError");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("register")
    .setDescription("Register your server to use commands")
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator),

  async execute(interaction) {
    const { id, name } = interaction.member.guild;
    const { user: username } = interaction;

    try {
      await insertServer(id, name);

      await interaction.reply({
        content: `Hey ${username}, your server was registered`,
        ephemeral: true,
      });
    } catch ({ graphQLErrors }) {
      if (findDuplicatePkError(graphQLErrors)) {
        await interaction.reply({
          content: "This server was registered already",
          ephemeral: true,
        });

        return;
      }

      await interaction.reply({
        content: `Internal error, if you think this is a bug, please contact developers: ${graphQLErrors}`,
        ephemeral: true,
      });
    }
  },
};

'''
'''--- packages/bot/src/commands/removeToken.js ---
const { SlashCommandBuilder, PermissionFlagsBits } = require("discord.js");
const listServerTokens = require("../graphql/queries/listServerTokens");
const deleteServerToken = require("../graphql/mutations/deleteServerToken");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("removetoken")
    .setDescription("Remove token from token list")
    .setDefaultMemberPermissions(PermissionFlagsBits.Administrator)
    .addStringOption((options) =>
      options
        .setName("token")
        .setDescription("Choice one token")
        .setAutocomplete(true)
        .setRequired(true)
    ),

  async autocomplete(interaction) {
    const serverId = interaction.member.guild.id;

    const tokens = await listServerTokens(serverId);

    const focusedValue = interaction.options.getFocused();

    const filtered = tokens.filter(({ metadata }) => {
      const { name = "", symbol = "" } = metadata || {};

      const focusedLowerCase = focusedValue.toLowerCase();

      return (
        name.toLowerCase().includes(focusedLowerCase) ||
        symbol.toLowerCase().includes(focusedLowerCase)
      );
    });

    await interaction.respond(
      filtered.map((token) => ({ name: token.metadata.name, value: token.id }))
    );
  },

  async execute(interaction) {
    const { user: username } = interaction;
    const tokenId = interaction.options.getString("token");
    const serverId = interaction.member.guild.id;

    const token = await deleteServerToken(tokenId, serverId);

    if (!token) {
      await interaction.reply({
        content:
          "This server has not yet been registered or this token not registered on server. Use the /register command to register your server or choice a token registered!",
        ephemeral: true,
      });

      return;
    }

    await interaction.reply({
      content: `Hey ${username} the token has been removed from the server's token list`,
      ephemeral: true,
    });
  },
};

'''
'''--- packages/bot/src/commands/send.js ---
const { SlashCommandBuilder } = require("discord.js");
const getSendParameters = require("../graphql/queries/getSendParameters");
const listServerTokens = require("../graphql/queries/listServerTokens");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("send")
    .setDescription("Transfer tokens to your friends")
    .addStringOption((option) =>
      option
        .setName("token")
        .setDescription("Select your token from the list")
        .setAutocomplete(true)
        .setRequired(true)
    )
    .addStringOption((option) =>
      option
        .setName("amount")
        .setDescription("The amount of Tokens to be sent")
        .setRequired(true)
    )
    .addUserOption((option) =>
      option
        .setName("receiver")
        .setDescription("The receiving user (wallet must be saved)")
        .setRequired(true)
    ),

  async autocomplete(interaction) {
    const serverId = interaction.member.guild.id;

    const tokens = await listServerTokens(serverId);

    const focusedValue = interaction.options.getFocused();

    const filtered = tokens.filter((choice) => {
      const { name = "", symbol = "" } = choice?.metadata || {};

      const focusedLowerCase = focusedValue.toLowerCase();

      return (
        name.toLowerCase().includes(focusedLowerCase) ||
        symbol.toLowerCase().includes(focusedLowerCase)
      );
    });

    await interaction.respond(
      filtered.map((token) => ({ name: token.metadata.name, value: token.id }))
    );
  },

  async execute(interaction) {
    const burnWallet = null;

    const { user: sender } = interaction;
    const serverId = interaction.member.guild.id;

    const tokenId = interaction.options.getString("token");
    const amount = interaction.options.getString("amount");
    const receiver = interaction.options.getUser("receiver");

    const { token, wallet } = await getSendParameters(
      serverId,
      receiver.id,
      tokenId
    );

    if (!token) {
      await interaction.reply({
        content:
          "That token is unavailable. Please, pick one of the tokens listed on this server",
        ephemeral: true,
      });

      return;
    }

    if (!wallet) {
      await interaction.reply({
        content: `Hey ${receiver}, ${sender} is trying to send you ${amount} ${token.metadata.name}. Please, register your wallet using /setwallet`,
        ephemeral: false,
      });

      return;
    }

    const linkToTransfer = `Click the link to transfer: https://peterthebot.com/transaction?token=${
      token.id
    }&amount=${amount.replace(
      /,/g,
      "."
    )}&receiver=${wallet}&burner=${burnWallet}&receiver_id=${
      receiver.id
    }&sender_id=${sender.id}&server_id=${serverId}`;

    await interaction.reply({
      content: linkToTransfer,
      ephemeral: true,
    });
  },
};

'''
'''--- packages/bot/src/commands/setWallet.js ---
const { SlashCommandBuilder } = require("discord.js");
const insertWallet = require("../graphql/mutations/insertWallet");
const findDuplicatePkError = require("../utils/findDuplicatePkError");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("setwallet")
    .setDescription(
      "Set your near wallet (warning: required to receive tokens)"
    )
    .addStringOption((options) =>
      options
        .setName("wallet")
        .setDescription("Your near wallet eg. peter.near")
        .setRequired(true)
    ),

  async execute(interaction) {
    const nearWallet = interaction.options.getString("wallet");
    const { username, id } = interaction.user;
    const serverId = interaction.member.guild.id;

    try {
      await insertWallet(id, serverId, nearWallet);
      await interaction.reply({
        content: `Hey ${username}, your wallet: ${nearWallet} is set`,
        ephemeral: true,
      });
    } catch ({ graphQLErrors }) {
      if (findDuplicatePkError(graphQLErrors)) {
        await interaction.reply({
          content: "You already have a registered wallet in this server",
          ephemeral: true,
        });

        return;
      }

      await interaction.reply({
        content: `Internal error, if you think this is a bug, please contact developers: ${graphQLErrors}`,
        ephemeral: true,
      });
    }
  },
};

'''
'''--- packages/bot/src/commands/tutorial.js ---
const isEmpty = require("lodash/isEmpty");
const { SlashCommandBuilder, EmbedBuilder } = require("discord.js");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("tutorial")
    .setDescription("How to use the bot."),

  async execute(interaction) {
    const embed = new EmbedBuilder().setTitle("Tutorial").setColor("Random")
      .setDescription(`
        Hi! If this is your first time using me, the best tipping bot on Near, please follow these steps!

        1) First, use the command /setwallet to connect your Near wallet to your discord account. Now you'll be set to send and receive tokens!
        2) To send tokens, use the /send command. Take care with decimals! Depending on your computer configuration, it could work with comma "0,1" or dot "0.1".
        3) To verify which wallet is connected to your account, use the /verifywallet command.
        4) To change the wallet connected to your account, just use the /setwallet command again.
        5) Feel free to send us any feedback at the /feedback command!
      `);

    await interaction.reply({ embeds: [embed], ephemeral: true });
  },
};

'''
'''--- packages/bot/src/commands/verifyWallet.js ---
const { SlashCommandBuilder } = require("discord.js");
const findUserWallet = require("../graphql/queries/findUserWallet");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("verifywallet")
    .setDescription(
      "Check which wallet is connected to your discord account on this server"
    ),

  async execute(interaction) {
    const { username, id } = interaction.user;
    const serverId = interaction.member.guild.id;

    const userWallet = await findUserWallet(id, serverId);

    if (!userWallet.wallet) {
      await interaction.reply({
        content:
          "There is no wallet registred. Please use /setwallet to save your wallet",
        ephemeral: true,
      });
      return;
    }

    await interaction.reply({
      content: `Hey you ${username}, your wallet is ${userWallet.wallet}`,
      ephemeral: true,
    });
  },
};

'''
'''--- packages/bot/src/commands/viewHistory.js ---
const { SlashCommandBuilder, EmbedBuilder } = require("discord.js");
const { formatDecimals } = require("../utils/formatDecimals");
const { viewFunction } = require("../utils/viewFunction");
const listServerTokens = require("../graphql/queries/listServerTokens");

module.exports = {
  data: new SlashCommandBuilder()
    .setName("viewhistory")
    .setDescription("See the history of tokens sent/received from a user")
    .addUserOption((option) =>
      option
        .setName("user")
        .setDescription("Choose the user whose history you want to see")
        .setRequired(true)
    )
    .addStringOption((option) =>
      option
        .setName("token")
        .setDescription("Choose the token you want to see in the history")
        .setRequired(true)
        .setAutocomplete(true)
    ),
  async autocomplete(interaction) {
    const serverId = interaction.member.guild.id;

    const tokens = await listServerTokens(serverId);

    const focusedValue = interaction.options.getFocused();

    const filtered = tokens.filter((choice) => {
      const { name = "", symbol = "" } = choice?.metadata || {};

      const focusedLowerCase = focusedValue.toLowerCase();

      return (
        name.toLowerCase().includes(focusedLowerCase) ||
        symbol.toLowerCase().includes(focusedLowerCase)
      );
    });

    await interaction.respond(
      filtered.map((token) => ({ name: token.metadata.name, value: token.id }))
    );
  },

  async execute(interaction) {
    const serverId = interaction.member.guild.id;
    const user = interaction.options.getUser("user");
    const coin = interaction.options.getString("token");
    const tokens = await listServerTokens(serverId);

    const amount = await viewFunction("view_history", {
      server: serverId,
      user: user.id,
      coin: coin === "near" ? "$NEAR" : coin,
    });

    const token = tokens.find(({ id }) => {
      if (coin === "$NEAR") {
        return id === "near";
      }
      return id === coin;
    });

    if (!token) {
      await interaction.reply({
        content: "Choose a token that is on the token list",
        ephemeral: true,
      });

      return;
    }

    const embed = new EmbedBuilder()
      .setTitle(`History of ${user.tag}`)
      .addFields({
        name: `Amount of ${token.metadata.name} sent/received`,
        value: `Amount: ${formatDecimals(amount, token.metadata.decimals)}`,
      });

    await interaction.reply({ embeds: [embed], ephemeral: true });
  },
};

'''
'''--- packages/bot/src/events/guildCreate.js ---
const { Events, EmbedBuilder } = require("discord.js");

const steps = [
  {
    name: "1 - Register server",
    value:
      "An administrator must use the command /register to enable the server utilization - you won't be able to use the bot without registering it",
  },
  {
    name: "2 - Enable tokens",
    value:
      "Use the /addtoken command to choose which tokens to make available on your server.",
  },
  {
    name: "3 - Set wallet",
    value:
      "Use the /setwallet command to add the address of the wallet you want to receive tokens from other users.",
  },
  {
    name: "4 - Send tokens",
    value: "Use the /send command to send tokens to anyone on your server.",
  },
];

module.exports = {
  name: Events.GuildCreate,
  async execute(guild) {
    const tutorial = new EmbedBuilder()
      .setTitle("Configuration tutorial")
      .setDescription(
        "Hi, thanks for inviting me to this server. Here is a tutorial on my configuration:"
      )
      .setColor("Random");

    steps.forEach(({ name, value }) => tutorial.addFields({ name, value }));

    const channel = guild.channels.cache.find((channel) => channel.type === 0);

    channel.send({ embeds: [tutorial] });
  },
};

'''
'''--- packages/bot/src/events/interactionCreate.js ---
const { Events } = require("discord.js");

module.exports = {
  name: Events.InteractionCreate,
  async execute(interaction) {
    if (!interaction.isChatInputCommand() && !interaction.isAutocomplete())
      return;
    const command = interaction.client.commands.get(interaction.commandName);

    if (!command) {
      console.error(
        `No command matching ${interaction.commandName} was found.`
      );
      return;
    }

    try {
      if (interaction.isChatInputCommand()) {
        await command.execute(interaction);
      } else {
        await command.autocomplete(interaction);
      }
    } catch (error) {
      console.error(`Error executing ${interaction.commandName}`);
      console.error(error);
    }
  },
};

'''
'''--- packages/bot/src/events/modal.js ---
const { Events, EmbedBuilder } = require("discord.js");

module.exports = {
  name: Events.InteractionCreate,
  async execute(interaction) {
    if (!interaction.isModalSubmit()) return;

    const token = interaction.fields.getTextInputValue("tokenName");

    const address = interaction.fields.getTextInputValue("address");

    const { user } = interaction;

    const message = new EmbedBuilder()
      .setTitle("New token request")
      .setDescription(token)
      .setFooter({
        text: user.tag,
        iconURL: user.displayAvatarURL({ format: "png" }),
      })
      .setColor("Random")
      .addFields({ name: "Address", value: address });

    await interaction.client.guilds.cache
      .get(process.env.SERVER_ID)
      .channels.cache.get(process.env.REQUEST_CHANNEL_ID)
      .send({ embeds: [message] });

    await interaction.reply({
      content: "Your request has been sent",
      ephemeral: true,
    });
  },
};

'''
'''--- packages/bot/src/events/ready.js ---
const { Events } = require("discord.js");

module.exports = {
  name: Events.ClientReady,
  once: true,
  async execute(client) {
    console.log(`Ready! Logged in as ${client.user.tag}`);
  },
};

'''
'''--- packages/bot/src/graphql/mutations/deleteServerToken.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (tokenId, serverId) => {
  const { data } = await graphQlClient.mutate({
    mutation: gql`
      mutation DeleteServerToken($tokenId: String!, $serverId: BigInt!) {
        deleteServerTokenByServerIdAndTokenId(
          input: { serverId: $serverId, tokenId: $tokenId }
        ) {
          serverToken {
            tokenId
            serverId
          }
        }
      }
    `,
    variables: {
      tokenId,
      serverId,
    },
  });

  console.error({ data });

  // TODO: cache eviction policy

  return data.deleteServerTokenByServerIdAndTokenId;
};

'''
'''--- packages/bot/src/graphql/mutations/insertServer.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (id, name) => {
  const result = await graphQlClient.mutate({
    mutation: gql`
      mutation InsertServer($server: ServerInput!) {
        createServer(input: { server: $server }) {
          server {
            nodeId
            id
            name
          }
        }
      }
    `,
    variables: {
      server: {
        id,
        name,
      },
    },
  });

  return result;
};

'''
'''--- packages/bot/src/graphql/mutations/insertServerToken.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (serverId, tokenId) => {
  const { data } = await graphQlClient.mutate({
    mutation: gql`
      mutation InsertServerToken($serverId: BigInt!, $tokenId: String!) {
        createServerToken(
          input: { serverToken: { serverId: $serverId, tokenId: $tokenId } }
        ) {
          serverToken {
            nodeId
            serverId
            tokenId
          }
        }
      }
    `,
    variables: {
      serverId,
      tokenId,
    },
  });

  return data;
};

'''
'''--- packages/bot/src/graphql/mutations/insertToken.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (id, metadata) => {
  const { data } = await graphQlClient.mutate({
    mutation: gql`
      mutation InsertToken($id: String, $metadata: JSON!) {
        createToken(input: { token: { id: $id, metadata: $metadata } }) {
          token {
            nodeId
            id
            metadata
          }
        }
      }
    `,
    variables: {
      objects: {
        id,
        metadata,
      },
    },
  });

  return data;
};

'''
'''--- packages/bot/src/graphql/mutations/insertWallet.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (userId, serverId, wallet) => {
  const { data } = await graphQlClient.mutate({
    mutation: gql`
      mutation upsertWallet(
        $userId: BigInt!
        $serverId: BigInt!
        $wallet: String!
      ) {
        upsertWallet(
          input: {
            wallet: { userId: $userId, serverId: $serverId, wallet: $wallet }
          }
        ) {
          wallet {
            nodeId
            userId
            serverId
            wallet
          }
        }
      }
    `,
    variables: {
      userId,
      serverId,
      wallet,
    },
  });

  return data?.wallet?.wallet;
};

'''
'''--- packages/bot/src/graphql/mutations/sendFeedback.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (userId, serverId, username, message) => {
  const { data } = await graphQlClient.mutate({
    mutation: gql`
      mutation SendFeedback(
        $serverId: BigInt!
        $userId: BigInt!
        $username: String!
        $message: String!
      ) {
        createFeedback(
          input: {
            feedback: {
              userId: $userId
              serverId: $serverId
              username: $username
              message: $message
            }
          }
        ) {
          feedback {
            nodeId
            id
            username
            message
            submittedAt
          }
        }
      }
    `,
    variables: {
      userId,
      serverId,
      username,
      message,
    },
  });

  return data;
};

'''
'''--- packages/bot/src/graphql/queries/findCommandHelp.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (command) => {
  const { data } = await graphQlClient.query({
    query: gql`
      query FindCommandHelp($command: String!) {
        helpByCommand(command: $command) {
          nodeId
          command
          message
        }
      }
    `,
    variables: {
      command,
    },
  });

  return data.helpByCommand;
};

'''
'''--- packages/bot/src/graphql/queries/findServerById.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (serverId) => {
  const { data } = await graphQlClient.query({
    query: gql`
      query FindServerById($id: BigInt!) {
        serverById(id: $id) {
          nodeId
          id
          name
        }
      }
    `,
    variables: {
      id: serverId,
    },
  });

  return data.serverById;
};

'''
'''--- packages/bot/src/graphql/queries/findUserWallet.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (userId, serverId) => {
  const { data } = await graphQlClient.query({
    query: gql`
      query FindUserWallet($userId: BigInt!, $serverId: BigInt!) {
        walletByUserIdAndServerId(userId: $userId, serverId: $serverId) {
          nodeId
          userId
          serverId
          wallet
        }
      }
    `,
    variables: {
      userId,
      serverId,
    },
  });

  return data.walletByUserIdAndServerId;
};

'''
'''--- packages/bot/src/graphql/queries/getSendParameters.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (serverId, receiverId, tokenId) => {
  const { data } = await graphQlClient.query({
    query: gql`
      query GetSendParameters(
        $serverId: BigInt!
        $receiverId: BigInt!
        $tokenId: String!
      ) {
        serverToken: serverTokenByServerIdAndTokenId(
          serverId: $serverId
          tokenId: $tokenId
        ) {
          tokenByTokenId {
            nodeId
            id
            metadata
          }
        }

        wallet: walletByUserIdAndServerId(
          serverId: $serverId
          userId: $receiverId
        ) {
          nodeId
          wallet
        }
      }
    `,
    variables: {
      serverId,
      receiverId,
      tokenId,
    },
  });

  return {
    token: data?.serverToken?.tokenByTokenId,
    wallet: data?.wallet?.wallet,
  };
};

'''
'''--- packages/bot/src/graphql/queries/listHelps.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async () => {
  const { data } = await graphQlClient.query({
    query: gql`
      query ListHelps {
        allHelps {
          nodes {
            nodeId
            command
            message
          }
        }
      }
    `,
  });

  return data.allHelps.nodes;
};

'''
'''--- packages/bot/src/graphql/queries/listServerTokens.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async (serverId) => {
  const { data } = await graphQlClient.query({
    query: gql`
      query ListServerTokens($serverId: BigInt!) {
        allServerTokens(condition: { serverId: $serverId }) {
          nodes {
            nodeId
            tokenByTokenId {
              nodeId
              id
              metadata
            }
          }
        }
      }
    `,
    variables: {
      serverId,
    },
  });

  console.error({ token: data.tokenByTokenId });

  return data.allServerTokens.nodes.map(
    ({ tokenByTokenId: { id, metadata } }) => ({
      id,
      metadata,
    })
  );
};

'''
'''--- packages/bot/src/graphql/queries/listTokens.js ---
const { gql } = require("@apollo/client/core");
const { graphQlClient } = require("../../lib/graphQlClient");

module.exports = async () => {
  const { data } = await graphQlClient.query({
    query: gql`
      query ListTokens {
        allTokens {
          nodes {
            nodeId
            id
            metadata
          }
        }
      }
    `,
  });

  return data.allTokens.nodes;
};

'''
'''--- packages/bot/src/handlers/commands.js ---
const { readdirSync } = require("fs");
const { REST, Routes } = require("discord.js");
const path = require("path");

module.exports = async (client) => {
  const slashCommands = [];

  const commandsPath = path.join(__dirname, "..", "commands");
  const commandFiles = readdirSync(commandsPath).filter((file) =>
    file.endsWith(".js")
  );

  const restClient = new REST({ version: "9" }).setToken(process.env.BOT_TOKEN);

  for (const file of commandFiles) {
    const filePath = path.join(commandsPath, file);
    const command = require(filePath);

    if ("data" in command && "execute" in command) {
      client.commands.set(command.data.name, command);
      slashCommands.push(command.data.toJSON());
    } else {
      console.log(
        `[WARNING] The command at ${filePath} is missing a required "data" or "execute" property.`
      );
    }
  }

  await restClient.put(Routes.applicationCommands(process.env.CLIENT_ID), {
    body: slashCommands,
  });
};

'''
'''--- packages/bot/src/handlers/events.js ---
const { readdirSync } = require("fs");
const path = require("path");

module.exports = (client) => {
  const eventsPath = path.join(__dirname, "..", "events");
  const eventFiles = readdirSync(eventsPath).filter((file) =>
    file.endsWith(".js")
  );

  for (const file of eventFiles) {
    const filePath = path.join(eventsPath, file);
    const event = require(filePath);

    if (event.once) {
      client.once(event.name, (...args) => event.execute(...args));
    } else {
      client.on(event.name, (...args) => event.execute(...args));
    }
  }
};

'''
'''--- packages/bot/src/handlers/index.js ---
const commandsHandler = require("./commands");
const eventsHandler = require("./events");

const handlers = [commandsHandler, eventsHandler];

module.exports = {
  async initializeHandlers(client) {
    await Promise.all(handlers.map((handler) => handler(client)));
  },
};

'''
'''--- packages/bot/src/lib/graphQlClient.js ---
const {
  ApolloClient,
  HttpLink,
  InMemoryCache,
} = require("@apollo/client/core");
const { defaultDataIdFromObject } = require("@apollo/client");
const fetch = require("node-fetch");

const graphQlClient = new ApolloClient({
  link: new HttpLink({
    uri: `http://localhost:${process.env.GRAPHQL_PORT}/graphql`,
    fetch,
    headers: {},
  }),
  defaultOptions: {
    watchQuery: {
      fetchPolicy: "no-cache",
      errorPolicy: "ignore",
    },
    query: {
      // disabling cache due to issues with invalidation
      // TODO: when re-enabling cache, consider "server-side" cache instead.
      fetchPolicy: "no-cache",
      errorPolicy: "all",
    },
  },
  cache: new InMemoryCache({
    dataIdFromObject(responseObject) {
      if (responseObject.nodeId) {
        return responseObject.nodeId;
      }
      return defaultDataIdFromObject(responseObject);
    },
  }),
});

module.exports = { graphQlClient };

'''
'''--- packages/bot/src/utils/findDuplicatePkError.js ---
module.exports = (graphQLErrors) => {
  if (Array.isArray(graphQLErrors)) {
    return graphQLErrors.find((error) =>
      error.message.match("duplicate key value violates unique constraint")
    );
  }

  return undefined;
};

'''
'''--- packages/bot/src/utils/findServerNotRegisteredError.js ---
module.exports = (graphQLErrors) => {
  if (Array.isArray(graphQLErrors)) {
    return graphQLErrors.find((error) =>
      error.message.match("violates foreign key constraint")
    );
  }

  return undefined;
};

'''
'''--- packages/bot/src/utils/formatDecimals.js ---
const { default: Big } = require("big.js");

const formatDecimals = (amount, decimals) => {
  return Big(amount).div(Big(10).pow(decimals)).toFixed(2);
};

module.exports = { formatDecimals };

'''
'''--- packages/bot/src/utils/viewFunction.js ---
const { providers } = require("near-api-js");

const viewFunction = async (methodName, args = {}) => {
  const provider = new providers.JsonRpcProvider({
    url: process.env.NEAR_NODE_URL,
  });

  const serializerArgs = Buffer.from(JSON.stringify(args)).toString("base64");

  const res = await provider.query({
    request_type: "call_function",
    account_id: process.env.CONTRACT,
    method_name: methodName,
    args_base64: serializerArgs,
    finality: "optimistic",
  });

  return (
    res &&
    res.result.length > 0 &&
    JSON.parse(Buffer.from(res.result).toString())
  );
};

module.exports = { viewFunction };

'''
'''--- packages/contract/Cargo.toml ---
[package]
name = "near-tipping-bot"
version = "0.2.0"
authors = ["Jack the dev", "Peter pan"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dev-dependencies]
near-sdk-sim = "3.1.0"

[dependencies]
near-sdk = "3.1.0"

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true
'''
'''--- packages/contract/package.json ---
{
  "name": "@near/contract",
  "version": "1.0.0",
  "license": "MIT",
  "private": true,
  "scripts": {
    "test:unit": "cargo test -- --nocapture",
    "test:integration": "yarn build && yarn build:test_token && cd tests && cargo test -- --nocapture",
    "build:test_token": "cd test_token && RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release && mkdir -p ../out && cp target/wasm32-unknown-unknown/release/test_token.wasm ../out/test_token.wasm",
    "build": "RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release && mkdir -p out && cp target/wasm32-unknown-unknown/release/near_tipping_bot.wasm out/near_tipping_bot.wasm"
  }
}

'''
'''--- packages/contract/readme.md ---
# Tipping bot contract

This contract handles all on chain logic and analytics for the tipping bot.

It does not implement any storage cost logic, meaning that the owner of the contract must provision all storage deposits for the proper functioning of the contract. Storage is mostly required for analytics functionalities.

## Tipping functions

1. `transfer_payment`
Arguments:
 - receiver -> NEAR AccountId of the user that will receive the tip
 - sender_discord -> String representing the discord account of the user sending the tip
 - receiver_discord -> String representing the discord account of the user receiving the tip
 - server_discord -> String representing the discord account of the server through which the transaction was initialized

 In this method you must pass the amount of native NEAR that you want to tip as a deposit

2. `ft_transfer_call`
ft_transfer_call must be called on the token contract (not on the tipping bot contract) with the following parameters to tip using a NEP-141 token.
Arguments:
 - receiver_id -> AccountId of the tipping bot contract
 - amount -> String amount of tokens to be tipped
 - msg -> String stringfied version of object:
    ```
    {
        receiver: string - NEAR AccountId of the user that will receive the tip,
        sender_discord: string - representing the discord account of the user sending the tip,
        receiver_discord: string - representing the discord account of the user receiving the tip,
        server_discord: string - representing the discord account of the server through which the transaction was initialized,
    }
    ```

## Analytics functions

1. `view_history`
Shows how many tokens a user has donated in a specific server
Arguments:
 - user -> String representing the discord account of the user that sent the tips
 - server -> String representing the discord account of the server through which the transaction was initialized
 - coin -> AccountId of the token you want to get data from (in case it is native near use `$NEAR`)

Returns `U128`

2. `view_last_server_tips`
Returns the last 5 tipping transactions from a server
Arguments:
 - server -> String representing the discord account of the server through which the transaction was initialized

Returns `Vec<LastTransactionsItem>`

3. `view_ranking`
Returns rank of 5 biggest donnors of a specific token in a specific server.
Arguments:
 - server -> String representing the discord account of the server through which the transaction was initialized
 - coin -> AccountId of the token you want to get data from (in case it is native near use `$NEAR`)

Returns `Vec<RankingItem>`
'''
'''--- packages/contract/src/lib.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
pub use near_sdk::serde_json::{self, json, Value};
use near_sdk::{
    borsh,
    collections::LookupMap,
    env, ext_contract,
    json_types::U128,
    log, near_bindgen,
    serde::{Deserialize, Serialize},
    AccountId, BorshStorageKey, Gas, PanicOnDefault, Promise, PromiseResult,
};

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc = near_sdk::wee_alloc::WeeAlloc::INIT;

pub const FRACTIONAL_BASE: u128 = 10_000;
pub const BASE_GAS: Gas = 5_000_000_000_000;

#[ext_contract(token_contract)]
trait FungibleToken {
    fn ft_transfer(receiver_id: String, amount: U128, memo: String);
}

#[ext_contract(ext_self)]
trait LogInfo {
    fn log_transfer(
        receiver: String,
        amount: U128,
        token: AccountId,
        sender: AccountId,
        sender_discord: String,
        receiver_discord: String,
        server_discord: String,
    );
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FtTransferCallMsg {
    receiver: String,
    sender_discord: String,
    receiver_discord: String,
    server_discord: String,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct ServerCoinUser {
    server: String,
    coin: String,
    user: String,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct ServerCoin {
    server: String,
    coin: String,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct RankingItem {
    user: String,
    amount: U128,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct LastTransactionsItem {
    sender: String,
    receiver: String,
    coin: String,
    amount: U128,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub user_history: LookupMap<ServerCoinUser, u128>,
    pub server_ranking: LookupMap<ServerCoin, Vec<RankingItem>>,
    pub server_last_tips: LookupMap<String, Vec<LastTransactionsItem>>,
}

#[derive(BorshDeserialize, BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    UserHistory,
    ServerRanking,
    ServerLastTips,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(
            env::is_valid_account_id(owner_id.as_bytes()),
            "Invalid owner account"
        );
        assert!(!env::state_exists(), "Already initialized");

        Self {
            owner_id,
            user_history: LookupMap::new(StorageKey::UserHistory),
            server_ranking: LookupMap::new(StorageKey::ServerRanking),
            server_last_tips: LookupMap::new(StorageKey::ServerLastTips),
        }
    }

    #[payable]
    pub fn transfer_payment(
        &mut self,
        receiver: AccountId,
        sender_discord: String,
        receiver_discord: String,
        server_discord: String,
    ) -> Promise {
        let sender_id = env::predecessor_account_id();
        let amount = env::attached_deposit();

        Promise::new(receiver.clone())
            .transfer(amount)
            .then(ext_self::log_transfer(
                receiver,
                U128(amount),
                "$NEAR".to_string(),
                sender_id,
                sender_discord,
                receiver_discord,
                server_discord,
                &env::current_account_id(),
                0,
                BASE_GAS,
            ))
    }

    pub fn ft_on_transfer(&mut self, sender_id: String, amount: U128, msg: String) -> String {
        let parsed_message: FtTransferCallMsg =
            serde_json::from_str(&msg).expect("msg in wrong format");

        token_contract::ft_transfer(
            parsed_message.receiver.clone(),
            amount.clone(),
            "discord bot donation".to_string(),
            &env::predecessor_account_id(),
            1,
            BASE_GAS,
        )
        .then(ext_self::log_transfer(
            parsed_message.receiver,
            amount,
            env::predecessor_account_id(),
            sender_id,
            parsed_message.sender_discord,
            parsed_message.receiver_discord,
            parsed_message.server_discord,
            &env::current_account_id(),
            0,
            BASE_GAS,
        ));
        "0".to_string()
    }

    #[private]
    pub fn log_transfer(
        &mut self,
        receiver: String,
        amount: U128,
        token: AccountId,
        sender: AccountId,
        sender_discord: String,
        receiver_discord: String,
        server_discord: String,
    ) {
        assert_eq!(env::promise_results_count(), 1, "ERR_TOO_MANY_RESULTS");
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_val) => {
                log!(
                    "{}",
                    &json!({
                        "standard": "The-Supah-Tipping-bot",
                        "version": "1.0.0",
                        "event": "transfer",
                        "data": {
                            "sender": sender,
                            "receiver": receiver,
                            "sender_discord": sender_discord,
                            "receiver_discord": receiver_discord,
                            "server_discord": server_discord,
                            "token": token,
                            "amount":amount,
                        }
                    })
                    .to_string()
                );
                self.update_analytics_records(
                    sender_discord,
                    receiver_discord,
                    server_discord,
                    token,
                    amount.0,
                )
            }
            PromiseResult::Failed => env::panic(b"ERR_CALL_FAILED"),
        }
    }

    pub fn view_history(&self, user: String, server: String, coin: String) -> U128 {
        U128(
            self.user_history
                .get(&ServerCoinUser { server, coin, user })
                .unwrap_or(0),
        )
    }

    pub fn view_last_server_tips(&self, server: String) -> Vec<LastTransactionsItem> {
        self.server_last_tips.get(&server).unwrap_or(vec![])
    }

    pub fn view_ranking(&self, server: String, coin: String) -> Vec<RankingItem> {
        self.server_ranking
            .get(&ServerCoin { server, coin })
            .unwrap_or(vec![])
    }
}

impl Contract {
    fn update_analytics_records(
        &mut self,
        user: String,
        receiver: String,
        server: String,
        coin: String,
        amount: u128,
    ) {
        let user_new_amount =
            self.update_user_history(user.clone(), server.clone(), coin.clone(), amount);
        self.update_last_tips(user.clone(), receiver, server.clone(), coin.clone(), amount);
        self.update_ranking(user, server, coin, user_new_amount);
    }

    fn update_user_history(
        &mut self,
        user: String,
        server: String,
        coin: String,
        amount: u128,
    ) -> u128 {
        let key = ServerCoinUser { server, coin, user };
        let current_balance = self.user_history.get(&key).unwrap_or(0);
        let new_balance = current_balance + amount;
        self.user_history.insert(&key, &new_balance);
        new_balance
    }

    fn update_last_tips(
        &mut self,
        sender: String,
        receiver: String,
        server: String,
        coin: String,
        amount: u128,
    ) {
        let transaction = LastTransactionsItem {
            sender,
            receiver,
            coin,
            amount: U128(amount),
        };

        let mut current_vec = self
            .server_last_tips
            .get(&server)
            .unwrap_or(Vec::with_capacity(5));

        current_vec.insert(0, transaction);

        if current_vec.len() > 5 {
            current_vec.pop();
        }

        self.server_last_tips.insert(&server, &current_vec);
    }

    fn update_ranking(&mut self, user: String, server: String, coin: String, amount: u128) {
        let key = ServerCoin { server, coin };

        let user_entry = RankingItem {
            user: user.clone(),
            amount: U128(amount),
        };

        let mut current_ranking = self
            .server_ranking
            .get(&key)
            .unwrap_or(Vec::with_capacity(5));

        // exclude same user if present
        current_ranking.retain(|entry| entry.user != user);

        let mut index = 0;
        let mut user_inserted = false;
        while index < current_ranking.len() {
            let entry = current_ranking.get(index).unwrap();
            if entry.amount.0 < amount {
                current_ranking.insert(index, user_entry.clone());
                user_inserted = true;
                break;
            }
            index += 1;
        }

        if current_ranking.len() > 5 {
            current_ranking.pop();
        } else if current_ranking.len() < 5 && !user_inserted {
            current_ranking.push(user_entry);
        }

        self.server_ranking.insert(&key, &current_ranking);
    }
}

//----------------------------------- TEST -------------------------------------------------

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    use super::*;

    pub const CONTRACT_ACCOUNT: &str = "contract.testnet";
    pub const OWNER_ACCOUNT: &str = "owner.testnet";

    pub fn get_context(
        input: Vec<u8>,
        is_view: bool,
        attached_deposit: u128,
        account_balance: u128,
        signer_id: AccountId,
    ) -> VMContext {
        VMContext {
            current_account_id: CONTRACT_ACCOUNT.to_string(),
            signer_account_id: signer_id.clone(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id: signer_id.clone(),
            input,
            block_index: 0,
            block_timestamp: 0,
            account_balance,
            account_locked_balance: 0,
            storage_usage: 0,
            attached_deposit,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    #[test]
    fn test_new() {
        let context = get_context(vec![], false, 0, 0, OWNER_ACCOUNT.to_string());

        testing_env!(context);

        let contract = Contract::new(OWNER_ACCOUNT.to_string());
        assert_eq!(contract.owner_id, OWNER_ACCOUNT.to_string())
    }
}

'''
'''--- packages/contract/test_token/Cargo.toml ---
[package]
name = "test_token"
version = "1.0.0"
authors = ["hack-a-du"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-contract-standards = "4.1.1"
near-sdk = "4.1.1"

'''
'''--- packages/contract/test_token/src/errors.rs ---
pub(crate) const ERR_001: &str =
  "lib: only_owner: this function is restricted to the owner of the contract";

'''
'''--- packages/contract/test_token/src/lib.rs ---
use near_contract_standards::{
  self,
  fungible_token::{
    FungibleToken,
    metadata::{FungibleTokenMetadata, FungibleTokenMetadataProvider},
  },
};
use near_sdk::{
  borsh::{self, BorshDeserialize, BorshSerialize},
  collections::LazyOption,
  env,
  json_types::U128,
  near_bindgen, PanicOnDefault, PromiseOrValue, AccountId, Balance,
};

pub mod errors;

use crate::errors::ERR_001;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
  owner_id: AccountId,
  token: FungibleToken,
  metadata: LazyOption<FungibleTokenMetadata>,
}

#[near_bindgen]
impl Contract {
  #[init]
  pub fn new(owner_id: AccountId, total_supply: U128, metadata: FungibleTokenMetadata) -> Self {
    assert!(!env::state_exists(), "Already initialized");
    metadata.assert_valid();
    let mut this = Self {
      owner_id: owner_id.clone(),
      token: FungibleToken::new(b"a".to_vec()),
      metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
    };
    this.token.internal_register_account(&owner_id);
    this.token.internal_deposit(&owner_id, total_supply.0);
    this
  }

  fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
    env::log_str(format!("Closed @{} with {}", account_id, balance).as_str());
  }
}

near_contract_standards::impl_fungible_token_core!(Contract, token);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
  fn ft_metadata(&self) -> FungibleTokenMetadata {
    self.metadata.get().unwrap()
  }
}

impl Contract {
  pub fn only_owner(&self) {
    assert_eq!(env::predecessor_account_id(), self.owner_id, "{}", ERR_001);
  }
}

'''
'''--- packages/contract/tests/Cargo.toml ---
[package]
name = "tests"
version = "0.1.0"
edition = "2021"

[dependencies]
anyhow = "1.0"
borsh = "0.9"
near-units = "0.2.0"
near-contract-standards = "4.0.0"
serde = "1.0"
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.10.0", features = ["full"] }
workspaces = "0.5.0"
futures = "0.3.21"

[dev-dependencies]
rstest = "0.15.0"
'''
'''--- packages/contract/tests/src/lib/events.rs ---
use workspaces::result::ExecutionResult;

#[allow(dead_code)] // it is used in tests, I found it preferable to #[cfg(test)]
pub const EVENT_JSON_LOG_PREFIX: &str = "EVENT_JSON:";

#[allow(dead_code)]
pub fn parse_event_logs<T>(
  result: ExecutionResult<T>,
) -> serde_json::Result<Vec<serde_json::Value>> {
  let prefix_len = EVENT_JSON_LOG_PREFIX.len();

  let logs = result.logs();

  let mut events = Vec::with_capacity(logs.len());
  for log in logs.iter() {
    let log = &log[prefix_len..];

    let event = serde_json::from_str(log)?;

    events.push(event);
  }

  Ok(events)
}

#[allow(dead_code)]
pub fn find_event_type(
  events: Vec<serde_json::Value>,
  event_type: &str,
) -> Option<serde_json::Value> {
  events
    .iter()
    .find(|event| event.get("event").and_then(|t| t.as_str()) == Some(event_type))
    .and_then(|event| Some(event.clone()))
}

'''
'''--- packages/contract/tests/src/lib/mod.rs ---
pub mod events;

'''
'''--- packages/contract/tests/src/main.rs ---
use std::path::Path;
use workspaces::{Contract, Account, Worker};
use workspaces::network::Sandbox;
use std::vec::Vec;
use std::io::Error;
use near_units::parse_near;
use futures::future::try_join_all;

mod lib;
mod methods;
mod tests_launchpad;

pub use methods::*;

pub const OUT_DIR: &str = "../out";

pub const FRACTION_BASE: u128 = 10_000;

pub const TO_NANO: u64 = 1_000_000_000;
pub const AVERAGE_BLOCK_TIME: u64 = 1_200_000_000;

pub const GAS_LIMIT: u64 = 300_000_000_000_000;
pub const DEFAULT_GAS: u64 = 3_000_000_000_000;

pub const FT_DECIMALS: u8 = 8;
pub const FT_INITIAL_USER_BALANCE: u128 = 100_000_000_000_000;

pub const USER_ACCOUNT_BALANCE: u128 = 500_000_000_000_000_000_000_000_000;
pub const CONTRACT_ACCOUNT_BALANCE: u128 = 200_000_000_000_000_000_000_000_000;

#[tokio::main]
async fn main() -> anyhow::Result<()> {
  anyhow::Ok(())
}

'''
'''--- packages/contract/tests/src/methods/mod.rs ---
use workspaces::{operations::CallTransaction, result::ExecutionResult};

use crate::*;

pub mod nep145;
pub mod token;
pub mod tipping_bot;

pub use token::*;
pub use tipping_bot::*;
pub use nep145::*;

pub async fn transact_call<'a, 'b>(
  call_transaction: CallTransaction<'a, 'b>,
) -> ExecutionResult<String> {
  call_transaction
    .transact()
    .await
    .unwrap()
    .into_result()
    .unwrap()
}

pub fn get_wasm(file_name: &str) -> Result<Vec<u8>, Error> {
  std::fs::read(Path::new(OUT_DIR).join(file_name))
}

pub async fn create_user_account(tla: &Account, account_id: &str) -> Account {
  tla
    .create_subaccount(account_id)
    .initial_balance(USER_ACCOUNT_BALANCE)
    .transact()
    .await
    .unwrap()
    .unwrap()
}

pub async fn deploy_contract(tla: &Account, account_id: &str, wasm: &Vec<u8>) -> Contract {
  let contract_account = tla
    .create_subaccount(account_id)
    .initial_balance(CONTRACT_ACCOUNT_BALANCE)
    .transact()
    .await
    .unwrap()
    .unwrap();

  contract_account.deploy(wasm).await.unwrap().unwrap()
}

pub async fn deploy_contract_from_wasm_path(
  tla: &Account,
  account_id: &str,
  wasm_path: &str,
) -> Contract {
  let wasm = get_wasm(wasm_path).unwrap();
  deploy_contract(&tla, account_id, &wasm).await
}

pub async fn time_travel(worker: &Worker<Sandbox>, seconds_to_advance: u64) -> anyhow::Result<()> {
  let blocks_to_advance = (seconds_to_advance * TO_NANO) / AVERAGE_BLOCK_TIME;
  worker.fast_forward(blocks_to_advance).await?;
  anyhow::Ok(())
}

'''
'''--- packages/contract/tests/src/methods/nep145.rs ---
use serde_json::json;
use workspaces::{Account, Contract, result::ExecutionResult};

use crate::*;

pub async fn storage_withdraw(
  contract: &Contract,
  account: &Account,
  amount: Option<u128>,
) -> ExecutionResult<String> {
  transact_call(
    account
      .call(contract.as_account().id(), "storage_withdraw")
      .args_json(json!({ "amount": amount.map(|a| a.to_string()) }))
      .deposit(1)
      .gas(GAS_LIMIT),
  )
  .await
}

pub async fn storage_unregister(contract: &Contract, account: &Account) -> ExecutionResult<String> {
  transact_call(
    account
      .call(contract.as_account().id(), "storage_unregister")
      .args_json(json!({ "force": false }))
      .deposit(1)
      .gas(GAS_LIMIT),
  )
  .await
}

pub async fn bulk_register_storage(
  accounts: Vec<&Account>,
  contracts: Vec<&Contract>,
) -> anyhow::Result<()> {
  let mut batch = Vec::new();
  for account in accounts.into_iter() {
    for contract in contracts.iter() {
      batch.push(
        account
          .call(contract.id(), "storage_deposit")
          .args_json(json!({
            "account_id": account.id(),
            "registration_only": false,
          }))
          .deposit(parse_near!("1 N"))
          .transact(),
      );
    }
  }
  try_join_all(batch).await?;
  anyhow::Ok(())
}

'''
'''--- packages/contract/tests/src/methods/tipping_bot.rs ---
use serde::{Serialize, Deserialize};
use serde_json::json;
use workspaces::result::ExecutionResult;

use crate::*;

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq, Clone)]
pub struct RankingItem {
    pub user: String,
    pub amount: String,
}

#[derive(Serialize, Deserialize, Debug, PartialEq, Eq)]
pub struct LastTransactionsItem {
    pub sender: String,
    pub receiver: String,
    pub coin: String,
    pub amount: String,
}

pub async fn initialize_tipping_bot(
    sender: &Account,
    contract: &Contract,
    owner: &Account
) -> ExecutionResult<String> {
    transact_call(
        sender
          .call(contract.id(), "new")
          .args_json(json!({
            "owner_id": owner.id(),
          }))
          .gas(GAS_LIMIT),
      )
      .await
}

pub async fn transfer_tip_near(
    sender: &Account,
    contract: &Contract,
    receiver: &Account,
    sender_discord: String,
    receiver_discord: String,
    server_discord: String,
    amount: u128
) -> ExecutionResult<String> {
    transact_call(
        sender
          .call(contract.id(), "transfer_payment")
          .args_json(json!({
            "receiver": receiver.id(),
            "sender_discord": sender_discord,
            "receiver_discord": receiver_discord,
            "server_discord": server_discord,
          }))
          .deposit(amount)
          .gas(GAS_LIMIT),
      )
      .await
}

pub async fn transfer_tip_nep141(
    sender: &Account,
    contract: &Contract,
    token_contract: &Contract,
    receiver: &Account,
    sender_discord: String,
    receiver_discord: String,
    server_discord: String,
    amount: u128
) -> ExecutionResult<String> {
    transact_call(
        sender
          .call(token_contract.id(), "ft_transfer_call")
          .args_json(json!({
            "receiver_id": contract.id(),
            "amount": amount.to_string(),
            "memo": null,
            "msg": json!({
                "receiver": receiver.id(),
                "sender_discord": sender_discord,
                "receiver_discord": receiver_discord,
                "server_discord": server_discord,
            }).to_string()
          }))
          .deposit(1)
          .gas(GAS_LIMIT),
      )
      .await
}

pub async fn view_history(
    contract: &Contract,
    user: String,
    server: String,
    coin: String,
) -> anyhow::Result<String> {
    anyhow::Ok(
        contract
          .view(
            "view_history",
            json!({
                "user": user,
                "server": server,
                "coin": coin,
            })
            .to_string()
            .into_bytes(),
          )
          .await?
          .json()?,
      )
}

pub async fn view_last_server_tips(
    contract: &Contract,
    server: String,
) -> anyhow::Result<Vec<LastTransactionsItem>> {
    anyhow::Ok(
        contract
          .view(
            "view_last_server_tips",
            json!({
                "server": server,
            })
            .to_string()
            .into_bytes(),
          )
          .await?
          .json()?,
      )
}

pub async fn view_ranking(
    contract: &Contract,
    server: String,
    coin: String,
) -> anyhow::Result<Vec<RankingItem>> {
    anyhow::Ok(
        contract
          .view(
            "view_ranking",
            json!({
                "server": server,
                "coin": coin,
            })
            .to_string()
            .into_bytes(),
          )
          .await?
          .json()?,
      )
}

'''
'''--- packages/contract/tests/src/methods/token.rs ---
use serde_json::json;
use workspaces::result::ExecutionResult;

use crate::*;

pub async fn ft_transfer(
  sender: &Account,
  contract: &Contract,
  receiver: &Account,
  amount: u128,
) -> ExecutionResult<String> {
  transact_call(
    sender
      .call(contract.id(), "ft_transfer")
      .args_json(json!({
        "receiver_id": receiver.id(),
        "amount": amount.to_string(),
        "memo": null,
      }))
      .deposit(1)
      .gas(GAS_LIMIT),
  )
  .await
}

pub async fn ft_transfer_call(
  sender: &Account,
  contract: &Contract,
  receiver: &Account,
  amount: u128,
  msg: String,
) -> ExecutionResult<String> {
  transact_call(
    sender
      .call(contract.id(), "ft_transfer_call")
      .args_json(json!({
        "receiver_id": receiver.id(),
        "amount": amount.to_string(),
        "memo": null,
        "msg": msg
      }))
      .deposit(1)
      .gas(GAS_LIMIT),
  )
  .await
}

pub async fn ft_balance_of(contract: &Contract, account: &Account) -> anyhow::Result<String> {
  anyhow::Ok(
    contract
      .view(
        "ft_balance_of",
        json!({
          "account_id": account.id()
        })
        .to_string()
        .into_bytes(),
      )
      .await?
      .json()?,
  )
}

pub async fn initialize_ft_contract(
  contract: &Contract,
  owner: &Account,
) -> ExecutionResult<String> {
  transact_call(contract.call("new").args_json(json!({
    "owner_id": owner.id(),
    "total_supply": "1000000000000000000000000000",
    "metadata": {
      "spec": "ft-1.0.0",
      "name": "name",
      "symbol": "NME",
      "icon": null,
      "reference": null,
      "reference_hash": null,
      "decimals": FT_DECIMALS,
    }
  })))
  .await
}

'''
'''--- packages/contract/tests/src/tests_launchpad/mod.rs ---
#[cfg(test)]
mod tests {

    use std::collections::HashMap;

    use crate::*;

    /// integration test happy case - normal listing
    /// aims to test full aplication fliw for a single listing
    /// 1. Initialize tipping-bot contract
    /// 2. Initialize sample NEP-141 contract to be used within tipping-bot
    /// 3. Fund 3 different accounts
    /// 4. Perform a large amount of transactions and
    ///    (a) assert that they work properly
    ///    (b) assert that analytics for them are generated correctly
    #[tokio::test]
    async fn test_normal_flow() -> anyhow::Result<()> {
        let worker: Worker<Sandbox> = workspaces::sandbox().await?;

        let root = worker.root_account().unwrap();

        // CREATE USER ACCOUNTS
        let owner = create_user_account(&root, "owner").await;
        let user_1 = create_user_account(&root, "user1").await;
        let user_2 = create_user_account(&root, "user2").await;
        let user_3 = create_user_account(&root, "user3").await;
        let user_4 = create_user_account(&root, "user4").await;
        let user_5 = create_user_account(&root, "user5").await;
        let user_6 = create_user_account(&root, "user6").await;
        let user_7 = create_user_account(&root, "user7").await;
        let user_8 = create_user_account(&root, "user8").await;
        let user_9 = create_user_account(&root, "user9").await;

        let dummy_receiver = create_user_account(&root, "receiver").await;

        // 1. Initialize tipping-bot contract
        let tipping_bot_wasm = get_wasm("near_tipping_bot.wasm")?;
        let tipping_bot = deploy_contract(&root, "tipping_bot", &tipping_bot_wasm).await;
        initialize_tipping_bot(&root, &tipping_bot, &owner).await;

        // 2. Initialize sample NEP-141 contract to be used within tipping-bot
        let ft_wasm = get_wasm("test_token.wasm")?;
        let ft_token = deploy_contract(&root, "ft_contract", &ft_wasm).await;
        initialize_ft_contract(&ft_token, &owner).await;

        // 3. Fund 3 different accounts
        bulk_register_storage(
            vec![
                &owner,
                &user_1,
                &user_2,
                &user_3,
                &user_4,
                &user_5,
                &user_6,
                &user_7,
                &user_8,
                &user_9,
                tipping_bot.as_account(),
                &dummy_receiver,
            ],
            vec![&ft_token],
        )
        .await?;

        ft_transfer(&owner, &ft_token, &user_1, FT_INITIAL_USER_BALANCE).await;
        ft_transfer(&owner, &ft_token, &user_2, FT_INITIAL_USER_BALANCE).await;
        ft_transfer(&owner, &ft_token, &user_3, FT_INITIAL_USER_BALANCE).await;
        ft_transfer(&owner, &ft_token, &user_4, FT_INITIAL_USER_BALANCE).await;
        ft_transfer(&owner, &ft_token, &user_5, FT_INITIAL_USER_BALANCE).await;
        ft_transfer(&owner, &ft_token, &user_6, FT_INITIAL_USER_BALANCE).await;
        ft_transfer(&owner, &ft_token, &user_7, FT_INITIAL_USER_BALANCE).await;
        ft_transfer(&owner, &ft_token, &user_8, FT_INITIAL_USER_BALANCE).await;
        ft_transfer(&owner, &ft_token, &user_9, FT_INITIAL_USER_BALANCE).await;

        // 4. Perform a large amount of transactions and
        //    (a) assert that they work properly
        //    (b) assert that analytics for them are generated correctly

        let transfers = [
          (&user_1, 10), 
          (&user_2, 11), 
          (&user_3, 30), 
          (&user_2, 12),
          (&user_4, 100),
          (&user_5, 70),
          (&user_6, 90),
          (&user_7, 500),
          (&user_8, 600),
          (&user_9, 10),
          (&user_9, 1000),
        ];

        let mut history: HashMap<String, u128> = HashMap::new();
        let mut previous_5: Vec<LastTransactionsItem> = vec![];

        for value in transfers {
            let user = value.0.id().to_string();
            let receiver = dummy_receiver.id().to_string();
            let server = "XsDfg".to_string();
            let token = "$NEAR".to_string();

            transfer_tip_near(
                value.0,
                &tipping_bot,
                &dummy_receiver,
                user.clone(),
                receiver.clone(),
                server.clone(),
                value.1,
            )
            .await;

            let previous_value = history.get(&user).unwrap_or(&0);
            history.insert(user.clone(), previous_value + value.1);

            previous_5.insert(
                0,
                LastTransactionsItem {
                    sender: user.clone(),
                    receiver: receiver.clone(),
                    coin: token.clone(),
                    amount: value.1.to_string(),
                },
            );

            if previous_5.len() > 5 {
                previous_5.pop();
            }

            let mut ranking: Vec<RankingItem> = vec![];
            for (key, value) in history.clone().into_iter() {
                let item = RankingItem {
                    user: key,
                    amount: value.to_string(),
                };

                if ranking.len() == 0 {
                    ranking.push(item);
                } else {
                    let mut index = 0;
                    let mut user_inserted = false;
                    while index < ranking.len() {
                        if value > ranking.get(index).unwrap().amount.parse::<u128>().unwrap() {
                            ranking.insert(index, item.clone());
                            user_inserted = true;
                            break;
                        }
                        index += 1;
                    }

                    if ranking.len() > 5 {
                        ranking.pop();
                    } else if ranking.len() < 5 && !user_inserted {
                        ranking.push(item);
                    }
                }
            }

            assert_eq!(
                view_history(&tipping_bot, user.clone(), server.clone(), token.clone()).await?,
                history.get(&user).unwrap_or(&0).to_string()
            );

            assert_eq!(
                view_last_server_tips(&tipping_bot, server.clone()).await?,
                previous_5
            );

            println!(
                "{:#?}",
                view_ranking(&tipping_bot, server.clone(), token.clone()).await?
            );
            println!("{:#?}", ranking);
            println!("-----------");

            assert_eq!(
                view_ranking(&tipping_bot, server.clone(), token.clone()).await?,
                ranking
            );
        }

        let mut history: HashMap<String, u128> = HashMap::new();

        for value in transfers {
            let user = value.0.id().to_string();
            let receiver = dummy_receiver.id().to_string();
            let server = "XsDfg".to_string();
            let token = ft_token.id().to_string();

            transfer_tip_nep141(
                value.0,
                &tipping_bot,
                &ft_token,
                &dummy_receiver,
                user.clone(),
                receiver.clone(),
                server.clone(),
                value.1,
            )
            .await;

            let previous_value = history.get(&user).unwrap_or(&0);
            history.insert(user.clone(), previous_value + value.1);

            previous_5.insert(
                0,
                LastTransactionsItem {
                    sender: user.clone(),
                    receiver: receiver.clone(),
                    coin: token.clone(),
                    amount: value.1.to_string(),
                },
            );

            if previous_5.len() > 5 {
                previous_5.pop();
            }

            let mut ranking: Vec<RankingItem> = vec![];
            for (key, value) in history.clone().into_iter() {
                let item = RankingItem {
                    user: key,
                    amount: value.to_string(),
                };

                if ranking.len() == 0 {
                    ranking.push(item);
                } else {
                    let mut index = 0;
                    let mut user_inserted = false;
                    while index < ranking.len() {
                        if value > ranking.get(index).unwrap().amount.parse::<u128>().unwrap() {
                            ranking.insert(index, item.clone());
                            user_inserted = true;
                            break;
                        }
                        index += 1;
                    }

                    if ranking.len() > 5 {
                        ranking.pop();
                    } else if ranking.len() < 5 && !user_inserted {
                        ranking.push(item);
                    }
                }
            }

            assert_eq!(
                view_history(&tipping_bot, user.clone(), server.clone(), token.clone()).await?,
                history.get(&user).unwrap_or(&0).to_string()
            );

            assert_eq!(
                view_last_server_tips(&tipping_bot, server.clone()).await?,
                previous_5
            );

            println!(
                "{:#?}",
                view_ranking(&tipping_bot, server.clone(), token.clone()).await?
            );
            println!("{:#?}", ranking);
            println!("-----------");

            assert_eq!(
                view_ranking(&tipping_bot, server.clone(), token.clone()).await?,
                ranking
            );
        }

        anyhow::Ok(())
    }
}

'''
'''--- packages/db/.gmrc.js ---
require("dotenv").config();

const LOCAL_ENV = {
  base: {
    user: "ntb",
    password: process.env.NTB_PASSWORD || "abacaba",
    host: "localhost",
    port: 5432,
    database: "ntb",
    tls: false,
  },
  shadow: {
    database: "ntb_shadow",
  },
  root: {
    user: "postgres",
    database: "postgres",
    password: process.env.POSTGRES_PASSWORD || "abacaba",
  },
};

// TODO: decide what to hard-code and what to use env vars for.
// I used the current production values as defaults for host & port and hard-coded the rest, except for secrets.
const PROD_ENV = {
  user: "ntb",
  password: process.env.NTB_PASSWORD,
  host:
    process.env.HOST || "ntb-prod-do-user-13083855-0.b.db.ondigitalocean.com",
  port: process.env.PORT || 25060,
  database: "ntb",
  tls: true,
  cert: "tls/do-ca.crt",
};

const buildQueryString = ({ tls, cert }) =>
  tls ? `?sslmode=verify-full&sslrootcert=${cert}` : "?sslmode=disable";

const buildConnectionString = ({
  user,
  password,
  host,
  port = 5432,
  database,
  tls,
  cert,
}) =>
  `postgresql://${user}:${password}@${host}:${port}/${database}${buildQueryString(
    { tls, cert }
  )}`;
const buildShadowConnectionString = ({ base, shadow }) =>
  buildConnectionString({ ...base, ...shadow });
const buildRootConnectionString = ({ base, root }) =>
  buildConnectionString({ ...base, ...root });

function buildEnvironmentConfiguration() {
  // TODO: we'll probably need different environments for local and remove development, so maybe NODE_ENV isn't ideal.
  switch (process.env.NODE_ENV) {
    case "development":
      return {
        connectionString: buildConnectionString(LOCAL_ENV.base),
        shadowConnectionString: buildShadowConnectionString(LOCAL_ENV),
        rootConnectionString: buildRootConnectionString(LOCAL_ENV),
      };
    case "production":
      return {
        connectionString: buildConnectionString(PROD_ENV),
      };
    default:
      throw new Error("Unrecognized environment");
  }
}

module.exports = {
  ...buildEnvironmentConfiguration(),

  /*
   * pgSettings: key-value settings to be automatically loaded into PostgreSQL
   * before running migrations, using an equivalent of `SET LOCAL <key> TO
   * <value>`
   */
  pgSettings: {
    // "search_path": "app_public,app_private,app_hidden,public",
  },

  /*
   * placeholders: substituted in SQL files when compiled/executed. Placeholder
   * keys should be prefixed with a colon and in all caps, like
   * `:COLON_PREFIXED_ALL_CAPS`. Placeholder values should be strings. They
   * will be replaced verbatim with NO ESCAPING AT ALL (this differs from how
   * psql handles placeholders) so should only be used with "safe" values. This
   * is useful for committing migrations where certain parameters can change
   * between environments (development, staging, production) but you wish to
   * use the same signed migration files for all.
   *
   * The special value "!ENV" can be used to indicate an environmental variable
   * of the same name should be used.
   *
   * Graphile Migrate automatically sets the `:DATABASE_NAME` and
   * `:DATABASE_OWNER` placeholders, and you should not attempt to override
   * these.
   */
  placeholders: {
    // ":DATABASE_VISITOR": "!ENV", // Uses process.env.DATABASE_VISITOR
  },
  /*
   * Actions allow you to run scripts or commands at certain points in the
   * migration lifecycle. SQL files are ran against the database directly.
   * "command" actions are ran with the following environmental variables set:
   *
   * - GM_DBURL: the PostgreSQL URL of the database being migrated
   * - GM_DBNAME: the name of the database from GM_DBURL
   * - GM_DBUSER: the user from GM_DBURL
   * - GM_SHADOW: set to 1 if the shadow database is being migrated, left unset
   *   otherwise
   *
   * If "shadow" is unspecified, the actions will run on events to both shadow
   * and normal databases. If "shadow" is true the action will only run on
   * actions to the shadow DB, and if false only on actions to the main DB.
   */
  /*
   * afterReset: actions executed after a `graphile-migrate reset` command.
   */
  afterReset: [
    // "afterReset.sql",
    // { "_": "command", "command": "graphile-worker --schema-only" },
  ],
  /*
   * afterAllMigrations: actions executed once all migrations are complete.
   */
  afterAllMigrations: [
    // {
    //   "_": "command",
    //   "shadow": true,
    //   "command": "if [ \"$IN_TESTS\" != \"1\" ]; then ./scripts/dump-db; fi",
    // },
  ],
  /*
   * afterCurrent: actions executed once the current migration has been
   * evaluated (i.e. in watch mode).
   */
  afterCurrent: [
    // {
    //   "_": "command",
    //   "shadow": true,
    //   "command": "if [ \"$IN_TESTS\" = \"1\" ]; then ./scripts/test-seed; fi",
    // },
  ],
  /*
   * blankMigrationContent: content to be written to the current migration
   * after commit. NOTE: this should only contain comments.
   */
  // "blankMigrationContent": "-- Write your migration here\n",
  /****************************************************************************\
  ***                                                                        ***
  ***         You probably don't want to edit anything below here.           ***
  ***                                                                        ***
  \****************************************************************************/
  /*
   * manageGraphileMigrateSchema: if you set this false, you must be sure to
   * keep the graphile_migrate schema up to date yourself. We recommend you
   * leave it at its default.
   */
  // "manageGraphileMigrateSchema": true,
  /*
   * migrationsFolder: path to the folder in which to store your migrations.
   */
  // migrationsFolder: "./migrations",
  "//generatedWith": "1.4.0",
};

'''
'''--- packages/db/README.md ---
# Database

This package contains the migrations needed in order to initialize the application's database.

## Migrations

They are located in the `migrations` folder and should be run sequentially in (lexicographical) order to achieve the correct state.

It's assumed they will run against a [Supabase](https://supabase.com/) schema, which already contains some functionality not native to Postgres (e.g. the `storage` schema).

When creating new migrations, keep them named appropriately, that is, with a serial numeric prefix, and underscore-separated (_) words.

'''
'''--- packages/db/migrations/committed/000001.sql ---
--! Previous: -
--! Hash: sha1:6836cdd2c8a9f0f20fb1ca671c9c390b726f222b

--! split: 0001-servers.sql
drop table if exists servers;
create table servers (
    id bigint primary key,
    name text not null 
);

--! split: 0002-tokens.sql
drop table if exists tokens;
create table tokens (
    id text not null primary key,
    metadata jsonb not null
);

--! split: 0003-server_tokens.sql
drop table if exists server_tokens;
create table server_tokens (
    server_id bigint not null references servers (id),
    token_id text not null references tokens (id),

    primary key (server_id, token_id)
);

--   As the server_id appears first on the table declaration, we would need a second
-- index if we want to search by token_id alone, e.g. 
-- create index index_server_tokens_token_id on server_tokens (token_id);

--! split: 0004-wallets.sql
drop table if exists wallets;
create table wallets (
    user_id bigint not null,
    server_id bigint not null references servers (id),
    wallet text not null,

    primary key (user_id, server_id)
);

--   As the user_id appears first on the table declaration, we would need a second
-- index if we want to search by server_id alone, e.g. 
-- create index index_wallets_server_id on wallets (server_id);

--! split: 0005-feedbacks.sql
drop table if exists feedbacks;
create table feedbacks (
    id uuid primary key default gen_random_uuid(),
    server_id bigint not null,
    user_id bigint not null,
    username text not null,
    message text not null,
    submitted_at timestamptz default now()
);

--! split: 0006-help.sql
drop table if exists help;
create table help (
    command text primary key,
    message text not null
);

'''
'''--- packages/db/migrations/current/1-current.sql ---
-- Enter migration here

'''
'''--- packages/db/package.json ---
{
  "name": "@near/db",
  "version": "1.0.0",
  "license": "UNLICENSED",
  "private": true,
  "scripts": {
    "gm": "graphile-migrate",
    "commit": "yarn run gm commit",
    "uncommit": "yarn run gm uncommit",
    "seed": "yarn run gm run src/seeds.sql",
    "migrate": "yarn run gm migrate"
  },
  "devDependencies": {
    "graphile-migrate": "^1.4.0"
  }
}

'''
'''--- packages/db/src/init.sh ---
#!/bin/bash
set -e

psql -v ON_ERROR_STOP=1 --username "$POSTGRES_USER" --dbname "$POSTGRES_DB" <<-EOSQL
	create user ntb createdb encrypted password '${NTB_PASSWORD}';
    create database ntb with owner = ntb;
    create database ntb_shadow with owner = ntb;
EOSQL

'''
'''--- packages/db/src/seeds.sql ---
insert into help (command, message) values
    (
        'addtoken',
        'This command is used to add a new token to your server''s token list. To use simply select a token from the list of available tokens and send the command.'
    ),
    (
        'alltokens',
        'This command is only for listing all tokens in your server''s token list. To use just select it, send the command and a list of tokens will be displayed to you.'
    ),
    (
        'commands',
        'This command is used to list all available bot commands. To use just select it, send the command and a list of commands will be displayed to you.'
    ),
    (
        'feedback',
        'This command is to send feedback to our team of developers. To use just select the command, enter your message and send the command, with this your feedback will be sent to our team.'
    ),
    (
        'newtoken',
        'This command is to make a request to add a token of interest to our token list if the token is not already in the list. To use, select the command, so you will open a modal with two fields for you to fill, the name of the token you want, and the near address of the same. After sending, your request will arrive to our team and will be analyzed.'
    ),
    (
        'register',
        'This command serves to register your server in our bot and be able to use the commands freely. It is quite simple to use, just select it and send the command that your server will be registered in the bot if it is not yet.'
    ),
    (
        'removetoken',
        'This command is used to remove a token from the token list from your server. To use simply select the token you want to remove from the list and send the command.'
    ),
    (
        'send',
        'This command is used to make transfers between server users. To use it you must select the token you want, inform the quantity and finally inform which user you want to transfer to.'
    ),
    (
        'setwallet',
        'This command is used to set your wallet in our bot so that you can receive transfers. To use just select the command and send.'
    ),
    (
        'verifywallet',
        'This command serves to verify that you already have a registered wallet in the bot. To use simply select the command, send it and then a message will be displayed whether or not you have a registered wallet.'
    ),
    (
        'tutorial',
        'This command serves to instruct how to use the bot to send tips.'
    ),
    (
        'helpinstall',
        'This command serves to instruct how to configure the bot on your server.'
    )
;

insert into tokens (id, metadata) values
    (
        'near',
        '{ "spec": "ft-1.0.0", "name": "Near", "symbol": "NEAR", "icon": "", "reference": "", "reference_hash": "", "decimals": 24 }'
    ),
    (
        'aaaaaa20d9e0e2461697782ef11675f668207961.factory.bridge.near',
        '{ "spec": "ft-1.0.0", "name": "Aurora", "symbol": "AURORA", "icon": "", "reference": "", "reference_hash": "", "decimals": 18 }'
    ),
    (
        'ftv2.nekotoken.near',
        '{ "spec": "ft-1.0.0", "name": "NEKO", "symbol": "NEKO", "icon": "", "reference": null, "reference_hash": null, "tax_rate": 0, "decimals": 24 }'
    ),
    (
        'token.sweat',
        '{ "spec": "ft-1.0", "name": "SWEAT", "symbol": "SWEAT", "icon": "", "reference": null, "reference_hash": null, "decimals": 18 }'
    ),
    (
        '2260fac5e5542a773aa44fbcfedf7c193bc2c599.factory.bridge.near',
        '{ "spec": "ft-1.0.0", "name": "Wrapped BTC", "symbol": "WBTC", "icon": "", "reference": "", "reference_hash": "", "decimals": 8 }'
    ),
    (
        'c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.factory.bridge.near',
        '{ "spec": "ft-1.0.0", "name": "Wrapped Ether", "symbol": "WETH", "icon": null, "reference": "", "reference_hash": "", "decimals": 18 }'
    ),
    (
        'utopia.secretskelliessociety.near',
        '{ "spec": "ft-1.0.0", "name": "Utopia", "symbol": "UTO", "icon": "", "reference": null, "reference_hash": null, "decimals": 8 }'
    ),
    (
        'token.v2.ref-finance.near',
        '{ "spec": "ft-1.0.0", "name": "Ref Finance Token", "symbol": "REF", "icon": "", "reference": null, "reference_hash": null, "decimals": 18 }'
    ),
    (
        'f5cfbc74057c610c8ef151a439252680ac68c6dc.factory.bridge.near',
        '{ "spec": "ft-1.0.0", "name": "Octopus Network Token", "symbol": "OCT", "icon": "", "reference": "", "reference_hash": "", "decimals": 18 }'
    ),
    (
        'sol.token.a11bd.near',
        '{ "spec": "ft-1.0.0", "name": "Solana", "symbol": "SOL", "icon": "", "reference": null, "reference_hash": null, "decimals": 24 }'
    ),
    (
        'dac17f958d2ee523a2206206994597c13d831ec7.factory.bridge.near',
        '{ "spec": "ft-1.0.0", "name": "Tether USD", "symbol": "USDT.e", "icon": "", "reference": "", "reference_hash": "", "decimals": 6 }'
    ),
    (
        'meta-pool.near',
        '{ "spec": "ft-1.0.0", "name": "Staked NEAR", "symbol": "STNEAR", "icon": "", "reference": "https://metapool.app", "reference_hash": null, "decimals": 24 }'
    ),
    (
        'token.pembrock.near',
        '{ "spec": "ft-1.0.0", "name": "PembRock", "symbol": "PEM", "icon": "", "reference": null, "reference_hash": null, "decimals": 18 }'
    ),
    (
        'a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48.factory.bridge.near',
        '{ "spec": "ft-1.0.0", "name": "USD Coin", "symbol": "USDC.e", "icon": "", "reference": "", "reference_hash": "", "decimals": 6 }'
    ),
    (
        '6b175474e89094c44da98b954eedeac495271d0f.factory.bridge.near',
        '{ "spec": "ft-1.0.0", "name": "Dai Stablecoin", "symbol": "DAI", "icon": "", "reference": "", "reference_hash": "", "decimals": 18 }'
    )
;

'''
'''--- packages/front/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/public/images/favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link rel="stylesheet" href="https://www.w3schools.com/w3css/4/w3.css" />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@100;200;300;400;500;600;700;800;900&display=swap"
      rel="stylesheet"
    />
    <link rel="prerender" as="image" href="./images/main-bg.jpg"/>
    <link rel="prerender" as="image" href="./images/wave_tipping_bot.png"/>
    <link rel="prerender" as="image" href="./images/tipping_bot_logo.png"/>

    <title>Peter Tipping Bot</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

'''
'''--- packages/front/package.json ---
{
  "name": "@near/front",
  "private": true,
  "version": "0.0.0",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "preview": "vite preview"
  },
  "engines": {
    "yarn": ">=1.22.0 <2.0.0",
    "node": ">=17.5.0"
  },
  "dependencies": {
    "@esbuild-plugins/node-globals-polyfill": "^0.1.1",
    "@headlessui/react": "^1.6.6",
    "@heroicons/react": "^2.0.4",
    "@near-wallet-selector/core": "^7.5.0",
    "@near-wallet-selector/meteor-wallet": "^7.5.0",
    "@near-wallet-selector/near-wallet": "^7.5.0",
    "@near-wallet-selector/sender": "^7.5.0",
    "@types/react-highlight-words": "^0.16.4",
    "autoprefixer": "^10.4.7",
    "big.js": "^6.2.1",
    "bn.js": "^5.2.1",
    "buffer": "^6.0.3",
    "near-api-js": "^0.44.2",
    "postcss": "^8.4.13",
    "react": "^18.0.0",
    "react-copy-to-clipboard": "^5.1.0",
    "react-dom": "^18.0.0",
    "react-highlight-words": "^0.18.0",
    "react-near": "^3.4.8",
    "react-router": "^6.3.0",
    "react-router-dom": "^6.3.0",
    "rxjs": "^7.8.0",
    "tailwind-merge": "^1.8.0",
    "tailwindcss": "^3.0.24",
    "use-mediaquery": "^1.0.1",
    "vite-plugin-pages": "^0.25.0"
  },
  "devDependencies": {
    "@types/big.js": "^6.1.6",
    "@types/react": "^18.0.0",
    "@types/react-dom": "^18.0.0",
    "@vitejs/plugin-react": "^1.3.0",
    "@vitejs/plugin-react-refresh": "^1.3.6",
    "buffer": "^6.0.3",
    "typescript": "^4.6.3",
    "vite": "^2.9.7",
    "vite-compatible-readable-stream": "^3.6.1"
  }
}

'''
'''--- packages/front/postcss.config.js ---
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

'''
'''--- packages/front/public/assets/hero-glow.svg ---
<svg fill="none" height="1602" viewBox="0 0 2769 1602" width="2769" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><filter id="a" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse" height="1044" width="1044" x="1682" y="558"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feBlend in="SourceGraphic" in2="BackgroundImageFix" mode="normal" result="shape"/><feGaussianBlur result="effect1_foregroundBlur" stdDeviation="100"/></filter><filter id="b" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse" height="1044" width="1044" x="1725" y="0"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feBlend in="SourceGraphic" in2="BackgroundImageFix" mode="normal" result="shape"/><feGaussianBlur result="effect1_foregroundBlur" stdDeviation="100"/></filter><filter id="c" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse" height="858" width="982" x="0" y="23"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feBlend in="SourceGraphic" in2="BackgroundImageFix" mode="normal" result="shape"/><feGaussianBlur result="effect1_foregroundBlur" stdDeviation="100"/></filter><filter id="d" color-interpolation-filters="sRGB" filterUnits="userSpaceOnUse" height="646" width="982" x="279" y="58"><feFlood flood-opacity="0" result="BackgroundImageFix"/><feBlend in="SourceGraphic" in2="BackgroundImageFix" mode="normal" result="shape"/><feGaussianBlur result="effect1_foregroundBlur" stdDeviation="100"/></filter><g filter="url(#a)" opacity=".34"><circle cx="2204" cy="1080" fill="#db469f" r="322"/></g><g filter="url(#b)" opacity=".7"><circle cx="2247" cy="522" fill="#043a8a" r="322"/></g><g filter="url(#c)" opacity=".9"><ellipse cx="491" cy="452" fill="#043a8a" rx="291" ry="229"/></g><g filter="url(#d)" opacity=".43"><ellipse cx="770" cy="381" fill="#043a8a" rx="291" ry="123"/></g></svg>

'''
'''--- packages/front/public/assets/logo.svg ---
<svg width="215" height="48" viewBox="0 0 215 48" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M70.088 19.8V31H73.096V27.88H74.552C77.032 27.88 78.632 26.296 78.632 23.848C78.632 21.384 77.032 19.8 74.552 19.8H70.088ZM73.064 25.208V22.536H74.264C75.128 22.536 75.624 23.064 75.624 23.88C75.624 24.68 75.128 25.208 74.264 25.208H73.064ZM82.9703 26.68H86.9862V24.104H82.9703V22.424H87.3223V19.8H79.9943V31H87.4503V28.328H82.9703V26.68ZM88.5079 19.8V22.552H91.3239V31H94.3479V22.552H97.1479V19.8H88.5079ZM101.564 26.68H105.58V24.104H101.564V22.424H105.916V19.8H98.588V31H106.044V28.328H101.564V26.68ZM114.158 26.84C115.534 26.312 116.318 25.128 116.318 23.528C116.318 21.224 114.734 19.8 112.11 19.8H107.854V31H110.846V27.032L113.502 31H116.798V30.664L114.158 26.84ZM110.83 22.552H112.03C112.846 22.552 113.326 22.984 113.326 23.768C113.326 24.552 112.846 24.968 112.03 24.968H110.83V22.552Z" fill="white"/>
<path d="M121.524 19.8V22.552H124.34V31H127.364V22.552H130.164V19.8H121.524ZM132.948 21.816C133.876 21.816 134.548 21.192 134.548 20.312C134.548 19.432 133.876 18.808 132.948 18.808C132.004 18.808 131.348 19.432 131.348 20.312C131.348 21.192 132.004 21.816 132.948 21.816ZM134.372 31V22.52H131.54V31H134.372ZM141.519 22.344C140.495 22.344 139.583 22.696 138.879 23.272L138.783 22.52H136.399V33.672H139.231V30.504C139.887 30.936 140.671 31.176 141.519 31.176C144.047 31.176 145.695 29.224 145.695 26.76C145.695 24.184 143.951 22.344 141.519 22.344ZM141.039 28.616C139.967 28.616 139.199 27.848 139.199 26.76C139.199 25.672 139.967 24.904 141.039 24.904C142.111 24.904 142.879 25.672 142.879 26.76C142.879 27.848 142.111 28.616 141.039 28.616ZM152.316 22.344C151.292 22.344 150.38 22.696 149.676 23.272L149.58 22.52H147.196V33.672H150.028V30.504C150.684 30.936 151.468 31.176 152.316 31.176C154.844 31.176 156.492 29.224 156.492 26.76C156.492 24.184 154.748 22.344 152.316 22.344ZM151.836 28.616C150.764 28.616 149.996 27.848 149.996 26.76C149.996 25.672 150.764 24.904 151.836 24.904C152.908 24.904 153.676 25.672 153.676 26.76C153.676 27.848 152.908 28.616 151.836 28.616ZM159.401 21.816C160.329 21.816 161.001 21.192 161.001 20.312C161.001 19.432 160.329 18.808 159.401 18.808C158.457 18.808 157.801 19.432 157.801 20.312C157.801 21.192 158.457 21.816 159.401 21.816ZM160.825 31V22.52H157.993V31H160.825ZM168.148 22.36C167.108 22.36 166.18 22.744 165.556 23.48L165.46 22.52H162.852V31H165.684V26.392C165.684 25.432 166.292 24.888 167.22 24.888C168.052 24.888 168.516 25.4 168.516 26.344V31H171.364V26.024C171.364 23.816 170.34 22.36 168.148 22.36ZM179.338 23.224C178.65 22.648 177.77 22.328 176.762 22.328C174.442 22.328 172.73 24.104 172.73 26.424C172.73 28.808 174.474 30.44 176.762 30.44C177.61 30.44 178.378 30.216 179.002 29.816V30.024C179.002 31.032 178.218 31.528 177.178 31.528C176.474 31.528 175.882 31.304 175.738 30.76H173.002C173.226 32.904 174.954 33.88 177.274 33.88C179.898 33.88 181.818 32.44 181.818 29.608V22.52H179.434L179.338 23.224ZM177.274 28.168C176.218 28.168 175.546 27.464 175.546 26.488C175.546 25.512 176.218 24.824 177.274 24.824C178.33 24.824 179.018 25.512 179.018 26.488C179.018 27.464 178.33 28.168 177.274 28.168ZM195.334 25.096C195.99 24.568 196.374 23.752 196.374 22.84C196.374 21.016 195.014 19.8 193.03 19.8H188.166V31H193.11C195.366 31 196.822 29.704 196.822 27.784C196.822 26.648 196.262 25.656 195.334 25.096ZM192.55 22.264C193.174 22.264 193.526 22.6 193.526 23.176C193.526 23.736 193.174 24.056 192.55 24.056H191.03V22.264H192.55ZM191.03 28.424V26.408H192.854C193.478 26.408 193.846 26.792 193.846 27.416C193.846 28.024 193.478 28.424 192.854 28.424H191.03ZM202.354 31.192C205.058 31.192 207.01 29.336 207.01 26.76C207.01 24.168 205.058 22.328 202.354 22.328C199.65 22.328 197.698 24.168 197.698 26.76C197.698 29.336 199.65 31.192 202.354 31.192ZM202.354 28.616C201.314 28.616 200.53 27.848 200.53 26.76C200.53 25.672 201.314 24.904 202.354 24.904C203.41 24.904 204.178 25.672 204.178 26.76C204.178 27.848 203.41 28.616 202.354 28.616ZM213.056 28.744C212.288 28.744 211.856 28.488 211.856 27.64V24.856H213.728V22.52H211.856V20.504L209.008 20.792V22.52H207.616V24.856H209.008V28.04C209.008 30.2 210.288 31.176 212.24 31.176C212.736 31.176 213.264 31.112 213.84 31V28.696C213.568 28.728 213.296 28.744 213.056 28.744Z" fill="#6D71FF"/>
<circle cx="23.9841" cy="24.0159" r="23.9841" transform="rotate(-90 23.9841 24.0159)" fill="url(#paint0_linear_560_50)"/>
<mask id="mask0_560_50" style="mask-type:alpha" maskUnits="userSpaceOnUse" x="0" y="0" width="48" height="48">
<circle cx="24.0159" cy="23.9842" r="23.9841" transform="rotate(-90 24.0159 23.9842)" fill="url(#paint1_linear_560_50)"/>
</mask>
<g mask="url(#mask0_560_50)">
<rect x="23.1897" y="16.2021" width="0.869142" height="3.15064" rx="0.434571" fill="#C2C4FF"/>
<g filter="url(#filter0_i_560_50)">
<circle cx="38.5083" cy="28.9133" r="3.58521" fill="#6D71FF"/>
</g>
<circle cx="9.06629" cy="28.9133" r="3.58521" fill="#6D71FF"/>
<circle cx="23.6244" cy="22.5032" r="3.58521" fill="#6D71FF"/>
<g filter="url(#filter1_i_560_50)">
<rect x="8.0885" y="20.5479" width="31.1805" height="16.8396" rx="8.41982" fill="white"/>
</g>
<rect x="8.22011" y="20.6795" width="30.9173" height="16.5764" rx="8.28821" stroke="#797CFF" stroke-width="0.263223"/>
<g filter="url(#filter2_f_560_50)">
<ellipse cx="31.2294" cy="29.0222" rx="5.21485" ry="5.3235" fill="#C6C7FF" fill-opacity="0.8"/>
</g>
<g filter="url(#filter3_f_560_50)">
<ellipse cx="16.1824" cy="31.0321" rx="4.50868" ry="4.72596" fill="#C6C7FF" fill-opacity="0.8"/>
</g>
<g filter="url(#filter4_i_560_50)">
<rect x="11.6737" y="23.8071" width="24.0101" height="10.3211" rx="5.16053" fill="#DEDFFF"/>
</g>
<rect x="11.8053" y="23.9387" width="23.7468" height="10.0578" rx="5.02892" stroke="#6D71FF" stroke-width="0.263223"/>
<circle cx="17.0515" cy="28.9677" r="1.03211" fill="#6D71FF"/>
<circle cx="30.0886" cy="28.9677" r="1.03211" fill="#6D71FF"/>
<circle cx="23.6786" cy="14.4095" r="1.03211" fill="#6D71FF"/>
<circle cx="24.2218" cy="14.0834" r="0.162964" fill="#DEDFFF"/>
<path d="M21.7775 30.543C21.8636 31.8636 25.0298 32.1141 25.4713 30.543" stroke="#6D71FF" stroke-width="1.05289" stroke-linecap="round"/>
<g filter="url(#filter5_i_560_50)">
<path d="M30.7538 55.3556C27.7539 60.5517 20.2539 60.5517 17.2539 55.3556L14.2415 50.138C11.2415 44.9418 14.9915 38.4467 20.9915 38.4467L27.0162 38.4467C33.0162 38.4467 36.7662 44.9418 33.7662 50.138L30.7538 55.3556Z" fill="#FDFDFF"/>
</g>
<path d="M30.6399 55.2898C27.6905 60.3982 20.3172 60.3981 17.3679 55.2897L14.3555 50.0722C11.4062 44.9638 15.0928 38.5783 20.9915 38.5783L27.0162 38.5783C32.9149 38.5783 36.6016 44.9638 33.6522 50.0722L30.6399 55.2898Z" stroke="#6D71FF" stroke-width="0.263223"/>
</g>
<path d="M37.9777 12.8409C38.0199 12.6966 38.2243 12.6966 38.2665 12.8409L38.8847 14.955C38.8991 15.0043 38.9377 15.0428 38.9869 15.0572L41.101 15.6754C41.2453 15.7176 41.2453 15.922 41.101 15.9642L38.9869 16.5825C38.9377 16.5969 38.8991 16.6354 38.8847 16.6847L38.2665 18.7988C38.2243 18.9431 38.0199 18.9431 37.9777 18.7988L37.3594 16.6847C37.345 16.6354 37.3065 16.5969 37.2573 16.5825L35.1432 15.9642C34.9989 15.922 34.9989 15.7176 35.1432 15.6754L37.2573 15.0572C37.3065 15.0428 37.345 15.0043 37.3594 14.955L37.9777 12.8409Z" fill="white"/>
<path d="M19.3797 4.19784C19.4219 4.05356 19.6263 4.05356 19.6685 4.19784L20.2867 6.31195C20.3011 6.3612 20.3396 6.39971 20.3889 6.41411L22.503 7.03238C22.6473 7.07457 22.6473 7.27897 22.503 7.32116L20.3889 7.93943C20.3396 7.95383 20.3011 7.99234 20.2867 8.04159L19.6685 10.1557C19.6263 10.3 19.4219 10.3 19.3797 10.1557L18.7614 8.04159C18.747 7.99234 18.7085 7.95383 18.6592 7.93943L16.5451 7.32116C16.4008 7.27897 16.4008 7.07457 16.5451 7.03238L18.6592 6.41411C18.7085 6.39971 18.747 6.3612 18.7614 6.31195L19.3797 4.19784Z" fill="white"/>
<path d="M9.55321 14.286C9.58041 14.193 9.71213 14.193 9.73932 14.286L10.1378 15.6484C10.147 15.6801 10.1719 15.7049 10.2036 15.7142L11.566 16.1127C11.659 16.1399 11.659 16.2716 11.566 16.2988L10.2036 16.6972C10.1719 16.7065 10.147 16.7313 10.1378 16.763L9.73932 18.1255C9.71213 18.2185 9.58041 18.2185 9.55321 18.1255L9.15478 16.763C9.14549 16.7313 9.12068 16.7065 9.08894 16.6972L7.72651 16.2988C7.63353 16.2716 7.63353 16.1399 7.72651 16.1127L9.08894 15.7142C9.12068 15.7049 9.14549 15.6801 9.15478 15.6484L9.55321 14.286Z" fill="white"/>
<defs>
<filter id="filter0_i_560_50" x="34.9231" y="25.3281" width="7.17041" height="7.17041" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dx="-1.31611" dy="1.05289"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.85 0 0 0 0 0.85411 0 0 0 0 1 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_560_50"/>
</filter>
<filter id="filter1_i_560_50" x="8.0885" y="20.5479" width="31.1805" height="16.8398" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dx="1.31611" dy="0.789669"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.427451 0 0 0 0 0.443137 0 0 0 0 1 0 0 0 0.29 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_560_50"/>
</filter>
<filter id="filter2_f_560_50" x="12.8534" y="10.5376" width="36.752" height="36.9693" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feGaussianBlur stdDeviation="6.58058" result="effect1_foregroundBlur_560_50"/>
</filter>
<filter id="filter3_f_560_50" x="-1.48744" y="13.145" width="35.3396" height="35.7745" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feGaussianBlur stdDeviation="6.58058" result="effect1_foregroundBlur_560_50"/>
</filter>
<filter id="filter4_i_560_50" x="11.6737" y="23.8071" width="24.01" height="10.3213" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dx="1.05289" dy="1.57934"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_560_50"/>
</filter>
<filter id="filter5_i_560_50" x="13.1857" y="38.4468" width="21.6364" height="20.8057" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
<feFlood flood-opacity="0" result="BackgroundImageFix"/>
<feBlend mode="normal" in="SourceGraphic" in2="BackgroundImageFix" result="shape"/>
<feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0" result="hardAlpha"/>
<feOffset dx="-5.26446" dy="0.526446"/>
<feComposite in2="hardAlpha" operator="arithmetic" k2="-1" k3="1"/>
<feColorMatrix type="matrix" values="0 0 0 0 0.427451 0 0 0 0 0.443137 0 0 0 0 1 0 0 0 0.45 0"/>
<feBlend mode="normal" in2="shape" result="effect1_innerShadow_560_50"/>
</filter>
<linearGradient id="paint0_linear_560_50" x1="23.9841" y1="0.0318508" x2="23.9841" y2="48" gradientUnits="userSpaceOnUse">
<stop stop-color="#A5D9FF"/>
<stop offset="1" stop-color="#AB80FF"/>
</linearGradient>
<linearGradient id="paint1_linear_560_50" x1="24.0159" y1="0.000112534" x2="24.0159" y2="47.9683" gradientUnits="userSpaceOnUse">
<stop stop-color="#A5D9FF"/>
<stop offset="1" stop-color="#AB80FF"/>
</linearGradient>
</defs>
</svg>

'''
'''--- packages/front/public/assets/tokens/aurora.svg ---
"data:image/svg+xml,%3Csvg version='1.1' id='Layer_1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' x='0px' y='0px' viewBox='0 0 288 288' style='enable-background:new 0 0 288 288;' xml:space='preserve'%3E %3Cstyle type='text/css'%3E .st0%7Bfill:%2370D44B;%7D .st1%7Bfill:%23FFFFFF;%7D %3C/style%3E %3Cpath class='st0' d='M144,0L144,0c79.5,0,144,64.5,144,144v0c0,79.5-64.5,144-144,144h0C64.5,288,0,223.5,0,144v0 C0,64.5,64.5,0,144,0z'/%3E %3Cpath class='st1' d='M144,58.8c7.6,0,14.5,4.3,17.9,11.1l56.2,112.5c4.9,9.9,0.9,21.9-9,26.8c-2.8,1.4-5.8,2.1-8.9,2.1H87.8 c-11,0-20-9-20-20c0-3.1,0.7-6.2,2.1-8.9l56.2-112.5C129.5,63,136.4,58.7,144,58.8 M144,45c-12.8,0-24.5,7.2-30.2,18.7L57.6,176.2 c-8.3,16.7-1.6,36.9,15.1,45.3c4.7,2.3,9.9,3.6,15.1,3.6h112.5c18.6,0,33.8-15.1,33.8-33.7c0-5.2-1.2-10.4-3.6-15.1L174.2,63.7 C168.5,52.2,156.8,45,144,45z'/%3E %3C/svg%3E"

'''
'''--- packages/front/public/logo-black.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
  <linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81">
    <stop offset=".21" stop-color="#24272a" />
    <stop offset=".42" stop-color="#24272a" stop-opacity="0" />
    <stop offset=".59" stop-color="#24272a" stop-opacity="0" />
    <stop offset=".81" stop-color="#24272a" />
  </linearGradient>
  <path
    d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z"
    fill="url(#a)" />
  <path
    d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z"
    fill="#24272a" />
</svg>
'''
'''--- packages/front/public/logo-white.svg ---
<svg viewBox="0 0 288 288" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"><linearGradient id="a" gradientUnits="userSpaceOnUse" x1="76.81" x2="211.16" y1="211.17" y2="76.81"><stop offset=".21" stop-color="#fff"/><stop offset=".42" stop-color="#fff" stop-opacity="0"/><stop offset=".59" stop-color="#fff" stop-opacity="0"/><stop offset=".81" stop-color="#fff"/></linearGradient><path d="m88.46 216a16.45 16.45 0 0 0 12.46-5.71l112.56-130.57a16.42 16.42 0 0 0 -13.94-7.72 16.46 16.46 0 0 0 -12.41 5.65l-113.13 129.8a16.46 16.46 0 0 0 14.46 8.55z" fill="url(#a)"/><path d="m88.46 216a16.46 16.46 0 0 0 7.54-1.83v-109l87.45 104.94a16.44 16.44 0 0 0 12.64 5.89h3.45a16.46 16.46 0 0 0 16.46-16.46v-111.08a16.46 16.46 0 0 0 -16.46-16.46 16.36 16.36 0 0 0 -7.54 1.81v109.05l-87.45-104.94a16.44 16.44 0 0 0 -12.64-5.92h-3.45a16.46 16.46 0 0 0 -16.46 16.46v111.08a16.46 16.46 0 0 0 16.46 16.46z" fill="#fff"/></svg>
'''
'''--- packages/front/src/components/assets/index.ts ---
export * from "./discord";
export * from "./twitter";
export * from "./robotIcon";

'''
'''--- packages/front/src/components/index.ts ---
export * from "./app";
export * from "./header";
export * from "./navbar";
export * from "./footer";
export * from "./available-tokens";
export * from "./highlight-text";
export * from "./link-button";
export * from "./section";
export * from "./button";
export * from "./assets";
export * from "./title";
export * from "./text";
export * from "./tutorial-card";
export * from "./space";
export * from "./divider";

'''
'''--- packages/front/src/components/loadingtransaction/index.ts ---
export * from "./loading-transaction";

'''
'''--- packages/front/src/index.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  width: 100vw;
  height: 100vh;
  font-family: 'Inter', sans-serif;
  background-color: #040d21;
}

body .ntb-space__stars {
  will-change: opacity, transform;
}

.ntb-space {
  background-size: 400% 250%, 100% 100%;
  background-position: 50% 50%;
  background-repeat: no-repeat, repeat;
  background-image: url('/assets/hero-glow.svg'),
    url('/images/bg-secondary.png');
}

@keyframes zoom {
  0% {
    opacity: 0.2;
    transform: scale(0.5) rotate(5deg);
    animation-timing-function: ease-in;
  }

  85% {
    opacity: 1;
  }

  100% {
    opacity: 0.2;
    transform: scale(1.5);
  }
}

.ntb-space__stars {
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  left: 0;
  overflow: hidden;
  background-image: radial-gradient(
      2px 2px at 50px 200px,
      #eee,
      rgba(0, 0, 0, 0)
    ),
    radial-gradient(2px 2px at 40px 70px, #fff, rgba(0, 0, 0, 0)),
    radial-gradient(3px 4px at 120px 40px, #ddd, rgba(0, 0, 0, 0));
  background-repeat: repeat;
  background-size: 250px 250px;
  opacity: 0.2;
  animation: zoom 12s infinite;
}

.ntb-space__stars:nth-child(1) {
  background-position: 10% 90%;
  animation-delay: 0s;
}

.ntb-space__stars:nth-child(2) {
  background-position: 20% 50%;
  background-size: 270px 500px;
  animation-delay: 0.3s;
}

.ntb-space__stars:nth-child(3) {
  background-position: 40% -80%;
  animation-delay: 1.2s;
}

/*.ntb-space__stars:nth-child(4) {
  background-position: -20% -30%;
  transform: rotate(60deg);
  animation-delay: 2.5s;
}*/

.ntb-space__stars:nth-child(4) {
  background-image: radial-gradient(
      2px 2px at 10px 100px,
      #eee,
      rgba(0, 0, 0, 0)
    ),
    radial-gradient(2px 2px at 20px 10px, #fff, rgba(0, 0, 0, 0)),
    radial-gradient(3px 4px at 150px 40px, #ddd, rgba(0, 0, 0, 0));
  background-position: 80% 30%;
  animation-delay: 4s;
}

/*.ntb-space__stars:nth-child(6) {
  background-position: 50% 20%;
  animation-delay: 6s;
}*/

'''
'''--- packages/front/src/json/tokens.json ---

'''
'''--- packages/front/src/json/tutorial.json ---
[
  {
    "title": "Register Server",
    "description": "An administrator use the command /register to register the server within the bot."
  },
  {
    "title": "Enable Tokens",
    "description": "Use the /addtoken command to choose which tokens to make available on your server."
  },
  {
    "title": "Set Tokens",
    "description": "Use the /setwallet command to add the address of the wallet you want to receive tokens."
  },
  {
    "title": "Send Tokens",
    "description": "Use the /send command to send tokens to anyone on your server."
  }
]

'''
'''--- packages/front/src/utils/actions.ts ---
import { TransactionPayload } from "./helpers";

export interface Actionable {
  error: string;
  success: string;
  check: ({ transaction: { actions } }: TransactionPayload) => boolean;
}

export const actions = [
  {
    error: "Something went wrong :(",
    success: "Tokens sent succesfully",
    check: ({ transaction: { actions } }: TransactionPayload) => {
      const [action] = actions;

      return action.FunctionCall.method_name === "ft_transfer_call";
    },
  },

  {
    error: "Something went wrong :(",
    success: "Tokens sent succesfully",
    check: ({ transaction: { actions } }: TransactionPayload) => {
      const [action] = actions;

      return action.FunctionCall.method_name === "transfer_payment";
    },
  },
];

export default actions;

'''
'''--- packages/front/src/utils/constants/contracts.ts ---
/**
 * Contracts constants
 */
export const defaultContract = "dev-1652055476064-95220052886384";

'''
'''--- packages/front/src/utils/constants/index.ts ---
export * from "./near";
export * from "./contracts";

'''
'''--- packages/front/src/utils/constants/near.ts ---
/**
 * Near constants
 */
export const AttachedGas = "300000000000000";
export const OneYOctoNear = "1000000000000000000000000";

'''
'''--- packages/front/src/utils/helpers.ts ---
import { utils, providers } from "near-api-js";
import { Buffer } from "buffer";

import type { CodeResult } from "near-api-js/lib/providers/provider";
import actions from "./actions";

import { WalletSelector } from "@near-wallet-selector/core";
import Big from "big.js";

export interface TransactionPayload {
  status: Status;
  transaction: Transaction;
  receipts_outcome: ReceiptOutcome[];
}

export interface Transaction {
  actions: Action[];
  hash: string;
  nonce: number;
  public_key: string;
  receiver_id: string;
  signature: string;
  signer_id: string;
}

interface Action {
  FunctionCall: FunctionCall;
}

interface FunctionCall {
  args: string;
  deposit: string;
  gas: number;
  method_name: string;
}

interface ReceiptOutcome {
  id: string;
  block_hash: string;
  outcome: Outcome;
}

interface Outcome {
  executor_id: string;
  gas_burnt: number;
  logs: string[];
  receipt_ids: string[];
  status: Status;
  tokens_burnt: string;
}

interface Status {
  SuccessValue?: string;
  SuccessReceiptId?: string;
  Failure?: string;
}

interface TransactionSend {
  signer_id: string;
  receiver_id: string;
  actions: Action[];
}

const rpcProviders = {
  testnet: "https://archival-rpc.testnet.near.org",
  mainnet: "https://archival-rpc.mainnet.near.org",
};

export const provider = new providers.JsonRpcProvider(
  rpcProviders[import.meta.env.VITE_NEAR_NETWORK]
);

export const getTransactionState = async (txHash: string, accountId: string) =>
  await provider.txStatus(txHash, accountId);

export const getTransactionsStatus = (receiptsOutcome: ReceiptOutcome[]) =>
  receiptsOutcome.every(
    ({ outcome }) => !Object.keys(outcome.status).includes("Failure")
  )
    ? "success"
    : "error";

export const getTransactionsAction = (
  transactions: Partial<TransactionPayload>[]
) => {
  return transactions
    .map((payload) => {
      const action = actions.find(({ check }) =>
        check(payload as TransactionPayload)
      );

      if (!action) {
        return;
      }

      const status = getTransactionsStatus(payload.receipts_outcome!);

      return {
        status,
        message: action[status],
        transactionHash: payload.transaction?.hash,
      };
    })
    .filter((item) => item)[0];
};

export const AttachedGas = "300000000000000";

const refreshPage = (transactions: string) => {
  const newUrl =
    window.location.origin +
    window.location.pathname +
    "?transactionHashes=" +
    transactions;

  window.location.href = newUrl;
};

export const executeMultipleTransactions = async (
  transactions: TransactionSend[],
  wallet: any
) => {
  try {
    const result = await wallet.signAndSendTransactions({ transactions });

    refreshPage(result.map(({ transaction }) => transaction.hash).join(","));
  } catch (e) {
    console.warn(e);
  }
};

export const getTransaction = (
  signerId: string,
  receiverId: string,
  method: string,
  args: any,
  amount?: string
): any => {
  return {
    signerId,
    receiverId,
    actions: [
      {
        type: "FunctionCall",
        params: {
          methodName: method,
          args,
          gas: AttachedGas,
          deposit:
            method === "transfer_payment"
              ? amount
              : amount
              ? utils.format.parseNearAmount(amount)!
              : "1",
        },
      },
    ],
  };
};

export const viewFunction = async (
  selector: WalletSelector,
  contractId: string,
  methodName: string,
  args = {}
) => {
  const { network } = selector.options;

  const provider = new providers.JsonRpcProvider({ url: network.nodeUrl });

  const serializedArgs = window.btoa(JSON.stringify(args));

  const res = await provider.query<CodeResult>({
    request_type: "call_function",
    account_id: contractId,
    method_name: methodName,
    args_base64: serializedArgs,
    finality: "optimistic",
  });

  return (
    res &&
    res.result.length > 0 &&
    JSON.parse(Buffer.from(res.result).toString())
  );
};

export const getTokenStorage = async (connection, account, token) => {
  try {
    return await viewFunction(connection, token, "storage_balance_of", {
      account_id: account,
    });
  } catch (e) {
    return;
  }
};

export const sendNear = (
  wallet: any,
  accountId: string,
  amount?: string,
  args = {}
) => {
  const decimals = new Big(10).pow(24);

  const transactions: Transaction[] = [];

  transactions.push(
    getTransaction(
      accountId!,
      import.meta.env.VITE_CONTRACT,
      "transfer_payment",
      args,
      Big(amount!).mul(decimals).toFixed(0)
    )
  );

  executeMultipleTransactions(transactions, wallet);
};

export const sendCommonToken = async (
  wallet: any,
  connection: WalletSelector,
  accountId: string,
  token: string,
  receiver: string,
  amount: string,
  senderId: string,
  receiverId: string,
  serverId: string
) => {
  const transactions: Transaction[] = [];

  const rawAccountStorage = await getTokenStorage(connection, accountId, token);

  const rawReceiverStorage = await getTokenStorage(connection, receiver, token);

  const rawContractStorage = await getTokenStorage(
    connection,
    import.meta.env.VITE_CONTRACT,
    token
  );

  if (!rawAccountStorage) {
    transactions.push(
      getTransaction(
        accountId!,
        token!,
        "storage_deposit",
        {
          account_id: accountId,
          registration_only: true,
        },
        "0.25"
      )
    );
  }

  if (!rawReceiverStorage) {
    transactions.push(
      getTransaction(
        accountId!,
        token!,
        "storage_deposit",
        {
          account_id: receiver,
          registration_only: true,
        },
        "0.25"
      )
    );
  }

  if (!rawContractStorage) {
    transactions.push(
      getTransaction(
        accountId!,
        token!,
        "storage_deposit",
        {
          account_id: import.meta.env.VITE_CONTRACT,
          registration_only: true,
        },
        "0.25"
      )
    );
  }

  const metadata = await viewFunction(connection, token!, "ft_metadata");

  const decimals = new Big(10).pow(metadata.decimals);

  transactions.push(
    getTransaction(accountId!, token!, "ft_transfer_call", {
      amount: Big(amount!).mul(decimals).toString(),
      memo: null,
      msg: JSON.stringify({
        receiver: receiver,
        sender_discord: senderId,
        receiver_discord: receiverId,
        server_discord: serverId,
      }),
      receiver_id: import.meta.env.VITE_CONTRACT,
    })
  );

  executeMultipleTransactions(transactions, wallet);
};

'''
'''--- packages/front/tailwind.config.js ---
module.exports = {
  content: ["./src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      colors: {
        azoxo: "#6D71FF",
        black: "#333333",
        pink: "#FC89F7",
        blue_button: "#7983FF",
        graphite: "#424250",
        purple: "#AB80FF",
        // grey: '#3D3D3D',
        lilac: "#DEDFFF",

        blue: {
          0: "#040d21",
        },
        grey: {
          100: "#333333",
        },
        purple: {
          0: "#6D71FF",
        },
      },

      fontSize: {
        fS32px: "32px",
      },

      backgroundImage: {
        lpbg: "url('/images/main-bg.jpg')",
        "bn-gradient": "linear-gradient(270deg, #7983FF 47.22%, #FC89F7 100%)",
      },

      boxShadow: {
        primary: "0px 2.84008px 35.501px rgba(171, 128, 255, 0.1)",
      },
    },
  },
  plugins: [],
};

'''
'''--- packages/front/tsconfig.json ---
{
  "compilerOptions": {
    "target": "ESNext",
    "useDefineForClassFields": true,
    "lib": ["DOM", "DOM.Iterable", "ESNext"],
    "allowJs": false,
    "skipLibCheck": true,
    "esModuleInterop": false,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "moduleResolution": "Node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",
    "baseUrl": ".",
    "noImplicitAny": false,
    "paths": {
      "@/*": ["src/*"]
    },
    "types": ["vite-plugin-pages/client-react", "vite/client"],
  },
  "include": ["./src"],
  "exclude": ["tailwind.config.js"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

'''
'''--- packages/front/tsconfig.node.json ---
{
  "compilerOptions": {
    "composite": true,
    "module": "esnext",
    "moduleResolution": "node"
  },
  "include": ["vite.config.ts"]
}

'''
'''--- packages/front/vercel.json ---
{
  "github": {
    "enabled": false
  },
  "routes": [{ "src": "/[^.]+", "dest": "/", "status": 200 }]
}

'''
'''--- packages/front/vite.config.ts ---
import { resolve } from "path";
import { defineConfig } from "vite";
import Pages from "vite-plugin-pages";
import react from "@vitejs/plugin-react";
import reactRefresh from "@vitejs/plugin-react-refresh";
import NodeGlobalsPolyfillPlugin from "@esbuild-plugins/node-globals-polyfill";

export default defineConfig({
  plugins: [
    react(),
    reactRefresh(),
    NodeGlobalsPolyfillPlugin({
      buffer: true,
      process: true,
    }),
    Pages({
      pagesDir: "src/pages",
    }),
  ],
  esbuild: {},
  define: {
    global: "window",
    "process.env": {},
  },
  resolve: {
    alias: {
      util: "util",
      process: "process/browser",
      "@": resolve(__dirname, "./src"),
    },
  },
});

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    
    "module": "esnext",
    "target": "esnext",
    "moduleResolution": "node",
    "jsx": "preserve",
    "downlevelIteration": true,
    /* noEmit - Snowpack builds (emits) files, not tsc. */
    "noEmit": true,
    /* Additional Options */
    "strict": true,
    "sourceMap": false,
    "skipLibCheck": true,
    "types": ["react", "jest", "node"],
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "allowSyntheticDefaultImports": true,
    "skipDefaultLibCheck": true,
    "importsNotUsedAsValues": "error",
    "isolatedModules": true,
    "typeRoots": ["@types/"],
    "baseUrl": ".",
  },
  "exclude": ["node_modules"],
  "include": ["./packages/**/*"]
}

'''