*GitHub Repository "pholophus/near-tutorial-guest-book"*

'''--- Monetize-NEAR-Smart-Contracts.md ---
#### Show Me the Money: Learn How to Monetize NEAR Smart Contracts

Learn how to design, build, and monetize smart contracts on the NEAR blockchain

Near

IntermediateSmart contracts1 hour

Written by Oysterpack

Show Table of Contents

Introduction[

](#introduction)
===============================

I invite you to join me In this tutorial series and learn how to design, build, and monetize smart contracts on the NEAR platform. Learning is fun, applying what you learn to build is more fun, and making money from what you have built is rewarding. I believe in the philosophy of the "proof is in the pudding". In this tutorial series, we will be building a real-world smart contract called the [STAKE](https://github.com/oysterpack/oysterpack-near-stake-token) token. The goals for this tutorial series are:

1.  Showcase the [STAKE](https://github.com/oysterpack/oysterpack-near-stake-token) token project on how to monetize NEAR smart contracts
    
2.  Share with you my approach to architect, design, and code smart contracts in Rust
    
3.  Take you step by step through designing, coding, and testing on the [STAKE](https://github.com/oysterpack/oysterpack-near-stake-token)
    
    token project.
    
4.  Share with you design patterns and best practices I have learned while working on the STAKE token project
    
5.  Make this a collaborative experience with the community
    

Regarding the last point, I welcome community participation in the [STAKE](https://github.com/oysterpack/oysterpack-near-stake-token) open source project.

NEAR Technology + Economics = Game Changer[

](#n-e-a-r-technology-economics-game-changer)
==========================================================================================

When I first discovered NEAR, what caught my attention was NEAR's economic model. It is well thought out and designed to provide economic incentive and value. Coupling that with NEAR's sharded scalability, speed, and low predictable operational cost provides a platform that can deliver real-world business and economic value. NEAR has the potential and all the key ingredients to becoming the first true economical decentralized cloud platform - to compete with centralized cloud platforms owned by a few big tech companies ...

You can have your STAKE and trade it too[

](#you-can-have-your-s-t-a-k-e-and-trade-it-too)
===========================================================================================

The STAKE token contract enables you to delegate your NEAR to stake, and in return, you are issued STAKE tokens. This enables you to trade your STAKE tokens while your NEAR is locked for staking and earning staking rewards. In addition, to earning staking rewards, the staked NEAR earns contract rewards from transaction fees. The STAKE token transforms your staked NEAR into a tradeable asset that is backed by revenue streams.

The STAKE token business model leverages the following from NEAR:

1.  [Staking pool delegation](https://docs.near.org/docs/validator/delegation#staking-pool-delegation)
    *   Anyone holding NEAR tokens can earn staking rewards by [delegating](https://docs.near.org/docs/validator/staking-overview#for-delegators) their tokens to staking pools
2.  [Staking pool](https://github.com/near/core-contracts/tree/master/staking-pool) core contract
    *   STAKE token contract integrates with [staking pool](https://github.com/near/core-contracts/tree/master/staking-pool) contracts for staking NEAR
3.  Contract rewards
    *   NEAR provides out of the box the ability to collect a portion of transaction fees and distributes them to the contracts that were run as part of the transaction
    *   STAKE token contract distributes a share of its contract rewards through staking
    *   STAKE token contract is also able to collect earnings from external contracts and distribute the funds through the staking mechanism

STAKE Token Contract High-Level Overview[

](#s-t-a-k-e-token-contract-high-level-overview)
===========================================================================================

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-near-stake-token-overview-1-.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-near-stake-token-overview-1-.png)

*   Users must register with the contract in order to use it. When registering, users are required to pay an upfront account storage fee to cover storage staking costs. On NEAR long term storage is not free. The account storage fee is escrowed and will be refunded back to the user when the account unregisters.
*   Contract is linked to a single staking pool contract, i.e., STAKE token contract is deployed per staking pool contract.
*   Contract will implement the new fungible token standard defined by [NEP-141](https://github.com/near/NEPs/discussions/146)
*   Contract has concept of contract ownership.
*   Contract supports an operator role that is managed by the contract owner.
*   Contract supports distributing contract rewards and earnings through the staking mechanism.
*   Contract supports adding liquidity for unstaking and withdrawals

What you will learn from the STAKE Token project from a technical perspective[

](#what-you-will-learn-from-the-s-t-a-k-e-token-project-from-a-technical-perspective)
---------------------------------------------------------------------------------------------------------------------------------------------------------------------

The STAKE token project is fairly complex and showcases the following

1.  Applying interface-driven design and domain modeling
    *   Leveraging Rust strong type system and compiler
2.  Cross-contract workflows
    *   High level and low-level approaches
    *   Making use of batch transactions
    *   Gas considerations
3.  State management
    *   Storage staking considerations
4.  Financial computation considerations
    *   Protecting against overflows
5.  New fungible token standard - [NEP-141](https://github.com/near/NEPs/discussions/146)
6.  Unit testing
7.  Simulation testing
8.  Contract deployment
9.  ... And the learning never ends

The World Is Your Oyster[

](#the-world-is-your-oyster)
-------------------------------------------------------

Decentralized network platforms, such as NEAR, provide tremendous economic opportunity. To put it into perspective, Amazon's market capitalization is currently valued at 1.56 trillion USD and 2021 revenue estimates are in the 411 - 488 billion USD range. That is just scratching the service. How much do you think the global economy is worth? Decentralized and scalable global cloud platforms such as NEAR provides an opportunity for all to participate in the global economy.

Conclusion[

](#conclusion)
===========================

NEAR is a super-fast smart contract platform with super low transaction fees that is user and developer-friendly for building real-world applications for the Open Web. I am excited about NEAR, and I hope I have inspired you to learn with me on this thrilling journey.

'''
'''--- NEAR-STAKE-Pool-Ground.md ---
Original tutorial can get from here #https://learn.figment.io/tutorials/stake-pool-contract

The agenda for this tutorial is:
1.  Show you the benefits that the OysterPack SMART STAKE pool provides
2.  Show you how to deploy and use the STAKE pool contract as a **Validator**
3.  Show you how to use the STAKE pool contract as a **Staker**

"Stakers" are the delegators ... to me "Stakers" sounds better than "delegators"

OysterPack SMART STAKE Benefits[

](#oyster-pack-s-m-a-r-t-s-t-a-k-e-benefits)
==============================================================================

Today there only lives a single staking pool contract in the NEAR wild. All validators on mainnet are using the [staking pool](https://github.com/near/core-contracts/tree/master/staking-pool) built by the NEAR core DEV team to bootstrap staking on NEAR's PoS blockchain. Staking on NEAR is permissionless, which enables staking to evolve. This illustrates the power and beauty of decentralization on the blockchain. There is nothing stopping any person with new ideas to build and create on the blockchain. The current staking pool on NEAR works, but there's always room for improvement - I call it the _"first generation"_ staking pool. Here's the list of improvements for the **"next generation"** **OysterPack SMART STAKE Pool** and how it compares to the first generation staking pool:

Locked staked NEAR is made mobile through **STAKE fungible tokens** provided by the STAKE pool

This enables staked NEAR value to be transferred while still being staked. This opens the door to many new DeFi use cases for staked NEAR.

Staking Done Right - Maximizing Yield[

](#staking-done-right-maximizing-yield)
===============================================================================

The first generation staking pool will only stake deposited funds and restake earnings once every epoch. Earnings are composed of staking rewards plus any contract rewards earned from transaction gas fees. Because earnings are only restaked once per epoch, you lose some potential yield from less compounding. The compounding yield opportunity is lost for earnings outside staking rewards because the NEAR protocol only issues staking rewards once per epoch. Thus, today some yield is left on the table for contract earnings received from transaction gas fees, which impacts long term stakers the most because of less compounding. The next generation STAKE pool maximizes yield by checking for earnings in each pool transaction and restakes earnings as soon as they are received to maximize the power of the compounding yield effect.

Unstaking Done Right[

](#unstaking-done-right)
===============================================

The following 2 improvements enable accounts to withdraw unstaked NEAR sooner:

1.  Unstaked NEAR is always available for withdrawal in **at most** 4 epochs per the NEAR protocol. Unstaked NEAR is locked for 4 epochs before it becomes available to be withdrawn, but is tracked per epoch. Thus, more funds can be unstaked without affecting funds that were unstaked in previous epochs. Compare this to the first generation staking pool, where each time you unstake, it resets the lockup period to 4 epochs for the total unstaked NEAR balance. For example, if 100 NEAR is unstaked in EPOCH 1 and 10 NEAR is unstaked in EPOCH 3. Then 100 NEAR is available for withdrawal in EPOCH 5 and 10 NEAR in EPOCH 7. In the first generation staking pool implementation, unstaking the 10 NEAR in EPOCH 3 would reset the lock period for the total unstaked, i.e., you would not be able to withdraw the 100 NEAR that was unstaked in EPOCH 1 until EPOCH 7. This issue has been resolved in the OysterPack SMART STAKE pool.
2.  Staking adds **liquidity** for withdrawing unstaked NEAR that is locked on a first come, first withdraw basis. For example, if you unstake 100 NEAR in EPOCH 1, normally you would not be able to withdraw the unstaked NEAR out of the pool until EPOCH 5. However, when other accounts stake while there are locked unstaked funds in the STAKE pool, then the new staked funds effectively add liquidity and unlock the unstaked funds. Think of it as the unstaked funds are being restaked. Thus, higher staking activity automatically provides more liquidity.

Enhanced Financial Model[

](#enhanced-financial-model)
-------------------------------------------------------

The goal is to provide more financial levers to validators in order to promote competition for staker business.

More Flexible Fee Model[

](#more-flexible-fee-model)
-----------------------------------------------------

1.  **Earnings based fee** The staking pool owner takes a percentage of the STAKE pool earnings. This matches the current commercial fee model implemented by the first generation staking pool. This fee keeps the financial incentives and interests aligned with all stakers. Owner earnings are directly aligned with the STAKE pool earnings.
2.  **Staking fee** This fee type is not supported by the first generation staking pool. The staking fee is a percentage of the amount staked. OysterPack SMART STAKE pools provide more commercial levers and can be configured to use a combination of earnings based fees and staking fees. For example, validators may choose to charge only a staking fee and pass on all earnings to delegators.

Enables External Revenue Sources for Boosting EPS[

](#enables-external-revenue-sources-for-boosting-e-p-s)
-----------------------------------------------------------------------------------------------------------

1.  **External revenue distributions** External sources of revenue can be deposited into the STAKE pool and distributed to all current stakers simply by staking the funds. This immediately distributes the revenue earnings via the STAKE token.
2.  **External revenue can be deposited into the treasury to distribute dividends** Dividends are distributed by the treasury by burning STAKE for earnings it receives. Thus, when STAKE is burned, the validator is effectively buying back shares funded by treasury earnings, which boosts the STAKE token value.

STAKE is modeled as a **dividend stock**. STAKE links the dividend yield directly to EPS (earnings per share or earnings per STAKE). When EPS increases, so does the dividend, and gets automatically paid out, which is governed by the contract (and not a board of directors). The STAKE pool contract enables validators to compete on EPS on more than just staking rewards provided by NEAR PoS.

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-stake-earnings.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-stake-earnings.png)

STAKE High Level Component Based Architecture[

](#s-t-a-k-e-high-level-component-based-architecture)
=====================================================================================================

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-stake-deployment.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-stake-deployment.png)

STAKE Pool Factory Contract[

](#s-t-a-k-e-pool-factory-contract)
-----------------------------------------------------------------

The factory contract makes it easy for anyone to deploy a new instance of the STAKE pool contract. We'll see how to deploy new STAKE pool contracts using the NEAR CLI below.

It currently costs a little just under 6 NEAR to deploy the STAKE pool contract to pay for contract storage usage. Thus, if you attach 6 NEAR, then you should be safe. Any extra will be transferred over to the owner's account storage balance. If deployment fails for any reason, then the factory contract is designed to refund the attached deposit.

STAKE Pool Contract[

](#s-t-a-k-e-pool-contract)
-------------------------------------------------

The STAKE Pool Contract is composed of 4 components, which are depicted on the right-hand side of the diagram. Each component provides multiple interfaces which are paired up in the diagram by the coloring scheme. The diagram also depicts the main actors and the key interfaces they depend on. In this tutorial, we will just be scratching the surface and focus on the core staking functionality to get started.

The STAKE pool contract is built using a component based architecture. If you happen to wander into the source code, you will probably notice that it follows a completely different design approach to build contracts on NEAR compared to what you are probably used to seeing. There's nothing special besides applying software engineering best practices. A component based approach enables component reuse across contracts - and I have plans for building many. My plan is to eventually publish them all to [https://crates.io](https://crates.io) to make it easy for developers to use them. Until then, if you are interested in using them, you'll need to pull them in from the GitHub project. I'll end the discussion on the benefits of a component based architecture here by putting it into context for web developers. If you prefer building web apps using React components, then you should also prefer building contracts using OysterPack SMART components for the same reasons.

You might also notice that I have built components that implement the NEAR standard APIs that I have covered in prior tutorials for account storage management and fungible tokens, but there's much more ...

How to Get Started as a Validator[

](#how-to-get-started-as-a-validator)
=========================================================================

I will not be covering on how to setup and run your own validator node. If you are interested in running your own validator node, then I refer you to the NEAR [staking](https://docs.near.org/docs/validator/staking) docs.

How to deploy the STAKE pool contract[

](#how-to-deploy-the-s-t-a-k-e-pool-contract)
=====================================================================================

To earn NEAR rewards for exercising the NEAR CLI commands, you will need to submit the NEAR requests through [DataHub](https://datahub.figment.io/) using your DataHub access key. If you have earned NEAR on previous NEAR tutorials, then you should already be set. Otherwise, follow the instructions in the following link on [how to obtain your DataHub access key](https://learn.figment.io/network-documentation/near/tutorials/intro-pathway-write-and-deploy-your-first-near-smart-contract/1.-connecting-to-a-near-node-using-datahub#configure-environment). We will use the NEAR CLI to submit the transactions. Plugin your DataHub API Key and NEAR account at the top, and then you should be all set to go.

Below is a NEAR CLI example which deploys a new STAKE contract on testnet:

`DATAHUB_APIKEY=<DATAHUB_APIKEY> NEAR_NODE_URL=https://near-testnet--rpc.datahub.figment.io/apikey/$DATAHUB_APIKEY NEAR_ACCOUNT=<YOUR-NEAR-ACCOUNT.testnet> NEAR_ENV=testnet STAKE_FACTORY=dev-1619461926372-2886358 ACCOUNT_ID=oysterpack.testnet STAKE_PUBLIC_KEY=ed25519:GTi3gtSio5ZYYKTT8WVovqJEob6KqdmkTi8KqGSfwqdm STAKE_SYMBOL=PEARL3 STAKING_FEE=1 EARNINGS_FEE=50 near call $STAKE_FACTORY deploy --accountId $ACCOUNT_ID --amount 6 --gas 300000000000000 --node_url $NEAR_NODE_URL --args \ "{\"stake_symbol\":\"$STAKE_SYMBOL\",\"stake_public_key\":\"$STAKE_PUBLIC_KEY\",\"earnings_fee\":$EARNINGS_FEE,\"staking_fee\":$STAKING_FEE}"`

If you successfully run the command, then the output will look like:

`Scheduling a call: dev-1619461926372-2886358.deploy({"stake_symbol":"PEARL3","stake_public_key":"ed25519:GTi3gtSio5ZYYKTT8WVovqJEob6KqdmkTi8KqGSfwqdm","earnings_fee":50,"staking_fee":1}) with attached 6 NEAR Receipt: 8DxtrFzCzW6iz98NHwEFy7mB9W4qgT8PZUwkZL3zd5b9         Log [dev-1619461926372-2886358]: [INFO] [DEPLOYMENT] ContractOwnershipComponent         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(97)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-97)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-184)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(97)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(184)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(8)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-105)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-184)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(104)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(-104)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(97)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] Registered(StorageBalance { total: YoctoNear(3930000000000000000000), available: YoctoNear(0) })         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(8)         Log [dev-1619461926372-2886358]: [INFO] [DEPLOYMENT] AccountManagementComponent         Log [dev-1619461926372-2886358]: [INFO] [DEPLOYMENT] locked balance for 10K contract storage         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1088320000000000000000000))         Log [dev-1619461926372-2886358]: [INFO] [DEPLOYMENT] owner balance = 1088320000000000000000000         Log [dev-1619461926372-2886358]: [INFO] [DEPLOYMENT] FungibleTokenComponent {   "spec": "ft-1.0.0",   "name": "STAKE",   "symbol": "PEARL3",   "decimals": 24,   "icon": null,   "reference": null,   "reference_hash": null }         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] StorageUsageChange(97)         Log [dev-1619461926372-2886358]: [INFO] [ACCOUNT_STORAGE_CHANGED] Registered(StorageBalance { total: YoctoNear(3930000000000000000000), available: YoctoNear(0) })         Log [dev-1619461926372-2886358]: [INFO] [DEPLOYMENT] StakingPoolComponent Receipt: Fi9DoMaxtKfyWg4couRP8WCtytr48RCPGjLcjD28Z6P5         Log [dev-1619461926372-2886358]: [INFO] [STAKE_POOL_DEPLOY_SUCCESS]  Transaction Id Yhrda9sutT4jhGMpwTuUZCZYm5vfH8RLCkvJzgnZj28 To see the transaction in the transaction explorer, please open this url in your browser https://explorer.testnet.near.org/transactions/Yhrda9sutT4jhGMpwTuUZCZYm5vfH8RLCkvJzgnZj28`

Log records use the following standard format: `[LOG_LEVEL] [EVENT] msg`

where LOG\_LEVEL -> INFO | WARN | ERR

The logs tell the story about what's happening during the deployment, which is illustrated in the below diagram:

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-stake-factory-deploy.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-stake-factory-deploy.png)

Notes[

](#notes)
=================

*   **AccountManagementComponent** is designed to track and log (**ACCOUNT\_STORAGE\_CHANGED**) all account storage changes
*   The STAKE pool contract implements the NEAR standard [account storage management](https://nomicon.io/Standards/StorageManagement.html) interface. It measures dynamically how much account storage is required by the contract and configures the minimum storage usage bound accordingly.
*   **AccountManagementComponent** is also designed to track all contract NEAR balances including account storage balances.
*   The **ContractOperator** interface provides the ability to lock a portion of the contract account balance to ensure it cannot be transferred out. This feature is used to lock enough account balance to pay for 10K of contract storage that is reserved for the STAKE pool to be operational.
*   The **STAKE Factory Contract** is designed to create and initialize the STAKE Pool contract using NEAR's batch transaction feature. This guarantees that either all actions in the batch transaction succeed or fail atomically. If the batch transaction fails for any reason, the factory contract is designed to refund the attached deposit.
*   In the above NEAR CLI example, the owner account was specified implicitly using the predecessor account. However note that the factory deploy function supports an optional `owner` argument that can be used to specify the owner account explicitly.
*   Fees are specified in basis points ([BPS](https://www.investopedia.com/terms/b/basispoint.asp)). An easy way to remember the unit conversion is 100 BPS = 1%. In the above example, the staking fee is 0.01%, and the earnings fee is 0.5%. At least one of the fees must be non-zero and the max fee is currently hard coded to be 1000 BPS (10%). Fees are configurable and can be changed after the STAKE pool is deployed by accounts that have the operator permission.
*   The **STAKE Pool Contract** implements the NEAR standard [fungible token](https://nomicon.io/Standards/FungibleToken/README.html%5D%28https://nomicon.io/Standards/FungibleToken/README.html) interfaces for the provided STAKE token.

How to operate the STAKE pool contract[

](#how-to-operate-the-s-t-a-k-e-pool-contract)
=======================================================================================

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-stake-operator-usecases.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-stake-operator-usecases.png)

The above diagram shows the role and responsibilities for the operator. In this tutorial, I will review the key APIs to be familiar with to get started. The rest is out of scope and will be covered in future tutorials and workshops.

How to start and stop staking[

](#how-to-start-and-stop-staking)
=================================================================

When the STAKE pool contract is deployed, it's initial status is offline. You can check the pool status using the following NEAR CLI command:

`STAKE=pearl near view  $STAKE.stake-v1.oysterpack.testnet ops_stake_status`

The status results look like:

`{ Offline: 'Stopped' } 'Online'`

If the pool is offline, then it also displays the offline reason. There are 2 reason why the pool would be offline:

*   **Stopped** - means the pool was explicitly stopped an operator
*   **StakeActionFailed** - means that a NEAR stake action failed, which will take the pool offline automatically

Staking can be started and stopped using the following NEAR CLI commands:

`near call  $STAKE.stake-v1.oysterpack.testnet ops_stake_operator_command --args '{"command":"StartStaking"}' --accountId $NEAR_ACCOUNT near call  $STAKE.stake-v1.oysterpack.testnet ops_stake_operator_command --args '{"command":"StopStaking"}' --accountId $NEAR_ACCOUNT`

Query and update fees[

](#query-and-update-fees)
-------------------------------------------------

Current fees can be queried via:

`near view  $STAKE.stake-v1.oysterpack.testnet ops_stake_fees`

which will return output like:

`{ staking_fee: 80, earnings_fee: 0 }`

Fees can be changed with the following NEAR CLI command:

`near call  $STAKE.stake-v1.oysterpack.testnet ops_stake_operator_command --args '{"command":{"UpdateFees":{"staking_fee":1,"earnings_fee":50}}}' --accountId $NEAR_ACCOUNT`

*   both fees must be specified and at least 1 must be non-zero

Query and update the staking public key[

](#query-and-update-the-staking-public-key)
-------------------------------------------------------------------------------------

The staking public key, i.e., the validator key, can be viewed and changed using the following NEAR CLI commands:

`near view  $STAKE.stake-v1.oysterpack.testnet ops_stake_public_key near call  $STAKE.stake-v1.oysterpack.testnet ops_stake_operator_command --args '{"command":{"UpdatePublicKey":"ed25519:GTi3gtSio5ZYYKTT8WVovqJEob6KqdmkTi8KqGSfwqdm"}}' --accountId $NEAR_ACCOUNT`

How to Get Started as a Staker[

](#how-to-get-started-as-a-staker)
===================================================================

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-staker-usecases.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-staker-usecases.png)

The STAKE Pool contract implements the NEAR standard [storage management](https://nomicon.io/Standards/StorageManagement.html) specification. This means that accounts must first register with the contract and deposit funds to pay for account storage before being able to use the contract. I defer to the [storage management](https://nomicon.io/Standards/StorageManagement.html) documentation for details.

account registration currently costs 0.000393 NEAR

How to stake[

](#how-to-stake)
-------------------------------

When an account stakes any account storage available balance will be staked in addition to any attached deposit. The account storage management interface is leveraged to enable accounts to collect deposits to stake at a later time.

`# stakes only the account's storage available balance near call  $STAKE.stake-v1.oysterpack.testnet ops_stake --accountId $NEAR_ACCOUNT # stakes the account's storage available balance + 1 NEAR attached deposit near call  $STAKE.stake-v1.oysterpack.testnet ops_stake --accountId $NEAR_ACCOUNT --amount 1`

The logs tell the story:

`Log [dev-1618770943926-8326158]: [INFO] [EARNINGS] 4101039949423780538046344837 Log [dev-1618770943926-8326158]: [INFO] [FT_BURN] account: dev-1618770943926-8326158, amount: 21956195625979298913189923 Log [dev-1618770943926-8326158]: [INFO] [TREASURY_DIVIDEND] 22859532518386059780519144 yoctoNEAR / 21956195625979298913189923 yoctoSTAKE Log [dev-1618770943926-8326158]: [INFO] [ACCOUNT_STORAGE_CHANGED] Withdrawal(YoctoNear(1)) Log [dev-1618770943926-8326158]: [INFO] [ACCOUNT_STORAGE_CHANGED] Deposit(YoctoNear(1)) Log [dev-1618770943926-8326158]: [INFO] [STAKE] near_amount=100000000000000000000000, stake_token_amount=96042291735938018665641 Log [dev-1618770943926-8326158]: [INFO] [FT_MINT] account: alfio-zappala-oysterpack.testnet, amount: 96042291735938018665641 Log [dev-1618770943926-8326158]: [INFO] [FT_BURN] account: alfio-zappala-oysterpack.testnet, amount: 768338333887504149325 Log [dev-1618770943926-8326158]: [INFO] [FT_MINT] account: oysterpack.testnet, amount: 768338333887504149325`

*   earnings were collected and distributed
*   the treasury paid a dividend from its earnings
*   because of rounding, 1 yoctoNEAR could not be staked and was deposited into the account's storage balance
*   the STAKE token value for the staked amount is computed
*   STAKE tokens were minted for the account
*   fees were transferred from the account to the owner by burning the fees from the account and minting them on the owner account

The account's updated stake balance is returned and looks like:

`{   "storage_balance": {     "total": "3930000000000000000001",     "available": "1"   },   "staked": {     "stake": "10888070762166201553542838",     "near_value": "11336746129103451686781599"   },   "unstaked": {     "total": "1",     "available": "1",     "locked": null   } }`

*   all account balances are returned, i.e., storage balance, staked, and unstaked balances
*   the current NEAR value for the account's STAKE token balance is returned
*   unstaked balance shows how much is available for withdrawal and locked - in the above example there is currently zero locked unstaked

How to unstake[

](#how-to-unstake)
-----------------------------------

`# unstakes all near call  $STAKE.stake-v1.oysterpack.testnet ops_unstake --accountId $NEAR_ACCOUNT # unstakes specified amount near call  $STAKE.stake-v1.oysterpack.testnet ops_unstake --accountId $NEAR_ACCOUNT  --args '{"amount":"1000000000000000000000000"}'`

`Log [dev-1618770943926-8326158]: [INFO] [EARNINGS] 1155935938423300000000 Log [dev-1618770943926-8326158]: [INFO] [FT_BURN] account: dev-1618770943926-8326158, amount: 6119045408724236555 Log [dev-1618770943926-8326158]: [INFO] [TREASURY_DIVIDEND] 6371198893243536821 yoctoNEAR / 6119045408724236555 yoctoSTAKE Log [dev-1618770943926-8326158]: [INFO] [UNSTAKE] near_amount=1000000000000000000000000, stake_token_amount=960422914297395816680428 Log [dev-1618770943926-8326158]: [INFO] [FT_BURN] account: alfio-zappala-oysterpack.testnet, amount: 960422914297395816680428`

*   earnings were collected again - **NOTE**: every contract transaction generates earnings
*   treasury pays a dividend from its earnings
*   the STAKE token value for the amount unstaked is computed and burned on the account

the account balances now look like:

`{   "storage_balance": {     "total": "3930000000000000000001",     "available": "1"   },   "staked": {     "stake": "9927647847868805736862410",     "near_value": "10336746160201213136176928"   },   "unstaked": {     "total": "1000000000000000000000001",     "available": "1",     "locked": {       "80": "1000000000000000000000000"     }   } }`

*   the unstaked balance now shows that there is 1 NEAR locked and will become available for withdrawal in epoch 80
*   **NOTE**: if there is liquidity, then the account will be able to withdraw sooner

How to restake unstaked funds[

](#how-to-restake-unstaked-funds)
-----------------------------------------------------------------

In order to restake funds using the first generation staking pool, the account would first need to withdraw the funds out of the pool and then stake them again. The OysterPack SMART STAKE pool simplifies the restake process by enabling the staker to restake unstaked funds.

`# restakes all unstaked funds near call  $STAKE.stake-v1.oysterpack.testnet  ops_restake --accountId $NEAR_ACCOUNT  # restakes the specified amount from the account's unstaked balance near call  $STAKE.stake-v1.oysterpack.testnet  ops_restake --accountId $NEAR_ACCOUNT  -args '{"amount":"100000000000000000000000"}'`

How to withdraw unstaked funds[

](#how-to-withdraw-unstaked-funds)
-------------------------------------------------------------------

`# withdraws all available unstaked NEAR near call  $STAKE.stake-v1.oysterpack.testnet  ops_stake_withdraw --accountId $NEAR_ACCOUNT # withdraws the specified amount from the unstaked available balance and against liquidity near call  $STAKE.stake-v1.oysterpack.testnet  ops_stake_withdraw --accountId $NEAR_ACCOUNT -args '{"amount":"100000000000000000000000"}'`

How to check STAKE pool balances[

](#how-to-check-s-t-a-k-e-pool-balances)
---------------------------------------------------------------------------

`near view  $STAKE.stake-v1.oysterpack.testnet ops_stake_pool_balances`

`{   total_staked: '364568699342368667595072121779',   total_stake_supply: '350140131647969807579006618378',   total_unstaked: '900000000000000000000000',   unstaked_liquidity: '100000000000000000000001',   treasury_balance: '2009406695051801299154334155',   current_contract_managed_total_balance: '364576420617778762607772121782',   last_contract_managed_total_balance: '364576419433154155124172121782',   earnings: '1184624607483600000000' }`

*   **total\_staked** - total NEAR that has been staked
*   **total\_stake\_supply** - total STAKE FT supply
*   **total\_unstaked** - total NEAR that has been unstaked and sitting in unstaked balances
*   **unstaked\_liquidity** - how much liquidity is currently available for withdrawing unstaked funds that are locked
*   **treasury\_balance** - treasury balance that is used to generate dividend payouts
*   **current\_contract\_managed\_total\_balance** and **last\_contract\_managed\_total\_balance** - used to track changes in balances to collect earnings
*   **earnings** - amount of earnings that are waiting to be collected on the next staking action

How to query staker account balances[

](#how-to-query-staker-account-balances)
-------------------------------------------------------------------------------

`near view  $STAKE.stake-v1.oysterpack.testnet ops_stake_balance --args '{"account_id":"oysterpack.testnet"}'`

How to transfer STAKE tokens[

](#how-to-transfer-s-t-a-k-e-tokens)
-------------------------------------------------------------------

The STAKE pool contract implements the NEAR standard \[fungible token\]\[9\] interface, and I defer to the NEAR docs for details. However, the STAKE Pool API offers 2 convenience transfer methods that enable stakers to transfer STAKE by specifying a NEAR amount. The amount of STAKE tokens transferred will be based on the current STAKE token value. The API's mirror NEAR standard `ft_transfer` and `ft_transfer_call` methods:

`near call  $STAKE.stake-v1.oysterpack.testnet ops_stake_transfer --accountId $NEAR_ACCOUNT --args '{"receiver_id":"xxx.testnet","amount":"1000000000000000000000000"}' --amount 0.000000000000000000000001 near call  $STAKE.stake-v1.oysterpack.testnet ops_stake_transfer_call --accountId $NEAR_ACCOUNT --args '{"receiver_id":"xxx.testnet","amount":"1000000000000000000000000","msg":""}' --amount 0.000000000000000000000001`

How to query the current STAKE token value[

](#how-to-query-the-current-s-t-a-k-e-token-value)
-----------------------------------------------------------------------------------------------

`# returns the NEAR value for 1 STAKE token near view  $STAKE.stake-v1.oysterpack.testnet ops_stake_token_value # returns the NEAR value for the specified STAKE token amount near view  $STAKE.stake-v1.oysterpack.testnet ops_stake_token_value --args '{"amount":"5000000000000000000000000"}'`

`'1041207985614422459014157'`

*   the latest earnings are included in the computation minus treasury dividends
*   if you need the most accurate STAKE token value, then use the following NEAR CLI command

`# returns the NEAR value for 1 STAKE token near call  $STAKE.stake-v1.oysterpack.testnet ops_stake_token_value_with_earnings  # returns the NEAR value for the specified STAKE token amount near call  $STAKE.stake-v1.oysterpack.testnet  ops_stake_token_value_with_earnings --account_id $NEAR_ACCOUNT --args '{"amount":"5000000000000000000000000"}'`

*   these are call methods and will require gas
*   earnings are collected and treasury dividend is paid before computing the STAKE token NEAR value - sample CLI command output looks like:

`Receipt: FLBamjxsgq9brEjoHMVTHXyXdiiHbe57wuaH9hs7SzCL         Log [dev-1618770943926-8326158]: [INFO] [EARNINGS] 1184624607483600000000         Log [dev-1618770943926-8326158]: [INFO] [FT_BURN] account: dev-1618770943926-8326158, amount: 6270926727134172193         Log [dev-1618770943926-8326158]: [INFO] [TREASURY_DIVIDEND] 6529338974230524798 yoctoNEAR / 6270926727134172193 yoctoSTAKE Transaction Id FoQJ7kmNnjR6g8ew35sZq8snCMBHDQQGpdYPRfAhYr2e To see the transaction in the transaction explorer, please open this url in your browser https://explorer.testnet.near.org/transactions/FoQJ7kmNnjR6g8ew35sZq8snCMBHDQQGpdYPRfAhYr2e '1041207983836766420575151'`

Conclusion[

](#conclusion)
===========================

The next generation STAKE Pool contract is ready and waiting for validators and stakers to use it. It's my gift to the NEAR community, and I hope you enjoy it. Staking is the bread and butter of any PoS blockchain like NEAR. OysterPack SMART mission is to build and provide the best staking solutions, products, and services to deliver the best and most profitable staking experience. The building never stops, and there's much more in the works ... so stay tuned folks.

I invite you to join the Figment and NEAR communities and embark on our common mission to defend and take back the Internet together.

Next Steps[

](#next-steps)
===========================

The focus will be providing the validators with more in-depth tutorials and workshops to help them get onboard.

'''
'''--- README.md ---
Guest Book
==========

Our Guest Book example is a simple app composed by two main components:

1.  A smart contract that stores messages from users, allowing to attach money to them.
2.  A simple web-based frontend that displays the last 10 messages posted.

![img](https://docs.near.org/assets/images/guest-book-b305a87a35cbef2b632ebe289d44f7b2.png)

* * *

Starting the Project[​](#starting-the-project "Direct link to heading")
-----------------------------------------------------------------------

You have two options to start using the project. The first and recommended is to use the app through Gitpod, which will open a web-based interactive environment. The second option is to clone the repository locally, for which you will need to install all the [Prerequisites](/develop/prerequisites).

*   🌐 JavaScript
*   🦀 Rust
*   🚀 AssemblyScript

Gitpod

Clone locally

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/near-examples/guest-book-js.git)

🌐 `https://github.com/near-examples/guest-book-js`

Gitpod

Clone locally

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/near-examples/guest-book-rust.git)

🦀 `https://github.com/near-examples/guest-book-rust`

Gitpod

Clone locally

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io/#https://github.com/near-examples/guest-book.git)

🚀 `https://github.com/near-examples/guest-book`

If you choose Gitpod a new browser window will open automatically with the code, give it a minute and the frontend will pop-up (make sure the pop-up window is not blocked).

If you are running the app locally, enter the directory where you cloned it and use `yarn` to install dependencies, and `yarn start` to start it.

    cd guest-bookyarnyarn deployyarn start

Your contract will then be **compiled** and **deployed** to an **account** in the `testnet` network. When done, a browser window should open.

* * *

Interacting With the Guest Book[​](#interacting-with-the-guest-book "Direct link to heading")
---------------------------------------------------------------------------------------------

![img](https://docs.near.org/assets/images/guest-book-b305a87a35cbef2b632ebe289d44f7b2.png) _Frontend of the Guest Book app_

Go ahead and login with your NEAR account. If you don't have one, you will be able to create one in the moment. Once logged in, you will be able to sign a message in the guest book. You can further send some money alongside your message. If you attach more than 0.01Ⓝ then your message will be marked as "premium".

* * *

Structure of a dApp[​](#structure-of-a-dapp "Direct link to heading")
---------------------------------------------------------------------

Now that you understand what the dApp does, let us take a closer look to its structure:

1.  The frontend code lives in the `/frontend` folder.
2.  The smart contract code is in the `/contract` folder.

### Contract[​](#contract "Direct link to heading")

The contract presents 2 methods: `add_message` and `get_message`.

*   🌐 JavaScript
*   🦀 Rust

contract/src/contract.ts

    loading...

[See full example on GitHub](https://github.com/near-examples/guest-book-js/blob/master/contract/src/contract.ts#L4-L24#)

contract/src/lib.rs

    loading...

[See full example on GitHub](https://github.com/near-examples/guest-book-rust/blob/main/contract/src/lib.rs#L29-L50#)

### Frontend[​](#frontend "Direct link to heading")

The frontend is composed by a single HTML file (`/index.html`) and uses REACT. Check `/App.js` and `/index.js` to understand how components are displayed in the screen.

You will notice in `/assets/js/index.js` the following code:

*   🌐 JavaScript

frontend/index.js

    loading...

[See full example on GitHub](https://github.com/near-examples/guest-book-rust/blob/main/frontend/index.js#L15-L25#)

It setups the necessary variables and starts the app.

* * *

Testing[​](#testing "Direct link to heading")
---------------------------------------------

When writing smart contracts it is very important to test all methods exhaustively. In this project you have two types of tests: unit and integration. Before digging in them, go ahead and perform the tests present in the dApp through the command `yarn test`.

### Unit test[​](#unit-test "Direct link to heading")

Unit tests check individual functions in the smart contract. Right now only rust implements unit testing.

*   🦀 Rust

contract/src/lib.rs

    loading...

[See full example on GitHub](https://github.com/near-examples/guest-book-rust/blob/main/contract/src/lib.rs#L63-L86#)

### Integration test[​](#integration-test "Direct link to heading")

Integration tests are generally written in JavaScript. They automatically deploy your contract and execute methods on it. In this way, integration tests simulate interactions between the contract and the users in a realistic scenario. You will find the integration tests for `hello-near` in `integration-tests/`.

*   🌐 JavaScript

integration-tests/src/main.ava.ts

    loading...

[See full example on GitHub](https://github.com/near-examples/guest-book-js/blob/master/integration-tests/src/main.ava.ts#L39-L59#)

'''
'''--- Registry-dApp-NEAR.md ---
In this tutorial we will be building a complete dApp for the NEAR Registry. NEAR Registry will allow you to track popular content just like Hacker News. Anyone can post an entry to the Registry. Upvoting the content requires you to connect using your NEAR wallet and attach NEAR to the entry. The Registry is sorted based on the NEAR attached to the entries. The same logic can be extended for any other type of registry.

Requirements[

](#requirements)
===============================

*   A NEAR testnet account: [https://wallet.testnet.near.org/](https://wallet.testnet.near.org/)
*   [Nodejs](https://nodejs.org/en/download/) v14 LTS or higher installed
*   [yarn](https://yarnpkg.com/) installed

Setup[

](#setup)
=================

`git clone https://github.com/viraja1/near-registry.git cd near-registry yarn install yarn test`

Exploring The Code[

](#exploring-the-code)
===========================================

1.  The backend code is present in the `/assembly` folder and gets deployed to the NEAR blockchain when you run `yarn deploy`. This sort of code that runs on a blockchain is called a "smart contract". [Learn more about NEAR smart contracts](https://docs.nearprotocol.com/docs/roles/developer/contracts/assemblyscript).
2.  The backend test code is present in the `/assembly/__tests__/` folder. We can test the backend code using the command `yarn test`.
3.  The frontend code is present in the `/src` folder. It uses near-api-js which is a JavaScript/TypeScript library for development of decentralized applications on the NEAR platform. It works in conjunction with NEAR RPC endpoints to help you connect your application to the NEAR blockchain. [Learn more about NEAR Frontend](https://docs.near.org/docs/api/naj-quick-reference).

NEAR smart contracts can be written in Rust or AssemblyScript. For NEAR Registry we will be using AssemblyScript, which is a dialect of TypeScript that compiles to WebAssembly (WASM).

Contracts are a named collection of exported functions that have access (via **near-sdk-as**) to their execution context (sender, receiver, block height, etc.) as well as storage services (key-value pair and convenience collections like Map, Vector and Dequeue), logging services and some utility functions.

To keep things organized, contracts can use one or more data objects which are commonly added to the model.ts file. All contracts and models must explicitly import the features of the NEAR SDK they intend to use.

**assembly/model.ts**

`import {context, u128, PersistentVector} from "near-sdk-as"; /**  * Exporting a new class Entry so it can be used outside of this file. */ @nearBindgen export class Entry {   sender: string;   constructor(public title: string, public description: string, public url: string, public id: i32, public votes: u128) {     this.sender = context.sender;   } } /**  * collections.vector is a persistent collection. Any changes to it will * be automatically saved in the storage. * The parameter to the constructor needs to be unique across a single contract. * It will be used as a prefix to all keys required to store data in the storage. */ export const entries = new PersistentVector<Entry>("entries");`

In the above `models.ts` file, we define a new custom type named Entry (primitive types like integers, strings and bool are always available by default). Since models are just AssemblyScript classes, they support custom constructors. Each entry has sender, title, description, url, id and votes. Each of these is associated with a specific type and is declared as public. In the constructor, we define the sender as **context.sender**. The context object provides context for contract execution including information about the transaction sender, blockchain height, and attached deposit available for use during contract execution.

At the end, we define that entries is a PersistentVector (collection) of type Entry. The PersistentVector writes and reads from storage, abstracting away a lot of what you might want to add to the storage object. It wraps the Storage class with convenience methods so you must always use a unique storage prefix for different collections to avoid data collision. PersistentVector acts like an array. To create entries, we use the syntax `new PersistentVector<Entry>("entries")`. The vector supports the methods like push, pop and length.

**assembly/main.ts**

`import {Entry, entries} from './model'; import {context, u128} from "near-sdk-as"; // --- contract code goes below /**  * Adds a new entry under the name of the sender's account id. * NOTE: This is a change method, which means it will modify the state. * But right now we don't distinguish them with annotations yet. */ export function addEntry(title: string, description: string, url: string): void {   // Creating a new entry and populating fields with our data   const entry = new Entry(title, description, url, entries.length, u128.fromU64(0));   // Adding the entry to end of the the persistent collection   entries.push(entry); } /**  * Up vote an entry using attachedDeposit * NOTE: This is a change method, which means it will modify the state. * But right now we don't distinguish them with annotations yet. */ export function upVoteEntry(index: i32): void {   const entry = entries[i32(index)];   entry.votes = u128.add(entry.votes, context.attachedDeposit);   entries[i32(index)] = entry; } /**  * Returns an array of entries. * NOTE: This is a view method, which means it does not modify the state. */ export function getEntries(): Entry[] {   const result = new Array<Entry>(entries.length);   for (let i = 0; i < entries.length; i++) {     result[i] = entries[i];   }   return result; }`

Contract function calls are stateless. Any state that you want to save to the blockchain needs to be explicitly saved by interacting with the storage object (such as **entries**). In the `main.ts` file, the contract functions like `addEntry`, `upVoteEntry` and `getEntries` are defined. Function declarations follow standard AssemblyScript conventions, including the parameters they take, optional arguments and return values.

There are two types of functions that can interact with the blockchain -- "view" functions and "change" functions. The difference, however, does not exist on the contract level. View functions like `getEntries` do not modify the state of the blockchain. Change functions like `addEntry` and `upVoteEntry` do modify the state.

In the `addEntry` function, we create a new Entry and add it to the entries PersistentVector using the push method. In the `upVoteEntry` function, we first fetch the entry from the entries PersistentVector using the index. Then we increment the entry votes using context.attachedDeposit. Then we update the entries PersistentVector using the index.

Unit tests[

](#unit-tests)
===========================

**assembly/\_\_tests\_\_/registry.spec.ts**

To make sure our smart contract works as expected, we have written the following unit tests. They test various cases like adding an entry, upvoting an entry, retrieving entries and attaching a deposit to a contract call. Use the command `yarn test` to run the test suite, it will then show the results on the console.

`import {addEntry, getEntries, upVoteEntry} from '../main'; import {Entry, entries} from '../model'; import {VMContext, Context, u128} from 'near-sdk-as'; function createEntry(title: string, description: string, url: string): Entry {   return new Entry(title, description, url, 0, u128.fromU64(0)); } const entry = createEntry('Near Protocol - Infrastructure for Innovation',   'NEAR is an open source platform that accelerates the development of decentralized applications.',   'https://near.org/'); describe('entries tests', () => {   afterEach(() => {     while (entries.length > 0) {       entries.pop();     }   });   it('adds a entry', () => {     addEntry('Near Protocol - Infrastructure for Innovation',       'NEAR is an open source platform that accelerates the development of decentralized applications.',       'https://near.org/');     expect(entries.length).toBe(       1,       'should only contain one entry'     );     expect(entries[0].url).toStrictEqual(       'https://near.org/',       'url matches'     );   });   it('check up vote', () => {     addEntry('Near Protocol - Infrastructure for Innovation',       'NEAR is an open source platform that accelerates the development of decentralized applications.',       'https://near.org/');     expect(entries[0].votes.toString()).toStrictEqual(u128.fromU32(0).toString(),       'entry should have 0 vote'     );     VMContext.setAttached_deposit(u128.from('10000000000000000000000'));     upVoteEntry(i32(0));     expect(entries[0].votes.toString()).toStrictEqual(u128.from('10000000000000000000000').toString(),       'entry should have a vote'     );   });   it('retrieves entries', () => {     addEntry('Near Protocol - Infrastructure for Innovation',       'NEAR is an open source platform that accelerates the development of decentralized applications.',       'https://near.org/');     const entriesList = getEntries();     expect(entriesList.length).toBe(       1,       'should be one entry'     );     expect(entriesList).toIncludeEqual(       entry,       'entries should include:\n' + entry.toJSON()     );   }); }); describe('attached deposit tests', () => {   beforeEach(() => {     VMContext.setAttached_deposit(u128.fromString('0'));     VMContext.setAccount_balance(u128.fromString('0'));   });   it('attaches a deposit to a contract call', () => {     log('Initial account balance: ' + Context.accountBalance.toString());     addEntry('Near Protocol - Infrastructure for Innovation',       'NEAR is an open source platform that accelerates the development of decentralized applications.',       'https://near.org/');     VMContext.setAttached_deposit(u128.from('10'));     log('Attached deposit: 10');     log('Account balance after deposit: ' + Context.accountBalance.toString());     expect(Context.accountBalance.toString()).toStrictEqual(       '10',       'balance should be 10'     );   }); });`

Deploying the smart contract[

](#deploying-the-smart-contract)
===============================================================

Every smart contract on NEAR has its [own associated account](https://docs.nearprotocol.com/docs/concepts/account). When running `yarn dev` to deploy, the smart contracts are deployed to the live NEAR testnet with a throwaway account. To make the deployment permanent, use the following steps:

Install the NEAR CLI[

](#install-the-n-e-a-r-c-l-i)
----------------------------------------------------

This command will install the NEAR CLI globally:

`npm install --global near-cli`

Then ensure that it is installed properly using the following command

`near --version`

Create an account for the contract[

](#create-an-account-for-the-contract)
---------------------------------------------------------------------------

Visit [NEAR Wallet](https://wallet.testnet.near.org/) and make a new account. You'll be deploying these smart contracts to this new account.

Now authorize via NEAR CLI for this new account, then follow the instructions to complete the process:

`near login`

Deploy with yarn[

](#deploy-with-yarn)
---------------------------------------

`yarn deploy`

As you can see in `package.json`, this builds & deploys smart contracts to NEAR testnet.

`{     "build": "yarn build:contract",     "build:contract": "asb",     "build:contract:debug": "asb --target debug",     "deploy": "yarn build && near deploy",     "dev": "yarn build:contract:debug && near dev-deploy",     "test": "yarn build:contract:debug && asp" }`

Take note of the smart contract account id from the console and update it in `src/config.js`.

Run the Frontend locally[

](#run-the-frontend-locally)
=======================================================

To see the frontend as it will appear after deployment, we need to use the local development server. Run the following commands from the `near-registry` directory:

`cd src yarn install yarn start`

Now you can visit [http://localhost:1234](http://localhost:1234) in your browser to test the NEAR Registry frontend and smart contracts deployed on the NEAR testnet.

Deploy the Frontend using netlify[

](#deploy-the-frontend-using-netlify)
=========================================================================

When you are happy with the looks and functionality of the dApp, you can deploy to a remote server. Run the following commands from the `near-registry` directory:

`cd src yarn build yarn global add netlify-cli netlify login netlify deploy --prod`

You must follow the instructions given by the netlify CLI and specify `./dist` as the publish directory.

Screenshots[

](#screenshots)
=============================

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/near_registry_1.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/near_registry_1.png)

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/near_registry_2.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/near_registry_2.png)

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/near_registry_3.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/near_registry_3.png)

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/near_registry_4.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/near_registry_4.png)

App Link (NEAR Testnet)[

](#app-link-n-e-a-r-testnet)
======================================================

[https://near-registry.netlify.app/](https://near-registry.netlify.app/)

Conclusion[

](#conclusion)
===========================

Congratulations! We have successfully deployed the NEAR Registry smart contract on the NEAR testnet. We have also tested the smart contracts by writing the test cases. We have then interacted with the smart contracts using the React frontend.

References[

](#references)
===========================

*   NEAR Guest Book - [https://github.com/near-examples/guest-book/](https://github.com/near-examples/guest-book/)
*   NEAR Smart Contract Docs - [https://docs.nearprotocol.com/docs/roles/developer/contracts/assemblyscript](https://docs.nearprotocol.com/docs/roles/developer/contracts/assemblyscript)
*   NEAR Frontend Docs - [https://docs.near.org/docs/api/naj-quick-reference](https://docs.near.org/docs/api/naj-quick-reference)

About the Author[

](#about-the-author)
=======================================

'''
'''--- Stake-Account-Storage-Standard-(NEP-145)-implementation.md.md ---
#### Account Storage Standard (NEP-145)

Complete guide to NEAR's new account storage standard

Near

IntermediateSmart contractsRust1 hour

Written by Oysterpack

Show Table of Contents

[Storage staking](https://docs.near.org/docs/concepts/storage-staking) is an issue that needs to be addressed by any multi-user contract that allocates storage for the user on the blockchain. This issue first arose while designing the [Fungible Token Core Standard - NEP-141](https://learn.figment.io/tutorials/2-fungible-token#what-does-account-registration-have-to-do-with-fungible-tokens). Once NEP-141 was finalized, the NEAR community circled back to work on this problem. In this tutorial, I will summarize the lengthy [online discussion](https://github.com/near/NEPs/discussions/145) and present to you the fruits of our labor.

Motivation: There Is No Free Storage[

](#motivation-there-is-no-free-storage)
==============================================================================

You can't get something for nothing. Long term contract state storage on the blockchain must be paid for. On the NEAR platform long term storage is paid for using a process called [storage staking](https://docs.near.org/docs/concepts/storage-staking). The contract is responsible to stake NEAR to pay for the contract's storage usage. The NEAR amount that is used for storage staking is effectively locked and cannot be transferred or used to pay for gas. Storage staking costs are the most expensive costs to consider for the contract on NEAR. If storage costs are not managed properly, then they can [break the bank](https://docs.near.org/docs/concepts/storage-staking#the-million-cheap-data-additions-attack) for the contract.

About "Account Storage Standard (formerly Account Registration)"[

](#about-account-storage-standard-formerly-account-registration)
-----------------------------------------------------------------------------------------------------------------------------------

If you happened to follow the [online discussion](https://github.com/near/NEPs/discussions/145), it started as "Account Registration". As we dove deeper, the discussion evolved into "Account Storage". The two are related, but with a different focus. The discussion was shifted towards account storage to focus on the core problem we were trying to solve with [storage staking](https://docs.near.org/docs/concepts/storage-staking) for multi-user contracts. Account registration is related but a separate concern, which is to be continued in future discussions ...

Account Storage API[

](#account-storage-a-p-i)
-----------------------------------------------

On NEAR, the contract is responsible to pay for its long term persistent storage. Thus, multi-user contracts should be designed to pass on storage costs to its user accounts. The account storage API provides the following:

1.  Accounts can lookup the minimum required account storage balance for the initial deposit in order to be able to use the contract.
2.  Accounts can deposit NEAR funds into the contract to pay for storage for either itself or on behalf of another account. The initial deposit for the account must be at least the minimum amount required by the contract.
3.  Account storage balances can be looked up. The amount required to pay for the account's storage usage will be locked up in the contract. Any storage balance above storage staking costs is available for withdrawal.
4.  Accounts can withdraw NEAR from the account's storage available balance.

Out of Scope[

](#out-of-scope)
-------------------------------

*   How to close the account and be able to withdraw all funds.
*   How the contract should account for changes in price for storage on the NEAR blockchain over time.

Quick API Overview[

](#quick-a-p-i-overview)
=============================================

[![](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-account-storage-api.png)](https://github.com/figment-networks/learn-tutorials/raw/master/assets/oysterpack-smart-account-storage-api.png)

**NOTES**

*   API functions are specified using the lowest common denominator with the goal of being programming language neutral (as much as possible)
*   String type is used as the de facto platform neutral type - but we will be leveraging Rust's type system when building the smart contract implementation
    *   When interacting with the contract, all amounts and balances MUST be unsigned integers in yoctoNEAR.
*   All account storage API functions are namespaced using a prefix naming convention (`account_`)
*   `#[payable]` implies that the function supports NEAR to be attached to the function call
*   API functions are tagged as either _**change methods**_ or _**view methods**_. This is from the [NEAR JSON RPC API](https://docs.near.org/docs/roles/developer/contracts/api) perspective.
    *   Cross contract calls always require gas regardless of whether the function call being invoked is a _**view method**_ or _**change method**_

**Domain Model**

`class AccountStorageBalance {   total: string;   available: string; }`

*   `total` represents the account's total storage balance in yoctoNEAR
*   `available` represents portion of the account's total balance that is available for withdrawal

**Function**

`#[payable] function storage_deposit(account_id: string|null): AccountStorageBalance;`

_change method_

Used by accounts to deposit funds to pay for account storage staking fees. This function supports 2 deposit modes:

1.  **self deposit** (`account_id` is not specified): predecessor account is used as the account
2.  **third party deposit** (`account_id` is valid NEAR account ID): the function caller is depositing NEAR funds for the specified `account_id`

If this is the initial deposit for the account, then the deposit must be enough to cover the minimum required balance. If the attached deposit is more than the required minimum balance, then the funds are credited to the account storage available balance.

**Example Use Cases**

1.  In order for the account to hold tokens, the account must first have enough NEAR funds deposited into the token contract to pay for the account's storage staking fees. The account can deposit NEAR funds for itself into the token contract, or another contract might have deposited NEAR funds into the token contract on the account's behalf to pay for the account's storage staking fees.
2.  Account's may use the blockchain to store data that grows over time. The account can use this API to deposit additional funds to pay for additional account storage usage growth.

**Arguments**

*   `account_id` - optional NEAR account ID. If not specified, then predecessor account ID will be used.

**Returns**

The account's updated storage balance.

**Panics**

*   If the attached deposit is less than the minimum required account storage fee on the initial deposit.
*   If `account_id` is not a valid NEAR account ID

**Function**

`#[payable] function storage_withdraw(amount: string|null): AccountStorageBalance;`

_change method_

Used to withdraw NEAR from the predecessor account's storage available balance. If amount is not specified, then all of the account's storage available balance will be withdrawn.

The attached yoctoNEAR will be refunded with the withdrawal transfer.

The account is required to attach exactly 1 yoctoNEAR to the function call to prevent restricted function-call access-key calls.

**Arguments**

*   `amount` - the amount to withdraw from the account's storage available balance expressed in yoctoNEAR

**Returns**

The account's updated storage balance.

**Panics**

*   If the attached deposit does not equal 1 yoctoNEAR
*   If the account is not registered with the contract
*   If the specified withdrawal amount is greater than the account's available storage balance

**Function**

`function storage_minimum_balance(): string;`

_view method_

Used to look up the minimum balance required for the initial deposit.

**Returns**

Amount in yoctoNEAR

**Function**

`function storage_balance_of(account_id: string): AccountStorageBalance;`

_view method_

Used to lookup the account storage balance for the specified account. If the account is unknown to the contract then the total account storage balance returned will be zero.

**Panics**

*   If `account_id` is not a valid NEAR account ID

Conclusion[

](#conclusion)
===========================

Overall, the Account Storage API itself is pretty straight forward. The key is to know its purpose and what problem it is trying to solve. Let's recap:

*   We discussed why contract storage costs must be carefully managed and accounted for by the contract.
*   We learned about how [storage staking](https://docs.near.org/docs/concepts/storage-staking) works on NEAR and how it impacts multi-user contracts.
*   We reviewed the new standard Account Storage API (NEP-145) in detail.

'''
'''--- cross-contract-calls.md ---
Introduction[

](#introduction)
===============================

At some point, you might want to call functions on existing contracts. This is called a _cross contract call_. There are plenty of reasons to do this:

*   You want to leverage a code library that others have written and released
*   You want your app to integrate with other contracts that have some transferable state (For instance, a game that has transferable inventory)
*   You want to build a bot that interacts with existing contracts in some way

Cross contract calls are really similar to calling an external API in the web 2.0 context.

In this tutorial, we will build a very simple example to get you up and running with cross contract calls.

Description[

](#description)
=============================

We're going to create two simple contracts:

*   `Calculator` this contract will have the calculation that we want to write for anyone to call
*   `Calculator Caller` this contract (no surprise) will call the calculation available in the other contract

For this example, we'll only implement the `add` functionality, but already we've got a problem! The accounting department at Super Evil Mega Corp sent all these numbers as strings. To make things worse, we don't know how long these strings are going to be. Why this is a problem: the largest integer that JavaScript can deal with is [9007199254740991](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/MAX_SAFE_INTEGER). To help out everyone who wants to add long numbers together, we're going to deploy a contract that people can incorporate into their own calculators.

Step 1 - Create a new Token Contract Project in Gitpod[

](#step-1-create-a-new-token-contract-project-in-gitpod)
=================================================================================================================

In a new browser tab or window:

*   Open a new Token Contract Project in [Gitpod](https://gitpod.io/#https://github.com/near-examples/token-contract-as)

When this opens in GitPod, the code will generate a unique NEAR account for this project and build then deploy the template files. You can take a look at what we're starting with by clicking "Open Browser" to see the token example running.

This sample project has a token smart contract and also some JavaScript tests that invoke smart contract functions. You can try running these tests right away to see the code interacting with the blockchain.

In Gitpod:

*   click **Terminal** >> **New Terminal**

In the new tab that opens at the bottom of Gitpod

*   type `yarn jest` in the command prompt

Once finished, the tests running in your terminal will appear like this:

[![Default Token Contract Test ](https://docs.near.org/docs/assets/default-token-contract-test.png)](https://docs.near.org/docs/assets/default-token-contract-test.png)

Note that `test-account-XXXXXXXXX_tTIMESTAMP-XXXXXXX` here is an automatically generated NEAR account for this particular project. Don't be distracted by these details, just compare the developer log output with the statements in the file `src/test.js`.

We are not going to keep any of the code from this template. It's just there as a starting point.

Step 2 - Write the Calculator contract[

](#step-2-write-the-calculator-contract)
=================================================================================

We're interested in writing only one function for this example. A function that takes in two strings `a` and `b` and returns the result of adding them together as a string.

In the file `assembly/main.ts` :

*   Replace the **entire contents of the file** with the code below _(note: this code implements addition of two large numbers as we do on paper)_

`import { context, storage, logging } from "near-sdk-as"; export function addLongNumbers(a: string, b: string): string {   // sends logs to the terminal of the contract placing call and the Near Explorer   logging.log("-------------------------------------------------------")   logging.log('Contract Called : ' + context.contractName)   logging.log('Contract Signer : ' + context.predecessor)   logging.log("- - - - - - - - - - - - - - - - - - - - - - - - - - - -")   logging.log("Caculating : " + a + " + " + b)   // Similar to long addition by hand, we start with the least significant digits first   const aReversed = a.split("").reverse();   const bReversed = b.split("").reverse();   // We initialize our resultant variable to be one more than the largest number's length   const maxLength = max(a.length, b.length);   let resultArray = new Array<String | null>(maxLength + 1);   let result = "";   let carry = 0;   // Loop through each digit adding the value to the other number, if it exists   for (let i = 0; i < maxLength; ++i) {     let aDigit = (i < a.length) ? U32.parseInt(aReversed[i]) : 0;     let bDigit = (i < b.length) ? U32.parseInt(bReversed[i]) : 0;     let digitSum = aDigit + bDigit + carry;     // Keep track of the carry amount     if (digitSum >= 10) {       carry = 1;       digitSum -= 10;     } else {       carry = 0;     }     resultArray[i] = digitSum.toString();   }   // If the final addition has a carry, add it to the extra slot we initialized for it   if (carry > 0) {     resultArray[maxLength] = carry.toString();   }   // Reverse again and combine the values for the final result   let reversedResultArray = resultArray.reverse();   // More terminal / Near Explorer logs   logging.log(">>> RESULT : " + reversedResultArray.join(""))   logging.log("-------------------------------------------------------")   return reversedResultArray.join(""); }`

Now that we've modified files in our assembly folder we will need to re-deploy the contract.

In your terminal windows:

*   Select the first terminal tab on the left that has localhost server running
*   Hold `CTRL + C` to stop the server and display the command prompt
*   Type `yarn dev` to rebuild and redeploy your modified contract

That's it for our `Calculator` for now.

Step 3 - Write some tests for the contract[

](#step-3-write-some-tests-for-the-contract)
=========================================================================================

It's a good habit to test code as soon as we've finished writing it, so that's exactly what we're going to do.

In the file `src/test.js` :

*   Replace **everything in the file** with the code below

After that is complete:

*   Click **File** >> **Save All** to save your changes

`describe("Calculator", function() {   let near;   let contract;   let alice;   let bob = "bob.near";   let eve = "eve.near";   jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000;   // Common setup below   beforeAll(async function () {     near = await nearAPI.connect(nearConfig);     accountId = nearConfig.contractName;     contract = await near.loadContract(accountId, {       // View methods are read only. They don't modify the state, but usually return some value.       viewMethods: [],       // Change methods can modify the state. But you don't receive the returned value when called.       changeMethods: ["addLongNumbers"],       sender: nearConfig.contractName     });     window.near = near;   });   // Multiple tests can be described below. Search Jasmine JS for documentation.   describe("simple", function() {     beforeAll(async function() {     // There can be some common setup for each test.     });     it("adds one digit", async function() {       const params = {         a: "1",         b: "3"       };       const result = await contract.addLongNumbers(params);       expect(result).toBe("4");     });     it("should work with first string longer", async function() {       const params = {         a: "10",         b: "3"       };       const result = await contract.addLongNumbers(params);       expect(result).toBe("13");     });     it("should work with second string longer", async function() {       const params = {         a: "4",         b: "15"       };       const result = await contract.addLongNumbers(params);       expect(result).toBe("19");     });     it("should work with carry", async function() {       const params = {         a: "19",         b: "22"       };       const result = await contract.addLongNumbers(params);       expect(result).toBe("41");     });     it("should work when result is one digit longer than largest input", async function() {       const params = {         a: "91",         b: "22"       };       const result = await contract.addLongNumbers(params);       expect(result).toBe("113");     });     it("should work with really large input", async function() {       const params = {         a: "29348756231984613809465238956138947136497182364018246710289467102946710289467198046",         b: "1"       };       const result = await contract.addLongNumbers(params);       expect(result).toBe("29348756231984613809465238956138947136497182364018246710289467102946710289467198047");     });   }); });`

Now lets run your new tests!

*   type `yarn jest` in the command prompt

Once finished, the completed test in your terminal will appear like this:

[![Jest tests running for Calculator Contract](https://docs.near.org/docs/assets/jest-tests-for-calculator-contract.png)](https://docs.near.org/docs/assets/jest-tests-for-calculator-contract.png)

Just make a mental note that the logs, "Contract Called" and the "Contract Signer" are the same. This will be important later.

Normally, we would create a UI at this point, but since we're calling this from elsewhere, let's move on the second contract.

Step 4 - Create a new contract for Calculator Caller[

](#step-4-create-a-new-contract-for-calculator-caller)
=============================================================================================================

Keep the tab open that you've been working on, you're going to need the ID of the contract you just created later.

The rest of the ID is the prefix "dev-" to be something like `dev-159372XXXX-XXXXXXX`. In fact the ID of the contract is just the NEAR account created for the contract by Gitpod automatically.

You can read more about [accounts on the NEAR platform here](https://docs.near.org/docs/concepts/account).

So let's make another smart contract. Following the same steps as before in a _new_ tab or window...

*   Open another new Token Contract Project in [Gitpod](https://gitpod.io/#https://github.com/near-examples/token-contract-as)
*   You should see a **Create Fresh Workspace** box at the top of your window
*   click **Create** in the upper right hand corner

[![Create fresh workspace](https://docs.near.org/docs/assets/gitpod-create-fresh-workspace.png)](https://docs.near.org/docs/assets/gitpod-create-fresh-workspace.png)

We're doing this because we need to create an entirely separate contract deployed at a different address to demonstrate the capabilities of cross contract calls.

Step 5 - Write the Calculator Caller code[

](#step-5-write-the-calculator-caller-code)
=======================================================================================

We want to implement code that actually passes the numbers over to the contract we're calling. Here we're going to do this by creating a single `callAddNumbers` function and add the piping which allows us to make this function work.

We're going to need a few things to make this happen:

*   To send two pieces of data (the two numbers we want to add) from one contract to another, we'll create a new _model_ for our contract to use. `AddArgs` will be a class that we use to encode the arguments we're sending.
*   Cross contract calls are always asynchronous so, to capture the return value from the other contract, we'll take advantage of the native `ContractPromise` class from `near-sdk-as`.
*   To `CalculatorAPI`, a class we'll create that will send the numbers we want to add to the other contract through an `add` method
*   `callAddNumbers`, function which will call the `CalculatorAPI` method we create to add the numbers

Let's start by creating the model first.

Create a new file `assembly/model.ts`:

*   Click on the `assembly` folder on the left hand side in your explorer
*   Then click **File** >> **New File**
*   Enter `model.ts` and then click **OK**
*   **Copy/Paste** the code below into this new file
*   Click **File** >> **Save**

`@nearBindgen export class AddArgs {   a: string;   b: string; }`

This will allow us to encode arguments to send between contracts as a single value.

Next we'll create the API that we can use to call the contract we've previously deployed.

In the file `assembly/main.ts` replace the **entire contents of the file** with the following code:

`import { context, storage, logging, ContractPromise } from "near-sdk-as"; import { AddArgs } from "./model";`

Notice that we're importing `AddArgs` from the model we just created using the syntax `"./model"` AND we're importing `ContractPromise` from `near-sdk-as`.

Here, we're creating a single method `add` that takes the strings we want to add and returns a `ContractPromise`.

We're also using the `AddArgs` model we created to package the strings we want to send to the other contract. When we call `args.encode()` it's a lot like something like `JSON.stringify(args)` to allow us to send this data.

_In order to create this `ContractPromise`, we need to know:_

*   The ID of the contract that we created before. **You'll need to replace this with your own.**
*   Whatever function we're trying to call on the `Calculator` contract.

In the file `assembly/main.ts` append the following code to the file:

`const OTHER_CONTRACT = "dev-REPLACE_THIS_IDENTIFIER"; export class CalculatorApi {   add(a: string, b: string): ContractPromise {     let args: AddArgs = { a, b };     let promise = ContractPromise.create(OTHER_CONTRACT, "addLongNumbers", args.encode(), 100000000000000);     logging.log("OTHER_CONTRACT: " + "(" + OTHER_CONTRACT + ")")     return promise;   } }`

_(For more info on making cross-contract calls using `ContractPromise`, check out_ [_ContractPromise_](https://near.github.io/near-sdk-as/classes/_sdk_core_assembly_contract_.contractpromise.html) _and_ [_ContractPromiseResult_](https://near.github.io/near-sdk-as/classes/_sdk_core_assembly_contract_.contractpromiseresult.html)

As a reminder, using the previous contract (the tab you kept open earlier), find the ID of the contract. You will use this to replace `dev-REPLACE_THIS_IDENTIFIER`.

You can find your contract ID stored in `neardev/dev-account.env`. In addition, you will see your contract ID displayed in the first terminal window with the running server. Towards the bottom there will be a line that states: "Done deploying to dev-1594333XXXXXX-XXXXXXX".

Next, we're going to use the `CalculatorApi` we just created.

In the file `assembly/main.ts` append the following code to the file:

`export function calculate(a: string , b: string): void {   let calculator = new CalculatorApi();   let promise = calculator.add(a, b);   promise.returnAsResult(); }`

You may notice this function returns `void`, which is a bit confusing because the contract is returning a promise. This is because it's calling a function elsewhere and the compiler thinks it's void.

(In future releases this will be changed.)

Now save your changes and redeploy the contract

*   Click **File** >> **Save**

Then navigate to your terminal windows

*   Select the first terminal tab on the left that has localhost server running
*   Hold `CTRL + C` to stop the server and display the command prompt
*   Type `yarn dev` to rebuild and redeploy your modified contract

Step 6 - More tests![

](#step-6-more-tests)
============================================

Let's make sure things are working as expected.

In the file `src/test.js`:

*   Replace the **entire contents of the file** with the code below

`const getConfig = require('./config'); let nearConfig = getConfig("development"); require('dotenv').config({ path: '/workspace/token-contract-as/neardev/dev-account.env' }) describe("CalculatorAPI", function() {   let near;   let contract;   jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000;   // Common setup below   beforeAll(async function () {     near = await nearAPI.connect({     deps: {      keyStore: new nearAPI.keyStores.UnencryptedFileSystemKeyStore('../../../home/gitpod/.near-credentials')     },     ...nearConfig   })     accountId = process.env.CONTRACT_NAME;     contract = await near.loadContract(accountId, {     // NOTE: This configuration only needed while NEAR is still in development     // View methods are read only. They don't modify the state, but usually return some value.     viewMethods: [],     // Change methods can modify the state. But you don't receive the returned value when called.     changeMethods: ["calculate", "addLongNumbers"],     sender: process.env.CONTRACT_NAME     });   });   // Multiple tests can be described below. Search Jasmine JS for documentation.   describe("simple", function() {     beforeAll(async function() {     // There can be some common setup for each test.     });     it("add one digit", async function() {       const params = {         a: "1",         b: "99"       };       const result = await contract.calculate(params);       expect(result).toBe("100");     });   }); });`

After that is complete:

*   Click **File** >> **Save All** to save your changes

Now let's test it out!

In Gitpod:

*   click **Terminal** >> **New Terminal**

In the new tab that opens at the bottom of Gitpod, type `yarn jest` in the command prompt.

You should see a successful test that looks something like this:

[![Cross contract call Jest test](https://docs.near.org/docs/assets/cross-contract-call-jest-test.png)](https://docs.near.org/docs/assets/cross-contract-call-jest-test.png)

Remember when we took a note that the 'Contract Called' and the 'Contract Signer' were the same in the test environment? Notice that they are different now! Can you figure out what this means?

Conclusion[

](#conclusion)
===========================

And we're done!

You can also view the details of your account & transactions by using the [Near Explorer](https://explorer.testnet.near.org/).

This is a simple example of a contract that calls another contract, but this opens up a lot of opportunities. Now, see if you can figure out how to build the frontend by checking out our [other tutorials](https://docs.near.org/docs/roles/developer/tutorials/introduction) and modifying `src/main.js` and `src/index.html`.

You're ready to cross as many contracts as you want! Happy coding! 🚀

If you had any difficulties following this tutorial or simply want to discuss NEAR tech with us you can [**join our community today**](https://figment.io/devchat)!

'''
'''--- crowd-funding-dapp-NEAR.md ---
In this tutorial, we will build a crowdfunding dApp on the NEAR blockchain. Our smart contract will be written in Rust and our frontend will be written in React.

The dApp will have the following functionalities:

*   Users logged in can post/create their own crowdfunding project
*   View the list of crowdfunding projects
*   Users can donate to a crowdfunding project
*   Vote on a crowdfunding project

After we have implemented all the features in our smart contract, we will connect the smart contract to our react frontend which looks like this

[![project image](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/projectimg.png?raw=true)](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/projectimg.png?raw=true)

Prerequisites📋[

](#prerequisites)
===================================

To follow along and complete this tutorial, you will need the basic knowledge of [React](https://reactjs.org/) and [Rust](https://www.youtube.com/watch?v=KDn_j48yoAo&t=581s).

Requirements[

](#requirements)
===============================

*   Install the [rust toolchain](https://www.rust-lang.org/tools/install).
*   [npx binary](https://www.npmjs.com/package/npx).
*   [Git](https://git-scm.com/downloads) and Node.js(v14+) installed
*   The [near-cli](https://docs.near.org/docs/tools/near-cli#installation)
*   [A NEAR account](https://docs.near.org/docs/develop/basics/create-account#creating-a-testnet-account)

As I mentioned earlier in the introduction, the smart contract for this dApp is written in Rust. If you are not familiar with Rust, you can take this [30 minutes crash course](https://www.youtube.com/watch?v=KDn_j48yoAo&t=581s).

Make sure you have everything installed from the requirements including near-cli and have a NEAR account

Overview[

](#overview)
=======================

We have looked at the things we need to install to follow along in this tutorial, now let’s look at the things we will be doing as the tutorial progresses. We will use the [npx](https://www.npmjs.com/package/npx) binary to scaffold our project with [create-near-app](https://github.com/near/create-near-app) which provides us with options of what to use for the frontend and backend. After scaffolding our project we will look at the file structure, write our smart contract and deploy and test that all functions are working, and connect to our React frontend.

Setting up our project[

](#setting-up-our-project)
===================================================

We set up our project with [create-near-app](https://github.com/near/create-near-app) by running the following command:

 `npx create-near-app --frontend=react --contract=rust crowdfundDapp  cd crowdfundDapp`

with the `--frontend=react` and `--contract=rust` options, we create our project to have a react frontend and a rust contract. After waiting a while for the command to install everything, we see this in our terminal:

[![create crowdfund](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/createcrowdfund.png?raw=true)](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/createcrowdfund.png?raw=true)

Now everything is successfully installed, and everything is ready to go, let’s look at what our file structure looks like.

File structure[

](#file-structure)
-----------------------------------

[![file structure](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/filestructure.png?raw=true)](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/filestructure.png?raw=true)

In our file structure, we have the `contract` folder, where we will be writing our contract specifically in the `src` directory. Then there is our `near-dev` folder that contains the configuration for deploying our contract in development mode and our `src` folder for our frontend. Looking closer into our contract folder:

[![project image](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/contract.png?raw=true)](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/contract.png?raw=true)

In the contract folder we have the `src` folder where we’ll be creating a `model.rs`, `lib.rs`, and `utils.rs` file. We already have the `lib.rs` file, so no need to create another one. The `cargo.toml` file contains information about our contract, including all the dependencies we need.

Building our contract[

](#building-our-contract)
=================================================

In the last section, we have seen how to set up our project and how our project is structured. Now let’s dive into building our contract.

How does our contract work[

](#how-does-our-contract-work)
-----------------------------------------------------------

Before building our contract, let’s discuss how our contract works, and the functions/endpoints we will call. In our contract, we want to be able to:

1.  Create a crowdfunding project - To do this we will need a `add_crowdfund` function, that when invoked will create a new crowdfunding project and add it to our array of crowdfunds.
2.  List all our crowdfunding project - To do this we will need a function `list_crowdfunds` to list all our crowdfunding projects
3.  Vote on a crowdfunding project - To do this, we will need a `add_vote` function to add a vote to our crowdfunding project.
4.  Donate to a crowdfunding project - To do this, we need a `add_donation` function that donates a certain amount of the NEAR token to the crowdfunding project

Create a `model.rs`, `lib.rs`, and `utils.rs` file in the `src` folder. In our `utils` file, we copy and paste the following code.

The `utils.rs` file contains some helpful functions and types we will be using as we build our contract, with some comments explaining what they do. Don’t get intimidated as you only need to copy and paste it into your `utils.rs` file

 `// utils.rs     use near_sdk::{         env,         PromiseResult,     };     /// == TYPES ====================================================================     /// Account Ids in Near are just strings.     pub type AccountId = String;     /// Gas is u64     pub type Gas = u64;     /// Amounts, Balances, and Money in NEAR are u128.     pub type Amount = u128;     pub type Balance = Amount;     pub type Money = Amount;     /// Timestamp in NEAR is a number.     pub type Timestamp = u64;     ///     /// == CONSTANTS ================================================================     ///     /// TODO: revist MIN_ACCOUNT_BALANCE after some real data is included b/c this     /// could end up being much higher     /// ONE_NEAR = unit of NEAR token in yocto Ⓝ (1e24)     pub const ONE_NEAR: u128 = 1_000_000_000_000_000_000_000_000 as u128;     /// XCC_GAS = gas for cross-contract calls, ~5 Tgas (teragas = 1e12) per "hop"     pub const XCC_GAS: Gas = 20_000_000_000_000;     /// MIN_ACCOUNT_BALANCE = 3 NEAR min to keep account alive via storage staking     pub const MIN_ACCOUNT_BALANCE: u128 = ONE_NEAR * 3;     /// == FUNCTIONS ================================================================     /// Converts Yocto Ⓝ token quantity into NEAR, as a String     pub fn asNEAR(amount: u128) -> String {         format!("{}", amount / ONE_NEAR)     }     /// Converts a quantity in NEAR into Yocto Ⓝ tokens     pub fn toYocto<D: Into<u128>>(amount: D) -> u128 {         ONE_NEAR * amount.into()     }     /// Asserts that the contract has called itself     pub fn assert_self() {         let caller = env::predecessor_account_id();         let current = env::current_account_id();         assert_eq!(caller, current, "Only this contract may call itself");     }     /// Asserts that only a single promise was received, and successful     pub fn assert_single_promise_success(){         assert_eq!(             env::promise_results_count(),             1,             "Expected exactly one promise result",         );         match env::promise_result(0) {             PromiseResult::Successful(_) => return,             _ => panic!("Expected PromiseStatus to be successful"),         };     }`

Create our models[

](#create-our-models)
-----------------------------------------

We can describe the model in our contract as a custom data container for defining new types. Just like the way we have primitive types, we can create our own custom types in our model that describe or are patterned to what we are building. The code for our `model.rs` file can be found below and we will explain what it does step by step

`// model.rs      use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};     #[allow(unused_imports)]     use near_sdk::{env, near_bindgen};     use near_sdk::serde::{Deserialize, Serialize};          use crate::utils::{         AccountId,         Money,         Timestamp     };     #[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]     #[serde(crate = "near_sdk::serde")]     pub struct Crowdfund{         id: i32,       pub creator: AccountId,         created_at: Timestamp,         title: String,         donation_target: u128,         pub total_donations: u128,        pub total_votes: i64,         description: String,        pub votes: Vec<String>     }          impl Crowdfund{         pub fn new(id:i32, title: String, donation_target:u128, description: String) -> Self {                          Crowdfund{                 id,                 creator: env::signer_account_id(),                 created_at: env::block_timestamp(),                 title,                 donation_target,                 total_donations: 0,                 total_votes : 0,                 description,                 votes: vec![],             }         }     }     #[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]     #[serde(crate = "near_sdk::serde")]     pub struct Donation {         amount: Money,         donor: AccountId,     }     impl Donation {         pub fn new() -> Self {                   Donation{             amount: env::attached_deposit(),             donor: env::predecessor_account_id(),             }         }       }`

Let’s breakdown what the code above is doing:

    `use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};     #[allow(unused_imports)]     use near_sdk::{env, near_bindgen};     use near_sdk::serde::{Deserialize, Serialize};`

Above we have the rust contract standard imports and can see the dependencies that are used in the `Cargo.toml` file. The dependencies that have to do with serialization which are `BorshDeserialize` and `BorshSerialize` are used to bundle our contract code and storage so it is ready for NEAR blockchain. The `use` statement before the dependencies just shows which dependencies we are using in this file.

`env` is used to log into your console or return some useful information like the signer’s account

   `// model.rs     use crate::utils::{         AccountId,         Money,         Timestamp     };`

Here, we just import some custom types we will be using from our `utils.rs` file. After this piece of code, we have our crowdfund `struct` which is crucial to our contract.

Crowdfund Struct[

](#crowdfund-struct)
---------------------------------------

A `struct` in rust is similar to classes in other languages. Structs kind of hold the state of the contract. Building our contract, our `struct` will be followed by an `impl`, where we write the core logic function of the contract.

`//model.rs     #[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]     #[serde(crate = "near_sdk::serde")]     pub struct Crowdfund{         id: i32,       pub creator: AccountId,         created_at: Timestamp,         title: String,         donation_target: u128,         pub total_donations: u128,        pub total_votes: i64,         description: String,        pub votes: Vec<String>     }`

We want to be able to add a new crowdfunding project, so the crowdfund `struct` above contains the fields of information a particular crowdfund project will have. We can see that each of the fields has a type. The last field is a type of vector, but we can just look at it as an array.

The keyword `pub` means that whatever we prefix it with is public and can be used externally

  `//model.rs     impl Crowdfund{         pub fn new(id:i32, title: String, donation_target:u128, description: String) -> Self {                          Crowdfund{                 id,                 creator: env::signer_account_id(),                 created_at: env::block_timestamp(),                 title,                 donation_target,                 total_donations: 0,                 total_votes : 0,                 description,                 votes: vec![],             }         }     }`

The block of code above is where we initialize our `Crowdund` model. The contract was initialized with some arguments and also contains some default data like the `creator` field which has its default as the signer account’s id. The `total_donations` and `total_votes` are also set to zero by default. The contract is also initialized with some arguments that we will provide when invoking the function to add a crowdfund. The arguments are:

*   `id`: A unique ID for each crowdfund
*   `title`: The title of our crowdfunding project
*   `donation_target`: the target amount for the crowdfunding project.
*   `description`: A little description of our crowdfunding project.

The following model we have in our `model.rs` file is:

`//model.rs     #[derive(Clone, Serialize, Deserialize, BorshDeserialize, BorshSerialize)]     #[serde(crate = "near_sdk::serde")]     pub struct Donation {         donor: AccountId,     }     impl Donation {         pub fn new() -> Self {                   Donation{             donor: env::predecessor_account_id(),             }         }       }`

For our donation `struct` we have a `donor` field we would like to store on the blockchain. Then we initialize the donation `struct` with the `donor` with the default value of the `predecessor_account_id()` which signifies the person that donated to the crowdfunding campaign. Now let's move over to our `lib.rs` file where we call the different functions that will make all the features for our crowdfunding dApp possible.

Adding a crowdfund project[

](#adding-a-crowdfund-project)
===========================================================

We have created our models in the model.rs file and we are now moving over to our `lib.rs` file where we will be writing the different functions we need to call to perform certain operations in the dApp. Before we get into the nitty-gritty of things let's look at some code we need available at the top of our `lib.rs` file.

  `mod models;   mod utils;   use crate::{       utils::{           AccountId,           ONE_NEAR,           assert_self,           assert_single_promise_success,       },       models::{           Crowdfund,           Donation       }   };   // To conserve gas, efficient serialization is achieved through Borsh (http://borsh.io/)   use near_sdk::{borsh::{self, BorshDeserialize, BorshSerialize}, Promise};   #[allow(unused_imports)]   use near_sdk::{env, PromiseIndex, near_bindgen};   near_sdk::setup_alloc!();`   

The first thing we do in our `lib.rs` file is import the `utils.rs` and `models.rs` modules which are also in the same `src` folder. After that, we signify what in particular we will be using in those modules with the `use` keyword, then finally the rust standard imports. Now to continue we need to create a contract struct

 `#[near_bindgen]     #[derive(Clone, Default, BorshDeserialize, BorshSerialize)]     pub struct Contract {         owner: AccountId,         crowdfunds: Vec<Crowdfund>,         donations: Vec<Donation>,     }`

The `#[near_bindgen]` before our contract `struct` is to allow easy compilation of our contract code into WebAssembly, so it is compatible and optimizable for the NEAR blockchain

In our contract `struct` we have the the `owner` field and then we have the `crowdfund` and `donation` field which are just vectors of their models `Crowdfund` and `Donation`. Next, we will have the `impl`

  `#[near_bindgen]     impl Contract{         #[init]         pub fn init(             owner: AccountId,         ) -> Self{             let crowdfunds: Vec<Crowdfund> = Vec::new();             let donations: Vec<Donation> = Vec::new();                  Contract{                 owner,                 crowdfunds,                 donations             }         }     }`

In our Contract `impl` the `#init` allows us to create a custom initialization of the contract with a function that takes in a parameter of `owner`. We construct a new, empty vector with the `Vec::new()`and assign it to `crowdfund` and `donations` respectively.

The vector will not be allocated until elements are pushed onto it.

The add\_crowdfund function[

](#the-add_crowdfund-function)
------------------------------------------------------------

After our initialization, we start writing our functions. The first function we have is the `add_crowdfund` function.

       `pub fn add_crowdfund(&mut self, title: String, donate:u128,description: String) {                          let id = self.crowdfunds.len() as i32;                          self.crowdfunds.push(Crowdfund::new(                 id,                 title,                 donate,                 description             ));             env::log("Added a new crowdfund".as_bytes());         }`

The `add_crowdfund` function accepts three parameters, `title`, `donate`, and `description` we will pass in when the function is called. We want to have a unique `id` for each crowdfunding project, so we create an `id` variable to the length of the total crowdfunds project we have in our vector. We have added a new Crowdfund project to our list of crowdfunding projects. So each time we call the `add_crowdfund` function, we update the blockchain state and a new crowdfund project is added to the list with the information we have provided as parameters. Finally, we log “Added a new crowdfund” to the blockchain.

Notice how we also passed in `&mut self` in our function?. It simply means we are passing on a mutable reference of `self` which points to our `Contract`

List all crowdfunding projects[

](#list-all-crowdfunding-projects)
===================================================================

We need to return all crowdfunding projects, so we create a function `list_crowdfunds` .

 `pub fn list_crowdfunds(&self) -> Vec<Crowdfund> {             assert_self();            let crowdfunds = &self.crowdfunds;            return crowdfunds.to_vec();         }`

When we call the function, we make use of the `assert_self` function from our `utils.rs` file, to make sure the contract calls itself, then we return our crowdfunds as a vector that displays an array of all our crowdfunding projects.

Voting a project[

](#voting-a-project)
=======================================

Assuming there is a project that really needs some support, the user can vote on that project. So in our contract, we added an `add_vote` function.

        `pub fn add_vote(&mut self, id:usize){             let crowdfund: &mut Crowdfund = self.crowdfunds.get_mut(id).unwrap();             let voter = env::predecessor_account_id();             crowdfund.total_votes = crowdfund.total_votes + 1;             env::log("vote submitted succesfully".as_bytes());             crowdfund.votes.push(voter);                      }`

We pass an `id` parameter to the `add_vote` function to determine the particular project we want to vote on. Then we can access the project by calling `.get_mut(id)` and passing in the id of the project. We set our voter to be the `predecessor_account_id()` and then we mutate our state with this line.

    `crowdfund.total_votes = crowdfund.total_votes + 1;`

This increments the `total_votes` field by 1, each time we call the function, then we add the voter to the votes vector, and we can see who has voted on that project.

Donate to a project[

](#donate-to-a-project)
=============================================

To donate to a particular project, we create an `add_donation` function and pass in the `id` of the project we want to donate to, and the amount of NEAR token we want to donate.

     `pub fn add_donation(&mut self, id:usize, amount:u128) {             let transfer_amount: u128 = ONE_NEAR * amount;             let crowdfund: &mut Crowdfund = self.crowdfunds.get_mut(id).unwrap();             crowdfund.total_donations = crowdfund.total_donations + transfer_amount;             self.donations.push(Donation::new());                        Promise::new(env::predecessor_account_id()).transfer(transfer_amount);           env::log("You have donated succesfully".as_bytes());         }`

Here we pass as a parameter, the `id` of the crowdfunding project and the `amount` we want to donate. We then add the donated amount to our current `total_donations` balance, and push a new donation each time we call the function and the amount in NEAR is transferred to the crowdfunding project owner.

Get total crowdfunds and donations count[

](#get-total-crowdfunds-and-donations-count)
=======================================================================================

Let’s add two more functions to our contract to determine the total crowdfunding projects we have and the total sum of donations a particular crowdfunding project has received.

    `pub fn crowdfund_count(&mut self) -> usize {             return self.crowdfunds.len();         }              pub fn get_total_donations(&mut self, id:usize) -> u128 {             let crowdfund: &mut Crowdfund = self.crowdfunds.get_mut(id).unwrap();             return crowdfund.total_donations;         }`

We have created two functions `crowdfund_count` that simply returns the length of our crowdfund vector and `get_total_donations` to return the total donations a particular crowdfund project has received.

Now that we are done with all the functions for this contract, it is time to deploy and invoke the functions in our contract to make sure everything is working fine, and that is what we will be doing in the next section

Deploying the smart contract🚀[

](#deploying-the-smart-contract)
=================================================================

Before we deploy our smart contract, let’s first login with the `near-cli` into the NEAR account we created.

**Login with `near-cli`**

Make sure you already have the `near-cli` installed, you can see the installation steps from the link in the prerequisites. Then run this command:

   `near login`

After login to the account we created, we see a successful message in the terminal.

Deploy the contract[

](#deploy-the-contract)
---------------------------------------------

To deploy our crowdfunding contract, we need to create an account for it. Since we have already created a testnet account, in my case `umavictor.testnet` , we can create a subaccount under `umavictor.testnet` to deploy the contract.

  `near create-account crowdfunddapp.umavictor.testnet --masterAccount umavictor.testnet`

[![sub account](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/createsubaccount.png?raw=true)](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/createsubaccount.png?raw=true)

In your case, the `umavictor` will be replaced by your own NEAR testnet account name you created

Once your sub-account is created, navigate to `src/config.js` and modify the line that sets the account name of the contract. Set it to the sub-account `id` you created above.

  `const CONTRACT_NAME = process.env.CONTRACT_NAME || 'crowdfunddapp.umavictor.testnet'`

we can finally deploy our contract. Since we use [create-near-app](https://github.com/near/create-near-app), deploying our contract is easy and can be done with the command

`near deploy`

[![deploy contract](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/crowdfunddeploy.png?raw=true)](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/crowdfunddeploy.png?raw=true)

we can see that after running the command, our contract was deployed successfully. yay!.

If you make a change in your contract, you can just delete the sub account with the command `near delete crowdfunddapp.umavictor.testnet umavictor.testnet`, and create it again.

Interact with our contract by calling contract methods[

](#interact-with-our-contract-by-calling-contract-methods)
===================================================================================================================

Now we can interact with our contract and make sure all our functions are doing what they are supposed to do. Let’s test out each function!.

Add Crowdfund project[

](#add-crowdfund-project)
-------------------------------------------------

Call `add_crowdfund` with the `near-cli`:

    `near call crowdfunddapp.umavictor.testnet add_crowdfund '{"title": "Eliots eye sight", "donate": 30, "description":"Raise funds for little Eliot to see again. Loss of sight was caused by an accident to the head"}' --accountId umavictor.testnet`

What the command above does is to call the contract deployed on `crowdfunddapp.umavictor.testnet`. On the contract, there is a method called `add_crowdfund` with three arguments provided and is signed by `umavictor.testnet`. In your terminal, you will see an output like this:

[![add crowdfund](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/addcrowdfund.png?raw=true)](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/addcrowdfund.png?raw=true)

Vote on a Crowdfund Project[

](#vote-on-a-crowdfund-project)
-------------------------------------------------------------

Call `add_vote` with the `near-cli`:

   `near call crowdfunddapp.umavictor.testnet add_vote '{"id":0}' --accountId umavictor.testnet`

this command increments the vote of the first crowdfunding project by one.

[![addvote](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/addvote.png?raw=true)](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/addvote.png?raw=true)

Donate to a crowdfunding project[

](#donate-to-a-crowdfunding-project)
=======================================================================

Call the `add_donate` method with the `near-cli`

 `near call crowdfunddapp.umavictor.testnet add_donation '{"id":0, "amount":1}' --accountId umavictor.testnet`

this command calls the `add_donation` method and 1 NEAR is sent to the crowdfund project.

List all crowdfunding projects[

](#list-all-crowdfunding-projects)
===================================================================

Call the `list_crowdfunds` method.

 `near call crowdfunddapp.umavictor.testnet list_crowdfunds --accountId umavictor.testnet`

This command lists all the crowdfunding projects to the terminal.

[![list crowdfunds](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/listcrowdfunds.png?raw=true)](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/listcrowdfunds.png?raw=true)

You can see the two crowdfund projects from the image and all the information we set. We have invoked the methods to see how they are working, let’s now build the react frontend

Building our frontend[

](#building-our-frontend)
=================================================

We are finally done building the smart contract. To connect and build our React frontend, we will be working on the `src` folder. This is not a React tutorial, so we will only touch on the important things. First, navigate to `utils.js` and update your change and view methods

`//utils.js   window.contract = await new Contract(window.walletConnection.account(), nearConfig.contractName, {         // View methods are read only. They don't modify the state, but usually return some value.         viewMethods: ['get_donation_count',"crowdfund_count"],         // Change methods can modify the state. But you don't receive the returned value when called.         changeMethods: ['add_crowdfund', 'add_vote','add_donation',"list_crowdfunds"],       })     }`

Take a look at the code in our `App.js`:

   `// App.js     import 'regenerator-runtime/runtime'     import { useEffect, useState } from 'react'     import ListCrowdfunds from './components/ListCrowdfunds'     import CreateCrowdfund from './components/CreateCrowdfunds'     import React from 'react'     import { login, logout } from './utils'     import './global.css'     import getConfig from './config'     const { networkId } = getConfig(process.env.NODE_ENV || 'development')          export default function App() {       const [crowdfunds, setCrowdfunds] = useState([])       const [toggleModal, setToggleModal] = useState(false)       function addProject() {         setToggleModal(!toggleModal)       }            useEffect(         () => {           // in this case, we only care to query the contract when signed in           if (window.walletConnection.isSignedIn()) {             // window.contract is set by initContract in index.js             window.contract.list_crowdfunds().then((crowdfundprojects) => {               const crowdfundList = [...crowdfundprojects]               setCrowdfunds(crowdfundList)             })           }         },         [],       )            // if not signed in, return early with sign-in prompt       if (!window.walletConnection.isSignedIn()) {         return (           <main>             <h1>Welcome to Paradis</h1>             <p style={{ textAlign: 'center' }}>               Click the button below to sign in:             </p>             <p style={{ textAlign: 'center', marginTop: '2.5em' }}>               <button onClick={login}>Sign in</button>             </p>           </main>         )       }       return (         // use React Fragment, <>, to avoid wrapping elements in unnecessary divs         <>           <header>             <div className="logo"></div>             <button className="link" style={{ float: 'right' }} onClick={logout}>               Sign out <span className="id">{window.accountId}</span>             </button>           </header>           <button onClick={addProject}>Add a project</button>           <main>             <CreateCrowdfund toggleModal={toggleModal} />             <section>               {crowdfunds.map((project, id) => {                 return (                   <div key={id}>                     <ListCrowdfunds project={project} />                   </div>                 )               })}             </section>           </main>         </>       )     }`

In the `App.js` file above, we import the configurations, utils, and components we will be using. We created our `crowdfunds` state which is an array of objects containing all our crowdfunding projects. In the `useEffect` hook, we call the `list_crowdfund` method from `window.contract` which has been set by `initContract` in the `index.js` file. We then set the crowdfunds state, using React’s `setState`.

Next, we check if a user is signed in, and if no user is signed in, we prompt them to.

[![Login](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/welcome.png?raw=true)](https://raw.githubusercontent.com/figment-networks/learn-tutorials/master/assets/welcome.png?raw=true)

Once signed in, we will see available projects we can donate to.

List Crowdfund component[

](#list-crowdfund-component)
-------------------------------------------------------

For our `App.js` component, we looped through all our crowdfunding projects and passed in the object prop to our `ListCrowdfunds` component. This is what our `ListCrowdfunds` component looks like.

  `// components/ListCrowdfunds.js     import React, { useState } from 'react'     const ONE_NEAR = 1_000_000_000_000_000_000_000_000     function ListCrowdfunds({ project }) {       const [donationAmount, setDonationAmount] = useState(0)       const [showDonateNotification, setShowDonateNotification] = useState(false)       function donate(e) {         e.preventDefault()         console.log(donationAmount)         window.contract.add_donation({ id: project.id, amount: donationAmount * 1 })         setShowDonateNotification(!showDonateNotification)       }       return (         <div className="project">           <h2>{project.title}</h2>{' '}           <span className="creator">{project.creator}</span>           <h3>description:</h3>           <p>{project.description}</p>           <h4>target: {project.donation_target} NEAR</h4>           <h4>Votes: {project.total_votes}</h4>           <button             onClick={() => {               window.contract.add_vote({ id: project.id })             }}           >             Vote           </button>           <h4>total donations: {project.total_donations / ONE_NEAR} NEAR</h4>           <form onSubmit={donate}>             <input               type="number"               value={donationAmount}               onChange={(e) => setDonationAmount(e.target.value)}             ></input>             <button onClick={donate}>Donate</button>           </form>           {showDonateNotification && <DonateNotification />}         </div>       )     }     function DonateNotification() {       return (         <aside>           <footer>             <div>✔ Succeeded </div>             <div>Donation was successful</div>           </footer>         </aside>       )     }     export default ListCrowdfunds`

In the `ListCrowdfunds` component, we set the donation amount state and when we want to donate, by clicking on the `Donate` button, the `donate` function is called which calls the `add_donation` method in our contract with the argument we provide from the form. We also have a notification component that notifies the user when our donation is successful.

Create Crowdfund Component[

](#create-crowdfund-component)
-----------------------------------------------------------

Our `CreateCrowdfund` component is a modal that contains a form for us to add a new crowdfund project.

   ``import React, { useState } from 'react'     function CreateCrowdfund({toggleModal}) {       const [title, setTitle] = useState('')       const [description, setDescription] = useState('')       const [target, setTarget] = useState(0)       const [showNotification, setShowNotification] = useState(false)       const handleSubmit = (event) => {         event.preventDefault()         window.contract.add_crowdfund({title:title, donate:target * 1, description:description})         setShowNotification(!showNotification)         alert(`crowdfund info: ${title} ${target} ${description}`)       }     console.log(`its ${toggleModal}`);       return (         <div>           {toggleModal == true && (             <div className='addcrowdfund'>               <form onSubmit={handleSubmit}>                 <label>                   Enter project title:                   <input                     type="text"                     value={title}                     onChange={(e) => setTitle(e.target.value)}                   />                 </label>                 <label>                   Enter donation target:                   <input                     type="number"                     value={target}                     onChange={(e) => setTarget(e.target.value)}                   />                 </label>                 <label>                   Enter project description:                   <input                     type="text"                     value={description}                     onChange={(e) => setDescription(e.target.value)}                   />                 </label>                 <input type="submit" className='submit' />               </form>             </div>           )}                      {showNotification && <Notification />}         </div>                )     }     function Notification() {       return (         <aside>           <footer>             <div>✔ Succeeded </div>              <div>Added new project Just now</div>           </footer>         </aside>       )     }     export default CreateCrowdfund``

This component conditionally renders when the `toggleModal` state is `true` . We have a state for the crowdfund `title`, `description`, and `target donation amount`, and each time our input changes, we set the state to the input value. On submitting the form, the `handleSubmit` function runs and our `add_crowdfund` method is called from the `window.contract` with the arguments we got from the input values.

You can check out a this [video](https://www.loom.com/share/f65f0c04298e434f88e0696d9bf3ad6b) walkthrough demo of the final dApp.

Yay!. We have concluded the tutorial and you can find the source code [here](https://github.com/uma-victor1/Crowdfunding-dApp).

Conclusion[

](#conclusion)
===========================

Finally!, we have come to the end of this tutorial. We learned how to build a crowdfunding dApp on the NEAR blockchain using Rust for the backend and React for the frontend, test our methods and deploy our smart contract live.

What Next?[

](#what-next)
==========================

You can play around with the code, and add some more functionalities like adding pagination so users can go back and forth between pages. Also you can add a sort functionality so the user can sort which crowdfunding project has the highest votes.

About the Author[

](#about-the-author)
=======================================

This tutorial was created by [Uma Victor](https://twitter.com/umavictor_), a software developer and web3 enthusiast.

References[

](#references)
===========================

*   NEAR [docs](https://docs.near.org/docs/develop/basics/getting-started).

'''