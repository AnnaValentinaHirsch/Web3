*GitHub Repository "marco-sundsk/ncd_examples"*

'''--- Cargo.toml ---
[workspace]
members = [
  "contracts/*"
]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- README.md ---
# ncd_examples
'''
'''--- contracts/cchl/Cargo.toml ---
[package]
name = "cross-contract-high-level"
version = "1.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.1.1"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.10"
maplit = "1.0"
near-units = "0.2.0"
serde = "1.0"
serde_with = "1"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.10.0", features = ["full"] }
workspaces = "0.7"
'''
'''--- contracts/cchl/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::env;
use near_sdk::{log, near_bindgen, PromiseOrValue};

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Contract { }

#[near_bindgen]
impl Contract {
    pub fn demo(&self, n: u32) -> u32 {
        n*(n-1)
    }

    pub fn factorial(&self, n: u32) -> PromiseOrValue<u32> {
        if n <= 1 {
            return PromiseOrValue::Value(1);
        }
        let account_id = env::current_account_id();

        Self::ext(account_id.clone())
            // .with_attached_deposit(1)
            .with_unused_gas_weight(6)
            .factorial(n - 1)
            .then(Self::ext(account_id).factorial_mult(n))
            .into()
    }

    /// Used for callbacks only. Multiplies current factorial result by the next value. Panics if
    /// it is not called by the contract itself.
    #[private]
    pub fn factorial_mult(&self, n: u32, #[callback_unwrap] cur: u32) -> u32 {
        log!("Received {:?} and {:?}", n, cur);
        let result = n * cur;
        log!("Multiplied {:?}", result.clone());
        result
    }
}
'''
'''--- contracts/cchl/tests/execution_result.txt ---
ExecutionFinalResult {
    total_gas_burnt: 47618721251509,

    transaction: ExecutionOutcome {
        block_hash: `JBkR229Wx56ujJ4pLpJ4SQSoJP3tsFYKr3dn8dwEq8Yr`,
        logs: [],
        receipt_ids: [
            `Aixy1NcjfJRUW7fhERS4whVHnNXQbE3zuG1C79XCyNAd`,
        ],
        gas_burnt: 2427956774944,
        tokens_burnt: 242795677494400000000,
        executor_id: AccountId(
            "test.near",
        ),
        status: SuccessReceiptId(Aixy1NcjfJRUW7fhERS4whVHnNXQbE3zuG1C79XCyNAd),
    }, // Convert Transaction To Receipt

    receipts: [
        ExecutionOutcome {
            block_hash: `CneBhpqUzYkKGWDvggZjy3jkrxcin7zxobExEuYqkYF7`,
            logs: [],
            receipt_ids: [
                `9ujGbuzGmRMsLszeVujgKdFhQB1Nh3EKWQwcWe3AthMb`,
                `HikGdYfvXgdrwYepnipNFc43FGZNb4BXJEprAcAErQrA`,
                `2LcrEcqynpEQu4eYq9YzaGjd5YmJyUAEa6WDjgVEN4PZ`,
            ],
            gas_burnt: 7539343474697,
            tokens_burnt: 753934347469700000000,
            executor_id: AccountId(
                "cchl.test.near",
            ),
            status: SuccessReceiptId(HikGdYfvXgdrwYepnipNFc43FGZNb4BXJEprAcAErQrA),
        }, // [layer 1] Called method: 'factorial' in contract, n=5

        ExecutionOutcome {
            block_hash: `H4nnrZkMm7og3RRSY3YT4ZdRGRDZREjdto4duovwUEUh`,
            logs: [],
            receipt_ids: [
                `J8GBsriyLuhECB2TuFDpEzqvGyyWNRDf9LNBtRqfYWNo`,
                `ErXg8ABqVoknGpBveMEiM1ovd4DzsnbchHkJTWBGibmx`,
                `DETBaerw7fuTqejXtMkp2QDVakxLb2WyfYZw79RqHVJ7`,
            ],
            gas_burnt: 7539481170785,
            tokens_burnt: 753948117078500000000,
            executor_id: AccountId(
                "cchl.test.near",
            ),
            status: SuccessReceiptId(ErXg8ABqVoknGpBveMEiM1ovd4DzsnbchHkJTWBGibmx),
        }, // [layer 2] Called method: 'factorial' in contract, n=4

        ExecutionOutcome {
            block_hash: `F3ssj3SU1ruvbPJpqm22DPBy4mMWK4Zm75sd5SDYWExh`,
            logs: [],
            receipt_ids: [
                `3QjAcCpNC2P6vmPYko3bXE8hN17dsXM8fZSQi9YiHt6K`,
                `4w5ekcZkjQZo5DnuZ5GqWPi8LPdAoCVYXc1H2vqY3Bbj`,
                `8MWkfaNLhRyKj5RZBLmjetNB9FxkSPPjvr8QvyZ5KaYV`,
            ],
            gas_burnt: 7539481170785,
            tokens_burnt: 753948117078500000000,
            executor_id: AccountId(
                "cchl.test.near",
            ),
            status: SuccessReceiptId(4w5ekcZkjQZo5DnuZ5GqWPi8LPdAoCVYXc1H2vqY3Bbj),
        }, // [layer 3] Called method: 'factorial' in contract, n=3

        ExecutionOutcome {
            block_hash: `NQxq5TKj9zRsVy82gFQ6XRRCopRnJ4RK5zqNQWy91zG`,
            logs: [],
            receipt_ids: [
                `DLWx8cjYbw83KcGnVSoNzCsf5DkeBToHGw7KoUA8hBdL`,
                `D128n2MEhTdEdoKNF5Rv8qoBUarytwmbVjGGFQrs67ZK`,
                `GZVYvxRa7gJ76wLcHAH8wBVUvqhdaUFEdKANa412wbxm`,
            ],
            gas_burnt: 7539481170785,
            tokens_burnt: 753948117078500000000,
            executor_id: AccountId(
                "cchl.test.near",
            ),
            status: SuccessReceiptId(D128n2MEhTdEdoKNF5Rv8qoBUarytwmbVjGGFQrs67ZK),
        }, // [layer 4] Called method: 'factorial' in contract, n=2

        ExecutionOutcome {
            block_hash: `79T2ygaPVN4xcqD2HkcrCWrzUV8DDjRC4v5XqxNyy8cP`,
            logs: [],
            receipt_ids: [
                `9G5cGzRTK1hooX7MqHZmLVmBn3tHQT3rNaLG2Bqxzrwv`,
            ],
            gas_burnt: 2556028715752,
            tokens_burnt: 255602871575200000000,
            executor_id: AccountId(
                "cchl.test.near",
            ),
            status: SuccessValue(`1`),
        }, // [layer 5] Called method: 'factorial' in contract, n=1

        ExecutionOutcome {
            block_hash: `J1pU79L6TDw9oTJD6jLttKD2BvLPQb7JuhY2uqskRwKb`,
            logs: [],
            receipt_ids: [],
            gas_burnt: 223182562500,
            tokens_burnt: 0,
            executor_id: AccountId(
                "test.near",
            ),
            status: SuccessValue(``),
        }, // system settles gas of [layer 5] and refund unused to caller

        ExecutionOutcome {
            block_hash: `J1pU79L6TDw9oTJD6jLttKD2BvLPQb7JuhY2uqskRwKb`,
            logs: [
                "Received 2 and 1",
                "Multiplied 2",
            ],
            receipt_ids: [
                `HD6MD1e8ky89bquE2SGqxT9Aoxqov3wd8UFRgvsrYsfx`,
            ],
            gas_burnt: 2616718088658,
            tokens_burnt: 261671808865800000000,
            executor_id: AccountId(
                "cchl.test.near",
            ),
            status: SuccessValue(`2`),
        }, // [layer 4 then callback] Called method: 'factorial_mult' in contract, n=2

        ExecutionOutcome {
            block_hash: `7TYdNV11cnGZ5gJuSvWpu4bxGRMDfdMChp5bwbHf18gY`,
            logs: [],
            receipt_ids: [],
            gas_burnt: 223182562500,
            tokens_burnt: 0,
            executor_id: AccountId(
                "test.near",
            ),
            status: SuccessValue(``),
        }, // system settles gas of [layer 4 then callback] and refund unused to caller

        ExecutionOutcome {
            block_hash: `79T2ygaPVN4xcqD2HkcrCWrzUV8DDjRC4v5XqxNyy8cP`,
            logs: [],
            receipt_ids: [],
            gas_burnt: 223182562500,
            tokens_burnt: 0,
            executor_id: AccountId(
                "test.near",
            ),
            status: SuccessValue(``),
        }, // system settles gas of [layer 3] and refund unused to caller

        ExecutionOutcome {
            block_hash: `7TYdNV11cnGZ5gJuSvWpu4bxGRMDfdMChp5bwbHf18gY`,
            logs: [
                "Received 3 and 2",
                "Multiplied 6",
            ],
            receipt_ids: [
                `HNZxm9h2tDQ6nfZU2uso4eLP3AauNsN8mXAVQvT3cyoB`,
            ],
            gas_burnt: 2616718088658,
            tokens_burnt: 261671808865800000000,
            executor_id: AccountId(
                "cchl.test.near",
            ),
            status: SuccessValue(`6`),
        }, // [layer 3 then callback] Called method: 'factorial_mult' in contract, n=3

        ExecutionOutcome {
            block_hash: `5MdHB3UdCq6qqj7oAj767LPwnGN9mxUUPFJp5xcW1pKj`,
            logs: [],
            receipt_ids: [],
            gas_burnt: 223182562500,
            tokens_burnt: 0,
            executor_id: AccountId(
                "test.near",
            ),
            status: SuccessValue(``),
        }, // system settles gas of [layer 3 then callback] and refund unused to caller
        ExecutionOutcome {
            block_hash: `NQxq5TKj9zRsVy82gFQ6XRRCopRnJ4RK5zqNQWy91zG`,
            logs: [],
            receipt_ids: [],
            gas_burnt: 223182562500,
            tokens_burnt: 0,
            executor_id: AccountId(
                "test.near",
            ),
            status: SuccessValue(``),
        }, // system settles gas of [layer 2] and refund unused to caller

        ExecutionOutcome {
            block_hash: `5MdHB3UdCq6qqj7oAj767LPwnGN9mxUUPFJp5xcW1pKj`,
            logs: [
                "Received 4 and 6",
                "Multiplied 24",
            ],
            receipt_ids: [
                `BSUcBFi76CmNDVSMBTKmQZF9y6MC1neXqSgp2bDdWxAN`,
            ],
            gas_burnt: 2617096159344,
            tokens_burnt: 261709615934400000000,
            executor_id: AccountId(
                "cchl.test.near",
            ),
            status: SuccessValue(`24`),
        }, // [layer 2 then callback] Called method: 'factorial_mult' in contract, n=4

        ExecutionOutcome {
            block_hash: `H3H2WaxocF9MbCDJPKwYCXr3NkanjCv6oo8wdTVFnCD6`,
            logs: [],
            receipt_ids: [],
            gas_burnt: 223182562500,
            tokens_burnt: 0,
            executor_id: AccountId(
                "test.near",
            ),
            status: SuccessValue(``),
        }, // system settles gas of [layer 2 then callback] and refund unused to caller
        ExecutionOutcome {
            block_hash: `F3ssj3SU1ruvbPJpqm22DPBy4mMWK4Zm75sd5SDYWExh`,
            logs: [],
            receipt_ids: [],
            gas_burnt: 223182562500,
            tokens_burnt: 0,
            executor_id: AccountId(
                "test.near",
            ),
            status: SuccessValue(``),
        }, // system settles gas of [layer 1] and refund unused to caller

        ExecutionOutcome {
            block_hash: `H3H2WaxocF9MbCDJPKwYCXr3NkanjCv6oo8wdTVFnCD6`,
            logs: [
                "Received 5 and 24",
                "Multiplied 120",
            ],
            receipt_ids: [
                `F4BwgDdEDGbV2Cne2RWQ2ygFHEbQZC96A1dYqTtSKXum`,
            ],
            gas_burnt: 2617773374601,
            tokens_burnt: 261777337460100000000,
            executor_id: AccountId(
                "cchl.test.near",
            ),
            status: SuccessValue(`120`),
        }, // [layer 1 then callback] Called method: 'factorial_mult' in contract, n=5

        ExecutionOutcome {
            block_hash: `4uUZfsB2mhb9i44QYBHojUTAB5QQbznMufxjCtSmkJKG`,
            logs: [],
            receipt_ids: [],
            gas_burnt: 223182562500,
            tokens_burnt: 0,
            executor_id: AccountId(
                "test.near",
            ),
            status: SuccessValue(``),
        }, // system settles gas of [layer 1 then callback] and refund unused to caller
        ExecutionOutcome {
            block_hash: `H4nnrZkMm7og3RRSY3YT4ZdRGRDZREjdto4duovwUEUh`,
            logs: [],
            receipt_ids: [],
            gas_burnt: 223182562500,
            tokens_burnt: 0,
            executor_id: AccountId(
                "test.near",
            ),
            status: SuccessValue(``),
        }, // system settles gas of remaining and refund unused to caller
    ],

    status: SuccessValue(`120`), // the final return value
}
'''
'''--- contracts/cchl/tests/test_cchl.rs ---
use serde_json::json;
pub use near_units::parse_near;
pub use workspaces::{
    network::Sandbox, result::ExecutionFinalResult, Account, AccountId, Contract, Worker,
};

pub async fn initialize_contracts_and_users(
    worker: &Worker<Sandbox>,
) -> anyhow::Result<(Account, Contract)> {
    let root = worker.root_account()?;

    let cchl = root
        .create_subaccount("cchl")
        .initial_balance(parse_near!("50 N"))
        .transact()
        .await?
        .unwrap();

    let cchl = cchl
        .deploy(&std::fs::read(format!("../../res/cross_contract_high_level.wasm"))?)
        .await?
        .unwrap();

    // cchl.call("new")
    // .args_json(json!({}))?
    // .gas(300_000_000_000_000)
    // .transact()
    // .await?;

    Ok((root, cchl))
}

#[tokio::test]
async fn test_cchl() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    let (root, cchl) = initialize_contracts_and_users(&worker).await?;
    println!("Contract deployed at {}.", cchl.id());

    let outcome = root
        .call(cchl.id(), "demo")
        .args_json(json!({
            "n": 5_u32,
        }))
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    println!("called demo.");
    let ret = outcome.json::<u32>().unwrap();
    println!("We got a return value of {}.", ret);

    let outcome = root
        .call(cchl.id(), "factorial")
        .args_json(json!({
            "n": 5_u32,
        }))
        .gas(300_000_000_000_000)
        .transact()
        .await?;
    println!("called factorial.");

    // let ret = outcome.json::<u32>().unwrap();
    let ret: u32 = outcome.clone().json()?;
    println!("We got a return value of {}.", ret);

    // show details of the call
    // println!("{:#?}", outcome);

    // show all logs in the call
    println!("logs = {:#?}", outcome.logs());

    // total gas burnt
    println!("total_gas_burnt: {:?}", outcome.total_gas_burnt);

    // break down gas burnt
    // println!(
    //     "initial transaction gas_burnt: {:?}",
    //     outcome.outcome().gas_burnt
    // );
    // println!("Following is the break down of all sub receipts in the call:");
    // for receipt in outcome.receipt_outcomes() {
    //     println!("sub receipt gas burnt: {:?}", receipt.gas_burnt);
    // }

    println!("Following is the break down of all receipts in the call:");
    for receipt in outcome.outcomes() {
        println!("receipt gas burnt: {:?}", receipt.gas_burnt);
    }

    Ok(())
}

'''
'''--- contracts/mock-dex/Cargo.toml ---
[package]
name = "mock_dex"
version = "1.0.0"
authors = ["Marco Sun <sun.dsk1@gmail.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.1.1"
near-sys = "=0.2"
near-contract-standards = "4.1.1"

'''
'''--- contracts/mock-dex/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
mkdir -p ../../res
cp ../../target/wasm32-unknown-unknown/release/mock_dex.wasm ../../res/
'''
'''--- contracts/mock-dex/src/lib.rs ---
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    json_types::U128,
    log, near_bindgen, AccountId, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, Default)]
pub struct Contract {}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        log!(format!(
            "predecessor: {}, gas: {}T, deposit: {}yocto",
            env::predecessor_account_id(),
            u64::from(env::prepaid_gas()) as f64 / 1e12,
            env::attached_deposit()
        ));
        log!(format!(
            "sender: {}, amount: {}, msg: {}",
            sender_id, amount.0, msg
        ));
        PromiseOrValue::Value(U128(0))
    }
}

'''
'''--- contracts/sim-token/Cargo.toml ---
[package]
name = "sim_token"
version = "1.0.0"
authors = ["Marco Sun <sun.dsk1@gmail.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.1.1"
near-sys = "=0.2"
near-contract-standards = "4.1.1"

'''
'''--- contracts/sim-token/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
mkdir -p ../../res
cp ../../target/wasm32-unknown-unknown/release/sim_token.wasm ../../res/
'''
'''--- contracts/sim-token/src/events.rs ---
use near_sdk::{
    AccountId, log,
    serde::{Serialize},
    serde_json::{json},
    json_types::U128,
};

const EVENT_STANDARD: &str = "test-token";
const EVENT_STANDARD_VERSION: &str = "1.0.0";

#[derive(Serialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
pub enum Event<'a> {
    TokenMint {
        caller_id: &'a AccountId,
        receiver_id: &'a AccountId,
        mint_amount: &'a U128,
        cur_supply: &'a U128,
    },
    TokenBurn {
        caller_id: &'a AccountId,
        target_id: &'a AccountId,
        burn_amount: &'a U128,
        cur_supply: &'a U128,
    },
}

impl Event<'_> {
    pub fn emit(&self) {
        emit_event(&self);
    }
}

// Emit event that follows NEP-297 standard: https://nomicon.io/Standards/EventsFormat
// Arguments
// * `standard`: name of standard, e.g. nep171
// * `version`: e.g. 1.0.0
// * `event`: type of the event, e.g. nft_mint
// * `data`: associate event data. Strictly typed for each set {standard, version, event} inside corresponding NEP
pub (crate) fn emit_event<T: ?Sized + Serialize>(data: &T) {
    let result = json!(data);
    let event_json = json!({
        "standard": EVENT_STANDARD,
        "version": EVENT_STANDARD_VERSION,
        "event": result["event"],
        "data": [result["data"]]
    })
    .to_string();
    log!(format!("EVENT_JSON:{}", event_json));
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::{test_utils, AccountId};

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice".to_string())
    }

    fn bob() -> AccountId {
        AccountId::new_unchecked("bob".to_string())
    }

    #[test]
    fn event_token_mint() {
        let caller_id = &alice();
        let receiver_id = &bob();
        let mint_amount = &U128(100);
        let cur_supply = &U128(10000);
        Event::TokenMint { caller_id, receiver_id, mint_amount, cur_supply }.emit();
        assert_eq!(
            test_utils::get_logs()[0],
            r#"EVENT_JSON:{"standard":"test-token","version":"1.0.0","event":"token_mint","data":[{"caller_id":"alice","receiver_id":"bob","mint_amount":"100","cur_supply":"10000"}]}"#
        );
    }

    #[test]
    fn event_token_burn() {
        let caller_id = &alice();
        let target_id = &bob();
        let burn_amount = &U128(100);
        let cur_supply = &U128(10000);
        Event::TokenBurn { caller_id, target_id, burn_amount, cur_supply }.emit();
        assert_eq!(
            test_utils::get_logs()[0],
            r#"EVENT_JSON:{"standard":"test-token","version":"1.0.0","event":"token_burn","data":[{"caller_id":"alice","target_id":"bob","burn_amount":"100","cur_supply":"10000"}]}"#
        );
    }
}
'''
'''--- contracts/sim-token/src/lib.rs ---
use near_contract_standards::fungible_token::{
    metadata::{FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,},
    events::{FtBurn, FtMint},
    FungibleToken
};
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize,},
    json_types::U128,
    collections::UnorderedSet,
    env, near_bindgen, require, AccountId, PanicOnDefault, PromiseOrValue, BorshStorageKey
};
use crate::events::Event;

mod events;
mod operator;
mod owner;
mod view;

pub(crate) fn assert_one_yocto() {
    require!(
        env::attached_deposit() == 1,
        "Requires attached deposit of exactly 1 yoctoNEAR"
    )
}

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKeys {
    Token,
    Operator,
}

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize, PanicOnDefault)]
pub struct Contract {
    owner_id: AccountId,
    operators: UnorderedSet<AccountId>,

    token: FungibleToken,
    name: String,
    symbol: String,
    icon: Option<String>,
    decimals: u8,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId, name: String, symbol: String, decimals: u8) -> Self {
        Self {
            owner_id: owner_id.clone(),
            operators: UnorderedSet::new(StorageKeys::Operator),
            token: FungibleToken::new(StorageKeys::Token),
            name,
            symbol,
            icon: None,
            decimals,
        }
    }

    pub fn mint(&mut self, account_id: AccountId, amount: U128) {
        if self.token.storage_balance_of(account_id.clone()).is_none() {
            self.token.internal_register_account(&account_id);
        }

        self.token
            .internal_deposit(&account_id, amount.into());
        
        Event::TokenMint { 
            caller_id: &env::predecessor_account_id(), 
            receiver_id: &account_id, 
            mint_amount: &amount, 
            cur_supply: &self.token.ft_total_supply() 
        }
        .emit();

        FtMint {
            owner_id: &account_id,
            amount: &amount,
            memo: None
        }
        .emit();
    }

    pub fn burn(&mut self, account_id: AccountId, amount: U128) {
        self.token
            .internal_withdraw(&account_id, amount.into());
        
        Event::TokenBurn { 
            caller_id: &env::predecessor_account_id(), 
            target_id: &account_id, 
            burn_amount: &amount, 
            cur_supply: &self.token.ft_total_supply() 
        }
        .emit();

        FtBurn {
            owner_id: &account_id,
            amount: &amount,
            memo: None
        }
        .emit();
    }
}

impl Contract {
    fn is_owner_or_operators(&self) -> bool {
        env::predecessor_account_id() == self.owner_id 
            || self.operators.contains(&env::predecessor_account_id())
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token);
near_contract_standards::impl_fungible_token_storage!(Contract, token);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        FungibleTokenMetadata {
            spec: FT_METADATA_SPEC.to_string(),
            name: self.name.clone(),
            symbol: self.symbol.clone(),
            icon: self.icon.clone(),
            reference: None,
            reference_hash: None,
            decimals: self.decimals,
        }
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{env, testing_env};

    use super::*;

    fn owner() -> AccountId {
        AccountId::new_unchecked("owner".to_string())
    }

    #[test]
    fn test_basics() {
        let mut context = VMContextBuilder::new();
        testing_env!(context.build());
        let mut contract = Contract::new(owner(), String::from("TBD"), String::from("TBD"), 24);
        testing_env!(context
            .attached_deposit(125 * env::storage_byte_cost())
            .build());
        // contract.storage_deposit(Some(accounts(0)), None);
        contract.mint(accounts(0), 1_000_000.into());
        assert_eq!(contract.ft_balance_of(accounts(0)), 1_000_000.into());

        testing_env!(context
            .attached_deposit(125 * env::storage_byte_cost())
            .build());
        contract.storage_deposit(Some(accounts(1)), None);
        testing_env!(context
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.ft_transfer(accounts(1), 1_000.into(), None);
        assert_eq!(contract.ft_balance_of(accounts(1)), 1_000.into());

        contract.burn(accounts(1), 500.into());
        assert_eq!(contract.ft_balance_of(accounts(1)), 500.into());
    }
}
'''
'''--- contracts/sim-token/src/operator.rs ---
use crate::*;
use near_sdk::{
    near_bindgen, log, ext_contract, AccountId, Gas
};

pub const TGAS: u64 = 1_000_000_000_000;

#[ext_contract(ext_nep_141)]
pub trait ExtNep141 {
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

// #[ext_contract(ext_self)]
// trait DemoCallback {
//     fn get_balance_callback(&mut self, account_id: AccountId);
// }

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn set_token_name(&mut self, name: String, symbol: String) {
        assert_one_yocto();
        require!(self.is_owner_or_operators(), "NOT ALLOWED");
        self.name = name;
        self.symbol = symbol;
    }

    #[payable]
    pub fn set_icon(&mut self, icon: String) {
        assert_one_yocto();
        require!(self.is_owner_or_operators(), "NOT ALLOWED");
        self.icon = Some(icon);
    }

    #[payable]
    pub fn set_decimals(&mut self, dec: u8) {
        assert_one_yocto();
        require!(self.is_owner_or_operators(), "NOT ALLOWED");
        self.decimals = dec;
    }

    #[payable]
    pub fn peek_user_balance(&mut self, account_id: AccountId) {
        assert_one_yocto();
        require!(self.is_owner_or_operators(), "NOT ALLOWED");
        ext_nep_141::ext(env::current_account_id())
            .with_static_gas(env::prepaid_gas() - Gas(20 * TGAS) - Gas(5 * TGAS))
            .ft_balance_of(account_id.clone())
        .then(
            Self::ext(env::current_account_id())
                .with_static_gas(Gas(5 * TGAS))
                .get_balance_callback(account_id)
            );
    }

    #[private]
    pub fn get_balance_callback(
        &mut self,
        account_id: AccountId,
        #[callback] balance: U128,
    ) {
        log!(format!(
            "account: {}, balance: {}",
            account_id, balance.0
        ));
    }
}
'''
'''--- contracts/sim-token/src/owner.rs ---
use crate::*;
use near_sdk::{
    near_bindgen,
};

impl Contract {
    fn assert_owner(&self) {
        require!(
            env::predecessor_account_id() == self.owner_id,
            "ERR_NOT_OWNER"
        );
    }
}

#[near_bindgen]
impl Contract {
    #[payable]
    pub fn set_owner(
        &mut self,
        new_owner_id: AccountId
    ) {
        assert_one_yocto();
        self.assert_owner();
        self.owner_id = new_owner_id;
    }

    /// Extend operators. Only can be called by owner.
    #[payable]
    pub fn extend_operators(&mut self, operators: Vec<AccountId>) {
        assert_one_yocto();
        self.assert_owner();
        for operator in operators {
            self.operators.insert(&operator);
        }
    }

    /// Remove operators. Only can be called by owner.
    #[payable]
    pub fn remove_operators(&mut self, operators: Vec<AccountId>) {
        assert_one_yocto();
        self.assert_owner();
        for operator in operators {
            self.operators.remove(&operator);
        }
    }

    /// Should only be called by this contract on migration.
    /// This is NOOP implementation. KEEP IT if you haven't changed contract state.
    /// If you have changed state, you need to implement migration from old state (keep the old struct with different name to deserialize it first).
    /// After migration goes live, revert back to this implementation for next updates.
    #[init(ignore_state)]
    #[private]
    pub fn migrate() -> Self {
        let contract: Contract = env::state_read().expect("ERR_NOT_INITIALIZED");
        contract
    }
}

#[cfg(target_arch = "wasm32")]
mod upgrade {
    use near_sdk::Gas;
    use near_sys as sys;

    use super::*;

    /// Gas for calling migration call.
    pub const GAS_FOR_MIGRATE_CALL: Gas = Gas(5_000_000_000_000);

    /// Self upgrade and call migrate, optimizes gas by not loading into memory the code.
    /// Takes as input non serialized set of bytes of the code.
    #[no_mangle]
    pub fn upgrade() {
        env::setup_panic_hook();
        let contract: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        contract.assert_owner();
        let current_id = env::current_account_id().as_bytes().to_vec();
        let method_name = "migrate".as_bytes().to_vec();
        unsafe {
            // Load input (wasm code) into register 0.
            sys::input(0);
            // Create batch action promise for the current contract ID
            let promise_id =
                sys::promise_batch_create(current_id.len() as _, current_id.as_ptr() as _);
            // 1st action in the Tx: "deploy contract" (code is taken from register 0)
            sys::promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);
            // 2nd action in the Tx: call this_contract.migrate() with remaining gas
            let attached_gas = env::prepaid_gas() - env::used_gas() - GAS_FOR_MIGRATE_CALL;
            sys::promise_batch_action_function_call(
                promise_id,
                method_name.len() as _,
                method_name.as_ptr() as _,
                0 as _,
                0 as _,
                0 as _,
                attached_gas.0,
            );
        }
    }
}
'''
'''--- contracts/sim-token/src/view.rs ---
use near_sdk::{
    serde::{Deserialize, Serialize},
    near_bindgen, AccountId
};
use crate::*;

#[derive(Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Metadata {
    pub version: String,
    pub owner_id: AccountId,
    pub operators: Vec<AccountId>,
}

#[near_bindgen]
impl Contract {
    pub fn metadata(&self) -> Metadata {
        Metadata {
            owner_id: self.owner_id.clone(),
            operators: self.operators.to_vec(),
            version: env!("CARGO_PKG_VERSION").to_string(),
        }
    }
}
'''
'''--- contracts/storage-demo/Cargo.toml ---
[package]
name = "storage-demo"
version = "1.1.0"
authors = ["Marco Sun <sun.dsk1@gmail.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "4.1.1"

'''
'''--- contracts/storage-demo/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedSet, Vector};
use near_sdk::{env, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault};
use note::{NoteBook, RichNoteBook, TextNoteBook};
use std::collections::HashMap;

mod note;

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    Notes,
    RichNotes { notes_id: u32 },
    Friends,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub notes: Vector<NoteBook>,
    pub friends: UnorderedSet<AccountId>,
    pub total_balance: Balance,
    pub friend_rate: HashMap<AccountId, u32>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        Self {
            owner_id,
            notes: Vector::new(StorageKey::Notes),
            friends: UnorderedSet::new(StorageKey::Friends),
            total_balance: 0,
            friend_rate: HashMap::new(),
        }
    }

    pub fn add_text_notebook(&mut self) -> u32 {
        let id = self.notes.len() as u32;
        let notebook = NoteBook::TextNoteBook(TextNoteBook::new(id));
        self.notes.push(&notebook);
        id
    }

    pub fn add_rich_notebook(&mut self) -> u32 {
        let id = self.notes.len() as u32;
        let notebook = NoteBook::RichNoteBook(RichNoteBook::new(id));
        self.notes.push(&notebook);
        id
    }

    pub fn add_notes(&mut self, notebook_id: u32, content: String) {
        let sender_id = env::predecessor_account_id();
        let mut notebook = self.notes.get(notebook_id.into()).expect("ERR_NO_NOTEBOOK");
        notebook.add_notes(&sender_id, &content);
        self.notes.replace(notebook_id.into(), &notebook);
    }

    pub fn add_friends(&mut self, friends: Vec<AccountId>) {
        for friend in friends {
            self.friends.insert(&friend);
            self.friend_rate.insert(friend, 0);
        }
    }

    pub fn remove_friends(&mut self, friends: Vec<AccountId>) {
        for friend in friends {
            self.friends.remove(&friend);
            self.friend_rate.remove(&friend);
        }
    }
}

'''
'''--- contracts/storage-demo/src/note.rs ---
use crate::*;

#[derive(BorshSerialize, BorshDeserialize)]
pub enum NoteBook {
    TextNoteBook(TextNoteBook),
    RichNoteBook(RichNoteBook),
}

impl NoteBook {
    pub fn kind(&self) -> String {
        match self {
            NoteBook::TextNoteBook(_) => "Text_NoteBook".to_string(),
            NoteBook::RichNoteBook(_) => "Rich_NoteBook".to_string(),
        }
    }

    pub fn add_notes(&mut self, sender_id: &AccountId, content: &String) {
        match self {
            NoteBook::TextNoteBook(notebook) => notebook.add_notes(sender_id, content),
            NoteBook::RichNoteBook(notebook) => notebook.add_notes(sender_id, content),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct TextNoteBook {
    pub id: u32,
    pub notes: Vec<String>,
}

impl TextNoteBook {
    pub fn new(id: u32) -> Self {
        Self {
            id,
            notes: Vec::new(),
        }
    }

    pub fn add_notes(&mut self, sender_id: &AccountId, content: &String) {
        let record = format!("{}:{}", sender_id, content);
        self.notes.push(record);
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct RichNoteBook {
    pub id: u32,
    pub notes: LookupMap<AccountId, String>,
    pub count: u32,
}

impl RichNoteBook {
    pub fn new(id: u32) -> Self {
        Self {
            id,
            notes: LookupMap::new(StorageKey::RichNotes { notes_id: id }),
            count: 0,
        }
    }

    pub fn add_notes(&mut self, sender_id: &AccountId, content: &String) {
        self.notes.insert(sender_id, content);
        self.count += 1;
    }
}

'''
'''--- tools/requirements.txt ---
base58==2.1.0
requests==2.26.0
'''
'''--- tools/storage_analyser/data/eg_whole.json ---
{
  "block_hash": "24Hen4tg96HTocRDHGRfEW5qTcXVHnDmzzwTqGVFrr8F",
  "block_height": 129050917,
  "proof": [],
  "values": [
    {
      "key": "AAAAAAAAAAAA",
      "proof": [],
      "value": "AAAAAAABAAAAGwAAAHUxLnRlc3RuZXQ6dGhpcyBpcyBtc2cgb25lLg=="
    },
    {
      "key": "AAEAAAAAAAAA",
      "proof": [],
      "value": "AQEAAAAFAAAAAQEAAAABAAAA"
    },
    {
      "key": "AQEAAAAKAAAAdTEudGVzdG5ldA==",
      "proof": [],
      "value": "EAAAAHRoaXMgaXMgbXNnIHR3by4="
    },
    {
      "key": "AmUAAAAAAAAAAA==",
      "proof": [],
      "value": "CgAAAHUyLnRlc3RuZXQ="
    },
    {
      "key": "AmkKAAAAdTIudGVzdG5ldA==",
      "proof": [],
      "value": "AAAAAAAAAAA="
    },
    {
      "key": "U1RBVEU=",
      "proof": [],
      "value": "CgAAAHUxLnRlc3RuZXQCAAAAAAAAAAEAAAAAAgAAAAJpAQAAAAAAAAACAAAAAmUAAAAAAAAAAAAAAAAAAAAAAQAAAAoAAAB1Mi50ZXN0bmV0AAAAAA=="
    }
  ]
}
'''
'''--- tools/storage_analyser/data/readme.txt ---
export NEAR_ENV=testnet
export EG=dev-1635142748034-53304986766242
near call $EG new '{"owner_id": "u1.testnet"}' --account_id $EG
# add notebook
near call $EG add_text_notebook '' --account_id $EG
near call $EG add_rich_notebook '' --account_id $EG
# add_notes
near call $EG add_notes '{"notebook_id": 0, "content": "this is msg one."}' --account_id u1.testnet
near call $EG add_notes '{"notebook_id": 1, "content": "this is msg two."}' --account_id u1.testnet
# add friends
near call $EG add_friends '{"friends": ["u2.testnet"]}' --account_id u1.testnet

{
    "values": [
      {
        "key": "AAAAAAAAAAAA",
        Vector_key: prefix + index
        content: b'
                  \x00 prefix=0
                  \x00\x00\x00\x00\x00\x00\x00\x00' index=0
        hex    : b'
                  \x00 \x00\x00\x00\x00\x00\x00\x00\x00'
        
        "value": "AAAAAAABAAAAGwAAAHUxLnRlc3RuZXQ6dGhpcyBpcyBtc2cgb25lLg=="
        Vector_value: Object  
        pub enum NoteBook {
            TextNoteBook(TextNoteBook),
            RichNoteBook(RichNoteBook),
        }
        pub struct TextNoteBook {
            pub id: u32,
            pub notes: Vec<String>,
        }
        content: b'
                  \x00 enum index=0 -> TextNoteBook
                  \x00\x00\x00\x00 note_id=0
                  \x01\x00\x00\x00 vec length
                  \x1b\x00\x00\x00 u1.testnet:this is msg one.' vec item
        hex    : b'
                  \x00 
                  \x00\x00\x00\x00
                  \x01\x00\x00\x00
                  \x1b\x00\x00\x00 \x75\x31\x2e\x74\x65\x73\x74\x6e\x65\x74\x3a\x74\x68\x69\x73\x20\x69\x73\x20\x6d\x73\x67\x20\x6f\x6e\x65\x2e'
      },

      {
        "key": "AAEAAAAAAAAA",
        content: b'
                  \x00 prefix=0
                  \x01\x00\x00\x00\x00\x00\x00\x00' index=1
        hex    : b'\x00 \x01\x00\x00\x00\x00\x00\x00\x00'
        "value": "AQEAAAAFAAAAAQEAAAABAAAA"
        pub enum NoteBook {
            TextNoteBook(TextNoteBook),
            RichNoteBook(RichNoteBook),
        }
        pub struct RichNoteBook {
            pub id: u32,
            pub notes: LookupMap<AccountId, String>,
            pub count: u32,
        }
        content: b'
                  \x01 enum index=1 -> RichNoteBook
                  \x01\x00\x00\x00 note_id=1
                  LookupMap: prefix_length + prefix (prefix+sub_prefix)
                  \x05\x00\x00\x00 \x01 \x01\x00\x00\x00
                  \x01\x00\x00\x00' count=1
        hex    : b'\x01\x01\x00\x00\x00\x05\x00\x00\x00\x01\x01\x00\x00\x00\x01\x00\x00\x00'
      },

      {
        "key": "AQEAAAAKAAAAdTEudGVzdG5ldA==",
        content: b'
                  \x01\x01\x00\x00\x00 prefix+sub_prefix
                  \n\x00\x00\x00u1.testnet' AccountId=u1.testnet
        hex    : b'\x01\x01\x00\x00\x00\x0a\x00\x00\x00\x75\x31\x2e\x74\x65\x73\x74\x6e\x65\x74'
        "value": "EAAAAHRoaXMgaXMgbXNnIHR3by4="
        LookupMap_value: Object(String)
        content: b'\x10\x00\x00\x00 this is msg two.'
        hex    : b'\x10\x00\x00\x00\x74\x68\x69\x73\x20\x69\x73\x20\x6d\x73\x67\x20\x74\x77\x6f\x2e'
      },

      {
        "key": "AmUAAAAAAAAAAA==",
        idx -> item, used for iteration
        content: b'\x02e \x00\x00\x00\x00\x00\x00\x00\x00'
        hex    : b'\x02\x65\x00\x00\x00\x00\x00\x00\x00\x00'
        "value": "CgAAAHUyLnRlc3RuZXQ="
        content: b'\n\x00\x00\x00u2.testnet'
        hex    : b'\x0a\x00\x00\x00\x75\x32\x2e\x74\x65\x73\x74\x6e\x65\x74'
      },

      {
        "key": "AmkKAAAAdTIudGVzdG5ldA==",
        item -> idx, used for telling item existence
        content: b'\x02i \n\x00\x00\x00u2.testnet'
        hex    : b'\x02\x69\x0a\x00\x00\x00\x75\x32\x2e\x74\x65\x73\x74\x6e\x65\x74'
        "value": "AAAAAAAAAAA="
        content: b'\x00\x00\x00\x00\x00\x00\x00\x00'
        hex    : b'\x00\x00\x00\x00\x00\x00\x00\x00'
      },
      {
        "key": "U1RBVEU=",
        content: b'STATE'
        hex    : b'\x53\x54\x41\x54\x45'
        "value": "CgAAAHUxLnRlc3RuZXQCAAAAAAAAAAEAAAAAAgAAAAJpAQAAAAAAAAACAAAAAmUAAAAAAAAAAAAAAAAAAAAAAQAAAAoAAAB1Mi50ZXN0bmV0AAAAAA=="
        pub struct Contract {
          pub owner_id: AccountId,
          pub notes: Vector<NoteBook>,
          pub friends: UnorderedSet<AccountId>,
          pub total_balance: Balance,
          pub friend_rate: HashMap<AccountId, u32>,
        }
        content: b'
                  String: length + content
                  \n\x00\x00\x00u1.testnet
                  Vector: item_count + prefix_length + prefix
                  \x02\x00\x00\x00\x00\x00\x00\x00
                  \x01\x00\x00\x00 \x00
                  UnorderedSet:
                  \x02\x00\x00\x00 \x02i
                  \x01\x00\x00\x00\x00\x00\x00\x00
                  \x02\x00\x00\x00\x02e
                  Balance: 
                  \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
                  HashMap: item_count + (key, value) list
                  \x01\x00\x00\x00 item_count=1
                  \n\x00\x00\x00u2.testnet \x00\x00\x00\x00' 
        
        hex    : b'
                  \x0a\x00\x00\x00 \x75\x31\x2e\x74\x65\x73\x74\x6e\x65\x74

                  \x02\x00\x00\x00\x00\x00\x00\x00
                  \x01\x00\x00\x00\x00
                  
                  \x02\x00\x00\x00 \x02\x69
                  \x01\x00\x00\x00\x00\x00\x00\x00
                  \x02\x00\x00\x00 \x02\x65
                  
                  \x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00
                  
                  \x01\x00\x00\x00
                  \x0a\x00\x00\x00\x75\x32\x2e\x74\x65\x73\x74\x6e\x65\x74 \x00\x00\x00\x00'
      }
    ]
  }
'''
'''--- tools/storage_analyser/main.py ---
from near_rpc import NodeJsonProviderError,  NodeJsonProvider
import base64
import json
import time

def show_b64_str(b64_content):
    code = base64.b64decode(b64_content)
    hex_repr = ''.join('\\x{:02x}'.format(b) for b in code)
    return (code, hex_repr)
    

def save2file(filename, json_obj):
    # print(json_obj)
    with open("data/eg_%s.json" % filename, mode='w', encoding="utf-8") as f:
        json.dump(json_obj, f, indent=2)
        print("File %s saved" % filename)

def fetch(prefix, filename=None):
    prefix_key = b''
    import base64
    if prefix:
        prefix_key = base64.b64encode(prefix)
        
    qurey_args = {
        "request_type": "view_state",
        "finality": "final",
        "account_id": "dev-1635142748034-53304986766242",
        "prefix_base64": prefix_key.decode(),
    }
    try:
        conn = NodeJsonProvider("https://rpc.testnet.near.org")
        ret = conn.query(qurey_args)

        if filename:
            save2file(filename, ret)

        import base64
        for item in ret['values']:
            print("key: ", base64.b64decode(item['key']))
            print("value: ", base64.b64decode(item['value']))

    except NodeJsonProviderError as e:
        print("RPC Error: ", e)
    except Exception as e:
        print("Error: ", e)

def analyse(filename):
    json_obj = None
    with open("data/eg_%s.json" % filename, mode='r', encoding="utf-8") as f:
        json_obj = json.load(f)
    print("File %s.json loaded" % filename)
    import base64

    for item in json_obj['values']:
        key = base64.b64decode(item['key'])
        if key == b'STATE':
            # this is contract main struct
            parse_main(base64.b64decode(item['value']))
            pass
        elif key.startswith(b'\x00'):
            parse_notebook(key, base64.b64decode(item['value']))
        elif key.startswith(b'\x01'):
            parse_rich(key, base64.b64decode(item['value']))
        elif key.startswith(b'\x02e'):
            parse_02e(key, base64.b64decode(item['value']))
        elif key.startswith(b'\x02i'):
            parse_02i(key, base64.b64decode(item['value']))
        print()

def parse_02e(bytes_key, bytes_content):
    id = int.from_bytes(bytes_key[2:], 'little')
    value_length = int.from_bytes(bytes_content[0:4], 'little')
    value = bytes_content[4:4+value_length]
    print("Friends Unordered Sets %s -> %s" % (id, value))

def parse_02i(bytes_key, bytes_content):
    value_length = int.from_bytes(bytes_key[2:6], 'little')
    value = bytes_key[6:6+value_length]
    id = int.from_bytes(bytes_content, 'little')
    print("Friends Unordered Sets %s <- %s" % (value, id))

def parse_notebook(bytes_key, bytes_content):
    notebook_id = int.from_bytes(bytes_key[1:], 'little')
    print("notebook id: %s" % notebook_id)
    if bytes_content[0:1] == b'\x00':
        inner_id = int.from_bytes(bytes_content[1:5], 'little')
        notes_count = int.from_bytes(bytes_content[5:9], 'little')
        print("TextNoteBook id: %s, count: %s" % (inner_id, notes_count))
        if notes_count > 0:
            buffer = bytes_content[9:]
            for i in range(notes_count):
                note_length = int.from_bytes(buffer[0:4], 'little')
                note_content = buffer[4:4+note_length]
                buffer = buffer[4+note_length:]
                print("    note content: %s" % note_content)

    elif bytes_content[0:1] == b'\x01':
        inner_id = int.from_bytes(bytes_content[1:5], 'little')
        prefix_length_value = int.from_bytes(bytes_content[5:9], 'little')
        prefix = bytes_content[9:9+prefix_length_value]
        notes_count = int.from_bytes(bytes_content[9+prefix_length_value:9+prefix_length_value+4], 'little')
        print("RichNoteBook id: %s, prefix: %s, count: %s" % (inner_id, prefix, notes_count))
    else:
        print("Unknown bytes!")

def parse_rich(bytes_key, bytes_content):
    notebook_id = int.from_bytes(bytes_key[1:5], 'little')
    sender_length = int.from_bytes(bytes_key[5:9], 'little')
    sender = bytes_key[9:9+sender_length]

    value_length = int.from_bytes(bytes_content[0:4], 'little')
    value = bytes_content[4:4+value_length]

    print("    RichNoteBook#%s has a note from %s, content is %s" % (notebook_id, sender, value))

def parse_main(bytes_content):
    buffer = bytes_content[:]
    
    owner_length = buffer[0:4]
    owner_length_value = int.from_bytes(owner_length, 'little')
    buffer = buffer[4:]
    owner = buffer[:owner_length_value].decode()
    buffer = buffer[owner_length_value:]

    vector_length = buffer[0:8]
    vector_length_value = int.from_bytes(vector_length, 'little')
    buffer = buffer[8:]
    prefix_length = buffer[0:4]
    prefix_length_value = int.from_bytes(prefix_length, 'little')
    buffer = buffer[4:]
    prefix_v = buffer[0:prefix_length_value]
    buffer = buffer[prefix_length_value:]

    prefix_length = buffer[0:4]
    prefix_length_value = int.from_bytes(prefix_length, 'little')
    buffer = buffer[4:]
    prefix_us1 = buffer[0:prefix_length_value]
    buffer = buffer[prefix_length_value:]
    set_length = buffer[0:8]
    set_length_value = int.from_bytes(set_length, 'little')
    buffer = buffer[8:]
    prefix_length = buffer[0:4]
    prefix_length_value = int.from_bytes(prefix_length, 'little')
    buffer = buffer[4:]
    prefix_us2 = buffer[0:prefix_length_value]
    buffer = buffer[prefix_length_value:]

    balance = buffer[0:16]
    balance_value = int.from_bytes(balance, 'little')
    buffer = buffer[16:]

    hashmap_length = buffer[0:4]
    hashmap_length_value = int.from_bytes(hashmap_length, 'little')
    buffer = buffer[4:]
    

    print("Main Structure:----------------")
    print("Owner: %s" % (owner))
    print("Vector length: %s" % (vector_length_value))
    print("Vector prefix: %s" % (prefix_v))
    print("UnorderedSet length: %s" % (set_length_value))
    print("UnorderedSet prefix1: %s, prefix2: %s" % (prefix_us1, prefix_us2))
    print("Balance : %s" % (balance_value))
    print("hashmap length : %s" % (hashmap_length_value))

    for i in range(hashmap_length_value):
        key_length = int.from_bytes(buffer[0:4], 'little')
        key = buffer[4:4+key_length]
        value = int.from_bytes(buffer[4+key_length:4+key_length+4], 'little')
        print("    friend %s has rate %s" % (key, value))

     

if __name__ == '__main__':

    # fetch(None, "whole")
    # analyse("whole")
    (plain, hex_plain) = show_b64_str(b'U1RBVEU=')
    print("content:", plain)
    print("hex    : b'{}'".format(hex_plain))
'''
'''--- tools/storage_analyser/near_rpc.py ---
import requests
import base64
import json

class NodeJsonProviderError(Exception):
    pass

class NodeJsonProvider(object):

    def __init__(self, node):
        self._rpc_addr = node

    def rpc_addr(self):
        return self._rpc_addr

    def json_rpc(self, method, params, timeout=300):
        j = {
            'method': method,
            'params': params,
            'id': 0,
            'jsonrpc': '2.0'
        }
        r = requests.post(self.rpc_addr(), json=j, timeout=timeout)
        r.raise_for_status()
        content = json.loads(r.content)
        if "error" in content:
            raise NodeJsonProviderError(content["error"])
        return content["result"]

    def send_tx(self, signed_tx):
        return self.json_rpc('broadcast_tx_async', [base64.b64encode(signed_tx).decode('utf8')])

    def send_tx_and_wait(self, signed_tx, timeout):
        return self.json_rpc('broadcast_tx_commit', [base64.b64encode(signed_tx).decode('utf8')], timeout=timeout)

    def get_status(self):
        r = requests.get("%s/status" % self.rpc_addr(), timeout=2)
        r.raise_for_status()
        return json.loads(r.content)
    
    def rpc_status(self):
        return self.json_rpc('status', [None])

    def get_validators(self):
        return self.json_rpc('validators', [None])

    def query(self, query_object):
        return self.json_rpc('query', query_object)

    def get_account(self, account_id, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_account", "account_id": account_id, "finality": finality})

    def get_access_key_list(self, account_id, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_access_key_list", "account_id": account_id, "finality": finality})

    def get_access_key(self, account_id, public_key, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_access_key", "account_id": account_id,
                                       "public_key": public_key, "finality": finality})

    def view_call(self, account_id, method_name, args, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "call_function", "account_id": account_id,
                                       "method_name": method_name, "args_base64": base64.b64encode(args).decode('utf8'), "finality": finality})

    def get_block(self, block_id):
        return self.json_rpc('block', [block_id])

    def get_chunk(self, chunk_id):
        return self.json_rpc('chunk', [chunk_id])

    def get_tx(self, tx_hash, tx_recipient_id):
        return self.json_rpc('tx', [tx_hash, tx_recipient_id])

    def get_changes_in_block(self, changes_in_block_request):
        return self.json_rpc('EXPERIMENTAL_changes_in_block', changes_in_block_request)

    def ping_node(self):
        ret = {'latest_block_height': 0, 'syncing': True}

        try:
            # status = self.get_status()
            status = self.rpc_status()
            print(status)
            if "sync_info" in status:
                ret['latest_block_height'] = status['sync_info']['latest_block_height']
                ret['syncing'] = status['sync_info']['syncing']
        except NodeJsonProviderError as e:
            print("ping node MultiNodeJsonProviderError: ", e)
        except Exception as e:
            print("ping node Exception: ", e)
    
        return ret

if __name__ == "__main__":
    pass
'''
'''--- tools/wasm_verification/rpc_provider.py ---
import requests
import base64
import json

class JsonProviderError(Exception):
    pass

class JsonProvider(object):

    def __init__(self, rpc_addr):
        if isinstance(rpc_addr, tuple):
            self._rpc_addr = "http://%s:%s" % rpc_addr
        else:
            self._rpc_addr = rpc_addr

    def rpc_addr(self):
        return self._rpc_addr

    def json_rpc(self, method, params, timeout=2):
        j = {
            'method': method,
            'params': params,
            'id': 'dontcare',
            'jsonrpc': '2.0'
        }
        r = requests.post(self.rpc_addr(), json=j, timeout=timeout)
        r.raise_for_status()
        content = json.loads(r.content)
        if "error" in content:
            raise JsonProviderError(content["error"])
        return content["result"]

    def send_tx(self, signed_tx):
        return self.json_rpc('broadcast_tx_async', [base64.b64encode(signed_tx).decode('utf8')])

    def send_tx_and_wait(self, signed_tx, timeout):
        return self.json_rpc('broadcast_tx_commit', [base64.b64encode(signed_tx).decode('utf8')], timeout=timeout)

    def get_status(self):
        r = requests.get("%s/status" % self.rpc_addr(), timeout=2)
        r.raise_for_status()
        return json.loads(r.content)

    def get_validators(self):
        return self.json_rpc('validators', [None])

    def query(self, query_object):
        return self.json_rpc('query', query_object)

    def get_account(self, account_id, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_account", "account_id": account_id, "finality": finality})

    def get_access_key_list(self, account_id, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_access_key_list", "account_id": account_id, "finality": finality})

    def get_access_key(self, account_id, public_key, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "view_access_key", "account_id": account_id,
                                       "public_key": public_key, "finality": finality})

    def view_call(self, account_id, method_name, args, finality='optimistic'):
        return self.json_rpc('query', {"request_type": "call_function", "account_id": account_id,
                                       "method_name": method_name, "args_base64": base64.b64encode(args).decode('utf8'), "finality": finality})

    def get_block(self, block_id):
        return self.json_rpc('block', [block_id])

    def get_chunk(self, chunk_id):
        return self.json_rpc('chunk', [chunk_id])

    def get_tx(self, tx_hash, tx_recipient_id):
        return self.json_rpc('tx', [tx_hash, tx_recipient_id])

    def get_changes_in_block(self, changes_in_block_request):
        return self.json_rpc('EXPERIMENTAL_changes_in_block', changes_in_block_request)
    
    def get_tx_status(self, tx_hash, sender_id):
        return self.json_rpc('EXPERIMENTAL_tx_status', [tx_hash, sender_id])

if __name__ == "__main__":
    conn = JsonProvider("https://rpc.testnet.near.org")
    status = conn.get_status()
    if "version" in status:
        print(status["version"])
    if "sync_info" in status:
        print(status['sync_info'])

    conn = JsonProvider("https://rpc.mainnet.near.org")
    ret = conn.get_account("v2.ref-finance.near")
    print(ret)

'''
'''--- tools/wasm_verification/verify.py ---
import json
import os
import hashlib
import base58
from rpc_provider import JsonProvider, JsonProviderError

def CalcFileSha256(filname):
    ''' calculate file sha256 '''
    with open(filname, "rb") as f:
        sha256obj = hashlib.sha256()
        sha256obj.update(f.read())
        bvalue = sha256obj.digest()
        # hash_value = sha256obj.hexdigest()
        return bvalue

def get_code_hash(contract_id, network):
    code_hash = ""
    rpc_endpoint = "https://rpc.testnet.near.org"
    if network.lower() == "mainnet":
        rpc_endpoint = "https://rpc.mainnet.near.org"
    try:
        conn = JsonProvider(rpc_endpoint)
        ret = conn.get_account(contract_id)
        code_hash = ret['code_hash']
    except JsonProviderError as e:
        print("RPC Error: ", e)
    except Exception as e:
        print("Error: ", e)
    return code_hash

if __name__ == '__main__':
    import getopt
    import sys
    try:
        opts, args = getopt.getopt(sys.argv[1:], "f:c:n:", [])
    except getopt.GetoptError:
        print('In except getopt.GetoptError')
        sys.exit(2)
    
    filepath = ""
    contract = ""
    network = "mainnet"
    for opt, arg in opts:
        if opt in ("-f",):  # wasm filepath
            filepath = arg
        elif opt in ("-c",):  # contract id
            contract = arg
        elif opt in ("-n",):  # network id
            network = arg
    
    print("WASM file: %s" % filepath)
    print("Contract %s on %s" % (contract, network))

    
    code_hash_local = bytes.decode(base58.b58encode(CalcFileSha256(filepath)))
    print("local:  ", code_hash_local)
    code_hash_net = get_code_hash(contract, network)
    print("network:", code_hash_net)
    if code_hash_local == code_hash_net:
        print("OK, Identical")
    else:
        print("!!!Different!!!")

    # python verify.py -f ref_exchange_release.wasm -c v2.ref-finance.near
    # python verify.py -f ref_token.wasm -c token.v2.ref-finance.near

'''