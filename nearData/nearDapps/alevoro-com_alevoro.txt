*GitHub Repository "alevoro-com/alevoro"*

'''--- src/config.js ---
const CONTRACT_NAME =  "contract.alevoro.testnet";

function getConfig (env) {
  switch (env) {
    case 'production':
    case 'mainnet':
      return {
        networkId: 'mainnet',
        nodeUrl: 'https://rpc.mainnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.near.org',
        helperUrl: 'https://helper.mainnet.near.org'
      }
    case 'development':
    case 'testnet':
      return {
        networkId: 'testnet',
        nodeUrl: 'https://rpc.testnet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.testnet.near.org',
        helperUrl: 'https://helper.testnet.near.org'
      }
    case 'betanet':
      return {
        networkId: 'betanet',
        nodeUrl: 'https://rpc.betanet.near.org',
        contractName: CONTRACT_NAME,
        walletUrl: 'https://wallet.betanet.near.org',
        helperUrl: 'https://helper.betanet.near.org'
      }
    case 'local':
      return {
        networkId: 'local',
        nodeUrl: 'http://localhost:3030',
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: 'http://localhost:4000/wallet',
        contractName: CONTRACT_NAME
      }
    case 'test':
    case 'ci':
      return {
        networkId: 'shared-test',
        nodeUrl: 'https://rpc.ci-testnet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      }
    case 'ci-betanet':
      return {
        networkId: 'shared-test-staging',
        nodeUrl: 'https://rpc.ci-betanet.near.org',
        contractName: CONTRACT_NAME,
        masterAccount: 'test.near'
      }
    default:
      throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`)
  }
}

module.exports = getConfig;

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
  <link rel="stylesheet" href="main.css">
</head>
<body>
  <div class="bg">
    <img class="bg__image" src="assets/bg.jpg" alt="">
  </div>
  <h1 class="site-title">alevoro.</h1>
  <h2 class="page-title">Profile</h2>
  <!--  LOGIN  -->
  <div class="login-container">
      <p class="my-account"></p>
      <p class="my-karma"></p>
      <p class="btn login" >Sign In</p>
  </div>
  <div class="navigator-container">
    <b class="btn navigator market-btn">Market</b><b class="navigator">|</b>
    <b class="btn navigator mint-btn">NFT Faucet</b><b class="navigator">|</b>
    <b class="btn navigator mynfts-btn">My NFTs</b><b class="navigator">|</b>
    <b class="btn navigator myloans-btn">My loans</b>
  </div>

  <div class="gallery"></div>
  <div class="gallery-alert"><div class="alert">Please, sign in</div></div>

  <!--  MODALS  -->
  <div id="mintModal" class="modal">
    <div id="mint-content-id" class="modal-content">
      <div class="modal-header">
        <span class="close closeMint">&times;</span>
        <h2>NFT Faucet</h2>
      </div>
      <p>Get NFT for testing purposes using Mintbase testnet app</p>
      <button class="modal-btn get-mint-url">Get</button>
    </div>
  </div>
  <div id="nftModal" class="modal">
    <div id="nft-content-id" class="modal-content">
      <div class="modal-header">
        <span class="close closeNFT">&times;</span>
        <h2 class="title-modal-nft"></h2>
      </div>
      <div id="modal-borrow-block">
        <p>Customize the parameters and put your NFT asset up as collateral for a loan</p>
        <p>Amount Ⓝ: <input class="modal-input input-amount" type="number" value="100" name="amount" min="1" max="100000"></p>
        <p>APR: <input class="modal-input input-apr" type="number"name="apr" value="30" min="1" max="10000"></p>
        <p>Duration:  </p>
        <p><input class="input-days slider" type="range" min="0" max="366" value="0" step="1"></p>
        <p><b class="output-days">0</b>&nbsp;days</p>
        <p><input class="input-hours slider" type="range" min="0" max="23" value="0" step="1"></p>
        <p><b class="output-hours">0</b>&nbsp;hours</p>
        <p><input class="input-minutes slider" type="range" min="0" max="59" value="0" step="1"></p>
        <p><b class="output-minutes">0</b>&nbsp;minutes</p>
      </div>
      <div id="modal-back-block">
        <p>Amount: <b class="amount">-</b><b> Ⓝ</b></p>
        <p>Duration: <b class="duration">-</b></p>
        <p>APR: <b class="apr">-</b></p>
        <div class="confirmed">
          <p>Creditor: <b class="creditor">-</b></p>
          <p>Time left: <b class="timer">-</b></p>
        </div>
      </div>
      <button class="modal-btn modal-main-btn"></button>
    </div>
  </div>

  <script src="./main.js"></script>
</body>
</html>

'''
'''--- src/main.js ---
import "regenerator-runtime/runtime";
import * as nearAPI from "near-api-js";
import getConfig from "./config";
import {getNFTsInfo, showNFT} from "./nft-utils/nft-utils.js";
import {getNFTs, viewAccountNFT} from "./nft-view/nft-view";
import {NFT} from "./nft-utils/classes";

const nearConfig = getConfig(process.env.NODE_ENV || "development");

const GAS = "200000000000000";

export const {
    utils: {
        format: {
            formatNearAmount, parseNearAmount
        }
    }
} = nearAPI;

let allNfts = {};
let marketNfts = {};
let myLoanNFTs = {};
let navigatorState = "Market";
let timer;
let stateTick = 0;

const SEC_IN_MIN = 60;
const SEC_IN_HOUR = 60 * SEC_IN_MIN;
const SEC_IN_DAY = 24 * SEC_IN_HOUR;

const CONTRACT_NAME = nearConfig.contractName;

async function connect(nearConfig) {
    // Connects to NEAR and provides `near`, `walletAccount` and `contract` objects in `window` scope
    // Initializing connection to the NEAR node.
    window.near = await nearAPI.connect({
        deps: {
            keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore()
        },
        ...nearConfig
    });

    // Needed to access wallet login
    window.walletConnection = new nearAPI.WalletConnection(window.near);

    // Initializing our contract APIs by contract name and configuration.
    window.contract = await new nearAPI.Contract(window.walletConnection.account(), nearConfig.contractName, {
        // View methods are read-only – they don't modify the state, but usually return some value
        viewMethods: ['get_debtors_tokens', 'get_locked_tokens', 'get_all_locked_tokens'],
        // Change methods can modify the state, but you don't receive the returned value when called
        changeMethods: ['transfer_nft_back', 'repay_loan',
            'transfer_deposit_for_nft', 'check_transfer_overdue_nft_to_creditor'],
        // Sender is the account ID to initialize transactions.
        // getAccountId() will return empty string if user is still unauthorized
        sender: window.walletConnection.getAccountId()
    });

}

function updateUI() {
    console.log("update UI");

    document.querySelector('.' + navigatorState.toLowerCase() + '-btn').style.textDecoration = "underline";
    document.querySelector('.gallery-alert').style.display = 'block';
    document.querySelector('.alert').innerHTML = "";
    if (!window.walletConnection.getAccountId()) {
        document.querySelector('.alert').innerHTML = "Please, sign in";
        document.querySelector('.my-account').style.display = 'none';
        document.querySelector('.my-karma').style.display = 'none';
        document.querySelector('.login').innerHTML = "sign in";
        document.querySelector(".gallery").innerHTML = "";
    } else {
        let myAcc = document.querySelector('.my-account');
        let myKarma = document.querySelector('.my-karma');
        myAcc.style.display = 'block';
        myAcc.innerHTML = window.walletConnection.getAccountId();
        myKarma.style.display = 'block';
        myKarma.innerHTML = "Karma: 100";

        document.querySelector('.login').innerHTML = "sign out";
        document.querySelector(".gallery").innerHTML = "";
        const curStateTick = stateTick;
        getAccountNFTs(window.walletConnection.getAccountId()).then(res =>
            initNFTs(res, "MyNFTs", curStateTick)
        );

        if (navigatorState === "MyNFTs") {
            contract.get_locked_tokens({
                account_id: window.walletConnection.getAccountId(),
                need_all: true
            }).then(res => {
                initNFTs(getNFTsInfo(res, CONTRACT_NAME), "MyNFTs", curStateTick);
            });
        } else if (navigatorState === "Market") {
            contract.get_all_locked_tokens({need_all: false}).then(res => {
                initNFTs(getNFTsInfo(res, CONTRACT_NAME), "Market", curStateTick);
            });
        } else if (navigatorState === "MyLoans") {
            contract.get_debtors_tokens({
                account_id: window.walletConnection.getAccountId()
            }).then(res => {
                initNFTs(getNFTsInfo(res, CONTRACT_NAME), "MyLoans", curStateTick);
            });
        }

        setTimeout(function () {
            document.querySelector('.alert').innerHTML = getAlertPhrase();
        }, 500);

    }
}

async function getAccountNFTs(ownerWallet) {
    let nfts = [];
    const contracts = await getNFTs(ownerWallet);
    for (const contactId of contracts) {
        const list = await viewAccountNFT(contactId, ownerWallet);
        if (!list || list.error || !list.length) continue;
        for (let i = 0; i < list.length; i++) {
            if (!list[i] || list[i].error) continue;
            console.log(list[i]);
            nfts.push(new NFT(list[i].title, list[i].owner_id, list[i].id, list[i].media, list[i].reference, list[i].type, false))
        }
    }
    return nfts;
}

function initNFTs(nfts, PAGE, curStateTick) {
    if (curStateTick !== stateTick) {
        return;
    }
    addLoadedNfts(nfts, PAGE);
    if (navigatorState === PAGE) {
        if (nfts.length > 0) {
            document.querySelector('.gallery-alert').style.display = 'none';
        }
        showGallery(nfts, PAGE);
    }
}

function addLoadedNfts(nfts, curPage) {
    for (let nft of nfts) {
        if (curPage === "Market") {
            marketNfts[nft.token_id] = nft;
        } else if (curPage === "MyLoans") {
            myLoanNFTs[nft.token_id] = nft;
        } else {
            allNfts[nft.token_id] = nft;
        }
    }
}

function getAlertPhrase() {
    if (navigatorState === 'Market') {
        return 'Market is empty'
    }
    if (navigatorState === 'MyNFTs') {
        return "You don't have any NFTs"
    }
    if (navigatorState === 'MyLoans') {
        return "You don't have any debtors"
    }
    return ""
}

function showGallery(nfts, nftState) {
    for (let i = 0; i < nfts.length; i++) {
        document.querySelector(".gallery").innerHTML += showNFT(nfts[i], nftState);
    }
    if (nfts.length > 0) {
        $('.container_image').off('click').click(function () {
            showModalNft(this.id, nftState)
        });
    }
}

function showModalNft(id, nftState) {
    modalNFT.style.display = "block";
    let nft;
    if (nftState === 'Market') {
        nft = marketNfts[id];
    } else if (nftState === 'MyLoans') {
        nft = myLoanNFTs[id];
    } else {
        nft = allNfts[id];
    }
    let deposit = parseNearAmount('0.1');
    const lockedBlock = document.getElementById('modal-back-block');
    const borrowBlock = document.getElementById('modal-borrow-block');
    document.querySelector('.modal-main-btn').style.display = 'inline';
    if (nft.hasOwnProperty('state') && (nft.state === 'Sale' || nft.state === 'Locked')) {
        lockedBlock.style.display = 'block';
        borrowBlock.style.display = 'none';

        document.querySelector('.apr').innerHTML = nft.apr;
        const curDur = secondsToTime(nft.duration);
        document.querySelector('.duration').innerHTML = `${curDur[0]} days, ${curDur[1]}:${curDur[2]}:${curDur[3]}`;
        document.querySelector('.amount').innerHTML = formatNearAmount(nft.borrowed_money);
        if (nft.state === "Locked") {
            document.querySelector('.confirmed').style.display = 'block';
            document.querySelector('.modal-main-btn').innerHTML = "Repay loan";
            document.querySelector('.creditor').innerHTML = nft.creditor;
            let curTime = Math.round(new Date().getTime() / 1000);
            let timeLeft = Number.parseInt(nft.duration) - (curTime - Number.parseInt((nft.start_time).toString().slice(0, 10)));
            let multiplier = 1 + (Number.parseInt(nft.apr) / 100);
            deposit = parseNearAmount((Number.parseFloat(formatNearAmount(nft.borrowed_money)) * multiplier).toString());
            if (nftState === 'MyLoans') {
                document.querySelector('.title-modal-nft').innerHTML = "Debtor";
                if (timeLeft > 0) {
                    showTimer(timeLeft, () => {
                        if (navigatorState === 'MyLoans' && nft.state !== 'TransferToCreditor' && nft.state !== 'TransferToBorrower') {
                            document.querySelector('.modal-main-btn').style.display = 'inline';
                            document.querySelector('.modal-main-btn').innerHTML = "Claim NFT";
                            $('.modal-main-btn').off('click').click(function () {
                                document.querySelector('.modal-main-btn').style.display = 'none';
                                contract.check_transfer_overdue_nft_to_creditor({token_id: id}).then(goToNFTsAndUpdate);
                            });
                        }
                    });
                    document.querySelector('.modal-main-btn').style.display = 'none';
                } else {
                    showTimer(timeLeft, () => {
                    });
                    if (nft.state !== 'TransferToCreditor' && nft.state !== 'TransferToBorrower') {
                        document.querySelector('.modal-main-btn').innerHTML = "Claim NFT";
                        $('.modal-main-btn').off('click').click(function () {
                            document.querySelector('.modal-main-btn').style.display = 'none';
                            contract.check_transfer_overdue_nft_to_creditor({token_id: id}).then(goToNFTsAndUpdate);
                        });
                    }
                }
            } else {
                document.querySelector('.title-modal-nft').innerHTML = "Repay";
                showTimer(timeLeft, function () {
                    if (navigatorState === 'MyNFTs') {
                        document.querySelector('.modal-main-btn').style.display = 'none';
                        document.querySelector('.title-modal-nft').innerHTML = "Lost NFT";
                    }
                });
                $('.modal-main-btn').off('click').click(function () {
                    contract.repay_loan({token_id: id}, GAS, deposit.toString()).then(updateUI);
                });
            }
        } else {
            document.querySelector('.confirmed').style.display = 'none';
            if (nftState === 'Market') {
                if (window.walletConnection.getAccountId() === nft.real_owner) {
                    document.querySelector('.title-modal-nft').innerHTML = "Your NFT";
                    document.querySelector('.modal-main-btn').style.display = 'none';
                } else {
                    document.querySelector('.title-modal-nft').innerHTML = "Lend";
                    document.querySelector('.modal-main-btn').innerHTML = "Lend";
                    $('.modal-main-btn').off('click').click(function () {
                        contract.transfer_deposit_for_nft({token_id: nft.token_id}, GAS, nft.borrowed_money).then(updateUI);
                    });
                }
            } else {
                document.querySelector('.title-modal-nft').innerHTML = "Return";
                document.querySelector('.modal-main-btn').innerHTML = "Return NFT";
                $('.modal-main-btn').off('click').click(function () {
                    contract.transfer_nft_back({token_id: id}, GAS, deposit).then(updateUI);
                });
            }
        }
    } else {
        if (!nft.hasOwnProperty('state')) {
            document.querySelector('.title-modal-nft').innerHTML = "Borrow";
            document.querySelector('.modal-main-btn').innerHTML = "Place offer";
            lockedBlock.style.display = 'none';
            borrowBlock.style.display = 'block';
            $('.modal-main-btn').off('click').click(function () {
                const amount = parseNearAmount(document.querySelector(".input-amount").value);
                const apr = Number.parseInt(document.querySelector(".input-apr").value);
                const days = Number.parseInt(document.querySelector(".input-days").value);
                const hours = Number.parseInt(document.querySelector(".input-hours").value);
                const minutes = Number.parseInt(document.querySelector(".input-minutes").value);
                const seconds = days * SEC_IN_DAY + hours * SEC_IN_HOUR + minutes * SEC_IN_MIN;

                if (amount && seconds && apr && apr > 0 && seconds > 0) {
                    const idAndContract = id.split(':');
                    const params = [idAndContract[1], amount, apr, seconds, nft.extra, nft.type, nft.title, nft.url];
                    const msg = params.join("!#@");
                    console.log(msg);
                    window.walletConnection.account().functionCall(
                        idAndContract[1],
                        'nft_approve',
                        {
                            token_id: idAndContract[0],
                            account_id: CONTRACT_NAME,
                            msg: msg
                        },
                        "300000000000000",
                        parseNearAmount('0.1')
                    ).then(updateUI);
                    modalNFT.style.display = "none";
                }
            });
        } else {
            document.querySelector('.title-modal-nft').innerHTML = "Pending return";
            lockedBlock.style.display = 'none';
            borrowBlock.style.display = 'none';
            document.querySelector('.modal-main-btn').style.display = 'none';
        }
    }
}

function secondsToTime(secondsLeft) {
    function formatNumber(num) {
        if (num / 10 < 1) {
            return '0' + num;
        }
        return num;

    }

    const seconds = formatNumber(secondsLeft % 60);
    const minutes = formatNumber(Math.floor(secondsLeft / SEC_IN_MIN) % 60);
    const hours = formatNumber(Math.floor(secondsLeft / SEC_IN_HOUR) % 24);
    const days = Math.floor(secondsLeft / (SEC_IN_DAY));
    return [days, hours, minutes, seconds]
}

function showTimer(secondsLeft, callback) {
    calculate();
    timer = setInterval(calculate, 1000);

    function calculate() {
        if (secondsLeft <= 0) {
            clearInterval(timer);
            document.querySelector('.timer').innerHTML = 'Time is over';
            callback();
            return
        }

        const curTime = secondsToTime(secondsLeft);
        document.querySelector('.timer').innerHTML = `${curTime[0]} days, ${curTime[1]}:${curTime[2]}:${curTime[3]}`;

        secondsLeft -= 1;
    }
}

function changeNavigatorState(newState) {
    if (navigatorState !== newState) {
        document.querySelector('.' + navigatorState.toLowerCase() + '-btn').style.textDecoration = "none";
        navigatorState = newState;
        stateTick += 1;
        updateUI()
    }
}

function goToNFTsAndUpdate() {
    modalNFT.style.display = "none";
    changeNavigatorState("MyNFTs");
}

let modalNFT = document.getElementById("nftModal");

document.querySelector('.closeNFT').addEventListener("click", function () {
    modalNFT.style.display = "none";
    clearInterval(timer);

    $("#nft-content-id").removeClass("modal-content");
    setTimeout(function () {
        $("#nft-content-id").addClass("modal-content");
    }, 1)
});

let modalMint = document.getElementById("mintModal");

document.querySelector('.mint-btn').addEventListener("click", function () {
    modalMint.style.display = "block";
});

document.querySelector('.get-mint-url').addEventListener("click", function () {
    closeMint();
    window.open("https://testnet.mintbase.io/thing/_oDJUEmptoHoi5hKS0Zrs95d3qOY2tiiwLlF_jMZ3TQ:arti.mintspace2.testnet", '_blank').focus();
});

document.querySelector('.closeMint').addEventListener("click", function () {
    closeMint();
});

function closeMint() {
    modalMint.style.display = "none";

    $("#mint-content-id").removeClass("modal-content");
    setTimeout(function(){
        $("#mint-content-id").addClass("modal-content");
    },1 )
}

document.querySelector('.market-btn').addEventListener("click", function () {
    changeNavigatorState("Market");
});

document.querySelector('.mynfts-btn').addEventListener("click", function () {
    changeNavigatorState("MyNFTs");
});

document.querySelector('.myloans-btn').addEventListener("click", function () {
    changeNavigatorState("MyLoans");
});

document.querySelector('.input-days').addEventListener("input", function () {
    document.querySelector('.output-days').innerHTML = this.value;
});

document.querySelector('.input-hours').addEventListener("input", function () {
    document.querySelector('.output-hours').innerHTML = this.value;
});

document.querySelector('.input-minutes').addEventListener("input", function () {
    document.querySelector('.output-minutes').innerHTML = this.value;
});

document.querySelector('.login').addEventListener("click", function () {
    if (!window.walletConnection.getAccountId()) {
        walletConnection.requestSignIn(nearConfig.contractName, 'My contr');
    } else {
        walletConnection.signOut();
    }
    updateUI()
});

window.nearInitPromise = connect(nearConfig).then(updateUI);

'''
'''--- src/nft-utils/classes.js ---
export {NFT, LockedNFT}

class NFT {
    constructor(title, owner, token_id, url, extra, type) {
        this.title = title;
        this.owner = owner;
        this.token_id = token_id;
        this.url = url;
        this.extra = extra;
        this.type = type;
    }
}

class LockedNFT extends NFT {
    constructor(title, owner, token_id, url, extra, type,
                apr, borrowed_money, duration, real_owner, state, creditor, start_time) {
        super(title, owner, token_id, url, extra, type);

        this.apr = apr;
        this.borrowed_money = borrowed_money;
        this.duration = duration;
        this.real_owner = real_owner;
        this.state = state;
        this.creditor = creditor;
        this.start_time = start_time;
    }
}

'''
'''--- src/nft-utils/nft-utils.js ---
import {LockedNFT} from "./classes";
export {getNFTsInfo, showNFT}

function getNFTsInfo(res, con_name) {
    let nfts = [];
    console.log("LOCKED");
    for (let nft of res) {
        console.log(nft);
        let curNFT = new LockedNFT(nft['title'], con_name, nft['token_id'], nft['media'], nft['extra'], nft['type'],
             nft['apr'], nft['borrowed_money'], nft['duration'], nft['owner_id'], nft['state'],
            nft['creditor'], nft['start_time']);

        nfts.push(curNFT);
    }
    console.log("LOCKED END");
    console.log(nfts);
    return nfts
}

function showNFT(nft, nftState) {
    console.log("show");
    const divInfo = `class=\"container_image\" id=\"${nft.token_id}\"`;
    let bottomText = nft.owner;
    if (nftState === 'Market' || nftState === 'MyLoans' || nft.state === "Return" || nft.state === "TransferToBorrower") {
        bottomText = nft.real_owner;
    } else {
        if (nft.state === "Sale"){
            bottomText = "Locked";
        } else if (nft.state === "Locked") {
            bottomText = "Collateral";
        }
    }
    return "<div class=\"nft\">\n" +
        "   <div class=\"nft__image\"><img " + divInfo + " src=\"" + nft.url + "\" alt=\"" + nft.title + "\"></div>\n" +
        "   <a class=\"nft__title\"  href=\"" + nft.extra +"\" target=\"_blank\">" + nft.title + "</a>\n" +
        "   <p class=\"nft__owner\">" + bottomText + "</p>\n" +
        "</div>"
}

'''
'''--- src/nft-view/mintbase.js ---
module.exports = {getMintbase, mintbaseCard};

const fetch = require('node-fetch');

async function getMintbase(url) {
    try {
        const res = await fetch(url, {timeout: 10000});
        if (res.status < 199 || res.status > 299) {
            return {error: res.statusText + ' (' + res.status + ')'}
        }
        const text = await res.text();
        try {
            return JSON.parse(text)
        } catch (err) {
            return {error: text}
        }
    } catch (err) {
        return {error: err}
    }
}

function mintbaseCard(data, is_uri) {
    if (is_uri){
        return  {
            type: 'mintbase',
            media: (data.media || data.animation_url || data.youtube_url),
            title: (data.title || "-")
        };
    }
    return {
        ref: data.reference
    }
}

'''
'''--- src/nft-view/nft-view.js ---
module.exports = {getNFTs, viewAccountNFT};

import {getMintbase, mintbaseCard} from "./mintbase";
const nearApi = require("near-api-js");

async function getNFTs(accountId) {
    try {
        const res = await fetch('https://helper.' + (accountId.substr(-5) === '.near' ? 'mainnet' : 'testnet')
            + '.near.org/account/' + accountId + '/likelyNFTs', {timeout: 30000});
        if (res.status < 199 || res.status > 299) {
            return {error: res.statusText + ' (' + res.status + ')'}
        }
        const text = await res.text();
        try {
            return JSON.parse(text)
        } catch (err) {
            return {error: text}
        }
    } catch (err) {
        return {error: err}
    }
}

async function viewAccountNFT(contractId, accountId) {
    try {
        let result = [];

        const network = accountId.substr(-5) === '.near' ? 'mainnet' : 'testnet';
        const provider = new nearApi.providers.JsonRpcProvider('https://rpc.' + network + '.near.org');
        const account = new nearApi.Account({provider: provider});

        // MINTBASE
        const list = await account.viewFunction(contractId, 'nft_tokens_for_owner_set', {
            account_id: accountId,
            from_index: '0',
            limit: 100
        });
        if (list.error) return [];
        for (const id of list) {
            const url = await account.viewFunction(contractId, 'nft_token_uri', {token_id: '' + id});
            const data_specific = await getMintbase(url);
            if (data_specific && !data_specific.error){
                let cur_res = mintbaseCard(data_specific, true);
                const data = await account.viewFunction(contractId, 'nft_token_metadata', {token_id: '' + id});
                if (data) {
                    const metadata = mintbaseCard(data, false);
                    const reference = "https://" + (network === 'testnet' ? "testnet." : "") +
                        "mintbase.io/thing/" + metadata['ref'] + ":" + contractId;
                    cur_res = {
                        ...cur_res,
                        owner_id: accountId,
                        id: id + ":" + contractId,
                        reference: reference
                    };
                    result.push(cur_res);
                }
            }

        }
        return result
    } catch (err) {
        return {error: err.type || err}
    }
}

'''
'''--- src/script.js ---
const nearAPI = require("near-api-js");

const { connect, keyStores ,KeyPair } = nearAPI;
const jsonKey = require('../neardev/keys/contract.pep.testnet');

const CONTRACT_NAME = 'contract.pep.testnet';

async function auth(){
    const keyStore = new keyStores.InMemoryKeyStore();
    const PRIVATE_KEY = jsonKey['private_key'];
    const keyPair = KeyPair.fromString(PRIVATE_KEY);

    await keyStore.setKey("testnet", CONTRACT_NAME, keyPair);
    console.log("AUTH START");
    const config = {
        networkId: "testnet",
        keyStore: keyStore,
        nodeUrl: "https://rpc.testnet.near.org",
        walletUrl: "https://wallet.testnet.near.org",
        helperUrl: "https://helper.testnet.near.org",
        explorerUrl: "https://explorer.testnet.near.org",
    };

    const near = await connect(config);
    const account = await near.account(CONTRACT_NAME);
    console.log("AUTH END");
    return account;
}

async function main() {
    const account = await auth();
    console.log("DONE");

    const nfts = await read_contract(account);
    console.log("READ COMPLETE");
    for (let nft of nfts) {
        const idAndContract = nft['token_id'].split(":");
        if (nft.state === "Return") {
            await send_nft(account, idAndContract[1], idAndContract[0], nft.owner_id)
        } else if (nft.state === "TransferToBorrower") {
            await send_nft(account, idAndContract[1], idAndContract[0], nft.owner_id)
        } else if (nft.state === "TransferToCreditor") {
            await send_nft(account, idAndContract[1], idAndContract[0], nft.creditor)
        }
    }

}

async function read_contract(account) {
    try {
        const tx = await account.viewFunction(
            CONTRACT_NAME,
            'get_all_locked_tokens',
            {
                need_all: true
            }
        );
        console.log(tx);
        return tx
    } catch (e) {
        console.log("ERROR");
        console.log(e);
        return []
    }
}

async function send_nft(account, contractId, tokenId, receiverId) {
    try {
        const tx = await account.viewFunction(
            contractId,
            'nft_token',
            {
                token_id: tokenId,
            }
        );
        if (tx.owner_id.Account === receiverId) {
            console.log(tx);
            deleteFromContract(account, contractId, tokenId);
        } else {
            const res = await account.functionCall(
                contractId,
                'nft_transfer',
                {
                    token_id: tokenId,
                    receiver_id: receiverId
                },
                '100000000000000',
                '1'
            );
            if (res.status !== null && typeof res.status.SuccessValue === 'string') {
                deleteFromContract(account, contractId, tokenId);
            }
        }
    } catch (e) {
        console.log("ERROR");
        console.log(e);
    }
}

async function deleteFromContract(account, contractId, tokenId){
    console.log("DEL");
    const del_tx = await account.functionCall(
        CONTRACT_NAME,
        'remove_transferred_token_from_locked_tokens',
        {
            token_id: tokenId + ":" + contractId,
        },
        '100000000000000',
        '1'
    );
    console.log(del_tx);
}

main();
'''
'''--- src/test-setup.js ---
(function () {
  let params = new URL(window.location).searchParams;
  let keyStore = new nearlib.keyStores.InMemoryKeyStore();
  nearConfig.contractName = params.get('contractName') || nearConfig.contractName;
  keyStore.setKey(nearConfig.networkId, nearConfig.contractName, nearlib.KeyPair.fromString(params.get('privateKey')));
  nearConfig.deps = { keyStore };
})();

'''
'''--- src/test.js ---
describe('Token', function () {
  let near;
  let contract;
  let accountId;

  jasmine.DEFAULT_TIMEOUT_INTERVAL = 10000;

  beforeAll(async function () {
    console.log('nearConfig', nearConfig);
    near = await nearlib.connect(nearConfig);
    accountId = nearConfig.contractName;
    contract = await near.loadContract(nearConfig.contractName, {
      viewMethods: ['get_num'],
      changeMethods: ['increment', 'decrement', 'reset'],
      sender: accountId
    });
  });

  describe('counter', function () {
    it('can be incremented', async function () {
      const startCounter = await contract.get_num();
      await contract.increment();
      const endCounter = await contract.get_num();
      expect(endCounter).toEqual(startCounter + 1);
    });
    it('can be decremented', async function () {
      await contract.increment();
      const startCounter = await contract.get_num();
      await contract.decrement();
      const endCounter = await contract.get_num();
      expect(endCounter).toEqual(startCounter - 1);
    });
    it('can be reset', async function () {
      await contract.increment();
      const startCounter = await contract.get_num();
      await contract.reset();
      const endCounter = await contract.get_num();
      expect(endCounter).toEqual(0);
    });
  });
});
'''