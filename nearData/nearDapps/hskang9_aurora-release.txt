*GitHub Repository "hskang9/aurora-release"*

'''--- README.md ---
# aurora-release
Aurora release modifications for E2E tests

'''
'''--- aurora-engine-2.8.1/.env/custom_example.env ---
# To create a new "custom.env" which is then invoked by `--profile custom`, the available
# environment values are below with an explanation.
#
# Simply remove the prefixed `#` to enable them.

# The cargo features should either be `mainnet`, `testnet` or something extra in order to make use
# of your own custom features.
#CARGO_FEATURES_BUILD = "mainnet"

# The cargo test features are used to build a test environment version of the engine WASM and test
# library. Either use `mainnet-test`, `testnet-test` or something extra in order to make use of your
# own custom features.
#CARGO_FEATURES_BUILD_TEST = "mainnet,integration-test"

# The cargo features to enable for the testing environment which will use the compiled binary for
# testing.
#CARGO_FEATURES_TEST

# The NEAR evm account where to deploy.
#
# For our own purposes, we have a special `aurora` TLD which only Aurora Labs can deploy to on both
# testnet and mainnet. Otherwise, use a name similar to `aurora-test.near` to deploy locally or
# elsewhere.
#NEAR_EVM_ACCOUNT = "aurora-test.near"

# The Aurora contract WASM file name.
#
# After building the binary, it will end up in the `bin` folder with this following name.
#WASM_FILE = "aurora-custom.wasm"

# The Aurora contract WASM test file name.
#
# To avoid confusion with the mainnet binary, it is wise to set this as something different as the
# test binary should never go to production and is only used in testing exclusively.
#
# After building the binary, it will end up in the `bin` folder with this following name.
#WASM_FILE_TEST = "aurora-custom-test.wasm"

# The NEAR CLI service name to use.
#
# For live purposes, this should be `near` however if you have setup a local development environment
# for the NEAR blockchain following https://docs.near.org/docs/tools/kurtosis-localnet, you should
# instead use `local-near`.
#NEAR_CLI = "local-near"

# The profile name.
#PROFILE = "testnet"

# The Rust compilier flags to use when compiling any binary. Does not work for the tests.
#RUSTC_FLAGS_BUILD = "-C link-arg=-s"

'''
'''--- aurora-engine-2.8.1/.env/local.env ---
CARGO_FEATURES_BUILD="testnet"
RUSTC_FLAGS_BUILD="-C link-arg=-s"
NEAR_EVM_ACCOUNT="aurora.test.near"
WASM_FILE="aurora-local.wasm"
NEAR_CLI="local_near"
PROFILE="testnet"
IS_PROD=false

'''
'''--- aurora-engine-2.8.1/.env/mainnet.env ---
CARGO_FEATURES_BUILD="mainnet"
CARGO_FEATURES_BUILD_TEST="mainnet,integration-test"
CARGO_FEATURES_TEST="mainnet-test"
RUSTC_FLAGS_BUILD="-C link-arg=-s"
NEAR_EVM_ACCOUNT="aurora"
WASM_FILE="aurora-mainnet.wasm"
WASM_FILE_TEST="aurora-mainnet-test.wasm"
NEAR_CLI="near"
PROFILE="mainnet"
IS_PROD=true

'''
'''--- aurora-engine-2.8.1/.env/testnet.env ---
CARGO_FEATURES_BUILD="testnet"
CARGO_FEATURES_BUILD_TEST="testnet,integration-test"
CARGO_FEATURES_TEST="testnet-test"
RUSTC_FLAGS_BUILD="-C link-arg=-s"
NEAR_EVM_ACCOUNT="aurora"
WASM_FILE="aurora-testnet.wasm"
WASM_FILE_TEST="aurora-testnet-test.wasm"
NEAR_CLI="near"
PROFILE="testnet"
IS_PROD=false

'''
'''--- aurora-engine-2.8.1/.github/pull_request_template.md ---
<!--
Thanks for submitting a pull request! Here are some helpful tips:

* Always create branches on and target the `develop` branch.
* Run all the tests locally and ensure that they are passing.
* Run `make format` to ensure that the code is formatted.
* Run `make check` to ensure that all checks passed successfully.
* Small commits and contributions that attempt one single goal is preferable.
* If the idea changes or adds anything functional which will affect users, an 
AIP discussion is required first on the Aurora forum: 
https://forum.aurora.dev/discussions/AIPs%20(Aurora%20Improvement%20Proposals).
* Avoid breaking the public API (namely in engine/src/lib.rs) unless required.
* If your PR is a WIP, ensure that you enable "draft" mode.
* Your first PRs won't use the CI automatically unless a maintainer starts.
If this is not your first PR, please do NOT abuse the CI resources.

Checklist:
- [ ] I have performed a self-review of my code
- [ ] I have documented my code, particularly in the hard-to-understand areas
- [ ] I have made corresponding changes to the documentation
- [ ] I have added tests to prove my fix or new feature is effective and works
- [ ] Any dependent changes have been merged
- [ ] The PR is targeting the `develop` branch and not `master`
- [ ] I have pre-squashed my commits into a single commit and rebased.
-->

## Description

<!-- 
Provide a general summary of your changes. A clear overview along with an 
in-depth explanation is beneficial.

If this PR closes any issues, be sure to add "closes #<number>" somewhere.
-->

## Performance / NEAR gas cost considerations

<!--
Performance regressions are not ideal, though we welcome performance 
improvements. Any PR must be completely mindful of any gas cost increases. The 
CI will fail if the gas costs change at all. Do update these tests to 
accommodate for the new gas changes. It is good to explain 
this change, if necessary.
-->

## Testing

<!--
Please describe the tests that you ran to verify your changes.
-->

## How should this be reviewed

<!--
Include any recommendations of areas to be careful of to ensure that the 
reviewers use extra attention.
-->

## Additional information

<!--
Include any additional information which you think should be in this PR, such
as prior arts, future extensions, unresolved problems, or a TODO list which 
should be followed up.
-->

'''
'''--- aurora-engine-2.8.1/.github/workflows/builds.yml ---
---
on:
  push:
    branches:
      - master
name: Build
jobs:
  release:
    name: Release
    runs-on: [self-hosted, heavy]
    strategy:
      matrix:
        profile: [mainnet, testnet]
    steps:
      - name: Potential broken submodules fix
        run: |
          git checkout -f $(git -c user.name=x -c user.email=x@x commit-tree $(git hash-object -t tree /dev/null) < /dev/null) || :
      - name: Clone the repository
        uses: actions/checkout@v3
      - run: cargo make --profile ${{ matrix.profile }} build-docker
      - run: ls -lH bin/aurora-${{ matrix.profile }}.wasm
      - name: Upload the aurora-${{ matrix.profile }}.wasm artifact
        uses: actions/upload-artifact@v2
        with:
          name: aurora-${{ matrix.profile }}.wasm
          path: bin/aurora-${{ matrix.profile }}.wasm
      - name: Update the latest release
        uses: svenstaro/upload-release-action@v2
        with:
          tag: latest
          file: bin/aurora-${{ matrix.profile }}.wasm
          overwrite: true
          repo_token: ${{ secrets.GITHUB_TOKEN }}
      - name: Update the latest tag
        uses: EndBug/latest-tag@latest
env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0

'''
'''--- aurora-engine-2.8.1/.github/workflows/lints.yml ---
---
on:
  push:
    branches:
      - master
      - develop
  pull_request:

name: Lints
jobs:
  fmt:
    name: Format
    runs-on: [self-hosted, light]
    steps:
      - name: Potential broken submodules fix
        run: |
          git checkout -f $(git -c user.name=x -c user.email=x@x commit-tree $(git hash-object -t tree /dev/null) < /dev/null) || :
      - name: Clone the repository
        uses: actions/checkout@v3
      - name: Run cargo fmt
        run: cargo make check-fmt
  clippy:
    name: Clippy
    runs-on: [self-hosted, heavy]
    steps:
      - name: Potential broken submodules fix
        run: |
          git checkout -f $(git -c user.name=x -c user.email=x@x commit-tree $(git hash-object -t tree /dev/null) < /dev/null) || :
      - name: Clone the repository
        uses: actions/checkout@v3
      - run: cargo make build-contracts
      - name: Run Contract cargo clippy
        run: cargo make clippy
      - name: Run cargo clippy
        run: cargo clippy
  udeps:
    name: Udeps
    runs-on: [self-hosted, heavy]
    steps:
      - name: Potential broken submodules fix
        run: |
          git checkout -f $(git -c user.name=x -c user.email=x@x commit-tree $(git hash-object -t tree /dev/null) < /dev/null) || :
      - name: Clone the repository
        uses: actions/checkout@v3
      - name: Update udeps
        run: cargo install --force cargo-udeps
      - name: Run udeps
        run: cargo make udeps
  contracts:
    name: Contracts
    runs-on: [self-hosted, light]
    steps:
      - name: Potential broken submodules fix
        run: |
          git checkout -f $(git -c user.name=x -c user.email=x@x commit-tree $(git hash-object -t tree /dev/null) < /dev/null) || :
      - name: Clone the repository
        uses: actions/checkout@v3
      - name: Run yarn lint
        run: cargo make check-contracts
      - name: Check committed EvmErc20.bin
        run: bash scripts/verify_evm_erc20.sh

'''
'''--- aurora-engine-2.8.1/.github/workflows/scheduled_lints.yml ---
---
on:
  schedule:
    - cron: '27 8 * * 1,4'
name: Scheduled lints
jobs:
  clippy:
    name: Nightly Clippy
    runs-on: [self-hosted, heavy]
    steps:
      - name: Potential broken submodules fix
        run: |
          git checkout -f $(git -c user.name=x -c user.email=x@x commit-tree $(git hash-object -t tree /dev/null) < /dev/null) || :
      - name: Clone the repository
        uses: actions/checkout@v3
      - run: make etc/eth-contracts/res/EvmErc20.bin
      - name: Update toolchain
        run: rustup update nightly
      - name: Run cargo clippy
        run: cargo +nightly clippy --no-default-features --features=mainnet -- -D warnings

'''
'''--- aurora-engine-2.8.1/.github/workflows/tests.yml ---
---
on:
  push:
    branches:
      - master
      - develop
  pull_request:

name: Tests
jobs:
  test:
    name: Test suite (mainnet, testnet)
    runs-on: [self-hosted, heavy]
    steps:
      - name: Potential broken submodules fix
        run: |
          git checkout -f $(git -c user.name=x -c user.email=x@x commit-tree $(git hash-object -t tree /dev/null) < /dev/null) || :
      - name: Clone the repository
        uses: actions/checkout@v3
      - name: Restore cache
        run: |
          cache-util restore cargo_git cargo_registry yarn_cache
          cache-util restore aurora-engine-target@generic@${{ hashFiles('**/Cargo.lock') }}:target
      - name: Build contracts
        run: cargo make build-contracts
      - name: Test contracts
        run: cargo make test-contracts
      - name: Build mainnet test WASM
        run: cargo make --profile mainnet build-test
      - name: List mainnet WASM directory and root directory
        run: ls -la target/wasm32-unknown-unknown/release && ls -la
      - name: Test mainnet
        run: cargo make --profile mainnet test-workspace
      - name: Build testnet test WASM
        run: cargo make --profile testnet build-test
      - name: List testnet WASM directory and root directory
        run: ls -la target/wasm32-unknown-unknown/release && ls -la
      - name: Test testnet
        run: cargo make --profile testnet test-workspace
      - name: Save cache
        run: |
          cache-util save cargo_git cargo_registry yarn_cache
          cache-util msave aurora-engine-target@generic@${{ hashFiles('**/Cargo.lock') }}:target
env:
  CARGO_TERM_COLOR: always
  CARGO_INCREMENTAL: 0

'''
'''--- aurora-engine-2.8.1/CHANGES.md ---
# Changelog

All notable changes to this project will be documented in this file.

The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/),
and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).

## [Unreleased]

## [2.8.1] 2022-12-07

### Changes

- Performance improvement (approximately 5% reduction in NEAR gas usage) by [@birchmd]. ([#645])

### Fixes

- Tracing bug fix by [@birchmd]. ([#646])

[#645]: https://github.com/aurora-is-near/aurora-engine/pull/645
[#646]: https://github.com/aurora-is-near/aurora-engine/pull/646

## [2.8.0] 2022-11-15

### Added

- New functions `pause_precompiles` and `resume_precompiles` to allow pausing/unpausing the exit precompiles on Aurora by [@RomanHodulak]. ([#588])
- Reproducible build in Docker by [@RomanHodulak]. ([#633])

### Fixes

- Update to latest SputnikVM by [@birchmd] (fixes some security issues including a potential call stack overflow and incorrect `is_static` indicator in exit precompiles). ([#628])
- Minor fixes for the XCC functionality by [@birchmd]. ([#610] [#616] [#622])
- Fix bn256 regression by [@joshuajbouw]. ([#637])

[#588]: https://github.com/aurora-is-near/aurora-engine/pull/588
[#610]: https://github.com/aurora-is-near/aurora-engine/pull/610
[#616]: https://github.com/aurora-is-near/aurora-engine/pull/616
[#622]: https://github.com/aurora-is-near/aurora-engine/pull/622
[#628]: https://github.com/aurora-is-near/aurora-engine/pull/628
[#633]: https://github.com/aurora-is-near/aurora-engine/pull/633
[#637]: https://github.com/aurora-is-near/aurora-engine/pull/637

## [2.7.0] 2022-08-19

### Added
- Get promise results precompile at address on `testnet` `0x0a3540f79be10ef14890e87c1a0040a68cc6af71` by [@birchmd]. ([#575])
- Cross-contract calls to NEAR contracts are now available for `testnet` by [@birchmd] and [@mfornet]. ([#560])

### Changes
- Use NEAR host functions for alt bn256 precompile by [@birchmd], [@joshuajbouw], and [@RomanHodulak]. ([#540])

### Fixes
- Fixed an issue where a transaction can panic on an empty input by [@birchmd]. ([#573])
- Return the correct value while using the `get_bridge_prover` method by [@birchmd]. ([#581])

[#575]: https://github.com/aurora-is-near/aurora-engine/pull/575
[#560]: https://github.com/aurora-is-near/aurora-engine/pull/560
[#540]: https://github.com/aurora-is-near/aurora-engine/pull/540
[#573]: https://github.com/aurora-is-near/aurora-engine/pull/573
[#581]: https://github.com/aurora-is-near/aurora-engine/pull/581

## [2.6.1] 2022-06-23

### Fixes

- Fixed an issue with accounting being problematic with the total supply of ETH on Aurora as it could artificially deplete by [@birchmd]. ([#536])
- Fixed the possibility of forging receipts to allow for withdrawals on the Rainbow Bridge by [@birchmd], [@mfornet], [@sept-en] and [@joshuajbouw]. Written by [@birchmd].
- Fixed the ability the steal funds from those by setting a fee when receiving NEP-141 as ERC-20 by [@birchmd], [@mfornet], and [@joshuajbouw]. Written by [@joshuajbouw].

[#536]: https://github.com/aurora-is-near/aurora-engine/pull/536

## [2.6.0] 2022-06-08

### Added

- A precompile at the address `0x536822d27de53629ef1f84c60555689e9488609f` was created to expose the prepaid gas from the NEAR host function by [@birchmd]. ([#479])

### Changes

- A better implementation of caching was added to reduce the overall gas costs of storage reads resulting in roughly a 15% - 18% reduction of gas costs by [@birchmd]. ([#488])

### Fixes

- If the `v` byte of secp256k1 is incorrect, it now returns correctly an empty vector by [@RomanHodulak]. ([#513])
- Original ETH transactions which do not contain a Chain ID are allowed again to allow for use of [EIP-1820] by [@joshuajbouw]. ([#520])
- Ecrecover didn't reject `r`, `s` values larger than curve order by [@RomanHodulak]. ([#515])
- The predecessor account ID was failing in the `view` method by [@birchmd]. ([#477])
- Ecrecover was incorrectly setting the NEAR ecrecover malleability flag by [@birchmd] and [@joshuajbouw]. ([#474])

[EIP-1820]: https://eips.ethereum.org/EIPS/eip-1820
[#520]: https://github.com/aurora-is-near/aurora-engine/pull/520
[#515]: https://github.com/aurora-is-near/aurora-engine/pull/515
[#513]: https://github.com/aurora-is-near/aurora-engine/pull/513
[#488]: https://github.com/aurora-is-near/aurora-engine/pull/488
[#479]: https://github.com/aurora-is-near/aurora-engine/pull/479
[#477]: https://github.com/aurora-is-near/aurora-engine/pull/477
[#474]: https://github.com/aurora-is-near/aurora-engine/pull/474

## [2.5.3] 2022-04-27

### Fixes

- Fixed inflation vulnerability relating to ExitToNear and ExitToEthereum by [@birchmd], [@mfornet], and [@joshuajbouw]. Written by [@birchmd].

## [2.5.2] 2022-03-22

### Removed

- New Aurora-only precompiles removed since they do not work in NEAR view calls. This will need to be fixed and they will be re-added to a future release.

## [2.5.1] - 2022-03-16

### Fixes

- Fix for bug in checking address exists introduced in the v2.5.0 release by [@birchmd]. ([#469])

### Added

- New Aurora-only precompiles for checking the current and predecessor NEAR account IDs by [@birchmd]. ([#462])

[#462]: https://github.com/aurora-is-near/aurora-engine/pull/462
[#469]: https://github.com/aurora-is-near/aurora-engine/pull/469

## [2.5.0] - 2022-03-09

### Changes

- Performance improvement by [@birchmd] and [@olonho]: ([#455]) ([#456])

### Fixes

- Bug fix for the behaviour of transactions to the zero address by [@birchmd]. ([#458])

[#455]: https://github.com/aurora-is-near/aurora-engine/pull/455
[#456]: https://github.com/aurora-is-near/aurora-engine/pull/456
[#458]: https://github.com/aurora-is-near/aurora-engine/pull/458

## [2.4.0] - 2022-02-16

### Changes

- Performance improvements by [@birchmd] and [@matklad]; the engine should now consume much less NEAR gas: ([#427]) ([#438]) ([#439]) ([#445]) ([#446])
- Security improvment: only Engine contract owner can use the `deploy_upgrade` method by [@birchmd]. ([#410])
- Bug fix: Engine now returns the error message in the case of a revert during an EVM contract deploy, previously it would always return an address (even when the deploy failed) by [@birchmd]. ([#424])
- Security improvment: Engine will no longer accept EVM transactions without a chain ID as part of their signature by [@birchmd]. This should have no impact on users as all modern Ethereum tooling includes the chain ID. ([#432])
- Improvements to code quality by [@mrLSD]: ([#386]) ([#387])
- Improvements and additions to internal tests and benchmarks by [@birchmd]: ([#408]) ([#415]) ([#429])

[#386]: https://github.com/aurora-is-near/aurora-engine/pull/386
[#387]: https://github.com/aurora-is-near/aurora-engine/pull/387
[#408]: https://github.com/aurora-is-near/aurora-engine/pull/408
[#410]: https://github.com/aurora-is-near/aurora-engine/pull/410
[#415]: https://github.com/aurora-is-near/aurora-engine/pull/415
[#424]: https://github.com/aurora-is-near/aurora-engine/pull/424
[#427]: https://github.com/aurora-is-near/aurora-engine/pull/427
[#429]: https://github.com/aurora-is-near/aurora-engine/pull/429
[#432]: https://github.com/aurora-is-near/aurora-engine/pull/432
[#438]: https://github.com/aurora-is-near/aurora-engine/pull/438
[#439]: https://github.com/aurora-is-near/aurora-engine/pull/439
[#445]: https://github.com/aurora-is-near/aurora-engine/pull/445
[#446]: https://github.com/aurora-is-near/aurora-engine/pull/446

## [2.3.0] - 2021-12-10

### Added

- A precompile which exposes NEAR's random number generator was added by [@mfornet] as requested by
  [@birchmd]. ([#368] [#297])
- London hard fork support was added by [@birchmd]. ([#244])

### Changes

- The gas limit for `deposit` and `ft_on_transfer` were changed as they were not attaching enough
  gas, as changed by [@mrLSD]. ([#389])

### Fixes

- There was an issue with the original storage not actually being stored. Unfortunately, previous
  transactions can't be updated with this change. This has been fixed by [@birchmd]. ([#390])
- Call arguments were intended to have a value attached to them to make it equivalent to an ETH
  call. This was fixed in a backwards compatible manner by [@andrcmdr], as reported by [@birchmd].
  ([#351] [#309])

### Removed

- Betanet support was dropped and will no longer be supported by [@joshuajbouw]. ([#388])

[#390]: https://github.com/aurora-is-near/aurora-engine/pull/390
[#389]: https://github.com/aurora-is-near/aurora-engine/pull/389
[#388]: https://github.com/aurora-is-near/aurora-engine/pull/388
[#368]: https://github.com/aurora-is-near/aurora-engine/pull/368
[#351]: https://github.com/aurora-is-near/aurora-engine/pull/351
[#311]: https://github.com/aurora-is-near/aurora-engine/pull/311
[#309]: https://github.com/aurora-is-near/aurora-engine/issues/309
[#297]: https://github.com/aurora-is-near/aurora-engine/issues/297
[#244]: https://github.com/aurora-is-near/aurora-engine/pull/244

## [2.2.0] - 2021-11-09

### Added

- Depositing ETH from Ethereum to Aurora now allows an `0x` prefix on the recipient address by [@joshuajbouw]. ([#337](https://github.com/aurora-is-near/aurora-engine/pull/337))

## [2.1.0] - 2021-11-04

### Fixed

- Bug in `ft_transfer_call` and `ft_resolve_transfer` by  [@birchmd] and [@mrLSD]. ([#326](https://github.com/aurora-is-near/aurora-engine/pull/326) [#330](https://github.com/aurora-is-near/aurora-engine/pull/330))
- Incorrect gas cost on ripemd precompile by [@joshuajbouw]. ([#329](https://github.com/aurora-is-near/aurora-engine/pull/329))

## [2.0.2] - 2021-11-01

### Added

- Logging number of storage writes by [@birchmd]. ([#322](https://github.com/aurora-is-near/aurora-engine/pull/322))

### Fixed

- Show full address in logging transaction sender on `submit` by [@birchmd]. ([#321](https://github.com/aurora-is-near/aurora-engine/pull/321))

## [2.0.1] - 2021-11-01

### Added

- Added logging of public keys during `submit` calls by [@joshuajbouw]. ([#319](https://github.com/aurora-is-near/aurora-engine/pull/319))

## [2.0.0] - 2021-10-27

### Added

- Public method for computing Aurora blockhash at a given hight by [@birchmd]. ([#303](https://github.com/aurora-is-near/aurora-engine/pull/303))

### Changed

- EVM logs returned in `SubmitResult` include the address the log originates from by [@birchmd]. ([#299](https://github.com/aurora-is-near/aurora-engine/pull/299))
  - Note: this is a breaking change in the `SubmitResult` binary format.

### Fixed

- Precompile bug fixes by [@birchmd]. ([#305](https://github.com/aurora-is-near/aurora-engine/pull/305), [#306](https://github.com/aurora-is-near/aurora-engine/pull/306))
- Update to latest `rust-blockchain/evm` version (fixes bug in `JUMPI`) EVM opcode by [@birchmd]. ([#316](https://github.com/aurora-is-near/aurora-engine/pull/316))

## [1.7.0] - 2021-10-13

### Changes

- Add EVM events for exit precompiles by [@birchmd]

## [1.6.4] - 2021-09-29

### Changes

- Fix JSON formatting in `ft_metadata` method by [@birchmd].
- Fix a bug in `block.timestamp` (units should be seconds) by [@birchmd].

## [1.6.3] - 2021-09-14

### Changes

- Revert the ERC-20 admin address changes for the time being by [@joshuajbouw].

## [1.6.2] - 2021-09-13

### Changes

- Change the ERC-20 admin address to have a dedicated account by [@sept-en].
- Fix precompile promises that were broken in rust-blockchain/evm by
  [@joshuajbouw] and [@birchmd].
- Fix the return format of `ft_balance_of` by [@joshuajbouw].

### Removed

- Remove Testnet balancing `balance_evm_and_nep141` by [@birchmd].

## [1.6.1] - 2021-08-23

### Breaking changes

- Update the `view` call to correctly return the Borsh serialization of
  `TransactionStatus`. Previously, it returned a string with the result of
  the transaction by name.

- Change the `ft_balance_of` result as previously it returned a non-JSON
  string value `0`. This has been fixed to return `"0"`.

## [1.6.0] - 2021-08-13

### Breaking changes

- Change the transaction status of `submit` as running out of gas,
  funds, or being out-of-the-offset are not fatal errors but failed
  executions.

The `submit` call altered the `SubmitResult` object to the following format:

```rust
enum TransactionStatus {
    Succeed(Vec<u8>),
    Revert(Vec<u8>),
    OutOfGas,
    OutOfFund,
    OutOfOffset,
    CallTooDeep,
}

struct ResultLog {
    topics: Vec<[u8; 32]>,
    data: Vec<u8>,
}

struct SubmitResult {
    status: TransactionStatus, // above
    gas_used: u64,
    logs: Vec<ResultLog>,
}
```

## [1.5.0] - 2021-07-30

## [1.4.3] - 2021-07-08

## [1.4.2] - 2021-06-25

## [1.4.1] - 2021-06-23

## [1.4.0] - 2021-06-18

## [1.3.0] - 2021-06-17

## [1.2.0] - 2021-06-05

## [1.1.0] - 2021-05-28

## [1.0.0] - 2021-05-12

[Unreleased]: https://github.com/aurora-is-near/aurora-engine/compare/2.8.1...develop
[2.8.1]: https://github.com/aurora-is-near/aurora-engine/compare/2.8.0...2.8.1
[2.8.0]: https://github.com/aurora-is-near/aurora-engine/compare/2.7.0...2.8.0
[2.7.0]: https://github.com/aurora-is-near/aurora-engine/compare/2.6.1...2.7.0
[2.6.1]: https://github.com/aurora-is-near/aurora-engine/compare/2.6.0...2.6.1 
[2.6.0]: https://github.com/aurora-is-near/aurora-engine/compare/2.5.3...2.6.0
[2.5.3]: https://github.com/aurora-is-near/aurora-engine/compare/2.5.2...2.5.3
[2.5.2]: https://github.com/aurora-is-near/aurora-engine/compare/2.5.1...2.5.2
[2.5.1]: https://github.com/aurora-is-near/aurora-engine/compare/2.5.0...2.5.1
[2.5.0]: https://github.com/aurora-is-near/aurora-engine/compare/2.4.0...2.5.0
[2.4.0]: https://github.com/aurora-is-near/aurora-engine/compare/2.3.0...2.4.0
[2.3.0]: https://github.com/aurora-is-near/aurora-engine/compare/2.2.0...2.3.0 
[2.2.0]: https://github.com/aurora-is-near/aurora-engine/compare/2.1.0...2.2.0
[2.1.0]: https://github.com/aurora-is-near/aurora-engine/compare/2.0.2...2.1.0
[2.0.2]: https://github.com/aurora-is-near/aurora-engine/compare/2.0.1...2.0.2
[2.0.1]: https://github.com/aurora-is-near/aurora-engine/compare/2.0.0...2.0.1
[2.0.0]: https://github.com/aurora-is-near/aurora-engine/compare/1.7.0...2.0.0
[1.7.0]: https://github.com/aurora-is-near/aurora-engine/compare/1.6.4...1.7.0
[1.6.4]: https://github.com/aurora-is-near/aurora-engine/compare/1.6.3...1.6.4
[1.6.3]: https://github.com/aurora-is-near/aurora-engine/compare/1.6.2...1.6.3
[1.6.2]: https://github.com/aurora-is-near/aurora-engine/compare/1.6.1...1.6.2
[1.6.1]: https://github.com/aurora-is-near/aurora-engine/compare/1.6.0...1.6.1
[1.6.0]: https://github.com/aurora-is-near/aurora-engine/compare/1.5.0...1.6.0
[1.5.0]: https://github.com/aurora-is-near/aurora-engine/compare/1.4.3...1.5.0
[1.4.3]: https://github.com/aurora-is-near/aurora-engine/compare/1.4.2...1.4.3
[1.4.2]: https://github.com/aurora-is-near/aurora-engine/compare/1.4.1...1.4.2
[1.4.1]: https://github.com/aurora-is-near/aurora-engine/compare/1.4.0...1.4.1
[1.4.0]: https://github.com/aurora-is-near/aurora-engine/compare/1.3.0...1.4.0
[1.3.0]: https://github.com/aurora-is-near/aurora-engine/compare/1.2.0...1.3.0
[1.2.0]: https://github.com/aurora-is-near/aurora-engine/compare/1.1.0...1.2.0
[1.1.0]: https://github.com/aurora-is-near/aurora-engine/compare/1.0.0...1.1.0
[1.0.0]: https://github.com/aurora-is-near/aurora-engine/tree/1.0.0

[@andrcmdr]: https://github.com/andrcmdr
[@birchmd]: https://github.com/birchmd
[@joshuajbouw]: https://github.com/joshuajbouw
[@mfornet]: https://github.com/mfornet
[@mrLSD]: https://github.com/mrLSD
[@RomanHodulak]: https://github.com/RomanHodulak
[@sept-en]: https://github.com/sept-en
[@matklad]: https://github.com/matklad
[@olonho]: https://github.com/olonho

'''
'''--- aurora-engine-2.8.1/CREDITS.md ---
# Credits

'''
'''--- aurora-engine-2.8.1/Cargo.toml ---
[profile.release]
opt-level = 3
debug = false
debug-assertions = false
overflow-checks = true
lto = true
panic = "abort"
incremental = false
codegen-units = 1
rpath = false

[profile.dev]
# Due to a strange bug, setting this to 3 will cause test failures
opt-level = "z"
debug = false
debug-assertions = true
overflow-checks = true
lto = true
panic = "abort"
incremental = false
codegen-units = 1
rpath = false

[profile.bench]
# lto must be enabled in the bench profile as well for
# it to actually happen when running tests with --release
lto = true
opt-level = 3

[workspace]
resolver = "2"
members = [
    "engine",
    "engine-test-doubles",
    "engine-precompiles",
    "engine-sdk",
    "engine-standalone-storage",
    "engine-standalone-tracing",
    "engine-tests",
    "engine-transactions",
    "engine-types",
]
exclude = [
    "etc/tests/state-migration-test",
    "etc/tests/ft-receiver",
    "etc/tests/benchmark-contract",
    "etc/tests/self-contained-5bEgfRQ",
    "etc/tests/fibonacci",
    "etc/xcc-router",
]

'''
'''--- aurora-engine-2.8.1/Makefile.toml ---
env_files = [
    { path = ".env/mainnet.env", profile = "mainnet" },
    { path = ".env/testnet.env", profile = "testnet" },
    { path = ".env/local.env", profile = "local" },
    { path = ".env/custom.env", profile = "custom" },
    { path = ".env/local.env", profile = "development" },
]

[config]
default_to_workspace = false
skip_core_tasks = true

[env]
CARGO = "cargo"
ENGINE_CARGO_TARGET = "wasm32-unknown-unknown"
SWEEP_DAYS = 30

[tasks.sweep]
category = "Cleanup"
install_crate = "cargo-sweep"
command = "${CARGO}"
args = [
    "sweep",
    "--time",
    "${SWEEP_DAYS}",
]

[tasks.clean-cargo]
category = "Cleanup"
command = "${CARGO}"
args = ["clean"]

[tasks.clean-contracts]
category = "Cleanup"
script = '''
rm -Rf etc/eth-contracts/.pnp
rm -Rf etc/eth-contracts/artifacts
rm -Rf etc/eth-contracts/cache
rm -Rf etc/tests/benchmark-contract/target
rm -Rf etc/tests/ft-receiver/target
rm -Rf etc/tests/self-contained-5bEgfRQ/target
'''

[tasks.clean-bin]
category = "Cleanup"
script = '''
rm -Rf bin
'''

[tasks.clean-flow]
category = "Cleanup"
dependencies = [
    "clean-cargo",
    "clean-contracts",
    "clean-bin",
]

[tasks.clean]
run_task = "clean-flow"

[tasks.fmt]
category = "Formatting"
command = "${CARGO}"
args = [
    "fmt",
    "--all",
]

[tasks.udeps]
category = "Check"
env = { "CARGO_MAKE_RUST_CHANNEL" = "nightly", "CARGO_MAKE_CRATE_INSTALLATION_LOCKED" = "true" }
install_crate = { crate_name = "cargo-udeps", binary = "cargo", min_version = "0.1.34", test_arg = ["udeps", "-h"], force = true }
command = "${CARGO}"
args = [
    "udeps",
    "--all-targets",
]

[tasks.clippy]
category = "Check"
command = "${CARGO}"
args = [
    "clippy",
    "--all-targets",
    "--",
    "-D",
    "warnings",
]

[tasks.check-fmt]
category = "Check"
command = "${CARGO}"
args = [
    "fmt",
    "--",
    "--check",
]

[tasks.check-contracts]
category = "Check"
script = '''
cd etc/eth-contracts
yarn
yarn lint
'''

[tasks.check]
category = "Check"
dependencies = [
    "check-contracts",
    "check-fmt",
    "clippy",
    "udeps",
]

[tasks.post-engine-build-env]
category = "Tools"
script = '''
echo "Environment:"
echo "    CARGO_MAKE_PROFILE:   ${CARGO_MAKE_PROFILE}"
echo "    IS_PROD:              ${IS_PROD}"
echo "    CARGO_FEATURES:       ${CARGO_FEATURES}"
echo "    WASM_FILE:            ${WASM_FILE}"
echo "    TARGET_DIR:           ${TARGET_DIR}"
echo "    RUSTFLAGS:            ${RUSTFLAGS}"
echo "    Extra build args:     ${RELEASE} ${@}"
'''

[tasks.copy-engine-build]
category = "Post"
command = "cp"
args = [
    "target/wasm32-unknown-unknown/${TARGET_DIR}/aurora_engine.wasm",
    "bin/${WASM_FILE}",
]

[tasks.make-bin-directory]
category = "Post"
command = "mkdir"
args = [
    "-p",
    "bin",
]

[tasks.build-contracts]
category = "Build"
script = '''
cd etc/eth-contracts
yarn
yarn build
'''

[tasks.build-engine]
category = "Build"
command = "${CARGO}"
args = [
    "build",
    "--target",
    "${ENGINE_CARGO_TARGET}",
    "@@remove-empty(RELEASE)",
    "--no-default-features",
    "--features=${CARGO_FEATURES}",
    "-p",
    "aurora-engine",
    "-Z",
    "avoid-dev-deps",
    "${@}",
]

[tasks.build-engine-flow]
category = "Build"
dependencies = [
    "build-contracts",
    "build-engine",
    "make-bin-directory",
    "copy-engine-build",
    "post-engine-build-env",
]

[tasks.build-engine-flow-docker]
category = "Build"
dependencies = [
    "build-engine",
    "make-bin-directory",
    "copy-engine-build",
    "post-engine-build-env",
]

[tasks.build-test]
condition = { profiles = ["mainnet", "testnet", "custom"] }
env = { "RUSTFLAGS" = "${RUSTC_FLAGS_BUILD}", "CARGO_FEATURES" = "${CARGO_FEATURES_BUILD_TEST}", "WASM_FILE" = "${WASM_FILE_TEST}", "RELEASE" = "--release", "TARGET_DIR" = "release" }
category = "Build"
run_task = "build-engine-flow"

[tasks.build]
condition = { profiles = ["mainnet", "testnet", "localnet", "development", "custom"] }
env = { "RUSTFLAGS" = "-C strip=symbols --remap-path-prefix ${HOME}=/path/to/home/ --remap-path-prefix ${PWD}=/path/to/source/", "CARGO_FEATURES" = "${CARGO_FEATURES_BUILD}", "RELEASE" = "--release", "TARGET_DIR" = "release" }
category = "Build"
run_task = "build-engine-flow"

[tasks.build-docker-inner]
condition = { profiles = ["mainnet", "testnet", "localnet", "development", "custom"] }
env = { "RUSTFLAGS" = "-C strip=symbols --remap-path-prefix ${HOME}=/path/to/home/ --remap-path-prefix ${PWD}=/path/to/source/", "CARGO_FEATURES" = "${CARGO_FEATURES_BUILD}", "RELEASE" = "--release", "TARGET_DIR" = "release" }
category = "Build"
run_task = "build-engine-flow-docker"

[tasks.build-docker]
category = "Build"
script = '''
docker run --volume $PWD:/host -w /host -i --rm nearprotocol/contract-builder:master-b8fc60809b907543d909ee75fcc1bd7b68cbe2fd-amd64 ./scripts/docker-entrypoint.sh ${PROFILE}
'''

[tasks.test-contracts]
category = "Test"
script = '''
cd etc/eth-contracts
yarn
yarn test
'''

[tasks.test-workspace]
condition = { profiles = ["mainnet", "testnet", "custom"] }
category = "Test"
command = "${CARGO}"
args = [
    "test",
    "--features",
    "${CARGO_FEATURES_TEST}",
]

[tasks.test-flow]
category = "Test"
dependencies = [
    "build-test",
    "test-contracts",
    "test-workspace",
]

[tasks.test]
category = "Test"
run_task = "test-flow"

[tasks.default]
condition = { profiles = ["mainnet", "testnet", "localnet", "development", "custom"] }
run_task = "build"

[tasks.deploy]
condition = { profiles = ["mainnet", "testnet", "localnet", "development", "custom"] }
category = "Deploy"
script = "${NEAR_CLI} deploy --acount-id${NEAR_EVM_ACCOUNT} --wasm-file=bin/${WASM_FILE}"

'''
'''--- aurora-engine-2.8.1/README.md ---
# Aurora Engine

[![Project license](https://img.shields.io/badge/License-Public%20Domain-blue.svg)](https://creativecommons.org/publicdomain/zero/1.0/)
[![Discord](https://img.shields.io/discord/490367152054992913?label=Discord)](https://discord.gg/jNjHYUF8vw)
[![Lints](https://github.com/aurora-is-near/aurora-engine/actions/workflows/lints.yml/badge.svg)](https://github.com/aurora-is-near/aurora-engine/actions/workflows/lints.yml)
[![Tests](https://github.com/aurora-is-near/aurora-engine/actions/workflows/tests.yml/badge.svg)](https://github.com/aurora-is-near/aurora-engine/actions/workflows/tests.yml)
[![Builds](https://github.com/aurora-is-near/aurora-engine/actions/workflows/builds.yml/badge.svg)](https://github.com/aurora-is-near/aurora-engine/actions/workflows/builds.yml)

Aurora Engine implements an Ethereum Virtual Machine (EVM) on the NEAR Protocol.
See [doc.aurora.dev](https://doc.aurora.dev/develop/compat/evm) for additional
documentation.

## Deployments

| Network | Contract ID         | Chain ID   |
|---------|---------------------|------------|
| Mainnet | [`aurora`][Mainnet] | 1313161554 |
| Testnet | [`aurora`][Testnet] | 1313161555 |
| Local   | `aurora.test.near`  | 1313161556 |

[Mainnet]: https://explorer.near.org/accounts/aurora
[Testnet]: https://explorer.testnet.near.org/accounts/aurora

## Development

### Prerequisites

- Node.js (v14+)
- cargo-make

```sh
cargo install --force cargo-make
```

### Prerequisites for Development

- Node.js (v14+)
- Docker
- cargo-make

## Development

### Branches

- [`master`] is the current stable branch.
  It must be ready, anytime, to deployed on chain at a moment's notice.

- [`develop`] is our bleeding-edge development branch.
  In general, kindly target all pull requests to this branch.

### Building & Make Commands

Every task with `cargo make` must have a `--profile` argument.

The current available `profile`s are:
- `mainnet`, suitable for mainnet.
- `testnet`, suitable for testnet.
- `local`, suitable for local development.
- `custom`, suitable for custom environments, see note below.

A custom environment may be required depending on the circumstances. This can
be created in the `.env` folder as `custom.env` following the structure of the
other `.env` files. See `bin/local-custom.env` for more details.

Every make most follow the following pattern, though `--profile` is not required
for all such as cleanup:
```sh
cargo make [--profile <profile>] <task>
```

#### Building the engine and contracts

To build the binaries there are a few commands to do such following the format.

The current available build `task`s are:
- `default`, does not need to be specified, runs `build`. Requires a `--profile`
  argument.
- `build`, builds all engine smart contract and produces the
  `aurora-<profile>-test.wasm` in the `bin` folder. Requires `build-contracts`. 
  Requires a `--profile` argument.
- `build-test`, builds all the below using test features. Requires a `--profile`
  argument.
- `build-contracts`, builds all the ETH contracts.
- `build-docker`, builds the `aurora-<profile>-test.wasm` in the `bin` folder using docker build environment. The purpose of this task is to produce reproducible binaries.

For example, the following will build the mainnet debug binary:
```sh
cargo make --profile mainnet build
```

#### Verifying binary hash

To verify that a deployed binary matches the source code, you may want build it reproducibly and then check that their hashes match. The motivation behind that is to prevent malicious code from being deployed.

Run these commands to produce the binary hash:
```sh
cargo make --profile <profile> build-docker
shasum -a 256 bin/aurora-<profile>.wasm
```

#### Running unit & integration tests

To run tests, there are a few cargo make tasks we can run:
- `test`, tests the whole cargo workspace and ETH contracts. Requires a 
  `--profile` argument.
- `test-workspace`, tests only the cargo workspace.
- `test-contracts`, tests only the contracts.

For example, the following will test the whole workspace and ETH contracts:
```sh
cargo make --profile mainnet test 
```

#### Running checks & lints

To run lints and checks, the following tasks are available:
- `check`, checks the format, clippy and ETH contracts.
- `check-contracts`, runs yarn lints on the ETH contracts.
- `check-fmt`, checks the workspace Rust format only.
- `check-clippy`, checks the Rust workspace with clippy only.

For example the following command will run the checks. `profile` is not required
here:
```
cargo make check
```

#### Cleanup

To clean up the workspace, the following tasks are available:
- `clean`, cleans all built binaries and ETH contracts.
- `clean-cargo`, cleans with cargo.
- `clean-contracts`, cleans the ETH contracts.
- `clean-bin`, cleans the binaries.

Additionally, there is also but not included in the `clean` task:
- `sweep`, sweeps the set amount of days in the ENV, default at 30 days.

For example, the following command will clean everything. `profile` is not 
required:
```
cargo make clean
```

## Deployment

### Downloading the latest EVM release

```sh
wget https://github.com/aurora-is-near/aurora-engine/releases/download/latest/mainnet-release.wasm
```

### Installing the Aurora CLI tool

```sh
npm install -g aurora-is-near/aurora-cli
```

### Deploying the EVM with the CLI

```sh
export NEAR_ENV=local
near delete aurora.test.near test.near  # if needed
near create-account aurora.test.near --master-account=test.near --initial-balance 1000000
aurora install --chain 1313161556 --owner test.near bin/mainnet-release.wasm
```

### Deploying the EVM without the CLI

```sh
export NEAR_ENV=local
near delete aurora.test.near test.near  # if needed
near create-account aurora.test.near --master-account=test.near --initial-balance 1000000
near deploy --account-id=aurora.test.near --wasm-file=bin/mainnet-release.wasm
aurora initialize --chain 1313161556 --owner test.near
```

## Usage

### Examining deployed EVM metadata

```sh
aurora get-version
aurora get-owner
aurora get-bridge-prover
aurora get-chain-id
```

### Deploying EVM contract bytecode

```sh
aurora deploy-code @contract.bytecode
```

```sh
aurora deploy-code 0x600060005560648060106000396000f360e060020a6000350480638ada066e146028578063d09de08a1460365780632baeceb714604d57005b5060005460005260206000f3005b5060016000540160005560005460005260206000f3005b5060016000540360005560005460005260206000f300
```

### Examining EVM contract state

```console
$ aurora encode-address test.near
0xCBdA96B3F2B8eb962f97AE50C3852CA976740e2B
```

```sh
aurora get-nonce 0xCBdA96B3F2B8eb962f97AE50C3852CA976740e2B
aurora get-balance 0xCBdA96B3F2B8eb962f97AE50C3852CA976740e2B
aurora get-code 0xFc481F4037887e10708552c0D7563Ec6858640d6
aurora get-storage-at 0xFc481F4037887e10708552c0D7563Ec6858640d6 0
```

### Calling an EVM contract read-only

```console
$ aurora encode-address test.near
0xCBdA96B3F2B8eb962f97AE50C3852CA976740e2B
```

```sh
aurora view --sender 0xCBdA96B3F2B8eb962f97AE50C3852CA976740e2B 0xFc481F4037887e10708552c0D7563Ec6858640d6 0x8ada066e  # getCounter()
aurora view --sender 0xCBdA96B3F2B8eb962f97AE50C3852CA976740e2B 0xFc481F4037887e10708552c0D7563Ec6858640d6 0xd09de08a  # increment()
aurora view --sender 0xCBdA96B3F2B8eb962f97AE50C3852CA976740e2B 0xFc481F4037887e10708552c0D7563Ec6858640d6 0x2baeceb7  # decrement()
```

### Calling an EVM contract mutatively

```sh
aurora call 0xFc481F4037887e10708552c0D7563Ec6858640d6 0xd09de08a  # increment()
aurora call 0xFc481F4037887e10708552c0D7563Ec6858640d6 0x2baeceb7  # decrement()
```

## Debugging

### Inspecting EVM storage state

```sh
near state aurora.test.near
aurora dump-storage
```

[`master`]:  https://github.com/aurora-is-near/aurora-engine/commits/master
[`develop`]: https://github.com/aurora-is-near/aurora-engine/commits/develop

## License
**aurora-engine** has multiple licenses:
* all crates except `engine-test` has **CCO-1.0** license
* `engine-test` has **GPL-v3** license

'''
'''--- aurora-engine-2.8.1/doc/benchmarks.md ---
# Benchmarks in the Aurora Engine

## What is being measured?

The primary quantity we are interested in measuring is the NEAR gas cost.
This limits how large of transactions we are able to process due to the [200 Tgas transaction limit](https://github.com/near/nearcore/blob/9a41274ddef3616ab195b24a207389c5ad5c7f5a/nearcore/res/genesis_config.json#L192) on NEAR.

As a secondary matter, we are interested in measuring the EVM gas used during a transaction since this is the way we expect many developers on our platform to think about the size of their transactions (since they come from the Ethereum ecosystem).
These measurements together can inform any correlation that exists between NEAR gas spent on Aurora and EVM gas spent on Ethereum.
So far we have seen that this correlation is not very strong, indicating that operations are costed very differently between our platform and Ethereum.

A final quantity of interest is the wall-clock time to execute a transaction.
This is less important for us as a smart contract on NEAR, but is reasonably important for the NEAR runtime itself.
At a high level, the NEAR runtime attempts to maintain the invariant that 1000 Tgas worth of computation can be completed in 1 second (regardless of which operations happen within this 1000 Tgas).
This arises from the [1000 Tgas gas limit](https://github.com/near/nearcore/blob/9a41274ddef3616ab195b24a207389c5ad5c7f5a/nearcore/res/genesis_config.json#L20) per block and the [1 second block time](https://github.com/near/nearcore/blob/9a41274ddef3616ab195b24a207389c5ad5c7f5a/nearcore/res/genesis_config.json#L238).
Moreover, the runtime wants the there to be a linear relationship between gas usage and time taken to complete the computation.
Obviously wall-clock time is not a stable metric as it varies according to the hardware and other details of the system running the test.
This means in reality the NEAR runtime measures gas costs by counting CPU instructions, with the assumption this has a rough correlation with wall-clock time.
For us, we measure wall-clock time because it is simpler and we do not need extreme precision the same way the runtime itself does.
The primary goal of these wall-clock measurements is simply to check the runtime's assumptions about the linear relationship between gas used and wall-clock time, and how much gas can be consumed in 1 second.

## How to do we measure these things?

NEAR gas is measured by [importing the NEAR runtime as a library](https://github.com/aurora-is-near/aurora-engine/blob/0fe4f0506866bd8813b270760864d22723925962/engine-tests/Cargo.toml#L34-L35), and executing our engine contract inside it.
There a [simple profiling structure](https://github.com/near/nearcore/blob/9a41274ddef3616ab195b24a207389c5ad5c7f5a/core/primitives-core/src/profile.rs#L49) that is returned by the runtime which breaks down how much NEAR gas was used by each host function which we also use.
We are working on a [more detailed profiling utility](https://github.com/birchmd/aurora-engine/blob/scoped-profiling/doc/profiling.md) that will allow breaking down costs spent on wasm computation within our contract since the majority of the gas is spent on wasm, not on host functions.

EVM gas is measured automatically as part of SputnikVM, so we get this for free.

Wall-clock time is measured using the [`criterion` rust benchmarking library](https://crates.io/crates/criterion).

## How are these tests/benchmarks run?

There are two types of benchmarks.

The first type are regression tests and simply running `make check` will execute them all (along with all the other tests we have).
Note: these use solidity contracts, so Docker, `yarn`, and `npm` are required dependencies in addition to the usual Rust tooling.
The regression tests check that no more than a given amount of NEAR gas is spent on a transaction.
This prevents us from introducing performance regressions as we continue to develop the engine.
If we suspect performance has actually improved we can print out the amount of gas used and change the bounds accordingly.
Some of these regression tests are discussed below.

The other type of benchmark is marked as `ignored` because they take too long to run to include in our usual CI.
These include the wall-clock time measurements discussed above.
They can be run by using the `--ignored` flag in `cargo test`.
They will print out amounts of gas used and time taken.
These values can be compared with previous runs to look for performance improvements / regressions.
Some of these benchmarks will also be included in the list below.

## Details of 5 specific benchmarks

Each benchmark below includes a description of contract what is being measured, how to run the benchmark
and some rationalization for how much better we would like to see that benchmark perform in the future.

### 1. Uniswap V3

This is a performance regression test.
It confirms it is possible to execute simple transactions involving the [Uniswap V3 protocol](https://docs.uniswap.org/protocol/reference/smart-contracts).
In particular the test creates a liquidity pool for a pair of tokens, adds liquidity and performs a swap.
[The test](https://github.com/aurora-is-near/aurora-engine/blob/a4c3cebbc5da0b14331601f2bff8047d276d2da0/engine-tests/src/tests/uniswap.rs#L24) can be run using the following command

```
make mainnet-test-build && cargo test --features mainnet-test uniswap
```

The adding liquidity operation consumes around 500k EVM gas, and around 165 NEAR Tgas.
With an EVM gas limit of 15 million on Ethereum. this means around 30 such operations could fit in one block.
30 such operations on Aurora would cost nearly 5000 Tgas, the equivalent of 5 blocks.
Therefore, for this benchmark we aim to have it cost 1/5th the amount of NEAR gas it does presently.

A wall-clock measurement using the uniswap contract also exists.
[That benchmark](https://github.com/aurora-is-near/aurora-engine/blob/a4c3cebbc5da0b14331601f2bff8047d276d2da0/engine-tests/src/benches/mod.rs#L42) can be run using the following command

```
make mainnet-test-build && cargo test --features mainnet-test uniswap -- --ignored --nocapture
```

### 2. 1inch liquidity protocol

This is a performance regression test.
It confirms it is possible to execute simple transactions involving the [1inch liquidity protocol](https://github.com/1inch/liquidity-protocol).
[The test](https://github.com/aurora-is-near/aurora-engine/blob/0fe4f0506866bd8813b270760864d22723925962/engine-tests/src/tests/one_inch.rs#L17) can be run using the following command

```
make mainnet-test-build && cargo test --features mainnet-test 1inch
```

The operation depositing funds into the 1inch liquidity pool consumes around 300k EVM gas, and around 120 NEAR Tgas.
With an EVM gas limit of 15 million on Ethereum. this means around 50 such operations could fit in one block.
50 such operations on Aurora would cost 6000 Tgas, the equivalent of 6 blocks.
Therefore, for this benchmark we aim to have it cost 1/6th the amount of NEAR gas it does presently.

### 3. NFT paginated view call

This is an `ignored` benchmark test.
It takes a very long time to run, so we do not include it in CI.
This test was inspired by a partner who was hitting the gas limit in view calls.
The purpose of the test was to see how high we would need to set the gas limit to enable their use case.
[The test](https://github.com/aurora-is-near/aurora-engine/blob/0fe4f0506866bd8813b270760864d22723925962/engine-tests/src/benches/mod.rs#L25) measures how much gas is needed to display [different numbers of NFTs](https://github.com/aurora-is-near/aurora-engine/blob/0fe4f0506866bd8813b270760864d22723925962/engine-tests/src/benches/mod.rs#L28) (per page) of [different sizes](https://github.com/aurora-is-near/aurora-engine/blob/0fe4f0506866bd8813b270760864d22723925962/engine-tests/src/benches/mod.rs#L27) (that is the size of the metadata in bytes).
Results from the last run of this test can be seen [here](https://github.com/aurora-is-near/aurora-engine/issues/199#issuecomment-906747906).
The benchmark can be run using the following command

```
make mainnet-test-build && cargo test --features mainnet-test nft_pagination -- --ignored --nocapture
```

Based on this measurement, we estimate it would take 2000 Tgas to complete this operation with reasonable values of NFT size and number of NFTs per page.
Since this operation is meant to complete in a single transaction, it must fit in 200 Tgas.
Therefore, for this benchmark we aim to have it cost 1/10th the amount of NEAR gas it does presently.

### 4. Deploying the largest possible contract

This is a performance regression test.
It checks we are able to deploy all possible EVM smart contracts (without any initialization logic) by showing the largest allowed (in terms of number of bytes) is able to be deployed within the gas limit.
[The test](https://github.com/aurora-is-near/aurora-engine/blob/a4c3cebbc5da0b14331601f2bff8047d276d2da0/engine-tests/src/tests/sanity.rs#L45) can be run using the following command

```
make mainnet-test-build && cargo test --features mainnet-test deploy_largest_contract
```

This operation costs around 5 million EVM gas, meaning 3 such operations could happen in one block.
At just 43 Tgas, we can already fit many more than 3 such operation into a single block on Aurora.
Therefore, we do not need improvement on this benchmark.
It is included here in case NEAR ever decided to raise the gas price on storage operations.

### 5. `ecpair` precompile

This single operation consumes [almost 2000 Tgas by itself](https://github.com/near/nearcore/issues/4787#issuecomment-920031553)!
In order to be fully Ethereum compatible we must be able to execute the [`ecpair` precompile](https://eips.ethereum.org/EIPS/eip-197).
It may be the case that this cannot be done efficiently enough in wasm and it will need to become a host function in the NEAR runtime instead (this was done for [`ecrecover` for example](https://github.com/near/nearcore/pull/4380)).
[The test](https://github.com/aurora-is-near/aurora-engine/blob/a4c3cebbc5da0b14331601f2bff8047d276d2da0/engine-tests/src/tests/standard_precompiles.rs#L24) is listed as `ignored` currently because the amount of gas it uses is too large.
It can be run using the following command

```
make mainnet-test-build && cargo test --features mainnet-test ecpair -- --ignored --nocapture
```

On Ethereum this operation would cost around 135k EVM gas, and thus could be repeated over 100 times in a single Ethereum block.
On aurora, repeating this operation 100 times would cost 200_000 Tgas, the equivalent of 200 blocks.
Therefore, for this benchmark we aim to have it cost 1/200th the amount of NEAR gas it does presently.

'''
'''--- aurora-engine-2.8.1/doc/eth-connector.md ---
# ETH connector

Aurora ETH connector is implementation for [NEP-141](https://nomicon.io/Standards/Tokens/FungibleToken/Core).

It has two basic accounts entities:
* Aurora on NEAR (`balance_of`)
* Aurora on ETH (`balance_of_eth`)

This means that there are two types of `total supply`:
* `total_eth_supply_on_near`
* `total_eth_supply_on_aurora`

Eth-Connector logic can be divided into three large groups:
1. NEP-141 specific logic
2. Eth-Connector specific logic
3. Admin Controlled specific logic

## ETH connector methods

* new_eth_connector (call once)
    > Initialize Eth Connector. Called once.

* verify_log_entry (integration-test, view)
   > Used for integrations tests only.

#### NEP-141 specific logic

For more details see: [NEP-141](https://nomicon.io/Standards/Tokens/FungibleToken/Core).

* ft_total_supply (view)
* ft_total_eth_supply_on_near (view)
* ft_total_eth_supply_on_aurora (view)
* ft_balance_of (view)
* ft_balance_of_eth (view)
* ft_transfer (mutable, payable)
* ft_resolve_transfer (private, mutable)
* storage_deposit (mutable)
* storage_withdraw (mutable, payable)
* storage_balance_of (view)
* ft_metadata (view)

* ft_transfer_call (mutable, payable)
   > - Verify message data if `sender_id == receiver_id ` before `ft_on_transfer` call to avoid verification panics
   >   - Fetch transfer message
   >   - Check is transfer amount > fee
   >   - Check overflow for recipient  `balance_of_eth_on_aurora` before process `ft_on_transfer`
   >   - Check overflow for `total_eth_supply_on_aurora` before process `ft_on_transfer`
   > - if sender_id != receiver_id
   >   - `transfer_eth_on_near` from `sender_id` to `receiver_id`
   > - Call `ft_on_transfer`
* ft_on_transfer (mutable)
   > - Fetch transfer message
   > - mint_eth_on_aurora for `recipient`
   > - if `fee` exist mint_eth_on_aurora for `relayer`

#### Eth-Connector specific logic

* deposit (mutable)
   > Deposit logic:
   > - fetch proof
   > - Prepare token message data for Finish Deposit
   > - Invoke promise - Verify proof log entry data by Custodian
   > - Invoke promise Finish Deposit with Token message data
   > 
   > Arguments: (proof: Proof)

* withdraw (mutable, payable)
   > Withdraw from NEAR accounts.
   > 
   > Arguments: (recipient_address: Address, amount: NEP141Wei) 

* finish_deposit (private, mutable)
   > Finish deposit logic 
   > - Check is Verify proof log entry data success
   > - If msg is set
   >   - Mint amount for Owner
   >   - Record Proof
   >   - Call ft_transfer_call for receiver_id
   > - else
   >   - Mint amount for Owner
   >   - Mint fee for relayer
   >   - Record Proof
   > 
   > Arguments: (deposit_call: FinishDepositCallArgs, [callback] verify_log_result: bool)

#### Admin Controlled specific logic

* get_accounts_counter (view)
* get_paused_flags (view)
* set_paused_flags (mutable, private)

## ETH connector specific source files

* `fungible_token.rs`
* `connector.rs`
* `admin_controlled.rs`
* `deposit_event.rs`
* `log_entry.rs`
* `proof.rs`

## Build
1. For production set in the Makefile
    ```   
       FEATURES = contract
    ```
   1.1. For **development and testing** set in the Makefile
    ```
       FEATURES = contract,integration-test
    ```
2. Build release: `$ make release`
3. Run tests: `$ cargo test`
4. Deploying process is common for Aurora itself. Please reference [README.md](../README.md)

## Initialize eth-connector
With `near-cli` run:
```
$ near call <NEAR_ACC> new_eth_connector '{"prover_account": "<PROVER_NEAR_ACCOUNT>", "eth_custodian_address": "<ETH_ADDRESS>"}' --account-id <NEAR_ACC>

```

## Ethereum specific flow
Follow by [this instruction](https://github.com/aurora-is-near/eth-connector/blob/master/README.md).

'''
'''--- aurora-engine-2.8.1/engine-precompiles/Cargo.toml ---
[package]
name = "aurora-engine-precompiles"
version = "1.0.0"
authors = ["Aurora Labs <hello@aurora.dev>"]
edition = "2021"
description = ""
documentation = ""
readme = true
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "CC0-1.0"
publish = false
autobenches = false

[dependencies]
aurora-engine-types = { path = "../engine-types", default-features = false }
aurora-engine-sdk = { path = "../engine-sdk", default-features = false }
borsh = { version = "0.9.3", default-features = false }
bn = { version = "0.5.11", package = "zeropool-bn", default-features = false }
evm = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false }
libsecp256k1 = { version = "0.7.0", default-features = false, features = ["static-context", "hmac"] }
num = { version = "0.4.0", default-features = false, features = ["alloc"] }
ripemd = { version = "0.1.1", default-features = false }
sha2 = { version = "0.10.2", default-features = false }
sha3 = { version = "0.10.2", default-features = false }
ethabi = { version = "18.0", default-features = false }
hex = { version = "0.4", default-features = false, features = ["alloc"] }

[dev-dependencies]
aurora-engine-test-doubles = { path = "../engine-test-doubles" }
serde = { version = "1", features = ["derive"] }
serde_json = "1"
rand = "0.8.5"

[features]
default = ["std"]
std = ["aurora-engine-types/std", "aurora-engine-sdk/std", "borsh/std", "bn/std", "evm/std", "libsecp256k1/std", "ripemd/std", "sha2/std", "sha3/std", "ethabi/std"]
contract = []
log = []
error_refund = []

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/account_ids.rs ---
use super::{EvmPrecompileResult, Precompile};
use crate::prelude::types::{Address, EthGas};
use crate::PrecompileOutput;
use aurora_engine_sdk::env::Env;
use aurora_engine_types::account_id::AccountId;
use evm::{Context, ExitError};

mod costs {
    use crate::prelude::types::EthGas;

    // TODO(#483): Determine the correct amount of gas
    pub(super) const PREDECESSOR_ACCOUNT_GAS: EthGas = EthGas::new(0);
    // TODO(#483): Determine the correct amount of gas
    pub(super) const CURRENT_ACCOUNT_GAS: EthGas = EthGas::new(0);
}

pub struct PredecessorAccount<'a, E> {
    env: &'a E,
}

pub mod predecessor_account {
    use aurora_engine_types::types::Address;

    /// predecessor_account_id precompile address
    ///
    /// Address: `0x723ffbaba940e75e7bf5f6d61dcbf8d9a4de0fd7`
    /// This address is computed as: `&keccak("predecessorAccountId")[12..]`
    pub const ADDRESS: Address =
        crate::make_address(0x723ffbab, 0xa940e75e7bf5f6d61dcbf8d9a4de0fd7);
}

impl<'a, E> PredecessorAccount<'a, E> {
    pub fn new(env: &'a E) -> Self {
        Self { env }
    }
}

impl<'a, E: Env> Precompile for PredecessorAccount<'a, E> {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::PREDECESSOR_ACCOUNT_GAS)
    }

    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let predecessor_account_id = self.env.predecessor_account_id();
        Ok(PrecompileOutput::without_logs(
            cost,
            predecessor_account_id.as_bytes().to_vec(),
        ))
    }
}

pub struct CurrentAccount {
    current_account_id: AccountId,
}

impl CurrentAccount {
    /// current_account_id precompile address
    ///
    /// Address: `0xfefae79e4180eb0284f261205e3f8cea737aff56`
    /// This address is computed as: `&keccak("currentAccountId")[12..]`
    pub const ADDRESS: Address =
        super::make_address(0xfefae79e, 0x4180eb0284f261205e3f8cea737aff56);

    pub fn new(current_account_id: AccountId) -> Self {
        Self { current_account_id }
    }
}

impl Precompile for CurrentAccount {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::PREDECESSOR_ACCOUNT_GAS)
    }

    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        Ok(PrecompileOutput::without_logs(
            cost,
            self.current_account_id.as_bytes().to_vec(),
        ))
    }
}

#[cfg(test)]
mod tests {
    use crate::account_ids::{predecessor_account, CurrentAccount};
    use crate::prelude::sdk::types::near_account_to_evm_address;

    #[test]
    fn test_predecessor_account_precompile_id() {
        assert_eq!(
            predecessor_account::ADDRESS,
            near_account_to_evm_address("predecessorAccountId".as_bytes())
        );
    }

    #[test]
    fn test_curent_account_precompile_id() {
        assert_eq!(
            CurrentAccount::ADDRESS,
            near_account_to_evm_address("currentAccountId".as_bytes())
        );
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/alt_bn256.rs ---
use crate::prelude::types::{Address, EthGas};
use crate::prelude::{Borrowed, PhantomData, Vec};
use crate::utils;
use crate::{Byzantium, EvmPrecompileResult, HardFork, Istanbul, Precompile, PrecompileOutput};
use bn::Group;
use evm::{Context, ExitError};

/// bn128 costs.
mod costs {
    use crate::prelude::types::EthGas;

    /// Cost of the Byzantium alt_bn128_add operation.
    pub(super) const BYZANTIUM_ADD: EthGas = EthGas::new(500);

    /// Cost of the Byzantium alt_bn128_mul operation.
    pub(super) const BYZANTIUM_MUL: EthGas = EthGas::new(40_000);

    /// Cost of the alt_bn128_pair per point.
    pub(super) const BYZANTIUM_PAIR_PER_POINT: EthGas = EthGas::new(80_000);

    /// Cost of the alt_bn128_pair operation.
    pub(super) const BYZANTIUM_PAIR_BASE: EthGas = EthGas::new(100_000);

    /// Cost of the Istanbul alt_bn128_add operation.
    pub(super) const ISTANBUL_ADD: EthGas = EthGas::new(150);

    /// Cost of the Istanbul alt_bn128_mul operation.
    pub(super) const ISTANBUL_MUL: EthGas = EthGas::new(6_000);

    /// Cost of the Istanbul alt_bn128_pair per point.
    pub(super) const ISTANBUL_PAIR_PER_POINT: EthGas = EthGas::new(34_000);

    /// Cost of the Istanbul alt_bn128_pair operation.
    pub(super) const ISTANBUL_PAIR_BASE: EthGas = EthGas::new(45_000);
}

/// bn128 constants.
mod consts {
    use crate::prelude::Borrowed;
    use evm::ExitError;

    /// Input length for the add operation.
    pub(super) const ADD_INPUT_LEN: usize = 128;

    /// Input length for the multiplication operation.
    pub(super) const MUL_INPUT_LEN: usize = 128;

    /// Pair element length.
    pub(super) const PAIR_ELEMENT_LEN: usize = 192;

    pub(super) const SCALAR_PART_LEN: usize = SCALAR_LEN / 2;

    /// Size of BN scalars.
    pub(super) const SCALAR_LEN: usize = 32;

    /// Half the size of a point size.
    pub(super) const POINT_PART_LEN: usize = POINT_LEN / 2;

    /// Size of BN points.
    pub(super) const POINT_LEN: usize = 64;

    /// Size of BN pairs.
    pub(super) const POINT_PAIR_LEN: usize = 128;

    /// Output length.
    pub(super) const OUTPUT_LEN: usize = 64;

    // pub(super) const ERR_BIG_ENDIAN: &str = "ERR_BIG_ENDIAN";

    pub(super) const ERR_BIG_ENDIAN: ExitError = ExitError::Other(Borrowed("ERR_BIG_ENDIAN"));
}

#[cfg(feature = "contract")]
trait HostFnEncode {
    type Encoded;

    fn host_fn_encode(self) -> Self::Encoded;
}

#[cfg(feature = "contract")]
fn concat_low_high<const P: usize, const S: usize>(low: [u8; P], high: [u8; P]) -> [u8; S] {
    let mut bytes = [0u8; S];
    bytes[0..P].copy_from_slice(&low);
    bytes[P..P * 2].copy_from_slice(&high);
    bytes
}

#[cfg(feature = "contract")]
impl HostFnEncode for bn::Fr {
    type Encoded = [u8; consts::SCALAR_LEN];

    fn host_fn_encode(self) -> Self::Encoded {
        let [low, high] = self.into_u256().0;
        concat_low_high(low.to_le_bytes(), high.to_le_bytes())
    }
}

#[cfg(feature = "contract")]
impl HostFnEncode for bn::Fq {
    type Encoded = [u8; consts::SCALAR_LEN];

    fn host_fn_encode(self) -> Self::Encoded {
        let [low, high] = self.into_u256().0;
        concat_low_high(low.to_le_bytes(), high.to_le_bytes())
    }
}

#[cfg(feature = "contract")]
impl HostFnEncode for bn::Fq2 {
    type Encoded = [u8; consts::SCALAR_LEN * 2];

    fn host_fn_encode(self) -> Self::Encoded {
        let [real_low, real_high] = self.real().into_u256().0;
        let real: [u8; consts::SCALAR_LEN] =
            concat_low_high(real_low.to_le_bytes(), real_high.to_le_bytes());

        let [imaginary_low, imaginary_high] = self.imaginary().into_u256().0;
        let imaginary: [u8; consts::SCALAR_LEN] =
            concat_low_high(imaginary_low.to_le_bytes(), imaginary_high.to_le_bytes());
        concat_low_high(real, imaginary)
    }
}

#[cfg(feature = "contract")]
impl HostFnEncode for bn::G1 {
    type Encoded = [u8; consts::POINT_LEN];

    fn host_fn_encode(self) -> Self::Encoded {
        bn::AffineG1::from_jacobian(self)
            .map(|p| {
                let (px, py) = (p.x().host_fn_encode(), p.y().host_fn_encode());
                concat_low_high(px, py)
            })
            .unwrap_or_else(|| [0u8; consts::POINT_LEN])
    }
}

#[cfg(feature = "contract")]
impl HostFnEncode for bn::G2 {
    type Encoded = [u8; consts::POINT_PAIR_LEN];

    fn host_fn_encode(self) -> Self::Encoded {
        bn::AffineG2::from_jacobian(self)
            .map(|g2| {
                let x = g2.x().host_fn_encode();
                let y = g2.y().host_fn_encode();
                concat_low_high(x, y)
            })
            .unwrap_or_else(|| [0u8; consts::POINT_PAIR_LEN])
    }
}

/// Reads the `x` and `y` points from an input at a given position.
fn read_point(input: &[u8], pos: usize) -> Result<bn::G1, ExitError> {
    use bn::{AffineG1, Fq, G1};

    let px = Fq::from_slice(&input[pos..(pos + consts::SCALAR_LEN)])
        .map_err(|_e| ExitError::Other(Borrowed("ERR_FQ_INCORRECT")))?;
    let py = Fq::from_slice(&input[(pos + consts::SCALAR_LEN)..(pos + consts::SCALAR_LEN * 2)])
        .map_err(|_e| ExitError::Other(Borrowed("ERR_FQ_INCORRECT")))?;

    Ok(if px == Fq::zero() && py == Fq::zero() {
        G1::zero()
    } else {
        AffineG1::new(px, py)
            .map_err(|_| ExitError::Other(Borrowed("ERR_BN128_INVALID_POINT")))?
            .into()
    })
}

#[derive(Default)]
pub struct Bn256Add<HF: HardFork>(PhantomData<HF>);

impl<HF: HardFork> Bn256Add<HF> {
    pub const ADDRESS: Address = super::make_address(0, 6);

    pub fn new() -> Self {
        Self(Default::default())
    }
}

impl<HF: HardFork> Bn256Add<HF> {
    fn run_inner(input: &[u8], _context: &Context) -> Result<Vec<u8>, ExitError> {
        let mut input = input.to_vec();
        input.resize(consts::ADD_INPUT_LEN, 0);

        let p1 = read_point(&input, 0)?;
        let p2 = read_point(&input, consts::POINT_LEN)?;

        let output = Self::execute(p1, p2)?;
        Ok(output.to_vec())
    }

    #[cfg(not(feature = "contract"))]
    fn execute(p1: bn::G1, p2: bn::G1) -> Result<[u8; consts::OUTPUT_LEN], ExitError> {
        let mut output = [0u8; consts::POINT_LEN];
        if let Some(sum) = bn::AffineG1::from_jacobian(p1 + p2) {
            sum.x()
                .to_big_endian(&mut output[0..consts::SCALAR_LEN])
                .map_err(|_e| consts::ERR_BIG_ENDIAN)?;
            sum.y()
                .to_big_endian(&mut output[consts::SCALAR_LEN..consts::SCALAR_LEN * 2])
                .map_err(|_e| consts::ERR_BIG_ENDIAN)?;
        }
        Ok(output)
    }

    #[cfg(feature = "contract")]
    fn execute(p1: bn::G1, p2: bn::G1) -> Result<[u8; consts::OUTPUT_LEN], ExitError> {
        Ok(aurora_engine_sdk::alt_bn128_g1_sum(
            p1.host_fn_encode(),
            p2.host_fn_encode(),
        ))
    }
}

impl Precompile for Bn256Add<Byzantium> {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::BYZANTIUM_ADD)
    }

    /// Takes in two points on the elliptic curve alt_bn128 and calculates the sum
    /// of them.
    ///
    /// See: https://eips.ethereum.org/EIPS/eip-196
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000006
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let output = Self::run_inner(input, context)?;
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

impl Precompile for Bn256Add<Istanbul> {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::ISTANBUL_ADD)
    }

    /// Takes in two points on the elliptic curve alt_bn128 and calculates the sum
    /// of them.
    ///
    /// See: https://eips.ethereum.org/EIPS/eip-196
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000006
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }
        let output = Self::run_inner(input, context)?;
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

#[derive(Default)]
pub struct Bn256Mul<HF: HardFork>(PhantomData<HF>);

impl<HF: HardFork> Bn256Mul<HF> {
    pub const ADDRESS: Address = super::make_address(0, 7);

    pub fn new() -> Self {
        Self(Default::default())
    }
}

impl<HF: HardFork> Bn256Mul<HF> {
    fn run_inner(input: &[u8], _context: &Context) -> Result<Vec<u8>, ExitError> {
        let mut input = input.to_vec();
        input.resize(consts::MUL_INPUT_LEN, 0);

        let p = read_point(&input, 0)?;
        let fr =
            bn::Fr::from_slice(&input[consts::POINT_LEN..consts::POINT_LEN + consts::SCALAR_LEN])
                .map_err(|_e| ExitError::Other(Borrowed("ERR_BN128_INVALID_FR")))?;

        let output = Self::execute(p, fr)?;
        Ok(output.to_vec())
    }

    #[cfg(not(feature = "contract"))]
    fn execute(p: bn::G1, fr: bn::Fr) -> Result<[u8; consts::OUTPUT_LEN], ExitError> {
        let mut output = [0u8; consts::OUTPUT_LEN];
        if let Some(mul) = bn::AffineG1::from_jacobian(p * fr) {
            mul.x()
                .into_u256()
                .to_big_endian(&mut output[0..consts::SCALAR_LEN])
                .map_err(|_e| consts::ERR_BIG_ENDIAN)?;
            mul.y()
                .into_u256()
                .to_big_endian(&mut output[consts::SCALAR_LEN..consts::SCALAR_LEN * 2])
                .map_err(|_e| consts::ERR_BIG_ENDIAN)?;
        }
        Ok(output)
    }

    #[cfg(feature = "contract")]
    fn execute(g1: bn::G1, fr: bn::Fr) -> Result<[u8; consts::OUTPUT_LEN], ExitError> {
        Ok(aurora_engine_sdk::alt_bn128_g1_scalar_multiple(
            g1.host_fn_encode(),
            fr.host_fn_encode(),
        ))
    }
}

impl Precompile for Bn256Mul<Byzantium> {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::BYZANTIUM_MUL)
    }

    /// Takes in two points on the elliptic curve alt_bn128 and multiples them.
    ///
    /// See: https://eips.ethereum.org/EIPS/eip-196
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000007
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let output = Self::run_inner(input, context)?;
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

impl Precompile for Bn256Mul<Istanbul> {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::ISTANBUL_MUL)
    }

    /// Takes in two points on the elliptic curve alt_bn128 and multiples them.
    ///
    /// See: https://eips.ethereum.org/EIPS/eip-196
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000007
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let output = Self::run_inner(input, context)?;
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

#[derive(Default)]
pub struct Bn256Pair<HF: HardFork>(PhantomData<HF>);

impl<HF: HardFork> Bn256Pair<HF> {
    pub const ADDRESS: Address = super::make_address(0, 8);

    pub fn new() -> Self {
        Self(Default::default())
    }
}

impl<HF: HardFork> Bn256Pair<HF> {
    fn run_inner(input: &[u8], _context: &Context) -> Result<Vec<u8>, ExitError> {
        if input.len() % consts::PAIR_ELEMENT_LEN != 0 {
            return Err(ExitError::Other(Borrowed("ERR_BN128_INVALID_LEN")));
        }

        let output = if input.is_empty() {
            bn::arith::U256::one()
        } else {
            let elements = input.len() / consts::PAIR_ELEMENT_LEN;
            let mut vals = Vec::with_capacity(elements);
            for idx in 0..elements {
                let ax = bn::Fq::from_slice(
                    &input[(idx * consts::PAIR_ELEMENT_LEN)
                        ..(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN)],
                )
                .map_err(|_e| ExitError::Other(Borrowed("ERR_BN128_INVALID_AX")))?;
                let ay = bn::Fq::from_slice(
                    &input[(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN)
                        ..(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN * 2)],
                )
                .map_err(|_e| ExitError::Other(Borrowed("ERR_BN128_INVALID_AY")))?;
                let bay = bn::Fq::from_slice(
                    &input[(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN * 2)
                        ..(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN * 3)],
                )
                .map_err(|_e| ExitError::Other(Borrowed("ERR_BN128_INVALID_BAY")))?;
                let bax = bn::Fq::from_slice(
                    &input[(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN * 3)
                        ..(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN * 4)],
                )
                .map_err(|_e| ExitError::Other(Borrowed("ERR_BN128_INVALID_BAX")))?;
                let bby = bn::Fq::from_slice(
                    &input[(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN * 4)
                        ..(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN * 5)],
                )
                .map_err(|_e| ExitError::Other(Borrowed("ERR_BN128_INVALID_BBY")))?;
                let bbx = bn::Fq::from_slice(
                    &input[(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN * 5)
                        ..(idx * consts::PAIR_ELEMENT_LEN + consts::SCALAR_LEN * 6)],
                )
                .map_err(|_e| ExitError::Other(Borrowed("ERR_BN128_INVALID_BBX")))?;

                let g1_a = {
                    if ax.is_zero() && ay.is_zero() {
                        bn::G1::zero()
                    } else {
                        bn::AffineG1::new(ax, ay)
                            .map_err(|_e| ExitError::Other(Borrowed("ERR_BN128_INVALID_A")))?
                            .into()
                    }
                };
                let g1_b = {
                    let ba = bn::Fq2::new(bax, bay);
                    let bb = bn::Fq2::new(bbx, bby);

                    if ba.is_zero() && bb.is_zero() {
                        bn::G2::zero()
                    } else {
                        bn::AffineG2::new(ba, bb)
                            .map_err(|_e| ExitError::Other(Borrowed("ERR_BN128_INVALID_B")))?
                            .into()
                    }
                };
                vals.push((g1_a, g1_b))
            }

            let result = Self::execute(vals);
            if result {
                bn::arith::U256::one()
            } else {
                bn::arith::U256::zero()
            }
        };

        let mut res = crate::vec![0u8; 32];
        output
            .to_big_endian(&mut res[0..32])
            .map_err(|_e| consts::ERR_BIG_ENDIAN)?;
        Ok(res)
    }

    #[cfg(not(feature = "contract"))]
    fn execute(vals: Vec<(bn::G1, bn::G2)>) -> bool {
        bn::pairing_batch(&vals) == bn::Gt::one()
    }

    #[cfg(feature = "contract")]
    fn execute(vals: Vec<(bn::G1, bn::G2)>) -> bool {
        let points = vals
            .into_iter()
            .map(|(g1, g2)| (g1.host_fn_encode(), g2.host_fn_encode()));
        aurora_engine_sdk::alt_bn128_pairing(points)
    }
}

impl Precompile for Bn256Pair<Byzantium> {
    fn required_gas(input: &[u8]) -> Result<EthGas, ExitError> {
        let input_len = u64::try_from(input.len()).map_err(utils::err_usize_conv)?;
        let pair_element_len =
            u64::try_from(consts::PAIR_ELEMENT_LEN).map_err(utils::err_usize_conv)?;
        Ok(
            costs::BYZANTIUM_PAIR_PER_POINT * input_len / pair_element_len
                + costs::BYZANTIUM_PAIR_BASE,
        )
    }

    /// Takes in elements and calculates the pair.
    ///
    /// See: https://eips.ethereum.org/EIPS/eip-197
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000008
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let output = Self::run_inner(input, context)?;
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

impl Precompile for Bn256Pair<Istanbul> {
    fn required_gas(input: &[u8]) -> Result<EthGas, ExitError> {
        let input_len = u64::try_from(input.len()).map_err(utils::err_usize_conv)?;
        let pair_element_len =
            u64::try_from(consts::PAIR_ELEMENT_LEN).map_err(utils::err_usize_conv)?;
        Ok(
            costs::ISTANBUL_PAIR_PER_POINT * input_len / pair_element_len
                + costs::ISTANBUL_PAIR_BASE,
        )
    }

    /// Takes in elements and calculates the pair.
    ///
    /// See: https://eips.ethereum.org/EIPS/eip-197
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000008
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let output = Self::run_inner(input, context)?;
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

#[cfg(test)]
mod tests {
    use crate::utils::new_context;

    use super::*;

    #[test]
    fn test_alt_bn128_add() {
        let input = hex::decode(
            "\
             18b18acfb4c2c30276db5411368e7185b311dd124691610c5d3b74034e093dc9\
             063c909c4720840cb5134cb9f59fa749755796819658d32efc0d288198f37266\
             07c2b7f58a84bd6145f00c9c2bc0bb1a187f20ff2c92963a88019e7c6a014eed\
             06614e20c147e940f2d70da3f74c9a17df361706a4485c742bd6788478fa17d7",
        )
        .unwrap();
        let expected = hex::decode(
            "\
            2243525c5efd4b9c3d3c45ac0ca3fe4dd85e830a4ce6b65fa1eeaee202839703\
            301d1d33be6da8e509df21cc35964723180eed7532537db9ae5e7d48f195c915",
        )
        .unwrap();

        let res = Bn256Add::<Byzantium>::new()
            .run(&input, Some(EthGas::new(500)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        // zero sum test
        let input = hex::decode(
            "\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();
        let expected = hex::decode(
            "\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();

        let res = Bn256Add::<Byzantium>::new()
            .run(&input, Some(EthGas::new(500)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        // out of gas test
        let input = hex::decode(
            "\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();
        let res =
            Bn256Add::<Byzantium>::new().run(&input, Some(EthGas::new(499)), &new_context(), false);
        assert!(matches!(res, Err(ExitError::OutOfGas)));

        // no input test
        let input = [0u8; 0];
        let expected = hex::decode(
            "\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();

        let res = Bn256Add::<Byzantium>::new()
            .run(&input, Some(EthGas::new(500)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        // point not on curve fail
        let input = hex::decode(
            "\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111",
        )
        .unwrap();

        let res =
            Bn256Add::<Byzantium>::new().run(&input, Some(EthGas::new(500)), &new_context(), false);
        assert!(matches!(
            res,
            Err(ExitError::Other(Borrowed("ERR_BN128_INVALID_POINT")))
        ));
    }

    #[test]
    fn test_alt_bn128_mul() {
        let input = hex::decode(
            "\
            2bd3e6d0f3b142924f5ca7b49ce5b9d54c4703d7ae5648e61d02268b1a0a9fb7\
            21611ce0a6af85915e2f1d70300909ce2e49dfad4a4619c8390cae66cefdb204\
            00000000000000000000000000000000000000000000000011138ce750fa15c2",
        )
        .unwrap();
        let expected = hex::decode(
            "\
            070a8d6a982153cae4be29d434e8faef8a47b274a053f5a4ee2a6c9c13c31e5c\
            031b8ce914eba3a9ffb989f9cdd5b0f01943074bf4f0f315690ec3cec6981afc",
        )
        .unwrap();

        let res = Bn256Mul::<Byzantium>::new()
            .run(&input, Some(EthGas::new(40_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        // out of gas test
        let input = hex::decode(
            "\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0200000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();
        let res = Bn256Mul::<Byzantium>::new().run(
            &input,
            Some(EthGas::new(39_999)),
            &new_context(),
            false,
        );
        assert!(matches!(res, Err(ExitError::OutOfGas)));

        // zero multiplication test
        let input = hex::decode(
            "\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0200000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();
        let expected = hex::decode(
            "\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();

        let res = Bn256Mul::<Byzantium>::new()
            .run(&input, Some(EthGas::new(40_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        // no input test
        let input = [0u8; 0];
        let expected = hex::decode(
            "\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();

        let res = Bn256Mul::<Byzantium>::new()
            .run(&input, Some(EthGas::new(40_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        // point not on curve fail
        let input = hex::decode(
            "\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111\
            0f00000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();

        let res = Bn256Mul::<Byzantium>::new().run(
            &input,
            Some(EthGas::new(40_000)),
            &new_context(),
            false,
        );
        assert!(matches!(
            res,
            Err(ExitError::Other(Borrowed("ERR_BN128_INVALID_POINT")))
        ));
    }

    #[test]
    fn test_alt_bn128_pair() {
        let input = hex::decode(
            "\
            1c76476f4def4bb94541d57ebba1193381ffa7aa76ada664dd31c16024c43f59\
            3034dd2920f673e204fee2811c678745fc819b55d3e9d294e45c9b03a76aef41\
            209dd15ebff5d46c4bd888e51a93cf99a7329636c63514396b4a452003a35bf7\
            04bf11ca01483bfa8b34b43561848d28905960114c8ac04049af4b6315a41678\
            2bb8324af6cfc93537a2ad1a445cfd0ca2a71acd7ac41fadbf933c2a51be344d\
            120a2a4cf30c1bf9845f20c6fe39e07ea2cce61f0c9bb048165fe5e4de877550\
            111e129f1cf1097710d41c4ac70fcdfa5ba2023c6ff1cbeac322de49d1b6df7c\
            2032c61a830e3c17286de9462bf242fca2883585b93870a73853face6a6bf411\
            198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2\
            1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\
            090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b\
            12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa",
        )
        .unwrap();
        let expected =
            hex::decode("0000000000000000000000000000000000000000000000000000000000000001")
                .unwrap();

        let res = Bn256Pair::<Byzantium>::new()
            .run(&input, Some(EthGas::new(260_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        // out of gas test
        let input = hex::decode(
            "\
            1c76476f4def4bb94541d57ebba1193381ffa7aa76ada664dd31c16024c43f59\
            3034dd2920f673e204fee2811c678745fc819b55d3e9d294e45c9b03a76aef41\
            209dd15ebff5d46c4bd888e51a93cf99a7329636c63514396b4a452003a35bf7\
            04bf11ca01483bfa8b34b43561848d28905960114c8ac04049af4b6315a41678\
            2bb8324af6cfc93537a2ad1a445cfd0ca2a71acd7ac41fadbf933c2a51be344d\
            120a2a4cf30c1bf9845f20c6fe39e07ea2cce61f0c9bb048165fe5e4de877550\
            111e129f1cf1097710d41c4ac70fcdfa5ba2023c6ff1cbeac322de49d1b6df7c\
            2032c61a830e3c17286de9462bf242fca2883585b93870a73853face6a6bf411\
            198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2\
            1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed\
            090689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b\
            12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa",
        )
        .unwrap();
        let res = Bn256Pair::<Byzantium>::new().run(
            &input,
            Some(EthGas::new(259_999)),
            &new_context(),
            false,
        );
        assert!(matches!(res, Err(ExitError::OutOfGas)));

        // no input test
        let input = [0u8; 0];
        let expected =
            hex::decode("0000000000000000000000000000000000000000000000000000000000000001")
                .unwrap();

        let res = Bn256Pair::<Byzantium>::new()
            .run(&input, Some(EthGas::new(260_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        // point not on curve fail
        let input = hex::decode(
            "\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111",
        )
        .unwrap();

        let res = Bn256Pair::<Byzantium>::new().run(
            &input,
            Some(EthGas::new(260_000)),
            &new_context(),
            false,
        );
        assert!(matches!(
            res,
            Err(ExitError::Other(Borrowed("ERR_BN128_INVALID_A")))
        ));

        // invalid input length
        let input = hex::decode(
            "\
            1111111111111111111111111111111111111111111111111111111111111111\
            1111111111111111111111111111111111111111111111111111111111111111\
            111111111111111111111111111111\
        ",
        )
        .unwrap();

        let res = Bn256Pair::<Byzantium>::new().run(
            &input,
            Some(EthGas::new(260_000)),
            &new_context(),
            false,
        );
        assert!(matches!(
            res,
            Err(ExitError::Other(Borrowed("ERR_BN128_INVALID_LEN",)))
        ));

        // on curve
        let input = hex::decode(
            "\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000",
        )
        .unwrap();
        let expected =
            hex::decode("0000000000000000000000000000000000000000000000000000000000000001")
                .unwrap();

        let res = Bn256Pair::<Byzantium>::new()
            .run(&input, Some(EthGas::new(260_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/blake2.rs ---
use evm::{Context, ExitError};

use crate::prelude::types::EthGas;
use crate::prelude::{mem, types::Address, Borrowed};
use crate::{EvmPrecompileResult, Precompile, PrecompileOutput};
use aurora_engine_types::Vec;

/// Blake2 costs.
mod costs {
    use crate::prelude::types::EthGas;

    /// Cost per round of Blake2 F.
    pub(super) const F_ROUND: EthGas = EthGas::new(1);
}

/// Blake2 constants.
mod consts {
    pub(super) const INPUT_LENGTH: usize = 213;

    /// The precomputed SIGMA.
    ///
    /// See [RFC 7693](https://datatracker.ietf.org/doc/html/rfc7693#section-2.7) specification for more details.
    pub(super) const SIGMA: [[usize; 16]; 10] = [
        [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
        [14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3],
        [11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4],
        [7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8],
        [9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13],
        [2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9],
        [12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11],
        [13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10],
        [6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5],
        [10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0],
    ];

    /// The initialization vector.
    ///
    /// See [RFC 7693](https://tools.ietf.org/html/rfc7693#section-2.6) specification for more details.
    pub(super) const IV: [u64; 8] = [
        0x6a09e667f3bcc908,
        0xbb67ae8584caa73b,
        0x3c6ef372fe94f82b,
        0xa54ff53a5f1d36f1,
        0x510e527fade682d1,
        0x9b05688c2b3e6c1f,
        0x1f83d9abfb41bd6b,
        0x5be0cd19137e2179,
    ];

    // G rotation constants.

    /// G rotation 1.
    pub(super) const R1: u32 = 32;

    /// G rotation 2.
    pub(super) const R2: u32 = 24;

    /// G rotation 3.
    pub(super) const R3: u32 = 16;

    /// G rotation 4.
    pub(super) const R4: u32 = 63;
}

/// The G primitive function which mixes two input worlds, "x" and "y", into
/// four words indexed by "a", "b", "c", and "d" in the working vector v[0..15].
///
/// See [RFC 7693](https://datatracker.ietf.org/doc/html/rfc7693#section-3.1) specification for more
/// details.
fn g(v: &mut [u64], a: usize, b: usize, c: usize, d: usize, x: u64, y: u64) {
    v[a] = v[a].wrapping_add(v[b]).wrapping_add(x);
    v[d] = (v[d] ^ v[a]).rotate_right(consts::R1);
    v[c] = v[c].wrapping_add(v[d]);
    v[b] = (v[b] ^ v[c]).rotate_right(consts::R2);
    v[a] = v[a].wrapping_add(v[b]).wrapping_add(y);
    v[d] = (v[d] ^ v[a]).rotate_right(consts::R3);
    v[c] = v[c].wrapping_add(v[d]);
    v[b] = (v[b] ^ v[c]).rotate_right(consts::R4);
}

/// Takes as an argument the state vector `h`, message block vector `m` (the last block is padded
/// with zeros to full block size, if required), 2w-bit offset counter `t`, and final block
/// indicator flag `f`. Local vector v[0..15] is used in processing. F returns a new state vector.
/// The number of rounds, `r`, is 12 for BLAKE2b and 10 for BLAKE2s. Rounds are numbered from 0 to
/// r - 1.
///
/// See [RFC 7693](https://datatracker.ietf.org/doc/html/rfc7693#section-3.2) specification for more
/// details.
fn f(mut h: [u64; 8], m: [u64; 16], t: [u64; 2], f: bool, rounds: u32) -> Vec<u8> {
    // Initialize the work vector.
    let mut v = [0u64; 16];
    v[0..8].copy_from_slice(&h); // First half from state.
    v[8..16].copy_from_slice(&consts::IV); // Second half from IV.

    v[12] ^= t[0]; // Low word of the offset.
    v[13] ^= t[1]; // High word.

    if f {
        // last block flag?
        v[14] = !v[14] // Invert all bits.
    }

    for i in 0..rounds {
        // Typically twelve rounds for blake2b.
        // Message word selection permutation for this round.
        let s = &consts::SIGMA[usize::try_from(i).expect("Round can convert to usize") % 10];
        g(&mut v, 0, 4, 8, 12, m[s[0]], m[s[1]]);
        g(&mut v, 1, 5, 9, 13, m[s[2]], m[s[3]]);
        g(&mut v, 2, 6, 10, 14, m[s[4]], m[s[5]]);
        g(&mut v, 3, 7, 11, 15, m[s[6]], m[s[7]]);

        g(&mut v, 0, 5, 10, 15, m[s[8]], m[s[9]]);
        g(&mut v, 1, 6, 11, 12, m[s[10]], m[s[11]]);
        g(&mut v, 2, 7, 8, 13, m[s[12]], m[s[13]]);
        g(&mut v, 3, 4, 9, 14, m[s[14]], m[s[15]]);
    }

    for i in 0..8 {
        // XOR the two halves.
        h[i] ^= v[i] ^ v[i + 8];
    }

    let mut result = Vec::with_capacity(64);
    for value in h {
        result.extend_from_slice(&value.to_le_bytes());
    }

    result
}

pub struct Blake2F;

impl Blake2F {
    pub const ADDRESS: Address = crate::make_address(0, 9);
}

impl Precompile for Blake2F {
    fn required_gas(input: &[u8]) -> Result<EthGas, ExitError> {
        let (int_bytes, _) = input.split_at(mem::size_of::<u32>());
        let num_rounds = u32::from_be_bytes(
            // Unwrap is fine here as it can not fail
            int_bytes.try_into().unwrap(),
        );
        Ok(num_rounds * costs::F_ROUND)
    }

    /// The compression function of the blake2 algorithm.
    ///
    /// Takes as an argument the state vector `h`, message block vector `m` (the last block is padded
    /// with zeros to full block size, if required), 2w-bit offset counter `t`, and final block
    /// indicator flag `f`. Local vector v[0..15] is used in processing. F returns a new state vector.
    /// The number of rounds, `r`, is 12 for BLAKE2b and 10 for BLAKE2s. Rounds are numbered from 0 to
    /// r - 1.
    ///
    /// See: https://eips.ethereum.org/EIPS/eip-152
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000009
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        if input.len() != consts::INPUT_LENGTH {
            return Err(ExitError::Other(Borrowed("ERR_BLAKE2F_INVALID_LEN")));
        }

        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let mut rounds_bytes = [0u8; 4];
        rounds_bytes.copy_from_slice(&input[0..4]);
        let rounds = u32::from_be_bytes(rounds_bytes);

        let mut h = [0u64; 8];
        for (mut x, value) in h.iter_mut().enumerate() {
            let mut word: [u8; 8] = [0u8; 8];
            x = x * 8 + 4;
            word.copy_from_slice(&input[x..(x + 8)]);
            *value = u64::from_le_bytes(word);
        }

        let mut m = [0u64; 16];
        for (mut x, value) in m.iter_mut().enumerate() {
            let mut word: [u8; 8] = [0u8; 8];
            x = x * 8 + 68;
            word.copy_from_slice(&input[x..(x + 8)]);
            *value = u64::from_le_bytes(word);
        }

        let mut t: [u64; 2] = [0u64; 2];
        for (mut x, value) in t.iter_mut().enumerate() {
            let mut word: [u8; 8] = [0u8; 8];
            x = x * 8 + 196;
            word.copy_from_slice(&input[x..(x + 8)]);
            *value = u64::from_le_bytes(word);
        }

        if input[212] != 0 && input[212] != 1 {
            return Err(ExitError::Other(Borrowed("ERR_BLAKE2F_FINAL_FLAG")));
        }
        let finished = input[212] != 0;

        let output = f(h, m, t, finished, rounds);
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

#[cfg(test)]
mod tests {
    use super::super::utils::new_context;
    use crate::prelude::Vec;

    use super::*;

    // [4 bytes for rounds]
    // [64 bytes for h]
    // [128 bytes for m]
    // [8 bytes for t_0]
    // [8 bytes for t_1]
    // [1 byte for f]
    const INPUT: &str = "\
            0000000c\
            48c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5\
            d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b\
            6162630000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0300000000000000\
            0000000000000000\
            01";

    fn test_blake2f_out_of_gas() -> EvmPrecompileResult {
        let input = hex::decode(INPUT).unwrap();
        Blake2F.run(&input, Some(EthGas::new(11)), &new_context(), false)
    }

    fn test_blake2f_empty() -> EvmPrecompileResult {
        let input = [0u8; 0];
        Blake2F.run(&input, Some(EthGas::new(0)), &new_context(), false)
    }

    fn test_blake2f_invalid_len_1() -> EvmPrecompileResult {
        let input = hex::decode(
            "\
            00000c\
            48c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5\
            d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b\
            6162630000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0300000000000000\
            0000000000000000\
            01",
        )
        .unwrap();
        Blake2F.run(&input, Some(EthGas::new(12)), &new_context(), false)
    }

    fn test_blake2f_invalid_len_2() -> EvmPrecompileResult {
        let input = hex::decode(
            "\
            000000000c\
            48c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5\
            d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b\
            6162630000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0300000000000000\
            0000000000000000\
            01",
        )
        .unwrap();
        Blake2F.run(&input, Some(EthGas::new(12)), &new_context(), false)
    }

    fn test_blake2f_invalid_flag() -> EvmPrecompileResult {
        let input = hex::decode(
            "\
            0000000c\
            48c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5\
            d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b\
            6162630000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0300000000000000\
            0000000000000000\
            02",
        )
        .unwrap();
        Blake2F.run(&input, Some(EthGas::new(12)), &new_context(), false)
    }

    fn test_blake2f_r_0() -> Vec<u8> {
        let input = hex::decode(
            "\
            00000000\
            48c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5\
            d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b\
            6162630000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0300000000000000\
            0000000000000000\
            01",
        )
        .unwrap();
        Blake2F
            .run(&input, Some(EthGas::new(12)), &new_context(), false)
            .unwrap()
            .output
    }

    fn test_blake2f_r_12() -> Vec<u8> {
        let input = hex::decode(INPUT).unwrap();
        Blake2F
            .run(&input, Some(EthGas::new(12)), &new_context(), false)
            .unwrap()
            .output
    }

    fn test_blake2f_final_block_false() -> Vec<u8> {
        let input = hex::decode(
            "\
            0000000c\
            48c9bdf267e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5\
            d182e6ad7f520e511f6c3e2b8c68059b6bbd41fbabd9831f79217e1319cde05b\
            6162630000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000000\
            0300000000000000\
            0000000000000000\
            00",
        )
        .unwrap();
        Blake2F
            .run(&input, Some(EthGas::new(12)), &new_context(), false)
            .unwrap()
            .output
    }

    #[test]
    fn test_blake2f() {
        assert!(matches!(
            test_blake2f_out_of_gas(),
            Err(ExitError::OutOfGas)
        ));

        assert!(matches!(
            test_blake2f_empty(),
            Err(ExitError::Other(Borrowed("ERR_BLAKE2F_INVALID_LEN")))
        ));

        assert!(matches!(
            test_blake2f_invalid_len_1(),
            Err(ExitError::Other(Borrowed("ERR_BLAKE2F_INVALID_LEN")))
        ));

        assert!(matches!(
            test_blake2f_invalid_len_2(),
            Err(ExitError::Other(Borrowed("ERR_BLAKE2F_INVALID_LEN")))
        ));

        assert!(matches!(
            test_blake2f_invalid_flag(),
            Err(ExitError::Other(Borrowed("ERR_BLAKE2F_FINAL_FLAG",)))
        ));

        let expected = hex::decode(
            "08c9bcf367e6096a3ba7ca8485ae67bb2bf894fe72f36e3cf1361d5f3af54fa5d\
            282e6ad7f520e511f6c3e2b8c68059b9442be0454267ce079217e1319cde05b",
        )
        .unwrap();
        assert_eq!(test_blake2f_r_0(), expected);

        let expected = hex::decode(
            "ba80a53f981c4d0d6a2797b69f12f6e94c212f14685ac4b74b12bb6fdbffa2d1\
                7d87c5392aab792dc252d5de4533cc9518d38aa8dbf1925ab92386edd4009923",
        )
        .unwrap();
        assert_eq!(test_blake2f_r_12(), expected);

        let expected = hex::decode(
            "75ab69d3190a562c51aef8d88f1c2775876944407270c42c9844252c26d28752\
            98743e7f6d5ea2f2d3e8d226039cd31b4e426ac4f2d3d666a610c2116fde4735",
        )
        .unwrap();
        assert_eq!(test_blake2f_final_block_false(), expected);
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/hash.rs ---
#[cfg(feature = "contract")]
use crate::prelude::sdk;
use crate::prelude::types::{Address, EthGas};
use crate::prelude::vec;
use crate::{utils, EvmPrecompileResult, Precompile, PrecompileOutput};
use evm::{Context, ExitError};

mod costs {
    use crate::prelude::types::EthGas;

    pub(super) const SHA256_BASE: EthGas = EthGas::new(60);

    pub(super) const SHA256_PER_WORD: EthGas = EthGas::new(12);

    pub(super) const RIPEMD160_BASE: EthGas = EthGas::new(600);

    pub(super) const RIPEMD160_PER_WORD: EthGas = EthGas::new(120);
}

mod consts {
    pub(super) const SHA256_WORD_LEN: u64 = 32;

    pub(super) const RIPEMD_WORD_LEN: u64 = 32;
}

/// SHA256 precompile.
pub struct SHA256;

impl SHA256 {
    pub const ADDRESS: Address = super::make_address(0, 2);
}

impl Precompile for SHA256 {
    fn required_gas(input: &[u8]) -> Result<EthGas, ExitError> {
        let input_len = u64::try_from(input.len()).map_err(utils::err_usize_conv)?;
        Ok(
            (input_len + consts::SHA256_WORD_LEN - 1) / consts::SHA256_WORD_LEN
                * costs::SHA256_PER_WORD
                + costs::SHA256_BASE,
        )
    }

    /// See: https://ethereum.github.io/yellowpaper/paper.pdf
    /// See: https://docs.soliditylang.org/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000002
    #[cfg(not(feature = "contract"))]
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        use sha2::Digest;

        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let output = sha2::Sha256::digest(input).to_vec();
        Ok(PrecompileOutput::without_logs(cost, output))
    }

    /// See: https://ethereum.github.io/yellowpaper/paper.pdf
    /// See: https://docs.soliditylang.org/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000002
    #[cfg(feature = "contract")]
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let output = sdk::sha256(input).as_bytes().to_vec();
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

/// RIPEMD160 precompile.
pub struct RIPEMD160;

impl RIPEMD160 {
    pub const ADDRESS: Address = super::make_address(0, 3);

    #[cfg(not(feature = "contract"))]
    fn internal_impl(input: &[u8]) -> [u8; 20] {
        use ripemd::{Digest, Ripemd160};

        let hash = Ripemd160::digest(input);
        let mut output = [0u8; 20];
        output.copy_from_slice(&hash);
        output
    }
}

impl Precompile for RIPEMD160 {
    fn required_gas(input: &[u8]) -> Result<EthGas, ExitError> {
        let input_len = u64::try_from(input.len()).map_err(utils::err_usize_conv)?;
        Ok(
            (input_len + consts::RIPEMD_WORD_LEN - 1) / consts::RIPEMD_WORD_LEN
                * costs::RIPEMD160_PER_WORD
                + costs::RIPEMD160_BASE,
        )
    }

    /// See: https://ethereum.github.io/yellowpaper/paper.pdf
    /// See: https://docs.soliditylang.org/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000003
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        #[cfg(not(feature = "contract"))]
        let hash = Self::internal_impl(input);
        #[cfg(feature = "contract")]
        let hash = sdk::ripemd160(input);
        // The result needs to be padded with leading zeros because it is only 20 bytes, but
        // the evm works with 32-byte words.
        let mut output = vec![0u8; 32];
        output[12..].copy_from_slice(&hash);
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

#[cfg(test)]
mod tests {
    use crate::utils::new_context;

    use super::*;

    #[test]
    fn test_sha256() {
        let input = b"";
        let expected =
            hex::decode("e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855")
                .unwrap();

        let res = SHA256
            .run(input, Some(EthGas::new(60)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);
    }

    #[test]
    fn test_ripemd160() {
        let input = b"";
        let expected =
            hex::decode("0000000000000000000000009c1185a5c5e9fc54612808977ee8f548b2258d31")
                .unwrap();

        let res = RIPEMD160
            .run(input, Some(EthGas::new(600)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/identity.rs ---
use crate::prelude::types::{Address, EthGas};
use crate::{utils, EvmPrecompileResult, Precompile, PrecompileOutput};
use evm::{Context, ExitError};

/// Identity precompile costs.
mod costs {
    use crate::prelude::types::EthGas;

    /// The base cost of the operation.
    pub(super) const IDENTITY_BASE: EthGas = EthGas::new(15);

    /// The cost per word.
    pub(super) const IDENTITY_PER_WORD: EthGas = EthGas::new(3);
}

mod consts {
    /// Length of the identity word.
    pub(super) const IDENTITY_WORD_LEN: u64 = 32;
}

pub struct Identity;

impl Identity {
    pub const ADDRESS: Address = super::make_address(0, 4);
}

impl Precompile for Identity {
    fn required_gas(input: &[u8]) -> Result<EthGas, ExitError> {
        let input_len = u64::try_from(input.len()).map_err(utils::err_usize_conv)?;
        Ok(
            (input_len + consts::IDENTITY_WORD_LEN - 1) / consts::IDENTITY_WORD_LEN
                * costs::IDENTITY_PER_WORD
                + costs::IDENTITY_BASE,
        )
    }

    /// Takes the input bytes, copies them, and returns it as the output.
    ///
    /// See: https://ethereum.github.io/yellowpaper/paper.pdf
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000004
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        Ok(PrecompileOutput::without_logs(cost, input.to_vec()))
    }
}

#[cfg(test)]
mod tests {
    use evm::ExitError;

    use crate::utils::new_context;

    use super::*;

    #[test]
    fn test_identity() {
        let input = [0u8, 1, 2, 3];

        let expected = input[0..2].to_vec();
        let res = Identity
            .run(&input[0..2], Some(EthGas::new(18)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        let expected = input.to_vec();
        let res = Identity
            .run(&input, Some(EthGas::new(18)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        // gas fail
        let res = Identity.run(&input[0..2], Some(EthGas::new(17)), &new_context(), false);

        assert!(matches!(res, Err(ExitError::OutOfGas)));

        // larger input
        let input = [
            0u8, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23,
            24, 25, 26, 27, 28, 29, 30, 31, 32,
        ];
        let res = Identity
            .run(&input, Some(EthGas::new(21)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, input.to_vec());
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/lib.rs ---
#![allow(dead_code)]
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(not(feature = "std"), feature(alloc_error_handler))]
#![deny(clippy::as_conversions)]

pub mod account_ids;
pub mod alt_bn256;
pub mod blake2;
pub mod hash;
pub mod identity;
pub mod modexp;
pub mod native;
mod prelude;
pub mod prepaid_gas;
pub mod promise_result;
pub mod random;
pub mod secp256k1;
mod utils;
pub mod xcc;

use crate::account_ids::{predecessor_account, CurrentAccount, PredecessorAccount};
use crate::alt_bn256::{Bn256Add, Bn256Mul, Bn256Pair};
use crate::blake2::Blake2F;
use crate::hash::{RIPEMD160, SHA256};
use crate::identity::Identity;
use crate::modexp::ModExp;
use crate::native::{exit_to_ethereum, exit_to_near, ExitToEthereum, ExitToNear};
use crate::prelude::types::EthGas;
use crate::prelude::{Vec, H160, H256};
use crate::prepaid_gas::PrepaidGas;
use crate::random::RandomSeed;
use crate::secp256k1::ECRecover;
use crate::xcc::CrossContractCall;
use aurora_engine_sdk::env::Env;
use aurora_engine_sdk::io::IO;
use aurora_engine_sdk::promise::ReadOnlyPromiseHandler;
use aurora_engine_types::{account_id::AccountId, types::Address, vec, BTreeMap, BTreeSet, Box};
use evm::backend::Log;
use evm::executor::{
    self,
    stack::{PrecompileFailure, PrecompileHandle},
};
use evm::{Context, ExitError, ExitFatal, ExitSucceed};
use promise_result::PromiseResult;
use xcc::cross_contract_call;

#[derive(Debug, Default, PartialEq, Eq)]
pub struct PrecompileOutput {
    pub cost: EthGas,
    pub output: Vec<u8>,
    pub logs: Vec<Log>,
}

impl PrecompileOutput {
    pub fn without_logs(cost: EthGas, output: Vec<u8>) -> Self {
        Self {
            cost,
            output,
            logs: Vec::new(),
        }
    }
}

type EvmPrecompileResult = Result<PrecompileOutput, ExitError>;

/// A precompiled function for use in the EVM.
pub trait Precompile {
    /// The required gas in order to run the precompile function.
    fn required_gas(input: &[u8]) -> Result<EthGas, ExitError>
    where
        Self: Sized;

    /// Runs the precompile function.
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        context: &Context,
        is_static: bool,
    ) -> EvmPrecompileResult;
}

pub trait HandleBasedPrecompile {
    fn run_with_handle(
        &self,
        handle: &mut impl PrecompileHandle,
    ) -> Result<PrecompileOutput, PrecompileFailure>;
}

/// Hard fork marker.
pub trait HardFork {}

/// Homestead hard fork marker.
pub struct Homestead;

/// Homestead hard fork marker.
pub struct Byzantium;

/// Homestead hard fork marker.
pub struct Istanbul;

/// Homestead hard fork marker.
pub struct Berlin;

impl HardFork for Homestead {}

impl HardFork for Byzantium {}

impl HardFork for Istanbul {}

impl HardFork for Berlin {}

pub struct Precompiles<'a, I, E, H> {
    pub all_precompiles: prelude::BTreeMap<Address, AllPrecompiles<'a, I, E, H>>,
    pub paused_precompiles: prelude::BTreeSet<Address>,
}

impl<'a, I, E, H> Precompiles<'a, I, E, H> {
    fn is_paused(&self, address: &Address) -> bool {
        self.paused_precompiles.contains(address)
    }
}

impl<'a, I: IO + Copy, E: Env, H: ReadOnlyPromiseHandler> executor::stack::PrecompileSet
    for Precompiles<'a, I, E, H>
{
    fn execute(
        &self,
        handle: &mut impl PrecompileHandle,
    ) -> Option<Result<executor::stack::PrecompileOutput, PrecompileFailure>> {
        let address = Address::new(handle.code_address());

        if self.is_paused(&address) {
            return Some(Err(PrecompileFailure::Fatal {
                exit_status: ExitFatal::Other(prelude::Cow::Borrowed("ERR_PAUSED")),
            }));
        }

        let result = match self.all_precompiles.get(&address)? {
            AllPrecompiles::ExitToNear(p) => process_precompile(p, handle),
            AllPrecompiles::ExitToEthereum(p) => process_precompile(p, handle),
            AllPrecompiles::PredecessorAccount(p) => process_precompile(p, handle),
            AllPrecompiles::PrepaidGas(p) => process_precompile(p, handle),
            AllPrecompiles::PromiseResult(p) => process_precompile(p, handle),
            AllPrecompiles::CrossContractCall(p) => process_handle_based_precompile(p, handle),
            AllPrecompiles::Generic(p) => process_precompile(p.as_ref(), handle),
        };

        Some(result.and_then(|output| post_process(output, handle)))
    }

    fn is_precompile(&self, address: prelude::H160) -> bool {
        self.all_precompiles.contains_key(&Address::new(address))
    }
}

fn process_precompile(
    p: &dyn Precompile,
    handle: &mut impl PrecompileHandle,
) -> Result<PrecompileOutput, PrecompileFailure> {
    let input = handle.input();
    let gas_limit = handle.gas_limit();
    let context = handle.context();
    let is_static = handle.is_static();

    p.run(input, gas_limit.map(EthGas::new), context, is_static)
        .map_err(|exit_status| PrecompileFailure::Error { exit_status })
}

fn process_handle_based_precompile(
    p: &impl HandleBasedPrecompile,
    handle: &mut impl PrecompileHandle,
) -> Result<PrecompileOutput, PrecompileFailure> {
    p.run_with_handle(handle)
}

fn post_process(
    output: PrecompileOutput,
    handle: &mut impl PrecompileHandle,
) -> Result<executor::stack::PrecompileOutput, PrecompileFailure> {
    handle.record_cost(output.cost.as_u64())?;
    for log in output.logs {
        handle.log(log.address, log.topics, log.data)?;
    }
    Ok(executor::stack::PrecompileOutput {
        exit_status: ExitSucceed::Returned,
        output: output.output,
    })
}

pub struct PrecompileConstructorContext<'a, I, E, H> {
    pub current_account_id: AccountId,
    pub random_seed: H256,
    pub io: I,
    pub env: &'a E,
    pub promise_handler: H,
}

impl<'a, I: IO + Copy, E: Env, H: ReadOnlyPromiseHandler> Precompiles<'a, I, E, H> {
    #[allow(dead_code)]
    pub fn new_homestead(ctx: PrecompileConstructorContext<'a, I, E, H>) -> Self {
        let addresses = vec![
            ECRecover::ADDRESS,
            SHA256::ADDRESS,
            RIPEMD160::ADDRESS,
            RandomSeed::ADDRESS,
            CurrentAccount::ADDRESS,
        ];
        let fun: prelude::Vec<Box<dyn Precompile>> = vec![
            Box::new(ECRecover),
            Box::new(SHA256),
            Box::new(RIPEMD160),
            Box::new(RandomSeed::new(ctx.random_seed)),
            Box::new(CurrentAccount::new(ctx.current_account_id.clone())),
        ];
        let map = addresses
            .into_iter()
            .zip(fun)
            .map(|(a, f)| (a, AllPrecompiles::Generic(f)))
            .collect();
        Self::with_generic_precompiles(map, ctx)
    }

    #[allow(dead_code)]
    pub fn new_byzantium(ctx: PrecompileConstructorContext<'a, I, E, H>) -> Self {
        let addresses = vec![
            ECRecover::ADDRESS,
            SHA256::ADDRESS,
            RIPEMD160::ADDRESS,
            Identity::ADDRESS,
            ModExp::<Byzantium>::ADDRESS,
            Bn256Add::<Byzantium>::ADDRESS,
            Bn256Mul::<Byzantium>::ADDRESS,
            Bn256Pair::<Byzantium>::ADDRESS,
            RandomSeed::ADDRESS,
            CurrentAccount::ADDRESS,
        ];
        let fun: prelude::Vec<Box<dyn Precompile>> = vec![
            Box::new(ECRecover),
            Box::new(SHA256),
            Box::new(RIPEMD160),
            Box::new(Identity),
            Box::new(ModExp::<Byzantium>::new()),
            Box::new(Bn256Add::<Byzantium>::new()),
            Box::new(Bn256Mul::<Byzantium>::new()),
            Box::new(Bn256Pair::<Byzantium>::new()),
            Box::new(RandomSeed::new(ctx.random_seed)),
            Box::new(CurrentAccount::new(ctx.current_account_id.clone())),
        ];
        let map = addresses
            .into_iter()
            .zip(fun)
            .map(|(a, f)| (a, AllPrecompiles::Generic(f)))
            .collect();

        Self::with_generic_precompiles(map, ctx)
    }

    pub fn new_istanbul(ctx: PrecompileConstructorContext<'a, I, E, H>) -> Self {
        let addresses = vec![
            ECRecover::ADDRESS,
            SHA256::ADDRESS,
            RIPEMD160::ADDRESS,
            Identity::ADDRESS,
            ModExp::<Byzantium>::ADDRESS,
            Bn256Add::<Istanbul>::ADDRESS,
            Bn256Mul::<Istanbul>::ADDRESS,
            Bn256Pair::<Istanbul>::ADDRESS,
            Blake2F::ADDRESS,
            RandomSeed::ADDRESS,
            CurrentAccount::ADDRESS,
        ];
        let fun: prelude::Vec<Box<dyn Precompile>> = vec![
            Box::new(ECRecover),
            Box::new(SHA256),
            Box::new(RIPEMD160),
            Box::new(Identity),
            Box::new(ModExp::<Byzantium>::new()),
            Box::new(Bn256Add::<Istanbul>::new()),
            Box::new(Bn256Mul::<Istanbul>::new()),
            Box::new(Bn256Pair::<Istanbul>::new()),
            Box::new(Blake2F),
            Box::new(RandomSeed::new(ctx.random_seed)),
            Box::new(CurrentAccount::new(ctx.current_account_id.clone())),
        ];
        let map = addresses
            .into_iter()
            .zip(fun)
            .map(|(a, f)| (a, AllPrecompiles::Generic(f)))
            .collect();

        Self::with_generic_precompiles(map, ctx)
    }

    pub fn new_berlin(ctx: PrecompileConstructorContext<'a, I, E, H>) -> Self {
        let addresses = vec![
            ECRecover::ADDRESS,
            SHA256::ADDRESS,
            RIPEMD160::ADDRESS,
            Identity::ADDRESS,
            ModExp::<Berlin>::ADDRESS,
            Bn256Add::<Istanbul>::ADDRESS,
            Bn256Mul::<Istanbul>::ADDRESS,
            Bn256Pair::<Istanbul>::ADDRESS,
            Blake2F::ADDRESS,
            RandomSeed::ADDRESS,
            CurrentAccount::ADDRESS,
        ];
        let fun: prelude::Vec<Box<dyn Precompile>> = vec![
            Box::new(ECRecover),
            Box::new(SHA256),
            Box::new(RIPEMD160),
            Box::new(Identity),
            Box::new(ModExp::<Berlin>::new()),
            Box::new(Bn256Add::<Istanbul>::new()),
            Box::new(Bn256Mul::<Istanbul>::new()),
            Box::new(Bn256Pair::<Istanbul>::new()),
            Box::new(Blake2F),
            Box::new(RandomSeed::new(ctx.random_seed)),
            Box::new(CurrentAccount::new(ctx.current_account_id.clone())),
        ];
        let map = addresses
            .into_iter()
            .zip(fun)
            .map(|(a, f)| (a, AllPrecompiles::Generic(f)))
            .collect();

        Self::with_generic_precompiles(map, ctx)
    }

    pub fn new_london(ctx: PrecompileConstructorContext<'a, I, E, H>) -> Self {
        // no precompile changes in London HF
        Self::new_berlin(ctx)
    }

    fn with_generic_precompiles(
        mut generic_precompiles: BTreeMap<Address, AllPrecompiles<'a, I, E, H>>,
        ctx: PrecompileConstructorContext<'a, I, E, H>,
    ) -> Self {
        let near_exit = ExitToNear::new(ctx.current_account_id.clone(), ctx.io);
        let ethereum_exit = ExitToEthereum::new(ctx.current_account_id.clone(), ctx.io);
        let cross_contract_call = CrossContractCall::new(ctx.current_account_id, ctx.io);
        let predecessor_account_id = PredecessorAccount::new(ctx.env);
        let prepaid_gas = PrepaidGas::new(ctx.env);
        let promise_results = PromiseResult::new(ctx.promise_handler);

        generic_precompiles.insert(exit_to_near::ADDRESS, AllPrecompiles::ExitToNear(near_exit));
        generic_precompiles.insert(
            exit_to_ethereum::ADDRESS,
            AllPrecompiles::ExitToEthereum(ethereum_exit),
        );
        generic_precompiles.insert(
            cross_contract_call::ADDRESS,
            AllPrecompiles::CrossContractCall(cross_contract_call),
        );
        generic_precompiles.insert(
            predecessor_account::ADDRESS,
            AllPrecompiles::PredecessorAccount(predecessor_account_id),
        );
        generic_precompiles.insert(
            prepaid_gas::ADDRESS,
            AllPrecompiles::PrepaidGas(prepaid_gas),
        );
        generic_precompiles.insert(
            promise_result::ADDRESS,
            AllPrecompiles::PromiseResult(promise_results),
        );

        Self {
            all_precompiles: generic_precompiles,
            paused_precompiles: BTreeSet::new(),
        }
    }
}

pub enum AllPrecompiles<'a, I, E, H> {
    ExitToNear(ExitToNear<I>),
    ExitToEthereum(ExitToEthereum<I>),
    CrossContractCall(CrossContractCall<I>),
    PredecessorAccount(PredecessorAccount<'a, E>),
    PrepaidGas(PrepaidGas<'a, E>),
    PromiseResult(PromiseResult<H>),
    Generic(Box<dyn Precompile>),
}

/// fn for making an address by concatenating the bytes from two given numbers,
/// Note that 32 + 128 = 160 = 20 bytes (the length of an address). This function is used
/// as a convenience for specifying the addresses of the various precompiles.
pub const fn make_address(x: u32, y: u128) -> prelude::types::Address {
    let x_bytes = x.to_be_bytes();
    let y_bytes = y.to_be_bytes();
    prelude::types::Address::new(H160([
        x_bytes[0],
        x_bytes[1],
        x_bytes[2],
        x_bytes[3],
        y_bytes[0],
        y_bytes[1],
        y_bytes[2],
        y_bytes[3],
        y_bytes[4],
        y_bytes[5],
        y_bytes[6],
        y_bytes[7],
        y_bytes[8],
        y_bytes[9],
        y_bytes[10],
        y_bytes[11],
        y_bytes[12],
        y_bytes[13],
        y_bytes[14],
        y_bytes[15],
    ]))
}

const fn make_h256(x: u128, y: u128) -> prelude::H256 {
    let x_bytes = x.to_be_bytes();
    let y_bytes = y.to_be_bytes();
    prelude::H256([
        x_bytes[0],
        x_bytes[1],
        x_bytes[2],
        x_bytes[3],
        x_bytes[4],
        x_bytes[5],
        x_bytes[6],
        x_bytes[7],
        x_bytes[8],
        x_bytes[9],
        x_bytes[10],
        x_bytes[11],
        x_bytes[12],
        x_bytes[13],
        x_bytes[14],
        x_bytes[15],
        y_bytes[0],
        y_bytes[1],
        y_bytes[2],
        y_bytes[3],
        y_bytes[4],
        y_bytes[5],
        y_bytes[6],
        y_bytes[7],
        y_bytes[8],
        y_bytes[9],
        y_bytes[10],
        y_bytes[11],
        y_bytes[12],
        y_bytes[13],
        y_bytes[14],
        y_bytes[15],
    ])
}

#[cfg(test)]
mod tests {
    use crate::prelude::H160;
    use crate::{prelude, Byzantium, Istanbul};
    use prelude::types::Address;
    use rand::Rng;

    #[test]
    fn test_precompile_addresses() {
        assert_eq!(super::secp256k1::ECRecover::ADDRESS, u8_to_address(1));
        assert_eq!(super::hash::SHA256::ADDRESS, u8_to_address(2));
        assert_eq!(super::hash::RIPEMD160::ADDRESS, u8_to_address(3));
        assert_eq!(super::identity::Identity::ADDRESS, u8_to_address(4));
        assert_eq!(super::ModExp::<Byzantium>::ADDRESS, u8_to_address(5));
        assert_eq!(super::Bn256Add::<Istanbul>::ADDRESS, u8_to_address(6));
        assert_eq!(super::Bn256Mul::<Istanbul>::ADDRESS, u8_to_address(7));
        assert_eq!(super::Bn256Pair::<Istanbul>::ADDRESS, u8_to_address(8));
        assert_eq!(super::blake2::Blake2F::ADDRESS, u8_to_address(9));
    }

    #[test]
    fn test_make_address() {
        for i in 0..u8::MAX {
            assert_eq!(super::make_address(0, i.into()), u8_to_address(i));
        }

        let mut rng = rand::thread_rng();
        for _ in 0..u8::MAX {
            let address = Address::new(H160(rng.gen()));
            let (x, y) = split_address(address);
            assert_eq!(address, super::make_address(x, y))
        }
    }

    #[test]
    fn test_paused_precompiles_throws_error() {
        use crate::{
            AllPrecompiles, Context, EvmPrecompileResult, ExitError, Precompile, PrecompileOutput,
            Precompiles,
        };
        use aurora_engine_sdk::env::Fixed;
        use aurora_engine_sdk::promise::Noop;
        use aurora_engine_test_doubles::io::StoragePointer;
        use aurora_engine_types::types::EthGas;
        use evm::executor::stack::{PrecompileFailure, PrecompileHandle, PrecompileSet};
        use evm::{ExitFatal, ExitReason, Transfer};

        struct MockPrecompile;

        impl Precompile for MockPrecompile {
            fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError>
            where
                Self: Sized,
            {
                Ok(EthGas::new(0))
            }

            fn run(
                &self,
                _input: &[u8],
                _target_gas: Option<EthGas>,
                _context: &Context,
                _is_static: bool,
            ) -> EvmPrecompileResult {
                Ok(PrecompileOutput::default())
            }
        }

        struct MockPrecompileHandle {
            code_address: H160,
        }

        impl MockPrecompileHandle {
            pub fn new(code_address: H160) -> Self {
                Self { code_address }
            }
        }

        impl PrecompileHandle for MockPrecompileHandle {
            fn call(
                &mut self,
                _to: H160,
                _transfer: Option<Transfer>,
                _input: Vec<u8>,
                _gas_limit: Option<u64>,
                _is_static: bool,
                _context: &Context,
            ) -> (ExitReason, Vec<u8>) {
                unimplemented!()
            }

            fn record_cost(&mut self, _cost: u64) -> Result<(), ExitError> {
                unimplemented!()
            }

            fn remaining_gas(&self) -> u64 {
                unimplemented!()
            }

            fn log(
                &mut self,
                _address: H160,
                _topics: Vec<aurora_engine_types::H256>,
                _data: Vec<u8>,
            ) -> Result<(), ExitError> {
                unimplemented!()
            }

            fn code_address(&self) -> H160 {
                self.code_address
            }

            fn input(&self) -> &[u8] {
                unimplemented!()
            }

            fn context(&self) -> &Context {
                unimplemented!()
            }

            fn is_static(&self) -> bool {
                unimplemented!()
            }

            fn gas_limit(&self) -> Option<u64> {
                unimplemented!()
            }
        }

        let precompile_address = Address::default();
        let precompile: AllPrecompiles<StoragePointer, Fixed, Noop> =
            AllPrecompiles::Generic(Box::new(MockPrecompile));

        let precompiles: Precompiles<StoragePointer, Fixed, Noop> = Precompiles {
            all_precompiles: {
                let mut map = prelude::BTreeMap::new();
                map.insert(precompile_address, precompile);
                map
            },
            paused_precompiles: {
                let mut set = prelude::BTreeSet::new();
                set.insert(precompile_address);
                set
            },
        };
        let mut precompile_handle = MockPrecompileHandle::new(precompile_address.raw());

        let result = precompiles
            .execute(&mut precompile_handle)
            .expect("result must contain error but is empty");
        let actual_failure = result.expect_err("result must contain failure but is successful");
        let expected_failure = PrecompileFailure::Fatal {
            exit_status: ExitFatal::Other(prelude::Cow::Borrowed("ERR_PAUSED")),
        };

        assert_eq!(expected_failure, actual_failure);
    }

    fn u8_to_address(x: u8) -> Address {
        let mut bytes = [0u8; 20];
        bytes[19] = x;
        Address::new(H160(bytes))
    }

    // Inverse function of `super::make_address`.
    fn split_address(a: Address) -> (u32, u128) {
        let mut x_bytes = [0u8; 4];
        let mut y_bytes = [0u8; 16];

        x_bytes.copy_from_slice(&a.raw()[0..4]);
        y_bytes.copy_from_slice(&a.raw()[4..20]);

        (u32::from_be_bytes(x_bytes), u128::from_be_bytes(y_bytes))
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/modexp.rs ---
use crate::prelude::types::{Address, EthGas};
use crate::prelude::{PhantomData, Vec, U256};
use crate::{
    utils, Berlin, Byzantium, EvmPrecompileResult, HardFork, Precompile, PrecompileOutput,
};
use evm::{Context, ExitError};
use num::{BigUint, Integer};

#[derive(Default)]
pub struct ModExp<HF: HardFork>(PhantomData<HF>);

impl<HF: HardFork> ModExp<HF> {
    pub const ADDRESS: Address = super::make_address(0, 5);

    pub fn new() -> Self {
        Self(Default::default())
    }
}

impl<HF: HardFork> ModExp<HF> {
    // Note: the output of this function is bounded by 2^67
    fn calc_iter_count(exp_len: u64, base_len: u64, bytes: &[u8]) -> Result<U256, ExitError> {
        let start = usize::try_from(base_len).map_err(utils::err_usize_conv)?;
        let exp_len = usize::try_from(exp_len).map_err(utils::err_usize_conv)?;
        let exp = parse_bytes(
            bytes,
            start.saturating_add(96),
            core::cmp::min(32, exp_len),
            // I don't understand why I need a closure here, but doesn't compile without one
            |x| U256::from(x),
        );

        if exp_len <= 32 && exp.is_zero() {
            Ok(U256::zero())
        } else if exp_len <= 32 {
            Ok(U256::from(exp.bits()) - U256::from(1))
        } else {
            // else > 32
            Ok(U256::from(8) * U256::from(exp_len - 32) + U256::from(exp.bits()) - U256::from(1))
        }
    }

    fn run_inner(input: &[u8]) -> Result<Vec<u8>, ExitError> {
        let (base_len, exp_len, mod_len) = parse_lengths(input);
        let base_len = usize::try_from(base_len).map_err(utils::err_usize_conv)?;
        let exp_len = usize::try_from(exp_len).map_err(utils::err_usize_conv)?;
        let mod_len = usize::try_from(mod_len).map_err(utils::err_usize_conv)?;

        let base_start = 96;
        let base_end = base_len.saturating_add(base_start);

        let exp_start = base_end;
        let exp_end = exp_len.saturating_add(exp_start);

        let mod_start = exp_end;

        let base = parse_bytes(input, base_start, base_len, BigUint::from_bytes_be);
        let exponent = parse_bytes(input, exp_start, exp_len, BigUint::from_bytes_be);
        let modulus = parse_bytes(input, mod_start, mod_len, BigUint::from_bytes_be);

        let output = {
            let computed_result = if modulus == BigUint::from(0u32) {
                Vec::new()
            } else {
                base.modpow(&exponent, &modulus).to_bytes_be()
            };
            // The result must be the same length as the input modulus.
            // To ensure this we pad on the left with zeros.
            if mod_len > computed_result.len() {
                let diff = mod_len - computed_result.len();
                let mut padded_result = Vec::with_capacity(mod_len);
                padded_result.extend(core::iter::repeat(0).take(diff));
                padded_result.extend_from_slice(&computed_result);
                padded_result
            } else {
                computed_result
            }
        };

        Ok(output)
    }
}

impl ModExp<Byzantium> {
    // ouput of this function is bounded by 2^128
    fn mul_complexity(x: u64) -> U256 {
        if x <= 64 {
            U256::from(x * x)
        } else if x <= 1_024 {
            U256::from(x * x / 4 + 96 * x - 3_072)
        } else {
            // up-cast to avoid overflow
            let x = U256::from(x);
            let x_sq = x * x; // x < 2^64 => x*x < 2^128 < 2^256 (no overflow)
            x_sq / U256::from(16) + U256::from(480) * x - U256::from(199_680)
        }
    }
}

impl Precompile for ModExp<Byzantium> {
    fn required_gas(input: &[u8]) -> Result<EthGas, ExitError> {
        let (base_len, exp_len, mod_len) = parse_lengths(input);

        let mul = Self::mul_complexity(core::cmp::max(mod_len, base_len));
        let iter_count = Self::calc_iter_count(exp_len, base_len, input)?;
        // mul * iter_count bounded by 2^195 < 2^256 (no overflow)
        let gas = mul * core::cmp::max(iter_count, U256::one()) / U256::from(20);

        Ok(EthGas::new(saturating_round(gas)))
    }

    /// See: https://eips.ethereum.org/EIPS/eip-198
    /// See: https://etherscan.io/address/0000000000000000000000000000000000000005
    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let output = Self::run_inner(input)?;
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

impl ModExp<Berlin> {
    // output bounded by 2^122
    fn mul_complexity(base_len: u64, mod_len: u64) -> U256 {
        let max_len = core::cmp::max(mod_len, base_len);
        let words = U256::from(Integer::div_ceil(&max_len, &8));
        words * words
    }
}

impl Precompile for ModExp<Berlin> {
    fn required_gas(input: &[u8]) -> Result<EthGas, ExitError> {
        let (base_len, exp_len, mod_len) = parse_lengths(input);

        let mul = Self::mul_complexity(base_len, mod_len);
        let iter_count = Self::calc_iter_count(exp_len, base_len, input)?;
        // mul * iter_count bounded by 2^189 (so no overflow)
        let gas = mul * iter_count.max(U256::one()) / U256::from(3);

        Ok(EthGas::new(core::cmp::max(200, saturating_round(gas))))
    }

    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let output = Self::run_inner(input)?;
        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

fn parse_bytes<T, F: FnOnce(&[u8]) -> T>(input: &[u8], start: usize, size: usize, f: F) -> T {
    let len = input.len();
    if start >= len {
        return f(&[]);
    }
    let end = start + size;
    if end > len {
        // Pad on the right with zeros if input is too short
        let bytes: Vec<u8> = input[start..]
            .iter()
            .copied()
            .chain(core::iter::repeat(0u8))
            .take(size)
            .collect();
        f(&bytes)
    } else {
        f(&input[start..end])
    }
}

fn saturating_round(x: U256) -> u64 {
    if x.bits() > 64 {
        u64::MAX
    } else {
        x.as_u64()
    }
}

fn parse_lengths(input: &[u8]) -> (u64, u64, u64) {
    let parse = |start: usize| -> u64 {
        // I don't understand why I need a closure here, but doesn't compile without one
        #[allow(clippy::redundant_closure)]
        saturating_round(parse_bytes(input, start, 32, |x| U256::from(x)))
    };
    let base_len = parse(0);
    let exp_len = parse(32);
    let mod_len = parse(64);

    (base_len, exp_len, mod_len)
}

#[cfg(test)]
mod tests {
    use crate::utils::new_context;

    use super::*;
    use crate::prelude::types::u256_to_arr;

    // Byzantium tests: https://github.com/holiman/go-ethereum/blob/master/core/vm/testdata/precompiles/modexp.json
    // Berlin tests:https://github.com/holiman/go-ethereum/blob/master/core/vm/testdata/precompiles/modexp_eip2565.json

    struct Test {
        input: &'static str,
        expected: &'static str,
        name: &'static str,
    }

    const TESTS: [Test; 18] = [
        Test {
            input: "\
            0000000000000000000000000000000000000000000000000000000000000001\
            0000000000000000000000000000000000000000000000000000000000000020\
            0000000000000000000000000000000000000000000000000000000000000020\
            03\
            fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e\
            ffffffffffffffffffffffffffffffffffffffffff2f",
            expected: "162ead82cadefaeaf6e9283248fdf2f2845f6396f6f17c4d5a39f820b6f6b5f9",
            name: "eth_tests_create2callPrecompiles_test0_berlin",
        },
        Test {
            input: "\
            0000000000000000000000000000000000000000000000000000000000000001\
            0000000000000000000000000000000000000000000000000000000000000020\
            0000000000000000000000000000000000000000000000000000000000000020\
            03\
            fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e\
            fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
            expected: "0000000000000000000000000000000000000000000000000000000000000001",
            name: "eip198_example_1",
        },
        Test {
            input: "\
            0000000000000000000000000000000000000000000000000000000000000000\
            0000000000000000000000000000000000000000000000000000000000000020\
            0000000000000000000000000000000000000000000000000000000000000020\
            fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2e\
            fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f",
            expected: "0000000000000000000000000000000000000000000000000000000000000000",
            name: "eip198_example_2",
        },
        Test {
            input: "\
            0000000000000000000000000000000000000000000000000000000000000040\
            0000000000000000000000000000000000000000000000000000000000000001\
            0000000000000000000000000000000000000000000000000000000000000040\
            e09ad9675465c53a109fac66a445c91b292d2bb2c5268addb30cd82f80fcb003\
            3ff97c80a5fc6f39193ae969c6ede6710a6b7ac27078a06d90ef1c72e5c85fb5\
            02fc9e1f6beb81516545975218075ec2af118cd8798df6e08a147c60fd6095ac\
            2bb02c2908cf4dd7c81f11c289e4bce98f3553768f392a80ce22bf5c4f4a248c\
            6b",
            expected: "60008f1614cc01dcfb6bfb09c625cf90b47d4468db81b5f8b7a39d42f332eab9b2da8f2d95311648a8f243f4bb13cfb3d8f7f2a3c014122ebb3ed41b02783adc",
            name: "nagydani_1_square",
        },
        Test {
            input: "\
            0000000000000000000000000000000000000000000000000000000000000040\
            0000000000000000000000000000000000000000000000000000000000000001\
            0000000000000000000000000000000000000000000000000000000000000040\
            e09ad9675465c53a109fac66a445c91b292d2bb2c5268addb30cd82f80fcb003\
            3ff97c80a5fc6f39193ae969c6ede6710a6b7ac27078a06d90ef1c72e5c85fb5\
            03fc9e1f6beb81516545975218075ec2af118cd8798df6e08a147c60fd6095ac\
            2bb02c2908cf4dd7c81f11c289e4bce98f3553768f392a80ce22bf5c4f4a248c\
            6b",
            expected: "4834a46ba565db27903b1c720c9d593e84e4cbd6ad2e64b31885d944f68cd801f92225a8961c952ddf2797fa4701b330c85c4b363798100b921a1a22a46a7fec",
            name: "nagydani_1_qube"
        },
        Test {
            input: "\
            0000000000000000000000000000000000000000000000000000000000000040\
            0000000000000000000000000000000000000000000000000000000000000003\
            0000000000000000000000000000000000000000000000000000000000000040\
            e09ad9675465c53a109fac66a445c91b292d2bb2c5268addb30cd82f80fcb003\
            3ff97c80a5fc6f39193ae969c6ede6710a6b7ac27078a06d90ef1c72e5c85fb5\
            010001fc9e1f6beb81516545975218075ec2af118cd8798df6e08a147c60fd60\
            95ac2bb02c2908cf4dd7c81f11c289e4bce98f3553768f392a80ce22bf5c4f4a\
            248c6b",
            expected: "c36d804180c35d4426b57b50c5bfcca5c01856d104564cd513b461d3c8b8409128a5573e416d0ebe38f5f736766d9dc27143e4da981dfa4d67f7dc474cbee6d2",
            name: "nagydani_1_pow0x10001",
        },
        Test {
            input: "\
            0000000000000000000000000000000000000000000000000000000000000080\
            0000000000000000000000000000000000000000000000000000000000000001\
            0000000000000000000000000000000000000000000000000000000000000080\
            cad7d991a00047dd54d3399b6b0b937c718abddef7917c75b6681f40cc15e2be\
            0003657d8d4c34167b2f0bbbca0ccaa407c2a6a07d50f1517a8f22979ce12a81\
            dcaf707cc0cebfc0ce2ee84ee7f77c38b9281b9822a8d3de62784c089c9b18dc\
            b9a2a5eecbede90ea788a862a9ddd9d609c2c52972d63e289e28f6a590ffbf51\
            02e6d893b80aeed5e6e9ce9afa8a5d5675c93a32ac05554cb20e9951b2c140e3\
            ef4e433068cf0fb73bc9f33af1853f64aa27a0028cbf570d7ac9048eae5dc7b2\
            8c87c31e5810f1e7fa2cda6adf9f1076dbc1ec1238560071e7efc4e9565c49be\
            9e7656951985860a558a754594115830bcdb421f741408346dd5997bb01c2870\
            87",
            expected: "981dd99c3b113fae3e3eaa9435c0dc96779a23c12a53d1084b4f67b0b053a27560f627b873e3f16ad78f28c94f14b6392def26e4d8896c5e3c984e50fa0b3aa44f1da78b913187c6128baa9340b1e9c9a0fd02cb78885e72576da4a8f7e5a113e173a7a2889fde9d407bd9f06eb05bc8fc7b4229377a32941a02bf4edcc06d70",
            name: "nagydani_2_square",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000080cad7d991a00047dd54d3399b6b0b937c718abddef7917c75b6681f40cc15e2be0003657d8d4c34167b2f0bbbca0ccaa407c2a6a07d50f1517a8f22979ce12a81dcaf707cc0cebfc0ce2ee84ee7f77c38b9281b9822a8d3de62784c089c9b18dcb9a2a5eecbede90ea788a862a9ddd9d609c2c52972d63e289e28f6a590ffbf5103e6d893b80aeed5e6e9ce9afa8a5d5675c93a32ac05554cb20e9951b2c140e3ef4e433068cf0fb73bc9f33af1853f64aa27a0028cbf570d7ac9048eae5dc7b28c87c31e5810f1e7fa2cda6adf9f1076dbc1ec1238560071e7efc4e9565c49be9e7656951985860a558a754594115830bcdb421f741408346dd5997bb01c287087",
            expected: "d89ceb68c32da4f6364978d62aaa40d7b09b59ec61eb3c0159c87ec3a91037f7dc6967594e530a69d049b64adfa39c8fa208ea970cfe4b7bcd359d345744405afe1cbf761647e32b3184c7fbe87cee8c6c7ff3b378faba6c68b83b6889cb40f1603ee68c56b4c03d48c595c826c041112dc941878f8c5be828154afd4a16311f",
            name: "nagydani_2_qube",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000080cad7d991a00047dd54d3399b6b0b937c718abddef7917c75b6681f40cc15e2be0003657d8d4c34167b2f0bbbca0ccaa407c2a6a07d50f1517a8f22979ce12a81dcaf707cc0cebfc0ce2ee84ee7f77c38b9281b9822a8d3de62784c089c9b18dcb9a2a5eecbede90ea788a862a9ddd9d609c2c52972d63e289e28f6a590ffbf51010001e6d893b80aeed5e6e9ce9afa8a5d5675c93a32ac05554cb20e9951b2c140e3ef4e433068cf0fb73bc9f33af1853f64aa27a0028cbf570d7ac9048eae5dc7b28c87c31e5810f1e7fa2cda6adf9f1076dbc1ec1238560071e7efc4e9565c49be9e7656951985860a558a754594115830bcdb421f741408346dd5997bb01c287087",
            expected: "ad85e8ef13fd1dd46eae44af8b91ad1ccae5b7a1c92944f92a19f21b0b658139e0cabe9c1f679507c2de354bf2c91ebd965d1e633978a830d517d2f6f8dd5fd58065d58559de7e2334a878f8ec6992d9b9e77430d4764e863d77c0f87beede8f2f7f2ab2e7222f85cc9d98b8467f4bb72e87ef2882423ebdb6daf02dddac6db2",
            name: "nagydani_2_pow0x10001",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000100c9130579f243e12451760976261416413742bd7c91d39ae087f46794062b8c239f2a74abf3918605a0e046a7890e049475ba7fbb78f5de6490bd22a710cc04d30088179a919d86c2da62cf37f59d8f258d2310d94c24891be2d7eeafaa32a8cb4b0cfe5f475ed778f45907dc8916a73f03635f233f7a77a00a3ec9ca6761a5bbd558a2318ecd0caa1c5016691523e7e1fa267dd35e70c66e84380bdcf7c0582f540174e572c41f81e93da0b757dff0b0fe23eb03aa19af0bdec3afb474216febaacb8d0381e631802683182b0fe72c28392539850650b70509f54980241dc175191a35d967288b532a7a8223ce2440d010615f70df269501944d4ec16fe4a3cb02d7a85909174757835187cb52e71934e6c07ef43b4c46fc30bbcd0bc72913068267c54a4aabebb493922492820babdeb7dc9b1558fcf7bd82c37c82d3147e455b623ab0efa752fe0b3a67ca6e4d126639e645a0bf417568adbb2a6a4eef62fa1fa29b2a5a43bebea1f82193a7dd98eb483d09bb595af1fa9c97c7f41f5649d976aee3e5e59e2329b43b13bea228d4a93f16ba139ccb511de521ffe747aa2eca664f7c9e33da59075cc335afcd2bf3ae09765f01ab5a7c3e3938ec168b74724b5074247d200d9970382f683d6059b94dbc336603d1dfee714e4b447ac2fa1d99ecb4961da2854e03795ed758220312d101e1e3d87d5313a6d052aebde75110363d",
            expected: "affc7507ea6d84751ec6b3f0d7b99dbcc263f33330e450d1b3ff0bc3d0874320bf4edd57debd587306988157958cb3cfd369cc0c9c198706f635c9e0f15d047df5cb44d03e2727f26b083c4ad8485080e1293f171c1ed52aef5993a5815c35108e848c951cf1e334490b4a539a139e57b68f44fee583306f5b85ffa57206b3ee5660458858534e5386b9584af3c7f67806e84c189d695e5eb96e1272d06ec2df5dc5fabc6e94b793718c60c36be0a4d031fc84cd658aa72294b2e16fc240aef70cb9e591248e38bd49c5a554d1afa01f38dab72733092f7555334bbef6c8c430119840492380aa95fa025dcf699f0a39669d812b0c6946b6091e6e235337b6f8",
            name: "nagydani_3_square",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000100c9130579f243e12451760976261416413742bd7c91d39ae087f46794062b8c239f2a74abf3918605a0e046a7890e049475ba7fbb78f5de6490bd22a710cc04d30088179a919d86c2da62cf37f59d8f258d2310d94c24891be2d7eeafaa32a8cb4b0cfe5f475ed778f45907dc8916a73f03635f233f7a77a00a3ec9ca6761a5bbd558a2318ecd0caa1c5016691523e7e1fa267dd35e70c66e84380bdcf7c0582f540174e572c41f81e93da0b757dff0b0fe23eb03aa19af0bdec3afb474216febaacb8d0381e631802683182b0fe72c28392539850650b70509f54980241dc175191a35d967288b532a7a8223ce2440d010615f70df269501944d4ec16fe4a3cb03d7a85909174757835187cb52e71934e6c07ef43b4c46fc30bbcd0bc72913068267c54a4aabebb493922492820babdeb7dc9b1558fcf7bd82c37c82d3147e455b623ab0efa752fe0b3a67ca6e4d126639e645a0bf417568adbb2a6a4eef62fa1fa29b2a5a43bebea1f82193a7dd98eb483d09bb595af1fa9c97c7f41f5649d976aee3e5e59e2329b43b13bea228d4a93f16ba139ccb511de521ffe747aa2eca664f7c9e33da59075cc335afcd2bf3ae09765f01ab5a7c3e3938ec168b74724b5074247d200d9970382f683d6059b94dbc336603d1dfee714e4b447ac2fa1d99ecb4961da2854e03795ed758220312d101e1e3d87d5313a6d052aebde75110363d",
            expected: "1b280ecd6a6bf906b806d527c2a831e23b238f89da48449003a88ac3ac7150d6a5e9e6b3be4054c7da11dd1e470ec29a606f5115801b5bf53bc1900271d7c3ff3cd5ed790d1c219a9800437a689f2388ba1a11d68f6a8e5b74e9a3b1fac6ee85fc6afbac599f93c391f5dc82a759e3c6c0ab45ce3f5d25d9b0c1bf94cf701ea6466fc9a478dacc5754e593172b5111eeba88557048bceae401337cd4c1182ad9f700852bc8c99933a193f0b94cf1aedbefc48be3bc93ef5cb276d7c2d5462ac8bb0c8fe8923a1db2afe1c6b90d59c534994a6a633f0ead1d638fdc293486bb634ff2c8ec9e7297c04241a61c37e3ae95b11d53343d4ba2b4cc33d2cfa7eb705e",
            name: "nagydani_3_qube",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000100c9130579f243e12451760976261416413742bd7c91d39ae087f46794062b8c239f2a74abf3918605a0e046a7890e049475ba7fbb78f5de6490bd22a710cc04d30088179a919d86c2da62cf37f59d8f258d2310d94c24891be2d7eeafaa32a8cb4b0cfe5f475ed778f45907dc8916a73f03635f233f7a77a00a3ec9ca6761a5bbd558a2318ecd0caa1c5016691523e7e1fa267dd35e70c66e84380bdcf7c0582f540174e572c41f81e93da0b757dff0b0fe23eb03aa19af0bdec3afb474216febaacb8d0381e631802683182b0fe72c28392539850650b70509f54980241dc175191a35d967288b532a7a8223ce2440d010615f70df269501944d4ec16fe4a3cb010001d7a85909174757835187cb52e71934e6c07ef43b4c46fc30bbcd0bc72913068267c54a4aabebb493922492820babdeb7dc9b1558fcf7bd82c37c82d3147e455b623ab0efa752fe0b3a67ca6e4d126639e645a0bf417568adbb2a6a4eef62fa1fa29b2a5a43bebea1f82193a7dd98eb483d09bb595af1fa9c97c7f41f5649d976aee3e5e59e2329b43b13bea228d4a93f16ba139ccb511de521ffe747aa2eca664f7c9e33da59075cc335afcd2bf3ae09765f01ab5a7c3e3938ec168b74724b5074247d200d9970382f683d6059b94dbc336603d1dfee714e4b447ac2fa1d99ecb4961da2854e03795ed758220312d101e1e3d87d5313a6d052aebde75110363d",
            expected: "37843d7c67920b5f177372fa56e2a09117df585f81df8b300fba245b1175f488c99476019857198ed459ed8d9799c377330e49f4180c4bf8e8f66240c64f65ede93d601f957b95b83efdee1e1bfde74169ff77002eaf078c71815a9220c80b2e3b3ff22c2f358111d816ebf83c2999026b6de50bfc711ff68705d2f40b753424aefc9f70f08d908b5a20276ad613b4ab4309a3ea72f0c17ea9df6b3367d44fb3acab11c333909e02e81ea2ed404a712d3ea96bba87461720e2d98723e7acd0520ac1a5212dbedcd8dc0c1abf61d4719e319ff4758a774790b8d463cdfe131d1b2dcfee52d002694e98e720cb6ae7ccea353bc503269ba35f0f63bf8d7b672a76",
            name: "nagydani_3_pow0x10001",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000200db34d0e438249c0ed685c949cc28776a05094e1c48691dc3f2dca5fc3356d2a0663bd376e4712839917eb9a19c670407e2c377a2de385a3ff3b52104f7f1f4e0c7bf7717fb913896693dc5edbb65b760ef1b00e42e9d8f9af17352385e1cd742c9b006c0f669995cb0bb21d28c0aced2892267637b6470d8cee0ab27fc5d42658f6e88240c31d6774aa60a7ebd25cd48b56d0da11209f1928e61005c6eb709f3e8e0aaf8d9b10f7d7e296d772264dc76897ccdddadc91efa91c1903b7232a9e4c3b941917b99a3bc0c26497dedc897c25750af60237aa67934a26a2bc491db3dcc677491944bc1f51d3e5d76b8d846a62db03dedd61ff508f91a56d71028125035c3a44cbb041497c83bf3e4ae2a9613a401cc721c547a2afa3b16a2969933d3626ed6d8a7428648f74122fd3f2a02a20758f7f693892c8fd798b39abac01d18506c45e71432639e9f9505719ee822f62ccbf47f6850f096ff77b5afaf4be7d772025791717dbe5abf9b3f40cff7d7aab6f67e38f62faf510747276e20a42127e7500c444f9ed92baf65ade9e836845e39c4316d9dce5f8e2c8083e2c0acbb95296e05e51aab13b6b8f53f06c9c4276e12b0671133218cc3ea907da3bd9a367096d9202128d14846cc2e20d56fc8473ecb07cecbfb8086919f3971926e7045b853d85a69d026195c70f9f7a823536e2a8f4b3e12e94d9b53a934353451094b8102df3143a0057457d75e8c708b6337a6f5a4fd1a06727acf9fb93e2993c62f3378b37d56c85e7b1e00f0145ebf8e4095bd723166293c60b6ac1252291ef65823c9e040ddad14969b3b340a4ef714db093a587c37766d68b8d6b5016e741587e7e6bf7e763b44f0247e64bae30f994d248bfd20541a333e5b225ef6a61199e301738b1e688f70ec1d7fb892c183c95dc543c3e12adf8a5e8b9ca9d04f9445cced3ab256f29e998e69efaa633a7b60e1db5a867924ccab0a171d9d6e1098dfa15acde9553de599eaa56490c8f411e4985111f3d40bddfc5e301edb01547b01a886550a61158f7e2033c59707789bf7c854181d0c2e2a42a93cf09209747d7082e147eb8544de25c3eb14f2e35559ea0c0f5877f2f3fc92132c0ae9da4e45b2f6c866a224ea6d1f28c05320e287750fbc647368d41116e528014cc1852e5531d53e4af938374daba6cee4baa821ed07117253bb3601ddd00d59a3d7fb2ef1f5a2fbba7c429f0cf9a5b3462410fd833a69118f8be9c559b1000cc608fd877fb43f8e65c2d1302622b944462579056874b387208d90623fcdaf93920ca7a9e4ba64ea208758222ad868501cc2c345e2d3a5ea2a17e5069248138c8a79c0251185d29ee73e5afab5354769142d2bf0cb6712727aa6bf84a6245fcdae66e4938d84d1b9dd09a884818622080ff5f98942fb20acd7e0c916c2d5ea7ce6f7e173315384518f",
            expected: "8a5aea5f50dcc03dc7a7a272b5aeebc040554dbc1ffe36753c4fc75f7ed5f6c2cc0de3a922bf96c78bf0643a73025ad21f45a4a5cadd717612c511ab2bff1190fe5f1ae05ba9f8fe3624de1de2a817da6072ddcdb933b50216811dbe6a9ca79d3a3c6b3a476b079fd0d05f04fb154e2dd3e5cb83b148a006f2bcbf0042efb2ae7b916ea81b27aac25c3bf9a8b6d35440062ad8eae34a83f3ffa2cc7b40346b62174a4422584f72f95316f6b2bee9ff232ba9739301c97c99a9ded26c45d72676eb856ad6ecc81d36a6de36d7f9dafafee11baa43a4b0d5e4ecffa7b9b7dcefd58c397dd373e6db4acd2b2c02717712e6289bed7c813b670c4a0c6735aa7f3b0f1ce556eae9fcc94b501b2c8781ba50a8c6220e8246371c3c7359fe4ef9da786ca7d98256754ca4e496be0a9174bedbecb384bdf470779186d6a833f068d2838a88d90ef3ad48ff963b67c39cc5a3ee123baf7bf3125f64e77af7f30e105d72c4b9b5b237ed251e4c122c6d8c1405e736299c3afd6db16a28c6a9cfa68241e53de4cd388271fe534a6a9b0dbea6171d170db1b89858468885d08fecbd54c8e471c3e25d48e97ba450b96d0d87e00ac732aaa0d3ce4309c1064bd8a4c0808a97e0143e43a24cfa847635125cd41c13e0574487963e9d725c01375db99c31da67b4cf65eff555f0c0ac416c727ff8d438ad7c42030551d68c2e7adda0abb1ca7c10",
            name: "nagydani_4_square",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000200db34d0e438249c0ed685c949cc28776a05094e1c48691dc3f2dca5fc3356d2a0663bd376e4712839917eb9a19c670407e2c377a2de385a3ff3b52104f7f1f4e0c7bf7717fb913896693dc5edbb65b760ef1b00e42e9d8f9af17352385e1cd742c9b006c0f669995cb0bb21d28c0aced2892267637b6470d8cee0ab27fc5d42658f6e88240c31d6774aa60a7ebd25cd48b56d0da11209f1928e61005c6eb709f3e8e0aaf8d9b10f7d7e296d772264dc76897ccdddadc91efa91c1903b7232a9e4c3b941917b99a3bc0c26497dedc897c25750af60237aa67934a26a2bc491db3dcc677491944bc1f51d3e5d76b8d846a62db03dedd61ff508f91a56d71028125035c3a44cbb041497c83bf3e4ae2a9613a401cc721c547a2afa3b16a2969933d3626ed6d8a7428648f74122fd3f2a02a20758f7f693892c8fd798b39abac01d18506c45e71432639e9f9505719ee822f62ccbf47f6850f096ff77b5afaf4be7d772025791717dbe5abf9b3f40cff7d7aab6f67e38f62faf510747276e20a42127e7500c444f9ed92baf65ade9e836845e39c4316d9dce5f8e2c8083e2c0acbb95296e05e51aab13b6b8f53f06c9c4276e12b0671133218cc3ea907da3bd9a367096d9202128d14846cc2e20d56fc8473ecb07cecbfb8086919f3971926e7045b853d85a69d026195c70f9f7a823536e2a8f4b3e12e94d9b53a934353451094b8103df3143a0057457d75e8c708b6337a6f5a4fd1a06727acf9fb93e2993c62f3378b37d56c85e7b1e00f0145ebf8e4095bd723166293c60b6ac1252291ef65823c9e040ddad14969b3b340a4ef714db093a587c37766d68b8d6b5016e741587e7e6bf7e763b44f0247e64bae30f994d248bfd20541a333e5b225ef6a61199e301738b1e688f70ec1d7fb892c183c95dc543c3e12adf8a5e8b9ca9d04f9445cced3ab256f29e998e69efaa633a7b60e1db5a867924ccab0a171d9d6e1098dfa15acde9553de599eaa56490c8f411e4985111f3d40bddfc5e301edb01547b01a886550a61158f7e2033c59707789bf7c854181d0c2e2a42a93cf09209747d7082e147eb8544de25c3eb14f2e35559ea0c0f5877f2f3fc92132c0ae9da4e45b2f6c866a224ea6d1f28c05320e287750fbc647368d41116e528014cc1852e5531d53e4af938374daba6cee4baa821ed07117253bb3601ddd00d59a3d7fb2ef1f5a2fbba7c429f0cf9a5b3462410fd833a69118f8be9c559b1000cc608fd877fb43f8e65c2d1302622b944462579056874b387208d90623fcdaf93920ca7a9e4ba64ea208758222ad868501cc2c345e2d3a5ea2a17e5069248138c8a79c0251185d29ee73e5afab5354769142d2bf0cb6712727aa6bf84a6245fcdae66e4938d84d1b9dd09a884818622080ff5f98942fb20acd7e0c916c2d5ea7ce6f7e173315384518f",
            expected: "5a2664252aba2d6e19d9600da582cdd1f09d7a890ac48e6b8da15ae7c6ff1856fc67a841ac2314d283ffa3ca81a0ecf7c27d89ef91a5a893297928f5da0245c99645676b481b7e20a566ee6a4f2481942bee191deec5544600bb2441fd0fb19e2ee7d801ad8911c6b7750affec367a4b29a22942c0f5f4744a4e77a8b654da2a82571037099e9c6d930794efe5cdca73c7b6c0844e386bdca8ea01b3d7807146bb81365e2cdc6475f8c23e0ff84463126189dc9789f72bbce2e3d2d114d728a272f1345122de23df54c922ec7a16e5c2a8f84da8871482bd258c20a7c09bbcd64c7a96a51029bbfe848736a6ba7bf9d931a9b7de0bcaf3635034d4958b20ae9ab3a95a147b0421dd5f7ebff46c971010ebfc4adbbe0ad94d5498c853e7142c450d8c71de4b2f84edbf8acd2e16d00c8115b150b1c30e553dbb82635e781379fe2a56360420ff7e9f70cc64c00aba7e26ed13c7c19622865ae07248daced36416080f35f8cc157a857ed70ea4f347f17d1bee80fa038abd6e39b1ba06b97264388b21364f7c56e192d4b62d9b161405f32ab1e2594e86243e56fcf2cb30d21adef15b9940f91af681da24328c883d892670c6aa47940867a81830a82b82716895db810df1b834640abefb7db2092dd92912cb9a735175bc447be40a503cf22dfe565b4ed7a3293ca0dfd63a507430b323ee248ec82e843b673c97ad730728cebc",
            name: "nagydani_4_qube",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000200db34d0e438249c0ed685c949cc28776a05094e1c48691dc3f2dca5fc3356d2a0663bd376e4712839917eb9a19c670407e2c377a2de385a3ff3b52104f7f1f4e0c7bf7717fb913896693dc5edbb65b760ef1b00e42e9d8f9af17352385e1cd742c9b006c0f669995cb0bb21d28c0aced2892267637b6470d8cee0ab27fc5d42658f6e88240c31d6774aa60a7ebd25cd48b56d0da11209f1928e61005c6eb709f3e8e0aaf8d9b10f7d7e296d772264dc76897ccdddadc91efa91c1903b7232a9e4c3b941917b99a3bc0c26497dedc897c25750af60237aa67934a26a2bc491db3dcc677491944bc1f51d3e5d76b8d846a62db03dedd61ff508f91a56d71028125035c3a44cbb041497c83bf3e4ae2a9613a401cc721c547a2afa3b16a2969933d3626ed6d8a7428648f74122fd3f2a02a20758f7f693892c8fd798b39abac01d18506c45e71432639e9f9505719ee822f62ccbf47f6850f096ff77b5afaf4be7d772025791717dbe5abf9b3f40cff7d7aab6f67e38f62faf510747276e20a42127e7500c444f9ed92baf65ade9e836845e39c4316d9dce5f8e2c8083e2c0acbb95296e05e51aab13b6b8f53f06c9c4276e12b0671133218cc3ea907da3bd9a367096d9202128d14846cc2e20d56fc8473ecb07cecbfb8086919f3971926e7045b853d85a69d026195c70f9f7a823536e2a8f4b3e12e94d9b53a934353451094b81010001df3143a0057457d75e8c708b6337a6f5a4fd1a06727acf9fb93e2993c62f3378b37d56c85e7b1e00f0145ebf8e4095bd723166293c60b6ac1252291ef65823c9e040ddad14969b3b340a4ef714db093a587c37766d68b8d6b5016e741587e7e6bf7e763b44f0247e64bae30f994d248bfd20541a333e5b225ef6a61199e301738b1e688f70ec1d7fb892c183c95dc543c3e12adf8a5e8b9ca9d04f9445cced3ab256f29e998e69efaa633a7b60e1db5a867924ccab0a171d9d6e1098dfa15acde9553de599eaa56490c8f411e4985111f3d40bddfc5e301edb01547b01a886550a61158f7e2033c59707789bf7c854181d0c2e2a42a93cf09209747d7082e147eb8544de25c3eb14f2e35559ea0c0f5877f2f3fc92132c0ae9da4e45b2f6c866a224ea6d1f28c05320e287750fbc647368d41116e528014cc1852e5531d53e4af938374daba6cee4baa821ed07117253bb3601ddd00d59a3d7fb2ef1f5a2fbba7c429f0cf9a5b3462410fd833a69118f8be9c559b1000cc608fd877fb43f8e65c2d1302622b944462579056874b387208d90623fcdaf93920ca7a9e4ba64ea208758222ad868501cc2c345e2d3a5ea2a17e5069248138c8a79c0251185d29ee73e5afab5354769142d2bf0cb6712727aa6bf84a6245fcdae66e4938d84d1b9dd09a884818622080ff5f98942fb20acd7e0c916c2d5ea7ce6f7e173315384518f",
            expected: "bed8b970c4a34849fc6926b08e40e20b21c15ed68d18f228904878d4370b56322d0da5789da0318768a374758e6375bfe4641fca5285ec7171828922160f48f5ca7efbfee4d5148612c38ad683ae4e3c3a053d2b7c098cf2b34f2cb19146eadd53c86b2d7ccf3d83b2c370bfb840913ee3879b1057a6b4e07e110b6bcd5e958bc71a14798c91d518cc70abee264b0d25a4110962a764b364ac0b0dd1ee8abc8426d775ec0f22b7e47b32576afaf1b5a48f64573ed1c5c29f50ab412188d9685307323d990802b81dacc06c6e05a1e901830ba9fcc67688dc29c5e27bde0a6e845ca925f5454b6fb3747edfaa2a5820838fb759eadf57f7cb5cec57fc213ddd8a4298fa079c3c0f472b07fb15aa6a7f0a3780bd296ff6a62e58ef443870b02260bd4fd2bbc98255674b8e1f1f9f8d33c7170b0ebbea4523b695911abbf26e41885344823bd0587115fdd83b721a4e8457a31c9a84b3d3520a07e0e35df7f48e5a9d534d0ec7feef1ff74de6a11e7f93eab95175b6ce22c68d78a642ad642837897ec11349205d8593ac19300207572c38d29ca5dfa03bc14cdbc32153c80e5cc3e739403d34c75915e49beb43094cc6dcafb3665b305ddec9286934ae66ec6b777ca528728c851318eb0f207b39f1caaf96db6eeead6b55ed08f451939314577d42bcc9f97c0b52d0234f88fd07e4c1d7780fdebc025cfffcb572cb27a8c33963",
            name: "nagydani_4_pow0x10001",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000400c5a1611f8be90071a43db23cc2fe01871cc4c0e8ab5743f6378e4fef77f7f6db0095c0727e20225beb665645403453e325ad5f9aeb9ba99bf3c148f63f9c07cf4fe8847ad5242d6b7d4499f93bd47056ddab8f7dee878fc2314f344dbee2a7c41a5d3db91eff372c730c2fdd3a141a4b61999e36d549b9870cf2f4e632c4d5df5f024f81c028000073a0ed8847cfb0593d36a47142f578f05ccbe28c0c06aeb1b1da027794c48db880278f79ba78ae64eedfea3c07d10e0562668d839749dc95f40467d15cf65b9cfc52c7c4bcef1cda3596dd52631aac942f146c7cebd46065131699ce8385b0db1874336747ee020a5698a3d1a1082665721e769567f579830f9d259cec1a836845109c21cf6b25da572512bf3c42fd4b96e43895589042ab60dd41f497db96aec102087fe784165bb45f942859268fd2ff6c012d9d00c02ba83eace047cc5f7b2c392c2955c58a49f0338d6fc58749c9db2155522ac17914ec216ad87f12e0ee95574613942fa615898c4d9e8a3be68cd6afa4e7a003dedbdf8edfee31162b174f965b20ae752ad89c967b3068b6f722c16b354456ba8e280f987c08e0a52d40a2e8f3a59b94d590aeef01879eb7a90b3ee7d772c839c85519cbeaddc0c193ec4874a463b53fcaea3271d80ebfb39b33489365fc039ae549a17a9ff898eea2f4cb27b8dbee4c17b998438575b2b8d107e4a0d66ba7fca85b41a58a8d51f191a35c856dfbe8aef2b00048a694bbccff832d23c8ca7a7ff0b6c0b3011d00b97c86c0628444d267c951d9e4fb8f83e154b8f74fb51aa16535e498235c5597dac9606ed0be3173a3836baa4e7d756ffe1e2879b415d3846bccd538c05b847785699aefde3e305decb600cd8fb0e7d8de5efc26971a6ad4e6d7a2d91474f1023a0ac4b78dc937da0ce607a45974d2cac1c33a2631ff7fe6144a3b2e5cf98b531a9627dea92c1dc82204d09db0439b6a11dd64b484e1263aa45fd9539b6020b55e3baece3986a8bffc1003406348f5c61265099ed43a766ee4f93f5f9c5abbc32a0fd3ac2b35b87f9ec26037d88275bd7dd0a54474995ee34ed3727f3f97c48db544b1980193a4b76a8a3ddab3591ce527f16d91882e67f0103b5cda53f7da54d489fc4ac08b6ab358a5a04aa9daa16219d50bd672a7cb804ed769d218807544e5993f1c27427104b349906a0b654df0bf69328afd3013fbe430155339c39f236df5557bf92f1ded7ff609a8502f49064ec3d1dbfb6c15d3a4c11a4f8acd12278cbf68acd5709463d12e3338a6eddb8c112f199645e23154a8e60879d2a654e3ed9296aa28f134168619691cd2c6b9e2eba4438381676173fc63c2588a3c5910dc149cf3760f0aa9fa9c3f5faa9162b0bf1aac9dd32b706a60ef53cbdb394b6b40222b5bc80eea82ba8958386672564cae3794f977871ab62337cf02e30049201ec12937e7ce79d0f55d9c810e20acf52212aca1d3888949e0e4830aad88d804161230eb89d4d329cc83570fe257217d2119134048dd2ed167646975fc7d77136919a049ea74cf08ddd2b896890bb24a0ba18094a22baa351bf29ad96c66bbb1a598f2ca391749620e62d61c3561a7d3653ccc8892c7b99baaf76bf836e2991cb06d6bc0514568ff0d1ec8bb4b3d6984f5eaefb17d3ea2893722375d3ddb8e389a8eef7d7d198f8e687d6a513983df906099f9a2d23f4f9dec6f8ef2f11fc0a21fac45353b94e00486f5e17d386af42502d09db33cf0cf28310e049c07e88682aeeb00cb833c5174266e62407a57583f1f88b304b7c6e0c84bbe1c0fd423072d37a5bd0aacf764229e5c7cd02473460ba3645cd8e8ae144065bf02d0dd238593d8e230354f67e0b2f23012c23274f80e3ee31e35e2606a4a3f31d94ab755e6d163cff52cbb36b6d0cc67ffc512aeed1dce4d7a0d70ce82f2baba12e8d514dc92a056f994adfb17b5b9712bd5186f27a2fda1f7039c5df2c8587fdc62f5627580c13234b55be4df3056050e2d1ef3218f0dd66cb05265fe1acfb0989d8213f2c19d1735a7cf3fa65d88dad5af52dc2bba22b7abf46c3bc77b5091baab9e8f0ddc4d5e581037de91a9f8dcbc69309be29cc815cf19a20a7585b8b3073edf51fc9baeb3e509b97fa4ecfd621e0fd57bd61cac1b895c03248ff12bdbc57509250df3517e8a3fe1d776836b34ab352b973d932ef708b14f7418f9eceb1d87667e61e3e758649cb083f01b133d37ab2f5afa96d6c84bcacf4efc3851ad308c1e7d9113624fce29fab460ab9d2a48d92cdb281103a5250ad44cb2ff6e67ac670c02fdafb3e0f1353953d6d7d5646ca1568dea55275a050ec501b7c6250444f7219f1ba7521ba3b93d089727ca5f3bbe0d6c1300b423377004954c5628fdb65770b18ced5c9b23a4a5a6d6ef25fe01b4ce278de0bcc4ed86e28a0a68818ffa40970128cf2c38740e80037984428c1bd5113f40ff47512ee6f4e4d8f9b8e8e1b3040d2928d003bd1c1329dc885302fbce9fa81c23b4dc49c7c82d29b52957847898676c89aa5d32b5b0e1c0d5a2b79a19d67562f407f19425687971a957375879d90c5f57c857136c17106c9ab1b99d80e69c8c954ed386493368884b55c939b8d64d26f643e800c56f90c01079d7c534e3b2b7ae352cefd3016da55f6a85eb803b85e2304915fd2001f77c74e28746293c46e4f5f0fd49cf988aafd0026b8e7a3bab2da5cdce1ea26c2e29ec03f4807fac432662b2d6c060be1c7be0e5489de69d0a6e03a4b9117f9244b34a0f1ecba89884f781c6320412413a00c4980287409a2a78c2cd7e65cecebbe4ec1c28cac4dd95f6998e78fc6f1392384331c9436aa10e10e2bf8ad2c4eafbcf276aa7bae64b74428911b3269c749338b0fc5075ad",
            expected: "d61fe4e3f32ac260915b5b03b78a86d11bfc41d973fce5b0cc59035cf8289a8a2e3878ea15fa46565b0d806e2f85b53873ea20ed653869b688adf83f3ef444535bf91598ff7e80f334fb782539b92f39f55310cc4b35349ab7b278346eda9bc37c0d8acd3557fae38197f412f8d9e57ce6a76b7205c23564cab06e5615be7c6f05c3d05ec690cba91da5e89d55b152ff8dd2157dc5458190025cf94b1ad98f7cbe64e9482faba95e6b33844afc640892872b44a9932096508f4a782a4805323808f23e54b6ff9b841dbfa87db3505ae4f687972c18ea0f0d0af89d36c1c2a5b14560c153c3fee406f5cf15cfd1c0bb45d767426d465f2f14c158495069d0c5955a00150707862ecaae30624ebacdd8ac33e4e6aab3ff90b6ba445a84689386b9e945d01823a65874444316e83767290fcff630d2477f49d5d8ffdd200e08ee1274270f86ed14c687895f6caf5ce528bd970c20d2408a9ba66216324c6a011ac4999098362dbd98a038129a2d40c8da6ab88318aa3046cb660327cc44236d9e5d2163bd0959062195c51ed93d0088b6f92051fc99050ece2538749165976233697ab4b610385366e5ce0b02ad6b61c168ecfbedcdf74278a38de340fd7a5fead8e588e294795f9b011e2e60377a89e25c90e145397cdeabc60fd32444a6b7642a611a83c464d8b8976666351b4865c37b02e6dc21dbcdf5f930341707b618cc0f03c3122646b3385c9df9f2ec730eec9d49e7dfc9153b6e6289da8c4f0ebea9ccc1b751948e3bb7171c9e4d57423b0eeeb79095c030cb52677b3f7e0b45c30f645391f3f9c957afa549c4e0b2465b03c67993cd200b1af01035962edbc4c9e89b31c82ac121987d6529dafdeef67a132dc04b6dc68e77f22862040b75e2ceb9ff16da0fca534e6db7bd12fa7b7f51b6c08c1e23dfcdb7acbd2da0b51c87ffbced065a612e9b1c8bba9b7e2d8d7a2f04fcc4aaf355b60d764879a76b5e16762d5f2f55d585d0c8e82df6940960cddfb72c91dfa71f6b4e1c6ca25dfc39a878e998a663c04fe29d5e83b9586d047b4d7ff70a9f0d44f127e7d741685ca75f11629128d916a0ffef4be586a30c4b70389cc746e84ebf177c01ee8a4511cfbb9d1ecf7f7b33c7dd8177896e10bbc82f838dcd6db7ac67de62bf46b6a640fb580c5d1d2708f3862e3d2b645d0d18e49ef088053e3a220adc0e033c2afcfe61c90e32151152eb3caaf746c5e377d541cafc6cbb0cc0fa48b5caf1728f2e1957f5addfc234f1a9d89e40d49356c9172d0561a695fce6dab1d412321bbf407f63766ffd7b6b3d79bcfa07991c5a9709849c1008689e3b47c50d613980bec239fb64185249d055b30375ccb4354d71fe4d05648fbf6c80634dfc3575f2f24abb714c1e4c95e8896763bf4316e954c7ad19e5780ab7a040ca6fb9271f90a8b22ae738daf6cb",
            name: "nagydani_5_square",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000400c5a1611f8be90071a43db23cc2fe01871cc4c0e8ab5743f6378e4fef77f7f6db0095c0727e20225beb665645403453e325ad5f9aeb9ba99bf3c148f63f9c07cf4fe8847ad5242d6b7d4499f93bd47056ddab8f7dee878fc2314f344dbee2a7c41a5d3db91eff372c730c2fdd3a141a4b61999e36d549b9870cf2f4e632c4d5df5f024f81c028000073a0ed8847cfb0593d36a47142f578f05ccbe28c0c06aeb1b1da027794c48db880278f79ba78ae64eedfea3c07d10e0562668d839749dc95f40467d15cf65b9cfc52c7c4bcef1cda3596dd52631aac942f146c7cebd46065131699ce8385b0db1874336747ee020a5698a3d1a1082665721e769567f579830f9d259cec1a836845109c21cf6b25da572512bf3c42fd4b96e43895589042ab60dd41f497db96aec102087fe784165bb45f942859268fd2ff6c012d9d00c02ba83eace047cc5f7b2c392c2955c58a49f0338d6fc58749c9db2155522ac17914ec216ad87f12e0ee95574613942fa615898c4d9e8a3be68cd6afa4e7a003dedbdf8edfee31162b174f965b20ae752ad89c967b3068b6f722c16b354456ba8e280f987c08e0a52d40a2e8f3a59b94d590aeef01879eb7a90b3ee7d772c839c85519cbeaddc0c193ec4874a463b53fcaea3271d80ebfb39b33489365fc039ae549a17a9ff898eea2f4cb27b8dbee4c17b998438575b2b8d107e4a0d66ba7fca85b41a58a8d51f191a35c856dfbe8aef2b00048a694bbccff832d23c8ca7a7ff0b6c0b3011d00b97c86c0628444d267c951d9e4fb8f83e154b8f74fb51aa16535e498235c5597dac9606ed0be3173a3836baa4e7d756ffe1e2879b415d3846bccd538c05b847785699aefde3e305decb600cd8fb0e7d8de5efc26971a6ad4e6d7a2d91474f1023a0ac4b78dc937da0ce607a45974d2cac1c33a2631ff7fe6144a3b2e5cf98b531a9627dea92c1dc82204d09db0439b6a11dd64b484e1263aa45fd9539b6020b55e3baece3986a8bffc1003406348f5c61265099ed43a766ee4f93f5f9c5abbc32a0fd3ac2b35b87f9ec26037d88275bd7dd0a54474995ee34ed3727f3f97c48db544b1980193a4b76a8a3ddab3591ce527f16d91882e67f0103b5cda53f7da54d489fc4ac08b6ab358a5a04aa9daa16219d50bd672a7cb804ed769d218807544e5993f1c27427104b349906a0b654df0bf69328afd3013fbe430155339c39f236df5557bf92f1ded7ff609a8502f49064ec3d1dbfb6c15d3a4c11a4f8acd12278cbf68acd5709463d12e3338a6eddb8c112f199645e23154a8e60879d2a654e3ed9296aa28f134168619691cd2c6b9e2eba4438381676173fc63c2588a3c5910dc149cf3760f0aa9fa9c3f5faa9162b0bf1aac9dd32b706a60ef53cbdb394b6b40222b5bc80eea82ba8958386672564cae3794f977871ab62337cf03e30049201ec12937e7ce79d0f55d9c810e20acf52212aca1d3888949e0e4830aad88d804161230eb89d4d329cc83570fe257217d2119134048dd2ed167646975fc7d77136919a049ea74cf08ddd2b896890bb24a0ba18094a22baa351bf29ad96c66bbb1a598f2ca391749620e62d61c3561a7d3653ccc8892c7b99baaf76bf836e2991cb06d6bc0514568ff0d1ec8bb4b3d6984f5eaefb17d3ea2893722375d3ddb8e389a8eef7d7d198f8e687d6a513983df906099f9a2d23f4f9dec6f8ef2f11fc0a21fac45353b94e00486f5e17d386af42502d09db33cf0cf28310e049c07e88682aeeb00cb833c5174266e62407a57583f1f88b304b7c6e0c84bbe1c0fd423072d37a5bd0aacf764229e5c7cd02473460ba3645cd8e8ae144065bf02d0dd238593d8e230354f67e0b2f23012c23274f80e3ee31e35e2606a4a3f31d94ab755e6d163cff52cbb36b6d0cc67ffc512aeed1dce4d7a0d70ce82f2baba12e8d514dc92a056f994adfb17b5b9712bd5186f27a2fda1f7039c5df2c8587fdc62f5627580c13234b55be4df3056050e2d1ef3218f0dd66cb05265fe1acfb0989d8213f2c19d1735a7cf3fa65d88dad5af52dc2bba22b7abf46c3bc77b5091baab9e8f0ddc4d5e581037de91a9f8dcbc69309be29cc815cf19a20a7585b8b3073edf51fc9baeb3e509b97fa4ecfd621e0fd57bd61cac1b895c03248ff12bdbc57509250df3517e8a3fe1d776836b34ab352b973d932ef708b14f7418f9eceb1d87667e61e3e758649cb083f01b133d37ab2f5afa96d6c84bcacf4efc3851ad308c1e7d9113624fce29fab460ab9d2a48d92cdb281103a5250ad44cb2ff6e67ac670c02fdafb3e0f1353953d6d7d5646ca1568dea55275a050ec501b7c6250444f7219f1ba7521ba3b93d089727ca5f3bbe0d6c1300b423377004954c5628fdb65770b18ced5c9b23a4a5a6d6ef25fe01b4ce278de0bcc4ed86e28a0a68818ffa40970128cf2c38740e80037984428c1bd5113f40ff47512ee6f4e4d8f9b8e8e1b3040d2928d003bd1c1329dc885302fbce9fa81c23b4dc49c7c82d29b52957847898676c89aa5d32b5b0e1c0d5a2b79a19d67562f407f19425687971a957375879d90c5f57c857136c17106c9ab1b99d80e69c8c954ed386493368884b55c939b8d64d26f643e800c56f90c01079d7c534e3b2b7ae352cefd3016da55f6a85eb803b85e2304915fd2001f77c74e28746293c46e4f5f0fd49cf988aafd0026b8e7a3bab2da5cdce1ea26c2e29ec03f4807fac432662b2d6c060be1c7be0e5489de69d0a6e03a4b9117f9244b34a0f1ecba89884f781c6320412413a00c4980287409a2a78c2cd7e65cecebbe4ec1c28cac4dd95f6998e78fc6f1392384331c9436aa10e10e2bf8ad2c4eafbcf276aa7bae64b74428911b3269c749338b0fc5075ad",
            expected: "5f9c70ec884926a89461056ad20ac4c30155e817f807e4d3f5bb743d789c83386762435c3627773fa77da5144451f2a8aad8adba88e0b669f5377c5e9bad70e45c86fe952b613f015a9953b8a5de5eaee4566acf98d41e327d93a35bd5cef4607d025e58951167957df4ff9b1627649d3943805472e5e293d3efb687cfd1e503faafeb2840a3e3b3f85d016051a58e1c9498aab72e63b748d834b31eb05d85dcde65e27834e266b85c75cc4ec0135135e0601cb93eeeb6e0010c8ceb65c4c319623c5e573a2c8c9fbbf7df68a930beb412d3f4dfd146175484f45d7afaa0d2e60684af9b34730f7c8438465ad3e1d0c3237336722f2aa51095bd5759f4b8ab4dda111b684aa3dac62a761722e7ae43495b7709933512c81c4e3c9133a51f7ce9f2b51fcec064f65779666960b4e45df3900f54311f5613e8012dd1b8efd359eda31a778264c72aa8bb419d862734d769076bce2810011989a45374e5c5d8729fec21427f0bf397eacbb4220f603cf463a4b0c94efd858ffd9768cd60d6ce68d755e0fbad007ce5c2223d70c7018345a102e4ab3c60a13a9e7794303156d4c2063e919f2153c13961fb324c80b240742f47773a7a8e25b3e3fb19b00ce839346c6eb3c732fbc6b888df0b1fe0a3d07b053a2e9402c267b2d62f794d8a2840526e3ade15ce2264496ccd7519571dfde47f7a4bb16292241c20b2be59f3f8fb4f6383f232d838c5a22d8c95b6834d9d2ca493f5a505ebe8899503b0e8f9b19e6e2dd81c1628b80016d02097e0134de51054c4e7674824d4d758760fc52377d2cad145e259aa2ffaf54139e1a66b1e0c1c191e32ac59474c6b526f5b3ba07d3e5ec286eddf531fcd5292869be58c9f22ef91026159f7cf9d05ef66b4299f4da48cc1635bf2243051d342d378a22c83390553e873713c0454ce5f3234397111ac3fe3207b86f0ed9fc025c81903e1748103692074f83824fda6341be4f95ff00b0a9a208c267e12fa01825054cc0513629bf3dbb56dc5b90d4316f87654a8be18227978ea0a8a522760cad620d0d14fd38920fb7321314062914275a5f99f677145a6979b156bd82ecd36f23f8e1273cc2759ecc0b2c69d94dad5211d1bed939dd87ed9e07b91d49713a6e16ade0a98aea789f04994e318e4ff2c8a188cd8d43aeb52c6daa3bc29b4af50ea82a247c5cd67b573b34cbadcc0a376d3bbd530d50367b42705d870f2e27a8197ef46070528bfe408360faa2ebb8bf76e9f388572842bcb119f4d84ee34ae31f5cc594f23705a49197b181fb78ed1ec99499c690f843a4d0cf2e226d118e9372271054fbabdcc5c92ae9fefaef0589cd0e722eaf30c1703ec4289c7fd81beaa8a455ccee5298e31e2080c10c366a6fcf56f7d13582ad0bcad037c612b710fc595b70fbefaaca23623b60c6c39b11beb8e5843b6b3dac60f",
            name: "nagydani_5_qube",
        },
        Test {
            input: "000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000400c5a1611f8be90071a43db23cc2fe01871cc4c0e8ab5743f6378e4fef77f7f6db0095c0727e20225beb665645403453e325ad5f9aeb9ba99bf3c148f63f9c07cf4fe8847ad5242d6b7d4499f93bd47056ddab8f7dee878fc2314f344dbee2a7c41a5d3db91eff372c730c2fdd3a141a4b61999e36d549b9870cf2f4e632c4d5df5f024f81c028000073a0ed8847cfb0593d36a47142f578f05ccbe28c0c06aeb1b1da027794c48db880278f79ba78ae64eedfea3c07d10e0562668d839749dc95f40467d15cf65b9cfc52c7c4bcef1cda3596dd52631aac942f146c7cebd46065131699ce8385b0db1874336747ee020a5698a3d1a1082665721e769567f579830f9d259cec1a836845109c21cf6b25da572512bf3c42fd4b96e43895589042ab60dd41f497db96aec102087fe784165bb45f942859268fd2ff6c012d9d00c02ba83eace047cc5f7b2c392c2955c58a49f0338d6fc58749c9db2155522ac17914ec216ad87f12e0ee95574613942fa615898c4d9e8a3be68cd6afa4e7a003dedbdf8edfee31162b174f965b20ae752ad89c967b3068b6f722c16b354456ba8e280f987c08e0a52d40a2e8f3a59b94d590aeef01879eb7a90b3ee7d772c839c85519cbeaddc0c193ec4874a463b53fcaea3271d80ebfb39b33489365fc039ae549a17a9ff898eea2f4cb27b8dbee4c17b998438575b2b8d107e4a0d66ba7fca85b41a58a8d51f191a35c856dfbe8aef2b00048a694bbccff832d23c8ca7a7ff0b6c0b3011d00b97c86c0628444d267c951d9e4fb8f83e154b8f74fb51aa16535e498235c5597dac9606ed0be3173a3836baa4e7d756ffe1e2879b415d3846bccd538c05b847785699aefde3e305decb600cd8fb0e7d8de5efc26971a6ad4e6d7a2d91474f1023a0ac4b78dc937da0ce607a45974d2cac1c33a2631ff7fe6144a3b2e5cf98b531a9627dea92c1dc82204d09db0439b6a11dd64b484e1263aa45fd9539b6020b55e3baece3986a8bffc1003406348f5c61265099ed43a766ee4f93f5f9c5abbc32a0fd3ac2b35b87f9ec26037d88275bd7dd0a54474995ee34ed3727f3f97c48db544b1980193a4b76a8a3ddab3591ce527f16d91882e67f0103b5cda53f7da54d489fc4ac08b6ab358a5a04aa9daa16219d50bd672a7cb804ed769d218807544e5993f1c27427104b349906a0b654df0bf69328afd3013fbe430155339c39f236df5557bf92f1ded7ff609a8502f49064ec3d1dbfb6c15d3a4c11a4f8acd12278cbf68acd5709463d12e3338a6eddb8c112f199645e23154a8e60879d2a654e3ed9296aa28f134168619691cd2c6b9e2eba4438381676173fc63c2588a3c5910dc149cf3760f0aa9fa9c3f5faa9162b0bf1aac9dd32b706a60ef53cbdb394b6b40222b5bc80eea82ba8958386672564cae3794f977871ab62337cf010001e30049201ec12937e7ce79d0f55d9c810e20acf52212aca1d3888949e0e4830aad88d804161230eb89d4d329cc83570fe257217d2119134048dd2ed167646975fc7d77136919a049ea74cf08ddd2b896890bb24a0ba18094a22baa351bf29ad96c66bbb1a598f2ca391749620e62d61c3561a7d3653ccc8892c7b99baaf76bf836e2991cb06d6bc0514568ff0d1ec8bb4b3d6984f5eaefb17d3ea2893722375d3ddb8e389a8eef7d7d198f8e687d6a513983df906099f9a2d23f4f9dec6f8ef2f11fc0a21fac45353b94e00486f5e17d386af42502d09db33cf0cf28310e049c07e88682aeeb00cb833c5174266e62407a57583f1f88b304b7c6e0c84bbe1c0fd423072d37a5bd0aacf764229e5c7cd02473460ba3645cd8e8ae144065bf02d0dd238593d8e230354f67e0b2f23012c23274f80e3ee31e35e2606a4a3f31d94ab755e6d163cff52cbb36b6d0cc67ffc512aeed1dce4d7a0d70ce82f2baba12e8d514dc92a056f994adfb17b5b9712bd5186f27a2fda1f7039c5df2c8587fdc62f5627580c13234b55be4df3056050e2d1ef3218f0dd66cb05265fe1acfb0989d8213f2c19d1735a7cf3fa65d88dad5af52dc2bba22b7abf46c3bc77b5091baab9e8f0ddc4d5e581037de91a9f8dcbc69309be29cc815cf19a20a7585b8b3073edf51fc9baeb3e509b97fa4ecfd621e0fd57bd61cac1b895c03248ff12bdbc57509250df3517e8a3fe1d776836b34ab352b973d932ef708b14f7418f9eceb1d87667e61e3e758649cb083f01b133d37ab2f5afa96d6c84bcacf4efc3851ad308c1e7d9113624fce29fab460ab9d2a48d92cdb281103a5250ad44cb2ff6e67ac670c02fdafb3e0f1353953d6d7d5646ca1568dea55275a050ec501b7c6250444f7219f1ba7521ba3b93d089727ca5f3bbe0d6c1300b423377004954c5628fdb65770b18ced5c9b23a4a5a6d6ef25fe01b4ce278de0bcc4ed86e28a0a68818ffa40970128cf2c38740e80037984428c1bd5113f40ff47512ee6f4e4d8f9b8e8e1b3040d2928d003bd1c1329dc885302fbce9fa81c23b4dc49c7c82d29b52957847898676c89aa5d32b5b0e1c0d5a2b79a19d67562f407f19425687971a957375879d90c5f57c857136c17106c9ab1b99d80e69c8c954ed386493368884b55c939b8d64d26f643e800c56f90c01079d7c534e3b2b7ae352cefd3016da55f6a85eb803b85e2304915fd2001f77c74e28746293c46e4f5f0fd49cf988aafd0026b8e7a3bab2da5cdce1ea26c2e29ec03f4807fac432662b2d6c060be1c7be0e5489de69d0a6e03a4b9117f9244b34a0f1ecba89884f781c6320412413a00c4980287409a2a78c2cd7e65cecebbe4ec1c28cac4dd95f6998e78fc6f1392384331c9436aa10e10e2bf8ad2c4eafbcf276aa7bae64b74428911b3269c749338b0fc5075ad",
            expected: "5a0eb2bdf0ac1cae8e586689fa16cd4b07dfdedaec8a110ea1fdb059dd5253231b6132987598dfc6e11f86780428982d50cf68f67ae452622c3b336b537ef3298ca645e8f89ee39a26758206a5a3f6409afc709582f95274b57b71fae5c6b74619ae6f089a5393c5b79235d9caf699d23d88fb873f78379690ad8405e34c19f5257d596580c7a6a7206a3712825afe630c76b31cdb4a23e7f0632e10f14f4e282c81a66451a26f8df2a352b5b9f607a7198449d1b926e27036810368e691a74b91c61afa73d9d3b99453e7c8b50fd4f09c039a2f2feb5c419206694c31b92df1d9586140cb3417b38d0c503c7b508cc2ed12e813a1c795e9829eb39ee78eeaf360a169b491a1d4e419574e712402de9d48d54c1ae5e03739b7156615e8267e1fb0a897f067afd11fb33f6e24182d7aaaaa18fe5bc1982f20d6b871e5a398f0f6f718181d31ec225cfa9a0a70124ed9a70031bdf0c1c7829f708b6e17d50419ef361cf77d99c85f44607186c8d683106b8bd38a49b5d0fb503b397a83388c5678dcfcc737499d84512690701ed621a6f0172aecf037184ddf0f2453e4053024018e5ab2e30d6d5363b56e8b41509317c99042f517247474ab3abc848e00a07f69c254f46f2a05cf6ed84e5cc906a518fdcfdf2c61ce731f24c5264f1a25fc04934dc28aec112134dd523f70115074ca34e3807aa4cb925147f3a0ce152d323bd8c675ace446d0fd1ae30c4b57f0eb2c23884bc18f0964c0114796c5b6d080c3d89175665fbf63a6381a6a9da39ad070b645c8bb1779506da14439a9f5b5d481954764ea114fac688930bc68534d403cff4210673b6a6ff7ae416b7cd41404c3d3f282fcd193b86d0f54d0006c2a503b40d5c3930da980565b8f9630e9493a79d1c03e74e5f93ac8e4dc1a901ec5e3b3e57049124c7b72ea345aa359e782285d9e6a5c144a378111dd02c40855ff9c2be9b48425cb0b2fd62dc8678fd151121cf26a65e917d65d8e0dacfae108eb5508b601fb8ffa370be1f9a8b749a2d12eeab81f41079de87e2d777994fa4d28188c579ad327f9957fb7bdecec5c680844dd43cb57cf87aeb763c003e65011f73f8c63442df39a92b946a6bd968a1c1e4d5fa7d88476a68bd8e20e5b70a99259c7d3f85fb1b65cd2e93972e6264e74ebf289b8b6979b9b68a85cd5b360c1987f87235c3c845d62489e33acf85d53fa3561fe3a3aee18924588d9c6eba4edb7a4d106b31173e42929f6f0c48c80ce6a72d54eca7c0fe870068b7a7c89c63cdda593f5b32d3cb4ea8a32c39f00ab449155757172d66763ed9527019d6de6c9f2416aa6203f4d11c9ebee1e1d3845099e55504446448027212616167eb36035726daa7698b075286f5379cd3e93cb3e0cf4f9cb8d017facbb5550ed32d5ec5400ae57e47e2bf78d1eaeff9480cc765ceff39db500",
            name: "nagydani_5_pow0x10001",
        }
    ];

    const BYZANTIUM_GAS: [EthGas; 18] = [
        EthGas::new(13_056),
        EthGas::new(13_056),
        EthGas::new(13_056),
        EthGas::new(204),
        EthGas::new(204),
        EthGas::new(3_276),
        EthGas::new(665),
        EthGas::new(665),
        EthGas::new(10_649),
        EthGas::new(1_894),
        EthGas::new(1_894),
        EthGas::new(30_310),
        EthGas::new(5_580),
        EthGas::new(5_580),
        EthGas::new(89_292),
        EthGas::new(17_868),
        EthGas::new(17_868),
        EthGas::new(285_900),
    ];

    const BERLIN_GAS: [EthGas; 18] = [
        EthGas::new(1_360),
        EthGas::new(1_360),
        EthGas::new(1_360),
        EthGas::new(200),
        EthGas::new(200),
        EthGas::new(341),
        EthGas::new(200),
        EthGas::new(200),
        EthGas::new(1_365),
        EthGas::new(341),
        EthGas::new(341),
        EthGas::new(5_461),
        EthGas::new(1_365),
        EthGas::new(1_365),
        EthGas::new(21_845),
        EthGas::new(5_461),
        EthGas::new(5_461),
        EthGas::new(87_381),
    ];

    #[test]
    fn test_modexp() {
        for (test, test_gas) in TESTS.iter().zip(BYZANTIUM_GAS.iter()) {
            let input = hex::decode(test.input).unwrap();

            let res = ModExp::<Byzantium>::new()
                .run(&input, Some(*test_gas), &new_context(), false)
                .unwrap()
                .output;
            let expected = hex::decode(test.expected).unwrap();
            assert_eq!(res, expected, "{}", test.name);
        }
    }

    #[test]
    fn test_byzantium_modexp_gas() {
        for (test, test_gas) in TESTS.iter().zip(BYZANTIUM_GAS.iter()) {
            let input = hex::decode(test.input).unwrap();

            let gas = ModExp::<Byzantium>::required_gas(&input).unwrap();
            assert_eq!(gas, *test_gas, "{} gas", test.name);
        }
    }

    #[test]
    fn test_berlin_modexp_gas() {
        for (test, test_gas) in TESTS.iter().zip(BERLIN_GAS.iter()) {
            let input = hex::decode(test.input).unwrap();

            let gas = ModExp::<Berlin>::required_gas(&input).unwrap();
            assert_eq!(gas, *test_gas, "{} gas", test.name);
        }
    }

    #[test]
    fn test_berlin_modexp_big_input() {
        let base_len = U256::from(4);
        let exp_len = U256::from(u64::MAX);
        let mod_len = U256::from(4);
        let base: u32 = 1;
        let exp = U256::MAX;

        let mut input: Vec<u8> = Vec::new();
        input.extend_from_slice(&u256_to_arr(&base_len));
        input.extend_from_slice(&u256_to_arr(&exp_len));
        input.extend_from_slice(&u256_to_arr(&mod_len));
        input.extend_from_slice(&base.to_be_bytes());
        input.extend_from_slice(&u256_to_arr(&exp));

        // completes without any overflow
        ModExp::<Berlin>::required_gas(&input).unwrap();
    }

    #[test]
    fn test_berlin_modexp_bigger_input() {
        let base_len = U256::MAX;
        let exp_len = U256::MAX;
        let mod_len = U256::MAX;
        let base: u32 = 1;
        let exp = U256::MAX;

        let mut input: Vec<u8> = Vec::new();
        input.extend_from_slice(&u256_to_arr(&base_len));
        input.extend_from_slice(&u256_to_arr(&exp_len));
        input.extend_from_slice(&u256_to_arr(&mod_len));
        input.extend_from_slice(&base.to_be_bytes());
        input.extend_from_slice(&u256_to_arr(&exp));

        // completes without any overflow
        ModExp::<Berlin>::required_gas(&input).unwrap();
    }

    #[test]
    fn test_berlin_modexp_empty_input() {
        let res = ModExp::<Berlin>::new()
            .run(&[], Some(EthGas::new(100_000)), &new_context(), false)
            .unwrap();
        let expected: Vec<u8> = Vec::new();
        assert_eq!(res.output, expected)
    }

    #[test]
    fn test_modexp_gas_revert() {
        let input = "000000000000090000000000000000";
        // Gas cost comes out to 18446744073709551615
        let res = ModExp::<Berlin>::new().run(
            &hex::decode(input).unwrap(),
            Some(EthGas::new(100_000)),
            &new_context(),
            false,
        );
        assert_eq!(Err(ExitError::OutOfGas), res);
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/native.rs ---
use super::{EvmPrecompileResult, Precompile};
use crate::prelude::{
    format,
    parameters::{PromiseArgs, PromiseCreateArgs, WithdrawCallArgs},
    sdk::io::{StorageIntermediate, IO},
    storage::{bytes_to_key, KeyPrefix},
    types::{Address, Yocto},
    vec, BorshSerialize, Cow, String, ToString, Vec, U256,
};
#[cfg(feature = "error_refund")]
use crate::prelude::{
    parameters::{PromiseWithCallbackArgs, RefundCallArgs},
    types,
};

use crate::prelude::types::EthGas;
use crate::PrecompileOutput;
use aurora_engine_types::account_id::AccountId;
use evm::backend::Log;
use evm::{Context, ExitError};

const ERR_TARGET_TOKEN_NOT_FOUND: &str = "Target token not found";

mod costs {
    use crate::prelude::types::{EthGas, NearGas};

    // TODO(#483): Determine the correct amount of gas
    pub(super) const EXIT_TO_NEAR_GAS: EthGas = EthGas::new(0);

    // TODO(#483): Determine the correct amount of gas
    pub(super) const EXIT_TO_ETHEREUM_GAS: EthGas = EthGas::new(0);

    /// Value determined experimentally based on tests and mainnet data. Example:
    /// https://explorer.mainnet.near.org/transactions/5CD7NrqWpK3H8MAAU4mYEPuuWz9AqR9uJkkZJzw5b8PM#D1b5NVRrAsJKUX2ZGs3poKViu1Rgt4RJZXtTfMgdxH4S
    pub(super) const FT_TRANSFER_GAS: NearGas = NearGas::new(10_000_000_000_000);

    /// Value determined experimentally based on tests.
    /// (No mainnet data available since this feature is not enabled)
    #[cfg(feature = "error_refund")]
    pub(super) const REFUND_ON_ERROR_GAS: NearGas = NearGas::new(5_000_000_000_000);

    // TODO(#332): Determine the correct amount of gas
    pub(super) const WITHDRAWAL_GAS: NearGas = NearGas::new(100_000_000_000_000);
}

pub mod events {
    use crate::prelude::{types::Address, vec, String, ToString, H160, H256, U256};

    /// Derived from event signature (see tests::test_exit_signatures)
    pub const EXIT_TO_NEAR_SIGNATURE: H256 = crate::make_h256(
        0x5a91b8bc9c1981673db8fb226dbd8fcd,
        0xd0c23f45cd28abb31403a5392f6dd0c7,
    );
    /// Derived from event signature (see tests::test_exit_signatures)
    pub const EXIT_TO_ETH_SIGNATURE: H256 = crate::make_h256(
        0xd046c2bb01a5622bc4b9696332391d87,
        0x491373762eeac0831c48400e2d5a5f07,
    );

    /// The exit precompile events have an `erc20_address` field to indicate
    /// which ERC-20 token is being withdrawn. However, ETH is not an ERC-20 token
    /// So we need to have some other address to fill this field. This constant is
    /// used for this purpose.
    pub const ETH_ADDRESS: Address = Address::new(H160([0; 20]));

    /// ExitToNear(
    ///    Address indexed sender,
    ///    Address indexed erc20_address,
    ///    string indexed dest,
    ///    uint amount
    /// )
    /// Note: in the ERC-20 exit case `sender` == `erc20_address` because it is
    /// the ERC-20 contract which calls the exit precompile. However in the case
    /// of ETH exit the sender will give the true sender (and the `erc20_address`
    /// will not be meaningful because ETH is not an ERC-20 token).
    pub struct ExitToNear {
        pub sender: Address,
        pub erc20_address: Address,
        pub dest: String,
        pub amount: U256,
    }

    impl ExitToNear {
        pub fn encode(self) -> ethabi::RawLog {
            let data = ethabi::encode(&[ethabi::Token::Int(self.amount)]);
            let topics = vec![
                EXIT_TO_NEAR_SIGNATURE,
                encode_address(self.sender),
                encode_address(self.erc20_address),
                aurora_engine_sdk::keccak(&ethabi::encode(&[ethabi::Token::String(self.dest)])),
            ];

            ethabi::RawLog { topics, data }
        }
    }

    /// ExitToEth(
    ///    Address indexed sender,
    ///    Address indexed erc20_address,
    ///    string indexed dest,
    ///    uint amount
    /// )
    /// Note: in the ERC-20 exit case `sender` == `erc20_address` because it is
    /// the ERC-20 contract which calls the exit precompile. However in the case
    /// of ETH exit the sender will give the true sender (and the `erc20_address`
    /// will not be meaningful because ETH is not an ERC-20 token).
    pub struct ExitToEth {
        pub sender: Address,
        pub erc20_address: Address,
        pub dest: Address,
        pub amount: U256,
    }

    impl ExitToEth {
        pub fn encode(self) -> ethabi::RawLog {
            let data = ethabi::encode(&[ethabi::Token::Int(self.amount)]);
            let topics = vec![
                EXIT_TO_ETH_SIGNATURE,
                encode_address(self.sender),
                encode_address(self.erc20_address),
                encode_address(self.dest),
            ];

            ethabi::RawLog { topics, data }
        }
    }

    fn encode_address(a: Address) -> H256 {
        let mut result = [0u8; 32];
        result[12..].copy_from_slice(a.as_bytes());
        H256(result)
    }

    pub fn exit_to_near_schema() -> ethabi::Event {
        ethabi::Event {
            name: "ExitToNear".to_string(),
            inputs: vec![
                ethabi::EventParam {
                    name: "sender".to_string(),
                    kind: ethabi::ParamType::Address,
                    indexed: true,
                },
                ethabi::EventParam {
                    name: "erc20_address".to_string(),
                    kind: ethabi::ParamType::Address,
                    indexed: true,
                },
                ethabi::EventParam {
                    name: "dest".to_string(),
                    kind: ethabi::ParamType::String,
                    indexed: true,
                },
                ethabi::EventParam {
                    name: "amount".to_string(),
                    kind: ethabi::ParamType::Uint(256),
                    indexed: false,
                },
            ],
            anonymous: false,
        }
    }

    pub fn exit_to_eth_schema() -> ethabi::Event {
        ethabi::Event {
            name: "ExitToEth".to_string(),
            inputs: vec![
                ethabi::EventParam {
                    name: "sender".to_string(),
                    kind: ethabi::ParamType::Address,
                    indexed: true,
                },
                ethabi::EventParam {
                    name: "erc20_address".to_string(),
                    kind: ethabi::ParamType::Address,
                    indexed: true,
                },
                ethabi::EventParam {
                    name: "dest".to_string(),
                    kind: ethabi::ParamType::Address,
                    indexed: true,
                },
                ethabi::EventParam {
                    name: "amount".to_string(),
                    kind: ethabi::ParamType::Uint(256),
                    indexed: false,
                },
            ],
            anonymous: false,
        }
    }
}

//TransferEthToNear
pub struct ExitToNear<I> {
    current_account_id: AccountId,
    io: I,
}

pub mod exit_to_near {
    use aurora_engine_types::types::Address;

    /// Exit to NEAR precompile address
    ///
    /// Address: `0xe9217bc70b7ed1f598ddd3199e80b093fa71124f`
    /// This address is computed as: `&keccak("exitToNear")[12..]`
    pub const ADDRESS: Address =
        crate::make_address(0xe9217bc7, 0x0b7ed1f598ddd3199e80b093fa71124f);
}

impl<I> ExitToNear<I> {
    pub fn new(current_account_id: AccountId, io: I) -> Self {
        Self {
            current_account_id,
            io,
        }
    }
}

fn get_nep141_from_erc20<I: IO>(erc20_token: &[u8], io: &I) -> Result<AccountId, ExitError> {
    AccountId::try_from(
        io.read_storage(bytes_to_key(KeyPrefix::Erc20Nep141Map, erc20_token).as_slice())
            .map(|s| s.to_vec())
            .ok_or(ExitError::Other(Cow::Borrowed(ERR_TARGET_TOKEN_NOT_FOUND)))?,
    )
    .map_err(|_| ExitError::Other(Cow::Borrowed("ERR_INVALID_NEP141_ACCOUNT")))
}

impl<I: IO> Precompile for ExitToNear<I> {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::EXIT_TO_NEAR_GAS)
    }

    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        context: &Context,
        is_static: bool,
    ) -> EvmPrecompileResult {
        #[cfg(feature = "error_refund")]
        fn parse_input(input: &[u8]) -> Result<(Address, &[u8]), ExitError> {
            if input.len() < 21 {
                return Err(ExitError::Other(Cow::from("ERR_INVALID_INPUT")));
            }
            let refund_address = Address::try_from_slice(&input[1..21]).unwrap();
            Ok((refund_address, &input[21..]))
        }
        #[cfg(not(feature = "error_refund"))]
        fn parse_input(input: &[u8]) -> &[u8] {
            &input[1..]
        }

        if let Some(target_gas) = target_gas {
            if Self::required_gas(input)? > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        // It's not allowed to call exit precompiles in static mode
        if is_static {
            return Err(ExitError::Other(Cow::from("ERR_INVALID_IN_STATIC")));
        } else if context.address != exit_to_near::ADDRESS.raw() {
            return Err(ExitError::Other(Cow::from("ERR_INVALID_IN_DELEGATE")));
        }

        // First byte of the input is a flag, selecting the behavior to be triggered:
        //      0x0 -> Eth transfer
        //      0x1 -> Erc20 transfer
        let flag = input[0];
        #[cfg(feature = "error_refund")]
        let (refund_address, mut input) = parse_input(input)?;
        #[cfg(not(feature = "error_refund"))]
        let mut input = parse_input(input);
        let current_account_id = self.current_account_id.clone();
        #[cfg(feature = "error_refund")]
        let refund_on_error_target = current_account_id.clone();

        let (nep141_address, args, exit_event) = match flag {
            0x0 => {
                // ETH transfer
                //
                // Input slice format:
                //      recipient_account_id (bytes) - the NEAR recipient account which will receive NEP-141 ETH tokens

                if let Ok(dest_account) = AccountId::try_from(input) {
                    (
                        current_account_id,
                        // There is no way to inject json, given the encoding of both arguments
                        // as decimal and valid account id respectively.
                        format!(
                            r#"{{"receiver_id": "{}", "amount": "{}", "memo": null}}"#,
                            dest_account,
                            context.apparent_value.as_u128()
                        ),
                        events::ExitToNear {
                            sender: Address::new(context.caller),
                            erc20_address: events::ETH_ADDRESS,
                            dest: dest_account.to_string(),
                            amount: context.apparent_value,
                        },
                    )
                } else {
                    return Err(ExitError::Other(Cow::from(
                        "ERR_INVALID_RECEIVER_ACCOUNT_ID",
                    )));
                }
            }
            0x1 => {
                // ERC20 transfer
                //
                // This precompile branch is expected to be called from the ERC20 burn function\
                //
                // Input slice format:
                //      amount (U256 big-endian bytes) - the amount that was burned
                //      recipient_account_id (bytes) - the NEAR recipient account which will receive NEP-141 tokens

                if context.apparent_value != U256::from(0) {
                    return Err(ExitError::Other(Cow::from(
                        "ERR_ETH_ATTACHED_FOR_ERC20_EXIT",
                    )));
                }

                let erc20_address = context.caller;
                let nep141_address = get_nep141_from_erc20(erc20_address.as_bytes(), &self.io)?;

                let amount = U256::from_big_endian(&input[..32]);
                input = &input[32..];

                if let Ok(receiver_account_id) = AccountId::try_from(input) {
                    (
                        nep141_address,
                        // There is no way to inject json, given the encoding of both arguments
                        // as decimal and valid account id respectively.
                        format!(
                            r#"{{"receiver_id": "{}", "amount": "{}", "memo": null}}"#,
                            receiver_account_id,
                            amount.as_u128()
                        ),
                        events::ExitToNear {
                            sender: Address::new(erc20_address),
                            erc20_address: Address::new(erc20_address),
                            dest: receiver_account_id.to_string(),
                            amount,
                        },
                    )
                } else {
                    return Err(ExitError::Other(Cow::from(
                        "ERR_INVALID_RECEIVER_ACCOUNT_ID",
                    )));
                }
            }
            _ => return Err(ExitError::Other(Cow::from("ERR_INVALID_FLAG"))),
        };

        #[cfg(feature = "error_refund")]
        let erc20_address = if flag == 0 {
            None
        } else {
            Some(exit_event.erc20_address)
        };
        #[cfg(feature = "error_refund")]
        let refund_args = RefundCallArgs {
            recipient_address: refund_address,
            erc20_address,
            amount: types::u256_to_arr(&exit_event.amount),
        };
        #[cfg(feature = "error_refund")]
        let refund_promise = PromiseCreateArgs {
            target_account_id: refund_on_error_target,
            method: "refund_on_error".to_string(),
            args: refund_args.try_to_vec().unwrap(),
            attached_balance: Yocto::new(0),
            attached_gas: costs::REFUND_ON_ERROR_GAS,
        };
        let transfer_promise = PromiseCreateArgs {
            target_account_id: nep141_address,
            method: "ft_transfer".to_string(),
            args: args.as_bytes().to_vec(),
            attached_balance: Yocto::new(1),
            attached_gas: costs::FT_TRANSFER_GAS,
        };

        #[cfg(feature = "error_refund")]
        let promise = PromiseArgs::Callback(PromiseWithCallbackArgs {
            base: transfer_promise,
            callback: refund_promise,
        });
        #[cfg(not(feature = "error_refund"))]
        let promise = PromiseArgs::Create(transfer_promise);

        let promise_log = Log {
            address: exit_to_near::ADDRESS.raw(),
            topics: Vec::new(),
            data: promise.try_to_vec().unwrap(),
        };
        let exit_event_log = exit_event.encode();
        let exit_event_log = Log {
            address: exit_to_near::ADDRESS.raw(),
            topics: exit_event_log.topics,
            data: exit_event_log.data,
        };

        Ok(PrecompileOutput {
            logs: vec![promise_log, exit_event_log],
            ..Default::default()
        })
    }
}

pub struct ExitToEthereum<I> {
    current_account_id: AccountId,
    io: I,
}

pub mod exit_to_ethereum {
    use aurora_engine_types::types::Address;

    /// Exit to Ethereum precompile address
    ///
    /// Address: `0xb0bd02f6a392af548bdf1cfaee5dfa0eefcc8eab`
    /// This address is computed as: `&keccak("exitToEthereum")[12..]`
    pub const ADDRESS: Address =
        crate::make_address(0xb0bd02f6, 0xa392af548bdf1cfaee5dfa0eefcc8eab);
}

impl<I> ExitToEthereum<I> {
    pub fn new(current_account_id: AccountId, io: I) -> Self {
        Self {
            current_account_id,
            io,
        }
    }
}

impl<I: IO> Precompile for ExitToEthereum<I> {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::EXIT_TO_ETHEREUM_GAS)
    }

    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        context: &Context,
        is_static: bool,
    ) -> EvmPrecompileResult {
        use crate::prelude::types::NEP141Wei;
        if let Some(target_gas) = target_gas {
            if Self::required_gas(input)? > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        // It's not allowed to call exit precompiles in static mode
        if is_static {
            return Err(ExitError::Other(Cow::from("ERR_INVALID_IN_STATIC")));
        } else if context.address != exit_to_ethereum::ADDRESS.raw() {
            return Err(ExitError::Other(Cow::from("ERR_INVALID_IN_DELEGATE")));
        }

        // First byte of the input is a flag, selecting the behavior to be triggered:
        //      0x0 -> Eth transfer
        //      0x1 -> Erc20 transfer
        let mut input = input;
        let flag = input[0];
        input = &input[1..];

        let (nep141_address, serialized_args, exit_event) = match flag {
            0x0 => {
                // ETH transfer
                //
                // Input slice format:
                //      eth_recipient (20 bytes) - the address of recipient which will receive ETH on Ethereum
                let recipient_address: Address = input
                    .try_into()
                    .map_err(|_| ExitError::Other(Cow::from("ERR_INVALID_RECIPIENT_ADDRESS")))?;
                (
                    self.current_account_id.clone(),
                    // There is no way to inject json, given the encoding of both arguments
                    // as decimal and hexadecimal respectively.
                    WithdrawCallArgs {
                        recipient_address,
                        amount: NEP141Wei::new(context.apparent_value.as_u128()),
                    }
                    .try_to_vec()
                    .map_err(|_| ExitError::Other(Cow::from("ERR_INVALID_AMOUNT")))?,
                    events::ExitToEth {
                        sender: Address::new(context.caller),
                        erc20_address: events::ETH_ADDRESS,
                        dest: recipient_address,
                        amount: context.apparent_value,
                    },
                )
            }
            0x1 => {
                // ERC-20 transfer
                //
                // This precompile branch is expected to be called from the ERC20 withdraw function
                // (or burn function with some flag provided that this is expected to be withdrawn)
                //
                // Input slice format:
                //      amount (U256 big-endian bytes) - the amount that was burned
                //      eth_recipient (20 bytes) - the address of recipient which will receive ETH on Ethereum

                if context.apparent_value != U256::from(0) {
                    return Err(ExitError::Other(Cow::from(
                        "ERR_ETH_ATTACHED_FOR_ERC20_EXIT",
                    )));
                }

                let erc20_address = context.caller;
                let nep141_address = get_nep141_from_erc20(erc20_address.as_bytes(), &self.io)?;

                let amount = U256::from_big_endian(&input[..32]);
                input = &input[32..];

                if input.len() == 20 {
                    // Parse ethereum address in hex
                    let eth_recipient: String = hex::encode(input);
                    // unwrap cannot fail since we checked the length already
                    let recipient_address = Address::try_from_slice(input).map_err(|_| {
                        ExitError::Other(crate::prelude::Cow::from("ERR_WRONG_ADDRESS"))
                    })?;

                    (
                        nep141_address,
                        // There is no way to inject json, given the encoding of both arguments
                        // as decimal and hexadecimal respectively.
                        format!(
                            r#"{{"amount": "{}", "recipient": "{}"}}"#,
                            amount.as_u128(),
                            eth_recipient
                        )
                        .into_bytes(),
                        events::ExitToEth {
                            sender: Address::new(erc20_address),
                            erc20_address: Address::new(erc20_address),
                            dest: recipient_address,
                            amount,
                        },
                    )
                } else {
                    return Err(ExitError::Other(Cow::from("ERR_INVALID_RECIPIENT_ADDRESS")));
                }
            }
            _ => {
                return Err(ExitError::Other(Cow::from(
                    "ERR_INVALID_RECEIVER_ACCOUNT_ID",
                )));
            }
        };

        let withdraw_promise = PromiseCreateArgs {
            target_account_id: nep141_address,
            method: "withdraw".to_string(),
            args: serialized_args,
            attached_balance: Yocto::new(1),
            attached_gas: costs::WITHDRAWAL_GAS,
        };

        let promise = PromiseArgs::Create(withdraw_promise).try_to_vec().unwrap();
        let promise_log = Log {
            address: exit_to_ethereum::ADDRESS.raw(),
            topics: Vec::new(),
            data: promise,
        };
        let exit_event_log = exit_event.encode();
        let exit_event_log = Log {
            address: exit_to_ethereum::ADDRESS.raw(),
            topics: exit_event_log.topics,
            data: exit_event_log.data,
        };

        Ok(PrecompileOutput {
            logs: vec![promise_log, exit_event_log],
            ..Default::default()
        })
    }
}

#[cfg(test)]
mod tests {
    use super::{exit_to_ethereum, exit_to_near};
    use crate::prelude::sdk::types::near_account_to_evm_address;

    #[test]
    fn test_precompile_id() {
        assert_eq!(
            exit_to_ethereum::ADDRESS,
            near_account_to_evm_address("exitToEthereum".as_bytes())
        );
        assert_eq!(
            exit_to_near::ADDRESS,
            near_account_to_evm_address("exitToNear".as_bytes())
        );
    }

    #[test]
    fn test_exit_signatures() {
        let exit_to_near = super::events::exit_to_near_schema();
        let exit_to_eth = super::events::exit_to_eth_schema();

        assert_eq!(
            exit_to_near.signature(),
            super::events::EXIT_TO_NEAR_SIGNATURE
        );
        assert_eq!(
            exit_to_eth.signature(),
            super::events::EXIT_TO_ETH_SIGNATURE
        );
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/prelude.rs ---
pub use aurora_engine_sdk as sdk;
pub use aurora_engine_types::account_id::*;
pub use aurora_engine_types::parameters;
pub use aurora_engine_types::storage;
pub use aurora_engine_types::types;
pub use aurora_engine_types::*;

pub use borsh::{BorshDeserialize, BorshSerialize};

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/prepaid_gas.rs ---
use super::{EvmPrecompileResult, Precompile};
use crate::prelude::types::{Address, EthGas};
use crate::PrecompileOutput;
use aurora_engine_sdk::env::Env;
use aurora_engine_types::{vec, U256};
use evm::{Context, ExitError};

/// prepaid_gas precompile address
///
/// Address: `0x536822d27de53629ef1f84c60555689e9488609f`
/// This address is computed as: `&keccak("prepaidGas")[12..]`
pub const ADDRESS: Address = crate::make_address(0x536822d2, 0x7de53629ef1f84c60555689e9488609f);

mod costs {
    use crate::prelude::types::EthGas;

    // TODO(#483): Determine the correct amount of gas
    pub(super) const PREPAID_GAS_COST: EthGas = EthGas::new(0);
}

pub struct PrepaidGas<'a, E> {
    env: &'a E,
}

impl<'a, E> PrepaidGas<'a, E> {
    pub fn new(env: &'a E) -> Self {
        Self { env }
    }
}

impl<'a, E: Env> Precompile for PrepaidGas<'a, E> {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::PREPAID_GAS_COST)
    }

    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let prepaid_gas = self.env.prepaid_gas();
        let bytes = {
            let mut buf = vec![0; 32];
            U256::from(prepaid_gas.as_u64()).to_big_endian(&mut buf);
            buf
        };
        Ok(PrecompileOutput::without_logs(cost, bytes))
    }
}

#[cfg(test)]
mod tests {
    use crate::prelude::sdk::types::near_account_to_evm_address;
    use crate::prepaid_gas;

    #[test]
    fn test_prepaid_gas_precompile_id() {
        assert_eq!(
            prepaid_gas::ADDRESS,
            near_account_to_evm_address("prepaidGas".as_bytes())
        );
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/promise_result.rs ---
use super::{EvmPrecompileResult, Precompile};
use crate::prelude::types::{Address, EthGas};
use crate::PrecompileOutput;
use aurora_engine_sdk::promise::ReadOnlyPromiseHandler;
use aurora_engine_types::{Cow, Vec};
use borsh::BorshSerialize;
use evm::{Context, ExitError};

/// get_promise_results precompile address
///
/// Address: `0x0a3540f79be10ef14890e87c1a0040a68cc6af71`
/// This address is computed as: `&keccak("getPromiseResults")[12..]`
pub const ADDRESS: Address = crate::make_address(0x0a3540f7, 0x9be10ef14890e87c1a0040a68cc6af71);

pub mod costs {
    use crate::prelude::types::EthGas;

    /// This cost is always charged for calling this precompile.
    pub const PROMISE_RESULT_BASE_COST: EthGas = EthGas::new(105);
    /// This is the cost per byte of promise result data.
    pub const PROMISE_RESULT_BYTE_COST: EthGas = EthGas::new(1);
}

pub struct PromiseResult<H> {
    handler: H,
}

impl<H> PromiseResult<H> {
    pub fn new(handler: H) -> Self {
        Self { handler }
    }
}

impl<H: ReadOnlyPromiseHandler> Precompile for PromiseResult<H> {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        // Only gives the cost we can know without reading any promise data.
        // This allows failing fast in the case the base cost cannot even be covered.
        Ok(costs::PROMISE_RESULT_BASE_COST)
    }

    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let mut cost = Self::required_gas(input)?;
        let check_cost = |cost: EthGas| -> Result<(), ExitError> {
            if let Some(target_gas) = target_gas {
                if cost > target_gas {
                    return Err(ExitError::OutOfGas);
                }
            }
            Ok(())
        };
        check_cost(cost)?;

        let num_promises = self.handler.ro_promise_results_count();
        let n_usize = usize::try_from(num_promises).map_err(crate::utils::err_usize_conv)?;
        let mut results = Vec::with_capacity(n_usize);
        for i in 0..num_promises {
            if let Some(result) = self.handler.ro_promise_result(i) {
                let n_bytes = u64::try_from(result.size()).map_err(crate::utils::err_usize_conv)?;
                cost += n_bytes * costs::PROMISE_RESULT_BYTE_COST;
                check_cost(cost)?;
                results.push(result);
            }
        }

        let bytes = results
            .try_to_vec()
            .map_err(|_| ExitError::Other(Cow::Borrowed("ERR_PROMISE_RESULT_SERIALIZATION")))?;
        Ok(PrecompileOutput::without_logs(cost, bytes))
    }
}

#[cfg(test)]
mod tests {
    use crate::prelude::sdk::types::near_account_to_evm_address;
    use crate::promise_result;

    #[test]
    fn test_get_promise_results_precompile_id() {
        assert_eq!(
            promise_result::ADDRESS,
            near_account_to_evm_address("getPromiseResults".as_bytes())
        );
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/random.rs ---
use super::{EvmPrecompileResult, Precompile};
use crate::prelude::types::{Address, EthGas};
use crate::prelude::H256;
use crate::PrecompileOutput;
use evm::{Context, ExitError};

mod costs {
    use crate::prelude::types::EthGas;

    // TODO(#483): Determine the correct amount of gas
    pub(super) const RANDOM_BYTES_GAS: EthGas = EthGas::new(0);
}

pub struct RandomSeed {
    random_seed: H256,
}

impl RandomSeed {
    /// Random bytes precompile address
    /// This is a per-block entropy source which could then be used to create a random sequence.
    /// It will return the same seed if called multiple time in the same block.
    ///
    /// Address: `0xc104f4840573bed437190daf5d2898c2bdf928ac`
    /// This address is computed as: `&keccak("randomSeed")[12..]`
    pub const ADDRESS: Address =
        super::make_address(0xc104f484, 0x0573bed437190daf5d2898c2bdf928ac);

    pub fn new(random_seed: H256) -> Self {
        Self { random_seed }
    }
}

impl Precompile for RandomSeed {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::RANDOM_BYTES_GAS)
    }

    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        Ok(PrecompileOutput::without_logs(
            cost,
            self.random_seed.as_bytes().to_vec(),
        ))
    }
}

#[cfg(test)]
mod tests {
    use crate::prelude::sdk::types::near_account_to_evm_address;
    use crate::random::RandomSeed;

    #[test]
    fn test_precompile_id() {
        assert_eq!(
            RandomSeed::ADDRESS,
            near_account_to_evm_address("randomSeed".as_bytes())
        );
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/secp256k1.rs ---
use crate::prelude::types::{Address, EthGas};
use crate::prelude::{sdk, vec::Vec, Borrowed, H256};
use crate::{EvmPrecompileResult, Precompile, PrecompileOutput};
use evm::{Context, ExitError};

mod costs {
    use crate::prelude::types::EthGas;

    pub(super) const ECRECOVER_BASE: EthGas = EthGas::new(3_000);
}

mod consts {
    pub(super) const INPUT_LEN: usize = 128;
}

/// See: https://ethereum.github.io/yellowpaper/paper.pdf
/// See: https://docs.soliditylang.org/en/develop/units-and-global-variables.html#mathematical-and-cryptographic-functions
/// See: https://etherscan.io/address/0000000000000000000000000000000000000001
// Quite a few library methods rely on this and that should be changed. This
// should only be for precompiles.
pub fn ecrecover(hash: H256, signature: &[u8]) -> Result<Address, ExitError> {
    assert_eq!(signature.len(), 65);

    #[cfg(feature = "contract")]
    return sdk::ecrecover(hash, signature).map_err(|e| ExitError::Other(Borrowed(e.as_str())));

    #[cfg(not(feature = "contract"))]
    internal_impl(hash, signature)
}

#[cfg(not(feature = "contract"))]
fn internal_impl(hash: H256, signature: &[u8]) -> Result<Address, ExitError> {
    use sha3::Digest;

    let hash = libsecp256k1::Message::parse_slice(hash.as_bytes()).unwrap();
    let v = signature[64];
    let signature = libsecp256k1::Signature::parse_standard_slice(&signature[0..64])
        .map_err(|_| ExitError::Other(Borrowed(sdk::ECRecoverErr.as_str())))?;
    let bit = match v {
        0..=26 => v,
        _ => v - 27,
    };

    if let Ok(recovery_id) = libsecp256k1::RecoveryId::parse(bit) {
        if let Ok(public_key) = libsecp256k1::recover(&hash, &signature, &recovery_id) {
            // recover returns a 65-byte key, but addresses come from the raw 64-byte key
            let r = sha3::Keccak256::digest(&public_key.serialize()[1..]);
            return Address::try_from_slice(&r[12..])
                .map_err(|_| ExitError::Other(Borrowed("ERR_INCORRECT_ADDRESS")));
        }
    }

    Err(ExitError::Other(Borrowed(sdk::ECRecoverErr.as_str())))
}

pub struct ECRecover;

impl ECRecover {
    pub const ADDRESS: Address = super::make_address(0, 1);
}

impl Precompile for ECRecover {
    fn required_gas(_input: &[u8]) -> Result<EthGas, ExitError> {
        Ok(costs::ECRECOVER_BASE)
    }

    fn run(
        &self,
        input: &[u8],
        target_gas: Option<EthGas>,
        _context: &Context,
        _is_static: bool,
    ) -> EvmPrecompileResult {
        let cost = Self::required_gas(input)?;
        if let Some(target_gas) = target_gas {
            if cost > target_gas {
                return Err(ExitError::OutOfGas);
            }
        }

        let mut input = input.to_vec();
        input.resize(consts::INPUT_LEN, 0);

        let mut hash = [0; 32];
        hash.copy_from_slice(&input[0..32]);

        let mut v = [0; 32];
        v.copy_from_slice(&input[32..64]);

        let mut signature = [0; 65]; // signature is (r, s, v), typed (uint256, uint256, uint8)
        signature[0..32].copy_from_slice(&input[64..96]); // r
        signature[32..64].copy_from_slice(&input[96..128]); // s

        let v_bit = match v[31] {
            27 | 28 if v[..31] == [0; 31] => v[31] - 27,
            _ => {
                return Ok(PrecompileOutput::without_logs(cost, Vec::new()));
            }
        };
        signature[64] = v_bit; // v

        let address_res = ecrecover(H256::from_slice(&hash), &signature);
        let output = match address_res {
            Ok(a) => {
                let mut output = [0u8; 32];
                output[12..32].copy_from_slice(a.as_bytes());
                output.to_vec()
            }
            Err(_) => Vec::new(),
        };

        Ok(PrecompileOutput::without_logs(cost, output))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::new_context;

    fn ecverify(hash: H256, signature: &[u8], signer: Address) -> bool {
        matches!(ecrecover(hash, signature), Ok(s) if s == signer)
    }

    #[test]
    fn test_ecverify() {
        let hash = H256::from_slice(
            &hex::decode("1111111111111111111111111111111111111111111111111111111111111111")
                .unwrap(),
        );
        let signature =
            &hex::decode("b9f0bb08640d3c1c00761cdd0121209268f6fd3816bc98b9e6f3cc77bf82b69812ac7a61788a0fdc0e19180f14c945a8e1088a27d92a74dce81c0981fb6447441b")
                .unwrap();
        let signer = Address::try_from_slice(
            &hex::decode("1563915e194D8CfBA1943570603F7606A3115508").unwrap(),
        )
        .unwrap();
        assert!(ecverify(hash, signature, signer));
    }

    #[test]
    fn test_ecrecover() {
        let input = hex::decode("47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad000000000000000000000000000000000000000000000000000000000000001b650acf9d3f5f0a2c799776a1254355d5f4061762a237396a99a0e0e3fc2bcd6729514a0dacb2e623ac4abd157cb18163ff942280db4d5caad66ddf941ba12e03").unwrap();
        let expected =
            hex::decode("000000000000000000000000c08b5542d177ac6686946920409741463a15dddb")
                .unwrap();

        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        // out of gas
        let input = hex::decode("47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad000000000000000000000000000000000000000000000000000000000000001b650acf9d3f5f0a2c799776a1254355d5f4061762a237396a99a0e0e3fc2bcd6729514a0dacb2e623ac4abd157cb18163ff942280db4d5caad66ddf941ba12e03").unwrap();

        let res = ECRecover.run(&input, Some(EthGas::new(2_999)), &new_context(), false);
        assert!(matches!(res, Err(ExitError::OutOfGas)));

        // bad inputs
        let input = hex::decode("47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad000000000000000000000000000000000000000000000000000000000000001a650acf9d3f5f0a2c799776a1254355d5f4061762a237396a99a0e0e3fc2bcd6729514a0dacb2e623ac4abd157cb18163ff942280db4d5caad66ddf941ba12e03").unwrap();
        let expected: Vec<u8> = Vec::new();

        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        let input = hex::decode("47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001b0000000000000000000000000000000000000000000000000000000000000000").unwrap();
        let expected: Vec<u8> = Vec::new();

        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        let input = hex::decode("47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad000000000000000000000000000000000000000000000000000000000000001b0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001b").unwrap();
        let expected: Vec<u8> = Vec::new();

        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        let input = hex::decode("47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad000000000000000000000000000000000000000000000000000000000000001bffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff000000000000000000000000000000000000000000000000000000000000001b").unwrap();
        let expected: Vec<u8> = Vec::new();

        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        let input = hex::decode("47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad000000000000000000000000000000000000000000000000000000000000001b000000000000000000000000000000000000000000000000000000000000001bffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff").unwrap();
        let expected: Vec<u8> = Vec::new();

        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);
    }

    #[test]
    fn test_ecrecover_geth_tests() {
        let input = hex::decode("a8b53bdf3306a35a7103ab5504a0c9b492295564b6202b1942a84ef300107281000000000000000000000000000000000000000000000000000000000000001b307835653165303366353363653138623737326363623030393366663731663366353366356337356237346463623331613835616138623838393262346538621122334455667788991011121314151617181920212223242526272829303132").unwrap();
        let expected: Vec<u8> = Vec::new();
        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        let input = hex::decode("18c547e4f7b0f325ad1e56f57e26c745b09a3e503d86e00e5255ff7f715d3d1c000000000000000000000000000000000000000000000000000000000000001c73b1693892219d736caba55bdb67216e485557ea6b6af75f37096c9aa6a5a75feeb940b1d03b21e36b0e47e79769f095fe2ab855bd91e3a38756b7d75a9c4549").unwrap();
        let expected =
            hex::decode("000000000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b")
                .unwrap();
        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        let input = hex::decode("18c547e4f7b0f325ad1e56f57e26c745b09a3e503d86e00e5255ff7f715d3d1c100000000000000000000000000000000000000000000000000000000000001c73b1693892219d736caba55bdb67216e485557ea6b6af75f37096c9aa6a5a75feeb940b1d03b21e36b0e47e79769f095fe2ab855bd91e3a38756b7d75a9c4549").unwrap();
        let expected: Vec<u8> = Vec::new();
        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        let input = hex::decode("18c547e4f7b0f325ad1e56f57e26c745b09a3e503d86e00e5255ff7f715d3d1c000000000000000000000000000000000000001000000000000000000000001c73b1693892219d736caba55bdb67216e485557ea6b6af75f37096c9aa6a5a75feeb940b1d03b21e36b0e47e79769f095fe2ab855bd91e3a38756b7d75a9c4549").unwrap();
        let expected: Vec<u8> = Vec::new();
        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);

        let input = hex::decode("18c547e4f7b0f325ad1e56f57e26c745b09a3e503d86e00e5255ff7f715d3d1c000000000000000000000000000000000000001000000000000000000000011c73b1693892219d736caba55bdb67216e485557ea6b6af75f37096c9aa6a5a75feeb940b1d03b21e36b0e47e79769f095fe2ab855bd91e3a38756b7d75a9c4549").unwrap();
        let expected: Vec<u8> = Vec::new();
        let res = ECRecover
            .run(&input, Some(EthGas::new(3_000)), &new_context(), false)
            .unwrap()
            .output;
        assert_eq!(res, expected);
    }
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/utils.rs ---
use crate::prelude::Borrowed;
use core::num::TryFromIntError;
#[cfg(test)]
use evm::Context;
use evm::ExitError;

#[cfg(test)]
pub fn new_context() -> Context {
    Context {
        address: Default::default(),
        caller: Default::default(),
        apparent_value: Default::default(),
    }
}

pub fn err_usize_conv(_e: TryFromIntError) -> ExitError {
    ExitError::Other(Borrowed("ERR_USIZE_CONVERSION"))
}

'''
'''--- aurora-engine-2.8.1/engine-precompiles/src/xcc.rs ---
//! Cross contract call precompile.
//!
//! Allow Aurora users interacting with NEAR smart contracts using cross contract call primitives.
//! TODO: How they work (low level explanation with examples)

use crate::{HandleBasedPrecompile, PrecompileOutput};
use aurora_engine_sdk::io::IO;
use aurora_engine_types::{
    account_id::AccountId,
    format,
    parameters::{CrossContractCallArgs, PromiseCreateArgs},
    types::{balance::ZERO_YOCTO, Address, EthGas, NearGas},
    vec, Cow, Vec, H160, H256, U256,
};
use borsh::{BorshDeserialize, BorshSerialize};
use evm::backend::Log;
use evm::executor::stack::{PrecompileFailure, PrecompileHandle};
use evm::ExitError;

pub mod costs {
    use crate::prelude::types::{EthGas, NearGas};

    /// Base EVM gas cost for calling this precompile.
    /// Value obtained from the following methodology:
    /// 1. Estimate the cost of calling this precompile in terms of NEAR gas.
    ///    This is done by calling the precompile with inputs of different lengths
    ///    and performing a linear regression to obtain a function
    ///    `NEAR_gas = CROSS_CONTRACT_CALL_BASE + (input_length) * (CROSS_CONTRACT_CALL_BYTE)`.
    /// 2. Convert the NEAR gas cost into an EVM gas cost using the conversion ratio below
    ///    (`CROSS_CONTRACT_CALL_NEAR_GAS`).
    ///
    /// This process is done in the `test_xcc_eth_gas_cost` test in
    /// `engine-tests/src/tests/xcc.rs`.
    pub const CROSS_CONTRACT_CALL_BASE: EthGas = EthGas::new(323_000);
    /// Additional EVM gas cost per bytes of input given.
    /// See `CROSS_CONTRACT_CALL_BASE` for estimation methodology.
    pub const CROSS_CONTRACT_CALL_BYTE: EthGas = EthGas::new(3);
    /// EVM gas cost per NEAR gas attached to the created promise.
    /// This value is derived from the gas report https://hackmd.io/@birchmd/Sy4piXQ29
    /// The units on this quantity are `NEAR Gas / EVM Gas`.
    /// The report gives a value `0.175 T(NEAR_gas) / k(EVM_gas)`. To convert the units to
    /// `NEAR Gas / EVM Gas`, we simply multiply `0.175 * 10^12 / 10^3 = 175 * 10^6`.
    pub const CROSS_CONTRACT_CALL_NEAR_GAS: u64 = 175_000_000;

    pub const ROUTER_EXEC_BASE: NearGas = NearGas::new(7_000_000_000_000);
    pub const ROUTER_EXEC_PER_CALLBACK: NearGas = NearGas::new(12_000_000_000_000);
    pub const ROUTER_SCHEDULE: NearGas = NearGas::new(5_000_000_000_000);
}

mod consts {
    pub(super) const ERR_INVALID_INPUT: &str = "ERR_INVALID_XCC_INPUT";
    pub(super) const ERR_SERIALIZE: &str = "ERR_XCC_CALL_SERIALIZE";
    pub(super) const ERR_STATIC: &str = "ERR_INVALID_IN_STATIC";
    pub(super) const ERR_DELEGATE: &str = "ERR_INVALID_IN_DELEGATE";
    pub(super) const ROUTER_EXEC_NAME: &str = "execute";
    pub(super) const ROUTER_SCHEDULE_NAME: &str = "schedule";
    /// Solidity selector for the ERC-20 transferFrom function
    /// https://www.4byte.directory/signatures/?bytes4_signature=0x23b872dd
    pub(super) const TRANSFER_FROM_SELECTOR: [u8; 4] = [0x23, 0xb8, 0x72, 0xdd];
}

pub struct CrossContractCall<I> {
    io: I,
    engine_account_id: AccountId,
}

impl<I> CrossContractCall<I> {
    pub fn new(engine_account_id: AccountId, io: I) -> Self {
        Self {
            io,
            engine_account_id,
        }
    }
}

pub mod cross_contract_call {
    use aurora_engine_types::{types::Address, H256};

    /// Exit to Ethereum precompile address
    ///
    /// Address: `0x516cded1d16af10cad47d6d49128e2eb7d27b372`
    /// This address is computed as: `&keccak("nearCrossContractCall")[12..]`
    pub const ADDRESS: Address =
        crate::make_address(0x516cded1, 0xd16af10cad47d6d49128e2eb7d27b372);

    /// Sentinel value used to indicate the following topic field is how much NEAR the
    /// cross-contract call will require.
    pub const AMOUNT_TOPIC: H256 =
        crate::make_h256(0x72657175697265645f6e656172, 0x72657175697265645f6e656172);
}

impl<I: IO> HandleBasedPrecompile for CrossContractCall<I> {
    fn run_with_handle(
        &self,
        handle: &mut impl PrecompileHandle,
    ) -> Result<PrecompileOutput, PrecompileFailure> {
        let input = handle.input();
        let target_gas = handle.gas_limit().map(EthGas::new);
        let context = handle.context();
        let is_static = handle.is_static();

        // This only includes the cost we can easily derive without parsing the input.
        // This allows failing fast without wasting computation on parsing.
        let input_len = u64::try_from(input.len()).map_err(crate::utils::err_usize_conv)?;
        let mut cost =
            costs::CROSS_CONTRACT_CALL_BASE + costs::CROSS_CONTRACT_CALL_BYTE * input_len;
        let check_cost = |cost: EthGas| -> Result<(), PrecompileFailure> {
            if let Some(target_gas) = target_gas {
                if cost > target_gas {
                    return Err(PrecompileFailure::Error {
                        exit_status: ExitError::OutOfGas,
                    });
                }
            }
            Ok(())
        };
        check_cost(cost)?;

        // It's not allowed to call cross contract call precompile in static or delegate mode
        if is_static {
            return Err(revert_with_message(consts::ERR_STATIC));
        } else if context.address != cross_contract_call::ADDRESS.raw() {
            return Err(revert_with_message(consts::ERR_DELEGATE));
        }

        let sender = context.caller;
        let target_account_id = create_target_account_id(sender, self.engine_account_id.as_ref());
        let args = CrossContractCallArgs::try_from_slice(input)
            .map_err(|_| ExitError::Other(Cow::from(consts::ERR_INVALID_INPUT)))?;
        let (promise, attached_near) = match args {
            CrossContractCallArgs::Eager(call) => {
                let call_gas = call.total_gas();
                let attached_near = call.total_near();
                let callback_count = call.promise_count() - 1;
                let router_exec_cost = costs::ROUTER_EXEC_BASE
                    + NearGas::new(callback_count * costs::ROUTER_EXEC_PER_CALLBACK.as_u64());
                let promise = PromiseCreateArgs {
                    target_account_id,
                    method: consts::ROUTER_EXEC_NAME.into(),
                    args: call
                        .try_to_vec()
                        .map_err(|_| ExitError::Other(Cow::from(consts::ERR_SERIALIZE)))?,
                    attached_balance: ZERO_YOCTO,
                    attached_gas: router_exec_cost + call_gas,
                };
                (promise, attached_near)
            }
            CrossContractCallArgs::Delayed(call) => {
                let attached_near = call.total_near();
                let promise = PromiseCreateArgs {
                    target_account_id,
                    method: consts::ROUTER_SCHEDULE_NAME.into(),
                    args: call
                        .try_to_vec()
                        .map_err(|_| ExitError::Other(Cow::from(consts::ERR_SERIALIZE)))?,
                    attached_balance: ZERO_YOCTO,
                    // We don't need to add any gas to the amount need for the schedule call
                    // since the promise is not executed right away.
                    attached_gas: costs::ROUTER_SCHEDULE,
                };
                (promise, attached_near)
            }
        };
        cost += EthGas::new(promise.attached_gas.as_u64() / costs::CROSS_CONTRACT_CALL_NEAR_GAS);
        check_cost(cost)?;

        let required_near =
            match state::get_code_version_of_address(&self.io, &Address::new(sender)) {
                // If there is no deployed version of the router contract then we need to charge for storage staking
                None => attached_near + state::STORAGE_AMOUNT,
                Some(_) => attached_near,
            };
        // if some NEAR payment is needed, transfer it from the caller to the engine's implicit address
        if required_near != ZERO_YOCTO {
            let engine_implicit_address = aurora_engine_sdk::types::near_account_to_evm_address(
                self.engine_account_id.as_bytes(),
            );
            let tx_data = transfer_from_args(
                sender,
                engine_implicit_address.raw(),
                U256::from(required_near.as_u128()),
            );
            let wnear_address = state::get_wnear_address(&self.io);
            let context = evm::Context {
                address: wnear_address.raw(),
                caller: cross_contract_call::ADDRESS.raw(),
                apparent_value: U256::zero(),
            };
            let (exit_reason, return_value) =
                handle.call(wnear_address.raw(), None, tx_data, None, false, &context);
            match exit_reason {
                // Transfer successful, nothing to do
                evm::ExitReason::Succeed(_) => (),
                evm::ExitReason::Revert(r) => {
                    return Err(PrecompileFailure::Revert {
                        exit_status: r,
                        output: return_value,
                    })
                }
                evm::ExitReason::Error(e) => {
                    return Err(PrecompileFailure::Error { exit_status: e })
                }
                evm::ExitReason::Fatal(f) => {
                    return Err(PrecompileFailure::Fatal { exit_status: f })
                }
            };
        }

        let topics = vec![
            cross_contract_call::AMOUNT_TOPIC,
            H256(aurora_engine_types::types::u256_to_arr(&U256::from(
                required_near.as_u128(),
            ))),
        ];

        let promise_log = Log {
            address: cross_contract_call::ADDRESS.raw(),
            topics,
            data: promise
                .try_to_vec()
                .map_err(|_| ExitError::Other(Cow::from(consts::ERR_SERIALIZE)))?,
        };

        Ok(PrecompileOutput {
            logs: vec![promise_log],
            cost,
            ..Default::default()
        })
    }
}

pub mod state {
    //! Functions for reading state related to the cross-contract call feature

    use aurora_engine_sdk::error::ReadU32Error;
    use aurora_engine_sdk::io::{StorageIntermediate, IO};
    use aurora_engine_types::storage::{self, KeyPrefix};
    use aurora_engine_types::types::{Address, Yocto};
    use borsh::{BorshDeserialize, BorshSerialize};

    pub const ERR_CORRUPTED_STORAGE: &str = "ERR_CORRUPTED_XCC_STORAGE";
    pub const ERR_MISSING_WNEAR_ADDRESS: &str = "ERR_MISSING_WNEAR_ADDRESS";
    pub const VERSION_KEY: &[u8] = b"version";
    pub const WNEAR_KEY: &[u8] = b"wnear";
    /// Amount of NEAR needed to cover storage for a router contract.
    pub const STORAGE_AMOUNT: Yocto = Yocto::new(2_000_000_000_000_000_000_000_000);

    /// Type wrapper for version of router contracts.
    #[derive(
        Debug,
        Clone,
        Copy,
        Default,
        PartialEq,
        Eq,
        PartialOrd,
        Ord,
        BorshDeserialize,
        BorshSerialize,
    )]
    pub struct CodeVersion(pub u32);

    impl CodeVersion {
        pub fn increment(self) -> Self {
            Self(self.0 + 1)
        }
    }

    /// Get the address of the wNEAR ERC-20 contract
    pub fn get_wnear_address<I: IO>(io: &I) -> Address {
        let key = storage::bytes_to_key(KeyPrefix::CrossContractCall, WNEAR_KEY);
        match io.read_storage(&key) {
            Some(bytes) => Address::try_from_slice(&bytes.to_vec()).expect(ERR_CORRUPTED_STORAGE),
            None => panic!("{}", ERR_MISSING_WNEAR_ADDRESS),
        }
    }

    /// Get the latest router contract version.
    pub fn get_latest_code_version<I: IO>(io: &I) -> CodeVersion {
        let key = storage::bytes_to_key(KeyPrefix::CrossContractCall, VERSION_KEY);
        read_version(io, &key).unwrap_or_default()
    }

    /// Get the version of the currently deploy router for the given address (if it exists).
    pub fn get_code_version_of_address<I: IO>(io: &I, address: &Address) -> Option<CodeVersion> {
        let key = storage::bytes_to_key(KeyPrefix::CrossContractCall, address.as_bytes());
        read_version(io, &key)
    }

    /// Private utility method for reading code version from storage.
    fn read_version<I: IO>(io: &I, key: &[u8]) -> Option<CodeVersion> {
        match io.read_u32(key) {
            Ok(value) => Some(CodeVersion(value)),
            Err(ReadU32Error::MissingValue) => None,
            Err(ReadU32Error::InvalidU32) => panic!("{}", ERR_CORRUPTED_STORAGE),
        }
    }
}

fn transfer_from_args(from: H160, to: H160, amount: U256) -> Vec<u8> {
    let args = ethabi::encode(&[
        ethabi::Token::Address(from),
        ethabi::Token::Address(to),
        ethabi::Token::Uint(amount),
    ]);
    [&consts::TRANSFER_FROM_SELECTOR, args.as_slice()].concat()
}

fn create_target_account_id(sender: H160, engine_account_id: &str) -> AccountId {
    format!("{}.{}", hex::encode(sender.as_bytes()), engine_account_id)
        .parse()
        .unwrap()
}

fn revert_with_message(message: &str) -> PrecompileFailure {
    PrecompileFailure::Revert {
        exit_status: evm::ExitRevert::Reverted,
        output: message.as_bytes().to_vec(),
    }
}

#[cfg(test)]
mod tests {
    use crate::prelude::sdk::types::near_account_to_evm_address;
    use crate::xcc::cross_contract_call;
    use aurora_engine_types::{vec, H160, U256};
    use rand::Rng;

    #[test]
    fn test_precompile_id() {
        assert_eq!(
            cross_contract_call::ADDRESS,
            near_account_to_evm_address("nearCrossContractCall".as_bytes())
        );
    }

    #[test]
    fn test_transfer_from_encoding() {
        let mut rng = rand::thread_rng();
        let from: [u8; 20] = rng.gen();
        let to: [u8; 20] = rng.gen();
        let amount: [u8; 32] = rng.gen();

        let from = H160(from);
        let to = H160(to);
        let amount = U256::from_big_endian(&amount);

        #[allow(deprecated)]
        let transfer_from_function = ethabi::Function {
            name: "transferFrom".into(),
            inputs: vec![
                ethabi::Param {
                    name: "from".into(),
                    kind: ethabi::ParamType::Address,
                    internal_type: None,
                },
                ethabi::Param {
                    name: "to".into(),
                    kind: ethabi::ParamType::Address,
                    internal_type: None,
                },
                ethabi::Param {
                    name: "amount".into(),
                    kind: ethabi::ParamType::Uint(256),
                    internal_type: None,
                },
            ],
            outputs: vec![ethabi::Param {
                name: "".into(),
                kind: ethabi::ParamType::Bool,
                internal_type: None,
            }],
            constant: None,
            state_mutability: ethabi::StateMutability::NonPayable,
        };
        let expected_tx_data = transfer_from_function
            .encode_input(&[
                ethabi::Token::Address(from),
                ethabi::Token::Address(to),
                ethabi::Token::Uint(amount),
            ])
            .unwrap();

        assert_eq!(
            super::transfer_from_args(from, to, amount),
            expected_tx_data
        );
    }
}

'''
'''--- aurora-engine-2.8.1/engine-sdk/Cargo.toml ---
[package]
name = "aurora-engine-sdk"
version = "1.0.0"
authors = ["Aurora Labs <hello@aurora.dev>"]
edition = "2021"
description = ""
documentation = ""
readme = true
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "CC0-1.0"
publish = false
autobenches = false

[dependencies]
aurora-engine-types = { path = "../engine-types", default-features = false }
borsh = { version = "0.9.3", default-features = false }
sha3 = { version = "0.10.2", default-features = false }
sha2 = { version = "0.10.2", default-features = false }

[features]
std = ["aurora-engine-types/std", "borsh/std", "sha3/std", "sha2/std"]
contract = []
log = []
all-promise-actions = []
mainnet = []
testnet = []

'''
'''--- aurora-engine-2.8.1/engine-sdk/src/caching.rs ---
use aurora_engine_types::BTreeMap;

/// A naive cache storing all key-value pairs it learns about..
#[derive(Default)]
pub struct FullCache<K, V> {
    inner: BTreeMap<K, V>,
}

impl<K: Ord, V> FullCache<K, V> {
    pub fn get_or_insert_with<F: FnOnce() -> V>(&mut self, k: K, f: F) -> &mut V {
        self.inner.entry(k).or_insert_with(f)
    }
}

'''
'''--- aurora-engine-2.8.1/engine-sdk/src/env.rs ---
use crate::error::{OneYoctoAttachError, PrivateCallError};
use crate::prelude::{NearGas, H256};
use aurora_engine_types::account_id::AccountId;

pub const DEFAULT_PREPAID_GAS: NearGas = NearGas::new(300_000_000_000_000);

/// Timestamp represented by the number of nanoseconds since the Unix Epoch.
#[derive(Default, Debug, Copy, Clone, Eq, PartialEq, PartialOrd, Ord)]
pub struct Timestamp(u64);

impl Timestamp {
    pub fn new(ns: u64) -> Self {
        Self(ns)
    }

    pub fn nanos(&self) -> u64 {
        self.0
    }

    pub fn millis(&self) -> u64 {
        self.0 / 1_000_000
    }

    pub fn secs(&self) -> u64 {
        self.0 / 1_000_000_000
    }
}

/// Returns information about the NEAR context in which the
/// transaction is executing. In the case of a standalone binary,
/// independent of NEAR these values would need to be mocked or otherwise
/// passed in from an external source.
pub trait Env {
    /// Account ID that signed the transaction.
    fn signer_account_id(&self) -> AccountId;
    /// Account ID of the currently executing contract.
    fn current_account_id(&self) -> AccountId;
    /// Account ID which called the current contract.
    fn predecessor_account_id(&self) -> AccountId;
    /// Height of the current block.
    fn block_height(&self) -> u64;
    /// Timestamp (in ns) of the current block.
    fn block_timestamp(&self) -> Timestamp;
    /// Amount of NEAR attached to current call
    fn attached_deposit(&self) -> u128;
    /// Random seed generated for the current block
    fn random_seed(&self) -> H256;
    /// Prepaid NEAR Gas
    fn prepaid_gas(&self) -> NearGas;

    fn assert_private_call(&self) -> Result<(), PrivateCallError> {
        if self.predecessor_account_id() == self.current_account_id() {
            Ok(())
        } else {
            Err(PrivateCallError)
        }
    }

    fn assert_one_yocto(&self) -> Result<(), OneYoctoAttachError> {
        if self.attached_deposit() == 1 {
            Ok(())
        } else {
            Err(OneYoctoAttachError)
        }
    }
}

/// Fully in-memory implementation of the blockchain environment with
/// fixed values for all the fields.
#[derive(Default, Debug, Clone, PartialEq, Eq)]
pub struct Fixed {
    pub signer_account_id: AccountId,
    pub current_account_id: AccountId,
    pub predecessor_account_id: AccountId,
    pub block_height: u64,
    pub block_timestamp: Timestamp,
    pub attached_deposit: u128,
    pub random_seed: H256,
    pub prepaid_gas: NearGas,
}

impl Env for Fixed {
    fn signer_account_id(&self) -> AccountId {
        self.signer_account_id.clone()
    }

    fn current_account_id(&self) -> AccountId {
        self.current_account_id.clone()
    }

    fn predecessor_account_id(&self) -> AccountId {
        self.predecessor_account_id.clone()
    }

    fn block_height(&self) -> u64 {
        self.block_height
    }

    fn block_timestamp(&self) -> Timestamp {
        self.block_timestamp
    }

    fn attached_deposit(&self) -> u128 {
        self.attached_deposit
    }

    fn random_seed(&self) -> H256 {
        self.random_seed
    }

    fn prepaid_gas(&self) -> NearGas {
        self.prepaid_gas
    }
}

'''
'''--- aurora-engine-2.8.1/engine-sdk/src/error.rs ---
#[derive(Debug)]
pub struct BorshDeserializeError;

impl AsRef<[u8]> for BorshDeserializeError {
    fn as_ref(&self) -> &[u8] {
        b"ERR_ARG_PARSE"
    }
}

#[derive(Debug)]
pub struct IncorrectInputLength;

impl AsRef<[u8]> for IncorrectInputLength {
    fn as_ref(&self) -> &[u8] {
        b"ERR_INCORRECT_INPUT_LENGTH"
    }
}

#[derive(Debug)]
pub enum ReadU32Error {
    InvalidU32,
    MissingValue,
}

impl AsRef<[u8]> for ReadU32Error {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::InvalidU32 => b"ERR_NOT_U32",
            Self::MissingValue => b"ERR_U32_NOT_FOUND",
        }
    }
}

#[derive(Debug)]
pub enum ReadU64Error {
    InvalidU64,
    MissingValue,
}

impl AsRef<[u8]> for ReadU64Error {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::InvalidU64 => b"ERR_NOT_U64",
            Self::MissingValue => b"ERR_U64_NOT_FOUND",
        }
    }
}

#[derive(Debug)]
pub enum ReadU256Error {
    InvalidU256,
    MissingValue,
}

impl AsRef<[u8]> for ReadU256Error {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::InvalidU256 => b"ERR_NOT_U256",
            Self::MissingValue => b"ERR_U256_NOT_FOUND",
        }
    }
}

#[derive(Debug)]
pub struct PrivateCallError;

impl AsRef<[u8]> for PrivateCallError {
    fn as_ref(&self) -> &[u8] {
        b"ERR_PRIVATE_CALL"
    }
}

#[derive(Debug)]
pub struct OneYoctoAttachError;

impl AsRef<[u8]> for OneYoctoAttachError {
    fn as_ref(&self) -> &[u8] {
        b"ERR_1YOCTO_ATTACH"
    }
}

'''
'''--- aurora-engine-2.8.1/engine-sdk/src/io.rs ---
use crate::error;
use crate::prelude::{vec, Vec};
use aurora_engine_types::U256;
use borsh::{BorshDeserialize, BorshSerialize};

/// The purpose of this trait is to represent a reference to a value that
/// could be obtained by IO, but without eagerly loading it into memory.
/// For example, the NEAR runtime registers API allows querying the length
/// of some bytes read from input or storage without loading them into the
/// wasm memory.
pub trait StorageIntermediate: Sized {
    fn len(&self) -> usize;
    fn is_empty(&self) -> bool;
    fn copy_to_slice(&self, buffer: &mut [u8]);

    fn to_vec(&self) -> Vec<u8> {
        let size = self.len();
        let mut buf = vec![0u8; size];
        self.copy_to_slice(&mut buf);
        buf
    }

    fn to_value<T: BorshDeserialize>(&self) -> Result<T, error::BorshDeserializeError> {
        let bytes = self.to_vec();
        T::try_from_slice(&bytes).map_err(|_| error::BorshDeserializeError)
    }
}

/// Trait for reading/writing values from storage and a generalized `stdin`/`stdout`.
pub trait IO {
    /// A type giving a reference to a value obtained by IO without loading it
    /// into memory. For example, in the case of a wasm contract on NEAR this
    /// will correspond to a register index.
    type StorageValue: StorageIntermediate;

    /// Read bytes that were passed as input to the process. This can be thought of as a
    /// generalization of `stdin` or command-line arguments. In the case of wasm contracts
    /// on NEAR these would be the arguments to the method.
    fn read_input(&self) -> Self::StorageValue;

    /// Return a value to an external process. In the case of wasm contracts on NEAR
    /// this corresponds to the return value from the contract method.
    fn return_output(&mut self, value: &[u8]);

    /// Read the value in storage at the given key, if any.
    fn read_storage(&self, key: &[u8]) -> Option<Self::StorageValue>;

    /// Check if there is a value in storage at the given key, but do not read the value.
    /// Equivalent to `self.read_storage(key).is_some()` but more efficient.
    fn storage_has_key(&self, key: &[u8]) -> bool;

    /// Write the given value to storage under the given key. Returns a reference to the old
    /// value stored at that key (if any).
    fn write_storage(&mut self, key: &[u8], value: &[u8]) -> Option<Self::StorageValue>;

    /// Write a `StorageIntermediate` to storage directly under the given key
    /// (without ever needing to load the value into memory).Returns a reference
    /// to the old value stored at that key (if any).
    fn write_storage_direct(
        &mut self,
        key: &[u8],
        value: Self::StorageValue,
    ) -> Option<Self::StorageValue>;

    /// Remove entry from storage and capture the value present at the given key (if any)
    fn remove_storage(&mut self, key: &[u8]) -> Option<Self::StorageValue>;

    /// Read the length of the bytes stored at the given key.
    fn read_storage_len(&self, key: &[u8]) -> Option<usize> {
        self.read_storage(key).map(|s| s.len())
    }

    /// Convenience function to read the input and deserialize the bytes using borsh.
    fn read_input_borsh<U: BorshDeserialize>(&self) -> Result<U, error::BorshDeserializeError> {
        self.read_input().to_value()
    }

    /// Convenience function to read the input into a 20-byte array.
    fn read_input_arr20(&self) -> Result<[u8; 20], error::IncorrectInputLength> {
        let value = self.read_input();

        if value.len() != 20 {
            return Err(error::IncorrectInputLength);
        }

        let mut buf = [0u8; 20];
        value.copy_to_slice(&mut buf);
        Ok(buf)
    }

    /// Convenience function to read the input into a 32-byte array.
    fn read_input_arr32(&self) -> Result<[u8; 32], error::IncorrectInputLength> {
        let value = self.read_input();

        if value.len() != 32 {
            return Err(error::IncorrectInputLength);
        }

        let mut buf = [0u8; 32];
        value.copy_to_slice(&mut buf);
        Ok(buf)
    }

    /// Convenience function to store the input directly in storage under the
    /// given key (without ever loading it into memory).
    fn read_input_and_store(&mut self, key: &[u8]) {
        let value = self.read_input();
        self.write_storage_direct(key, value);
    }

    /// Convenience function to read a 32-bit unsigned integer from storage
    /// (assumes little-endian encoding).
    fn read_u32(&self, key: &[u8]) -> Result<u32, error::ReadU32Error> {
        let value = self
            .read_storage(key)
            .ok_or(error::ReadU32Error::MissingValue)?;

        if value.len() != 4 {
            return Err(error::ReadU32Error::InvalidU32);
        }

        let mut result = [0u8; 4];
        value.copy_to_slice(&mut result);
        Ok(u32::from_le_bytes(result))
    }

    /// Convenience function to read a 64-bit unsigned integer from storage
    /// (assumes little-endian encoding).
    fn read_u64(&self, key: &[u8]) -> Result<u64, error::ReadU64Error> {
        let value = self
            .read_storage(key)
            .ok_or(error::ReadU64Error::MissingValue)?;

        if value.len() != 8 {
            return Err(error::ReadU64Error::InvalidU64);
        }

        let mut result = [0u8; 8];
        value.copy_to_slice(&mut result);
        Ok(u64::from_le_bytes(result))
    }

    /// Convenience function to read a 256-bit unsigned integer from storage
    /// (assumes big-endian encoding).
    fn read_u256(&self, key: &[u8]) -> Result<U256, error::ReadU256Error> {
        let value = self
            .read_storage(key)
            .ok_or(error::ReadU256Error::MissingValue)?;

        if value.len() != 32 {
            return Err(error::ReadU256Error::InvalidU256);
        }

        let mut result = [0u8; 32];
        value.copy_to_slice(&mut result);
        Ok(U256::from_big_endian(&result))
    }

    fn write_borsh<T: BorshSerialize>(
        &mut self,
        key: &[u8],
        value: &T,
    ) -> Option<Self::StorageValue> {
        let bytes = value.try_to_vec().ok()?;
        self.write_storage(key, &bytes)
    }
}

'''
'''--- aurora-engine-2.8.1/engine-sdk/src/lib.rs ---
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(not(feature = "std"), feature(alloc_error_handler))]

#[cfg(feature = "contract")]
use crate::prelude::{Address, Vec, U256};
use crate::prelude::{H256, STORAGE_PRICE_PER_BYTE};
pub use types::keccak;

pub mod caching;
pub mod env;
pub mod error;
pub mod io;
#[cfg(feature = "contract")]
pub mod near_runtime;
mod prelude;
pub mod promise;
pub mod types;

#[cfg(feature = "contract")]
use near_runtime::exports;

#[cfg(feature = "contract")]
const ECRECOVER_MESSAGE_SIZE: u64 = 32;
#[cfg(feature = "contract")]
const ECRECOVER_SIGNATURE_LENGTH: u64 = 64;
#[cfg(feature = "contract")]
const ECRECOVER_MALLEABILITY_FLAG: u64 = 0;

#[cfg(feature = "contract")]
pub fn panic_utf8(bytes: &[u8]) -> ! {
    unsafe {
        exports::panic_utf8(bytes.len() as u64, bytes.as_ptr() as u64);
    }
    unreachable!()
}

#[cfg(feature = "contract")]
pub fn log_utf8(bytes: &[u8]) {
    unsafe {
        exports::log_utf8(bytes.len() as u64, bytes.as_ptr() as u64);
    }
}

/// Calls environment sha256 on given input.
#[cfg(feature = "contract")]
pub fn sha256(input: &[u8]) -> H256 {
    unsafe {
        const REGISTER_ID: u64 = 1;
        exports::sha256(input.len() as u64, input.as_ptr() as u64, 1);
        let bytes = H256::zero();
        exports::read_register(REGISTER_ID, bytes.0.as_ptr() as *const u64 as u64);
        bytes
    }
}

#[cfg(not(feature = "contract"))]
pub fn sha256(input: &[u8]) -> H256 {
    use sha2::Digest;

    let output = sha2::Sha256::digest(input);
    H256(output.into())
}

/// Calls environment ripemd160 on given input.
#[cfg(feature = "contract")]
pub fn ripemd160(input: &[u8]) -> [u8; 20] {
    unsafe {
        const REGISTER_ID: u64 = 1;
        exports::ripemd160(input.len() as u64, input.as_ptr() as u64, REGISTER_ID);
        let bytes = [0u8; 20];
        exports::read_register(REGISTER_ID, bytes.as_ptr() as u64);
        bytes
    }
}

#[cfg(feature = "contract")]
pub fn alt_bn128_g1_sum(left: [u8; 64], right: [u8; 64]) -> [u8; 64] {
    let mut bytes = Vec::with_capacity(64 * 2 + 2); // 64 bytes per G1 + 2 positive integer bytes.

    bytes.push(0); // positive sign
    bytes.extend_from_slice(&left);
    bytes.push(0);
    bytes.extend_from_slice(&right);

    let value_ptr = bytes.as_ptr() as u64;
    let value_len = bytes.len() as u64;

    unsafe {
        const REGISTER_ID: u64 = 1;
        exports::alt_bn128_g1_sum(value_len, value_ptr, REGISTER_ID);
        let mut output = [0u8; 64];
        exports::read_register(REGISTER_ID, output.as_ptr() as u64);
        let x = U256::from_little_endian(&output[0..32]);
        let y = U256::from_little_endian(&output[32..64]);
        x.to_big_endian(&mut output[0..32]);
        y.to_big_endian(&mut output[32..64]);
        output
    }
}

#[cfg(feature = "contract")]
pub fn alt_bn128_g1_scalar_multiple(g1: [u8; 64], fr: [u8; 32]) -> [u8; 64] {
    let mut bytes = [0u8; 96];
    bytes[0..64].copy_from_slice(&g1);
    bytes[64..96].copy_from_slice(&fr);

    let value_ptr = bytes.as_ptr() as u64;
    let value_len = bytes.len() as u64;

    unsafe {
        const REGISTER_ID: u64 = 1;
        exports::alt_bn128_g1_multiexp(value_len, value_ptr, REGISTER_ID);
        let mut output = [0u8; 64];
        exports::read_register(REGISTER_ID, output.as_ptr() as u64);
        let x = U256::from_little_endian(&output[0..32]);
        let y = U256::from_little_endian(&output[32..64]);
        x.to_big_endian(&mut output[0..32]);
        y.to_big_endian(&mut output[32..64]);
        output
    }
}

#[cfg(feature = "contract")]
pub fn alt_bn128_pairing<I>(pairs: I) -> bool
where
    I: ExactSizeIterator<Item = ([u8; 64], [u8; 128])>,
{
    let n = pairs.len();
    let mut bytes = Vec::with_capacity(n * 6 * 32);
    let mut buf = [0u8; 64 + 128];
    for (g1, g2) in pairs {
        buf[0..64].copy_from_slice(&g1);
        buf[64..192].copy_from_slice(&g2);
        bytes.extend_from_slice(&buf);
    }

    let value_ptr = bytes.as_ptr() as u64;
    let value_len = bytes.len() as u64;

    let result = unsafe { exports::alt_bn128_pairing_check(value_len, value_ptr) };

    result == 1
}

/// Recover address from message hash and signature.
#[cfg(feature = "contract")]
pub fn ecrecover(hash: H256, signature: &[u8]) -> Result<Address, ECRecoverErr> {
    unsafe {
        let hash_ptr = hash.as_ptr() as u64;
        let sig_ptr = signature.as_ptr() as u64;
        const RECOVER_REGISTER_ID: u64 = 1;
        const KECCACK_REGISTER_ID: u64 = 2;
        let result = exports::ecrecover(
            ECRECOVER_MESSAGE_SIZE,
            hash_ptr,
            ECRECOVER_SIGNATURE_LENGTH,
            sig_ptr,
            signature[64] as u64,
            ECRECOVER_MALLEABILITY_FLAG,
            RECOVER_REGISTER_ID,
        );
        if result == (true as u64) {
            // The result from the ecrecover call is in a register; we can use this
            // register directly for the input to keccak256. This is why the length is
            // set to `u64::MAX`.
            exports::keccak256(u64::MAX, RECOVER_REGISTER_ID, KECCACK_REGISTER_ID);
            let keccak_hash_bytes = [0u8; 32];
            exports::read_register(KECCACK_REGISTER_ID, keccak_hash_bytes.as_ptr() as u64);
            Ok(Address::try_from_slice(&keccak_hash_bytes[12..]).map_err(|_| ECRecoverErr)?)
        } else {
            Err(ECRecoverErr)
        }
    }
}

#[cfg(feature = "contract")]
pub fn log(data: &str) {
    log_utf8(data.as_bytes())
}

#[cfg(not(feature = "contract"))]
pub fn log(_data: &str) {
    // TODO: standalone logging
}

#[macro_export]
macro_rules! log {
    ($($args:tt)*) => {
        #[cfg(feature = "log")]
        $crate::log(&aurora_engine_types::format!("{}", format_args!($($args)*)))
    };
}

pub fn storage_byte_cost() -> u128 {
    STORAGE_PRICE_PER_BYTE
}

pub struct ECRecoverErr;

impl ECRecoverErr {
    pub fn as_str(&self) -> &'static str {
        "ERR_ECRECOVER"
    }
}

impl AsRef<[u8]> for ECRecoverErr {
    fn as_ref(&self) -> &[u8] {
        self.as_str().as_bytes()
    }
}

'''
'''--- aurora-engine-2.8.1/engine-sdk/src/near_runtime.rs ---
use crate::io::StorageIntermediate;
use crate::prelude::NearGas;
use crate::promise::PromiseId;
use aurora_engine_types::account_id::AccountId;
use aurora_engine_types::parameters::{
    NearPublicKey, PromiseAction, PromiseBatchAction, PromiseCreateArgs,
};
use aurora_engine_types::types::PromiseResult;
use aurora_engine_types::H256;

#[cfg(all(feature = "mainnet", not(feature = "testnet")))]
/// The mainnet eth_custodian address 0x6BFaD42cFC4EfC96f529D786D643Ff4A8B89FA52
const CUSTODIAN_ADDRESS: &[u8] = &[
    107, 250, 212, 44, 252, 78, 252, 150, 245, 41, 215, 134, 214, 67, 255, 74, 139, 137, 250, 82,
];

#[cfg(feature = "testnet")]
/// The testnet eth_custodian address 0x84a82Bb39c83989D5Dc07e1310281923D2544dC2
const CUSTODIAN_ADDRESS: &[u8] = &[
    132, 168, 43, 179, 156, 131, 152, 157, 93, 192, 126, 19, 16, 40, 25, 35, 210, 84, 77, 194,
];

macro_rules! feature_gated {
    ($feature_name:literal, $code:block) => {
        if cfg!(feature = $feature_name) {
            $code
        } else {
            unimplemented!("Not implemented without feature {}", $feature_name)
        }
    };
}

/// Wrapper type for indices in NEAR's register API.
pub struct RegisterIndex(u64);

/// Singleton type used to implement the IO traits in the case of using NEAR's
/// runtime (i.e. for wasm contracts).
#[derive(Copy, Clone, Default)]
pub struct Runtime;

impl Runtime {
    const READ_STORAGE_REGISTER_ID: RegisterIndex = RegisterIndex(0);
    const INPUT_REGISTER_ID: RegisterIndex = RegisterIndex(1);
    const WRITE_REGISTER_ID: RegisterIndex = RegisterIndex(2);
    const EVICT_REGISTER_ID: RegisterIndex = RegisterIndex(3);
    const ENV_REGISTER_ID: RegisterIndex = RegisterIndex(4);
    const PROMISE_REGISTER_ID: RegisterIndex = RegisterIndex(5);

    const GAS_FOR_STATE_MIGRATION: NearGas = NearGas::new(100_000_000_000_000);

    /// Deploy code from given key in place of the current contract.
    /// Not implemented in terms of higher level traits (eg IO) for efficiency reasons.
    pub fn self_deploy(code_key: &[u8]) {
        unsafe {
            // Load current account id into register 0.
            exports::current_account_id(0);
            // Use register 0 as the destination for the promise.
            let promise_id = exports::promise_batch_create(u64::MAX as _, 0);
            // Remove code from storage and store it in register 1.
            exports::storage_remove(code_key.len() as _, code_key.as_ptr() as _, 1);
            exports::promise_batch_action_deploy_contract(promise_id, u64::MAX, 1);
            Self::promise_batch_action_function_call(
                promise_id,
                b"state_migration",
                &[],
                0,
                Self::GAS_FOR_STATE_MIGRATION.as_u64(),
            )
        }
    }

    /// Assumes a valid account ID has been written to ENV_REGISTER_ID
    /// by a previous call.
    fn read_account_id() -> AccountId {
        let bytes = Self::ENV_REGISTER_ID.to_vec();
        match AccountId::try_from(bytes) {
            Ok(account_id) => account_id,
            // the environment must give us a valid Account ID.
            Err(_) => unreachable!(),
        }
    }

    /// Convenience wrapper around `exports::promise_batch_action_function_call`
    fn promise_batch_action_function_call(
        promise_idx: u64,
        method_name: &[u8],
        arguments: &[u8],
        amount: u128,
        gas: u64,
    ) {
        unsafe {
            exports::promise_batch_action_function_call(
                promise_idx,
                method_name.len() as _,
                method_name.as_ptr() as _,
                arguments.len() as _,
                arguments.as_ptr() as _,
                &amount as *const u128 as _,
                gas,
            )
        }
    }
}

impl StorageIntermediate for RegisterIndex {
    fn len(&self) -> usize {
        unsafe {
            let result = exports::register_len(self.0);
            // By convention, an unused register will return a length of U64::MAX
            // (see https://nomicon.io/RuntimeSpec/Components/BindingsSpec/RegistersAPI.html).
            if result < u64::MAX {
                result as usize
            } else {
                0
            }
        }
    }

    fn is_empty(&self) -> bool {
        self.len() == 0
    }

    fn copy_to_slice(&self, buffer: &mut [u8]) {
        unsafe { exports::read_register(self.0, buffer.as_ptr() as u64) }
    }
}

impl crate::io::IO for Runtime {
    type StorageValue = RegisterIndex;

    fn read_input(&self) -> Self::StorageValue {
        unsafe {
            exports::input(Runtime::INPUT_REGISTER_ID.0);
        }
        Runtime::INPUT_REGISTER_ID
    }

    fn return_output(&mut self, value: &[u8]) {
        unsafe {
            #[cfg(any(feature = "mainnet", feature = "testnet"))]
            if value.len() >= 56 && &value[36..56] == CUSTODIAN_ADDRESS {
                panic!("ERR_ILLEGAL_RETURN");
            }
            exports::value_return(value.len() as u64, value.as_ptr() as u64);
        }
    }

    fn read_storage(&self, key: &[u8]) -> Option<Self::StorageValue> {
        unsafe {
            if exports::storage_read(
                key.len() as u64,
                key.as_ptr() as u64,
                Runtime::READ_STORAGE_REGISTER_ID.0,
            ) == 1
            {
                Some(Runtime::READ_STORAGE_REGISTER_ID)
            } else {
                None
            }
        }
    }

    fn storage_has_key(&self, key: &[u8]) -> bool {
        unsafe { exports::storage_has_key(key.len() as _, key.as_ptr() as _) == 1 }
    }

    fn write_storage(&mut self, key: &[u8], value: &[u8]) -> Option<Self::StorageValue> {
        unsafe {
            if exports::storage_write(
                key.len() as u64,
                key.as_ptr() as u64,
                value.len() as u64,
                value.as_ptr() as u64,
                Runtime::WRITE_REGISTER_ID.0,
            ) == 1
            {
                Some(Runtime::WRITE_REGISTER_ID)
            } else {
                None
            }
        }
    }

    fn write_storage_direct(
        &mut self,
        key: &[u8],
        value: Self::StorageValue,
    ) -> Option<Self::StorageValue> {
        unsafe {
            if exports::storage_write(
                key.len() as _,
                key.as_ptr() as _,
                u64::MAX,
                value.0,
                Runtime::WRITE_REGISTER_ID.0,
            ) == 1
            {
                Some(Runtime::WRITE_REGISTER_ID)
            } else {
                None
            }
        }
    }

    fn remove_storage(&mut self, key: &[u8]) -> Option<Self::StorageValue> {
        unsafe {
            if exports::storage_remove(
                key.len() as _,
                key.as_ptr() as _,
                Runtime::EVICT_REGISTER_ID.0,
            ) == 1
            {
                Some(Runtime::EVICT_REGISTER_ID)
            } else {
                None
            }
        }
    }
}

impl crate::env::Env for Runtime {
    fn signer_account_id(&self) -> AccountId {
        unsafe {
            exports::signer_account_id(Self::ENV_REGISTER_ID.0);
        }
        Self::read_account_id()
    }

    fn current_account_id(&self) -> AccountId {
        unsafe {
            exports::current_account_id(Self::ENV_REGISTER_ID.0);
        }
        Self::read_account_id()
    }

    fn predecessor_account_id(&self) -> AccountId {
        unsafe {
            exports::predecessor_account_id(Self::ENV_REGISTER_ID.0);
        }
        Self::read_account_id()
    }

    fn block_height(&self) -> u64 {
        unsafe { exports::block_index() }
    }

    fn block_timestamp(&self) -> crate::env::Timestamp {
        let ns = unsafe { exports::block_timestamp() };
        crate::env::Timestamp::new(ns)
    }

    fn attached_deposit(&self) -> u128 {
        unsafe {
            let data = [0u8; core::mem::size_of::<u128>()];
            exports::attached_deposit(data.as_ptr() as u64);
            u128::from_le_bytes(data)
        }
    }

    fn random_seed(&self) -> H256 {
        unsafe {
            exports::random_seed(0);
            let bytes = H256::zero();
            exports::read_register(0, bytes.0.as_ptr() as *const u64 as u64);
            bytes
        }
    }

    fn prepaid_gas(&self) -> NearGas {
        NearGas::new(unsafe { exports::prepaid_gas() })
    }
}

impl crate::promise::PromiseHandler for Runtime {
    type ReadOnly = Self;

    fn promise_results_count(&self) -> u64 {
        unsafe { exports::promise_results_count() }
    }

    fn promise_result(&self, index: u64) -> Option<PromiseResult> {
        unsafe {
            match exports::promise_result(index, Self::PROMISE_REGISTER_ID.0) {
                0 => Some(PromiseResult::NotReady),
                1 => {
                    let bytes = Self::PROMISE_REGISTER_ID.to_vec();
                    Some(PromiseResult::Successful(bytes))
                }
                2 => Some(PromiseResult::Failed),
                _ => None,
            }
        }
    }

    unsafe fn promise_create_call(&mut self, args: &PromiseCreateArgs) -> PromiseId {
        let account_id = args.target_account_id.as_bytes();
        let method_name = args.method.as_bytes();
        let arguments = args.args.as_slice();
        let amount = args.attached_balance.as_u128();
        let gas = args.attached_gas.as_u64();

        let id = {
            exports::promise_create(
                account_id.len() as _,
                account_id.as_ptr() as _,
                method_name.len() as _,
                method_name.as_ptr() as _,
                arguments.len() as _,
                arguments.as_ptr() as _,
                &amount as *const u128 as _,
                gas,
            )
        };
        PromiseId::new(id)
    }

    unsafe fn promise_attach_callback(
        &mut self,
        base: PromiseId,
        callback: &PromiseCreateArgs,
    ) -> PromiseId {
        let account_id = callback.target_account_id.as_bytes();
        let method_name = callback.method.as_bytes();
        let arguments = callback.args.as_slice();
        let amount = callback.attached_balance.as_u128();
        let gas = callback.attached_gas.as_u64();

        let id = {
            exports::promise_then(
                base.raw(),
                account_id.len() as _,
                account_id.as_ptr() as _,
                method_name.len() as _,
                method_name.as_ptr() as _,
                arguments.len() as _,
                arguments.as_ptr() as _,
                &amount as *const u128 as _,
                gas,
            )
        };

        PromiseId::new(id)
    }

    unsafe fn promise_create_batch(&mut self, args: &PromiseBatchAction) -> PromiseId {
        let account_id = args.target_account_id.as_bytes();

        let id = { exports::promise_batch_create(account_id.len() as _, account_id.as_ptr() as _) };

        for action in args.actions.iter() {
            match action {
                PromiseAction::CreateAccount => {
                    exports::promise_batch_action_create_account(id);
                }
                PromiseAction::Transfer { amount } => {
                    let amount = amount.as_u128();
                    exports::promise_batch_action_transfer(id, &amount as *const u128 as _);
                }
                PromiseAction::DeployContract { code } => {
                    let code = code.as_slice();
                    exports::promise_batch_action_deploy_contract(
                        id,
                        code.len() as _,
                        code.as_ptr() as _,
                    );
                }
                PromiseAction::FunctionCall {
                    name,
                    gas,
                    attached_yocto,
                    args,
                } => {
                    let method_name = name.as_bytes();
                    let arguments = args.as_slice();
                    let amount = attached_yocto.as_u128();
                    exports::promise_batch_action_function_call(
                        id,
                        method_name.len() as _,
                        method_name.as_ptr() as _,
                        arguments.len() as _,
                        arguments.as_ptr() as _,
                        &amount as *const u128 as _,
                        gas.as_u64(),
                    )
                }
                PromiseAction::Stake { amount, public_key } => {
                    feature_gated!("all-promise-actions", {
                        let amount = amount.as_u128();
                        let pk: RawPublicKey = public_key.into();
                        let pk_bytes = pk.as_bytes();
                        exports::promise_batch_action_stake(
                            id,
                            &amount as *const u128 as _,
                            pk_bytes.len() as _,
                            pk_bytes.as_ptr() as _,
                        )
                    });
                }
                PromiseAction::AddFullAccessKey { public_key, nonce } => {
                    feature_gated!("all-promise-actions", {
                        let pk: RawPublicKey = public_key.into();
                        let pk_bytes = pk.as_bytes();
                        exports::promise_batch_action_add_key_with_full_access(
                            id,
                            pk_bytes.len() as _,
                            pk_bytes.as_ptr() as _,
                            *nonce,
                        )
                    });
                }
                PromiseAction::AddFunctionCallKey {
                    public_key,
                    nonce,
                    allowance,
                    receiver_id,
                    function_names,
                } => {
                    feature_gated!("all-promise-actions", {
                        let pk: RawPublicKey = public_key.into();
                        let pk_bytes = pk.as_bytes();
                        let allowance = allowance.as_u128();
                        let receiver_id = receiver_id.as_bytes();
                        let function_names = function_names.as_bytes();
                        exports::promise_batch_action_add_key_with_function_call(
                            id,
                            pk_bytes.len() as _,
                            pk_bytes.as_ptr() as _,
                            *nonce,
                            &allowance as *const u128 as _,
                            receiver_id.len() as _,
                            receiver_id.as_ptr() as _,
                            function_names.len() as _,
                            function_names.as_ptr() as _,
                        )
                    });
                }
                PromiseAction::DeleteKey { public_key } => {
                    feature_gated!("all-promise-actions", {
                        let pk: RawPublicKey = public_key.into();
                        let pk_bytes = pk.as_bytes();
                        exports::promise_batch_action_delete_key(
                            id,
                            pk_bytes.len() as _,
                            pk_bytes.as_ptr() as _,
                        )
                    });
                }
                PromiseAction::DeleteAccount { beneficiary_id } => {
                    feature_gated!("all-promise-actions", {
                        let beneficiary_id = beneficiary_id.as_bytes();
                        exports::promise_batch_action_delete_key(
                            id,
                            beneficiary_id.len() as _,
                            beneficiary_id.as_ptr() as _,
                        )
                    });
                }
            }
        }

        PromiseId::new(id)
    }

    fn promise_return(&mut self, promise: PromiseId) {
        unsafe {
            exports::promise_return(promise.raw());
        }
    }

    fn read_only(&self) -> Self::ReadOnly {
        Self
    }
}

/// Similar to NearPublicKey, except the first byte includes
/// the curve identifier.
enum RawPublicKey {
    Ed25519([u8; 33]),
    Secp256k1([u8; 65]),
}

impl RawPublicKey {
    fn as_bytes(&self) -> &[u8] {
        match self {
            Self::Ed25519(bytes) => bytes,
            Self::Secp256k1(bytes) => bytes,
        }
    }
}

impl<'a> From<&'a NearPublicKey> for RawPublicKey {
    fn from(key: &'a NearPublicKey) -> Self {
        match key {
            NearPublicKey::Ed25519(bytes) => {
                let mut buf = [0u8; 33];
                buf[1..33].copy_from_slice(bytes);
                Self::Ed25519(buf)
            }
            NearPublicKey::Secp256k1(bytes) => {
                let mut buf = [0u8; 65];
                buf[0] = 0x01;
                buf[1..65].copy_from_slice(bytes);
                Self::Secp256k1(buf)
            }
        }
    }
}

/// Some host functions are not usable in NEAR view calls.
/// This struct puts in default values for those calls instead.
pub struct ViewEnv;

impl crate::env::Env for ViewEnv {
    fn signer_account_id(&self) -> AccountId {
        AccountId::new("system").unwrap()
    }

    fn current_account_id(&self) -> AccountId {
        unsafe {
            exports::current_account_id(Runtime::ENV_REGISTER_ID.0);
        }
        Runtime::read_account_id()
    }

    fn predecessor_account_id(&self) -> AccountId {
        AccountId::new("system").unwrap()
    }

    fn block_height(&self) -> u64 {
        unsafe { exports::block_index() }
    }

    fn block_timestamp(&self) -> crate::env::Timestamp {
        let ns = unsafe { exports::block_timestamp() };
        crate::env::Timestamp::new(ns)
    }

    fn attached_deposit(&self) -> u128 {
        1
    }

    fn random_seed(&self) -> H256 {
        unsafe {
            exports::random_seed(0);
            let bytes = H256::zero();
            exports::read_register(0, bytes.0.as_ptr() as *const u64 as u64);
            bytes
        }
    }

    fn prepaid_gas(&self) -> NearGas {
        NearGas::new(300)
    }
}

pub(crate) mod exports {
    #[allow(unused)]
    extern "C" {
        // #############
        // # Registers #
        // #############
        pub(crate) fn read_register(register_id: u64, ptr: u64);
        pub(crate) fn register_len(register_id: u64) -> u64;
        // ###############
        // # Context API #
        // ###############
        pub(crate) fn current_account_id(register_id: u64);
        pub(crate) fn signer_account_id(register_id: u64);
        pub(crate) fn signer_account_pk(register_id: u64);
        pub(crate) fn predecessor_account_id(register_id: u64);
        pub(crate) fn input(register_id: u64);
        // TODO #1903 fn block_height() -> u64;
        pub(crate) fn block_index() -> u64;
        pub(crate) fn block_timestamp() -> u64;
        fn epoch_height() -> u64;
        pub(crate) fn storage_usage() -> u64;
        // #################
        // # Economics API #
        // #################
        fn account_balance(balance_ptr: u64);
        pub(crate) fn attached_deposit(balance_ptr: u64);
        pub(crate) fn prepaid_gas() -> u64;
        fn used_gas() -> u64;
        // ############
        // # Math API #
        // ############
        pub(crate) fn random_seed(register_id: u64);
        pub(crate) fn sha256(value_len: u64, value_ptr: u64, register_id: u64);
        pub(crate) fn keccak256(value_len: u64, value_ptr: u64, register_id: u64);
        pub(crate) fn ripemd160(value_len: u64, value_ptr: u64, register_id: u64);
        pub(crate) fn ecrecover(
            hash_len: u64,
            hash_ptr: u64,
            sig_len: u64,
            sig_ptr: u64,
            v: u64,
            malleability_flag: u64,
            register_id: u64,
        ) -> u64;
        pub(crate) fn alt_bn128_g1_sum(value_len: u64, value_ptr: u64, register_id: u64);
        pub(crate) fn alt_bn128_g1_multiexp(value_len: u64, value_ptr: u64, register_id: u64);
        pub(crate) fn alt_bn128_pairing_check(value_len: u64, value_ptr: u64) -> u64;
        // #####################
        // # Miscellaneous API #
        // #####################
        pub(crate) fn value_return(value_len: u64, value_ptr: u64);
        pub(crate) fn panic();
        pub(crate) fn panic_utf8(len: u64, ptr: u64);
        pub(crate) fn log_utf8(len: u64, ptr: u64);
        fn log_utf16(len: u64, ptr: u64);
        fn abort(msg_ptr: u32, filename_ptr: u32, line: u32, col: u32);
        // ################
        // # Promises API #
        // ################
        pub(crate) fn promise_create(
            account_id_len: u64,
            account_id_ptr: u64,
            method_name_len: u64,
            method_name_ptr: u64,
            arguments_len: u64,
            arguments_ptr: u64,
            amount_ptr: u64,
            gas: u64,
        ) -> u64;
        pub(crate) fn promise_then(
            promise_index: u64,
            account_id_len: u64,
            account_id_ptr: u64,
            method_name_len: u64,
            method_name_ptr: u64,
            arguments_len: u64,
            arguments_ptr: u64,
            amount_ptr: u64,
            gas: u64,
        ) -> u64;
        fn promise_and(promise_idx_ptr: u64, promise_idx_count: u64) -> u64;
        pub(crate) fn promise_batch_create(account_id_len: u64, account_id_ptr: u64) -> u64;
        fn promise_batch_then(promise_index: u64, account_id_len: u64, account_id_ptr: u64) -> u64;
        // #######################
        // # Promise API actions #
        // #######################
        pub(crate) fn promise_batch_action_create_account(promise_index: u64);
        pub(crate) fn promise_batch_action_deploy_contract(
            promise_index: u64,
            code_len: u64,
            code_ptr: u64,
        );
        pub(crate) fn promise_batch_action_function_call(
            promise_index: u64,
            method_name_len: u64,
            method_name_ptr: u64,
            arguments_len: u64,
            arguments_ptr: u64,
            amount_ptr: u64,
            gas: u64,
        );
        pub(crate) fn promise_batch_action_transfer(promise_index: u64, amount_ptr: u64);
        pub(crate) fn promise_batch_action_stake(
            promise_index: u64,
            amount_ptr: u64,
            public_key_len: u64,
            public_key_ptr: u64,
        );
        pub(crate) fn promise_batch_action_add_key_with_full_access(
            promise_index: u64,
            public_key_len: u64,
            public_key_ptr: u64,
            nonce: u64,
        );
        pub(crate) fn promise_batch_action_add_key_with_function_call(
            promise_index: u64,
            public_key_len: u64,
            public_key_ptr: u64,
            nonce: u64,
            allowance_ptr: u64,
            receiver_id_len: u64,
            receiver_id_ptr: u64,
            method_names_len: u64,
            method_names_ptr: u64,
        );
        pub(crate) fn promise_batch_action_delete_key(
            promise_index: u64,
            public_key_len: u64,
            public_key_ptr: u64,
        );
        pub(crate) fn promise_batch_action_delete_account(
            promise_index: u64,
            beneficiary_id_len: u64,
            beneficiary_id_ptr: u64,
        );
        // #######################
        // # Promise API results #
        // #######################
        pub(crate) fn promise_results_count() -> u64;
        pub(crate) fn promise_result(result_idx: u64, register_id: u64) -> u64;
        pub(crate) fn promise_return(promise_id: u64);
        // ###############
        // # Storage API #
        // ###############
        pub(crate) fn storage_write(
            key_len: u64,
            key_ptr: u64,
            value_len: u64,
            value_ptr: u64,
            register_id: u64,
        ) -> u64;
        pub(crate) fn storage_read(key_len: u64, key_ptr: u64, register_id: u64) -> u64;
        pub(crate) fn storage_remove(key_len: u64, key_ptr: u64, register_id: u64) -> u64;
        pub(crate) fn storage_has_key(key_len: u64, key_ptr: u64) -> u64;
        fn storage_iter_prefix(prefix_len: u64, prefix_ptr: u64) -> u64;
        fn storage_iter_range(start_len: u64, start_ptr: u64, end_len: u64, end_ptr: u64) -> u64;
        fn storage_iter_next(iterator_id: u64, key_register_id: u64, value_register_id: u64)
            -> u64;
        // ###############
        // # Validator API #
        // ###############
        fn validator_stake(account_id_len: u64, account_id_ptr: u64, stake_ptr: u64);
        fn validator_total_stake(stake_ptr: u64);
    }
}

'''
'''--- aurora-engine-2.8.1/engine-sdk/src/prelude.rs ---
pub use aurora_engine_types::types::{Address, NearGas, PromiseResult, STORAGE_PRICE_PER_BYTE};
pub use aurora_engine_types::{vec, Vec, H256, U256};
pub use borsh::{BorshDeserialize, BorshSerialize};

'''
'''--- aurora-engine-2.8.1/engine-sdk/src/promise.rs ---
use aurora_engine_types::parameters::{
    PromiseBatchAction, PromiseCreateArgs, PromiseWithCallbackArgs,
};
use aurora_engine_types::types::PromiseResult;

#[derive(Debug, Eq, PartialEq, Copy, Clone)]
pub struct PromiseId(u64);

impl PromiseId {
    pub fn new(id: u64) -> Self {
        Self(id)
    }

    pub fn raw(self) -> u64 {
        self.0
    }
}

pub trait PromiseHandler {
    type ReadOnly: ReadOnlyPromiseHandler;

    fn promise_results_count(&self) -> u64;
    fn promise_result(&self, index: u64) -> Option<PromiseResult>;

    /// # Safety
    /// Creating calls to other contracts using the Engine account is dangerous because
    /// it has special admin privileges (especially with itself), for example minting
    /// bridged tokens. Therefore, this function must be used with extreme caution to prevent
    /// security vulnerabilities. In particular, it must not be possible for users to execute
    /// arbitrary calls using the Engine.
    unsafe fn promise_create_call(&mut self, args: &PromiseCreateArgs) -> PromiseId;

    /// # Safety
    /// See note on `promise_create_call`.
    unsafe fn promise_attach_callback(
        &mut self,
        base: PromiseId,
        callback: &PromiseCreateArgs,
    ) -> PromiseId;

    /// # Safety
    /// See note on `promise_create_call`. Promise batches in particular must be used very
    /// carefully because they can take destructive actions such as deploying new contract
    /// code or adding/removing access keys.
    unsafe fn promise_create_batch(&mut self, args: &PromiseBatchAction) -> PromiseId;

    fn promise_return(&mut self, promise: PromiseId);

    /// # Safety
    /// See note on `promise_create_call`.
    unsafe fn promise_create_with_callback(&mut self, args: &PromiseWithCallbackArgs) -> PromiseId {
        let base = self.promise_create_call(&args.base);
        self.promise_attach_callback(base, &args.callback)
    }

    fn read_only(&self) -> Self::ReadOnly;
}

pub trait ReadOnlyPromiseHandler {
    fn ro_promise_results_count(&self) -> u64;
    fn ro_promise_result(&self, index: u64) -> Option<PromiseResult>;
}

impl<T: PromiseHandler> ReadOnlyPromiseHandler for T {
    fn ro_promise_results_count(&self) -> u64 {
        self.promise_results_count()
    }

    fn ro_promise_result(&self, index: u64) -> Option<PromiseResult> {
        self.promise_result(index)
    }
}

/// A promise handler which does nothing. Should only be used when promises can be safely ignored.
#[derive(Debug, Copy, Clone)]
pub struct Noop;

impl PromiseHandler for Noop {
    type ReadOnly = Self;

    fn promise_results_count(&self) -> u64 {
        0
    }

    fn promise_result(&self, _index: u64) -> Option<PromiseResult> {
        None
    }

    unsafe fn promise_create_call(&mut self, _args: &PromiseCreateArgs) -> PromiseId {
        PromiseId::new(0)
    }

    unsafe fn promise_attach_callback(
        &mut self,
        _base: PromiseId,
        _callback: &PromiseCreateArgs,
    ) -> PromiseId {
        PromiseId::new(0)
    }

    unsafe fn promise_create_batch(&mut self, _args: &PromiseBatchAction) -> PromiseId {
        PromiseId::new(0)
    }

    fn promise_return(&mut self, _promise: PromiseId) {}

    fn read_only(&self) -> Self::ReadOnly {
        Self
    }
}

'''
'''--- aurora-engine-2.8.1/engine-sdk/src/types.rs ---
#[cfg(feature = "contract")]
use crate::io::IO;
use crate::prelude::{Address, H256};

#[cfg(not(feature = "contract"))]
use sha3::{Digest, Keccak256};

#[cfg(feature = "contract")]
#[inline]
pub fn keccak(input: &[u8]) -> H256 {
    unsafe {
        super::exports::keccak256(input.len() as u64, input.as_ptr() as u64, 1);
        let bytes = H256::zero();
        super::exports::read_register(1, bytes.0.as_ptr() as *const u64 as u64);
        bytes
    }
}

#[cfg(not(feature = "contract"))]
#[inline]
pub fn keccak(data: &[u8]) -> H256 {
    H256::from_slice(Keccak256::digest(data).as_slice())
}

pub fn near_account_to_evm_address(addr: &[u8]) -> Address {
    Address::try_from_slice(&keccak(addr)[12..]).unwrap()
}

#[cfg(feature = "contract")]
pub trait ExpectUtf8<T> {
    fn expect_utf8(self, message: &[u8]) -> T;
}

#[cfg(feature = "contract")]
impl<T> ExpectUtf8<T> for Option<T> {
    fn expect_utf8(self, message: &[u8]) -> T {
        match self {
            Some(t) => t,
            None => crate::panic_utf8(message),
        }
    }
}

#[cfg(feature = "contract")]
impl<T, E> ExpectUtf8<T> for core::result::Result<T, E> {
    fn expect_utf8(self, message: &[u8]) -> T {
        match self {
            Ok(t) => t,
            Err(_) => crate::panic_utf8(message),
        }
    }
}

#[cfg(feature = "contract")]
pub trait SdkExpect<T> {
    fn sdk_expect(self, msg: &str) -> T;
}

#[cfg(feature = "contract")]
impl<T> SdkExpect<T> for Option<T> {
    fn sdk_expect(self, msg: &str) -> T {
        match self {
            Some(t) => t,
            None => crate::panic_utf8(msg.as_ref()),
        }
    }
}

#[cfg(feature = "contract")]
impl<T, E> SdkExpect<T> for core::result::Result<T, E> {
    fn sdk_expect(self, msg: &str) -> T {
        match self {
            Ok(t) => t,
            Err(_) => crate::panic_utf8(msg.as_ref()),
        }
    }
}

#[cfg(feature = "contract")]
pub trait SdkUnwrap<T> {
    fn sdk_unwrap(self) -> T;
}

#[cfg(feature = "contract")]
impl<T> SdkUnwrap<T> for Option<T> {
    fn sdk_unwrap(self) -> T {
        match self {
            Some(t) => t,
            None => crate::panic_utf8("ERR_UNWRAP".as_bytes()),
        }
    }
}

#[cfg(feature = "contract")]
impl<T, E: AsRef<[u8]>> SdkUnwrap<T> for core::result::Result<T, E> {
    fn sdk_unwrap(self) -> T {
        match self {
            Ok(t) => t,
            Err(e) => crate::panic_utf8(e.as_ref()),
        }
    }
}

#[cfg(feature = "contract")]
pub trait SdkProcess<T> {
    fn sdk_process(self);
}

#[cfg(feature = "contract")]
impl<T: AsRef<[u8]>, E: AsRef<[u8]>> SdkProcess<T> for Result<T, E> {
    fn sdk_process(self) {
        match self {
            Ok(r) => crate::near_runtime::Runtime.return_output(r.as_ref()),
            Err(e) => crate::panic_utf8(e.as_ref()),
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/Cargo.toml ---
[package]
name = "engine-standalone-storage"
version = "0.1.0"
edition = "2021"
authors = ["Aurora Labs <hello@aurora.dev>"]
description = "Aurora engine standalone storage library. Provides the storage backend used by the standalone engine."
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "CC0-1.0"
publish = false
autobenches = false

[lib]
crate-type = ["lib"]

[dependencies]
aurora-engine = { path = "../engine", default-features = false, features = ["std"] }
aurora-engine-types = { path = "../engine-types", default-features = false, features = ["std"] }
aurora-engine-sdk = { path = "../engine-sdk", default-features = false, features = ["std"] }
aurora-engine-transactions = { path = "../engine-transactions", default-features = false, features = ["std"] }
aurora-engine-precompiles = { path = "../engine-precompiles", default-features = false, features = ["std"] }
borsh = { version = "0.9.3" }
evm-core = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false }
hex = "0.4.3"
rocksdb = { version = "0.19.0", default-features = false }
postgres = "0.19.2"
serde = "1.0.130"
serde_json = "1.0.72"
base64 = "0.13.0"

[features]
default = ["snappy", "lz4", "zstd", "zlib"]
mainnet = []
testnet = []
snappy = ["rocksdb/snappy"]
lz4 = ["rocksdb/lz4"]
zstd = ["rocksdb/zstd"]
zlib = ["rocksdb/zlib"]
bzip2 = ["rocksdb/bzip2"]

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/diff.rs ---
use borsh::{BorshDeserialize, BorshSerialize};
use std::collections::{btree_map, BTreeMap};

#[derive(Debug, Default, Clone, BorshDeserialize, BorshSerialize, PartialEq, Eq)]
/// Collection of Engine state keys which changed by executing a transaction.
pub struct Diff(BTreeMap<Vec<u8>, DiffValue>);

#[derive(Debug, Clone, BorshDeserialize, BorshSerialize, PartialEq, Eq)]
pub enum DiffValue {
    Modified(Vec<u8>),
    Deleted,
}

impl DiffValue {
    pub fn value(&self) -> Option<&[u8]> {
        match self {
            Self::Deleted => None,
            Self::Modified(new_value) => Some(new_value.as_slice()),
        }
    }

    pub fn take_value(self) -> Option<Vec<u8>> {
        match self {
            Self::Deleted => None,
            Self::Modified(new_value) => Some(new_value),
        }
    }

    pub fn try_to_bytes(&self) -> Result<Vec<u8>, std::io::Error> {
        self.try_to_vec()
    }

    pub fn try_from_bytes(bytes: &[u8]) -> Result<Self, std::io::Error> {
        Self::try_from_slice(bytes)
    }
}

impl Diff {
    /// Compose two Diffs into a single one. If there is a conflict between them
    /// then the value from the given (`other`) Diff is kept.
    pub fn append(&mut self, mut other: Self) {
        self.0.append(&mut other.0);
    }

    pub fn modify(&mut self, key: Vec<u8>, value: Vec<u8>) {
        self.0.insert(key, DiffValue::Modified(value));
    }

    pub fn delete(&mut self, key: Vec<u8>) {
        self.0.insert(key, DiffValue::Deleted);
    }

    pub fn clear(&mut self) {
        self.0.clear()
    }

    pub fn get(&self, key: &[u8]) -> Option<&DiffValue> {
        self.0.get(key)
    }

    pub fn take(&mut self, key: &[u8]) -> Option<DiffValue> {
        self.0.remove(key)
    }

    pub fn iter(&self) -> btree_map::Iter<Vec<u8>, DiffValue> {
        self.0.iter()
    }

    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    pub fn try_to_bytes(&self) -> Result<Vec<u8>, std::io::Error> {
        self.try_to_vec()
    }

    pub fn try_from_bytes(bytes: &[u8]) -> Result<Self, std::io::Error> {
        Self::try_from_slice(bytes)
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/engine_state.rs ---
use aurora_engine_sdk::io::{StorageIntermediate, IO};
use rocksdb::DB;
use std::cell::{Cell, RefCell};

use crate::diff::{Diff, DiffValue};
use crate::StoragePrefix;

#[derive(Debug)]
pub enum EngineStorageValue<'a> {
    Slice(&'a [u8]),
    Vec(Vec<u8>),
}

impl<'a> AsRef<[u8]> for EngineStorageValue<'a> {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::Slice(slice) => slice,
            Self::Vec(bytes) => bytes,
        }
    }
}

impl<'a> StorageIntermediate for EngineStorageValue<'a> {
    fn len(&self) -> usize {
        self.as_ref().len()
    }

    fn is_empty(&self) -> bool {
        self.as_ref().is_empty()
    }

    fn copy_to_slice(&self, buffer: &mut [u8]) {
        buffer.copy_from_slice(self.as_ref())
    }
}

#[derive(Copy, Clone)]
pub struct EngineStateAccess<'db, 'input, 'output> {
    input: &'input [u8],
    bound_block_height: u64,
    bound_tx_position: u16,
    transaction_diff: &'output RefCell<Diff>,
    output: &'output Cell<Vec<u8>>,
    db: &'db DB,
}

impl<'db, 'input, 'output> EngineStateAccess<'db, 'input, 'output> {
    pub fn new(
        input: &'input [u8],
        bound_block_height: u64,
        bound_tx_position: u16,
        transaction_diff: &'output RefCell<Diff>,
        output: &'output Cell<Vec<u8>>,
        db: &'db DB,
    ) -> Self {
        Self {
            input,
            bound_block_height,
            bound_tx_position,
            transaction_diff,
            output,
            db,
        }
    }

    pub fn get_transaction_diff(&self) -> Diff {
        self.transaction_diff.borrow().clone()
    }

    fn construct_engine_read(&self, key: &[u8]) -> rocksdb::ReadOptions {
        let upper_bound =
            super::construct_engine_key(key, self.bound_block_height, self.bound_tx_position);
        let lower_bound = super::construct_storage_key(StoragePrefix::Engine, key);
        let mut opt = rocksdb::ReadOptions::default();
        opt.set_iterate_upper_bound(upper_bound);
        opt.set_iterate_lower_bound(lower_bound);
        opt
    }
}

impl<'db, 'input: 'db, 'output: 'db> IO for EngineStateAccess<'db, 'input, 'output> {
    type StorageValue = EngineStorageValue<'db>;

    fn read_input(&self) -> Self::StorageValue {
        EngineStorageValue::Slice(self.input)
    }

    fn return_output(&mut self, value: &[u8]) {
        self.output.set(value.to_vec())
    }

    fn read_storage(&self, key: &[u8]) -> Option<Self::StorageValue> {
        if let Some(diff) = self.transaction_diff.borrow().get(key) {
            return diff
                .value()
                .map(|bytes| EngineStorageValue::Vec(bytes.to_vec()));
        }

        let opt = self.construct_engine_read(key);
        let mut iter = self.db.iterator_opt(rocksdb::IteratorMode::End, opt);
        let value = iter.next().and_then(|maybe_elem| {
            maybe_elem
                .ok()
                .map(|(_, value)| DiffValue::try_from_bytes(&value).unwrap())
        })?;
        value.take_value().map(EngineStorageValue::Vec)
    }

    fn storage_has_key(&self, key: &[u8]) -> bool {
        self.read_storage(key).is_some()
    }

    fn write_storage(&mut self, key: &[u8], value: &[u8]) -> Option<Self::StorageValue> {
        let original_value = self.read_storage(key);

        self.transaction_diff
            .borrow_mut()
            .modify(key.to_vec(), value.to_vec());

        original_value
    }

    fn write_storage_direct(
        &mut self,
        key: &[u8],
        value: Self::StorageValue,
    ) -> Option<Self::StorageValue> {
        self.write_storage(key, value.as_ref())
    }

    fn remove_storage(&mut self, key: &[u8]) -> Option<Self::StorageValue> {
        let original_value = self.read_storage(key);

        self.transaction_diff.borrow_mut().delete(key.to_vec());

        original_value
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/error.rs ---
use aurora_engine_types::H256;

use crate::TransactionIncluded;

#[derive(Debug, PartialEq, Clone)]
pub enum Error {
    BlockNotFound(H256),
    Borsh(String),
    NoBlockAtHeight(u64),
    TransactionNotFound(TransactionIncluded),
    TransactionHashNotFound(H256),
    Rocksdb(rocksdb::Error),
    EngineAccountIdNotSet,
    EngineAccountIdCorrupted,
}

impl From<rocksdb::Error> for Error {
    fn from(e: rocksdb::Error) -> Self {
        Self::Rocksdb(e)
    }
}

impl From<std::io::Error> for Error {
    fn from(e: std::io::Error) -> Self {
        Self::Borsh(e.to_string())
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/json_snapshot/mod.rs ---
use crate::Storage;

pub mod types;

/// Write engine state directly into the Storage from a
/// JSON snapshot (which can be extracted from a NEAR RPC node).
pub fn initialize_engine_state(
    storage: &mut Storage,
    snapshot: types::JsonSnapshot,
) -> Result<(), error::Error> {
    // The snapshot is giving us a post-state, so we insert it right at the end of its block height.
    let block_height = snapshot.result.block_height;
    let transaction_position = u16::MAX;

    let mut batch = rocksdb::WriteBatch::default();
    for entry in snapshot.result.values {
        let key = base64::decode(entry.key)?;
        let value = base64::decode(entry.value)?;
        let storage_key = crate::construct_engine_key(&key, block_height, transaction_position);
        let storage_value = crate::diff::DiffValue::Modified(value);
        batch.put(storage_key, storage_value.try_to_bytes()?);
    }
    storage.db.write(batch)?;

    Ok(())
}

pub mod error {
    #[derive(Debug)]
    pub enum Error {
        Base64(base64::DecodeError),
        Rocksdb(rocksdb::Error),
        Borsh(std::io::Error),
    }

    impl From<base64::DecodeError> for Error {
        fn from(e: base64::DecodeError) -> Self {
            Self::Base64(e)
        }
    }

    impl From<rocksdb::Error> for Error {
        fn from(e: rocksdb::Error) -> Self {
            Self::Rocksdb(e)
        }
    }

    impl From<std::io::Error> for Error {
        fn from(e: std::io::Error) -> Self {
            Self::Borsh(e)
        }
    }
}

#[cfg(test)]
mod test {
    /// Requires a JSON snapshot to work. This can be obtained from https://github.com/aurora-is-near/contract-state
    #[test]
    #[ignore]
    fn test_consume_snapshot() {
        let snapshot = crate::json_snapshot::types::JsonSnapshot::load_from_file(
            "contract.aurora.block51077328.json",
        )
        .unwrap();
        let mut storage = crate::Storage::open("rocks_tmp/").unwrap();
        super::initialize_engine_state(&mut storage, snapshot).unwrap();
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/json_snapshot/types.rs ---
use serde::{Deserialize, Serialize};
use std::path::Path;

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonSnapshot {
    pub id: String,
    pub jsonrpc: String,
    pub result: JsonSnapshotResult,
}

impl JsonSnapshot {
    pub fn load_from_file<P: AsRef<Path>>(path: P) -> Result<Self, Box<dyn std::error::Error>> {
        let file = std::fs::File::open(path)?;
        let reader = std::io::BufReader::new(file);
        let snapshot = serde_json::from_reader(reader)?;
        Ok(snapshot)
    }
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonSnapshotResult {
    /// Base 64 encoding of the block hash
    pub block_hash: String,
    pub block_height: u64,
    /// See https://github.com/near/nearcore/blob/2bc63c60afe202e7c78a67176a4e267b8c0fb48f/core/primitives/src/views.rs#L201-L202.
    pub proof: Vec<String>,
    pub values: Vec<JsonSnapshotValue>,
}

#[derive(Serialize, Deserialize, Debug, Clone)]
pub struct JsonSnapshotValue {
    /// Base 64 encoding of the key
    pub key: String,
    /// See https://github.com/near/nearcore/blob/2bc63c60afe202e7c78a67176a4e267b8c0fb48f/core/primitives/src/views.rs#L201-L202.
    pub proof: Vec<String>,
    /// Base 64 encoding of the value
    pub value: String,
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/lib.rs ---
use aurora_engine_sdk::env::Timestamp;
use aurora_engine_types::{account_id::AccountId, H256};
use rocksdb::DB;
use std::cell::{Cell, RefCell};
use std::collections::HashMap;
use std::path::Path;
use sync::types::TransactionMessage;

const VERSION: u8 = 0;

pub mod diff;
pub mod engine_state;
pub mod error;
pub mod json_snapshot;
pub mod promise;
pub mod relayer_db;
/// Functions for receiving new blocks and transactions to keep the storage up to date.
pub mod sync;

pub use diff::{Diff, DiffValue};
pub use error::Error;

/// Length (in bytes) of the suffix appended to Engine keys which specify the
/// block height and transaction position. 64 bits for the block height,
/// 16 bits for the transaction position.
const ENGINE_KEY_SUFFIX_LEN: usize = (64 / 8) + (16 / 8);

#[repr(u8)]
pub enum StoragePrefix {
    BlockHash = 0x00,
    BlockHeight = 0x01,
    TransactionData = 0x02,
    TransactionHash = 0x03,
    Diff = 0x04,
    Engine = 0x05,
    BlockMetadata = 0x06,
    EngineAccountId = 0x07,
}

const ACCOUNT_ID_KEY: &[u8] = b"engine_account_id";

pub struct Storage {
    db: DB,
}

impl Storage {
    pub fn open<P: AsRef<Path>>(path: P) -> Result<Self, rocksdb::Error> {
        let db = DB::open_default(path)?;
        Ok(Self { db })
    }

    pub fn set_engine_account_id(&mut self, id: &AccountId) -> Result<(), rocksdb::Error> {
        let key = construct_storage_key(StoragePrefix::EngineAccountId, ACCOUNT_ID_KEY);
        self.db.put(key, id.as_bytes())
    }

    pub fn get_engine_account_id(&self) -> Result<AccountId, error::Error> {
        let key = construct_storage_key(StoragePrefix::EngineAccountId, ACCOUNT_ID_KEY);
        let slice = self
            .db
            .get_pinned(key)?
            .ok_or(Error::EngineAccountIdNotSet)?;
        let account_id =
            AccountId::try_from(slice.as_ref()).map_err(|_| Error::EngineAccountIdCorrupted)?;
        Ok(account_id)
    }

    pub fn get_latest_block(&self) -> Result<(H256, u64), error::Error> {
        self.block_read(rocksdb::IteratorMode::End)
    }

    pub fn get_earliest_block(&self) -> Result<(H256, u64), error::Error> {
        self.block_read(rocksdb::IteratorMode::Start)
    }

    fn block_read(&self, mode: rocksdb::IteratorMode) -> Result<(H256, u64), error::Error> {
        let upper_bound = construct_storage_key(StoragePrefix::BlockHash, &u64::MAX.to_be_bytes());
        let lower_bound = construct_storage_key(StoragePrefix::BlockHash, &[]);
        let prefix_len = lower_bound.len();
        let mut opt = rocksdb::ReadOptions::default();
        opt.set_iterate_upper_bound(upper_bound);
        opt.set_iterate_lower_bound(lower_bound);

        let mut iter = self.db.iterator_opt(mode, opt);
        let (key, value) = iter.next().ok_or(error::Error::NoBlockAtHeight(0))??;
        let block_height = {
            let mut buf = [0u8; 8];
            buf.copy_from_slice(&key[prefix_len..]);
            u64::from_be_bytes(buf)
        };
        let block_hash = H256::from_slice(&value);
        Ok((block_hash, block_height))
    }

    pub fn get_block_hash_by_height(&self, block_height: u64) -> Result<H256, error::Error> {
        let storage_key =
            construct_storage_key(StoragePrefix::BlockHash, &block_height.to_be_bytes());
        self.db
            .get_pinned(storage_key)?
            .map(|slice| H256::from_slice(slice.as_ref()))
            .ok_or(error::Error::NoBlockAtHeight(block_height))
    }

    pub fn get_block_height_by_hash(&self, block_hash: H256) -> Result<u64, error::Error> {
        let storage_key = construct_storage_key(StoragePrefix::BlockHeight, block_hash.as_ref());
        self.db
            .get_pinned(storage_key)?
            .map(|slice| {
                let mut buf = [0u8; 8];
                buf.copy_from_slice(slice.as_ref());
                u64::from_be_bytes(buf)
            })
            .ok_or(error::Error::BlockNotFound(block_hash))
    }

    pub fn get_block_metadata(&self, block_hash: H256) -> Result<BlockMetadata, error::Error> {
        let storage_key = construct_storage_key(StoragePrefix::BlockMetadata, block_hash.as_ref());
        self.db
            .get_pinned(storage_key)?
            .map(|slice| {
                let mut buf = [0u8; 40];
                buf.copy_from_slice(slice.as_ref());
                BlockMetadata::from_bytes(buf)
            })
            .ok_or(error::Error::BlockNotFound(block_hash))
    }

    pub fn set_block_data(
        &mut self,
        block_hash: H256,
        block_height: u64,
        block_metadata: BlockMetadata,
    ) -> Result<(), rocksdb::Error> {
        let block_height_bytes = block_height.to_be_bytes();

        let mut batch = rocksdb::WriteBatch::default();

        let storage_key = construct_storage_key(StoragePrefix::BlockHash, &block_height_bytes);
        batch.put(storage_key, block_hash);

        let storage_key = construct_storage_key(StoragePrefix::BlockHeight, block_hash.as_ref());
        batch.put(storage_key, block_height_bytes);

        let storage_key = construct_storage_key(StoragePrefix::BlockMetadata, block_hash.as_ref());
        batch.put(storage_key, block_metadata.to_bytes());

        self.db.write(batch)
    }

    pub fn get_transaction_data(
        &self,
        tx_hash: H256,
    ) -> Result<sync::types::TransactionMessage, error::Error> {
        let storage_key = construct_storage_key(StoragePrefix::TransactionData, tx_hash.as_ref());
        let bytes = self
            .db
            .get_pinned(storage_key)?
            .ok_or(error::Error::TransactionHashNotFound(tx_hash))?;
        let message = TransactionMessage::try_from_slice(bytes.as_ref())?;
        Ok(message)
    }

    pub fn get_transaction_by_position(
        &self,
        tx_included: TransactionIncluded,
    ) -> Result<H256, error::Error> {
        let storage_key =
            construct_storage_key(StoragePrefix::TransactionHash, &tx_included.to_bytes());
        self.db
            .get_pinned(storage_key)?
            .map(|slice| H256::from_slice(slice.as_ref()))
            .ok_or(error::Error::TransactionNotFound(tx_included))
    }

    pub fn get_transaction_diff(
        &self,
        tx_included: TransactionIncluded,
    ) -> Result<Diff, error::Error> {
        let storage_key = construct_storage_key(StoragePrefix::Diff, &tx_included.to_bytes());
        self.db
            .get_pinned(storage_key)?
            .map(|slice| Diff::try_from_bytes(slice.as_ref()).unwrap())
            .ok_or(error::Error::TransactionNotFound(tx_included))
    }

    pub fn set_transaction_included(
        &mut self,
        tx_hash: H256,
        tx_included: &TransactionMessage,
        diff: &Diff,
    ) -> Result<(), error::Error> {
        let batch = rocksdb::WriteBatch::default();
        self.process_transaction(tx_hash, tx_included, diff, batch, |batch, key, value| {
            batch.put(key, value)
        })
    }

    pub fn revert_transaction_included(
        &mut self,
        tx_hash: H256,
        tx_included: &TransactionMessage,
        diff: &Diff,
    ) -> Result<(), error::Error> {
        let batch = rocksdb::WriteBatch::default();
        self.process_transaction(tx_hash, tx_included, diff, batch, |batch, key, _value| {
            batch.delete(key)
        })
    }

    fn process_transaction<F: Fn(&mut rocksdb::WriteBatch, &[u8], &[u8])>(
        &mut self,
        tx_hash: H256,
        tx_msg: &TransactionMessage,
        diff: &Diff,
        mut batch: rocksdb::WriteBatch,
        action: F,
    ) -> Result<(), error::Error> {
        let tx_included = TransactionIncluded {
            block_hash: tx_msg.block_hash,
            position: tx_msg.position,
        };
        let tx_included_bytes = tx_included.to_bytes();
        let block_height = self.get_block_height_by_hash(tx_included.block_hash)?;

        let storage_key = construct_storage_key(StoragePrefix::TransactionHash, &tx_included_bytes);
        action(&mut batch, &storage_key, tx_hash.as_ref());

        let storage_key = construct_storage_key(StoragePrefix::TransactionData, tx_hash.as_ref());
        let msg_bytes = tx_msg.to_bytes();
        action(&mut batch, &storage_key, &msg_bytes);

        let storage_key = construct_storage_key(StoragePrefix::Diff, &tx_included_bytes);
        let diff_bytes = diff.try_to_bytes().unwrap();
        action(&mut batch, &storage_key, &diff_bytes);

        for (key, value) in diff.iter() {
            let storage_key = construct_engine_key(key, block_height, tx_included.position);
            let value_bytes = value.try_to_bytes().unwrap();
            action(&mut batch, &storage_key, &value_bytes);
        }

        self.db.write(batch).map_err(Into::into)
    }

    /// Returns a list of transactions that modified the key, and the values _after_ each transaction.
    pub fn track_engine_key(
        &self,
        engine_key: &[u8],
    ) -> Result<Vec<(u64, H256, DiffValue)>, error::Error> {
        let db_key_prefix = construct_storage_key(StoragePrefix::Engine, engine_key);
        let n = db_key_prefix.len();
        let iter = self.db.prefix_iterator(&db_key_prefix);
        let mut result = Vec::with_capacity(100);
        for maybe_elem in iter {
            let (k, v) = maybe_elem?;
            if k.len() < n || k[0..n] != db_key_prefix {
                break;
            }
            let value = DiffValue::try_from_bytes(v.as_ref()).unwrap();
            let block_height = {
                let mut buf = [0u8; 8];
                buf.copy_from_slice(&k[n..(n + 8)]);
                u64::from_be_bytes(buf)
            };
            let transaction_position = {
                let mut buf = [0u8; 2];
                buf.copy_from_slice(&k[(n + 8)..(n + 10)]);
                u16::from_be_bytes(buf)
            };
            let block_hash = self
                .get_block_hash_by_height(block_height)
                .unwrap_or_default();
            let tx_included = TransactionIncluded {
                block_hash,
                position: transaction_position,
            };
            let tx_hash = self
                .get_transaction_by_position(tx_included)
                .unwrap_or_default();
            result.push((block_height, tx_hash, value))
        }
        Ok(result)
    }

    /// Construct a snapshot of the Engine post-state at the given block height.
    /// I.e. get the state of the Engine after all transactions in that block have been applied.
    pub fn get_snapshot(
        &self,
        block_height: u64,
    ) -> Result<HashMap<Vec<u8>, Vec<u8>>, rocksdb::Error> {
        let engine_prefix = construct_storage_key(StoragePrefix::Engine, &[]);
        let engine_prefix_len = engine_prefix.len();
        let mut iter: rocksdb::DBRawIterator = self.db.prefix_iterator(&engine_prefix).into();
        let mut result = HashMap::new();

        while iter.valid() {
            // unwrap is safe because the iterator is valid
            let db_key = iter.key().unwrap().to_vec();
            if db_key[0..engine_prefix_len] != engine_prefix {
                break;
            }
            // raw engine key skips the 2-byte prefix and the block+position suffix
            let engine_key = &db_key[engine_prefix_len..(db_key.len() - ENGINE_KEY_SUFFIX_LEN)];
            let key_block_height = {
                let n = engine_prefix_len + engine_key.len();
                let mut buf = [0u8; 8];
                buf.copy_from_slice(&db_key[n..(n + 8)]);
                u64::from_be_bytes(buf)
            };
            // If the key was created after the block height we want then we can skip it
            if key_block_height <= block_height {
                // the key we want is the last key for this block, or the key immediately before it
                let desired_db_key = construct_engine_key(engine_key, block_height, u16::MAX);
                iter.seek_for_prev(&desired_db_key);

                let value = if iter.valid() {
                    let bytes = iter.value().unwrap();
                    diff::DiffValue::try_from_bytes(bytes).unwrap_or_else(|e| {
                        panic!(
                            "Could not deserialize key={} value={} error={:?}",
                            base64::encode(&db_key),
                            base64::encode(bytes),
                            e,
                        )
                    })
                } else {
                    break;
                };
                // only put it values that are still present (i.e. ignore deleted keys)
                if let Some(bytes) = value.take_value() {
                    result.insert(engine_key.to_vec(), bytes);
                }
            }

            // move to the next key by skipping all other DB keys corresponding to the same engine key
            while iter.valid()
                && iter
                    .key()
                    .map(|db_key| {
                        db_key[0..engine_prefix_len] == engine_prefix
                            && &db_key[engine_prefix_len..(db_key.len() - ENGINE_KEY_SUFFIX_LEN)]
                                == engine_key
                    })
                    .unwrap_or(false)
            {
                iter.next();
            }
        }

        iter.status()?;

        Ok(result)
    }

    /// Same as `access_engine_storage_at_position`, but does not modify `self`, hence the immutable
    /// borrow instead of the mutable one. The use case for this function is to execute a transaction
    /// with the engine, but not to make any immediate changes to storage; only return the diff and outcome.
    /// Note the closure is allowed to mutate the `EngineStateAccess` object, but this does not impact the `Storage`
    /// because all changes are held in the diff in memory.
    pub fn with_engine_access<'db, 'input, R, F>(
        &'db self,
        block_height: u64,
        transaction_position: u16,
        input: &'input [u8],
        f: F,
    ) -> EngineAccessResult<R>
    where
        F: for<'output> FnOnce(engine_state::EngineStateAccess<'db, 'input, 'output>) -> R,
    {
        let diff = RefCell::new(Diff::default());
        let engine_output = Cell::new(Vec::new());

        let engine_state = engine_state::EngineStateAccess::new(
            input,
            block_height,
            transaction_position,
            &diff,
            &engine_output,
            &self.db,
        );

        let result = f(engine_state);
        let diff = engine_state.get_transaction_diff();
        let engine_output = engine_output.into_inner();

        EngineAccessResult {
            result,
            engine_output,
            diff,
        }
    }
}

#[derive(Debug, Clone, Eq, PartialEq)]
pub struct EngineAccessResult<R> {
    pub result: R,
    pub engine_output: Vec<u8>,
    pub diff: Diff,
}

#[derive(Debug, Copy, Clone, Eq, PartialEq)]
pub struct TransactionIncluded {
    pub block_hash: H256,
    pub position: u16,
}

impl TransactionIncluded {
    pub fn to_bytes(self) -> [u8; 34] {
        let mut bytes = [0u8; 34];

        bytes[0..32].copy_from_slice(self.block_hash.as_ref());
        bytes[32..34].copy_from_slice(&self.position.to_be_bytes());

        bytes
    }

    pub fn from_bytes(bytes: [u8; 34]) -> Self {
        let block_hash = H256::from_slice(&bytes[0..32]);
        let mut position = [0u8; 2];
        position.copy_from_slice(&bytes[32..34]);

        Self {
            block_hash,
            position: u16::from_be_bytes(position),
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct BlockMetadata {
    pub timestamp: Timestamp,
    /// Each NEAR block has a 32-byte entropy source generated by a VRF. We need this data
    /// to execute the Aurora randomness precompile correctly because it uses this NEAR
    /// entropy source.
    pub random_seed: H256,
}

impl BlockMetadata {
    pub fn to_bytes(&self) -> [u8; 40] {
        let mut buf = [0u8; 40];
        buf[0..8].copy_from_slice(&self.timestamp.nanos().to_be_bytes());
        buf[8..40].copy_from_slice(self.random_seed.as_ref());
        buf
    }

    pub fn from_bytes(bytes: [u8; 40]) -> Self {
        let nanos = {
            let mut buf = [0u8; 8];
            buf.copy_from_slice(&bytes[0..8]);
            u64::from_be_bytes(buf)
        };
        let random_seed = {
            let mut buf = [0u8; 32];
            buf.copy_from_slice(&bytes[8..40]);
            H256(buf)
        };

        Self {
            timestamp: Timestamp::new(nanos),
            random_seed,
        }
    }
}

fn construct_storage_key(prefix: StoragePrefix, key: &[u8]) -> Vec<u8> {
    [&[VERSION], &[prefix as u8], key].concat()
}

fn construct_engine_key(key: &[u8], block_height: u64, transaction_position: u16) -> Vec<u8> {
    construct_storage_key(
        StoragePrefix::Engine,
        [
            key,
            &block_height.to_be_bytes(),
            &transaction_position.to_be_bytes(),
        ]
        .concat()
        .as_slice(),
    )
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/promise.rs ---
use aurora_engine_sdk::promise::{PromiseHandler, PromiseId};
use aurora_engine_types::parameters::{PromiseBatchAction, PromiseCreateArgs};
use aurora_engine_types::types::PromiseResult;

/// Implements `PromiseHandler` so that it can be used in the standalone engine implementation of
/// methods like `call`, however since the standalone engine cannot schedule promises in a
/// meaningful way, the mutable implementations are no-ops. Functionally, this is only an implementation
/// of `ReadOnlyPromiseHandler`, which is needed for the standalone engine to properly serve the
/// EVM precompile that gives back information on the results of promises (possibly scheduled using
/// the cross-contract calls feature).
#[derive(Debug, Clone, Copy)]
pub struct NoScheduler<'a> {
    pub promise_data: &'a [Option<Vec<u8>>],
}

impl<'a> PromiseHandler for NoScheduler<'a> {
    type ReadOnly = Self;

    fn promise_results_count(&self) -> u64 {
        u64::try_from(self.promise_data.len()).unwrap_or_default()
    }

    fn promise_result(&self, index: u64) -> Option<PromiseResult> {
        let i = usize::try_from(index).ok()?;
        let result = match self.promise_data.get(i)? {
            Some(bytes) => PromiseResult::Successful(bytes.clone()),
            None => PromiseResult::Failed,
        };
        Some(result)
    }

    unsafe fn promise_create_call(&mut self, _args: &PromiseCreateArgs) -> PromiseId {
        PromiseId::new(0)
    }

    unsafe fn promise_attach_callback(
        &mut self,
        _base: PromiseId,
        _callback: &PromiseCreateArgs,
    ) -> PromiseId {
        PromiseId::new(0)
    }

    unsafe fn promise_create_batch(&mut self, _args: &PromiseBatchAction) -> PromiseId {
        PromiseId::new(0)
    }

    fn promise_return(&mut self, _promise: PromiseId) {}

    fn read_only(&self) -> Self::ReadOnly {
        *self
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/relayer_db/mod.rs ---
use aurora_engine::engine;
use aurora_engine_sdk::env::{self, Env, DEFAULT_PREPAID_GAS};
use aurora_engine_transactions::EthTransactionKind;
use aurora_engine_types::account_id::AccountId;
use aurora_engine_types::H256;
use postgres::fallible_iterator::FallibleIterator;

use crate::{BlockMetadata, Storage};

pub mod types;

const TRANSACTION_QUERY: &str = "
SELECT
  transaction.block, transaction.index, transaction.id,
  transaction.hash, transaction.near_hash, transaction.near_receipt_hash,
  transaction.from, transaction.to, transaction.nonce, transaction.gas_price,
  transaction.gas_limit, transaction.gas_used, transaction.value, transaction.input,
  transaction.v, transaction.r, transaction.s, transaction.status, transaction.output,
  block.hash as block_hash
FROM transaction INNER JOIN block
ON transaction.block = block.id
ORDER BY transaction.block, transaction.index
";

/// Opens a Postgres connection to a running server hosting the relayer database.
pub fn connect_without_tls(
    connection_params: &types::ConnectionParams,
) -> Result<postgres::Client, postgres::Error> {
    let connection_string = connection_params.as_connection_string();
    postgres::Client::connect(&connection_string, postgres::NoTls)
}

pub fn read_block_data(
    connection: &mut postgres::Client,
) -> Result<postgres::RowIter<'_>, postgres::Error> {
    connection.query_raw::<_, u32, _>("SELECT * FROM block", std::iter::empty())
}

pub fn read_transaction_data(
    connection: &mut postgres::Client,
) -> Result<postgres::RowIter<'_>, postgres::Error> {
    connection.query_raw::<_, u32, _>(TRANSACTION_QUERY, std::iter::empty())
}

pub fn initialize_blocks<I>(storage: &mut Storage, mut rows: I) -> Result<(), error::Error>
where
    I: FallibleIterator<Item = types::BlockRow, Error = postgres::Error>,
{
    while let Some(row) = rows.next()? {
        let metadata = BlockMetadata {
            timestamp: env::Timestamp::new(row.timestamp.unwrap_or(0)),
            // TODO: need relayer to index this, tracking issue: https://github.com/aurora-is-near/aurora-relayer/issues/135
            random_seed: H256([0; 32]),
        };

        storage
            .set_block_data(row.hash, row.id, metadata)
            .map_err(crate::Error::Rocksdb)?;
    }
    Ok(())
}

pub fn initialize_transactions<I>(
    storage: &mut Storage,
    mut rows: I,
    engine_state: engine::EngineState,
) -> Result<(), error::Error>
where
    I: FallibleIterator<Item = types::TransactionRow, Error = postgres::Error>,
{
    let signer_account_id = "relayer.aurora".parse().unwrap();
    let predecessor_account_id: AccountId = "relayer.aurora".parse().unwrap();
    let current_account_id = "aurora".parse().unwrap();
    let relayer_address =
        aurora_engine_sdk::types::near_account_to_evm_address(predecessor_account_id.as_bytes());
    let mut env = env::Fixed {
        signer_account_id,
        current_account_id,
        predecessor_account_id,
        block_height: 0,
        block_timestamp: env::Timestamp::new(0),
        attached_deposit: 0,
        random_seed: H256::zero(),
        prepaid_gas: DEFAULT_PREPAID_GAS,
    };
    // We use the Noop handler here since the relayer DB does not contain any promise information.
    let mut handler = aurora_engine_sdk::promise::Noop;

    while let Some(row) = rows.next()? {
        let near_tx_hash = row.near_hash;
        let tx_succeeded = row.status;
        let transaction_position = row.index;
        let block_height = row.block;
        let block_hash = row.block_hash;
        let block_metadata = storage.get_block_metadata(block_hash)?;
        let tx: EthTransactionKind = row.into();
        let transaction_bytes: Vec<u8> = (&tx).into();
        let tx_hash = aurora_engine_sdk::keccak(&transaction_bytes);

        env.block_height = block_height;
        env.block_timestamp = block_metadata.timestamp;
        env.random_seed = block_metadata.random_seed;

        let result = storage.with_engine_access(block_height, transaction_position, &[], |io| {
            engine::submit(
                io,
                &env,
                &transaction_bytes,
                engine_state.clone(),
                env.current_account_id(),
                relayer_address,
                &mut handler,
            )
        });
        match result.result {
            // Engine errors would always turn into panics on the NEAR side, so we do not need to persist
            // any diff. Therefore, even if the error was expected, we still continue to the next transaction.
            Err(e) => {
                if tx_succeeded {
                    println!(
                        "WARN: Transaction with NEAR hash {:?} expected to succeed, but failed with error message {:?}",
                        near_tx_hash,
                        e
                    );
                }
                continue;
            }
            Ok(result) => {
                if result.status.is_fail() && tx_succeeded {
                    println!(
                        "WARN: Transaction with NEAR hash {:?} expected to succeed, but failed with error message {:?}",
                        near_tx_hash,
                        result.status
                    );
                    continue;
                }
                // if result.status.is_fail() && !tx_succeeded then this is consistent; we
                // should still persist the diff because failed transactions can impact the state.
                // For example, a transaction that runs of out of gas still has its balance deducted
                // for the gas spent. Therefore, we do not have a `continue` statement here.
            }
        }

        let diff = result.diff;
        let tx_msg = crate::TransactionMessage {
            block_hash,
            near_receipt_id: near_tx_hash,
            position: transaction_position,
            succeeded: true,
            signer: env.signer_account_id(),
            caller: env.predecessor_account_id(),
            attached_near: 0,
            transaction: crate::sync::types::TransactionKind::Submit(tx),
            promise_data: Vec::new(),
        };
        storage.set_transaction_included(tx_hash, &tx_msg, &diff)?;
    }
    Ok(())
}

pub mod error {
    use aurora_engine::engine;

    #[derive(Debug)]
    pub enum Error {
        Storage(crate::Error),
        Postgres(postgres::Error),
        EngineState(engine::EngineStateError),
        Engine(engine::EngineError),
    }

    impl From<crate::Error> for Error {
        fn from(e: crate::Error) -> Self {
            Self::Storage(e)
        }
    }

    impl From<postgres::Error> for Error {
        fn from(e: postgres::Error) -> Self {
            Self::Postgres(e)
        }
    }

    impl From<engine::EngineStateError> for Error {
        fn from(e: engine::EngineStateError) -> Self {
            Self::EngineState(e)
        }
    }

    impl From<engine::EngineError> for Error {
        fn from(e: engine::EngineError) -> Self {
            Self::Engine(e)
        }
    }
}

#[cfg(test)]
mod test {
    use super::FallibleIterator;
    use crate::sync::types::{TransactionKind, TransactionMessage};
    use aurora_engine::{connector, engine, parameters};
    use aurora_engine_types::H256;

    /// Requires a running postgres server to work. A snapshot of the DB can be
    /// downloaded using the script from https://github.com/aurora-is-near/partner-relayer-deploy
    /// The postgres DB can be started in Docker using the following command:
    /// docker run --name mainnet_database -p '127.0.0.1:15432:5432' -v $PATH_TO_DB:/var/lib/postgresql/data auroraisnear/relayer-database:latest
    #[test]
    #[ignore]
    fn test_fill_db() {
        let mut storage = crate::Storage::open("rocks_tmp/").unwrap();
        let mut connection = super::connect_without_tls(&Default::default()).unwrap();
        let engine_state = engine::EngineState {
            chain_id: aurora_engine_types::types::u256_to_arr(&1313161555.into()),
            owner_id: "aurora".parse().unwrap(),
            bridge_prover_id: "prover.bridge.near".parse().unwrap(),
            upgrade_delay_blocks: 0,
        };

        // Initialize engine and connector states in storage.
        // Use explicit scope so borrows against `storage` are dropped before processing DB rows.
        {
            let block_height = 0;
            let block_hash = H256::zero();
            let block_metadata = crate::BlockMetadata {
                timestamp: aurora_engine_sdk::env::Timestamp::new(0),
                random_seed: H256::zero(),
            };
            storage
                .set_block_data(block_hash, block_height, block_metadata)
                .unwrap();
            let result = storage.with_engine_access(block_height, 0, &[], |io| {
                let mut local_io = io;
                engine::set_state(&mut local_io, engine_state.clone());
                connector::EthConnectorContract::create_contract(
                    io,
                    engine_state.owner_id.clone(),
                    parameters::InitCallArgs {
                        prover_account: engine_state.bridge_prover_id.clone(),
                        eth_custodian_address: "6bfad42cfc4efc96f529d786d643ff4a8b89fa52"
                            .to_string(),
                        metadata: Default::default(),
                    },
                )
            });

            result.result.ok().unwrap();
            let diff = result.diff;
            storage
                .set_transaction_included(
                    H256::zero(),
                    &TransactionMessage {
                        block_hash,
                        position: 0,
                        near_receipt_id: H256::zero(),
                        succeeded: true,
                        signer: "aurora".parse().unwrap(),
                        caller: "aurora".parse().unwrap(),
                        attached_near: 0,
                        transaction: TransactionKind::Unknown,
                        promise_data: Vec::new(),
                    },
                    &diff,
                )
                .unwrap();
        }
        let block_rows = super::read_block_data(&mut connection).unwrap();
        super::initialize_blocks(&mut storage, block_rows.map(|row| Ok(row.into()))).unwrap();
        let tx_rows = super::read_transaction_data(&mut connection).unwrap();
        super::initialize_transactions(
            &mut storage,
            tx_rows.map(|row| Ok(row.into())),
            engine_state,
        )
        .unwrap();

        connection.close().unwrap();
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/relayer_db/types.rs ---
use aurora_engine_transactions::{
    legacy::{LegacyEthSignedTransaction, TransactionLegacy},
    EthTransactionKind,
};
use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::{H256, U256};
use std::convert::TryFrom;
use std::io::{Cursor, Read};
use std::time::SystemTime;

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct ConnectionParams {
    // URL to the host (eg localhost)
    pub host: String,
    pub port: u32,
    pub db_name: String,
    pub user: String,
    pub password: String,
}

impl ConnectionParams {
    pub fn as_connection_string(&self) -> String {
        format!(
            "host={} port={} dbname={} user={} password={}",
            self.host, self.port, self.db_name, self.user, self.password
        )
    }
}

impl Default for ConnectionParams {
    fn default() -> Self {
        Self {
            host: "localhost".into(),
            port: 15432,
            db_name: "aurora".into(),
            user: "aurora".into(),
            password: "aurora".into(),
        }
    }
}

/// Row from the `block` table in the relayer's DB.
#[derive(Debug)]
pub struct BlockRow {
    /// Chain ID the block is from
    pub chain: u64,
    /// Block height
    pub id: u64,
    /// Block hash (on Aurora)
    pub hash: H256,
    /// Block hash (on NEAR)
    pub near_hash: Option<H256>,
    /// Time the block was created (in ns since the unix epoch)
    pub timestamp: Option<u64>,
    /// Size of the block (in bytes)
    pub size: u32,
    /// Maximum amount of EVM gas allowed to be spent
    pub gas_limit: U256,
    /// Amount of EVM gas spent in transactions in this block
    pub gas_used: U256,
    /// Hash of the parent block
    pub parent_hash: H256,
    /// Root hash for transactions trie
    pub transactions_root: H256,
    /// Root hash for state trie
    pub state_root: H256,
    /// Root hash for receipts trie
    pub receipts_root: H256,
}

impl From<postgres::Row> for BlockRow {
    fn from(row: postgres::Row) -> Self {
        let chain: i32 = row.get("chain");
        let id: i64 = row.get("id");
        let hash = get_hash(&row, "hash");
        let near_hash: Option<&[u8]> = row.get("near_hash");
        let timestamp = get_timestamp(&row, "timestamp");
        let size: i32 = row.get("size");
        let gas_limit = get_numeric(&row, "gas_limit");
        let gas_used = get_numeric(&row, "gas_used");
        let parent_hash = get_hash(&row, "parent_hash");
        let transactions_root = get_hash(&row, "transactions_root");
        let state_root = get_hash(&row, "state_root");
        let receipts_root = get_hash(&row, "receipts_root");

        Self {
            chain: chain as u64,
            id: id as u64,
            hash,
            near_hash: near_hash.map(H256::from_slice),
            timestamp,
            size: size as u32,
            gas_limit,
            gas_used,
            parent_hash,
            transactions_root,
            state_root,
            receipts_root,
        }
    }
}

/// Row from the `transaction` table in the relayer's DB.
#[derive(Debug)]
pub struct TransactionRow {
    /// Block height where the transaction was included in the chain
    pub block: u64,
    /// Hash of the block which included the transaction. Not present in the `transaction` table, so will need
    /// to be filled using a `JOIN` against the `block` table.
    pub block_hash: H256,
    /// Position in the block (if a block includes multiple transactions this index will increase)
    pub index: u16,
    /// Some unique id?
    pub id: u64,
    /// Transaction hash (on Aurora)
    pub hash: H256,
    /// Transaction hash (on NEAR)
    pub near_hash: H256,
    /// Hash of the receipt on NEAR that the transaction was processed in
    pub near_receipt_hash: H256,
    /// Address that signed the transaction
    pub from: Address,
    /// Address the transaction is sent to
    pub to: Option<Address>,
    /// Nonce of the transaction
    pub nonce: U256,
    /// Gas price
    pub gas_price: U256,
    /// Maximum amount of EVM gas the transaction can spend
    pub gas_limit: U256,
    /// Amount of EVM gas used in the transaction
    pub gas_used: u64,
    /// Value attached to the transaction
    pub value: Wei,
    /// Input sent with the transaction
    pub input: Vec<u8>,
    /// Signature parameter v
    pub v: u64,
    /// Signature parameter r
    pub r: U256,
    /// Signature parameter s
    pub s: U256,
    /// True if transaction succeeded
    pub status: bool,
    /// Output bytes from the transaction execution
    pub output: Vec<u8>,
}

impl From<postgres::Row> for TransactionRow {
    fn from(row: postgres::Row) -> Self {
        let block: i64 = row.get("block");
        let block_hash = get_hash(&row, "block_hash");
        let index: i32 = row.get("index");
        let id: i64 = row.get("id");
        let hash = get_hash(&row, "hash");
        let near_hash = get_hash(&row, "near_hash");
        let near_receipt_hash = get_hash(&row, "near_receipt_hash");
        let from = get_address(&row, "from");
        let to: Option<&[u8]> = row.get("to");
        let nonce = get_numeric(&row, "nonce");
        let gas_price = get_numeric(&row, "gas_price");
        let gas_limit = get_numeric(&row, "gas_limit");
        let gas_used = get_numeric(&row, "gas_used");
        let value = get_numeric(&row, "value");
        let input: Option<Vec<u8>> = row.get("input");
        let v = get_numeric(&row, "v");
        let r = get_numeric(&row, "r");
        let s = get_numeric(&row, "s");
        let status: bool = row.get("status");
        let output: Option<Vec<u8>> = row.get("output");

        Self {
            block: block as u64,
            block_hash,
            index: index as u16,
            id: id as u64,
            hash,
            near_hash,
            near_receipt_hash,
            from,
            to: to.map(|arr| Address::try_from_slice(arr).unwrap()),
            nonce,
            gas_price,
            gas_limit,
            gas_used: gas_used.low_u64(),
            value: Wei::new(value),
            input: input.unwrap_or_default(),
            v: v.low_u64(),
            r,
            s,
            status,
            output: output.unwrap_or_default(),
        }
    }
}

impl From<TransactionRow> for EthTransactionKind {
    fn from(row: TransactionRow) -> Self {
        let legacy = LegacyEthSignedTransaction {
            transaction: TransactionLegacy {
                nonce: row.nonce,
                gas_price: row.gas_price,
                gas_limit: row.gas_limit,
                to: row.to,
                value: row.value,
                data: row.input,
            },
            v: row.v,
            r: row.r,
            s: row.s,
        };

        Self::Legacy(legacy)
    }
}

fn get_numeric(row: &postgres::Row, field: &str) -> U256 {
    let value: PostgresNumeric = row.get(field);
    U256::try_from(value).unwrap()
}

fn get_hash(row: &postgres::Row, field: &str) -> H256 {
    let value: &[u8] = row.get(field);
    H256::from_slice(value)
}

fn get_address(row: &postgres::Row, field: &str) -> Address {
    let value: &[u8] = row.get(field);
    Address::try_from_slice(value).unwrap()
}

fn get_timestamp(row: &postgres::Row, field: &str) -> Option<u64> {
    let timestamp: Option<SystemTime> = row.get(field);
    timestamp
        .and_then(|t| t.duration_since(SystemTime::UNIX_EPOCH).ok())
        .map(|d| d.as_nanos() as u64)
}

struct PostgresNumeric {
    /// The contribution of the first group to the value of the number is given by `groups[0] * 10000^weight`.
    /// The weight decreases by 1 for subsequent groups
    weight: i16,
    /// Sign of the number
    sign: PostgresNumericSign,
    /// The number of base10 digits to put after the decimal separator
    scale: u16,
    /// The "digits" of the number in base 10000 (offset by the weight).
    groups: Vec<u16>,
}

impl PostgresNumeric {
    const BASE_WEIGHT: U256 = U256([10000u64, 0, 0, 0]);
}

#[repr(u16)]
enum PostgresNumericSign {
    Positive = 0x0000,
    Negative = 0x4000,
    NaN = 0xc000,
}

impl TryFrom<PostgresNumeric> for U256 {
    type Error = NumericToU256Error;

    fn try_from(value: PostgresNumeric) -> Result<Self, Self::Error> {
        if let PostgresNumericSign::Negative = value.sign {
            return Err(NumericToU256Error::Negative);
        } else if let PostgresNumericSign::NaN = value.sign {
            return Err(NumericToU256Error::NaN);
        } else if value.scale != 0 || value.weight < 0 {
            return Err(NumericToU256Error::NotAWholeNumber);
        }

        let mut total = U256::zero();
        let mut weight = PostgresNumeric::BASE_WEIGHT
            .checked_pow(value.weight.into())
            .ok_or(NumericToU256Error::Overflow)?;
        for group in value.groups {
            let contribution = U256::from(group)
                .checked_mul(weight)
                .ok_or(NumericToU256Error::Overflow)?;
            total = total
                .checked_add(contribution)
                .ok_or(NumericToU256Error::Overflow)?;
            weight /= PostgresNumeric::BASE_WEIGHT;
        }
        Ok(total)
    }
}

#[derive(Debug)]
enum NumericToU256Error {
    Negative,
    NaN,
    NotAWholeNumber,
    Overflow,
}

impl<'a> postgres::types::FromSql<'a> for PostgresNumeric {
    fn from_sql(
        _: &postgres::types::Type,
        raw: &'a [u8],
    ) -> Result<Self, Box<dyn std::error::Error + Sync + Send>> {
        let mut cursor = Cursor::new(raw);
        let read_16bits = |cursor: &mut Cursor<&[u8]>| -> Result<[u8; 2], std::io::Error> {
            let mut buf = [0u8; 2];
            cursor.read_exact(&mut buf)?;
            Ok(buf)
        };
        let read_u16 = |cursor: &mut Cursor<&[u8]>| -> Result<u16, std::io::Error> {
            read_16bits(cursor).map(u16::from_be_bytes)
        };
        let read_i16 = |cursor: &mut Cursor<&[u8]>| -> Result<i16, std::io::Error> {
            read_16bits(cursor).map(i16::from_be_bytes)
        };

        let num_groups = read_u16(&mut cursor)?;
        let weight = read_i16(&mut cursor)?;

        let sign_raw = read_u16(&mut cursor)?;
        let sign = if sign_raw == PostgresNumericSign::Positive as u16 {
            PostgresNumericSign::Positive
        } else if sign_raw == PostgresNumericSign::Negative as u16 {
            PostgresNumericSign::Negative
        } else if sign_raw == PostgresNumericSign::NaN as u16 {
            PostgresNumericSign::NaN
        } else {
            panic!("Unexpected Numeric Sign value");
        };

        let scale = read_u16(&mut cursor)?;
        let mut groups = Vec::with_capacity(num_groups as usize);
        for _ in 0..num_groups {
            groups.push(read_u16(&mut cursor)?);
        }

        Ok(PostgresNumeric {
            weight,
            sign,
            scale,
            groups,
        })
    }

    fn accepts(ty: &postgres::types::Type) -> bool {
        matches!(ty, &postgres::types::Type::NUMERIC)
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/sync/mod.rs ---
use aurora_engine::pausables::{
    EnginePrecompilesPauser, PausedPrecompilesManager, PrecompileFlags,
};
use aurora_engine::{connector, engine, parameters::SubmitResult, xcc};
use aurora_engine_sdk::env::{self, Env, DEFAULT_PREPAID_GAS};
use aurora_engine_types::{
    account_id::AccountId,
    parameters::PromiseWithCallbackArgs,
    types::{Address, Yocto},
    H256,
};

pub mod types;

use crate::engine_state::EngineStateAccess;
use crate::{BlockMetadata, Diff, Storage};
use types::{Message, TransactionKind, TransactionMessage};

pub fn consume_message(
    storage: &mut Storage,
    message: Message,
) -> Result<ConsumeMessageOutcome, crate::Error> {
    match message {
        Message::Block(block_message) => {
            let block_hash = block_message.hash;
            let block_height = block_message.height;
            let block_metadata = block_message.metadata;
            storage
                .set_block_data(block_hash, block_height, block_metadata)
                .map_err(crate::Error::Rocksdb)?;
            Ok(ConsumeMessageOutcome::BlockAdded)
        }

        Message::Transaction(transaction_message) => {
            // Failed transactions have no impact on the state of our database.
            if !transaction_message.succeeded {
                return Ok(ConsumeMessageOutcome::FailedTransactionIgnored);
            }

            let transaction_position = transaction_message.position;
            let block_hash = transaction_message.block_hash;
            let block_height = storage.get_block_height_by_hash(block_hash)?;
            let block_metadata = storage.get_block_metadata(block_hash)?;
            let engine_account_id = storage.get_engine_account_id()?;

            let (tx_hash, diff, result) = storage
                .with_engine_access(block_height, transaction_position, &[], |io| {
                    execute_transaction(
                        transaction_message.as_ref(),
                        block_height,
                        &block_metadata,
                        engine_account_id,
                        io,
                    )
                })
                .result;
            match result.as_ref() {
                Err(_) | Ok(Some(TransactionExecutionResult::Submit(Err(_)))) => (), // do not persist if Engine encounters an error
                _ => storage.set_transaction_included(tx_hash, &transaction_message, &diff)?,
            }
            let outcome = TransactionIncludedOutcome {
                hash: tx_hash,
                info: *transaction_message,
                diff,
                maybe_result: result,
            };
            Ok(ConsumeMessageOutcome::TransactionIncluded(Box::new(
                outcome,
            )))
        }
    }
}

pub fn execute_transaction_message(
    storage: &Storage,
    transaction_message: TransactionMessage,
) -> Result<TransactionIncludedOutcome, crate::Error> {
    let transaction_position = transaction_message.position;
    let block_hash = transaction_message.block_hash;
    let block_height = storage.get_block_height_by_hash(block_hash)?;
    let block_metadata = storage.get_block_metadata(block_hash)?;
    let engine_account_id = storage.get_engine_account_id()?;
    let result = storage.with_engine_access(block_height, transaction_position, &[], |io| {
        execute_transaction(
            &transaction_message,
            block_height,
            &block_metadata,
            engine_account_id,
            io,
        )
    });
    let (tx_hash, diff, maybe_result) = result.result;
    let outcome = TransactionIncludedOutcome {
        hash: tx_hash,
        info: transaction_message,
        diff,
        maybe_result,
    };
    Ok(outcome)
}

fn execute_transaction<'db>(
    transaction_message: &TransactionMessage,
    block_height: u64,
    block_metadata: &BlockMetadata,
    engine_account_id: AccountId,
    io: EngineStateAccess<'db, 'db, 'db>,
) -> (
    H256,
    Diff,
    Result<Option<TransactionExecutionResult>, error::Error>,
) {
    let signer_account_id = transaction_message.signer.clone();
    let predecessor_account_id = transaction_message.caller.clone();
    let relayer_address =
        aurora_engine_sdk::types::near_account_to_evm_address(predecessor_account_id.as_bytes());
    let near_receipt_id = transaction_message.near_receipt_id;
    let current_account_id = engine_account_id;
    let env = env::Fixed {
        signer_account_id,
        current_account_id,
        predecessor_account_id,
        block_height,
        block_timestamp: block_metadata.timestamp,
        attached_deposit: transaction_message.attached_near,
        random_seed: block_metadata.random_seed,
        prepaid_gas: DEFAULT_PREPAID_GAS,
    };

    let (tx_hash, result) = match &transaction_message.transaction {
        TransactionKind::Submit(tx) => {
            // We can ignore promises in the standalone engine because it processes each receipt separately
            // and it is fed a stream of receipts (it does not schedule them)
            let mut handler = crate::promise::NoScheduler {
                promise_data: &transaction_message.promise_data,
            };
            let transaction_bytes: Vec<u8> = tx.into();
            let tx_hash = aurora_engine_sdk::keccak(&transaction_bytes);

            let result = engine::get_state(&io)
                .map(|engine_state| {
                    let submit_result = engine::submit(
                        io,
                        &env,
                        &transaction_bytes,
                        engine_state,
                        env.current_account_id(),
                        relayer_address,
                        &mut handler,
                    );
                    Some(TransactionExecutionResult::Submit(submit_result))
                })
                .map_err(Into::into);

            (tx_hash, result)
        }

        other => {
            let result = non_submit_execute(
                other,
                io,
                env,
                relayer_address,
                &transaction_message.promise_data,
            );
            (near_receipt_id, result)
        }
    };

    let diff = io.get_transaction_diff();

    (tx_hash, diff, result)
}

/// Handles all transaction kinds other than `submit`.
/// The `submit` transaction kind is special because it is the only one where the transaction hash is
/// different than the NEAR receipt hash.
fn non_submit_execute<'db>(
    transaction: &TransactionKind,
    mut io: EngineStateAccess<'db, 'db, 'db>,
    env: env::Fixed,
    relayer_address: Address,
    promise_data: &[Option<Vec<u8>>],
) -> Result<Option<TransactionExecutionResult>, error::Error> {
    let result = match transaction {
        TransactionKind::Call(args) => {
            // We can ignore promises in the standalone engine (see above)
            let mut handler = crate::promise::NoScheduler { promise_data };
            let mut engine =
                engine::Engine::new(relayer_address, env.current_account_id(), io, &env)?;

            let result = engine.call_with_args(args.clone(), &mut handler);

            Some(TransactionExecutionResult::Submit(result))
        }

        TransactionKind::Deploy(input) => {
            // We can ignore promises in the standalone engine (see above)
            let mut handler = crate::promise::NoScheduler { promise_data };
            let mut engine =
                engine::Engine::new(relayer_address, env.current_account_id(), io, &env)?;

            let result = engine.deploy_code_with_input(input.clone(), &mut handler);

            Some(TransactionExecutionResult::Submit(result))
        }

        TransactionKind::DeployErc20(args) => {
            // No promises can be created by `deploy_erc20_token`
            let mut handler = crate::promise::NoScheduler { promise_data };
            let result = engine::deploy_erc20_token(args.clone(), io, &env, &mut handler)?;

            Some(TransactionExecutionResult::DeployErc20(result))
        }

        TransactionKind::FtOnTransfer(args) => {
            // No promises can be created by `ft_on_transfer`
            let mut handler = crate::promise::NoScheduler { promise_data };
            let mut engine =
                engine::Engine::new(relayer_address, env.current_account_id(), io, &env)?;

            if env.predecessor_account_id == env.current_account_id {
                connector::EthConnectorContract::init_instance(io)?
                    .ft_on_transfer(&engine, args)?;
            } else {
                engine.receive_erc20_tokens(
                    &env.predecessor_account_id,
                    args,
                    &env.current_account_id,
                    &mut handler,
                );
            }

            None
        }

        TransactionKind::FtTransferCall(args) => {
            let mut connector = connector::EthConnectorContract::init_instance(io)?;
            let promise_args = connector.ft_transfer_call(
                env.predecessor_account_id.clone(),
                env.current_account_id.clone(),
                args.clone(),
                env.prepaid_gas,
            )?;

            Some(TransactionExecutionResult::Promise(promise_args))
        }

        TransactionKind::ResolveTransfer(args, promise_result) => {
            let mut connector = connector::EthConnectorContract::init_instance(io)?;
            connector.ft_resolve_transfer(args.clone(), promise_result.clone());

            None
        }

        TransactionKind::FtTransfer(args) => {
            let mut connector = connector::EthConnectorContract::init_instance(io)?;
            connector.ft_transfer(&env.predecessor_account_id, args.clone())?;

            None
        }

        TransactionKind::Withdraw(args) => {
            let mut connector = connector::EthConnectorContract::init_instance(io)?;
            connector.withdraw_eth_from_near(
                &env.current_account_id,
                &env.predecessor_account_id,
                args.clone(),
            )?;

            None
        }

        TransactionKind::Deposit(raw_proof) => {
            let connector_contract = connector::EthConnectorContract::init_instance(io)?;
            let promise_args = connector_contract.deposit(
                raw_proof.clone(),
                env.current_account_id(),
                env.predecessor_account_id(),
            )?;

            Some(TransactionExecutionResult::Promise(promise_args))
        }

        TransactionKind::FinishDeposit(finish_args) => {
            let mut connector = connector::EthConnectorContract::init_instance(io)?;
            let maybe_promise_args = connector.finish_deposit(
                env.predecessor_account_id(),
                env.current_account_id(),
                finish_args.clone(),
                env.prepaid_gas,
            )?;

            maybe_promise_args.map(TransactionExecutionResult::Promise)
        }

        TransactionKind::StorageDeposit(args) => {
            let mut connector = connector::EthConnectorContract::init_instance(io)?;
            let _ = connector.storage_deposit(
                env.predecessor_account_id,
                Yocto::new(env.attached_deposit),
                args.clone(),
            )?;

            None
        }

        TransactionKind::StorageUnregister(force) => {
            let mut connector = connector::EthConnectorContract::init_instance(io)?;
            let _ = connector.storage_unregister(env.predecessor_account_id, *force)?;

            None
        }

        TransactionKind::StorageWithdraw(args) => {
            let mut connector = connector::EthConnectorContract::init_instance(io)?;
            connector.storage_withdraw(&env.predecessor_account_id, args.clone())?;

            None
        }

        TransactionKind::SetPausedFlags(args) => {
            let mut connector = connector::EthConnectorContract::init_instance(io)?;
            connector.set_paused_flags(args.clone());

            None
        }

        TransactionKind::RegisterRelayer(evm_address) => {
            let mut engine =
                engine::Engine::new(relayer_address, env.current_account_id(), io, &env)?;
            engine.register_relayer(env.predecessor_account_id.as_bytes(), *evm_address);

            None
        }

        TransactionKind::RefundOnError(maybe_args) => {
            let result: Result<Option<TransactionExecutionResult>, engine::EngineStateError> =
                maybe_args
                    .clone()
                    .map(|args| {
                        let mut handler = crate::promise::NoScheduler { promise_data };
                        let engine_state = engine::get_state(&io)?;
                        let result =
                            engine::refund_on_error(io, &env, engine_state, args, &mut handler);
                        Ok(TransactionExecutionResult::Submit(result))
                    })
                    .transpose();

            result?
        }

        TransactionKind::SetConnectorData(args) => {
            let mut connector_io = io;
            connector::set_contract_data(&mut connector_io, args.clone())?;

            None
        }

        TransactionKind::NewConnector(args) => {
            connector::EthConnectorContract::create_contract(
                io,
                env.current_account_id,
                args.clone(),
            )?;

            None
        }
        TransactionKind::NewEngine(args) => {
            engine::set_state(&mut io, args.clone().into());

            None
        }
        TransactionKind::FactoryUpdate(bytecode) => {
            let router_bytecode = xcc::RouterCode::borrowed(bytecode);
            xcc::update_router_code(&mut io, &router_bytecode);

            None
        }
        TransactionKind::FactoryUpdateAddressVersion(args) => {
            xcc::set_code_version_of_address(&mut io, &args.address, args.version);

            None
        }
        TransactionKind::FactorySetWNearAddress(address) => {
            xcc::set_wnear_address(&mut io, address);

            None
        }
        TransactionKind::Unknown => None,
        // Not handled in this function; is handled by the general `execute_transaction` function
        TransactionKind::Submit(_) => unreachable!(),
        TransactionKind::PausePrecompiles(args) => {
            let precompiles_to_pause = PrecompileFlags::from_bits_truncate(args.paused_mask);

            let mut pauser = EnginePrecompilesPauser::from_io(io);
            pauser.pause_precompiles(precompiles_to_pause);

            None
        }
        TransactionKind::ResumePrecompiles(args) => {
            let precompiles_to_resume = PrecompileFlags::from_bits_truncate(args.paused_mask);

            let mut pauser = EnginePrecompilesPauser::from_io(io);
            pauser.resume_precompiles(precompiles_to_resume);

            None
        }
    };

    Ok(result)
}

#[derive(Debug)]
pub enum ConsumeMessageOutcome {
    BlockAdded,
    FailedTransactionIgnored,
    TransactionIncluded(Box<TransactionIncludedOutcome>),
}

#[derive(Debug)]
pub struct TransactionIncludedOutcome {
    pub hash: aurora_engine_types::H256,
    pub info: TransactionMessage,
    pub diff: crate::Diff,
    pub maybe_result: Result<Option<TransactionExecutionResult>, error::Error>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum TransactionExecutionResult {
    Submit(engine::EngineResult<SubmitResult>),
    DeployErc20(Address),
    Promise(PromiseWithCallbackArgs),
}

pub mod error {
    use aurora_engine::{connector, engine, fungible_token};

    #[derive(Debug)]
    pub enum Error {
        EngineState(engine::EngineStateError),
        Engine(engine::EngineError),
        DeployErc20(engine::DeployErc20Error),
        FtOnTransfer(connector::error::FtTransferCallError),
        Deposit(connector::error::DepositError),
        FinishDeposit(connector::error::FinishDepositError),
        FtTransfer(fungible_token::error::TransferError),
        FtWithdraw(connector::error::WithdrawError),
        FtStorageFunding(fungible_token::error::StorageFundingError),
        InvalidAddress(aurora_engine_types::types::address::error::AddressError),
        ConnectorInit(connector::error::InitContractError),
        ConnectorStorage(connector::error::StorageReadError),
    }

    impl From<engine::EngineStateError> for Error {
        fn from(e: engine::EngineStateError) -> Self {
            Self::EngineState(e)
        }
    }

    impl From<engine::EngineError> for Error {
        fn from(e: engine::EngineError) -> Self {
            Self::Engine(e)
        }
    }

    impl From<engine::DeployErc20Error> for Error {
        fn from(e: engine::DeployErc20Error) -> Self {
            Self::DeployErc20(e)
        }
    }

    impl From<connector::error::FtTransferCallError> for Error {
        fn from(e: connector::error::FtTransferCallError) -> Self {
            Self::FtOnTransfer(e)
        }
    }

    impl From<connector::error::DepositError> for Error {
        fn from(e: connector::error::DepositError) -> Self {
            Self::Deposit(e)
        }
    }

    impl From<connector::error::FinishDepositError> for Error {
        fn from(e: connector::error::FinishDepositError) -> Self {
            Self::FinishDeposit(e)
        }
    }

    impl From<fungible_token::error::TransferError> for Error {
        fn from(e: fungible_token::error::TransferError) -> Self {
            Self::FtTransfer(e)
        }
    }

    impl From<connector::error::WithdrawError> for Error {
        fn from(e: connector::error::WithdrawError) -> Self {
            Self::FtWithdraw(e)
        }
    }

    impl From<fungible_token::error::StorageFundingError> for Error {
        fn from(e: fungible_token::error::StorageFundingError) -> Self {
            Self::FtStorageFunding(e)
        }
    }

    impl From<aurora_engine_types::types::address::error::AddressError> for Error {
        fn from(e: aurora_engine_types::types::address::error::AddressError) -> Self {
            Self::InvalidAddress(e)
        }
    }

    impl From<connector::error::InitContractError> for Error {
        fn from(e: connector::error::InitContractError) -> Self {
            Self::ConnectorInit(e)
        }
    }

    impl From<connector::error::StorageReadError> for Error {
        fn from(e: connector::error::StorageReadError) -> Self {
            Self::ConnectorStorage(e)
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-storage/src/sync/types.rs ---
use crate::Storage;
use aurora_engine::parameters;
use aurora_engine::parameters::PausePrecompilesCallArgs;
use aurora_engine::xcc::AddressVersionUpdateArgs;
use aurora_engine_transactions::{EthTransactionKind, NormalizedEthTransaction};
use aurora_engine_types::account_id::AccountId;
use aurora_engine_types::types::Address;
use aurora_engine_types::{
    types::{self, Wei},
    H256, U256,
};
use borsh::{BorshDeserialize, BorshSerialize};
use std::borrow::Cow;

/// Type describing the format of messages sent to the storage layer for keeping
/// it in sync with the blockchain.
#[derive(Debug, Clone)]
pub enum Message {
    Block(BlockMessage),
    Transaction(Box<TransactionMessage>),
}

#[derive(Debug, Clone)]
pub struct BlockMessage {
    pub height: u64,
    pub hash: H256,
    pub metadata: crate::BlockMetadata,
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct TransactionMessage {
    /// Hash of the block which included this transaction
    pub block_hash: H256,
    /// Receipt ID of the receipt that was actually executed on NEAR
    pub near_receipt_id: H256,
    /// If multiple Aurora transactions are included in the same block,
    /// this index gives the order in which they should be executed.
    pub position: u16,
    /// True if the transaction executed successfully on the blockchain, false otherwise.
    pub succeeded: bool,
    /// NEAR account that signed the transaction
    pub signer: AccountId,
    /// NEAR account that called the Aurora engine contract
    pub caller: AccountId,
    /// Amount of NEAR token attached to the transaction
    pub attached_near: u128,
    /// Details of the transaction that was executed
    pub transaction: TransactionKind,
    /// Results from previous NEAR receipts
    /// (only present when this transaction is a callback of another transaction).
    pub promise_data: Vec<Option<Vec<u8>>>,
}

impl TransactionMessage {
    pub fn to_bytes(&self) -> Vec<u8> {
        let borshable: BorshableTransactionMessage = self.into();
        borshable.try_to_vec().unwrap()
    }

    pub fn try_from_slice(bytes: &[u8]) -> Result<Self, std::io::Error> {
        let borshable = match BorshableTransactionMessage::try_from_slice(bytes) {
            Ok(b) => b,
            // To avoid DB migration, allow fallback on deserializing V1 messages
            Err(_) => BorshableTransactionMessageV1::try_from_slice(bytes)
                .map(BorshableTransactionMessage::V1)?,
        };
        Self::try_from(borshable).map_err(|e| {
            let message = e.as_str();
            std::io::Error::new(std::io::ErrorKind::Other, message)
        })
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
#[allow(clippy::large_enum_variant)]
pub enum TransactionKind {
    /// Raw Ethereum transaction submitted to the engine
    Submit(EthTransactionKind),
    /// Ethereum transaction triggered by a NEAR account
    Call(parameters::CallArgs),
    /// Administrative method that makes a subset of precompiles paused
    PausePrecompiles(PausePrecompilesCallArgs),
    /// Administrative method that resumes previously paused subset of precompiles
    ResumePrecompiles(PausePrecompilesCallArgs),
    /// Input here represents the EVM code used to create the new contract
    Deploy(Vec<u8>),
    /// New bridged token
    DeployErc20(parameters::DeployErc20TokenArgs),
    /// This type of transaction can impact the aurora state because of the bridge
    FtOnTransfer(parameters::NEP141FtOnTransferArgs),
    /// Bytes here will be parsed into `aurora_engine::proof::Proof`
    Deposit(Vec<u8>),
    /// This can change balances on aurora in the case that `receiver_id == aurora`.
    /// Example: https://explorer.mainnet.near.org/transactions/DH6iNvXCt5n5GZBZPV1A6sLmMf1EsKcxXE4uqk1cShzj
    FtTransferCall(parameters::TransferCallCallArgs),
    /// FinishDeposit-type receipts are created by calls to `deposit`
    FinishDeposit(parameters::FinishDepositCallArgs),
    /// ResolveTransfer-type receipts are created by calls to ft_on_transfer
    ResolveTransfer(parameters::ResolveTransferCallArgs, types::PromiseResult),
    /// ft_transfer (related to eth-connector)
    FtTransfer(parameters::TransferCallArgs),
    /// Function to take ETH out of Aurora
    Withdraw(aurora_engine_types::parameters::WithdrawCallArgs),
    /// FT storage standard method
    StorageDeposit(parameters::StorageDepositCallArgs),
    /// FT storage standard method
    StorageUnregister(Option<bool>),
    /// FT storage standard method
    StorageWithdraw(parameters::StorageWithdrawCallArgs),
    /// Admin only method
    SetPausedFlags(parameters::PauseEthConnectorCallArgs),
    /// Ad entry mapping from address to relayer NEAR account
    RegisterRelayer(types::Address),
    /// Called if exist precompiles fail
    RefundOnError(Option<aurora_engine_types::parameters::RefundCallArgs>),
    /// Update eth-connector config
    SetConnectorData(parameters::SetContractDataCallArgs),
    /// Initialize eth-connector
    NewConnector(parameters::InitCallArgs),
    /// Initialize Engine
    NewEngine(parameters::NewCallArgs),
    /// Update xcc-router bytecode
    FactoryUpdate(Vec<u8>),
    /// Update the version of a deployed xcc-router contract
    FactoryUpdateAddressVersion(AddressVersionUpdateArgs),
    FactorySetWNearAddress(types::Address),
    /// Sentinel kind for cases where a NEAR receipt caused a
    /// change in Aurora state, but we failed to parse the Action.
    Unknown,
}

impl TransactionKind {
    pub fn eth_repr(
        self,
        engine_account: &AccountId,
        caller: &AccountId,
        block_height: u64,
        transaction_position: u16,
        storage: &Storage,
    ) -> NormalizedEthTransaction {
        match self {
            // In the case the submit arg fails to normalize, there is no EVM execution
            Self::Submit(eth_tx_kind) => eth_tx_kind
                .try_into()
                .unwrap_or_else(|_| Self::no_evm_execution("submit")),
            Self::Call(call_args) => {
                let from = Self::get_implicit_address(caller);
                let nonce =
                    Self::get_implicit_nonce(&from, block_height, transaction_position, storage);
                let (to, data, value) = match call_args {
                    parameters::CallArgs::V1(args) => (args.contract, args.input, Wei::zero()),
                    parameters::CallArgs::V2(args) => (
                        args.contract,
                        args.input,
                        Wei::new(U256::from_big_endian(&args.value)),
                    ),
                };
                NormalizedEthTransaction {
                    address: from,
                    chain_id: None,
                    nonce,
                    gas_limit: U256::from(u64::MAX),
                    max_priority_fee_per_gas: U256::zero(),
                    max_fee_per_gas: U256::zero(),
                    to: Some(to),
                    value,
                    data,
                    access_list: Vec::new(),
                }
            }
            Self::Deploy(data) => {
                let from = Self::get_implicit_address(caller);
                let nonce =
                    Self::get_implicit_nonce(&from, block_height, transaction_position, storage);
                NormalizedEthTransaction {
                    address: from,
                    chain_id: None,
                    nonce,
                    gas_limit: U256::from(u64::MAX),
                    max_priority_fee_per_gas: U256::zero(),
                    max_fee_per_gas: U256::zero(),
                    to: None,
                    value: Wei::zero(),
                    data,
                    access_list: Vec::new(),
                }
            }
            Self::DeployErc20(_) => {
                let from = Self::get_implicit_address(caller);
                let nonce =
                    Self::get_implicit_nonce(&from, block_height, transaction_position, storage);
                let data = aurora_engine::engine::setup_deploy_erc20_input(engine_account);
                NormalizedEthTransaction {
                    address: from,
                    chain_id: None,
                    nonce,
                    gas_limit: U256::from(u64::MAX),
                    max_priority_fee_per_gas: U256::zero(),
                    max_fee_per_gas: U256::zero(),
                    to: None,
                    value: Wei::zero(),
                    data,
                    access_list: Vec::new(),
                }
            }
            Self::FtOnTransfer(args) => {
                if engine_account == caller {
                    let recipient = aurora_engine::deposit_event::FtTransferMessageData::parse_on_transfer_message(&args.msg).map(|data| data.recipient).unwrap_or_default();
                    let value = Wei::new(U256::from(args.amount.as_u128()));
                    // This transaction mints new ETH, so we'll say it comes from the zero address.
                    NormalizedEthTransaction {
                        address: types::Address::default(),
                        chain_id: None,
                        nonce: U256::zero(),
                        gas_limit: U256::from(u64::MAX),
                        max_priority_fee_per_gas: U256::zero(),
                        max_fee_per_gas: U256::zero(),
                        to: Some(recipient),
                        value,
                        data: Vec::new(),
                        access_list: Vec::new(),
                    }
                } else {
                    let from = Self::get_implicit_address(engine_account);
                    let nonce = Self::get_implicit_nonce(
                        &from,
                        block_height,
                        transaction_position,
                        storage,
                    );
                    let to = storage
                        .with_engine_access(block_height, transaction_position, &[], |io| {
                            aurora_engine::engine::get_erc20_from_nep141(&io, caller)
                        })
                        .result
                        .ok()
                        .and_then(|bytes| types::Address::try_from_slice(&bytes).ok())
                        .unwrap_or_default();
                    let erc20_recipient = hex::decode(&args.msg.as_bytes()[0..40])
                        .ok()
                        .and_then(|bytes| types::Address::try_from_slice(&bytes).ok())
                        .unwrap_or_default();
                    let data = aurora_engine::engine::setup_receive_erc20_tokens_input(
                        &args,
                        &erc20_recipient,
                    );
                    NormalizedEthTransaction {
                        address: from,
                        chain_id: None,
                        nonce,
                        gas_limit: U256::from(u64::MAX),
                        max_priority_fee_per_gas: U256::zero(),
                        max_fee_per_gas: U256::zero(),
                        to: Some(to),
                        value: Wei::zero(),
                        data,
                        access_list: Vec::new(),
                    }
                }
            }
            Self::RefundOnError(maybe_args) => {
                match maybe_args {
                    Some(args) => match args.erc20_address {
                        Some(erc20_address) => {
                            // ERC-20 refund
                            let from = Self::get_implicit_address(engine_account);
                            let nonce = Self::get_implicit_nonce(
                                &from,
                                block_height,
                                transaction_position,
                                storage,
                            );
                            let to = erc20_address;
                            let data = aurora_engine::engine::setup_refund_on_error_input(
                                U256::from_big_endian(&args.amount),
                                args.recipient_address,
                            );
                            NormalizedEthTransaction {
                                address: from,
                                chain_id: None,
                                nonce,
                                gas_limit: U256::from(u64::MAX),
                                max_priority_fee_per_gas: U256::zero(),
                                max_fee_per_gas: U256::zero(),
                                to: Some(to),
                                value: Wei::zero(),
                                data,
                                access_list: Vec::new(),
                            }
                        }
                        None => {
                            // ETH refund
                            let value = Wei::new(U256::from_big_endian(&args.amount));
                            let from = aurora_engine_precompiles::native::exit_to_near::ADDRESS;
                            let nonce = Self::get_implicit_nonce(
                                &from,
                                block_height,
                                transaction_position,
                                storage,
                            );
                            NormalizedEthTransaction {
                                address: from,
                                chain_id: None,
                                nonce,
                                gas_limit: U256::from(u64::MAX),
                                max_priority_fee_per_gas: U256::zero(),
                                max_fee_per_gas: U256::zero(),
                                to: Some(args.recipient_address),
                                value,
                                data: Vec::new(),
                                access_list: Vec::new(),
                            }
                        }
                    },
                    None => Self::no_evm_execution("refund_on_error"),
                }
            }
            Self::Deposit(_) => Self::no_evm_execution("deposit"),
            Self::FtTransferCall(_) => Self::no_evm_execution("ft_transfer_call"),
            Self::FinishDeposit(_) => Self::no_evm_execution("finish_deposit"),
            Self::ResolveTransfer(_, _) => Self::no_evm_execution("resolve_transfer"),
            Self::FtTransfer(_) => Self::no_evm_execution("ft_transfer"),
            TransactionKind::Withdraw(_) => Self::no_evm_execution("withdraw"),
            TransactionKind::StorageDeposit(_) => Self::no_evm_execution("storage_deposit"),
            TransactionKind::StorageUnregister(_) => Self::no_evm_execution("storage_unregister"),
            TransactionKind::StorageWithdraw(_) => Self::no_evm_execution("storage_withdraw"),
            TransactionKind::SetPausedFlags(_) => Self::no_evm_execution("set_paused_flags"),
            TransactionKind::RegisterRelayer(_) => Self::no_evm_execution("register_relayer"),
            TransactionKind::SetConnectorData(_) => Self::no_evm_execution("set_connector_data"),
            TransactionKind::NewConnector(_) => Self::no_evm_execution("new_connector"),
            TransactionKind::NewEngine(_) => Self::no_evm_execution("new_engine"),
            TransactionKind::FactoryUpdate(_) => Self::no_evm_execution("factory_update"),
            TransactionKind::FactoryUpdateAddressVersion(_) => {
                Self::no_evm_execution("factory_update_address_version")
            }
            TransactionKind::FactorySetWNearAddress(_) => {
                Self::no_evm_execution("factory_set_wnear_address")
            }
            TransactionKind::Unknown => Self::no_evm_execution("unknown"),
            Self::PausePrecompiles(_) => Self::no_evm_execution("pause_precompiles"),
            Self::ResumePrecompiles(_) => Self::no_evm_execution("resume_precompiles"),
        }
    }

    /// There are many cases where a receipt on NEAR can change the Aurora contract state, but no EVM execution actually occurs.
    /// In these cases we have a sentinel Ethereum transaction from the zero address to itself with input equal to the method name.
    fn no_evm_execution(method_name: &str) -> NormalizedEthTransaction {
        NormalizedEthTransaction {
            address: Address::from_array([0; 20]),
            chain_id: None,
            nonce: U256::zero(),
            gas_limit: U256::zero(),
            max_priority_fee_per_gas: U256::zero(),
            max_fee_per_gas: U256::zero(),
            to: Some(Address::from_array([0; 20])),
            value: Wei::zero(),
            data: method_name.as_bytes().to_vec(),
            access_list: Vec::new(),
        }
    }

    fn get_implicit_address(caller: &AccountId) -> types::Address {
        aurora_engine_sdk::types::near_account_to_evm_address(caller.as_bytes())
    }

    fn get_implicit_nonce(
        from: &types::Address,
        block_height: u64,
        transaction_position: u16,
        storage: &Storage,
    ) -> U256 {
        storage
            .with_engine_access(block_height, transaction_position, &[], |io| {
                aurora_engine::engine::get_nonce(&io, from)
            })
            .result
    }
}

/// This data type represents `TransactionMessage` above in the way consistent with how it is
/// stored on disk (in the DB). This type implements borsh (de)serialization. The purpose of
/// having a private struct for borsh, which is separate from the main `TransactionMessage`
/// which is used in the actual logic of executing transactions,
/// is to decouple the on-disk representation of the data from how it is used in the code.
/// This allows us to keep the `TransactionMessage` structure clean (no need to worry about
/// backwards compatibility with storage), hiding the complexity which is not important to
/// the logic of processing transactions.
///
/// V1 is an older version of `TransactionMessage`, before the addition of `promise_data`.
///
/// V2 is a structurally identical message to `TransactionMessage` above.
///
/// For details of what the individual fields mean, see the comments on the main
/// `TransactionMessage` type.
#[derive(BorshDeserialize, BorshSerialize)]
enum BorshableTransactionMessage<'a> {
    V1(BorshableTransactionMessageV1<'a>),
    V2(BorshableTransactionMessageV2<'a>),
}

#[derive(BorshDeserialize, BorshSerialize)]
struct BorshableTransactionMessageV1<'a> {
    pub block_hash: [u8; 32],
    pub near_receipt_id: [u8; 32],
    pub position: u16,
    pub succeeded: bool,
    pub signer: Cow<'a, AccountId>,
    pub caller: Cow<'a, AccountId>,
    pub attached_near: u128,
    pub transaction: BorshableTransactionKind<'a>,
}

#[derive(BorshDeserialize, BorshSerialize)]
struct BorshableTransactionMessageV2<'a> {
    pub block_hash: [u8; 32],
    pub near_receipt_id: [u8; 32],
    pub position: u16,
    pub succeeded: bool,
    pub signer: Cow<'a, AccountId>,
    pub caller: Cow<'a, AccountId>,
    pub attached_near: u128,
    pub transaction: BorshableTransactionKind<'a>,
    pub promise_data: Cow<'a, Vec<Option<Vec<u8>>>>,
}

impl<'a> From<&'a TransactionMessage> for BorshableTransactionMessage<'a> {
    fn from(t: &'a TransactionMessage) -> Self {
        Self::V2(BorshableTransactionMessageV2 {
            block_hash: t.block_hash.0,
            near_receipt_id: t.near_receipt_id.0,
            position: t.position,
            succeeded: t.succeeded,
            signer: Cow::Borrowed(&t.signer),
            caller: Cow::Borrowed(&t.caller),
            attached_near: t.attached_near,
            transaction: (&t.transaction).into(),
            promise_data: Cow::Borrowed(&t.promise_data),
        })
    }
}

impl<'a> TryFrom<BorshableTransactionMessage<'a>> for TransactionMessage {
    type Error = aurora_engine_transactions::Error;

    fn try_from(t: BorshableTransactionMessage<'a>) -> Result<Self, Self::Error> {
        match t {
            BorshableTransactionMessage::V1(t) => Ok(Self {
                block_hash: H256(t.block_hash),
                near_receipt_id: H256(t.near_receipt_id),
                position: t.position,
                succeeded: t.succeeded,
                signer: t.signer.into_owned(),
                caller: t.caller.into_owned(),
                attached_near: t.attached_near,
                transaction: t.transaction.try_into()?,
                promise_data: Vec::new(),
            }),
            BorshableTransactionMessage::V2(t) => Ok(Self {
                block_hash: H256(t.block_hash),
                near_receipt_id: H256(t.near_receipt_id),
                position: t.position,
                succeeded: t.succeeded,
                signer: t.signer.into_owned(),
                caller: t.caller.into_owned(),
                attached_near: t.attached_near,
                transaction: t.transaction.try_into()?,
                promise_data: t.promise_data.into_owned(),
            }),
        }
    }
}

/// Same as `TransactionKind`, but with `Submit` variant replaced with raw bytes
/// so that it can derive the Borsh traits. All non-copy elements are `Cow` also
/// so that this type can be cheaply created from a `TransactionKind` reference.
#[derive(BorshDeserialize, BorshSerialize, Clone)]
enum BorshableTransactionKind<'a> {
    Submit(Cow<'a, Vec<u8>>),
    Call(Cow<'a, parameters::CallArgs>),
    Deploy(Cow<'a, Vec<u8>>),
    DeployErc20(Cow<'a, parameters::DeployErc20TokenArgs>),
    FtOnTransfer(Cow<'a, parameters::NEP141FtOnTransferArgs>),
    Deposit(Cow<'a, Vec<u8>>),
    FtTransferCall(Cow<'a, parameters::TransferCallCallArgs>),
    FinishDeposit(Cow<'a, parameters::FinishDepositCallArgs>),
    ResolveTransfer(
        Cow<'a, parameters::ResolveTransferCallArgs>,
        Cow<'a, types::PromiseResult>,
    ),
    FtTransfer(Cow<'a, parameters::TransferCallArgs>),
    Withdraw(Cow<'a, aurora_engine_types::parameters::WithdrawCallArgs>),
    StorageDeposit(Cow<'a, parameters::StorageDepositCallArgs>),
    StorageUnregister(Option<bool>),
    StorageWithdraw(Cow<'a, parameters::StorageWithdrawCallArgs>),
    SetPausedFlags(Cow<'a, parameters::PauseEthConnectorCallArgs>),
    RegisterRelayer(Cow<'a, types::Address>),
    RefundOnError(Cow<'a, Option<aurora_engine_types::parameters::RefundCallArgs>>),
    SetConnectorData(Cow<'a, parameters::SetContractDataCallArgs>),
    NewConnector(Cow<'a, parameters::InitCallArgs>),
    NewEngine(Cow<'a, parameters::NewCallArgs>),
    FactoryUpdate(Cow<'a, Vec<u8>>),
    FactoryUpdateAddressVersion(Cow<'a, AddressVersionUpdateArgs>),
    FactorySetWNearAddress(types::Address),
    PausePrecompiles(Cow<'a, parameters::PausePrecompilesCallArgs>),
    ResumePrecompiles(Cow<'a, parameters::PausePrecompilesCallArgs>),
    Unknown,
}

impl<'a> From<&'a TransactionKind> for BorshableTransactionKind<'a> {
    fn from(t: &'a TransactionKind) -> Self {
        match t {
            TransactionKind::Submit(eth_tx) => {
                let tx_bytes = eth_tx.into();
                Self::Submit(Cow::Owned(tx_bytes))
            }
            TransactionKind::Call(x) => Self::Call(Cow::Borrowed(x)),
            TransactionKind::Deploy(x) => Self::Deploy(Cow::Borrowed(x)),
            TransactionKind::DeployErc20(x) => Self::DeployErc20(Cow::Borrowed(x)),
            TransactionKind::FtOnTransfer(x) => Self::FtOnTransfer(Cow::Borrowed(x)),
            TransactionKind::Deposit(x) => Self::Deposit(Cow::Borrowed(x)),
            TransactionKind::FtTransferCall(x) => Self::FtTransferCall(Cow::Borrowed(x)),
            TransactionKind::FinishDeposit(x) => Self::FinishDeposit(Cow::Borrowed(x)),
            TransactionKind::ResolveTransfer(x, y) => {
                Self::ResolveTransfer(Cow::Borrowed(x), Cow::Borrowed(y))
            }
            TransactionKind::FtTransfer(x) => Self::FtTransfer(Cow::Borrowed(x)),
            TransactionKind::Withdraw(x) => Self::Withdraw(Cow::Borrowed(x)),
            TransactionKind::StorageDeposit(x) => Self::StorageDeposit(Cow::Borrowed(x)),
            TransactionKind::StorageUnregister(x) => Self::StorageUnregister(*x),
            TransactionKind::StorageWithdraw(x) => Self::StorageWithdraw(Cow::Borrowed(x)),
            TransactionKind::SetPausedFlags(x) => Self::SetPausedFlags(Cow::Borrowed(x)),
            TransactionKind::RegisterRelayer(x) => Self::RegisterRelayer(Cow::Borrowed(x)),
            TransactionKind::RefundOnError(x) => Self::RefundOnError(Cow::Borrowed(x)),
            TransactionKind::SetConnectorData(x) => Self::SetConnectorData(Cow::Borrowed(x)),
            TransactionKind::NewConnector(x) => Self::NewConnector(Cow::Borrowed(x)),
            TransactionKind::NewEngine(x) => Self::NewEngine(Cow::Borrowed(x)),
            TransactionKind::FactoryUpdate(x) => Self::FactoryUpdate(Cow::Borrowed(x)),
            TransactionKind::FactoryUpdateAddressVersion(x) => {
                Self::FactoryUpdateAddressVersion(Cow::Borrowed(x))
            }
            TransactionKind::FactorySetWNearAddress(address) => {
                Self::FactorySetWNearAddress(*address)
            }
            TransactionKind::Unknown => Self::Unknown,
            TransactionKind::PausePrecompiles(x) => Self::PausePrecompiles(Cow::Borrowed(x)),
            TransactionKind::ResumePrecompiles(x) => Self::ResumePrecompiles(Cow::Borrowed(x)),
        }
    }
}

impl<'a> TryFrom<BorshableTransactionKind<'a>> for TransactionKind {
    type Error = aurora_engine_transactions::Error;

    fn try_from(t: BorshableTransactionKind<'a>) -> Result<Self, Self::Error> {
        match t {
            BorshableTransactionKind::Submit(tx_bytes) => {
                // `BorshableTransactionKind` is an internal type, so we will
                // assume the conversion is infallible. If the conversion were to
                // fail then something has gone very wrong.
                let eth_tx = tx_bytes.as_slice().try_into()?;
                Ok(Self::Submit(eth_tx))
            }
            BorshableTransactionKind::Call(x) => Ok(Self::Call(x.into_owned())),
            BorshableTransactionKind::Deploy(x) => Ok(Self::Deploy(x.into_owned())),
            BorshableTransactionKind::DeployErc20(x) => Ok(Self::DeployErc20(x.into_owned())),
            BorshableTransactionKind::FtOnTransfer(x) => Ok(Self::FtOnTransfer(x.into_owned())),
            BorshableTransactionKind::Deposit(x) => Ok(Self::Deposit(x.into_owned())),
            BorshableTransactionKind::FtTransferCall(x) => Ok(Self::FtTransferCall(x.into_owned())),
            BorshableTransactionKind::FinishDeposit(x) => Ok(Self::FinishDeposit(x.into_owned())),
            BorshableTransactionKind::ResolveTransfer(x, y) => {
                Ok(Self::ResolveTransfer(x.into_owned(), y.into_owned()))
            }
            BorshableTransactionKind::FtTransfer(x) => Ok(Self::FtTransfer(x.into_owned())),
            BorshableTransactionKind::Withdraw(x) => Ok(Self::Withdraw(x.into_owned())),
            BorshableTransactionKind::StorageDeposit(x) => Ok(Self::StorageDeposit(x.into_owned())),
            BorshableTransactionKind::StorageUnregister(x) => Ok(Self::StorageUnregister(x)),
            BorshableTransactionKind::StorageWithdraw(x) => {
                Ok(Self::StorageWithdraw(x.into_owned()))
            }
            BorshableTransactionKind::SetPausedFlags(x) => Ok(Self::SetPausedFlags(x.into_owned())),
            BorshableTransactionKind::RegisterRelayer(x) => {
                Ok(Self::RegisterRelayer(x.into_owned()))
            }
            BorshableTransactionKind::RefundOnError(x) => Ok(Self::RefundOnError(x.into_owned())),
            BorshableTransactionKind::SetConnectorData(x) => {
                Ok(Self::SetConnectorData(x.into_owned()))
            }
            BorshableTransactionKind::NewConnector(x) => Ok(Self::NewConnector(x.into_owned())),
            BorshableTransactionKind::NewEngine(x) => Ok(Self::NewEngine(x.into_owned())),
            BorshableTransactionKind::FactoryUpdate(x) => Ok(Self::FactoryUpdate(x.into_owned())),
            BorshableTransactionKind::FactoryUpdateAddressVersion(x) => {
                Ok(Self::FactoryUpdateAddressVersion(x.into_owned()))
            }
            BorshableTransactionKind::FactorySetWNearAddress(address) => {
                Ok(Self::FactorySetWNearAddress(address))
            }
            BorshableTransactionKind::Unknown => Ok(Self::Unknown),
            BorshableTransactionKind::PausePrecompiles(x) => {
                Ok(Self::PausePrecompiles(x.into_owned()))
            }
            BorshableTransactionKind::ResumePrecompiles(x) => {
                Ok(Self::ResumePrecompiles(x.into_owned()))
            }
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-tracing/Cargo.toml ---
[package]
name = "engine-standalone-tracing"
version = "0.1.0"
edition = "2021"
authors = ["Aurora Labs <hello@aurora.dev>"]
description = "Aurora engine standalone tracing library. Provides functions and types for extracing geth-like traces from standalone engine execution."
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "CC0-1.0"
publish = false
autobenches = false

[lib]
crate-type = ["lib"]

[dependencies]
aurora-engine-types = { path = "../engine-types", default-features = false, features = ["std"] }
evm-core = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false, features = ["std"] }
evm = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false, features = ["std", "tracing"] }
evm-runtime = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false, features = ["std", "tracing"] }
evm-gasometer = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false, features = ["std", "tracing"] }
hex = { version = "0.4", default-features = false, features = ["std"] }
serde = { version = "1", features = ["derive"], optional = true }

[features]
default = []
mainnet = []
testnet = []
impl-serde = ["aurora-engine-types/impl-serde", "serde"]

'''
'''--- aurora-engine-2.8.1/engine-standalone-tracing/src/lib.rs ---
pub mod sputnik;
pub mod types;

pub use types::{
    Depth, LogMemory, LogStack, LogStorage, LogStorageKey, LogStorageValue, Logs, ProgramCounter,
    StepTransactionTrace, TraceLog, TransactionTrace,
};

'''
'''--- aurora-engine-2.8.1/engine-standalone-tracing/src/sputnik.rs ---
use aurora_engine_types::types::EthGas;
use evm::{Capture, Opcode};
use std::cell::RefCell;
use std::ptr::NonNull;
use std::rc::Rc;

use crate::types::{
    LogStorageKey, LogStorageValue, Logs, ProgramCounter, TraceLog, TransactionTrace,
};

/// Capture all events from SputnikVM emitted from within the given closure using the given listener.
pub fn traced_call<T, R, F>(listener: &mut T, f: F) -> R
where
    T: evm_gasometer::tracing::EventListener
        + evm_runtime::tracing::EventListener
        + evm::tracing::EventListener
        + 'static,
    F: FnOnce() -> R,
{
    let mut gas_listener = SharedMutableReference::new(listener);
    let mut runtime_listener = gas_listener.clone();
    let mut evm_listener = gas_listener.clone();

    evm_gasometer::tracing::using(&mut gas_listener, || {
        evm_runtime::tracing::using(&mut runtime_listener, || {
            evm::tracing::using(&mut evm_listener, f)
        })
    })
}

#[derive(Debug, Clone, Default, PartialEq, Eq)]
pub struct TransactionTraceBuilder {
    logs: Vec<TraceLog>,
    current: TraceLog,
    current_memory_gas: u64,
    gas_used: EthGas,
    failed: bool,
    output: Vec<u8>,
}

impl TransactionTraceBuilder {
    pub fn finish(self) -> TransactionTrace {
        TransactionTrace::new(self.gas_used, self.failed, self.output, Logs(self.logs))
    }
}

impl evm_gasometer::tracing::EventListener for TransactionTraceBuilder {
    fn event(&mut self, event: evm_gasometer::tracing::Event) {
        use evm_gasometer::tracing::Event;
        match event {
            Event::RecordCost { cost, snapshot } => {
                self.current.gas_cost = EthGas::new(cost);
                if let Some(snapshot) = snapshot {
                    self.current.gas =
                        EthGas::new(snapshot.gas_limit - snapshot.used_gas - snapshot.memory_gas);
                }
            }
            Event::RecordDynamicCost {
                gas_cost,
                memory_gas,
                gas_refund: _,
                snapshot,
            } => {
                // In SputnikVM memory gas is cumulative (ie this event always shows the total) gas
                // spent on memory up to this point. But geth traces simply show how much gas each step
                // took, regardless of how that gas was used. So if this step caused an increase to the
                // memory gas then we need to record that.
                let memory_cost_diff = if memory_gas > self.current_memory_gas {
                    memory_gas - self.current_memory_gas
                } else {
                    0
                };
                self.current_memory_gas = memory_gas;
                self.current.gas_cost = EthGas::new(gas_cost + memory_cost_diff);
                if let Some(snapshot) = snapshot {
                    self.current.gas =
                        EthGas::new(snapshot.gas_limit - snapshot.used_gas - snapshot.memory_gas);
                }
            }
            Event::RecordRefund {
                refund: _,
                snapshot,
            } => {
                // This one seems to show up at the end of a transaction, so it
                // can be used to set the total gas used.
                if let Some(snapshot) = snapshot {
                    self.gas_used = EthGas::new(snapshot.used_gas);
                }
            }
            Event::RecordTransaction { .. } => (), // not useful
            Event::RecordStipend { .. } => (),     // not useful
        }
    }
}

impl evm_runtime::tracing::EventListener for TransactionTraceBuilder {
    fn event(&mut self, event: evm_runtime::tracing::Event) {
        use evm_runtime::tracing::Event;
        match event {
            Event::Step {
                address: _,
                opcode,
                position,
                stack,
                memory,
            } => {
                self.current.opcode = opcode;
                if let Ok(pc) = position {
                    self.current.program_counter = ProgramCounter(*pc as u32);
                }
                self.current.stack = stack
                    .data()
                    .iter()
                    .map(|x| {
                        let mut buf = [0u8; 32];
                        x.to_big_endian(&mut buf);
                        buf
                    })
                    .collect();
                self.current.memory = memory.data().as_slice().into();
            }

            Event::StepResult {
                result,
                return_value,
            } => {
                match result {
                    Ok(_) => {
                        // Step completed, push current log into the record
                        self.logs.push(self.current.clone());
                    }
                    Err(Capture::Exit(reason)) => {
                        // Step completed, push current log into the record
                        self.logs.push(self.current.clone());
                        // Current sub-call completed, reduce depth by 1
                        self.current.depth.decrement();

                        // if the depth is 0 then the transaction is complete
                        if self.current.depth.is_zero() {
                            if !return_value.is_empty() {
                                self.output = return_value.to_vec();
                            }
                            if !reason.is_succeed() {
                                self.failed = true;
                            }
                        }
                    }
                    Err(Capture::Trap(opcode)) => {
                        // "Trap" here means that there is some opcode which has special
                        // handling logic outside the core `step` function. This means the
                        // `StepResult` does not necessarily indicate the current log
                        // is finished yet. In particular, `SLoad` and `SStore` events come
                        // _after_ the `StepResult`, but still correspond to the current step.
                        if opcode == &Opcode::SLOAD || opcode == &Opcode::SSTORE {
                            // will push the log after processing `SLOAD` / `SSTORE` events
                        } else {
                            self.logs.push(self.current.clone());
                        }
                    }
                }
            }

            Event::SLoad {
                address: _,
                index,
                value,
            } => {
                self.current
                    .storage
                    .insert(LogStorageKey(index.0), LogStorageValue(value.0));
                self.logs.push(self.current.clone());
            }

            Event::SStore {
                address: _,
                index,
                value,
            } => {
                self.current
                    .storage
                    .insert(LogStorageKey(index.0), LogStorageValue(value.0));
                self.logs.push(self.current.clone());
            }
        }
    }
}

impl evm::tracing::EventListener for TransactionTraceBuilder {
    fn event(&mut self, event: evm::tracing::Event) {
        use evm::tracing::Event;
        match event {
            Event::Call { .. } => {
                self.current.depth.increment();
            }
            Event::Create { .. } => {
                self.current.depth.increment();
            }
            Event::Suicide { .. } => (), // TODO: ???
            Event::Exit {
                reason: _,
                return_value,
            } => {
                if !self.current.depth.is_zero() {
                    // If the depth is not zero then an error must have occurred to
                    // exit early.
                    self.failed = true;
                    self.output = return_value.to_vec();
                }
            }
            Event::PrecompileSubcall { .. } => (),
            Event::TransactCall { .. } => (), // no useful information
            Event::TransactCreate { .. } => (), // no useful information
            Event::TransactCreate2 { .. } => (), // no useful information
        }
    }
}

/// This structure is intentionally private to this module as it is memory unsafe (contains a raw pointer).
/// Its purpose here is to allow a single event handling object to be used as the listener for
/// all SputnikVM events. It is needed because the listener must be passed as an object with a `'static`
/// lifetime, hence a normal reference cannot be used and we resort to raw pointers. The usage of this
/// struct in this module is safe because the `SharedMutableReference` objects created do not outlive
/// the reference they are based on (see `pub fn traced_call`). Moreover, because the SputnikVM code
/// is single-threaded, we do not need to worry about race conditions.
struct SharedMutableReference<T> {
    pointer: Rc<RefCell<NonNull<T>>>,
}

impl<T> SharedMutableReference<T> {
    fn new(reference: &mut T) -> Self {
        let ptr = NonNull::new(reference as _).unwrap();
        Self {
            pointer: Rc::new(RefCell::new(ptr)),
        }
    }

    fn clone(&self) -> Self {
        Self {
            pointer: Rc::clone(&self.pointer),
        }
    }
}

impl<T: evm_gasometer::tracing::EventListener> evm_gasometer::tracing::EventListener
    for SharedMutableReference<T>
{
    fn event(&mut self, event: evm_gasometer::tracing::Event) {
        unsafe {
            self.pointer.borrow_mut().as_mut().event(event);
        }
    }
}

impl<T: evm_runtime::tracing::EventListener> evm_runtime::tracing::EventListener
    for SharedMutableReference<T>
{
    fn event(&mut self, event: evm_runtime::tracing::Event) {
        unsafe {
            self.pointer.borrow_mut().as_mut().event(event);
        }
    }
}

impl<T: evm::tracing::EventListener> evm::tracing::EventListener for SharedMutableReference<T> {
    fn event(&mut self, event: evm::tracing::Event) {
        unsafe {
            self.pointer.borrow_mut().as_mut().event(event);
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-tracing/src/types/call_tracer.rs ---
//! This module defines data structure to produce traces compatible with geths "callTracer":
//! https://github.com/ethereum/go-ethereum/blob/ad15050c7fbedd0f05a49e81400de18c2cc2c284/eth/tracers/native/call.go

use aurora_engine_types::{types::Address, U256};

#[derive(Debug, Clone, PartialEq, Eq)]
pub struct CallFrame {
    pub call_type: CallType,
    pub from: Address,
    pub to: Option<Address>,
    pub value: U256,
    pub gas: u64,
    pub gas_used: u64,
    pub input: Vec<u8>,
    pub output: Vec<u8>,
    pub error: Option<String>,
    pub calls: Vec<CallFrame>,
}

#[derive(Debug, Default, Clone, PartialEq, Eq)]
pub struct CallTracer {
    pub call_stack: Vec<CallFrame>,
}

impl CallTracer {
    fn end(&mut self, output: Vec<u8>, error: Option<&evm::ExitReason>) {
        let frame = self.call_stack.first_mut().unwrap();
        match error {
            None => frame.output = output,
            Some(error) => {
                let error_message = format!("{:?}", error);
                if error_message.to_lowercase().contains("revert") {
                    frame.output = output;
                }
                frame.error = Some(error_message);
            }
        }
    }

    fn enter(
        &mut self,
        call_type: CallType,
        from: Address,
        to: Address,
        input: Vec<u8>,
        gas: u64,
        value: U256,
    ) {
        let frame = CallFrame {
            call_type,
            from,
            to: Some(to),
            value,
            gas,
            gas_used: 0,
            input,
            output: Vec::new(),
            error: None,
            calls: Vec::new(),
        };
        self.call_stack.push(frame);
    }

    fn exit(&mut self, output: Vec<u8>, error: Option<&evm::ExitReason>) {
        if self.call_stack.len() <= 1 {
            return self.end(output, error);
        }

        let mut frame = self.call_stack.pop().unwrap();
        match error {
            None => frame.output = output,
            Some(error) => {
                frame.error = Some(format!("{:?}", error));
                match frame.call_type {
                    CallType::Create | CallType::Create2 => frame.to = None,
                    _ => (),
                }
            }
        }

        self.call_stack.last_mut().unwrap().calls.push(frame);
    }

    fn update_gas_from_snapshot(&mut self, snapshot: Option<evm_gasometer::Snapshot>) {
        if let Some(snapshot) = snapshot {
            if let Some(frame) = self.call_stack.last_mut() {
                frame.gas = snapshot.gas_limit;
                frame.gas_used = snapshot.used_gas + snapshot.memory_gas;
            }
        }
    }

    #[cfg(feature = "serde")]
    pub fn serializable(mut self) -> Option<SerializableCallFrame> {
        if self.call_stack.len() != 1 {
            // If there is more than one element in `call_stack` then it must mean the trace did not complete
            // because there is only 1 top-level call. Note: additional frames are added as new scopes are entered,
            // but then the frames are coalesced as those scopes are existed.
            return None;
        }

        Some(self.call_stack.pop().unwrap().into())
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum CallType {
    Call,
    StaticCall,
    DelegateCall,
    CallCode,
    Create,
    Create2,
    SelfDestruct,
}

impl AsRef<str> for CallType {
    fn as_ref(&self) -> &str {
        match self {
            Self::Call => "CALL",
            Self::StaticCall => "STATICCALL",
            Self::DelegateCall => "DELEGATECALL",
            Self::CallCode => "CALLCODE",
            Self::Create => "CREATE",
            Self::Create2 => "CREATE2",
            Self::SelfDestruct => "SELFDESTRUCT",
        }
    }
}

impl evm_gasometer::tracing::EventListener for CallTracer {
    fn event(&mut self, event: evm_gasometer::tracing::Event) {
        match event {
            // RecordRefund always comes at the end of an internal transaction and has all the gas information we need.
            evm_gasometer::tracing::Event::RecordRefund {
                refund: _,
                snapshot,
            } => self.update_gas_from_snapshot(snapshot),

            // Not useful
            evm_gasometer::tracing::Event::RecordCost { .. } => (),
            evm_gasometer::tracing::Event::RecordDynamicCost { .. } => (),
            evm_gasometer::tracing::Event::RecordStipend { .. } => (),
            evm_gasometer::tracing::Event::RecordTransaction { .. } => (),
        }
    }
}

impl evm_runtime::tracing::EventListener for CallTracer {
    fn event(&mut self, _event: evm_runtime::tracing::Event) {}
}

impl evm::tracing::EventListener for CallTracer {
    fn event(&mut self, event: evm::tracing::Event) {
        match event {
            evm::tracing::Event::Call {
                code_address,
                transfer,
                input,
                target_gas,
                is_static,
                context,
            } => {
                let call_type = if is_static {
                    CallType::StaticCall
                } else if code_address == context.address {
                    CallType::Call
                } else if transfer.is_none() {
                    CallType::DelegateCall
                } else {
                    CallType::CallCode
                };

                self.enter(
                    call_type,
                    Address::new(context.caller),
                    Address::new(context.address),
                    input.to_vec(),
                    target_gas.unwrap_or_default(),
                    context.apparent_value,
                );
            }
            evm::tracing::Event::Create {
                caller,
                address,
                scheme,
                value,
                init_code,
                target_gas,
            } => {
                let call_type = match scheme {
                    evm::CreateScheme::Legacy { .. } => CallType::Create,
                    evm::CreateScheme::Create2 { .. } => CallType::Create2,
                    evm::CreateScheme::Fixed(_) => CallType::Create, // is this even possible in production?
                };

                self.enter(
                    call_type,
                    Address::new(caller),
                    Address::new(address),
                    init_code.to_vec(),
                    target_gas.unwrap_or_default(),
                    value,
                );
            }
            evm::tracing::Event::Suicide {
                address,
                target,
                balance,
            } => {
                // TODO: gas = 0 is right?
                self.enter(
                    CallType::SelfDestruct,
                    Address::new(address),
                    Address::new(target),
                    Vec::new(),
                    0,
                    balance,
                );
                self.exit(Vec::new(), None);
            }
            // Exit event always comes after RecordRefund, so we don't need to worry about gas here (it's handled in RecordRefund)
            evm::tracing::Event::Exit {
                reason,
                return_value,
            } => {
                let error = match reason {
                    evm::ExitReason::Succeed(_) => None,
                    other => Some(other),
                };
                self.exit(return_value.to_vec(), error);
            }

            // not useful
            evm::tracing::Event::PrecompileSubcall { .. } => (),
            evm::tracing::Event::TransactCall { .. } => (),
            evm::tracing::Event::TransactCreate { .. } => (),
            evm::tracing::Event::TransactCreate2 { .. } => (),
        }
    }
}

#[cfg(feature = "serde")]
#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub struct SerializableCallFrame {
    #[serde(rename = "type")]
    call_type: String,
    from: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    to: Option<String>,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    value: Option<String>,
    gas: String,
    #[serde(rename = "gasUsed")]
    gas_used: String,
    input: String,
    output: String,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    error: Option<String>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    calls: Vec<SerializableCallFrame>,
}

#[cfg(feature = "serde")]
impl From<CallFrame> for SerializableCallFrame {
    fn from(frame: CallFrame) -> Self {
        let value = if frame.value.is_zero() {
            None
        } else {
            let value = frame.value;
            Some(format!("0x{value:x}"))
        };

        let gas = frame.gas;
        let gas_used = frame.gas_used;
        Self {
            call_type: frame.call_type.as_ref().into(),
            from: format!("0x{}", frame.from.encode()),
            to: frame.to.map(|addr| format!("0x{}", addr.encode())),
            value,
            gas: format!("0x{gas:x}"),
            gas_used: format!("0x{gas_used:x}"),
            input: format!("0x{}", hex::encode(&frame.input)),
            output: format!("0x{}", hex::encode(&frame.output)),
            error: frame.error,
            calls: frame.calls.into_iter().map(Into::into).collect(),
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-standalone-tracing/src/types/mod.rs ---
use aurora_engine_types::types::EthGas;
use aurora_engine_types::BTreeMap;
use evm_core::Opcode;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};
use std::ops::Index;

pub mod call_tracer;

/// Depth of a log.
#[derive(Debug, Clone, Copy, Default, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Depth(u32);

impl Depth {
    /// Performs the conversion into a u32.
    pub fn into_u32(self) -> u32 {
        self.0
    }

    pub fn increment(&mut self) {
        self.0 += 1;
    }

    pub fn decrement(&mut self) {
        self.0 -= 1;
    }

    pub fn is_zero(&self) -> bool {
        self.0 == 0
    }
}

/// A trace log memory.
#[derive(Debug, Clone, Default, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct LogMemory(Vec<[u8; 32]>);

impl LogMemory {
    /// Returns the number of elements in the memory buffer.
    pub fn len(&self) -> usize {
        self.0.len()
    }

    /// Returns true if there are no elements in the memory buffer.
    #[allow(dead_code)]
    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    /// Performs the conversion into a raw buffer.
    pub fn into_raw(self) -> Vec<[u8; 32]> {
        self.0
    }
}

impl From<&[u8]> for LogMemory {
    fn from(bytes: &[u8]) -> Self {
        let mut result = Vec::with_capacity(bytes.len() / 32);
        let mut buf = [0u8; 32];
        for (i, b) in bytes.iter().enumerate() {
            let j = i % 32;
            buf[j] = *b;
            if j == 31 {
                result.push(buf)
            }
        }
        Self(result)
    }
}

/// The stack of the log.
#[derive(Debug, Clone, Default, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct LogStack(Vec<[u8; 32]>);

impl LogStack {
    /// Returns the number of elements in the stack buffer.
    pub fn len(&self) -> usize {
        self.0.len()
    }

    /// Returns true if there are no elements in the stack buffer.
    #[allow(dead_code)]
    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    /// Performs the conversion into a vector.
    pub fn into_raw(self) -> Vec<[u8; 32]> {
        self.0
    }
}

impl std::iter::FromIterator<[u8; 32]> for LogStack {
    fn from_iter<T: IntoIterator<Item = [u8; 32]>>(iter: T) -> Self {
        let vec = iter.into_iter().collect();
        Self(vec)
    }
}

/// A trace log program counter.
#[derive(Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ProgramCounter(pub u32);

impl ProgramCounter {
    /// Performs the conversion into a u32.
    pub fn into_u32(self) -> u32 {
        self.0
    }
}

/// A storage key for the `LogStorage`.
#[derive(Debug, Clone, Default, PartialEq, Eq, PartialOrd, Ord)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct LogStorageKey(pub [u8; 32]);

impl LogStorageKey {
    /// Performs the conversion into a 32 byte word.
    pub fn into_raw(self) -> [u8; 32] {
        self.0
    }
}

/// A storage value for the `LogStorage`.
#[derive(Debug, Clone, Default, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct LogStorageValue(pub [u8; 32]);

impl LogStorageValue {
    /// Performs the conversion into a 32 byte word.
    pub fn into_raw(self) -> [u8; 32] {
        self.0
    }
}

/// A map for `LogStorageKeys` to `LogStorageValue`s.
#[derive(Debug, Clone, Default, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct LogStorage(BTreeMap<LogStorageKey, LogStorageValue>);

impl LogStorage {
    pub fn insert(&mut self, key: LogStorageKey, value: LogStorageValue) {
        self.0.insert(key, value);
    }
}

impl IntoIterator for LogStorage {
    type Item = (LogStorageKey, LogStorageValue);
    type IntoIter = std::collections::btree_map::IntoIter<LogStorageKey, LogStorageValue>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

/// The trace log of an execution on the EVM.
#[derive(Debug, Clone, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct TraceLog {
    /// The depth of the log.
    pub depth: Depth,
    /// Any errors that may have occurred during execution.
    pub error: Option<String>,
    /// Remaining (unused) gas.
    pub gas: EthGas,
    /// Gas cost for the opcode at this step.
    pub gas_cost: EthGas,
    /// The bounded memory.
    pub memory: LogMemory,
    /// The opcode as a byte.
    #[cfg_attr(feature = "serde", serde(with = "opcode_serde"))]
    pub opcode: Opcode,
    /// The current program counter of the transaction.
    pub program_counter: ProgramCounter,
    /// The local stack.
    pub stack: LogStack,
    /// The storage of the execution.
    pub storage: LogStorage,
}

impl Default for TraceLog {
    fn default() -> Self {
        Self {
            depth: Default::default(),
            error: Default::default(),
            gas: Default::default(),
            gas_cost: Default::default(),
            memory: Default::default(),
            opcode: Opcode::STOP,
            program_counter: Default::default(),
            stack: Default::default(),
            storage: Default::default(),
        }
    }
}

#[derive(Debug, Clone, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Logs(pub Vec<TraceLog>);

impl Logs {
    /// Returns the number of logs.
    #[allow(dead_code)]
    pub fn len(&self) -> usize {
        self.0.len()
    }

    /// Returns true if there are no logs.
    #[allow(dead_code)]
    pub fn is_empty(&self) -> bool {
        self.0.is_empty()
    }
}

impl Index<usize> for Logs {
    type Output = TraceLog;

    fn index(&self, index: usize) -> &Self::Output {
        &self.0[index]
    }
}

impl IntoIterator for Logs {
    type Item = TraceLog;
    type IntoIter = std::vec::IntoIter<Self::Item>;

    fn into_iter(self) -> Self::IntoIter {
        self.0.into_iter()
    }
}

#[derive(Debug, Default)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
#[allow(dead_code)]
pub struct TransactionTrace {
    /// The total gas cost of the transaction.
    gas: EthGas,
    /// Flag indicating if the operation exited with an error.
    failed: bool,
    /// Bytes returned from the execution
    return_value: Vec<u8>,
    /// The collection of traces.
    struct_logs: Logs,
}

impl TransactionTrace {
    /// Constructs a new TransactionTrace with a given gas, return, and logs.
    pub fn new(
        gas: EthGas,
        failed: bool,
        return_value: Vec<u8>,
        struct_logs: Logs,
    ) -> TransactionTrace {
        Self {
            gas,
            failed,
            return_value,
            struct_logs,
        }
    }

    /// Returns the EthGas associated with this transaction as a reference.
    pub fn gas(&self) -> EthGas {
        self.gas
    }

    /// Returns the output bytes of the transaction as a slice.
    pub fn result(&self) -> &[u8] {
        self.return_value.as_slice()
    }

    /// Returns a reference to the logs.
    pub fn logs(&self) -> &Logs {
        &self.struct_logs
    }
}

/// Consumes a `TransactionTrace` and provides the ability to step through each
/// execution of the transaction.
#[derive(Debug, Default)]
pub struct StepTransactionTrace {
    /// The under-laying transaction trace.
    inner: TransactionTrace,
    /// The current step.
    step: usize,
}

impl StepTransactionTrace {
    /// Constructs a new `TraceStepper` with a given `TransactionTrace`.
    #[allow(dead_code)]
    pub fn new(transaction_trace: TransactionTrace) -> Self {
        Self {
            inner: transaction_trace,
            step: 0,
        }
    }

    /// Steps through the logs, one at a time until it reaches the end of the
    /// execution.
    ///
    /// Returns a reference to a `TraceLog` if there is log, else it will return
    /// `None`.
    #[allow(dead_code)]
    pub fn step(&mut self) -> Option<&TraceLog> {
        if self.step > self.inner.struct_logs.len() {
            None
        } else {
            self.step += 1;
            Some(&self.inner.struct_logs[self.step])
        }
    }
}

// Custom serde serialization for opcode, given it is not provided upstream
// See here for custom serde serialization: https://serde.rs/custom-serialization.html
#[cfg(feature = "serde")]
mod opcode_serde {
    pub fn serialize<S>(opcode: &evm_core::Opcode, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_u8(opcode.0)
    }

    struct U8Visitor;

    impl<'de> serde::de::Visitor<'de> for U8Visitor {
        type Value = u8;

        fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
            formatter.write_str("an integer between 0 and 2^8 - 1")
        }

        fn visit_u8<E>(self, v: u8) -> Result<Self::Value, E>
        where
            E: serde::de::Error,
        {
            Ok(v)
        }
    }

    pub fn deserialize<'de, D>(deserializer: D) -> Result<evm_core::Opcode, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        Ok(evm_core::Opcode(deserializer.deserialize_u8(U8Visitor)?))
    }
}

'''
'''--- aurora-engine-2.8.1/engine-test-doubles/Cargo.toml ---
[package]
name = "aurora-engine-test-doubles"
version = "1.0.0"
authors = ["Aurora Labs <hello@aurora.dev>"]
edition = "2021"
description = "Contains implementations of engine traits suitable for using in tests"
documentation = ""
readme = true
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "GPL-3.0"
publish = false
autobenches = false

[dependencies]
aurora-engine-types = { path = "../engine-types", default-features = false, features = ["std"] }
aurora-engine-sdk = { path = "../engine-sdk" }
evm = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false, features = ["std", "tracing"] }
evm-runtime = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false, features = ["std", "tracing"] }
evm-gasometer = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false, features = ["std", "tracing"] }

[dev-dependencies]

'''
'''--- aurora-engine-2.8.1/engine-test-doubles/src/io.rs ---
use aurora_engine_sdk::io::{StorageIntermediate, IO};
use std::collections::HashMap;
use std::sync::RwLock;

pub struct Value(Vec<u8>);

impl StorageIntermediate for Value {
    fn len(&self) -> usize {
        self.0.len()
    }

    fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    fn copy_to_slice(&self, buffer: &mut [u8]) {
        buffer.copy_from_slice(&self.0)
    }
}

#[derive(Debug, Default)]
pub struct Storage {
    pub input: Vec<u8>,
    pub output: Vec<u8>,
    pub kv_store: HashMap<Vec<u8>, Vec<u8>>,
}

/// In-memory implementation of [IO].
#[derive(Debug, Clone, Copy)]
pub struct StoragePointer<'a>(pub &'a RwLock<Storage>);

impl<'a> IO for StoragePointer<'a> {
    type StorageValue = Value;

    fn read_input(&self) -> Self::StorageValue {
        Value(self.0.read().unwrap().input.clone())
    }

    fn return_output(&mut self, value: &[u8]) {
        let mut storage = self.0.write().unwrap();
        storage.output = value.to_vec();
    }

    fn read_storage(&self, key: &[u8]) -> Option<Self::StorageValue> {
        self.0
            .read()
            .unwrap()
            .kv_store
            .get(key)
            .map(|v| Value(v.clone()))
    }

    fn storage_has_key(&self, key: &[u8]) -> bool {
        self.0.read().unwrap().kv_store.contains_key(key)
    }

    fn write_storage(&mut self, key: &[u8], value: &[u8]) -> Option<Self::StorageValue> {
        let key = key.to_vec();
        let value = value.to_vec();
        let mut storage = self.0.write().unwrap();
        storage.kv_store.insert(key, value).map(Value)
    }

    fn write_storage_direct(
        &mut self,
        key: &[u8],
        value: Self::StorageValue,
    ) -> Option<Self::StorageValue> {
        let key = key.to_vec();
        let mut storage = self.0.write().unwrap();
        storage.kv_store.insert(key, value.0).map(Value)
    }

    fn remove_storage(&mut self, key: &[u8]) -> Option<Self::StorageValue> {
        let mut storage = self.0.write().unwrap();
        storage.kv_store.remove(key).map(Value)
    }
}

'''
'''--- aurora-engine-2.8.1/engine-test-doubles/src/lib.rs ---
pub mod io;
pub mod promise;
pub mod tracing;

'''
'''--- aurora-engine-2.8.1/engine-test-doubles/src/promise.rs ---
use aurora_engine_sdk::promise::PromiseHandler;
use aurora_engine_sdk::promise::PromiseId;
use aurora_engine_types::parameters::{PromiseBatchAction, PromiseCreateArgs};
use aurora_engine_types::types::PromiseResult;
use std::collections::HashMap;

#[derive(Debug, PartialEq, Eq)]
pub enum PromiseArgs {
    Create(PromiseCreateArgs),
    #[allow(dead_code)]
    Callback {
        base: PromiseId,
        callback: PromiseCreateArgs,
    },
    Batch(PromiseBatchAction),
}

/// Doesn't actually schedule any promises, only tracks what promises should be scheduled
#[derive(Default)]
pub struct PromiseTracker {
    internal_index: u64,
    pub promise_results: Vec<PromiseResult>,
    pub scheduled_promises: HashMap<u64, PromiseArgs>,
    pub returned_promise: Option<PromiseId>,
}

impl PromiseTracker {
    fn take_id(&mut self) -> u64 {
        let id = self.internal_index;
        self.internal_index += 1;
        id
    }
}

impl PromiseHandler for PromiseTracker {
    type ReadOnly = Self;

    fn promise_results_count(&self) -> u64 {
        self.promise_results.len() as u64
    }

    fn promise_result(&self, index: u64) -> Option<PromiseResult> {
        self.promise_results.get(index as usize).cloned()
    }

    unsafe fn promise_create_call(&mut self, args: &PromiseCreateArgs) -> PromiseId {
        let id = self.take_id();
        self.scheduled_promises
            .insert(id, PromiseArgs::Create(args.clone()));
        PromiseId::new(id)
    }

    unsafe fn promise_attach_callback(
        &mut self,
        base: PromiseId,
        callback: &PromiseCreateArgs,
    ) -> PromiseId {
        let id = self.take_id();
        self.scheduled_promises.insert(
            id,
            PromiseArgs::Callback {
                base,
                callback: callback.clone(),
            },
        );
        PromiseId::new(id)
    }

    unsafe fn promise_create_batch(&mut self, args: &PromiseBatchAction) -> PromiseId {
        let id = self.take_id();
        self.scheduled_promises
            .insert(id, PromiseArgs::Batch(args.clone()));
        PromiseId::new(id)
    }

    fn promise_return(&mut self, promise: PromiseId) {
        self.returned_promise = Some(promise);
    }

    fn read_only(&self) -> Self::ReadOnly {
        Self {
            internal_index: 0,
            promise_results: self.promise_results.clone(),
            scheduled_promises: Default::default(),
            returned_promise: Default::default(),
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-test-doubles/src/tracing.rs ---
#[derive(Debug, Clone, PartialEq, Eq, Default)]
pub struct Listener {
    pub events: Vec<String>,
}

impl evm_gasometer::tracing::EventListener for Listener {
    fn event(&mut self, event: evm_gasometer::tracing::Event) {
        self.events.push(format!("{:?}", event));
    }
}

impl evm_runtime::tracing::EventListener for Listener {
    fn event(&mut self, event: evm_runtime::tracing::Event) {
        self.events.push(format!("{:?}", event));
    }
}

impl evm::tracing::EventListener for Listener {
    fn event(&mut self, event: evm::tracing::Event) {
        self.events.push(format!("{:?}", event));
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/Cargo.toml ---
[package]
name = "aurora-engine-tests"
version = "1.0.0"
authors = ["Aurora Labs <hello@aurora.dev>"]
edition = "2021"
description = ""
documentation = ""
readme = true
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "GPL-3.0"
publish = false
autobenches = false

[dependencies]

[dev-dependencies]
aurora-engine = { path = "../engine", default-features = false, features = ["std", "tracing"] }
aurora-engine-test-doubles = { path = "../engine-test-doubles", default-features = false }
aurora-engine-types = { path = "../engine-types", default-features = false, features = ["std"] }
aurora-engine-sdk = { path = "../engine-sdk", default-features = false, features = ["std"] }
aurora-engine-precompiles = { path = "../engine-precompiles", default-features = false, features = ["std"] }
aurora-engine-transactions = { path = "../engine-transactions", default-features = false, features = ["std"] }
engine-standalone-storage = { path = "../engine-standalone-storage" }
engine-standalone-tracing = { path = "../engine-standalone-tracing", default-features = false, features = ["impl-serde"] }
borsh = { version = "0.9.3", default-features = false }
sha3 = { version = "0.10.2", default-features = false }
evm = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false, features = ["std", "tracing"] }
evm-runtime = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false, features = ["std", "tracing"] }
evm-gasometer = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false, features = ["std", "tracing"] }
rlp = { version = "0.5.0", default-features = false }
base64 = "0.13.0"
bstr = "1.0.1"
byte-slice-cast = { version = "1.0", default-features = false }
ethabi = "18.0"
serde = { version = "1", features = ["derive"] }
serde_json = "1"
hex = { version = "0.4.3", default-features = false }
near-sdk = { git = "https://github.com/aurora-is-near/near-sdk-rs.git", rev = "a4634850023fd115053970f17e10861779d5167d" }
near-sdk-sim = { git = "https://github.com/aurora-is-near/near-sdk-rs.git", rev = "a4634850023fd115053970f17e10861779d5167d" }
near-crypto = { git = "https://github.com/birchmd/nearcore.git", rev = "6033903be2037d67510188450f289b2d6e033f04" }
near-vm-errors = { git = "https://github.com/birchmd/nearcore.git", rev = "6033903be2037d67510188450f289b2d6e033f04" }
near-vm-runner = { git = "https://github.com/birchmd/nearcore.git", rev = "6033903be2037d67510188450f289b2d6e033f04", default-features = false, features = [ "wasmer2_vm" ] }
near-vm-logic = { git = "https://github.com/birchmd/nearcore.git", rev = "6033903be2037d67510188450f289b2d6e033f04" }
near-primitives-core = { git = "https://github.com/birchmd/nearcore.git", rev = "6033903be2037d67510188450f289b2d6e033f04" }
near-primitives = { git = "https://github.com/birchmd/nearcore.git", rev = "6033903be2037d67510188450f289b2d6e033f04", default-features = false, features = [ "nightly_protocol" ] }
libsecp256k1 = { version = "0.7.0", default-features = false }
rand = "0.8.5"
criterion = "0.4.0"
git2 = "0.15"
tempfile = "3.2.0"
walrus = "0.19"

[features]
mainnet-test = []
testnet-test = []
error_refund = ["aurora-engine/error_refund", "aurora-engine-precompiles/error_refund"]

'''
'''--- aurora-engine-2.8.1/engine-tests/src/benches/eth_deploy_code.rs ---
use criterion::{BatchSize, BenchmarkId, Criterion, Throughput};
use libsecp256k1::SecretKey;

use crate::prelude::Wei;
use crate::test_utils::{
    address_from_secret_key, create_deploy_transaction, deploy_evm, sign_transaction, SUBMIT,
};

const INITIAL_BALANCE: Wei = Wei::new_u64(1000);
const INITIAL_NONCE: u64 = 0;

pub(crate) fn eth_deploy_code_benchmark(c: &mut Criterion) {
    let mut runner = deploy_evm();
    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    runner.create_address(
        address_from_secret_key(&source_account),
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    let inputs: Vec<_> = [1, 4, 8, 10, 13, 14]
        .iter()
        .copied()
        .map(|n| {
            let code_size = 2usize.pow(n);
            let code: Vec<u8> = vec![0; code_size];
            let transaction = create_deploy_transaction(code, INITIAL_NONCE.into());
            let signed_transaction =
                sign_transaction(transaction, Some(runner.chain_id), &source_account);
            rlp::encode(&signed_transaction).to_vec()
        })
        .collect();
    let calling_account_id = "some-account.near";

    // measure gas usage
    for input in inputs.iter() {
        let input_size = input.len();
        let (output, maybe_err) = runner
            .one_shot()
            .call(SUBMIT, calling_account_id, input.clone());
        assert!(maybe_err.is_none());
        let output = output.unwrap();
        let gas = output.burnt_gas;
        let eth_gas = crate::test_utils::parse_eth_gas(&output);
        // TODO(#45): capture this in a file
        println!("ETH_DEPLOY_CODE_{:?} NEAR GAS: {:?}", input_size, gas);
        println!("ETH_DEPLOY_CODE_{:?} ETH GAS: {:?}", input_size, eth_gas);
    }

    // measure wall-clock time
    let mut group = c.benchmark_group("deploy_code");
    for input in inputs {
        let input_size = input.len() as u64;
        let id = BenchmarkId::from_parameter(input_size);
        group.throughput(Throughput::Bytes(input_size));
        group.bench_function(id, |b| {
            b.iter_batched(
                || (runner.one_shot(), calling_account_id, input.clone()),
                |(r, c, i)| r.call(SUBMIT, c, i),
                BatchSize::SmallInput,
            )
        });
    }
    group.finish();
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/benches/eth_erc20.rs ---
use crate::prelude::U256;
use criterion::{BatchSize, BenchmarkId, Criterion};
use libsecp256k1::SecretKey;

use crate::test_utils::erc20::{ERC20Constructor, ERC20};
use crate::test_utils::{address_from_secret_key, deploy_evm, sign_transaction, SUBMIT};

const INITIAL_BALANCE: u64 = 1000;
const INITIAL_NONCE: u64 = 0;
const TRANSFER_AMOUNT: u64 = 67;

pub(crate) fn eth_erc20_benchmark(c: &mut Criterion) {
    let mut runner = deploy_evm();
    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    runner.create_address(
        address_from_secret_key(&source_account),
        crate::prelude::Wei::new_u64(INITIAL_BALANCE),
        INITIAL_NONCE.into(),
    );
    let calling_account_id = "some-account.near";

    // deploy the erc20 contract
    let constructor = ERC20Constructor::load();
    let contract = ERC20(runner.deploy_contract(
        &source_account,
        |c| c.deploy("Benchmarker", "BENCH", INITIAL_NONCE.into()),
        constructor,
    ));

    // create the transaction for minting
    let tx = contract.mint(
        address_from_secret_key(&source_account),
        INITIAL_BALANCE.into(),
        U256::from(INITIAL_NONCE + 1),
    );
    let signed_tx = sign_transaction(tx, Some(runner.chain_id), &source_account);
    let mint_tx_bytes = rlp::encode(&signed_tx).to_vec();

    // create the transaction for transfer
    let dest_address = address_from_secret_key(&SecretKey::random(&mut rng));
    let tx = contract.transfer(
        dest_address,
        TRANSFER_AMOUNT.into(),
        U256::from(INITIAL_NONCE + 2),
    );
    let signed_tx = sign_transaction(tx, Some(runner.chain_id), &source_account);
    let transfer_tx_bytes = rlp::encode(&signed_tx).to_vec();

    let mut group = c.benchmark_group("erc20");
    let mint_id = BenchmarkId::from_parameter("mint");
    let transfer_id = BenchmarkId::from_parameter("transfer");

    // measure mint wall-clock time
    group.bench_function(mint_id, |b| {
        b.iter_batched(
            || (runner.one_shot(), calling_account_id, mint_tx_bytes.clone()),
            |(r, c, i)| r.call(SUBMIT, c, i),
            BatchSize::SmallInput,
        )
    });

    // Measure mint gas usage; don't use `one_shot` because we want to keep this state change for
    // the next benchmark where we transfer some of the minted tokens.
    let (output, maybe_error) = runner.call(SUBMIT, calling_account_id, mint_tx_bytes.clone());
    assert!(maybe_error.is_none());
    let output = output.unwrap();
    let gas = output.burnt_gas;
    let eth_gas = crate::test_utils::parse_eth_gas(&output);
    // TODO(#45): capture this in a file
    println!("ETH_ERC20_MINT NEAR GAS: {:?}", gas);
    println!("ETH_ERC20_MINT ETH GAS: {:?}", eth_gas);

    // Measure transfer gas usage
    let (output, maybe_err) =
        runner
            .one_shot()
            .call(SUBMIT, calling_account_id, transfer_tx_bytes.clone());
    assert!(maybe_err.is_none());
    let output = output.unwrap();
    let gas = output.burnt_gas;
    let eth_gas = crate::test_utils::parse_eth_gas(&output);
    // TODO(#45): capture this in a file
    println!("ETH_ERC20_TRANSFER NEAR GAS: {:?}", gas);
    println!("ETH_ERC20_TRANSFER ETH GAS: {:?}", eth_gas);

    // measure transfer wall-clock time
    group.bench_function(transfer_id, |b| {
        b.iter_batched(
            || {
                (
                    runner.one_shot(),
                    calling_account_id,
                    transfer_tx_bytes.clone(),
                )
            },
            |(r, c, i)| r.call(SUBMIT, c, i),
            BatchSize::SmallInput,
        )
    });

    group.finish();
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/benches/eth_standard_precompiles.rs ---
use crate::prelude::U256;
use criterion::{BatchSize, BenchmarkId, Criterion};
use libsecp256k1::SecretKey;

use crate::prelude::Wei;
use crate::test_utils::standard_precompiles::{PrecompilesConstructor, PrecompilesContract};
use crate::test_utils::{address_from_secret_key, deploy_evm, sign_transaction, SUBMIT};

const INITIAL_BALANCE: Wei = Wei::new_u64(1000);
const INITIAL_NONCE: u64 = 0;

pub(crate) fn eth_standard_precompiles_benchmark(c: &mut Criterion) {
    let mut runner = deploy_evm();
    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    runner.create_address(
        address_from_secret_key(&source_account),
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    let calling_account_id = "some-account.near";

    // deploy StandardPrecompiles contract
    let constructor = PrecompilesConstructor::load();
    let contract = PrecompilesContract(runner.deploy_contract(
        &source_account,
        |c| c.deploy(INITIAL_NONCE.into()),
        constructor,
    ));

    let test_names = PrecompilesContract::all_method_names();
    let bench_ids = test_names.iter().map(BenchmarkId::from_parameter);

    // create testing transactions
    let transactions: Vec<_> = test_names
        .iter()
        .map(|method_name| {
            let tx = contract.call_method(method_name, U256::from(INITIAL_NONCE + 1));
            let signed_tx = sign_transaction(tx, Some(runner.chain_id), &source_account);
            rlp::encode(&signed_tx).to_vec()
        })
        .collect();

    // measure gas usage
    for (tx_bytes, name) in transactions.iter().zip(test_names.iter()) {
        let (output, maybe_err) =
            runner
                .one_shot()
                .call(SUBMIT, calling_account_id, tx_bytes.clone());
        assert!(maybe_err.is_none());
        let output = output.unwrap();
        let gas = output.burnt_gas;
        let eth_gas = crate::test_utils::parse_eth_gas(&output);
        // TODO(#45): capture this in a file
        println!("ETH_STANDARD_PRECOMPILES_{} NEAR GAS: {:?}", name, gas);
        println!("ETH_STANDARD_PRECOMPILES_{} ETH GAS: {:?}", name, eth_gas);
    }

    let mut group = c.benchmark_group("standard_precompiles");

    // measure wall-clock time
    for (tx_bytes, id) in transactions.iter().zip(bench_ids.into_iter()) {
        group.bench_function(id, |b| {
            b.iter_batched(
                || (runner.one_shot(), calling_account_id, tx_bytes.clone()),
                |(r, c, i)| r.call(SUBMIT, c, i),
                BatchSize::SmallInput,
            )
        });
    }

    group.finish();
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/benches/eth_transfer.rs ---
use criterion::{BatchSize, Criterion};
use libsecp256k1::SecretKey;

use crate::prelude::Wei;
use crate::test_utils::{address_from_secret_key, create_eth_transaction, deploy_evm, SUBMIT};

const INITIAL_BALANCE: Wei = Wei::new_u64(1000);
const INITIAL_NONCE: u64 = 0;
const TRANSFER_AMOUNT: Wei = Wei::new_u64(123);

pub(crate) fn eth_transfer_benchmark(c: &mut Criterion) {
    let mut runner = deploy_evm();
    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    runner.create_address(
        address_from_secret_key(&source_account),
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    let dest_account = address_from_secret_key(&SecretKey::random(&mut rng));
    let transaction = create_eth_transaction(
        Some(dest_account),
        TRANSFER_AMOUNT,
        vec![],
        Some(runner.chain_id),
        &source_account,
    );
    let input = rlp::encode(&transaction).to_vec();
    let calling_account_id = "some-account.near";

    // measure gas usage
    let (output, maybe_err) = runner
        .one_shot()
        .call(SUBMIT, calling_account_id, input.clone());
    assert!(maybe_err.is_none());
    let gas = output.unwrap().burnt_gas;
    // TODO(#45): capture this in a file
    println!("ETH_TRANSFER NEAR GAS: {:?}", gas);
    println!("ETH_TRANSFER ETH GAS: {:?}", 21_000);

    // measure wall-clock time
    c.bench_function("eth_transfer", |b| {
        b.iter_batched(
            || (runner.one_shot(), calling_account_id, input.clone()),
            |(r, c, i)| r.call(SUBMIT, c, i),
            BatchSize::SmallInput,
        )
    });
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/benches/mod.rs ---
use crate::tests::uniswap::UniswapTestContext;
use criterion::Criterion;

mod eth_deploy_code;
mod eth_erc20;
mod eth_standard_precompiles;
mod eth_transfer;
mod nft_pagination;
mod uniswap;

// We don't want to run in CI, so ignore. To run locally use `cargo test --release -- --ignored`
#[test]
#[ignore]
fn benches() {
    let mut c = Criterion::default();

    eth_deploy_code::eth_deploy_code_benchmark(&mut c);
    eth_erc20::eth_erc20_benchmark(&mut c);
    eth_standard_precompiles::eth_standard_precompiles_benchmark(&mut c);
    eth_transfer::eth_transfer_benchmark(&mut c);

    c.final_summary();
}

#[test]
#[ignore]
fn measure_nft_pagination_gas_usage() {
    const TOTAL_TOKENS: usize = 500;
    let data_sizes = [100, 500, 1000, 2000];
    let tokens_per_page = [1, 2, 4, 8, 16, 32];

    for size in data_sizes {
        for n_tokens in tokens_per_page {
            let gas_used = nft_pagination::measure_gas_usage(TOTAL_TOKENS, size, n_tokens);
            println!("{},{},{}", size, n_tokens, gas_used);
        }
    }
}

#[test]
#[ignore]
fn uniswap_benches() {
    let mut c = Criterion::default();

    let mut context = UniswapTestContext::new("uniswap-wasmer2");
    uniswap::uniswap_benchmark(&mut c, &mut context);

    let mut context = UniswapTestContext::new("uniswap-wasmer2-no-gas");
    context.no_gas();
    uniswap::uniswap_benchmark(&mut c, &mut context);

    c.final_summary();
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/benches/nft_pagination.rs ---
use crate::prelude::{Address, Wei, U256};
use crate::test_utils::{self, solidity};
use aurora_engine_transactions::legacy::TransactionLegacy;
use libsecp256k1::SecretKey;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::sync::Once;

const INITIAL_BALANCE: Wei = Wei::new_u64(1_000);
const INITIAL_NONCE: u64 = 0;

static DOWNLOAD_ONCE: Once = Once::new();
static COMPILE_ONCE: Once = Once::new();

pub(crate) fn measure_gas_usage(
    total_tokens: usize,
    data_size: usize,
    tokens_per_page: usize,
) -> u64 {
    let (mut runner, mut source_account, dest_address) = initialize_evm();

    let marketplace_constructor = MarketPlaceConstructor::load();
    let nonce = source_account.use_nonce();
    let marketplace = MarketPlace(runner.deploy_contract(
        &source_account.secret_key,
        |c| c.deploy_without_args(nonce.into()),
        marketplace_constructor.0,
    ));

    // mint NFTs
    let data = "0".repeat(data_size);
    for i in 0..total_tokens {
        let result = runner
            .submit_with_signer(&mut source_account, |nonce| {
                marketplace.mint(
                    dest_address,
                    data.clone(),
                    Wei::from_eth(i.into()).unwrap(),
                    nonce,
                )
            })
            .unwrap();
        assert!(result.status.is_ok());
    }

    // show them
    let nonce = source_account.nonce;
    let tx = marketplace.get_page(tokens_per_page, 0, nonce.into());
    let (result, profile) = runner.profiled_view_call(test_utils::as_view_call(tx, dest_address));

    let status = result.unwrap();
    assert!(status.is_ok());
    profile.all_gas()
}

struct MarketPlaceConstructor(solidity::ContractConstructor);

struct MarketPlace(solidity::DeployedContract);

impl MarketPlaceConstructor {
    pub fn load() -> Self {
        let sources_path = Self::download_solidity_sources();
        let compile_artifact = Self::truffle_compile(sources_path);
        Self(solidity::ContractConstructor::compile_from_extended_json(
            compile_artifact,
        ))
    }

    fn truffle_compile<P: AsRef<Path>>(contracts_dir: P) -> PathBuf {
        COMPILE_ONCE.call_once(|| {
            // install npm packages
            let status = Command::new("/usr/bin/env")
                .current_dir(contracts_dir.as_ref())
                .args(["npm", "install"])
                .status()
                .unwrap();
            assert!(status.success());

            // install truffle
            let status = Command::new("/usr/bin/env")
                .current_dir(contracts_dir.as_ref())
                .args(["npm", "install", "--save-dev", "truffle"])
                .status()
                .unwrap();
            assert!(status.success());

            // compile
            let status = Command::new("/usr/bin/env")
                .current_dir(contracts_dir.as_ref())
                .args([
                    "node_modules/truffle/build/cli.bundled.js",
                    "compile",
                    "--all",
                ])
                .status()
                .unwrap();
            assert!(status.success());
        });

        // compile artifacts are saved to this path
        // (specified in truffle config of `NFT-culturas-latinas` repo)
        let artifacts_path =
            std::fs::canonicalize(contracts_dir.as_ref().join("../frontend/src/contracts/"))
                .unwrap();

        artifacts_path.join("MarketPlace.json")
    }

    fn download_solidity_sources() -> PathBuf {
        let sources_dir = Path::new("target").join("NFT-culturas-latinas");
        let contracts_dir = sources_dir.join("blockchain");
        if contracts_dir.exists() {
            contracts_dir
        } else {
            // Contracts not already present, so download them (but only once, even
            // if multiple tests running in parallel saw `contracts_dir` does not exist).
            DOWNLOAD_ONCE.call_once(|| {
                let url = "https://github.com/birchmd/NFT-culturas-latinas.git";
                git2::Repository::clone(url, sources_dir).unwrap();
            });
            contracts_dir
        }
    }
}

impl MarketPlace {
    pub fn mint(
        &self,
        recipient: Address,
        data: String,
        price: Wei,
        nonce: U256,
    ) -> TransactionLegacy {
        self.0.call_method_with_args(
            "minar",
            &[
                ethabi::Token::Address(recipient.raw()),
                ethabi::Token::String(data),
                ethabi::Token::Uint(price.raw()),
            ],
            nonce,
        )
    }

    pub fn get_page(
        &self,
        tokens_per_page: usize,
        page_index: usize,
        nonce: U256,
    ) -> TransactionLegacy {
        self.0.call_method_with_args(
            "obtenerPaginav2",
            &[
                ethabi::Token::Uint(U256::from(tokens_per_page)),
                ethabi::Token::Uint(U256::from(page_index)),
            ],
            nonce,
        )
    }
}

fn initialize_evm() -> (test_utils::AuroraRunner, test_utils::Signer, Address) {
    // set up Aurora runner and accounts
    let mut runner = test_utils::deploy_evm();
    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    let source_address = test_utils::address_from_secret_key(&source_account);
    runner.create_address(source_address, INITIAL_BALANCE, INITIAL_NONCE.into());
    let dest_address = test_utils::address_from_secret_key(&SecretKey::random(&mut rng));
    let mut signer = test_utils::Signer::new(source_account);
    signer.nonce = INITIAL_NONCE;

    runner.wasm_config.limit_config.max_gas_burnt = u64::MAX;

    (runner, signer, dest_address)
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/benches/uniswap.rs ---
use criterion::{BatchSize, BenchmarkId, Criterion};

use crate::prelude::U256;
use crate::test_utils::{self, SUBMIT};
use crate::tests::uniswap::UniswapTestContext;

const MINT_AMOUNT: u64 = 1_000_000_000;
const LIQUIDITY_AMOUNT: u64 = MINT_AMOUNT / 2;
const OUTPUT_AMOUNT: u64 = LIQUIDITY_AMOUNT / 100;

pub(crate) fn uniswap_benchmark(c: &mut Criterion, context: &mut UniswapTestContext) {
    let calling_account_id = "some-account.near";
    let chain_id = Some(context.runner.chain_id);
    let (token_a, token_b) = context.create_token_pair(MINT_AMOUNT.into());
    context.create_pool(&token_a, &token_b);

    // Approve spending the tokens
    context.approve_erc20(&token_a, context.manager.0.address, U256::MAX);
    context.approve_erc20(&token_b, context.manager.0.address, U256::MAX);
    context.approve_erc20(&token_a, context.swap_router.0.address, U256::MAX);
    context.approve_erc20(&token_b, context.swap_router.0.address, U256::MAX);

    // create transaction for adding liquidity
    let nonce = context.signer.use_nonce();
    let liquidity_params = context.mint_params(LIQUIDITY_AMOUNT.into(), &token_a, &token_b);
    let tx = context.manager.mint(liquidity_params, nonce.into());
    let signed_tx = test_utils::sign_transaction(tx, chain_id, &context.signer.secret_key);
    let liquidity_tx_bytes = rlp::encode(&signed_tx).to_vec();

    // create transaction for swapping
    let nonce = context.signer.use_nonce();
    let swap_params = context.exact_output_single_params(OUTPUT_AMOUNT.into(), &token_a, &token_b);
    let tx = context
        .swap_router
        .exact_output_single(swap_params, nonce.into());
    let signed_tx = test_utils::sign_transaction(tx, chain_id, &context.signer.secret_key);
    let swap_tx_bytes = rlp::encode(&signed_tx).to_vec();

    let mut group = c.benchmark_group(&context.name);
    let liquidity_id = BenchmarkId::from_parameter("add_liquidity");
    let swap_id = BenchmarkId::from_parameter("swap");

    // measure add_liquidity wall-clock time
    group.bench_function(liquidity_id, |b| {
        b.iter_batched(
            || {
                (
                    context.runner.one_shot(),
                    calling_account_id,
                    liquidity_tx_bytes.clone(),
                )
            },
            |(r, c, i)| r.call(SUBMIT, c, i),
            BatchSize::SmallInput,
        )
    });

    // Measure add_liquidity gas usage; don't use `one_shot` because we want to keep
    // this state change for the next benchmark where we swap some tokens in the pool.
    let (output, maybe_error) =
        context
            .runner
            .call(SUBMIT, calling_account_id, liquidity_tx_bytes.clone());
    assert!(maybe_error.is_none());
    let output = output.unwrap();
    let gas = output.burnt_gas;
    let eth_gas = crate::test_utils::parse_eth_gas(&output);
    // TODO(#45): capture this in a file
    println!("UNISWAP_ADD_LIQUIDITY NEAR GAS: {:?}", gas);
    println!("UNISWAP_ADD_LIQUIDITY ETH GAS: {:?}", eth_gas);

    // Measure swap gas usage
    let (output, maybe_error) =
        context
            .runner
            .one_shot()
            .call(SUBMIT, calling_account_id, swap_tx_bytes.clone());
    assert!(maybe_error.is_none());
    let output = output.unwrap();
    let gas = output.burnt_gas;
    let eth_gas = crate::test_utils::parse_eth_gas(&output);
    // TODO(#45): capture this in a file
    println!("UNISWAP_SWAP NEAR GAS: {:?}", gas);
    println!("UNISWAP_SWAP ETH GAS: {:?}", eth_gas);

    // measure add_liquidity wall-clock time
    group.bench_function(swap_id, |b| {
        b.iter_batched(
            || {
                (
                    context.runner.one_shot(),
                    calling_account_id,
                    swap_tx_bytes.clone(),
                )
            },
            |(r, c, i)| r.call(SUBMIT, c, i),
            BatchSize::SmallInput,
        )
    });

    group.finish();
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/lib.rs ---
#[cfg(test)]
mod benches;
#[cfg(test)]
mod prelude;
#[cfg(test)]
mod test_utils;
#[cfg(test)]
mod tests;

'''
'''--- aurora-engine-2.8.1/engine-tests/src/prelude.rs ---
mod v0 {
    pub use aurora_engine::connector;
    pub use aurora_engine::fungible_token;
    #[cfg(feature = "meta-call")]
    pub use aurora_engine::meta_parsing;
    pub use aurora_engine::parameters;
    pub use aurora_engine_sdk as sdk;
    pub use aurora_engine_transactions as transactions;
    pub use aurora_engine_types::parameters::*;
    pub use aurora_engine_types::storage;
    pub use aurora_engine_types::types::*;
    pub use aurora_engine_types::*;
    pub use borsh::{BorshDeserialize, BorshSerialize};
}

pub use v0::*;

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/erc20.rs ---
use crate::prelude::{transactions::legacy::TransactionLegacy, Address, U256};
use crate::test_utils::solidity;
use aurora_engine_transactions::NormalizedEthTransaction;
use std::path::{Path, PathBuf};
use std::sync::Once;

pub(crate) struct ERC20Constructor(pub solidity::ContractConstructor);

pub(crate) struct ERC20(pub solidity::DeployedContract);

impl From<ERC20Constructor> for solidity::ContractConstructor {
    fn from(c: ERC20Constructor) -> Self {
        c.0
    }
}

static DOWNLOAD_ONCE: Once = Once::new();

impl ERC20Constructor {
    pub fn load() -> Self {
        Self(solidity::ContractConstructor::compile_from_source(
            Self::download_solidity_sources(),
            Self::solidity_artifacts_path(),
            "token/ERC20/presets/ERC20PresetMinterPauser.sol",
            "ERC20PresetMinterPauser",
        ))
    }

    pub fn deploy(&self, name: &str, symbol: &str, nonce: U256) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .constructor()
            .unwrap()
            .encode_input(
                self.0.code.clone(),
                &[
                    ethabi::Token::String(name.to_string()),
                    ethabi::Token::String(symbol.to_string()),
                ],
            )
            .unwrap();
        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: None,
            value: Default::default(),
            data,
        }
    }

    fn download_solidity_sources() -> PathBuf {
        let sources_dir = Path::new("target").join("openzeppelin-contracts");
        let contracts_dir = sources_dir.join("contracts");
        if contracts_dir.exists() {
            contracts_dir
        } else {
            // Contracts not already present, so download them (but only once, even
            // if multiple tests running in parallel saw `contracts_dir` does not exist).
            DOWNLOAD_ONCE.call_once(|| {
                let url = "https://github.com/OpenZeppelin/openzeppelin-contracts";
                git2::Repository::clone(url, sources_dir).unwrap();
            });
            contracts_dir
        }
    }

    fn solidity_artifacts_path() -> PathBuf {
        Path::new("target").join("solidity_build")
    }
}

impl ERC20 {
    pub fn mint(&self, recipient: Address, amount: U256, nonce: U256) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .function("mint")
            .unwrap()
            .encode_input(&[
                ethabi::Token::Address(recipient.raw()),
                ethabi::Token::Uint(amount),
            ])
            .unwrap();

        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.0.address),
            value: Default::default(),
            data,
        }
    }

    pub fn transfer(&self, recipient: Address, amount: U256, nonce: U256) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .function("transfer")
            .unwrap()
            .encode_input(&[
                ethabi::Token::Address(recipient.raw()),
                ethabi::Token::Uint(amount),
            ])
            .unwrap();
        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.0.address),
            value: Default::default(),
            data,
        }
    }

    pub fn transfer_from(
        &self,
        from: Address,
        to: Address,
        amount: U256,
        nonce: U256,
    ) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .function("transferFrom")
            .unwrap()
            .encode_input(&[
                ethabi::Token::Address(from.raw()),
                ethabi::Token::Address(to.raw()),
                ethabi::Token::Uint(amount),
            ])
            .unwrap();
        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.0.address),
            value: Default::default(),
            data,
        }
    }

    pub fn approve(&self, spender: Address, amount: U256, nonce: U256) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .function("approve")
            .unwrap()
            .encode_input(&[
                ethabi::Token::Address(spender.raw()),
                ethabi::Token::Uint(amount),
            ])
            .unwrap();
        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.0.address),
            value: Default::default(),
            data,
        }
    }

    pub fn balance_of(&self, address: Address, nonce: U256) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .function("balanceOf")
            .unwrap()
            .encode_input(&[ethabi::Token::Address(address.raw())])
            .unwrap();
        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.0.address),
            value: Default::default(),
            data,
        }
    }
}

pub(crate) fn legacy_into_normalized_tx(tx: TransactionLegacy) -> NormalizedEthTransaction {
    NormalizedEthTransaction {
        address: Default::default(),
        chain_id: None,
        nonce: tx.nonce,
        gas_limit: tx.gas_limit,
        max_priority_fee_per_gas: tx.gas_price,
        max_fee_per_gas: tx.gas_price,
        to: tx.to,
        value: tx.value,
        data: tx.data,
        access_list: Vec::new(),
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/exit_precompile.rs ---
use crate::prelude::{
    parameters::SubmitResult, transactions::legacy::TransactionLegacy, Address, Wei, U256,
};
use crate::test_utils::{self, solidity, AuroraRunner, Signer};
use near_vm_errors::VMError;

pub(crate) struct TesterConstructor(pub solidity::ContractConstructor);

const DEPLOY_CONTRACT_GAS: u64 = 1_000_000_000;
pub const DEST_ACCOUNT: &str = "target.aurora";
pub const DEST_ADDRESS: Address =
    aurora_engine_precompiles::make_address(0xe0f5206b, 0xbd039e7b0592d8918820024e2a7437b9);

impl TesterConstructor {
    #[cfg(feature = "error_refund")]
    pub fn load() -> Self {
        Self(solidity::ContractConstructor::compile_from_extended_json(
            "../etc/eth-contracts/artifacts/contracts/test/TesterV2.sol/TesterV2.json",
        ))
    }
    #[cfg(not(feature = "error_refund"))]
    pub fn load() -> Self {
        Self(solidity::ContractConstructor::compile_from_extended_json(
            "../etc/eth-contracts/artifacts/contracts/test/Tester.sol/Tester.json",
        ))
    }

    pub fn deploy(&self, nonce: u64, token: Address) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .constructor()
            .unwrap()
            .encode_input(self.0.code.clone(), &[ethabi::Token::Address(token.raw())])
            .unwrap();

        TransactionLegacy {
            nonce: nonce.into(),
            gas_price: Default::default(),
            gas_limit: U256::from(DEPLOY_CONTRACT_GAS),
            to: None,
            value: Default::default(),
            data,
        }
    }
}

pub(crate) struct Tester {
    pub contract: solidity::DeployedContract,
}

impl From<TesterConstructor> for solidity::ContractConstructor {
    fn from(c: TesterConstructor) -> Self {
        c.0
    }
}

impl From<solidity::DeployedContract> for Tester {
    fn from(contract: solidity::DeployedContract) -> Self {
        Self { contract }
    }
}

impl Tester {
    fn call_function(
        &self,
        runner: &mut AuroraRunner,
        signer: &mut Signer,
        method: &str,
        value: Wei,
        params: &[ethabi::Token],
    ) -> Result<SubmitResult, VMError> {
        let data = self
            .contract
            .abi
            .function(method)
            .unwrap()
            .encode_input(params)
            .unwrap();

        let tx = TransactionLegacy {
            nonce: signer.use_nonce().into(),
            gas_price: Default::default(),
            gas_limit: U256::from(DEPLOY_CONTRACT_GAS),
            to: Some(self.contract.address),
            value,
            data,
        };

        runner.submit_transaction(&signer.secret_key, tx)
    }

    fn submit_result_to_success_or_revert(result: SubmitResult) -> Result<SubmitResult, Revert> {
        match result.status {
            aurora_engine::parameters::TransactionStatus::Succeed(_) => Ok(result),
            aurora_engine::parameters::TransactionStatus::Revert(bytes) => Err(Revert(bytes)),
            other => panic!("Unexpected status {:?}", other),
        }
    }

    pub fn hello_world(
        &self,
        runner: &mut AuroraRunner,
        signer: &mut Signer,
        name: String,
    ) -> String {
        let output_type = &[ethabi::ParamType::String];
        let result = self
            .call_function(
                runner,
                signer,
                "helloWorld",
                Wei::zero(),
                &[ethabi::Token::String(name)],
            )
            .unwrap();
        let output_bytes = test_utils::unwrap_success(result);
        let output = ethabi::decode(output_type, &output_bytes).unwrap();

        match &output[..] {
            [ethabi::Token::String(string)] => string.to_string(),
            _ => unreachable!(),
        }
    }

    pub fn withdraw(
        &self,
        runner: &mut AuroraRunner,
        signer: &mut Signer,
        flag: bool,
    ) -> Result<SubmitResult, VMError> {
        self.call_function(
            runner,
            signer,
            "withdraw",
            Wei::zero(),
            &[ethabi::Token::Bool(flag)],
        )
    }

    pub fn withdraw_and_fail(
        &self,
        runner: &mut AuroraRunner,
        signer: &mut Signer,
        flag: bool,
    ) -> Result<SubmitResult, Revert> {
        Self::submit_result_to_success_or_revert(
            self.call_function(
                runner,
                signer,
                "withdrawAndFail",
                Wei::zero(),
                &[ethabi::Token::Bool(flag)],
            )
            .unwrap(),
        )
    }

    pub fn try_withdraw_and_avoid_fail(
        &self,
        runner: &mut AuroraRunner,
        signer: &mut Signer,
        flag: bool,
    ) -> Result<SubmitResult, Revert> {
        Self::submit_result_to_success_or_revert(
            self.call_function(
                runner,
                signer,
                "tryWithdrawAndAvoidFail",
                Wei::zero(),
                &[ethabi::Token::Bool(flag)],
            )
            .unwrap(),
        )
    }

    pub fn try_withdraw_and_avoid_fail_and_succeed(
        &self,
        runner: &mut AuroraRunner,
        signer: &mut Signer,
        flag: bool,
    ) -> Result<SubmitResult, Revert> {
        Self::submit_result_to_success_or_revert(
            self.call_function(
                runner,
                signer,
                "tryWithdrawAndAvoidFailAndSucceed",
                Wei::zero(),
                &[ethabi::Token::Bool(flag)],
            )
            .unwrap(),
        )
    }

    pub fn withdraw_eth(
        &self,
        runner: &mut AuroraRunner,
        signer: &mut Signer,
        is_to_near: bool,
        amount: Wei,
    ) -> Result<SubmitResult, Revert> {
        Self::submit_result_to_success_or_revert(if is_to_near {
            self.call_function(
                runner,
                signer,
                "withdrawEthToNear",
                amount,
                &[ethabi::Token::Bytes(DEST_ACCOUNT.as_bytes().to_vec())],
            )
            .unwrap()
        } else {
            self.call_function(
                runner,
                signer,
                "withdrawEthToEthereum",
                amount,
                &[ethabi::Token::Address(DEST_ADDRESS.raw())],
            )
            .unwrap()
        })
    }
}

#[derive(Debug)]
pub(crate) struct Revert(Vec<u8>);

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/mocked_external.rs ---
use near_vm_logic::mocks::mock_external::MockedExternal;

/// Derived from mainnet data reported here: https://hackmd.io/@birchmd/r1HRjr0P9
/// Uses the formulas:
/// n_T = (G_T / G_R) * (g_R / g_T)
/// n_c = (G_c / G_R) * (g_R / g_c)
/// Where n_T is the average number of new touched trie nodes per read,
/// n_c is the average number of cached trie nodes read per read,
/// G_T is the average gas cost of touching trie node per Aurora transaction,
/// G_c is the average gas cost of reading cached trie node per Aurora transaction,
/// G_R is the average gas cost of `STORAGE_READ_BASE`  per Aurora transaction,
/// g_R is the `STORAGE_READ_BASE` cost (from the config),
/// g_T is the `TOUCHING_TRIE_NODE` cost (from the config), and
/// g_c is the `READ_CACHED_TRIE_NODE` cost (from the config).
pub const MAINNET_AVERAGE_TOUCHED_TRIE_PER_READ: u64 = 2;
pub const MAINNET_AVERAGE_READ_CACHED_TRIE_PER_READ: u64 = 11;
/// This is still needed because writes will touch every node in the depth, unlike reads which take advantage of caching.
pub const MAINNET_AVERAGE_TRIE_DEPTH: u64 = 13;

#[derive(Clone)]
pub struct MockedExternalWithTrie {
    pub underlying: MockedExternal,
    new_trie_node_count: std::cell::Cell<u64>,
    cached_trie_node_count: std::cell::Cell<u64>,
}

impl MockedExternalWithTrie {
    pub fn new(ext: MockedExternal) -> Self {
        Self {
            underlying: ext,
            new_trie_node_count: std::cell::Cell::new(0),
            cached_trie_node_count: std::cell::Cell::new(0),
        }
    }

    fn increment_new_trie_node_count(&self, amount: u64) {
        let cell_value = self.new_trie_node_count.get();
        self.new_trie_node_count.set(cell_value + amount);
    }

    fn increment_cached_trie_node_count(&self, amount: u64) {
        let cell_value = self.cached_trie_node_count.get();
        self.cached_trie_node_count.set(cell_value + amount);
    }
}

impl near_vm_logic::External for MockedExternalWithTrie {
    fn storage_set(&mut self, key: &[u8], value: &[u8]) -> Result<(), near_vm_logic::VMLogicError> {
        self.increment_new_trie_node_count(MAINNET_AVERAGE_TRIE_DEPTH);
        self.underlying.storage_set(key, value)
    }

    fn storage_get<'a>(
        &'a self,
        key: &[u8],
    ) -> Result<Option<Box<dyn near_vm_logic::ValuePtr + 'a>>, near_vm_logic::VMLogicError> {
        self.increment_new_trie_node_count(MAINNET_AVERAGE_TOUCHED_TRIE_PER_READ);
        self.increment_cached_trie_node_count(MAINNET_AVERAGE_READ_CACHED_TRIE_PER_READ);
        self.underlying.storage_get(key)
    }

    fn storage_remove(&mut self, key: &[u8]) -> Result<(), near_vm_logic::VMLogicError> {
        self.increment_new_trie_node_count(MAINNET_AVERAGE_TRIE_DEPTH);
        self.underlying.storage_remove(key)
    }

    fn storage_remove_subtree(&mut self, prefix: &[u8]) -> Result<(), near_vm_logic::VMLogicError> {
        self.underlying.storage_remove_subtree(prefix)
    }

    fn storage_has_key(&mut self, key: &[u8]) -> Result<bool, near_vm_logic::VMLogicError> {
        self.underlying.storage_has_key(key)
    }

    fn validator_stake(
        &self,
        account_id: &near_primitives::types::AccountId,
    ) -> Result<Option<near_primitives::types::Balance>, near_vm_logic::VMLogicError> {
        self.underlying.validator_stake(account_id)
    }

    fn validator_total_stake(
        &self,
    ) -> Result<near_primitives::types::Balance, near_vm_logic::VMLogicError> {
        self.underlying.validator_total_stake()
    }

    fn generate_data_id(&mut self) -> near_primitives::hash::CryptoHash {
        self.underlying.generate_data_id()
    }

    fn get_trie_nodes_count(&self) -> near_primitives::types::TrieNodesCount {
        let db_reads = self.new_trie_node_count.get();
        let mem_reads = self.cached_trie_node_count.get();
        near_primitives::types::TrieNodesCount {
            db_reads,
            mem_reads,
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/mod.rs ---
use aurora_engine::parameters::ViewCallArgs;
use aurora_engine_types::account_id::AccountId;
use aurora_engine_types::types::{NEP141Wei, PromiseResult};
use borsh::{BorshDeserialize, BorshSerialize};
use libsecp256k1::{self, Message, PublicKey, SecretKey};
use near_primitives::runtime::config_store::RuntimeConfigStore;
use near_primitives::version::PROTOCOL_VERSION;
use near_primitives_core::config::VMConfig;
use near_primitives_core::contract::ContractCode;
use near_primitives_core::profile::ProfileData;
use near_primitives_core::runtime::fees::RuntimeFeesConfig;
use near_vm_logic::types::ReturnData;
use near_vm_logic::{VMContext, VMOutcome, ViewConfig};
use near_vm_runner::{MockCompiledContractCache, VMError};
use rlp::RlpStream;

use crate::prelude::fungible_token::{FungibleToken, FungibleTokenMetadata};
use crate::prelude::parameters::{InitCallArgs, NewCallArgs, SubmitResult, TransactionStatus};
use crate::prelude::transactions::{
    eip_1559::{self, SignedTransaction1559, Transaction1559},
    eip_2930::{self, SignedTransaction2930, Transaction2930},
    legacy::{LegacyEthSignedTransaction, TransactionLegacy},
};
use crate::prelude::{sdk, Address, Wei, H256, U256};
use crate::test_utils::solidity::{ContractConstructor, DeployedContract};

// TODO(Copied from #84): Make sure that there is only one Signer after both PR are merged.

pub fn origin() -> String {
    "aurora".to_string()
}

pub(crate) const SUBMIT: &str = "submit";
pub(crate) const CALL: &str = "call";
pub(crate) const DEPLOY_ERC20: &str = "deploy_erc20_token";
pub(crate) const PAUSE_PRECOMPILES: &str = "pause_precompiles";
pub(crate) const PAUSED_PRECOMPILES: &str = "paused_precompiles";
pub(crate) const RESUME_PRECOMPILES: &str = "resume_precompiles";

pub(crate) mod erc20;
pub(crate) mod exit_precompile;
pub(crate) mod mocked_external;
pub(crate) mod one_inch;
pub(crate) mod random;
pub(crate) mod rust;
pub(crate) mod self_destruct;
pub(crate) mod solidity;
pub(crate) mod standalone;
pub(crate) mod standard_precompiles;
pub(crate) mod uniswap;
pub(crate) mod weth;

pub struct Signer {
    pub nonce: u64,
    pub secret_key: SecretKey,
}

impl Signer {
    pub fn new(secret_key: SecretKey) -> Self {
        Self {
            nonce: 0,
            secret_key,
        }
    }

    pub fn random() -> Self {
        let mut rng = rand::thread_rng();
        let sk = SecretKey::random(&mut rng);
        Self::new(sk)
    }

    pub fn use_nonce(&mut self) -> u64 {
        let nonce = self.nonce;
        self.nonce += 1;
        nonce
    }
}

pub(crate) struct AuroraRunner {
    pub aurora_account_id: String,
    pub chain_id: u64,
    pub code: ContractCode,
    pub cache: MockCompiledContractCache,
    pub ext: mocked_external::MockedExternalWithTrie,
    pub context: VMContext,
    pub wasm_config: VMConfig,
    pub fees_config: RuntimeFeesConfig,
    pub current_protocol_version: u32,
    pub previous_logs: Vec<String>,
    // Use the standalone in parallel if set. This allows checking both
    // implementations give the same results.
    pub standalone_runner: Option<standalone::StandaloneRunner>,
    // Empty by default. Can be set in tests if the transaction should be
    // executed as if it was a callback.
    pub promise_results: Vec<PromiseResult>,
}

/// Same as `AuroraRunner`, but consumes `self` on execution (thus preventing building on
/// the `ext` post-state with future calls to the contract.
#[derive(Clone)]
pub(crate) struct OneShotAuroraRunner<'a> {
    pub base: &'a AuroraRunner,
    pub ext: mocked_external::MockedExternalWithTrie,
    pub context: VMContext,
}

impl<'a> OneShotAuroraRunner<'a> {
    pub fn profiled_call(
        self,
        method_name: &str,
        caller_account_id: &str,
        input: Vec<u8>,
    ) -> (Option<VMOutcome>, Option<VMError>, ExecutionProfile) {
        let (outcome, error) = self.call(method_name, caller_account_id, input);
        let profile = outcome
            .as_ref()
            .map(ExecutionProfile::new)
            .unwrap_or_default();
        (outcome, error, profile)
    }

    pub fn call(
        mut self,
        method_name: &str,
        caller_account_id: &str,
        input: Vec<u8>,
    ) -> (Option<VMOutcome>, Option<VMError>) {
        AuroraRunner::update_context(
            &mut self.context,
            caller_account_id,
            caller_account_id,
            input,
        );

        match near_vm_runner::run(
            &self.base.code,
            method_name,
            &mut self.ext,
            self.context.clone(),
            &self.base.wasm_config,
            &self.base.fees_config,
            &[],
            self.base.current_protocol_version,
            Some(&self.base.cache),
        ) {
            near_vm_runner::VMResult::Aborted(outcome, error) => (Some(outcome), Some(error)),
            near_vm_runner::VMResult::Ok(outcome) => (Some(outcome), None),
        }
    }
}

impl AuroraRunner {
    pub fn one_shot(&self) -> OneShotAuroraRunner {
        OneShotAuroraRunner {
            base: self,
            ext: self.ext.clone(),
            context: self.context.clone(),
        }
    }

    pub fn update_context(
        context: &mut VMContext,
        caller_account_id: &str,
        signer_account_id: &str,
        input: Vec<u8>,
    ) {
        context.block_index += 1;
        context.block_timestamp += 1_000_000_000;
        context.input = input;
        context.signer_account_id = as_account_id(signer_account_id);
        context.predecessor_account_id = as_account_id(caller_account_id);
    }

    pub fn call(
        &mut self,
        method_name: &str,
        caller_account_id: &str,
        input: Vec<u8>,
    ) -> (Option<VMOutcome>, Option<VMError>) {
        self.call_with_signer(method_name, caller_account_id, caller_account_id, input)
    }

    pub fn call_with_signer(
        &mut self,
        method_name: &str,
        caller_account_id: &str,
        signer_account_id: &str,
        input: Vec<u8>,
    ) -> (Option<VMOutcome>, Option<VMError>) {
        Self::update_context(
            &mut self.context,
            caller_account_id,
            signer_account_id,
            input,
        );

        let vm_promise_results: Vec<_> = self
            .promise_results
            .iter()
            .map(|p| match p {
                PromiseResult::Failed => near_vm_logic::types::PromiseResult::Failed,
                PromiseResult::NotReady => near_vm_logic::types::PromiseResult::NotReady,
                PromiseResult::Successful(bytes) => {
                    near_vm_logic::types::PromiseResult::Successful(bytes.clone())
                }
            })
            .collect();
        let (maybe_outcome, maybe_error) = match near_vm_runner::run(
            &self.code,
            method_name,
            &mut self.ext,
            self.context.clone(),
            &self.wasm_config,
            &self.fees_config,
            &vm_promise_results,
            self.current_protocol_version,
            Some(&self.cache),
        ) {
            near_vm_runner::VMResult::Aborted(outcome, error) => (Some(outcome), Some(error)),
            near_vm_runner::VMResult::Ok(outcome) => (Some(outcome), None),
        };
        if let Some(outcome) = &maybe_outcome {
            self.context.storage_usage = outcome.storage_usage;
            self.previous_logs = outcome.logs.clone();
        }

        if let Some(standalone_runner) = &mut self.standalone_runner {
            if maybe_error.is_none()
                && (method_name == SUBMIT
                    || method_name == CALL
                    || method_name == DEPLOY_ERC20
                    || method_name == PAUSE_PRECOMPILES
                    || method_name == RESUME_PRECOMPILES)
            {
                standalone_runner
                    .submit_raw(method_name, &self.context, &self.promise_results)
                    .unwrap();
                self.validate_standalone();
            }
        }

        (maybe_outcome, maybe_error)
    }

    pub fn consume_json_snapshot(
        &mut self,
        snapshot: engine_standalone_storage::json_snapshot::types::JsonSnapshot,
    ) {
        let trie = &mut self.ext.underlying.fake_trie;
        for entry in snapshot.result.values {
            let key = base64::decode(entry.key).unwrap();
            let value = base64::decode(entry.value).unwrap();
            trie.insert(key, value);
        }
    }

    pub fn create_address(
        &mut self,
        address: Address,
        init_balance: crate::prelude::Wei,
        init_nonce: U256,
    ) {
        self.internal_create_address(address, init_balance, init_nonce, None)
    }

    pub fn create_address_with_code(
        &mut self,
        address: Address,
        init_balance: crate::prelude::Wei,
        init_nonce: U256,
        code: Vec<u8>,
    ) {
        self.internal_create_address(address, init_balance, init_nonce, Some(code))
    }

    fn internal_create_address(
        &mut self,
        address: Address,
        init_balance: crate::prelude::Wei,
        init_nonce: U256,
        code: Option<Vec<u8>>,
    ) {
        let trie = &mut self.ext.underlying.fake_trie;

        let balance_key = crate::prelude::storage::address_to_key(
            crate::prelude::storage::KeyPrefix::Balance,
            &address,
        );
        let balance_value = init_balance.to_bytes();

        let nonce_key = crate::prelude::storage::address_to_key(
            crate::prelude::storage::KeyPrefix::Nonce,
            &address,
        );
        let nonce_value = crate::prelude::u256_to_arr(&init_nonce);

        if let Some(code) = code.clone() {
            let code_key = crate::prelude::storage::address_to_key(
                crate::prelude::storage::KeyPrefix::Code,
                &address,
            );
            trie.insert(code_key.to_vec(), code);
        }

        let ft_key = crate::prelude::storage::bytes_to_key(
            crate::prelude::storage::KeyPrefix::EthConnector,
            &[crate::prelude::storage::EthConnectorStorageId::FungibleToken as u8],
        );
        let ft_value = {
            let mut current_ft: FungibleToken = trie
                .get(&ft_key)
                .map(|bytes| FungibleToken::try_from_slice(bytes).unwrap())
                .unwrap_or_default();
            current_ft.total_eth_supply_on_near =
                current_ft.total_eth_supply_on_near + NEP141Wei::new(init_balance.raw().as_u128());
            current_ft.total_eth_supply_on_aurora = current_ft.total_eth_supply_on_aurora
                + NEP141Wei::new(init_balance.raw().as_u128());
            current_ft
        };

        let aurora_balance_key = [
            ft_key.as_slice(),
            self.context.current_account_id.as_ref().as_bytes(),
        ]
        .concat();
        let aurora_balance_value = {
            let mut current_balance: u128 = trie
                .get(&aurora_balance_key)
                .map(|bytes| u128::try_from_slice(bytes).unwrap())
                .unwrap_or_default();
            current_balance += init_balance.raw().as_u128();
            current_balance
        };

        let proof_key = crate::prelude::storage::bytes_to_key(
            crate::prelude::storage::KeyPrefix::EthConnector,
            &[crate::prelude::storage::EthConnectorStorageId::UsedEvent as u8],
        );

        trie.insert(balance_key.to_vec(), balance_value.to_vec());
        if !init_nonce.is_zero() {
            trie.insert(nonce_key.to_vec(), nonce_value.to_vec());
        }
        trie.insert(ft_key, ft_value.try_to_vec().unwrap());
        trie.insert(proof_key, vec![0]);
        trie.insert(
            aurora_balance_key,
            aurora_balance_value.try_to_vec().unwrap(),
        );

        if let Some(standalone_runner) = &mut self.standalone_runner {
            standalone_runner.env.block_height = self.context.block_index;
            standalone_runner.mint_account(address, init_balance, init_nonce, code);
            self.validate_standalone();
        }

        self.context.block_index += 1;
    }

    pub fn submit_with_signer<F: FnOnce(U256) -> TransactionLegacy>(
        &mut self,
        signer: &mut Signer,
        make_tx: F,
    ) -> Result<SubmitResult, VMError> {
        self.submit_with_signer_profiled(signer, make_tx)
            .map(|(result, _)| result)
    }

    pub fn submit_with_signer_profiled<F: FnOnce(U256) -> TransactionLegacy>(
        &mut self,
        signer: &mut Signer,
        make_tx: F,
    ) -> Result<(SubmitResult, ExecutionProfile), VMError> {
        let nonce = signer.use_nonce();
        let tx = make_tx(nonce.into());
        self.submit_transaction_profiled(&signer.secret_key, tx)
    }

    pub fn submit_transaction(
        &mut self,
        account: &SecretKey,
        transaction: TransactionLegacy,
    ) -> Result<SubmitResult, VMError> {
        self.submit_transaction_profiled(account, transaction)
            .map(|(result, _)| result)
    }

    pub fn submit_transaction_profiled(
        &mut self,
        account: &SecretKey,
        transaction: TransactionLegacy,
    ) -> Result<(SubmitResult, ExecutionProfile), VMError> {
        let calling_account_id = "some-account.near";
        let signed_tx = sign_transaction(transaction, Some(self.chain_id), account);

        let (output, maybe_err) =
            self.call(SUBMIT, calling_account_id, rlp::encode(&signed_tx).to_vec());

        if let Some(err) = maybe_err {
            Err(err)
        } else {
            let output = output.unwrap();
            let profile = ExecutionProfile::new(&output);
            let submit_result =
                SubmitResult::try_from_slice(&output.return_data.as_value().unwrap()).unwrap();
            Ok((submit_result, profile))
        }
    }

    pub fn deploy_contract<F: FnOnce(&T) -> TransactionLegacy, T: Into<ContractConstructor>>(
        &mut self,
        account: &SecretKey,
        constructor_tx: F,
        contract_constructor: T,
    ) -> DeployedContract {
        let calling_account_id = "some-account.near";
        let tx = constructor_tx(&contract_constructor);
        let signed_tx = sign_transaction(tx, Some(self.chain_id), account);
        let (output, maybe_err) =
            self.call(SUBMIT, calling_account_id, rlp::encode(&signed_tx).to_vec());
        assert!(maybe_err.is_none());
        let submit_result =
            SubmitResult::try_from_slice(&output.unwrap().return_data.as_value().unwrap()).unwrap();
        let address = Address::try_from_slice(&unwrap_success(submit_result)).unwrap();
        let contract_constructor: ContractConstructor = contract_constructor.into();
        DeployedContract {
            abi: contract_constructor.abi,
            address,
        }
    }

    pub fn view_call(&self, args: ViewCallArgs) -> Result<TransactionStatus, VMError> {
        let input = args.try_to_vec().unwrap();
        let mut runner = self.one_shot();
        runner.context.view_config = Some(ViewConfig {
            max_gas_burnt: u64::MAX,
        });
        let (outcome, maybe_error) = runner.call("view", "viewer", input);
        Ok(
            TransactionStatus::try_from_slice(&Self::bytes_from_outcome(outcome, maybe_error)?)
                .unwrap(),
        )
    }

    pub fn profiled_view_call(
        &self,
        args: ViewCallArgs,
    ) -> (Result<TransactionStatus, VMError>, ExecutionProfile) {
        let input = args.try_to_vec().unwrap();
        let mut runner = self.one_shot();
        runner.context.view_config = Some(ViewConfig {
            max_gas_burnt: u64::MAX,
        });
        let (outcome, maybe_error, profile) = runner.profiled_call("view", "viewer", input);
        let status = Self::bytes_from_outcome(outcome, maybe_error)
            .map(|bytes| TransactionStatus::try_from_slice(&bytes).unwrap());

        (status, profile)
    }

    pub fn get_balance(&self, address: Address) -> Wei {
        Wei::new(self.u256_getter_method_call("get_balance", address))
    }

    pub fn get_nonce(&self, address: Address) -> U256 {
        self.u256_getter_method_call("get_nonce", address)
    }

    pub fn get_code(&self, address: Address) -> Vec<u8> {
        self.getter_method_call("get_code", address)
    }

    pub fn get_storage(&self, address: Address, key: H256) -> H256 {
        let input = aurora_engine::parameters::GetStorageAtArgs {
            address,
            key: key.0,
        };
        let (outcome, maybe_error) =
            self.one_shot()
                .call("get_storage_at", "getter", input.try_to_vec().unwrap());
        assert!(maybe_error.is_none());
        let output = outcome.unwrap().return_data.as_value().unwrap();
        let mut result = [0u8; 32];
        result.copy_from_slice(&output);
        H256(result)
    }

    fn u256_getter_method_call(&self, method_name: &str, address: Address) -> U256 {
        let bytes = self.getter_method_call(method_name, address);
        U256::from_big_endian(&bytes)
    }

    // Used in `get_balance` and `get_nonce`. This function exists to avoid code duplication
    // since the contract's `get_nonce` and `get_balance` have the same type signature.
    fn getter_method_call(&self, method_name: &str, address: Address) -> Vec<u8> {
        let (outcome, maybe_error) =
            self.one_shot()
                .call(method_name, "getter", address.as_bytes().to_vec());
        assert!(maybe_error.is_none());
        outcome.unwrap().return_data.as_value().unwrap()
    }

    fn bytes_from_outcome(
        maybe_outcome: Option<VMOutcome>,
        maybe_error: Option<VMError>,
    ) -> Result<Vec<u8>, VMError> {
        if let Some(error) = maybe_error {
            Err(error)
        } else {
            let bytes = maybe_outcome.unwrap().return_data.as_value().unwrap();
            Ok(bytes)
        }
    }

    pub fn with_random_seed(mut self, random_seed: H256) -> Self {
        self.context.random_seed = random_seed.as_bytes().to_vec();
        self
    }

    fn validate_standalone(&self) {
        if let Some(standalone_runner) = &self.standalone_runner {
            let standalone_state = standalone_runner.get_current_state();
            // The number of keys in standalone_state may be larger because values are never deleted
            // (they are replaced with a Deleted identifier instead; this is important for replaying transactions).
            assert!(self.ext.underlying.fake_trie.len() <= standalone_state.iter().count());
            for (key, value) in standalone_state.iter() {
                let trie_value = self.ext.underlying.fake_trie.get(key).map(|v| v.as_slice());
                let standalone_value = value.value();
                if trie_value != standalone_value {
                    panic!(
                        "Standalone mismatch at {:?}.\nStandlaone: {:?}\nWasm      : {:?}",
                        key, standalone_value, trie_value
                    );
                }
            }
        }
    }
}

impl Default for AuroraRunner {
    fn default() -> Self {
        let aurora_account_id = "aurora".to_string();
        let evm_wasm_bytes = if cfg!(feature = "mainnet-test") {
            std::fs::read("../bin/aurora-mainnet-test.wasm").unwrap()
        } else if cfg!(feature = "testnet-test") {
            std::fs::read("../bin/aurora-testnet-test.wasm").unwrap()
        } else {
            panic!("AuroraRunner requires mainnet-test or testnet-test feature enabled.")
        };

        // Fetch config (mainly costs) for the latest protocol version.
        let runtime_config_store = RuntimeConfigStore::new(None);
        let runtime_config = runtime_config_store.get_config(PROTOCOL_VERSION);
        let wasm_config = runtime_config.wasm_config.clone();

        Self {
            aurora_account_id: aurora_account_id.clone(),
            chain_id: 1313161556, // NEAR localnet,
            code: ContractCode::new(evm_wasm_bytes, None),
            cache: Default::default(),
            ext: mocked_external::MockedExternalWithTrie::new(Default::default()),
            context: VMContext {
                current_account_id: as_account_id(&aurora_account_id),
                signer_account_id: as_account_id(&aurora_account_id),
                signer_account_pk: vec![],
                predecessor_account_id: as_account_id(&aurora_account_id),
                input: vec![],
                block_index: 0,
                block_timestamp: 0,
                epoch_height: 0,
                account_balance: 10u128.pow(25),
                account_locked_balance: 0,
                storage_usage: 100,
                attached_deposit: 0,
                prepaid_gas: 10u64.pow(18),
                random_seed: vec![],
                view_config: None,
                output_data_receivers: vec![],
            },
            wasm_config,
            fees_config: RuntimeFeesConfig::test(),
            current_protocol_version: u32::MAX,
            previous_logs: Default::default(),
            standalone_runner: None,
            promise_results: Vec::new(),
        }
    }
}

/// Wrapper around `ProfileData` to still include the wasm gas usage
/// (which was removed in https://github.com/near/nearcore/pull/4438).
#[derive(Debug, Default, Clone)]
pub(crate) struct ExecutionProfile {
    pub host_breakdown: ProfileData,
    wasm_gas: u64,
}

impl ExecutionProfile {
    pub fn new(outcome: &VMOutcome) -> Self {
        let wasm_gas =
            outcome.burnt_gas - outcome.profile.host_gas() - outcome.profile.action_gas();
        Self {
            host_breakdown: outcome.profile.clone(),
            wasm_gas,
        }
    }

    pub fn wasm_gas(&self) -> u64 {
        self.wasm_gas
    }

    pub fn all_gas(&self) -> u64 {
        self.wasm_gas + self.host_breakdown.host_gas() + self.host_breakdown.action_gas()
    }
}

pub(crate) fn deploy_evm() -> AuroraRunner {
    let mut runner = AuroraRunner::default();
    let args = NewCallArgs {
        chain_id: crate::prelude::u256_to_arr(&U256::from(runner.chain_id)),
        owner_id: str_to_account_id(runner.aurora_account_id.as_str()),
        bridge_prover_id: str_to_account_id("bridge_prover.near"),
        upgrade_delay_blocks: 1,
    };

    let account_id = runner.aurora_account_id.clone();
    let (_, maybe_error) = runner.call("new", &account_id, args.try_to_vec().unwrap());

    assert!(maybe_error.is_none());

    let args = InitCallArgs {
        prover_account: str_to_account_id("prover.near"),
        eth_custodian_address: "d045f7e19B2488924B97F9c145b5E51D0D895A65".to_string(),
        metadata: FungibleTokenMetadata::default(),
    };
    let (_, maybe_error) =
        runner.call("new_eth_connector", &account_id, args.try_to_vec().unwrap());

    assert!(maybe_error.is_none());

    let mut standalone_runner = standalone::StandaloneRunner::default();
    standalone_runner.init_evm();

    runner.standalone_runner = Some(standalone_runner);
    runner.validate_standalone();

    runner
}

pub(crate) fn transfer(to: Address, amount: Wei, nonce: U256) -> TransactionLegacy {
    TransactionLegacy {
        nonce,
        gas_price: Default::default(),
        gas_limit: u64::MAX.into(),
        to: Some(to),
        value: amount,
        data: Vec::new(),
    }
}

pub(crate) fn create_deploy_transaction(contract_bytes: Vec<u8>, nonce: U256) -> TransactionLegacy {
    let len = contract_bytes.len();
    if len > u16::MAX as usize {
        panic!("Cannot deploy a contract with that many bytes!");
    }
    let len = len as u16;
    // This bit of EVM byte code essentially says:
    // "If msg.value > 0 revert; otherwise return `len` amount of bytes that come after me
    // in the code." By prepending this to `contract_bytes` we create a valid EVM program which
    // returns `contract_bytes`, which is exactly what we want.
    let init_code = format!(
        "608060405234801561001057600080fd5b5061{}806100206000396000f300",
        hex::encode(len.to_be_bytes())
    );
    let data = hex::decode(init_code)
        .unwrap()
        .into_iter()
        .chain(contract_bytes.into_iter())
        .collect();

    TransactionLegacy {
        nonce,
        gas_price: Default::default(),
        gas_limit: u64::MAX.into(),
        to: None,
        value: Wei::zero(),
        data,
    }
}

pub(crate) fn create_eth_transaction(
    to: Option<Address>,
    value: crate::prelude::Wei,
    data: Vec<u8>,
    chain_id: Option<u64>,
    secret_key: &SecretKey,
) -> LegacyEthSignedTransaction {
    // nonce, gas_price and gas are not used by EVM contract currently
    let tx = TransactionLegacy {
        nonce: Default::default(),
        gas_price: Default::default(),
        gas_limit: u64::MAX.into(),
        to,
        value,
        data,
    };
    sign_transaction(tx, chain_id, secret_key)
}

pub(crate) fn as_view_call(tx: TransactionLegacy, sender: Address) -> ViewCallArgs {
    ViewCallArgs {
        sender,
        address: tx.to.unwrap(),
        amount: tx.value.to_bytes(),
        input: tx.data,
    }
}

pub(crate) fn sign_transaction(
    tx: TransactionLegacy,
    chain_id: Option<u64>,
    secret_key: &SecretKey,
) -> LegacyEthSignedTransaction {
    let mut rlp_stream = RlpStream::new();
    tx.rlp_append_unsigned(&mut rlp_stream, chain_id);
    let message_hash = sdk::keccak(rlp_stream.as_raw());
    let message = Message::parse_slice(message_hash.as_bytes()).unwrap();

    let (signature, recovery_id) = libsecp256k1::sign(&message, secret_key);
    let v: u64 = match chain_id {
        Some(chain_id) => (recovery_id.serialize() as u64) + 2 * chain_id + 35,
        None => (recovery_id.serialize() as u64) + 27,
    };
    let r = U256::from_big_endian(&signature.r.b32());
    let s = U256::from_big_endian(&signature.s.b32());
    LegacyEthSignedTransaction {
        transaction: tx,
        v,
        r,
        s,
    }
}

pub(crate) fn sign_access_list_transaction(
    tx: Transaction2930,
    secret_key: &SecretKey,
) -> SignedTransaction2930 {
    let mut rlp_stream = RlpStream::new();
    rlp_stream.append(&eip_2930::TYPE_BYTE);
    tx.rlp_append_unsigned(&mut rlp_stream);
    let message_hash = sdk::keccak(rlp_stream.as_raw());
    let message = Message::parse_slice(message_hash.as_bytes()).unwrap();

    let (signature, recovery_id) = libsecp256k1::sign(&message, secret_key);
    let r = U256::from_big_endian(&signature.r.b32());
    let s = U256::from_big_endian(&signature.s.b32());

    SignedTransaction2930 {
        transaction: tx,
        parity: recovery_id.serialize(),
        r,
        s,
    }
}

pub(crate) fn sign_eip_1559_transaction(
    tx: Transaction1559,
    secret_key: &SecretKey,
) -> SignedTransaction1559 {
    let mut rlp_stream = RlpStream::new();
    rlp_stream.append(&eip_1559::TYPE_BYTE);
    tx.rlp_append_unsigned(&mut rlp_stream);
    let message_hash = sdk::keccak(rlp_stream.as_raw());
    let message = Message::parse_slice(message_hash.as_bytes()).unwrap();

    let (signature, recovery_id) = libsecp256k1::sign(&message, secret_key);
    let r = U256::from_big_endian(&signature.r.b32());
    let s = U256::from_big_endian(&signature.s.b32());

    SignedTransaction1559 {
        transaction: tx,
        parity: recovery_id.serialize(),
        r,
        s,
    }
}

pub(crate) fn address_from_secret_key(sk: &SecretKey) -> Address {
    let pk = PublicKey::from_secret_key(sk);
    let hash = sdk::keccak(&pk.serialize()[1..]);
    Address::try_from_slice(&hash[12..]).unwrap()
}

pub(crate) fn parse_eth_gas(output: &VMOutcome) -> u64 {
    let submit_result_bytes = match &output.return_data {
        ReturnData::Value(bytes) => bytes.as_slice(),
        ReturnData::None | ReturnData::ReceiptIndex(_) => panic!("Unexpected ReturnData"),
    };
    let submit_result = SubmitResult::try_from_slice(submit_result_bytes).unwrap();
    submit_result.gas_used
}

pub(crate) fn validate_address_balance_and_nonce(
    runner: &AuroraRunner,
    address: Address,
    expected_balance: crate::prelude::Wei,
    expected_nonce: U256,
) {
    assert_eq!(runner.get_balance(address), expected_balance, "balance");
    assert_eq!(runner.get_nonce(address), expected_nonce, "nonce");
}

pub(crate) fn address_from_hex(address: &str) -> Address {
    let bytes = if let Some(address) = address.strip_prefix("0x") {
        hex::decode(address).unwrap()
    } else {
        hex::decode(address).unwrap()
    };

    Address::try_from_slice(&bytes).unwrap()
}

pub(crate) fn as_account_id(account_id: &str) -> near_primitives_core::types::AccountId {
    account_id.parse().unwrap()
}

pub(crate) fn str_to_account_id(account_id: &str) -> AccountId {
    use aurora_engine_types::str::FromStr;
    AccountId::from_str(account_id).unwrap()
}

pub fn unwrap_success(result: SubmitResult) -> Vec<u8> {
    match result.status {
        TransactionStatus::Succeed(ret) => ret,
        other => panic!("Unexpected status: {:?}", other),
    }
}

pub fn unwrap_success_slice(result: &SubmitResult) -> &[u8] {
    match &result.status {
        TransactionStatus::Succeed(ret) => ret,
        other => panic!("Unexpected status: {:?}", other),
    }
}

pub fn unwrap_revert(result: SubmitResult) -> Vec<u8> {
    match result.status {
        TransactionStatus::Revert(ret) => ret,
        other => panic!("Unexpected status: {:?}", other),
    }
}

pub fn panic_on_fail(status: TransactionStatus) {
    match status {
        TransactionStatus::Succeed(_) => (),
        TransactionStatus::Revert(message) => panic!("{}", String::from_utf8_lossy(&message)),
        other => panic!("{}", String::from_utf8_lossy(other.as_ref())),
    }
}

pub fn assert_gas_bound(total_gas: u64, tgas_bound: u64) {
    // Add 1 to round up
    let tgas_used = (total_gas / 1_000_000_000_000) + 1;
    assert!(
        tgas_used == tgas_bound,
        "{} Tgas is not equal to {} Tgas",
        tgas_used,
        tgas_bound,
    );
}

/// Returns true if `abs(a - b) / max(a, b) <= x / 100`. The implementation is written differently than
/// this simpler formula to avoid floating point arithmetic.
pub fn within_x_percent(x: u64, a: u64, b: u64) -> bool {
    let (larger, smaller) = if a < b { (b, a) } else { (a, b) };

    (100 / x) * (larger - smaller) <= larger
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/one_inch/liquidity_protocol.rs ---
use crate::prelude::parameters::SubmitResult;
use crate::prelude::{Address, U256};
use crate::test_utils::{self, solidity, ExecutionProfile};
use std::path::PathBuf;
use std::sync::Once;

static DOWNLOAD_ONCE: Once = Once::new();
static COMPILE_ONCE: Once = Once::new();

pub(crate) struct Helper<'a> {
    pub runner: &'a mut test_utils::AuroraRunner,
    pub signer: &'a mut test_utils::Signer,
}

impl<'a> Helper<'a> {
    pub(crate) fn create_mooniswap_deployer(
        &mut self,
    ) -> (SubmitResult, ExecutionProfile, PoolDeployer) {
        let artifacts_path = download_and_compile_solidity_sources();
        let deployer_constructor =
            test_utils::solidity::ContractConstructor::compile_from_extended_json(
                artifacts_path.join("MooniswapDeployer.sol/MooniswapDeployer.json"),
            );
        let data = deployer_constructor.code;
        let abi = deployer_constructor.abi;

        let (result, profile) = self
            .runner
            .submit_with_signer_profiled(self.signer, |nonce| {
                crate::prelude::transactions::legacy::TransactionLegacy {
                    nonce,
                    gas_price: Default::default(),
                    gas_limit: u64::MAX.into(),
                    to: None,
                    value: Default::default(),
                    data,
                }
            })
            .unwrap();

        let deployer_address =
            Address::try_from_slice(test_utils::unwrap_success_slice(&result)).unwrap();
        let deployer = PoolDeployer(solidity::DeployedContract {
            abi,
            address: deployer_address,
        });

        (result, profile, deployer)
    }

    pub(crate) fn create_pool_factory(
        &mut self,
        pool_deployer: &PoolDeployer,
    ) -> (SubmitResult, ExecutionProfile, PoolFactory) {
        let artifacts_path = download_and_compile_solidity_sources();
        let constructor = test_utils::solidity::ContractConstructor::compile_from_extended_json(
            artifacts_path.join("MooniswapFactory.sol/MooniswapFactory.json"),
        );

        let signer_address = test_utils::address_from_secret_key(&self.signer.secret_key);
        let (result, profile) = self
            .runner
            .submit_with_signer_profiled(self.signer, |nonce| {
                constructor.deploy_with_args(
                    nonce,
                    &[
                        ethabi::Token::Address(signer_address.raw()),
                        ethabi::Token::Address(pool_deployer.0.address.raw()),
                        ethabi::Token::Address(signer_address.raw()),
                    ],
                )
            })
            .unwrap();

        let address = Address::try_from_slice(test_utils::unwrap_success_slice(&result)).unwrap();
        let pool_factory = PoolFactory(constructor.deployed_at(address));

        (result, profile, pool_factory)
    }

    pub(crate) fn create_pool(
        &mut self,
        pool_factory: &PoolFactory,
        token_a: Address,
        token_b: Address,
    ) -> (SubmitResult, ExecutionProfile, Pool) {
        let artifacts_path = download_and_compile_solidity_sources();
        let constructor = test_utils::solidity::ContractConstructor::compile_from_extended_json(
            artifacts_path.join("Mooniswap.sol/Mooniswap.json"),
        );

        let (result, profile) = self
            .runner
            .submit_with_signer_profiled(self.signer, |nonce| {
                pool_factory.0.call_method_with_args(
                    "deploy",
                    &[
                        ethabi::Token::Address(token_a.raw()),
                        ethabi::Token::Address(token_b.raw()),
                    ],
                    nonce,
                )
            })
            .unwrap();

        let address =
            Address::try_from_slice(&test_utils::unwrap_success_slice(&result)[12..32]).unwrap();
        let pool = Pool(constructor.deployed_at(address));

        (result, profile, pool)
    }

    pub(crate) fn create_erc20(&mut self, name: &str, symbol: &str) -> test_utils::erc20::ERC20 {
        let constructor = test_utils::erc20::ERC20Constructor::load();
        let nonce = self.signer.use_nonce();
        test_utils::erc20::ERC20(self.runner.deploy_contract(
            &self.signer.secret_key,
            |c| c.deploy(name, symbol, nonce.into()),
            constructor,
        ))
    }

    pub(crate) fn mint_erc20_tokens(
        &mut self,
        token: &test_utils::erc20::ERC20,
        dest: Address,
    ) -> SubmitResult {
        let result = self
            .runner
            .submit_with_signer(self.signer, |nonce| {
                token.mint(dest, 1_000_000.into(), nonce)
            })
            .unwrap();
        assert!(result.status.is_ok());
        result
    }

    pub(crate) fn approve_erc20_tokens(
        &mut self,
        token: &test_utils::erc20::ERC20,
        dest: Address,
    ) -> SubmitResult {
        let result = self
            .runner
            .submit_with_signer(self.signer, |nonce| {
                token.approve(dest, 1_000_000.into(), nonce)
            })
            .unwrap();
        assert!(result.status.is_ok());
        result
    }

    pub(crate) fn pool_deposit(
        &mut self,
        pool: &Pool,
        args: DepositArgs,
    ) -> (SubmitResult, ExecutionProfile) {
        self.pool_call(
            pool,
            "deposit",
            &[
                ethabi::Token::FixedArray(vec![
                    ethabi::Token::Uint(args.max_token_a),
                    ethabi::Token::Uint(args.max_token_b),
                ]),
                ethabi::Token::FixedArray(vec![
                    ethabi::Token::Uint(args.min_token_a),
                    ethabi::Token::Uint(args.min_token_b),
                ]),
            ],
        )
    }

    pub(crate) fn pool_swap(
        &mut self,
        pool: &Pool,
        args: SwapArgs,
    ) -> (SubmitResult, ExecutionProfile) {
        self.pool_call(
            pool,
            "swap",
            &[
                ethabi::Token::Address(args.src_token.raw()),
                ethabi::Token::Address(args.dst_token.raw()),
                ethabi::Token::Uint(args.amount),
                ethabi::Token::Uint(args.min_amount),
                ethabi::Token::Address(args.referral.raw()),
            ],
        )
    }

    pub(crate) fn pool_withdraw(
        &mut self,
        pool: &Pool,
        args: WithdrawArgs,
    ) -> (SubmitResult, ExecutionProfile) {
        self.pool_call(
            pool,
            "withdraw",
            &[
                ethabi::Token::Uint(args.amount),
                ethabi::Token::Array(vec![
                    ethabi::Token::Uint(args.min_token_a),
                    ethabi::Token::Uint(args.min_token_b),
                ]),
            ],
        )
    }

    fn pool_call(
        &mut self,
        pool: &Pool,
        method_name: &str,
        args: &[ethabi::Token],
    ) -> (SubmitResult, ExecutionProfile) {
        let (result, profile) = self
            .runner
            .submit_with_signer_profiled(self.signer, |nonce| {
                pool.0.call_method_with_args(method_name, args, nonce)
            })
            .unwrap();
        assert!(result.status.is_ok());
        (result, profile)
    }
}

pub(crate) struct PoolDeployer(solidity::DeployedContract);

pub(crate) struct PoolFactory(solidity::DeployedContract);

pub(crate) struct Pool(solidity::DeployedContract);

pub(crate) struct DepositArgs {
    pub min_token_a: U256,
    pub min_token_b: U256,
    pub max_token_a: U256,
    pub max_token_b: U256,
}

pub(crate) struct SwapArgs {
    pub src_token: Address,
    pub dst_token: Address,
    pub amount: U256,
    pub min_amount: U256,
    pub referral: Address,
}

pub(crate) struct WithdrawArgs {
    pub amount: U256,
    pub min_token_a: U256,
    pub min_token_b: U256,
}

impl Pool {
    pub fn address(&self) -> Address {
        self.0.address
    }
}

fn download_and_compile_solidity_sources() -> PathBuf {
    super::download_and_compile_solidity_sources(
        "liquidity-protocol",
        &DOWNLOAD_ONCE,
        &COMPILE_ONCE,
    )
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/one_inch/mod.rs ---
use std::path::{Path, PathBuf};
use std::process::Command;
use std::sync::Once;

pub(crate) mod liquidity_protocol;

pub(crate) fn download_and_compile_solidity_sources(
    repo_name: &str,
    download_once: &'static Once,
    compile_once: &'static Once,
) -> PathBuf {
    let sources_dir = Path::new("target").join(repo_name);
    if !sources_dir.exists() {
        // Contracts not already present, so download them (but only once, even
        // if multiple tests running in parallel saw `contracts_dir` does not exist).
        download_once.call_once(|| {
            let url = format!("https://github.com/1inch/{}", repo_name);
            let repo = git2::Repository::clone(&url, &sources_dir).unwrap();
            if repo_name == "limit-order-protocol" {
                // We need to checkout a specific commit because the code in the current `master`
                // cannot be used with our version of `ethereum-types`, it gives the following error:
                // Error("unknown variant `error`, expected one of `constructor`, `function`, `event`, `fallback`, `receive`", line: 9, column: 21)
                let commit_hash =
                    git2::Oid::from_str("49ab85b3c39d916711495596a1bf811848437896").unwrap();
                repo.set_head_detached(commit_hash).unwrap();
                let mut opts = git2::build::CheckoutBuilder::new();
                repo.checkout_head(Some(opts.force())).unwrap();
            }
        });
    }

    compile_once.call_once(|| {
        // install packages
        let status = Command::new("/usr/bin/env")
            .current_dir(&sources_dir)
            .args(["yarn", "install"])
            .status()
            .unwrap();
        assert!(status.success());

        let hardhat = |command: &str| {
            let status = Command::new("/usr/bin/env")
                .current_dir(&sources_dir)
                .args(["node_modules/hardhat/internal/cli/cli.js", command])
                .status()
                .unwrap();
            assert!(status.success());
        };

        // clean and compile
        hardhat("clean");
        hardhat("compile");
    });

    sources_dir.join("artifacts/contracts")
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/random.rs ---
use crate::prelude::U256;
use crate::test_utils::{self, solidity, AuroraRunner, Signer};
use aurora_engine_transactions::legacy::TransactionLegacy;
use aurora_engine_types::H256;
use ethabi::Constructor;

const DEFAULT_GAS: u64 = 1_000_000_000;

pub(crate) struct RandomConstructor(pub solidity::ContractConstructor);

impl RandomConstructor {
    pub fn load() -> Self {
        Self(solidity::ContractConstructor::compile_from_extended_json(
            "../etc/eth-contracts/artifacts/contracts/test/Random.sol/Random.json",
        ))
    }

    pub fn deploy(&self, nonce: u64) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .constructor()
            .unwrap_or(&Constructor { inputs: vec![] })
            .encode_input(self.0.code.clone(), &[])
            .unwrap();

        TransactionLegacy {
            nonce: nonce.into(),
            gas_price: Default::default(),
            gas_limit: U256::from(DEFAULT_GAS),
            to: None,
            value: Default::default(),
            data,
        }
    }
}

impl From<RandomConstructor> for solidity::ContractConstructor {
    fn from(c: RandomConstructor) -> Self {
        c.0
    }
}

pub(crate) struct Random {
    contract: solidity::DeployedContract,
}

impl Random {
    pub fn random_seed(&self, runner: &mut AuroraRunner, signer: &mut Signer) -> H256 {
        let data = self
            .contract
            .abi
            .function("randomSeed")
            .unwrap()
            .encode_input(&[])
            .unwrap();

        let tx = TransactionLegacy {
            nonce: signer.use_nonce().into(),
            gas_price: Default::default(),
            gas_limit: U256::from(DEFAULT_GAS),
            to: Some(self.contract.address),
            value: Default::default(),
            data,
        };

        let result = runner.submit_transaction(&signer.secret_key, tx).unwrap();
        let result = test_utils::unwrap_success(result);

        let mut random_seed = [0; 32];
        random_seed.copy_from_slice(result.as_slice());
        H256::from(random_seed)
    }
}

impl From<solidity::DeployedContract> for Random {
    fn from(contract: solidity::DeployedContract) -> Self {
        Self { contract }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/rust.rs ---
use std::path::Path;
use std::process::Command;

pub fn compile<P: AsRef<Path>>(source_path: P) {
    let output = Command::new("cargo")
        .current_dir(source_path)
        .env("RUSTFLAGS", "-C link-arg=-s")
        .args(["build", "--target", "wasm32-unknown-unknown", "--release"])
        .output()
        .unwrap();

    if !output.status.success() {
        panic!("{}", String::from_utf8(output.stderr).unwrap());
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/self_destruct.rs ---
use crate::prelude::{
    parameters::CallArgs, parameters::FunctionCallArgsV2, transactions::legacy::TransactionLegacy,
    Address, WeiU256, U256,
};
use crate::test_utils::{self, solidity, AuroraRunner, Signer};
use borsh::BorshSerialize;

pub(crate) struct SelfDestructFactoryConstructor(pub solidity::ContractConstructor);

const DEFAULT_GAS: u64 = 1_000_000_000;

impl SelfDestructFactoryConstructor {
    pub fn load() -> Self {
        Self(solidity::ContractConstructor::compile_from_extended_json(
            "../etc/eth-contracts/artifacts/contracts/test/StateTest.sol/SelfDestructFactory.json",
        ))
    }

    pub fn deploy(&self, nonce: u64) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .constructor()
            .unwrap()
            .encode_input(self.0.code.clone(), &[])
            .unwrap();

        TransactionLegacy {
            nonce: nonce.into(),
            gas_price: Default::default(),
            gas_limit: U256::from(DEFAULT_GAS),
            to: None,
            value: Default::default(),
            data,
        }
    }
}

pub(crate) struct SelfDestructFactory {
    contract: solidity::DeployedContract,
}

impl From<SelfDestructFactoryConstructor> for solidity::ContractConstructor {
    fn from(c: SelfDestructFactoryConstructor) -> Self {
        c.0
    }
}

impl From<solidity::DeployedContract> for SelfDestructFactory {
    fn from(contract: solidity::DeployedContract) -> Self {
        Self { contract }
    }
}

impl SelfDestructFactory {
    pub fn deploy(&self, runner: &mut AuroraRunner, signer: &mut Signer) -> Address {
        let data = self
            .contract
            .abi
            .function("deploy")
            .unwrap()
            .encode_input(&[])
            .unwrap();

        let tx = TransactionLegacy {
            nonce: signer.use_nonce().into(),
            gas_price: Default::default(),
            gas_limit: U256::from(DEFAULT_GAS),
            to: Some(self.contract.address),
            value: Default::default(),
            data,
        };

        let result = runner.submit_transaction(&signer.secret_key, tx).unwrap();
        let result = test_utils::unwrap_success(result);

        Address::try_from_slice(&result[12..]).unwrap()
    }
}

pub(crate) struct SelfDestructConstructor(pub solidity::ContractConstructor);

impl SelfDestructConstructor {
    pub fn load() -> Self {
        Self(solidity::ContractConstructor::compile_from_extended_json(
            "../etc/eth-contracts/artifacts/contracts/test/StateTest.sol/SelfDestruct.json",
        ))
    }
}

pub(crate) struct SelfDestruct {
    contract: solidity::DeployedContract,
}

impl SelfDestruct {
    pub fn counter(&self, runner: &mut AuroraRunner, signer: &mut Signer) -> Option<u128> {
        let data = self
            .contract
            .abi
            .function("counter")
            .unwrap()
            .encode_input(&[])
            .unwrap();

        let tx = TransactionLegacy {
            nonce: signer.use_nonce().into(),
            gas_price: Default::default(),
            gas_limit: U256::from(DEFAULT_GAS),
            to: Some(self.contract.address),
            value: Default::default(),
            data,
        };

        let result = runner.submit_transaction(&signer.secret_key, tx).unwrap();
        let result = test_utils::unwrap_success(result);

        if result.len() == 32 {
            Some(u128::from_be_bytes(result[16..32].try_into().unwrap()))
        } else {
            None
        }
    }

    pub fn increase(&self, runner: &mut AuroraRunner, signer: &mut Signer) {
        let data = self
            .contract
            .abi
            .function("increase")
            .unwrap()
            .encode_input(&[])
            .unwrap();

        let tx = TransactionLegacy {
            nonce: signer.use_nonce().into(),
            gas_price: Default::default(),
            gas_limit: U256::from(DEFAULT_GAS),
            to: Some(self.contract.address),
            value: Default::default(),
            data,
        };

        runner.submit_transaction(&signer.secret_key, tx).unwrap();
    }

    pub fn finish_using_submit(&self, runner: &mut AuroraRunner, signer: &mut Signer) {
        let data = self
            .contract
            .abi
            .function("finish")
            .unwrap()
            .encode_input(&[])
            .unwrap();

        let tx = TransactionLegacy {
            nonce: signer.use_nonce().into(),
            gas_price: Default::default(),
            gas_limit: U256::from(DEFAULT_GAS),
            to: Some(self.contract.address),
            value: Default::default(),
            data,
        };

        runner.submit_transaction(&signer.secret_key, tx).unwrap();
    }

    pub fn finish(&self, runner: &mut AuroraRunner) {
        let data = self
            .contract
            .abi
            .function("finish")
            .unwrap()
            .encode_input(&[])
            .unwrap();

        let input = CallArgs::V2(FunctionCallArgsV2 {
            contract: self.contract.address,
            value: WeiU256::default(),
            input: data.to_vec(),
        })
        .try_to_vec()
        .unwrap();

        runner.call("call", "anyone", input);
    }
}

impl From<solidity::DeployedContract> for SelfDestruct {
    fn from(contract: solidity::DeployedContract) -> Self {
        Self { contract }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/solidity.rs ---
use crate::prelude::{transactions::legacy::TransactionLegacy, Address, U256};
use near_sdk::serde_json;
use serde::Deserialize;
use std::fs;
use std::path::Path;
use std::process::Command;

pub(crate) struct ContractConstructor {
    pub abi: ethabi::Contract,
    pub code: Vec<u8>,
}

pub(crate) struct DeployedContract {
    pub abi: ethabi::Contract,
    pub address: Address,
}

#[derive(Deserialize)]
struct ExtendedJsonSolidityArtifact {
    abi: ethabi::Contract,
    bytecode: String,
}

impl ContractConstructor {
    /// Same as `compile_from_source` but always recompiles instead of reusing artifacts when they exist.
    pub fn force_compile<P1, P2, P3>(
        sources_root: P1,
        artifacts_base_path: P2,
        contract_file: P3,
        contract_name: &str,
    ) -> Self
    where
        P1: AsRef<Path>,
        P2: AsRef<Path>,
        P3: AsRef<Path>,
    {
        compile(&sources_root, &contract_file, &artifacts_base_path);
        Self::compile_from_source(
            sources_root,
            artifacts_base_path,
            contract_file,
            contract_name,
        )
    }

    // Note: `contract_file` must be relative to `sources_root`
    pub fn compile_from_source<P1, P2, P3>(
        sources_root: P1,
        artifacts_base_path: P2,
        contract_file: P3,
        contract_name: &str,
    ) -> Self
    where
        P1: AsRef<Path>,
        P2: AsRef<Path>,
        P3: AsRef<Path>,
    {
        let bin_file = format!("{}.bin", contract_name);
        let abi_file = format!("{}.abi", contract_name);
        let hex_path = artifacts_base_path.as_ref().join(&bin_file);
        let hex_rep = match std::fs::read_to_string(&hex_path) {
            Ok(hex) => hex,
            Err(_) => {
                // An error occurred opening the file, maybe the contract hasn't been compiled?
                compile(sources_root, contract_file, &artifacts_base_path);
                // If another error occurs, then we can't handle it so we just unwrap.
                std::fs::read_to_string(hex_path).unwrap()
            }
        };
        let code = hex::decode(&hex_rep).unwrap();
        let abi_path = artifacts_base_path.as_ref().join(&abi_file);
        let reader = std::fs::File::open(abi_path).unwrap();
        let abi = ethabi::Contract::load(reader).unwrap();

        Self { abi, code }
    }

    pub fn compile_from_extended_json<P>(contract_path: P) -> Self
    where
        P: AsRef<Path>,
    {
        let reader = std::fs::File::open(contract_path).unwrap();
        let contract: ExtendedJsonSolidityArtifact = serde_json::from_reader(reader).unwrap();

        Self {
            abi: contract.abi,
            code: hex::decode(&contract.bytecode[2..]).unwrap(),
        }
    }

    pub fn deployed_at(&self, address: Address) -> DeployedContract {
        DeployedContract {
            abi: self.abi.clone(),
            address,
        }
    }

    pub fn deploy_without_constructor(&self, nonce: U256) -> TransactionLegacy {
        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: None,
            value: Default::default(),
            data: self.code.clone(),
        }
    }

    pub fn deploy_without_args(&self, nonce: U256) -> TransactionLegacy {
        self.deploy_with_args(nonce, &[])
    }

    pub fn deploy_with_args(&self, nonce: U256, args: &[ethabi::Token]) -> TransactionLegacy {
        let data = self
            .abi
            .constructor()
            .unwrap()
            .encode_input(self.code.clone(), args)
            .unwrap();
        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: None,
            value: Default::default(),
            data,
        }
    }
}

impl DeployedContract {
    pub fn call_method_without_args(&self, method_name: &str, nonce: U256) -> TransactionLegacy {
        self.call_method_with_args(method_name, &[], nonce)
    }

    pub fn call_method_with_args(
        &self,
        method_name: &str,
        args: &[ethabi::Token],
        nonce: U256,
    ) -> TransactionLegacy {
        let data = self
            .abi
            .function(method_name)
            .unwrap()
            .encode_input(args)
            .unwrap();
        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.address),
            value: Default::default(),
            data,
        }
    }
}

/// Compiles a solidity contract. `source_path` gives the directory containing all solidity
/// source files to consider (including imports). `contract_file` must be
/// given relative to `source_path`. `output_path` gives the directory where the compiled
/// artifacts are written. Requires Docker to be installed.
fn compile<P1, P2, P3>(source_path: P1, contract_file: P2, output_path: P3)
where
    P1: AsRef<Path>,
    P2: AsRef<Path>,
    P3: AsRef<Path>,
{
    let source_path = fs::canonicalize(source_path).unwrap();
    fs::create_dir_all(&output_path).unwrap();
    let output_path = fs::canonicalize(output_path).unwrap();
    let source_mount_arg = format!("{}:/contracts", source_path.to_str().unwrap());
    let output_mount_arg = format!("{}:/output", output_path.to_str().unwrap());
    let contract_arg = format!("/contracts/{}", contract_file.as_ref().to_str().unwrap());
    let output = Command::new("/usr/bin/env")
        .args([
            "docker",
            "run",
            "-v",
            &source_mount_arg,
            "-v",
            &output_mount_arg,
            "ethereum/solc:stable",
            "--allow-paths",
            "/contracts/",
            "-o",
            "/output",
            "--abi",
            "--bin",
            "--overwrite",
            &contract_arg,
        ])
        .output()
        .unwrap();
    if !output.status.success() {
        panic!(
            "Could not compile solidity contracts in docker: {}",
            String::from_utf8(output.stderr).unwrap()
        );
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/standalone/mocks/block.rs ---
use aurora_engine_transactions::legacy::LegacyEthSignedTransaction;

/// A vastly simplified block structure
pub struct Block {
    pub height: u64,
    pub transactions: Vec<LegacyEthSignedTransaction>,
}

/// A vastly simplified blockchain structure. It is assumed
/// the 0th block is genesis and the parent of ith block is
/// block i-1.
pub type Blockchain = Vec<Block>;

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/standalone/mocks/mod.rs ---
use crate::test_utils;
use aurora_engine::engine;
use aurora_engine::fungible_token::FungibleTokenMetadata;
use aurora_engine::parameters::{
    FinishDepositCallArgs, InitCallArgs, NEP141FtOnTransferArgs, NewCallArgs,
};
use aurora_engine_sdk::env::{Env, DEFAULT_PREPAID_GAS};
use aurora_engine_sdk::io::IO;
use aurora_engine_types::types::{Address, Balance, NEP141Wei, NearGas, Wei};
use aurora_engine_types::{account_id::AccountId, H256, U256};
use engine_standalone_storage::{BlockMetadata, Storage};
use near_sdk_sim::DEFAULT_GAS;

pub mod block;

pub const ETH_CUSTODIAN_ADDRESS: Address =
    aurora_engine_precompiles::make_address(0xd045f7e1, 0x9b2488924b97f9c145b5e51d0d895a65);

pub fn compute_block_hash(block_height: u64) -> H256 {
    aurora_engine::engine::compute_block_hash([0u8; 32], block_height, b"aurora")
}

pub fn insert_block(storage: &mut Storage, block_height: u64) {
    let block_hash = compute_block_hash(block_height);
    let block_metadata = BlockMetadata {
        timestamp: aurora_engine_sdk::env::Timestamp::new(0),
        random_seed: H256::zero(),
    };
    storage
        .set_block_data(block_hash, block_height, block_metadata)
        .unwrap();
}

pub fn default_env(block_height: u64) -> aurora_engine_sdk::env::Fixed {
    let aurora_id: AccountId = test_utils::AuroraRunner::default()
        .aurora_account_id
        .parse()
        .unwrap();
    aurora_engine_sdk::env::Fixed {
        signer_account_id: aurora_id.clone(),
        current_account_id: aurora_id.clone(),
        predecessor_account_id: aurora_id,
        block_height,
        block_timestamp: aurora_engine_sdk::env::Timestamp::new(0),
        attached_deposit: 0,
        random_seed: H256::zero(),
        prepaid_gas: DEFAULT_PREPAID_GAS,
    }
}

pub fn init_evm<I: IO + Copy, E: Env>(mut io: I, env: &E, chain_id: u64) {
    let new_args = NewCallArgs {
        chain_id: aurora_engine_types::types::u256_to_arr(&U256::from(chain_id)),
        owner_id: env.current_account_id(),
        bridge_prover_id: test_utils::str_to_account_id("bridge_prover.near"),
        upgrade_delay_blocks: 1,
    };

    engine::set_state(&mut io, new_args.into());

    let connector_args = InitCallArgs {
        prover_account: test_utils::str_to_account_id("prover.near"),
        eth_custodian_address: ETH_CUSTODIAN_ADDRESS.encode(),
        metadata: FungibleTokenMetadata::default(),
    };

    aurora_engine::connector::EthConnectorContract::create_contract(
        io,
        env.current_account_id(),
        connector_args,
    )
    .map_err(unsafe_to_string)
    .unwrap();
}

pub fn mint_evm_account<I: IO + Copy, E: Env>(
    address: Address,
    balance: Wei,
    nonce: U256,
    code: Option<Vec<u8>>,
    mut io: I,
    env: &E,
) {
    use evm::backend::ApplyBackend;

    let aurora_account_id = env.current_account_id();
    let mut engine = engine::Engine::new(address, aurora_account_id.clone(), io, env).unwrap();
    let state_change = evm::backend::Apply::Modify {
        address: address.raw(),
        basic: evm::backend::Basic {
            balance: balance.raw(),
            nonce,
        },
        code,
        storage: std::iter::empty(),
        reset_storage: false,
    };

    let deposit_args = FinishDepositCallArgs {
        new_owner_id: aurora_account_id.clone(),
        amount: NEP141Wei::new(balance.raw().as_u128()),
        proof_key: String::new(),
        relayer_id: aurora_account_id.clone(),
        fee: 0.into(),
        msg: None,
    };

    // Delete the fake proof so that we can use it again.
    let proof_key = crate::prelude::storage::bytes_to_key(
        crate::prelude::storage::KeyPrefix::EthConnector,
        &[crate::prelude::storage::EthConnectorStorageId::UsedEvent as u8],
    );
    io.remove_storage(&proof_key);

    let mut connector = aurora_engine::connector::EthConnectorContract::init_instance(io).unwrap();
    connector
        .finish_deposit(
            aurora_account_id.clone(),
            aurora_account_id.clone(),
            deposit_args,
            NearGas::new(DEFAULT_GAS),
        )
        .map_err(unsafe_to_string)
        .unwrap();

    let transfer_args = NEP141FtOnTransferArgs {
        sender_id: aurora_account_id,
        amount: Balance::new(balance.raw().as_u128()),
        msg: format!(
            "aurora:{}{}",
            hex::encode(Wei::zero().to_bytes()),
            hex::encode(address.as_bytes())
        ),
    };
    connector.ft_on_transfer(&engine, &transfer_args).unwrap();

    engine.apply(std::iter::once(state_change), std::iter::empty(), false);
}

pub fn unsafe_to_string<E: AsRef<[u8]>>(e: E) -> String {
    String::from_utf8(e.as_ref().to_vec()).unwrap()
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/standalone/mod.rs ---
use aurora_engine::engine;
use aurora_engine::parameters::{
    CallArgs, DeployErc20TokenArgs, PausePrecompilesCallArgs, SubmitResult, TransactionStatus,
};
use aurora_engine_sdk::env::{self, Env};
use aurora_engine_transactions::legacy::{LegacyEthSignedTransaction, TransactionLegacy};
use aurora_engine_types::types::{Address, NearGas, PromiseResult, Wei};
use aurora_engine_types::{H256, U256};
use borsh::BorshDeserialize;
use engine_standalone_storage::{
    sync::{
        self,
        types::{TransactionKind, TransactionMessage},
    },
    BlockMetadata, Diff, Storage,
};
use libsecp256k1::SecretKey;
use tempfile::TempDir;

use crate::test_utils;

pub mod mocks;
pub mod storage;

pub struct StandaloneRunner {
    pub storage_dir: TempDir,
    pub storage: Storage,
    pub env: env::Fixed,
    pub chain_id: u64,
    // Cumulative diff from all transactions (ie full state representation)
    pub cumulative_diff: Diff,
}

impl StandaloneRunner {
    pub fn init_evm(&mut self) {
        self.init_evm_with_chain_id(self.chain_id)
    }

    pub fn init_evm_with_chain_id(&mut self, chain_id: u64) {
        self.chain_id = chain_id;
        let storage = &mut self.storage;
        let env = &mut self.env;
        storage
            .set_engine_account_id(&env.current_account_id)
            .unwrap();
        env.block_height += 1;
        let transaction_hash = H256::zero();
        let tx_msg = Self::template_tx_msg(storage, env, 0, transaction_hash, &[]);
        let result = storage.with_engine_access(env.block_height, 0, &[], |io| {
            mocks::init_evm(io, env, chain_id);
        });
        let outcome = sync::TransactionIncludedOutcome {
            hash: transaction_hash,
            info: tx_msg,
            diff: result.diff,
            maybe_result: Ok(None),
        };
        self.cumulative_diff.append(outcome.diff.clone());
        test_utils::standalone::storage::commit(storage, &outcome);
    }

    pub fn mint_account(
        &mut self,
        address: Address,
        balance: Wei,
        nonce: U256,
        code: Option<Vec<u8>>,
    ) {
        let storage = &mut self.storage;
        let env = &mut self.env;
        let transaction_hash = {
            let bytes = [
                address.raw().as_ref(),
                &balance.to_bytes(),
                &aurora_engine_types::types::u256_to_arr(&nonce),
            ]
            .concat();
            aurora_engine_sdk::keccak(&bytes)
        };

        env.block_height += 1;
        let tx_msg = Self::template_tx_msg(storage, env, 0, transaction_hash, &[]);

        let result = storage.with_engine_access(env.block_height, 0, &[], |io| {
            mocks::mint_evm_account(address, balance, nonce, code, io, env)
        });
        let outcome = sync::TransactionIncludedOutcome {
            hash: transaction_hash,
            info: tx_msg,
            diff: result.diff,
            maybe_result: Ok(None),
        };
        self.cumulative_diff.append(outcome.diff.clone());
        test_utils::standalone::storage::commit(storage, &outcome);
    }

    pub fn transfer_with_signer(
        &mut self,
        signer: &mut test_utils::Signer,
        amount: Wei,
        dest: Address,
    ) -> Result<SubmitResult, engine::EngineError> {
        let tx = TransactionLegacy {
            nonce: signer.use_nonce().into(),
            gas_price: U256::zero(),
            gas_limit: u64::MAX.into(),
            to: Some(dest),
            value: amount,
            data: Vec::new(),
        };
        self.submit_transaction(&signer.secret_key, tx)
    }

    pub fn submit_transaction(
        &mut self,
        account: &SecretKey,
        transaction: TransactionLegacy,
    ) -> Result<SubmitResult, engine::EngineError> {
        let storage = &mut self.storage;
        let env = &mut self.env;
        env.block_height += 1;
        let signed_tx = test_utils::sign_transaction(transaction, Some(self.chain_id), account);
        let transaction_bytes = rlp::encode(&signed_tx).to_vec();

        Self::internal_submit_transaction(
            &transaction_bytes,
            0,
            storage,
            env,
            &mut self.cumulative_diff,
            &[],
        )
    }

    pub fn submit_raw_transaction_bytes(
        &mut self,
        transaction_bytes: &[u8],
    ) -> Result<SubmitResult, engine::EngineError> {
        self.env.predecessor_account_id = "some-account.near".parse().unwrap();
        let storage = &mut self.storage;
        let env = &mut self.env;
        env.block_height += 1;

        Self::internal_submit_transaction(
            transaction_bytes,
            0,
            storage,
            env,
            &mut self.cumulative_diff,
            &[],
        )
    }

    /// Note: does not persist the diff in the DB.
    pub fn execute_transaction_at_position(
        &mut self,
        signed_tx: &LegacyEthSignedTransaction,
        block_height: u64,
        transaction_position: u16,
    ) -> Result<sync::TransactionIncludedOutcome, engine::EngineError> {
        let storage = &mut self.storage;
        let env = &mut self.env;

        env.block_height = block_height;
        let transaction_bytes = rlp::encode(signed_tx).to_vec();
        let transaction_hash = aurora_engine_sdk::keccak(&transaction_bytes);

        let mut tx_msg = Self::template_tx_msg(storage, env, 0, transaction_hash, &[]);
        tx_msg.position = transaction_position;
        tx_msg.transaction =
            TransactionKind::Submit(transaction_bytes.as_slice().try_into().unwrap());
        let outcome = sync::execute_transaction_message(storage, tx_msg).unwrap();

        match outcome.maybe_result.as_ref().unwrap().as_ref().unwrap() {
            sync::TransactionExecutionResult::Submit(result) => {
                if let Err(e) = result.as_ref() {
                    return Err(e.clone());
                }
            }
            _ => unreachable!(),
        };

        Ok(outcome)
    }

    pub fn submit_raw(
        &mut self,
        method_name: &str,
        ctx: &near_vm_logic::VMContext,
        promise_results: &[PromiseResult],
    ) -> Result<SubmitResult, engine::EngineError> {
        let mut env = self.env.clone();
        env.block_height = ctx.block_index;
        env.attached_deposit = ctx.attached_deposit;
        env.block_timestamp = aurora_engine_sdk::env::Timestamp::new(ctx.block_timestamp);
        env.predecessor_account_id = ctx.predecessor_account_id.as_ref().parse().unwrap();
        env.current_account_id = ctx.current_account_id.as_ref().parse().unwrap();
        env.signer_account_id = ctx.signer_account_id.as_ref().parse().unwrap();
        env.prepaid_gas = NearGas::new(ctx.prepaid_gas);

        let storage = &mut self.storage;
        if method_name == test_utils::SUBMIT {
            let transaction_bytes = &ctx.input;
            Self::internal_submit_transaction(
                transaction_bytes,
                0,
                storage,
                &mut env,
                &mut self.cumulative_diff,
                promise_results,
            )
        } else if method_name == test_utils::CALL {
            let call_args = CallArgs::try_from_slice(&ctx.input).unwrap();
            let transaction_hash = aurora_engine_sdk::keccak(&ctx.input);
            let mut tx_msg =
                Self::template_tx_msg(storage, &env, 0, transaction_hash, promise_results);
            tx_msg.transaction = TransactionKind::Call(call_args);

            let outcome = sync::execute_transaction_message(storage, tx_msg).unwrap();
            self.cumulative_diff.append(outcome.diff.clone());
            test_utils::standalone::storage::commit(storage, &outcome);

            unwrap_result(outcome)
        } else if method_name == test_utils::DEPLOY_ERC20 {
            let deploy_args = DeployErc20TokenArgs::try_from_slice(&ctx.input).unwrap();
            let transaction_hash = aurora_engine_sdk::keccak(&ctx.input);
            let mut tx_msg =
                Self::template_tx_msg(storage, &env, 0, transaction_hash, promise_results);
            tx_msg.transaction = TransactionKind::DeployErc20(deploy_args);

            let outcome = sync::execute_transaction_message(storage, tx_msg).unwrap();
            self.cumulative_diff.append(outcome.diff.clone());
            test_utils::standalone::storage::commit(storage, &outcome);

            let address = match outcome.maybe_result.unwrap().unwrap() {
                sync::TransactionExecutionResult::DeployErc20(address) => address,
                _ => unreachable!(),
            };
            Ok(SubmitResult::new(
                TransactionStatus::Succeed(address.raw().as_ref().to_vec()),
                0,
                Vec::new(),
            ))
        } else if method_name == test_utils::RESUME_PRECOMPILES {
            let input = &ctx.input[..];
            let call_args = PausePrecompilesCallArgs::try_from_slice(input)
                .expect("Unable to parse input as PausePrecompilesCallArgs");

            let transaction_hash = aurora_engine_sdk::keccak(&ctx.input);
            let mut tx_msg =
                Self::template_tx_msg(storage, &env, 0, transaction_hash, promise_results);
            tx_msg.transaction = TransactionKind::ResumePrecompiles(call_args);

            let outcome = sync::execute_transaction_message(storage, tx_msg).unwrap();
            self.cumulative_diff.append(outcome.diff.clone());
            storage::commit(storage, &outcome);

            Ok(SubmitResult::new(
                TransactionStatus::Succeed(Vec::new()),
                0,
                Vec::new(),
            ))
        } else if method_name == test_utils::PAUSE_PRECOMPILES {
            let input = &ctx.input[..];
            let call_args = PausePrecompilesCallArgs::try_from_slice(input)
                .expect("Unable to parse input as PausePrecompilesCallArgs");

            let transaction_hash = aurora_engine_sdk::keccak(&ctx.input);
            let mut tx_msg =
                Self::template_tx_msg(storage, &env, 0, transaction_hash, promise_results);
            tx_msg.transaction = TransactionKind::PausePrecompiles(call_args);

            let outcome = sync::execute_transaction_message(storage, tx_msg).unwrap();
            self.cumulative_diff.append(outcome.diff.clone());
            storage::commit(storage, &outcome);

            Ok(SubmitResult::new(
                TransactionStatus::Succeed(Vec::new()),
                0,
                Vec::new(),
            ))
        } else {
            panic!("Unsupported standalone method {}", method_name);
        }
    }

    pub fn get_current_state(&self) -> &Diff {
        &self.cumulative_diff
    }

    pub fn get_balance(&mut self, address: &Address) -> Wei {
        self.storage
            .with_engine_access(self.env.block_height + 1, 0, &[], |io| {
                engine::get_balance(&io, address)
            })
            .result
    }

    pub fn get_nonce(&mut self, address: &Address) -> U256 {
        self.storage
            .with_engine_access(self.env.block_height + 1, 0, &[], |io| {
                engine::get_nonce(&io, address)
            })
            .result
    }

    pub fn get_code(&mut self, address: &Address) -> Vec<u8> {
        self.storage
            .with_engine_access(self.env.block_height + 1, 0, &[], |io| {
                engine::get_code(&io, address)
            })
            .result
    }

    pub fn close(self) {
        drop(self.storage);
        self.storage_dir.close().unwrap();
    }

    pub(crate) fn template_tx_msg(
        storage: &mut Storage,
        env: &env::Fixed,
        transaction_position: u16,
        transaction_hash: H256,
        promise_results: &[PromiseResult],
    ) -> TransactionMessage {
        let block_hash = mocks::compute_block_hash(env.block_height);
        let block_metadata = BlockMetadata {
            timestamp: env.block_timestamp,
            random_seed: env.random_seed,
        };
        storage
            .set_block_data(block_hash, env.block_height, block_metadata)
            .unwrap();
        let promise_data = promise_results
            .iter()
            .map(|p| match p {
                PromiseResult::Failed | PromiseResult::NotReady => None,
                PromiseResult::Successful(bytes) => Some(bytes.clone()),
            })
            .collect();
        TransactionMessage {
            block_hash,
            near_receipt_id: transaction_hash,
            position: transaction_position,
            succeeded: true,
            signer: env.signer_account_id(),
            caller: env.predecessor_account_id(),
            attached_near: env.attached_deposit,
            transaction: TransactionKind::Unknown,
            promise_data,
        }
    }

    fn internal_submit_transaction<'db>(
        transaction_bytes: &[u8],
        transaction_position: u16,
        storage: &'db mut Storage,
        env: &mut env::Fixed,
        cumulative_diff: &mut Diff,
        promise_results: &[PromiseResult],
    ) -> Result<SubmitResult, engine::EngineError> {
        let transaction_hash = aurora_engine_sdk::keccak(transaction_bytes);
        let mut tx_msg = Self::template_tx_msg(
            storage,
            env,
            transaction_position,
            transaction_hash,
            promise_results,
        );
        tx_msg.transaction = TransactionKind::Submit(transaction_bytes.try_into().unwrap());

        let outcome = sync::execute_transaction_message(storage, tx_msg).unwrap();
        cumulative_diff.append(outcome.diff.clone());
        test_utils::standalone::storage::commit(storage, &outcome);

        unwrap_result(outcome)
    }
}

fn unwrap_result(
    outcome: sync::TransactionIncludedOutcome,
) -> Result<SubmitResult, engine::EngineError> {
    match outcome.maybe_result.unwrap().unwrap() {
        sync::TransactionExecutionResult::Submit(result) => result,
        sync::TransactionExecutionResult::Promise(_) => panic!("Unexpected promise."),
        sync::TransactionExecutionResult::DeployErc20(_) => panic!("Unexpected DeployErc20."),
    }
}

impl Default for StandaloneRunner {
    fn default() -> Self {
        let (storage_dir, storage) = storage::create_db();
        let env = mocks::default_env(0);
        let chain_id = test_utils::AuroraRunner::default().chain_id;
        Self {
            storage_dir,
            storage,
            env,
            chain_id,
            cumulative_diff: Diff::default(),
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/standalone/storage.rs ---
use engine_standalone_storage::{self, sync::TransactionIncludedOutcome, Storage};
use tempfile::TempDir;

pub fn commit(storage: &mut Storage, outcome: &TransactionIncludedOutcome) {
    storage
        .set_transaction_included(outcome.hash, &outcome.info, &outcome.diff)
        .unwrap();
}

pub fn create_db() -> (TempDir, Storage) {
    let dir = TempDir::new().unwrap();
    let storage = Storage::open(dir.path()).unwrap();
    (dir, storage)
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/standard_precompiles.rs ---
use crate::prelude::{transactions::legacy::TransactionLegacy, U256};
use crate::test_utils::solidity;
use std::path::{Path, PathBuf};

pub(crate) struct PrecompilesConstructor(pub solidity::ContractConstructor);

pub(crate) struct PrecompilesContract(pub solidity::DeployedContract);

impl From<PrecompilesConstructor> for solidity::ContractConstructor {
    fn from(c: PrecompilesConstructor) -> Self {
        c.0
    }
}

impl PrecompilesConstructor {
    pub fn load() -> Self {
        Self(solidity::ContractConstructor::compile_from_source(
            Self::sources_root(),
            Self::solidity_artifacts_path(),
            "StandardPrecompiles.sol",
            "StandardPrecompiles",
        ))
    }

    pub fn deploy(&self, nonce: U256) -> TransactionLegacy {
        self.0.deploy_without_args(nonce)
    }

    fn solidity_artifacts_path() -> PathBuf {
        Path::new("target").join("solidity_build")
    }

    fn sources_root() -> PathBuf {
        Path::new("src").join("benches").join("res")
    }
}

impl PrecompilesContract {
    pub fn call_method(&self, method_name: &str, nonce: U256) -> TransactionLegacy {
        self.0.call_method_without_args(method_name, nonce)
    }

    pub fn all_method_names() -> &'static [&'static str] {
        &[
            "test_ecrecover",
            "test_sha256",
            "test_ripemd160",
            "test_identity",
            "test_modexp",
            "test_ecadd",
            "test_ecmul",
            "test_ecpair",
            "test_blake2f",
            "test_all",
        ]
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/uniswap.rs ---
use crate::prelude::{Address, U256};
use crate::test_utils::solidity;
use aurora_engine_transactions::legacy::TransactionLegacy;
use std::ops::Not;
use std::path::{Path, PathBuf};
use std::process::Command;
use std::sync::Once;

pub(crate) struct FactoryConstructor(pub solidity::ContractConstructor);

pub(crate) struct Factory(pub solidity::DeployedContract);

pub(crate) struct Pool(pub solidity::DeployedContract);

pub(crate) struct PositionManagerConstructor(pub solidity::ContractConstructor);

pub(crate) struct PositionManager(pub solidity::DeployedContract);

pub(crate) struct SwapRouterConstructor(pub solidity::ContractConstructor);

pub(crate) struct SwapRouter(pub solidity::DeployedContract);

pub(crate) struct MintParams {
    pub token0: Address,
    pub token1: Address,
    pub fee: u64,
    pub tick_lower: i64,
    pub tick_upper: i64,
    pub amount0_desired: U256,
    pub amount1_desired: U256,
    pub amount0_min: U256,
    pub amount1_min: U256,
    pub recipient: Address,
    pub deadline: U256,
}

impl From<FactoryConstructor> for solidity::ContractConstructor {
    fn from(c: FactoryConstructor) -> Self {
        c.0
    }
}

impl From<PositionManagerConstructor> for solidity::ContractConstructor {
    fn from(c: PositionManagerConstructor) -> Self {
        c.0
    }
}

impl From<SwapRouterConstructor> for solidity::ContractConstructor {
    fn from(c: SwapRouterConstructor) -> Self {
        c.0
    }
}

static DOWNLOAD_ONCE: Once = Once::new();

impl FactoryConstructor {
    pub fn load() -> Self {
        let artifact_path = uniswap_root_path().join(
            [
                "node_modules",
                "@uniswap",
                "v3-core",
                "artifacts",
                "contracts",
                "UniswapV3Factory.sol",
                "UniswapV3Factory.json",
            ]
            .iter()
            .collect::<PathBuf>(),
        );

        Self(load_constructor(artifact_path))
    }

    pub fn deploy(&self, nonce: U256) -> TransactionLegacy {
        self.0.deploy_without_args(nonce)
    }
}

impl PositionManagerConstructor {
    pub fn load() -> Self {
        let artifact_path = uniswap_root_path().join(
            [
                "node_modules",
                "@uniswap",
                "v3-periphery",
                "artifacts",
                "contracts",
                "NonfungiblePositionManager.sol",
                "NonfungiblePositionManager.json",
            ]
            .iter()
            .collect::<PathBuf>(),
        );

        Self(load_constructor(artifact_path))
    }

    pub fn deploy(
        &self,
        factory: Address,
        wrapped_eth: Address,
        token_descriptor: Address,
        nonce: U256,
    ) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .constructor()
            .unwrap()
            .encode_input(
                self.0.code.clone(),
                &[
                    ethabi::Token::Address(factory.raw()),
                    ethabi::Token::Address(wrapped_eth.raw()),
                    ethabi::Token::Address(token_descriptor.raw()),
                ],
            )
            .unwrap();
        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: None,
            value: Default::default(),
            data,
        }
    }
}

impl Factory {
    pub fn create_pool(
        &self,
        token_a: Address,
        token_b: Address,
        fee: U256,
        nonce: U256,
    ) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .function("createPool")
            .unwrap()
            .encode_input(&[
                ethabi::Token::Address(token_a.raw()),
                ethabi::Token::Address(token_b.raw()),
                ethabi::Token::Uint(fee),
            ])
            .unwrap();

        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.0.address),
            value: Default::default(),
            data,
        }
    }
}

impl Pool {
    pub fn from_address(address: Address) -> Self {
        let artifact_path = uniswap_root_path().join(
            [
                "node_modules",
                "@uniswap",
                "v3-core",
                "artifacts",
                "contracts",
                "UniswapV3Pool.sol",
                "UniswapV3Pool.json",
            ]
            .iter()
            .collect::<PathBuf>(),
        );
        let constructor = load_constructor(artifact_path);

        Self(solidity::DeployedContract {
            abi: constructor.abi,
            address,
        })
    }

    pub fn initialize(&self, price: U256, nonce: U256) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .function("initialize")
            .unwrap()
            .encode_input(&[ethabi::Token::Uint(price)])
            .unwrap();

        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.0.address),
            value: Default::default(),
            data,
        }
    }
}

impl PositionManager {
    pub fn mint(&self, params: MintParams, nonce: U256) -> TransactionLegacy {
        let tick_lower = Self::i64_to_u256(params.tick_lower);
        let tick_upper = Self::i64_to_u256(params.tick_upper);
        let data = self
            .0
            .abi
            .function("mint")
            .unwrap()
            .encode_input(&[ethabi::Token::Tuple(vec![
                ethabi::Token::Address(params.token0.raw()),
                ethabi::Token::Address(params.token1.raw()),
                ethabi::Token::Uint(params.fee.into()),
                ethabi::Token::Int(tick_lower),
                ethabi::Token::Int(tick_upper),
                ethabi::Token::Uint(params.amount0_desired),
                ethabi::Token::Uint(params.amount1_desired),
                ethabi::Token::Uint(params.amount0_min),
                ethabi::Token::Uint(params.amount1_min),
                ethabi::Token::Address(params.recipient.raw()),
                ethabi::Token::Uint(params.deadline),
            ])])
            .unwrap();

        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.0.address),
            value: Default::default(),
            data,
        }
    }

    fn i64_to_u256(x: i64) -> U256 {
        let y = U256::from(x.abs());
        if x < 0 {
            // compute two's complement to get negative number
            y.not().overflowing_add(U256::one()).0
        } else {
            y
        }
    }
}

impl SwapRouterConstructor {
    pub fn load() -> Self {
        let artifact_path = uniswap_root_path().join(
            [
                "node_modules",
                "@uniswap",
                "v3-periphery",
                "artifacts",
                "contracts",
                "SwapRouter.sol",
                "SwapRouter.json",
            ]
            .iter()
            .collect::<PathBuf>(),
        );

        Self(load_constructor(artifact_path))
    }

    pub fn deploy(&self, factory: Address, wrapped_eth: Address, nonce: U256) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .constructor()
            .unwrap()
            .encode_input(
                self.0.code.clone(),
                &[
                    ethabi::Token::Address(factory.raw()),
                    ethabi::Token::Address(wrapped_eth.raw()),
                ],
            )
            .unwrap();
        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: None,
            value: Default::default(),
            data,
        }
    }
}

pub struct ExactOutputSingleParams {
    pub token_in: Address,
    pub token_out: Address,
    pub fee: u64,
    pub recipient: Address,
    pub deadline: U256,
    pub amount_out: U256,
    pub amount_in_max: U256,
    pub price_limit: U256,
}

pub struct ExactInputParams {
    pub token_in: Address,
    // Vec of poolFee + tokenAddress
    pub path: Vec<(u64, Address)>,
    pub recipient: Address,
    pub deadline: U256,
    pub amount_in: U256,
    pub amount_out_min: U256,
}

impl SwapRouter {
    pub fn exact_output_single(
        &self,
        params: ExactOutputSingleParams,
        nonce: U256,
    ) -> TransactionLegacy {
        let data = self
            .0
            .abi
            .function("exactOutputSingle")
            .unwrap()
            .encode_input(&[ethabi::Token::Tuple(vec![
                ethabi::Token::Address(params.token_in.raw()),
                ethabi::Token::Address(params.token_out.raw()),
                ethabi::Token::Uint(params.fee.into()),
                ethabi::Token::Address(params.recipient.raw()),
                ethabi::Token::Uint(params.deadline),
                ethabi::Token::Uint(params.amount_out),
                ethabi::Token::Uint(params.amount_in_max),
                ethabi::Token::Uint(params.price_limit),
            ])])
            .unwrap();

        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.0.address),
            value: Default::default(),
            data,
        }
    }

    pub fn exact_input(&self, params: ExactInputParams, nonce: U256) -> TransactionLegacy {
        let path: Vec<u8> = {
            // The encoding here is 32-byte address, then 3-byte (24-bit) fee, alternating
            let mut result = Vec::with_capacity(32 + 35 * params.path.len());
            result.extend_from_slice(params.token_in.as_bytes());
            for (fee, token) in params.path.iter() {
                let fee_bytes = fee.to_be_bytes();
                result.extend_from_slice(&fee_bytes[5..8]);
                result.extend_from_slice(token.as_bytes());
            }
            result
        };
        let data = self
            .0
            .abi
            .function("exactInput")
            .unwrap()
            .encode_input(&[ethabi::Token::Tuple(vec![
                ethabi::Token::Bytes(path),
                ethabi::Token::Address(params.recipient.raw()),
                ethabi::Token::Uint(params.deadline),
                ethabi::Token::Uint(params.amount_in),
                ethabi::Token::Uint(params.amount_out_min),
            ])])
            .unwrap();

        TransactionLegacy {
            nonce,
            gas_price: Default::default(),
            gas_limit: u64::MAX.into(),
            to: Some(self.0.address),
            value: Default::default(),
            data,
        }
    }
}

fn load_constructor(artifact_path: PathBuf) -> solidity::ContractConstructor {
    if !artifact_path.exists() {
        download_uniswap_artifacts();
    }

    solidity::ContractConstructor::compile_from_extended_json(artifact_path)
}

fn uniswap_root_path() -> PathBuf {
    Path::new("../etc").join("tests").join("uniswap")
}

fn download_uniswap_artifacts() {
    DOWNLOAD_ONCE.call_once(|| {
        let output = Command::new("/usr/bin/env")
            .current_dir(&uniswap_root_path())
            .args(["yarn", "install"])
            .output()
            .unwrap();

        if !output.status.success() {
            panic!(
                "Downloading uniswap npm package failed.\n{}",
                String::from_utf8(output.stderr).unwrap()
            );
        }
    });
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/test_utils/weth.rs ---
use aurora_engine_transactions::legacy::TransactionLegacy;
use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::U256;

use crate::test_utils::solidity;

pub struct WethConstructor(solidity::ContractConstructor);

impl WethConstructor {
    pub fn load() -> Self {
        Self(solidity::ContractConstructor::compile_from_source(
            "src/tests/res",
            "src/tests/res",
            "weth.sol",
            "weth",
        ))
    }

    pub fn deploy(&self, nonce: U256) -> TransactionLegacy {
        self.0.deploy_without_constructor(nonce)
    }

    #[allow(dead_code)]
    pub fn deployed_at(self, address: Address) -> Weth {
        Weth(self.0.deployed_at(address))
    }
}

// We never need to access deployed WETH in current tests because we are replaying mainnet
// transactions. But this might still be useful in the future.
#[allow(dead_code)]
pub struct Weth(solidity::DeployedContract);

impl Weth {
    #[allow(dead_code)]
    pub fn deposit(&self, amount: Wei, nonce: U256) -> TransactionLegacy {
        let mut result = self.0.call_method_without_args("deposit", nonce);
        result.value = amount;
        result
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/access_lists.rs ---
use crate::prelude::transactions::eip_2930::{self, AccessTuple, Transaction2930};
use crate::prelude::transactions::EthTransactionKind;
use crate::prelude::Wei;
use crate::prelude::{H256, U256};
use crate::test_utils;
use std::convert::TryFrom;
use std::iter;

// Test taken from https://github.com/ethereum/tests/blob/develop/GeneralStateTests/stExample/accessListExample.json
// TODO(#170): generally support Ethereum tests
#[test]
fn test_access_list_tx_encoding_decoding() {
    let secret_key = libsecp256k1::SecretKey::parse_slice(
        &hex::decode("45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8").unwrap(),
    )
    .unwrap();
    let transaction = Transaction2930 {
        chain_id: 1,
        nonce: U256::zero(),
        gas_price: U256::from(0x0a),
        gas_limit: U256::from(0x061a80),
        to: Some(test_utils::address_from_hex(
            "0x095e7baea6a6c7c4c2dfeb977efac326af552d87",
        )),
        value: Wei::new_u64(0x0186a0),
        data: vec![0],
        access_list: vec![
            AccessTuple {
                address: test_utils::address_from_hex("0x095e7baea6a6c7c4c2dfeb977efac326af552d87")
                    .raw(),
                storage_keys: vec![H256::zero(), one()],
            },
            AccessTuple {
                address: test_utils::address_from_hex("0x195e7baea6a6c7c4c2dfeb977efac326af552d87")
                    .raw(),
                storage_keys: vec![H256::zero()],
            },
        ],
    };

    let signed_tx = test_utils::sign_access_list_transaction(transaction, &secret_key);
    let bytes: Vec<u8> = iter::once(eip_2930::TYPE_BYTE)
        .chain(rlp::encode(&signed_tx).into_iter())
        .collect();
    let expected_bytes = hex::decode("01f8f901800a83061a8094095e7baea6a6c7c4c2dfeb977efac326af552d87830186a000f893f85994095e7baea6a6c7c4c2dfeb977efac326af552d87f842a00000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001f794195e7baea6a6c7c4c2dfeb977efac326af552d87e1a0000000000000000000000000000000000000000000000000000000000000000080a011c97e0bb8a356fe4f49b37863d059c6fe8cd3214a6ac06a8387a2f6f0b75f60a0212368a1097da30806edfd13d9c35662e1baee939235eb25de867980bd0eda26").unwrap();

    assert_eq!(bytes, expected_bytes);

    let decoded_tx = match EthTransactionKind::try_from(expected_bytes.as_slice()) {
        Ok(EthTransactionKind::Eip2930(tx)) => tx,
        Ok(_) => panic!("Unexpected transaction type"),
        Err(_) => panic!("Transaction parsing failed"),
    };

    assert_eq!(signed_tx, decoded_tx);

    assert_eq!(
        signed_tx.sender().unwrap(),
        test_utils::address_from_secret_key(&secret_key)
    )
}

fn one() -> H256 {
    let mut x = [0u8; 32];
    x[31] = 1;
    H256(x)
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/account_id_precompiles.rs ---
use crate::test_utils::{self, standalone};
use aurora_engine::parameters::SubmitResult;

#[test]
fn test_account_id_precompiles() {
    let mut signer = test_utils::Signer::random();
    let mut runner = test_utils::deploy_evm();
    let mut standalone = standalone::StandaloneRunner::default();

    standalone.init_evm();
    runner.standalone_runner = Some(standalone);

    let constructor = test_utils::solidity::ContractConstructor::compile_from_source(
        "src/tests/res",
        "target/solidity_build",
        "AccountIds.sol",
        "AccountIds",
    );

    // deploy contract
    let nonce = signer.use_nonce();
    let contract = runner.deploy_contract(
        &signer.secret_key,
        |c| c.deploy_without_constructor(nonce.into()),
        constructor,
    );

    // check current_account_id is correct
    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            contract.call_method_without_args("currentAccountId", nonce)
        })
        .unwrap();
    assert_eq!(unwrap_ethabi_string(&result), "aurora");

    // check predecessor_account_id is correct
    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            contract.call_method_without_args("predecessorAccountId", nonce)
        })
        .unwrap();
    assert_eq!(unwrap_ethabi_string(&result), "some-account.near");

    // confirm the precompile works in view calls too
    let tx = contract.call_method_without_args("predecessorAccountId", 0.into());
    let sender = test_utils::address_from_secret_key(&signer.secret_key);
    let result = runner
        .view_call(test_utils::as_view_call(tx, sender))
        .unwrap();
    assert!(result.is_ok());

    // double check the case where account_id is the full 64 bytes
    let account_id = "abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789";
    assert_eq!(account_id.len(), 64);
    runner.standalone_runner.as_mut().unwrap().env.block_height += 1000;
    runner
        .standalone_runner
        .as_mut()
        .unwrap()
        .env
        .predecessor_account_id = account_id.parse().unwrap();
    let nonce = signer.use_nonce();
    let tx = contract.call_method_without_args("predecessorAccountId", nonce.into());
    let result = runner
        .standalone_runner
        .as_mut()
        .unwrap()
        .submit_transaction(&signer.secret_key, tx)
        .unwrap();
    assert_eq!(unwrap_ethabi_string(&result), account_id);
}

fn unwrap_ethabi_string(result: &SubmitResult) -> String {
    let bytes = test_utils::unwrap_success_slice(result);
    let mut tokens = ethabi::decode(&[ethabi::ParamType::String], bytes).unwrap();
    tokens.pop().unwrap().into_string().unwrap()
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/contract_call.rs ---
use crate::prelude::{parameters::SubmitResult, vec, Address, Wei, H256, U256};
use crate::test_utils::{origin, AuroraRunner, Signer};

use crate::test_utils;
use crate::test_utils::exit_precompile::{Tester, TesterConstructor, DEST_ACCOUNT, DEST_ADDRESS};

fn setup_test() -> (AuroraRunner, Signer, Address, Tester) {
    let mut runner = AuroraRunner::new();
    let token = runner.deploy_erc20_token("tt.testnet");
    let mut signer = test_utils::Signer::random();
    runner.create_address(
        test_utils::address_from_secret_key(&signer.secret_key),
        Wei::from_eth(1.into()).unwrap(),
        U256::zero(),
    );

    let tester_ctr = TesterConstructor::load();
    let nonce = signer.use_nonce();

    let tester: Tester = runner
        .deploy_contract(
            &signer.secret_key,
            |ctr| ctr.deploy(nonce, token),
            tester_ctr,
        )
        .into();

    runner.mint(token, tester.contract.address, 1_000_000_000, origin());

    (runner, signer, token, tester)
}

#[test]
fn hello_world_solidity() {
    let (mut runner, mut signer, _token, tester) = setup_test();

    let name = "AuroraG".to_string();
    let expected = format!("Hello {}!", name);

    let result = tester.hello_world(&mut runner, &mut signer, name);
    assert_eq!(expected, result);
}

#[test]
fn withdraw() {
    let (mut runner, mut signer, token, tester) = setup_test();

    let test_data = vec![
        (true, "call_contract tt.testnet.ft_transfer"),
        (false, "call_contract tt.testnet.withdraw"),
    ];

    for (is_to_near, expected) in test_data {
        let withdraw_result = tester
            .withdraw(&mut runner, &mut signer, is_to_near)
            .unwrap();

        // parse exit events
        let schema = if is_to_near {
            aurora_engine_precompiles::native::events::exit_to_near_schema()
        } else {
            aurora_engine_precompiles::native::events::exit_to_eth_schema()
        };
        let exit_events = parse_exit_events(withdraw_result, &schema);

        // One exit event
        assert_eq!(exit_events.len(), 1);

        let dest = if is_to_near {
            // transferred to "target.aurora" (defined in Tester.sol)
            let dest = "target.aurora";
            // need to hash it since it is an indexed value in the log
            let dest = aurora_engine_sdk::keccak(&ethabi::encode(&[ethabi::Token::String(
                dest.to_string(),
            )]));
            ethabi::LogParam {
                name: "dest".to_string(),
                value: ethabi::Token::FixedBytes(dest.as_bytes().to_vec()),
            }
        } else {
            // transferred to 0xE0f5206BBD039e7b0592d8918820024e2a7437b9 (defined in Tester.sol)
            let address = hex::decode("E0f5206BBD039e7b0592d8918820024e2a7437b9").unwrap();
            let address = Address::try_from_slice(&address).unwrap();
            ethabi::LogParam {
                name: "dest".to_string(),
                value: ethabi::Token::Address(address.raw()),
            }
        };
        let expected_event = vec![
            ethabi::LogParam {
                name: "sender".to_string(),
                value: ethabi::Token::Address(token.raw()),
            },
            ethabi::LogParam {
                name: "erc20_address".to_string(),
                value: ethabi::Token::Address(token.raw()),
            },
            dest,
            ethabi::LogParam {
                name: "amount".to_string(),
                value: ethabi::Token::Uint(1.into()),
            },
        ];
        assert_eq!(&expected_event, &exit_events[0].params);

        // One promise is scheduled
        assert!(runner.previous_logs.contains(&expected.to_string()));
    }
}

#[test]
fn withdraw_and_fail() {
    let (mut runner, mut signer, _token, tester) = setup_test();

    let test_data = vec![
        (true, "call_contract tt.testnet.ft_transfer"),
        (false, "call_contract tt.testnet.withdraw"),
    ];

    for (flag, not_expected) in test_data {
        assert!(tester
            .withdraw_and_fail(&mut runner, &mut signer, flag)
            .is_err());

        // No promise is scheduled
        assert!(!runner.previous_logs.contains(&not_expected.to_string()));
    }
}

#[test]
fn try_withdraw_and_avoid_fail() {
    let (mut runner, mut signer, _token, tester) = setup_test();

    let test_data = vec![
        (true, "call_contract tt.testnet.ft_transfer"),
        (false, "call_contract tt.testnet.withdraw"),
    ];

    for (flag, not_expected) in test_data {
        assert!(tester
            .try_withdraw_and_avoid_fail(&mut runner, &mut signer, flag)
            .is_ok());

        // No promise is scheduled
        assert!(!runner.previous_logs.contains(&not_expected.to_string()));
    }
}

#[test]
fn try_withdraw_and_avoid_fail_and_succeed() {
    let (mut runner, mut signer, _token, tester) = setup_test();

    let test_data = vec![
        (true, "call_contract tt.testnet.ft_transfer"),
        (false, "call_contract tt.testnet.withdraw"),
    ];

    for (flag, expected) in test_data {
        println!("{}", flag);
        assert!(tester
            .try_withdraw_and_avoid_fail_and_succeed(&mut runner, &mut signer, flag)
            .is_ok());
        // One promise is scheduled
        println!("{:?} {:?}", runner.previous_logs, expected.to_string());
        assert!(runner.previous_logs.contains(&expected.to_string()));
    }
}

#[test]
fn withdraw_eth() {
    let (mut runner, mut signer, _token, tester) = setup_test();
    let amount = Wei::new_u64(10);

    // exit to NEAR
    let result = tester
        .withdraw_eth(&mut runner, &mut signer, true, amount)
        .unwrap();
    let dest = aurora_engine_sdk::keccak(&ethabi::encode(&[ethabi::Token::String(
        DEST_ACCOUNT.to_string(),
    )]));
    let schema = aurora_engine_precompiles::native::events::exit_to_near_schema();
    let mut expected_event = vec![
        ethabi::LogParam {
            name: "sender".to_string(),
            value: ethabi::Token::Address(tester.contract.address.raw()),
        },
        ethabi::LogParam {
            name: "erc20_address".to_string(),
            value: ethabi::Token::Address(
                aurora_engine_precompiles::native::events::ETH_ADDRESS.raw(),
            ),
        },
        ethabi::LogParam {
            name: "dest".to_string(),
            value: ethabi::Token::FixedBytes(dest.as_bytes().to_vec()),
        },
        ethabi::LogParam {
            name: "amount".to_string(),
            value: ethabi::Token::Uint(amount.raw()),
        },
    ];
    let exit_events = parse_exit_events(result, &schema);

    assert!(exit_events.len() == 1);
    assert_eq!(&expected_event, &exit_events[0].params);

    // exit to ethereum
    let amount = Wei::new_u64(42);
    let result = tester
        .withdraw_eth(&mut runner, &mut signer, false, amount)
        .unwrap();
    expected_event[2] = ethabi::LogParam {
        name: "dest".to_string(),
        value: ethabi::Token::Address(DEST_ADDRESS.raw()),
    };
    expected_event[3] = ethabi::LogParam {
        name: "amount".to_string(),
        value: ethabi::Token::Uint(amount.raw()),
    };
    let schema = aurora_engine_precompiles::native::events::exit_to_eth_schema();
    let exit_events = parse_exit_events(result, &schema);

    assert!(exit_events.len() == 1);
    assert_eq!(&expected_event, &exit_events[0].params);
}

fn parse_exit_events(result: SubmitResult, schema: &ethabi::Event) -> Vec<ethabi::Log> {
    let signature = schema.signature();
    result
        .logs
        .into_iter()
        .filter_map(|log| {
            if log.topics.first().unwrap() != &signature.0 {
                return None;
            }
            Some(
                schema
                    .parse_log(ethabi::RawLog {
                        topics: log.topics.into_iter().map(H256).collect(),
                        data: log.data,
                    })
                    .unwrap(),
            )
        })
        .collect()
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/ecrecover.rs ---
use super::sanity::initialize_transfer;
use crate::prelude::Wei;
use crate::prelude::{Address, U256};
use crate::test_utils::{self, AuroraRunner, Signer};
use aurora_engine_precompiles::Precompile;

const ECRECOVER_ADDRESS: Address = aurora_engine_precompiles::make_address(0, 1);

/// ecrecover tests taken from geth
#[test]
fn test_ecrecover_geth() {
    let (mut runner, mut signer, _) = initialize_transfer();

    let inputs = [
        "a8b53bdf3306a35a7103ab5504a0c9b492295564b6202b1942a84ef300107281000000000000000000000000000000000000000000000000000000000000001b307835653165303366353363653138623737326363623030393366663731663366353366356337356237346463623331613835616138623838393262346538621122334455667788991011121314151617181920212223242526272829303132",
        "18c547e4f7b0f325ad1e56f57e26c745b09a3e503d86e00e5255ff7f715d3d1c000000000000000000000000000000000000000000000000000000000000001c73b1693892219d736caba55bdb67216e485557ea6b6af75f37096c9aa6a5a75feeb940b1d03b21e36b0e47e79769f095fe2ab855bd91e3a38756b7d75a9c4549",
        "18c547e4f7b0f325ad1e56f57e26c745b09a3e503d86e00e5255ff7f715d3d1c100000000000000000000000000000000000000000000000000000000000001c73b1693892219d736caba55bdb67216e485557ea6b6af75f37096c9aa6a5a75feeb940b1d03b21e36b0e47e79769f095fe2ab855bd91e3a38756b7d75a9c4549",
        "18c547e4f7b0f325ad1e56f57e26c745b09a3e503d86e00e5255ff7f715d3d1c000000000000000000000000000000000000001000000000000000000000001c73b1693892219d736caba55bdb67216e485557ea6b6af75f37096c9aa6a5a75feeb940b1d03b21e36b0e47e79769f095fe2ab855bd91e3a38756b7d75a9c4549",
        "18c547e4f7b0f325ad1e56f57e26c745b09a3e503d86e00e5255ff7f715d3d1c000000000000000000000000000000000000001000000000000000000000011c73b1693892219d736caba55bdb67216e485557ea6b6af75f37096c9aa6a5a75feeb940b1d03b21e36b0e47e79769f095fe2ab855bd91e3a38756b7d75a9c4549",
    ];
    let outputs = [
        Vec::new(),
        hex::decode("000000000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b").unwrap(),
        Vec::new(),
        Vec::new(),
        Vec::new(),
    ];

    for (input, output) in inputs.iter().zip(outputs.iter()) {
        check_wasm_ecrecover(
            &mut runner,
            &mut signer,
            hex::decode(input).unwrap(),
            output,
        );
    }
}

/// The ecrecover implementation in both the standalone and wasm contract should be the same.
#[test]
fn test_ecrecover_standalone() {
    let (mut runner, mut signer, _) = initialize_transfer();

    let hash =
        hex::decode("5cc4cee58087de1a2ea481fe9c65c92adc27cff464b7f00a486dc9bf6bb8efb3").unwrap();
    let sig = hex::decode("32573a0b258f251971a4ec35511c018a7e7bf75a5886534b48d12e47263048a2fe6e03543955255e235388b224704555fd036a954d3ee6dd030d9d1fea1830d71c").unwrap();

    let input = construct_input(&hash, &sig);

    let ctx = evm::Context {
        address: Default::default(),
        caller: Default::default(),
        apparent_value: U256::zero(),
    };
    let standalone_result = aurora_engine_precompiles::secp256k1::ECRecover
        .run(&input, None, &ctx, false)
        .unwrap();

    check_wasm_ecrecover(&mut runner, &mut signer, input, &standalone_result.output);
}

fn check_wasm_ecrecover(
    runner: &mut AuroraRunner,
    signer: &mut Signer,
    input: Vec<u8>,
    expected_output: &[u8],
) {
    let wasm_result = runner
        .submit_with_signer(signer, |nonce| {
            aurora_engine_transactions::legacy::TransactionLegacy {
                nonce,
                gas_price: U256::zero(),
                gas_limit: u64::MAX.into(),
                to: Some(ECRECOVER_ADDRESS),
                value: Wei::zero(),
                data: input,
            }
        })
        .unwrap();
    assert_eq!(
        expected_output,
        test_utils::unwrap_success_slice(&wasm_result),
    );
}

fn construct_input(hash: &[u8], sig: &[u8]) -> Vec<u8> {
    let mut buf = [0u8; 128];
    (buf[0..32]).copy_from_slice(hash);
    buf[63] = sig[64];
    (buf[64..128]).copy_from_slice(&sig[0..64]);

    buf.to_vec()
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/eip1559.rs ---
use crate::prelude::transactions::eip_1559::{self, SignedTransaction1559, Transaction1559};
use crate::prelude::transactions::eip_2930::AccessTuple;
use crate::prelude::transactions::EthTransactionKind;
use crate::prelude::Wei;
use crate::prelude::{H256, U256};
use crate::test_utils;
use aurora_engine::parameters::SubmitResult;
use borsh::BorshDeserialize;
use std::convert::TryFrom;
use std::iter;

const SECRET_KEY: &str = "45a915e4d060149eb4365960e6a7a45f334393093061116b197e3240065ff2d8";
const INITIAL_NONCE: u64 = 1;
const INITIAL_BALANCE: Wei = Wei::new_u64(0x0de0b6b3a7640000);

const CONTRACT_ADDRESS: &str = "0xcccccccccccccccccccccccccccccccccccccccc";
const CONTRACT_NONCE: u64 = 1;
const CONTRACT_CODE: &str = "3a6000554860015500";
const CONTRACT_BALANCE: Wei = Wei::new_u64(0x0de0b6b3a7640000);

const EXAMPLE_TX_HEX: &str = "02f8c101010a8207d0833d090094cccccccccccccccccccccccccccccccccccccccc8000f85bf85994ccccccccccccccccccccccccccccccccccccccccf842a00000000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000180a0d671815898b8dd34321adbba4cb6a57baa7017323c26946f3719b00e70c755c2a03528b9efe3be57ea65a933d1e6bbf3b7d0c78830138883c1201e0c641fee6464";

// Test taken from https://github.com/ethereum/tests/blob/develop/GeneralStateTests/stExample/eip1559.json
// TODO(#170): generally support Ethereum tests
#[test]
fn test_eip_1559_tx_encoding_decoding() {
    let secret_key = exmaple_signer().secret_key;
    let transaction = example_transaction();

    let signed_tx = test_utils::sign_eip_1559_transaction(transaction, &secret_key);
    let bytes = encode_tx(&signed_tx);
    let expected_bytes = hex::decode(EXAMPLE_TX_HEX).unwrap();

    assert_eq!(bytes, expected_bytes);

    let decoded_tx = match EthTransactionKind::try_from(expected_bytes.as_slice()) {
        Ok(EthTransactionKind::Eip1559(tx)) => tx,
        Ok(_) => panic!("Unexpected transaction type"),
        Err(_) => panic!("Transaction parsing failed"),
    };

    assert_eq!(signed_tx, decoded_tx);

    assert_eq!(
        signed_tx.sender().unwrap(),
        test_utils::address_from_secret_key(&secret_key)
    )
}

// Test inspired by https://github.com/ethereum/tests/blob/develop/GeneralStateTests/stExample/eip1559.json
// but modified slightly because our BASEFEE is always 0.
#[test]
fn test_eip_1559_example() {
    let mut runner = test_utils::deploy_evm();
    let mut signer = exmaple_signer();
    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);
    let contract_address = test_utils::address_from_hex(CONTRACT_ADDRESS);
    let contract_code = hex::decode(CONTRACT_CODE).unwrap();

    runner.create_address(signer_address, INITIAL_BALANCE, signer.nonce.into());
    runner.create_address_with_code(
        contract_address,
        CONTRACT_BALANCE,
        CONTRACT_NONCE.into(),
        contract_code.clone(),
    );

    // Check initial state
    assert_eq!(runner.get_balance(signer_address), INITIAL_BALANCE);
    assert_eq!(runner.get_nonce(signer_address), signer.nonce.into());
    assert_eq!(runner.get_balance(contract_address), CONTRACT_BALANCE);
    assert_eq!(runner.get_nonce(contract_address), CONTRACT_NONCE.into());
    assert_eq!(runner.get_code(contract_address), contract_code);

    let mut transaction = example_transaction();
    transaction.chain_id = runner.chain_id;
    signer.use_nonce();
    let signed_tx = test_utils::sign_eip_1559_transaction(transaction, &signer.secret_key);

    let sender = "relay.aurora";
    let (maybe_outcome, maybe_err) = runner.call(test_utils::SUBMIT, sender, encode_tx(&signed_tx));
    assert!(maybe_err.is_none());
    let result =
        SubmitResult::try_from_slice(&maybe_outcome.unwrap().return_data.as_value().unwrap())
            .unwrap();
    assert_eq!(result.gas_used, 0xb8d2);

    // Check post state:
    // signer spent some ETH on gas fees and incremented nonce for submitting transaction
    assert_eq!(
        runner.get_balance(signer_address),
        Wei::new_u64(0x0de0b6b3a75cc7cc)
    );
    assert_eq!(runner.get_nonce(signer_address), signer.nonce.into());
    // Contract balance, code, nonce all unchanged, but storage was written
    assert_eq!(runner.get_balance(contract_address), CONTRACT_BALANCE);
    assert_eq!(runner.get_nonce(contract_address), CONTRACT_NONCE.into());
    assert_eq!(runner.get_code(contract_address), contract_code);
    assert_eq!(
        runner.get_storage(contract_address, H256::zero()),
        h256_from_hex("000000000000000000000000000000000000000000000000000000000000000a")
    );
    assert_eq!(runner.get_storage(contract_address, one()), H256::zero());
    // Gas fees were awarded to the address derived from sending account
    let coinbase = aurora_engine_sdk::types::near_account_to_evm_address(sender.as_bytes());
    assert_eq!(runner.get_balance(coinbase), Wei::new_u64(0x73834));
}

fn encode_tx(signed_tx: &SignedTransaction1559) -> Vec<u8> {
    iter::once(eip_1559::TYPE_BYTE)
        .chain(rlp::encode(signed_tx).into_iter())
        .collect()
}

fn exmaple_signer() -> test_utils::Signer {
    let secret_key =
        libsecp256k1::SecretKey::parse_slice(&hex::decode(SECRET_KEY).unwrap()).unwrap();

    test_utils::Signer {
        nonce: INITIAL_NONCE,
        secret_key,
    }
}

fn example_transaction() -> Transaction1559 {
    Transaction1559 {
        chain_id: 1,
        nonce: U256::from(INITIAL_NONCE),
        gas_limit: U256::from(0x3d0900),
        max_fee_per_gas: U256::from(0x07d0),
        max_priority_fee_per_gas: U256::from(0x0a),
        to: Some(test_utils::address_from_hex(CONTRACT_ADDRESS)),
        value: Wei::zero(),
        data: vec![0],
        access_list: vec![AccessTuple {
            address: test_utils::address_from_hex(CONTRACT_ADDRESS).raw(),
            storage_keys: vec![H256::zero(), one()],
        }],
    }
}

fn h256_from_hex(hex: &str) -> H256 {
    let bytes = hex::decode(hex).unwrap();
    let mut result = [0u8; 32];
    result.copy_from_slice(&bytes);
    H256(result)
}

fn one() -> H256 {
    let mut x = [0u8; 32];
    x[31] = 1;
    H256(x)
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/erc20.rs ---
use crate::prelude::Wei;
use crate::prelude::{Address, U256};
use crate::test_utils::{
    self,
    erc20::{ERC20Constructor, ERC20},
    Signer,
};
use aurora_engine::parameters::TransactionStatus;
use aurora_engine_sdk as sdk;
use bstr::ByteSlice;
use libsecp256k1::SecretKey;

const INITIAL_BALANCE: u64 = 1_000_000;
const INITIAL_NONCE: u64 = 0;
const TRANSFER_AMOUNT: u64 = 67;

#[test]
fn erc20_mint() {
    let (mut runner, mut source_account, dest_address, contract) = initialize_erc20();

    // Validate pre-state
    assert_eq!(
        U256::zero(),
        get_address_erc20_balance(&mut runner, &source_account, dest_address, &contract)
    );

    // Do mint transaction
    let mint_amount: u64 = 10;
    let outcome = runner.submit_with_signer(&mut source_account, |nonce| {
        contract.mint(dest_address, mint_amount.into(), nonce)
    });
    assert!(outcome.is_ok());

    // Validate post-state
    assert_eq!(
        U256::from(mint_amount),
        get_address_erc20_balance(&mut runner, &source_account, dest_address, &contract)
    );
}

#[test]
fn erc20_mint_out_of_gas() {
    let (mut runner, mut source_account, dest_address, contract) = initialize_erc20();

    // Validate pre-state
    assert_eq!(
        U256::zero(),
        get_address_erc20_balance(&mut runner, &source_account, dest_address, &contract)
    );

    // Try mint transaction
    let mint_amount: u64 = rand::random();
    let nonce = source_account.use_nonce();
    let mut mint_tx = contract.mint(dest_address, mint_amount.into(), nonce.into());

    // not enough gas to cover intrinsic cost
    let intrinsic_gas = test_utils::erc20::legacy_into_normalized_tx(mint_tx.clone())
        .intrinsic_gas(&evm::Config::istanbul())
        .unwrap();
    mint_tx.gas_limit = (intrinsic_gas - 1).into();
    let outcome = runner.submit_transaction(&source_account.secret_key, mint_tx.clone());
    let error = outcome.unwrap_err();
    let error_message = format!("{:?}", error);
    assert!(error_message.contains("ERR_INTRINSIC_GAS"));

    // not enough gas to complete transaction
    const GAS_LIMIT: u64 = 67_000;
    const GAS_PRICE: u64 = 10;
    mint_tx.gas_limit = U256::from(GAS_LIMIT);
    mint_tx.gas_price = U256::from(GAS_PRICE); // also set non-zero gas price to check gas still charged.
    let outcome = runner.submit_transaction(&source_account.secret_key, mint_tx);
    let error = outcome.unwrap();
    assert_eq!(error.status, TransactionStatus::OutOfGas);

    // Validate post-state

    test_utils::validate_address_balance_and_nonce(
        &runner,
        test_utils::address_from_secret_key(&source_account.secret_key),
        Wei::new_u64(INITIAL_BALANCE - GAS_LIMIT * GAS_PRICE),
        (INITIAL_NONCE + 2).into(),
    );
    test_utils::validate_address_balance_and_nonce(
        &runner,
        sdk::types::near_account_to_evm_address(
            runner.context.predecessor_account_id.as_ref().as_bytes(),
        ),
        Wei::new_u64(GAS_LIMIT * GAS_PRICE),
        U256::zero(),
    );
}

#[test]
fn profile_erc20_get_balance() {
    let (mut runner, mut source_account, _, contract) = initialize_erc20();
    let source_address = test_utils::address_from_secret_key(&source_account.secret_key);

    let outcome = runner.submit_with_signer(&mut source_account, |nonce| {
        contract.mint(source_address, INITIAL_BALANCE.into(), nonce)
    });
    assert!(outcome.is_ok());

    let balance_tx = contract.balance_of(source_address, U256::zero());
    let (result, profile) =
        runner.profiled_view_call(test_utils::as_view_call(balance_tx, source_address));
    assert!(result.is_ok());

    // call costs less than 2 Tgas
    test_utils::assert_gas_bound(profile.all_gas(), 2);
    // at least 70% of the cost is spent on wasm computation (as opposed to host functions)
    let wasm_fraction = (100 * profile.wasm_gas()) / profile.all_gas();
    assert!(
        (20..=30).contains(&wasm_fraction),
        "{}% is not between 20% and 30%",
        wasm_fraction
    );
}

#[test]
fn erc20_transfer_success() {
    let (mut runner, mut source_account, dest_address, contract) = initialize_erc20();
    let source_address = test_utils::address_from_secret_key(&source_account.secret_key);

    let outcome = runner.submit_with_signer(&mut source_account, |nonce| {
        contract.mint(source_address, INITIAL_BALANCE.into(), nonce)
    });
    assert!(outcome.is_ok());

    // Validate pre-state
    assert_eq!(
        U256::from(INITIAL_BALANCE),
        get_address_erc20_balance(&mut runner, &source_account, source_address, &contract)
    );
    assert_eq!(
        U256::zero(),
        get_address_erc20_balance(&mut runner, &source_account, dest_address, &contract)
    );

    // Do transfer
    let outcome = runner
        .submit_with_signer(&mut source_account, |nonce| {
            contract.transfer(dest_address, TRANSFER_AMOUNT.into(), nonce)
        })
        .unwrap();
    assert!(outcome.status.is_ok());

    // Validate post-state
    assert_eq!(
        U256::from(INITIAL_BALANCE - TRANSFER_AMOUNT),
        get_address_erc20_balance(&mut runner, &source_account, source_address, &contract)
    );
    assert_eq!(
        U256::from(TRANSFER_AMOUNT),
        get_address_erc20_balance(&mut runner, &source_account, dest_address, &contract)
    );
}

#[test]
fn erc20_transfer_insufficient_balance() {
    let (mut runner, mut source_account, dest_address, contract) = initialize_erc20();
    let source_address = test_utils::address_from_secret_key(&source_account.secret_key);

    let outcome = runner.submit_with_signer(&mut source_account, |nonce| {
        contract.mint(source_address, INITIAL_BALANCE.into(), nonce)
    });
    assert!(outcome.is_ok());

    // Validate pre-state
    assert_eq!(
        U256::from(INITIAL_BALANCE),
        get_address_erc20_balance(&mut runner, &source_account, source_address, &contract)
    );
    assert_eq!(
        U256::zero(),
        get_address_erc20_balance(&mut runner, &source_account, dest_address, &contract)
    );

    // Do transfer
    let outcome = runner
        .submit_with_signer(&mut source_account, |nonce| {
            contract.transfer(dest_address, (2 * INITIAL_BALANCE).into(), nonce)
        })
        .unwrap();
    let message = parse_erc20_error_message(&test_utils::unwrap_revert(outcome));
    assert_eq!(&message, "&ERC20: transfer amount exceeds balance");

    // Validate post-state
    assert_eq!(
        U256::from(INITIAL_BALANCE),
        get_address_erc20_balance(&mut runner, &source_account, source_address, &contract)
    );
    assert_eq!(
        U256::zero(),
        get_address_erc20_balance(&mut runner, &source_account, dest_address, &contract)
    );
}

#[test]
fn deploy_erc_20_out_of_gas() {
    let mut runner = test_utils::deploy_evm();
    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    let source_address = test_utils::address_from_secret_key(&source_account);
    runner.create_address(
        source_address,
        Wei::new_u64(INITIAL_BALANCE),
        INITIAL_NONCE.into(),
    );

    let constructor = ERC20Constructor::load();
    let mut deploy_transaction = constructor.deploy("OutOfGas", "OOG", INITIAL_NONCE.into());

    // not enough gas to cover intrinsic cost
    let intrinsic_gas = test_utils::erc20::legacy_into_normalized_tx(deploy_transaction.clone())
        .intrinsic_gas(&evm::Config::istanbul())
        .unwrap();
    deploy_transaction.gas_limit = (intrinsic_gas - 1).into();
    let outcome = runner.submit_transaction(&source_account, deploy_transaction.clone());
    let error = outcome.unwrap_err();
    let error_message = format!("{:?}", error);
    assert!(error_message.contains("ERR_INTRINSIC_GAS"));

    // not enough gas to complete transaction
    deploy_transaction.gas_limit = U256::from(intrinsic_gas + 1);
    let outcome = runner.submit_transaction(&source_account, deploy_transaction);
    let error = outcome.unwrap();
    assert_eq!(error.status, TransactionStatus::OutOfGas);

    // Validate post-state
    test_utils::validate_address_balance_and_nonce(
        &runner,
        test_utils::address_from_secret_key(&source_account),
        Wei::new_u64(INITIAL_BALANCE),
        (INITIAL_NONCE + 1).into(),
    );
}

fn get_address_erc20_balance(
    runner: &mut test_utils::AuroraRunner,
    signer: &Signer,
    address: Address,
    contract: &ERC20,
) -> U256 {
    let balance_tx = contract.balance_of(address, signer.nonce.into());
    let result = runner
        .view_call(test_utils::as_view_call(
            balance_tx,
            test_utils::address_from_secret_key(&signer.secret_key),
        ))
        .unwrap();
    let bytes = match result {
        aurora_engine::parameters::TransactionStatus::Succeed(bytes) => bytes,
        err => panic!("Unexpected view call status {:?}", err),
    };
    U256::from_big_endian(&bytes)
}

fn parse_erc20_error_message(result: &[u8]) -> String {
    let start_index = result.find_char('&').unwrap();
    let end_index = result[start_index..].find_byte(0).unwrap() + start_index;

    String::from_utf8(result[start_index..end_index].to_vec()).unwrap()
}

fn initialize_erc20() -> (test_utils::AuroraRunner, Signer, Address, ERC20) {
    // set up Aurora runner and accounts
    let mut runner = test_utils::deploy_evm();
    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    let source_address = test_utils::address_from_secret_key(&source_account);
    runner.create_address(
        source_address,
        Wei::new_u64(INITIAL_BALANCE),
        INITIAL_NONCE.into(),
    );
    let dest_address = test_utils::address_from_secret_key(&SecretKey::random(&mut rng));

    let mut signer = Signer::new(source_account);
    signer.nonce = INITIAL_NONCE;
    let nonce = signer.use_nonce();
    let constructor = ERC20Constructor::load();
    let contract = ERC20(runner.deploy_contract(
        &signer.secret_key,
        |c| c.deploy("TestToken", "TEST", nonce.into()),
        constructor,
    ));

    (runner, signer, dest_address, contract)
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/erc20_connector.rs ---
use crate::prelude::{Address, Balance, Wei, WeiU256, U256};
use crate::test_utils;
use crate::test_utils::{create_eth_transaction, origin, AuroraRunner};
use aurora_engine::parameters::{CallArgs, FunctionCallArgsV2, SubmitResult};
use aurora_engine_transactions::legacy::LegacyEthSignedTransaction;
use borsh::{BorshDeserialize, BorshSerialize};
use ethabi::Token;
use libsecp256k1::SecretKey;
use near_vm_logic::VMOutcome;
use near_vm_runner::VMError;
use serde_json::json;
use sha3::Digest;

const INITIAL_BALANCE: Wei = Wei::new_u64(1000);
const INITIAL_NONCE: u64 = 0;

pub struct CallResult {
    outcome: Option<VMOutcome>,
    error: Option<VMError>,
}

impl CallResult {
    fn check_ok(&self) {
        assert!(self.error.is_none());
    }

    fn value(&self) -> Vec<u8> {
        self.outcome
            .as_ref()
            .unwrap()
            .return_data
            .clone()
            .as_value()
            .unwrap()
    }

    fn submit_result(&self) -> SubmitResult {
        SubmitResult::try_from_slice(self.value().as_slice()).unwrap()
    }
}

fn keccak256(input: &[u8]) -> Vec<u8> {
    sha3::Keccak256::digest(input).to_vec()
}

fn get_selector(str_selector: &str) -> Vec<u8> {
    keccak256(str_selector.as_bytes())[..4].to_vec()
}

fn build_input(str_selector: &str, inputs: &[Token]) -> Vec<u8> {
    let sel = get_selector(str_selector);
    let inputs = ethabi::encode(inputs);
    [sel.as_slice(), inputs.as_slice()].concat().to_vec()
}

fn create_ethereum_address() -> Address {
    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    test_utils::address_from_secret_key(&source_account)
}

pub struct EthereumAddress {
    pub secret_key: SecretKey,
    pub address: Address,
}

impl test_utils::AuroraRunner {
    pub fn new() -> Self {
        test_utils::deploy_evm()
    }

    pub fn make_call(
        &mut self,
        method_name: &str,
        caller_account_id: String,
        input: Vec<u8>,
    ) -> CallResult {
        let (outcome, error) = self.call(method_name, &caller_account_id, input);
        CallResult { outcome, error }
    }

    pub fn make_call_with_signer(
        &mut self,
        method_name: &str,
        caller_account_id: String,
        signer_account_id: String,
        input: Vec<u8>,
    ) -> CallResult {
        let (outcome, error) =
            self.call_with_signer(method_name, &caller_account_id, &signer_account_id, input);
        CallResult { outcome, error }
    }

    pub fn evm_call(&mut self, contract: Address, input: Vec<u8>, origin: String) -> CallResult {
        self.make_call(
            "call",
            origin,
            CallArgs::V2(FunctionCallArgsV2 {
                contract,
                value: WeiU256::default(),
                input,
            })
            .try_to_vec()
            .unwrap(),
        )
    }

    pub fn evm_submit(&mut self, input: LegacyEthSignedTransaction, origin: String) -> CallResult {
        self.make_call("submit", origin, rlp::encode(&input).to_vec())
    }

    pub fn deploy_erc20_token(&mut self, nep141: &str) -> Address {
        let result = self.make_call("deploy_erc20_token", origin(), nep141.try_to_vec().unwrap());

        result.check_ok();

        let raw_address: [u8; 20] = Vec::<u8>::try_from_slice(result.value().as_slice())
            .unwrap()
            .try_into()
            .unwrap();
        Address::try_from_slice(&raw_address).unwrap()
    }

    pub fn create_account(&mut self) -> EthereumAddress {
        let mut rng = rand::thread_rng();
        let source_account = SecretKey::random(&mut rng);
        let source_address = test_utils::address_from_secret_key(&source_account);
        self.create_address(source_address, INITIAL_BALANCE, INITIAL_NONCE.into());
        EthereumAddress {
            secret_key: source_account,
            address: source_address,
        }
    }

    pub fn balance_of(&mut self, token: Address, target: Address, origin: String) -> U256 {
        let input = build_input("balanceOf(address)", &[Token::Address(target.raw())]);
        let result = self.evm_call(token, input, origin);
        result.check_ok();
        let output = test_utils::unwrap_success(result.submit_result());
        U256::from_big_endian(output.as_slice())
    }

    pub fn mint(
        &mut self,
        token: Address,
        target: Address,
        amount: u64,
        origin: String,
    ) -> CallResult {
        let input = build_input(
            "mint(address,uint256)",
            &[
                Token::Address(target.raw()),
                Token::Uint(U256::from(amount)),
            ],
        );
        let result = self.evm_call(token, input, origin);
        result.check_ok();
        result
    }

    #[allow(dead_code)]
    pub fn admin(&mut self, token: Address, origin: String) -> CallResult {
        let input = build_input("admin()", &[]);
        let result = self.evm_call(token, input, origin);
        result.check_ok();
        result
    }

    pub fn transfer_erc20(
        &mut self,
        token: Address,
        sender: SecretKey,
        receiver: Address,
        amount: u64,
        origin: String,
    ) -> CallResult {
        // transfer(address recipient, uint256 amount)
        let input = build_input(
            "transfer(address,uint256)",
            &[
                Token::Address(receiver.raw()),
                Token::Uint(U256::from(amount)),
            ],
        );

        let input = create_eth_transaction(Some(token), Wei::zero(), input, None, &sender);

        let result = self.evm_submit(input, origin); // create_eth_transaction()
        result.check_ok();
        result
    }

    pub fn ft_on_transfer(
        &mut self,
        nep141: String,
        sender_id: String,
        relayer_id: String,
        amount: Balance,
        msg: String,
    ) -> String {
        let res = self.make_call_with_signer(
            "ft_on_transfer",
            nep141,
            relayer_id,
            json!({
                "sender_id": sender_id,
                "amount": amount.to_string(),
                "msg": msg
            })
            .to_string()
            .into_bytes(),
        );
        res.check_ok();
        String::from_utf8(res.value()).unwrap()
    }

    pub fn register_relayer(
        &mut self,
        relayer_account_id: String,
        relayer_address: Address,
    ) -> CallResult {
        self.make_call(
            "register_relayer",
            relayer_account_id,
            relayer_address.try_to_vec().unwrap(),
        )
    }
}

#[test]
fn test_deploy_erc20_token() {
    let mut runner = AuroraRunner::new();
    runner.deploy_erc20_token("tt.testnet");
}

#[test]
fn test_mint() {
    let mut runner = AuroraRunner::new();
    let token = runner.deploy_erc20_token("tt.testnet");
    let address = runner.create_account().address;
    let balance = runner.balance_of(token, address, origin());
    assert_eq!(balance, U256::from(0));
    let amount = 10;
    let _result = runner.mint(token, address, amount, origin());
    let balance = runner.balance_of(token, address, origin());
    assert_eq!(balance, U256::from(amount));
}

#[test]
fn test_mint_not_admin() {
    let mut runner = AuroraRunner::new();
    let token = runner.deploy_erc20_token("tt.testnet");
    let address = runner.create_account().address;
    let balance = runner.balance_of(token, address, origin());
    assert_eq!(balance, U256::from(0));
    let amount = 10;
    runner.mint(token, address, amount, "not_admin".to_string());
    let balance = runner.balance_of(token, address, origin());
    assert_eq!(balance, U256::from(0));
}

#[test]
fn test_ft_on_transfer() {
    let mut runner = AuroraRunner::new();
    // Standalone runner presently does not support ft_on_transfer
    runner.standalone_runner = None;
    let nep141 = "tt.testnet".to_string();
    let alice = "alice".to_string();
    let token = runner.deploy_erc20_token(&nep141);
    let amount = Balance::new(10);
    let recipient = runner.create_account().address;

    let balance = runner.balance_of(token, recipient, origin());
    assert_eq!(balance, U256::from(0));

    let res = runner.ft_on_transfer(nep141, alice.clone(), alice, amount, recipient.encode());
    // Transaction should succeed so return amount is 0
    assert_eq!(res, "\"0\"");

    let balance = runner.balance_of(token, recipient, origin());
    assert_eq!(balance, U256::from(amount.as_u128()));
}

#[test]
fn test_ft_on_transfer_fail() {
    let mut runner = AuroraRunner::new();
    let nep141 = "tt.testnet".to_string();
    let alice = "alice".to_string();
    let amount = Balance::new(10);

    let recipient = runner.create_account().address;

    let res = runner.ft_on_transfer(nep141, alice.clone(), alice, amount, recipient.encode());

    // Transaction should fail so it must return everything
    assert_eq!(res, format!("\"{}\"", amount));
}

#[ignore]
#[test]
fn test_relayer_charge_fee() {
    let mut runner = AuroraRunner::new();
    // Standalone runner presently does not support ft_on_transfer
    runner.standalone_runner = None;
    let amount = Balance::new(10);
    let fee = 51;
    let nep141 = "tt.testnet".to_string();
    let alice = "alice".to_string();
    let token = runner.deploy_erc20_token(&nep141);
    let recipient = runner.create_account().address;

    let recipient_balance = runner.get_balance(recipient);
    assert_eq!(recipient_balance, INITIAL_BALANCE);

    let relayer = create_ethereum_address();
    runner.register_relayer(alice.clone(), relayer);
    let relayer_balance = runner.get_balance(relayer);
    assert_eq!(relayer_balance, Wei::zero());

    let balance = runner.balance_of(token, recipient, origin());
    assert_eq!(balance, U256::from(0));

    let fee_encoded = &mut [0; 32];
    U256::from(fee).to_big_endian(fee_encoded);

    runner.ft_on_transfer(
        nep141,
        alice.clone(),
        alice,
        amount,
        recipient.encode() + &hex::encode(fee_encoded),
    );

    let recipient_balance_end = runner.get_balance(recipient);
    assert_eq!(
        recipient_balance_end,
        Wei::new_u64(INITIAL_BALANCE.raw().as_u64() - fee)
    );
    let relayer_balance = runner.get_balance(relayer);
    assert_eq!(relayer_balance, Wei::new_u64(fee));

    let balance = runner.balance_of(token, recipient, origin());
    assert_eq!(balance, U256::from(amount.as_u128()));
}

#[test]
fn test_transfer_erc20_token() {
    let mut runner = AuroraRunner::new();
    let token = runner.deploy_erc20_token("tt.testnet");
    let peer0 = runner.create_account();
    let peer1 = runner.create_account();

    let to_mint = 51;
    let to_transfer = 43;

    assert_eq!(
        runner.balance_of(token, peer0.address, origin()),
        U256::zero()
    );
    assert_eq!(
        runner.balance_of(token, peer1.address, origin()),
        U256::zero()
    );

    runner.mint(token, peer0.address, to_mint, origin());

    assert_eq!(
        runner.balance_of(token, peer0.address, origin()),
        U256::from(to_mint)
    );

    runner.transfer_erc20(
        token,
        peer0.secret_key,
        peer1.address,
        to_transfer,
        origin(),
    );
    assert_eq!(
        runner.balance_of(token, peer0.address, origin()),
        U256::from(to_mint - to_transfer)
    );

    assert_eq!(
        runner.balance_of(token, peer1.address, origin()),
        U256::from(to_transfer)
    );
}

// Simulation tests for exit to NEAR precompile.
// Note: `AuroraRunner` is not suitable for these tests because
// it does not execute promises; but `near-sdk-sim` does.
pub mod sim_tests {
    use crate::prelude::{Wei, WeiU256, U256};
    use crate::test_utils;
    use crate::test_utils::erc20::{ERC20Constructor, ERC20};
    use crate::test_utils::exit_precompile::TesterConstructor;
    use crate::tests::state_migration::{deploy_evm, AuroraAccount};
    use aurora_engine::parameters::{
        CallArgs, DeployErc20TokenArgs, FunctionCallArgsV2, SubmitResult,
    };
    use aurora_engine_types::types::Address;
    use borsh::{BorshDeserialize, BorshSerialize};
    use near_sdk_sim::UserAccount;
    use serde_json::json;

    const FT_PATH: &str = "src/tests/res/fungible_token.wasm";
    const FT_TOTAL_SUPPLY: u128 = 1_000_000;
    const FT_TRANSFER_AMOUNT: u128 = 300_000;
    const FT_EXIT_AMOUNT: u128 = 100_000;
    const FT_ACCOUNT: &str = "test_token.root";
    const INITIAL_ETH_BALANCE: u64 = 777_777_777;
    const ETH_EXIT_AMOUNT: u64 = 111_111_111;

    #[test]
    fn test_ghsa_5c82_x4m4_hcj6_exploit() {
        let TestExitToNearEthContext {
            mut signer,
            signer_address,
            chain_id,
            tester_address: _,
            aurora,
        } = test_exit_to_near_eth_common();

        let constructor = test_utils::solidity::ContractConstructor::force_compile(
            "src/tests/res",
            "target/solidity_build",
            "exploit.sol",
            "Exploit",
        );
        let nonce = signer.use_nonce().into();
        let deploy_tx = constructor.deploy_without_constructor(nonce);
        let signed_tx = test_utils::sign_transaction(deploy_tx, Some(chain_id), &signer.secret_key);
        let deploy_result = aurora.call("submit", &rlp::encode(&signed_tx));
        let contract_address = match &deploy_result.status() {
            near_sdk_sim::transaction::ExecutionStatus::SuccessValue(bytes) => {
                let submit_result = SubmitResult::try_from_slice(bytes).unwrap();
                Address::try_from_slice(test_utils::unwrap_success_slice(&submit_result)).unwrap()
            }
            _ => panic!("Unknown result: {:?}", deploy_result),
        };
        let contract = constructor.deployed_at(contract_address);

        let nonce = signer.use_nonce().into();
        let hacker_account = "hacker.near";
        let hacker_account_bytes = hacker_account.as_bytes().to_vec();
        let mut exploit_tx = contract.call_method_with_args(
            "exploit",
            &[ethabi::Token::Bytes(hacker_account_bytes)],
            nonce,
        );
        exploit_tx.value = Wei::new_u64(ETH_EXIT_AMOUNT);
        let signed_tx =
            test_utils::sign_transaction(exploit_tx, Some(chain_id), &signer.secret_key);
        aurora
            .call("submit", &rlp::encode(&signed_tx))
            .assert_success();

        // check balances -- Hacker does not steal any funds!
        assert_eq!(
            nep_141_balance_of(
                aurora.contract.account_id.as_str(),
                &aurora.contract,
                &aurora,
            ),
            INITIAL_ETH_BALANCE as u128
        );
        assert_eq!(
            nep_141_balance_of(hacker_account, &aurora.contract, &aurora),
            0
        );
        assert_eq!(
            eth_balance_of(signer_address, &aurora),
            Wei::new_u64(INITIAL_ETH_BALANCE)
        );
    }

    #[test]
    fn test_exit_to_near() {
        // Deploy Aurora; deploy NEP-141; bridge NEP-141 to ERC-20 on Aurora
        let TestExitToNearContext {
            ft_owner,
            ft_owner_address,
            nep_141,
            erc20,
            aurora,
        } = test_exit_to_near_common();

        // Call exit function on ERC-20; observe ERC-20 burned + NEP-141 transferred
        exit_to_near(
            &ft_owner,
            ft_owner.account_id.as_str(),
            FT_EXIT_AMOUNT,
            &erc20,
            &aurora,
        );

        assert_eq!(
            nep_141_balance_of(ft_owner.account_id.as_str(), &nep_141, &aurora),
            FT_TOTAL_SUPPLY - FT_TRANSFER_AMOUNT + FT_EXIT_AMOUNT
        );
        assert_eq!(
            nep_141_balance_of(aurora.contract.account_id.as_str(), &nep_141, &aurora),
            FT_TRANSFER_AMOUNT - FT_EXIT_AMOUNT
        );
        assert_eq!(
            erc20_balance(&erc20, ft_owner_address, &aurora),
            (FT_TRANSFER_AMOUNT - FT_EXIT_AMOUNT).into()
        );
    }

    #[test]
    fn test_exit_to_near_refund() {
        // Deploy Aurora; deploy NEP-141; bridge NEP-141 to ERC-20 on Aurora
        let TestExitToNearContext {
            ft_owner,
            ft_owner_address,
            nep_141,
            erc20,
            aurora,
        } = test_exit_to_near_common();

        // Call exit on ERC-20; ft_transfer promise fails; expect refund on Aurora;
        exit_to_near(
            &ft_owner,
            // The ft_transfer will fail because this account is not registered with the NEP-141
            "unregistered.near",
            FT_EXIT_AMOUNT,
            &erc20,
            &aurora,
        );

        assert_eq!(
            nep_141_balance_of(ft_owner.account_id.as_str(), &nep_141, &aurora),
            FT_TOTAL_SUPPLY - FT_TRANSFER_AMOUNT
        );
        assert_eq!(
            nep_141_balance_of(aurora.contract.account_id.as_str(), &nep_141, &aurora),
            FT_TRANSFER_AMOUNT
        );
        #[cfg(feature = "error_refund")]
        assert_eq!(
            erc20_balance(&erc20, ft_owner_address, &aurora),
            FT_TRANSFER_AMOUNT.into()
        );
        // If the refund feature is not enabled then there is no refund in the EVM
        #[cfg(not(feature = "error_refund"))]
        assert_eq!(
            erc20_balance(&erc20, ft_owner_address, &aurora),
            (FT_TRANSFER_AMOUNT - FT_EXIT_AMOUNT).into()
        );
    }

    #[test]
    fn test_exit_to_near_eth() {
        // Same test as above, but exit ETH instead of a bridged NEP-141

        let TestExitToNearEthContext {
            signer,
            signer_address,
            chain_id,
            tester_address,
            aurora,
        } = test_exit_to_near_eth_common();
        let exit_account_id = "any.near".to_owned();

        // call exit to near
        let input = super::build_input(
            "withdrawEthToNear(bytes)",
            &[ethabi::Token::Bytes(exit_account_id.as_bytes().to_vec())],
        );
        let tx = test_utils::create_eth_transaction(
            Some(tester_address),
            Wei::new_u64(ETH_EXIT_AMOUNT),
            input,
            Some(chain_id),
            &signer.secret_key,
        );
        aurora.call("submit", &rlp::encode(&tx)).assert_success();

        // check balances
        assert_eq!(
            nep_141_balance_of(
                aurora.contract.account_id.as_str(),
                &aurora.contract,
                &aurora,
            ),
            (INITIAL_ETH_BALANCE - ETH_EXIT_AMOUNT) as u128
        );
        assert_eq!(
            nep_141_balance_of(exit_account_id.as_str(), &aurora.contract, &aurora),
            ETH_EXIT_AMOUNT as u128
        );
        assert_eq!(
            eth_balance_of(signer_address, &aurora),
            Wei::new_u64(INITIAL_ETH_BALANCE - ETH_EXIT_AMOUNT)
        );
    }

    #[test]
    fn test_exit_to_near_eth_refund() {
        // Test the case where the ft_transfer promise from the exit call fails;
        // ensure ETH is refunded.

        let TestExitToNearEthContext {
            signer,
            signer_address,
            chain_id,
            tester_address,
            aurora,
        } = test_exit_to_near_eth_common();
        let exit_account_id = "any.near".to_owned();

        // Make the ft_transfer call fail by draining the Aurora account
        let transfer_args = json!({
            "receiver_id": "tmp.near",
            "amount": format!("{:?}", INITIAL_ETH_BALANCE),
            "memo": "null",
        });
        aurora
            .contract
            .call(
                aurora.contract.account_id(),
                "ft_transfer",
                transfer_args.to_string().as_bytes(),
                near_sdk_sim::DEFAULT_GAS,
                1,
            )
            .assert_success();

        // call exit to near
        let input = super::build_input(
            "withdrawEthToNear(bytes)",
            &[ethabi::Token::Bytes(exit_account_id.as_bytes().to_vec())],
        );
        let tx = test_utils::create_eth_transaction(
            Some(tester_address),
            Wei::new_u64(ETH_EXIT_AMOUNT),
            input,
            Some(chain_id),
            &signer.secret_key,
        );
        aurora.call("submit", &rlp::encode(&tx)).assert_success();

        // check balances
        assert_eq!(
            nep_141_balance_of(exit_account_id.as_str(), &aurora.contract, &aurora),
            0
        );
        #[cfg(feature = "error_refund")]
        assert_eq!(
            eth_balance_of(signer_address, &aurora),
            Wei::new_u64(INITIAL_ETH_BALANCE)
        );
        // If the refund feature is not enabled then there is no refund in the EVM
        #[cfg(not(feature = "error_refund"))]
        assert_eq!(
            eth_balance_of(signer_address, &aurora),
            Wei::new_u64(INITIAL_ETH_BALANCE - ETH_EXIT_AMOUNT)
        );
    }

    fn test_exit_to_near_eth_common() -> TestExitToNearEthContext {
        let aurora = deploy_evm();
        let chain_id = test_utils::AuroraRunner::default().chain_id;
        let signer = test_utils::Signer::random();
        let signer_address = test_utils::address_from_secret_key(&signer.secret_key);
        aurora
            .call(
                "mint_account",
                &(signer_address, signer.nonce, INITIAL_ETH_BALANCE)
                    .try_to_vec()
                    .unwrap(),
            )
            .assert_success();

        assert_eq!(
            nep_141_balance_of(
                aurora.contract.account_id.as_str(),
                &aurora.contract,
                &aurora,
            ),
            INITIAL_ETH_BALANCE as u128
        );
        assert_eq!(
            eth_balance_of(signer_address, &aurora),
            Wei::new_u64(INITIAL_ETH_BALANCE)
        );

        // deploy contract with simple exit to near method
        let constructor = TesterConstructor::load();
        let deploy_data = constructor.deploy(0, Address::zero()).data;
        let submit_result: SubmitResult = aurora.call("deploy_code", &deploy_data).unwrap_borsh();
        let tester_address =
            Address::try_from_slice(&test_utils::unwrap_success(submit_result)).unwrap();

        TestExitToNearEthContext {
            signer,
            signer_address,
            chain_id,
            tester_address,
            aurora,
        }
    }

    fn test_exit_to_near_common() -> TestExitToNearContext {
        // 1. deploy Aurora
        let aurora = deploy_evm();

        // 2. Create account
        let ft_owner = aurora.user.create_user(
            "ft_owner.root".parse().unwrap(),
            near_sdk_sim::STORAGE_AMOUNT,
        );
        let ft_owner_address =
            aurora_engine_sdk::types::near_account_to_evm_address(ft_owner.account_id.as_bytes());
        aurora
            .call(
                "mint_account",
                &(ft_owner_address, 0u64, INITIAL_ETH_BALANCE)
                    .try_to_vec()
                    .unwrap(),
            )
            .assert_success();

        // 3. Deploy NEP-141
        let nep_141 = deploy_nep_141(
            FT_ACCOUNT,
            ft_owner.account_id.as_ref(),
            FT_TOTAL_SUPPLY,
            &aurora,
        );

        assert_eq!(
            nep_141_balance_of(ft_owner.account_id.as_str(), &nep_141, &aurora),
            FT_TOTAL_SUPPLY
        );

        // 4. Deploy ERC-20 from NEP-141 and bridge value to Aurora
        let erc20 = deploy_erc20_from_nep_141(&nep_141, &aurora);
        transfer_nep_141_to_erc_20(
            &nep_141,
            &erc20,
            &ft_owner,
            ft_owner_address,
            FT_TRANSFER_AMOUNT,
            &aurora,
        );

        assert_eq!(
            nep_141_balance_of(ft_owner.account_id.as_str(), &nep_141, &aurora),
            FT_TOTAL_SUPPLY - FT_TRANSFER_AMOUNT
        );
        assert_eq!(
            nep_141_balance_of(aurora.contract.account_id.as_str(), &nep_141, &aurora),
            FT_TRANSFER_AMOUNT
        );
        assert_eq!(
            erc20_balance(&erc20, ft_owner_address, &aurora),
            FT_TRANSFER_AMOUNT.into()
        );

        TestExitToNearContext {
            ft_owner,
            ft_owner_address,
            nep_141,
            erc20,
            aurora,
        }
    }

    fn exit_to_near(
        source: &near_sdk_sim::UserAccount,
        dest: &str,
        amount: u128,
        erc20: &ERC20,
        aurora: &AuroraAccount,
    ) {
        let input = super::build_input(
            "withdrawToNear(bytes,uint256)",
            &[
                ethabi::Token::Bytes(dest.as_bytes().to_vec()),
                ethabi::Token::Uint(amount.into()),
            ],
        );
        let call_args = CallArgs::V2(FunctionCallArgsV2 {
            contract: erc20.0.address,
            value: WeiU256::default(),
            input,
        });
        source
            .call(
                aurora.contract.account_id(),
                "call",
                &call_args.try_to_vec().unwrap(),
                near_sdk_sim::DEFAULT_GAS,
                0,
            )
            .assert_success();
    }

    pub(crate) fn transfer_nep_141_to_erc_20(
        nep_141: &near_sdk_sim::UserAccount,
        erc20: &ERC20,
        source: &near_sdk_sim::UserAccount,
        dest: Address,
        amount: u128,
        aurora: &AuroraAccount,
    ) {
        let transfer_args = json!({
            "receiver_id": aurora.contract.account_id.as_str(),
            "amount": format!("{:?}", amount),
            "memo": "null",
        });
        source
            .call(
                nep_141.account_id(),
                "ft_transfer",
                transfer_args.to_string().as_bytes(),
                near_sdk_sim::DEFAULT_GAS,
                1,
            )
            .assert_success();

        let mint_tx = erc20.mint(dest, amount.into(), 0.into());
        let call_args = CallArgs::V2(FunctionCallArgsV2 {
            contract: erc20.0.address,
            value: WeiU256::default(),
            input: mint_tx.data,
        });
        aurora
            .contract
            .call(
                aurora.contract.account_id(),
                "call",
                &call_args.try_to_vec().unwrap(),
                near_sdk_sim::DEFAULT_GAS,
                0,
            )
            .assert_success();
    }

    fn eth_balance_of(address: Address, aurora: &AuroraAccount) -> Wei {
        let result = aurora.call("get_balance", address.as_bytes());

        result.assert_success();
        match result.status() {
            near_sdk_sim::transaction::ExecutionStatus::SuccessValue(bytes) => {
                Wei::new(U256::from_big_endian(&bytes))
            }
            _ => unreachable!(),
        }
    }

    fn erc20_balance(erc20: &ERC20, address: Address, aurora: &AuroraAccount) -> U256 {
        let balance_tx = erc20.balance_of(address, 0.into());
        let call_args = CallArgs::V2(FunctionCallArgsV2 {
            contract: erc20.0.address,
            value: WeiU256::default(),
            input: balance_tx.data,
        });
        let result = aurora.call("call", &call_args.try_to_vec().unwrap());
        let submit_result: SubmitResult = result.unwrap_borsh();
        U256::from_big_endian(&test_utils::unwrap_success(submit_result))
    }

    pub(crate) fn deploy_erc20_from_nep_141(
        nep_141: &near_sdk_sim::UserAccount,
        aurora: &AuroraAccount,
    ) -> ERC20 {
        let args = DeployErc20TokenArgs {
            nep141: nep_141.account_id().as_str().parse().unwrap(),
        };
        let result = aurora.call("deploy_erc20_token", &args.try_to_vec().unwrap());
        let addr_bytes: Vec<u8> = result.unwrap_borsh();
        let address = Address::try_from_slice(&addr_bytes).unwrap();
        let abi = ERC20Constructor::load().0.abi;
        ERC20(crate::test_utils::solidity::DeployedContract { abi, address })
    }

    pub fn nep_141_balance_of(
        account_id: &str,
        nep_141: &near_sdk_sim::UserAccount,
        aurora: &AuroraAccount,
    ) -> u128 {
        aurora
            .user
            .call(
                nep_141.account_id(),
                "ft_balance_of",
                json!({ "account_id": account_id }).to_string().as_bytes(),
                near_sdk_sim::DEFAULT_GAS,
                0,
            )
            .unwrap_json_value()
            .as_str()
            .unwrap()
            .parse()
            .unwrap()
    }

    /// Deploys the standard FT implementation:
    /// https://github.com/near/near-sdk-rs/blob/master/examples/fungible-token/ft/src/lib.rs
    pub fn deploy_nep_141(
        nep_141_account_id: &str,
        token_owner: &str,
        amount: u128,
        aurora: &AuroraAccount,
    ) -> UserAccount {
        let contract_bytes = std::fs::read(FT_PATH).unwrap();

        let contract_account = aurora.user.deploy(
            &contract_bytes,
            nep_141_account_id.parse().unwrap(),
            5 * near_sdk_sim::STORAGE_AMOUNT,
        );

        let init_args = json!({
            "owner_id": token_owner,
            "total_supply": format!("{:?}", amount),
        })
        .to_string();

        aurora
            .user
            .call(
                contract_account.account_id(),
                "new_default_meta",
                init_args.as_bytes(),
                near_sdk_sim::DEFAULT_GAS,
                0,
            )
            .assert_success();

        // Need to register Aurora contract so that it can receive tokens
        let args = json!({
            "account_id": &aurora.contract.account_id,
        })
        .to_string();
        aurora
            .user
            .call(
                contract_account.account_id(),
                "storage_deposit",
                args.as_bytes(),
                near_sdk_sim::DEFAULT_GAS,
                near_sdk_sim::STORAGE_AMOUNT,
            )
            .assert_success();

        contract_account
    }

    struct TestExitToNearContext {
        ft_owner: near_sdk_sim::UserAccount,
        ft_owner_address: Address,
        nep_141: near_sdk_sim::UserAccount,
        erc20: ERC20,
        aurora: AuroraAccount,
    }

    struct TestExitToNearEthContext {
        signer: test_utils::Signer,
        signer_address: Address,
        chain_id: u64,
        tester_address: Address,
        aurora: AuroraAccount,
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/eth_connector.rs ---
use crate::prelude::Address;
use crate::prelude::WithdrawCallArgs;
use crate::test_utils::str_to_account_id;
use aurora_engine::admin_controlled::{PausedMask, ERR_PAUSED};
use aurora_engine::connector::{
    ERR_NOT_ENOUGH_BALANCE_FOR_FEE, PAUSE_DEPOSIT, PAUSE_WITHDRAW, UNPAUSE_ALL,
};
use aurora_engine::fungible_token::FungibleTokenMetadata;
use aurora_engine::parameters::{
    InitCallArgs, NewCallArgs, RegisterRelayerCallArgs, WithdrawResult,
};
use aurora_engine_types::types::{Fee, NEP141Wei};
use borsh::{BorshDeserialize, BorshSerialize};
use byte_slice_cast::AsByteSlice;
use ethabi::ethereum_types::U256;
use near_sdk::test_utils::accounts;
use near_sdk_sim::transaction::ExecutionStatus;
use near_sdk_sim::{to_yocto, ExecutionResult, UserAccount, DEFAULT_GAS, STORAGE_AMOUNT};
use serde_json::json;

const CONTRACT_ACC: &str = "eth_connector.root";
const PROOF_DATA_NEAR: &str = r#"{"log_index":0,"log_entry_data":[248,251,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,54,144,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,144,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"receipt_index":0,"receipt_data":[249,2,6,1,130,107,17,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,253,248,251,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,54,144,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,144,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"header_data":[249,2,10,160,177,33,112,26,26,176,12,12,163,2,249,133,245,12,51,201,55,50,148,156,122,67,27,26,101,178,36,153,54,100,53,137,160,29,204,77,232,222,199,93,122,171,133,181,103,182,204,212,26,211,18,69,27,148,138,116,19,240,161,66,253,64,212,147,71,148,124,28,230,160,8,239,64,193,62,78,177,68,166,204,116,240,224,174,172,126,160,197,65,5,202,188,134,5,164,246,19,133,35,57,28,114,241,186,81,123,163,166,161,24,32,157,168,170,13,108,58,61,46,160,6,199,163,13,91,119,225,39,168,255,213,10,107,252,143,246,138,241,108,139,59,35,187,185,162,223,53,108,222,73,181,109,160,27,154,49,63,26,170,15,177,97,255,6,204,84,221,234,197,159,172,114,47,148,126,32,199,241,127,101,120,182,51,52,100,185,1,0,0,0,8,0,0,0,0,0,0,0,32,0,0,0,0,0,2,0,8,0,0,0,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,8,32,0,32,0,0,128,0,2,0,0,0,1,0,32,0,0,0,2,0,0,0,0,32,0,0,0,0,0,4,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,128,64,0,0,0,0,1,32,0,0,0,0,0,0,96,32,0,64,0,0,0,128,1,0,0,0,0,1,0,0,0,8,0,0,0,18,32,0,0,64,145,1,8,0,4,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,33,16,0,128,0,0,0,0,0,0,128,0,2,0,0,0,0,0,0,0,0,0,0,2,0,80,0,0,0,0,0,0,0,0,1,128,0,8,0,0,0,0,4,0,0,0,128,2,0,32,0,128,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,16,0,8,0,0,0,0,0,0,0,0,0,0,128,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,132,25,1,227,23,131,157,85,14,131,122,18,0,131,75,91,132,132,96,174,58,224,140,115,112,105,100,101,114,49,48,1,2,8,230,160,188,212,199,183,154,22,223,85,103,215,24,122,240,235,79,129,44,93,184,88,161,218,79,5,44,226,106,100,50,40,163,97,136,155,158,202,3,149,91,200,78],"proof":[[248,113,160,46,156,31,85,241,226,241,13,5,56,73,146,176,67,195,109,6,189,172,104,44,103,44,88,32,15,181,152,136,29,121,252,160,191,48,87,174,71,151,208,114,164,150,51,200,171,90,90,106,46,200,79,77,222,145,95,89,141,137,138,149,67,73,8,87,128,128,128,128,128,128,160,175,9,219,77,174,13,247,133,55,172,92,185,202,7,160,10,204,112,44,133,36,96,30,234,235,134,30,209,205,166,212,255,128,128,128,128,128,128,128,128],[249,2,13,48,185,2,9,249,2,6,1,130,107,17,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,253,248,251,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,12,54,144,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,144,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]}"#;
const PROOF_DATA_ETH: &str = r#"{"log_index":0,"log_entry_data":[249,1,27,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,216,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,200,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0],"receipt_index":0,"receipt_data":[249,2,40,1,130,121,129,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,1,30,249,1,27,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,216,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,200,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0],"header_data":[249,2,23,160,227,118,223,171,207,47,75,187,79,185,74,198,88,140,54,97,161,196,35,70,121,178,154,141,172,91,193,252,86,64,228,227,160,29,204,77,232,222,199,93,122,171,133,181,103,182,204,212,26,211,18,69,27,148,138,116,19,240,161,66,253,64,212,147,71,148,109,150,79,199,61,172,73,162,195,49,105,169,235,252,47,207,92,249,136,136,160,232,74,213,122,210,55,65,43,78,225,85,247,174,212,229,211,176,186,250,113,21,129,16,181,52,172,217,167,148,242,153,45,160,15,198,229,127,6,235,198,161,226,121,173,106,62,0,90,25,158,11,242,44,178,3,137,22,245,126,227,91,74,156,24,115,160,65,253,74,43,97,155,196,93,59,43,202,12,155,49,115,95,124,247,230,15,1,171,150,10,56,115,247,86,81,8,39,11,185,1,0,128,32,9,2,0,0,0,0,0,0,32,16,128,32,0,0,128,2,0,0,64,51,0,0,0,129,0,32,66,32,0,14,0,144,0,0,0,2,13,34,0,128,64,200,128,4,32,16,0,64,0,0,34,0,32,0,40,0,8,0,0,32,176,0,196,1,0,0,10,1,16,8,16,0,0,72,48,0,0,36,0,17,4,128,10,68,0,16,0,1,32,0,128,0,32,0,12,64,162,8,98,2,0,32,0,0,16,136,1,16,40,0,0,0,0,4,0,0,44,32,0,0,192,49,0,8,12,64,96,129,0,2,0,0,128,0,12,64,10,8,1,132,0,32,0,1,4,33,0,4,128,140,128,0,2,66,0,0,192,0,2,16,2,0,0,0,32,16,0,0,64,0,242,4,0,0,0,0,0,0,4,128,0,32,0,14,194,0,16,10,64,32,0,0,0,2,16,96,16,129,0,16,32,32,128,128,32,0,2,68,0,32,1,8,64,16,32,2,5,2,68,0,32,0,2,16,1,0,0,16,2,0,0,16,2,0,0,0,128,0,16,0,36,128,32,0,4,64,16,0,40,16,0,17,0,16,132,25,207,98,158,131,157,85,88,131,122,17,225,131,121,11,191,132,96,174,60,127,153,216,131,1,10,1,132,103,101,116,104,134,103,111,49,46,49,54,135,119,105,110,100,111,119,115,160,33,15,129,167,71,37,0,207,110,217,101,107,71,110,48,237,4,83,174,75,131,188,213,179,154,115,243,94,107,52,238,144,136,84,114,37,115,236,166,252,105],"proof":[[248,177,160,211,36,253,39,157,18,180,1,3,139,140,168,65,238,106,111,239,53,121,48,235,96,8,115,106,93,174,165,66,207,49,216,160,172,74,129,163,113,84,7,35,23,12,83,10,253,21,57,198,143,128,73,112,84,222,23,146,164,219,89,23,138,197,111,237,160,52,220,245,245,91,231,95,169,113,225,49,168,40,77,59,232,33,210,4,93,203,94,247,212,15,42,146,32,70,206,193,54,160,6,140,29,61,156,224,194,173,129,74,84,92,11,129,184,212,37,31,23,140,226,87,230,72,30,52,97,66,185,236,139,228,128,128,128,128,160,190,114,105,101,139,216,178,42,238,75,109,119,227,138,206,144,183,82,34,173,26,173,188,231,152,171,56,163,2,179,13,190,128,128,128,128,128,128,128,128],[249,2,47,48,185,2,43,249,2,40,1,130,121,129,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,1,30,249,1,27,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,39,216,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,200,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0]]}"#;
const DEPOSITED_RECIPIENT: &str = "eth_recipient.root";
const PROVER_ACCOUNT: &str = "eth_connector.root";
const CUSTODIAN_ADDRESS: &str = "096DE9C2B8A5B8c22cEe3289B101f6960d68E51E";
const DEPOSITED_AMOUNT: u128 = 800400;
const DEPOSITED_FEE: u128 = 400;
const RECIPIENT_ETH_ADDRESS: &str = "891b2749238b27ff58e951088e55b04de71dc374";
const EVM_CUSTODIAN_ADDRESS: &str = "096DE9C2B8A5B8c22cEe3289B101f6960d68E51E";
const DEPOSITED_EVM_AMOUNT: u128 = 10200;
const DEPOSITED_EVM_FEE: u128 = 200;

#[derive(
    Default, BorshDeserialize, BorshSerialize, Clone, serde::Deserialize, serde::Serialize,
)]
pub struct Proof {
    pub log_index: u64,
    pub log_entry_data: Vec<u8>,
    pub receipt_index: u64,
    pub receipt_data: Vec<u8>,
    pub header_data: Vec<u8>,
    pub proof: Vec<Vec<u8>>,
}

#[derive(BorshDeserialize, Debug)]
pub struct IsUsedProofResult {
    pub is_used_proof: bool,
}

fn init(custodian_address: &str) -> (UserAccount, UserAccount) {
    let master_account = near_sdk_sim::init_simulator(None);
    let contract = init_contract(&master_account, CONTRACT_ACC, custodian_address);
    (master_account, contract)
}

fn init_contract(
    master_account: &UserAccount,
    contract_name: &str,
    custodian_address: &str,
) -> UserAccount {
    let contract_account = master_account.deploy(
        crate::test_utils::AuroraRunner::default().code.code(),
        contract_name.parse().unwrap(),
        to_yocto("1000000"),
    );
    contract_account
        .call(
            contract_name.parse().unwrap(),
            "new",
            &NewCallArgs {
                chain_id: [0u8; 32],
                owner_id: str_to_account_id(master_account.account_id.clone().as_str()),
                bridge_prover_id: str_to_account_id(accounts(0).as_str()),
                upgrade_delay_blocks: 1,
            }
            .try_to_vec()
            .unwrap(),
            DEFAULT_GAS,
            STORAGE_AMOUNT,
        )
        .assert_success();
    contract_account
        .call(
            contract_name.parse().unwrap(),
            "new_eth_connector",
            &InitCallArgs {
                prover_account: str_to_account_id(PROVER_ACCOUNT),
                eth_custodian_address: custodian_address.into(),
                metadata: FungibleTokenMetadata::default(),
            }
            .try_to_vec()
            .unwrap(),
            DEFAULT_GAS,
            0,
        )
        .assert_success();
    contract_account
}

fn validate_eth_address(address: &str) -> Address {
    Address::decode(address).unwrap()
}

fn call_deposit_eth_to_near(
    master_account: &UserAccount,
    contract: &str,
) -> Vec<Option<ExecutionResult>> {
    let proof: Proof = serde_json::from_str(PROOF_DATA_NEAR).unwrap();
    let res = master_account.call(
        contract.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    //println!("{:#?}", res.promise_results());
    // Calculate Gas burnt
    // let total_gas_burnt = res
    //     .promise_results()
    //     .iter()
    //     .fold(0, |s, v| s + v.as_ref().unwrap().gas_burnt());
    // println!("{:#?}", total_gas_burnt);
    res.promise_results()
}

fn call_is_used_proof(account: &UserAccount, contract: &str, proof: &str) -> bool {
    let proof: Proof = serde_json::from_str(proof).unwrap();
    let res = account.view(
        contract.parse().unwrap(),
        "is_used_proof",
        &proof.try_to_vec().unwrap(),
    );
    let result = IsUsedProofResult::try_from_slice(&res.unwrap()).unwrap();
    result.is_used_proof
}

fn assert_proof_was_used(account: &UserAccount, contract: &str, proof: &str) {
    let is_used_proof = call_is_used_proof(account, contract, proof);
    assert!(
        is_used_proof,
        "{}",
        "Expected not to fail because the proof should have been already used",
    );
}

fn assert_proof_was_not_used(account: &UserAccount, contract: &str, proof: &str) {
    let is_used_proof = call_is_used_proof(account, contract, proof);
    assert!(
        !is_used_proof,
        "{}",
        "Expected not to fail and to have an unused proof but it was already used",
    );
}

#[allow(dead_code)]
fn print_logs(logs: &[String]) {
    for l in logs {
        println!("[log] {}", l);
    }
}

fn call_deposit_eth_to_aurora(master_account: &UserAccount, contract: &str) {
    let proof: Proof = serde_json::from_str(PROOF_DATA_ETH).unwrap();
    let res = master_account.call(
        contract.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        10,
    );
    res.assert_success();
}

fn get_eth_on_near_balance(master_account: &UserAccount, acc: &str, contract: &str) -> u128 {
    #[derive(BorshSerialize)]
    pub struct BalanceOfCallArgs {
        pub account_id: String,
    }

    let balance = master_account.view(
        contract.parse().unwrap(),
        "ft_balance_of",
        json!({ "account_id": acc }).to_string().as_bytes(),
    );
    let val_str = String::from_utf8(balance.unwrap()).unwrap();
    let val = &val_str[1..val_str.len() - 1];
    val.parse().unwrap()
}

fn get_eth_balance(master_account: &UserAccount, address: Address, contract: &str) -> u128 {
    #[derive(BorshSerialize, BorshDeserialize)]
    pub struct BalanceOfEthCallArgs {
        pub address: Address,
    }

    let balance = master_account.view(
        contract.parse().unwrap(),
        "ft_balance_of_eth",
        &BalanceOfEthCallArgs { address }.try_to_vec().unwrap(),
    );
    let val_str = String::from_utf8(balance.unwrap()).unwrap();
    let val = &val_str[1..val_str.len() - 1];
    val.parse().unwrap()
}

fn total_supply(master_account: &UserAccount, contract: &str) -> u128 {
    let balance = master_account.view(contract.parse().unwrap(), "ft_total_supply", &[]);
    let val_str = String::from_utf8(balance.unwrap()).unwrap();
    let val = &val_str[1..val_str.len() - 1];
    val.parse().unwrap()
}

fn total_eth_supply_on_near(master_account: &UserAccount, contract: &str) -> u128 {
    let balance = master_account.view(
        contract.parse().unwrap(),
        "ft_total_eth_supply_on_near",
        &[],
    );
    let val_str = String::from_utf8(balance.unwrap()).unwrap();
    let val = &val_str[1..val_str.len() - 1];
    val.parse().unwrap()
}

fn total_eth_supply_on_aurora(master_account: &UserAccount, contract: &str) -> u128 {
    let balance = master_account.view(
        contract.parse().unwrap(),
        "ft_total_eth_supply_on_aurora",
        &[],
    );
    let val_str = String::from_utf8(balance.unwrap()).unwrap();
    let val = &val_str[1..val_str.len() - 1];
    val.parse().unwrap()
}

#[test]
fn test_deposit_eth_to_near_balance_total_supply() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE);

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_near(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_aurora(&master_account, CONTRACT_ACC);
    assert_eq!(balance, 0);
}

#[test]
fn test_deposit_eth_to_aurora_balance_total_supply() {
    let (master_account, contract) = init(EVM_CUSTODIAN_ADDRESS);
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "register_relayer",
        &RegisterRelayerCallArgs {
            address: validate_eth_address(CUSTODIAN_ADDRESS),
        }
        .try_to_vec()
        .unwrap(),
        DEFAULT_GAS,
        0,
    );
    res.assert_success();

    call_deposit_eth_to_aurora(&contract, CONTRACT_ACC);
    assert_proof_was_used(&contract, CONTRACT_ACC, PROOF_DATA_ETH);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(RECIPIENT_ETH_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, DEPOSITED_EVM_AMOUNT - DEPOSITED_EVM_FEE);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(CUSTODIAN_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, DEPOSITED_EVM_FEE);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_EVM_AMOUNT);

    let balance = total_eth_supply_on_near(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_EVM_AMOUNT);

    let balance = total_eth_supply_on_aurora(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_EVM_AMOUNT);
}

#[test]
fn test_withdraw_eth_from_near() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let withdraw_amount = NEP141Wei::new(100);
    let recipient_addr = validate_eth_address(RECIPIENT_ETH_ADDRESS);
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "withdraw",
        &WithdrawCallArgs {
            recipient_address: recipient_addr,
            amount: withdraw_amount,
        }
        .try_to_vec()
        .unwrap(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();
    let data = res.promise_results();
    assert!(data.len() > 1);
    assert!(data[0].is_some());
    match data[1].clone().unwrap().outcome().status {
        ExecutionStatus::SuccessValue(ref v) => {
            let d: WithdrawResult = WithdrawResult::try_from_slice(v).unwrap();
            assert_eq!(d.amount, withdraw_amount);
            assert_eq!(d.recipient_id, recipient_addr);
            let custodian_addr = validate_eth_address(CUSTODIAN_ADDRESS);
            assert_eq!(d.eth_custodian_address, custodian_addr);
        }
        _ => panic!(),
    }

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE - withdraw_amount.as_u128());

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - withdraw_amount.as_u128());
}

#[test]
fn test_ft_transfer() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let transfer_amount = 70;
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer",
        json!({
            "receiver_id": DEPOSITED_RECIPIENT,
            "amount": transfer_amount.to_string(),
            "memo": "transfer memo"
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(
        balance,
        DEPOSITED_AMOUNT - DEPOSITED_FEE + transfer_amount as u128
    );

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE - transfer_amount as u128);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_aurora(&master_account, CONTRACT_ACC);
    assert_eq!(balance, 0);

    let balance = total_eth_supply_on_near(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);
}

#[test]
fn test_ft_transfer_call_eth() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE);

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE);

    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "register_relayer",
        &RegisterRelayerCallArgs {
            address: validate_eth_address(CUSTODIAN_ADDRESS),
        }
        .try_to_vec()
        .unwrap(),
        DEFAULT_GAS,
        0,
    );
    res.assert_success();

    let transfer_amount = 50;
    let fee: u128 = 30;
    let mut msg = U256::from(fee).as_byte_slice().to_vec();
    msg.append(
        &mut validate_eth_address(RECIPIENT_ETH_ADDRESS)
            .as_bytes()
            .to_vec(),
    );

    let message = [CONTRACT_ACC, hex::encode(msg).as_str()].join(":");
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer_call",
        json!({
            "receiver_id": CONTRACT_ACC,
            "amount": transfer_amount.to_string(),
            "msg": message,
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE);

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(RECIPIENT_ETH_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, transfer_amount - fee);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(CUSTODIAN_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, fee);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_near(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_aurora(&master_account, CONTRACT_ACC);
    assert_eq!(balance, transfer_amount);
}

#[test]
fn test_ft_transfer_call_without_message() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    let recipient_account = create_user_account(&master_account);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE);

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE);

    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "register_relayer",
        &RegisterRelayerCallArgs {
            address: validate_eth_address(CUSTODIAN_ADDRESS),
        }
        .try_to_vec()
        .unwrap(),
        DEFAULT_GAS,
        0,
    );
    res.assert_success();

    let transfer_amount = 50;
    // Send to Aurora contract with wrong message should failed
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer_call",
        json!({
            "receiver_id": CONTRACT_ACC,
            "amount": transfer_amount.to_string(),
            "msg": "",
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    match res.outcome().status {
        ExecutionStatus::Failure(_) => {}
        _ => panic!("Expected execution failure"),
    }

    // Assert balances remain unchanged
    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE);
    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE);

    // Sending to random account should not change balances
    let transfer_amount = 22;
    let res = recipient_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer_call",
        json!({
            "receiver_id": "some-test-acc",
            "amount": transfer_amount.to_string(),
            "msg": "",
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();

    // some-test-acc does not implement `ft_on_transfer` therefore the call fails and the transfer is reverted.
    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE);
    let balance = get_eth_on_near_balance(&master_account, "some-test-acc", CONTRACT_ACC);
    assert_eq!(balance, 0);
    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE);

    // Sending to external receiver with empty message should be success
    let dummy_ft_receiver = master_account.deploy(
        &dummy_ft_receiver_bytes(),
        "ft-rec.root".parse().unwrap(),
        near_sdk_sim::STORAGE_AMOUNT,
    );
    let res = recipient_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer_call",
        json!({
            "receiver_id": dummy_ft_receiver.account_id(),
            "amount": transfer_amount.to_string(),
            "msg": "",
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE - transfer_amount);
    let balance = get_eth_on_near_balance(
        &master_account,
        dummy_ft_receiver.account_id().as_ref(),
        CONTRACT_ACC,
    );
    assert_eq!(balance, transfer_amount);
    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(RECIPIENT_ETH_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, 0);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(CUSTODIAN_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, 0);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_near(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_aurora(&master_account, CONTRACT_ACC);
    assert_eq!(balance, 0);
}

#[test]
fn test_deposit_with_0x_prefix() {
    use aurora_engine::deposit_event::TokenMessageData;
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);

    let eth_custodian_address: Address = Address::decode(CUSTODIAN_ADDRESS).unwrap();
    let recipient_address = Address::from_array([10u8; 20]);
    let deposit_amount = 17;
    let recipient_address_encoded = recipient_address.encode();

    // Note the 0x prefix before the deposit address.
    let message = [CONTRACT_ACC, ":", "0x", &recipient_address_encoded].concat();
    let fee: Fee = Fee::new(NEP141Wei::new(0));
    let token_message_data =
        TokenMessageData::parse_event_message_and_prepare_token_message_data(&message, fee)
            .unwrap();

    let deposit_event = aurora_engine::deposit_event::DepositedEvent {
        eth_custodian_address,
        sender: Address::zero(),
        token_message_data,
        amount: NEP141Wei::new(deposit_amount),
        fee,
    };

    let event_schema = ethabi::Event {
        name: aurora_engine::deposit_event::DEPOSITED_EVENT.into(),
        inputs: aurora_engine::deposit_event::DepositedEvent::event_params(),
        anonymous: false,
    };
    let log_entry = aurora_engine::log_entry::LogEntry {
        address: eth_custodian_address.raw(),
        topics: vec![
            event_schema.signature(),
            // the sender is not important
            crate::prelude::H256::zero(),
        ],
        data: ethabi::encode(&[
            ethabi::Token::String(message),
            ethabi::Token::Uint(U256::from(deposit_event.amount.as_u128())),
            ethabi::Token::Uint(U256::from(deposit_event.fee.as_u128())),
        ]),
    };
    let proof = Proof {
        log_index: 1,
        // Only this field matters for the purpose of this test
        log_entry_data: rlp::encode(&log_entry).to_vec(),
        receipt_index: 1,
        receipt_data: Vec::new(),
        header_data: Vec::new(),
        proof: Vec::new(),
    };

    let res = master_account.call(
        contract.account_id(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    res.assert_success();

    let aurora_balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(aurora_balance, deposit_amount);
    let address_balance = get_eth_balance(&master_account, recipient_address, CONTRACT_ACC);
    assert_eq!(address_balance, deposit_amount);
}

fn generate_dummy_proof(message: String, deposit_amount: u128, log_index: u64) -> Proof {
    use aurora_engine::deposit_event::TokenMessageData;

    let eth_custodian_address: Address = Address::decode(CUSTODIAN_ADDRESS).unwrap();

    let fee: Fee = Fee::new(NEP141Wei::new(0));
    let token_message_data =
        TokenMessageData::parse_event_message_and_prepare_token_message_data(&message, fee)
            .unwrap();

    let deposit_event = aurora_engine::deposit_event::DepositedEvent {
        eth_custodian_address,
        sender: Address::zero(),
        token_message_data,
        amount: NEP141Wei::new(deposit_amount),
        fee,
    };

    let event_schema = ethabi::Event {
        name: aurora_engine::deposit_event::DEPOSITED_EVENT.into(),
        inputs: aurora_engine::deposit_event::DepositedEvent::event_params(),
        anonymous: false,
    };
    let log_entry = aurora_engine::log_entry::LogEntry {
        address: eth_custodian_address.raw(),
        topics: vec![
            event_schema.signature(),
            // the sender is not important
            crate::prelude::H256::zero(),
        ],
        data: ethabi::encode(&[
            ethabi::Token::String(message),
            ethabi::Token::Uint(U256::from(deposit_event.amount.as_u128())),
            ethabi::Token::Uint(U256::from(deposit_event.fee.as_u128())),
        ]),
    };

    Proof {
        log_index,
        // Only this field matters for the purpose of this test
        log_entry_data: rlp::encode(&log_entry).to_vec(),
        receipt_index: 1,
        receipt_data: Vec::new(),
        header_data: Vec::new(),
        proof: Vec::new(),
    }
}

#[test]
fn test_deposit_eth_to_near_account() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);

    let deposit_amount = 17;

    let user_account_id = "some_user.root";
    let _user_account = master_account.create_user(
        user_account_id.parse().unwrap(),
        to_yocto("100"), // initial balance
    );
    let proof = generate_dummy_proof(user_account_id.to_string(), deposit_amount, 1);

    let res = master_account.call(
        contract.account_id(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    let promises = res.promise_results();
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        p.assert_success()
    }
    res.assert_success();

    let aurora_balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(aurora_balance, 0);
    let user_account_balance =
        get_eth_on_near_balance(&master_account, user_account_id, CONTRACT_ACC);
    assert_eq!(user_account_balance, deposit_amount);
}

#[test]
fn test_deposit_eth_with_empty_custom_connector_account() {
    // In this, test we make an ETH deposit using the message format for targeting
    // an Aurora address, but use a different NEAR account than the Aurora Engine.
    // The result is that the ETH is correctly minted to the Engine, but then an
    // error occurs when it tries to transfer those funds because the listed NEAR
    // account does not implement `ft_on_transfer`.
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);

    let deposit_amount = 17;

    let user_account_id = "some_user.root";
    let _user_account = master_account.create_user(
        user_account_id.parse().unwrap(),
        to_yocto("100"), // initial balance
    );

    let recipient_address = Address::from_array([10u8; 20]);
    let recipient_address_encoded = recipient_address.encode();
    let message = [user_account_id, ":", "0x", &recipient_address_encoded].concat();
    let proof = generate_dummy_proof(message, deposit_amount, 1);
    let res = master_account.call(
        contract.account_id(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    let promises = res.promise_results();
    res.assert_success();

    let promise = &promises[promises.len() - 5];
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        format!(
            r#"CompilationError(CodeDoesNotExist {{ account_id: AccountId("{}") }}"#,
            user_account_id
        )
        .as_str(),
        "Expected failure in `ft_on_transfer` call, but deposit succeeded",
    );

    let user_account_balance =
        get_eth_on_near_balance(&master_account, user_account_id, CONTRACT_ACC);
    assert_eq!(user_account_balance, 0);
    let aurora_balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(aurora_balance, deposit_amount);
    let address_balance = get_eth_balance(&master_account, recipient_address, CONTRACT_ACC);
    assert_eq!(address_balance, 0);
}

#[test]
fn test_deposit_eth_with_custom_connector_account() {
    // In this test, we make an ETH deposit using the message format for targeting
    // an Aurora address, but use a different NEAR account than the Aurora Engine.
    // Additionally, the target account implements `ft_on_transfer` so that it can
    // receive the ETH and perform some action with it. This is safe because the ETH is
    // minted in the Engine first, then transferred to the target account using
    // `ft_transfer_call`.
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);

    let deposit_amount = 17;

    let user_account_id = "some_user.root";
    let _user_account = master_account.deploy(
        &dummy_ft_receiver_bytes(),
        user_account_id.parse().unwrap(),
        to_yocto("100"), // initial balance
    );

    let recipient_address = Address::from_array([10u8; 20]);
    let recipient_address_encoded = recipient_address.encode();
    let message = [user_account_id, ":", "0x", &recipient_address_encoded].concat();
    let proof = generate_dummy_proof(message, deposit_amount, 1);
    let res = master_account.call(
        contract.account_id(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    let promises = res.promise_results();
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        if p.executor_id().as_str() == user_account_id {
            // The `ft_on_transfer` implementation in the user's account generates this log.
            assert_eq!(
                p.logs().first().map(|s| s.as_str()),
                Some("in 17 tokens from @eth_connector.root ft_on_transfer, msg = some_user.root:00000000000000000000000000000000000000000000000000000000000000000a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a0a"),
            );
        }
        p.assert_success()
    }
    res.assert_success();

    let user_account_balance =
        get_eth_on_near_balance(&master_account, user_account_id, CONTRACT_ACC);
    assert_eq!(user_account_balance, deposit_amount);
    let aurora_balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(aurora_balance, 0);
    let address_balance = get_eth_balance(&master_account, recipient_address, CONTRACT_ACC);
    assert_eq!(address_balance, 0);
}

#[test]
fn test_deposit_with_same_proof() {
    let (_master_account, contract) = init(CUSTODIAN_ADDRESS);

    assert_proof_was_not_used(&contract, CONTRACT_ACC, PROOF_DATA_NEAR);

    let promises = call_deposit_eth_to_near(&contract, CONTRACT_ACC);
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        p.assert_success()
    }

    assert_proof_was_used(&contract, CONTRACT_ACC, PROOF_DATA_NEAR);

    let promises = call_deposit_eth_to_near(&contract, CONTRACT_ACC);
    let promise = &promises[promises.len() - 2];
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        "ERR_PROOF_EXIST",
        "Expected failure as the provided proof already exists, but deposit succeeded",
    );
}

#[test]
fn test_deposit_wrong_custodian_address() {
    let wrong_custodian_address = "0000000000000000000000000000000000000001";
    let (_master_account, contract) = init(wrong_custodian_address);
    let promises = call_deposit_eth_to_near(&contract, CONTRACT_ACC);
    let promise = &promises[promises.len() - 2];
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        "ERR_WRONG_EVENT_ADDRESS",
        "Expected failure as the provided proof originated from wrong EthCustodian contract, but deposit succeeded",
    );

    assert_proof_was_not_used(&contract, CONTRACT_ACC, PROOF_DATA_NEAR);
}

#[test]
fn test_ft_transfer_call_without_relayer() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE);

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE);

    let transfer_amount = 50;
    let fee: u128 = 30;
    let mut msg = U256::from(fee).as_byte_slice().to_vec();
    msg.append(
        &mut validate_eth_address(RECIPIENT_ETH_ADDRESS)
            .as_bytes()
            .to_vec(),
    );
    let relayer_id = "relayer.root";
    let message = [relayer_id, hex::encode(msg).as_str()].join(":");
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer_call",
        json!({
            "receiver_id": CONTRACT_ACC,
            "amount": transfer_amount.to_string(),
            "msg": message,
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE);

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(RECIPIENT_ETH_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, transfer_amount);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(CUSTODIAN_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, 0);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_near(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_aurora(&master_account, CONTRACT_ACC);
    assert_eq!(balance, transfer_amount);
}

#[test]
fn test_ft_transfer_call_fee_greater_than_amount() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let transfer_amount = 10;
    let fee: u128 = transfer_amount + 10;
    let mut msg = fee.to_be_bytes().to_vec();
    msg.append(
        &mut validate_eth_address(RECIPIENT_ETH_ADDRESS)
            .as_bytes()
            .to_vec(),
    );
    let relayer_id = "relayer.root";
    let message = [relayer_id, hex::encode(msg).as_str()].join(":");
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer_call",
        json!({
            "receiver_id": CONTRACT_ACC,
            "amount": transfer_amount.to_string(),
            "msg": message,
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    match res.outcome().clone().status {
        ExecutionStatus::Failure(_) => {}
        _ => panic!(),
    }

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT - DEPOSITED_FEE);

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(RECIPIENT_ETH_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, 0);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(CUSTODIAN_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, 0);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_near(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_aurora(&master_account, CONTRACT_ACC);
    assert_eq!(balance, 0);
}

fn call_deposit_with_proof(
    account: &UserAccount,
    contract: &str,
    proof: &str,
) -> Vec<Option<ExecutionResult>> {
    let proof: Proof = serde_json::from_str(proof).unwrap();
    let res = account.call(
        contract.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    res.promise_results()
}

fn call_set_paused_flags(
    account: &UserAccount,
    contract: &str,
    paused_mask: PausedMask,
) -> ExecutionResult {
    account.call(
        contract.parse().unwrap(),
        "set_paused_flags",
        &paused_mask.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    )
}

fn create_user_account(master_account: &UserAccount) -> UserAccount {
    master_account.create_user(
        "eth_recipient.root".parse().unwrap(),
        to_yocto("100"), // initial balance
    )
}

#[test]
fn test_admin_controlled_only_admin_can_pause() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    let user_account = create_user_account(&master_account);

    // Try to pause from the user - should fail
    let res = call_set_paused_flags(&user_account, CONTRACT_ACC, PAUSE_DEPOSIT);
    let promises = res.promise_results();
    let p = promises[1].clone();
    match p.unwrap().outcome().clone().status {
        ExecutionStatus::Failure(_) => {}
        _ => panic!("Expected failure as only admin can pause, but user successfully paused"),
    }

    // Try to pause from the admin - should succeed
    let res = call_set_paused_flags(&contract, CONTRACT_ACC, PAUSE_DEPOSIT);
    res.assert_success();
}

#[test]
fn test_admin_controlled_admin_can_peform_actions_when_paused() {
    let (_master_account, contract) = init(CUSTODIAN_ADDRESS);

    // 1st deposit call when unpaused - should succeed
    let promises = call_deposit_with_proof(&contract, CONTRACT_ACC, PROOF_DATA_NEAR);
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        p.assert_success()
    }

    let withdraw_amount = NEP141Wei::new(100);
    let recipient_addr = validate_eth_address(RECIPIENT_ETH_ADDRESS);

    // 1st withdraw call when unpaused  - should succeed
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "withdraw",
        &WithdrawCallArgs {
            recipient_address: recipient_addr,
            amount: withdraw_amount,
        }
        .try_to_vec()
        .unwrap(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();
    let promises = res.promise_results();
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        p.assert_success()
    }

    // Pause deposit
    let res = call_set_paused_flags(&contract, CONTRACT_ACC, PAUSE_DEPOSIT);
    res.assert_success();

    // 2nd deposit call when paused, but the admin is calling it - should succeed
    // NB: We can use `PROOF_DATA_ETH` this will be just a different proof but the same deposit
    // method which should be paused
    let promises = call_deposit_with_proof(&contract, CONTRACT_ACC, PROOF_DATA_ETH);
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        p.assert_success()
    }

    // Pause withdraw
    let res = call_set_paused_flags(&contract, CONTRACT_ACC, PAUSE_WITHDRAW);
    res.assert_success();

    // 2nd withdraw call when paused, but the admin is calling it - should succeed
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "withdraw",
        &WithdrawCallArgs {
            recipient_address: recipient_addr,
            amount: withdraw_amount,
        }
        .try_to_vec()
        .unwrap(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();
    let promises = res.promise_results();
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        p.assert_success()
    }
}

#[test]
fn test_deposit_pausability() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    let user_account = create_user_account(&master_account);

    // 1st deposit call - should succeed
    let promises = call_deposit_with_proof(&user_account, CONTRACT_ACC, PROOF_DATA_NEAR);
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        p.assert_success()
    }

    // Pause deposit
    let res = call_set_paused_flags(&contract, CONTRACT_ACC, PAUSE_DEPOSIT);
    res.assert_success();

    // 2nd deposit call - should fail
    // NB: We can use `PROOF_DATA_ETH` this will be just a different proof but the same deposit
    // method which should be paused
    let promises = call_deposit_with_proof(&user_account, CONTRACT_ACC, PROOF_DATA_ETH);
    let num_promises = promises.len();
    let p = promises[num_promises - 2].clone();
    assert_execution_status_failure(
        p.unwrap().outcome().clone().status,
        ERR_PAUSED,
        "Expected failure due to pause, but deposit succeeded",
    );

    // Unpause all
    let res = call_set_paused_flags(&contract, CONTRACT_ACC, UNPAUSE_ALL);
    res.assert_success();

    // 3rd deposit call - should succeed
    let promises = call_deposit_with_proof(&user_account, CONTRACT_ACC, PROOF_DATA_ETH);
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        p.assert_success()
    }
}

#[test]
fn test_withdraw_from_near_pausability() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    let user_account = create_user_account(&master_account);

    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let withdraw_amount = NEP141Wei::new(100);
    let recipient_addr = validate_eth_address(RECIPIENT_ETH_ADDRESS);
    // 1st withdraw - should succeed
    let res = user_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "withdraw",
        &WithdrawCallArgs {
            recipient_address: recipient_addr,
            amount: withdraw_amount,
        }
        .try_to_vec()
        .unwrap(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();
    let promises = res.promise_results();
    assert!(promises.len() > 1);
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        p.assert_success()
    }

    // Pause withdraw
    let res = call_set_paused_flags(&contract, CONTRACT_ACC, PAUSE_WITHDRAW);
    res.assert_success();

    // 2nd withdraw - should fail
    let res = user_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "withdraw",
        &WithdrawCallArgs {
            recipient_address: recipient_addr,
            amount: withdraw_amount,
        }
        .try_to_vec()
        .unwrap(),
        DEFAULT_GAS,
        1,
    );
    let promises = res.promise_results();
    let p = promises[1].clone();
    assert_execution_status_failure(
        p.unwrap().outcome().clone().status,
        ERR_PAUSED,
        "Expected failure due to pause, but withdraw succeeded",
    );

    // Unpause all
    let res = call_set_paused_flags(&contract, CONTRACT_ACC, UNPAUSE_ALL);
    res.assert_success();

    let res = user_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "withdraw",
        &WithdrawCallArgs {
            recipient_address: recipient_addr,
            amount: withdraw_amount,
        }
        .try_to_vec()
        .unwrap(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();
    let promises = res.promise_results();
    assert!(promises.len() > 1);
    for p in promises.iter() {
        assert!(p.is_some());
        let p = p.as_ref().unwrap();
        p.assert_success()
    }
}

#[test]
fn test_get_accounts_counter() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let counter = master_account
        .view(CONTRACT_ACC.parse().unwrap(), "get_accounts_counter", &[])
        .unwrap();
    assert_eq!(u64::try_from_slice(&counter[..]).unwrap(), 2);
}

#[test]
fn test_get_accounts_counter_and_transfer() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let counter = master_account
        .view(CONTRACT_ACC.parse().unwrap(), "get_accounts_counter", &[])
        .unwrap();
    assert_eq!(u64::try_from_slice(&counter[..]).unwrap(), 2);

    let transfer_amount = 70;
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer",
        json!({
            "receiver_id": DEPOSITED_RECIPIENT,
            "amount": transfer_amount.to_string(),
            "memo": "transfer memo"
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    res.assert_success();

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(
        balance,
        DEPOSITED_AMOUNT - DEPOSITED_FEE + transfer_amount as u128
    );

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_FEE - transfer_amount as u128);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let balance = total_eth_supply_on_aurora(&master_account, CONTRACT_ACC);
    assert_eq!(balance, 0);

    let balance = total_eth_supply_on_near(&master_account, CONTRACT_ACC);
    assert_eq!(balance, DEPOSITED_AMOUNT);

    let counter = master_account
        .view(CONTRACT_ACC.parse().unwrap(), "get_accounts_counter", &[])
        .unwrap();
    assert_eq!(u64::try_from_slice(&counter[..]).unwrap(), 2);
}

#[test]
fn test_deposit_to_near_with_zero_fee() {
    let (master_account, contract) = init(CUSTODIAN_ADDRESS);
    let proof_str = r#"{"log_index":0,"log_entry_data":[248,251,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,184,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"receipt_index":0,"receipt_data":[249,2,6,1,130,106,249,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,253,248,251,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,184,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"header_data":[249,2,23,160,7,139,123,21,146,99,81,234,117,153,151,30,67,221,231,90,105,219,121,127,196,224,201,83,178,31,173,155,190,123,227,174,160,29,204,77,232,222,199,93,122,171,133,181,103,182,204,212,26,211,18,69,27,148,138,116,19,240,161,66,253,64,212,147,71,148,109,150,79,199,61,172,73,162,195,49,105,169,235,252,47,207,92,249,136,136,160,227,202,170,144,85,104,169,90,220,93,227,155,76,252,229,223,163,146,127,223,157,121,27,238,116,64,112,216,124,129,107,9,160,158,128,122,7,117,120,186,231,92,224,181,67,43,66,153,79,155,38,238,166,68,1,151,100,134,126,214,86,59,66,174,201,160,235,177,124,164,253,179,174,206,160,196,186,61,51,64,217,35,121,86,229,24,251,162,51,82,72,31,218,240,150,32,157,48,185,1,0,0,0,8,0,0,32,0,0,0,0,0,0,128,0,0,0,2,0,128,0,64,32,0,0,0,0,0,0,64,0,0,10,0,0,0,0,0,0,3,0,0,0,0,64,128,0,0,64,0,0,0,0,0,16,0,0,130,0,1,16,0,32,4,0,0,0,0,0,2,1,0,0,0,0,0,8,0,8,0,0,32,0,4,128,2,0,128,0,0,0,0,0,0,0,0,0,4,32,0,8,2,0,0,0,128,65,0,136,0,0,40,0,0,0,8,0,0,128,0,34,0,4,0,185,2,0,0,4,32,128,0,2,0,0,0,128,0,0,10,0,1,0,1,0,0,0,0,32,1,8,128,0,0,4,0,0,0,128,128,0,70,0,0,0,0,0,0,16,64,0,64,0,34,64,0,0,0,4,0,0,0,0,1,128,0,9,0,0,0,0,0,16,0,0,64,2,0,0,0,132,0,64,32,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,4,0,0,0,32,8,0,16,0,8,0,16,68,0,0,0,16,0,0,0,128,0,64,0,0,128,0,0,0,0,0,0,0,16,0,1,0,16,132,49,181,116,68,131,157,92,101,131,122,18,0,131,101,155,9,132,96,174,110,74,153,216,131,1,10,1,132,103,101,116,104,134,103,111,49,46,49,54,135,119,105,110,100,111,119,115,160,228,82,26,232,236,82,141,6,111,169,92,14,115,254,59,131,192,3,202,209,126,79,140,182,163,12,185,45,210,17,60,38,136,84,114,37,115,236,183,145,213],"proof":[[248,145,160,187,129,186,104,13,250,13,252,114,170,223,247,137,53,113,225,188,217,54,244,108,193,247,236,197,29,0,161,119,76,227,184,160,66,209,234,66,254,223,80,22,246,80,204,38,2,90,115,201,183,79,207,47,192,234,143,221,89,78,36,199,127,9,55,190,160,91,160,251,58,165,255,90,2,105,47,46,220,67,3,52,105,42,182,130,224,19,162,115,159,136,158,218,93,187,148,188,9,128,128,128,128,128,160,181,223,248,223,173,187,103,169,52,204,62,13,90,70,147,236,199,27,201,112,157,4,139,63,188,12,98,117,10,82,85,125,128,128,128,128,128,128,128,128],[249,2,13,48,185,2,9,249,2,6,1,130,106,249,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,253,248,251,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,11,184,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]}"#;
    let proof: Proof = serde_json::from_str(proof_str).unwrap();
    let res = master_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    res.assert_success();

    assert_proof_was_used(&contract, CONTRACT_ACC, proof_str);

    let deposited_amount = 3000;

    let balance = get_eth_on_near_balance(&master_account, DEPOSITED_RECIPIENT, CONTRACT_ACC);
    assert_eq!(balance, deposited_amount);

    let balance = get_eth_on_near_balance(&master_account, CONTRACT_ACC, CONTRACT_ACC);
    assert_eq!(balance, 0);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, deposited_amount);

    let balance = total_eth_supply_on_near(&master_account, CONTRACT_ACC);
    assert_eq!(balance, deposited_amount);

    let balance = total_eth_supply_on_aurora(&master_account, CONTRACT_ACC);
    assert_eq!(balance, 0);
}

#[test]
fn test_deposit_to_aurora_with_zero_fee() {
    let (master_account, contract) = init(EVM_CUSTODIAN_ADDRESS);
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "register_relayer",
        &RegisterRelayerCallArgs {
            address: validate_eth_address(CUSTODIAN_ADDRESS),
        }
        .try_to_vec()
        .unwrap(),
        DEFAULT_GAS,
        0,
    );
    res.assert_success();

    let proof_str = r#"{"log_index":0,"log_entry_data":[249,1,27,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,208,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0],"receipt_index":3,"receipt_data":[249,2,41,1,131,2,246,200,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,1,30,249,1,27,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,208,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0],"header_data":[249,2,23,160,110,48,40,236,52,198,197,25,255,191,199,4,137,3,185,31,202,84,90,80,104,32,176,13,144,141,165,183,36,30,94,138,160,29,204,77,232,222,199,93,122,171,133,181,103,182,204,212,26,211,18,69,27,148,138,116,19,240,161,66,253,64,212,147,71,148,148,156,193,169,167,156,148,249,191,22,225,202,121,212,79,2,197,75,191,164,160,127,26,168,212,111,22,173,213,25,217,187,227,114,86,173,99,166,195,67,16,104,111,200,109,110,147,241,23,71,122,89,215,160,47,120,179,75,110,158,228,18,242,156,38,111,95,25,236,211,158,53,53,62,89,190,2,40,220,41,151,200,127,219,33,219,160,222,177,165,249,98,109,130,37,226,229,165,113,45,12,145,30,16,28,154,86,22,203,218,233,13,246,165,177,61,57,68,83,185,1,0,0,32,8,0,33,0,0,0,64,0,32,0,128,0,0,0,132,0,0,0,64,32,64,0,0,1,0,32,64,0,0,8,0,0,0,0,0,0,137,32,0,0,0,64,128,0,0,16,0,0,0,0,33,64,0,1,0,0,0,0,0,0,0,0,68,0,0,0,2,1,64,0,0,0,0,9,16,0,0,32,0,0,0,128,2,0,0,0,33,0,0,0,128,0,0,0,12,64,32,8,66,2,0,0,64,0,0,8,0,0,40,8,8,0,0,0,0,16,0,0,0,0,64,49,0,0,8,0,96,0,0,18,0,0,0,0,0,64,10,0,1,0,0,32,0,0,0,33,0,0,128,136,10,64,0,64,0,0,192,128,0,0,64,1,0,0,4,0,8,0,64,0,34,0,0,0,0,0,0,0,0,0,0,0,8,8,0,4,0,0,0,32,0,4,0,2,0,0,0,129,4,0,96,16,4,8,0,0,0,0,0,0,1,0,128,16,0,0,2,0,4,0,32,0,8,0,0,0,0,16,0,1,0,0,0,0,64,0,128,0,0,32,36,128,0,0,4,64,0,8,8,16,0,1,4,16,132,50,32,156,229,131,157,92,137,131,122,18,0,131,35,159,183,132,96,174,111,126,153,216,131,1,10,3,132,103,101,116,104,136,103,111,49,46,49,54,46,51,133,108,105,110,117,120,160,59,74,90,253,211,14,166,114,39,213,120,95,221,43,109,173,72,205,160,203,71,44,83,159,36,59,129,84,32,16,254,251,136,49,16,97,244,161,246,244,85],"proof":[[248,113,160,227,103,29,228,16,56,196,146,115,29,122,202,254,140,214,86,189,108,47,197,2,195,50,211,4,126,58,175,71,11,70,78,160,229,239,23,242,100,150,90,169,21,162,252,207,202,244,187,71,172,126,191,33,166,162,45,134,108,114,6,76,78,177,148,140,128,128,128,128,128,128,160,21,91,249,81,132,162,52,236,128,181,5,72,158,228,177,131,87,144,64,194,111,103,180,16,183,103,245,136,125,213,208,76,128,128,128,128,128,128,128,128],[249,1,241,128,160,52,154,34,8,39,210,121,1,151,92,91,225,198,154,204,207,11,204,187,59,223,154,187,102,115,110,193,141,201,198,95,253,160,218,19,188,241,210,48,51,3,76,125,48,152,171,188,45,136,109,71,236,171,242,162,10,34,245,160,191,5,120,9,80,129,160,147,160,142,184,113,171,112,171,131,124,150,117,65,27,207,149,119,136,120,65,7,99,155,114,169,57,91,125,26,117,49,67,160,173,217,104,114,149,170,18,227,251,73,78,11,220,243,240,66,117,32,199,64,138,173,169,43,8,122,39,47,210,54,41,192,160,139,116,124,73,113,242,225,65,167,48,33,13,149,51,152,196,79,93,126,103,116,48,177,25,80,186,34,55,15,116,2,13,160,67,10,207,13,108,228,254,73,175,10,166,107,144,157,150,135,173,179,140,112,129,205,168,132,194,4,191,175,239,50,66,245,160,26,193,195,232,40,106,60,72,133,32,204,205,104,90,20,60,166,16,214,184,115,44,216,62,82,30,141,124,160,72,173,62,160,67,5,174,33,105,28,248,245,48,15,129,153,96,27,97,125,29,194,233,139,228,8,243,221,79,2,151,52,75,30,47,136,160,103,94,192,58,117,224,88,80,21,183,254,178,135,21,78,20,233,250,7,22,243,14,41,56,12,118,206,224,75,42,96,77,160,225,64,237,254,248,145,134,195,166,49,205,129,233,54,142,136,235,242,10,14,175,76,73,131,26,135,102,237,64,23,102,213,160,167,104,45,101,228,93,89,216,167,142,125,0,216,77,167,4,245,156,140,98,117,19,165,25,185,204,84,161,175,153,193,20,160,53,22,192,197,176,225,102,6,251,115,216,238,53,110,254,106,193,134,232,100,173,93,211,71,195,10,192,107,97,190,165,12,160,104,206,244,51,77,131,79,209,64,233,97,35,142,75,42,205,198,120,222,90,199,168,126,235,12,225,30,240,214,56,253,168,160,230,94,127,56,22,169,3,159,236,49,217,88,2,175,168,22,104,177,154,127,106,165,176,238,236,141,83,64,123,28,177,206,160,140,137,2,195,227,9,182,245,76,62,215,174,168,254,15,125,111,241,30,50,110,189,66,58,230,2,252,104,182,247,223,94,128],[249,2,48,32,185,2,44,249,2,41,1,131,2,246,200,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,1,30,249,1,27,148,9,109,233,194,184,165,184,194,44,238,50,137,177,1,246,150,13,104,229,30,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,7,208,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0]]}"#;
    let proof: Proof = serde_json::from_str(proof_str).unwrap();
    let res = master_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    res.assert_success();

    assert_proof_was_used(&contract, CONTRACT_ACC, proof_str);

    let deposited_amount = 2000;

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(RECIPIENT_ETH_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, deposited_amount);

    let balance = get_eth_balance(
        &master_account,
        validate_eth_address(CUSTODIAN_ADDRESS),
        CONTRACT_ACC,
    );
    assert_eq!(balance, 0);

    let balance = total_supply(&master_account, CONTRACT_ACC);
    assert_eq!(balance, deposited_amount);

    let balance = total_eth_supply_on_aurora(&master_account, CONTRACT_ACC);
    assert_eq!(balance, deposited_amount);

    let balance = total_eth_supply_on_near(&master_account, CONTRACT_ACC);
    assert_eq!(balance, deposited_amount);
}

#[test]
fn test_deposit_to_near_amount_less_fee() {
    let custodian_address = "73c8931CA2aD746d97a59A7ABDDa0a9205F7ffF9";
    let (master_account, contract) = init(custodian_address);
    let proof_str = r#"{"log_index":0,"log_entry_data":[248,251,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,150,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,88,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"receipt_index":0,"receipt_data":[249,2,6,1,130,106,251,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,253,248,251,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,150,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,88,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"header_data":[249,2,10,160,139,92,51,142,163,95,21,160,61,29,148,206,54,147,187,96,77,109,244,8,130,155,249,198,206,30,173,216,144,176,252,123,160,29,204,77,232,222,199,93,122,171,133,181,103,182,204,212,26,211,18,69,27,148,138,116,19,240,161,66,253,64,212,147,71,148,124,28,230,160,8,239,64,193,62,78,177,68,166,204,116,240,224,174,172,126,160,218,9,209,192,173,39,133,109,141,57,2,146,184,12,94,217,6,138,173,67,121,185,24,179,133,189,219,40,81,210,73,106,160,219,108,244,199,44,203,84,71,126,74,82,240,203,255,238,20,226,29,239,51,7,19,144,34,156,137,232,159,71,30,164,29,160,209,61,241,33,17,103,192,203,57,156,112,250,18,166,26,237,248,153,226,185,87,220,156,93,249,17,39,190,125,96,247,239,185,1,0,0,0,8,0,0,0,0,0,0,0,0,1,0,0,0,0,0,128,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,0,32,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,64,0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,32,0,0,0,0,8,0,0,2,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,8,0,0,0,0,0,0,40,0,0,0,0,0,0,0,0,0,0,0,0,0,144,4,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,132,91,80,110,139,131,157,118,104,131,122,18,0,131,30,4,87,132,96,175,154,220,140,115,112,105,100,101,114,49,48,1,2,9,64,160,80,163,212,151,183,11,70,219,178,190,167,172,64,187,47,14,29,226,253,132,116,145,81,143,54,249,121,123,193,241,120,249,136,244,120,239,134,243,43,177,139],"proof":[[248,81,160,164,35,68,182,184,52,174,73,6,81,4,92,187,190,187,106,255,124,123,24,244,168,161,247,60,181,75,29,192,175,96,140,128,128,128,128,128,128,128,160,169,157,199,164,106,205,109,88,111,183,255,180,108,15,155,137,126,163,108,44,117,125,138,221,3,188,93,85,146,129,19,139,128,128,128,128,128,128,128,128],[249,2,13,48,185,2,9,249,2,6,1,130,106,251,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,253,248,251,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,150,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,88,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]}"#;
    let proof: Proof = serde_json::from_str(proof_str).unwrap();
    let res = master_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    let promise = &res.promise_results()[res.promise_results().len() - 2];
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        ERR_NOT_ENOUGH_BALANCE_FOR_FEE,
        "Expected failure as the deposited amount is less than fee, but deposit to NEP-141 succeeded",
    );

    assert_proof_was_not_used(&contract, CONTRACT_ACC, proof_str);
}

#[test]
fn test_deposit_to_aurora_amount_less_fee() {
    let custodian_address = "73c8931CA2aD746d97a59A7ABDDa0a9205F7ffF9";
    let (master_account, contract) = init(custodian_address);
    let proof_str = r#"{"log_index":0,"log_entry_data":[249,1,27,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,150,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,132,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0],"receipt_index":0,"receipt_data":[249,2,40,1,130,121,119,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,1,30,249,1,27,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,150,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,132,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0],"header_data":[249,2,10,160,234,97,221,132,104,51,119,219,129,206,197,27,130,197,14,113,167,32,152,214,207,205,156,210,35,213,198,227,116,42,51,224,160,29,204,77,232,222,199,93,122,171,133,181,103,182,204,212,26,211,18,69,27,148,138,116,19,240,161,66,253,64,212,147,71,148,124,28,230,160,8,239,64,193,62,78,177,68,166,204,116,240,224,174,172,126,160,15,150,233,184,181,140,226,81,205,139,229,87,226,149,49,207,117,33,36,83,124,8,75,199,231,48,13,23,189,217,179,12,160,241,37,169,74,233,62,231,112,0,207,95,228,68,240,108,254,57,199,255,130,142,158,161,180,243,50,255,222,77,251,252,126,160,31,111,236,60,142,91,35,119,195,92,158,134,65,138,8,247,98,122,229,21,226,85,38,130,141,139,168,60,83,90,63,244,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,128,0,0,0,0,128,0,0,0,32,0,0,0,0,0,0,64,0,0,10,0,0,0,0,0,0,1,0,0,0,0,64,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,1,0,0,0,0,0,8,0,0,2,0,0,0,4,0,2,0,0,0,0,0,0,0,0,0,0,0,4,0,0,8,2,0,0,0,0,0,0,136,0,4,40,0,0,0,0,0,0,0,0,0,0,0,0,48,0,0,0,0,32,0,0,10,0,0,0,0,0,0,10,0,1,0,0,0,0,0,0,32,0,0,128,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,16,0,0,64,0,34,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,128,2,0,0,0,128,0,1,32,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,4,0,0,0,32,128,0,0,0,0,0,16,0,0,0,0,0,0,0,0,128,0,0,0,0,128,0,0,0,0,0,0,0,16,0,1,0,16,132,91,127,63,197,131,157,118,142,131,122,18,0,131,25,25,181,132,96,175,156,157,140,115,112,105,100,101,114,49,48,1,2,9,64,160,68,227,115,157,18,184,21,217,93,74,196,34,230,228,210,239,61,26,221,245,191,46,44,135,134,2,20,53,95,18,128,54,136,162,198,27,59,153,146,63,16],"proof":[[248,113,160,204,110,241,220,150,206,51,121,104,130,125,127,249,35,9,242,107,45,164,62,147,221,93,116,73,79,49,96,226,92,235,247,160,43,215,154,177,148,177,15,202,141,217,45,114,108,33,74,0,144,126,189,26,78,152,232,105,119,103,203,51,79,45,113,124,128,128,128,128,128,128,160,74,177,164,103,85,250,153,17,105,68,205,207,176,48,89,230,100,35,20,167,34,117,11,115,14,107,128,214,48,17,53,209,128,128,128,128,128,128,128,128],[249,2,47,48,185,2,43,249,2,40,1,130,121,119,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,1,30,249,1,27,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,150,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,3,132,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0]]}"#;
    let proof: Proof = serde_json::from_str(proof_str).unwrap();
    let res = master_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    let promise = &res.promise_results()[res.promise_results().len() - 2];
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        ERR_NOT_ENOUGH_BALANCE_FOR_FEE,
        "Expected failure as the deposited amount is less than fee, but deposit to Aurora succeeded",
    );

    assert_proof_was_not_used(&contract, CONTRACT_ACC, proof_str);
}

#[test]
fn test_deposit_to_near_amount_zero_fee_non_zero() {
    let custodian_address = "73c8931CA2aD746d97a59A7ABDDa0a9205F7ffF9";
    let (master_account, contract) = init(custodian_address);
    let proof_str = r#"{"log_index":0,"log_entry_data":[248,251,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,244,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"receipt_index":0,"receipt_data":[249,2,6,1,130,106,251,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,253,248,251,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,244,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"header_data":[249,2,10,160,47,76,8,45,83,192,115,218,108,188,181,117,148,40,254,44,169,118,92,188,207,7,122,246,133,75,100,184,134,128,91,12,160,29,204,77,232,222,199,93,122,171,133,181,103,182,204,212,26,211,18,69,27,148,138,116,19,240,161,66,253,64,212,147,71,148,124,28,230,160,8,239,64,193,62,78,177,68,166,204,116,240,224,174,172,126,160,225,211,110,129,173,98,101,150,55,116,11,30,26,161,226,8,234,249,90,46,245,112,225,68,76,26,215,135,27,181,140,22,160,229,44,239,5,102,141,42,118,174,163,144,225,90,152,120,60,150,25,144,217,154,234,25,69,35,226,103,149,188,127,81,106,160,177,89,93,76,113,24,117,182,174,52,148,6,239,129,151,18,222,56,245,9,232,80,7,129,118,118,108,72,76,247,238,101,185,1,0,1,4,200,10,0,0,0,0,8,0,32,0,128,3,1,0,0,145,4,33,72,8,0,2,0,128,0,18,64,26,38,0,4,16,8,1,136,65,40,32,0,0,1,72,0,2,0,128,0,64,0,0,48,0,32,0,0,0,0,192,0,100,9,0,12,0,16,0,0,1,2,8,8,0,8,12,128,64,0,192,2,0,0,64,2,68,129,0,128,1,0,0,128,128,68,0,64,64,32,0,67,0,32,0,0,41,20,1,0,16,40,0,16,16,32,0,0,0,128,0,0,0,64,48,4,8,8,0,0,0,0,66,32,64,0,0,48,0,16,8,1,64,0,0,16,32,0,33,32,0,0,128,0,2,2,128,0,0,192,0,2,40,0,0,0,0,0,1,0,67,1,0,131,32,6,8,0,0,8,96,128,0,0,0,0,12,0,0,0,65,2,160,2,64,0,2,4,32,0,128,0,1,34,0,105,0,160,0,32,18,32,16,1,0,0,0,20,0,32,0,20,0,96,128,0,16,0,0,64,16,2,192,1,0,4,32,0,32,130,2,0,0,32,0,0,0,4,64,12,64,0,0,4,0,0,1,132,93,96,3,163,131,157,117,205,131,122,18,0,131,113,87,104,132,96,175,145,182,140,115,112,105,100,101,114,49,48,1,2,9,64,160,179,183,88,73,3,20,234,255,8,238,6,186,173,204,149,149,235,233,232,35,158,194,53,246,218,39,221,246,90,7,34,255,136,176,36,100,161,146,27,98,29],"proof":[[248,177,160,93,101,188,48,5,53,36,126,41,0,92,130,188,117,104,230,178,29,27,194,22,86,212,235,193,20,241,42,157,88,117,205,160,141,83,180,197,22,126,217,34,74,50,114,118,42,157,161,171,8,158,98,92,183,124,137,130,211,1,106,44,222,37,13,32,160,62,131,146,138,69,63,89,98,140,64,187,93,207,160,0,4,134,154,205,47,168,231,136,249,129,230,137,29,3,210,67,173,160,76,91,176,245,81,3,198,111,175,230,185,70,220,111,189,88,15,154,173,107,239,121,185,13,159,197,61,37,231,252,22,200,128,128,128,128,160,13,246,139,212,38,202,103,201,31,80,247,136,186,58,17,52,66,119,115,128,23,123,59,166,177,68,79,182,9,242,60,106,128,128,128,128,128,128,128,128],[249,2,13,48,185,2,9,249,2,6,1,130,106,251,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,253,248,251,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,244,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]}"#;
    let proof: Proof = serde_json::from_str(proof_str).unwrap();
    let res = master_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    let promise = &res.promise_results()[res.promise_results().len() - 2];
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        ERR_NOT_ENOUGH_BALANCE_FOR_FEE,
        "Expected failure as the deposited amount is zero and the fee is not zero, but deposit to NEP-141 succeeded",
    );

    assert_proof_was_not_used(&contract, CONTRACT_ACC, proof_str);
}

#[test]
fn test_deposit_to_aurora_amount_zero_fee_non_zero() {
    let custodian_address = "73c8931CA2aD746d97a59A7ABDDa0a9205F7ffF9";
    let (master_account, contract) = init(custodian_address);
    let proof_str = r#"{"log_index":0,"log_entry_data":[249,1,27,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,174,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0],"receipt_index":1,"receipt_data":[249,2,41,1,131,1,110,54,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,1,30,249,1,27,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,174,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0],"header_data":[249,2,21,160,60,128,9,36,168,69,207,249,164,88,177,15,74,221,137,160,110,246,3,133,209,132,169,179,31,86,142,216,160,11,162,137,160,29,204,77,232,222,199,93,122,171,133,181,103,182,204,212,26,211,18,69,27,148,138,116,19,240,161,66,253,64,212,147,71,148,28,255,226,5,233,121,118,187,157,30,192,6,245,34,35,96,168,147,83,224,160,182,206,231,252,255,115,166,11,152,156,84,169,204,36,0,94,3,17,113,103,104,252,225,161,115,85,74,227,104,249,187,232,160,211,106,68,136,2,141,5,14,201,111,68,218,251,84,103,176,66,10,190,123,58,119,216,141,192,197,222,181,211,87,117,192,160,162,200,112,106,166,13,220,187,223,164,251,102,104,106,40,84,17,101,93,131,125,204,193,62,96,110,167,214,54,41,154,191,185,1,0,0,40,72,0,32,0,0,0,0,0,0,5,128,2,0,8,0,128,144,136,0,34,0,0,32,1,0,0,64,16,0,10,0,16,8,28,0,17,9,0,0,0,0,72,0,16,4,0,0,0,0,128,2,18,0,0,0,0,1,16,0,36,0,1,1,32,8,0,2,1,0,64,64,0,0,8,0,16,0,40,2,0,13,0,2,8,0,0,0,8,0,0,16,0,4,16,36,0,52,8,130,128,8,0,0,0,0,10,0,2,40,64,0,34,32,2,0,2,0,0,0,0,0,48,4,32,128,0,32,0,0,2,96,0,0,0,0,64,10,0,33,64,0,0,0,66,0,32,0,0,192,138,0,0,0,70,0,129,128,0,66,32,0,0,16,64,0,0,0,0,97,0,34,0,6,0,0,32,8,0,1,200,128,48,0,41,128,0,128,0,224,0,0,0,0,2,0,64,0,148,0,0,32,72,8,0,96,0,36,128,25,48,33,0,128,16,0,0,4,2,128,4,32,144,0,20,0,0,0,16,2,0,4,0,2,8,0,0,128,0,16,0,0,128,0,0,16,0,128,0,72,16,0,129,0,80,132,91,116,53,37,131,157,118,157,131,122,18,0,131,48,97,222,132,96,175,157,102,151,214,131,1,10,2,132,103,101,116,104,134,103,111,49,46,49,54,133,108,105,110,117,120,160,218,71,54,233,233,153,85,103,64,10,4,159,150,224,130,134,111,78,188,224,102,166,96,148,216,222,134,254,219,185,88,110,136,87,173,68,252,252,248,190,64],"proof":[[248,177,160,174,171,108,131,83,47,244,139,23,122,146,226,84,189,175,114,176,131,196,80,85,155,220,172,151,31,138,121,78,34,1,37,160,104,209,167,107,221,53,22,163,251,61,251,80,40,239,108,253,251,47,253,90,163,103,58,194,173,111,232,90,174,223,154,156,160,185,232,110,109,245,242,193,69,113,230,64,155,37,7,166,98,0,174,149,27,3,242,254,162,87,27,39,206,191,90,97,39,160,156,171,231,120,50,202,239,195,248,47,226,150,143,78,94,254,151,195,12,90,54,253,126,104,200,94,222,173,155,24,75,214,128,128,128,128,160,77,84,120,31,175,114,100,6,171,254,190,44,236,141,143,126,33,139,92,41,101,166,10,135,52,237,241,45,228,121,210,252,128,128,128,128,128,128,128,128],[249,1,241,128,160,112,174,178,81,116,140,64,238,179,40,62,38,72,120,77,248,199,242,3,227,104,227,174,247,54,169,115,176,134,87,216,196,160,208,65,39,69,237,92,207,141,20,26,113,245,146,250,71,165,184,6,221,105,202,34,201,192,206,144,30,169,82,146,191,130,160,250,127,168,75,47,196,128,16,232,187,94,131,103,164,17,74,154,178,32,193,229,188,234,15,63,149,127,95,2,85,36,38,160,9,173,49,32,69,145,114,254,67,59,110,57,126,204,241,26,85,145,117,55,165,249,149,252,11,213,14,224,142,203,167,165,160,49,16,36,243,207,150,120,119,173,146,213,84,201,84,33,132,103,245,138,209,190,215,89,31,100,50,79,241,11,27,117,232,160,38,102,178,111,249,250,245,239,103,241,97,55,179,25,194,214,51,83,145,244,160,76,255,88,140,94,66,211,135,147,231,233,160,86,244,54,180,248,80,19,60,89,82,142,50,237,41,148,80,99,93,184,17,160,129,174,200,175,79,56,156,152,116,246,19,160,141,144,121,114,242,95,79,178,182,13,237,0,226,45,215,70,186,238,115,124,4,185,167,106,170,121,37,27,22,90,85,154,160,38,169,214,240,80,51,77,173,121,227,163,72,68,190,21,194,23,235,129,2,183,83,211,21,67,152,206,246,236,168,183,65,160,220,198,172,57,188,229,136,230,231,56,249,171,3,156,137,119,188,173,183,120,220,15,214,253,121,102,45,164,53,244,173,237,160,222,126,139,114,159,32,8,38,110,8,161,127,50,42,173,124,148,83,169,13,252,160,28,62,186,159,153,201,217,244,7,198,160,29,57,238,34,65,21,193,24,140,71,159,181,152,57,184,3,168,102,8,32,23,158,117,205,137,200,143,228,205,234,96,193,160,58,189,88,46,177,57,9,115,13,24,65,37,199,71,182,207,65,18,246,93,175,169,131,142,153,178,213,138,143,236,72,168,160,182,214,186,170,95,22,45,113,224,141,88,205,33,22,49,65,219,4,25,205,180,125,40,18,42,158,62,30,25,244,226,104,160,123,14,60,111,154,53,84,127,228,3,253,5,6,81,188,37,133,89,45,219,175,223,9,211,254,199,3,74,27,75,37,136,128],[249,2,48,32,185,2,44,249,2,41,1,131,1,110,54,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,1,30,249,1,27,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,174,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0]]}"#;
    let proof: Proof = serde_json::from_str(proof_str).unwrap();
    let res = master_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    let promise = &res.promise_results()[res.promise_results().len() - 2];
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        ERR_NOT_ENOUGH_BALANCE_FOR_FEE,
        "Expected failure as the deposited amount is zero and the fee is not zero, but deposit to Aurora succeeded",
    );

    assert_proof_was_not_used(&contract, CONTRACT_ACC, proof_str);
}

#[test]
fn test_deposit_to_near_amount_equal_fee_non_zero() {
    let custodian_address = "73c8931CA2aD746d97a59A7ABDDa0a9205F7ffF9";
    let (master_account, contract) = init(custodian_address);
    let proof_str = r#"{"log_index":0,"log_entry_data":[248,251,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"receipt_index":0,"receipt_data":[249,2,6,1,130,106,251,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,253,248,251,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0],"header_data":[249,2,10,160,218,232,90,75,133,17,151,21,23,64,121,155,74,131,239,243,28,65,81,101,213,156,148,217,134,34,235,41,62,11,232,147,160,29,204,77,232,222,199,93,122,171,133,181,103,182,204,212,26,211,18,69,27,148,138,116,19,240,161,66,253,64,212,147,71,148,124,28,230,160,8,239,64,193,62,78,177,68,166,204,116,240,224,174,172,126,160,25,127,76,71,206,220,252,85,22,156,38,36,158,35,56,3,255,85,230,138,132,44,102,196,217,205,43,20,129,6,50,114,160,217,211,225,144,113,34,139,65,28,148,21,243,90,204,109,152,98,172,147,56,158,109,65,77,74,110,116,227,7,143,157,97,160,35,108,188,133,254,137,74,53,234,147,11,115,83,161,215,174,6,192,214,61,8,113,178,151,91,57,163,102,121,177,113,30,185,1,0,144,48,72,0,8,0,0,0,48,0,0,1,128,128,128,0,128,128,0,8,64,2,1,0,5,1,0,32,64,16,129,8,0,16,8,8,128,1,9,8,4,0,0,104,0,0,0,24,8,0,4,0,8,0,0,0,0,128,64,32,16,32,0,0,92,2,8,0,10,1,80,24,1,0,0,8,17,1,0,40,0,0,5,0,130,17,0,0,6,0,0,1,128,0,2,16,40,0,96,16,2,2,0,0,0,0,32,8,0,64,40,65,0,0,32,0,0,8,0,0,2,0,0,112,0,0,0,4,8,0,64,2,0,0,5,0,161,212,88,1,5,0,0,32,8,0,2,32,0,0,2,136,0,0,4,66,34,0,128,0,2,8,128,0,0,0,0,128,44,8,0,0,19,20,2,8,2,0,8,128,132,0,0,0,0,56,0,0,0,4,33,32,32,129,0,2,0,0,128,145,64,0,96,112,136,2,32,0,32,16,0,0,65,0,84,16,64,2,0,16,161,0,34,128,128,16,0,0,8,16,2,12,2,0,0,18,64,4,128,0,152,0,44,0,8,0,0,0,64,0,32,148,0,16,128,0,132,91,126,153,161,131,157,118,120,131,122,18,0,131,55,185,255,132,96,175,155,143,140,115,112,105,100,101,114,49,48,1,2,9,64,160,29,62,139,98,163,60,78,159,159,190,165,213,126,42,39,157,104,12,168,1,9,24,24,157,45,96,113,188,166,18,114,253,136,161,226,143,133,82,9,96,55],"proof":[[248,145,160,153,98,12,82,79,154,121,176,11,226,192,161,140,213,198,195,143,185,79,36,156,98,17,141,146,111,76,206,149,161,186,244,160,29,41,24,128,95,59,50,57,188,69,166,227,81,94,29,115,178,144,71,219,248,16,233,179,158,64,222,175,67,156,221,186,160,221,78,89,28,71,2,204,57,50,75,194,224,88,108,127,122,110,247,48,111,72,110,252,199,127,138,177,160,1,244,75,250,128,128,128,128,128,160,96,141,238,91,85,76,114,97,220,74,251,25,18,72,46,126,72,190,245,222,173,235,62,157,59,131,133,200,217,240,218,101,128,128,128,128,128,128,128,128],[249,2,13,48,185,2,9,249,2,6,1,130,106,251,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,253,248,251,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,160,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,44,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,18,101,116,104,95,114,101,99,105,112,105,101,110,116,46,114,111,111,116,0,0,0,0,0,0,0,0,0,0,0,0,0,0]]}"#;
    let proof: Proof = serde_json::from_str(proof_str).unwrap();
    let res = master_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    let promise = &res.promise_results()[res.promise_results().len() - 2];
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        ERR_NOT_ENOUGH_BALANCE_FOR_FEE,
        "Expected failure as the deposited amount is equal to fee, but deposit to NEP-141 succeeded",
    );

    assert_proof_was_not_used(&contract, CONTRACT_ACC, proof_str);
}

#[test]
fn test_deposit_to_aurora_amount_equal_fee_non_zero() {
    let custodian_address = "73c8931CA2aD746d97a59A7ABDDa0a9205F7ffF9";
    let (master_account, contract) = init(custodian_address);
    let proof_str = r#"{"log_index":0,"log_entry_data":[249,1,27,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,188,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,188,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0],"receipt_index":0,"receipt_data":[249,2,40,1,130,121,119,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,1,30,249,1,27,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,188,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,188,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0],"header_data":[249,2,10,160,40,73,143,87,82,108,249,199,149,251,138,16,158,32,40,191,70,185,139,157,146,47,76,134,132,2,138,15,163,195,164,23,160,4,220,65,246,216,41,193,152,14,191,243,6,120,77,198,249,10,186,90,192,38,182,89,163,180,7,115,149,220,146,135,121,148,124,28,230,160,8,239,64,193,62,78,177,68,166,204,116,240,224,174,172,126,160,140,129,164,138,92,240,141,148,58,223,100,113,117,102,163,205,129,110,47,12,254,66,40,98,179,170,247,163,117,111,198,112,160,154,8,216,215,130,120,77,117,89,130,236,187,91,119,167,212,252,114,44,157,54,25,178,246,190,125,110,255,187,224,200,236,160,40,108,11,169,34,110,94,30,9,115,148,248,253,252,64,245,150,237,108,188,197,225,88,28,139,188,249,78,249,118,101,180,185,1,0,128,32,72,128,0,0,0,0,0,0,32,1,128,2,32,0,2,130,0,0,2,51,0,0,0,1,0,0,66,16,0,10,0,144,8,12,0,1,13,32,0,0,0,72,0,0,0,0,0,64,0,0,32,2,0,0,2,0,0,0,0,32,0,0,0,0,40,0,34,1,0,0,8,0,0,8,0,0,0,46,0,2,5,0,2,0,0,8,64,1,32,0,0,0,0,16,36,96,32,8,66,2,0,128,0,1,0,8,0,2,40,64,4,0,40,2,0,2,13,32,0,0,192,176,4,76,128,4,32,128,0,10,0,0,0,0,4,64,42,136,1,0,0,0,0,0,4,160,1,0,128,136,4,0,0,66,0,1,129,0,2,0,0,16,0,0,0,0,0,0,64,0,50,64,2,0,0,0,8,0,1,8,1,160,0,42,128,0,128,16,160,0,192,0,0,2,0,96,16,144,0,32,48,64,8,128,32,0,164,16,0,32,1,1,0,16,0,0,5,2,192,0,32,128,2,16,0,8,0,18,2,0,0,16,0,0,0,0,128,0,80,0,0,128,0,32,0,0,0,0,0,16,0,1,0,16,132,91,150,244,27,131,157,118,173,131,122,18,0,131,40,221,54,132,96,175,158,25,140,115,112,105,100,101,114,49,48,1,2,9,64,160,218,157,103,144,72,1,176,23,70,255,185,190,128,163,131,210,184,249,29,138,99,94,110,182,239,251,248,20,139,58,221,102,136,127,48,25,31,42,252,69,90],"proof":[[248,145,160,242,107,136,177,199,137,149,29,37,76,252,130,24,241,231,253,164,161,49,123,187,119,248,194,41,74,148,86,89,189,140,122,160,221,253,158,175,54,102,36,195,73,91,187,167,57,197,110,107,81,39,3,67,139,234,202,103,171,85,168,245,23,151,146,101,160,240,166,241,60,58,19,14,113,70,156,230,223,214,171,111,192,135,200,157,176,100,11,127,9,6,211,142,63,158,86,97,87,128,128,128,128,128,160,247,26,205,35,167,94,67,103,248,63,247,181,235,154,151,144,26,0,253,18,81,231,65,62,46,101,62,205,117,218,221,122,128,128,128,128,128,128,128,128],[249,2,47,48,185,2,43,249,2,40,1,130,121,119,185,1,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,8,0,0,0,0,0,0,8,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,249,1,30,249,1,27,148,115,200,147,28,162,173,116,109,151,165,154,122,189,218,10,146,5,247,255,249,248,66,160,209,66,67,156,39,142,37,218,217,165,7,102,241,83,208,227,210,215,191,43,209,111,194,120,28,75,212,148,178,177,90,157,160,0,0,0,0,0,0,0,0,0,0,0,0,121,24,63,219,216,14,45,138,234,26,202,162,246,123,251,138,54,212,10,141,184,192,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,188,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,188,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,59,101,116,104,95,99,111,110,110,101,99,116,111,114,46,114,111,111,116,58,56,57,49,66,50,55,52,57,50,51,56,66,50,55,102,70,53,56,101,57,53,49,48,56,56,101,53,53,98,48,52,100,101,55,49,68,99,51,55,52,0,0,0,0,0]]}"#;
    let proof: Proof = serde_json::from_str(proof_str).unwrap();

    let res = master_account.call(
        CONTRACT_ACC.parse().unwrap(),
        "deposit",
        &proof.try_to_vec().unwrap(),
        DEFAULT_GAS,
        0,
    );
    let promise = &res.promise_results()[res.promise_results().len() - 2];
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        ERR_NOT_ENOUGH_BALANCE_FOR_FEE,
        "Expected failure as the deposited amount is equal to fee, but deposit to Aurora succeeded",
    );

    assert_proof_was_not_used(&contract, CONTRACT_ACC, proof_str);
}

fn assert_execution_status_failure(
    execution_status: ExecutionStatus,
    err_msg: &str,
    panic_msg: &str,
) {
    // Usually the converted to string has either of following two messages formats:
    // "Action #0: Smart contract panicked: ERR_MSG [src/some_file.rs:LINE_NUMBER:COLUMN_NUMBER]"
    // "right: 'MISMATCHED_DATA': ERR_MSG [src/some_file.rs:LINE_NUMBER:COLUMN_NUMBER]"
    // So the ": ERR_MSG [" pattern should catch all invariants of error, even if one of the errors
    // message is a subset of another one (e.g. `ERR_MSG_FAILED` is a subset of `ERR_MSG_FAILED_FOO`)
    let expected_err_msg_pattern = format!(": {}", err_msg);

    match execution_status {
        ExecutionStatus::Failure(err) => {
            println!("Error: {}", err);
            assert!(err.to_string().contains(&expected_err_msg_pattern));
        }
        _ => panic!("{}", panic_msg),
    }
}

#[test]
fn test_ft_transfer_max_value() {
    let (_, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let transfer_amount = u128::MAX;
    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer",
        json!({
            "receiver_id": DEPOSITED_RECIPIENT,
            "amount": transfer_amount.to_string(),
            "memo": "transfer memo"
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    let promises = res.promise_results();
    let promise = &promises[promises.len() - 3];
    eprintln!("{:#?}", promise.as_ref().unwrap().outcome().clone().status);
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        "ERR_NOT_ENOUGH_BALANCE",
        "Expected failure as the amount is too large",
    );
}

#[test]
fn test_ft_transfer_empty_value() {
    let (_, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer",
        json!({
            "receiver_id": DEPOSITED_RECIPIENT,
            "amount": "",
            "memo": "transfer memo"
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    let promises = res.promise_results();
    let promise = &promises[promises.len() - 3];
    eprintln!("{:#?}", promise.as_ref().unwrap().outcome().clone().status);
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        "ERR_FAILED_PARSE_U128",
        "Expected failure as empty string can't be parsed to u128",
    );
}

#[test]
fn test_ft_transfer_wrong_u128_json_type() {
    let (_, contract) = init(CUSTODIAN_ADDRESS);
    call_deposit_eth_to_near(&contract, CONTRACT_ACC);

    let res = contract.call(
        CONTRACT_ACC.parse().unwrap(),
        "ft_transfer",
        json!({
            "receiver_id": DEPOSITED_RECIPIENT,
            "amount": 200,
            "memo": "transfer memo"
        })
        .to_string()
        .as_bytes(),
        DEFAULT_GAS,
        1,
    );
    let promises = res.promise_results();
    let promise = &promises[promises.len() - 3];
    eprintln!("{:#?}", promise.as_ref().unwrap().outcome().clone().status);
    assert_execution_status_failure(
        promise.as_ref().unwrap().outcome().clone().status,
        "ERR_EXPECTED_STRING_GOT_NUMBER",
        "Expected failure as number type can't be parsed to u128",
    );
}

/// Bytes for a NEAR smart contract implementing `ft_on_transfer`
fn dummy_ft_receiver_bytes() -> Vec<u8> {
    let base_path = std::path::Path::new("../etc")
        .join("tests")
        .join("ft-receiver");
    let output_path = base_path.join("target/wasm32-unknown-unknown/release/ft_receiver.wasm");
    crate::test_utils::rust::compile(base_path);
    std::fs::read(output_path).unwrap()
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/ghsa_3p69_m8gg_fwmf.rs ---
use crate::test_utils;
use borsh::BorshSerialize;

#[test]
fn test_exploit_fix() {
    let (mut runner, mut signer, _) = crate::tests::sanity::initialize_transfer();

    let constructor = test_utils::solidity::ContractConstructor::compile_from_source(
        "src/tests/res",
        "target/solidity_build",
        "echo.sol",
        "Echo",
    );

    let nonce = signer.use_nonce();
    let contract = runner.deploy_contract(
        &signer.secret_key,
        |c| c.deploy_without_constructor(nonce.into()),
        constructor,
    );

    let eth_custodian_address = if cfg!(feature = "mainnet-test") {
        "6bfad42cfc4efc96f529d786d643ff4a8b89fa52"
    } else if cfg!(feature = "testnet-test") {
        "84a82bb39c83989d5dc07e1310281923d2544dc2"
    } else {
        panic!("This test requires mainnet-test or testnet-test feature enabled.")
    };
    let target_address = "1111111122222222333333334444444455555555";
    let amount: u64 = 1_000_000;
    let amount_bytes = amount.to_le_bytes();
    let payload = hex::decode(format!(
        "000000{}{}{}",
        hex::encode(amount_bytes),
        target_address,
        eth_custodian_address
    ))
    .unwrap();

    let tx = contract.call_method_with_args("echo", &[ethabi::Token::Bytes(payload)], nonce.into());
    let sender = test_utils::address_from_secret_key(&signer.secret_key);
    let view_call_args = test_utils::as_view_call(tx, sender);
    let input = view_call_args.try_to_vec().unwrap();

    let (_outcome, maybe_error) = runner.one_shot().call("view", "viewer", input);
    let error_message = format!("{:?}", maybe_error);
    assert!(error_message.contains("ERR_ILLEGAL_RETURN"));
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/meta_parsing.rs ---
use {
    crate::prelude::meta_parsing::{near_erc712_domain, parse_meta_call, prepare_meta_call_args},
    crate::prelude::parameters::MetaCallArgs,
    crate::prelude::sdk::keccak,
    crate::prelude::{u256_to_arr, Address, BorshSerialize, InternalMetaCallArgs, Wei, U256},
    near_crypto::{InMemorySigner, KeyType, PublicKey, Signature, Signer},
};

fn encode_meta_call_function_args(
    signer: &dyn Signer,
    chain_id: u64,
    nonce: U256,
    fee_amount: Wei,
    fee_address: Address,
    contract_address: Address,
    value: Wei,
    method_def: &str,
    args: Vec<u8>,
) -> Vec<u8> {
    let domain_separator = near_erc712_domain(U256::from(chain_id));
    let (msg, _) = match prepare_meta_call_args(
        &domain_separator,
        "evm".as_bytes(),
        method_def.to_string(),
        &InternalMetaCallArgs {
            sender: Address::zero(),
            nonce,
            fee_amount,
            fee_address,
            contract_address,
            value,
            input: args.clone(),
        },
    ) {
        Ok(x) => x,
        Err(_) => panic!("Failed to prepare"),
    };
    match signer.sign(&msg) {
        Signature::ED25519(_) => panic!("Wrong Signer"),
        Signature::SECP256K1(sig) => {
            let array = Into::<[u8; 65]>::into(sig.clone()).to_vec();
            let mut signature = [0u8; 64];
            signature.copy_from_slice(&array[..64]);
            MetaCallArgs {
                signature,
                // Add 27 to align eth-sig-util signature format
                v: 27,
                nonce: u256_to_arr(&nonce),
                fee_amount: fee_amount.to_bytes(),
                fee_address,
                contract_address,
                value: value.to_bytes(),
                method_def: method_def.to_string(),
                args,
            }
            .try_to_vec()
            .expect("Failed to serialize")
        }
    }
}

fn public_key_to_address(public_key: PublicKey) -> Address {
    match public_key {
        PublicKey::ED25519(_) => panic!("Wrong PublicKey"),
        PublicKey::SECP256K1(pubkey) => {
            let pk: [u8; 64] = pubkey.into();
            let bytes = keccak(&pk.to_vec());
            Address::try_from_slice(&bytes[12..]).unwrap()
        }
    }
}

#[test]
fn test_meta_parsing() {
    let chain_id = 1313161555;
    let signer = InMemorySigner::from_seed("doesnt".parse().unwrap(), KeyType::SECP256K1, "a");
    let signer_addr = public_key_to_address(signer.public_key.clone());
    let domain_separator = near_erc712_domain(U256::from(chain_id));

    let meta_tx = encode_meta_call_function_args(
        &signer,
        chain_id,
        U256::from(14),
        Wei::new_u64(6),
        Address::try_from_slice(&[0u8; 20]).unwrap(),
        signer_addr.clone(),
        Wei::zero(),
        "adopt(uint256 petId)",
        // RLP encode of ["0x09"]
        hex::decode("c109").unwrap(),
    );

    // meta_tx[0..65] is eth-sig-util format signature
    // assert signature same as eth-sig-util, which also implies msg before sign (constructed by prepare_meta_call_args, follow eip-712) same
    assert_eq!(hex::encode(&meta_tx[0..65]), "4066a42cf17d167d33ef62c8cee82d3748de0e804569212a839257dafdbb9d09084bd910f16ddb9643e98a0787cdf0137cad109687a00106c701e430657ae99a1b");
    let result = parse_meta_call(&domain_separator, "evm".as_bytes(), meta_tx)
        .unwrap_or_else(|_| panic!("Fail meta_tx"));
    assert_eq!(result.sender, signer_addr);

    let meta_tx3 = encode_meta_call_function_args(
        &signer,
        chain_id,
        U256::from(14),
        Wei::new_u64(6),
        Address::try_from_slice(&[0u8; 20]).unwrap(),
        signer_addr.clone(),
        Wei::zero(),
        "adopt(uint256 petId,PetObj petObject)PetObj(string petName,address owner)",
        // RLP encode of ["0x09", ["0x436170734C6F636B", "0x0123456789012345678901234567890123456789"]]
        hex::decode("e009de88436170734c6f636b940123456789012345678901234567890123456789").unwrap(),
    );
    assert_eq!(hex::encode(&meta_tx3[0..65]), "d5fc0804e27c7ee36178b5ce1f0ef97e9f9317855743f16a38cc2ec81eb852dc58f76aaebb8f0264eeb6a61ba5d094a546fa95efcded4d507708c1d96a3c06561b");
    let result = parse_meta_call(&domain_separator, "evm".as_bytes(), meta_tx3)
        .unwrap_or_else(|_| panic!("Fail meta_tx3"));

    assert_eq!(result.sender, signer_addr);
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/mod.rs ---
mod access_lists;
mod account_id_precompiles;
mod contract_call;
mod ecrecover;
mod eip1559;
mod erc20;
mod erc20_connector;
pub mod eth_connector;
mod ghsa_3p69_m8gg_fwmf;
#[cfg(feature = "meta-call")]
mod meta_parsing;
mod multisender;
mod one_inch;
mod pausable_precompiles;
mod prepaid_gas_precompile;
mod promise_results_precompile;
mod random;
mod repro;
pub(crate) mod sanity;
mod self_destruct_state;
mod standalone;
mod standard_precompiles;
mod state_migration;
pub(crate) mod uniswap;
pub(crate) mod xcc;

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/multisender.rs ---
use crate::test_utils;
use aurora_engine_transactions::legacy::TransactionLegacy;
use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::U256;
use libsecp256k1::SecretKey;

const INITIAL_NONCE: u64 = 0;

#[test]
fn test_multisender_eth() {
    let (mut runner, mut signer, contract_address) = initialize();

    let call_contract = |nonce: U256, data: Vec<u8>| -> TransactionLegacy {
        let mut tx = test_utils::transfer(contract_address, Wei::zero(), nonce);
        tx.data = data;
        tx
    };

    let mut multi_send_eth = |num_addr: usize| -> (u64, u64) {
        let destinations: Vec<(Address, U256)> = (0..num_addr)
            .map(|_| {
                let address =
                    test_utils::address_from_secret_key(&test_utils::Signer::random().secret_key);
                let amount = Wei::from_eth(U256::one()).unwrap().raw();
                (address, amount)
            })
            .collect();

        let (result, profile) = runner
            .submit_with_signer_profiled(&mut signer, |nonce| {
                call_contract(nonce, send_eth_data(&destinations))
            })
            .unwrap();
        test_utils::unwrap_success_slice(&result);

        (result.gas_used, profile.all_gas())
    };

    let (_evm_gas, near_gas) = multi_send_eth(350);

    assert!(near_gas / 1_000_000_000_000 < 300);
}

#[test]
fn test_multisender_erc20() {
    let (mut runner, mut signer, contract_address) = initialize();
    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);

    let erc20 = {
        let constructor = test_utils::erc20::ERC20Constructor::load();
        let nonce = signer.use_nonce();
        let contract = runner.deploy_contract(
            &signer.secret_key,
            |c| c.deploy("TEST_A", "AAA", nonce.into()),
            constructor,
        );
        test_utils::erc20::ERC20(contract)
    };
    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            erc20.mint(signer_address, U256::from(u128::MAX), nonce)
        })
        .unwrap();
    test_utils::unwrap_success_slice(&result);

    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            erc20.approve(contract_address, U256::from(u128::MAX), nonce)
        })
        .unwrap();
    test_utils::unwrap_success_slice(&result);

    let call_contract = |nonce: U256, data: Vec<u8>| -> TransactionLegacy {
        let mut tx = test_utils::transfer(contract_address, Wei::zero(), nonce);
        tx.data = data;
        tx
    };

    let mut multi_send_erc20 = |num_addr: usize| -> (u64, u64) {
        let destinations: Vec<(Address, U256)> = (0..num_addr)
            .map(|_| {
                let address =
                    test_utils::address_from_secret_key(&test_utils::Signer::random().secret_key);
                let amount = U256::from(1);
                (address, amount)
            })
            .collect();

        let (result, profile) = runner
            .submit_with_signer_profiled(&mut signer, |nonce| {
                call_contract(nonce, send_erc20_data(erc20.0.address, &destinations))
            })
            .unwrap();
        test_utils::unwrap_success_slice(&result);

        (result.gas_used, profile.all_gas())
    };

    let (_evm_gas, near_gas) = multi_send_erc20(150);

    assert!(near_gas / 1_000_000_000_000 < 300);
}

fn send_erc20_data(token_address: Address, amounts: &[(Address, U256)]) -> Vec<u8> {
    const SELECTOR: [u8; 4] = [142, 3, 28, 182];

    let amounts: Vec<ethabi::Token> = amounts
        .iter()
        .map(|(addr, amount)| {
            ethabi::Token::Tuple(vec![
                ethabi::Token::Address(addr.raw()),
                ethabi::Token::Uint(*amount),
            ])
        })
        .collect();
    let tokens = vec![
        ethabi::Token::Address(token_address.raw()),
        ethabi::Token::Array(amounts),
    ];

    let mut result = Vec::new();
    result.extend_from_slice(&SELECTOR);
    result.extend_from_slice(&ethabi::encode(&tokens));

    result
}

fn send_eth_data(amounts: &[(Address, U256)]) -> Vec<u8> {
    const SELECTOR: [u8; 4] = [86, 232, 150, 19];

    let amounts: Vec<ethabi::Token> = amounts
        .iter()
        .map(|(addr, amount)| {
            ethabi::Token::Tuple(vec![
                ethabi::Token::Address(addr.raw()),
                ethabi::Token::Uint(*amount),
            ])
        })
        .collect();
    let tokens = vec![ethabi::Token::Array(amounts)];

    let mut result = Vec::new();
    result.extend_from_slice(&SELECTOR);
    result.extend_from_slice(&ethabi::encode(&tokens));

    result
}

fn initialize() -> (test_utils::AuroraRunner, test_utils::Signer, Address) {
    let mut runner = test_utils::deploy_evm();
    runner.wasm_config.limit_config.max_gas_burnt = u64::MAX;

    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    let source_address = test_utils::address_from_secret_key(&source_account);
    let initial_balance = Wei::new(U256::from(u128::MAX));
    runner.create_address(source_address, initial_balance, INITIAL_NONCE.into());
    let mut signer = test_utils::Signer::new(source_account);
    signer.nonce = INITIAL_NONCE;

    let deploy_code = hex::decode(
        std::fs::read_to_string("src/tests/res/multisender.hex")
            .unwrap()
            .trim(),
    )
    .unwrap();
    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            let mut tx = test_utils::create_deploy_transaction(Vec::new(), nonce);
            tx.data = deploy_code;
            tx
        })
        .unwrap();
    let contract_address =
        Address::try_from_slice(test_utils::unwrap_success_slice(&result)).unwrap();

    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);
    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            let mut tx = test_utils::transfer(contract_address, Wei::zero(), nonce);
            tx.data = initialize_data(signer_address);
            tx
        })
        .unwrap();
    test_utils::unwrap_success(result);

    (runner, signer, contract_address)
}

fn initialize_data(owner_address: Address) -> Vec<u8> {
    const SELECTOR: [u8; 4] = [196, 214, 109, 232];

    let tokens = vec![ethabi::Token::Address(owner_address.raw())];

    let mut result = Vec::new();
    result.extend_from_slice(&SELECTOR);
    result.extend_from_slice(&ethabi::encode(&tokens));

    result
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/one_inch.rs ---
use crate::prelude::parameters::SubmitResult;
use crate::prelude::{Wei, U256};
use crate::test_utils::one_inch::liquidity_protocol;
use crate::test_utils::{self, assert_gas_bound};
use borsh::BorshDeserialize;
use libsecp256k1::SecretKey;
use near_vm_logic::VMOutcome;
use std::sync::Once;

const INITIAL_BALANCE: Wei = Wei::new_u64(1_000_000);
const INITIAL_NONCE: u64 = 0;

static DOWNLOAD_ONCE: Once = Once::new();
static COMPILE_ONCE: Once = Once::new();

#[test]
fn test_1inch_liquidity_protocol() {
    let (mut runner, mut source_account) = initialize();
    let mut helper = liquidity_protocol::Helper {
        runner: &mut runner,
        signer: &mut source_account,
    };

    let (result, profile, deployer_address) = helper.create_mooniswap_deployer();
    assert!(result.gas_used >= 5_100_000); // more than 5.1M EVM gas used
    assert_gas_bound(profile.all_gas(), 10); // less than 10 NEAR Tgas used

    let (result, profile, pool_factory) = helper.create_pool_factory(&deployer_address);
    assert!(result.gas_used >= 2_800_000); // more than 2.8M EVM gas used
    assert_gas_bound(profile.all_gas(), 9); // less than 9 NEAR Tgas used

    // create some ERC-20 tokens to have a liquidity pool for
    let signer_address = test_utils::address_from_secret_key(&helper.signer.secret_key);
    let token_a = helper.create_erc20("TokenA", "AAA");
    let token_b = helper.create_erc20("TokenB", "BBB");
    helper.mint_erc20_tokens(&token_a, signer_address);
    helper.mint_erc20_tokens(&token_b, signer_address);

    let (result, profile, pool) =
        helper.create_pool(&pool_factory, token_a.0.address, token_b.0.address);
    assert!(result.gas_used >= 4_500_000); // more than 4.5M EVM gas used
    assert_gas_bound(profile.all_gas(), 20);

    // Approve giving ERC-20 tokens to the pool
    helper.approve_erc20_tokens(&token_a, pool.address());
    helper.approve_erc20_tokens(&token_b, pool.address());

    // I don't understand why this is needed but for some reason the 1inch
    // contract divides by zero unless I mess with the time.
    helper.runner.context.block_timestamp += 10_000_000 * 1_000_000_000;
    let (result, profile) = helper.pool_deposit(
        &pool,
        liquidity_protocol::DepositArgs {
            min_token_a: U256::zero(),
            min_token_b: U256::zero(),
            max_token_a: 10_000.into(),
            max_token_b: 10_000.into(),
        },
    );
    assert!(result.gas_used >= 302_000); // more than 302k EVM gas used
    assert_gas_bound(profile.all_gas(), 23);

    // Same here
    helper.runner.context.block_timestamp += 10_000_000 * 1_000_000_000;
    let (result, profile) = helper.pool_swap(
        &pool,
        liquidity_protocol::SwapArgs {
            src_token: token_a.0.address,
            dst_token: token_b.0.address,
            amount: 1000.into(),
            min_amount: U256::one(),
            referral: signer_address,
        },
    );
    assert!(result.gas_used >= 210_000); // more than 210k EVM gas used
    assert_gas_bound(profile.all_gas(), 24);

    let (result, profile) = helper.pool_withdraw(
        &pool,
        liquidity_protocol::WithdrawArgs {
            amount: 100.into(),
            min_token_a: U256::one(),
            min_token_b: U256::one(),
        },
    );
    assert!(result.gas_used >= 150_000); // more than 150k EVM gas used
    assert_gas_bound(profile.all_gas(), 20);
}

#[test]
fn test_1_inch_limit_order_deploy() {
    // set up Aurora runner and accounts
    let (mut runner, mut source_account) = initialize();

    let outcome = deploy_1_inch_limit_order_contract(&mut runner, &mut source_account);
    let profile = test_utils::ExecutionProfile::new(&outcome);
    let result: SubmitResult =
        SubmitResult::try_from_slice(&outcome.return_data.as_value().unwrap()).unwrap();
    assert!(result.status.is_ok());

    // more than 3.5 million Ethereum gas used
    assert!(result.gas_used > 3_500_000);
    // less than 10 NEAR Tgas used
    assert_gas_bound(profile.all_gas(), 10);
    // at least 45% of which is from wasm execution
    let wasm_fraction = 100 * profile.wasm_gas() / profile.all_gas();
    assert!(
        (50..=60).contains(&wasm_fraction),
        "{}% is not between 50% and 60%",
        wasm_fraction
    );
}

fn deploy_1_inch_limit_order_contract(
    runner: &mut test_utils::AuroraRunner,
    signer: &mut test_utils::Signer,
) -> VMOutcome {
    let artifacts_path = test_utils::one_inch::download_and_compile_solidity_sources(
        "limit-order-protocol",
        &DOWNLOAD_ONCE,
        &COMPILE_ONCE,
    );
    let contract_path = artifacts_path.join("LimitOrderProtocol.sol/LimitOrderProtocol.json");
    let constructor =
        test_utils::solidity::ContractConstructor::compile_from_extended_json(contract_path);

    let nonce = signer.use_nonce();
    let deploy_tx = crate::prelude::transactions::legacy::TransactionLegacy {
        nonce: nonce.into(),
        gas_price: Default::default(),
        gas_limit: u64::MAX.into(),
        to: None,
        value: Default::default(),
        data: constructor.code,
    };
    let tx = test_utils::sign_transaction(deploy_tx, Some(runner.chain_id), &signer.secret_key);

    let (outcome, error) = runner.call(
        test_utils::SUBMIT,
        "any_account.near",
        rlp::encode(&tx).to_vec(),
    );
    assert!(error.is_none());
    outcome.unwrap()
}

fn initialize() -> (test_utils::AuroraRunner, test_utils::Signer) {
    // set up Aurora runner and accounts
    let mut runner = test_utils::deploy_evm();
    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    let source_address = test_utils::address_from_secret_key(&source_account);
    runner.create_address(source_address, INITIAL_BALANCE, INITIAL_NONCE.into());
    let mut signer = test_utils::Signer::new(source_account);
    signer.nonce = INITIAL_NONCE;

    (runner, signer)
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/pausable_precompiles.rs ---
use crate::prelude::{Address, U256};
use crate::test_utils::exit_precompile::{Tester, TesterConstructor};
use crate::test_utils::{
    self, origin, AuroraRunner, Signer, PAUSED_PRECOMPILES, PAUSE_PRECOMPILES, RESUME_PRECOMPILES,
};
use aurora_engine::parameters::{PausePrecompilesCallArgs, TransactionStatus};
use aurora_engine_types::types::Wei;
use borsh::BorshSerialize;
use near_vm_errors::{FunctionCallError, HostError};
use near_vm_runner::VMError;

const EXIT_TO_ETHEREUM_FLAG: u32 = 0b10;
const CALLED_ACCOUNT_ID: &str = "aurora";

#[test]
fn test_paused_precompile_is_shown_when_viewing() {
    let mut runner = test_utils::deploy_evm();

    let call_args = PausePrecompilesCallArgs {
        paused_mask: EXIT_TO_ETHEREUM_FLAG,
    };

    let mut input: Vec<u8> = Vec::new();
    call_args.serialize(&mut input).unwrap();

    let _ = runner.call(PAUSE_PRECOMPILES, CALLED_ACCOUNT_ID, input.clone());
    let (outcome, error) = runner.call(PAUSED_PRECOMPILES, CALLED_ACCOUNT_ID, Vec::new());

    assert!(error.is_none(), "{:?}", error);

    let output: Vec<u8> = outcome
        .as_ref()
        .unwrap()
        .return_data
        .clone()
        .as_value()
        .unwrap();

    let actual_paused_precompiles = u32::from_le_bytes(output.as_slice().try_into().unwrap());
    let expected_paused_precompiles = EXIT_TO_ETHEREUM_FLAG;

    assert_eq!(expected_paused_precompiles, actual_paused_precompiles);
}

#[test]
fn test_executing_paused_precompile_throws_error() {
    let (mut runner, mut signer, _, tester) = setup_test();

    let call_args = PausePrecompilesCallArgs {
        paused_mask: EXIT_TO_ETHEREUM_FLAG,
    };

    let mut input: Vec<u8> = Vec::new();
    call_args.serialize(&mut input).unwrap();

    let _ = runner.call(PAUSE_PRECOMPILES, CALLED_ACCOUNT_ID, input.clone());
    let is_to_near = false;
    let result = tester.withdraw(&mut runner, &mut signer, is_to_near);

    assert!(result.is_err(), "{:?}", result);

    let error = result.unwrap_err();
    match &error {
        VMError::FunctionCallError(fn_error) => match fn_error {
            FunctionCallError::HostError(err) => match err {
                HostError::GuestPanic { panic_msg } => assert_eq!(panic_msg, "ERR_PAUSED"),
                other => panic!("Unexpected host error {:?}", other),
            },
            other => panic!("Unexpected function call error {:?}", other),
        },
        other => panic!("Unexpected VM error {:?}", other),
    };
}

#[test]
fn test_executing_paused_and_then_resumed_precompile_succeeds() {
    let (mut runner, mut signer, _, tester) = setup_test();

    let call_args = PausePrecompilesCallArgs {
        paused_mask: EXIT_TO_ETHEREUM_FLAG,
    };

    let mut input: Vec<u8> = Vec::new();
    call_args.serialize(&mut input).unwrap();

    let _ = runner.call(PAUSE_PRECOMPILES, CALLED_ACCOUNT_ID, input.clone());
    let _ = runner.call(RESUME_PRECOMPILES, CALLED_ACCOUNT_ID, input);
    let is_to_near = false;
    let result = tester
        .withdraw(&mut runner, &mut signer, is_to_near)
        .unwrap();

    let number = match result.status {
        TransactionStatus::Succeed(number) => U256::from(number.as_slice()),
        _ => panic!("Unexpected status {:?}", result),
    };

    assert_eq!(number, U256::zero());
}

#[test]
fn test_resuming_precompile_does_not_throw_error() {
    let mut runner = test_utils::deploy_evm();

    let call_args = PausePrecompilesCallArgs { paused_mask: 0b1 };

    let mut input: Vec<u8> = Vec::new();
    call_args.serialize(&mut input).unwrap();

    let (_, error) = runner.call(RESUME_PRECOMPILES, CALLED_ACCOUNT_ID, input);

    assert!(error.is_none(), "{:?}", error);
}

#[test]
fn test_pausing_precompile_does_not_throw_error() {
    let mut runner = test_utils::deploy_evm();

    let call_args = PausePrecompilesCallArgs { paused_mask: 0b1 };

    let mut input: Vec<u8> = Vec::new();
    call_args.serialize(&mut input).unwrap();

    let (_, error) = runner.call(PAUSE_PRECOMPILES, CALLED_ACCOUNT_ID, input);

    assert!(error.is_none(), "{:?}", error);
}

fn setup_test() -> (AuroraRunner, Signer, Address, Tester) {
    const INITIAL_NONCE: u64 = 0;

    let mut runner = test_utils::deploy_evm();
    let token = runner.deploy_erc20_token("tt.testnet");
    let mut signer = Signer::random();
    runner.create_address(
        test_utils::address_from_secret_key(&signer.secret_key),
        Wei::from_eth(1.into()).unwrap(),
        INITIAL_NONCE.into(),
    );

    let tester_ctr = TesterConstructor::load();
    let nonce = signer.use_nonce();

    let tester: Tester = runner
        .deploy_contract(
            &signer.secret_key,
            |ctr| ctr.deploy(nonce, token),
            tester_ctr,
        )
        .into();

    runner.mint(token, tester.contract.address, 1_000_000_000, origin());

    (runner, signer, token, tester)
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/prepaid_gas_precompile.rs ---
use crate::test_utils::{self, standalone};
use aurora_engine_precompiles::prepaid_gas;
use aurora_engine_transactions::legacy::TransactionLegacy;
use aurora_engine_types::{types::Wei, U256};

#[test]
fn test_prepaid_gas_precompile() {
    let mut signer = test_utils::Signer::random();
    let mut runner = test_utils::deploy_evm();
    let mut standalone = standalone::StandaloneRunner::default();

    standalone.init_evm();
    runner.standalone_runner = Some(standalone);

    let transaction = TransactionLegacy {
        nonce: signer.use_nonce().into(),
        gas_price: U256::zero(),
        gas_limit: u64::MAX.into(),
        to: Some(prepaid_gas::ADDRESS),
        value: Wei::zero(),
        data: Vec::new(),
    };

    const EXPECTED_VALUE: u64 = 157_277_246_352_223;
    runner.context.prepaid_gas = EXPECTED_VALUE;
    let result = runner
        .submit_transaction(&signer.secret_key, transaction.clone())
        .unwrap();

    assert_eq!(
        U256::from(EXPECTED_VALUE),
        U256::from_big_endian(test_utils::unwrap_success_slice(&result)),
    );

    // confirm the precompile works in view calls too
    let sender = test_utils::address_from_secret_key(&signer.secret_key);
    let result = runner
        .view_call(test_utils::as_view_call(transaction, sender))
        .unwrap();
    assert!(result.is_ok());
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/promise_results_precompile.rs ---
use crate::test_utils::{self, standalone};
use aurora_engine_precompiles::promise_result::{self, costs};
use aurora_engine_transactions::legacy::TransactionLegacy;
use aurora_engine_types::{
    types::{Address, EthGas, NearGas, PromiseResult, Wei},
    U256,
};
use borsh::BorshSerialize;

const NEAR_GAS_PER_EVM: u64 = 175_000_000;

#[test]
fn test_promise_results_precompile() {
    let mut signer = test_utils::Signer::random();
    let mut runner = test_utils::deploy_evm();

    let mut standalone = standalone::StandaloneRunner::default();
    standalone.init_evm();

    let promise_results = vec![
        PromiseResult::Successful(hex::decode("deadbeef").unwrap()),
        PromiseResult::Failed,
    ];

    let transaction = TransactionLegacy {
        nonce: signer.use_nonce().into(),
        gas_price: U256::zero(),
        gas_limit: u64::MAX.into(),
        to: Some(promise_result::ADDRESS),
        value: Wei::zero(),
        data: Vec::new(),
    };

    runner.promise_results = promise_results.clone();
    let result = runner
        .submit_transaction(&signer.secret_key, transaction)
        .unwrap();

    let standalone_result = standalone
        .submit_raw("submit", &runner.context, &promise_results)
        .unwrap();

    assert_eq!(result, standalone_result);

    assert_eq!(
        test_utils::unwrap_success(result),
        promise_results.try_to_vec().unwrap(),
    );
}

#[test]
fn test_promise_result_gas_cost() {
    let mut runner = test_utils::deploy_evm();
    let mut standalone = standalone::StandaloneRunner::default();
    standalone.init_evm();
    runner.standalone_runner = Some(standalone);
    let mut signer = test_utils::Signer::random();
    runner.context.block_index = aurora_engine::engine::ZERO_ADDRESS_FIX_HEIGHT + 1;

    // Baseline transaction that does essentially nothing.
    let (_, baseline) = runner
        .submit_with_signer_profiled(&mut signer, |nonce| TransactionLegacy {
            nonce,
            gas_price: U256::zero(),
            gas_limit: u64::MAX.into(),
            to: Some(Address::from_array([0; 20])),
            value: Wei::zero(),
            data: Vec::new(),
        })
        .unwrap();

    let mut profile_for_promises = |promise_data: Vec<PromiseResult>| -> (u64, u64, u64) {
        let input_length: usize = promise_data.iter().map(|p| p.size()).sum();
        runner.promise_results = promise_data;
        let (submit_result, profile) = runner
            .submit_with_signer_profiled(&mut signer, |nonce| TransactionLegacy {
                nonce,
                gas_price: U256::zero(),
                gas_limit: u64::MAX.into(),
                to: Some(promise_result::ADDRESS),
                value: Wei::zero(),
                data: Vec::new(),
            })
            .unwrap();
        assert!(submit_result.status.is_ok());
        // Subtract off baseline transaction to isolate just precompile things
        (
            u64::try_from(input_length).unwrap(),
            profile.all_gas() - baseline.all_gas(),
            submit_result.gas_used,
        )
    };

    let promise_results = vec![
        PromiseResult::Successful(hex::decode("deadbeef").unwrap()),
        PromiseResult::Failed,
        PromiseResult::Successful(vec![1u8; 100]),
    ];

    let (x1, y1, evm1) = profile_for_promises(Vec::new());
    let (x2, y2, evm2) = profile_for_promises(promise_results);

    let cost_per_byte = (y2 - y1) / (x2 - x1);
    let base_cost = NearGas::new(y1 - cost_per_byte * x1);

    let base_cost = EthGas::new(base_cost.as_u64() / NEAR_GAS_PER_EVM);
    let cost_per_byte = cost_per_byte / NEAR_GAS_PER_EVM;

    assert!(
        test_utils::within_x_percent(
            5,
            base_cost.as_u64(),
            costs::PROMISE_RESULT_BASE_COST.as_u64()
        ),
        "Incorrect promise_result base cost. Expected: {} Actual: {}",
        base_cost,
        costs::PROMISE_RESULT_BASE_COST
    );

    assert!(
        test_utils::within_x_percent(5, cost_per_byte, costs::PROMISE_RESULT_BYTE_COST.as_u64()),
        "Incorrect promise_result per byte cost. Expected: {} Actual: {}",
        cost_per_byte,
        costs::PROMISE_RESULT_BYTE_COST
    );

    let total_gas1 = y1 + baseline.all_gas();
    let total_gas2 = y2 + baseline.all_gas();
    assert!(
        test_utils::within_x_percent(6, evm1, total_gas1 / NEAR_GAS_PER_EVM),
        "Incorrect EVM gas used. Expected: {} Actual: {}",
        evm1,
        total_gas1 / NEAR_GAS_PER_EVM
    );
    assert!(
        test_utils::within_x_percent(6, evm2, total_gas2 / NEAR_GAS_PER_EVM),
        "Incorrect EVM gas used. Expected: {} Actual: {}",
        evm2,
        total_gas2 / NEAR_GAS_PER_EVM
    );
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/random.rs ---
use crate::test_utils;
use crate::test_utils::random::{Random, RandomConstructor};
use aurora_engine_types::H256;

#[test]
fn test_random_number_precompile() {
    let random_seed = H256::from_slice(vec![7; 32].as_slice());
    let mut signer = test_utils::Signer::random();
    let mut runner = test_utils::deploy_evm().with_random_seed(random_seed);

    let random_ctr = RandomConstructor::load();
    let nonce = signer.use_nonce();
    let random: Random = runner
        .deploy_contract(&signer.secret_key, |ctr| ctr.deploy(nonce), random_ctr)
        .into();

    let counter_value = random.random_seed(&mut runner, &mut signer);
    assert_eq!(counter_value, random_seed);
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/repro.rs ---
//! A module containing tests which reproduce transactions sent to live networks.

use crate::test_utils::standalone;
use crate::test_utils::{AuroraRunner, ExecutionProfile};
use aurora_engine::parameters::SubmitResult;
use borsh::{BorshDeserialize, BorshSerialize};
use engine_standalone_storage::json_snapshot;

/// This test reproduces a transaction from testnet:
/// https://explorer.testnet.near.org/transactions/GdASJ3KESs8VegpFECTveCwLQp8fxw8yvsauNEmGb6pZ
/// It hit the NEAR gas limit even after the 2.4 engine release and limit increase to 300 Tgas.
/// The purpose of having it here is to be able to track it's performance as we continue to
/// optimize the Engine.
/// The test is somewhat inscrutable because the data was directly pulled from the Engine contract
/// on testnet, but according to the partner that submitted the transaction, the high level
/// description of what is happening is as follows:
/// "flashswap from uniswapv pool with call back to liquidate the user on compound and swap back the seized asset to payback the pool"
#[allow(non_snake_case)]
#[test]
fn repro_GdASJ3KESs() {
    // Note: this snapshot is pruned from the full Engine state on testnet at that block height.
    // The full snapshot is very large, and all that is necessary for this test are the keys used
    // in the transaction. This pruned snapshot contains precisely those keys, and no others.
    repro_common(ReproContext {
        snapshot_path: "src/tests/res/aurora_state_GdASJ3KESs.json",
        block_index: 83596945,
        block_timestamp: 1645717564644206730,
        input_path: "src/tests/res/input_GdASJ3KESs.hex",
        evm_gas_used: 706713,
        near_gas_used: 122,
    });
}

/// This test reproduces a transaction from mainnet:
/// https://explorer.mainnet.near.org/transactions/8ru7VEAEbyfZdbC1W2PYQv2cY3W92rbTToDEN4yTp8aZ
/// It hit the NEAR gas limit even after the 2.5.2 engine release and limit increase to 300 Tgas.
/// The purpose of having it here is to be able to track its performance as we continue to
/// optimize the Engine.
/// The test is somewhat inscrutable because the data was directly pulled from the Engine contract
/// on mainnet, but according to the partner that submitted the transaction, the transaction should
/// be doing something similar to this one on Ethereum itself:
/// https://etherscan.io/tx/0x6c1ccadf6553f4f8bdb475667a91f050b1dfb63ded09053354f1e6fd78ff63a6
#[allow(non_snake_case)]
#[test]
fn repro_8ru7VEA() {
    // Note: this snapshot is pruned from the full Engine state on mainnet at that block height.
    // The full snapshot is very large, and all that is necessary for this test are the keys used
    // in the transaction. This pruned snapshot contains precisely those keys, and no others.
    repro_common(ReproContext {
        snapshot_path: "src/tests/res/aurora_state_8ru7VEA.json",
        block_index: 62625815,
        block_timestamp: 1648829935343349589,
        input_path: "src/tests/res/input_8ru7VEA.hex",
        evm_gas_used: 1732181,
        near_gas_used: 223,
    });
}

/// This test reproduces a transaction from mainnet:
/// https://explorer.mainnet.near.org/transactions/FRcorNvFojoxBrdiVMTy9gRD3H8EYXXKau4feevMZmFV
/// It hit the gas limit at the time of its execution (engine v2.5.2 after 300 Tgas limit increase).
/// The transaction performs some complex defi interaction (description from the user):
/// 1. It sell 30% BSTN to NEAR, and mint cNEAR
/// 2. It sells 35% BSTN to NEAR, and make NEAR-BSTN LP token
/// 3. Deposit LP token created from step2 to Trisolaris farm
#[allow(non_snake_case)]
#[test]
fn repro_FRcorNv() {
    repro_common(ReproContext {
        snapshot_path: "src/tests/res/aurora_state_FRcorNv.json",
        block_index: 64328524,
        block_timestamp: 1650960438774745116,
        input_path: "src/tests/res/input_FRcorNv.hex",
        evm_gas_used: 1239721,
        near_gas_used: 181,
    });
}

/// This test reproduces a transaction from mainnet:
/// https://explorer.mainnet.near.org/transactions/5bEgfRQ5TSJfN9XCqYkMr9cgBLToM7JmS1bNzKpDXJhT
/// It hit the gas limit at the time of its execution (engine v2.5.2 after 300 Tgas limit increase).
/// The transaction is a "claim xp rewards action" from the game CryptoBlades.
#[allow(non_snake_case)]
#[test]
fn repro_5bEgfRQ() {
    repro_common(ReproContext {
        snapshot_path: "src/tests/res/aurora_state_5bEgfRQ.json",
        block_index: 64417403,
        block_timestamp: 1651073772931594646,
        input_path: "src/tests/res/input_5bEgfRQ.hex",
        evm_gas_used: 6_414_105,
        near_gas_used: 657,
    });
}

/// This test reproduces a transaction from mainnet:
/// https://explorer.mainnet.near.org/transactions/D98vwmi44hAYs8KtX5aLne1zEkj3MUss42e5SkG2a4SC
/// It hit the gas limit at the time of its execution (engine v2.5.2 after 300 Tgas limit increase).
/// The transaction is a harvest action for some sort of defi contract. See the report here:
/// https://github.com/aurora-is-near/aurora-relayer/issues/60#issuecomment-1118549256
#[allow(non_snake_case)]
#[test]
fn repro_D98vwmi() {
    repro_common(ReproContext {
        snapshot_path: "src/tests/res/aurora_state_D98vwmi.json",
        block_index: 64945381,
        block_timestamp: 1651753443421003245,
        input_path: "src/tests/res/input_D98vwmi.hex",
        evm_gas_used: 1_035_348,
        near_gas_used: 182,
    });
}

/// This test reproduces a transaction from testnet:
/// https://explorer.testnet.near.org/transactions/Emufid2pv2UpxrZae4NyowF2N2ZHvYEPq16LsQc7Uoc6
/// It hit the gas limit at the time of its execution (engine v2.7.0).
/// The transaction is some kind of multi-step token swap. The user says it should be similar
/// to this transaction on Polygon:
/// https://mumbai.polygonscan.com/tx/0xd9ab182692c74a873f0c444854ed1045edbb32a252b561677042276143a024b7
#[allow(non_snake_case)]
#[test]
fn repro_Emufid2() {
    repro_common(ReproContext {
        snapshot_path: "src/tests/res/aurora_state_Emufid2.json",
        block_index: 99197180,
        block_timestamp: 1662118048636713538,
        input_path: "src/tests/res/input_Emufid2.hex",
        evm_gas_used: 1_156_364,
        near_gas_used: 306,
    });
}

fn repro_common(context: ReproContext) {
    let ReproContext {
        snapshot_path,
        block_index,
        block_timestamp,
        input_path,
        evm_gas_used,
        near_gas_used,
    } = context;

    let snapshot = json_snapshot::types::JsonSnapshot::load_from_file(snapshot_path).unwrap();

    let mut runner = AuroraRunner::default();
    runner.wasm_config.limit_config.max_gas_burnt = 3_000_000_000_000_000;
    runner.context.storage_usage = 1_000_000_000;
    runner.consume_json_snapshot(snapshot.clone());
    runner.context.block_index = block_index;
    runner.context.block_timestamp = block_timestamp;

    let tx_hex = std::fs::read_to_string(input_path).unwrap();
    let tx_bytes = hex::decode(tx_hex.trim()).unwrap();

    let (outcome, error) = runner.call("submit", "relay.aurora", tx_bytes);
    let outcome = outcome.unwrap();
    let profile = ExecutionProfile::new(&outcome);
    if let Some(error) = error {
        panic!("{:?}", error);
    }
    let submit_result =
        SubmitResult::try_from_slice(&outcome.return_data.as_value().unwrap()).unwrap();

    assert_eq!(submit_result.gas_used, evm_gas_used);
    assert_eq!(near_gas_used, profile.all_gas() / 1_000_000_000_000);

    // Also validate the SubmitResult in the standalone engine
    let mut standalone = standalone::StandaloneRunner::default();
    standalone
        .storage
        .set_engine_account_id(&"aurora".parse().unwrap())
        .unwrap();
    json_snapshot::initialize_engine_state(&mut standalone.storage, snapshot).unwrap();
    let standalone_result = standalone
        .submit_raw("submit", &runner.context, &[])
        .unwrap();
    assert_eq!(
        submit_result.try_to_vec().unwrap(),
        standalone_result.try_to_vec().unwrap()
    );
    standalone.close()
}

struct ReproContext<'a> {
    snapshot_path: &'a str,
    block_index: u64,
    block_timestamp: u64,
    input_path: &'a str,
    evm_gas_used: u64,
    near_gas_used: u64,
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/res/33db52b0e7fa03cd84e8c99fea90a1962b4f8d0e63c8bbe4c11373a233dc4f0e_trace.json ---
[
    {
        "depth": 1,
        "gas": 6874,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 0,
        "step": 1
    },
    {
        "depth": 1,
        "gas": 6871,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 2,
        "step": 2
    },
    {
        "depth": 1,
        "gas": 6868,
        "gas_cost": 12,
        "op": 82,
        "opcode_name": "MSTORE",
        "pc": 4,
        "step": 3
    },
    {
        "depth": 1,
        "gas": 6856,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 5,
        "step": 4
    },
    {
        "depth": 1,
        "gas": 6853,
        "gas_cost": 2,
        "op": 54,
        "opcode_name": "CALLDATASIZE",
        "pc": 7,
        "step": 5
    },
    {
        "depth": 1,
        "gas": 6851,
        "gas_cost": 3,
        "op": 16,
        "opcode_name": "LT",
        "pc": 8,
        "step": 6
    },
    {
        "depth": 1,
        "gas": 6848,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 9,
        "step": 7
    },
    {
        "depth": 1,
        "gas": 6845,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 12,
        "step": 8
    },
    {
        "depth": 1,
        "gas": 6835,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 13,
        "step": 9
    },
    {
        "depth": 1,
        "gas": 6832,
        "gas_cost": 3,
        "op": 53,
        "opcode_name": "CALLDATALOAD",
        "pc": 15,
        "step": 10
    },
    {
        "depth": 1,
        "gas": 6829,
        "gas_cost": 3,
        "op": 124,
        "opcode_name": "PUSH29",
        "pc": 16,
        "step": 11
    },
    {
        "depth": 1,
        "gas": 6826,
        "gas_cost": 3,
        "op": 144,
        "opcode_name": "SWAP1",
        "pc": 46,
        "step": 12
    },
    {
        "depth": 1,
        "gas": 6823,
        "gas_cost": 5,
        "op": 4,
        "opcode_name": "DIV",
        "pc": 47,
        "step": 13
    },
    {
        "depth": 1,
        "gas": 6818,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 48,
        "step": 14
    },
    {
        "depth": 1,
        "gas": 6815,
        "gas_cost": 3,
        "op": 22,
        "opcode_name": "AND",
        "pc": 53,
        "step": 15
    },
    {
        "depth": 1,
        "gas": 6812,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 54,
        "step": 16
    },
    {
        "depth": 1,
        "gas": 6809,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 55,
        "step": 17
    },
    {
        "depth": 1,
        "gas": 6806,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 60,
        "step": 18
    },
    {
        "depth": 1,
        "gas": 6803,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 61,
        "step": 19
    },
    {
        "depth": 1,
        "gas": 6800,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 64,
        "step": 20
    },
    {
        "depth": 1,
        "gas": 6790,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 65,
        "step": 21
    },
    {
        "depth": 1,
        "gas": 6787,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 66,
        "step": 22
    },
    {
        "depth": 1,
        "gas": 6784,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 71,
        "step": 23
    },
    {
        "depth": 1,
        "gas": 6781,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 72,
        "step": 24
    },
    {
        "depth": 1,
        "gas": 6778,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 75,
        "step": 25
    },
    {
        "depth": 1,
        "gas": 6768,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 76,
        "step": 26
    },
    {
        "depth": 1,
        "gas": 6765,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 77,
        "step": 27
    },
    {
        "depth": 1,
        "gas": 6762,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 82,
        "step": 28
    },
    {
        "depth": 1,
        "gas": 6759,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 83,
        "step": 29
    },
    {
        "depth": 1,
        "gas": 6756,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 86,
        "step": 30
    },
    {
        "depth": 1,
        "gas": 6746,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 87,
        "step": 31
    },
    {
        "depth": 1,
        "gas": 6743,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 88,
        "step": 32
    },
    {
        "depth": 1,
        "gas": 6740,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 93,
        "step": 33
    },
    {
        "depth": 1,
        "gas": 6737,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 94,
        "step": 34
    },
    {
        "depth": 1,
        "gas": 6734,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 97,
        "step": 35
    },
    {
        "depth": 1,
        "gas": 6724,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 98,
        "step": 36
    },
    {
        "depth": 1,
        "gas": 6721,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 99,
        "step": 37
    },
    {
        "depth": 1,
        "gas": 6718,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 104,
        "step": 38
    },
    {
        "depth": 1,
        "gas": 6715,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 105,
        "step": 39
    },
    {
        "depth": 1,
        "gas": 6712,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 108,
        "step": 40
    },
    {
        "depth": 1,
        "gas": 6702,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 109,
        "step": 41
    },
    {
        "depth": 1,
        "gas": 6699,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 110,
        "step": 42
    },
    {
        "depth": 1,
        "gas": 6696,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 115,
        "step": 43
    },
    {
        "depth": 1,
        "gas": 6693,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 116,
        "step": 44
    },
    {
        "depth": 1,
        "gas": 6690,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 119,
        "step": 45
    },
    {
        "depth": 1,
        "gas": 6680,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 120,
        "step": 46
    },
    {
        "depth": 1,
        "gas": 6677,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 121,
        "step": 47
    },
    {
        "depth": 1,
        "gas": 6674,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 126,
        "step": 48
    },
    {
        "depth": 1,
        "gas": 6671,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 127,
        "step": 49
    },
    {
        "depth": 1,
        "gas": 6668,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 130,
        "step": 50
    },
    {
        "depth": 1,
        "gas": 6658,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 131,
        "step": 51
    },
    {
        "depth": 1,
        "gas": 6655,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 132,
        "step": 52
    },
    {
        "depth": 1,
        "gas": 6652,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 137,
        "step": 53
    },
    {
        "depth": 1,
        "gas": 6649,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 138,
        "step": 54
    },
    {
        "depth": 1,
        "gas": 6646,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 141,
        "step": 55
    },
    {
        "depth": 1,
        "gas": 6636,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 142,
        "step": 56
    },
    {
        "depth": 1,
        "gas": 6633,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 143,
        "step": 57
    },
    {
        "depth": 1,
        "gas": 6630,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 148,
        "step": 58
    },
    {
        "depth": 1,
        "gas": 6627,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 149,
        "step": 59
    },
    {
        "depth": 1,
        "gas": 6624,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 152,
        "step": 60
    },
    {
        "depth": 1,
        "gas": 6614,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 153,
        "step": 61
    },
    {
        "depth": 1,
        "gas": 6611,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 154,
        "step": 62
    },
    {
        "depth": 1,
        "gas": 6608,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 159,
        "step": 63
    },
    {
        "depth": 1,
        "gas": 6605,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 160,
        "step": 64
    },
    {
        "depth": 1,
        "gas": 6602,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 163,
        "step": 65
    },
    {
        "depth": 1,
        "gas": 6592,
        "gas_cost": 1,
        "op": 91,
        "opcode_name": "JUMPDEST",
        "pc": 970,
        "step": 66
    },
    {
        "depth": 1,
        "gas": 6591,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 971,
        "step": 67
    },
    {
        "depth": 1,
        "gas": 6588,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 974,
        "step": 68
    },
    {
        "depth": 1,
        "gas": 6585,
        "gas_cost": 8,
        "op": 86,
        "opcode_name": "JUMP",
        "pc": 977,
        "step": 69
    },
    {
        "depth": 1,
        "gas": 6577,
        "gas_cost": 1,
        "op": 91,
        "opcode_name": "JUMPDEST",
        "pc": 1088,
        "step": 70
    },
    {
        "depth": 1,
        "gas": 6576,
        "gas_cost": 2,
        "op": 52,
        "opcode_name": "CALLVALUE",
        "pc": 1089,
        "step": 71
    },
    {
        "depth": 1,
        "gas": 6574,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1090,
        "step": 72
    },
    {
        "depth": 1,
        "gas": 6571,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1092,
        "step": 73
    },
    {
        "depth": 1,
        "gas": 6568,
        "gas_cost": 2,
        "op": 51,
        "opcode_name": "CALLER",
        "pc": 1094,
        "step": 74
    },
    {
        "depth": 1,
        "gas": 6566,
        "gas_cost": 3,
        "op": 115,
        "opcode_name": "PUSH20",
        "pc": 1095,
        "step": 75
    },
    {
        "depth": 1,
        "gas": 6563,
        "gas_cost": 3,
        "op": 22,
        "opcode_name": "AND",
        "pc": 1116,
        "step": 76
    },
    {
        "depth": 1,
        "gas": 6560,
        "gas_cost": 3,
        "op": 115,
        "opcode_name": "PUSH20",
        "pc": 1117,
        "step": 77
    },
    {
        "depth": 1,
        "gas": 6557,
        "gas_cost": 3,
        "op": 22,
        "opcode_name": "AND",
        "pc": 1138,
        "step": 78
    },
    {
        "depth": 1,
        "gas": 6554,
        "gas_cost": 3,
        "op": 129,
        "opcode_name": "DUP2",
        "pc": 1139,
        "step": 79
    },
    {
        "depth": 1,
        "gas": 6551,
        "gas_cost": 3,
        "op": 82,
        "opcode_name": "MSTORE",
        "pc": 1140,
        "step": 80
    },
    {
        "depth": 1,
        "gas": 6548,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1141,
        "step": 81
    },
    {
        "depth": 1,
        "gas": 6545,
        "gas_cost": 3,
        "op": 1,
        "opcode_name": "ADD",
        "pc": 1143,
        "step": 82
    },
    {
        "depth": 1,
        "gas": 6542,
        "gas_cost": 3,
        "op": 144,
        "opcode_name": "SWAP1",
        "pc": 1144,
        "step": 83
    },
    {
        "depth": 1,
        "gas": 6539,
        "gas_cost": 3,
        "op": 129,
        "opcode_name": "DUP2",
        "pc": 1145,
        "step": 84
    },
    {
        "depth": 1,
        "gas": 6536,
        "gas_cost": 3,
        "op": 82,
        "opcode_name": "MSTORE",
        "pc": 1146,
        "step": 85
    },
    {
        "depth": 1,
        "gas": 6533,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1147,
        "step": 86
    },
    {
        "depth": 1,
        "gas": 6530,
        "gas_cost": 3,
        "op": 1,
        "opcode_name": "ADD",
        "pc": 1149,
        "step": 87
    },
    {
        "depth": 1,
        "gas": 6527,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1150,
        "step": 88
    },
    {
        "depth": 1,
        "gas": 6524,
        "gas_cost": 42,
        "op": 32,
        "opcode_name": "SHA3",
        "pc": 1152,
        "step": 89
    },
    {
        "depth": 1,
        "gas": 6482,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1153,
        "step": 90
    },
    {
        "depth": 1,
        "gas": 6479,
        "gas_cost": 3,
        "op": 130,
        "opcode_name": "DUP3",
        "pc": 1155,
        "step": 91
    },
    {
        "depth": 1,
        "gas": 6476,
        "gas_cost": 3,
        "op": 130,
        "opcode_name": "DUP3",
        "pc": 1156,
        "step": 92
    },
    {
        "depth": 1,
        "gas": 6473,
        "gas_cost": 2100,
        "op": 84,
        "opcode_name": "SLOAD",
        "pc": 1157,
        "step": 93
    },
    {
        "depth": 1,
        "gas": 4373,
        "gas_cost": 3,
        "op": 1,
        "opcode_name": "ADD",
        "pc": 1158,
        "step": 94
    },
    {
        "depth": 1,
        "gas": 4370,
        "gas_cost": 3,
        "op": 146,
        "opcode_name": "SWAP3",
        "pc": 1159,
        "step": 95
    },
    {
        "depth": 1,
        "gas": 4367,
        "gas_cost": 2,
        "op": 80,
        "opcode_name": "POP",
        "pc": 1160,
        "step": 96
    },
    {
        "depth": 1,
        "gas": 4365,
        "gas_cost": 2,
        "op": 80,
        "opcode_name": "POP",
        "pc": 1161,
        "step": 97
    },
    {
        "depth": 1,
        "gas": 4363,
        "gas_cost": 3,
        "op": 129,
        "opcode_name": "DUP2",
        "pc": 1162,
        "step": 98
    },
    {
        "depth": 1,
        "gas": 4360,
        "gas_cost": 3,
        "op": 144,
        "opcode_name": "SWAP1",
        "pc": 1163,
        "step": 99
    },
    {
        "depth": 1,
        "gas": 4357,
        "gas_cost": 2900,
        "op": 85,
        "opcode_name": "SSTORE",
        "pc": 1164,
        "step": 100
    },
    {
        "depth": 1,
        "gas": 1457,
        "gas_cost": 2,
        "op": 80,
        "opcode_name": "POP",
        "pc": 1165,
        "step": 101
    },
    {
        "depth": 1,
        "gas": 1455,
        "gas_cost": 2,
        "op": 51,
        "opcode_name": "CALLER",
        "pc": 1166,
        "step": 102
    },
    {
        "depth": 1,
        "gas": 1453,
        "gas_cost": 3,
        "op": 115,
        "opcode_name": "PUSH20",
        "pc": 1167,
        "step": 103
    },
    {
        "depth": 1,
        "gas": 1450,
        "gas_cost": 3,
        "op": 22,
        "opcode_name": "AND",
        "pc": 1188,
        "step": 104
    },
    {
        "depth": 1,
        "gas": 1447,
        "gas_cost": 3,
        "op": 127,
        "opcode_name": "PUSH32",
        "pc": 1189,
        "step": 105
    },
    {
        "depth": 1,
        "gas": 1444,
        "gas_cost": 2,
        "op": 52,
        "opcode_name": "CALLVALUE",
        "pc": 1222,
        "step": 106
    },
    {
        "depth": 1,
        "gas": 1442,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1223,
        "step": 107
    },
    {
        "depth": 1,
        "gas": 1439,
        "gas_cost": 3,
        "op": 81,
        "opcode_name": "MLOAD",
        "pc": 1225,
        "step": 108
    },
    {
        "depth": 1,
        "gas": 1436,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 1226,
        "step": 109
    },
    {
        "depth": 1,
        "gas": 1433,
        "gas_cost": 3,
        "op": 130,
        "opcode_name": "DUP3",
        "pc": 1227,
        "step": 110
    },
    {
        "depth": 1,
        "gas": 1430,
        "gas_cost": 3,
        "op": 129,
        "opcode_name": "DUP2",
        "pc": 1228,
        "step": 111
    },
    {
        "depth": 1,
        "gas": 1427,
        "gas_cost": 6,
        "op": 82,
        "opcode_name": "MSTORE",
        "pc": 1229,
        "step": 112
    },
    {
        "depth": 1,
        "gas": 1421,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1230,
        "step": 113
    },
    {
        "depth": 1,
        "gas": 1418,
        "gas_cost": 3,
        "op": 1,
        "opcode_name": "ADD",
        "pc": 1232,
        "step": 114
    },
    {
        "depth": 1,
        "gas": 1415,
        "gas_cost": 3,
        "op": 145,
        "opcode_name": "SWAP2",
        "pc": 1233,
        "step": 115
    },
    {
        "depth": 1,
        "gas": 1412,
        "gas_cost": 2,
        "op": 80,
        "opcode_name": "POP",
        "pc": 1234,
        "step": 116
    },
    {
        "depth": 1,
        "gas": 1410,
        "gas_cost": 2,
        "op": 80,
        "opcode_name": "POP",
        "pc": 1235,
        "step": 117
    },
    {
        "depth": 1,
        "gas": 1408,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1236,
        "step": 118
    },
    {
        "depth": 1,
        "gas": 1405,
        "gas_cost": 3,
        "op": 81,
        "opcode_name": "MLOAD",
        "pc": 1238,
        "step": 119
    },
    {
        "depth": 1,
        "gas": 1402,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 1239,
        "step": 120
    },
    {
        "depth": 1,
        "gas": 1399,
        "gas_cost": 3,
        "op": 145,
        "opcode_name": "SWAP2",
        "pc": 1240,
        "step": 121
    },
    {
        "depth": 1,
        "gas": 1396,
        "gas_cost": 3,
        "op": 3,
        "opcode_name": "SUB",
        "pc": 1241,
        "step": 122
    },
    {
        "depth": 1,
        "gas": 1393,
        "gas_cost": 3,
        "op": 144,
        "opcode_name": "SWAP1",
        "pc": 1242,
        "step": 123
    },
    {
        "depth": 1,
        "gas": 1390,
        "gas_cost": 1381,
        "op": 162,
        "opcode_name": "LOG2",
        "pc": 1243,
        "step": 124
    },
    {
        "depth": 1,
        "gas": 9,
        "gas_cost": 8,
        "op": 86,
        "opcode_name": "JUMP",
        "pc": 1244,
        "step": 125
    },
    {
        "depth": 1,
        "gas": 1,
        "gas_cost": 1,
        "op": 91,
        "opcode_name": "JUMPDEST",
        "pc": 978,
        "step": 126
    },
    {
        "depth": 1,
        "gas": 0,
        "gas_cost": 0,
        "op": 0,
        "opcode_name": "STOP",
        "pc": 979,
        "step": 127
    }
]
'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/res/79f7f8f9b3ad98f29a3df5cbed1556397089701c3ce007c2844605849dfb0ad4_trace.json ---
[
    {
        "depth": 1,
        "gas": 23974,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 0,
        "step": 1
    },
    {
        "depth": 1,
        "gas": 23971,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 2,
        "step": 2
    },
    {
        "depth": 1,
        "gas": 23968,
        "gas_cost": 12,
        "op": 82,
        "opcode_name": "MSTORE",
        "pc": 4,
        "step": 3
    },
    {
        "depth": 1,
        "gas": 23956,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 5,
        "step": 4
    },
    {
        "depth": 1,
        "gas": 23953,
        "gas_cost": 2,
        "op": 54,
        "opcode_name": "CALLDATASIZE",
        "pc": 7,
        "step": 5
    },
    {
        "depth": 1,
        "gas": 23951,
        "gas_cost": 3,
        "op": 16,
        "opcode_name": "LT",
        "pc": 8,
        "step": 6
    },
    {
        "depth": 1,
        "gas": 23948,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 9,
        "step": 7
    },
    {
        "depth": 1,
        "gas": 23945,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 12,
        "step": 8
    },
    {
        "depth": 1,
        "gas": 23935,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 13,
        "step": 9
    },
    {
        "depth": 1,
        "gas": 23932,
        "gas_cost": 3,
        "op": 53,
        "opcode_name": "CALLDATALOAD",
        "pc": 15,
        "step": 10
    },
    {
        "depth": 1,
        "gas": 23929,
        "gas_cost": 3,
        "op": 124,
        "opcode_name": "PUSH29",
        "pc": 16,
        "step": 11
    },
    {
        "depth": 1,
        "gas": 23926,
        "gas_cost": 3,
        "op": 144,
        "opcode_name": "SWAP1",
        "pc": 46,
        "step": 12
    },
    {
        "depth": 1,
        "gas": 23923,
        "gas_cost": 5,
        "op": 4,
        "opcode_name": "DIV",
        "pc": 47,
        "step": 13
    },
    {
        "depth": 1,
        "gas": 23918,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 48,
        "step": 14
    },
    {
        "depth": 1,
        "gas": 23915,
        "gas_cost": 3,
        "op": 22,
        "opcode_name": "AND",
        "pc": 53,
        "step": 15
    },
    {
        "depth": 1,
        "gas": 23912,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 54,
        "step": 16
    },
    {
        "depth": 1,
        "gas": 23909,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 55,
        "step": 17
    },
    {
        "depth": 1,
        "gas": 23906,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 60,
        "step": 18
    },
    {
        "depth": 1,
        "gas": 23903,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 61,
        "step": 19
    },
    {
        "depth": 1,
        "gas": 23900,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 64,
        "step": 20
    },
    {
        "depth": 1,
        "gas": 23890,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 65,
        "step": 21
    },
    {
        "depth": 1,
        "gas": 23887,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 66,
        "step": 22
    },
    {
        "depth": 1,
        "gas": 23884,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 71,
        "step": 23
    },
    {
        "depth": 1,
        "gas": 23881,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 72,
        "step": 24
    },
    {
        "depth": 1,
        "gas": 23878,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 75,
        "step": 25
    },
    {
        "depth": 1,
        "gas": 23868,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 76,
        "step": 26
    },
    {
        "depth": 1,
        "gas": 23865,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 77,
        "step": 27
    },
    {
        "depth": 1,
        "gas": 23862,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 82,
        "step": 28
    },
    {
        "depth": 1,
        "gas": 23859,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 83,
        "step": 29
    },
    {
        "depth": 1,
        "gas": 23856,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 86,
        "step": 30
    },
    {
        "depth": 1,
        "gas": 23846,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 87,
        "step": 31
    },
    {
        "depth": 1,
        "gas": 23843,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 88,
        "step": 32
    },
    {
        "depth": 1,
        "gas": 23840,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 93,
        "step": 33
    },
    {
        "depth": 1,
        "gas": 23837,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 94,
        "step": 34
    },
    {
        "depth": 1,
        "gas": 23834,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 97,
        "step": 35
    },
    {
        "depth": 1,
        "gas": 23824,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 98,
        "step": 36
    },
    {
        "depth": 1,
        "gas": 23821,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 99,
        "step": 37
    },
    {
        "depth": 1,
        "gas": 23818,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 104,
        "step": 38
    },
    {
        "depth": 1,
        "gas": 23815,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 105,
        "step": 39
    },
    {
        "depth": 1,
        "gas": 23812,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 108,
        "step": 40
    },
    {
        "depth": 1,
        "gas": 23802,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 109,
        "step": 41
    },
    {
        "depth": 1,
        "gas": 23799,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 110,
        "step": 42
    },
    {
        "depth": 1,
        "gas": 23796,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 115,
        "step": 43
    },
    {
        "depth": 1,
        "gas": 23793,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 116,
        "step": 44
    },
    {
        "depth": 1,
        "gas": 23790,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 119,
        "step": 45
    },
    {
        "depth": 1,
        "gas": 23780,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 120,
        "step": 46
    },
    {
        "depth": 1,
        "gas": 23777,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 121,
        "step": 47
    },
    {
        "depth": 1,
        "gas": 23774,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 126,
        "step": 48
    },
    {
        "depth": 1,
        "gas": 23771,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 127,
        "step": 49
    },
    {
        "depth": 1,
        "gas": 23768,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 130,
        "step": 50
    },
    {
        "depth": 1,
        "gas": 23758,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 131,
        "step": 51
    },
    {
        "depth": 1,
        "gas": 23755,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 132,
        "step": 52
    },
    {
        "depth": 1,
        "gas": 23752,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 137,
        "step": 53
    },
    {
        "depth": 1,
        "gas": 23749,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 138,
        "step": 54
    },
    {
        "depth": 1,
        "gas": 23746,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 141,
        "step": 55
    },
    {
        "depth": 1,
        "gas": 23736,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 142,
        "step": 56
    },
    {
        "depth": 1,
        "gas": 23733,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 143,
        "step": 57
    },
    {
        "depth": 1,
        "gas": 23730,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 148,
        "step": 58
    },
    {
        "depth": 1,
        "gas": 23727,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 149,
        "step": 59
    },
    {
        "depth": 1,
        "gas": 23724,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 152,
        "step": 60
    },
    {
        "depth": 1,
        "gas": 23714,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 153,
        "step": 61
    },
    {
        "depth": 1,
        "gas": 23711,
        "gas_cost": 3,
        "op": 99,
        "opcode_name": "PUSH4",
        "pc": 154,
        "step": 62
    },
    {
        "depth": 1,
        "gas": 23708,
        "gas_cost": 3,
        "op": 20,
        "opcode_name": "EQ",
        "pc": 159,
        "step": 63
    },
    {
        "depth": 1,
        "gas": 23705,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 160,
        "step": 64
    },
    {
        "depth": 1,
        "gas": 23702,
        "gas_cost": 10,
        "op": 87,
        "opcode_name": "JUMPI",
        "pc": 163,
        "step": 65
    },
    {
        "depth": 1,
        "gas": 23692,
        "gas_cost": 1,
        "op": 91,
        "opcode_name": "JUMPDEST",
        "pc": 970,
        "step": 66
    },
    {
        "depth": 1,
        "gas": 23691,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 971,
        "step": 67
    },
    {
        "depth": 1,
        "gas": 23688,
        "gas_cost": 3,
        "op": 97,
        "opcode_name": "PUSH2",
        "pc": 974,
        "step": 68
    },
    {
        "depth": 1,
        "gas": 23685,
        "gas_cost": 8,
        "op": 86,
        "opcode_name": "JUMP",
        "pc": 977,
        "step": 69
    },
    {
        "depth": 1,
        "gas": 23677,
        "gas_cost": 1,
        "op": 91,
        "opcode_name": "JUMPDEST",
        "pc": 1088,
        "step": 70
    },
    {
        "depth": 1,
        "gas": 23676,
        "gas_cost": 2,
        "op": 52,
        "opcode_name": "CALLVALUE",
        "pc": 1089,
        "step": 71
    },
    {
        "depth": 1,
        "gas": 23674,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1090,
        "step": 72
    },
    {
        "depth": 1,
        "gas": 23671,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1092,
        "step": 73
    },
    {
        "depth": 1,
        "gas": 23668,
        "gas_cost": 2,
        "op": 51,
        "opcode_name": "CALLER",
        "pc": 1094,
        "step": 74
    },
    {
        "depth": 1,
        "gas": 23666,
        "gas_cost": 3,
        "op": 115,
        "opcode_name": "PUSH20",
        "pc": 1095,
        "step": 75
    },
    {
        "depth": 1,
        "gas": 23663,
        "gas_cost": 3,
        "op": 22,
        "opcode_name": "AND",
        "pc": 1116,
        "step": 76
    },
    {
        "depth": 1,
        "gas": 23660,
        "gas_cost": 3,
        "op": 115,
        "opcode_name": "PUSH20",
        "pc": 1117,
        "step": 77
    },
    {
        "depth": 1,
        "gas": 23657,
        "gas_cost": 3,
        "op": 22,
        "opcode_name": "AND",
        "pc": 1138,
        "step": 78
    },
    {
        "depth": 1,
        "gas": 23654,
        "gas_cost": 3,
        "op": 129,
        "opcode_name": "DUP2",
        "pc": 1139,
        "step": 79
    },
    {
        "depth": 1,
        "gas": 23651,
        "gas_cost": 3,
        "op": 82,
        "opcode_name": "MSTORE",
        "pc": 1140,
        "step": 80
    },
    {
        "depth": 1,
        "gas": 23648,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1141,
        "step": 81
    },
    {
        "depth": 1,
        "gas": 23645,
        "gas_cost": 3,
        "op": 1,
        "opcode_name": "ADD",
        "pc": 1143,
        "step": 82
    },
    {
        "depth": 1,
        "gas": 23642,
        "gas_cost": 3,
        "op": 144,
        "opcode_name": "SWAP1",
        "pc": 1144,
        "step": 83
    },
    {
        "depth": 1,
        "gas": 23639,
        "gas_cost": 3,
        "op": 129,
        "opcode_name": "DUP2",
        "pc": 1145,
        "step": 84
    },
    {
        "depth": 1,
        "gas": 23636,
        "gas_cost": 3,
        "op": 82,
        "opcode_name": "MSTORE",
        "pc": 1146,
        "step": 85
    },
    {
        "depth": 1,
        "gas": 23633,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1147,
        "step": 86
    },
    {
        "depth": 1,
        "gas": 23630,
        "gas_cost": 3,
        "op": 1,
        "opcode_name": "ADD",
        "pc": 1149,
        "step": 87
    },
    {
        "depth": 1,
        "gas": 23627,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1150,
        "step": 88
    },
    {
        "depth": 1,
        "gas": 23624,
        "gas_cost": 42,
        "op": 32,
        "opcode_name": "SHA3",
        "pc": 1152,
        "step": 89
    },
    {
        "depth": 1,
        "gas": 23582,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1153,
        "step": 90
    },
    {
        "depth": 1,
        "gas": 23579,
        "gas_cost": 3,
        "op": 130,
        "opcode_name": "DUP3",
        "pc": 1155,
        "step": 91
    },
    {
        "depth": 1,
        "gas": 23576,
        "gas_cost": 3,
        "op": 130,
        "opcode_name": "DUP3",
        "pc": 1156,
        "step": 92
    },
    {
        "depth": 1,
        "gas": 23573,
        "gas_cost": 2100,
        "op": 84,
        "opcode_name": "SLOAD",
        "pc": 1157,
        "step": 93
    },
    {
        "depth": 1,
        "gas": 21473,
        "gas_cost": 3,
        "op": 1,
        "opcode_name": "ADD",
        "pc": 1158,
        "step": 94
    },
    {
        "depth": 1,
        "gas": 21470,
        "gas_cost": 3,
        "op": 146,
        "opcode_name": "SWAP3",
        "pc": 1159,
        "step": 95
    },
    {
        "depth": 1,
        "gas": 21467,
        "gas_cost": 2,
        "op": 80,
        "opcode_name": "POP",
        "pc": 1160,
        "step": 96
    },
    {
        "depth": 1,
        "gas": 21465,
        "gas_cost": 2,
        "op": 80,
        "opcode_name": "POP",
        "pc": 1161,
        "step": 97
    },
    {
        "depth": 1,
        "gas": 21463,
        "gas_cost": 3,
        "op": 129,
        "opcode_name": "DUP2",
        "pc": 1162,
        "step": 98
    },
    {
        "depth": 1,
        "gas": 21460,
        "gas_cost": 3,
        "op": 144,
        "opcode_name": "SWAP1",
        "pc": 1163,
        "step": 99
    },
    {
        "depth": 1,
        "gas": 21457,
        "gas_cost": 20000,
        "op": 85,
        "opcode_name": "SSTORE",
        "pc": 1164,
        "step": 100
    },
    {
        "depth": 1,
        "gas": 1457,
        "gas_cost": 2,
        "op": 80,
        "opcode_name": "POP",
        "pc": 1165,
        "step": 101
    },
    {
        "depth": 1,
        "gas": 1455,
        "gas_cost": 2,
        "op": 51,
        "opcode_name": "CALLER",
        "pc": 1166,
        "step": 102
    },
    {
        "depth": 1,
        "gas": 1453,
        "gas_cost": 3,
        "op": 115,
        "opcode_name": "PUSH20",
        "pc": 1167,
        "step": 103
    },
    {
        "depth": 1,
        "gas": 1450,
        "gas_cost": 3,
        "op": 22,
        "opcode_name": "AND",
        "pc": 1188,
        "step": 104
    },
    {
        "depth": 1,
        "gas": 1447,
        "gas_cost": 3,
        "op": 127,
        "opcode_name": "PUSH32",
        "pc": 1189,
        "step": 105
    },
    {
        "depth": 1,
        "gas": 1444,
        "gas_cost": 2,
        "op": 52,
        "opcode_name": "CALLVALUE",
        "pc": 1222,
        "step": 106
    },
    {
        "depth": 1,
        "gas": 1442,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1223,
        "step": 107
    },
    {
        "depth": 1,
        "gas": 1439,
        "gas_cost": 3,
        "op": 81,
        "opcode_name": "MLOAD",
        "pc": 1225,
        "step": 108
    },
    {
        "depth": 1,
        "gas": 1436,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 1226,
        "step": 109
    },
    {
        "depth": 1,
        "gas": 1433,
        "gas_cost": 3,
        "op": 130,
        "opcode_name": "DUP3",
        "pc": 1227,
        "step": 110
    },
    {
        "depth": 1,
        "gas": 1430,
        "gas_cost": 3,
        "op": 129,
        "opcode_name": "DUP2",
        "pc": 1228,
        "step": 111
    },
    {
        "depth": 1,
        "gas": 1427,
        "gas_cost": 6,
        "op": 82,
        "opcode_name": "MSTORE",
        "pc": 1229,
        "step": 112
    },
    {
        "depth": 1,
        "gas": 1421,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1230,
        "step": 113
    },
    {
        "depth": 1,
        "gas": 1418,
        "gas_cost": 3,
        "op": 1,
        "opcode_name": "ADD",
        "pc": 1232,
        "step": 114
    },
    {
        "depth": 1,
        "gas": 1415,
        "gas_cost": 3,
        "op": 145,
        "opcode_name": "SWAP2",
        "pc": 1233,
        "step": 115
    },
    {
        "depth": 1,
        "gas": 1412,
        "gas_cost": 2,
        "op": 80,
        "opcode_name": "POP",
        "pc": 1234,
        "step": 116
    },
    {
        "depth": 1,
        "gas": 1410,
        "gas_cost": 2,
        "op": 80,
        "opcode_name": "POP",
        "pc": 1235,
        "step": 117
    },
    {
        "depth": 1,
        "gas": 1408,
        "gas_cost": 3,
        "op": 96,
        "opcode_name": "PUSH1",
        "pc": 1236,
        "step": 118
    },
    {
        "depth": 1,
        "gas": 1405,
        "gas_cost": 3,
        "op": 81,
        "opcode_name": "MLOAD",
        "pc": 1238,
        "step": 119
    },
    {
        "depth": 1,
        "gas": 1402,
        "gas_cost": 3,
        "op": 128,
        "opcode_name": "DUP1",
        "pc": 1239,
        "step": 120
    },
    {
        "depth": 1,
        "gas": 1399,
        "gas_cost": 3,
        "op": 145,
        "opcode_name": "SWAP2",
        "pc": 1240,
        "step": 121
    },
    {
        "depth": 1,
        "gas": 1396,
        "gas_cost": 3,
        "op": 3,
        "opcode_name": "SUB",
        "pc": 1241,
        "step": 122
    },
    {
        "depth": 1,
        "gas": 1393,
        "gas_cost": 3,
        "op": 144,
        "opcode_name": "SWAP1",
        "pc": 1242,
        "step": 123
    },
    {
        "depth": 1,
        "gas": 1390,
        "gas_cost": 1381,
        "op": 162,
        "opcode_name": "LOG2",
        "pc": 1243,
        "step": 124
    },
    {
        "depth": 1,
        "gas": 9,
        "gas_cost": 8,
        "op": 86,
        "opcode_name": "JUMP",
        "pc": 1244,
        "step": 125
    },
    {
        "depth": 1,
        "gas": 1,
        "gas_cost": 1,
        "op": 91,
        "opcode_name": "JUMPDEST",
        "pc": 978,
        "step": 126
    },
    {
        "depth": 1,
        "gas": 0,
        "gas_cost": 0,
        "op": 0,
        "opcode_name": "STOP",
        "pc": 979,
        "step": 127
    }
]
'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/res/aurora_state_5bEgfRQ.json ---
{
    "id": "1",
    "jsonrpc": "2.0",
    "result": {
        "block_hash": "8jy95G6qWUMRMG7R2Q12DGV1ZFSBoSVGSYQ8iPcaXSGS",
        "block_height": 64417402,
        "proof": [],
        "values": [
            {
                "key": "BwBTVEFURQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5FQVIGAAAAYXVyb3JhAAAAAAAAAAAAAAAA"
            },
            {
                "key": "BwE6cnmGam5+n4bFr9VpYTHlySlWrw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwE/cVmVZH/kTbRUEbuegbehrVqDhw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFBk3kdtZIAYIVij244XPFxO/nXAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGCHhg4nymDw7S6VFHSk9S97oqHhg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGW+yTl4O32PpPAgax7yC9ltzQESw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMs="
            },
            {
                "key": "BwI6cnmGam5+n4bFr9VpYTHlySlWrw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwI/cVmVZH/kTbRUEbuegbehrVqDhw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJBk3kdtZIAYIVij244XPFxO/nXAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJrGVnnAwPjNNfLV3IixilrwTL67Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABVaa/lgjGrQ0="
            },
            {
                "key": "BwKCHhg4nymDw7S6VFHSk9S97oqHhg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKW+yTl4O32PpPAgax7yC9ltzQESw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQJHIgte4A="
            },
            {
                "key": "BwM6cnmGam5+n4bFr9VpYTHlySlWrw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwM/cVmVZH/kTbRUEbuegbehrVqDhw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwNBk3kdtZIAYIVij244XPFxO/nXAA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOCHhg4nymDw7S6VFHSk9S97oqHhg==",
                "proof": [],
                "value": "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ZXNzRVJDNzIxOiBvcGVyYXRvciBxdWVyeSBmb3Igbm9uZXhpc3RlbnQgdG9rZW5BY2Nlc3NDb250cm9sOiBzZW5kZXIgbXVzdCBiZSBhbiBhZG1pbiB0byByZXZva2VFUkM3MjE6IGFwcHJvdmUgY2FsbGVyIGlzIG5vdCBvd25lciBub3IgYXBwcm92ZWQgZm9yIGFsbEVSQzcyMTogYmFsYW5jZSBxdWVyeSBmb3IgdGhlIHplcm8gYWRkcmVzc0VSQzcyMTogb3duZXIgcXVlcnkgZm9yIG5vbmV4aXN0ZW50IHRva2VuSW5pdGlhbGl6YWJsZTogY29udHJhY3QgaXMgYWxyZWFkeSBpbml0aWFsaXplZEVudW1lcmFibGVNYXA6IGluZGV4IG91dCBvZiBib3VuZHNTYWZlTWF0aDogbXVsdGlwbGljYXRpb24gb3ZlcmZsb3dFUkM3MjE6IGFwcHJvdmVkIHF1ZXJ5IGZvciBub25leGlzdGVudCB0b2tlbkVSQzcyMTogdHJhbnNmZXIgb2YgdG9rZW4gdGhhdCBpcyBub3Qgb3duRVJDNzIxTWV0YWRhdGE6IFVSSSBxdWVyeSBmb3Igbm9uZXhpc3RlbnQgdG9rZW5FUkM3MjE6IGFwcHJvdmFsIHRvIGN1cnJlbnQgb3duZXJFUkM3MjE6IHRyYW5zZmVyIGNhbGxlciBpcyBub3Qgb3duZXIgbm9yIGFwcHJvdmVkQWNjZXNzQ29udHJvbDogY2FuIG9ubHkgcmVub3VuY2Ugcm9sZXMgZm9yIHNlbGaiZGlwZnNYIhIgywyec8XyVgOafC2GaUMeeXkR2JYSYcgQmOq1DXLDvntkc29sY0MABgUAMw=="
            },
            {
                "key": "BwQ6cnmGam5+n4bFr9VpYTHlySlWrwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABm",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKo="
            },
            {
                "key": "BwQ6cnmGam5+n4bFr9VpYTHlySlWrwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKo="
            },
            {
                "key": "BwQ6cnmGam5+n4bFr9VpYTHlySlWrwjfGqL38rxZUYIyh6MxSgy31UDeakYHLWX6HQuho/nt",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwQ6cnmGam5+n4bFr9VpYTHlySlWrzYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAgh4YOJ8pg8O0ulRR0pPUve6Kh4Y="
            },
            {
                "key": "BwQ6cnmGam5+n4bFr9VpYTHlySlWr0ZQGHm4yoUl6ML9UZ4vv8+i6+omUBKUqgLL/PsS6USn",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAlvsk5eDt9j6TwIGse8gvZbc0BEs="
            },
            {
                "key": "BwQ6cnmGam5+n4bFr9VpYTHlySlWr2a+TxVcXvLr03crIo8vAGgeTtWCbNs7GUPMEa0VrR3R",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYmlhuQEAAAA="
            },
            {
                "key": "BwQ6cnmGam5+n4bFr9VpYTHlySlWr2btFaofQan/AfWgnpKr1cYK7KoS9ujvvC85ALyxwnBo",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKo="
            },
            {
                "key": "BwQ6cnmGam5+n4bFr9VpYTHlySlWr7UxJ2hKVosxc64TufimAW4kPmO26O4ReNanF4ULXWED",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA7sukTeGZ/lTI+RTDojcc+bvPZxE="
            },
            {
                "key": "BwQ6cnmGam5+n4bFr9VpYTHlySlWr8GPNrcpfhVp4B7ISyQ+yVrNul7atQjdJPwNoz5A4mfM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKk="
            },
            {
                "key": "BwQ6cnmGam5+n4bFr9VpYTHlySlWr+y2OuBLzFUpDEp3pftPEuL8k2u6tDvYfX4bZvYyR5Nz",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwQ/cVmVZH/kTbRUEbuegbehrVqDhwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABl",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAOnJ5hmpufp+Gxa/VaWEx5ckpVq8="
            },
            {
                "key": "BwQ/cVmVZH/kTbRUEbuegbehrVqDhzXYtCrv/ei5GiD065rXf5ljTQfkwZHq4XPXoGFXo5Wi",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHY="
            },
            {
                "key": "BwQ/cVmVZH/kTbRUEbuegbehrVqDhzYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAQZN5HbWSAGCFYo9uOFzxcTv51wA="
            },
            {
                "key": "BwQ/cVmVZH/kTbRUEbuegbehrVqDh7UxJ2hKVosxc64TufimAW4kPmO26O4ReNanF4ULXWED",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA7sukTeGZ/lTI+RTDojcc+bvPZxE="
            }
        ]
    }
}
'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/res/aurora_state_8ru7VEA.json ---
{
    "id": "1",
    "jsonrpc": "2.0",
    "result": {
        "block_hash": "EZyYk1jni7ACJspCYwdVu6rQ5jhePxgZQWWgJBDhifGe",
        "block_height": 62625814,
        "proof": [],
        "values": [
            {
                "key": "BwBTVEFURQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5FQVIGAAAAYXVyb3JhAAAAAAAAAAAAAAAA"
            },
            {
                "key": "BwECUtQOC63tWZB635CLJC5Cm2kP7Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEEoameaM8GfSM1bezbughHzExVXw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEPrQ7YSKehZSbop1dOQYsBXb9BtQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwESyHMx8IbDySYkj5ZPhwLAhC/Xfw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEkiGgR0tXjYv9pEJrtCm7j7u7ACw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwElbQNgfu4BVriiq4TaHVsoMhn+lw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEwusoniC2wlOoQZKI+KGbfrPxYSA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwE15H61pE+qvLI1DIM69RYuNeSvjQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFW2IIjU3mHFEwgC0nxu750U5VGvg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8="
            },
            {
                "key": "BwFb2sYIzTjFyHOPW+IIExlKMVDU/w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFjtKBTjOjZCHayAa8QINEzCKiyUw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFkJHMr12cvzA2jfR5wo4o8isX4Bw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFrw/ZfxQ5JBg4h7WmWvpbuS0BHUg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwF+nqEOWYSgnRnQXzHKPLZbt981nQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwF/qmT69UdQouPuYhFmY1/q9AarIg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGEsSOHXw82uWbQtsoUsxEhvZZ2rQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGIX4z25FvdP9zcZE79zQrJOIDHgQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGL7EeGWt47FyqSjfj5kLx/KjufeQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGhsXQunDLHyqlybYIEvVcV40GYYQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGjoe9a5lYVcgIzY4YuI4r6hMcu9Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGpyX/4Jdud1TBW1lrnBAMbSVnZmg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwG64NffzQPJDrzgA8WDMsE0anKDag==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwG/nu9jE5tn/Qq/Ir1VBKywUZpCEg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHDdHds9cSXre72tQVYiwDLKYUx/Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHF4drsKtQB6+vdPjJRbZCrJRo6ow==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGg="
            },
            {
                "key": "BwHGw8yE6r1GQ8OCyYj6KDBlf8cKaw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHJve7TPNAVQeHu0Q+QUZ0sBv4/6w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHLqM/E5AwTP9nVwJJ2SebZl0ExKA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHc1tTis+HR4eb6jCHIoyPcvs/5cA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHhcf+l+ZGtzyfUJ80Pgvzj8s0GIA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwH6lDSEZ/ZNWkV/dfi8QEldM8Zauw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwICUtQOC63tWZB635CLJC5Cm2kP7Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIEoameaM8GfSM1bezbughHzExVXw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIPrQ7YSKehZSbop1dOQYsBXb9BtQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwISyHMx8IbDySYkj5ZPhwLAhC/Xfw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIkiGgR0tXjYv9pEJrtCm7j7u7ACw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIlbQNgfu4BVriiq4TaHVsoMhn+lw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIwusoniC2wlOoQZKI+KGbfrPxYSA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwI15H61pE+qvLI1DIM69RYuNeSvjQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJW2IIjU3mHFEwgC0nxu750U5VGvg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARz0Y9WyVIA="
            },
            {
                "key": "BwJb2sYIzTjFyHOPW+IIExlKMVDU/w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJjtKBTjOjZCHayAa8QINEzCKiyUw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJkJHMr12cvzA2jfR5wo4o8isX4Bw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJrw/ZfxQ5JBg4h7WmWvpbuS0BHUg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJ+nqEOWYSgnRnQXzHKPLZbt981nQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJ/qmT69UdQouPuYhFmY1/q9AarIg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKEsSOHXw82uWbQtsoUsxEhvZZ2rQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKIX4z25FvdP9zcZE79zQrJOIDHgQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKL7EeGWt47FyqSjfj5kLx/KjufeQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKhsXQunDLHyqlybYIEvVcV40GYYQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKjoe9a5lYVcgIzY4YuI4r6hMcu9Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKpyX/4Jdud1TBW1lrnBAMbSVnZmg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwK64NffzQPJDrzgA8WDMsE0anKDag==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwK/nu9jE5tn/Qq/Ir1VBKywUZpCEg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLDdHds9cSXre72tQVYiwDLKYUx/Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLF4drsKtQB6+vdPjJRbZCrJRo6ow==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLGw8yE6r1GQ8OCyYj6KDBlf8cKaw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLJve7TPNAVQeHu0Q+QUZ0sBv4/6w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFJJxrnlqB5W3w="
            },
            {
                "key": "BwLLqM/E5AwTP9nVwJJ2SebZl0ExKA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLc1tTis+HR4eb6jCHIoyPcvs/5cA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLhcf+l+ZGtzyfUJ80Pgvzj8s0GIA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwL6lDSEZ/ZNWkV/dfi8QEldM8Zauw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwMCUtQOC63tWZB635CLJC5Cm2kP7Q==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwMEoameaM8GfSM1bezbughHzExVXw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwMPrQ7YSKehZSbop1dOQYsBXb9BtQ==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEBFldgADVg4ByAY3FQGKYRYQCiV4BjpFfC1xFhAHFXgGOkV8LXFGEC0VeAY6kFnLsUYQMBV4BjsPqERBRhAzFXgGPdYu0+FGEDT1eAY/L944sUYQN/V2EBFlZbgGNxUBimFGECb1eAY42ly1sUYQJ5V4BjldibQRRhApdXgGOdwp+sFGECtVdhARZWW4BjMTzlZxFhAOlXgGMxPOVnFGEBt1eAYzlQk1EUYQHVV4BjQMEPGRRhAgVXgGNn6Ci/FGECIVeAY3CggjEUYQI/V2EBFlZbgGMG/d4DFGEBG1eAYwlep7MUYQE5V4BjGBYN3RRhAWlXgGMjuHLdFGEBh1dbYACA/VthASNhA5tWW2BAUWEBMJGQYRRJVltgQFGAkQOQ81thAVNgBIA2A4EBkGEBTpGQYRUEVlthBC1WW2BAUWEBYJGQYRVfVltgQFGAkQOQ81thAXFhBEtWW2BAUWEBfpGQYRWJVltgQFGAkQOQ81thAaFgBIA2A4EBkGEBnJGQYRWkVlthBFVWW2BAUWEBrpGQYRVfVltgQFGAkQOQ81thAb9hBU1WW2BAUWEBzJGQYRYTVltgQFGAkQOQ81thAe9gBIA2A4EBkGEB6pGQYRUEVlthBWRWW2BAUWEB/JGQYRVfVltgQFGAkQOQ81thAh9gBIA2A4EBkGECGpGQYRUEVlthBhBWWwBbYQIpYQaaVltgQFFhAjaRkGEWaVZbYEBRgJEDkPNbYQJZYASANgOBAZBhAlSRkGEWhFZbYQatVltgQFFhAmaRkGEViVZbYEBRgJEDkPNbYQJ3YQb2VlsAW2ECgWEHflZbYEBRYQKOkZBhFsBWW2BAUYCRA5DzW2ECn2EHp1ZbYEBRYQKskZBhFElWW2BAUYCRA5DzW2ECz2AEgDYDgQGQYQLKkZBhFQRWW2EIOVZbAFthAutgBIA2A4EBkGEC5pGQYRUEVlthCMNWW2BAUWEC+JGQYRVfVltgQFGAkQOQ81thAxtgBIA2A4EBkGEDFpGQYRUEVlthCa5WW2BAUWEDKJGQYRVfVltgQFGAkQOQ81thAzlhCcxWW2BAUWEDRpGQYRb0VltgQFGAkQOQ81thA2lgBIA2A4EBkGEDZJGQYRcPVlthCdJWW2BAUWEDdpGQYRWJVltgQFGAkQOQ81thA5lgBIA2A4EBkGEDlJGQYRaEVlthCllWWwBbYGBgBIBUYQOqkGEXflZbgGAfAWAggJEEAmAgAWBAUZCBAWBAUoCSkZCBgVJgIAGCgFRhA9aQYRd+VluAFWEEI1eAYB8QYQP4V2EBAICDVAQCg1KRYCABkWEEI1ZbggGRkGAAUmAgYAAgkFuBVIFSkGABAZBgIAGAgxFhBAZXgpADYB8WggGRW1BQUFBQkFCQVltgAGEEQWEEOmELUVZbhIRhC1lWW2ABkFCSkVBQVltgAGADVJBQkFZbYABhBGKEhIRhDSRWW2AAYAJgAIZz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgYABhBK1hC1FWW3P//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBUkFCCgRAVYQUtV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYQUkkGEYIlZbYEBRgJEDkP1bYQVBhWEFOWELUVZbhYQDYQtZVltgAZFQUJOSUFBQVltgAGAGYACQVJBhAQAKkARg/xaQUJBWW2AAYQYGYQVxYQtRVluEhGACYABhBX9hC1FWW3P//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBgAIhz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgVGEGAZGQYRhxVlthC1lWW2ABkFCSkVBQVlthBhhhC1FWW3P//////////////////////////xZhBjZhB35WW3P//////////////////////////xYUYQaMV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYQaDkGEZE1ZbYEBRgJEDkP1bYQaWgoJhD6hWW1BQVltgBmABkFSQYQEACpAEYOAbgVZbYABgAWAAg3P//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBUkFCRkFBWW2EG/mELUVZbc///////////////////////////FmEHHGEHflZbc///////////////////////////FhRhB3JXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhB2mQYRkTVltgQFGAkQOQ/VthB3xgAGERCVZbVltgAIBgAJBUkGEBAAqQBHP//////////////////////////xaQUJBWW2BgYAWAVGEHtpBhF35WW4BgHwFgIICRBAJgIAFgQFGQgQFgQFKAkpGQgYFSYCABgoBUYQfikGEXflZbgBVhCC9XgGAfEGEIBFdhAQCAg1QEAoNSkWAgAZFhCC9WW4IBkZBgAFJgIGAAIJBbgVSBUpBgAQGQYCABgIMRYQgSV4KQA2AfFoIBkVtQUFBQUJBQkFZbYQhBYQtRVltz//////////////////////////8WYQhfYQd+Vltz//////////////////////////8WFGEItVdgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWEIrJBhGRNWW2BAUYCRA5D9W2EIv4KCYRHNVltQUFZbYACAYAJgAGEI0mELUVZbc///////////////////////////FnP//////////////////////////xaBUmAgAZCBUmAgAWAAIGAAhXP//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBUkFCCgRAVYQmPV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYQmGkGEZpVZbYEBRgJEDkP1bYQmjYQmaYQtRVluFhYQDYQtZVltgAZFQUJKRUFBWW2AAYQnCYQm7YQtRVluEhGENJFZbYAGQUJKRUFBWW2AHVIFWW2AAYAJgAIRz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgYACDc///////////////////////////FnP//////////////////////////xaBUmAgAZCBUmAgAWAAIFSQUJKRUFBWW2EKYWELUVZbc///////////////////////////FmEKf2EHflZbc///////////////////////////FhRhCtVXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhCsyQYRkTVltgQFGAkQOQ/VtgAHP//////////////////////////xaBc///////////////////////////FhQVYQtFV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYQs8kGEaN1ZbYEBRgJEDkP1bYQtOgWERCVZbUFZbYAAzkFCQVltgAHP//////////////////////////xaDc///////////////////////////FhQVYQvJV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYQvAkGEayVZbYEBRgJEDkP1bYABz//////////////////////////8WgnP//////////////////////////xYUFWEMOVdgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWEMMJBhG1tWW2BAUYCRA5D9W4BgAmAAhXP//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBgAIRz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAggZBVUIFz//////////////////////////8Wg3P//////////////////////////xZ/jFvh5evsfVvRT3FCfR6E890DFMD3sikeWyAKyMfDuSWDYEBRYQ0XkZBhFYlWW2BAUYCRA5CjUFBQVltgAHP//////////////////////////xaDc///////////////////////////FhQVYQ2UV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYQ2LkGEb7VZbYEBRgJEDkP1bYABz//////////////////////////8WgnP//////////////////////////xYUFWEOBFdgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWEN+5BhHH9WW2BAUYCRA5D9W2EOD4ODg2ETplZbYABgAWAAhXP//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBUkFCBgRAVYQ6WV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYQ6NkGEdEVZbYEBRgJEDkP1bgYEDYAFgAIZz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAggZBVUIFgAWAAhXP//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBgAIKCVGEPK5GQYRhxVluSUFCBkFVQgnP//////////////////////////xaEc///////////////////////////Fn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz74RgQFFhD4+RkGEViVZbYEBRgJEDkKNhD6KEhIRhE6tWW1BQUFBWW2AAc///////////////////////////FoJz//////////////////////////8WFBVhEBhXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhEA+QYR19VltgQFGAkQOQ/VthECRgAIODYROmVluAYANgAIKCVGEQNpGQYRhxVluSUFCBkFVQgGABYACEc///////////////////////////FnP//////////////////////////xaBUmAgAZCBUmAgAWAAIGAAgoJUYRCMkZBhGHFWW5JQUIGQVVCBc///////////////////////////FmAAc///////////////////////////Fn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz74NgQFFhEPGRkGEViVZbYEBRgJEDkKNhEQVgAIODYROrVltQUFZbYACAYACQVJBhAQAKkARz//////////////////////////8WkFCBYACAYQEACoFUgXP//////////////////////////wIZFpCDc///////////////////////////FgIXkFVQgXP//////////////////////////xaBc///////////////////////////Fn+L4AecUxZZFBNEzR/QpPKEGUl/lyKj2q/jtBhva2RX4GBAUWBAUYCRA5CjUFBWW2AAc///////////////////////////FoJz//////////////////////////8WFBVhEj1XYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhEjSQYR4PVltgQFGAkQOQ/VthEkmCYACDYROmVltgAGABYACEc///////////////////////////FnP//////////////////////////xaBUmAgAZCBUmAgAWAAIFSQUIGBEBVhEtBXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhEseQYR6hVltgQFGAkQOQ/VuBgQNgAWAAhXP//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACCBkFVQgWADYACCglRhEyiRkGEewVZbklBQgZBVUGAAc///////////////////////////FoNz//////////////////////////8Wf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvhGBAUWETjZGQYRWJVltgQFGAkQOQo2EToYNgAIRhE6tWW1BQUFZbUFBQVltQUFBWW2AAgVGQUJGQUFZbYACCglJgIIIBkFCSkVBQVltgAFuDgRAVYRPqV4CCAVGBhAFSYCCBAZBQYRPPVluDgREVYRP5V2AAhIQBUltQUFBQVltgAGAfGWAfgwEWkFCRkFBWW2AAYRQbgmETsFZbYRQlgYVhE7tWW5NQYRQ1gYVgIIYBYRPMVlthFD6BYRP/VluEAZFQUJKRUFBWW2AAYCCCAZBQgYEDYACDAVJhFGOBhGEUEFZbkFCSkVBQVltgAID9W2AAc///////////////////////////ghaQUJGQUFZbYABhFJuCYRRwVluQUJGQUFZbYRSrgWEUkFZbgRRhFLZXYACA/VtQVltgAIE1kFBhFMiBYRSiVluSkVBQVltgAIGQUJGQUFZbYRThgWEUzlZbgRRhFOxXYACA/VtQVltgAIE1kFBhFP6BYRTYVluSkVBQVltgAIBgQIOFAxIVYRUbV2EVGmEUa1ZbW2AAYRUphYKGAWEUuVZbklBQYCBhFTqFgoYBYRTvVluRUFCSUJKQUFZbYACBFRWQUJGQUFZbYRVZgWEVRFZbglJQUFZbYABgIIIBkFBhFXRgAIMBhGEVUFZbkpFQUFZbYRWDgWEUzlZbglJQUFZbYABgIIIBkFBhFZ5gAIMBhGEVelZbkpFQUFZbYACAYABgYISGAxIVYRW9V2EVvGEUa1ZbW2AAYRXLhoKHAWEUuVZbk1BQYCBhFdyGgocBYRS5VluSUFBgQGEV7YaChwFhFO9WW5FQUJJQklCSVltgAGD/ghaQUJGQUFZbYRYNgWEV91ZbglJQUFZbYABgIIIBkFBhFihgAIMBhGEWBFZbkpFQUFZbYAB//////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCFpBQkZBQVlthFmOBYRYuVluCUlBQVltgAGAgggGQUGEWfmAAgwGEYRZaVluSkVBQVltgAGAggoQDEhVhFppXYRaZYRRrVltbYABhFqiEgoUBYRS5VluRUFCSkVBQVlthFrqBYRSQVluCUlBQVltgAGAgggGQUGEW1WAAgwGEYRaxVluSkVBQVltgAIGQUJGQUFZbYRbugWEW21ZbglJQUFZbYABgIIIBkFBhFwlgAIMBhGEW5VZbkpFQUFZbYACAYECDhQMSFWEXJldhFyVhFGtWW1tgAGEXNIWChgFhFLlWW5JQUGAgYRdFhYKGAWEUuVZbkVBQklCSkFBWW39OSHtxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAUmAiYARSYCRgAP1bYABgAoIEkFBgAYIWgGEXlldgf4IWkVBbYCCCEIEUFWEXqldhF6lhF09WW1tQkZBQVlt/RVJDMjA6IHRyYW5zZmVyIGFtb3VudCBleGNlZWRzIGFgAIIBUn9sbG93YW5jZQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAgggFSUFZbYABhGAxgKINhE7tWW5FQYRgXgmEXsFZbYECCAZBQkZBQVltgAGAgggGQUIGBA2AAgwFSYRg7gWEX/1ZbkFCRkFBWW39OSHtxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAAUmARYARSYCRgAP1bYABhGHyCYRTOVluRUGEYh4NhFM5WW5JQgn///////////////////////////////////////////wOCERVhGLxXYRi7YRhCVltbgoIBkFCSkVBQVlt/T3duYWJsZTogY2FsbGVyIGlzIG5vdCB0aGUgb3duZXJgAIIBUlBWW2AAYRj9YCCDYRO7VluRUGEZCIJhGMdWW2AgggGQUJGQUFZbYABgIIIBkFCBgQNgAIMBUmEZLIFhGPBWW5BQkZBQVlt/RVJDMjA6IGRlY3JlYXNlZCBhbGxvd2FuY2UgYmVsb3dgAIIBUn8gemVybwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAgggFSUFZbYABhGY9gJYNhE7tWW5FQYRmagmEZM1ZbYECCAZBQkZBQVltgAGAgggGQUIGBA2AAgwFSYRm+gWEZglZbkFCRkFBWW39Pd25hYmxlOiBuZXcgb3duZXIgaXMgdGhlIHplcm8gYWAAggFSf2RkcmVzcwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYCCCAVJQVltgAGEaIWAmg2ETu1ZbkVBhGiyCYRnFVltgQIIBkFCRkFBWW2AAYCCCAZBQgYEDYACDAVJhGlCBYRoUVluQUJGQUFZbf0VSQzIwOiBhcHByb3ZlIGZyb20gdGhlIHplcm8gYWRkYACCAVJ/cmVzcwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgIIIBUlBWW2AAYRqzYCSDYRO7VluRUGEavoJhGldWW2BAggGQUJGQUFZbYABgIIIBkFCBgQNgAIMBUmEa4oFhGqZWW5BQkZBQVlt/RVJDMjA6IGFwcHJvdmUgdG8gdGhlIHplcm8gYWRkcmVgAIIBUn9zcwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAgggFSUFZbYABhG0VgIoNhE7tWW5FQYRtQgmEa6VZbYECCAZBQkZBQVltgAGAgggGQUIGBA2AAgwFSYRt0gWEbOFZbkFCRkFBWW39FUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGAAggFSf2RyZXNzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYCCCAVJQVltgAGEb12Alg2ETu1ZbkVBhG+KCYRt7VltgQIIBkFCRkFBWW2AAYCCCAZBQgYEDYACDAVJhHAaBYRvKVluQUJGQUFZbf0VSQzIwOiB0cmFuc2ZlciB0byB0aGUgemVybyBhZGRyYACCAVJ/ZXNzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgIIIBUlBWW2AAYRxpYCODYRO7VluRUGEcdIJhHA1WW2BAggGQUJGQUFZbYABgIIIBkFCBgQNgAIMBUmEcmIFhHFxWW5BQkZBQVlt/RVJDMjA6IHRyYW5zZmVyIGFtb3VudCBleGNlZWRzIGJgAIIBUn9hbGFuY2UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAgggFSUFZbYABhHPtgJoNhE7tWW5FQYR0GgmEcn1ZbYECCAZBQkZBQVltgAGAgggGQUIGBA2AAgwFSYR0qgWEc7lZbkFCRkFBWW39FUkMyMDogbWludCB0byB0aGUgemVybyBhZGRyZXNzAGAAggFSUFZbYABhHWdgH4NhE7tWW5FQYR1ygmEdMVZbYCCCAZBQkZBQVltgAGAgggGQUIGBA2AAgwFSYR2WgWEdWlZbkFCRkFBWW39FUkMyMDogYnVybiBmcm9tIHRoZSB6ZXJvIGFkZHJlc2AAggFSf3MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYCCCAVJQVltgAGEd+WAhg2ETu1ZbkVBhHgSCYR2dVltgQIIBkFCRkFBWW2AAYCCCAZBQgYEDYACDAVJhHiiBYR3sVluQUJGQUFZbf0VSQzIwOiBidXJuIGFtb3VudCBleGNlZWRzIGJhbGFuYACCAVJ/Y2UAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgIIIBUlBWW2AAYR6LYCKDYRO7VluRUGEeloJhHi9WW2BAggGQUJGQUFZbYABgIIIBkFCBgQNgAIMBUmEeuoFhHn5WW5BQkZBQVltgAGEezIJhFM5WW5FQYR7Xg2EUzlZbklCCghAVYR7qV2Ee6WEYQlZbW4KCA5BQkpFQUFb+omRpcGZzWCISIKn1YAbXjfJNKm4f8YWkNFZU9M0C1jlvEHJAeugmi+aqZHNvbGNDAAgJADM="
            },
            {
                "key": "BwMSyHMx8IbDySYkj5ZPhwLAhC/Xfw==",
                "proof": [],
                "value": "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W2BAgFGEgVJgIIEBhJBSgVFgAWABYKAbA4gWkn/ewrrN0vBbWd402ptSPf+L5C5eOOgYyC/bC653Q4enJJKCkAMBkKJQUFBQUFZbYACBZAEAAAAAhBBhGTxXYEBRYkYbzWDlG4FSYCBgBIIBgYFSg1FgJIQBUoNRkJKDkmBEkJEBkZCFAZCAg4NgAIMVYRPJV4GBAVGDggFSYCABYROxVltQkZKRUFBWW2BAgFGAggGQkVJgAICCUmAgggFSkFb+QlJMOjpkZWxlZ2F0ZUJ5U2lnOiBpbnZhbGlkIG5vbmNlQkVQMjA6IHRyYW5zZmVyIGZyb20gdGhlIHplcm8gYWRkcmVzc0JFUDIwOiBhcHByb3ZlIGZyb20gdGhlIHplcm8gYWRkcmVzc0JSTDo6X3dyaXRlQ2hlY2twb2ludDogYmxvY2sgbnVtYmVyIGV4Y2VlZHMgMzIgYml0c0JSTDo6ZGVsZWdhdGVCeVNpZzogaW52YWxpZCBzaWduYXR1cmVPd25hYmxlOiBuZXcgb3duZXIgaXMgdGhlIHplcm8gYWRkcmVzc0JFUDIwOiB0cmFuc2ZlciBhbW91bnQgZXhjZWVkcyBhbGxvd2FuY2VFSVA3MTJEb21haW4oc3RyaW5nIG5hbWUsdWludDI1NiBjaGFpbklkLGFkZHJlc3MgdmVyaWZ5aW5nQ29udHJhY3QpQlJMOjpnZXRQcmlvclZvdGVzOiBub3QgeWV0IGRldGVybWluZWRPd25hYmxlOiBjYWxsZXIgaXMgbm90IHRoZSBvd25lckJFUDIwOiB0cmFuc2ZlciBhbW91bnQgZXhjZWVkcyBiYWxhbmNlQkVQMjA6IHRyYW5zZmVyIHRvIHRoZSB6ZXJvIGFkZHJlc3NCRVAyMDogZGVjcmVhc2VkIGFsbG93YW5jZSBiZWxvdyB6ZXJvQlJMOjpkZWxlZ2F0ZUJ5U2lnOiBzaWduYXR1cmUgZXhwaXJlZERlbGVnYXRpb24oYWRkcmVzcyBkZWxlZ2F0ZWUsdWludDI1NiBub25jZSx1aW50MjU2IGV4cGlyeSlCRVAyMDogYXBwcm92ZSB0byB0aGUgemVybyBhZGRyZXNzomRpcGZzWCISIHjhz6zG85KCHZ1HLMlry5nNMs+FE6/zVI12P8JQj5sRZHNvbGNDAAYGADM="
            },
            {
                "key": "BwMkiGgR0tXjYv9pEJrtCm7j7u7ACw==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEBqVdgADVg4ByAY2pieEIRYQD5V4Bjupp6VhFhAJdXgGPSEiCnEWEAcVeAY9ISIKcUYQU0V4Bj1QWszxRhBTxXgGPdYu0+FGEFjVeAY//2yukUYQW7V2EBqVZbgGO6mnpWFGEE/leAY7wlz3cUYQUGV4BjxFoBVRRhBSxXYQGpVluAY37OvgARYQDTV4Bjfs6+ABRhBGVXgGOJr8tEFGEEi1eAY5XYm0EUYQTKV4BjqQWcuxRhBNJXYQGpVluAY2pieEIUYQQRV4BjcKCCMRRhBDdXgGN0ZPw9FGEEXVdhAalWW4BjI7hy3RFhAWZXgGM2ROUVEWEBQFeAYzZE5RUUYQPLV4BjSFzJVRRhA9NXgGNZCcDVFGEEAVeAY1o9VJMUYQQJV2EBqVZbgGMjuHLdFGEDb1eAYzCt+B8UYQOlV4BjMTzlZxRhA61XYQGpVluAYwIsDZ8UYQGuV4BjBv3eAxRhAjxXgGMJAvGsFGECuVeAYwlep7MUYQLxV4BjDf4WgRRhAzFXgGMYFg3dFGEDVVdbYACA/VthAjpgBIA2A2CAgRAVYQHEV2AAgP1bgTWRYCCBATWRYAFgAWCgGwNgQIMBNRaRkIEBkGCAgQFgYIIBNWQBAAAAAIERFWEB+1dgAID9W4IBg2AgggERFWECDVdgAID9W4A1kGAgAZGEYAGDAoQBEWQBAAAAAIMRFxVhAi9XYACA/VtQkJJQkFBhBcNWWwBbYQJEYQrLVltgQIBRYCCAglKDUYGDAVKDUZGSg5KQgwGRhQGQgIODYABbg4EQFWECfleBgQFRg4IBUmAgAWECZlZbUFBQUJBQkIEBkGAfFoAVYQKrV4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUJJQUFBgQFGAkQOQ81thAsFhCvlWW2BAgFFgAWABYHAbA5SFFoFSkpCTFmAggwFSY/////8WgYMBUpBRkIGQA2BgAZDzW2EDHWAEgDYDYECBEBVhAwdXYACA/VtQYAFgAWCgGwOBNRaQYCABNWELI1ZbYECAUZEVFYJSUZCBkANgIAGQ81thAzlhCzpWW2BAgFFgAWABYKAbA5CSFoJSUZCBkANgIAGQ81thA11hC0lWW2BAgFGRglJRkIGQA2AgAZDzW2EDHWAEgDYDYGCBEBVhA4VXYACA/VtQYAFgAWCgGwOBNYEWkWAggQE1kJEWkGBAATVhC09WW2EDXWEL41ZbYQO1YQwHVltgQIBRYP+QkhaCUlGQgZADYCABkPNbYQNdYQwMVlthAjpgBIA2A2BAgRAVYQPpV2AAgP1bUGABYAFgoBsDgTWBFpFgIAE1FmEMElZbYQNdYQyWVlthA11hDJxWW2EDXWAEgDYDYCCBEBVhBCdXYACA/VtQNWABYAFgoBsDFmEMolZbYQNdYASANgNgIIEQFWEETVdgAID9W1A1YAFgAWCgGwMWYREeVlthA11hETBWW2EDXWAEgDYDYCCBEBVhBHtXYACA/VtQNWABYAFgoBsDFmERNlZbYQSxYASANgNgIIEQFWEEoVdgAID9W1A1YAFgAWCgGwMWYRFIVltgQIBRkoNSYCCDAZGQkVKAUZGCkAMBkPNbYQJEYRTcVlthAx1gBIA2A2BAgRAVYQToV2AAgP1bUGABYAFgoBsDgTUWkGAgATVhFPtWW2EDXWEVCFZbYQI6YASANgNgIIEQFWEFHFdgAID9W1A1YAFgAWCgGwMWYRUOVlthAzlhFoBWW2EDOWEWj1ZbYQI6YASANgNg4IEQFWEFUldgAID9W1BgAWABYKAbA4E1gRaRYCCBATWQkRaQYECBATWQYGCBATWQYP9ggIIBNRaQYKCBATWQYMABNWEWnlZbYQNdYASANgNgQIEQFWEFo1dgAID9W1BgAWABYKAbA4E1gRaRYCABNRZhGKBWW2ECOmEYvVZbYAxUYAEUYQYOV2BAgFFiRhvNYOUbgVJgIGAEggFSYBFgJIIBUnAVW5pc3dhcFYyOiBMT0NLRUWB6G2BEggFSkFGQgZADYGQBkP1bYABgDFWEFRWAYQYhV1BgAIQRW2EGXFdgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCWBUmAgAYBhIohgJZE5YEABkVBQYEBRgJEDkP1bYACAYQZnYQr5VltQkVCRUIFgAWABYHAbAxaHEIAVYQaMV1CAYAFgAWBwGwMWhhBbYQbHV2BAUWJGG81g5RuBUmAEAYCAYCABgoEDglJgIYFSYCABgGEi0WAhkTlgQAGRUFBgQFGAkQOQ/VtgBlRgB1RgAJGCkWABYAFgoBsDkYIWkZCBFpCJFoIUgBWQYQcFV1CAYAFgAWCgGwMWiWABYAFgoBsDFhQVW2EHTldgQIBRYkYbzWDlG4FSYCBgBIIBUmAVYCSCAVJ0VW5pc3dhcFYyOiBJTlZBTElEX1RPYFgbYESCAVKQUZCBkANgZAGQ/VuKFWEHX1dhB1+Cio1hGh9WW4kVYQdwV2EHcIGKjGEaH1ZbhhVhCCJXiGABYAFgoBsDFmMQ0ehcM42NjIxgQFGGY/////8WYOAbgVJgBAGAhmABYAFgoBsDFoFSYCABhYFSYCABhIFSYCABgGAgAYKBA4JShISCgYFSYCABklCAgoQ3YACBhAFSYB8ZYB+CARaQUICDAZJQUFCWUFBQUFBQUGAAYEBRgIMDgWAAh4A7FYAVYQgJV2AAgP1bUFrxFYAVYQgdVz1gAIA+PWAA/VtQUFBQW2BAgFFjcKCCMWDgG4FSMGAEggFSkFFgAWABYKAbA4QWkWNwoIIxkWAkgIMBkmAgkpGQgpADAYGGgDsVgBVhCGhXYACA/VtQWvoVgBVhCHxXPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhCJJXYACA/VtQUWBAgFFjcKCCMWDgG4FSMGAEggFSkFGRlVBgAWABYKAbA4MWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYQjeV2AAgP1bUFr6FYAVYQjyVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYQkIV2AAgP1bUFGSUGAAkVBQYAFgAWBwGwOFFoqQA4MRYQkrV2AAYQk6VluJhWABYAFgcBsDFgODA1uQUGAAiYVgAWABYHAbAxYDgxFhCVdXYABhCWZWW4mFYAFgAWBwGwMWA4MDW5BQYACCEYBhCXdXUGAAgRFbYQmyV2BAUWJGG81g5RuBUmAEAYCAYCABgoEDglJgJIFSYCABgGEirWAkkTlgQAGRUFBgQFGAkQOQ/VtgAGEJ1GEJwoRgA2EbuVZbYQnOh2ED6GEbuVZbkGEcHFZbkFBgAGEJ5mEJwoRgA2EbuVZbkFBhCgtiD0JAYQoFYAFgAWBwGwOLgRaQixZhG7lWW5BhG7lWW2EKFYODYRu5VlsQFWEKV1dgQIBRYkYbzWDlG4FSYCBgBIIBUmAMYCSCAVJrVW5pc3dhcFYyOiBLYKAbYESCAVKQUZCBkANgZAGQ/VtQUGEKZYSEiIhhHGxWW2BAgFGDgVJgIIEBg5BSgIIBjZBSYGCBAYyQUpBRYAFgAWCgGwOLFpEzkX/XitlfpGyZS2VR0NqF/Cdf5hPON2V/uNXj0TCEAVnYIpGBkANggAGQo1BQYAFgDFVQUFBQUFBQUFBWW2BAUYBgQAFgQFKAYBKBUmAgAXEpurm0NKm7sLgQJigQKje1srdgcRuBUlCBVltgCFRgAWABYHAbA4CCFpJgAWBwG4MEkJEWkWABYOAbkARj/////xaQVltgAGELMDOEhGEeK1ZbUGABW5KRUFBWW2AGVGABYAFgoBsDFoFWW2AAVIFWW2ABYAFgoBsDgxZgAJCBUmACYCCQgVJgQICDIDOEUpCRUoEgVGAAGRRhC85XYAFgAWCgGwOEFmAAkIFSYAJgIJCBUmBAgIMgM4RSkJFSkCBUYQupkINhHBxWW2ABYAFgoBsDhRZgAJCBUmACYCCQgVJgQICDIDOEUpCRUpAgVVthC9mEhIRhHo1WW1BgAZOSUFBQVlt/bnHtrhKxuX9NH2A3D+8QEF+i+q4BJhFKFpxkhF1hJsmBVltgEoFWW2ADVIFWW2AFVGABYAFgoBsDFjMUYQxoV2BAgFFiRhvNYOUbgVJgIGAEggFSYBRgJIIBUnMqtzS5u7C4KxkdECMnqSEkoiIip2BhG2BEggFSkFGQgZADYGQBkP1bYAaAVGABYAFgoBsDk4QWYAFgAWCgGwMZkYIWF5CRVWAHgFSSkJMWkRYXkFVWW2AJVIFWW2AKVIFWW2AAYAxUYAEUYQzvV2BAgFFiRhvNYOUbgVJgIGAEggFSYBFgJIIBUnAVW5pc3dhcFYyOiBMT0NLRUWB6G2BEggFSkFGQgZADYGQBkP1bYABgDIGQVYBhDP9hCvlWW1BgBlRgQIBRY3CggjFg4BuBUjBgBIIBUpBRk5VQkZNQYACSYAFgAWCgGwOQkRaRY3CggjGRYCSAgwGSYCCSkZCCkAMBgYaAOxWAFWENU1dgAID9W1Ba+hWAFWENZ1c9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWENfVdgAID9W1BRYAdUYECAUWNwoIIxYOAbgVIwYASCAVKQUZKTUGAAkmABYAFgoBsDkJIWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYQ3QV2AAgP1bUFr6FYAVYQ3kVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYQ36V2AAgP1bUFGQUGAAYQ4Tg2ABYAFgcBsDhxZhHBxWW5BQYABhDiqDYAFgAWBwGwOHFmEcHFZbkFBgAGEOOIeHYR87VltgAFSQkVCAYRAPV2AFVGBAgFFjfNB+R2DgG4FSkFFgAJJgAWABYKAbAxaRY3zQfkeRYASAgwGSYCCSkZCCkAMBgYaAOxWAFWEOiFdgAID9W1Ba+hWAFWEOnFc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEOsldgAID9W1BRkFAzYAFgAWCgGwOCFhQVYQ+NV4BgAWABYKAbAxZjQNwON2BAUYFj/////xZg4BuBUmAEAWAgYEBRgIMDgYaAOxWAFWEPAFdgAID9W1Ba+hWAFWEPFFc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEPKldgAID9W1BRmVCJFYAVkGEPP1dQYAAZihQVW2EPiFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAVYCSCAVJ0QmFkIGRlc2lyZWQgbGlxdWlkaXR5YFgbYESCAVKQUZCBkANgZAGQ/VthEAlWW2ABYAFgoBsDgRYVYQ/iV2BAgFFiRhvNYOUbgVJgIGAEggFSYBZgJIIBUnUmurm6EDc3uhA0MLsykDa0s7kwuje5YFEbYESCAVKQUZCBkANgZAGQ/VthD/phA+hhCc5hD/WIiGEbuVZbYSB7VluZUGEQCWAAYQPoYSDNVltQYRBSVlthEE9gAWABYHAbA4kWYRAmhoRhG7lWW4FhEC1X/lsEYAFgAWBwGwOJFmEQQoaFYRu5VluBYRBJV/5bBGEhV1ZbmFBbYACJEWEQkVdgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCiBUmAgAYBhIxpgKJE5YEABkVBQYEBRgJEDkP1bYRCbiophIM1WW2EQp4aGiophHGxWW4EVYRDRV2AIVGEQzZBgAWABYHAbA4CCFpFgAWBwG5AEFmEbuVZbYAtVW2BAgFGFgVJgIIEBhZBSgVEzkn9MIJtfyK1QdY8T4uEIi6VqVg3/aQocb+8mOU9MA4IcT5KCkAMBkKJQUGABYAxVUJSWlVBQUFBQUFZbYAFgIFJgAJCBUmBAkCBUgVZbYAtUgVZbYARgIFJgAJCBUmBAkCBUgVZbYACAYAxUYAEUYRGWV2BAgFFiRhvNYOUbgVJgIGAEggFSYBFgJIIBUnAVW5pc3dhcFYyOiBMT0NLRUWB6G2BEggFSkFGQgZADYGQBkP1bYABgDIGQVYBhEaZhCvlWW1BgBlRgB1RgQIBRY3CggjFg4BuBUjBgBIIBUpBRlJZQkpRQYAFgAWCgGwORghaTkRaRYACRhJFjcKCCMZFgJICDAZJgIJKRkIKQAwGBhoA7FYAVYRICV2AAgP1bUFr6FYAVYRIWVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRIsV2AAgP1bUFFgQIBRY3CggjFg4BuBUjBgBIIBUpBRkZJQYACRYAFgAWCgGwOFFpFjcKCCMZFgJICDAZJgIJKRkIKQAwGBhoA7FYAVYRJ6V2AAgP1bUFr6FYAVYRKOVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRKkV2AAgP1bUFEwYACQgVJgAWAgUmBAgSBUkZJQYRLDiIhhHztWW2AAVJCRUIBhEtSEh2EbuVZbgWES21f+WwSaUIBhEumEhmEbuVZbgWES8Ff+WwSZUGAAixGAFWETA1dQYACKEVthEz5XYEBRYkYbzWDlG4FSYAQBgIBgIAGCgQOCUmAogVJgIAGAYSLyYCiROWBAAZFQUGBAUYCRA5D9W2ETSDCEYSFvVlthE1OHjY1hGh9WW2ETXoaNjGEaH1ZbYECAUWNwoIIxYOAbgVIwYASCAVKQUWABYAFgoBsDiRaRY3CggjGRYCSAgwGSYCCSkZCCkAMBgYaAOxWAFWETpFdgAID9W1Ba+hWAFWETuFc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWETzldgAID9W1BRYECAUWNwoIIxYOAbgVIwYASCAVKQUZGWUGABYAFgoBsDiBaRY3CggjGRYCSAggGSYCCSkJGQgpADAYGGgDsVgBVhFBpXYACA/VtQWvoVgBVhFC5XPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhFERXYACA/VtQUZNQYRRUhYWLi2EcbFZbgRVhFH5XYAhUYRR6kGABYAFgcBsDgIIWkWABYHAbkAQWYRu5VltgC1VbYECAUYyBUmAggQGMkFKBUWABYAFgoBsDjxaSM5J/3M1BLwsSUoGcsf0zC5MiTKQmEokrs/T3iZdubYGTZJaSkIGQA5CRAZCjUFBQUFBQUFBQYAFgDIGQVVCRUJFWW2BAUYBgQAFgQFKAYAOBUmAgAWIFNMVg7BuBUlCBVltgAGELMDOEhGEejVZbYQPogVZbYAxUYAEUYRVZV2BAgFFiRhvNYOUbgVJgIGAEggFSYBFgJIIBUnAVW5pc3dhcFYyOiBMT0NLRUWB6G2BEggFSkFGQgZADYGQBkP1bYABgDFVgBlRgB1RgCFRgQIBRY3CggjFg4BuBUjBgBIIBUpBRYAFgAWCgGwOUhRaUkJMWkmEWApKFkoeSYRX9kmABYAFgcBsDFpGFkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYRXLV2AAgP1bUFr6FYAVYRXfVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRX1V2AAgP1bUFGQYRwcVlthGh9WW2EWdoGEYRX9YAhgDpBUkGEBAAqQBGABYAFgcBsDFmABYAFgcBsDFoVgAWABYKAbAxZjcKCCMTBgQFGCY/////8WYOAbgVJgBAGAgmABYAFgoBsDFoFSYCABkVBQYCBgQFGAgwOBhoA7FYAVYRXLV2AAgP1bUFBgAWAMVVBWW2AFVGABYAFgoBsDFoFWW2AHVGABYAFgoBsDFoFWW0KEEBVhFuhXYECAUWJGG81g5RuBUmAgYASCAVJgEmAkggFScRVbmlzd2FwVjI6IEVYUElSRUWByG2BEggFSkFGQgZADYGQBkP1bYANUYAFgAWCgGwOAiRZgAIGBUmAEYCCQgVJgQICDIIBUYAGAggGQklWCUX9uce2uErG5f00fYDcP7xAQX6L6rgEmEUoWnGSEXWEmyYGGAVKAhAGWkJZSlY0WYGCGAVJggIUBjJBSYKCFAZWQlVJgwICFAYuQUoFRgIYDkJEBgVJg4IUBglKAUZCDASBhGQFg8BthAQCGAVJhAQKFAZaQllJhASKAhQGWkJZSgFGAhQOQlgGGUmEBQoQBgIJShlGWgwGWkJYglYOQUmEBYoQBgIJShpBSYP+JFmEBgoUBUmEBooQBiJBSYQHChAGHkFJRkZOSYQHigIIBk2AfGYEBkoGQA5CRAZCFWvoVgBVhGANXPWAAgD49YAD9W1BQYEBRYB8ZAVGRUFBgAWABYKAbA4EWFYAVkGEYOVdQiGABYAFgoBsDFoFgAWABYKAbAxYUW2EYildgQIBRYkYbzWDlG4FSYCBgBIIBUmAcYCSCAVJ/VW5pc3dhcFYyOiBJTlZBTElEX1NJR05BVFVSRQAAAABgRIIBUpBRkIGQA2BkAZD9W2EYlYmJiWEeK1ZbUFBQUFBQUFBQVltgAmAgkIFSYACSg1JgQICEIJCRUpCCUpAgVIFWW2AMVGABFGEZCFdgQIBRYkYbzWDlG4FSYCBgBIIBUmARYCSCAVJwFVuaXN3YXBWMjogTE9DS0VFgehtgRIIBUpBRkIGQA2BkAZD9W2AAYAxVYAZUYECAUWNwoIIxYOAbgVIwYASCAVKQUWEaGJJgAWABYKAbAxaRY3CggjGRYCSAgwGSYCCSkZCCkAMBgYaAOxWAFWEZWVdgAID9W1Ba+hWAFWEZbVc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEZg1dgAID9W1BRYAdUYECAUWNwoIIxYOAbgVIwYASCAVKQUWABYAFgoBsDkJIWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYRnQV2AAgP1bUFr6FYAVYRnkVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRn6V2AAgP1bUFFgCFRgAWABYHAbA4CCFpFgAWBwG5AEFmEcbFZbYAFgDFVWW2BAgFGAggGCUmAZgVJ/dHJhbnNmZXIoYWRkcmVzcyx1aW50MjU2KQAAAAAAAABgIJGCAVKBUWABYAFgoBsDhYEWYCSDAVJgRICDAYaQUoRRgIQDkJEBgVJgZJCSAYRSkYEBgFFgAWABYOAbAxZjqQWcu2DgGxeBUpJRgVFgAJRgYJSJFpOSkYKRkICDg1tgIIMQYRrMV4BRglJgHxmQkgGRYCCRggGRAWEarVZbYAGDYCADYQEACgOAGYJRFoGEURaAgheFUlBQUFBQUJBQAZFQUGAAYEBRgIMDgWAAhlrxkVBQPYBgAIEUYRsuV2BAUZFQYB8ZYD89ARaCAWBAUj2CUj1gAGAghAE+YRszVltgYJFQW1CRUJFQgYAVYRthV1CAURWAYRthV1CAgGAgAZBRYCCBEBVhG15XYACA/VtQUVthG7JXYECAUWJGG81g5RuBUmAgYASCAVJgGmAkggFSf1VuaXN3YXBWMjogVFJBTlNGRVJfRkFJTEVEAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtQUFBQUFZbYACBFYBhG9RXUFCAggKCgoKBYRvRV/5bBBRbYQs0V2BAgFFiRhvNYOUbgVJgIGAEggFSYBRgJIIBUnNkcy1tYXRoLW11bC1vdmVyZmxvd2BgG2BEggFSkFGQgZADYGQBkP1bgIIDgoERFWELNFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAVYCSCAVJ0ZHMtbWF0aC1zdWItdW5kZXJmbG93YFgbYESCAVKQUZCBkANgZAGQ/VtgAWABYHAbA4QRgBWQYRyKV1BgAWABYHAbA4MRFVthHNFXYECAUWJGG81g5RuBUmAgYASCAVJgE2AkggFSclVuaXN3YXBWMjogT1ZFUkZMT1dgaBtgRIIBUpBRkIGQA2BkAZD9W2AIVGP/////QoEWkWABYOAbkASBFoIDkIEWFYAVkGEdAVdQYAFgAWBwGwOEFhUVW4AVYR0VV1BgAWABYHAbA4MWFRVbFWEdgFeAY/////8WYR09hWEdLoZhIgFWW2ABYAFg4BsDFpBhIhNWW2AJgFRgAWABYOAbA5KQkhaSkJICAZBVY/////+BFmEdaIRhHS6HYSIBVltgCoBUYAFgAWDgGwOSkJIWkpCSAgGQVVtgCIBUbf//////////////////GRZgAWABYHAbA4iBFpGQkRdt//////////////////9gcBsZFmABYHAbiIMWgQKRkJEXYAFgAWDgGwMWYAFg4Btj/////4cWAheSg5BVYECAUYSEFoFSkZCTBJCRFmAgggFSgVF/HEEempbgcSQcLyH3cmsXronjyrTHi+UOBisDqf/7utGSkYGQA5CRAZChUFBQUFBQVltgAWABYKAbA4CEFmAAgYFSYAJgIJCBUmBAgIMglIcWgIRSlIJSkYKQIIWQVYFRhYFSkVF/jFvh5evsfVvRT3FCfR6E890DFMD3sikeWyAKyMfDuSWSgZADkJEBkKNQUFBWW2ABYAFgoBsDgxZgAJCBUmABYCBSYECQIFRhHrCQgmEcHFZbYAFgAWCgGwOAhRZgAJCBUmABYCBSYECAgiCTkJNVkIQWgVIgVGEe35CCYSI4VltgAWABYKAbA4CEFmAAgYFSYAFgIJCBUmBAkYKQIJSQlFWAUYWBUpBRkZOShxaSf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkpGCkAMBkKNQUFBWW2AAgGAFYACQVJBhAQAKkARgAWABYKAbAxZgAWABYKAbAxZjAX5+WGBAUYFj/////xZg4BuBUmAEAWAgYEBRgIMDgYaAOxWAFWEfjFdgAID9W1Ba+hWAFWEfoFc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEftldgAID9W1BRYAtUYAFgAWCgGwOCFhWAFZRQkZJQkGEgZ1eAFWEgYldgAGEf82EP9WABYAFgcBsDiIEWkIgWYRu5VluQUGAAYSAAg2Ege1ZbkFCAghEVYSBfV2AAYSAiYSAZhIRhHBxWW2AAVJBhG7lWW5BQYABhIDuDYSA1hmAFYRu5VluQYSI4VluQUGAAgYOBYSBIV/5bBJBQgBVhIFtXYSBbh4JhIM1WW1BQUFtQUFthIHNWW4AVYSBzV2AAYAtVW1BQkpFQUFZbYABgA4IRFWEgvldQgGABYAKCBAFbgYEQFWEguFeAkVBgAoGChYFhIKdX/lsEAYFhILBX/lsEkFBhIJBWW1BhIMhWW4EVYSDIV1BgAVuRkFBWW2AAVGEg2pCCYSI4VltgAJCBVWABYAFgoBsDgxaBUmABYCBSYECQIFRhIP+QgmEiOFZbYAFgAWCgGwODFmAAgYFSYAFgIJCBUmBAgIMglJCUVYNRhYFSk1GSk5GSf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkoGQA5CRAZCjUFBWW2AAgYMQYSFmV4FhIWhWW4Jbk5JQUFBWW2ABYAFgoBsDghZgAJCBUmABYCBSYECQIFRhIZKQgmEcHFZbYAFgAWCgGwODFmAAkIFSYAFgIFJgQIEgkZCRVVRhIbmQgmEcHFZbYACQgVVgQIBRg4FSkFFgAWABYKAbA4UWkX/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75GQgZADYCABkKNQUFZbYAFgAWBwGwMWYAFgcBsCkFZbYABgAWABYHAbA4IWYAFgAWDgGwOEFoFhIjBX/lsEk5JQUFBWW4CCAYKBEBVhCzRXYECAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSc2RzLW1hdGgtYWRkLW92ZXJmbG93YGAbYESCAVKQUZCBkANgZAGQ/f5Vbmlzd2FwVjI6IElOU1VGRklDSUVOVF9PVVRQVVRfQU1PVU5UVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfSU5QVVRfQU1PVU5UVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZX0JVUk5FRFVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX0xJUVVJRElUWV9NSU5URUSiZGlwZnNYIhIgcTqL8h3wZDPzS1yavxhqu3N+clJFg730IBBaKJeR4khkc29sY0MABgwAMw=="
            },
            {
                "key": "BwMlbQNgfu4BVriiq4TaHVsoMhn+lw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwMstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "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UFCWUJaUUFBQUFBWW2AAgRWAYULzV1BQgIICgoKCgWFC8Ff+WwQUW2ERi1dgQIBRYkYbzWDlG4FSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1tdWwtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W4CCAYKBEBVhEYtXYECAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSf2RzLW1hdGgtYWRkLW92ZXJmbG93AAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgAIBgAGFDq4WFYT9pVltQkFBgAIBhQ7yIiIhhNMtWW2ABYAFgoBsDFmMJAvGsYEBRgWP/////FmDgG4FSYAQBYGBgQFGAgwOBhoA7FYAVYUP0V2AAgP1bUFr6FYAVYUQIVz1gAIA+PWAA/VtQUFBQYEBRPWBggRAVYUQeV2AAgP1bUIBRYCCQkQFRbf//////////////////kYIWk1AWkFBgAWABYKAbA4eBFpCEFhRhRFhXgIJhRFtWW4GBW5CZkJhQllBQUFBQUFBW/lVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9PVVRQVVRfQU1PVU5UVW5pc3dhcFYyTGlicmFyeTogSURFTlRJQ0FMX0FERFJFU1NFU1VuaXN3YXBWMlJvdXRlcjogSU5TVUZGSUNJRU5UX0JfQU1PVU5UVW5pc3dhcFYyTGlicmFyeTogSU5TVUZGSUNJRU5UX0xJUVVJRElUWVVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IEVYQ0VTU0lWRV9JTlBVVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IElOU1VGRklDSUVOVF9BX0FNT1VOVFRyYW5zZmVySGVscGVyOiBFVEhfVFJBTlNGRVJfRkFJTEVEVW5pc3dhcFYyUm91dGVyOiBJTlNVRkZJQ0lFTlRfT1VUUFVUX0FNT1VOVFRyYW5zZmVySGVscGVyOiBUUkFOU0ZFUl9GUk9NX0ZBSUxFRFVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IEVYUElSRUQAAAAAAAAAAKFkc29sY0MABgwACg=="
            },
            {
                "key": "BwMwusoniC2wlOoQZKI+KGbfrPxYSA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwM15H61pE+qvLI1DIM69RYuNeSvjQ==",
                "proof": [],
                "value": "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FpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACAYAVgAJBUkGEBAAqQBGABYAFgoBsDFmABYAFgoBsDFmMBfn5YYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYSAkV2AAgP1bUFr6FYAVYSA4Vz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYSBOV2AAgP1bUFFgC1RgAWABYKAbA4IWFYAVlFCRklCQYSD/V4AVYSD6V2AAYSCLYRBZYAFgAWBwGwOIgRaQiBZhHChWW5BQYABhIJiDYSETVluQUICCERVhIPdXYABhILphILGEhGEclFZbYABUkGEcKFZbkFBgAGEg04NhIM2GYAVhHChWW5BhItBWW5BQYACBg4FhIOBX/lsEkFCAFWEg81dhIPOHgmEhZVZbUFBQW1BQW2EhC1ZbgBVhIQtXYABgC1VbUFCSkVBQVltgAGADghEVYSFWV1CAYAFgAoIEAVuBgRAVYSFQV4CRUGACgYKFgWEhP1f+WwQBgWEhSFf+WwSQUGEhKFZbUGEhYFZbgRVhIWBXUGABW5GQUFZbYABUYSFykIJhItBWW2AAkIFVYAFgAWCgGwODFoFSYAFgIFJgQJAgVGEhl5CCYSLQVltgAWABYKAbA4MWYACBgVJgAWAgkIFSYECAgyCUkJRVg1GFgVKTUZKTkZJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SgZADkJEBkKNQUFZbYACBgxBhIf5XgWEiAFZbgluTklBQUFZbYAFgAWCgGwOCFmAAkIFSYAFgIFJgQJAgVGEiKpCCYRyUVltgAWABYKAbA4MWYACQgVJgAWAgUmBAgSCRkJFVVGEiUZCCYRyUVltgAJCBVWBAgFGDgVKQUWABYAFgoBsDhRaRf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkZCBkANgIAGQo1BQVltgAWABYHAbAxZgAWBwGwKQVltgAGABYAFgcBsDghZgAWABYOAbA4QWgWEiyFf+WwSTklBQUFZbgIIBgoEQFWELaFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1hZGQtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9/lVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX09VVFBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlfQlVSTkVEVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZX01JTlRFRKFkc29sY0MABgwACg=="
            },
            {
                "key": "BwNb2sYIzTjFyHOPW+IIExlKMVDU/w==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwNjtKBTjOjZCHayAa8QINEzCKiyUw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwNkJHMr12cvzA2jfR5wo4o8isX4Bw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwNrw/ZfxQ5JBg4h7WmWvpbuS0BHUg==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwN+nqEOWYSgnRnQXzHKPLZbt981nQ==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwN/qmT69UdQouPuYhFmY1/q9AarIg==",
                "proof": [],
                "value": "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GwODFmEVKFdgCFRhHDyCYRw2YQd0VluQYRRxVlsRFWEVKFdgQIBRYkYbzWDlG4FSYCBgBIIBgZBSYCSCAVJ/RVJDMjBDYXBwZWQ6IE1heCBzdXBwbHkgZXhjZWVkZWRgRIIBUpBRkIGQA2BkAZD9W2AAYRyzQ2BAUYBgYAFgQFKAYC6BUmAgAWEf72AukTlhHfRWW5BQYACEY/////8WEYAVYRz8V1BgAWABYKAbA4UWYACQgVJgC2AgkIFSYECAgyBj/////2AAGYkBgRaFUpJSkJEgVIKCFpEWFFsVYR05V2ABYAFgoBsDhRZgAJCBUmALYCCQgVJgQICDIGP/////YAAZiQEWhFKQkVKQIGABAYKQVWEdqlZbYECAUYCCAYJSY/////+AhBaCUmAggIMBhoFSYAFgAWCgGwOKFmAAgYFSYAuEUoaBIIuGFoJShFKGgSCVUYZUkIYWY/////8ZkYIWF4dVklFgAZaHAVWQgVJgDJCSUpOQIIBUkogBkJEWkZCSFheQVVtgQIBRhIFSYCCBAYSQUoFRYAFgAWCgGwOIFpJ/3sK6zdLwW1neNNqbUj3/i+QuXjjoGMgv2wuud0OHpySSgpADAZCiUFBQUFBWW2AAgWQBAAAAAIQQYR5KV2BAUWJGG81g5RuBUmAgYASCAYGBUoNRYCSEAVKDUZCSg5JgRJCRAZGQhQGQgIODYACDFWEWrleBgQFRg4IBUmAgAWEWllZbUJGSkVBQVltgQIBRgIIBkJFSYACAglJgIIIBUpBW/mdldFByaW9yVm90ZXM6IG5vdCB5ZXQgZGV0ZXJtaW5lZEVSQzIwOiB0cmFuc2ZlciB0byB0aGUgemVybyBhZGRyZXNzRVJDMjA6IGJ1cm4gYW1vdW50IGV4Y2VlZHMgYmFsYW5jZU93bmFibGU6IG5ldyBvd25lciBpcyB0aGUgemVybyBhZGRyZXNzRVJDMjA6IGFwcHJvdmUgdG8gdGhlIHplcm8gYWRkcmVzc0VSQzIwOiB0cmFuc2ZlciBhbW91bnQgZXhjZWVkcyBiYWxhbmNlYWRkTWludGVyOiBFWENFRUQgTUFYIEFNT1VOVCBPRiBNSU5URVJTV2FubmFTd2FwTWludGFibGU6IE1VU1QgQkUgTUlOVEVSRVJDMjA6IHRyYW5zZmVyIGFtb3VudCBleGNlZWRzIGFsbG93YW5jZU93bmFibGU6IGNhbGxlciBpcyBub3QgdGhlIG93bmVyYWRkTWludGVyOiBNSU5URVIgSEFTIE5PVCBFWElTVEVEX3dyaXRlQ2hlY2twb2ludDogYmxvY2sgbnVtYmVyIGV4Y2VlZHMgMzIgYml0c0VSQzIwOiBidXJuIGZyb20gdGhlIHplcm8gYWRkcmVzc0VSQzIwOiB0cmFuc2ZlciBmcm9tIHRoZSB6ZXJvIGFkZHJlc3NFUkMyMDogYXBwcm92ZSBmcm9tIHRoZSB6ZXJvIGFkZHJlc3NFUkMyMDogZGVjcmVhc2VkIGFsbG93YW5jZSBiZWxvdyB6ZXJvomRpcGZzWCISIBQ8YHMYi2aT8znBgwlCzBq002Ql/BlYRHvflP9rnFquZHNvbGNDAAYMADM="
            },
            {
                "key": "BwOEsSOHXw82uWbQtsoUsxEhvZZ2rQ==",
                "proof": [],
                "value": "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FpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACAYAVgAJBUkGEBAAqQBGABYAFgoBsDFmABYAFgoBsDFmMBfn5YYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYSAkV2AAgP1bUFr6FYAVYSA4Vz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYSBOV2AAgP1bUFFgC1RgAWABYKAbA4IWFYAVlFCRklCQYSD/V4AVYSD6V2AAYSCLYRBZYAFgAWBwGwOIgRaQiBZhHChWW5BQYABhIJiDYSETVluQUICCERVhIPdXYABhILphILGEhGEclFZbYABUkGEcKFZbkFBgAGEg04NhIM2GYAVhHChWW5BhItBWW5BQYACBg4FhIOBX/lsEkFCAFWEg81dhIPOHgmEhZVZbUFBQW1BQW2EhC1ZbgBVhIQtXYABgC1VbUFCSkVBQVltgAGADghEVYSFWV1CAYAFgAoIEAVuBgRAVYSFQV4CRUGACgYKFgWEhP1f+WwQBgWEhSFf+WwSQUGEhKFZbUGEhYFZbgRVhIWBXUGABW5GQUFZbYABUYSFykIJhItBWW2AAkIFVYAFgAWCgGwODFoFSYAFgIFJgQJAgVGEhl5CCYSLQVltgAWABYKAbA4MWYACBgVJgAWAgkIFSYECAgyCUkJRVg1GFgVKTUZKTkZJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SgZADkJEBkKNQUFZbYACBgxBhIf5XgWEiAFZbgluTklBQUFZbYAFgAWCgGwOCFmAAkIFSYAFgIFJgQJAgVGEiKpCCYRyUVltgAWABYKAbA4MWYACQgVJgAWAgUmBAgSCRkJFVVGEiUZCCYRyUVltgAJCBVWBAgFGDgVKQUWABYAFgoBsDhRaRf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkZCBkANgIAGQo1BQVltgAWABYHAbAxZgAWBwGwKQVltgAGABYAFgcBsDghZgAWABYOAbA4QWgWEiyFf+WwSTklBQUFZbgIIBgoEQFWELaFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1hZGQtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9/lVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX09VVFBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlfQlVSTkVEVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZX01JTlRFRKFkc29sY0MABgwACg=="
            },
            {
                "key": "BwOIX4z25FvdP9zcZE79zQrJOIDHgQ==",
                "proof": [],
                "value": "YIBgQFJgBDYQYQF1V2AANWDgHIBjazUYSBFhAMtXgGOpBZy7EWEAf1eAY91i7T4RYQBZV4Bj3WLtPhRhA+xXgGP0irTgFGEEMleAY/hRpEAUYQQ6V2EBdVZbgGOpBZy7FGEDmVeAY7jpdEwUYQO5V4BjvoMaLhRhA8xXYQF1VluAY40yyvQRYQCwV4BjjTLK9BRhA0RXgGOV2JtBFGEDZFeAY6RXwtcUYQN5V2EBdVZbgGNrNRhIFGEC7leAY3CggjEUYQMOV2EBdVZbgGMxPOVnEWEBLVeAY0DBDxkRYQEHV4BjQMEPGRRhAphXgGNTAgjyFGECuFeAY1yXWrsUYQLYV2EBdVZbgGMxPOVnFGECNleAYzfSwvQUYQJYV4BjOVCTURRhAnhXYQF1VluAYxgWDd0RYQFeV4BjGBYN3RRhAdVXgGMjuHLdFGEB9FeAYyaSxZ8UYQIUV2EBdVZbgGMG/d4DFGEBeleAYwlep7MUYQGlV1tgAID9WzSAFWEBhldgAID9W1BhAY9hBHJWW2BAUWEBnJGQYRMHVltgQFGAkQOQ81s0gBVhAbFXYACA/VtQYQHFYQHANmAEYRGHVlthBQRWW2BAUZAVFYFSYCABYQGcVls0gBVhAeFXYACA/VtQYAJUW2BAUZCBUmAgAWEBnFZbNIAVYQIAV2AAgP1bUGEBxWECDzZgBGEQ+VZbYQUaVls0gBVhAiBXYACA/VtQYQI0YQIvNmAEYRJWVlthBd5WWwBbNIAVYQJCV2AAgP1bUGAJVGBAUWD/kJEWgVJgIAFhAZxWWzSAFWECZFdgAID9W1BhAjRhAnM2YARhEdxWW2EF+lZbNIAVYQKEV2AAgP1bUGEBxWECkzZgBGERh1ZbYQZRVls0gBVhAqRXYACA/VtQYQI0YQKzNmAEYRGHVlthBo1WWzSAFWECxFdgAID9W1BhAjRhAtM2YARhEJZWW2EGslZbNIAVYQLkV2AAgP1bUGEB5mAGVIFWWzSAFWEC+ldgAID9W1BhAjRhAwk2YARhEZlWW2EHBFZbNIAVYQMaV2AAgP1bUGEB5mEDKTZgBGEQc1ZbYAFgAWCgGwMWYACQgVJgIIGQUmBAkCBUkFZbNIAVYQNQV2AAgP1bUGECNGEDXzZgBGERh1ZbYQd0Vls0gBVhA3BXYACA/VtQYQGPYQfwVls0gBVhA4VXYACA/VtQYQHFYQOUNmAEYRGHVlthB/9WWzSAFWEDpVdgAID9W1BhAcVhA7Q2YARhEYdWW2EIsFZbYQGPYQPHNmAEYRE5VlthCL1WWzSAFWED2FdgAID9W1BhAjRhA+c2YARhEm5WW2EJSVZbNIAVYQP4V2AAgP1bUGEB5mEEBzZgBGEQwVZbYAFgAWCgGwORghZgAJCBUmABYCCQgVJgQICDIJOQlBaCUpGQkVIgVJBWW2ECNGEJZFZbNIAVYQRGV2AAgP1bUGAFVGEEWpBgAWABYKAbAxaBVltgQFFgAWABYKAbA5CRFoFSYCABYQGcVltgYGAHgFRhBIGQYRN1VluAYB8BYCCAkQQCYCABYEBRkIEBYEBSgJKRkIGBUmAgAYKAVGEErZBhE3VWW4AVYQT6V4BgHxBhBM9XYQEAgINUBAKDUpFgIAGRYQT6VluCAZGQYABSYCBgACCQW4FUgVKQYAEBkGAgAYCDEWEE3VeCkANgHxaCAZFbUFBQUFCQUJBWW2AAYQURM4SEYQl9VltQYAGSkVBQVltgAGEFJ4SEhGEK1VZbYAFgAWCgGwOEFmAAkIFSYAFgIJCBUmBAgIMgM4RSkJFSkCBUgoEQFWEFxldgQFFiRhvNYOUbgVJgIGAEggFSYChgJIIBUn9FUkMyMDogdHJhbnNmZXIgYW1vdW50IGV4Y2VlZHMgYWBEggFSf2xsb3dhbmNlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYGSCAVJghAFbYEBRgJEDkP1bYQXThTOFhANhCX1WW1BgAZSTUFBQUFZbYAVUYAFgAWCgGwMWMxRhBfVXYACA/VtgBlVWW2AFVGABYAFgoBsDFjMUYQYRV2AAgP1bglFhBiSQYAeQYCCGAZBhD1NWW1CBUWEGOJBgCJBgIIUBkGEPU1ZbUGAJgFRg/xkWYP+SkJIWkZCRF5BVUFBWWzNgAIGBUmABYCCQgVJgQICDIGABYAFgoBsDhxaEUpCRUoEgVJCRYQURkYWQYQaIkIaQYRMaVlthCX1WW2AFVGABYAFgoBsDFjMUYQakV2AAgP1bYQaugoJhDO5WW1BQVltgBVRgAWABYKAbAxYzFGEGyVdgAID9W2BAUWABYAFgoBsDgxaQghVhCPwCkIOQYACBgYGFiIjxk1BQUFAVgBVhBv9XPWAAgD49YAD9W1BQUFZbYQcPM1uCYQ3OVltgQFGBkGAAkGEHJ5CDkIaQYCABYRLXVltgQFFgIIGDAwOBUpBgQFKQUGAAhFFgIWEHSJGQYRMaVluQUGAgYACCYCCFAWAAc+khe8cLftH1mN3TGZ6AsJP6cRJPWvFQUFBQUFBWW2EHfTNhBwlWW2BAUWABYPgbYCCCAVJgIYEBgpBSYGCDkBtr////////////////GYEWYEGDAVKCkWAAkGBVAWBAgFFgHxmBhAMBgVKRkFKQUGA1YCBgAIKChQGCc7C9Avajkq9Ui98c+u5d+g7vzI6rWvFQUFBQUFBQVltgYGAIgFRhBIGQYRN1VlszYACQgVJgAWAgkIFSYECAgyBgAWABYKAbA4YWhFKQkVKBIFSCgRAVYQiZV2BAUWJGG81g5RuBUmAgYASCAVJgJWAkggFSf0VSQzIwOiBkZWNyZWFzZWQgYWxsb3dhbmNlIGJlbG93YESCAVJ/IHplcm8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgZIIBUmCEAWEFvVZbYQimM4WFhANhCX1WW1BgAZOSUFBQVltgAGEFETOEhGEK1VZbYAVUYGCQYAFgAWCgGwMWMxRhCNdXYACA/VtgAICEYAFgAWCgGwMWhGBAUWEI8pGQYRK7VltgAGBAUYCDA4GFWvSRUFA9gGAAgRRhCS1XYEBRkVBgHxlgPz0BFoIBYEBSPYJSPWAAYCCEAT5hCTJWW2BgkVBbUJFQkVCBYQlBV2AAgP1blJNQUFBQVltgBVRgAWABYKAbAxYzFGEJYFdgAID9W5BVVltgBVRgAWABYKAbAxYzFGEJe1dgAID9W1ZbYAFgAWCgGwODFmEJ+FdgQFFiRhvNYOUbgVJgIGAEggFSYCSAggFSf0VSQzIwOiBhcHByb3ZlIGZyb20gdGhlIHplcm8gYWRkYESCAVJ/cmVzcwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgZIIBUmCEAWEFvVZbYAFgAWCgGwOCFmEKdFdgQFFiRhvNYOUbgVJgIGAEggFSYCJgJIIBUn9FUkMyMDogYXBwcm92ZSB0byB0aGUgemVybyBhZGRyZWBEggFSf3NzAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYGSCAVJghAFhBb1WW2ABYAFgoBsDg4EWYACBgVJgAWAgkIFSYECAgyCUhxaAhFKUglKRgpAghZBVkFGEgVJ/jFvh5evsfVvRT3FCfR6E890DFMD3sikeWyAKyMfDuSWRAWBAUYCRA5CjUFBQVltgAWABYKAbA4MWYQtRV2BAUWJGG81g5RuBUmAgYASCAVJgJWAkggFSf0VSQzIwOiB0cmFuc2ZlciBmcm9tIHRoZSB6ZXJvIGFkYESCAVJ/ZHJlc3MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgZIIBUmCEAWEFvVZbYAFgAWCgGwOCFmELzVdgQFFiRhvNYOUbgVJgIGAEggFSYCNgJIIBUn9FUkMyMDogdHJhbnNmZXIgdG8gdGhlIHplcm8gYWRkcmBEggFSf2VzcwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYGSCAVJghAFhBb1WW2ABYAFgoBsDgxZgAJCBUmAggZBSYECQIFSBgRAVYQxcV2BAUWJGG81g5RuBUmAgYASCAVJgJmAkggFSf0VSQzIwOiB0cmFuc2ZlciBhbW91bnQgZXhjZWVkcyBiYESCAVJ/YWxhbmNlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgZIIBUmCEAWEFvVZbYAFgAWCgGwOAhRZgAJCBUmAggZBSYECAgiCFhQOQVZGFFoFSkIEggFSEkpBhDJOQhJBhExpWW5JQUIGQVVCCYAFgAWCgGwMWhGABYAFgoBsDFn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz74RgQFFhDN+RgVJgIAGQVltgQFGAkQOQo1tQUFBQVltgAWABYKAbA4IWYQ1EV2BAUWJGG81g5RuBUmAgYASCAVJgH2AkggFSf0VSQzIwOiBtaW50IHRvIHRoZSB6ZXJvIGFkZHJlc3MAYESCAVJgZAFhBb1WW4BgAmAAgoJUYQ1WkZBhExpWW5CRVVBQYAFgAWCgGwOCFmAAkIFSYCCBkFJgQIEggFSDkpBhDYOQhJBhExpWW5CRVVBQYEBRgYFSYAFgAWCgGwODFpBgAJB/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++QYCABYEBRgJEDkKNhBq5WW2ABYAFgoBsDghZhDkpXYEBRYkYbzWDlG4FSYCBgBIIBUmAhYCSCAVJ/RVJDMjA6IGJ1cm4gZnJvbSB0aGUgemVybyBhZGRyZXNgRIIBUn9zAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGBkggFSYIQBYQW9VltgAWABYKAbA4IWYACQgVJgIIGQUmBAkCBUgYEQFWEO2VdgQFFiRhvNYOUbgVJgIGAEggFSYCJgJIIBUn9FUkMyMDogYnVybiBhbW91bnQgZXhjZWVkcyBiYWxhbmBEggFSf2NlAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYGSCAVJghAFhBb1WW2ABYAFgoBsDgxZgAJCBUmAggZBSYECBIIODA5BVYAKAVISSkGEPCJCEkGETMlZbkJFVUFBgQFGCgVJgAJBgAWABYKAbA4UWkH/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75BgIAFgQFGAkQOQo2EG/1ZbgoBUYQ9fkGETdVZbkGAAUmAgYAAgkGAfAWAgkASBAZKCYQ+BV2AAhVVhD8dWW4JgHxBhD5pXgFFg/xkWg4ABF4VVYQ/HVluCgAFgAQGFVYIVYQ/HV5GCAVuCgREVYQ/HV4JRglWRYCABkZBgAQGQYQ+sVltQYQ/TkpFQYQ/XVltQkFZbW4CCERVhD9NXYACBVWABAWEP2FZbYACCYB+DARJhD/xXgIH9W4E1Z///////////gIIRFWEQF1dhEBdhE8ZWW2BAUWAfgwFgHxmQgRZgPwEWgQGQgoIRgYMQFxVhED9XYRA/YRPGVluBYEBSg4FShmAghYgBAREVYRBXV4SF/VuDYCCHAWAggwE3koMBYCABk5CTUlCTklBQUFZbYABgIIKEAxIVYRCEV4CB/VuBNWEQj4FhE9xWW5OSUFBQVltgAIBgQIOFAxIVYRCoV4CB/VuCNWEQs4FhE9xWW5RgIJOQkwE1k1BQUFZbYACAYECDhQMSFWEQ01eBgv1bgjVhEN6BYRPcVluRUGAggwE1YRDugWET3FZbgJFQUJJQkpBQVltgAIBgAGBghIYDEhVhEQ1XgIH9W4M1YREYgWET3FZbklBgIIQBNWERKIFhE9xWW5KVkpRQUFBgQJGQkQE1kFZbYACAYECDhQMSFWERS1eBgv1bgjVhEVaBYRPcVluRUGAggwE1Z///////////gREVYRFxV4GC/VthEX2FgoYBYQ/sVluRUFCSUJKQUFZbYACAYECDhQMSFWEQqFeBgv1bYACAYECDhQMSFWERq1eBgv1bgjVn//////////+BERVhEcFXgoP9W2ERzYWChgFhD+xWW5VgIJSQlAE1lFBQUFBWW2AAgGAAYGCEhgMSFWER8FeCg/1bgzVn//////////+AghEVYRIHV4SF/VthEhOHg4gBYQ/sVluUUGAghgE1kVCAghEVYRIoV4OE/VtQYRI1hoKHAWEP7FZbklBQYECEATVg/4EWgRRhEktXgYL9W4CRUFCSUJJQklZbYABgIIKEAxIVYRJnV4CB/VtQNZGQUFZbYACAYECDhQMSFWESgFeBgv1bUFCANZJgIJCRATWRUFZbYACBUYCEUmESp4FgIIYBYCCGAWETSVZbYB8BYB8ZFpKQkgFgIAGSkVBQVltgAIJRYRLNgYRgIIcBYRNJVluRkJEBkpFQUFZbYABgAWD4G4JSg2ABgwFSglFhEvmBYCGFAWAghwFhE0lWW5GQkQFgIQGTklBQUFZbYABgIIJSYRCPYCCDAYRhEo9WW2AAghmCERVhEy1XYRMtYROwVltQAZBWW2AAgoIQFWETRFdhE0RhE7BWW1ADkFZbYABbg4EQFWETZFeBgQFRg4IBUmAgAWETTFZbg4ERFWEM6FdQUGAAkQFSVltgAYGBHJCCFoBhE4lXYH+CFpFQW2AgghCBFBVhE6pXY05Ie3Fg4BtgAFJgImAEUmAkYAD9W1CRkFBWW2NOSHtxYOAbYABSYBFgBFJgJGAA/VtjTkh7cWDgG2AAUmBBYARSYCRgAP1bYAFgAWCgGwOBFoEUYRPxV2AAgP1bUFb+omRpcGZzWCISIIqot8wyACyGuSUeySs3Dxt6qH+ZvrltajqGyHCgk7reZHNvbGNDAAgDADM="
            },
            {
                "key": "BwOL7EeGWt47FyqSjfj5kLx/KjufeQ==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOhsXQunDLHyqlybYIEvVcV40GYYQ==",
                "proof": [],
                "value": "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G2BEggFSkFGQgZADYGQBkP1bYACAYABhSfSFhWFF4VZbUJBQYUoChoaGYTtPVltQYACAYUoRiIiIYTtPVltgAWABYKAbAxZjCQLxrGBAUYFj/////xZg4BuBUmAEAWBgYEBRgIMDgYaAOxWAFWFKSVdgAID9W1Ba+hWAFWFKXVc9YACAPj1gAP1bUFBQUGBAUT1gYIEQFWFKc1dgAID9W1CAUWAgkJEBUWABYAFgcBsDkYIWk1AWkFBgAWABYKAbA4eBFpCEFhRhSqZXgIJhSqlWW4GBW5CZkJhQllBQUFBQUFBW/kF1cm9yYVJvdXRlcjogSU5TVUZGSUNJRU5UX09VVFBVVF9BTU9VTlRBdXJvcmFMaWJyYXJ5OiBJTlNVRkZJQ0lFTlRfQU1PVU5UQXVyb3JhUm91dGVyOiBJTlNVRkZJQ0lFTlRfQl9BTU9VTlRBdXJvcmFSb3V0ZXI6IEVYQ0VTU0lWRV9JTlBVVF9BTU9VTlRBdXJvcmFMaWJyYXJ5OiBJTlNVRkZJQ0lFTlRfT1VUUFVUX0FNT1VOVEF1cm9yYUxpYnJhcnk6IElERU5USUNBTF9BRERSRVNTRVNBdXJvcmFSb3V0ZXI6IElOU1VGRklDSUVOVF9BX0FNT1VOVEF1cm9yYUxpYnJhcnk6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRBdXJvcmFSb3V0ZXI6IElOVkFMSURfUEFUSAAAAAAAAFRyYW5zZmVySGVscGVyOiBFVEhfVFJBTlNGRVJfRkFJTEVEQXVyb3JhTGlicmFyeTogSU5TVUZGSUNJRU5UX0xJUVVJRElUWVRyYW5zZmVySGVscGVyOiBUUkFOU0ZFUl9GUk9NX0ZBSUxFREF1cm9yYVJvdXRlcjogUGVybWlzc2lvbiBEZW5pZWQAQXVyb3JhUm91dGVyOiBFWFBJUkVEAAAAAAAAAAAAAACiZGlwZnNYIhIgkPATjsFRJ5qTT4rLS3ItCMxinRgtufcz+yUHbLId15dkc29sY0MABgYAMw=="
            },
            {
                "key": "BwOjoe9a5lYVcgIzY4YuI4r6hMcu9Q==",
                "proof": [],
                "value": "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/f5XYW5uYVN3YXBSb3V0ZXI6IEVYUElSRUQAAAAAAAAAAFdhbm5hU3dhcFJvdXRlcjogSU5TVUZGSUNJRU5UX09VVFBVVF9BTU9VTlRXYW5uYVN3YXBMaWJyYXJ5OiBJREVOVElDQUxfQUREUkVTU0VTVHJhbnNmZXJIZWxwZXI6OnRyYW5zZmVyRnJvbTogdHJhbnNmZXJGcm9tIGZhaWxlZFRyYW5zZmVySGVscGVyOjpzYWZlVHJhbnNmZXJFVEg6IEVUSCB0cmFuc2ZlciBmYWlsZWRXYW5uYVN3YXBSb3V0ZXI6IElOU1VGRklDSUVOVF9CX0FNT1VOVFdhbm5hU3dhcFJvdXRlcjogSU5WQUxJRF9QQVRIAAAAV2FubmFTd2FwUm91dGVyOiBJTlNVRkZJQ0lFTlRfQV9BTU9VTlRXYW5uYVN3YXBMaWJyYXJ5OiBJTlNVRkZJQ0lFTlRfSU5QVVRfQU1PVU5UV2FubmFTd2FwUm91dGVyOiBFWENFU1NJVkVfSU5QVVRfQU1PVU5UVHJhbnNmZXJIZWxwZXI6OnNhZmVUcmFuc2ZlcjogdHJhbnNmZXIgZmFpbGVkV2FubmFTd2FwTGlicmFyeTogSU5TVUZGSUNJRU5UX09VVFBVVF9BTU9VTlRXYW5uYVN3YXBMaWJyYXJ5OiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZV2FubmFTd2FwTGlicmFyeTogSU5TVUZGSUNJRU5UX0FNT1VOVKJkaXBmc1giEiAYcQDZGbNEiGPHacRNuj38jYkjAMZAhJ7YlKXfDOB1MmRzb2xjQwAGDAAz"
            },
            {
                "key": "BwOpyX/4Jdud1TBW1lrnBAMbSVnZmg==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwO64NffzQPJDrzgA8WDMsE0anKDag==",
                "proof": [],
                "value": "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AID9W1Ba+hWAFWFC41c9YACAPj1gAP1bUFBQUGBAUT1gYIEQFWFC+VdgAID9W1CAUWAgkJEBUWABYAFgcBsDkYIWk1AWkFBgAWABYKAbA4eBFpCEFhRhQyxXgIJhQy9WW4GBW5CZkJhQllBQUFBQUFBW/lVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9PVVRQVVRfQU1PVU5UVW5pc3dhcFYyTGlicmFyeTogSURFTlRJQ0FMX0FERFJFU1NFU1VuaXN3YXBWMlJvdXRlcjogSU5TVUZGSUNJRU5UX0JfQU1PVU5UVW5pc3dhcFYyTGlicmFyeTogSU5TVUZGSUNJRU5UX0xJUVVJRElUWVVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IEVYQ0VTU0lWRV9JTlBVVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IElOVkFMSURfUEFUSAAAAFVuaXN3YXBWMlJvdXRlcjogSU5TVUZGSUNJRU5UX0FfQU1PVU5UVHJhbnNmZXJIZWxwZXI6IEVUSF9UUkFOU0ZFUl9GQUlMRURVbmlzd2FwVjJSb3V0ZXI6IElOU1VGRklDSUVOVF9PVVRQVVRfQU1PVU5UVHJhbnNmZXJIZWxwZXI6IFRSQU5TRkVSX0ZST01fRkFJTEVEVW5pc3dhcFYyTGlicmFyeTogSU5TVUZGSUNJRU5UX0lOUFVUX0FNT1VOVFVuaXN3YXBWMlJvdXRlcjogRVhQSVJFRAAAAAAAAAAAomRpcGZzWCISIBBGGBVmz4o1vWD36UuC3N5aMbnkaqaX8VtzmtZYt4cRZHNvbGNDAAYMADM="
            },
            {
                "key": "BwO/nu9jE5tn/Qq/Ir1VBKywUZpCEg==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPDdHds9cSXre72tQVYiwDLKYUx/Q==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEBqVdgADVg4ByAY2pieEIRYQD5V4Bjupp6VhFhAJdXgGPSEiCnEWEAcVeAY9ISIKcUYQU0V4Bj1QWszxRhBTxXgGPdYu0+FGEFjVeAY//2yukUYQW7V2EBqVZbgGO6mnpWFGEE/leAY7wlz3cUYQUGV4BjxFoBVRRhBSxXYQGpVluAY37OvgARYQDTV4Bjfs6+ABRhBGVXgGOJr8tEFGEEi1eAY5XYm0EUYQTKV4BjqQWcuxRhBNJXYQGpVluAY2pieEIUYQQRV4BjcKCCMRRhBDdXgGN0ZPw9FGEEXVdhAalWW4BjI7hy3RFhAWZXgGM2ROUVEWEBQFeAYzZE5RUUYQPLV4BjSFzJVRRhA9NXgGNZCcDVFGEEAVeAY1o9VJMUYQQJV2EBqVZbgGMjuHLdFGEDb1eAYzCt+B8UYQOlV4BjMTzlZxRhA61XYQGpVluAYwIsDZ8UYQGuV4BjBv3eAxRhAjxXgGMJAvGsFGECuVeAYwlep7MUYQLxV4BjDf4WgRRhAzFXgGMYFg3dFGEDVVdbYACA/VthAjpgBIA2A2CAgRAVYQHEV2AAgP1bgTWRYCCBATWRYAFgAWCgGwNgQIMBNRaRkIEBkGCAgQFgYIIBNWQBAAAAAIERFWEB+1dgAID9W4IBg2AgggERFWECDVdgAID9W4A1kGAgAZGEYAGDAoQBEWQBAAAAAIMRFxVhAi9XYACA/VtQkJJQkFBhBcNWWwBbYQJEYQrLVltgQIBRYCCAglKDUYGDAVKDUZGSg5KQgwGRhQGQgIODYABbg4EQFWECfleBgQFRg4IBUmAgAWECZlZbUFBQUJBQkIEBkGAfFoAVYQKrV4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUJJQUFBgQFGAkQOQ81thAsFhCvlWW2BAgFFgAWABYHAbA5SFFoFSkpCTFmAggwFSY/////8WgYMBUpBRkIGQA2BgAZDzW2EDHWAEgDYDYECBEBVhAwdXYACA/VtQYAFgAWCgGwOBNRaQYCABNWELI1ZbYECAUZEVFYJSUZCBkANgIAGQ81thAzlhCzpWW2BAgFFgAWABYKAbA5CSFoJSUZCBkANgIAGQ81thA11hC0lWW2BAgFGRglJRkIGQA2AgAZDzW2EDHWAEgDYDYGCBEBVhA4VXYACA/VtQYAFgAWCgGwOBNYEWkWAggQE1kJEWkGBAATVhC09WW2EDXWEL41ZbYQO1YQwHVltgQIBRYP+QkhaCUlGQgZADYCABkPNbYQNdYQwMVlthAjpgBIA2A2BAgRAVYQPpV2AAgP1bUGABYAFgoBsDgTWBFpFgIAE1FmEMElZbYQNdYQyWVlthA11hDJxWW2EDXWAEgDYDYCCBEBVhBCdXYACA/VtQNWABYAFgoBsDFmEMolZbYQNdYASANgNgIIEQFWEETVdgAID9W1A1YAFgAWCgGwMWYREeVlthA11hETBWW2EDXWAEgDYDYCCBEBVhBHtXYACA/VtQNWABYAFgoBsDFmERNlZbYQSxYASANgNgIIEQFWEEoVdgAID9W1A1YAFgAWCgGwMWYRFIVltgQIBRkoNSYCCDAZGQkVKAUZGCkAMBkPNbYQJEYRTcVlthAx1gBIA2A2BAgRAVYQToV2AAgP1bUGABYAFgoBsDgTUWkGAgATVhFPtWW2EDXWEVCFZbYQI6YASANgNgIIEQFWEFHFdgAID9W1A1YAFgAWCgGwMWYRUOVlthAzlhFoBWW2EDOWEWj1ZbYQI6YASANgNg4IEQFWEFUldgAID9W1BgAWABYKAbA4E1gRaRYCCBATWQkRaQYECBATWQYGCBATWQYP9ggIIBNRaQYKCBATWQYMABNWEWnlZbYQNdYASANgNgQIEQFWEFo1dgAID9W1BgAWABYKAbA4E1gRaRYCABNRZhGKBWW2ECOmEYvVZbYAxUYAEUYQYOV2BAgFFiRhvNYOUbgVJgIGAEggFSYBFgJIIBUnAVW5pc3dhcFYyOiBMT0NLRUWB6G2BEggFSkFGQgZADYGQBkP1bYABgDFWEFRWAYQYhV1BgAIQRW2EGXFdgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCWBUmAgAYBhIohgJZE5YEABkVBQYEBRgJEDkP1bYACAYQZnYQr5VltQkVCRUIFgAWABYHAbAxaHEIAVYQaMV1CAYAFgAWBwGwMWhhBbYQbHV2BAUWJGG81g5RuBUmAEAYCAYCABgoEDglJgIYFSYCABgGEi0WAhkTlgQAGRUFBgQFGAkQOQ/VtgBlRgB1RgAJGCkWABYAFgoBsDkYIWkZCBFpCJFoIUgBWQYQcFV1CAYAFgAWCgGwMWiWABYAFgoBsDFhQVW2EHTldgQIBRYkYbzWDlG4FSYCBgBIIBUmAVYCSCAVJ0VW5pc3dhcFYyOiBJTlZBTElEX1RPYFgbYESCAVKQUZCBkANgZAGQ/VuKFWEHX1dhB1+Cio1hGh9WW4kVYQdwV2EHcIGKjGEaH1ZbhhVhCCJXiGABYAFgoBsDFmMQ0ehcM42NjIxgQFGGY/////8WYOAbgVJgBAGAhmABYAFgoBsDFoFSYCABhYFSYCABhIFSYCABgGAgAYKBA4JShISCgYFSYCABklCAgoQ3YACBhAFSYB8ZYB+CARaQUICDAZJQUFCWUFBQUFBQUGAAYEBRgIMDgWAAh4A7FYAVYQgJV2AAgP1bUFrxFYAVYQgdVz1gAIA+PWAA/VtQUFBQW2BAgFFjcKCCMWDgG4FSMGAEggFSkFFgAWABYKAbA4QWkWNwoIIxkWAkgIMBkmAgkpGQgpADAYGGgDsVgBVhCGhXYACA/VtQWvoVgBVhCHxXPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhCJJXYACA/VtQUWBAgFFjcKCCMWDgG4FSMGAEggFSkFGRlVBgAWABYKAbA4MWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYQjeV2AAgP1bUFr6FYAVYQjyVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYQkIV2AAgP1bUFGSUGAAkVBQYAFgAWBwGwOFFoqQA4MRYQkrV2AAYQk6VluJhWABYAFgcBsDFgODA1uQUGAAiYVgAWABYHAbAxYDgxFhCVdXYABhCWZWW4mFYAFgAWBwGwMWA4MDW5BQYACCEYBhCXdXUGAAgRFbYQmyV2BAUWJGG81g5RuBUmAEAYCAYCABgoEDglJgJIFSYCABgGEirWAkkTlgQAGRUFBgQFGAkQOQ/VtgAGEJ1GEJwoRgA2EbuVZbYQnOh2ED6GEbuVZbkGEcHFZbkFBgAGEJ5mEJwoRgA2EbuVZbkFBhCgtiD0JAYQoFYAFgAWBwGwOLgRaQixZhG7lWW5BhG7lWW2EKFYODYRu5VlsQFWEKV1dgQIBRYkYbzWDlG4FSYCBgBIIBUmAMYCSCAVJrVW5pc3dhcFYyOiBLYKAbYESCAVKQUZCBkANgZAGQ/VtQUGEKZYSEiIhhHGxWW2BAgFGDgVJgIIEBg5BSgIIBjZBSYGCBAYyQUpBRYAFgAWCgGwOLFpEzkX/XitlfpGyZS2VR0NqF/Cdf5hPON2V/uNXj0TCEAVnYIpGBkANggAGQo1BQYAFgDFVQUFBQUFBQUFBWW2BAUYBgQAFgQFKAYBKBUmAgAXEpurm0NKm7sLgQJigQKje1srdgcRuBUlCBVltgCFRgAWABYHAbA4CCFpJgAWBwG4MEkJEWkWABYOAbkARj/////xaQVltgAGELMDOEhGEeK1ZbUGABW5KRUFBWW2AGVGABYAFgoBsDFoFWW2AAVIFWW2ABYAFgoBsDgxZgAJCBUmACYCCQgVJgQICDIDOEUpCRUoEgVGAAGRRhC85XYAFgAWCgGwOEFmAAkIFSYAJgIJCBUmBAgIMgM4RSkJFSkCBUYQupkINhHBxWW2ABYAFgoBsDhRZgAJCBUmACYCCQgVJgQICDIDOEUpCRUpAgVVthC9mEhIRhHo1WW1BgAZOSUFBQVlt/bnHtrhKxuX9NH2A3D+8QEF+i+q4BJhFKFpxkhF1hJsmBVltgEoFWW2ADVIFWW2AFVGABYAFgoBsDFjMUYQxoV2BAgFFiRhvNYOUbgVJgIGAEggFSYBRgJIIBUnMqtzS5u7C4KxkdECMnqSEkoiIip2BhG2BEggFSkFGQgZADYGQBkP1bYAaAVGABYAFgoBsDk4QWYAFgAWCgGwMZkYIWF5CRVWAHgFSSkJMWkRYXkFVWW2AJVIFWW2AKVIFWW2AAYAxUYAEUYQzvV2BAgFFiRhvNYOUbgVJgIGAEggFSYBFgJIIBUnAVW5pc3dhcFYyOiBMT0NLRUWB6G2BEggFSkFGQgZADYGQBkP1bYABgDIGQVYBhDP9hCvlWW1BgBlRgQIBRY3CggjFg4BuBUjBgBIIBUpBRk5VQkZNQYACSYAFgAWCgGwOQkRaRY3CggjGRYCSAgwGSYCCSkZCCkAMBgYaAOxWAFWENU1dgAID9W1Ba+hWAFWENZ1c9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWENfVdgAID9W1BRYAdUYECAUWNwoIIxYOAbgVIwYASCAVKQUZKTUGAAkmABYAFgoBsDkJIWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYQ3QV2AAgP1bUFr6FYAVYQ3kVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYQ36V2AAgP1bUFGQUGAAYQ4Tg2ABYAFgcBsDhxZhHBxWW5BQYABhDiqDYAFgAWBwGwOHFmEcHFZbkFBgAGEOOIeHYR87VltgAFSQkVCAYRAPV2AFVGBAgFFjfNB+R2DgG4FSkFFgAJJgAWABYKAbAxaRY3zQfkeRYASAgwGSYCCSkZCCkAMBgYaAOxWAFWEOiFdgAID9W1Ba+hWAFWEOnFc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEOsldgAID9W1BRkFAzYAFgAWCgGwOCFhQVYQ+NV4BgAWABYKAbAxZjQNwON2BAUYFj/////xZg4BuBUmAEAWAgYEBRgIMDgYaAOxWAFWEPAFdgAID9W1Ba+hWAFWEPFFc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEPKldgAID9W1BRmVCJFYAVkGEPP1dQYAAZihQVW2EPiFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAVYCSCAVJ0QmFkIGRlc2lyZWQgbGlxdWlkaXR5YFgbYESCAVKQUZCBkANgZAGQ/VthEAlWW2ABYAFgoBsDgRYVYQ/iV2BAgFFiRhvNYOUbgVJgIGAEggFSYBZgJIIBUnUmurm6EDc3uhA0MLsykDa0s7kwuje5YFEbYESCAVKQUZCBkANgZAGQ/VthD/phA+hhCc5hD/WIiGEbuVZbYSB7VluZUGEQCWAAYQPoYSDNVltQYRBSVlthEE9gAWABYHAbA4kWYRAmhoRhG7lWW4FhEC1X/lsEYAFgAWBwGwOJFmEQQoaFYRu5VluBYRBJV/5bBGEhV1ZbmFBbYACJEWEQkVdgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCiBUmAgAYBhIxpgKJE5YEABkVBQYEBRgJEDkP1bYRCbiophIM1WW2EQp4aGiophHGxWW4EVYRDRV2AIVGEQzZBgAWABYHAbA4CCFpFgAWBwG5AEFmEbuVZbYAtVW2BAgFGFgVJgIIEBhZBSgVEzkn9MIJtfyK1QdY8T4uEIi6VqVg3/aQocb+8mOU9MA4IcT5KCkAMBkKJQUGABYAxVUJSWlVBQUFBQUFZbYAFgIFJgAJCBUmBAkCBUgVZbYAtUgVZbYARgIFJgAJCBUmBAkCBUgVZbYACAYAxUYAEUYRGWV2BAgFFiRhvNYOUbgVJgIGAEggFSYBFgJIIBUnAVW5pc3dhcFYyOiBMT0NLRUWB6G2BEggFSkFGQgZADYGQBkP1bYABgDIGQVYBhEaZhCvlWW1BgBlRgB1RgQIBRY3CggjFg4BuBUjBgBIIBUpBRlJZQkpRQYAFgAWCgGwORghaTkRaRYACRhJFjcKCCMZFgJICDAZJgIJKRkIKQAwGBhoA7FYAVYRICV2AAgP1bUFr6FYAVYRIWVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRIsV2AAgP1bUFFgQIBRY3CggjFg4BuBUjBgBIIBUpBRkZJQYACRYAFgAWCgGwOFFpFjcKCCMZFgJICDAZJgIJKRkIKQAwGBhoA7FYAVYRJ6V2AAgP1bUFr6FYAVYRKOVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRKkV2AAgP1bUFEwYACQgVJgAWAgUmBAgSBUkZJQYRLDiIhhHztWW2AAVJCRUIBhEtSEh2EbuVZbgWES21f+WwSaUIBhEumEhmEbuVZbgWES8Ff+WwSZUGAAixGAFWETA1dQYACKEVthEz5XYEBRYkYbzWDlG4FSYAQBgIBgIAGCgQOCUmAogVJgIAGAYSLyYCiROWBAAZFQUGBAUYCRA5D9W2ETSDCEYSFvVlthE1OHjY1hGh9WW2ETXoaNjGEaH1ZbYECAUWNwoIIxYOAbgVIwYASCAVKQUWABYAFgoBsDiRaRY3CggjGRYCSAgwGSYCCSkZCCkAMBgYaAOxWAFWETpFdgAID9W1Ba+hWAFWETuFc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWETzldgAID9W1BRYECAUWNwoIIxYOAbgVIwYASCAVKQUZGWUGABYAFgoBsDiBaRY3CggjGRYCSAggGSYCCSkJGQgpADAYGGgDsVgBVhFBpXYACA/VtQWvoVgBVhFC5XPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhFERXYACA/VtQUZNQYRRUhYWLi2EcbFZbgRVhFH5XYAhUYRR6kGABYAFgcBsDgIIWkWABYHAbkAQWYRu5VltgC1VbYECAUYyBUmAggQGMkFKBUWABYAFgoBsDjxaSM5J/3M1BLwsSUoGcsf0zC5MiTKQmEokrs/T3iZdubYGTZJaSkIGQA5CRAZCjUFBQUFBQUFBQYAFgDIGQVVCRUJFWW2BAUYBgQAFgQFKAYAOBUmAgAWIFNMVg7BuBUlCBVltgAGELMDOEhGEejVZbYQPogVZbYAxUYAEUYRVZV2BAgFFiRhvNYOUbgVJgIGAEggFSYBFgJIIBUnAVW5pc3dhcFYyOiBMT0NLRUWB6G2BEggFSkFGQgZADYGQBkP1bYABgDFVgBlRgB1RgCFRgQIBRY3CggjFg4BuBUjBgBIIBUpBRYAFgAWCgGwOUhRaUkJMWkmEWApKFkoeSYRX9kmABYAFgcBsDFpGFkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYRXLV2AAgP1bUFr6FYAVYRXfVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRX1V2AAgP1bUFGQYRwcVlthGh9WW2EWdoGEYRX9YAhgDpBUkGEBAAqQBGABYAFgcBsDFmABYAFgcBsDFoVgAWABYKAbAxZjcKCCMTBgQFGCY/////8WYOAbgVJgBAGAgmABYAFgoBsDFoFSYCABkVBQYCBgQFGAgwOBhoA7FYAVYRXLV2AAgP1bUFBgAWAMVVBWW2AFVGABYAFgoBsDFoFWW2AHVGABYAFgoBsDFoFWW0KEEBVhFuhXYECAUWJGG81g5RuBUmAgYASCAVJgEmAkggFScRVbmlzd2FwVjI6IEVYUElSRUWByG2BEggFSkFGQgZADYGQBkP1bYANUYAFgAWCgGwOAiRZgAIGBUmAEYCCQgVJgQICDIIBUYAGAggGQklWCUX9uce2uErG5f00fYDcP7xAQX6L6rgEmEUoWnGSEXWEmyYGGAVKAhAGWkJZSlY0WYGCGAVJggIUBjJBSYKCFAZWQlVJgwICFAYuQUoFRgIYDkJEBgVJg4IUBglKAUZCDASBhGQFg8BthAQCGAVJhAQKFAZaQllJhASKAhQGWkJZSgFGAhQOQlgGGUmEBQoQBgIJShlGWgwGWkJYglYOQUmEBYoQBgIJShpBSYP+JFmEBgoUBUmEBooQBiJBSYQHChAGHkFJRkZOSYQHigIIBk2AfGYEBkoGQA5CRAZCFWvoVgBVhGANXPWAAgD49YAD9W1BQYEBRYB8ZAVGRUFBgAWABYKAbA4EWFYAVkGEYOVdQiGABYAFgoBsDFoFgAWABYKAbAxYUW2EYildgQIBRYkYbzWDlG4FSYCBgBIIBUmAcYCSCAVJ/VW5pc3dhcFYyOiBJTlZBTElEX1NJR05BVFVSRQAAAABgRIIBUpBRkIGQA2BkAZD9W2EYlYmJiWEeK1ZbUFBQUFBQUFBQVltgAmAgkIFSYACSg1JgQICEIJCRUpCCUpAgVIFWW2AMVGABFGEZCFdgQIBRYkYbzWDlG4FSYCBgBIIBUmARYCSCAVJwFVuaXN3YXBWMjogTE9DS0VFgehtgRIIBUpBRkIGQA2BkAZD9W2AAYAxVYAZUYECAUWNwoIIxYOAbgVIwYASCAVKQUWEaGJJgAWABYKAbAxaRY3CggjGRYCSAgwGSYCCSkZCCkAMBgYaAOxWAFWEZWVdgAID9W1Ba+hWAFWEZbVc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEZg1dgAID9W1BRYAdUYECAUWNwoIIxYOAbgVIwYASCAVKQUWABYAFgoBsDkJIWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYRnQV2AAgP1bUFr6FYAVYRnkVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRn6V2AAgP1bUFFgCFRgAWABYHAbA4CCFpFgAWBwG5AEFmEcbFZbYAFgDFVWW2BAgFGAggGCUmAZgVJ/dHJhbnNmZXIoYWRkcmVzcyx1aW50MjU2KQAAAAAAAABgIJGCAVKBUWABYAFgoBsDhYEWYCSDAVJgRICDAYaQUoRRgIQDkJEBgVJgZJCSAYRSkYEBgFFgAWABYOAbAxZjqQWcu2DgGxeBUpJRgVFgAJRgYJSJFpOSkYKRkICDg1tgIIMQYRrMV4BRglJgHxmQkgGRYCCRggGRAWEarVZbYAGDYCADYQEACgOAGYJRFoGEURaAgheFUlBQUFBQUJBQAZFQUGAAYEBRgIMDgWAAhlrxkVBQPYBgAIEUYRsuV2BAUZFQYB8ZYD89ARaCAWBAUj2CUj1gAGAghAE+YRszVltgYJFQW1CRUJFQgYAVYRthV1CAURWAYRthV1CAgGAgAZBRYCCBEBVhG15XYACA/VtQUVthG7JXYECAUWJGG81g5RuBUmAgYASCAVJgGmAkggFSf1VuaXN3YXBWMjogVFJBTlNGRVJfRkFJTEVEAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtQUFBQUFZbYACBFYBhG9RXUFCAggKCgoKBYRvRV/5bBBRbYQs0V2BAgFFiRhvNYOUbgVJgIGAEggFSYBRgJIIBUnNkcy1tYXRoLW11bC1vdmVyZmxvd2BgG2BEggFSkFGQgZADYGQBkP1bgIIDgoERFWELNFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAVYCSCAVJ0ZHMtbWF0aC1zdWItdW5kZXJmbG93YFgbYESCAVKQUZCBkANgZAGQ/VtgAWABYHAbA4QRgBWQYRyKV1BgAWABYHAbA4MRFVthHNFXYECAUWJGG81g5RuBUmAgYASCAVJgE2AkggFSclVuaXN3YXBWMjogT1ZFUkZMT1dgaBtgRIIBUpBRkIGQA2BkAZD9W2AIVGP/////QoEWkWABYOAbkASBFoIDkIEWFYAVkGEdAVdQYAFgAWBwGwOEFhUVW4AVYR0VV1BgAWABYHAbA4MWFRVbFWEdgFeAY/////8WYR09hWEdLoZhIgFWW2ABYAFg4BsDFpBhIhNWW2AJgFRgAWABYOAbA5KQkhaSkJICAZBVY/////+BFmEdaIRhHS6HYSIBVltgCoBUYAFgAWDgGwOSkJIWkpCSAgGQVVtgCIBUbf//////////////////GRZgAWABYHAbA4iBFpGQkRdt//////////////////9gcBsZFmABYHAbiIMWgQKRkJEXYAFgAWDgGwMWYAFg4Btj/////4cWAheSg5BVYECAUYSEFoFSkZCTBJCRFmAgggFSgVF/HEEempbgcSQcLyH3cmsXronjyrTHi+UOBisDqf/7utGSkYGQA5CRAZChUFBQUFBQVltgAWABYKAbA4CEFmAAgYFSYAJgIJCBUmBAgIMglIcWgIRSlIJSkYKQIIWQVYFRhYFSkVF/jFvh5evsfVvRT3FCfR6E890DFMD3sikeWyAKyMfDuSWSgZADkJEBkKNQUFBWW2ABYAFgoBsDgxZgAJCBUmABYCBSYECQIFRhHrCQgmEcHFZbYAFgAWCgGwOAhRZgAJCBUmABYCBSYECAgiCTkJNVkIQWgVIgVGEe35CCYSI4VltgAWABYKAbA4CEFmAAgYFSYAFgIJCBUmBAkYKQIJSQlFWAUYWBUpBRkZOShxaSf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkpGCkAMBkKNQUFBWW2AAgGAFYACQVJBhAQAKkARgAWABYKAbAxZgAWABYKAbAxZjAX5+WGBAUYFj/////xZg4BuBUmAEAWAgYEBRgIMDgYaAOxWAFWEfjFdgAID9W1Ba+hWAFWEfoFc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEftldgAID9W1BRYAtUYAFgAWCgGwOCFhWAFZRQkZJQkGEgZ1eAFWEgYldgAGEf82EP9WABYAFgcBsDiIEWkIgWYRu5VluQUGAAYSAAg2Ege1ZbkFCAghEVYSBfV2AAYSAiYSAZhIRhHBxWW2AAVJBhG7lWW5BQYABhIDuDYSA1hmAFYRu5VluQYSI4VluQUGAAgYOBYSBIV/5bBJBQgBVhIFtXYSBbh4JhIM1WW1BQUFtQUFthIHNWW4AVYSBzV2AAYAtVW1BQkpFQUFZbYABgA4IRFWEgvldQgGABYAKCBAFbgYEQFWEguFeAkVBgAoGChYFhIKdX/lsEAYFhILBX/lsEkFBhIJBWW1BhIMhWW4EVYSDIV1BgAVuRkFBWW2AAVGEg2pCCYSI4VltgAJCBVWABYAFgoBsDgxaBUmABYCBSYECQIFRhIP+QgmEiOFZbYAFgAWCgGwODFmAAgYFSYAFgIJCBUmBAgIMglJCUVYNRhYFSk1GSk5GSf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkoGQA5CRAZCjUFBWW2AAgYMQYSFmV4FhIWhWW4Jbk5JQUFBWW2ABYAFgoBsDghZgAJCBUmABYCBSYECQIFRhIZKQgmEcHFZbYAFgAWCgGwODFmAAkIFSYAFgIFJgQIEgkZCRVVRhIbmQgmEcHFZbYACQgVVgQIBRg4FSkFFgAWABYKAbA4UWkX/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75GQgZADYCABkKNQUFZbYAFgAWBwGwMWYAFgcBsCkFZbYABgAWABYHAbA4IWYAFgAWDgGwOEFoFhIjBX/lsEk5JQUFBWW4CCAYKBEBVhCzRXYECAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSc2RzLW1hdGgtYWRkLW92ZXJmbG93YGAbYESCAVKQUZCBkANgZAGQ/f5Vbmlzd2FwVjI6IElOU1VGRklDSUVOVF9PVVRQVVRfQU1PVU5UVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfSU5QVVRfQU1PVU5UVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZX0JVUk5FRFVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX0xJUVVJRElUWV9NSU5URUSiZGlwZnNYIhIgcTqL8h3wZDPzS1yavxhqu3N+clJFg730IBBaKJeR4khkc29sY0MABgwAMw=="
            },
            {
                "key": "BwPELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPF4drsKtQB6+vdPjJRbZCrJRo6ow==",
                "proof": [],
                "value": "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UFBQVltgAIBgBWAAkFSQYQEACpAEYAFgAWCgGwMWYAFgAWCgGwMWYwF+flhgQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGgDsVgBVhHlxXYACA/VtQWvoVgBVhHnBXPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhHoZXYACA/VtQUWALVGABYAFgoBsDghYVgBWUUJGSUJBhH1VXgBVhH1BXYABhHslhDqBgAWABYHAbA4iBFpCIFmP/////YRp6FlZbkFBgAGEe1oNhH2lWW5BQgIIRFWEfTVdgAGEfBGEe9YSEY/////9hGt0WVltgAFSQY/////9hGnoWVluQUGAAYR8pg2EfHYZgBWP/////YRp6FlZbkGP/////YSE+FlZbkFBgAIGDgWEfNlf+WwSQUIAVYR9JV2EfSYeCYR+7VltQUFBbUFBbYR9hVluAFWEfYVdgAGALVVtQUJKRUFBWW2AAYAOCERVhH6xXUIBgAWACggQBW4GBEBVhH6ZXgJFQYAKBgoWBYR+VV/5bBAGBYR+eV/5bBJBQYR9+VltQYR+2VluBFWEftldQYAFbkZBQVltgAFRhH86QgmP/////YSE+FlZbYACQgVVgAWABYKAbA4MWgVJgAWAgUmBAkCBUYR/5kIJj/////2EhPhZWW2ABYAFgoBsDgxZgAIGBUmABYCCQgVJgQICDIJSQlFWDUYWBUpNRkpORkn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75KBkAOQkQGQo1BQVltgAIGDEGEgYFeBYSBiVluCW5OSUFBQVltgAWABYKAbA4IWYACQgVJgAWAgUmBAkCBUYSCSkIJj/////2Ea3RZWW2ABYAFgoBsDgxZgAJCBUmABYCBSYECBIJGQkVVUYSC/kIJj/////2Ea3RZWW2AAkIFVYECAUYOBUpBRYAFgAWCgGwOFFpF/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++RkIGQA2AgAZCjUFBWW2ABYAFgcBsDFmABYHAbApBWW2AAYAFgAWBwGwOCFmABYAFg4BsDhBaBYSE2V/5bBJOSUFBQVluAggGCgRAVYQtsV2BAgFFiRhvNYOUbgVJgIGAEggFSYBRgJIIBUnNkcy1tYXRoLWFkZC1vdmVyZmxvd2BgG2BEggFSkFGQgZADYGQBkP3+QXVyb3JhOiBJTlNVRkZJQ0lFTlRfT1VUUFVUX0FNT1VOVEF1cm9yYTogSU5TVUZGSUNJRU5UX0xJUVVJRElUWV9NSU5URURBdXJvcmE6IElOU1VGRklDSUVOVF9MSVFVSURJVFlfQlVSTkVEQXVyb3JhOiBJTlNVRkZJQ0lFTlRfSU5QVVRfQU1PVU5UomVienpyMVggeIEf0o966gU75fkANlk808aPf2n607FkTSYYmxd4ip9kc29sY0MABRAAMkVJUDcxMkRvbWFpbihzdHJpbmcgbmFtZSxzdHJpbmcgdmVyc2lvbix1aW50MjU2IGNoYWluSWQsYWRkcmVzcyB2ZXJpZnlpbmdDb250cmFjdCmiZWJ6enIxWCB6Hpl/MPAMCFbARPPSqskdZrVBtAHUc9lctgrh1lYv/2Rzb2xjQwAFEAAy"
            },
            {
                "key": "BwPGw8yE6r1GQ8OCyYj6KDBlf8cKaw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPJve7TPNAVQeHu0Q+QUZ0sBv4/6w==",
                "proof": [],
                "value": "YGBgQFJgBDYQYQCuV2P/////fAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAA1BBZjBv3eA4EUYQC4V4BjCV6nsxRhAUJXgGMYFg3dFGEBhVeAYyO4ct0UYQGqV4BjLhp9TRRhAd9XgGMxPOVnFGEB9VeAY3CggjEUYQIeV4BjldibQRRhAkpXgGOpBZy7FGECXVeAY9DjDbAUYQCuV4Bj3WLtPhRhAoxXW2EAtmECvlZbAFs0FWEAw1dgAID9W2EAy2EDIVZbYEBRYCCAglKBkIEBg4GBUYFSYCABkVCAUZBgIAGQgIODYABbg4EQFWEBB1eAggFRg4IBUmAgAWEA71ZbUFBQUJBQkIEBkGAfFoAVYQE0V4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUJJQUFBgQFGAkQOQ81s0FWEBTVdgAID9W2EBcXP//////////////////////////2AENRZgJDVhA79WW2BAUZAVFYFSYCABYEBRgJEDkPNbNBVhAZBXYACA/VthAZhhBDhWW2BAUZCBUmAgAWBAUYCRA5DzWzQVYQG1V2AAgP1bYQFxc///////////////////////////YAQ1gRaQYCQ1FmBENWEEU1ZbNBVhAepXYACA/VthALZgBDVhBfRWWzQVYQIAV2AAgP1bYQIIYQbJVltgQFFg/5CRFoFSYCABYEBRgJEDkPNbNBVhAilXYACA/VthAZhz//////////////////////////9gBDUWYQbSVls0FWECVVdgAID9W2EAy2EG5FZbNBVhAmhXYACA/VthAXFz//////////////////////////9gBDUWYCQ1YQdPVls0FWECl1dgAID9W2EBmHP//////////////////////////2AENYEWkGAkNRZhB2NWW3P//////////////////////////zMWYACBgVJgA2AgUmBAkIGQIIBUNJCBAZCRVX/h//zEkj0EtVn00pqL/GzaBOtbDTxGB1HCQCxcXMkQnJFRkIFSYCABYEBRgJEDkKJWW2AAgFRgAYFgARYVYQEAAgMWYAKQBIBgHwFgIICRBAJgIAFgQFGQgQFgQFKAkpGQgYFSYCABgoBUYAGBYAEWFWEBAAIDFmACkASAFWEDt1eAYB8QYQOMV2EBAICDVAQCg1KRYCABkWEDt1ZbggGRkGAAUmAgYAAgkFuBVIFSkGABAZBgIAGAgxFhA5pXgpADYB8WggGRW1BQUFBQgVZbc///////////////////////////M4EWYACBgVJgBGAgkIFSYECAgyCUhxaAhFKUkJFSgIIghZBVkJKRkH+MW+Hl6+x9W9FPcUJ9HoTz3QMUwPeyKR5bIArIx8O5JZCFkFGQgVJgIAFgQFGAkQOQo1BgAZKRUFBWW3P//////////////////////////zAWMZBWW3P//////////////////////////4MWYACQgVJgA2AgUmBAgSBUgpAQFWEEhldgAID9WzNz//////////////////////////8WhHP//////////////////////////xYUFYAVYQT3V1Bz//////////////////////////+AhRZgAJCBUmAEYCCQgVJgQICDIDOQlBaDUpKQUiBUYAAZFBVbFWEFeFdz//////////////////////////+AhRZgAJCBUmAEYCCQgVJgQICDIDOQlBaDUpKQUiBUgpAQFWEFPVdgAID9W3P//////////////////////////4CFFmAAkIFSYARgIJCBUmBAgIMgM5CUFoNSkpBSIIBUg5ADkFVbc///////////////////////////gIUWYACBgVJgA2AgUmBAgIIggFSHkAOQVZKGFoCCUpCDkCCAVIYBkFWRf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkIWQUZCBUmAgAWBAUYCRA5CjUGABk5JQUFBWW3P//////////////////////////zMWYACQgVJgA2AgUmBAkCBUgZAQFWEGJ1dgAID9W3P//////////////////////////zMWYACBgVJgA2AgUmBAkIGQIIBUhJADkFWCFWEI/AKQg5BRYABgQFGAgwOBhYiI8ZNQUFBQFRVhBnxXYACA/Vszc///////////////////////////Fn9/z1MsFfCm2wvW0OA4vqcdMNgIx9mMs79yaKlb9QgbZYJgQFGQgVJgIAFgQFGAkQOQolBWW2ACVGD/FoFWW2ADYCBSYACQgVJgQJAgVIFWW2ABgFRgAYFgARYVYQEAAgMWYAKQBIBgHwFgIICRBAJgIAFgQFGQgQFgQFKAkpGQgYFSYCABgoBUYAGBYAEWFWEBAAIDFmACkASAFWEDt1eAYB8QYQOMV2EBAICDVAQCg1KRYCABkWEDt1ZbYABhB1wzhIRhBFNWW5OSUFBQVltgBGAgkIFSYACSg1JgQICEIJCRUpCCUpAgVIFWAKFlYnp6cjBYIDu6e3PWBEPHcF+ILaWUAoTgEpnPdNr7gDxlT7Pufj3UACk="
            },
            {
                "key": "BwPLqM/E5AwTP9nVwJJ2SebZl0ExKA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPc1tTis+HR4eb6jCHIoyPcvs/5cA==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEBNldgADVg4ByAY05x4MgRYQCyV4BjldibQRFhAIFXgGPVBazPEWEAZleAY9UFrM8UYQPuV4Bj3WLtPhRhBExXgGPjDDl4FGEEh1dhATZWW4BjldibQRRhA61XgGOpBZy7FGEDtVdhATZWW4BjTnHgyBRhAw5XgGNwoIIxFGEDFleAY37OvgAUYQNJV4BjjaXLWxRhA3xXYQE2VluAYyO4ct0RYQEJV4BjMstrDBFhAO5XgGMyy2sMFGECxVeAYzZE5RUUYQLNV4BjQMEPGRRhAtVXYQE2VluAYyO4ct0UYQJkV4BjMTzlZxRhAqdXYQE2VluAYwb93gMUYQE7V4BjB4375xRhAbhXgGMJXqezFGEB/VeAYxgWDd0UYQJKV1tgAID9W2EBQ2EEj1ZbYECAUWAggIJSg1GBgwFSg1GRkoOSkIMBkYUBkICDg2AAW4OBEBVhAX1XgYEBUYOCAVJgIAFhAWVWW1BQUFCQUJCBAZBgHxaAFWEBqleAggOAUWABg2AgA2EBAAoDGRaBUmAgAZFQW1CSUFBQYEBRgJEDkPNbYQH7YASANgNgYIEQFWEBzldgAID9W1Bz//////////////////////////+BNRaQYCCBATUVFZBgQAE1FRVhBMhWWwBbYQI2YASANgNgQIEQFWECE1dgAID9W1Bz//////////////////////////+BNRaQYCABNWEGvlZbYECAUZEVFYJSUZCBkANgIAGQ81thAlJhBzJWW2BAgFGRglJRkIGQA2AgAZDzW2ECNmAEgDYDYGCBEBVhAnpXYACA/VtQc///////////////////////////gTWBFpFgIIEBNZCRFpBgQAE1YQc4VlthAq9hCjJWW2BAgFFg/5CSFoJSUZCBkANgIAGQ81thAlJhCjdWW2ECUmEKR1ZbYQH7YASANgNgQIEQFWEC61dgAID9W1Bz//////////////////////////+BNRaQYCABNWEKVlZbYQH7YQxPVlthAlJgBIA2A2AggRAVYQMsV2AAgP1bUDVz//////////////////////////8WYQ1rVlthAlJgBIA2A2AggRAVYQNfV2AAgP1bUDVz//////////////////////////8WYQ19VlthA4RhDY9WW2BAgFFz//////////////////////////+QkhaCUlGQgZADYCABkPNbYQFDYQ2rVlthAjZgBIA2A2BAgRAVYQPLV2AAgP1bUHP//////////////////////////4E1FpBgIAE1YQ3kVlthAftgBIA2A2DggRAVYQQEV2AAgP1bUHP//////////////////////////4E1gRaRYCCBATWQkRaQYECBATWQYGCBATWQYP9ggIIBNRaQYKCBATWQYMABNWEPu1ZbYQJSYASANgNgQIEQFWEEYldgAID9W1Bz//////////////////////////+BNYEWkWAgATUWYRKkVlthA4RhEsFWW2BAUYBgQAFgQFKAYAqBUmAgAX9Sb3NlIFRva2VuAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSUIFWW2ADVHP//////////////////////////xYzFGEFTldgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggGBkFJgJIIBUn9Pd25hYmxlOiBjYWxsZXIgaXMgbm90IHRoZSBvd25lcmBEggFSkFGQgZADYGQBkP1bgRVhBnhXc///////////////////////////gxYVFYBhBXVXUIBbYQXgV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgFWAkggFSf093bmFibGU6IHplcm8gYWRkcmVzcwAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgA1RgQFFz//////////////////////////+AhhaSFpB/i+AHnFMWWRQTRM0f0KTyhBlJf5cio9qv47QYb2tkV+CQYACQo2ADgFRz//////////////////////////+FFn////////////////8AAAAAAAAAAAAAAAAAAAAAAAAAAJGCFheQkVVgBIBUkJEWkFVhBrlWW2AEgFR/////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAWc///////////////////////////hRYXkFVbUFBQVlszYACBgVJgAWAgkIFSYECAgyBz//////////////////////////+HFoCFUpCDUoGEIIaQVYFRhoFSkVGTlJCTkJJ/jFvh5evsfVvRT3FCfR6E890DFMD3sikeWyAKyMfDuSWSgpADAZCjUGABW5KRUFBWW2AFVIFWW2AAgRVhCcNXc///////////////////////////hBZgAJCBUmAggZBSYECQIFSCgRAVYQfVV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgFmAkggFSf0VSQzIwOiBiYWxhbmNlIHRvbyBsb3cAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VuDc///////////////////////////FoVz//////////////////////////8WFGEJwVdz//////////////////////////+FFmAAkIFSYAFgIJCBUmBAgIMgM4RSkJFSkCBUf///////////////////////////////////////////gRRhCQVXg4EQFWEIz1dgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBhgJIIBUn9FUkMyMDogYWxsb3dhbmNlIHRvbyBsb3cAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bc///////////////////////////hhZgAJCBUmABYCCQgVJgQICDIDOEUpCRUpAghIIDkFVbc///////////////////////////hRZhCYdXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAWYCSCAVJ/RVJDMjA6IG5vIHplcm8gYWRkcmVzcwAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W1Bz//////////////////////////+AhhZgAJCBUmAggZBSYECAgiCGhQOQVZGGFoFSIIBUhAGQVVtQW4Jz//////////////////////////8WhHP//////////////////////////xZ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++EYEBRgIKBUmAgAZFQUGBAUYCRA5CjUGABk5JQUFBWW2ASgVZbawM7Ljyf0IA86AAAAIFWW2AAYQpRYRLdVluQUJBWW2ADVHP//////////////////////////xYzFGEK3FdgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggGBkFJgJIIBUn9Pd25hYmxlOiBjYWxsZXIgaXMgbm90IHRoZSBvd25lcmBEggFSkFGQgZADYGQBkP1bc///////////////////////////ghZhC15XYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAdYCSCAVJ/Uk9TRTogbm8gbWludCB0byB6ZXJvIGFkZHJlc3MAAABgRIIBUpBRkIGQA2BkAZD9W2AFVGELa5CCYRM9VltrAzsuPJ/QgDzoAAAAEBVhC+VXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAXYCSCAVJ/Uk9TRTogRG9uJ3QgZ28gb3ZlciBNQVgAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W2AFgFSCAZBVc///////////////////////////ghZgAIGBUmAggYFSYECAgyCAVIYBkFWAUYWBUpBRf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkpGBkAOQkQGQo1BQVltgBFRz//////////////////////////8WM4EUYQzWV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAYGQUmAkggFSf093bmFibGU6IGNhbGxlciAhPSBwZW5kaW5nIG93bmVyYESCAVKQUZCBkANgZAGQ/VtgA1RgQFFz//////////////////////////+AhBaSFpB/i+AHnFMWWRQTRM0f0KTyhBlJf5cio9qv47QYb2tkV+CQYACQo2ADgFRz//////////////////////////+QkhZ/////////////////AAAAAAAAAAAAAAAAAAAAAAAAAACSgxYXkFVgBIBUkJEWkFVWW2AAYCCBkFKQgVJgQJAgVIFWW2ACYCBSYACQgVJgQJAgVIFWW2ADVHP//////////////////////////xaBVltgQFGAYEABYEBSgGAEgVJgIAF/Uk9TRQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUlCBVltgAIEVFYBhDglXUDNz//////////////////////////+EFhRbFWEPZVczYACQgVJgIIGQUmBAkCBUgoEQFWEOjVdgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBZgJIIBUn9FUkMyMDogYmFsYW5jZSB0b28gbG93AAAAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bM3P//////////////////////////4UWFGEPY1dz//////////////////////////+EFmEPLFdgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBZgJIIBUn9FUkMyMDogbm8gemVybyBhZGRyZXNzAAAAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bM2AAkIFSYCCBkFJgQICCIIWEA5BVc///////////////////////////hhaCUpAggFSEAZBVW1BbYECAUYOBUpBRc///////////////////////////hRaRM5F/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++RgZADYCABkKNQYAGSkVBQVltz//////////////////////////+HFmEQPVdgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBhgJIIBUn9FUkMyMDogT3duZXIgY2Fubm90IGJlIDAAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bg0IQYRCrV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgDmAkggFSf0VSQzIwOiBFeHBpcmVkAAAAAAAAAAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/Vtz//////////////////////////+AiBZgAIGBUmACYCCQgVJgQJGCkCCAVGABgYEBkJJVg1F/bnHtrhKxuX9NH2A3D+8QEF+i+q4BJhFKFpxkhF1hJsmBhQFSgIUBhpBSlYwWYGCHAVJggIYBi5BSYKCGAVJgwICGAYqQUoNRgIcDkJEBgVJg4JCVAZCSUoNRkwGSkJIgkJGQYRFOkGETr1ZbhYWFYEBRYACBUmAgAWBAUmBAUYCFgVJgIAGEYP8WgVJgIAGDgVJgIAGCgVJgIAGUUFBQUFBgIGBAUWAggQOQgIQDkIVa+hWAFWERpVc9YACAPj1gAP1bUFBQYCBgQFEDUXP//////////////////////////xYUYRIxV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgGGAkggFSf0VSQzIwOiBJbnZhbGlkIFNpZ25hdHVyZQAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/Vtz//////////////////////////+AiBZgAIGBUmABYCCQgVJgQICDIJSLFoCEUpSCUpGCkCCJkFWBUYmBUpFRf4xb4eXr7H1b0U9xQn0ehPPdAxTA97IpHlsgCsjHw7klkoGQA5CRAZCjUFBQUFBQUFZbYAFgIJCBUmAAkoNSYECAhCCQkVKQglKQIFSBVltgBFRz//////////////////////////8WgVZbYABGfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABORUFSgRRhExVXYRMQgWEUolZbYRM3Vlt/N7xKam/e0Na4ShyFf6G6VbM3kHprYZ5Dwl67kQQMc7JbkVBQkFZbgYEBgYEQFWEHLFdgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBhgJIIBUn9Cb3JpbmdNYXRoOiBBZGQgT3ZlcmZsb3cAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bYABgQFGAYEABYEBSgGACgVJgIAF/GQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUlBhE+9hEt1WW4NgQFFgIAGAhIBRkGAgAZCAg4NbYCCDEGEUQFeAUYJSf//////////////////////////////////////////gkJIBkWAgkYIBkQFhFANWW1GBUWAgk4QDYQEACn///////////////////////////////////////////wGAGZCSFpEWF5BSkgGUhVJQg4EBkpCSUlBgQIBRgIQDgwGBUpKBAZBSgVGRASCTklBQUFZbYECAUX9H55U0okWVLosWiToza4Wj2eqfqMVz89gDr7kqeUaSGGAggIMBkZCRUoGDAZOQk1IwYGCAgwGRkJFSglGAgwOQkQGBUmCAkJEBkJFSgFGRASCQVv6iZGlwZnNYIhIgqFf490kpka47yNT74IKPMZC7lONPKxusxTs0GjvdTs9kc29sY0MABgwAMw=="
            },
            {
                "key": "BwPhcf+l+ZGtzyfUJ80Pgvzj8s0GIA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwP6lDSEZ/ZNWkV/dfi8QEldM8Zauw==",
                "proof": [],
                "value": "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OjpkZWxlZ2F0ZUJ5U2lnOiBzaWduYXR1cmUgZXhwaXJlZFRyaTo6c2V0TWludGVyOiBvbmx5IHRoZSBtaW50ZXIgY2FuIGNoYW5nZSB0aGUgbWludGVyIGFkZHJlc3NUcmk6Ol9tb3ZlVm90ZXM6IHZvdGUgYW1vdW50IG92ZXJmbG93c1RyaTo6bWludDogYW1vdW50IGV4Y2VlZHMgOTYgYml0c1RyaTo6bWludDogdHJhbnNmZXIgYW1vdW50IG92ZXJmbG93c1RyaTo6ZGVsZWdhdGVCeVNpZzogaW52YWxpZCBub25jZVRyaTo6X3RyYW5zZmVyVG9rZW5zOiB0cmFuc2ZlciBhbW91bnQgb3ZlcmZsb3dzVHJpOjpwZXJtaXQ6IGFtb3VudCBleGNlZWRzIDk2IGJpdHNUcmk6OnRyYW5zZmVyOiBhbW91bnQgZXhjZWVkcyA5NiBiaXRzVHJpOjpfbW92ZVZvdGVzOiB2b3RlIGFtb3VudCB1bmRlcmZsb3dzVHJpOjpfd3JpdGVDaGVja3BvaW50OiBibG9jayBudW1iZXIgZXhjZWVkcyAzMiBiaXRzoWRzb2xjQwAGDAAK"
            },
            {
                "key": "BwQCUtQOC63tWZB635CLJC5Cm2kP7QEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAMLrKJ4gtsJTqEGSiPihm36z8WEg="
            },
            {
                "key": "BwQCUtQOC63tWZB635CLJC5Cm2kP7QEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAo6HvWuZWFXICM2OGLiOK+oTHLvU="
            },
            {
                "key": "BwQCUtQOC63tWZB635CLJC5Cm2kP7QEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ="
            },
            {
                "key": "BwQCUtQOC63tWZB635CLJC5Cm2kP7QEAAADfaWbJcQUcPVTsWRYmBlMUk6UUBKAChC9WAJ1+XPSo1A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGJH9dk="
            },
            {
                "key": "BwQPrQ7YSKehZSbop1dOQYsBXb9BtQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUE9MABI="
            },
            {
                "key": "BwQPrQ7YSKehZSbop1dOQYsBXb9BtQEAAAAvm+nX4WRQ3RrAvXzuGHegGBiaR6fohdkaT208KMjjkQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAtJ8/CjLjzU4TO0="
            },
            {
                "key": "BwQPrQ7YSKehZSbop1dOQYsBXb9BtQEAAADCZEj+YQh83i/tOC4E1DNeO9NSYjrOBjccpTpeKxswaw==",
                "proof": [],
                "value": "//////////////////////////////////////////8="
            },
            {
                "key": "BwQSyHMx8IbDySYkj5ZPhwLAhC/XfwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABI="
            },
            {
                "key": "BwQSyHMx8IbDySYkj5ZPhwLAhC/XfwEAAACdejHBV43zzt0z5VJyOwD7d5fgcXkvQUpbInMkHwAUwQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAABClymh6IGWLjGY="
            },
            {
                "key": "BwQSyHMx8IbDySYkj5ZPhwLAhC/XfwEAAADCZEj+YQh83i/tOC4E1DNeO9NSYjrOBjccpTpeKxswaw==",
                "proof": [],
                "value": "//////////////////////////////////////////8="
            },
            {
                "key": "BwQkiGgR0tXjYv9pEJrtCm7j7u7ACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwQkiGgR0tXjYv9pEJrtCm7j7u7ACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAyb3u0zzQFUHh7tEPkFGdLAb+P+s="
            },
            {
                "key": "BwQkiGgR0tXjYv9pEJrtCm7j7u7ACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YkcfHgAAAAAAAQEJHgY5PMhbAAAOysPbdWGvDiDBMM0="
            },
            {
                "key": "BwQkiGgR0tXjYv9pEJrtCm7j7u7ACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAACze4pj6X3bYVnGM8dUE="
            },
            {
                "key": "BwQkiGgR0tXjYv9pEJrtCm7j7u7ACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAANdN9/WV59ojF0QVv1A6uA9eM6QzI="
            },
            {
                "key": "BwQkiGgR0tXjYv9pEJrtCm7j7u7ACwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwQlbQNgfu4BVriiq4TaHVsoMhn+lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwQlbQNgfu4BVriiq4TaHVsoMhn+lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAyb3u0zzQFUHh7tEPkFGdLAb+P+s="
            },
            {
                "key": "BwQlbQNgfu4BVriiq4TaHVsoMhn+lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YkckYQAAAAAADunl+pQRQG/xAADb5bc8uMl2s/YMsDY="
            },
            {
                "key": "BwQlbQNgfu4BVriiq4TaHVsoMhn+lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAADUagx1SRZ9S+dMgzrVQ="
            },
            {
                "key": "BwQlbQNgfu4BVriiq4TaHVsoMhn+lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAARMPrJzYS3FTvKdFtVfGQQ+/rY3tY="
            },
            {
                "key": "BwQlbQNgfu4BVriiq4TaHVsoMhn+lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwQwusoniC2wlOoQZKI+KGbfrPxYSAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwQ15H61pE+qvLI1DIM69RYuNeSvjQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAD60O2EinoWUm6KdXTkGLAV2/QbU="
            },
            {
                "key": "BwQ15H61pE+qvLI1DIM69RYuNeSvjQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwQ15H61pE+qvLI1DIM69RYuNeSvjQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YkcamgAACHE5tOrcPm36ogUgAAAAAtJ8/CjLjzU4TO0="
            },
            {
                "key": "BwQ15H61pE+qvLI1DIM69RYuNeSvjQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAALq+A3dS3L3EFXKlyx22tKN6aw="
            },
            {
                "key": "BwQ15H61pE+qvLI1DIM69RYuNeSvjQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAABeQc2U8wozEif3gKgtooKI="
            },
            {
                "key": "BwQ15H61pE+qvLI1DIM69RYuNeSvjQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwRb2sYIzTjFyHOPW+IIExlKMVDU/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAEshzMfCGw8kmJI+WT4cCwIQv138="
            },
            {
                "key": "BwRb2sYIzTjFyHOPW+IIExlKMVDU/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwRb2sYIzTjFyHOPW+IIExlKMVDU/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YkclZgAAGYexWrACAW1AQpIiAAAAABClymh6IGWLjGY="
            },
            {
                "key": "BwRb2sYIzTjFyHOPW+IIExlKMVDU/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAACMvLC5RU5w9O7A2OG/T6nbG/uqs="
            },
            {
                "key": "BwRb2sYIzTjFyHOPW+IIExlKMVDU/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAaPoCMD+wHNX+akJ5eIq8="
            },
            {
                "key": "BwRb2sYIzTjFyHOPW+IIExlKMVDU/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwRjtKBTjOjZCHayAa8QINEzCKiyUwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAiF+M9uRb3T/c3GRO/c0KyTiAx4E="
            },
            {
                "key": "BwRjtKBTjOjZCHayAa8QINEzCKiyUwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAyb3u0zzQFUHh7tEPkFGdLAb+P+s="
            },
            {
                "key": "BwRjtKBTjOjZCHayAa8QINEzCKiyUwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YkcjyQAAAAAAAbcGPawQsg1eAAAAAJiSvYhG6rfdXAc="
            },
            {
                "key": "BwRjtKBTjOjZCHayAa8QINEzCKiyUwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAuLGBVKlqo4P2/EAZsDccg="
            },
            {
                "key": "BwRjtKBTjOjZCHayAa8QINEzCKiyUwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAABhghg0eUpubKiPlvL3nO1u1t3s="
            },
            {
                "key": "BwRjtKBTjOjZCHayAa8QINEzCKiyUwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAACJTRDYBdBZFIGRhW2TykkbEVG2xJKL6LCvfjTMIsrK7w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADXtpkBBXGRAdq+t3FE8qM4XIAzrNOvl+lCOmlega0etQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAdWhA="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADXtpkBBXGRAdq+t3FE8qM4XIAzrNOvl+lCOmlega0etg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAnohg="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADXtpkBBXGRAdq+t3FE8qM4XIAzrNOvl+lCOmlega0etw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGcZjg="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADXtpkBBXGRAdq+t3FE8qM4XIAzrNOvl+lCOmlega0euA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADMW6A="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADXtpkBBXGRAdq+t3FE8qM4XIAzrNOvl+lCOmlega0euQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEcrbw="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADXtpkBBXGRAdq+t3FE8qM4XIAzrNOvl+lCOmlega0eug==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYUF2A="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADXtpkBBXGRAdq+t3FE8qM4XIAzrNOvl+lCOmlega0euw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIdBA="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADXtpkBBXGRAdq+t3FE8qM4XIAzrNOvl+lCOmlega0evA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9Uj4A="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADfaWbJcQUcPVTsWRYmBlMUk6UUBKAChC9WAJ1+XPSoxw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAi+xHhlreOxcqko34+ZC8fyo7n3k="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADfaWbJcQUcPVTsWRYmBlMUk6UUBKAChC9WAJ1+XPSoyA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADfaWbJcQUcPVTsWRYmBlMUk6UUBKAChC9WAJ1+XPSoyQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAf6pk+vVHUKLj7mIRZmNf6vQGqyI="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADfaWbJcQUcPVTsWRYmBlMUk6UUBKAChC9WAJ1+XPSoyg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA+pQ0hGf2TVpFf3X4vEBJXTPGWrs="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADfaWbJcQUcPVTsWRYmBlMUk6UUBKAChC9WAJ1+XPSoyw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAiF+M9uRb3T/c3GRO/c0KyTiAx4E="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADfaWbJcQUcPVTsWRYmBlMUk6UUBKAChC9WAJ1+XPSozA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA3NbU4rPh0eHm+owhyKMj3L7P+XA="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADfaWbJcQUcPVTsWRYmBlMUk6UUBKAChC9WAJ1+XPSozQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAEshzMfCGw8kmJI+WT4cCwIQv138="
            },
            {
                "key": "BwRkJHMr12cvzA2jfR5wo4o8isX4BwEAAADfaWbJcQUcPVTsWRYmBlMUk6UUBKAChC9WAJ1+XPSozg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAD60O2EinoWUm6KdXTkGLAV2/QbU="
            },
            {
                "key": "BwRrw/ZfxQ5JBg4h7WmWvpbuS0BHUjYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA4XH/pfmRrc8n1CfND4L84/LNBiA="
            },
            {
                "key": "BwRrw/ZfxQ5JBg4h7WmWvpbuS0BHUnAIJXs0ttEo5ZgXJihTlrx07XK7n3GHkbRXkRKP0qQO",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAqcl/+CXbndUwVtZa5wQDG0lZ2Zo="
            },
            {
                "key": "BwRrw/ZfxQ5JBg4h7WmWvpbuS0BHUrUxJ2hKVosxc64TufimAW4kPmO26O4ReNanF4ULXWED",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA6AbbBpN4jsedbEWok04Or5Svo34="
            },
            {
                "key": "BwR+nqEOWYSgnRnQXzHKPLZbt981nQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAi+xHhlreOxcqko34+ZC8fyo7n3k="
            },
            {
                "key": "BwR+nqEOWYSgnRnQXzHKPLZbt981nQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwR+nqEOWYSgnRnQXzHKPLZbt981nQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YkcljgAAHGD91BjDYiKpDe0fAAAAAAK2diwdhQi9vaA="
            },
            {
                "key": "BwR+nqEOWYSgnRnQXzHKPLZbt981nQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAADQowIribEJOuYUY9Gc8ZvjBQcoI="
            },
            {
                "key": "BwR+nqEOWYSgnRnQXzHKPLZbt981nQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAALIoNysWNhrwBm/XgFlQY="
            },
            {
                "key": "BwR+nqEOWYSgnRnQXzHKPLZbt981nQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwR/qmT69UdQouPuYhFmY1/q9AarIgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAhTMudWi52H2r0UqzRoC8VdIE9pRI="
            },
            {
                "key": "BwR/qmT69UdQouPuYhFmY1/q9AarIgEAAABvrvL+3UQfYoMQ5KTUuQLZYFuAnotL5VWPtIeuscgang==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAABsaNKR7fpnDMTJ4="
            },
            {
                "key": "BwR/qmT69UdQouPuYhFmY1/q9AarIgEAAAB3a7eyzg0HdakJk9o4F9RgsMlS7yJ82kb2FRtu4sdBPg==",
                "proof": [],
                "value": "//////////////////////////////////////////8="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA+pQ0hGf2TVpFf3X4vEBJXTPGWrs="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YkclWQAAAA9iof7cX8P9SCc5AAirexPYdwLIJ3Hd/WY="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAD6zSP+X3OZ5k9JW9uzVZE="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAB2gYh6LiRpLj9EGM6GHQ87JTqJwEMk="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwSIX4z25FvdP9zcZE79zQrJOIDHgQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABI="
            },
            {
                "key": "BwSIX4z25FvdP9zcZE79zQrJOIDHgQEAAAAEu2ofH9CdoBcFYYKgZWel1p/JH12fVsrLJlc33MNgSw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAJiSvYhG6rfdXAc="
            },
            {
                "key": "BwSIX4z25FvdP9zcZE79zQrJOIDHgQEAAABMa0OEYgmu0xI/0ogzpo0J3WEEmZyvTwaA55tqr2X3Pw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAMRQ3m7WtstndCY="
            },
            {
                "key": "BwSIX4z25FvdP9zcZE79zQrJOIDHgQEAAAB3a7eyzg0HdakJk9o4F9RgsMlS7yJ82kb2FRtu4sdBPg==",
                "proof": [],
                "value": "//////////////////////////////////////////8="
            },
            {
                "key": "BwSIX4z25FvdP9zcZE79zQrJOIDHgQEAAACTXJc/Mmezh2pKDZfM3BHx36NYx59BNtxCy/meOh+8zg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAvOy26SGPaKefVk="
            },
            {
                "key": "BwSL7EeGWt47FyqSjfj5kLx/KjufeQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABI="
            },
            {
                "key": "BwSL7EeGWt47FyqSjfj5kLx/KjufeQEAAAB3a7eyzg0HdakJk9o4F9RgsMlS7yJ82kb2FRtu4sdBPg==",
                "proof": [],
                "value": "//////////////////////////////////////////8="
            },
            {
                "key": "BwSL7EeGWt47FyqSjfj5kLx/KjufeQEAAAB8AAkF1KdsEaww6ltiTEgLtQ7jyoWGIP7gJSb55KhYmg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK2diwdhQi9vaA="
            },
            {
                "key": "BwSjoe9a5lYVcgIzY4YuI4r6hMcu9QEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAlLUDgut7VmQet+QiyQuQptpD+0="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAo6HvWuZWFXICM2OGLiOK+oTHLvU="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAyb3u0zzQFUHh7tEPkFGdLAb+P+s="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAAASM1jIQ9khwTlkrG+tKgxF9+oUDFFoBD0lSwt9M2eHug==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAAAuPlYILo+ubRKm0CvOqgfF8123/yujcjho/+uVbx6dYg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAAAuPlYILo+ubRKm0CvOqgfF8123/yujcjho/+uVbx6dYw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAiF+M9uRb3T/c3GRO/c0KyTiAx4E="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAAAuPlYILo+ubRKm0CvOqgfF8123/yujcjho/+uVbx6dZA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA3NbU4rPh0eHm+owhyKMj3L7P+XA="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAAA93rRO9RS/w6VNj5vcq6TZWs/jOqQLE/4VFY6MGtkdCQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAABuB6a1GbBiQVhg9ADTpSSW1U61ZUCbR8zU8TQ+m/fj7A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAACXVfNHK2XAL1W/KZH5jG0w6tHGuSOXNGCKGtjTpAaGDg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAiF+M9uRb3T/c3GRO/c0KyTiAx4E="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAACXVfNHK2XAL1W/KZH5jG0w6tHGuSOXNGCKGtjTpAaGDw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAyb3u0zzQFUHh7tEPkFGdLAb+P+s="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAACXVfNHK2XAL1W/KZH5jG0w6tHGuSOXNGCKGtjTpAaGEA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAADGVfVBsDZ3/gKsgbu4W585hKHzJK6jlKDluWEfspnyXg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAADOYNiEuxuyZyq8d712QLnkyDa6o4FbtM0Fone7CqCYrQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAADOYNiEuxuyZyq8d712QLnkyDa6o4FbtM0Fone7CqCYrg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAyb3u0zzQFUHh7tEPkFGdLAb+P+s="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAADOYNiEuxuyZyq8d712QLnkyDa6o4FbtM0Fone7CqCYrw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAiF+M9uRb3T/c3GRO/c0KyTiAx4E="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAADfWcRQ/yulNl3aHZdSCOXHM0mCCVwnoZgJmaBd2XEy5w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA3NbU4rPh0eHm+owhyKMj3L7P+XA="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAADfWcRQ/yulNl3aHZdSCOXHM0mCCVwnoZgJmaBd2XEy6A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAiF+M9uRb3T/c3GRO/c0KyTiAx4E="
            },
            {
                "key": "BwSpyX/4Jdud1TBW1lrnBAMbSVnZmgEAAADfWcRQ/yulNl3aHZdSCOXHM0mCCVwnoZgJmaBd2XEy6Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwS/nu9jE5tn/Qq/Ir1VBKywUZpCEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAf6pk+vVHUKLj7mIRZmNf6vQGqyI="
            },
            {
                "key": "BwS/nu9jE5tn/Qq/Ir1VBKywUZpCEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwS/nu9jE5tn/Qq/Ir1VBKywUZpCEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "Ykcj+AAAa/WpHIm3yf8/ef/SAAAABsaNKR7fpnDMTJ4="
            },
            {
                "key": "BwS/nu9jE5tn/Qq/Ir1VBKywUZpCEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAIQs4784nlhGs1/YmLPGwN2GfvI="
            },
            {
                "key": "BwS/nu9jE5tn/Qq/Ir1VBKywUZpCEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAALhbNPYeHuSgc1CZ4ziB6Y="
            },
            {
                "key": "BwS/nu9jE5tn/Qq/Ir1VBKywUZpCEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwTDdHds9cSXre72tQVYiwDLKYUx/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAiF+M9uRb3T/c3GRO/c0KyTiAx4E="
            },
            {
                "key": "BwTDdHds9cSXre72tQVYiwDLKYUx/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwTDdHds9cSXre72tQVYiwDLKYUx/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YkclowAAfWxsBbvRf5sAi1AGAAAAAvOy26SGPaKefVk="
            },
            {
                "key": "BwTDdHds9cSXre72tQVYiwDLKYUx/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAOEg8b+AzFWsdo0MfprqkElH+KI="
            },
            {
                "key": "BwTDdHds9cSXre72tQVYiwDLKYUx/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAGBcPlKoGY2kT9ev/KF9ZM="
            },
            {
                "key": "BwTDdHds9cSXre72tQVYiwDLKYUx/QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAABBnz9BYy3VD7nuZGIklR3jeBRRGsQYULpk4+cRbxIzYA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAirexPYdwLIJ3Hd/WY="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAABaluRROFh5W2fmqPfA5lUS0cVutAOe+ahZmTjJmisk6A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAOysPbdWGvDiDBMM0="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAABvrvL+3UQfYoMQ5KTUuQLZYFuAnotL5VWPtIeuscgang==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAABr9akcibfJ/z95/9I="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAABxD6TXoeTBr5otxkmu5PtVrBGUwQJ3jo7EmUcronXX9A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAIcTm06tw+bfqiBSA="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAAB3a7eyzg0HdakJk9o4F9RgsMlS7yJ82kb2FRtu4sdBPg==",
                "proof": [],
                "value": "//////////////////////////////////////////8="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAAB8AAkF1KdsEaww6ltiTEgLtQ7jyoWGIP7gJSb55KhYmg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAcYP3UGMNiIqkN7R8="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAACFX4KNInnWEnqd7gAYws+qsn8/Bs4fyzOrQ+u2E1bUdg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAZh7FasAIBbUBCkiI="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAACTXJc/Mmezh2pKDZfM3BHx36NYx59BNtxCy/meOh+8zg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAB9bGwFu9F/mwCLUAY="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAADDy8k/YRCr47/GqH2FVqkC1HW0RIWOeTTPE1HTDtvV8Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAADb5bc8uMl2s/YMsDY="
            },
            {
                "key": "BwTF4drsKtQB6+vdPjJRbZCrJRo6owEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAn2eJCcc1ABrGSC/M/JKOEbcDvK4="
            },
            {
                "key": "BwTGw8yE6r1GQ8OCyYj6KDBlf8cKawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAiF+M9uRb3T/c3GRO/c0KyTiAx4E="
            },
            {
                "key": "BwTGw8yE6r1GQ8OCyYj6KDBlf8cKawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA3NbU4rPh0eHm+owhyKMj3L7P+XA="
            },
            {
                "key": "BwTGw8yE6r1GQ8OCyYj6KDBlf8cKawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YkclYQAAAAHcSDM1FfL8RHudAAAAAMRQ3m7WtstndCY="
            },
            {
                "key": "BwTGw8yE6r1GQ8OCyYj6KDBlf8cKawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAEb84pePGzrBlGDxsDA9f0Joc="
            },
            {
                "key": "BwTGw8yE6r1GQ8OCyYj6KDBlf8cKawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAHec6I+dRJ8H/pbgCzhX5tsE="
            },
            {
                "key": "BwTGw8yE6r1GQ8OCyYj6KDBlf8cKawAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwTJve7TPNAVQeHu0Q+QUZ0sBv4/6wEAAABinAFp7wH2To9SkZ5LWaZ3+CEUas7D2b/z1iISJA3Ffg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABtwY9rBCyDV4="
            },
            {
                "key": "BwTJve7TPNAVQeHu0Q+QUZ0sBv4/6wEAAABpy9zBPihT/l16/AOLOFUbMV5hL0DFJN9gN0zhL+25JA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQkeBjk8yFs="
            },
            {
                "key": "BwTJve7TPNAVQeHu0Q+QUZ0sBv4/6wEAAADpDt73vhE7eYbL1p3MpuK62Kxll5YGwz21vFTDbHw3UQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAO6eX6lBFAb/E="
            },
            {
                "key": "BwTLqM/E5AwTP9nVwJJ2SebZl0ExKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABl",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA6NSlEAA="
            },
            {
                "key": "BwTLqM/E5AwTP9nVwJJ2SebZl0ExKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABm",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAZCRzK9dnL8wNo30ecKOKPIrF+Ac="
            },
            {
                "key": "BwTLqM/E5AwTP9nVwJJ2SebZl0ExKAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABn",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAa8P2X8UOSQYOIe1plr6W7ktAR1I="
            },
            {
                "key": "BwTLqM/E5AwTP9nVwJJ2SebZl0ExKDYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAABKGpnmjPBn0jNW3s27oIR8xMVV8="
            },
            {
                "key": "BwTLqM/E5AwTP9nVwJJ2SebZl0ExKLUxJ2hKVosxc64TufimAW4kPmO26O4ReNanF4ULXWED",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA6AbbBpN4jsedbEWok04Or5Svo34="
            },
            {
                "key": "BwTc1tTis+HR4eb6jCHIoyPcvs/5cAEAAABMa0OEYgmu0xI/0ogzpo0J3WEEmZyvTwaA55tqr2X3Pw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAdxIMzUV8vxEe50="
            },
            {
                "key": "BwTc1tTis+HR4eb6jCHIoyPcvs/5cAEAAAB3a7eyzg0HdakJk9o4F9RgsMlS7yJ82kb2FRtu4sdBPg==",
                "proof": [],
                "value": "//////////////////////////////////////////8="
            },
            {
                "key": "BwT6lDSEZ/ZNWkV/dfi8QEldM8ZauwEAAACWH6TdjYa0knYcWyugZMrot7wZkqiSqcJWj1gKVWX7DA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAD2Kh/txfw/1IJzk="
            },
            {
                "key": "BwT6lDSEZ/ZNWkV/dfi8QEldM8ZauwEAAADCZEj+YQh83i/tOC4E1DNeO9NSYjrOBjccpTpeKxswaw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAD///////////////8="
            },
            {
                "key": "BwcCUtQOC63tWZB635CLJC5Cm2kP7Q==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcPrQ7YSKehZSbop1dOQYsBXb9BtQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcSyHMx8IbDySYkj5ZPhwLAhC/Xfw==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcwusoniC2wlOoQZKI+KGbfrPxYSA==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwdkJHMr12cvzA2jfR5wo4o8isX4Bw==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwd/qmT69UdQouPuYhFmY1/q9AarIg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BweIX4z25FvdP9zcZE79zQrJOIDHgQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BweL7EeGWt47FyqSjfj5kLx/KjufeQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwehsXQunDLHyqlybYIEvVcV40GYYQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwejoe9a5lYVcgIzY4YuI4r6hMcu9Q==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwepyX/4Jdud1TBW1lrnBAMbSVnZmg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwe64NffzQPJDrzgA8WDMsE0anKDag==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfF4drsKtQB6+vdPjJRbZCrJRo6ow==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfJve7TPNAVQeHu0Q+QUZ0sBv4/6w==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwfc1tTis+HR4eb6jCHIoyPcvs/5cA==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwf6lDSEZ/ZNWkV/dfi8QEldM8Zauw==",
                "proof": [],
                "value": "AAAAAQ=="
            }
        ]
    }
}
'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/res/aurora_state_D98vwmi.json ---
{
    "id": "1",
    "jsonrpc": "2.0",
    "result": {
        "block_hash": "2PjpsB1gZgfHdvCV2PtBCiDgvWQo3uYavxUjkerZBWLM",
        "block_height": 64945380,
        "proof": [],
        "values": [
            {
                "key": "BwBTVEFURQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5FQVIGAAAAYXVyb3JhAAAAAAAAAAAAAAAA"
            },
            {
                "key": "BwEIrBI2rjmC7JRj7+EPDzINn1qaSw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEXQnYlkLsGiC7blauQaVsBzNfnpA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEaZC8OPDr1ReesvTiwclGzmQkU8Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF0="
            },
            {
                "key": "BwEkD9xeRGbkbkhXe3iG39UcB39z9g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwE16AHGJGSjebCdHu0htRh1InErbQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFPpZyuKx4NO7rbM4W6KbCzWCLorQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFt5Uck4SgnRSBgbwOFkaAMXpSh9g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwF5xXwkZ5RgbIOrMtxW5c0gMPtVKw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGRqZpSLW/DpCRwG4dUlyecQmwdcA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGVUunf5S/3WY7uZ18w6y1wctRceg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGY6NS09T+iotG5xlGvkZ/IOe5MGg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGevDGAo0Azymmhy6T0a9/JA0xgfA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGfH5M8ZgodyFbw4P4FhDWHnFzO8A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGh/JZ/2hQNqO4kHMpRkcdG2Bj3XA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwG789QoHxDlN9WxPKgL4iNiMQsr+Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwG8iiROj7aD7B/W+I88xuVlCCF06w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwG+RuQw0zb8gn0JbbBEy67s5y4XvA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwG/pRgh+LMOODnpqzNMiD5UBbvDjA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHCQgWxL7BWgisrLEK17hgnKgqOdA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHCv9jBeAQ1j6nwrWg9ICk0QYDOXw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHa3Zf6+uYT9TzSJb8K2XPe33nEPA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHhzwm9ouCJxjMw8P/j9ta3kINZcw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHimiNtOPYJ+niRhRoIKMi53Rl/bg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwH06yF7okVGE7FdvepuXyInZBDong==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwH6Zw0HclwEWG6R1/lwUSoz0NaT4A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwH6eGusN12IBhhVVRSSNazbGCwDOw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwIIrBI2rjmC7JRj7+EPDzINn1qaSw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIXQnYlkLsGiC7blauQaVsBzNfnpA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIaZC8OPDr1ReesvTiwclGzmQkU8Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIkD9xeRGbkbkhXe3iG39UcB39z9g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwI16AHGJGSjebCdHu0htRh1InErbQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJPpZyuKx4NO7rbM4W6KbCzWCLorQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJt5Uck4SgnRSBgbwOFkaAMXpSh9g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJ5xXwkZ5RgbIOrMtxW5c0gMPtVKw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKRqZpSLW/DpCRwG4dUlyecQmwdcA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKVUunf5S/3WY7uZ18w6y1wctRceg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKY6NS09T+iotG5xlGvkZ/IOe5MGg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKevDGAo0Azymmhy6T0a9/JA0xgfA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKfH5M8ZgodyFbw4P4FhDWHnFzO8A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKh/JZ/2hQNqO4kHMpRkcdG2Bj3XA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwK789QoHxDlN9WxPKgL4iNiMQsr+Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwK8iiROj7aD7B/W+I88xuVlCCF06w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwK+RuQw0zb8gn0JbbBEy67s5y4XvA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwK/pRgh+LMOODnpqzNMiD5UBbvDjA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLCQgWxL7BWgisrLEK17hgnKgqOdA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLCv9jBeAQ1j6nwrWg9ICk0QYDOXw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLa3Zf6+uYT9TzSJb8K2XPe33nEPA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLhzwm9ouCJxjMw8P/j9ta3kINZcw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLimiNtOPYJ+niRhRoIKMi53Rl/bg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwL06yF7okVGE7FdvepuXyInZBDong==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwL6Zw0HclwEWG6R1/lwUSoz0NaT4A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwL6eGusN12IBhhVVRSSNazbGCwDOw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwMIrBI2rjmC7JRj7+EPDzINn1qaSw==",
                "proof": [],
                "value": "YIBgQFJgBDYQYQL/V2AANWDgHIBjc6zumBFhAZBXgGPDf2jiEWEA3FeAY/Kzq70RYQCVV4Bj+FGkQBFhAG9XgGP4UaRAFGENTFeAY/j52igUYQ1hV4Bj/KeCCxRhDXZXgGP+nESuFGENoFdhAv9WW4Bj8rOrvRRhDMFXgGPz/bFaFGEM9FeAY/XjxGIUYQ0JV2EC/1ZbgGPDf2jiFGELr1eAY8Xr6uwUYQwIV4Bjz6mSARRhDDJXgGPbAGp1FGEMR1eAY91i7T4UYQxxV4Bj6ccU8hRhDKxXYQL/VluAY6av7ZURYQFJV4Bjrp1wsBFhASNXgGOunXCwFGELD1eAY7KgL/EUYQskV4Bjtx0aDBRhC2dXgGO9bYlNFGELmldhAv9WW4Bjpq/tlRRhCqxXgGOpBZy7FGEKwVeAY6pa8P0UYQr6V2EC/1ZbgGNzrO6YFGEJ5leAY4UqEuMUYQn7V4Bjj4QN3RRhCiVXgGOV2JtBFGEKOleAY5XdkZMUYQpPV4BjoHEtaBRhCoJXYQL/VluAYzr55mkRYQJPV4BjVVvMQBFhAghXgGNgGgvxEWEB4leAY2AaC/EUYQlfV4BjZ1LnAhRhCYlXgGNvMH3DFGEJnleAY3CggjEUYQmzV2EC/1ZbgGNVW8xAFGEIbVeAY1xg2hsUYQk1V4BjX+O1ZxRhCUpXYQL/VluAYzr55mkUYQcCV4BjOx0hohRhBzVXgGM+lBAQFGEHSleAY0SHFS8UYQd0V4BjRXa12xRhCCVXgGNHvTcYFGEIWFdhAv9WW4BjGBYN3RFhArxXgGMjuHLdEWEClleAYyO4ct0UYQYqV4BjJgj4GBRhBm1XgGMmeCJHFGEGpleAYzE85WcUYQbXV2EC/1ZbgGMYFg3dFGEFy1eAYxgt8PUUYQXgV4BjG+GVYBRhBfVXYQL/VluAYwb93gMUYQO/V4BjCTPB7RRhBElXgGMJXqezFGEE+leAYw51JwIUYQVHV4BjFzuZBBRhBYNXgGMXv9+8FGEFmFdbNBVhAzxXYEBRYkYbzWDlG4FSYAQBgIBgIAGCgQOCUmA3gVJgIAGAYR3sYDeROWBAAZFQUGBAUYCRA5D9W2ASVGBAUWAAkWABYAFgoBsDFpCCkDaQgIODgIKEN2BAUZIBlFBgAJNQkJFQUICDA4GFWvSRUFA9gGAAgRRhA59XYEBRkVBgHxlgPz0BFoIBYEBSPYJSPWAAYCCEAT5hA6RWW2BgkVBbUFCQUGBAUT1gAII+gYAVYQO7Vz2C81s9gv1bNIAVYQPLV2AAgP1bUGED1GENtVZbYECAUWAggIJSg1GBgwFSg1GRkoOSkIMBkYUBkICDg2AAW4OBEBVhBA5XgYEBUYOCAVJgIAFhA/ZWW1BQUFCQUJCBAZBgHxaAFWEEO1eAggOAUWABg2AgA2EBAAoDGRaBUmAgAZFQW1CSUFBQYEBRgJEDkPNbNIAVYQRVV2AAgP1bUGED1GAEgDYDYCCBEBVhBGxXYACA/VuBAZBgIIEBgTVgAWAgG4ERFWEEhldgAID9W4IBg2AgggERFWEEmFdgAID9W4A1kGAgAZGEYAGDAoQBEWABYCAbgxEXFWEEuVdgAID9W5GQgIBgHwFgIICRBAJgIAFgQFGQgQFgQFKAk5KRkIGBUmAgAYODgIKEN2AAkgGRkJFSUJKVUGEOQpRQUFBQUFZbNIAVYQUGV2AAgP1bUGEFM2AEgDYDYECBEBVhBR1XYACA/VtQYAFgAWCgGwOBNRaQYCABNWEOYVZbYECAUZEVFYJSUZCBkANgIAGQ81s0gBVhBVNXYACA/VtQYQVxYASANgNgIIEQFWEFaldgAID9W1A1YQ7YVltgQIBRkYJSUZCBkANgIAGQ81s0gBVhBY9XYACA/VtQYQVxYQ8/Vls0gBVhBaRXYACA/VtQYQVxYASANgNgIIEQFWEFu1dgAID9W1A1YAFgAWCgGwMWYQ9FVls0gBVhBddXYACA/VtQYQVxYQ+XVls0gBVhBexXYACA/VtQYQVxYQ+dVls0gBVhBgFXYACA/VtQYQYoYASANgNgIIEQFWEGGFdgAID9W1A1YAFgAWCgGwMWYQ/0VlsAWzSAFWEGNldgAID9W1BhBTNgBIA2A2BggRAVYQZNV2AAgP1bUGABYAFgoBsDgTWBFpFgIIEBNZCRFpBgQAE1YRBDVls0gBVhBnlXYACA/VtQYQVxYASANgNgQIEQFWEGkFdgAID9W1BgAWABYKAbA4E1FpBgIAE1YRDDVls0gBVhBrJXYACA/VtQYQa7YREZVltgQIBRYAFgAWCgGwOQkhaCUlGQgZADYCABkPNbNIAVYQbjV2AAgP1bUGEG7GERKFZbYECAUWD/kJIWglJRkIGQA2AgAZDzWzSAFWEHDldgAID9W1BhBXFgBIA2A2AggRAVYQclV2AAgP1bUDVgAWABYKAbAxZhETFWWzSAFWEHQVdgAID9W1BhBXFhEYNWWzSAFWEHVldgAID9W1BhBXFgBIA2A2AggRAVYQdtV2AAgP1bUDVhEbtWWzSAFWEHgFdgAID9W1BhA9RgBIA2A2AggRAVYQeXV2AAgP1bgQGQYCCBAYE1YAFgIBuBERVhB7FXYACA/VuCAYNgIIIBERVhB8NXYACA/VuANZBgIAGRhGABgwKEARFgAWAgG4MRFxVhB+RXYACA/VuRkICAYB8BYCCAkQQCYCABYEBRkIEBYEBSgJOSkZCBgVJgIAGDg4CChDdgAJIBkZCRUlCSlVBhEgKUUFBQUFBWWzSAFWEIMVdgAID9W1BhBXFgBIA2A2AggRAVYQhIV2AAgP1bUDVgAWABYKAbAxZhFCFWWzSAFWEIZFdgAID9W1BhBXFhFHNWWzSAFWEIeVdgAID9W1BhBihgBIA2A2BggRAVYQiQV2AAgP1bYAFgAWCgGwOCNRaRYCCBATUVFZGBAZBgYIEBYECCATVgAWAgG4ERFWEIwVdgAID9W4IBg2AgggERFWEI01dgAID9W4A1kGAgAZGEYAGDAoQBEWABYCAbgxEXFWEI9FdgAID9W5GQgIBgHwFgIICRBAJgIAFgQFGQgQFgQFKAk5KRkIGBUmAgAYODgIKEN2AAkgGRkJFSUJKVUGEUeZRQUFBQUFZbNIAVYQlBV2AAgP1bUGEGu2EWHFZbNIAVYQlWV2AAgP1bUGEGu2EWK1ZbNIAVYQlrV2AAgP1bUGEFcWAEgDYDYCCBEBVhCYJXYACA/VtQNWEWOlZbNIAVYQmVV2AAgP1bUGEFcWEWgVZbNIAVYQmqV2AAgP1bUGEGu2EWjFZbNIAVYQm/V2AAgP1bUGEFcWAEgDYDYCCBEBVhCdZXYACA/VtQNWABYAFgoBsDFmEWm1ZbNIAVYQnyV2AAgP1bUGEFcWEW7VZbNIAVYQoHV2AAgP1bUGEFcWAEgDYDYCCBEBVhCh5XYACA/VtQNWEXJVZbNIAVYQoxV2AAgP1bUGEFcWEXbFZbNIAVYQpGV2AAgP1bUGED1GEXclZbNIAVYQpbV2AAgP1bUGEFcWAEgDYDYCCBEBVhCnJXYACA/VtQNWABYAFgoBsDFmEXylZbNIAVYQqOV2AAgP1bUGEFcWAEgDYDYCCBEBVhCqVXYACA/VtQNWEYHFZbNIAVYQq4V2AAgP1bUGEFcWEYY1ZbNIAVYQrNV2AAgP1bUGEFM2AEgDYDYECBEBVhCuRXYACA/VtQYAFgAWCgGwOBNRaQYCABNWEYm1ZbNIAVYQsGV2AAgP1bUGEFcWEY8VZbNIAVYQsbV2AAgP1bUGEFcWEY91ZbNIAVYQswV2AAgP1bUGEFcWAEgDYDYGCBEBVhC0dXYACA/VtQYAFgAWCgGwOBNYEWkWAggQE1kJEWkGBAATVhGS9WWzSAFWELc1dgAID9W1BhBXFgBIA2A2AggRAVYQuKV2AAgP1bUDVgAWABYKAbAxZhGY1WWzSAFWELpldgAID9W1BhBXFhGd9WWzSAFWELu1dgAID9W1BhC+JgBIA2A2AggRAVYQvSV2AAgP1bUDVgAWABYKAbAxZhGhdWW2BAgFGUhVJgIIUBk5CTUoODAZGQkVJgYIMBUlGQgZADYIABkPNbNIAVYQwUV2AAgP1bUGEFcWAEgDYDYCCBEBVhDCtXYACA/VtQNWEaqVZbNIAVYQw+V2AAgP1bUGEFcWEa8FZbNIAVYQxTV2AAgP1bUGEFcWAEgDYDYCCBEBVhDGpXYACA/VtQNWEa9lZbNIAVYQx9V2AAgP1bUGEFcWAEgDYDYECBEBVhDJRXYACA/VtQYAFgAWCgGwOBNYEWkWAgATUWYRs9Vls0gBVhDLhXYACA/VtQYQVxYRuXVls0gBVhDM1XYACA/VtQYQVxYASANgNgIIEQFWEM5FdgAID9W1A1YAFgAWCgGwMWYRvPVls0gBVhDQBXYACA/VtQYQa7YRwhVls0gBVhDRVXYACA/VtQYQVxYASANgNgYIEQFWENLFdgAID9W1BgAWABYKAbA4E1gRaRYCCBATWRYECQkQE1FmEcMFZbNIAVYQ1YV2AAgP1bUGEGu2EckVZbNIAVYQ1tV2AAgP1bUGEFcWEcpVZbNIAVYQ2CV2AAgP1bUGEFcWAEgDYDYCCBEBVhDZlXYACA/VtQNWEc3VZbNIAVYQ2sV2AAgP1bUGEFM2EdJFZbYAGAVGBAgFFgIGAChIYWFWEBAAJgABkBkJQWk5CTBGAfgQGEkASEAoIBhAGQklKBgVKSkYMBgoKAFWEOOleAYB8QYQ4PV2EBAICDVAQCg1KRYCABkWEOOlZbggGRkGAAUmAgYAAgkFuBVIFSkGABAZBgIAGAgxFhDh1XgpADYB8WggGRW1BQUFBQgVZbYBJUYGCQYQ5bkGABYAFgoBsDFoNhHSlWW5KRUFBWW2BAgFFgAWABYKAbA4QWYCSCAVJgRICCAYSQUoJRgIMDkJEBgVJgZJCRAZCRUmAggQGAUWABYAFg4BsDFmMJXqezYOAbF5BSYACQYGCQYQ63kGEOQlZbkFCAgGAgAZBRYCCBEBVhDs5XYACA/VtQUZSTUFBQUFZbYECAUWAkgIIBhJBSglGAgwOQkQGBUmBEkJEBkJFSYCCBAYBRYAFgAWDgGwMWYwc6k4Fg4RsXkFJgAJBgYJBhDx+QYQ5CVluQUICAYCABkFFgIIEQFWEPNldgAID9W1BRk5JQUFBWW2AIVIFWW2BAgFFgAWABYKAbA4MWYCSAgwGRkJFSglGAgwOQkQGBUmBEkJEBkJFSYCCBAYBRYAFgAWDgGwMWYwXv9+9g4hsXkFJgAJBgYJBhDx+QYQ5CVltgDVSBVltgQIBRYASBUmAkgQGQkVJgIIEBgFFgAWABYOAbAxZjGC3w9WDgGxeQUmAAkGBgkGEP1ZBhEgJWW5BQgIBgIAGQUWAggRAVYQ/sV2AAgP1bUFGRUFCQVltgQIBRYAFgAWCgGwODFmAkgIMBkZCRUoJRgIMDkJEBgVJgRJCRAZCRUmAggQGAUWABYAFg4BsDFmLfDKtg5RsXkFJhED+QYQ5CVltQUFZbYECAUWABYAFgoBsDgIYWYCSDAVKEFmBEggFSYGSAggGEkFKCUYCDA5CRAYFSYISQkQGQkVJgIIEBgFFgAWABYOAbAxZjI7hy3WDgGxeQUmAAkGBgkGEQoZBhDkJWW5BQgIBgIAGQUWAggRAVYRC4V2AAgP1bUFGVlFBQUFBQVltgQIBRYAFgAWCgGwOEFmAkggFSYESAggGEkFKCUYCDA5CRAYFSYGSQkQGQkVJgIIEBgFFgAWABYOAbAxZjBMEfA2DjGxeQUmAAkGBgkGEOt5BhDkJWW2AEVGABYAFgoBsDFoFWW2ADVGD/FoFWW2BAgFFgAWABYKAbA4MWYCSAgwGRkJFSglGAgwOQkQGBUmBEkJEBkJFSYCCBAYBRYAFgAWDgGwMWYzr55mlg4BsXkFJgAJBgYJBhDx+QYQ5CVltgQIBRYASBUmAkgQGQkVJgIIEBgFFgAWABYOAbAxZjHY6Q0WDhGxeQUmAAkGBgkGEP1ZBhEgJWW2BAgFFgJICCAYSQUoJRgIMDkJEBgVJgRJCRAZCRUmAggQGAUWABYAFg4BsDFmMD6UEBYOQbF5BSYACQYGCQYQ8fkGEOQlZbYGBgAGBgMGABYAFgoBsDFoRgQFFgJAGAgGAgAYKBA4JSg4GBUYFSYCABkVCAUZBgIAGQgIODYABbg4EQFWESU1eBgQFRg4IBUmAgAWESO1ZbUFBQUJBQkIEBkGAfFoAVYRKAV4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUGBAgFFgHxmBhAMBgVKRgVJgIIIBgFFgAWABYOAbAxZjCTPB7WDgGxeBUpBRglGSlVCTUIOSUJCAg4NbYCCDEGES21eAUYJSYB8ZkJIBkWAgkYIBkQFhErxWW2ABg2AgA2EBAAoDgBmCURaBhFEWgIIXhVJQUFBQUFCQUAGRUFBgAGBAUYCDA4GFWvqRUFA9gGAAgRRhEztXYEBRkVBgHxlgPz0BFoIBYEBSPYJSPWAAYCCEAT5hE0BWW2BgkVBbUJFQkVBgAIIUFWETVVc9YCCCAf1bgIBgIAGQUWAggRAVYRNqV2AAgP1bgQGQgIBRYEBRk5KRkIRgAWAgG4IRFWETiVdgAID9W5CDAZBgIIIBhYERFWETnldgAID9W4JRYAFgIBuBEYKCAYgQFxVhE7dXYACA/VuCUlCBUWAgkYIBkpCRAZCAg4NgAFuDgRAVYRPkV4GBAVGDggFSYCABYRPMVltQUFBQkFCQgQGQYB8WgBVhFBFXgIIDgFFgAYNgIANhAQAKAxkWgVJgIAGRUFtQYEBSUFBQklBQUJGQUFZbYECAUWABYAFgoBsDgxZgJICDAZGQkVKCUYCDA5CRAYFSYESQkQGQkVJgIIEBgFFgAWABYOAbAxZjRXa122DgGxeQUmAAkGBgkGEPH5BhDkJWW2ALVIFWW2ADVGEBAJAEYAFgAWCgGwMWMxRhFMdXYEBRYkYbzWDlG4FSYAQBgIBgIAGCgQOCUmA5gVJgIAGAYR4jYDmROWBAAZFQUGBAUYCRA5D9W4EVYRUBV2BAgFFgBIFSYCSBAZCRUmAggQGAUWABYAFg4BsDFmMVOrUFYOAbF5BSYRT/kGEOQlZbUFtgEoBUYAFgAWCgGwOFgRZgAWABYKAbAxmDFheQklVgQFFgIGAkggGBgVKFUWBEhAFShVGUkJMWk2EVzZOGk5CSg5JgZJCSAZGQhQGQgIODYABbg4EQFWEVa1eBgQFRg4IBUmAgAWEVU1ZbUFBQUJBQkIEBkGAfFoAVYRWYV4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUGBAgFFgHxmBhAMBgVKRkFJgIIEBgFFgAWABYOAbAxZjCtzO5WDjGxeQUpJQYQ5CkVBQVltQYBJUYECAUWABYAFgoBsDgIUWglKQkhZgIIMBUoBRf9YE3pTUWVP5E4B57BuC1TPLIWDJBtEHbR9+1UvvvKl6koGQA5CRAZChUFBQUFZbYBJUYAFgAWCgGwMWgVZbYAVUYAFgAWCgGwMWgVZbYECAUWAkgIIBhJBSglGAgwOQkQGBUmBEkJEBkJFSYCCBAYBRYAFgAWDgGwMWY2AaC/Fg4BsXkFJgAJBgYJBhDx+QYQ5CVltmY3naBbYAAIFWW2ARVGABYAFgoBsDFoFWW2BAgFFgAWABYKAbA4MWYCSAgwGRkJFSglGAgwOQkQGBUmBEkJEBkJFSYCCBAYBRYAFgAWDgGwMWY3CggjFg4BsXkFJgAJBgYJBhDx+QYRICVltgQIBRYASBUmAkgQGQkVJgIIEBgFFgAWABYOAbAxZjDnWd02DjGxeQUmAAkGBgkGEP1ZBhDkJWW2BAgFFgJICCAYSQUoJRgIMDkJEBgVJgRJCRAZCRUmAggQGAUWABYAFg4BsDFmOFKhLjYOAbF5BSYACQYGCQYQ8fkGEOQlZbYAxUgVZbYAKAVGBAgFFgIGABhBYVYQEAAmAAGQGQkxaEkARgH4EBhJAEhAKCAYQBkJJSgYFSkpGDAYKCgBVhDjpXgGAfEGEOD1dhAQCAg1QEAoNSkWAgAZFhDjpWW2BAgFFgAWABYKAbA4MWYCSAgwGRkJFSglGAgwOQkQGBUmBEkJEBkJFSYCCBAYBRYAFgAWDgGwMWY5XdkZNg4BsXkFJgAJBgYJBhDx+QYRICVltgQIBRYCSAggGEkFKCUYCDA5CRAYFSYESQkQGQkVJgIIEBgFFgAWABYOAbAxZjFA4lrWDjGxeQUmAAkGBgkGEPH5BhDkJWW2BAgFFgBIFSYCSBAZCRUmAggQGAUWABYAFg4BsDFmOmr+2VYOAbF5BSYACQYGCQYQ/VkGEOQlZbYECAUWABYAFgoBsDhBZgJIIBUmBEgIIBhJBSglGAgwOQkQGBUmBkkJEBkJFSYCCBAYBRYAFgAWDgGwMWY6kFnLtg4BsXkFJgAJBgYJBhDreQYQ5CVltgClSBVltgQIBRYASBUmAkgQGQkVJgIIEBgFFgAWABYOAbAxZjCunXC2DkGxeQUmAAkGBgkGEP1ZBhEgJWW2BAgFFgAWABYKAbA4CGFmAkgwFShBZgRIIBUmBkgIIBhJBSglGAgwOQkQGBUmCEkJEBkJFSYCCBAYBRYAFgAWDgGwMWY7KgL/Fg4BsXkFJgAJBgYJBhEKGQYQ5CVltgQIBRYAFgAWCgGwODFmAkgIMBkZCRUoJRgIMDkJEBgVJgRJCRAZCRUmAggQGAUWABYAFg4BsDFmMtx0aDYOIbF5BSYACQYGCQYQ8fkGEOQlZbYECAUWAEgVJgJIEBkJFSYCCBAYBRYAFgAWDgGwMWY71tiU1g4BsXkFJgAJBgYJBhD9WQYQ5CVltgQIBRYAFgAWCgGwODFmAkgIMBkZCRUoJRgIMDkJEBgVJgRJCRAZCRUmAggQGAUWABYAFg4BsDFmNhv7RxYOEbF5BSYACQgZCBkIGQYGCQYRpvkGESAlZbkFCAgGAgAZBRYICBEBVhGoZXYACA/VtQgFFgIIIBUWBAgwFRYGCQkwFRkZmQmFCRllCUUJJQUFBWW2BAgFFgJICCAYSQUoJRgIMDkJEBgVJgRJCRAZCRUmAggQGAUWABYAFg4BsDFmMxevq7YOIbF5BSYACQYGCQYQ8fkGEOQlZbYAlUgVZbYECAUWAkgIIBhJBSglGAgwOQkQGBUmBEkJEBkJFSYCCBAYBRYAFgAWDgGwMWY9sAanVg4BsXkFJgAJBgYJBhDx+QYQ5CVltgQIBRYAFgAWCgGwOAhRZgJIMBUoMWYESAgwGRkJFSglGAgwOQkQGBUmBkkJEBkJFSYCCBAYBRYAFgAWDgGwMWY26xdp9g4RsXkFJgAJBgYJBhDreQYRICVltgQIBRYASBUmAkgQGQkVJgIIEBgFFgAWABYOAbAxZjdOOKeWDhGxeQUmAAkGBgkGEP1ZBhDkJWW2BAgFFgAWABYKAbA4MWYCSAgwGRkJFSglGAgwOQkQGBUmBEkJEBkJFSYCCBAYBRYAFgAWDgGwMWY/Kzq71g4BsXkFJgAJBgYJBhDx+QYQ5CVltgBlRgAWABYKAbAxaBVltgQIBRYAFgAWCgGwOAhhZgJIMBUmBEggGFkFKDFmBkgIMBkZCRUoJRgIMDkJEBgVJghJCRAZCRUmAggQGAUWABYAFg4BsDFmN68eIxYOEbF5BSYACQYGCQYRChkGEOQlZbYANUYQEAkARgAWABYKAbAxaBVltgQIBRYASBUmAkgQGQkVJgIIEBgFFgAWABYOAbAxZjHx87RWDjGxeQUmAAkGBgkGEP1ZBhEgJWW2BAgFFgJICCAYSQUoJRgIMDkJEBgVJgRJCRAZCRUmAggQGAUWABYAFg4BsDFmP8p4ILYOAbF5BSYACQYGCQYQ8fkGEOQlZbYAGBVltgYGAAYGCEYAFgAWCgGwMWhGBAUYCCgFGQYCABkICDg1tgIIMQYR1pV4BRglJgHxmQkgGRYCCRggGRAWEdSlZbYAGDYCADYQEACgOAGYJRFoGEURaAgheFUlBQUFBQUJBQAZFQUGAAYEBRgIMDgYVa9JFQUD2AYACBFGEdyVdgQFGRUGAfGWA/PQEWggFgQFI9glI9YABgIIQBPmEdzlZbYGCRUFtQkVCRUGAAghQVYR3jVz1gIIIB/VuUk1BQUFBW/kNFcmMyMERlbGVnYXRvcjpmYWxsYmFjazogY2Fubm90IHNlbmQgdmFsdWUgdG8gZmFsbGJhY2tDRXJjMjBEZWxlZ2F0b3I6Ol9zZXRJbXBsZW1lbnRhdGlvbjogQ2FsbGVyIG11c3QgYmUgYWRtaW6iZWJ6enIxWCAhblzi5bsze0XjzTxdCHbR+0aHu+/yhN7brq8f1Ce9zWRzb2xjQwAFEAAy"
            },
            {
                "key": "BwMXQnYlkLsGiC7blauQaVsBzNfnpA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwMkD9xeRGbkbkhXe3iG39UcB39z9g==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEAfVdgADVg4ByAY0C8CvQRYQBbV4BjQLwK9BRhAOFXgGNsLfanFGEA6VeAY25x4tgUYQDxV4BjuBaIFhRhARpXYQB9VluAYwxXSGEUYQCCV4BjFfJAUxRhAJxXgGMhkfkqFGEAxVdbYACA/VthAIphAUlWW2BAgFGRglJRkIGQA2AgAZDzW2EAimAEgDYDYGCBEBVhALJXYACA/VtQgDWQYCCBATWQYEABNWEBUVZbYQDNYQGrVltgQIBRkRUVglJRkIGQA2AgAZDzW2EAimEBsFZbYQCKYQG2VlthAIpgBIA2A2BggRAVYQEHV2AAgP1bUIA1kGAggQE1kGBAATVhAbxWW2EAimAEgDYDYICBEBVhATBXYACA/VtQgDWQYCCBATWQYECBATWQYGABNWECDlZbYwHhM4CBVltgAIBhAV+FhYVhAbxWW5BQYQGgYAFUYQGUZw3gtrOnZAAAYQGIYABUhmECjZCRkGP/////FlZbkGP/////YQLvFlZbkGP/////YQMxFlZbkVBQW5OSUFBQVltgAYFWW2ABVIFWW2AAVIFWW2AAgmEBy1dQYABhAaRWW2ECBmEB7oNhAeKHh2P/////YQMxFlZbkGP/////YQOLFlZbYQGIhWcN4Lazp2QAAGP/////YQKNFlZblJNQUFBQVltgAIBhAilnDeC2s6dkAACEY/////9hA4sWVluQUGAAYQI4h4eHYQFRVluQUGAAYQJYZw3gtrOnZAAAYQGIhIZj/////2ECjRZWW5BQYQKBZw3gtrOnZAAAYQGIg2ECdYyMjGEBvFZbkGP/////YQKNFlZbmJdQUFBQUFBQUFZbYACCYQKcV1BgAGEC6VZbgoICgoSCgWECqVf+WwQUYQLmV2BAUWJGG81g5RuBUmAEAYCAYCABgoEDglJgIYFSYCABgGEEymAhkTlgQAGRUFBgQFGAkQOQ/VuQUFuSkVBQVltgAGEC5oODYEBRgGBAAWBAUoBgGoFSYCABf1NhZmVNYXRoOiBkaXZpc2lvbiBieSB6ZXJvAAAAAAAAgVJQYQPNVltgAIKCAYOBEBVhAuZXYECAUWJGG81g5RuBUmAgYASCAVJgG2AkggFSf1NhZmVNYXRoOiBhZGRpdGlvbiBvdmVyZmxvdwAAAAAAYESCAVKQUZCBkANgZAGQ/VtgAGEC5oODYEBRgGBAAWBAUoBgH4FSYCABf1NhZmVNYXRoOiBzdWJ0cmFjdGlvbiB1bmRlcmZsb3cAgVJQYQRvVltgAIGDYQRZV2BAUWJGG81g5RuBUmAEAYCAYCABgoEDglKDgYFRgVJgIAGRUIBRkGAgAZCAg4NgAFuDgRAVYQQeV4GBAVGDggFSYCABYQQGVltQUFBQkFCQgQGQYB8WgBVhBEtXgIIDgFFgAYNgIANhAQAKAxkWgVJgIAGRUFtQklBQUGBAUYCRA5D9W1BgAIOFgWEEZVf+WwSVlFBQUFBQVltgAIGEhBEVYQTBV2BAUWJGG81g5RuBUmAgYASCAYGBUoNRYCSEAVKDUZCSg5JgRJCRAZGQhQGQgIODYACDFWEEHleBgQFRg4IBUmAgAWEEBlZbUFBQkAOQVv5TYWZlTWF0aDogbXVsdGlwbGljYXRpb24gb3ZlcmZsb3eiZWJ6enIxWCAix20Hi3TdFZ6iUPoc+4QKsLp55X9fwMdZYd1QSSQXwGRzb2xjQwAFEAAy"
            },
            {
                "key": "BwMstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "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UFCWUJaUUFBQUFBWW2AAgRWAYULzV1BQgIICgoKCgWFC8Ff+WwQUW2ERi1dgQIBRYkYbzWDlG4FSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1tdWwtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W4CCAYKBEBVhEYtXYECAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSf2RzLW1hdGgtYWRkLW92ZXJmbG93AAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgAIBgAGFDq4WFYT9pVltQkFBgAIBhQ7yIiIhhNMtWW2ABYAFgoBsDFmMJAvGsYEBRgWP/////FmDgG4FSYAQBYGBgQFGAgwOBhoA7FYAVYUP0V2AAgP1bUFr6FYAVYUQIVz1gAIA+PWAA/VtQUFBQYEBRPWBggRAVYUQeV2AAgP1bUIBRYCCQkQFRbf//////////////////kYIWk1AWkFBgAWABYKAbA4eBFpCEFhRhRFhXgIJhRFtWW4GBW5CZkJhQllBQUFBQUFBW/lVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9PVVRQVVRfQU1PVU5UVW5pc3dhcFYyTGlicmFyeTogSURFTlRJQ0FMX0FERFJFU1NFU1VuaXN3YXBWMlJvdXRlcjogSU5TVUZGSUNJRU5UX0JfQU1PVU5UVW5pc3dhcFYyTGlicmFyeTogSU5TVUZGSUNJRU5UX0xJUVVJRElUWVVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IEVYQ0VTU0lWRV9JTlBVVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IElOU1VGRklDSUVOVF9BX0FNT1VOVFRyYW5zZmVySGVscGVyOiBFVEhfVFJBTlNGRVJfRkFJTEVEVW5pc3dhcFYyUm91dGVyOiBJTlNVRkZJQ0lFTlRfT1VUUFVUX0FNT1VOVFRyYW5zZmVySGVscGVyOiBUUkFOU0ZFUl9GUk9NX0ZBSUxFRFVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IEVYUElSRUQAAAAAAAAAAKFkc29sY0MABgwACg=="
            },
            {
                "key": "BwM16AHGJGSjebCdHu0htRh1InErbQ==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEATFdgADVg4ByAYzZZz+YUYQBRV4BjXGDaGxRhAGZXgGOS7v6bFGEAj1eAY/d8R5EUYQCiV1tgAID9W2EAZGEAXzZgBGEC6FZbYQC1VlsAW2AAVGABYAFgoBsDFltgQFFgAWABYKAbA5CRFoFSYCABYEBRgJEDkPNbYQBkYQCdNmAEYQLoVlthAP1WW2ABVGEAc5BgAWABYKAbAxaBVlthAL1hATZWW2EAxoFhAlNWW2BAUWABYAFgoBsDghaQf7x811og7if9mt66syBB91UhTbxr/6kMwCJbOdouXC07kGAAkKJQVlthAQVhATZWW2ABgFRgAWABYKAbAxkWYAFgAWCgGwOSkJIWkZCRF5BVVltgAWABYKAbAxY7FRWQVltgAVRgQIBRY6IX/d9g4BuBUpBRYAFgAWCgGwOQkhaRY5HRSFSRg5Fjohf935FgBICCAZJgIJKQkZCCkAMBgYZa+hWAFWEBiFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhAayRkGEDGFZbYEBRYAFgAWDgGwMZYOCEkBsWgVJgBIEBkZCRUjNgJIIBUmBEAWAgYEBRgIMDgYZa+hWAFWEB7lc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhAhKRkGEDMVZbYQJRV2BAUWJGG81g5RuBUmAgYASCAVJgC2AkggFSaiFnb3Zlcm5hbmNlYKgbYESCAVJgZAFbYEBRgJEDkP1bVltgAWABYKAbA4EWO2ECxldgQFFiRhvNYOUbgVJgIGAEggFSYDNgJIIBUn9VcGdyYWRlYWJsZUJlYWNvbjogaW1wbGVtZW50YXRpb2BEggFSchuIGlzIG5vdCBhIGNvbnRyYWN1gahtgZIIBUmCEAWECSFZbYACAVGABYAFgoBsDGRZgAWABYKAbA5KQkhaRkJEXkFVWW2AAYCCChAMSFWEC+ldgAID9W4E1YAFgAWCgGwOBFoEUYQMRV2AAgP1bk5JQUFBWW2AAYCCChAMSFWEDKldgAID9W1BRkZBQVltgAGAggoQDEhVhA0NXYACA/VuBUYAVFYEUYQMRV2AAgP3+omRpcGZzWCISIJtR/sgx2C6n7ORYeaiNIShbJdO03/Mc6eBtKtF+WYt3ZHNvbGNDAAgNADM="
            },
            {
                "key": "BwNPpZyuKx4NO7rbM4W6KbCzWCLorQ==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwNt5Uck4SgnRSBgbwOFkaAMXpSh9g==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwN5xXwkZ5RgbIOrMtxW5c0gMPtVKw==",
                "proof": [],
                "value": "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Anf///////////////////////////////+QkhaRkJEXkJNVVINRkYJSM5KCAZKQklKSFpJQfxfqvQpm+mMfdTfO/dXfaqJdWskEz3WW6VjUOnWgDQ1okQFgQFGAkQOQolBWW2AAgGAAgGAAY/////+Gaf////////////8WERVgQFGAYEABYEBSgGAPgVJgIAF/Tm8gZGF0YSBwcmVzZW50AAAAAAAAAAAAAAAAAAAAAACBUlCQYQfbV2BAUWJGG81g5RuBUmAEAWEFZ5GQYQzyVltQUFBQY/////+DFmAAkIFSYAJgIJCBUmBAkYKQIIJRgIQBkJNSVGAXgZALgIRSYAFgwBuQkQRn//////////8WkpCRAYKQUpOUkJJQgpFQhJBWW2AAY/////+CERVhCERXUGAAkZBQVltQY/////8WYACQgVJgAmAgUmBAkCBUYBcLkFZbYABj/////4IRFWEIdldQYACRkFBWW1Bj/////xZgAJCBUmACYCBSYECQIFRgAWDAG5AEZ///////////FpBWW2AAgoFSYCCBkFJgQJAgYAEBVGEIvIEzYQlNVlthBOiDg2EKaVZbYACAMzIUYQkYV2BAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSf09ubHkgY2FsbGFibGUgYnkgRU9BAAAAAAAAAAAAAAAAYESCAVJgZAFhBWdWW1BQYAFUY/////8WYACQgVJgAmAgUmBAkCBUYBeBkAuRYAFgwBuQkQRn//////////8WkFZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2EJiYFgAWABYKAbAxZgFGEK6FZbYQmUg2AgYQroVltgQFFgIAFhCaWSkZBhDj5WW2BAgFFgHxmBhAMBgVKQgpBSYkYbzWDlG4JSYQVnkWAEAWEM8lZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaEUpCRUpAggFRg/xkWYAEXkFVhCiUzkFZbYAFgAWCgGwMWgWABYAFgoBsDFoN/L4eIEX5+/x2C6SbseUkB0Xx4AkpQJwlAMEVApzNlbw1gQFFgQFGAkQOQpFBQVltgAIKBUmAggYFSYECAgyBgAWABYKAbA4UWhFKQkVKQIFRg/xYVYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaAhVKSUoCDIIBUYP8ZFpBVUTOShZF/9jkfXDLZxp0qR+pnC0QpdLU5NdHtx/1k6yHgR6g5FxuRkKRQUFZbYGBgAGEK94NgAmEOv1ZbYQsCkGACYQ7eVltn//////////+BERVhCxpXYQsaYQ72VltgQFGQgIJSgGAfAWAfGRZgIAGCAWBAUoAVYQtEV2AgggGBgDaDNwGQUFtQkFBgA2D8G4FgAIFRgRBhC19XYQtfYQ8MVltgIAEBkGABYAFg+BsDGRaQgWAAGpBTUGAPYPsbgWABgVGBEGELjldhC45hDwxWW2AgAQGQYAFgAWD4GwMZFpCBYAAakFNQYABhC7KEYAJhDr9WW2ELvZBgAWEO3lZbkFBbYAGBERVhDEJXfzAxMjM0NTY3ODlhYmNkZWYAAAAAAAAAAAAAAAAAAAAAhWAPFmAQgRBhC/5XYQv+YQ8MVlsaYPgbgoKBUYEQYQwUV2EMFGEPDFZbYCABAZBgAWABYPgbAxkWkIFgABqQU1BgBJSQlByTYQw7gWEPIlZbkFBhC8BWW1CDFWEMkVdgQFFiRhvNYOUbgVJgIGAEggGBkFJgJIIBUn9TdHJpbmdzOiBoZXggbGVuZ3RoIGluc3VmZmljaWVudGBEggFSYGQBYQVnVluTklBQUFZbYABgIIKEAxIVYQyqV2AAgP1bgTVgAWABYOAbAxmBFoEUYQyRV2AAgP1bYABbg4EQFWEM3VeBgQFRg4IBUmAgAWEMxVZbg4ERFWEM7FdgAISEAVJbUFBQUFZbYCCBUmAAglGAYCCEAVJhDRGBYECFAWAghwFhDMJWW2AfAWAfGRaRkJEBYEABkpFQUFZbYABgIIKEAxIVYQ03V2AAgP1bUDWRkFBWW2AAgGBAg4UDEhVhDVFXYACA/VuCNZFQYCCDATVgAWABYKAbA4EWgRRhDW9XYACA/VuAkVBQklCSkFBWW2AAYCCChAMSFWENjFdgAID9W4E1gGAXC4EUYQyRV2AAgP1bYABgIIKEAxIVYQ2vV2AAgP1bgTVp/////////////4EWgRRhDJFXYACA/VtgAYGBHJCCFoBhDd1XYH+CFpFQW2AgghCBFBVhDf5XY05Ie3Fg4BtgAFJgImAEUmAkYAD9W1CRkFBWW2NOSHtxYOAbYABSYBFgBFJgJGAA/VtgAGP/////gIMWgYEUFWEONFdhDjRhDgRWW2ABAZOSUFBQVlt/QWNjZXNzQ29udHJvbDogYWNjb3VudCAAAAAAAAAAAACBUmAAg1FhDnaBYBeFAWAgiAFhDMJWW38gaXMgbWlzc2luZyByb2xlIAAAAAAAAAAAAAAAAAAAAGAXkYQBkYIBUoNRYQ6zgWAohAFgIIgBYQzCVlsBYCgBlJNQUFBQVltgAIFgABkEgxGCFRUWFWEO2VdhDtlhDgRWW1ACkFZbYACCGYIRFWEO8VdhDvFhDgRWW1ABkFZbY05Ie3Fg4BtgAFJgQWAEUmAkYAD9W2NOSHtxYOAbYABSYDJgBFJgJGAA/VtgAIFhDzFXYQ8xYQ4EVltQYAAZAZBW/qFkc29sY0MACAkACg=="
            },
            {
                "key": "BwORqZpSLW/DpCRwG4dUlyecQmwdcA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOVUunf5S/3WY7uZ18w6y1wctRceg==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOY6NS09T+iotG5xlGvkZ/IOe5MGg==",
                "proof": [],
                "value": "YIBgQFJgBDYQYQFmV2AANWDgHIBjeTeWnRFhANFXgGOcOeKTEWEAileAY78JWVURYQBkV4BjvwlZVRRhBBpXgGPYHF5FFGEEOleAY+ybJoUUYQRaV4Bj+FGkQBRhBHpXYQFmVluAY5w54pMUYQO6V4BjsNsZZBRhA9pXgGO0vlBuFGED+ldhAWZWW4BjeTeWnRRhAx1XgGN5a4m5FGEDPVeAY4Ep/BwUYQNSV4BjiAVxSxRhA2dXgGOI6XK4FGEDeleAY4utON0UYQOaV2EBZlZbgGNLOgp0EWEBI1eAY0s6CnQUYQJLV4BjX+O1ZxRhAnlXgGNm+RokFGECm1eAY2cOiv0UYQK9V4BjcEtsAhRhAt1XgGN0RTKuFGEC/VdhAWZWW4BjAwzmOBRhAWhXgGMFuXg9FGEBnleAYwlSxWMUYQG+V4BjHZTLlBRhAd5XgGMp9M6NFGEB/leAYy8ysR8UYQIrV1sAWzSAFWEBdFdgAID9W1BhAYhhAYM2YARhJg5WW2EEj1ZbYEBRYQGVkZBhLRdWW2BAUYCRA5DzWzSAFWEBqldgAID9W1BhAYhhAbk2YARhJg5WW2EErFZbNIAVYQHKV2AAgP1bUGEBZmEB2TZgBGEmDlZbYQTJVls0gBVhAepXYACA/VtQYQFmYQH5NmAEYSezVlthBVxWWzSAFWECCldgAID9W1BhAh5hAhk2YARhJdJWW2EFv1ZbYEBRYQGVkZBhK8hWWzSAFWECN1dgAID9W1BhAWZhAkY2YARhJohWW2EF5lZbNIAVYQJXV2AAgP1bUGECa2ECZjZgBGEmDlZbYQZ4VltgQFFhAZWSkZBhLPxWWzSAFWEChVdgAID9W1BhAo5hBq1WW2BAUWEBlZGQYSv/Vls0gBVhAqdXYACA/VtQYQKwYQa8VltgQFFhAZWRkGEs7lZbNIAVYQLJV2AAgP1bUGEBZmEC2DZgBGEk2lZbYQbOVls0gBVhAulXYACA/VtQYQFmYQL4NmAEYSS0VlthByRWWzSAFWEDCVdgAID9W1BhAWZhAxg2YARhJi1WW2EHcFZbNIAVYQMpV2AAgP1bUGEBiGEDODZgBGEmy1ZbYQfOVls0gBVhA0lXYACA/VtQYQGIYQfxVls0gBVhA15XYACA/VtQYQFmYQf1VlthAWZhA3U2YARhJw5WW2EIOVZbNIAVYQOGV2AAgP1bUGEBiGEDlTZgBGEmy1ZbYQuHVls0gBVhA6ZXYACA/VtQYQFmYQO1NmAEYSS0VlthC6pWWzSAFWEDxldgAID9W1BhAWZhA9U2YARhJRRWW2EL9lZbNIAVYQPmV2AAgP1bUGECHmED9TZgBGEl0lZbYQxlVls0gBVhBAZXYACA/VtQYQFmYQQVNmAEYSS0VlthDI9WWzSAFWEEJldgAID9W1BhAYhhBDU2YARhJg5WW2ENSVZbNIAVYQRGV2AAgP1bUGECa2EEVTZgBGEmDlZbYQ1mVls0gBVhBGZXYACA/VtQYQFmYQR1NmAEYSYOVlthDZtWWzSAFWEEhldgAID9W1BhAh5hDnFWW2ACYCCQgVJgAJKDUmBAgIQgkJFSkIJSkCBUgVZbYAhgIJCBUmAAkoNSYECAhCCQkVKQglKQIFSBVlthBViCgmABYACQVJBhAQAKkARgAWABYKAbAxZgAWABYKAbAxZjsHctC2BAUYFj/////xZg4BuBUmAEAWAAYEBRgIMDgYaAOxWAFWEFHFdgAID9W1Ba+hWAFWEFMFc9YACAPj1gAP1bUFBQUGBAUT1gAII+YB89kIEBYB8ZFoIBYEBSYQMYkZCBAZBhJWFWW1BQVltgCVRg/4UWEGEFiVdgQFFiRhvNYOUbgVJgBAFhBYCQYSx+VltgQFGAkQOQ/VthBZFhDoBWW2EFrVdgQFFiRhvNYOUbgVJgBAFhBYCQYSzOVlthBbmEhISEYQ6pVltQUFBQVltgCYGBVIEQYQXMV/5bYACRglJgIJCRIAFUYAFgAWCgGwMWkFCBVlthBe5hDoBWW2EGCldgQFFiRhvNYOUbgVJgBAFhBYCQYSxeVltgAGEGF4SEhGEUD1ZbkFCAFWEGN1dgQFFiRhvNYOUbgVJgBAFhBYCQYSyOVlt/xtO62JCqFTYukGEfhkO/r89bCanUeBKVvXuorf+gNxGEhIRgQFFhBmqTkpGQYS1AVltgQFGAkQOQoVBQUFBWW2AFYCCQgVJgAJKDUmBAgIQgkJFSkIJSkCBUYAFgAWDgGwOBFpBgAWDgG5AEY/////8WglZbYAFUYAFgAWCgGwMWgVZbagwJfOe8kHFbNLnxYCQbgVZbYQbWYQ6AVlthBvJXYEBRYkYbzWDlG4FSYAQBYQWAkGEsblZbYABbYAlUYP+CFhAVYQcfV2EHDIGEYRViVlthBxeBhIRhGDNWW2ABAWEG9VZbUFBQVltgAFRgAWABYKAbAxYzFGEHTldgQFFiRhvNYOUbgVJgBAFhBYCQYSy+VltgAIBUYAFgAWCgGwMZFmABYAFgoBsDkpCSFpGQkReQVVZbYECAUWABgIJSgYMBkJJSYGCRYCCAgwGQgDiDOQGQUFCQUIKBYACBUYEQYQegV/5bYCACYCABAZBgAWABYKAbAxaQgWABYAFgoBsDFoFSUFBhBbmEgoRgAYBhCDlWW2AHYCCQgVJgAJOEUmBAgIUgglKShFKChCCQUoJSkCBUgVZbQpBWW2AKVGD/FhVhCBhXYEBRYkYbzWDlG4FSYAQBYQWAkGEsrlZbYAGAVGABYAFgoBsDGRYzF4FVYAqAVGD/GRaQkReQVVZbYAlUYP+GFhBhCF1XYEBRYkYbzWDlG4FSYAQBYQWAkGEsflZbYABbg1GBEBVhC39XYACEgoFRgRBhCHdX/ltgIJCBApGQkQEBUWABVGBAUWM9mKHlYOAbgVKRklBgAWABYKAbAxaQYz2YoeWQYQizkISQYAQBYSvIVltgIGBAUYCDA4GGgDsVgBVhCMtXYACA/VtQWvoVgBVhCN9XPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQYQkDkZCBAZBhJZZWW2EJH1dgQFFiRhvNYOUbgVJgBAFhBYCQYSxOVltgAYQVFRQVYQqnV2EJMmEin1ZbYEBRgGAgAWBAUoCDYAFgAWCgGwMWY6pa8P1gQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGgDsVgBVhCXZXYACA/VtQWvoVgBVhCYpXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQYQmukZCBAZBhJfBWW5BSkFBhCb2Ig4NhGmxWW2AAW4dRgRAVYQqkV2EJ6ImEioSBUYEQYQnaV/5bYCACYCABAVGFYR1+VlthClWJiYOBUYEQYQn4V/5bYCACYCABAVFgCGAAjWD/FmD/FoFSYCABkIFSYCABYAAgYACMhoFRgRBhCidX/ltgIAJgIAEBUWABYAFgoBsDFmABYAFgoBsDFoFSYCABkIFSYCABYAAgVGEUD1ZbYP+KFmAAkIFSYAhgIFJgQIEgilGQkZCLkIWQgRBhCnhX/ltgIJCBApGQkQGBAVFgAWABYKAbAxaCUoEBkZCRUmBAAWAAIFVgAQFhCcBWW1BQW2ABgxUVFBVhC3ZXYQq8h4JhFWJWW2AAW4ZRgRAVYQt0V2EK5oiDiYSBUYEQYQrZV/5bYCACYCABAVFhGDNWW2ELJYiIg4FRgRBhCvZX/ltgIAJgIAEBUWAIYACMYP8WYP8WgVJgIAGQgVJgIAFgACBgAIuGgVGBEGEKJ1f+W2D/iRZgAJCBUmAIYCBSYECBIIlRkJGQipCFkIEQYQtIV/5bYCCQgQKRkJEBgQFRYAFgAWCgGwMWglKBAZGQkVJgQAFgACBVYAEBYQq/VltQW1BgAQFhCGBWW1BQUFBQUFZbYAZgIJCBUmAAk4RSYECAhSCCUpKEUoKEIJBSglKQIFSBVltgAFRgAWABYKAbAxYzFGEL1FdgQFFiRhvNYOUbgVJgBAFhBYCQYSyeVltgAYBUYAFgAWCgGwMZFmABYAFgoBsDkpCSFpGQkReQVVZbYQv+YQ6AVlthDBpXYEBRYkYbzWDlG4FSYAQBYQWAkGEsLlZbYABbYAlUYP+CFhAVYQW5V2EMQ4GFYQw+NoaQA4YBhmEltFZbYRpsVlthDF2BhYVhDFg2h5ADhwGHYSW0VlthHX5WW2ABAWEMHVZbYABgCYKBVIEQYQx0V/5bYACRglJgIJCRIAFUYAFgAWCgGwMWkpFQUFZbYABUYAFgAWCgGwMWMxRhDLlXYEBRYkYbzWDlG4FSYAQBYQWAkGEs3lZbYAmAVGABgQGCVWAAgpBSf24VQBcbbAyWC3GnAg2fYAd/avkxqLv1kNoCI9rPdcevAYBUYAFgAWCgGwMZFmABYAFgoBsDhBYXkFVUYEBRYAAZkJEBkH/LKdb3e9ROV74yX4kKnlee/hPC/2+tYkwTitNlt5iL85BhDT2Qg5CFkGEtJVZbYEBRgJEDkKFQUFZbYANgIJCBUmAAkoNSYECAhCCQkVKQglKQIFSBVltgBGAgkIFSYACSg1JgQICEIJCRUpCCUpAgVGABYAFg4BsDgRaQYAFg4BuQBGP/////FoJWW2AAVGABYAFgoBsDFjMUYQ3FV2BAUWJGG81g5RuBUmAEAWEFgJBhLB5WW2AAYAmDYP8WgVSBEGEN11f+W2AAkYJSYCCQkSABVGAJgFRgAWABYKAbA5CSFpJQg5Fg/4YWkIEQYQ4DV/5bkGAAUmAgYAAgAWAAYQEACoFUgWABYAFgoBsDAhkWkINgAWABYKAbAxYCF5BVUH+yLzp1X8gF8lAsgRG3tvNF896hdqTvgYKaa8KLFy6fp4OChGBAUWEOZJOSkZBhLWhWW2BAUYCRA5ChUFBQVltgAFRgAWABYKAbAxaBVltgAIBUYAFgAWCgGwMWMxSAYQ6kV1BgAVRgAWABYKAbAxYzFFuQUJBWW2D/hBZgAJCBUmACYCCQgVJgQICDIGABYAFgoBsDhxaEUpCRUpAgVIAVYQ7lV2EO4IWFYRViVlthELxWW4IVYRC8V2ABVGBAUWM9mKHlYOAbgVJgAWABYKAbA5CRFpBjPZih5ZBhDxuQh5BgBAFhK8hWW2AgYEBRgIMDgYaAOxWAFWEPM1dgAID9W1Ba+hWAFWEPR1c9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlBhD2uRkIEBkGElllZbYQ+HV2BAUWJGG81g5RuBUmAEAWEFgJBhLD5WW2D/hRZgAJCBUmAEYCCQgVJgQICDIGABYAFgoBsDiBaEUpCRUpAgVGABYAFg4BsDFhWAFWEP9VdQYP+FFmAAkIFSYARgIJCBUmBAgIMgYAFgAWCgGwOIFoRSkJFSkCBUYAFg4BuQBGP/////FhVbFWEQvFdgQFGAYEABYEBSgGoMCXznvJBxWzS58WAkG2ABYAFg4BsDFoFSYCABYRBWYRAtYQfxVltgQFGAYEABYEBSgGAfgVJgIAFgAIBRYCBhLtCDOYFRkVKBUlBhH7VWW2P/////kIEWkJFSYP+HFmAAkIFSYARgIJCBUmBAgIMgYAFgAWCgGwOKFoRSglKQkSCDUYFUlJCSAVGQkhZgAWDgGwJgAWABYOAbA5GCFmABYAFg4BsDGZCUFpOQkxcWkZCRF5BVW4KBFGERKFdg/4UWYACQgVJgAmAgkIFSYECAgyBgAWABYKAbA4gWgIVSklKRgpAghZBVkFF/cZdRF9DDU+ExsDD5z2nuz97Xd/W6KgNrBmuQ2kyJq0KQYREfkIiQh5BhLZBWW2BAUYCRA5CiW2D/hRZgAJCBUmADYCCQgVJgQICDIGABYAFgoBsDiBaEUpCRUpAgVIAVYRHuV2ERXWEin1ZbYEBRgGAgAWBAUoCHYAFgAWCgGwMWY6pa8P1gQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGgDsVgBVhEaFXYACA/VtQWvoVgBVhEbVXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQYRHZkZCBAZBhJfBWW5BSkFBhEeiHh4NhGmxWW1BhE5xWW4IVYROcV2ABVGBAUWM9mKHlYOAbgVJgAWABYKAbA5CRFpBjPZih5ZBhEiSQiJBgBAFhK8hWW2AgYEBRgIMDgYaAOxWAFWESPFdgAID9W1Ba+hWAFWESUFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlBhEnSRkIEBkGElllZbYRKQV2BAUWJGG81g5RuBUmAEAWEFgJBhLD5WW2D/hhZgAJCBUmAFYCCQgVJgQICDIGABYAFgoBsDiRaEUpCRUpAgVGABYAFg4BsDFhWAFWES/ldQYP+GFmAAkIFSYAVgIJCBUmBAgIMgYAFgAWCgGwOJFoRSkJFSkCBUYAFg4BuQBGP/////FhVbFWETnFdgQFGAYEABYEBSgGoMCXznvJBxWzS58WAkG2ABYAFg4BsDFoFSYCABYRM2YRAtYQfxVltj/////5CBFpCRUmD/iBZgAJCBUmAFYCCQgVJgQICDIGABYAFgoBsDixaEUoJSkJEgg1GBVJSQkgFRkJIWYAFg4BsCYAFgAWDgGwORghZgAWABYOAbAxmQlBaTkJMXFpGQkReQVVuCgRRhC39XYP+GFmAAkIFSYANgIJCBUmBAgIMgYAFgAWCgGwOJFoCFUpJSkYKQIIWQVZBRf/xPk93UoGypnUzVjo8qPq7I8vN5XxJ9g+DCA+CPiZfhkGET/5CJkIeQYS2QVltgQFGAkQOQolBQUFBQUFZbYACAYAmFYP8WgVSBEGEUIlf+W2AAkYJSYCCCIAFUYEBRY3CggjFg4BuBUmABYAFgoBsDkJEWklCCkZCCkGNwoIIxkGEUYJAwkGAEAWEr1lZbYCBgQFGAgwOBhoA7FYAVYRR4V2AAgP1bUFr6FYAVYRSMVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUGEUsJGQgQGQYSXwVluQUGAAhRGAFWEUwldQgIURFVsVYRVUV2BAUWOpBZy7YOAbgVJgAWABYKAbA4MWkGOpBZy7kGEU9ZCJkImQYAQBYSvkVltgIGBAUYCDA4FgAIeAOxWAFWEVD1dgAID9W1Ba8RWAFWEVI1c9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlBhFUeRkIEBkGElllZbUGAAk1BQUFBhFVtWW4STUFBQUFuTklBQUFZbYAlUYP+DFhBhFYZXYEBRYkYbzWDlG4FSYAQBYQWAkGEsflZbYP+CFmAAgYFSYARgIJCBUmBAgIMgYAFgAWCgGwOGFoCFUpCDUoGEIJSEUmACg1KBhCCQhFKQkVKBIFSQYRXKYQfxVluDVJCRUGAAkGEV6pCDkGABYOAbkARj/////xZhH+hWW5BQYACBEYAVYRX8V1BgAIMRWxVhF9lXYACFYAFgAWCgGwMWYxgWDd1gQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGgDsVgBVhFjxXYACA/VtQWvoVgBVhFlBXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQYRZ0kZCBAZBhJfBWW5BQYABhFoKDhmEgIlZbkFBhFoxhIp9WW2AAgxFhFqlXYEBRgGAgAWBAUoBgAIFSUGEWs1ZbYRazgoRhIGRWW5BQYRa9YSKfVltgQIBRYCCBAZCRUohUYAFgAWDgGwMWgVJhFt+Qg2EgoVZbkFBgQFGAYEABYEBSgGEXL4NgAAFRYEBRgGBAAWBAUoBgGoFSYCABf25ldyBpbmRleCBleGNlZWRzIDIyNCBiaXRzAAAAAAAAgVJQYSDGVltgAWABYOAbAxaBUmAgAWEXaohgQFGAYEABYEBSgGAfgVJgIAFgAIBRYCBhLtCDOYFRkVKBUlBhH7VWW2P/////kIEWkJFSYP+MFmAAkIFSYARgIJCBUmBAgIMgYAFgAWCgGwOPFoRSglKQkSCDUYFUlJCSAVGQkhZgAWDgGwJgAWABYOAbA5GCFmABYAFg4BsDGZCUFpOQkxcWkZCRF5BVUGELf5JQUFBWW4AVYQt/V2EYDIJgQFGAYEABYEBSgGAfgVJgIAFgAIBRYCBhLtCDOYFRkVKBUlBhH7VWW4RUY/////+RkJEWYAFg4BsCYAFgAWDgGwOQkRYXhFVQUFBQUFBWW2AJVGD/hBYQYRhXV2BAUWJGG81g5RuBUmAEAWEFgJBhLH5WW2D/gxZgAJCBUmAEYCCQgVJgQICDIGABYAFgoBsDhhaEUpCRUpAgYRiFYSKfVltQYECAUWAggQGQkVKBVGABYAFg4BsDFoFSYRimYSKfVltQYECAUWAggIIBg1Jg/4gWYACQgVJgBoJSg4EgYAFgAWCgGwOAihaDUpCDUoSCIJCIFoCDUoGEUpSCIIBUhVKGUZWQklKQkVKRkJFVgFEVgBVhGQFXUIFRFRVbFWEZGFdqDAl857yQcVs0ufFgJBuBUlthGSBhIp9WW2EZKoODYSDtVluQUGAAhmABYAFgoBsDFmNwoIIxh2BAUYJj/////xZg4BuBUmAEAWEZWpGQYSvIVltgIGBAUYCDA4GGgDsVgBVhGXJXYACA/VtQWvoVgBVhGYZXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQYRmqkZCBAZBhJfBWW5BQYABhGbiChGEhElZbYP+KFmAAkIFSYAhgIJCBUmBAgIMgYAFgAWCgGwOMFoRSkJFSgSBUkZJQkGEZ7ZCDYSFAVltg/4sWYACQgVJgCGAgkIFSYECAgyBgAWABYKAbA4COFoCGUpGQk1KSgZAghJBViVGQUZOUUJGSkIwWkX+szQNdAsRWvjUwauzVpf5iMgcT3eCczWiwpejtkwOZmZFhGliRj5GIkZBhLZ5WW2BAUYCRA5CjUFBQUFBQUFBQUFZbYAlUYP+EFhBhGpBXYEBRYkYbzWDlG4FSYAQBYQWAkGEsflZbYP+DFmAAgYFSYAVgIJCBUmBAgIMgYAFgAWCgGwOHFoCFUpCDUoGEIJSEUmADg1KBhCCQhFKQkVKBIFSQYRrUYQfxVluDVJCRUGAAkGEa9JCDkGABYOAbkARj/////xZhH+hWW5BQYACBEYAVYRsGV1BgAIMRWxVhHSJXYABhG4eHYAFgAWCgGwMWY0e9NxhgQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGgDsVgBVhG0lXYACA/VtQWvoVgBVhG11XPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQYRuBkZCBAZBhJfBWW4dhIXZWW5BQYABhG5WDhmEgIlZbkFBhG59hIp9WW2AAgxFhG7xXYEBRgGAgAWBAUoBgAIFSUGEbxlZbYRvGgoRhIGRWW5BQYRvQYSKfVltgQIBRYCCBAZCRUohUYAFgAWDgGwMWgVJhG/KQg2EgoVZbkFBgQFGAYEABYEBSgGEcQoNgAAFRYEBRgGBAAWBAUoBgGoFSYCABf25ldyBpbmRleCBleGNlZWRzIDIyNCBiaXRzAAAAAAAAgVJQYSDGVltgAWABYOAbAxaBUmAgAWEcfYhgQFGAYEABYEBSgGAfgVJgIAFgAIBRYCBhLtCDOYFRkVKBUlBhH7VWW2P/////FoFSUGAFYACNYP8WYP8WgVJgIAGQgVJgIAFgACBgAIxgAWABYKAbAxZgAWABYKAbAxaBUmAgAZCBUmAgAWAAIGAAggFRgWAAAWAAYQEACoFUgWABYAFg4BsDAhkWkINgAWABYOAbAxYCF5BVUGAgggFRgWAAAWAcYQEACoFUgWP/////AhkWkINj/////xYCF5BVUJBQUFBQUFBhHXVWW4AVYR11V2EdVYJgQFGAYEABYEBSgGAfgVJgIAFgAIBRYCBhLtCDOYFRkVKBUlBhH7VWW4RUY/////+RkJEWYAFg4BsCYAFgAWDgGwOQkRYXhFVbUFBQUFBQUFZbYAlUYP+FFhBhHaJXYEBRYkYbzWDlG4FSYAQBYQWAkGEsflZbYP+EFmAAkIFSYAVgIJCBUmBAgIMgYAFgAWCgGwOHFoRSkJFSkCBhHdBhIp9WW1BgQIBRYCCBAZCRUoFUYAFgAWDgGwMWgVJhHfFhIp9WW1BgQIBRYCCAggGDUmD/iRZgAJCBUmAHglKDgSBgAWABYKAbA4CLFoNSkINShIIgkIkWgINSgYRSlIIggFSFUoZRlZCSUpCRUpGQkVWAURWAFWEeW1dQgVFqDAl857yQcVs0ufFgJBsRFVsVYR5yV2oMCXznvJBxWzS58WAkG4FSW2EeemEin1ZbYR6Eg4NhIO1WW5BQYABhHs+IYAFgAWCgGwMWY5XdkZOJYEBRgmP/////FmDgG4FSYAQBYR63kZBhK8hWW2AgYEBRgIMDgYaAOxWAFWEbSVdgAID9W5BQYABhHt2ChGEhElZbYP+LFmAAkIFSYAhgIJCBUmBAgIMgYAFgAWCgGwONFoRSkJFSgSBUkZJQkGEfEpCDYSFAVluQUIBgCGAAjWD/FmD/FoFSYCABkIFSYCABYAAgYACLYAFgAWCgGwMWYAFgAWCgGwMWgVJgIAGQgVJgIAFgACCBkFVQiGABYAFgoBsDFopgAWABYKAbAxZ/obagRmZKDs8GgFnybeVoePjQ55mQfKLkLZFIzL3HF6eNhYpgAAFRYEBRYR+gk5KRkGEtnlZbYEBRgJEDkKNQUFBQUFBQUFBQUFZbYACBZAEAAAAAhBBhH91XYEBRYkYbzWDlG4FSYAQBYQWAkZBhLA1WW1CCkFBbkpFQUFZbYABhFVuDg2BAUYBgQAFgQFKAYBWBUmAgAXRzdWJ0cmFjdGlvbiB1bmRlcmZsb3dgWBuBUlBhIZRWW2AAYRVbg4NgQFGAYEABYEBSgGAXgVJgIAF/bXVsdGlwbGljYXRpb24gb3ZlcmZsb3cAAAAAAAAAAACBUlBhIcBWW2EgbGEin1ZbYEBRgGAgAWBAUoBhIJhhIJKGagwJfOe8kHFbNLnxYCQbYSAiVluFYSIRVluQUpOSUFBQVlthIKlhIp9WW2BAUYBgIAFgQFKAYSCYhWAAAVGFYAABUWEhQFZbYACBYAFg4BuEEGEf3VdgQFFiRhvNYOUbgVJgBAFhBYCRkGEsDVZbYSD1YSKfVltgQFGAYCABYEBSgGEgmIVgAAFRhWAAAVFhH+hWW2AAagwJfOe8kHFbNLnxYCQbYSExhIRgAAFRYSAiVluBYSE4V/5bBJOSUFBQVltgAGEVW4ODYEBRgGBAAWBAUoBgEYFSYCABcGFkZGl0aW9uIG92ZXJmbG93YHgbgVJQYSJEVltgAGEVW2EhjYRnDeC2s6dkAABhICJWW4NRYSIRVltgAIGEhBEVYSG4V2BAUWJGG81g5RuBUmAEAWEFgJGQYSwNVltQUFCQA5BWW2AAgxWAYSHNV1CCFVsVYSHaV1BgAGEVW1Zbg4MCg4WCgWEh51f+WwQUg5BhIghXYEBRYkYbzWDlG4FSYAQBYQWAkZBhLA1WW1CUk1BQUFBWW2AAYRVbg4NgQFGAYEABYEBSgGAOgVJgIAFtZGl2aWRlIGJ5IHplcm9gkBuBUlBhImtWW2AAg4MBgoWCEBVhIghXYEBRYkYbzWDlG4FSYAQBYQWAkZBhLA1WW2AAgYNhIoxXYEBRYkYbzWDlG4FSYAQBYQWAkZBhLA1WW1CChIFhIpZX/lsElJNQUFBQVltgQFGAYCABYEBSgGAAgVJQkFZbgDVhH+KBYS6UVltgAIJgH4MBEmEizldgAID9W4E1YSLhYSLcgmEt4FZbYS25VluRUIGBg1JgIIQBk1BgIIEBkFCDhWAghAKCAREVYSMGV2AAgP1bYABbg4EQFWEjMleBYSMciIJhIrJWW4RSUGAgkoMBkpGQkQGQYAEBYSMJVltQUFBQkpFQUFZbYACCYB+DARJhI01XYACA/VuBNWEjW2Ei3IJhLeBWW5FQgYGDUmAghAGTUGAggQGQUIOFYCCEAoIBERVhI4BXYACA/VtgAFuDgRAVYSMyV4FhI5aIgmEkMlZbhFJQYCCSgwGSkZCRAZBgAQFhI4NWW2AAgmAfgwESYSO9V2AAgP1bgVFhI8thItyCYS3gVluRUIGBg1JgIIQBk1BgIIEBkFCDhWAghAKCAREVYSPwV2AAgP1bYABbg4EQFWEjMleBYSQGiIJhJD1WW4RSUGAgkoMBkpGQkQGQYAEBYSPzVluANWEf4oFhLqtWW4BRYR/igWEuq1ZbgDVhH+KBYS60VluAUWEf4oFhLrRWW2AAYCCChAMSFWEkWldgAID9W1CRkFBWW2AAYCCChAMSFWEkcldgAID9W2EkfGAgYS25VluQUGAAYSSKhIRhJJNWW4JSUJKRUFBWW4A1YR/igWEuvVZbgFFhH+KBYS69VluANWEf4oFhLsZWW2AAYCCChAMSFWEkxldgAID9W2AAYSTShIRhIrJWW5STUFBQUFZbYACAYECDhQMSFWEk7VdgAID9W2AAYST5hYVhIrJWW5JQUGAgYSUKhYKGAWEislZbkVBQklCSkFBWW2AAgGAAYGCEhgMSFWElKVdgAID9W2AAYSU1hoZhIrJWW5NQUGAgYSVGhoKHAWEislZbklBQYEBhJVeGgocBYSRIVluRUFCSUJJQklZbYABgIIKEAxIVYSVzV2AAgP1bgVFn//////////+BERVhJYpXYACA/VthJNKEgoUBYSOsVltgAGAggoQDEhVhJahXYACA/VtgAGEk0oSEYSQnVltgAGAggoQDEhVhJcZXYACA/VtgAGEk0oSEYSRgVltgAGAggoQDEhVhJeRXYACA/VtgAGEk0oSEYSSTVltgAGAggoQDEhVhJgJXYACA/VtgAGEk0oSEYSSeVltgAIBgQIOFAxIVYSYhV2AAgP1bYABhJPmFhWEkqVZbYACAYABgYISGAxIVYSZCV2AAgP1bYABhJk6GhmEkqVZbk1BQYCBhJl+GgocBYSKyVluSUFBgQIQBNWf//////////4ERFWEmfFdgAID9W2ElV4aChwFhIzxWW2AAgGAAYGCEhgMSFWEmnVdgAID9W2AAYSaphoZhJKlWW5NQUGAgYSa6hoKHAWEislZbklBQYEBhJVeGgocBYSSTVltgAIBgAGBghIYDEhVhJuBXYACA/VtgAGEm7IaGYSSpVluTUFBgIGEm/YaChwFhIrJWW5JQUGBAYSVXhoKHAWEislZbYACAYACAYABgoIaIAxIVYScmV2AAgP1bYABhJzKIiGEkqVZblVBQYCCGATVn//////////+BERVhJ09XYACA/VthJ1uIgokBYSK9VluUUFBgQIYBNWf//////////4ERFWEneFdgAID9W2EnhIiCiQFhIzxWW5NQUGBgYSeViIKJAWEkHFZbklBQYIBhJ6aIgokBYSQcVluRUFCSlVCSlZCTUFZbYACAYACAYICFhwMSFWEnyVdgAID9W2AAYSfVh4dhJKlWW5RQUGAgYSfmh4KIAWEkMlZbk1BQYEBhJ/eHgogBYSSTVluSUFBgYGEoCIeCiAFhJJNWW5FQUJKVkZRQklBWW2EoHYFhLlNWW4JSUFBWW2EoHYFhLg5WW2EoHYFhLh5WW2AAYShAgmEuAVZbYShKgYVhLgVWW5NQYShagYVgIIYBYS5eVlthKGOBYS6KVluQkwGTklBQUFZbYABhKHpgIYNhLgVWW39vbmx5IGFkbWluIGNhbiBzZXQgcmV3YXJkIGFkZHJlc4FSYHNg+BtgIIIBUmBAAZKRUFBWW2AAYSi9YDWDYS4FVlt/b25seSBhZG1pbiBjYW4gdXBkYXRlIGFuZCBkaXN0cmmBUnRidXRlIGJvcnJvd2VyIHJld2FyZHNgWBtgIIIBUmBAAZKRUFBWW2AAYSkUYBuDYS4FVlt/cmV3YXJkIG1hcmtldCBpcyBub3QgbGlzdGVkAAAAAACBUmAgAZKRUFBWW2AAYSlNYBWDYS4FVlt0G1hcmtldCBtdXN0IGJlIGxpc3RlZYFobgVJgIAGSkVBQVltgAGEpfmAbg2EuBVZbf29ubHkgYWRtaW4gY2FuIGdyYW50IHJld2FyZAAAAAAAgVJgIAGSkVBQVltgAGEpt2A1g2EuBVZbf29ubHkgYWRtaW4gY2FuIHVwZGF0ZSBhbmQgZGlzdHJpgVJ0YnV0ZSBzdXBwbGllciByZXdhcmRzYFgbYCCCAVJgQAGSkVBQVltgAGEqDmAVg2EuBVZbdByZXdhcmRUeXBlIGlzIGludmFsaWWBaG4FSYCABkpFQUFZbYABhKj9gHYNhLgVWW39pbnN1ZmZpY2llbnQgcmV3YXJkIGZvciBncmFudAAAAIFSYCABkpFQUFZbYABhKnhgHoNhLgVWW39vbmx5IGFkbWluIGNhbiBzZXQgQ29tcHRyb2xsZXIAAIFSYCABkpFQUFZbYABhKrFgJYNhLgVWW39SZXdhcmREaXN0cmlidXRvciBhbHJlYWR5IGluaXRpYYFSZBsaXplZYNobYCCCAVJgQAGSkVBQVltgAGEq+GAYg2EuBVZbf29ubHkgYWRtaW4gY2FuIHNldCBhZG1pbgAAAAAAAAAAgVJgIAGSkVBQVltgAGErMWAfg2EuBVZbf29ubHkgYWRtaW4gY2FuIHNldCByZXdhcmQgc3BlZWQAgVJgIAGSkVBQVltgAGEramAlg2EuBVZbf29ubHkgYWRtaW4gY2FuIGFkZCBuZXcgcmV3YXJkIGFkgVJkZHJlc3Ng2BtgIIIBUmBAAZKRUFBWW2EoHYFhLjVWW2EoHYFhLkFWW2EoHYFhLkRWW2EoHYFhLk1WW2AggQFhH+KChGEoI1ZbYCCBAWEf4oKEYSgUVltgQIEBYSvygoVhKBRWW2EVW2AggwGEYSutVltgIIEBYR/igoRhKCxWW2AggIJSgQFhFVuBhGEoNVZbYCCAglKBAWEf4oFhKG1WW2AggIJSgQFhH+KBYSiwVltgIICCUoEBYR/igWEpB1ZbYCCAglKBAWEf4oFhKUBWW2AggIJSgQFhH+KBYSlxVltgIICCUoEBYR/igWEpqlZbYCCAglKBAWEf4oFhKgFWW2AggIJSgQFhH+KBYSoyVltgIICCUoEBYR/igWEqa1ZbYCCAglKBAWEf4oFhKqRWW2AggIJSgQFhH+KBYSrrVltgIICCUoEBYR/igWErJFZbYCCAglKBAWEf4oFhK11WW2AggQFhH+KChGErpFZbYECBAWEtCoKFYSukVlthFVtgIIMBhGErtlZbYCCBAWEf4oKEYSutVltgQIEBYS0zgoVhK79WW2EVW2AggwGEYSgjVltgYIEBYS1OgoZhK79WW2EtW2AggwGFYSgUVlthJNJgQIMBhGErrVZbYGCBAWEtdoKGYSu/VlthLYNgIIMBhWEoI1ZbYSTSYECDAYRhKCNWW2BAgQFhK/KChWErv1ZbYGCBAWEtrIKGYSu/VlthLVtgIIMBhWErrVZbYEBRgYEBZ///////////gRGCghAXFWEt2FdgAID9W2BAUpGQUFZbYABn//////////+CERVhLfdXYACA/VtQYCCQgQIBkFZbUZBWW5CBUmAgAZBWW2AAYR/igmEuKVZbFRWQVltgAGEf4oJhLg5WW2ABYAFgoBsDFpBWW2ABYAFg4BsDFpBWW5BWW2P/////FpBWW2D/FpBWW2AAYR/igmEuHlZbYABbg4EQFWEueVeBgQFRg4IBUmAgAWEuYVZbg4ERFWEFuVdQUGAAkQFSVltgHwFgHxkWkFZbYS6dgWEuDlZbgRRhLqhXYACA/VtQVlthLp2BYS4ZVlthLp2BYS4eVlthLp2BYS5BVlthLp2BYS5NVv5ibG9jayB0aW1lc3RhbXAgZXhjZWVkcyAzMiBiaXRzAKNlYnp6cjFYIFhhQsCtVyzZ89nhAaorwB4rzjr6VIAOI/y9u0y/uEjibGV4cGVyaW1lbnRhbPVkc29sY0MABRAAQA=="
            },
            {
                "key": "BwOevDGAo0Azymmhy6T0a9/JA0xgfA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOfH5M8ZgodyFbw4P4FhDWHnFzO8A==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOh/JZ/2hQNqO4kHMpRkcdG2Bj3XA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwO789QoHxDlN9WxPKgL4iNiMQsr+Q==",
                "proof": [],
                "value": "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FpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACAYAVgAJBUkGEBAAqQBGABYAFgoBsDFmABYAFgoBsDFmMBfn5YYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYSAkV2AAgP1bUFr6FYAVYSA4Vz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYSBOV2AAgP1bUFFgC1RgAWABYKAbA4IWFYAVlFCRklCQYSD/V4AVYSD6V2AAYSCLYRBZYAFgAWBwGwOIgRaQiBZhHChWW5BQYABhIJiDYSETVluQUICCERVhIPdXYABhILphILGEhGEclFZbYABUkGEcKFZbkFBgAGEg04NhIM2GYAVhHChWW5BhItBWW5BQYACBg4FhIOBX/lsEkFCAFWEg81dhIPOHgmEhZVZbUFBQW1BQW2EhC1ZbgBVhIQtXYABgC1VbUFCSkVBQVltgAGADghEVYSFWV1CAYAFgAoIEAVuBgRAVYSFQV4CRUGACgYKFgWEhP1f+WwQBgWEhSFf+WwSQUGEhKFZbUGEhYFZbgRVhIWBXUGABW5GQUFZbYABUYSFykIJhItBWW2AAkIFVYAFgAWCgGwODFoFSYAFgIFJgQJAgVGEhl5CCYSLQVltgAWABYKAbA4MWYACBgVJgAWAgkIFSYECAgyCUkJRVg1GFgVKTUZKTkZJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SgZADkJEBkKNQUFZbYACBgxBhIf5XgWEiAFZbgluTklBQUFZbYAFgAWCgGwOCFmAAkIFSYAFgIFJgQJAgVGEiKpCCYRyUVltgAWABYKAbA4MWYACQgVJgAWAgUmBAgSCRkJFVVGEiUZCCYRyUVltgAJCBVWBAgFGDgVKQUWABYAFgoBsDhRaRf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkZCBkANgIAGQo1BQVltgAWABYHAbAxZgAWBwGwKQVltgAGABYAFgcBsDghZgAWABYOAbA4QWgWEiyFf+WwSTklBQUFZbgIIBgoEQFWELaFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1hZGQtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9/lVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX09VVFBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlfQlVSTkVEVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZX01JTlRFRKFkc29sY0MABgwACg=="
            },
            {
                "key": "BwO8iiROj7aD7B/W+I88xuVlCCF06w==",
                "proof": [],
                "value": "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FpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACAYAVgAJBUkGEBAAqQBGABYAFgoBsDFmABYAFgoBsDFmMBfn5YYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYSAkV2AAgP1bUFr6FYAVYSA4Vz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYSBOV2AAgP1bUFFgC1RgAWABYKAbA4IWFYAVlFCRklCQYSD/V4AVYSD6V2AAYSCLYRBZYAFgAWBwGwOIgRaQiBZhHChWW5BQYABhIJiDYSETVluQUICCERVhIPdXYABhILphILGEhGEclFZbYABUkGEcKFZbkFBgAGEg04NhIM2GYAVhHChWW5BhItBWW5BQYACBg4FhIOBX/lsEkFCAFWEg81dhIPOHgmEhZVZbUFBQW1BQW2EhC1ZbgBVhIQtXYABgC1VbUFCSkVBQVltgAGADghEVYSFWV1CAYAFgAoIEAVuBgRAVYSFQV4CRUGACgYKFgWEhP1f+WwQBgWEhSFf+WwSQUGEhKFZbUGEhYFZbgRVhIWBXUGABW5GQUFZbYABUYSFykIJhItBWW2AAkIFVYAFgAWCgGwODFoFSYAFgIFJgQJAgVGEhl5CCYSLQVltgAWABYKAbA4MWYACBgVJgAWAgkIFSYECAgyCUkJRVg1GFgVKTUZKTkZJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SgZADkJEBkKNQUFZbYACBgxBhIf5XgWEiAFZbgluTklBQUFZbYAFgAWCgGwOCFmAAkIFSYAFgIFJgQJAgVGEiKpCCYRyUVltgAWABYKAbA4MWYACQgVJgAWAgUmBAgSCRkJFVVGEiUZCCYRyUVltgAJCBVWBAgFGDgVKQUWABYAFgoBsDhRaRf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkZCBkANgIAGQo1BQVltgAWABYHAbAxZgAWBwGwKQVltgAGABYAFgcBsDghZgAWABYOAbA4QWgWEiyFf+WwSTklBQUFZbgIIBgoEQFWELaFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1hZGQtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9/lVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX09VVFBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlfQlVSTkVEVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZX01JTlRFRKFkc29sY0MABgwACg=="
            },
            {
                "key": "BwO+RuQw0zb8gn0JbbBEy67s5y4XvA==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEBgldgADVg4ByAY4IFv2oRYQDYV4BjtatY3BFhAIxXgGPVR3QfEWEAZleAY9VHdB8UYQP9V4Bj5f5FdxRhBBBXgGP+r5aMFGEEO1dgAID9W4BjtatY3BRhA7BXgGO2M2IMFGEDw1eAY8Sbrr4UYQPWV2AAgP1bgGOR0UhUEWEAvVeAY5HRSFQUYQMnV4Bjmm/I9RRhA15XgGOiF/3fFGEDqFdgAID9W4BjggW/ahRhAuZXgGOCuOvHFGEDFFdgAID9W4BjNlaKvhFhATpXgGNe1jtAEWEBFFeAY17WO0AUYQKrV4BjZooPAhRhAtBXgGNyhOQWFGEC3ldgAID9W4BjNlaKvhRhAnBXgGNQ0lvNFGECg1eAY1T9TVAUYQKjV2AAgP1bgGMkipyjEWEBa1eAYySKnKMUYQHxV4BjLy/xXRRhAiJXgGMxPOVnFGECN1dgAID9W4BjAf/JpxRhAYdXgGMYH1p3FGEBr1dbYACA/VthAZphAZU2YARhDJhWW2EEi1ZbYEBRkBUVgVJgIAFbYEBRgJEDkPNbYECAUYCCAZCRUmATgVJ/Rmx1eFByaWNlRmVlZCAxLjAuMAAAAAAAAAAAAAAAAABgIIIBUltgQFFhAaaRkGEM8lZbYQIUYQH/NmAEYQ0lVltgAJCBUmAggZBSYECQIGABAVSQVltgQFGQgVJgIAFhAaZWW2ECNWECMDZgBGENPlZbYQTCVlsAW2ECXn8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACIFWW2BAUWD/kJEWgVJgIAFhAaZWW2ECNWECfjZgBGENPlZbYQTtVltgAVRj/////xZgAJCBUmACYCBSYECQIFRgFwthAhRWW2ECFGABgVZbYAFUYQK7kGP/////FoFWW2BAUWP/////kJEWgVJgIAFhAaZWW2ABVGP/////FmECFFZbYQHkYQV+VltgAVRj/////xZgAJCBUmACYCBSYECQIFRgAWDAG5AEZ///////////FmECFFZbYQI1YQMiNmAEYQ16VlthBhBWW2EBmmEDNTZgBGENPlZbYACRglJgIIKBUmBAgIQgYAFgAWCgGwOTkJMWhFKRkFKQIFRg/xaQVlthA3FhA2w2YARhDZ1WW2EHa1ZbYECAUWn/////////////locWgVJgIIEBlZCVUoQBkpCSUmBggwFSkJEWYICCAVJgoAFhAaZWW2ECFGAAgVZbYQIUYQO+NmAEYQ0lVlthCC5WW2ECFGED0TZgBGENJVZbYQhgVlthAhR/IXAsivRhJ8f6IH+J0LCoRBuzKVmgrH33kOmrGiXJiSaBVlthAjVhBAs2YARhDT5WW2EIoFZbYQQYYQjGVltgQIBRYBeTkJMLg1Jn//////////+QkRZgIIMBUgFhAaZWW2EDcWABVGP/////FmAAgYFSYAJgIJCBUmBAkYKQIIJRgIQBkJNSVGAXgZALgIRSYAFgwBuQkQRn//////////8WkpCRAYKQUpGSgZCEkFZbYABgAWABYOAbAxmCFmN5ZdsLYOAbFIBhBLxXUGMB/8mnYOAbYAFgAWDgGwMZgxYUW5KRUFBWW2AAgoFSYCCBkFJgQJAgYAEBVGEE3oEzYQlNVlthBOiDg2EJy1ZbUFBQVltgAWABYKAbA4EWMxRhBXBXYEBRYkYbzWDlG4FSYCBgBIIBUmAvYCSCAVJ/QWNjZXNzQ29udHJvbDogY2FuIG9ubHkgcmVub3VuY2VgRIIBUn8gcm9sZXMgZm9yIHNlbGYAAAAAAAAAAAAAAAAAAAAAAGBkggFSYIQBW2BAUYCRA5D9W2EFeoKCYQppVltQUFZbYGBgA4BUYQWNkGENyVZbgGAfAWAggJEEAmAgAWBAUZCBAWBAUoCSkZCBgVJgIAGCgFRhBbmQYQ3JVluAFWEGBleAYB8QYQXbV2EBAICDVAQCg1KRYCABkWEGBlZbggGRkGAAUmAgYAAgkFuBVIFSkGABAZBgIAGAgxFhBelXgpADYB8WggGRW1BQUFBQkFCQVlszYACQgVJ/URGurkqnmImSjnL4i1hyEJdU3p1Bnqmk499fuiHU1G9gIFJgQJAgVGD/FmEGjldgQFFiRhvNYOUbgVJgIGAEggFSYBlgJIIBUn9DYWxsZXIgaXMgbm90IGEgdmFsaWRhdG9yAAAAAAAAAGBEggFSYGQBYQVnVltgAYBUY/////8WkGAAYQakg2EOGlZbglRj/////5GCFmEBAJOQkwqSgwKSggIZFpGQkReQkVVgQIBRgIIBglJgF4WQC4CCUmf//////////0KBFmAggIUBkYJSYAGAVIgWYACQgVJgAoNSh5AglVGSUZCTFmABYMAbAnf///////////////////////////////+QkhaRkJEXkJNVVINRkYJSM5KCAZKQklKSFpJQfxfqvQpm+mMfdTfO/dXfaqJdWskEz3WW6VjUOnWgDQ1okQFgQFGAkQOQolBWW2AAgGAAgGAAY/////+Gaf////////////8WERVgQFGAYEABYEBSgGAPgVJgIAF/Tm8gZGF0YSBwcmVzZW50AAAAAAAAAAAAAAAAAAAAAACBUlCQYQfbV2BAUWJGG81g5RuBUmAEAWEFZ5GQYQzyVltQUFBQY/////+DFmAAkIFSYAJgIJCBUmBAkYKQIIJRgIQBkJNSVGAXgZALgIRSYAFgwBuQkQRn//////////8WkpCRAYKQUpOUkJJQgpFQhJBWW2AAY/////+CERVhCERXUGAAkZBQVltQY/////8WYACQgVJgAmAgUmBAkCBUYBcLkFZbYABj/////4IRFWEIdldQYACRkFBWW1Bj/////xZgAJCBUmACYCBSYECQIFRgAWDAG5AEZ///////////FpBWW2AAgoFSYCCBkFJgQJAgYAEBVGEIvIEzYQlNVlthBOiDg2EKaVZbYACAMzIUYQkYV2BAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSf09ubHkgY2FsbGFibGUgYnkgRU9BAAAAAAAAAAAAAAAAYESCAVJgZAFhBWdWW1BQYAFUY/////8WYACQgVJgAmAgUmBAkCBUYBeBkAuRYAFgwBuQkQRn//////////8WkFZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2EJiYFgAWABYKAbAxZgFGEK6FZbYQmUg2AgYQroVltgQFFgIAFhCaWSkZBhDj5WW2BAgFFgHxmBhAMBgVKQgpBSYkYbzWDlG4JSYQVnkWAEAWEM8lZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaEUpCRUpAggFRg/xkWYAEXkFVhCiUzkFZbYAFgAWCgGwMWgWABYAFgoBsDFoN/L4eIEX5+/x2C6SbseUkB0Xx4AkpQJwlAMEVApzNlbw1gQFFgQFGAkQOQpFBQVltgAIKBUmAggYFSYECAgyBgAWABYKAbA4UWhFKQkVKQIFRg/xYVYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaAhVKSUoCDIIBUYP8ZFpBVUTOShZF/9jkfXDLZxp0qR+pnC0QpdLU5NdHtx/1k6yHgR6g5FxuRkKRQUFZbYGBgAGEK94NgAmEOv1ZbYQsCkGACYQ7eVltn//////////+BERVhCxpXYQsaYQ72VltgQFGQgIJSgGAfAWAfGRZgIAGCAWBAUoAVYQtEV2AgggGBgDaDNwGQUFtQkFBgA2D8G4FgAIFRgRBhC19XYQtfYQ8MVltgIAEBkGABYAFg+BsDGRaQgWAAGpBTUGAPYPsbgWABgVGBEGELjldhC45hDwxWW2AgAQGQYAFgAWD4GwMZFpCBYAAakFNQYABhC7KEYAJhDr9WW2ELvZBgAWEO3lZbkFBbYAGBERVhDEJXfzAxMjM0NTY3ODlhYmNkZWYAAAAAAAAAAAAAAAAAAAAAhWAPFmAQgRBhC/5XYQv+YQ8MVlsaYPgbgoKBUYEQYQwUV2EMFGEPDFZbYCABAZBgAWABYPgbAxkWkIFgABqQU1BgBJSQlByTYQw7gWEPIlZbkFBhC8BWW1CDFWEMkVdgQFFiRhvNYOUbgVJgIGAEggGBkFJgJIIBUn9TdHJpbmdzOiBoZXggbGVuZ3RoIGluc3VmZmljaWVudGBEggFSYGQBYQVnVluTklBQUFZbYABgIIKEAxIVYQyqV2AAgP1bgTVgAWABYOAbAxmBFoEUYQyRV2AAgP1bYABbg4EQFWEM3VeBgQFRg4IBUmAgAWEMxVZbg4ERFWEM7FdgAISEAVJbUFBQUFZbYCCBUmAAglGAYCCEAVJhDRGBYECFAWAghwFhDMJWW2AfAWAfGRaRkJEBYEABkpFQUFZbYABgIIKEAxIVYQ03V2AAgP1bUDWRkFBWW2AAgGBAg4UDEhVhDVFXYACA/VuCNZFQYCCDATVgAWABYKAbA4EWgRRhDW9XYACA/VuAkVBQklCSkFBWW2AAYCCChAMSFWENjFdgAID9W4E1gGAXC4EUYQyRV2AAgP1bYABgIIKEAxIVYQ2vV2AAgP1bgTVp/////////////4EWgRRhDJFXYACA/VtgAYGBHJCCFoBhDd1XYH+CFpFQW2AgghCBFBVhDf5XY05Ie3Fg4BtgAFJgImAEUmAkYAD9W1CRkFBWW2NOSHtxYOAbYABSYBFgBFJgJGAA/VtgAGP/////gIMWgYEUFWEONFdhDjRhDgRWW2ABAZOSUFBQVlt/QWNjZXNzQ29udHJvbDogYWNjb3VudCAAAAAAAAAAAACBUmAAg1FhDnaBYBeFAWAgiAFhDMJWW38gaXMgbWlzc2luZyByb2xlIAAAAAAAAAAAAAAAAAAAAGAXkYQBkYIBUoNRYQ6zgWAohAFgIIgBYQzCVlsBYCgBlJNQUFBQVltgAIFgABkEgxGCFRUWFWEO2VdhDtlhDgRWW1ACkFZbYACCGYIRFWEO8VdhDvFhDgRWW1ABkFZbY05Ie3Fg4BtgAFJgQWAEUmAkYAD9W2NOSHtxYOAbYABSYDJgBFJgJGAA/VtgAIFhDzFXYQ8xYQ4EVltQYAAZAZBW/qFkc29sY0MACAkACg=="
            },
            {
                "key": "BwO/pRgh+LMOODnpqzNMiD5UBbvDjA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPCQgWxL7BWgisrLEK17hgnKgqOdA==",
                "proof": [],
                "value": "YIBgQFI2YQATV2EAEWEAF1ZbAFthABFbYQAnYQAiYQBeVlthAJZWW1ZbYGBhAE6Dg2BAUYBgYAFgQFKAYCeBUmAgAWECTGAnkTlhALpWW5OSUFBQVls7FRWQVluQVltgAGEAkX82CJShO6GjIQZnyChJLbmNyj4gdsw3Nakgo8pQXTgrvFRgAWABYKAbAxaQVluQUJBWWzZgAIA3YACANmAAhFr0PWAAgD6AgBVhALVXPWAA81s9YAD9W2BggzthAR5XYEBRYkYbzWDlG4FSYCBgBIIBUmAmYCSCAVJ/QWRkcmVzczogZGVsZWdhdGUgY2FsbCB0byBub24tY29gRIIBUmUbnRyYWN1g0htgZIIBUmCEAVtgQFGAkQOQ/VtgAICFYAFgAWCgGwMWhWBAUWEBOZGQYQHMVltgAGBAUYCDA4GFWvSRUFA9gGAAgRRhAXRXYEBRkVBgHxlgPz0BFoIBYEBSPYJSPWAAYCCEAT5hAXlWW2BgkVBbUJFQkVBhAYmCgoZhAZNWW5aVUFBQUFBQVltgYIMVYQGiV1CBYQBOVluCURVhAbJXglGAhGAgAf1bgWBAUWJGG81g5RuBUmAEAWEBFZGQYQHoVltgAIJRYQHegYRgIIcBYQIbVluRkJEBkpFQUFZbYABgIIJSglGAYCCEAVJhAgeBYECFAWAghwFhAhtWW2AfAWAfGRaRkJEBYEABkpFQUFZbYABbg4EQFWECNleBgQFRg4IBUmAgAWECHlZbg4ERFWECRVdgAISEAVJbUFBQUFb+QWRkcmVzczogbG93LWxldmVsIGRlbGVnYXRlIGNhbGwgZmFpbGVkomRpcGZzWCISIJuEcPBuijlgyRIQP8K+F37arWlYTuPH0oCe5zfnlAjnZHNvbGNDAAgCADM="
            },
            {
                "key": "BwPCv9jBeAQ1j6nwrWg9ICk0QYDOXw==",
                "proof": [],
                "value": "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T1dXgYEBUYOCAVJgIAFhTz9WW2BAUYBgIAFgQFKAYACBUlCQVluCgFRgAYFgARYVYQEAAgMWYAKQBJBgAFJgIGAAIJBgHwFgIJAEgQGSgmAfEGFRQleAUWD/GRaDgAEXhVVhUW9WW4KAAWABAYVVghVhUW9XkYIBW4KBERVhUW9XglGCVZFgIAGRkGABAZBhUVRWW1BhUXuSkVBhUnlWW1CQVltgQIBRYQEggQGQkVKAYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSUJBWW2BAgFFhAQCBAZCRUoBgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUlCQVltgQIBRYOCBAZCRUoBgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSUJBWW2BAgFFggIEBkJFSgGAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJQkFZbYQ6YkZBbgIIRFWFRe1dgAIFVYAEBYVJ/Vv5vbmx5IGFkbWluIG1heSBpbml0aWFsaXplIHRoZSBtYXJrZXRtYXJrZXQgbWF5IG9ubHkgYmUgaW5pdGlhbGl6ZWQgb25jZUNFcmMyMDo6c3dlZXBUb2tlbjogY2FuIG5vdCBzd2VlcCB1bmRlcmx5aW5nIHRva2VuaW5pdGlhbCBleGNoYW5nZSByYXRlIG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8ub25seSB0aGUgYWRtaW4gbWF5IHNldCB0aGUgY29tcC1saWtlIGRlbGVnYXRlc2V0dGluZyBpbnRlcmVzdCByYXRlIG1vZGVsIGZhaWxlZG9ubHkgdGhlIGFkbWluIG1heSBjYWxsIF9yZXNpZ25JbXBsZW1lbnRhdGlvbk1JTlRfTkVXX0FDQ09VTlRfQkFMQU5DRV9DQUxDVUxBVElPTl9GQUlMRURib3Jyb3dCYWxhbmNlU3RvcmVkOiBib3Jyb3dCYWxhbmNlU3RvcmVkSW50ZXJuYWwgZmFpbGVkUkVQQVlfQk9SUk9XX05FV19BQ0NPVU5UX0JPUlJPV19CQUxBTkNFX0NBTENVTEFUSU9OX0ZBSUxFRN3yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvUkVQQVlfQk9SUk9XX05FV19UT1RBTF9CQUxBTkNFX0NBTENVTEFUSU9OX0ZBSUxFRExJUVVJREFURV9DT01QVFJPTExFUl9DQUxDVUxBVEVfQU1PVU5UX1NFSVpFX0ZBSUxFRGV4Y2hhbmdlUmF0ZVN0b3JlZDogZXhjaGFuZ2VSYXRlU3RvcmVkSW50ZXJuYWwgZmFpbGVkTUlOVF9ORVdfVE9UQUxfU1VQUExZX0NBTENVTEFUSU9OX0ZBSUxFRG9uZSBvZiByZWRlZW1Ub2tlbnNJbiBvciByZWRlZW1BbW91bnRJbiBtdXN0IGJlIHplcm9yZWR1Y2UgcmVzZXJ2ZXMgdW5leHBlY3RlZCB1bmRlcmZsb3dvbmx5IHRoZSBhZG1pbiBtYXkgY2FsbCBfYmVjb21lSW1wbGVtZW50YXRpb26iZWJ6enIxWCD9+ewIgEgGGZanDOp1rSJltIQula434bU6pxKw8zuTq2Rzb2xjQwAFEAAy"
            },
            {
                "key": "BwPELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPa3Zf6+uYT9TzSJb8K2XPe33nEPA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPhzwm9ouCJxjMw8P/j9ta3kINZcw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPimiNtOPYJ+niRhRoIKMi53Rl/bg==",
                "proof": [],
                "value": "YIBgQFI2YQALVwBbYQATYQAVVlsAW2EAJWEAIGEAZVZbYQD+VltWW2BgYQBMg4NgQFGAYGABYEBSgGAngVJgIAFhAuZgJ5E5YQEiVluTklBQUFZbYAFgAWCgGwMWOxUVkFZbkFZbYABhAJh/o/CtdOVCOuv9gNPvQ0ZXgzWppyrq7ln/bLNYKzUTPVBUYAFgAWCgGwMWkFZbYAFgAWCgGwMWY1xg2htgQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGWvoVgBVhANVXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQD5kZBhAj1WW5BQkFZbNmAAgDdgAIA2YACEWvQ9YACAPoCAFWEBHVc9YADzWz1gAP1bYGBgAWABYKAbA4QWO2EBj1dgQFFiRhvNYOUbgVJgIGAEggFSYCZgJIIBUn9BZGRyZXNzOiBkZWxlZ2F0ZSBjYWxsIHRvIG5vbi1jb2BEggFSZRudHJhY3WDSG2BkggFSYIQBW2BAUYCRA5D9W2AAgIVgAWABYKAbAxaFYEBRYQGqkZBhApZWW2AAYEBRgIMDgYVa9JFQUD2AYACBFGEB5VdgQFGRUGAfGWA/PQEWggFgQFI9glI9YABgIIQBPmEB6lZbYGCRUFtQkVCRUGEB+oKChmECBFZblpVQUFBQUFBWW2BggxVhAhNXUIFhAExWW4JRFWECI1eCUYCEYCAB/VuBYEBRYkYbzWDlG4FSYAQBYQGGkZBhArJWW2AAYCCChAMSFWECT1dgAID9W4FRYAFgAWCgGwOBFoEUYQBMV2AAgP1bYABbg4EQFWECgVeBgQFRg4IBUmAgAWECaVZbg4ERFWECkFdgAISEAVJbUFBQUFZbYACCUWECqIGEYCCHAWECZlZbkZCRAZKRUFBWW2AggVJgAIJRgGAghAFSYQLRgWBAhQFgIIcBYQJmVltgHwFgHxkWkZCRAWBAAZKRUFBW/kFkZHJlc3M6IGxvdy1sZXZlbCBkZWxlZ2F0ZSBjYWxsIGZhaWxlZKJkaXBmc1giEiADxaal938VfrdYPm+5tG2nm2ETlLVYTPfE4mq4vz7WhGRzb2xjQwAIDQAz"
            },
            {
                "key": "BwP06yF7okVGE7FdvepuXyInZBDong==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwP6Zw0HclwEWG6R1/lwUSoz0NaT4A==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEAV1dgADVg4ByAYzE85WcUYQBcV4BjTZ+oKhRhAHpXgGNQ0lvNFGEAnleAY8QeCc4UYQC4V4Bj+E/roxRhAMBXW2AAgP1bYQBkYQDIVltgQIBRYP+QkhaCUlGQgZADYCABkPNbYQCCYQDNVltgQIBRYAFgAWCgGwOQkhaCUlGQgZADYCABkPNbYQCmYQDcVltgQIBRkYJSUZCBkANgIAGQ81thAGRhAnNWW2EAgmECg1ZbYBKBVltgAVRgAWABYKAbAxaBVltgAIBUYECAUWNQ0lvNYOAbgVKQUYOSYAFgAWCgGwMWkWNQ0lvNkWAEgIMBkmAgkpGQgpADAYGGgDsVgBVhASFXYACA/VtQWvoVgBVhATVXPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhAUtXYACA/VtQUWABVGBAgFFjUNJbzWDgG4FSkFGSk1BgAJJgAWABYKAbA5CSFpFjUNJbzZFgBICCAZJgIJKQkZCCkAMBgYaAOxWAFWEBmFdgAID9W1Ba+hWAFWEBrFc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEBwldgAID9W1BRYAFUkJFQYBJgAWCgG5CRBGD/FhEVYQIuV2ABVGAAkGEB/pBgAWCgG5AEYP8WYBJj/////2ECkhZWW5BQYQIkYAqCkAphAhiFhWP/////YQLdFlZbkGP/////YQM2FlZbk1BQUFBhAnBWW2ABVGAAkGECSpBgEpBgAWCgG5AEYP8WYQKSVluQUGECJGAKgpAKYQJkhYVj/////2EC3RZWW5Bj/////2EC3RZWW5BWW2ABVGABYKAbkARg/xaBVltgAFRgAWABYKAbAxaBVltgAGEC1IODYEBRgGBAAWBAUoBgH4FSYCABf1NhZmVNYXRoOiBzdWJ0cmFjdGlvbiB1bmRlcmZsb3cAgVJQYQN4VluQUFuSkVBQVltgAIJhAuxXUGAAYQLXVluCggKChIKBYQL5V/5bBBRhAtRXYEBRYkYbzWDlG4FSYAQBgIBgIAGCgQOCUmAhgVJgIAGAYQR1YCGROWBAAZFQUGBAUYCRA5D9W2AAYQLUg4NgQFGAYEABYEBSgGAagVJgIAF/U2FmZU1hdGg6IGRpdmlzaW9uIGJ5IHplcm8AAAAAAACBUlBhBA9WW2AAgYSEERVhBAdXYEBRYkYbzWDlG4FSYAQBgIBgIAGCgQOCUoOBgVGBUmAgAZFQgFGQYCABkICDg2AAW4OBEBVhA8xXgYEBUYOCAVJgIAFhA7RWW1BQUFCQUJCBAZBgHxaAFWED+VeAggOAUWABg2AgA2EBAAoDGRaBUmAgAZFQW1CSUFBQYEBRgJEDkP1bUFBQkAOQVltgAIGDYQReV2BAUWJGG81g5RuBUmAgYASCAYGBUoNRYCSEAVKDUZCSg5JgRJCRAZGQhQGQgIODYACDFWEDzFeBgQFRg4IBUmAgAWEDtFZbUGAAg4WBYQRqV/5bBJWUUFBQUFBW/lNhZmVNYXRoOiBtdWx0aXBsaWNhdGlvbiBvdmVyZmxvd6JlYnp6cjFYILIif2fuOr5F7qKVEGIl5suBhRlhBsBmepLcOWR8ex8NZHNvbGNDAAUQADI="
            },
            {
                "key": "BwP6eGusN12IBhhVVRSSNazbGCwDOw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwQIrBI2rjmC7JRj7+EPDzINn1qaSwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC",
                "proof": [],
                "value": "Y0JTVE4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo="
            },
            {
                "key": "BwQIrBI2rjmC7JRj7+EPDzINn1qaSwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAnx+TPGYKHchW8OD+BYQ1h5xczvA="
            },
            {
                "key": "BwQkD9xeRGbkbkhXe3iG39UcB39z9gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0BTX4="
            },
            {
                "key": "BwQkD9xeRGbkbkhXe3iG39UcB39z9gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACXND38="
            },
            {
                "key": "BwQ16AHGJGSjebCdHu0htRh1InErbQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAnrwxgKNAM8ppocuk9GvfyQNMYHw="
            },
            {
                "key": "BwRPpZyuKx4NO7rbM4W6KbCzWCLorQEAAAAflAeSCYQQNNsImktx9DMGcOuXdS2H46hR60dXEcNxfA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA+mcNB3JcBFhukdf5cFEqM9DWk+A="
            },
            {
                "key": "BwRt5Uck4SgnRSBgbwOFkaAMXpSh9gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAv6UYIfizDjg56aszTIg+VAW7w4w="
            },
            {
                "key": "BwRt5Uck4SgnRSBgbwOFkaAMXpSh9gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAkamaUi1vw6QkcBuHVJcnnEJsHXA="
            },
            {
                "key": "BwRt5Uck4SgnRSBgbwOFkaAMXpSh9gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAmOjUtPU/oqLRucZRr5GfyDnuTBo="
            },
            {
                "key": "BwRt5Uck4SgnRSBgbwOFkaAMXpSh9gEAAAAbdHStdez94Q/YDLA7O4Gvq0KuNn6mpBzZV3h/tAXZuA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwRt5Uck4SgnRSBgbwOFkaAMXpSh9gEAAAArsuPrNZi/xw1DKpz1jLmkyFxNr6X2IcyxKyDIXCI9Tg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwRt5Uck4SgnRSBgbwOFkaAMXpSh9gEAAACzvBlmvPB9SZiphaN2YhZ4eTyWduw+4oAcAARo18swQQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA+nhrrDddiAYYVVUUkjWs2xgsAzs="
            },
            {
                "key": "BwRt5Uck4SgnRSBgbwOFkaAMXpSh9gEAAAD5semsS3m3yIKTo8w9FwfhHXxKWQsaAjt5M/dkGXBH4A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwRt5Uck4SgnRSBgbwOFkaAMXpSh9gEAAAD5semsS3m3yIKTo8w9FwfhHXxKWQsaAjt5M/dkGXBH4Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACbbmSo7GAAA="
            },
            {
                "key": "BwR5xXwkZ5RgbIOrMtxW5c0gMPtVKwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQIA="
            },
            {
                "key": "BwR5xXwkZ5RgbIOrMtxW5c0gMPtVKwEAAACdD6Ax11jZpeXLwrOtyKSU1ToCtEpTwi4SCZceeqsW+w==",
                "proof": [],
                "value": "AAAAAGJzwcMAAAAAAAAAAAAAAAAAAAAAAAAAAEr+vSQ="
            },
            {
                "key": "BwSRqZpSLW/DpCRwG4dUlyecQmwdcAEAAACKMK6GbnOtSzjpEW9BmkhwQ3MezmqICZ+TdJj034uh1g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAvkbkMNM2/IJ9CW2wRMuu7OcuF7w="
            },
            {
                "key": "BwSVUunf5S/3WY7uZ18w6y1wctRcegEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg="
            },
            {
                "key": "BwSVUunf5S/3WY7uZ18w6y1wctRcegEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAACp3SIapYL+cjiFmQTrzpbfH4M="
            },
            {
                "key": "BwSVUunf5S/3WY7uZ18w6y1wctRcegEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAYnO/y2Jzuxk="
            },
            {
                "key": "BwSVUunf5S/3WY7uZ18w6y1wctRcegEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAu/PUKB8Q5TfVsTyoC+IjYjELK/k="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAT0TRhJCK42fK0MsbMyoRVF12vIc="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAbeVHJOEoJ0UgYG8DhZGgDF6UofY="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAAAf7gQIidkSDap4NSkWFjaYva/niHggGVKSbNwGM/b0/A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFYDbF7QI/7A="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAAAvhZ1vdrQ9RI685bQih0lUI9+HQXJUQ1v/KG5uyf8BMw==",
                "proof": [],
                "value": "YnPBfQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAABo6Ot2+r1Doxshg7BhdI6JEWI0qmxsicbaOYPv9cwMQg==",
                "proof": [],
                "value": "YnPBfQAAAAAAAAAq81xgLYho2Zgb6xnO1GUbppEp2xg="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAABuFUAXG2wMlgtxpwINn2AHf2r5Mai79ZDaAiPaz3XHrw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAnx+TPGYKHchW8OD+BYQ1h5xczvA="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAABuFUAXG2wMlgtxpwINn2AHf2r5Mai79ZDaAiPaz3XHsA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAABvYm/dz49UDnunGL9WPUffcld+67+fMkr3rwfkY/pUrQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAp3SppK1fsknoZYzTZYXTV04ku66o="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAACSsQZs6lQ4meIXiMw+BGEANTf/kfDBPgUZifVaWVqvcw==",
                "proof": [],
                "value": "YnPBkgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAACUZVUi3zbXQqqHt55BXdu38wFPz9cYFm37SK6uKl9thg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAoOPHWyMFxs="
            },
            {
                "key": "BwSY6NS09T+iotG5xlGvkZ/IOe5MGgEAAACjRoOS2H+UdxMN/oIc36WLqPZt8RsImLODloDfHc7rSw==",
                "proof": [],
                "value": "YnPBkgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwSfH5M8ZgodyFbw4P4FhDWHnFzO8AEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA==",
                "proof": [],
                "value": "QlNUTgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwSfH5M8ZgodyFbw4P4FhDWHnFzO8AEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABI="
            },
            {
                "key": "BwSfH5M8ZgodyFbw4P4FhDWHnFzO8AEAAAB1r24wg0CrGom4+JM0LOAZ4nRZtUY00Urk8kktF0G8yw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAABlm5tuDo7e4hxds="
            },
            {
                "key": "BwSfH5M8ZgodyFbw4P4FhDWHnFzO8AEAAACvpydrOoC945c3zwzE8A4E01ulqv5TpqDllXUf4XNgag==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAWvlQwnrVGVfWM7w="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAnx+TPGYKHchW8OD+BYQ1h5xczvA="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YnPBggACbsIA0ed1v3sxcP9JAAAAWvlQwnrVGVfWM7w="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAACqCQBlq18H3+p2kjZ8fY/CBkw="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAHyMJ/OJD5HXdUugQAFcu0="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwS8iiROj7aD7B/W+I88xuVlCCF06wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwS8iiROj7aD7B/W+I88xuVlCCF06wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA9Oshe6JFRhOxXb3qbl8iJ2QQ6J4="
            },
            {
                "key": "BwS8iiROj7aD7B/W+I88xuVlCCF06wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YnPBmwAAAAAAAAAAAAbvf2KHAAvYOXBgltSgIdnsCYg="
            },
            {
                "key": "BwS8iiROj7aD7B/W+I88xuVlCCF06wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB9Vbw9lH99ZbU="
            },
            {
                "key": "BwS8iiROj7aD7B/W+I88xuVlCCF06wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAiePnpSF3Ng76C3aH5XQpUCOmRMLwMLZhc8="
            },
            {
                "key": "BwS8iiROj7aD7B/W+I88xuVlCCF06wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwS+RuQw0zb8gn0JbbBEy67s5y4XvAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABODM="
            },
            {
                "key": "BwS+RuQw0zb8gn0JbbBEy67s5y4XvAEAAAA/BEtocU8L9f8Cru0WarCiPAaJiSUhI3N2ZyLtx/ElRQ==",
                "proof": [],
                "value": "AAAAAGJzwbMAAAAAAAAAAAAAAAAAAAAAAAADl2gpmj4="
            },
            {
                "key": "BwTCQgWxL7BWgisrLEK17hgnKgqOdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEt",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAuageEh2MnWGWgrud22gjQ5F48vg="
            },
            {
                "key": "BwTCQgWxL7BWgisrLEK17hgnKgqOdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEu",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAW9lzB6QN+/2670s9mXrbgW8trcw="
            },
            {
                "key": "BwTCQgWxL7BWgisrLEK17hgnKgqOdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEw",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ/fQvbkgAA="
            },
            {
                "key": "BwTCQgWxL7BWgisrLEK17hgnKgqOdAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEx",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABHDeTfggAA="
            },
            {
                "key": "BwTCQgWxL7BWgisrLEK17hgnKgqOdDYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAofyWf9oUDajuJBzKUZHHRtgY91w="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAABxVEKWPt231o/sEBC0BaNcHiCC3iKPg51n8I8vyvbEXg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAvYOXBgltSgIdnsCYg="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAACvpydrOoC945c3zwzE8A4E01ulqv5TpqDllXUf4XNgag==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAJuwgDR53W/ezFw/0k="
            },
            {
                "key": "BwThzwm9ouCJxjMw8P/j9ta3kINZcwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAF0J2JZC7Bogu25WrkGlbAczX56Q="
            },
            {
                "key": "BwThzwm9ouCJxjMw8P/j9ta3kINZcwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAT6WcriseDTu62zOFuimws1gi6K0="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA1",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPQkA="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAwkIFsS+wVoIrKyxCte4YJyoKjnQ="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA9Oshe6JFRhOxXb3qbl8iJ2QQ6J4="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD7",
                "proof": [],
                "value": "AAAAAAAAAAAAAAD06yF7okVGE7FdvepuXyInZBDongA="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD8",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAqoe+5TgAA="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD9",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGJzIC4="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEt",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAbeVHJOEoJ0UgYG8DhZGgDF6UofY="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEu",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA+nhrrDddiAYYVVUUkjWs2xgsAzs="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEv",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADS8T93ifAAA="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEw",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACOG8m/BAAA="
            },
            {
                "key": "BwTimiNtOPYJ+niRhRoIKMi53Rl/bqPwrXTlQjrr/YDT70NGV4M1qacq6u5Z/2yzWCs1Ez1Q",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAANegBxiRko3mwnR7tIbUYdSJxK20="
            },
            {
                "key": "BwT06yF7okVGE7FdvepuXyInZBDongEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA==",
                "proof": [],
                "value": "V0JUQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwT06yF7okVGE7FdvepuXyInZBDongEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwT06yF7okVGE7FdvepuXyInZBDongEAAAAHTkf/gO02ydL/z+KoVW+LDhZZbDPR/GOCRWz0THhzaQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACDHMdEU="
            },
            {
                "key": "BwT06yF7okVGE7FdvepuXyInZBDongEAAABxVEKWPt231o/sEBC0BaNcHiCC3iKPg51n8I8vyvbEXg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABu9/Yoc="
            },
            {
                "key": "BwT6Zw0HclwEWG6R1/lwUSoz0NaT4AEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAecV8JGeUYGyDqzLcVuXNIDD7VSs="
            },
            {
                "key": "BwT6Zw0HclwEWG6R1/lwUSoz0NaT4AEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAalVLp3+Uv91mO7mdfMOstcHLUXHo="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC",
                "proof": [],
                "value": "Y1dCVEMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAbeVHJOEoJ0UgYG8DhZGgDF6UofY="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAJA/cXkRm5G5IV3t4ht/VHAd/c/Y="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABCnQaRieAAA="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGJzivg="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADe98ptrU7iQ="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBEeZ+4="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVSZI="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUTaOrzk="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA9Oshe6JFRhOxXb3qbl8iJ2QQ6J4="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDOwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAwr/YwXgENY+p8K1oPSApNEGAzl8="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDO9Dk3pRAxcv5cPnkZX1NRCRprHsGjcIrP979cpa2IrJa",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACm9RM="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDO91J20a5Do62chDxCh6VZ9GNTmPNvaWA5A0hwp9qx/Oj",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASKHQ="
            },
            {
                "key": "BwT6eGusN12IBhhVVRSSNazbGCwDO91J20a5Do62chDxCh6VZ9GNTmPNvaWA5A0hwp9qx/Ok",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADe9RexEXk+0="
            },
            {
                "key": "BwckD9xeRGbkbkhXe3iG39UcB39z9g==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwc16AHGJGSjebCdHu0htRh1InErbQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwdPpZyuKx4NO7rbM4W6KbCzWCLorQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwdt5Uck4SgnRSBgbwOFkaAMXpSh9g==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwd5xXwkZ5RgbIOrMtxW5c0gMPtVKw==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BweRqZpSLW/DpCRwG4dUlyecQmwdcA==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BweVUunf5S/3WY7uZ18w6y1wctRceg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BweY6NS09T+iotG5xlGvkZ/IOe5MGg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwefH5M8ZgodyFbw4P4FhDWHnFzO8A==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwe+RuQw0zb8gn0JbbBEy67s5y4XvA==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwfhzwm9ouCJxjMw8P/j9ta3kINZcw==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwf06yF7okVGE7FdvepuXyInZBDong==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwf6Zw0HclwEWG6R1/lwUSoz0NaT4A==",
                "proof": [],
                "value": "AAAAAQ=="
            }
        ]
    }
}
'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/res/aurora_state_Emufid2.json ---
{
    "id": "1",
    "jsonrpc": "2.0",
    "result": {
        "block_hash": "GFm9DHxH46VFRrJ4nz5K93vQyZ3hZPNiV7myS2xJL4iS",
        "block_height": 99197179,
        "proof": [],
        "values": [
            {
                "key": "BwBTVEFURQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5FQVMGAAAAYXVyb3JhAAAAAAAAAAAAAAAA"
            },
            {
                "key": "BwEIohKKF0n0FEsN/ObdMF573LHv8Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwES4RoP3Sh2Lur7zng1ukN6GSVCww==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEzwfD9LYjCn/e9+pwZpHXXnLmTyw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwF1lEzuYMKXasxmD3VzaJCh3xpiQg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGDz8mAMQpgjYhcf/vsznYgoV5row==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF4="
            },
            {
                "key": "BwGzIZ1VKG1hyqRjpvnnTkHugTxvHg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwG7YyZJhdwHBWt9Alu8TULUn8bBpg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHCMFMViItOEVFSZVvL6PptDjVgxA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHO0wGqlC9yDUadiBuPrx1IdGybfQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHbUOWoZ4HHQDWl+4LNNsVEA+lpNg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAALs="
            },
            {
                "key": "BwHgwCG9gEDVTmHxB8hqDX7rfCv4sw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM="
            },
            {
                "key": "BwHidktZ1Z81M6wwyDnRjKKpuXoPKA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHjC5Q5M8SiTrTfBVJR+ZKm3g1q0Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHpXZ7l7J29EQeNilR0tEJ54pIvhQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwH7UPpdjx8B02RTHBJm7g7nu4MC+g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwJrGVnnAwPjNNfLV3IixilrwTL67Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHZdlnJoBrou8="
            },
            {
                "key": "BwLbUOWoZ4HHQDWl+4LNNsVEA+lpNg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQK71YSrR4="
            },
            {
                "key": "BwMIohKKF0n0FEsN/ObdMF573LHv8Q==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwMS4RoP3Sh2Lur7zng1ukN6GSVCww==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwMzwfD9LYjCn/e9+pwZpHXXnLmTyw==",
                "proof": [],
                "value": "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G81g5RuBUmAgYASCAVJgGWAkggFSf0NyZWF0ZTI6IEZhaWxlZCBvbiBkZXBsb3kAAAAAAAAAYESCAVJgZAFiAAfBVluUk1BQUFBWW4KAVGIAKomQYgA0iFZbkGAAUmAgYAAgkGAfAWAgkASBAZKCYgAqrVdgAIVVYgAq+FZbgmAfEGIAKshXgFFg/xkWg4ABF4VVYgAq+FZbgoABYAEBhVWCFWIAKvhXkYIBW4KBERViACr4V4JRglWRYCABkZBgAQGQYgAq21ZbUGIAKwaSkVBiACsYVltQkFZbYRpRgGIAN86DOQGQVltbgIIRFWIAKwZXYACBVWABAWIAKxlWW4A1YAFgAWCgGwOBFoEUYgArR1dgAID9W5GQUFZbYABgIIKEAxIVYgArX1dgAID9W2IAK2qCYgArL1Zbk5JQUFBWW2AAYCCChAMSFWIAK4RXYACA/VtQNZGQUFZbY05Ie3Fg4BtgAFJgQWAEUmAkYAD9W2BAUWBggQFn//////////+BEYKCEBcVYgArx1diACvHYgAri1ZbYEBSkFZbYEBRYB+CAWAfGRaBAWf//////////4ERgoIQFxViACv5V2IAK/liACuLVltgQFKRkFBWW4AVFYEUYgAlbFdgAID9W2AAgmAfgwESYgAsIldgAID9W4E1Z///////////gREVYgAsP1diACw/YgAri1ZbYgAsVGAfggFgHxkWYCABYgArzVZbgYFShGAgg4YBAREVYgAsaldgAID9W4FgIIUBYCCDATdgAJGBAWAgAZGQkVKTklBQUFZbYABgIICDhQMSFWIALJtXYACA/VuCNWf//////////4CCERViACy0V2AAgP1bgYUBkVBgYICDiAMSFWIALMtXYACA/VtiACzVYgAroVZbgzWBUoSEATWDgREVYgAs61dgAID9W4QBYB+BAYkTYgAs/VdgAID9W4A1hIERFWIALRJXYgAtEmIAK4tWW2IALSKHgmAFGwFiACvNVluBgVKQhAKCAYcBkIeBAZCLgxEVYgAtP1dgAID9W5KIAZJbgoQQFWIALaRXhYSNAxIVYgAtXldgAICB/VtiAC1oYgAroVZbhDWBUomFATViAC17gWIALAFWW4GLAVJgQIWBATViAC2QgWIALAFWW5CCAVKCUpKFAZKQiAGQYgAtRFZbgImGAVJQUFBQYECEATWUUIKFERViAC3CV2AAgP1bYgAt0IiGhgFiACwQVltgQIIBUpeWUFBQUFBQUFZbYABbg4EQFWIALf1XgYEBUYOCAVJgIAFiAC3jVluDgREVYgALHldQUGAAkQFSVltgAIFRgIRSYgAuKYFgIIYBYCCGAWIALeBWW2AfAWAfGRaSkJIBYCABkpFQUFZbYCCBUmAAYgAramAggwGEYgAuD1ZbYACAYABgYISGAxIVYgAuaFdgAID9W2IALnOEYgArL1ZbklBiAC6DYCCFAWIAKy9WW5FQYECEATWQUJJQklCSVltgAGBggoQDEhViAC6mV2AAgP1bUJGQUFZbYACAYACAYABg4IaIAxIVYgAuxVdgAID9W2IALtCGYgArL1ZblFBgIIYBNZNQYgAu52BAhwFiACsvVluSUGIALvdgYIcBYgArL1ZbkVBiAC8Ih2CAiAFiAC6TVluQUJKVUJKVkJNQVluANWD/gRaBFGIAK0dXYACA/VtgAIBgAIBgAGCghogDEhViAC8/V2AAgP1bhTWUUGIAL1FgIIcBYgArL1Zbk1BiAC9hYECHAWIALxRWW5SXk5ZQk5RgYIEBNZRQYIABNZKRUFBWW2AAgGAAgGAAgGAAh4kDYQLggRIVYgAvl1dgAID9W2IAL6KJYgArL1Zbl1BgIIkBNZZQYgAvuWBAigFiACsvVluVUGIAL8lgYIoBYgArL1ZblFBiAC/aimCAiwFiAC6TVluTUGEBoGDfGYIBEhViAC/wV2AAgP1bUGDgiAGRUGIAMAeJYQKAigFiAC6TVluQUJKVmJGUl1CSlVBWW2AAgGAAgGAAgGAAYOCIigMSFWIAMDFXYACA/VuHNZZQYgAwQ2AgiQFiACsvVluVUGIAMFNgQIkBYgArL1ZblFBgYIgBNZNQYgAwamCAiQFiAC8UVluSUGCgiAE1kVBgwIgBNZBQkpWYkZSXUJKVUFZbY05Ie3Fg4BtgAFJgIWAEUmAkYAD9W2ADgRBiACVsV2NOSHtxYOAbYABSYCFgBFJgJGAA/VuGgVJgIIEBhpBSYECBAYWQUmBggQGEkFJgAWABYKAbA4MWYICCAVJgwIEBYgAw8YNiADCcVluCYKCDAVKXllBQUFBQUFBWW2AAgGAAgGAAgGDAh4kDEhViADEcV2AAgP1bhjWVUGIAMS5gIIgBYgAvFFZblFBgQIcBNWf//////////4CCERViADFMV2AAgP1bYgAxWoqDiwFiACwQVluVUGBgiQE1kVCAghEVYgAxcVdgAID9W2IAMX+Kg4sBYgAsEFZblFBggIkBNZNQYKCJATWRUICCERViADGdV2AAgP1bUGIAMayJgooBYgAsEFZbkVBQkpVQkpVQkpVWW2BAgIJSg1GQggGBkFJgAJBgIJBgYIQBkIKHAYRbgoEQFWIAMfRXgVGEUpKEAZKQhAGQYAEBYgAx1lZbUFBQg4EDgoUBUoRRgIJShYMBkYMBkGAAW4GBEBViADI0V4NRYAFgAWCgGwMWg1KShAGSkYQBkWABAWIAMg1WW1CQl5ZQUFBQUFBQVltgIIEBYgAyUINiADCcVluRkFKQVltgAIBgAIBggIWHAxIVYgAybVdgAID9W4Q1k1BiADJ/YCCGAWIAKy9WW5JQYECFATWRUGIAMpZgYIYBYgArL1ZbkFCSlZGUUJJQVltgIICCUoGBAVJ/T3duYWJsZTogY2FsbGVyIGlzIG5vdCB0aGUgb3duZXJgQIIBUmBgAZBWW2NOSHtxYOAbYABSYDJgBFJgJGAA/VtgAINRYgAzAIGEYCCIAWIALeBWW4NRkIMBkGIAMxaBg2AgiAFiAC3gVlsBlJNQUFBQVltgAGAAGYIUFWIAM0JXY05Ie3Fg4BtgAFJgEWAEUmAkYAD9W1BgAQGQVltgAINRYgAzXYGEYCCIAWIALeBWW5GQkQGRglJQYCABkZBQVltgAINRYgAzgYGEYCCIAWIALeBWW2Dgk5CTG2ABYAFg4BsDGRaRkJIBkIFSYAQBkpFQUFZbYABgIIKEAxIVYgAztFdgAID9W1BRkZBQVltg4IFSYABiADPQYOCDAYpiAC4PVltgAWABYKAbA5iJFmAghAFSlogWYECDAVJQYGCBAZSQlFJggIQBkpCSUpCTFmCgggFSYMABkZCRUpGQUFZbYABgIIKEAxIVYgA0IFdgAID9W4FRYgAraoFiACwBVltgAWABYPgbAxlg+JmKG4EWglKXiRuIFmABggFSlYgbhxZgAocBUpOHG4YWYAOGAVKRhhuFFmAEhQFShRuEFmAFhAFShBuDFmAGgwFSkJIbFmAHggFSYAgBkFZbYAGBgRyQghaAYgA0nVdgf4IWkVBbYCCCEIEUFWIALqZXY05Ie3Fg4BtgAFJgImAEUmAkYAD9W2ABYAFgoBsDgGIANNODYgArL1ZbFoNSgGIANOVgIIQBYgArL1ZbFmAghAFSUGBAkIEBNZEBUlZbhoFSYCCBAYaQUmBAgQGFkFJgAWABYKAbA4QWYGCCAVJhAoCBAWIANTxggIMBYgA1L4ZiACsvVltgAWABYKAbAxaQUlZbYgA1SmAghQFiACsvVltgAWABYKAbAxZgoIMBUmBAhAE1YMCDAVJiADVwYGCFAWIAKy9WW2ABYAFgoBsDFmDggwFSYgA1jGCAhQFiACsvVlthAQBiADWkgYUBg2ABYAFgoBsDFpBSVlthASCRUGCghgE1goUBUmIANcBgwIcBYgArL1ZbYQFAYgA12IGHAYNgAWABYKAbAxaQUlZbYgA15mDgiQFiACsvVluRUGEBYGIANgCBiAGEYAFgAWCgGwMWkFJWW2IANg2EigFiACsvVluTUGEBgJJQYgA2KYOIAYVgAWABYKAbAxaQUlZbhIkBNWEBoIgBUoGJATVhAcCIAVJiADZKgYoBYgArL1ZblFBQUGIANmVhAeCGAYRgAWABYKAbAxaQUlZbhgE1YQIAhQFSUGIANoGQUGECIIMBhGIANL9WW5eWUFBQUFBQUFZbYCCAglJgKJCCAVJ/U3ludGhlc2lzOiByZXByZXNlbnRhdGlvbiBhbHJlYWRgQIIBUmd5IGV4aXN0c2DAG2BgggFSYIABkFZbYMCBUmAAYgA26WDAgwGJYgAuD1ZbgoEDYCCEAVJiADb9gYliAC4PVluQUGD/hxZgQIQBUoVgYIQBUoRggIQBUoKBA2CghAFSYgA3KIGFYgAuD1ZbmZhQUFBQUFBQUFBWW2BzYPgbgVJgAINRYgA3U4FgAYUBYCCIAWIALeBWW2BfYPgbYAGRhAGRggFSg1FiADd2gWAChAFgIIgBYgAt4FZbAWACAZSTUFBQUFZbYCCAglJgK5CCAVJ/SW5pdGlhbGl6YWJsZTogY29udHJhY3QgaXMgbm90IGlgQIIBUmpuaXRpYWxpemluZ2CoG2BgggFSYIABkFb+YQFAYEBSf25x7a4Ssbl/TR9gNw/vEBBfovquASYRShacZIRdYSbJYQEgUjSAFWIAADdXYACA/VtQYEBRYgAaUTgDgGIAGlGDOYEBYECBkFJiAABakWIAA3FWW2BAUYBgQAFgQFKAYASBUmAgAWNFWVdBYOAbgVJQgGBAUYBgQAFgQFKAYAGBUmAgAWAxYPgbgVJQiIhgAGIAAKZiAAH6YCAbYCAcVltgAIBUYAFgAWCgGwMZFmABYAFgoBsDgxaQgReCVWBAUZKTUJF/i+AHnFMWWRQTRM0f0KTyhBlJf5cio9qv47QYb2tkV+CQgpCjUIFRYgABBZBgBJBgIIUBkGIAAf5WW1CAUWIAARuQYAWQYCCEAZBiAAH+VltQUIJRYCCThAEgglGShAGSkJIgYMCDgVJg4IKQUkZgoIGBUmBAgFF/i3PDxpu4/j1RLsxM91nMeSOfexebD/rKqaddUis5QA+BigGBkFKBgwGYkJhSYGCBAZWQlVJggICGAZOQk1IwhYMBUoBRgIYDkJIBglKTkJIBkJJSgFGQhQEgkFJQYQEAUodRYgABuJJQYAeRiQGQYgAB/lZbUGAIgpBVYAmDkFWAUWIAAdiQYAqQYCCEAZBiAAH+VltQUGALgFRg/xkWYP+UkJQWk5CTF5CSVVBiAARtklBQUFZbM5BWW4KAVGIAAgyQYgAEMFZbkGAAUmAgYAAgkGAfAWAgkASBAZKCYgACMFdgAIVVYgACe1ZbgmAfEGIAAktXgFFg/xkWg4ABF4VVYgACe1ZbgoABYAEBhVWCFWIAAntXkYIBW4KBERViAAJ7V4JRglWRYCABkZBgAQGQYgACXlZbUGIAAomSkVBiAAKNVltQkFZbW4CCERViAAKJV2AAgVVgAQFiAAKOVltjTkh7cWDgG2AAUmBBYARSYCRgAP1bYACCYB+DARJiAALMV2AAgP1bgVFgAWABYEAbA4CCERViAALpV2IAAuliAAKkVltgQFFgH4MBYB8ZkIEWYD8BFoEBkIKCEYGDEBcVYgADFFdiAAMUYgACpFZbgWBAUoOBUmAgklCGg4WIAQERFWIAAzFXYACA/VtgAJFQW4OCEBViAANVV4WCAYMBUYGDAYQBUpCCAZBiAAM2VluDghEVYgADZ1dgAIOFgwEBUluWlVBQUFBQUFZbYACAYACAYACAYMCHiQMSFWIAA4tXYACA/VuGUWABYAFgQBsDgIIRFWIAA6NXYACA/VtiAAOxioOLAWIAArpWW5dQYCCJAVGRUICCERViAAPIV2AAgP1bYgAD1oqDiwFiAAK6VluWUGBAiQFRkVBg/4IWghRiAAPvV2AAgP1bYGCJAVFggIoBUWCgiwFRk5dQkJVQk1CAghEVYgAEFFdgAID9W1BiAAQjiYKKAWIAArpWW5FQUJKVUJKVUJKVVltgAYGBHJCCFoBiAARFV2B/ghaRUFtgIIIQgRQVYgAEZ1djTkh7cWDgG2AAUmAiYARSYCRgAP1bUJGQUFZbYIBRYKBRYMBRYOBRYQEAUWEBIFFhFZRiAAS9YAA5YABhCGkBUmAAYQ3hAVJgAGEOMAFSYABhDgsBUmAAYQ2PAVJgAGENuAFSYRWUYADz/mCAYEBSNIAVYQAQV2AAgP1bUGAENhBhAalXYAA1YOAcgGN0dzQSEWEA+VeAY58MgSURYQCXV4BjqRit9RFhAHFXgGOpGK31FGEDR1eAY9UFrM8UYQNaV4Bj3WLtPhRhA21XgGPy/eOLFGEDgFdgAID9W4BjnwyBJRRhAxlXgGOkV8LXFGEDIVeAY6kFnLsUYQM0V2AAgP1bgGONpctbEWEA01eAY42ly1sUYQLQV4BjldibQRRhAutXgGOb5OeyFGEC81eAY53Cn6wUYQMGV2AAgP1bgGN0dzQSFGECrFeAY3UyUEkUYQK1V4Bjfs6+ABRhAr1XYACA/VuAYzJCSqMRYQFmV4BjOVCTURFhAUBXgGM5UJNRFGECU1eAY0DBDxkUYQJmV4BjcKCCMRRhAntXgGNxUBimFGECpFdgAID9W4BjMkJKoxRhAjZXgGM0CORwFGECQ1eAYzZE5RUUYQJLV2AAgP1bgGMG/d4DFGEBrleAYwlep7MUYQHMV4BjGBYN3RRhAe9XgGMjuHLdFGECAVeAYy6YAK8UYQIUV4BjMTzlZxRhAh1XW2AAgP1bYQG2YQOTVltgQFFhAcORkGESy1ZbYEBRgJEDkPNbYQHfYQHaNmAEYRM8VlthBCVWW2BAUZAVFYFSYCABYQHDVltgA1RbYEBRkIFSYCABYQHDVlthAd9hAg82YARhE2ZWW2EEO1ZbYQHzYAhUgVZbYAtUYP8WW2BAUWD/kJEWgVJgIAFhAcNWW2ALVGECJJBg/xaBVltgCVRhAfNWW2EB82EE8VZbYQHfYQJhNmAEYRM8VlthBQBWW2ECeWECdDZgBGETPFZbYQU3VlsAW2EB82ECiTZgBGETolZbYAFgAWCgGwMWYACQgVJgAWAgUmBAkCBUkFZbYQJ5YQVvVlthAfNgCVSBVlthAbZhBeNWW2EB82ECyzZgBGETolZbYQZxVltgAFRgQFFgAWABYKAbA5CRFoFSYCABYQHDVlthAbZhBpFWW2ECeWEDATZgBGETZlZbYQagVlthAnlhAxQ2YARhEzxWW2EG81ZbYQG2YQcnVlthAd9hAy82YARhEzxWW2EHNFZbYQHfYQNCNmAEYRM8VlthB5FWW2ECeWEDVTZgBGETZlZbYQeeVlthAnlhA2g2YARhE8RWW2EIFVZbYQHzYQN7NmAEYRQ3VlthCXlWW2ECeWEDjjZgBGETolZbYQmkVltgYGAEgFRhA6KQYRRqVluAYB8BYCCAkQQCYCABYEBRkIEBYEBSgJKRkIGBUmAgAYKAVGEDzpBhFGpWW4AVYQQbV4BgHxBhA/BXYQEAgINUBAKDUpFgIAGRYQQbVluCAZGQYABSYCBgACCQW4FUgVKQYAEBkGAgAYCDEWED/leCkANgHxaCAZFbUFBQUFCQUJBWW2AAYQQyM4SEYQqOVltQYAGSkVBQVltgAGEESISEhGELs1ZbYAFgAWCgGwOEFmAAkIFSYAJgIJCBUmBAgIMgM4RSkJFSkCBUgoEQFWEE0ldgQFFiRhvNYOUbgVJgIGAEggFSYChgJIIBUn9FUkMyMDogdHJhbnNmZXIgYW1vdW50IGV4Y2VlZHMgYWBEggFSZ2xsb3dhbmNlYMAbYGSCAVJghAFbYEBRgJEDkP1bYQTmhTNhBOGGhWEUtVZbYQqOVltQYAGUk1BQUFBWW2AAYQT7YQ2LVluQUJBWWzNgAIGBUmACYCCQgVJgQICDIGABYAFgoBsDhxaEUpCRUoEgVJCRYQQykYWQYQThkIaQYRTMVltgAFRgAWABYKAbAxYzFGEFYVdgQFFiRhvNYOUbgVJgBAFhBMmQYRTkVlthBWuCgmEOflZbUFBWW2AAVGABYAFgoBsDFjMUYQWZV2BAUWJGG81g5RuBUmAEAWEEyZBhFORWW2AAgFRgQFFgAWABYKAbA5CRFpB/i+AHnFMWWRQTRM0f0KTyhBlJf5cio9qv47QYb2tkV+CQg5CjYACAVGABYAFgoBsDGRaQVVZbYAqAVGEF8JBhFGpWW4BgHwFgIICRBAJgIAFgQFGQgQFgQFKAkpGQgYFSYCABgoBUYQYckGEUalZbgBVhBmlXgGAfEGEGPldhAQCAg1QEAoNSkWAgAZFhBmlWW4IBkZBgAFJgIGAAIJBbgVSBUpBgAQGQYCABgIMRYQZMV4KQA2AfFoIBkVtQUFBQUIFWW2ABYAFgoBsDgRZgAJCBUmAGYCBSYECBIFRbkpFQUFZbYGBgBYBUYQOikGEUalZbYABUYAFgAWCgGwMWMxRhBspXYEBRYkYbzWDlG4FSYAQBYQTJkGEU5FZbYQbUg4JhDn5WW2EG7oODg2EG5IeHYQl5VlthBOGRkGEUzFZbUFBQVltgAFRgAWABYKAbAxYzFGEHHVdgQFFiRhvNYOUbgVJgBAFhBMmQYRTkVlthBWuCgmEPXVZbYAeAVGEF8JBhFGpWWzNgAJCBUmACYCCQgVJgQICDIGABYAFgoBsDhhaEUpCRUoEgVIKBEBVhB3hXYEBRYkYbzWDlG4FSYAQBYQTJkGEVGVZbYQeHM4VhBOGGhWEUtVZbUGABk5JQUFBWW2AAYQQyM4SEYQuzVltgAFRgAWABYKAbAxYzFGEHyFdgQFFiRhvNYOUbgVJgBAFhBMmQYRTkVltgAGEH1ISEYQl5VluQUIGBEBVhB/ZXYEBRYkYbzWDlG4FSYAQBYQTJkGEVGVZbYQgFhIRhBOGFhWEUtVZbYQgPhINhD11WW1BQUFBWW4NCERVhCGVXYEBRYkYbzWDlG4FSYCBgBIIBUmAdYCSCAVJ/RVJDMjBQZXJtaXQ6IGV4cGlyZWQgZGVhZGxpbmUAAABgRIIBUmBkAWEEyVZbYAB/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACIiIhhCJSMYRCsVltgQIBRYCCBAZaQllJgAWABYKAbA5SFFpCGAVKSkJEWYGCEAVJggIMBUmCgggFSYMCBAYaQUmDgAWBAUWAggYMDA4FSkGBAUoBRkGAgASCQUGAAYQjvgmEQ1FZbkFBgAGEI/4KHh4dhESJWW5BQiWABYAFgoBsDFoFgAWABYKAbAxYUYQliV2BAUWJGG81g5RuBUmAgYASCAVJgHmAkggFSf0VSQzIwUGVybWl0OiBpbnZhbGlkIHNpZ25hdHVyZQAAYESCAVJgZAFhBMlWW2EJbYqKimEKjlZbUFBQUFBQUFBQUFZbYAFgAWCgGwORghZgAJCBUmACYCCQgVJgQICDIJOQlBaCUpGQkVIgVJBWW2AAVGABYAFgoBsDFjMUYQnOV2BAUWJGG81g5RuBUmAEAWEEyZBhFORWW2ABYAFgoBsDgRZhCjNXYEBRYkYbzWDlG4FSYCBgBIIBUmAmYCSCAVJ/T3duYWJsZTogbmV3IG93bmVyIGlzIHRoZSB6ZXJvIGFgRIIBUmVkZHJlc3Ng0BtgZIIBUmCEAWEEyVZbYACAVGBAUWABYAFgoBsDgIUWk5IWkX+L4AecUxZZFBNEzR/QpPKEGUl/lyKj2q/jtBhva2RX4JGjYACAVGABYAFgoBsDGRZgAWABYKAbA5KQkhaRkJEXkFVWW2ABYAFgoBsDgxZhCvBXYEBRYkYbzWDlG4FSYCBgBIIBUmAkgIIBUn9FUkMyMDogYXBwcm92ZSBmcm9tIHRoZSB6ZXJvIGFkZGBEggFSY3Jlc3Ng4BtgZIIBUmCEAWEEyVZbYAFgAWCgGwOCFmELUVdgQFFiRhvNYOUbgVJgIGAEggFSYCJgJIIBUn9FUkMyMDogYXBwcm92ZSB0byB0aGUgemVybyBhZGRyZWBEggFSYXNzYPAbYGSCAVJghAFhBMlWW2ABYAFgoBsDg4EWYACBgVJgAmAgkIFSYECAgyCUhxaAhFKUglKRgpAghZBVkFGEgVJ/jFvh5evsfVvRT3FCfR6E890DFMD3sikeWyAKyMfDuSWRAVtgQFGAkQOQo1BQUFZbYAFgAWCgGwODFmEMF1dgQFFiRhvNYOUbgVJgIGAEggFSYCVgJIIBUn9FUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGBEggFSZGRyZXNzYNgbYGSCAVJghAFhBMlWW2ABYAFgoBsDghZhDHlXYEBRYkYbzWDlG4FSYCBgBIIBUmAjYCSCAVJ/RVJDMjA6IHRyYW5zZmVyIHRvIHRoZSB6ZXJvIGFkZHJgRIIBUmJlc3Ng6BtgZIIBUmCEAWEEyVZbYAFgAWCgGwODFmAAkIFSYAFgIFJgQJAgVIGBEBVhDPFXYEBRYkYbzWDlG4FSYCBgBIIBUmAmYCSCAVJ/RVJDMjA6IHRyYW5zZmVyIGFtb3VudCBleGNlZWRzIGJgRIIBUmVhbGFuY2Vg0BtgZIIBUmCEAWEEyVZbYQz7goJhFLVWW2ABYAFgoBsDgIYWYACQgVJgAWAgUmBAgIIgk5CTVZCFFoFSkIEggFSEkpBhDTGQhJBhFMxWW5JQUIGQVVCCYAFgAWCgGwMWhGABYAFgoBsDFn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz74RgQFFhDX2RgVJgIAGQVltgQFGAkQOQo1BQUFBWW2AAfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARhQVYQ3aV1B/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQVltQYECAUX8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGAggIMBkZCRUn8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIKEAVJ/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgYIMBUkZggIMBUjBgoICEAZGQkVKDUYCEA5CRAYFSYMCQkgGQklKAUZEBIJBWW2ABYAFgoBsDghZhDtRXYEBRYkYbzWDlG4FSYCBgBIIBUmAfYCSCAVJ/RVJDMjA6IG1pbnQgdG8gdGhlIHplcm8gYWRkcmVzcwBgRIIBUmBkAWEEyVZbgGADYACCglRhDuaRkGEUzFZbkJFVUFBgAWABYKAbA4IWYACQgVJgAWAgUmBAgSCAVIOSkGEPE5CEkGEUzFZbkJFVUFBgQFGBgVJgAWABYKAbA4MWkGAAkH/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75BgIAFgQFGAkQOQo1BQVltgAWABYKAbA4IWYQ+9V2BAUWJGG81g5RuBUmAgYASCAVJgIWAkggFSf0VSQzIwOiBidXJuIGZyb20gdGhlIHplcm8gYWRkcmVzYESCAVJgc2D4G2BkggFSYIQBYQTJVltgAWABYKAbA4IWYACQgVJgAWAgUmBAkCBUgYEQFWEQMVdgQFFiRhvNYOUbgVJgIGAEggFSYCJgJIIBUn9FUkMyMDogYnVybiBhbW91bnQgZXhjZWVkcyBiYWxhbmBEggFSYWNlYPAbYGSCAVJghAFhBMlWW2EQO4KCYRS1VltgAWABYKAbA4QWYACQgVJgAWAgUmBAgSCRkJFVYAOAVISSkGEQaZCEkGEUtVZbkJFVUFBgQFGCgVJgAJBgAWABYKAbA4UWkH/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75BgIAFhC6ZWW2ABYAFgoBsDgRZgAJCBUmAGYCBSYECQIIBUYAGBAYJVkFtQkZBQVltgAGEGi2EQ4WENi1Zbg2BAUWEZAWDwG2AgggFSYCKBAYOQUmBCgQGCkFJgAJBgYgFgQFFgIIGDAwOBUpBgQFKAUZBgIAEgkFCSkVBQVltgAH9/////////////////////XVduc1ekUB3f6S9GaBsgoIIRFWERn1dgQFFiRhvNYOUbgVJgIGAEggFSYCJgJIIBUn9FQ0RTQTogaW52YWxpZCBzaWduYXR1cmUgJ3MnIHZhbGBEggFSYXVlYPAbYGSCAVJghAFhBMlWW4Ng/xZgGxSAYRG0V1CDYP8WYBwUW2ESC1dgQFFiRhvNYOUbgVJgIGAEggFSYCJgJIIBUn9FQ0RTQTogaW52YWxpZCBzaWduYXR1cmUgJ3YnIHZhbGBEggFSYXVlYPAbYGSCAVJghAFhBMlWW2BAgFFgAICCUmAgggGAhFKIkFJg/4cWkoIBkpCSUmBggQGFkFJggIEBhJBSYAGQYKABYCBgQFFgIIEDkICEA5CFWvoVgBVhEl9XPWAAgD49YAD9W1BQYEBRYB8ZAVGRUFBgAWABYKAbA4EWYRLCV2BAUWJGG81g5RuBUmAgYASCAVJgGGAkggFSf0VDRFNBOiBpbnZhbGlkIHNpZ25hdHVyZQAAAAAAAAAAYESCAVJgZAFhBMlWW5WUUFBQUFBWW2AAYCCAg1KDUYCChQFSYABbgYEQFWES+FeFgQGDAVGFggFgQAFSggFhEtxWW4GBERVhEwpXYABgQIOHAQFSW1BgHwFgHxkWkpCSAWBAAZOSUFBQVluANWABYAFgoBsDgRaBFGETN1dgAID9W5GQUFZbYACAYECDhQMSFWETT1dgAID9W2ETWINhEyBWW5RgIJOQkwE1k1BQUFZbYACAYABgYISGAxIVYRN7V2AAgP1bYROEhGETIFZbklBhE5JgIIUBYRMgVluRUGBAhAE1kFCSUJJQklZbYABgIIKEAxIVYRO0V2AAgP1bYRO9gmETIFZbk5JQUFBWW2AAgGAAgGAAgGAAYOCIigMSFWET31dgAID9W2ET6IhhEyBWW5ZQYRP2YCCJAWETIFZblVBgQIgBNZRQYGCIATWTUGCAiAE1YP+BFoEUYRQaV2AAgP1blpmVmFCTlpKVlGCghAE1lFBgwJCTATWSkVBQVltgAIBgQIOFAxIVYRRKV2AAgP1bYRRTg2ETIFZbkVBhFGFgIIQBYRMgVluQUJJQkpBQVltgAYGBHJCCFoBhFH5XYH+CFpFQW2AgghCBFBVhEM5XY05Ie3Fg4BtgAFJgImAEUmAkYAD9W2NOSHtxYOAbYABSYBFgBFJgJGAA/VtgAIKCEBVhFMdXYRTHYRSfVltQA5BWW2AAghmCERVhFN9XYRTfYRSfVltQAZBWW2AggIJSgYEBUn9Pd25hYmxlOiBjYWxsZXIgaXMgbm90IHRoZSBvd25lcmBAggFSYGABkFZbYCCAglJgJZCCAVJ/RVJDMjA6IGRlY3JlYXNlZCBhbGxvd2FuY2UgYmVsb3dgQIIBUmQgemVyb2DYG2BgggFSYIABkFb+omRpcGZzWCISIDWltY0oJzg3PL/b5L9m8ur+wpaBhh15acZVbdO4N/Z0ZHNvbGNDAAgKADN1bnN5bnRoZXNpemVXaXRoU3dhcChieXRlczMyLGFkZHJlc3MsdWludDI1NixhZGRyZXNzLChhZGRyZXNzLGFkZHJlc3MsdWludDI1NixhZGRyZXNzLGFkZHJlc3MsdWludDI1NixhZGRyZXNzLGFkZHJlc3MsYWRkcmVzcyx1aW50MjU2LHVpbnQyNTYsYWRkcmVzcyx1aW50MjU2KSwoYWRkcmVzcyxhZGRyZXNzLHVpbnQyNTYpKWVtZXJnZW5jeVVuc3ludGhlc2l6ZShieXRlczMyLGFkZHJlc3MsdWludDgsYnl0ZXMzMixieXRlczMydW5zeW50aGVzaXplKGJ5dGVzMzIsYWRkcmVzcyx1aW50MjU2LGFkZHJlc3MpbWludFN5bnRoZXRpY1Rva2VuKGJ5dGVzMzIsYWRkcmVzcyx1aW50MjU2LGFkZHJlc3MpomRpcGZzWCISIJ3CXIwz05iOe+qdT2juTZO3tfIvw7pQ+sXIz4lwyDtnZHNvbGNDAAgKADM="
            },
            {
                "key": "BwN1lEzuYMKXasxmD3VzaJCh3xpiQg==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwODz8mAMQpgjYhcf/vsznYgoV5row==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOzIZ1VKG1hyqRjpvnnTkHugTxvHg==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwO7YyZJhdwHBWt9Alu8TULUn8bBpg==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPCMFMViItOEVFSZVvL6PptDjVgxA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPO0wGqlC9yDUadiBuPrx1IdGybfQ==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEATFdgADVg4ByAY4MZfvAUYQBRV4BjjaXLWxRhAFtXgGOv4W5EFGEAi1eAY9gFt4wUYQCuV1tgAID9W2EAWWEA0VZbAFtgAVRhAG6QYAFgAWCgGwMWgVZbYEBRYAFgAWCgGwOQkRaBUmAgAVtgQFGAkQOQ81thAJ5hAJk2YARhAa9WW2EBKlZbYEBRkBUVgVJgIAFhAIJWW2EAnmEAvDZgBGEBr1ZbYACQgVJgIIGQUmBAkCBUYP8WkFZbYAFUYAFgAWCgGwMWMxRhARxXYEBRYkYbzWDlG4FSYCBgBIIBUmAJYCSCAVJoNze6EDe7tzK5YLkbYESCAVJgZAFbYEBRgJEDkP1bYAFUYAFgAWCgGwMW/1tgAVRgAJBgAWABYKAbAxYzFGEBc1dgQFFiRhvNYOUbgVJgIGAEggFSYAlgJIIBUmg3N7oQN7u3MrlguRtgRIIBUmBkAWEBE1ZbYACCgVJgIIGQUmBAkCBUYP8WFWEBkldQYAGRkFBWW1BgAJCBUmAggZBSYECBIIBUYP8ZFmABF5BVkFZbYABgIIKEAxIVYQHBV2AAgP1bUDWRkFBW/qJkaXBmc1giEiAmjF/tE12k0guM8pcZUmg65fOfIOGnXSXA2v6hMNz+VWRzb2xjQwAICgAz"
            },
            {
                "key": "BwPgwCG9gEDVTmHxB8hqDX7rfCv4sw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPidktZ1Z81M6wwyDnRjKKpuXoPKA==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEBFldgADVg4ByAY3YuOmMRYQCiV4Bj2nQiKBFhAHFXgGPadCIoFGECQ1eAY+eM6pIUYQJWV4Bj8v3jixRhAmlXgGP1Z9yGFGECfFeAY/jIdl4UYQKPV2AAgP1bgGN2LjpjFGEB+1eAY32gqHcUYQIOV4BjjaXLWxRhAh9XgGPI9cLYFGECMFdgAID9W4BjSG/wzRFhAOlXgGNIb/DNFGEBhleAY1crbAUUYQGbV4BjY6787BRhAc1XgGNkJWZrFGEB4FeAY3FQGKYUYQHzV2AAgP1bgGMO37qlFGEBG1eAYyr4lvsUYQEwV4BjLYjQzxRhAWBXgGM93P+2FGEBc1dbYACA/VthAS5hASk2YARhTb9WW2EColZbAFtgalRhAUOQYAFgAWCgGwMWgVZbYEBRYAFgAWCgGwOQkRaBUmAgAVtgQFGAkQOQ81thAS5hAW42YARhTkRWW2ELFFZbYQEuYQGBNmAEYU6NVlthGM1WW2EBjmEZtlZbYEBRYQFXkZBhT05WW2EBvWEBqTZgBGFPgVZbYGVUYAFgAWCgGwORghaRFhSQVltgQFGQFRWBUmAgAWEBV1ZbYQEuYQHbNmAEYU+wVlthGkRWW2BpVGEBQ5BgAWABYKAbAxaBVlthAS5hIbBWW2EBLmECCTZgBGFP71ZbYSIFVltgZVRgAWABYKAbAxZhAUNWW2AzVGABYAFgoBsDFmEBQ1ZbYQEuYQI+NmAEYVBkVlthJ79WW2EBLmECUTZgBGFPgVZbYTICVltga1RhAUOQYAFgAWCgGwMWgVZbYQEuYQJ3NmAEYU+BVlthMldWW2EBLmECijZgBGFQxlZbYTMOVlthAS5hAp02YARhUSlWW2FGgVZbYABgaIFhArdggIgBYGCJAWFPgVZbYAFgAWCgGwOQgRaCUmAgggGSkJJSYEABYAAgVBaQUGEC5IFggIcBNWFHwFZbYAFgAWCgGwOBFmMJXqezYQMDYICIAWBgiQFhT4FWW4dggAE1YEBRg2P/////FmDgG4FSYAQBYQMlkpGQYVGFVltgIGBAUYCDA4FgAIda8RWAFWEDRFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhA2iRkGFRnlZbUGBAUWNwoIIxYOAbgVIwYASCAVJgAJBgAWABYKAbA4MWkGNwoIIxkGAkAWAgYEBRgIMDgYZa+hWAFWEDsFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhA9SRkGFRwFZbkFBgAGED6GCAiAFgYIkBYU+BVltgAWABYKAbAxZjzCsn12CAiQE1YQQLYMCLAWCgjAFhUdlWW2BAUWABYAFg4BsDGWDghZAbFoFSYASBAZKQklJgDwtgJIIBUmBEAWAgYEBRgIMDgYZa+hWAFWEET1c9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhBHORkGFRwFZbkFCAh2DAATURFWEE+FdhBKZhBJVhAQCJAWDgigFhT4FWW2ABYAFgoBsDhRaQhGFIfFZbYACAUWAgYVS1gzmBUZFSYQTFYICJAWBgigFhT4FWW4RhBNdhAQCLAWDgjAFhT4FWW4VgQFFhBOiUk5KRkGFR/FZbYEBRgJEDkKFQUFBhCw5WW2EFCGCAiAFgYIkBYU+BVltgAWABYKAbAxZjGk0B0mCAiQE1YQUrYMCLAWCgjAFhUdlWW2BAUWABYAFg4BsDGWDghZAbFoFSYASBAZKQklJgDwtgJIIBUmAAYESCAVJgZAFgAGBAUYCDA4FgAIeAOxWAFWEFc1dgAID9W1Ba8RWAFWEFh1c9YACAPj1gAP1bUFBQUFBQUGAAYQXchWCgAWAggQGQYQWmkZBhUdlWW2APC2BnYABhBb1ggIoBYGCLAWFPgVZbYAFgAWCgGwMWgVJgIIEBkZCRUmBAAWAAIJBhSNdWW2BAUWNwoIIxYOAbgVIwYASCAVJgAWABYKAbA5GQkRaQY3CggjGQYCQBYCBgQFGAgwOBhlr6FYAVYQYiVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEGRpGQYVHAVluQUGAAYQZXYCCHAYdhT4FWW2ABYAFgoBsDFmPMKyfXg2EGdmBAigFgIIsBYVHZVltgQFFgAWABYOAbAxlg4IWQGxaBUmAEgQGSkJJSYA8LYCSCAVJgRAFgIGBAUYCDA4GGWvoVgBVhBrpXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQbekZBhUcBWW5BQgIZgQAE1ERVhB6xXYQc4YQcAYQEAiAFg4IkBYU+BVluDYQcoYQcUYECLAWAgjAFhUdlWW2APC2BnYABhBb1gII4BjmFPgVZbYAFgAWCgGwMWkZBhSHxWW2AAgFFgIGFUtYM5gVGRUmEHVGAgiAGIYU+BVlthB3thB2dgQIoBYCCLAWFR2VZbYA8LYGdgAGEFvWAgjQGNYU+BVlthB4xhAQCKAWDgiwFhT4FWW4VgQFFhB52Uk5KRkGFR/FZbYEBRgJEDkKFQUGELDlZbYQfTYQe/YECIAWAgiQFhUdlWW2APC2BnYABhBb1gIIsBi2FPgVZbYAFgAWCgGwMWYwlep7NhB+5gIIkBiWFPgVZbhGBAUYNj/////xZg4BuBUmAEAWEIDJKRkGFRhVZbYCBgQFGAgwOBYACHWvEVgBVhCCtXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQhPkZBhUZ5WW1BhCF1gIIcBh2FPgVZbYAFgAWCgGwMWYxpNAdKDYQh8YECKAWAgiwFhUdlWW2BAUWABYAFg4BsDGWDghZAbFoFSYASBAZKQklJgDwtgJIIBUmAAYESCAVJgZAFgAGBAUYCDA4FgAIeAOxWAFWEIxFdgAID9W1Ba8RWAFWEI2Fc9YACAPj1gAP1bUFBQUGAAYQkIh2AgAWAggQGQYQj0kZBhUdlWW2APC2BnYABhBb1gIIwBjGFPgVZbYEBRY3CggjFg4BuBUjBgBIIBUmABYAFgoBsDkZCRFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhCU5XPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQlykZBhUcBWW5BQgxVhCuJXYQmNYQj0YECJAWAgigFhUdlWW2BqVGBAUWMJXqezYOAbgVJgAWABYKAbA5KDFpJjCV6ns5JhCcCSkRaQhZBgBAFhUYVWW2AgYEBRgIMDgWAAh1rxFYAVYQnfVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEKA5GQYVGeVltQYECAUWBggQGCUmABYAFgoBsDgIkWglKHgRZgIICEAZGQkVKChAGIkFJgalSSk5KQkRaRY0UcdjWRYQpkkWEKUJGQjQGQjQFhUdlWW2APC2BnYABhBb1gII8Bj2FPgVZbhDBhCndhAQCOAWDgjwFhT4FWW4ZgQFGGY/////8WYOAbgVJgBAFhCpiVlJOSkZBhUiZWW2AgYEBRgIMDgWAAh1rxFYAVYQq3Vz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEK25GQYVHAVltQUGELClZbYQsKYQr2YQEAiQFg4IoBYU+BVluCYQcoYQpQYECMAWAgjQFhUdlWW1BQUFtQUFBQVltgAFtgBYEQFWEMTldgAIKCYAWBEGELNFdhCzRhUnNWW2AgAgE1ERVhDDxXYQuDg4JgBYEQYQtUV2ELVGFSc1ZbYCACAWAggQGQYQtnkZBhT4FWW4ODYAWBEGELeVdhC3lhUnNWW2AgAgE1YUfAVluCgWAFgRBhC5VXYQuVYVJzVltgIAIBYCCBAZBhC6iRkGFPgVZbYAFgAWCgGwMWYwlep7NhC8NgIIcBh2FPgVZbhIRgBYEQYQvVV2EL1WFSc1ZbYCACATVgQFGDY/////8WYOAbgVJgBAFhC/eSkZBhUYVWW2AgYEBRgIMDgWAAh1rxFYAVYQwWVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEMOpGQYVGeVltQW4BhDEaBYVKJVluRUFBhCxdWW1BgAGEMXmAghQGFYU+BVltgAWABYKAbAxZjft6JxYNgAWBAUYNj/////xZg4BuBUmAEAWEMjJKRkGFSslZbYCBgQFGAgwOBhlr6FYAVYQypVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEMzZGQYVHAVluQUICEYGABNREVYQ3zV2AAW2AFgRAVYQ3sV2AAg4JgBYEQYQz7V2EM+2FSc1ZbYCACATURFWEN2ldhDVdhDRthAUCHAWEBIIgBYU+BVluEg2AFgRBhDS1XYQ0tYVJzVltgIAIBNYaEYAWBEGENRFdhDURhUnNWW2AgAgFgIIEBkGEHKJGQYU+BVltgAIBRYCBhVLWDOYFRkVJhDXNgIIcBh2FPgVZbhYNgBYEQYQ2FV2ENhWFSc1ZbYCACAWAggQGQYQ2YkZBhT4FWW2ENqmEBQIkBYQEgigFhT4FWW4aFYAWBEGENvFdhDbxhUnNWW2AgAgE1YEBRYQ3RlJOSkZBhUfxWW2BAUYCRA5ChW4BhDeSBYVKJVluRUFBhDN5WW1BQUFBQVlthDgBgIIUBhWFPgVZbYAFgAWCgGwMWY4RzhJmDYABgQFGDY/////8WYOAbgVJgBAFhDi6SkZBhUspWW2AAYEBRgIMDgWAAh4A7FYAVYQ5IV2AAgP1bUFrxFYAVYQ5cVz1gAIA+PWAA/VtQYQ5zk1BQYMCGAZFQUGCghQFhUdlWW2APC2EOhmCghQFggIYBYVHZVltgDwsUYRNFV2AAYGiBYQ6gYCCHAYdhT4FWW2ABYAFgoBsDkIEWglJgIICDAZOQk1JgQJGCAWAAIFQWklCCkWMJXqezkWEO2ZGQiAGQiAFhT4FWW2BAUWNwoIIxYOAbgVIwYASCAVJgAWABYKAbA4UWkGNwoIIxkGAkAWAgYEBRgIMDgYZa+hWAFWEPHVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhD0GRkGFRwFZbYEBRg2P/////FmDgG4FSYAQBYQ9ekpGQYVGFVltgIGBAUYCDA4FgAIda8RWAFWEPfVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhD6GRkGFRnlZbUGBAUWNwoIIxYOAbgVIwYASCAVJgAJBgAWABYKAbA4MWkGNwoIIxkGAkAWAgYEBRgIMDgYZa+hWAFWEP6Vc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhEA2RkGFRwFZbkFBgAGEQIWBAhwFgIIgBYU+BVltgAWABYKAbAxZjXg1EP2EQP2CgiQFggIoBYVHZVlthEE9gwIoBYKCLAWFR2VZbYEBRYAFgAWDgGwMZYOCFkBsWgVJgD5KDC2AEggFSkQtgJIIBUmBEgQGFkFJgZAFgIGBAUYCDA4GGWvoVgBVhEJtXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRC/kZBhUcBWW5BQgIZgwAE1ERVhEptXYRGgYRDiYQFAiAFhASCJAWFPgVZbYREMYRD1YKCKAWCAiwFhUdlWW2APC2BnYABhBb1gQI0BYCCOAWFPgVZbYEBRY3CggjFg4BuBUjBgBIIBUmABYAFgoBsDkZCRFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhEVJXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRF2kZBhUcBWW2EHKGERiWCgiwFggIwBYVHZVltgDwtgZ2AAYQW9YECOAWAgjwFhT4FWW2AAgFFgIGFUtYM5gVGRUmERv2BAiAFgIIkBYU+BVlthEdJhEPVgoIoBYICLAWFR2VZbYRHkYQFAigFhASCLAWFPgVZbYRIRYRH3YKCMAWCAjQFhUdlWW2APC2BnYACNYCABYCCBAZBhBb2RkGFPgVZbYEBRY3CggjFg4BuBUjBgBIIBUmABYAFgoBsDkZCRFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhEldXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRJ7kZBhUcBWW2BAUWESi5STkpGQYVH8VltgQFGAkQOQoVBQUFBQUFZbYRKrYECHAWAgiAFhT4FWW2ABYAFgoBsDFmM98CEkYRLJYKCJAWCAigFhUdlWW2ES2WDAigFgoIsBYVHZVltgQFFgAWABYOAbAxlg4IWQGxaBUmAPkoMLYASCAVKRC2AkggFSYESBAYWQUmBkgQGEkFJghAFgAGBAUYCDA4FgAIeAOxWAFWETKVdgAID9W1Ba8RWAFWETPVc9YACAPj1gAP1bUFBQUFBQUFtgAGBogWETWmBghwFgQIgBYU+BVltgAWABYKAbA5CBFoJSYCCCAZKQklJgQJCBAWAAIFSQkRaRUIGQYwlep7OQYROVkGBgiAGQiAFhT4FWW2BAUWNwoIIxYOAbgVIwYASCAVJgAWABYKAbA4UWkGNwoIIxkGAkAWAgYEBRgIMDgYZa+hWAFWET2Vc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhE/2RkGFRwFZbYEBRg2P/////FmDgG4FSYAQBYRQakpGQYVGFVltgIGBAUYCDA4FgAIda8RWAFWEUOVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhFF2RkGFRnlZbUGBAUWNwoIIxYOAbgVIwYASCAVJgAJBgAWABYKAbA4MWkGNwoIIxkGAkAWAgYEBRgIMDgYZa+hWAFWEUpVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhFMmRkGFRwFZbkFBgAGEU3WBghwFgQIgBYU+BVltgAWABYKAbAxZjzCsn14NhFP1hAQCKAWDgiwFhUdlWW2BAUWABYAFg4BsDGWDghZAbFoFSYASBAZKQklJgDwtgJIIBUmBEAWAgYEBRgIMDgYZa+hWAFWEVQVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhFWWRkGFRwFZbkFCAhmEBAAE1ERVhFcxXYRWJYQSVYQFAiAFhASCJAWFPgVZbYACAUWAgYVS1gzmBUZFSYRWoYGCIAWBAiQFhT4FWW4RhFbthAUCKAWEBIIsBYU+BVluFYEBRYRKLlJOSkZBhUfxWW2EV3GBghwFgQIgBYU+BVltgAWABYKAbAxZjGk0B0oNhFfxhAQCKAWDgiwFhUdlWW2BAUWABYAFg4BsDGWDghZAbFoFSYASBAZKQklJgDwtgJIIBUmAAYESCAVJgZAFgAGBAUYCDA4FgAIeAOxWAFWEWRFdgAID9W1Ba8RWAFWEWWFc9YACAPj1gAP1bUFBQUFBQUGAAYRaOhGDgAWAggQGQYRZ3kZBhUdlWW2APC2BnYABhBb1gYIkBYECKAWFPgVZbYEBRY3CggjFg4BuBUjBgBIIBUmABYAFgoBsDkZCRFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhFtRXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRb4kZBhUcBWW5BQYQGghAE1FWEYo1dhFxlhFndhAQCGAWDghwFhUdlWW2BqVGBAUWMJXqezYOAbgVJgAWABYKAbA5KDFpJjCV6ns5JhF0ySkRaQhZBgBAFhUYVWW2AgYEBRgIMDgWAAh1rxFYAVYRdrVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEXj5GQYVGeVltQYABgQFGAYGABYEBSgIZhAWABYCCBAZBhF7GRkGFPgVZbYAFgAWCgGwMWgVJgIAFhF9FhAaCIAWEBgIkBYU+BVltgAWABYKAbA5CBFoJSYQGgiAE1YCCQkgGRkJFSYGpUkZJQFmNFHHY1YRgkYRgNYQEAiQFg4IoBYVHZVltgDwtgZ2AAYQW9YGCMAWBAjQFhT4FWW4QwYRg4YQFAiwFhASCMAWFPgVZbhmBAUYZj/////xZg4BuBUmAEAWEYWZWUk5KRkGFSJlZbYCBgQFGAgwOBYACHWvEVgBVhGHhXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRickZBhUcBWW1BQYQsOVlthCw5hGLhhAUCGAWEBIIcBYU+BVluCYQcoYRgNYQEAiQFg4IoBYVHZVlthGNVhSOxWW2ABYAFgoBsDFmEY8GAzVGABYAFgoBsDFpBWW2ABYAFgoBsDFhRhGR9XYEBRYkYbzWDlG4FSYAQBYRkWkGFS4lZbYEBRgJEDkP1bYABbgYEQFWEZhVdhGXKDg4OBgRBhGT9XYRk/YVJzVluQUGAgAgFgIIEBkGEZVJGQYU+BVltgAWABYKAbA4cWYACQgVJgZ2AgUmBAkCCQYUkgVltQgGEZfYFhUolWW5FQUGEZIlZbUFBQYAFgAWCgGwORghZgAJCBUmBoYCBSYECQIIBUYAFgAWCgGwMZFpGQkhYXkFVWW2BmgFRhGcOQYVMXVluAYB8BYCCAkQQCYCABYEBRkIEBYEBSgJKRkIGBUmAgAYKAVGEZ75BhUxdWW4AVYRo8V4BgHxBhGhFXYQEAgINUBAKDUpFgIAGRYRo8VluCAZGQYABSYCBgACCQW4FUgVKQYAEBkGAgAYCDEWEaH1eCkANgHxaCAZFbUFBQUFCBVltgAFtgBYEQFWEbT1dgAIKCYAWBEGEaZFdhGmRhUnNWW2AgAgE1ERVhGz1XYRqEg4JgBYEQYQtUV2ELVGFSc1ZbgoFgBYEQYRqWV2EalmFSc1ZbYCACAWAggQGQYRqpkZBhT4FWW2ABYAFgoBsDFmMJXqezYRrEYCCHAYdhT4FWW4SEYAWBEGEa1ldhGtZhUnNWW2AgAgE1YEBRg2P/////FmDgG4FSYAQBYRr4kpGQYVGFVltgIGBAUYCDA4FgAIda8RWAFWEbF1c9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhGzuRkGFRnlZbUFuAYRtHgWFSiVZbkVBQYRpHVltQYABhG19gIIUBhWFPgVZbYAFgAWCgGwMWY37eicWDYAFgQFGDY/////8WYOAbgVJgBAFhG42SkZBhUrJWW2AgYEBRgIMDgYZa+hWAFWEbqlc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhG86RkGFRwFZbkFCAhGAgATURFWEcrVdgAFtgBYEQFWEN7FdgAIOCYAWBEGEb/FdhG/xhUnNWW2AgAgE1ERVhHJtXYRwaYQ0bYMCHAWCgiAFhT4FWW2AAgFFgIGFUtYM5gVGRUmEcNmAghwGHYU+BVluFg2AFgRBhHEhXYRxIYVJzVltgIAIBYCCBAZBhHFuRkGFPgVZbYRxrYMCJAWCgigFhT4FWW4aFYAWBEGEcfVdhHH1hUnNWW2AgAgE1YEBRYRySlJOSkZBhUfxWW2BAUYCRA5ChW4BhHKWBYVKJVluRUFBhG99WW2EcumAghQGFYU+BVltgAWABYKAbAxZjhHOEmYNgAGBAUYNj/////xZg4BuBUmAEAWEc6JKRkGFSylZbYABgQFGAgwOBYACHgDsVgBVhHQJXYACA/VtQWvEVgBVhHRZXPWAAgD49YAD9W1BgaJJQYACRUGEdLpBQYCCHAYdhT4FWW2ABYAFgoBsDkIEWglJgIIIBkpCSUmBAAWAAIFQWYwlep7NhHWBggIcBYGCIAWFPgVZbYGhgAGEdcWAgigGKYU+BVltgAWABYKAbA5CBFoJSYCCCAZKQklJgQJCBAWAAIFSQUWNwoIIxYOAbgVIwYASCAVKRFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhHcpXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYR3ukZBhUcBWW2BAUYNj/////xZg4BuBUmAEAWEeC5KRkGFRhVZbYCBgQFGAgwOBYACHWvEVgBVhHipXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYR5OkZBhUZ5WW1BhHldhTNVWW2BoYABhHmhgIIgBiGFPgVZbYAFgAWCgGwOQgRaCUmAgggGSkJJSYECQgQFgACBUkFFjcKCCMWDgG4FSMGAEggFSkRaQY3CggjGQYCQBYCBgQFGAgwOBhlr6FYAVYR7BVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEe5ZGQYVHAVluBhmBAATVgA4EQYR77V2Ee+2FSc1ZbYCACAVJgAGEfEmCAhwFgYIgBYU+BVltgAWABYKAbAxZjOIPhGYNgAWBAUYNj/////xZg4BuBUmAEAWEfQJKRkGFTb1ZbYCBgQFGAgwOBhlr6FYAVYR9dVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEfgZGQYVHAVluQUICGYIABNREVYSCAV2Ef9WEfomDAiAFgoIkBYU+BVluDiGBAATVgA4EQYR+4V2EfuGFSc1ZbYCACAVFgaGAAYR/RYICMAWBgjQFhT4FWW2ABYAFgoBsDkIEWglJgIIIBkpCSUmBAAWAAIFQWkZBhSHxWW2AAgFFgIGFUtYM5gVGRUmEgFGCAiAFgYIkBYU+BVltgaGAAYSAoYICLAWBgjAFhT4FWW2ABYAFgoBsDkIEWglJgIIIBkpCSUmBAAWAAIFQWYSBVYMCKAWCgiwFhT4FWW4WKYEABNWADgRBhIGtXYSBrYVJzVltgIAIBUWBAUWESi5STkpGQYVH8VlthIJBggIcBYGCIAWFPgVZbYAFgAWCgGwMWY0UVzvODYABgQFGDY/////8WYOAbgVJgBAFhIL6SkZBhU4xWW2AAYEBRgIMDgWAAh4A7FYAVYSDYV2AAgP1bUFrxFYAVYSDsVz1gAIA+PWAA/VtQUFBQYABgaGAAiGBgAWAggQGQYSEJkZBhT4FWW2ABYAFgoBsDkIEWglJgIIIBkpCSUmBAkIEBYAAgVJBRY3CggjFg4BuBUjBgBIIBUpEWkGNwoIIxkGAkAWAgYEBRgIMDgYZa+hWAFWEhYlc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhIYaRkGFRwFZbkFBhCwphIZtgwIkBYKCKAWFPgVZbgmBoYABhH9FggI0BYGCOAWFPgVZbYSG4YUjsVltgAWABYKAbAxZhIdNgM1RgAWABYKAbAxaQVltgAWABYKAbAxYUYSH5V2BAUWJGG81g5RuBUmAEAWEZFpBhUuJWW2EiA2AAYUk1VltWW2EiDWFI7FZbYGtUYAFgAWCgGwOQgRaRFhRhIidXYACA/VthIi9hTPNWW2AAW2AFgRAVYSSWV2BqVGABYAFgoBsDFmO8pzgjhoNgBYEQYSJeV2EiXmFSc1ZbYCACAWAggQGQYSJxkZBhT4FWW2BAUWDgg5AbYAFgAWDgGwMZFoFSYAFgAWCgGwOQkRZgBIIBUmAkAWAgYEBRgIMDgYZa+hWAFWEitVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhItmRkGFTp1ZbgoJgBYEQYSLrV2Ei62FSc1ZbYAFgAWCgGwOQkhZgIJKQkgIBUmAAhIJgBYEQYSMSV2EjEmFSc1ZbYCACATURFWEkhFdgalRgAWABYKAbAxZj0yqZHoSDYAWBEGEjQFdhI0BhUnNWW2AgAgE1h4RgBYEQYSNXV2EjV2FSc1ZbYCACAWAggQGQYSNqkZBhT4FWW4eFYAWBEGEjfFdhI3xhUnNWW2AgAgE1MGBAUYVj/////xZg4BuBUmAEAWEjoZSTkpGQYVPEVltgAGBAUYCDA4FgAIeAOxWAFWEju1dgAID9W1Ba8RWAFWEjz1c9YACAPj1gAP1bUFBQUIGBYAWBEGEj5VdhI+VhUnNWW2AgAgFRYAFgAWCgGwMWYwlep7OIYAABYCCBAZBhJAuRkGFPgVZbhoRgBYEQYSQdV2EkHWFSc1ZbYCACATVgQFGDY/////8WYOAbgVJgBAFhJD+SkZBhUYVWW2AgYEBRgIMDgWAAh1rxFYAVYSReVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEkgpGQYVGeVltQW4BhJI6BYVKJVluRUFBhIjJWW1BgAGEkpmAgiAGIYU+BVltgAWABYKAbAxZjft6JxYVgAWBAUYNj/////xZg4BuBUmAEAWEk1JKRkGFSslZbYCBgQFGAgwOBhlr6FYAVYSTxVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGElFZGQYVHAVluQUICHYEABNREVYSaeV2AAW2AFgRAVYSaWV2AAhYJgBYEQYSVDV2ElQ2FSc1ZbYCACATURFWEmhFdgalRgAWABYKAbAxZjlQASW4WDYAWBEGElcVdhJXFhUnNWW2AgAgE1iWAAAWAggQGQYSWJkZBhT4FWW2ElmWBAjAFgII0BYU+BVltgQIwBNWElrmCAjgFgYI8BYVPrVluNYIABNY5goAE1YEBRiGP/////FmDgG4FSYAQBYSXal5aVlJOSkZBhVA5WW2AAYEBRgIMDgWAAh4A7FYAVYSX0V2AAgP1bUFrxFYAVYSYIVz1gAIA+PWAA/VtQYACAUWAgYVS1gzmBUZFSklBhJiqRUFBgIIoBimFPgVZbhINgBYEQYSY8V2EmPGFSc1ZbYCACAVGKYCABYCCBAZBhJlSRkGFPgVZbiIVgBYEQYSZmV2EmZmFSc1ZbYCACATVgQFFhJnuUk5KRkGFR/FZbYEBRgJEDkKFbgGEmjoFhUolWW5FQUGElJlZbUFBQYQ3sVlthJqtgIIgBiGFPgVZbYAFgAWCgGwMWY4RzhJmFYABgQFGDY/////8WYOAbgVJgBAFhJtmSkZBhUspWW2AAYEBRgIMDgWAAh4A7FYAVYSbzV2AAgP1bUFrxFYAVYScHVz1gAIA+PWAA/VtQYQsKklBhJyCRUFBgQIkBYCCKAWFPgVZbYGhgAGEnMWAgjAGMYU+BVltgAWABYKAbA5CBFoJSYCCCAZKQklJgQJCBAWAAIFSQUWNwoIIxYOAbgVIwYASCAVKRFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhJ4pXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYSeukZBhUcBWW2BoYABhH9FgII0BjWFPgVZbYSfHYUjsVltga1RgAWABYKAbA5CBFpEWFGEn4VdgAID9W2En6WFM81ZbYABbYAWBEBVhKlBXYGpUYAFgAWCgGwMWY7ynOCOGg2AFgRBhKBhXYSgYYVJzVltgIAIBYCCBAZBhKCuRkGFPgVZbYEBRYOCDkBtgAWABYOAbAxkWgVJgAWABYKAbA5CRFmAEggFSYCQBYCBgQFGAgwOBhlr6FYAVYShvVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEok5GQYVOnVluCgmAFgRBhKKVXYSilYVJzVltgAWABYKAbA5CSFmAgkpCSAgFSYACEgmAFgRBhKMxXYSjMYVJzVltgIAIBNREVYSo+V2BqVGABYAFgoBsDFmPTKpkehINgBYEQYSj6V2Eo+mFSc1ZbYCACATWHhGAFgRBhKRFXYSkRYVJzVltgIAIBYCCBAZBhKSSRkGFPgVZbh4VgBYEQYSk2V2EpNmFSc1ZbYCACATUwYEBRhWP/////FmDgG4FSYAQBYSlblJOSkZBhU8RWW2AAYEBRgIMDgWAAh4A7FYAVYSl1V2AAgP1bUFrxFYAVYSmJVz1gAIA+PWAA/VtQUFBQgYFgBYEQYSmfV2Epn2FSc1ZbYCACAVFgAWABYKAbAxZjCV6ns4hgAAFgIIEBkGEpxZGQYU+BVluGhGAFgRBhKddXYSnXYVJzVltgIAIBNWBAUYNj/////xZg4BuBUmAEAWEp+ZKRkGFRhVZbYCBgQFGAgwOBYACHWvEVgBVhKhhXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYSo8kZBhUZ5WW1BbgGEqSIFhUolWW5FQUGEn7FZbUGAAYSpgYCCIAYhhT4FWW2ABYAFgoBsDFmN+3onFhWABYEBRg2P/////FmDgG4FSYAQBYSqOkpGQYVKyVltgIGBAUYCDA4GGWvoVgBVhKqtXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYSrPkZBhUcBWW5BQgIdgIAE1ERVhLE1XYABbYAWBEBVhJpZXYACFgmAFgRBhKv1XYSr9YVJzVltgIAIBNREVYSw7V2BqVGABYAFgoBsDFmOVABJbhYNgBYEQYSsrV2ErK2FSc1ZbYCACATWJYAABYCCBAZBhK0ORkGFPgVZbYStTYECMAWAgjQFhT4FWW2BAjAE1YStoYICOAWBgjwFhU+tWW41ggAE1jmCgATVgQFGIY/////8WYOAbgVJgBAFhK5SXlpWUk5KRkGFUDlZbYABgQFGAgwOBYACHgDsVgBVhK65XYACA/VtQWvEVgBVhK8JXPWAAgD49YAD9W1BgAIBRYCBhVLWDOYFRkVKSUGEr5JFQUGAgigGKYU+BVluEg2AFgRBhK/ZXYSv2YVJzVltgIAIBUWEsC2DAjAFgoI0BYU+BVluIhWAFgRBhLB1XYSwdYVJzVltgIAIBNWBAUWEsMpSTkpGQYVH8VltgQFGAkQOQoVuAYSxFgWFSiVZbkVBQYSrgVlthLFpgIIgBiGFPgVZbYAFgAWCgGwMWY4RzhJmFYABgQFGDY/////8WYOAbgVJgBAFhLIiSkZBhUspWW2AAYEBRgIMDgWAAh4A7FYAVYSyiV2AAgP1bUFrxFYAVYSy2Vz1gAIA+PWAA/VtQYGiUUGAAk1BhLNCSUFBQYCCIAYhhT4FWW2ABYAFgoBsDkIEWglJgIIIBkpCSUmBAAWAAIFQWYwlep7NhLQJggIgBYGCJAWFPgVZbYGhgAGEtE2AgiwGLYU+BVltgAWABYKAbA5CBFoJSYCCCAZKQklJgQJCBAWAAIFSQUWNwoIIxYOAbgVIwYASCAVKRFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhLWxXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYS2QkZBhUcBWW2BAUYNj/////xZg4BuBUmAEAWEtrZKRkGFRhVZbYCBgQFGAgwOBYACHWvEVgBVhLcxXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYS3wkZBhUZ5WW1BhLflhTNVWW2BoYABhLgpgIIkBiWFPgVZbYAFgAWCgGwOQgRaCUmAgggGSkJJSYECQgQFgACBUkFFjcKCCMWDgG4FSMGAEggFSkRaQY3CggjGQYCQBYCBgQFGAgwOBhlr6FYAVYS5jVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEuh5GQYVHAVluBh2BAATVgA4EQYS6dV2EunWFSc1ZbYCACAVJgAGEutGCAiAFgYIkBYU+BVltgAWABYKAbAxZjOIPhGYNgAWBAUYNj/////xZg4BuBUmAEAWEu4pKRkGFTb1ZbYCBgQFGAgwOBhlr6FYAVYS7/Vz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEvI5GQYVHAVluQUICHYIABNREVYTDIV2AAW2AFgRAVYTAtV2AAhYJgBYEQYS9RV2EvUWFSc1ZbYCACATURFWEwG1dgalRgAWABYKAbAxZjlQASW4WDYAWBEGEvf1dhL39hUnNWW2AgAgE1iWAAAWAggQGQYS+XkZBhT4FWW2Evp2BAjAFgII0BYU+BVltgQIwBNWEvvGCAjgFgYI8BYVPrVluNYIABNY5goAE1YEBRiGP/////FmDgG4FSYAQBYS/ol5aVlJOSkZBhVA5WW2AAYEBRgIMDgWAAh4A7FYAVYTACV2AAgP1bUFrxFYAVYTAWVz1gAIA+PWAA/VtQUFBQW4BhMCWBYVKJVluRUFBhLzRWW1BgAIBRYCBhVLWDOYFRkVJhME1ggIkBYGCKAWFPgVZbYGhgAGEwYWCAjAFgYI0BYU+BVltgAWABYKAbA5CBFoJSYCCCAZKQklJgQAFgACBUFmEwjmDAiwFgoIwBYU+BVluFi2BAATVgA4EQYTCkV2EwpGFSc1ZbYCACAVFgQFFhMLmUk5KRkGFR/FZbYEBRgJEDkKFQUGEN7FZbYTDYYICIAWBgiQFhT4FWW2ABYAFgoBsDFmNFFc7zg2AAYEBRg2P/////FmDgG4FSYAQBYTEGkpGQYVOMVltgAGBAUYCDA4FgAIeAOxWAFWExIFdgAID9W1Ba8RWAFWExNFc9YACAPj1gAP1bUFBQUGAAYGhgAIlgYAFgIIEBkGExUZGQYU+BVltgAWABYKAbA5CBFoJSYCCCAZKQklJgQJCBAWAAIFSQUWNwoIIxYOAbgVIwYASCAVKRFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhMapXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYTHOkZBhUcBWW5BQYTH4YTHjYMCKAWCgiwFhT4FWW4JgaGAAYR/RYICOAWBgjwFhT4FWW1BQUFBQUFBQVlthMgphSOxWW2ABYAFgoBsDFmEyJWAzVGABYAFgoBsDFpBWW2ABYAFgoBsDFhRhMktXYEBRYkYbzWDlG4FSYAQBYRkWkGFS4lZbYTJUgWFJh1ZbUFZbYTJfYUjsVltgAWABYKAbAxZhMnpgM1RgAWABYKAbAxaQVltgAWABYKAbAxYUYTKgV2BAUWJGG81g5RuBUmAEAWEZFpBhUuJWW2ABYAFgoBsDgRZhMwVXYEBRYkYbzWDlG4FSYCBgBIIBUmAmYCSCAVJ/T3duYWJsZTogbmV3IG93bmVyIGlzIHRoZSB6ZXJvIGFgRIIBUmVkZHJlc3Ng0BtgZIIBUmCEAWEZFlZbYTJUgWFJNVZbYTMWYUjsVltga1RgAWABYKAbA5CBFpEWFGEzMFdgAID9W2EzOGFM81ZbYABbYAWBEBVhNZ9XYGpUYAFgAWCgGwMWY7ynOCOGg2AFgRBhM2dXYTNnYVJzVltgIAIBYCCBAZBhM3qRkGFPgVZbYEBRYOCDkBtgAWABYOAbAxkWgVJgAWABYKAbA5CRFmAEggFSYCQBYCBgQFGAgwOBhlr6FYAVYTO+Vz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEz4pGQYVOnVluCgmAFgRBhM/RXYTP0YVJzVltgAWABYKAbA5CSFmAgkpCSAgFSYACEgmAFgRBhNBtXYTQbYVJzVltgIAIBNREVYTWNV2BqVGABYAFgoBsDFmPTKpkehINgBYEQYTRJV2E0SWFSc1ZbYCACATWHhGAFgRBhNGBXYTRgYVJzVltgIAIBYCCBAZBhNHORkGFPgVZbh4VgBYEQYTSFV2E0hWFSc1ZbYCACATUwYEBRhWP/////FmDgG4FSYAQBYTSqlJOSkZBhU8RWW2AAYEBRgIMDgWAAh4A7FYAVYTTEV2AAgP1bUFrxFYAVYTTYVz1gAIA+PWAA/VtQUFBQgYFgBYEQYTTuV2E07mFSc1ZbYCACAVFgAWABYKAbAxZjCV6ns4hgAAFgIIEBkGE1FJGQYU+BVluGhGAFgRBhNSZXYTUmYVJzVltgIAIBNWBAUYNj/////xZg4BuBUmAEAWE1SJKRkGFRhVZbYCBgQFGAgwOBYACHWvEVgBVhNWdXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYTWLkZBhUZ5WW1BbgGE1l4FhUolWW5FQUGEzO1ZbUGAAYTWvYCCIAYhhT4FWW2ABYAFgoBsDFmN+3onFhWABYEBRg2P/////FmDgG4FSYAQBYTXdkpGQYVKyVltgIGBAUYCDA4GGWvoVgBVhNfpXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYTYekZBhUcBWW5BQgIdgYAE1ERVhN55XYABbYAWBEBVhJpZXYACFgmAFgRBhNkxXYTZMYVJzVltgIAIBNREVYTeMV2BqVGABYAFgoBsDFmOVABJbhYNgBYEQYTZ6V2E2emFSc1ZbYCACATWJYAABYCCBAZBhNpKRkGFPgVZbYTaiYECMAWAgjQFhT4FWW2BAjAE1YTa3YICOAWBgjwFhU+tWW41ggAE1jmCgATVgQFGIY/////8WYOAbgVJgBAFhNuOXlpWUk5KRkGFUDlZbYABgQFGAgwOBYACHgDsVgBVhNv1XYACA/VtQWvEVgBVhNxFXPWAAgD49YAD9W1BgAIBRYCBhVLWDOYFRkVKSUGE3M5FQUGAgigGKYU+BVluEg2AFgRBhN0VXYTdFYVJzVltgIAIBUWE3XGEBQIwBYQEgjQFhT4FWW4iFYAWBEGE3bldhN25hUnNWW2AgAgE1YEBRYTeDlJOSkZBhUfxWW2BAUYCRA5ChW4BhN5aBYVKJVluRUFBhNi9WW2E3q2AgiAGIYU+BVltgAWABYKAbAxZjhHOEmYVgAGBAUYNj/////xZg4BuBUmAEAWE32ZKRkGFSylZbYABgQFGAgwOBYACHgDsVgBVhN/NXYACA/VtQWvEVgBVhOAdXPWAAgD49YAD9W1BQUFBQUIRgoAFgIIEBkGE4IJGQYVHZVltgDwthODNgoIcBYICIAWFR2VZbYA8LFGE+E1dgAGBogWE4TWAgiQGJYU+BVltgAWABYKAbA5CBFoJSYCCAgwGTkJNSYECRggFgACBUFpJQgpFjCV6ns5FhOIaRkIoBkIoBYU+BVltgQFFjcKCCMWDgG4FSMGAEggFSYAFgAWCgGwOFFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhOMpXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYTjukZBhUcBWW2BAUYNj/////xZg4BuBUmAEAWE5C5KRkGFRhVZbYCBgQFGAgwOBYACHWvEVgBVhOSpXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYTlOkZBhUZ5WW1BgQFFjcKCCMWDgG4FSMGAEggFSYACQYAFgAWCgGwODFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhOZZXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYTm6kZBhUcBWW5BQYTnMYECIAWAgiQFhT4FWW2ABYAFgoBsDFmNeDUQ/YTnqYKCKAWCAiwFhUdlWW2E5+mDAiwFgoIwBYVHZVltgQFFgAWABYOAbAxlg4IWQGxaBUmAPkoMLYASCAVKRC2AkggFSYESBAYSQUmBkAWAgYEBRgIMDgYZa+pJQUFCAFWE6YldQYECAUWAfPZCBAWAfGRaCAZCSUmE6X5GBAZBhUcBWW2ABW2E7YldgAFtgBYEQFWEmlldgAIWCYAWBEGE6hldhOoZhUnNWW2AgAgE1ERVhO1BXYGpUYAFgAWCgGwMWY5UAEluFg2AFgRBhOrRXYTq0YVJzVltgIAIBNYlgAAFgIIEBkGE6zJGQYU+BVlthOtxgQIwBYCCNAWFPgVZbYECMATVhOvFggI4BYGCPAWFT61ZbjWCAATWOYKABNWBAUYhj/////xZg4BuBUmAEAWE7HZeWlZSTkpGQYVQOVltgAGBAUYCDA4FgAIeAOxWAFWE7N1dgAID9W1Ba8RWAFWE7S1c9YACAPj1gAP1bUFBQUFuAYTtagWFSiVZbkVBQYTppVluAiGDAATURFWE9aVdgAFtgBYEQFWE8bVdgAIaCYAWBEGE7jldhO45hUnNWW2AgAgE1ERVhPFtXYGpUYAFgAWCgGwMWY5UAEluGg2AFgRBhO7xXYTu8YVJzVltgIAIBNYpgAAFgIIEBkGE71JGQYU+BVlthO+RgQI0BYCCOAWFPgVZbjGBAATWNYGABYCCBAZBhO/yRkGFT61ZbjmCAATWPYKABNWBAUYhj/////xZg4BuBUmAEAWE8KJeWlZSTkpGQYVQOVltgAGBAUYCDA4FgAIeAOxWAFWE8QldgAID9W1Ba8RWAFWE8Vlc9YACAPj1gAP1bUFBQUFuAYTxlgWFSiVZbkVBQYTtxVltQYACAUWAgYVS1gzmBUZFSYTyNYECKAWAgiwFhT4FWW2E8oGER92CgjAFggI0BYVHZVlthPLJhAUCMAWEBII0BYU+BVlthPN9hPMVgoI4BYICPAWFR2VZbYA8LYGdgAI9gIAFgIIEBkGEFvZGQYU+BVltgQFFjcKCCMWDgG4FSMGAEggFSYAFgAWCgGwORkJEWkGNwoIIxkGAkAWAgYEBRgIMDgYZa+hWAFWE9JVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhPUmRkGFRwFZbYEBRYT1ZlJOSkZBhUfxWW2BAUYCRA5ChUFBQYQ3sVlthPXlgQIkBYCCKAWFPgVZbYAFgAWCgGwMWYz3wISRhPZdgoIsBYICMAWFR2VZbYT2nYMCMAWCgjQFhUdlWW2BAUWABYAFg4BsDGWDghZAbFoFSYA+SgwtgBIIBUpELYCSCAVJgRIEBhZBSYGSBAYSQUmCEAWAAYEBRgIMDgWAAh4A7FYAVYT33V2AAgP1bUFrxFYAVYT4LVz1gAIA+PWAA/VtQUFBQUFBQW2AAYGiBYT4oYGCJAWBAigFhT4FWW2ABYAFgoBsDkIEWglJgIIIBkpCSUmBAkIEBYAAgVJCRFpFQgZBjCV6ns5BhPmOQYGCKAZCKAWFPgVZbYEBRY3CggjFg4BuBUjBgBIIBUmABYAFgoBsDhRaQY3CggjGQYCQBYCBgQFGAgwOBhlr6FYAVYT6nVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGE+y5GQYVHAVltgQFGDY/////8WYOAbgVJgBAFhPuiSkZBhUYVWW2AgYEBRgIMDgWAAh1rxFYAVYT8HVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGE/K5GQYVGeVltQYEBRY3CggjFg4BuBUjBgBIIBUmAAkGABYAFgoBsDgxaQY3CggjGQYCQBYCBgQFGAgwOBhlr6FYAVYT9zVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGE/l5GQYVHAVluQUGE/qWBgiAFgQIkBYU+BVltgAWABYKAbAxZjzCsn14JhP8lhAQCLAWDgjAFhUdlWW2BAUWABYAFg4BsDGWDghZAbFoFSYASBAZKQklJgDwtgJIIBUmBEAWAgYEBRgIMDgYZa+pJQUFCAFWFAKVdQYECAUWAfPZCBAWAfGRaCAZCSUmFAJpGBAZBhUcBWW2ABW2FBL1dgAFtgBYEQFWFBKVdgAIWCYAWBEGFATVdhQE1hUnNWW2AgAgE1ERVhQRdXYGpUYAFgAWCgGwMWY5UAEluFg2AFgRBhQHtXYUB7YVJzVltgIAIBNYlgAAFgIIEBkGFAk5GQYU+BVlthQKNgQIwBYCCNAWFPgVZbYECMATVhQLhggI4BYGCPAWFT61ZbjWCAATWOYKABNWBAUYhj/////xZg4BuBUmAEAWFA5JeWlZSTkpGQYVQOVltgAGBAUYCDA4FgAIeAOxWAFWFA/ldgAID9W1Ba8RWAFWFBElc9YACAPj1gAP1bUFBQUFuAYUEhgWFSiVZbkVBQYUAwVltQYUKBVluAiGEBAAE1ERVhQn9XYABbYAWBEBVhQjtXYACGgmAFgRBhQVxXYUFcYVJzVltgIAIBNREVYUIpV2BqVGABYAFgoBsDFmOVABJbhoNgBYEQYUGKV2FBimFSc1ZbYCACATWKYAABYCCBAZBhQaKRkGFPgVZbYUGyYECNAWAgjgFhT4FWW4xgQAE1jWBgAWAggQGQYUHKkZBhU+tWW45ggAE1j2CgATVgQFGIY/////8WYOAbgVJgBAFhQfaXlpWUk5KRkGFUDlZbYABgQFGAgwOBYACHgDsVgBVhQhBXYACA/VtQWvEVgBVhQiRXPWAAgD49YAD9W1BQUFBbgGFCM4FhUolWW5FQUGFBP1ZbUGAAgFFgIGFUtYM5gVGRUmFCW2BgigFgQIsBYU+BVluEYUJuYQFAjAFhASCNAWFPgVZbhWBAUWE9WZSTkpGQYVH8VltQW2FCkWBgiAFgQIkBYU+BVltgAWABYKAbAxZjGk0B0oJhQrFhAQCLAWDgjAFhUdlWW2BAUWABYAFg4BsDGWDghZAbFoFSYASBAZKQklJgDwtgJIIBUmAAYESCAVJgZAFgAGBAUYCDA4FgAIeAOxWAFWFC+VdgAID9W1Ba8ZJQUFCAFWFDCldQYAFbYUQQV2AAW2AFgRAVYUQKV2AAhYJgBYEQYUMuV2FDLmFSc1ZbYCACATURFWFD+FdgalRgAWABYKAbAxZjlQASW4WDYAWBEGFDXFdhQ1xhUnNWW2AgAgE1iWAAAWAggQGQYUN0kZBhT4FWW2FDhGBAjAFgII0BYU+BVltgQIwBNWFDmWCAjgFgYI8BYVPrVluNYIABNY5goAE1YEBRiGP/////FmDgG4FSYAQBYUPFl5aVlJOSkZBhVA5WW2AAYEBRgIMDgWAAh4A7FYAVYUPfV2AAgP1bUFrxFYAVYUPzVz1gAIA+PWAA/VtQUFBQW4BhRAKBYVKJVluRUFBhQxFWW1BhCwpWW2AAYUQ9YUQmYQEAigFg4IsBYVHZVltgDwtgZ2AAYQW9YGCNAWBAjgFhT4FWW2BAUWNwoIIxYOAbgVIwYASCAVJgAWABYKAbA5GQkRaQY3CggjGQYCQBYCBgQFGAgwOBhlr6FYAVYUSDVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGFEp5GQYVHAVluQUGEBoIgBNRVhRldXYUTIYUQmYQEAigFg4IsBYVHZVltgalRgQFFjCV6ns2DgG4FSYAFgAWCgGwOSgxaSYwlep7OSYUT7kpEWkIWQYAQBYVGFVltgIGBAUYCDA4FgAIda8RWAFWFFGlc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhRT6RkGFRnlZbUGAAYEBRgGBgAWBAUoCKYQFgAWAggQGQYUVgkZBhT4FWW2ABYAFgoBsDFoFSYCABYUWAYQGgjAFhAYCNAWFPgVZbYAFgAWCgGwOQgRaCUmEBoIwBNWAgkJIBkZCRUmBqVJGSUBZjRRx2NWFF1mFFvGEBAI0BYOCOAWFR2VZbYA8LYGdgAI5gQAFgIIEBkGEFvZGQYU+BVluEMI1hASABYCCBAZBhReyRkGFPgVZbhmBAUYZj/////xZg4BuBUmAEAWFGDZWUk5KRkGFSJlZbYCBgQFGAgwOBYACHWvEVgBVhRixXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYUZQkZBhUcBWW1BQYTH4VlthMfhhRmxhAUCKAWEBIIsBYU+BVluCYQcoYUW8YQEAjQFg4I4BYVHZVltgAFRhAQCQBGD/FmFGnFdgAFRg/xYVYUagVlswOxVbYUcDV2BAUWJGG81g5RuBUmAgYASCAVJgLmAkggFSf0luaXRpYWxpemFibGU6IGNvbnRyYWN0IGlzIGFscmVhYESCAVJtGR5IGluaXRpYWxpemVlgkhtgZIIBUmCEAWEZFlZbYABUYQEAkARg/xYVgBVhRyVXYACAVGH//xkWYQEBF5BVW2FHLWFJqVZbYUc1YUnQVlthRz6FYUmHVltgaYBUYAFgAWCgGwOAhxZgAWABYKAbAxmSgxYXkJJVYGqAVIaEFpCDFheQVWBrgFSShRaSkJEWkZCRF5BVYECAUYCCAZCRUmAFgIJSZDIuMi4zYNgbYCCQkgGRglJhR6eRYGaRYU0RVltQgBVhDexXYACAVGH/ABkWkFVQUFBQUFZbYEBRY3CggjFg4BuBUjBgBIIBUoGQYAFgAWCgGwOEFpBjcKCCMZBgJAFgIGBAUYCDA4GGWvoVgBVhSAZXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYUgqkZBhUcBWWxAVYUh4V2BAUWJGG81g5RuBUmAgYASCAYGQUmAkggFSf0N1cnZlUHJveHk6IGluc3VmZmljaWVudCBiYWxhbmNlYESCAVJgZAFhGRZWW1BQVlthSNKDY6kFnLtg4BuEhGBAUWAkAWFIm5KRkGFRhVZbYECAUWAfGYGEAwGBUpGQUmAggQGAUWABYAFg4BsDFmABYAFg4BsDGZCTFpKQkheQkVJhSgdWW1BQUFZbYABhSOODg2FK2VZbkFBbkpFQUFZbYABgFDYQgBWQYUkJV1BgZVRgAWABYKAbAxYzFFsVYUkbV1BgExk2ATVgYByQVltQM5BWW2AAYUjjg2ABYAFgoBsDhBZhSwNWW2AzgFRgAWABYKAbA4OBFmABYAFgoBsDGYMWgReQk1VgQFGRFpGQgpB/i+AHnFMWWRQTRM0f0KTyhBlJf5cio9qv47QYb2tkV+CQYACQo1BQVltgZYBUYAFgAWCgGwMZFmABYAFgoBsDkpCSFpGQkReQVVZbYABUYQEAkARg/xZhIgNXYEBRYkYbzWDlG4FSYAQBYRkWkGFUTVZbYABUYQEAkARg/xZhSfdXYEBRYkYbzWDlG4FSYAQBYRkWkGFUTVZbYSIDYUoCYUjsVlthSTVWW2AAYUpcgmBAUYBgQAFgQFKAYCCBUmAgAX9TYWZlRVJDMjA6IGxvdy1sZXZlbCBjYWxsIGZhaWxlZIFSUIVgAWABYKAbAxZhS1KQkpGQY/////8WVluAUZCRUBVhSNJXgIBgIAGQUYEBkGFKepGQYVGeVlthSNJXYEBRYkYbzWDlG4FSYCBgBIIBUmAqYCSCAVJ/U2FmZUVSQzIwOiBFUkMyMCBvcGVyYXRpb24gZGlkIG5gRIIBUmkb3Qgc3VjY2VlZYLIbYGSCAVJghAFhGRZWW2AAgmAAAYKBVIEQYUrwV2FK8GFSc1ZbkGAAUmAgYAAgAVSQUJKRUFBWW2AAgYFSYAGDAWAgUmBAgSBUYUtKV1CBVGABgYEBhFVgAISBUmAggIIgkJMBhJBVhFSEglKChgGQk1JgQJAgkZCRVWFI5lZbUGAAYUjmVltgYGFLYYSEYACFYUtrVluQUFuTklBQUFZbYGCCRxAVYUvMV2BAUWJGG81g5RuBUmAgYASCAVJgJmAkggFSf0FkZHJlc3M6IGluc3VmZmljaWVudCBiYWxhbmNlIGZvYESCAVJlHIgY2FsbYNIbYGSCAVJghAFhGRZWW2ABYAFgoBsDhRY7YUwjV2BAUWJGG81g5RuBUmAgYASCAVJgHWAkggFSf0FkZHJlc3M6IGNhbGwgdG8gbm9uLWNvbnRyYWN0AAAAYESCAVJgZAFhGRZWW2AAgIZgAWABYKAbAxaFh2BAUWFMP5GQYVSYVltgAGBAUYCDA4GFh1rxklBQUD2AYACBFGFMfFdgQFGRUGAfGWA/PQEWggFgQFI9glI9YABgIIQBPmFMgVZbYGCRUFtQkVCRUGFMkYKChmFMnFZbl5ZQUFBQUFBQVltgYIMVYUyrV1CBYUtkVluCURVhTLtXglGAhGAgAf1bgWBAUWJGG81g5RuBUmAEAWEZFpGQYU9OVltgQFGAYGABYEBSgGADkGAgggKANoM3UJGSkVBQVltgQFGAYKABYEBSgGAFkGAgggKANoM3UJGSkVBQVluCgFRhTR2QYVMXVluQYABSYCBgACCQYB8BYCCQBIEBkoJhTT9XYACFVWFNhVZbgmAfEGFNWFeAUWD/GRaDgAEXhVVhTYVWW4KAAWABAYVVghVhTYVXkYIBW4KBERVhTYVXglGCVZFgIAGRkGABAZBhTWpWW1BhTZGSkVBhTZVWW1CQVltbgIIRFWFNkVdgAIFVYAEBYU2WVltgAWABYKAbA4EWgRRhMlRXYACA/VtgAIBgAICEhgNhAWCBEhVhTddXYACA/VthAQCAghIVYU3nV2AAgP1bhpVQhQE1kFBhTfiBYU2qVluSUGEBIIUBNWFOCYFhTapWW5OWkpVQkpNhAUABNZJQUFZbYABhAcCChAMSFWFOLVdgAID9W1CRkFBWW4BgoIEBgxAVYUjmV2AAgP1bYACAYABhAwCEhgMSFWFOWldgAID9W2FOZIWFYU4aVluSUGFOdIVhAcCGAWFOM1ZbkVBhToSFYQJghgFhTjNWW5BQklCSUJJWW2AAgGAAgGBghYcDEhVhTqNXYACA/VuENWFOroFhTapWW5NQYCCFATVhTr6BYU2qVluSUGBAhQE1Z///////////gIIRFWFO21dgAID9W4GHAZFQh2AfgwESYU7vV2AAgP1bgTWBgREVYU7+V2AAgP1biGAggmAFG4UBAREVYU8TV2AAgP1blZiUl1BQYCABlFBQUFZbYABbg4EQFWFPPVeBgQFRg4IBUmAgAWFPJVZbg4ERFWELDldQUGAAkQFSVltgIIFSYACCUYBgIIQBUmFPbYFgQIUBYCCHAWFPIlZbYB8BYB8ZFpGQkQFgQAGSkVBQVltgAGAggoQDEhVhT5NXYACA/VuBNWFLZIFhTapWW2AAYMCChAMSFWFOLVdgAID9W2AAgGAAYQIAhIYDEhVhT8ZXYACA/VthT9CFhWFPnlZbklBhT9+FYMCGAWFOM1ZbkVBhToSFYQFghgFhTjNWW2AAgGAAgGAAhYcDYQNAgRIVYVAJV2AAgP1bYKCBEhVhUBdXYACA/VtQhZRQYVAoh2CgiAFhT55WW5NQYVA4h2EBYIgBYU4zVluSUGFQSIdhAgCIAWFOM1ZbkVBhUFiHYQKgiAFhTjNWW5BQkpVQkpWQk1BWW2AAgGAAgGAAYQNghogDEhVhUH1XYACA/VthUIeHh2FPnlZblFBhUJaHYMCIAWFPnlZbk1BhUKaHYQGAiAFhTjNWW5JQYVC2h2ECIIgBYU4zVluRUGFQWIdhAsCIAWFOM1ZbYACAYACAYABhBGCGiAMSFWFQ31dgAID9W2FQ6YeHYU4aVluUUGFQ+YdhAcCIAWFPnlZbk1BhUQmHYQKAiAFhTjNWW5JQYVEZh2EDIIgBYU4zVluRUGFQWIdhA8CIAWFOM1ZbYACAYACAYICFhwMSFWFRP1dgAID9W4Q1YVFKgWFNqlZbk1BgIIUBNWFRWoFhTapWW5JQYECFATVhUWqBYU2qVluRUGBghQE1YVF6gWFNqlZbk5aSlVCQk1BQVltgAWABYKAbA5KQkhaCUmAgggFSYEABkFZbYABgIIKEAxIVYVGwV2AAgP1bgVGAFRWBFGFLZFdgAID9W2AAYCCChAMSFWFR0ldgAID9W1BRkZBQVltgAGAggoQDEhVhUetXYACA/VuBNYBgDwuBFGFLZFdgAID9W2ABYAFgoBsDlIUWgVKShBZgIIQBUpIWYECCAVJgYIEBkZCRUmCAAZBWW2ABYAFgoBsDlYYWgVJgIICCAZWQlVKShRZgQICFAZGQkVKRhRZgYIQBUoBRhRZggIQBUpKDAVGQkxZgoIIBUpEBUWDAggFSYOABkFZbY05Ie3Fg4BtgAFJgMmAEUmAkYAD9W2AAYAAZghQVYVKrV2NOSHtxYOAbYABSYBFgBFJgJGAA/VtQYAEBkFZbYMCBAWCghIM3kRUVYKCRkJEBUpGQUFZbYMCBAWCghIM3YKCRkJEBkZCRUpGQUFZbYCCAglKBgQFSf093bmFibGU6IGNhbGxlciBpcyBub3QgdGhlIG93bmVyYECCAVJgYAGQVltgAYGBHJCCFoBhUytXYH+CFpFQW2AgghCBFBVhTi1XY05Ie3Fg4BtgAFJgImAEUmAkYAD9W4BgAFtgA4EQFWELDleBUYRSYCCThAGTkJEBkGABAWFTUFZbYICBAWFTfYKFYVNMVluCFRVgYIMBUpOSUFBQVltggIEBYVOagoVhU0xWW4JgYIMBUpOSUFBQVltgAGAggoQDEhVhU7lXYACA/VuBUWFLZIFhTapWW5OEUmABYAFgoBsDkoMWYCCFAVJgQIQBkZCRUhZgYIIBUmCAAZBWW2AAYCCChAMSFWFT/VdgAID9W4E1YP+BFoEUYUtkV2AAgP1blodSYAFgAWCgGwOVhhZgIIgBUpOQlBZgQIYBUmBghQGRkJFSYP8WYICEAVJgoIMBkZCRUmDAggFSYOABkFZbYCCAglJgK5CCAVJ/SW5pdGlhbGl6YWJsZTogY29udHJhY3QgaXMgbm90IGlgQIIBUmpuaXRpYWxpemluZ2CoG2BgggFSYIABkFZbYACCUWFUqoGEYCCHAWFPIlZbkZCRAZKRUFBW/i5evLwQ4SPiXGxwuDJD6xNzVkxxH8CIyU1R7SkSRCQHomRpcGZzWCISIHT6kHD8p5FSYoQeYeRZLA75OXV1khFtsGyhAyk1ACuiZHNvbGNDAAgKADM="
            },
            {
                "key": "BwPjC5Q5M8SiTrTfBVJR+ZKm3g1q0Q==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPpXZ7l7J29EQeNilR0tEJ54pIvhQ==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwP7UPpdjx8B02RTHBJm7g7nu4MC+g==",
                "proof": [],
                "value": "YAQ2EBVhAA1XYRBgVltgBGAAYBw3YABRNGEQZldjqQWcu4EYYQDAV2AENYBgoBxhEGZXYOBSYAYzYKBSYIBSYEBggCCAVGAkNYCCEGEQZleAggOQUJBQgVVQYAZg4FFgoFJggFJgQGCAIIBUYCQ1gYGDARBhEGZXgIIBkFCQUIFVUGDgUTN/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs+9gJDVhAQBSYCBhAQCjYAFhAQBSYCBhAQDzW2MjuHLdgRhhAfdXYAQ1gGCgHGEQZldg4FJgJDWAYKAcYRBmV2EBAFJgBmDgUWCgUmCAUmBAYIAggFRgRDWAghBhEGZXgIIDkFCQUIFVUGAGYQEAUWCgUmCAUmBAYIAggFRgRDWBgYMBEGEQZleAggGQUJBQgVVQYAdg4FFgoFJggFJgQGCAIDNgoFJggFJgQGCAIFRhASBSf///////////////////////////////////////////YQEgURRhAbVXYQEgUWBENYCCEGEQZleAggOQUJBQYAdg4FFgoFJggFJgQGCAIDNgoFJggFJgQGCAIFVbYQEAUWDgUX/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz72BENWEBQFJgIGEBQKNgAWEBQFJgIGEBQPNbYwlep7OBGGECb1dgBDWAYKAcYRBmV2DgUmAkNWAHM2CgUmCAUmBAYIAgYOBRYKBSYIBSYEBggCBVYOBRM3+MW+Hl6+x9W9FPcUJ9HoTz3QMUwPeyKR5bIArIx8O5JWAkNWEBAFJgIGEBAKNgAWEBAFJgIGEBAPNbY9UFrM+BGGEF3FdgBDWAYKAcYRBmV2DgUmAkNYBgoBxhEGZXYQEAUmCENYBgCBxhEGZXYQEgUmAAYOBRFGEQZldgZDVCEWEQZldgCmDgUWCgUmCAUmBAYIAgVGEBQFJgAGACYQQAUn8ZAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGEEIFJhBABgAoBgIIRhBgABAYJgIIUBYARa+lBQgFGCAZFQUGAFVGAggmEGAAEBUmAggQGQUH9uce2uErG5f00fYDcP7xAQX6L6rgEmEUoWnGSEXWEmyWEFQFJg4FFhBWBSYQEAUWEFgFJgRDVhBaBSYQFAUWEFwFJgZDVhBeBSYMBhBSBSYQUggFFgIIIBIJBQYCCCYQYAAQFSYCCBAZBQgGEGAFJhBgCQUIBRYCCCASCQUGEBYFJgAGDgUTsRYQPwV2DgUWEBYFFhAYBSYQEgUWEBoFJgQGCkYQHAN2AgYIBggGEBgGABWvpQYIBRGGEQZldhBVBWW2AAYKQ1YQIgUmDENWECQFJgQGECAFJhAgBgQIBgIIRhAsABAYJgIIUBYARa+lBQgFGCAZFQUGAfYAFgIIIGYQJgAWAggoQBEWEQZldgIIBhAoCCYQEgYARa+lBQgYFSkFCQUGABgGAghGECwAEBgmAghQFgBFr6UFCAUYIBkVBQgGECwFJhAsCQUIBRYCABgGEBgIKEYARa+pBQUFB/Fia6fgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABjFia6fmECAFJhAiCAYEBhAWBRglJgIIIBkVCAglKAgwGAYQGAgFFgIAGAg4KEYARa+pBQUFCAUYBgIIMBAYGCYCBgAYIDBmAfggEDkFADNoI3UFCAUWAgAWAgYAGCAwZgH4IBA5BQkFCQUIEBUFBQUGAgYQIAYMRhAhxg4FFa+mEFPVc9YABgAD49YAD9W2AfPREVYRBmV2ECAFEYYRBmV1tgRDVgB2DgUWCgUmCAUmBAYIAgYQEAUWCgUmCAUmBAYIAgVWEBQFFgAYGBgwEQYRBmV4CCAZBQkFBgCmDgUWCgUmCAUmBAYIAgVWEBAFFg4FF/jFvh5evsfVvRT3FCfR6E890DFMD3sikeWyAKyMfDuSVgRDVhAYBSYCBhAYCjYAFhAYBSYCBhAYDzW2M5UJNRgRhhBopXYAQ1gGCgHGEQZldg4FJgBzNgoFJggFJgQGCAIGDgUWCgUmCAUmBAYIAgVGAkNYGBgwEQYRBmV4CCAZBQkFBhAQBSYQEAUWAHM2CgUmCAUmBAYIAgYOBRYKBSYIBSYEBggCBVYOBRM3+MW+Hl6+x9W9FPcUJ9HoTz3QMUwPeyKR5bIArIx8O5JWEBAFFhASBSYCBhASCjYAFhASBSYCBhASDzW2OkV8LXgRhhBzZXYAQ1gGCgHGEQZldg4FJgBzNgoFJggFJgQGCAIGDgUWCgUmCAUmBAYIAgVGAkNYCCEGEQZleAggOQUJBQYQEAUmEBAFFgBzNgoFJggFJgQGCAIGDgUWCgUmCAUmBAYIAgVWDgUTN/jFvh5evsfVvRT3FCfR6E890DFMD3sikeWyAKyMfDuSVhAQBRYQEgUmAgYQEgo2ABYQEgUmAgYQEg81tjQMEPGYEYYQfaV2AENYBgoBxhEGZXYOBSYAlUMxhhEGZXYAiAVGAkNYGBgwEQYRBmV4CCAZBQkFCBVVBgBmDgUWCgUmCAUmBAYIAggFRgJDWBgYMBEGEQZleAggGQUJBQgVVQYOBRYAB/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs+9gJDVhAQBSYCBhAQCjYAFhAQBSYCBhAQDzW2NpYvhFgRhhCMZXYAQ1gGCgHGEQZldg4FJgCVQzGGEQZldgCFRhAQBSYQEAUWAkNYCCAoIVgoSDBBQXFWEQZleQUJBQZw3gtrOnZAAAgIIEkFCQUGEBIFJgAGEBIFERFWEIt1dhAQBRYQEgUYGBgwEQYRBmV4CCAZBQkFBgCFVgBmDgUWCgUmCAUmBAYIAggFRhASBRgYGDARBhEGZXgIIBkFCQUIFVUGDgUWAAf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvYQEgUWEBQFJgIGEBQKNbYQEgUWEBQFJgIGEBQPNbY3nMZ5CBGGEJZldgBDWAYKAcYRBmV2DgUmAJVDMYYRBmV2AIgFRgJDWAghBhEGZXgIIDkFCQUIFVUGAGYOBRYKBSYIBSYEBggCCAVGAkNYCCEGEQZleAggOQUJBQgVVQYABg4FF/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs+9gJDVhAQBSYCBhAQCjYAFhAQBSYCBhAQDzW2MWUun8gRhhCcNXYAQ1gGCgHGEQZldg4FJgCVQzGGEQZld/5JDTE44y8fZu85caPHPH93BLoMHRAA8eLD32/AN2YQszYQEAUmDgUWEBIFJgQGEBAKFg4FFgCVUAW2MxPOVngRhhCdlXYBJg4FJgIGDg81tjVP1NUIEYYQpzV2EBIIBgIICCUmAGYOBSf3Y1LjAuMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYQEAUmDggYQBgIKAUWAgAYCDgoRgBFr6kFBQUIBRgGAggwEBgYJgIGABggMGYB+CAQOQUAM2gjdQUIBRYCABYCBgAYIDBmAfggEDkFCQUJBQkFCBAZBQkFCQUGEBIPNbY+FDDgaBGGEOFldgBDVgBAFgQIE1EWEQZleAgDVgIAGAgmDgN1BQUGAkNWAEAWAggTURYRBmV4CANWAgAYCCYQFAN1BQUDNjjaXLW2EBgFJgIGEBgGAEYQGcYAlUWvphCuFXPWAAYAA+PWAA/VtgHz0RFWEQZldhAYBRGGEQZld/aO2eZoHJjQ4nRM5sCNRsBF4JikebEgtbclP6leTEiVRhAYCAYMCAglKAgwGAYACAgmAgglQBYMBgAGADgYNSAVuCYMBRYCACERVhC0dXYQtmVltgwFGFAVRgwFFgIAKFAVKBUWABAYCDUoEUFWELNVdbUFBQUFBQgFGAYCCDAQGBgmAgYAGCAwZgH4IBA5BQAzaCN1BQgFFgIAFgIGABggMGYB+CAQOQUJBQkFCBAZBQYCCCAZFQgIJSgIMBgGADgIJgIIJUAWDAYABgAoGDUgFbgmDAUWAgAhEVYQvYV2EL91ZbYMBRhQFUYMBRYCAChQFSgVFgAQGAg1KBFBVhC8ZXW1BQUFBQUIBRgGAggwEBgYJgIGABggMGYB+CAQOQUAM2gjdQUIBRYCABYCBgAYIDBmAfggEDkFCQUJBQgQGQUGAgggGRUICCUoCDAYBg4IBRYCABgIOChGAEWvqQUFBQgFGAYCCDAQGBgmAgYAGCAwZgH4IBA5BQAzaCN1BQgFFgIAFgIGABggMGYB+CAQOQUJBQkFCBAZBQYCCCAZFQgIJSgIMBgGEBQIBRYCABgIOChGAEWvqQUFBQgFGAYCCDAQGBgmAgYAGCAwZgH4IBA5BQAzaCN1BQgFFgIAFgIGABggMGYB+CAQOQUJBQkFCBAZBQYCCCAZFQM4JSYCCCAZFQQoJSkFCQUGEBgKFg4IBgAGAgglEBYMBgAGADgYNSAVuCYMBRYCACERVhDSpXYQ1JVltgwFFgIAKFAVFgwFGFAVWBUWABAYCDUoEUFWENGFdbUFBQUFBQYQFAgGADYCCCUQFgwGAAYAKBg1IBW4JgwFFgIAIRFWENd1dhDZZWW2DAUWAgAoUBUWDAUYUBVYFRYAEBgINSgRQVYQ1lV1tQUFBQUFB/i3PDxpu4/j1RLsxM91nMeSOfexebD/rKqaddUis5QA9hAmBSYOCAUWAgggEgkFBhAoBSf1cvAdgkiFoRjV0hx0VC8mOxMdKJeVXGKnIVlPHXw7LiYQKgUkZhAsBSMGEC4FJgoGECQFJhAkCAUWAgggEgkFBgBVUAW2MG/d4DgRhhDrlXYOCAYCCAglKAgwGAYACAgmAgglQBYMBgAGADgYNSAVuCYMBRYCACERVhDlNXYQ5yVltgwFGFAVRgwFFgIAKFAVKBUWABAYCDUoEUFWEOQVdbUFBQUFBQgFGAYCCDAQGBgmAgYAGCAwZgH4IBA5BQAzaCN1BQgFFgIAFgIGABggMGYB+CAQOQUJBQkFCBAZBQkFCQUGDg81tjldibQYEYYQ9cV2DggGAggIJSgIMBgGADgIJgIIJUAWDAYABgAoGDUgFbgmDAUWAgAhEVYQ72V2EPFVZbYMBRhQFUYMBRYCAChQFSgVFgAQGAg1KBFBVhDuRXW1BQUFBQUIBRgGAggwEBgYJgIGABggMGYB+CAQOQUAM2gjdQUIBRYCABYCBgAYIDBmAfggEDkFCQUJBQgQGQUJBQkFBg4PNbYzZE5RWBGGEPc1dgBVRg4FJgIGDg81tjcKCCMYEYYQ+oV2AENYBgoBxhEGZXYOBSYAZg4FFgoFJggFJgQGCAIFRhAQBSYCBhAQDzW2PdYu0+gRhhD/tXYAQ1gGCgHGEQZldg4FJgJDWAYKAcYRBmV2EBAFJgB2DgUWCgUmCAUmBAYIAgYQEAUWCgUmCAUmBAYIAgVGEBIFJgIGEBIPNbYxgWDd2BGGEQEldgCFRg4FJgIGDg81tjB1RhcoEYYRApV2AJVGDgUmAgYODzW2N+zr4AgRhhEF5XYAQ1gGCgHGEQZldg4FJgCmDgUWCgUmCAUmBAYIAgVGEBAFJgIGEBAPNbUFtgAGAA/VtgAID9"
            },
            {
                "key": "BwQIohKKF0n0FEsN/ObdMF573LHv8QEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAg8/JgDEKYI2IXH/77M52IKFea6M="
            },
            {
                "key": "BwQIohKKF0n0FEsN/ObdMF573LHv8QEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwQIohKKF0n0FEsN/ObdMF573LHv8QEAAADUN2BQv249cqoTpvPSJCGsDfdXsb+5X9PKsrPVBeyfzA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwQS4RoP3Sh2Lur7zng1ukN6GSVCwwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABl",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAQLAyRIBKP+7bMt33r2kMtJwASTU="
            },
            {
                "key": "BwQS4RoP3Sh2Lur7zng1ukN6GSVCwwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABq",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAg8/JgDEKYI2IXH/77M52IKFea6M="
            },
            {
                "key": "BwQS4RoP3Sh2Lur7zng1ukN6GSVCwwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABr",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA4MAhvYBA1U5h8QfIag1+63wr+LM="
            },
            {
                "key": "BwQS4RoP3Sh2Lur7zng1ukN6GSVCwwIExcxFxImRXAFwcXN2wPokb9D27wNk+NPWPHOSNPph",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAU="
            },
            {
                "key": "BwQS4RoP3Sh2Lur7zng1ukN6GSVCwzYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA4nZLWdWfNTOsMMg50Yyiqbl6Dyg="
            },
            {
                "key": "BwQS4RoP3Sh2Lur7zng1ukN6GSVCw3Nku8xGDuHysoClQimR6KFgDp0gAHt2pS06vUaxytGa",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA6V2e5eydvREHjYpUdLRCeeKSL4U="
            },
            {
                "key": "BwQS4RoP3Sh2Lur7zng1ukN6GSVCw7UxJ2hKVosxc64TufimAW4kPmO26O4ReNanF4ULXWED",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAuJ5vWld9BOQXyhnyF+lJLat/aDM="
            },
            {
                "key": "BwQS4RoP3Sh2Lur7zng1ukN6GSVCw8cvFIdnGwUfbLLWbVN2Ap5ZfpjR8JQjlyGb84/wLa26",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA+1D6XY8fAdNkUxwSZu4O57uDAvo="
            },
            {
                "key": "BwQS4RoP3Sh2Lur7zng1ukN6GSVCw+agx/iyZBRZKr7/QBGkodNPU3M36jIW9zJZ0pf6dmAa",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA4wuUOTPEok603wVSUfmSpt4NatE="
            },
            {
                "key": "BwR1lEzuYMKXasxmD3VzaJCh3xpiQgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9CQA="
            },
            {
                "key": "BwR1lEzuYMKXasxmD3VzaJCh3xpiQgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASoF8gA="
            },
            {
                "key": "BwR1lEzuYMKXasxmD3VzaJCh3xpiQgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQ="
            },
            {
                "key": "BwR1lEzuYMKXasxmD3VzaJCh3xpiQgEAAAApDezZVItiqNYDRamIOG/IS6a8lUhACPY2L5MWDvPlYw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA+1D6XY8fAdNkUxwSZu4O57uDAvo="
            },
            {
                "key": "BwR1lEzuYMKXasxmD3VzaJCh3xpiQgEAAAApDezZVItiqNYDRamIOG/IS6a8lUhACPY2L5MWDvPlZA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA6V2e5eydvREHjYpUdLRCeeKSL4U="
            },
            {
                "key": "BwR1lEzuYMKXasxmD3VzaJCh3xpiQgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM9g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAABnZceT+hAHnQAAAA="
            },
            {
                "key": "BwR1lEzuYMKXasxmD3VzaJCh3xpiQgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM9w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAABnZceT+hAHnQAAAA="
            },
            {
                "key": "BwR1lEzuYMKXasxmD3VzaJCh3xpiQgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM+A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAABnZceT+hAHnQAAAA="
            },
            {
                "key": "BwSDz8mAMQpgjYhcf/vsznYgoV5rowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABl",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAQLAyRIBKP+7bMt33r2kMtJwASTU="
            },
            {
                "key": "BwSDz8mAMQpgjYhcf/vsznYgoV5rowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABs",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA4MAhvYBA1U5h8QfIag1+63wr+LM="
            },
            {
                "key": "BwSDz8mAMQpgjYhcf/vsznYgoV5rowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABt",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAEuEaD90odi7q+854NbpDehklQsM="
            },
            {
                "key": "BwSDz8mAMQpgjYhcf/vsznYgoV5rowAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABw",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5FQVM="
            },
            {
                "key": "BwSDz8mAMQpgjYhcf/vsznYgoV5roy1VdSihy4ZrDZZZB7+JET6t8fGHzRcQvSYESYzKjk5f",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAACKISihdJ9BRLDfzm3TBee9yx7/E="
            },
            {
                "key": "BwSDz8mAMQpgjYhcf/vsznYgoV5rozYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAM8Hw/S2Iwp/3vfqcGaR115y5k8s="
            },
            {
                "key": "BwSDz8mAMQpgjYhcf/vsznYgoV5ro2CPqmMTWkB/iImDZZvbDahShMDMz/Tsx+Mrwtrm29b1",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAEO5GL/Urijzfv0OhdssDCmTq+BM="
            },
            {
                "key": "BwSDz8mAMQpgjYhcf/vsznYgoV5ro7UxJ2hKVosxc64TufimAW4kPmO26O4ReNanF4ULXWED",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAuJ5vWld9BOQXyhnyF+lJLat/aDM="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9CQA="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA+1D6XY8fAdNkUxwSZu4O57uDAvo="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQ="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAAApDezZVItiqNYDRamIOG/IS6a8lUhACPY2L5MWDvPlYw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAHWcBDYCdkO1KbCIBlbcWTU28JBE="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAAApDezZVItiqNYDRamIOG/IS6a8lUhACPY2L5MWDvPlZA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAACKISihdJ9BRLDfzm3TBee9yx7/E="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAAApDezZVItiqNYDRamIOG/IS6a8lUhACPY2L5MWDvPlZQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAU4gYlZ+9++dhhLYxVOgfyV35Tq0="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAAApDezZVItiqNYDRamIOG/IS6a8lUhACPY2L5MWDvPlZg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAASGbV3m+t2WBXbKuyz1bK31X1O2c="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAAApDezZVItiqNYDRamIOG/IS6a8lUhACPY2L5MWDvPlZw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAsZLASMuU5Da1+ukmuuMYiA084FY="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM9g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM9w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM+A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM+Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwSzIZ1VKG1hyqRjpvnnTkHugTxvHgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM+g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwS7YyZJhdwHBWt9Alu8TULUn8bBpgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA9CQA="
            },
            {
                "key": "BwS7YyZJhdwHBWt9Alu8TULUn8bBpgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA6V2e5eydvREHjYpUdLRCeeKSL4U="
            },
            {
                "key": "BwS7YyZJhdwHBWt9Alu8TULUn8bBpgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQ="
            },
            {
                "key": "BwS7YyZJhdwHBWt9Alu8TULUn8bBpgEAAAApDezZVItiqNYDRamIOG/IS6a8lUhACPY2L5MWDvPlZg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA4wuUOTPEok603wVSUfmSpt4NatE="
            },
            {
                "key": "BwS7YyZJhdwHBWt9Alu8TULUn8bBpgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM9g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwS7YyZJhdwHBWt9Alu8TULUn8bBpgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM9w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwS7YyZJhdwHBWt9Alu8TULUn8bBpgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM+A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwS7YyZJhdwHBWt9Alu8TULUn8bBpgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM+Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwS7YyZJhdwHBWt9Alu8TULUn8bBpgEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oM+g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwTO0wGqlC9yDUadiBuPrx1IdGybfQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA4MAhvYBA1U5h8QfIag1+63wr+LM="
            },
            {
                "key": "BwTgwCG9gEDVTmHxB8hqDX7rfCv4swAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABn",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAQLAyRIBKP+7bMt33r2kMtJwASTU="
            },
            {
                "key": "BwTgwCG9gEDVTmHxB8hqDX7rfCv4swAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABp",
                "proof": [],
                "value": "L+WXwU1n4CJ3E0hNjQcgYSMf2T1Ei6PwyN+IuWYVMlk="
            },
            {
                "key": "BwTgwCG9gEDVTmHxB8hqDX7rfCv4swAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABq",
                "proof": [],
                "value": "FWR6a/DmuGoMeyVYCosw9OqcHDfvVWBCH/tIsoKf6RU="
            },
            {
                "key": "BwTgwCG9gEDVTmHxB8hqDX7rfCv4swAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABr",
                "proof": [],
                "value": "ArgrzwJfBEPxWFKCXOXonQ2Lmi06Z3RDeFMH8mfPZYc="
            },
            {
                "key": "BwTgwCG9gEDVTmHxB8hqDX7rfCv4swAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABs",
                "proof": [],
                "value": "LbVNu545W4N1Z7vY5rhNfScNVvglvifLVyo6h19+P+o="
            },
            {
                "key": "BwTgwCG9gEDVTmHxB8hqDX7rfCv4swAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABt",
                "proof": [],
                "value": "AAAAAAAAAAAAAAIHZ4bXpdfxiYIgUDqjVSclCyddu+k="
            },
            {
                "key": "BwTgwCG9gEDVTmHxB8hqDX7rfCv4swAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABu",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAztMBqpQvcg1GnYgbj68dSHRsm30="
            },
            {
                "key": "BwTgwCG9gEDVTmHxB8hqDX7rfCv4szYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAwjBTFYiLThFRUmVby+j6bQ41YMQ="
            },
            {
                "key": "BwTgwCG9gEDVTmHxB8hqDX7rfCv4s7UxJ2hKVosxc64TufimAW4kPmO26O4ReNanF4ULXWED",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAuJ5vWld9BOQXyhnyF+lJLat/aDM="
            },
            {
                "key": "BwTjC5Q5M8SiTrTfBVJR+ZKm3g1q0QEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAg8/JgDEKYI2IXH/77M52IKFea6M="
            },
            {
                "key": "BwTjC5Q5M8SiTrTfBVJR+ZKm3g1q0QEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwTjC5Q5M8SiTrTfBVJR+ZKm3g1q0QEAAABg+JTDvuE2veAf0Har2kGUrHIMG/r9udIX3bp6OX0Hwg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAUrfS3MgM0uQAAAA="
            },
            {
                "key": "BwTpXZ7l7J29EQeNilR0tEJ54pIvhQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAABnZceT+hAHnQAAAA="
            },
            {
                "key": "BwTpXZ7l7J29EQeNilR0tEJ54pIvhQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAu2MmSYXcBwVrfQJbvE1C1J/GwaY="
            },
            {
                "key": "BwTpXZ7l7J29EQeNilR0tEJ54pIvhQEAAADd1Logm8B4KM/Vfs4y1bZWm2xeMHXVNiTzfsYjNwg3RQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAABnZceT+hAHnQAAAA="
            },
            {
                "key": "BwT7UPpdjx8B02RTHBJm7g7nu4MC+gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAABnZceT+hAHnQAAAA="
            },
            {
                "key": "BwT7UPpdjx8B02RTHBJm7g7nu4MC+gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAsyGdVShtYcqkY6b5505B7oE8bx4="
            },
            {
                "key": "BwT7UPpdjx8B02RTHBJm7g7nu4MC+gEAAADd1Logm8B4KM/Vfs4y1bZWm2xeMHXVNiTzfsYjNwg3RQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAABnZceT+hAHnQAAAA="
            },
            {
                "key": "BwcIohKKF0n0FEsN/ObdMF573LHv8Q==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwd1lEzuYMKXasxmD3VzaJCh3xpiQg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwezIZ1VKG1hyqRjpvnnTkHugTxvHg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwe7YyZJhdwHBWt9Alu8TULUn8bBpg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfO0wGqlC9yDUadiBuPrx1IdGybfQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfjC5Q5M8SiTrTfBVJR+ZKm3g1q0Q==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfpXZ7l7J29EQeNilR0tEJ54pIvhQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwf7UPpdjx8B02RTHBJm7g7nu4MC+g==",
                "proof": [],
                "value": "AAAAAQ=="
            }
        ]
    }
}
'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/res/aurora_state_FRcorNv.json ---
{
    "id": "1",
    "jsonrpc": "2.0",
    "result": {
        "block_hash": "6SKRsWLucTb1yaaSYKDBCdrDvrFv9ruKoAorsWKaBcZs",
        "block_height": 64328523,
        "proof": [],
        "values": [
            {
                "key": "BwBTVEFURQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5FQVIGAAAAYXVyb3JhAAAAAAAAAAAAAAAA"
            },
            {
                "key": "BwEaZC8OPDr1ReesvTiwclGzmQkU8Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF0="
            },
            {
                "key": "BwEfHtIUvvXoPY9dDrXXAR65ZdDXmw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEszGH+mdecyTUNAGn5w3sbsHmmSw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwE4OJVnELzJ0SLdI4Y6BUnKjVZ11g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwE+ByIkGNgSVCOLutyYWdG6cW9X0g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFKRQddPnUvNnZhD8Qn9eaRXOY6Yw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGEsSOHXw82uWbQtsoUsxEhvZZ2rQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGTeWSLIvUofHblZf6CqxmsuJmmMQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGYGlLNAnzJDYFTCNRSHfLGHBta3g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGZkKZY9xJIzFB+pilG8Ot3KEkbcA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGfH5M8ZgodyFbw4P4FhDWHnFzO8A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGoyq81wBNgMylN0oahQFH783rtBw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwG21nkOEjXRbTp4O5BG7goVFkH+2g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwG3YQjrdktEJ1BcS7Ago32Vs+9a/g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwG789QoHxDlN9WxPKgL4iNiMQsr+Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHCH/ASKemC18i4aRFjsKPLjzV0Uw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHGb1lCaAQdtgUH8AcDsVJJL7F25w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA8U="
            },
            {
                "key": "BwHXqBKl0syW54yDsDJMgiae6CrxyA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHcbQn1zAheKZctGSyzrc36ZJWnQQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHlUKiGcWJBr7fuJ25kcgfXZn4eeQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwH6lDSEZ/ZNWkV/dfi8QEldM8Zauw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwIaZC8OPDr1ReesvTiwclGzmQkU8Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIfHtIUvvXoPY9dDrXXAR65ZdDXmw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIszGH+mdecyTUNAGn5w3sbsHmmSw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwI4OJVnELzJ0SLdI4Y6BUnKjVZ11g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwI+ByIkGNgSVCOLutyYWdG6cW9X0g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJKRQddPnUvNnZhD8Qn9eaRXOY6Yw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKEsSOHXw82uWbQtsoUsxEhvZZ2rQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKTeWSLIvUofHblZf6CqxmsuJmmMQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKYGlLNAnzJDYFTCNRSHfLGHBta3g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKZkKZY9xJIzFB+pilG8Ot3KEkbcA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKfH5M8ZgodyFbw4P4FhDWHnFzO8A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKoyq81wBNgMylN0oahQFH783rtBw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwK21nkOEjXRbTp4O5BG7goVFkH+2g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwK3YQjrdktEJ1BcS7Ago32Vs+9a/g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwK789QoHxDlN9WxPKgL4iNiMQsr+Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLCH/ASKemC18i4aRFjsKPLjzV0Uw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLGb1lCaAQdtgUH8AcDsVJJL7F25w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLXqBKl0syW54yDsDJMgiae6CrxyA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLcbQn1zAheKZctGSyzrc36ZJWnQQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLlUKiGcWJBr7fuJ25kcgfXZn4eeQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwL6lDSEZ/ZNWkV/dfi8QEldM8Zauw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwMfHtIUvvXoPY9dDrXXAR65ZdDXmw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwMstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "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UFCWUJaUUFBQUFBWW2AAgRWAYULzV1BQgIICgoKCgWFC8Ff+WwQUW2ERi1dgQIBRYkYbzWDlG4FSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1tdWwtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W4CCAYKBEBVhEYtXYECAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSf2RzLW1hdGgtYWRkLW92ZXJmbG93AAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgAIBgAGFDq4WFYT9pVltQkFBgAIBhQ7yIiIhhNMtWW2ABYAFgoBsDFmMJAvGsYEBRgWP/////FmDgG4FSYAQBYGBgQFGAgwOBhoA7FYAVYUP0V2AAgP1bUFr6FYAVYUQIVz1gAIA+PWAA/VtQUFBQYEBRPWBggRAVYUQeV2AAgP1bUIBRYCCQkQFRbf//////////////////kYIWk1AWkFBgAWABYKAbA4eBFpCEFhRhRFhXgIJhRFtWW4GBW5CZkJhQllBQUFBQUFBW/lVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9PVVRQVVRfQU1PVU5UVW5pc3dhcFYyTGlicmFyeTogSURFTlRJQ0FMX0FERFJFU1NFU1VuaXN3YXBWMlJvdXRlcjogSU5TVUZGSUNJRU5UX0JfQU1PVU5UVW5pc3dhcFYyTGlicmFyeTogSU5TVUZGSUNJRU5UX0xJUVVJRElUWVVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IEVYQ0VTU0lWRV9JTlBVVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IElOU1VGRklDSUVOVF9BX0FNT1VOVFRyYW5zZmVySGVscGVyOiBFVEhfVFJBTlNGRVJfRkFJTEVEVW5pc3dhcFYyUm91dGVyOiBJTlNVRkZJQ0lFTlRfT1VUUFVUX0FNT1VOVFRyYW5zZmVySGVscGVyOiBUUkFOU0ZFUl9GUk9NX0ZBSUxFRFVuaXN3YXBWMkxpYnJhcnk6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRVbmlzd2FwVjJSb3V0ZXI6IEVYUElSRUQAAAAAAAAAAKFkc29sY0MABgwACg=="
            },
            {
                "key": "BwMszGH+mdecyTUNAGn5w3sbsHmmSw==",
                "proof": [],
                "value": "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VltgQFGAYCABYEBSgGAAgVJQkFZbgoBUYAGBYAEWFWEBAAIDFmACkASQYABSYCBgACCQYB8BYCCQBIEBkoJgHxBhUTFXgFFg/xkWg4ABF4VVYVFeVluCgAFgAQGFVYIVYVFeV5GCAVuCgREVYVFeV4JRglWRYCABkZBgAQGQYVFDVltQYVFqkpFQYVJoVltQkFZbYECAUWEBIIEBkJFSgGAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUlCQVltgQIBRYQEAgQGQkVKAYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJQkFZbYECAUWDggQGQkVKAYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUlCQVltgQIBRYICBAZCRUoBgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSUJBWW2EOmJGQW4CCERVhUWpXYACBVWABAWFSblb+b25seSBhZG1pbiBtYXkgaW5pdGlhbGl6ZSB0aGUgbWFya2V0bWFya2V0IG1heSBvbmx5IGJlIGluaXRpYWxpemVkIG9uY2VDRXJjMjA6OnN3ZWVwVG9rZW46IGNhbiBub3Qgc3dlZXAgdW5kZXJseWluZyB0b2tlbmluaXRpYWwgZXhjaGFuZ2UgcmF0ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLm9ubHkgdGhlIGFkbWluIG1heSBzZXQgdGhlIGNvbXAtbGlrZSBkZWxlZ2F0ZXNldHRpbmcgaW50ZXJlc3QgcmF0ZSBtb2RlbCBmYWlsZWRvbmx5IHRoZSBhZG1pbiBtYXkgY2FsbCBfcmVzaWduSW1wbGVtZW50YXRpb25NSU5UX05FV19BQ0NPVU5UX0JBTEFOQ0VfQ0FMQ1VMQVRJT05fRkFJTEVEYm9ycm93QmFsYW5jZVN0b3JlZDogYm9ycm93QmFsYW5jZVN0b3JlZEludGVybmFsIGZhaWxlZFJFUEFZX0JPUlJPV19ORVdfQUNDT1VOVF9CT1JST1dfQkFMQU5DRV9DQUxDVUxBVElPTl9GQUlMRUTd8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz71JFUEFZX0JPUlJPV19ORVdfVE9UQUxfQkFMQU5DRV9DQUxDVUxBVElPTl9GQUlMRURMSVFVSURBVEVfQ09NUFRST0xMRVJfQ0FMQ1VMQVRFX0FNT1VOVF9TRUlaRV9GQUlMRURleGNoYW5nZVJhdGVTdG9yZWQ6IGV4Y2hhbmdlUmF0ZVN0b3JlZEludGVybmFsIGZhaWxlZE1JTlRfTkVXX1RPVEFMX1NVUFBMWV9DQUxDVUxBVElPTl9GQUlMRURvbmUgb2YgcmVkZWVtVG9rZW5zSW4gb3IgcmVkZWVtQW1vdW50SW4gbXVzdCBiZSB6ZXJvcmVkdWNlIHJlc2VydmVzIHVuZXhwZWN0ZWQgdW5kZXJmbG93b25seSB0aGUgYWRtaW4gbWF5IGNhbGwgX2JlY29tZUltcGxlbWVudGF0aW9uomVienpyMVggfqrnIi5EOPGDZelaxc/HrY46bU0Mhd6FOarCIYr284Rkc29sY0MABRAAMg=="
            },
            {
                "key": "BwM4OJVnELzJ0SLdI4Y6BUnKjVZ11g==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEBo1dgADVg4ByAY3FQGKYRYQDuV4Bjq33gmBFhAJdXgGPRq7kHEWEAcVeAY9GruQcUYQM5V4Bj2fMGpxRhA0xXgGPt2LFwFGEDVFeAY/L944sUYQNcV2EBo1ZbgGOrfeCYFGEDAFeAY7HAR0QUYQMTV4Bjw0YlPRRhAyZXYQGjVluAY42ly1sRYQDIV4BjjaXLWxRhAsRXgGONvb5tFGECzFeAY5PxpAsUYQLfV2EBo1ZbgGNxUBimFGECiVeAY3jtXR8UYQKRV4BjiLukLxRhArFXYQGjVluAYy+UDHARYQFQV4BjV6W1jBFhASpXgGNXpbWMFGECZleAY2FiGqoUYQJ5V4BjcDDBoBRhAoFXYQGjVluAYy+UDHAUYQIrV4BjT3CxWhRhAj5XgGNR6wWmFGECRldhAaNWW4BjF8r28RFhAYFXgGMXyvbxFGEB/VeAYxj8zHYUYQIFV4BjGatFPBRhAhhXYQGjVluAYwgePtoUYQGoV4BjCtWNLxRhAcZXgGMVJv4nFGEB21dbYACA/VthAbBhA29WW2BAUWEBvZGQYSYnVltgQFGAkQOQ81thAdlhAdQ2YARhIRdWW2EDdVZbAFthAe5hAek2YARhIHdWW2EFDVZbYEBRYQG9k5KRkGEl/FZbYQGwYQVQVlthAdlhAhM2YARhIKdWW2EFVlZbYQHZYQImNmAEYR9mVlthBvhWW2EB2WECOTZgBGEgp1ZbYQkiVlthAdlhCkNWW2ECWWECVDZgBGEgd1ZbYQrmVltgQFFhAb2RkGElwlZbYQHZYQJ0NmAEYR+CVlthDYxWW2EBsGENvFZbYQGwYQ3gVlthAdlhD9VWW2ECpGECnzZgBGEgd1ZbYRBrVltgQFFhAb2RkGEhqVZbYQHZYQK/NmAEYSFEVlthEJJWW2ECpGESF1ZbYQHZYQLaNmAEYSEXVlthEiZWW2EC8mEC7TZgBGEgp1ZbYRO5VltgQFFhAb2SkZBhJm9WW2EB2WEDDjZgBGEg1lZbYRPdVlthAbBhAyE2YARhIKdWW2EV71ZbYQKkYQM0NmAEYSB3VlthF+NWW2EB2WEDRzZgBGEhF1ZbYRfwVlthAqRhGitWW2ECpGEaT1ZbYQHZYQNqNmAEYR9mVlthGnNWW2ABVJBWW2EDfWEKQ1ZbYQOFYR9GVlthA46EYQrmVltgAIWBUmAEYCCQgVJgQICDIDOEUpCRUpAggVGRklCQYQPgkGTo1KUQAJBhA8yQh5BgAWABYIAbAxZhG0BWW4FhA9NX/ltgAYQBVJGQBGEbfVZbYAGCAVWAVGED8ZCFYRvKVluBVWADgFRgAJGQh5CBEGEEBVf+W2AAkYJSYCCQkSABVGABYAFgoBsDFpBQgBVhBItXgVRgQFFjWN9G12DgG4FSYAFgAWCgGwODFpFjWN9G15FhBFiRipEzkYqRYACRkGAEAWEmMFZbYABgQFGAgwOBYACHgDsVgBVhBHJXYACA/VtQWvEVgBVhBIZXPWAAgD49YAD9W1BQUFBbYQS5hIZgAomBVIEQYQSdV/5bYACRglJgIJCRIAFUYAFgAWCgGwMWkZBhG+1WW4NgAWABYKAbAxaGM2ABYAFgoBsDFn+BZr8l+KK37TyFBJIH2kNY0W7b7Zd9I/ou5vDd4+whMohgQFFhBP2RkGEmJ1ZbYEBRgJEDkKRQUFBQUFBWW2ABgYFUgRBhBRpX/ltgAJGCUmAgkJEgAVRgAWABYIAbA4EWkVBn//////////9gAWCAG4IEgRaRYAFgwBuQBBaDVltgBVSBVlthBV5hCkNWW2EFZmEfRlZbYQVvg2EK5lZbYACEgVJgBGAgkIFSYECAgyAzhFKQkVKBIIJRgVSTlFCQkmTo1KUQAJFhBauRkGABYAFggBsDFmEbQFZbgWEFslf+WwSQUGAAYQXWYQXRhGABAVSEYRt9kJGQY/////8WVlthHHVWW2ABhAGDkFWQUIAVYQYZV2EGGWABYAFgoBsDfwAAAAAAAAAAAAAAAPqUNIRn9k1aRX91+LxASV0zxlq7FoaDYRvtVltgAGADh4FUgRBhBihX/ltgAJGCUmAgkJEgAVRgAWABYKAbAxaQUIAVYQatV4NUYEBRY1jfRtdg4BuBUmABYAFgoBsDgxaRY1jfRteRYQZ6kYuRM5GMkYmRkGAEAWEmMFZbYABgQFGAgwOBYACHgDsVgBVhBpRXYACA/VtQWvEVgBVhBqhXPWAAgD49YAD9W1BQUFBbhjNgAWABYKAbAxZ/cbq2XO0uV1B3WgYTvgZ99I7wbPkqSW6/dmOuBmCSSVSEYEBRYQbnkZBhJidWW2BAUYCRA5CjUFBQUFBQUFZbYEBRY3CggjFg4BuBUmAAkGABYAFgoBsDgxaQY3CggjGQYQcnkDOQYAQBYSGpVltgIGBAUYCDA4GGgDsVgBVhBz9XYACA/VtQWvoVgBVhB1NXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQd3kZBhII9WW5BQgGEHn1dgQFFiRhvNYOUbgVJgBAFhB5aQYSKbVltgQFGAkQOQ/VthB7RgAWABYKAbA4MWMzCEYRybVltgQFFjCV6ns2DgG4FSYAFgAWCgGwODFpBjCV6ns5BhCAKQfwAAAAAAAAAAAAAAAB8e0hS+9eg9j10OtdcBHrll0NebkIWQYAQBYSHhVltgIGBAUYCDA4FgAIeAOxWAFWEIHFdgAID9W1Ba8RWAFWEIMFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhCFSRkGEf8VZbUGBAUWMcV3YrYOMbgVJgAWABYKAbA38AAAAAAAAAAAAAAAAfHtIUvvXoPY9dDrXXAR65ZdDXmxaQY+K7sViQYQjDkH8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB5CFkGAEAWEmb1ZbYABgQFGAgwOBYACHgDsVgBVhCN1XYACA/VtQWvEVgBVhCPFXPWAAgD49YAD9W1BQYEBRf5ipvTt6YXWB/FOx4pklNODgy1CRydRKoaf8l49wbKqDklBgAJFQoVBQVltgAIKBUmAEYCCQgVJgQICDIDOEUpCRUoEggFSCglVgAYIBg5BVYAOAVJKTkZKGkIEQYQlZV/5bYACRglJgIJCRIAFUYAFgAWCgGwMWkFCAFWEJ3ldgQFFjWN9G12DgG4FSYAFgAWCgGwOCFpBjWN9G15BhCauQiJAzkImQYACQgZBgBAFhJjBWW2AAYEBRgIMDgWAAh4A7FYAVYQnFV2AAgP1bUFrxFYAVYQnZVz1gAIA+PWAA/VtQUFBQW2EJ8ISDYAKIgVSBEGEEnVf+W4NgAWABYKAbAxaFM2ABYAFgoBsDFn8srF4g4VQdg2OBUnpD9lGFHjAoF7cdyOgQKE5pIQwca4VgQFFhCjSRkGEmJ1ZbYEBRgJEDkKRQUFBQUFZbYEBRYxxXditg4xuBUmABYAFgoBsDfwAAAAAAAAAAAAAAAB8e0hS+9eg9j10OtdcBHrll0NebFpBj4ruxWJBhCrKQfwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHkGAAkGAEAWEmb1ZbYABgQFGAgwOBYACHgDsVgBVhCsxXYACA/VtQWvEVgBVhCuBXPWAAgD49YAD9W1BQUFBWW2EK7mEfRlZbYAGCgVSBEGEK+1f+W2AAkYJSYCCRgpAgYECAUWBggQGCUpKQkQFUYAFgAWCAGwOBFoNSZ///////////YAFggBuCBIEWlIQBhZBSYAFgwBuQkQQWkIIBUpFQQxEVYQ2HV2AAYAKDgVSBEGELXlf+W2AAkYJSYCCQkSABVGBAUWNwoIIxYOAbgVJgAWABYKAbA5CRFpBjcKCCMZBhC5eQMJBgBAFhIalWW2AgYEBRgIMDgYaAOxWAFWELr1dgAID9W1Ba+hWAFWELw1c9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhC+eRkGEgj1ZbkFCAFWEMj1dgAGEMEoNgIAFRZ///////////FkNhG8qQkZBj/////xZWW5BQYABgBVRhDEOFYEABUWf//////////xZhDD1hDDZhDeBWW4aQYRtAVluQYRtAVluBYQxKV/5bBJBQYQyBYQxwhGEMY4Rk6NSlEABhG0BWW4FhDGpX/lsEYRy8VluFUWABYAFggBsDFpBhHOVWW2ABYAFggBsDFoRSUFBbYQyYQ2EdFFZbZ///////////FmAggwFSYAGAVIORkIWQgRBhDLhX/ltgAJGCUmAgkYKQIINRkQGAVISEAVFgQJWGAVFv/////////////////////xmQkhZgAWABYIAbA5CUFpOQkxdn//////////9ggBsZFmABYIAbZ///////////lIUWAhd3////////////////////////////////FmABYMAbk5CRFpKQkgKRkJEXkFWDAVGDUZFRhZJ/D8lUUCKlQlQa0IXQkfsJoqs2/uNmpFdqtjcU6pB601OSYQ19kpCRhpFhJn1WW2BAUYCRA5CiUFuRkFBWW4BgAFuBgRAVYQrgV2ENs4SEg4GBEGENp1f+W5BQYCACATVhCuZWW1BgAQFhDZBWW38AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB4FWW2AAfwAAAAAAAAAAAAAAAB8e0hS+9eg9j10OtdcBHrll0NebYAFgAWCgGwMWYxfK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lIWQIIRRkgGAVJWFAVFgQJCVAVGEFmABYMAbAnf///////////////////////////////+VkJQWYAFggBsCZ///////////YIAbGWABYAFggBsDkJQWb/////////////////////8ZkJcWlpCWF5KQkhaUkJQXkpCSFheQVWACVGABYAFgoBsDgIUWkpCGFpFhFbKRYRvKVlt/ge4PjFxG4stBmEiG93qEGBckq7hsMqX23lObB1CdReWHYEBRYRXhkZBhJidWW2BAUYCRA5CkUFBQUFZbYABhFflhH0ZWW2ABhIFUgRBhFgZX/ltgAJGCUmAggIMgYECAUWBggQGCUpGQkwFUYAFgAWCAGwOAghaDUmf//////////2ABYIAbgwSBFoSGAVJgAWDAG5CSBJCRFoKFAVKIhVJgBINSg4UgYAFgAWCgGwOJFoZSkJJSkYMgglFgAoBUlJZQkZSSFpKIkIEQYRaFV/5bYACRglJgIJCRIAFUYEBRY3CggjFg4BuBUmABYAFgoBsDkJEWkGNwoIIxkGEWvpAwkGAEAWEhqVZbYCBgQFGAgwOBhoA7FYAVYRbWV2AAgP1bUFr6FYAVYRbqVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEXDpGQYSCPVluQUINgIAFRZ///////////FkMRgBVhFyxXUIAVFVsVYReqV2AAYRdUhWAgAVFn//////////8WQ2EbypCRkGP/////FlZbkFBgAGAFVGEXeIdgQAFRZ///////////FmEMPWEMNmEN4FZbgWEXf1f+WwSQUGEXpYNhF5WDZOjUpRAAYRtAVluBYRecV/5bhpGQBGEdQlZbk1BQUFtgAYMBVINUYRfYkWEF0ZFk6NSlEACQYRfKkIdhG0BWW4FhF9FX/lsEkGEbfVZbl5ZQUFBQUFBQVltgA4GBVIEQYRB4V/5bYRf4YQpDVlthGABhH0ZWW2EYCYRhCuZWW2AAhYFSYARgIJCBUmBAgIMgM4RSkJFSgSCCUYFUk5RQkJJk6NSlEACRYRhFkZBgAWABYIAbAxZhG0BWW4FhGExX/lsEkFBgAGEYa2EF0YRgAQFUhGEbfZCRkGP/////FlZbkFBhGKZk6NSlEABhGJaGYAABUWABYAFggBsDFolhG0CQkZBj/////xZWW4FhGJ1X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"
            },
            {
                "key": "BwM+ByIkGNgSVCOLutyYWdG6cW9X0g==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwNKRQddPnUvNnZhD8Qn9eaRXOY6Yw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOEsSOHXw82uWbQtsoUsxEhvZZ2rQ==",
                "proof": [],
                "value": "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FpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACAYAVgAJBUkGEBAAqQBGABYAFgoBsDFmABYAFgoBsDFmMBfn5YYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYSAkV2AAgP1bUFr6FYAVYSA4Vz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYSBOV2AAgP1bUFFgC1RgAWABYKAbA4IWFYAVlFCRklCQYSD/V4AVYSD6V2AAYSCLYRBZYAFgAWBwGwOIgRaQiBZhHChWW5BQYABhIJiDYSETVluQUICCERVhIPdXYABhILphILGEhGEclFZbYABUkGEcKFZbkFBgAGEg04NhIM2GYAVhHChWW5BhItBWW5BQYACBg4FhIOBX/lsEkFCAFWEg81dhIPOHgmEhZVZbUFBQW1BQW2EhC1ZbgBVhIQtXYABgC1VbUFCSkVBQVltgAGADghEVYSFWV1CAYAFgAoIEAVuBgRAVYSFQV4CRUGACgYKFgWEhP1f+WwQBgWEhSFf+WwSQUGEhKFZbUGEhYFZbgRVhIWBXUGABW5GQUFZbYABUYSFykIJhItBWW2AAkIFVYAFgAWCgGwODFoFSYAFgIFJgQJAgVGEhl5CCYSLQVltgAWABYKAbA4MWYACBgVJgAWAgkIFSYECAgyCUkJRVg1GFgVKTUZKTkZJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SgZADkJEBkKNQUFZbYACBgxBhIf5XgWEiAFZbgluTklBQUFZbYAFgAWCgGwOCFmAAkIFSYAFgIFJgQJAgVGEiKpCCYRyUVltgAWABYKAbA4MWYACQgVJgAWAgUmBAgSCRkJFVVGEiUZCCYRyUVltgAJCBVWBAgFGDgVKQUWABYAFgoBsDhRaRf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkZCBkANgIAGQo1BQVltgAWABYHAbAxZgAWBwGwKQVltgAGABYAFgcBsDghZgAWABYOAbA4QWgWEiyFf+WwSTklBQUFZbgIIBgoEQFWELaFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1hZGQtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9/lVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX09VVFBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlfQlVSTkVEVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZX01JTlRFRKFkc29sY0MABgwACg=="
            },
            {
                "key": "BwOTeWSLIvUofHblZf6CqxmsuJmmMQ==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEB+ldgADVg4ByAY4CTWqkRYQEaV4BjtrVfJRFhAK1XgGPZ8wanEWEAfFeAY9nzBqcUYQVvV4Bj7MhDuBRhBY1XgGPvGTjIFGEFq1eAY/L944sUYQXbV4Bj+x2yeBRhBfdXYQH6VluAY7a1XyUUYQTnV4BjvU3puxRhBQNXgGPA7iR/FGEFIVeAY8hNY6sUYQU/V2EB+lZbgGOswhZqEWEA6VeAY6zCFmoUYQRxV4BjrlxS7BRhBI9XgGOzTIyvFGEEmVeAY7PwBnQUYQTJV2EB+lZbgGOAk1qpFGEEDVeAY4Ep/BwUYQQrV4BjgXsc0hRhBDVXgGONpctbFGEEU1dhAfpWW4BjPRi5EhFhAZJXgGNlSyTXEWEBYVeAY2VLJNcUYQOFV4BjcKCCMRRhA7VXgGNxUBimFGED5VeAY3mRB7UUYQPvV2EB+lZbgGM9GLkSFGEDI1eAY0JIsgwUYQMtV4BjRkElfRRhA0tXgGNK4oWcFGEDVVdhAfpWW4BjLhp9TRFhAc5XgGMuGn1NFGECm1eAYzKYDkMUYQK3V4BjOpjvORRhAtVXgGM6+eZpFGEC81dhAfpWW4BijMJiFGEB/1eAYwNYdNEUYQIvV4BjF7TE0xRhAk1XgGMdx/UhFGECa1dbYACA/VthAhlgBIA2A4EBkGECFJGQYTgpVlthBhVWW2BAUWECJpGQYThvVltgQFGAkQOQ81thAjdhBtZWW2BAUWECRJGQYThvVltgQFGAkQOQ81thAlVhB3dWW2BAUWECYpGQYTjpVltgQFGAkQOQ81thAoVgBIA2A4EBkGECgJGQYTkwVlthB49WW2BAUWECkpGQYThvVltgQFGAkQOQ81thArVgBIA2A4EBkGECsJGQYTkwVlthCdJWWwBbYQK/YQ8sVltgQFFhAsyRkGE46VZbYEBRgJEDkPNbYQLdYQ9EVltgQFFhAuqRkGE4b1ZbYEBRgJEDkPNbYQMNYASANgOBAZBhAwiRkGE4KVZbYQ9KVltgQFFhAxqRkGE4b1ZbYEBRgJEDkPNbYQMrYRBMVlsAW2EDNWET/1ZbYEBRYQNCkZBhOWxWW2BAUYCRA5DzW2EDU2EUF1ZbAFthA29gBIA2A4EBkGEDapGQYTmHVlthGKVWW2BAUWEDfJGQYThvVltgQFGAkQOQ81thA59gBIA2A4EBkGEDmpGQYTgpVlthGOhWW2BAUWEDrJGQYThvVltgQFGAkQOQ81thA89gBIA2A4EBkGEDypGQYTgpVlthGX9WW2BAUWED3JGQYThvVltgQFGAkQOQ81thA+1hGftWWwBbYQP3YRs4VltgQFFhBASRkGE56FZbYEBRgJEDkPNbYQQVYRtQVltgQFFhBCKRkGE6JFZbYEBRgJEDkPNbYQQzYRtoVlsAW2EEPWEcilZbYEBRYQRKkZBhOG9WW2BAUYCRA5DzW2EEW2EdH1ZbYEBRYQRokZBhOWxWW2BAUYCRA5DzW2EEeWEdSVZbYEBRYQSGkZBhOmBWW2BAUYCRA5DzW2EEl2EdYVZbAFthBLNgBIA2A4EBkGEErpGQYTgpVlthHnFWW2BAUWEEwJGQYThvVltgQFGAkQOQ81thBNFhHolWW2BAUWEE3pGQYTlsVltgQFGAkQOQ81thBQFgBIA2A4EBkGEE/JGQYTkwVlthHq9WWwBbYQULYSQgVltgQFFhBRiRkGE5bFZbYEBRgJEDkPNbYQUpYSQ4VltgQFFhBTaRkGE46VZbYEBRgJEDkPNbYQVZYASANgOBAZBhBVSRkGE4KVZbYSRQVltgQFFhBWaRkGE4b1ZbYEBRgJEDkPNbYQV3YSRoVltgQFFhBYSRkGE46VZbYEBRgJEDkPNbYQWVYSSAVltgQFFhBaKRkGE4b1ZbYEBRgJEDkPNbYQXFYASANgOBAZBhBcCRkGE4KVZbYSSFVltgQFFhBdKRkGE4b1ZbYEBRgJEDkPNbYQX1YASANgOBAZBhBfCRkGE4KVZbYSSdVlsAW2EF/2EmSVZbYEBRYQYMkZBhOpxWW2BAUYCRA5DzW2AAYQPoYGZgAIRz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgVGEGZJGQYTrmVlthBm2DYRl/VlsQYQbMV2BmYACDc///////////////////////////FnP//////////////////////////xaBUmAgAZCBUmAgAWAAIFRhBruDYRl/VlthBsWRkGE7PFZbkFBhBtFWW2AAkFBbkZBQVltgAIBgAHM4OJVnELzJ0SLdI4Y6BUnKjVZ11nP//////////////////////////xZjk/GkC2AXMGBAUYNj/////xZg4BuBUmAEAWEHK5KRkGE7cFZbYECAUYCDA4GGWvoVgBVhB0dXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQdrkZBhO+RWW5FQkVCBklBQUJBWW3PCH/ASKemC18i4aRFjsKPLjzV0U4FWW2AAgHNKRQddPnUvNnZhD8Qn9eaRXOY6Y3P//////////////////////////xZjGBYN3WBAUYFj/////xZg4BuBUmAEAWAgYEBRgIMDgYZa+hWAFWEH8Vc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhCBWRkGE8JFZbc0pFB10+dS82dmEPxCf15pFc5jpjc///////////////////////////FmOPhA3dYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhlr6FYAVYQh0Vz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEImJGQYTwkVltzSkUHXT51LzZ2YQ/EJ/XmkVzmOmNz//////////////////////////8WY0e9NxhgQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGWvoVgBVhCPdXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQkbkZBhPCRWW3NKRQddPnUvNnZhD8Qn9eaRXOY6Y3P//////////////////////////xZjOx0homBAUYFj/////xZg4BuBUmAEAWAgYEBRgIMDgYZa+hWAFWEJelc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhCZ6RkGE8JFZbYQmokZBhOuZWW2EJspGQYTs8VlthCbyRkGE8gFZbkFCAg2EJypGQYTyxVluRUFCRkFBWW2EJ2mEmYVZbc///////////////////////////FmEJ+GEdH1Zbc///////////////////////////FhRhCk5XYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhCkWQYT1oVltgQFGAkQOQ/VtgAGEKmYJgZmAAM3P//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBUYSZpVluQUGAAYQsFYQqoYRyKVltgZVSEYQq2kZBhPLFWW2EKwJGQYTyAVltgZ2AAM3P//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBUYSZpVluQUIBgZWAAgoJUYQsZkZBhOzxWW5JQUIGQVVCAYGdgADNz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgYACCglRhC2+RkGE7PFZbklBQgZBVUIFgZmAAM3P//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBgAIKCVGELxZGQYTs8VluSUFCBkFVQYABzxCwwrGzBX6yb2Thhi8qhofroUB1z//////////////////////////8WY3CggjEwYEBRgmP/////FmDgG4FSYAQBYQwbkZBhOWxWW2AgYEBRgIMDgYZa+hWAFWEMOFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhDFyRkGE8JFZbkFBzSkUHXT51LzZ2YQ/EJ/XmkVzmOmNz//////////////////////////8WY9sAanWEYEBRgmP/////FmDgG4FSYAQBYQyrkZBhOG9WW2AAYEBRgIMDgWAAh4A7FYAVYQzFV2AAgP1bUFrxFYAVYQzZVz1gAIA+PWAA/VtQUFBQYACBc8QsMKxswV+sm9k4YYvKoaH66FAdc///////////////////////////FmNwoIIxMGBAUYJj/////xZg4BuBUmAEAWENLZGQYTlsVltgIGBAUYCDA4GGWvoVgBVhDUpXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQ1ukZBhPCRWW2ENeJGQYTs8VluQUGAAYQ3FgmBoYAAzc///////////////////////////FnP//////////////////////////xaBUmAgAZCBUmAgAWAAIFRhGKVWW5BQYACBERVhDoZXc8QsMKxswV+sm9k4YYvKoaH66FAdc///////////////////////////FmOpBZy7YGlgAJBUkGEBAAqQBHP//////////////////////////xaDYEBRg2P/////FmDgG4FSYAQBYQ5BkpGQYT2IVltgIGBAUYCDA4FgAIda8RWAFWEOYFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhDoSRkGE96VZbUFtzxCwwrGzBX6yb2Thhi8qhofroUB1z//////////////////////////8WY6kFnLszg4VhDsORkGE7PFZbYEBRg2P/////FmDgG4FSYAQBYQ7gkpGQYT2IVltgIGBAUYCDA4FgAIda8RWAFWEO/1c9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhDyORkGE96VZbUFBQUFBQUFZbc8QsMKxswV+sm9k4YYvKoaH66FAdgVZbYGVUgVZbYACAYGVUFBVhD19XYACQUGEQR1ZbYGVUYGdgAIRz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgVHNKRQddPnUvNnZhD8Qn9eaRXOY6Y3P//////////////////////////xZjOvnmaYVgQFGCY/////8WYOAbgVJgBAFhD++RkGE5bFZbYCBgQFGAgwOBhlr6FYAVYRAMVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEQMJGQYTwkVlthEDqRkGE8sVZbYRBEkZBhPIBWW5BQW5GQUFZbYRBUYSZhVltz//////////////////////////8WYRByYR0fVltz//////////////////////////8WFGEQyFdgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWEQv5BhPWhWW2BAUYCRA5D9W2AAYRDTM2EGFVZbkFBgAGERP2EQ4mEcilZbYGVUhGEQ8JGQYTyxVlthEPqRkGE8gFZbYGdgADNz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgVGEmaVZbkFCAYGVgAIKCVGERU5GQYTs8VluSUFCBkFVQgGBnYAAzc///////////////////////////FnP//////////////////////////xaBUmAgAZCBUmAgAWAAIGAAgoJUYRGpkZBhOzxWW5JQUIGQVVBhEbhhJoJWW2AAc8QsMKxswV+sm9k4YYvKoaH66FAdc///////////////////////////FmNwoIIxMGBAUYJj/////xZg4BuBUmAEAWESB5GQYTlsVltgIGBAUYCDA4GGWvoVgBVhEiRXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRJIkZBhPCRWW5BQc0pFB10+dS82dmEPxCf15pFc5jpjc///////////////////////////FmPbAGp1hGBAUYJj/////xZg4BuBUmAEAWESl5GQYThvVltgAGBAUYCDA4FgAIeAOxWAFWESsVdgAID9W1Ba8RWAFWESxVc9YACAPj1gAP1bUFBQUGAAgXPELDCsbMFfrJvZOGGLyqGh+uhQHXP//////////////////////////xZjcKCCMTBgQFGCY/////8WYOAbgVJgBAFhExmRkGE5bFZbYCBgQFGAgwOBhlr6FYAVYRM2Vz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGETWpGQYTwkVlthE2SRkGE7PFZbkFBzxCwwrGzBX6yb2Thhi8qhofroUB1z//////////////////////////8WY6kFnLszg2BAUYNj/////xZg4BuBUmAEAWETtZKRkGE9iFZbYCBgQFGAgwOBYACHWvEVgBVhE9RXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRP4kZBhPelWW1BQUFBQVltzt2EI63ZLRCdQXEuwIKN9lbPvWv6BVltgAHOfH5M8ZgodyFbw4P4FhDWHnFzO8HP//////////////////////////xZjcKCCMTBgQFGCY/////8WYOAbgVJgBAFhFGaRkGE5bFZbYCBgQFGAgwOBhlr6FYAVYRSDVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEUp5GQYTwkVluQUGAAc8If8BIp6YLXyLhpEWOwo8uPNXRTc///////////////////////////FmNwoIIxMGBAUYJj/////xZg4BuBUmAEAWEU+JGQYTlsVltgIGBAUYCDA4GGWvoVgBVhFRVXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRU5kZBhPCRWW5BQYRVDYSc3VltgAGADZ///////////gREVYRVgV2EVX2E+FlZbW2BAUZCAglKAYCACYCABggFgQFKAFWEVjleBYCABYCCCAoA2gzeAggGRUFCQUFtQkFBz+pQ0hGf2TVpFf3X4vEBJXTPGWruBYACBUYEQYRW6V2EVuWE+RVZbW2AgAmAgAQGQc///////////////////////////FpCBc///////////////////////////FoFSUFBzxCwwrGzBX6yb2Thhi8qhofroUB2BYAGBUYEQYRYdV2EWHGE+RVZbW2AgAmAgAQGQc///////////////////////////FpCBc///////////////////////////FoFSUFBznx+TPGYKHchW8OD+BYQ1h5xczvCBYAKBUYEQYRaAV2EWf2E+RVZbW2AgAmAgAQGQc///////////////////////////FpCBc///////////////////////////FoFSUFBhF1GBc/qUNIRn9k1aRX91+LxASV0zxlq7c///////////////////////////FmNwoIIxMGBAUYJj/////xZg4BuBUmAEAWEXC5GQYTlsVltgIGBAUYCDA4GGWvoVgBVhFyhXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRdMkZBhPCRWW2Ep1lZbUGAAg3OfH5M8ZgodyFbw4P4FhDWHnFzO8HP//////////////////////////xZjcKCCMTBgQFGCY/////8WYOAbgVJgBAFhF6KRkGE5bFZbYCBgQFGAgwOBhlr6FYAVYRe/Vz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEX45GQYTwkVlthF+2RkGE7PFZbkFBhF/iBYSwOVltgAINzwh/wEinpgtfIuGkRY7Cjy481dFNz//////////////////////////8WY3CggjEwYEBRgmP/////FmDgG4FSYAQBYRhIkZBhOWxWW2AgYEBRgIMDgYZa+hWAFWEYZVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhGImRkGE8JFZbYRiTkZBhOzxWW5BQYRiegWExm1ZbUFBQUFBWW2AAYgP0gIJCYRi3kZBhOzxWWxAVYRjdV2ED6GED44RhGM6RkGE8sVZbYRjYkZBhPIBWW2EY4FZbYABbkFCSkVBQVltgAIBhGPxhGPeEYRl/VlthB49WW5BQYABhGUhgZmAAhnP//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACBUYQePVluQUGED6IFhGViRkGE65lZbghBhGXNXgIJhGWqRkGE7PFZbklBQUGEZelZbYACSUFBQW5GQUFZbYACAYGVUFBVhGZRXYACQUGEZ9lZbYGVUYGdgAIRz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgVGEZ32EcilZbYRnpkZBhPLFWW2EZ85GQYTyAVluQUFuRkFBWW2EaA2EmYVZbc///////////////////////////FmEaIWEdH1Zbc///////////////////////////FhRhGndXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhGm6QYT1oVltgQFGAkQOQ/VtgAHP//////////////////////////xZgM2AAkFSQYQEACpAEc///////////////////////////FnP//////////////////////////xZ/i+AHnFMWWRQTRM0f0KTyhBlJf5cio9qv47QYb2tkV+BgQFFgQFGAkQOQo2AAYDNgAGEBAAqBVIFz//////////////////////////8CGRaQg3P//////////////////////////xYCF5BVUFZbc0pFB10+dS82dmEPxCf15pFc5jpjgVZbcyy0XttFF9WUev3jvqv5WlglBoWLgVZbYABgAZBUkGEBAAqQBGD/FoBhG45XUGAAgFSQYQEACpAEYP8WFVthG81XYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhG8SQYT7mVltgQFGAkQOQ/VtgAIBgAZBUkGEBAAqQBGD/FhWQUIAVYRwdV2ABYABgAWEBAAqBVIFg/wIZFpCDFRUCF5BVUGABYACAYQEACoFUgWD/AhkWkIMVFQIXkFVQW2EcJWEzS1ZbM2BpYABhAQAKgVSBc///////////////////////////AhkWkINz//////////////////////////8WAheQVVCAFWEch1dgAIBgAWEBAAqBVIFg/wIZFpCDFRUCF5BVUFtQVltgAHNKRQddPnUvNnZhD8Qn9eaRXOY6Y3P//////////////////////////xZjcKCCMTBgQFGCY/////8WYOAbgVJgBAFhHNmRkGE5bFZbYCBgQFGAgwOBhlr6FYAVYRz2Vz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEdGpGQYTwkVluQUJBWW2AAYDNgAJBUkGEBAAqQBHP//////////////////////////xaQUJBWW3PXqBKl0syW54yDsDJMgiae6CrxyIFWW2EdaWEmYVZbc///////////////////////////FmEdh2EdH1Zbc///////////////////////////FhRhHd1XYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhHdSQYT1oVltgQFGAkQOQ/VtzODiVZxC8ydEi3SOGOgVJyo1WddZz//////////////////////////8WYwrVjS9gF2EeF2EG1lZbYR4fYR0fVltgQFGEY/////8WYOAbgVJgBAFhHj2TkpGQYT8GVltgAGBAUYCDA4FgAIeAOxWAFWEeV1dgAID9W1Ba8RWAFWEea1c9YACAPj1gAP1bUFBQUFZbYGdgIFKAYABSYEBgACBgAJFQkFBUgVZbYGlgAJBUkGEBAAqQBHP//////////////////////////xaBVlthHrdhJmFWW3P//////////////////////////xZhHtVhHR9WW3P//////////////////////////xYUYR8rV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYR8ikGE9aFZbYEBRgJEDkP1bYABhHzVhHIpWW5BQYABzxCwwrGzBX6yb2Thhi8qhofroUB1z//////////////////////////8WY3CggjEwYEBRgmP/////FmDgG4FSYAQBYR+GkZBhOWxWW2AgYEBRgIMDgYZa+hWAFWEfo1c9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhH8eRkGE8JFZbkFBzxCwwrGzBX6yb2Thhi8qhofroUB1z//////////////////////////8WYyO4ct0zMIZgQFGEY/////8WYOAbgVJgBAFhIBqTkpGQYT89VltgIGBAUYCDA4FgAIda8RWAFWEgOVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhIF2RkGE96VZbUGAAc8QsMKxswV+sm9k4YYvKoaH66FAdc///////////////////////////FmNwoIIxMGBAUYJj/////xZg4BuBUmAEAWEgrZGQYTlsVltgIGBAUYCDA4GGWvoVgBVhIMpXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYSDukZBhPCRWW5BQgYFhIPyRkGE7PFZbk1BhITBzxCwwrGzBX6yb2Thhi8qhofroUB1zSkUHXT51LzZ2YQ/EJ/XmkVzmOmNhNDRWW2AAc0pFB10+dS82dmEPxCf15pFc5jpjc///////////////////////////FmNwoIIxMGBAUYJj/////xZg4BuBUmAEAWEhf5GQYTlsVltgIGBAUYCDA4GGWvoVgBVhIZxXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYSHAkZBhPCRWW5BQc0pFB10+dS82dmEPxCf15pFc5jpjc///////////////////////////FmOgcS1ohmBAUYJj/////xZg4BuBUmAEAWEiD5GQYThvVltgAGBAUYCDA4FgAIeAOxWAFWEiKVdgAID9W1Ba8RWAFWEiPVc9YACAPj1gAP1bUFBQUGAAgXNKRQddPnUvNnZhD8Qn9eaRXOY6Y3P//////////////////////////xZjcKCCMTBgQFGCY/////8WYOAbgVJgBAFhIpGRkGE5bFZbYCBgQFGAgwOBhlr6FYAVYSKuVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEi0pGQYTwkVlthItyRkGE7PFZbkFBgAIBgZVQUFWEi8leBkFBhIw5WW4VgZVSDYSMBkZBhPLFWW2EjC5GQYTyAVluQUFuAYGVgAIKCVGEjIJGQYTrmVluSUFCBkFVQgGBnYAAzc///////////////////////////FnP//////////////////////////xaBUmAgAZCBUmAgAWAAIGAAgoJUYSN2kZBhOuZWW5JQUIGQVVCBYGZgADNz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgYACCglRhI8yRkGE65lZbklBQgZBVUEJgaGAAM3P//////////////////////////xZz//////////////////////////8WgVJgIAGQgVJgIAFgACCBkFVQUFBQUFBQUFZbc7vz1CgfEOU31bE8qAviI2IxCyv5gVZbc58fkzxmCh3IVvDg/gWENYecXM7wgVZbYGhgIFKAYABSYEBgACBgAJFQkFBUgVZbc/qUNIRn9k1aRX91+LxASV0zxlq7gVZbYBeBVltgZmAgUoBgAFJgQGAAIGAAkVCQUFSBVlthJKVhJmFWW3P//////////////////////////xZhJMNhHR9WW3P//////////////////////////xYUYSUZV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYSUQkGE9aFZbYEBRgJEDkP1bYABz//////////////////////////8WgXP//////////////////////////xYUFWEliVdgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWElgJBhP+ZWW2BAUYCRA5D9W4Bz//////////////////////////8WYDNgAJBUkGEBAAqQBHP//////////////////////////xZz//////////////////////////8Wf4vgB5xTFlkUE0TNH9Ck8oQZSX+XIqPar+O0GG9rZFfgYEBRYEBRgJEDkKOAYDNgAGEBAAqBVIFz//////////////////////////8CGRaQg3P//////////////////////////xYCF5BVUFBWW3M4OJVnELzJ0SLdI4Y6BUnKjVZ11oFWW2AAM5BQkFZbYACBgxBhJnhXgWEmelZbgluQUJKRUFBWW2AAYGdgADNz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgVJBQYACBEYAVYSbXV1BhA+iBEFsVYSc0V4BgZVRhJuqRkGE7PFZbYGWBkFVQYGdgADNz//////////////////////////8Wc///////////////////////////FoFSYCABkIFSYCABYAAgYACQVVtQVltgAGACZ///////////gREVYSdUV2EnU2E+FlZbW2BAUZCAglKAYCACYCABggFgQFKAFWEngleBYCABYCCCAoA2gzeAggGRUFCQUFtQkFBzSkUHXT51LzZ2YQ/EJ/XmkVzmOmOBYACBUYEQYSeuV2EnrWE+RVZbW2AgAmAgAQGQc///////////////////////////FpCBc///////////////////////////FoFSUFBzt2EI63ZLRCdQXEuwIKN9lbPvWv6BYAGBUYEQYSgRV2EoEGE+RVZbW2AgAmAgAQGQc///////////////////////////FpCBc///////////////////////////FoFSUFBz16gSpdLMlueMg7AyTIImnugq8chz//////////////////////////8WY3RFMq5gADCEYEBRhGP/////FmDgG4FSYAQBYSidk5KRkGFBDFZbYABgQFGAgwOBYACHgDsVgBVhKLdXYACA/VtQWvEVgBVhKMtXPWAAgD49YAD9W1BQUFBz16gSpdLMlueMg7AyTIImnugq8chz//////////////////////////8WYwlSxWNgATBgQFGDY/////8WYOAbgVJgBAFhKR+SkZBhQYVWW2AAYEBRgIMDgWAAh4A7FYAVYSk5V2AAgP1bUFrxFYAVYSlNVz1gAIA+PWAA/VtQUFBQczg4lWcQvMnRIt0jhjoFScqNVnXWc///////////////////////////FmMY/Mx2YBcwYEBRg2P/////FmDgG4FSYAQBYSmhkpGQYTtwVltgAGBAUYCDA4FgAIeAOxWAFWEpu1dgAID9W1Ba8RWAFWEpz1c9YACAPj1gAP1bUFBQUFBWW2AAgIIRFWEsA1dgAINgAIFRgRBhKfZXYSn1YT5FVltbYCACYCABAVGQUGAAhGABhlFhKhGRkGE7PFZbgVGBEGEqIldhKiFhPkVWW1tgIAJgIAEBUZBQYACBc///////////////////////////FmNwoIIxMGBAUYJj/////xZg4BuBUmAEAWEqZ5GQYTlsVltgIGBAUYCDA4GGWvoVgBVhKoRXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYSqokZBhPCRWW5BQYSrIg3MstF7bRRfVlHr9476r+VpYJQaFi2E0NFZbcyy0XttFF9WUev3jvqv5WlglBoWLc///////////////////////////FmM47Rc5hmAAiTBhAlhCYSsLkZBhOuZWW2BAUYZj/////xZg4BuBUmAEAWErK5WUk5KRkGFB31ZbYABgQFGAgwOBYACHWvEVgBVhK0pXPWAAgD49YAD9W1BQUFBgQFE9YACCPj1gHxlgH4IBFoIBgGBAUlCBAZBhK3ORkGFDY1ZbUICCc///////////////////////////FmNwoIIxMGBAUYJj/////xZg4BuBUmAEAWErrpGQYTlsVltgIGBAUYCDA4GGWvoVgBVhK8tXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYSvvkZBhPCRWW2Er+ZGQYTs8VluTUFBQUGEsCFZbYACQUFuSkVBQVltgAGEnEGELuINhLCGRkGE8sVZbYSwrkZBhPIBWW5BQYACBg2EsO5GQYTs8VluQUGAAYAJn//////////+BERVhLFpXYSxZYT4WVltbYEBRkICCUoBgIAJgIAGCAWBAUoAVYSyIV4FgIAFgIIICgDaDN4CCAZFQUJBQW1CQUHOfH5M8ZgodyFbw4P4FhDWHnFzO8IFgAIFRgRBhLLRXYSyzYT5FVltbYCACYCABAZBz//////////////////////////8WkIFz//////////////////////////8WgVJQUHPELDCsbMFfrJvZOGGLyqGh+uhQHYFgAYFRgRBhLRdXYS0WYT5FVltbYCACYCABAZBz//////////////////////////8WkIFz//////////////////////////8WgVJQUGAAYS1dgoVhKdZWW5BQYS2Rc8QsMKxswV+sm9k4YYvKoaH66FAdc0pFB10+dS82dmEPxCf15pFc5jpjYTQ0VltgAIERFWEuGldzSkUHXT51LzZ2YQ/EJ/XmkVzmOmNz//////////////////////////8WY6BxLWiCYEBRgmP/////FmDgG4FSYAQBYS3nkZBhOG9WW2AAYEBRgIMDgWAAh4A7FYAVYS4BV2AAgP1bUFrxFYAVYS4VVz1gAIA+PWAA/VtQUFBQW2AAYS4yg2AChmEuLZGQYTyAVlthKdZWW5BQYS5mc8QsMKxswV+sm9k4YYvKoaH66FAdcyy0XttFF9WUev3jvqv5WlglBoWLYTQ0VlthLphznx+TPGYKHchW8OD+BYQ1h5xczvBzLLRe20UX1ZR6/eO+q/laWCUGhYthNDRWW2AAgRGAFWEuv1dQYABgAoVhLrKRkGE8gFZbhWEuvZGQYTs8VlsRWxVhL7NXcyy0XttFF9WUev3jvqv5WlglBoWLc///////////////////////////FmPo4zcAc8QsMKxswV+sm9k4YYvKoaH66FAdc58fkzxmCh3IVvDg/gWENYecXM7whGACiWEvLJGQYTyAVluJYS83kZBhOzxWW2AAgDBhAlhCYS9JkZBhOuZWW2BAUYlj/////xZg4BuBUmAEAWEvbJiXlpWUk5KRkGFDrFZbYGBgQFGAgwOBYACHWvEVgBVhL4tXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYS+vkZBhRCpWW1BQUFthL+Vzu/PUKB8Q5TfVsTyoC+IjYjELK/lzODiVZxC8ydEi3SOGOgVJyo1WddZhNDRWW2AAc7vz1CgfEOU31bE8qAviI2IxCyv5c///////////////////////////FmNwoIIxMGBAUYJj/////xZg4BuBUmAEAWEwNJGQYTlsVltgIGBAUYCDA4GGWvoVgBVhMFFXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYTB1kZBhPCRWW5BQYACBERVhMZJXczg4lWcQvMnRIt0jhjoFScqNVnXWc///////////////////////////FmONvb5tYBdzu/PUKB8Q5TfVsTyoC+IjYjELK/lz//////////////////////////8WY3CggjEwYEBRgmP/////FmDgG4FSYAQBYTD/kZBhOWxWW2AgYEBRgIMDgYZa+hWAFWExHFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhMUCRkGE8JFZbMGBAUYRj/////xZg4BuBUmAEAWExX5OSkZBhPwZWW2AAYEBRgIMDgWAAh4A7FYAVYTF5V2AAgP1bUFrxFYAVYTGNVz1gAIA+PWAA/VtQUFBQW1BQUFBQUFBWW2AAYAJn//////////+BERVhMbhXYTG3YT4WVltbYEBRkICCUoBgIAJgIAGCAWBAUoAVYTHmV4FgIAFgIIICgDaDN4CCAZFQUJBQW1CQUHPCH/ASKemC18i4aRFjsKPLjzV0U4FgAIFRgRBhMhJXYTIRYT5FVltbYCACYCABAZBz//////////////////////////8WkIFz//////////////////////////8WgVJQUHPELDCsbMFfrJvZOGGLyqGh+uhQHYFgAYFRgRBhMnVXYTJ0YT5FVltbYCACYCABAZBz//////////////////////////8WkIFz//////////////////////////8WgVJQUGAAYTK7goRhKdZWW5BQYACBERVhM0ZXc0pFB10+dS82dmEPxCf15pFc5jpjc///////////////////////////FmOgcS1ogmBAUYJj/////xZg4BuBUmAEAWEzE5GQYThvVltgAGBAUYCDA4FgAIeAOxWAFWEzLVdgAID9W1Ba8RWAFWEzQVc9YACAPj1gAP1bUFBQUFtQUFBWW2AAYAGQVJBhAQAKkARg/xaAYTNxV1BgAIBUkGEBAAqQBGD/FhVbYTOwV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYTOnkGE+5lZbYEBRgJEDkP1bYACAYAGQVJBhAQAKkARg/xYVkFCAFWE0AFdgAWAAYAFhAQAKgVSBYP8CGRaQgxUVAheQVVBgAWAAgGEBAAqBVIFg/wIZFpCDFRUCF5BVUFthNAhhNVxWW2E0EGE2NVZbgBVhNDFXYACAYAFhAQAKgVSBYP8CGRaQgxUVAheQVVBbUFZbYACCc///////////////////////////FmPdYu0+MIRgQFGDY/////8WYOAbgVJgBAFhNHGSkZBhRH1WW2AgYEBRgIMDgYZa+hWAFWE0jlc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhNLKRkGE8JFZbFBVhNVhXgXP//////////////////////////xZjCV6ns4J///////////////////////////////////////////9gQFGDY/////8WYOAbgVJgBAFhNROSkZBhPYhWW2AgYEBRgIMDgWAAh1rxFYAVYTUyVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGE1VpGQYT3pVltQW1BQVltgAGABkFSQYQEACpAEYP8WgGE1gldQYACAVJBhAQAKkARg/xYVW2E1wVdgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWE1uJBhPuZWW2BAUYCRA5D9W2AAgGABkFSQYQEACpAEYP8WFZBQgBVhNhFXYAFgAGABYQEACoFUgWD/AhkWkIMVFQIXkFVQYAFgAIBhAQAKgVSBYP8CGRaQgxUVAheQVVBbgBVhNjJXYACAYAFhAQAKgVSBYP8CGRaQgxUVAheQVVBbUFZbYABgAZBUkGEBAAqQBGD/FoBhNltXUGAAgFSQYQEACpAEYP8WFVthNppXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhNpGQYT7mVltgQFGAkQOQ/VtgAIBgAZBUkGEBAAqQBGD/FhWQUIAVYTbqV2ABYABgAWEBAAqBVIFg/wIZFpCDFRUCF5BVUGABYACAYQEACoFUgWD/AhkWkIMVFQIXkFVQW2AAYTb0YSZhVluQUIBgM2AAYQEACoFUgXP//////////////////////////wIZFpCDc///////////////////////////FgIXkFVQgHP//////////////////////////xZgAHP//////////////////////////xZ/i+AHnFMWWRQTRM0f0KTyhBlJf5cio9qv47QYb2tkV+BgQFFgQFGAkQOQo1CAFWE3tFdgAIBgAWEBAAqBVIFg/wIZFpCDFRUCF5BVUFtQVltgAGBAUZBQkFZbYACA/VtgAID9W2AAc///////////////////////////ghaQUJGQUFZbYABhN/aCYTfLVluQUJGQUFZbYTgGgWE361ZbgRRhOBFXYACA/VtQVltgAIE1kFBhOCOBYTf9VluSkVBQVltgAGAggoQDEhVhOD9XYTg+YTfBVltb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"
            },
            {
                "key": "BwOYGlLNAnzJDYFTCNRSHfLGHBta3g==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOZkKZY9xJIzFB+pilG8Ot3KEkbcA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOfH5M8ZgodyFbw4P4FhDWHnFzO8A==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOoyq81wBNgMylN0oahQFH783rtBw==",
                "proof": [],
                "value": "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FpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACAYAVgAJBUkGEBAAqQBGABYAFgoBsDFmABYAFgoBsDFmMBfn5YYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYSAkV2AAgP1bUFr6FYAVYSA4Vz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYSBOV2AAgP1bUFFgC1RgAWABYKAbA4IWFYAVlFCRklCQYSD/V4AVYSD6V2AAYSCLYRBZYAFgAWBwGwOIgRaQiBZhHChWW5BQYABhIJiDYSETVluQUICCERVhIPdXYABhILphILGEhGEclFZbYABUkGEcKFZbkFBgAGEg04NhIM2GYAVhHChWW5BhItBWW5BQYACBg4FhIOBX/lsEkFCAFWEg81dhIPOHgmEhZVZbUFBQW1BQW2EhC1ZbgBVhIQtXYABgC1VbUFCSkVBQVltgAGADghEVYSFWV1CAYAFgAoIEAVuBgRAVYSFQV4CRUGACgYKFgWEhP1f+WwQBgWEhSFf+WwSQUGEhKFZbUGEhYFZbgRVhIWBXUGABW5GQUFZbYABUYSFykIJhItBWW2AAkIFVYAFgAWCgGwODFoFSYAFgIFJgQJAgVGEhl5CCYSLQVltgAWABYKAbA4MWYACBgVJgAWAgkIFSYECAgyCUkJRVg1GFgVKTUZKTkZJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SgZADkJEBkKNQUFZbYACBgxBhIf5XgWEiAFZbgluTklBQUFZbYAFgAWCgGwOCFmAAkIFSYAFgIFJgQJAgVGEiKpCCYRyUVltgAWABYKAbA4MWYACQgVJgAWAgUmBAgSCRkJFVVGEiUZCCYRyUVltgAJCBVWBAgFGDgVKQUWABYAFgoBsDhRaRf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkZCBkANgIAGQo1BQVltgAWABYHAbAxZgAWBwGwKQVltgAGABYAFgcBsDghZgAWABYOAbA4QWgWEiyFf+WwSTklBQUFZbgIIBgoEQFWELaFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1hZGQtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9/lVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX09VVFBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlfQlVSTkVEVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZX01JTlRFRKFkc29sY0MABgwACg=="
            },
            {
                "key": "BwO21nkOEjXRbTp4O5BG7goVFkH+2g==",
                "proof": [],
                "value": "YIBgQFJgBDYQYQBZV2AANWDgHIBjCxVrthRhAHJXgGM2Wc/mFGEAnVeAY08e8oYUYQDGV4BjXGDaGxRhAOJXgGOPKDlwFGEBDVeAY/hRpEAUYQE2V2EAaFZbNmEAaFdhAGZhAWFWWwBbYQBwYQFhVlsAWzSAFWEAfldgAID9W1BhAIdhAXNWW2BAUWEAlJGQYQZkVltgQFGAkQOQ81s0gBVhAKlXYACA/VtQYQDEYASANgOBAZBhAL+RkGEGtVZbYQGCVlsAW2EA4GAEgDYDgQGQYQDbkZBhB0dWW2EB11ZbAFs0gBVhAO5XYACA/VtQYQD3YQKmVltgQFFhAQSRkGEGZFZbYEBRgJEDkPNbNIAVYQEZV2AAgP1bUGEBNGAEgDYDgQGQYQEvkZBhBrVWW2EC/lZbAFs0gBVhAUJXYACA/VtQYQFLYQQDVltgQFFhAViRkGEGZFZbYEBRgJEDkPNbYQFxYQFsYQSmVlthBNdWW1ZbYABhAX1hBKZWW5BQkFZbYQGKYQT9Vltz//////////////////////////8WM3P//////////////////////////xYUFWEBy1dhAcaBYQUuVlthAdRWW2EB02EBYVZbW1BWW2EB32EE/VZbc///////////////////////////FjNz//////////////////////////8WFBVhAphXYQIbg2EFLlZbYACDc///////////////////////////FoODYEBRYQJEkpGQYQfmVltgAGBAUYCDA4GFWvSRUFA9gGAAgRRhAn9XYEBRkVBgHxlgPz0BFoIBYEBSPYJSPWAAYCCEAT5hAoRWW2BgkVBbUFCQUIBhApJXYACA/VtQYQKhVlthAqBhAWFWW1tQUFBWW2AAYQKwYQT9Vltz//////////////////////////8WM3P//////////////////////////xYUFWEC8ldhAuthBKZWW5BQYQL7VlthAvphAWFWW1uQVlthAwZhBP1WW3P//////////////////////////xYzc///////////////////////////FhQVYQP3V2AAc///////////////////////////FoFz//////////////////////////8WFBVhA6lXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhA6CQYQiCVltgQFGAkQOQ/Vt/fmRNeUIvF8AeSJS19PWI0zHr+ihlPUKugy3FnjjJeY9hA9JhBP1WW4JgQFFhA+GSkZBhCKJWW2BAUYCRA5ChYQPygWEFfVZbYQQAVlthA/9hAWFWW1tQVltgAGEEDWEE/VZbc///////////////////////////FjNz//////////////////////////8WFBVhBE9XYQRIYQT9VluQUGEEWFZbYQRXYQFhVltbkFZbYACAYAB/xdJGAYb3IzySfn2y3McDwOUAtlPKgic7e/rYBF2FpHBgABuQUIM/kVCAghQVgBVhBJ1XUGAAgBuCFBVbklBQUJGQUFZbYACAfzYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8YAAbkFCAVJFQUJBWWzZgAIA3YACANmAAhFr0PWAAgD6AYACBFGEE+Fc9YADzWz1gAP1bYACAf7UxJ2hKVosxc64TufimAW4kPmO26O4ReNanF4ULXWEDYAAbkFCAVJFQUJBWW2EFN4FhBaxWW4Bz//////////////////////////8Wf7x811og7if9mt66syBB91UhTbxr/6kMwCJbOdouXC07YEBRYEBRgJEDkKJQVltgAH+1MSdoSlaLMXOuE7n4pgFuJD5jtujuEXjWpxeFC11hA2AAG5BQgYFVUFBWW2EFtYFhBFtWW2EF9FdgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWEF65BhCT1WW2BAUYCRA5D9W2AAfzYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8YAAbkFCBgVVQUFZbYABz//////////////////////////+CFpBQkZBQVltgAGEGToJhBiNWW5BQkZBQVlthBl6BYQZDVluCUlBQVltgAGAgggGQUGEGeWAAgwGEYQZVVluSkVBQVltgAID9W2AAgP1bYQaSgWEGQ1ZbgRRhBp1XYACA/VtQVltgAIE1kFBhBq+BYQaJVluSkVBQVltgAGAggoQDEhVhBstXYQbKYQZ/VltbYABhBtmEgoUBYQagVluRUFCSkVBQVltgAID9W2AAgP1bYACA/VtgAICDYB+EARJhBwdXYQcGYQbiVltbgjWQUGf//////////4ERFWEHJFdhByNhBudWW1tgIIMBkVCDYAGCAoMBERVhB0BXYQc/YQbsVltbklCSkFBWW2AAgGAAYECEhgMSFWEHYFdhB19hBn9WW1tgAGEHboaChwFhBqBWW5NQUGAghAE1Z///////////gREVYQePV2EHjmEGhFZbW2EHm4aChwFhBvFWW5JQklBQklCSUJJWW2AAgZBQkpFQUFZbgoGDN2AAg4MBUlBQUFZbYABhB82DhWEHp1Zbk1BhB9qDhYRhB7JWW4KEAZBQk5JQUFBWW2AAYQfzgoSGYQfBVluRUIGQUJOSUFBQVltgAIKCUmAgggGQUJKRUFBWW39UcmFuc3BhcmVudFVwZ3JhZGVhYmxlUHJveHk6IG5ld2AAggFSfyBhZG1pbiBpcyB0aGUgemVybyBhZGRyZXNzAAAAAAAAYCCCAVJQVltgAGEIbGA6g2EH/1ZbkVBhCHeCYQgQVltgQIIBkFCRkFBWW2AAYCCCAZBQgYEDYACDAVJhCJuBYQhfVluQUJGQUFZbYABgQIIBkFBhCLdgAIMBhWEGVVZbYQjEYCCDAYRhBlVWW5OSUFBQVlt/VXBncmFkZWFibGVQcm94eTogbmV3IGltcGxlbWVudGFgAIIBUn90aW9uIGlzIG5vdCBhIGNvbnRyYWN0AAAAAAAAAAAAAGAgggFSUFZbYABhCSdgNoNhB/9WW5FQYQkygmEIy1ZbYECCAZBQkZBQVltgAGAgggGQUIGBA2AAgwFSYQlWgWEJGlZbkFCRkFBW/qJkaXBmc1giEiBmxLbWDsOOU0DANofTrp4aGSfghKNZf6/40z5iZSMa12Rzb2xjQwAICgAz"
            },
            {
                "key": "BwO3YQjrdktEJ1BcS7Ago32Vs+9a/g==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwO789QoHxDlN9WxPKgL4iNiMQsr+Q==",
                "proof": [],
                "value": "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FpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACAYAVgAJBUkGEBAAqQBGABYAFgoBsDFmABYAFgoBsDFmMBfn5YYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYSAkV2AAgP1bUFr6FYAVYSA4Vz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYSBOV2AAgP1bUFFgC1RgAWABYKAbA4IWFYAVlFCRklCQYSD/V4AVYSD6V2AAYSCLYRBZYAFgAWBwGwOIgRaQiBZhHChWW5BQYABhIJiDYSETVluQUICCERVhIPdXYABhILphILGEhGEclFZbYABUkGEcKFZbkFBgAGEg04NhIM2GYAVhHChWW5BhItBWW5BQYACBg4FhIOBX/lsEkFCAFWEg81dhIPOHgmEhZVZbUFBQW1BQW2EhC1ZbgBVhIQtXYABgC1VbUFCSkVBQVltgAGADghEVYSFWV1CAYAFgAoIEAVuBgRAVYSFQV4CRUGACgYKFgWEhP1f+WwQBgWEhSFf+WwSQUGEhKFZbUGEhYFZbgRVhIWBXUGABW5GQUFZbYABUYSFykIJhItBWW2AAkIFVYAFgAWCgGwODFoFSYAFgIFJgQJAgVGEhl5CCYSLQVltgAWABYKAbA4MWYACBgVJgAWAgkIFSYECAgyCUkJRVg1GFgVKTUZKTkZJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SgZADkJEBkKNQUFZbYACBgxBhIf5XgWEiAFZbgluTklBQUFZbYAFgAWCgGwOCFmAAkIFSYAFgIFJgQJAgVGEiKpCCYRyUVltgAWABYKAbA4MWYACQgVJgAWAgUmBAgSCRkJFVVGEiUZCCYRyUVltgAJCBVWBAgFGDgVKQUWABYAFgoBsDhRaRf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkZCBkANgIAGQo1BQVltgAWABYHAbAxZgAWBwGwKQVltgAGABYAFgcBsDghZgAWABYOAbA4QWgWEiyFf+WwSTklBQUFZbgIIBgoEQFWELaFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1hZGQtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9/lVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX09VVFBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9JTlBVVF9BTU9VTlRVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlfQlVSTkVEVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZX01JTlRFRKFkc29sY0MABgwACg=="
            },
            {
                "key": "BwPCH/ASKemC18i4aRFjsKPLjzV0Uw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPGb1lCaAQdtgUH8AcDsVJJL7F25w==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPXqBKl0syW54yDsDJMgiae6CrxyA==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPcbQn1zAheKZctGSyzrc36ZJWnQQ==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPlUKiGcWJBr7fuJ25kcgfXZn4eeQ==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwP6lDSEZ/ZNWkV/dfi8QEldM8Zauw==",
                "proof": [],
                "value": "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OjpkZWxlZ2F0ZUJ5U2lnOiBzaWduYXR1cmUgZXhwaXJlZFRyaTo6c2V0TWludGVyOiBvbmx5IHRoZSBtaW50ZXIgY2FuIGNoYW5nZSB0aGUgbWludGVyIGFkZHJlc3NUcmk6Ol9tb3ZlVm90ZXM6IHZvdGUgYW1vdW50IG92ZXJmbG93c1RyaTo6bWludDogYW1vdW50IGV4Y2VlZHMgOTYgYml0c1RyaTo6bWludDogdHJhbnNmZXIgYW1vdW50IG92ZXJmbG93c1RyaTo6ZGVsZWdhdGVCeVNpZzogaW52YWxpZCBub25jZVRyaTo6X3RyYW5zZmVyVG9rZW5zOiB0cmFuc2ZlciBhbW91bnQgb3ZlcmZsb3dzVHJpOjpwZXJtaXQ6IGFtb3VudCBleGNlZWRzIDk2IGJpdHNUcmk6OnRyYW5zZmVyOiBhbW91bnQgZXhjZWVkcyA5NiBiaXRzVHJpOjpfbW92ZVZvdGVzOiB2b3RlIGFtb3VudCB1bmRlcmZsb3dzVHJpOjpfd3JpdGVDaGVja3BvaW50OiBibG9jayBudW1iZXIgZXhjZWVkcyAzMiBiaXRzoWRzb2xjQwAGDAAK"
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA+pQ0hGf2TVpFf3X4vEBJXTPGWrs="
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPnM2KHFCAAA="
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQ="
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAADCV1oOnlk8APlZ+MkvEtsoacM5WjsFAtBeJRZEb3H4dw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAmZCmWPcSSMxQfqYpRvDrdyhJG3A="
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAADCV1oOnlk8APlZ+MkvEtsoacM5WjsFAtBeJRZEb3H4eA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg="
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAADCV1oOnlk8APlZ+MkvEtsoacM5WjsFAtBeJRZEb3H4eQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPVkvk="
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAADCV1oOnlk8APlZ+MkvEtsoacM5WjsFAtBeJRZEb3H4eg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAT4BvALY2xg+jPnvTRfAA="
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAADj2GVXAyd6aurgf+gHILqA9imqWmGrQHdSaEEmB9J2Uw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQ="
            },
            {
                "key": "BwQfHtIUvvXoPY9dDrXXAR65ZdDXmwEAAADj2GVXAyd6aurgf+gHILqA9imqWmGrQHdSaEEmB9J2VA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAACIlTb18fiMe1cBc="
            },
            {
                "key": "BwQ4OJVnELzJ0SLdI4Y6BUnKjVZ11gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg="
            },
            {
                "key": "BwQ4OJVnELzJ0SLdI4Y6BUnKjVZ11gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg="
            },
            {
                "key": "BwQ4OJVnELzJ0SLdI4Y6BUnKjVZ11gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg="
            },
            {
                "key": "BwQ4OJVnELzJ0SLdI4Y6BUnKjVZ11gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF0="
            },
            {
                "key": "BwQ4OJVnELzJ0SLdI4Y6BUnKjVZ11gEAAAAKd3kbwuabhjR4yefDYDf8SubPPzAwWsZI7B4Tby0FGw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3fgnQe9pgWiiw="
            },
            {
                "key": "BwQ4OJVnELzJ0SLdI4Y6BUnKjVZ11gEAAAAKd3kbwuabhjR4yefDYDf8SubPPzAwWsZI7B4Tby0FHA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADTIU8u//KEo="
            },
            {
                "key": "BwQ4OJVnELzJ0SLdI4Y6BUnKjVZ11gEAAABAV4f6Eqgj4PK3YxzEGzuogoszIcqBERH6dc06o7ta5Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAu/PUKB8Q5TfVsTyoC+IjYjELK/k="
            },
            {
                "key": "BwQ4OJVnELzJ0SLdI4Y6BUnKjVZ11gEAAACxDi1SdhIHOybuzf1xfmoyDPRLSvrCsHMtn8vit/oNDQ==",
                "proof": [],
                "value": "AAAAAAAAAAgAAAAAA9WS+QAAAAAAAAAAAAAAAADektY="
            },
            {
                "key": "BwQ4OJVnELzJ0SLdI4Y6BUnKjVZ11gEAAADCV1oOnlk8APlZ+MkvEtsoacM5WjsFAtBeJRZEb3H4cg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA3G0J9cwIXimXLRkss63N+mSVp0E="
            },
            {
                "key": "BwQ+ByIkGNgSVCOLutyYWdG6cW9X0gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPMBrMc="
            },
            {
                "key": "BwQ+ByIkGNgSVCOLutyYWdG6cW9X0gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACr/qAeg="
            },
            {
                "key": "BwQ+ByIkGNgSVCOLutyYWdG6cW9X0gEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACbbmSo7GAAA="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA5VCohnFiQa+37iduZHIH12Z+Hnk="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAPgciJBjYElQji7rcmFnRunFvV9I="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3gtrOnZAAA="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGJnqBU="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgOOHliwWTY="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAABTR51lLuBm7hQFvQAU="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAACWpxtMtGw3yffWL4="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQECMj3+dE="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6YwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAALMxh/pnXnMk1DQBp+cN7G7B5pks="
            },
            {
                "key": "BwRKRQddPnUvNnZhD8Qn9eaRXOY6Y7EyMIkzDAKtOuosBSE88ASymzw8rMOozQNBC6hlEpHG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE15brseA="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA+pQ0hGf2TVpFf3X4vEBJXTPGWrs="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YmeoLAAAABZ9fllxu71J/MkkAAwere4Yvpw2a69+Lvc="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAEsO3Z0YkBoCuEpiclEg2E="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAB2gYjQWAZFM/xzzt8utAulq/nJAeeY="
            },
            {
                "key": "BwSEsSOHXw82uWbQtsoUsxEhvZZ2rQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwSZkKZY9xJIzFB+pilG8Ot3KEkbcAEAAADAnrkh52JvxvrNr8mdg6NfT3PyupyJd3GXRV9jP4NYwA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQ="
            },
            {
                "key": "BwSfH5M8ZgodyFbw4P4FhDWHnFzO8AEAAAAA7dDpoX0zAEPjateoY3isBS24WbkbOGBshNyWtzaR5A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAIlaJ2MKrYtfSc4="
            },
            {
                "key": "BwSfH5M8ZgodyFbw4P4FhDWHnFzO8AEAAAAPBMnu2BL1k+Afp2WAHjLwiigXyleA2h+Vvk58JSJhCg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM2fr3ep401A="
            },
            {
                "key": "BwSfH5M8ZgodyFbw4P4FhDWHnFzO8AEAAAATsGCa9HL6YPKx0xiLNqJSrvVYR1th0CEat2WENBdK2A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAowMiUie+1cPnw0="
            },
            {
                "key": "BwSfH5M8ZgodyFbw4P4FhDWHnFzO8AEAAACvpydrOoC945c3zwzE8A4E01ulqv5TpqDllXUf4XNgag==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAQjUCbk3DYgRpreI="
            },
            {
                "key": "BwSfH5M8ZgodyFbw4P4FhDWHnFzO8AEAAADylGlbky5pspDFr5rmYxBk91sKAUlaF/W41MnaZyShCQ==",
                "proof": [],
                "value": "//////////////////////////////9ASxblT85D1RY="
            },
            {
                "key": "BwSoyq81wBNgMylN0oahQFH783rtBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAwh/wEinpgtfIuGkRY7Cjy481dFM="
            },
            {
                "key": "BwSoyq81wBNgMylN0oahQFH783rtBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwSoyq81wBNgMylN0oahQFH783rtBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YmenQgAAASZlE5EagqymLPUiAAEHpAw1orgqhZUA4dw="
            },
            {
                "key": "BwSoyq81wBNgMylN0oahQFH783rtBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAGjc1/lWjyx6MIjPQnDNR3s="
            },
            {
                "key": "BwSoyq81wBNgMylN0oahQFH783rtBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAABkV0LM1jZAp6RjaJ5erffPlKU="
            },
            {
                "key": "BwSoyq81wBNgMylN0oahQFH783rtBwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwS21nkOEjXRbTp4O5BG7goVFkH+2jYIlKE7oaMhBmfIKEktuY3KPiB2zDc1qSCjylBdOCu8",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAk3lkiyL1KHx25WX+gqsZrLiZpjE="
            },
            {
                "key": "BwS3YQjrdktEJ1BcS7Ago32Vs+9a/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADeqHpyWSUJI="
            },
            {
                "key": "BwS3YQjrdktEJ1BcS7Ago32Vs+9a/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ8xFRfc4="
            },
            {
                "key": "BwS3YQjrdktEJ1BcS7Ago32Vs+9a/gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAALMxh/pnXnMk1DQBp+cN7G7B5pks="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAM1am2Axr40Zd6iHY="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxm9ZQmgEHbYFB/AHA7FSSS+xduc="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAnx+TPGYKHchW8OD+BYQ1h5xczvA="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAxCwwrGzBX6yb2Thhi8qhofroUB0="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YmeoBgACrjS6/QkjNHaM12UkAAAAQjUCbk3DYgRpreI="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAABDXlpnkGnG/w2av6v2sfu7EZQ="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAB+iZiZ4SQ9AUGv2VdZM3M="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL",
                "proof": [],
                "value": "AAAAAAAAAAAAsXevpAdN38EujzbgW+oCGq6zivFEncg="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+TozBlyRqzTcF6YqcqQ6BvUyEIBY1ahiqTbnK8TFUO9I",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAmTqxyBe+Jl4rrM="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+a5pkYDz5ShUzf22VlXuvImMV1VtcHiIhOS4qZGkstgY",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAIe952K8e8/42b0nU="
            },
            {
                "key": "BwS789QoHxDlN9WxPKgL4iNiMQsr+e102u6razNE4NqETnwk0c8wDI5I5cuCLtaFv1HJU0Cj",
                "proof": [],
                "value": "//////////////////////////////////////////8="
            },
            {
                "key": "BwTCH/ASKemC18i4aRFjsKPLjzV0UwEAAAAA7dDpoX0zAEPjateoY3isBS24WbkbOGBshNyWtzaR5A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAXdS83IpL8rxQEPGYQ="
            },
            {
                "key": "BwTCH/ASKemC18i4aRFjsKPLjzV0UwEAAAABI/Y+iK1S1ty41bagEydeeV7Hey3RgEkn/UXn5pmLEw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAEHpAw1orgqhZUA4dw="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAAABI/Y+iK1S1ty41bagEydeeV7Hey3RgEkn/UXn5pmLEw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAABJmUTkRqCrKYs9SI="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAAABU+PlwyxE7MZXYr6I3m0HwLxf5dZT9UEYAeFWQYfvqw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAfeOhetrdBfOAoxqBI="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAABBGZ77nPk3S91G2upzwBe3LZx4EFGdHcJeR3/5NHAfLA==",
                "proof": [],
                "value": "///////////////////////////dbpNf/TN8fccYgM8="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAABBnz9BYy3VD7nuZGIklR3jeBRRGsQYULpk4+cRbxIzYA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAwere4Yvpw2a69+Lvc="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAACvpydrOoC945c3zwzE8A4E01ulqv5TpqDllXUf4XNgag==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAKuNLr9CSM0dozXZSQ="
            },
            {
                "key": "BwTELDCsbMFfrJvZOGGLyqGh+uhQHQEAAADylGlbky5pspDFr5rmYxBk91sKAUlaF/W41MnaZyShCQ==",
                "proof": [],
                "value": "/////////////////////////////OoO1yQSn2qJYFE="
            },
            {
                "key": "BwTGb1lCaAQdtgUH8AcDsVJJL7F25wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA55NFXJco/JGj5aM/r/nrLyKK4VE="
            },
            {
                "key": "BwTGb1lCaAQdtgUH8AcDsVJJL7F25wEAAADSb6HY35ozelU7T933GzMOSdlv2HW5tT+9TlQQU2BRsQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAu/PUKB8Q5TfVsTyoC+IjYjELK/k="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAT0TRhJCK42fK0MsbMyoRVF12vIc="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA5VCohnFiQa+37iduZHIH12Z+Hnk="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAAAAPRWVK1tfYEwttp1CrjrwY7+ZBfgTWSaDu48TEXA6jw==",
                "proof": [],
                "value": "YmelCAAAAAAAAAAEfyBbB1HRmUR1dl/L7ks1saisUy0="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAAAHleg6BZSRCsSbZ5cO+z5iHSXA9tJus3QyixEMU+6f2A==",
                "proof": [],
                "value": "YmekzAAAAAAAAAAAAA51m18OmCDu2eO3k1zCZXj13kw="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAAASGNdapdJDFwSIS1HNHe3VbtdixGbR+bl4KsgKNlZQxw==",
                "proof": [],
                "value": "YmeoFQAAAAAAAABCxeGcxHwmDjEFZOjfARCGXxOIP+g="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAAAok1t87h3VfqewRITDbxJPwnieWz28+fOx270F9csbfQ==",
                "proof": [],
                "value": "Ymen4wAAAAAAAAAAAAAAAADAl9Gw0Y0cWKNGSo2TIFI="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAABSKn6yJwg+vPq5+eTMDew/yw19FdeKaXrASHl4lwTQAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAI53Cu437fH78gA="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAABedS8R0H71eP2v2vGe9Je2f8K/oUKthRcoON6XxJhhGw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAACi0TEQP+t/wYgA="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAABpn2QUafGjYG9nvtEymvOQC53AlbfrNP+CueumprOVZw==",
                "proof": [],
                "value": "YmeoFQAAAAAAAAAAACa70ahJ+DbVUmGpwQKHz313I+I="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAABqlWTWqUaKrht7bHVf+AOdDYiuX1IZaJGYphwIOAN8XQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAACahTD7fCLKuzN9ByulDfUyZhK0="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAABuFUAXG2wMlgtxpwINn2AHf2r5Mai79ZDaAiPaz3XHrw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAnx+TPGYKHchW8OD+BYQ1h5xczvA="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAABuFUAXG2wMlgtxpwINn2AHf2r5Mai79ZDaAiPaz3XHsA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAwh/wEinpgtfIuGkRY7Cjy481dFM="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAABvX+ZhgktRRz0Y/fYwlRXMmK6fBF8wQXjX72qi9jFHJw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAADAl9GupbRcT7Re4QuJVRM="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAABw1B46XOkwDBbAX79TEQtbmekNGzuFPNE6RNb2P3QPYw==",
                "proof": [],
                "value": "YmentgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAACRepyqdfJy6Knu2OUWJBMPPtcOIMd3k+guCATfKoWN7w==",
                "proof": [],
                "value": "Ymen4wAAAAAAAAAAAAAAAAADrhm1bai8kZ0spxK7AH0="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAACSfYeGIopdonbKpw8IBTTiUGLkCz90XyqujwjNZfefKA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABgi63ilgi8A="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAACaAM5Nl9dQL6rCiJ2H0b6x/fJdYf2REwPwaAhWjoarYw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgLo9Lh1hTg="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAACshq1IcDn5CiG7M58r+ZPgqxGk3N0sJU+WklnTnP/GCg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADhResQs2sEA="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAADNWk0We2RDodu/dYDu52hN1ZtWIKmGNwaF8Yeq2uMwJA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAABpwL9BUKegBRQtSE="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAADQuTpFKwQIv0q4RGnMkBo/qpayMocZO+oUB9ZD/QGq+g==",
                "proof": [],
                "value": "YmentgAAAAAAAAAAAAAAAADBPdLOiHiQkQQWdOpnBZo="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAADWM0Tzx/cUsSddDuyE+XKqnkLUarkwNP3LabJNIHUe2A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAABBuYaGBl9tBtVkeUEKtpMTkPrPTv0="
            },
            {
                "key": "BwTXqBKl0syW54yDsDJMgiae6CrxyAEAAAD0ONFn/EAHtvpzsDEY033HK8TZkSwCyCWCKjB5Rvy5RA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAA5jfzUF9xLRtv7XZsXtQjxJRy8="
            },
            {
                "key": "BwTcbQn1zAheKZctGSyzrc36ZJWnQQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEHcbWY="
            },
            {
                "key": "BwTcbQn1zAheKZctGSyzrc36ZJWnQQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPVkvk="
            },
            {
                "key": "BwTcbQn1zAheKZctGSyzrc36ZJWnQQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZO8ehB0jKAA="
            },
            {
                "key": "BwTcbQn1zAheKZctGSyzrc36ZJWnQQEAAAAZobUPL4MKLN9E395BztXqt9zciH2NndswfsaQlGtFpg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3fgnQe9pgWiiw="
            },
            {
                "key": "BwTcbQn1zAheKZctGSyzrc36ZJWnQQEAAAAZobUPL4MKLN9E395BztXqt9zciH2NndswfsaQlGtFpw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD522wMDM/5bY="
            },
            {
                "key": "BwTlUKiGcWJBr7fuJ25kcgfXZn4eeQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAmBpSzQJ8yQ2BUwjUUh3yxhwbWt4="
            },
            {
                "key": "BwTlUKiGcWJBr7fuJ25kcgfXZn4eeQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI="
            },
            {
                "key": "BwTlUKiGcWJBr7fuJ25kcgfXZn4eeQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA16gSpdLMlueMg7AyTIImnugq8cg="
            },
            {
                "key": "BwTlUKiGcWJBr7fuJ25kcgfXZn4eeQEAAAAxEFV7V/8sVFUdePVAVXRXkg6azv6t/nFN78UM4GU6ww==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwTlUKiGcWJBr7fuJ25kcgfXZn4eeQEAAADMlJzP0BnibUln1Uke3neDh08ICdXGz5XJvottXaFc1A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwTlUKiGcWJBr7fuJ25kcgfXZn4eeQEAAADXtpkBBXGRAdq+t3FE8qM4XIAzrNOvl+lCOmlega0etQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAASkUHXT51LzZ2YQ/EJ/XmkVzmOmM="
            },
            {
                "key": "BwTlUKiGcWJBr7fuJ25kcgfXZn4eeQEAAADXtpkBBXGRAdq+t3FE8qM4XIAzrNOvl+lCOmlega0etg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAt2EI63ZLRCdQXEuwIKN9lbPvWv4="
            },
            {
                "key": "BwT6lDSEZ/ZNWkV/dfi8QEldM8ZauwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAtxw3DfhtZ2PNNAg="
            },
            {
                "key": "BwT6lDSEZ/ZNWkV/dfi8QEldM8ZauwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAHx7SFL716D2PXQ611wEeuWXQ15s="
            },
            {
                "key": "BwT6lDSEZ/ZNWkV/dfi8QEldM8ZauwEAAACWH6TdjYa0knYcWyugZMrot7wZkqiSqcJWj1gKVWX7DA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAFn1+WXG7vUn8ySQ="
            },
            {
                "key": "BwT6lDSEZ/ZNWkV/dfi8QEldM8ZauwEAAADC1v3bDGO+bjyayaixR+I2crHnaIYwlTa2oewuBs1Z9w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAD///////////////8="
            },
            {
                "key": "BwT6lDSEZ/ZNWkV/dfi8QEldM8ZauwEAAADnSRqKC8VrEjRGsOt++SIwk4rPqIOvPHb9QUX5cue0OQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAa1CzINKnPe5oos="
            },
            {
                "key": "BwT6lDSEZ/ZNWkV/dfi8QEldM8ZauwEAAADxXayASSN7OJVQApsrKgX1mEDr6ya1WvENjQeSPusFLw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAIpeLWgLKcnw7ys="
            },
            {
                "key": "BwcfHtIUvvXoPY9dDrXXAR65ZdDXmw==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcstF7bRRfVlHr9476r+VpYJQaFiw==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwc4OJVnELzJ0SLdI4Y6BUnKjVZ11g==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwc+ByIkGNgSVCOLutyYWdG6cW9X0g==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BweZkKZY9xJIzFB+pilG8Ot3KEkbcA==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwefH5M8ZgodyFbw4P4FhDWHnFzO8A==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfCH/ASKemC18i4aRFjsKPLjzV0Uw==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfELDCsbMFfrJvZOGGLyqGh+uhQHQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfGb1lCaAQdtgUH8AcDsVJJL7F25w==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfXqBKl0syW54yDsDJMgiae6CrxyA==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfcbQn1zAheKZctGSyzrc36ZJWnQQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwflUKiGcWJBr7fuJ25kcgfXZn4eeQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwf6lDSEZ/ZNWkV/dfi8QEldM8Zauw==",
                "proof": [],
                "value": "AAAAAQ=="
            }
        ]
    }
}
'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/res/aurora_state_GdASJ3KESs.json ---
{
    "id": "1",
    "jsonrpc": "2.0",
    "result": {
        "block_hash": "6rNmxVZP7U7WgVxMizFTvW9qsjNaVkQUcFYacqTUe2kK",
        "block_height": 83596945,
        "proof": [],
        "values": [
            {
                "key": "BwBTVEFURQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5FQVMGAAAAYXVyb3JhAAAAAAAAAAAAAAAA"
            },
            {
                "key": "BwEGMDQRyR2dZnGgQBhiHHl80jDekQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEKE7wfPEQbyxZeiSX+PifRjRzWbA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEO5+A0vP8Fl7pteYmz7k0w+fMCOg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEO83fOjnVvx8c0pso2Z7vWEOvS5g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAVA="
            },
            {
                "key": "BwETinEuzJxsXHG1tp3V5O3M9hzYMw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEUGeC9xOHyxa3hXlO+2OLyebb1Ag==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEUx+8X8a8G+wVko+Aexq61p9rg1w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwEjwGu4MJq/lLZn8J9aDPdi+7+/fw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwE8KGXyRSyURa9G8cLtXPsRYlt5Fg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwE+iNewbwUmoTD9bM7tmbbgoHo6ow==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFNiozBKxx/2JNdhcDzZGIVQeaxEA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFN3EJzywCoH+bnjBm+ffkgXHllqg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwFkeizHNj5ghPLIh1GTMQfSUMj0Hg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGAUhVGawEusaVyGiK+KtXyUL7/ig==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGEKvgHT6QVg+NyCCHPFDUEnPk1ZQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGaawE5b3vnABiCY34wAn4pQmSfBg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGm6DUHzzeVUxlrfwP8JsVi6Gl7lw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGrLm6O7Dx/Er+OqFKSW0a5MavGKg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwGxmMDYl1VHNFR13pIi0WlOeuMONg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHbnsmE7PHdDISdRrFDP1Z5vx3gKQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwHwk1yq9f5/fVopXqPAFeeeH5KbTg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwH5TvpQXEUeeuAkVT0xjTHh81wy9A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY="
            },
            {
                "key": "BwIGMDQRyR2dZnGgQBhiHHl80jDekQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIKE7wfPEQbyxZeiSX+PifRjRzWbA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIO5+A0vP8Fl7pteYmz7k0w+fMCOg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIO83fOjnVvx8c0pso2Z7vWEOvS5g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwITinEuzJxsXHG1tp3V5O3M9hzYMw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIUGeC9xOHyxa3hXlO+2OLyebb1Ag==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIUx+8X8a8G+wVko+Aexq61p9rg1w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwIjwGu4MJq/lLZn8J9aDPdi+7+/fw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwI8KGXyRSyURa9G8cLtXPsRYlt5Fg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwI+iNewbwUmoTD9bM7tmbbgoHo6ow==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJNiozBKxx/2JNdhcDzZGIVQeaxEA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJN3EJzywCoH+bnjBm+ffkgXHllqg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwJkeizHNj5ghPLIh1GTMQfSUMj0Hg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKAUhVGawEusaVyGiK+KtXyUL7/ig==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKEKvgHT6QVg+NyCCHPFDUEnPk1ZQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKaawE5b3vnABiCY34wAn4pQmSfBg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKm6DUHzzeVUxlrfwP8JsVi6Gl7lw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKrLm6O7Dx/Er+OqFKSW0a5MavGKg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwKxmMDYl1VHNFR13pIi0WlOeuMONg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLbnsmE7PHdDISdRrFDP1Z5vx3gKQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwLwk1yq9f5/fVopXqPAFeeeH5KbTg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwL5TvpQXEUeeuAkVT0xjTHh81wy9A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA="
            },
            {
                "key": "BwMGMDQRyR2dZnGgQBhiHHl80jDekQ==",
                "proof": [],
                "value": "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GwOCFmEHRldgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCOBUmAgAYBhCgFgI5E5YEABkVBQYEBRgJEDkP1bYQeJgWBAUYBgYAFgQFKAYCaBUmAgAWEKRmAmkTlgAWABYKAbA4YWYACQgVJgIIGQUmBAkCBUkZBj/////2EIGBZWW2ABYAFgoBsDgIUWYACQgVJgIIGQUmBAgIIgk5CTVZCEFoFSIFRhB76QgmP/////YQivFlZbYAFgAWCgGwOAhBZgAIGBUmAggYFSYECRgpAglJCUVYBRhYFSkFGRk5KHFpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACBhIQRFWEIp1dgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSg4GBUYFSYCABkVCAUZBgIAGQgIODYABbg4EQFWEIbFeBgQFRg4IBUmAgAWEIVFZbUFBQUJBQkIEBkGAfFoAVYQiZV4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUJJQUFBgQFGAkQOQ/VtQUFCQA5BWW2AAgoIBg4EQFWEJCVdgQIBRYkYbzWDlG4FSYCBgBIIBUmAbYCSCAVJ/U2FmZU1hdGg6IGFkZGl0aW9uIG92ZXJmbG93AAAAAABgRIIBUpBRkIGQA2BkAZD9W5OSUFBQVltgAWABYKAbA4IWYQlrV2BAgFFiRhvNYOUbgVJgIGAEggFSYB9gJIIBUn9FUkMyMDogbWludCB0byB0aGUgemVybyBhZGRyZXNzAGBEggFSkFGQgZADYGQBkP1bYAJUYQl+kIJj/////2EIrxZWW2ACVWABYAFgoBsDghZgAJCBUmAggZBSYECQIFRhCaqQgmP/////YQivFlZbYAFgAWCgGwODFmAAgYFSYCCBgVJgQICDIJSQlFWDUYWBUpNRkpORkn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75KBkAOQkQGQo1BQVv5FUkMyMDogdHJhbnNmZXIgdG8gdGhlIHplcm8gYWRkcmVzc0VSQzIwOiBhcHByb3ZlIHRvIHRoZSB6ZXJvIGFkZHJlc3NFUkMyMDogdHJhbnNmZXIgYW1vdW50IGV4Y2VlZHMgYmFsYW5jZUVSQzIwOiB0cmFuc2ZlciBhbW91bnQgZXhjZWVkcyBhbGxvd2FuY2VFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzRVJDMjA6IGFwcHJvdmUgZnJvbSB0aGUgemVybyBhZGRyZXNzRVJDMjA6IGRlY3JlYXNlZCBhbGxvd2FuY2UgYmVsb3cgemVyb6JlYnp6cjFYIN+VXdyQSPN23HwhPpca+f/2wyjvOK6TNcxZRUr9oYTTZHNvbGNDAAUQADI="
            },
            {
                "key": "BwMKE7wfPEQbyxZeiSX+PifRjRzWbA==",
                "proof": [],
                "value": "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Anf///////////////////////////////+QkhaRkJEXkJNVVINRkYJSM5KCAZKQklKSFpJQfxfqvQpm+mMfdTfO/dXfaqJdWskEz3WW6VjUOnWgDQ1okQFgQFGAkQOQolBWW2AAgGAAgGAAY/////+Gaf////////////8WERVgQFGAYEABYEBSgGAPgVJgIAF/Tm8gZGF0YSBwcmVzZW50AAAAAAAAAAAAAAAAAAAAAACBUlCQYQfbV2BAUWJGG81g5RuBUmAEAWEFZ5GQYQzyVltQUFBQY/////+DFmAAkIFSYAJgIJCBUmBAkYKQIIJRgIQBkJNSVGAXgZALgIRSYAFgwBuQkQRn//////////8WkpCRAYKQUpOUkJJQgpFQhJBWW2AAY/////+CERVhCERXUGAAkZBQVltQY/////8WYACQgVJgAmAgUmBAkCBUYBcLkFZbYABj/////4IRFWEIdldQYACRkFBWW1Bj/////xZgAJCBUmACYCBSYECQIFRgAWDAG5AEZ///////////FpBWW2AAgoFSYCCBkFJgQJAgYAEBVGEIvIEzYQlNVlthBOiDg2EKaVZbYACAMzIUYQkYV2BAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSf09ubHkgY2FsbGFibGUgYnkgRU9BAAAAAAAAAAAAAAAAYESCAVJgZAFhBWdWW1BQYAFUY/////8WYACQgVJgAmAgUmBAkCBUYBeBkAuRYAFgwBuQkQRn//////////8WkFZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2EJiYFgAWABYKAbAxZgFGEK6FZbYQmUg2AgYQroVltgQFFgIAFhCaWSkZBhDj5WW2BAgFFgHxmBhAMBgVKQgpBSYkYbzWDlG4JSYQVnkWAEAWEM8lZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaEUpCRUpAggFRg/xkWYAEXkFVhCiUzkFZbYAFgAWCgGwMWgWABYAFgoBsDFoN/L4eIEX5+/x2C6SbseUkB0Xx4AkpQJwlAMEVApzNlbw1gQFFgQFGAkQOQpFBQVltgAIKBUmAggYFSYECAgyBgAWABYKAbA4UWhFKQkVKQIFRg/xYVYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaAhVKSUoCDIIBUYP8ZFpBVUTOShZF/9jkfXDLZxp0qR+pnC0QpdLU5NdHtx/1k6yHgR6g5FxuRkKRQUFZbYGBgAGEK94NgAmEOv1ZbYQsCkGACYQ7eVltn//////////+BERVhCxpXYQsaYQ72VltgQFGQgIJSgGAfAWAfGRZgIAGCAWBAUoAVYQtEV2AgggGBgDaDNwGQUFtQkFBgA2D8G4FgAIFRgRBhC19XYQtfYQ8MVltgIAEBkGABYAFg+BsDGRaQgWAAGpBTUGAPYPsbgWABgVGBEGELjldhC45hDwxWW2AgAQGQYAFgAWD4GwMZFpCBYAAakFNQYABhC7KEYAJhDr9WW2ELvZBgAWEO3lZbkFBbYAGBERVhDEJXfzAxMjM0NTY3ODlhYmNkZWYAAAAAAAAAAAAAAAAAAAAAhWAPFmAQgRBhC/5XYQv+YQ8MVlsaYPgbgoKBUYEQYQwUV2EMFGEPDFZbYCABAZBgAWABYPgbAxkWkIFgABqQU1BgBJSQlByTYQw7gWEPIlZbkFBhC8BWW1CDFWEMkVdgQFFiRhvNYOUbgVJgIGAEggGBkFJgJIIBUn9TdHJpbmdzOiBoZXggbGVuZ3RoIGluc3VmZmljaWVudGBEggFSYGQBYQVnVluTklBQUFZbYABgIIKEAxIVYQyqV2AAgP1bgTVgAWABYOAbAxmBFoEUYQyRV2AAgP1bYABbg4EQFWEM3VeBgQFRg4IBUmAgAWEMxVZbg4ERFWEM7FdgAISEAVJbUFBQUFZbYCCBUmAAglGAYCCEAVJhDRGBYECFAWAghwFhDMJWW2AfAWAfGRaRkJEBYEABkpFQUFZbYABgIIKEAxIVYQ03V2AAgP1bUDWRkFBWW2AAgGBAg4UDEhVhDVFXYACA/VuCNZFQYCCDATVgAWABYKAbA4EWgRRhDW9XYACA/VuAkVBQklCSkFBWW2AAYCCChAMSFWENjFdgAID9W4E1gGAXC4EUYQyRV2AAgP1bYABgIIKEAxIVYQ2vV2AAgP1bgTVp/////////////4EWgRRhDJFXYACA/VtgAYGBHJCCFoBhDd1XYH+CFpFQW2AgghCBFBVhDf5XY05Ie3Fg4BtgAFJgImAEUmAkYAD9W1CRkFBWW2NOSHtxYOAbYABSYBFgBFJgJGAA/VtgAGP/////gIMWgYEUFWEONFdhDjRhDgRWW2ABAZOSUFBQVlt/QWNjZXNzQ29udHJvbDogYWNjb3VudCAAAAAAAAAAAACBUmAAg1FhDnaBYBeFAWAgiAFhDMJWW38gaXMgbWlzc2luZyByb2xlIAAAAAAAAAAAAAAAAAAAAGAXkYQBkYIBUoNRYQ6zgWAohAFgIIgBYQzCVlsBYCgBlJNQUFBQVltgAIFgABkEgxGCFRUWFWEO2VdhDtlhDgRWW1ACkFZbYACCGYIRFWEO8VdhDvFhDgRWW1ABkFZbY05Ie3Fg4BtgAFJgQWAEUmAkYAD9W2NOSHtxYOAbYABSYDJgBFJgJGAA/VtgAIFhDzFXYQ8xYQ4EVltQYAAZAZBW/qFkc29sY0MACAkACg=="
            },
            {
                "key": "BwMO5+A0vP8Fl7pteYmz7k0w+fMCOg==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwMTinEuzJxsXHG1tp3V5O3M9hzYMw==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwMUGeC9xOHyxa3hXlO+2OLyebb1Ag==",
                "proof": [],
                "value": "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GwOCFmEHRldgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCOBUmAgAYBhCgFgI5E5YEABkVBQYEBRgJEDkP1bYQeJgWBAUYBgYAFgQFKAYCaBUmAgAWEKRmAmkTlgAWABYKAbA4YWYACQgVJgIIGQUmBAkCBUkZBj/////2EIGBZWW2ABYAFgoBsDgIUWYACQgVJgIIGQUmBAgIIgk5CTVZCEFoFSIFRhB76QgmP/////YQivFlZbYAFgAWCgGwOAhBZgAIGBUmAggYFSYECRgpAglJCUVYBRhYFSkFGRk5KHFpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACBhIQRFWEIp1dgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSg4GBUYFSYCABkVCAUZBgIAGQgIODYABbg4EQFWEIbFeBgQFRg4IBUmAgAWEIVFZbUFBQUJBQkIEBkGAfFoAVYQiZV4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUJJQUFBgQFGAkQOQ/VtQUFCQA5BWW2AAgoIBg4EQFWEJCVdgQIBRYkYbzWDlG4FSYCBgBIIBUmAbYCSCAVJ/U2FmZU1hdGg6IGFkZGl0aW9uIG92ZXJmbG93AAAAAABgRIIBUpBRkIGQA2BkAZD9W5OSUFBQVltgAWABYKAbA4IWYQlrV2BAgFFiRhvNYOUbgVJgIGAEggFSYB9gJIIBUn9FUkMyMDogbWludCB0byB0aGUgemVybyBhZGRyZXNzAGBEggFSkFGQgZADYGQBkP1bYAJUYQl+kIJj/////2EIrxZWW2ACVWABYAFgoBsDghZgAJCBUmAggZBSYECQIFRhCaqQgmP/////YQivFlZbYAFgAWCgGwODFmAAgYFSYCCBgVJgQICDIJSQlFWDUYWBUpNRkpORkn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75KBkAOQkQGQo1BQVv5FUkMyMDogdHJhbnNmZXIgdG8gdGhlIHplcm8gYWRkcmVzc0VSQzIwOiBhcHByb3ZlIHRvIHRoZSB6ZXJvIGFkZHJlc3NFUkMyMDogdHJhbnNmZXIgYW1vdW50IGV4Y2VlZHMgYmFsYW5jZUVSQzIwOiB0cmFuc2ZlciBhbW91bnQgZXhjZWVkcyBhbGxvd2FuY2VFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzRVJDMjA6IGFwcHJvdmUgZnJvbSB0aGUgemVybyBhZGRyZXNzRVJDMjA6IGRlY3JlYXNlZCBhbGxvd2FuY2UgYmVsb3cgemVyb6JlYnp6cjFYIN+VXdyQSPN23HwhPpca+f/2wyjvOK6TNcxZRUr9oYTTZHNvbGNDAAUQADI="
            },
            {
                "key": "BwMUx+8X8a8G+wVko+Aexq61p9rg1w==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEAqVdgADVg4ByAY0C8CvQRYQBxV4BjQLwK9BRhAUZXgGNsLfanFGEBTleAY25x4tgUYQFWV4BjjaXLWxRhAX9XgGO4FogWFGEBo1eAY/0tozkUYQHSV2EAqVZbgGMMV0hhFGEArleAYxXyQFMUYQDIV4BjIDfz5xRhAPFXgGMhkfkqFGEBIleAYybDlPcUYQE+V1tgAID9W2EAtmEB2lZbYECAUZGCUlGQgZADYCABkPNbYQC2YASANgNgYIEQFWEA3ldgAID9W1CANZBgIIEBNZBgQAE1YQHiVlthASBgBIA2A2CAgRAVYQEHV2AAgP1bUIA1kGAggQE1kGBAgQE1kGBgATVhAflWWwBbYQEqYQJUVltgQIBRkRUVglJRkIGQA2AgAZDzW2EAtmECWVZbYQC2YQJfVlthALZhAmVWW2EAtmAEgDYDYGCBEBVhAWxXYACA/VtQgDWQYCCBATWQYEABNWECa1ZbYQGHYQLBVltgQIBRYAFgAWCgGwOQkhaCUlGQgZADYCABkPNbYQC2YASANgNggIEQFWEBuVdgAID9W1CANZBgIIEBNZBgQIEBNZBgYAE1YQLQVlthALZhA09WW2MB4TOAgVZbYABhAe+EhIRhA1VWW5BQW5OSUFBQVltgAFRgAWABYKAbAxYzFGECQldgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCaBUmAgAYBhByBgJpE5YEABkVBQYEBRgJEDkP1bYQJOhISEhGEEHlZbUFBQUFZbYAGBVltgA1SBVltgAlSBVltgAVSBVltgAIJhAnpXUGAAYQHyVlthAe9hAp2DYQKRh4dj/////2EEwhZWW5Bj/////2EFJRZWW2ECtYVnDeC2s6dkAABj/////2EFZxZWW5Bj/////2EFwBZWW2AAVGABYAFgoBsDFoFWW2AAgGEC62cN4Lazp2QAAIRj/////2EFJRZWW5BQYABhAvqHh4dhA1VWW5BQYABhAxpnDeC2s6dkAABhArWEhmP/////YQVnFlZbkFBhA0NnDeC2s6dkAABhArWDYQM3jIyMYQJrVluQY/////9hBWcWVluYl1BQUFBQUFBQVltgBFSBVltgAIBhA2OFhYVhAmtWW5BQYARUgRFhA6lXYQOhYAJUYQOVZw3gtrOnZAAAYQK1YAFUhmEFZ5CRkGP/////FlZbkGP/////YQTCFlZbkVBQYQHyVltgAGED1GACVGEDlWcN4Lazp2QAAGECtWABVGAEVGEFZ5CRkGP/////FlZbkFBgAGED7WAEVIRhBSWQkZBj/////xZWW5BQYQQUgmEDlWcN4Lazp2QAAGECtWADVIZhBWeQkZBj/////xZWW5NQUFBQYQHyVlthBDKEYwHhM4Bj/////2EFwBZWW2ACVWEETGECnWMB4TOAg2P/////YQVnFlZbYAFVYQRjgmMB4TOAY/////9hBcAWVltgA4GQVWAEgpBVYAJUYAFUYECAUZKDUmAggwGRkJFSgYEBkpCSUmBggQGDkFKQUX9pYKsjTH70sMkZcQD1OTz83nxFOskQonvSAAqh3UwGjZGBkANggAGQoVBQUFBWW2AAgoIBg4EQFWEFHFdgQIBRYkYbzWDlG4FSYCBgBIIBUmAbYCSCAVJ/U2FmZU1hdGg6IGFkZGl0aW9uIG92ZXJmbG93AAAAAABgRIIBUpBRkIGQA2BkAZD9W5BQW5KRUFBWW2AAYQUcg4NgQFGAYEABYEBSgGAfgVJgIAF/U2FmZU1hdGg6IHN1YnRyYWN0aW9uIHVuZGVyZmxvdwCBUlBhBgJWW2AAgmEFdldQYABhBR9WW4KCAoKEgoFhBYNX/lsEFGEFHFdgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCGBUmAgAYBhBv9gIZE5YEABkVBQYEBRgJEDkP1bYABhBRyDg2BAUYBgQAFgQFKAYBqBUmAgAX9TYWZlTWF0aDogZGl2aXNpb24gYnkgemVybwAAAAAAAIFSUGEGmVZbYACBhIQRFWEGkVdgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSg4GBUYFSYCABkVCAUZBgIAGQgIODYABbg4EQFWEGVleBgQFRg4IBUmAgAWEGPlZbUFBQUJBQkIEBkGAfFoAVYQaDV4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUJJQUFBgQFGAkQOQ/VtQUFCQA5BWW2AAgYNhBuhXYEBRYkYbzWDlG4FSYCBgBIIBgYFSg1FgJIQBUoNRkJKDkmBEkJEBkZCFAZCAg4NgAIMVYQZWV4GBAVGDggFSYCABYQY+VltQYACDhYFhBvRX/lsElZRQUFBQUFb+U2FmZU1hdGg6IG11bHRpcGxpY2F0aW9uIG92ZXJmbG93b25seSB0aGUgb3duZXIgbWF5IGNhbGwgdGhpcyBmdW5jdGlvbi6iZWJ6enIxWCBx3dGz0H7dl1LHKEROI8uHka+nCtCBOws6yrxUaLH+/2Rzb2xjQwAFEAAy"
            },
            {
                "key": "BwMjwGu4MJq/lLZn8J9aDPdi+7+/fw==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEAtFdgADVg4ByAY0DBDxkRYQBxV4BjQMEPGRRhAhBXgGNwoIIxFGECPleAY5XYm0EUYQJkV4BjpFfC1xRhAmxXgGOpBZy7FGECmFeAY91i7T4UYQLEV2EAtFZbgGMG/d4DFGEAuVeAYwlep7MUYQE2V4BjGBYN3RRhAXZXgGMjuHLdFGEBkFeAYzE85WcUYQHGV4BjOVCTURRhAeRXW2AAgP1bYQDBYQLyVltgQIBRYCCAglKDUYGDAVKDUZGSg5KQgwGRhQGQgIODYABbg4EQFWEA+1eBgQFRg4IBUmAgAWEA41ZbUFBQUJBQkIEBkGAfFoAVYQEoV4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUJJQUFBgQFGAkQOQ81thAWJgBIA2A2BAgRAVYQFMV2AAgP1bUGABYAFgoBsDgTUWkGAgATVhA4hWW2BAgFGRFRWCUlGQgZADYCABkPNbYQF+YQOlVltgQIBRkYJSUZCBkANgIAGQ81thAWJgBIA2A2BggRAVYQGmV2AAgP1bUGABYAFgoBsDgTWBFpFgIIEBNZCRFpBgQAE1YQOrVlthAc5hBDhWW2BAgFFg/5CSFoJSUZCBkANgIAGQ81thAWJgBIA2A2BAgRAVYQH6V2AAgP1bUGABYAFgoBsDgTUWkGAgATVhBEFWW2ECPGAEgDYDYECBEBVhAiZXYACA/VtQYAFgAWCgGwOBNRaQYCABNWEElVZbAFthAX5gBIA2A2AggRAVYQJUV2AAgP1bUDVgAWABYKAbAxZhBKNWW2EAwWEEvlZbYQFiYASANgNgQIEQFWECgldgAID9W1BgAWABYKAbA4E1FpBgIAE1YQUfVlthAWJgBIA2A2BAgRAVYQKuV2AAgP1bUGABYAFgoBsDgTUWkGAgATVhBY1WW2EBfmAEgDYDYECBEBVhAtpXYACA/VtQYAFgAWCgGwOBNYEWkWAgATUWYQWhVltgA4BUYECAUWAgYB9gAmAAGWEBAGABiBYVAgGQlRaUkJQEk4QBgZAEgQKCAYEBkJJSgoFSYGCTkJKQkYMBgoKAFWEDfleAYB8QYQNTV2EBAICDVAQCg1KRYCABkWEDflZbggGRkGAAUmAgYAAgkFuBVIFSkGABAZBgIAGAgxFhA2FXgpADYB8WggGRW1BQUFBQkFCQVltgAGEDnGEDlWEFzFZbhIRhBdBWW1BgAZKRUFBWW2ACVJBWW2AAYQO4hISEYQa8VlthBC6EYQPEYQXMVlthBCmFYEBRgGBgAWBAUoBgKIFSYCABYQpsYCiROWABYAFgoBsDihZgAJCBUmABYCBSYECBIJBhBAJhBcxWW2ABYAFgoBsDFoFSYCCBAZGQkVJgQAFgACBUkZBj/////2EIGBZWW2EF0FZbUGABk5JQUFBWW2AFVGD/FpBWW2AAYQOcYQROYQXMVluEYQQphWABYABhBF9hBcxWW2ABYAFgoBsDkIEWglJgIICDAZOQk1JgQJGCAWAAkIEgkYwWgVKSUpAgVJBj/////2EIrxZWW2EEn4KCYQkQVltQUFZbYAFgAWCgGwMWYACQgVJgIIGQUmBAkCBUkFZbYASAVGBAgFFgIGAfYAJgABlhAQBgAYgWFQIBkJUWlJCUBJOEAYGQBIECggGBAZCSUoKBUmBgk5CSkJGDAYKCgBVhA35XgGAfEGEDU1dhAQCAg1QEAoNSkWAgAZFhA35WW2AAYQOcYQUsYQXMVluEYQQphWBAUYBgYAFgQFKAYCWBUmAgAWEK3WAlkTlgAWAAYQVWYQXMVltgAWABYKAbA5CBFoJSYCCAgwGTkJNSYECRggFgAJCBIJGNFoFSklKQIFSRkGP/////YQgYFlZbYABhA5xhBZphBcxWW4SEYQa8VltgAWABYKAbA5GCFmAAkIFSYAFgIJCBUmBAgIMgk5CUFoJSkZCRUiBUkFZbM5BWW2ABYAFgoBsDgxZhBhVXYEBRYkYbzWDlG4FSYAQBgIBgIAGCgQOCUmAkgVJgIAGAYQq5YCSROWBAAZFQUGBAUYCRA5D9W2ABYAFgoBsDghZhBlpXYEBRYkYbzWDlG4FSYAQBgIBgIAGCgQOCUmAigVJgIAGAYQokYCKROWBAAZFQUGBAUYCRA5D9W2ABYAFgoBsDgIQWYACBgVJgAWAgkIFSYECAgyCUhxaAhFKUglKRgpAghZBVgVGFgVKRUX+MW+Hl6+x9W9FPcUJ9HoTz3QMUwPeyKR5bIArIx8O5JZKBkAOQkQGQo1BQUFZbYAFgAWCgGwODFmEHAVdgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCWBUmAgAYBhCpRgJZE5YEABkVBQYEBRgJEDkP1bYAFgAWCgGwOCFmEHRldgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCOBUmAgAYBhCgFgI5E5YEABkVBQYEBRgJEDkP1bYQeJgWBAUYBgYAFgQFKAYCaBUmAgAWEKRmAmkTlgAWABYKAbA4YWYACQgVJgIIGQUmBAkCBUkZBj/////2EIGBZWW2ABYAFgoBsDgIUWYACQgVJgIIGQUmBAgIIgk5CTVZCEFoFSIFRhB76QgmP/////YQivFlZbYAFgAWCgGwOAhBZgAIGBUmAggYFSYECRgpAglJCUVYBRhYFSkFGRk5KHFpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACBhIQRFWEIp1dgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSg4GBUYFSYCABkVCAUZBgIAGQgIODYABbg4EQFWEIbFeBgQFRg4IBUmAgAWEIVFZbUFBQUJBQkIEBkGAfFoAVYQiZV4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUJJQUFBgQFGAkQOQ/VtQUFCQA5BWW2AAgoIBg4EQFWEJCVdgQIBRYkYbzWDlG4FSYCBgBIIBUmAbYCSCAVJ/U2FmZU1hdGg6IGFkZGl0aW9uIG92ZXJmbG93AAAAAABgRIIBUpBRkIGQA2BkAZD9W5OSUFBQVltgAWABYKAbA4IWYQlrV2BAgFFiRhvNYOUbgVJgIGAEggFSYB9gJIIBUn9FUkMyMDogbWludCB0byB0aGUgemVybyBhZGRyZXNzAGBEggFSkFGQgZADYGQBkP1bYAJUYQl+kIJj/////2EIrxZWW2ACVWABYAFgoBsDghZgAJCBUmAggZBSYECQIFRhCaqQgmP/////YQivFlZbYAFgAWCgGwODFmAAgYFSYCCBgVJgQICDIJSQlFWDUYWBUpNRkpORkn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75KBkAOQkQGQo1BQVv5FUkMyMDogdHJhbnNmZXIgdG8gdGhlIHplcm8gYWRkcmVzc0VSQzIwOiBhcHByb3ZlIHRvIHRoZSB6ZXJvIGFkZHJlc3NFUkMyMDogdHJhbnNmZXIgYW1vdW50IGV4Y2VlZHMgYmFsYW5jZUVSQzIwOiB0cmFuc2ZlciBhbW91bnQgZXhjZWVkcyBhbGxvd2FuY2VFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzRVJDMjA6IGFwcHJvdmUgZnJvbSB0aGUgemVybyBhZGRyZXNzRVJDMjA6IGRlY3JlYXNlZCBhbGxvd2FuY2UgYmVsb3cgemVyb6JlYnp6cjFYIN+VXdyQSPN23HwhPpca+f/2wyjvOK6TNcxZRUr9oYTTZHNvbGNDAAUQADI="
            },
            {
                "key": "BwM8KGXyRSyURa9G8cLtXPsRYlt5Fg==",
                "proof": [],
                "value": "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G81g5RuBUmAgYASCAYGBUoNRYCSEAVKDUZCSg5JgRJCRAZGQhQGQgIODYACDFWFSuleBgQFRg4IBUmAgAWFSolZbUFBQkAOQVltgAIMVgGFUtldQghVbFWFUw1dQYABhHGlWW4ODAoOFgoFhVNBX/lsEFIOQYVUfV2BAUWJGG81g5RuBUmAgYASCAYGBUoNRYCSEAVKDUZCSg5JgRJCRAZGQhQGQgIODYACDFWFSuleBgQFRg4IBUmAgAWFSolZbUJSTUFBQUFZbYACDgwGChYIQFWFVH1dgQFFiRhvNYOUbgVJgIGAEggGBgVKDUWAkhAFSg1GQkoOSYESQkQGRkIUBkICDg2AAgxVhUrpXgYEBUYOCAVJgIAFhUqJWW2AAYRxpg4NgQFGAYEABYEBSgGAOgVJgIAFtZGl2aWRlIGJ5IHplcm9gkBuBUlBgAIGDYVX6V2BAUWJGG81g5RuBUmAgYASCAYGBUoNRYCSEAVKDUZCSg5JgRJCRAZGQhQGQgIODYACDFWFSuleBgQFRg4IBUmAgAWFSolZbUIKEgWFWBFf+WwSUk1BQUFBWW2BAUYBgIAFgQFKAYACBUlCQVluBVIGDVYGBERVhFxVXYACDgVJgIJAgYRcVkYEBkIMBYVauVltgQFGAYQFAAWBAUoBgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFhVoJhVg1WW4FSYCABYVaPYVYNVluBUmAgAWFWnGFWDVZbgVJgIAFhVqlhVg1WW5BSkFZbYSmrkZBbgIIRFWFWyFdgAIFVYAEBYVa0VltQkFb+Y2Fubm90IHBhdXNlIGEgbWFya2V0IHRoYXQgaXMgbm90IGxpc3RlZENhbiBub3QgcmVwYXkgbW9yZSB0aGFuIHRoZSB0b3RhbCBib3Jyb3dvbmx5IHBhdXNlIGd1YXJkaWFuIGFuZCBhZG1pbiBjYW4gcGF1c2Vvbmx5IGFkbWluIGNhbiBzZXQgYm9ycm93IGNhcCBndWFyZGlhbm9ubHkgYWRtaW4gb3IgYm9ycm93IGNhcCBndWFyZGlhbiBjYW4gc2V0IGJvcnJvdyBjYXBzZXhpdE1hcmtldDogZ2V0QWNjb3VudFNuYXBzaG90IGZhaWxlZENvbXB0cm9sbGVyOjpfc2V0Q29tcFNwZWVkcyBpbnZhbGlkIGlucHV0b25seSB1bml0cm9sbGVyIGFkbWluIGNhbiBjaGFuZ2UgYnJhaW5zomVienpyMVggz/qQlZ+HOIiSHN1QHgKfcrGVcJPETvhJwwr/f2KbPklkc29sY0MABRAAMg=="
            },
            {
                "key": "BwM+iNewbwUmoTD9bM7tmbbgoHo6ow==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwNNiozBKxx/2JNdhcDzZGIVQeaxEA==",
                "proof": [],
                "value": "YIBgQFJgBDYQYQDsV2AANWDgHIBjUvrgBxFhAIpXgGPLOzqzEWEAWVeAY8s7OrMUYQKvV4Bj5AtltRRhAthXgGPktW50FGEDAVeAY/Jj89AUYQMuV2EA81ZbgGNS+uAHFGECCVeAY1/jtWcUYQIyV4Bji6043RRhAl1XgGOqs/hoFGEChldhAPNWW4BjJjDBLxFhAMZXgGMmMMEvFGEBdVeAY0HA4bUUYQGgV4BjRpPI5hRhAbdXgGNRz/jZFGEB4FdhAPNWW4BjEClhyhRhAPhXgGMQ0ehcFGEBNVeAYxwV1QAUYQFeV2EA81ZbNmEA81cAW2AAgP1bNIAVYQEEV2AAgP1bUGEBH2AEgDYDgQGQYQEakZBhMR5WW2EDV1ZbYEBRYQEskZBhPztWW2BAUYCRA5DzWzSAFWEBQVdgAID9W1BhAVxgBIA2A4EBkGEBV5GQYTJIVlthBMRWWwBbNIAVYQFqV2AAgP1bUGEBc2EQS1ZbAFs0gBVhAYFXYACA/VtQYQGKYRJ5VltgQFFhAZeRkGFBNVZbYEBRgJEDkPNbNIAVYQGsV2AAgP1bUGEBtWESn1ZbAFs0gBVhAcNXYACA/VtQYQHeYASANgOBAZBhAdmRkGExllZbYRNoVlsAWzSAFWEB7FdgAID9W1BhAgdgBIA2A4EBkGECApGQYTDMVlthFv9WWwBbNIAVYQIVV2AAgP1bUGECMGAEgDYDgQGQYQIrkZBhNBxWW2EY+lZbAFs0gBVhAj5XYACA/VtQYQJHYRmpVltgQFFhAlSRkGFBGlZbYEBRgJEDkPNbNIAVYQJpV2AAgP1bUGEChGAEgDYDgQGQYQJ/kZBhMMxWW2EZz1ZbAFs0gBVhApJXYACA/VtQYQKtYASANgOBAZBhAqiRkGEx5VZbYRzOVlsAWzSAFWECu1dgAID9W1BhAtZgBIA2A4EBkGEC0ZGQYTXaVlthIc5WWwBbNIAVYQLkV2AAgP1bUGEC/2AEgDYDgQGQYQL6kZBhMshWW2EiZ1ZbAFs0gBVhAw1XYACA/VtQYQMWYSMYVltgQFFhAyWTkpGQYT/RVltgQFGAkQOQ81s0gBVhAzpXYACA/VtQYQNVYASANgOBAZBhA1CRkGEzPVZbYSNdVlsAW2AAgGAAkFSQYQEACpAEc///////////////////////////FnP//////////////////////////xYzc///////////////////////////FhRhA+hXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhA9+QYUFyVltgQFGAkQOQ/VtgQFGAYGABYEBSgINz//////////////////////////8WgVJgIAFiAVGAQgGBUmAgAWABFRWBUlBgAWAAggFRgWAAAWAAYQEACoFUgXP//////////////////////////wIZFpCDc///////////////////////////FgIXkFVQYCCCAVGBYAEBVWBAggFRgWACAWAAYQEACoFUgWD/AhkWkIMVFQIXkFVQkFBQYAFgAAFgAJBUkGEBAAqQBHP//////////////////////////xaQUJGQUFZbYACAYACEhIEBkGEE2JGQYTFHVluSUJJQklBgADNz//////////////////////////8WYw3+FoFgQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGgDsVgBVhBSZXYACA/VtQWvoVgBVhBTpXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQVekZBhMPVWW5BQYAAzc///////////////////////////FmPSEiCnYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYQWoV2AAgP1bUFr6FYAVYQW8Vz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEF4JGQYTD1VluQUHP5TvpQXEUeeuAkVT0xjTHh81wy9HP//////////////////////////xZj5qQ5BYODYEBRg2P/////FmDgG4FSYAQBYQYxkpGQYUAIVltgIGBAUYCDA4GGgDsVgBVhBklXYACA/VtQWvoVgBVhBl1XPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQaBkZBhMPVWW3P//////////////////////////xYzc///////////////////////////FhRhBrhXYACA/VuCc///////////////////////////FoRz//////////////////////////8WFBVhCY9XYACAihQVYQb8V4hhBv5WW4lbkFBgAICLFBVhBxBXgmEHElZbg1uQUGEHP4aDg3P//////////////////////////xZhJAqQkpGQY/////8WVluFc///////////////////////////FmP148RiiISIYEBRhGP/////FmDgG4FSYAQBYQd8k5KRkGFAkVZbYCBgQFGAgwOBYACHgDsVgBVhB5ZXYACA/VtQWvEVgBVhB6pXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQfOkZBhNgNWW1CEc///////////////////////////FmPbAGp1hnP//////////////////////////xZjcKCCMTBgQFGCY/////8WYOAbgVJgBAFhCCSRkGE/VlZbYCBgQFGAgwOBhoA7FYAVYQg8V2AAgP1bUFr6FYAVYQhQVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEIdJGQYTYDVltgQFGCY/////8WYOAbgVJgBAFhCJCRkGFDMlZbYCBgQFGAgwOBYACHgDsVgBVhCKpXYACA/VtQWvEVgBVhCL5XPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQjikZBhNgNWW1CAc///////////////////////////FmOpBZy7M2ABYQPlYQPohwKBYQkRV/5bBAFgQFGDY/////8WYOAbgVJgBAFhCTCSkZBhP6hWW2AgYEBRgIMDgWAAh4A7FYAVYQlKV2AAgP1bUFrxFYAVYQleVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEJgpGQYTViVltQUFBQUFBQUGEQRFZbYACAYACAjBRhCalXi5JQhJFQg5BQYQmzVluKklCDkVCEkFBbYQneh4SEc///////////////////////////FmEkCpCSkZBj/////xZWW4Zz//////////////////////////8WY/XjxGKJhYlgQFGEY/////8WYOAbgVJgBAFhChuTkpGQYUCRVltgIGBAUYCDA4FgAIeAOxWAFWEKNVdgAID9W1Ba8RWAFWEKSVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhCm2RkGE2A1ZbUGAAhnP//////////////////////////xZjOvnmaTBgQFGCY/////8WYOAbgVJgBAFhCqmRkGE/VlZbYCBgQFGAgwOBYACHgDsVgBVhCsNXYACA/VtQWvEVgBVhCtdXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQr7kZBhNgNWW5BQhnP//////////////////////////xZj2wBqdYhz//////////////////////////8WY3CggjEwYEBRgmP/////FmDgG4FSYAQBYQtSkZBhP1ZWW2AgYEBRgIMDgYaAOxWAFWELaldgAID9W1Ba+hWAFWELflc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhC6KRkGE2A1ZbYEBRgmP/////FmDgG4FSYAQBYQu+kZBhQzJWW2AgYEBRgIMDgWAAh4A7FYAVYQvYV2AAgP1bUFrxFYAVYQvsVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEMEJGQYTYDVltQYACHc///////////////////////////FmNvMH3DYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYQxZV2AAgP1bUFr6FYAVYQxtVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEMkZGQYTD1VluQUGAAgGEMtXP5TvpQXEUeeuAkVT0xjTHh81wy9IeHYSVoVluRUJFQYABhDMaIg4VhJnpWW5BQhXP//////////////////////////xaEc///////////////////////////FhQVYQ2cV4Vz//////////////////////////8WY6kFnLszg2BAUYNj/////xZg4BuBUmAEAWENN5KRkGE/qFZbYCBgQFGAgwOBYACHgDsVgBVhDVFXYACA/VtQWvEVgBVhDWVXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYQ2JkZBhNWJWW1BQUFBQUFBQUFBQUFBQYRBEVlthDdtzv/yQDxq8hbVli2+gsd84KIEPnbSGhnP//////////////////////////xZhJAqQkpGQY/////8WVltgYGACZ///////////gRGAFWEN9VdgAID9W1BgQFGQgIJSgGAgAmAgAYIBYEBSgBVhDiRXgWAgAWAgggKANoM3gIIBkVBQkFBbUJBQhIFgAIFRgRBhDjVX/ltgIAJgIAEBkHP//////////////////////////xaQgXP//////////////////////////xaBUlBQhoFgAYFRgRBhDn1X/ltgIAJgIAEBkHP//////////////////////////xaQgXP//////////////////////////xaBUlBQc7/8kA8avIW1ZYtvoLHfOCiBD520c///////////////////////////FmOIA9vug4iEMGA8QgFgQFGGY/////8WYOAbgVJgBAFhDw+VlJOSkZBhQ5lWW2AAYEBRgIMDgWAAh4A7FYAVYQ8pV2AAgP1bUFrxFYAVYQ89Vz1gAIA+PWAA/VtQUFBQYEBRPWAAgj49YB8ZYB+CARaCAYBgQFJQgQGQYQ9mkZBhNSFWW1BhD6dzv/yQDxq8hbVli2+gsd84KIEPnbRgAIdz//////////////////////////8WYSQKkJKRkGP/////FlZbhnP//////////////////////////xZjqQWcuzOEYEBRg2P/////FmDgG4FSYAQBYQ/ikpGQYT+oVltgIGBAUYCDA4FgAIeAOxWAFWEP/FdgAID9W1Ba8RWAFWEQEFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhEDSRkGE1YlZbUFBQUFBQUFBQUFBQUFBQW1BQUFBQVltgAICQVJBhAQAKkARz//////////////////////////8Wc///////////////////////////FjNz//////////////////////////8WFGEQ2ldgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWEQ0ZBhQXJWW2BAUYCRA5D9W2ABYAIBYACQVJBhAQAKkARg/xZhESxXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhESOQYUKSVltgQFGAkQOQ/VtgAYABVEIRYRFyV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYRFpkGFBklZbYEBRgJEDkP1bYAFgAAFgAJBUkGEBAAqQBHP//////////////////////////xZgAIBhAQAKgVSBc///////////////////////////AhkWkINz//////////////////////////8WAheQVVB//y0HvRiKnrQay8Sn2znhiVbJWrf1T0NNl4Sb9iBuV3xgAICQVJBhAQAKkARz//////////////////////////8WYEBRYRInkZBhP1ZWW2BAUYCRA5ChYAFgAICCAWAAYQEACoFUkHP//////////////////////////wIZFpBVYAGCAWAAkFVgAoIBYABhAQAKgVSQYP8CGRaQVVBQVltgBWAAkFSQYQEACpAEc///////////////////////////FoFWW2AAgJBUkGEBAAqQBHP//////////////////////////xZz//////////////////////////8WM3P//////////////////////////xYUYRMuV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYRMlkGFBclZbYEBRgJEDkP1bYACAkFSQYQEACpAEc///////////////////////////FnP//////////////////////////xb/W2AAYARgAJBUkGEBAAqQBHP//////////////////////////xZz//////////////////////////8WY17IjHmFYEBRgmP/////FmDgG4FSYAQBYRPFkZBhPztWW2BgYEBRgIMDgYaAOxWAFWET3VdgAID9W1Ba+hWAFWET8Vc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhFBWRkGE2LFZbUJFQUGAAgRRhFCdXUGEW+lZbYABnDeC2s6dkAABgBlSFc///////////////////////////FmMXv9+8iGBAUYJj/////xZg4BuBUmAEAWEUbpGQYT87VltgIGBAUYCDA4FgAIeAOxWAFWEUiFdgAID9W1Ba8RWAFWEUnFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhFMCRkGE2A1ZbAoFhFMhX/lsEkFBgAGAHVGcN4Lazp2QAAIVz//////////////////////////8WYzr55mmJYEBRgmP/////FmDgG4FSYAQBYRUSkZBhPztWW2AgYEBRgIMDgWAAh4A7FYAVYRUsV2AAgP1bUFrxFYAVYRVAVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEVZJGQYTYDVlsCgWEVbFf+WwSQUGAAYAVgAJBUkGEBAAqQBHP//////////////////////////xZz//////////////////////////8WY/xX1N+HYEBRgmP/////FmDgG4FSYAQBYRXMkZBhPztWW2AgYEBRgIMDgYaAOxWAFWEV5FdgAID9W1Ba+hWAFWEV+Fc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhFhyRkGE2A1ZbkFCAgwKSUGAFYACQVJBhAQAKkARz//////////////////////////8Wc///////////////////////////FmP8V9TfhmBAUYJj/////xZg4BuBUmAEAWEWfpGQYT87VltgIGBAUYCDA4GGgDsVgBVhFpZXYACA/VtQWvoVgBVhFqpXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRbOkZBhNgNWW4ICkVBhFvWHh4eEhogQYRbmV4ZhFuhWW4dbgWEW71f+WwRhHM5WW1BQUFBbUFBQVltgAIBz//////////////////////////8WgnP//////////////////////////xYUFWEXwldgADCQUIBz//////////////////////////8WMZFQYACAkFSQYQEACpAEc///////////////////////////FnP//////////////////////////xZhCPyDkIEVApBgQFFgAGBAUYCDA4GFiIjxk1BQUFAVgBVhF7tXPWAAgD49YAD9W1BQYRiaVluBc///////////////////////////FmNwoIIxMGBAUYJj/////xZg4BuBUmAEAWEX+5GQYT9WVltgIGBAUYCDA4GGgDsVgBVhGBNXYACA/VtQWvoVgBVhGCdXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRhLkZBhNgNWW5BQYRiZYACAkFSQYQEACpAEc///////////////////////////FoKEc///////////////////////////FmEni5CSkZBj/////xZWW1t/bBmPDj5PaGaN/XsaaJ7hEBl9gi3Y7JOmhRONS4U3rgZgAICQVJBhAQAKkARz//////////////////////////8Wg4NgQFFhGO6TkpGQYT9xVltgQFGAkQOQoVBQVltgBWAAkFSQYQEACpAEc///////////////////////////FnP//////////////////////////xZj7MHphIuLi4uLi2BAUYdj/////xZg4BuBUmAEAWEZX5aVlJOSkZBhQMhWW2AAYEBRgIMDgWAAh4A7FYAVYRl5V2AAgP1bUFrxFYAVYRmNVz1gAIA+PWAA/VtQUFBQYRmdhISEhGEiZ1ZbUFBQUFBQUFBQUFZbYARgAJBUkGEBAAqQBHP//////////////////////////xaBVltgAICQVJBhAQAKkARz//////////////////////////8Wc///////////////////////////FjNz//////////////////////////8WFGEaXldgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWEaVZBhQXJWW2BAUYCRA5D9W4BgBGAAYQEACoFUgXP//////////////////////////wIZFpCDc///////////////////////////FgIXkFVQYARgAJBUkGEBAAqQBHP//////////////////////////xZz//////////////////////////8WY33A0dBgQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGgDsVgBVhGwdXYACA/VtQWvoVgBVhGxtXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRs/kZBhMPVWW2AFYABhAQAKgVSBc///////////////////////////AhkWkINz//////////////////////////8WAheQVVBgBGAAkFSQYQEACpAEc///////////////////////////FnP//////////////////////////xZj6HVURmBAUYFj/////xZg4BuBUmAEAWAgYEBRgIMDgYaAOxWAFWEb51dgAID9W1Ba+hWAFWEb+1c9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhHB+RkGE2A1ZbYAaBkFVQYARgAJBUkGEBAAqQBHP//////////////////////////xZz//////////////////////////8WY0rakK9gQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGgDsVgBVhHI1XYACA/VtQWvoVgBVhHKFXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYRzFkZBhNgNWW2AHgZBVUFBWW2AAgINz//////////////////////////8WhXP//////////////////////////xYUFWEdv1eEc///////////////////////////FmNvMH3DYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYR1LV2AAgP1bUFr6FYAVYR1fVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEdg5GQYTD1VluQUGEduHP5TvpQXEUeeuAkVT0xjTHh81wy9IJzsZjA2JdVRzRUdd6SItFpTnrjDjZhKBFWW5FQYR+wVluEc///////////////////////////FmNvMH3DYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYR4FV2AAgP1bUFr6FYAVYR4ZVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEePZGQYTD1VluQUGAAYR7dc/lO+lBcRR564CRVPTGNMeHzXDL0g4dz//////////////////////////8WY28wfcNgQFGBY/////8WYOAbgVJgBAFgIGBAUYCDA4GGgDsVgBVhHqBXYACA/VtQWvoVgBVhHrRXPWAAgD49YAD9W1BQUFBgQFE9YB8ZYB+CARaCAYBgQFJQgQGQYR7YkZBhMPVWW2Eog1ZbkFCAlFCBklBQUGED2YECYgGGoIUCERVhH65Xc/lO+lBcRR564CRVPTGNMeHzXDL0c///////////////////////////FmPmpDkFg3OxmMDYl1VHNFR13pIi0WlOeuMONmBAUYNj/////xZg4BuBUmAEAWEfW5KRkGFACFZbYCBgQFGAgwOBhoA7FYAVYR9zV2AAgP1bUFr6FYAVYR+HVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEfq5GQYTD1VluSUFtQW2BghoaGYEBRYCABYR/Hk5KRkGFAMVZbYEBRYCCBgwMDgVKQYEBSkFBgAIJz//////////////////////////8WhHP//////////////////////////xZjDf4WgWBAUYFj/////xZg4BuBUmAEAWAgYEBRgIMDgYaAOxWAFWEgN1dgAID9W1Ba+hWAFWEgS1c9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhIG+RkGEw9VZbc///////////////////////////FhRhIJFXYABhIJNWW4RbkFBgAINz//////////////////////////8WhXP//////////////////////////xZj0hIgp2BAUYFj/////xZg4BuBUmAEAWAgYEBRgIMDgYaAOxWAFWEg9FdgAID9W1Ba+hWAFWEhCFc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhISyRkGEw9VZbc///////////////////////////FhRhIU5XYABhIVBWW4VbkFCEc///////////////////////////FmMCLA2fg4Mwh2BAUYVj/////xZg4BuBUmAEAWEhkZSTkpGQYUNNVltgAGBAUYCDA4FgAIeAOxWAFWEhq1dgAID9W1Ba8RWAFWEhv1c9YACAPj1gAP1bUFBQUFBQUFBQUFBQUFZbYACAkFSQYQEACpAEc///////////////////////////FnP//////////////////////////xYzc///////////////////////////FhRhIl1XYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhIlSQYUFyVltgQFGAkQOQ/VuAYAiBkFVQUFZbYABbYAEVYSMRV2Ei5YWFg4GBEGEigFf+W5BQYCACAWAggQGQYSKVkZBhMMxWW4SEYAKFAoGBEGEipFf+W5BQYCACAWAggQGQYSK5kZBhMMxWW4WFYAFgAocCAYGBEGEiy1f+W5BQYCACAWAggQGQYSLgkZBhMMxWW2ETaFZbYAhUWhCAYSL6V1CEhJBQYAGCARRbFWEjBFdhIxFWW4CAYAEBkVBQYSJqVltQUFBQUFZbYAGAYAABYACQVJBhAQAKkARz//////////////////////////8WkIBgAQFUkIBgAgFgAJBUkGEBAAqQBGD/FpBQg1ZbYAVgAJBUkGEBAAqQBHP//////////////////////////xZz//////////////////////////8WY+zB6YSKioqKiopgQFGHY/////8WYOAbgVJgBAFhI8KWlZSTkpGQYUDIVltgAGBAUYCDA4FgAIeAOxWAFWEj3FdgAID9W1Ba8RWAFWEj8Fc9YACAPj1gAP1bUFBQUGEj/4ODg2ETaFZbUFBQUFBQUFBQVltgAIEUgGEko1dQYACDc///////////////////////////FmPdYu0+MIVgQFGDY/////8WYOAbgVJgBAFhJFGSkZBhQAhWW2AgYEBRgIMDgYaAOxWAFWEkaVdgAID9W1Ba+hWAFWEkfVc9YACAPj1gAP1bUFBQUGBAUT1gHxlgH4IBFoIBgGBAUlCBAZBhJKGRkGE2A1ZbFFthJOJXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhJNmQYUMSVltgQFGAkQOQ/VthJWODYwlep7Ng4BuEhGBAUWAkAWElAZKRkGFAaFZbYEBRYCCBgwMDgVKQYEBSkHv/////////////////////////////////////GRZgIIIBgFF7/////////////////////////////////////4OBgxYXg1JQUFBQYSnIVltQUFBWW2AAgGAAYSV3hYVhKo9WW1CQUGAAgGEliIiIiGEoEVZbc///////////////////////////FmMJAvGsYEBRgWP/////FmDgG4FSYAQBYGBgQFGAgwOBhoA7FYAVYSXNV2AAgP1bUFr6FYAVYSXhVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEmBZGQYTWLVltQbf//////////////////FpFQbf//////////////////FpFQgnP//////////////////////////xaHc///////////////////////////FhRhJmRXgIJhJmdWW4GBW4CVUIGWUFBQUFBQk1CTkVBQVltgAICEEWEmvldgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWEmtZBhQdJWW2BAUYCRA5D9W2AAgxGAFWEmzldQYACCEVthJw1XYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhJwSQYUJSVltgQFGAkQOQ/VtgAGEnNmED6GEnKIeHYSu9kJGQY/////8WVlthK72QkZBj/////xZWW5BQYABhJ2FhA+VhJ1OIh2EsLZCRkGP/////FlZbYSu9kJGQY/////8WVluQUGEngGABgoSBYSdxV/5bBGEsfZCRkGP/////FlZbklBQUJOSUFBQVlthKAyDY6kFnLtg4BuEhGBAUWAkAWEnqpKRkGFAaFZbYEBRYCCBgwMDgVKQYEBSkHv/////////////////////////////////////GRZgIIIBgFF7/////////////////////////////////////4OBgxYXg1JQUFBQYSnIVltQUFBWW2AAgGAAYSgghYVhKo9WW5FQkVCFgoJgQFFgIAFhKDiSkZBhPrZWW2BAUWAggYMDA4FSkGBAUoBRkGAgASBgQFFgIAFhKF+SkZBhPvlWW2BAUWAggYMDA4FSkGBAUoBRkGAgASBgABySUFBQk5JQUFBWW2AAgGAAgGEok4aGYSqPVltQkFBhKKGHh4dhKBFWW5FQYACCO5BQYACBY/////8WFBVhKM9XYACAhIKSUIGRUJRQlFCUUFBQYSm/VltgAICEc///////////////////////////FmMJAvGsYEBRgWP/////FmDgG4FSYAQBYGBgQFGAgwOBhoA7FYAVYSkYV2AAgP1bUFr6FYAVYSksVz1gAIA+PWAA/VtQUFBQYEBRPWAfGWAfggEWggGAYEBSUIEBkGEpUJGQYTWLVltQbf//////////////////FpFQbf//////////////////FpFQg3P//////////////////////////xaJc///////////////////////////FhRhKa9XgIJhKbJWW4GBW4CXUIGYUFBQUFBQUFuTUJNQk5BQVltgYGEqKoJgQFGAYEABYEBSgGAggVJgIAF/U2FmZUVSQzIwOiBsb3ctbGV2ZWwgY2FsbCBmYWlsZWSBUlCFc///////////////////////////FmEs0pCSkZBj/////xZWW5BQYACBUREVYSqKV4CAYCABkFGBAZBhKkqRkGE1YlZbYSqJV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYSqAkGFC8lZbYEBRgJEDkP1bW1BQUFZbYACAgnP//////////////////////////xaEc///////////////////////////FhQVYSsBV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYSr4kGFB8lZbYEBRgJEDkP1bgnP//////////////////////////xaEc///////////////////////////FhBhKztXgoRhKz5WW4ODW4CSUIGTUFBQYABz//////////////////////////8WgnP//////////////////////////xYUFWErtldgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWErrZBhQtJWW2BAUYCRA5D9W5JQkpBQVltgAICDFBVhK9BXYACQUGEsJ1ZbYACChAKQUIKEgoFhK+FX/lsEFGEsIldgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWEsGZBhQnJWW2BAUYCRA5D9W4CRUFBbkpFQUFZbYACCghEVYSxyV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYSxpkGFCElZbYEBRgJEDkP1bgYMDkFCSkVBQVltgAICChAGQUIOBEBVhLMhXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAFhLL+QYUGyVltgQFGAkQOQ/VuAkVBQkpFQUFZbYGBhLOGEhGAAhWEs6lZbkFCTklBQUFZbYGCCRxAVYS0vV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYS0mkGFCMlZbYEBRgJEDkP1bYS04hWEt/1ZbYS13V2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBYS1ukGFCslZbYEBRgJEDkP1bYABgYIZz//////////////////////////8WhYdgQFFhLaGRkGE+4lZbYABgQFGAgwOBhYda8ZJQUFA9gGAAgRRhLd5XYEBRkVBgHxlgPz0BFoIBYEBSPYJSPWAAYCCEAT5hLeNWW2BgkVBbUJFQkVBhLfOCgoZhLhJWW5JQUFCUk1BQUFBWW2AAgII7kFBgAIERkVBQkZBQVltgYIMVYS4iV4KQUGEuclZbYACDUREVYS41V4JRgIRgIAH9W4FgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAWEuaZGQYUFQVltgQFGAkQOQ/VuTklBQUFZbYACBNZBQYS6IgWFHiVZbkpFQUFZbYACBUZBQYS6dgWFHiVZbkpFQUFZbYACBNZBQYS6ygWFHoFZbkpFQUFZbYACAg2AfhAESYS7KV2AAgP1bgjWQUGf//////////4ERFWEu41dgAID9W2AggwGRUINgIIICgwERFWEu+1dgAID9W5JQkpBQVltgAICDYB+EARJhLxRXYACA/VuCNZBQZ///////////gREVYS8tV2AAgP1bYCCDAZFQg2AgggKDAREVYS9FV2AAgP1bklCSkFBWW2AAgINgH4QBEmEvXldgAID9W4I1kFBn//////////+BERVhL3dXYACA/VtgIIMBkVCDYCCCAoMBERVhL49XYACA/VuSUJKQUFZbYACCYB+DARJhL6dXYACA/VuBUWEvumEvtYJhRCBWW2FD81ZbkVCBgYNSYCCEAZNQYCCBAZBQg4VgIIQCggERFWEv31dgAID9W2AAW4OBEBVhMA9XgWEv9YiCYTCiVluEUmAghAGTUGAggwGSUFBgAYEBkFBhL+JWW1BQUFCSkVBQVltgAIFRkFBhMCiBYUe3VluSkVBQVltgAICDYB+EARJhMEBXYACA/VuCNZBQZ///////////gREVYTBZV2AAgP1bYCCDAZFQg2ABggKDAREVYTBxV2AAgP1bklCSkFBWW2AAgVGQUGEwh4FhR85WW5KRUFBWW2AAgTWQUGEwnIFhR+VWW5KRUFBWW2AAgVGQUGEwsYFhR+VWW5KRUFBWW2AAgVGQUGEwxoFhR/xWW5KRUFBWW2AAYCCChAMSFWEw3ldgAID9W2AAYTDshIKFAWEueVZbkVBQkpFQUFZbYABgIIKEAxIVYTEHV2AAgP1bYABhMRWEgoUBYS6OVluRUFCSkVBQVltgAGAggoQDEhVhMTBXYACA/VtgAGExPoSChQFhLqNWW5FQUJKRUFBWW2AAgGAAYGCEhgMSFWExXFdgAID9W2AAYTFqhoKHAWEuo1Zbk1BQYCBhMXuGgocBYS6jVluSUFBgQGExjIaChwFhLqNWW5FQUJJQklCSVltgAIBgAGBghIYDEhVhMatXYACA/VtgAGExuYaChwFhLnlWW5NQUGAgYTHKhoKHAWEueVZbklBQYEBhMduGgocBYS55VluRUFCSUJJQklZbYACAYACAYICFhwMSFWEx+1dgAID9W2AAYTIJh4KIAWEueVZblFBQYCBhMhqHgogBYS55VluTUFBgQGEyK4eCiAFhLnlWW5JQUGBgYTI8h4KIAWEwjVZbkVBQkpWRlFCSUFZbYACAYACAYABggIaIAxIVYTJgV2AAgP1bYABhMm6IgokBYS55VluVUFBgIGEyf4iCiQFhMI1WW5RQUGBAYTKQiIKJAWEwjVZbk1BQYGCGATVn//////////+BERVhMq1XYACA/VthMrmIgokBYTAuVluSUJJQUJKVUJKVkJNQVltgAIBgAIBgQIWHAxIVYTLeV2AAgP1bYACFATVn//////////+BERVhMvhXYACA/VthMwSHgogBYS64VluUUJRQUGAghQE1Z///////////gREVYTMjV2AAgP1bYTMvh4KIAWEuuFZbklCSUFCSlZGUUJJQVltgAIBgAIBgAIBgAIBgAGDAiowDEhVhM1tXYACA/VtgAIoBNWf//////////4ERFWEzdVdgAID9W2EzgYyCjQFhLwJWW5lQmVBQYCCKATVn//////////+BERVhM6BXYACA/VthM6yMgo0BYS8CVluXUJdQUGBAigE1Z///////////gREVYTPLV2AAgP1bYTPXjIKNAWEvTFZblVCVUFBgYGEz6oyCjQFhLnlWW5NQUGCAYTP7jIKNAWEueVZbklBQYKBhNAyMgo0BYS55VluRUFCSlZhQkpWYUJKVmFZbYACAYACAYACAYACAYACAYKCLjQMSFWE0O1dgAID9W2AAiwE1Z///////////gREVYTRVV2AAgP1bYTRhjYKOAWEvAlZbmlCaUFBgIIsBNWf//////////4ERFWE0gFdgAID9W2E0jI2CjgFhLwJWW5hQmFBQYECLATVn//////////+BERVhNKtXYACA/VthNLeNgo4BYS9MVluWUJZQ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"
            },
            {
                "key": "BwNN3EJzywCoH+bnjBm+ffkgXHllqg==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEAfVdgADVg4ByAY0C8CvQRYQBbV4BjQLwK9BRhAOFXgGNsLfanFGEA6VeAY25x4tgUYQDxV4BjuBaIFhRhARpXYQB9VluAYwxXSGEUYQCCV4BjFfJAUxRhAJxXgGMhkfkqFGEAxVdbYACA/VthAIphAUlWW2BAgFGRglJRkIGQA2AgAZDzW2EAimAEgDYDYGCBEBVhALJXYACA/VtQgDWQYCCBATWQYEABNWEBUVZbYQDNYQGrVltgQIBRkRUVglJRkIGQA2AgAZDzW2EAimEBsFZbYQCKYQG2VlthAIpgBIA2A2BggRAVYQEHV2AAgP1bUIA1kGAggQE1kGBAATVhAbxWW2EAimAEgDYDYICBEBVhATBXYACA/VtQgDWQYCCBATWQYECBATWQYGABNWECDlZbYwHhM4CBVltgAIBhAV+FhYVhAbxWW5BQYQGgYAFUYQGUZw3gtrOnZAAAYQGIYABUhmECjZCRkGP/////FlZbkGP/////YQLvFlZbkGP/////YQMxFlZbkVBQW5OSUFBQVltgAYFWW2ABVIFWW2AAVIFWW2AAgmEBy1dQYABhAaRWW2ECBmEB7oNhAeKHh2P/////YQMxFlZbkGP/////YQOLFlZbYQGIhWcN4Lazp2QAAGP/////YQKNFlZblJNQUFBQVltgAIBhAilnDeC2s6dkAACEY/////9hA4sWVluQUGAAYQI4h4eHYQFRVluQUGAAYQJYZw3gtrOnZAAAYQGIhIZj/////2ECjRZWW5BQYQKBZw3gtrOnZAAAYQGIg2ECdYyMjGEBvFZbkGP/////YQKNFlZbmJdQUFBQUFBQUFZbYACCYQKcV1BgAGEC6VZbgoICgoSCgWECqVf+WwQUYQLmV2BAUWJGG81g5RuBUmAEAYCAYCABgoEDglJgIYFSYCABgGEEymAhkTlgQAGRUFBgQFGAkQOQ/VuQUFuSkVBQVltgAGEC5oODYEBRgGBAAWBAUoBgGoFSYCABf1NhZmVNYXRoOiBkaXZpc2lvbiBieSB6ZXJvAAAAAAAAgVJQYQPNVltgAIKCAYOBEBVhAuZXYECAUWJGG81g5RuBUmAgYASCAVJgG2AkggFSf1NhZmVNYXRoOiBhZGRpdGlvbiBvdmVyZmxvdwAAAAAAYESCAVKQUZCBkANgZAGQ/VtgAGEC5oODYEBRgGBAAWBAUoBgH4FSYCABf1NhZmVNYXRoOiBzdWJ0cmFjdGlvbiB1bmRlcmZsb3cAgVJQYQRvVltgAIGDYQRZV2BAUWJGG81g5RuBUmAEAYCAYCABgoEDglKDgYFRgVJgIAGRUIBRkGAgAZCAg4NgAFuDgRAVYQQeV4GBAVGDggFSYCABYQQGVltQUFBQkFCQgQGQYB8WgBVhBEtXgIIDgFFgAYNgIANhAQAKAxkWgVJgIAGRUFtQklBQUGBAUYCRA5D9W1BgAIOFgWEEZVf+WwSVlFBQUFBQVltgAIGEhBEVYQTBV2BAUWJGG81g5RuBUmAgYASCAYGBUoNRYCSEAVKDUZCSg5JgRJCRAZGQhQGQgIODYACDFWEEHleBgQFRg4IBUmAgAWEEBlZbUFBQkAOQVv5TYWZlTWF0aDogbXVsdGlwbGljYXRpb24gb3ZlcmZsb3eiZWJ6enIxWCAix20Hi3TdFZ6iUPoc+4QKsLp55X9fwMdZYd1QSSQXwGRzb2xjQwAFEAAy"
            },
            {
                "key": "BwNkeizHNj5ghPLIh1GTMQfSUMj0Hg==",
                "proof": [],
                "value": "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VltgQFGAYCABYEBSgGAAgVJQkFZbgoBUYAGBYAEWFWEBAAIDFmACkASQYABSYCBgACCQYB8BYCCQBIEBkoJgHxBhUTFXgFFg/xkWg4ABF4VVYVFeVluCgAFgAQGFVYIVYVFeV5GCAVuCgREVYVFeV4JRglWRYCABkZBgAQGQYVFDVltQYVFqkpFQYVJoVltQkFZbYECAUWEBIIEBkJFSgGAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUlCQVltgQIBRYQEAgQGQkVKAYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJQkFZbYECAUWDggQGQkVKAYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSYCABYACBUlCQVltgQIBRYICBAZCRUoBgAIFSYCABYACBUmAgAWAAgVJgIAFgAIFSUJBWW2EOmJGQW4CCERVhUWpXYACBVWABAWFSblb+b25seSBhZG1pbiBtYXkgaW5pdGlhbGl6ZSB0aGUgbWFya2V0bWFya2V0IG1heSBvbmx5IGJlIGluaXRpYWxpemVkIG9uY2VDRXJjMjA6OnN3ZWVwVG9rZW46IGNhbiBub3Qgc3dlZXAgdW5kZXJseWluZyB0b2tlbmluaXRpYWwgZXhjaGFuZ2UgcmF0ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvLm9ubHkgdGhlIGFkbWluIG1heSBzZXQgdGhlIGNvbXAtbGlrZSBkZWxlZ2F0ZXNldHRpbmcgaW50ZXJlc3QgcmF0ZSBtb2RlbCBmYWlsZWRvbmx5IHRoZSBhZG1pbiBtYXkgY2FsbCBfcmVzaWduSW1wbGVtZW50YXRpb25NSU5UX05FV19BQ0NPVU5UX0JBTEFOQ0VfQ0FMQ1VMQVRJT05fRkFJTEVEYm9ycm93QmFsYW5jZVN0b3JlZDogYm9ycm93QmFsYW5jZVN0b3JlZEludGVybmFsIGZhaWxlZFJFUEFZX0JPUlJPV19ORVdfQUNDT1VOVF9CT1JST1dfQkFMQU5DRV9DQUxDVUxBVElPTl9GQUlMRUTd8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz71JFUEFZX0JPUlJPV19ORVdfVE9UQUxfQkFMQU5DRV9DQUxDVUxBVElPTl9GQUlMRURMSVFVSURBVEVfQ09NUFRST0xMRVJfQ0FMQ1VMQVRFX0FNT1VOVF9TRUlaRV9GQUlMRURleGNoYW5nZVJhdGVTdG9yZWQ6IGV4Y2hhbmdlUmF0ZVN0b3JlZEludGVybmFsIGZhaWxlZE1JTlRfTkVXX1RPVEFMX1NVUFBMWV9DQUxDVUxBVElPTl9GQUlMRURvbmUgb2YgcmVkZWVtVG9rZW5zSW4gb3IgcmVkZWVtQW1vdW50SW4gbXVzdCBiZSB6ZXJvcmVkdWNlIHJlc2VydmVzIHVuZXhwZWN0ZWQgdW5kZXJmbG93b25seSB0aGUgYWRtaW4gbWF5IGNhbGwgX2JlY29tZUltcGxlbWVudGF0aW9uomVienpyMVggxhSiXJSqpMlz4W6G2kO0pubREshMVf9cU7uxjKxJmipkc29sY0MABRAAMg=="
            },
            {
                "key": "BwOAUhVGawEusaVyGiK+KtXyUL7/ig==",
                "proof": [],
                "value": "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Anf///////////////////////////////+QkhaRkJEXkJNVVINRkYJSM5KCAZKQklKSFpJQfxfqvQpm+mMfdTfO/dXfaqJdWskEz3WW6VjUOnWgDQ1okQFgQFGAkQOQolBWW2AAgGAAgGAAY/////+Gaf////////////8WERVgQFGAYEABYEBSgGAPgVJgIAF/Tm8gZGF0YSBwcmVzZW50AAAAAAAAAAAAAAAAAAAAAACBUlCQYQfbV2BAUWJGG81g5RuBUmAEAWEFZ5GQYQzyVltQUFBQY/////+DFmAAkIFSYAJgIJCBUmBAkYKQIIJRgIQBkJNSVGAXgZALgIRSYAFgwBuQkQRn//////////8WkpCRAYKQUpOUkJJQgpFQhJBWW2AAY/////+CERVhCERXUGAAkZBQVltQY/////8WYACQgVJgAmAgUmBAkCBUYBcLkFZbYABj/////4IRFWEIdldQYACRkFBWW1Bj/////xZgAJCBUmACYCBSYECQIFRgAWDAG5AEZ///////////FpBWW2AAgoFSYCCBkFJgQJAgYAEBVGEIvIEzYQlNVlthBOiDg2EKaVZbYACAMzIUYQkYV2BAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSf09ubHkgY2FsbGFibGUgYnkgRU9BAAAAAAAAAAAAAAAAYESCAVJgZAFhBWdWW1BQYAFUY/////8WYACQgVJgAmAgUmBAkCBUYBeBkAuRYAFgwBuQkQRn//////////8WkFZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2EJiYFgAWABYKAbAxZgFGEK6FZbYQmUg2AgYQroVltgQFFgIAFhCaWSkZBhDj5WW2BAgFFgHxmBhAMBgVKQgpBSYkYbzWDlG4JSYQVnkWAEAWEM8lZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaEUpCRUpAggFRg/xkWYAEXkFVhCiUzkFZbYAFgAWCgGwMWgWABYAFgoBsDFoN/L4eIEX5+/x2C6SbseUkB0Xx4AkpQJwlAMEVApzNlbw1gQFFgQFGAkQOQpFBQVltgAIKBUmAggYFSYECAgyBgAWABYKAbA4UWhFKQkVKQIFRg/xYVYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaAhVKSUoCDIIBUYP8ZFpBVUTOShZF/9jkfXDLZxp0qR+pnC0QpdLU5NdHtx/1k6yHgR6g5FxuRkKRQUFZbYGBgAGEK94NgAmEOv1ZbYQsCkGACYQ7eVltn//////////+BERVhCxpXYQsaYQ72VltgQFGQgIJSgGAfAWAfGRZgIAGCAWBAUoAVYQtEV2AgggGBgDaDNwGQUFtQkFBgA2D8G4FgAIFRgRBhC19XYQtfYQ8MVltgIAEBkGABYAFg+BsDGRaQgWAAGpBTUGAPYPsbgWABgVGBEGELjldhC45hDwxWW2AgAQGQYAFgAWD4GwMZFpCBYAAakFNQYABhC7KEYAJhDr9WW2ELvZBgAWEO3lZbkFBbYAGBERVhDEJXfzAxMjM0NTY3ODlhYmNkZWYAAAAAAAAAAAAAAAAAAAAAhWAPFmAQgRBhC/5XYQv+YQ8MVlsaYPgbgoKBUYEQYQwUV2EMFGEPDFZbYCABAZBgAWABYPgbAxkWkIFgABqQU1BgBJSQlByTYQw7gWEPIlZbkFBhC8BWW1CDFWEMkVdgQFFiRhvNYOUbgVJgIGAEggGBkFJgJIIBUn9TdHJpbmdzOiBoZXggbGVuZ3RoIGluc3VmZmljaWVudGBEggFSYGQBYQVnVluTklBQUFZbYABgIIKEAxIVYQyqV2AAgP1bgTVgAWABYOAbAxmBFoEUYQyRV2AAgP1bYABbg4EQFWEM3VeBgQFRg4IBUmAgAWEMxVZbg4ERFWEM7FdgAISEAVJbUFBQUFZbYCCBUmAAglGAYCCEAVJhDRGBYECFAWAghwFhDMJWW2AfAWAfGRaRkJEBYEABkpFQUFZbYABgIIKEAxIVYQ03V2AAgP1bUDWRkFBWW2AAgGBAg4UDEhVhDVFXYACA/VuCNZFQYCCDATVgAWABYKAbA4EWgRRhDW9XYACA/VuAkVBQklCSkFBWW2AAYCCChAMSFWENjFdgAID9W4E1gGAXC4EUYQyRV2AAgP1bYABgIIKEAxIVYQ2vV2AAgP1bgTVp/////////////4EWgRRhDJFXYACA/VtgAYGBHJCCFoBhDd1XYH+CFpFQW2AgghCBFBVhDf5XY05Ie3Fg4BtgAFJgImAEUmAkYAD9W1CRkFBWW2NOSHtxYOAbYABSYBFgBFJgJGAA/VtgAGP/////gIMWgYEUFWEONFdhDjRhDgRWW2ABAZOSUFBQVlt/QWNjZXNzQ29udHJvbDogYWNjb3VudCAAAAAAAAAAAACBUmAAg1FhDnaBYBeFAWAgiAFhDMJWW38gaXMgbWlzc2luZyByb2xlIAAAAAAAAAAAAAAAAAAAAGAXkYQBkYIBUoNRYQ6zgWAohAFgIIgBYQzCVlsBYCgBlJNQUFBQVltgAIFgABkEgxGCFRUWFWEO2VdhDtlhDgRWW1ACkFZbYACCGYIRFWEO8VdhDvFhDgRWW1ABkFZbY05Ie3Fg4BtgAFJgQWAEUmAkYAD9W2NOSHtxYOAbYABSYDJgBFJgJGAA/VtgAIFhDzFXYQ8xYQ4EVltQYAAZAZBW/qFkc29sY0MACAkACg=="
            },
            {
                "key": "BwOEKvgHT6QVg+NyCCHPFDUEnPk1ZQ==",
                "proof": [],
                "value": "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Anf///////////////////////////////+QkhaRkJEXkJNVVINRkYJSM5KCAZKQklKSFpJQfxfqvQpm+mMfdTfO/dXfaqJdWskEz3WW6VjUOnWgDQ1okQFgQFGAkQOQolBWW2AAgGAAgGAAY/////+Gaf////////////8WERVgQFGAYEABYEBSgGAPgVJgIAF/Tm8gZGF0YSBwcmVzZW50AAAAAAAAAAAAAAAAAAAAAACBUlCQYQfbV2BAUWJGG81g5RuBUmAEAWEFZ5GQYQzyVltQUFBQY/////+DFmAAkIFSYAJgIJCBUmBAkYKQIIJRgIQBkJNSVGAXgZALgIRSYAFgwBuQkQRn//////////8WkpCRAYKQUpOUkJJQgpFQhJBWW2AAY/////+CERVhCERXUGAAkZBQVltQY/////8WYACQgVJgAmAgUmBAkCBUYBcLkFZbYABj/////4IRFWEIdldQYACRkFBWW1Bj/////xZgAJCBUmACYCBSYECQIFRgAWDAG5AEZ///////////FpBWW2AAgoFSYCCBkFJgQJAgYAEBVGEIvIEzYQlNVlthBOiDg2EKaVZbYACAMzIUYQkYV2BAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSf09ubHkgY2FsbGFibGUgYnkgRU9BAAAAAAAAAAAAAAAAYESCAVJgZAFhBWdWW1BQYAFUY/////8WYACQgVJgAmAgUmBAkCBUYBeBkAuRYAFgwBuQkQRn//////////8WkFZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2EJiYFgAWABYKAbAxZgFGEK6FZbYQmUg2AgYQroVltgQFFgIAFhCaWSkZBhDj5WW2BAgFFgHxmBhAMBgVKQgpBSYkYbzWDlG4JSYQVnkWAEAWEM8lZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaEUpCRUpAggFRg/xkWYAEXkFVhCiUzkFZbYAFgAWCgGwMWgWABYAFgoBsDFoN/L4eIEX5+/x2C6SbseUkB0Xx4AkpQJwlAMEVApzNlbw1gQFFgQFGAkQOQpFBQVltgAIKBUmAggYFSYECAgyBgAWABYKAbA4UWhFKQkVKQIFRg/xYVYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaAhVKSUoCDIIBUYP8ZFpBVUTOShZF/9jkfXDLZxp0qR+pnC0QpdLU5NdHtx/1k6yHgR6g5FxuRkKRQUFZbYGBgAGEK94NgAmEOv1ZbYQsCkGACYQ7eVltn//////////+BERVhCxpXYQsaYQ72VltgQFGQgIJSgGAfAWAfGRZgIAGCAWBAUoAVYQtEV2AgggGBgDaDNwGQUFtQkFBgA2D8G4FgAIFRgRBhC19XYQtfYQ8MVltgIAEBkGABYAFg+BsDGRaQgWAAGpBTUGAPYPsbgWABgVGBEGELjldhC45hDwxWW2AgAQGQYAFgAWD4GwMZFpCBYAAakFNQYABhC7KEYAJhDr9WW2ELvZBgAWEO3lZbkFBbYAGBERVhDEJXfzAxMjM0NTY3ODlhYmNkZWYAAAAAAAAAAAAAAAAAAAAAhWAPFmAQgRBhC/5XYQv+YQ8MVlsaYPgbgoKBUYEQYQwUV2EMFGEPDFZbYCABAZBgAWABYPgbAxkWkIFgABqQU1BgBJSQlByTYQw7gWEPIlZbkFBhC8BWW1CDFWEMkVdgQFFiRhvNYOUbgVJgIGAEggGBkFJgJIIBUn9TdHJpbmdzOiBoZXggbGVuZ3RoIGluc3VmZmljaWVudGBEggFSYGQBYQVnVluTklBQUFZbYABgIIKEAxIVYQyqV2AAgP1bgTVgAWABYOAbAxmBFoEUYQyRV2AAgP1bYABbg4EQFWEM3VeBgQFRg4IBUmAgAWEMxVZbg4ERFWEM7FdgAISEAVJbUFBQUFZbYCCBUmAAglGAYCCEAVJhDRGBYECFAWAghwFhDMJWW2AfAWAfGRaRkJEBYEABkpFQUFZbYABgIIKEAxIVYQ03V2AAgP1bUDWRkFBWW2AAgGBAg4UDEhVhDVFXYACA/VuCNZFQYCCDATVgAWABYKAbA4EWgRRhDW9XYACA/VuAkVBQklCSkFBWW2AAYCCChAMSFWENjFdgAID9W4E1gGAXC4EUYQyRV2AAgP1bYABgIIKEAxIVYQ2vV2AAgP1bgTVp/////////////4EWgRRhDJFXYACA/VtgAYGBHJCCFoBhDd1XYH+CFpFQW2AgghCBFBVhDf5XY05Ie3Fg4BtgAFJgImAEUmAkYAD9W1CRkFBWW2NOSHtxYOAbYABSYBFgBFJgJGAA/VtgAGP/////gIMWgYEUFWEONFdhDjRhDgRWW2ABAZOSUFBQVlt/QWNjZXNzQ29udHJvbDogYWNjb3VudCAAAAAAAAAAAACBUmAAg1FhDnaBYBeFAWAgiAFhDMJWW38gaXMgbWlzc2luZyByb2xlIAAAAAAAAAAAAAAAAAAAAGAXkYQBkYIBUoNRYQ6zgWAohAFgIIgBYQzCVlsBYCgBlJNQUFBQVltgAIFgABkEgxGCFRUWFWEO2VdhDtlhDgRWW1ACkFZbYACCGYIRFWEO8VdhDvFhDgRWW1ABkFZbY05Ie3Fg4BtgAFJgQWAEUmAkYAD9W2NOSHtxYOAbYABSYDJgBFJgJGAA/VtgAIFhDzFXYQ8xYQ4EVltQYAAZAZBW/qFkc29sY0MACAkACg=="
            },
            {
                "key": "BwOaawE5b3vnABiCY34wAn4pQmSfBg==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOm6DUHzzeVUxlrfwP8JsVi6Gl7lw==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEBuVdgADVg4ByAY2pieEIRYQD5V4Bjupp6VhFhAJdXgGPSEiCnEWEAcVeAY9ISIKcUYQXaV4Bj1QWszxRhBeJXgGPdYu0+FGEGQFeAY//2yukUYQZ7V2EBuVZbgGO6mnpWFGEFl1eAY7wlz3cUYQWfV4BjxFoBVRRhBdJXYQG5VluAY37OvgARYQDTV4Bjfs6+ABRhBNdXgGOJr8tEFGEFCleAY5XYm0EUYQVWV4BjqQWcuxRhBV5XYQG5VluAY2pieEIUYQRpV4BjcKCCMRRhBJxXgGN0ZPw9FGEEz1dhAblWW4BjI7hy3RFhAWZXgGM2ROUVEWEBQFeAYzZE5RUUYQQWV4BjSFzJVRRhBB5XgGNZCcDVFGEEWVeAY1o9VJMUYQRhV2EBuVZbgGMjuHLdFGEDrVeAYzCt+B8UYQPwV4BjMTzlZxRhA/hXYQG5VluAYwlep7MRYQGXV4BjCV6nsxRhAxVXgGMN/haBFGEDYleAYxgWDd0UYQOTV2EBuVZbgGMCLA2fFGEBvleAYwb93gMUYQJZV4BjCQLxrBRhAtZXW2AAgP1bYQJXYASANgNggIEQFWEB1FdgAID9W4E1kWAggQE1kXP//////////////////////////2BAgwE1FpGQgQGQYICBAWBgggE1ZAEAAAAAgREVYQIYV2AAgP1bggGDYCCCAREVYQIqV2AAgP1bgDWQYCABkYRgAYMChAERZAEAAAAAgxEXFWECTFdgAID9W1CQklCQUGEGg1ZbAFthAmFhDVdWW2BAgFFgIICCUoNRgYMBUoNRkZKDkpCDAZGFAZCAg4NgAFuDgRAVYQKbV4GBAVGDggFSYCABYQKDVltQUFBQkFCQgQGQYB8WgBVhAshXgIIDgFFgAYNgIANhAQAKAxkWgVJgIAGRUFtQklBQUGBAUYCRA5DzW2EC3mENkFZbYECAUW3//////////////////5SFFoFSkpCTFmAggwFSY/////8WgYMBUpBRkIGQA2BgAZDzW2EDTmAEgDYDYECBEBVhAytXYACA/VtQc///////////////////////////gTUWkGAgATVhDeVWW2BAgFGRFRWCUlGQgZADYCABkPNbYQNqYQ38VltgQIBRc///////////////////////////kJIWglJRkIGQA2AgAZDzW2EDm2EOGFZbYECAUZGCUlGQgZADYCABkPNbYQNOYASANgNgYIEQFWEDw1dgAID9W1Bz//////////////////////////+BNYEWkWAggQE1kJEWkGBAATVhDh5WW2EDm2EO/VZbYQQAYQ8hVltgQIBRYP+QkhaCUlGQgZADYCABkPNbYQObYQ8mVlthAldgBIA2A2BAgRAVYQQ0V2AAgP1bUHP//////////////////////////4E1gRaRYCABNRZhDyxWW2EDm2EQBVZbYQObYRALVlthA5tgBIA2A2AggRAVYQR/V2AAgP1bUDVz//////////////////////////8WYRARVlthA5tgBIA2A2AggRAVYQSyV2AAgP1bUDVz//////////////////////////8WYRPLVlthA5thE91WW2EDm2AEgDYDYCCBEBVhBO1XYACA/VtQNXP//////////////////////////xZhE+NWW2EFPWAEgDYDYCCBEBVhBSBXYACA/VtQNXP//////////////////////////xZhE/VWW2BAgFGSg1JgIIMBkZCRUoBRkYKQAwGQ81thAmFhGJJWW2EDTmAEgDYDYECBEBVhBXRXYACA/VtQc///////////////////////////gTUWkGAgATVhGMtWW2EDm2EY2FZbYQJXYASANgNgIIEQFWEFtVdgAID9W1A1c///////////////////////////FmEY3lZbYQNqYRrUVlthA2phGvBWW2ECV2AEgDYDYOCBEBVhBfhXYACA/VtQc///////////////////////////gTWBFpFgIIEBNZCRFpBgQIEBNZBgYIEBNZBg/2CAggE1FpBgoIEBNZBgwAE1YRsMVlthA5tgBIA2A2BAgRAVYQZWV2AAgP1bUHP//////////////////////////4E1gRaRYCABNRZhHdhWW2ECV2Ed9VZbYAxUYAEUYQb0V2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgEWAkggFSf1VuaXN3YXBWMjogTE9DS0VEAAAAAAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgAGAMVYQVFYBhBwdXUGAAhBFbYQdcV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBgIBgIAGCgQOCUmAlgVJgIAGAYSsvYCWROWBAAZFQUGBAUYCRA5D9W2AAgGEHZ2ENkFZbUJFQkVCBbf//////////////////FocQgBVhB5pXUIBt//////////////////8WhhBbYQfvV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBgIBgIAGCgQOCUmAhgVJgIAGAYSt4YCGROWBAAZFQUGBAUYCRA5D9W2AGVGAHVGAAkYKRc///////////////////////////kYIWkZCBFpCJFoIUgBWQYQhUV1CAc///////////////////////////Folz//////////////////////////8WFBVbYQi/V2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgFWAkggFSf1VuaXN3YXBWMjogSU5WQUxJRF9UTwAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VuKFWEI0FdhCNCCio1hH9tWW4kVYQjhV2EI4YGKjGEf21ZbhhVhCcNXiHP//////////////////////////xZjENHoXDONjYyMYEBRhmP/////FmDgG4FSYAQBgIZz//////////////////////////8Wc///////////////////////////FoFSYCABhYFSYCABhIFSYCABgGAgAYKBA4JShISCgYFSYCABklCAgoQ3YACBhAFSYB8ZYB+CARaQUICDAZJQUFCWUFBQUFBQUGAAYEBRgIMDgWAAh4A7FYAVYQmqV2AAgP1bUFrxFYAVYQm+Vz1gAIA+PWAA/VtQUFBQW2BAgFF/cKCCMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUjBgBIIBUpBRc///////////////////////////hBaRY3CggjGRYCSAgwGSYCCSkZCCkAMBgYaAOxWAFWEKL1dgAID9W1Ba+hWAFWEKQ1c9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEKWVdgAID9W1BRYECAUX9woIIxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSMGAEggFSkFGRlVBz//////////////////////////+DFpFjcKCCMZFgJICCAZJgIJKQkZCCkAMBgYaAOxWAFWEKy1dgAID9W1Ba+hWAFWEK31c9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEK9VdgAID9W1BRklBgAJFQUG3//////////////////4UWipADgxFhCx9XYABhCzVWW4mFbf//////////////////FgODA1uQUGAAiYVt//////////////////8WA4MRYQtZV2AAYQtvVluJhW3//////////////////xYDgwNbkFBgAIIRgGELgFdQYACBEVthC9VXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAGAgGAgAYKBA4JSYCSBUmAgAYBhK1RgJJE5YEABkVBQYEBRgJEDkP1bYABhDAlhC+uEYANj/////2Eh6BZWW2EL/YdhA+hj/////2Eh6BZWW5Bj/////2EibhZWW5BQYABhDCFhC+uEYANj/////2Eh6BZWW5BQYQxZYg9CQGEMTW3//////////////////4uBFpCLFmP/////YSHoFlZbkGP/////YSHoFlZbYQxpg4Nj/////2Eh6BZWWxAVYQzWV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgDGAkggFSf1VuaXN3YXBWMjogSwAAAAAAAAAAAAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtQUGEM5ISEiIhhIuBWW2BAgFGDgVJgIIEBg5BSgIIBjZBSYGCBAYyQUpBRc///////////////////////////ixaRM5F/14rZX6RsmUtlUdDahfwnX+YTzjdlf7jV49EwhAFZ2CKRgZADYIABkKNQUGABYAxVUFBQUFBQUFBQVltgQFGAYEABYEBSgGAKgVJgIAF/VW5pc3dhcCBWMgAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUlCBVltgCFRt//////////////////+AghaSbgEAAAAAAAAAAAAAAAAAAIMEkJEWkXwBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAEY/////8WkFZbYABhDfIzhIRhJZxWW1BgAVuSkVBQVltgBlRz//////////////////////////8WgVZbYABUgVZbc///////////////////////////gxZgAJCBUmACYCCQgVJgQICDIDOEUpCRUoEgVH///////////////////////////////////////////xRhDuhXc///////////////////////////hBZgAJCBUmACYCCQgVJgQICDIDOEUpCRUpAgVGEOtpCDY/////9hIm4WVltz//////////////////////////+FFmAAkIFSYAJgIJCBUmBAgIMgM4RSkJFSkCBVW2EO84SEhGEmC1ZbUGABk5JQUFBWW39uce2uErG5f00fYDcP7xAQX6L6rgEmEUoWnGSEXWEmyYFWW2ASgVZbYANUgVZbYAVUc///////////////////////////FjMUYQ+yV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgFGAkggFSf1VuaXN3YXBWMjogRk9SQklEREVOAAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgBoBUc///////////////////////////k4QWf////////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAkYIWF5CRVWAHgFSSkJMWkRYXkFVWW2AJVIFWW2AKVIFWW2AAYAxUYAEUYRCEV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgEWAkggFSf1VuaXN3YXBWMjogTE9DS0VEAAAAAAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgAGAMgZBVgGEQlGENkFZbUGAGVGBAgFF/cKCCMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUjBgBIIBUpBRk5VQkZNQYACSc///////////////////////////kJEWkWNwoIIxkWAkgIMBkmAgkpGQgpADAYGGgDsVgBVhEQ5XYACA/VtQWvoVgBVhESJXPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhEThXYACA/VtQUWAHVGBAgFF/cKCCMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUjBgBIIBUpBRkpNQYACSc///////////////////////////kJIWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYRGxV2AAgP1bUFr6FYAVYRHFVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRHbV2AAgP1bUFGQUGAAYRIBg23//////////////////4cWY/////9hIm4WVluQUGAAYRIlg23//////////////////4cWY/////9hIm4WVluQUGAAYRIzh4dhJuxWW2AAVJCRUIBhEnBXYRJcYQPoYQv9YRJXh4dj/////2Eh6BZWW2EoeFZbmFBhEmtgAGED6GEoylZbYRLNVlthEspt//////////////////+JFmESlIaEY/////9hIegWVluBYRKbV/5bBG3//////////////////4kWYRK9hoVj/////2Eh6BZWW4FhEsRX/lsEYSl6VluYUFtgAIkRYRMmV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBgIBgIAGCgQOCUmAogVJgIAGAYSvBYCiROWBAAZFQUGBAUYCRA5D9W2ETMIqKYSjKVlthEzyGhoqKYSLgVluBFWETfldgCFRhE3qQbf//////////////////gIIWkW4BAAAAAAAAAAAAAAAAAACQBBZj/////2Eh6BZWW2ALVVtgQIBRhYFSYCCBAYWQUoFRM5J/TCCbX8itUHWPE+LhCIulalYN/2kKHG/vJjlPTAOCHE+SgpADAZCiUFBgAWAMVVCUlpVQUFBQUFBWW2ABYCBSYACQgVJgQJAgVIFWW2ALVIFWW2AEYCBSYACQgVJgQJAgVIFWW2AAgGAMVGABFGEUaVdgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBFgJIIBUn9Vbmlzd2FwVjI6IExPQ0tFRAAAAAAAAAAAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bYABgDIGQVYBhFHlhDZBWW1BgBlRgB1RgQIBRf3CggjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVIwYASCAVKQUZSWUJKUUHP//////////////////////////5GCFpORFpFgAJGEkWNwoIIxkWAkgIMBkmAgkpGQgpADAYGGgDsVgBVhFPtXYACA/VtQWvoVgBVhFQ9XPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhFSVXYACA/VtQUWBAgFF/cKCCMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUjBgBIIBUpBRkZJQYACRc///////////////////////////hRaRY3CggjGRYCSAgwGSYCCSkZCCkAMBgYaAOxWAFWEVmVdgAID9W1Ba+hWAFWEVrVc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEVw1dgAID9W1BRMGAAkIFSYAFgIFJgQIEgVJGSUGEV4oiIYSbsVltgAFSQkVCAYRX5hIdj/////2Eh6BZWW4FhFgBX/lsEmlCAYRYUhIZj/////2Eh6BZWW4FhFhtX/lsEmVBgAIsRgBVhFi5XUGAAihFbYRaDV2BAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYAQBgIBgIAGCgQOCUmAogVJgIAGAYSuZYCiROWBAAZFQUGBAUYCRA5D9W2EWjTCEYSmSVlthFpiHjY1hH9tWW2EWo4aNjGEf21ZbYECAUX9woIIxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSMGAEggFSkFFz//////////////////////////+JFpFjcKCCMZFgJICDAZJgIJKRkIKQAwGBhoA7FYAVYRcPV2AAgP1bUFr6FYAVYRcjVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRc5V2AAgP1bUFFgQIBRf3CggjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVIwYASCAVKQUZGWUHP//////////////////////////4gWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYRerV2AAgP1bUFr6FYAVYRe/Vz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRfVV2AAgP1bUFGTUGEX5YWFi4thIuBWW4EVYRgnV2AIVGEYI5Bt//////////////////+AghaRbgEAAAAAAAAAAAAAAAAAAJAEFmP/////YSHoFlZbYAtVW2BAgFGMgVJgIIEBjJBSgVFz//////////////////////////+PFpIzkn/czUEvCxJSgZyx/TMLkyJMpCYSiSuz9PeJl25tgZNklpKQgZADkJEBkKNQUFBQUFBQUFBgAWAMgZBVUJFQkVZbYEBRgGBAAWBAUoBgBoFSYCABf1VOSS1WMgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJQgVZbYABhDfIzhIRhJgtWW2ED6IFWW2AMVGABFGEZT1dgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBFgJIIBUn9Vbmlzd2FwVjI6IExPQ0tFRAAAAAAAAAAAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bYABgDFVgBlRgB1RgCFRgQIBRf3CggjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVIwYASCAVKQUXP//////////////////////////5SFFpSQkxaSYRorkoWSh5JhGiaSbf//////////////////FpGFkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYRnuV2AAgP1bUFr6FYAVYRoCVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRoYV2AAgP1bUFGQY/////9hIm4WVlthH9tWW2AIVGBAgFF/cKCCMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUjBgBIIBUpBRYRrKkoSSh5JhGiaSbgEAAAAAAAAAAAAAAAAAAJAEbf//////////////////FpFz//////////////////////////+GFpFjcKCCMZFgJICCAZJgIJKQkZCCkAMBgYaAOxWAFWEZ7ldgAID9W1BQYAFgDFVQVltgBVRz//////////////////////////8WgVZbYAdUc///////////////////////////FoFWW0KEEBVhG3tXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmASYCSCAVJ/VW5pc3dhcFYyOiBFWFBJUkVEAAAAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W2ADVHP//////////////////////////4CJFmAAgYFSYARgIJCBUmBAgIMggFRgAYCCAZCSVYJRf25x7a4Ssbl/TR9gNw/vEBBfovquASYRShacZIRdYSbJgYYBUoCEAZaQllKVjRZgYIYBUmCAhQGMkFJgoIUBlZCVUmDAgIUBi5BSgVGAhgOQkQGBUmDghQGCUoBRkIMBIH8ZAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGEBAIYBUmEBAoUBlpCWUmEBIoCFAZaQllKAUYCFA5CWAYZSYQFChAGAglKGUZaDAZaQliCVg5BSYQFihAGAglKGkFJg/4kWYQGChQFSYQGihAGIkFJhAcKEAYeQUlGRk5JhAeKAggGTf//////////////////////////////////////////ggQGSgZADkJEBkIVa+hWAFWEc3Fc9YACAPj1gAP1bUFBgQFF//////////////////////////////////////////+ABUZFQUHP//////////////////////////4EWFYAVkGEdV1dQiHP//////////////////////////xaBc///////////////////////////FhRbYR3CV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgHGAkggFSf1VuaXN3YXBWMjogSU5WQUxJRF9TSUdOQVRVUkUAAAAAYESCAVKQUZCBkANgZAGQ/VthHc2JiYlhJZxWW1BQUFBQUFBQUFZbYAJgIJCBUmAAkoNSYECAhCCQkVKQglKQIFSBVltgDFRgARRhHmZXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmARYCSCAVJ/VW5pc3dhcFYyOiBMT0NLRUQAAAAAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W2AAYAxVYAZUYECAUX9woIIxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSMGAEggFSkFFhH9SSc///////////////////////////FpFjcKCCMZFgJICDAZJgIJKRkIKQAwGBhoA7FYAVYR7dV2AAgP1bUFr6FYAVYR7xVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYR8HV2AAgP1bUFFgB1RgQIBRf3CggjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVIwYASCAVKQUXP//////////////////////////5CSFpFjcKCCMZFgJICCAZJgIJKQkZCCkAMBgYaAOxWAFWEfeldgAID9W1Ba+hWAFWEfjlc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEfpFdgAID9W1BRYAhUbf//////////////////gIIWkW4BAAAAAAAAAAAAAAAAAACQBBZhIuBWW2ABYAxVVltgQIBRgIIBglJgGYFSf3RyYW5zZmVyKGFkZHJlc3MsdWludDI1NikAAAAAAAAAYCCRggFSgVFz//////////////////////////+FgRZgJIMBUmBEgIMBhpBShFGAhAOQkQGBUmBkkJIBhFKRgQGAUXv/////////////////////////////////////Fn+pBZy7AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABeBUpJRgVFgAJRgYJSJFpOSkYKRkICDg1tgIIMQYSDhV4BRglJ//////////////////////////////////////////+CQkgGRYCCRggGRAWEgpFZbYAGDYCADYQEACgOAGYJRFoGEURaAgheFUlBQUFBQUJBQAZFQUGAAYEBRgIMDgWAAhlrxkVBQPYBgAIEUYSFDV2BAUZFQYB8ZYD89ARaCAWBAUj2CUj1gAGAghAE+YSFIVltgYJFQW1CRUJFQgYAVYSF2V1CAURWAYSF2V1CAgGAgAZBRYCCBEBVhIXNXYACA/VtQUVthIeFXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAaYCSCAVJ/VW5pc3dhcFYyOiBUUkFOU0ZFUl9GQUlMRUQAAAAAAABgRIIBUpBRkIGQA2BkAZD9W1BQUFBQVltgAIEVgGEiA1dQUICCAoKCgoFhIgBX/lsEFFthDfZXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAUYCSCAVJ/ZHMtbWF0aC1tdWwtb3ZlcmZsb3cAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W4CCA4KBERVhDfZXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAVYCSCAVJ/ZHMtbWF0aC1zdWItdW5kZXJmbG93AAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W23//////////////////4QRgBWQYSMMV1Bt//////////////////+DERVbYSN3V2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgE2AkggFSf1VuaXN3YXBWMjogT1ZFUkZMT1cAAAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgCFRj/////0KBFpF8AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACQBIEWggOQgRYVgBWQYSPHV1Bt//////////////////+EFhUVW4AVYSPiV1Bt//////////////////+DFhUVWxVhJJJXgGP/////FmEkJYVhI/uGYSpXVlt7/////////////////////////////////////xaQY/////9hKnsWVltgCYBUe/////////////////////////////////////+SkJIWkpCSAgGQVWP/////gRZhJGWEYSP7h2EqV1ZbYAqAVHv/////////////////////////////////////kpCSFpKQkgIBkFVbYAiAVH////////////////////////8AAAAAAAAAAAAAAAAAABZt//////////////////+IgRaRkJEXf/////8AAAAAAAAAAAAAAAAAAP//////////////////Fm4BAAAAAAAAAAAAAAAAAACIgxaBApGQkRd7/////////////////////////////////////xZ8AQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABj/////4cWAheSg5BVYECAUYSEFoFSkZCTBJCRFmAgggFSgVF/HEEempbgcSQcLyH3cmsXronjyrTHi+UOBisDqf/7utGSkYGQA5CRAZChUFBQUFBQVltz//////////////////////////+AhBZgAIGBUmACYCCQgVJgQICDIJSHFoCEUpSCUpGCkCCFkFWBUYWBUpFRf4xb4eXr7H1b0U9xQn0ehPPdAxTA97IpHlsgCsjHw7klkoGQA5CRAZCjUFBQVltz//////////////////////////+DFmAAkIFSYAFgIFJgQJAgVGEmQZCCY/////9hIm4WVltz//////////////////////////+AhRZgAJCBUmABYCBSYECAgiCTkJNVkIQWgVIgVGEmg5CCY/////9hKrwWVltz//////////////////////////+AhBZgAIGBUmABYCCQgVJgQJGCkCCUkJRVgFGFgVKQUZGTkocWkn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75KRgpADAZCjUFBQVltgAIBgBWAAkFSQYQEACpAEc///////////////////////////FnP//////////////////////////xZjAX5+WGBAUYFj/////xZg4BuBUmAEAWAgYEBRgIMDgYaAOxWAFWEnV1dgAID9W1Ba+hWAFWEna1c9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEngVdgAID9W1BRYAtUc///////////////////////////ghYVgBWUUJGSUJBhKGRXgBVhKF9XYABhJ9hhEldt//////////////////+IgRaQiBZj/////2Eh6BZWW5BQYABhJ+WDYSh4VluQUICCERVhKFxXYABhKBNhKASEhGP/////YSJuFlZbYABUkGP/////YSHoFlZbkFBgAGEoOINhKCyGYAVj/////2Eh6BZWW5Bj/////2EqvBZWW5BQYACBg4FhKEVX/lsEkFCAFWEoWFdhKFiHgmEoylZbUFBQW1BQW2EocFZbgBVhKHBXYABgC1VbUFCSkVBQVltgAGADghEVYSi7V1CAYAFgAoIEAVuBgRAVYSi1V4CRUGACgYKFgWEopFf+WwQBgWEorVf+WwSQUGEojVZbUGEoxVZbgRVhKMVXUGABW5GQUFZbYABUYSjdkIJj/////2EqvBZWW2AAkIFVc///////////////////////////gxaBUmABYCBSYECQIFRhKRWQgmP/////YSq8FlZbc///////////////////////////gxZgAIGBUmABYCCQgVJgQICDIJSQlFWDUYWBUpNRkpORkn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75KBkAOQkQGQo1BQVltgAIGDEGEpiVeBYSmLVluCW5OSUFBQVltz//////////////////////////+CFmAAkIFSYAFgIFJgQJAgVGEpyJCCY/////9hIm4WVltz//////////////////////////+DFmAAkIFSYAFgIFJgQIEgkZCRVVRhKgKQgmP/////YSJuFlZbYACQgVVgQIBRg4FSkFFz//////////////////////////+FFpF/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++RkIGQA2AgAZCjUFBWW23//////////////////xZuAQAAAAAAAAAAAAAAAAAAApBWW2AAbf//////////////////ghZ7/////////////////////////////////////4QWgWEqtFf+WwSTklBQUFZbgIIBgoEQFWEN9ldgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBRgJIIBUn9kcy1tYXRoLWFkZC1vdmVyZmxvdwAAAAAAAAAAAAAAAGBEggFSkFGQgZADYGQBkP3+VW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfT1VUUFVUX0FNT1VOVFVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX0lOUFVUX0FNT1VOVFVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX0xJUVVJRElUWVVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX0xJUVVJRElUWV9CVVJORURVbmlzd2FwVjI6IElOU1VGRklDSUVOVF9MSVFVSURJVFlfTUlOVEVEomVienpyMVggfcoYR55YSHYGv3DHnkTY3uYjU8nubQH5qdcIhbh2XyJkc29sY0MABRAAMg=="
            },
            {
                "key": "BwOrLm6O7Dx/Er+OqFKSW0a5MavGKg==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwOxmMDYl1VHNFR13pIi0WlOeuMONg==",
                "proof": [],
                "value": "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GwOCFmEHRldgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSYCOBUmAgAYBhCgFgI5E5YEABkVBQYEBRgJEDkP1bYQeJgWBAUYBgYAFgQFKAYCaBUmAgAWEKRmAmkTlgAWABYKAbA4YWYACQgVJgIIGQUmBAkCBUkZBj/////2EIGBZWW2ABYAFgoBsDgIUWYACQgVJgIIGQUmBAgIIgk5CTVZCEFoFSIFRhB76QgmP/////YQivFlZbYAFgAWCgGwOAhBZgAIGBUmAggYFSYECRgpAglJCUVYBRhYFSkFGRk5KHFpJ/3fJSrRviyJtpwrBo/DeNqpUrp/FjxKEWKPVaTfUjs++SkYKQAwGQo1BQUFZbYACBhIQRFWEIp1dgQFFiRhvNYOUbgVJgBAGAgGAgAYKBA4JSg4GBUYFSYCABkVCAUZBgIAGQgIODYABbg4EQFWEIbFeBgQFRg4IBUmAgAWEIVFZbUFBQUJBQkIEBkGAfFoAVYQiZV4CCA4BRYAGDYCADYQEACgMZFoFSYCABkVBbUJJQUFBgQFGAkQOQ/VtQUFCQA5BWW2AAgoIBg4EQFWEJCVdgQIBRYkYbzWDlG4FSYCBgBIIBUmAbYCSCAVJ/U2FmZU1hdGg6IGFkZGl0aW9uIG92ZXJmbG93AAAAAABgRIIBUpBRkIGQA2BkAZD9W5OSUFBQVltgAWABYKAbA4IWYQlrV2BAgFFiRhvNYOUbgVJgIGAEggFSYB9gJIIBUn9FUkMyMDogbWludCB0byB0aGUgemVybyBhZGRyZXNzAGBEggFSkFGQgZADYGQBkP1bYAJUYQl+kIJj/////2EIrxZWW2ACVWABYAFgoBsDghZgAJCBUmAggZBSYECQIFRhCaqQgmP/////YQivFlZbYAFgAWCgGwODFmAAgYFSYCCBgVJgQICDIJSQlFWDUYWBUpNRkpORkn/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75KBkAOQkQGQo1BQVv5FUkMyMDogdHJhbnNmZXIgdG8gdGhlIHplcm8gYWRkcmVzc0VSQzIwOiBhcHByb3ZlIHRvIHRoZSB6ZXJvIGFkZHJlc3NFUkMyMDogdHJhbnNmZXIgYW1vdW50IGV4Y2VlZHMgYmFsYW5jZUVSQzIwOiB0cmFuc2ZlciBhbW91bnQgZXhjZWVkcyBhbGxvd2FuY2VFUkMyMDogdHJhbnNmZXIgZnJvbSB0aGUgemVybyBhZGRyZXNzRVJDMjA6IGFwcHJvdmUgZnJvbSB0aGUgemVybyBhZGRyZXNzRVJDMjA6IGRlY3JlYXNlZCBhbGxvd2FuY2UgYmVsb3cgemVyb6JlYnp6cjFYIN+VXdyQSPN23HwhPpca+f/2wyjvOK6TNcxZRUr9oYTTZHNvbGNDAAUQADI="
            },
            {
                "key": "BwPbnsmE7PHdDISdRrFDP1Z5vx3gKQ==",
                "proof": [],
                "value": "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"
            },
            {
                "key": "BwPwk1yq9f5/fVopXqPAFeeeH5KbTg==",
                "proof": [],
                "value": "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Anf///////////////////////////////+QkhaRkJEXkJNVVINRkYJSM5KCAZKQklKSFpJQfxfqvQpm+mMfdTfO/dXfaqJdWskEz3WW6VjUOnWgDQ1okQFgQFGAkQOQolBWW2AAgGAAgGAAY/////+Gaf////////////8WERVgQFGAYEABYEBSgGAPgVJgIAF/Tm8gZGF0YSBwcmVzZW50AAAAAAAAAAAAAAAAAAAAAACBUlCQYQfbV2BAUWJGG81g5RuBUmAEAWEFZ5GQYQzyVltQUFBQY/////+DFmAAkIFSYAJgIJCBUmBAkYKQIIJRgIQBkJNSVGAXgZALgIRSYAFgwBuQkQRn//////////8WkpCRAYKQUpOUkJJQgpFQhJBWW2AAY/////+CERVhCERXUGAAkZBQVltQY/////8WYACQgVJgAmAgUmBAkCBUYBcLkFZbYABj/////4IRFWEIdldQYACRkFBWW1Bj/////xZgAJCBUmACYCBSYECQIFRgAWDAG5AEZ///////////FpBWW2AAgoFSYCCBkFJgQJAgYAEBVGEIvIEzYQlNVlthBOiDg2EKaVZbYACAMzIUYQkYV2BAUWJGG81g5RuBUmAgYASCAVJgFGAkggFSf09ubHkgY2FsbGFibGUgYnkgRU9BAAAAAAAAAAAAAAAAYESCAVJgZAFhBWdWW1BQYAFUY/////8WYACQgVJgAmAgUmBAkCBUYBeBkAuRYAFgwBuQkQRn//////////8WkFZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2EJiYFgAWABYKAbAxZgFGEK6FZbYQmUg2AgYQroVltgQFFgIAFhCaWSkZBhDj5WW2BAgFFgHxmBhAMBgVKQgpBSYkYbzWDlG4JSYQVnkWAEAWEM8lZbYACCgVJgIIGBUmBAgIMgYAFgAWCgGwOFFoRSkJFSkCBUYP8WYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaEUpCRUpAggFRg/xkWYAEXkFVhCiUzkFZbYAFgAWCgGwMWgWABYAFgoBsDFoN/L4eIEX5+/x2C6SbseUkB0Xx4AkpQJwlAMEVApzNlbw1gQFFgQFGAkQOQpFBQVltgAIKBUmAggYFSYECAgyBgAWABYKAbA4UWhFKQkVKQIFRg/xYVYQV6V2AAgoFSYCCBgVJgQICDIGABYAFgoBsDhRaAhVKSUoCDIIBUYP8ZFpBVUTOShZF/9jkfXDLZxp0qR+pnC0QpdLU5NdHtx/1k6yHgR6g5FxuRkKRQUFZbYGBgAGEK94NgAmEOv1ZbYQsCkGACYQ7eVltn//////////+BERVhCxpXYQsaYQ72VltgQFGQgIJSgGAfAWAfGRZgIAGCAWBAUoAVYQtEV2AgggGBgDaDNwGQUFtQkFBgA2D8G4FgAIFRgRBhC19XYQtfYQ8MVltgIAEBkGABYAFg+BsDGRaQgWAAGpBTUGAPYPsbgWABgVGBEGELjldhC45hDwxWW2AgAQGQYAFgAWD4GwMZFpCBYAAakFNQYABhC7KEYAJhDr9WW2ELvZBgAWEO3lZbkFBbYAGBERVhDEJXfzAxMjM0NTY3ODlhYmNkZWYAAAAAAAAAAAAAAAAAAAAAhWAPFmAQgRBhC/5XYQv+YQ8MVlsaYPgbgoKBUYEQYQwUV2EMFGEPDFZbYCABAZBgAWABYPgbAxkWkIFgABqQU1BgBJSQlByTYQw7gWEPIlZbkFBhC8BWW1CDFWEMkVdgQFFiRhvNYOUbgVJgIGAEggGBkFJgJIIBUn9TdHJpbmdzOiBoZXggbGVuZ3RoIGluc3VmZmljaWVudGBEggFSYGQBYQVnVluTklBQUFZbYABgIIKEAxIVYQyqV2AAgP1bgTVgAWABYOAbAxmBFoEUYQyRV2AAgP1bYABbg4EQFWEM3VeBgQFRg4IBUmAgAWEMxVZbg4ERFWEM7FdgAISEAVJbUFBQUFZbYCCBUmAAglGAYCCEAVJhDRGBYECFAWAghwFhDMJWW2AfAWAfGRaRkJEBYEABkpFQUFZbYABgIIKEAxIVYQ03V2AAgP1bUDWRkFBWW2AAgGBAg4UDEhVhDVFXYACA/VuCNZFQYCCDATVgAWABYKAbA4EWgRRhDW9XYACA/VuAkVBQklCSkFBWW2AAYCCChAMSFWENjFdgAID9W4E1gGAXC4EUYQyRV2AAgP1bYABgIIKEAxIVYQ2vV2AAgP1bgTVp/////////////4EWgRRhDJFXYACA/VtgAYGBHJCCFoBhDd1XYH+CFpFQW2AgghCBFBVhDf5XY05Ie3Fg4BtgAFJgImAEUmAkYAD9W1CRkFBWW2NOSHtxYOAbYABSYBFgBFJgJGAA/VtgAGP/////gIMWgYEUFWEONFdhDjRhDgRWW2ABAZOSUFBQVlt/QWNjZXNzQ29udHJvbDogYWNjb3VudCAAAAAAAAAAAACBUmAAg1FhDnaBYBeFAWAgiAFhDMJWW38gaXMgbWlzc2luZyByb2xlIAAAAAAAAAAAAAAAAAAAAGAXkYQBkYIBUoNRYQ6zgWAohAFgIIgBYQzCVlsBYCgBlJNQUFBQVltgAIFgABkEgxGCFRUWFWEO2VdhDtlhDgRWW1ACkFZbYACCGYIRFWEO8VdhDvFhDgRWW1ABkFZbY05Ie3Fg4BtgAFJgQWAEUmAkYAD9W2NOSHtxYOAbYABSYDJgBFJgJGAA/VtgAIFhDzFXYQ8xYQ4EVltQYAAZAZBW/qFkc29sY0MACAkACg=="
            },
            {
                "key": "BwP5TvpQXEUeeuAkVT0xjTHh81wy9A==",
                "proof": [],
                "value": "YIBgQFI0gBVhABBXYACA/VtQYAQ2EGEAiFdgADVg4ByAY6LnSvYRYQBbV4BjoudK9hRhAP1XgGPJxlOWFGEBMleAY+akOQUUYQFtV4Bj9GkB7RRhAahXYQCIVluAYwF+flgUYQCNV4BjCUt0FRRhAL5XgGMePdGLFGEAxleAY1dPK6MUYQDjV1tgAID9W2EAlWEB21ZbYECAUXP//////////////////////////5CSFoJSUZCBkANgIAGQ81thAJVhAfdWW2EAlWAEgDYDYCCBEBVhANxXYACA/VtQNWECE1ZbYQDrYQJHVltgQIBRkYJSUZCBkANgIAGQ81thATBgBIA2A2AggRAVYQETV2AAgP1bUDVz//////////////////////////8WYQJNVlsAW2EAlWAEgDYDYECBEBVhAUhXYACA/VtQc///////////////////////////gTWBFpFgIAE1FmEDGlZbYQCVYASANgNgQIEQFWEBg1dgAID9W1Bz//////////////////////////+BNYEWkWAgATUWYQdtVlthATBgBIA2A2AggRAVYQG+V2AAgP1bUDVz//////////////////////////8WYQegVltgAFRz//////////////////////////8WgVZbYAFUc///////////////////////////FoFWW2ADgYFUgRBhAiBX/ltgAJGCUmAgkJEgAVRz//////////////////////////8WkFCBVltgA1SQVltgAVRz//////////////////////////8WMxRhAtNXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAUYCSCAVJ/VW5pc3dhcFYyOiBGT1JCSURERU4AAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W2ABgFR/////////////////AAAAAAAAAAAAAAAAAAAAAAAAAAAWc///////////////////////////kpCSFpGQkReQVVZbYACBc///////////////////////////FoNz//////////////////////////8WFBVhA7dXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAeYCSCAVJ/VW5pc3dhcFYyOiBJREVOVElDQUxfQUREUkVTU0VTAABgRIIBUpBRkIGQA2BkAZD9W2AAgINz//////////////////////////8WhXP//////////////////////////xYQYQP0V4OFYQP3VluEhFuQklCQUHP//////////////////////////4IWYQR+V2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgF2AkggFSf1VuaXN3YXBWMjogWkVST19BRERSRVNTAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/Vtz//////////////////////////+CgRZgAJCBUmACYCCQgVJgQICDIIWFFoRSkJFSkCBUFhVhBR9XYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAWYCSCAVJ/VW5pc3dhcFYyOiBQQUlSX0VYSVNUUwAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W2BgYEBRgGAgAWEFMZBhCG1WW2AgggGBA4JSYB8ZYB+CARZgQFJQkFBgAIODYEBRYCABgINz//////////////////////////8Wc///////////////////////////FmBgG4FSYBQBgnP//////////////////////////xZz//////////////////////////8WYGAbgVJgFAGSUFBQYEBRYCCBgwMDgVKQYEBSgFGQYCABIJBQgIJRYCCEAWAA9WBAgFF/SFzJVQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUnP//////////////////////////4eBFmAEgwFShoEWYCSDAVKRUZKXUJCHFpFjSFzJVZFgRICCAZJgAJKQkZCCkAMBgYOHgDsVgBVhBl5XYACA/VtQWvEVgBVhBnJXPWAAgD49YAD9W1BQUFBz//////////////////////////+EgRZgAIGBUmACYCCBgVJgQICEIImHFoCGUpCDUoGFIIBUl40Wf////////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAmIkWgReQkVWTg1KBhSCGhlKDUoGFIIBUiBaFF5BVYAOAVGABgQGCVZWBkFJ/wldaDp5ZPAD5WfjJLxLbKGnDOVo7BQLQXiUWRG9x+FuQlQGAVJCXFoQXkJZVklSDUZKDUpCCAVKBUX8NNki9D2uoATSjO6knWsWF2dMV8K2DVc3e/eMa+ijQ6ZKRgZADkJEBkKNQUFBQkpFQUFZbYAJgIJCBUmAAkoNSYECAhCCQkVKQglKQIFRz//////////////////////////8WgVZbYAFUc///////////////////////////FjMUYQgmV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgFGAkggFSf1VuaXN3YXBWMjogRk9SQklEREVOAAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgAIBUf////////////////wAAAAAAAAAAAAAAAAAAAAAAAAAAFnP//////////////////////////5KQkhaRkJEXkFVWW2EtdIBhCHuDOQGQVv5ggGBAUmABYAxVNIAVYQAVV2AAgP1bUGBAUUaQgGBSYS0igjlgQIBRkYKQA2BSAYIggoIBglJgCoNSaSq3NLm7sLgQKxlgsRtgIJOEAVKBUYCDAYNSYAGBUmAxYPgbkIQBUoFRgIQBkZCRUn+/zI75j/v3tsP+x79RhbVmuYY+NanYOs1JrWgktZaXOIGDAVJ/yJ79qlTA8gx632Eogt8JUPWpUWN+AwfNy0xnLymLi8ZgYIIBUmCAgQGUkJRSMGCggIYBkZCRUoFRgIYDkJEBgVJgwJCUAZBSglGSAZGQkSBgA1VQYAWAVGABYAFgoBsDGRYzF5BVYSwdgGEBBWAAOWAA8/5ggGBAUjSAFWEAEFdgAID9W1BgBDYQYQG5V2AANWDgHIBjamJ4QhFhAPlXgGO6mnpWEWEAl1eAY9ISIKcRYQBxV4Bj0hIgpxRhBdpXgGPVBazPFGEF4leAY91i7T4UYQZAV4Bj//bK6RRhBntXYQG5VluAY7qaelYUYQWXV4BjvCXPdxRhBZ9XgGPEWgFVFGEF0ldhAblWW4Bjfs6+ABFhANNXgGN+zr4AFGEE11eAY4mvy0QUYQUKV4BjldibQRRhBVZXgGOpBZy7FGEFXldhAblWW4BjamJ4QhRhBGlXgGNwoIIxFGEEnFeAY3Rk/D0UYQTPV2EBuVZbgGMjuHLdEWEBZleAYzZE5RURYQFAV4BjNkTlFRRhBBZXgGNIXMlVFGEEHleAY1kJwNUUYQRZV4BjWj1UkxRhBGFXYQG5VluAYyO4ct0UYQOtV4BjMK34HxRhA/BXgGMxPOVnFGED+FdhAblWW4BjCV6nsxFhAZdXgGMJXqezFGEDFVeAYw3+FoEUYQNiV4BjGBYN3RRhA5NXYQG5VluAYwIsDZ8UYQG+V4BjBv3eAxRhAllXgGMJAvGsFGEC1ldbYACA/VthAldgBIA2A2CAgRAVYQHUV2AAgP1bgTWRYCCBATWRc///////////////////////////YECDATUWkZCBAZBggIEBYGCCATVkAQAAAACBERVhAhhXYACA/VuCAYNgIIIBERVhAipXYACA/VuANZBgIAGRhGABgwKEARFkAQAAAACDERcVYQJMV2AAgP1bUJCSUJBQYQaDVlsAW2ECYWENV1ZbYECAUWAggIJSg1GBgwFSg1GRkoOSkIMBkYUBkICDg2AAW4OBEBVhAptXgYEBUYOCAVJgIAFhAoNWW1BQUFCQUJCBAZBgHxaAFWECyFeAggOAUWABg2AgA2EBAAoDGRaBUmAgAZFQW1CSUFBQYEBRgJEDkPNbYQLeYQ2QVltgQIBRbf//////////////////lIUWgVKSkJMWYCCDAVJj/////xaBgwFSkFGQgZADYGABkPNbYQNOYASANgNgQIEQFWEDK1dgAID9W1Bz//////////////////////////+BNRaQYCABNWEN5VZbYECAUZEVFYJSUZCBkANgIAGQ81thA2phDfxWW2BAgFFz//////////////////////////+QkhaCUlGQgZADYCABkPNbYQObYQ4YVltgQIBRkYJSUZCBkANgIAGQ81thA05gBIA2A2BggRAVYQPDV2AAgP1bUHP//////////////////////////4E1gRaRYCCBATWQkRaQYEABNWEOHlZbYQObYQ79VlthBABhDyFWW2BAgFFg/5CSFoJSUZCBkANgIAGQ81thA5thDyZWW2ECV2AEgDYDYECBEBVhBDRXYACA/VtQc///////////////////////////gTWBFpFgIAE1FmEPLFZbYQObYRAFVlthA5thEAtWW2EDm2AEgDYDYCCBEBVhBH9XYACA/VtQNXP//////////////////////////xZhEBFWW2EDm2AEgDYDYCCBEBVhBLJXYACA/VtQNXP//////////////////////////xZhE8tWW2EDm2ET3VZbYQObYASANgNgIIEQFWEE7VdgAID9W1A1c///////////////////////////FmET41ZbYQU9YASANgNgIIEQFWEFIFdgAID9W1A1c///////////////////////////FmET9VZbYECAUZKDUmAggwGRkJFSgFGRgpADAZDzW2ECYWEYklZbYQNOYASANgNgQIEQFWEFdFdgAID9W1Bz//////////////////////////+BNRaQYCABNWEYy1ZbYQObYRjYVlthAldgBIA2A2AggRAVYQW1V2AAgP1bUDVz//////////////////////////8WYRjeVlthA2phGtRWW2EDamEa8FZbYQJXYASANgNg4IEQFWEF+FdgAID9W1Bz//////////////////////////+BNYEWkWAggQE1kJEWkGBAgQE1kGBggQE1kGD/YICCATUWkGCggQE1kGDAATVhGwxWW2EDm2AEgDYDYECBEBVhBlZXYACA/VtQc///////////////////////////gTWBFpFgIAE1FmEd2FZbYQJXYR31VltgDFRgARRhBvRXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmARYCSCAVJ/VW5pc3dhcFYyOiBMT0NLRUQAAAAAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W2AAYAxVhBUVgGEHB1dQYACEEVthB1xXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAGAgGAgAYKBA4JSYCWBUmAgAYBhKy9gJZE5YEABkVBQYEBRgJEDkP1bYACAYQdnYQ2QVltQkVCRUIFt//////////////////8WhxCAFWEHmldQgG3//////////////////xaGEFthB+9XYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAGAgGAgAYKBA4JSYCGBUmAgAYBhK3hgIZE5YEABkVBQYEBRgJEDkP1bYAZUYAdUYACRgpFz//////////////////////////+RghaRkIEWkIkWghSAFZBhCFRXUIBz//////////////////////////8WiXP//////////////////////////xYUFVthCL9XYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAVYCSCAVJ/VW5pc3dhcFYyOiBJTlZBTElEX1RPAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W4oVYQjQV2EI0IKKjWEf21ZbiRVhCOFXYQjhgYqMYR/bVluGFWEJw1eIc///////////////////////////FmMQ0ehcM42NjIxgQFGGY/////8WYOAbgVJgBAGAhnP//////////////////////////xZz//////////////////////////8WgVJgIAGFgVJgIAGEgVJgIAGAYCABgoEDglKEhIKBgVJgIAGSUICChDdgAIGEAVJgHxlgH4IBFpBQgIMBklBQUJZQUFBQUFBQYABgQFGAgwOBYACHgDsVgBVhCapXYACA/VtQWvEVgBVhCb5XPWAAgD49YAD9W1BQUFBbYECAUX9woIIxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSMGAEggFSkFFz//////////////////////////+EFpFjcKCCMZFgJICDAZJgIJKRkIKQAwGBhoA7FYAVYQovV2AAgP1bUFr6FYAVYQpDVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYQpZV2AAgP1bUFFgQIBRf3CggjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVIwYASCAVKQUZGVUHP//////////////////////////4MWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYQrLV2AAgP1bUFr6FYAVYQrfVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYQr1V2AAgP1bUFGSUGAAkVBQbf//////////////////hRaKkAODEWELH1dgAGELNVZbiYVt//////////////////8WA4MDW5BQYACJhW3//////////////////xYDgxFhC1lXYABhC29WW4mFbf//////////////////FgODA1uQUGAAghGAYQuAV1BgAIERW2EL1VdgQFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAEAYCAYCABgoEDglJgJIFSYCABgGErVGAkkTlgQAGRUFBgQFGAkQOQ/VtgAGEMCWEL64RgA2P/////YSHoFlZbYQv9h2ED6GP/////YSHoFlZbkGP/////YSJuFlZbkFBgAGEMIWEL64RgA2P/////YSHoFlZbkFBhDFliD0JAYQxNbf//////////////////i4EWkIsWY/////9hIegWVluQY/////9hIegWVlthDGmDg2P/////YSHoFlZbEBVhDNZXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAMYCSCAVJ/VW5pc3dhcFYyOiBLAAAAAAAAAAAAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W1BQYQzkhISIiGEi4FZbYECAUYOBUmAggQGDkFKAggGNkFJgYIEBjJBSkFFz//////////////////////////+LFpEzkX/XitlfpGyZS2VR0NqF/Cdf5hPON2V/uNXj0TCEAVnYIpGBkANggAGQo1BQYAFgDFVQUFBQUFBQUFBWW2BAUYBgQAFgQFKAYAqBUmAgAX9Vbmlzd2FwIFYyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSUIFWW2AIVG3//////////////////4CCFpJuAQAAAAAAAAAAAAAAAAAAgwSQkRaRfAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkARj/////xaQVltgAGEN8jOEhGElnFZbUGABW5KRUFBWW2AGVHP//////////////////////////xaBVltgAFSBVltz//////////////////////////+DFmAAkIFSYAJgIJCBUmBAgIMgM4RSkJFSgSBUf///////////////////////////////////////////FGEO6Fdz//////////////////////////+EFmAAkIFSYAJgIJCBUmBAgIMgM4RSkJFSkCBUYQ62kINj/////2EibhZWW3P//////////////////////////4UWYACQgVJgAmAgkIFSYECAgyAzhFKQkVKQIFVbYQ7zhISEYSYLVltQYAGTklBQUFZbf25x7a4Ssbl/TR9gNw/vEBBfovquASYRShacZIRdYSbJgVZbYBKBVltgA1SBVltgBVRz//////////////////////////8WMxRhD7JXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAUYCSCAVJ/VW5pc3dhcFYyOiBGT1JCSURERU4AAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W2AGgFRz//////////////////////////+ThBZ/////////////////AAAAAAAAAAAAAAAAAAAAAAAAAACRghYXkJFVYAeAVJKQkxaRFheQVVZbYAlUgVZbYApUgVZbYABgDFRgARRhEIRXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmARYCSCAVJ/VW5pc3dhcFYyOiBMT0NLRUQAAAAAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W2AAYAyBkFWAYRCUYQ2QVltQYAZUYECAUX9woIIxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSMGAEggFSkFGTlVCRk1BgAJJz//////////////////////////+QkRaRY3CggjGRYCSAgwGSYCCSkZCCkAMBgYaAOxWAFWERDldgAID9W1Ba+hWAFWERIlc9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEROFdgAID9W1BRYAdUYECAUX9woIIxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSMGAEggFSkFGSk1BgAJJz//////////////////////////+QkhaRY3CggjGRYCSAggGSYCCSkJGQgpADAYGGgDsVgBVhEbFXYACA/VtQWvoVgBVhEcVXPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhEdtXYACA/VtQUZBQYABhEgGDbf//////////////////hxZj/////2EibhZWW5BQYABhEiWDbf//////////////////hxZj/////2EibhZWW5BQYABhEjOHh2Em7FZbYABUkJFQgGEScFdhElxhA+hhC/1hEleHh2P/////YSHoFlZbYSh4VluYUGESa2AAYQPoYSjKVlthEs1WW2ESym3//////////////////4kWYRKUhoRj/////2Eh6BZWW4FhEptX/lsEbf//////////////////iRZhEr2GhWP/////YSHoFlZbgWESxFf+WwRhKXpWW5hQW2AAiRFhEyZXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAGAgGAgAYKBA4JSYCiBUmAgAYBhK8FgKJE5YEABkVBQYEBRgJEDkP1bYRMwiophKMpWW2ETPIaGiophIuBWW4EVYRN+V2AIVGETepBt//////////////////+AghaRbgEAAAAAAAAAAAAAAAAAAJAEFmP/////YSHoFlZbYAtVW2BAgFGFgVJgIIEBhZBSgVEzkn9MIJtfyK1QdY8T4uEIi6VqVg3/aQocb+8mOU9MA4IcT5KCkAMBkKJQUGABYAxVUJSWlVBQUFBQUFZbYAFgIFJgAJCBUmBAkCBUgVZbYAtUgVZbYARgIFJgAJCBUmBAkCBUgVZbYACAYAxUYAEUYRRpV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgEWAkggFSf1VuaXN3YXBWMjogTE9DS0VEAAAAAAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgAGAMgZBVgGEUeWENkFZbUGAGVGAHVGBAgFF/cKCCMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUjBgBIIBUpBRlJZQkpRQc///////////////////////////kYIWk5EWkWAAkYSRY3CggjGRYCSAgwGSYCCSkZCCkAMBgYaAOxWAFWEU+1dgAID9W1Ba+hWAFWEVD1c9YACAPj1gAP1bUFBQUGBAUT1gIIEQFWEVJVdgAID9W1BRYECAUX9woIIxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSMGAEggFSkFGRklBgAJFz//////////////////////////+FFpFjcKCCMZFgJICDAZJgIJKRkIKQAwGBhoA7FYAVYRWZV2AAgP1bUFr6FYAVYRWtVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYRXDV2AAgP1bUFEwYACQgVJgAWAgUmBAgSBUkZJQYRXiiIhhJuxWW2AAVJCRUIBhFfmEh2P/////YSHoFlZbgWEWAFf+WwSaUIBhFhSEhmP/////YSHoFlZbgWEWG1f+WwSZUGAAixGAFWEWLldQYACKEVthFoNXYEBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgBAGAgGAgAYKBA4JSYCiBUmAgAYBhK5lgKJE5YEABkVBQYEBRgJEDkP1bYRaNMIRhKZJWW2EWmIeNjWEf21ZbYRajho2MYR/bVltgQIBRf3CggjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVIwYASCAVKQUXP//////////////////////////4kWkWNwoIIxkWAkgIMBkmAgkpGQgpADAYGGgDsVgBVhFw9XYACA/VtQWvoVgBVhFyNXPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhFzlXYACA/VtQUWBAgFF/cKCCMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUjBgBIIBUpBRkZZQc///////////////////////////iBaRY3CggjGRYCSAggGSYCCSkJGQgpADAYGGgDsVgBVhF6tXYACA/VtQWvoVgBVhF79XPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhF9VXYACA/VtQUZNQYRflhYWLi2Ei4FZbgRVhGCdXYAhUYRgjkG3//////////////////4CCFpFuAQAAAAAAAAAAAAAAAAAAkAQWY/////9hIegWVltgC1VbYECAUYyBUmAggQGMkFKBUXP//////////////////////////48WkjOSf9zNQS8LElKBnLH9MwuTIkykJhKJK7P094mXbm2Bk2SWkpCBkAOQkQGQo1BQUFBQUFBQUGABYAyBkFVQkVCRVltgQFGAYEABYEBSgGAGgVJgIAF/VU5JLVYyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUlCBVltgAGEN8jOEhGEmC1ZbYQPogVZbYAxUYAEUYRlPV2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgEWAkggFSf1VuaXN3YXBWMjogTE9DS0VEAAAAAAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/VtgAGAMVWAGVGAHVGAIVGBAgFF/cKCCMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUjBgBIIBUpBRc///////////////////////////lIUWlJCTFpJhGiuShZKHkmEaJpJt//////////////////8WkYWRY3CggjGRYCSAggGSYCCSkJGQgpADAYGGgDsVgBVhGe5XYACA/VtQWvoVgBVhGgJXPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhGhhXYACA/VtQUZBj/////2EibhZWW2Ef21ZbYAhUYECAUX9woIIxAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSMGAEggFSkFFhGsqShJKHkmEaJpJuAQAAAAAAAAAAAAAAAAAAkARt//////////////////8WkXP//////////////////////////4YWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYRnuV2AAgP1bUFBgAWAMVVBWW2AFVHP//////////////////////////xaBVltgB1Rz//////////////////////////8WgVZbQoQQFWEbe1dgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBJgJIIBUn9Vbmlzd2FwVjI6IEVYUElSRUQAAAAAAAAAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bYANUc///////////////////////////gIkWYACBgVJgBGAgkIFSYECAgyCAVGABgIIBkJJVglF/bnHtrhKxuX9NH2A3D+8QEF+i+q4BJhFKFpxkhF1hJsmBhgFSgIQBlpCWUpWNFmBghgFSYICFAYyQUmCghQGVkJVSYMCAhQGLkFKBUYCGA5CRAYFSYOCFAYJSgFGQgwEgfxkBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYQEAhgFSYQEChQGWkJZSYQEigIUBlpCWUoBRgIUDkJYBhlJhAUKEAYCCUoZRloMBlpCWIJWDkFJhAWKEAYCCUoaQUmD/iRZhAYKFAVJhAaKEAYiQUmEBwoQBh5BSUZGTkmEB4oCCAZN//////////////////////////////////////////+CBAZKBkAOQkQGQhVr6FYAVYRzcVz1gAIA+PWAA/VtQUGBAUX//////////////////////////////////////////4AFRkVBQc///////////////////////////gRYVgBWQYR1XV1CIc///////////////////////////FoFz//////////////////////////8WFFthHcJXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmAcYCSCAVJ/VW5pc3dhcFYyOiBJTlZBTElEX1NJR05BVFVSRQAAAABgRIIBUpBRkIGQA2BkAZD9W2EdzYmJiWElnFZbUFBQUFBQUFBQVltgAmAgkIFSYACSg1JgQICEIJCRUpCCUpAgVIFWW2AMVGABFGEeZldgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBFgJIIBUn9Vbmlzd2FwVjI6IExPQ0tFRAAAAAAAAAAAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bYABgDFVgBlRgQIBRf3CggjEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVIwYASCAVKQUWEf1JJz//////////////////////////8WkWNwoIIxkWAkgIMBkmAgkpGQgpADAYGGgDsVgBVhHt1XYACA/VtQWvoVgBVhHvFXPWAAgD49YAD9W1BQUFBgQFE9YCCBEBVhHwdXYACA/VtQUWAHVGBAgFF/cKCCMQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUjBgBIIBUpBRc///////////////////////////kJIWkWNwoIIxkWAkgIIBkmAgkpCRkIKQAwGBhoA7FYAVYR96V2AAgP1bUFr6FYAVYR+OVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYR+kV2AAgP1bUFFgCFRt//////////////////+AghaRbgEAAAAAAAAAAAAAAAAAAJAEFmEi4FZbYAFgDFVWW2BAgFGAggGCUmAZgVJ/dHJhbnNmZXIoYWRkcmVzcyx1aW50MjU2KQAAAAAAAABgIJGCAVKBUXP//////////////////////////4WBFmAkgwFSYESAgwGGkFKEUYCEA5CRAYFSYGSQkgGEUpGBAYBRe/////////////////////////////////////8Wf6kFnLsAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF4FSklGBUWAAlGBglIkWk5KRgpGQgIODW2AggxBhIOFXgFGCUn//////////////////////////////////////////4JCSAZFgIJGCAZEBYSCkVltgAYNgIANhAQAKA4AZglEWgYRRFoCCF4VSUFBQUFBQkFABkVBQYABgQFGAgwOBYACGWvGRUFA9gGAAgRRhIUNXYEBRkVBgHxlgPz0BFoIBYEBSPYJSPWAAYCCEAT5hIUhWW2BgkVBbUJFQkVCBgBVhIXZXUIBRFYBhIXZXUICAYCABkFFgIIEQFWEhc1dgAID9W1BRW2Eh4VdgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBpgJIIBUn9Vbmlzd2FwVjI6IFRSQU5TRkVSX0ZBSUxFRAAAAAAAAGBEggFSkFGQgZADYGQBkP1bUFBQUFBWW2AAgRWAYSIDV1BQgIICgoKCgWEiAFf+WwQUW2EN9ldgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBRgJIIBUn9kcy1tYXRoLW11bC1vdmVyZmxvdwAAAAAAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bgIIDgoERFWEN9ldgQIBRfwjDeaAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgVJgIGAEggFSYBVgJIIBUn9kcy1tYXRoLXN1Yi11bmRlcmZsb3cAAAAAAAAAAAAAAGBEggFSkFGQgZADYGQBkP1bbf//////////////////hBGAFZBhIwxXUG3//////////////////4MRFVthI3dXYECAUX8Iw3mgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIFSYCBgBIIBUmATYCSCAVJ/VW5pc3dhcFYyOiBPVkVSRkxPVwAAAAAAAAAAAAAAAABgRIIBUpBRkIGQA2BkAZD9W2AIVGP/////QoEWkXwBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJAEgRaCA5CBFhWAFZBhI8dXUG3//////////////////4QWFRVbgBVhI+JXUG3//////////////////4MWFRVbFWEkkleAY/////8WYSQlhWEj+4ZhKldWW3v/////////////////////////////////////FpBj/////2EqexZWW2AJgFR7/////////////////////////////////////5KQkhaSkJICAZBVY/////+BFmEkZYRhI/uHYSpXVltgCoBUe/////////////////////////////////////+SkJIWkpCSAgGQVVtgCIBUf////////////////////////wAAAAAAAAAAAAAAAAAAFm3//////////////////4iBFpGQkRd//////wAAAAAAAAAAAAAAAAAA//////////////////8WbgEAAAAAAAAAAAAAAAAAAIiDFoECkZCRF3v/////////////////////////////////////FnwBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGP/////hxYCF5KDkFVgQIBRhIQWgVKRkJMEkJEWYCCCAVKBUX8cQR6aluBxJBwvIfdyaxeuiePKtMeL5Q4GKwOp//u60ZKRgZADkJEBkKFQUFBQUFBWW3P//////////////////////////4CEFmAAgYFSYAJgIJCBUmBAgIMglIcWgIRSlIJSkYKQIIWQVYFRhYFSkVF/jFvh5evsfVvRT3FCfR6E890DFMD3sikeWyAKyMfDuSWSgZADkJEBkKNQUFBWW3P//////////////////////////4MWYACQgVJgAWAgUmBAkCBUYSZBkIJj/////2EibhZWW3P//////////////////////////4CFFmAAkIFSYAFgIFJgQICCIJOQk1WQhBaBUiBUYSaDkIJj/////2EqvBZWW3P//////////////////////////4CEFmAAgYFSYAFgIJCBUmBAkYKQIJSQlFWAUYWBUpBRkZOShxaSf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkpGCkAMBkKNQUFBWW2AAgGAFYACQVJBhAQAKkARz//////////////////////////8Wc///////////////////////////FmMBfn5YYEBRgWP/////FmDgG4FSYAQBYCBgQFGAgwOBhoA7FYAVYSdXV2AAgP1bUFr6FYAVYSdrVz1gAIA+PWAA/VtQUFBQYEBRPWAggRAVYSeBV2AAgP1bUFFgC1Rz//////////////////////////+CFhWAFZRQkZJQkGEoZFeAFWEoX1dgAGEn2GESV23//////////////////4iBFpCIFmP/////YSHoFlZbkFBgAGEn5YNhKHhWW5BQgIIRFWEoXFdgAGEoE2EoBISEY/////9hIm4WVltgAFSQY/////9hIegWVluQUGAAYSg4g2EoLIZgBWP/////YSHoFlZbkGP/////YSq8FlZbkFBgAIGDgWEoRVf+WwSQUIAVYShYV2EoWIeCYSjKVltQUFBbUFBbYShwVluAFWEocFdgAGALVVtQUJKRUFBWW2AAYAOCERVhKLtXUIBgAWACggQBW4GBEBVhKLVXgJFQYAKBgoWBYSikV/5bBAGBYSitV/5bBJBQYSiNVltQYSjFVluBFWEoxVdQYAFbkZBQVltgAFRhKN2QgmP/////YSq8FlZbYACQgVVz//////////////////////////+DFoFSYAFgIFJgQJAgVGEpFZCCY/////9hKrwWVltz//////////////////////////+DFmAAgYFSYAFgIJCBUmBAgIMglJCUVYNRhYFSk1GSk5GSf93yUq0b4sibacKwaPw3jaqVK6fxY8ShFij1Wk31I7PvkoGQA5CRAZCjUFBWW2AAgYMQYSmJV4FhKYtWW4Jbk5JQUFBWW3P//////////////////////////4IWYACQgVJgAWAgUmBAkCBUYSnIkIJj/////2EibhZWW3P//////////////////////////4MWYACQgVJgAWAgUmBAgSCRkJFVVGEqApCCY/////9hIm4WVltgAJCBVWBAgFGDgVKQUXP//////////////////////////4UWkX/d8lKtG+LIm2nCsGj8N42qlSun8WPEoRYo9VpN9SOz75GQgZADYCABkKNQUFZbbf//////////////////Fm4BAAAAAAAAAAAAAAAAAAACkFZbYABt//////////////////+CFnv/////////////////////////////////////hBaBYSq0V/5bBJOSUFBQVluAggGCgRAVYQ32V2BAgFF/CMN5oAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACBUmAgYASCAVJgFGAkggFSf2RzLW1hdGgtYWRkLW92ZXJmbG93AAAAAAAAAAAAAAAAYESCAVKQUZCBkANgZAGQ/f5Vbmlzd2FwVjI6IElOU1VGRklDSUVOVF9PVVRQVVRfQU1PVU5UVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfSU5QVVRfQU1PVU5UVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZVW5pc3dhcFYyOiBJTlNVRkZJQ0lFTlRfTElRVUlESVRZX0JVUk5FRFVuaXN3YXBWMjogSU5TVUZGSUNJRU5UX0xJUVVJRElUWV9NSU5URUSiZWJ6enIxWCB9yhhHnlhIdga/cMeeRNje5iNTye5tAfmp1wiFuHZfImRzb2xjQwAFEAAyRUlQNzEyRG9tYWluKHN0cmluZyBuYW1lLHN0cmluZyB2ZXJzaW9uLHVpbnQyNTYgY2hhaW5JZCxhZGRyZXNzIHZlcmlmeWluZ0NvbnRyYWN0KaJlYnp6cjFYICdg+S1/odtvWqFjB7rWXfTrzIVQxLHwN1Wrjf2DDBePZHNvbGNDAAUQADI="
            },
            {
                "key": "BwQGMDQRyR2dZnGgQBhiHHl80jDekQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "V0VUSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwQGMDQRyR2dZnGgQBhiHHl80jDekQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABI="
            },
            {
                "key": "BwQGMDQRyR2dZnGgQBhiHHl80jDekQEAAACqMwetmqdZTVB72iiNDmuwEPFHh4Apf7JAJbFybFZN1w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYyWUkp5W6t+wM="
            },
            {
                "key": "BwQKE7wfPEQbyxZeiSX+PifRjRzWbAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB/M="
            },
            {
                "key": "BwQKE7wfPEQbyxZeiSX+PifRjRzWbAEAAADeX+mutyRVpdIIJxUQgSJtCJFxa8mKKxRW8ISOSzO6rg==",
                "proof": [],
                "value": "AAAAAGIXphAAAAAAAAAAAAAAAAAAAAAAAAAAAC+2mIk="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAPChl8kUslEWvRvHC7Vz7EWJbeRY="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA257JhOzx3QyEnUaxQz9Web8d4Ck="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA3gtrOnZAAA="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABg==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADvzuRyVsAAA="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAAAWXipMmX15IgFp6uSW64vic/LqUXtRKngye/k1DZWoTw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAAAWXipMmX15IgFp6uSW64vic/LqUXtRKngye/k1DZWoUA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACbbmSo7GAAA="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAAAo6Wl37ul/d6xgCpq1Gg6LaPgroEBlCkkErXWsymnzcA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQG9DpUtB6N8="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAAArfyyxlpfBfU/0WiciYu5SNakZNQx5n3J5ECcRcnfshA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAAA5rsZxAnS6n/K86vKP8hCYTIEHKkW5l9MkIoybt1ugIQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACbbmSo7GAAA="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAAA9s35GuC8IESWGS7XiHw0qFojuHA/lJ53eQ2e0qsM90w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAADAl857yQcVs0ufEAAAAAA="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAABQCE+zZLQZ1jbO3IDkSf60pcRhbj6LBc4aoB3H0p5G0A==",
                "proof": [],
                "value": "YheoDAAAAAAAAAAAAAAAAADAl857yQcVs0ufEAAAAAA="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAACrLiaxscoe0tcW3c7qVd/74hN2oCZcZB1mT7geCzs9Qw==",
                "proof": [],
                "value": "YheoMQAAAAAAAAAAFr8my7mjBun+QW90ea5yeUaCzOw="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAADRwJ5sKh3gBG+JJ6gOtwzFCe/LDUpN3CwzYWD8rG9anw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAFrybQv8oV+bjhiY426JY8GOYYR4="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAADSEwLS9zKm9MKXIxI/0s7Ae5XpkJ6FQefRf3YG0WviRw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACbbmSo7GAAA="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAADTh8KfwG2oiTDK1kbbbh4CK3xQTRhM0TMW7ZY8nYL9GA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAADTh8KfwG2oiTDK1kbbbh4CK3xQTRhM0TMW7ZY8nYL9GQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADH1xO0naAAA="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAADUzuV39/QAY7xlqD1gdYJe/OuA2bys1hErKPzrp6/w8A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAPojXsG8FJqEw/WzO7Zm24KB6OqM="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAADUzuV39/QAY7xlqD1gdYJe/OuA2bys1hErKPzrp6/w8Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAE4pxLsycbFxxtbad1eTtzPYc2DM="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAADUzuV39/QAY7xlqD1gdYJe/OuA2bys1hErKPzrp6/w8g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAqy5ujuw8fxK/jqhSkltGuTGrxio="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAADUzuV39/QAY7xlqD1gdYJe/OuA2bys1hErKPzrp6/w8w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAmmsBOW975wAYgmN+MAJ+KUJknwY="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAADWWGst2X937Suv8uT0fXeyFxkjZamJoIU28lPvnVaRuQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAiscjBInoAAA="
            },
            {
                "key": "BwQO5+A0vP8Fl7pteYmz7k0w+fMCOgEAAADt/t5ex7p97IxcGYLaaeNpyAkFq5Tk76xDzTx/EblLQw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAADAl857yQcVs0ufEAAAAAA="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC",
                "proof": [],
                "value": "Y1VTREMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAADufgNLz/BZe6bXmJs+5NMPnzAjo="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAFMfvF/GvBvsFZKPgHsautafa4Nc="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsaK8LsUAAA="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIXqDE="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADeG2Jvr0TS0="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABNx/tTrIA="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI026qw="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQXb1erjcOM="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAI8BruDCav5S2Z/CfWgz3Yvu/v38="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAZHosxzY+YITyyIdRkzEH0lDI9B4="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYMyGdUgO3AY+1kb9AgMPIihuCZbQ3lIwY9cALHdS+HyBX",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASn98FE="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYM+sPCLBmLR6qR3qYNWzz1VOSZsuu+6rx/PXfBrIDqHzv",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPB1dCU="
            },
            {
                "key": "BwQTinEuzJxsXHG1tp3V5O3M9hzYM+sPCLBmLR6qR3qYNWzz1VOSZsuu+6rx/PXfBrIDqHzw",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADeG1vxStnso="
            },
            {
                "key": "BwQUGeC9xOHyxa3hXlO+2OLyebb1AgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "V0JUQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwQUGeC9xOHyxa3hXlO+2OLyebb1AgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwQUGeC9xOHyxa3hXlO+2OLyebb1AgEAAAAgU4SrhkJOcEjC9shz8+3flBQS0nSOjtat24ZCLMsS3A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAARazYcX8="
            },
            {
                "key": "BwQUx+8X8a8G+wVko+Aexq61p9rg1wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF6Apr8="
            },
            {
                "key": "BwQUx+8X8a8G+wVko+Aexq61p9rg1wEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACxorwuxQAAA="
            },
            {
                "key": "BwQjwGu4MJq/lLZn8J9aDPdi+7+/fwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "VVNEQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwQjwGu4MJq/lLZn8J9aDPdi+7+/fwEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAY="
            },
            {
                "key": "BwQjwGu4MJq/lLZn8J9aDPdi+7+/fwEAAAAnrnCs8KFqn0KGFh2/trEO56HJmhDgTY+KOFr2dXV20w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAPEvCRmXo="
            },
            {
                "key": "BwQjwGu4MJq/lLZn8J9aDPdi+7+/fwEAAAAtAjOTataguoJ5e0fccRrEGszS8aEt0eE7Sve6r7if4A==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4TqYIwgE="
            },
            {
                "key": "BwQjwGu4MJq/lLZn8J9aDPdi+7+/fwEAAAD/GOgUvR+YrV7xcKxjddZVvxmUsSfUN3AERiqMzjuR6Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB6m/t0="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC",
                "proof": [],
                "value": "Y05FQVIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAF",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAADufgNLz/BZe6bXmJs+5NMPnzAjo="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAATdxCc8sAqB/m54wZvn35IFx5Zao="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAsaK8LsUAAA="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGIXqDY="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADePDZhQKSX8="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAABDzjaPiZvGYEJaw="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQthvqKD64iUw="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4KvL5j5tw="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAsZjA2JdVRzRUdd6SItFpTnrjDjY="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6owAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAZHosxzY+YITyyIdRkzEH0lDI9B4="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6oyGdUgO3AY+1kb9AgMPIihuCZbQ3lIwY9cALHdS+HyBX",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS+5qH6M="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6o+sPCLBmLR6qR3qYNWzz1VOSZsuu+6rx/PXfBrIDqHzv",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMLieX4oWoCA="
            },
            {
                "key": "BwQ+iNewbwUmoTD9bM7tmbbgoHo6o+sPCLBmLR6qR3qYNWzz1VOSZsuu+6rx/PXfBrIDqHzw",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADeOthNiU1EE="
            },
            {
                "key": "BwRN3EJzywCoH+bnjBm+ffkgXHllqgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL0BTX4="
            },
            {
                "key": "BwRN3EJzywCoH+bnjBm+ffkgXHllqgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACXND38="
            },
            {
                "key": "BwSAUhVGawEusaVyGiK+KtXyUL7/igEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+U="
            },
            {
                "key": "BwSAUhVGawEusaVyGiK+KtXyUL7/igEAAAC6LOnWchvGVow2qgPJFWsIXwQBZ4Ln2XE0M4jVeFNuCQ==",
                "proof": [],
                "value": "AAAAAGIXplEAAAAAAAAAAAAAAAAAAAAAAAADQQIiFRg="
            },
            {
                "key": "BwSEKvgHT6QVg+NyCCHPFDUEnPk1ZQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+8="
            },
            {
                "key": "BwSEKvgHT6QVg+NyCCHPFDUEnPk1ZQEAAADekj0pH4DYl4jONNLzHnE7/Rb236ZVgCAvsCLIhrn9xg==",
                "proof": [],
                "value": "AAAAAGIXpxEAAAAAAAAAAAAAAAAAAAAAAAAAOLbgsII="
            },
            {
                "key": "BwSaawE5b3vnABiCY34wAn4pQmSfBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC",
                "proof": [],
                "value": "Y0JUQwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwSaawE5b3vnABiCY34wAn4pQmSfBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHb4iYlE="
            },
            {
                "key": "BwSaawE5b3vnABiCY34wAn4pQmSfBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACddbY="
            },
            {
                "key": "BwSaawE5b3vnABiCY34wAn4pQmSfBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8QU3tcI="
            },
            {
                "key": "BwSaawE5b3vnABiCY34wAn4pQmSfBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAFBngvcTh8sWt4V5Tvtji8nm29QI="
            },
            {
                "key": "BwSaawE5b3vnABiCY34wAn4pQmSfBgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAZHosxzY+YITyyIdRkzEH0lDI9B4="
            },
            {
                "key": "BwSaawE5b3vnABiCY34wAn4pQmSfBiGdUgO3AY+1kb9AgMPIihuCZbQ3lIwY9cALHdS+HyBX",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABMSQs="
            },
            {
                "key": "BwSm6DUHzzeVUxlrfwP8JsVi6Gl7lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAG",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAI8BruDCav5S2Z/CfWgz3Yvu/v38="
            },
            {
                "key": "BwSm6DUHzzeVUxlrfwP8JsVi6Gl7lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAH",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAsZjA2JdVRzRUdd6SItFpTnrjDjY="
            },
            {
                "key": "BwSm6DUHzzeVUxlrfwP8JsVi6Gl7lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI",
                "proof": [],
                "value": "YhecngAAAAF6x/oTvlwpsmsYAAAAAAAAAAAPEvCRmXo="
            },
            {
                "key": "BwSm6DUHzzeVUxlrfwP8JsVi6Gl7lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAgEqaMgntJC0J4fVeZ2t7ioZRkW5g="
            },
            {
                "key": "BwSm6DUHzzeVUxlrfwP8JsVi6Gl7lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAK",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAANAtXPl4IPUNh9fis="
            },
            {
                "key": "BwSm6DUHzzeVUxlrfwP8JsVi6Gl7lwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE="
            },
            {
                "key": "BwSrLm6O7Dx/Er+OqFKSW0a5MavGKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC",
                "proof": [],
                "value": "Y1dFVEgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAo="
            },
            {
                "key": "BwSrLm6O7Dx/Er+OqFKSW0a5MavGKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAL",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKG63fuPZbD9F8="
            },
            {
                "key": "BwSrLm6O7Dx/Er+OqFKSW0a5MavGKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAM",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB1cfNvTLdT8="
            },
            {
                "key": "BwSrLm6O7Dx/Er+OqFKSW0a5MavGKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASu3waV+4="
            },
            {
                "key": "BwSrLm6O7Dx/Er+OqFKSW0a5MavGKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAR",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAABjA0EckdnWZxoEAYYhx5fNIw3pE="
            },
            {
                "key": "BwSrLm6O7Dx/Er+OqFKSW0a5MavGKgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAS",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAZHosxzY+YITyyIdRkzEH0lDI9B4="
            },
            {
                "key": "BwSrLm6O7Dx/Er+OqFKSW0a5MavGKiGdUgO3AY+1kb9AgMPIihuCZbQ3lIwY9cALHdS+HyBX",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKHJok="
            },
            {
                "key": "BwSxmMDYl1VHNFR13pIi0WlOeuMONgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABA==",
                "proof": [],
                "value": "TkVBUgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAg="
            },
            {
                "key": "BwSxmMDYl1VHNFR13pIi0WlOeuMONgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABI="
            },
            {
                "key": "BwSxmMDYl1VHNFR13pIi0WlOeuMONgEAAAAnrnCs8KFqn0KGFh2/trEO56HJmhDgTY+KOFr2dXV20w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAXrH+hO+XCmyaxg="
            },
            {
                "key": "BwSxmMDYl1VHNFR13pIi0WlOeuMONgEAAACGHIQMXe1Di76I52ZCqQU6LswC8b9LsMs0t7tg/4ejiw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAk2mfJVCn0aPW7Q="
            },
            {
                "key": "BwSxmMDYl1VHNFR13pIi0WlOeuMONgEAAAD/GOgUvR+YrV7xcKxjddZVvxmUsSfUN3AERiqMzjuR6Q==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADv+kmAfII4EQ="
            },
            {
                "key": "BwTbnsmE7PHdDISdRrFDP1Z5vx3gKQEAAACKMK6GbnOtSzjpEW9BmkhwQ3MezmqICZ+TdJj034uh1g==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAgFIVRmsBLrGlchoivirV8lC+/4o="
            },
            {
                "key": "BwTbnsmE7PHdDISdRrFDP1Z5vx3gKQEAAACNPI5wNiQtZ9Ych454kC0znCckZcKwNwu0igVqcOJWVQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAA8JNcqvX+f31aKV6jwBXnnh+Sm04="
            },
            {
                "key": "BwTbnsmE7PHdDISdRrFDP1Z5vx3gKQEAAACmi+DP8774+Anb767W2NhyD7J3Ze76N/+UeKL8uEFeoA==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAChO8HzxEG8sWXokl/j4n0Y0c1mw="
            },
            {
                "key": "BwTbnsmE7PHdDISdRrFDP1Z5vx3gKQEAAADZdipHeQkoK+XcEOWfCZRCJCzJ5cb6KZPIz+T3BWwBFw==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAhCr4B0+kFYPjcgghzxQ1BJz5NWU="
            },
            {
                "key": "BwTwk1yq9f5/fVopXqPAFeeeH5KbTgEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB+k="
            },
            {
                "key": "BwTwk1yq9f5/fVopXqPAFeeeH5KbTgEAAABd5P/nnINcDJBKtZSKmBIQjeouNQ3RDsnGTHcFUWqs8Q==",
                "proof": [],
                "value": "AAAAAGIXpmQAAAAAAAAAAAAAAAAAAAAAAAAAAAX1S9c="
            },
            {
                "key": "BwT5TvpQXEUeeuAkVT0xjTHh81wy9AEAAAAGGVrFpciyJCQvz3I4Z8L8lao1I1QO5yK5+dbq7ZNg3w==",
                "proof": [],
                "value": "AAAAAAAAAAAAAAAApug1B883lVMZa38D/CbFYuhpe5c="
            },
            {
                "key": "BwcGMDQRyR2dZnGgQBhiHHl80jDekQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcKE7wfPEQbyxZeiSX+PifRjRzWbA==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcO5+A0vP8Fl7pteYmz7k0w+fMCOg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcUGeC9xOHyxa3hXlO+2OLyebb1Ag==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcUx+8X8a8G+wVko+Aexq61p9rg1w==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwcjwGu4MJq/lLZn8J9aDPdi+7+/fw==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwdNiozBKxx/2JNdhcDzZGIVQeaxEA==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwdN3EJzywCoH+bnjBm+ffkgXHllqg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BweAUhVGawEusaVyGiK+KtXyUL7/ig==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BweEKvgHT6QVg+NyCCHPFDUEnPk1ZQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwexmMDYl1VHNFR13pIi0WlOeuMONg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "BwfbnsmE7PHdDISdRrFDP1Z5vx3gKQ==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwfwk1yq9f5/fVopXqPAFeeeH5KbTg==",
                "proof": [],
                "value": "AAAAAQ=="
            },
            {
                "key": "Bwf5TvpQXEUeeuAkVT0xjTHh81wy9A==",
                "proof": [],
                "value": "AAAAAQ=="
            }
        ]
    }
}
'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/sanity.rs ---
use crate::prelude::{Address, U256};
use crate::prelude::{Wei, ERC20_MINT_SELECTOR};
use crate::test_utils;
use crate::tests::state_migration;
use aurora_engine::fungible_token::FungibleTokenMetadata;
use aurora_engine::parameters::{SubmitResult, TransactionStatus};
use aurora_engine_sdk as sdk;
use borsh::BorshSerialize;
use libsecp256k1::SecretKey;
use rand::RngCore;
use std::path::{Path, PathBuf};

const INITIAL_BALANCE: Wei = Wei::new_u64(1_000_000);
const INITIAL_NONCE: u64 = 0;
const TRANSFER_AMOUNT: Wei = Wei::new_u64(123);
const GAS_PRICE: u64 = 10;

#[test]
fn test_total_supply_accounting() {
    let (mut runner, mut signer, benefactor) = initialize_transfer();

    let constructor = test_utils::solidity::ContractConstructor::compile_from_source(
        "src/tests/res",
        "target/solidity_build",
        "self_destructor.sol",
        "SelfDestruct",
    );

    let deploy_contract = |runner: &mut test_utils::AuroraRunner,
                           signer: &mut test_utils::Signer|
     -> test_utils::solidity::DeployedContract {
        let submit_result = runner
            .submit_with_signer(signer, |nonce| {
                let mut deploy_tx = constructor.deploy_without_constructor(nonce);
                deploy_tx.value = TRANSFER_AMOUNT;
                deploy_tx
            })
            .unwrap();

        let contract_address =
            Address::try_from_slice(test_utils::unwrap_success_slice(&submit_result)).unwrap();
        constructor.deployed_at(contract_address)
    };

    let get_total_supply = |runner: &mut test_utils::AuroraRunner| -> Wei {
        let (outcome, _) = runner.call("ft_total_eth_supply_on_aurora", "aurora", Vec::new());
        let amount: u128 = String::from_utf8(outcome.unwrap().return_data.as_value().unwrap())
            .unwrap()
            .replace('"', "")
            .parse()
            .unwrap();
        Wei::new(U256::from(amount))
    };

    // Self-destruct with some benefactor does not reduce the total supply
    let contract = deploy_contract(&mut runner, &mut signer);
    let _submit_result = runner
        .submit_with_signer(&mut signer, |nonce| {
            contract.call_method_with_args(
                "destruct",
                &[ethabi::Token::Address(benefactor.raw())],
                nonce,
            )
        })
        .unwrap();
    assert_eq!(runner.get_balance(benefactor), TRANSFER_AMOUNT);
    assert_eq!(get_total_supply(&mut runner), INITIAL_BALANCE);

    // Self-destruct with self benefactor burns any ETH in the destroyed contract
    let contract = deploy_contract(&mut runner, &mut signer);
    let _submit_result = runner
        .submit_with_signer(&mut signer, |nonce| {
            contract.call_method_with_args(
                "destruct",
                &[ethabi::Token::Address(contract.address.raw())],
                nonce,
            )
        })
        .unwrap();
    assert_eq!(
        get_total_supply(&mut runner),
        INITIAL_BALANCE - TRANSFER_AMOUNT
    );
}

#[test]
fn test_transaction_to_zero_address() {
    // Transactions that explicit list `0x0000...` as the `to` field in the transaction
    // should not be interpreted as contract creation. Previously this was the case
    // and it caused the Engine to incorrectly derive the sender's address.
    // See the mismatch between the sender address reported by the Aurora explorer
    // and the sender logged by the engine:
    //   - https://testnet.aurorascan.dev/tx/0x51846313113e13ff87ccbd153f1b339b857bf7729fe16af7d351ff06943c4c20
    //   - https://explorer.testnet.near.org/transactions/5URFuet378c6zokikG62uK4YH31AnZb99pDPRnVJBAy2
    // This is a test to show the bug is now fixed.
    let tx_hex = "f8648080836691b79400000000000000000000000000000000000000008080849c8a82caa0464cada9d6a907f5537dcc0f95274a30ddaeff33276e9b3993815586293a2010a07626bd794381ba59f30e26ec6f3448d19f63bb12dcda19acda429b2fb7d3dfba";
    let tx_bytes = hex::decode(tx_hex).unwrap();
    let tx = aurora_engine_transactions::EthTransactionKind::try_from(tx_bytes.as_slice()).unwrap();
    let normalized_tx = aurora_engine_transactions::NormalizedEthTransaction::try_from(tx).unwrap();
    let address = normalized_tx.address;
    let sender = hex::encode(address.as_bytes());
    assert_eq!(sender.as_str(), "63eafba871e0bda44be3cde19df5aa1c0f078142");

    // We want the standalone engine to still reproduce the old behaviour for blocks before the bug fix, and
    // to use the correct parsing for blocks after the fix.
    let mut runner = test_utils::standalone::StandaloneRunner::default();
    runner.init_evm_with_chain_id(normalized_tx.chain_id.unwrap());
    let mut context = test_utils::AuroraRunner::default().context;
    context.input = tx_bytes;
    // Prior to the fix the zero address is interpreted as None, causing a contract deployment.
    // It also incorrectly derives the sender address, so does not increment the right nonce.
    context.block_index = aurora_engine::engine::ZERO_ADDRESS_FIX_HEIGHT - 1;
    let result = runner
        .submit_raw(test_utils::SUBMIT, &context, &[])
        .unwrap();
    assert_eq!(result.gas_used, 53_000);
    runner.env.block_height = aurora_engine::engine::ZERO_ADDRESS_FIX_HEIGHT;
    assert_eq!(runner.get_nonce(&address), U256::zero());

    // After the fix this transaction is simply a transfer of 0 ETH to the zero address
    context.block_index = aurora_engine::engine::ZERO_ADDRESS_FIX_HEIGHT;
    let result = runner
        .submit_raw(test_utils::SUBMIT, &context, &[])
        .unwrap();
    assert_eq!(result.gas_used, 21_000);
    runner.env.block_height = aurora_engine::engine::ZERO_ADDRESS_FIX_HEIGHT + 1;
    assert_eq!(runner.get_nonce(&address), U256::one());
}

#[test]
fn test_state_format() {
    // The purpose of this test is to make sure that if we accidentally
    // change the binary format of the `EngineState` then we will know
    // about it. This is important because changing the state format will
    // break the contract unless we do a state migration.
    let args = aurora_engine::parameters::NewCallArgs {
        chain_id: aurora_engine_types::types::u256_to_arr(&666.into()),
        owner_id: "boss".parse().unwrap(),
        bridge_prover_id: "prover_mcprovy_face".parse().unwrap(),
        upgrade_delay_blocks: 3,
    };
    let state: aurora_engine::engine::EngineState = args.into();
    let expected_hex: String = [
        "000000000000000000000000000000000000000000000000000000000000029a",
        "04000000626f7373",
        "1300000070726f7665725f6d6370726f76795f66616365",
        "0300000000000000",
    ]
    .concat();
    assert_eq!(hex::encode(state.try_to_vec().unwrap()), expected_hex);
}

#[test]
fn test_deploy_contract() {
    let (mut runner, mut signer, _) = initialize_transfer();

    // Randomly generate some "contract code"
    const LEN: usize = 567;
    let code: Vec<u8> = {
        let mut rng = rand::thread_rng();
        let mut buf = vec![0u8; LEN];
        rng.fill_bytes(&mut buf);
        buf
    };

    // Deploy that code
    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            test_utils::create_deploy_transaction(code.clone(), nonce)
        })
        .unwrap();
    let address = Address::try_from_slice(test_utils::unwrap_success_slice(&result)).unwrap();

    // Confirm the code stored at that address is equal to the input code.
    let stored_code = runner.get_code(address);
    assert_eq!(code, stored_code);
}

#[test]
fn test_deploy_largest_contract() {
    // Check to see we can deploy the largest allowed contract size within the
    // NEAR gas limit of 200 Tgas.
    let (mut runner, mut signer, _) = initialize_transfer();

    let len = evm::Config::berlin().create_contract_limit.unwrap();
    let code: Vec<u8> = {
        let mut rng = rand::thread_rng();
        let mut buf = vec![0u8; len];
        rng.fill_bytes(&mut buf);
        buf
    };

    // Deploy that code
    let (result, profile) = runner
        .submit_with_signer_profiled(&mut signer, |nonce| {
            test_utils::create_deploy_transaction(code.clone(), nonce)
        })
        .unwrap();

    // At least 5 million EVM gas
    assert!(
        result.gas_used >= 5_000_000,
        "{:?} not greater than 5 million",
        result.gas_used,
    );

    // Less than 12 NEAR Tgas
    test_utils::assert_gas_bound(profile.all_gas(), 10);
}

#[test]
fn test_log_address() {
    let (mut runner, mut signer, _) = initialize_transfer();

    let mut deploy_contract = |name: &str, signer: &mut test_utils::Signer| {
        let constructor = test_utils::solidity::ContractConstructor::compile_from_source(
            "src/tests/res",
            "target/solidity_build",
            "caller.sol",
            name,
        );

        let nonce = signer.use_nonce();
        runner.deploy_contract(
            &signer.secret_key,
            |c| c.deploy_without_constructor(nonce.into()),
            constructor,
        )
    };

    let greet_contract = deploy_contract("Greeter", &mut signer);
    let caller_contract = deploy_contract("Caller", &mut signer);

    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            caller_contract.call_method_with_args(
                "greet",
                &[ethabi::Token::Address(greet_contract.address.raw())],
                nonce,
            )
        })
        .unwrap();

    // Address included in the log should come from the contract emitting the log,
    // not the contract that invoked the call.
    let log_address = result.logs.first().unwrap().address;
    assert_eq!(log_address, greet_contract.address);
}

#[test]
fn test_is_contract() {
    let (mut runner, mut signer, _) = initialize_transfer();
    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);

    let constructor = test_utils::solidity::ContractConstructor::force_compile(
        "src/tests/res",
        "target/solidity_build",
        "is_contract.sol",
        "IsContract",
    );

    let nonce = signer.use_nonce();
    let contract = runner.deploy_contract(
        &signer.secret_key,
        |c| c.deploy_without_constructor(nonce.into()),
        constructor,
    );

    let call_contract = |account: Address,
                         runner: &mut test_utils::AuroraRunner,
                         signer: &mut test_utils::Signer|
     -> bool {
        let result = runner
            .submit_with_signer(signer, |nonce| {
                contract.call_method_with_args(
                    "isContract",
                    &[ethabi::Token::Address(account.raw())],
                    nonce,
                )
            })
            .unwrap();
        let bytes = test_utils::unwrap_success_slice(&result);
        ethabi::decode(&[ethabi::ParamType::Bool], bytes)
            .unwrap()
            .pop()
            .unwrap()
            .into_bool()
            .unwrap()
    };

    // Should return false for accounts that don't exist
    assert!(!call_contract(
        Address::from_array([1; 20]),
        &mut runner,
        &mut signer
    ));

    // Should return false for accounts that don't have contract code
    assert!(!call_contract(signer_address, &mut runner, &mut signer),);

    // Should return true for contracts
    let erc20_constructor = test_utils::erc20::ERC20Constructor::load();
    let nonce = signer.use_nonce();
    let token_a = runner.deploy_contract(
        &signer.secret_key,
        |c| c.deploy("TOKEN_A", "TA", nonce.into()),
        erc20_constructor,
    );
    assert!(call_contract(token_a.address, &mut runner, &mut signer),);
}

#[test]
fn test_solidity_pure_bench() {
    let (mut runner, mut signer, _) = initialize_transfer();
    runner.wasm_config.limit_config.max_gas_burnt = u64::MAX;

    let constructor = test_utils::solidity::ContractConstructor::force_compile(
        "src/tests/res",
        "target/solidity_build",
        "bench.sol",
        "Bencher",
    );

    let nonce = signer.use_nonce();
    let contract = runner.deploy_contract(
        &signer.secret_key,
        |c| c.deploy_without_constructor(nonce.into()),
        constructor,
    );

    // Number of iterations to do
    let loop_limit: u32 = 10_000;
    let (result, profile) = runner
        .submit_with_signer_profiled(&mut signer, |nonce| {
            contract.call_method_with_args(
                "cpu_ram_soak_test",
                &[ethabi::Token::Uint(loop_limit.into())],
                nonce,
            )
        })
        .unwrap();

    assert!(
        result.gas_used > 38_000_000,
        "Over 38 million EVM gas is used"
    );
    let near_gas = profile.all_gas();
    assert!(
        near_gas > 1500 * 1_000_000_000_000,
        "Expected 1500 NEAR Tgas to be used, but only consumed {}",
        near_gas / 1_000_000_000_000,
    );

    // Pure rust version of the same contract
    let base_path = std::path::Path::new("../etc")
        .join("tests")
        .join("benchmark-contract");
    let output_path =
        base_path.join("target/wasm32-unknown-unknown/release/benchmark_contract.wasm");
    test_utils::rust::compile(base_path);
    let contract_bytes = std::fs::read(output_path).unwrap();
    let code = near_primitives_core::contract::ContractCode::new(contract_bytes, None);
    let mut context = runner.context.clone();
    context.input = loop_limit.to_le_bytes().to_vec();
    let (outcome, error) = match near_vm_runner::run(
        &code,
        "cpu_ram_soak_test",
        &mut runner.ext,
        context,
        &runner.wasm_config,
        &runner.fees_config,
        &[],
        runner.current_protocol_version,
        Some(&runner.cache),
    ) {
        near_vm_runner::VMResult::Aborted(outcome, error) => (Some(outcome), Some(error)),
        near_vm_runner::VMResult::Ok(outcome) => (Some(outcome), None),
    };
    if let Some(e) = error {
        panic!("{:?}", e);
    }
    let outcome = outcome.unwrap();
    let profile = test_utils::ExecutionProfile::new(&outcome);
    // Check the contract actually did the work.
    assert_eq!(&outcome.logs, &[format!("Done {} iterations!", loop_limit)]);
    assert!(profile.all_gas() < 1_000_000_000_000); // Less than 1 Tgas used!
}

#[test]
fn test_revert_during_contract_deploy() {
    let (mut runner, mut signer, _) = initialize_transfer();

    let constructor = test_utils::solidity::ContractConstructor::compile_from_source(
        "src/tests/res",
        "target/solidity_build",
        "reverter.sol",
        "ReverterByDefault",
    );

    let nonce = signer.use_nonce();
    let deploy_tx =
        constructor.deploy_with_args(nonce.into(), &[ethabi::Token::Uint(U256::zero())]);
    let submit_result = runner
        .submit_transaction(&signer.secret_key, deploy_tx)
        .unwrap();

    let revert_bytes = crate::test_utils::unwrap_revert(submit_result);
    // First 4 bytes is a function selector with signature `Error(string)`
    assert_eq!(&revert_bytes[0..4], &[8, 195, 121, 160]);
    // Remaining data is an ABI-encoded string
    let revert_message = ethabi::decode(&[ethabi::ParamType::String], &revert_bytes[4..])
        .unwrap()
        .pop()
        .unwrap()
        .into_string()
        .unwrap();

    assert_eq!(revert_message.as_str(), "Revert message");
}

#[test]
fn test_call_too_deep_error() {
    let (mut runner, mut signer, _) = initialize_transfer();

    let constructor = test_utils::solidity::ContractConstructor::compile_from_source(
        "src/tests/res",
        "target/solidity_build",
        "CallTooDeep.sol",
        "CallTooDeep",
    );

    let nonce = signer.use_nonce();
    let contract = runner.deploy_contract(
        &signer.secret_key,
        |c| c.deploy_without_constructor(nonce.into()),
        constructor,
    );

    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            contract.call_method_without_args("test", nonce)
        })
        .unwrap();

    // It is counter-intuitive that this returns a `Revert` instead of `CallTooDeep`.
    // The reason this is the case is because it is only the last call that triggers the
    // `CallTooDeep` exit status, while the one before only sees that the call it made failed
    // and therefore reverts. As a result, the `CallTooDeep` exit status is not actually
    // visible to users.
    match result.status {
        TransactionStatus::Revert(_) => (),
        other => panic!("Unexpected status {:?}", other),
    }
}

#[test]
fn test_create_out_of_gas() {
    let (mut runner, mut signer, _) = initialize_transfer();
    let constructor_code = {
        // This EVM bytecode caused an integer overflow in the SputnikVM gas calculation prior to
        // https://github.com/aurora-is-near/sputnikvm/pull/17
        let code = "60e041184138410745413205374848484848484848484848484848484848484848484541384107456969697835ffff004545453a4747f06262483b646464645454543030303030303030303030303030303030303030303136383432353936337a5a5a8154543838929260545454545454545454315555555555555555555a5a5a5a5a5a5a5a3d5a615a5a5a5a5a455858580153455858585801825858828282545360305858586158f05858f05830303030303030303136383431353936337a5a5a8154543838929260545454545454545454315555555d55555555555a5a5a5a5a5a5a5a5a5a5a5a5a5a5a4558585801534558585858018258588282825453601558583158183d60253d60013a58f08258853480f07e82823aabac9fcdcea7a758583d6015315858585858f058585860253d60013a3d381a3d3361333030305858586158f05858f0583af00133303030828258588282825453601531585858583d60253d60013a58f08258853580f03a82827eab3d4343468546464646464646464646836500838311111111111111111111837676767676765a5a1515fb41151514742393f0555555555555555555555555555555555555555555555555555555555555555a5a5a5a5a5a455858580153455858585801827676765a5a1515fb41151514742393f055555555555555555555554558585801534558585858018258588282825453601531585858183d60253d60013a5858853580f03a82827eab3d9fcdcea7a75858fe3d60153f484848c40200000000000034483b325885858585858585853d60013a58f08261333030305858853580f03a82827eab30ac9fcdcea7a758583d6085853d60013a58f08261333060253d5e013a3d381a3d3361333030305858586158f05858f0583af001333030308282585882828254535a1531585858583d60253d60013a58f08258853580f03a82827eab3d9fcdcea7a758583d60153f484848483b323a4545314545353a4545450945317432454545304545304545303a4545314545353a45454509453174324545453045453a3a4545453a4545303a454530453a4545303a4545324545353a454545094531743a4546464646303a4545314545353a45454509453174324545453045453a3a4545453a4545303a454530453a4545303a4545314545353a4545450945317432454545304545304545303a4545314545353a45454509453174324545453045453a3a4545453a4545303a454530453a4545303a4545324545353a454545094531743a4546464619464646464646464646464646464646464646468258588282825453601531585858183d60253d60013a58f08258853580f03a828255555555555555555555555555555555555555555555555555556b6b6b6b3a5a3a4447474747f045456464ae646464646464646c6464325858435858013658584337585843015836585858384358585858f15858f158585885854085855858f15858f158580136585843375858430158f1585836585843385843385858013658584337585843015836585843585843385843385858013658584337585843015836585843385858585858f15858f158585858f15858f15858385858585858f15858f1585858f158585858f1585836585843385843385858365858015858433758f15858385858585858f15858f1585858f158585858f158583658584338584338585801365858489292605454545454545454543030303030303030303030303030303030303030303136383431353936337a5a5a8154543838929260545454545454545454315555555555555555555a5a5a5a5a5a5a5a5a5a5a5a413205374848484848484848484848484848484848485a6128a756455f07ef93f31ef468d3bc0d17e020b320616161616161616161616161616161616161616161616161515151515151070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070707070751515151484848485151515151515151515151515151515151515151515151515151515151515151515151515151515151515151515151518d616161616141364107454132053748484848484848489060604145614138415a07614541325a5a4558585801534558585858018258588282825453601531585858183d60253d60013a58f08258853480f07e82823aabac9fcdcea7a758583d6015315858585858f058585860253d60013a3d381a3d3361333030305858586158f05858f05830303030303030303136383431353936337a5a5a815454383892926054545454827676765a5a1515fb41151514742393f05555555555555555555555555555555555555555453a4747f04545646464646464646464646c6464643a474745343a4747f045454545453a4747f06262483b646464646464646464646c64646464646464646445646464646464646464646c6464646464646464f0305830303030343a36321a34347a36311a34347d34343a30282828282828282828282828282828282828282828282828282828282828a2a230340b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b050b0b0b3030303030303030303030303030303031353038323036333333333333333333333333333333333345304545304545303a4545314545353a45454509453174324545453045453a3a454506060606060606060606060606065050505050505050505050505050505050505050503361333030305858586158f05858f0581af00133303030828258588282825453601531585858583d60253d60013a58f28258853580f03a82827eab3d9fcdcea7a7464646464646464646464646462946464646464646464646464631707432454545304545353a4545453a4545303a4545304545353a453b32588585858585853a000000000000000000583f48383838486158f05858f0583af00133303030828258588282825453601531585858583d60253d60013a58f08258853580f03a82827eab3d9fcdcea7a758583d60153f484848483b32583f48d93838483b32586e858585858585585858f058585860253d5e013a3d381a3d33613330303058584358585858f15858f158585885854085855858f15858f158580136585843375858430158f1585836585843385843385858013658584337585843015836585843585843385843385858013658584337585843015836585843385858585858f15858f158585858f15858f15858385858585858f15858f1585858f158585858f1585836585843385843385858365858015858433758586158f05858f0583af00133305858586025603d013a3d381a5d3d3361050000003b325885b0bd02f6a392af548bdf1cfaee5dfa0eefcc8eab82827eabac9fcdcea7a758583dfeffffffffffffff6015000000000000000000000000ffffff303d389a3d603dff7effffffffffffff0600f15858385858585858f15858f1585858f158585858f158583658584338584338585801365858489292605454545454545454543030303030303030303030303030303030303030303136383431353936337a5a5a8154543838929260545454545454545454315555555555555555555a5a5a5a5a5affffffffffffffffffffffffffffffffffffffffffffffffffff5a5a5a5a5a5a5a5a5a4558585801534558585858018258588282825453601531585858183d60253d60013a58f08258853480f07e82823aabac9fcdcea7a758583d6015315858580000f70000000037201616355858f058585860253d60013a3d381a3d336133303030585851586158f05858f05830303030303030303136383431353936337a5a5a8154543838929260545454545454545454315555555555555555555a5a5a325a5a5a5a5a5a5a5a5a5a5a5a4558585801534558585858018258588282825453601558583158183d60253d60013a58f08258853480f07e82823aabac000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000009fcdcea7a758583d6015315858585858f058585860253d60013a3d381a3d3361333030305858586158f05858f0583af0013330303082825858828282545360153155555555555555555555555a5a5a5a5a5a4558585843468546464646464646464646838383111111111111111111ffff11837676767676765a5a1515fb41151514742393f0555555555555555555555555555555555555555555555555555555555555555a5a5a5a5a5a455858580153455858585801827676765a5a1515fb41151516742393f055555555555555555555555562483b45454545ff3a4747f06262483b4545454545453a47474745343a4747f045454555555555555555555555555555553d3d838311111111111111111111837676767676765a5a1515fb41151514742393f055483f3f453f484848483b32583f48383838483b3258858561616161616161616161616161616161615555555555555555555555555555555555555555555555556155555555618255555a82";
        hex::decode(code).unwrap()
    };
    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            aurora_engine_transactions::legacy::TransactionLegacy {
                nonce,
                gas_price: U256::zero(),
                gas_limit: u64::MAX.into(),
                to: None,
                value: Wei::zero(),
                data: constructor_code,
            }
        })
        .unwrap();
    assert!(
        matches!(result.status, TransactionStatus::OutOfGas),
        "Unexpected status: {:?}",
        result.status
    );
}

#[test]
fn test_timestamp() {
    let (mut runner, mut signer, _) = initialize_transfer();

    let constructor = test_utils::solidity::ContractConstructor::compile_from_source(
        "src/tests/res",
        "target/solidity_build",
        "timestamp.sol",
        "Timestamp",
    );

    // deploy contract
    let nonce = signer.use_nonce();
    let contract = runner.deploy_contract(
        &signer.secret_key,
        |c| c.deploy_without_constructor(nonce.into()),
        constructor,
    );

    // set timestamp
    let t = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap();
    let t_ns = t.as_nanos();
    let t_s = U256::from(t.as_secs());
    runner.context.block_timestamp = t_ns as u64;

    // call contract
    let result = runner
        .submit_with_signer(&mut signer, |nonce| {
            contract.call_method_without_args("getCurrentBlockTimestamp", nonce)
        })
        .unwrap();
    let timestamp = U256::from_big_endian(&test_utils::unwrap_success(result));

    // Check time is correct.
    // The `+1`  is needed here because the runner increments the context
    // timestamp by 1 second automatically before each transaction.
    assert_eq!(t_s + 1, timestamp);
}

#[test]
fn test_override_state() {
    let (mut runner, mut account1, viewer_address) = initialize_transfer();
    let account1_address = test_utils::address_from_secret_key(&account1.secret_key);
    let mut account2 = test_utils::Signer::random();
    let account2_address = test_utils::address_from_secret_key(&account2.secret_key);
    runner.create_address(account2_address, INITIAL_BALANCE, INITIAL_NONCE.into());

    let contract = test_utils::solidity::ContractConstructor::compile_from_source(
        "src/tests/res",
        "target/solidity_build",
        "poster.sol",
        "Poster",
    );

    // deploy contract
    let result = runner
        .submit_with_signer(&mut account1, |nonce| {
            crate::prelude::transactions::legacy::TransactionLegacy {
                nonce,
                gas_price: Default::default(),
                gas_limit: u64::MAX.into(),
                to: None,
                value: Default::default(),
                data: contract.code.clone(),
            }
        })
        .unwrap();
    let address = Address::try_from_slice(&test_utils::unwrap_success(result)).unwrap();
    let contract = contract.deployed_at(address);

    // define functions to interact with the contract
    let get_address = |runner: &test_utils::AuroraRunner| {
        let result = runner
            .view_call(test_utils::as_view_call(
                contract.call_method_without_args("get", U256::zero()),
                viewer_address,
            ))
            .unwrap();
        match result {
            crate::prelude::parameters::TransactionStatus::Succeed(bytes) => {
                Address::try_from_slice(&bytes[12..32]).unwrap()
            }
            _ => panic!("tx failed"),
        }
    };

    let post_address = |runner: &mut test_utils::AuroraRunner, signer: &mut test_utils::Signer| {
        let result = runner
            .submit_with_signer(signer, |nonce| {
                contract.call_method_with_args(
                    "post",
                    &[ethabi::Token::String("Hello, world!".to_string())],
                    nonce,
                )
            })
            .unwrap();
        assert!(result.status.is_ok());
    };

    // Assert the initial state is 0
    assert_eq!(get_address(&runner), Address::new(H160([0; 20])));
    post_address(&mut runner, &mut account1);
    // Assert the address matches the first caller
    assert_eq!(get_address(&runner), account1_address);
    post_address(&mut runner, &mut account2);
    // Assert the address matches the second caller
    assert_eq!(get_address(&runner), account2_address);
}

#[test]
fn test_num_wasm_functions() {
    // Counts the number of functions in our wasm output.
    // See https://github.com/near/nearcore/issues/4814 for context
    let runner = test_utils::deploy_evm();
    let module = walrus::ModuleConfig::default()
        .parse(runner.code.code())
        .unwrap();
    let num_functions = module.funcs.iter().count();
    assert!(
        num_functions <= 1440,
        "{} is not less than 1440",
        num_functions
    );
}

/// Tests we can transfer Eth from one account to another and that the balances are correctly
/// updated.
#[test]
fn test_eth_transfer_success() {
    // set up Aurora runner and accounts
    let (mut runner, mut source_account, dest_address) = initialize_transfer();
    let source_address = test_utils::address_from_secret_key(&source_account.secret_key);

    // validate pre-state
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    test_utils::validate_address_balance_and_nonce(&runner, dest_address, Wei::zero(), 0.into());

    // perform transfer
    runner
        .submit_with_signer(&mut source_account, |nonce| {
            test_utils::transfer(dest_address, TRANSFER_AMOUNT, nonce)
        })
        .unwrap();

    // validate post-state
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE - TRANSFER_AMOUNT,
        (INITIAL_NONCE + 1).into(),
    );
    test_utils::validate_address_balance_and_nonce(
        &runner,
        dest_address,
        TRANSFER_AMOUNT,
        0.into(),
    );
}

/// Tests the case where the transfer amount is larger than the address balance
#[test]
fn test_eth_transfer_insufficient_balance() {
    let (mut runner, mut source_account, dest_address) = initialize_transfer();
    let source_address = test_utils::address_from_secret_key(&source_account.secret_key);

    // validate pre-state
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    test_utils::validate_address_balance_and_nonce(&runner, dest_address, Wei::zero(), 0.into());

    // attempt transfer
    let result = runner
        .submit_with_signer(&mut source_account, |nonce| {
            // try to transfer more than we have
            test_utils::transfer(dest_address, INITIAL_BALANCE + INITIAL_BALANCE, nonce)
        })
        .unwrap();
    assert_eq!(result.status, TransactionStatus::OutOfFund);

    // validate post-state
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE,
        // the nonce is still incremented even though the transfer failed
        (INITIAL_NONCE + 1).into(),
    );
    test_utils::validate_address_balance_and_nonce(&runner, dest_address, Wei::zero(), 0.into());
}

/// Tests the case where the nonce on the transaction does not match the address
#[test]
fn test_eth_transfer_incorrect_nonce() {
    let (mut runner, mut source_account, dest_address) = initialize_transfer();
    let source_address = test_utils::address_from_secret_key(&source_account.secret_key);

    // validate pre-state
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    test_utils::validate_address_balance_and_nonce(&runner, dest_address, Wei::zero(), 0.into());

    // attempt transfer
    let err = runner
        .submit_with_signer(&mut source_account, |nonce| {
            // creating transaction with incorrect nonce
            test_utils::transfer(dest_address, TRANSFER_AMOUNT, nonce + 1)
        })
        .unwrap_err();
    let error_message = format!("{:?}", err);
    assert!(error_message.contains("ERR_INCORRECT_NONCE"));

    // validate post-state (which is the same as pre-state in this case)
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    test_utils::validate_address_balance_and_nonce(&runner, dest_address, Wei::zero(), 0.into());
}

#[test]
fn test_eth_transfer_not_enough_gas() {
    let (mut runner, mut source_account, dest_address) = initialize_transfer();
    let source_address = test_utils::address_from_secret_key(&source_account.secret_key);
    let transaction = |nonce| {
        let mut tx = test_utils::transfer(dest_address, TRANSFER_AMOUNT, nonce);
        tx.gas_limit = 10_000.into(); // this is not enough gas
        tx
    };

    // validate pre-state
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    test_utils::validate_address_balance_and_nonce(&runner, dest_address, Wei::zero(), 0.into());

    // attempt transfer
    let err = runner
        .submit_with_signer(&mut source_account, transaction)
        .unwrap_err();
    let error_message = format!("{:?}", err);
    assert!(error_message.contains("ERR_INTRINSIC_GAS"));

    // validate post-state (which is the same as pre-state in this case)
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    test_utils::validate_address_balance_and_nonce(&runner, dest_address, Wei::zero(), 0.into());
}

#[test]
fn test_transfer_charging_gas_success() {
    let (mut runner, mut source_account, dest_address) = initialize_transfer();
    let source_address = test_utils::address_from_secret_key(&source_account.secret_key);
    let transaction = |nonce| {
        let mut tx = test_utils::transfer(dest_address, TRANSFER_AMOUNT, nonce);
        tx.gas_limit = 30_000.into();
        tx.gas_price = GAS_PRICE.into();
        tx
    };

    // validate pre-state
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    test_utils::validate_address_balance_and_nonce(&runner, dest_address, Wei::zero(), 0.into());

    // do transfer
    let result = runner
        .submit_with_signer(&mut source_account, transaction)
        .unwrap();
    let spent_amount = Wei::new_u64(GAS_PRICE * result.gas_used);
    let expected_source_balance = INITIAL_BALANCE - TRANSFER_AMOUNT - spent_amount;
    let expected_dest_balance = TRANSFER_AMOUNT;
    let expected_relayer_balance = spent_amount;
    let relayer_address = sdk::types::near_account_to_evm_address(
        runner.context.predecessor_account_id.as_ref().as_bytes(),
    );

    // validate post-state
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        expected_source_balance,
        (INITIAL_NONCE + 1).into(),
    );
    test_utils::validate_address_balance_and_nonce(
        &runner,
        dest_address,
        expected_dest_balance,
        0.into(),
    );
    test_utils::validate_address_balance_and_nonce(
        &runner,
        relayer_address,
        expected_relayer_balance,
        0.into(),
    );
}

#[test]
fn test_eth_transfer_charging_gas_not_enough_balance() {
    let (mut runner, mut source_account, dest_address) = initialize_transfer();
    let source_address = test_utils::address_from_secret_key(&source_account.secret_key);
    let transaction = |nonce| {
        let mut tx = test_utils::transfer(dest_address, TRANSFER_AMOUNT, nonce);
        // With this gas limit and price the account does not
        // have enough balance to cover the gas cost
        tx.gas_limit = 3_000_000.into();
        tx.gas_price = GAS_PRICE.into();
        tx
    };

    // validate pre-state
    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );
    test_utils::validate_address_balance_and_nonce(&runner, dest_address, Wei::zero(), 0.into());

    // attempt transfer
    let result = runner
        .submit_with_signer(&mut source_account, transaction)
        .unwrap();
    assert_eq!(result.status, TransactionStatus::OutOfFund);

    // validate post-state
    let relayer = sdk::types::near_account_to_evm_address(
        runner.context.predecessor_account_id.as_ref().as_bytes(),
    );

    test_utils::validate_address_balance_and_nonce(
        &runner,
        source_address,
        INITIAL_BALANCE,
        // nonce is still incremented since the transaction was otherwise valid
        (INITIAL_NONCE + 1).into(),
    );
    test_utils::validate_address_balance_and_nonce(&runner, dest_address, Wei::zero(), 0.into());
    test_utils::validate_address_balance_and_nonce(&runner, relayer, Wei::zero(), 0.into());
}

pub(crate) fn initialize_transfer() -> (test_utils::AuroraRunner, test_utils::Signer, Address) {
    // set up Aurora runner and accounts
    let mut runner = test_utils::deploy_evm();
    let mut rng = rand::thread_rng();
    let source_account = SecretKey::random(&mut rng);
    let source_address = test_utils::address_from_secret_key(&source_account);
    runner.create_address(source_address, INITIAL_BALANCE, INITIAL_NONCE.into());
    let dest_address = test_utils::address_from_secret_key(&SecretKey::random(&mut rng));
    let mut signer = test_utils::Signer::new(source_account);
    signer.nonce = INITIAL_NONCE;

    (runner, signer, dest_address)
}

use aurora_engine_types::H160;
use sha3::Digest;

#[test]
fn check_selector() {
    // Selector to call mint function in ERC 20 contract
    //
    // keccak("mint(address,uint256)".as_bytes())[..4];
    let mut hasher = sha3::Keccak256::default();
    hasher.update(b"mint(address,uint256)");
    assert_eq!(hasher.finalize()[..4].to_vec(), ERC20_MINT_SELECTOR);
}

#[test]
fn test_block_hash() {
    let runner = test_utils::AuroraRunner::default();
    let chain_id = {
        let number = crate::prelude::U256::from(runner.chain_id);
        crate::prelude::u256_to_arr(&number)
    };
    let account_id = runner.aurora_account_id;
    let block_hash = aurora_engine::engine::compute_block_hash(chain_id, 10, account_id.as_bytes());

    assert_eq!(
        hex::encode(block_hash.0).as_str(),
        "c4a46f076b64877cbd8c5dbfd7bfbbea21a5653b79e3b6d06b6dfb5c88f1c384",
    );
}

#[test]
fn test_block_hash_api() {
    let mut runner = test_utils::deploy_evm();

    let block_height: u64 = 10;
    let (maybe_outcome, maybe_error) = runner.call(
        "get_block_hash",
        "any.near",
        block_height.try_to_vec().unwrap(),
    );
    if let Some(error) = maybe_error {
        panic!("Call failed: {:?}", error);
    }
    let outcome = maybe_outcome.unwrap();
    let block_hash = outcome.return_data.as_value().unwrap();

    assert_eq!(
        hex::encode(&block_hash).as_str(),
        "c4a46f076b64877cbd8c5dbfd7bfbbea21a5653b79e3b6d06b6dfb5c88f1c384",
    );
}

#[test]
fn test_block_hash_contract() {
    let (mut runner, mut source_account, _) = initialize_transfer();
    let test_constructor = test_utils::solidity::ContractConstructor::compile_from_source(
        ["src", "tests", "res"].iter().collect::<PathBuf>(),
        Path::new("target").join("solidity_build"),
        "blockhash.sol",
        "BlockHash",
    );
    let nonce = source_account.use_nonce();
    let test_contract = runner.deploy_contract(
        &source_account.secret_key,
        |c| c.deploy_without_args(nonce.into()),
        test_constructor,
    );

    let result = runner
        .submit_with_signer(&mut source_account, |nonce| {
            test_contract.call_method_without_args("test", nonce)
        })
        .unwrap();

    test_utils::panic_on_fail(result.status);
}

#[test]
fn test_ft_metadata() {
    let mut runner = test_utils::deploy_evm();

    let account_id: String = runner.context.signer_account_id.clone().into();
    let (maybe_outcome, maybe_error) = runner.call("ft_metadata", &account_id, Vec::new());
    assert!(maybe_error.is_none());
    let outcome = maybe_outcome.unwrap();
    let json_value =
        aurora_engine::json::parse_json(&outcome.return_data.as_value().unwrap()).unwrap();

    assert_eq!(
        json_value,
        aurora_engine::json::JsonValue::from(FungibleTokenMetadata::default())
    );
}

// Same as `test_eth_transfer_insufficient_balance` above, except runs through
// `near-sdk-sim` instead of `near-vm-runner`. This is important because `near-sdk-sim`
// has more production logic, in particular, state revert on contract panic.
// TODO: should be able to generalize the `call` backend of `AuroraRunner` so that this
//       test does not need to be written twice.
#[test]
fn test_eth_transfer_insufficient_balance_sim() {
    let (aurora, mut signer, address) = initialize_evm_sim();

    // Run transaction which will fail (transfer more than current balance)
    let nonce = signer.use_nonce();
    let tx = test_utils::transfer(
        Address::new(H160([1; 20])),
        INITIAL_BALANCE + INITIAL_BALANCE,
        nonce.into(),
    );
    let signed_tx = test_utils::sign_transaction(
        tx,
        Some(test_utils::AuroraRunner::default().chain_id),
        &signer.secret_key,
    );
    let call_result = aurora.call("submit", rlp::encode(&signed_tx).as_ref());
    let result: SubmitResult = call_result.unwrap_borsh();
    assert_eq!(result.status, TransactionStatus::OutOfFund);

    // validate post-state
    assert_eq!(
        query_address_sim(&address, "get_nonce", &aurora),
        U256::from(INITIAL_NONCE + 1),
    );
    assert_eq!(
        query_address_sim(&address, "get_balance", &aurora),
        INITIAL_BALANCE.raw(),
    );
}

// Same as `test_eth_transfer_charging_gas_not_enough_balance` but run through `near-sdk-sim`.
#[test]
fn test_eth_transfer_charging_gas_not_enough_balance_sim() {
    let (aurora, mut signer, address) = initialize_evm_sim();

    // Run transaction which will fail (not enough balance to cover gas)
    let nonce = signer.use_nonce();
    let mut tx = test_utils::transfer(Address::new(H160([1; 20])), TRANSFER_AMOUNT, nonce.into());
    tx.gas_limit = 3_000_000.into();
    tx.gas_price = GAS_PRICE.into();
    let signed_tx = test_utils::sign_transaction(
        tx,
        Some(test_utils::AuroraRunner::default().chain_id),
        &signer.secret_key,
    );
    let call_result = aurora.call("submit", rlp::encode(&signed_tx).as_ref());
    let result: SubmitResult = call_result.unwrap_borsh();
    assert_eq!(result.status, TransactionStatus::OutOfFund);

    // validate post-state
    assert_eq!(
        query_address_sim(&address, "get_nonce", &aurora),
        U256::from(INITIAL_NONCE + 1),
    );
    assert_eq!(
        query_address_sim(&address, "get_balance", &aurora),
        INITIAL_BALANCE.raw(),
    );
}

fn initialize_evm_sim() -> (state_migration::AuroraAccount, test_utils::Signer, Address) {
    let aurora = state_migration::deploy_evm();
    let signer = test_utils::Signer::random();
    let address = test_utils::address_from_secret_key(&signer.secret_key);

    let args = (address, INITIAL_NONCE, INITIAL_BALANCE.raw().low_u64());
    aurora
        .call("mint_account", &args.try_to_vec().unwrap())
        .assert_success();

    // validate pre-state
    assert_eq!(
        query_address_sim(&address, "get_nonce", &aurora),
        U256::from(INITIAL_NONCE),
    );
    assert_eq!(
        query_address_sim(&address, "get_balance", &aurora),
        INITIAL_BALANCE.raw(),
    );

    (aurora, signer, address)
}

fn query_address_sim(
    address: &Address,
    method: &str,
    aurora: &state_migration::AuroraAccount,
) -> U256 {
    let x = aurora.call(method, address.as_bytes());
    match &x.outcome().status {
        near_sdk_sim::transaction::ExecutionStatus::SuccessValue(b) => U256::from_big_endian(b),
        other => panic!("Unexpected outcome: {:?}", other),
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/self_destruct_state.rs ---
use crate::test_utils;
use crate::test_utils::self_destruct::{
    SelfDestruct, SelfDestructConstructor, SelfDestructFactory, SelfDestructFactoryConstructor,
};

/// Check that account state should be properly removed after calling selfdestruct
#[test]
fn test_self_destruct_reset_state() {
    let mut signer = test_utils::Signer::random();
    let mut runner = test_utils::deploy_evm();

    let sd_factory_ctr = SelfDestructFactoryConstructor::load();
    let nonce = signer.use_nonce();
    let sd_factory: SelfDestructFactory = runner
        .deploy_contract(&signer.secret_key, |ctr| ctr.deploy(nonce), sd_factory_ctr)
        .into();

    let sd_contract_addr = sd_factory.deploy(&mut runner, &mut signer);

    let sd: SelfDestruct = SelfDestructConstructor::load()
        .0
        .deployed_at(sd_contract_addr)
        .into();

    let counter_value = sd.counter(&mut runner, &mut signer);
    assert_eq!(counter_value, Some(0));
    sd.increase(&mut runner, &mut signer);
    let counter_value = sd.counter(&mut runner, &mut signer);
    assert_eq!(counter_value, Some(1));
    sd.finish(&mut runner);
    let counter_value = sd.counter(&mut runner, &mut signer);
    assert!(counter_value.is_none());

    let sd_contract_addr1 = sd_factory.deploy(&mut runner, &mut signer);
    assert_eq!(sd_contract_addr, sd_contract_addr1);

    let counter_value = sd.counter(&mut runner, &mut signer);
    assert_eq!(counter_value, Some(0));
}

#[test]
fn test_self_destruct_with_submit() {
    let mut signer = test_utils::Signer::random();
    let mut runner = test_utils::deploy_evm();

    let sd_factory_ctr = SelfDestructFactoryConstructor::load();
    let nonce = signer.use_nonce();
    let sd_factory: SelfDestructFactory = runner
        .deploy_contract(&signer.secret_key, |ctr| ctr.deploy(nonce), sd_factory_ctr)
        .into();

    let sd_contract_addr = sd_factory.deploy(&mut runner, &mut signer);

    let sd: SelfDestruct = SelfDestructConstructor::load()
        .0
        .deployed_at(sd_contract_addr)
        .into();

    sd.finish_using_submit(&mut runner, &mut signer);
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/standalone/call_tracer.rs ---
use crate::test_utils::{self, standalone};
use aurora_engine_types::{
    parameters::{CrossContractCallArgs, PromiseArgs, PromiseCreateArgs},
    storage,
    types::{Address, NearGas, Wei, Yocto},
    U256,
};
use borsh::BorshSerialize;
use engine_standalone_storage::sync;
use engine_standalone_tracing::{
    sputnik,
    types::call_tracer::{self, CallTracer},
};

#[test]
fn test_trace_precompile_direct_call() {
    let mut runner = standalone::StandaloneRunner::default();
    let mut signer = test_utils::Signer::random();

    runner.init_evm();

    let tx = aurora_engine_transactions::legacy::TransactionLegacy {
        nonce: signer.use_nonce().into(),
        gas_price: U256::zero(),
        gas_limit: u64::MAX.into(),
        to: Some(aurora_engine_precompiles::random::RandomSeed::ADDRESS),
        value: Wei::zero(),
        data: Vec::new(),
    };

    let mut listener = CallTracer::default();
    let standalone_result = sputnik::traced_call(&mut listener, || {
        runner.submit_transaction(&signer.secret_key, tx).unwrap()
    });
    assert!(standalone_result.status.is_ok());
    assert_eq!(listener.call_stack.len(), 1);

    let trace = listener.call_stack.pop().unwrap();

    let expected_trace = call_tracer::CallFrame {
        call_type: call_tracer::CallType::Call,
        from: test_utils::address_from_secret_key(&signer.secret_key),
        to: Some(aurora_engine_precompiles::random::RandomSeed::ADDRESS),
        value: U256::zero(),
        gas: u64::MAX,
        gas_used: 21000_u64,
        input: Vec::new(),
        output: [0u8; 32].to_vec(),
        error: None,
        calls: Vec::new(),
    };

    assert_eq!(trace, expected_trace);

    runner.close();
}

#[test]
fn test_trace_contract_single_call() {
    let mut runner = standalone::StandaloneRunner::default();
    let mut signer = test_utils::Signer::random();
    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);

    runner.init_evm();

    let constructor = test_utils::erc20::ERC20Constructor::load();
    let deploy_tx = constructor.deploy("Test", "TST", signer.use_nonce().into());
    let deploy_result = runner
        .submit_transaction(&signer.secret_key, deploy_tx)
        .unwrap();
    let contract_address = {
        let bytes = test_utils::unwrap_success_slice(&deploy_result);
        Address::try_from_slice(bytes).unwrap()
    };
    let contract = test_utils::erc20::ERC20(constructor.0.deployed_at(contract_address));

    let tx = contract.balance_of(signer_address, signer.use_nonce().into());
    let mut listener = CallTracer::default();
    let standalone_result = sputnik::traced_call(&mut listener, || {
        runner
            .submit_transaction(&signer.secret_key, tx.clone())
            .unwrap()
    });
    assert!(standalone_result.status.is_ok());
    assert_eq!(listener.call_stack.len(), 1);

    let trace = listener.call_stack.pop().unwrap();

    let expected_trace = call_tracer::CallFrame {
        call_type: call_tracer::CallType::Call,
        from: signer_address,
        to: Some(contract_address),
        value: U256::zero(),
        gas: u64::MAX,
        gas_used: trace.gas_used,
        input: tx.data,
        output: [0u8; 32].to_vec(),
        error: None,
        calls: Vec::new(),
    };

    assert_eq!(trace, expected_trace);

    runner.close();
}

#[test]
fn test_trace_contract_with_sub_call() {
    use crate::tests::uniswap::UniswapTestContext;
    const MINT_AMOUNT: u64 = 1_000_000_000_000;
    const LIQUIDITY_AMOUNT: u64 = MINT_AMOUNT / 5;
    const OUTPUT_AMOUNT: u64 = LIQUIDITY_AMOUNT / 100;

    let mut context = UniswapTestContext::new("uniswap");
    let (token_a, token_b) = context.create_token_pair(MINT_AMOUNT.into());
    let pool = context.create_pool(&token_a, &token_b);

    let (_result, _profile) =
        context.add_equal_liquidity(LIQUIDITY_AMOUNT.into(), &token_a, &token_b);

    context.approve_erc20(&token_a, context.swap_router.0.address, U256::MAX);
    context.approve_erc20(&token_b, context.swap_router.0.address, U256::MAX);
    let params = context.exact_output_single_params(OUTPUT_AMOUNT.into(), &token_a, &token_b);

    let mut listener = CallTracer::default();
    let (_amount_in, _profile) = sputnik::traced_call(&mut listener, || {
        context
            .runner
            .submit_with_signer_profiled(&mut context.signer, |nonce| {
                context.swap_router.exact_output_single(params, nonce)
            })
            .unwrap()
    });

    assert_eq!(listener.call_stack.len(), 1);

    let user_address = test_utils::address_from_secret_key(&context.signer.secret_key);
    let router_address = context.swap_router.0.address;
    let pool_address = pool.0.address;
    let b_address = token_b.0.address;
    let a_address = token_a.0.address;

    // Call flow:
    // User -> Router.exactOutputSingle -> Pool.swap -> B.transfer
    //                                               -> A.balanceOf
    //                                               -> Router.uniswapV3SwapCallback -> A.transferFrom
    //                                               -> A.balanceOf
    let root_call = listener.call_stack.first().unwrap();
    assert_eq!(root_call.from, user_address);
    assert_eq!(root_call.to.unwrap(), router_address);

    let call = subcall_lense(root_call, &[0]);
    assert_eq!(call.from, router_address);
    assert_eq!(call.to.unwrap(), pool_address);

    let call = subcall_lense(root_call, &[0, 0]);
    assert_eq!(call.from, pool_address);
    assert_eq!(call.to.unwrap(), b_address);

    let call = subcall_lense(root_call, &[0, 1]);
    assert_eq!(call.from, pool_address);
    assert_eq!(call.to.unwrap(), a_address);

    let call = subcall_lense(root_call, &[0, 2]);
    assert_eq!(call.from, pool_address);
    assert_eq!(call.to.unwrap(), router_address);

    let call = subcall_lense(root_call, &[0, 2, 0]);
    assert_eq!(call.from, router_address);
    assert_eq!(call.to.unwrap(), a_address);

    let call = subcall_lense(root_call, &[0, 3]);
    assert_eq!(call.from, pool_address);
    assert_eq!(call.to.unwrap(), a_address);
}

#[test]
fn test_trace_contract_with_precompile_sub_call() {
    let mut runner = standalone::StandaloneRunner::default();
    let mut signer = test_utils::Signer::random();

    runner.init_evm();

    let constructor = test_utils::standard_precompiles::PrecompilesConstructor::load();
    let deploy_tx = constructor.deploy(signer.use_nonce().into());
    let deploy_result = runner
        .submit_transaction(&signer.secret_key, deploy_tx)
        .unwrap();
    let contract_address = {
        let bytes = test_utils::unwrap_success_slice(&deploy_result);
        Address::try_from_slice(bytes).unwrap()
    };
    let contract = test_utils::standard_precompiles::PrecompilesContract(
        constructor.0.deployed_at(contract_address),
    );

    // This transaction calls the standard precompiles (`ecrecover`, `sha256`, etc) one aft the other.
    // So the trace is one top-level call with multiple sub-calls (and the sub-calls contain no further sub-calls).
    let tx = contract.call_method("test_all", signer.use_nonce().into());
    let mut listener = CallTracer::default();
    let standalone_result = sputnik::traced_call(&mut listener, || {
        runner
            .submit_transaction(&signer.secret_key, tx.clone())
            .unwrap()
    });
    assert!(standalone_result.status.is_ok());
    assert_eq!(listener.call_stack.len(), 1);

    let trace = listener.call_stack.pop().unwrap();
    assert_eq!(trace.calls.len(), 8);
    for call in trace.calls {
        assert!(call.calls.is_empty());
    }

    runner.close();
}

#[test]
fn test_trace_precompiles_with_subcalls() {
    // The XCC precompile does internal sub-calls. We will trace an XCC call.

    let mut runner = standalone::StandaloneRunner::default();
    let mut signer = test_utils::Signer::random();
    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);
    let xcc_address = aurora_engine_precompiles::xcc::cross_contract_call::ADDRESS;

    runner.init_evm();

    // Deploy an ERC-20 contract to act as wNEAR. It doesn't actually need to be bridged for
    // this test because we are not executing any scheduled promises.
    let constructor = test_utils::erc20::ERC20Constructor::load();
    let deploy_tx = constructor.deploy("wNEAR", "WNEAR", signer.use_nonce().into());
    let deploy_result = runner
        .submit_transaction(&signer.secret_key, deploy_tx)
        .unwrap();
    let wnear_address = {
        let bytes = test_utils::unwrap_success_slice(&deploy_result);
        Address::try_from_slice(bytes).unwrap()
    };
    let wnear = test_utils::erc20::ERC20(constructor.0.deployed_at(wnear_address));
    let mint_tx = wnear.mint(signer_address, u128::MAX.into(), signer.use_nonce().into());
    runner
        .submit_transaction(&signer.secret_key, mint_tx)
        .unwrap();
    let approve_tx = wnear.approve(xcc_address, U256::MAX, signer.use_nonce().into());
    runner
        .submit_transaction(&signer.secret_key, approve_tx)
        .unwrap();
    // Ensure the above ERC-20 token is registered as if it were a bridged token
    {
        runner.env.block_height += 1;
        let storage = &mut runner.storage;
        let env = &runner.env;

        let mut tx =
            standalone::StandaloneRunner::template_tx_msg(storage, env, 0, Default::default(), &[]);
        tx.transaction = sync::types::TransactionKind::DeployErc20(
            aurora_engine::parameters::DeployErc20TokenArgs {
                nep141: "wrap.near".parse().unwrap(),
            },
        );
        let mut outcome = sync::execute_transaction_message(storage, tx).unwrap();
        let key = storage::bytes_to_key(storage::KeyPrefix::Nep141Erc20Map, b"wrap.near");
        outcome.diff.modify(key, wnear_address.as_bytes().to_vec());
        let key =
            storage::bytes_to_key(storage::KeyPrefix::Erc20Nep141Map, wnear_address.as_bytes());
        outcome.diff.modify(key, b"wrap.near".to_vec());
        test_utils::standalone::storage::commit(storage, &outcome);
    }

    // Setup xcc precompile in standalone runner
    let xcc_router_bytes = crate::tests::xcc::contract_bytes();
    let factory_update = {
        runner.env.block_height += 1;
        runner.env.predecessor_account_id = "aurora".parse().unwrap();
        runner.env.signer_account_id = "aurora".parse().unwrap();
        let storage = &mut runner.storage;
        let env = &runner.env;

        let mut tx =
            standalone::StandaloneRunner::template_tx_msg(storage, env, 0, Default::default(), &[]);
        tx.transaction = sync::types::TransactionKind::FactoryUpdate(xcc_router_bytes);
        tx
    };
    let outcome = sync::execute_transaction_message(&runner.storage, factory_update).unwrap();
    test_utils::standalone::storage::commit(&mut runner.storage, &outcome);
    let set_wnear_address = {
        runner.env.block_height += 1;
        let storage = &mut runner.storage;
        let env = &runner.env;

        let mut tx =
            standalone::StandaloneRunner::template_tx_msg(storage, env, 0, Default::default(), &[]);
        tx.transaction = sync::types::TransactionKind::FactorySetWNearAddress(wnear_address);
        tx
    };
    let outcome = sync::execute_transaction_message(&runner.storage, set_wnear_address).unwrap();
    test_utils::standalone::storage::commit(&mut runner.storage, &outcome);

    // User calls XCC precompile
    let promise = PromiseCreateArgs {
        target_account_id: "some_account.near".parse().unwrap(),
        method: "whatever".into(),
        args: Vec::new(),
        attached_balance: Yocto::new(1),
        attached_gas: NearGas::new(100_000_000_000_000),
    };
    let xcc_args = CrossContractCallArgs::Delayed(PromiseArgs::Create(promise));
    let tx = aurora_engine_transactions::legacy::TransactionLegacy {
        nonce: signer.use_nonce().into(),
        gas_price: U256::zero(),
        gas_limit: u64::MAX.into(),
        to: Some(xcc_address),
        value: Wei::zero(),
        data: xcc_args.try_to_vec().unwrap(),
    };
    let mut listener = CallTracer::default();
    let standalone_result = sputnik::traced_call(&mut listener, || {
        runner
            .submit_transaction(&signer.secret_key, tx.clone())
            .unwrap()
    });
    assert!(standalone_result.status.is_ok());
    assert_eq!(listener.call_stack.len(), 1);

    let trace = listener.call_stack.pop().unwrap();
    assert_eq!(trace.calls.len(), 1);
    let subcall = trace.calls.first().unwrap();
    assert_eq!(subcall.call_type, call_tracer::CallType::Call);
    assert_eq!(subcall.from, xcc_address);
    assert_eq!(subcall.to.unwrap(), wnear_address);
    assert_eq!(U256::from_big_endian(&subcall.output), U256::one());

    runner.close();
}

/// A convenience function for pulling out a sub-call from a trace.
/// The `path` gives the index to pull out of each `calls` array.
/// For example `path == []` simply returns the given `root`, while
/// `path == [2, 0]` will return `root.calls[2].calls[0]`.
fn subcall_lense<'a, 'b>(
    root: &'a call_tracer::CallFrame,
    path: &'b [usize],
) -> &'a call_tracer::CallFrame {
    let mut result = root;
    for index in path {
        result = result.calls.get(*index).unwrap();
    }
    result
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/standalone/json_snapshot.rs ---
use crate::test_utils::{self, standalone};
use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::{H160, U256};
use engine_standalone_storage::json_snapshot;

const NONCE_PREFIX: [u8; 2] = [0x07, 0x01];
const BALANCE_PREFIX: [u8; 2] = [0x07, 0x02];
const CODE_PREFIX: [u8; 2] = [0x07, 0x03];

#[test]
fn test_consume_snapshot() {
    let snapshot = json_snapshot::types::JsonSnapshot::load_from_file(
        "src/tests/res/contract.aurora.block51077328.json",
    )
    .unwrap();
    let mut runner = standalone::StandaloneRunner::default();
    json_snapshot::initialize_engine_state(&mut runner.storage, snapshot.clone()).unwrap();

    // check accounts to see they were written properly
    runner.env.block_height = snapshot.result.block_height + 1;
    for entry in snapshot.result.values {
        let key = base64::decode(entry.key).unwrap();
        let value = base64::decode(entry.value).unwrap();
        if key.as_slice().starts_with(&NONCE_PREFIX) {
            let address = address_from_key(&key);
            let nonce = U256::from_big_endian(&value);
            assert_eq!(nonce, runner.get_nonce(&address))
        } else if key.as_slice().starts_with(&BALANCE_PREFIX) {
            let address = address_from_key(&key);
            let balance = U256::from_big_endian(&value);
            assert_eq!(balance, runner.get_balance(&address).raw())
        } else if key.as_slice().starts_with(&CODE_PREFIX) {
            let address = address_from_key(&key);
            assert_eq!(value, runner.get_code(&address))
        }
    }

    runner.close();
}

#[test]
fn test_produce_snapshot() {
    let snapshot = json_snapshot::types::JsonSnapshot::load_from_file(
        "src/tests/res/contract.aurora.block51077328.json",
    )
    .unwrap();
    let mut runner = standalone::StandaloneRunner {
        chain_id: 1313161554,
        ..Default::default()
    };
    runner
        .storage
        .set_engine_account_id(&"aurora".parse().unwrap())
        .unwrap();
    json_snapshot::initialize_engine_state(&mut runner.storage, snapshot.clone()).unwrap();

    // add a couple more transactions that write some extra keys
    runner.env.block_height = snapshot.result.block_height + 1;
    let sk = libsecp256k1::SecretKey::parse(&[0x77; 32]).unwrap();
    let mut signer = test_utils::Signer::new(sk);
    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);
    let dest1 = Address::from_array([0x11; 20]);
    let dest2 = Address::from_array([0x22; 20]);
    let initial_balance = Wei::from_eth(U256::one()).unwrap();
    let transfer_amount = Wei::new_u64(100_000);
    runner.mint_account(signer_address, initial_balance, U256::zero(), None);

    runner
        .transfer_with_signer(&mut signer, transfer_amount, dest1)
        .unwrap();
    runner
        .transfer_with_signer(&mut signer, transfer_amount, dest2)
        .unwrap();

    // Take snapshot from before these transactions new are included
    let mut computed_snapshot = runner
        .storage
        .get_snapshot(snapshot.result.block_height)
        .unwrap();

    // Computed snapshot should exactly the same keys from initial snapshot
    for entry in snapshot.result.values.iter() {
        let key = base64::decode(&entry.key).unwrap();
        let value = base64::decode(&entry.value).unwrap();
        assert_eq!(computed_snapshot.remove(&key).unwrap(), value);
    }
    assert!(computed_snapshot.is_empty());

    // Take snapshot of current state
    let computed_snapshot = runner
        .storage
        .get_snapshot(runner.env.block_height)
        .unwrap();

    // New snapshot should still contain all keys from initial snapshot
    for entry in snapshot.result.values {
        let key = base64::decode(entry.key).unwrap();
        // skip the eth-connector keys; they were changed by minting the new account
        if key[0..3] == [7, 6, 1] {
            continue;
        }
        let value = base64::decode(entry.value).unwrap();
        assert_eq!(computed_snapshot.get(&key).unwrap(), &value);
    }

    // New snapshot should contain the keys from the new transactions as well
    let addr_info = [
        signer_address.as_bytes(),
        dest1.as_bytes(),
        dest2.as_bytes(),
    ]
    .into_iter()
    .zip([
        initial_balance - transfer_amount - transfer_amount,
        transfer_amount,
        transfer_amount,
    ])
    .zip([signer.nonce, 0, 0]);
    for ((address, balance), nonce) in addr_info {
        let balance_key = [&BALANCE_PREFIX, address].concat();
        let nonce_key = [&NONCE_PREFIX, address].concat();
        let balance_value = balance.to_bytes().to_vec();
        let nonce_value = {
            let mut buf = vec![0; 32];
            U256::from(nonce).to_big_endian(&mut buf);
            buf
        };
        assert_eq!(computed_snapshot.get(&balance_key).unwrap(), &balance_value);
        if nonce != 0 {
            assert_eq!(computed_snapshot.get(&nonce_key).unwrap(), &nonce_value);
        }
    }

    runner.close();
}

fn address_from_key(key: &[u8]) -> Address {
    let mut result = [0u8; 20];
    result.copy_from_slice(&key[2..22]);
    Address::new(H160(result))
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/standalone/mod.rs ---
mod call_tracer;
mod json_snapshot;
mod sanity;
mod storage;
mod sync;
mod tracing;

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/standalone/sanity.rs ---
use aurora_engine::engine;
use aurora_engine_sdk::env::DEFAULT_PREPAID_GAS;
use aurora_engine_test_doubles::io::{Storage, StoragePointer};
use aurora_engine_test_doubles::promise::PromiseTracker;
use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::{account_id::AccountId, H160, H256, U256};
use std::sync::RwLock;

#[test]
fn test_deploy_code() {
    let chain_id: [u8; 32] = {
        let value = U256::from(1313161554);
        let mut buf = [0u8; 32];
        value.to_big_endian(&mut buf);
        buf
    };
    let owner_id: AccountId = "aurora".parse().unwrap();
    let state = engine::EngineState {
        chain_id,
        owner_id: owner_id.clone(),
        bridge_prover_id: "mr_the_prover".parse().unwrap(),
        upgrade_delay_blocks: 0,
    };
    let origin = Address::new(H160([0u8; 20]));
    let storage = RwLock::new(Storage::default());
    let io = StoragePointer(&storage);
    let env = aurora_engine_sdk::env::Fixed {
        signer_account_id: owner_id.clone(),
        current_account_id: owner_id.clone(),
        predecessor_account_id: owner_id.clone(),
        block_height: 0,
        block_timestamp: aurora_engine_sdk::env::Timestamp::new(0),
        attached_deposit: 0,
        random_seed: H256::zero(),
        prepaid_gas: DEFAULT_PREPAID_GAS,
    };
    let mut handler = PromiseTracker::default();
    let mut engine = engine::Engine::new_with_state(state, origin, owner_id, io, &env);
    let code_to_deploy = vec![1, 2, 3, 4, 5, 6];
    let result = engine.deploy_code(
        origin,
        Wei::zero(),
        evm_deploy(&code_to_deploy),
        u64::MAX,
        Vec::new(),
        &mut handler,
    );

    // no promises are scheduled
    assert!(handler.scheduled_promises.is_empty());

    // execution was successful
    let contract_address = match result.unwrap().status {
        aurora_engine::parameters::TransactionStatus::Succeed(bytes) => {
            Address::try_from_slice(&bytes).unwrap()
        }
        other => panic!("Unexpected status: {:?}", other),
    };

    // state is updated
    assert_eq!(engine::get_balance(&io, &origin), Wei::zero());
    assert_eq!(engine::get_balance(&io, &contract_address), Wei::zero());
    assert_eq!(engine::get_nonce(&io, &origin), U256::one());
    assert_eq!(engine::get_nonce(&io, &contract_address), U256::one());
    assert_eq!(engine::get_generation(&io, &contract_address), 1);
    assert_eq!(engine::get_code(&io, &contract_address), code_to_deploy);
}

fn evm_deploy(code: &[u8]) -> Vec<u8> {
    let len = code.len();
    if len > u16::MAX as usize {
        panic!("Cannot deploy a contract with that many bytes!");
    }
    let len = len as u16;
    // This bit of EVM byte code essentially says:
    // "If msg.value > 0 revert; otherwise return `len` amount of bytes that come after me
    // in the code." By prepending this to `code` we create a valid EVM program which
    // returns `code`, which is exactly what we want.
    let init_code = format!(
        "608060405234801561001057600080fd5b5061{}806100206000396000f300",
        hex::encode(len.to_be_bytes())
    );
    hex::decode(init_code)
        .unwrap()
        .into_iter()
        .chain(code.iter().copied())
        .collect()
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/standalone/storage.rs ---
use aurora_engine_sdk::env::Timestamp;
use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::{H256, U256};
use engine_standalone_storage::{
    sync::types::{TransactionKind, TransactionMessage},
    BlockMetadata,
};

use crate::test_utils::standalone::{mocks, storage::create_db};
use crate::test_utils::{self, Signer};

#[test]
fn test_replay_transaction() {
    let mut signer = Signer::random();
    let address = test_utils::address_from_secret_key(&signer.secret_key);
    let balance = Wei::new_u64(1000);
    let dest_address = test_utils::address_from_secret_key(&Signer::random().secret_key);
    let transfer_amounts: Vec<Wei> = vec![10, 13, 75, 88, 1, 9, 19, 256]
        .into_iter()
        .map(Wei::new_u64)
        .collect();
    let cumulative_transfer_amounts: Vec<Wei> = transfer_amounts
        .iter()
        .scan(Wei::zero(), |total, amount| {
            let new_total = *total + *amount;
            *total = new_total;
            Some(new_total)
        })
        .collect();
    let mut runner = test_utils::standalone::StandaloneRunner::default();
    let chain_id = Some(runner.chain_id);
    let create_transfer = |from: &mut Signer, to: Address, amount: Wei| {
        test_utils::sign_transaction(
            test_utils::transfer(to, amount, from.use_nonce().into()),
            chain_id,
            &from.secret_key,
        )
    };

    runner.init_evm();
    runner.mint_account(address, balance, signer.nonce.into(), None);

    let blockchain: mocks::block::Blockchain = vec![
        mocks::block::Block {
            height: 5,
            transactions: vec![
                create_transfer(&mut signer, dest_address, transfer_amounts[0]),
                create_transfer(&mut signer, dest_address, transfer_amounts[1]),
            ],
        },
        mocks::block::Block {
            height: 12,
            transactions: vec![
                create_transfer(&mut signer, dest_address, transfer_amounts[2]),
                create_transfer(&mut signer, dest_address, transfer_amounts[3]),
                create_transfer(&mut signer, dest_address, transfer_amounts[4]),
            ],
        },
        mocks::block::Block {
            height: 13,
            transactions: vec![create_transfer(
                &mut signer,
                dest_address,
                transfer_amounts[5],
            )],
        },
        mocks::block::Block {
            height: 20,
            transactions: vec![
                create_transfer(&mut signer, dest_address, transfer_amounts[6]),
                create_transfer(&mut signer, dest_address, transfer_amounts[7]),
            ],
        },
    ];

    // execute all the transactions
    let mut i = 0; // counter to keep track of which transaction we're on in the flattened list
    let sequential_diffs: Vec<Vec<_>> = blockchain
        .iter()
        .map(|block| {
            let block_height = block.height;
            block
                .transactions
                .iter()
                .enumerate()
                .map(|(position, tx)| {
                    let diff = runner
                        .execute_transaction_at_position(tx, block_height, position as u16)
                        .unwrap();

                    test_utils::standalone::storage::commit(&mut runner.storage, &diff);

                    assert_eq!(
                        runner.get_balance(&address),
                        balance - cumulative_transfer_amounts[i]
                    );
                    assert_eq!(
                        runner.get_balance(&dest_address),
                        cumulative_transfer_amounts[i]
                    );

                    i += 1;
                    diff.diff
                })
                .collect()
        })
        .collect();

    // should be able to replay all transactions in any order
    let mut rng = rand::thread_rng();
    let mut shuffled: Vec<_> = blockchain.iter().zip(sequential_diffs).collect();
    rand::seq::SliceRandom::shuffle(shuffled.as_mut_slice(), &mut rng);

    for (block, diffs) in shuffled {
        let block_height = block.height;
        let mut txs: Vec<_> = block.transactions.iter().enumerate().zip(diffs).collect();
        rand::seq::SliceRandom::shuffle(txs.as_mut_slice(), &mut rng);
        for ((position, tx), diff) in txs {
            let replay_diff = runner
                .execute_transaction_at_position(tx, block_height, position as u16)
                .unwrap()
                .diff;
            assert_eq!(replay_diff, diff);
        }
    }
}

#[test]
fn test_consume_transaction() {
    // Some util structures we will use in this test
    let signer = Signer::random();
    let address = test_utils::address_from_secret_key(&signer.secret_key);
    let balance = Wei::new_u64(1000);
    let transfer_amount = Wei::new_u64(37);
    let nonce = signer.nonce.into();
    let dest_address = test_utils::address_from_secret_key(&Signer::random().secret_key);
    let mut runner = test_utils::standalone::StandaloneRunner::default();

    runner.init_evm();
    runner.mint_account(address, balance, nonce, None);

    // check pre-state
    assert_eq!(runner.get_balance(&address), balance);
    assert_eq!(runner.get_nonce(&address), U256::zero());

    // Try to execute a transfer transaction
    let tx = test_utils::transfer(dest_address, transfer_amount, nonce);
    let result = runner.submit_transaction(&signer.secret_key, tx).unwrap();
    assert!(result.status.is_ok());

    // Confirm the balances and nonces match the expected values (note the transfer has been applied)
    assert_eq!(runner.get_balance(&address), balance - transfer_amount);
    assert_eq!(runner.get_balance(&dest_address), transfer_amount);
    assert_eq!(runner.get_nonce(&address), U256::one());
    assert_eq!(runner.get_nonce(&dest_address), U256::zero());

    runner.close();
}

#[test]
fn test_block_index() {
    let (temp_dir, mut storage) = create_db();

    let block_hash = H256([3u8; 32]);
    let block_height = 17u64;
    let block_metadata = BlockMetadata {
        timestamp: Timestamp::new(23_000),
        random_seed: H256([91u8; 32]),
    };

    // write block hash / height association
    storage
        .set_block_data(block_hash, block_height, block_metadata.clone())
        .unwrap();
    // read it back
    assert_eq!(
        block_hash,
        storage.get_block_hash_by_height(block_height).unwrap()
    );
    assert_eq!(
        block_height,
        storage.get_block_height_by_hash(block_hash).unwrap()
    );
    assert_eq!(
        block_metadata,
        storage.get_block_metadata(block_hash).unwrap()
    );
    assert_eq!(
        (block_hash, block_height),
        storage.get_latest_block().unwrap(),
    );
    assert_eq!(
        (block_hash, block_height),
        storage.get_earliest_block().unwrap(),
    );

    // block hash / height that do not exist are errors
    let missing_block_height = block_height + 1;
    let missing_block_hash = H256([32u8; 32]);
    match storage.get_block_hash_by_height(missing_block_height) {
        Err(engine_standalone_storage::Error::NoBlockAtHeight(h)) if h == missing_block_height => {}
        other => panic!("Unexpected response: {:?}", other),
    }
    match storage.get_block_height_by_hash(missing_block_hash) {
        Err(engine_standalone_storage::Error::BlockNotFound(h)) if h == missing_block_hash => (), // ok
        other => panic!("Unexpected response: {:?}", other),
    }
    match storage.get_block_metadata(missing_block_hash) {
        Err(engine_standalone_storage::Error::BlockNotFound(h)) if h == missing_block_hash => (), // ok
        other => panic!("Unexpected response: {:?}", other),
    }

    // insert later block
    let next_height = block_height + 1;
    let next_hash = H256([0xaa; 32]);
    storage
        .set_block_data(next_hash, next_height, block_metadata.clone())
        .unwrap();

    // check earliest+latest blocks are still correct
    assert_eq!(
        (next_hash, next_height),
        storage.get_latest_block().unwrap(),
    );
    assert_eq!(
        (block_hash, block_height),
        storage.get_earliest_block().unwrap(),
    );

    // insert earlier block
    let prev_height = block_height - 1;
    let prev_hash = H256([0xbb; 32]);
    storage
        .set_block_data(prev_hash, prev_height, block_metadata)
        .unwrap();

    // check earliest+latest blocks are still correct
    assert_eq!(
        (next_hash, next_height),
        storage.get_latest_block().unwrap(),
    );
    assert_eq!(
        (prev_hash, prev_height),
        storage.get_earliest_block().unwrap(),
    );

    drop(storage);
    temp_dir.close().unwrap();
}

#[test]
fn test_transaction_index() {
    let (temp_dir, mut storage) = create_db();

    let block_height = 37u64;
    mocks::insert_block(&mut storage, block_height);
    let block_hash = mocks::compute_block_hash(block_height);
    let tx_hash = H256([77u8; 32]);
    let tx_position = 0u16;
    let tx_msg = TransactionMessage {
        block_hash,
        near_receipt_id: H256::zero(),
        position: tx_position,
        succeeded: true,
        signer: "placeholder.near".parse().unwrap(),
        caller: "placeholder.near".parse().unwrap(),
        attached_near: 0,
        transaction: TransactionKind::Unknown,
        promise_data: Vec::new(),
    };
    let tx_included = engine_standalone_storage::TransactionIncluded {
        block_hash,
        position: tx_position,
    };
    let diff = {
        let mut tmp = engine_standalone_storage::Diff::default();
        let key = aurora_engine_types::storage::bytes_to_key(
            aurora_engine_types::storage::KeyPrefix::Balance,
            &[1u8; 20],
        );
        let value = crate::prelude::Wei::new_u64(159).to_bytes().to_vec();
        tmp.modify(key, value);
        tmp
    };

    // write transaction association
    storage
        .set_transaction_included(tx_hash, &tx_msg, &diff)
        .unwrap();
    // read it back
    assert_eq!(tx_msg, storage.get_transaction_data(tx_hash).unwrap(),);
    assert_eq!(
        tx_hash,
        storage.get_transaction_by_position(tx_included).unwrap()
    );
    assert_eq!(
        diff.try_to_bytes().unwrap(),
        storage
            .get_transaction_diff(tx_included)
            .unwrap()
            .try_to_bytes()
            .unwrap()
    );

    // transactions that do not exist are errors
    let missing_block_hash = H256([32u8; 32]);
    let tx_not_included = engine_standalone_storage::TransactionIncluded {
        block_hash: missing_block_hash,
        position: 0,
    };
    let missing_tx_hash = H256([13u8; 32]);
    match storage.get_transaction_data(missing_tx_hash) {
        Err(engine_standalone_storage::Error::TransactionHashNotFound(h))
            if h == missing_tx_hash => {}
        other => panic!("Unexpected response: {:?}", other),
    }
    match storage.get_transaction_by_position(tx_not_included) {
        Err(engine_standalone_storage::Error::TransactionNotFound(x)) if x == tx_not_included => (), // ok
        other => panic!("Unexpected response: {:?}", other),
    }
    match storage.get_transaction_diff(tx_not_included) {
        Err(engine_standalone_storage::Error::TransactionNotFound(x)) if x == tx_not_included => (), // ok
        other => panic!("Unexpected response: {:?}", other),
    }

    drop(storage);
    temp_dir.close().unwrap();
}

#[test]
fn test_track_key() {
    // Set up the test
    let mut signer = Signer::random();
    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);
    let initial_balance = Wei::new_u64(1000);
    let transfer_amount = Wei::new_u64(37);
    let dest1 = Address::from_array([0x11; 20]);
    let dest2 = Address::from_array([0x22; 20]);
    let mut runner = test_utils::standalone::StandaloneRunner::default();

    runner.init_evm();
    runner.mint_account(signer_address, initial_balance, signer.nonce.into(), None);
    let created_block_height = runner.env.block_height;

    let result = runner
        .transfer_with_signer(&mut signer, transfer_amount, dest1)
        .unwrap();
    assert!(result.status.is_ok());
    let result = runner
        .transfer_with_signer(&mut signer, transfer_amount, dest2)
        .unwrap();
    assert!(result.status.is_ok());

    // The balance key for the signer will have changed 3 times:
    // 1. Account minted
    // 2. Transfer to dest1
    // 3. Transfer to dest2
    let balance_key = aurora_engine_types::storage::address_to_key(
        aurora_engine_types::storage::KeyPrefix::Balance,
        &signer_address,
    );
    let trace = runner.storage.track_engine_key(&balance_key).unwrap();
    let mut expected_balance = initial_balance;
    for (i, (block_height, tx_hash, value)) in trace.into_iter().enumerate() {
        let i = i as u64;
        assert_eq!(block_height, created_block_height + i);
        let transaction_included = engine_standalone_storage::TransactionIncluded {
            block_hash: runner
                .storage
                .get_block_hash_by_height(block_height)
                .unwrap(),
            position: 0,
        };
        assert_eq!(
            tx_hash,
            runner
                .storage
                .get_transaction_by_position(transaction_included)
                .unwrap()
        );
        let balance = Wei::new(U256::from_big_endian(value.value().unwrap()));
        assert_eq!(balance, expected_balance);
        expected_balance = expected_balance - transfer_amount;
    }

    runner.close();
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/standalone/sync.rs ---
use aurora_engine::deposit_event::TokenMessageData;
use aurora_engine_sdk::env::{Env, Timestamp};
use aurora_engine_types::types::{Address, Balance, Fee, NEP141Wei, Wei};
use aurora_engine_types::{account_id::AccountId, H160, H256, U256};
use borsh::{BorshDeserialize, BorshSerialize};
use engine_standalone_storage::sync;

use crate::test_utils::{self, standalone::StandaloneRunner};

#[test]
fn test_consume_block_message() {
    let (runner, block_message) = initialize();

    assert_eq!(
        runner
            .storage
            .get_block_height_by_hash(block_message.hash)
            .unwrap(),
        block_message.height,
    );
    assert_eq!(
        runner
            .storage
            .get_block_hash_by_height(block_message.height)
            .unwrap(),
        block_message.hash,
    );
    assert_eq!(
        runner
            .storage
            .get_block_metadata(block_message.hash)
            .unwrap(),
        block_message.metadata,
    );

    runner.close()
}

#[test]
fn test_consume_deposit_message() {
    let (mut runner, block_message) = initialize();

    let recipient_address = Address::new(H160([22u8; 20]));
    let deposit_amount = Wei::new_u64(123_456_789);
    let proof = mock_proof(recipient_address, deposit_amount);

    let transaction_message = sync::types::TransactionMessage {
        block_hash: block_message.hash,
        near_receipt_id: H256([0x11; 32]),
        position: 0,
        succeeded: true,
        signer: runner.env.signer_account_id(),
        caller: runner.env.predecessor_account_id(),
        attached_near: 0,
        transaction: sync::types::TransactionKind::Deposit(proof.try_to_vec().unwrap()),
        promise_data: Vec::new(),
    };

    let outcome = sync::consume_message(
        &mut runner.storage,
        sync::types::Message::Transaction(Box::new(transaction_message)),
    )
    .unwrap();
    let outcome = match outcome {
        sync::ConsumeMessageOutcome::TransactionIncluded(outcome) => outcome,
        other => panic!("Unexpected outcome {:?}", other),
    };

    let finish_deposit_args = match outcome.maybe_result.unwrap().unwrap() {
        sync::TransactionExecutionResult::Promise(promise_args) => {
            let bytes = promise_args.callback.args;
            aurora_engine::parameters::FinishDepositCallArgs::try_from_slice(&bytes).unwrap()
        }
        other => panic!("Unexpected result {:?}", other),
    };
    // Now executing aurora callbacks, so predecessor_account_id = current_account_id
    runner.env.predecessor_account_id = runner.env.current_account_id.clone();

    let transaction_message = sync::types::TransactionMessage {
        block_hash: block_message.hash,
        near_receipt_id: H256([0x22; 32]),
        position: 1,
        succeeded: true,
        signer: runner.env.signer_account_id(),
        caller: runner.env.predecessor_account_id(),
        attached_near: 0,
        transaction: sync::types::TransactionKind::FinishDeposit(finish_deposit_args),
        promise_data: Vec::new(),
    };

    let outcome = sync::consume_message(
        &mut runner.storage,
        sync::types::Message::Transaction(Box::new(transaction_message)),
    )
    .unwrap();
    let outcome = match outcome {
        sync::ConsumeMessageOutcome::TransactionIncluded(outcome) => outcome,
        other => panic!("Unexpected outcome {:?}", other),
    };

    let ft_on_transfer_args = match outcome.maybe_result.unwrap().unwrap() {
        sync::TransactionExecutionResult::Promise(promise_args) => {
            let bytes = promise_args.base.args;
            let json = aurora_engine::json::parse_json(&bytes).unwrap();
            aurora_engine::parameters::NEP141FtOnTransferArgs::try_from(json)
                .ok()
                .unwrap()
        }
        other => panic!("Unexpected result {:?}", other),
    };

    let transaction_message = sync::types::TransactionMessage {
        block_hash: block_message.hash,
        near_receipt_id: H256([0x33; 32]),
        position: 2,
        succeeded: true,
        signer: runner.env.signer_account_id(),
        caller: runner.env.predecessor_account_id(),
        attached_near: 0,
        transaction: sync::types::TransactionKind::FtOnTransfer(ft_on_transfer_args),
        promise_data: Vec::new(),
    };

    sync::consume_message(
        &mut runner.storage,
        sync::types::Message::Transaction(Box::new(transaction_message)),
    )
    .unwrap();

    assert_eq!(runner.get_balance(&recipient_address), deposit_amount);

    runner.close()
}

#[test]
fn test_consume_deploy_message() {
    let (mut runner, block_message) = initialize();

    let code = b"hello_world!".to_vec();
    let input = test_utils::create_deploy_transaction(code.clone(), U256::zero()).data;

    let transaction_message = sync::types::TransactionMessage {
        block_hash: block_message.hash,
        near_receipt_id: H256([8u8; 32]),
        position: 0,
        succeeded: true,
        signer: runner.env.signer_account_id(),
        caller: runner.env.predecessor_account_id(),
        attached_near: 0,
        transaction: sync::types::TransactionKind::Deploy(input),
        promise_data: Vec::new(),
    };

    sync::consume_message(
        &mut runner.storage,
        sync::types::Message::Transaction(Box::new(transaction_message)),
    )
    .unwrap();

    let diff = runner
        .storage
        .get_transaction_diff(engine_standalone_storage::TransactionIncluded {
            block_hash: block_message.hash,
            position: 0,
        })
        .unwrap();
    let mut deployed_address = Address::zero();
    for (key, value) in diff.iter() {
        match value.value() {
            Some(bytes) if bytes == code.as_slice() => {
                deployed_address = Address::try_from_slice(&key[2..22]).unwrap();
                break;
            }
            _ => continue,
        }
    }

    assert_eq!(runner.get_code(&deployed_address), code);

    runner.close()
}

#[test]
fn test_consume_deploy_erc20_message() {
    let (mut runner, block_message) = initialize();

    let token: AccountId = "some_nep141.near".parse().unwrap();
    let mint_amount: u128 = 555_555;
    let dest_address = Address::new(H160([170u8; 20]));

    let args = aurora_engine::parameters::DeployErc20TokenArgs {
        nep141: token.clone(),
    };
    let transaction_message = sync::types::TransactionMessage {
        block_hash: block_message.hash,
        near_receipt_id: H256([8u8; 32]),
        position: 0,
        succeeded: true,
        signer: runner.env.signer_account_id(),
        caller: runner.env.predecessor_account_id(),
        attached_near: 0,
        transaction: sync::types::TransactionKind::DeployErc20(args),
        promise_data: Vec::new(),
    };

    // Deploy ERC-20 (this would be the flow for bridging a new NEP-141 to Aurora)
    sync::consume_message(
        &mut runner.storage,
        sync::types::Message::Transaction(Box::new(transaction_message)),
    )
    .unwrap();

    let erc20_address = runner
        .storage
        .with_engine_access(runner.env.block_height + 1, 0, &[], |io| {
            aurora_engine::engine::get_erc20_from_nep141(&io, &token)
        })
        .result
        .unwrap();

    runner.env.block_height += 1;
    runner.env.signer_account_id = "some_account.near".parse().unwrap();
    runner.env.predecessor_account_id = token;
    test_utils::standalone::mocks::insert_block(&mut runner.storage, runner.env.block_height);
    let block_hash = test_utils::standalone::mocks::compute_block_hash(runner.env.block_height);

    let args = aurora_engine::parameters::NEP141FtOnTransferArgs {
        sender_id: "mr_money_bags.near".parse().unwrap(),
        amount: Balance::new(mint_amount),
        msg: hex::encode(dest_address.as_bytes()),
    };
    let transaction_message = sync::types::TransactionMessage {
        block_hash,
        near_receipt_id: H256([8u8; 32]),
        position: 0,
        succeeded: true,
        signer: runner.env.signer_account_id(),
        caller: runner.env.predecessor_account_id(),
        attached_near: 0,
        transaction: sync::types::TransactionKind::FtOnTransfer(args),
        promise_data: Vec::new(),
    };

    // Mint new tokens (via ft_on_transfer flow, same as the bridge)
    sync::consume_message(
        &mut runner.storage,
        sync::types::Message::Transaction(Box::new(transaction_message)),
    )
    .unwrap();

    // Check balance is correct
    let deployed_token = test_utils::erc20::ERC20(
        test_utils::erc20::ERC20Constructor::load()
            .0
            .deployed_at(Address::try_from_slice(&erc20_address).unwrap()),
    );
    let signer = test_utils::Signer::random();
    let tx = deployed_token.balance_of(dest_address, signer.nonce.into());
    let result = runner.submit_transaction(&signer.secret_key, tx).unwrap();
    assert_eq!(
        U256::from_big_endian(&test_utils::unwrap_success(result)).low_u128(),
        mint_amount
    );
}

#[test]
fn test_consume_ft_on_transfer_message() {
    // Only need to check the case of aurora calling `ft_on_transfer` on itself, the other case
    // is handled in the `test_consume_deploy_erc20_message` above.

    let (mut runner, block_message) = initialize();

    let mint_amount = 8_675_309;
    let fee = Wei::zero();
    let dest_address = Address::new(H160([221u8; 20]));

    // Mint ETH on Aurora per the bridge workflow
    let args = aurora_engine::parameters::NEP141FtOnTransferArgs {
        sender_id: "mr_money_bags.near".parse().unwrap(),
        amount: Balance::new(mint_amount),
        msg: [
            "relayer.near",
            ":",
            hex::encode(fee.to_bytes()).as_str(),
            hex::encode(dest_address.as_bytes()).as_str(),
        ]
        .concat(),
    };
    let transaction_message = sync::types::TransactionMessage {
        block_hash: block_message.hash,
        near_receipt_id: H256([8u8; 32]),
        position: 0,
        succeeded: true,
        signer: runner.env.signer_account_id(),
        caller: runner.env.predecessor_account_id(),
        attached_near: 0,
        transaction: sync::types::TransactionKind::FtOnTransfer(args),
        promise_data: Vec::new(),
    };

    sync::consume_message(
        &mut runner.storage,
        sync::types::Message::Transaction(Box::new(transaction_message)),
    )
    .unwrap();

    assert_eq!(
        runner.get_balance(&dest_address).raw().low_u128(),
        mint_amount
    );
}

#[test]
fn test_consume_call_message() {
    let (mut runner, _) = initialize();

    let caller = "some_account.near";
    let initial_balance = Wei::new_u64(800_000);
    let transfer_amount = Wei::new_u64(115_321);
    let caller_address = aurora_engine_sdk::types::near_account_to_evm_address(caller.as_bytes());
    let recipient_address = Address::new(H160([1u8; 20]));
    runner.mint_account(caller_address, initial_balance, U256::zero(), None);

    runner.env.block_height += 1;
    runner.env.signer_account_id = caller.parse().unwrap();
    runner.env.predecessor_account_id = caller.parse().unwrap();
    test_utils::standalone::mocks::insert_block(&mut runner.storage, runner.env.block_height);
    let block_hash = test_utils::standalone::mocks::compute_block_hash(runner.env.block_height);

    let transaction_message = sync::types::TransactionMessage {
        block_hash,
        near_receipt_id: H256([8u8; 32]),
        position: 0,
        succeeded: true,
        signer: runner.env.signer_account_id(),
        caller: runner.env.predecessor_account_id(),
        attached_near: 0,
        transaction: sync::types::TransactionKind::Call(simple_transfer_args(
            recipient_address,
            transfer_amount,
        )),
        promise_data: Vec::new(),
    };

    sync::consume_message(
        &mut runner.storage,
        sync::types::Message::Transaction(Box::new(transaction_message)),
    )
    .unwrap();

    assert_eq!(runner.get_balance(&recipient_address), transfer_amount);
    assert_eq!(
        runner.get_balance(&caller_address),
        initial_balance - transfer_amount
    );
    assert_eq!(runner.get_nonce(&caller_address), U256::one());
}

#[test]
fn test_consume_submit_message() {
    let (mut runner, _) = initialize();

    let mut signer = test_utils::Signer::random();
    let initial_balance = Wei::new_u64(800_000);
    let transfer_amount = Wei::new_u64(115_321);
    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);
    let recipient_address = Address::new(H160([1u8; 20]));
    runner.mint_account(signer_address, initial_balance, signer.nonce.into(), None);

    runner.env.block_height += 1;
    test_utils::standalone::mocks::insert_block(&mut runner.storage, runner.env.block_height);
    let block_hash = test_utils::standalone::mocks::compute_block_hash(runner.env.block_height);
    let transaction = test_utils::transfer(
        recipient_address,
        transfer_amount,
        signer.use_nonce().into(),
    );
    let signed_transaction =
        test_utils::sign_transaction(transaction, Some(runner.chain_id), &signer.secret_key);
    let eth_transaction =
        crate::prelude::transactions::EthTransactionKind::Legacy(signed_transaction);

    let transaction_message = sync::types::TransactionMessage {
        block_hash,
        near_receipt_id: H256([8u8; 32]),
        position: 0,
        succeeded: true,
        signer: runner.env.signer_account_id(),
        caller: runner.env.predecessor_account_id(),
        attached_near: 0,
        transaction: sync::types::TransactionKind::Submit(eth_transaction),
        promise_data: Vec::new(),
    };

    sync::consume_message(
        &mut runner.storage,
        sync::types::Message::Transaction(Box::new(transaction_message)),
    )
    .unwrap();

    assert_eq!(runner.get_balance(&recipient_address), transfer_amount);
    assert_eq!(
        runner.get_balance(&signer_address),
        initial_balance - transfer_amount
    );
    assert_eq!(runner.get_nonce(&signer_address), U256::one());
}

fn mock_proof(recipient_address: Address, deposit_amount: Wei) -> aurora_engine::proof::Proof {
    let eth_custodian_address = test_utils::standalone::mocks::ETH_CUSTODIAN_ADDRESS;

    let fee = Fee::new(NEP141Wei::new(0));
    let message = ["aurora", ":", recipient_address.encode().as_str()].concat();
    let token_message_data: TokenMessageData =
        TokenMessageData::parse_event_message_and_prepare_token_message_data(&message, fee)
            .unwrap();

    let deposit_event = aurora_engine::deposit_event::DepositedEvent {
        eth_custodian_address,
        sender: Address::new(H160([0u8; 20])),
        token_message_data,
        amount: NEP141Wei::new(deposit_amount.raw().as_u128()),
        fee,
    };

    let event_schema = ethabi::Event {
        name: aurora_engine::deposit_event::DEPOSITED_EVENT.into(),
        inputs: aurora_engine::deposit_event::DepositedEvent::event_params(),
        anonymous: false,
    };
    let log_entry = aurora_engine::log_entry::LogEntry {
        address: eth_custodian_address.raw(),
        topics: vec![
            event_schema.signature(),
            // the sender is not important
            crate::prelude::H256::zero(),
        ],
        data: ethabi::encode(&[
            ethabi::Token::String(message),
            ethabi::Token::Uint(U256::from(deposit_event.amount.as_u128())),
            ethabi::Token::Uint(U256::from(deposit_event.fee.as_u128())),
        ]),
    };
    aurora_engine::proof::Proof {
        log_index: 1,
        // Only this field matters for the purpose of this test
        log_entry_data: rlp::encode(&log_entry).to_vec(),
        receipt_index: 1,
        receipt_data: Vec::new(),
        header_data: Vec::new(),
        proof: Vec::new(),
    }
}

fn simple_transfer_args(
    dest_address: Address,
    transfer_amount: Wei,
) -> aurora_engine::parameters::CallArgs {
    aurora_engine::parameters::CallArgs::V2(aurora_engine::parameters::FunctionCallArgsV2 {
        contract: dest_address,
        value: transfer_amount.to_bytes(),
        input: Vec::new(),
    })
}

fn sample_block() -> sync::types::BlockMessage {
    let block_height = 101;
    let block_hash = test_utils::standalone::mocks::compute_block_hash(block_height);

    sync::types::BlockMessage {
        height: block_height,
        hash: block_hash,
        metadata: engine_standalone_storage::BlockMetadata {
            timestamp: Timestamp::new(1_000_001),
            random_seed: H256([2u8; 32]),
        },
    }
}

fn initialize() -> (StandaloneRunner, sync::types::BlockMessage) {
    let mut runner = StandaloneRunner::default();
    runner.init_evm();

    let block_message = sample_block();
    sync::consume_message(
        &mut runner.storage,
        sync::types::Message::Block(block_message.clone()),
    )
    .unwrap();

    let env = test_utils::standalone::mocks::default_env(block_message.height);
    runner.env = env;

    (runner, block_message)
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/standalone/tracing.rs ---
use aurora_engine_sdk::env::Env;
use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::{H256, U256};
use engine_standalone_tracing::{sputnik, types::TransactionTrace};
use serde::Deserialize;
use std::path::Path;

use crate::test_utils::{self, standalone};

/// This test replays two transactions from Ethereum mainnet (listed below) and checks we obtain
/// the same gas usage and transaction trace as reported by etherscan.
/// Transactions:
/// * https://etherscan.io/tx/0x79f7f8f9b3ad98f29a3df5cbed1556397089701c3ce007c2844605849dfb0ad4
/// * https://etherscan.io/tx/0x33db52b0e7fa03cd84e8c99fea90a1962b4f8d0e63c8bbe4c11373a233dc4f0e
/// Traces:
/// * https://etherscan.io/vmtrace?txhash=0x79f7f8f9b3ad98f29a3df5cbed1556397089701c3ce007c2844605849dfb0ad4
/// * https://etherscan.io/vmtrace?txhash=0x33db52b0e7fa03cd84e8c99fea90a1962b4f8d0e63c8bbe4c11373a233dc4f0e
#[test]
fn test_evm_tracing_with_storage() {
    let mut runner = standalone::StandaloneRunner::default();
    let mut signer = test_utils::Signer::random();
    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);
    let sender_address = Address::decode("304ee8ae14eceb3a544dff53a27eb1bb1aaa471f").unwrap();
    let weth_address = Address::decode("c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2").unwrap();

    // Initialize EVM
    runner.init_evm_with_chain_id(1);
    runner.mint_account(signer_address, Wei::zero(), signer.nonce.into(), None);

    // Deploy WETH contract
    let weth_constructor = test_utils::weth::WethConstructor::load();
    let deploy_tx = weth_constructor.deploy(signer.use_nonce().into());
    let result = runner
        .submit_transaction(&signer.secret_key, deploy_tx)
        .unwrap();
    let contract_address =
        Address::try_from_slice(test_utils::unwrap_success_slice(&result)).unwrap();

    // Move it over to the same address as it exists on mainnet
    let mut diff = engine_standalone_storage::Diff::default();
    for (key, value) in runner.get_current_state().iter() {
        if key.len() >= 22 && &key[2..22] == contract_address.as_bytes() {
            let mut new_key = key.clone();
            new_key[2..22].copy_from_slice(weth_address.as_bytes());
            match value {
                engine_standalone_storage::diff::DiffValue::Modified(bytes) => {
                    diff.modify(new_key, bytes.clone())
                }
                engine_standalone_storage::diff::DiffValue::Deleted => diff.delete(new_key),
            }
        }
    }
    runner.env.block_height += 1;
    let block_height = runner.env.block_height;
    let block_hash = test_utils::standalone::mocks::compute_block_hash(block_height);
    let block_metadata = engine_standalone_storage::BlockMetadata {
        timestamp: runner.env.block_timestamp(),
        random_seed: runner.env.random_seed(),
    };
    runner
        .storage
        .set_block_data(block_hash, block_height, block_metadata)
        .unwrap();
    let tx = engine_standalone_storage::sync::TransactionIncludedOutcome {
        hash: H256::zero(),
        info: engine_standalone_storage::sync::types::TransactionMessage {
            block_hash,
            near_receipt_id: H256::zero(),
            position: 0,
            succeeded: true,
            signer: "system".parse().unwrap(),
            caller: "system".parse().unwrap(),
            attached_near: 0,
            transaction: engine_standalone_storage::sync::types::TransactionKind::Unknown,
            promise_data: Vec::new(),
        },
        diff,
        maybe_result: Ok(None),
    };
    test_utils::standalone::storage::commit(&mut runner.storage, &tx);

    // Replay transaction depositing some ETH to get WETH (for the first time)
    // tx: https://etherscan.io/tx/0x79f7f8f9b3ad98f29a3df5cbed1556397089701c3ce007c2844605849dfb0ad4
    let tx_nonce = U256::from(2);
    let tx_bytes = hex::decode(MAINNET_TX_79F7F8F9).unwrap();
    runner.mint_account(
        sender_address,
        Wei::from_eth(2.into()).unwrap(),
        tx_nonce,
        None,
    );
    let mut listener = sputnik::TransactionTraceBuilder::default();
    let result = sputnik::traced_call(&mut listener, || {
        runner.submit_raw_transaction_bytes(&tx_bytes).unwrap()
    });
    assert!(result.status.is_ok());
    assert_eq!(result.gas_used, 45_038);

    // Check trace
    check_transaction_trace(
        listener.finish(),
        "src/tests/res/79f7f8f9b3ad98f29a3df5cbed1556397089701c3ce007c2844605849dfb0ad4_trace.json",
    );

    // Replay transaction depositing some ETH to get WETH (for the second time)
    // tx: https://etherscan.io/tx/0x33db52b0e7fa03cd84e8c99fea90a1962b4f8d0e63c8bbe4c11373a233dc4f0e
    let tx_nonce = U256::from(14);
    let tx_bytes = hex::decode(MAINNET_TX_33DB52B0).unwrap();
    runner.mint_account(
        sender_address,
        Wei::from_eth(2.into()).unwrap(),
        tx_nonce,
        None,
    );
    let mut listener = sputnik::TransactionTraceBuilder::default();
    let result = sputnik::traced_call(&mut listener, || {
        runner.submit_raw_transaction_bytes(&tx_bytes).unwrap()
    });
    assert!(result.status.is_ok());
    assert_eq!(result.gas_used, 27_938);

    // Check trace
    check_transaction_trace(
        listener.finish(),
        "src/tests/res/33db52b0e7fa03cd84e8c99fea90a1962b4f8d0e63c8bbe4c11373a233dc4f0e_trace.json",
    );
}

/// Test based on expected trace of
/// https://rinkeby.etherscan.io/tx/0xfc9359e49278b7ba99f59edac0e3de49956e46e530a53c15aa71226b7aa92c6f
/// (geth example found at https://gist.github.com/karalabe/c91f95ac57f5e57f8b950ec65ecc697f).
#[test]
fn test_evm_tracing() {
    let mut runner = standalone::StandaloneRunner::default();
    let mut signer = test_utils::Signer::random();

    // Initialize EVM
    runner.init_evm();

    // Deploy contract
    let deploy_tx = aurora_engine_transactions::legacy::TransactionLegacy {
        nonce: signer.use_nonce().into(),
        gas_price: U256::zero(),
        gas_limit: u64::MAX.into(),
        to: None,
        value: Wei::zero(),
        data: hex::decode(CONTRACT_CODE).unwrap(),
    };
    let result = runner
        .submit_transaction(&signer.secret_key, deploy_tx)
        .unwrap();
    let contract_address =
        Address::try_from_slice(test_utils::unwrap_success_slice(&result)).unwrap();

    // Interact with contract (and trace execution)
    let tx = aurora_engine_transactions::legacy::TransactionLegacy {
        nonce: signer.use_nonce().into(),
        gas_price: U256::zero(),
        gas_limit: 90_000.into(),
        to: Some(contract_address),
        value: Wei::zero(),
        data: hex::decode(CONTRACT_INPUT).unwrap(),
    };
    let mut listener = sputnik::TransactionTraceBuilder::default();
    let result = sputnik::traced_call(&mut listener, || {
        runner.submit_transaction(&signer.secret_key, tx).unwrap()
    });
    assert!(result.status.is_ok());

    // Check trace
    let trace = listener.finish();
    let positions: Vec<u8> = trace
        .logs()
        .0
        .iter()
        .map(|l| l.program_counter.into_u32() as u8)
        .collect();
    assert_eq!(positions.as_slice(), &EXPECTED_POSITIONS);

    let costs: Vec<u32> = trace
        .logs()
        .0
        .iter()
        .map(|l| l.gas_cost.as_u64() as u32)
        .collect();
    assert_eq!(costs.as_slice(), &EXPECTED_COSTS);

    let op_codes: Vec<u8> = trace.logs().0.iter().map(|l| l.opcode.0).collect();
    assert_eq!(op_codes.as_slice(), &EXPECTED_OP_CODES);
}

const MAINNET_TX_79F7F8F9: &str = "02f87701028459682f00851fb8b1884182afee94c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2880c7d713b49da000084d0e30db0c080a0b1bf69eab31f6d5482f0f8a48f8fcda916db162e0b874d523293c29246e30ed4a03b79f1f9ccbc4fd6beb9809343eadfe1ddafbc0c7b8673aff2cad5bf3345c227";
const MAINNET_TX_33DB52B0: &str = "02f877010e845d57122a85135bb40f4c826d2294c02aaa39b223fe8d0a0e5c4f27ead9083c756cc28805ebc9f935949db384d0e30db0c001a0956288989306881d6e400d6b40cf06d1210a87d71e8dc4179a3e1a37890ae318a06cbbffed3e749cf9c56de8f8db6ec3df62dbebe2e0b007d020de0b27c05db064";
const CONTRACT_CODE: &str = "60606040525b60008054600160a060020a03191633600160a060020a0316179055346001555b5b61011e806100356000396000f3006060604052361560465763ffffffff7c010000000000000000000000000000000000000000000000000000000060003504166383197ef08114604a5780638da5cb5b14605c575b5b5b005b3415605457600080fd5b60466095565b005b3415606657600080fd5b606c60d6565b60405173ffffffffffffffffffffffffffffffffffffffff909116815260200160405180910390f35b6000543373ffffffffffffffffffffffffffffffffffffffff9081169116141560d35760005473ffffffffffffffffffffffffffffffffffffffff16ff5b5b565b60005473ffffffffffffffffffffffffffffffffffffffff16815600a165627a7a7230582080eeb07bf95bf0cca20d03576cbb3a25de3bd0d1275c173d370dcc90ce23158d0029";
const CONTRACT_INPUT: &str = "2df07fbaabbe40e3244445af30759352e348ec8bebd4dd75467a9f29ec55d98d6cf6c418de0e922b1c55be39587364b88224451e7901d10a4a2ee2eeab3cccf51c";
const EXPECTED_POSITIONS: [u8; 27] = [
    0, 2, 4, 5, 6, 7, 9, 10, 15, 45, 47, 48, 49, 50, 55, 56, 57, 59, 60, 61, 66, 67, 69, 70, 71,
    72, 73,
];
const EXPECTED_COSTS: [u32; 27] = [
    3, 3, 12, 2, 3, 3, 10, 3, 3, 3, 3, 5, 3, 3, 3, 3, 3, 10, 3, 3, 3, 3, 10, 1, 1, 1, 0,
];
const EXPECTED_OP_CODES: [u8; 27] = [
    96, 96, 82, 54, 21, 96, 87, 99, 124, 96, 53, 4, 22, 99, 129, 20, 96, 87, 128, 99, 20, 96, 87,
    91, 91, 91, 0,
];

fn check_transaction_trace<P: AsRef<Path>>(trace: TransactionTrace, expected_trace_path: P) {
    let expected_trace: Vec<EtherscanTraceStep> = {
        let file = std::fs::File::open(expected_trace_path).unwrap();
        let reader = std::io::BufReader::new(file);
        serde_json::from_reader(reader).unwrap()
    };

    assert_eq!(trace.logs().0.len(), expected_trace.len());
    for (log, step) in trace.logs().0.iter().zip(expected_trace.into_iter()) {
        assert_eq!(
            log.program_counter.0, step.pc,
            "Program counters should match"
        );
        assert_eq!(log.depth.into_u32(), step.depth, "Depths should match");
        assert_eq!(log.opcode.as_u8(), step.op, "opcodes should match");
        assert_eq!(
            log.gas_cost.as_u64(),
            step.gas_cost,
            "gas costs should match"
        );
    }
}

#[derive(Debug, Deserialize, PartialEq, Eq, Clone)]
struct EtherscanTraceStep {
    pub step: u32,
    pub pc: u32,
    pub op: u8,
    pub gas: u64,
    pub gas_cost: u64,
    pub depth: u32,
    pub opcode_name: String,
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/standard_precompiles.rs ---
use crate::prelude::Wei;
use crate::test_utils::{
    self,
    standard_precompiles::{PrecompilesConstructor, PrecompilesContract},
    AuroraRunner, ExecutionProfile, Signer,
};

const INITIAL_BALANCE: Wei = Wei::new_u64(1000);
const INITIAL_NONCE: u64 = 0;

fn precompile_execution_profile(method: &str) -> ExecutionProfile {
    let (mut runner, mut signer, contract) = initialize();
    let (_result, profile) = runner
        .submit_with_signer_profiled(&mut signer, |nonce| contract.call_method(method, nonce))
        .unwrap();
    profile
}

#[test]
fn test_standard_precompiles() {
    let (mut runner, mut signer, contract) = initialize();

    let outcome = runner
        .submit_with_signer(&mut signer, |nonce| contract.call_method("test_all", nonce))
        .unwrap();

    test_utils::panic_on_fail(outcome.status);
}

#[test]
fn profile_ecrecover() {
    let profile = precompile_execution_profile("test_ecrecover");
    test_utils::assert_gas_bound(profile.all_gas(), 6);
}

#[test]
fn profile_sha256() {
    let profile = precompile_execution_profile("test_sha256");
    test_utils::assert_gas_bound(profile.all_gas(), 5);
}

#[test]
fn profile_ripemd160() {
    let profile = precompile_execution_profile("test_ripemd160");
    test_utils::assert_gas_bound(profile.all_gas(), 5);
}

#[test]
fn profile_identity() {
    let profile = precompile_execution_profile("test_identity");
    test_utils::assert_gas_bound(profile.all_gas(), 5);
}

#[test]
fn profile_modexp() {
    let profile = precompile_execution_profile("test_modexp");
    test_utils::assert_gas_bound(profile.all_gas(), 8);
}

#[test]
fn profile_ecadd() {
    let profile = precompile_execution_profile("test_ecadd");
    test_utils::assert_gas_bound(profile.all_gas(), 5);
}

#[test]
fn profile_ecmul() {
    let profile = precompile_execution_profile("test_ecmul");
    test_utils::assert_gas_bound(profile.all_gas(), 6);
}

#[test]
fn profile_ecpair() {
    let profile = precompile_execution_profile("test_ecpair");
    test_utils::assert_gas_bound(profile.all_gas(), 102);
}

#[test]
fn profile_blake2f() {
    let profile = precompile_execution_profile("test_blake2f");
    test_utils::assert_gas_bound(profile.all_gas(), 6);
}

fn initialize() -> (AuroraRunner, Signer, PrecompilesContract) {
    let mut runner = test_utils::deploy_evm();
    let mut signer = Signer::random();
    signer.nonce = INITIAL_NONCE;
    runner.create_address(
        test_utils::address_from_secret_key(&signer.secret_key),
        INITIAL_BALANCE,
        INITIAL_NONCE.into(),
    );

    let constructor = PrecompilesConstructor::load();
    let nonce = signer.use_nonce();
    let contract = PrecompilesContract(runner.deploy_contract(
        &signer.secret_key,
        |c| c.deploy(nonce.into()),
        constructor,
    ));

    (runner, signer, contract)
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/state_migration.rs ---
use crate::prelude::U256;
use crate::test_utils::{self, str_to_account_id, AuroraRunner};
use aurora_engine::parameters::{InitCallArgs, NewCallArgs};
use borsh::BorshSerialize;
use near_sdk_sim::{ExecutionResult, UserAccount};
use std::fs;
use std::path::Path;

#[test]
fn test_state_migration() {
    let aurora = deploy_evm();

    // do upgrade
    let upgraded_contract_bytes = contract_bytes();
    aurora
        .call("stage_upgrade", &upgraded_contract_bytes)
        .assert_success();
    aurora.call("deploy_upgrade", &[]).assert_success();

    // upgraded contract as some_new_fancy_function
    let result = aurora.call("some_new_fancy_function", &[]);
    result.assert_success();
    let some_numbers: [u32; 7] = result.unwrap_borsh();
    assert_eq!(some_numbers, [3, 1, 4, 1, 5, 9, 2]);
}

pub fn deploy_evm() -> AuroraAccount {
    let aurora_runner = AuroraRunner::default();
    let main_account = near_sdk_sim::init_simulator(None);
    let sim_aurora_account = format!(
        "{}.{}",
        aurora_runner.aurora_account_id,
        main_account.account_id()
    );
    let contract_account = main_account.deploy(
        aurora_runner.code.code(),
        sim_aurora_account.parse().unwrap(),
        5 * near_sdk_sim::STORAGE_AMOUNT,
    );
    let prover_account = str_to_account_id("prover.near");
    let new_args = NewCallArgs {
        chain_id: crate::prelude::u256_to_arr(&U256::from(aurora_runner.chain_id)),
        owner_id: str_to_account_id(main_account.account_id.as_str()),
        bridge_prover_id: prover_account.clone(),
        upgrade_delay_blocks: 1,
    };
    main_account
        .call(
            contract_account.account_id.clone(),
            "new",
            &new_args.try_to_vec().unwrap(),
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
        .assert_success();
    let init_args = InitCallArgs {
        prover_account,
        eth_custodian_address: "d045f7e19B2488924B97F9c145b5E51D0D895A65".to_string(),
        metadata: Default::default(),
    };
    contract_account
        .call(
            contract_account.account_id.clone(),
            "new_eth_connector",
            &init_args.try_to_vec().unwrap(),
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
        .assert_success();
    AuroraAccount {
        user: main_account,
        contract: contract_account,
    }
}

pub struct AuroraAccount {
    pub user: UserAccount,
    pub contract: UserAccount,
}

impl AuroraAccount {
    pub fn call(&self, method: &str, args: &[u8]) -> ExecutionResult {
        self.user.call(
            self.contract.account_id.clone(),
            method,
            args,
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
    }
}

fn contract_bytes() -> Vec<u8> {
    let base_path = Path::new("../etc")
        .join("tests")
        .join("state-migration-test");
    let output_path = base_path
        .join("target/wasm32-unknown-unknown/release/aurora_engine_state_migration_test.wasm");
    test_utils::rust::compile(base_path);
    fs::read(output_path).unwrap()
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/uniswap.rs ---
use crate::prelude::{Address, U256};
use crate::test_utils::{
    self,
    erc20::{ERC20Constructor, ERC20},
    uniswap::{
        ExactInputParams, ExactOutputSingleParams, Factory, FactoryConstructor, MintParams, Pool,
        PositionManager, PositionManagerConstructor, SwapRouter, SwapRouterConstructor,
    },
    AuroraRunner, ExecutionProfile, Signer,
};
use aurora_engine_types::types::Wei;
use aurora_engine_types::H160;
use libsecp256k1::SecretKey;
use rand::SeedableRng;

const INITIAL_BALANCE: u64 = 1000;
const INITIAL_NONCE: u64 = 0;
// The "fee" can only be specific values, see
// https://github.com/Uniswap/uniswap-v3-core/blob/main/contracts/UniswapV3Factory.sol#L26
const POOL_FEE: u64 = 500;
const MINT_AMOUNT: u64 = 1_000_000_000_000;
const LIQUIDITY_AMOUNT: u64 = MINT_AMOUNT / 5;
const OUTPUT_AMOUNT: u64 = LIQUIDITY_AMOUNT / 100;
const INPUT_AMOUNT: u64 = LIQUIDITY_AMOUNT / 100;

#[test]
fn test_uniswap_input_multihop() {
    let mut context = UniswapTestContext::new("uniswap");

    // evm_gas = 970k
    // near total gas = 122 Tgas

    let tokens = context.create_tokens(10, MINT_AMOUNT.into());
    for (token_a, token_b) in tokens.iter().zip(tokens.iter().skip(1)) {
        context.create_pool(token_a, token_b);
        context.add_equal_liquidity(LIQUIDITY_AMOUNT.into(), token_a, token_b);
    }

    let (_amount_out, _evm_gas, profile) = context.exact_input(&tokens, INPUT_AMOUNT.into());

    assert_eq!(113, profile.all_gas() / 1_000_000_000_000);
}

#[test]
fn test_uniswap_exact_output() {
    let mut context = UniswapTestContext::new("uniswap");
    let (token_a, token_b) = context.create_token_pair(MINT_AMOUNT.into());
    let _pool = context.create_pool(&token_a, &token_b);

    let (_result, profile) =
        context.add_equal_liquidity(LIQUIDITY_AMOUNT.into(), &token_a, &token_b);
    test_utils::assert_gas_bound(profile.all_gas(), 32);
    let wasm_fraction = 100 * profile.wasm_gas() / profile.all_gas();
    assert!(
        (40..=50).contains(&wasm_fraction),
        "{}% is not between 40% and 50%",
        wasm_fraction
    );

    let (_amount_in, profile) =
        context.exact_output_single(&token_a, &token_b, OUTPUT_AMOUNT.into());
    test_utils::assert_gas_bound(profile.all_gas(), 17);
    let wasm_fraction = 100 * profile.wasm_gas() / profile.all_gas();
    assert!(
        (45..=55).contains(&wasm_fraction),
        "{}% is not between 45% and 55%",
        wasm_fraction
    );
}

#[derive(Debug, Copy, Clone, PartialEq, Eq)]
pub(crate) struct LiquidityResult {
    pub token_id: U256,
    pub liquidity: U256,
    pub amount0: U256,
    pub amount1: U256,
}

pub(crate) struct UniswapTestContext {
    pub factory: Factory,
    pub manager: PositionManager,
    pub swap_router: SwapRouter,
    pub signer: Signer,
    pub runner: AuroraRunner,
    pub name: String,
}

impl UniswapTestContext {
    pub fn new(name: &str) -> Self {
        let mut runner = test_utils::deploy_evm();
        let mut rng = rand::rngs::StdRng::seed_from_u64(414243);
        let source_account = SecretKey::random(&mut rng);
        let source_address = test_utils::address_from_secret_key(&source_account);
        runner.create_address(
            source_address,
            Wei::new_u64(INITIAL_BALANCE),
            INITIAL_NONCE.into(),
        );

        let mut signer = Signer {
            nonce: INITIAL_NONCE,
            secret_key: source_account,
        };

        let nonce = signer.use_nonce();
        let factory = Factory(runner.deploy_contract(
            &signer.secret_key,
            |c| c.deploy(nonce.into()),
            FactoryConstructor::load(),
        ));

        let wrapped_eth = Self::create_token_with_runner(
            "Wrapped Ether",
            "WETH",
            U256::MAX,
            &mut runner,
            &mut signer,
        );
        let weth_address = wrapped_eth.0.address;

        let nonce = signer.use_nonce();
        let manager = PositionManager(runner.deploy_contract(
            &signer.secret_key,
            |c| {
                c.deploy(
                    factory.0.address,
                    weth_address,
                    Address::new(H160([0; 20])),
                    nonce.into(),
                )
            },
            PositionManagerConstructor::load(),
        ));

        let nonce = signer.use_nonce();
        let swap_router = SwapRouter(runner.deploy_contract(
            &signer.secret_key,
            |c| c.deploy(factory.0.address, weth_address, nonce.into()),
            SwapRouterConstructor::load(),
        ));

        Self {
            factory,
            manager,
            swap_router,
            signer,
            runner,
            name: String::from(name),
        }
    }

    pub fn no_gas(&mut self) {
        self.runner.wasm_config.regular_op_cost = 0;
    }

    pub fn create_tokens(&mut self, n: usize, mint_amount: U256) -> Vec<ERC20> {
        let names = ('a'..='z').into_iter().map(|c| format!("token_{}", c));
        let symbols = ('A'..='Z').into_iter().map(|c| format!("{}{}{}", c, c, c));
        let mut result: Vec<ERC20> = names
            .zip(symbols)
            .take(n)
            .map(|(name, symbol)| self.create_token(&name, &symbol, mint_amount))
            .collect();
        result.sort_by_key(|t| t.0.address);
        result
    }

    pub fn create_token_pair(&mut self, mint_amount: U256) -> (ERC20, ERC20) {
        let token_a = self.create_token("token_a", "A", mint_amount);
        let token_b = self.create_token("token_b", "B", mint_amount);

        if token_a.0.address < token_b.0.address {
            (token_a, token_b)
        } else {
            (token_b, token_a)
        }
    }

    pub fn create_pool(&mut self, token_a: &ERC20, token_b: &ERC20) -> Pool {
        let token_a = token_a.0.address;
        let token_b = token_b.0.address;
        let factory = &self.factory;
        let result = self
            .runner
            .submit_with_signer(&mut self.signer, |nonce| {
                factory.create_pool(token_a, token_b, POOL_FEE.into(), nonce)
            })
            .unwrap();
        assert!(result.status.is_ok(), "Failed to create pool");

        let address = Address::try_from_slice(&test_utils::unwrap_success(result)[12..]).unwrap();
        let pool = Pool::from_address(address);

        // 2^96 corresponds to a price ratio of 1
        let result = self
            .runner
            .submit_with_signer(&mut self.signer, |nonce| {
                pool.initialize(U256::from(2).pow(U256::from(96)), nonce)
            })
            .unwrap();
        assert!(result.status.is_ok(), "Failed to initialize pool");

        pool
    }

    pub fn mint_params(&self, amount: U256, token_a: &ERC20, token_b: &ERC20) -> MintParams {
        let token0 = std::cmp::min(token_a.0.address, token_b.0.address);
        let token1 = std::cmp::max(token_a.0.address, token_b.0.address);

        MintParams {
            token0,
            token1,
            fee: POOL_FEE,
            tick_lower: -1000,
            tick_upper: 1000,
            amount0_desired: amount,
            amount1_desired: amount,
            amount0_min: U256::one(),
            amount1_min: U256::one(),
            recipient: test_utils::address_from_secret_key(&self.signer.secret_key),
            deadline: U256::MAX, // no deadline
        }
    }

    pub fn add_equal_liquidity(
        &mut self,
        amount: U256,
        token_a: &ERC20,
        token_b: &ERC20,
    ) -> (LiquidityResult, ExecutionProfile) {
        self.approve_erc20(token_a, self.manager.0.address, U256::MAX);
        self.approve_erc20(token_b, self.manager.0.address, U256::MAX);

        let params = self.mint_params(amount, token_a, token_b);

        let manager = &self.manager;
        let (result, profile) = self
            .runner
            .submit_with_signer_profiled(&mut self.signer, |nonce| manager.mint(params, nonce))
            .unwrap();
        assert!(result.status.is_ok());

        let result = {
            let mut values = [U256::zero(); 4];
            let result_bytes = test_utils::unwrap_success(result);
            for (i, item) in values.iter_mut().enumerate() {
                let lower = i * 32;
                let upper = (i + 1) * 32;
                let value = U256::from_big_endian(&result_bytes[lower..upper]);
                *item = value;
            }
            LiquidityResult {
                token_id: values[0],
                liquidity: values[1],
                amount0: values[2],
                amount1: values[3],
            }
        };
        assert_eq!(result.amount0, amount);
        assert_eq!(result.amount1, amount);

        (result, profile)
    }

    pub fn exact_input_params(&self, amount_in: U256, token_path: &[ERC20]) -> ExactInputParams {
        let path = token_path
            .iter()
            .skip(1)
            .map(|t| (POOL_FEE, t.0.address))
            .collect();
        ExactInputParams {
            token_in: token_path[0].0.address,
            path,

            recipient: Address::new(H160([0; 20])),
            deadline: U256::MAX,
            amount_in,
            amount_out_min: U256::one(),
        }
    }

    pub fn exact_input(
        &mut self,
        token_path: &[ERC20],
        amount_in: U256,
    ) -> (U256, u64, ExecutionProfile) {
        for token in token_path.iter() {
            self.approve_erc20(token, self.swap_router.0.address, U256::MAX);
        }
        let params = self.exact_input_params(amount_in, token_path);
        let swap_router = &self.swap_router;
        let (result, profile) = self
            .runner
            .submit_with_signer_profiled(&mut self.signer, |nonce| {
                swap_router.exact_input(params, nonce)
            })
            .unwrap();
        assert!(result.status.is_ok(), "Swap failed");

        let evm_gas = result.gas_used;
        let amount_out = U256::from_big_endian(&test_utils::unwrap_success(result));
        (amount_out, evm_gas, profile)
    }

    pub fn exact_output_single_params(
        &self,
        amount_out: U256,
        token_in: &ERC20,
        token_out: &ERC20,
    ) -> ExactOutputSingleParams {
        ExactOutputSingleParams {
            token_in: token_in.0.address,
            token_out: token_out.0.address,
            fee: POOL_FEE,

            recipient: Address::new(H160([0; 20])),
            deadline: U256::MAX,
            amount_out,
            amount_in_max: U256::from(100) * amount_out,
            price_limit: U256::zero(),
        }
    }

    pub fn exact_output_single(
        &mut self,
        token_in: &ERC20,
        token_out: &ERC20,
        amount_out: U256,
    ) -> (U256, ExecutionProfile) {
        self.approve_erc20(token_in, self.swap_router.0.address, U256::MAX);
        self.approve_erc20(token_out, self.swap_router.0.address, U256::MAX);

        let params = self.exact_output_single_params(amount_out, token_in, token_out);
        let swap_router = &self.swap_router;
        let (result, profile) = self
            .runner
            .submit_with_signer_profiled(&mut self.signer, |nonce| {
                swap_router.exact_output_single(params, nonce)
            })
            .unwrap();
        assert!(result.status.is_ok(), "Swap failed");

        let amount_in = U256::from_big_endian(&test_utils::unwrap_success(result));
        assert!(amount_in >= amount_out);

        (amount_in, profile)
    }

    pub fn approve_erc20(&mut self, token: &ERC20, spender: Address, amount: U256) {
        let result = self
            .runner
            .submit_with_signer(&mut self.signer, |nonce| {
                token.approve(spender, amount, nonce)
            })
            .unwrap();
        assert!(result.status.is_ok(), "Failed to approve ERC-20");
    }

    fn create_token(&mut self, name: &str, symbol: &str, mint_amount: U256) -> ERC20 {
        Self::create_token_with_runner(
            name,
            symbol,
            mint_amount,
            &mut self.runner,
            &mut self.signer,
        )
    }

    fn create_token_with_runner(
        name: &str,
        symbol: &str,
        mint_amount: U256,
        runner: &mut AuroraRunner,
        signer: &mut Signer,
    ) -> ERC20 {
        let nonce = signer.use_nonce();
        let contract = ERC20(runner.deploy_contract(
            &signer.secret_key,
            |c| c.deploy(name, symbol, nonce.into()),
            ERC20Constructor::load(),
        ));

        let nonce = signer.use_nonce();
        let mint_tx = contract.mint(
            test_utils::address_from_secret_key(&signer.secret_key),
            mint_amount,
            nonce.into(),
        );
        let result = runner
            .submit_transaction(&signer.secret_key, mint_tx)
            .unwrap();
        assert!(result.status.is_ok(), "Minting ERC-20 tokens failed");

        contract
    }
}

'''
'''--- aurora-engine-2.8.1/engine-tests/src/tests/xcc.rs ---
use crate::test_utils::erc20::{ERC20Constructor, ERC20};
use crate::test_utils::{self, AuroraRunner};
use crate::tests::erc20_connector::sim_tests;
use crate::tests::state_migration::{deploy_evm, AuroraAccount};
use aurora_engine_precompiles::xcc::{self, costs, cross_contract_call};
use aurora_engine_transactions::legacy::TransactionLegacy;
use aurora_engine_types::account_id::AccountId;
use aurora_engine_types::parameters::{
    CrossContractCallArgs, NearPromise, PromiseArgs, PromiseCreateArgs, PromiseWithCallbackArgs,
    SimpleNearPromise,
};
use aurora_engine_types::types::{Address, EthGas, NearGas, Wei, Yocto};
use aurora_engine_types::U256;
use borsh::{BorshDeserialize, BorshSerialize};
use near_primitives::transaction::Action;
use near_primitives_core::contract::ContractCode;
use near_sdk_sim::UserAccount;
use serde_json::json;
use std::fs;
use std::path::Path;

const WNEAR_AMOUNT: u128 = 10 * near_sdk_sim::STORAGE_AMOUNT;

#[test]
fn test_xcc_eth_gas_cost() {
    let mut runner = test_utils::deploy_evm();
    runner.standalone_runner = None;
    let xcc_wasm_bytes = contract_bytes();
    let _ = runner.call("factory_update", "aurora", xcc_wasm_bytes);
    let mut signer = test_utils::Signer::random();
    let mut baseline_signer = test_utils::Signer::random();
    runner.context.block_index = aurora_engine::engine::ZERO_ADDRESS_FIX_HEIGHT + 1;
    // Need to use engine's deploy!
    let wnear_erc20 = deploy_erc20(&mut runner, &mut signer);
    approve_erc20(
        &wnear_erc20,
        cross_contract_call::ADDRESS,
        &mut runner,
        &mut signer,
    );
    approve_erc20(
        &wnear_erc20,
        test_utils::address_from_secret_key(&baseline_signer.secret_key),
        &mut runner,
        &mut signer,
    );
    let _ = runner.call(
        "factory_set_wnear_address",
        "aurora",
        wnear_erc20.0.address.as_bytes().to_vec(),
    );

    // Baseline transaction is an ERC-20 transferFrom call since such a call is included as part
    // of the precompile execution, but we want to isolate just the precompile logic itself
    // (the EVM subcall is charged separately).
    let (baseline_result, baseline) = runner
        .submit_with_signer_profiled(&mut baseline_signer, |nonce| {
            wnear_erc20.transfer_from(
                test_utils::address_from_secret_key(&signer.secret_key),
                Address::from_array([1u8; 20]),
                U256::from(near_sdk_sim::STORAGE_AMOUNT),
                nonce,
            )
        })
        .unwrap();
    if !baseline_result.status.is_ok() {
        panic!("Unexpected baseline status: {:?}", baseline_result);
    }

    let mut profile_for_promise = |p: PromiseArgs| -> (u64, u64, u64) {
        let data = CrossContractCallArgs::Eager(p).try_to_vec().unwrap();
        let input_length = data.len();
        let (submit_result, profile) = runner
            .submit_with_signer_profiled(&mut signer, |nonce| TransactionLegacy {
                nonce,
                gas_price: U256::zero(),
                gas_limit: u64::MAX.into(),
                to: Some(cross_contract_call::ADDRESS),
                value: Wei::zero(),
                data,
            })
            .unwrap();
        assert!(submit_result.status.is_ok());
        // Subtract off baseline transaction to isolate just precompile things
        (
            u64::try_from(input_length).unwrap(),
            profile.all_gas() - baseline.all_gas(),
            submit_result.gas_used,
        )
    };

    let promise = PromiseCreateArgs {
        target_account_id: "some_account.near".parse().unwrap(),
        method: "some_method".into(),
        args: b"hello_world".to_vec(),
        attached_balance: Yocto::new(56),
        attached_gas: NearGas::new(500),
    };
    // Shorter input
    let (x1, y1, evm1) = profile_for_promise(PromiseArgs::Create(promise.clone()));
    // longer input
    let (x2, y2, evm2) = profile_for_promise(PromiseArgs::Callback(PromiseWithCallbackArgs {
        base: promise.clone(),
        callback: promise,
    }));

    // NEAR costs (inferred from a line through (x1, y1) and (x2, y2))
    let xcc_cost_per_byte = (y2 - y1) / (x2 - x1);
    let xcc_base_cost = NearGas::new(y1 - xcc_cost_per_byte * x1);

    // Convert to EVM cost using conversion ratio
    let xcc_base_cost = EthGas::new(xcc_base_cost.as_u64() / costs::CROSS_CONTRACT_CALL_NEAR_GAS);
    let xcc_cost_per_byte = xcc_cost_per_byte / costs::CROSS_CONTRACT_CALL_NEAR_GAS;

    assert!(
        test_utils::within_x_percent(
            5,
            xcc_base_cost.as_u64(),
            costs::CROSS_CONTRACT_CALL_BASE.as_u64()
        ),
        "Incorrect xcc base cost. Expected: {} Actual: {}",
        xcc_base_cost,
        costs::CROSS_CONTRACT_CALL_BASE
    );

    assert!(
        test_utils::within_x_percent(
            5,
            xcc_cost_per_byte,
            costs::CROSS_CONTRACT_CALL_BYTE.as_u64()
        ),
        "Incorrect xcc per byte cost. Expected: {} Actual: {}",
        xcc_cost_per_byte,
        costs::CROSS_CONTRACT_CALL_BYTE
    );

    // As a sanity check, confirm that the total EVM gas spent aligns with expectations.
    // The additional gas added is the amount attached to the XCC call (this is "used", but not
    // "burnt").
    let total_gas1 = y1 + baseline.all_gas() + costs::ROUTER_EXEC_BASE.as_u64();
    let total_gas2 = y2
        + baseline.all_gas()
        + costs::ROUTER_EXEC_BASE.as_u64()
        + costs::ROUTER_EXEC_PER_CALLBACK.as_u64();
    assert!(
        test_utils::within_x_percent(20, evm1, total_gas1 / costs::CROSS_CONTRACT_CALL_NEAR_GAS),
        "Incorrect EVM gas used. Expected: {} Actual: {}",
        evm1,
        total_gas1 / costs::CROSS_CONTRACT_CALL_NEAR_GAS
    );
    assert!(
        test_utils::within_x_percent(20, evm2, total_gas2 / costs::CROSS_CONTRACT_CALL_NEAR_GAS),
        "Incorrect EVM gas used. Expected: {} Actual: {}",
        evm2,
        total_gas2 / costs::CROSS_CONTRACT_CALL_NEAR_GAS
    );
}

#[test]
fn test_xcc_precompile_eager() {
    test_xcc_precompile_common(false)
}

#[test]
fn test_xcc_precompile_scheduled() {
    test_xcc_precompile_common(true)
}

/// This test uses the XCC feature where the promise has many nested callbacks.
/// The contract it uses is one which computes Fibonacci numbers in an inefficient way.
/// The contract has two functions: `seed` and `accumulate`.
/// The `seed` function always returns `{"a": "0", "b": "1"}`.
/// The `accumulate` function performs one step of the Fibonacci recursion relation using
/// a promise result (i.e. result from prior call) as input.
/// Therefore, we can compute Fibonacci numbers by creating a long chain of callbacks.
/// For example, to compute the 6th number:
/// `seed.then(accumulate).then(accumulate).then(accumulate).then(accumulate).then(accumulate)`.
#[test]
fn test_xcc_multiple_callbacks() {
    let XccTestContext {
        aurora,
        mut signer,
        signer_address,
        chain_id,
        ..
    } = init_xcc();

    // 1. Deploy Fibonacci contract
    let fib_account_id = deploy_fibonacci(&aurora);

    // 2. Create XCC account, schedule Fibonacci call
    let n = 6;
    let promise = make_fib_promise(n, &fib_account_id);
    let xcc_args = CrossContractCallArgs::Delayed(PromiseArgs::Recursive(promise));
    let _result = submit_xcc_transaction(xcc_args, &aurora, &mut signer, chain_id);

    // 3. Make Fibonacci call
    let router_account = format!(
        "{}.{}",
        hex::encode(signer_address.as_bytes()),
        aurora.contract.account_id.as_str()
    );
    let result = aurora.user.call(
        router_account.parse().unwrap(),
        "execute_scheduled",
        b"{\"nonce\": \"0\"}",
        near_sdk_sim::DEFAULT_GAS,
        0,
    );
    result.assert_success();

    // 4. Check the result is correct
    let output = result.unwrap_json_value();
    check_fib_result(output, n);
}

/// This test is similar to `test_xcc_multiple_callbacks`, but instead of computing
/// Fibonacci numbers through repeated callbacks, it uses the `And` promise combinator.
#[test]
fn test_xcc_and_combinator() {
    let XccTestContext {
        aurora,
        mut signer,
        signer_address,
        chain_id,
        ..
    } = init_xcc();

    // 1. Deploy Fibonacci contract
    let fib_account_id = deploy_fibonacci(&aurora);

    // 2. Create XCC account, schedule Fibonacci call
    let n = 6;
    let promise = NearPromise::Then {
        base: Box::new(NearPromise::And(vec![
            NearPromise::Simple(SimpleNearPromise::Create(PromiseCreateArgs {
                target_account_id: fib_account_id.clone(),
                method: "fib".into(),
                args: format!(r#"{{"n": {}}}"#, n - 1).into_bytes(),
                attached_balance: Yocto::new(0),
                attached_gas: NearGas::new(10_000_000_000_000_u64 * n),
            })),
            NearPromise::Simple(SimpleNearPromise::Create(PromiseCreateArgs {
                target_account_id: fib_account_id.clone(),
                method: "fib".into(),
                args: format!(r#"{{"n": {}}}"#, n - 2).into_bytes(),
                attached_balance: Yocto::new(0),
                attached_gas: NearGas::new(10_000_000_000_000_u64 * n),
            })),
        ])),
        callback: SimpleNearPromise::Create(PromiseCreateArgs {
            target_account_id: fib_account_id,
            method: "sum".into(),
            args: Vec::new(),
            attached_balance: Yocto::new(0),
            attached_gas: NearGas::new(5_000_000_000_000),
        }),
    };
    let xcc_args = CrossContractCallArgs::Delayed(PromiseArgs::Recursive(promise));
    let _result = submit_xcc_transaction(xcc_args, &aurora, &mut signer, chain_id);

    // 3. Make Fibonacci call
    let router_account = format!(
        "{}.{}",
        hex::encode(signer_address.as_bytes()),
        aurora.contract.account_id.as_str()
    );
    let result = aurora.user.call(
        router_account.parse().unwrap(),
        "execute_scheduled",
        b"{\"nonce\": \"0\"}",
        near_sdk_sim::DEFAULT_GAS,
        0,
    );
    result.assert_success();

    // 4. Check the result is correct
    let output = result.unwrap_json_value();
    check_fib_result(output, usize::try_from(n).unwrap());
}

fn check_fib_result(output: serde_json::Value, n: usize) {
    let fib_numbers: [u8; 8] = [0, 1, 1, 2, 3, 5, 8, 13];
    let get_number = |field_name: &str| -> u8 {
        output
            .as_object()
            .unwrap()
            .get(field_name)
            .unwrap()
            .as_str()
            .unwrap()
            .parse()
            .unwrap()
    };
    let a = get_number("a");
    let b = get_number("b");
    assert_eq!(a, fib_numbers[n]);
    assert_eq!(b, fib_numbers[n + 1]);
}

fn test_xcc_precompile_common(is_scheduled: bool) {
    let XccTestContext {
        aurora,
        mut signer,
        signer_address,
        chain_id,
        wnear_account,
    } = init_xcc();

    let router_account = format!(
        "{}.{}",
        hex::encode(signer_address.as_bytes()),
        aurora.contract.account_id.as_str()
    );

    // 1. Deploy NEP-141 token.
    let ft_owner = aurora.user.create_user(
        "ft_owner.root".parse().unwrap(),
        near_sdk_sim::STORAGE_AMOUNT,
    );
    let nep_141_supply = 500;
    let nep_141_token = sim_tests::deploy_nep_141(
        "test_token.root",
        ft_owner.account_id.as_ref(),
        nep_141_supply,
        &aurora,
    );

    // 2. Register EVM router contract
    let args = serde_json::json!({
        "account_id": router_account,
    })
    .to_string();
    aurora
        .user
        .call(
            nep_141_token.account_id(),
            "storage_deposit",
            args.as_bytes(),
            near_sdk_sim::DEFAULT_GAS,
            near_sdk_sim::STORAGE_AMOUNT,
        )
        .assert_success();

    // 3. Give router some tokens
    let transfer_amount: u128 = 199;
    let args = serde_json::json!({
        "receiver_id": router_account,
        "amount": format!("{}", transfer_amount),
    })
    .to_string();
    ft_owner
        .call(
            nep_141_token.account_id(),
            "ft_transfer",
            args.as_bytes(),
            near_sdk_sim::DEFAULT_GAS,
            1,
        )
        .assert_success();
    assert_eq!(
        sim_tests::nep_141_balance_of(ft_owner.account_id.as_str(), &nep_141_token, &aurora),
        nep_141_supply - transfer_amount
    );

    // 4. Use xcc precompile to send those tokens back
    let args = serde_json::json!({
        "receiver_id": ft_owner.account_id.as_str(),
        "amount": format!("{}", transfer_amount),
    })
    .to_string();
    let promise = PromiseCreateArgs {
        target_account_id: nep_141_token.account_id.as_str().parse().unwrap(),
        method: "ft_transfer".into(),
        args: args.into_bytes(),
        attached_balance: Yocto::new(1),
        attached_gas: NearGas::new(100_000_000_000_000),
    };
    let callback = PromiseCreateArgs {
        target_account_id: nep_141_token.account_id.as_str().parse().unwrap(),
        method: "ft_balance_of".into(),
        args: format!("{{\"account_id\":\"{}\"}}", router_account).into_bytes(),
        attached_balance: Yocto::new(0),
        attached_gas: NearGas::new(2_000_000_000_000),
    };
    let promise_args = PromiseArgs::Callback(PromiseWithCallbackArgs {
        base: promise,
        callback,
    });
    let xcc_args = if is_scheduled {
        CrossContractCallArgs::Delayed(promise_args)
    } else {
        CrossContractCallArgs::Eager(promise_args)
    };
    let engine_balance_before_xcc = get_engine_near_balance(&aurora);
    let _result = submit_xcc_transaction(xcc_args, &aurora, &mut signer, chain_id);

    print_outcomes(&aurora);
    let engine_balance_after_xcc = get_engine_near_balance(&aurora);
    assert!(
        // engine loses less than 0.01 NEAR
        engine_balance_after_xcc.max(engine_balance_before_xcc)
            - engine_balance_after_xcc.min(engine_balance_before_xcc)
            < 10_000_000_000_000_000_000_000,
        "Engine lost too much NEAR funding xcc: Before={:?} After={:?}",
        engine_balance_before_xcc,
        engine_balance_after_xcc,
    );
    let router_balance = aurora
        .user
        .borrow_runtime()
        .view_account(&router_account)
        .unwrap()
        .amount();
    assert!(
        // router loses less than 0.01 NEAR from its allocated funds
        xcc::state::STORAGE_AMOUNT.as_u128() - router_balance < 10_000_000_000_000_000_000_000,
        "Router lost too much NEAR: Balance={:?}",
        router_balance,
    );
    // Router has no wNEAR balance because it all was unwrapped to actual NEAR
    assert_eq!(
        sim_tests::nep_141_balance_of(&router_account, &wnear_account, &aurora),
        0,
    );

    if is_scheduled {
        // The promise was only scheduled, not executed immediately. So the FT balance has not changed yet.
        assert_eq!(
            sim_tests::nep_141_balance_of(ft_owner.account_id.as_str(), &nep_141_token, &aurora),
            nep_141_supply - transfer_amount
        );

        // Now we execute the scheduled promise
        aurora
            .user
            .call(
                router_account.parse().unwrap(),
                "execute_scheduled",
                b"{\"nonce\": \"0\"}",
                near_sdk_sim::DEFAULT_GAS,
                0,
            )
            .assert_success();
    }

    assert_eq!(
        sim_tests::nep_141_balance_of(ft_owner.account_id.as_str(), &nep_141_token, &aurora),
        nep_141_supply
    );
}

/// Deploys the EVM, sets xcc router code, deploys wnear contract, bridges wnear into EVM, and calls `factory_set_wnear_address`
fn init_xcc() -> XccTestContext {
    let aurora = deploy_evm();
    let chain_id = AuroraRunner::default().chain_id;
    let xcc_wasm_bytes = contract_bytes();
    aurora
        .user
        .call(
            aurora.contract.account_id(),
            "factory_update",
            &xcc_wasm_bytes,
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
        .assert_success();

    let mut signer = test_utils::Signer::random();
    let signer_address = test_utils::address_from_secret_key(&signer.secret_key);

    // Setup wNEAR contract and bridge it to Aurora
    let wnear_account = deploy_wnear(&aurora);
    let wnear_erc20 = sim_tests::deploy_erc20_from_nep_141(&wnear_account, &aurora);
    sim_tests::transfer_nep_141_to_erc_20(
        &wnear_account,
        &wnear_erc20,
        &aurora.user,
        signer_address,
        WNEAR_AMOUNT,
        &aurora,
    );
    aurora
        .user
        .call(
            aurora.contract.account_id(),
            "factory_set_wnear_address",
            wnear_erc20.0.address.as_bytes(),
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
        .assert_success();
    let approve_tx = wnear_erc20.approve(
        cross_contract_call::ADDRESS,
        WNEAR_AMOUNT.into(),
        signer.use_nonce().into(),
    );
    let signed_transaction =
        test_utils::sign_transaction(approve_tx, Some(chain_id), &signer.secret_key);
    aurora
        .user
        .call(
            aurora.contract.account_id(),
            "submit",
            &rlp::encode(&signed_transaction),
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
        .assert_success();

    XccTestContext {
        aurora,
        signer,
        signer_address,
        chain_id,
        wnear_account,
    }
}

struct XccTestContext {
    pub aurora: AuroraAccount,
    pub signer: test_utils::Signer,
    pub signer_address: Address,
    pub chain_id: u64,
    pub wnear_account: UserAccount,
}

fn submit_xcc_transaction(
    xcc_args: CrossContractCallArgs,
    aurora: &AuroraAccount,
    signer: &mut test_utils::Signer,
    chain_id: u64,
) -> near_sdk_sim::ExecutionResult {
    let transaction = TransactionLegacy {
        nonce: signer.use_nonce().into(),
        gas_price: 0u64.into(),
        gas_limit: u64::MAX.into(),
        to: Some(cross_contract_call::ADDRESS),
        value: Wei::zero(),
        data: xcc_args.try_to_vec().unwrap(),
    };
    let signed_transaction =
        test_utils::sign_transaction(transaction, Some(chain_id), &signer.secret_key);
    let result = aurora.user.call(
        aurora.contract.account_id(),
        "submit",
        &rlp::encode(&signed_transaction),
        near_sdk_sim::DEFAULT_GAS,
        0,
    );
    result.assert_success();
    let submit_result: aurora_engine::parameters::SubmitResult = result.unwrap_borsh();
    if !submit_result.status.is_ok() {
        panic!("Unexpected result {:?}", submit_result);
    }
    result
}

fn get_engine_near_balance(aurora: &AuroraAccount) -> u128 {
    aurora
        .user
        .borrow_runtime()
        .view_account(aurora.contract.account_id.as_str())
        .unwrap()
        .amount()
}

fn print_outcomes(aurora: &AuroraAccount) {
    let rt = aurora.user.borrow_runtime();
    for id in rt.last_outcomes.iter() {
        println!("{:?}=={:?}\n\n", id, rt.outcome(id).unwrap());
    }
}

#[test]
fn test_xcc_schedule_gas() {
    let mut router = deploy_router();

    let promise = PromiseCreateArgs {
        target_account_id: "some_account.near".parse().unwrap(),
        method: "some_method".into(),
        args: b"hello_world".to_vec(),
        attached_balance: Yocto::new(56),
        attached_gas: NearGas::new(100_000_000_000_000),
    };

    let (maybe_outcome, maybe_error) = router.call(
        "schedule",
        "aurora",
        PromiseArgs::Create(promise).try_to_vec().unwrap(),
    );
    assert!(maybe_error.is_none());
    let outcome = maybe_outcome.unwrap();
    assert!(
        outcome.burnt_gas < costs::ROUTER_SCHEDULE.as_u64(),
        "{:?} not less than {:?}",
        outcome.burnt_gas,
        costs::ROUTER_SCHEDULE
    );
    assert_eq!(outcome.logs.len(), 1);
    assert_eq!(outcome.logs[0], "Promise scheduled at nonce 0");
}

#[test]
fn test_xcc_exec_gas() {
    let mut router = deploy_router();

    let create_promise_chain =
        |base_promise: &PromiseCreateArgs, callback_count: usize| -> NearPromise {
            let mut result = NearPromise::Simple(SimpleNearPromise::Create(base_promise.clone()));
            for _ in 0..callback_count {
                result = NearPromise::Then {
                    base: Box::new(result),
                    callback: SimpleNearPromise::Create(base_promise.clone()),
                };
            }
            result
        };
    let promise = PromiseCreateArgs {
        target_account_id: "some_account.near".parse().unwrap(),
        method: "some_method".into(),
        args: b"hello_world".to_vec(),
        attached_balance: Yocto::new(56),
        attached_gas: NearGas::new(100_000_000_000_000),
    };

    for callback_count in 0..5 {
        let x = create_promise_chain(&promise, callback_count);
        let args = PromiseArgs::Recursive(x);

        let (maybe_outcome, maybe_error) =
            router.call("execute", "aurora", args.try_to_vec().unwrap());
        assert!(maybe_error.is_none());
        let outcome = maybe_outcome.unwrap();

        let callback_count = args.promise_count() - 1;
        let router_exec_cost = costs::ROUTER_EXEC_BASE
            + NearGas::new(callback_count * costs::ROUTER_EXEC_PER_CALLBACK.as_u64());
        assert!(
            outcome.burnt_gas < router_exec_cost.as_u64(),
            "{:?} not less than {:?}",
            outcome.burnt_gas,
            router_exec_cost
        );

        assert_eq!(outcome.action_receipts.len(), args.promise_count() as usize);
        for (target_account_id, receipt) in outcome.action_receipts {
            assert_eq!(
                target_account_id.as_str(),
                promise.target_account_id.as_ref()
            );
            assert_eq!(receipt.actions.len(), 1);
            let action = &receipt.actions[0];
            match action {
                Action::FunctionCall(function_call) => {
                    assert_eq!(function_call.method_name, promise.method);
                    assert_eq!(function_call.args, promise.args);
                    assert_eq!(function_call.deposit, promise.attached_balance.as_u128());
                    assert_eq!(function_call.gas, promise.attached_gas.as_u64());
                }
                other => panic!("Unexpected action {:?}", other),
            };
        }
    }
}

fn deploy_fibonacci(aurora: &AuroraAccount) -> AccountId {
    let fib_contract_bytes = {
        let base_path = Path::new("..").join("etc").join("tests").join("fibonacci");
        let output_path =
            base_path.join("target/wasm32-unknown-unknown/release/fibonacci_on_near.wasm");
        test_utils::rust::compile(base_path);
        fs::read(output_path).unwrap()
    };
    let fib_account_id = format!("fib.{}", aurora.user.account_id.as_str());
    let _fib_account = aurora.user.deploy(
        &fib_contract_bytes,
        fib_account_id.parse().unwrap(),
        near_sdk_sim::STORAGE_AMOUNT,
    );
    fib_account_id.parse().unwrap()
}

fn deploy_router() -> AuroraRunner {
    let mut router = AuroraRunner {
        code: ContractCode::new(contract_bytes(), None),
        ..Default::default()
    };

    router.context.current_account_id = "some_address.aurora".parse().unwrap();
    router.context.predecessor_account_id = "aurora".parse().unwrap();

    let init_args = r#"{"wnear_account": "wrap.near", "must_register": true}"#;
    let (maybe_outcome, maybe_error) =
        router.call("initialize", "aurora", init_args.as_bytes().to_vec());
    assert!(maybe_error.is_none());
    let outcome = maybe_outcome.unwrap();
    assert!(outcome.used_gas < aurora_engine::xcc::INITIALIZE_GAS.as_u64());

    router
}

fn deploy_wnear(aurora: &AuroraAccount) -> UserAccount {
    let contract_bytes = std::fs::read("src/tests/res/w_near.wasm").unwrap();

    let account_id = format!("wrap.{}", aurora.user.account_id.as_str());
    let contract_account = aurora.user.deploy(
        &contract_bytes,
        account_id.parse().unwrap(),
        5 * near_sdk_sim::STORAGE_AMOUNT,
    );

    aurora
        .user
        .call(
            contract_account.account_id(),
            "new",
            &[],
            near_sdk_sim::DEFAULT_GAS,
            0,
        )
        .assert_success();

    // Need to register Aurora contract so that it can receive tokens
    let args = json!({
        "account_id": &aurora.contract.account_id,
    })
    .to_string();
    aurora
        .user
        .call(
            contract_account.account_id(),
            "storage_deposit",
            args.as_bytes(),
            near_sdk_sim::DEFAULT_GAS,
            near_sdk_sim::STORAGE_AMOUNT,
        )
        .assert_success();

    // Need to also register root account
    let args = json!({
        "account_id": &aurora.user.account_id,
    })
    .to_string();
    aurora
        .user
        .call(
            contract_account.account_id(),
            "storage_deposit",
            args.as_bytes(),
            near_sdk_sim::DEFAULT_GAS,
            near_sdk_sim::STORAGE_AMOUNT,
        )
        .assert_success();

    // Mint some wNEAR for the root account to use
    aurora
        .user
        .call(
            contract_account.account_id(),
            "near_deposit",
            &[],
            near_sdk_sim::DEFAULT_GAS,
            WNEAR_AMOUNT,
        )
        .assert_success();

    contract_account
}

fn deploy_erc20(runner: &mut AuroraRunner, signer: &mut test_utils::Signer) -> ERC20 {
    let engine_account = runner.aurora_account_id.clone();
    let args = aurora_engine::parameters::DeployErc20TokenArgs {
        nep141: "wrap.near".parse().unwrap(),
    };
    let (maybe_output, maybe_error) = runner.call(
        "deploy_erc20_token",
        &engine_account,
        args.try_to_vec().unwrap(),
    );
    assert!(maybe_error.is_none());
    let output = maybe_output.unwrap();
    let address = {
        let bytes: Vec<u8> =
            BorshDeserialize::try_from_slice(output.return_data.as_value().as_ref().unwrap())
                .unwrap();
        Address::try_from_slice(&bytes).unwrap()
    };

    let contract = ERC20(ERC20Constructor::load().0.deployed_at(address));
    let dest_address = test_utils::address_from_secret_key(&signer.secret_key);
    let call_args =
        aurora_engine::parameters::CallArgs::V1(aurora_engine::parameters::FunctionCallArgsV1 {
            contract: address,
            input: contract
                .mint(dest_address, WNEAR_AMOUNT.into(), U256::zero())
                .data,
        });
    let (_, maybe_error) = runner.call("call", &engine_account, call_args.try_to_vec().unwrap());
    assert!(maybe_error.is_none());

    contract
}

fn approve_erc20(
    token: &ERC20,
    spender: Address,
    runner: &mut AuroraRunner,
    signer: &mut test_utils::Signer,
) {
    let approve_result = runner
        .submit_with_signer(signer, |nonce| {
            token.approve(spender, WNEAR_AMOUNT.into(), nonce)
        })
        .unwrap();
    assert!(approve_result.status.is_ok());
}

pub(crate) fn contract_bytes() -> Vec<u8> {
    let base_path = Path::new("../etc").join("xcc-router");
    let output_path = base_path.join("target/wasm32-unknown-unknown/release/xcc_router.wasm");
    test_utils::rust::compile(base_path);
    fs::read(output_path).unwrap()
}

fn make_fib_promise(n: usize, account_id: &AccountId) -> NearPromise {
    if n == 0 {
        NearPromise::Simple(SimpleNearPromise::Create(PromiseCreateArgs {
            target_account_id: account_id.clone(),
            method: "seed".into(),
            args: Vec::new(),
            attached_balance: Yocto::new(0),
            attached_gas: NearGas::new(5_000_000_000_000),
        }))
    } else {
        let base = make_fib_promise(n - 1, account_id);
        let callback = SimpleNearPromise::Create(PromiseCreateArgs {
            target_account_id: account_id.clone(),
            method: "accumulate".into(),
            args: Vec::new(),
            attached_balance: Yocto::new(0),
            attached_gas: NearGas::new(5_000_000_000_000),
        });
        NearPromise::Then {
            base: Box::new(base),
            callback,
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-transactions/Cargo.toml ---
[package]
name = "aurora-engine-transactions"
version = "1.0.0"
authors = ["Aurora Labs <hello@aurora.dev>"]
edition = "2021"
description = ""
documentation = ""
readme = true
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "CC0-1.0"
publish = false
autobenches = false

[dependencies]
aurora-engine-types = { path = "../engine-types", default-features = false }
aurora-engine-sdk = { path = "../engine-sdk", default-features = false }
aurora-engine-precompiles = { path = "../engine-precompiles", default-features = false }
evm = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false }
rlp = { version = "0.5.0", default-features = false }
serde = { version = "1", features = ["derive"], optional = true }

[dev-dependencies]
hex = { version = "0.4", default-features = false, features = ["alloc"] }

[features]
std = ["aurora-engine-types/std", "aurora-engine-sdk/std", "aurora-engine-precompiles/std", "evm/std", "rlp/std"]
impl-serde = ["aurora-engine-types/impl-serde", "serde"]

'''
'''--- aurora-engine-2.8.1/engine-transactions/src/backwards_compatibility.rs ---
//! Warning: this module _incorrectly_ parses RLP-serialized Ethereum transactions.
//! This is intentional and needed for our "standalone engine" to be able to reproduce
//! the Aurora state on the NEAR blockchain before the time a bug was fixed. See
//! https://github.com/aurora-is-near/aurora-engine/pull/458 for more details, but external
//! users of this library should _never_ use the adapter in this module.

use crate::{Error, EthTransactionKind};
use aurora_engine_types::{types::Address, H160};

const ZERO_ADDRESS: Option<Address> = Some(Address::new(H160::zero()));

/// This struct is a modification to the usual `EthTransactionKind` parsing logic.
/// For blocks strictly less than `bug_fix_height`, it still has the bug where the
/// zero address in the `to` field is converted to `None`. For blocks greater than
/// or equal to `bug_fix_height` it correctly parses the transaction.
pub struct EthTransactionKindAdapter {
    bug_fix_height: u64,
}

impl EthTransactionKindAdapter {
    pub const fn new(bug_fix_height: u64) -> Self {
        Self { bug_fix_height }
    }

    pub fn try_parse_bytes(
        &self,
        bytes: &[u8],
        block_height: u64,
    ) -> Result<EthTransactionKind, Error> {
        let mut result = EthTransactionKind::try_from(bytes)?;

        // Prior to the bug fix, the zero address was always parsed as None if
        // it was in the `to` field.
        if block_height < self.bug_fix_height {
            match &mut result {
                EthTransactionKind::Legacy(tx) => {
                    if tx.transaction.to == ZERO_ADDRESS {
                        tx.transaction.to = None;
                    }
                }
                EthTransactionKind::Eip1559(tx) => {
                    if tx.transaction.to == ZERO_ADDRESS {
                        tx.transaction.to = None;
                    }
                }
                EthTransactionKind::Eip2930(tx) => {
                    if tx.transaction.to == ZERO_ADDRESS {
                        tx.transaction.to = None;
                    }
                }
            }
        }

        Ok(result)
    }
}

'''
'''--- aurora-engine-2.8.1/engine-transactions/src/eip_1559.rs ---
use crate::eip_2930::AccessTuple;
use crate::Error;
use aurora_engine_precompiles::secp256k1::ecrecover;
use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::{Vec, U256};
use rlp::{Decodable, DecoderError, Encodable, Rlp, RlpStream};

/// Type indicator (per EIP-1559)
pub const TYPE_BYTE: u8 = 0x02;

/// A EIP-1559 transaction kind from the London hard fork.
///
/// See [EIP-1559](https://github.com/ethereum/EIPs/blob/master/EIPS/eip-1559.md)
/// for more details.
#[derive(Debug, Eq, PartialEq, Clone)]
pub struct Transaction1559 {
    pub chain_id: u64,
    pub nonce: U256,
    pub max_priority_fee_per_gas: U256,
    pub max_fee_per_gas: U256,
    pub gas_limit: U256,
    pub to: Option<Address>,
    pub value: Wei,
    pub data: Vec<u8>,
    pub access_list: Vec<AccessTuple>,
}

impl Transaction1559 {
    /// RLP encoding of the data for an unsigned message (used to make signature)
    pub fn rlp_append_unsigned(&self, s: &mut RlpStream) {
        self.rlp_append(s, 9);
    }

    /// RLP encoding for a signed message (used to encode the transaction for sending to tx pool)
    pub fn rlp_append_signed(&self, s: &mut RlpStream) {
        self.rlp_append(s, 12);
    }

    fn rlp_append(&self, s: &mut RlpStream, list_len: usize) {
        s.begin_list(list_len);
        s.append(&self.chain_id);
        s.append(&self.nonce);
        s.append(&self.max_priority_fee_per_gas);
        s.append(&self.max_fee_per_gas);
        s.append(&self.gas_limit);
        match self.to.as_ref() {
            None => s.append(&""),
            Some(address) => s.append(&address.raw()),
        };
        s.append(&self.value.raw());
        s.append(&self.data);
        s.begin_list(self.access_list.len());
        for tuple in self.access_list.iter() {
            s.begin_list(2);
            s.append(&tuple.address);
            s.begin_list(tuple.storage_keys.len());
            for key in tuple.storage_keys.iter() {
                s.append(key);
            }
        }
    }
}

#[derive(Debug, Eq, PartialEq, Clone)]
pub struct SignedTransaction1559 {
    pub transaction: Transaction1559,
    /// The parity (0 for even, 1 for odd) of the y-value of a secp256k1 signature.
    pub parity: u8,
    pub r: U256,
    pub s: U256,
}

impl SignedTransaction1559 {
    pub fn sender(&self) -> Result<Address, Error> {
        let mut rlp_stream = RlpStream::new();
        rlp_stream.append(&TYPE_BYTE);
        self.transaction.rlp_append_unsigned(&mut rlp_stream);
        let message_hash = aurora_engine_sdk::keccak(rlp_stream.as_raw());
        ecrecover(
            message_hash,
            &super::vrs_to_arr(self.parity, self.r, self.s),
        )
        .map_err(|_e| Error::EcRecover)
    }
}

impl Encodable for SignedTransaction1559 {
    fn rlp_append(&self, s: &mut RlpStream) {
        self.transaction.rlp_append_signed(s);
        s.append(&self.parity);
        s.append(&self.r);
        s.append(&self.s);
    }
}

impl Decodable for SignedTransaction1559 {
    fn decode(rlp: &Rlp<'_>) -> Result<Self, DecoderError> {
        if rlp.item_count() != Ok(12) {
            return Err(rlp::DecoderError::RlpIncorrectListLen);
        }
        let chain_id = rlp.val_at(0)?;
        let nonce = rlp.val_at(1)?;
        let max_priority_fee_per_gas = rlp.val_at(2)?;
        let max_fee_per_gas = rlp.val_at(3)?;
        let gas_limit = rlp.val_at(4)?;
        let to = super::rlp_extract_to(rlp, 5)?;
        let value = Wei::new(rlp.val_at(6)?);
        let data = rlp.val_at(7)?;
        let access_list = rlp.list_at(8)?;
        let parity = rlp.val_at(9)?;
        let r = rlp.val_at(10)?;
        let s = rlp.val_at(11)?;
        Ok(Self {
            transaction: Transaction1559 {
                chain_id,
                nonce,
                max_priority_fee_per_gas,
                max_fee_per_gas,
                gas_limit,
                to,
                value,
                data,
                access_list,
            },
            parity,
            r,
            s,
        })
    }
}

'''
'''--- aurora-engine-2.8.1/engine-transactions/src/eip_2930.rs ---
use crate::Error;
use aurora_engine_precompiles::secp256k1::ecrecover;
use aurora_engine_sdk as sdk;
use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::{Vec, H160, H256, U256};
use rlp::{Decodable, DecoderError, Encodable, Rlp, RlpStream};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

/// Type indicator (per EIP-2718) for access list transactions
pub const TYPE_BYTE: u8 = 0x01;

#[derive(Debug, Eq, PartialEq, Clone)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct AccessTuple {
    pub address: H160,
    pub storage_keys: Vec<H256>,
}

impl Decodable for AccessTuple {
    fn decode(rlp: &Rlp<'_>) -> Result<Self, DecoderError> {
        let address = rlp.val_at(0)?;
        let storage_keys = rlp.list_at(1)?;

        Ok(Self {
            address,
            storage_keys,
        })
    }
}

/// See https://eips.ethereum.org/EIPS/eip-2930
#[derive(Debug, Eq, PartialEq, Clone)]
pub struct Transaction2930 {
    pub chain_id: u64,
    pub nonce: U256,
    pub gas_price: U256,
    pub gas_limit: U256,
    pub to: Option<Address>,
    pub value: Wei,
    pub data: Vec<u8>,
    pub access_list: Vec<AccessTuple>,
}

impl Transaction2930 {
    /// RLP encoding of the data for an unsigned message (used to make signature)
    pub fn rlp_append_unsigned(&self, s: &mut RlpStream) {
        self.rlp_append(s, 8);
    }

    /// RLP encoding for a signed message (used to encode the transaction for sending to tx pool)
    pub fn rlp_append_signed(&self, s: &mut RlpStream) {
        self.rlp_append(s, 11);
    }

    fn rlp_append(&self, s: &mut RlpStream, list_len: usize) {
        s.begin_list(list_len);
        s.append(&self.chain_id);
        s.append(&self.nonce);
        s.append(&self.gas_price);
        s.append(&self.gas_limit);
        match self.to.as_ref() {
            None => s.append(&""),
            Some(address) => s.append(&address.raw()),
        };
        s.append(&self.value.raw());
        s.append(&self.data);
        s.begin_list(self.access_list.len());
        for tuple in self.access_list.iter() {
            s.begin_list(2);
            s.append(&tuple.address);
            s.begin_list(tuple.storage_keys.len());
            for key in tuple.storage_keys.iter() {
                s.append(key);
            }
        }
    }
}

#[derive(Debug, Eq, PartialEq, Clone)]
pub struct SignedTransaction2930 {
    pub transaction: Transaction2930,
    /// The parity (0 for even, 1 for odd) of the y-value of a secp256k1 signature.
    pub parity: u8,
    pub r: U256,
    pub s: U256,
}

impl SignedTransaction2930 {
    pub fn sender(&self) -> Result<Address, Error> {
        let mut rlp_stream = RlpStream::new();
        rlp_stream.append(&TYPE_BYTE);
        self.transaction.rlp_append_unsigned(&mut rlp_stream);
        let message_hash = sdk::keccak(rlp_stream.as_raw());
        ecrecover(
            message_hash,
            &super::vrs_to_arr(self.parity, self.r, self.s),
        )
        .map_err(|_e| Error::EcRecover)
    }
}

impl Encodable for SignedTransaction2930 {
    fn rlp_append(&self, s: &mut RlpStream) {
        self.transaction.rlp_append_signed(s);
        s.append(&self.parity);
        s.append(&self.r);
        s.append(&self.s);
    }
}

impl Decodable for SignedTransaction2930 {
    fn decode(rlp: &Rlp<'_>) -> Result<Self, DecoderError> {
        if rlp.item_count() != Ok(11) {
            return Err(rlp::DecoderError::RlpIncorrectListLen);
        }
        let chain_id = rlp.val_at(0)?;
        let nonce = rlp.val_at(1)?;
        let gas_price = rlp.val_at(2)?;
        let gas_limit = rlp.val_at(3)?;
        let to = super::rlp_extract_to(rlp, 4)?;
        let value = Wei::new(rlp.val_at(5)?);
        let data = rlp.val_at(6)?;
        let access_list = rlp.list_at(7)?;
        let parity = rlp.val_at(8)?;
        let r = rlp.val_at(9)?;
        let s = rlp.val_at(10)?;
        Ok(Self {
            transaction: Transaction2930 {
                chain_id,
                nonce,
                gas_price,
                gas_limit,
                to,
                value,
                data,
                access_list,
            },
            parity,
            r,
            s,
        })
    }
}

'''
'''--- aurora-engine-2.8.1/engine-transactions/src/legacy.rs ---
use crate::Error;
use aurora_engine_precompiles::secp256k1::ecrecover;
use aurora_engine_sdk as sdk;
use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::{Vec, U256};
use rlp::{Decodable, DecoderError, Encodable, Rlp, RlpStream};

#[derive(Debug, Eq, PartialEq, Clone)]
pub struct TransactionLegacy {
    /// A monotonically increasing transaction counter for this sender
    pub nonce: U256,
    /// The fee the sender pays per unit of gas
    pub gas_price: U256,
    /// The maximum amount of gas units consumed by the transaction
    pub gas_limit: U256,
    /// The receiving address (`None` for the zero address)
    pub to: Option<Address>,
    /// The amount of ETH to transfer
    pub value: Wei,
    /// Arbitrary binary data for a contract call invocation
    pub data: Vec<u8>,
}

impl TransactionLegacy {
    pub fn rlp_append_unsigned(&self, s: &mut RlpStream, chain_id: Option<u64>) {
        s.begin_list(if chain_id.is_none() { 6 } else { 9 });
        s.append(&self.nonce);
        s.append(&self.gas_price);
        s.append(&self.gas_limit);
        match self.to.as_ref() {
            None => s.append(&""),
            Some(address) => s.append(&address.raw()),
        };
        s.append(&self.value.raw());
        s.append(&self.data);
        if let Some(chain_id) = chain_id {
            s.append(&chain_id);
            s.append(&0u8);
            s.append(&0u8);
        }
    }

    /// Returns self.gas as a u64, or None if self.gas > u64::MAX
    #[allow(unused)]
    pub fn get_gas_limit(&self) -> Option<u64> {
        self.gas_limit.try_into().ok()
    }
}

#[derive(Debug, Eq, PartialEq, Clone)]
pub struct LegacyEthSignedTransaction {
    /// The unsigned transaction data
    pub transaction: TransactionLegacy,
    /// The ECDSA recovery ID
    pub v: u64,
    /// The first ECDSA signature output
    pub r: U256,
    /// The second ECDSA signature output
    pub s: U256,
}

impl LegacyEthSignedTransaction {
    /// Returns sender of given signed transaction by doing ecrecover on the signature.
    pub fn sender(&self) -> Result<Address, Error> {
        let mut rlp_stream = RlpStream::new();
        // See details of CHAIN_ID computation here - https://github.com/ethereum/EIPs/blob/master/EIPS/eip-155.md#specification
        let (chain_id, rec_id) = match self.v {
            0..=26 | 29..=34 => return Err(Error::InvalidV),
            27..=28 => (
                None,
                u8::try_from(self.v - 27).map_err(|_e| Error::InvalidV)?,
            ),
            _ => (
                Some((self.v - 35) / 2),
                u8::try_from((self.v - 35) % 2).map_err(|_e| Error::InvalidV)?,
            ),
        };
        self.transaction
            .rlp_append_unsigned(&mut rlp_stream, chain_id);
        let message_hash = sdk::keccak(rlp_stream.as_raw());
        ecrecover(message_hash, &super::vrs_to_arr(rec_id, self.r, self.s))
            .map_err(|_e| Error::EcRecover)
    }

    /// Returns chain id encoded in `v` parameter of the signature if that was done, otherwise None.
    pub fn chain_id(&self) -> Option<u64> {
        match self.v {
            0..=34 => None,
            _ => Some((self.v - 35) / 2),
        }
    }
}

impl Encodable for LegacyEthSignedTransaction {
    fn rlp_append(&self, s: &mut RlpStream) {
        s.begin_list(9);
        s.append(&self.transaction.nonce);
        s.append(&self.transaction.gas_price);
        s.append(&self.transaction.gas_limit);
        match self.transaction.to.as_ref() {
            None => s.append(&""),
            Some(address) => s.append(&address.raw()),
        };
        s.append(&self.transaction.value.raw());
        s.append(&self.transaction.data);
        s.append(&self.v);
        s.append(&self.r);
        s.append(&self.s);
    }
}

impl Decodable for LegacyEthSignedTransaction {
    fn decode(rlp: &Rlp<'_>) -> Result<Self, DecoderError> {
        if rlp.item_count() != Ok(9) {
            return Err(rlp::DecoderError::RlpIncorrectListLen);
        }
        let nonce = rlp.val_at(0)?;
        let gas_price = rlp.val_at(1)?;
        let gas = rlp.val_at(2)?;
        let to = super::rlp_extract_to(rlp, 3)?;
        let value = Wei::new(rlp.val_at(4)?);
        let data = rlp.val_at(5)?;
        let v = rlp.val_at(6)?;
        let r = rlp.val_at(7)?;
        let s = rlp.val_at(8)?;
        Ok(Self {
            transaction: TransactionLegacy {
                nonce,
                gas_price,
                gas_limit: gas,
                to,
                value,
                data,
            },
            v,
            r,
            s,
        })
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use aurora_engine_types::vec;

    #[test]
    fn test_eth_signed_no_chain_sender() {
        let encoded_tx = hex::decode("f901f680883362396163613030836691b78080b901a06080604052600080546001600160a01b0319163317905534801561002257600080fd5b5061016e806100326000396000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c8063445df0ac146100465780638da5cb5b14610060578063fdacd57614610084575b600080fd5b61004e6100a3565b60408051918252519081900360200190f35b6100686100a9565b604080516001600160a01b039092168252519081900360200190f35b6100a16004803603602081101561009a57600080fd5b50356100b8565b005b60015481565b6000546001600160a01b031681565b6000546001600160a01b031633146101015760405162461bcd60e51b81526004018080602001828103825260338152602001806101076033913960400191505060405180910390fd5b60015556fe546869732066756e6374696f6e206973207265737472696374656420746f2074686520636f6e74726163742773206f776e6572a265627a7a72315820b7e3396b30da5009ea603d5c2bdfd68577b979d5817fbe4fbd7d983f5c04ff3464736f6c634300050f00321ca0f0133510c01bc64a64f84b411082ff74bbc4a3aa5c720d2b5f61ad76716ee232a03412d91486eb012423492af258a4cd3b03ce67dde7fdc93bbea142bce6a59c9f").unwrap();
        let tx = LegacyEthSignedTransaction::decode(&Rlp::new(&encoded_tx)).unwrap();
        assert_eq!(tx.v, 28);
        assert_eq!(tx.chain_id(), None);
        assert_eq!(
            tx.sender().unwrap(),
            address_from_arr(&hex::decode("cf3c4c291ce0ad0ef5f6de577cd19d6d6ecf4db6").unwrap())
        );
    }

    #[test]
    fn test_decode_eth_signed_transaction() {
        let encoded_tx = hex::decode("f86a8086d55698372431831e848094f0109fc8df283027b6285cc889f5aa624eac1f55843b9aca008025a009ebb6ca057a0535d6186462bc0b465b561c94a295bdb0621fc19208ab149a9ca0440ffd775ce91a833ab410777204d5341a6f9fa91216a6f3ee2c051fea6a0428").unwrap();
        let tx = LegacyEthSignedTransaction::decode(&Rlp::new(&encoded_tx)).unwrap();
        assert_eq!(tx.v, 37);
        assert_eq!(tx.chain_id(), Some(1));
        assert_eq!(
            tx.transaction,
            TransactionLegacy {
                nonce: U256::zero(),
                gas_price: U256::from(234567897654321u128),
                gas_limit: U256::from(2000000u128),
                to: Some(address_from_arr(
                    &hex::decode("F0109fC8DF283027b6285cc889F5aA624EaC1F55").unwrap()
                )),
                value: Wei::new_u64(1000000000),
                data: vec![],
            }
        );
        assert_eq!(
            tx.sender().unwrap(),
            address_from_arr(&hex::decode("2c7536e3605d9c16a7a3d7b1898e529396a65c23").unwrap())
        );
    }

    #[test]
    fn test_none_decode_eth_signed_transaction() {
        let encoded_tx = hex::decode("f8c58001831e84808080b874600060005560648060106000396000f360e060020a6000350480638ada066e146028578063d09de08a1460365780632baeceb714604d57005b5060005460005260206000f3005b5060016000540160005560005460005260206000f3005b5060016000540360005560005460005260206000f300849c8a82cba07bea58c20d614248f6f1607704ee209eee14190f6187d6c7dc935b6599199cd5a02fe682dec51911f02d6a2812f301419d3f181acd3ef5b3609ac28b1dc42b0531").unwrap();
        let tx_1 = LegacyEthSignedTransaction::decode(&Rlp::new(&encoded_tx)).unwrap();

        let encoded_tx = hex::decode("f8d98001831e848094000000000000000000000000000000000000000080b874600060005560648060106000396000f360e060020a6000350480638ada066e146028578063d09de08a1460365780632baeceb714604d57005b5060005460005260206000f3005b5060016000540160005560005460005260206000f3005b5060016000540360005560005460005260206000f300849c8a82cba0668cfa20c8521b28fa8e42f26df0f2c090dda2fb5cbbb60dd616e8d00f93d9d8a00a1e5de8454ce9072cefd8268c0bf8eba2c1206a5e5a43914c1d62962c121d94").unwrap();
        let tx_2 = LegacyEthSignedTransaction::decode(&Rlp::new(&encoded_tx)).unwrap();

        // tx_2 has the zero address as its `to` field
        assert_eq!(tx_2.transaction.to, Some(address_from_arr(&[0u8; 20])));

        // otherwise, tx_1 and tx_2 are identical.
        let mut tx_2_mod = tx_2;
        tx_2_mod.transaction.to = None;
        assert_eq!(tx_1.transaction, tx_2_mod.transaction);
    }

    fn address_from_arr(arr: &[u8]) -> Address {
        assert_eq!(arr.len(), 20);
        Address::try_from_slice(arr).unwrap()
    }
}

'''
'''--- aurora-engine-2.8.1/engine-transactions/src/lib.rs ---
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(not(feature = "std"), feature(alloc_error_handler))]
#![deny(clippy::as_conversions)]

use aurora_engine_types::types::{Address, Wei};
use aurora_engine_types::{vec, Vec, H160, U256};
use eip_2930::AccessTuple;
use rlp::{Decodable, DecoderError, Rlp};

pub mod backwards_compatibility;
pub mod eip_1559;
pub mod eip_2930;
pub mod legacy;

/// Typed Transaction Envelope (see https://eips.ethereum.org/EIPS/eip-2718)
#[derive(Debug, Eq, PartialEq, Clone)]
pub enum EthTransactionKind {
    Legacy(legacy::LegacyEthSignedTransaction),
    Eip2930(eip_2930::SignedTransaction2930),
    Eip1559(eip_1559::SignedTransaction1559),
}

impl TryFrom<&[u8]> for EthTransactionKind {
    type Error = Error;

    fn try_from(bytes: &[u8]) -> Result<Self, Self::Error> {
        if bytes.is_empty() {
            Err(Error::EmptyInput)
        } else if bytes[0] == eip_2930::TYPE_BYTE {
            Ok(Self::Eip2930(eip_2930::SignedTransaction2930::decode(
                &Rlp::new(&bytes[1..]),
            )?))
        } else if bytes[0] == eip_1559::TYPE_BYTE {
            Ok(Self::Eip1559(eip_1559::SignedTransaction1559::decode(
                &Rlp::new(&bytes[1..]),
            )?))
        } else if bytes[0] <= 0x7f {
            Err(Error::UnknownTransactionType)
        } else if bytes[0] == 0xff {
            Err(Error::ReservedSentinel)
        } else {
            let legacy = legacy::LegacyEthSignedTransaction::decode(&Rlp::new(bytes))?;
            Ok(Self::Legacy(legacy))
        }
    }
}

impl<'a> From<&'a EthTransactionKind> for Vec<u8> {
    fn from(tx: &'a EthTransactionKind) -> Self {
        let mut stream = rlp::RlpStream::new();
        match &tx {
            EthTransactionKind::Legacy(tx) => {
                stream.append(tx);
            }
            EthTransactionKind::Eip1559(tx) => {
                stream.append(&eip_1559::TYPE_BYTE);
                stream.append(tx);
            }
            EthTransactionKind::Eip2930(tx) => {
                stream.append(&eip_2930::TYPE_BYTE);
                stream.append(tx);
            }
        }
        stream.out().to_vec()
    }
}

/// A normalized Ethereum transaction which can be created from older
/// transactions.
pub struct NormalizedEthTransaction {
    pub address: Address,
    pub chain_id: Option<u64>,
    pub nonce: U256,
    pub gas_limit: U256,
    pub max_priority_fee_per_gas: U256,
    pub max_fee_per_gas: U256,
    pub to: Option<Address>,
    pub value: Wei,
    pub data: Vec<u8>,
    pub access_list: Vec<AccessTuple>,
}

impl TryFrom<EthTransactionKind> for NormalizedEthTransaction {
    type Error = Error;

    fn try_from(kind: EthTransactionKind) -> Result<Self, Self::Error> {
        use EthTransactionKind::*;
        Ok(match kind {
            Legacy(tx) => Self {
                address: tx.sender()?,
                chain_id: tx.chain_id(),
                nonce: tx.transaction.nonce,
                gas_limit: tx.transaction.gas_limit,
                max_priority_fee_per_gas: tx.transaction.gas_price,
                max_fee_per_gas: tx.transaction.gas_price,
                to: tx.transaction.to,
                value: tx.transaction.value,
                data: tx.transaction.data,
                access_list: vec![],
            },
            Eip2930(tx) => Self {
                address: tx.sender()?,
                chain_id: Some(tx.transaction.chain_id),
                nonce: tx.transaction.nonce,
                gas_limit: tx.transaction.gas_limit,
                max_priority_fee_per_gas: tx.transaction.gas_price,
                max_fee_per_gas: tx.transaction.gas_price,
                to: tx.transaction.to,
                value: tx.transaction.value,
                data: tx.transaction.data,
                access_list: tx.transaction.access_list,
            },
            Eip1559(tx) => Self {
                address: tx.sender()?,
                chain_id: Some(tx.transaction.chain_id),
                nonce: tx.transaction.nonce,
                gas_limit: tx.transaction.gas_limit,
                max_priority_fee_per_gas: tx.transaction.max_priority_fee_per_gas,
                max_fee_per_gas: tx.transaction.max_fee_per_gas,
                to: tx.transaction.to,
                value: tx.transaction.value,
                data: tx.transaction.data,
                access_list: tx.transaction.access_list,
            },
        })
    }
}

impl NormalizedEthTransaction {
    pub fn intrinsic_gas(&self, config: &evm::Config) -> Result<u64, Error> {
        let is_contract_creation = self.to.is_none();

        let base_gas = if is_contract_creation {
            config.gas_transaction_create
        } else {
            config.gas_transaction_call
        };

        let num_zero_bytes = u64::try_from(self.data.iter().filter(|b| **b == 0).count())
            .map_err(|_e| Error::IntegerConversion)?;
        let gas_zero_bytes = config
            .gas_transaction_zero_data
            .checked_mul(num_zero_bytes)
            .ok_or(Error::GasOverflow)?;

        let data_len = u64::try_from(self.data.len()).map_err(|_e| Error::IntegerConversion)?;
        let num_non_zero_bytes = data_len - num_zero_bytes;
        let gas_non_zero_bytes = config
            .gas_transaction_non_zero_data
            .checked_mul(num_non_zero_bytes)
            .ok_or(Error::GasOverflow)?;

        let access_list_len =
            u64::try_from(self.access_list.len()).map_err(|_e| Error::IntegerConversion)?;
        let gas_access_list_address = config
            .gas_access_list_address
            .checked_mul(access_list_len)
            .ok_or(Error::GasOverflow)?;

        let gas_access_list_storage = config
            .gas_access_list_storage_key
            .checked_mul(
                u64::try_from(
                    self.access_list
                        .iter()
                        .map(|a| a.storage_keys.len())
                        .sum::<usize>(),
                )
                .map_err(|_e| Error::IntegerConversion)?,
            )
            .ok_or(Error::GasOverflow)?;

        base_gas
            .checked_add(gas_zero_bytes)
            .and_then(|gas| gas.checked_add(gas_non_zero_bytes))
            .and_then(|gas| gas.checked_add(gas_access_list_address))
            .and_then(|gas| gas.checked_add(gas_access_list_storage))
            .ok_or(Error::GasOverflow)
    }
}

#[derive(Debug, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize))]
pub enum Error {
    UnknownTransactionType,
    EmptyInput,
    // Per the EIP-2718 spec 0xff is a reserved value
    ReservedSentinel,
    InvalidV,
    EcRecover,
    GasOverflow,
    IntegerConversion,
    #[cfg_attr(feature = "serde", serde(serialize_with = "decoder_err_to_str"))]
    RlpDecodeError(DecoderError),
}

#[cfg(feature = "serde")]
fn decoder_err_to_str<S: serde::Serializer>(err: &DecoderError, ser: S) -> Result<S::Ok, S::Error> {
    ser.serialize_str(&format!("{:?}", err))
}

impl Error {
    pub fn as_str(&self) -> &'static str {
        match self {
            Self::UnknownTransactionType => "ERR_UNKNOWN_TX_TYPE",
            Self::EmptyInput => "ERR_EMPTY_TX_INPUT",
            Self::ReservedSentinel => "ERR_RESERVED_LEADING_TX_BYTE",
            Self::InvalidV => "ERR_INVALID_V",
            Self::EcRecover => "ERR_ECRECOVER",
            Self::GasOverflow => "ERR_GAS_OVERFLOW",
            Self::IntegerConversion => "ERR_INTEGER_CONVERSION",
            Self::RlpDecodeError(_) => "ERR_TX_RLP_DECODE",
        }
    }
}

impl From<DecoderError> for Error {
    fn from(e: DecoderError) -> Self {
        Self::RlpDecodeError(e)
    }
}

impl AsRef<[u8]> for Error {
    fn as_ref(&self) -> &[u8] {
        self.as_str().as_bytes()
    }
}

fn rlp_extract_to(rlp: &Rlp<'_>, index: usize) -> Result<Option<Address>, DecoderError> {
    let value = rlp.at(index)?;
    if value.is_empty() {
        if value.is_data() {
            Ok(None)
        } else {
            Err(rlp::DecoderError::RlpExpectedToBeData)
        }
    } else {
        let v: H160 = value.as_val()?;
        let addr = Address::new(v);
        Ok(Some(addr))
    }
}

fn vrs_to_arr(v: u8, r: U256, s: U256) -> [u8; 65] {
    let mut result = [0u8; 65]; // (r, s, v), typed (uint256, uint256, uint8)
    r.to_big_endian(&mut result[0..32]);
    s.to_big_endian(&mut result[32..64]);
    result[64] = v;
    result
}

#[cfg(test)]
mod tests {
    use super::{Error, EthTransactionKind};
    use crate::{eip_1559, eip_2930};

    #[test]
    fn test_try_parse_empty_input() {
        assert!(matches!(
            EthTransactionKind::try_from([].as_ref()),
            Err(Error::EmptyInput)
        ));

        // If the first byte is present, then empty bytes will be passed in to
        // the RLP parsing. Let's also check this is not a problem.
        assert!(matches!(
            EthTransactionKind::try_from([eip_1559::TYPE_BYTE].as_ref()),
            Err(Error::RlpDecodeError(_))
        ));
        assert!(matches!(
            EthTransactionKind::try_from([eip_2930::TYPE_BYTE].as_ref()),
            Err(Error::RlpDecodeError(_))
        ));
        assert!(matches!(
            EthTransactionKind::try_from([0x80].as_ref()),
            Err(Error::RlpDecodeError(_))
        ));
    }
}

'''
'''--- aurora-engine-2.8.1/engine-types/Cargo.toml ---
[package]
name = "aurora-engine-types"
version = "1.0.0"
authors = ["Aurora Labs <hello@aurora.dev>"]
edition = "2021"
description = ""
documentation = ""
readme = true
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "CC0-1.0"
publish = false
autobenches = false

[dependencies]
borsh = { version = "0.9.3", default-features = false }
hex = { version = "0.4", default-features = false, features = ["alloc"] }
primitive-types = { version = "0.12", default-features = false, features = ["rlp"] }
serde = { version = "1", features = ["derive"], optional = true }

[dev-dependencies]
rand = "0.8.5"

[features]
default = ["std"]
std = ["borsh/std", "hex/std", "primitive-types/std"]
impl-serde = ["primitive-types/impl-serde", "serde"]

'''
'''--- aurora-engine-2.8.1/engine-types/src/account_id.rs ---
//! Guarantees all properly constructed AccountId's are valid for the NEAR network.
//!
//! Inpired by: https://github.com/near/nearcore/tree/master/core/account-id

use crate::{fmt, str, str::FromStr, Box, String, Vec};
use borsh::{BorshDeserialize, BorshSerialize};

pub const MIN_ACCOUNT_ID_LEN: usize = 2;
pub const MAX_ACCOUNT_ID_LEN: usize = 64;

/// Account identifier.
///
/// This guarantees all properly constructed AccountId's are valid for the NEAR network.
#[derive(
    BorshSerialize, BorshDeserialize, Default, Eq, Ord, Hash, Clone, Debug, PartialEq, PartialOrd,
)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct AccountId(Box<str>);

impl AccountId {
    pub fn new(account_id: &str) -> Result<Self, ParseAccountError> {
        Self::validate(account_id)?;
        Ok(Self(account_id.into()))
    }

    pub fn as_bytes(&self) -> &[u8] {
        self.as_ref().as_bytes()
    }

    pub fn validate(account_id: &str) -> Result<(), ParseAccountError> {
        if account_id.len() < MIN_ACCOUNT_ID_LEN {
            Err(ParseAccountError::TooShort)
        } else if account_id.len() > MAX_ACCOUNT_ID_LEN {
            Err(ParseAccountError::TooLong)
        } else {
            // Adapted from https://github.com/near/near-sdk-rs/blob/fd7d4f82d0dfd15f824a1cf110e552e940ea9073/near-sdk/src/environment/env.rs#L819

            // NOTE: We don't want to use Regex here, because it requires extra time to compile it.
            // The valid account ID regex is /^(([a-z\d]+[-_])*[a-z\d]+\.)*([a-z\d]+[-_])*[a-z\d]+$/
            // Instead the implementation is based on the previous character checks.

            // We can safely assume that last char was a separator.
            let mut last_char_is_separator = true;

            for c in account_id.bytes() {
                let current_char_is_separator = match c {
                    b'a'..=b'z' | b'0'..=b'9' => false,
                    b'-' | b'_' | b'.' => true,
                    _ => {
                        return Err(ParseAccountError::Invalid);
                    }
                };
                if current_char_is_separator && last_char_is_separator {
                    return Err(ParseAccountError::Invalid);
                }
                last_char_is_separator = current_char_is_separator;
            }

            (!last_char_is_separator)
                .then_some(())
                .ok_or(ParseAccountError::Invalid)
        }
    }

    pub fn is_top_level_account_id(&self) -> bool {
        self.0.len() >= MIN_ACCOUNT_ID_LEN
            && self.0.len() <= MAX_ACCOUNT_ID_LEN
            && self.as_ref() != "system"
            && !self.as_ref().contains('.')
    }

    /// Returns true if the signer_id can create a direct sub-account with the given account Id.
    pub fn is_sub_account_of(&self, parent_account_id: &AccountId) -> bool {
        if parent_account_id.0.len() >= self.0.len() {
            return false;
        }
        // Will not panic, since valid account id is utf-8 only and the length is checked above.
        // e.g. when `near` creates `aa.near`, it splits into `aa.` and `near`
        let (prefix, suffix) = self.0.split_at(self.0.len() - parent_account_id.0.len());

        prefix.find('.') == Some(prefix.len() - 1) && suffix == parent_account_id.as_ref()
    }
}

impl TryFrom<String> for AccountId {
    type Error = ParseAccountError;

    fn try_from(account_id: String) -> Result<Self, Self::Error> {
        AccountId::new(&account_id)
    }
}

impl TryFrom<&[u8]> for AccountId {
    type Error = ParseAccountError;

    fn try_from(account_id: &[u8]) -> Result<Self, Self::Error> {
        let account_id = str::from_utf8(account_id).map_err(|_| ParseAccountError::Invalid)?;
        AccountId::new(account_id)
    }
}

impl TryFrom<Vec<u8>> for AccountId {
    type Error = ParseAccountError;

    fn try_from(account_id: Vec<u8>) -> Result<Self, Self::Error> {
        AccountId::try_from(&account_id[..])
    }
}

impl FromStr for AccountId {
    type Err = ParseAccountError;

    fn from_str(account_id: &str) -> Result<Self, Self::Err> {
        Self::validate(account_id)?;
        Ok(Self(account_id.into()))
    }
}

impl From<AccountId> for String {
    fn from(account_id: AccountId) -> Self {
        account_id.0.into_string()
    }
}

impl fmt::Display for AccountId {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.0)
    }
}

impl From<AccountId> for Box<str> {
    fn from(value: AccountId) -> Box<str> {
        value.0
    }
}

impl From<AccountId> for Vec<u8> {
    fn from(account_id: AccountId) -> Vec<u8> {
        account_id.as_bytes().to_vec()
    }
}

impl<T: ?Sized> AsRef<T> for AccountId
where
    Box<str>: AsRef<T>,
{
    fn as_ref(&self) -> &T {
        self.0.as_ref()
    }
}

/// A list of errors that occur when parsing an invalid Account ID.
#[derive(Eq, Hash, Clone, Debug, PartialEq)]
pub enum ParseAccountError {
    TooLong,
    TooShort,
    Invalid,
}

impl AsRef<[u8]> for ParseAccountError {
    fn as_ref(&self) -> &[u8] {
        match self {
            ParseAccountError::TooLong => b"ERR_ACCOUNT_ID_TO_LONG",
            ParseAccountError::TooShort => b"ERR_ACCOUNT_ID_TO_SHORT",
            ParseAccountError::Invalid => b"ERR_ACCOUNT_ID_TO_INVALID",
        }
    }
}

impl fmt::Display for ParseAccountError {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let msg = String::from_utf8(self.as_ref().to_vec()).unwrap();
        write!(f, "{}", msg)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn is_implicit(account_id: &str) -> bool {
        account_id.len() == 64
            && account_id
                .as_bytes()
                .iter()
                .all(|b| matches!(b, b'a'..=b'f' | b'0'..=b'9'))
    }

    pub const OK_ACCOUNT_IDS: [&str; 24] = [
        "aa",
        "a-a",
        "a-aa",
        "100",
        "0o",
        "com",
        "near",
        "bowen",
        "b-o_w_e-n",
        "b.owen",
        "bro.wen",
        "a.ha",
        "a.b-a.ra",
        "system",
        "over.9000",
        "google.com",
        "illia.cheapaccounts.near",
        "0o0ooo00oo00o",
        "alex-skidanov",
        "10-4.8-2",
        "b-o_w_e-n",
        "no_lols",
        "0123456789012345678901234567890123456789012345678901234567890123",
        // Valid, but can't be created
        "near.a",
    ];

    pub const BAD_ACCOUNT_IDS: [&str; 24] = [
        "a",
        "A",
        "Abc",
        "-near",
        "near-",
        "-near-",
        "near.",
        ".near",
        "near@",
        "@near",
        "неар",
        "@@@@@",
        "0__0",
        "0_-_0",
        "0_-_0",
        "..",
        "a..near",
        "nEar",
        "_bowen",
        "hello world",
        "abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz",
        "01234567890123456789012345678901234567890123456789012345678901234",
        // `@` separators are banned now
        "some-complex-address@gmail.com",
        "sub.buy_d1gitz@atata@b0-rg.c_0_m",
    ];

    #[test]
    fn test_is_valid_account_id() {
        for account_id in OK_ACCOUNT_IDS.iter().cloned() {
            if let Err(err) = AccountId::validate(account_id) {
                panic!("Valid account id {:?} marked invalid: {}", account_id, err);
            }
        }

        for account_id in BAD_ACCOUNT_IDS.iter().cloned() {
            if AccountId::validate(account_id).is_ok() {
                panic!("Valid account id {:?} marked valid", account_id);
            }
        }
    }

    #[test]
    fn test_is_valid_top_level_account_id() {
        let ok_top_level_account_ids = &[
            "aa",
            "a-a",
            "a-aa",
            "100",
            "0o",
            "com",
            "near",
            "bowen",
            "b-o_w_e-n",
            "0o0ooo00oo00o",
            "alex-skidanov",
            "b-o_w_e-n",
            "no_lols",
            "0123456789012345678901234567890123456789012345678901234567890123",
        ];
        for account_id in ok_top_level_account_ids {
            assert!(
                account_id
                    .parse::<AccountId>()
                    .map_or(false, |account_id| account_id.is_top_level_account_id()),
                "Valid top level account id {:?} marked invalid",
                account_id
            );
        }

        let bad_top_level_account_ids = &[
            "near.a",
            "b.owen",
            "bro.wen",
            "a.ha",
            "a.b-a.ra",
            "some-complex-address@gmail.com",
            "sub.buy_d1gitz@atata@b0-rg.c_0_m",
            "over.9000",
            "google.com",
            "illia.cheapaccounts.near",
            "10-4.8-2",
            "a",
            "A",
            "Abc",
            "-near",
            "near-",
            "-near-",
            "near.",
            ".near",
            "near@",
            "@near",
            "неар",
            "@@@@@",
            "0__0",
            "0_-_0",
            "0_-_0",
            "..",
            "a..near",
            "nEar",
            "_bowen",
            "hello world",
            "abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz.abcdefghijklmnopqrstuvwxyz",
            "01234567890123456789012345678901234567890123456789012345678901234",
            // Valid regex and length, but reserved
            "system",
        ];
        for account_id in bad_top_level_account_ids {
            assert!(
                !account_id
                    .parse::<AccountId>()
                    .map_or(false, |account_id| account_id.is_top_level_account_id()),
                "Invalid top level account id {:?} marked valid",
                account_id
            );
        }
    }

    #[test]
    fn test_is_valid_sub_account_id() {
        let ok_pairs = &[
            ("test", "a.test"),
            ("test-me", "abc.test-me"),
            ("gmail.com", "abc.gmail.com"),
            ("gmail.com", "abc-lol.gmail.com"),
            ("gmail.com", "abc_lol.gmail.com"),
            ("gmail.com", "bro-abc_lol.gmail.com"),
            ("g0", "0g.g0"),
            ("1g", "1g.1g"),
            ("5-3", "4_2.5-3"),
        ];
        for (signer_id, sub_account_id) in ok_pairs {
            assert!(
                matches!(
                    (signer_id.parse::<AccountId>(), sub_account_id.parse::<AccountId>()),
                    (Ok(signer_id), Ok(sub_account_id)) if sub_account_id.is_sub_account_of(&signer_id)
                ),
                "Failed to create sub-account {:?} by account {:?}",
                sub_account_id,
                signer_id
            );
        }

        let bad_pairs = &[
            ("test", ".test"),
            ("test", "test"),
            ("test", "a1.a.test"),
            ("test", "est"),
            ("test", ""),
            ("test", "st"),
            ("test5", "ббб"),
            ("test", "a-test"),
            ("test", "etest"),
            ("test", "a.etest"),
            ("test", "retest"),
            ("test-me", "abc-.test-me"),
            ("test-me", "Abc.test-me"),
            ("test-me", "-abc.test-me"),
            ("test-me", "a--c.test-me"),
            ("test-me", "a_-c.test-me"),
            ("test-me", "a-_c.test-me"),
            ("test-me", "_abc.test-me"),
            ("test-me", "abc_.test-me"),
            ("test-me", "..test-me"),
            ("test-me", "a..test-me"),
            ("gmail.com", "a.abc@gmail.com"),
            ("gmail.com", ".abc@gmail.com"),
            ("gmail.com", ".abc@gmail@com"),
            ("gmail.com", "abc@gmail@com"),
            ("test", "a@test"),
            ("test_me", "abc@test_me"),
            ("gmail.com", "abc@gmail.com"),
            ("gmail@com", "abc.gmail@com"),
            ("gmail.com", "abc-lol@gmail.com"),
            ("gmail@com", "abc_lol.gmail@com"),
            ("gmail@com", "bro-abc_lol.gmail@com"),
            (
                "gmail.com",
                "123456789012345678901234567890123456789012345678901234567890@gmail.com",
            ),
            (
                "123456789012345678901234567890123456789012345678901234567890",
                "1234567890.123456789012345678901234567890123456789012345678901234567890",
            ),
            ("aa", "ъ@aa"),
            ("aa", "ъ.aa"),
        ];
        for (signer_id, sub_account_id) in bad_pairs {
            assert!(
                !matches!(
                    (signer_id.parse::<AccountId>(), sub_account_id.parse::<AccountId>()),
                    (Ok(signer_id), Ok(sub_account_id)) if sub_account_id.is_sub_account_of(&signer_id)
                ),
                "Invalid sub-account {:?} created by account {:?}",
                sub_account_id,
                signer_id
            );
        }
    }

    #[test]
    fn test_is_account_id_64_len_hex() {
        let valid_64_len_hex_account_ids = &[
            "0000000000000000000000000000000000000000000000000000000000000000",
            "6174617461746174617461746174617461746174617461746174617461746174",
            "0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
            "ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
            "20782e20662e64666420482123494b6b6c677573646b6c66676a646b6c736667",
        ];
        for valid_account_id in valid_64_len_hex_account_ids {
            assert!(
                matches!(
                    valid_account_id.parse::<AccountId>(),
                    Ok(account_id) if is_implicit(account_id.as_ref())
                ),
                "Account ID {} should be valid 64-len hex",
                valid_account_id
            );
            assert!(
                is_implicit(valid_account_id),
                "Account ID {} should be valid 64-len hex",
                valid_account_id
            );
        }

        let invalid_64_len_hex_account_ids = &[
            "000000000000000000000000000000000000000000000000000000000000000",
            "6.74617461746174617461746174617461746174617461746174617461746174",
            "012-456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef",
            "fffff_ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
            "oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo",
            "00000000000000000000000000000000000000000000000000000000000000",
        ];
        for invalid_account_id in invalid_64_len_hex_account_ids {
            assert!(
                !matches!(
                    invalid_account_id.parse::<AccountId>(),
                    Ok(account_id) if is_implicit(account_id.as_ref())
                ),
                "Account ID {} should be invalid 64-len hex",
                invalid_account_id
            );
            assert!(
                !is_implicit(invalid_account_id),
                "Account ID {} should be invalid 64-len hex",
                invalid_account_id
            );
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-types/src/lib.rs ---
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(not(feature = "std"), feature(alloc_error_handler))]
#![cfg_attr(feature = "log", feature(panic_info_message))]
#![deny(clippy::as_conversions)]

pub mod account_id;
pub mod parameters;
pub mod storage;
pub mod types;

mod v0 {
    extern crate alloc;
    extern crate core;

    pub use alloc::{
        borrow::ToOwned,
        borrow::{Cow, Cow::*},
        boxed::Box,
        collections::BTreeMap as HashMap,
        collections::BTreeMap,
        collections::BTreeSet,
        fmt, format, str,
        string::String,
        string::ToString,
        vec,
        vec::Vec,
    };
    pub use core::{
        cmp::Ordering, fmt::Display, marker::PhantomData, mem, ops::Add, ops::AddAssign, ops::Div,
        ops::Mul, ops::Sub, ops::SubAssign,
    };
    pub use primitive_types::{H160, H256, U256};
}

pub use v0::*;

'''
'''--- aurora-engine-2.8.1/engine-types/src/parameters.rs ---
use crate::account_id::*;
use crate::types::*;
use crate::*;
use borsh::maybestd::io;
use borsh::{BorshDeserialize, BorshSerialize};

#[must_use]
#[derive(Debug, BorshSerialize, BorshDeserialize)]
pub enum PromiseArgs {
    Create(PromiseCreateArgs),
    Callback(PromiseWithCallbackArgs),
    Recursive(NearPromise),
}

impl PromiseArgs {
    /// Counts the total number of promises this call creates (including callbacks).
    pub fn promise_count(&self) -> u64 {
        match self {
            Self::Create(_) => 1,
            Self::Callback(_) => 2,
            Self::Recursive(p) => p.promise_count(),
        }
    }

    pub fn total_gas(&self) -> NearGas {
        match self {
            Self::Create(call) => call.attached_gas,
            Self::Callback(cb) => cb.base.attached_gas + cb.callback.attached_gas,
            Self::Recursive(p) => p.total_gas(),
        }
    }

    pub fn total_near(&self) -> Yocto {
        match self {
            Self::Create(call) => call.attached_balance,
            Self::Callback(cb) => cb.base.attached_balance + cb.callback.attached_balance,
            Self::Recursive(p) => p.total_near(),
        }
    }
}

#[derive(Debug, BorshSerialize, BorshDeserialize, Clone, PartialEq, Eq)]
pub enum SimpleNearPromise {
    Create(PromiseCreateArgs),
    Batch(PromiseBatchAction),
}

impl SimpleNearPromise {
    pub fn total_gas(&self) -> NearGas {
        match self {
            Self::Create(call) => call.attached_gas,
            Self::Batch(batch) => {
                let total: u64 = batch
                    .actions
                    .iter()
                    .filter_map(|a| {
                        if let PromiseAction::FunctionCall { gas, .. } = a {
                            Some(gas.as_u64())
                        } else {
                            None
                        }
                    })
                    .sum();
                NearGas::new(total)
            }
        }
    }

    pub fn total_near(&self) -> Yocto {
        match self {
            Self::Create(call) => call.attached_balance,
            Self::Batch(batch) => {
                let total: u128 = batch
                    .actions
                    .iter()
                    .filter_map(|a| match a {
                        PromiseAction::FunctionCall { attached_yocto, .. } => {
                            Some(attached_yocto.as_u128())
                        }
                        PromiseAction::Transfer { amount } => Some(amount.as_u128()),
                        _ => None,
                    })
                    .sum();
                Yocto::new(total)
            }
        }
    }
}

#[derive(Debug, Clone, PartialEq, Eq)]
pub enum NearPromise {
    Simple(SimpleNearPromise),
    Then {
        base: Box<NearPromise>,
        // Near doesn't allow arbitrary promises in the callback,
        // only simple calls to contracts or batches of actions.
        callback: SimpleNearPromise,
    },
    And(Vec<NearPromise>),
}

impl NearPromise {
    pub fn promise_count(&self) -> u64 {
        match self {
            Self::Simple(_) => 1,
            Self::Then { base, .. } => base.promise_count() + 1,
            Self::And(ps) => ps.iter().map(Self::promise_count).sum(),
        }
    }

    pub fn total_gas(&self) -> NearGas {
        match self {
            Self::Simple(x) => x.total_gas(),
            Self::Then { base, callback } => base.total_gas() + callback.total_gas(),
            Self::And(promises) => {
                let total = promises.iter().map(|p| p.total_gas().as_u64()).sum();
                NearGas::new(total)
            }
        }
    }

    pub fn total_near(&self) -> Yocto {
        match self {
            Self::Simple(x) => x.total_near(),
            Self::Then { base, callback } => base.total_near() + callback.total_near(),
            Self::And(promises) => {
                let total = promises.iter().map(|p| p.total_near().as_u128()).sum();
                Yocto::new(total)
            }
        }
    }
}

// Cannot use derive macro on recursive types, so we write it by hand
impl BorshSerialize for NearPromise {
    fn serialize<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        match self {
            Self::Simple(x) => {
                writer.write_all(&[0x00])?;
                x.serialize(writer)
            }
            Self::Then { base, callback } => {
                writer.write_all(&[0x01])?;
                base.serialize(writer)?;
                callback.serialize(writer)
            }
            Self::And(promises) => {
                writer.write_all(&[0x02])?;
                promises.serialize(writer)
            }
        }
    }
}

impl BorshDeserialize for NearPromise {
    fn deserialize(buf: &mut &[u8]) -> io::Result<Self> {
        let variant_byte = buf[0];
        *buf = &buf[1..];
        match variant_byte {
            0x00 => {
                let inner = SimpleNearPromise::deserialize(buf)?;
                Ok(Self::Simple(inner))
            }
            0x01 => {
                let base = Self::deserialize(buf)?;
                let callback = SimpleNearPromise::deserialize(buf)?;
                Ok(Self::Then {
                    base: Box::new(base),
                    callback,
                })
            }
            0x02 => {
                let promises: Vec<Self> = Vec::deserialize(buf)?;
                Ok(Self::And(promises))
            }
            _ => Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "Invalid variant byte for NearPromise",
            )),
        }
    }
}

#[must_use]
#[derive(Debug, BorshSerialize, BorshDeserialize, Clone, PartialEq, Eq)]
pub struct PromiseCreateArgs {
    pub target_account_id: AccountId,
    pub method: String,
    pub args: Vec<u8>,
    pub attached_balance: Yocto,
    pub attached_gas: NearGas,
}

#[must_use]
#[derive(Debug, BorshSerialize, BorshDeserialize, Clone, PartialEq, Eq)]
pub struct PromiseWithCallbackArgs {
    pub base: PromiseCreateArgs,
    pub callback: PromiseCreateArgs,
}

#[derive(Debug, BorshSerialize, BorshDeserialize, Clone, PartialEq, Eq)]
pub enum PromiseAction {
    CreateAccount,
    Transfer {
        amount: Yocto,
    },
    DeployContract {
        code: Vec<u8>,
    },
    FunctionCall {
        name: String,
        args: Vec<u8>,
        attached_yocto: Yocto,
        gas: NearGas,
    },
    Stake {
        amount: Yocto,
        public_key: NearPublicKey,
    },
    AddFullAccessKey {
        public_key: NearPublicKey,
        nonce: u64,
    },
    AddFunctionCallKey {
        public_key: NearPublicKey,
        nonce: u64,
        allowance: Yocto,
        receiver_id: AccountId,
        function_names: String,
    },
    DeleteKey {
        public_key: NearPublicKey,
    },
    DeleteAccount {
        beneficiary_id: AccountId,
    },
}

#[derive(Debug, BorshSerialize, BorshDeserialize, Clone, PartialEq, Eq)]
pub enum NearPublicKey {
    /// ed25519 public keys are 32 bytes
    Ed25519([u8; 32]),
    /// secp256k1 keys are in the uncompressed 64 byte format
    Secp256k1([u8; 64]),
}

#[must_use]
#[derive(Debug, BorshSerialize, BorshDeserialize, Clone, PartialEq, Eq)]
pub struct PromiseBatchAction {
    pub target_account_id: AccountId,
    pub actions: Vec<PromiseAction>,
}

/// withdraw NEAR eth-connector call args
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct WithdrawCallArgs {
    pub recipient_address: Address,
    pub amount: NEP141Wei,
}

/// withdraw NEAR eth-connector call args
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct RefundCallArgs {
    pub recipient_address: Address,
    pub erc20_address: Option<Address>,
    pub amount: RawU256,
}

/// Args passed to the the cross contract call precompile.
/// That precompile is used by Aurora contracts to make calls to the broader NEAR ecosystem.
/// See https://github.com/aurora-is-near/AIPs/pull/2 for design details.
#[derive(Debug, BorshSerialize, BorshDeserialize)]
pub enum CrossContractCallArgs {
    /// The promise is to be executed immediately (as part of the same NEAR transaction as the EVM call).
    Eager(PromiseArgs),
    /// The promise is to be stored in the router contract, and can be executed in a future transaction.
    /// The purpose of this is to expand how much NEAR gas can be made available to a cross contract call.
    /// For example, if an expensive EVM call ends with a NEAR cross contract call, then there may not be
    /// much gas left to perform it. In this case, the promise could be `Delayed` (stored in the router)
    /// and executed in a separate transaction with a fresh 300 Tgas available for it.
    Delayed(PromiseArgs),
}

'''
'''--- aurora-engine-2.8.1/engine-types/src/storage.rs ---
use crate::types::Address;
use crate::*;
use borsh::{BorshDeserialize, BorshSerialize};

// NOTE: We start at 0x7 as our initial value as our original storage was not
// version prefixed and ended as 0x6.
pub enum VersionPrefix {
    V1 = 0x7,
}

impl From<VersionPrefix> for u8 {
    fn from(v: VersionPrefix) -> Self {
        match v {
            VersionPrefix::V1 => 0x7,
        }
    }
}

#[allow(dead_code)]
#[derive(Clone, Copy, BorshSerialize, BorshDeserialize)]
pub enum KeyPrefix {
    Config = 0x0,
    Nonce = 0x1,
    Balance = 0x2,
    Code = 0x3,
    Storage = 0x4,
    RelayerEvmAddressMap = 0x5,
    EthConnector = 0x6,
    Generation = 0x7,
    Nep141Erc20Map = 0x8,
    Erc20Nep141Map = 0x9,
    CrossContractCall = 0xa,
}

impl From<KeyPrefix> for u8 {
    fn from(k: KeyPrefix) -> Self {
        use KeyPrefix::*;
        match k {
            Config => 0x0,
            Nonce => 0x1,
            Balance => 0x2,
            Code => 0x3,
            Storage => 0x4,
            RelayerEvmAddressMap => 0x5,
            EthConnector => 0x6,
            Generation => 0x7,
            Nep141Erc20Map => 0x8,
            Erc20Nep141Map => 0x9,
            CrossContractCall => 0xa,
        }
    }
}

/// Enum used to differentiate different storage keys used by eth-connector
#[derive(Clone, Copy, BorshSerialize, BorshDeserialize)]
pub enum EthConnectorStorageId {
    Contract = 0x0,
    FungibleToken = 0x1,
    UsedEvent = 0x2,
    PausedMask = 0x3,
    StatisticsAuroraAccountsCounter = 0x4,
    FungibleTokenMetadata = 0x5,
}

impl From<EthConnectorStorageId> for u8 {
    fn from(id: EthConnectorStorageId) -> Self {
        use EthConnectorStorageId::*;
        match id {
            Contract => 0x0,
            FungibleToken => 0x1,
            UsedEvent => 0x2,
            PausedMask => 0x3,
            StatisticsAuroraAccountsCounter => 0x4,
            FungibleTokenMetadata => 0x5,
        }
    }
}

/// We can't use const generic over Enum, but we can do it over integral type
pub type KeyPrefixU8 = u8;

// TODO: Derive From<u8> using macro to avoid missing new arguments in the future
impl From<KeyPrefixU8> for KeyPrefix {
    fn from(value: KeyPrefixU8) -> Self {
        match value {
            0x0 => Self::Config,
            0x1 => Self::Nonce,
            0x2 => Self::Balance,
            0x3 => Self::Code,
            0x4 => Self::Storage,
            0x5 => Self::RelayerEvmAddressMap,
            0x6 => Self::EthConnector,
            0x7 => Self::Generation,
            0x8 => Self::Nep141Erc20Map,
            0x9 => Self::Erc20Nep141Map,
            0xa => Self::CrossContractCall,
            _ => unreachable!(),
        }
    }
}

#[allow(dead_code)]
pub fn bytes_to_key(prefix: KeyPrefix, bytes: &[u8]) -> Vec<u8> {
    [&[u8::from(VersionPrefix::V1)], &[u8::from(prefix)], bytes].concat()
}

#[allow(dead_code)]
pub fn address_to_key(prefix: KeyPrefix, address: &Address) -> [u8; 22] {
    let mut result = [0u8; 22];
    result[0] = u8::from(VersionPrefix::V1);
    result[1] = u8::from(prefix);
    result[2..22].copy_from_slice(address.as_bytes());
    result
}

pub enum StorageKeyKind {
    Normal([u8; 54]),
    Generation([u8; 58]),
}

impl AsRef<[u8]> for StorageKeyKind {
    fn as_ref(&self) -> &[u8] {
        use StorageKeyKind::*;
        match &self {
            Normal(v) => v,
            Generation(v) => v,
        }
    }
}

pub fn storage_to_key(address: &Address, key: &H256, generation: u32) -> StorageKeyKind {
    if generation == 0 {
        StorageKeyKind::Normal(normal_storage_key(address, key))
    } else {
        StorageKeyKind::Generation(generation_storage_key(address, key, generation))
    }
}

#[allow(dead_code)]
fn normal_storage_key(address: &Address, key: &H256) -> [u8; 54] {
    let mut result = [0u8; 54];
    result[0] = u8::from(VersionPrefix::V1);
    result[1] = u8::from(KeyPrefix::Storage);
    result[2..22].copy_from_slice(address.as_bytes());
    result[22..54].copy_from_slice(&key.0);
    result
}

#[allow(dead_code)]
fn generation_storage_key(address: &Address, key: &H256, generation: u32) -> [u8; 58] {
    let mut result = [0u8; 58];
    result[0] = u8::from(VersionPrefix::V1);
    result[1] = u8::from(KeyPrefix::Storage);
    result[2..22].copy_from_slice(address.as_bytes());
    result[22..26].copy_from_slice(&generation.to_le_bytes());
    result[26..58].copy_from_slice(&key.0);
    result
}

'''
'''--- aurora-engine-2.8.1/engine-types/src/types/address.rs ---
use crate::{format, String, H160};
use borsh::maybestd::io;
use borsh::{BorshDeserialize, BorshSerialize};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

/// Base Eth Address type
#[derive(Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Address(H160);

impl Address {
    /// Construct Address from H160
    pub const fn new(val: H160) -> Self {
        Self(val)
    }

    /// Get raw H160 data
    pub fn raw(&self) -> H160 {
        self.0
    }

    /// Encode address to string
    pub fn encode(&self) -> String {
        hex::encode(self.0.as_bytes())
    }

    pub fn decode(address: &str) -> Result<Address, error::AddressError> {
        if address.len() != 40 {
            return Err(error::AddressError::IncorrectLength);
        }
        let mut result = [0u8; 20];
        hex::decode_to_slice(address, &mut result)
            .map_err(|_| error::AddressError::FailedDecodeHex)?;
        Ok(Address::new(H160(result)))
    }

    pub fn as_bytes(&self) -> &[u8] {
        self.0.as_bytes()
    }

    pub fn try_from_slice(raw_addr: &[u8]) -> Result<Self, error::AddressError> {
        if raw_addr.len() != 20 {
            return Err(error::AddressError::IncorrectLength);
        }
        Ok(Self::new(H160::from_slice(raw_addr)))
    }

    pub const fn from_array(array: [u8; 20]) -> Self {
        Self(H160(array))
    }

    pub const fn zero() -> Self {
        Address::new(H160([0u8; 20]))
    }
}

impl TryFrom<&[u8]> for Address {
    type Error = error::AddressError;

    fn try_from(raw_addr: &[u8]) -> Result<Self, Self::Error> {
        Self::try_from_slice(raw_addr).map_err(|_| error::AddressError::IncorrectLength)
    }
}

impl BorshSerialize for Address {
    fn serialize<W: io::Write>(&self, writer: &mut W) -> io::Result<()> {
        writer.write_all(self.0.as_bytes())
    }
}

impl BorshDeserialize for Address {
    fn deserialize(buf: &mut &[u8]) -> io::Result<Self> {
        if buf.len() < 20 {
            return Err(io::Error::new(
                io::ErrorKind::Other,
                format!("{}", error::AddressError::IncorrectLength),
            ));
        }
        // Guaranty no panics. The length checked early
        let address = Self(H160::from_slice(&buf[..20]));
        *buf = &buf[20..];
        Ok(address)
    }
}

impl Default for Address {
    fn default() -> Self {
        Address::zero()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_address_serializer() {
        let eth_address = "096DE9C2B8A5B8c22cEe3289B101f6960d68E51E";
        // borsh serialize
        let serialized_addr =
            Address::new(H160::from_slice(&hex::decode(eth_address).unwrap()[..]))
                .try_to_vec()
                .unwrap();
        assert_eq!(serialized_addr.len(), 20);

        let addr = Address::try_from_slice(&serialized_addr).unwrap();
        assert_eq!(
            addr.encode(),
            "096DE9C2B8A5B8c22cEe3289B101f6960d68E51E".to_lowercase()
        );
    }

    #[test]
    fn test_address_decode() {
        // Test compatibility with previous typ RawAddress.
        // It was: type RawAddress = [u8;20];
        let eth_address_vec = hex::decode("096DE9C2B8A5B8c22cEe3289B101f6960d68E51E").unwrap();
        let mut eth_address = [0u8; 20];
        eth_address.copy_from_slice(&eth_address_vec[..]);

        let aurora_eth_address =
            Address::decode("096DE9C2B8A5B8c22cEe3289B101f6960d68E51E").unwrap();
        assert_eq!(eth_address, aurora_eth_address.as_bytes());

        let serialized_addr = eth_address.try_to_vec().unwrap();
        let aurora_serialized_addr = aurora_eth_address.try_to_vec().unwrap();

        assert_eq!(serialized_addr.len(), 20);
        assert_eq!(aurora_serialized_addr.len(), 20);
        assert_eq!(serialized_addr, aurora_serialized_addr);

        // Used serialized data from `RawAddress`
        let addr = Address::try_from_slice(&serialized_addr).unwrap();
        assert_eq!(
            addr.encode(),
            "096DE9C2B8A5B8c22cEe3289B101f6960d68E51E".to_lowercase()
        );
    }

    #[test]
    fn test_wrong_address_19() {
        let serialized_addr = [0u8; 19];
        let addr = Address::try_from_slice(&serialized_addr);
        let err = addr.unwrap_err();
        matches!(err, error::AddressError::IncorrectLength);
    }
}

pub mod error {
    use crate::{fmt, String};

    #[derive(Eq, Hash, Clone, Debug, PartialEq)]
    pub enum AddressError {
        FailedDecodeHex,
        IncorrectLength,
    }

    impl AsRef<[u8]> for AddressError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::FailedDecodeHex => b"FAILED_DECODE_ETH_ADDRESS",
                Self::IncorrectLength => b"ETH_WRONG_ADDRESS_LENGTH",
            }
        }
    }

    impl fmt::Display for AddressError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let msg = String::from_utf8(self.as_ref().to_vec()).unwrap();
            write!(f, "{}", msg)
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-types/src/types/balance.rs ---
use crate::fmt::Formatter;
use crate::{Add, Display, Sub};
use borsh::{BorshDeserialize, BorshSerialize};

pub const ZERO_BALANCE: Balance = Balance::new(0);
pub const ZERO_YOCTO: Yocto = Yocto::new(0);

#[derive(
    Default, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, BorshSerialize, BorshDeserialize,
)]
/// A generic type for 128-bit balances, especially for NEP-141 tokens. This generic type should not be used
/// to represent NEAR balances (`Yocto` is designed for this purpose) or for eth-connector balances (`NEP141Wei`
/// is designed for this purpose). The reason we have specific types for NEAR and eth-connector is because of the
/// significant role they play in our system; therefore we do not want to mix them up with generic token balances.
pub struct Balance(u128);

impl Display for Balance {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl Balance {
    /// Constructs a new `Balance` with a given u128 value.
    pub const fn new(amount: u128) -> Balance {
        Self(amount)
    }

    /// Consumes `Balance` and returns the underlying type.
    pub fn as_u128(self) -> u128 {
        self.0
    }
}

#[derive(
    Default, BorshSerialize, BorshDeserialize, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd,
)]
/// Near Yocto type which wraps an underlying u128.
/// 1 NEAR = 10^24 yoctoNEAR
pub struct Yocto(u128);

impl Display for Yocto {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl Yocto {
    /// Constructs a new `Yocto NEAR` with a given u128 value.
    pub const fn new(yocto: u128) -> Yocto {
        Self(yocto)
    }

    /// Consumes `Yocto NEAR` and returns the underlying type.
    pub fn as_u128(self) -> u128 {
        self.0
    }
}

impl Add<Yocto> for Yocto {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub<Yocto> for Yocto {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

pub mod error {
    use crate::{fmt, String};

    #[derive(Eq, Hash, Clone, Debug, PartialEq)]
    pub struct BalanceOverflowError;

    impl AsRef<[u8]> for BalanceOverflowError {
        fn as_ref(&self) -> &[u8] {
            b"ERR_BALANCE_OVERFLOW"
        }
    }

    impl fmt::Display for BalanceOverflowError {
        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
            let msg = String::from_utf8(self.as_ref().to_vec()).unwrap();
            write!(f, "{}", msg)
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine-types/src/types/fee.rs ---
use crate::fmt::Formatter;
use crate::types::NEP141Wei;
use crate::{Add, Display};
use borsh::{BorshDeserialize, BorshSerialize};

#[derive(
    Default, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, BorshSerialize, BorshDeserialize,
)]
/// Engine `fee` type which wraps an underlying u128.
pub struct Fee(NEP141Wei);

impl Display for Fee {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl Fee {
    /// Constructs a new `Fee` with a given u128 value.
    pub const fn new(fee: NEP141Wei) -> Fee {
        Self(fee)
    }

    /// Consumes `Fee` and returns the underlying type.
    pub fn as_u128(self) -> u128 {
        self.0.as_u128()
    }
}

impl Add<Fee> for Fee {
    type Output = Fee;

    fn add(self, rhs: Fee) -> Self::Output {
        Fee(self.0 + rhs.0)
    }
}

impl From<u128> for Fee {
    fn from(fee: u128) -> Self {
        Self(NEP141Wei::new(fee))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_fee_add() {
        let fee = Fee::new(NEP141Wei::new(100));
        assert_eq!(fee + fee, Fee::from(200));
        assert_eq!(fee.add(200.into()), Fee::from(300));
    }

    #[test]
    fn test_fee_from() {
        let fee = Fee::new(NEP141Wei::new(100));
        let fee2 = Fee::from(100u128);
        assert_eq!(fee, fee2);
        let res: u128 = fee.as_u128();
        assert_eq!(res, 100);
    }
}

'''
'''--- aurora-engine-2.8.1/engine-types/src/types/gas.rs ---
use crate::fmt::Formatter;
use crate::{Add, AddAssign, Display, Div, Mul, Sub};
use borsh::{BorshDeserialize, BorshSerialize};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

#[derive(
    Default, BorshSerialize, BorshDeserialize, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd,
)]
/// Near gas type which wraps an underlying u64.
pub struct NearGas(u64);

impl Display for NearGas {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl Sub<NearGas> for NearGas {
    type Output = NearGas;

    fn sub(self, rhs: NearGas) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Add<NearGas> for NearGas {
    type Output = NearGas;

    fn add(self, rhs: NearGas) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl NearGas {
    /// Constructs a new `NearGas` with a given u64 value.
    pub const fn new(gas: u64) -> NearGas {
        Self(gas)
    }

    /// Consumes `NearGas` and returns the underlying type.
    pub fn as_u64(self) -> u64 {
        self.0
    }
}

#[derive(Default, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
/// Ethereum gas type which wraps an underlying u64.
pub struct EthGas(u64);

impl Display for EthGas {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl EthGas {
    /// Constructs a new `EthGas` with a given u64 value.
    pub const fn new(gas: u64) -> EthGas {
        Self(gas)
    }

    /// Consumes `EthGas` and returns the underlying type.
    pub fn as_u64(self) -> u64 {
        self.0
    }
}

impl Add<EthGas> for EthGas {
    type Output = EthGas;

    fn add(self, rhs: EthGas) -> Self::Output {
        EthGas(self.0 + rhs.0)
    }
}

impl AddAssign<EthGas> for EthGas {
    fn add_assign(&mut self, rhs: EthGas) {
        self.0 += rhs.0
    }
}

impl Div<u64> for EthGas {
    type Output = EthGas;

    fn div(self, rhs: u64) -> Self::Output {
        EthGas(self.0 / rhs)
    }
}

impl Mul<EthGas> for u32 {
    type Output = EthGas;

    fn mul(self, rhs: EthGas) -> Self::Output {
        EthGas(u64::from(self) * rhs.0)
    }
}

impl Mul<u32> for EthGas {
    type Output = EthGas;

    fn mul(self, rhs: u32) -> Self::Output {
        EthGas(self.0 * u64::from(rhs))
    }
}

impl Mul<u64> for EthGas {
    type Output = EthGas;

    fn mul(self, rhs: u64) -> Self::Output {
        EthGas(self.0 * rhs)
    }
}

impl Mul<EthGas> for u64 {
    type Output = EthGas;

    fn mul(self, rhs: EthGas) -> Self::Output {
        EthGas(self * rhs.0)
    }
}

'''
'''--- aurora-engine-2.8.1/engine-types/src/types/mod.rs ---
use crate::{str, vec, String, Vec, U256};
use borsh::{BorshDeserialize, BorshSerialize};

pub mod address;
pub mod balance;
pub mod fee;
pub mod gas;
pub mod wei;

pub use address::*;
pub use balance::*;
pub use fee::*;
pub use gas::*;
pub use wei::*;

pub type RawU256 = [u8; 32];
// Big-endian large integer type.
pub type RawH256 = [u8; 32]; // Unformatted binary data of fixed length.

pub type StorageUsage = u64;

/// Selector to call mint function in ERC 20 contract
///
/// keccak("mint(address,uint256)".as_bytes())[..4];
#[allow(dead_code)]
pub const ERC20_MINT_SELECTOR: &[u8] = &[64, 193, 15, 25];

#[derive(Debug)]
pub enum AddressValidationError {
    FailedDecodeHex,
    IncorrectLength,
}

impl AsRef<[u8]> for AddressValidationError {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::FailedDecodeHex => b"FAILED_DECODE_ETH_ADDRESS",
            Self::IncorrectLength => b"ETH_WRONG_ADDRESS_LENGTH",
        }
    }
}

pub const STORAGE_PRICE_PER_BYTE: u128 = 10_000_000_000_000_000_000;
// 1e19yN, 0.00001N
pub const ERR_FAILED_PARSE: &str = "ERR_FAILED_PARSE";
pub const ERR_INVALID_ETH_ADDRESS: &str = "ERR_INVALID_ETH_ADDRESS";

/// Internal args format for meta call.
#[derive(Debug)]
pub struct InternalMetaCallArgs {
    pub sender: Address,
    pub nonce: U256,
    pub fee_amount: Wei,
    pub fee_address: Address,
    pub contract_address: Address,
    pub value: Wei,
    pub input: Vec<u8>,
}

pub struct StorageBalanceBounds {
    pub min: Yocto,
    pub max: Option<Yocto>,
}

/// promise results structure
#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
pub enum PromiseResult {
    NotReady,
    Successful(Vec<u8>),
    Failed,
}

impl PromiseResult {
    pub fn size(&self) -> usize {
        match self {
            Self::Failed | Self::NotReady => 1,
            Self::Successful(bytes) => bytes.len(),
        }
    }
}

/// ft_resolve_transfer result of eth-connector
pub struct FtResolveTransferResult {
    pub amount: Balance,
    pub refund_amount: Balance,
}

const HEX_ALPHABET: &[u8; 16] = b"0123456789abcdef";

#[allow(dead_code)]
pub fn bytes_to_hex(v: &[u8]) -> String {
    let mut result = String::new();
    for x in v {
        result.push(char::from(HEX_ALPHABET[usize::from(x / 16)]));
        result.push(char::from(HEX_ALPHABET[usize::from(x % 16)]));
    }
    result
}

#[derive(Default)]
pub struct Stack<T> {
    stack: Vec<T>,
    boundaries: Vec<usize>,
}

impl<T> Stack<T> {
    pub fn new() -> Self {
        Self {
            stack: Vec::new(),
            boundaries: vec![0],
        }
    }

    pub fn enter(&mut self) {
        self.boundaries.push(self.stack.len());
    }

    pub fn commit(&mut self) {
        self.boundaries.pop().unwrap();
    }

    pub fn discard(&mut self) {
        let boundary = self.boundaries.pop().unwrap();
        self.stack.truncate(boundary);
    }

    pub fn push(&mut self, value: T) {
        self.stack.push(value);
    }

    pub fn into_vec(self) -> Vec<T> {
        self.stack
    }
}

pub fn str_from_slice(inp: &[u8]) -> &str {
    str::from_utf8(inp).unwrap()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_hex() {
        assert_eq!(
            bytes_to_hex(&[0u8, 1u8, 255u8, 16u8]),
            "0001ff10".to_string()
        );
    }

    /// Build view of the stack. Intervals between None values are scopes.
    fn view_stack(stack: &Stack<i32>) -> Vec<Option<i32>> {
        let mut res = vec![];
        let mut pnt = 0;

        for &pos in stack.boundaries.iter() {
            while pnt < pos {
                res.push(Some(stack.stack[pnt]));
                pnt += 1;
            }
            res.push(None);
        }

        while pnt < stack.stack.len() {
            res.push(Some(stack.stack[pnt]));
            pnt += 1;
        }

        res
    }

    fn check_stack(stack: &Stack<i32>, expected: Vec<Option<i32>>) {
        if let Some(&last) = stack.boundaries.last() {
            assert!(last <= stack.stack.len());
        }
        assert_eq!(view_stack(stack), expected);
    }

    #[test]
    fn test_stack() {
        let mut stack = Stack::new(); // [ $ ]
        check_stack(&stack, vec![None]);

        stack.push(1); // [ $, 1]
        check_stack(&stack, vec![None, Some(1)]);
        stack.push(2); // [ $, 1, 2 ]
        check_stack(&stack, vec![None, Some(1), Some(2)]);
        stack.enter(); // [$, 1, 2, $]
        check_stack(&stack, vec![None, Some(1), Some(2), None]);
        stack.push(3); // [$, 1, 2, $, 3]
        check_stack(&stack, vec![None, Some(1), Some(2), None, Some(3)]);
        stack.discard(); // [$, 1, 2]
        check_stack(&stack, vec![None, Some(1), Some(2)]);
        stack.enter();
        check_stack(&stack, vec![None, Some(1), Some(2), None]);
        stack.push(4); // [$, 1, 2, $, 4]
        check_stack(&stack, vec![None, Some(1), Some(2), None, Some(4)]);
        stack.enter(); // [$, 1, 2, $, 4, $]
        check_stack(&stack, vec![None, Some(1), Some(2), None, Some(4), None]);
        stack.push(5); // [$, 1, 2, $, 4, $, 5]
        check_stack(
            &stack,
            vec![None, Some(1), Some(2), None, Some(4), None, Some(5)],
        );
        stack.commit(); // [$, 1, 2, $, 4, 5]
        check_stack(&stack, vec![None, Some(1), Some(2), None, Some(4), Some(5)]);
        stack.discard(); // [$, 1, 2]
        check_stack(&stack, vec![None, Some(1), Some(2)]);
        stack.push(6); // [$, 1, 2, 6]
        check_stack(&stack, vec![None, Some(1), Some(2), Some(6)]);
        stack.enter(); // [$, 1, 2, 6, $]
        check_stack(&stack, vec![None, Some(1), Some(2), Some(6), None]);
        stack.enter(); // [$, 1, 2, 6, $, $]
        check_stack(&stack, vec![None, Some(1), Some(2), Some(6), None, None]);
        stack.enter(); // [$, 1, 2, 6, $, $, $]
        check_stack(
            &stack,
            vec![None, Some(1), Some(2), Some(6), None, None, None],
        );
        stack.commit(); // [$, 1, 2, 6, $, $]
        check_stack(&stack, vec![None, Some(1), Some(2), Some(6), None, None]);
        stack.discard(); // [$, 1, 2, 6, $]
        check_stack(&stack, vec![None, Some(1), Some(2), Some(6), None]);
        stack.push(7); // [$, 1, 2, 6, $, 7]

        assert_eq!(stack.into_vec(), vec![1, 2, 6, 7]);
    }
}

'''
'''--- aurora-engine-2.8.1/engine-types/src/types/wei.rs ---
use crate::fmt::Formatter;
use crate::types::balance::error;
use crate::types::Fee;
use crate::{Add, Display, Sub, SubAssign, U256};
use borsh::{BorshDeserialize, BorshSerialize};
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

pub const ZERO_NEP141_WEI: NEP141Wei = NEP141Wei::new(0);
pub const ZERO_WEI: Wei = Wei::new_u64(0);

/// Wei compatible Borsh-encoded raw value to attach an ETH balance to the transaction
pub type WeiU256 = [u8; 32];

// Type representing the NEP-141 balances of the eth-connector (ie Wei amounts that have been bridged to Near)
#[derive(
    Default, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd, BorshSerialize, BorshDeserialize,
)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct NEP141Wei(u128);

impl Display for NEP141Wei {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl NEP141Wei {
    /// Constructs a new `NEP141Wei` with a given u128 value.
    pub const fn new(amount: u128) -> Self {
        Self(amount)
    }

    pub fn checked_sub(self, rhs: Self) -> Option<Self> {
        self.0.checked_sub(rhs.0).map(Self)
    }

    pub fn checked_add(self, rhs: Self) -> Option<Self> {
        self.0.checked_add(rhs.0).map(Self)
    }

    /// Consumes `NEP141Wei` and returns the underlying type.
    pub fn as_u128(self) -> u128 {
        self.0
    }
}

impl Sub<NEP141Wei> for NEP141Wei {
    type Output = Self;

    fn sub(self, rhs: Self) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

impl Add<NEP141Wei> for NEP141Wei {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl SubAssign<NEP141Wei> for NEP141Wei {
    fn sub_assign(&mut self, rhs: Self) {
        *self = *self - rhs;
    }
}

/// Newtype to distinguish balances (denominated in Wei) from other U256 types.
#[derive(Default, Debug, Clone, Copy, Eq, PartialEq, Ord, PartialOrd)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct Wei(U256);

impl Wei {
    const ETH_TO_WEI: U256 = U256([1_000_000_000_000_000_000, 0, 0, 0]);

    pub const fn zero() -> Self {
        Self(U256([0, 0, 0, 0]))
    }

    pub const fn new(amount: U256) -> Self {
        Self(amount)
    }

    // Purposely not implementing `From<u64>` because I want the call site to always
    // say `Wei::<something>`. If `From` is implemented then the caller might write
    // `amount.into()` without thinking too hard about the units. Explicitly writing
    // `Wei` reminds the developer to think about whether the amount they enter is really
    // in units of `Wei` or not.
    pub const fn new_u64(amount: u64) -> Self {
        Self(U256([amount, 0, 0, 0]))
    }

    pub fn from_eth(amount: U256) -> Option<Self> {
        amount.checked_mul(Self::ETH_TO_WEI).map(Self)
    }

    pub fn to_bytes(self) -> [u8; 32] {
        u256_to_arr(&self.0)
    }

    pub fn is_zero(&self) -> bool {
        self.0.is_zero()
    }

    pub fn raw(self) -> U256 {
        self.0
    }

    pub fn checked_sub(self, rhs: Self) -> Option<Self> {
        self.0.checked_sub(rhs.0).map(Self)
    }

    pub fn checked_add(self, rhs: Self) -> Option<Self> {
        self.0.checked_add(rhs.0).map(Self)
    }

    /// Try convert U256 to u128 with checking overflow.
    /// NOTICE: Error can contain only overflow
    pub fn try_into_u128(self) -> Result<u128, error::BalanceOverflowError> {
        self.0.try_into().map_err(|_| error::BalanceOverflowError)
    }
}

impl Display for Wei {
    fn fmt(&self, f: &mut Formatter<'_>) -> crate::fmt::Result {
        self.0.fmt(f)
    }
}

impl Add<Self> for Wei {
    type Output = Wei;

    fn add(self, rhs: Self) -> Self::Output {
        Self(self.0 + rhs.0)
    }
}

impl Sub<Self> for Wei {
    type Output = Wei;

    fn sub(self, rhs: Self) -> Self::Output {
        Self(self.0 - rhs.0)
    }
}

/// Type casting from Wei compatible Borsh-encoded raw value into the Wei value, to attach an ETH balance to the transaction
impl From<WeiU256> for Wei {
    fn from(value: WeiU256) -> Self {
        Wei(U256::from_big_endian(&value))
    }
}

impl From<Fee> for Wei {
    fn from(value: Fee) -> Self {
        Wei(U256::from(value.as_u128()))
    }
}

impl From<NEP141Wei> for Wei {
    fn from(value: NEP141Wei) -> Self {
        Wei(U256::from(value.as_u128()))
    }
}

#[allow(dead_code)]
pub fn u256_to_arr(value: &U256) -> [u8; 32] {
    let mut result = [0u8; 32];
    value.to_big_endian(&mut result);
    result
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_wei_from_eth() {
        let eth_amount: u64 = rand::random();
        let wei_amount = U256::from(eth_amount) * U256::from(10).pow(18.into());
        assert_eq!(Wei::from_eth(eth_amount.into()), Some(Wei::new(wei_amount)));
    }

    #[test]
    fn test_wei_from_u64() {
        let x: u64 = rand::random();
        assert_eq!(Wei::new_u64(x).raw().as_u64(), x);
    }
}

'''
'''--- aurora-engine-2.8.1/engine/Cargo.toml ---
[package]
name = "aurora-engine"
version = "2.8.0"
authors = ["Aurora Labs <hello@aurora.dev>"]
edition = "2021"
description = ""
documentation = ""
readme = true
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "CC0-1.0"
publish = false
autobenches = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
aurora-engine-types = { path = "../engine-types", default-features = false }
aurora-engine-sdk = { path = "../engine-sdk", default-features = false }
aurora-engine-precompiles = { path = "../engine-precompiles", default-features = false }
aurora-engine-transactions = { path = "../engine-transactions", default-features = false }
base64 = { version = "0.13.0", default-features = false, features = ["alloc"] }
bitflags = { version = "1.3", default-features = false }
borsh = { version = "0.9.3", default-features = false }
byte-slice-cast = { version = "1.0", default-features = false }
ethabi = { version = "18.0", default-features = false }
evm = { git = "https://github.com/aurora-is-near/sputnikvm.git", tag = "v0.37.3-aurora", default-features = false }
hex = { version = "0.4", default-features = false, features = ["alloc"] }
rjson = { git = "https://github.com/aurora-is-near/rjson", rev = "cc3da949", default-features = false, features = ["integer"] }
rlp = { version = "0.5.0", default-features = false }
serde = { version = "1", features = ["derive"], optional = true }

[target.'cfg(target_arch = "wasm32")'.dependencies]
wee_alloc = { version = "0.4.5", default-features = false }

[dev-dependencies]
aurora-engine-test-doubles = { path = "../engine-test-doubles" }
serde_json = "1"
test-case = "2.1"
sha3 = "0.10"
digest = "0.10"

[features]
default = ["std"]
std = ["aurora-engine-types/std", "aurora-engine-sdk/std", "aurora-engine-precompiles/std", "aurora-engine-transactions/std", "base64/std", "borsh/std", "byte-slice-cast/std", "ethabi/std", "evm/std", "hex/std", "rjson/std", "rlp/std"]
contract = ["aurora-engine-sdk/contract", "aurora-engine-precompiles/contract"]
evm_bully = []
log = ["aurora-engine-sdk/log", "aurora-engine-precompiles/log"]
tracing = ["evm/tracing"]
error_refund = ["aurora-engine-precompiles/error_refund"]
integration-test = ["log"]
all-promise-actions = ["aurora-engine-sdk/all-promise-actions"]
mainnet = ["contract", "log", "aurora-engine-sdk/mainnet"]
testnet = ["contract", "log", "aurora-engine-sdk/testnet"]
impl-serde = ["aurora-engine-types/impl-serde", "serde", "aurora-engine-transactions/impl-serde", "evm/with-serde"]

'''
'''--- aurora-engine-2.8.1/engine/src/accounting.rs ---
use aurora_engine_types::U256;
use core::cmp::Ordering;

/// This struct tracks changes to the supply of a U256 quantity.
/// It is used in our code to keep track of the total supply of ETH on Aurora.
/// This struct is intentionally designed to avoid doing subtraction as much as possible
/// to avoid complexities of signed values and over/underflow.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct Accounting {
    gained: U256,
    lost: U256,
}

impl Accounting {
    pub fn change(&mut self, amount: Change) {
        match amount.new_value.cmp(&amount.old_value) {
            Ordering::Greater => {
                let net_gained = amount.new_value - amount.old_value;
                self.gained = self.gained.saturating_add(net_gained);
            }
            Ordering::Less => {
                let net_lost = amount.old_value - amount.new_value;
                self.lost = self.lost.saturating_add(net_lost);
            }
            Ordering::Equal => (),
        }
    }

    pub fn remove(&mut self, amount: U256) {
        self.lost = self.lost.saturating_add(amount);
    }

    pub fn net(&self) -> Net {
        match self.gained.cmp(&self.lost) {
            Ordering::Equal => Net::Zero,
            Ordering::Greater => Net::Gained(self.gained - self.lost),
            Ordering::Less => Net::Lost(self.lost - self.gained),
        }
    }
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Default)]
pub struct Change {
    pub new_value: U256,
    pub old_value: U256,
}

#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum Net {
    Zero,
    Gained(U256),
    Lost(U256),
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_removing_loss_is_same_as_decreasing_change() {
        let loss = U256::from(16u64);
        let change = Change {
            new_value: U256::zero(),
            old_value: loss,
        };

        let mut changed_accounting = Accounting::default();
        changed_accounting.change(change);

        let mut removed_accounting = Accounting::default();
        removed_accounting.remove(loss);

        assert_eq!(removed_accounting, changed_accounting);
    }

    #[test]
    fn test_removing_loss_nets_loss() {
        let mut actual_accounting = Accounting::default();

        let loss = U256::from(16u64);

        actual_accounting.remove(loss);

        let actual_net = actual_accounting.net();
        let expected_net = Net::Lost(loss);

        assert_eq!(expected_net, actual_net);
    }

    #[test]
    fn test_equal_change_nets_zero() {
        let mut actual_accounting = Accounting::default();

        let value = U256::from(16u64);
        let equal_change = Change {
            new_value: value,
            old_value: value,
        };

        actual_accounting.change(equal_change);

        let actual_net = actual_accounting.net();
        let expected_net = Net::Zero;

        assert_eq!(expected_net, actual_net);
    }

    #[test]
    fn test_decreasing_change_nets_loss() {
        let mut actual_accounting = Accounting::default();

        let new_value = U256::from(16u64);
        let old_value = U256::from(32u64);
        let decreasing_change = Change {
            new_value,
            old_value,
        };

        actual_accounting.change(decreasing_change);

        let actual_net = actual_accounting.net();
        let expected_net = Net::Lost(U256::from(16u64));

        assert_eq!(expected_net, actual_net);
    }

    #[test]
    fn test_increasing_change_nets_gain() {
        let mut actual_accounting = Accounting::default();

        let new_value = U256::from(32u64);
        let old_value = U256::from(16u64);
        let increasing_change = Change {
            new_value,
            old_value,
        };

        actual_accounting.change(increasing_change);

        let actual_net = actual_accounting.net();
        let expected_net = Net::Gained(U256::from(16u64));

        assert_eq!(expected_net, actual_net);
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/admin_controlled.rs ---
pub type PausedMask = u8;

pub const ERR_PAUSED: &str = "ERR_PAUSED";

pub trait AdminControlled {
    /// Return the current mask representing all paused events.
    fn get_paused(&self) -> PausedMask;

    /// Update mask with all paused events.
    /// Implementor is responsible for guaranteeing that this function can only be
    /// called by owner of the contract.
    fn set_paused(&mut self, paused: PausedMask);

    /// Return if the contract is paused for the current flag and user
    fn is_paused(&self, flag: PausedMask, is_owner: bool) -> bool {
        (self.get_paused() & flag) != 0 && !is_owner
    }

    /// Asserts the passed paused flag is not set. Returns `PausedError` if paused.
    fn assert_not_paused(&self, flag: PausedMask, is_owner: bool) -> Result<(), PausedError> {
        if self.is_paused(flag, is_owner) {
            Err(PausedError)
        } else {
            Ok(())
        }
    }
}

pub struct PausedError;

impl AsRef<[u8]> for PausedError {
    fn as_ref(&self) -> &[u8] {
        ERR_PAUSED.as_bytes()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    struct MockAdminControlled {
        mask: PausedMask,
    }

    impl MockAdminControlled {
        pub fn new() -> Self {
            Self { mask: 0 }
        }
    }

    impl AdminControlled for MockAdminControlled {
        fn get_paused(&self) -> PausedMask {
            self.mask
        }

        fn set_paused(&mut self, paused: PausedMask) {
            self.mask = paused
        }
    }

    #[test]
    fn test_setting_paused_mask_with_1_bit_marks_it_as_paused() {
        let is_owner = false;
        let mask = 1u8;
        let mut admin_controlled = MockAdminControlled::new();

        assert!(!admin_controlled.is_paused(mask, is_owner));
        admin_controlled.set_paused(mask);
        assert!(admin_controlled.is_paused(mask, is_owner));
    }

    #[test]
    fn test_setting_paused_mask_with_0_bit_marks_it_as_not_paused() {
        let is_owner = false;
        let mask = 1u8;
        let mut admin_controlled = MockAdminControlled::new();
        admin_controlled.set_paused(mask);

        assert!(admin_controlled.is_paused(mask, is_owner));
        admin_controlled.set_paused(0u8);
        assert!(!admin_controlled.is_paused(mask, is_owner));
    }

    #[test]
    fn test_setting_paused_mask_with_1_bit_fails_to_assert_not_paused() {
        let is_owner = false;
        let mask = 1u8;
        let admin_controlled = MockAdminControlled::new();

        let result = admin_controlled.assert_not_paused(mask, is_owner);
        assert!(result.is_ok(), "asserting as paused failed");
    }

    #[test]
    fn test_setting_paused_mask_with_0_bit_asserts_not_paused() {
        let is_owner = false;
        let mask = 1u8;
        let mut admin_controlled = MockAdminControlled::new();

        admin_controlled.set_paused(mask);
        let error = admin_controlled
            .assert_not_paused(mask, is_owner)
            .expect_err("asserting as not paused failed");

        let expected_error_message = b"ERR_PAUSED";
        let actual_error_message = error.as_ref();
        assert_eq!(expected_error_message, actual_error_message);
    }

    #[test]
    fn test_paused_mask_has_no_effect_on_owner() {
        let is_owner = true;
        let mask = 1u8;
        let mut admin_controlled = MockAdminControlled::new();

        admin_controlled.set_paused(mask);
        assert!(!admin_controlled.is_paused(mask, is_owner));
    }

    #[test]
    fn test_asserting_paused_mask_has_no_effect_on_owner() {
        let is_owner = true;
        let mask = 1u8;
        let mut admin_controlled = MockAdminControlled::new();

        admin_controlled.set_paused(mask);
        let result = admin_controlled.assert_not_paused(mask, is_owner);
        assert!(result.is_ok(), "asserting as not paused failed");
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/connector.rs ---
use crate::admin_controlled::{AdminControlled, PausedMask};
use crate::deposit_event::{DepositedEvent, FtTransferMessageData, TokenMessageData};
use crate::engine::Engine;
use crate::fungible_token::{self, FungibleToken, FungibleTokenMetadata, FungibleTokenOps};
use crate::parameters::{
    BalanceOfCallArgs, BalanceOfEthCallArgs, FinishDepositCallArgs, InitCallArgs,
    NEP141FtOnTransferArgs, PauseEthConnectorCallArgs, ResolveTransferCallArgs,
    SetContractDataCallArgs, StorageBalanceOfCallArgs, StorageDepositCallArgs,
    StorageWithdrawCallArgs, TransferCallArgs, TransferCallCallArgs, WithdrawResult,
};
use crate::prelude::{
    address::error::AddressError, NEP141Wei, Wei, U256, ZERO_NEP141_WEI, ZERO_WEI,
};
use crate::prelude::{
    format, sdk, str, AccountId, Address, BorshDeserialize, BorshSerialize, EthConnectorStorageId,
    KeyPrefix, NearGas, PromiseResult, ToString, Vec, WithdrawCallArgs, Yocto, ERR_FAILED_PARSE,
};
use crate::prelude::{PromiseBatchAction, PromiseCreateArgs, PromiseWithCallbackArgs};
use crate::proof::Proof;
use aurora_engine_sdk::env::Env;
use aurora_engine_sdk::io::{StorageIntermediate, IO};

pub const ERR_NOT_ENOUGH_BALANCE_FOR_FEE: &str = "ERR_NOT_ENOUGH_BALANCE_FOR_FEE";
/// Indicate zero attached balance for promise call
pub const ZERO_ATTACHED_BALANCE: Yocto = Yocto::new(0);
/// NEAR Gas for calling `fininsh_deposit` promise. Used in the `deposit` logic.
pub const GAS_FOR_FINISH_DEPOSIT: NearGas = NearGas::new(50_000_000_000_000);
/// NEAR Gas for calling `verify_log_entry` promise. Used in the `deposit` logic.
// Note: Is 40Tgas always enough?
const GAS_FOR_VERIFY_LOG_ENTRY: NearGas = NearGas::new(40_000_000_000_000);

/// Admin control flow flag indicates that all control flow unpause (unblocked).
pub const UNPAUSE_ALL: PausedMask = 0;
/// Admin control flow flag indicates that the deposit is paused.
pub const PAUSE_DEPOSIT: PausedMask = 1 << 0;
/// Admin control flow flag indicates that withdrawal is paused.
pub const PAUSE_WITHDRAW: PausedMask = 1 << 1;

/// Eth-connector contract data. It's stored in the storage.
/// Contains:
/// * connector specific data
/// * Fungible token data
/// * paused_mask - admin control flow data
/// * io - I/O trait handler
pub struct EthConnectorContract<I: IO> {
    contract: EthConnector,
    ft: FungibleTokenOps<I>,
    paused_mask: PausedMask,
    io: I,
}

/// Connector specific data. It always should contain `prover account` -
#[derive(BorshSerialize, BorshDeserialize)]
pub struct EthConnector {
    /// It used in the Deposit flow, to verify log entry form incoming proof.
    pub prover_account: AccountId,
    /// It is Eth address, used in the Deposit and Withdraw logic.
    pub eth_custodian_address: Address,
}

impl<I: IO + Copy> EthConnectorContract<I> {
    /// Init Eth-connector contract instance.
    /// Load contract data from storage and init I/O handler.
    /// Used as single point of contract access for various contract actions
    pub fn init_instance(io: I) -> Result<Self, error::StorageReadError> {
        Ok(Self {
            contract: get_contract_data(&io, &EthConnectorStorageId::Contract)?,
            ft: get_contract_data::<FungibleToken, I>(&io, &EthConnectorStorageId::FungibleToken)?
                .ops(io),
            paused_mask: get_contract_data(&io, &EthConnectorStorageId::PausedMask)?,
            io,
        })
    }

    /// Create contract data - init eth-connector contract specific data.
    /// Used only once for first time initialization.
    /// Initialized contract data stored in the storage.
    pub fn create_contract(
        mut io: I,
        owner_id: AccountId,
        args: InitCallArgs,
    ) -> Result<(), error::InitContractError> {
        // Check is it already initialized
        let contract_key_exists =
            io.storage_has_key(&construct_contract_key(&EthConnectorStorageId::Contract));
        if contract_key_exists {
            return Err(error::InitContractError::AlreadyInitialized);
        }

        sdk::log!("[init contract]");

        let contract_data = set_contract_data(
            &mut io,
            SetContractDataCallArgs {
                prover_account: args.prover_account,
                eth_custodian_address: args.eth_custodian_address,
                metadata: args.metadata,
            },
        )
        .map_err(error::InitContractError::InvalidCustodianAddress)?;

        let mut ft = FungibleTokenOps::new(io);
        // Register FT account for current contract
        ft.internal_register_account(&owner_id);

        let paused_mask = UNPAUSE_ALL;
        io.write_borsh(
            &construct_contract_key(&EthConnectorStorageId::PausedMask),
            &paused_mask,
        );

        Self {
            contract: contract_data,
            ft,
            paused_mask,
            io,
        }
        .save_ft_contract();

        Ok(())
    }

    /// Deposit all types of tokens
    pub fn deposit(
        &self,
        raw_proof: Vec<u8>,
        current_account_id: AccountId,
        predecessor_account_id: AccountId,
    ) -> Result<PromiseWithCallbackArgs, error::DepositError> {
        // Check is current account owner
        let is_owner = current_account_id == predecessor_account_id;
        // Check is current flow paused. If it's owner account just skip it.
        self.assert_not_paused(PAUSE_DEPOSIT, is_owner)
            .map_err(|_| error::DepositError::Paused)?;

        sdk::log!("[Deposit tokens]");

        // Get incoming deposit arguments
        let proof: Proof =
            Proof::try_from_slice(&raw_proof).map_err(|_| error::DepositError::ProofParseFailed)?;
        // Fetch event data from Proof
        let event = DepositedEvent::from_log_entry_data(&proof.log_entry_data)
            .map_err(error::DepositError::EventParseFailed)?;

        sdk::log!(
            "Deposit started: from {} to recipient {:?} with amount: {:?} and fee {:?}",
            event.sender.encode(),
            event.token_message_data.recipient(),
            event.amount,
            event.fee
        );

        sdk::log!(
            "Event's address {}, custodian address {}",
            event.eth_custodian_address.encode(),
            self.contract.eth_custodian_address.encode(),
        );

        if event.eth_custodian_address != self.contract.eth_custodian_address {
            return Err(error::DepositError::CustodianAddressMismatch);
        }

        if NEP141Wei::new(event.fee.as_u128()) >= event.amount {
            return Err(error::DepositError::InsufficientAmountForFee);
        }

        // Verify proof data with cross-contract call to prover account
        sdk::log!(
            "Deposit verify_log_entry for prover: {}",
            self.contract.prover_account,
        );

        // Do not skip bridge call. This is only used for development and diagnostics.
        let skip_bridge_call = false.try_to_vec().unwrap();
        let mut proof_to_verify = raw_proof;
        proof_to_verify.extend(skip_bridge_call);

        let verify_call = PromiseCreateArgs {
            target_account_id: self.contract.prover_account.clone(),
            method: "verify_log_entry".to_string(),
            args: proof_to_verify,
            attached_balance: ZERO_ATTACHED_BALANCE,
            attached_gas: GAS_FOR_VERIFY_LOG_ENTRY,
        };

        // Finalize deposit
        let data = match event.token_message_data {
            // Deposit to NEAR accounts
            TokenMessageData::Near(account_id) => FinishDepositCallArgs {
                new_owner_id: account_id,
                amount: event.amount,
                proof_key: proof.key(),
                relayer_id: predecessor_account_id,
                fee: event.fee,
                msg: None,
            }
            .try_to_vec()
            .unwrap(),
            // Deposit to Eth accounts
            // fee is being minted in the `ft_on_transfer` callback method
            TokenMessageData::Eth {
                receiver_id,
                message,
            } => {
                // Transfer to self and then transfer ETH in `ft_on_transfer`
                // address - is NEAR account
                let transfer_data = TransferCallCallArgs {
                    receiver_id,
                    amount: event.amount,
                    memo: None,
                    msg: message.encode(),
                }
                .try_to_vec()
                .unwrap();

                // Send to self - current account id
                FinishDepositCallArgs {
                    new_owner_id: current_account_id.clone(),
                    amount: event.amount,
                    proof_key: proof.key(),
                    relayer_id: predecessor_account_id,
                    fee: event.fee,
                    msg: Some(transfer_data),
                }
                .try_to_vec()
                .unwrap()
            }
        };

        let finish_call = PromiseCreateArgs {
            target_account_id: current_account_id,
            method: "finish_deposit".to_string(),
            args: data,
            attached_balance: ZERO_ATTACHED_BALANCE,
            attached_gas: GAS_FOR_FINISH_DEPOSIT,
        };
        Ok(PromiseWithCallbackArgs {
            base: verify_call,
            callback: finish_call,
        })
    }

    /// Finish deposit (private method)
    /// NOTE: we should `record_proof` only after `mint` operation. The reason
    /// is that in this case we only calculate the amount to be credited but
    /// do not save it, however, if an error occurs during the calculation,
    /// this will happen before `record_proof`. After that contract will save.
    pub fn finish_deposit(
        &mut self,
        predecessor_account_id: AccountId,
        current_account_id: AccountId,
        data: FinishDepositCallArgs,
        prepaid_gas: NearGas,
    ) -> Result<Option<PromiseWithCallbackArgs>, error::FinishDepositError> {
        sdk::log!("Finish deposit with the amount: {}", data.amount);

        // Mint tokens to recipient minus fee
        if let Some(msg) = data.msg {
            // Mint - calculate new balances
            self.mint_eth_on_near(data.new_owner_id, data.amount)?;
            // Store proof only after `mint` calculations
            self.record_proof(&data.proof_key)?;
            // Save new contract data
            self.save_ft_contract();
            let transfer_call_args = TransferCallCallArgs::try_from_slice(&msg).unwrap();
            let promise = self.ft_transfer_call(
                predecessor_account_id,
                current_account_id,
                transfer_call_args,
                prepaid_gas,
            )?;
            Ok(Some(promise))
        } else {
            // Mint - calculate new balances
            self.mint_eth_on_near(
                data.new_owner_id.clone(),
                data.amount - NEP141Wei::new(data.fee.as_u128()),
            )?;
            self.mint_eth_on_near(data.relayer_id, NEP141Wei::new(data.fee.as_u128()))?;
            // Store proof only after `mint` calculations
            self.record_proof(&data.proof_key)?;
            // Save new contract data
            self.save_ft_contract();
            Ok(None)
        }
    }

    /// Internal ETH withdraw ETH logic
    pub(crate) fn internal_remove_eth(
        &mut self,
        amount: Wei,
    ) -> Result<(), fungible_token::error::WithdrawError> {
        self.burn_eth_on_aurora(amount)?;
        self.save_ft_contract();
        Ok(())
    }

    /// Record used proof as hash key
    fn record_proof(&mut self, key: &str) -> Result<(), error::ProofUsed> {
        sdk::log!("Record proof: {}", key);

        if self.is_used_event(key) {
            return Err(error::ProofUsed);
        }

        self.save_used_event(key);
        Ok(())
    }

    ///  Mint nETH tokens
    fn mint_eth_on_near(
        &mut self,
        owner_id: AccountId,
        amount: NEP141Wei,
    ) -> Result<(), fungible_token::error::DepositError> {
        sdk::log!("Mint {} nETH tokens for: {}", amount, owner_id);

        if self.ft.get_account_eth_balance(&owner_id).is_none() {
            self.ft.accounts_insert(&owner_id, ZERO_NEP141_WEI);
        }
        self.ft.internal_deposit_eth_to_near(&owner_id, amount)
    }

    ///  Mint ETH tokens
    fn mint_eth_on_aurora(
        &mut self,
        owner_id: Address,
        amount: Wei,
    ) -> Result<(), fungible_token::error::DepositError> {
        sdk::log!("Mint {} ETH tokens for: {}", amount, owner_id.encode());
        self.ft.internal_deposit_eth_to_aurora(owner_id, amount)
    }

    /// Burn ETH tokens
    fn burn_eth_on_aurora(
        &mut self,
        amount: Wei,
    ) -> Result<(), fungible_token::error::WithdrawError> {
        self.ft.internal_withdraw_eth_from_aurora(amount)
    }

    /// Withdraw nETH from NEAR accounts
    /// NOTE: it should be without any log data
    pub fn withdraw_eth_from_near(
        &mut self,
        current_account_id: &AccountId,
        predecessor_account_id: &AccountId,
        args: WithdrawCallArgs,
    ) -> Result<WithdrawResult, error::WithdrawError> {
        // Check is current account id is owner
        let is_owner = current_account_id == predecessor_account_id;
        // Check is current flow paused. If it's owner just skip asserrion.
        self.assert_not_paused(PAUSE_WITHDRAW, is_owner)
            .map_err(|_| error::WithdrawError::Paused)?;

        // Burn tokens to recipient
        self.ft
            .internal_withdraw_eth_from_near(predecessor_account_id, args.amount)?;
        // Save new contract data
        self.save_ft_contract();

        Ok(WithdrawResult {
            recipient_id: args.recipient_address,
            amount: args.amount,
            eth_custodian_address: self.contract.eth_custodian_address,
        })
    }

    /// Returns total ETH supply on NEAR (nETH as NEP-141 token)
    pub fn ft_total_eth_supply_on_near(&mut self) {
        let total_supply = self.ft.ft_total_eth_supply_on_near();
        sdk::log!("Total ETH supply on NEAR: {}", total_supply);
        self.io
            .return_output(format!("\"{}\"", total_supply).as_bytes());
    }

    /// Returns total ETH supply on Aurora (ETH in Aurora EVM)
    pub fn ft_total_eth_supply_on_aurora(&mut self) {
        let total_supply = self.ft.ft_total_eth_supply_on_aurora();
        sdk::log!("Total ETH supply on Aurora: {}", total_supply);
        self.io
            .return_output(format!("\"{}\"", total_supply).as_bytes());
    }

    /// Return balance of nETH (ETH on Near)
    pub fn ft_balance_of(&mut self, args: BalanceOfCallArgs) {
        let balance = self.ft.ft_balance_of(&args.account_id);
        sdk::log!("Balance of nETH [{}]: {}", args.account_id, balance);

        self.io.return_output(format!("\"{}\"", balance).as_bytes());
    }

    /// Return balance of ETH (ETH in Aurora EVM)
    pub fn ft_balance_of_eth_on_aurora(
        &mut self,
        args: BalanceOfEthCallArgs,
    ) -> Result<(), crate::prelude::types::balance::error::BalanceOverflowError> {
        let balance = self
            .ft
            .internal_unwrap_balance_of_eth_on_aurora(&args.address);
        sdk::log!("Balance of ETH [{}]: {}", args.address.encode(), balance);
        self.io.return_output(format!("\"{}\"", balance).as_bytes());
        Ok(())
    }

    /// Transfer between NEAR accounts
    pub fn ft_transfer(
        &mut self,
        predecessor_account_id: &AccountId,
        args: TransferCallArgs,
    ) -> Result<(), fungible_token::error::TransferError> {
        self.ft.internal_transfer_eth_on_near(
            predecessor_account_id,
            &args.receiver_id,
            args.amount,
            &args.memo,
        )?;
        self.save_ft_contract();
        sdk::log!(
            "Transfer amount {} to {} success with memo: {:?}",
            args.amount,
            args.receiver_id,
            args.memo
        );
        Ok(())
    }

    /// FT resolve transfer logic
    pub fn ft_resolve_transfer(
        &mut self,
        args: ResolveTransferCallArgs,
        promise_result: PromiseResult,
    ) {
        let amount = self.ft.ft_resolve_transfer(
            promise_result,
            &args.sender_id,
            &args.receiver_id,
            args.amount,
        );
        sdk::log!(
            "Resolve transfer from {} to {} success",
            args.sender_id,
            args.receiver_id
        );
        // `ft_resolve_transfer` can change `total_supply` so we should save the contract
        self.save_ft_contract();
        self.io.return_output(format!("\"{}\"", amount).as_bytes());
    }

    /// FT transfer call from sender account (invoker account) to receiver
    /// We starting early checking for message data to avoid `ft_on_transfer` call panics
    /// But we don't check relayer exists. If relayer doesn't exist we simply not mint/burn the amount of the fee
    /// We allow empty messages for cases when `receiver_id =! current_account_id`
    pub fn ft_transfer_call(
        &mut self,
        predecessor_account_id: AccountId,
        current_account_id: AccountId,
        args: TransferCallCallArgs,
        prepaid_gas: NearGas,
    ) -> Result<PromiseWithCallbackArgs, error::FtTransferCallError> {
        sdk::log!(
            "Transfer call to {} amount {}",
            args.receiver_id,
            args.amount,
        );

        // Verify message data before `ft_on_transfer` call to avoid verification panics
        // It's allowed empty message if `receiver_id =! current_account_id`
        if args.receiver_id == current_account_id {
            let message_data = FtTransferMessageData::parse_on_transfer_message(&args.msg)
                .map_err(error::FtTransferCallError::MessageParseFailed)?;
            // Check is transfer amount > fee
            if message_data.fee.as_u128() >= args.amount.as_u128() {
                return Err(error::FtTransferCallError::InsufficientAmountForFee);
            }

            // Additional check overflow before process `ft_on_transfer`
            // But don't check overflow for relayer
            // Note: It can't overflow because the total supply doesn't change during transfer.
            let amount_for_check = self
                .ft
                .internal_unwrap_balance_of_eth_on_aurora(&message_data.recipient);
            if amount_for_check
                .checked_add(Wei::from(args.amount))
                .is_none()
            {
                return Err(error::FtTransferCallError::Transfer(
                    fungible_token::error::TransferError::BalanceOverflow,
                ));
            }
            if self
                .ft
                .total_eth_supply_on_aurora
                .checked_add(Wei::from(args.amount))
                .is_none()
            {
                return Err(error::FtTransferCallError::Transfer(
                    fungible_token::error::TransferError::TotalSupplyOverflow,
                ));
            }
        }

        self.ft
            .ft_transfer_call(
                predecessor_account_id,
                args.receiver_id,
                args.amount,
                &args.memo,
                args.msg,
                current_account_id,
                prepaid_gas,
            )
            .map_err(Into::into)
    }

    /// FT storage deposit logic
    pub fn storage_deposit(
        &mut self,
        predecessor_account_id: AccountId,
        amount: Yocto,
        args: StorageDepositCallArgs,
    ) -> Result<Option<PromiseBatchAction>, fungible_token::error::StorageFundingError> {
        let account_id = args
            .account_id
            .unwrap_or_else(|| predecessor_account_id.clone());
        let (res, maybe_promise) = self.ft.storage_deposit(
            predecessor_account_id,
            &account_id,
            amount,
            args.registration_only,
        )?;
        self.save_ft_contract();
        self.io.return_output(&res.to_json_bytes());
        Ok(maybe_promise)
    }

    /// FT storage unregister
    pub fn storage_unregister(
        &mut self,
        account_id: AccountId,
        force: Option<bool>,
    ) -> Result<Option<PromiseBatchAction>, fungible_token::error::StorageFundingError> {
        let promise = match self.ft.internal_storage_unregister(account_id, force) {
            Ok((_, p)) => {
                self.io.return_output(b"true");
                Some(p)
            }
            Err(fungible_token::error::StorageFundingError::NotRegistered) => {
                self.io.return_output(b"false");
                None
            }
            Err(other) => return Err(other),
        };
        Ok(promise)
    }

    /// FT storage withdraw
    pub fn storage_withdraw(
        &mut self,
        account_id: &AccountId,
        args: StorageWithdrawCallArgs,
    ) -> Result<(), fungible_token::error::StorageFundingError> {
        let res = self.ft.storage_withdraw(account_id, args.amount)?;
        self.save_ft_contract();
        self.io.return_output(&res.to_json_bytes());
        Ok(())
    }

    /// Get balance of storage
    pub fn storage_balance_of(&mut self, args: StorageBalanceOfCallArgs) {
        self.io
            .return_output(&self.ft.storage_balance_of(&args.account_id).to_json_bytes());
    }

    /// ft_on_transfer callback function
    pub fn ft_on_transfer<'env, E: Env>(
        &mut self,
        engine: &Engine<'env, I, E>,
        args: &NEP141FtOnTransferArgs,
    ) -> Result<(), error::FtTransferCallError> {
        sdk::log!("Call ft_on_transfer");
        // Parse message with specific rules
        let message_data = FtTransferMessageData::parse_on_transfer_message(&args.msg)
            .map_err(error::FtTransferCallError::MessageParseFailed)?;

        // Special case when predecessor_account_id is current_account_id
        let wei_fee = Wei::from(message_data.fee);
        // Mint fee to relayer
        let relayer = engine.get_relayer(message_data.relayer.as_bytes());
        match (wei_fee, relayer) {
            (fee, Some(evm_relayer_address)) if fee > ZERO_WEI => {
                self.mint_eth_on_aurora(
                    message_data.recipient,
                    Wei::new(U256::from(args.amount.as_u128())) - fee,
                )?;
                self.mint_eth_on_aurora(evm_relayer_address, fee)?;
            }
            _ => self.mint_eth_on_aurora(
                message_data.recipient,
                Wei::new(U256::from(args.amount.as_u128())),
            )?,
        }
        self.save_ft_contract();
        self.io.return_output("\"0\"".as_bytes());
        Ok(())
    }

    /// Get accounts counter for statistics.
    /// It represents total unique accounts (all-time, including accounts which now have zero balance).
    pub fn get_accounts_counter(&mut self) {
        self.io
            .return_output(&self.ft.get_accounts_counter().to_le_bytes());
    }

    pub fn get_bridge_prover(&self) -> &AccountId {
        &self.contract.prover_account
    }

    /// Save eth-connector fungible token contract data
    fn save_ft_contract(&mut self) {
        self.io.write_borsh(
            &construct_contract_key(&EthConnectorStorageId::FungibleToken),
            &self.ft.data(),
        );
    }

    /// Generate key for used events from Proof
    fn used_event_key(&self, key: &str) -> Vec<u8> {
        let mut v = construct_contract_key(&EthConnectorStorageId::UsedEvent).to_vec();
        v.extend_from_slice(key.as_bytes());
        v
    }

    /// Save already used event proof as hash key
    fn save_used_event(&mut self, key: &str) {
        self.io.write_borsh(&self.used_event_key(key), &0u8);
    }

    /// Check is event of proof already used
    fn is_used_event(&self, key: &str) -> bool {
        self.io.storage_has_key(&self.used_event_key(key))
    }

    /// Checks whether the provided proof was already used
    pub fn is_used_proof(&self, proof: Proof) -> bool {
        self.is_used_event(&proof.key())
    }

    /// Get Eth connector paused flags
    pub fn get_paused_flags(&self) -> PausedMask {
        self.get_paused()
    }

    /// Set Eth connector paused flags
    pub fn set_paused_flags(&mut self, args: PauseEthConnectorCallArgs) {
        self.set_paused(args.paused_mask);
    }
}

impl<I: IO + Copy> AdminControlled for EthConnectorContract<I> {
    /// Get current admin paused status
    fn get_paused(&self) -> PausedMask {
        self.paused_mask
    }

    /// Set admin paused status
    fn set_paused(&mut self, paused_mask: PausedMask) {
        self.paused_mask = paused_mask;
        self.io.write_borsh(
            &construct_contract_key(&EthConnectorStorageId::PausedMask),
            &self.paused_mask,
        );
    }
}

fn construct_contract_key(suffix: &EthConnectorStorageId) -> Vec<u8> {
    crate::prelude::bytes_to_key(KeyPrefix::EthConnector, &[u8::from(*suffix)])
}

fn get_contract_data<T: BorshDeserialize, I: IO>(
    io: &I,
    suffix: &EthConnectorStorageId,
) -> Result<T, error::StorageReadError> {
    io.read_storage(&construct_contract_key(suffix))
        .ok_or(error::StorageReadError::KeyNotFound)
        .and_then(|x| {
            x.to_value()
                .map_err(|_| error::StorageReadError::BorshDeserialize)
        })
}

/// Sets the contract data and returns it back
pub fn set_contract_data<I: IO>(
    io: &mut I,
    args: SetContractDataCallArgs,
) -> Result<EthConnector, AddressError> {
    // Get initial contract arguments
    let contract_data = EthConnector {
        prover_account: args.prover_account,
        eth_custodian_address: Address::decode(&args.eth_custodian_address)?,
    };
    // Save eth-connector specific data
    io.write_borsh(
        &construct_contract_key(&EthConnectorStorageId::Contract),
        &contract_data,
    );

    io.write_borsh(
        &construct_contract_key(&EthConnectorStorageId::FungibleTokenMetadata),
        &args.metadata,
    );

    Ok(contract_data)
}

/// Return metdata
pub fn get_metadata<I: IO>(io: &I) -> Option<FungibleTokenMetadata> {
    io.read_storage(&construct_contract_key(
        &EthConnectorStorageId::FungibleTokenMetadata,
    ))
    .and_then(|data| data.to_value().ok())
}

pub mod error {
    use crate::errors;
    use aurora_engine_types::types::address::error::AddressError;
    use aurora_engine_types::types::balance::error::BalanceOverflowError;

    use crate::deposit_event::error::ParseOnTransferMessageError;
    use crate::{deposit_event, fungible_token};

    const PROOF_EXIST: &[u8; 15] = errors::ERR_PROOF_EXIST;

    #[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
    pub enum StorageReadError {
        KeyNotFound,
        BorshDeserialize,
    }

    impl AsRef<[u8]> for StorageReadError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::KeyNotFound => errors::ERR_CONNECTOR_STORAGE_KEY_NOT_FOUND,
                Self::BorshDeserialize => errors::ERR_FAILED_DESERIALIZE_CONNECTOR_DATA,
            }
        }
    }

    #[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
    pub enum DepositError {
        Paused,
        ProofParseFailed,
        EventParseFailed(deposit_event::error::ParseError),
        CustodianAddressMismatch,
        InsufficientAmountForFee,
        InvalidAddress(AddressError),
    }

    impl AsRef<[u8]> for DepositError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::Paused => crate::admin_controlled::ERR_PAUSED.as_bytes(),
                Self::ProofParseFailed => super::ERR_FAILED_PARSE.as_bytes(),
                Self::EventParseFailed(e) => e.as_ref(),
                Self::CustodianAddressMismatch => errors::ERR_WRONG_EVENT_ADDRESS,
                Self::InsufficientAmountForFee => super::ERR_NOT_ENOUGH_BALANCE_FOR_FEE.as_bytes(),
                Self::InvalidAddress(e) => e.as_ref(),
            }
        }
    }

    #[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
    pub enum FinishDepositError {
        TransferCall(FtTransferCallError),
        ProofUsed,
    }

    impl From<ProofUsed> for FinishDepositError {
        fn from(_: ProofUsed) -> Self {
            Self::ProofUsed
        }
    }

    impl From<FtTransferCallError> for FinishDepositError {
        fn from(e: FtTransferCallError) -> Self {
            Self::TransferCall(e)
        }
    }

    impl From<fungible_token::error::DepositError> for FinishDepositError {
        fn from(e: fungible_token::error::DepositError) -> Self {
            Self::TransferCall(FtTransferCallError::Transfer(e.into()))
        }
    }

    impl AsRef<[u8]> for FinishDepositError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::ProofUsed => PROOF_EXIST,
                Self::TransferCall(e) => e.as_ref(),
            }
        }
    }

    #[derive(Debug)]
    pub enum WithdrawError {
        Paused,
        FT(fungible_token::error::WithdrawError),
    }

    impl From<fungible_token::error::WithdrawError> for WithdrawError {
        fn from(e: fungible_token::error::WithdrawError) -> Self {
            Self::FT(e)
        }
    }

    impl AsRef<[u8]> for WithdrawError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::Paused => crate::admin_controlled::ERR_PAUSED.as_bytes(),
                Self::FT(e) => e.as_ref(),
            }
        }
    }

    #[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
    pub enum FtTransferCallError {
        BalanceOverflow(BalanceOverflowError),
        MessageParseFailed(ParseOnTransferMessageError),
        InsufficientAmountForFee,
        Transfer(fungible_token::error::TransferError),
    }

    impl From<fungible_token::error::TransferError> for FtTransferCallError {
        fn from(e: fungible_token::error::TransferError) -> Self {
            Self::Transfer(e)
        }
    }

    impl From<fungible_token::error::DepositError> for FtTransferCallError {
        fn from(e: fungible_token::error::DepositError) -> Self {
            Self::Transfer(e.into())
        }
    }

    impl From<ParseOnTransferMessageError> for FtTransferCallError {
        fn from(e: ParseOnTransferMessageError) -> Self {
            Self::MessageParseFailed(e)
        }
    }

    impl AsRef<[u8]> for FtTransferCallError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::MessageParseFailed(e) => e.as_ref(),
                Self::InsufficientAmountForFee => super::ERR_NOT_ENOUGH_BALANCE_FOR_FEE.as_bytes(),
                Self::Transfer(e) => e.as_ref(),
                Self::BalanceOverflow(e) => e.as_ref(),
            }
        }
    }

    #[derive(Debug)]
    pub enum InitContractError {
        AlreadyInitialized,
        InvalidCustodianAddress(AddressError),
    }

    impl AsRef<[u8]> for InitContractError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::AlreadyInitialized => errors::ERR_CONTRACT_INITIALIZED,
                Self::InvalidCustodianAddress(e) => e.as_ref(),
            }
        }
    }

    pub struct ProofUsed;

    impl AsRef<[u8]> for ProofUsed {
        fn as_ref(&self) -> &[u8] {
            PROOF_EXIST
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/deposit_event.rs ---
use crate::deposit_event::error::ParseEventMessageError;
use crate::log_entry::LogEntry;
use crate::prelude::account_id::AccountId;
use crate::prelude::{
    vec, Address, BorshDeserialize, BorshSerialize, Fee, NEP141Wei, String, ToString, Vec, U256,
};
use aurora_engine_types::types::address::error::AddressError;
use byte_slice_cast::AsByteSlice;
use ethabi::{Event, EventParam, Hash, Log, ParamType, RawLog};

pub const DEPOSITED_EVENT: &str = "Deposited";

pub type EventParams = Vec<EventParam>;

/// On-transfer message. Used for `ft_transfer_call` and  `ft_on_transfer` functions.
/// Message parsed from input args with `parse_on_transfer_message`.
#[derive(BorshSerialize, BorshDeserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Eq))]
pub struct FtTransferMessageData {
    pub relayer: AccountId,
    pub recipient: Address,
    pub fee: Fee,
}

impl FtTransferMessageData {
    /// Get on-transfer data from arguments message field.
    /// Used for `ft_transfer_call` and `ft_on_transfer`
    pub fn parse_on_transfer_message(
        message: &str,
    ) -> Result<Self, error::ParseOnTransferMessageError> {
        // Split message by separator
        let data: Vec<_> = message.split(':').collect();
        // Message data array should contain 2 elements
        if data.len() != 2 {
            return Err(error::ParseOnTransferMessageError::TooManyParts);
        }

        // Check relayer account id from 1-th data element
        let account_id = AccountId::try_from(data[0].as_bytes())
            .map_err(|_| error::ParseOnTransferMessageError::InvalidAccount)?;

        // Decode message array from 2-th element of data array
        let msg =
            hex::decode(data[1]).map_err(|_| error::ParseOnTransferMessageError::InvalidHexData)?;
        // Length = fee[32] + eth_address[20] bytes
        if msg.len() != 52 {
            return Err(error::ParseOnTransferMessageError::WrongMessageFormat);
        }

        // Parse fee from message slice. It should contain 32 bytes
        // But after that in will be parse to u128
        // That logic for compatability.
        let mut raw_fee: [u8; 32] = Default::default();
        raw_fee.copy_from_slice(&msg[..32]);
        let fee_u128: u128 = U256::from_little_endian(&raw_fee)
            .try_into()
            .map_err(|_| error::ParseOnTransferMessageError::OverflowNumber)?;
        let fee: Fee = fee_u128.into();

        // Get recipient Eth address from message slice
        let recipient = Address::try_from_slice(&msg[32..52]).unwrap();

        Ok(FtTransferMessageData {
            relayer: account_id,
            recipient,
            fee,
        })
    }

    /// Encode to String with specific rules
    pub fn encode(&self) -> String {
        // The first data section should contain fee data.
        // Pay attention, that for compatibility reasons we used U256 type
        // it means 32 bytes for fee data
        let mut data = U256::from(self.fee.as_u128()).as_byte_slice().to_vec();
        // Second data section should contain Eth address
        data.extend(self.recipient.as_bytes());
        // Add `:` separator between relayer_id and data message
        [self.relayer.as_ref(), &hex::encode(data)].join(":")
    }

    /// Prepare message for `ft_transfer_call` -> `ft_on_transfer`
    pub fn prepare_message_for_on_transfer(
        relayer_account_id: &AccountId,
        fee: Fee,
        recipient: String,
    ) -> Result<Self, ParseEventMessageError> {
        let address = if recipient.len() == 42 {
            recipient
                .strip_prefix("0x")
                .ok_or(ParseEventMessageError::EthAddressValidationError(
                    AddressError::FailedDecodeHex,
                ))?
                .to_string()
        } else {
            recipient
        };

        let recipient_address =
            Address::decode(&address).map_err(ParseEventMessageError::EthAddressValidationError)?;

        Ok(Self {
            relayer: relayer_account_id.clone(),
            recipient: recipient_address,
            fee,
        })
    }
}

/// Token message data used for Deposit flow.
/// It contains two basic data structure: Near, Eth
/// The message parsed from event `recipient` field - `log_entry_data`
/// after fetching proof `log_entry_data`
#[derive(BorshSerialize, BorshDeserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Eq))]
pub enum TokenMessageData {
    /// Deposit no NEAR account
    Near(AccountId),
    ///Deposit to Eth accounts fee is being minted in the `ft_on_transfer` callback method
    Eth {
        receiver_id: AccountId,
        message: FtTransferMessageData,
    },
}

impl TokenMessageData {
    /// Parse event message data for tokens. Data parsed form event `recipient` field.
    /// Used for Deposit flow.
    /// For Eth logic flow message validated and prepared for  `ft_on_transfer` logic.
    /// It mean validating Eth address correctness and preparing message for
    /// parsing for `ft_on_transfer` message parsing with correct and validated data.
    pub fn parse_event_message_and_prepare_token_message_data(
        message: &str,
        fee: Fee,
    ) -> Result<TokenMessageData, error::ParseEventMessageError> {
        let data: Vec<_> = message.split(':').collect();
        // Data array can contain 1 or 2 elements
        if data.len() >= 3 {
            return Err(error::ParseEventMessageError::TooManyParts);
        }
        let account_id = AccountId::try_from(data[0].as_bytes())
            .map_err(|_| error::ParseEventMessageError::InvalidAccount)?;

        // If data array contain only one element it should return NEAR account id
        if data.len() == 1 {
            Ok(TokenMessageData::Near(account_id))
        } else {
            let raw_message = data[1].into();
            let message = FtTransferMessageData::prepare_message_for_on_transfer(
                &account_id,
                fee,
                raw_message,
            )?;

            Ok(TokenMessageData::Eth {
                receiver_id: account_id,
                message,
            })
        }
    }

    // Get recipient account id from Eth part of Token message data
    pub fn recipient(&self) -> AccountId {
        match self {
            Self::Near(acc) => acc.clone(),
            Self::Eth {
                receiver_id,
                message: _,
            } => receiver_id.clone(),
        }
    }
}

/// Ethereum event
pub struct EthEvent {
    pub eth_custodian_address: Address,
    pub log: Log,
}

#[allow(dead_code)]
impl EthEvent {
    /// Get Ethereum event from `log_entry_data`
    pub fn fetch_log_entry_data(
        name: &str,
        params: EventParams,
        data: &[u8],
    ) -> Result<Self, error::DecodeError> {
        let event = Event {
            name: name.to_string(),
            inputs: params,
            anonymous: false,
        };
        let log_entry: LogEntry = rlp::decode(data).map_err(|_| error::DecodeError::RlpFailed)?;
        let eth_custodian_address = Address::new(log_entry.address);
        let topics = log_entry.topics.iter().map(|h| Hash::from(h.0)).collect();

        let raw_log = RawLog {
            topics,
            data: log_entry.data,
        };
        let log = event
            .parse_log(raw_log)
            .map_err(|_| error::DecodeError::SchemaMismatch)?;

        Ok(Self {
            eth_custodian_address,
            log,
        })
    }
}

/// Data that was emitted by Deposited event.
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Eq))]
pub struct DepositedEvent {
    pub eth_custodian_address: Address,
    pub sender: Address,
    pub token_message_data: TokenMessageData,
    pub amount: NEP141Wei,
    pub fee: Fee,
}

impl DepositedEvent {
    #[allow(dead_code)]
    pub fn event_params() -> EventParams {
        vec![
            EventParam {
                name: "sender".to_string(),
                kind: ParamType::Address,
                indexed: true,
            },
            EventParam {
                name: "recipient".to_string(),
                kind: ParamType::String,
                indexed: false,
            },
            EventParam {
                name: "amount".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
            EventParam {
                name: "fee".to_string(),
                kind: ParamType::Uint(256),
                indexed: false,
            },
        ]
    }

    /// Parses raw Ethereum logs proof's entry data
    pub fn from_log_entry_data(data: &[u8]) -> Result<Self, error::ParseError> {
        let event = EthEvent::fetch_log_entry_data(DEPOSITED_EVENT, Self::event_params(), data)
            .map_err(error::ParseError::LogParseFailed)?;
        let raw_sender = event.log.params[0]
            .value
            .clone()
            .into_address()
            .ok_or(error::ParseError::InvalidSender)?
            .0;
        let sender = Address::from_array(raw_sender);

        // parse_event_message
        let event_message_data: String = event.log.params[1].value.clone().to_string();

        let amount = event.log.params[2]
            .value
            .clone()
            .into_uint()
            .ok_or(error::ParseError::InvalidAmount)?
            .try_into()
            .map(NEP141Wei::new)
            .map_err(|_| error::ParseError::OverflowNumber)?;
        let fee = event.log.params[3]
            .value
            .clone()
            .into_uint()
            .ok_or(error::ParseError::InvalidFee)?
            .try_into()
            .map(|v| Fee::new(NEP141Wei::new(v)))
            .map_err(|_| error::ParseError::OverflowNumber)?;

        let token_message_data =
            TokenMessageData::parse_event_message_and_prepare_token_message_data(
                &event_message_data,
                fee,
            )?;

        Ok(Self {
            eth_custodian_address: event.eth_custodian_address,
            sender,
            token_message_data,
            amount,
            fee,
        })
    }
}

pub mod error {
    use super::*;
    use crate::errors;

    #[derive(Debug)]
    pub enum DecodeError {
        RlpFailed,
        SchemaMismatch,
    }
    impl AsRef<[u8]> for DecodeError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::RlpFailed => errors::ERR_RLP_FAILED,
                Self::SchemaMismatch => errors::ERR_PARSE_DEPOSIT_EVENT,
            }
        }
    }

    #[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
    pub enum ParseEventMessageError {
        TooManyParts,
        InvalidAccount,
        EthAddressValidationError(AddressError),
    }

    impl AsRef<[u8]> for ParseEventMessageError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::TooManyParts => errors::ERR_INVALID_EVENT_MESSAGE_FORMAT,
                Self::InvalidAccount => errors::ERR_INVALID_ACCOUNT_ID,
                Self::EthAddressValidationError(e) => e.as_ref(),
            }
        }
    }

    impl From<ParseEventMessageError> for ParseError {
        fn from(e: ParseEventMessageError) -> Self {
            Self::MessageParseFailed(e)
        }
    }

    #[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
    pub enum ParseError {
        LogParseFailed(DecodeError),
        InvalidSender,
        InvalidAmount,
        InvalidFee,
        MessageParseFailed(ParseEventMessageError),
        OverflowNumber,
    }

    impl AsRef<[u8]> for ParseError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::LogParseFailed(e) => e.as_ref(),
                Self::InvalidSender => errors::ERR_INVALID_SENDER,
                Self::InvalidAmount => errors::ERR_INVALID_AMOUNT,
                Self::InvalidFee => errors::ERR_INVALID_FEE,
                Self::MessageParseFailed(e) => e.as_ref(),
                Self::OverflowNumber => errors::ERR_OVERFLOW_NUMBER,
            }
        }
    }

    #[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
    pub enum ParseOnTransferMessageError {
        TooManyParts,
        InvalidHexData,
        WrongMessageFormat,
        InvalidAccount,
        OverflowNumber,
    }

    impl AsRef<[u8]> for ParseOnTransferMessageError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::TooManyParts => errors::ERR_INVALID_ON_TRANSFER_MESSAGE_FORMAT,
                Self::InvalidHexData => errors::ERR_INVALID_ON_TRANSFER_MESSAGE_HEX,
                Self::WrongMessageFormat => errors::ERR_INVALID_ON_TRANSFER_MESSAGE_DATA,
                Self::InvalidAccount => errors::ERR_INVALID_ACCOUNT_ID,
                Self::OverflowNumber => errors::ERR_OVERFLOW_NUMBER,
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::errors;
    use aurora_engine_precompiles::make_address;
    use aurora_engine_types::H160;

    #[test]
    fn test_decoded_and_then_encoded_message_does_not_change() {
        let expect_message =
            "aurora:05000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000";
        let message_data =
            FtTransferMessageData::parse_on_transfer_message(expect_message).unwrap();
        let actual_message = message_data.encode();

        assert_eq!(expect_message, actual_message);
    }

    #[test]
    fn test_parsing_message_with_incorrect_amount_of_parts() {
        let message = "foo";
        let error = FtTransferMessageData::parse_on_transfer_message(message).unwrap_err();
        let expected_error_message = errors::ERR_INVALID_ON_TRANSFER_MESSAGE_FORMAT;
        let actual_error_message = error.as_ref();

        assert_eq!(expected_error_message, actual_error_message);
    }

    #[test]
    fn test_parsing_message_with_invalid_account_id() {
        let message = "INVALID:0";
        let error = FtTransferMessageData::parse_on_transfer_message(message).unwrap_err();
        let expected_error_message = errors::ERR_INVALID_ACCOUNT_ID;
        let actual_error_message = error.as_ref();

        assert_eq!(expected_error_message, actual_error_message);
    }

    #[test]
    fn test_parsing_message_with_invalid_hex_data() {
        let message = "foo:INVALID";
        let error = FtTransferMessageData::parse_on_transfer_message(message).unwrap_err();
        let expected_error_message = errors::ERR_INVALID_ON_TRANSFER_MESSAGE_HEX;
        let actual_error_message = error.as_ref();

        assert_eq!(expected_error_message, actual_error_message);
    }

    #[test]
    fn test_parsing_message_with_invalid_length_of_hex_data() {
        let message = "foo:dead";
        let error = FtTransferMessageData::parse_on_transfer_message(message).unwrap_err();
        let expected_error_message = errors::ERR_INVALID_ON_TRANSFER_MESSAGE_DATA;
        let actual_error_message = error.as_ref();

        assert_eq!(expected_error_message, actual_error_message);
    }

    #[test]
    fn test_parsing_message_with_overflowing_fee() {
        let message =
            "foo:ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff";
        let error = FtTransferMessageData::parse_on_transfer_message(message).unwrap_err();
        let expected_error_message = errors::ERR_OVERFLOW_NUMBER;
        let actual_error_message = error.as_ref();

        assert_eq!(expected_error_message, actual_error_message);
    }

    #[test]
    fn test_eth_token_message_data_decodes_recipient_correctly() {
        let fee = Fee::new(NEP141Wei::new(0));
        let address = Address::zero();
        let message = format!("aurora:{}", address.encode());

        let token_message_data =
            TokenMessageData::parse_event_message_and_prepare_token_message_data(&message, fee)
                .unwrap();
        let actual_recipient = token_message_data.recipient().to_string();
        let expected_recipient = "aurora";

        assert_eq!(expected_recipient, actual_recipient);
    }

    #[test]
    fn test_eth_token_message_data_decodes_recipient_correctly_with_prefix() {
        let fee = Fee::new(NEP141Wei::new(0));
        let address = Address::zero();
        let message = format!("aurora:0x{}", address.encode());

        let token_message_data =
            TokenMessageData::parse_event_message_and_prepare_token_message_data(&message, fee)
                .unwrap();
        let actual_recipient = token_message_data.recipient().to_string();
        let expected_recipient = "aurora";

        assert_eq!(expected_recipient, actual_recipient);
    }

    #[test]
    fn test_near_token_message_data_decodes_recipient_correctly() {
        let fee = Fee::new(NEP141Wei::new(0));
        let message = "aurora";

        let token_message_data =
            TokenMessageData::parse_event_message_and_prepare_token_message_data(message, fee)
                .unwrap();
        let actual_recipient = token_message_data.recipient().to_string();
        let expected_recipient = "aurora";

        assert_eq!(expected_recipient, actual_recipient);
    }

    #[test]
    fn test_token_message_data_fails_with_too_many_parts() {
        let fee = Fee::new(NEP141Wei::new(0));
        let message = "aurora:foo:bar";

        let parse_error =
            TokenMessageData::parse_event_message_and_prepare_token_message_data(message, fee)
                .unwrap_err();
        let actual_parse_error = parse_error.as_ref();
        let expected_parse_error = errors::ERR_INVALID_EVENT_MESSAGE_FORMAT;

        assert_eq!(expected_parse_error, actual_parse_error);
    }

    #[test]
    fn test_token_message_data_fails_with_invalid_account() {
        let fee = Fee::new(NEP141Wei::new(0));
        let message = "INVALID";

        let parse_error =
            TokenMessageData::parse_event_message_and_prepare_token_message_data(message, fee)
                .unwrap_err();
        let actual_parse_error = parse_error.as_ref();
        let expected_parse_error = errors::ERR_INVALID_ACCOUNT_ID;

        assert_eq!(expected_parse_error, actual_parse_error);
    }

    #[test]
    fn test_eth_token_message_data_fails_with_invalid_address_length() {
        let fee = Fee::new(NEP141Wei::new(0));
        let message = "aurora:0xINVALID";

        let parse_error =
            TokenMessageData::parse_event_message_and_prepare_token_message_data(message, fee)
                .unwrap_err();
        let actual_parse_error = std::str::from_utf8(parse_error.as_ref()).unwrap();
        let expected_parse_error = AddressError::IncorrectLength.to_string();

        assert_eq!(expected_parse_error, actual_parse_error);
    }

    #[test]
    fn test_eth_token_message_data_fails_with_invalid_address() {
        let fee = Fee::new(NEP141Wei::new(0));
        let message = "aurora:0xINVALID_ADDRESS_WITH_CORRECT_LENGTH_HERE";

        let parse_error =
            TokenMessageData::parse_event_message_and_prepare_token_message_data(message, fee)
                .unwrap_err();
        let actual_parse_error = std::str::from_utf8(parse_error.as_ref()).unwrap();
        let expected_parse_error = AddressError::FailedDecodeHex.to_string();

        assert_eq!(expected_parse_error, actual_parse_error);
    }

    #[test]
    fn test_deposited_event_parses_from_log_entry_successfully() {
        let recipient_address = Address::zero();
        let eth_custodian_address = make_address(0xd045f7e1, 0x9b2488924b97f9c145b5e51d0d895a65);

        let fee = Fee::new(NEP141Wei::new(0));
        let message = ["aurora", ":", recipient_address.encode().as_str()].concat();
        let token_message_data: TokenMessageData =
            TokenMessageData::parse_event_message_and_prepare_token_message_data(&message, fee)
                .unwrap();

        let expected_deposited_event = DepositedEvent {
            eth_custodian_address,
            sender: Address::new(H160([0u8; 20])),
            token_message_data,
            amount: NEP141Wei::new(0),
            fee,
        };

        let event_schema = Event {
            name: DEPOSITED_EVENT.into(),
            inputs: DepositedEvent::event_params(),
            anonymous: false,
        };
        let log_entry = LogEntry {
            address: eth_custodian_address.raw(),
            topics: vec![
                event_schema.signature(),
                // the sender is not important
                crate::prelude::H256::zero(),
            ],
            data: ethabi::encode(&[
                ethabi::Token::String(message),
                ethabi::Token::Uint(U256::from(expected_deposited_event.amount.as_u128())),
                ethabi::Token::Uint(U256::from(expected_deposited_event.fee.as_u128())),
            ]),
        };

        let log_entry_data = rlp::encode(&log_entry).to_vec();
        let actual_deposited_event = DepositedEvent::from_log_entry_data(&log_entry_data).unwrap();

        assert_eq!(expected_deposited_event, actual_deposited_event);
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/engine.rs ---
use crate::parameters::{CallArgs, NEP141FtOnTransferArgs, ResultLog, SubmitResult, ViewCallArgs};
use core::mem;
use evm::backend::{Apply, ApplyBackend, Backend, Basic, Log};
use evm::executor;
use evm::{Config, CreateScheme, ExitError, ExitFatal, ExitReason};

use crate::connector::EthConnectorContract;
use crate::errors;
use crate::map::BijectionMap;
use aurora_engine_sdk::caching::FullCache;
use aurora_engine_sdk::env::Env;
use aurora_engine_sdk::io::{StorageIntermediate, IO};
use aurora_engine_sdk::promise::{PromiseHandler, PromiseId, ReadOnlyPromiseHandler};

use crate::accounting;
use crate::parameters::{DeployErc20TokenArgs, NewCallArgs, TransactionStatus};
use crate::pausables::{
    EngineAuthorizer, EnginePrecompilesPauser, PausedPrecompilesChecker, PrecompileFlags,
};
use crate::prelude::parameters::RefundCallArgs;
use crate::prelude::precompiles::native::{exit_to_ethereum, exit_to_near};
use crate::prelude::precompiles::xcc::cross_contract_call;
use crate::prelude::precompiles::Precompiles;
use crate::prelude::transactions::{EthTransactionKind, NormalizedEthTransaction};
use crate::prelude::{
    address_to_key, bytes_to_key, sdk, storage_to_key, u256_to_arr, vec, AccountId, Address,
    BTreeMap, BorshDeserialize, BorshSerialize, KeyPrefix, PromiseArgs, PromiseCreateArgs,
    ToString, Vec, Wei, Yocto, ERC20_MINT_SELECTOR, H160, H256, U256,
};
use aurora_engine_precompiles::PrecompileConstructorContext;
use core::cell::RefCell;
use core::iter::once;

/// Used as the first byte in the concatenation of data used to compute the blockhash.
/// Could be useful in the future as a version byte, or to distinguish different types of blocks.
const BLOCK_HASH_PREFIX: u8 = 0;
const BLOCK_HASH_PREFIX_SIZE: usize = 1;
const BLOCK_HEIGHT_SIZE: usize = 8;
const CHAIN_ID_SIZE: usize = 32;

#[cfg(not(feature = "contract"))]
/// Block height where the bug fix for parsing transactions to the zero address
/// is deployed. The current value is only approximate; will be updated once the
/// fix is actually deployed.
pub const ZERO_ADDRESS_FIX_HEIGHT: u64 = 61200152;

pub fn current_address(current_account_id: &AccountId) -> Address {
    aurora_engine_sdk::types::near_account_to_evm_address(current_account_id.as_bytes())
}

macro_rules! unwrap_res_or_finish {
    ($e:expr, $output:expr, $io:expr) => {
        match $e {
            Ok(v) => v,
            Err(_e) => {
                #[cfg(feature = "log")]
                sdk::log(crate::prelude::format!("{:?}", _e).as_str());
                $io.return_output($output);
                return;
            }
        }
    };
}

macro_rules! assert_or_finish {
    ($e:expr, $output:expr, $io:expr) => {
        if !$e {
            $io.return_output($output);
            return;
        }
    };
}

#[derive(Debug, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize))]
pub struct EngineError {
    pub kind: EngineErrorKind,
    pub gas_used: u64,
}

impl From<EngineErrorKind> for EngineError {
    fn from(kind: EngineErrorKind) -> Self {
        Self { kind, gas_used: 0 }
    }
}

impl AsRef<[u8]> for EngineError {
    fn as_ref(&self) -> &[u8] {
        self.kind.as_bytes()
    }
}

/// Errors with the EVM engine.
#[derive(Debug, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize))]
pub enum EngineErrorKind {
    /// Normal EVM errors.
    EvmError(ExitError),
    /// Fatal EVM errors.
    EvmFatal(ExitFatal),
    /// Incorrect nonce.
    IncorrectNonce,
    FailedTransactionParse(crate::prelude::transactions::Error),
    InvalidChainId,
    InvalidSignature,
    IntrinsicGasNotMet,
    MaxPriorityGasFeeTooLarge,
    GasPayment(GasPaymentError),
    GasOverflow,
}

impl EngineErrorKind {
    pub fn with_gas_used(self, gas_used: u64) -> EngineError {
        EngineError {
            kind: self,
            gas_used,
        }
    }

    pub fn as_bytes(&self) -> &[u8] {
        use EngineErrorKind::*;
        match self {
            EvmError(ExitError::StackUnderflow) => errors::ERR_STACK_UNDERFLOW,
            EvmError(ExitError::StackOverflow) => errors::ERR_STACK_OVERFLOW,
            EvmError(ExitError::InvalidJump) => errors::ERR_INVALID_JUMP,
            EvmError(ExitError::InvalidRange) => errors::ERR_INVALID_RANGE,
            EvmError(ExitError::DesignatedInvalid) => errors::ERR_DESIGNATED_INVALID,
            EvmError(ExitError::CallTooDeep) => errors::ERR_CALL_TOO_DEEP,
            EvmError(ExitError::CreateCollision) => errors::ERR_CREATE_COLLISION,
            EvmError(ExitError::CreateContractLimit) => errors::ERR_CREATE_CONTRACT_LIMIT,
            EvmError(ExitError::OutOfOffset) => errors::ERR_OUT_OF_OFFSET,
            EvmError(ExitError::OutOfGas) => errors::ERR_OUT_OF_GAS,
            EvmError(ExitError::OutOfFund) => errors::ERR_OUT_OF_FUND,
            EvmError(ExitError::Other(m)) => m.as_bytes(),
            EvmError(_) => unreachable!(), // unused misc
            EvmFatal(ExitFatal::NotSupported) => errors::ERR_NOT_SUPPORTED,
            EvmFatal(ExitFatal::UnhandledInterrupt) => errors::ERR_UNHANDLED_INTERRUPT,
            EvmFatal(ExitFatal::Other(m)) => m.as_bytes(),
            EvmFatal(_) => unreachable!(), // unused misc
            IncorrectNonce => errors::ERR_INCORRECT_NONCE,
            FailedTransactionParse(e) => e.as_ref(),
            InvalidChainId => errors::ERR_INVALID_CHAIN_ID,
            InvalidSignature => errors::ERR_INVALID_ECDSA_SIGNATURE,
            IntrinsicGasNotMet => errors::ERR_INTRINSIC_GAS,
            MaxPriorityGasFeeTooLarge => errors::ERR_MAX_PRIORITY_FEE_GREATER,
            GasPayment(e) => e.as_ref(),
            GasOverflow => errors::ERR_GAS_OVERFLOW,
        }
    }
}

impl AsRef<[u8]> for EngineErrorKind {
    fn as_ref(&self) -> &[u8] {
        self.as_bytes()
    }
}

impl From<ExitError> for EngineErrorKind {
    fn from(e: ExitError) -> Self {
        EngineErrorKind::EvmError(e)
    }
}

impl From<ExitFatal> for EngineErrorKind {
    fn from(e: ExitFatal) -> Self {
        EngineErrorKind::EvmFatal(e)
    }
}

/// An engine result.
pub type EngineResult<T> = Result<T, EngineError>;

trait ExitIntoResult {
    /// Checks if the EVM exit is ok or an error.
    fn into_result(self, data: Vec<u8>) -> Result<TransactionStatus, EngineErrorKind>;
}

impl ExitIntoResult for ExitReason {
    fn into_result(self, data: Vec<u8>) -> Result<TransactionStatus, EngineErrorKind> {
        use ExitReason::*;
        match self {
            Succeed(_) => Ok(TransactionStatus::Succeed(data)),
            Revert(_) => Ok(TransactionStatus::Revert(data)),
            Error(ExitError::OutOfOffset) => Ok(TransactionStatus::OutOfOffset),
            Error(ExitError::OutOfFund) => Ok(TransactionStatus::OutOfFund),
            Error(ExitError::OutOfGas) => Ok(TransactionStatus::OutOfGas),
            Error(e) => Err(e.into()),
            Fatal(e) => Err(e.into()),
        }
    }
}

#[derive(Debug, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub struct BalanceOverflow;

impl AsRef<[u8]> for BalanceOverflow {
    fn as_ref(&self) -> &[u8] {
        errors::ERR_BALANCE_OVERFLOW
    }
}

/// Errors resulting from trying to pay for gas
#[derive(Debug, Clone, Eq, PartialEq)]
#[cfg_attr(feature = "serde", derive(serde::Serialize, serde::Deserialize))]
pub enum GasPaymentError {
    /// Overflow adding ETH to an account balance (should never happen)
    BalanceOverflow(BalanceOverflow),
    /// Overflow in gas * gas_price calculation
    EthAmountOverflow,
    /// Not enough balance for account to cover the gas cost
    OutOfFund,
}

impl AsRef<[u8]> for GasPaymentError {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::BalanceOverflow(overflow) => overflow.as_ref(),
            Self::EthAmountOverflow => errors::ERR_GAS_ETH_AMOUNT_OVERFLOW,
            Self::OutOfFund => errors::ERR_OUT_OF_FUND,
        }
    }
}

impl From<BalanceOverflow> for GasPaymentError {
    fn from(overflow: BalanceOverflow) -> Self {
        Self::BalanceOverflow(overflow)
    }
}

#[derive(Debug)]
pub enum DeployErc20Error {
    State(EngineStateError),
    Failed(TransactionStatus),
    Engine(EngineError),
    Register(RegisterTokenError),
}

impl AsRef<[u8]> for DeployErc20Error {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::State(e) => e.as_ref(),
            Self::Failed(e) => e.as_ref(),
            Self::Engine(e) => e.as_ref(),
            Self::Register(e) => e.as_ref(),
        }
    }
}

pub struct ERC20Address(pub Address);

impl AsRef<[u8]> for ERC20Address {
    fn as_ref(&self) -> &[u8] {
        self.0.as_bytes()
    }
}

impl TryFrom<Vec<u8>> for ERC20Address {
    type Error = AddressParseError;

    fn try_from(bytes: Vec<u8>) -> Result<Self, Self::Error> {
        if bytes.len() == 20 {
            Ok(Self(
                Address::try_from_slice(&bytes).map_err(|_| AddressParseError)?,
            ))
        } else {
            Err(AddressParseError)
        }
    }
}

pub struct AddressParseError;

impl AsRef<[u8]> for AddressParseError {
    fn as_ref(&self) -> &[u8] {
        errors::ERR_PARSE_ADDRESS
    }
}

pub struct NEP141Account(pub AccountId);

impl AsRef<[u8]> for NEP141Account {
    fn as_ref(&self) -> &[u8] {
        self.0.as_bytes()
    }
}

impl TryFrom<Vec<u8>> for NEP141Account {
    type Error = aurora_engine_types::account_id::ParseAccountError;

    fn try_from(bytes: Vec<u8>) -> Result<Self, Self::Error> {
        AccountId::try_from(bytes).map(Self)
    }
}

pub const ERR_INVALID_NEP141_ACCOUNT_ID: &str = "ERR_INVALID_NEP141_ACCOUNT_ID";

#[derive(Debug)]
pub enum GetErc20FromNep141Error {
    InvalidNep141AccountId,
    Nep141NotFound,
}

impl GetErc20FromNep141Error {
    pub fn to_str(&self) -> &str {
        match self {
            Self::InvalidNep141AccountId => ERR_INVALID_NEP141_ACCOUNT_ID,
            Self::Nep141NotFound => "ERR_NEP141_NOT_FOUND",
        }
    }
}

impl AsRef<[u8]> for GetErc20FromNep141Error {
    fn as_ref(&self) -> &[u8] {
        self.to_str().as_bytes()
    }
}

#[derive(Debug)]
pub enum RegisterTokenError {
    InvalidNep141AccountId,
    TokenAlreadyRegistered,
}

impl RegisterTokenError {
    pub fn to_str(&self) -> &str {
        match self {
            Self::InvalidNep141AccountId => ERR_INVALID_NEP141_ACCOUNT_ID,
            Self::TokenAlreadyRegistered => "ERR_NEP141_TOKEN_ALREADY_REGISTERED",
        }
    }
}

impl AsRef<[u8]> for RegisterTokenError {
    fn as_ref(&self) -> &[u8] {
        self.to_str().as_bytes()
    }
}

#[derive(Debug)]
pub enum EngineStateError {
    NotFound,
    DeserializationFailed,
}

impl AsRef<[u8]> for EngineStateError {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::NotFound => errors::ERR_STATE_NOT_FOUND,
            Self::DeserializationFailed => errors::ERR_STATE_CORRUPTED,
        }
    }
}

pub struct StackExecutorParams<'a, I, E, H> {
    precompiles: Precompiles<'a, I, E, H>,
    gas_limit: u64,
}

impl<'env, I: IO + Copy, E: Env, H: ReadOnlyPromiseHandler> StackExecutorParams<'env, I, E, H> {
    fn new(gas_limit: u64, precompiles: Precompiles<'env, I, E, H>) -> Self {
        Self {
            precompiles,
            gas_limit,
        }
    }

    fn make_executor<'a>(
        &'a self,
        engine: &'a Engine<'env, I, E>,
    ) -> executor::stack::StackExecutor<
        'static,
        'a,
        executor::stack::MemoryStackState<Engine<'env, I, E>>,
        Precompiles<'env, I, E, H>,
    > {
        let metadata = executor::stack::StackSubstateMetadata::new(self.gas_limit, CONFIG);
        let state = executor::stack::MemoryStackState::new(metadata, engine);
        executor::stack::StackExecutor::new_with_precompiles(state, CONFIG, &self.precompiles)
    }
}

#[derive(Debug, Default, PartialEq, Eq)]
pub struct GasPaymentResult {
    pub prepaid_amount: Wei,
    pub effective_gas_price: U256,
    pub priority_fee_per_gas: U256,
}

/// Engine internal state, mostly configuration.
/// Should not contain anything large or enumerable.
#[derive(BorshSerialize, BorshDeserialize, Default, Clone, PartialEq, Eq, Debug)]
pub struct EngineState {
    /// Chain id, according to the EIP-155 / ethereum-lists spec.
    pub chain_id: [u8; 32],
    /// Account which can upgrade this contract.
    /// Use empty to disable updatability.
    pub owner_id: AccountId,
    /// Account of the bridge prover.
    /// Use empty to not use base token as bridged asset.
    pub bridge_prover_id: AccountId,
    /// How many blocks after staging upgrade can deploy it.
    pub upgrade_delay_blocks: u64,
}

impl From<NewCallArgs> for EngineState {
    fn from(args: NewCallArgs) -> Self {
        EngineState {
            chain_id: args.chain_id,
            owner_id: args.owner_id,
            bridge_prover_id: args.bridge_prover_id,
            upgrade_delay_blocks: args.upgrade_delay_blocks,
        }
    }
}

pub struct Engine<'env, I: IO, E: Env> {
    state: EngineState,
    origin: Address,
    gas_price: U256,
    current_account_id: AccountId,
    io: I,
    env: &'env E,
    generation_cache: RefCell<BTreeMap<Address, u32>>,
    account_info_cache: RefCell<FullCache<Address, Basic>>,
    contract_code_cache: RefCell<FullCache<Address, Vec<u8>>>,
    contract_storage_cache: RefCell<FullCache<(Address, H256), H256>>,
}

pub(crate) const CONFIG: &Config = &Config::london();

/// Key for storing the state of the engine.
const STATE_KEY: &[u8; 5] = b"STATE";

impl<'env, I: IO + Copy, E: Env> Engine<'env, I, E> {
    pub fn new(
        origin: Address,
        current_account_id: AccountId,
        io: I,
        env: &'env E,
    ) -> Result<Self, EngineStateError> {
        get_state(&io).map(|state| Self::new_with_state(state, origin, current_account_id, io, env))
    }

    pub fn new_with_state(
        state: EngineState,
        origin: Address,
        current_account_id: AccountId,
        io: I,
        env: &'env E,
    ) -> Self {
        Self {
            state,
            origin,
            gas_price: U256::zero(),
            current_account_id,
            io,
            env,
            generation_cache: RefCell::new(BTreeMap::new()),
            account_info_cache: RefCell::new(FullCache::default()),
            contract_code_cache: RefCell::new(FullCache::default()),
            contract_storage_cache: RefCell::new(FullCache::default()),
        }
    }

    pub fn charge_gas(
        &mut self,
        sender: &Address,
        transaction: &NormalizedEthTransaction,
    ) -> Result<GasPaymentResult, GasPaymentError> {
        if transaction.max_fee_per_gas.is_zero() {
            return Ok(GasPaymentResult::default());
        }

        let priority_fee_per_gas = transaction
            .max_priority_fee_per_gas
            .min(transaction.max_fee_per_gas - self.block_base_fee_per_gas());
        let effective_gas_price = priority_fee_per_gas + self.block_base_fee_per_gas();
        let gas_limit = transaction.gas_limit;
        let prepaid_amount = gas_limit
            .checked_mul(effective_gas_price)
            .map(Wei::new)
            .ok_or(GasPaymentError::EthAmountOverflow)?;

        let new_balance = get_balance(&self.io, sender)
            .checked_sub(prepaid_amount)
            .ok_or(GasPaymentError::OutOfFund)?;

        set_balance(&mut self.io, sender, &new_balance);

        self.gas_price = effective_gas_price;

        Ok(GasPaymentResult {
            prepaid_amount,
            effective_gas_price,
            priority_fee_per_gas,
        })
    }

    pub fn deploy_code_with_input<P: PromiseHandler>(
        &mut self,
        input: Vec<u8>,
        handler: &mut P,
    ) -> EngineResult<SubmitResult> {
        let origin = Address::new(self.origin());
        let value = Wei::zero();
        self.deploy_code(origin, value, input, u64::MAX, Vec::new(), handler)
    }

    pub fn deploy_code<P: PromiseHandler>(
        &mut self,
        origin: Address,
        value: Wei,
        input: Vec<u8>,
        gas_limit: u64,
        access_list: Vec<(H160, Vec<H256>)>, // See EIP-2930
        handler: &mut P,
    ) -> EngineResult<SubmitResult> {
        let pause_flags = EnginePrecompilesPauser::from_io(self.io).paused();
        let precompiles = self.create_precompiles(pause_flags, handler);

        let executor_params = StackExecutorParams::new(gas_limit, precompiles);
        let mut executor = executor_params.make_executor(self);
        let address = executor.create_address(CreateScheme::Legacy {
            caller: origin.raw(),
        });
        let (exit_reason, return_value) =
            executor.transact_create(origin.raw(), value.raw(), input, gas_limit, access_list);
        let result = if exit_reason.is_succeed() {
            address.0.to_vec()
        } else {
            return_value
        };

        let used_gas = executor.used_gas();
        let status = match exit_reason.into_result(result) {
            Ok(status) => status,
            Err(e) => {
                increment_nonce(&mut self.io, &origin);
                return Err(e.with_gas_used(used_gas));
            }
        };

        let (values, logs) = executor.into_state().deconstruct();
        let logs = filter_promises_from_logs(&self.io, handler, logs, &self.current_account_id);

        self.apply(values, Vec::<Log>::new(), true);

        Ok(SubmitResult::new(status, used_gas, logs))
    }

    /// Call the EVM contract with arguments
    pub fn call_with_args<P: PromiseHandler>(
        &mut self,
        args: CallArgs,
        handler: &mut P,
    ) -> EngineResult<SubmitResult> {
        let origin = Address::new(self.origin());
        match args {
            CallArgs::V2(call_args) => {
                let contract = call_args.contract;
                let value = call_args.value.into();
                let input = call_args.input;
                self.call(
                    &origin,
                    &contract,
                    value,
                    input,
                    u64::MAX,
                    Vec::new(),
                    handler,
                )
            }
            CallArgs::V1(call_args) => {
                let contract = call_args.contract;
                let value = Wei::zero();
                let input = call_args.input;
                self.call(
                    &origin,
                    &contract,
                    value,
                    input,
                    u64::MAX,
                    Vec::new(),
                    handler,
                )
            }
        }
    }

    #[allow(clippy::too_many_arguments)]
    pub fn call<P: PromiseHandler>(
        &mut self,
        origin: &Address,
        contract: &Address,
        value: Wei,
        input: Vec<u8>,
        gas_limit: u64,
        access_list: Vec<(H160, Vec<H256>)>, // See EIP-2930
        handler: &mut P,
    ) -> EngineResult<SubmitResult> {
        let pause_flags = EnginePrecompilesPauser::from_io(self.io).paused();
        let precompiles = self.create_precompiles(pause_flags, handler);

        let executor_params = StackExecutorParams::new(gas_limit, precompiles);
        let mut executor = executor_params.make_executor(self);
        let (exit_reason, result) = executor.transact_call(
            origin.raw(),
            contract.raw(),
            value.raw(),
            input,
            gas_limit,
            access_list,
        );

        let used_gas = executor.used_gas();
        let status = match exit_reason.into_result(result) {
            Ok(status) => status,
            Err(e) => {
                increment_nonce(&mut self.io, origin);
                return Err(e.with_gas_used(used_gas));
            }
        };

        let (values, logs) = executor.into_state().deconstruct();
        let logs = filter_promises_from_logs(&self.io, handler, logs, &self.current_account_id);

        // There is no way to return the logs to the NEAR log method as it only
        // allows a return of UTF-8 strings.
        self.apply(values, Vec::<Log>::new(), true);

        Ok(SubmitResult::new(status, used_gas, logs))
    }

    pub fn view_with_args(&self, args: ViewCallArgs) -> Result<TransactionStatus, EngineErrorKind> {
        let origin = &args.sender;
        let contract = &args.address;
        let value = U256::from_big_endian(&args.amount);
        // View calls cannot interact with promises
        let mut handler = aurora_engine_sdk::promise::Noop;
        let pause_flags = EnginePrecompilesPauser::from_io(self.io).paused();
        let precompiles = self.create_precompiles(pause_flags, &mut handler);

        let executor_params = StackExecutorParams::new(u64::MAX, precompiles);
        self.view(
            origin,
            contract,
            Wei::new(value),
            args.input,
            &executor_params,
        )
    }

    pub fn view(
        &self,
        origin: &Address,
        contract: &Address,
        value: Wei,
        input: Vec<u8>,
        executor_params: &StackExecutorParams<I, E, aurora_engine_sdk::promise::Noop>,
    ) -> Result<TransactionStatus, EngineErrorKind> {
        let mut executor = executor_params.make_executor(self);
        let (status, result) = executor.transact_call(
            origin.raw(),
            contract.raw(),
            value.raw(),
            input,
            executor_params.gas_limit,
            Vec::new(),
        );
        status.into_result(result)
    }

    fn relayer_key(account_id: &[u8]) -> Vec<u8> {
        bytes_to_key(KeyPrefix::RelayerEvmAddressMap, account_id)
    }

    pub fn register_relayer(&mut self, account_id: &[u8], evm_address: Address) {
        let key = Self::relayer_key(account_id);
        self.io.write_storage(&key, evm_address.as_bytes());
    }

    pub fn get_relayer(&self, account_id: &[u8]) -> Option<Address> {
        let key = Self::relayer_key(account_id);
        let raw_addr = self.io.read_storage(&key).map(|v| v.to_vec())?;
        Address::try_from_slice(&raw_addr[..]).ok()
    }

    pub fn register_token(
        &mut self,
        erc20_token: Address,
        nep141_token: AccountId,
    ) -> Result<(), RegisterTokenError> {
        match get_erc20_from_nep141(&self.io, &nep141_token) {
            Err(GetErc20FromNep141Error::Nep141NotFound) => (),
            Err(GetErc20FromNep141Error::InvalidNep141AccountId) => {
                return Err(RegisterTokenError::InvalidNep141AccountId);
            }
            Ok(_) => return Err(RegisterTokenError::TokenAlreadyRegistered),
        }

        let erc20_token = ERC20Address(erc20_token);
        let nep141_token = NEP141Account(nep141_token);
        nep141_erc20_map(self.io).insert(&nep141_token, &erc20_token);
        Ok(())
    }

    /// Transfers an amount from a given sender to a receiver, provided that
    /// the have enough in their balance.
    ///
    /// If the sender can send, and the receiver can receive, then the transfer
    /// will execute successfully.
    pub fn transfer<P: PromiseHandler>(
        &mut self,
        sender: Address,
        receiver: Address,
        value: Wei,
        gas_limit: u64,
        handler: &mut P,
    ) -> EngineResult<SubmitResult> {
        self.call(
            &sender,
            &receiver,
            value,
            Vec::new(),
            gas_limit,
            Vec::new(),
            handler,
        )
    }

    /// Mint tokens for recipient on a particular ERC20 token
    /// This function should return the amount of tokens unused,
    /// which will be always all (<amount>) if there is any problem
    /// with the input, or 0 if tokens were minted successfully.
    ///
    /// The output will be serialized as a String
    /// https://github.com/near/NEPs/discussions/146
    ///
    /// IMPORTANT: This function should not panic, otherwise it won't
    /// be possible to return the tokens to the sender.
    pub fn receive_erc20_tokens<P: PromiseHandler>(
        &mut self,
        token: &AccountId,
        args: &NEP141FtOnTransferArgs,
        current_account_id: &AccountId,
        handler: &mut P,
    ) {
        let str_amount = crate::prelude::format!("\"{}\"", args.amount);
        let output_on_fail = str_amount.as_bytes();

        // Parse message to determine recipient
        let recipient = {
            // Message format:
            //      Recipient of the transaction - 40 characters (Address in hex)
            let message = args.msg.as_bytes();
            assert_or_finish!(message.len() >= 40, output_on_fail, self.io);

            Address::new(H160(unwrap_res_or_finish!(
                hex::decode(&message[..40]).unwrap().as_slice().try_into(),
                output_on_fail,
                self.io
            )))
        };

        let erc20_token = Address::from_array(unwrap_res_or_finish!(
            unwrap_res_or_finish!(
                get_erc20_from_nep141(&self.io, token),
                output_on_fail,
                self.io
            )
            .as_slice()
            .try_into(),
            output_on_fail,
            self.io
        ));

        let erc20_admin_address = current_address(current_account_id);
        unwrap_res_or_finish!(
            self.call(
                &erc20_admin_address,
                &erc20_token,
                Wei::zero(),
                setup_receive_erc20_tokens_input(args, &recipient),
                u64::MAX,
                Vec::new(), // TODO: are there values we should put here?
                handler,
            )
            .and_then(|submit_result| {
                match submit_result.status {
                    TransactionStatus::Succeed(_) => Ok(()),
                    TransactionStatus::Revert(bytes) => {
                        let error_message = crate::prelude::format!(
                            "Reverted with message: {}",
                            crate::prelude::String::from_utf8_lossy(&bytes)
                        );
                        Err(EngineError {
                            kind: EngineErrorKind::EvmError(ExitError::Other(
                                crate::prelude::Cow::from(error_message),
                            )),
                            gas_used: submit_result.gas_used,
                        })
                    }
                    TransactionStatus::OutOfFund => Err(EngineError {
                        kind: EngineErrorKind::EvmError(ExitError::OutOfFund),
                        gas_used: submit_result.gas_used,
                    }),
                    TransactionStatus::OutOfOffset => Err(EngineError {
                        kind: EngineErrorKind::EvmError(ExitError::OutOfOffset),
                        gas_used: submit_result.gas_used,
                    }),
                    TransactionStatus::OutOfGas => Err(EngineError {
                        kind: EngineErrorKind::EvmError(ExitError::OutOfGas),
                        gas_used: submit_result.gas_used,
                    }),
                    TransactionStatus::CallTooDeep => Err(EngineError {
                        kind: EngineErrorKind::EvmError(ExitError::CallTooDeep),
                        gas_used: submit_result.gas_used,
                    }),
                }
            }),
            output_on_fail,
            self.io
        );

        // TODO(marX)
        // Everything succeed so return "0"
        self.io.return_output(b"\"0\"");
    }

    fn create_precompiles<P: PromiseHandler>(
        &self,
        pause_flags: PrecompileFlags,
        handler: &mut P,
    ) -> Precompiles<'env, I, E, P::ReadOnly> {
        let current_account_id = self.current_account_id.clone();
        let random_seed = self.env.random_seed();
        let io = self.io;
        let env = self.env;
        let ro_promise_handler = handler.read_only();

        let precompiles = if cfg!(all(feature = "mainnet", not(feature = "integration-test"))) {
            let mut tmp = Precompiles::new_london(PrecompileConstructorContext {
                current_account_id,
                random_seed,
                io,
                env,
                promise_handler: ro_promise_handler,
            });
            // Cross contract calls are not enabled on mainnet yet.
            tmp.all_precompiles
                .remove(&aurora_engine_precompiles::xcc::cross_contract_call::ADDRESS);
            tmp
        } else {
            Precompiles::new_london(PrecompileConstructorContext {
                current_account_id,
                random_seed,
                io,
                env,
                promise_handler: ro_promise_handler,
            })
        };

        Self::apply_pause_flags_to_precompiles(precompiles, pause_flags)
    }

    fn apply_pause_flags_to_precompiles<H: ReadOnlyPromiseHandler>(
        precompiles: Precompiles<'env, I, E, H>,
        pause_flags: PrecompileFlags,
    ) -> Precompiles<'env, I, E, H> {
        Precompiles {
            paused_precompiles: precompiles
                .all_precompiles
                .keys()
                .filter(|address| pause_flags.is_paused_by_address(address))
                .copied()
                .collect(),
            all_precompiles: precompiles.all_precompiles,
        }
    }
}

pub fn submit<I: IO + Copy, E: Env, P: PromiseHandler>(
    mut io: I,
    env: &E,
    transaction_bytes: &[u8],
    state: EngineState,
    current_account_id: AccountId,
    relayer_address: Address,
    handler: &mut P,
) -> EngineResult<SubmitResult> {
    #[cfg(feature = "contract")]
    let transaction = NormalizedEthTransaction::try_from(
        EthTransactionKind::try_from(transaction_bytes)
            .map_err(EngineErrorKind::FailedTransactionParse)?,
    )
    .map_err(|_e| EngineErrorKind::InvalidSignature)?;

    #[cfg(not(feature = "contract"))]
    // The standalone engine must use the backwards compatible parser to reproduce the NEAR state,
    // but the contract itself does not need to make such checks because it never executes historical
    // transactions.
    let transaction: NormalizedEthTransaction = {
        let adapter =
            aurora_engine_transactions::backwards_compatibility::EthTransactionKindAdapter::new(
                ZERO_ADDRESS_FIX_HEIGHT,
            );
        let block_height = env.block_height();
        let tx: EthTransactionKind = adapter
            .try_parse_bytes(transaction_bytes, block_height)
            .map_err(EngineErrorKind::FailedTransactionParse)?;
        tx.try_into()
            .map_err(|_e| EngineErrorKind::InvalidSignature)?
    };

    // Validate the chain ID, if provided inside the signature:
    if let Some(chain_id) = transaction.chain_id {
        if U256::from(chain_id) != U256::from(state.chain_id) {
            return Err(EngineErrorKind::InvalidChainId.into());
        }
    }

    // Retrieve the signer of the transaction:
    let sender = transaction.address;

    sdk::log!("signer_address {:?}", sender);

    check_nonce(&io, &sender, &transaction.nonce)?;

    // Check intrinsic gas is covered by transaction gas limit
    match transaction.intrinsic_gas(crate::engine::CONFIG) {
        Err(_e) => {
            return Err(EngineErrorKind::GasOverflow.into());
        }
        Ok(intrinsic_gas) => {
            if transaction.gas_limit < intrinsic_gas.into() {
                return Err(EngineErrorKind::IntrinsicGasNotMet.into());
            }
        }
    }

    if transaction.max_priority_fee_per_gas > transaction.max_fee_per_gas {
        return Err(EngineErrorKind::MaxPriorityGasFeeTooLarge.into());
    }

    let mut engine = Engine::new_with_state(state, sender, current_account_id, io, env);
    let prepaid_amount = match engine.charge_gas(&sender, &transaction) {
        Ok(gas_result) => gas_result,
        Err(GasPaymentError::OutOfFund) => {
            increment_nonce(&mut io, &sender);
            let result = SubmitResult::new(TransactionStatus::OutOfFund, 0, vec![]);
            return Ok(result);
        }
        Err(err) => {
            return Err(EngineErrorKind::GasPayment(err).into());
        }
    };
    let gas_limit: u64 = transaction
        .gas_limit
        .try_into()
        .map_err(|_| EngineErrorKind::GasOverflow)?;
    let access_list = transaction
        .access_list
        .into_iter()
        .map(|a| (a.address, a.storage_keys))
        .collect();
    let result = if let Some(receiver) = transaction.to {
        engine.call(
            &sender,
            &receiver,
            transaction.value,
            transaction.data,
            gas_limit,
            access_list,
            handler,
        )
        // TODO: charge for storage
    } else {
        // Execute a contract deployment:
        engine.deploy_code(
            sender,
            transaction.value,
            transaction.data,
            gas_limit,
            access_list,
            handler,
        )
        // TODO: charge for storage
    };

    // Give refund
    let gas_used = match &result {
        Ok(submit_result) => submit_result.gas_used,
        Err(engine_err) => engine_err.gas_used,
    };
    refund_unused_gas(&mut io, &sender, gas_used, prepaid_amount, &relayer_address).map_err(
        |e| EngineError {
            gas_used,
            kind: EngineErrorKind::GasPayment(e),
        },
    )?;

    // return result to user
    result
}

pub fn setup_refund_on_error_input(amount: U256, refund_address: Address) -> Vec<u8> {
    let selector = ERC20_MINT_SELECTOR;
    let mint_args = ethabi::encode(&[
        ethabi::Token::Address(refund_address.raw()),
        ethabi::Token::Uint(amount),
    ]);

    [selector, mint_args.as_slice()].concat()
}

pub fn refund_on_error<I: IO + Copy, E: Env, P: PromiseHandler>(
    io: I,
    env: &E,
    state: EngineState,
    args: RefundCallArgs,
    handler: &mut P,
) -> EngineResult<SubmitResult> {
    let current_account_id = env.current_account_id();
    match args.erc20_address {
        // ERC-20 exit; re-mint burned tokens
        Some(erc20_address) => {
            let erc20_admin_address = current_address(&current_account_id);
            let mut engine =
                Engine::new_with_state(state, erc20_admin_address, current_account_id, io, env);
            let erc20_address = erc20_address;
            let refund_address = args.recipient_address;
            let amount = U256::from_big_endian(&args.amount);
            let input = setup_refund_on_error_input(amount, refund_address);

            engine.call(
                &erc20_admin_address,
                &erc20_address,
                Wei::zero(),
                input,
                u64::MAX,
                Vec::new(),
                handler,
            )
        }
        // ETH exit; transfer ETH back from precompile address
        None => {
            let exit_address = aurora_engine_precompiles::native::exit_to_near::ADDRESS;
            let mut engine =
                Engine::new_with_state(state, exit_address, current_account_id, io, env);
            let refund_address = args.recipient_address;
            let amount = Wei::new(U256::from_big_endian(&args.amount));
            engine.call(
                &exit_address,
                &refund_address,
                amount,
                Vec::new(),
                u64::MAX,
                vec![
                    (exit_address.raw(), Vec::new()),
                    (refund_address.raw(), Vec::new()),
                ],
                handler,
            )
        }
    }
}

/// There is one Aurora block per NEAR block height (note: when heights in NEAR are skipped
/// they are interpreted as empty blocks on Aurora). The blockhash is derived from the height
/// according to
/// ```text
/// block_hash = sha256(concat(
///     BLOCK_HASH_PREFIX,
///     block_height as u64,
///     chain_id,
///     engine_account_id,
/// ))
/// ```
pub fn compute_block_hash(chain_id: [u8; 32], block_height: u64, account_id: &[u8]) -> H256 {
    debug_assert_eq!(BLOCK_HASH_PREFIX_SIZE, mem::size_of_val(&BLOCK_HASH_PREFIX));
    debug_assert_eq!(BLOCK_HEIGHT_SIZE, mem::size_of_val(&block_height));
    debug_assert_eq!(CHAIN_ID_SIZE, mem::size_of_val(&chain_id));
    let mut data = Vec::with_capacity(
        BLOCK_HASH_PREFIX_SIZE + BLOCK_HEIGHT_SIZE + CHAIN_ID_SIZE + account_id.len(),
    );
    data.push(BLOCK_HASH_PREFIX);
    data.extend_from_slice(&chain_id);
    data.extend_from_slice(account_id);
    data.extend_from_slice(&block_height.to_be_bytes());

    sdk::sha256(&data)
}

pub fn get_state<I: IO>(io: &I) -> Result<EngineState, EngineStateError> {
    match io.read_storage(&bytes_to_key(KeyPrefix::Config, STATE_KEY)) {
        None => Err(EngineStateError::NotFound),
        Some(bytes) => EngineState::try_from_slice(&bytes.to_vec())
            .map_err(|_| EngineStateError::DeserializationFailed),
    }
}

/// Saves state into the storage.
pub fn set_state<I: IO>(io: &mut I, state: EngineState) {
    io.write_storage(
        &bytes_to_key(KeyPrefix::Config, STATE_KEY),
        &state.try_to_vec().expect("ERR_SER"),
    );
}

pub fn get_authorizer() -> EngineAuthorizer {
    // TODO: a temporary account until the engine adapts std with near-plugins
    let account = AccountId::new("aurora").expect("Failed to parse account from string");

    EngineAuthorizer::from_accounts(once(account))
}

pub fn refund_unused_gas<I: IO>(
    io: &mut I,
    sender: &Address,
    gas_used: u64,
    gas_result: GasPaymentResult,
    relayer: &Address,
) -> Result<(), GasPaymentError> {
    if gas_result.effective_gas_price.is_zero() {
        return Ok(());
    }

    let gas_to_wei = |price: U256| {
        U256::from(gas_used)
            .checked_mul(price)
            .map(Wei::new)
            .ok_or(GasPaymentError::EthAmountOverflow)
    };

    let spent_amount = gas_to_wei(gas_result.effective_gas_price)?;
    let reward_amount = gas_to_wei(gas_result.priority_fee_per_gas)?;

    let refund = gas_result
        .prepaid_amount
        .checked_sub(spent_amount)
        .ok_or(GasPaymentError::EthAmountOverflow)?;

    add_balance(io, sender, refund)?;
    add_balance(io, relayer, reward_amount)?;

    Ok(())
}

pub fn setup_receive_erc20_tokens_input(
    args: &NEP141FtOnTransferArgs,
    recipient: &Address,
) -> Vec<u8> {
    let selector = ERC20_MINT_SELECTOR;
    let tail = ethabi::encode(&[
        ethabi::Token::Address(recipient.raw()),
        ethabi::Token::Uint(U256::from(args.amount.as_u128())),
    ]);

    [selector, tail.as_slice()].concat()
}

pub fn setup_deploy_erc20_input(current_account_id: &AccountId) -> Vec<u8> {
    #[cfg(feature = "error_refund")]
    let erc20_contract = include_bytes!("../../etc/eth-contracts/res/EvmErc20V2.bin");
    #[cfg(not(feature = "error_refund"))]
    let erc20_contract = include_bytes!("../../etc/eth-contracts/res/EvmErc20.bin");

    let erc20_admin_address = current_address(current_account_id);

    let deploy_args = ethabi::encode(&[
        ethabi::Token::String("Empty".to_string()),
        ethabi::Token::String("EMPTY".to_string()),
        ethabi::Token::Uint(ethabi::Uint::from(0)),
        ethabi::Token::Address(erc20_admin_address.raw()),
    ]);

    ([erc20_contract, deploy_args.as_slice()].concat()).to_vec()
}

/// Used to bridge NEP-141 tokens from NEAR to Aurora. On Aurora the NEP-141 becomes an ERC-20.
pub fn deploy_erc20_token<I: IO + Copy, E: Env, P: PromiseHandler>(
    args: DeployErc20TokenArgs,
    io: I,
    env: &E,
    handler: &mut P,
) -> Result<Address, DeployErc20Error> {
    let current_account_id = env.current_account_id();
    let input = setup_deploy_erc20_input(&current_account_id);
    let mut engine = Engine::new(
        aurora_engine_sdk::types::near_account_to_evm_address(
            env.predecessor_account_id().as_bytes(),
        ),
        current_account_id,
        io,
        env,
    )
    .map_err(DeployErc20Error::State)?;

    let address = match Engine::deploy_code_with_input(&mut engine, input, handler) {
        Ok(result) => match result.status {
            TransactionStatus::Succeed(ret) => {
                Address::new(H160(ret.as_slice().try_into().unwrap()))
            }
            other => return Err(DeployErc20Error::Failed(other)),
        },
        Err(e) => return Err(DeployErc20Error::Engine(e)),
    };

    sdk::log!("Deployed ERC-20 in Aurora at: {:#?}", address);
    engine
        .register_token(address, args.nep141)
        .map_err(DeployErc20Error::Register)?;

    Ok(address)
}

pub fn set_code<I: IO>(io: &mut I, address: &Address, code: &[u8]) {
    io.write_storage(&address_to_key(KeyPrefix::Code, address), code);
}

pub fn remove_code<I: IO>(io: &mut I, address: &Address) {
    io.remove_storage(&address_to_key(KeyPrefix::Code, address));
}

pub fn get_code<I: IO>(io: &I, address: &Address) -> Vec<u8> {
    io.read_storage(&address_to_key(KeyPrefix::Code, address))
        .map(|s| s.to_vec())
        .unwrap_or_default()
}

pub fn get_code_size<I: IO>(io: &I, address: &Address) -> usize {
    io.read_storage_len(&address_to_key(KeyPrefix::Code, address))
        .unwrap_or(0)
}

pub fn set_nonce<I: IO>(io: &mut I, address: &Address, nonce: &U256) {
    io.write_storage(
        &address_to_key(KeyPrefix::Nonce, address),
        &u256_to_arr(nonce),
    );
}

pub fn remove_nonce<I: IO>(io: &mut I, address: &Address) {
    io.remove_storage(&address_to_key(KeyPrefix::Nonce, address));
}

/// Checks the nonce to ensure that the address matches the transaction
/// nonce.
#[inline]
pub fn check_nonce<I: IO>(
    io: &I,
    address: &Address,
    transaction_nonce: &U256,
) -> Result<(), EngineErrorKind> {
    let account_nonce = get_nonce(io, address);

    if transaction_nonce != &account_nonce {
        return Err(EngineErrorKind::IncorrectNonce);
    }

    Ok(())
}

pub fn get_nonce<I: IO>(io: &I, address: &Address) -> U256 {
    io.read_u256(&address_to_key(KeyPrefix::Nonce, address))
        .unwrap_or_else(|_| U256::zero())
}

pub fn increment_nonce<I: IO>(io: &mut I, address: &Address) {
    let account_nonce = get_nonce(io, address);
    let new_nonce = account_nonce.saturating_add(U256::one());
    set_nonce(io, address, &new_nonce);
}

pub fn nep141_erc20_map<I: IO>(io: I) -> BijectionMap<NEP141Account, ERC20Address, I> {
    BijectionMap::new(KeyPrefix::Nep141Erc20Map, KeyPrefix::Erc20Nep141Map, io)
}

pub fn get_erc20_from_nep141<I: IO>(
    io: &I,
    nep141_account_id: &AccountId,
) -> Result<Vec<u8>, GetErc20FromNep141Error> {
    let key = bytes_to_key(KeyPrefix::Nep141Erc20Map, nep141_account_id.as_bytes());
    io.read_storage(&key)
        .map(|v| v.to_vec())
        .ok_or(GetErc20FromNep141Error::Nep141NotFound)
}

pub fn add_balance<I: IO>(
    io: &mut I,
    address: &Address,
    amount: Wei,
) -> Result<(), BalanceOverflow> {
    let current_balance = get_balance(io, address);
    let new_balance = current_balance.checked_add(amount).ok_or(BalanceOverflow)?;
    set_balance(io, address, &new_balance);
    Ok(())
}

pub fn set_balance<I: IO>(io: &mut I, address: &Address, balance: &Wei) {
    io.write_storage(
        &address_to_key(KeyPrefix::Balance, address),
        &balance.to_bytes(),
    );
}

pub fn remove_balance<I: IO + Copy>(io: &mut I, address: &Address) {
    io.remove_storage(&address_to_key(KeyPrefix::Balance, address));
}

pub fn get_balance<I: IO>(io: &I, address: &Address) -> Wei {
    let raw = io
        .read_u256(&address_to_key(KeyPrefix::Balance, address))
        .unwrap_or_else(|_| U256::zero());
    Wei::new(raw)
}

pub fn remove_storage<I: IO>(io: &mut I, address: &Address, key: &H256, generation: u32) {
    io.remove_storage(storage_to_key(address, key, generation).as_ref());
}

pub fn set_storage<I: IO>(
    io: &mut I,
    address: &Address,
    key: &H256,
    value: &H256,
    generation: u32,
) {
    io.write_storage(storage_to_key(address, key, generation).as_ref(), &value.0);
}

pub fn get_storage<I: IO>(io: &I, address: &Address, key: &H256, generation: u32) -> H256 {
    io.read_storage(storage_to_key(address, key, generation).as_ref())
        .and_then(|value| {
            if value.len() == 32 {
                let mut buf = [0u8; 32];
                value.copy_to_slice(&mut buf);
                Some(H256(buf))
            } else {
                None
            }
        })
        .unwrap_or_default()
}

pub fn is_account_empty<I: IO>(io: &I, address: &Address) -> bool {
    get_balance(io, address).is_zero()
        && get_nonce(io, address).is_zero()
        && get_code_size(io, address) == 0
}

/// Increments storage generation for a given address.
pub fn set_generation<I: IO>(io: &mut I, address: &Address, generation: u32) {
    io.write_storage(
        &address_to_key(KeyPrefix::Generation, address),
        &generation.to_be_bytes(),
    );
}

pub fn get_generation<I: IO>(io: &I, address: &Address) -> u32 {
    io.read_storage(&address_to_key(KeyPrefix::Generation, address))
        .map(|value| {
            let mut bytes = [0u8; 4];
            value.copy_to_slice(&mut bytes);
            u32::from_be_bytes(bytes)
        })
        .unwrap_or(0)
}

/// Removes all storage for the given address.
fn remove_all_storage<I: IO>(io: &mut I, address: &Address, generation: u32) {
    // FIXME: there is presently no way to prefix delete trie state.
    // NOTE: There is not going to be a method on runtime for this.
    //     You may need to store all keys in a list if you want to do this in a contract.
    //     Maybe you can incentivize people to delete dead old keys. They can observe them from
    //     external indexer node and then issue special cleaning transaction.
    //     Either way you may have to store the nonce per storage address root. When the account
    //     has to be deleted the storage nonce needs to be increased, and the old nonce keys
    //     can be deleted over time. That's how TurboGeth does storage.
    set_generation(io, address, generation + 1);
}

/// Removes an account.
fn remove_account<I: IO + Copy>(io: &mut I, address: &Address, generation: u32) {
    remove_nonce(io, address);
    remove_balance(io, address);
    remove_code(io, address);
    remove_all_storage(io, address, generation);
}

fn filter_promises_from_logs<I, T, P>(
    io: &I,
    handler: &mut P,
    logs: T,
    current_account_id: &AccountId,
) -> Vec<ResultLog>
where
    T: IntoIterator<Item = Log>,
    P: PromiseHandler,
    I: IO + Copy,
{
    logs.into_iter()
        .filter_map(|log| {
            if log.address == exit_to_near::ADDRESS.raw()
                || log.address == exit_to_ethereum::ADDRESS.raw()
            {
                if log.topics.is_empty() {
                    if let Ok(promise) = PromiseArgs::try_from_slice(&log.data) {
                        match promise {
                            PromiseArgs::Create(promise) => {
                                // Safety: this promise creation is safe because it does not come from
                                // users directly. The exit precompiles only create promises which we
                                // are able to execute without violating any security invariants.
                                unsafe { schedule_promise(handler, &promise) }
                            }
                            PromiseArgs::Callback(promise) => {
                                // Safety: This is safe because the promise data comes from our own
                                // exit precompiles. See note above.
                                unsafe {
                                    let base_id = schedule_promise(handler, &promise.base);
                                    schedule_promise_callback(handler, base_id, &promise.callback)
                                }
                            }
                            PromiseArgs::Recursive(_) => {
                                unreachable!("Exit precompiles do not produce recursive promises")
                            }
                        };
                    }
                    // do not pass on these "internal logs" to caller
                    None
                } else {
                    // The exit precompiles do produce externally consumable logs in
                    // addition to the promises. The external logs have a non-empty
                    // `topics` field.
                    Some(log.into())
                }
            } else if log.address == cross_contract_call::ADDRESS.raw() {
                if log.topics[0] == cross_contract_call::AMOUNT_TOPIC {
                    // NEAR balances are 128-bit, so the leading 16 bytes of the 256-bit topic
                    // value should always be zero.
                    assert_eq!(&log.topics[1].as_bytes()[0..16], &[0; 16]);
                    let required_near =
                        Yocto::new(U256::from_big_endian(log.topics[1].as_bytes()).low_u128());
                    if let Ok(promise) = PromiseCreateArgs::try_from_slice(&log.data) {
                        crate::xcc::handle_precompile_promise(
                            io,
                            handler,
                            promise,
                            required_near,
                            current_account_id,
                        );
                    }
                }
                // do not pass on these "internal logs" to caller
                None
            } else {
                Some(log.into())
            }
        })
        .collect()
}

unsafe fn schedule_promise<P: PromiseHandler>(
    handler: &mut P,
    promise: &PromiseCreateArgs,
) -> PromiseId {
    sdk::log!(
        "call_contract {}.{}",
        promise.target_account_id,
        promise.method
    );
    handler.promise_create_call(promise)
}

unsafe fn schedule_promise_callback<P: PromiseHandler>(
    handler: &mut P,
    base_id: PromiseId,
    promise: &PromiseCreateArgs,
) -> PromiseId {
    sdk::log!(
        "callback_call_contract {}.{}",
        promise.target_account_id,
        promise.method
    );
    handler.promise_attach_callback(base_id, promise)
}

impl<'env, I: IO + Copy, E: Env> evm::backend::Backend for Engine<'env, I, E> {
    /// Returns the "effective" gas price (as defined by EIP-1559)
    fn gas_price(&self) -> U256 {
        self.gas_price
    }

    /// Returns the origin address that created the contract.
    fn origin(&self) -> H160 {
        self.origin.raw()
    }

    /// Returns a block hash from a given index.
    ///
    /// Currently, this returns
    /// 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff if
    /// only for the 256 most recent blocks, excluding of the current one.
    /// Otherwise, it returns 0x0.
    ///
    /// In other words, if the requested block index is less than the current
    /// block index, return
    /// 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff.
    /// Otherwise, return 0.
    ///
    /// This functionality may change in the future. Follow
    /// [nearcore#3456](https://github.com/near/nearcore/issues/3456) for more
    /// details.
    ///
    /// See: https://doc.aurora.dev/develop/compat/evm#blockhash
    fn block_hash(&self, number: U256) -> H256 {
        let idx = U256::from(self.env.block_height());
        if idx.saturating_sub(U256::from(256)) <= number && number < idx {
            // since `idx` comes from `u64` it is always safe to downcast `number` from `U256`
            compute_block_hash(
                self.state.chain_id,
                number.low_u64(),
                self.current_account_id.as_bytes(),
            )
        } else {
            H256::zero()
        }
    }

    /// Returns the current block index number.
    fn block_number(&self) -> U256 {
        U256::from(self.env.block_height())
    }

    /// Returns a mocked coinbase which is the EVM address for the Aurora
    /// account, being 0x4444588443C3a91288c5002483449Aba1054192b.
    ///
    /// See: https://doc.aurora.dev/develop/compat/evm#coinbase
    fn block_coinbase(&self) -> H160 {
        H160([
            0x44, 0x44, 0x58, 0x84, 0x43, 0xC3, 0xa9, 0x12, 0x88, 0xc5, 0x00, 0x24, 0x83, 0x44,
            0x9A, 0xba, 0x10, 0x54, 0x19, 0x2b,
        ])
    }

    /// Returns the current block timestamp.
    fn block_timestamp(&self) -> U256 {
        U256::from(self.env.block_timestamp().secs())
    }

    /// Returns the current block difficulty.
    ///
    /// See: https://doc.aurora.dev/develop/compat/evm#difficulty
    fn block_difficulty(&self) -> U256 {
        U256::zero()
    }

    /// Returns the current block gas limit.
    ///
    /// Currently, this returns 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
    /// as there isn't a gas limit alternative right now but this may change in
    /// the future.
    ///
    /// See: https://doc.aurora.dev/develop/compat/evm#gaslimit
    fn block_gas_limit(&self) -> U256 {
        U256::max_value()
    }

    /// Returns the current base fee for the current block.
    ///
    /// Currently, this returns 0 as there is no concept of a base fee at this
    /// time but this may change in the future.
    ///
    /// TODO: doc.aurora.dev link
    fn block_base_fee_per_gas(&self) -> U256 {
        U256::zero()
    }

    /// Returns the states chain ID.
    fn chain_id(&self) -> U256 {
        U256::from(self.state.chain_id)
    }

    /// Checks if an address exists.
    fn exists(&self, address: H160) -> bool {
        let address = Address::new(address);
        let mut cache = self.account_info_cache.borrow_mut();
        let basic_info = cache.get_or_insert_with(address, || Basic {
            nonce: get_nonce(&self.io, &address),
            balance: get_balance(&self.io, &address).raw(),
        });
        if !basic_info.balance.is_zero() || !basic_info.nonce.is_zero() {
            return true;
        }
        let mut cache = self.contract_code_cache.borrow_mut();
        let code = cache.get_or_insert_with(address, || get_code(&self.io, &address));
        !code.is_empty()
    }

    /// Returns basic account information.
    fn basic(&self, address: H160) -> Basic {
        let address = Address::new(address);
        let result = self
            .account_info_cache
            .borrow_mut()
            .get_or_insert_with(address, || Basic {
                nonce: get_nonce(&self.io, &address),
                balance: get_balance(&self.io, &address).raw(),
            })
            .clone();
        result
    }

    /// Returns the code of the contract from an address.
    fn code(&self, address: H160) -> Vec<u8> {
        let address = Address::new(address);
        self.contract_code_cache
            .borrow_mut()
            .get_or_insert_with(address, || get_code(&self.io, &address))
            .clone()
    }

    /// Get storage value of address at index.
    fn storage(&self, address: H160, index: H256) -> H256 {
        let address = Address::new(address);
        let generation = *self
            .generation_cache
            .borrow_mut()
            .entry(address)
            .or_insert_with(|| get_generation(&self.io, &address));
        let result = *self
            .contract_storage_cache
            .borrow_mut()
            .get_or_insert_with((address, index), || {
                get_storage(&self.io, &address, &index, generation)
            });
        result
    }

    /// Get original storage value of address at index, if available.
    ///
    /// Since SputnikVM collects storage changes in memory until the transaction is over,
    /// the "original storage" will always be the same as the storage because no values
    /// are written to storage until after the transaction is complete.
    fn original_storage(&self, address: H160, index: H256) -> Option<H256> {
        Some(self.storage(address, index))
    }
}

impl<'env, J: IO + Copy, E: Env> ApplyBackend for Engine<'env, J, E> {
    fn apply<A, I, L>(&mut self, values: A, _logs: L, delete_empty: bool)
    where
        A: IntoIterator<Item = Apply<I>>,
        I: IntoIterator<Item = (H256, H256)>,
        L: IntoIterator<Item = Log>,
    {
        let mut writes_counter: usize = 0;
        let mut code_bytes_written: usize = 0;
        let mut accounting = accounting::Accounting::default();
        for apply in values {
            match apply {
                Apply::Modify {
                    address,
                    basic,
                    code,
                    storage,
                    reset_storage,
                } => {
                    let current_basic = self.basic(address);
                    accounting.change(accounting::Change {
                        new_value: basic.balance,
                        old_value: current_basic.balance,
                    });

                    let address = Address::new(address);
                    let generation = get_generation(&self.io, &address);

                    if current_basic.nonce != basic.nonce {
                        set_nonce(&mut self.io, &address, &basic.nonce);
                        writes_counter += 1;
                    }
                    if current_basic.balance != basic.balance {
                        set_balance(&mut self.io, &address, &Wei::new(basic.balance));
                        writes_counter += 1;
                    }

                    if let Some(code) = code {
                        set_code(&mut self.io, &address, &code);
                        code_bytes_written = code.len();
                        sdk::log!("code_write_at_address {:?} {}", address, code_bytes_written);
                    }

                    let next_generation = if reset_storage {
                        remove_all_storage(&mut self.io, &address, generation);
                        generation + 1
                    } else {
                        generation
                    };

                    for (index, value) in storage {
                        if value == H256::default() {
                            remove_storage(&mut self.io, &address, &index, next_generation)
                        } else {
                            set_storage(&mut self.io, &address, &index, &value, next_generation)
                        }
                        writes_counter += 1;
                    }

                    // We only need to remove the account if:
                    // 1. we are supposed to delete an empty account
                    // 2. the account is empty
                    // 3. we didn't already clear out the storage (because if we did then there is
                    //    nothing to do)
                    if delete_empty
                        && is_account_empty(&self.io, &address)
                        && generation == next_generation
                    {
                        remove_account(&mut self.io, &address, generation);
                        writes_counter += 1;
                    }
                }
                Apply::Delete { address } => {
                    let current_basic = self.basic(address);
                    accounting.remove(current_basic.balance);

                    let address = Address::new(address);
                    let generation = get_generation(&self.io, &address);
                    remove_account(&mut self.io, &address, generation);
                    writes_counter += 1;
                }
            }
        }
        match accounting.net() {
            // Net loss is possible if `SELFDESTRUCT(self)` calls are made.
            accounting::Net::Lost(amount) => {
                sdk::log!("Burn {} ETH due to SELFDESTRUCT", amount);
                // Apply changes for eth-connector. We ignore the `StorageReadError` intentionally since
                // if we cannot read the storage then there is nothing to remove.
                EthConnectorContract::init_instance(self.io)
                    .map(|mut connector| {
                        // The `unwrap` is safe here because (a) if the connector
                        // is implemented correctly then the total supply will never underflow and (b) we are passing
                        // in the balance directly so there will always be enough balance.
                        connector.internal_remove_eth(Wei::new(amount)).unwrap();
                    })
                    .ok();
            }
            accounting::Net::Zero => (),
            accounting::Net::Gained(_) => {
                // It should be impossible to gain ETH using normal EVM operations in production.
                // In tests we have convenience functions that can poof addresses with ETH out of nowhere.
                #[cfg(all(not(feature = "integration-test"), feature = "contract"))]
                {
                    panic!("ERR_INVALID_ETH_SUPPLY_INCREASE");
                }
            }
        }
        // These variable are only used if logging feature is enabled.
        // In production logging is always enabled so we can ignore the warnings.
        #[allow(unused_variables)]
        let total_bytes = 32 * writes_counter + code_bytes_written;
        #[allow(unused_assignments)]
        if code_bytes_written > 0 {
            writes_counter += 1;
        }
        sdk::log!(
            "total_writes_count {}\ntotal_written_bytes {}",
            writes_counter,
            total_bytes
        );
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parameters::{FunctionCallArgsV1, FunctionCallArgsV2};
    use aurora_engine_precompiles::make_address;
    use aurora_engine_sdk::env::Fixed;
    use aurora_engine_sdk::promise::Noop;
    use aurora_engine_test_doubles::io::{Storage, StoragePointer};
    use aurora_engine_test_doubles::promise::PromiseTracker;
    use aurora_engine_types::types::RawU256;
    use sha3::{Digest, Keccak256};
    use std::sync::RwLock;

    #[test]
    fn test_view_call_to_empty_contract_without_input_returns_empty_data() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        add_balance(&mut io, &origin, Wei::new_u64(22000)).unwrap();
        let engine =
            Engine::new_with_state(EngineState::default(), origin, current_account_id, io, &env);

        let contract = make_address(1, 1);
        let value = Wei::new_u64(1000);
        let input = vec![];
        let args = ViewCallArgs {
            sender: origin,
            address: contract,
            amount: RawU256::from(value.raw()),
            input,
        };
        let actual_status = engine.view_with_args(args).unwrap();
        let expected_status = TransactionStatus::Succeed(Vec::new());

        assert_eq!(expected_status, actual_status);
    }

    #[test]
    fn test_deploying_code_with_empty_input_succeeds() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let io = StoragePointer(&storage);
        let mut engine =
            Engine::new_with_state(EngineState::default(), origin, current_account_id, io, &env);

        let input = vec![];
        let mut handler = Noop;

        let actual_result = engine.deploy_code_with_input(input, &mut handler).unwrap();

        let nonce = U256::zero();
        let expected_address = create_legacy_address(origin.raw(), nonce).0.to_vec();
        let expected_status = TransactionStatus::Succeed(expected_address);
        let expected_gas_used = 53000;
        let expected_logs = Vec::new();
        let expected_result = SubmitResult::new(expected_status, expected_gas_used, expected_logs);

        assert_eq!(expected_result, actual_result);
    }

    #[test]
    fn test_call_to_empty_contract_returns_empty_data() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        add_balance(&mut io, &origin, Wei::new_u64(22000)).unwrap();
        let mut engine =
            Engine::new_with_state(EngineState::default(), origin, current_account_id, io, &env);

        let input = Vec::<u8>::new();
        let mut handler = Noop;
        let contract = make_address(1, 1);
        let value = Wei::new_u64(1000);
        let args = CallArgs::V2(FunctionCallArgsV2 {
            contract,
            value: RawU256::from(value.raw()),
            input,
        });
        let actual_result = engine.call_with_args(args, &mut handler).unwrap();

        let expected_data = Vec::new();
        let expected_status = TransactionStatus::Succeed(expected_data);
        let expected_gas_used = 21000;
        let expected_logs = Vec::new();
        let expected_result = SubmitResult::new(expected_status, expected_gas_used, expected_logs);

        assert_eq!(expected_result, actual_result);
    }

    #[test]
    fn test_call_with_empty_balance_fails_with_out_of_funds_error() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let io = StoragePointer(&storage);
        let mut engine =
            Engine::new_with_state(EngineState::default(), origin, current_account_id, io, &env);

        let input = Vec::<u8>::new();
        let mut handler = Noop;
        let contract = make_address(1, 1);
        let value = Wei::new_u64(1000);
        let args = CallArgs::V2(FunctionCallArgsV2 {
            contract,
            value: RawU256::from(value.raw()),
            input,
        });
        let actual_result = engine.call_with_args(args, &mut handler).unwrap();

        let expected_status = TransactionStatus::OutOfFund;
        let expected_gas_used = 21000;
        let expected_logs = Vec::new();
        let expected_result = SubmitResult::new(expected_status, expected_gas_used, expected_logs);

        assert_eq!(expected_result, actual_result);
    }

    #[test]
    fn test_transfer_moves_balance_from_sender_to_recipient() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        add_balance(&mut io, &origin, Wei::new_u64(22000)).unwrap();
        let mut engine =
            Engine::new_with_state(EngineState::default(), origin, current_account_id, io, &env);

        let gas_limit = u64::MAX;
        let mut handler = Noop;
        let receiver = make_address(1, 1);
        let value = Wei::new_u64(1000);
        let actual_result = engine
            .transfer(origin, receiver, value, gas_limit, &mut handler)
            .unwrap();

        let expected_data = Vec::new();
        let expected_status = TransactionStatus::Succeed(expected_data);
        let expected_gas_used = 21000;
        let expected_logs = Vec::new();
        let expected_result = SubmitResult::new(expected_status, expected_gas_used, expected_logs);

        assert_eq!(expected_result, actual_result);
    }

    #[test]
    fn test_call_with_v1_args_to_empty_contract_returns_empty_data() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        add_balance(&mut io, &origin, Wei::new_u64(22000)).unwrap();
        let mut engine =
            Engine::new_with_state(EngineState::default(), origin, current_account_id, io, &env);

        let input = Vec::<u8>::new();
        let mut handler = Noop;
        let contract = make_address(1, 1);
        let args = CallArgs::V1(FunctionCallArgsV1 { contract, input });
        let actual_result = engine.call_with_args(args, &mut handler).unwrap();

        let expected_data = Vec::new();
        let expected_status = TransactionStatus::Succeed(expected_data);
        let expected_gas_used = 21000;
        let expected_logs = Vec::new();
        let expected_result = SubmitResult::new(expected_status, expected_gas_used, expected_logs);

        assert_eq!(expected_result, actual_result);
    }

    #[test]
    fn test_registering_relayer_succeeds() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        add_balance(&mut io, &origin, Wei::new_u64(22000)).unwrap();
        let mut engine =
            Engine::new_with_state(EngineState::default(), origin, current_account_id, io, &env);

        let account_id = AccountId::new("relayer").unwrap();
        let expected_relayer_address = make_address(1, 1);
        engine.register_relayer(account_id.as_bytes(), expected_relayer_address);
        let actual_relayer_address = engine.get_relayer(account_id.as_bytes()).unwrap();

        assert_eq!(expected_relayer_address, actual_relayer_address);
    }

    #[test]
    fn test_registering_token_succeeds() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        set_balance(&mut io, &origin, &Wei::new_u64(22000));
        let mut engine = Engine::new_with_state(
            EngineState::default(),
            origin,
            current_account_id.clone(),
            io,
            &env,
        );

        let receiver = make_address(6, 6);
        let erc20_token = make_address(4, 5);
        let nep141_token = AccountId::new("testcoin").unwrap();
        let args = NEP141FtOnTransferArgs {
            sender_id: Default::default(),
            amount: Default::default(),
            msg: receiver.encode(),
        };
        let mut handler = Noop;
        engine
            .register_token(erc20_token, nep141_token.clone())
            .unwrap();
        engine.receive_erc20_tokens(&nep141_token, &args, &current_account_id, &mut handler);

        let storage_read = storage.read().unwrap();
        let actual_output = std::str::from_utf8(storage_read.output.as_slice()).unwrap();
        let expected_output = "\"0\"";

        assert_eq!(expected_output, actual_output);
    }

    #[test]
    fn test_deploying_token_succeeds() {
        let env = Fixed::default();
        let origin = aurora_engine_sdk::types::near_account_to_evm_address(
            env.predecessor_account_id().as_bytes(),
        );
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        add_balance(&mut io, &origin, Wei::new_u64(22000)).unwrap();
        set_state(&mut io, EngineState::default());

        let nep141_token = AccountId::new("testcoin").unwrap();
        let mut handler = Noop;
        let args = DeployErc20TokenArgs {
            nep141: nep141_token,
        };
        let nonce = U256::zero();
        let expected_address = Address::new(create_legacy_address(origin.raw(), nonce));
        let actual_address = deploy_erc20_token(args, io, &env, &mut handler).unwrap();

        assert_eq!(expected_address, actual_address);
    }

    #[test]
    fn test_gas_charge_for_empty_transaction_is_zero() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        add_balance(&mut io, &origin, Wei::new_u64(22000)).unwrap();
        let mut engine =
            Engine::new_with_state(EngineState::default(), origin, current_account_id, io, &env);

        let transaction = NormalizedEthTransaction {
            address: Default::default(),
            chain_id: None,
            nonce: Default::default(),
            gas_limit: U256::MAX,
            max_priority_fee_per_gas: Default::default(),
            max_fee_per_gas: U256::MAX,
            to: None,
            value: Default::default(),
            data: vec![],
            access_list: vec![],
        };
        let actual_result = engine.charge_gas(&origin, &transaction).unwrap();

        let expected_result = GasPaymentResult {
            prepaid_amount: Wei::zero(),
            effective_gas_price: U256::zero(),
            priority_fee_per_gas: U256::zero(),
        };

        assert_eq!(expected_result, actual_result);
    }

    #[test]
    fn test_scheduling_promise_creates_it() {
        use aurora_engine_test_doubles::promise::PromiseArgs;
        use std::collections::HashMap;

        let mut promise_tracker = PromiseTracker::default();
        let args = PromiseCreateArgs {
            target_account_id: Default::default(),
            method: "".to_string(),
            args: vec![],
            attached_balance: Default::default(),
            attached_gas: Default::default(),
        };
        // This is safe because it's just a test
        let actual_id = unsafe { schedule_promise(&mut promise_tracker, &args) };
        let actual_scheduled_promises = promise_tracker.scheduled_promises;
        let expected_scheduled_promises = {
            let mut map = HashMap::new();
            map.insert(actual_id.raw(), PromiseArgs::Create(args));
            map
        };

        assert_eq!(expected_scheduled_promises, actual_scheduled_promises);
    }

    #[test]
    fn test_scheduling_promise_callback_adds_it() {
        use aurora_engine_test_doubles::promise::PromiseArgs;
        use std::collections::HashMap;

        let mut promise_tracker = PromiseTracker::default();
        let args = PromiseCreateArgs {
            target_account_id: Default::default(),
            method: "".to_string(),
            args: vec![],
            attached_balance: Default::default(),
            attached_gas: Default::default(),
        };
        let base_id = PromiseId::new(6);
        // This is safe because it's just a test
        let actual_id = unsafe { schedule_promise_callback(&mut promise_tracker, base_id, &args) };
        let actual_scheduled_promises = promise_tracker.scheduled_promises;
        let expected_scheduled_promises = {
            let mut map = HashMap::new();
            map.insert(
                actual_id.raw(),
                PromiseArgs::Callback {
                    base: base_id,
                    callback: args,
                },
            );
            map
        };

        assert_eq!(expected_scheduled_promises, actual_scheduled_promises);
    }

    #[test]
    fn test_loading_original_storage_loads_stored_value() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        let engine =
            Engine::new_with_state(EngineState::default(), origin, current_account_id, io, &env);

        let expected_value = H256::from_low_u64_le(64);
        let index = H256::zero();
        let generation = get_generation(&io, &origin);
        set_storage(&mut io, &origin, &index, &expected_value, generation);
        let actual_value = engine.original_storage(origin.raw(), index).unwrap();

        assert_eq!(expected_value, actual_value);
    }

    #[test]
    fn test_loading_engine_from_storage_loads_stored_state() {
        let origin = Address::zero();
        let current_account_id = AccountId::default();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        let expected_state = EngineState::default();
        set_state(&mut io, expected_state.clone());
        let engine = Engine::new(origin, current_account_id, io, &env).unwrap();
        let actual_state = engine.state;

        assert_eq!(expected_state, actual_state);
    }

    #[test]
    fn test_refund_transfer_eth_back_from_precompile_address() {
        let recipient_address = make_address(1, 1);
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        let expected_state = EngineState::default();
        let refund_amount = Wei::new_u64(1000);
        add_balance(&mut io, &exit_to_near::ADDRESS, refund_amount).unwrap();
        set_state(&mut io, expected_state.clone());
        let args = RefundCallArgs {
            recipient_address,
            erc20_address: None,
            amount: RawU256::from(refund_amount.raw()),
        };
        let mut handler = Noop;
        let actual_result = refund_on_error(io, &env, expected_state, args, &mut handler).unwrap();
        let expected_result =
            SubmitResult::new(TransactionStatus::Succeed(Vec::new()), 25800, Vec::new());

        assert_eq!(expected_result, actual_result);
    }

    #[test]
    fn test_refund_remint_burned_erc20_tokens() {
        let origin = Address::zero();
        let env = Fixed::default();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        let expected_state = EngineState::default();
        set_state(&mut io, expected_state.clone());
        let value = Wei::new_u64(1000);
        let args = RefundCallArgs {
            recipient_address: Default::default(),
            erc20_address: Some(origin),
            amount: RawU256::from(value.raw()),
        };
        let mut handler = Noop;
        let actual_result = refund_on_error(io, &env, expected_state, args, &mut handler).unwrap();
        let expected_result =
            SubmitResult::new(TransactionStatus::Succeed(Vec::new()), 21344, Vec::new());

        assert_eq!(expected_result, actual_result);
    }

    #[test]
    fn test_refund_free_effective_gas_does_nothing() {
        let origin = Address::zero();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        let expected_state = EngineState::default();
        set_state(&mut io, expected_state);
        let relayer = make_address(1, 1);
        let gas_result = GasPaymentResult {
            prepaid_amount: Default::default(),
            effective_gas_price: U256::zero(),
            priority_fee_per_gas: U256::zero(),
        };

        refund_unused_gas(&mut io, &origin, 1000, gas_result, &relayer).unwrap();
    }

    #[test]
    fn test_refund_gas_pays_expected_amount() {
        let origin = Address::zero();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);
        let expected_state = EngineState::default();
        set_state(&mut io, expected_state);
        let relayer = make_address(1, 1);
        let gas_result = GasPaymentResult {
            prepaid_amount: Wei::new_u64(8000),
            effective_gas_price: Wei::new_u64(1).raw(),
            priority_fee_per_gas: U256::zero(),
        };
        let gas_used = 4000;

        refund_unused_gas(&mut io, &origin, gas_used, gas_result, &relayer).unwrap();

        let actual_refund = get_balance(&io, &origin);
        let expected_refund = Wei::new_u64(gas_used);

        assert_eq!(expected_refund, actual_refund);
    }

    #[test]
    fn test_check_nonce_with_increment_succeeds() {
        let origin = Address::zero();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);

        increment_nonce(&mut io, &origin);
        check_nonce(&io, &origin, &U256::from(1u64)).unwrap();
    }

    #[test]
    fn test_check_nonce_without_increment_fails() {
        let origin = Address::zero();
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);

        increment_nonce(&mut io, &origin);
        let actual_error_kind = check_nonce(&io, &origin, &U256::from(0u64)).unwrap_err();
        let actual_error_kind = std::str::from_utf8(actual_error_kind.as_bytes()).unwrap();
        let expected_error_kind = std::str::from_utf8(errors::ERR_INCORRECT_NONCE).unwrap();

        assert_eq!(expected_error_kind, actual_error_kind);
    }

    #[test]
    fn test_missing_engine_state_is_not_found() {
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let io = StoragePointer(&storage);

        let actual_error = get_state(&io).unwrap_err();
        let actual_error = std::str::from_utf8(actual_error.as_ref()).unwrap();
        let expected_error = std::str::from_utf8(errors::ERR_STATE_NOT_FOUND).unwrap();

        assert_eq!(expected_error, actual_error);
    }

    #[test]
    fn test_empty_engine_state_is_corrupted() {
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let mut io = StoragePointer(&storage);

        io.write_storage(&bytes_to_key(KeyPrefix::Config, STATE_KEY), &[]);
        let actual_error = get_state(&io).unwrap_err();
        let actual_error = std::str::from_utf8(actual_error.as_ref()).unwrap();
        let expected_error = std::str::from_utf8(errors::ERR_STATE_CORRUPTED).unwrap();

        assert_eq!(expected_error, actual_error);
    }

    #[test]
    fn test_filtering_promises_from_logs_with_none_keeps_all() {
        let storage = Storage::default();
        let storage = RwLock::new(storage);
        let io = StoragePointer(&storage);
        let current_account_id = AccountId::default();
        let mut handler = Noop;
        let logs = vec![Log {
            address: Default::default(),
            topics: vec![],
            data: vec![],
        }];

        let actual_logs = filter_promises_from_logs(&io, &mut handler, logs, &current_account_id);
        let expected_logs = vec![ResultLog {
            address: Default::default(),
            topics: vec![],
            data: vec![],
        }];

        assert_eq!(expected_logs, actual_logs);
    }

    fn create_legacy_address(address: H160, nonce: U256) -> H160 {
        let mut stream = rlp::RlpStream::new_list(2);
        stream.append(&address);
        stream.append(&nonce);
        H256::from_slice(Keccak256::digest(&stream.out()).as_slice()).into()
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/errors.rs ---
pub const ERR_NOT_A_JSON_TYPE: &[u8; 19] = b"ERR_NOT_A_JSON_TYPE";
pub const ERR_JSON_MISSING_VALUE: &[u8; 22] = b"ERR_JSON_MISSING_VALUE";
pub const ERR_FAILED_PARSE_U8: &[u8; 19] = b"ERR_FAILED_PARSE_U8";
pub const ERR_FAILED_PARSE_U64: &[u8; 20] = b"ERR_FAILED_PARSE_U64";
pub const ERR_FAILED_PARSE_U128: &[u8; 21] = b"ERR_FAILED_PARSE_U128";
pub const ERR_FAILED_PARSE_BOOL: &[u8; 21] = b"ERR_FAILED_PARSE_BOOL";
pub const ERR_FAILED_PARSE_STRING: &[u8; 23] = b"ERR_FAILED_PARSE_STRING";
pub const ERR_FAILED_PARSE_ARRAY: &[u8; 22] = b"ERR_FAILED_PARSE_ARRAY";
pub const ERR_EXPECTED_STRING_GOT_NUMBER: &[u8; 30] = b"ERR_EXPECTED_STRING_GOT_NUMBER";
pub const ERR_OUT_OF_RANGE_U8: &[u8; 19] = b"ERR_OUT_OF_RANGE_U8";
pub const ERR_OUT_OF_RANGE_U128: &[u8; 21] = b"ERR_OUT_OF_RANGE_U128";

pub const ERR_PROMISE_COUNT: &[u8; 17] = b"ERR_PROMISE_COUNT";
pub const ERR_REFUND_FAILURE: &[u8; 18] = b"ERR_REFUND_FAILURE";
pub const ERR_NOT_ALLOWED_TOO_EARLY: &[u8; 25] = b"ERR_NOT_ALLOWED:TOO_EARLY";
pub const ERR_PROMISE_FAILED: &[u8; 18] = b"ERR_PROMISE_FAILED";
pub const ERR_VERIFY_PROOF: &[u8; 16] = b"ERR_VERIFY_PROOF";
pub const ERR_INVALID_UPGRADE: &[u8; 19] = b"ERR_INVALID_UPGRADE";
pub const ERR_NO_UPGRADE: &[u8; 14] = b"ERR_NO_UPGRADE";
pub const ERR_NOT_ALLOWED: &[u8; 20] = b"ERR_NOT_ALLOWED_TEST";

pub const ERR_SERIALIZE: &str = "ERR_SERIALIZE";
pub const ERR_PROMISE_ENCODING: &str = "ERR_PROMISE_ENCODING";
pub const ERR_ARGS: &str = "ERR_ARGS";
pub const ERR_VALUE_CONVERSION: &str = "ERR_VALUE_CONVERSION";

pub const ERR_BORSH_DESERIALIZE: &str = "ERR_BORSH_DESERIALIZE";
pub const ERR_META_TX_PARSE: &str = "ERR_META_TX_PARSE";

pub const ERR_STACK_UNDERFLOW: &[u8; 19] = b"ERR_STACK_UNDERFLOW";
pub const ERR_STACK_OVERFLOW: &[u8; 18] = b"ERR_STACK_OVERFLOW";
pub const ERR_INVALID_JUMP: &[u8; 16] = b"ERR_INVALID_JUMP";
pub const ERR_INVALID_RANGE: &[u8; 17] = b"ERR_INVALID_RANGE";
pub const ERR_DESIGNATED_INVALID: &[u8; 22] = b"ERR_DESIGNATED_INVALID";
pub const ERR_CALL_TOO_DEEP: &[u8; 17] = b"ERR_CALL_TOO_DEEP";
pub const ERR_CREATE_COLLISION: &[u8; 20] = b"ERR_CREATE_COLLISION";
pub const ERR_CREATE_CONTRACT_LIMIT: &[u8; 25] = b"ERR_CREATE_CONTRACT_LIMIT";
pub const ERR_OUT_OF_OFFSET: &[u8; 17] = b"ERR_OUT_OF_OFFSET";
pub const ERR_OUT_OF_GAS: &[u8; 14] = b"ERR_OUT_OF_GAS";
pub const ERR_OUT_OF_FUND: &[u8; 15] = b"ERR_OUT_OF_FUND";
pub const ERR_NOT_SUPPORTED: &[u8; 17] = b"ERR_NOT_SUPPORTED";
pub const ERR_UNHANDLED_INTERRUPT: &[u8; 23] = b"ERR_UNHANDLED_INTERRUPT";
pub const ERR_INCORRECT_NONCE: &[u8; 19] = b"ERR_INCORRECT_NONCE";
pub const ERR_INVALID_CHAIN_ID: &[u8; 20] = b"ERR_INVALID_CHAIN_ID";
pub const ERR_INVALID_ECDSA_SIGNATURE: &[u8; 27] = b"ERR_INVALID_ECDSA_SIGNATURE";
pub const ERR_INTRINSIC_GAS: &[u8; 17] = b"ERR_INTRINSIC_GAS";
pub const ERR_MAX_PRIORITY_FEE_GREATER: &[u8; 28] = b"ERR_MAX_PRIORITY_FEE_GREATER";
pub const ERR_GAS_OVERFLOW: &[u8; 16] = b"ERR_GAS_OVERFLOW";
pub const ERR_BALANCE_OVERFLOW: &[u8; 20] = b"ERR_BALANCE_OVERFLOW";
pub const ERR_GAS_ETH_AMOUNT_OVERFLOW: &[u8; 27] = b"ERR_GAS_ETH_AMOUNT_OVERFLOW";
pub const ERR_PARSE_ADDRESS: &[u8; 17] = b"ERR_PARSE_ADDRESS";
pub const ERR_STATE_NOT_FOUND: &[u8; 19] = b"ERR_STATE_NOT_FOUND";
pub const ERR_STATE_CORRUPTED: &[u8; 19] = b"ERR_STATE_CORRUPTED";

pub const ERR_CONNECTOR_STORAGE_KEY_NOT_FOUND: &[u8; 35] = b"ERR_CONNECTOR_STORAGE_KEY_NOT_FOUND";
pub const ERR_FAILED_DESERIALIZE_CONNECTOR_DATA: &[u8; 37] =
    b"ERR_FAILED_DESERIALIZE_CONNECTOR_DATA";
pub const ERR_PROOF_EXIST: &[u8; 15] = b"ERR_PROOF_EXIST";
pub const ERR_WRONG_EVENT_ADDRESS: &[u8; 23] = b"ERR_WRONG_EVENT_ADDRESS";
pub const ERR_CONTRACT_INITIALIZED: &[u8; 24] = b"ERR_CONTRACT_INITIALIZED";

pub const ERR_RLP_FAILED: &[u8; 14] = b"ERR_RLP_FAILED";
pub const ERR_PARSE_DEPOSIT_EVENT: &[u8; 23] = b"ERR_PARSE_DEPOSIT_EVENT";
pub const ERR_INVALID_EVENT_MESSAGE_FORMAT: &[u8; 32] = b"ERR_INVALID_EVENT_MESSAGE_FORMAT";
pub const ERR_INVALID_SENDER: &[u8; 18] = b"ERR_INVALID_SENDER";
pub const ERR_INVALID_AMOUNT: &[u8; 18] = b"ERR_INVALID_AMOUNT";
pub const ERR_INVALID_FEE: &[u8; 15] = b"ERR_INVALID_FEE";
pub const ERR_INVALID_ON_TRANSFER_MESSAGE_FORMAT: &[u8; 38] =
    b"ERR_INVALID_ON_TRANSFER_MESSAGE_FORMAT";
pub const ERR_INVALID_ON_TRANSFER_MESSAGE_HEX: &[u8; 35] = b"ERR_INVALID_ON_TRANSFER_MESSAGE_HEX";
pub const ERR_INVALID_ON_TRANSFER_MESSAGE_DATA: &[u8; 36] = b"ERR_INVALID_ON_TRANSFER_MESSAGE_DATA";
pub const ERR_INVALID_ACCOUNT_ID: &[u8; 22] = b"ERR_INVALID_ACCOUNT_ID";
pub const ERR_OVERFLOW_NUMBER: &[u8; 19] = b"ERR_OVERFLOW_NUMBER";

pub const ERR_TOTAL_SUPPLY_OVERFLOW: &[u8; 25] = b"ERR_TOTAL_SUPPLY_OVERFLOW";
pub const ERR_NOT_ENOUGH_BALANCE: &[u8; 22] = b"ERR_NOT_ENOUGH_BALANCE";
pub const ERR_TOTAL_SUPPLY_UNDERFLOW: &[u8; 26] = b"ERR_TOTAL_SUPPLY_UNDERFLOW";
pub const ERR_ZERO_AMOUNT: &[u8; 15] = b"ERR_ZERO_AMOUNT";
pub const ERR_SENDER_EQUALS_RECEIVER: &[u8; 26] = b"ERR_SENDER_EQUALS_RECEIVER";
pub const ERR_ACCOUNT_NOT_REGISTERED: &[u8; 26] = b"ERR_ACCOUNT_NOT_REGISTERED";
pub const ERR_NO_AVAILABLE_BALANCE: &[u8; 24] = b"ERR_NO_AVAILABLE_BALANCE";
pub const ERR_ATTACHED_DEPOSIT_NOT_ENOUGH: &[u8; 31] = b"ERR_ATTACHED_DEPOSIT_NOT_ENOUGH";
pub const ERR_FAILED_UNREGISTER_ACCOUNT_POSITIVE_BALANCE: &[u8; 46] =
    b"ERR_FAILED_UNREGISTER_ACCOUNT_POSITIVE_BALANCE";

pub const ERR_ACCOUNTS_COUNTER_OVERFLOW: &str = "ERR_ACCOUNTS_COUNTER_OVERFLOW";

pub const ERR_REVERT: &[u8; 10] = b"ERR_REVERT";
pub const ERR_OUT_OF_FUNDS: &[u8; 16] = b"ERR_OUT_OF_FUNDS";

'''
'''--- aurora-engine-2.8.1/engine/src/fungible_token.rs ---
use crate::connector::ZERO_ATTACHED_BALANCE;
use crate::engine;
use crate::json::{parse_json, JsonValue};
use crate::parameters::{NEP141FtOnTransferArgs, ResolveTransferCallArgs, StorageBalance};
use crate::prelude::account_id::AccountId;
use crate::prelude::Wei;
use crate::prelude::{
    sdk, storage, vec, Address, BTreeMap, Balance, BorshDeserialize, BorshSerialize, NearGas,
    PromiseAction, PromiseBatchAction, PromiseCreateArgs, PromiseResult, PromiseWithCallbackArgs,
    StorageBalanceBounds, StorageUsage, String, ToString, Vec,
};
use aurora_engine_sdk::io::{StorageIntermediate, IO};
use aurora_engine_types::types::{NEP141Wei, Yocto, ZERO_NEP141_WEI, ZERO_YOCTO};

/// Gas for `resolve_transfer`: 5 TGas
const GAS_FOR_RESOLVE_TRANSFER: NearGas = NearGas::new(5_000_000_000_000);
/// Gas for `ft_on_transfer`
const GAS_FOR_FT_TRANSFER_CALL: NearGas = NearGas::new(35_000_000_000_000);

#[derive(Debug, Default, BorshDeserialize, BorshSerialize)]
pub struct FungibleToken {
    /// Total ETH supply on Near (nETH as NEP-141 token)
    pub total_eth_supply_on_near: NEP141Wei,

    /// Total ETH supply on Aurora (ETH in Aurora EVM)
    /// NOTE: For compatibility reasons, we do not use  `Wei` (32 bytes)
    /// buy `NEP141Wei` (16 bytes)
    pub total_eth_supply_on_aurora: NEP141Wei,

    /// The storage size in bytes for one account.
    pub account_storage_usage: StorageUsage,
}

impl FungibleToken {
    pub fn ops<I: IO>(self, io: I) -> FungibleTokenOps<I> {
        FungibleTokenOps {
            total_eth_supply_on_near: self.total_eth_supply_on_near,
            total_eth_supply_on_aurora: Wei::from(self.total_eth_supply_on_aurora),
            account_storage_usage: self.account_storage_usage,
            io,
        }
    }
}

pub struct FungibleTokenOps<I: IO> {
    /// Total ETH supply on Near (nETH as NEP-141 token)
    pub total_eth_supply_on_near: NEP141Wei,

    /// Total ETH supply on Aurora (ETH in Aurora EVM)
    pub total_eth_supply_on_aurora: Wei,

    /// The storage size in bytes for one account.
    pub account_storage_usage: StorageUsage,

    io: I,
}

/// Fungible token Reference hash type.
/// Used for FungibleTokenMetadata
#[derive(Debug, BorshDeserialize, BorshSerialize, Clone, PartialEq, Eq)]
pub struct FungibleReferenceHash([u8; 32]);

impl FungibleReferenceHash {
    /// Encode to base64-encoded string
    pub fn encode(&self) -> String {
        base64::encode(self)
    }
}

impl AsRef<[u8]> for FungibleReferenceHash {
    fn as_ref(&self) -> &[u8] {
        &self.0
    }
}

#[derive(Debug, BorshDeserialize, BorshSerialize, Clone, PartialEq, Eq)]
pub struct FungibleTokenMetadata {
    pub spec: String,
    pub name: String,
    pub symbol: String,
    pub icon: Option<String>,
    pub reference: Option<String>,
    pub reference_hash: Option<FungibleReferenceHash>,
    pub decimals: u8,
}

impl Default for FungibleTokenMetadata {
    fn default() -> Self {
        Self {
            spec: "ft-1.0.0".to_string(),
            name: "Ether".to_string(),
            symbol: "ETH".to_string(),
            icon: Some("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAYAAABw4pVUAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsQAAA7EAZUrDhsAAAs3SURBVHhe7Z1XqBQ9FMdFsYu999577wUfbCiiPoggFkQsCKJP9t57V7AgimLBjg8qKmLBXrD33hVUEAQ1H7+QXMb9Zndnd+/MJJf7h8Pu3c3Mzua3yTk5SeZmEZkySplADFMmEMOUCcQwZQggHz58EHfu3FF/2a0MAWTjxo2iWbNm6i+7ZT2QW7duiUWLFolixYqJQ4cOqVftlfVAZs6cKdauXSuqV68uKlWqpF61V1YDoUXMmTNHrFu3TtSoUUNCmTBhgnrXTlkL5Nu3b2Ly5MmyuwJIzZo1RaNGjUTx4sXFu3fvVCn7ZC2QVatWiQULFvwPSL169USnTp1UKftkJZCbN2+KGTNmSBiLFy/+BwhWoUIFsX//flXaLlkJZPr06WkwIoE0btxYNGzYUFSsWFGVtkvWATlw4IB05BqGGxAMBz9u3Dh1lD2yCsjXr1/THHk8IDwvVaqUeP36tTraDlkFZOXKldKRO2HEAoKD79ixozraDlkD5Pr16/848nhANBQc/N69e9VZzJc1QCIduRcgGA4eKLbICiD79u37nyN3WiwgvMZ7Y8eOVWczW8YDwZFPmTIlauvA4gHhsUSJEuLFixfqrObKeCArVqxwdeROiwUE43UcfNu2bdVZzZXRQK5duyYduRsEp8UDog1fsnPnTnV2M2U0kFiO3GlegeDgy5cvr85upowFQqg6d+5cVwCR5hUI71NuzJgx6lPMk5FAPn365Doij2ZegWCUIUX/9OlT9WlmyUggy5Yti+vInZYIEAwH37JlS/VpZsk4IJcvX5bTsl5bB5YoEMqRDd62bZv6VHNkHJBp06YlBANLFAiGgy9btqz6VHNkFJBdu3Z5duROSwYIxjEjRoxQn26GjAHy8ePHuCPyaJYsEMozgn/48KG6ivBlDJAlS5Yk5MidlgqQ+vXri+bNm6urCF9GALl48aJ05G6V7cWSBYJxDOu5Nm/erK4mXBkBJBlH7rRUgGAmOfjQgZBbSsaROy1VIBjHDxs2TF1VeAoVyPv37+WI3K2SE7H0AMKxJUuWFHfv3lVXF45CBZKKI3daegDBcPBNmzZVVxeOQgNy/vz5hEfkbsbxAGFtb6pAOL5y5cpye0NYCg1Iqo5c29KlS2WEVKdOHdGkSZOUoeDgS5cura4yeIUCZMeOHWLevHkpASEBScvAB/Xs2VMUKVJE1K1bV44pUgHDcbVq1RJDhgxRVxusAgfy5s0bMXXq1IRgOMsuX75c7gcZP368aN++vez3W7VqJfLnzy8KFCggU+tUKNncZMFwDA6eNcRBK3AgCxculOas8HiG82duffXq1WLkyJGiRYsWokGDBrI1UPHMlQOjaNGisqUUKlRIPrKclLKA0RUdWfnRDNCUD1qBAjl79qyYNWuWa6VHGq0CEGw7oHsaNGiQrCBMg9DmBKJNgylYsKAciQOFfYhUtlcwHEe3GKQCA/Lnzx/PyUMc9Zo1a+SAsV+/fvLXSgXxa3eCiAXECaZw4cISDPPpGijniweG93HwXHtQCgwIk0E4cjcAGhItAf8AuG7dukknzbgAENFgYLGAaNNgKMcibGYNdXdGxUeDgz8aOHCg+hb+KxAgr169kpUcCUKb01GzOJrKonuJB0KbFyBOAw4thgCgdu3aaWAA4AYGB8/a4iAUCBBG405Hrv2Dm6MGhFulx7JEgWjTYHisVq2a/GxapBMGgLguLAj5DuTMmTP/OHLtqPETdAW6u4h01IlYskC06e6MIICROlA0GH19vM51+y1fgfz+/TvNkWtHjR/p27ev7JboJrx2S7EsVSAYUDCgcC4CAEbtXJsGg4PnO/kpX4Fs3bpVwiB0BEz37t09O+pELD2AOE23GM5ZpkwZGeVxraRnBgwYoL6dP/INCCNyfAeOukOHDmmZVLcKTdXSG4jTNBidAaDlXLlyRX3L9JdvQPr06SObvHbU6dUa3MxPINp0d5Y3b16RJ08e9S3TX74Befz4sejcubOoWrWqdNi2AgEEj8DIkiWLdO4PHjxQ3zL95asPQQcPHpSTR/gOv6D4BUQ7+uzZs4usWbOK7du3q2/ln3wHosU+j3LlysmIxa1SUzG/gOTLl0+2ilGjRqlv4b8CA4K+fPkievXqJZt9MgPAaJbeQHT3hA9kJX6QChSI1smTJ+U4RKct3Co5EUsvIHRP2bJlEzlz5hRHjhxRVxusfANy4cIF9Sy6GLnrAZhbRXu1VIEAguiJVuHlfltbtmxRz9JfvgHhxpQMBt++fatecdfPnz/lYIvtAcmOU1IBQi4LEG3atJHXEkssEWK0fvv2bfVK+svXLosJKW4AQ3QSb07h6tWr0uEz+Eq0G0sGCAM+IieOI98WS3///hVDhw4VOXLkkAlRP+W7D9mwYYNMLtJa4n1xRBqe3bIMKL2CSQQI3VPu3Lllq+C64olsNPMnBCJdunRRr/qnQJw6IS/pdypg/vz5cff38YscPny49C9eujGvQCgDiB49eqhPii4WgJPuAQQ+Lqi1v4EAefToUVrWFzCsyWIx2q9fv1QJd92/f1+0bt1aLlaINdqPB4TuCRD80rmtbCzhR8hG66SizvKeOHFClfBXgQBBe/bskfcr0dO1pOFZU3Xs2DFVIrqY/q1SpUpa1tUrELqnXLlySRhe5jKYw2d2kHBcz4OwIjLIXVaBAUF0V5Ezh7Nnz5Z27949VSq6CBDoOphHiQYECDyyTgsQ/fv3V0dH1/Hjx2V6h7wbEAguMH4ABBlBKlAgbneE090Yd21Yv369+P79uyrtrpcvX/6TtIwEorsnlvA8efJEHeUuRuFdu3aVKR2CCCcMnpNyf/78uSodjAIFgk6fPh11txQtCGBebhlO0pLuhKSlBkISEBhMjMXTxIkTZYVzvBOEhgFQriloBQ4EEUrGWhKEryEyu3HjhjoiuggWqDxAeOnrufcW5QkUIkFoGEBiUi0MhQKEeel4q995DyjcZ/Hz58/qSHfRrcTbSUuZdu3ayTEOYawbDIz3iLDiRYB+KRQgiP/3waJrNxjagMI0MK2AKC1ZjR49Wm5/JqEZDQTGe8A4fPiwOjJ4hQYEsS3By/5CwFCOVsWAzatIAhKVed3MQznWEIepUIEg/IUzFI5lgCEgYG1XrKQlyT9CY3wFXZBb5UcaURZ+JWyFDoSs8KRJk2L6E6dRDoB0YyQtneukSGAOHjxYDu70KNut8iONckRcJvzbpNCBIAZmXrcpYBoekRpgyBQzhiE1wkDOKwiMsuSr6BJNkBFAENEU45DIyo9nwGGxNs44ERAY5QlxmQsxRcYAIcxMdKubtmS3RVOe7u3Hjx/qKsKXMUAQA0EiKbdKj2XJAiEC2717t/p0M2QUEETaw0so7LREgVCO8l4Sj0HLOCAIB+81FMYSAUIZQmGSkybKSCAs1I7MCseyRIEwaveSJwtDRgJBR48e9RwKewXC+0x0AdtUGQsEMSL3cnMaL0B4j1wWc/Qmy2ggzG/ruXg3ENq8AmHgyCSZyTIaCLp06VLce8DHA8LrrGDxMnEVtowHgjZt2hR1QguLB4R0Su/evdXZzJYVQJBe25UoELK4Nv1PQ2uAPHv2LKo/iQaEv0mNeFn4bYqsAYL4p5IsGfIChOfMb7Dp1CZZBQTRQiJDYTcgerrWNlkHhHVbkV1XJBAemXDirqe2yTog6Ny5c9LJayhOIBgrS1h1b6OsBIKocB0KO4FwtwVu7WSrrAWC9NouDYQsLstCbZbVQNjmwCwjQFjCwzTuqVOn1Lt2ymogiBk/PafOfbdsl/VAEEBs+gfEsZQhgDChxVKgjKAMASQjKROIYcoEYpgygRglIf4D6lp/+XognSwAAAAASUVORK5CYII=".to_string()),
            reference: None,
            reference_hash: None,
            decimals: 18,
        }
    }
}

impl From<FungibleTokenMetadata> for JsonValue {
    fn from(metadata: FungibleTokenMetadata) -> Self {
        let mut kvs = BTreeMap::new();
        kvs.insert("spec".to_string(), JsonValue::String(metadata.spec));
        kvs.insert("name".to_string(), JsonValue::String(metadata.name));
        kvs.insert("symbol".to_string(), JsonValue::String(metadata.symbol));
        kvs.insert(
            "icon".to_string(),
            metadata
                .icon
                .map(JsonValue::String)
                .unwrap_or(JsonValue::Null),
        );
        kvs.insert(
            "reference".to_string(),
            metadata
                .reference
                .map(JsonValue::String)
                .unwrap_or(JsonValue::Null),
        );
        kvs.insert(
            "reference_hash".to_string(),
            metadata
                .reference_hash
                .map(|hash| JsonValue::String(hash.encode()))
                .unwrap_or(JsonValue::Null),
        );
        kvs.insert(
            "decimals".to_string(),
            JsonValue::U64(u64::from(metadata.decimals)),
        );

        JsonValue::Object(kvs)
    }
}

impl<I: IO + Copy> FungibleTokenOps<I> {
    pub fn new(io: I) -> Self {
        FungibleToken::default().ops(io)
    }

    pub fn data(&self) -> FungibleToken {
        FungibleToken {
            total_eth_supply_on_near: self.total_eth_supply_on_near,
            // TODO: both types should be same
            // ut must never panic
            total_eth_supply_on_aurora: NEP141Wei::new(
                self.total_eth_supply_on_aurora.try_into_u128().unwrap(),
            ),
            account_storage_usage: self.account_storage_usage,
        }
    }

    /// Balance of ETH (ETH on Aurora)
    pub fn internal_unwrap_balance_of_eth_on_aurora(&self, address: &Address) -> Wei {
        engine::get_balance(&self.io, address)
    }

    /// Internal ETH deposit to NEAR - nETH (NEP-141)
    pub fn internal_deposit_eth_to_near(
        &mut self,
        account_id: &AccountId,
        amount: NEP141Wei,
    ) -> Result<(), error::DepositError> {
        let balance = self
            .get_account_eth_balance(account_id)
            .unwrap_or(ZERO_NEP141_WEI);
        let new_balance = balance
            .checked_add(amount)
            .ok_or(error::DepositError::BalanceOverflow)?;
        self.accounts_insert(account_id, new_balance);
        self.total_eth_supply_on_near = self
            .total_eth_supply_on_near
            .checked_add(amount)
            .ok_or(error::DepositError::TotalSupplyOverflow)?;
        Ok(())
    }

    /// Internal ETH deposit to Aurora
    pub fn internal_deposit_eth_to_aurora(
        &mut self,
        address: Address,
        amount: Wei,
    ) -> Result<(), error::DepositError> {
        let balance = self.internal_unwrap_balance_of_eth_on_aurora(&address);
        let new_balance = balance
            .checked_add(amount)
            .ok_or(error::DepositError::BalanceOverflow)?;
        engine::set_balance(&mut self.io, &address, &new_balance);
        self.total_eth_supply_on_aurora = self
            .total_eth_supply_on_aurora
            .checked_add(amount)
            .ok_or(error::DepositError::TotalSupplyOverflow)?;
        Ok(())
    }

    /// Withdraw NEAR tokens
    pub fn internal_withdraw_eth_from_near(
        &mut self,
        account_id: &AccountId,
        amount: NEP141Wei,
    ) -> Result<(), error::WithdrawError> {
        let balance = self
            .get_account_eth_balance(account_id)
            .unwrap_or(ZERO_NEP141_WEI);
        let new_balance = balance
            .checked_sub(amount)
            .ok_or(error::WithdrawError::InsufficientFunds)?;
        self.accounts_insert(account_id, new_balance);
        self.total_eth_supply_on_near = self
            .total_eth_supply_on_near
            .checked_sub(amount)
            .ok_or(error::WithdrawError::TotalSupplyUnderflow)?;
        Ok(())
    }

    /// Withdraw ETH tokens
    pub fn internal_withdraw_eth_from_aurora(
        &mut self,
        amount: Wei,
    ) -> Result<(), error::WithdrawError> {
        self.total_eth_supply_on_aurora = self
            .total_eth_supply_on_aurora
            .checked_sub(amount)
            .ok_or(error::WithdrawError::TotalSupplyUnderflow)?;
        Ok(())
    }

    /// Transfer NEAR tokens
    pub fn internal_transfer_eth_on_near(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: NEP141Wei,
        #[allow(unused_variables)] memo: &Option<String>,
    ) -> Result<(), error::TransferError> {
        if sender_id == receiver_id {
            return Err(error::TransferError::SelfTransfer);
        }
        if amount == ZERO_NEP141_WEI {
            return Err(error::TransferError::ZeroAmount);
        }

        // Check is account receiver_id exist
        if !self.accounts_contains_key(receiver_id) {
            // Register receiver_id account with 0 balance. We need it because
            // when we retire to get the balance of `receiver_id` it will fail
            // if it does not exist.
            self.internal_register_account(receiver_id)
        }
        self.internal_withdraw_eth_from_near(sender_id, amount)?;
        self.internal_deposit_eth_to_near(receiver_id, amount)?;
        sdk::log!("Transfer {} from {} to {}", amount, sender_id, receiver_id);
        #[cfg(feature = "log")]
        if let Some(memo) = memo {
            sdk::log!("Memo: {}", memo);
        }
        Ok(())
    }

    pub fn internal_register_account(&mut self, account_id: &AccountId) {
        self.accounts_insert(account_id, ZERO_NEP141_WEI)
    }

    pub fn ft_total_eth_supply_on_near(&self) -> NEP141Wei {
        self.total_eth_supply_on_near
    }

    pub fn ft_total_eth_supply_on_aurora(&self) -> Wei {
        self.total_eth_supply_on_aurora
    }

    pub fn ft_balance_of(&self, account_id: &AccountId) -> NEP141Wei {
        self.get_account_eth_balance(account_id)
            .unwrap_or(ZERO_NEP141_WEI)
    }

    #[allow(clippy::too_many_arguments)]
    pub fn ft_transfer_call(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: NEP141Wei,
        memo: &Option<String>,
        msg: String,
        current_account_id: AccountId,
        prepaid_gas: NearGas,
    ) -> Result<PromiseWithCallbackArgs, error::TransferError> {
        // Special case for Aurora transfer itself - we shouldn't transfer
        if sender_id != receiver_id {
            self.internal_transfer_eth_on_near(&sender_id, &receiver_id, amount, memo)?;
        }
        let data1: String = NEP141FtOnTransferArgs {
            amount: Balance::new(amount.as_u128()),
            msg,
            sender_id: sender_id.clone(),
        }
        .try_into()
        .unwrap();

        let data2 = ResolveTransferCallArgs {
            receiver_id: receiver_id.clone(),
            amount,
            sender_id,
        }
        .try_to_vec()
        .unwrap();
        // Initiating receiver's call and the callback
        let ft_on_transfer_call = PromiseCreateArgs {
            target_account_id: receiver_id,
            method: "ft_on_transfer".to_string(),
            args: data1.into_bytes(),
            attached_balance: ZERO_ATTACHED_BALANCE,
            attached_gas: prepaid_gas - GAS_FOR_FT_TRANSFER_CALL - GAS_FOR_RESOLVE_TRANSFER,
        };
        let ft_resolve_transfer_call = PromiseCreateArgs {
            target_account_id: current_account_id,
            method: "ft_resolve_transfer".to_string(),
            args: data2,
            attached_balance: ZERO_ATTACHED_BALANCE,
            attached_gas: GAS_FOR_RESOLVE_TRANSFER,
        };
        Ok(PromiseWithCallbackArgs {
            base: ft_on_transfer_call,
            callback: ft_resolve_transfer_call,
        })
    }

    pub fn internal_ft_resolve_transfer(
        &mut self,
        promise_result: PromiseResult,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: NEP141Wei,
    ) -> (NEP141Wei, NEP141Wei) {
        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match promise_result {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(value) => {
                if let Some(raw_unused_amount) =
                    parse_json(value.as_slice()).and_then(|x| (&x).try_into().ok())
                {
                    let unused_amount = NEP141Wei::new(raw_unused_amount);
                    // let unused_amount = Balance::from(raw_unused_amount);
                    if amount > unused_amount {
                        unused_amount
                    } else {
                        amount
                    }
                } else {
                    amount
                }
            }
            PromiseResult::Failed => amount,
        };

        if unused_amount > ZERO_NEP141_WEI {
            let receiver_balance = self
                .get_account_eth_balance(receiver_id)
                .unwrap_or_else(|| {
                    self.accounts_insert(receiver_id, ZERO_NEP141_WEI);
                    ZERO_NEP141_WEI
                });
            if receiver_balance > ZERO_NEP141_WEI {
                let refund_amount = if receiver_balance > unused_amount {
                    unused_amount
                } else {
                    receiver_balance
                };
                self.accounts_insert(receiver_id, receiver_balance - refund_amount);
                sdk::log!(
                    "Decrease receiver {} balance to: {}",
                    receiver_id,
                    receiver_balance - refund_amount
                );

                return if let Some(sender_balance) = self.get_account_eth_balance(sender_id) {
                    self.accounts_insert(sender_id, sender_balance + refund_amount);
                    sdk::log!(
                        "Refund amount {} from {} to {}",
                        refund_amount,
                        receiver_id,
                        sender_id
                    );
                    (amount - refund_amount, ZERO_NEP141_WEI)
                } else {
                    // Sender's account was deleted, so we need to burn tokens.
                    self.total_eth_supply_on_near -= refund_amount;
                    sdk::log!("The account of the sender was deleted");
                    (amount, refund_amount)
                };
            }
        }
        (amount, ZERO_NEP141_WEI)
    }

    pub fn ft_resolve_transfer(
        &mut self,
        promise_result: PromiseResult,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: NEP141Wei,
    ) -> NEP141Wei {
        self.internal_ft_resolve_transfer(promise_result, sender_id, receiver_id, amount)
            .0
    }

    pub fn internal_storage_unregister(
        &mut self,
        account_id: AccountId,
        force: Option<bool>,
    ) -> Result<(NEP141Wei, PromiseBatchAction), error::StorageFundingError> {
        let force = force.unwrap_or(false);
        if let Some(balance) = self.get_account_eth_balance(&account_id) {
            if balance == ZERO_NEP141_WEI || force {
                self.accounts_remove(&account_id);
                self.total_eth_supply_on_near -= balance;
                let storage_deposit = self.storage_balance_of(&account_id);
                let action = PromiseAction::Transfer {
                    // The `+ 1` is to cover the 1 yoctoNEAR necessary to call this function in the first place.
                    amount: storage_deposit.total + Yocto::new(1),
                };
                let promise = PromiseBatchAction {
                    target_account_id: account_id,
                    actions: vec![action],
                };
                Ok((balance, promise))
            } else {
                Err(error::StorageFundingError::UnRegisterPositiveBalance)
            }
        } else {
            sdk::log!("The account {} is not registered", account_id);
            Err(error::StorageFundingError::NotRegistered)
        }
    }

    pub fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        let required_storage_balance =
            Yocto::new(u128::from(self.account_storage_usage) * sdk::storage_byte_cost());
        StorageBalanceBounds {
            min: required_storage_balance,
            max: Some(required_storage_balance),
        }
    }

    pub fn internal_storage_balance_of(&self, account_id: &AccountId) -> Option<StorageBalance> {
        if self.accounts_contains_key(account_id) {
            Some(StorageBalance {
                total: self.storage_balance_bounds().min,
                available: ZERO_YOCTO,
            })
        } else {
            None
        }
    }

    pub fn storage_balance_of(&self, account_id: &AccountId) -> StorageBalance {
        self.internal_storage_balance_of(account_id)
            .unwrap_or_default()
    }

    // `registration_only` doesn't affect the implementation for vanilla fungible token.
    #[allow(unused_variables)]
    pub fn storage_deposit(
        &mut self,
        predecessor_account_id: AccountId,
        account_id: &AccountId,
        amount: Yocto,
        registration_only: Option<bool>,
    ) -> Result<(StorageBalance, Option<PromiseBatchAction>), error::StorageFundingError> {
        let promise = if self.accounts_contains_key(account_id) {
            sdk::log!("The account is already registered, refunding the deposit");
            if amount > ZERO_YOCTO {
                let action = PromiseAction::Transfer { amount };
                let promise = PromiseBatchAction {
                    target_account_id: predecessor_account_id,
                    actions: vec![action],
                };
                Some(promise)
            } else {
                None
            }
        } else {
            let min_balance = self.storage_balance_bounds().min;
            if amount < min_balance {
                return Err(error::StorageFundingError::InsufficientDeposit);
            }

            self.internal_register_account(account_id);
            let refund = amount - min_balance;
            if refund > ZERO_YOCTO {
                let action = PromiseAction::Transfer { amount: refund };
                let promise = PromiseBatchAction {
                    target_account_id: predecessor_account_id,
                    actions: vec![action],
                };
                Some(promise)
            } else {
                None
            }
        };
        let balance = self.internal_storage_balance_of(account_id).unwrap();
        Ok((balance, promise))
    }

    pub fn storage_withdraw(
        &mut self,
        account_id: &AccountId,
        amount: Option<Yocto>,
    ) -> Result<StorageBalance, error::StorageFundingError> {
        if let Some(storage_balance) = self.internal_storage_balance_of(account_id) {
            match amount {
                Some(amount) if amount > ZERO_YOCTO => {
                    // The available balance is always zero because `StorageBalanceBounds::max` is
                    // equal to `StorageBalanceBounds::min`. Therefore it is impossible to withdraw
                    // a positive amount.
                    Err(error::StorageFundingError::NoAvailableBalance)
                }
                _ => Ok(storage_balance),
            }
        } else {
            Err(error::StorageFundingError::NotRegistered)
        }
    }

    /// Insert account.
    /// Calculate total unique accounts
    pub fn accounts_insert(&mut self, account_id: &AccountId, amount: NEP141Wei) {
        if !self.accounts_contains_key(account_id) {
            let key = Self::get_statistic_key();
            let accounts_counter = self
                .io
                .read_u64(&key)
                .unwrap_or(0)
                .checked_add(1)
                .expect(crate::errors::ERR_ACCOUNTS_COUNTER_OVERFLOW);
            self.io.write_storage(&key, &accounts_counter.to_le_bytes());
        }
        self.io
            .write_borsh(&Self::account_to_key(account_id), &amount);
    }

    /// Get accounts counter for statistics
    /// It represents total unique accounts.
    pub fn get_accounts_counter(&self) -> u64 {
        self.io.read_u64(&Self::get_statistic_key()).unwrap_or(0)
    }

    fn accounts_contains_key(&self, account_id: &AccountId) -> bool {
        self.io.storage_has_key(&Self::account_to_key(account_id))
    }

    fn accounts_remove(&mut self, account_id: &AccountId) {
        self.io.remove_storage(&Self::account_to_key(account_id));
    }

    /// Balance of nETH (ETH on NEAR token)
    pub fn get_account_eth_balance(&self, account_id: &AccountId) -> Option<NEP141Wei> {
        self.io
            .read_storage(&Self::account_to_key(account_id))
            .and_then(|s| NEP141Wei::try_from_slice(&s.to_vec()).ok())
    }

    /// Fungible token key
    fn account_to_key(account_id: &AccountId) -> Vec<u8> {
        let mut key = storage::bytes_to_key(
            storage::KeyPrefix::EthConnector,
            &[u8::from(storage::EthConnectorStorageId::FungibleToken)],
        );
        key.extend_from_slice(account_id.as_bytes());
        key
    }

    /// Key for store contract statistics data
    fn get_statistic_key() -> Vec<u8> {
        storage::bytes_to_key(
            crate::prelude::storage::KeyPrefix::EthConnector,
            &[u8::from(
                crate::prelude::EthConnectorStorageId::StatisticsAuroraAccountsCounter,
            )],
        )
    }
}

pub mod error {
    use crate::errors;
    use crate::prelude::types::balance::error::BalanceOverflowError;

    const TOTAL_SUPPLY_OVERFLOW: &[u8; 25] = errors::ERR_TOTAL_SUPPLY_OVERFLOW;
    const BALANCE_OVERFLOW: &[u8; 20] = errors::ERR_BALANCE_OVERFLOW;
    const NOT_ENOUGH_BALANCE: &[u8; 22] = errors::ERR_NOT_ENOUGH_BALANCE;
    const TOTAL_SUPPLY_UNDERFLOW: &[u8; 26] = errors::ERR_TOTAL_SUPPLY_UNDERFLOW;
    const ZERO_AMOUNT: &[u8; 15] = errors::ERR_ZERO_AMOUNT;
    const SELF_TRANSFER: &[u8; 26] = errors::ERR_SENDER_EQUALS_RECEIVER;

    #[derive(Debug)]
    pub enum DepositError {
        TotalSupplyOverflow,
        BalanceOverflow,
    }

    impl AsRef<[u8]> for DepositError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::TotalSupplyOverflow => TOTAL_SUPPLY_OVERFLOW,
                Self::BalanceOverflow => BALANCE_OVERFLOW,
            }
        }
    }

    #[derive(Debug)]
    pub enum WithdrawError {
        TotalSupplyUnderflow,
        InsufficientFunds,
        BalanceOverflow(BalanceOverflowError),
    }

    impl AsRef<[u8]> for WithdrawError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::TotalSupplyUnderflow => TOTAL_SUPPLY_UNDERFLOW,
                Self::InsufficientFunds => NOT_ENOUGH_BALANCE,
                Self::BalanceOverflow(e) => e.as_ref(),
            }
        }
    }

    #[derive(Debug)]
    pub enum TransferError {
        TotalSupplyUnderflow,
        TotalSupplyOverflow,
        InsufficientFunds,
        BalanceOverflow,
        ZeroAmount,
        SelfTransfer,
    }

    impl AsRef<[u8]> for TransferError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::TotalSupplyUnderflow => TOTAL_SUPPLY_UNDERFLOW,
                Self::TotalSupplyOverflow => TOTAL_SUPPLY_OVERFLOW,
                Self::InsufficientFunds => NOT_ENOUGH_BALANCE,
                Self::BalanceOverflow => BALANCE_OVERFLOW,
                Self::ZeroAmount => ZERO_AMOUNT,
                Self::SelfTransfer => SELF_TRANSFER,
            }
        }
    }

    impl From<WithdrawError> for TransferError {
        fn from(err: WithdrawError) -> Self {
            match err {
                WithdrawError::InsufficientFunds => Self::InsufficientFunds,
                WithdrawError::TotalSupplyUnderflow => Self::TotalSupplyUnderflow,
                WithdrawError::BalanceOverflow(_) => Self::BalanceOverflow,
            }
        }
    }

    impl From<DepositError> for TransferError {
        fn from(err: DepositError) -> Self {
            match err {
                DepositError::BalanceOverflow => Self::BalanceOverflow,
                DepositError::TotalSupplyOverflow => Self::TotalSupplyOverflow,
            }
        }
    }

    #[derive(Debug)]
    pub enum StorageFundingError {
        NotRegistered,
        NoAvailableBalance,
        InsufficientDeposit,
        UnRegisterPositiveBalance,
    }

    impl AsRef<[u8]> for StorageFundingError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::NotRegistered => errors::ERR_ACCOUNT_NOT_REGISTERED,
                Self::NoAvailableBalance => errors::ERR_NO_AVAILABLE_BALANCE,
                Self::InsufficientDeposit => errors::ERR_ATTACHED_DEPOSIT_NOT_ENOUGH,
                Self::UnRegisterPositiveBalance => {
                    errors::ERR_FAILED_UNREGISTER_ACCOUNT_POSITIVE_BALANCE
                }
            }
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/json.rs ---
use crate::prelude::{BTreeMap, String, Vec};

use crate::errors;
use core::convert::From;
use rjson::{Array, Null, Object, Value};

#[derive(PartialEq)]
pub enum JsonValue {
    Null,
    F64(f64),
    I64(i64),
    U64(u64),
    Bool(bool),
    String(String),
    Array(Vec<JsonValue>),
    Object(BTreeMap<String, JsonValue>),
}

#[derive(Ord, PartialOrd, Eq, PartialEq)]
pub enum JsonError {
    NotJsonType,
    MissingValue,
    InvalidU8,
    InvalidU64,
    InvalidU128,
    InvalidBool,
    InvalidString,
    ExpectedStringGotNumber,
    OutOfRange(JsonOutOfRangeError),
}

#[derive(Debug, Ord, PartialOrd, Eq, PartialEq)]
pub enum JsonOutOfRangeError {
    OutOfRangeU8,
    OutOfRangeU128,
}

#[derive(Debug, Ord, PartialOrd, Eq, PartialEq)]
pub enum ParseError {
    InvalidAccountId,
}

pub struct JsonArray(Vec<JsonValue>);
pub struct JsonObject(BTreeMap<String, JsonValue>);

impl JsonValue {
    #[allow(dead_code)]
    pub fn string(&self, key: &str) -> Result<String, JsonError> {
        match self {
            JsonValue::Object(o) => match o.get(key).ok_or(JsonError::MissingValue)? {
                JsonValue::String(s) => Ok(s.into()),
                _ => Err(JsonError::InvalidString),
            },
            _ => Err(JsonError::NotJsonType),
        }
    }

    #[allow(dead_code)]
    pub fn u64(&self, key: &str) -> Result<u64, JsonError> {
        match self {
            JsonValue::Object(o) => match o.get(key).ok_or(JsonError::MissingValue)? {
                JsonValue::U64(n) => Ok(*n),
                _ => Err(JsonError::InvalidU64),
            },
            _ => Err(JsonError::NotJsonType),
        }
    }

    #[allow(dead_code)]
    pub fn u128(&self, key: &str) -> Result<u128, JsonError> {
        match self {
            JsonValue::Object(o) => o.get(key).ok_or(JsonError::MissingValue)?.try_into(),
            _ => Err(JsonError::NotJsonType),
        }
    }

    #[allow(dead_code)]
    pub fn bool(&self, key: &str) -> Result<bool, JsonError> {
        match self {
            JsonValue::Object(o) => match o.get(key).ok_or(JsonError::MissingValue)? {
                JsonValue::Bool(n) => Ok(*n),
                _ => Err(JsonError::InvalidBool),
            },
            _ => Err(JsonError::NotJsonType),
        }
    }

    #[allow(dead_code)]
    pub fn parse_u8(v: &JsonValue) -> Result<u8, JsonError> {
        match v {
            JsonValue::U64(n) => match u8::try_from(*n) {
                Ok(v) => Ok(v),
                Err(_e) => Err(JsonError::OutOfRange(JsonOutOfRangeError::OutOfRangeU8)),
            },
            _ => Err(JsonError::InvalidU8),
        }
    }
}

impl AsRef<[u8]> for JsonError {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::NotJsonType => errors::ERR_NOT_A_JSON_TYPE,
            Self::MissingValue => errors::ERR_JSON_MISSING_VALUE,
            Self::InvalidU8 => errors::ERR_FAILED_PARSE_U8,
            Self::InvalidU64 => errors::ERR_FAILED_PARSE_U64,
            Self::InvalidU128 => errors::ERR_FAILED_PARSE_U128,
            Self::InvalidBool => errors::ERR_FAILED_PARSE_BOOL,
            Self::InvalidString => errors::ERR_FAILED_PARSE_STRING,
            Self::ExpectedStringGotNumber => errors::ERR_EXPECTED_STRING_GOT_NUMBER,
            Self::OutOfRange(err) => err.as_ref(),
        }
    }
}

impl AsRef<[u8]> for JsonOutOfRangeError {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::OutOfRangeU8 => errors::ERR_OUT_OF_RANGE_U8,
            Self::OutOfRangeU128 => errors::ERR_OUT_OF_RANGE_U128,
        }
    }
}

impl Array<JsonValue, JsonObject, JsonValue> for JsonArray {
    fn new() -> Self {
        JsonArray(Vec::new())
    }
    fn push(&mut self, v: JsonValue) {
        self.0.push(v)
    }
}

impl Object<JsonValue, JsonArray, JsonValue> for JsonObject {
    fn new<'b>() -> Self {
        JsonObject(BTreeMap::new())
    }
    fn insert(&mut self, k: String, v: JsonValue) {
        self.0.insert(k, v);
    }
}

impl Null<JsonValue, JsonArray, JsonObject> for JsonValue {
    fn new() -> Self {
        JsonValue::Null
    }
}

impl Value<JsonArray, JsonObject, JsonValue> for JsonValue {}

impl From<f64> for JsonValue {
    fn from(v: f64) -> Self {
        JsonValue::F64(v)
    }
}

impl From<i64> for JsonValue {
    fn from(v: i64) -> Self {
        JsonValue::I64(v)
    }
}

impl From<u64> for JsonValue {
    fn from(v: u64) -> Self {
        JsonValue::U64(v)
    }
}

impl From<bool> for JsonValue {
    fn from(v: bool) -> Self {
        JsonValue::Bool(v)
    }
}

impl From<String> for JsonValue {
    fn from(v: String) -> Self {
        JsonValue::String(v)
    }
}

impl From<JsonArray> for JsonValue {
    fn from(v: JsonArray) -> Self {
        JsonValue::Array(v.0)
    }
}

impl From<JsonObject> for JsonValue {
    fn from(v: JsonObject) -> Self {
        JsonValue::Object(v.0)
    }
}

impl TryFrom<&JsonValue> for u128 {
    type Error = JsonError;

    fn try_from(value: &JsonValue) -> Result<Self, Self::Error> {
        match value {
            JsonValue::String(n) => {
                if let Ok(x) = n.parse::<u128>() {
                    Ok(x)
                } else if n.parse::<i128>().is_ok() {
                    Err(JsonError::OutOfRange(JsonOutOfRangeError::OutOfRangeU128))
                } else {
                    Err(JsonError::InvalidU128)
                }
            }
            JsonValue::F64(_) => Err(JsonError::ExpectedStringGotNumber),
            JsonValue::I64(_) => Err(JsonError::ExpectedStringGotNumber),
            JsonValue::U64(_) => Err(JsonError::ExpectedStringGotNumber),
            _ => Err(JsonError::InvalidU128),
        }
    }
}

impl core::fmt::Debug for JsonValue {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        match self {
            JsonValue::Null => f.write_str("null"),
            JsonValue::String(v) => f.write_fmt(format_args!("\"{}\"", v)),
            JsonValue::F64(v) => f.write_fmt(format_args!("{}", v)),
            JsonValue::I64(v) => f.write_fmt(format_args!("{}", v)),
            JsonValue::U64(v) => f.write_fmt(format_args!("{}", v)),
            JsonValue::Bool(v) => f.write_fmt(format_args!("{}", v)),
            JsonValue::Array(arr) => {
                f.write_str("[")?;
                let mut items = arr.iter();
                if let Some(item) = items.next() {
                    f.write_fmt(format_args!("{:?}", item))?;
                }
                for item in items {
                    f.write_fmt(format_args!(", {:?}", item))?;
                }
                f.write_str("]")
            }
            JsonValue::Object(kvs) => {
                f.write_str("{")?;
                let mut pairs = kvs.iter();
                if let Some((key, value)) = pairs.next() {
                    f.write_fmt(format_args!("\"{}\": {:?}", key, value))?;
                }
                for (key, value) in pairs {
                    f.write_fmt(format_args!(", \"{}\": {:?}", key, value))?;
                }
                f.write_str("}")
            }
        }
    }
}

impl core::fmt::Display for JsonValue {
    fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
        f.write_fmt(format_args!("{:?}", *self))
    }
}

pub fn parse_json(data: &[u8]) -> Option<JsonValue> {
    let data_array: Vec<char> = data.iter().map(|b| char::from(*b)).collect::<Vec<_>>();
    let mut index = 0;
    rjson::parse::<JsonValue, JsonArray, JsonObject, JsonValue>(&data_array, &mut index)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_json_all_types_fail_to_parse_missing_key() {
        let expected_err = std::str::from_utf8(errors::ERR_JSON_MISSING_VALUE).unwrap();
        let json = parse_json(r#"{"foo": 123}"#.as_bytes()).unwrap();

        let actual_err = json.string("missing_key").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let actual_err = json.bool("missing_key").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let actual_err = json.u64("missing_key").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let actual_err = json.u128("missing_key").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);
    }

    #[test]
    fn test_json_type_string() {
        let json = parse_json(r#"{"foo": "abcd"}"#.as_bytes()).unwrap();
        let string_data = json.string("foo").ok().unwrap();
        assert_eq!(string_data, "abcd");

        let expected_err = std::str::from_utf8(errors::ERR_FAILED_PARSE_STRING).unwrap();
        let json = parse_json(r#"{"foo": 123}"#.as_bytes()).unwrap();
        let actual_err = json.string("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": true}"#.as_bytes()).unwrap();
        let actual_err = json.string("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": ["abcd"]}"#.as_bytes()).unwrap();
        let actual_err = json.string("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": {}}"#.as_bytes()).unwrap();
        let actual_err = json.string("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": null}"#.as_bytes()).unwrap();
        let actual_err = json.string("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let expected_err = std::str::from_utf8(errors::ERR_NOT_A_JSON_TYPE).unwrap();
        let json = JsonValue::Null;
        let actual_err = json.string("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);
    }

    #[test]
    #[should_panic(expected = "overflow")]
    fn test_json_type_u64_with_u128_value() {
        let _ = parse_json(format!(r#"{{"foo": {} }}"#, u128::MAX).as_bytes());
    }

    #[test]
    fn test_json_type_u64() {
        let json = parse_json(r#"{"foo": 123}"#.as_bytes()).unwrap();
        let val = json.u64("foo").ok().unwrap();
        assert_eq!(val, 123);

        let json = parse_json(format!(r#"{{"foo": {} }}"#, u64::MAX).as_bytes()).unwrap();
        let val = json.u64("foo").ok().unwrap();
        assert_eq!(val, u64::MAX);

        let expected_err = std::str::from_utf8(errors::ERR_FAILED_PARSE_U64).unwrap();
        let json = parse_json(r#"{"foo": 12.99}"#.as_bytes()).unwrap();
        let actual_err = json.u64("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": -123}"#.as_bytes()).unwrap();
        let actual_err = json.u64("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": "abcd"}"#.as_bytes()).unwrap();
        let actual_err = json.u64("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": "123"}"#.as_bytes()).unwrap();
        let actual_err = json.u64("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": true}"#.as_bytes()).unwrap();
        let actual_err = json.u64("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": [123]}"#.as_bytes()).unwrap();
        let actual_err = json.u64("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": {}}"#.as_bytes()).unwrap();
        let actual_err = json.u64("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": null}"#.as_bytes()).unwrap();
        let actual_err = json.u64("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let expected_err = std::str::from_utf8(errors::ERR_NOT_A_JSON_TYPE).unwrap();
        let json = JsonValue::Null;
        let actual_err = json.u64("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);
    }

    #[test]
    fn test_json_type_u128() {
        let json = parse_json(r#"{"foo": "123"}"#.as_bytes()).unwrap();
        let val = json.u128("foo").ok().unwrap();
        assert_eq!(val, 123);

        let expected_err =
            std::str::from_utf8(JsonOutOfRangeError::OutOfRangeU128.as_ref()).unwrap();
        let json = parse_json(r#"{"foo": "-123"}"#.as_bytes()).unwrap();
        let actual_err = json.u128("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let expected_err = std::str::from_utf8(errors::ERR_EXPECTED_STRING_GOT_NUMBER).unwrap();
        let json = parse_json(r#"{"foo": 123}"#.as_bytes()).unwrap();
        let actual_err = json.u128("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": 12.3}"#.as_bytes()).unwrap();
        let actual_err = json.u128("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let expected_err = std::str::from_utf8(errors::ERR_FAILED_PARSE_U128).unwrap();
        let json = parse_json(r#"{"foo": "12.3"}"#.as_bytes()).unwrap();
        let actual_err = json.u128("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": "abcd"}"#.as_bytes()).unwrap();
        let actual_err = json.u128("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": true}"#.as_bytes()).unwrap();
        let actual_err = json.u128("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": ["123"]}"#.as_bytes()).unwrap();
        let actual_err = json.u128("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": {}}"#.as_bytes()).unwrap();
        let actual_err = json.u128("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": null}"#.as_bytes()).unwrap();
        let actual_err = json.u128("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let expected_err = std::str::from_utf8(errors::ERR_NOT_A_JSON_TYPE).unwrap();
        let json = JsonValue::Null;
        let actual_err = json.u128("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);
    }

    #[test]
    fn test_json_type_bool() {
        let json = parse_json(r#"{"foo": true}"#.as_bytes()).unwrap();
        let val = json.bool("foo").ok().unwrap();
        assert!(val);

        let json = parse_json(r#"{"foo": false}"#.as_bytes()).unwrap();
        let val = json.bool("foo").ok().unwrap();
        assert!(!val);

        let expected_err = std::str::from_utf8(errors::ERR_FAILED_PARSE_BOOL).unwrap();
        let json = parse_json(r#"{"foo": "true"}"#.as_bytes()).unwrap();
        let actual_err = json.bool("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": "false"}"#.as_bytes()).unwrap();
        let actual_err = json.bool("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": [true]}"#.as_bytes()).unwrap();
        let actual_err = json.bool("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": 123}"#.as_bytes()).unwrap();
        let actual_err = json.bool("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": 12.3}"#.as_bytes()).unwrap();
        let actual_err = json.bool("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": "abcd"}"#.as_bytes()).unwrap();
        let actual_err = json.bool("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": {}}"#.as_bytes()).unwrap();
        let actual_err = json.bool("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let json = parse_json(r#"{"foo": null}"#.as_bytes()).unwrap();
        let actual_err = json.bool("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let expected_err = std::str::from_utf8(errors::ERR_NOT_A_JSON_TYPE).unwrap();
        let json = JsonValue::Null;
        let actual_err = json.bool("foo").unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);
    }

    #[test]
    fn test_json_type_u8() {
        let json = JsonValue::from(123_u64);
        let val = JsonValue::parse_u8(&json).ok().unwrap();
        assert_eq!(val, 123);

        let expected_err = std::str::from_utf8(errors::ERR_FAILED_PARSE_U8).unwrap();
        let json = JsonValue::from(-1_i64);
        let actual_err = JsonValue::parse_u8(&json).unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let expected_err = std::str::from_utf8(JsonOutOfRangeError::OutOfRangeU8.as_ref()).unwrap();
        let json = JsonValue::from(256_u64);
        let actual_err = JsonValue::parse_u8(&json).unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);

        let expected_err = std::str::from_utf8(errors::ERR_FAILED_PARSE_U8).unwrap();
        let json = JsonValue::from("abcd".to_string());
        let actual_err = JsonValue::parse_u8(&json).unwrap_err();
        let actual_err = std::str::from_utf8(actual_err.as_ref()).unwrap();
        assert_eq!(actual_err, expected_err);
    }

    #[test]
    fn test_json_serialization() {
        // Test showing valid json (without trailing commas) is produced from the
        // `Display` impl on `JsonValue`.

        // empty object
        let object = JsonValue::Object(BTreeMap::new());
        assert_eq!(&format!("{}", object), "{}");

        // object with 1 field
        let object = JsonValue::Object(
            vec![("pi".to_string(), JsonValue::F64(std::f64::consts::PI))]
                .into_iter()
                .collect(),
        );
        assert_eq!(&format!("{}", object), "{\"pi\": 3.141592653589793}");

        // object with 2 fields
        let object = JsonValue::Object(
            vec![
                ("pi".to_string(), JsonValue::F64(std::f64::consts::PI)),
                ("Pie".to_string(), JsonValue::String("Apple".to_string())),
            ]
            .into_iter()
            .collect(),
        );
        assert_eq!(
            &format!("{}", object),
            "{\"Pie\": \"Apple\", \"pi\": 3.141592653589793}"
        );

        // object with empty array
        let object = JsonValue::Object(
            vec![("empty".to_string(), JsonValue::Array(vec![]))]
                .into_iter()
                .collect(),
        );
        assert_eq!(&format!("{}", object), "{\"empty\": []}");

        // object with single element array
        let object = JsonValue::Object(
            vec![(
                "numbers".to_string(),
                JsonValue::Array(vec![JsonValue::U64(42)]),
            )]
            .into_iter()
            .collect(),
        );
        assert_eq!(&format!("{}", object), "{\"numbers\": [42]}");

        // object with two-element array
        let object = JsonValue::Object(
            vec![(
                "words".to_string(),
                JsonValue::Array(vec![
                    JsonValue::String("Hello".to_string()),
                    JsonValue::String("World".to_string()),
                ]),
            )]
            .into_iter()
            .collect(),
        );
        assert_eq!(
            &format!("{}", object),
            "{\"words\": [\"Hello\", \"World\"]}"
        );
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/lib.rs ---
#![cfg_attr(not(feature = "std"), no_std)]
#![cfg_attr(not(feature = "std"), feature(alloc_error_handler))]
#![cfg_attr(
    all(feature = "log", target_arch = "wasm32"),
    feature(panic_info_message)
)]
#![deny(clippy::as_conversions)]

use aurora_engine_types::parameters::PromiseCreateArgs;

#[cfg(not(feature = "std"))]
extern crate alloc;
#[cfg(not(feature = "std"))]
extern crate core;

mod map;
pub mod parameters;
pub mod proof;

pub mod accounting;
pub mod admin_controlled;
#[cfg_attr(feature = "contract", allow(dead_code))]
pub mod connector;
pub mod deposit_event;
pub mod engine;
pub mod errors;
pub mod fungible_token;
pub mod json;
pub mod log_entry;
pub mod pausables;
mod prelude;
pub mod xcc;

#[cfg(target_arch = "wasm32")]
#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[cfg(target_arch = "wasm32")]
#[panic_handler]
#[cfg_attr(not(feature = "log"), allow(unused_variables))]
#[no_mangle]
pub unsafe fn on_panic(info: &::core::panic::PanicInfo) -> ! {
    #[cfg(feature = "log")]
    {
        use prelude::ToString;

        if let Some(msg) = info.message() {
            let msg = if let Some(log) = info.location() {
                prelude::format!("{} [{}]", msg, log)
            } else {
                msg.to_string()
            };
            prelude::sdk::panic_utf8(msg.as_bytes());
        } else if let Some(log) = info.location() {
            prelude::sdk::panic_utf8(log.to_string().as_bytes());
        }
    }

    ::core::arch::wasm32::unreachable();
}

#[cfg(target_arch = "wasm32")]
#[alloc_error_handler]
#[no_mangle]
pub unsafe fn on_alloc_error(_: core::alloc::Layout) -> ! {
    ::core::arch::wasm32::unreachable();
}

#[cfg(feature = "contract")]
mod contract {
    use borsh::{BorshDeserialize, BorshSerialize};
    use core::str::FromStr;

    use crate::connector::{self, EthConnectorContract};
    use crate::engine::{self, Engine, EngineState};
    use crate::fungible_token::FungibleTokenMetadata;
    use crate::json::parse_json;
    use crate::parameters::{
        self, CallArgs, DeployErc20TokenArgs, GetErc20FromNep141CallArgs, GetStorageAtArgs,
        InitCallArgs, IsUsedProofCallArgs, NEP141FtOnTransferArgs, NewCallArgs,
        PauseEthConnectorCallArgs, PausePrecompilesCallArgs, ResolveTransferCallArgs,
        SetContractDataCallArgs, StorageDepositCallArgs, StorageWithdrawCallArgs,
        TransferCallCallArgs, ViewCallArgs,
    };
    #[cfg(feature = "evm_bully")]
    use crate::parameters::{BeginBlockArgs, BeginChainArgs};
    use crate::pausables::{
        Authorizer, EnginePrecompilesPauser, PausedPrecompilesChecker, PausedPrecompilesManager,
        PrecompileFlags,
    };
    use crate::prelude::String;
    use crate::prelude::account_id::AccountId;
    use crate::prelude::parameters::RefundCallArgs;
    use crate::prelude::sdk::types::{
        near_account_to_evm_address, SdkExpect, SdkProcess, SdkUnwrap,
    };
    use crate::prelude::storage::{bytes_to_key, KeyPrefix};
    use crate::prelude::{
        sdk, u256_to_arr, Address, PromiseResult, ToString, Yocto, ERR_FAILED_PARSE, H256,
    };
    use crate::{errors, pausables};
    use aurora_engine_sdk::env::Env;
    use aurora_engine_sdk::io::{StorageIntermediate, IO};
    use aurora_engine_sdk::near_runtime::{Runtime, ViewEnv};
    use aurora_engine_sdk::promise::PromiseHandler;

    #[cfg(feature = "integration-test")]
    use crate::prelude::NearGas;

    const CODE_KEY: &[u8; 4] = b"CODE";
    const CODE_STAGE_KEY: &[u8; 10] = b"CODE_STAGE";

    ///
    /// ADMINISTRATIVE METHODS
    ///

    /// Sets the configuration for the Engine.
    /// Should be called on deployment.
    #[no_mangle]
    pub extern "C" fn new() {
        let mut io = Runtime;
        if let Ok(state) = engine::get_state(&io) {
            require_owner_only(&state, &io.predecessor_account_id());
        }

        let args: NewCallArgs = io.read_input_borsh().sdk_unwrap();
        engine::set_state(&mut io, args.into());
    }

    /// Get version of the contract.
    #[no_mangle]
    pub extern "C" fn get_version() {
        let mut io = Runtime;
        let version = match option_env!("NEAR_EVM_VERSION") {
            Some(v) => v.as_bytes(),
            None => include_bytes!("../../VERSION"),
        };
        io.return_output(version)
    }

    /// Get owner account id for this contract.
    #[no_mangle]
    pub extern "C" fn get_owner() {
        let mut io = Runtime;
        let state = engine::get_state(&io).sdk_unwrap();
        io.return_output(state.owner_id.as_bytes());
    }

    /// Set owner account id for this contract.
    #[no_mangle]
    pub extern "C" fn set_owner() {
        let mut io = Runtime;
        let mut state = engine::get_state(&io).sdk_unwrap();
        require_owner_only(&state, &io.predecessor_account_id());
        let args = io.read_input().to_vec();
        let sr: String = String::from_utf8(args).unwrap();
        let id = AccountId::from_str(&sr).unwrap();
        
        sdk::log_utf8("hey I r thing".as_bytes());
        sdk::log_utf8(id.as_bytes());
        state.owner_id = id.clone();
        engine::set_state(&mut io, state);
        io.return_output(id.as_bytes());
    }

    /// Get bridge prover id for this contract.
    #[no_mangle]
    pub extern "C" fn get_bridge_prover() {
        let mut io = Runtime;
        let connector = EthConnectorContract::init_instance(io).sdk_unwrap();
        io.return_output(connector.get_bridge_prover().as_bytes());
    }

    /// Get chain id for this contract.
    #[no_mangle]
    pub extern "C" fn get_chain_id() {
        let mut io = Runtime;
        io.return_output(&engine::get_state(&io).sdk_unwrap().chain_id)
    }

    #[no_mangle]
    pub extern "C" fn get_upgrade_index() {
        let mut io = Runtime;
        let state = engine::get_state(&io).sdk_unwrap();
        let index = internal_get_upgrade_index();
        io.return_output(&(index + state.upgrade_delay_blocks).to_le_bytes())
    }

    /// Stage new code for deployment.
    #[no_mangle]
    pub extern "C" fn stage_upgrade() {
        let mut io = Runtime;
        let state = engine::get_state(&io).sdk_unwrap();
        let block_height = io.block_height();
        require_owner_only(&state, &io.predecessor_account_id());
        io.read_input_and_store(&bytes_to_key(KeyPrefix::Config, CODE_KEY));
        io.write_storage(
            &bytes_to_key(KeyPrefix::Config, CODE_STAGE_KEY),
            &block_height.to_le_bytes(),
        );
    }

    /// Deploy staged upgrade.
    #[no_mangle]
    pub extern "C" fn deploy_upgrade() {
        let io = Runtime;
        let state = engine::get_state(&io).sdk_unwrap();
        require_owner_only(&state, &io.predecessor_account_id());
        let index = internal_get_upgrade_index();
        if io.block_height() <= index + state.upgrade_delay_blocks {
            sdk::panic_utf8(errors::ERR_NOT_ALLOWED_TOO_EARLY);
        }
        Runtime::self_deploy(&bytes_to_key(KeyPrefix::Config, CODE_KEY));
    }

    /// Called as part of the upgrade process (see `engine-sdk::self_deploy`). This function is meant
    /// to make any necessary changes to the state such that it aligns with the newly deployed
    /// code.
    #[no_mangle]
    pub extern "C" fn state_migration() {
        // TODO: currently we don't have migrations
    }

    /// Resumes previously [`paused`] precompiles.
    ///
    /// [`paused`]: crate::contract::pause_precompiles
    #[no_mangle]
    pub extern "C" fn resume_precompiles() {
        let io = Runtime;
        let state = engine::get_state(&io).sdk_unwrap();
        let predecessor_account_id = io.predecessor_account_id();

        require_owner_only(&state, &predecessor_account_id);

        let args: PausePrecompilesCallArgs = io.read_input_borsh().sdk_unwrap();
        let flags = PrecompileFlags::from_bits_truncate(args.paused_mask);
        let mut pauser = EnginePrecompilesPauser::from_io(io);
        pauser.resume_precompiles(flags);
    }

    /// Pauses a precompile.
    #[no_mangle]
    pub extern "C" fn pause_precompiles() {
        let io = Runtime;
        let authorizer: pausables::EngineAuthorizer = engine::get_authorizer();

        if !authorizer.is_authorized(&io.predecessor_account_id()) {
            sdk::panic_utf8("ERR_UNAUTHORIZED".as_bytes());
        }

        let args: PausePrecompilesCallArgs = io.read_input_borsh().sdk_unwrap();
        let flags = PrecompileFlags::from_bits_truncate(args.paused_mask);
        let mut pauser = EnginePrecompilesPauser::from_io(io);
        pauser.pause_precompiles(flags);
    }

    /// Returns an unsigned integer where each 1-bit means that a precompile corresponding to that bit is paused and
    /// 0-bit means not paused.
    #[no_mangle]
    pub extern "C" fn paused_precompiles() {
        let mut io = Runtime;
        let pauser = EnginePrecompilesPauser::from_io(io);
        let data = pauser.paused().bits().to_le_bytes();
        io.return_output(&data[..]);
    }

    ///
    /// MUTATIVE METHODS
    ///

    /// Deploy code into the EVM.
    #[no_mangle]
    pub extern "C" fn deploy_code() {
        let io = Runtime;
        let input = io.read_input().to_vec();
        let current_account_id = io.current_account_id();
        let mut engine = Engine::new(
            predecessor_address(&io.predecessor_account_id()),
            current_account_id,
            io,
            &io,
        )
        .sdk_unwrap();
        Engine::deploy_code_with_input(&mut engine, input, &mut Runtime)
            .map(|res| res.try_to_vec().sdk_expect(errors::ERR_SERIALIZE))
            .sdk_process();
        // TODO: charge for storage
    }

    /// Call method on the EVM contract.
    #[no_mangle]
    pub extern "C" fn call() {
        let io = Runtime;
        let bytes = io.read_input().to_vec();
        let args = CallArgs::deserialize(&bytes).sdk_expect(errors::ERR_BORSH_DESERIALIZE);
        let current_account_id = io.current_account_id();
        let mut engine = Engine::new(
            predecessor_address(&io.predecessor_account_id()),
            current_account_id,
            io,
            &io,
        )
        .sdk_unwrap();
        Engine::call_with_args(&mut engine, args, &mut Runtime)
            .map(|res| res.try_to_vec().sdk_expect(errors::ERR_SERIALIZE))
            .sdk_process();
        // TODO: charge for storage
    }

    /// Process signed Ethereum transaction.
    /// Must match CHAIN_ID to make sure it's signed for given chain vs replayed from another chain.
    #[no_mangle]
    pub extern "C" fn submit() {
        let io = Runtime;
        let input = io.read_input().to_vec();
        let current_account_id = io.current_account_id();
        let state = engine::get_state(&io).sdk_unwrap();
        let relayer_address = predecessor_address(&io.predecessor_account_id());
        let result = engine::submit(
            io,
            &io,
            &input,
            state,
            current_account_id,
            relayer_address,
            &mut Runtime,
        );

        result
            .map(|res| res.try_to_vec().sdk_expect(errors::ERR_SERIALIZE))
            .sdk_process();
    }

    #[no_mangle]
    pub extern "C" fn register_relayer() {
        let io = Runtime;
        let relayer_address = io.read_input_arr20().sdk_unwrap();

        let current_account_id = io.current_account_id();
        let predecessor_account_id = io.predecessor_account_id();
        let mut engine = Engine::new(
            predecessor_address(&predecessor_account_id),
            current_account_id,
            io,
            &io,
        )
        .sdk_unwrap();
        engine.register_relayer(
            predecessor_account_id.as_bytes(),
            Address::from_array(relayer_address),
        );
    }

    /// Updates the bytecode for user's router contracts created by the engine.
    /// These contracts are where cross-contract calls initiated by the EVM precompile
    /// will be sent from.
    #[no_mangle]
    pub extern "C" fn factory_update() {
        let mut io = Runtime;
        let state = engine::get_state(&io).sdk_unwrap();
        require_owner_only(&state, &io.predecessor_account_id());
        let bytes = io.read_input().to_vec();
        let router_bytecode = crate::xcc::RouterCode::new(bytes);
        crate::xcc::update_router_code(&mut io, &router_bytecode);
    }

    /// Updates the bytecode version for the given account. This is only called as a callback
    /// when a new version of the router contract is deployed to an account.
    #[no_mangle]
    pub extern "C" fn factory_update_address_version() {
        let mut io = Runtime;
        io.assert_private_call().sdk_unwrap();
        let check_deploy: Result<(), &[u8]> = match io.promise_result(0) {
            Some(PromiseResult::Successful(_)) => Ok(()),
            Some(_) => Err(b"ERR_ROUTER_DEPLOY_FAILED"),
            None => Err(b"ERR_ROUTER_UPDATE_NOT_CALLBACK"),
        };
        check_deploy.sdk_unwrap();
        let args: crate::xcc::AddressVersionUpdateArgs = io.read_input_borsh().sdk_unwrap();
        crate::xcc::set_code_version_of_address(&mut io, &args.address, args.version);
    }

    /// Sets the address for the wNEAR ERC-20 contract. This contract will be used by the
    /// cross-contract calls feature to have users pay for their NEAR transactions.
    #[no_mangle]
    pub extern "C" fn factory_set_wnear_address() {
        let mut io = Runtime;
        let state = engine::get_state(&io).sdk_unwrap();
        require_owner_only(&state, &io.predecessor_account_id());
        let address = io.read_input_arr20().sdk_unwrap();
        crate::xcc::set_wnear_address(&mut io, &Address::from_array(address));
    }

    /// Allow receiving NEP141 tokens to the EVM contract.
    ///
    /// This function returns the amount of tokens to return to the sender.
    /// Either all tokens are transferred tokens are returned in case of an
    /// error, or no token is returned if tx was successful.
    #[no_mangle]
    pub extern "C" fn ft_on_transfer() {
        let io = Runtime;
        let current_account_id = io.current_account_id();
        let predecessor_account_id = io.predecessor_account_id();
        let mut engine = Engine::new(
            predecessor_address(&predecessor_account_id),
            current_account_id.clone(),
            io,
            &io,
        )
        .sdk_unwrap();

        let args: NEP141FtOnTransferArgs = parse_json(io.read_input().to_vec().as_slice())
            .sdk_unwrap()
            .try_into()
            .sdk_unwrap();

        if predecessor_account_id == current_account_id {
            EthConnectorContract::init_instance(io)
                .sdk_unwrap()
                .ft_on_transfer(&engine, &args)
                .sdk_unwrap();
        } else {
            engine.receive_erc20_tokens(
                &predecessor_account_id,
                &args,
                &current_account_id,
                &mut Runtime,
            );
        }
    }

    /// Deploy ERC20 token mapped to a NEP141
    #[no_mangle]
    pub extern "C" fn deploy_erc20_token() {
        let mut io = Runtime;
        // Id of the NEP141 token in Near
        let args: DeployErc20TokenArgs = io.read_input_borsh().sdk_unwrap();

        let address = engine::deploy_erc20_token(args, io, &io, &mut Runtime).sdk_unwrap();

        io.return_output(
            &address
                .as_bytes()
                .try_to_vec()
                .sdk_expect(errors::ERR_SERIALIZE),
        );

        // TODO: charge for storage
    }

    /// Callback invoked by exit to NEAR precompile to handle potential
    /// errors in the exit call.
    #[no_mangle]
    pub extern "C" fn refund_on_error() {
        let io = Runtime;
        io.assert_private_call().sdk_unwrap();

        // This function should only be called as the callback of
        // exactly one promise.
        if io.promise_results_count() != 1 {
            sdk::panic_utf8(errors::ERR_PROMISE_COUNT);
        }

        if let Some(PromiseResult::Successful(_)) = io.promise_result(0) {
            // Promise succeeded -- nothing to do
        } else {
            // Exit call failed; need to refund tokens
            let args: RefundCallArgs = io.read_input_borsh().sdk_unwrap();
            let state = engine::get_state(&io).sdk_unwrap();
            let refund_result =
                engine::refund_on_error(io, &io, state, args, &mut Runtime).sdk_unwrap();

            if !refund_result.status.is_ok() {
                sdk::panic_utf8(errors::ERR_REFUND_FAILURE);
            }
        }
    }

    ///
    /// NONMUTATIVE METHODS
    ///
    #[no_mangle]
    pub extern "C" fn view() {
        let mut io = Runtime;
        let env = ViewEnv;
        let args: ViewCallArgs = io.read_input_borsh().sdk_unwrap();
        let current_account_id = io.current_account_id();
        let engine = Engine::new(args.sender, current_account_id, io, &env).sdk_unwrap();
        let result = Engine::view_with_args(&engine, args).sdk_unwrap();
        io.return_output(&result.try_to_vec().sdk_expect(errors::ERR_SERIALIZE));
    }

    #[no_mangle]
    pub extern "C" fn get_block_hash() {
        let mut io = Runtime;
        let block_height = io.read_input_borsh().sdk_unwrap();
        let account_id = io.current_account_id();
        let chain_id = engine::get_state(&io)
            .map(|state| state.chain_id)
            .sdk_unwrap();
        let block_hash =
            crate::engine::compute_block_hash(chain_id, block_height, account_id.as_bytes());
        io.return_output(block_hash.as_bytes())
    }

    #[no_mangle]
    pub extern "C" fn get_code() {
        let mut io = Runtime;
        let address = io.read_input_arr20().sdk_unwrap();
        let code = engine::get_code(&io, &Address::from_array(address));
        io.return_output(&code)
    }

    #[no_mangle]
    pub extern "C" fn get_balance() {
        let mut io = Runtime;
        let address = io.read_input_arr20().sdk_unwrap();
        let balance = engine::get_balance(&io, &Address::from_array(address));
        io.return_output(&balance.to_bytes())
    }

    #[no_mangle]
    pub extern "C" fn get_nonce() {
        let mut io = Runtime;
        let address = io.read_input_arr20().sdk_unwrap();
        let nonce = engine::get_nonce(&io, &Address::from_array(address));
        io.return_output(&u256_to_arr(&nonce))
    }

    #[no_mangle]
    pub extern "C" fn get_storage_at() {
        let mut io = Runtime;
        let args: GetStorageAtArgs = io.read_input_borsh().sdk_unwrap();
        let address = args.address;
        let generation = engine::get_generation(&io, &address);
        let value = engine::get_storage(&io, &args.address, &H256(args.key), generation);
        io.return_output(&value.0)
    }

    ///
    /// BENCHMARKING METHODS
    ///
    #[cfg(feature = "evm_bully")]
    #[no_mangle]
    pub extern "C" fn begin_chain() {
        use crate::prelude::U256;
        let mut io = Runtime;
        let mut state = engine::get_state(&io).sdk_unwrap();
        require_owner_only(&state, &io.predecessor_account_id());
        let args: BeginChainArgs = io.read_input_borsh().sdk_unwrap();
        state.chain_id = args.chain_id;
        engine::set_state(&mut io, state);
        // set genesis block balances
        for account_balance in args.genesis_alloc {
            engine::set_balance(
                &mut io,
                &account_balance.address,
                &crate::prelude::Wei::new(U256::from(account_balance.balance)),
            )
        }
        // return new chain ID
        io.return_output(&engine::get_state(&io).sdk_unwrap().chain_id)
    }

    #[cfg(feature = "evm_bully")]
    #[no_mangle]
    pub extern "C" fn begin_block() {
        let io = Runtime;
        let state = engine::get_state(&io).sdk_unwrap();
        require_owner_only(&state, &io.predecessor_account_id());
        let _args: BeginBlockArgs = io.read_input_borsh().sdk_unwrap();
        // TODO: https://github.com/aurora-is-near/aurora-engine/issues/2
    }

    #[no_mangle]
    pub extern "C" fn new_eth_connector() {
        let io = Runtime;
        // Only the owner can initialize the EthConnector
        io.assert_private_call().sdk_unwrap();

        let args: InitCallArgs = io.read_input_borsh().sdk_unwrap();
        let owner_id = io.current_account_id();

        EthConnectorContract::create_contract(io, owner_id, args).sdk_unwrap();
    }

    #[no_mangle]
    pub extern "C" fn set_eth_connector_contract_data() {
        let mut io = Runtime;
        // Only the owner can set the EthConnector contract data
        io.assert_private_call().sdk_unwrap();

        let args: SetContractDataCallArgs = io.read_input_borsh().sdk_unwrap();
        connector::set_contract_data(&mut io, args).sdk_unwrap();
    }

    #[no_mangle]

    pub extern "C" fn withdraw() {
        let io = Runtime;
        io.assert_one_yocto().sdk_unwrap();
        let args = io.read_input_borsh().sdk_unwrap();
        let current_account_id = io.current_account_id();
        let predecessor_account_id = io.predecessor_account_id();
        let result = EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .withdraw_eth_from_near(&current_account_id, &predecessor_account_id, args)
            .sdk_unwrap();
        let result_bytes = result.try_to_vec().sdk_expect(errors::ERR_SERIALIZE);
        // We intentionally do not go through the `io` struct here because we must bypass
        // the check that prevents output that is accepted by the eth_custodian
        #[allow(clippy::as_conversions)]
        unsafe {
            exports::value_return(
                u64::try_from(result_bytes.len()).sdk_expect(errors::ERR_VALUE_CONVERSION),
                result_bytes.as_ptr() as u64,
            );
        }
    }

    #[no_mangle]
    pub extern "C" fn deposit() {
        let mut io = Runtime;
        let raw_proof = io.read_input().to_vec();
        let current_account_id = io.current_account_id();
        let predecessor_account_id = io.predecessor_account_id();
        let promise_args = EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .deposit(raw_proof, current_account_id, predecessor_account_id)
            .sdk_unwrap();
        // Safety: this call is safe because it comes from the eth-connector, not users.
        // The call is to verify the user-supplied proof for the deposit, with `finish_deposit`
        // as a callback.
        let promise_id = unsafe { io.promise_create_with_callback(&promise_args) };
        io.promise_return(promise_id);
    }

    #[no_mangle]
    pub extern "C" fn finish_deposit() {
        let mut io = Runtime;
        io.assert_private_call().sdk_unwrap();

        // Check result from proof verification call
        if io.promise_results_count() != 1 {
            sdk::panic_utf8(errors::ERR_PROMISE_COUNT);
        }
        let promise_result = match io.promise_result(0) {
            Some(PromiseResult::Successful(bytes)) => {
                bool::try_from_slice(&bytes).sdk_expect(errors::ERR_PROMISE_ENCODING)
            }
            _ => sdk::panic_utf8(errors::ERR_PROMISE_FAILED),
        };
        if !promise_result {
            sdk::panic_utf8(errors::ERR_VERIFY_PROOF);
        }

        let data = io.read_input_borsh().sdk_unwrap();
        let current_account_id = io.current_account_id();
        let predecessor_account_id = io.predecessor_account_id();
        let maybe_promise_args = EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .finish_deposit(
                predecessor_account_id,
                current_account_id,
                data,
                io.prepaid_gas(),
            )
            .sdk_unwrap();

        if let Some(promise_args) = maybe_promise_args {
            // Safety: this call is safe because it comes from the eth-connector, not users.
            // The call will be to the Engine's ft_transfer_call`, which is needed as part
            // of the bridge flow (if depositing ETH to an Aurora address).
            let promise_id = unsafe { io.promise_create_with_callback(&promise_args) };
            io.promise_return(promise_id);
        }
    }

    #[no_mangle]
    pub extern "C" fn is_used_proof() {
        let mut io = Runtime;
        let args: IsUsedProofCallArgs = io.read_input_borsh().sdk_unwrap();

        let is_used_proof = EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .is_used_proof(args.proof);
        let res = is_used_proof.try_to_vec().unwrap();
        io.return_output(&res[..]);
    }

    #[no_mangle]
    pub extern "C" fn ft_total_supply() {
        let io = Runtime;
        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .ft_total_eth_supply_on_near();
    }

    #[no_mangle]
    pub extern "C" fn ft_total_eth_supply_on_near() {
        let io = Runtime;
        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .ft_total_eth_supply_on_near();
    }

    #[no_mangle]
    pub extern "C" fn ft_total_eth_supply_on_aurora() {
        let io = Runtime;
        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .ft_total_eth_supply_on_aurora();
    }

    #[no_mangle]
    pub extern "C" fn ft_balance_of() {
        let io = Runtime;
        let args = parameters::BalanceOfCallArgs::try_from(
            parse_json(&io.read_input().to_vec()).sdk_unwrap(),
        )
        .sdk_unwrap();
        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .ft_balance_of(args);
    }

    #[no_mangle]
    pub extern "C" fn ft_balance_of_eth() {
        let io = Runtime;
        let args: parameters::BalanceOfEthCallArgs = io.read_input().to_value().sdk_unwrap();
        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .ft_balance_of_eth_on_aurora(args)
            .sdk_unwrap();
    }

    #[no_mangle]
    pub extern "C" fn ft_transfer() {
        let io = Runtime;
        io.assert_one_yocto().sdk_unwrap();
        let predecessor_account_id = io.predecessor_account_id();
        let args = parameters::TransferCallArgs::try_from(
            parse_json(&io.read_input().to_vec()).sdk_unwrap(),
        )
        .sdk_unwrap();
        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .ft_transfer(&predecessor_account_id, args)
            .sdk_unwrap();
    }

    #[no_mangle]
    pub extern "C" fn ft_resolve_transfer() {
        let io = Runtime;

        io.assert_private_call().sdk_unwrap();
        if io.promise_results_count() != 1 {
            sdk::panic_utf8(errors::ERR_PROMISE_COUNT);
        }

        let args: ResolveTransferCallArgs = io.read_input().to_value().sdk_unwrap();
        let promise_result = io.promise_result(0).sdk_unwrap();

        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .ft_resolve_transfer(args, promise_result);
    }

    #[no_mangle]
    pub extern "C" fn ft_transfer_call() {
        use sdk::types::ExpectUtf8;
        let mut io = Runtime;
        // Check is payable
        io.assert_one_yocto().sdk_unwrap();

        let args = TransferCallCallArgs::try_from(
            parse_json(&io.read_input().to_vec()).expect_utf8(ERR_FAILED_PARSE.as_bytes()),
        )
        .sdk_unwrap();
        let current_account_id = io.current_account_id();
        let predecessor_account_id = io.predecessor_account_id();
        let promise_args = EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .ft_transfer_call(
                predecessor_account_id,
                current_account_id,
                args,
                io.prepaid_gas(),
            )
            .sdk_unwrap();
        // Safety: this call is safe. It is required by the NEP-141 spec that `ft_transfer_call`
        // creates a call to another contract's `ft_on_transfer` method.
        let promise_id = unsafe { io.promise_create_with_callback(&promise_args) };
        io.promise_return(promise_id);
    }

    #[no_mangle]
    pub extern "C" fn storage_deposit() {
        let mut io = Runtime;
        let args = StorageDepositCallArgs::from(parse_json(&io.read_input().to_vec()).sdk_unwrap());
        let predecessor_account_id = io.predecessor_account_id();
        let amount = Yocto::new(io.attached_deposit());
        let maybe_promise = EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .storage_deposit(predecessor_account_id, amount, args)
            .sdk_unwrap();
        if let Some(promise) = maybe_promise {
            // Safety: This call is safe. It is only a transfer back to the user in the case
            // that they over paid for their deposit.
            unsafe { io.promise_create_batch(&promise) };
        }
    }

    #[no_mangle]
    pub extern "C" fn storage_unregister() {
        let mut io = Runtime;
        io.assert_one_yocto().sdk_unwrap();
        let predecessor_account_id = io.predecessor_account_id();
        let force = parse_json(&io.read_input().to_vec()).and_then(|args| args.bool("force").ok());
        let maybe_promise = EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .storage_unregister(predecessor_account_id, force)
            .sdk_unwrap();
        if let Some(promise) = maybe_promise {
            // Safety: This call is safe. It is only a transfer back to the user for their deposit.
            unsafe { io.promise_create_batch(&promise) };
        }
    }

    #[no_mangle]
    pub extern "C" fn storage_withdraw() {
        let io = Runtime;
        io.assert_one_yocto().sdk_unwrap();
        let args =
            StorageWithdrawCallArgs::from(parse_json(&io.read_input().to_vec()).sdk_unwrap());
        let predecessor_account_id = io.predecessor_account_id();
        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .storage_withdraw(&predecessor_account_id, args)
            .sdk_unwrap()
    }

    #[no_mangle]
    pub extern "C" fn storage_balance_of() {
        let io = Runtime;
        let args = parameters::StorageBalanceOfCallArgs::try_from(
            parse_json(&io.read_input().to_vec()).sdk_unwrap(),
        )
        .sdk_unwrap();
        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .storage_balance_of(args)
    }

    #[no_mangle]
    pub extern "C" fn get_paused_flags() {
        let mut io = Runtime;
        let paused_flags = EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .get_paused_flags();
        let data = paused_flags.try_to_vec().expect(ERR_FAILED_PARSE);
        io.return_output(&data[..]);
    }

    #[no_mangle]
    pub extern "C" fn set_paused_flags() {
        let io = Runtime;
        io.assert_private_call().sdk_unwrap();

        let args: PauseEthConnectorCallArgs = io.read_input_borsh().sdk_unwrap();
        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .set_paused_flags(args);
    }

    #[no_mangle]
    pub extern "C" fn get_accounts_counter() {
        let io = Runtime;
        EthConnectorContract::init_instance(io)
            .sdk_unwrap()
            .get_accounts_counter();
    }

    #[no_mangle]
    pub extern "C" fn get_erc20_from_nep141() {
        let mut io = Runtime;
        let args: GetErc20FromNep141CallArgs = io.read_input_borsh().sdk_unwrap();

        io.return_output(
            engine::get_erc20_from_nep141(&io, &args.nep141)
                .sdk_unwrap()
                .as_slice(),
        );
    }

    #[no_mangle]
    pub extern "C" fn get_nep141_from_erc20() {
        let mut io = Runtime;
        let erc20_address: crate::engine::ERC20Address =
            io.read_input().to_vec().try_into().sdk_unwrap();
        io.return_output(
            engine::nep141_erc20_map(io)
                .lookup_right(&erc20_address)
                .sdk_expect("ERC20_NOT_FOUND")
                .as_ref(),
        );
    }

    #[no_mangle]
    pub extern "C" fn ft_metadata() {
        let mut io = Runtime;
        let metadata: FungibleTokenMetadata = connector::get_metadata(&io).unwrap_or_default();
        let json_data = crate::json::JsonValue::from(metadata);
        io.return_output(json_data.to_string().as_bytes())
    }

    #[cfg(feature = "integration-test")]
    #[no_mangle]
    pub extern "C" fn verify_log_entry() {
        sdk::log!("Call from verify_log_entry");
        let mut io = Runtime;
        let data = true.try_to_vec().unwrap();
        io.return_output(&data[..]);
    }

    /// Function used to create accounts for tests
    #[cfg(feature = "integration-test")]
    #[no_mangle]
    pub extern "C" fn mint_account() {
        use crate::connector::ZERO_ATTACHED_BALANCE;
        use crate::prelude::{NEP141Wei, U256};
        use evm::backend::ApplyBackend;
        const GAS_FOR_VERIFY: NearGas = NearGas::new(20_000_000_000_000);
        const GAS_FOR_FINISH: NearGas = NearGas::new(50_000_000_000_000);

        let mut io = Runtime;
        let args: ([u8; 20], u64, u64) = io.read_input_borsh().sdk_expect(errors::ERR_ARGS);
        let address = Address::from_array(args.0);
        let nonce = U256::from(args.1);
        let balance = NEP141Wei::new(u128::from(args.2));
        let current_account_id = io.current_account_id();
        let mut engine = Engine::new(address, current_account_id, io, &io).sdk_unwrap();
        let state_change = evm::backend::Apply::Modify {
            address: address.raw(),
            basic: evm::backend::Basic {
                balance: U256::from(balance.as_u128()),
                nonce,
            },
            code: None,
            storage: core::iter::empty(),
            reset_storage: false,
        };
        engine.apply(core::iter::once(state_change), core::iter::empty(), false);

        // Call "finish_deposit" to mint the corresponding
        // nETH NEP-141 tokens as well
        let aurora_account_id = io.current_account_id();
        let args = crate::parameters::FinishDepositCallArgs {
            new_owner_id: aurora_account_id.clone(),
            amount: balance,
            proof_key: crate::prelude::String::new(),
            relayer_id: aurora_account_id.clone(),
            fee: 0.into(),
            msg: None,
        };
        let verify_call = aurora_engine_types::parameters::PromiseCreateArgs {
            target_account_id: aurora_account_id.clone(),
            method: "verify_log_entry".to_string(),
            args: crate::prelude::Vec::new(),
            attached_balance: ZERO_ATTACHED_BALANCE,
            attached_gas: GAS_FOR_VERIFY,
        };
        let finish_call = aurora_engine_types::parameters::PromiseCreateArgs {
            target_account_id: aurora_account_id,
            method: "finish_deposit".to_string(),
            args: args.try_to_vec().unwrap(),
            attached_balance: ZERO_ATTACHED_BALANCE,
            attached_gas: GAS_FOR_FINISH,
        };
        // Safety: this call is safe because it is only used in integration tests.
        unsafe {
            io.promise_create_with_callback(
                &aurora_engine_types::parameters::PromiseWithCallbackArgs {
                    base: verify_call,
                    callback: finish_call,
                },
            )
        };
    }

    ///
    /// Utility methods.
    ///

    fn internal_get_upgrade_index() -> u64 {
        let io = Runtime;
        match io.read_u64(&bytes_to_key(KeyPrefix::Config, CODE_STAGE_KEY)) {
            Ok(index) => index,
            Err(sdk::error::ReadU64Error::InvalidU64) => {
                sdk::panic_utf8(errors::ERR_INVALID_UPGRADE)
            }
            Err(sdk::error::ReadU64Error::MissingValue) => sdk::panic_utf8(errors::ERR_NO_UPGRADE),
        }
    }

    fn require_owner_only(state: &EngineState, predecessor_account_id: &AccountId) {
        if &state.owner_id != predecessor_account_id {
            sdk::panic_utf8(errors::ERR_NOT_ALLOWED);
        }
    }

    fn predecessor_address(predecessor_account_id: &AccountId) -> Address {
        near_account_to_evm_address(predecessor_account_id.as_bytes())
    }

    mod exports {
        extern "C" {
            pub(crate) fn value_return(value_len: u64, value_ptr: u64);
        }
    }
}

pub trait AuroraState {
    fn add_promise(&mut self, promise: PromiseCreateArgs);
}
'''
'''--- aurora-engine-2.8.1/engine/src/log_entry.rs ---
use crate::prelude::{Vec, H160, H256};

#[derive(Default, Debug, Clone, PartialEq, Eq)]
pub struct LogEntry {
    pub address: H160,
    pub topics: Vec<H256>,
    pub data: Vec<u8>,
}

impl rlp::Decodable for LogEntry {
    fn decode(rlp: &rlp::Rlp) -> Result<Self, rlp::DecoderError> {
        let result = LogEntry {
            address: rlp.val_at(0usize)?,
            topics: rlp.list_at(1usize)?,
            data: rlp.val_at(2usize)?,
        };
        Ok(result)
    }
}

impl rlp::Encodable for LogEntry {
    fn rlp_append(&self, stream: &mut rlp::RlpStream) {
        stream.begin_list(3usize);
        stream.append(&self.address);
        stream.append_list::<H256, _>(&self.topics);
        stream.append(&self.data);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use rlp::{Decodable, Encodable, Rlp, RlpStream};

    #[test]
    fn test_roundtrip_rlp_encoding() {
        let address = H160::from_low_u64_le(32u64);
        let topics = vec![H256::zero()];
        let data = vec![0u8, 1u8, 2u8, 3u8];
        let expected_log_entry = LogEntry {
            address,
            topics,
            data,
        };

        let mut stream = RlpStream::new();

        expected_log_entry.rlp_append(&mut stream);

        let bytes = stream.out();
        let rlp = Rlp::new(bytes.as_ref());
        let actual_log_entry = LogEntry::decode(&rlp).unwrap();

        assert_eq!(expected_log_entry, actual_log_entry);
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/map.rs ---
pub use crate::prelude::{bytes_to_key, PhantomData, Vec};
use aurora_engine_sdk::io::{StorageIntermediate, IO};
use aurora_engine_types::storage::KeyPrefix;

/// A map storing a 1:1 relation between elements of types L and R.
/// The map is backed by storage of type I.
pub struct BijectionMap<L, R, I> {
    left_prefix: KeyPrefix,
    right_prefix: KeyPrefix,
    io: I,
    left_phantom: PhantomData<L>,
    right_phantom: PhantomData<R>,
}

impl<L: AsRef<[u8]> + TryFrom<Vec<u8>>, R: AsRef<[u8]> + TryFrom<Vec<u8>>, I: IO>
    BijectionMap<L, R, I>
{
    pub fn new(left_prefix: KeyPrefix, right_prefix: KeyPrefix, io: I) -> Self {
        Self {
            left_prefix,
            right_prefix,
            io,
            left_phantom: PhantomData,
            right_phantom: PhantomData,
        }
    }

    pub fn insert(&mut self, left: &L, right: &R) {
        let key = self.left_key(left);
        self.io.write_storage(&key, right.as_ref());

        let key = self.right_key(right);
        self.io.write_storage(&key, left.as_ref());
    }

    pub fn lookup_left(&self, left: &L) -> Option<R> {
        let key = self.left_key(left);
        self.io
            .read_storage(&key)
            .and_then(|v| v.to_vec().try_into().ok())
    }

    pub fn lookup_right(&self, right: &R) -> Option<L> {
        let key = self.right_key(right);
        self.io
            .read_storage(&key)
            .and_then(|v| v.to_vec().try_into().ok())
    }

    fn left_key(&self, left: &L) -> Vec<u8> {
        bytes_to_key(self.left_prefix, left.as_ref())
    }

    fn right_key(&self, right: &R) -> Vec<u8> {
        bytes_to_key(self.right_prefix, right.as_ref())
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_map_finds_inserted_pair() {
        use crate::engine::{ERC20Address, NEP141Account};
        use aurora_engine_test_doubles::io::{Storage, StoragePointer};
        use aurora_engine_types::account_id::AccountId;
        use aurora_engine_types::types::Address;
        use std::sync::RwLock;

        let storage = RwLock::new(Storage::default());
        let storage = StoragePointer(&storage);
        let left_prefix = KeyPrefix::Nep141Erc20Map;
        let right_prefix = KeyPrefix::Erc20Nep141Map;

        let mut map: BijectionMap<NEP141Account, ERC20Address, _> =
            BijectionMap::new(left_prefix, right_prefix, storage);

        let erc20_token = Address::zero();
        let nep141_token = AccountId::new("aurora").unwrap();
        let expected_left = NEP141Account(nep141_token);
        let expected_right = ERC20Address(erc20_token);
        map.insert(&expected_left, &expected_right);

        let actual_right = map.lookup_left(&expected_left).unwrap();

        assert_eq!(expected_right.0, actual_right.0);

        let actual_left = map.lookup_right(&expected_right).unwrap();

        assert_eq!(expected_left.0, actual_left.0);
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/parameters.rs ---
use crate::admin_controlled::PausedMask;
use crate::errors;
use crate::fungible_token::FungibleTokenMetadata;
use crate::json::{JsonError, JsonValue};
use crate::prelude::account_id::AccountId;
use crate::prelude::{
    format, Address, Balance, BorshDeserialize, BorshSerialize, RawH256, RawU256, String, Vec,
    WeiU256,
};
use crate::proof::Proof;
use aurora_engine_types::types::{Fee, NEP141Wei, Yocto};
use evm::backend::Log;
#[cfg(feature = "serde")]
use serde::{Deserialize, Serialize};

/// Borsh-encoded parameters for the `new` function.
#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
pub struct NewCallArgs {
    /// Chain id, according to the EIP-115 / ethereum-lists spec.
    pub chain_id: RawU256,
    /// Account which can upgrade this contract.
    /// Use empty to disable updatability.
    pub owner_id: AccountId,
    /// Account of the bridge prover.
    /// Use empty to not use base token as bridged asset.
    pub bridge_prover_id: AccountId,
    /// How many blocks after staging upgrade can deploy it.
    pub upgrade_delay_blocks: u64,
}

/// Borsh-encoded log for use in a `SubmitResult`.
#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct ResultLog {
    pub address: Address,
    pub topics: Vec<RawU256>,
    pub data: Vec<u8>,
}

impl From<Log> for ResultLog {
    fn from(log: Log) -> Self {
        let topics = log
            .topics
            .into_iter()
            .map(|topic| topic.0)
            .collect::<Vec<_>>();
        ResultLog {
            address: Address::new(log.address),
            topics,
            data: log.data,
        }
    }
}

/// The status of a transaction.
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub enum TransactionStatus {
    Succeed(Vec<u8>),
    Revert(Vec<u8>),
    OutOfGas,
    OutOfFund,
    OutOfOffset,
    CallTooDeep,
}

impl TransactionStatus {
    pub fn is_ok(&self) -> bool {
        matches!(*self, TransactionStatus::Succeed(_))
    }

    pub fn is_revert(&self) -> bool {
        matches!(*self, TransactionStatus::Revert(_))
    }

    pub fn is_fail(&self) -> bool {
        *self == TransactionStatus::OutOfGas
            || *self == TransactionStatus::OutOfFund
            || *self == TransactionStatus::OutOfOffset
            || *self == TransactionStatus::CallTooDeep
    }
}

impl AsRef<[u8]> for TransactionStatus {
    fn as_ref(&self) -> &[u8] {
        match self {
            Self::Succeed(_) => b"SUCCESS",
            Self::Revert(_) => errors::ERR_REVERT,
            Self::OutOfFund => errors::ERR_OUT_OF_FUNDS,
            Self::OutOfGas => errors::ERR_OUT_OF_GAS,
            Self::OutOfOffset => errors::ERR_OUT_OF_OFFSET,
            Self::CallTooDeep => errors::ERR_CALL_TOO_DEEP,
        }
    }
}

/// Borsh-encoded parameters for the `call`, `call_with_args`, `deploy_code`,
/// and `deploy_with_input` methods.
#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct SubmitResult {
    version: u8,
    pub status: TransactionStatus,
    pub gas_used: u64,
    pub logs: Vec<ResultLog>,
}

impl SubmitResult {
    /// Must be incremented when making breaking changes to the SubmitResult ABI.
    /// The current value of 7 is chosen because previously a `TransactionStatus` object
    /// was first in the serialization, which is an enum with less than 7 variants.
    /// Therefore, no previous `SubmitResult` would have began with a leading 7 byte,
    /// and this can be used to distinguish the new ABI (with version byte) from the old.
    const VERSION: u8 = 7;

    pub fn new(status: TransactionStatus, gas_used: u64, logs: Vec<ResultLog>) -> Self {
        Self {
            version: Self::VERSION,
            status,
            gas_used,
            logs,
        }
    }
}

/// Borsh-encoded parameters for the engine `call` function.
#[derive(BorshSerialize, BorshDeserialize, Debug, PartialEq, Eq, Clone)]
pub struct FunctionCallArgsV2 {
    pub contract: Address,
    /// Wei compatible Borsh-encoded value field to attach an ETH balance to the transaction
    pub value: WeiU256,
    pub input: Vec<u8>,
}

/// Legacy Borsh-encoded parameters for the engine `call` function, to provide backward type compatibility
#[derive(BorshSerialize, BorshDeserialize, Debug, PartialEq, Eq, Clone)]
pub struct FunctionCallArgsV1 {
    pub contract: Address,
    pub input: Vec<u8>,
}

/// Deserialized values from bytes to current or legacy Borsh-encoded parameters
/// for passing to the engine `call` function, and to provide backward type compatibility
#[derive(BorshSerialize, BorshDeserialize, Debug, PartialEq, Eq, Clone)]
pub enum CallArgs {
    V2(FunctionCallArgsV2),
    V1(FunctionCallArgsV1),
}

impl CallArgs {
    pub fn deserialize(bytes: &[u8]) -> Option<Self> {
        // For handling new input format (wrapped into call args enum) - for data structures with new arguments,
        // made for flexibility and extensibility.
        if let Ok(value) = Self::try_from_slice(bytes) {
            Some(value)
            // Fallback, for handling old input format,
            // i.e. input, formed as a raw (not wrapped into call args enum) data structure with legacy arguments,
            // made for backward compatibility.
        } else if let Ok(value) = FunctionCallArgsV1::try_from_slice(bytes) {
            Some(Self::V1(value))
            // Dealing with unrecognized input should be handled and result as an exception in a call site.
        } else {
            None
        }
    }
}

/// Borsh-encoded parameters for the `view` function.
#[derive(BorshSerialize, BorshDeserialize, Debug, Eq, PartialEq)]
pub struct ViewCallArgs {
    pub sender: Address,
    pub address: Address,
    pub amount: RawU256,
    pub input: Vec<u8>,
}

/// Borsh-encoded parameters for `deploy_erc20_token` function.
#[derive(BorshSerialize, BorshDeserialize, Debug, Eq, PartialEq, Clone)]
pub struct DeployErc20TokenArgs {
    pub nep141: AccountId,
}

/// Borsh-encoded parameters for `get_erc20_from_nep141` function.
pub type GetErc20FromNep141CallArgs = DeployErc20TokenArgs;

/// Borsh-encoded parameters for the `get_storage_at` function.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct GetStorageAtArgs {
    pub address: Address,
    pub key: RawH256,
}

/// Borsh-encoded (genesis) account balance used by the `begin_chain` function.
#[cfg(feature = "evm_bully")]
#[derive(BorshSerialize, BorshDeserialize)]
pub struct AccountBalance {
    pub address: Address,
    pub balance: RawU256,
}

/// Borsh-encoded parameters for the `begin_chain` function.
#[cfg(feature = "evm_bully")]
#[derive(BorshSerialize, BorshDeserialize)]
pub struct BeginChainArgs {
    pub chain_id: RawU256,
    pub genesis_alloc: Vec<AccountBalance>,
}

/// Borsh-encoded parameters for the `begin_block` function.
#[cfg(feature = "evm_bully")]
#[derive(BorshSerialize, BorshDeserialize)]
pub struct BeginBlockArgs {
    /// The current block's hash (for replayer use).
    pub hash: RawU256,
    /// The current block's beneficiary address.
    pub coinbase: Address,
    /// The current block's timestamp (in seconds since the Unix epoch).
    pub timestamp: RawU256,
    /// The current block's number (the genesis block is number zero).
    pub number: RawU256,
    /// The current block's difficulty.
    pub difficulty: RawU256,
    /// The current block's gas limit.
    pub gaslimit: RawU256,
}

/// Borsh-encoded parameters for the `ft_transfer_call` function
/// for regular NEP-141 tokens.
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct NEP141FtOnTransferArgs {
    pub sender_id: AccountId,
    /// Balance can be for Eth on Near and for Eth to Aurora
    /// `ft_on_transfer` can be called with arbitrary NEP-141 tokens attached, therefore we do not specify a particular type Wei.
    pub amount: Balance,
    pub msg: String,
}

impl TryFrom<JsonValue> for NEP141FtOnTransferArgs {
    type Error = JsonError;

    fn try_from(value: JsonValue) -> Result<Self, Self::Error> {
        Ok(Self {
            sender_id: AccountId::try_from(value.string("sender_id")?)
                .map_err(|_| JsonError::InvalidString)?,
            amount: Balance::new(value.u128("amount")?),
            msg: value.string("msg")?,
        })
    }
}

impl From<NEP141FtOnTransferArgs> for String {
    fn from(value: NEP141FtOnTransferArgs) -> Self {
        format!(
            r#"{{"sender_id": "{}", "amount": "{}", "msg": "{}"}}"#,
            value.sender_id,
            value.amount,
            // Escape message to avoid json injection attacks
            value.msg.replace('\\', "\\\\").replace('"', "\\\"")
        )
    }
}

/// Eth-connector deposit arguments
#[derive(BorshSerialize, BorshDeserialize)]
pub struct DepositCallArgs {
    /// Proof data
    pub proof: Proof,
    /// Optional relayer address
    pub relayer_eth_account: Option<Address>,
}

/// Eth-connector isUsedProof arguments
#[derive(BorshSerialize, BorshDeserialize)]
pub struct IsUsedProofCallArgs {
    /// Proof data
    pub proof: Proof,
}

/// withdraw result for eth-connector
#[derive(BorshSerialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(BorshDeserialize))]
pub struct WithdrawResult {
    pub amount: NEP141Wei,
    pub recipient_id: Address,
    pub eth_custodian_address: Address,
}

/// Fungible token storage balance
#[derive(Default)]
pub struct StorageBalance {
    pub total: Yocto,
    pub available: Yocto,
}

impl StorageBalance {
    pub fn to_json_bytes(&self) -> Vec<u8> {
        format!(
            "{{\"total\": \"{}\", \"available\": \"{}\"}}",
            self.total, self.available
        )
        .into_bytes()
    }
}

/// ft_resolve_transfer eth-connector call args
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct ResolveTransferCallArgs {
    pub sender_id: AccountId,
    pub amount: NEP141Wei,
    pub receiver_id: AccountId,
}

impl TryFrom<JsonValue> for ResolveTransferCallArgs {
    type Error = error::ParseTypeFromJsonError;

    fn try_from(v: JsonValue) -> Result<Self, Self::Error> {
        Ok(Self {
            sender_id: AccountId::try_from(v.string("sender_id")?)?,
            receiver_id: AccountId::try_from(v.string("receiver_id")?)?,
            amount: NEP141Wei::new(v.u128("amount")?),
        })
    }
}

/// Finish deposit NEAR eth-connector call args
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct FinishDepositCallArgs {
    pub new_owner_id: AccountId,
    pub amount: NEP141Wei,
    pub proof_key: String,
    pub relayer_id: AccountId,
    pub fee: Fee,
    pub msg: Option<Vec<u8>>,
}

/// Deposit ETH args
#[derive(Default, BorshDeserialize, BorshSerialize, Clone)]
pub struct DepositEthCallArgs {
    pub proof: Proof,
    pub relayer_eth_account: Address,
}

/// Finish deposit NEAR eth-connector call args
#[derive(BorshSerialize, BorshDeserialize)]
pub struct FinishDepositEthCallArgs {
    pub new_owner_id: Address,
    pub amount: NEP141Wei,
    pub fee: Balance,
    pub relayer_eth_account: AccountId,
    pub proof: Proof,
}

/// Eth-connector initial args
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct InitCallArgs {
    pub prover_account: AccountId,
    pub eth_custodian_address: String,
    pub metadata: FungibleTokenMetadata,
}

/// Eth-connector Set contract data call args
pub type SetContractDataCallArgs = InitCallArgs;

/// transfer eth-connector call args
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct TransferCallCallArgs {
    pub receiver_id: AccountId,
    pub amount: NEP141Wei,
    pub memo: Option<String>,
    pub msg: String,
}

impl TryFrom<JsonValue> for TransferCallCallArgs {
    type Error = error::ParseTypeFromJsonError;

    fn try_from(v: JsonValue) -> Result<Self, Self::Error> {
        let receiver_id = AccountId::try_from(v.string("receiver_id")?)?;
        let amount = NEP141Wei::new(v.u128("amount")?);
        let memo = v.string("memo").ok();
        let msg = v.string("msg")?;
        Ok(Self {
            receiver_id,
            amount,
            memo,
            msg,
        })
    }
}

/// storage_balance_of eth-connector call args
#[derive(BorshSerialize, BorshDeserialize)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct StorageBalanceOfCallArgs {
    pub account_id: AccountId,
}

impl TryFrom<JsonValue> for StorageBalanceOfCallArgs {
    type Error = error::ParseTypeFromJsonError;

    fn try_from(v: JsonValue) -> Result<Self, Self::Error> {
        let account_id = AccountId::try_from(v.string("account_id")?)?;
        Ok(Self { account_id })
    }
}

/// storage_deposit eth-connector call args
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct StorageDepositCallArgs {
    pub account_id: Option<AccountId>,
    pub registration_only: Option<bool>,
}

impl From<JsonValue> for StorageDepositCallArgs {
    fn from(v: JsonValue) -> Self {
        Self {
            account_id: v
                .string("account_id")
                .map_or(None, |acc| AccountId::try_from(acc).ok()),
            registration_only: v.bool("registration_only").ok(),
        }
    }
}

/// storage_withdraw eth-connector call args
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct StorageWithdrawCallArgs {
    pub amount: Option<Yocto>,
}

impl From<JsonValue> for StorageWithdrawCallArgs {
    fn from(v: JsonValue) -> Self {
        Self {
            amount: v.u128("amount").map(Yocto::new).ok(),
        }
    }
}

/// transfer args for json invocation
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct TransferCallArgs {
    pub receiver_id: AccountId,
    pub amount: NEP141Wei,
    pub memo: Option<String>,
}

impl TryFrom<JsonValue> for TransferCallArgs {
    type Error = error::ParseTypeFromJsonError;

    fn try_from(v: JsonValue) -> Result<Self, Self::Error> {
        Ok(Self {
            receiver_id: AccountId::try_from(v.string("receiver_id")?)?,
            amount: NEP141Wei::new(v.u128("amount")?),
            memo: v.string("memo").ok(),
        })
    }
}

/// balance_of args for json invocation
#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BalanceOfCallArgs {
    pub account_id: AccountId,
}

#[derive(Debug, Clone, PartialEq, Eq, BorshSerialize, BorshDeserialize)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct BalanceOfEthCallArgs {
    pub address: Address,
}

impl TryFrom<JsonValue> for BalanceOfCallArgs {
    type Error = error::ParseTypeFromJsonError;

    fn try_from(v: JsonValue) -> Result<Self, Self::Error> {
        Ok(Self {
            account_id: AccountId::try_from(v.string("account_id")?)?,
        })
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct RegisterRelayerCallArgs {
    pub address: Address,
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
#[cfg_attr(feature = "serde", derive(Serialize, Deserialize))]
pub struct PauseEthConnectorCallArgs {
    pub paused_mask: PausedMask,
}

#[derive(Debug, Clone, BorshSerialize, BorshDeserialize, PartialEq, Eq)]
pub struct PausePrecompilesCallArgs {
    pub paused_mask: u32,
}

pub mod error {
    use crate::json::JsonError;
    use aurora_engine_types::account_id::ParseAccountError;

    pub enum ParseTypeFromJsonError {
        Json(JsonError),
        InvalidAccount(ParseAccountError),
    }

    impl From<JsonError> for ParseTypeFromJsonError {
        fn from(e: JsonError) -> Self {
            Self::Json(e)
        }
    }

    impl From<ParseAccountError> for ParseTypeFromJsonError {
        fn from(e: ParseAccountError) -> Self {
            Self::InvalidAccount(e)
        }
    }

    impl AsRef<[u8]> for ParseTypeFromJsonError {
        fn as_ref(&self) -> &[u8] {
            match self {
                Self::Json(e) => e.as_ref(),
                Self::InvalidAccount(e) => e.as_ref(),
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_view_call_fail() {
        let bytes = [0; 71];
        let _ = ViewCallArgs::try_from_slice(&bytes).unwrap_err();
    }

    #[test]
    fn test_roundtrip_view_call() {
        let x = ViewCallArgs {
            sender: Address::from_array([1; 20]),
            address: Address::from_array([2; 20]),
            amount: [3; 32],
            input: vec![1, 2, 3],
        };
        let bytes = x.try_to_vec().unwrap();
        let res = ViewCallArgs::try_from_slice(&bytes).unwrap();
        assert_eq!(x, res);
    }

    #[test]
    fn test_call_args_deserialize() {
        let new_input = FunctionCallArgsV2 {
            contract: Address::from_array([0u8; 20]),
            value: WeiU256::default(),
            input: Vec::new(),
        };
        let legacy_input = FunctionCallArgsV1 {
            contract: Address::from_array([0u8; 20]),
            input: Vec::new(),
        };

        // Parsing bytes in a new input format - data structures (wrapped into call args enum) with new arguments,
        // made for flexibility and extensibility.

        // Using new input format (wrapped into call args enum) and data structure with new argument (`value` field).
        let input_bytes = CallArgs::V2(new_input.clone()).try_to_vec().unwrap();
        let parsed_data = CallArgs::deserialize(&input_bytes);
        assert_eq!(parsed_data, Some(CallArgs::V2(new_input.clone())));

        // Using new input format (wrapped into call args enum) and old data structure with legacy arguments,
        // this is allowed for compatibility reason.
        let input_bytes = CallArgs::V1(legacy_input.clone()).try_to_vec().unwrap();
        let parsed_data = CallArgs::deserialize(&input_bytes);
        assert_eq!(parsed_data, Some(CallArgs::V1(legacy_input.clone())));

        // Parsing bytes in an old input format - raw data structure (not wrapped into call args enum) with legacy arguments,
        // made for backward compatibility.

        // Using old input format (not wrapped into call args enum) - raw data structure with legacy arguments.
        let input_bytes = legacy_input.try_to_vec().unwrap();
        let parsed_data = CallArgs::deserialize(&input_bytes);
        assert_eq!(parsed_data, Some(CallArgs::V1(legacy_input)));

        // Using old input format (not wrapped into call args enum) - raw data structure with new argument (`value` field).
        // Data structures with new arguments allowed only in new input format for future extensibility reason.
        // Raw data structure (old input format) allowed only with legacy arguments for backward compatibility reason.
        // Unrecognized input should be handled and result as an exception in a call site.
        let input_bytes = new_input.try_to_vec().unwrap();
        let parsed_data = CallArgs::deserialize(&input_bytes);
        assert_eq!(parsed_data, None);
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/pausables.rs ---
use crate::prelude::{AccountId, Address, BTreeSet, Vec};
use aurora_engine_precompiles::native::{exit_to_ethereum, exit_to_near};
use aurora_engine_sdk::io::{StorageIntermediate, IO};
use aurora_engine_types::storage::{bytes_to_key, KeyPrefix};
use bitflags::bitflags;
use borsh::{BorshDeserialize, BorshSerialize};

bitflags! {
    /// Wraps unsigned integer where each bit identifies a different precompile.
    #[derive(BorshSerialize, BorshDeserialize, Default)]
    pub struct PrecompileFlags: u32 {
        const EXIT_TO_NEAR        = 0b01;
        const EXIT_TO_ETHEREUM    = 0b10;
    }
}

impl PrecompileFlags {
    pub fn from_address(address: &Address) -> Option<Self> {
        Some(if address == &exit_to_ethereum::ADDRESS {
            PrecompileFlags::EXIT_TO_ETHEREUM
        } else if address == &exit_to_near::ADDRESS {
            PrecompileFlags::EXIT_TO_NEAR
        } else {
            return None;
        })
    }

    /// Checks if the precompile belonging to the `address` is marked as paused.
    pub fn is_paused_by_address(&self, address: &Address) -> bool {
        match Self::from_address(address) {
            Some(precompile_flag) => self.contains(precompile_flag),
            None => false,
        }
    }
}

/// Can check if given account has a permission to pause precompiles.
pub trait Authorizer {
    /// Checks if the `account` has the permission to pause precompiles.
    fn is_authorized(&self, account: &AccountId) -> bool;
}

/// Can check if a subset of precompiles is currently paused or not.
pub trait PausedPrecompilesChecker {
    /// Checks if all of the `precompiles` are paused.
    ///
    /// The `precompiles` mask can be a subset and every 1 bit is meant to be checked and every 0 bit is ignored.
    fn is_paused(&self, precompiles: PrecompileFlags) -> bool;

    /// Returns a set of all paused precompiles in a bitmask, where every 1 bit means paused and every 0 bit means
    /// the opposite.
    ///
    /// To determine which bit belongs to what precompile, you have to match it with appropriate constant, for example
    /// [`PrecompileFlags::EXIT_TO_NEAR`].
    ///
    /// # Example
    /// ```
    /// # use aurora_engine::pausables::{PausedPrecompilesChecker, PrecompileFlags};
    /// # fn check(checker: impl PausedPrecompilesChecker) {
    /// let flags = checker.paused();
    ///
    /// if flags.contains(PrecompileFlags::EXIT_TO_NEAR) {
    ///     println!("EXIT_TO_NEAR is paused!");
    /// }
    /// # }
    /// ```
    fn paused(&self) -> PrecompileFlags;
}

/// Responsible for resuming and pausing of precompiles.
pub trait PausedPrecompilesManager {
    /// Resumes all the given `precompiles_to_resume`.
    ///
    /// The `precompiles_to_resume` mask can be a subset and every 1 bit is meant to be resumed and every 0 bit is
    /// ignored.
    fn resume_precompiles(&mut self, precompiles_to_resume: PrecompileFlags);

    /// Pauses all the given precompiles.
    ///
    /// The `precompiles_to_pause` mask can be a subset and every 1 bit is meant to be paused and every 0 bit is
    /// ignored.
    fn pause_precompiles(&mut self, precompiles_to_pause: PrecompileFlags);
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Default, Clone)]
pub struct EngineAuthorizer {
    /// List of [AccountId]s with the permission to pause precompiles.
    pub acl: BTreeSet<AccountId>,
}

impl EngineAuthorizer {
    /// Creates new [EngineAuthorizer] and grants permission to pause precompiles for all given `accounts`.
    pub fn from_accounts(accounts: impl Iterator<Item = AccountId>) -> Self {
        Self {
            acl: accounts.collect(),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Debug, Default, Clone)]
pub struct EnginePrecompilesPauser<I: IO> {
    /// Storage to read pause flags from and write into.
    io: I,
}

impl<I: IO> EnginePrecompilesPauser<I> {
    /// Key for storing [PrecompileFlags].
    const PAUSE_FLAGS_KEY: &'static [u8; 11] = b"PAUSE_FLAGS";

    /// Creates new [EnginePrecompilesPauser] instance that reads from and writes into storage accessed using `io`.
    pub fn from_io(io: I) -> Self {
        Self { io }
    }

    fn read_flags_from_storage(&self) -> PrecompileFlags {
        match self.io.read_storage(&Self::storage_key()) {
            None => PrecompileFlags::empty(),
            Some(bytes) => {
                let int_length = core::mem::size_of::<u32>();
                let input = bytes.to_vec();

                if input.len() < int_length {
                    return PrecompileFlags::empty();
                }

                let (int_bytes, _) = input.split_at(int_length);
                PrecompileFlags::from_bits_truncate(u32::from_le_bytes(
                    int_bytes.try_into().unwrap(),
                ))
            }
        }
    }

    fn write_flags_into_storage(&mut self, pause_flags: PrecompileFlags) {
        self.io
            .write_storage(&Self::storage_key(), &pause_flags.bits().to_le_bytes());
    }

    fn storage_key() -> Vec<u8> {
        bytes_to_key(KeyPrefix::Config, Self::PAUSE_FLAGS_KEY)
    }
}

impl Authorizer for EngineAuthorizer {
    fn is_authorized(&self, account: &AccountId) -> bool {
        self.acl.get(account).is_some()
    }
}

impl<I: IO> PausedPrecompilesChecker for EnginePrecompilesPauser<I> {
    fn is_paused(&self, precompiles: PrecompileFlags) -> bool {
        self.read_flags_from_storage().contains(precompiles)
    }

    fn paused(&self) -> PrecompileFlags {
        self.read_flags_from_storage()
    }
}

impl<I: IO> PausedPrecompilesManager for EnginePrecompilesPauser<I> {
    fn resume_precompiles(&mut self, precompiles_to_resume: PrecompileFlags) {
        let mut pause_flags = self.read_flags_from_storage();
        pause_flags.remove(precompiles_to_resume);
        self.write_flags_into_storage(pause_flags);
    }

    fn pause_precompiles(&mut self, precompiles_to_pause: PrecompileFlags) {
        let mut pause_flags = self.read_flags_from_storage();
        pause_flags.insert(precompiles_to_pause);
        self.write_flags_into_storage(pause_flags);
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use aurora_engine_test_doubles::io::{Storage, StoragePointer};
    use std::iter::once;
    use std::sync::RwLock;
    use test_case::test_case;

    #[test_case(PrecompileFlags::EXIT_TO_ETHEREUM, exit_to_ethereum::ADDRESS)]
    #[test_case(PrecompileFlags::EXIT_TO_NEAR, exit_to_near::ADDRESS)]
    fn test_paused_flag_marks_precompiles_address_as_paused(
        flags: PrecompileFlags,
        address: Address,
    ) {
        assert!(flags.is_paused_by_address(&address));
    }

    #[test]
    fn test_unknown_precompile_address_is_not_marked_as_paused() {
        let flags = PrecompileFlags::all();
        let address = Address::zero();

        assert!(!flags.is_paused_by_address(&address));
    }

    #[test]
    fn test_pausing_precompile_marks_it_as_paused() {
        let storage = RwLock::new(Storage::default());
        let io = StoragePointer(&storage);
        let mut pauser = EnginePrecompilesPauser::from_io(io);
        let flags = PrecompileFlags::EXIT_TO_NEAR;

        assert!(!pauser.is_paused(flags));
        pauser.pause_precompiles(flags);
        assert!(pauser.is_paused(flags));
    }

    #[test]
    fn test_resuming_precompile_removes_its_mark_as_paused() {
        let storage = RwLock::new(Storage::default());
        let io = StoragePointer(&storage);
        let mut pauser = EnginePrecompilesPauser::from_io(io);
        let flags = PrecompileFlags::EXIT_TO_NEAR;
        pauser.pause_precompiles(flags);

        assert!(pauser.is_paused(flags));
        pauser.resume_precompiles(flags);
        assert!(!pauser.is_paused(flags));
    }

    #[test]
    fn test_granting_permission_to_account_authorizes_it() {
        let account = AccountId::default();
        let authorizer = EngineAuthorizer::from_accounts(once(account.clone()));

        assert!(authorizer.is_authorized(&account));
    }

    #[test]
    fn test_revoking_permission_from_account_unauthorizes_it() {
        let account = AccountId::default();
        let authorizer = EngineAuthorizer::default();

        assert!(!authorizer.is_authorized(&account));
    }

    #[test]
    fn test_no_precompile_is_paused_if_storage_contains_too_few_bytes() {
        let key = EnginePrecompilesPauser::<StoragePointer>::storage_key();
        let storage = RwLock::new(Storage::default());
        let mut io = StoragePointer(&storage);
        io.write_storage(key.as_slice(), &[7u8]);
        let pauser = EnginePrecompilesPauser::from_io(io);

        let expected_paused = PrecompileFlags::empty();
        let actual_paused = pauser.paused();
        assert_eq!(expected_paused, actual_paused);
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/prelude.rs ---
mod v0 {
    pub use aurora_engine_precompiles as precompiles;
    pub use aurora_engine_sdk as sdk;
    pub use aurora_engine_sdk::types::*;
    pub use aurora_engine_transactions as transactions;
    pub use aurora_engine_types::account_id::*;
    pub use aurora_engine_types::parameters::*;
    pub use aurora_engine_types::storage::*;
    pub use aurora_engine_types::types::*;
    pub use aurora_engine_types::*;
    pub use borsh::{BorshDeserialize, BorshSerialize};
}

pub use v0::*;

'''
'''--- aurora-engine-2.8.1/engine/src/proof.rs ---
use crate::prelude::{sdk, BorshDeserialize, BorshSerialize, String, ToString, Vec};

#[derive(Debug, Default, BorshDeserialize, BorshSerialize, Clone)]
#[cfg_attr(feature = "impl-serde", derive(serde::Deserialize, serde::Serialize))]
pub struct Proof {
    pub log_index: u64,
    pub log_entry_data: Vec<u8>,
    pub receipt_index: u64,
    pub receipt_data: Vec<u8>,
    pub header_data: Vec<u8>,
    pub proof: Vec<Vec<u8>>,
}

impl Proof {
    pub fn key(&self) -> String {
        let mut data = self.log_index.try_to_vec().unwrap();
        data.extend(self.receipt_index.try_to_vec().unwrap());
        data.extend(self.header_data.clone());
        sdk::sha256(&data[..])
            .0
            .iter()
            .map(|n| n.to_string())
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::deposit_event::{DepositedEvent, TokenMessageData, DEPOSITED_EVENT};
    use crate::log_entry::LogEntry;
    use aurora_engine_precompiles::make_address;
    use aurora_engine_types::types::{Address, Fee, NEP141Wei, Wei};
    use aurora_engine_types::{H160, U256};

    const ETH_CUSTODIAN_ADDRESS: Address =
        make_address(0xd045f7e1, 0x9b2488924b97f9c145b5e51d0d895a65);

    #[test]
    fn test_proof_key_generates_successfully() {
        let recipient_address = Address::new(H160([22u8; 20]));
        let deposit_amount = Wei::new_u64(123_456_789);
        let proof = self::create_proof(recipient_address, deposit_amount);

        let expected_key =
            "1297721518512077871939115641114233180253108247225100248224214775219368216419218177247";
        let actual_key = proof.key();

        assert_eq!(expected_key, actual_key);
    }

    fn create_proof(recipient_address: Address, deposit_amount: Wei) -> Proof {
        let eth_custodian_address = ETH_CUSTODIAN_ADDRESS;

        let fee = Fee::new(NEP141Wei::new(0));
        let message = ["aurora", ":", recipient_address.encode().as_str()].concat();
        let token_message_data: TokenMessageData =
            TokenMessageData::parse_event_message_and_prepare_token_message_data(&message, fee)
                .unwrap();

        let deposit_event = DepositedEvent {
            eth_custodian_address,
            sender: Address::new(H160([0u8; 20])),
            token_message_data,
            amount: NEP141Wei::new(deposit_amount.raw().as_u128()),
            fee,
        };

        let event_schema = ethabi::Event {
            name: DEPOSITED_EVENT.into(),
            inputs: DepositedEvent::event_params(),
            anonymous: false,
        };
        let log_entry = LogEntry {
            address: eth_custodian_address.raw(),
            topics: vec![
                event_schema.signature(),
                // the sender is not important
                crate::prelude::H256::zero(),
            ],
            data: ethabi::encode(&[
                ethabi::Token::String(message),
                ethabi::Token::Uint(U256::from(deposit_event.amount.as_u128())),
                ethabi::Token::Uint(U256::from(deposit_event.fee.as_u128())),
            ]),
        };

        Proof {
            log_index: 1,
            // Only this field matters for the purpose of this test
            log_entry_data: rlp::encode(&log_entry).to_vec(),
            receipt_index: 1,
            receipt_data: Vec::new(),
            header_data: Vec::new(),
            proof: Vec::new(),
        }
    }
}

'''
'''--- aurora-engine-2.8.1/engine/src/xcc.rs ---
use crate::parameters::{CallArgs, FunctionCallArgsV2};
use aurora_engine_precompiles::xcc::state;
use aurora_engine_sdk::io::{StorageIntermediate, IO};
use aurora_engine_sdk::promise::PromiseHandler;
use aurora_engine_types::account_id::AccountId;
use aurora_engine_types::parameters::{PromiseAction, PromiseBatchAction, PromiseCreateArgs};
use aurora_engine_types::storage::{self, KeyPrefix};
use aurora_engine_types::types::{Address, NearGas, Yocto, ZERO_YOCTO};
use aurora_engine_types::{format, Cow, Vec, U256};
use borsh::{BorshDeserialize, BorshSerialize};

pub const ERR_NO_ROUTER_CODE: &str = "ERR_MISSING_XCC_BYTECODE";
pub const ERR_INVALID_ACCOUNT: &str = "ERR_INVALID_XCC_ACCOUNT";
pub const ERR_ATTACHED_NEAR: &str = "ERR_ATTACHED_XCC_NEAR";
pub const CODE_KEY: &[u8] = b"router_code";
/// Gas costs estimated from simulation tests.
pub const VERSION_UPDATE_GAS: NearGas = NearGas::new(5_000_000_000_000);
pub const INITIALIZE_GAS: NearGas = NearGas::new(15_000_000_000_000);
pub const UNWRAP_AND_REFUND_GAS: NearGas = NearGas::new(25_000_000_000_000);
pub const WITHDRAW_GAS: NearGas = NearGas::new(30_000_000_000_000);
/// Solidity selector for the withdrawToNear function
/// https://www.4byte.directory/signatures/?bytes4_signature=0x6b351848
pub const WITHDRAW_TO_NEAR_SELECTOR: [u8; 4] = [0x6b, 0x35, 0x18, 0x48];

pub use aurora_engine_precompiles::xcc::state::{
    get_code_version_of_address, get_latest_code_version, get_wnear_address, CodeVersion,
    ERR_CORRUPTED_STORAGE, STORAGE_AMOUNT, VERSION_KEY, WNEAR_KEY,
};

/// Type wrapper for router bytecode.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct RouterCode<'a>(pub Cow<'a, [u8]>);

impl<'a> RouterCode<'a> {
    pub fn new(bytes: Vec<u8>) -> Self {
        Self(Cow::Owned(bytes))
    }

    pub fn borrowed(bytes: &'a [u8]) -> Self {
        Self(Cow::Borrowed(bytes))
    }
}

#[derive(Debug, Clone, PartialEq, Eq, BorshDeserialize, BorshSerialize)]
pub struct AddressVersionUpdateArgs {
    pub address: Address,
    pub version: CodeVersion,
}

pub fn handle_precompile_promise<I, P>(
    io: &I,
    handler: &mut P,
    promise: PromiseCreateArgs,
    required_near: Yocto,
    current_account_id: &AccountId,
) where
    P: PromiseHandler,
    I: IO + Copy,
{
    let target_account: &str = promise.target_account_id.as_ref();
    let sender = Address::decode(&target_account[0..40]).expect(ERR_INVALID_ACCOUNT);

    // Confirm target_account is of the form `{address}.{aurora}`
    // Address prefix parsed above, so only need to check `.{aurora}`
    assert_eq!(&target_account[40..41], ".", "{}", ERR_INVALID_ACCOUNT);
    assert_eq!(
        &target_account[41..],
        current_account_id.as_ref(),
        "{}",
        ERR_INVALID_ACCOUNT
    );
    // Confirm there is 0 NEAR attached to the promise
    // (the precompile should not drain the engine's balance).
    assert_eq!(
        promise.attached_balance, ZERO_YOCTO,
        "{}",
        ERR_ATTACHED_NEAR
    );

    let latest_code_version = get_latest_code_version(io);
    let sender_code_version = get_code_version_of_address(io, &sender);
    let deploy_needed = match sender_code_version {
        None => AddressVersionStatus::DeployNeeded {
            create_needed: true,
        },
        Some(version) if version < latest_code_version => AddressVersionStatus::DeployNeeded {
            create_needed: false,
        },
        Some(_version) => AddressVersionStatus::UpToDate,
    };
    // 1. If the router contract account does not exist or is out of date then we start
    //    with a batch transaction to deploy the router. This batch also has an attached
    //    callback to update the engine's storage with the new version of that router account.
    let setup_id = match &deploy_needed {
        AddressVersionStatus::DeployNeeded { create_needed } => {
            let mut promise_actions = Vec::with_capacity(4);
            if *create_needed {
                promise_actions.push(PromiseAction::CreateAccount);
                promise_actions.push(PromiseAction::Transfer {
                    amount: STORAGE_AMOUNT,
                });
            }
            promise_actions.push(PromiseAction::DeployContract {
                code: get_router_code(io).0.into_owned(),
            });
            // After a deploy we call the contract's initialize function
            let wnear_address = state::get_wnear_address(io);
            let wnear_account = crate::engine::nep141_erc20_map(*io)
                .lookup_right(&crate::engine::ERC20Address(wnear_address))
                .unwrap();
            let init_args = format!(
                r#"{{"wnear_account": "{}", "must_register": {}}}"#,
                wnear_account.0.as_ref(),
                create_needed,
            );
            promise_actions.push(PromiseAction::FunctionCall {
                name: "initialize".into(),
                args: init_args.into_bytes(),
                attached_yocto: ZERO_YOCTO,
                gas: INITIALIZE_GAS,
            });
            let batch = PromiseBatchAction {
                target_account_id: promise.target_account_id.clone(),
                actions: promise_actions,
            };
            // Safety: This batch creation is safe because it only acts on the router sub-account
            // (not the main engine account), and the actions performed are only (1) create it
            // for the first time and/or (2) deploy the code from our storage (i.e. the deployed
            // code is controlled by us, not the user).
            let promise_id = unsafe { handler.promise_create_batch(&batch) };
            // Add a callback here to update the version of the account
            let args = AddressVersionUpdateArgs {
                address: sender,
                version: latest_code_version,
            };
            let callback = PromiseCreateArgs {
                target_account_id: current_account_id.clone(),
                method: "factory_update_address_version".into(),
                args: args.try_to_vec().unwrap(),
                attached_balance: ZERO_YOCTO,
                attached_gas: VERSION_UPDATE_GAS,
            };

            // Safety: A call from the engine to the engine's `factory_update_address_version`
            // method is safe because that method only writes the specific router sub-account
            // metadata that has just been deployed above.
            unsafe { Some(handler.promise_attach_callback(promise_id, &callback)) }
        }
        AddressVersionStatus::UpToDate => None,
    };
    // 2. If some NEAR is required for this call (from storage staking for a new account
    //    and/or attached NEAR to the call the user wants to make), then we need to have the
    //    engine withdraw that amount of wNEAR to the router account and then have the router
    //    unwrap it into actual NEAR. In the case of storage staking, the engine contract
    //    covered the cost initially (see setup batch above), so the unwrapping also sends
    //    a refund back to the engine.
    let withdraw_id = if required_near == ZERO_YOCTO {
        setup_id
    } else {
        let wnear_address = state::get_wnear_address(io);
        let withdraw_call_args = CallArgs::V2(FunctionCallArgsV2 {
            contract: wnear_address,
            value: [0u8; 32],
            input: withdraw_to_near_args(&promise.target_account_id, required_near),
        });
        let withdraw_call = PromiseCreateArgs {
            target_account_id: current_account_id.clone(),
            method: "call".into(),
            args: withdraw_call_args.try_to_vec().unwrap(),
            attached_balance: ZERO_YOCTO,
            attached_gas: WITHDRAW_GAS,
        };
        // Safety: This promise is safe. Even though this is a call from the engine account to
        // itself invoking the `call` method (which could be dangerous), the argument to `call`
        // is controlled entirely by us (not any user). This call will only execute the wnear
        // exit precompile, and only for the necessary amount. Note that this amount will always
        // be present, otherwise the user's call to the xcc precompile would have failed.
        let id = unsafe {
            match setup_id {
                None => handler.promise_create_call(&withdraw_call),
                Some(setup_id) => handler.promise_attach_callback(setup_id, &withdraw_call),
            }
        };
        let refund_needed = match deploy_needed {
            AddressVersionStatus::DeployNeeded { create_needed } => create_needed,
            AddressVersionStatus::UpToDate => false,
        };
        let args = format!(
            r#"{{"amount": "{}", "refund_needed": {}}}"#,
            required_near.as_u128(),
            refund_needed,
        );
        let unwrap_call = PromiseCreateArgs {
            target_account_id: promise.target_account_id.clone(),
            method: "unwrap_and_refund_storage".into(),
            args: args.into_bytes(),
            attached_balance: ZERO_YOCTO,
            attached_gas: UNWRAP_AND_REFUND_GAS,
        };
        // Safety: This call is safe because the router's `unwrap_and_refund_storage` method
        // does not violate any security invariants. It only interacts with the wrap.near contract
        // to obtain NEAR from WNEAR.
        unsafe { Some(handler.promise_attach_callback(id, &unwrap_call)) }
    };
    // 3. Finally we can do the call the user wanted to do.

    // Safety: this call is safe because the promise comes from the XCC precompile, not the
    // user directly. The XCC precompile will only construct promises that target the `execute`
    // and `schedule` methods of the user's router contract. Therefore, the user cannot have
    // the engine make arbitrary calls.
    let _promise_id = unsafe {
        match withdraw_id {
            None => handler.promise_create_call(&promise),
            Some(withdraw_id) => handler.promise_attach_callback(withdraw_id, &promise),
        }
    };
}

/// Read the current wasm bytecode for the router contracts
pub fn get_router_code<I: IO>(io: &I) -> RouterCode {
    let key = storage::bytes_to_key(KeyPrefix::CrossContractCall, CODE_KEY);
    let bytes = io.read_storage(&key).expect(ERR_NO_ROUTER_CODE).to_vec();
    RouterCode::new(bytes)
}

/// Set new router bytecode, and update increment the version by 1.
pub fn update_router_code<I: IO>(io: &mut I, code: &RouterCode) {
    let key = storage::bytes_to_key(KeyPrefix::CrossContractCall, CODE_KEY);
    io.write_storage(&key, &code.0);

    let current_version = get_latest_code_version(io);
    set_latest_code_version(io, current_version.increment());
}

/// Set the address of the wNEAR ERC-20 contract
pub fn set_wnear_address<I: IO>(io: &mut I, address: &Address) {
    let key = storage::bytes_to_key(KeyPrefix::CrossContractCall, WNEAR_KEY);
    io.write_storage(&key, address.as_bytes());
}

/// Set the version of the router contract deployed for the given address.
pub fn set_code_version_of_address<I: IO>(io: &mut I, address: &Address, version: CodeVersion) {
    let key = storage::bytes_to_key(KeyPrefix::CrossContractCall, address.as_bytes());
    let value_bytes = version.0.to_le_bytes();
    io.write_storage(&key, &value_bytes);
}

/// Sets the latest router contract version. This function is intentionally private because
/// it should never be set manually. The version is managed automatically by `update_router_code`.
fn set_latest_code_version<I: IO>(io: &mut I, version: CodeVersion) {
    let key = storage::bytes_to_key(KeyPrefix::CrossContractCall, VERSION_KEY);
    let value_bytes = version.0.to_le_bytes();
    io.write_storage(&key, &value_bytes);
}

/// Private enum used for bookkeeping what actions are needed in the call to the router contract.
enum AddressVersionStatus {
    UpToDate,
    DeployNeeded { create_needed: bool },
}

fn withdraw_to_near_args(recipient: &AccountId, amount: Yocto) -> Vec<u8> {
    let args = ethabi::encode(&[
        ethabi::Token::Bytes(recipient.as_bytes().to_vec()),
        ethabi::Token::Uint(U256::from(amount.as_u128())),
    ]);
    [&WITHDRAW_TO_NEAR_SELECTOR, args.as_slice()].concat()
}

#[cfg(test)]
mod tests {
    use aurora_engine_types::{account_id::AccountId, types::Yocto, U256};

    #[test]
    fn test_withdraw_to_near_encoding() {
        let recipient: AccountId = "some_account.near".parse().unwrap();
        let amount = Yocto::new(1332654);
        #[allow(deprecated)]
        let withdraw_function = ethabi::Function {
            name: "withdrawToNear".into(),
            inputs: vec![
                ethabi::Param {
                    name: "recipient".into(),
                    kind: ethabi::ParamType::Bytes,
                    internal_type: None,
                },
                ethabi::Param {
                    name: "amount".into(),
                    kind: ethabi::ParamType::Uint(256),
                    internal_type: None,
                },
            ],
            outputs: vec![],
            constant: None,
            state_mutability: ethabi::StateMutability::NonPayable,
        };
        let expected_tx_data = withdraw_function
            .encode_input(&[
                ethabi::Token::Bytes(recipient.as_bytes().to_vec()),
                ethabi::Token::Uint(U256::from(amount.as_u128())),
            ])
            .unwrap();

        assert_eq!(
            super::withdraw_to_near_args(&recipient, amount),
            expected_tx_data
        );
    }
}

'''
'''--- aurora-engine-2.8.1/etc/eth-contracts/.soliumrc.json ---
{
  "extends": "solium:all",
  "plugins": ["security"],
  "rules": {
    "mixedcase": "off",
    "error-reason": "off",
    "indentation": ["error", 4],
    "lbrace": "off",
    "linebreak-style": ["error", "unix"],
    "max-len": ["error", 139],
    "no-constant": ["error"],
    "no-empty-blocks": "off",
    "quotes": ["error", "double"],
    "uppercase": "off",
    "visibility-first": "error",
    "arg-overflow": ["error", 5],
    "function-order": "off",

    "security/enforce-explicit-visibility": ["error"],
    "security/no-block-members": ["off"],
    "security/no-inline-assembly": ["warning"]
  }
}

'''
'''--- aurora-engine-2.8.1/etc/eth-contracts/hardhat.config.js ---
require('@nomiclabs/hardhat-waffle');
require('solidity-coverage');
require('./tasks/storage');

/**
 * @type import('hardhat/config').HardhatUserConfig
 */
module.exports = {
    newStorageLayoutPath: './storageLayout',
    solidity: {
        version: '0.8.15',
        settings: {
            optimizer: {
                enabled: true,
                runs: 1000,
            },
            outputSelection: {
                '*': {
                    '*': ['storageLayout'],
                },
            },
        },
    },
};

'''
'''--- aurora-engine-2.8.1/etc/eth-contracts/main.js ---
const fs = require('fs');
const path = require('path');
const artifact = require(process.argv[2]);
if (!fs.existsSync('res')) {
    fs.mkdirSync('res');
}
const contractName = artifact.contractName;
fs.writeFileSync(path.join('res', contractName + '.hex'), artifact.bytecode);
fs.writeFileSync(path.join('res', contractName + '.bin'), Buffer.from(artifact.bytecode.substring(2), 'hex'));

'''
'''--- aurora-engine-2.8.1/etc/eth-contracts/package.json ---
{
  "name": "evm-erc20-token",
  "version": "0.1.0",
  "description": "ERC20 token implementation on EVM mapped from Native NEP-141",
  "dependencies": {
    "@openzeppelin/contracts": "^4.7.3"
  },
  "devDependencies": {
    "@nomiclabs/hardhat-ethers": "^2.0.6",
    "@nomiclabs/hardhat-waffle": "^2.0.3",
    "chai": "^4.3.6",
    "eslint": "^8.18.0",
    "eslint-config-standard": "^17.0.0",
    "eslint-plugin-import": "^2.26.0",
    "eslint-plugin-n": "^15.0.0",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-promise": "^6.0.0",
    "eth-gas-reporter": "^0.2.25",
    "ethereum-waffle": "^3.4.4",
    "ethers": "^5.6.9",
    "hardhat": "^2.12.4",
    "hardhat-storage-layout": "^0.1.6",
    "rainbow-bridge-lib": "^3.0.0",
    "solc": "0.8.15",
    "solidity-coverage": "^0.7.21",
    "solium": "^1.2.5",
    "typescript": ">=3.7.0"
  },
  "scripts": {
    "compile": "hardhat compile",
    "build": "yarn compile && node main.js ./artifacts/contracts/EvmErc20.sol/EvmErc20.json && node main.js ./artifacts/contracts/EvmErc20V2.sol/EvmErc20V2.json",
    "test": "yarn hardhat test",
    "coverage": "hardhat coverage",
    "lint:js": "eslint .",
    "lint:js:fix": "eslint . --fix",
    "lint:sol": "solium -d .",
    "lint:sol:fix": "solium -d . --fix",
    "lint": "yarn lint:js && yarn lint:sol",
    "lint:fix": "yarn lint:js:fix && yarn lint:sol:fix"
  }
}

'''
'''--- aurora-engine-2.8.1/etc/eth-contracts/tasks/storage.js ---
require('hardhat-storage-layout');
// eslint-disable-next-line no-undef
task('storageLayout', 'automatically generates the contract storage layout')
    .setAction(async () => {
        // eslint-disable-next-line no-undef
        await hre.storageLayout.export();
    });

module.exports = {};

'''
'''--- aurora-engine-2.8.1/etc/eth-contracts/test/EvmErc20.js ---
const { ethers } = require('hardhat');
const { expect } = require('chai');

describe('EthCustodian contract', () => {
    let user1;
    let deployerAccount;
    let adminAccount;

    let evmErc20Factory;
    let evmErc20Contract;

    const metadataName = 'EMPTY_TOKEN';
    const metadataSymbol = 'EMPTY_SYMBOL';
    const metadataDecimals = 0;

    beforeEach(async () => {
        [deployerAccount, user1] = await ethers.getSigners();

        // Make the deployer admin
        adminAccount = deployerAccount;

        evmErc20Factory = await ethers.getContractFactory('EvmErc20');
        evmErc20Contract = await evmErc20Factory
            .connect(adminAccount)
            .deploy(
                metadataName,
                metadataSymbol,
                metadataDecimals,
                adminAccount.address,
            );
    });

    describe('AdminControlled', () => {
        it('Only admin is allowed to update the metadata', async () => {
            const newMetadataName = 'NEW_CUSTOM_TOKEN';
            const newMetadataSymbol = 'NEW_CSTM';
            const newMetadataDecimals = 18;

            await expect(
                evmErc20Contract
                    .connect(user1)
                    .setMetadata(
                        newMetadataName,
                        newMetadataSymbol,
                        newMetadataDecimals,
                    ),
            )
                .to
                .be
                .reverted;

            expect(await evmErc20Contract.name()).to.equal(metadataName);
            expect(await evmErc20Contract.symbol()).to.equal(metadataSymbol);
            expect(await evmErc20Contract.decimals()).to.equal(metadataDecimals);

            await evmErc20Contract
                .connect(adminAccount)
                .setMetadata(
                    newMetadataName,
                    newMetadataSymbol,
                    newMetadataDecimals,
                );

            expect(await evmErc20Contract.name()).to.equal(newMetadataName);
            expect(await evmErc20Contract.symbol()).to.equal(newMetadataSymbol);
            expect(await evmErc20Contract.decimals()).to.equal(newMetadataDecimals);
        });
    });

    describe('Metadata', () => {
        it('Should match the deployed metadata', async () => {
            expect(await evmErc20Contract.name()).to.equal(metadataName);
            expect(await evmErc20Contract.symbol()).to.equal(metadataSymbol);
            expect(await evmErc20Contract.decimals()).to.equal(metadataDecimals);
        });

        it('Should update the metadata', async () => {
            const newMetadataName = 'NEW_CUSTOM_TOKEN';
            const newMetadataSymbol = 'NEW_CSTM';
            const newMetadataDecimals = 18;

            await evmErc20Contract
                .connect(adminAccount)
                .setMetadata(
                    newMetadataName,
                    newMetadataSymbol,
                    newMetadataDecimals,
                );

            expect(await evmErc20Contract.name()).to.equal(newMetadataName);
            expect(await evmErc20Contract.symbol()).to.equal(newMetadataSymbol);
            expect(await evmErc20Contract.decimals()).to.equal(newMetadataDecimals);
        });
    });
});

'''
'''--- aurora-engine-2.8.1/etc/tests/benchmark-contract/Cargo.toml ---
[package]
name = "benchmark_contract"
version = "1.0.0"
authors = ["Aurora <hello@aurora.dev>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
wee_alloc = { version = "0.4.5", default-features = false }

'''
'''--- aurora-engine-2.8.1/etc/tests/benchmark-contract/src/lib.rs ---
#![no_std]
#![feature(alloc_error_handler)]

extern crate alloc;

use alloc::format;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[panic_handler]
#[no_mangle]
pub unsafe fn panic(_info: &::core::panic::PanicInfo) -> ! {
    core::arch::wasm32::unreachable();
}

#[alloc_error_handler]
#[no_mangle]
pub unsafe fn on_alloc_error(_: core::alloc::Layout) -> ! {
    core::arch::wasm32::unreachable();
}

extern "C" {
    fn input(register_id: u64);
    fn register_len(register_id: u64) -> u64;
    fn read_register(register_id: u64, ptr: u64);
    fn log_utf8(len: u64, ptr: u64);
}

#[no_mangle]
pub unsafe extern "C" fn cpu_ram_soak_test() {
    let mut buf = [0u8; 100 * 1024];
    let len = buf.len();
    let loop_limit = read_input() as usize;
    let mut counter = 0;
    for i in 0..loop_limit {
        let j = (i * 7 + len / 2) % len;
        let k = (i * 3) % len;
        let tmp = buf[k];
        buf[k] = buf[j];
        buf[j] = tmp;
        counter += 1;
    }
    let msg = format!("Done {} iterations!", counter);
    log_utf8(msg.len() as u64, msg.as_ptr() as u64);
}

unsafe fn read_input() -> u32 {
    const REGISTER_ID: u64 = 1;
    input(REGISTER_ID);
    let input_len = register_len(REGISTER_ID);
    assert_eq!(input_len, 4);
    let buf = [0u8; 4];
    read_register(REGISTER_ID, buf.as_ptr() as u64);
    u32::from_le_bytes(buf)
}

'''
'''--- aurora-engine-2.8.1/etc/tests/fibonacci/Cargo.toml ---
[package]
name = "fibonacci_on_near"
version = "1.0.0"
authors = ["Aurora <hello@aurora.dev>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"

[dependencies]
near-sdk = "4.0.0"
serde = "1"

'''
'''--- aurora-engine-2.8.1/etc/tests/fibonacci/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, Gas, Promise, PromiseError};

const FIVE_TGAS: Gas = Gas(5_000_000_000_000);

#[near_bindgen]
#[derive(Default, BorshDeserialize, BorshSerialize)]
pub struct Fib;

#[derive(serde::Deserialize, serde::Serialize)]
pub struct FibAcc {
    a: U128,
    b: U128,
}

#[near_bindgen]
impl Fib {
    /// Seeds the Fibonacci recursion with the starting values (i.e. F[0] and F[1]).
    pub fn seed() -> FibAcc {
        FibAcc {
            a: U128(0),
            b: U128(1),
        }
    }

    /// Performs one step of the Fibonacci recursion.
    #[handle_result]
    pub fn accumulate(
        #[callback_result] acc: Result<FibAcc, PromiseError>,
    ) -> Result<FibAcc, &'static str> {
        match acc {
            Ok(acc) => Ok(FibAcc {
                a: acc.b,
                b: u128_sum(acc.a, acc.b),
            }),
            Err(_) => Err("Promise failed"),
        }
    }

    /// Computes the nth Fibonacci number using NEAR cross-contract calls to this contract.
    /// It begins with the seed, followed by `n` calls to the `accumulate` function.
    pub fn fib(n: u8) -> Promise {
        let account = env::current_account_id();
        let mut p =
            Promise::new(account.clone()).function_call("seed".into(), Vec::new(), 0, FIVE_TGAS);
        let mut n = n;
        while n > 0 {
            n -= 1;
            p = p.then(Promise::new(account.clone()).function_call(
                "accumulate".into(),
                Vec::new(),
                0,
                FIVE_TGAS,
            ))
        }
        p
    }

    /// An alternative version of `accumulate`. Rather then performing the recursion
    /// with a single input which contains the previous two Fibonacci values, this function
    /// takes the previous two terms as separate inputs. This gives an alternate way to compute
    /// Fibonacci numbers using this contract: `fib(n - 1).and(fib(n - 2)).then(sum)`.
    #[handle_result]
    pub fn sum(
        #[callback_result] fib_n_minus_1: Result<FibAcc, PromiseError>,
        #[callback_result] fib_n_minus_2: Result<FibAcc, PromiseError>,
    ) -> Result<FibAcc, String> {
        let FibAcc {
            a: fib_n_minus_1,
            b: fib_n,
        } = fib_n_minus_1.map_err(|e| format!("Promise 1 failed {:?}", e))?;
        let FibAcc {
            a: fib_n_minus_2,
            b: _,
        } = fib_n_minus_2.map_err(|e| format!("Promise 2 failed {:?}", e))?;
        Ok(FibAcc {
            a: u128_sum(fib_n_minus_1, fib_n_minus_2),
            b: u128_sum(fib_n_minus_1, fib_n),
        })
    }
}

fn u128_sum(x: U128, y: U128) -> U128 {
    U128(x.0 + y.0)
}

'''
'''--- aurora-engine-2.8.1/etc/tests/ft-receiver/Cargo.toml ---
[package]
name = "ft_receiver"
version = "1.0.0"
authors = ["Aurora <hello@aurora.dev>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"

'''
'''--- aurora-engine-2.8.1/etc/tests/ft-receiver/src/lib.rs ---
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128, ValidAccountId};
use near_sdk::{near_bindgen, log, PromiseOrValue};

/// Will happily take and NEP-141
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, Default)]
struct DummyFungibleTokenReceiver;

#[near_bindgen]
impl FungibleTokenReceiver for DummyFungibleTokenReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        log!("in {} tokens from @{} ft_on_transfer, msg = {}", amount.0, sender_id.as_ref(), msg);
        PromiseOrValue::Value(U128::from(0))
    }
}

'''
'''--- aurora-engine-2.8.1/etc/tests/self-contained-5bEgfRQ/Cargo.toml ---
[package]
name = "self-contained-5bEgfRQ"
version = "1.0.0"
authors = ["Aurora Labs <hello@aurora.dev>"]
edition = "2021"
description = "A wasm contract that reproduces a transaction from mainnet: https://explorer.mainnet.near.org/transactions/5bEgfRQ5TSJfN9XCqYkMr9cgBLToM7JmS1bNzKpDXJhT"
documentation = ""
readme = true
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "CC0-1.0"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
opt-level = "z"
debug = false
debug-assertions = false
overflow-checks = true
lto = true
panic = "abort"
incremental = false
codegen-units = 1
rpath = false

[profile.dev]
opt-level = "z"
debug = false
debug-assertions = true
overflow-checks = true
lto = true
panic = "abort"
incremental = false
codegen-units = 1
rpath = false

[dependencies]
borsh = { version = "0.9.3", default-features = false }
aurora-engine = { path = "../../../engine", default-features = false }
aurora-engine-sdk = { path = "../../../engine-sdk", default-features = false, features = ["contract"] }
aurora-engine-types = { path = "../../../engine-types", default-features = false }

'''
'''--- aurora-engine-2.8.1/etc/tests/self-contained-5bEgfRQ/src/lib.rs ---
#![no_std]

extern crate alloc;

mod promise;

use aurora_engine_sdk::{
    env,
    io::{self, IO},
    near_runtime,
};
use aurora_engine_types::types::gas::NearGas;
use aurora_engine_types::{BTreeMap, Cow, Vec, H256};
use borsh::{BorshDeserialize, BorshSerialize};

const STATE: &[u8; 52072] = include_bytes!("../state.bin");
const INPUT: &[u8] = &[
    248, 109, 129, 203, 132, 1, 201, 195, 128, 131, 102, 145, 183, 148, 63, 113, 89, 149, 100, 127,
    228, 77, 180, 84, 17, 187, 158, 129, 183, 161, 173, 90, 131, 135, 128, 132, 188, 103, 232, 135,
    132, 156, 138, 130, 199, 160, 85, 99, 19, 114, 59, 112, 86, 130, 51, 7, 173, 56, 131, 100, 65,
    4, 75, 55, 195, 220, 143, 211, 226, 205, 75, 118, 39, 64, 248, 101, 95, 156, 160, 1, 115, 246,
    9, 137, 244, 94, 244, 29, 39, 85, 229, 80, 165, 155, 165, 17, 193, 95, 61, 221, 8, 35, 85, 138,
    5, 237, 53, 68, 18, 30, 90,
];

#[no_mangle]
pub extern "C" fn run() {
    let local_env = env::Fixed {
        signer_account_id: "relay.aurora".parse().unwrap(),
        current_account_id: "aurora".parse().unwrap(),
        predecessor_account_id: "relay.aurora".parse().unwrap(),
        block_height: 64417403,
        block_timestamp: env::Timestamp::new(1651073772931594646),
        attached_deposit: 0,
        random_seed: H256([0u8; 32]),
        prepaid_gas: NearGas::new(300_000_000_000_000),
    };

    let state = BTreeMap::try_from_slice(STATE).unwrap();
    let in_mem_io = InMemIO::new(&state, INPUT);

    let engine_state = aurora_engine::engine::get_state(&in_mem_io).unwrap();
    let relayer_address = aurora_engine_sdk::types::near_account_to_evm_address(
        local_env.predecessor_account_id.as_bytes(),
    );
    let mut handler = promise::Noop;
    let result = aurora_engine::engine::submit(
        in_mem_io,
        &local_env,
        INPUT,
        engine_state,
        local_env.current_account_id.clone(),
        relayer_address,
        &mut handler,
    )
    .unwrap();

    let mut rt = near_runtime::Runtime;
    let return_bytes = result.try_to_vec().unwrap();
    rt.return_output(&return_bytes);
}

#[derive(Clone, Copy)]
struct InMemIO<'a> {
    kv_store: &'a BTreeMap<Vec<u8>, Vec<u8>>,
    input_bytes: &'a [u8],
}

impl<'a> InMemIO<'a> {
    fn new(kv_store: &'a BTreeMap<Vec<u8>, Vec<u8>>, input_bytes: &'a [u8]) -> Self {
        Self {
            kv_store,
            input_bytes,
        }
    }
}

struct InMemIOStorageValue<'a>(Cow<'a, [u8]>);

impl<'a> io::StorageIntermediate for InMemIOStorageValue<'a> {
    fn len(&self) -> usize {
        self.0.len()
    }

    fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    fn copy_to_slice(&self, buffer: &mut [u8]) {
        buffer.copy_from_slice(self.0.as_ref())
    }

    fn to_vec(&self) -> Vec<u8> {
        self.0.to_vec()
    }
}

impl<'a> IO for InMemIO<'a> {
    type StorageValue = InMemIOStorageValue<'a>;

    fn read_input(&self) -> Self::StorageValue {
        InMemIOStorageValue(Cow::Borrowed(self.input_bytes))
    }

    fn read_storage(&self, key: &[u8]) -> Option<Self::StorageValue> {
        self.kv_store
            .get(key)
            .map(|v| InMemIOStorageValue(Cow::Owned(v.clone())))
    }

    fn storage_has_key(&self, key: &[u8]) -> bool {
        self.kv_store.contains_key(key)
    }

    // The mutable methods are broken, but that's ok because we don't actually need to change this storage
    fn return_output(&mut self, _value: &[u8]) {}

    fn write_storage(&mut self, _key: &[u8], _value: &[u8]) -> Option<Self::StorageValue> {
        None
    }

    fn write_storage_direct(
        &mut self,
        _key: &[u8],
        _value: Self::StorageValue,
    ) -> Option<Self::StorageValue> {
        None
    }

    fn remove_storage(&mut self, _key: &[u8]) -> Option<Self::StorageValue> {
        None
    }
}

'''
'''--- aurora-engine-2.8.1/etc/tests/self-contained-5bEgfRQ/src/promise.rs ---
use aurora_engine_sdk::promise::{PromiseHandler, PromiseId};
use aurora_engine_types::parameters::{PromiseBatchAction, PromiseCreateArgs};
use aurora_engine_types::types::PromiseResult;

/// A promise handler which does nothing. Should only be used when promises can be safely ignored.
pub struct Noop;

impl PromiseHandler for Noop {
    fn promise_results_count(&self) -> u64 {
        0
    }

    fn promise_result(&self, _index: u64) -> Option<PromiseResult> {
        None
    }

    fn promise_create_call(&mut self, _args: &PromiseCreateArgs) -> PromiseId {
        PromiseId::new(0)
    }

    fn promise_attach_callback(
        &mut self,
        _base: PromiseId,
        _callback: &PromiseCreateArgs,
    ) -> PromiseId {
        PromiseId::new(0)
    }

    fn promise_create_batch(&mut self, _args: &PromiseBatchAction) -> PromiseId {
        PromiseId::new(0)
    }

    fn promise_return(&mut self, _promise: PromiseId) {}
}

'''
'''--- aurora-engine-2.8.1/etc/tests/state-migration-test/Cargo.toml ---
[package]
name = "aurora-engine-state-migration-test"
version = "1.0.0"
authors = ["NEAR <hello@near.org>"]
edition = "2021"
description = ""
documentation = ""
readme = true
homepage = "https://github.com/aurora-is-near/aurora-engine"
repository = "https://github.com/aurora-is-near/aurora-engine"
license = "CC0-1.0"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[profile.release]
opt-level = "z"
debug = false
debug-assertions = false
overflow-checks = true
lto = true
panic = "abort"
incremental = false
codegen-units = 1
rpath = false

[profile.dev]
opt-level = "z"
debug = false
debug-assertions = true
overflow-checks = true
lto = true
panic = "abort"
incremental = false
codegen-units = 1
rpath = false

[dependencies]
borsh = { version = "0.9.3", default-features = false }
aurora-engine = { path = "../../../engine", default-features = false }
aurora-engine-sdk = { path = "../../../engine-sdk", default-features = false, features = ["contract"] }
aurora-engine-types = { path = "../../../engine-types", default-features = false }

'''
'''--- aurora-engine-2.8.1/etc/tests/state-migration-test/src/lib.rs ---
#![no_std]

extern crate alloc;

use alloc::vec::Vec;
use aurora_engine::engine::{self, EngineState};
use aurora_engine_sdk::near_runtime::Runtime;
use aurora_engine_sdk::io::{IO, StorageIntermediate};
use aurora_engine_types::storage;
use borsh::{BorshDeserialize, BorshSerialize};

#[derive(BorshDeserialize, BorshSerialize)]
struct NewFancyState {
    old_state: EngineState,
    some_other_numbers: [u32; 7],
}

#[no_mangle]
pub extern "C" fn state_migration() {
    let mut io = Runtime;
    let old_state = match engine::get_state(&io) {
        Ok(state) => state,
        Err(e) => aurora_engine_sdk::panic_utf8(e.as_ref()),
    };

    let new_state = NewFancyState {
        old_state,
        some_other_numbers: [3, 1, 4, 1, 5, 9, 2],
    };

    io.write_storage(&state_key(), &new_state.try_to_vec().expect("ERR_SER"));
}

#[no_mangle]
pub extern "C" fn some_new_fancy_function() {
    let mut io = Runtime;
    let state = io.read_storage(&state_key())
        .and_then(|bytes| NewFancyState::try_from_slice(&bytes.to_vec()).ok())
        .unwrap();

    io.return_output(&state.some_other_numbers.try_to_vec().unwrap());
}

fn state_key() -> Vec<u8> {
    storage::bytes_to_key(storage::KeyPrefix::Config, b"STATE")
}

'''
'''--- aurora-engine-2.8.1/etc/tests/uniswap/package.json ---
{
  "name": "uniswap-sources",
  "version": "0.1.0",
  "description": "Depends on uniswap packages we need",
  "dependencies": {
    "@uniswap/v3-core": "^1.0.0",
    "@uniswap/v3-periphery": "^1.0.0"
  }
}

'''
'''--- aurora-engine-2.8.1/etc/xcc-router/Cargo.toml ---
[package]
name = "xcc_router"
version = "1.0.0"
authors = ["Aurora <hello@aurora.dev>"]
edition = "2021"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"

[dependencies]
aurora-engine-types = { path = "../../engine-types", default-features = false }
near-sdk = "4.0.0"

[features]
default = []
all-promise-actions = []

'''
'''--- aurora-engine-2.8.1/etc/xcc-router/src/lib.rs ---
use aurora_engine_types::parameters::{
    NearPromise, PromiseAction, PromiseArgs, PromiseCreateArgs, PromiseWithCallbackArgs,
    SimpleNearPromise,
};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::{U128, U64};
use near_sdk::BorshStorageKey;
use near_sdk::{env, near_bindgen, AccountId, Gas, PanicOnDefault, Promise, PromiseIndex};

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests;

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Version,
    Parent,
    Nonce,
    Map,
}

const CURRENT_VERSION: u32 = 1;

const ERR_ILLEGAL_CALLER: &str = "ERR_ILLEGAL_CALLER";
/// Gas cost estimated from mainnet data. Cost seems to consistently be 3 Tgas, but we add a
/// little more to be safe. Example:
/// https://explorer.mainnet.near.org/transactions/3U9SKbGKM3MchLa2hLTNuYLdErcEDneJGbGv1cHZXuvE#HsHabUdJ7DRJcseNa4GQTYwm8KtbB4mqsq2AUssJWWv6
const WNEAR_WITHDRAW_GAS: Gas = Gas(5_000_000_000_000);
/// Gas cost estimated from mainnet data. Example:
/// https://explorer.mainnet.near.org/transactions/5NbZ7SfrodNxeLcSkCmLAEdbZfbkk9cjqz3zSDwktKrk#D7un3c3Nxv7Ee3JpQSKiM97LbwCDFPbMo5iLoijGPXPM
const WNEAR_REGISTER_GAS: Gas = Gas(5_000_000_000_000);
/// Gas cost estimated from simulation tests.
const REFUND_GAS: Gas = Gas(5_000_000_000_000);
/// Registration amount computed from FT token source code, see
/// https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/fungible_token/core_impl.rs#L50
/// https://github.com/near/near-sdk-rs/blob/master/near-contract-standards/src/fungible_token/storage_impl.rs#L101
const WNEAR_REGISTER_AMOUNT: u128 = 1_250_000_000_000_000_000_000;
/// Must match arora_engine_precompiles::xcc::state::STORAGE_AMOUNT
const REFUND_AMOUNT: u128 = 2_000_000_000_000_000_000_000_000;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Router {
    /// The account id of the Aurora Engine instance that controls this router.
    parent: LazyOption<AccountId>,
    /// The version of the router contract that was last deployed
    version: LazyOption<u32>,
    /// A sequential id to keep track of how many scheduled promises this router has executed.
    /// This allows multiple promises to be scheduled before any of them are executed.
    nonce: LazyOption<u64>,
    /// The storage for the scheduled promises.
    scheduled_promises: LookupMap<u64, PromiseArgs>,
    /// Account ID for the wNEAR contract.
    wnear_account: AccountId,
}

#[near_bindgen]
impl Router {
    #[init(ignore_state)]
    pub fn initialize(wnear_account: AccountId, must_register: bool) -> Self {
        // The first time this function is called there is no state and the parent is set to be
        // the predecessor account id. In subsequent calls, only the original parent is allowed to
        // call this function. The idea is that the Create, Deploy and Initialize actions are done in a single
        // NEAR batch when a new router is deployed by the engine, so the caller will be the Aurora
        // engine instance that the user's address belongs to. If we update this contract and deploy
        // a new version of it, again the Deploy and Initialize actions will be done in a single batch
        // by the engine.
        let caller = env::predecessor_account_id();
        let mut parent = LazyOption::new(StorageKey::Parent, None);
        match parent.get() {
            None => {
                parent.set(&caller);
            }
            Some(parent) => {
                if caller != parent {
                    env::panic_str(ERR_ILLEGAL_CALLER);
                }
            }
        }

        if must_register {
            env::promise_create(
                wnear_account.clone(),
                "storage_deposit",
                b"{}",
                WNEAR_REGISTER_AMOUNT,
                WNEAR_REGISTER_GAS,
            );
        }

        let mut version = LazyOption::new(StorageKey::Version, None);
        if version.get().unwrap_or_default() != CURRENT_VERSION {
            // Future migrations would go here

            version.set(&CURRENT_VERSION);
        }

        let nonce = LazyOption::new(StorageKey::Nonce, None);
        let scheduled_promises = LookupMap::new(StorageKey::Map);
        Self {
            parent,
            version,
            nonce,
            scheduled_promises,
            wnear_account,
        }
    }

    /// This function can only be called by the parent account (i.e. Aurora engine) to ensure that
    /// no one can create calls on behalf of the user this router contract is deployed for.
    /// The engine only calls this function when the special precompile in the EVM for NEAR cross
    /// contract calls is used by the address associated with the sub-account this router contract
    /// is deployed at.
    pub fn execute(&self, #[serializer(borsh)] promise: PromiseArgs) {
        self.require_parent_caller();

        let promise_id = Router::promise_create(promise);
        env::promise_return(promise_id)
    }

    /// Similar security considerations here as for `execute`.
    pub fn schedule(&mut self, #[serializer(borsh)] promise: PromiseArgs) {
        self.require_parent_caller();

        let nonce = self.nonce.get().unwrap_or_default();
        self.scheduled_promises.insert(&nonce, &promise);
        self.nonce.set(&(nonce + 1));

        near_sdk::log!("Promise scheduled at nonce {}", nonce);
    }

    /// It is intentional that this function can be called by anyone (not just the parent).
    /// There is no security risk to allowing this function to be open because it can only
    /// act on promises that were created via `schedule`.
    #[payable]
    pub fn execute_scheduled(&mut self, nonce: U64) {
        let promise = match self.scheduled_promises.remove(&nonce.0) {
            Some(promise) => promise,
            None => env::panic_str("ERR_PROMISE_NOT_FOUND"),
        };

        let promise_id = Router::promise_create(promise);
        env::promise_return(promise_id)
    }

    /// The router will receive wNEAR deposits from its user. This function is to
    /// unwrap that wNEAR into NEAR. Additionally, this function will transfer some
    /// NEAR back to its parent, if needed. This transfer is done because the parent
    /// must cover the storage staking cost with the router account is first created,
    /// but the user ultimately is responsible to pay for it.
    pub fn unwrap_and_refund_storage(&self, amount: U128, refund_needed: bool) {
        self.require_parent_caller();

        let args = format!(r#"{{"amount": "{}"}}"#, amount.0);
        let id = env::promise_create(
            self.wnear_account.clone(),
            "near_withdraw",
            args.as_bytes(),
            1,
            WNEAR_WITHDRAW_GAS,
        );
        let final_id = if refund_needed {
            env::promise_then(
                id,
                env::current_account_id(),
                "send_refund",
                &[],
                0,
                REFUND_GAS,
            )
        } else {
            id
        };
        env::promise_return(final_id);
    }

    #[private]
    pub fn send_refund(&self) -> Promise {
        let parent = self
            .parent
            .get()
            .unwrap_or_else(|| env::panic_str("ERR_CONTRACT_NOT_INITIALIZED"));

        Promise::new(parent).transfer(REFUND_AMOUNT)
    }
}

impl Router {
    fn require_parent_caller(&self) {
        let caller = env::predecessor_account_id();
        let parent = self
            .parent
            .get()
            .unwrap_or_else(|| env::panic_str("ERR_CONTRACT_NOT_INITIALIZED"));
        if caller != parent {
            env::panic_str(ERR_ILLEGAL_CALLER)
        }
    }

    fn promise_create(promise: PromiseArgs) -> PromiseIndex {
        match promise {
            PromiseArgs::Create(call) => Self::base_promise_create(&call),
            PromiseArgs::Callback(cb) => Self::cb_promise_create(&cb),
            PromiseArgs::Recursive(p) => Self::recursive_promise_create(&p),
        }
    }

    fn cb_promise_create(promise: &PromiseWithCallbackArgs) -> PromiseIndex {
        let base = Self::base_promise_create(&promise.base);
        let promise = &promise.callback;

        env::promise_then(
            base,
            near_sdk::AccountId::new_unchecked(promise.target_account_id.to_string()),
            promise.method.as_str(),
            &promise.args,
            promise.attached_balance.as_u128(),
            promise.attached_gas.as_u64().into(),
        )
    }

    fn base_promise_create(promise: &PromiseCreateArgs) -> PromiseIndex {
        env::promise_create(
            near_sdk::AccountId::new_unchecked(promise.target_account_id.to_string()),
            promise.method.as_str(),
            &promise.args,
            promise.attached_balance.as_u128(),
            promise.attached_gas.as_u64().into(),
        )
    }

    fn recursive_promise_create(promise: &NearPromise) -> PromiseIndex {
        match promise {
            NearPromise::Simple(x) => match x {
                SimpleNearPromise::Create(call) => Self::base_promise_create(call),
                SimpleNearPromise::Batch(batch) => {
                    let target =
                        near_sdk::AccountId::new_unchecked(batch.target_account_id.to_string());
                    let id = env::promise_batch_create(&target);
                    Self::add_batch_actions(id, &batch.actions);
                    id
                }
            },
            NearPromise::Then { base, callback } => {
                let base_index = Self::recursive_promise_create(base);
                match callback {
                    SimpleNearPromise::Create(call) => env::promise_then(
                        base_index,
                        near_sdk::AccountId::new_unchecked(call.target_account_id.to_string()),
                        call.method.as_str(),
                        &call.args,
                        call.attached_balance.as_u128(),
                        call.attached_gas.as_u64().into(),
                    ),
                    SimpleNearPromise::Batch(batch) => {
                        let target =
                            near_sdk::AccountId::new_unchecked(batch.target_account_id.to_string());
                        let id = env::promise_batch_then(base_index, &target);
                        Self::add_batch_actions(id, &batch.actions);
                        id
                    }
                }
            }
            NearPromise::And(promises) => {
                let indices: Vec<PromiseIndex> = promises
                    .iter()
                    .map(Self::recursive_promise_create)
                    .collect();
                env::promise_and(&indices)
            }
        }
    }

    #[cfg(not(feature = "all-promise-actions"))]
    fn add_batch_actions(_id: PromiseIndex, _actions: &[PromiseAction]) {
        unimplemented!("NEAR batch transactions are not supported. Please file an issue at https://github.com/aurora-is-near/aurora-engine")
    }

    #[cfg(feature = "all-promise-actions")]
    fn add_batch_actions(id: PromiseIndex, actions: &[PromiseAction]) {
        for action in actions.iter() {
            match action {
                PromiseAction::CreateAccount => env::promise_batch_action_create_account(id),
                PromiseAction::Transfer { amount } => {
                    env::promise_batch_action_transfer(id, amount.as_u128())
                }
                PromiseAction::DeployContract { code } => {
                    env::promise_batch_action_deploy_contract(id, code)
                }
                PromiseAction::FunctionCall {
                    name,
                    args,
                    attached_yocto,
                    gas,
                } => env::promise_batch_action_function_call(
                    id,
                    name,
                    args,
                    attached_yocto.as_u128(),
                    gas.as_u64().into(),
                ),
                PromiseAction::Stake { amount, public_key } => {
                    env::promise_batch_action_stake(id, amount.as_u128(), &to_sdk_pk(public_key))
                }
                PromiseAction::AddFullAccessKey { public_key, nonce } => {
                    env::promise_batch_action_add_key_with_full_access(
                        id,
                        &to_sdk_pk(public_key),
                        *nonce,
                    )
                }
                PromiseAction::AddFunctionCallKey {
                    public_key,
                    nonce,
                    allowance,
                    receiver_id,
                    function_names,
                } => {
                    let receiver_id = near_sdk::AccountId::new_unchecked(receiver_id.to_string());
                    env::promise_batch_action_add_key_with_function_call(
                        id,
                        &to_sdk_pk(public_key),
                        *nonce,
                        allowance.as_u128(),
                        &receiver_id,
                        function_names,
                    )
                }
                PromiseAction::DeleteKey { public_key } => {
                    env::promise_batch_action_delete_key(id, &to_sdk_pk(public_key))
                }
                PromiseAction::DeleteAccount { beneficiary_id } => {
                    let beneficiary_id =
                        near_sdk::AccountId::new_unchecked(beneficiary_id.to_string());
                    env::promise_batch_action_delete_account(id, &beneficiary_id)
                }
            }
        }
    }
}

#[cfg(feature = "all-promise-actions")]
fn to_sdk_pk(key: &aurora_engine_types::parameters::NearPublicKey) -> near_sdk::PublicKey {
    let (curve_type, key_bytes): (near_sdk::CurveType, &[u8]) = match key {
        aurora_engine_types::parameters::NearPublicKey::Ed25519(bytes) => {
            (near_sdk::CurveType::ED25519, bytes)
        }
        aurora_engine_types::parameters::NearPublicKey::Secp256k1(bytes) => {
            (near_sdk::CurveType::SECP256K1, bytes)
        }
    };
    let mut data = Vec::with_capacity(1 + key_bytes.len());
    data.push(curve_type as u8);
    data.extend_from_slice(key_bytes);

    // Unwrap should be safe because we only encode valid public keys
    data.try_into().unwrap()
}

'''
'''--- aurora-engine-2.8.1/etc/xcc-router/src/tests.rs ---
use super::Router;
use aurora_engine_types::parameters::{PromiseArgs, PromiseCreateArgs, PromiseWithCallbackArgs};
use aurora_engine_types::types::{NearGas, Yocto};
use near_sdk::mock::VmAction;
use near_sdk::test_utils::test_env::{alice, bob, carol};
use near_sdk::test_utils::{self, VMContextBuilder};
use near_sdk::testing_env;

const WNEAR_ACCOUNT: &str = "wrap.near";

#[test]
fn test_initialize() {
    let (parent, contract) = create_contract();

    assert_eq!(contract.parent.get().unwrap(), parent);
}

/// `initialize` should be able to be called multiple times without resetting the state.
#[test]
fn test_reinitialize() {
    let (_parent, mut contract) = create_contract();

    let nonce = 8;
    contract.nonce.set(&nonce);
    drop(contract);

    let contract = Router::initialize(WNEAR_ACCOUNT.parse().unwrap(), false);
    assert_eq!(contract.nonce.get().unwrap(), nonce);
}

// If an account other than the parent calls `initialize` it panics.
#[test]
#[should_panic]
fn test_reinitialize_wrong_caller() {
    let (parent, contract) = create_contract();

    assert_eq!(contract.parent.get().unwrap(), parent);
    drop(contract);

    testing_env!(VMContextBuilder::new()
        .predecessor_account_id(bob())
        .build());
    let _contract = Router::initialize(WNEAR_ACCOUNT.parse().unwrap(), false);
}

#[test]
#[should_panic]
fn test_execute_wrong_caller() {
    let (_parent, contract) = create_contract();

    let promise = PromiseCreateArgs {
        target_account_id: bob().as_str().parse().unwrap(),
        method: "some_method".into(),
        args: b"hello_world".to_vec(),
        attached_balance: Yocto::new(56),
        attached_gas: NearGas::new(100_000_000_000_000),
    };

    testing_env!(VMContextBuilder::new()
        .predecessor_account_id(bob())
        .build());
    contract.execute(PromiseArgs::Create(promise));
}

#[test]
fn test_execute() {
    let (_parent, contract) = create_contract();

    let promise = PromiseCreateArgs {
        target_account_id: bob().as_str().parse().unwrap(),
        method: "some_method".into(),
        args: b"hello_world".to_vec(),
        attached_balance: Yocto::new(56),
        attached_gas: NearGas::new(100_000_000_000_000),
    };

    contract.execute(PromiseArgs::Create(promise.clone()));

    let mut receipts = test_utils::get_created_receipts();
    assert_eq!(receipts.len(), 1);
    let receipt = receipts.pop().unwrap();
    assert_eq!(
        receipt.receiver_id.as_str(),
        promise.target_account_id.as_ref()
    );

    validate_function_call_action(&receipt.actions, promise);
}

#[test]
fn test_execute_callback() {
    let (_parent, contract) = create_contract();

    let promise = PromiseWithCallbackArgs {
        base: PromiseCreateArgs {
            target_account_id: bob().as_str().parse().unwrap(),
            method: "some_method".into(),
            args: b"hello_world".to_vec(),
            attached_balance: Yocto::new(5678),
            attached_gas: NearGas::new(100_000_000_000_000),
        },
        callback: PromiseCreateArgs {
            target_account_id: carol().as_str().parse().unwrap(),
            method: "another_method".into(),
            args: b"goodbye_world".to_vec(),
            attached_balance: Yocto::new(567),
            attached_gas: NearGas::new(10_000_000_000_000),
        },
    };

    contract.execute(PromiseArgs::Callback(promise.clone()));

    let receipts = test_utils::get_created_receipts();
    assert_eq!(receipts.len(), 2);
    let base = &receipts[0];
    let callback = &receipts[1];

    validate_function_call_action(&base.actions, promise.base);
    validate_function_call_action(&callback.actions, promise.callback);
}

#[test]
#[should_panic]
fn test_schedule_wrong_caller() {
    let (_parent, mut contract) = create_contract();

    let promise = PromiseCreateArgs {
        target_account_id: bob().as_str().parse().unwrap(),
        method: "some_method".into(),
        args: b"hello_world".to_vec(),
        attached_balance: Yocto::new(56),
        attached_gas: NearGas::new(100_000_000_000_000),
    };

    testing_env!(VMContextBuilder::new()
        .predecessor_account_id(bob())
        .build());
    contract.schedule(PromiseArgs::Create(promise));
}

#[test]
fn test_schedule_and_execute() {
    let (_parent, mut contract) = create_contract();

    let promise = PromiseCreateArgs {
        target_account_id: bob().as_str().parse().unwrap(),
        method: "some_method".into(),
        args: b"hello_world".to_vec(),
        attached_balance: Yocto::new(56),
        attached_gas: NearGas::new(100_000_000_000_000),
    };

    contract.schedule(PromiseArgs::Create(promise.clone()));

    // no promise actually create yet
    let receipts = test_utils::get_created_receipts();
    assert!(receipts.is_empty());

    // promise stored and nonce incremented instead
    assert_eq!(contract.nonce.get().unwrap(), 1);
    let stored_promise = match contract.scheduled_promises.get(&0) {
        Some(PromiseArgs::Create(promise)) => promise,
        _ => unreachable!(),
    };
    assert_eq!(stored_promise, promise);

    // promise executed after calling `execute_scheduled`
    // anyone can call this function
    testing_env!(VMContextBuilder::new()
        .predecessor_account_id(bob())
        .build());
    contract.execute_scheduled(0.into());

    assert_eq!(contract.nonce.get().unwrap(), 1);
    assert!(!contract.scheduled_promises.contains_key(&0));

    let mut receipts = test_utils::get_created_receipts();
    assert_eq!(receipts.len(), 1);
    let receipt = receipts.pop().unwrap();
    assert_eq!(
        receipt.receiver_id.as_str(),
        promise.target_account_id.as_ref()
    );
    validate_function_call_action(&receipt.actions, promise);
}

fn validate_function_call_action(actions: &[VmAction], promise: PromiseCreateArgs) {
    assert_eq!(actions.len(), 1);
    let action = &actions[0];

    assert_eq!(
        *action,
        VmAction::FunctionCall {
            function_name: promise.method,
            args: promise.args,
            gas: promise.attached_gas.as_u64().into(),
            deposit: promise.attached_balance.as_u128()
        }
    );
}

fn create_contract() -> (near_sdk::AccountId, Router) {
    let parent = alice();
    testing_env!(VMContextBuilder::new()
        .current_account_id(format!("some_address.{}", parent).try_into().unwrap())
        .predecessor_account_id(parent.clone())
        .build());
    let contract = Router::initialize(WNEAR_ACCOUNT.parse().unwrap(), false);

    (parent, contract)
}

'''
'''--- aurora-engine-2.8.1/scripts/docker-entrypoint.sh ---
#!/bin/bash
cargo install --no-default-features --force cargo-make
cargo make --profile "$1" build-docker-inner

'''
'''--- aurora-engine-2.8.1/scripts/verify_evm_erc20.sh ---
rm etc/eth-contracts/res/*.bin etc/eth-contracts/res/*.hex
cargo make build-contracts
if [[ $(git diff etc/eth-contracts/res/) ]]; then
	echo "Error EvmErc20.bin not up to date"
	exit 1
else
	exit 0
fi

'''