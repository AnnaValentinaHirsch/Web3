*GitHub Repository "21st-Athena/Neko-Staking-Parcel"*

'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react'],
}

'''
'''--- src/App.js ---
import "regenerator-runtime/runtime";
import React from "react";
import { login, logout } from "./utils";
import "./global.css";

import getConfig from "./config";
const { networkId } = getConfig(process.env.NODE_ENV || "development");

export default function App() {
	// use React Hooks to store greeting in component state
	const [greeting, set_greeting] = React.useState();

	// when the user has not yet interacted with the form, disable the button
	const [buttonDisabled, setButtonDisabled] = React.useState(true);

	// after submitting the form, we want to show Notification
	const [showNotification, setShowNotification] = React.useState(false);

	// The useEffect hook can be used to fire side-effects during render
	// Learn more: https://reactjs.org/docs/hooks-intro.html
	React.useEffect(
		() => {
			// in this case, we only care to query the contract when signed in
			if (window.walletConnection.isSignedIn()) {
				// window.contract is set by initContract in index.js
				window.contract.get_greeting({ account_id: window.accountId }).then((greetingFromContract) => {
					set_greeting(greetingFromContract);
				});
			}
		},

		// The second argument to useEffect tells React when to re-run the effect
		// Use an empty array to specify "only run on first render"
		// This works because signing into NEAR Wallet reloads the page
		[]
	);

	// if not signed in, return early with sign-in prompt
	if (!window.walletConnection.isSignedIn()) {
		return (
			<main>
				<h1>Welcome to Neko Stake!</h1>
				<p>
					To make use of the NEAR blockchain, you need to sign in. The button below will sign you in using NEAR Wallet.
				</p>
				<p>
					By default, when your app runs in "development" mode, it connects to a test network ("testnet") wallet. This
					works just like the main network ("mainnet") wallet, but the NEAR Tokens on testnet aren't convertible to
					other currencies – they're just for testing!
				</p>
				<p>Go ahead and click the button below to try it out:</p>
				<p style={{ textAlign: "center", marginTop: "2.5em" }}>
					<button onClick={login}>Sign in</button>
				</p>
			</main>
		);
	}

	return (
		// use React Fragment, <>, to avoid wrapping elements in unnecessary divs
		<>
			<button className="link" style={{ float: "right" }} onClick={logout}>
				Sign out
			</button>
			<main>
				<h1>
					<label
						htmlFor="greeting"
						style={{
							color: "var(--secondary)",
							borderBottom: "2px solid var(--secondary)",
						}}
					>
						{greeting}
					</label>
					{" " /* React trims whitespace around tags; insert literal space character when needed */}
					{window.accountId}!
				</h1>
				<form
					onSubmit={async (event) => {
						event.preventDefault();

						// get elements from the form using their id attribute
						const { fieldset, greeting } = event.target.elements;

						// hold onto new user-entered value from React's SynthenticEvent for use after `await` call
						const newGreeting = greeting.value;

						// disable the form while the value gets updated on-chain
						fieldset.disabled = true;

						try {
							// make an update call to the smart contract
							await window.contract.set_greeting({
								// pass the value that the user entered in the greeting field
								message: newGreeting,
							});
						} catch (e) {
							alert(
								"Something went wrong! " +
									"Maybe you need to sign out and back in? " +
									"Check your browser console for more info."
							);
							throw e;
						} finally {
							// re-enable the form, whether the call succeeded or failed
							fieldset.disabled = false;
						}

						// update local `greeting` variable to match persisted value
						set_greeting(newGreeting);

						// show Notification
						setShowNotification(true);

						// remove Notification again after css animation completes
						// this allows it to be shown again next time the form is submitted
						setTimeout(() => {
							setShowNotification(false);
						}, 11000);
					}}
				>
					<fieldset id="fieldset">
						<label
							htmlFor="greeting"
							style={{
								display: "block",
								color: "var(--gray)",
								marginBottom: "0.5em",
							}}
						>
							Change greeting
						</label>
						<div style={{ display: "flex" }}>
							<input
								autoComplete="off"
								defaultValue={greeting}
								id="greeting"
								onChange={(e) => setButtonDisabled(e.target.value === greeting)}
								style={{ flex: 1 }}
							/>
							<button disabled={buttonDisabled} style={{ borderRadius: "0 5px 5px 0" }}>
								Save
							</button>
						</div>
					</fieldset>
				</form>
				<p>Look at that! A Hello World app! This greeting is stored on the NEAR blockchain. Check it out:</p>
				<ol>
					<li>
						Look in <code>src/App.js</code> and <code>src/utils.js</code> – you'll see <code>get_greeting</code> and{" "}
						<code>set_greeting</code> being called on <code>contract</code>. What's this?
					</li>
					<li>
						Ultimately, this <code>contract</code> code is defined in <code>assembly/main.ts</code> – this is the source
						code for your{" "}
						<a target="_blank" rel="noreferrer" href="https://docs.near.org/docs/develop/contracts/overview">
							smart contract
						</a>
						.
					</li>
					<li>
						When you run <code>yarn dev</code>, the code in <code>assembly/main.ts</code> gets deployed to the NEAR
						testnet. You can see how this happens by looking in <code>package.json</code> at the <code>scripts</code>{" "}
						section to find the <code>dev</code> command.
					</li>
				</ol>
				<hr />
				<p>
					To keep learning, check out{" "}
					<a target="_blank" rel="noreferrer" href="https://docs.near.org">
						the NEAR docs
					</a>{" "}
					or look through some{" "}
					<a target="_blank" rel="noreferrer" href="https://examples.near.org">
						example apps
					</a>
					.
				</p>
			</main>
			{showNotification && <Notification />}
		</>
	);
}

// this component gets rendered by App after the form is submitted
function Notification() {
	const urlPrefix = `https://explorer.${networkId}.near.org/accounts`;
	return (
		<aside>
			<a target="_blank" rel="noreferrer" href={`${urlPrefix}/${window.accountId}`}>
				{window.accountId}
			</a>
			{" " /* React trims whitespace around tags; insert literal space character when needed */}
			called method: 'set_greeting' in contract:{" "}
			<a target="_blank" rel="noreferrer" href={`${urlPrefix}/${window.contract.contractId}`}>
				{window.contract.contractId}
			</a>
			<footer>
				<div>✔ Succeeded</div>
				<div>Just now</div>
			</footer>
		</aside>
	);
}

'''
'''--- src/__mocks__/fileMock.js ---
// NOTE: This is used to mock resource imports in JSX for tests
module.exports = '' 

'''
'''--- src/components/Header.js ---
import React from "react";
import ReactDOM from "react-dom";
import "../styles/header.scss";
import { Image, Stack } from "react-bootstrap";
import FallinesLogo from "../assets/fellines-logo.png";
import { login, logout } from "../utils.js";
import { Navbar, Container, Nav, NavDropdown } from "react-bootstrap";
import { Button, styled } from "@mui/material";
const StyledButton = styled(Button)`
	background-color: #7e181d;
	color: #fdb55a;
	width: 180px;
	height: 60px;
	padding: 6px 18px;
	font-size: 18px;
	border: 3px solid #f9ba55;
	&:hover {
		color: #fff;
		border: 3px solid #f9ba55;
		background-color: #7e181d;
	}
	&:focus {
		background-color: #7e181d;
		border: 3px solid #f9ba55;
	}
	border-radius: 0px;
`;
const Header = (props) => {
	let connectionButton;
	if (window.accountId == null || typeof window.accountId === "undefined" || accountId == "") {
		connectionButton = (
			<Nav.Link href="/#" style={{ color: "gold" }}>
				<StyledButton className="bold-font btn-transparent header_connect_btn" onClick={() => login()}>
					Connect Wallet
				</StyledButton>
			</Nav.Link>
		);
	} else {
		connectionButton = (
			<Nav.Link href="/#" style={{ color: "gold" }}>
				<StyledButton className="btn btn-danger" onClick={() => logout()}>
					{window.accountId}
				</StyledButton>
			</Nav.Link>
		);
	}

	return (
		<Navbar
			expand="lg"
			className="shadow"
			style={{
				display: "flex",
				background: "rgba(18,18,18,0.5)",
				alignItems: "center",
				width: "100%",
				backgroundImage: ` url(${require("../assets/navbg.png")})`,
				backgroundSize: "cover",
				textAlign: `center`,
			}}
		>
			<Container>
				<Navbar.Brand href="#home">
					<Image src={FallinesLogo} className="logo-header" />
				</Navbar.Brand>
				<Navbar.Toggle aria-controls="basic-navbar-nav" />
				<Navbar.Collapse id="basic-navbar-nav">
					<Nav className="me-auto">
						<Nav.Link href="/" style={{ color: "gold" }}>
							<StyledButton>Home</StyledButton>
						</Nav.Link>
					</Nav>
					<Nav>
						<Nav.Link href="/nekostake" style={{ color: "gold" }}>
							<StyledButton>
								NEKO Stake
							</StyledButton>
						</Nav.Link>
						<Nav.Link href="/nft" style={{ color: "gold" }}>
							<StyledButton>NFT Stake</StyledButton>
						</Nav.Link>
						<Nav.Link href="/landingpage" stype={{ color: "gold" }}>
							<StyledButton>Landing Page</StyledButton>
						</Nav.Link>
						{connectionButton}
					</Nav>
				</Navbar.Collapse>
			</Container>
		</Navbar>
	);
};

export default Header;

'''
'''--- src/components/LandingPage.js ---
import { utils } from "near-api-js";
import React, { useEffect } from "react";

import Modal from "react-modal";
import { Image, Stack } from "react-bootstrap";
import { Box, Button, Container, Grid, IconButton, Typography, styled, Input, TextField, spacing } from "@mui/material";
import { toast } from "react-toastify";
import { async } from "regenerator-runtime";
import { GifPlayer } from "react-gif-player";
import { gifFrames } from "gif-frames";
import delay from "delay";

import CookieStatic from "../assets/cookie_static.png";
import CookieGif from "../assets/cookie_gif.gif";
import Nekobackground from "../assets/Background_modal.png";
import NekoStakeBtnImg from "../assets/facotry_transparent_2.png";
import AnimEntry from "../assets/anim/ff1_exit.gif";
import AnimDance from "../assets/anim/ff1_dance.gif";
import AnimReturn from "../assets/anim/ff1_return.gif";
import AnimFianlReturn from "../assets/anim/ff1_return-final.gif";

const NORMAL_GAS = "150000000000000";
const StyledButton = styled(Button)`
	background-color: #7e181d;
	color: #fdb55a;
	width: 180px;
	height: 60px;
	padding: 6px 18px;
	font-size: 18px;
	border: 3px solid #f9ba55;
	&:hover {
		color: #fff;
		border: 3px solid #f9ba55;
	}
	&:focus {
		background-color: #7e181d;
		border: 3px solid #f9ba55;
	}
	border-radius: 0px;
`;

export default function Landing() {
	const [totalStaked, setTotalStaked] = React.useState(0);
	const [nekoBalance, setNekoBalance] = React.useState(0);
	const [accReward, setAccReward] = React.useState(0);
	const [lastUpdate, setLastUpdate] = React.useState(0);
	const [cookieBalance, setCookieBalance] = React.useState(0);
	const [contractBalance, setContractBalance] = React.useState(0);
	const [isRegisteredCookie, setIsRegisteredCookie] = React.useState(false);
	const [isLoading, setIsLoading] = React.useState(false);
    const {isHOver, setIsHOver} = React.useState(false);
    const [animState, setAnimState] = React.useState(0);
	const amountRef = React.useRef(null);
	const stakeRef = React.useRef(null);
	const unstakeRef = React.useRef(null);
	const bakeRef = React.useRef(null);
	const unBakeRef = React.useRef(null);
    
    const [modalIsOpen, setIsOpen] = React.useState(false);

    const LPBackground = () => {
        return <img 
                src={Nekobackground}
                style={{
                    width: "100%",
                    height: "100%"
                }}
            />
    }
    const handleOpenModal = () => {
        setIsOpen(true);
    }
    const handleCloseModal = () => {
        setIsOpen(false);
    }
	React.useEffect(() => {
		if (!window.accountId) return;
		window.contract_factory
			.storage_balance_of({ account_id: window.accountId })
			.then((res) => {
				setIsRegisteredCookie(res);
			})
			.catch((e) => {
				console.log(e.message);
			});
		window.contract_factory
			.ft_balance_of({ account_id: window.accountId })
			.then((res) => {
				setCookieBalance(res);
			})
			.catch((e) => {
				console.log(e.message);
			});
		window.contract.ft_balance_of({ account_id: window.accountId }).then((res) => {
			setNekoBalance(res);
		});
		window.contract_factory.ft_balance_of({ account_id: process.env.REACT_APP_NEKO_CONTRACT_ID }).then((res) => {
			setContractBalance(res);
		});
		getStakeData();

	}, [window.accountId]);

    useEffect(
        () => {
            const checkAnimState = async() => {
                if (animState == 1) {
                    await delay(3000);
                    setAnimState(2);
                } else if (animState == 3) {
                    await delay(2800);
                    setAnimState(0);
                }
            };

            checkAnimState();
        },
        [ animState ]
    );
	const getStakeData = async () => {
		try {
			const stakeData = await window.contract.get_stake_by_id({ id: window.accountId });
			setTotalStaked(stakeData.total_stake);
			setAccReward(stakeData.acc_reward);
			setLastUpdate(new Date(stakeData.last_update_time / 1000000).toLocaleString());
			console.log(stakeData);
		} catch (e) {
			console.error(e.message);
		}
	};
	const updateStakeData = async () => {
		setIsLoading(true);
		try {
			await toast.promise(window.contract.update_stake_data({ account_id: window.accountId }), {
				pending: "Loading",
				success: "success",
			});
			getStakeData();
		} catch (e) {
			toast.error(e.message);
		}
		setIsLoading(false);
	};
	const openCookieAccount = async () => {
		await toast.promise(
			window.contract_factory.storage_deposit(
				{ account_id: window.accountId },
				"300000000000000",
				utils.format.parseNearAmount("0.01")
			),
			{
				pending: "Opening...",
				error: `${accountId == "" ? "Connect your Wallet First" : "Error..."}`,
			}
		);
		getStakeData();
	};
	const ftMint = async () => {
		setIsLoading(true);
		console.log(amountRef.current.value);
		try {
			toast.promise(
				window.contract.ft_mint({
					to: window.accountId,
					amount: parseInt(amountRef.current.value),
				}),
				{ pending: "Minting Test Neko", success: "Minted Test Neko", error: "Error Minting Test Neko" }
			);
		} catch (e) {
			toast.error(e.message);
		}
		setIsLoading(false);
	};
	const stake = async () => {
		setIsLoading(true);
		console.log(stakeRef.current.value);
		if (cookieBalance < parseInt(stakeRef.current.value)) {
			toast.error("You don't have enough Cookie!");
			return;
		}
		try {
			await toast.promise(
				window.contract.stake(
					{
						amount: parseInt(stakeRef.current.value),
					},
					"180000000000000",
					1
				),
				{ pending: "Staking Test Neko", success: "Staked Test Neko", error: "Error Staking Test Neko" }
			);
		} catch (e) {
			toast.error(e.message);
		}

		setIsLoading(false);
	};
	const unstake = async () => {
		setIsLoading(true);
		
		if (totalStaked < unstakeRef.current.value) {
			toast.error("You don't have enough staked Cookie!");
			return;
		}

		try {
			await toast.promise(
				window.contract.unstake(
					{
						amount: parseInt(unstakeRef.current.value),
					},
					"180000000000000",
					1
				),
				{ pending: "Unstaking Neko", success: "Unstaked  Neko", error: "Error Unstaking  Neko" }
			);
		} catch (e) {
			toast.error(e.message);
		}

		setIsLoading(false);
	};
	const claimReward = async () => {
		setIsLoading(true);
		try {
			await toast.promise(
				window.contract.claim_neko(
					{
						account_id: window.accountId,
					},
					"300000000000000",
					1
				),
				{ pending: "Claiming Reward", success: "Claimed Reward", error: "Error Claiming Reward" }
			);
		} catch (e) {
			toast.error(e.message);
		}

		setIsLoading(false);
	};
	const bake = async () => {
		setIsLoading(true);
		console.log(nekoBalance, bakeRef.current.value);
		if (nekoBalance < bakeRef.current.value) {
			toast.error("You don't have enough Neko!");
			return;
		}
		try {
			await toast.promise(
				window.contract.bake({ args: { amount: parseInt(bakeRef.current.value) }, amount: 2, gas: NORMAL_GAS }),
				{
					pending: "Baking Neko",
					success: "Baked Neko",
					error: "Error Baking Neko",
				}
			);
		} catch (e) {
			console.log(e.message);
		}
	};
	const unbake = async () => {
		setIsLoading(true);
		
		if (cookieBalance < parseInt(unBakeRef.current.value)) {
			toast.error("You don't have enough Cookie!");
			return;
		}
		try {
			await toast.promise(
				window.contract.unbake({ args: { amount: parseInt(unBakeRef.current.value) }, amount: 1, gas: NORMAL_GAS }),
				{ pending: "Unbaking Neko", success: "Unbaked Neko", error: "Error Unbaking Neko" }
			);
		} catch (e) {
			console.log(e.message);
		}
	};
    const NekoStakeBtnModal = () => {
        const moveToEntryAnim = () => {
            setAnimState(1);
        };
        const moveToReturnAnim = () => {
            setAnimState(3);
        };
        return <div>
            {/* <GifPlayer gif={ChangeNekoStakeBtnImg} autoplay={true} /> */}
            { animState == 0 ? (
                <Image
                    onClick={ handleOpenModal }
                    src={`${NekoStakeBtnImg}`}
                    onMouseEnter={moveToEntryAnim}
                    className="nekoStakeImg"
                    style={{
                        position: "absolute",
                        top: "65%",
                        left: "2%",
                    }}
                    >
                </Image>
            ) : animState == 1 ? (
                <Image
                    onClick={ handleOpenModal }
                    src={`${AnimEntry}`}
                    className="nekoStakeImg"
                    onMouseLeave={moveToReturnAnim}
                    style={{
                        position: "absolute",
                        top: "65%",
                        left: "2%",
                    }}
                >
                </Image>
            ) : animState == 2 ? (
                <Image
                    onClick={ handleOpenModal }
                    src={`${AnimDance}`}
                    onMouseLeave={moveToReturnAnim}
                    className="nekoStakeImg"
                    style={{
                        position: "absolute",
                        top: "65%",
                        left: "2%",
                    }}
                ></Image>
            ) : (
                <Image
                    onClick={ handleOpenModal }
                    src={`${AnimReturn}`}
                    className="nekoStakeImg"
                    style={{
                        position: "absolute",
                        top: "65%",
                        left: "2%",
                    }}
                ></Image>
            )}
            <Modal
                isOpen={modalIsOpen}
                contentLabel="Minimal Modal Example"
            >
                <Box sx={{ mt: 5 }}>
                    <div>
                        <p style={{ textAlign: "center" }}>Cookie in stock(Vault):{contractBalance} [Dev Only]</p>
                    </div>
                    {isRegisteredCookie ? (
                        <Box>
                            <Grid container spacing={2} justifyContent="center">
                                <Grid item xs={12} sm={12} sx={{ textAlign: "center" }}>
                                    <Grid item>
                                        <Typography
                                            color={"#ebad55"}
                                            className="grow"
                                            variant="h3"
                                            fontWeight={"900"}
                                            sx={{ textShadow: "2px 2px 6px #B78E2B" }}
                                        >
                                            FORTUNE COOKIE
                                        </Typography>
                                    </Grid>
                                </Grid>
                                <Grid item xs={12} sm={12} md={4}>
                                    <Grid item sx={{ pt: 4 }}>
                                        <div style={{ display: "flex", flexDirection: "column" }}>
                                            <Box
                                                sx={{
                                                    minWidth: "350px",
                                                    height: "auto",
                                                    border: "5px solid  #fdb55a",
                                                    textAlign: "center",
                                                    alignSelf: "center",
                                                    padding: "10px",
                                                    margin: "15px",
                                                }}
                                            >
                                                <StyledButton style={{ width: "250px" }} onClick={updateStakeData}>
                                                    Update Stake Data
                                                </StyledButton>
                                                <Grid container spacing={2} justifyContent="center">
                                                    <Grid item xs={6}>
                                                        <p>
                                                            Total Staked: <br />
                                                            {totalStaked} $NEKO
                                                        </p>
                                                    </Grid>
        
                                                    <Grid item xs={6}>
                                                        <p>
                                                            Accrued Reward: <br />
                                                            {accReward} $NEKO
                                                        </p>
                                                    </Grid>
                                                    <Grid item xs={6}>
                                                        <TextField
                                                            variant="filled"
                                                            inputRef={stakeRef}
                                                            type="number"
                                                            defaultValue={"100"}
                                                            style={{ margin: "10px" }}
                                                        />
                                                        <p>Your Cookie:{cookieBalance}</p>
                                                        <StyledButton onClick={stake}>Stake COOKIE</StyledButton>
                                                        <hr />
                                                        <TextField
                                                            variant="filled"
                                                            inputRef={bakeRef}
                                                            type="number"
                                                            defaultValue={"0"}
                                                            style={{ margin: "10px" }}
                                                        />
                                                        <p>Your Neko:{nekoBalance}</p>
                                                        <StyledButton onClick={bake}>
                                                            bake
                                                            <br />
                                                            (NEKO->Cookie)
                                                        </StyledButton>
                                                    </Grid>
                                                    <Grid item xs={6}>
                                                        <TextField
                                                            variant="filled"
                                                            inputRef={unstakeRef}
                                                            type="number"
                                                            defaultValue={"0"}
                                                            style={{ margin: "10px" }}
                                                        />
                                                        <p>Total Staked:{totalStaked}</p>
                                                        <StyledButton onClick={unstake}>Unstake</StyledButton>
                                                        <hr />
                                                        <TextField
                                                            variant="filled"
                                                            inputRef={unBakeRef}
                                                            type="number"
                                                            defaultValue={"0"}
                                                            style={{ margin: "10px" }}
                                                        />
                                                        <p>Your Cookie:{cookieBalance}</p>
                                                        <StyledButton onClick={unbake}>
                                                            Unbake
                                                            <br />
                                                            (Cookie->Neko)
                                                        </StyledButton>
                                                    </Grid>
        
                                                    <Grid item xs={12}>
                                                        <StyledButton style={{ background: "#7e181d", color: "#fdb55a" }} onClick={claimReward}>
                                                            Claim NEKO
                                                        </StyledButton>
                                                        <p>Last Update:{lastUpdate}</p>
                                                    </Grid>
                                                </Grid>
                                            </Box>
                                        </div>
                                    </Grid>
                                </Grid>
                                <Grid item xs={12} sm={12} md={4}>
                                    <Grid itemxs={12} sx={{ pt: 5 }}>
                                        <div className="vertical-flip-container flip-container">
                                            <div className={isLoading ? "flipper" : "not-flipper"}>
                                                {!isLoading ? (
                                                    <div className="front">
                                                        <Image src={CookieStatic} style={{ width: "250px" }} className="catheader-img" />
                                                    </div>
                                                ) : (
                                                    <div className="back">
                                                        <Image src={CookieGif} style={{ width: "250px" }} className="catheader-img" />
                                                    </div>
                                                )}
                                            </div>
                                        </div>
                                    </Grid>
                                    <Grid itemxs={12} sx={{ pt: 4 }}>
                                        <StyledButton onClick={ftMint}>Mint Some Test Neko!</StyledButton>
                                        <TextField variant="filled" inputRef={amountRef} type="number" defaultValue={"100"} />
                                    </Grid>
                                </Grid>
                            </Grid>
                        </Box>
                    ) : (
                        <>
                            <Grid container spacing={2} justifyContent="center">
                                <Grid item xs={12} sx={{ textAlign: "center" }}>
                                    <Grid item>
                                        <Typography
                                            color={"#EBAD55"}
                                            className="grow"
                                            variant="h3"
                                            fontWeight={"900"}
                                            sx={{ textShadow: "2px 2px 6px #B78E2B" }}
                                        >
                                            GOOD FORTUNE FELINES
                                        </Typography>
                                    </Grid>
                                    <Grid item sx={{ pt: 4 }}>
                                        <Typography variant="subtitle1">you dont have cookie account</Typography>
                                    </Grid>
                                    <Grid item sx={{ pt: 4 }}>
                                        <StyledButton onClick={openCookieAccount}>Open Cookie Account</StyledButton>
                                    </Grid>
                                </Grid>
                            </Grid>
                        </>
                    )}
                </Box>
                <button onClick={ handleCloseModal }>Close Modal</button>
            </Modal>
        </div>
    }

    return (
        <div>
            <LPBackground/>
            <NekoStakeBtnModal/>
        </div>
    );
}

'''
'''--- src/components/NFTStake.js ---
import { utils } from "near-api-js";
import React from "react";

import { Image, Stack } from "react-bootstrap";
import { Box, Button, Container, Grid, IconButton, Typography, styled, Input, TextField } from "@mui/material";
import { toast } from "react-toastify";
import HelpIcon from "@mui/icons-material/Help";
import { async } from "regenerator-runtime";
import CachedIcon from "@mui/icons-material/Cached";
import { Steps, Hints } from "intro.js-react";
import TokenImg from "../assets/token.png";
const TOKEN_STORAGE_COST = utils.format.parseNearAmount("0.005");
const StyledButton = styled(Button)`
	background-color: #7e181d;
	color: #fdb55a;
	width: 180px;
	height: 60px;
	padding: 6px 18px;
	// font-size: 1.5vmin;
	border: 3px solid #f9ba55;
	&:hover {
		color: #fff;
		border: 3px solid #f9ba55;
	}
	&:focus {
		background-color: #7e181d;
		border: 3px solid #f9ba55;
	}
	border-radius: 0px;
`;
export default function NFTStake() {
	const [ownedNft, setOwnedNft] = React.useState([]);
	const [stakedNft, setStakedNft] = React.useState([]);
	const [totalStaked, setTotalStaked] = React.useState(0);
	//tutorial state

	const [enabled, setEnabled] = React.useState(false);
	const [initialStep, setInitialStep] = React.useState(0);
	const steps = [
		{
			element: "#your-nft",
			intro: "You can see your NFTs here.",
			position: "right",
		},
		{
			element: "#staked-nft",
			intro: "You can see staked NFTs here",
		},
		{
			element: "#your-nft-image",
			intro: "Click on the image to stake your nft",
			position: "right",
		},
		{
			element: "#refresh-reward-rate",
			intro: "Your NFT reward rate will be shown here",
			position: "right",
		},
		{
			element: "#refresh-reward-button",
			intro:
				"Reward rate update every 20 minutes after you stake your NFT,you can refresh the reward rate here (this will cost ~10Tgas)",
			position: "right",
		},
		{
			element: "#claim-reward-button",
			intro: "You can claim your reward without unstake your NFT here",
			position: "right",
		},
		{
			element: "#staked-nft-image",
			intro: "You Click on the image to unstake your nft",
			position: "right",
		},
	];
	const onExit = () => {
		setEnabled(false);
	};
	React.useEffect(() => {
		if (!window.accountId) return;
		get_owned_nft();

		get_staked_nft();
		window.contract.get_all_nft_staked_total({}).then((res) => {
			setTotalStaked(res);
		});
	}, [window.accountId]);
	const get_owned_nft = async () => {
		const owned_nft = await window.contract_nft.nft_tokens_for_owner({ account_id: window.accountId });
		setOwnedNft([...owned_nft]);
	};
	const get_staked_nft = async () => {
		/* 	const allId = await window.contract.nft_get_all_id({}); */

		const chunkSize = 350;
		const array = Array.from({ length: 1608 }, (_, i) => i + 1);
		let temp = [];
		for (let i = 0; i < array.length; i += chunkSize) {
			const chunk = array.slice(i, i + chunkSize);
			let staked_nft = await window.contract.get_is_token_owner_many({
				account_id: window.accountId,
				token_id: chunk,
			});
			temp = temp.concat(staked_nft);
			setStakedNft([...temp]);
			console.log([...temp]);
		}
	};

	const createNekoAccount = async () => {
		await window.contract.storage_deposit(
			{ account_id: window.accountId },
			"300000000000000",
			utils.format.parseNearAmount("0.01")
		);
	};
	const stake_nft = async (tokenId) => {
		await window.contract_nft.nft_approve({
			args: {
				token_id: tokenId,
				account_id: process.env.REACT_APP_NEKO_CONTRACT_ID,
				msg: "stake-approve",
			},
			amount: "500000000000000000000",
			gas: "150000000000000",
		});
	};
	const unstake_nft = async (tokenId) => {
		const unstake = await window.contract.nft_unstake({
			args: { token_id: tokenId },
			amount: TOKEN_STORAGE_COST,
			gas: "150000000000000",
		});
	};
	const nft_refresh_reward = async (tokenId) => {
		await toast.promise(window.contract.nft_refresh_reward({ args: { token_id: tokenId } }), {
			pending: "updating...",
			error: "error",
		});
		get_staked_nft();
	};
	const claim_nft_stake_reward = async (tokenId) => {
		await toast.promise(
			window.contract.claim_nft_stake_reward({ args: { token_id: tokenId }, amount: TOKEN_STORAGE_COST }),
			{
				pending: "updating...",
				error: "error",
			}
		);
		get_staked_nft();
	};

	const parseEstReward = (rewardRate, lastUpdateTime, accReward) => {
		const final = Math.floor(
			(rewardRate * ((Date.now() * 1000000 - lastUpdateTime) / (1000000000 * 1200))) / rewardRate
		);
		return accReward + final * rewardRate;
	};
	return (
		<Box sx={{ mt: 5 }}>
			<Steps
				enabled={enabled}
				steps={steps}
				initialStep={initialStep}
				onExit={onExit}
				options={{ tooltipClass: "steps" }}
			/>
			<Grid container spacing={2} justifyContent="center">
				<Grid item xs={12} sx={{ textAlign: "center" }}>
					<Grid item>
						<Typography
							color={"#EBAD55"}
							className="grow"
							variant="h3"
							fontWeight={"900"}
							sx={{ textShadow: "2px 2px 6px #B78E2B", paddingBottom: "50px" }}
						>
							NFT STAKE
						</Typography>
						<Typography
							color={"#EBAD55"}
							variant="h5"
							fontWeight={"900"}
							sx={{ textShadow: "2px 2px 6px #B78E2B", paddingBottom: "50px" }}
						>
							Total Staked Felines: {totalStaked}
						</Typography>

						<StyledButton onClick={createNekoAccount}>Add NEKO to Near Wallet</StyledButton>
					</Grid>
				</Grid>
			</Grid>
			<Grid container spacing={2} justifyContent="center">
				<Grid item xs={12} sm={12} md={4} className="nft-grid">
					<div style={{ textAlign: "center", paddingTop: "10px", paddingBottom: "10px" }}>
						YOUR NFT
						<IconButton onClick={() => setEnabled(true)}>
							<HelpIcon />
						</IconButton>
						<br />
						<small>Click to stake</small>
					</div>
					<div
						style={{ border: "5px solid #fdb55a", padding: "10px", margin: "10px", overflowY: "auto", height: "470px" }}
						id="your-nft"
					>
						<Grid container spacing={3}>
							{ownedNft.length > 0 ? (
								ownedNft.map((nft) => {
									return (
										<Grid key={nft.token_id} item xs={6} sm={6} md={4}>
											<div>
												<Grid item>
													<Grid
														container
														display={"flex"}
														flexDirection={"column"}
														justifyContent={"center"}
														alignItems={"center"}
													>
														<Grid item>
															<img
																id="your-nft-image"
																onClick={() => stake_nft(nft.token_id)}
																src={`https://ewtd.mypinata.cloud/ipfs/QmNtWmU8LuNNexpcw3djhGcdudkUarX8oiovGCZrwrhYR4/${nft.token_id}.png`}
																width="100%"
																style={{ cursor: "pointer" }}
																className="nft-image"
															></img>
														</Grid>
														<Grid item>
															<span>{nft.token_id}</span>
														</Grid>
													</Grid>
												</Grid>
											</div>
										</Grid>
									);
								})
							) : (
								<Grid item xs={6} sm={6} md={4}>
									0 NFTS
								</Grid>
							)}
						</Grid>
					</div>
				</Grid>
				<Grid item xs={12} sm={12} md={4}>
					<div style={{ textAlign: "center", paddingTop: "10px", paddingBottom: "10px" }}>
						NFT STAKED
						<IconButton onClick={() => setEnabled(true)}>
							<HelpIcon />
						</IconButton>
						<br />
						<small>Click to unstake</small>
					</div>
					<div
						style={{ border: "5px solid #fdb55a", padding: "10px", margin: "10px", overflowY: "auto", height: "470px" }}
						id="staked-nft"
					>
						<Grid container spacing={3}>
							{stakedNft.map((nft) => {
								return (
									<Grid key={nft.token_id} item xs={6} sm={6} md={4}>
										<div>
											<Grid item>
												<Grid
													container
													display={"flex"}
													flexDirection={"column"}
													justifyContent={"center"}
													alignItems={"center"}
												>
													<Grid item>
														<img
															id="staked-nft-image"
															onClick={() => unstake_nft(nft.token_id)}
															src={`https://ewtd.mypinata.cloud/ipfs/QmNtWmU8LuNNexpcw3djhGcdudkUarX8oiovGCZrwrhYR4/${nft.token_id}.png`}
															style={{ cursor: "pointer" }}
															className="nft-image"
															width="100%"
														></img>
													</Grid>
													<Grid item>
														<span>{nft.token_id}</span>
													</Grid>
													<Grid item>
														<span id="refresh-reward-rate">Reward Rate:{nft.reward_rate}</span>
													</Grid>
													<Grid item>
														<span style={{ textAlign: "center" }}>
															EST Reward:{parseEstReward(nft.reward_rate, nft.last_stake_time, nft.acc_reward)}
														</span>
														{/* 	<IconButton
															id="refresh-reward-button"
															style={{ padding: "3px", width: "auto", height: "auto" }}
															onClick={() => nft_refresh_reward(nft.token_id)}
														>
															<CachedIcon />
														</IconButton> */}
													</Grid>
													<Grid item>
														<span>{/*Traits:{nft.traits_data}*/}</span>
													</Grid>

													<Grid item>
														<StyledButton
															id="claim-reward-button"
															style={{ padding: "4px", width: "auto", height: "auto" }}
															onClick={() => claim_nft_stake_reward(nft.token_id)}
														>
															Claim Reward
														</StyledButton>
													</Grid>
												</Grid>
											</Grid>
										</div>
									</Grid>
								);
							})}
						</Grid>
					</div>
				</Grid>
			</Grid>
		</Box>
	);
}

'''
'''--- src/components/Stake.js ---
import { utils } from "near-api-js";
import React from "react";

import { Image, Stack } from "react-bootstrap";
import { Box, Button, Container, Grid, IconButton, Typography, styled, Input, TextField, spacing } from "@mui/material";
import { toast } from "react-toastify";
import { async } from "regenerator-runtime";
import CookieStatic from "../assets/cookie_static.png";
import CookieGif from "../assets/cookie_gif.gif";
const NORMAL_GAS = "150000000000000";
const StyledButton = styled(Button)`
	background-color: #7e181d;
	color: #fdb55a;
	width: 180px;
	height: 60px;
	padding: 6px 18px;
	font-size: 18px;
	border: 3px solid #f9ba55;
	&:hover {
		color: #fff;
		border: 3px solid #f9ba55;
	}
	&:focus {
		background-color: #7e181d;
		border: 3px solid #f9ba55;
	}
	border-radius: 0px;
`;
export default function Stake() {
	const [totalStaked, setTotalStaked] = React.useState(0);
	const [nekoBalance, setNekoBalance] = React.useState(0);
	const [accReward, setAccReward] = React.useState(0);
	const [lastUpdate, setLastUpdate] = React.useState(0);
	const [cookieBalance, setCookieBalance] = React.useState(0);
	const [contractBalance, setContractBalance] = React.useState(0);
	const [isRegisteredCookie, setIsRegisteredCookie] = React.useState(false);
	const [isLoading, setIsLoading] = React.useState(false);
	const amountRef = React.useRef(null);
	const stakeRef = React.useRef(null);
	const unstakeRef = React.useRef(null);
	const bakeRef = React.useRef(null);
	const unBakeRef = React.useRef(null);
	React.useEffect(() => {
		if (!window.accountId) return;
		window.contract_factory
			.storage_balance_of({ account_id: window.accountId })
			.then((res) => {
				setIsRegisteredCookie(res);
			})
			.catch((e) => {
				console.log(e.message);
			});
		window.contract_factory
			.ft_balance_of({ account_id: window.accountId })
			.then((res) => {
				setCookieBalance(res);
			})
			.catch((e) => {
				console.log(e.message);
			});
		window.contract.ft_balance_of({ account_id: window.accountId }).then((res) => {
			setNekoBalance(res);
		});
		window.contract_factory.ft_balance_of({ account_id: process.env.REACT_APP_NEKO_CONTRACT_ID }).then((res) => {
			setContractBalance(res);
		});
		getStakeData();
	}, [window.accountId]);
	const getStakeData = async () => {
		try {
			const stakeData = await window.contract.get_stake_by_id({ id: window.accountId });
			setTotalStaked(stakeData.total_stake);
			setAccReward(stakeData.acc_reward);
			setLastUpdate(new Date(stakeData.last_update_time / 1000000).toLocaleString());
			console.log(stakeData);
		} catch (e) {
			console.error(e.message);
		}
	};
	const updateStakeData = async () => {
		setIsLoading(true);
		try {
			await toast.promise(window.contract.update_stake_data({ account_id: window.accountId }), {
				pending: "Loading",
				success: "success",
			});
			getStakeData();
		} catch (e) {
			toast.error(e.message);
		}
		setIsLoading(false);
	};
	const openCookieAccount = async () => {
		await toast.promise(
			window.contract_factory.storage_deposit(
				{ account_id: window.accountId },
				"300000000000000",
				utils.format.parseNearAmount("0.01")
			),
			{
				pending: "Opening...",
				error: `${accountId == "" ? "Connect your Wallet First" : "Error..."}`,
			}
		);
		getStakeData();
	};
	const ftMint = async () => {
		setIsLoading(true);
		console.log(amountRef.current.value);
		try {
			toast.promise(
				window.contract.ft_mint({
					to: window.accountId,
					amount: parseInt(amountRef.current.value),
				}),
				{ pending: "Minting Test Neko", success: "Minted Test Neko", error: "Error Minting Test Neko" }
			);
		} catch (e) {
			toast.error(e.message);
		}
		setIsLoading(false);
	};
	const stake = async () => {
		setIsLoading(true);
		console.log(stakeRef.current.value);
		if (cookieBalance < parseInt(stakeRef.current.value)) {
			toast.error("You don't have enough Cookie!");
			return;
		}
		try {
			await toast.promise(
				window.contract.stake(
					{
						amount: parseInt(stakeRef.current.value),
					},
					"180000000000000",
					1
				),
				{ pending: "Staking Test Neko", success: "Staked Test Neko", error: "Error Staking Test Neko" }
			);
		} catch (e) {
			toast.error(e.message);
		}

		setIsLoading(false);
	};
	const unstake = async () => {
		setIsLoading(true);
		
		if (totalStaked < unstakeRef.current.value) {
			toast.error("You don't have enough staked Cookie!");
			return;
		}

		try {
			await toast.promise(
				window.contract.unstake(
					{
						amount: parseInt(unstakeRef.current.value),
					},
					"180000000000000",
					1
				),
				{ pending: "Unstaking Neko", success: "Unstaked  Neko", error: "Error Unstaking  Neko" }
			);
		} catch (e) {
			toast.error(e.message);
		}

		setIsLoading(false);
	};
	const claimReward = async () => {
		setIsLoading(true);
		try {
			await toast.promise(
				window.contract.claim_neko(
					{
						account_id: window.accountId,
					},
					"300000000000000",
					1
				),
				{ pending: "Claiming Reward", success: "Claimed Reward", error: "Error Claiming Reward" }
			);
		} catch (e) {
			toast.error(e.message);
		}

		setIsLoading(false);
	};
	const bake = async () => {
		setIsLoading(true);
		console.log(nekoBalance, bakeRef.current.value);
		if (nekoBalance < bakeRef.current.value) {
			toast.error("You don't have enough Neko!");
			return;
		}
		try {
			await toast.promise(
				window.contract.bake({ args: { amount: parseInt(bakeRef.current.value) }, amount: 2, gas: NORMAL_GAS }),
				{
					pending: "Baking Neko",
					success: "Baked Neko",
					error: "Error Baking Neko",
				}
			);
		} catch (e) {
			console.log(e.message);
		}
	};
	const unbake = async () => {
		setIsLoading(true);
		
		if (cookieBalance < parseInt(unBakeRef.current.value)) {
			toast.error("You don't have enough Cookie!");
			return;
		}
		try {
			await toast.promise(
				window.contract.unbake({ args: { amount: parseInt(unBakeRef.current.value) }, amount: 1, gas: NORMAL_GAS }),
				{ pending: "Unbaking Neko", success: "Unbaked Neko", error: "Error Unbaking Neko" }
			);
		} catch (e) {
			console.log(e.message);
		}
	};

	return (
		<Box sx={{ mt: 5 }}>
			<div>
				<p style={{ textAlign: "center" }}>Cookie in stock(Vault):{contractBalance} [Dev Only]</p>
			</div>
			{isRegisteredCookie ? (
				<Box>
					<Grid container spacing={2} justifyContent="center">
						<Grid item xs={12} sm={12} sx={{ textAlign: "center" }}>
							<Grid item>
								<Typography
									color={"#EBAD55"}
									className="grow"
									variant="h3"
									fontWeight={"900"}
									sx={{ textShadow: "2px 2px 6px #B78E2B" }}
								>
									FORTUNE COOKIE
								</Typography>
							</Grid>
						</Grid>
						<Grid item xs={12} sm={12} md={4}>
							<Grid item sx={{ pt: 4 }}>
								<div style={{ display: "flex", flexDirection: "column" }}>
									<Box
										sx={{
											minWidth: "350px",
											height: "auto",
											border: "5px solid  #fdb55a",
											textAlign: "center",
											alignSelf: "center",
											padding: "10px",
											margin: "15px",
										}}
									>
										<StyledButton style={{ width: "250px" }} onClick={updateStakeData}>
											Update Stake Data
										</StyledButton>
										<Grid container spacing={2} justifyContent="center">
											<Grid item xs={6}>
												<p>
													Total Staked: <br />
													{totalStaked} $NEKO
												</p>
											</Grid>

											<Grid item xs={6}>
												<p>
													Accrued Reward: <br />
													{accReward} $NEKO
												</p>
											</Grid>
											<Grid item xs={6}>
												<TextField
													variant="filled"
													inputRef={stakeRef}
													type="number"
													defaultValue={"100"}
													style={{ margin: "10px" }}
												/>
												<p>Your Cookie:{cookieBalance}</p>
												<StyledButton onClick={stake}>Stake COOKIE</StyledButton>
												<hr />
												<TextField
													variant="filled"
													inputRef={bakeRef}
													type="number"
													defaultValue={"0"}
													style={{ margin: "10px" }}
												/>
												<p>Your Neko:{nekoBalance}</p>
												<StyledButton onClick={bake}>
													bake
													<br />
													(NEKO->Cookie)
												</StyledButton>
											</Grid>
											<Grid item xs={6}>
												<TextField
													variant="filled"
													inputRef={unstakeRef}
													type="number"
													defaultValue={"0"}
													style={{ margin: "10px" }}
												/>
												<p>Total Staked:{totalStaked}</p>
												<StyledButton onClick={unstake}>Unstake</StyledButton>
												<hr />
												<TextField
													variant="filled"
													inputRef={unBakeRef}
													type="number"
													defaultValue={"0"}
													style={{ margin: "10px" }}
												/>
												<p>Your Cookie:{cookieBalance}</p>
												<StyledButton onClick={unbake}>
													Unbake
													<br />
													(Cookie->Neko)
												</StyledButton>
											</Grid>

											<Grid item xs={12}>
												<StyledButton style={{ background: "#7e181d", color: "#fdb55a" }} onClick={claimReward}>
													Claim NEKO
												</StyledButton>
												<p>Last Update:{lastUpdate}</p>
											</Grid>
										</Grid>
									</Box>
								</div>
							</Grid>
						</Grid>
						<Grid item xs={12} sm={12} md={4}>
							<Grid itemxs={12} sx={{ pt: 5 }}>
								<div className="vertical-flip-container flip-container">
									<div className={isLoading ? "flipper" : "not-flipper"}>
										{!isLoading ? (
											<div className="front">
												<Image src={CookieStatic} style={{ width: "250px" }} className="catheader-img" />
											</div>
										) : (
											<div className="back">
												<Image src={CookieGif} style={{ width: "250px" }} className="catheader-img" />
											</div>
										)}
									</div>
								</div>
							</Grid>
							<Grid itemxs={12} sx={{ pt: 4 }}>
								<StyledButton onClick={ftMint}>Mint Some Test Neko!</StyledButton>
								<TextField variant="filled" inputRef={amountRef} type="number" defaultValue={"100"} />
							</Grid>
						</Grid>
					</Grid>
				</Box>
			) : (
				<>
					<Grid container spacing={2} justifyContent="center">
						<Grid item xs={12} sx={{ textAlign: "center" }}>
							<Grid item>
								<Typography
									color={"#EBAD55"}
									className="grow"
									variant="h3"
									fontWeight={"900"}
									sx={{ textShadow: "2px 2px 6px #B78E2B" }}
								>
									GOOD FORTUNE FELINES
								</Typography>
							</Grid>
							<Grid item sx={{ pt: 4 }}>
								<Typography variant="subtitle1">you dont have cookie account</Typography>
							</Grid>
							<Grid item sx={{ pt: 4 }}>
								<StyledButton onClick={openCookieAccount}>Open Cookie Account</StyledButton>
							</Grid>
						</Grid>
					</Grid>
				</>
			)}
		</Box>
	);
}

'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.REACT_APP_NEKO_CONTRACT_ID;

function getConfig(env) {
	switch (env) {
		case "production":
		case "mainnet":
			return {
				networkId: "mainnet",
				nodeUrl: "https://rpc.mainnet.near.org",
				contractName: CONTRACT_NAME,
				walletUrl: "https://wallet.near.org",
				helperUrl: "https://helper.mainnet.near.org",
				explorerUrl: "https://explorer.mainnet.near.org",
			};
		case "development":
		case "testnet":
			return {
				networkId: "testnet",
				nodeUrl: "https://rpc.testnet.near.org",
				contractName: CONTRACT_NAME,
				walletUrl: "https://wallet.testnet.near.org",
				helperUrl: "https://helper.testnet.near.org",
				explorerUrl: "https://explorer.testnet.near.org",
			};
		case "betanet":
			return {
				networkId: "betanet",
				nodeUrl: "https://rpc.betanet.near.org",
				contractName: CONTRACT_NAME,
				walletUrl: "https://wallet.betanet.near.org",
				helperUrl: "https://helper.betanet.near.org",
				explorerUrl: "https://explorer.betanet.near.org",
			};
		case "local":
			return {
				networkId: "local",
				nodeUrl: "http://localhost:3030",
				keyPath: `${process.env.HOME}/.near/validator_key.json`,
				walletUrl: "http://localhost:4000/wallet",
				contractName: CONTRACT_NAME,
			};
		case "test":
		case "ci":
			return {
				networkId: "shared-test",
				nodeUrl: "https://rpc.ci-testnet.near.org",
				contractName: CONTRACT_NAME,
				masterAccount: "test.near",
			};
		case "ci-betanet":
			return {
				networkId: "shared-test-staging",
				nodeUrl: "https://rpc.ci-betanet.near.org",
				contractName: CONTRACT_NAME,
				masterAccount: "test.near",
			};
		default:
			throw Error(`Unconfigured environment '${env}'. Can be configured in src/config.js.`);
	}
}

module.exports = getConfig;

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="./assets/favicon.ico" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="apple-touch-icon" href="./assets/favicon.ico" />
		<title>Neko Stake</title>
	</head>
	<body>
		<noscript>You need to enable JavaScript to run this app.</noscript>
		<div id="root"></div>
		<!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
		<script src="./index.js"></script>
	</body>
</html>

'''
'''--- src/index.js ---
import React from "react";
import ReactDOM from "react-dom";
// import App from './App'
import Home from "./pages/Home";

import "react-toastify/dist/ReactToastify.css";
import { initContract } from "./utils";
import "./styles/global.scss";
import "intro.js/introjs.css";
// Importing the Bootstrap CSS
// import 'bootstrap/dist/css/bootstrap.min.css';

window.nearInitPromise = initContract()
	.then(() => {
		ReactDOM.render(
			// <App />,
			<Home />,
			document.querySelector("#root")
		);
	})
	.catch(console.error);

'''
'''--- src/jest.init.js ---
import 'regenerator-runtime/runtime'

'''
'''--- src/main.test.js ---
beforeAll(async function () {
  // NOTE: nearlib and nearConfig are made available by near-cli/test_environment
  const near = await nearlib.connect(nearConfig)
  window.accountId = nearConfig.contractName
  window.contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['get_greeting'],
    changeMethods: [],
    sender: window.accountId
  })

  window.walletConnection = {
    requestSignIn() {
    },
    signOut() {
    },
    isSignedIn() {
      return true
    },
    getAccountId() {
      return window.accountId
    }
  }
})

test('get_greeting', async () => {
  const message = await window.contract.get_greeting({ account_id: window.accountId })
  expect(message).toEqual('Hello')
})

'''
'''--- src/pages/Admin.js ---
import { Button, TextField } from "@mui/material";
import React, { useState } from "react";
import { toast } from "react-toastify";

export default function Admin() {
	const [rewardRate, setRewardRate] = React.useState(0);
	const [feeRate, setFeeRate] = React.useState(0);
	const [traitsRewardRate, setTraitsRewardRate] = React.useState({});
	const [totalSupply, setTotalSupply] = React.useState(0);
	const [interval, setInterval] = React.useState(0);
	const rewardRateRef = React.useRef(null);
	const bakeFeeRef = React.useRef(null);
	const intervalRef = React.useRef(null);
	const traitNameRef = React.useRef(null);
	const traitRewardRef = React.useRef(null);
	const mintTokenAddressRef = React.useRef(null);
	const mintTokenAmountRef = React.useRef(null);
	useState(() => {
		window.contract.get_reward_rate().then((rate) => {
			setRewardRate(rate);
		});
		window.contract.get_fee_rate().then((rate) => {
			setFeeRate(rate);
		});
		window.contract.get_traits_reward_rate().then((rate) => {
			setTraitsRewardRate(rate);
		});
		window.contract.ft_total_supply().then((supply) => {
			setTotalSupply(supply);
		});
		window.contract.get_interval().then((interval) => {
			setInterval(interval);
		});
	}, []);
	const setRewardRateCall = async () => {
		if (rewardRateRef.current.value == "") {
			toast.error("Please input a number");
			return;
		}
		await toast.promise(
			window.contract.set_reward_rate({
				args: {
					rate: parseInt(rewardRateRef.current.value.trim()),
				},
			}),
			{ pending: "updating...", success: "success", error: "error" }
		);
	};
	const setBakeFeeCall = async () => {
		if (bakeFeeRef.current.value == "") {
			toast.error("Please input a number");
			return;
		}
		await toast.promise(
			window.contract.set_bake_fee({
				args: {
					rate: parseInt(bakeFeeRef.current.value.trim()),
				},
			}),
			{ pending: "updating...", success: "success", error: "error" }
		);
	};
	const setIntervalCall = async () => {
		if (intervalRef.current.value == "") {
			toast.error("Please input a number");
			return;
		}
		await toast.promise(
			window.contract.set_reward_interval({
				args: {
					interval: parseInt(intervalRef.current.value.trim()),
				},
			}),
			{ pending: "updating...", success: "success", error: "error" }
		);
	};
	const addTraitReward = async () => {
		if (traitNameRef.current.value == "" || traitRewardRef.current.value == "") {
			toast.error("Invalid Input");
			return;
		}
		await toast.promise(
			window.contract.upload_traits_value({
				args: {
					trait_name: traitNameRef.current.value.trim(),
					reward_value: parseInt(traitRewardRef.current.value.trim()),
				},
			}),
			{ pending: "updating...", success: "success", error: "error" }
		);
	};
	const mintTokenToAddress = async () => {
		if (mintTokenAddressRef.current.value == "" || mintTokenAmountRef.current.value == "") {
			toast.error("Invalid Input");
			return;
		}
		await toast.promise(
			window.contract.ft_mint({
				args: {
					to: mintTokenAddressRef.current.value.trim(),
					amount: parseInt(mintTokenAmountRef.current.value.trim()),
				},
			}),
			{ pending: "updating...", success: "success", error: "error" }
		);
	};
	return (
		<>
			<div style={{ textAlign: "center", marginTop: "20px" }}>
				<h2>NEKO Staking Config</h2>
				<h3>Total circulating supply:{totalSupply}</h3>
				<div> NEKO Stake Reward rate:{rewardRate}%</div>
				<TextField
					label="Reward Rate"
					type={"number"}
					InputProps={{
						endAdornment: (
							<Button onClick={setRewardRateCall} position="end">
								Set
							</Button>
						),
						inputRef: rewardRateRef,
					}}
				></TextField>
				<div>NEKO Baking Fee : {feeRate}%</div>
				<TextField
					label="Baking fee"
					type={"number"}
					InputProps={{
						endAdornment: (
							<Button onClick={setBakeFeeCall} position="end">
								Set
							</Button>
						),
						inputRef: bakeFeeRef,
					}}
				></TextField>
				<div>Set Reward Interval(seconds) </div>
				<TextField
					label="Interval"
					type={"number"}
					InputProps={{
						endAdornment: (
							<Button onClick={setIntervalCall} position="end">
								Set
							</Button>
						),
						inputRef: intervalRef,
					}}
				></TextField>
			</div>
			<div style={{ textAlign: "center", marginTop: "20px" }}>
				<h2>NFT Staking Config</h2>
				<div>
					<h6>Current Reward Traits:</h6>

					{Object.keys(traitsRewardRate).map((trait) => {
						return (
							<div key={trait}>
								{trait} : {traitsRewardRate[trait]} NEKO / {interval} seconds
							</div>
						);
					})}
				</div>
				<br />
				<div>
					<TextField label="Traits Name" InputProps={{ inputRef: traitNameRef }} type={"text"}></TextField>
					<TextField label="Traits Reward Rate" InputProps={{ inputRef: traitRewardRef }} type={"number"}></TextField>
					<Button onClick={addTraitReward}>Add</Button>
				</div>
				<div>
					<h5>Mint Token To Address</h5>
					<TextField
						label="Account ID"
						type={"text"}
						InputProps={{
							endAdornment: (
								<TextField
									label="Amount"
									position="end"
									InputProps={{
										endAdornment: (
											<Button onClick={mintTokenToAddress} position="end">
												Mint
											</Button>
										),
										inputRef: mintTokenAmountRef,
									}}
									type={"number"}
								></TextField>
							),
							inputRef: mintTokenAddressRef,
						}}
					></TextField>
				</div>
			</div>
		</>
	);
}

'''
'''--- src/pages/Home.js ---
import { utils } from "near-api-js";
import regeneratorRuntime from "regenerator-runtime";
import React, { useState, useEffect } from "react";
import ReactDOM from "react-dom";
import Header from "../components/Header";
import Stake from "../components/Stake";
import LandingPage from "../components/LandingPage";
import { ToastContainer } from "react-toastify";
import { createTheme, CssBaseline, ThemeProvider } from "@mui/material";
import NFTStake from "../components/NFTStake";
import NekoStake from "../components/Stake.js";
import { BrowserRouter, Routes, Route } from "react-router-dom";
import Admin from "./Admin";
const darkTheme = createTheme({
	typography: {
		h3: {
			fontFamily: "Source Sans Pro",
			fontWeight: "700",
		},
		fontFamily: "Source Sans Pro",
	},

	palette: {
		mode: "dark",
		primary: {
			main: "#EBAD55",
			light: "#90f2f7",
		},
		secondary: {
			main: "#fbf9f8",
		},
		background: {
			default: "#972F34",
			paper: "#181818",
		},
		warning: {
			main: "#ff3d00",
		},
		text: {
			primary: "#EBAD55",
		},
	},
});
const Home = () => {
	return (
		<ThemeProvider theme={darkTheme}>
			<div className="home">
				<Header />

				<BrowserRouter>
					<Routes>
						<Route path="/" exact element={<Stake />} />
						<Route path="/nft" exact element={<NFTStake />} />
						<Route path="/nekostake" exact element={<NekoStake />} />
						<Route path="*" element={<NFTStake />} />
						<Route path="/landingpage" element={<LandingPage />} />
						<Route path="/admin" element={<Admin />} />
					</Routes>
				</BrowserRouter>
				<ToastContainer />
			</div>
			<CssBaseline />
		</ThemeProvider>
	);
};

export default Home;

'''
'''--- src/utils.js ---
import { connect, Contract, keyStores, WalletConnection } from "near-api-js";
import getConfig from "./config";

const nearConfig = getConfig("testnet");

// Initialize contract & set global variables
export async function initContract() {
	// Initialize connection to the NEAR testnet
	const near = await connect(
		Object.assign({ deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } }, nearConfig)
	);

	// Initializing Wallet based Account. It can work with NEAR testnet wallet that
	// is hosted at https://wallet.testnet.near.org
	window.walletConnection = new WalletConnection(near);

	// Getting the Account ID. If still unauthorized, it's just empty string
	window.accountId = window.walletConnection.getAccountId();

	// Initializing our contract APIs by contract name and configuration
	window.contract = await new Contract(window.walletConnection.account(), nearConfig.contractName, {
		// View methods are read only. They don't modify the state, but usually return some value.
		viewMethods: [
			"get_stake_by_id",
			"get_nft_stake_by_id",
			"ft_balance_of",
			"get_nft_stake_by_account",
			"get_all_nft_staked_total",
			"get_nft_stake_by_account_chunk",
			"get_all_nft_staked_id",
			//Admin
			"get_nft_id",
			"get_interval",
			"get_reward_rate",
			"get_fee_rate",
			"get_traits_reward_rate",
			"ft_total_supply",
			"nft_get_all_id",
			"get_is_token_owner_many",
		],
		// Change methods can modify the state. But you don't receive the returned value when called.
		changeMethods: [
			"stake",
			"ft_mint",
			"bake",
			"unbake",
			"update_stake_data",
			"claim_neko",
			"unstake",
			"nft_unstake",
			"claim_nft_stake_reward",
			"nft_refresh_reward",
			"storage_deposit",
			//ADMIN
			"set_nft_id",
			"upload_traits_value",
			"set_reward_rate",
			"set_bake_fee",
			"set_reward_interval",
			"set_bonus_traits",
			"set_bonus_rate",
		],
	});
	//FACTORY CONTRACT
	window.contract_factory = await new Contract(
		window.walletConnection.account(),
		process.env.REACT_APP_FACTORY_CONTRACT_ID,
		{
			// View methods are read only. They don't modify the state, but usually return some value.
			viewMethods: ["get_stake_by_id", "ft_balance_of", "storage_balance_of"],
			// Change methods can modify the state. But you don't receive the returned value when called.
			changeMethods: ["stake", "ft_mint", "update_stake_data", "storage_deposit"],
		}
	);
	//NFT CONTRACT
	window.contract_nft = await new Contract(window.walletConnection.account(), process.env.REACT_APP_NFT_CONTRACT_ID, {
		viewMethods: ["nft_tokens_for_owner"],
		changeMethods: ["nft_mint", "nft_approve"],
	});
}

export function logout() {
	window.walletConnection.signOut();
	// reload page
	window.location.replace(window.location.origin + window.location.pathname);
}

export function login() {
	// Allow the current app to make calls to the specified contract on the
	// user's behalf.
	// This works by creating a new access key for the user's account and storing
	// the private key in localStorage.
	window.walletConnection.requestSignIn(nearConfig.contractName);
}

'''
'''--- src/wallet/login/index.html ---
<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/css/bootstrap.min.css" integrity="sha384-GJzZqFGwb1QTTN6wy59ffF1BuGJpLSa9DkKMp0DgiMDm4iYMj70gZWKYbI706tWS" crossorigin="anonymous">
</head>
<body style="background: #fff; margin-top: 3em">
  <div>For local account login, Please run the following command in NEAR CLI, then enter account id here.
  </div>
  <div>
      <code id="shell-command"></code>
  </div>
  <input type="text" id="accountId" name="accountId" placeholder="Account id"></input>
  <button type="button" onClick="done()">done</button>
  <script>
    const currentUrl = new URL(window.location.href);
    const message = `NODE_ENV=local near create_account {newAccountId} --masterAccount {masterAccountId} --publicKey ${currentUrl.searchParams.get('public_key')} --initialAmount 10000000000000000000`;
    document.getElementById('shell-command').innerText = message;

    function done() {
      const successUrl = new URL(currentUrl.searchParams.get('success_url'));
      successUrl.searchParams.set('account_id', document.getElementById('accountId').value);
      successUrl.searchParams.set('public_key', currentUrl.searchParams.get('public_key'));
      window.location.assign(successUrl.toString());
    }
  </script>
</body>
</html>
'''