*GitHub Repository "phoenix-token/x-phoenix-token"*

'''--- .gitlab-ci.yml ---
variables:
  RUSTFLAGS: '-C link-arg=-s'
stages:
  - build
build:
  image: rust:1.58.1
  stage: build
  variables:
    RUSTFLAGS: '-C link-arg=-s'
  script:
    - rustup target add wasm32-unknown-unknown
    - cargo build --target wasm32-unknown-unknown --release
'''
'''--- Cargo.toml ---
[package]
name = "x_phoenix_token"
version = "0.0.1"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
uint = { version = "0.9.0", default-features = false }
near-sdk = "3.1.0"
near-contract-standards = "3.2.0"
'''
'''--- README.md ---
# x_phoenix_token

'''
'''--- compile.sh ---
#!/bin/bash
set -e
rustup target add wasm32-unknown-unknown
RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
'''
'''--- package-lock.json ---
{
  "name": "phoenix_token",
  "lockfileVersion": 2,
  "requires": true,
  "packages": {
    "": {
      "dependencies": {
        "near-api-js": "^0.44.2"
      }
    },
    "node_modules/base-x": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.9.tgz",
      "integrity": "sha512-H7JU6iBHTal1gp56aKoaa//YUxEaAOUiydvrV/pILqIHXTtqxSkATOnDA2u+jZ/61sD+L/412+7kzXRtWukhpQ==",
      "dependencies": {
        "safe-buffer": "^5.0.1"
      }
    },
    "node_modules/bn.js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.0.tgz",
      "integrity": "sha512-D7iWRBvnZE8ecXiLj/9wbxH7Tk79fAh8IHaTNq1RWRixsS02W+5qS+iE9yq6RYl0asXx5tw0bLhmT5pIfbSquw=="
    },
    "node_modules/borsh": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.6.0.tgz",
      "integrity": "sha512-sl5k89ViqsThXQpYa9XDtz1sBl3l1lI313cFUY1HKr+wvMILnb+58xpkqTNrYbelh99dY7K8usxoCusQmqix9Q==",
      "dependencies": {
        "bn.js": "^5.2.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      }
    },
    "node_modules/bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha1-vhYedsNU9veIrkBx9j806MTwpCo=",
      "dependencies": {
        "base-x": "^3.0.2"
      }
    },
    "node_modules/capability": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
      "integrity": "sha1-Ua2HNT8ZNv/Xfy8hx0YzpN6oiAE="
    },
    "node_modules/depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
      "engines": {
        "node": ">= 0.8"
      }
    },
    "node_modules/error-polyfill": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.3.tgz",
      "integrity": "sha512-XHJk60ufE+TG/ydwp4lilOog549iiQF2OAPhkk9DdiYWMrltz5yhDz/xnKuenNwP7gy3dsibssO5QpVhkrSzzg==",
      "dependencies": {
        "capability": "^0.2.5",
        "o3": "^1.0.3",
        "u3": "^0.1.1"
      }
    },
    "node_modules/http-errors": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.1.tgz",
      "integrity": "sha512-Kpk9Sm7NmI+RHhnj6OIWDI1d6fIoFAtFt9RLaTMRlg/8w49juAStsrBgp0Dp4OdxdVbRIeKhtCUvoi/RuAhO4g==",
      "dependencies": {
        "depd": "~1.1.2",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": ">= 1.5.0 < 2",
        "toidentifier": "1.0.1"
      },
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/http-errors/node_modules/depd": {
      "version": "1.1.2",
      "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
      "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "node_modules/js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "node_modules/mustache": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
      "integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ==",
      "bin": {
        "mustache": "bin/mustache"
      }
    },
    "node_modules/near-api-js": {
      "version": "0.44.2",
      "resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-0.44.2.tgz",
      "integrity": "sha512-eMnc4V+geggapEUa3nU2p8HSHn/njtloI4P2mceHQWO8vDE1NGpnAw8FuTBrLmXSgIv9m6oocgFc9t3VNf5zwg==",
      "dependencies": {
        "bn.js": "5.2.0",
        "borsh": "^0.6.0",
        "bs58": "^4.0.0",
        "depd": "^2.0.0",
        "error-polyfill": "^0.1.3",
        "http-errors": "^1.7.2",
        "js-sha256": "^0.9.0",
        "mustache": "^4.0.0",
        "node-fetch": "^2.6.1",
        "text-encoding-utf-8": "^1.0.2",
        "tweetnacl": "^1.0.1"
      }
    },
    "node_modules/node-fetch": {
      "version": "2.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz",
      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
      "dependencies": {
        "whatwg-url": "^5.0.0"
      },
      "engines": {
        "node": "4.x || >=6.0.0"
      },
      "peerDependencies": {
        "encoding": "^0.1.0"
      },
      "peerDependenciesMeta": {
        "encoding": {
          "optional": true
        }
      }
    },
    "node_modules/o3": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
      "integrity": "sha1-GSzod6iC36Z1HwQSqGX6+y2h2sA=",
      "dependencies": {
        "capability": "^0.2.5"
      }
    },
    "node_modules/safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
      "funding": [
        {
          "type": "github",
          "url": "https://github.com/sponsors/feross"
        },
        {
          "type": "patreon",
          "url": "https://www.patreon.com/feross"
        },
        {
          "type": "consulting",
          "url": "https://feross.org/support"
        }
      ]
    },
    "node_modules/setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "node_modules/statuses": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
      "integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow=",
      "engines": {
        "node": ">= 0.6"
      }
    },
    "node_modules/text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "node_modules/toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
      "engines": {
        "node": ">=0.6"
      }
    },
    "node_modules/tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha1-gYT9NH2snNwYWZLzpmIuFLnZq2o="
    },
    "node_modules/tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "node_modules/u3": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/u3/-/u3-0.1.1.tgz",
      "integrity": "sha512-+J5D5ir763y+Am/QY6hXNRlwljIeRMZMGs0cT6qqZVVzzT3X3nFPXVyPOFRMOR4kupB0T8JnCdpWdp6Q/iXn3w=="
    },
    "node_modules/webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha1-JFNCdeKnvGvnvIZhHMFq4KVlSHE="
    },
    "node_modules/whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha1-lmRU6HZUYuN2RNNib2dCzotwll0=",
      "dependencies": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    }
  },
  "dependencies": {
    "base-x": {
      "version": "3.0.9",
      "resolved": "https://registry.npmjs.org/base-x/-/base-x-3.0.9.tgz",
      "integrity": "sha512-H7JU6iBHTal1gp56aKoaa//YUxEaAOUiydvrV/pILqIHXTtqxSkATOnDA2u+jZ/61sD+L/412+7kzXRtWukhpQ==",
      "requires": {
        "safe-buffer": "^5.0.1"
      }
    },
    "bn.js": {
      "version": "5.2.0",
      "resolved": "https://registry.npmjs.org/bn.js/-/bn.js-5.2.0.tgz",
      "integrity": "sha512-D7iWRBvnZE8ecXiLj/9wbxH7Tk79fAh8IHaTNq1RWRixsS02W+5qS+iE9yq6RYl0asXx5tw0bLhmT5pIfbSquw=="
    },
    "borsh": {
      "version": "0.6.0",
      "resolved": "https://registry.npmjs.org/borsh/-/borsh-0.6.0.tgz",
      "integrity": "sha512-sl5k89ViqsThXQpYa9XDtz1sBl3l1lI313cFUY1HKr+wvMILnb+58xpkqTNrYbelh99dY7K8usxoCusQmqix9Q==",
      "requires": {
        "bn.js": "^5.2.0",
        "bs58": "^4.0.0",
        "text-encoding-utf-8": "^1.0.2"
      }
    },
    "bs58": {
      "version": "4.0.1",
      "resolved": "https://registry.npmjs.org/bs58/-/bs58-4.0.1.tgz",
      "integrity": "sha1-vhYedsNU9veIrkBx9j806MTwpCo=",
      "requires": {
        "base-x": "^3.0.2"
      }
    },
    "capability": {
      "version": "0.2.5",
      "resolved": "https://registry.npmjs.org/capability/-/capability-0.2.5.tgz",
      "integrity": "sha1-Ua2HNT8ZNv/Xfy8hx0YzpN6oiAE="
    },
    "depd": {
      "version": "2.0.0",
      "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
      "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw=="
    },
    "error-polyfill": {
      "version": "0.1.3",
      "resolved": "https://registry.npmjs.org/error-polyfill/-/error-polyfill-0.1.3.tgz",
      "integrity": "sha512-XHJk60ufE+TG/ydwp4lilOog549iiQF2OAPhkk9DdiYWMrltz5yhDz/xnKuenNwP7gy3dsibssO5QpVhkrSzzg==",
      "requires": {
        "capability": "^0.2.5",
        "o3": "^1.0.3",
        "u3": "^0.1.1"
      }
    },
    "http-errors": {
      "version": "1.8.1",
      "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-1.8.1.tgz",
      "integrity": "sha512-Kpk9Sm7NmI+RHhnj6OIWDI1d6fIoFAtFt9RLaTMRlg/8w49juAStsrBgp0Dp4OdxdVbRIeKhtCUvoi/RuAhO4g==",
      "requires": {
        "depd": "~1.1.2",
        "inherits": "2.0.4",
        "setprototypeof": "1.2.0",
        "statuses": ">= 1.5.0 < 2",
        "toidentifier": "1.0.1"
      },
      "dependencies": {
        "depd": {
          "version": "1.1.2",
          "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
          "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak="
        }
      }
    },
    "inherits": {
      "version": "2.0.4",
      "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
      "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ=="
    },
    "js-sha256": {
      "version": "0.9.0",
      "resolved": "https://registry.npmjs.org/js-sha256/-/js-sha256-0.9.0.tgz",
      "integrity": "sha512-sga3MHh9sgQN2+pJ9VYZ+1LPwXOxuBJBA5nrR5/ofPfuiJBE2hnjsaN8se8JznOmGLN2p49Pe5U/ttafcs/apA=="
    },
    "mustache": {
      "version": "4.2.0",
      "resolved": "https://registry.npmjs.org/mustache/-/mustache-4.2.0.tgz",
      "integrity": "sha512-71ippSywq5Yb7/tVYyGbkBggbU8H3u5Rz56fH60jGFgr8uHwxs+aSKeqmluIVzM0m0kB7xQjKS6qPfd0b2ZoqQ=="
    },
    "near-api-js": {
      "version": "0.44.2",
      "resolved": "https://registry.npmjs.org/near-api-js/-/near-api-js-0.44.2.tgz",
      "integrity": "sha512-eMnc4V+geggapEUa3nU2p8HSHn/njtloI4P2mceHQWO8vDE1NGpnAw8FuTBrLmXSgIv9m6oocgFc9t3VNf5zwg==",
      "requires": {
        "bn.js": "5.2.0",
        "borsh": "^0.6.0",
        "bs58": "^4.0.0",
        "depd": "^2.0.0",
        "error-polyfill": "^0.1.3",
        "http-errors": "^1.7.2",
        "js-sha256": "^0.9.0",
        "mustache": "^4.0.0",
        "node-fetch": "^2.6.1",
        "text-encoding-utf-8": "^1.0.2",
        "tweetnacl": "^1.0.1"
      }
    },
    "node-fetch": {
      "version": "2.6.7",
      "resolved": "https://registry.npmjs.org/node-fetch/-/node-fetch-2.6.7.tgz",
      "integrity": "sha512-ZjMPFEfVx5j+y2yF35Kzx5sF7kDzxuDj6ziH4FFbOp87zKDZNx8yExJIb05OGF4Nlt9IHFIMBkRl41VdvcNdbQ==",
      "requires": {
        "whatwg-url": "^5.0.0"
      }
    },
    "o3": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/o3/-/o3-1.0.3.tgz",
      "integrity": "sha1-GSzod6iC36Z1HwQSqGX6+y2h2sA=",
      "requires": {
        "capability": "^0.2.5"
      }
    },
    "safe-buffer": {
      "version": "5.2.1",
      "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
      "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ=="
    },
    "setprototypeof": {
      "version": "1.2.0",
      "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
      "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw=="
    },
    "statuses": {
      "version": "1.5.0",
      "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
      "integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow="
    },
    "text-encoding-utf-8": {
      "version": "1.0.2",
      "resolved": "https://registry.npmjs.org/text-encoding-utf-8/-/text-encoding-utf-8-1.0.2.tgz",
      "integrity": "sha512-8bw4MY9WjdsD2aMtO0OzOCY3pXGYNx2d2FfHRVUKkiCPDWjKuOlhLVASS+pD7VkLTVjW268LYJHwsnPFlBpbAg=="
    },
    "toidentifier": {
      "version": "1.0.1",
      "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
      "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA=="
    },
    "tr46": {
      "version": "0.0.3",
      "resolved": "https://registry.npmjs.org/tr46/-/tr46-0.0.3.tgz",
      "integrity": "sha1-gYT9NH2snNwYWZLzpmIuFLnZq2o="
    },
    "tweetnacl": {
      "version": "1.0.3",
      "resolved": "https://registry.npmjs.org/tweetnacl/-/tweetnacl-1.0.3.tgz",
      "integrity": "sha512-6rt+RN7aOi1nGMyC4Xa5DdYiukl2UWCbcJft7YhxReBGQD7OAM8Pbxw6YMo4r2diNEA8FEmu32YOn9rhaiE5yw=="
    },
    "u3": {
      "version": "0.1.1",
      "resolved": "https://registry.npmjs.org/u3/-/u3-0.1.1.tgz",
      "integrity": "sha512-+J5D5ir763y+Am/QY6hXNRlwljIeRMZMGs0cT6qqZVVzzT3X3nFPXVyPOFRMOR4kupB0T8JnCdpWdp6Q/iXn3w=="
    },
    "webidl-conversions": {
      "version": "3.0.1",
      "resolved": "https://registry.npmjs.org/webidl-conversions/-/webidl-conversions-3.0.1.tgz",
      "integrity": "sha1-JFNCdeKnvGvnvIZhHMFq4KVlSHE="
    },
    "whatwg-url": {
      "version": "5.0.0",
      "resolved": "https://registry.npmjs.org/whatwg-url/-/whatwg-url-5.0.0.tgz",
      "integrity": "sha1-lmRU6HZUYuN2RNNib2dCzotwll0=",
      "requires": {
        "tr46": "~0.0.3",
        "webidl-conversions": "^3.0.0"
      }
    }
  }
}

'''
'''--- package.json ---
{
  "scripts": {
    "build": "./compile.sh",
    "deploy": "./compile.sh && node ./script/01_deploy_token.js"
  },
  "dependencies": {
    "near-api-js": "^0.44.2"
  }
}

'''
'''--- script/01_deploy_token.js ---
const { keyStores, connect } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const ACCOUNT_ID = "xpnx.testnet";
const WASM_PATH = "target/wasm32-unknown-unknown/release/x_phoenix_token.wasm";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

async function main() {
    const near = await connect(config);
    const account = await near.account(ACCOUNT_ID);
    const result = await account.deployContract(fs.readFileSync(WASM_PATH));
    console.log(result);
}
main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });

'''
'''--- script/02_init.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const ACCOUNT_ID = "xpnx.testnet";
const ACCOUNT_LOCKED = "pnx.zus.testnet";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

async function main() {
    const near = await connect(config);
    const account = await near.account(ACCOUNT_ID);
    const result = await account.functionCall({
      contractId: ACCOUNT_ID,
      methodName: "new",
      args: {'owner_id': ACCOUNT_ID, 'locked_token': ACCOUNT_LOCKED}
    })
    console.log(result);
}
main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });

'''
'''--- script/03_stake.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const INCA_CONTRACT = "pnx.zus.testnet";
const XINCA_CONTRACT = "xpnx.testnet";
const ACCOUNT_ID = "inti02.testnet";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);
// converts NEAR amount into yoctoNEAR (10^-24)

const amountInYocto = utils.format.parseNearAmount("0.0125");
const ftAttachAmount = utils.format.parseNearAmount("1");

const config = {
    keyStore,
    networkId: "testnet",
    nodeUrl: "https://rpc.testnet.near.org",
};

async function main() {
    const near = await connect(config);
    const account = await near.account(ACCOUNT_ID);
    console.log('getAccountDetails', await account.getAccountDetails());
    const storage_balance = await account.viewFunction(XINCA_CONTRACT, "storage_balance_of", {"account_id": ACCOUNT_ID});
    console.log('storage_balance', storage_balance);
    if (storage_balance == null) {
        const storage_deposit = await account.functionCall({
            contractId: XINCA_CONTRACT,
            methodName: 'storage_deposit',
            args: {"account_id": ACCOUNT_ID, "registration_only": true},
            attachedDeposit: amountInYocto
        })
        console.log('storage_deposit', storage_deposit);
    }

    const result = await account.functionCall({
        contractId: INCA_CONTRACT,
        methodName: "ft_transfer_call",
        args: {
            receiver_id: XINCA_CONTRACT,
            amount: '10000000000000000000',
            msg: ''
        },
        attachedDeposit: '1',
        gas: "300000000000000",
    });
    console.log(result);
}
main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });

'''
'''--- script/04_owner_scripts.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const INCA_CONTRACT = "pnx.zus.testnet";
const XINCA_CONTRACT = "xpnx.testnet";
const ACCOUNT_ID = "inti01.testnet";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};
//
async function main() {
  const near = await connect(config);
  const account = await near.account(XINCA_CONTRACT);
  const result = await account.functionCall({
    contractId: XINCA_CONTRACT,
    methodName: "modify_reward_per_sec",
    args: {
      'reward_per_sec': "500000000000000", // 0.0005
      'distribute_before_change': true
    },
    gas: "300000000000000",
  })
  console.log(result);
}
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
'''
'''--- script/05.unstake.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const INCA_CONTRACT = "pnx.zus.testnet";
const XINCA_CONTRACT = "xpnx.testnet";
const ACCOUNT_ID = "inti25.testnet";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);
// converts NEAR amount into yoctoNEAR (10^-24)

const amountInYocto = utils.format.parseNearAmount("0.0125");
const ftAttachAmount = utils.format.parseNearAmount("1");

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

async function main() {
  const near = await connect(config);
  const account = await near.account(ACCOUNT_ID);

  const result = await account.functionCall({
    contractId: XINCA_CONTRACT,
    methodName: "unstake",
    args: {
      amount: '10000000000000000000',
    },
    attachedDeposit: '1',
    gas: "300000000000000",
  });
  console.log(result);
}
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
'''
'''--- script/deploy.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' near deploy --wasmFile target/wasm32-unknown-unknown/release/phoenix_token.wasm --accountId zus.testnet

'''
'''--- script/main.js ---
const nearAPI = require("near-api-js");

async function main() {
    console.log("hello")

    // creates keyStore from a private key string
    // you can define your key here or use an environment variable

    const { keyStores, KeyPair, connect, WalletConnection, providers } = nearAPI;
    const keyStore = new keyStores.InMemoryKeyStore();
    const PRIVATE_KEY = "3XnoQybjR5nuVuP61nQenUyXNtoFwxSXdi9iTrFafre3s1ra7ozxEgvpBcZgekvwJiSQU3XAKAuq23VEsEjEs8oY";
    // creates a public / private key pair using the provided private key
    const keyPair = KeyPair.fromString(PRIVATE_KEY);
    // adds the keyPair you created to keyStore
    await keyStore.setKey("testnet", "pnx_token.zus.testnet", keyPair);

    const config = {
        networkId: "testnet",
        keyStore, // optional if not signing transactions
        nodeUrl: "https://rpc.testnet.near.org",
        walletUrl: "https://wallet.testnet.near.org",
        helperUrl: "https://helper.testnet.near.org",
        explorerUrl: "https://explorer.testnet.near.org",
    };
    const near = await connect(config);

    const account = await near.account("pnx_token.zus.testnet");
    let balance = await account.getAccountBalance();

    console.log("balance", balance);
    console.log("Detail", await account.getAccountDetails());

    const provider = new providers.JsonRpcProvider(
        "https://archival-rpc.testnet.near.org"
    );

    const TX_HASH = "A6utqRDa5CisafD1975MBk9to7t8RS1U4g78TvDmGKGK";

    const result = await provider.txStatus(TX_HASH, "pnx_token.zus.testnet");
    console.log("Result: ", result);

}
main()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });

'''
'''--- script/test_local.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable test -- --nocapture

'''
'''--- script/view.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const fs = require("fs");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const INCA_CONTRACT = "pnx.zus.testnet";
const XINCA_CONTRACT = "xpnx.testnet";
const ACCOUNT_ID = "inti02.testnet";

const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
};

async function main() {
  const near = await connect(config);
  const account = await near.account(ACCOUNT_ID);
  // view INTI Token Contract
  let result = await account.viewFunction(INCA_CONTRACT, "ft_metadata");
  console.log(result);
  // view xINTI Token Contract
  result = await account.viewFunction(XINCA_CONTRACT, "ft_metadata");
  console.log(result);

  result = await account.viewFunction(XINCA_CONTRACT, "get_virtual_price");
  console.log('Price = ', result / 100000000);

}
main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });
'''
'''--- src/lib.rs ---
/*!
 * xINT NEP-141 Token contract
 *
 */
// use std::iter::Map;
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId, U128};
// Needed by `impl_fungible_token_core` for old Rust.
#[allow(unused_imports)]
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};
use near_sdk::borsh::maybestd::collections::LinkedList;
// use crate::utils::DURATION_30DAYS_IN_SEC;
use crate::utils::DURATION_1H_IN_SEC;
pub use crate::utils::nano_to_sec;
pub use crate::views::ContractMetadata;

mod xpnx;
mod utils;
mod owner;
mod views;
mod storage_impl;

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub ft: FungibleToken,
    pub owner_id: AccountId,
    pub locked_token: AccountId,
    /// deposit reward that does not distribute to locked REF yet
    pub undistributed_reward: Balance,
    /// locked amount
    pub locked_token_amount: Balance,
    /// the previous distribution time in seconds
    pub prev_distribution_time_in_sec: u32,
    /// when would the reward starts to distribute
    pub reward_genesis_time_in_sec: u32,
    pub reward_per_sec: Balance,
    /// current account number in contract
    pub account_number: u64,
    pub account_list: LinkedList<AccountId>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: ValidAccountId, locked_token: ValidAccountId) -> Self {
        let initial_reward_genisis_time = DURATION_1H_IN_SEC + nano_to_sec(env::block_timestamp());
        Contract {
            ft: FungibleToken::new(b"a".to_vec()),
            owner_id: owner_id.into(),
            locked_token: locked_token.into(),
            undistributed_reward: 0,
            locked_token_amount: 0,
            prev_distribution_time_in_sec: initial_reward_genisis_time,
            reward_genesis_time_in_sec: initial_reward_genisis_time,
            reward_per_sec: 0,
            account_number: 0,
            account_list: LinkedList::new(),
        }
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, ft);
const DATA_IMAGE_SVG_PNX_ICON: &str = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDAiIGhlaWdodD0iNDAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PGNpcmNsZSBjeD0iMjAiIGN5PSIyMCIgcj0iMjAiIGZpbGw9IiMwNzA2MzgiLz48cGF0aCBkPSJNMjguNDU1IDI5LjczMmMtMi41MTQgMi44NTUtNy4wNSA2LjEyLTExLjAxNyA2LjE1My0yLjUxNy0uMzI0LTQuODM3LTEuMTE2LTYuODE1LTIuMjYyIDIuNTAyLjE3NCA1LjUxNS0uMjc3IDguNDI3LTEuNzkgMS4zOTktLjYwNSAzLjYzMy0yLjIzOCAzLjcxOC0yLjI5Ny0uMDY2LjAzNy0yLjQ5IDEuNDgyLTMuOTQ2IDEuOTY1LTQuMzQ0IDEuNzkxLTguNjQ3IDEuMzEyLTEwLjc2Mi4yNzItMi40OTktMi4yMzgtNC4wMy01LjE4LTQuMDYtOC40MS4zMyAzLjEwMyA1Ljg4OCA2LjI1NCAxMS41NCA1LjEyNyA2LjQtMS4yNzcgMTAuNzM0LTcuNjQ1IDE1LjgzNC04LjQxNCAxLjE1OS0uMTc1IDIuNDY2LS4wNyAzLjM2Ny41MzggMS4wNzUuNzI2IDEuMjI3IDEuNTUgMS4yNTUgMi42NTIuMTc5IDYuNjktNi40MzUgMTIuMTc5LTE0LjYzIDEyLjczNCAyLjg4My0xLjQwOSA1LjQzNy0zLjg2NSA3LjA4OS02LjI2OFoiIGZpbGw9InVybCgjYSkiLz48cGF0aCBkPSJNMTEuNTQ1IDEwLjI2OGMyLjUxNC0yLjg1NSA3LjA1LTYuMTIgMTEuMDE3LTYuMTUzIDIuNTE3LjMyMyA0LjgzNyAxLjExNiA2LjgxNSAyLjI2Mi0yLjUwMi0uMTc0LTUuNTE1LjI3Ny04LjQyNyAxLjc5LTEuMzk5LjYwNS0zLjYzMyAyLjIzOC0zLjcxOCAyLjI5Ny4wNjYtLjAzNyAyLjQ5LTEuNDgyIDMuOTQ2LTEuOTY1IDQuMzQ0LTEuNzkxIDguNjQ4LTEuMzEyIDEwLjc2Mi0uMjcyIDIuNDk5IDIuMjM4IDQuMDMgNS4xOCA0LjA2IDguNDEtLjMzLTMuMTAzLTUuODg4LTYuMjU0LTExLjU0LTUuMTI3LTYuNCAxLjI3Ny0xMC43MzMgNy42NDUtMTUuODM0IDguNDE0LTEuMTU5LjE3NS0yLjQ2Ni4wNy0zLjM2Ny0uNTM4LTEuMDc1LS43MjYtMS4yMjctMS41NS0xLjI1NS0yLjY1Mi0uMTc5LTYuNjkgNi40MzUtMTIuMTggMTQuNjMtMTIuNzM0LTIuODgzIDEuNDA5LTUuNDM3IDMuODY1LTcuMDg5IDYuMjY4WiIgZmlsbD0idXJsKCNiKSIvPjxkZWZzPjxsaW5lYXJHcmFkaWVudCBpZD0iYSIgeDE9IjM2IiB5MT0iMjgiIHgyPSI5LjU1NiIgeTI9IjI4IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+PHN0b3Agc3RvcC1jb2xvcj0iIzAwRjhEQiIvPjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzA4RjhDQyIvPjwvbGluZWFyR3JhZGllbnQ+PGxpbmVhckdyYWRpZW50IGlkPSJiIiB4MT0iNCIgeTE9IjEyIiB4Mj0iMzAuNDQ0IiB5Mj0iMTIiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj48c3RvcCBzdG9wLWNvbG9yPSIjMDBGOERCIi8+PHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDhGOENDIi8+PC9saW5lYXJHcmFkaWVudD48L2RlZnM+PC9zdmc+";
#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        let data_url = DATA_IMAGE_SVG_PNX_ICON;
        FungibleTokenMetadata {
            spec: FT_METADATA_SPEC.to_string(),
            name: String::from("XPNX Token"),
            symbol: String::from("XPNX"),
            icon: Some(String::from(data_url)),
            reference: None,
            reference_hash: None,
            decimals: 18,
        }
    }
}

'''
'''--- src/owner.rs ---
//! Implement all the relevant logic for owner of this contract.

use crate::*;
// use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
// use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_sdk::json_types::U128;
use near_sdk::{log};
// use std::cmp::{max, min};
use crate::utils::{nano_to_sec};
#[near_bindgen]
impl Contract {
    /// Change owner. Only can be called by owner.
    pub fn set_owner(&mut self, owner_id: ValidAccountId) {
        self.assert_owner();
        self.owner_id = owner_id.as_ref().clone();
    }

    /// Get the owner of this account.
    pub fn get_owner(&self) -> AccountId {
        self.owner_id.clone()
    }

    pub fn modify_reward_per_sec(&mut self, reward_per_sec: U128, distribute_before_change: bool) {
        self.assert_owner();
        if distribute_before_change {
            self.distribute_reward();
        }
        self.reward_per_sec = reward_per_sec.into();
    }

    pub fn reset_reward_genesis_time_in_sec(&mut self, reward_genesis_time_in_sec: u32) {
        self.assert_owner();
        let cur_time = nano_to_sec(env::block_timestamp());
        log!("cur_time = {} reward_genesis_time_in_sec = {} ", cur_time, reward_genesis_time_in_sec);
        if reward_genesis_time_in_sec < cur_time {
            env::panic(b"ERR_RESET_TIME_IS_PAST_TIME");
        } else if self.reward_genesis_time_in_sec < cur_time {
            env::panic(b"ERR_REWARD_GENESIS_TIME_PASSED");
        }
        self.reward_genesis_time_in_sec = reward_genesis_time_in_sec;
        self.prev_distribution_time_in_sec = reward_genesis_time_in_sec;
    }

    pub fn compound_reward(&mut self) {
        self.assert_owner();
        self.compound();
    }

    pub(crate) fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "ERR_NOT_ALLOWED"
        );
    }

    /// Migration function.
    /// For next version upgrades, change this function.
    #[init(ignore_state)]
    #[private]
    pub fn migrate() -> Self {
        let prev: Contract = env::state_read().expect("ERR_NOT_INITIALIZED");
        prev
    }
}

#[cfg(target_arch = "wasm32")]
mod upgrade {
    use near_sdk::env::BLOCKCHAIN_INTERFACE;
    use near_sdk::Gas;

    use super::*;

    const BLOCKCHAIN_INTERFACE_NOT_SET_ERR: &str = "Blockchain interface not set.";

    /// Gas for calling migration call.
    pub const GAS_FOR_MIGRATE_CALL: Gas = 5_000_000_000_000;

    /// Self upgrade and call migrate, optimizes gas by not loading into memory the code.
    /// Takes as input non serialized set of bytes of the code.
    #[no_mangle]
    pub extern "C" fn upgrade() {
        env::setup_panic_hook();
        env::set_blockchain_interface(Box::new(near_blockchain::NearBlockchain {}));
        let contract: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        contract.assert_owner();
        let current_id = env::current_account_id().into_bytes();
        let method_name = "migrate".as_bytes().to_vec();
        unsafe {
            BLOCKCHAIN_INTERFACE.with(|b| {
                // Load input into register 0.
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .input(0);
                let promise_id = b
                    .borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_create(current_id.len() as _, current_id.as_ptr() as _);
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);
                let attached_gas = env::prepaid_gas() - env::used_gas() - GAS_FOR_MIGRATE_CALL;
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_function_call(
                        promise_id,
                        method_name.len() as _,
                        method_name.as_ptr() as _,
                        0 as _,
                        0 as _,
                        0 as _,
                        attached_gas,
                    );
            });
        }
    }

}

'''
'''--- src/storage_impl.rs ---
use crate::*;
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};

use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::near_bindgen;

#[near_bindgen]
impl StorageManagement for Contract {
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        let local_account_id =
            account_id.clone().map(|a| a.into()).unwrap_or_else(|| env::predecessor_account_id());
        if !self.ft.accounts.contains_key(&local_account_id) {
            self.account_number += 1;
            self.account_list.push_back(local_account_id);
        }
        self.ft.storage_deposit(account_id, registration_only)
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        self.ft.storage_withdraw(amount)
    }

    #[payable]
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        #[allow(unused_variables)]
        if let Some((account_id, balance)) = self.ft.internal_storage_unregister(force) {
            let number = self.account_number.checked_sub(1).unwrap_or(0);
            self.account_number = number;
            true
        } else {
            false
        }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        self.ft.storage_balance_bounds()
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        self.ft.storage_balance_of(account_id)
    }
}
'''
'''--- src/utils.rs ---

use near_sdk::json_types::U128;
use near_sdk::{ext_contract, Gas, Timestamp};
use uint::construct_uint;

/// Attach no deposit.
pub const NO_DEPOSIT: u128 = 0;

pub const GAS_FOR_RESOLVE_TRANSFER: Gas = 10_000_000_000_000;

pub const GAS_FOR_FT_TRANSFER: Gas = 20_000_000_000_000;

// pub const DURATION_30DAYS_IN_SEC: u32 = 60 * 60 * 24 * 30;

pub const DURATION_1H_IN_SEC: u32 = 60 * 60;

construct_uint! {
    pub struct U256(4);
}

pub fn nano_to_sec(nano: Timestamp) -> u32 {
    (nano / 1_000_000_000) as u32
}

#[ext_contract(ext_self)]
pub trait XINT {
    fn callback_post_unstake(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        share: U128,
    );
}

'''
'''--- src/views.rs ---
//! View functions for the contract.

use crate::*;
use near_sdk::serde::{Serialize};

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Deserialize, Debug))]
pub struct ContractMetadata {
    pub version: String,
    pub owner_id: AccountId,
    pub locked_token: AccountId,
    // at prev_distribution_time, the amount of undistributed reward
    pub undistributed_reward: U128,
    // at prev_distribution_time, the amount of staked token
    pub locked_token_amount: U128,
    // at call time, the amount of undistributed reward
    pub cur_undistributed_reward: U128,
    // at call time, the amount of staked token
    pub cur_locked_token_amount: U128,
    pub supply: U128,
    pub prev_distribution_time_in_sec: u32,
    pub reward_genesis_time_in_sec: u32,
    pub reward_per_sec: U128,
    /// current account number in contract
    pub account_number: u64,
    pub total_supply: Balance,
    pub account_list: String
}

#[near_bindgen]
impl Contract {
    /// Return contract basic info
    pub fn contract_metadata(&self) -> ContractMetadata {
        let to_be_distributed =
            self.try_distribute_reward(nano_to_sec(env::block_timestamp()));
        // only update version number here
        ContractMetadata {
            version: env!("CARGO_PKG_VERSION").to_string(),
            owner_id: self.owner_id.clone(),
            locked_token: self.locked_token.clone(),
            undistributed_reward: self.undistributed_reward.into(),
            locked_token_amount: self.locked_token_amount.into(),
            cur_undistributed_reward: (self.undistributed_reward - to_be_distributed).into(),
            cur_locked_token_amount: (self.locked_token_amount + to_be_distributed).into(),
            supply: self.ft.total_supply.into(),
            prev_distribution_time_in_sec: self.prev_distribution_time_in_sec,
            reward_genesis_time_in_sec: self.reward_genesis_time_in_sec,
            reward_per_sec: self.reward_per_sec.into(),
            account_number: self.account_number,
            total_supply: self.ft.total_supply,
            account_list: self.get_account_list(),
        }
    }

    pub fn get_virtual_price(&self) -> U128 {
        if self.ft.total_supply == 0 {
            100_000_000.into()
        } else {
            ((self.locked_token_amount
                + self.try_distribute_reward(nano_to_sec(env::block_timestamp())))
                * 100_000_000
                / self.ft.total_supply)
                .into()
        }
    }

    pub(crate) fn get_account_list(&self) -> String {
        let mut result:String = String::new();
        for account in self.account_list.clone() {
            result.push_str(account.as_str());
            result.push_str(",");
        }
        return result;
    }
}

'''
'''--- src/xpnx.rs ---
use crate::*;
use crate::utils::{ext_self, U256, GAS_FOR_FT_TRANSFER, GAS_FOR_RESOLVE_TRANSFER, NO_DEPOSIT, nano_to_sec};
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_contract_standards::fungible_token::core_impl::ext_fungible_token;
use near_sdk::json_types::U128;
use near_sdk::{assert_one_yocto, env, log, Promise, PromiseResult};
use std::cmp::{max, min};

impl Contract {
    pub fn internal_stake(&mut self, account_id: &AccountId, amount: Balance) {
        // check account has registered
        assert!(self.ft.accounts.contains_key(account_id), "Account not registered.");
        self.compound();
        let mut minted = amount;
        if self.ft.total_supply != 0 {
            assert!(self.locked_token_amount > 0, "ERR_INTERNAL");
            minted = (U256::from(amount) * U256::from(self.ft.total_supply) / U256::from(self.locked_token_amount)).as_u128();
        }

        assert!(minted > 0, "ERR_STAKE_TOO_SMALL");

        self.locked_token_amount += amount;
        self.ft.internal_deposit(account_id, minted);
        log!("{} Stake {} assets, get {} token", account_id, amount, minted);
    }

    pub fn internal_add_reward(&mut self, account_id: &AccountId, amount: Balance) {
        self.undistributed_reward += amount;
        log!("{} add {} assets as reward", account_id, amount);
    }

    /// return the amount of to be distribute reward this time
    pub(crate) fn try_distribute_reward(&self, cur_timestamp_in_sec: u32) -> Balance {
        if cur_timestamp_in_sec > self.reward_genesis_time_in_sec && cur_timestamp_in_sec > self.prev_distribution_time_in_sec {
            let ideal_amount = self.reward_per_sec * (cur_timestamp_in_sec - self.prev_distribution_time_in_sec) as u128;
            log!("try_distribute_reward self.reward_per_sec = {}", self.reward_per_sec);
            log!("try_distribute_reward cur_timestamp_in_sec - self.prev_distribution_time_in_sec = {}", cur_timestamp_in_sec - self.prev_distribution_time_in_sec);
            min(ideal_amount, self.undistributed_reward)
        } else {
            0
        }
    }

    pub(crate) fn distribute_reward(&mut self) {
        let cur_time = nano_to_sec(env::block_timestamp());
        let new_reward = self.try_distribute_reward(cur_time);
        if new_reward > 0 {
            self.undistributed_reward -= new_reward;
            self.locked_token_amount += new_reward;
        }
        self.prev_distribution_time_in_sec = max(cur_time, self.reward_genesis_time_in_sec);
    }

    pub(crate) fn compound(&mut self) {
        let cur_time = nano_to_sec(env::block_timestamp());
        let current_reward = self.try_distribute_reward(cur_time);
        let mut size = 0;
        for account in self.account_list.clone() {
            log!("account id ={}, current_reward = {}", account, current_reward);
            if  current_reward > 0 {
                self.ft.internal_deposit(&account, current_reward);
                size += 1;
            }
        }
        log!("compound_reward current_reward = {}", current_reward);
        if current_reward > 0 && size > 0 {
            self.undistributed_reward -= current_reward * size;
            self.locked_token_amount += current_reward * size;
        }
        self.prev_distribution_time_in_sec = max(cur_time, self.reward_genesis_time_in_sec);
    }
}

#[near_bindgen]
impl Contract {

    /// unstake token and send assets back to the predecessor account.
    /// Requirements:
    /// * The predecessor account should be registered.
    /// * `amount` must be a positive integer.
    /// * The predecessor account should have at least the `amount` of tokens.
    /// * Requires attached deposit of exactly 1 yoctoNEAR.
    #[payable]
    pub fn unstake(&mut self, amount: U128) -> Promise {
        // Checkpoint
        self.distribute_reward();

        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let amount: Balance = amount.into();

        assert!(self.ft.total_supply > 0, "ERR_EMPTY_TOTAL_SUPPLY");
        let unlocked = (U256::from(amount) * U256::from(self.locked_token_amount) / U256::from(self.ft.total_supply)).as_u128();

        self.ft.internal_withdraw(&account_id, amount);
        // assert!(self.ft.total_supply >= 10u128.pow(18), "ERR_KEEP_AT_LEAST_ONE_XPNX");
        self.locked_token_amount -= unlocked;

        log!("Withdraw {} NEAR from {}", amount, account_id);

        ext_fungible_token::ft_transfer(
            account_id.clone(),
            U128(unlocked),
            None,
            &self.locked_token,
            1,
            GAS_FOR_FT_TRANSFER,
        )
            .then(ext_self::callback_post_unstake(
                account_id.clone(),
                U128(unlocked),
                U128(amount),
                &env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_RESOLVE_TRANSFER,
            ))
    }

    #[private]
    pub fn callback_post_unstake(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        share: U128,
    ) {
        assert_eq!(
            env::promise_results_count(),
            1,
            "Err: expected 1 promise result from unstake"
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_) => {}
            PromiseResult::Failed => {
                // This reverts the changes from unstake function.
                // If account doesn't exit, the unlock token stay in contract.
                if self.ft.accounts.contains_key(&sender_id) {
                    self.locked_token_amount += amount.0;
                    self.ft.internal_deposit(&sender_id, share.0);
                    env::log(
                        format!(
                            "Account {} unstake failed and reverted.",
                            sender_id
                        )
                            .as_bytes(),
                    );
                } else {
                    env::log(
                        format!(
                            "Account {} has unregisterd. unlocking token goes to contract.",
                            sender_id
                        )
                            .as_bytes(),
                    );
                }
            }
        };
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// Callback on receiving tokens by this contract.
    fn ft_on_transfer(
        &mut self,
        sender_id: ValidAccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        // Checkpoint
        self.distribute_reward();
        let token_in = env::predecessor_account_id();
        let amount: Balance = amount.into();
        assert_eq!(token_in, self.locked_token, "ERR_ILLEGAL_TOKEN");
        if msg.is_empty() {
            // user stake.
            self.internal_stake(sender_id.as_ref(), amount);
            PromiseOrValue::Value(U128(0))
        } else {
            // deposit reward
            log!("Add reward {} token with msg {}", amount, msg);
            self.internal_add_reward(sender_id.as_ref(), amount);
            PromiseOrValue::Value(U128(0))
        }
    }
}
'''