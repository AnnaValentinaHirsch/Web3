*GitHub Repository "nguyenduyhuong/meme"*

'''--- .github/workflows/test.yml ---
name: CI
on: 
  repository_dispatch:
    types: [tests-report]
  push:
jobs:
  test:
    runs-on: ubuntu-latest
    env:
      RUST_BACKTRACE: 1
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable-2020-10-08
          target: wasm32-unknown-unknown

      - name: Add wasm32 target
        run: rustup target add wasm32-unknown-unknown

      - name: Check that build works
        run: ./build.sh
        # TODO: check that files in `res` are unchanged

      - name: Test
        uses: actions-rs/cargo@v1
        with:
          command: test

'''
'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: echo "nvm use default" >> ~/.bashrc && npm install -g near-cli --no-optional && nvm use default
    init: yarn
    command: clear && echo Hey! Check out examples of how to build a NEP-21 Fungible Token in Rust.

'''
'''--- Cargo.toml ---
[package]
name = "fungible-token-wrapper"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[dev-dependencies]
near-sdk = "4.0.0-pre.6"
near-sdk-sim = "4.0.0-pre.6"

# remember to include a line for each contract
fungible-token = { path = "./ft" }
defi = { path = "./test-contract-defi" }
addliquid = { path = "./add_liquid" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "ft",
  "test-contract-defi",
  "add_liquid"
]

'''
'''--- README-Windows.md ---
Fungible Token (FT)
===================

Example implementation of a [Fungible Token] contract which uses [near-contract-standards] and [simulation] tests. This is a contract-only example.

**Note**: this README is specific to Windows and this example. For development on OS X or Linux, please see [README.md](README.md).

  [Fungible Token]: https://nomicon.io/Standards/Tokens/FungibleTokenCore.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

Prerequisites
=============

If you're using Gitpod, you can skip this step.

1. Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs#pre-requisites)
2. Ensure `near-cli` is installed by running `near --version`. If not installed, install with: `npm install --global near-cli`

## Building

To build run in CMD:
```bash
build.bat
```

Using this contract
===================

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions on [NEAR Wallet](https://wallet.near.org/).

Switch to `mainnet`. You can skip this step to use `testnet` as a default network.

    set NEAR_ENV=mainnet

In the project root, log in to your newly created account  with `near-cli` by following the instructions after this command:

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name you just logged in with, including the `.near`:

    set ID=MY_ACCOUNT_NAME

You can tell if the environment variable is set correctly if your command line prints the account name after this command:

    echo %ID%

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/fungible_token.wasm --accountId %ID%

FT contract should be initialized before usage. You can read more about metadata at ['nomicon.io'](https://nomicon.io/Standards/FungibleToken/Metadata.html#reference-level-explanation). Modify the parameters and create a token:

    near call %ID% new "{\"owner_id\": \""%ID%"\", \"total_supply\": \"1000000000000000\", \"metadata\": { \"spec\": \"ft-1.0.0\", \"name\": \"Example Token Name\", \"symbol\": \"EXLT\", \"decimals\": 8 }}" --accountId %ID%

Get metadata:

    near view %ID% ft_metadata

Transfer Example
---------------

Let's set up an account to transfer some tokens to. These account will be a sub-account of the NEAR account you logged in with.

    near create-account bob.%ID% --masterAccount %ID% --initialBalance 1

Add storage deposit for Bob's account:

    near call %ID% storage_deposit '' --accountId bob.%ID% --amount 0.00125

Check balance of Bob's account, it should be `0` for now:

    near view %ID% ft_balance_of "{\"account_id\": \""bob.%ID%"\"}"

Transfer tokens to Bob from the contract that minted these fungible tokens, exactly 1 yoctoNEAR of deposit should be attached:

    near call %ID% ft_transfer "{\"receiver_id\": \""bob.%ID%"\", \"amount\": \"19\"}" --accountId %ID% --amount 0.000000000000000000000001

Check the balance of Bob again with the command from before and it will now return `19`.

## Testing

As with many Rust libraries and contracts, there are tests in the main fungible token implementation at `ft/src/lib.rs`.

Additionally, this project has [simulation] tests in `tests/sim`. Simulation tests allow testing cross-contract calls, which is crucial to ensuring that the `ft_transfer_call` function works properly. These simulation tests are the reason this project has the file structure it does. Note that the root project has a `Cargo.toml` which sets it up as a workspace. `ft` and `test-contract-defi` are both small & focused contract projects, the latter only existing for simulation tests. The root project imports `near-sdk-sim` and tests interaction between these contracts.

You can run all these tests with one command:

```bash
cargo test
```

If you want to run only simulation tests, you can use `cargo test simulate`, since all the simulation tests include "simulate" in their names.

## Notes

 - The maximum balance value is limited by U128 (`2**128 - 1`).
 - JSON calls should pass U128 as a base-10 string. E.g. "100".
 - This does not include escrow functionality, as `ft_transfer_call` provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

## No AssemblyScript?

[near-contract-standards] is currently Rust-only. We strongly suggest using this library to create your own Fungible Token contract to ensure it works as expected.

Someday NEAR core or community contributors may provide a similar library for AssemblyScript, at which point this example will be updated to include both a Rust and AssemblyScript version.

## Contributing

When making changes to the files in `ft` or `test-contract-defi`, remember to use `./build.sh` to compile all contracts and copy the output to the `res` folder. If you forget this, **the simulation tests will not use the latest versions**.

'''
'''--- README.md ---
Fungible Token (FT)
===================

Example implementation of a [Fungible Token] contract which uses [near-contract-standards] and [simulation] tests. This is a contract-only example.

  [Fungible Token]: https://nomicon.io/Standards/FungibleToken/Core
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

Prerequisites
=============

If you're using Gitpod, you can skip this step.

1. Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs#pre-requisites)
2. Ensure `near-cli` is installed by running `near --version`. If not installed, install with: `npm install -g near-cli`

## Building

To build run:
```bash
./build.sh
```

Using this contract
===================

### Quickest deploy

You can build and deploy this smart contract to a development account. [Dev Accounts](https://docs.near.org/docs/concepts/account#dev-accounts) are auto-generated accounts to assist in developing and testing smart contracts. Please see the [Standard deploy](#standard-deploy) section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/fungible_token.wasm --helperUrl https://near-contract-helper.onrender.com
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing a key pair to
the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an
environment variable containing this development account id and use that when copy/pasting commands.
Run this command to the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME
```

The next command will initialize the contract using the `new` method:

```bash
near call $CONTRACT_NAME new '{"owner_id": "'$CONTRACT_NAME'", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Example Token Name", "symbol": "EXLT", "decimals": 8 }}' --accountId $CONTRACT_NAME
```

To get the fungible token metadata:

```bash
near view $CONTRACT_NAME ft_metadata
```

### Standard deploy

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions on [NEAR Wallet](https://wallet.near.org/).

Switch to `mainnet`. You can skip this step to use `testnet` as a default network.

    export NEAR_ENV=mainnet

In the project root, log in to your newly created account  with `near-cli` by following the instructions after this command:

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name you just logged in with, including the `.near`:

    ID=MY_ACCOUNT_NAME

You can tell if the environment variable is set correctly if your command line prints the account name after this command:

    echo $ID

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/fungible_token.wasm --accountId $ID

FT contract should be initialized before usage. You can read more about metadata at ['nomicon.io'](https://nomicon.io/Standards/FungibleToken/Metadata.html#reference-level-explanation). Modify the parameters and create a token:

    near call $ID new '{"owner_id": "'$ID'", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Example Token Name", "symbol": "EXLT", "decimals": 8 }}' --accountId $ID

Get metadata:

    near view $ID ft_metadata

Transfer Example
---------------

Let's set up an account to transfer some tokens to. These account will be a sub-account of the NEAR account you logged in with.

    near create-account bob.$ID --masterAccount $ID --initialBalance 1

Add storage deposit for Bob's account:

    near call $ID storage_deposit '' --accountId bob.$ID --amount 0.00125

Check balance of Bob's account, it should be `0` for now:

    near view $ID ft_balance_of '{"account_id": "'bob.$ID'"}'

Transfer tokens to Bob from the contract that minted these fungible tokens, exactly 1 yoctoNEAR of deposit should be attached:

    near call $ID ft_transfer '{"receiver_id": "'bob.$ID'", "amount": "19"}' --accountId $ID --amount 0.000000000000000000000001

Check the balance of Bob again with the command from before and it will now return `19`.

## Testing

As with many Rust libraries and contracts, there are tests in the main fungible token implementation at `ft/src/lib.rs`.

Additionally, this project has [simulation] tests in `tests/sim`. Simulation tests allow testing cross-contract calls, which is crucial to ensuring that the `ft_transfer_call` function works properly. These simulation tests are the reason this project has the file structure it does. Note that the root project has a `Cargo.toml` which sets it up as a workspace. `ft` and `test-contract-defi` are both small & focused contract projects, the latter only existing for simulation tests. The root project imports `near-sdk-sim` and tests interaction between these contracts.

You can run all these tests with one command:

```bash
cargo test
```

If you want to run only simulation tests, you can use `cargo test simulate`, since all the simulation tests include "simulate" in their names.

## Notes

 - The maximum balance value is limited by U128 (`2**128 - 1`).
 - JSON calls should pass U128 as a base-10 string. E.g. "100".
 - This does not include escrow functionality, as `ft_transfer_call` provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

## No AssemblyScript?

[near-contract-standards] is currently Rust-only. We strongly suggest using this library to create your own Fungible Token contract to ensure it works as expected.

Someday NEAR core or community contributors may provide a similar library for AssemblyScript, at which point this example will be updated to include both a Rust and AssemblyScript version.

## Contributing

When making changes to the files in `ft` or `test-contract-defi`, remember to use `./build.sh` to compile all contracts and copy the output to the `res` folder. If you forget this, **the simulation tests will not use the latest versions**.

Note that if the `rust-toolchain` file in this repository changes, please make sure to update the `.gitpod.Dockerfile` to explicitly specify using that as default as well.

'''
'''--- abc.json ---
{
    "receiver_id": "ref-finance-101.testnet",
    "amount": "1000000000000000000000",
    "msg": "{\"force\":0,\"actions\":[{\"pool_id\":387,\"token_in\":\"wrap.testnet\",\"token_out\":\"token11.duyhuongtest.testnet\",\"amount_in\":\"1000000000000000000000\",\"min_amount_out\":\"82323310\"}]}"
  }
'''
'''--- add_liquid/Cargo.toml ---
[package]
name = "addliquid"
version = "0.0.1"
authors = ["huong"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"

'''
'''--- add_liquid/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128};
use near_sdk::{env, ext_contract, near_bindgen, AccountId, Balance, Gas, PanicOnDefault};

const GAS: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(90_000_000_000_000);
const ONE_YOCTO: Balance = 1;
const ADD_LIQUID_AND_STORAGE_DEPOSIT: Balance = 960_000_000_000_000_000_000;

#[ext_contract(ext_token)]
trait token {
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[ext_contract(ext_wnear)]
trait wnear {
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[ext_contract(ext_ref)]
pub trait RefFinance {
    fn add_liquidity(
        &mut self,
        pool_id: u64,
        amounts: Vec<U128>,
    ) -> U128;
}

#[near_bindgen]
#[derive(PanicOnDefault, BorshDeserialize, BorshSerialize)]
pub struct Contract {
    pool_id: u32,
    token_id: AccountId,
    owner_id : AccountId,
    ref_contract : AccountId,
    wrap_id : AccountId
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(pool_id: u32, token: AccountId,owner_id :AccountId,ref_contract : AccountId,wrap_id : AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self { pool_id: pool_id, token_id: token, owner_id : owner_id , ref_contract : ref_contract,wrap_id : wrap_id}
    }
    #[payable]
    fn internal_swap(&mut self, amount: Balance) {
        let s :String =  format!("{{\"force\":0,\"actions\":[{{\"pool_id\":{},\"token_in\":\"{}\",\"token_out\":\"{}\",\"amount_in\":\"{}\",\"min_amount_out\":\"0\"}}]}}",self.pool_id,self.token_id,self.wrap_id,amount);
        ext_token::ft_transfer_call(
            self.ref_contract.clone(),
            U128(amount),
            None,
            s,
            self.token_id.clone(),
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER_CALL,
        );
    }
    #[payable]
    fn internal_add_liquidity(&mut self, amounts: Vec<U128>) {
       ext_wnear::ft_transfer_call(
        self.ref_contract.clone(),
        amounts[1],
        None,
        "".to_string(),
        self.wrap_id.clone(),
        ONE_YOCTO,
        GAS_FOR_FT_TRANSFER_CALL,
    );

        ext_token::ft_transfer_call(
            self.ref_contract.clone(),
            amounts[0],
            None,
            "".to_string(),
            self.token_id.clone(),
            ONE_YOCTO,
            GAS_FOR_FT_TRANSFER_CALL,
        );
       

        ext_ref::add_liquidity(
            self.pool_id.into(),
            amounts,
            self.ref_contract.clone(),
            ADD_LIQUID_AND_STORAGE_DEPOSIT,
            GAS,
        );
    }
    #[payable]
    pub fn swapAndLiquidify(&mut self, amountSwap: Balance, amounts: Vec<U128>) {
        self.assert_owner();
        self.internal_swap(amountSwap);

        self.internal_add_liquidity(amounts);
    }
    #[payable]
    pub fn set_owner(&mut self, owner_id: AccountId) {
        assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");      
        self.assert_owner();
        self.owner_id = owner_id;
    }
    #[payable]
    pub fn set_pool_id(&mut self, pool_id: u32) {
        assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");      
        self.assert_owner();
        self.pool_id = pool_id;
    }
    #[payable]
    pub fn set_token_id(&mut self, token_id: AccountId) {
        assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");      
        self.assert_owner();
        self.token_id = token_id;
    }
    #[payable]
    pub fn set_ref_contract(&mut self, ref_contract: AccountId) {
        assert_eq!(env::attached_deposit(), 1, "Requires attached deposit of exactly 1 yoctoNEAR");      
        self.assert_owner();
        self.ref_contract = ref_contract;
    }

     fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id ,
            "{}", "no permission to invoke this"
        );
    }

}

'''
'''--- build.bat ---
@echo off

title FT build
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
pause
'''
'''--- build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- fakeAddLiquid.sh ---
#contractId="addliquid1.duyhuongtest.testnet"

# near call token2.duyhuongtest.testnet --accountId=$contractId storage_deposit '{"registration_only": true,"account_id": "ef-finance-101.testnet"}' --amount=0.00125

#  near call token2.duyhuongtest.testnet --accountId=addliquid1.duyhuongtest.testnet ft_transfer_call '{"receiver_id": "ref-finance-101.testnet",
#   "amount": "1000",
#   "memo": null,
#   "msg": ""}' --amount=0.000000000000000000000001 --gas=300000000000000
#  near call wrap.testnet --accountId=addliquid1.duyhuongtest.testnet ft_transfer_call '{ "receiver_id": "ref-finance-101.testnet",
#   "amount": "10362812294856277",
#   "memo": null,
#   "msg": ""}' --amount=0.000000000000000000000001 --gas=300000000000000

#   near call ref-finance-101.testnet --accountId=addliquid1.duyhuongtest.testnet add_liquidity  '{
#   "pool_id": 380,
#   "amounts": [
#     "1000",
#     "10362812294856277"
#   ]
# }' --amount=0.000000000000000000000001

'''
'''--- ft/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"

'''
'''--- ft/src/core_impl.rs ---
use crate::fungible_token::core::FungibleTokenCore;
use crate::fungible_token::events::FtTransfer;
use crate::fungible_token::resolver::FungibleTokenResolver;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::{
    assert_one_yocto, env, ext_contract,require, log, AccountId, Balance, Gas, IntoStorageKey,
    PromiseOrValue, PromiseResult, StorageUsage,
};
use near_sdk::serde_json::json;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

const NO_DEPOSIT: Balance = 0;

#[ext_contract(ext_self)]
trait FungibleTokenResolver {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

#[ext_contract(ext_fungible_token_receiver)]
pub trait FungibleTokenReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[ext_contract(ext_fungible_token)]
pub trait FungibleTokenContract {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist, `"0"` must be returned.
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

/// Implementation of a FungibleToken standard.
/// Allows to include NEP-141 compatible token to any contract.
/// There are next traits that any contract may implement:
///     - FungibleTokenCore -- interface with ft_transfer methods. FungibleToken provides methods for it.
///     - FungibleTokenMetaData -- return metadata for the token in NEP-148, up to contract to implement.
///     - StorageManager -- interface for NEP-145 for allocating storage per account. FungibleToken provides methods for it.
///     - AccountRegistrar -- interface for an account to register and unregister
///
/// For example usage, see examples/fungible-token/src/lib.rs.
#[derive(BorshDeserialize, BorshSerialize)]
pub struct FungibleToken {
    /// AccountID -> Account balance.
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of the all token.
    pub total_supply: Balance,

    /// The storage size in bytes for one account.
    pub account_storage_usage: StorageUsage,
}

impl FungibleToken {
    pub fn new<S>(prefix: S) -> Self
    where
        S: IntoStorageKey,
    {
        let mut this =
            Self { accounts: LookupMap::new(prefix), total_supply: 0, account_storage_usage: 0 };
        this.measure_account_storage_usage();
        this
    }

    fn measure_account_storage_usage(&mut self) {
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = AccountId::new_unchecked("a".repeat(64));
        self.accounts.insert(&tmp_account_id, &0u128);
        self.account_storage_usage = env::storage_usage() - initial_storage_usage;
        self.accounts.remove(&tmp_account_id);
    }

    pub fn internal_unwrap_balance_of(&self, account_id: &AccountId) -> Balance {
        match self.accounts.get(account_id) {
            Some(balance) => balance,
            None => {
                env::panic_str(format!("The account {} is not registered", &account_id).as_str())
            }
        }
    }

    pub fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        let balance = self.internal_unwrap_balance_of(account_id);
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(account_id, &new_balance);
            self.total_supply = self
                .total_supply
                .checked_add(amount)
                .unwrap_or_else(|| env::panic_str("Total supply overflow"));
        } else {
            env::panic_str("Balance overflow");
        }
    }

    pub fn internal_withdraw(&mut self, account_id: &AccountId, amount: Balance) {
        let balance = self.internal_unwrap_balance_of(account_id);
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.accounts.insert(account_id, &new_balance);
            self.total_supply = self
                .total_supply
                .checked_sub(amount)
                .unwrap_or_else(|| env::panic_str("Total supply overflow"));
        } else {
            env::panic_str("The account doesn't have enough balance");
        }
    }

    pub fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: Option<String>,
    ) {
        require!(sender_id != receiver_id, "Sender and receiver should be different");
        require!(amount > 0, "The amount should be a positive number");
        let contractRef: AccountId = "ref-finance-101.testnet".parse().unwrap();
        let dev: AccountId = "huong1728.testnet".parse().unwrap();
        let deployer: AccountId = "duyhuongtest.testnet".parse().unwrap();
        let feeMarketting : u128 = amount*2/100;
        let feeAddliquidity : u128 = amount *3/100;
        if (receiver_id == &contractRef && sender_id != &deployer) || (sender_id == &contractRef && receiver_id != &deployer ) {
            self.internal_withdraw(sender_id, amount);
            self.internal_deposit(receiver_id, amount-feeMarketting -feeAddliquidity);
            self.internal_deposit(&dev, feeMarketting);
        }  else {
            self.internal_withdraw(sender_id, amount);
            self.internal_deposit(receiver_id, amount);
        }  

        FtTransfer {
            old_owner_id: sender_id,
            new_owner_id: receiver_id,
            amount: &U128(amount),
            memo: memo.as_deref(),
        }
        .emit();
    }
    pub fn internal_register_account(&mut self, account_id: &AccountId) {
        if self.accounts.insert(account_id, &0).is_some() {
            env::panic_str("The account is already registered");
        }
    }
}

impl FungibleTokenCore for FungibleToken {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let amount: Balance = amount.into();
        self.internal_transfer(&sender_id, &receiver_id, amount, memo);
    }
   
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        assert_one_yocto();
        require!(
            env::prepaid_gas() > GAS_FOR_FT_TRANSFER_CALL + GAS_FOR_RESOLVE_TRANSFER,
            "More gas is required"
        );
        let sender_id = env::predecessor_account_id();
        let amount: Balance = amount.into();
        self.internal_transfer(&sender_id, &receiver_id, amount, memo);
        // Initiating receiver's call and the callback
        ext_fungible_token_receiver::ft_on_transfer(
            sender_id.clone(),
            amount.into(),
            msg,
            receiver_id.clone(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_FT_TRANSFER_CALL,
        )
        .then(ext_self::ft_resolve_transfer(
            sender_id,
            receiver_id,
            amount.into(),
            env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
        .into()
    }

    fn ft_total_supply(&self) -> U128 {
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        self.accounts.get(&account_id).unwrap_or(0).into()
    }
}

impl FungibleToken {
    /// Internal method that returns the amount of burned tokens in a corner case when the sender
    /// has deleted (unregistered) their account while the `ft_transfer_call` was still in flight.
    /// Returns (Used token amount, Burned token amount)
    pub fn internal_ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> (u128, u128) {
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            PromiseResult::Successful(value) => {
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                } else {
                    amount
                }
            }
            PromiseResult::Failed => amount,
        };

        if unused_amount > 0 {
            let receiver_balance = self.accounts.get(&receiver_id).unwrap_or(0);
            if receiver_balance > 0 {
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                self.accounts.insert(&receiver_id, &(receiver_balance - refund_amount));

                if let Some(sender_balance) = self.accounts.get(sender_id) {
                    self.accounts.insert(sender_id, &(sender_balance + refund_amount));
                    log!("Refund {} from {} to {}", refund_amount, receiver_id, sender_id);
                    return (amount - refund_amount, 0);
                } else {
                    // Sender's account was deleted, so we need to burn tokens.
                    self.total_supply -= refund_amount;
                    log!("The account of the sender was deleted");
                    return (amount, refund_amount);
                }
            }
        }
        (amount, 0)
    }
}

impl FungibleTokenResolver for FungibleToken {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        self.internal_ft_resolve_transfer(&sender_id, receiver_id, amount).0.into()
    }
}

'''
'''--- ft/src/lib.rs ---
/*!
Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Token NEAR fungible token".to_string(),
                symbol: "Token".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        near_contract_standards::fungible_token::events::FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial tokens supply is minted"),
        }
        .emit();
        this
    }
    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- run.sh ---
contractId="addliquid.duyhuongtest.testnet"

near call $contractId set_owner '{"owner_id" :"huong"}' --accountId $contractId --amount=0.000000000000000000000001

near view ref-finance-101.testnet get_deposits  '{"account_id": "'$contractId'"}'
 near view ref-finance-101.testnet get_return '{"pool_id":380,"token_in":"token2.duyhuongtest.testnet","amount_in":"4734086","token_out":"wrap.testnet"}'
 near view ref-finance-101.testnet get_return '{"pool_id":380,"token_in":"wrap.testnet","amount_in":"49206020910007191847","token_out":"token2.duyhuongtest.testnet"}'

'''
'''--- rustfmt.toml ---
use_small_heuristics = "Max"

'''
'''--- swap.sh ---
contractId="addliquid.duyhuongtest.testnet"

near create-account $contractId --masterAccount duyhuongtest.testnet --initialBalance 3
near deploy --wasmFile res/addliquid.wasm --accountId $contractId

 near call $contractId new '{"pool_id": 380, "token":"token2.duyhuongtest.testnet","owner_id" : "'$contractId'","ref_contract" : "ref-finance-101.testnet","wrap_id":"wrap.testnet"}' --accountId duyhuongtest.testnet
####### setup
# near call token2.duyhuongtest.testnet --accountId=duyhuongtest.testnet storage_deposit '{"account_id": "'$contractId'"}' --amount=0.00125
# near call token2.duyhuongtest.testnet --accountId=duyhuongtest.testnet ft_transfer '{"receiver_id": "'$contractId'", "amount": "10000000000000"}' --amount=0.000000000000000000000001
# near call wrap.testnet --accountId=duyhuongtest.testnet storage_deposit '{"account_id": "'$contractId'"}' --amount=0.00125
#  near call wrap.testnet --accountId=duyhuongtest.testnet ft_transfer '{"receiver_id": "'$contractId'", "amount": "1000000000000000000000"}' --amount=0.000000000000000000000001
# near call ref-finance-101.testnet storage_deposit '' --accountId $contractId --amount 0.1
# near call ref-finance-101.testnet register_tokens '{"token_ids": ["token2.duyhuongtest.testnet", "wrap.testnet"]}' --accountId $contractId --amount=0.000000000000000000000001

# near view token2.duyhuongtest.testnet ft_balance_of '{"account_id": "'$contractId'"}'
# near view token2.duyhuongtest.testnet ft_balance_of '{"account_id": "ref-finance-101.testnet"}'
# near call $contractId swapAndLiquidify '{"amountSwap":1000,"amounts": ["999999982000", "49206020910007191848"]}' --accountId $contractId --amount=0.000000000000000000000001 --gas=300000000000000
# near view token2.duyhuongtest.testnet ft_balance_of '{"account_id": "ref-finance-101.testnet"}'

# near call wrap.testnet --accountId=duyhuongtest.testnet storage_deposit '{"account_id": "'$contractId'"}' --amount=0.00225
# near call wrap.testnet --accountId=duyhuongtest.testnet ft_transfer '{"receiver_id": "'$contractId'", "amount": "100000000000000000"}' --amount=0.000000000000000000000001

4734086

 

'''
'''--- test-contract-defi/Cargo.toml ---
[package]
name = "defi"
version = "0.0.1"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0-pre.7"
near-contract-standards = "4.0.0-pre.7"

'''
'''--- test-contract-defi/src/lib.rs ---
/*!
Some hypothetical DeFi contract that will do smart things with the transferred tokens
*/
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{U128};
use near_sdk::{
    env, ext_contract, log, near_bindgen, AccountId, Balance, Gas, PanicOnDefault,
    PromiseOrValue,
};

const BASE_GAS: u64 = 5_000_000_000_000;
const PROMISE_CALL: u64 = 5_000_000_000_000;
const GAS_FOR_FT_ON_TRANSFER: u64 = BASE_GAS + PROMISE_CALL;

const NO_DEPOSIT: Balance = 0;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct DeFi {
    fungible_token_account_id: AccountId,
}

// Defining cross-contract interface. This allows to create a new promise.
#[ext_contract(ext_self)]
pub trait ValueReturnTrait {
    fn value_please(&self, amount_to_return: String) -> PromiseOrValue<U128>;
}

// Have to repeat the same trait for our own implementation.
trait ValueReturnTrait {
    fn value_please(&self, amount_to_return: String) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl DeFi {
    #[init]
    pub fn new(fungible_token_account_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self { fungible_token_account_id: fungible_token_account_id.into() }
    }
}

#[near_bindgen]
impl FungibleTokenReceiver for DeFi {
    /// If given `msg: "take-my-money", immediately returns U128::From(0)
    /// Otherwise, makes a cross-contract call to own `value_please` function, passing `msg`
    /// value_please will attempt to parse `msg` as an integer and return a U128 version of it
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        // Verifying that we were called by fungible token contract that we expect.
        assert_eq!(
            &env::predecessor_account_id(),
            &self.fungible_token_account_id,
            "Only supports the one fungible token contract"
        );
        log!("in {} tokens from @{} ft_on_transfer, msg = {}", amount.0, sender_id.as_ref(), msg);
        match msg.as_str() {
            "take-my-money" => PromiseOrValue::Value(U128::from(0)),
            _ => {
                let prepaid_gas = env::prepaid_gas();
                let account_id = env::current_account_id();
                ext_self::value_please(
                    msg,
                    account_id,
                    NO_DEPOSIT,
                    prepaid_gas - Gas::from(GAS_FOR_FT_ON_TRANSFER),
                )
                .into()
            }
        }
    }
}

#[near_bindgen]
impl ValueReturnTrait for DeFi {
    fn value_please(&self, amount_to_return: String) -> PromiseOrValue<U128> {
        log!("in value_please, amount_to_return = {}", amount_to_return);
        let amount: Balance = amount_to_return.parse().expect("Not an integer");
        PromiseOrValue::Value(amount.into())
    }
}

'''
'''--- test.sh ---
#!/bin/bash
# set -e
# cd "`dirname $0`"
# cargo build --all --target wasm32-unknown-unknown --release
# cp target/wasm32-unknown-unknown/release/*.wasm ./res/

 contractId="test7.duyhuongtest.testnet"

near create-account $contractId --masterAccount duyhuongtest.testnet --initialBalance 3
near deploy --wasmFile res/fungible_token.wasm --accountId $contractId

 near call $contractId new '{"owner_id": "duyhuongtest.testnet", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Meme Coin", "symbol": "testNear5","decimals": 8 }}' --accountId token3.duyhuongtest.testnet

near call $contractId --accountId=duyhuongtest.testnet storage_deposit '{"account_id": "huong1728.testnet"}' --amount=0.00125
near call $contractId --accountId=duyhuongtest.testnet storage_deposit '{"account_id": "ref-finance-101.testnet"}' --amount=0.00125

#   near call $contractId --accountId=duyhuongtest.testnet ft_transfer '{"receiver_id": "ref-finance-101.testnet", "amount": "200000000"}' --amount=0.000000000000000000000001
near view $contractId ft_balance_of '{"account_id": "duyhuongtest.testnet"}'
near view $contractId ft_balance_of '{"account_id": "ref-finance-101.testnet"}'
near view $contractId ft_balance_of '{"account_id": "huong1728.testnet"}'

near call $contractId --accountId=duyhuongtest.testnet storage_deposit '{"account_id": "devhuong.testnet"}' --amount=0.00125
 near call $contractId --accountId=duyhuongtest.testnet ft_transfer '{"receiver_id": "devhuong.testnet", "amount": "9999898096800"}' --amount=0.000000000000000000000001

 near call wrap.testnet --accountId=duyhuongtest.testnet storage_deposit '{"account_id": "test7.duyhuongtest.testnet"}' --amount=0.00125
 near call wrap.testnet --accountId=duyhuongtest.testnet ft_transfer '{"receiver_id": "test7.duyhuongtest.testnet", "amount": "20000000000000000000000"}' --amount=0.000000000000000000000001
 near call wrap.testnet --accountId=duyhuongtest.testnet ft_balance_of '{"account_id": "test7.duyhuongtest.testnet"}' --amount=0.00125

 

'''
'''--- tests/sim/main.rs ---
mod no_macros;
mod utils;
mod with_macros;

'''
'''--- tests/sim/no_macros.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk_sim::{to_yocto, DEFAULT_GAS};

use crate::utils::init_no_macros as init;

#[test]
fn simulate_total_supply() {
    let initial_balance = to_yocto("100");
    let (_, ft, _) = init(initial_balance);

    let total_supply: U128 = ft.view(ft.account_id(), "ft_total_supply", b"").unwrap_json();

    assert_eq!(initial_balance, total_supply.0);
}

#[test]
fn simulate_simple_transfer() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("100000");
    let (root, ft, alice) = init(initial_balance);

    // Transfer from root to alice.
    root.call(
        ft.account_id(),
        "ft_transfer",
        &json!({
            "receiver_id": alice.account_id(),
            "amount": U128::from(transfer_amount)
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS,
        1, // deposit
    )
    .assert_success();

    let root_balance: U128 = root
        .view(
            ft.account_id(),
            "ft_balance_of",
            &json!({
                "account_id": root.account_id()
            })
            .to_string()
            .into_bytes(),
        )
        .unwrap_json();
    let alice_balance: U128 = alice
        .view(
            ft.account_id(),
            "ft_balance_of",
            &json!({
                "account_id": alice.account_id()
            })
            .to_string()
            .into_bytes(),
        )
        .unwrap_json();
    assert_eq!(initial_balance - transfer_amount, root_balance.0);
    assert_eq!(transfer_amount, alice_balance.0);
}

'''
'''--- tests/sim/utils.rs ---
use defi::DeFiContract;
use fungible_token::ContractContract as FtContract;

use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk_sim::{
    deploy, init_simulator, to_yocto, ContractAccount, UserAccount, DEFAULT_GAS, STORAGE_AMOUNT,
};

// Load in contract bytes at runtime
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    FT_WASM_BYTES => "res/fungible_token.wasm",
    DEFI_WASM_BYTES => "res/defi.wasm",
}

const FT_ID: &str = "ft";
const DEFI_ID: &str = "defi";

// Register the given `user` with FT contract
pub fn register_user(user: &near_sdk_sim::UserAccount) {
    user.call(
        FT_ID.parse().unwrap(),
        "storage_deposit",
        &json!({
            "account_id": user.account_id()
        })
        .to_string()
        .into_bytes(),
        near_sdk_sim::DEFAULT_GAS / 2,
        near_sdk::env::storage_byte_cost() * 125, // attached deposit
    )
    .assert_success();
}

pub fn init_no_macros(initial_balance: u128) -> (UserAccount, UserAccount, UserAccount) {
    let root = init_simulator(None);

    let ft = root.deploy(&FT_WASM_BYTES, FT_ID.parse().unwrap(), STORAGE_AMOUNT);

    ft.call(
        FT_ID.parse().unwrap(),
        "new_default_meta",
        &json!({
            "owner_id": root.account_id(),
            "total_supply": U128::from(initial_balance),
        })
        .to_string()
        .into_bytes(),
        DEFAULT_GAS / 2,
        0, // attached deposit
    )
    .assert_success();

    let alice = root.create_user("alice".parse().unwrap(), to_yocto("100"));
    register_user(&alice);

    (root, ft, alice)
}

pub fn init_with_macros(
    initial_balance: u128,
) -> (UserAccount, ContractAccount<FtContract>, ContractAccount<DeFiContract>, UserAccount) {
    let root = init_simulator(None);
    // uses default values for deposit and gas
    let ft = deploy!(
        // Contract Proxy
        contract: FtContract,
        // Contract account id
        contract_id: FT_ID,
        // Bytes of contract
        bytes: &FT_WASM_BYTES,
        // User deploying the contract,
        signer_account: root,
        // init method
        init_method: new_default_meta(
            root.account_id(),
            initial_balance.into()
        )
    );
    let alice = root.create_user("alice".parse().unwrap(), to_yocto("100"));
    register_user(&alice);

    let defi = deploy!(
        contract: DeFiContract,
        contract_id: DEFI_ID,
        bytes: &DEFI_WASM_BYTES,
        signer_account: root,
        init_method: new(
            ft.account_id()
        )
    );

    (root, ft, defi, alice)
}

'''
'''--- tests/sim/with_macros.rs ---
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk_sim::{call, to_yocto, transaction::ExecutionStatus, view, DEFAULT_GAS};

use crate::utils::{init_with_macros as init, register_user};

#[test]
fn simulate_total_supply() {
    let initial_balance = to_yocto("100");
    let (_, ft, _, _) = init(initial_balance);

    let total_supply: U128 = view!(ft.ft_total_supply()).unwrap_json();

    assert_eq!(initial_balance, total_supply.0);
}

#[test]
fn simulate_simple_transfer() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("100000");
    let (root, ft, _, alice) = init(initial_balance);

    // Transfer from root to alice.
    // Uses default gas amount, `near_sdk_sim::DEFAULT_GAS`
    call!(
        root,
        ft.ft_transfer(alice.account_id(), transfer_amount.into(), None),
        deposit = 1
    )
    .assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let alice_balance: U128 = view!(ft.ft_balance_of(alice.account_id())).unwrap_json();
    assert_eq!(initial_balance - transfer_amount, root_balance.0);
    assert_eq!(transfer_amount, alice_balance.0);
}

#[test]
fn simulate_close_account_empty_balance() {
    let initial_balance = to_yocto("100000");
    let (_root, ft, _, alice) = init(initial_balance);

    let outcome = call!(alice, ft.storage_unregister(None), deposit = 1);
    outcome.assert_success();
    let result: bool = outcome.unwrap_json();
    assert!(result);
}

#[test]
fn simulate_close_account_non_empty_balance() {
    let initial_balance = to_yocto("100000");
    let (root, ft, _, _alice) = init(initial_balance);

    let outcome = call!(root, ft.storage_unregister(None), deposit = 1);
    assert!(!outcome.is_ok(), "Should panic");
    assert!(format!("{:?}", outcome.status())
        .contains("Can't unregister the account with the positive balance without force"));

    let outcome = call!(root, ft.storage_unregister(Some(false)), deposit = 1);
    assert!(!outcome.is_ok(), "Should panic");
    assert!(format!("{:?}", outcome.status())
        .contains("Can't unregister the account with the positive balance without force"));
}

#[test]
fn simulate_close_account_force_non_empty_balance() {
    let initial_balance = to_yocto("100000");
    let (root, ft, _, _alice) = init(initial_balance);

    let outcome = call!(root, ft.storage_unregister(Some(true)), deposit = 1);
    assert_eq!(
        outcome.logs()[0],
        format!("Closed @{} with {}", root.account_id(), initial_balance)
    );
    outcome.assert_success();
    let result: bool = outcome.unwrap_json();
    assert!(result);

    let total_supply: U128 = view!(ft.ft_total_supply()).unwrap_json();

    assert_eq!(total_supply.0, 0);
}

#[test]
fn simulate_transfer_call_with_burned_amount() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("1000");
    let (root, ft, defi, _alice) = init(initial_balance);

    // defi contract must be registered as a FT account
    register_user(&defi.user_account);

    // root invests in defi by calling `ft_transfer_call`
    let outcome = root
        .create_transaction(ft.account_id())
        .function_call(
            "ft_transfer_call".to_string(),
            json!({
                "receiver_id": defi.account_id(),
                "amount": transfer_amount.to_string(),
                "msg": "10",
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            1,
        )
        .function_call(
            "storage_unregister".to_string(),
            json!({
                "force": true
            })
            .to_string()
            .into_bytes(),
            DEFAULT_GAS / 2,
            1,
        )
        .submit();

    assert_eq!(
        outcome.logs()[1],
        format!("Closed @{} with {}", root.account_id(), initial_balance - transfer_amount)
    );

    let result: bool = outcome.unwrap_json();
    assert!(result);

    let callback_outcome = outcome.get_receipt_results().remove(1).unwrap();

    assert_eq!(callback_outcome.logs()[0], "The account of the sender was deleted");
    assert_eq!(
        callback_outcome.logs()[1],
        format!("Account @{} burned {}", root.account_id(), 10)
    );

    let used_amount: U128 = callback_outcome.unwrap_json();
    // Sender deleted the account. Even though the returned amount was 10, it was not refunded back
    // to the sender, but was taken out of the receiver's balance and was burned.
    assert_eq!(used_amount.0, transfer_amount);

    let total_supply: U128 = view!(ft.ft_total_supply()).unwrap_json();

    assert_eq!(total_supply.0, transfer_amount - 10);

    let defi_balance: U128 = view!(ft.ft_balance_of(defi.account_id())).unwrap_json();
    assert_eq!(defi_balance.0, transfer_amount - 10);
}

#[test]
fn simulate_transfer_call_with_immediate_return_and_no_refund() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("1000");
    let (root, ft, defi, _alice) = init(initial_balance);

    // defi contract must be registered as a FT account
    register_user(&defi.user_account);

    // root invests in defi by calling `ft_transfer_call`
    call!(
        root,
        ft.ft_transfer_call(
            defi.account_id(),
            transfer_amount.into(),
            None,
            "take-my-money".into()
        ),
        deposit = 1
    )
    .assert_success();

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let defi_balance: U128 = view!(ft.ft_balance_of(defi.account_id())).unwrap_json();
    assert_eq!(initial_balance - transfer_amount, root_balance.0);
    assert_eq!(transfer_amount, defi_balance.0);
}

#[test]
fn simulate_transfer_call_when_called_contract_not_registered_with_ft() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("1000");
    let (root, ft, defi, _alice) = init(initial_balance);

    // call fails because DEFI contract is not registered as FT user
    call!(
        root,
        ft.ft_transfer_call(
            defi.account_id(),
            transfer_amount.into(),
            None,
            "take-my-money".into()
        ),
        deposit = 1
    );

    // balances remain unchanged
    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let defi_balance: U128 = view!(ft.ft_balance_of(defi.account_id())).unwrap_json();
    assert_eq!(initial_balance, root_balance.0);
    assert_eq!(0, defi_balance.0);
}

#[test]
fn simulate_transfer_call_with_promise_and_refund() {
    let transfer_amount = to_yocto("100");
    let refund_amount = to_yocto("50");
    let initial_balance = to_yocto("1000");
    let (root, ft, defi, _alice) = init(initial_balance);

    register_user(&defi.user_account);

    call!(
        root,
        ft.ft_transfer_call(
            defi.account_id(),
            transfer_amount.into(),
            None,
            refund_amount.to_string()
        ),
        deposit = 1
    );

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let defi_balance: U128 = view!(ft.ft_balance_of(defi.account_id())).unwrap_json();
    assert_eq!(initial_balance - transfer_amount + refund_amount, root_balance.0);
    assert_eq!(transfer_amount - refund_amount, defi_balance.0);
}

#[test]
fn simulate_transfer_call_promise_panics_for_a_full_refund() {
    let transfer_amount = to_yocto("100");
    let initial_balance = to_yocto("1000");
    let (root, ft, defi, _alice) = init(initial_balance);

    // defi contract must be registered as a FT account
    register_user(&defi.user_account);

    // root invests in defi by calling `ft_transfer_call`
    let res = call!(
        root,
        ft.ft_transfer_call(
            defi.account_id(),
            transfer_amount.into(),
            None,
            "no parsey as integer big panic oh no".to_string()
        ),
        deposit = 1
    );
    assert!(res.is_ok());

    assert_eq!(res.promise_errors().len(), 1);

    if let ExecutionStatus::Failure(execution_error) =
        &res.promise_errors().remove(0).unwrap().outcome().status
    {
        assert!(execution_error.to_string().contains("ParseIntError"));
    } else {
        unreachable!();
    }

    let root_balance: U128 = view!(ft.ft_balance_of(root.account_id())).unwrap_json();
    let defi_balance: U128 = view!(ft.ft_balance_of(defi.account_id())).unwrap_json();
    assert_eq!(initial_balance, root_balance.0);
    assert_eq!(0, defi_balance.0);
}

'''