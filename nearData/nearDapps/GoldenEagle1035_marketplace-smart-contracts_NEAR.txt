*GitHub Repository "GoldenEagle1035/marketplace-smart-contracts_NEAR"*

'''--- .dependabot/config.yml ---
version: 1
update_configs:
  - package_manager: "javascript"
    directory: "/"
    update_schedule: "live"
    automerged_updates:
      - match:
          dependency_type: "development"
          update_type: "all"
      - match:
          dependency_type: "production"
          update_type: "all"
  - package_manager: "rust:cargo"
    directory: "/contracts/rust"
    update_schedule: "live"
    automerged_updates:
      - match:
          dependency_type: "development"
          update_type: "all"
      - match:
          dependency_type: "production"
          update_type: "all"

'''
'''--- README.md ---
Amplify Art Music NFT & Marketplace Contract
==========================

Modules:
1) Market
2) NFTs

## Work Item: Show List of nfts in User's wallet
function nft_tokens_for_owner implementation is in progress.

These are old docs, but useful for understanding how it proceeded.

## Doc v0.5 ( Resolved Gas Errors + Fixed Design to suit Album Songs)
This is for the current implementation

A) Album & song uploads & to list all album bundle copies on market
1) add_token_types

B) To Buy a album Bundle on teh marketplace
1) offer_album

C) To list song on the marketplace
1) nft_approve

D) To Buy the song on the marketplace 
1) offer
2) nft_token(to check if the owner has it now )

## Doc v0.4
Was about series minting

## Doc v0.3 Error Handling
Error can be found in Logs of the transaction failed / succeeded otherwise

## Doc v0.2 (Mint + Price Setting + Purchase)
1) Deploy NFT Contract
`near dev-deploy --accountId=dev-1623229186642-77647971299977 --wasmFile=./out/music_nft.wasm`

2) Create a Market Account
`near create_account market.dev-1623229186642-77647971299977 --masterAccount=dev-1623227573802-45982734932448 --initial-balance 50`

3) Deploy the Music contracts
`near deploy --accountId=market.dev-1623229186642-77647971299977 --wasmFile=./out/music_market.wasm`

4) New Function
`near call market.dev-1623229186642-77647971299977 new '{"owner_id": "dev-1623229186642-77647971299977", "nft_contract_id": "dev-1623229186642-77647971299977"}' --accountId=dev-1623229186642-77647971299977`

`near call dev-1623229186642-77647971299977 new '{"owner_id":"dev-1623229186642-77647971299977","metadata":{"spec":"music-nft-0.2.0","name":"AmplifyArt","symbol":"AMPLIFY"},"supply_cap_by_type":{"test": "1000000"}}' --accountId=dev-1623229186642-77647971299977`

7) Storage Cost Call for the Minter
`near call --accountId=rahulsoshte.testnet market.dev-1623229186642-77647971299977 storage_deposit --gas 200000000000000 --amount 20`

8) For further steps follow scripts/app2.js

## Doc v0.1 (Simple Mint function)

1) Copy the WASM File into your machine 
<br>

2) Install Near CLI (https://docs.near.org/docs/tools/near-cli#windows )
<br>

3) Deploy the WASM file on Testnet <br>
`near deploy --wasmFile target/wasm32-unknown-unknown/release/rust_counter_tutorial.wasm --accountId YOUR_ACCOUNT_HERE`
<br>
4) For Quick Testing - CLI Arguments ( Will work on WSL ) <br>
`near login`
`near call YOUR_ACCOUNT_HERE increment --accountId YOUR_ACCOUNT_HERE`
`near call --accountId CALLER-ID RECEIVER-ID new '{"owner_id": "OWNER-ID"}'` ( Have to only call once )
`near call --accountId dev-1622112382753-68159924582656 dev-1622112382753-68159924582656 mint_token '{"token_id":"IPFS_METADATA_LINk", "owner_id": "dev-1622112382753-68159924582656"}'`
<br>
5) For testing with the NEAR API
You need to take reference of near-api-js documentation
https://docs.near.org/docs/api/naj-quick-reference#contract

So the TokenID can be a IPFS CID of the Metadata (Content ID, a unique hash) & the Metadata's structure can be, For example let's say <b>"21 Guns"</b> song

```
Metadata {

  "name": "21 Guns",
  "album": "21st Century Breakdown",
  "description": "The song is about fighting a good fight, but not the fights unworthy of fighting for. You only got one life, and just one 21 gun salute, avail of it. Live your life an honorable life and give up the petty things.",
  "audio_file_ipfs_link": "https://ipfs.io/ipfs/QmQvx9dxYNA4kp1ZDzC1jd2LyYgwhffwK3TfBRv7QNqGd8?filename=21guns.mp3",
  "singer":"Green Day",
  "genre":"Alternative Rock",
  "song_writers":"Billie, Mike, Tre",
  "released_date":"2009"
}
```

This whole metadata can be represented by a unique hash ( IPFS Content ID / IPFS URL ) which will be used as the tokenID / unique identifier of the NFT on the blockchain.

What happends with using HTTPS URL with AWS S3 as the unique identifier for the NFT is that the links can possibly break, and the TokenID on the blockchain for the NFT becomes a little useless.

'''
'''--- contracts/market/Cargo.toml ---
[package]
name = "music-market"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "=3.1.0"

[profile.release]
codegen-units=24
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contracts/market/README.md ---
# TBD

'''
'''--- contracts/market/build-mainnet.sh ---
#!/bin/bash
set -e
# If you are on windows and using WSL, make sure to run this command 'sed -i -e 's/\r$//' build.sh'

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../mainnet_out/

'''
'''--- contracts/market/build-testnet.sh ---
#!/bin/bash
set -e
# If you are on windows and using WSL, make sure to run this command 'sed -i -e 's/\r$//' build.sh'

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../testnet_out/

'''
'''--- contracts/market/build.sh ---
#!/bin/bash
set -e
# If you are on windows and using WSL, make sure to run this command 'sed -i -e 's/\r$//' build.sh'

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../out/

'''
'''--- contracts/market/neardev/dev-account.env ---
CONTRACT_NAME=dev-1641120395136-60504998065740
'''
'''--- contracts/market/src/external.rs ---
use crate::*;

//* external contract calls
//* Useful for calling the NFT contract functions

#[ext_contract(ext_contract)]
trait ExtContract {

    //* Cross Contract Call Interface to NFT contract 
    //* for minting a new album bundle and assign ownership of it to the users
    fn nft_transfer_payout(
        &mut self,
        album_hash_copy: String,
        balance: Option<U128>,
    );
    
    //* Cross Contract Call Interface to NFT contract 
    //* To transfer ownership to the buyer of the song on sale
    fn nft_transfer_payout_song(
        &mut self,
        song_token_id: String,
        receiver_id: ValidAccountId,
        balance: Option<U128>,
    );

}
'''
'''--- contracts/market/src/internal.rs ---
use crate::*;

impl Contract {
    //Delist song from sale list
    pub(crate) fn internal_remove_song_sale(
        &mut self, 
        nft_contract_id: ValidAccountId, 
        token_id: TokenId
    ) {

        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, ":", token_id);

        let sale_song = self.song_sales.remove(key: &contract_and_token_id).expect("No sale");

    }
}
'''
'''--- contracts/market/src/lib.rs ---

// NEAR SDK Imports
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::json_types::{Base64VecU8, U128, U64};
use near_sdk::collections::{LookupMap};
use near_sdk::{
    env, ext_contract, near_bindgen, AccountId, Balance, Gas,
    BorshStorageKey, PanicOnDefault, Promise,log, 
};

// Rust Std Library Imports
use std::collections::HashMap;

// Re-export of modules
pub use crate::sale::*;
pub use crate::external::*;
mod sale;
mod external;
mod nft_callbacks;

// Type Declarations
pub type ContractAndTokenId = String;
pub type TokenId = String;
pub type AlbumHash = String;

// Constants
const NO_DEPOSIT: Balance = 0;

// Payout determines who gets what after 
pub type Payout = HashMap<AccountId, U128>;

// Boilerplate for setting up allocator used in Wasm binary.
near_sdk::setup_alloc!();

//* Contract Struct Declaration for NEAR collections
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub sales: LookupMap<ContractAndTokenId, Sale>,
    pub song_sales: LookupMap<ContractAndTokenId, SaleSong>,
    pub nft_contract_id: AccountId,
}

//* Helper structure to for keys of the persistent collections.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Sales,
    SongSales,
}

#[near_bindgen]
impl Contract {
    
    //* Contract Initializer Method
    #[init]
    //#[init(ignore_state)]
    pub fn new(owner_id: ValidAccountId, nft_contract_id: ValidAccountId ) -> Self {

        let this = Self {

            //* Owner of the contract
            owner_id: owner_id.into(),

            //* Album Sales
            sales: LookupMap::new(StorageKey::Sales.try_to_vec().unwrap()),
            
            //* Song Sales
            song_sales: LookupMap::new(StorageKey::SongSales.try_to_vec().unwrap()),
                
            //* Album
            nft_contract_id: nft_contract_id.into(),
        };

        this
    }

    pub fn get_album_sale(&self, nft_contract_id: AccountId, album_hash: String) -> Option<Sale> {
        let nft_contract_token = format!("{}{}{}", nft_contract_id,":", album_hash);
        self.sales.get(&nft_contract_token)
    }

    pub fn get_song_sale(&self, nft_contract_id: AccountId, song_token_id: String) -> Option<SaleSong> {
        let nft_contract_token = format!("{}{}{}", nft_contract_id,":", song_token_id);
        self.song_sales.get(&nft_contract_token)
    }
    
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    use super::*;
    use near_sdk::json_types::ValidAccountId;
    use std::convert::TryFrom;
    
    fn alice() -> ValidAccountId {
        ValidAccountId::try_from("alice.near").unwrap()
    }
    fn bob() -> ValidAccountId {
        ValidAccountId::try_from("bob.near").unwrap()
    }
    fn carol() -> ValidAccountId {
        ValidAccountId::try_from("carol.near").unwrap()
    }
    fn dex() -> ValidAccountId {
        ValidAccountId::try_from("dex.near").unwrap()
    }
    fn get_nft_contract_id() -> ValidAccountId {
        ValidAccountId::try_from("nft.amplifytest.testnet").unwrap()
    }

    fn get_context() -> VMContext {
        VMContext {
            predecessor_account_id: "alice.testnet".to_string(),
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "bob.testnet".to_string(),
            signer_account_pk: vec![0],
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
            storage_usage: 1000
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context();
        let mut contract = Contract::new(dex(), get_nft_contract_id());
        // testing_env!(context.is_view(true).build());
        // assert_eq!(contract.nft_token("1".to_string()), None);
    }

}
'''
'''--- contracts/market/src/nft_callbacks.rs ---
use crate::*;

/// approval callbacks from NFT Contracts

// Trait Declaration for Song NFT Approval
//? do we need more params for some reason
trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(&mut self, token_id: TokenId, owner_id: ValidAccountId, price: U128);
}

trait NonFungibleTokensApprovalsReceiver {
    fn nft_on_approve_bulk(&mut self, tokens: Vec<TokenId>, owner_id: ValidAccountId);
}

// Trait Declaration for Album NFT Approval
//? do we need more params for some reason
trait NonFungibleAlbumApprovalReceiver {
    fn album_on_approve(&mut self, album_hash: AlbumHash, owner_id: ValidAccountId, price: U128);
}

#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {
    // For a Song NFT Approval on the marketplace
    #[payable]
    fn nft_on_approve(&mut self, token_id: TokenId, owner_id: ValidAccountId, price: U128) {
        self.check_valid_callback(owner_id.clone());

        let nft_contract_id = env::predecessor_account_id();

        let contract_and_token_id = format!("{}{}{}", nft_contract_id, ":", token_id);
        log!("{:?} contract_and_token_id", contract_and_token_id);

        let existing = self.song_sales.get(&contract_and_token_id);
        if existing.is_some() {
            panic!("Song is already in sale");
        }
        self.song_sales.insert(
            &contract_and_token_id,
            &SaleSong {
                owner_id: owner_id.clone().into(),
                token_id: token_id.clone().into(),
                price,
                created_at: env::block_timestamp().into(),
            },
        );
    }
}

#[near_bindgen]
impl NonFungibleTokensApprovalsReceiver for Contract {
    // For a Song NFT Approval on the marketplace
    #[payable]
    fn nft_on_approve_bulk(&mut self, tokens: Vec<TokenId>, owner_id: ValidAccountId) {
        self.check_valid_callback(owner_id.clone());

        let nft_contract_id = env::predecessor_account_id();
        for token_id in tokens {
            let contract_and_token_id = format!("{}{}{}", nft_contract_id, ":", token_id);
            log!("{:?} contract_and_token_id", contract_and_token_id);
            self.song_sales.insert(
                &contract_and_token_id,
                &SaleSong {
                    owner_id: owner_id.clone().into(),
                    token_id: token_id.clone().into(),
                    price: U128(0),
                    created_at: env::block_timestamp().into(),
                },
            );
        }
    }
}

#[near_bindgen]
impl NonFungibleAlbumApprovalReceiver for Contract {
    //* Adds a sale for particular Album Series
    //* Call from the NFT Contract
    #[payable]
    fn album_on_approve(&mut self, album_hash: AlbumHash, owner_id: ValidAccountId, price: U128) {
        self.check_valid_callback(owner_id.clone());

        let nft_contract_id = env::predecessor_account_id();
        if nft_contract_id != self.nft_contract_id {
            log!(
                "{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",
                false,
                "unauthorized call",
                "UNAUTHORISED_CALL"
            );
            panic!("Unauthorized");
        }

        let contract_and_token_id = format!("{}{}{}", nft_contract_id, ":", album_hash);
        self.sales.insert(
            &contract_and_token_id,
            &Sale {
                owner_id: owner_id.clone().into(),
                created_at: env::block_timestamp().into(),
                album_name: album_hash.clone(),
                price,
                is_album: Some(true),
            },
        );
    }
}

//? why is this needed
#[near_bindgen]
impl Contract {
    #[private]
    pub fn check_valid_callback(&mut self, owner_id: ValidAccountId) {
        // enforce cross contract calls and owner_id is signer

        let nft_contract_id = env::predecessor_account_id();
        let signer_id = env::signer_account_id();
        assert_ne!(
            nft_contract_id, signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );

        assert_eq!(
            owner_id.as_ref(),
            &signer_id,
            "owner_id should be signer_id"
        );
    }
}

'''
'''--- contracts/market/src/sale.rs ---
use crate::*;

const GAS_FOR_MINT: Gas = 40_000_000_000_000;
const GAS_FOR_ROYALTIES: Gas = 120_000_000_000_000;
use near_sdk::promise_result_as_success;
use near_sdk::utils;

//* Sale Structure for Album Sales
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Sale {
    pub owner_id: AccountId,
    pub created_at: U64,
    pub album_name: String,
    pub price: U128, // required
    pub is_album: Option<bool>,
}

//* Sale Structure for
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleSong {
    pub owner_id: AccountId,
    pub token_id: String,
    pub price: U128,
    pub created_at: U64, // required
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

//? Why is this here, when we have price as param in Sales
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Price {
    pub price: Option<U128>,
}

#[near_bindgen]
impl Contract {
    //* Buy Method for Album
    #[payable]
    pub fn offer_album(&mut self, nft_contract_id: ValidAccountId, albumipfs_hash_copy: String) {
        let contract_id: AccountId = nft_contract_id.clone().into();

        if &contract_id != &self.nft_contract_id {
            log!(
                "{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",
                false,
                "wrong nft id",
                "WRONG_NFT_ID"
            );
            panic!("wrong nft id");
        }

        let mut split = albumipfs_hash_copy.split(":");

        if split.clone().count() != 2 {
            log!(
                "{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",
                false,
                "incorrect bundle id",
                "INCORRECT_BUNDLE_ID"
            );
            panic!("Incorrect Bundle ID")
        }

        let (album_id, _copy_no) = (split.next().unwrap(), split.next().unwrap());
        let contract_and_token_id = format!("{}{}{}", contract_id, ":", album_id);
        //* No need to actually remove sale for now if album are greater than, as the thing will fail anyway
        //* But removing sale will help in saving storage
        let v = self.sales.get(&contract_and_token_id);

        let sale = if v.is_some() {
            v.unwrap()
        } else {
            log!(
                "{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",
                false,
                "No sale",
                "NO_SUCH_SALE"
            );
            panic!("No sale");
        };
        let buyer_id = env::predecessor_account_id();

        if (sale.owner_id == buyer_id) == true {
            log!(
                "{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",
                false,
                "Cannot buy on your own sale",
                "CANNOT_BUY_ON_OWN_SALE"
            );
            panic!("Cannot buy on your own sale");
        }

        let deposit = env::attached_deposit();
        let price = sale.price;

        if (deposit > 0) == false {
            log!(
                "{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",
                false,
                "Attached deposit must be greater than 0",
                "DEPOSIT_NOT_GREATER_THAN_0"
            );
            panic!("Attached deposit must be greater than 0");
        }

        if deposit >= price.0 {
            ext_contract::nft_transfer_payout(
                albumipfs_hash_copy,
                Some(U128::from(deposit)),
                &nft_contract_id,
                env::attached_deposit(),
                GAS_FOR_MINT,
            )
            .then(ext_self::resolve_purchase(
                env::signer_account_id(),
                U128::from(deposit),
                price,
                Some(contract_and_token_id),
                &env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_ROYALTIES,
            ));
        } else {
            //* If the deposit is less then panic and give error in Logs
            log!(
                "{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",
                false,
                "deposit is not equal to sale price",
                "DEPOSIT_NOT_EQUAL_TO_SALE_PRICE"
            );
            panic!("deposit is not equal to sale price");
        }
    }

    #[payable]
    pub fn offer(
        &mut self,
        nft_contract_id: ValidAccountId,
        receiver_id: ValidAccountId,
        song_token_id: String,
    ) {
        let deposit = env::attached_deposit();
        let contract_id: AccountId = nft_contract_id.clone().into();
        if &contract_id != &self.nft_contract_id {
            log!(
                "{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",
                false,
                "wrong nft id",
                "WRONG_NFT_ID"
            );
            panic!("wrong nft id");
        }

        let contract_and_token_id = format!("{}{}{}", contract_id, ":", song_token_id);
        let v = self.song_sales.get(&contract_and_token_id);

        let sale = if v.is_some() {
            v.unwrap()
        } else {
            log!(
                "{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",
                false,
                "No sale",
                "NO_SUCH_SONG_SALE"
            );
            panic!("No sale");
        };

        let price = sale.price;

        if deposit >= price.0 {
            ext_contract::nft_transfer_payout_song(
                song_token_id,
                receiver_id,
                Some(U128::from(deposit)),
                &nft_contract_id,
                1,
                GAS_FOR_MINT,
            )
            .then(ext_self::resolve_purchase(
                env::signer_account_id(),
                U128::from(deposit),
                price,
                Some(contract_and_token_id),
                &env::current_account_id(),
                NO_DEPOSIT,
                GAS_FOR_ROYALTIES,
            ));
        } else {
            //* If the deposit is less then panic and give error in Logs
            log!(
                "{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",
                false,
                "deposit is not equal to sale price",
                "DEPOSIT_NOT_EQUAL_TO_SALE_PRICE"
            );
            panic!("deposit is not equal to sale price");
        }
    }
    //* Suited for Amplify Art Purposes
    //* original sell [97% to seller, 3% to platform]
    //* secondary sell [95% to seller, 2% to platform, 3% to original artist]

    #[private]
    pub fn resolve_purchase(
        &mut self,
        buyer_id: AccountId,
        paid: U128,
        price: U128,
        contract_and_token_id: Option<String>,
    ) -> Option<U128> {
        //* Convert Promise to Value
        let payout_option = promise_result_as_success().and_then(|value| {
            //* None means a bad payout from bad NFT contract

            near_sdk::serde_json::from_slice::<Payout>(&value)
                .ok()
                .and_then(|payout| {
                    if payout.len() > 3 || payout.is_empty() {
                        log!("Cannot have more than 3 royalties or no royalties");
                        None
                    } else {
                        let mut remainder = price.0;
                        for &value in payout.values() {
                            remainder = remainder.checked_sub(value.0)?;
                        }
                        if remainder == 0 || remainder == 1 {
                            Some(payout)
                        } else {
                            None
                        }
                    }
                })
        });

        //* is payout option valid?
        let payout = if let Some(payout_option) = payout_option {
            // Only if the payout is valid remove the sale, else dont
            if contract_and_token_id.is_some() {
                self.song_sales
                    .remove(&contract_and_token_id.unwrap())
                    .expect("Not able to remove sale for some reason");

                //self.tokens_per_owner.remove();
            } else {
                panic!("Can not find contract_and_token_id");
            }
            payout_option
        } else {
            //* pay back the deposit for minting the token if this was a series purchase and unsuccessful
            Promise::new(buyer_id).transfer(u128::from(paid));
            return None;
        };
        // NEAR payouts
        for (receiver_id, amount) in payout {
            Promise::new(receiver_id).transfer(amount.0);
        }

        Some(price)
    }
    #[payable]
    pub fn remove_song_sale(&mut self, nft_contract_id: ValidAccountId, token_id: String) {
        // utils::assert_one_yocto();
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, ":", token_id);
        let signer_id = env::predecessor_account_id();
        let current_owner = self.song_sales.get(&contract_and_token_id.clone()).unwrap();
        assert_eq!(
            signer_id, current_owner.owner_id,
            "Only token owner can delist"
        );
        log!(
            "{:?} {:?} {:?}",
            current_owner.owner_id,
            current_owner.token_id,
            signer_id
        );
        self.song_sales
            .remove(&contract_and_token_id)
            .expect("Not able to remove sale for some reason");
    }
}

/// self call

#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(
        &mut self,
        buyer_id: AccountId,
        paid: U128,
        price: U128,
        contract_and_token_id: Option<String>,
    ) -> Promise;
}

'''
'''--- contracts/nft/Cargo.toml ---
[package]
name = "music-nft"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib"] 

[dependencies]
near-sdk = "=3.1.0"
serde_json = "1.0"

[profile.release]
codegen-units=24
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contracts/nft/README.md ---
# TBD

'''
'''--- contracts/nft/build-mainnet.sh ---
#!/bin/bash
set -e
# If you are on windows and using WSL, make sure to run this command 'sed -i -e 's/\r$//' build.sh'

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../mainnet_out/music_nft.wasm

'''
'''--- contracts/nft/build-testnet.sh ---
#!/bin/bash
set -e
# If you are on windows and using WSL, make sure to run this command 'sed -i -e 's/\r$//' build.sh'

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../testnet_out/music_nft.wasm

'''
'''--- contracts/nft/build.sh ---
#!/bin/bash
set -e
# If you are on windows and using WSL, make sure to run this command 'sed -i -e 's/\r$//' build.sh'

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
mkdir -p ../../out
cp target/wasm32-unknown-unknown/release/*.wasm ../../out/music_nft.wasm

'''
'''--- contracts/nft/neardev/dev-account.env ---
CONTRACT_NAME=dev-1641120460472-62531070684087
'''
'''--- contracts/nft/src/enumeration.rs ---
use crate::*;

#[near_bindgen]
impl Contract {

        //Query for the total supply of NFTs on the contract
        pub fn nft_total_supply(&self) -> U128 {
            //return the length of the token metadata by ID
            U128(self.token_metadata_by_id.len() as u128)
        }
    
        //Query for nft tokens on the contract regardless of the owner using pagination
        pub fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<JsonToken> {
            //get a vector of the keys in the token_metadata_by_id collection.  
            let keys = self.token_metadata_by_id.keys_as_vector();
    
            //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
            let start = u128::from(from_index.unwrap_or(U128(0)));
    
            //iterate through the keys vector
            keys.iter()
                //skip to the index we specified in the start variable
                .skip(start as usize) 
                //take the first "limit" elements in the vector. If we didn't specify a limit, use 0
                .take(limit.unwrap_or(0) as usize) 
                //we'll map the token IDs which are strings into Json Tokens
                .map(|token_id| self.nft_token(token_id.clone()).unwrap())
                //since we turned the keys into an iterator, we need to turn it back into a vector to return
                .collect()
        }
    
        //get the total supply of NFTs for a given owner
        pub fn nft_supply_for_owner(
            &self,
            account_id: AccountId,
        ) -> U128 {
            //get the set of tokens for the passed in owner
            let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
    
            //if there is some set of tokens, we'll return the length as a U128
            if let Some(tokens_for_owner_set) = tokens_for_owner_set {
                U128(tokens_for_owner_set.len() as u128)
            } else {
                //if there isn't a set of tokens for the passed in account ID, we'll return 0
                U128(0)
            }
        }
        
        pub fn nft_tokens_for_owner(
            &self,
            account_id: AccountId,
            from_index: Option<U128>,
            limit: Option<u64>,
        ) -> Vec<JsonToken> {
            //get the set of tokens 
            let tokens_for_owner_set = self.tokens_per_owner.get(&account_id);
            
            let tokens = if let Some(tokens_for_owner_set) = tokens_for_owner_set {
                tokens_for_owner_set
            } else {
                return vec![];
            };                                                      

            let keys = tokens.as_vector();

            let start = u128::from(from_index.unwrap_or(U128(0)));

            keys.iter()
                .skip(start as usize) 
                .take(limit.unwrap_or(0) as usize) 
                .map(|token_id| self.nft_token(token_id.clone()).unwrap())
                .collect()
        }
}
'''
'''--- contracts/nft/src/events.rs ---
use std::fmt;

use near_sdk::serde::{Deserialize, Serialize};

/// Enum that represents the data type of the EventLog.
/// The enum can either be an NftMint or an NftTransfer.
#[derive(Serialize, Deserialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[serde(crate = "near_sdk::serde")]
#[non_exhaustive]
pub enum EventLogVariant {
    NftMint(Vec<NftMintLog>),
    NftTransfer(Vec<NftTransferLog>),
}

/// Interface to capture data about an event
///
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct EventLog {
    pub standard: String,
    pub version: String,

    // `flatten` to not have "event": {<EventLogVariant>} in the JSON, just have the contents of {<EventLogVariant>}.
    #[serde(flatten)]
    pub event: EventLogVariant,
}

impl fmt::Display for EventLog {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_fmt(format_args!(
            "EVENT_JSON:{}",
            &serde_json::to_string(self).map_err(|_| fmt::Error)?
        ))
    }
}

/// An event log to capture token minting
///
/// Arguments
/// * `owner_id`: "account.near"
/// * `token_ids`: ["1", "abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftMintLog {
    pub owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

/// An event log to capture token transfer
///
/// Arguments
/// * `authorized_id`: approved account to transfer
/// * `old_owner_id`: "owner.near"
/// * `new_owner_id`: "receiver.near"
/// * `token_ids`: ["1", "12345abc"]
/// * `memo`: optional message
#[derive(Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct NftTransferLog {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub authorized_id: Option<String>,

    pub old_owner_id: String,
    pub new_owner_id: String,
    pub token_ids: Vec<String>,

    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn nep_format_vector() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]},{"owner_id":"user1.near","token_ids":["meme"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![
                NftMintLog {
                    owner_id: "foundation.near".to_owned(),
                    token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                    memo: None,
                },
                NftMintLog {
                    owner_id: "user1.near".to_owned(),
                    token_ids: vec!["meme".to_string()],
                    memo: None,
                },
            ]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_mint() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"foundation.near","token_ids":["aurora","proximitylabs"]}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftMint(vec![NftMintLog {
                owner_id: "foundation.near".to_owned(),
                token_ids: vec!["aurora".to_string(), "proximitylabs".to_string()],
                memo: None,
            }]),
        };
        assert_eq!(expected, log.to_string());
    }

    #[test]
    fn nep_format_transfer_all_fields() {
        let expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"authorized_id":"market.near","old_owner_id":"user1.near","new_owner_id":"user2.near","token_ids":["token"],"memo":"Go Team!"}]}"#;
        let log = EventLog {
            standard: "nep171".to_string(),
            version: "1.0.0".to_string(),
            event: EventLogVariant::NftTransfer(vec![NftTransferLog {
                authorized_id: Some("market.near".to_string()),
                old_owner_id: "user1.near".to_string(),
                new_owner_id: "user2.near".to_string(),
                token_ids: vec!["token".to_string()],
                memo: Some("Go Team!".to_owned()),
            }]),
        };
        assert_eq!(expected, log.to_string());
    }
} 
'''
'''--- contracts/nft/src/internal.rs ---

use crate::*;
use near_sdk::{log, CryptoHash, utils};

    pub(crate) fn assert_at_least_one_yocto() {

        if (env::attached_deposit() >= 1) == false {
            log!("{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",false,"Requires attached deposit of at least 1 yoctoNEAR","ATTACHED_DEPOSIT_ATLEAST_1_YOCTO_REQUIRED");
            panic!("Requires attached deposit of at least 1 yoctoNEAR");
        }
        
    }

    //used to generate a unique prefix in our storage collections (this is to avoid data collisions)
    pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
        //get the default hash
        let mut hash = CryptoHash::default();
        //we hash the account ID and return it
        hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
        hash
    }

impl Contract {

    //add a token to the set of tokens an owner has
    pub(crate) fn internal_add_token_to_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //get the set of tokens for the given account
        let mut tokens_set = self.tokens_per_owner.get(account_id).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKey::TokenPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_account_id(&account_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        //we insert the token ID into the set
        tokens_set.insert(token_id);

        //we insert that set for the given account ID. 
        self.tokens_per_owner.insert(account_id, &tokens_set);
    }

    //remove a token from an owner (internal method and can't be called directly via CLI).
    pub(crate) fn internal_remove_token_from_owner(
        &mut self,
        account_id: &AccountId,
        token_id: &TokenId,
    ) {
        //we get the set of tokens that the owner has
        let mut tokens_set = self
            .tokens_per_owner
            .get(account_id)
            //if there is no set of tokens for the owner, we panic with the following message:
            .expect("Token should be owned by the sender");

        //we remove the the token_id from the set of tokens
        tokens_set.remove(token_id);

        //if the token set is now empty, we remove the owner from the tokens_per_owner collection
        if tokens_set.is_empty() {
            self.tokens_per_owner.remove(account_id);
        } else {
        //if the token set is not empty, we simply insert it back for the account ID. 
            self.tokens_per_owner.insert(account_id, &tokens_set);
        }
    }

    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
    ) -> AccountId {

        let mut split = token_id.split(":");
  
        if  split.clone().count() != 3 {
            log!("{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",false,"incorrect token id","INCORRECT_TOKEN_ID");
            panic!("Incorrect ID");
        }
        
        let (album_id, copy_no, song_id) = (split.next().unwrap(), split.next().unwrap(),split.next().unwrap());
        
        let final_album_id = format!("{}:{}", album_id, copy_no);
        
        let mut owner_vectors = self.album_to_album_bundle_data.get(&final_album_id).unwrap();
        let album_data = self.album_to_album_data.get(&album_id.to_string()).unwrap();
        let song_vectors = album_data.cover_and_song_per_album_type;    
        let index = song_vectors.iter().position(|r| r == song_id).unwrap();
        let prev_owner_id = owner_vectors[index].clone();
    
        if sender_id != &self.market_contract {
            log!("{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",false,"unauthorized call","UNAUTHORISED_CALL");
            panic!("Unauthorized");
        }
        
        let _got = std::mem::replace(&mut owner_vectors[index], receiver_id.clone());
    
        log!(
            "Transfer {} from @{} to @{}",
            token_id,
            &prev_owner_id,
            receiver_id.clone()
        );

        //we remove the token from it's current owner's set
        self.internal_remove_token_from_owner(&prev_owner_id.to_string(), token_id);
        //we then add the token to the receiver_id's set
        self.internal_add_token_to_owner(receiver_id, token_id);

        self.album_to_album_bundle_data.insert(&final_album_id, &owner_vectors);

        prev_owner_id

    }
}

'''
'''--- contracts/nft/src/lib.rs ---

//* near sdk imports
use std::collections::HashMap;

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedSet, UnorderedMap};
use near_sdk::json_types::{Base64VecU8, ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, Gas, AccountId, CryptoHash, Balance, PanicOnDefault, log, ext_contract,
};
use near_sdk::BorshStorageKey;

//* Re-exports
pub use crate::nft_core::*;
pub use crate::token::*;
pub use crate::mint::*;
use crate::internal::*;
pub use crate::metadata::*;
pub use crate::events::*;

mod nft_core;
mod token;
mod mint;
mod internal;
mod metadata;
mod enumeration;
mod events;

//* Constants
pub type AlbumHash = String;
pub type SongHash = String;
pub type CoverHash = String;

const GAS_FOR_ALBUM_APPROVE: Gas = 30_000_000_000_000;
/// This spec can be treated like a version of the standard.
pub const NFT_METADATA_SPEC: &str = "1.0.0";
/// This is the name of the NFT standard we're using
pub const NFT_STANDARD_NAME: &str = "nep171";
//* Boilerplate for setting up allocator used in Wasm binary.
near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub owner_id: AccountId,
    pub market_contract: AccountId,
    pub bundles_bought_per_album_type: LookupMap<AlbumHash,u32>,
    pub album_to_album_bundle_data: LookupMap<String, Vec<AccountId>>,
    pub metadata: LazyOption<NFTMetadata>,
    pub album_to_album_data: LookupMap<String, AlbumData>,
    pub tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,
    pub token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,
}

//* Helper structure to for keys of the persistent collections.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    BundleBoughtPerAlbumType,
    AlbumToAlbumBundleData,
    AlbumToAlbumData,
    NftMetadata,
    TokensPerOwner,
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    TokenMetadataById,
}

#[near_bindgen]
impl Contract {
    //#[init(ignore_state)]
    #[init]
    pub fn new(owner_id: ValidAccountId, metadata: NFTMetadata, market_contract_id: ValidAccountId) -> Self {
        
        let this = Self {
            
            owner_id: owner_id.into(),
            market_contract: market_contract_id.into(),
            bundles_bought_per_album_type: LookupMap::new(StorageKey::BundleBoughtPerAlbumType.try_to_vec().unwrap()),
            album_to_album_bundle_data: LookupMap::new(StorageKey::AlbumToAlbumBundleData.try_to_vec().unwrap()),
            album_to_album_data: LookupMap::new(StorageKey::AlbumToAlbumData.try_to_vec().unwrap()),
            metadata: LazyOption::new(
                StorageKey::NftMetadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),  
            tokens_per_owner: LookupMap::new(StorageKey::TokensPerOwner.try_to_vec().unwrap()),
            token_metadata_by_id: UnorderedMap::new(
                StorageKey::TokenMetadataById.try_to_vec().unwrap(),
            ),   
        };

        this
    }

    //* Storing the token types / Album, Listing the Album on the Market Cross Contract
    #[payable]
    pub fn add_token_types(&mut self,
        album_hash: AlbumHash,
        cover_songslist: Vec<SongHash>,
        songs_metadatalist: Vec<TokenMetadata>,
        number_of_album_copies:u32,
        price: U128,
    ){

        assert_at_least_one_yocto();
        
        let initial_storage_usage = env::storage_usage();

        if number_of_album_copies <= 0 {
            log!("{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",false,"incorrect number of copies","INCORRECT_NO_OF_COPIES");
            panic!("incorrect number of copies");
        };

        let v: Vec<u32> = (0..number_of_album_copies).collect();

        self.album_to_album_data.insert(
            &album_hash,
            &AlbumData {
                copies_per_album_type: v.clone(),
                album_to_creator: env::predecessor_account_id().clone(),
                cover_and_song_per_album_type: cover_songslist.clone(),
            },
        );

        if (self.bundles_bought_per_album_type.insert(&album_hash, &0).is_none()) == false {
            log!("{{\"token_type\":\"{}\",\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}", &album_hash,false, "album type exists", "ALBUM_TYPE_EXISTS");
            panic!("Album Already exists");
        };

        for (_index, album_copie) in (0..number_of_album_copies.clone()).enumerate() {
            let mut i = 0;
            while i < cover_songslist.len() {
                let token_id:TokenId = format!("{}:{}:{}", &album_hash, album_copie + 1, cover_songslist[i]);
                self.token_metadata_by_id.insert(&token_id, &songs_metadatalist[i]);
                i += 1;
            }
        }

        let storage_cost = env::storage_byte_cost() * Balance::from(env::storage_usage() - initial_storage_usage);
        
        //* Cross Contract Call to Market Contract Call
        ext_non_fungible_album_approval_receiver::album_on_approve(
            album_hash,
            env::signer_account_id(),
            price,
            &self.market_contract,
            env::attached_deposit()
            .checked_sub(storage_cost)
            .expect("Deposit not enough for approval"),
            env::prepaid_gas() - GAS_FOR_ALBUM_APPROVE,
        );
        
    }

    pub fn get_album_bundle_owners(&self, album_hash_copy: String) -> Option<Vec<AccountId>> {
        self.album_to_album_bundle_data.get(&album_hash_copy)
    }

}

#[ext_contract(ext_non_fungible_album_approval_receiver)]
trait NonFungibleAlbumApprovalReceiver {
    fn album_on_approve(&mut self, album_hash: AlbumHash, owner_id: AccountId, price: U128);
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};

    use super::*;
    use near_sdk::json_types::ValidAccountId;
    use std::convert::TryFrom;

    fn alice() -> ValidAccountId {
        ValidAccountId::try_from("alice.near").unwrap()
    }
    fn bob() -> ValidAccountId {
        ValidAccountId::try_from("bob.near").unwrap()
    }
    fn carol() -> ValidAccountId {
        ValidAccountId::try_from("carol.near").unwrap()
    }
    fn dex() -> ValidAccountId {
        ValidAccountId::try_from("dex.near").unwrap()
    }
    fn get_market_contract_id() -> ValidAccountId {
        ValidAccountId::try_from("market.amplifytest.testnet").unwrap()
    }
    fn get_context() -> VMContext {
        VMContext {
            predecessor_account_id: "alice.testnet".to_string(),
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "bob.testnet".to_string(),
            signer_account_pk: vec![0],
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
            storage_usage: 1000
        }
    }
        
    #[test]
    fn test_new() {
        let mut context = get_context();
        //let mut contract = Contract::new(dex(), get_market_contract_id());
        // testing_env!(context.is_view(true).build());
        // assert_eq!(contract.nft_token("1".to_string()), None);
    }

}
'''
'''--- contracts/nft/src/metadata.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct NFTMetadata {
    pub spec: String,              // required, essentially a version like "nft-1.0.0"
    pub name: String,              // required, ex. "Mosaics"
    pub symbol: String,            // required, ex. "MOSIAC"
    pub icon: Option<String>,      // Data URL
    pub base_uri: Option<String>, // Centralized gateway known to have reliable access to decentralized storage assets referenced by `reference` or `media` URLs
    pub reference: Option<String>, // URL to a JSON file with more info
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub title: Option<String>, // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
    pub description: Option<String>, // free-form description
    pub media: Option<String>, // URL to associated media, preferably to decentralized, content-addressed storage
    pub media_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
    pub copies: Option<u64>, // number of copies of this set of metadata in existence when token was minted.
    pub issued_at: Option<u64>, // When token was issued or minted, Unix epoch in milliseconds
    pub expires_at: Option<u64>, // When token expires, Unix epoch in milliseconds
    pub starts_at: Option<u64>, // When token starts being valid, Unix epoch in milliseconds
    pub updated_at: Option<u64>, // When token was last updated, Unix epoch in milliseconds
    pub extra: Option<String>, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
    pub reference: Option<String>, // URL to an off-chain JSON file with more info.
    pub reference_hash: Option<Base64VecU8>, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    //owner of the token
    pub owner_id: AccountId,
}

//The Json token is what will be returned from view calls. 
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct JsonToken {
    //token ID
    pub token_id: TokenId,
    //owner of the token
    pub owner_id: AccountId,
    //token metadata
    pub metadata: TokenMetadata,
}

pub trait NonFungibleTokenMetadata {
    //view call for returning the contract metadata
    fn nft_metadata(&self) -> NFTMetadata;
}

#[near_bindgen]
impl NonFungibleTokenMetadata for Contract {
    fn nft_metadata(&self) -> NFTMetadata {
        self.metadata.get().unwrap()
    }
}
'''
'''--- contracts/nft/src/mint.rs ---
use crate::*;

const GAS_FOR_NFT_APPROVE: Gas = 30_000_000_000_000;

#[near_bindgen]
impl Contract {

    #[payable]
    pub fn nft_mint(
        &mut self,
        album_hash_copy: String,//Album:1//Album:2//Album:3
    ) -> AccountId {
        assert_at_least_one_yocto();
        let initial_storage_usage = env::storage_usage();

        let mut split = album_hash_copy.split(":");
        
        if split.clone().count() != 2 {
            
            log!("{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",false,"incorrect bundle id","INCORRECT_BUNDLE_ID");
            panic!("Incorrect Bundle ID");
        
        }

        let (album_id, copy_no) = (split.next().unwrap(), split.next().unwrap());

        //* Called when offer is called to set owner of the album bundle song NFTs  
        if &env::predecessor_account_id() != &self.market_contract {
            
            log!("{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",false,"unauthorized call","UNAUTHORISED_CALL");
            panic!("predecessor_account_id (market?) not approved")
        
        }

        let album_data = self.album_to_album_data.get(&album_id.to_string()).unwrap();

        let number_of_max_copies = album_data.copies_per_album_type.len();

        let v = self.bundles_bought_per_album_type.get(&album_id.to_string());//1,2,3

        let v_1 = v.unwrap() + 1;

        let no = copy_no.parse::<u32>().unwrap();
        //album:2 cannot be bought befroe album:1
        //Serial buy
        if v_1 != no {
            
            if no > v_1 {

                log!("{{\"album_type\":\"{}\",\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",album_hash_copy,false,"album already bought","ALBUM_SERIAL_BUY_ERROR");
                panic!("album serial buy error");

            }

            if no < v_1 {

                log!("{{\"album_type\":\"{}\",\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",album_hash_copy,false,"album already bought","ALBUM_ALREADY_BOUGHT");
                panic!("album already bought");

            }
        }
    
        //* If greater than number of copies, don't mint.
        if v_1 > number_of_max_copies as u32 {

            log!("{{\"album_type\":\"{}\",\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",album_hash_copy,false,"Cant buy more album bundles","NO_MORE_BUNDLES");
            panic!("No more album bundles available");

        }
        
        self.bundles_bought_per_album_type.insert(&album_id.to_string(), &v_1);

        let owner_id = env::signer_account_id();

        let final_album_id = format!("{}", album_hash_copy);

        let number_of_songs = album_data.cover_and_song_per_album_type;

        let mut cc: Vec<String> = vec![];

        let mut tokens: Vec<TokenId> = vec![];
       
        //Get tokens_per_owner populated by data
        let mut tokens_set = self.tokens_per_owner.get(&env::signer_account_id().to_string()).unwrap_or_else(|| {
            //if the account doesn't have any tokens, we create a new unordered set
            UnorderedSet::new(
                StorageKey::TokenPerOwnerInner {
                    //we get a new unique prefix for the collection
                    account_id_hash: hash_account_id(&env::signer_account_id().to_string()),
                }
                .try_to_vec()
                .unwrap(),
            )
        });

        for _x in number_of_songs.clone() {

            cc.push(owner_id.clone());

            let token_id:TokenId = format!("{}:{}", album_hash_copy, _x);

            //Get tokens_per_owner populated by data
            tokens_set.insert(&token_id);

            //insert the token ID and metadata
            //self.token_metadata_by_id.insert(&token_id, &metadata);

            tokens.push(token_id);
        }
        
        let storage_cost = env::storage_byte_cost() * Balance::from(env::storage_usage() - initial_storage_usage);

        ext_non_fungibles_approval_receiver::nft_on_approve_bulk(
            tokens.clone(),
            env::signer_account_id(),
            &self.market_contract,
            env::attached_deposit()
                .checked_sub(storage_cost)
                .expect("Deposit not enough for approval"),
            env::prepaid_gas() - GAS_FOR_NFT_APPROVE,
        );
        
        // SongIPFSHash1, SongIPFSHash2 // Struct Values
        // Owner 1, Owner 1 // Vector with all the owners
        // Album:1 --> Song1, song2, song3
        //Album:1 --> Owner1, Owner2, Owner3
        self.album_to_album_bundle_data.insert(&final_album_id, &cc);
        
        //Get tokens_per_owner populated by data
        self.tokens_per_owner.insert(&env::signer_account_id().to_string(), &tokens_set);

        // Construct the mint log as per the events standard.
        let nft_mint_log: EventLog = EventLog {
            // Standard name ("nep171").
            standard: NFT_STANDARD_NAME.to_string(),
            // Version of the standard ("nft-1.0.0").
            version: NFT_METADATA_SPEC.to_string(),
            // The data related with the event stored in a vector.
            event: EventLogVariant::NftMint(vec![NftMintLog {
                // Owner of the token.
                owner_id: env::signer_account_id().to_string(),
                // Vector of token IDs that were minted.
                token_ids: tokens,
                // An optional memo to include.
                memo: None,
            }]),
        };

        // Log the serialized json.
        log!("{}", &nft_mint_log.to_string());

        //* Return to nft_transfer_payout in nft_core.rs
        album_data.album_to_creator
        
    }

}

'''
'''--- contracts/nft/src/nft_core.rs ---
use crate::*;
use near_sdk::json_types::{ValidAccountId, U64};
use near_sdk::{ext_contract, log, Gas};

//* CONSTANTS
//* This is good. Finally the promises will be better
const GAS_FOR_NFT_APPROVE: Gas = 60_000_000_000_000;

//? Why dont we need this constants now
//// const GAS_FOR_RESOLVE_TRANSFER: Gas = 10_000_000_000_000;
///// const GAS_FOR_NFT_TRANSFER_CALL: Gas = 25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER;
///// const NO_DEPOSIT: Balance = 0;
//* These are all NFT standards, need to make the contract as compatible to NEP-171 contract as possible.

pub trait NonFungibleTokenCore {
    
    //* Transfer Album Bundle and generates a payout variable which Market acts on
    fn nft_transfer_payout(
        &mut self,
        album_hash: String,
        balance:Option<U128>,
    ) -> Option<Payout>;

    //* Transfer Song NFT and generates a payout variable which Market acts on
    fn nft_transfer_payout_song(
        &mut self,
        song_token_id: String,
        receiver_id: ValidAccountId,
        balance:Option<U128>,
    ) -> Option<Payout>;

    //* Approve the marketplace for sale of the song NFT
    fn nft_approve(&mut self, token_id: TokenId, account_id: ValidAccountId, price: U128);

    //* View Method to know the owner and metadata of a particular token
    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken>;

}

#[ext_contract(ext_non_fungible_token_receiver)]
trait NonFungibleTokenReceiver {
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_non_fungible_approval_receiver)]
trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        price: U128,
    );
}

#[ext_contract(ext_non_fungibles_approval_receiver)]
trait NonFungibleTokensApprovalsReceiver {
    fn nft_on_approve_bulk(
        &mut self,
        tokens: Vec<TokenId>,
        owner_id: AccountId,
    );
}

#[ext_contract(ext_self)]
trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        owner_id: AccountId,
        receiver_id: AccountId,
        approved_account_ids: HashMap<AccountId, U64>,
        token_id: TokenId,
    ) -> bool;
}

trait NonFungibleTokenResolver {
    fn nft_resolve_transfer(
        &mut self,
        owner_id: AccountId,
        receiver_id: AccountId,
        approved_account_ids: HashMap<AccountId, U64>,
        token_id: TokenId,
    ) -> bool;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {

    //* Royalty Support    
    //* Meant for Album Bundle Royalty Support
    //* original sell [97% to seller, 3% to platform]
    #[payable]
    fn nft_transfer_payout(
        &mut self,
        album_hash_copy: String,
        balance: Option<U128>,
    ) -> Option<Payout> {
        
        let owner_id = self.nft_mint(album_hash_copy.clone());

        let payout = if let Some(balance) = balance {

            let complete_royalty = 10_000u128;
            let balance_piece = u128::from(balance) / complete_royalty;
            let mut payout: Payout = HashMap::new();

            // Payout to Platform
            payout.insert(self.owner_id.clone(), U128(300 as u128 * balance_piece));
          
            // payout to Seller
            payout.insert(owner_id, U128(9700 as u128 * balance_piece));

            Some(payout)
            
        } else {
            None
        };

        payout

    }

    //* secondary sell [95% to seller, 2% to platform, 3% to original artist]
    #[payable]
    fn nft_transfer_payout_song(
        &mut self,
        song_token_id: String,
        receiver_id: ValidAccountId,
        balance: Option<U128>,
    ) -> Option<Payout> {
    
        let sender_id = env::predecessor_account_id();

        // First transfer the song token
        let owner_id = self.internal_transfer(&sender_id, receiver_id.as_ref(), &song_token_id);

        let mut split = song_token_id.split(":");
        
        if split.clone().count() != 3 {
            log!("{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",false,"incorrect token id","INCORRECT_TOKEN_ID");
            panic!("Incorrect Token ID")
        } 

        let (album_id, _copy_no, _song_id) = (split.next().unwrap(), split.next().unwrap(),split.next().unwrap());
        // let artist = self.album_to_creator.get(&album_id.to_string()).unwrap();
        let album_data = self.album_to_album_data.get(&album_id.to_string()).unwrap();
        let artist = album_data.album_to_creator;

        // Get the album royalty structure
        let payout = if let Some(balance) = balance {

            let complete_royalty = 10_000u128;
            let balance_piece = u128::from(balance) / complete_royalty;
            let mut payout: Payout = HashMap::new();

            // Payout to Platform
            payout.insert(self.owner_id.clone(), U128(200 as u128 * balance_piece));
          
            // Payout to Artist
            payout.insert(artist, U128(300 as u128 * balance_piece));

            // payout to Seller
            payout.insert(owner_id, U128(9500 as u128 * balance_piece));

            Some(payout)

        } else {
            None
        };

        payout
    }

    #[payable]
    fn nft_approve(&mut self, token_id: TokenId, account_id: ValidAccountId, price: U128) {
        assert_at_least_one_yocto();
        
        let initial_storage_usage = env::storage_usage();
        let account_id: AccountId = account_id.into();
        
        if &account_id != &self.market_contract{
            
            log!("{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",false,"wrong market","WRONG_MARKET_ID");
            panic!("wrong market id");

        }
        // ALbum1:1:song1

        let mut split = token_id.split(":");

        if split.clone().count() != 3 {
            log!("{{\"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",false,"incorrect token id","INCORRECT_TOKEN_ID");
            panic!("Incorrect Token ID")
        } 

        let (album_id, copy_no, song_id) = (split.next().unwrap(), split.next().unwrap(), split.next().unwrap());

        // let (album_id, copy_no, song_id) = (split.next().unwrap(), split.next().unwrap(),split.next().unwrap());
        //Eg album:1
        let final_album_id = format!("{}:{}", album_id, copy_no);
        let owner_vectors = self.album_to_album_bundle_data.get(&final_album_id).unwrap();
        let album_data = self.album_to_album_data.get(&album_id.to_string()).unwrap();
        let song_vectors = album_data.cover_and_song_per_album_type;

        let index = song_vectors.iter().position(|r| r == song_id).unwrap();

        if &env::predecessor_account_id() != &owner_vectors[index] {
            
            log!("{{\"token_id\":\"{}\",\"predecessor\":\"{}\",\"token_owner\":\"{}\", \"success\":\"{}\",\"message\":\"{}\",\"error_type\":\"{}\"}}",token_id,&env::predecessor_account_id(), &owner_vectors[index], false,"Predecessor must be the token owner","PREDECESSOR_NOT_TOKEN_OWNER");
            panic!("Predecessor must be the token owner");
        
        }

        let storage_cost = env::storage_byte_cost() * Balance::from(env::storage_usage() - initial_storage_usage);

        ext_non_fungible_approval_receiver::nft_on_approve(
            token_id.clone(),
            env::signer_account_id(),
            price,
            &account_id,
            env::attached_deposit()
                    .checked_sub(storage_cost)
                    .expect("Deposit not enough for approval"),
            env::prepaid_gas() - GAS_FOR_NFT_APPROVE,
        );

    }

    fn nft_token(&self, token_id: TokenId) -> Option<JsonToken> {
        
        let metadata = self.token_metadata_by_id.get(&token_id).unwrap();
        let mut split = token_id.split(":");
        let (album_id, copy_no, song_id) = (split.next().unwrap(), split.next().unwrap(),split.next().unwrap());
        // let album_data = self.album_to_album_data.get(&album_id.to_string()).unwrap();
        let album_data_option = self.album_to_album_data.get(&album_id.to_string());
        if album_data_option.is_none() {
            return None
        }
        let album_data = album_data_option.unwrap();
        let final_album_id = format!("{}:{}", album_id, copy_no);
        let owner_vector_option = self.album_to_album_bundle_data.get(&final_album_id);
        if owner_vector_option.is_none() {
            
            return Some(JsonToken {
                token_id:token_id.clone(),
                owner_id:album_data.album_to_creator.clone(),
                //album: final_album_id.clone(),
                metadata,
            })
        
        }

        let owner_vectors = owner_vector_option.unwrap();
        let song_vectors = album_data.cover_and_song_per_album_type;

        let index = song_vectors.iter().position(|r| r == song_id).unwrap();
        let owner_id = owner_vectors[index].clone();
        
        Some(JsonToken {
            token_id: token_id.clone(),
            owner_id: owner_id.clone(),
            metadata,
        })
    }
}
'''
'''--- contracts/nft/src/token.rs ---
use crate::*;

pub type TokenId = String;
pub type Payout = HashMap<AccountId, U128>;

//? Do we use it anywhere, since we have changed the design
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Token {
    pub owner_id: AccountId,
}

//* Useful for Read Method
// #[derive(Serialize, Deserialize)]
// #[serde(crate = "near_sdk::serde")]
// pub struct JsonToken {
//     pub token_id: TokenId,
//     pub owner_id: AccountId,
//     pub album: AlbumHash,
// }

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AlbumData {
   
    pub copies_per_album_type: Vec<u32>,
    pub cover_and_song_per_album_type: Vec<String>,
    pub album_to_creator: AccountId,

}

'''
'''--- docs/document.txt ---
near call nft.bitmonk.testnet add_token_types '{"album_hash":"9500","cover_songslist":["9001","9002"],"songs_metadatalist":[{"title": "AmplifyArt9001", "description": "Amplify art new music 9001", "media": "https://bafybeigvvcy6eoo6n3k7kzkamwuze7b2vfotqsgso3qcrh34w7oxmjkzru.ipfs.dweb.link/"},{"title": "AmplifyArt9002", "description": "Amplify art volume 1 9002", "media": "https://bafybeiac2eqj3dnazlanflapfgvrwlfu7sl7gw2sa3maponkpaeprrszay.ipfs.dweb.link/"}],"number_of_album_copies":5,"price":"1"}' --accountId=bitmonk.testnet --deposit=1 --gas 200000000000000
'''
'''--- docs/folder_structure.md ---
/contracts
Contain the NFT and Market Contracts

/diagrams
Contain the Diagrammatical representation of the Project and

/keys
has only some testnet keys. Not needed since the keys have been hardcoded in the deployment scripts.

/mainnet
Contains the mainnet config, deployments scripts. Read it carefully.

/mainnet_out
WASM files compiled when yarn build-nft-mainnet or build-market-market

/neardev
Contains the Account ID for deployment to dev-1631962167293-57148505657038

/nearmainnet
Contains the Account ID for deployment to mainnet dev amplifyapp.near

/neartestnet
Contains the Account ID for deployment to testnet

/old
Contains some old contracts made from the NEP-171 implementations in https://github.com/near-examples/nft-market

/out
Contains the wasm files for dev-1631962167293-57148505657038(Not useful)

/scripts
Contains many scripts for calling the Smart Contract. app5.js was the latest. Read them properly so as to understand the logic.

/testnet_out
WASM files compiled when yarn build-nft-testnet or build-market-testnet

/testnet-2
Contains the Testnet Config files(deployed on nft.dev-1633963337441-72420501486968)

/utils
Contains the Testnet Config Files for dev-1631962167293-57148505657038
'''
'''--- docs/nep-171.md ---
The problem statement doesnt fit properly into NEP-171 examples. Also doesnt fit the nft-series repo
https://github.com/near-examples/nft-series.
If we follow the NEP-171 standard, it will cause lots of gas errros and high storage costs.
So had to implement something different and still make it compatible with NEP-171.

Since a album has many album bundles, and a album bundle will have many songs. It is a many to many relationship.
So what I did was simulate a many to many relationship. If you can check the diagrams folder you will know better. You need to install draw.io Visual Studio Code Extension for that.
'''
'''--- docs/stateDoc.txt ---
    
NFT contract    

    1. owner_id: AccountId,
    # market_contract: AccountId,
    # bundles_bought_per_album_type: LookupMap<AlbumHash,u32>,
    # album_to_album_bundle_data: LookupMap<String, Vec<AccountId>>,
    # metadata: LazyOption<NFTMetadata>,
    # album_to_album_data: LookupMap<String, AlbumData>,
    # tokens_per_owner: LookupMap<AccountId, UnorderedSet<TokenId>>,
    # token_metadata_by_id: UnorderedMap<TokenId, TokenMetadata>,
'''
'''--- docs/token_ipfs.md ---
Here most of the minting concept is taken up from the 
Remember that the Album / Album Bundle is not an NFT. But when you buy a album bundle, you all the song and Cover NFTs.
The TokenID or the unique identifier of the song / cover NFT is in this format

AlbumIPFSHash:BundleNO:SongHash
QmZ9Rvr3Z9EMqDb5sCV49aNnpwmiMKoT69naokRVysma5s:1:QmXSVdaJSfwYn4eMTBaeWN6ZYRwS62Mcu4FeWABGVu68q4
QmZ9Rvr3Z9EMqDb5sCV49aNnpwmiMKoT69naokRVysma5s:2:QmXSVdaJSfwYn4eMTBaeWN6ZYRwS62Mcu4FeWABGVu68q4
'''
'''--- docs/upgrade.md ---
While upgrading you need to test the contract upgrade on Testnet first and then Mainnet.
If upgrade fails, there is huge risk losing all data.

Upgrade may fail for many reasons
1) You rearranged the Contract Storage State.
2) When you changed the state you didnt migrate to the newer state.

The upgrade will never fail if you just change the code except if you change the Contract Storage State code without migrate call.

Never commit until functionality/upgrade is tested on Testnet after the ugrade happens. If somehow the upgrade fails on the testnet, remove every change and go to the last change and try fresh deployment using testnet-2/deploy-nft-testnet and upgrading again.

Reference:
https://www.near-sdk.io/upgrading/production-basics

Each new upgrade gets a new Branch as upgrading is to be a little careful.

For upgrading on Mainnet use deploy-nft-mainnet-upgrade.js to upgrade NFT contract and deploy-market-mainnet-upgrade.js for Market in mainnet/
or for Testnet use deploy-nft-testnet-upgrade.js or deploy-market-testnet-upgrade.js

please read NEAR Docs well as well ask on the Discord Channel.
'''
'''--- package.json ---
{
  "name": "music-non-fungible-token",
  "version": "0.2.5",
  "description": "Implementation of NFT Music Marketplace using Rust",
  "author": "Near, Inc. <hello@near.org>",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {

    "build": "cd contracts/nft && cargo check && cd ../.. && cd contracts/market && cargo check && cd ../..",
    "build:contracts": "cd contracts/nft && ./build.sh && cd ../.. && cd contracts/market && ./build.sh && cd ../..",
    "account": "rm -rf neardev && (near dev-deploy || exit 0)",
    "deploy": "cd utils && node patch-config.js && node deploy.js",
    "build-nft":"cd contracts/nft && ./build.sh",
    "build-market":"cd contracts/market && ./build.sh",
    "build-nft-testnet":"cd contracts/nft && ./build-testnet.sh",
    "build-market-testnet":"cd contracts/market && ./build-testnet.sh",
    "build-nft-mainnet":"cd contracts/nft && ./build-mainnet.sh",
    "build-market-mainnet":"cd contracts/market && ./build-mainnet.sh"    
  },
  "devDependencies": {
    "jest": "^26.6.3",
    "near-cli": "^2.0.1",
    "near-sdk-as": "^3.2.0"
  },
  "engines": {
    "node": ">=12.0.0"
  },
  "dependencies": {
    "bn.js": "^5.2.0",
    "bs58": "^4.0.1",
    "crypto": "^1.0.1",
    "dotenv": "^10.0.0",
    "fs": "^0.0.1-security",
    "ipfs-core": "^0.8.0",
    "near-api-js": "^0.42.0",
    "node-fetch": "^2.6.1",
    "patch-package": "^6.4.7",
    "postinstall-postinstall": "^2.1.0"
  }
}

'''
'''--- scripts/app.js ---
const { connect, KeyPair, keyStores, utils } = require("near-api-js");
const path = require("path");
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";

const config = {
  networkId: "testnet",
  nodeUrl: "https://rpc.testnet.near.org",
  walletUrl: "https://wallet.testnet.near.org",
  helperUrl: "https://helper.testnet.near.org",
};

// if (process.argv.length !== 5) {
//   console.info(
//     "Please run command in the following format: \n node create-account CREATOR_ACCOUNT.testnet NEW_ACCOUNT.testnet AMOUNT"
//   );
//   process.exit(1);
// }

createAccount(process.argv[2], process.argv[3], process.argv[4]);

async function createAccount(creatorAccountId, newAccountId, amount) {
  const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
  const keyStore = new keyStores.UnencryptedFileSystemKeyStore(credentialsPath);
  const near = await connect({ ...config, keyStore });
  const creatorAccount = await near.account(creatorAccountId);
  const keyPair = KeyPair.fromRandom("ed25519");
  const publicKey = keyPair.publicKey.toString();
  await keyStore.setKey(config.networkId, newAccountId, keyPair);

  return await creatorAccount.functionCall({
    contractId: "testnet",
    methodName: "create_account",
    args: {
      new_account_id: newAccountId,
      new_public_key: publicKey,
    },
    gas: "300000000000000",
    attachedDeposit: utils.format.parseNearAmount(amount),
  });
}
'''
'''--- scripts/app.test.js ---
const fs = require('fs');
const BN = require('bn.js');
const nearAPI = require('near-api-js');
const testUtils = require('./test-utils');
const getConfig = require('./config');

const { 
	Contract, KeyPair, Account,
	utils: { format: { parseNearAmount }},
	transactions: { deployContract, functionCall },
} = nearAPI;
const { 
	connection, initContract, getAccount, getAccountBalance,
	contract, contractAccount, contractName, contractMethods, createAccessKeyAccount,
	createOrInitAccount,
	getContract,
} = testUtils;
const { 
	networkId, GAS, GUESTS_ACCOUNT_SECRET
} = getConfig();

jasmine.DEFAULT_TIMEOUT_INTERVAL = 60000;

/// setup consts
const DELIMETER = '||';

const now = Date.now();
const tokenTypes = [
	// one unique type
	`typeA:${now}`,
		// 2 tokens of same type
	`typeB:${now}`,
	`typeB:${now}`,
];
const tokenIds = tokenTypes.map((type, i) => `${type}:${i}`);
console.log(tokenTypes)
console.log(tokenIds)

let sale_conditions = [
				{
					ft_token_id: 'near',
					price: 1 
				}
			];

console.log(JSON.stringify({sale_conditions}));
const contract_royalty = 500;

const metadata = {
	media: 'https://media1.tenor.com/images/4c1d96a989150e7019bfbabbebd2ff36/tenor.gif?itemid=20269144',
	issued_at: now.toString()
};
const metadata2 = {
	media: 'https://media1.tenor.com/images/818161c07948bac34aa7c5f5712ec3d7/tenor.gif?itemid=15065455',
	issued_at: now.toString()
};

/// contractAccount.accountId is the NFT contract and contractAccount is the owner
/// see initContract in ./test-utils.js for details
const contractId = contractAccount.accountId;
console.log('\n\n contractId:', contractId, '\n\n');
/// the test fungible token
const fungibleId = 'fungible.' + contractId;
/// the market contract
const marketId = 'market.' + contractId;

describe('deploy contract ' + contractName, () => {

	let alice, aliceId, bob, bobId,
		fungibleAccount, marketAccount,
		storageMinimum, storageMarket;

	/// most of the following code in beforeAll can be used for deploying and initializing contracts
	/// skip tests if you want to deploy to production or testnet without any NFTs
	beforeAll(async () => {
	    await initContract();

		/// some users
		aliceId = 'alice-' + now + '.' + contractId;
		alice = await getAccount(aliceId);
		console.log('\n\n Alice accountId:', aliceId, '\n\n');

		bobId = 'bob-' + now + '.' + contractId;
		bob = await getAccount(bobId);
		console.log('\n\n Bob accountId:', bobId, '\n\n');

		// set contract royalty to 5%
		await contractAccount.functionCall({
			contractId: contractName,
			methodName: 'set_contract_royalty',
			args: { contract_royalty },
			gas: GAS
		});
		
		// set token types and hard supply caps
		const supply_cap_by_type = {
			[tokenTypes[0]]: '1',
			[tokenTypes[1]]: '500',
		};
		
		await contractAccount.functionCall({
			contractId,
			methodName: 'add_token_types',
			args: { supply_cap_by_type },
			gas: GAS
		});
		
		/// create or get fungibleAccount and deploy ft.wasm (if not already deployed)
		fungibleAccount = await createOrInitAccount(fungibleId, GUESTS_ACCOUNT_SECRET);
		const fungibleAccountState = await fungibleAccount.state();
		console.log('\n\n state:', fungibleAccountState, '\n\n');
		if (fungibleAccountState.code_hash === '11111111111111111111111111111111') {
			const fungibleContractBytes = fs.readFileSync('./out/ft.wasm');
			console.log('\n\n deploying fungibleAccount contractBytes:', fungibleContractBytes.length, '\n\n');
			const newFungibleArgs = {
				/// will have totalSupply minted to them
				owner_id: contractId,
				total_supply: parseNearAmount('1000000'),
				name: 'Test Fungible T',
				symbol: 'TFT',
				// not set by user request
				version: '1',
				reference: 'https://github.com/near/core-contracts/tree/master/w-near-141',
				reference_hash: '7c879fa7b49901d0ecc6ff5d64d7f673da5e4a5eb52a8d50a214175760d8919a',
				decimals: 24,
			};
			const actions = [
				deployContract(fungibleContractBytes),
				functionCall('new', newFungibleArgs, GAS)
			];
			await fungibleAccount.signAndSendTransaction({ receiverId: fungibleId, actions });
			/// find out how much needed to store for FTs
			storageMinimum = await contractAccount.viewFunction(fungibleId, 'storage_minimum_balance');
			console.log('\n\n storageMinimum:', storageMinimum, '\n\n');
			/// pay storageMinimum for all the royalty receiving accounts
			const promises = [];
			for (let i = 1; i < 6; i++) {
				promises.push(fungibleAccount.functionCall({
					contractId: fungibleId,
					methodName: 'storage_deposit',
					args: { account_id: `a${i}.testnet` },
					gas: GAS,
					attachedDeposit: storageMinimum
				}));
			}
			await Promise.all(promises);
		} else {
			/// find out how much needed to store for FTs
			storageMinimum = await contractAccount.viewFunction(fungibleId, 'storage_minimum_balance');
			console.log('\n\n storageMinimum:', storageMinimum, '\n\n');
		}

		/** 
		 * Deploy the Market Contract and connect it to the NFT contract (contractId)
		 * and the FT contract (fungibleAccount.[contractId])
		 */ 

		/// default option for markets, init with all FTs you want it to support
		const ft_token_ids = [fungibleId];
		
		/// create or get market account and deploy market.wasm (if not already deployed)
		marketAccount = await createOrInitAccount(marketId, GUESTS_ACCOUNT_SECRET);
		const marketAccountState = await marketAccount.state();
		console.log('\n\nstate:', marketAccountState, '\n\n');
		if (marketAccountState.code_hash === '11111111111111111111111111111111') {

			const marketContractBytes = fs.readFileSync('./out/market.wasm');
			console.log('\n\n deploying marketAccount contractBytes:', marketContractBytes.length, '\n\n');
			const newMarketArgs = {
				owner_id: contractId,
				ft_token_ids
			};
			const actions = [
				deployContract(marketContractBytes),
				functionCall('new', newMarketArgs, GAS)
			];
			await marketAccount.signAndSendTransaction({ receiverId: marketId, actions });

			/// NOTE market must register for all ft_token_ids it wishes to use (e.g. use this loop for standard fts)
			ft_token_ids.forEach(async (ft_token_id) => {
				const deposit = await marketAccount.viewFunction(ft_token_id, 'storage_minimum_balance');
				await marketAccount.functionCall({
					contractId: ft_token_id,
					methodName: 'storage_deposit',
					args: {},
					gas: GAS,
					attachedDeposit: deposit
				});
			});
		}
		// get all supported tokens as array
		const supportedTokens = await marketAccount.viewFunction(marketId, 'supported_ft_token_ids');
		console.log('\n\n market supports these fungible tokens:', supportedTokens, '\n\n');

		// should be [false], just testing api
		const added = await contractAccount.functionCall({
			contractId: marketId,
			methodName: 'add_ft_token_ids',
			args: { ft_token_ids },
			gas: GAS,
		});
		console.log('\n\n added these tokens', supportedTokens, '\n\n');

		/// find out how much needed for market storage
		storageMarket = await contractAccount.viewFunction(marketId, 'storage_amount');
		console.log('\n\n storageMarket:', storageMarket, '\n\n');
	});

	test('NFT enumerable tests (no tokens)', async () => {
		const nft_supply_for_owner = await bob.viewFunction(contractName, 'nft_supply_for_owner', { account_id: bobId });
		console.log('\n\n nft_supply_for_owner', nft_supply_for_owner, '\n\n');
		expect(nft_supply_for_owner).toEqual('0');
		// messing around with index and limit
		const bobTokens = await bob.viewFunction(contractName, 'nft_tokens_for_owner', {
			account_id: bobId, from_index: '1001', limit: '1000'
		});
		console.log('\n\n bobTokens', bobTokens, '\n\n');
		expect(bobTokens.length).toEqual(0);
	});

// We need to do this documentation
	test('Alice mints nft and approves a sale for a fixed amount of NEAR', async () => {
		const token_id = tokenIds[0];
		await alice.functionCall({
			contractId: marketId,
			methodName: 'storage_deposit',
			args: {},
			gas: GAS,
			attachedDeposit: storageMarket
		});
		
		await alice.functionCall({
			contractId: contractId,
			methodName: 'nft_mint',
			args: {
				token_id,
				metadata,
				token_type: tokenTypes[0],
				perpetual_royalties: {
					'a1.testnet': 500,
					'a2.testnet': 250,
					'a3.testnet': 250,
					'a4.testnet': 250,
					'a5.testnet': 250,
					// 'a6.testnet': 250,
					// 'a7.testnet': 250,
				},
			},
			gas: GAS,
			attachedDeposit: parseNearAmount('1')
		});

		const price = parseNearAmount('1');
		let sale_conditions = [
			{
				ft_token_id: 'near',
				price 
			}
		];

		await alice.functionCall({
			contractId: contractId,
			methodName: 'nft_approve',
			args: {
				token_id,
				account_id: marketId,
				msg: JSON.stringify({ sale_conditions })
			},
			gas: GAS,
			attachedDeposit: parseNearAmount('0.01')
		});

		const sale = await alice.viewFunction(marketId, 'get_sale', {
			nft_contract_token: contractId + DELIMETER + token_id
		});
		console.log('\n\n get_sale result for nft', sale, '\n\n');
		expect(sale.conditions.near).toEqual(price);
	});

	test('token transfer locked - owner unlocks token transfer token type', async () => {
		const token_id = tokenIds[0];
		try {
			await contractAccount.functionCall({
				contractId,
				methodName: 'nft_transfer',
				args: {
					receiver_id: bobId,
					token_id
				},
				gas: GAS,
				attachedDeposit: 1
			});
			expect(false);
		} catch(e) {
			expect(true);
		}

		// unlock all token types
		await contractAccount.functionCall({
			contractId,
			methodName: 'unlock_token_types',
			args: {
				token_types: tokenTypes
			},
			gas: GAS
		});
		const tokenLocked = await contractAccount.viewFunction(contractName, 'is_token_locked', { token_id });
		expect(tokenLocked).toEqual(false);

		// should be none (we default unlocked token_type in constructor -> test-utils.js)
		const typesLocked = await contractAccount.viewFunction(contractName, 'get_token_types_locked');
		console.log(typesLocked);
		expect(typesLocked.length).toEqual(0);
	});

	test('get sales supply', async () => {
		const supply = await contractAccount.viewFunction(marketId, 'get_supply_sales', {});
		console.log('\n\n', supply, '\n\n');
		expect(parseInt(supply, 10) > 0).toEqual(true);
	});

	test('get sales & supply by owner id', async () => {
		const sales_by_owner_id = await contractAccount.viewFunction(marketId, 'get_sales_by_owner_id', {
			account_id: aliceId,
			from_index: '0',
			limit: '50'
		});
		console.log('\n\n sales_by_owner_id', sales_by_owner_id, '\n\n');
		expect(sales_by_owner_id.length).toEqual(1);

		const supply = await contractAccount.viewFunction(marketId, 'get_supply_by_owner_id', {
			account_id: aliceId,
		});
		console.log('\n\n get_supply_by_owner_id', supply, '\n\n');
		expect(parseInt(supply, 10) > 0).toEqual(true);
	});

	test('get sales & supply by nft contract id', async () => {
		const sales_by_nft_contract_id = await contractAccount.viewFunction(marketId, 'get_sales_by_nft_contract_id', {
			nft_contract_id: contractId,
			from_index: '0',
			limit: '50'
		});
		console.log('\n\n sales_by_nft_contract_id', sales_by_nft_contract_id, '\n\n');
		expect(sales_by_nft_contract_id.length > 0).toEqual(true);

		const supply = await contractAccount.viewFunction(marketId, 'get_supply_by_nft_contract_id', {
			nft_contract_id: contractId,
		});
		console.log('\n\n get_supply_by_nft_contract_id', supply, '\n\n');
		expect(parseInt(supply, 10) > 0).toEqual(true);
	});

	test('get sales & supply by nft token type', async () => {
		const sales_by_nft_token_type = await contractAccount.viewFunction(marketId, 'get_sales_by_nft_token_type', {
			token_type: tokenTypes[0],
			from_index: '0',
			limit: '50'
		});
		console.log('\n\n sales_by_nft_token_type', sales_by_nft_token_type, '\n\n');
		expect(sales_by_nft_token_type.length > 0).toEqual(true);

		const supply = await contractAccount.viewFunction(marketId, 'get_supply_by_nft_token_type', {
			token_type: tokenTypes[0],
		});
		console.log('\n\n get_supply_by_nft_token_type', supply, '\n\n');
		expect(parseInt(supply, 10) > 0).toEqual(true);
	});

	test('bob purchase nft with NEAR', async () => {
		const token_id = tokenIds[0];
		const aliceBalanceBefore = await getAccountBalance(aliceId);
		/// purchase = near deposit = sale.price -> nft_transfer -> royalties transfer near
		await bob.functionCall({
			contractId: marketId,
			methodName: 'offer',
			args: {
			  nft_contract_id: contractId,
			  token_id,
			},
			gas: GAS,
			attachedDeposit: parseNearAmount('1')
		});
		/// check owner
		const token = await contract.nft_token({ token_id });
		expect(token.owner_id).toEqual(bobId);
		// check alice balance went up by over 80% of 1 N
		const aliceBalanceAfter = await getAccountBalance(aliceId);
		expect(new BN(aliceBalanceAfter.total).sub(new BN(aliceBalanceBefore.total)).gt(new BN(parseNearAmount('0.79')))).toEqual(true);
	});

	test('contract account registers bob with market contract', async () => {
		await contractAccount.functionCall({
			contractId: marketId,
			methodName: 'storage_deposit',
			args: { account_id: bobId },
			gas: GAS,
			attachedDeposit: storageMarket
		});
		const result = await contractAccount.viewFunction(marketId, 'storage_paid', { account_id: bobId });
		expect(result).toEqual(parseNearAmount('0.01'));
	});

	test('bob withdraws storage', async () => {
		await bob.functionCall({
			contractId: marketId,
			methodName: 'storage_withdraw',
			args: {},
			gas: GAS,
			attachedDeposit: 1
		});
		const result = await contractAccount.viewFunction(marketId, 'storage_paid', { account_id: bobId });
		expect(result).toEqual('0');
	});

	test('bob approves sale with FT and NEAR (fixed prices)', async () => {
		const token_id = tokenIds[0];
		await bob.functionCall({
			contractId: marketId,
			methodName: 'storage_deposit',
			args: {},
			gas: GAS,
			attachedDeposit: storageMarket
		});
		await bob.functionCall({
			contractId: fungibleId,
			methodName: 'storage_deposit',
			args: {},
			gas: GAS,
			attachedDeposit: storageMinimum
		});
		const token = await contract.nft_token({ token_id });
		let sale_conditions = [
			{
				ft_token_id: fungibleId,
				price: parseNearAmount('25')
			},
			{
				ft_token_id: 'near',
				price: parseNearAmount('5')
			}
		];

		console.log('\n\n sale_conditions', sale_conditions, '\n\n');
		console.log('\n\n token.royalty', token.royalty, '\n\n');

		if (sale_conditions.length + token.royalty.length > 8) {
			throw new Error("Cannot have more than 8 royalties + sale collateral at the same time");
		}

		await bob.functionCall({
			contractId,
			methodName: 'nft_approve',
			args: {
				token_id,
				account_id: marketId,
				msg: JSON.stringify({ sale_conditions })
			},
			gas: GAS,
			attachedDeposit: storageMarket
		});
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + DELIMETER + token_id });
		console.log('\n\n get_sale', sale, '\n\n');
		expect(sale.conditions[fungibleId]).toEqual(parseNearAmount('25'));
	});

	test('enumerable tests', async () => {
		const total_supply = await bob.viewFunction(contractName, 'nft_total_supply', {});
		console.log('\n\n total_supply', total_supply, '\n\n');
		// could be several tests in, with many tokens minted
		const nft_supply_for_owner = await bob.viewFunction(contractName, 'nft_supply_for_owner', { account_id: bobId });
		console.log('\n\n nft_supply_for_owner', nft_supply_for_owner, '\n\n');
		expect(nft_supply_for_owner).toEqual('1');
		const tokens = await bob.viewFunction(contractName, 'nft_tokens', { from_index: '0', limit: '1000' });
		console.log('\n\n nft_tokens', tokens, '\n\n');
		// proxy for total supply with low limits, could be several tests in, with many tokens minted
		expect(tokens.length > 0).toEqual(true);
		const bobTokens = await bob.viewFunction(contractName, 'nft_tokens_for_owner', { account_id: bobId, from_index: '0', limit: '1000' });
		console.log('\n\n nft_tokens_for_owner (bob)', bobTokens, '\n\n');
		expect(bobTokens.length).toEqual(1);
	});
    
	test('bob changes price in FT to 20 N', async () => {
		const token_id = tokenIds[0];
		await bob.functionCall({
			contractId: marketId,
			methodName: 'update_price',
			args: {
			  nft_contract_id: contractId,
			  token_id,
			  ft_token_id: fungibleId,
			  price: parseNearAmount('20')
			},
			gas: GAS,
			attachedDeposit: 1
		});
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + DELIMETER + token_id });
		console.log('\n\n get_sale (updated price to 20 N)', sale, '\n\n');
		expect(sale.conditions[fungibleId]).toEqual(parseNearAmount('20'));
	});

	test('contract owner makes low bid', async () => {
		const token_id = tokenIds[0];
		/// purchase = ft_transfer_call -> market: ft_on_transfer -> nft_transfer
		await contractAccount.functionCall({
			contractId: marketId,
			methodName: 'offer',
			args: {
			  nft_contract_id: contractId,
			  token_id,
			},
			gas: GAS,
			attachedDeposit: parseNearAmount('1')
		});
		
		/// check sale should have 2 N bid for near from contract owner
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + DELIMETER + token_id });
		expect(sale.bids['near'].owner_id).toEqual(contractId);
		expect(sale.bids['near'].price).toEqual(parseNearAmount('1'));
	});

	test('alice outbids contract owner', async () => {
		const token_id = tokenIds[0];

		const contractBalanceBefore = await getAccountBalance(contractId);
		/// purchase = ft_transfer_call -> market: ft_on_transfer -> nft_transfer
		await alice.functionCall({
			contractId: marketId,
			methodName: 'offer',
			args: {
			  nft_contract_id: contractId,
			  token_id
			},
			gas: GAS,
			attachedDeposit: parseNearAmount('1.1')
		});
		
		/// check sale should have 1.1 N bid for near from alice
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + DELIMETER + token_id });
		expect(sale.bids['near'].owner_id).toEqual(aliceId);
		expect(sale.bids['near'].price).toEqual(parseNearAmount('1.1'));

		// contract owner gets back 1 N - gas > 0.9
		const contractBalanceAfter = await getAccountBalance(contractId);

		expect(new BN(contractBalanceAfter.total).sub(new BN(contractBalanceBefore.total)).gt(new BN(parseNearAmount('0.9')))).toEqual(true);
	});

	test('alice gets 100 FTs', async () => {
		await alice.functionCall({
			contractId: fungibleId,
			methodName: 'storage_deposit',
			args: {},
			gas: GAS,
			attachedDeposit: storageMinimum
		});
		let amount = parseNearAmount('100');
		await contractAccount.functionCall({
			contractId: fungibleId,
			methodName: 'ft_transfer',
			args: {
			  receiver_id: aliceId,
			  amount: parseNearAmount('100')
			},
			gas: GAS,
			attachedDeposit: 1
		});
		/// check balance
		const balance = await contractAccount.viewFunction(fungibleId, 'ft_balance_of', { account_id: aliceId });
		expect(balance).toEqual(amount);
	});

	test('contract owner bids with fts', async () => {
		const token_id = tokenIds[0];
		await contractAccount.functionCall({
			contractId: fungibleId,
			methodName: 'ft_transfer_call',
			args: {
			  receiver_id: marketId,
			  amount: parseNearAmount('10'),
			  msg: JSON.stringify({ nft_contract_id: contractId, token_id })
			},
			gas: GAS,
			attachedDeposit: 1
		});
		// marketplace contract has 10 FTs (a bid)
		const marketFTBalance = await contractAccount.viewFunction(fungibleId, 'ft_balance_of', { account_id: marketId });
		expect(marketFTBalance).toEqual(parseNearAmount('10'));
	});

	test('alice purchase NFT with FT -> alice gets NEAR back, contract owner gets FTs back', async () => {
		const token_id = tokenIds[0];
		const ownerBalanceBefore = await contractAccount.viewFunction(fungibleId, 'ft_balance_of', { account_id: contractId });
		const aliceBalanceBefore = await getAccountBalance(aliceId);
		/// purchase = ft_transfer_call -> market: ft_on_transfer -> nft_transfer
		await alice.functionCall({
			contractId: fungibleId,
			methodName: 'ft_transfer_call',
			args: {
			  receiver_id: marketId,
			  amount: parseNearAmount('20'),
			  msg: JSON.stringify({ nft_contract_id: contractId, token_id })
			},
			gas: GAS,
			attachedDeposit: 1
		});
		/// check owner
		const token = await contract.nft_token({ token_id });
		expect(token.owner_id).toEqual(aliceId);
		/// check FT balances
		const aliceBalance = await alice.viewFunction(fungibleId, 'ft_balance_of', { account_id: aliceId });
		expect(aliceBalance).toEqual(parseNearAmount('80'));
		const marketBalance = await marketAccount.viewFunction(fungibleId, 'ft_balance_of', { account_id: marketId });
		console.log('\n\n ft_balance_of fungibleId', marketBalance, '\n\n');
		// marketplace contract has NO MORE FTs (bids were paid back)
		const marketFTBalance = await contractAccount.viewFunction(fungibleId, 'ft_balance_of', { account_id: marketId });
		expect(marketFTBalance).toEqual(parseNearAmount('0'));
		/// bob gets 80% of the FTs
		const bobBalance = await bob.viewFunction(fungibleId, 'ft_balance_of', { account_id: bobId });
		expect(bobBalance).toEqual(parseNearAmount('16'));
		// alice's bid of 1.1 NEAR was returned (check N diff > than 1.1 - gas)
		const ownerBalanceAfter = await contractAccount.viewFunction(fungibleId, 'ft_balance_of', { account_id: contractId });
		const aliceBalanceAfter = await getAccountBalance(aliceId);
		expect(new BN(aliceBalanceAfter.total).sub(new BN(aliceBalanceBefore.total)).gt(new BN(parseNearAmount('1')))).toEqual(true);
		// Owner received 5% royalty in FTs on NFT purchase
		expect(new BN(ownerBalanceAfter).sub(new BN(ownerBalanceBefore)).toString()).toEqual(parseNearAmount('11'));
	});

	/// near bid

	test('bob fails to mint past hard cap for token type', async () => {
		const token_id = tokenIds[1];
		try {
			await bob.functionCall({
				contractId,
				methodName: 'nft_mint',
				args: {
				  token_id,
				  metadata,
				  token_type: tokenTypes[0]
				},
				gas: GAS,
				attachedDeposit: parseNearAmount('1')
			  });
			expect(false);
		} catch (e) {
			expect(true);
		}
		const hardCap = await bob.viewFunction(contractId, 'nft_supply_for_type', { token_type: tokenTypes[0] });
		expect(hardCap).toEqual('1');
	});

	test('bob: nft mints (different token_type) 2 new tokens, approve sale with NEAR open for bids', async () => {
		let token_id = tokenIds[1];
		await bob.functionCall({
			contractId: marketId,
			methodName: 'storage_deposit',
			args: {},
			gas: GAS,
			attachedDeposit: storageMarket
		});

		/// bob just double paid for storage (check this)
		const result = await contractAccount.viewFunction(marketId, 'storage_paid', { account_id: bobId });
		expect(result).toEqual(parseNearAmount('0.02'));

		await bob.functionCall({
			contractId,
			methodName: 'nft_mint',
			args: {
			  token_id,
			  metadata,
			  token_type: tokenTypes[1],
			},
			gas: GAS,
			attachedDeposit: parseNearAmount('1')
		});
		await bob.functionCall({
			contractId,
			methodName: 'nft_approve',
			args: {
			  token_id,
			  account_id: marketId,
			  perpetual_royalties: { bobId: 500 },
			  msg: '{"sale_conditions":[{"ft_token_id":"near"}]}'
			},
			gas: GAS,
			attachedDeposit: storageMarket
		});
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + DELIMETER + token_id });
		console.log('\n\n', sale, '\n\n');
		expect(sale.conditions["near"]).toEqual(parseNearAmount('0'));

		token_id = tokenIds[2];
		await bob.functionCall({
			contractId,
			methodName: 'nft_mint',
			args: {
			  token_id,
			  metadata: metadata2,
			  token_type: tokenTypes[2],
			},
			gas: GAS,
			attachedDeposit: parseNearAmount('1')
		});
		await bob.functionCall({
			contractId,
			methodName: 'nft_approve',
			args: {
			  token_id,
			  account_id: marketId,
			  perpetual_royalties: { bobId: 500 },
			  msg: '{"sale_conditions":[{"ft_token_id":"near"}]}'
			},
			gas: GAS,
			attachedDeposit: storageMarket
		});
		const sale2 = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + DELIMETER + token_id });
		console.log('\n\n', sale2, '\n\n');
		expect(sale2.conditions["near"]).toEqual(parseNearAmount('0'));
	});

	test('alice bid with NEAR', async () => {
		const token_id = tokenIds[1];
		await alice.functionCall({
			contractId: marketId,
			methodName: 'offer',
			args: {
			  nft_contract_id: contractId,
			  token_id,
			},
			gas: GAS,
			attachedDeposit: parseNearAmount('0.2')
		});
		const sale = await bob.viewFunction(marketId, 'get_sale', { nft_contract_token: contractId + DELIMETER + token_id });
		expect(sale.bids['near'].owner_id).toEqual(aliceId);
		expect(sale.bids['near'].price).toEqual(parseNearAmount('0.2'));
	});

	test('bob accept bid', async () => {
		const token_id = tokenIds[1];
		const bobBalanceBefore = await getAccountBalance(bobId);
		/// purchase = near deposit = sale.price -> nft_transfer -> royalties transfer near
		await bob.functionCall({
			contractId: marketId,
			methodName: 'accept_offer',
			args: {
			  nft_contract_id: contractId,
			  token_id,
			  ft_token_id: 'near'
			},
			gas: GAS
		});
		/// check owner
		const token = await contract.nft_token({ token_id });
		expect(token.owner_id).toEqual(aliceId);
		const bobBalanceAfter = await getAccountBalance(bobId);
		/// bob got close to 0.18 N (95% - gas) from this sale
		expect(new BN(bobBalanceAfter.total).sub(new BN(bobBalanceBefore.total)).gt(new BN(parseNearAmount('0.17')))).toEqual(true);
	});

	test('get_sales_by_nft_token_type', async () => {
		const tokenTypeSales = await bob.viewFunction(marketId, 'get_sales_by_nft_token_type', {
			token_type: tokenTypes[1],
			from_index: '0',
			limit: '10'
		});
		console.log('\n\n tokenTypeSales', tokenTypeSales, '\n\n');
		expect(tokenTypeSales.length).toEqual(1);
		const tokenTypeSales2 = await bob.viewFunction(marketId, 'get_sales_by_nft_token_type', {
			token_type: tokenTypes[2],
			from_index: '0',
			limit: new BN('10').toString()
		});
		console.log('\n\n tokenTypeSales', tokenTypeSales2, '\n\n');
		expect(tokenTypeSales2.length).toEqual(1);
	});

	/// for testing frontend

	test('alice lingering sale in marketplace', async () => {
		const token_id = tokenIds[1];
		await alice.functionCall({
			contractId: marketId,
			methodName: 'storage_deposit',
			args: {},
			gas: GAS,
			attachedDeposit: storageMarket
		});
		await alice.functionCall({
			contractId,
			methodName: 'nft_approve',
			args: {
			  token_id,
			  account_id: marketId,
			  perpetual_royalties: { [aliceId]: 500 },
			  msg: '{"sale_conditions":[{"ft_token_id":"near"}]}'
			},
			gas: GAS,
			attachedDeposit: storageMarket
		});
	});

});
'''
'''--- scripts/app1.js ---
require("dotenv").config();

// Load Near Javascript API components
const near = require("near-api-js");
const fs = require("fs");

// Configure the directory where NEAR credentials are going to be stored
const credentialsPath = "/home/hunter/.near-credentials";

// Configure the keyStore to be used with the NEAR Javascript API
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore = new UnencryptedFileSystemKeyStore(credentialsPath);

// Setup default client options
const options = {
  networkId:   process.env.NEAR_NETWORK,
  nodeUrl:     process.env.NEAR_NODE_URL,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   process.env.NEAR_ACCOUNT, 
  keyStore:    keyStore
}

async function main() {
  let keyPair;

  // Configure the client with options and our local key store
  const client = await near.connect(options);

  // Configure the key pair file location
  const keyRootPath = client.connection.signer.keyStore.keyDir;
  const keyFilePath = `${keyRootPath}/${options.networkId}/${options.accountId}.json`;

  // Check if the key pair exists, and create a new one if it does not
  if (!fs.existsSync(keyFilePath)) {
    console.log("Generating a new key pair")
    keyPair = near.KeyPair.fromRandom("ed25519");
  } else {
    let content = JSON.parse(fs.readFileSync(keyFilePath).toString());
    keyPair = near.KeyPair.fromString(content.private_key);

    console.log(`Key pair for account ${options.accountId} already exists, skipping creation`);
  }

  // Create a key pair in credentials directory
  await client.connection.signer.keyStore.setKey(options.networkId, options.accountId, keyPair);

  // Determine if account already exists
  try {
    await client.account(options.accountId);
    return console.log(`Sorry, account '${options.accountId}' already exists.`);
  }
  catch (e) {
    if (!e.message.includes("does not exist while viewing")) {
      throw e;
    }
  }

  // Generate a public key for account creation step
  const publicKey = keyPair.getPublicKey()

  // Create the account
  try {
    const response = await client.createAccount(options.accountId, publicKey);
    console.log(`Account ${response.accountId} for network "${options.networkId}" was created.`);
    console.log("----------------------------------------------------------------");
    console.log("OPEN LINK BELOW to see account in NEAR Explorer!");
    console.log(`${options.explorerUrl}/accounts/${response.accountId}`);
    console.log("----------------------------------------------------------------");
  }
  catch(error) {
    console.log("ERROR:", error);
  }
}

main();
'''
'''--- scripts/app2.js ---
// Load environment variables
require("dotenv").config();
const path = require("path");

// Load NEAR Javascript API components
const near = require("near-api-js");
const { transactions } = require("near-api-js");
 const { 
		Contract, KeyPair, Account,
		utils: { format: { parseNearAmount }},
		transactions: { deployContract, functionCall },
	} = near;

const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore = new UnencryptedFileSystemKeyStore(credentialsPath)

const now = Date.now();

// Setup default client options
const options = {
  networkId:   `testnet`,
  nodeUrl:     `https://rpc.testnet.near.org`,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   "dev-1625057166863-88051363268524",
  keyStore: keyStore
}

async function main() {
  // Configure the client with options and our local key store
    const client = await near.connect(options);
  
  //Minter account
    const account = await client.account(options.accountId);

  //Buyer Account
    const account_2 = await client.account("dev-1625072038241-90221386101668");
  
  //Where NFT is deployed
    const contract_account = await client.account("dev-1623229186642-77647971299977");

    const account_3 = await client.account("dev-1625071653611-35981054215498");

    // A simple example for tokentypes an tokenID generator
    //   const tokenTypes = [
    // 	// one unique type
    // 	`test:QmNdF6fEHci2gjQTDne1vKKk7pn2bvBEQjU75ThtySCSSv1L1`,
    // 	`test:QmNdF6fEHci2gjQTDne1vKKk7pn2bvBEQjU75ThtySCSSvl1`
    //     ];
    // 	const tokenIds = tokenTypes.map((type, i) => `${type}:${i}`);

    let contractId = "dev-1626006665148-21315355628435";
    let marketContractId = "market."+contractId;

    // const token_id = "test:QmehoXtWCjjCazuC9NGuhn6RmuWWuvd1AEc6tFULxzrZNU:107"
    const token_id = "test:"+now.toString();
    
    console.log("Starting Minting Album and Songs")
    let result = await account.functionCall(
        contractId,
        'nft_mint',
        {
            token_id:token_id,
            metadata:{},
            token_type:"test",
            perpetual_royalties:{
            },
            songslist:['QmaTBCqWQyywTj3CBDkLfMsLcX7XCgxED3fvhV4BgfEQ7w1','QmP1A9fF4jWB2LgwzYiweMbaeKsYtdU1dSkQAg2sgEyve2']
        },
        200000000000000,
        parseNearAmount('1')
    );
    console.log("Finished Minting Album and Songs")
    
    console.log("Starting Approving the Market for Sale of the album NFT for fixed amount of NEAR" )
      
    result = await account.functionCall(
        	marketContractId,
        	'storage_deposit',
        	{},
        	200000000000000,
        	parseNearAmount('5')
    );
    
    result = await account_2.functionCall(
        marketContractId,
        'storage_deposit',
        {},
        200000000000000,
        parseNearAmount('5')
    );
    
    const price = parseNearAmount('1');          
    let sale_conditions = [
        {
            ft_token_id: 'near',
            price 
        }
    ];

    result = await account.functionCall(
    			contractId,
    			'nft_approve',
    			{
    				token_id: token_id,
    				account_id: marketContractId,
    				msg: JSON.stringify({ sale_conditions })
    			},
    			200000000000000,
    			parseNearAmount('0.01')
    	);
        
// 	// console.log(result)
    console.log("Stopped Approving")

    console.log("Starting Unlocking")
    
    // const tokenLocked = await contract_account.viewFunction("dev-1623229186642-77647971299977", 'is_token_locked', { token_id });
    // console.log(tokenLocked);

    result = await contract_account.functionCall(
        contractId,
        'unlock_token_types',
        {
            token_types: [`test`, token_id]
        },
        200000000000000
    );

    // const tokenLocked1 = await contract_account.viewFunction("dev-1623229186642-77647971299977", 'is_token_locked', { token_id });
    // console.log(tokenLocked1);
    
    console.log("Stopped Unlocking")
    
    console.log("Started offer")
    result = await account_2.functionCall(
        marketContractId,
        "offer_album",
        {
        nft_contract_id: contractId,
        token_id: token_id
        },
        300000000000000,
        parseNearAmount('1')
    )
    console.log("Finished offer");
   
    
    let one_of_the_song_tokens = token_id+":"+"QmaTBCqWQyywTj3CBDkLfMsLcX7XCgxED3fvhV4BgfEQ7w1"; 
    // const tokens = await account.viewFunction(contractId, 'nft_tokens_for_owner', {
	// 		account_id:account_2.accountId,
	// 		from_index: '0',
	// 		limit: '100'
	// });
    // console.log(tokens);
    
    console.log("Approving after buying")
    result = await account_2.functionCall(
        contractId,
        'nft_approve',
        {
            token_id: one_of_the_song_tokens,
            account_id: marketContractId,
            msg: JSON.stringify({ sale_conditions })
        },
        200000000000000,
        parseNearAmount('0.01')
    );
    console.log("Finished Approving after buying")
    
    console.log("Started offer for secondary market song")
    result = await account_3.functionCall(
        marketContractId,
        "offer",
        {
        nft_contract_id: contractId,
        token_id: one_of_the_song_tokens
        },
        300000000000000,
        parseNearAmount('1')
    )
    console.log("Finished offer for secondary market song");
    
    const token = await account_3.functionCall(
        contractId,
        "nft_token",
        { token_id: token_id }
        
    )
    // Contains the txn hash where you can find the owner_id
    console.log(token)
    
};

main();

'''
'''--- scripts/app4.js ---
// Load environment variables
require("dotenv").config();
const path = require("path");
const crypto = require('crypto');
const bs58 = require('bs58')

// const IPFS = require('ipfs-core')
// const now = Date.now();

// Load NEAR Javascript API components
const near = require("near-api-js");
const { transactions } = require("near-api-js");
const { contract, contractMethods } = require("../utils/near-utils");
const { error } = require("console");
 const { 
		Contract, KeyPair, Account,
		utils: { format: { parseNearAmount }},
		transactions: { deployContract, functionCall },
	} = near;

var arr = [];

while(arr.length < 5){
    // var r = Math.floor(Math.random() * 100) + 1;
    var current_date = (new Date()).valueOf().toString();
    var random = Math.random().toString();
    let r = crypto.createHash('sha1').update(current_date + random).digest('hex');

    if(arr.indexOf(r) === -1) arr.push(r);
}

const fs = require('fs');
const contractId = fs.readFileSync('./../neardev/dev-account').toString()

const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials/testnet";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore1 = new UnencryptedFileSystemKeyStore(credentialsPath)

const now = Date.now();

// Setup default client options
const options = {
  networkId:   `testnet`,
  nodeUrl:     `https://rpc.testnet.near.org`,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   "dev-1625057166863-88051363268524",
  keyStore: keyStore1
}

// let contractId = "dev-1628448071974-77438826237855";

let marketContractId = "market."+contractId;

let albumhash = "fu012d11211";

let songslisthash = ['35e3de8bf884a57cb24a3c4ab188da2a','281b3d4d3b4ca68c987bf897a83a66a0'];

//Album Hash : f8d7bd28b526864cf358256ca7b041c6
// No of copies : 2
// Song 1 hash: 35e3de8bf884a57cb24a3c4ab188da2a
// Song 2 hash : 281b3d4d3b4ca68c987bf897a83a66a0

async function create_album_token_type(owner_account, client){

    console.log("Inside the function")
    const supply_cap_by_type = {
        // [albumhash]: "2",
        [albumhash]:"1",
    };

    try {
        let result = await owner_account.functionCall(
            contractId,
            'add_token_types',
            { supply_cap_by_type },
            200000000000000
        )
        
    
    } catch (error) {

        const response = await client.connection.provider.txStatus(
            bs58.decode(error.transaction_outcome.id.toString('utf-8')),
            "rahulsoshte.testnet"
        );
        
        console.log(response.receipts_outcome[0].outcome.logs);
        const obj = JSON.parse(response.receipts_outcome[0].outcome.logs[0]);
        console.log(obj);
    }
    
    console.log("Ending the function")

}

async function mint_album_copy(minteraccount, copy_no, client) {
    const token_id = albumhash+":"+copy_no;
    
    try {
        let result = await minteraccount.functionCall(
            contractId,
            'nft_mint',
            {
                token_id:token_id,
                metadata:{},
                token_type:albumhash,
                perpetual_royalties:{
                },
                songslist:songslisthash,
            },
            300000000000000,
            parseNearAmount('1')
        );
        console.log(result);

    } catch(error){
        
        const response = await client.connection.provider.txStatus(
            bs58.decode(error.transaction_outcome.id.toString('utf-8')),
            minteraccount.accountId
        );
        
        const obj = JSON.parse(response.receipts_outcome[0].outcome.logs[0]);
        console.log(obj);
        

    }
}

async function unlock_album_token_type(owner_account){
        
    result = await owner_account.functionCall(
        contractId,
        'unlock_token_types',
        {
            token_types: [albumhash]
        },
        200000000000000
    );

}

async function unlock_album_copy_token_type(owner_account, album){
        
    result = await owner_account.functionCall(
        contractId,
        'unlock_token_types',
        {
            token_types: [album]
        },
        200000000000000
    );

}

async function approving_album_for_sale(minter, copy_no, price_arg, client){
    const price = parseNearAmount(price_arg);
    const token_id = albumhash+":"+copy_no;

    try {
    result = await minter.functionCall(
    	contractId,
    	'nft_approve',
    	{
    	    token_id: token_id,
    	    account_id: marketContractId,
    	    msg: JSON.stringify({ sale_conditions })
    	},
    	200000000000000,
    	parseNearAmount('0.01')
    );

    } catch(error) {
        
        const response = await client.connection.provider.txStatus(
            bs58.decode(error.transaction_outcome.id.toString('utf-8')),
            minter.accountId
        );
        
        const obj = JSON.parse(response.receipts_outcome[0].outcome.logs[0]);
        console.log(obj);
        
    }

}

async function buy_album_nft(buyer, copy_no, price,client){

    const token_id = albumhash+":"+copy_no;
    
    try {
        result = await buyer.functionCall(
            marketContractId,
            "offer_album",
            {
            nft_contract_id: contractId,
            token_id: token_id
            },
            300000000000000,
            parseNearAmount(price)
        )
    } catch(error) {

        const response = await client.connection.provider.txStatus(
            bs58.decode(error.transaction_outcome.id.toString('utf-8')),
            buyer.accountId
        );
        
        const obj = JSON.parse(response.receipts_outcome[0].outcome.logs[0]);
        console.log(obj);
    }

}

async function put_song_up_for_selling(account_which_bought_the_album, songtokenid, price_arg ){
    
    const price = parseNearAmount(price_arg);

    let sale_conditions = [
        {
            ft_token_id: 'near',
            price
        }
    ];

    let result = await account_which_bought_the_album.functionCall(
        marketContractId,
        'storage_deposit',
        {},
        200000000000000,
        parseNearAmount('3')
    );
    
    result = await account_which_bought_the_album.functionCall(
        contractId,
        'nft_approve',
        {
            token_id: songtokenid,
            account_id: marketContractId,
            msg: JSON.stringify({ sale_conditions })
        },
        200000000000000,
        parseNearAmount('0.01')
    );

}

async function buy_song_nft(anotheraccount, price_arg, songtokenid, client){
    try {
    result = await anotheraccount.functionCall(
        marketContractId,
        "offer",
        {
        nft_contract_id: contractId,
        token_id: songtokenid
        },
        300000000000000,
        parseNearAmount(price_arg)
    )} catch(error) {
        const response = await client.connection.provider.txStatus(
            bs58.decode(error.transaction_outcome.id.toString('utf-8')),
            anotheraccount.accountId
        );
        
        const obj = JSON.parse(response.receipts_outcome[0].outcome.logs[0]);
        console.log(obj);
    }
}

async function main() {
    // const ipfs = await IPFS.create()
    // const { cid } = await ipfs.add(now.toString())
    // albumhash = cid.toString();

    const client = await near.connect(options);
    const account = await client.account(options.accountId);
    const account_2 = await client.account("dev-1625072038241-90221386101668");
    const contract_account = await client.account(contractId);
    const owner_account = await client.account("rahulsoshte.testnet");
    const account_3 = await client.account("dev-1625071653611-35981054215498");
    const account_4 = await client.account("dev-1625074608971-76452383946912");

    console.log("Creating the album token type");
    // await create_album_token_type(owner_account, client);
    console.log("Finished creating the album token type");

    console.log("Starting Minting Album and Songs")
    // await mint_album_copy(account_2,"1",client);
    // await mint_album_copy(account_2,"2",client);
    console.log("Finished Minting Album and Songs")

    console.log("Starting Approving the Market for Sale of the album NFT for fixed amount of NEAR" )
    // await approving_album_for_sale(account_2, "1", "3", client);
    console.log("Stopped Approving")

    console.log("started Unlock token types");
    // await unlock_album_token_type(owner_account);
    console.log("Finished Unlock token types");
                       
    console.log("Buying the album nft") 
    // await buy_album_nft(account_3, "1", "3",client);
    console.log("Finished buying the album nft")         
     
    console.log("Putting up the 1st song 35e3de8bf884a57cb24a3c4ab188da2a of the 1st album copy f8d7bd28b526864cf358256ca7b041c6:1 for selling")
    // let songtokenid = albumhash+":1:35e3de8bf884a57cb24a3c4ab188da2a";
    // await put_song_up_for_selling(account_3, albumhash+":1", "1" );
    console.log("Finished Putting up the 1st song 35e3de8bf884a57cb24a3c4ab188da2a of the 1st album copy f8d7bd28b526864cf358256ca7b041c6:1 for selling")
    
    console.log("Another party buying this song f8d7bd28b526864cf358256ca7b041c6:1:35e3de8bf884a57cb24a3c4ab188da2a listed by account_3")
    // await unlock_album_copy_token_type(owner_account, albumhash+":1" )
    await buy_song_nft(account_4, "1", albumhash+":1", client);
    console.log("Finished Another party buying this song listed by account_3")

    // console.log("buyAnother party buying this song f8d7bd28b526864cf358256ca7b041c6:1:35e3de8bf884a57cb24a3c4ab188da2a listed by account_3")
    // await unlock_album_copy_token_type(owner_account, albumhash+":1" )
    // await buy_song_nft(account_4, "1", songtokenid);
    // console.log("Finished Another party buying this song listed by account_3")

    
	// const token = await account_3.functionCall(
    //     contractId,
    //     "nft_token",
    //     { token_id: "QmRwFRQMeTN3cjCC9topw9dnRcyZY1gHduCDdzH6YhAsCL:2"},
		
    // )

	// const jsjd = Buffer.from(token?.status?.SuccessValue, 'base64').toString('utf-8');
	
	// const obj = JSON.parse(jsjd);

	// console.log(obj.owner_id);

	// const contract_1 = new Contract(contract_account, contractId, contractMethods);
	// const contract_1 = new Contract(contract_account, contractId, {
	// viewMethods: ["get_token_ids", "nft_token", "get_sale"],});

	// const token = await contract_1.nft_token({ token_id:"QmRwFRQMeTN3cjCC9topw9dnRcyZY1gHduCDdzH6YhAsCL:1" });
    // console.log(token.owner_id);
	
	    // Contains the txn hash where you can find the owner_id

	// {
	// 	// name of contract you're connecting to
	// 	viewMethods: ["getMessages"], // view methods do not change state but usually return a value
	// 	changeMethods: ["addMessage"], // change methods modify state
	// 	sender: account, // account object to initialize and sign transactions.
	//   }

    // const token = await account_3.functionCall(
    //     contractId,
    //     "nft_token",
    //     { token_id: albumhash+":"+"1:"+"35e3de8bf884a57cb24a3c4ab188da2a" }
        
    // )
    // // Contains the txn hash where you can find the owner_id
    // console.log(token)
    
};

main();

'''
'''--- scripts/app5.js ---
// Load environment variables
require("dotenv").config();
const path = require("path");
const crypto = require('crypto');
const bs58 = require('bs58')
const near = require("near-api-js");
const { transactions } = require("near-api-js");
const { contract, contractMethods } = require("../utils/near-utils");
const { error } = require("console");
const { 
		Contract, KeyPair, Account,
		utils: { format: { parseNearAmount }},
		transactions: { deployContract, functionCall },
} = near;

const fs = require('fs');
const contractId = fs.readFileSync('./../neardev/dev-account').toString()
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore1 = new UnencryptedFileSystemKeyStore(credentialsPath)

const now = Date.now();

// Setup default client options
const options = {
  networkId:   `testnet`,
  nodeUrl:     `https://archival-rpc.testnet.near.org`,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   "dev-1629347195077-55896395664466",
  keyStore: keyStore1
}

// let contractId = "dev-1628448071974-77438826237855";

let marketContractId = "market."+contractId;

let albumhash = "fu012d11211";

let songslisthash = ['35e3de8bf884a57cb24a3c4ab188da2a','281b3d4d3b4ca68c987bf897a83a66a0'];

//Album Hash : f8d7bd28b526864cf358256ca7b041c6
// No of copies : 2
// Song 1 hash: 35e3de8bf884a57cb24a3c4ab188da2a
// Song 2 hash : 281b3d4d3b4ca68c987bf897a83a66a0

async function create_album_token_type_approve_for_sale(owner_account, client){

    console.log("Inside the function")
    let accoff = owner_account.accountId;

    try {

        let result = await owner_account.functionCall(
            "nft." + "dev-1633963337441-72420501486968",
            'add_token_types',
            { album_hash: "f8d7bd28b526864cf358256ca7b041c61",
            cover_songslist:['f8d7bd28b526864cf358256ca71','35e3de8bf884a57cb24a3c4ab188da2a1', '281b3d4d3b4ca68c987bf897a83a66a01'],
            number_of_album_copies: 10,
            price: parseNearAmount('1'),   
        },
            200000000000000,
            parseNearAmount('1'),
        )
        
    
    } catch (error) {

        const response = await client.connection.provider.txStatus(
            bs58.decode(error.transaction_outcome.id.toString('utf-8')),
            owner_account.accountId
        );
        
        console.log(response.receipts_outcome[0].outcome.logs);
        const obj = JSON.parse(response.receipts_outcome[0].outcome.logs[0]);
        console.log(obj);
        // console.log(error)
    }
    
    console.log("Ending the function")

}

async function buy_album_bundle(buyer, copy_no, price,client){

    const token_id = "f8d7bd28b526864cf358256ca7b041c6"+":"+copy_no;
    console.log(price);

    try {
        await buyer.functionCall(
            "market.dev-1633963337441-72420501486968",
            "offer_album",
            {
            nft_contract_id: "nft.dev-1633963337441-72420501486968", 
            albumipfs_hash_copy: "f8d7bd28b526864cf358256ca7b041c61:1",
            },
            300000000000000,
            parseNearAmount(price),
        )

    } catch(error) {

        const response = await client.connection.provider.txStatus(
            bs58.decode(error.transaction_outcome.id.toString('utf-8')),
            buyer.accountId
        );
        
        const obj = JSON.parse(response.receipts_outcome[0].outcome.logs[0]);
        console.log(obj);

    }

}

async function approve_song_for_sale(account_which_bought_the_album, songtokenid, price_arg ){
    
    const price = parseNearAmount(price_arg);
    
    result = await account_which_bought_the_album.functionCall(
        "nft.dev-1633963337441-72420501486968",
        'nft_approve',
        {
            token_id: songtokenid,
            account_id: "market.dev-1633963337441-72420501486968",
            price: price,
        },
        300000000000000,
        parseNearAmount('0.01')
    );

}

async function buy_song_nft(anotheraccount, price_arg, songtokenid, client){
    try {
    result = await anotheraccount.functionCall(
        "market.dev-1633963337441-72420501486968",
        "offer",
        {
        nft_contract_id: "nft.dev-1633963337441-72420501486968",
        receiver_id: anotheraccount.accountId,
        song_token_id: songtokenid
        },
        300000000000000,
        parseNearAmount(price_arg)

    )} catch(error) {
        
        const response = await client.connection.provider.txStatus(
            bs58.decode(error.transaction_outcome.id.toString('utf-8')),
            anotheraccount.accountId
        );
        
        const obj = JSON.parse(response.receipts_outcome[0].outcome.logs[0]);
        console.log(obj);

    }
}

// TODO: Make sure all the test pass, I think we must believe in Rust, than in ourselves. I dont think Rust 
// will allow us to have race conditions
// https://www.near-sdk.io/testing/simulation-tests#helpful-snippets

async function main() {
    // const ipfs = await IPFS.create()
    // const { cid } = await ipfs.add(now.toString())
    // albumhash = cid.toString();
    const client = await near.connect(options);
    const account = await client.account(options.accountId);
    const account_2 = await client.account("dev-1629380376321-33090015362981");
    // const contract_account = await client.account(contractId);
    // const owner_account = await client.account("rahulsoshte.testnet");
    const account_3 = await client.account("dev-1629388705488-74235831867416");
    const account_4 = await client.account("dev-1629705968328-38910598243699");
    const account_5 = await client.account("dev-1629386507988-35890115858726")
    // Add Album Data and Upload for Sale
    // await create_album_token_type_approve_for_sale(account, client);

    // Offer for the price
    // await buy_album_bundle(account_2, "2", "1", client);
    
    // await buy_album_bundle(account_2, "2", "1", client);
    // await buy_album_bundle(account_2, "2", "1", client);

    // Approve a song on the marketplace

    // await approve_song_for_sale(account_2, "f8d7bd28b526864cf358256ca7b041c61:1:35e3de8bf884a57cb24a3c4ab188da2a1","1",marketContractId);
    // await approve_song_for_sale(account_2, "f8d7bd28b526864cf358256ca7b041c61:1:281b3d4d3b4ca68c987bf897a83a66a01","1",marketContractId);

    // // Buy Song from the market
    // let songtokenid_1 = "f8d7bd28b526864cf358256ca7b041c61:1:35e3de8bf884a57cb24a3c4ab188da2a1";
    // let songtokenid = "f8d7bd28b526864cf358256ca7b041c61:1:281b3d4d3b4ca68c987bf897a83a66a01";
    //Duplic
    // await buy_song_nft(account_3, "1", songtokenid_1, client); // This worked
    // buy_song_nft(account_4, "1", songtokenid_1, client); // This worked
    // buy_song_nft(account_5, "1", songtokenid_1, client); // These all didnt work at all 
    // buy_song_nft(account_4, "1", songtokenid_1, client); // These all didnt work at all 
    // await buy_song_nft(account_4, "0.1", songtokenid, client); // These all didnt work at all

    const token = await account_3.functionCall(
        "nft.dev-1633963337441-72420501486968",
        "nft_token",
        { token_id: "f8d7bd28b526864cf358256ca7b041c61:1:35e3de8bf884a57cb24a3c4ab188da2a1"},	
    );

    // const token = await account_3.functionCall(
    //     "market."+ contractId,
    //     "get_song_sale",
    //     { nft_contract_id: "nft." + contractId, song_token_id: "QmbvXWy7WE3aFabf1TStLGPzrM8qh9FsGSQWakefLvCQvM:1:QmXFQGq94BAN1KpyHj7bGk5qdWv3PW1PRDeaNvqGWnzH93"},	
    // );

};

main();

'''
'''--- scripts/config.js ---
const contractName = 'dev-1623140301605-87509875380088';

module.exports = function getConfig() {
	let config = {
		networkId: "testnet",
		nodeUrl: "https://rpc.testnet.near.org",
		// walletUrl: 'http://localhost:1234',
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		contractName,
	};

	if (process.env.REACT_APP_ENV !== undefined) {
		config = {
			explorerUrl: "https://explorer.testnet.near.org",
			...config,
			GAS: "200000000000000",
			DEFAULT_NEW_ACCOUNT_AMOUNT: "5",
			DEFAULT_NEW_CONTRACT_AMOUNT: "5",
			GUESTS_ACCOUNT_SECRET:
        "7UVfzoKZL4WZGF98C3Ue7tmmA6QamHCiB1Wd5pkxVPAc7j6jf3HXz5Y9cR93Y68BfGDtMLQ9Q29Njw5ZtzGhPxv",
			contractMethods: {
				changeMethods: [
					"new",
					"nft_mint",
					"add_token_types",
					"unlock_token_types",
					"storage_deposit",
					"nft_approve",
				],
				viewMethods: ["get_token_ids", "nft_token", "get_sale"],
			},
			marketDeposit: "100000000000000000000000",
			marketId: "market." + contractName,
		};
	}

	if (process.env.REACT_APP_ENV === "prod") {
		config = {
			...config,
			networkId: "mainnet",
			nodeUrl: "https://rpc.mainnet.near.org",
			walletUrl: "https://wallet.near.org",
			helperUrl: "https://helper.mainnet.near.org",
			contractName: "near",
		};
	}

	return config;
};

'''
'''--- scripts/execute.js ---
// Load environment variables
require("dotenv").config();
const path = require("path");
// Load NEAR Javascript API components
const near = require("near-api-js");
 const { 
		Contract, KeyPair, Account,
		utils: { format: { parseNearAmount }},
		transactions: { deployContract, functionCall },
	} = near;
const homedir = require("os").homedir();

const CREDENTIALS_DIR = ".near-credentials";
// Directory where NEAR credentials are going to be stored
// const credentialsPath = "";
const credentialsPath = path.join(homedir, CREDENTIALS_DIR);
// Configure the keyStore to be used with the NEAR Javascript API
const UnencryptedFileSystemKeyStore = near.keyStores.UnencryptedFileSystemKeyStore;
const keyStore = new UnencryptedFileSystemKeyStore(credentialsPath)

// Setup default client options
const options = {
  networkId:   `testnet`,
  nodeUrl:     `https://rpc.testnet.near.org`,
  walletUrl:   `https://wallet.${process.env.NEAR_NETWORK}.near.org`,
  helperUrl:   `https://helper.${process.env.NEAR_NETWORK}.near.org`,
  explorerUrl: `https://explorer.${process.env.NEAR_NETWORK}.near.org`,
  accountId:   "rahulsoshte.testnet",
  keyStore: keyStore
}

async function main() {
  // Configure the client with options and our local key store
  const client = await near.connect(options);
  const account = await client.account(options.accountId);
  
//   // We'are using the same contract name, feel free to create a different one.
//   const contractName = options.accountId;

//   // Construct a new contract object, we'll be using it to perform calls
//   const contract = new near.Contract(account, contractName, {
//     viewMethods: ["get_token_owner"],   // our read function
//     changeMethods: ["nft_approve", "new"], // our write function
//     sender: options.accountId,   // account used to sign contract call transactions
//   });

  // const value = "ipfs://io3";
  // // await contract.new({owner_id: "dev-1622649845327-24859001153459"})
  // // const don1 = await contract.mint_token({ token_id: value, owner_id:"rahulsoshte.testnet" })
  // // const don = await contract.get_token_owner({token_id: "ipfs://io1"})
  // // console.log(don1.transaction);
  // result = await account.functionCall(
  //   options.accountId,
  //   "mint_token",
  //   { token_id:value, owner_id: "rahulsoshte.testnet"}
  // );
  // console.log(result);

  			// await alice.functionCall({
    		// 	contractId: marketId,
    		// 	methodName: 'storage_deposit',
    		// 	args: {},
    		// 	gas: GAS,
    		// 	attachedDeposit: 10000000000000000000000
    		// });

    		// await alice.functionCall({
    		// 	contractId: contractId,
    		// 	methodName: 'nft_mint',
    		// 	args: {
    		// 		token_id,
    		// 		metadata,
    		// 		token_type: tokenTypes[0],
    		// 		perpetual_royalties: {
    		// 			'a1.testnet': 500,
    		// 			'a2.testnet': 250,
    		// 			'a3.testnet': 250,
    		// 			'a4.testnet': 250,
    		// 			'a5.testnet': 250,
    		// 			// 'a6.testnet': 250,
    		// 			// 'a7.testnet': 250,
    		// 		},
    		// 	},
    		// 	gas: GAS,
    		// 	attachedDeposit: parseNearAmount('1')
    		// });
    
    		const price = parseNearAmount('1');
    		
			let sale_conditions = [
    			{
    				ft_token_id: 'near',
    				price 
    			}
    		];
			
		// const token_id = "";
		
			console.log(JSON.stringify({
				sale_conditions: [
					{ ft_token_id: "near", price: parseNearAmount('1')}
				]
			}))
	// 
	const tokenTypes = [
	// one unique type
	`test:QmNdF6fEHci2gjQTDne1vKKk7pn2bvBEQjU75ThtySCSSv1L1`,
	`test:QmNdF6fEHci2gjQTDne1vKKk7pn2bvBEQjU75ThtySCSSvl1`
	];

	const tokenIds = tokenTypes.map((type, i) => `${type}:${i}`);
    console.log(tokenIds)

	const token_id = tokenIds[0];

	
	// console.log(typeof token_id)

	// let result = await account.functionCall({
    // 			contractId: "dev-1622649845327-24859001153459",
    // 			methodName: 'nft_approve',
    // 			args: {
    // 				token_id: "test:QmNdF6fEHci2gjQTDne1vKKk7pn2bvBEQjU75ThtySCSSv1:0",
    // 				account_id: "market.dev-1622649845327-24859001153459",
    // 				msg: JSON.stringify({ sale_conditions })
    // 			},
    // 			gas: 200000000000000,
    // 			attachedDeposit: parseNearAmount('0.01')
    // 	});

	// 	console.log(result);

	// await A.functionCall({
	// 	contractId: marketId,
	// 	methodName: 'storage_deposit',
	// 	args: {},
	// 	gas:200000000000000,
	// 	attachedDeposit: parseNearAmount('0.01')
	// });

	let result = await account.functionCall({
		contractId: "dev-1622649845327-24859001153459",
		methodName: 'nft_mint',
		args: {
			token_id: token_id.toString("binary"),
			metadata: {"name":"Test"},
			token_type: tokenTypes[0],
			perpetual_royalties: {
				'a1.testnet': 500,
				'a2.testnet': 250,
				'a3.testnet': 250,
				'a4.testnet': 250,
				'a5.testnet': 250,
				// 'a6.testnet': 250,
				// 'a7.testnet': 250,
			},
		},
		gas:200000000000000,
		attachedDeposit: parseNearAmount('1')
	});

	console.log(result)

};

main();
'''
'''--- scripts/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("./config");
const { nodeUrl, networkId, contractName, contractMethods } = getConfig(true);
const {
	keyStores: { InMemoryKeyStore },
	Near,
	Account,
	Contract,
	KeyPair,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;

console.log(
	"Loading Credentials:\n",
	`${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
);
const credentials = JSON.parse(
	fs.readFileSync(
		`${process.env.HOME}/.near-credentials/${networkId}/${contractName}.json`
	)
);
const keyStore = new InMemoryKeyStore();
keyStore.setKey(
	networkId,
	contractName,
	KeyPair.fromString(credentials.private_key)
);
const near = new Near({
	networkId,
	nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
contractAccount.addAccessKey = (publicKey) =>
	contractAccount.addKey(
		publicKey,
		contractName,
		contractMethods.changeMethods,
		parseNearAmount("0.1")
	);
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
	near,
	keyStore,
	connection,
	contract,
	contractName,
	contractAccount,
	contractMethods,
};

'''
'''--- scripts/secondary.js ---

'''
'''--- scripts/snippet.js ---
const token_id = "test:QmehoXtWCjjCazuC9NGuhn6RmuWWuvd1AEc6tFULxzrZNU:24"

const price = parseNearAmount('1');          
let sale_conditions = [
    {
        ft_token_id: 'near',
        price 
    }
];

result = await account.signAndSendTransaction(
    "dev-1623229186642-77647971299977",
    [
      transactions.functionCall(
        'nft_mint',
      {
          token_id:token_id,
          metadata:{},
          token_type:"test",
          perpetual_royalties:{
              'a1.testnet': 500,
              'a2.testnet': 250,
              'a3.testnet': 250,
              'a4.testnet': 250,
              'a5.testnet': 250,
              // 'a6.testnet': 250,
              // 'a7.testnet': 250,
          },
      },
      50000000000000,
      parseNearAmount('1')
      ),
      transactions.functionCall(
        'nft_approve',
                        {
                            token_id: token_id,
                            account_id: "market.dev-1623229186642-77647971299977",
                            msg: JSON.stringify({ sale_conditions })
                        },
                        50000000000000,
                        parseNearAmount('0.01')
      ),
    ],
  );

  console.log(result)

// console.log("Finished Adding token types")
    // console.log("Added Token Types Transaction " + result)

    // result = await account.signAndSendTransaction(
    //   "dev-1625743122506-94648200703093",
    //   [
    //     transactions.functionCall(
    //       'nft_mint',
    //     {
    //         token_id:token_id,
    //         metadata:{},
    //         token_type:"test",
    //         perpetual_royalties:{
    //         },
    //         songslist:['QmehoXtWCjjCazuC9NGuhn6RmuWWuvd1AEc6tFULxzrZNU','QmehoXtWCjjCazuC9NGuhn6RmuWWuvd1AEc6tFULxzrZNU','QmehoXtWCjjCazuC9NGuhn6RmuWWuvd1AEc6tFULxzrZNU']
    //     },
    //     100000000000000,
    //     parseNearAmount('1')
    //     ),
    //     transactions.functionCall(
    //       'nft_approve',
    //           			{
    //           				token_id: token_id,
    //           				account_id: "market.dev-1625743122506-94648200703093",
    //           				msg: JSON.stringify({ sale_conditions })
    //           			},
    //           			100000000000000,
    //           			parseNearAmount('0.01')
    //     ),
    //   ],
    // );

    
     // const token = await account.functionCall(
    //     "dev-1625057166863-88051363268524",
    //     "nft_token",
    //     { token_id: "test:QmehoXtWCjjCazuC9NGuhn6RmuWWuvd1AEc6tFULxzrZNU:104" }
    //   )
    // // Contains the txn hash where you can find the owner_id
    // console.log(token)

    // const tokens = await account.viewFunction(contractId, 'nft_tokens_for_owner', {
		// 	account_id:"dev-1625057166863-88051363268524",
		// 	from_index: '0',
		// 	limit: '100'
		// });

    // console.log(tokens);

    //     console.log("Getting Sale on the Smart Contract")
//     const DELIMETER = '||';

//     const sale = await account.viewFunction("market.dev-1623229186642-77647971299977", 
//     'get_sale',
//      { nft_contract_token: "dev-1623229186642-77647971299977" + DELIMETER + token_id}
//     );

//     console.log('\n\n get_sale result for nft', sale, '\n\n');
'''
'''--- scripts/test-utils.js ---
const BN = require('bn.js');
const fetch = require('node-fetch');
const nearAPI = require('near-api-js');
const { KeyPair, Account, Contract, utils: { format: { parseNearAmount } } } = nearAPI;
const { near, connection, keyStore, contract, contractAccount } = require('./near-utils');
const getConfig = require('./config');
const {
	networkId, contractName, contractMethods,
	DEFAULT_NEW_ACCOUNT_AMOUNT, 
	DEFAULT_NEW_CONTRACT_AMOUNT,
} = getConfig();

const TEST_HOST = 'http://localhost:3000';
/// exports
async function initContract() {
	/// try to call new on contract, swallow e if already initialized
	try {
		const newArgs = {
			owner_id: contractAccount.accountId,
			metadata: {
				spec: 'nft-1',
				name: 'Test NFT',
				symbol: 'TNFT',
			},
			supply_cap_by_type: {
				test: '1000000',
			},
			unlocked: true
		};
		await contract.new(newArgs);
	} catch (e) {
		if (!/initialized/.test(e.toString())) {
			throw e;
		}
	}
	return { contract, contractName };
}
const getAccountBalance = async (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();

const createOrInitAccount = async(accountId, secret) => {
	let account;
	try {
		account = await createAccount(accountId, DEFAULT_NEW_CONTRACT_AMOUNT, secret);
	} catch (e) {
		if (!/because it already exists/.test(e.toString())) {
			throw e;
		}
		account = new nearAPI.Account(connection, accountId);

		console.log(await getAccountBalance(accountId));

		const newKeyPair = KeyPair.fromString(secret);
		keyStore.setKey(networkId, accountId, newKeyPair);
	}
	return account;
};

async function getAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	accountId = accountId || generateUniqueSubAccount();
	const account = new nearAPI.Account(connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount);
};

async function getContract(account) {
	return new Contract(account || contractAccount, contractName, {
		...contractMethods,
		signer: account || undefined
	});
}

const createAccessKeyAccount = (key) => {
	connection.signer.keyStore.setKey(networkId, contractName, key);
	return new Account(connection, contractName);
};

const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => {
		// console.log(res)
		return res.json();
	});
};

const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({ ...data })
	}).then((res) => {
		console.log(res);
		return res.json();
	});
};

function generateUniqueSubAccount() {
	return `t${Date.now()}.${contractName}`;
}

/// internal
async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT, secret) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
}

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

module.exports = { 
	TEST_HOST,
	near,
	connection,
	keyStore,
	getContract,
	getAccountBalance,
	contract,
	contractName,
	contractMethods,
	contractAccount,
	createOrInitAccount,
	createAccessKeyAccount,
	initContract, getAccount, postSignedJson, postJson,
};

/// functionCallV2 console.warn upgrade helper

// [contractAccount, alice, bob].forEach((account) => {
// 	const temp = account.functionCall;
// 	const keys = ['contractId', 'methodName', 'args', 'gas', 'attachedDeposit'];
// 	account.functionCall = async (...args) => {
// 		if (typeof args[0] === 'string') {
// 			const functionCallOptions = {};
// 			args.forEach((arg, i) => {
// 				functionCallOptions[keys[i]] = arg;
// 			});
// 			console.warn(functionCallOptions);
// 		}
// 		return await temp.call(account, ...args);
// 	};
// });
'''
'''--- utils/config.js ---
const contractName = 'dev-1631962167293-57148505657038';
const private_key = '3qjktzrnN3xLEw7bLczLFBaA6Bvo9xYhEnj2RfHeyMwsatWurUh1B4zApY2pgzbgkbnEQqYnkCxdTopB9GqzNSQf';
const market_private_key = 'ed25519:DvT8BanvAijUvptnTm9eaH37fkq8DoWrgxeZBPaUq2ZTDz5iZYAQZEuxp2ZEZtkkjRzxK8Qp84Ur2SdRUSvchVV';

module.exports = function getConfig() {
	
    let config = {
		networkId: "mainnet",
		nodeUrl: "https://rpc.testnet.near.org",
		// walletUrl: 'http://localhost:1234',
		walletUrl: "https://wallet.testnet.near.org",
		helperUrl: "https://helper.testnet.near.org",
		contractName,
		private_key,
		market_private_key,
        explorerUrl: "https://explorer.testnet.near.org",
		GAS: "200000000000000",
		DEFAULT_NEW_ACCOUNT_AMOUNT: "5",
		DEFAULT_NEW_CONTRACT_AMOUNT: "5",
		contractMethods: {
			changeMethods: [
				"new",
				"storage_deposit",
				"nft_mint",
				"nft_approve",
				"offer",
				],
				viewMethods: ["get_token_ids", "nft_token", "get_sale"],
			},
			marketDeposit: "100000000000000000000000",
			marketId: "market." + contractName,
	};

	return config;
};

'''
'''--- utils/create_initial_accounts.js ---
const fs = require('fs');
const testUtils = require('./tutils.js');
const nearAPI = require('near-api-js');
const getConfig = require('./config');

const { 
	GAS, private_key, contractName, market_private_key
} = getConfig(true);

const { 
	createOrInitAccount,
	createOrInitAccount2,
	createOrInitAccount3,
	initAccount
} = testUtils;

const { 
	Contract, KeyPair, Account,
	utils: { format: { parseNearAmount }},
	transactions: { deployContract, functionCall },
} = nearAPI;

// require("dotenv").config();
require('dotenv').config({path:__dirname+'/./../neardev/dev-account.env'}) 
// console.log(process.env.CONTRACT_NAME);

function sleep(ms) {
	return new Promise(resolve => setTimeout(resolve, ms));
}
  
async function main(){

    console.log(process.env.CONTRACT_NAME);
	// const acct ="nft."+ process.env.CONTRACT_NAME;
	// var deployAccount;
	// deployAccount = await createOrInitAccount2(acct);
	const macct2 = "market"+"." + process.env.CONTRACT_NAME;
	var marketAccount;
	marketAccount = await createOrInitAccount3(macct2);
	
}

main();

'''
'''--- utils/deploy-market-upgrade.js ---
const fs = require('fs');
const testUtils = require('./tutils.js');
const nearAPI = require('near-api-js');
const getConfig = require('./config');

const { 
	GAS, private_key, contractName, market_private_key
} = getConfig(true);

const { 
	createOrInitAccount,
	createOrInitAccount2,
	createOrInitAccount3,
	initAccount
} = testUtils;

const { 
	Contract, KeyPair, Account,
	utils: { format: { parseNearAmount }},
	transactions: { deployContract, functionCall },
} = nearAPI;

// require("dotenv").config();
require('dotenv').config({path:__dirname+'/./../neardev/dev-account.env'}) 
// console.log(process.env.CONTRACT_NAME);

function sleep(ms) {
	return new Promise(resolve => setTimeout(resolve, ms));
}
  
async function main(){

	const acct ="nft."+ process.env.CONTRACT_NAME;
	const macct2 = "market"+"." + process.env.CONTRACT_NAME;

	var marketAccount;

	marketAccount = await createOrInitAccount(macct2, market_private_key);

    const marketContractBytes = fs.readFileSync('.././out/music_market.wasm');
    console.log('\n\n deploying marketAccount contractBytes:', marketContractBytes.length, '\n\n');

    const actions1 = [
        deployContract(marketContractBytes)
    ];

	await marketAccount.signAndSendTransaction(macct2, actions1);

}

main();

'''
'''--- utils/deploy-market.js ---
const fs = require('fs');
const testUtils = require('./tutils.js');
const nearAPI = require('near-api-js');
const getConfig = require('./config');

const { 
	GAS, private_key, contractName, market_private_key
} = getConfig(true);

const { 
	createOrInitAccount,
	createOrInitAccount2,
	createOrInitAccount3,
	initAccount
} = testUtils;

const { 
	Contract, KeyPair, Account,
	utils: { format: { parseNearAmount }},
	transactions: { deployContract, functionCall },
} = nearAPI;

// require("dotenv").config();
require('dotenv').config({path:__dirname+'/./../neardev/dev-account.env'}) 
// console.log(process.env.CONTRACT_NAME);

function sleep(ms) {
	return new Promise(resolve => setTimeout(resolve, ms));
}
  
async function main(){

	const acct ="nft."+ process.env.CONTRACT_NAME;
	const macct2 = "market"+"." + process.env.CONTRACT_NAME;

	var marketAccount;

	marketAccount = await createOrInitAccount(macct2, market_private_key);
	await marketAccount.deleteAccount(process.env.CONTRACT_NAME);
	marketAccount = await createOrInitAccount(macct2, market_private_key);

    const marketContractBytes = fs.readFileSync('.././out/music_market.wasm');
    console.log('\n\n deploying marketAccount contractBytes:', marketContractBytes.length, '\n\n');
    const newMarketArgs = {
        owner_id: process.env.CONTRACT_NAME,
		nft_contract_id: acct,
    };

    const actions1 = [
        deployContract(marketContractBytes),
        functionCall('new', newMarketArgs, GAS)
    ];

	await sleep(1000);
	await marketAccount.signAndSendTransaction(macct2, actions1);

	// }

}

main();

'''
'''--- utils/deploy-nft-upgrade.js ---
const fs = require('fs');
const testUtils = require('./tutils.js');
const nearAPI = require('near-api-js');
const getConfig = require('./config');

const { 
	GAS, private_key, contractName, market_private_key
} = getConfig(true);

const { 
	createOrInitAccount,
	createOrInitAccount2,
	createOrInitAccount3,
	initAccount
} = testUtils;

const { 
	Contract, KeyPair, Account,
	utils: { format: { parseNearAmount }},
	transactions: { deployContract, functionCall },
} = nearAPI;

// require("dotenv").config();
require('dotenv').config({path:__dirname+'/./../neardev/dev-account.env'}) 
// console.log(process.env.CONTRACT_NAME);

function sleep(ms) {
	return new Promise(resolve => setTimeout(resolve, ms));
}
  
async function main(){

	const acct ="nft."+ process.env.CONTRACT_NAME;
	const macct2 = "market"+"." + process.env.CONTRACT_NAME;

	var deployAccount;

	// await sleep(3000);
	deployAccount = await createOrInitAccount(acct, private_key);
	// await sleep(3000);

	const contractBytes = fs.readFileSync('.././out/music_nft.wasm');
	console.log('\n\n Deploying NFT Contract \n\n');
	
	const actions = [
    	deployContract(contractBytes)
	];

	// await sleep(1000);
	await deployAccount.signAndSendTransaction(acct, actions);

}

main();

'''
'''--- utils/deploy-nft.js ---
const fs = require('fs');
const testUtils = require('./tutils.js');
const nearAPI = require('near-api-js');
const getConfig = require('./config');

const { 
	GAS, private_key, contractName, market_private_key
} = getConfig(true);

const { 
	createOrInitAccount,
	createOrInitAccount2,
	createOrInitAccount3,
	initAccount
} = testUtils;

const { 
	Contract, KeyPair, Account,
	utils: { format: { parseNearAmount }},
	transactions: { deployContract, functionCall },
} = nearAPI;

// require("dotenv").config();
require('dotenv').config({path:__dirname+'/./../neardev/dev-account.env'}) 
// console.log(process.env.CONTRACT_NAME);

function sleep(ms) {
	return new Promise(resolve => setTimeout(resolve, ms));
}
  
async function main(){

	const acct ="nft."+ process.env.CONTRACT_NAME;
	const macct2 = "market"+"." + process.env.CONTRACT_NAME;

	var deployAccount;

	deployAccount = await createOrInitAccount(acct, private_key);
	// await sleep(3000);
	try{
		// await deployAccount.deleteAccount(process.env.CONTRACT_NAME);
	} catch(e){
		// console.log(e);
	}
	// await sleep(3000);
	// deployAccount = await createOrInitAccount(acct, private_key);
	// await sleep(3000);

	const contractBytes = fs.readFileSync('.././out/music_nft.wasm');
	console.log('\n\n Deploying NFT Contract \n\n');
	const newArgs = {
    	owner_id: process.env.CONTRACT_NAME,
		metadata: {
        	spec: '0.5.0',
        	name: 'amplify art',
        	symbol: 'amplify',
    	},
		market_contract_id: macct2,

	};

	const actions = [
    	// deployContract(contractBytes),
    	functionCall('new', newArgs, GAS)
	];

	// await sleep(1000);
	await deployAccount.signAndSendTransaction(acct, actions);

}

main();
// QmbvXWy7WE3aFabf1TStLGPzrM8qh9FsGSQWakefLvCQvM
// QmbvXWy7WE3aFabf1TStLGPzrM8qh9FsGSQWakefLvCQvM:2
'''
'''--- utils/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("./config");
const { nodeUrl, networkId, contractName, contractMethods, private_key } = getConfig(true);
const {
	keyStores: { InMemoryKeyStore },
	Near,
	Account,
	Contract,
	KeyPair,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;

// console.log(
// 	"Loading Credentials:\n",
// 	`keys/${networkId}/${contractName}.json`
// );
// const credentials = JSON.parse(
// 	fs.readFileSync(
// 		`keys/${networkId}/${networkId}/${contractName}.json`
// 	)
// );

// const UnencryptedFileSystemKeyStore = nearAPI.keyStores.UnencryptedFileSystemKeyStore;
// const keyStore = new UnencryptedFileSystemKeyStore("/home/hunter/.near-credentials");

const keyStore = new InMemoryKeyStore();
keyStore.setKey(
	networkId,
	contractName,
	KeyPair.fromString("ed25519:5DURCxXJ8CVCfBP9ppNdW2NGzWtw9h48er3wCNq9X71GgUgasHgvb2AHLoFmgiBhMwLA28jFNFmFf3HXzkca2MZ1")
);

const near = new Near({
	networkId,
	nodeUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractName);
contractAccount.addAccessKey = (publicKey) =>
	contractAccount.addKey(
		publicKey,
		contractName,
		contractMethods.changeMethods,
		parseNearAmount("0.1")
	);
const contract = new Contract(contractAccount, contractName, contractMethods);

module.exports = {
	near,
	keyStore,
	connection,
	contract,
	contractName,
	contractAccount,
	contractMethods,
};

'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./../neardev/dev-account').toString()
const path = './config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''
'''--- utils/patch-deploy-config.js ---
const fs = require('fs');
const path = './src/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = 'dev-1618440176640-7650905';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''
'''--- utils/tutils.js ---
const BN = require('bn.js');
const fetch = require('node-fetch');
const nearAPI = require('near-api-js');
const { KeyPair, Account, Contract, utils: { format: { parseNearAmount } } } = nearAPI;
const { near, connection, keyStore, contract, contractAccount } = require('./near-utils');
const getConfig = require('./config');
const {
	networkId, contractName, contractMethods,
	DEFAULT_NEW_ACCOUNT_AMOUNT, 
	DEFAULT_NEW_CONTRACT_AMOUNT,
} = getConfig();
const path = './config.js'
const fs = require('fs');

const TEST_HOST = 'http://localhost:3000';
// /// exports
async function initContract() {
// 	/// try to call new on contract, swallow e if already initialized
	try {
		const newArgs = {
			owner_id: contractAccount.accountId,
			metadata: {
				spec: '0.3.0',
				name: 'Amplify Art',
				symbol: 'Amplify Art',
			},
			supply_cap_by_type: {
				test: '1000000',
			},
			unlocked: true
		};
		await contract.new(newArgs);
	} catch (e) {
		if (!/initialized/.test(e.toString())) {
			throw e;
		}
	}
	return { contract, contractName };
}
const getAccountBalance = async (accountId) => (new nearAPI.Account(connection, accountId)).getAccountBalance();

const createOrInitAccount = async(accountId, secret) => {
	let account;
	// console.log('Creating account');
	try {
		account = await createAccount(accountId, DEFAULT_NEW_CONTRACT_AMOUNT, secret);
	} catch (e) {
		
		if (!/because it already exists/.test(e.toString())) {
			throw e;
		}
		console.log("Hello Sir");
		// console.log()
		account = new nearAPI.Account(connection, accountId);

		console.log(await getAccountBalance(accountId));

		const newKeyPair = KeyPair.fromString(secret);
		keyStore.setKey(networkId, accountId, newKeyPair);

	}
	return account;
};

const createOrInitAccount2 = async(accountId) => {
	let account;
	try {
		account = await createAccountCredentials(accountId, DEFAULT_NEW_CONTRACT_AMOUNT);
	} catch (e) {
		if (!/because it already exists/.test(e.toString())) {
			throw e;
		}
		account = new nearAPI.Account(connection, accountId);

		console.log(await getAccountBalance(accountId));
	
	}
	return account;
};

const createOrInitAccount3 = async(accountId) => {
	let account;
	try {
		account = await createAccountCredentials1(accountId, DEFAULT_NEW_CONTRACT_AMOUNT);
	} catch (e) {
		if (!/because it already exists/.test(e.toString())) {
			throw e;
		}
		account = new nearAPI.Account(connection, accountId);

		console.log(await getAccountBalance(accountId));
	
	}
	return account;
};

const initAccount = async(accountId) => {
	let account;
	account = new nearAPI.Account(connection, accountId);
	console.log(await getAccountBalance(accountId));
	return account;
};

async function getAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	accountId = accountId || generateUniqueSubAccount();
	const account = new nearAPI.Account(connection, accountId);
	try {
		await account.state();
		return account;
	} catch(e) {
		if (!/does not exist/.test(e.toString())) {
			throw e;
		}
	}
	return await createAccount(accountId, fundingAmount);
};

async function getContract(account) {
	return new Contract(account || contractAccount, contractName, {
		...contractMethods,
		signer: account || undefined
	});
}

const createAccessKeyAccount = (key) => {
	connection.signer.keyStore.setKey(networkId, contractName, key);
	return new Account(connection, contractName);
};

const postSignedJson = async ({ account, contractName, url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({
			...data,
			accountId: account.accountId,
			contractName,
			...(await getSignature(account))
		})
	}).then((res) => {
		// console.log(res)
		return res.json();
	});
};

const postJson = async ({ url, data = {} }) => {
	return await fetch(url, {
		method: 'POST',
		headers: { 'content-type': 'application/json' },
		body: JSON.stringify({ ...data })
	}).then((res) => {
		console.log(res);
		return res.json();
	});
};

function generateUniqueSubAccount() {
	return `t${Date.now()}.${contractName}`;
}

/// internal
async function createAccount(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT, secret) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = secret ? KeyPair.fromString(secret) : KeyPair.fromRandom('ed25519');
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	keyStore.setKey(networkId, accountId, newKeyPair);
	return new nearAPI.Account(connection, accountId);
}

//internal
async function createAccountCredentials(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = KeyPair.fromRandom('ed25519');
	// console.log(newKeyPair);
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	// keyStore.setKey(networkId, accountId, newKeyPair);
	await contractAccount.connection.signer.keyStore.setKey(networkId, accountId, newKeyPair);
	const nft_privateKey = newKeyPair.secretKey;
	 
	fs.readFile(path, 'utf-8', function(err, data) {
		if (err) throw err;
	 
		data = data.replace(/.*const private_key.*/gim, `const private_key = '${nft_privateKey}';`);
	 
		fs.writeFile(path, data, 'utf-8', function(err) {
			if (err) throw err;
			console.log('Done!');
		})
	})
	
	return new nearAPI.Account(connection, accountId);
}

async function createAccountCredentials1(accountId, fundingAmount = DEFAULT_NEW_ACCOUNT_AMOUNT) {
	const contractAccount = new Account(connection, contractName);
	const newKeyPair = KeyPair.fromRandom('ed25519');
	// console.log(newKeyPair);
	await contractAccount.createAccount(accountId, newKeyPair.publicKey, new BN(parseNearAmount(fundingAmount)));
	// keyStore.setKey(networkId, accountId, newKeyPair);
	await contractAccount.connection.signer.keyStore.setKey(networkId, accountId, newKeyPair);
	
	const nft_privateKey = newKeyPair.secretKey;
	 
	fs.readFile(path, 'utf-8', function(err, data) {
		if (err) throw err;
	 
		data = data.replace(/.*const market_private_key.*/gim, `const market_private_key = '${newKeyPair}';`);
	 
		fs.writeFile(path, data, 'utf-8', function(err) {
			if (err) throw err;
			console.log('Done!');
		})
	})
	
	return new nearAPI.Account(connection, accountId);
}

const getSignature = async (account) => {
	const { accountId } = account;
	const block = await account.connection.provider.block({ finality: 'final' });
	const blockNumber = block.header.height.toString();
	const signer = account.inMemorySigner || account.connection.signer;
	const signed = await signer.signMessage(Buffer.from(blockNumber), accountId, networkId);
	const blockNumberSignature = Buffer.from(signed.signature).toString('base64');
	return { blockNumber, blockNumberSignature };
};

module.exports = { 
	TEST_HOST,
	near,
	connection,
	keyStore,
	getContract,
	getAccountBalance,
	contract,
	contractName,
	contractMethods,
	contractAccount,
	createOrInitAccount,
	createOrInitAccount2,
	createOrInitAccount3,
	initAccount,
	createAccessKeyAccount,
	initContract, getAccount, postSignedJson, postJson,
};
'''