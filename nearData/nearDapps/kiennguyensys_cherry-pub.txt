*GitHub Repository "kiennguyensys/cherry-pub"*

'''--- Cargo.toml ---
[workspace]

members = [
    "nft",
    "cherry-pool",
    "simulation"
]
'''
'''--- README.md ---
# cherry-pub
PoolTogether in Near

'''
'''--- cherry-pool/Cargo.toml ---
[package]
name = "cherry-pool"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.1"
primitive-types = "^0.7.3"
uint = { version = "0.8.3", default-features = false }
getrandom = { version = "0.2", features = ["js"] }
rand = "0.8.5"
rand_chacha = "0.3.1"
'''
'''--- cherry-pool/src/internal.rs ---
use crate::*;
use rand::prelude::*;
use rand_chacha::ChaCha8Rng;
use std::convert::TryInto;
const ON_STAKE_ACTION_GAS: u64 = 20_000_000_000_000;
const NO_DEPOSIT: Balance = 0;
const NUM_EPOCHS_TO_UNLOCK: EpochHeight = 4;

impl StakingPool {
    pub(crate) fn internal_ping(&mut self ) -> bool {
        let epoch_height = env::epoch_height();
        if self.last_epoch_height == epoch_height {
            return false;
        }
        self.last_epoch_height = epoch_height;

        // New total amount (both locked and unlocked balances).
        // NOTE: We need to subtract `attached_deposit` in case `ping` called from `deposit` call
        // since the attached deposit gets included in the `account_balance`, and we have not
        // accounted it yet.
        let total_balance =
            env::account_locked_balance() + env::account_balance() - env::attached_deposit();

        assert!(
            total_balance >= self.last_total_balance,
            "The new total balance should not be less than the old total balance"
        );
        let total_reward = total_balance - self.last_total_balance;

        if total_reward > 0 {
            // The validation fee that the contract owner takes.
            // let owners_fee = self.reward_fee_fraction.multiply(total_reward);

            // Distributing the remaining reward to the delegators first.
            // let remaining_reward = total_reward - owners_fee;
            self.total_reward += total_reward;
            self.total_staked_balance += total_reward;

            // Now buying "stake" shares for the contract owner at the new share price.
            // let num_shares = self.num_shares_from_staked_amount_rounded_down(owners_fee);
            // if num_shares > 0 {
            //     // Updating owner's inner account
            //     let owner_id = self.owner_id.clone();
            //     let mut account = self.internal_get_account(&owner_id);
            //     account.stake_shares += num_shares;
            //     self.internal_save_account(&owner_id, &account);
            //     // Increasing the total amount of "stake" shares.
            //     self.total_stake_shares += num_shares;
            // }
            // Increasing the total staked balance by the owners fee, no matter whether the owner
            // received any shares or not.
            // self.total_staked_balance += owners_fee;

            env::log(
                format!(
                    "Epoch {}: Contract received total rewards of {} tokens. New total staked balance is {}",
                    epoch_height, total_reward, self.total_staked_balance,
                )
                    .as_bytes(),
            );
            // if num_shares > 0 {
            //     env::log(format!("Total rewards fee is {} stake shares.", num_shares).as_bytes());
            // }
        }

        if self.next_prize_event_epoch_height <= env::epoch_height() {
            let winner = self.get_prize_winner();
            self.transfer_prize_to_winner(winner);
            self.next_prize_event_epoch_height = env::epoch_height() + 14;
        }

        self.last_total_balance = total_balance;
        true
    }

    pub(crate) fn internal_stake(&mut self, amount: Balance) {
        assert!(amount > 0, "Staking amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.get_account(account_id);

        // Calculate the number of "stake" shares that the account will receive for staking the
        // given amount.
        let num_shares = self.num_shares_from_staked_amount_rounded_down(amount);
        assert!(
            num_shares > 0,
            "The calculated number of \"stake\" shares received for staking should be positive"
        );
        // The amount of tokens the account will be charged from the unstaked balance.
        // Rounded down to avoid overcharging the account to guarantee that the account can always
        // unstake at least the same amount as staked.
        let charge_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);
        assert!(
            charge_amount > 0,
            "Invariant violation. Calculated staked amount must be positive, because \"stake\" share price should be at least 1"
        );

        assert!(
            account.unstaked_balance >= charge_amount,
            "Not enough unstaked balance to stake"
        );
        account.unstaked_balance -= charge_amount;
        account.stake_shares += num_shares;
        account.stake_points += 1;
        self.save_account(&account);

        // The staked amount that will be added to the total to guarantee the "stake" share price
        // never decreases. The difference between `stake_amount` and `charge_amount` is paid
        // from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let stake_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);

        self.total_staked_balance += stake_amount;
        self.total_stake_shares += num_shares;

        env::log(
            format!(
                "@{} staking {}. Received {} new staking shares. Total {} unstaked balance and {} staking shares",
                account.account_id, charge_amount, num_shares, account.unstaked_balance, account.stake_shares
            )
                .as_bytes(),
        );
        env::log(
            format!(
                "Contract total staked balance is {}. Total number of shares {}",
                self.total_staked_balance, self.total_stake_shares
            )
            .as_bytes(),
        );
    } 

    pub(crate) fn internal_add_tickets(&mut self, amount: u128, multiplier: u64) {
        assert!(amount > 0, "Staking amount should be positive");
        
        let tickets_amount = amount / MIN_TICKET_DEPOSIT_PRICE;
        let mut tickets_num = tickets_amount as u64;
        

        let mut account = self.get_account(env::predecessor_account_id());
        tickets_num = tickets_num * multiplier;
        account.tickets_amount += tickets_num;
        self.save_account(&account);
        println!("tickets added: {}", tickets_num);
        
        let next_tickets_count = self.tickets_count + tickets_num;
        let mut optional = Some(self.tickets_count);

        while let Some(i) = optional {
            if i >= next_tickets_count {
                optional = None;
            } else {
                self.tickets_random_slots.push(&account.account_id);
                optional = Some(i + 1);
            }
        }
        self.tickets_count = next_tickets_count;
    }

    pub(crate) fn internal_remove_tickets(&mut self, amount: u128) {
        assert!(amount > 0, "Staking amount should be positive");
        
        let tickets_amount = amount / MIN_TICKET_DEPOSIT_PRICE;
        let mut tickets_num = tickets_amount as u64;

        let mut account = self.get_account(env::predecessor_account_id());
        tickets_num = tickets_num * account.tickets_multiplier;
        account.tickets_amount -= tickets_num;
        account.tickets_multiplier = 1;
        self.save_account(&account);

        println!("tickets removed: {}", tickets_amount);

        let next_tickets_count = self.tickets_count - tickets_num;

        for i in 0..next_tickets_count {
            let ticket_owner = self.tickets_random_slots.get(i as u64).unwrap();
            if ticket_owner == account.account_id && tickets_num > 0 {
                self.tickets_random_slots.swap_remove(i as u64);
                tickets_num -= 1;
            }
        }

        self.tickets_count = next_tickets_count;
    }

    pub(crate) fn internal_unstake(&mut self, amount: u128) {
        assert!(amount > 0, "Unstaking amount should be positive");

        let account_id = env::predecessor_account_id();
        let mut account = self.get_account(account_id);

        assert!(
            self.total_staked_balance > 0,
            "The contract doesn't have staked balance"
        );
        // Calculate the number of shares required to unstake the given amount.
        // NOTE: The number of shares the account will pay is rounded up.
        let num_shares = self.num_shares_from_staked_amount_rounded_up(amount);
        assert!(
            num_shares > 0,
            "Invariant violation. The calculated number of \"stake\" shares for unstaking should be positive"
        );
        assert!(
            account.stake_shares >= num_shares,
            "Not enough staked balance to unstake"
        );

        // Calculating the amount of tokens the account will receive by unstaking the corresponding
        // number of "stake" shares, rounding up.
        let receive_amount = self.staked_amount_from_num_shares_rounded_up(num_shares);
        assert!(
            receive_amount > 0,
            "Invariant violation. Calculated staked amount must be positive, because \"stake\" share price should be at least 1"
        );

        account.stake_shares -= num_shares;
        account.unstaked_balance += receive_amount;
        account.stake_points -= 1;
        account.unstaked_available_epoch_height = env::epoch_height() + NUM_EPOCHS_TO_UNLOCK;
        self.save_account(&account);

        // The amount tokens that will be unstaked from the total to guarantee the "stake" share
        // price never decreases. The difference between `receive_amount` and `unstake_amount` is
        // paid from the allocated STAKE_SHARE_PRICE_GUARANTEE_FUND.
        let unstake_amount = self.staked_amount_from_num_shares_rounded_down(num_shares);

        self.total_staked_balance -= unstake_amount;
        self.total_stake_shares -= num_shares;

        env::log(
            format!(
                "@{} unstaking {}. Spent {} staking shares. Total {} unstaked balance and {} staking shares",
                account.account_id, receive_amount, num_shares, account.unstaked_balance, account.stake_shares
            )
                .as_bytes(),
        );
        env::log(
            format!(
                "Contract total staked balance is {}. Total number of shares {}",
                self.total_staked_balance, self.total_stake_shares
            )
            .as_bytes(),
        );
    }

    pub(crate) fn internal_restake(&mut self) {
        if self.is_restake_paused {
            return;
        }
        // Stakes with the staking public key. If the public key is invalid the entire function
        // call will be rolled back.
        Promise::new(env::current_account_id())
            .stake(self.total_staked_balance, self.stake_public_key.clone())
            .then(ext_self::on_stake_action(
                &env::current_account_id(),
                NO_DEPOSIT,
                ON_STAKE_ACTION_GAS,
            ));
    }

    pub(crate) fn num_shares_from_staked_amount_rounded_down(
        &self,
        amount: Balance,
    ) -> Balance {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        (U256::from(self.total_stake_shares) * U256::from(amount)
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the number of "stake" shares rounded up corresponding to the given staked balance
    /// amount.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    pub(crate) fn num_shares_from_staked_amount_rounded_up(
        &self,
        amount: Balance,
    ) -> Balance {
        assert!(
            self.total_staked_balance > 0,
            "The total staked balance can't be 0"
        );
        ((U256::from(self.total_stake_shares) * U256::from(amount)
            + U256::from(self.total_staked_balance - 1))
            / U256::from(self.total_staked_balance))
        .as_u128()
    }

    /// Returns the staked amount rounded down corresponding to the given number of "stake" shares.
    pub(crate) fn staked_amount_from_num_shares_rounded_down(
        &self,
        num_shares: Balance,
    ) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        (U256::from(self.total_staked_balance) * U256::from(num_shares)
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    /// Returns the staked amount rounded up corresponding to the given number of "stake" shares.
    ///
    /// Rounding up division of `a / b` is done using `(a + b - 1) / b`.
    pub(crate) fn staked_amount_from_num_shares_rounded_up(
        &self,
        num_shares: Balance,
    ) -> Balance {
        assert!(
            self.total_stake_shares > 0,
            "The total number of stake shares can't be 0"
        );
        ((U256::from(self.total_staked_balance) * U256::from(num_shares)
            + U256::from(self.total_stake_shares - 1))
            / U256::from(self.total_stake_shares))
        .as_u128()
    }

    // pub(crate) fn random_winners(&mut self) {
    //     self.random_u64();
    // }
    pub(crate) fn get_prize_winner(&mut self) -> AccountId {
        assert!(self.next_prize_event_epoch_height <= env::epoch_height(), "Next prize event time not reached");
        let ticket_id = self.random_u64(0, self.tickets_count);
        println!("Winning Ticket: {}", ticket_id);
        let winner = self.tickets_random_slots.get(ticket_id as u64).unwrap();
        winner
    }

    pub(crate) fn transfer_prize_to_winner(&mut self, winner: AccountId) -> Promise {
        assert!(self.next_prize_event_epoch_height <= env::epoch_height(), "Next prize event time not reached");
        let prize = self.total_reward;
        self.total_reward = 0;
        Promise::new(winner).transfer(prize)
    }

    pub(crate) fn random_u64(&self, min_inc: u64, max_exc: u64) -> u64 {
        // Returns a random number between min (included) and max (excluded)
        let seed_vec = env::random_seed();
        let mut seed: <ChaCha8Rng as SeedableRng>::Seed = env::sha256(&seed_vec.to_owned()).try_into().unwrap();
        thread_rng().fill(&mut seed);
        let mut rng = ChaCha8Rng::from_seed(seed);
        let random = rng.next_u64() % (max_exc - min_inc) + min_inc;
        random
    }

    pub(crate) fn validate_nft_owner(&mut self) -> Promise {
        ext_nft_enumeration::nft_tokens_for_owner(
            env::predecessor_account_id(),
            None,
            None,
            &self.nft_contract_id,
            0,
            5_000_000_000_000
        )
        .then(ext_self::nft_valid_callback(
            &env::current_account_id(), // this contract's account id
            0, // yocto NEAR to attach to the callback
            5_000_000_000_000 // gas to attach to the callback
        ))
    }

    pub fn nft_valid_callback(&self) -> bool {
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
      
        // handle the result from the cross contract call this method is a callback for
        match env::promise_result(0) {
          PromiseResult::NotReady => unreachable!(),
          PromiseResult::Failed => false,
          PromiseResult::Successful(result) => {
              let tokens = near_sdk::serde_json::from_slice::<Vec<Token>>(&result).unwrap();
              if tokens.len() > 0 {
                  true
              } else {
                  false
              }
          },
        }
    }

    pub fn pay_nft_for_multiplier(&mut self, token: Token) -> Promise {
        ext_nft::nft_transfer_call(
            env::current_account_id(),
            token.clone().token_id,
            None,
            None,
            "Transfered".to_owned(),
            &self.nft_contract_id,
            0,
            5_000_000_000_000
        )
        .then(ext_self::nft_transfer_callback(
            token.token_id,
            &env::current_account_id(), // this contract's account id
            0, // yocto NEAR to attach to the callback
            5_000_000_000_000 // gas to attach to the callback
        ))
    }

    pub fn nft_transfer_callback(&mut self, token_id: TokenId) -> bool {
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
      
        // handle the result from the cross contract call this method is a callback for
        match env::promise_result(0) {
          PromiseResult::NotReady => unreachable!(),
          PromiseResult::Failed => false,
          PromiseResult::Successful(result) => {
              let is_transfer_successful = near_sdk::serde_json::from_slice::<bool>(&result).unwrap();
              if is_transfer_successful {          
                    let mut account = self.get_account(env::predecessor_account_id());
                    account.tickets_multiplier = 2;
                    let current_staked_amount = account.staked_balance;

                    self.internal_add_tickets(current_staked_amount, account.tickets_multiplier - 1);
                    self.nft_hold.push(&token_id);
              }
              is_transfer_successful
          },
        }
    }

    pub fn claim_reward_nft(&mut self) -> Promise {
        let mut account = self.get_account(env::predecessor_account_id());
        assert!(account.stake_points >= 10, "Not enough Stake Times to Claim NFT");
        account.stake_points = 0;
        let token_id = self.nft_hold.pop().unwrap();

        ext_nft::nft_transfer_call(
            env::predecessor_account_id(),
            token_id.clone(),
            None,
            None,
            "Transfered".to_owned(),
            &self.nft_contract_id,
            0,
            5_000_000_000_000
        )
        // .then(ext_self::nft_transfer_callback(
        //     token_id,
        //     &env::current_account_id(), // this contract's account id
        //     0, // yocto NEAR to attach to the callback
        //     5_000_000_000_000 // gas to attach to the callback
        // ))
    }
}

#[ext_contract(ext_nft)]
trait NonFungibleToken {
    // change methods
    fn nft_transfer(&mut self, receiver_id: String, token_id: String, approval_id: Option<u64>, memo: Option<String>);
    fn nft_transfer_call(&mut self, receiver_id: String, token_id: String, approval_id: Option<u64>, memo: Option<String>, msg: String) -> bool;

    // view method
    fn nft_token(&self, token_id: String) -> Option<Token>;
}

#[ext_contract(ext_nft_enumeration)]
trait NonFungibleTokenApprovalManagement: NonFungibleToken {
    fn nft_total_supply(&self) -> U128;
    fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Token>;
    fn nft_supply_for_owner(&self, account_id: String) -> String;
    fn nft_tokens_for_owner(&self, account_id: String, from_index: Option<U128>, limit: Option<u64>) -> Vec<Token>;
}
'''
'''--- cherry-pool/src/lib.rs ---

use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LookupMap, Vector},
    env, ext_contract,
    json_types::{ValidAccountId, U128, U64, Base58PublicKey},
    log, near_bindgen,
    serde::{Deserialize, Serialize},
    wee_alloc, AccountId, Balance, EpochHeight, PanicOnDefault, 
    Promise, PromiseOrValue,PromiseResult,
    PublicKey
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
// use std::convert::TryFrom;
use uint::construct_uint;
mod internal;
mod test_utils;

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct U256(4);
}

const STAKE_SHARE_PRICE_GUARANTEE_FUND: Balance = 1_000_000_000_000;
const MIN_TICKET_DEPOSIT_PRICE: Balance = 10 * 10u128.pow(24);
const POOL_THRESHOLD: Balance = 10_000 * 10u128.pow(24);

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct StakingPool {
    owner_id: AccountId,
    accounts: LookupMap<String, StakingPoolAccount>,
    tickets_count: u64,
    tickets_random_slots: Vector<AccountId>,
    next_prize_event_epoch_height: EpochHeight,
    total_reward: Balance,
    total_staked_balance: Balance,
    last_total_balance: Balance,
    total_stake_shares: Balance,
    stake_public_key: PublicKey,
    last_epoch_height: EpochHeight,
    is_restake_paused: bool,
    nft_contract_id: AccountId,
    nft_hold: Vector<TokenId>
}

/// staking pool interface that STAKE token contract depends on
#[near_bindgen]
impl StakingPool {
    #[init]
    pub fn new(owner_id: AccountId, stake_public_key: Base58PublicKey) -> Self {
        let account_balance = env::account_balance();
        let total_staked_balance = account_balance - STAKE_SHARE_PRICE_GUARANTEE_FUND;
        assert_eq!(
            env::account_locked_balance(),
            0,
            "The staking pool shouldn't be staking at the initialization"
        );
        let mut this = Self {
            owner_id: owner_id,
            accounts: LookupMap::new(b"a".to_vec()),
            tickets_random_slots: Vector::new(b"t".to_vec()),
            tickets_count: 0,
            next_prize_event_epoch_height: env::epoch_height() + 14,
            total_reward: 0,
            total_staked_balance: total_staked_balance,
            last_total_balance: account_balance,
            total_stake_shares: total_staked_balance,
            stake_public_key: stake_public_key.into(),
            last_epoch_height: env::epoch_height(),
            is_restake_paused: false,
            nft_contract_id: "cherrypub_nft.testnet".to_owned(),
            nft_hold: Vector::new(b"h".to_vec())
        };
        this
    }

    pub fn get_account(&self, account_id: AccountId) -> StakingPoolAccount {
        let mut account = 
            self.accounts
            .get(&account_id)
            .unwrap_or_else(|| StakingPoolAccount::new(&account_id));
        account.staked_balance = 
            self
            .staked_amount_from_num_shares_rounded_down(account.stake_shares)
            .into();
        account.can_withdraw =
            account.unstaked_available_epoch_height <= env::epoch_height();
        account
    }

    /// Distributes rewards and restakes if needed.
    pub fn ping(&mut self) {
        if self.internal_ping() {
            self.internal_restake();
        }
    }

    #[payable]
    pub fn deposit(&mut self) {
        let need_to_restake = self.internal_ping();
        let amount = env::attached_deposit();
        let mut account = self.get_account(env::predecessor_account_id());
        account.unstaked_balance += amount;
        self.last_total_balance += amount;
        self.save_account(&account);

        if need_to_restake {
            self.internal_restake();
        }
    }

    pub fn stake(&mut self, amount: Balance) {
        self.internal_ping();
        self.internal_stake(amount);
        self.internal_add_tickets(amount, 1);
        self.internal_restake();
    }

    #[payable]
    pub fn deposit_and_stake(&mut self) {
        self.deposit();
        self.stake(env::attached_deposit());
    }

    pub fn withdraw_all(&mut self) {
        let mut account = self.get_account(env::predecessor_account_id());
        assert!(account.can_withdraw, "account cannot withdraw yet");
        assert!(account.unstaked_balance > 0, "unstaked balance is zero");
        let unstaked_balance = account.unstaked_balance;
        account.unstaked_balance = 0;
        self.save_account(&account);
        Promise::new(account.account_id).transfer(unstaked_balance);
    }

    pub fn unstake(&mut self, amount: Balance) {
        self.internal_ping();
        self.internal_unstake(amount);
        self.internal_remove_tickets(amount);
        self.internal_restake();
    }

    pub fn unstake_all(&mut self) {
        let mut account = self.get_account(env::predecessor_account_id());
        assert!(account.staked_balance > 0, "Staked balance is zero");
        account.unstaked_balance += account.staked_balance;
        self.total_staked_balance -= account.staked_balance;
        account.staked_balance = 0;
        self.save_account(&account);
    }

    // *** View Method
    /// Returns the unstaked balance of the given account.
    pub fn get_account_unstaked_balance(&self, account_id: AccountId) -> u128 {
        self.get_account(account_id).unstaked_balance
    }

    /// Returns the staked balance of the given account.
    /// NOTE: This is computed from the amount of "stake" shares the given account has and the
    /// current amount of total staked balance and total stake shares on the account.
    pub fn get_account_staked_balance(&self, account_id: AccountId) -> u128 {
        self.get_account(account_id).staked_balance
    }

    /// current numbers of tickets on the account
    pub fn get_account_tickets_amount(&self, account_id: AccountId) -> u64 {
        self.get_account(account_id).tickets_amount
    }

    /// Returns the total balance of the given account (including staked and unstaked balances).
    pub fn get_account_total_balance(&self, account_id: AccountId) -> u128 {
        let account = self.get_account(account_id);
        (account.unstaked_balance + account.staked_balance).into()
    }

    /// Returns `true` if the given account can withdraw tokens in the current epoch.
    pub fn is_account_unstaked_balance_available(&self, account_id: AccountId) -> bool {
        self.get_account(account_id).can_withdraw
    }

    pub fn on_stake_action(&mut self) {
        assert_eq!(
            env::current_account_id(),
            env::predecessor_account_id(),
            "Can be called only as a callback"
        );

        assert_eq!(
            env::promise_results_count(),
            1,
            "Contract expected a result on the callback"
        );
        let stake_action_succeeded = match env::promise_result(0) {
            PromiseResult::Successful(_) => true,
            _ => false,
        };

        // If the stake action failed and the current locked amount is positive, then the contract
        // has to unstake.
        if !stake_action_succeeded && env::account_locked_balance() > 0 {
            Promise::new(env::current_account_id()).stake(0, self.stake_public_key.clone());
        }
    }
}

/// exposed to support simulation testing
#[near_bindgen]
impl StakingPool {
    pub fn update_account(&mut self, account: StakingPoolAccount) {
    }
}

impl StakingPool {
    fn save_account(&mut self, account: &StakingPoolAccount) {
        self.accounts.insert(&account.account_id, account);
    }
}

/// Interface for the contract itself.
#[ext_contract(ext_self)]
pub trait SelfContract {
    /// A callback to check the result of the staking action.
    /// In case the stake amount is less than the minimum staking threshold, the staking action
    /// fails, and the stake amount is not changed. This might lead to inconsistent state and the
    /// follow withdraw calls might fail. To mitigate this, the contract will issue a new unstaking
    /// action in case of the failure of the first staking action.
    fn on_stake_action(&mut self);
    fn nft_valid_callback(&self) -> bool;
    fn nft_transfer_callback(&mut self, token_id: TokenId) -> bool;
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct StakingPoolAccount {
    pub account_id: AccountId,
    /// The unstaked balance that can be withdrawn or staked.
    pub unstaked_balance: Balance,
    /// The amount balance staked at the current "stake" share price.
    pub staked_balance: Balance,
    /// The amount of shares
    pub stake_shares: Balance,
    /// Updated when stake/unstake actions happen, used for reward
    pub stake_points: u64,
    /// The amount of tickets
    pub tickets_amount: u64,
    /// Bonus multiplier by using special NFT
    pub tickets_multiplier: u64,
    /// Whether the unstaked balance is available for withdrawal now.
    pub can_withdraw: bool,
    pub unstaked_available_epoch_height: EpochHeight,
}

impl StakingPoolAccount {
    pub fn new(account_id: &str) -> Self {
        StakingPoolAccount {
            account_id: account_id.to_string(),
            unstaked_balance: 0,
            staked_balance: 0,
            stake_shares: 0,
            stake_points: 0,
            tickets_multiplier: 1,
            tickets_amount: 0,
            can_withdraw: false,
            unstaked_available_epoch_height: 0
        }
    }
}

#[cfg(test)]
mod tests {
    use std::convert::TryFrom;

    use near_sdk::{serde_json, testing_env, MockedBlockchain, VMContext};

    use crate::test_utils::*;

    use super::*;

    struct Emulator {
        pub contract: StakingPool,
        pub epoch_height: EpochHeight,
        pub amount: Balance,
        pub locked_amount: Balance,
        last_total_staked_balance: Balance,
        last_total_stake_shares: Balance,
        context: VMContext,
    }

    impl Emulator {
        pub fn new(
            owner: String,
            stake_public_key: String,
        ) -> Self {
            let context = VMContextBuilder::new()
                .current_account_id(owner.clone())
                .account_balance(ntoy(30))
                .finish();
            testing_env!(context.clone());
            let contract = StakingPool::new(
                owner,
                Base58PublicKey::try_from(stake_public_key).unwrap(),
            );
            let last_total_staked_balance = contract.total_staked_balance;
            let last_total_stake_shares = contract.total_stake_shares;
            Emulator {
                contract,
                epoch_height: 0,
                amount: ntoy(30),
                locked_amount: 0,
                last_total_staked_balance,
                last_total_stake_shares,
                context,
            }
        }

        fn verify_stake_price_increase_guarantee(&mut self) {
            let total_staked_balance = self.contract.total_staked_balance;
            let total_stake_shares = self.contract.total_stake_shares;

            assert!(
                U256::from(total_staked_balance) * U256::from(self.last_total_stake_shares)
                    >= U256::from(self.last_total_staked_balance) * U256::from(total_stake_shares),
                "Price increase guarantee was violated."
            );
            self.last_total_staked_balance = total_staked_balance;
            self.last_total_stake_shares = total_stake_shares;

        }

        pub fn update_context(&mut self, predecessor_account_id: String, deposit: Balance) {
            self.verify_stake_price_increase_guarantee();
            self.context = VMContextBuilder::new()
                .current_account_id(staking())
                .predecessor_account_id(predecessor_account_id.clone())
                .signer_account_id(predecessor_account_id)
                .attached_deposit(deposit)
                .account_balance(self.amount)
                .account_locked_balance(self.locked_amount)
                .epoch_height(self.epoch_height)
                .finish();
            testing_env!(self.context.clone());
            println!(
                "Epoch: {}, Deposit: {}, amount: {}, locked_amount: {}",
                self.epoch_height, deposit, self.amount, self.locked_amount
            );
        }

        pub fn simulate_stake_call(&mut self) {
            let total_stake = self.contract.total_staked_balance;
            // Stake action
            self.amount = self.amount + self.locked_amount - total_stake;
            self.locked_amount = total_stake;
            // Second function call action
            self.update_context(staking(), 0);
        }

        pub fn skip_epochs(&mut self, num: EpochHeight) {
            self.epoch_height += num;
            self.locked_amount = (self.locked_amount * (100 + u128::from(num))) / 100;
        }
    }

    #[test]
    fn test_restake_fail() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            // zero_fee(),
        );
        emulator.update_context(bob(), 0);
        emulator.contract.internal_restake();
        // let receipts = env::created_receipts();
        // assert_eq!(receipts.len(), 2);
        // // Mocked Receipt fields are private, so can't check directly.
        // assert!(serde_json::to_string(&receipts[0])
        //     .unwrap()
        //     .contains("\"actions\":[{\"Stake\":{\"stake\":29999999999999000000000000,"));
        // assert!(serde_json::to_string(&receipts[1])
        //     .unwrap()
        //     .contains("\"method_name\":\"on_stake_action\""));
        emulator.simulate_stake_call();

        emulator.update_context(staking(), 0);
        testing_env_with_promise_results(emulator.context.clone(), PromiseResult::Failed);
        emulator.contract.on_stake_action();
        // let receipts = env::created_receipts();
        // assert_eq!(receipts.len(), 1);
        // assert!(serde_json::to_string(&receipts[0])
        //     .unwrap()
        //     .contains("\"actions\":[{\"Stake\":{\"stake\":0,"));
    }

    #[test]
    fn test_stake_unstake() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string(),
            // zero_fee(),
        );
        let deposit_amount = ntoy(10_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);
        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_staked_balance(bob()),
            deposit_amount
        );
        let locked_amount = emulator.locked_amount;
        // 10 epochs later, unstake half of the money.
        emulator.skip_epochs(10);
        // Overriding rewards
        emulator.locked_amount = locked_amount + ntoy(10);
        emulator.update_context(bob(), 0);
        emulator.contract.ping();
        println!("Total Stake shares: {}", emulator.contract.total_stake_shares);
        println!("Total Stake Balance: {}", emulator.contract.total_staked_balance);
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()),
            deposit_amount + ntoy(10)
        );
        emulator.contract.unstake((deposit_amount / 2).into());
        emulator.simulate_stake_call();
        assert_eq_in_near!(
            emulator.contract.get_account_staked_balance(bob()),
            deposit_amount / 2 + ntoy(10)
        );
        assert_eq_in_near!(
            emulator.contract.get_account_unstaked_balance(bob()),
            deposit_amount / 2
        );
        let acc = emulator.contract.get_account(bob());
        assert_eq!(acc.account_id, bob());
        assert_eq_in_near!(acc.unstaked_balance, deposit_amount / 2);
        assert_eq_in_near!(acc.staked_balance, deposit_amount / 2 + ntoy(10));
        assert!(!acc.can_withdraw);

        assert!(!emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
        emulator.skip_epochs(4);
        emulator.update_context(bob(), 0);
        assert!(emulator
            .contract
            .is_account_unstaked_balance_available(bob()),);
    }

    #[test]
    fn test_add_remove_tickets() {
        let mut emulator = Emulator::new(owner(), "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_owned());

        let deposit_amount = ntoy(1_000);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);

        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_tickets_amount(bob()),
            1_00
        );

        emulator.skip_epochs(4);
        emulator.update_context(bob(), 0);

        emulator.contract.unstake((deposit_amount / 2).into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_tickets_amount(bob()),
            50
        );
    }

    #[test]
    fn test_winner_announcement() {
        let mut emulator = Emulator::new(owner(), "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_owned());

        let deposit_amount = ntoy(1_00);
        emulator.update_context(bob(), deposit_amount);
        emulator.contract.deposit();
        emulator.amount += deposit_amount;
        emulator.update_context(bob(), 0);

        emulator.contract.stake(deposit_amount.into());
        emulator.simulate_stake_call();
        assert_eq!(
            emulator.contract.get_account_tickets_amount(bob()),
            10
        );

        emulator.skip_epochs(14);
        emulator.update_context(bob(), 0);

        let winner = emulator.contract.get_prize_winner();
        assert_eq!(winner, bob());

        let contract_balance = emulator.amount;
        let reward = emulator.contract.total_reward;
        let promise = emulator.contract.transfer_prize_to_winner(winner);

        emulator.update_context(bob(), 0);

        println!("{}", emulator.contract.total_staked_balance);
        assert_eq!(emulator.amount, contract_balance - reward);
    }

    // #[test]
    fn test_rewards() {
        let mut emulator = Emulator::new(
            owner(),
            "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7".to_string()
        );
        let initial_balance = ntoy(100);
        emulator.update_context(alice(), initial_balance);
        emulator.contract.deposit();
        emulator.amount += initial_balance;
        let mut remaining = 100;
        let mut amount = 1;
        while remaining >= 4 {
            emulator.skip_epochs(3);
            emulator.update_context(alice(), 0);
            emulator.contract.ping();
            emulator.update_context(alice(), 0);
            amount = 2 + (amount - 1) % 3;
            emulator.contract.stake(ntoy(amount).into());
            emulator.simulate_stake_call();
            remaining -= amount;
        }
    }
}

'''
'''--- cherry-pool/src/test_utils.rs ---
use near_sdk::{AccountId, MockedBlockchain, PromiseResult, VMContext};
use near_sdk::{Balance, BlockHeight, EpochHeight};

pub fn staking() -> AccountId {
    "staking".to_string()
}

pub fn alice() -> AccountId {
    "alice".to_string()
}
pub fn bob() -> AccountId {
    "bob".to_string()
}
pub fn owner() -> AccountId {
    "owner".to_string()
}

pub fn ntoy(near_amount: Balance) -> Balance {
    near_amount * 10u128.pow(24)
}

/// Rounds to nearest
pub fn yton(yocto_amount: Balance) -> Balance {
    (yocto_amount + (5 * 10u128.pow(23))) / 10u128.pow(24)
}

#[macro_export]
macro_rules! assert_eq_in_near {
    ($a:expr, $b:expr) => {
        assert_eq!(yton($a), yton($b))
    };
    ($a:expr, $b:expr, $c:expr) => {
        assert_eq!(yton($a), yton($b), $c)
    };
}

pub struct VMContextBuilder {
    context: VMContext,
}

impl VMContextBuilder {
    pub fn new() -> Self {
        Self {
            context: VMContext {
                current_account_id: "".to_string(),
                signer_account_id: "".to_string(),
                signer_account_pk: vec![0, 1, 2],
                predecessor_account_id: "".to_string(),
                input: vec![],
                epoch_height: 0,
                block_index: 0,
                block_timestamp: 0,
                account_balance: 0,
                account_locked_balance: 0,
                storage_usage: 10u64.pow(6),
                attached_deposit: 0,
                prepaid_gas: 10u64.pow(18),
                random_seed: vec![0, 1, 2],
                is_view: false,
                output_data_receivers: vec![],
            },
        }
    }

    pub fn current_account_id(mut self, account_id: AccountId) -> Self {
        self.context.current_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn signer_account_id(mut self, account_id: AccountId) -> Self {
        self.context.signer_account_id = account_id;
        self
    }

    pub fn predecessor_account_id(mut self, account_id: AccountId) -> Self {
        self.context.predecessor_account_id = account_id;
        self
    }

    #[allow(dead_code)]
    pub fn block_index(mut self, block_index: BlockHeight) -> Self {
        self.context.block_index = block_index;
        self
    }

    pub fn epoch_height(mut self, epoch_height: EpochHeight) -> Self {
        self.context.epoch_height = epoch_height;
        self
    }

    pub fn attached_deposit(mut self, amount: Balance) -> Self {
        self.context.attached_deposit = amount;
        self
    }

    pub fn account_balance(mut self, amount: Balance) -> Self {
        self.context.account_balance = amount;
        self
    }

    pub fn account_locked_balance(mut self, amount: Balance) -> Self {
        self.context.account_locked_balance = amount;
        self
    }

    pub fn finish(self) -> VMContext {
        self.context
    }
}

pub fn testing_env_with_promise_results(context: VMContext, promise_result: PromiseResult) {
    let storage = near_sdk::env::take_blockchain_interface()
        .unwrap()
        .as_mut_mocked_blockchain()
        .unwrap()
        .take_storage();

    near_sdk::env::set_blockchain_interface(Box::new(MockedBlockchain::new(
        context,
        Default::default(),
        Default::default(),
        vec![promise_result],
        storage,
        Default::default(),
        Default::default(),
    )));
}

'''
'''--- nft/Cargo.toml ---
[package]
name = "cherry-pub-nft"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html
[lib]
crate-type = ["cdylib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.1"
'''
'''--- nft/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/cherry-pub-nft.wasm ./res/
'''
'''--- nft/src/lib.rs ---
/*!
Non-Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::*;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{
    env, near_bindgen, wee_alloc, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue, Gas
};

#[global_allocator]
static ALLOC: wee_alloc::WeeAlloc = wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";
const GAS_FOR_NFT_MINT: Gas = 25_000_000_000_000; 

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Cherry Pub Collection".to_string(),
                symbol: "CHEPU".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: ValidAccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    /// Mint a new token with ID=`token_id` belonging to `receiver_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: ValidAccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens.mint(token_id, receiver_id, Some(token_metadata))
    }

    pub fn owner_mint_collection(&mut self) -> u64 {
        assert_eq!(env::predecessor_account_id(), self.tokens.owner_id, "Only owner can mint collection");
        
        let mut i: u64 = 1;

        let lengend_edition_metadata = TokenMetadata {
            title: Some("Cherry Wine".into()),
            description: Some("a very-old wine glass made from sweet cherries".into()),
            media: Some("https://bafkreibdx7v3i2hgb7yy2qljzpuvp54pnj4bti6w44thqu6jsaxxwz6ncy.ipfs.nftstorage.link/".into()),
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None
        };
        while i <= 1 {
            self.nft_mint(i.to_string(), ValidAccountId::try_from(self.tokens.owner_id.clone()).unwrap(), lengend_edition_metadata.clone());
            i = i + 1;
        }

        let rare_edition_metadata = TokenMetadata {
            title: Some("Cherry Cocktail".into()),
            description: Some("a yummy cocktail made from fresh cherries".into()),
            media: Some("https://bafkreic76dlg7our5p7d3pe5ablvkacfqgr3otk7n4qwl7cx6sjdij6vgi.ipfs.nftstorage.link/".into()),
            media_hash: None,
            copies: Some(9u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None
        };
        while i > 1 && i <= 10 {
            self.nft_mint(i.to_string(), ValidAccountId::try_from(self.tokens.owner_id.clone()).unwrap(), rare_edition_metadata.clone());
            i = i + 1;
        }

        let common_edition_metadata = TokenMetadata {
            title: Some("Cherry Cake".into()),
            description: Some("A delicious cake".into()),
            media: Some("https://bafkreick2df2lyge67dxvb7nw5uajybtnvru46vg3hdewxoswd72oledji.ipfs.nftstorage.link/".into()),
            media_hash: None,
            copies: Some(40u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None
        };
        while i > 10 && i <= 50 {
            self.nft_mint(i.to_string(), ValidAccountId::try_from(self.tokens.owner_id.clone()).unwrap(), common_edition_metadata.clone());
            i = i + 1;
        }

        i
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, MockedBlockchain};

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Cherry Wine".into()),
            description: Some("a very-old wine glass made from sweet cherries".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn legend_edition_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Cherry Wine".into()),
            description: Some("a very-old wine glass made from sweet cherries".into()),
            media: Some("https://bafkreibdx7v3i2hgb7yy2qljzpuvp54pnj4bti6w44thqu6jsaxxwz6ncy.ipfs.nftstorage.link/".into()),
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn rare_edition_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Cherry Cocktail".into()),
            description: Some("a yummy cocktail made from fresh cherries".into()),
            media: Some("https://bafkreic76dlg7our5p7d3pe5ablvkacfqgr3otk7n4qwl7cx6sjdij6vgi.ipfs.nftstorage.link/".into()),
            media_hash: None,
            copies: Some(9u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn common_edition_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Cherry Cake".into()),
            description: Some("A delicious cake".into()),
            media: Some("https://bafkreick2df2lyge67dxvb7nw5uajybtnvru46vg3hdewxoswd72oledji.ipfs.nftstorage.link/".into()),
            media_hash: None,
            copies: Some(40u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint_entire_collection() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(1));

        testing_env!(
            context
            .account_balance(10u128.pow(24) * 100)
            .attached_deposit(MINT_STORAGE_COST * 50)
            .prepaid_gas(GAS_FOR_NFT_MINT * 10)
            .storage_usage(env::storage_usage())
            .predecessor_account_id(accounts(1))
            .build()
        );

        contract.owner_mint_collection();

        let supplies = contract.nft_total_supply();
        assert_eq!(supplies, U128::from(50));
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(1));

        testing_env!(
            context
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(1))
            .build()
        );

        let nft = contract.nft_mint("1".to_owned(), accounts(1), sample_token_metadata());
        assert_eq!(nft.owner_id, accounts(1).to_string());
        assert_eq!(nft.token_id, "1".to_owned());
        assert_eq!(nft.metadata.unwrap(), sample_token_metadata());
        assert_eq!(nft.approved_account_ids.unwrap(), HashMap::new());

    }

    #[test]
    #[should_panic(expected = "token_id must be unique")]
    fn test_mint_unique() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());

        let mut contract = Contract::new_default_meta(accounts(0));

        testing_env!(
            context
            .predecessor_account_id(accounts(0))
            .attached_deposit(MINT_STORAGE_COST * 2)
            .build()
        );

        let token_minted_1 = contract.nft_mint("0".to_owned(), accounts(0), sample_token_metadata());
        let token_minted_2 = contract.nft_mint("0".to_owned(), accounts(1), sample_token_metadata());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(
            context
            .predecessor_account_id(accounts(0))
            .attached_deposit(MINT_STORAGE_COST)
            .build()
        );

        let mut contract = Contract::new_default_meta(accounts(0));
        let token_minted = contract.nft_mint("0".to_owned(), accounts(0), sample_token_metadata());

        testing_env!(
            context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build()
        );
        contract.nft_transfer(accounts(1), token_minted.token_id, None, None);

        let token_transfered = contract.nft_token("0".to_owned()).unwrap();
        assert_eq!(token_transfered.owner_id, accounts(1).to_string());
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));

        testing_env!(
            context
            .predecessor_account_id(accounts(0))
            .attached_deposit(MINT_STORAGE_COST)
            .build()
        );

        let mut contract = Contract::new_default_meta(accounts(0));
        let token_id = contract.nft_mint("0".to_owned(), accounts(0), sample_token_metadata());

        contract.nft_approve(token_id.token_id, accounts(1), None);
        assert!(contract.nft_is_approved("0".to_owned(), accounts(1), None));
    }

    // #[test]
    // fn test_reject() {
    //     let mut context = get_context(accounts(0));
    //     testing_env!(
    //         context
    //         .predecessor_account_id(accounts(0))
    //         .attached_deposit(MINT_STORAGE_COST)
    //         .build()
    //     );

    //     let mut contract = Contract::new_default_meta(accounts(0));
    //     let token_minted = contract.nft_mint("0".to_owned(), accounts(0), sample_token_metadata());

    //     testing_env!(
    //         context
    //         .predecessor_account_id(accounts(0))
    //         .attached_deposit(10u128.pow(24))
    //         .build()
    //     );

    //     contract.nft_approve(token_minted.token_id, accounts(1), None);

    //     testing_env!(
    //         context
    //         .predecessor_account_id(accounts(0))
    //         .attached_deposit(1)
    //         .build()
    //     );
    //     contract.nft_transfer(accounts(2), "0".to_owned(), Some(1), None);
    //     contract.nft_revoke("0".to_owned(), accounts(1));
    // }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(
            context
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build()
        );

        let mut contract = Contract::new_default_meta(accounts(0));
        let token_minted = contract.nft_mint("0".to_owned(), accounts(0), sample_token_metadata());

        testing_env!(
            context
            .predecessor_account_id(accounts(0))
            .attached_deposit(10u128.pow(24))
            .build()
        );

        contract.nft_approve(token_minted.token_id, accounts(1), None);

        testing_env!(
            context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build()
        );
        contract.nft_revoke("0".to_owned(), accounts(1));

        assert!(!contract.nft_is_approved("0".to_owned(), accounts(1), None));

    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(
            context
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build()
        );

        let mut contract = Contract::new_default_meta(accounts(0));
        let token_minted = contract.nft_mint("0".to_owned(), accounts(0), sample_token_metadata());

        testing_env!(
            context
            .predecessor_account_id(accounts(0))
            .attached_deposit(10u128.pow(24))
            .build()
        );

        contract.nft_approve(token_minted.clone().token_id, accounts(1), None);
        contract.nft_approve(token_minted.clone().token_id, accounts(2), None);

        testing_env!(
            context
            .predecessor_account_id(accounts(0))
            .attached_deposit(1)
            .build()
        );
        contract.nft_revoke_all("0".to_owned());

        let token = contract.nft_token("0".to_owned()).unwrap();
        
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }
}

'''
'''--- simulation/Cargo.toml ---
[package]
name = "simulation"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "3.1.0"
near-sdk-sim = "3.2.0"
'''
'''--- simulation/src/lib.rs ---
#![allow(dead_code, unused_variables)]
mod local;
mod remote;
pub use local::*;
pub use remote::*;

#[cfg(test)]
mod test {
    use near_sdk_sim::{call, deploy, init_simulator, ContractAccount, UserAccount};
    use super::*;

    // Load in contract bytes
    near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
        // update `contract.wasm` for your contract's name
        LOCAL_WASM_BYTES => "../target/wasm32-unknown-unknown/release/cherry_pool.wasm",
    
        // if you run `cargo build` without `--release` flag:
        REMOTE_WASM_BYTES => "../target/wasm32-unknown-unknown/release/cherry_pub_nft.wasm",
    }

    // init simulated environment
    fn init() -> (
        UserAccount,
        ContractAccount<LocalContract>,
        ContractAccount<RemoteContract>,
    ) {
        // init simulator returns the master account of the simulated environment
        let master_account = init_simulator(None);
        // create account and deploy contract code for LocalContract
        // uses default values for deposit and gas
        let local_contract = deploy!(
            // Contract Proxy
            contract: LocalContract,
            // Contract account id
            contract_id: "local",
            // Bytes of contract
            bytes: &LOCAL_WASM_BYTES,
            // User deploying the contract,
            signer_account: master_account
        );
        // create account and deploy contract code for RemoteContract
        let remote_contract = deploy!(
            // Contract Proxy
            contract: RemoteContract,
            // Contract account id
            contract_id: "remote",
            // Bytes of contract
            bytes: &REMOTE_WASM_BYTES,
            // User deploying the contract,
            signer_account: master_account
        );

        return (master_account, local_contract, remote_contract);
    }

    #[test]
    fn high_level_function_call() {
        let (master_account, local, _remote) = init();
        // simulate a user signing a transaction calling local.xcc
        let res = call!(
            master_account,
            local.xcc("high_fc", "remote", "do_some_work")
        );

        res.assert_success();

        // the result returned by local.xcc
        println!(
            "{:#?}\n{:#?}\n{:#?}\n",
            res,
            res.promise_results(),
            res.unwrap_json::<String>()
        );
    }

    #[test]
    fn high_level_batch_action() {
        let (master_account, local, _remote) = init();
        // simulate a user signing a transaction calling local.xcc
        let res = call!(
            master_account,
            local.xcc("high_ba", "remote", "do_some_work")
        );

        res.assert_success();

        // the result returned by local.xcc
        println!(
            "{:#?}\n{:#?}\n{:#?}\n",
            res,
            res.promise_results(),
            res.unwrap_json::<String>()
        );
    }

    #[test]
    fn low_level_function_call() {
        let (master_account, local, _remote) = init();
        // simulate a user signing a transaction calling local.xcc
        let res = call!(
            master_account,
            local.xcc("low_fc", "remote", "do_some_work")
        );

        res.assert_success();

        // the result returned by local.xcc
        println!(
            "{:#?}\n{:#?}\n{:#?}\n",
            res,
            res.promise_results(),
            res.unwrap_json::<String>()
        );
    }

    #[test]
    fn low_level_batch_action() {
        let (master_account, local, _remote) = init();
        // simulate a user signing a transaction calling local.xcc
        let res = call!(
            master_account,
            local.xcc("low_ba", "remote", "do_some_work")
        );

        res.assert_success();

        // the result returned by local.xcc
        println!(
            "{:#?}\n{:#?}\n{:#?}\n",
            res,
            res.promise_results(),
            res.unwrap_json::<String>()
        );
    }
}
'''
'''--- simulation/src/local.rs ---
use near_sdk::{near_bindgen, Promise};
#[allow(dead_code)]
#[near_bindgen]
pub struct Local {
}

#[near_bindgen]
impl Local {
  #[allow(unused_variables, dead_code)]
  pub fn xcc(level: &str, account: &str, method: &str){
  }
}
'''
'''--- simulation/src/remote.rs ---
use near_sdk::near_bindgen;

#[near_bindgen]
pub struct Remote {}

#[near_bindgen]
impl Remote {
  fn do_some_work() {}
}
'''