*GitHub Repository "keypom/keypom-app"*

'''--- README.md ---
# React 17, Parcel with useContext and useReducer
- Bundled with Parcel 2.0.1
- *Minimal all-in-one state management with async/await support*

## Getting Started: State Store & useContext

>The following steps are already done, but describe how to use `src/utils/state` to create and use your own `store` and `StateProvider`.

1. Create a file e.g. `/state/app.js` and add the following code
```js
import { State } from '../utils/state';

// example
const initialState = {
	app: {
		mounted: false
	}
};

export const { store, Provider } = State(initialState);
```
2. Now in your `index.js` wrap your `App` component with the `StateProvider`
```js
import { Provider } from './state/app';

ReactDOM.render(
    <Provider>
        <App />
    </Provider>,
    document.getElementById('root')
);
```
3. Finally in `App.js` you can `useContext(store)`
```js
const { state, dispatch, update } = useContext(store);
```

## Usage in Components
### Print out state values
```js
<p>Hello {state.foo && state.foo.bar.hello}</p>
```
### Update state directly in component functions
```js
const handleClick = () => {
    update('clicked', !state.clicked);
};
```
### Dispatch a state update function (action listener)
```js
const onMount = () => {
    dispatch(onAppMount('world'));
};
useEffect(onMount, []);
```
## Dispatched Functions with context (update, getState, dispatch)

When a function is called using dispatch, it expects arguments passed in to the outer function and the inner function returned to be async with the following json args: `{ update, getState, dispatch }`

Example of a call:
```js
dispatch(onAppMount('world'));
```

All dispatched methods **and** update calls are async and can be awaited. It also doesn't matter what file/module the functions are in, since the json args provide all the context needed for updates to state.

For example:
```js
import { helloWorld } from './hello';

export const onAppMount = (message) => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
	update('clicked', false);
	update('data', { mounted: true });
	await update('', { data: { mounted: false } });

	console.log('getState', getState());

	update('foo.bar', { hello: true });
	update('foo.bar', { hello: false, goodbye: true });
	update('foo', { bar: { hello: true, goodbye: false } });
	update('foo.bar.goodbye', true);

	await new Promise((resolve) => setTimeout(() => {
		console.log('getState', getState());
		resolve();
	}, 2000));

	dispatch(helloWorld(message));
};
```
## Prefixing store and Provider

The default names the `State` factory method returns are `store` and `Provider`. However, if you want multiple stores and provider contexts you can pass an additional `prefix` argument to disambiguate.

```js
export const { appStore, AppProvider } = State(initialState, 'app');
```

## Performance and memo

The updating of a single store, even several levels down, is quite quick. If you're worried about components re-rendering, use `memo`:
```js
import React, { memo } from 'react';

const HelloMessage = memo(({ message }) => {
	console.log('rendered message');
	return <p>Hello { message }</p>;
});

export default HelloMessage;
```
Higher up the component hierarchy you might have:
```js
const App = () => {
	const { state, dispatch, update } = useContext(appStore);
    ...
	const handleClick = () => {
		update('clicked', !state.clicked);
	};

	return (
		<div className="root">
			<HelloMessage message={state.foo && state.foo.bar.hello} />
			<p>clicked: {JSON.stringify(state.clicked)}</p>
			<button className="outline" onClick={handleClick}>Click Me</button>
		</div>
	);
};
```
When the button is clicked, the component HelloMessage will not re-render, it's value has been memoized (cached). Using this method you can easily prevent performance intensive state updates in further down components until they are neccessary.

Reference:
- https://reactjs.org/docs/context.html
- https://dmitripavlutin.com/use-react-memo-wisely/

'''
'''--- package.json ---
{
	"name": "react-parcel-boilerplate",
	"version": "1.0.0",
	"description": "React Parcel Boilerplate",
	"author": "Matt Lockyer",
	"license": "ISC",
	"dependencies": {
		"@near-wallet-selector/core": "v7.2.1",
		"@near-wallet-selector/modal-ui": "^7.2.1",
		"@near-wallet-selector/my-near-wallet": "^7.2.1",
		"@near-wallet-selector/near-wallet": "^7.2.1",
		"@near-wallet-selector/sender": "v7.2.1",
		"animejs": "^3.2.1",
		"copy-to-clipboard": "^3.3.2",
		"dirty-json": "^0.9.2",
		"keypom-js": "^0.0.14",
		"near-api-js": "^0.44.2",
		"near-seed-phrase": "^0.2.0",
		"parcel": "^2.8.0",
		"react": "^18.2.0",
		"react-dom": "^18.2.0",
		"react-feather": "^2.0.10",
		"react-qr-reader": "^3.0.0-beta-1",
		"react-router-dom": "^6.3.0"
	},
	"devDependencies": {
		"@parcel/transformer-sass": "2.8.0",
		"ava": "^4.3.0",
		"buffer": "^5.5.0",
		"crypto-browserify": "^3.12.0",
		"eslint": "^8.19.0",
		"events": "^3.3.0",
		"process": "^0.11.10",
		"rimraf": "^3.0.2",
		"stream-browserify": "^3.0.0"
	},
	"browserslist": [
		"last 2 Chrome versions"
	],
	"scripts": {
		"clean": "rm -rf dist .parcel-cache",
		"build": "yarn static && parcel build src/index.html --public-url ./ --no-cache --no-source-maps",
		"static": "rm -rf dist && mkdir dist && cp -a ./static/* ./dist",
		"start": "yarn clean && yarn static && parcel src/index.html --open",
		"start-no-open": "yarn clean && yarn static && parcel src/index.html",
		"mainnet": "yarn static && REACT_APP_NETWORK_ID=mainnet REACT_APP_CONTRACT_ID=beta.keypom.near parcel src/index.html --open",
		"fix": "eslint test/ --fix"
	}
}

'''
'''--- src/App.js ---
import React, { lazy, Suspense, useContext, useEffect, useRef } from 'react';
import {
	Routes,
	Route,
	useLocation,
	useSearchParams,
} from "react-router-dom";

import { appStore, onAppMount } from './state/app';
import { initNear } from './state/near';
/// all
import { Loading } from './components/Loading';
import { Message } from './components/Message';
/// main 
const Header = React.lazy(() => import('./components/Header'));
const Sidebar = React.lazy(() => import('./components/Sidebar'));
/// main
const Home = React.lazy(() => import('./components/Home'));
const Account = React.lazy(() => import('./components/Account'));
const Drops = React.lazy(() => import('./components/Drops'));
const Create = React.lazy(() => import('./components/Create'));
const Contracts = React.lazy(() => import('./components/Contracts'));
const Deploy = React.lazy(() => import('./components/Deploy'));
/// alt
const Claim = React.lazy(() => import('./components/Claim'));
const Ticket = React.lazy(() => import('./components/Ticket'));
const Scanner = React.lazy(() => import('./components/Scanner'));
const Distro = React.lazy(() => import('./components/Distro'));

// import './css/normalize.css';
// import './css/skeleton.css';
import './css/modal-ui.css';
import './App.scss';

const alt = (loading, message, path, Component, routeArgs) => {
	return <main className={path.split('/')[1]}>
		{loading && <Loading />}
		<Routes>
			<Route path={path} element={<Suspense fallback={null}>
				<Component {...routeArgs} />
			</Suspense>} />
		</Routes>
		<input type="file" id="file-btn" />
		{message && <Message {...{ message }} />}
	</main>
}

const main = (path, Component, routeArgs) => {
	return <Route path={path} element={
		<Suspense fallback={null}>
			<Component {...routeArgs} />
		</Suspense>
	} />
}

const App = () => {
	const { state, dispatch, update } = useContext(appStore);

	if (!state) return null

	const { app, wallet, contract } = state
	const { menu, loading, message } = app
	const { pathname } = useLocation();
	const [search] = useSearchParams();

	const onMount = async () => {
		if (/claim|ticket|scanner|distro/.test(pathname)) return
		await dispatch(onAppMount());
		await dispatch(initNear());
	};
	useEffect(() => {
		onMount()
	}, []);

	const routeArgs = {
		dispatch, state, update, wallet, contract
	}

	/// TODO switch to switch
	if (/claim|ticket|scanner|distro/.test(pathname)) {
		if (/claim/.test(pathname)) return alt(loading, message, "/claim/:secretKey", Claim, routeArgs)
		if (/ticket/.test(pathname)) return alt(loading, message, "/ticket/:secretKey", Ticket, routeArgs)
		if (/scanner/.test(pathname)) return alt(loading, message, "/scanner", Scanner, routeArgs)
		if (/distro/.test(pathname)) return alt(loading, message, "/distro", Distro, routeArgs)
	}

	return (
		<>
			{loading && <Loading />}
			<Suspense fallback={null}>
				<Header {...{ pathname, menu, wallet, update }} />
				{/* <Sidebar {...{ pathname, wallet, update }} /> */}
			</Suspense>
			{
				wallet.isSignedIn() ?
					/* Account Paths */
					<main>
						<Routes>
							{ main('/account', Account, routeArgs) }
							{ main('/deploy/:what', Deploy, routeArgs) }
							{ main('/deploy', Deploy, routeArgs) }
							{ main('/create', Create, routeArgs) }
							{ main('/drops', Drops, routeArgs) }
							{ main('/drops/:which', Drops, routeArgs) }
							{ main('/contracts', Contracts, routeArgs) }
							{ main('/contracts/:which', Contracts, routeArgs) }
							{ main('/', Home, routeArgs) }
						</Routes>
					</main>
					:
					/* Public Paths */
					<main>
						<Routes>
							{ main('/', Home, routeArgs)}
						</Routes>
					</main>
			}

			<input type="file" id="file-btn" />
		</>
	);
};

export default App;

 

'''
'''--- src/components/Account.js ---
import { generateSeedPhrase } from 'near-seed-phrase';
import { setAppData, getAppData } from '../state/app'
import { contractId, viewMethod } from '../state/near'
import { file } from '../utils/store'
import { parseNearAmount, formatNearAmount } from "near-api-js/lib/utils/format";
import {
	useNavigate
} from "react-router-dom";

const ImportAppData = ({ update, wallet }) => <button className="outline" onClick={() => {
	const confirm = window.confirm(`Do you want to remove all current app data and replace it? Make sure you export app data first!`)
	if (!confirm) return
	const fileBtn = document.querySelector('#file-btn')
	fileBtn.onchange = ({ target }) => {
		const reader = new FileReader()
		reader.onload = ({ target: { result } }) => {
			try {
				const json = JSON.parse(result)
				if (!json.seedPhrase) return alert(error)
				console.log(json)
				setAppData(update, json)
				wallet.update()
			} catch (e) {
				const error = `Something is wrong with your App Data, try again please!`
				return alert(error)
			}
		}
		reader.readAsText(target.files[0]);
		target.value = []
	}
	fileBtn.click()
}}>Import App Data</button>

const Account = ({ update, wallet, contract }) => {

	const navigate = useNavigate()
	if (!wallet.isSignedIn()) navigate('/')

	const appData = getAppData()
	const { balanceFormatted } = contract

	const handleAddDeposit = async () => {
		const howMuch = window.prompt('How much (in NEAR) would you like to add to your account?')
		if (parseInt(howMuch) === NaN) return

		update('app.loading', true)
		await wallet.functionCall({
			contractId,
			methodName: `add_to_balance`,
			gas: '100000000000000',
			attachedDeposit: parseNearAmount(howMuch)
		})
		await wallet.update()
		update('app.loading', false)
	}

	const handleWithdraw = async () => {
		update('app.loading', true)
		await wallet.functionCall({
			contractId,
			methodName: `withdraw_from_balance`,
			gas: '100000000000000',
		})
		await wallet.update()
		update('app.loading', false)
	}

	return <>
		<h4>{wallet.accountId}</h4>
		<button className="outline" onClick={() => {
			wallet.signOut()
			navigate('/')
		}}>Sign Out</button>

		<h4>Balance {balanceFormatted}</h4>
		<button className="outline" onClick={handleAddDeposit}>Add Deposit</button>
		<button className="outline" onClick={handleWithdraw}>Withdraw All</button>

		<h4>Key Management</h4>
		{
			appData?.seedPhrase ?
				<div>
					<button className="outline" onClick={() => {
						file(`${wallet.accountId}.keypom.json`, JSON.stringify(appData))
					}}>Export App Data</button>
					<ImportAppData {...{ update, wallet }} />
					<button className="outline" onClick={() => {
						setAppData(update, null)
					}}>Clear App Data</button>
				</div>
				:
				<div>
					<ImportAppData {...{ update, wallet }} />
					<button className="outline" onClick={() => {
						alert(`You're going to create a main key for using this app. You should keep it somewhere safe. DO NOT SHARE IT!`)
						const trySeedPhrase = () => {
							const { seedPhrase } = generateSeedPhrase()
							const words = seedPhrase.split(' ')
							window.prompt('Copy this somewhere safe!', seedPhrase)
							const wordChoice = Math.ceil(Math.random() * words.length)
							const wordPrompt = window.prompt(`What is the ${wordChoice} word?`)
							if (wordPrompt !== words[wordChoice - 1]) {
								alert('Incorrect try again')
								return trySeedPhrase()
							}
							// correct
							setAppData(update, { seedPhrase })
							alert('App Data Created')
						}
						trySeedPhrase()

					}}>Create App Data</button>
				</div>
		}
	</>

}

export default Account
'''
'''--- src/components/Blank.js ---
import { useEffect } from "react";

export const Comtracts = ({ state, update, wallet }) => {

	const { contracts } = state.app?.data
	
	const onMount = async () => {

	}
	useEffect(() => {
		onMount()
	}, [])

}
'''
'''--- src/components/Claim.js ---
import * as nearAPI from 'near-api-js';
import { useState } from 'react';
const { KeyPair } = nearAPI
import { useEffect } from "react";

import { view, call, getClaimAccount } from '../state/near'

import {
	Link, useParams,
} from "react-router-dom";

import './Claim.scss'

const Claim = ({ state, update, wallet }) => {
	const { secretKey } = useParams()

	const [keyPair, setKeyPair] = useState({})
	const [keyInfo, setKeyInfo] = useState({})
	const [isTicket, setIsTicket] = useState({})
	const [drop, setDrop] = useState({})
	
	const onMount = async () => {
		const _keyPair = KeyPair.fromString(secretKey)
		setKeyPair(_keyPair)
		console.log(_keyPair)
		let _drop, _keyInfo
		try {
			_drop = await view('get_drop_information', { key: _keyPair.publicKey.toString() })
			setDrop(_drop)
			console.log(_drop)
			_keyInfo = await view('get_key_information', { key: _keyPair.publicKey.toString() })
			setKeyInfo(_keyInfo)
			console.log(_keyInfo)
		} catch(e) {
			console.warn(e)
			setDrop(null)
			return
		}
		const { FC } = _drop.drop_type
		setIsTicket(FC?.method_data?.length === 2 && FC?.method_data[0] === null)
		

		if (_keyInfo.key_info.num_uses === 2) {
			update('app.loading', true)
			const account = await getClaimAccount(_keyPair.secretKey)
			const res = await call(wallet, 'claim', { account_id: `testnet` })
			console.log(res)
			update('app.loading', false)
		}
	}
	useEffect(() => {
		onMount()
	}, [])

	if (!drop) return <p>Not a valid drop</p>

	let metadata
	if (drop.metadata) {
		metadata = JSON.parse(drop.metadata)
	}

	console.log(metadata)

	return <>
	{ 
		metadata && <img src={metadata.media} />
	}
	<button className="outline" onClick={async () => {
		const account = await getClaimAccount(keyPair.secretKey)
		
		const res = await call(account, 'claim', { account_id: `md1.testnet` })
		console.log(res)
	}}>Claim Drop</button>
	</>

}
export default Claim
'''
'''--- src/components/Contracts.js ---
import { useState, useEffect } from "react";

import {
	Link, useParams, useSearchParams
} from "react-router-dom";
import { Form } from "./Form";
import { viewMethod, gas } from '../state/near'
import { explorerLink, addContract, removeContract, updateContract } from "../state/contracts";

import { contractBySpec } from "../state/deploy"
import { parseNearAmount } from "near-api-js/lib/utils/format";

const Contracts = ({ state, update, wallet }) => {

	const [interact, setInteract] = useState()
	const [data, setData] = useState([])
	const { contracts } = state.app?.data
	const { which } = useParams()

	const onMount = async () => {
		if (!which) return
		let contract
		try {
			const metadata = await viewMethod({ contractId: which, methodName: 'nft_metadata' })
			if (!metadata) return
			contract = contractBySpec(metadata.spec)

			if (contract.data) {
				const res = await Promise.all(Object.entries(contract.data).map(([methodName, args]) =>
					viewMethod({ contractId: which, methodName, args })
				))
				setData(res)
				console.log(res)
			}

			console.log('here')
			const series = await viewMethod({ contractId: which, methodName: 'nft_metadata' })
			if (!contract) return
		} catch (e) {
			console.warn(e)
			return
		}
		setInteract(contract.interact)
	}
	useEffect(() => {
		onMount()
	}, [which])

	if (which) {
		if (!interact) return <p>Cannot find contract by spec or interaction data</p>
		return <>
			{
				data.length > 0 && data[0].length > 0 && <>
					<h3>Data</h3>
					{
						data.map((d, i) => <div key={i}>
							<h4>Data {i}</h4>
							{
								d.map((d) => {
									console.log(d)
									return <p key={d.series_id}>{JSON.stringify(d)}</p>
								})
							}
						</div>)
					}
				</>
			}
			<h3>Methods</h3>
			{
				Object.entries(interact).map(([k, { form, valuesMap, deposit, number }]) => {

					return <div key={k}>
						<h4>{k}</h4>
						<Form {...{
							data: form,
							submit: async (values) => {

								const args = {}
								Object.entries(values).forEach(([k, v]) => {
									if (number) {
										if (number.includes(k)) v = parseInt(v)
									}

									const map = valuesMap || {}
									if (map[k]) {
										const nested = map[k].split('.')
										let obj = args[map[k]]
										while (nested.length > 1) {
											const inner = nested.shift()
											obj = args[inner] = args[inner] || {}
										}
										obj[nested[0]] = v
										return
									}
									args[k] = v
								})

								const res = await wallet.functionCall({
									contractId: which,
									methodName: k,
									args,
									attachedDeposit: deposit ? parseNearAmount(deposit) : undefined,
									gas
								})
							},
							submitLabel: `Call ${k} Method`
						}} />
					</div>
				})
			}
		</>
	}

	return <>

		{
			(!contracts || !contracts.length) ? <>
				<p>No contracts deployed</p>
			</>
				:
				<>
					<h4>Your Contracts</h4>

					{
						contracts.map((contractId) => <div key={contractId}>
							<div className="grid sm">
								<div>
									<p>{contractId}</p>
								</div>
								<div>
									<a href={explorerLink(contractId)} target="_blank" rel="noopener noreferrer">
										<button className="outline">Explorer</button>
									</a>
								</div>
								<div>
									<Link to={`/contracts/${contractId}`}><button className="outline">Interact</button></Link>
								</div>
								<div>
									<button className="outline" onClick={() => updateContract(update, contractId)}>Update</button>
								</div>
								<div>
									<button className="outline button-warning" onClick={() => removeContract(wallet, update, contractId)}>Remove</button>
								</div>
							</div>

							<div className="spacer"></div>
						</div>)

					}
				</>
		}

		<h4>Admin</h4>
		<Link to={'/deploy'}><button className="outline">Deploy a New Contract</button></Link>
		<button className="outline" onClick={() => addContract(update)}>Add Existing Contract By Account ID</button>

	</>

}

export default Contracts
'''
'''--- src/components/Create.js ---
import { parseNearAmount } from "near-api-js/lib/utils/format";
import { useEffect, useState } from "react";
import { useNavigate } from "react-router-dom";
import { genKeys } from '../state/drops'
import { call, contractId, view, viewMethod } from '../state/near'
import { Form } from "./Form";
import { hash } from "../utils/crypto"
import { createDrop } from "keypom-js";

import dJSON from 'dirty-json';

import './Create.scss'

const types = ['Simple', 'FT Drop', 'NFT Drop', 'Custom Call']
const params = ['receiver_id', 'method_name', 'args', 'attached_deposit', 'account_id_field', 'drop_id_field']
// const functionCall = {
// 	None: false,
// 	receiver_id: '',
// 	method_name: '',
// 	args: '',
// 	attached_deposit: 0,
// 	account_id_field: '',
// 	drop_id_field: '',
// }
const functionCall = {
	None: false,
	receiver_id: 'keypom-beta-nfts.testnet',
	method_name: 'nft_mint',
	args: '',
	attached_deposit: '0.015',
	account_id_field: 'receiver_id',
	drop_id_field: 'mint_id',
}

// https://testnet-api.kitwallet.app/account/md1.testnet/likelyNFTsFromBlock

const tokenMap = {
	'USDC (testnet.ref.finance)': 'usdc.fakes.testnet',
	'USDT.e (testnet.ref.finance': 'usdt.fakes.testnet',
	'DAI (testnet.ref.finance)': 'dai.fakes.testnet'
}

const Create = ({ state, update, wallet }) => {

	const { seedPhrase } = state.app?.data

	const navigate = useNavigate()

	const [type, setType] = useState('Simple')
	const [curNFT, setCurNFT] = useState()
	const [dataNFT, setDataNFT] = useState()
	const [customData, setCustomData] = useState([{
		Keys: 0,
		metadata: JSON.stringify({
			media: 'https://cloudflare-ipfs.com/ipfs/bafybeicxyjkc6feovbz63ssr46yzbq4i3pifauhr32dwenmzhis5fopwny', id: 'keypom-beta',
		}),
		password: '',
		...functionCall,
	}])

	const onMount = async () => {
		if (type !== 'NFT Drop' && !state.nfts) return
		const likelyNFTs = await fetch('https://testnet-api.kitwallet.app/account/md1.testnet/likelyNFTsFromBlock').then((r) => r.json())
		state.nfts = likelyNFTs.list
		setCurNFT(state.nfts[0])
	}

	useEffect(() => {
		onMount()
	}, [type])

	const onNFT = async () => {
		if (!curNFT) return
		try {
			const nftMetadata = await viewMethod({
				contractId: curNFT,
				methodName: 'nft_metadata'
			})
			const tokens = await viewMethod({
				contractId: curNFT,
				methodName: 'nft_tokens_for_owner',
				args: {
					account_id: wallet.accountId,
					limit: 10,
				}
			})
			setDataNFT({
				...nftMetadata,
				tokens,
				curToken: tokens[0] || null
			})
		} catch (e) {
			alert('Something wrong with the NFT contract you selected. Please try another contract.')
			console.warn(e)
		}
	}
	useEffect(() => {
		onNFT()
	}, [curNFT])

	return <>
		<h4>Create Drop</h4>

		{
			types.map((t) => <button key={t}
				className={type === t ? 'button-primary' : 'outline'}
				onClick={() => setType(t)}>
				{t}
			</button>)
		}

		{
			type === 'Simple' && <>
				<Form {...{
					data: {
						Keys: 0,
						NEAR: 0,
					},
					submit: async (values) => {
						update('app.loading', true)
						try {
							const dropId = Date.now().toString()
							const keys = await genKeys(seedPhrase, parseInt(values.Keys), dropId)

							await createDrop({
								wallet,
								dropId,
								publicKeys: keys.map(({ publicKey }) => publicKey.toString()),
								depositPerUseYocto: parseNearAmount(values.NEAR) || '1',
								hasBalance: true,
							})
						} catch (e) {
							console.warn(e)
							throw e
						} finally {
							await wallet.update()
							navigate('/drops')
							update('app.loading', false)
						}
					}
				}} />
			</>
		}

		{
			type === 'FT Drop' && <>
				<Form {...{
					data: {
						Keys: 0,
						NEAR: 0,
						'FT Contract ID': [
							'USDC (testnet.ref.finance)',
							'USDT.e (testnet.ref.finance',
							'DAI (testnet.ref.finance)'
						],
						'FT Amount': 0
					},
					submit: async (values) => {

						try {
							const dropId = Date.now().toString()
							const keys = await genKeys(seedPhrase, parseInt(values.Keys), dropId)
							const ftData = {
								contractId: tokenMap[values['FT Contract ID']],
								senderId: wallet.accountId,
								balancePerUse: values['FT Amount']
							}
							createDrop({
								wallet,
								dropId,
								publicKeys: keys.map(({ publicKey }) => publicKey.toString()),
								depositPerUseYocto: parseNearAmount(values.NEAR) || '1',
								hasBalance: true,
								ftData,
							})

						} catch (e) {
							console.warn(e)
							throw e
						} finally {
							await wallet.update()
							update('app.loading', false)
						}
					}
				}} />
			</>
		}

		{
			type === 'NFT Drop' && <>
				{
					state.nfts?.length > 0
						?
						<>
							<Form {...{
								data: {
									NEAR: 0,
									'NFT Contract ID': state.nfts,
									'NFT Token ID': dataNFT ? dataNFT.tokens.map(({ token_id }) => token_id) : ['No Tokens']
								},
								onChange: (k, newValues) => {
									switch (k) {
										case 'NFT Contract ID': setCurNFT(newValues[k]); break;
										case 'NFT Token ID': setDataNFT({
											...dataNFT,
											curToken: dataNFT.tokens.find(({ token_id }) => token_id === newValues[k])
										}); break;
									}
								},
								BeforeSubmit: () => <>
									{
										dataNFT?.curToken
											?
											<>
												<p>NFT Preview</p>
												<img className="nft-preview" src={
													/http/.test(dataNFT?.curToken.metadata.media)
														? dataNFT?.curToken.metadata.media
														: `https://cloudflare-ipfs.com/ipfs/${dataNFT?.curToken.metadata.media}`
												}
												/>
											</>
											:
											<p>You don't own any NFTs for this contract</p>
									}
								</>,
								submit: async (values) => {
									try {
										const dropId = Date.now().toString()
										const keys = await genKeys(seedPhrase, 1, dropId)
										
										const nftData = {
											contractId: values['NFT Contract ID'],
											tokenIds: [values['NFT Token ID']],
											senderId: wallet.accountId,
										}
										if (nftData.tokenIds[0] === 'No Tokens') nftData.tokenIds = [dataNFT?.curToken.token_id]

										createDrop({
											wallet,
											dropId,
											publicKeys: keys.map(({ publicKey }) => publicKey.toString()),
											depositPerUseYocto: parseNearAmount(values.NEAR) || '1',
											hasBalance: true,
											nftData,
										})
			
									} catch (e) {
										console.warn(e)
										throw e
									} finally {
										await wallet.update()
										update('app.loading', false)
									}
								}
							}} />
						</>
						:
						<>
							<p>Your account doesn't own any likely NFTs</p>
							<button>Manually Add NFT</button>
						</>
				}

			</>
		}

		{
			type === 'Custom Call' && <>
				{
					customData.map((data, i) => {
						return <div key={i}>
							<Form {...{
								data,
								onChange: (k, values) => {
									let newData = [...customData]
									newData[i][k] = values[k]
									if (k === 'None') {
										if (values[k]) {
											const newData = [...customData]
											params.forEach((p) => {
												newData[i]['__' + p] = newData[i][p]
												delete newData[i][p]
											})
										} else {
											const newData = [...customData]
											params.forEach((p) => {
												newData[i][p] = newData[i]['__' + p]
												delete newData[i]['__' + p]
											})
										}
									}
									setCustomData(newData)
								},
							}} />

							{
								i > 0 && <button className="outline" onClick={() => {
									const newData = [...customData]
									newData.splice(i, 1)
									setCustomData(newData)
								}}>Remove Call 👆</button>
							}

							<button className="outline" onClick={() => {
								const newData = [...customData]
								newData.splice(i + 1, 0, { ...functionCall })
								setCustomData(newData)
							}}>Add Call 👇</button>

						</div>
					})
				}

				<button className="button-primary" onClick={async () => {
					console.log(customData)

					const first = customData[0]
					const numKeys = parseInt(first.Keys)
					const metadata = first.metadata.length ? JSON.stringify(dJSON.parse(first.metadata)) : undefined
					const { password } = first
					delete first.Keys

					update('app.loading', true)

					let args = {
						public_keys: [],
						deposit_per_use: parseNearAmount('0.2'),
						metadata,
						config: {
							uses_per_key: customData.length,
							usage: {
								refund_deposit: true,
							}
						},
						fc: {
							methods: customData.map((data) => data.None ? null : [{
								account_id_field: data.account_id_field,
								drop_id_field: data.drop_id_field,
								receiver_id: data.receiver_id,
								method_name: data.method_name,
								args: data.args.length ? JSON.stringify(dJSON.parse(data.args)) : '',
								attached_deposit: parseNearAmount(data.attached_deposit) || '0'
							}])
						}
					}

					try {
						const res = await call(wallet, 'create_drop', args)

						const drops = await view('get_drops_for_owner', { account_id: wallet.accountId })
						drops.sort((a, b) => b.drop_id - a.drop_id)
						const { drop_id } = drops[0]

						const keys = await genKeys(seedPhrase, numKeys, drop_id)
						args = {
							drop_id,
							public_keys: keys.map(({ publicKey }) => publicKey.toString()),

							// making tickets
							passwords_per_use: password.length > 0
								? await Promise.all(keys.map(async ({ publicKey }) => ([{
									pw: await hash(await hash(password + publicKey.toString() + 1), 'hex'),
									key_use: 1
								}]))) : undefined
						}

						const res2 = await call(wallet, 'add_keys', args, '300000000000000')
						console.log(res2)

					} catch (e) {
						update('app.loading', false)
						throw e
					}
					await wallet.update()
					update('app.loading', false)

				}}>Submit</button>
			</>
		}

	</>

}

export default Create
'''
'''--- src/components/Deploy.js ---
import { useEffect } from "react";

import {
	Link, useParams, useSearchParams
} from "react-router-dom";

import { Form } from "./Form";
import { handleDeploy, checkDeploy } from '../state/deploy'

import { contracts } from "../state/deploy"
const { nftSimple, nftSeries } = contracts

const Deploy = ({ state, update, wallet }) => {

	const { seedPhrase } = state.app?.data
	const { what } = useParams()
	const [searchParams] = useSearchParams();

	const onMount = async () => {
		const { contracts } = state.app.data
		await checkDeploy({ state, update, wallet })
	}
	useEffect(() => {
		onMount()
	}, [])

	if (!seedPhrase) {
		return <>
			<p>Please set up your app data first</p>
			<Link to="/account"><button>Account</button></Link>
		</>
	}

	switch (what) {
		case 'nft-simple':
			return <div>
				<Form {...{
					data: {
						...nftSimple.form,
						...nftSimple.args,
						owner_id: wallet.accountId,
					},
					submit: async (values) => {
						update('app.loading', true)
						await handleDeploy({ seedPhrase, values })
						await checkDeploy({ state, update, wallet })
						update('app.loading', false)
					},
					submitLabel: 'Deploy',
				}} />
			</div>
			break;
		case 'nft-series':
			return <div>
				<Form {...{
					data: {
						...nftSeries.form,
						...nftSeries.args,
						owner_id: wallet.accountId,
					},
					submit: async (values) => {
						update('app.loading', true)
						await handleDeploy({ seedPhrase, values })
						await checkDeploy({ state, update, wallet })
						update('app.loading', false)
					},
					submitLabel: 'Deploy',
				}} />
			</div>
			break;
		default:
			return <div>
				<Link to="/deploy/nft-simple"><button className="outline">Deploy NFT Simple</button></Link>
				<Link to="/deploy/nft-series"><button className="outline">Deploy NFT Series</button></Link>
			</div>
	}
}

export default Deploy
'''
'''--- src/components/Distro.js ---
import { useEffect, useState } from "react";
import * as nearAPI from 'near-api-js';
const { KeyPair } = nearAPI
import { get, set, del } from '../utils/store'
import { popMessage } from '../state/app'
import { view, networkId } from '../state/near'
import { share } from '../utils/mobile'

const LINKS = '__DISTRO_LINKS'

import './Distro.scss'

const statusLabel = [
	'available',
	'clicked',
	'attended',
	'claimed'
]

const BATCH_SIZE = 100

const checkLinks = async (update, links, cur = 0) => {
	console.log('updating links', cur, cur + BATCH_SIZE)

	const keys = links.slice(cur, cur + BATCH_SIZE).map(({ link }) => KeyPair.fromString(link.split('/ticket/')[1]).publicKey.toString())
	let keyInfo
	try {
		keyInfo = await view('get_key_information_batch', { keys })
	} catch (e) {
		console.warn(e)
		return alert('error updating keys')
	}

	// console.log(keyInfo.map(({ key_info }) => key_info.remaining_uses))

	keyInfo.forEach((info, i) => {
		i += cur
		if (!info) {
			links[i].uses = 0
			return
		}
		const { key_info } = info
		links[i].uses = key_info.remaining_uses
	})

	links.forEach((_, i) => {
		i += cur
		if (networkId !== 'testnet') return
		links[i].link = links[i].link.replace('https://', 'https://testnet.')
	})

	set(LINKS, links)
	update([...links])

	// more?
	cur += BATCH_SIZE
	if (cur < links.length) {
		return await checkLinks(update, links, cur)
	}
}

const ImportLinks = ({ links, update }) => <button className="outline" onClick={() => {
	if (links.length) {
		const confirm = window.confirm(`Do you want to remove all current tickets and replace them with the ones in the file?!`)
		if (!confirm) return
	}
	const fileBtn = document.querySelector('#file-btn')
	fileBtn.onchange = ({ target }) => {
		const reader = new FileReader()
		reader.onload = ({ target: { result } }) => {
			result = result
			.replaceAll('\r', '')
			.replace(/,|'|"|;/gi, '')
			.split('\n')
			.filter((link) => link.length > 2)
			.map((link) => ({
				uses: 3,
				link
			}))
			console.log(result)
			// TODO recursive loop to check uses
			checkLinks(update, result)
		}
		reader.readAsText(target.files[0]);
		target.value = []
	}
	fileBtn.click()
}}>Import Tickets</button>

const Distro = ({ update, dispatch }) => {

	const [links, setLinks] = useState(get(LINKS) || [])
	const [tight, setTight] = useState(false)

	const onMount = async () => {
		checkLinks(setLinks, links)
		setInterval(() => checkLinks(setLinks, get(LINKS)), 30000)
		update('app.loading', false)
	}
	useEffect(() => {
		onMount()
	}, [])

	return <div className={tight ? "tight" : ""}>
		<ImportLinks {...{ links, update: setLinks }} />
		<button className="outline" onClick={() => setTight(!tight)} style={{backgroundColor: tight? '#00ff0044' : 'white'}}>{!tight ? 'Tight View' : 'Larger View'}</button>
		<h4>Tickets</h4>

		<button className="fixed-bottom" onClick={() => window.scrollTo(0, 0)}>Top</button>

		{
			links.map(({ uses, link, shared }, i) => {
				const status = statusLabel[3 - uses]

				return <div key={link}>
					<div className="grid sm">
						<div>
							<p>{i + 1}. {link.split('/ticket/')[1].substring(0, 8)}</p>
						</div>
						<div className={uses < 3 ? 'width-100' : 'flex'}>
							{uses === 3 && <p className={shared ? 'clicked' : 'available'}>{shared ? 'shared' : 'not shared'}</p>}
							<p className={status}>{status}</p>
						</div>
						{uses > 1 && <>
						<div>
							{
								uses > 2 && <button className="outline" onClick={() => {
									if (!window.confirm(`Manually mark ticket as ${shared ? 'not shared? It looks like you shared this ticket!' : 'shared?'} Only visible to you.`)) {
										return
									}
									links[i].shared = !shared
									setLinks([...links])
									set(LINKS, links)
								}}>{shared ? 'Not Shared' : 'Mark Shared'}</button>
							}
						</div>
						<div>
							<button className="outline" onClick={() => {
								if (shared && !window.confirm('It looks like you shared this ticket! Share this ticket again?')) {
									return
								}
								if (uses !== 3 && !window.confirm('The ticket has been claimed (clicked by someone)! Share this ticket again?')) {
									return
								}

								links[i].shared = true
								setLinks([...links])
								set(LINKS, links)

								const { mobile } = share(links[i].link)
								if (!mobile) dispatch(popMessage('Ticket Link Copied'))
							}}>Share</button>
						</div>
					</>
					}
					</div>
					
					<hr />
				</div>
			})
		}

	</div>

}

export default Distro
'''
'''--- src/components/Drops.js ---
import { useEffect } from "react";
import { file } from '../utils/store'

import {
	Link, useParams, useNavigate,
} from "react-router-dom";
import { genKeys } from '../state/drops'
import { networkId, viewMethod } from '../state/near'
import { addKeys, deleteKeys } from "keypom-js";

const Drops = ({ state, update, contract, wallet }) => {

	const { seedPhrase } = state.app.data
	const { drops } = contract
	const { which } = useParams()
	const navigate = useNavigate();

	const onMount = async () => {

	}
	useEffect(() => {
		onMount()
	}, [which])

	const handleAddKeys = async (drop) => {
		update('app.loading', true)
		
		let parsedNum = 1
		/// TODO add warning about sending FTs and prompt for NFT token IDs (complicated)
		let nftTokenIds
		if (drop.nft) {
			const tokens = await viewMethod({
				contractId: drop.nft.contract_id,
				methodName: 'nft_tokens_for_owner',
				args: {
					account_id: wallet.accountId,
					limit: 10,
				}
			})
			const tokenIds = tokens.map(({ token_id }) => token_id)
			const tokenId = window.prompt(`Enter the NFT Token ID you want to add to the drop. ${tokenIds.map((id) => '\n' + id)}`)
			if (!tokenIds.includes(tokenId)) {
				alert('Not a valid Token ID that you own. Please try again.')
				return update('app.loading', false)
			}
			nftTokenIds = [tokenId]
		} else {
			const num = window.prompt(`How many keys would you like to add to the drop?`)
			parsedNum = parseInt(num)
			if (!num || isNaN(parsedNum) || parsedNum > 100 || parsedNum < 1) {
				alert('Please enter a number between 1-100')
				return update('app.loading', false)
			}
		}

		try {
			const keys = await genKeys(seedPhrase, parsedNum, drop.drop_id, drop.next_key_id)

			await addKeys({
				wallet,
				drop,
				nftTokenIds,
				publicKeys: keys.map(({ publicKey }) => publicKey.toString()),
				hasBalance: true,
			})
		} catch(e) {
			console.warn(e)
			throw e
		} finally {
			await wallet.update()
			update('app.loading', false)
		}
	}

	const handleRemoveDrop = async (drop) => {
		if (!window.confirm('Delete this drop and all keys?')) return
		update('app.loading', true)
		try {
			await deleteKeys({
				wallet,
				drop,
			})
		} catch (e) {
			throw e
		} finally {
			await wallet.update()
			navigate('/drops')
			update('app.loading', false)
		}
	}

	if (!drops?.length) return <>
		<p>No drops</p>
		<Link to={'/create'}><button className="outline">Create a Drop</button></Link>
	</>

	if (which) {
		const drop = drops.find((d) => d.drop_id === which)
		if (!drop) return <p>Can't find drop ID {which}</p>

		return <>
			<h4>Drop ID: {drop.drop_id}</h4>
			<div className="grid sm">
				<div>
					<button className="outline" onClick={() => handleAddKeys(drop)}>Add Keys</button>
				</div>
				<div>
					<button className="outline" onClick={() => handleRemoveDrop(drop)}>Remove Drop</button>
				</div>
			</div>
			{
				drop.keyPairs && <>

					<h4>Keys {drop.keySupply}</h4>
					<button className="outline" onClick={async () => {
						update('app.loading', true)
						const keys = await genKeys(seedPhrase, drop.next_key_id, drop.drop_id)
						update('app.loading', false)
						const walletUrl = `https://wallet.${networkId === 'testnet' ? `testnet.` : ``}near.org`
						const links = keys.map(({secretKey}) => `${walletUrl}/linkdrop/${contractId}/${secretKey}`)
						// const links = keys.map(({ secretKey }) => `${window.location.origin}/ticket/${secretKey}`)
						console.log('LINKS', links)
						file(`Drop ID ${drop.drop_id} Links.csv`, links.join('\r\n'))
					}}>Download All Links</button>
					{
						drop.keyPairs.map(({ publicKey, secretKey }) => <div className="key-row" key={publicKey}>
							<div className="grid sm">
								<div className="twelve columns">
									<p>{secretKey.substring(0, 32)}</p>
								</div>
								<div>
									<Link to={`/ticket/${secretKey}`} target="_blank" rel="noopener noreferrer"><button>Preview Drop</button></Link>
								</div>
								{/* <div>
									<button className="outline" onClick={async () => {
										update('app.loading', true)
										await claimDrop(wallet.accountId, secretKey)
										await wallet.update()
										update('app.loading', false)
									}}>Claim Drop</button>
								</div> */}
							</div>
						</div>)
					}

				</>
			}
		</>
	}

	return <>
		<h4>Your Drops</h4>

		{
			drops.map((drop) => {
				const { drop_id, balance, drop_type_label } = drop

				return <div key={drop_id}>
					<div className="grid sm">
						<div>
							<p>Drop ID: {drop_id}</p>
						</div>
						<div>
							<p>{drop_type_label}</p>
						</div>
						<div>
							<Link to={`/drops/${drop_id}`}>
								<button className="outline">Details</button>
							</Link>
						</div>
						<div>
							<button className="outline" onClick={() => handleRemoveDrop(drop)}>Remove Drop</button>
						</div>
					</div>
				</div>
			})
		}
		<br />
		<Link to={'/create'}><button>Create a Drop</button></Link>
	</>

}

export default Drops
'''
'''--- src/components/Form.js ---
import { useState } from 'react'

const genFields = (data, values, onChange) => {
	return Object.entries(data).map(([k, v]) => {
		if (/__/.test(k)) return null

		const input = {
			id: k,
			type: 'text',
			className: 'u-full-width',
			required: v !== '_',
			value: values[k],
			onChange: (e) => {
				onChange(k, e.target.value)
			}
		}

		// if (/password/gi.test(k)) {
		// 	input.type = 'password'
		// }

		if (typeof v === 'number') {
			input.type = 'number'
		} else if (typeof v === 'boolean') {
			input.type = 'checkbox'
			input.checked = values[k]
			input.onChange = (e) => {
				onChange(k, e.target.checked)
			}
		} else if (Array.isArray(v)) {
			if (Array.isArray(values[k])) values[k] = v[0]
			input.value = values[k]
		}
		
		return <div key={k}>
			<label htmlFor={k}>{k}</label>
			{
				Array.isArray(v)
				?
				<select {...input}>
					{
						v.map((val) => <option key={val} value={val}>{val}</option>)
					}
				</select>
				:
				v.toString().length > 64 ? 
				<textarea {...input} />
				:
				<input {...input} />

			}
		</div>
	})
}

export const Form = ({ data, onChange, submit, submitLabel, BeforeSubmit }) => {

	const [values, setValues] = useState({ ...data })
	const onValueChange = (k, v) => {
		const newValues = { ...values, [k]: v }
		setValues(newValues)
		if (onChange) onChange(k, newValues)
	}

	return <>
		<div className="row">
			{genFields(data, values, onValueChange)}
		</div>
		{ BeforeSubmit && <BeforeSubmit />}
		<br/>
		<br/>
		{ submit && <button onClick={() => submit(values)}>{ submitLabel ? submitLabel : 'Submit' }</button> }
	</>
}
'''
'''--- src/components/Header.js ---
import {
	Link
} from "react-router-dom";

import { SidebarLinks } from './SidebarLinks';
import { Menu } from 'react-feather';
import './Header.scss';

const Links = ({ update, wallet }) => {
	const hideMenu = () => update('app.menu', false)
	return <nav>
		{/* <Link onClick={hideMenu} to="/about">About</Link> */}
		{
			wallet.isSignedIn() ? <>
				<Link onClick={hideMenu} to="/">Home</Link>
				<Link onClick={hideMenu} to="/drops">Drops</Link>
				<Link onClick={hideMenu} to="/contracts">Contracts</Link>
				<Link onClick={hideMenu} to="/account">Account</Link>
			</>
			:
			<Link onClick={hideMenu} to="/">Home</Link>
		}
	</nav>
}

const Header = ({ pathname, menu, wallet, update }) => {

	const len = pathname.split('/').length

	return <header>
		<div>
			<p>
				Keypom { pathname.length > 1 ? '-' : ''}
				{
					pathname.split('/').map((str, i) => <span key={str + i}>
						{
							pathname.split('/').length === i+1
							? str.substring(0, 12) + (str.length > 12 ? '...' : '')
							: <Link to={'/' + str}>{ str }</Link>
						}
						&nbsp;
					</span>)
				}
			</p>
		</div>
		<div>
			<Menu onClick={() => update('app', { menu: !menu })} />
			<Links {...{ update, wallet }} />
		</div>
		{menu && window.innerWidth < 768 && <div className="mobile">
			<SidebarLinks {...{ pathname, update, wallet }} />
			<Links {...{ update, wallet }} />
		</div>}
	</header>
}
export default Header
'''
'''--- src/components/Home.js ---
import React from 'react'

import anime from 'animejs/lib/anime.es.js';
import Keypom from '../img/keypom-small.png'

const Home = ({ wallet }) => {

	return <div>

		<center><h2>Woof! Woof! Beta Warning</h2></center>
		<p>The Keypom App is still in active beta and things may break.</p>
		<p>The app is currently ONLY available on testnet</p>
		<div className='footer'>
			<img onClick={({ target }) => {
				anime({
					targets: target,
					duration: 0,
					scale: 1,
					complete: () => {
						anime({
							targets: target,
							scale: 4,
							easing: 'easeOutCubic',
							duration: 150,
							complete: () => {
								anime({
									targets: target,
									scale: 1,
									easing: 'easeInCubic',
									duration: 150,
								});
							}
						});
					}
				});
			}} src={Keypom} />
			<p>Keypom is lit!</p>
		</div>

		{!wallet.isSignedIn() &&

			<>
				<h2>Sign in to get started</h2>
				<button className="outline" onClick={() => wallet.signIn()}>Sign In</button>

			</>
		}

	</div>
}
export default Home
'''
'''--- src/components/Loading.js ---

import NearIcon from '../img/near-icon.svg'
import './Loading.scss'

export const Loading = () => {
	return <div className="modal-overlay">
		<img src={NearIcon} />
	</div>
}
'''
'''--- src/components/Message.js ---
export const Message = ({ message }) => {

	return <div className="message">
		<div>{message}</div>
	</div>

}
'''
'''--- src/components/Scanner.js ---
import { useEffect, useState } from "react";
import { QrReader } from 'react-qr-reader';
import * as nearAPI from 'near-api-js';
const { KeyPair } = nearAPI
import { view, call, getClaimAccount } from '../state/near'
import { get, set } from '../utils/store'
import { hash } from '../utils/crypto'

import './Scanner.scss'

const PASSWORD = '__PASSWORD'

const claim = async (secretKey) => {
	const keyPair = KeyPair.fromString(secretKey)
	const publicKey = keyPair.publicKey.toString()
	let keyInfo = await view('get_key_information', { key: publicKey })

	if (keyInfo?.remaining_uses === 1) return false
	
	const account = await getClaimAccount(keyPair.secretKey)
	const password = get(PASSWORD)
	await call(account, 'claim', {
		account_id: `testnet`,
		password: password ? await hash(password + publicKey + 1) : undefined
	})

	// fast return from scanner, tx in flight
	// if (keyInfo?.remaining_uses === 2) return true
	
	keyInfo = await view('get_key_information', { key: publicKey })
	if (keyInfo?.remaining_uses === 1) return true
	
	return false
}

const Scanner = ({ state, update }) => {

	const { loading } = state.app
	const [valid, setValid] = useState(null);

	const onMount = async () => {
		set(PASSWORD, window.prompt('Update Password for Claiming?'))

		setTimeout(() => document.body.classList.add('dark'), 10)
		update('app.loading', false)
	}
	useEffect(() => {
		onMount()
	}, [])

	return <>
		{ valid === null && !loading && <QrReader
			constraints={{ facingMode: 'environment' }}
			onResult={async (result, error) => {
				if (!!result) {
					try {
						update('app.loading', true)
						const res = await claim(result?.text)
						setValid(res)
					} catch (e) {
						setValid('Network Error. Reload Scanner. Try ticket again but please admit the attendee.')
					} finally {
						update('app.loading', false)
					}
				}
				if (!!error) {
					console.info(error);
				}
			}}
		/>}

		<div className="result">
			{
				valid === null && <p>Scan Ticket</p>
			}
			{
				valid === true && <p className="valid">Valid Ticket</p>
			}
			{
				valid === false && <p className="invalid">Invalid Ticket</p>
			}
			{
				typeof valid === 'string' && <p className="info">{ valid }</p>
			}
		</div>
		<button className="outline" onClick={() => {
			setValid(null)
		}}>Next Ticket</button>
		<br />
		<br />
		<p>If the scanner is frozen or stops working:</p>
		<button className="outline" onClick={() => {
			window.location.reload()
			window.location.href = window.location.href
		}}>Reload Scanner</button>
	</>

}

export default Scanner
'''
'''--- src/components/Sidebar.js ---
import { SidebarLinks } from './SidebarLinks';
import './Sidebar.scss'

const Sidebar = ({ pathname, update, wallet }) => {
	return <div className="sidebar">
		<SidebarLinks {...{ pathname, update, wallet }} />
	</div>
}

export default Sidebar
'''
'''--- src/components/SidebarLinks.js ---
import {
	Link,
	useNavigate
} from "react-router-dom";

export const SidebarLinks = ({ pathname, update, wallet }) => {
	const hideMenu = () => update('app.menu', false)

	const navigate = useNavigate()

	switch (pathname.substring(1)) {
		case 'account':
			return <nav>
				<Link onClick={() => {
					wallet.signOut()
					hideMenu()
					navigate('/')
				}} to="/">Sign Out</Link>
			</nav>
		break;
		case 'deploy':
			return <nav>
				<Link onClick={hideMenu} to="/deploy/nft-simple">NFT Simple</Link>
				<Link to="/deploy/nft-series">NFT Series</Link>
			</nav>
		default:
			return <nav>
				{/* <Link onClick={hideMenu} to="/">Home</Link>
				<Link onClick={hideMenu} to="/deploy">Deploy</Link>
				<Link onClick={hideMenu} to="/account">Account</Link> */}
			</nav>
	}

	
}
'''
'''--- src/components/Ticket.js ---
import { useState } from 'react';
import * as nearAPI from 'near-api-js';
const { KeyPair } = nearAPI
import { useEffect, useRef } from "react";
import { get, set, del } from '../utils/store'
import anime from 'animejs/lib/anime.es.js';
import Keypom from '../img/keypom-small.png'

import { view, call, getClaimAccount, initNear, networkId, walletUrl, contractId } from '../state/near'

import {
	useParams,
} from "react-router-dom";

import './Ticket.scss'

const DROP_AND_SECRET_KEY = '__DROP_AND_SECRET_KEY'
const CLAIMED = '__CLAIMED'
const FIRST_CLAIM_TIMEOUT = 2000
let claimTimeout = null
let claimFn = null

function openInNewTab(href) {
	Object.assign(document.createElement('a'), {
		target: '_blank',
		rel: 'noopener noreferrer',
		href: href,
	}).click();
}

function addScript(src) {
	return new Promise((resolve, reject) => {
	  const s = document.createElement('script');
  
	  s.setAttribute('src', src);
	  s.addEventListener('load', resolve);
	  s.addEventListener('error', reject);
  
	  document.body.appendChild(s);
	});
  }

const poms = () => {
	document.body.querySelector('.poms').style.display = 'block'
	const w = Math.min(500, window.innerWidth)
	const scales = [3, 4, 5, 6, 7, 8, 9, 3, 4, 5, 6, 8, 9].map((v) => v * Math.max(1, w / 100))
	anime({
		targets: '.poms > img',
		scaleX: 0,
		scaleY: 0,
		translateX: 0,
		translateY: 0,
		opacity: 1,
		duration: 0,
		complete: () => {
			anime({
				targets: '.poms > img',
				scaleX: (_, i) => scales[i],
				scaleY: (_, i) => scales[i],
				translateX: () => Math.random() * w * 2 - w * 1,
				translateY: () => Math.random() * w * 2 - w * 1,
				opacity: 0,
				rotate: '1turn',
				easing: 'easeOutQuad',
				duration: 2500,
				delay: anime.stagger(300),
				complete: () => {
					document.querySelectorAll('.poms > img').forEach((p) => p.style.display = 'none')
				}
			});
		}
	});
}

const genQR = (qr) => {
	const h = document.getElementById('media').getBoundingClientRect().height + 64

	anime({
		targets: qr.current,
		translateY: -h,
		opacity: 0,
		duration: 0,
		complete: () => {
			anime({
				targets: qr.current,
				translateY: 0,
				opacity: 1,
				easing: 'easeOutQuad',
				duration: 1000,
			});
		}
	});

	const qrEl = document.getElementById('qr')

	if (!qrEl || qrEl.children.length) return

	new QRCode(qr.current, {
		text: window.location.href.split('/ticket/')[1],
		width: 256,
		height: 256,
		colorDark: "#304",
		colorLight: "#FFF",
		correctLevel: QRCode.CorrectLevel.M
	})
}

/** 
 * 
 * TODO check the new metadata.id enforcement
 * 
 */

const Ticket = ({ dispatch, state, update, wallet }) => {

	const qr = useRef();
	const paramSecretKey = useParams().secretKey

	const [keyPair, setKeyPair] = useState({})
	const [keyInfo, setKeyInfo] = useState({})
	const [drop, setDrop] = useState({})
	const [dropId, setDropId] = useState({})
	const [claimed, setClaimed] = useState(!!get(CLAIMED))

	const onMount = async () => {
		window.addEventListener('blur', () => clearInterval(claimTimeout));
		window.addEventListener('focus', () => {
			if (claimFn) claimTimeout = setTimeout(claimFn, FIRST_CLAIM_TIMEOUT)
		});

		update('app.loading', true)
		try {

			const _keyPair = KeyPair.fromString(paramSecretKey)
			setKeyPair(_keyPair)

			const _drop = await view('get_drop_information', { key: _keyPair.publicKey.toString() })
			setDrop(_drop)

			// use metadata.id if it exists (catch all for multiple drops per event)
			let { drop_id } = _drop
			try {
				const metadata = JSON.parse(_drop.metadata)
				if (metadata.id) drop_id = metadata.id
			} catch (e) { }

			setDropId(drop_id)

			// console.log(_drop)
			const _keyInfo = await view('get_key_information', { key: _keyPair.publicKey.toString() })
			setKeyInfo(_keyInfo)

			console.log(_drop, _keyInfo)

			// console.log(_keyInfo)
			const remaining_uses = _keyInfo?.remaining_uses
			if (remaining_uses === 3) {

				try {
					claimFn = async () => {
						const keyInfoAgain = await view('get_key_information', { key: _keyPair.publicKey.toString() })
						if (keyInfoAgain.remaining_uses === 3) {
							try {
								const account = await getClaimAccount(_keyPair.secretKey)
								const res = await call(account, 'claim', { account_id: `testnet` })
								if (res?.status?.SuccessValue !== '') {
									window.location.reload()
									window.location.href = window.location.href
									return
								}
							} catch (e) {
								window.location.reload()
								window.location.href = window.location.href
								return
							}
						}
					}
					claimTimeout = setTimeout(claimFn, FIRST_CLAIM_TIMEOUT)

					poms()

					let id = _drop.drop_id
					// use metadata.id if it exists (catch all for multiple drops per event)
					try {
						console.log(_drop)
						const metadata = JSON.parse(_drop.metadata)
						if (metadata.id) id = metadata.id
					} catch (e) { }

					set(DROP_AND_SECRET_KEY, { ...get(DROP_AND_SECRET_KEY), id: paramSecretKey })
				} catch (e) {
					window.location.reload()
					window.location.href = window.location.href
				}
			}

			await addScript('https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js')
			
			setTimeout(() => {
				const container = document.querySelector('#qr-container')
				if (container) container.style.display = 'block';
				genQR(qr)
				setTimeout(() => document.querySelector('.footer').style.display = 'block', 1000)
			}, remaining_uses === 3 ? FIRST_CLAIM_TIMEOUT : 500)

		} catch (e) {
			console.warn(e)
			setDrop(null)
			return
		} finally {
			update('app.loading', false)
		}
		await dispatch(initNear(false))
	}
	useEffect(() => { onMount() }, [])

	let metadata
	if (drop?.metadata) {
		metadata = JSON.parse(drop.metadata)
	}
	const remaining_uses = keyInfo?.remaining_uses

	return <>

		<div className="poms">
			<img src={Keypom} />
			<img src={Keypom} />
			<img src={Keypom} />
			<img src={Keypom} />
			<img src={Keypom} />
			<img src={Keypom} />
			<img src={Keypom} />
			<img src={Keypom} />
			<img src={Keypom} />
			<img src={Keypom} />
		</div>

		{claimed ? <>
			<h4>NFT Claimed</h4>
			<button className="outline" onClick={() => {
				openInNewTab(`https://${networkId === 'mainnet' ? 'app' : 'testnet'}.mynearwallet.com/?tab=collectibles`)
			}}>Go to MyNearWallet</button>
		</>
			:
			<>
				{
					(!drop || !keyInfo) && <h4>Not a valid drop</h4>
				}
				{
					remaining_uses === 2 && dropId === 'nearweek-party' && <div style={{ marginTop: 32, color: 'white' }}>
						<p style={{ color: 'white' }}>Venue @ <a href="https://goo.gl/maps/1bATJSYiMJVfYAQQ8" target="_blank">Bica do Sapato</a> next to the Santa Apolonia Metro Station</p>
						<p style={{ color: 'white' }}>Look for a big light sculpture marking the main entrance.</p>
					</div>
				}
				{
					metadata && keyInfo && <img id="media" src={metadata.media} />
				}
				{
					remaining_uses === 1 && <>
						{
							wallet.isSignedIn() ?
								<button className="outline" onClick={async () => {
									update('app.loading', true)
									try {
										const account = await getClaimAccount(keyPair.secretKey)
										const res = await call(account, 'claim', { account_id: wallet.accountId })
										if (res?.status?.SuccessValue !== '') {
											window.location.reload()
											window.location.href = window.location.href
											return
										}
										poms()
										// set(CLAIMED, true)
										// setClaimed(true)
									} catch (e) {
										window.location.reload()
										window.location.href = window.location.href
										return
									} finally {
										update('app.loading', false)
									}
								}}>Claim NFT</button>
								:
								<>
									<button className="outline" onClick={() => {
										window.open(walletUrl + '/linkdrop/' + contractId + '/' + keyPair.secretKey)
									}}>Claim NFT on MyNearWallet</button>
									<button className="outline" onClick={() => wallet.signIn()}>Sign In With Another Wallet</button>
								</>
						}
					</>
				}
				{
					remaining_uses !== 1 && <div id="qr-container">
						<p>This is a DEMO Keypom ticket!</p>
						<ol>
							<li><s>Claim the ticket by clicking the link (flying Pomeranians)</s></li>
							<li>Open the scanner app on your phone <a href="">{`${window.location.origin}/scanner`}</a></li>
							<li>Scan your QR Code</li>
							<li>RELOAD THIS PAGE to claim your NEAR Wallet and NFT</li>
						</ol>
						<div id="qr" ref={qr}></div>
					</div>
				}
			</>}

		<div className="footer" style={{ display: 'none' }}>
			<img onClick={({ target }) => {
				anime({
					targets: target,
					duration: 0,
					scale: 1,
					complete: () => {
						anime({
							targets: target,
							scale: 4,
							easing: 'easeOutCubic',
							duration: 150,
							complete: () => {
								anime({
									targets: target,
									scale: 1,
									easing: 'easeInCubic',
									duration: 150,
								});
							}
						});
					}
				});
			}} src={Keypom} />
		</div>
	</>

}

export default Ticket
'''
'''--- src/css/modal-ui.css ---
@import url("https://fonts.googleapis.com/css2?family=Manrope:wght@400;500;600&display=swap");

#near-wallet-selector-modal {
  --backdrop-bg: #26262630;
  --heading-color: #222222;
  --text-color: #676767;
  --sidebar-border-color: #EDEDED;
  --selected-wallet-bg: #4F7CD1;
  --selected-wallet-bg-hover: transparent;
  --wallet-option-border-color: #A7A7A730;
  --wallet-option-bg-hover: #EDEDED;
  --content-bg: #FFFFFF;
  --change-path-bg: #EDEDED;
  --home-button-bg: #EDEDED;
  --confirm-button-bg: #5F8AFA;
  --confirm-button-bg-hover: #5AA6FF;
  --error: #DB5555;
  --close-button-bg-color: #EDEDED;
  --close-button-fill-icon-color: #9F9F9F;
  --spinner-color: #676767;
  --bottom-section: #ececec;
  --mobile-text: #3e3e3e;
  --connected-green: #47E586;
}

#near-wallet-selector-modal .dark-theme {
  --backdrop-bg: #26262630;
  --heading-color: #FFFFFF;
  --text-color: #C1C1C1;
  --sidebar-border-color: #313030;
  --selected-wallet-bg: #4F7CD1;
  --selected-wallet-bg-hover: #262626CC;
  --wallet-option-border-color: #A7A7A730;
  --wallet-option-bg-hover: #313030;
  --content-bg: #232323;
  --change-path-bg: #161616;
  --home-button-bg: #313030;
  --confirm-button-bg: #5F8AFA;
  --confirm-button-bg-hover: #5AA6FF;
  --error: #DB5555;
  --close-button-bg-color: #313030;
  --close-button-fill-icon-color: #C1C1C1;
  --spinner-color: #FFFFFF;
  --bottom-section: #131313;
  --mobile-text: #c1c1c1;
  --connected-green: #47E586;
}

@media (prefers-color-scheme: dark) {
  #near-wallet-selector-modal {
    --backdrop-bg: #26262630;
    --heading-color: #FFFFFF;
    --text-color: #C1C1C1;
    --sidebar-border-color: #313030;
    --selected-wallet-bg: #4F7CD1;
    --selected-wallet-bg-hover: #262626CC;
    --wallet-option-border-color: #A7A7A730;
    --wallet-option-bg-hover: #313030;
    --content-bg: #232323;
    --change-path-bg: #161616;
    --home-button-bg: #313030;
    --confirm-button-bg: #5F8AFA;
    --confirm-button-bg-hover: #5AA6FF;
    --error: #DB5555;
    --close-button-bg-color: #313030;
    --close-button-fill-icon-color: #C1C1C1;
    --spinner-color: #FFFFFF;
    --bottom-section: #131313;
    --mobile-text: #c1c1c1;
    --connected-green: #47E586;
  }
}

/**
 * Modal Wrapper
 */

.nws-modal-wrapper {
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  opacity: 0;
  visibility: hidden;
  /*transition: visibility 0s linear 0.25s, opacity 0.25s 0s;*/
  color: var(--wallet-selector-text-color, var(--text-color));
  font-family: Manrope, sans-serif;
  font-weight: 500;
  z-index: 100;
  display: flex;
  justify-content: center;
  align-items: center;
}

.nws-modal-wrapper .nws-modal-overlay {
  background: var(--wallet-selector-backdrop-bg, var(--backdrop-bg));
  height: 100%;
  width: 100%;
  position: absolute;
}

/**
 * Modal
 */

.nws-modal-wrapper .nws-modal {
  background: var(--wallet-selector-content-bg, var(--content-bg));
  width: 812px;
  max-width: 812px;
  height: auto;
  max-height: 70vh;
  border-radius: 16px;
  position: absolute;
  left: 50%;
  transform: translate(-50%, 0px);
  transition: visibility 0s linear 0s, opacity 0.25s 0s, transform 0.25s;
  background-color: var(--wallet-selector-content-bg, var(--content-bg));
  overflow-y: auto;
  font-size: 16px;
  line-height: 1.6;
  overflow: hidden;
  display: inline-flex;
}

.nws-modal-wrapper .nws-modal * {
  box-sizing: border-box;
}

.nws-modal-wrapper .nws-modal button {
  padding: 0.5em 1em;
  cursor: pointer;
  border: none;
}

/**
* Modal Left Side
*/

.nws-modal-wrapper .nws-modal .modal-left {
  width: 35%;
  border-right: 1px solid var(--wallet-selector-sidebar-border-color, var(--sidebar-border-color));
  padding: 32px 24px;
  height: 100%;
  max-height: 70vh;
  overflow: auto;
}

.nws-modal-wrapper .nws-modal .modal-left .modal-left-title h2 {
  margin-top: 0;
  margin-bottom: 20px;
  font-size: 18px;
  font-weight: bold;
  color: var(--wallet-selector-heading-color, var(--heading-color));
}

.nws-modal-wrapper .nws-modal .modal-left::-webkit-scrollbar {
  width: 10px;
}

/**
 * Modal Wallet Options Section/Wrapper
 */

.nws-modal-wrapper .nws-modal .wallet-options-wrapper {
  margin-bottom: 20px;
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .description {
  margin-top: 0;
  margin-bottom: 0;
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list {
  margin: 0;
  list-style-type: none;
  padding: 0;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 10px;
}

.single-wallet {
  display: flex;
  flex-wrap: nowrap;
  flex-direction: row;
  align-content: center;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  column-gap: 24px;
  padding: 12px;
  cursor: pointer;
}

.single-wallet .icon {
  height: 48px;
  width: auto;
}

.single-wallet .icon img {
  width: 100%;
  height: auto;
  max-width: 48px;
}

.single-wallet .content {
  width: 50%;
}

.single-wallet .content .name {
  font-family: inherit;
  font-style: normal;
  font-weight: 700;
  font-size: 14px;
  line-height: 24px;
  color: #FFFFFF;
}

.single-wallet .content .description {
  font-family: inherit;
  font-style: normal;
  font-weight: 700;
  font-size: 14px;
  line-height: 150%;
}

.single-wallet .button-get {
  margin-left: auto;
  margin-right: 0;
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar {
  border-radius: 8px;
  justify-content: flex-start;
  column-gap: 12px;
  cursor: pointer;
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar:hover {
  background-color: var(--wallet-selector-wallet-option-bg-hover, var(--wallet-option-bg-hover));
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar.selected-wallet {
  z-index: -1;
  padding: 12px;
  background-color: var(--wallet-selector-selected-wallet-bg, var(--selected-wallet-bg));
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar.selected-wallet .content .title {
  color: #FFFFFF;
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar.deprecated-wallet {
  opacity: 0.4;
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar .warning-triangle {
  display: flex;
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar .icon {
  width: 40px;
  height: 40px;
  background-color: #FFF;
  padding: 5px;
  border-radius: 5px;
  position: relative;
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar.connected-wallet .icon::before {
  content: '';
  display: block;
  width: 10px;
  height: 10px;
  background-color: var(--connected-green);
  border-radius: 50%;
  position: absolute;
  top: -8px;
  right: -8px;
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar.connected-wallet .icon::before {
  border: 3px solid var(--wallet-selector-content-bg, var(--content-bg));
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar.selected-wallet.connected-wallet .icon::before {
  border: 3px solid var(--wallet-selector-selected-wallet-bg, var(--selected-wallet-bg));
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar .content {
  height: 32px;
  width: auto;
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar .content .title {
  font-style: normal;
  font-weight: 500;
  font-size: 14px;
  line-height: 32px;
  /* identical to box height, or 171% */
  align-items: center;
  color: var(--wallet-selector-heading-color, var(--heading-color));
}

.nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list .single-wallet.sidebar .content .description {
  display: none;
}

/**
* Modal Right Side
*/

.nws-modal-wrapper .nws-modal .modal-right {
  width: 65%;
  padding: 32px;
  overflow: hidden;
}

.nws-modal-wrapper .nws-modal .wallet-home-wrapper .get-wallet-wrapper,
.nws-modal-wrapper .nws-modal .wallet-home-wrapper .wallet-info-wrapper,
.nws-modal-wrapper .nws-modal .connecting-wrapper,
.nws-modal-wrapper .nws-modal .wallet-not-installed-wrapper,
.nws-modal-wrapper .nws-modal .switch-network-message-wrapper {
  margin-top: 91px;
  padding: 0 28px;
}

.nws-modal-wrapper .nws-modal .wallet-home-wrapper .get-wallet-wrapper {
  padding: 0;
}

.nws-modal-wrapper .nws-modal .modal-right .wallet-what {
  display: flex;
  align-content: center;
  flex-direction: row;
  align-items: flex-start;
  width: 100%;
  gap: 32px;
  justify-content: flex-start;
  flex-wrap: nowrap;
}

.nws-modal-wrapper .nws-modal .modal-right .wallet-what+.wallet-what {
  margin-top: 50px;
}

.nws-modal-wrapper .nws-modal .modal-right .wallet-what .icon-side {
  width: 15%;
  padding-top: 9px;
  padding-bottom: 9px;
}

.nws-modal-wrapper .nws-modal .modal-right .wallet-what .icon-side img {
  width: 100%;
  height: auto;
  max-height: 65px;
  border-radius: 6px;
}

.nws-modal-wrapper .nws-modal .modal-right .wallet-what .content-side {
  width: 100%;
}

.nws-modal-wrapper .nws-modal .modal-right .wallet-what .content-side h3 {
  margin: 0 auto 8px 0;
  font-family: inherit;
  font-style: normal;
  font-weight: 700;
  font-size: 16px;
  line-height: 24px;
  color: var(--wallet-selector-text-color, var(--heading-color));
}

.nws-modal-wrapper .nws-modal .modal-right .wallet-what .content-side p {
  margin: 0;
  font-family: inherit;
  font-style: normal;
  font-weight: 400;
  font-size: 14px;
  line-height: 150%;
  word-break: break-word;
  width: 80%;
}

/**
 * Modal Header
 */

.nws-modal-wrapper .nws-modal .modal-right .nws-modal-header h3.middleTitle {
  text-align: center;
  margin: 4px auto;
  font-size: 18px;
  color: var(--wallet-selector-heading-color, var(--heading-color));
}

.nws-modal-wrapper .nws-modal .modal-right .nws-modal-body.get-wallet-body {
  padding-left: 32px;
  padding-right: 0;
  row-gap: 16px;
  margin-top: 64px;
}

.nws-modal-wrapper .nws-modal .nws-modal-body button.middleButton {
  background-color: var(--wallet-selector-selected-wallet-bg, var(--selected-wallet-bg));
  font: inherit;
  border-radius: 4px;
  color: #FFFFFF;
  font-weight: 700;
  font-size: 14px;
  line-height: 24px;
  border-color: var(--wallet-selector-selected-wallet-bg, var(--selected-wallet-bg));
  display: block;
  margin: 75px auto 12px auto;
  border: 0.1em solid var(--wallet-selector-selected-wallet-bg, var(--selected-wallet-bg));
}

.nws-modal-wrapper .nws-modal .nws-modal-body button.get-wallet {
  margin: 4px 0;
  background-color: var(--wallet-selector-home-button-bg, var(--home-button-bg));
  border-radius: 4px;
  padding: 8px 24px;
  border-width: 0;
  font-style: normal;
  font-weight: 700;
  font-size: 14px;
  line-height: 24px;
  font-family: inherit;
  color: #6494EE;
}

.nws-modal-wrapper .nws-modal .nws-modal-header {
  width: 100%;
  display: flex;
  flex: 1;
  align-items: flex-start;
  justify-content: space-between;
}

.nws-modal-wrapper .nws-modal .nws-modal-header .close-button {
  border: 0;
  cursor: pointer;
  height: 32px;
  padding: 4px;
  background-color: var(--wallet-selector-close-button-bg-color, var(--close-button-bg-color));
  border-radius: 50px;
}

.nws-modal-wrapper .nws-modal .nws-modal-header .close-button svg {
  fill: var(--wallet-selector-close-button-fill-icon-color, var(--close-button-fill-icon-color));
}

.nws-modal-wrapper .nws-modal .back-button {
  background: transparent;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  display: block;
  /* vertical-align: middle; */
  border: none;
  padding: 4px
}

.nws-modal-wrapper .nws-modal .nws-modal-header-wrapper {
  display: flex;
  align-items: center;
}

.nws-modal-wrapper .nws-modal .nws-modal-header .close-button:active {
  background: transparent;
}

.nws-modal-wrapper .nws-modal .nws-modal-header .close-button svg {
  pointer-events: none;
}

.nws-modal-wrapper .nws-modal .nws-modal-header h2 {
  margin-top: 0;
  margin-bottom: 20px;
  font-size: 18px;
  font-weight: bold;
  color: var(--wallet-selector-heading-color, var(--heading-color));
}

.nws-modal-wrapper .nws-modal .action-buttons {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

/**
 * Modal Switch Network Message Section/Wrapper
 */

.nws-modal-wrapper .nws-modal .switch-network-message-wrapper .content .network-id {
  color: var(--wallet-selector-selected-wallet-bg, var(--selected-wallet-bg));
}

/**
 * Modal Ledger Derivation Path Section/Wrapper
 */

.nws-modal-wrapper .nws-modal .derivation-path-wrapper {
  padding: 0 26px;
}

.nws-modal-wrapper .nws-modal .derivation-path-wrapper .enter-derivation-path .ledger-image {
  display: flex;
  justify-content: center;
  margin-top: 53px;
  margin-bottom: 40px;
}

.nws-modal-wrapper .nws-modal .derivation-path-wrapper .enter-derivation-path .ledger-description {
  font-size: 14px;
  text-align: center;
}

.nws-modal-wrapper .nws-modal .derivation-path-wrapper .enter-derivation-path .ledger-description .specify-path {
  color: var(--wallet-selector-selected-wallet-bg, var(--selected-wallet-bg));
  cursor: pointer;
}

.nws-modal-wrapper .nws-modal .derivation-path-wrapper .derivation-path-list {
  display: flex;
  justify-content: center;
  flex-direction: column;
  margin-bottom: 16px;
}

.nws-modal-wrapper .specify-path-wrapper .change-path-wrapper {
  display: flex;
  justify-content: center;
  margin-top: 91px;
}

.nws-modal-wrapper .specify-path-wrapper .change-path-wrapper .display-path {
  background: var(--home-button-bg);
  color: #606060;
  padding: 16px;
  border-radius: 8px;
  letter-spacing: 1px;
  font-weight: 700;
}

.nws-modal-wrapper .specify-path-wrapper .change-path-wrapper .change-path {
  background: var(--change-path-bg);
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-left: 10px;
  width: 63px;
  padding: 0 5px;
  border-radius: 8px;
}

.nws-modal-wrapper .specify-path-wrapper .change-path-wrapper .change-path .path-value {
  width: 100%;
  text-align: center;
  font-weight: bold;
}

.nws-modal-wrapper .nws-modal .specify-path-wrapper .path-description {
  font-size: 14px;
  margin-top: 24px;
  text-align: center;
}

.nws-modal-wrapper .nws-modal .specify-path-wrapper .what-link {
  font-size: 14px;
  text-align: center;
  color: var(--selected-wallet-bg);
  cursor: pointer;
}

.nws-modal-wrapper .specify-path-wrapper .change-path-wrapper .change-path .buttons-wrapper {
  display: flex;
  flex-direction: column;
}

.nws-modal-wrapper .specify-path-wrapper .change-path-wrapper .change-path .buttons-wrapper button {
  padding: 0;
  width: 23px;
  background-color: var(--home-button-bg);
  border: none;
}

.nws-modal-wrapper .nws-modal .no-accounts-found-wrapper {
  margin-top: 50px;
  font-size: 14px;
}

.nws-modal-wrapper .nws-modal .enter-custom-account {
  margin-top: 20px;
}

.nws-modal-wrapper .nws-modal .enter-custom-account p {
  text-align: center;
  font-size: 14px;
}

.nws-modal-wrapper .nws-modal .enter-custom-account .input-wrapper {
  display: flex;
  justify-content: center;
  margin-top: 90px;
}

.nws-modal-wrapper .nws-modal .enter-custom-account .input-wrapper input {
  text-align: center;
  color: var(--wallet-selector-heading-color, var(--heading-color));
  border: 1px solid var(--confirm-button-bg-hover);
  padding: 6px 8px;
  border-radius: 50px;
}

/**
 * Modal Wallet ChooseLedgerAccountForm/Wrapper
 */

.nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper p {
  font-size: 14px;
  text-align: center;
  margin-top: 20px;
}

.nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper .button-wrapper {
  display: flex;
  justify-content: center;
}

.nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper .button-wrapper button {
  color: var(--selected-wallet-bg);
  font-weight: 600;
  background-color: transparent;
  border-radius: 20px;
  font-size: 14px;
  border: 1px solid var(--selected-wallet-bg);
  width: 78px;
  padding: 6px 8px;
}

.nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper .form {
  margin-top: 96px;
}

.nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper .nws-form-control {
  display: flex;
  flex-direction: column;
  margin-bottom: 16px;
  padding: 10px;
  color: var(--text-color);
}

.nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper .nws-form-control .account {
  border-bottom: 1px solid var(--sidebar-border-color);
  padding: 16px 0;
  color: var(--wallet-selector-heading-color, var(--heading-color));
}

.nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper .nws-form-control .account input[type=checkbox] {
  width: 25px;
  -ms-transform: scale(2);
  -moz-transform: scale(2);
  -webkit-transform: scale(2);
  -o-transform: scale(2);
  transform: scale(1.7);
  padding: 10px;
}

.nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper .nws-form-control label {
  color: inherit;
}

.nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper .action-buttons {
  justify-content: flex-end;
}

.nws-modal-wrapper .nws-modal .overview-wrapper p {
  font-size: 14px;
  text-align: center;
}

.nws-modal-wrapper .nws-modal .overview-wrapper .accounts {
  margin-top: 96px;
}

.nws-modal-wrapper .nws-modal .overview-wrapper .account {
  border-bottom: 1px solid var(--sidebar-border-color);
  padding: 16px 0;
  color: var(--wallet-selector-heading-color, var(--heading-color));
}

/*
  Connecting Wrapper Section/Wrapper
*/
.nws-modal-wrapper .nws-modal .connecting-wrapper .content {
  display: flex;
  flex-direction: column;
  align-items: center;
}

/**
 * Modal Wallet Not Installed Section/Wrapper
 */

.nws-modal-wrapper .wallet-not-installed-wrapper .refresh-link {
  color: #5f8afa;
  cursor: pointer;
}

.nws-modal-wrapper .wallet-not-installed-wrapper .wallet-data {
  display: flex;
  align-items: center;
}

.nws-modal-wrapper .wallet-not-installed-wrapper .wallet-data p {
  margin: 0 0 0 10px;
}

.nws-modal-wrapper .wallet-not-installed-wrapper .wallet-data .wallet-icon-box {
  width: 40px;
  height: 40px;
}

.nws-modal-wrapper .wallet-not-installed-wrapper .wallet-data .wallet-icon-box img {
  width: 100%;
  height: auto;
}

.open {
  opacity: 1;
  visibility: visible;
  transition: visibility 0s linear 0s, opacity 0.25s 0s;
}

.nws-modal-wrapper .spinner {
  margin-right: 10px;
  --size: 160px;
  --border: 6px;
  width: var(--size);
  height: var(--size);
  border-radius: 50%;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
}

.nws-modal-wrapper .spinner .icon {
  width: calc(var(--size) / 1.2);
  height: calc(var(--size) / 1.2);
  border: 1px solid rgba(0, 0, 0, 0.05);
  border-radius: 50%;
  box-shadow: rgba(0, 0, 0, 0.05) 0 10px 20px 0;
}

.nws-modal-wrapper .spinner img {
  width: 100%;
  height: auto;
}

@keyframes spin {
  100% {
    transform: rotate(360deg);
  }
}

@media (max-width: 600px) {
  .nws-modal-wrapper .nws-modal-wrapper .nws-modal {
    width: 250px;
  }

  .nws-modal-wrapper .nws-modal-wrapper .nws-modal .derivation-path-wrapper .derivation-path-list input {
    max-width: 140px;
  }

  .nws-modal-wrapper .nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper .nws-form-control {
    flex-direction: column;
  }

  .nws-modal-wrapper .nws-modal-wrapper .nws-modal .choose-ledger-account-form-wrapper .nws-form-control select {
    text-align: center;
  }
}

.nws-modal-wrapper .nws-modal-wrapper.dark-theme .nws-modal #near-wallet img,
.nws-modal-wrapper .nws-modal-wrapper.dark-theme .nws-modal #math-wallet img,
.nws-modal-wrapper .nws-modal-wrapper.dark-theme .nws-modal #ledger img,
.nws-modal-wrapper .nws-modal-wrapper.dark-theme .nws-modal .wallet-not-installed-wrapper .math-wallet img {
  filter: invert(1);
}

.nws-modal-wrapper .nws-modal-wrapper.dark-theme .spinner .icon {
  box-shadow: 0 10px 20px 0 rgba(255, 255, 255, 0.05);
}

@media (prefers-color-scheme: dark) {

  .nws-modal-wrapper .nws-modal #near-wallet img,
  .nws-modal-wrapper .nws-modal #math-wallet img,
  .nws-modal-wrapper .nws-modal #ledger img,
  .nws-modal-wrapper .nws-modal .wallet-not-installed-wrapper .math-wallet img {
    filter: invert(1);
  }

  .nws-modal-wrapper .spinner .icon {
    box-shadow: 0 10px 20px 0 rgba(255, 255, 255, 0.05);
  }
}

@keyframes outAnimation {
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
    visibility: hidden;
  }
}

/**
* Modal Wallet Connecting Section/Wrapper
*/

.connecting-wrapper {
  display: flex;
  flex-direction: column;
  flex-wrap: nowrap;
  align-items: center;
  justify-content: flex-start;
}

.connecting-wrapper .content .icon {
  width: 80px;
  height: 80px;
  background-color: white;
  border-radius: 10px;
  padding: 10px
}

.connecting-wrapper .content .icon img {
  width: 100%;
  height: auto;
}

.connecting-wrapper .content .connecting-name {
  font-style: normal;
  font-weight: 700;
  font-size: 16px;
  line-height: 24px;
  display: flex;
  align-items: center;
  text-align: center;
  color: var(--wallet-selector-heading-color, var(--heading-color));
}

.connecting-wrapper .content .connecting-details {
  font-style: normal;
  font-weight: 500;
  font-size: 14px;
  line-height: 24px;
  display: flex;
  align-items: center;
  margin-top: 40px;
}

.connecting-wrapper .content .connecting-details span {
  color: var(--wallet-selector-selected-wallet-bg, var(--selected-wallet-bg));
}

.connecting-wrapper .content .connecting-details .spinner {
  width: 25px;
  height: auto;
  animation: spinner 2s linear infinite;
}

@keyframes spinner {
  0% {
    transform: rotate(0deg);
  }

  100% {
    transform: rotate(360deg);
  }
}

.nws-modal-wrapper .nws-modal .nws-modal-body .alert-message .connection button {
  margin: 24px auto;
  font-style: normal;
  font-weight: 700;
  font-size: 14px;
  line-height: 24px;
  display: flex;
  color: #6494EE;
  align-items: center;
  padding: 8px 24px;
  gap: 8px;
  width: 86px;
  height: 40px;
  background-color: var(--wallet-selector-home-button-bg, var(--home-button-bg));
  border-radius: 4px;
  border: 0;
}

.nws-modal-wrapper .nws-modal .nws-modal-body .alert-message .connection .error-wrapper {
  vertical-align: middle;
  align-items: center;
  display: flex;
  flex-wrap: nowrap;
  justify-content: center;
  flex-direction: column;
  column-gap: 12px;
  font-style: normal;
  font-weight: 500;
  font-size: 14px;
  line-height: 150%;
  text-align: center;
}

.nws-modal-wrapper .nws-modal .nws-modal-body .alert-message .connection .error {
  color: #CE5A6F;
  vertical-align: middle;
  align-items: center;
  display: flex;
  flex-wrap: nowrap;
  justify-content: center;
  flex-direction: row;
  column-gap: 12px;
  font-style: normal;
  font-weight: 500;
  font-size: 14px;
  line-height: 150%;
  text-align: center;
}

.nws-modal-wrapper .nws-modal .nws-modal-body .alert-message .connection .error-wrapper .error svg {
  color: var(--wallet-selector-content-bg, var(--content-bg));
}

.nws-modal-wrapper .nws-modal .nws-modal-body .alert-message .connection .success {
  color: #4FD98F;
}

.nws-modal-wrapper .nws-modal .connecting-wrapper .content {
  padding: 25px;
}

.connecting-wrapper .content .connecting-details {
  margin-top: 20px;
}

.connecting-wrapper .wallet-connected-success {
  display: flex;
  align-items: center;
}

.connecting-wrapper .wallet-connected-success svg {
  color: var(--content-bg);
}

.connecting-wrapper .wallet-connected-success span {
  font-size: 14px;
  margin-left: 10px;
  color: var(--wallet-selector-connected-green, var(--connected-green));
}

.single-wallet-get {
  display: flex;
  flex-wrap: nowrap;
  flex-direction: row;
  align-content: center;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  column-gap: 24px;
  padding: 12px;
  max-width: 450px;
  margin: auto;
  margin-top: 20px;
}

.single-wallet-get .icon {
  min-width: 48px;
  max-height: 48px;
  width: 48px;
  height: 48px;
  background-color: #FFF;
  padding: 5px;
  border-radius: 4px;
  position: relative;
}

.single-wallet-get .icon img {
  width: 100%;
  height: auto;
  max-width: 48px;
}

.single-wallet-get .title {
  font-family: inherit;
  font-style: normal;
  font-weight: 700;
  font-size: 14px;
  line-height: 24px;
  align-items: center;
  color: var(--wallet-selector-heading-color, var(--heading-color));
}

.single-wallet-get .description {
  font-family: inherit;
  font-style: normal;
  font-weight: 400;
  font-size: 14px;
  line-height: 150%;
  align-items: center;
}

.single-wallet-get .button-get {
  margin-left: auto;
  margin-right: 0;
}

.connected-flag {
  color: var(--connected-green);
  border: 1px solid var(--connected-green);
  border-radius: 50px;
  padding: 3px 10px;
  display: flex;
  align-items: center;
}

.connected-flag::before {
  content: '';
  display: block;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  background-color: var(--connected-green);
  margin-right: 5px;
}

@media (min-width: 769px) {
  .nws-modal-wrapper .nws-modal .modal-right .nws-modal-body .what-wallet-mobile {
    display: none;
  }
}

/*************Queries for mobile **********/

@media (max-width: 768px) {

  .nws-modal-wrapper .nws-modal .wallet-home-wrapper .get-wallet-wrapper,
  .nws-modal-wrapper .nws-modal .wallet-home-wrapper .wallet-info-wrapper,
  .nws-modal-wrapper .nws-modal .connecting-wrapper,
  .nws-modal-wrapper .nws-modal .wallet-not-installed-wrapper,
  .nws-modal-wrapper .nws-modal .switch-network-message-wrapper {
    margin-top: 20px;
    padding: 0;
  }

  .nws-modal-wrapper .wallet-not-installed-wrapper>p {
    margin: 20px 0px 30px 0px;
    max-width: 500px;
  }

  .nws-modal-wrapper .nws-modal .modal-right .nws-modal-body .what-wallet-hide {
    display: none;
  }

  .nws-modal-wrapper .nws-modal .modal-right .nws-modal-body .what-wallet-mobile p {
    font-size: 14px;
    margin-bottom: 0;
    text-align: center;
    max-width: 600px;
    margin: auto;
  }

  .nws-modal-wrapper .nws-modal-overlay {
    background: var(--wallet-selector-backdrop-bg, var(--bottom-section));
    height: 100%;
    width: 100%;
    position: absolute;
  }

  .nws-modal-wrapper .nws-modal .modal-left {
    padding: 32px 12px;
  }

  .nws-modal-wrapper .nws-modal {
    width: 100%;
    display: block;
    overflow: auto;
  }

  .nws-modal-wrapper .nws-modal .modal-left {
    width: 100%;
    background-color: var(--wallet-selector-content-bg, var(--content-bg));
  }

  .nws-modal-wrapper .nws-modal .modal-left .nws-modal-body {
    display: flex;
    overflow: auto;
  }

  .nws-modal-wrapper .nws-modal .modal-left .nws-modal-body .wallet-options-wrapper {
    display: flex;
    margin: auto;
  }

  .nws-modal-wrapper .nws-modal .modal-right {
    width: 100%;
    background-color: var(--wallet-selector-mobile-bottom-section, var(--bottom-section));
  }

  .nws-modal-wrapper .nws-modal .modal-right .nws-modal-header h3.middleTitle {
    text-align: center;
    font-size: 16px;
    margin: 4px auto;
  }

  .nws-modal-wrapper .nws-modal .modal-right .nws-modal-body .content {
    font-size: 14px;
    text-align: center;
    color: var(--mobile-text);
    margin: 0
  }

  .nws-modal-wrapper .nws-modal .modal-right .nws-modal-body {
    margin-top: 10px;
    padding: 0;
  }

  .nws-modal-wrapper .nws-modal .nws-modal-body button.middleButton {
    margin: 25px auto 12px auto;
  }

  .nws-modal-wrapper .nws-modal .modal-header {
    display: block;
    font-size: 18px;
    text-align: center;
  }

  .nws-modal-wrapper .nws-modal .nws-modal-header .close-button {
    position: absolute;
    right: 30px;
    top: 30px;
  }

  .nws-modal-wrapper .nws-modal .nws-modal-header h2 {
    font-size: 18px;
    text-align: center;
  }

  .nws-modal-wrapper .nws-modal .wallet-options-wrapper .description {
    display: none;
  }

  .nws-modal-wrapper .nws-modal .wallet-options-wrapper .options-list {
    display: flex;
    overflow-x: auto;
  }

  .nws-modal-wrapper .nws-modal .info {
    display: none;
    width: 90px;
  }

  .single-wallet {
    display: block;
    width: 85px;
  }

  .single-wallet.sidebar .icon {
    width: 56px;
    height: 56px;
    margin: auto;
  }

  .single-wallet.sidebar .content {
    width: auto;
  }

  .single-wallet .content .title {
    margin-top: 10px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .nws-modal-wrapper .nws-modal .wallet-home-wrapper .get-wallet-wrapper {
    margin-top: 0;
  }

  .nws-modal-wrapper .nws-modal .derivation-path-wrapper .enter-derivation-path .ledger-image,
  .nws-modal-wrapper .specify-path-wrapper .change-path-wrapper {
    margin-top: 30px;
    margin-bottom: 30px;
  }

  .nws-modal-wrapper .nws-modal .derivation-path-wrapper .enter-derivation-path .ledger-description>p {
    max-width: 450px;
    margin-left: auto;
    margin-right: auto;
  }

  ::-webkit-scrollbar {
    height: 4px;
    width: 4px;
    background: var(--backdrop-bg);

  }

  ::-webkit-scrollbar-thumb:horizontal {
    background: var(--close-button-fill-icon-color);
    border-radius: 10px;
  }
}
'''
'''--- src/css/theme.css ---
/* Pink Light scheme (Default) */
/* Can be forced with data-theme="light" */
[data-theme="light"],
:root:not([data-theme="dark"]) {
  --primary: #da0088;
  --primary-hover: #fb00bb;
  --primary-focus: rgba(216, 27, 96, 0.125);
  --primary-inverse: #FFF;
  --form-element-border-color: #DDD;
  --border-radius: 0;
}

/* Pink Dark scheme (Auto) */
/* Automatically enabled if user has Dark mode enabled */
@media only screen and (prefers-color-scheme: dark) {
  :root:not([data-theme="light"]) {
    --primary: #d81b60;
    --primary-hover: #e91e63;
    --primary-focus: rgba(216, 27, 96, 0.25);
    --primary-inverse: #FFF;
	--form-element-border-color: #DDD;
	--border-radius: 0;
  }
}

/* Pink Dark scheme (Forced) */
/* Enabled if forced with data-theme="dark" */
[data-theme="dark"] {
  --primary: #d81b60;
  --primary-hover: #e91e63;
  --primary-focus: rgba(216, 27, 96, 0.25);
  --primary-inverse: #FFF;
}

/* Pink (Common styles) */
:root {
  --form-element-active-border-color: var(--primary);
  --form-element-focus-color: var(--primary-focus);
  --switch-color: var(--primary-inverse);
  --switch-checked-background-color: var(--primary);
}

.web-share-fade-in-up > button {
	background: var(--primary) !important;
}
'''
'''--- src/data/nft-series.js ---
export const nftSeries = {
	wasm: '/nft-series.wasm',
	form: {
		contract_id: '',
		NEAR: 5,
		owner_id: '',
		__spec: 'nft-1.0.99',
		name: '',
		symbol: '',
		// icon: '_',
		// base_uri: '_',
		// reference: '_',
		// reference_hash: '_',
	},
	data: {
		get_series: {
			from_index: '0',
			limit: 50,
		}
	},
	interact: {
		create_series: {
			form: {
				mint_id: 1,
				media: '',

				title: '',
				description: '',

				copies: 10,
				royalty_receiver: '',
				royalty_percent: 0,
			},
			valuesMap: {
				media: 'metadata.media',
				title: 'metadata.title',
				description: 'metadata.description',
				copies: 'metadata.copies',
			},
			number: ['mint_id', 'copies'],
			deposit: '0.1'
		},
		update_mint_id: {
			form: {
				old_mint_id: 1,
				new_mint_id: 2,
			},
			number: ['old_mint_id', 'new_mint_id'],
		},
		add_approved_minter: {
			form: {
				account_id: ''
			}
		},
	}
}
'''
'''--- src/data/nft-simple.js ---
export const nftSimple = {
	wasm: '/nft-simple.wasm',
	form: {
		contract_id: '',
		NEAR: 5,
		owner_id: '',
		__spec: 'nft-1.0.0',
		name: '',
		symbol: '',
		// icon: '_',
		// base_uri: '_',
		// reference: '_',
		// reference_hash: '_',
	},
}
'''
'''--- src/img/my-near-wallet-icon.svg ---
<svg width="111" height="112" viewBox="0 0 111 112" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M78.0001 66.34V38.64C78.0001 33.12 72.4 27.71 65.48 27.71C61.7606 27.7749 58.2115 29.2805 55.5801 31.91L43.0901 19.58C46.4088 16.3502 50.3852 13.8743 54.7479 12.3211C59.1106 10.7679 63.757 10.1741 68.3701 10.58C84.6101 12.12 95.3101 25.27 95.3101 39.03V84.03L78.0001 66.34Z" fill="url(#paint0_linear_528_1332)"/>
<path d="M16.1001 28V73C16.1001 86.76 26.8101 99.91 43.0401 101.45C47.6532 101.856 52.2996 101.262 56.6623 99.7089C61.025 98.1557 65.0014 95.6798 68.3201 92.45L55.8301 80.12C53.1987 82.7495 49.6496 84.2552 45.9301 84.32C39.0101 84.32 33.4101 78.91 33.4101 73.39V45.89" fill="url(#paint1_linear_528_1332)"/>
<path d="M62.7999 51.19L95.2899 83.77V92.77C95.2899 95.72 92.3699 98.83 88.8599 98.89C86.8599 98.89 84.7698 97.32 83.4698 96.02L50.3999 62.78L16.1099 28.28V19.28C16.1099 16.33 19.0299 13.22 22.5399 13.16C24.5399 13.16 26.6299 14.73 27.9299 16.03L62.7999 51.19Z" fill="url(#paint2_linear_528_1332)"/>
<defs>
<linearGradient id="paint0_linear_528_1332" x1="50.9601" y1="9.49001" x2="108.59" y2="70.34" gradientUnits="userSpaceOnUse">
<stop offset="0.06" stop-color="#B6D7FE"/>
<stop offset="0.12" stop-color="#A6D4FC"/>
<stop offset="0.26" stop-color="#88CEF8"/>
<stop offset="0.38" stop-color="#76CAF6"/>
<stop offset="0.47" stop-color="#70C9F5"/>
<stop offset="0.73" stop-color="#18A0EC"/>
</linearGradient>
<linearGradient id="paint1_linear_528_1332" x1="21.3201" y1="35.88" x2="55.5801" y2="117.2" gradientUnits="userSpaceOnUse">
<stop offset="0.01" stop-color="#8537FF"/>
<stop offset="0.49" stop-color="#D095FE"/>
<stop offset="0.72" stop-color="#E9ADFF"/>
<stop offset="0.85" stop-color="#F8BCFF"/>
</linearGradient>
<linearGradient id="paint2_linear_528_1332" x1="98.3799" y1="97.71" x2="17.9099" y2="19.16" gradientUnits="userSpaceOnUse">
<stop stop-color="#35D7FD"/>
<stop offset="0.68" stop-color="#9A68FE"/>
<stop offset="1" stop-color="#B45DFF"/>
</linearGradient>
</defs>
</svg>

'''
'''--- src/img/near-icon.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 288 288"><g id="Layer_1" data-name="Layer 1"><path d="M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z"/></g></svg>
'''
'''--- src/img/sender-icon.svg ---
<?xml version="1.0" encoding="UTF-8"?>
<svg width="60px" height="108px" viewBox="0 0 60 108" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <title>symble-Color</title>
    <g id="定稿" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">
        <g id="Sender-svg" transform="translate(-924.000000, -240.000000)" fill="#2E79DF">
            <g id="1" transform="translate(240.000000, 240.000000)">
                <path d="M731.030358,44.7388566 C732.635586,45.3251687 734.109757,46.091225 735.41929,47.0327914 C737.161902,48.2855715 738.612713,49.8504902 739.688121,51.720433 C740.241158,52.6820654 740.675161,53.6889918 740.99372,54.7317766 C741.315894,55.7822725 741.522009,56.8689832 741.616271,57.9821168 C742.282833,65.8085593 737.453761,74.9096997 728.859932,81.6705677 L728.471956,81.9722564 C726.977363,83.1204604 725.372095,84.1987928 723.665529,85.1879265 L684.307532,108 C683.15258,100.329149 685.283073,92.4505304 690.153902,86.3765836 C692.259598,83.7497243 694.877695,81.4608337 697.964392,79.6717703 L720.955703,66.345902 C724.089121,64.5297585 726.081012,61.4940724 726.67294,58.1919345 C727.144026,55.5661934 726.730102,52.7726869 725.301512,50.2886231 C724.152788,48.2911981 722.503123,46.7639035 720.600481,45.7730364 C718.437905,44.6451761 715.947781,44.2105553 713.495722,44.5661608 C713.634239,44.500585 713.773199,44.4372041 713.912602,44.3760182 C715.999127,43.8580037 718.060524,43.5286154 720.061104,43.3856575 C724.054093,43.1012096 727.805214,43.5592194 731.030358,44.7388566 Z M743.692468,0 C744.84742,7.67085123 742.716927,15.5494696 737.846098,21.6234164 C735.740402,24.2502757 733.122305,26.5391663 730.035608,28.3282297 L707.044297,41.654098 C703.910879,43.4702415 701.918988,46.5059276 701.32706,49.8080655 C700.855974,52.4338066 701.269898,55.2273131 702.698488,57.7113769 C703.847212,59.7088019 705.496877,61.2360965 707.399519,62.2269636 C709.562095,63.3548239 712.052219,63.7894447 714.504278,63.4338392 C714.365761,63.499415 714.226801,63.5627959 714.087398,63.6239818 C712.000873,64.1419963 709.939476,64.4713846 707.938896,64.6143425 C703.945907,64.8987904 700.194786,64.4407806 696.969642,63.2611434 C695.364414,62.6748313 693.890243,61.908775 692.58071,60.9672086 C690.838098,59.7144285 689.387287,58.1495098 688.311879,56.279567 C687.758842,55.3179346 687.324839,54.3110082 687.00628,53.2682234 C686.684106,52.2177275 686.477991,51.1310168 686.383729,50.0178832 C685.717167,42.1914407 690.546239,33.0903003 699.140068,26.3294323 L699.528044,26.0277436 C701.022637,24.8795396 702.627905,23.8012072 704.334471,22.8120735 L743.692468,0 Z" id="symble-Color"></path>
            </g>
        </g>
    </g>
</svg>
'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <base href="/">
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <meta name="title" content="Keypom Ticket">
    <meta property="og:title" content="Keypom Ticket">
    <meta name="twitter:title" content="Keypom Ticket">

    <meta name="description" content="Click to get your ticket!">
    <meta property="og:description" content="Click to get your ticket!">
    <meta name="twitter:description" content="Click to get your ticket!">
    
    <meta name="image" content="https://keypom.xyz/social-clean.jpg">
    <meta property="og:image" content="https://keypom.xyz/social-clean.jpg">
    <meta name="twitter:image" content="https://keypom.xyz/social-clean.jpg"></meta>

    <meta property="og:url" content="https://keypom.xyz">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="Keypom"></meta>
    <meta name="twitter:image:alt" content="Keypom Ticket"></meta>

    <link rel="stylesheet" href="https://unpkg.com/@picocss/pico@latest/css/pico.min.css">
    <link rel="stylesheet" href="./css/theme.css" />

    <title>Keypom</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script type="module" src="./index.js"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from 'react';
import { createRoot } from 'react-dom/client';
import App from './App';
import { AppProvider } from './state/app.js';
import { BrowserRouter } from "react-router-dom";

const container = document.getElementById('root');
const root = createRoot(container);
root.render(<AppProvider>
	<BrowserRouter>
		<App />
	</BrowserRouter>
</AppProvider>);

'''
'''--- src/qr-worker.js ---
self.addEventListener('message', function(e) {
    const input = e.data;

    switch (input.cmd) {
        case 'init':
            init();
            break;
        case 'process':
            process(input);
            break;
        default:
            console.log('Unknown command for QRCode worker.');
            break;
    }
});

function init() {
    self.importScripts(
        'lib/jsqrcode/src/grid.js',
        'lib/jsqrcode/src/version.js',
        'lib/jsqrcode/src/detector.js',
        'lib/jsqrcode/src/formatinf.js',
        'lib/jsqrcode/src/errorlevel.js',
        'lib/jsqrcode/src/bitmat.js',
        'lib/jsqrcode/src/datablock.js',
        'lib/jsqrcode/src/bmparser.js',
        'lib/jsqrcode/src/datamask.js',
        'lib/jsqrcode/src/rsdecoder.js',
        'lib/jsqrcode/src/gf256poly.js',
        'lib/jsqrcode/src/gf256.js',
        'lib/jsqrcode/src/decoder.js',
        'lib/jsqrcode/src/qrcode.js',
        'lib/jsqrcode/src/findpat.js',
        'lib/jsqrcode/src/alignpat.js',
        'lib/jsqrcode/src/databr.js'
    );
}

function process(input) {
    qrcode.width = input.width;
    qrcode.height = input.height;
    qrcode.imagedata = input.imageData;

    let result = false;
    try {
        result = qrcode.process();
    } catch (e) {}

    postMessage(result);
}
'''
'''--- src/state/app.js ---
import { get, set } from '../utils/store'
import { State } from '../utils/state';
import { initNear } from './near';

export const APP_DATA = '__APP_DATA'

// example
const initialState = {
	app: {
		mounted: false,
		menu: false,
		loading: true,
		message: null,
		data: get(APP_DATA) || { seedPhrase: null, contracts: [] },
	},
	wallet: {
		isSignedIn: () => false
	},
	contract: {},
	nfts: null,
};

export const { appStore, AppProvider } = State(initialState, 'app');

export const popMessage = (message) =>  async ({ update }) => {
	update('app.message', message);
	setTimeout(() => update('app.message', null), 3000)
};
// example app function
export const onAppMount = () => async ({ update, getState, dispatch }) => {
	update('app', { mounted: true });
};

export const insertAppDataArr = (update, k, v) => {
	const appData = getAppData()
	if (!appData[k]) appData[k] = []
	if (!appData[k].includes(v)) appData[k].push(v)
	set(APP_DATA, appData)
	update('app.data', appData)
}

export const removeAppDataArr = (update, k, v) => {
	const appData = getAppData()
	if (!appData[k]) return
	const newArr = appData[k].filter((el) => el !== v)
	appData[k] = newArr
	set(APP_DATA, appData)
	update('app.data', appData)
}

export const setAppData = (update, data) => {
	set(APP_DATA, data)
	update('app.data', data)
}

export const getAppData = () => get(APP_DATA)

'''
'''--- src/state/contracts.js ---
import { networkId, viewMethod, getAccountWithMain } from "../state/near";
import { contractBySpec } from "../state/deploy";
import { insertAppDataArr, removeAppDataArr } from "../state/app";

export const explorerLink = (contractId) => `https://explorer.${networkId}.near.org/accounts/${contractId}`

export const removeContract = async (wallet, update, contractId) => {
	const confirm = window.confirm(`Really delete ${contractId} contract? This will remove all NFTs and any data!!!`)
	if (!confirm) return
	update('app.loading', true)
	try {
		const contractAccount = getAccountWithMain(contractId)
		await contractAccount.deleteAccount(wallet.accountId)
		removeAppDataArr(update, 'contracts', contractId)
	} catch(e) {
		if (/Can not sign transactions for account/.test(e.toString())) {
			removeAppDataArr(update, 'contracts', contractId)
		}
		console.warn(e)
	} finally {
		update('app.loading', false)
	}
}

export const updateContract = async (update, contractId) => {
	const metadata = await viewMethod({ contractId, methodName: 'nft_metadata' })
	if (!metadata) return
	update('app.loading', true)
	const confirm = window.confirm(`Push latest wasm to ${contractId}? This may have unintended consequences and you might have to remove your contract.`)
	if (!confirm) return update('app.loading', false)
	try {
		const whichContract = contractBySpec(metadata.spec)
		const bytes = await fetch(whichContract.wasm).then((res) => res.arrayBuffer())
		const contractAccount = getAccountWithMain(contractId)
		await contractAccount.deployContract(new Uint8Array(bytes))
	} catch(e) {
		throw e
	} finally {
		update('app.loading', false)
	}
}

export const addContract = (update) => {
	const contractId = window.prompt(`Enter contract account ID e.g. contract.near`)
	if (!contractId || !contractId.length) return
	insertAppDataArr(update, 'contracts', contractId)
}
'''
'''--- src/state/deploy.js ---
import { get, set, del } from '../utils/store'

import { parseSeedPhrase } from 'near-seed-phrase'
import { insertAppDataArr } from "../state/app";
import { contractId, accountExists, accountSuffix, txStatus, getState, getAccountWithMain, viewMethod } from "../state/near";
import { parseNearAmount } from "near-api-js/lib/utils/format";

import { nftSimple } from "../data/nft-simple";
import { nftSeries } from "../data/nft-series";

export const contracts = {
	nftSimple,
	nftSeries,
}

export const contractBySpec = (spec) => Object.values(contracts).find(({ form: { __spec } }) => __spec === spec)

const DEPLOY = `__DEPLOY`

export const checkDeploy = async ({ state, wallet, update }) => {

	const deploy = get(DEPLOY)
	if (!deploy) return update('app.loading', false)

	const { new_account_id, new_public_key, values } = deploy
	const { contracts } = state.app.data

	/// check if contract account was created yet

	if (!contracts || !contracts.includes(deploy.new_account_id)) {

		/// have a proxy key to create account?

		let keyInfo
		try {
			keyInfo = await viewMethod({
				methodName: 'get_key_information',
				args: {
					key: new_public_key
				}
			})
		} catch (e) {
			console.warn(e)
			throw e
		}

		if (!keyInfo) {
			try {
				await wallet.functionCall({
					contractId,
					methodName: `create_drop`,
					gas: '100000000000000',
					args: {
						public_keys: [new_public_key],
						deposit_per_use: parseNearAmount(values.NEAR.toString() || '5'),
						drop_config: {
							max_claims_per_key: 1,
						}
					}
				})
			} catch (e) {
				if (/No user balance|Not enough attached/.test(e.toString())) {
					del(DEPLOY)
					return alert('Not enough NEAR in account')
				}
				throw e
			}
		}

		/// NOTE could have been front run on account_id if it was attempted before

		if (!(await accountExists(deploy.new_account_id))) {
			const claimAccount = getAccountWithMain(contractId)

			/// could have called but page reloaded and key doesn't have enough balance, just swallow exception

			try {
				await claimAccount.functionCall({
					contractId,
					methodName: `create_account_and_claim`,
					gas: '100000000000000',
					args: {
						new_public_key,
						new_account_id
					}
				})
			} catch (e) {
				console.warn(e)
			}
		}

		if (await accountExists(deploy.new_account_id)) {
			insertAppDataArr(update, 'contracts', new_account_id)
		} else {
			alert('Could not deploy your account. Please try again!')
		}
	}

	/// check contract state

	const contractState = await getState(new_account_id)
	if (!contractState.code_hash) {
		const whichContract = contractBySpec(values.spec)
		const bytes = await fetch(whichContract.wasm).then((res) => res.arrayBuffer())
		const contractAccount = getAccountWithMain(new_account_id)
		await contractAccount.deployContract(new Uint8Array(bytes))
	}

	/// check contract initialized

	try {
		await viewMethod({ contractId: new_account_id, methodName: 'nft_tokens' })
	} catch (e) {
		if (!/The contract is not initialized/gi.test(e.toString())) {
			throw e
		}

		const contractAccount = getAccountWithMain(new_account_id)
		const res = await contractAccount.functionCall({
			contractId: new_account_id,
			methodName: 'new',
			gas: '100000000000000',
			args: {
				owner_id: wallet.accountId,
				metadata: {
					spec: values.spec,
					name: values.name,
					symbol: values.symbol,
					base_uri: 'https://cloudflare-ipfs.com/ipfs/'
				}
			}
		})
		console.log(res)

		del(DEPLOY)
	}

	update('app.loading', false)
}

export const handleDeploy = async ({ seedPhrase, values }) => {

	/// validation

	// try {
	// 	Object.keys(data).forEach((k) => {
	// 		if (values[k] || values[k].length > 0) return
	// 		throw `Missing value ${k}`
	// 	})
	// } catch (e) {
	// 	return alert(e)
	// }

	// __spec was a hidden field in values
	values.spec = values.__spec

	const new_account_id = values.contract_id + accountSuffix
	if (await accountExists(new_account_id)) {
		update('app.loading', false)
		return alert(`Account ${new_account_id} exists. Try again!`)
	}
	const new_public_key = parseSeedPhrase(seedPhrase).publicKey.toString()

	set(DEPLOY, { new_account_id, new_public_key, values })
}
'''
'''--- src/state/drops.js ---
import * as nearAPI from 'near-api-js';
const { KeyPair } = nearAPI
import { parseSeedPhrase, generateSeedPhrase } from "near-seed-phrase"
import { gas, contractId, getClaimAccount } from './near'

const hashBuf = (str) => crypto.subtle.digest('SHA-256', new TextEncoder().encode(str))

export const claimDrop = async (accountId, secretKey) => {
	const claimAccount = getClaimAccount(secretKey)
	const res = await claimAccount.functionCall({
		contractId,
		methodName: 'claim',
		args: {
			account_id: accountId
		},
		gas,
	})
	return res
}

export const genKeys = async (seedPhrase, num, drop_id, nonce = 0) => {
	const { secretKey } = parseSeedPhrase(seedPhrase)
	const keys = []
	for (let i = nonce; i < nonce + num; i++) {
		const hash = await hashBuf(`${secretKey}_${drop_id}_${i}`)
		const { secretKey: s } = generateSeedPhrase(hash)
		keys.push(KeyPair.fromString(s))
	}
	return keys
}

export const matchKeys = async (seedPhrase, drop_id, keys) => {
	const { secretKey } = parseSeedPhrase(seedPhrase)
	const keyPairs = []
	if (keys.length === 0) return keyPairs
	await Promise.all(keys.map(async (key) => {
		const hash = await hashBuf(`${secretKey}_${drop_id}_${key.key_id}`)
		const { secretKey: s } = generateSeedPhrase(hash)
		const keyPair = KeyPair.fromString(s)
		keyPairs.push(keyPair)
	}))
	return keyPairs
}
'''
'''--- src/state/near.js ---
import * as nearAPI from 'near-api-js';
const { KeyPair } = nearAPI
import { formatNearAmount } from "near-api-js/lib/utils/format";
import { near, connection, networkId, keyStore, accountSuffix, contractId } from '../../utils/near-utils';
export { accountSuffix, networkId, contractId, walletUrl } from '../../utils/near-utils';
import { matchKeys } from './drops'
import { parseSeedPhrase } from 'near-seed-phrase'
import { getAppData } from './app';
import { getSelector, getAccount, viewFunction, functionCall as _functionCall } from '../utils/wallet-selector-compat'

import { initKeypom } from "keypom-js";

export const gas = '100000000000000';

export const initNear = (hasUpdate = true) => async ({ update, getState }) => {

	initKeypom({
		near,
		keypomContractId: contractId
	})

	let updateAccount
	if (hasUpdate) {
		updateAccount = async () => {
			const account = await getAccount()
	
			if (!account.accountId) return update('app.loading', false)
			
			const balance = await view('get_user_balance', { account_id: account.accountId })
	
			const drops = await view('get_drops_for_owner', { account_id: account.accountId })

			console.log('DROPS', drops)
			console.log('REGISTERED USES', drops.map(({registered_uses}) => registered_uses))
			/// TODO this has been updated with the drop nonce
			// TODO make this a key matching algo that ensures 1-1 keyPair generation for the drop keys
			// should work even when you paginate, drop.keyPairs stays synced with drop.keys
			const { seedPhrase } = getState().app.data

			if (!seedPhrase) {
				alert('Please go to Account and load your app data again.')
				return update('app.loading', false)
			}

			/// going to mutate the drop directly, wait for all updates then execute after
			await Promise.all(drops.map(async (drop) => {
				
				await Promise.all([
					(async() => {
						try {
							drop.keySupply = await view('get_key_supply_for_drop', { drop_id: drop.drop_id })
						} catch (e) {
							drop.keySupply = 0
							console.log(e)
						}
					})(),
					(async() => {
						/// TODO fix this so it's checking the keys are valid before showing them to user
						if (drop.next_key_id === 0) {
							drop.keys = []
							drop.keyPairs = []
							return
						}
						const keys = await view('get_keys_for_drop', { drop_id: drop.drop_id, from_index: '0', limit: 5 })
						drop.keys = keys.map(({ pk }) => pk)
						drop.keyPairs = await matchKeys(seedPhrase, drop.drop_id, keys)
					})()
				])
			}))
			
			const contract = {
				drops,
				balance,
				balanceFormatted: formatNearAmount(balance, 4)
			}
	
			update('', { contract })
			update('wallet.accountId', account.accountId)
			update('app.loading', false)
		}
	}

	const selector = await getSelector({
		networkId,
		contractId,
		onAccountChange: async (accountId) => {
			if (!accountId) {
				return update('app.loading', false)
			}
			console.log('Current Account:', accountId)
			if (hasUpdate) {
				updateAccount()
			}
		}
	})
	
	const account = await getAccount()
	selector.accountId = account.accountId
	selector.functionCall = _functionCall
	selector.viewFunction = viewFunction
	try {
		selector.wallet = await selector.wallet()
	} catch(e) {}
	selector.signAndSendTransaction = selector.wallet.signAndSendTransaction
	selector.signAndSendTransactions = selector.wallet.signAndSendTransactions
	/// updates the account re: the app contract
	if (hasUpdate) {
		selector.update = updateAccount
	}

	await update('', { near, wallet: selector });
};

export const accountExists = async (accountId) => {
	try {
		const account = new nearAPI.Account(connection, accountId);
		await account.state();
		return true;
	} catch(e) {
		if (!/no such file|does not exist/.test(e.toString())) {
			throw e;
		}
		return false;
	}
};

export const txStatus = (txHash) => connection.provider.txStatus(txHash, networkId);

export const getState = async (accountId) => {
	const account = new nearAPI.Account(connection, accountId);
	const state = await account.state();
	if (state.code_hash === `11111111111111111111111111111111`) state.code_hash = null
	return state
}

export const getAccountWithMain = (accountId) => {
	const account = new nearAPI.Account(connection, accountId);
	keyStore.setKey(networkId, accountId, KeyPair.fromString(parseSeedPhrase(getAppData().seedPhrase).secretKey))
	return account
}

export const getClaimAccount = (secretKey) => {
	const account = new nearAPI.Account(connection, contractId);
	keyStore.setKey(networkId, contractId, KeyPair.fromString(secretKey))
	return account
}

export const functionCall = ({ contractId, methodName, args = {} }) => {
	const account = getAccountWithMain(contractId)
	return account.functionCall({
		contractId,
		methodName,
		args,
		gas,
	})
}

export const viewMethod = ({ contractId: _contractId, methodName, args = {} }) => {
	const account = new nearAPI.Account(connection, accountSuffix.substring(1));
	return account.viewFunction(_contractId || contractId, methodName, args)
}

export const view = (methodName, args) => {
	const account = new nearAPI.Account(connection, accountSuffix.substring(1));
	return account.viewFunction(contractId, methodName, args)
}

export const call = (account, methodName, args, _gas = gas) => {
	return account.functionCall({
		contractId,
		methodName,
		args,
		gas: _gas,
	})
}
'''
'''--- src/utils/crypto.js ---

export const hash = async (string, from = 'utf8') => {
	const bytes = Buffer.from(string, from)
	const hashBuffer = await crypto.subtle.digest('SHA-256', bytes);
	const hashArray = Array.from(new Uint8Array(hashBuffer));
	const hashHex = hashArray
	  .map((bytes) => bytes.toString(16).padStart(2, '0'))
	  .join('');
	return hashHex;
}
'''
'''--- src/utils/mobile.js ---
import copy from 'copy-to-clipboard';

export const share = (text) => {
	if (navigator.share && /mobile/gi.test(window.navigator.userAgent)) {
		navigator.share({
			text
		}).catch((e) => {
			copy(text);
			return { mobile: true, error: true };
		});
		return { mobile: true };
	} else {
		copy(text);
		return { mobile: false };
	}
};
'''
'''--- src/utils/state.js ---
import React, { createContext, useReducer } from 'react';

export const State = (initialState, prefix) => {
	let updatedState = initialState;
	const getState = () => updatedState;
	const store = createContext(initialState);
	const { Provider: InnerProvider } = store;

	const updateState = (state, newState, path = '') => {
		// console.log('updateState', state, path, newState) // debugging
		if (path.length === 0) {
			const retState = { ...state }
			if (newState === null) return null
			Object.entries(newState).map(([k, v]) => {
				retState[k] = state[k] && typeof v === 'object' && !Array.isArray(v) ?
					updateState(state[k], v) : v
			})
			return retState;
		}
		const pathArr = path.split('.');
		const first = pathArr[0];
		state = { ...state };
		if (!state[first]) {
			state[first] = {};
		}
		if (pathArr.length === 1) {
			state[first] = !!newState && typeof newState === 'object' && !Array.isArray(newState) ? {
				...state[first],
				...newState
			} : newState;
		} else {
			state[first] = {
				...state[first],
				...updateState(state[first], newState, pathArr.slice(1).join('.'))
			};
		}

		return state;
	};

	const Provider = ({ children }) => {
		const [state, dispatch] = useReducer((state, payload) => {
			const { path, newState } = payload;
			if (path === undefined) {
				return state;
			}
			updatedState = updateState(state, newState, path);
			return updatedState;
		}, initialState);

		const update = (path, newState) => {
			dispatch({ path, newState });
		};
		const wrappedDispatch = (fn) => fn({ update, getState, dispatch: wrappedDispatch });

		return <InnerProvider value={{ update, state, dispatch: wrappedDispatch }}>{children}</InnerProvider>;
	};

	if (prefix) {
		return {
			[prefix + 'Store']: store,
			[prefix.substr(0, 1).toUpperCase() + prefix.substr(1) + 'Provider']: Provider,
		};
	}
    
	return { store, Provider };
};

'''
'''--- src/utils/store.js ---
export const get = window.get = (k) => {
	const v = localStorage.getItem(k);
	if (!/\{|\[/.test(v?.charAt(0))) {
		return v;
	}
	try {
		return JSON.parse(v);
	} catch (e) {
		console.warn(e);
	}
};
export const set = window.set = (k, v) => localStorage.setItem(k, typeof v === 'string' ? v : JSON.stringify(v));
export const del = window.del = (k) => localStorage.removeItem(k);

export const file = (fn, data) => {
	// Dynamically create a File
	const file = new File([data], fn);
    // Create a link and set the URL using `createObjectURL`
    const link = document.createElement('a');
    link.style.display = 'none';
    link.href = URL.createObjectURL(file);
    link.download = file.name;

    // It needs to be added to the DOM so it can be clicked
    document.body.appendChild(link);
    link.click();

    // To make this work on Firefox we need to wait
    // a little while before removing it.
    setTimeout(() => {
        URL.revokeObjectURL(link.href);
        link.parentNode.removeChild(link);
    }, 0);
}
'''
'''--- src/utils/wallet-selector-compat.ts ---
import { setupWalletSelector } from "@near-wallet-selector/core";
import { setupModal } from "@near-wallet-selector/modal-ui";
import { setupMyNearWallet } from "@near-wallet-selector/my-near-wallet";
import { setupNearWallet } from "@near-wallet-selector/near-wallet";
import { setupSender } from "@near-wallet-selector/sender";
import * as nearAPI from "near-api-js";
import BN from "bn.js";
import NearIcon from '../img/my-near-wallet-icon.svg'
import SenderIcon from '../img/sender-icon.svg'

import '../css/modal-ui.css'

const {
	Near, Account,
	keyStores: { BrowserLocalStorageKeyStore }
} = nearAPI

let network, contractId, selector, modal, wallet, init, accountId, near;

const networks = {
	mainnet: {
		networkId: 'mainnet',
		nodeUrl: 'https://rpc.mainnet.near.org',
		walletUrl: 'https://wallet.near.org',
		helperUrl: 'https://helper.mainnet.near.org'
	},
	testnet: {
		networkId: 'testnet',
		nodeUrl: 'https://rpc.testnet.near.org',
		walletUrl: 'https://wallet.testnet.near.org',
		helperUrl: 'https://helper.testnet.near.org'
	}
}

interface WalletMethodArgs {
	signerId?: string;
	contractId?: string;
	methodName?: string;
	args?: any;
	gas?: string | BN;
	attachedDeposit?: string | BN;
}

interface GetWalletSelectorArgs {
	networkId: string,
	contractId: string | null,
	onAccountChange: (accountId: string | null) => void;
}

export const getSelector = async ({
	networkId,
	contractId: _contractId,
	onAccountChange,
}: GetWalletSelectorArgs) => {
	if (init) return selector;
	init = true;

	network = networkId;
	contractId = _contractId;

	selector = await setupWalletSelector({
		network,
		debug: true,
		modules: [
			setupNearWallet(),
			setupMyNearWallet(),
			setupSender(),
		],
	});

	selector.store.observable.subscribe(async (state) => {
		const newAccountId = state.accounts[0]?.accountId
		if (newAccountId && newAccountId !== accountId) {
			accountId = newAccountId
			wallet = await selector.wallet()
			onAccountChange(accountId);
		}
	})

    modal = setupModal(selector, { contractId });

	let defaultAccountId
	try {
		wallet = await selector.wallet()
		defaultAccountId = (await wallet?.getAccounts())?.[0]?.accountId;
	} catch(e) {
		if (!/No wallet/.test(e)) throw e
		console.warn(e)
		onAccountChange(null)
	}
	if (defaultAccountId) {
		accountId = defaultAccountId;
	}
	// await onAccountChange(accountId);

	selector.signIn = () => {
		modal.show()
	}

	selector.signOut = async () => {
		await wallet.signOut().catch((err) => {
			console.log("Failed to disconnect wallet-selector");
			console.error(err);
		});
		window.location.reload()
	}

	return selector;
}

export const getNear = () => {
	if (!near) {
		near = new Near({
			...networks[network],
			deps: { keyStore: new BrowserLocalStorageKeyStore() },
		});
	}
	return near;
};

export const getAccount = async (viewAsAccountId: string | null) => {
	near = getNear();
	return new Account(near.connection, viewAsAccountId || accountId);
};

export const viewFunction = async ({
	contractId: _contractId,
	methodName,
	args = {},
}: WalletMethodArgs) => {
	if (!_contractId && !contractId) {
		throw new Error("viewFunction error: contractId undefined");
	}
	if (!methodName) {
		throw new Error("viewFunction error: methodName undefined");
	}
	const account = await getAccount(network);
	return account.viewFunction(contractId, methodName, args)
};

export const functionCall = async ({
	contractId: _contractId,
	methodName,
	args,
	gas,
	attachedDeposit,
}: WalletMethodArgs) => {
	if (!selector) {
		throw new Error("functionCall error: selector not initialized");
	}
	if (!wallet) {
		throw new Error("functionCall error: no wallet selected");
	}
	if (!_contractId && !contractId) {
		throw new Error("functionCall error: contractId undefined");
	}
	if (!methodName) {
		throw new Error("functionCall error: methodName undefined");
	}

	const res = await wallet.signAndSendTransaction({
		receiverId: _contractId || contractId,
		actions: [
			{
				type: "FunctionCall",
				params: {
					methodName,
					args: args || '',
					gas: gas?.toString() || "30000000000000",
					deposit: attachedDeposit?.toString() || undefined,
				},
			},
		],
	});
	return res
};

'''
'''--- utils/config.js ---
const contractName = process.env.REACT_APP_CONTRACT_ID || 'beta.keypom.testnet';

console.log(process.env.REACT_APP_NETWORK_ID, process.env.REACT_APP_CONTRACT_ID)

module.exports = function getConfig(network = process.env.REACT_APP_NETWORK_ID || 'testnet') {
	let config = {
		networkId: "testnet",
		nodeUrl: "https://rpc.testnet.near.org",
		walletUrl: "https://testnet.mynearwallet.com",
		helperUrl: "https://helper.testnet.near.org",
		contractName,
	};

	switch (network) {
		case 'testnet':
			config = {
				...config,
				explorerUrl: "https://explorer.testnet.near.org",
				GAS: "200000000000000",
				gas: "200000000000000",
				attachedDeposit: '10000000000000000000000', // 0.01 N (1kb storage)
				NEW_ACCOUNT_AMOUNT: '1000000000000000000000000',
				NEW_CONTRACT_AMOUNT: '5000000000000000000000000',
				contractId: contractName,
				isBrowser: new Function("try {return this===window;}catch(e){ return false;}")()
			};
			break;

		case 'mainnet':
			config = {
				...config,
				networkId: "mainnet",
				nodeUrl: "https://rpc.mainnet.near.org",
				walletUrl: "https://app.mynearwallet.com",
				helperUrl: "https://helper.near.org",
				explorerUrl: "https://explorer.near.org",
				GAS: "200000000000000",
				gas: "200000000000000",
				attachedDeposit: '10000000000000000000000', // 0.01 N (1kb storage)
				NEW_ACCOUNT_AMOUNT: '1000000000000000000000000',
				NEW_CONTRACT_AMOUNT: '5000000000000000000000000',
				contractId: contractName,
				isBrowser: new Function("try {return this===window;}catch(e){ return false;}")()
			};
			break;
	}
	return config;
};

'''
'''--- utils/near-utils.js ---
const fs = require("fs");
const nearAPI = require("near-api-js");
const getConfig = require("./config");
const { nodeUrl, walletUrl, networkId, contractId, isBrowser } = getConfig();

const {
	keyStores: { InMemoryKeyStore, BrowserLocalStorageKeyStore },
	Near,
	Account,
	Contract,
	KeyPair,
	utils: {
		format: { parseNearAmount },
	},
} = nearAPI;

let credentials, keyStore;

if (isBrowser) {
	keyStore = new BrowserLocalStorageKeyStore();
} else {
	/// nodejs (for tests)
	try {
		console.log(`Loading Credentials: ${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`);
		credentials = JSON.parse(
			fs.readFileSync(
				`${process.env.HOME}/.near-credentials/${networkId}/${contractId}.json`
			)
		);
	} catch(e) {
		console.warn(`Loading Credentials: ./neardev/${networkId}/${contractId}.json`);
		credentials = JSON.parse(
			fs.readFileSync(
				`./neardev/${networkId}/${contractId}.json`
			)
		);
	}
	keyStore = new InMemoryKeyStore();
	keyStore.setKey(
		networkId,
		contractId,
		KeyPair.fromString(credentials.private_key)
	);
}

const near = new Near({
	networkId,
	nodeUrl,
	walletUrl,
	deps: { keyStore },
});
const { connection } = near;
const contractAccount = new Account(connection, contractId);

module.exports = {
	near,
	walletUrl,
	networkId,
	accountSuffix: networkId === 'mainnet' ? '.near' : '.testnet',
	credentials,
	keyStore,
	connection,
	contractId,
	contractAccount,
};

'''
'''--- utils/patch-config.js ---
const fs = require('fs');
const contractName = fs.readFileSync('./neardev/dev-account').toString()
const path = './utils/config.js'
 
fs.readFile(path, 'utf-8', function(err, data) {
    if (err) throw err;
 
    data = data.replace(/.*const contractName.*/gim, `const contractName = '${contractName}';`);
 
    fs.writeFile(path, data, 'utf-8', function(err) {
        if (err) throw err;
        console.log('Done!');
    })
})

'''