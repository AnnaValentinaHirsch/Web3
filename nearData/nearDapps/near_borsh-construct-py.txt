*GitHub Repository "near/borsh-construct-py"*

'''--- .github/workflows/docs.yml ---
name: Docs
on:
  push:
    branches:
      - master

jobs:
  build:
    name: Deploy docs
    runs-on: ubuntu-latest
    steps:
      - name: Checkout main
        uses: actions/checkout@v2

      - name: Deploy docs
        uses: mhausenblas/mkdocs-deploy-gh-pages@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

'''
'''--- .github/workflows/tests.yml ---
name: Tests

on:
  push:
    branches: [master]
  pull_request:
    branches: [master]

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v2

      - name: Set up Python
        uses: actions/setup-python@v1
        with:
          python-version: 3.9

      - name: Run image
        uses: abatilo/actions-poetry@v2.0.0
        with:
          poetry-version: 1.1.7

      - name: Install nox-poetry
        run: pip install nox-poetry

      - name: Run tests
        run: nox

'''
'''--- .vscode/settings.json ---
{
	"python.linting.flake8Enabled": true,
	"python.linting.enabled": true,
	"python.formatting.provider": "black",
	"python.linting.mypyEnabled": true,
}
'''
'''--- CHANGELOG.md ---
# Changelog

## [0.1.0] - 2021-10-01

Initial release

'''
'''--- README.md ---
# borsh-construct

[![Tests](https://github.com/near/borsh-construct-py/workflows/Tests/badge.svg)](https://github.com/near/borsh-construct-py/actions?workflow=Tests)
[![Docs](https://github.com/near/borsh-construct-py/workflows/Docs/badge.svg)](https://near.github.io/borsh-construct-py/)

`borsh-construct` is an implementation of the [Borsh](https://borsh.io/) binary serialization format for Python projects.

Borsh stands for Binary Object Representation Serializer for Hashing. It is meant to be used in security-critical projects as it prioritizes consistency, safety, speed, and comes with a strict specification.

Read the [Documentation](https://near.github.io/borsh-construct-py/).
## Installation

```sh
pip install borsh-construct

```

### Development Setup

1. Install [poetry](https://python-poetry.org/docs/#installation)
2. Install dev dependencies:
```sh
poetry install

```
3. Install [nox-poetry](https://github.com/cjolowicz/nox-poetry) (note: do not use Poetry to install this, see [here](https://medium.com/@cjolowicz/nox-is-a-part-of-your-global-developer-environment-like-poetry-pre-commit-pyenv-or-pipx-1cdeba9198bd))
4. Activate the poetry shell:
```sh
poetry shell

```

### Quick Tests
```sh
pytest

```

### Full Tests
```sh
nox

```

'''
'''--- docs/defining_new_types.md ---
# Defining New Types

You can build new schemas on top of `borsh-construct` using [`construct.Adapter`](https://construct.readthedocs.io/en/latest/adapters.html#adapting).

For example, here we implement (de)serialization for Python's `Fraction` class:

```python
from typing import Tuple
from fractions import Fraction
from construct import Adapter
from borsh_construct import I32, TupleStruct

class Frac(Adapter):
    def __init__(self, int_type) -> None:
        super().__init__(TupleStruct(int_type, int_type))  # type: ignore

    def _encode(self, obj: Fraction, context, path) -> Tuple[int, int]:
        return obj.numerator, obj.denominator

    def _decode(self, obj: Tuple[int, int], context, path) -> Fraction:
        numerator, denominator = obj
        return Fraction(numerator, denominator)

frac = Frac(I32)
to_serialize = Fraction(10, 3)
assert frac.parse(frac.build(to_serialize)) == to_serialize

```

'''
'''--- docs/img/bowl-mix.svg ---
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="m16.2 11 4.1-6.5 1.7 1-3.4 5.5h-2.4m-.6 1H2v3c0 3.9 3.1 7 7 7h6c3.9 0 7-3.1 7-7v-3h-6.4z"/></svg>
'''
'''--- docs/index.md ---
# Introduction

`borsh-construct` is an implementation of the [Borsh](https://borsh.io/) binary serialization format for Python projects.

Borsh stands for Binary Object Representation Serializer for Hashing. It is meant to be used in security-critical projects as it prioritizes consistency, safety, speed, and comes with a strict specification.

`borsh-construct` is built on top of the very powerful [`construct`](https://construct.readthedocs.io/en/latest/) library, so it is strongly recommended that you have a look at the basics of `construct` before using `borsh-construct`.

## Who is this for?

This library was built with the NEAR and Solana blockchains in mind: the only obvious reason to use `borsh-construct` currently is to write client code for those blockchains, as they typically expect Borsh serialization.

You may find other reasons to use `borsh-construct`, but it is worth noting that the Borsh spec is written from a Rust perspective, so if you're not interacting with a Rust project then Borsh may not make sense.

## Installation

`pip install borsh-construct`

Alternatively, using conda/mamba:

`mamba install borsh-construct -c conda-forge`

## Usage

Since `borsh-construct` is built with `construct`, it serializes objects using `.build` and deserializes them using `.parse`. For example:

```python
>>> from borsh_construct import U8, String, CStruct
>>> animal = CStruct(
...     "name" / String,
...     "legs" / U8
... )
>>> animal.build({"name": "Ferris", "legs": 6})
b'\x06\x00\x00\x00Ferris\x06'
>>> animal.parse(b'\x06\x00\x00\x00Ferris\x06')
Container(name=u'Ferris', legs=6)

```

'''
'''--- docs/types.md ---
This is an outline of all the types supported by `borsh-construct`. Since Borsh is Rust-centric, some Rust snippets are included to make it clear what the equivalent Rust type is.

## Numeric types

All numeric types mentioned in the Borsh spec are supported:

- Unsigned integers: U8, U16, U32, U64, U128
- Signed integers: I8, I16, I32, I64, I128
- Floats: F32, F64
- Bool (this is not explicitly part of the spec, but `borsh-rs` implements Bool as a `u8` with value 0 or 1)

Example:

```python
>>> from borsh_construct import U32
>>> U32.build(42)
b'*\x00\x00\x00'
>>> U32.parse(b'*\x00\x00\x00')
42

```

!!! note

    Most of the numeric types come directly from the `construct` library, and are just aliased so that they match the Borsh spec. For example, `borsh_construct.U8` is really `construct.Int8ul`.

## Fixed sized arrays

`construct` gives us a nice `[]` syntax to represent fixed sized arrays. For example, an array of 3 u8 integers:

```python
>>> from borsh_construct import U8
>>> U8[3].build([1, 2, 3])
b'\x01\x02\x03'
>>> U8[3].parse(b'\x01\x02\x03')
ListContainer([1, 2, 3])

```

This is what that fixed size array looks like in Rust:

```rust
let arr = [1u8, 2, 3];

```

## Dynamic sized arrays

Dynamic arrays are implemented using the `Vec` function:

```python
>>> from borsh_construct import Vec, U8
>>> Vec(U8).build([1, 2, 3])
b'\x03\x00\x00\x00\x01\x02\x03'
>>> Vec(U8).parse(b'\x03\x00\x00\x00\x01\x02\x03')
ListContainer([1, 2, 3])

```

In Rust we could build that vector like this:

```rust
let v = vec![1u8, 2, 3];

```

## C-like structs

This is analogous to a Rust struct with named fields:

```python
>>> from borsh_construct import CStruct, String, U8
>>> person = CStruct(
...     "name" / String,
...     "age" / U8
... )
>>> person.build({"name": "Alice", "age": 50})
b'\x05\x00\x00\x00Alice2'
>>> person.parse(b'\x05\x00\x00\x00Alice2')
Container(name=u'Alice', age=50)

```
Rust type:
```rust
struct Person {
    name: String,
    age: u8,
}

```

## Tuple structs
```python
>>> from borsh_construct import TupleStruct, I32, F32
>>> pair = TupleStruct(I32, F32)
>>> pair.build([3, 0.5])
b'\x03\x00\x00\x00\x00\x00\x00?'
>>> pair.parse(b'\x03\x00\x00\x00\x00\x00\x00?')
ListContainer([3, 0.5])

```
Rust type:
```rust
struct Pair(i32, f32);

```

## Enum

Rust's `enum` is the trickiest part of `borsh-construct` because it's rather different from Python's `enum.Enum`. Under the hood, `borsh-construct` uses the [`sumtypes`](https://sumtypes.readthedocs.io/en/latest/) library to represent Rust enums in Python.

Notice below how our `message` object has a `.enum` attribute: this is the Python imitation of Rust's enum type.

Defining an enum:

```python
>>> from borsh_construct import Enum, I32, CStruct, TupleStruct, String
>>> message = Enum(
...     "Quit",
...     "Move" / CStruct("x" / I32, "y" / I32),
...     "Write" / TupleStruct(String),
...     "ChangeColor" / TupleStruct(I32, I32, I32),
...     enum_name="Message",
... )
>>> message.build(message.enum.Quit())
b'\x00'
>>> message.parse(b'\x00')
Message.Quit()
>>> message.build(message.enum.Move(x=1, y=3))
b'\x01\x01\x00\x00\x00\x03\x00\x00\x00'
>>> message.parse(b'\x01\x01\x00\x00\x00\x03\x00\x00\x00')
Message.Move(x=1, y=3)
>>> message.build(message.enum.Write(("hello",)))
b'\x02\x05\x00\x00\x00hello'
>>> message.parse(b'\x02\x05\x00\x00\x00hello')
Message.Write(tuple_data=ListContainer(['hello']))
>>> message.build(message.enum.ChangeColor((1, 2, 3)))
b'\x03\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'
>>> message.parse(b'\x03\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00')
Message.ChangeColor(tuple_data=ListContainer([1, 2, 3]))

```

Notice also how each variant of the enum is a subclass of the enum itself:

```python
>>> assert isinstance(message.enum.Quit(), message.enum)

```

Rust type:
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

## HashMap

You can think of HashMap as a Python dictionary as long as the keys and values have a well-defined type.

```python
>>> from borsh_construct import HashMap, String, U32
>>> scores = HashMap(String, U32)
>>> scores.build({"Blue": 10, "Yellow": 50})
b'\x02\x00\x00\x00\x04\x00\x00\x00Blue\n\x00\x00\x00\x06\x00\x00\x00Yellow2\x00\x00\x00'
>>> scores.parse(b'\x02\x00\x00\x00\x04\x00\x00\x00Blue\n\x00\x00\x00\x06\x00\x00\x00Yellow2\x00\x00\x00')
{'Blue': 10, 'Yellow': 50}

```
Rust type:
```rust
fn main() {
    use std::collections::HashMap;

    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);
}
```

## HashSet

The HashSet is similar to a Python `set` with a well-defined type.

```python
>>> from borsh_construct import HashSet, I32
>>> a = HashSet(I32)
>>> a.build({1, 2, 3})
b'\x03\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00'
>>> a.parse(b'\x03\x00\x00\x00\x01\x00\x00\x00\x02\x00\x00\x00\x03\x00\x00\x00')
{1, 2, 3}

```
Rust type:
```rust
use std::collections::HashSet;

fn main() {
    let mut a: HashSet<i32> = vec![1i32, 2, 3].into_iter().collect();
}

```

## Option

Rust programmers will notice that our Option type is not implemented like a Rust enum, because it's not worth the complexity.

```python
>>> from borsh_construct import Option, U8
>>> optional_num = Option(U8)
>>> optional_num.build(None)
b'\x00'
>>> optional_num.parse(b'\x00') is None
True
>>> optional_num.build(3)
b'\x01\x03'
>>> optional_num.parse(b'\x01\x03')
3

```
Rust type:
```rust
Option<u8>
```

## Bytes

The Borsh spec doesn't specifically mention serializing raw bytes, but it's worth including anyway:

```python
>>> from borsh_construct import Bytes
>>> Bytes.build(bytes([1, 2, 3]))
b'\x03\x00\x00\x00\x01\x02\x03'
>>> Bytes.parse(b'\x03\x00\x00\x00\x01\x02\x03')
b'\x01\x02\x03'

```
Rust type:
```rust
vec![1u8, 2, 3]

```

## String

Python:

```python
>>> from borsh_construct import String
>>> String.build("🚀🚀🚀")
b'\x0c\x00\x00\x00\xf0\x9f\x9a\x80\xf0\x9f\x9a\x80\xf0\x9f\x9a\x80'
>>> String.parse(b'\x0c\x00\x00\x00\xf0\x9f\x9a\x80\xf0\x9f\x9a\x80\xf0\x9f\x9a\x80')
'🚀🚀🚀'

```

Rust type:

```rust
String::from("🚀🚀🚀")

```

'''
'''--- mkdocs.yml ---
site_name: borsh-construct
theme:
  name: material
  icon:
    logo: material/bowl-mix
  favicon: img/bowl-mix.svg
  palette:
    - scheme: default
      primary: lime
      toggle:
        icon: material/toggle-switch-off-outline
        name: Switch to dark mode
    - scheme: slate
      toggle:
        icon: material/toggle-switch
        name: Switch to light mode
  custom_dir: overrides
markdown_extensions:
  - pymdownx.highlight
  - pymdownx.superfences
  - admonition
repo_url: https://github.com/near/borsh-construct-py
repo_name: near/borsh-construct-py
site_url: https://near.github.io/borsh-construct-py/
nav:
  - index.md
  - types.md
  - defining_new_types.md

'''
'''--- noxfile.py ---
from nox_poetry import session  # type: ignore

@session(python=["3.9", "3.8.3"])
def tests(session):  # noqa: D103,WPS442
    session.run_always("poetry", "install", external=True)
    session.install(".")
    session.run("pytest", external=True)

'''
'''--- overrides/main.html ---
{% extends "base.html" %}

{% block extrahead %}
<meta name="google-site-verification" content="gKb0euQxz-JHX0YpuGjh8ws4phjC7dZiXnHd84lNFxA" />
{% endblock %}
'''
'''--- poetry.toml ---
[virtualenvs]
in-project = true

'''
'''--- pyproject.toml ---
[tool.poetry]
name = "borsh-construct"
version = "0.1.0"
description = "Python implementation of Borsh serialization, built on the Construct library."
authors = ["kevinheavey <kevinheavey123@gmail.com>"]
license = "MIT"
homepage = "https://github.com/near/borsh-construct-py"
repository = "https://github.com/near/borsh-construct-py"
readme = "README.md"

[tool.poetry.dependencies]
python = "^3.8.3"
construct-typing = "^0.5.1"
sumtypes = "^0.1a5"

[tool.poetry.dev-dependencies]
pytest = "^5.2"
wemake-python-styleguide = "^0.15.3"
mypy = "^0.910"
black = "^21.7b0"
pydocstyle = "^6.1.1"
isort = "^5.9.3"
coverage = {extras = ["toml"], version = "^5.5"}
pytest-cov = "^2.12.1"
mkdocs = "^1.2.2"
mkdocs-material = "^7.2.6"
flake8 = "^3.9.2"
pytest-flake8 = "^1.0.7"
pytest-mypy = "^0.8.1"
hypothesis = "^6.23.0"

[build-system]
requires = ["poetry-core>=1.0.0"]
build-backend = "poetry.core.masonry.api"

[tool.coverage.paths]
source = ["src", "*/site-packages"]

[tool.coverage.run]
branch = true
source = ["borsh_construct"]

[tool.coverage.report]
show_missing = true
fail_under = 100

'''
'''--- src/borsh_construct/__init__.py ---
from importlib.metadata import version, PackageNotFoundError
from construct import Flag as Bool
from construct import Int8sl as I8
from construct import Int16sl as I16
from construct import Int16ul as U16
from construct import Int32sl as I32
from construct import Int64sl as I64
from construct import Int64ul as U64

from .core import (
    F32,
    F64,
    I128,
    U8,
    U32,
    U128,
    Vec,
    CStruct,
    TupleStruct,
    Bytes,
    String,
    Option,
    HashMap,
    HashSet,
)
from .enum import Enum

try:
    __version__ = version(__name__)
except PackageNotFoundError:  # pragma: no cover
    __version__ = "unknown"

__all__ = [
    "I8",
    "I16",
    "I32",
    "U8",
    "I64",
    "I128",
    "U16",
    "U32",
    "U64",
    "U128",
    "F32",
    "F64",
    "Bool",
    "Vec",
    "CStruct",
    "TupleStruct",
    "Bytes",
    "String",
    "Enum",
    "Option",
    "HashMap",
    "HashSet",
]

'''
'''--- src/borsh_construct/core.py ---
from typing import Any, Optional, List, Tuple
from math import isnan
from construct import Adapter, Array, BytesInteger, Construct
from construct import singleton  # type: ignore
from construct import FormatField, FormatFieldError, GreedyBytes, IfThenElse
from construct import Int8ul as U8
from construct import Int32ul as U32
from construct import Pass, Prefixed, PrefixedArray
from construct import Sequence
from construct import Struct

TUPLE_DATA = "tuple_data"

NAMED_TUPLE_FIELD_ERROR = ValueError("TupleStruct cannot have named fields")
UNNAMED_SUBCON_ERROR = ValueError("CStruct fields and enum variants must be named")
NON_STR_NAME_ERROR = ValueError("Names must be strings.")
TUPLE_DATA_NAME_ERROR = ValueError(
    f"The name {TUPLE_DATA} is reserved. If you encountered this "
    "error it's either a wild coincidence or you're "
    "doing it wrong."  # noqa: C812
)
UNDERSCORE_NAME_ERROR = ValueError("names cannot start with an underscore.")
U128 = BytesInteger(16, signed=False, swapped=True)
I128 = BytesInteger(16, signed=True, swapped=True)

class TupleStruct(Sequence):
    """Python implementation of Rust tuple struct."""

    def __init__(self, *subcons) -> None:
        super().__init__(*subcons)  # type: ignore
        for subcon in self.subcons:
            if subcon.name is not None:
                raise NAMED_TUPLE_FIELD_ERROR

class CStruct(Struct):
    """Python implementation of Rust C-like struct."""

    def __init__(self, *subcons) -> None:
        super().__init__(*subcons)
        for subcon in subcons:
            check_subcon_name(subcon.name)

def _check_name_not_null(name: Optional[str]) -> None:
    if name is None:
        raise UNNAMED_SUBCON_ERROR

def check_subcon_name(name: Optional[str]) -> None:
    """Check that CStructs and Enums have valid names."""  # noqa: DAR101
    _check_name_not_null(name)
    if not isinstance(name, str):
        raise NON_STR_NAME_ERROR
    if name == TUPLE_DATA:
        raise TUPLE_DATA_NAME_ERROR
    if name[0] == "_":
        raise UNDERSCORE_NAME_ERROR

class FormatFieldNoNan(FormatField):
    """Adapted form of `construct.FormatField` that forbids nan."""

    def _parse(self, stream, context, path):
        result = super()._parse(stream, context, path)
        if isnan(result):
            raise FormatFieldError("Borsh does not support nan.")
        return result

    def _build(self, obj, stream, context, path):
        if isnan(obj):
            raise FormatFieldError("Borsh does not support nan.")
        return super()._build(obj, stream, context, path)

@singleton
def F32() -> FormatFieldNoNan:  # noqa: N802
    """Little endian, 32-bit IEEE floating point number."""
    return FormatFieldNoNan("<", "f")

@singleton
def F64() -> FormatFieldNoNan:  # noqa: N802
    """Little endian, 64-bit IEEE floating point number."""
    return FormatFieldNoNan("<", "d")

def Vec(subcon: Construct) -> Array:  # noqa: N802
    """Dynamic sized array.

    Args:
        subcon (Construct): the type of the array members.

    Returns:
        Array: a Construct PrefixedArray.
    """
    return PrefixedArray(U32, subcon)

Bytes = Prefixed(U32, GreedyBytes)

class _String(Adapter):
    def __init__(self) -> None:
        super().__init__(Bytes)  # type: ignore

    def _decode(self, obj: bytes, context, path) -> str:
        return obj.decode("utf8")

    def _encode(self, obj: str, context, path) -> bytes:
        return bytes(obj, "utf8")

String = _String()

class Option(Adapter):
    """Borsh implementation for Rust's Option type."""

    _discriminator_key = "discriminator"
    _value_key = "value"

    def __init__(self, subcon: Construct) -> None:
        option_struct = CStruct(
            self._discriminator_key / U8,
            self._value_key
            / IfThenElse(lambda this: this[self._discriminator_key] == 0, Pass, subcon),
        )
        super().__init__(option_struct)  # type: ignore

    def _decode(self, obj, context, path) -> Any:
        return obj[self._value_key]

    def _encode(self, obj, context, path) -> dict:
        discriminator = 0 if obj is None else 1
        return {self._discriminator_key: discriminator, self._value_key: obj}

class HashMap(Adapter):
    """Borsh implementation for Rust HashMap."""

    def __init__(self, key_subcon: Construct, value_subcon: Construct) -> None:
        super().__init__(
            PrefixedArray(U32, TupleStruct(key_subcon, value_subcon)),
        )  # type: ignore

    def _decode(self, obj: List[Tuple[Any, Any]], context, path) -> dict:
        return dict(obj)

    def _encode(self, obj, context, path) -> List[Tuple]:
        return sorted(obj.items())

class HashSet(Adapter):
    """Python implementation of Rust HashSet."""

    def __init__(self, subcon: Construct) -> None:
        super().__init__(PrefixedArray(U32, subcon))  # type: ignore

    def _decode(self, obj, context, path) -> set:
        return set(obj)

    def _encode(self, obj, context, path) -> list:
        return sorted(obj)

'''
'''--- src/borsh_construct/enum.py ---
from __future__ import annotations
from typing import List, Tuple, Union, cast, Any, Dict
from sumtypes import sumtype, constructor
from construct import Pass, Renamed, Adapter, Switch, Container, Construct
import attr

from .core import CStruct, TupleStruct, U8, TUPLE_DATA, check_subcon_name

def _rust_enum(klass):
    indexed = sumtype(klass)
    for idx, cname in enumerate(indexed._sumtype_constructor_names):  # noqa: WPS437
        constructr = getattr(indexed, cname)
        constructr.index = idx

    # __getitem__ magic method cannot be classmethod
    @classmethod
    def getitem(cls, _index: int):  # noqa: WPS614
        return getattr(cls, cls._sumtype_constructor_names[_index])

    indexed.getitem = getitem

    return indexed

def _tuple_struct():
    return constructor(**{TUPLE_DATA: attr.ib(type=tuple)})

def _unit_struct():
    return constructor()

def _clike_struct(*fields: str):
    return constructor(*fields)

def _handle_cstruct_variant(underlying_variant, variant_name) -> Tuple[str, Any]:
    subcon_names: List[str] = []
    for s in underlying_variant.subcons:
        name = s.name
        subcon_names.append(cast(str, name))
    return variant_name, _clike_struct(*subcon_names)

def _handle_struct_variant(variant) -> Tuple[str, Any]:
    variant_name = variant.name
    check_subcon_name(variant_name)
    underlying_variant = variant.subcon if isinstance(variant, Renamed) else variant
    if isinstance(underlying_variant, TupleStruct):
        return variant_name, _tuple_struct()
    elif isinstance(underlying_variant, CStruct):
        return _handle_cstruct_variant(underlying_variant, variant_name)
    variant_type = type(underlying_variant)
    raise ValueError(f"Unrecognized variant type: {variant_type}")

def _make_cls_dict(*variants) -> dict:  # noqa: WPS210
    result = {"__doc__": "Python representation of Rust's Enum type."}
    seen_variant_names = set()
    for variant in variants:
        if isinstance(variant, str):
            variant_name = variant
            result[variant] = _unit_struct()
        else:
            variant_name = variant.name
            key, val = _handle_struct_variant(variant)
            result[key] = val
        if variant_name in seen_variant_names:
            raise ValueError("Enum variant names must be unique.")
        seen_variant_names.add(variant_name)
    return result

def _make_enum(*variants, name: str):
    klass = type(name, (object,), _make_cls_dict(*variants))
    return _rust_enum(klass)

class Enum(Adapter):
    """Borsh representation of Rust's enum type."""

    _index_key = "index"
    _value_key = "value"

    def __init__(self, *variants: Union[str, Construct], enum_name: str) -> None:
        """Init enum.

        Note: unlike other types, you must use the `enum_name` keyword argument
        to give your Enum a name when instantiating it.
        """  # noqa: DAR101
        switch_cases = {}
        for idx, var in enumerate(variants):
            if isinstance(var, str):
                parser = Pass
            else:
                parser = var
            switch_cases[idx] = parser
        enum_struct = CStruct(
            self._index_key / U8,
            self._value_key / Switch(lambda this: this.index, switch_cases),
        )
        super().__init__(enum_struct)  # type: ignore
        self.variants = variants
        self.enum_name = enum_name
        self.enum = _make_enum(*variants, name=enum_name)

    def _decode(self, obj: Any, context, path) -> Any:
        index = obj.index
        enum_variant = self.enum.getitem(index)
        val = obj.value
        if val is None:
            return enum_variant()
        if isinstance(val, Container):
            return enum_variant(**{k: v for k, v in val.items() if k != "_io"})
        return enum_variant(val)

    def _encode(self, obj: Any, context, path) -> Dict[str, Any]:
        index = obj.index
        as_dict = attr.asdict(obj)
        if as_dict:
            try:
                to_build = as_dict[TUPLE_DATA]
            except KeyError:
                to_build = as_dict
        else:
            to_build = None
        return {self._index_key: index, self._value_key: to_build}

'''
'''--- tests/__init__.py ---
"""Unit tests."""

'''
'''--- tests/conftest.py ---
import logging

def pytest_configure(config):
    """Flake8 is very verbose by default. Silence it."""  # noqa: DAR101
    logging.getLogger("flake8").setLevel(logging.ERROR)

'''
'''--- tests/test_core.py ---
"""Core tests."""
from typing import Any

import pytest
from borsh_construct import (
    F32,
    F64,
    I8,
    I16,
    I32,
    I64,
    I128,
    U8,
    U16,
    U32,
    U64,
    U128,
    Bool,
    Vec,
    CStruct,
    TupleStruct,
    Enum,
    String,
    Option,
    HashMap,
    HashSet,
    Bytes,
)
from borsh_construct.core import (
    NAMED_TUPLE_FIELD_ERROR,
    TUPLE_DATA,
    UNNAMED_SUBCON_ERROR,
    NON_STR_NAME_ERROR,
    UNDERSCORE_NAME_ERROR,
    TUPLE_DATA_NAME_ERROR,
)
from construct import Construct, Float32l, Float64l, FormatField, FormatFieldError

ENUM = Enum(
    "Unit",
    "TupleVariant" / TupleStruct(U128, String, I64, Option(U16)),
    "CStructVariant"
    / CStruct("u128_field" / U128, "string_field" / String, "vec_field" / Vec(U16)),
    enum_name="Placeholder",
)

TYPE_INPUT_EXPECTED = (
    (Bool, True, [1]),
    (Bool, False, [0]),
    (U8, 255, [255]),
    (I8, -128, [128]),
    (U16, 65535, [255, 255]),
    (I16, -32768, [0, 128]),
    (U32, 4294967295, [255, 255, 255, 255]),
    (I32, -2147483648, [0, 0, 0, 128]),
    (U64, 18446744073709551615, [255, 255, 255, 255, 255, 255, 255, 255]),
    (I64, -9223372036854775808, [0, 0, 0, 0, 0, 0, 0, 128]),
    (
        U128,
        340282366920938463463374607431768211455,
        [
            255,
            255,
            255,
            255,
            255,
            255,
            255,
            255,
            255,
            255,
            255,
            255,
            255,
            255,
            255,
            255,
        ],
    ),
    (
        I128,
        -170141183460469231731687303715884105728,
        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128],
    ),
    (F32, 0.5, [0, 0, 0, 63]),
    (F64, -0.5, [0, 0, 0, 0, 0, 0, 224, 191]),
    (I16[3], [1, 2, 3], [1, 0, 2, 0, 3, 0]),
    (Vec(I16), [1, 1], [2, 0, 0, 0, 1, 0, 1, 0]),
    (
        TupleStruct(U128, String, I64, Option(U16)),
        [123, "hello", 1400, 13],
        [
            123,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            0,
            104,
            101,
            108,
            108,
            111,
            120,
            5,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            13,
            0,
        ],
    ),
    (
        CStruct("u128_field" / U128, "string_field" / String, "vec_field" / Vec(U16)),
        {"u128_field": 1033, "string_field": "hello", "vec_field": [1, 2, 3]},
        [
            9,
            4,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            0,
            104,
            101,
            108,
            108,
            111,
            3,
            0,
            0,
            0,
            1,
            0,
            2,
            0,
            3,
            0,
        ],
    ),
    (ENUM, ENUM.enum.Unit(), [0]),
    (
        ENUM,
        ENUM.enum.TupleVariant([10, "hello", 13, 12]),
        [
            1,
            10,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            0,
            104,
            101,
            108,
            108,
            111,
            13,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            1,
            12,
            0,
        ],
    ),
    (
        ENUM,
        ENUM.enum.CStructVariant(
            u128_field=15,
            string_field="hi",
            vec_field=[3, 2, 1],
        ),
        [
            2,
            15,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            0,
            0,
            0,
            104,
            105,
            3,
            0,
            0,
            0,
            3,
            0,
            2,
            0,
            1,
            0,
        ],
    ),
    (
        HashMap(U8, ENUM),
        {2: ENUM.enum.Unit(), 1: ENUM.enum.TupleVariant([11, "hello", 123, None])},
        [
            2,
            0,
            0,
            0,
            1,
            1,
            11,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            5,
            0,
            0,
            0,
            104,
            101,
            108,
            108,
            111,
            123,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            2,
            0,
        ],
    ),
    (HashSet(U8), {1, 2, 3}, [3, 0, 0, 0, 1, 2, 3]),
    (Bytes, b"\x01\x02\x03", [3, 0, 0, 0, 1, 2, 3]),
    (
        String,
        "🚀🚀🚀",
        [12, 0, 0, 0, 240, 159, 154, 128, 240, 159, 154, 128, 240, 159, 154, 128],
    ),
)

@pytest.mark.parametrize("obj_type,obj_input,expected", TYPE_INPUT_EXPECTED)
def test_serde(obj_type: Construct, obj_input: Any, expected: Any) -> None:
    """Tests that inputs are serialized and deserialized as expected."""
    serialized = obj_type.build(obj_input)
    assert list(serialized) == expected
    deserialized = obj_type.parse(serialized)
    assert deserialized == obj_input

@pytest.mark.parametrize(
    "nonan_type,construct_type",
    [(F32, Float32l), (F64, Float64l)],
)
def test_nan_floats(nonan_type: FormatField, construct_type: FormatField) -> None:
    """Check that error is raised if you try to build or parse nan floats."""
    nan = float("nan")  # noqa: WPS456
    with pytest.raises(FormatFieldError):
        nonan_type.build(nan)
    nan_serialized = construct_type.build(nan)
    with pytest.raises(FormatFieldError):
        nonan_type.parse(nan_serialized)

def test_named_tuple_struct_field_raises() -> None:
    """Check that error is raised if TupleStruct field is named."""
    with pytest.raises(ValueError) as exc:
        TupleStruct("foo" / U8)
    assert exc.value == NAMED_TUPLE_FIELD_ERROR

def test_unnamed_subcon_raises() -> None:
    """Check that error is raised when enum variant or CStruct field is unnamed."""
    with pytest.raises(ValueError) as excinfo:
        Enum("foo", TupleStruct(U8), enum_name="placeholder")
    assert str(excinfo.value) == str(UNNAMED_SUBCON_ERROR)

def test_non_str_name_raises() -> None:
    """Check that error is raised when subcon name is not a string."""
    with pytest.raises(ValueError) as excinfo:
        CStruct(1 / U8)  # type: ignore
    assert str(excinfo.value) == str(NON_STR_NAME_ERROR)

def test_tuple_data_name_raises() -> None:
    """Check that error is raised when subcon name is not a string."""
    with pytest.raises(ValueError) as excinfo:
        CStruct(TUPLE_DATA / U8)
    assert str(excinfo.value) == str(TUPLE_DATA_NAME_ERROR)

def test_underscore_name_raises() -> None:
    """Check that error is raised when subcon name starts with underscore."""
    with pytest.raises(ValueError) as excinfo:
        CStruct("_foo" / U8)
    assert str(excinfo.value) == str(UNDERSCORE_NAME_ERROR)

def test_unrecognized_variant_type_raises() -> None:
    """Check that error is raised if variant type is not valid."""
    with pytest.raises(ValueError) as excinfo:
        Enum("foo" / U8, enum_name="placeholder")
    assert "Unrecognized" in str(excinfo.value)

def test_duplicate_variant_name_raises() -> None:
    """Check error raised if two variants in same Enum have same name."""
    with pytest.raises(ValueError) as excinfo:
        Enum("foo", "foo", enum_name="placeholder")
    assert "must be unique" in str(excinfo.value)

'''
'''--- tests/test_hypothesis.py ---
from hypothesis import given
import hypothesis.strategies as st

from borsh_construct import (
    U8,
    I8,
    U16,
    I16,
    U32,
    I32,
    U64,
    I64,
    U128,
    I128,
    F32,
    F64,
    String,
    Bytes,
    HashMap,
    HashSet,
    Vec,
    Option,
)

borsh_simple_types = (
    U8,
    I8,
    U16,
    I16,
    U32,
    I32,
    U64,
    I64,
    U128,
    I128,
    F32,
    F64,
    Bytes,
    String,
)
borsh_compound_types = (
    HashMap,
    HashSet,
    Vec,
    Option,
)

@given(st.text())
def test_string(s):
    """Test string encoding/decoding."""
    assert String.parse(String.build(s)) == s

u8_ints = st.integers(0, 255)
i8_ints = st.integers(-128, 127)
u16_ints = st.integers(0, 65535)
i16_ints = st.integers(-32768, 32767)
u32_ints = st.integers(0, 4294967295)
i32_ints = st.integers(-2147483648, 2147483647)
u64_ints = st.integers(0, 18446744073709551615)
i64_ints = st.integers(-9223372036854775808, 9223372036854775807)
u128_ints = st.integers(0, 340282366920938463463374607431768211455)
i128_ints = st.integers(
    -170141183460469231731687303715884105728,
    170141183460469231731687303715884105727,
)
f32_floats = st.floats(width=32, allow_nan=False)
f64_floats = st.floats(width=64, allow_nan=False)
numeric_strategies = (
    u8_ints,
    i8_ints,
    u16_ints,
    i16_ints,
    u32_ints,
    i32_ints,
    u64_ints,
    i64_ints,
    u128_ints,
    i128_ints,
)

type_map = {
    U8: u8_ints,
    I8: i8_ints,
    U16: u16_ints,
    I16: i16_ints,
    U32: u32_ints,
    I32: i32_ints,
    U64: u64_ints,
    I64: i64_ints,
    U128: u128_ints,
    I128: i128_ints,
    F32: f32_floats,
    F64: f64_floats,
    Bytes: st.binary(),
    String: st.text(),
}

@given(u8_ints)
def test_u8(s):
    """Test U8 encoding/decoding."""
    assert U8.parse(U8.build(s)) == s

@given(i8_ints)
def test_i8(s):
    """Test I8 encoding/decoding."""
    assert I8.parse(I8.build(s)) == s

@given(u16_ints)
def test_u16(s):
    """Test I16 encoding/decoding."""
    assert U16.parse(U16.build(s)) == s

@given(i16_ints)
def test_i16(s):
    """Test I16 encoding/decoding."""
    assert I16.parse(I16.build(s)) == s

@given(u32_ints)
def test_u32(s):
    """Test U32 encoding/decoding."""
    assert U32.parse(U32.build(s)) == s

@given(i32_ints)
def test_i32(s):
    """Test I32 encoding/decoding."""
    assert I32.parse(I32.build(s)) == s

@given(u64_ints)
def test_u64(s):
    """Test U64 encoding/decoding."""
    assert U64.parse(U64.build(s)) == s

@given(i64_ints)
def test_i64(s):
    """Test I64 encoding/decoding."""
    assert I64.parse(I64.build(s)) == s

@given(u128_ints)
def test_u128(s):
    """Test U128 encoding/decoding."""
    assert U128.parse(U128.build(s)) == s

@given(i128_ints)
def test_i128(s):
    """Test I128 encoding/decoding."""
    assert I128.parse(I128.build(s)) == s

@given(f32_floats)
def test_f32(s):
    """Test F32 encoding/decoding."""
    assert F32.parse(F32.build(s)) == s

@given(f64_floats)
def test_f64(s):
    """Test F64 encoding/decoding."""
    assert F64.parse(F64.build(s)) == s

@st.composite
def element_and_borsh_type(draw, elements=st.sampled_from(borsh_simple_types)):
    """Return a simple borsh type and a simple example of data fitting that type."""
    borsh_type = draw(elements)
    data_strategy = type_map[borsh_type]
    data = draw(data_strategy)
    return data, borsh_type

@st.composite
def list_data_and_borsh_type(
    draw,
    elements=st.sampled_from(borsh_simple_types),
    min_length=0,
    unique=False,
):
    """Return a list whose elements fit a particular borsh type."""
    borsh_type = draw(elements)
    data_strategy = type_map[borsh_type]
    data = draw(st.lists(data_strategy, min_size=min_length, unique=unique))
    return data, borsh_type, len(data)

@given(list_data_and_borsh_type())  # type: ignore
def test_vec(data_borsh_type):
    """Test Vec encoding."""
    data, borsh_type, _ = data_borsh_type
    vec_type = Vec(borsh_type)
    assert vec_type.parse(vec_type.build(data)) == data

@given(list_data_and_borsh_type(min_length=1))  # type: ignore
def test_array(data_borsh_type):
    """Test Array encoding."""
    data, borsh_type, length = data_borsh_type
    array_type = borsh_type[length]
    assert array_type.parse(array_type.build(data)) == data

@given(element_and_borsh_type())  # type: ignore
def test_option(data_borsh_type):
    """Test Option encoding."""
    data, borsh_type = data_borsh_type
    option_type = Option(borsh_type)
    assert option_type.parse(option_type.build(data)) == data

@given(list_data_and_borsh_type())  # type: ignore
def test_hashset(data_borsh_type):
    """Test HashSet encoding."""
    data, borsh_type, _ = data_borsh_type
    data = set(data)
    set_type = HashSet(borsh_type)
    assert set_type.parse(set_type.build(data)) == data

'''