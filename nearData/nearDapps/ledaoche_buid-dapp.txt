*GitHub Repository "ledaoche/buid-dapp"*

'''--- .gitpod.yml ---
# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: nvm use default && npm install near-shell -g --no-optional
    command: yarn && brew install tree && clear && echo Welcome to Exploring AssemblyScript Contracts with NEAR Protocol
'''
'''--- README.md ---
![Near, Inc. logo](https://near.org/wp-content/themes/near-19/assets/img/logo.svg?t=1553011311)

# NEAR Protocol Workshop :: Exploring AssemblyScript Contracts

This workshop includes several activities:

- a [**scavenger hunt**](#activityscavenger-hunt) through several AssemblyScript projects to get you quickly oriented
- a [**debugging challenge**](#activitydebugging-challenge) to fix a few failing unit tests with broken contracts
- a [**development lifecycle challenge**](#activitydevelopment-lifecycle) to guide you through NEAR platform tools for testing
- a [**design challenge**](#activitydesign-challenge) to create new contracts and related models that satisfy a set of requirements

**Prerequisites**

If you're already comfortable with TypeScript then reading AssemblyScript should be a breeze. If you're coming from JavaScript, you'll have to get your head around `static types` and code compilation (since JavaScript has dynamic types and is an interpreted language) but reading through the samples here should not be too difficult. If you have no programming experience then this workshop will be challenging for you -- find someone to pair with so you can stay motivated and productive.

**Companion Presentation**

This hands-on workshop is paired with a presentation called [Hello AssemblyScript](https://docs.google.com/presentation/d/1Sz823KGP_dI2bNUoTlQtphI3Sz2Jej5bmYl-oYhp5HM) which helps set the context for this work and clarifies a few key mental models.

Before diving into this workshop, have a look at the slides linked above.

**Orientation**

If you're totally new to NEAR you can [start here](https://docs.near.org/docs/concepts/new-to-near) with a high level overview.

NEAR Protocol (aka "NEAR") is a public peer-to-peer key-value database. Public as in open to everyone for reading anything and writing what you are allowed to. Write permissions are defined by access keys so only the owner of the data can give permissions to modify data they own.

Manipulation of data is controlled by stored procedures (smart contracts) executing as [WebAssembly (Wasm)](https://webassembly.org) which means they can be implemented in any programming language that compiles to Wasm (ie. Rust, AssemblyScript, Kotlin, C, C++, Nim, Zig, etc).  Currently only the first two languages are supported for development on the NEAR platform.

_We will not be building dApps around any of these contracts since our focus is on learning AssemblyScript. Almost all of the contract code presented in this workshop is also running on [live examples](https://near.dev) where you will also find the frontend code that relies on these contracts._

## Environment Setup

### Using Gitpod

[![Open in Gitpod](https://gitpod.io/button/open-in-gitpod.svg)](https://gitpod.io#https://github.com/near-examples/workshop--exploring-assemblyscript-contracts)

### Local Setup

1. clone this repo locally
2. run `yarn` to install dependencies

## Available commands

### Building contracts

- `yarn build` builds all contracts
- `yarn build <contract name>` builds a specific contract
- `yarn clean` deletes the `out` folder containing built contracts

### Testing contracts

- `yarn test` runs unit tests for all contracts

See `package.json` for more detail about these and other scripts.

You will find the following folder structure in this repository under the `assembly` folder.

```text
assembly
│
├── A.sample-projects
│   ├── 01.greeting
│   ├── 02.wallet-example
│   ├── 03.counter
│   ├── 04.token-contract
│   ├── 05.guestbook
│   ├── 06.chat
│   └── 07.cross-contract-calls
│
├── B.debugging-challenge
│   ├── 01.broken-greeting
│   ├── 03.broken-counter
│   └── 05.broken-guestbook
│
└── C.design-challenge
    ├── 01.PinkyPromise
    ├── 02.OpenPetition
    └── 03.BucketList
```

### Filtering Tests

You can filter tests using the following syntax

```text
yarn test -f <contract name>.unit
```

For example:

`yarn test -f greeting.unit` or `yarn test -f counter.unit`

_Note the projects are ordered by increasing complexity so lower numbers roughly implies "easier to understand"._

## Activity::Scavenger Hunt

> **_Instructions_**
>
> 1. Scan the items to scavenge (ie. to find) in the lists below
> 2. For the most interesting ones, look for them in the folder called `A.sample-projects`
>
> All of them appear in contract files (`main.ts` and `model.ts`) or their unit tests (`*.unit.spec.ts`)
>
> Keep your own notes. Time permitting, we will share and discuss your findings and answer questions at the end of the activity.

**First Steps**

_Note, some of these may only take you **a few seconds** to complete so don't overthink things. This activity is about massive exposure to several examples of smart contracts written using AssemblyScript for the NEAR platform._

Find examples of the following:

- [ ] a contract method that takes no parameters
- [ ] a contract method that takes one parameter
- [ ] a model passed to a contract method

**Models Organize and Serialize Data**

NEAR Protocol stores data in a key-value store called `Storage`. For developer convenience when building more complex dApps, `Storage` is also wrapped by a few other persistent collections including `PersistentVector`, `PersistentSet`, `PersistentMap` and `PersistentDeque`.

Reading and writing to `Storage` requires specifying the type of data to store, whether `string`, `number` or `binary`.

All custom data types (ie. custom data models) must be decorated with the `@nearBindgen` decorator so that the system knows to serialize when storing and deserialize when retrieving them.

Find examples of the following:

- [ ] use of `Storage` to read and / or write data from blockchain storage
- [ ] use of `PersistentVector` to store contract data in an array-like data structure
- [ ] use of `PersistentMap` to store contract data in a map-like data structure
- [ ] use of `PersistentDeque` to store contract data in a queue-like data structure
- [ ] use of `PersistentSet` to store contract data in a set-like data structure
- [ ] an example that includes the `@nearBindgen` decorator
- [ ] use of the `getPrimitive<T>()` method on the `Storage` class
- [ ] use of the `getString()` method on the `Storage` class
- [ ] use of the `setString()` method on the `Storage` class

**Contracts Expose an Interface**

NEAR Protocol accounts are initially created without an associated contract. Each account can have a maximum of 1 contract deployed to its storage (although a contract may be deployed to many accounts).

Each account maintains it's own copy of a contract code as well as any state storage consumed by the contract during normal operation. You can read more about [accounts on the NEAR platform here](https://docs.near.org/docs/concepts/account).

Find examples of the following:

- [ ] use of `context.sender` which represents the account that signed the current transaction
- [ ] an example of a unit test where the test explicitly sets the `signer_account_id` to control `context.sender`
- [ ] use of `context.contractName` which represents the account on which the contract lives
- [ ] an example of a unit test where the test explicitly sets the `current_account_id` to control `context.contractName`
- [ ] use of `context.attachedDeposit` to capture the tokens attached to a contract function call
- [ ] an example of a unit test where the test explicitly sets the `attached_deposit` to control `context.attachedDeposit`

**Validation**

- [ ] use of `assert()` in a contract method to guarantee that some value meets the necessary criteria

## Activity::Debugging Challenge

> **_Instructions_**
>
> Debug as many of the following problems as you can.
>
> - They are ordered by increasing difficulty.
> - All of the related files appear in the folder called `B.debugging-challenge`
> - **None of the tests were altered**. Only the `main.ts` contract file and / or the `model.ts` model file were changed from the original to create the problems you see in these failing tests or failures to compile the code.
> - You know you're finished when the tests pass
>
> Keep your own notes. Time permitting, we will share and discuss your findings and answer questions at the end of the activity.

### Broken Greeting

- [ ] run `yarn test -f broken-greeting` and fix the failing unit tests

<details>
  <summary><em>Reveal hints</em></summary>
  <ul>
    <li>Run this command in the terminal to reveal the needed fixes<br><code>git diff --no-index assembly/B.debugging-challenge/01.broken-greeting/main.ts assembly/A.sample-projects/01.greeting/assembly/index.ts</code></li>
  </ul>
</details>

**You know you're finished when** the unit tests are all passing and you see something like this:

```text
[Describe]: 01. Greeting

 [Success]: ✔ should respond to showYouKnow()
 [Success]: ✔ should respond to sayHello()
 [Success]: ✔ should respond to sayMyName()
 [Success]: ✔ should respond to saveMyName()
 [Success]: ✔ should respond to saveMyMessage()
 [Success]: ✔ should respond to getAllMessages()

    [File]: B.debugging-challenge/01.broken-greeting/__tests__/greeting.spec.ts
  [Groups]: 2 pass, 2 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 6 pass,  0 fail, 6 total
    [Time]: 13.597ms
```

### Broken Counter

- [ ] run `yarn test -f broken-counter` and fix the failing unit tests

<details>
  <summary><em>Reveal hints</em></summary>
  <ul>
    <li>One error is preventing the code from compiling so none of the other tests are running.  solve the compiler error first so you can see the failing tests</li>
    <li>Run this command in the terminal to reveal the needed fixes<br><code>git diff --no-index assembly/B.debugging-challenge/03.broken-counter/main.ts assembly/A.sample-projects/03.counter/assembly/index.ts</code></li>
  </ul>
</details>

### Broken Guestbook

- [ ] run `yarn test -f broken-guestbook` and fix the failing unit tests

Note, in this challenge, some of the issues are preventing the code from the compiling in the first place, so the tests aren't even running.

<details>
  <summary><em>Reveal hints</em></summary>
  <li><code>@nearBindgen</code> is a decorator added to custom models so they can be serialized and stored on chain</li>
  <li>Persistent collections like <code>PersistentVector<T></code>require a type parameter which will often be the model you are trying to store on chain</li>
  <li>You can get the account name of the user that calls a function using <code>context.sender</code></li>
  <li>Run this command in the terminal to reveal the needed fixes for the <strong>contract</strong><br><code>git diff --no-index assembly/A.sample-projects/05.guestbook/main.ts assembly/B.debugging-challenge/05.broken-guestbook/main.ts</code></li>
  <li>Run this command in the terminal to reveal the needed fixes for the <strong>model</strong><br><code>git diff --no-index assembly/B.debugging-challenge/05.broken-guestbook/model.ts assembly/A.sample-projects/05.guestbook/assembly/model.ts</code></li>
</details>

## Activity::Development Lifecycle

> **_Instructions_**
>
> Open the challenge linked in this section
>
> - All related code is located in `A.sample-projects/01.greeting`
>
> Keep your own notes. Time permitting, we will share and discuss your findings and answer questions at the end of the activity.

Let's explore the contract development lifecycle on NEAR Protocol.

We will start with a simple but instructive contract design and explore the contract interface (hint: you've seen it already), build the contract (with a quick peek at the WebAssembly text format), and finally test the contract using unit tests, simulation tests and integration tests.

As we move from end-to-in in this process, focus on the parts that are most interesting to you and feel free to skip the parts that are boring or maybe overwhelming. Come back anytime.

[Open the **Development Lifecycle** challenge](assembly/A.sample-projects/01.greeting/README.md)

## Activity::Design Challenge

> **_Instructions_**
>
> 1. Choose one of the following projects and write the model(s) and contract(s) that satisfy the following requirements.
> 2. Write unit tests for all models and contracts.
>
> Keep your own notes. Time permitting, we will share and discuss your findings and answer questions at the end of the activity.

**Important Note:**
The design guidelines below are almost certaginly incomplete. They are intended to inspire you to consider the design challenge on your own or with your pair or team. Feel free to run with these ideas and do not be constrained by what you see here.

### PinkyPromise

_(inspired by a 2019 hackathon project)_

PinkyPromise is a system for recording promises on the blockchain for all to see, forever and ever. A promise is a piece of text that is made `from` someone `to` someone (possibly themselves). A promise may eventually be marked as `kept` or `broken` by the owner of the `to` account.

**Models**

- `PinkyPromise`
  - Collects a commitment (as string) between two accounts (as strings). Consider whether to use `Storage` directly (our on-chain key-value store) or one of the persistent collections that wraps `Storage` to mimic a Vector, Map, Queue or Set.

**Contracts**

- `main`
  - `makePromise(to: string, statement: string)`

### BucketList

_(inspired by Covid-19)_

BucketList is a system that records things we wish we all could do as soon as it's safe to go back outside.

**Models**

- `Activity` represents something we want to do
  - `description` as `string`
  - `cost` as `u8` (let's keep it small since these are frugal times)
  - `friends` as `PersistentVector<string>` of account names of our friends, if we have any

**Contracts**

- `main`
  - `add(item: string, friends: string[], cost: u8): bool`
  - `list(): Activity[]`

### OpenPetition

_(inspired by an internal hackathon project)_

OpenPetition is a system for managing the creation and support of petitions (ie. Change.org for blockchain).
**Models**

- `Petition`
  - Collects signatures (`context.sender`) in a `PersistentVector<string>` for anyone that calls the main contract's `sign` method, passing in the petition identifier.
  - The Petition model should include Petition metadata like
    - `title` as `string`
    - `body` as `string` and
    - `funding` as `u128`
  - The Petition model should include methods like
    - `sign(): bool`
    - `signWithFunds(amount: u128 = 0): bool`

**Contracts**

- `main`
  - `sign(petitionId: string): bool` allows the `context.sender` to sign the petition
  - `list(): Array<string>` returns a list of petition identifiers
  - `show(petitionId: string): Petition` returns the details of a petition
  - `contract.petitions` could be the collection of petitions stored as a `PersistentMap<string, Petition>` where the key is petition identifier and the value is the petition instance

**Stretch Goals**

- Consider how you would structure this project if each petition were its own contract instead of a model on a single contract. What could the benefits of this be?

## Getting Help

If you find yourself stuck with any of this, feel free to reach out to us via the following links:

- [near.org / help](http://near.org/help)
- [near.chat](http://near.chat)
- [documentation](http://docs.near.org)

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.spec.ts");

// // include tests for all folders under "/assembly" recursively since each one is a separate contract
// const fs = require('fs')
// const path = require('path')

// function readDirR(dir) {
//   return fs.statSync(dir).isDirectory()
//     ? [Array.prototype].concat(...fs.readdirSync(dir).map(f => readDirR(path.join(dir, f))))
//     : dir;
// }

// readDirR(path.resolve(__dirname, "assembly"))
//   .filter(dir => !dir.includes("/."))
//   .filter(dir => dir.includes("__tests__"))
//   .map(dir => module.exports.include.push(dir))

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "assembly/A.sample-projects/01.greeting",
    "assembly/A.sample-projects/02.wallet-example",
    "assembly/A.sample-projects/03.counter",
    "assembly/A.sample-projects/05.guestbook",
    "assembly/A.sample-projects/07.cross-contract-calls/assembly/sentences",
    "assembly/A.sample-projects/07.cross-contract-calls/assembly/words"
  ],
  "outDir": "./out"
}

'''
'''--- assembly/A.sample-projects/01.greeting/README.md ---
![Near, Inc. logo](https://near.org/wp-content/themes/near-19/assets/img/logo.svg?t=1553011311)

# NEAR Protocol Workshop :: Development Lifecycle Challenge

_This challenge is part of a larger workshop on AssemblyScript_

- [NEAR Protocol Workshop :: Development Lifecycle Challenge](#near-protocol-workshop--development-lifecycle-challenge)
  - [Design](#design)
    - [Interface](#interface)
    - [Models](#models)
  - [Build](#build)
    - [Readable Output](#readable-output)
    - [Cost Optimized Output](#cost-optimized-output)
  - [Test](#test)
    - [Unit Tests](#unit-tests)
    - [Simulation Tests](#simulation-tests)
      - [Simulation Testing with `near-vm`](#simulation-testing-with-near-vm)
      - [Simulation Testing with Runtime API](#simulation-testing-with-runtime-api)
    - [Integration Tests](#integration-tests)
      - [Integration Tests with NEAR Shell](#integration-tests-with-near-shell)
      - [Integration Tests with `near-api-js`](#integration-tests-with-near-api-js)

## Design

### Interface

```ts
export function showYouKnow(): void;
```

- "View" function (ie. a function that does NOT alter contract state)
- Takes no parameters
- Returns nothing

```ts
export function sayHello(): string;
```

- View function
- Takes no parameters
- Returns a string

```ts
export function sayMyName(): string;
```

- "Call" function (although it does NOT alter state, it DOES read from `context`, [see docs for details](https://docs.near.org/docs/develop/contracts/as/intro))
- Takes no parameters
- Returns a string

```ts
export function saveMyName(): void;
```

- "Call" function (ie. a function that alters contract state)
- Takes no parameters
- Saves the sender account name to contract state
- Returns nothing

```ts
export function saveMyMessage(message: string): bool;
```

- Call function
- Takes a single parameter message of type string
- Saves the sender account name and message to contract state
- Returns nothing

```ts
export function getAllMessages(): Array<string>;
```

- View function
- Takes no parameters
- Reads all recorded messages from contract state (this can become expensive!)
- Returns an array of messages if any are found, otherwise empty array

**Notes**

- All of these methods append to the log for consistency

### Models

_This contract has no custom models_

## Build

We have several configuration options when compiling AssemblyScript to Wasm.

To take two illustrative extremes, we can compile a readable WAT file (WebAssembly text format) or we can compile a speedy, size-optimized binary (which may leave the WAT format harder to read).

Let's try both.

### Readable Output

To better understand how AssemblyScript is transformed into Wasm, read the contract `.wat` file generated by the following steps.

To generate the `.wat` file alongside the `.wasm` file:

1. **move to the _sample project_ folder** (where **this** `README.md` appears: `01.greeting/`)
2. and run `yarn build`

You should see something like

```text
compiling contract [ 01.greeting/main.ts ] to [ out/greeting.{wasm,wat} ]
I/O Read  : 7.899 ms
I/O Write : 3.388 ms
Parse     : 326.413 ms
Compile   : 300.792 ms
Emit      : 135.141 ms
Validate  : 54.424 ms
Optimize  : 0.261 ms
Filesize  : 14.666kB
✨  Done in 2.39s.
```

> **Notes**
>
> - The optimize step took less than half a second (your exact timings may vary)
> - The size of this file is about `15kB`

You should now be able to see the`.wasm` and `.wat` files for this contract in a folder called `out`.

Consider scanning the WAT file for any recognizable strings, you may be surprised at what you find. Since it's almost 10k lines long, you can search for the method names included in the interface above or scroll from the top of the file down to about line 200 or so for maximum benefit.

If interested, these links will help you make sense of the WAT format you just saw:

- [Understanding WebAssembly text format](https://developer.mozilla.org/en-US/docs/WebAssembly/Understanding_the_text_format)
- [Practice Making Sense of WAT using AssemblyScript](http://pldev2.cs.umd.edu/as-demo/)

### Cost Optimized Output

To generate a speedy, size-optimized version of this contract (which will ultimately cost less to maintain):

1. **move to the repository _root_ folder** (where the **main** workshop `README.md` appears)
2. **run** `yarn build greeting`

You should see something like

```text
compiling contract [ 01.greeting/main.ts         ] to [ out/greeting.wasm ]
I/O Read  : 7.957 ms
I/O Write : 0.665 ms
Parse     : 327.135 ms
Compile   : 279.230 ms
Emit      : 42.876 ms
Validate  : 50.480 ms
Optimize  : 2660.980 ms
Filesize  : 14.669kb
✨  Done in 4.54s.
```

> **Notes**
>
> - The optimize step took almost `3 seconds`, about 10X unoptimized time
> - The size of this file is _also_ about `15kb` although `.wasm` file sizes will diverge by 5X with increased contract complexity

**A brief aside**

_Which folder should I be in while running these commands?_

Almost all terminal commands in this workshop should be executed in the repository's **root folder**.

The _only_ 2 cases when it's useful to execute a command in a sample project folder are

- if you want to generate the `.wat` file or
- if you want to run simulation tests (more on this later)

_Compiling AssemblyScript?_

If you're curious about the differences between the two compilation processes used above, take a look at the file called `asconfig.js` (in the repository root folder) where you'll find two functions, `compileReadable` and `compileOptimized`. You'll find the functions differ in switches passed to the compiler. You could try changing the switches to see the difference in output.

_Using Gitpod?_

Please feel encouraged to edit any and all files in this repo while you explore. A reset of this environment is just a click away: just head back to the main `README` and reopen this workshop in Gitpod if you ever get stuck.

## Test

There are three classes of tests presented here:

- **Unit** tests exercise the methods and models of your contract
- **Simulation** tests provide fine-grained control over contract state, execution context and even network economics
- **Integration** tests get as close to production as possible with deployment to a local node, BetaNet or TestNet

We will explore each of these in turn.

### Unit Tests

Unit tests are written using [`as-pect`](https://github.com/jtenner/as-pect) which provides "blazing 🔥 fast testing with AssemblyScript".

To see unit tests for this contract run

```text
yarn test -f greeting.unit
```

You should see something like this (may be colorized depending on your terminal configuration)

```text
[Describe]: Greeting

 [Success]: ✔ should respond to showYouKnow()
 [Success]: ✔ should respond to sayHello()
 [Success]: ✔ should respond to sayMyName()
 [Success]: ✔ should respond to saveMyName()
 [Success]: ✔ should respond to saveMyMessage()
 [Success]: ✔ should respond to getAllMessages()

    [File]: 01.greeting/__tests__/greeting.unit.spec.ts
  [Groups]: 2 pass, 2 total
  [Result]: ✔ PASS
[Snapshot]: 0 total, 0 added, 0 removed, 0 different
 [Summary]: 6 pass,  0 fail, 6 total
    [Time]: 12.852ms

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

  [Result]: ✔ PASS
   [Files]: 1 total
  [Groups]: 2 count, 2 pass
   [Tests]: 6 pass, 0 fail, 6 total
    [Time]: 2350.078ms
✨  Done in 3.01s.
```

You can explore the contents of `01.greeting/__tests__/greeting.spec.ts` for unit test details.

### Simulation Tests

There are two types of simulation tests we can expect to use:

- **`near-vm`** allows us to exercise contract methods inside an exact replica of the on-chain virtual machine
- **Runtime API** exposes interfaces for cross-contract calls and is compatible with popular testing frameworks

Only the first, using `near-vm`, will be addressed in depth here. It's key limitation is that we can only test one contract at a time, invoking methods, observing changes in state and getting a sense of the operating costs of the contract.

#### Simulation Testing with `near-vm`

Run the following commands to simulate calling the method `sayMyName` on this contract

1. First compile (or recompile after changes) the optimized `.wasm` file

   ```text
   yarn build greeting
   ```

2. Then run a simulation test

   ```text
   yarn test:simulate:vm:greeting --method-name sayMyName
   ```

You should see something like the following response

```text
{"outcome":{"balance":"10000000000000000000000000","storage_usage":100,"return_data":{"Value":"\"Hello, bob!\""},"burnt_gas":41812607821,"used_gas":41812607821,"logs":["sayMyName() was called"]},"err":null,"receipts":[],"state":{}}
✨  Done in 1.75s.
```

Which can be reformatted for easier scanning

```json
{
  "outcome": {
    "balance": "10000000000000000000000000",
    "storage_usage": 100,
    "return_data": {
      "Value": "\"Hello, bob!\""
    },
    "burnt_gas": 41812607821,
    "used_gas": 41812607821,
    "logs": ["sayMyName() was called"]
  },
  "err": null,
  "receipts": [],
  "state": {}
}
```

> **Notes**
>
> - The value in `return_data` is what we expect if our account name were "bob". But how did that get there? Run `near-vm --help` to see simulation options including control over contract state and execution context as well as network economics.
> - The amounts of `burnt_gas` and `used_gas` are the same, so why two different values? `used_gas` >= `burnt_gas` is always true. If ever a difference, it will be refunded back to the originating account. [See SO for more](https://stackoverflow.com/a/59146364).
> - The entry in `logs` is exactly what we would expect to see.
> - The contract `state` is empty.

Run the following command to simulate calling the method `saveMyName` on this contract

```text
yarn test:simulate:vm:greeting --method-name saveMyName
```

_(You only need to rebuild the contract if you've made changes)_

After reformatting, you should see something like the following response

```json
{
  "outcome": {
    "balance": "10000000000000000000000000",
    "storage_usage": 149,
    "return_data": "None",
    "burnt_gas": 49055516114,
    "used_gas": 49055516114,
    "logs": ["saveMyName() was called"]
  },
  "err": null,
  "receipts": [],
  "state": {
    "c2VuZGVy": "Ym9i"
  }
}
```

> **Notes**
>
> - The absence of value in `return_data` since `saveMyName` has a return type of `void`.
> - The amount of `used_gas` is higher now, by about 7.2 billion units. This difference represents more compute time required to fetch an account name from the `context` object as well as reading and writing to storage
> - The entry in `logs` is exactly what we would expect to see.
> - This time the contract `state` is not empty. It has 1 entry, a `key : value` pair, that is encoded as Base64 and, when decoded looks like this: `{"sender":"bob"}`.

**A brief aside on decoding**

_Base Sixty What?_

Just like human languages encode our thoughts into spoken words and printed text, data is encoded in different formats on computer systems depending on the use case. If data is "at rest", say on a backup drive, it can be encoded using a compression algorithm for better storage efficiency. And when data is "in motion", say between machines over HTTP, base64 is a good choice since the data less likely to get corrupted during transfer.

The state "key" and "value" above were decoded using the code snippet below but we could just as easily have used a [website like this one](https://www.base64decode.org/).

```js
const key = "c2VuZGVy";
const value = "Ym9i";
const decodedKey = Buffer.from(key, "base64").toString("utf8");
const decodedValue = Buffer.from(value, "base64").toString("utf8");
console.log(decodedKey, decodedValue);
```

#### Simulation Testing with Runtime API

At a very high level, testing with the Runtime API allows us, using JavaScript, to create accounts for contracts, load them up with the Wasm binary, add user accounts and simulate their interaction.

To try this out:

1. **move to the _sample project_ folder** (where **this** `README.md` appears: `01.greeting/`)
2. run `yarn` inside that folder _(we will use Jest for this)_
3. run `yarn build` to build `greeting.wasm` locally (just as we did when browsing the `.wat` file earlier)
4. run `yarn test:simulate:runtime`

You should see something like

```text
 PASS  __tests__/greeting.simulate.spec.js
  Greeting
    View methods
      ✓ responds to showYouKnow() (113ms)
      ✓ responds to sayHello() (115ms)
      responds to getAllMessages()
        ✓ works with 0 messages (133ms)
        ✓ works with 1 message (229ms)
        ✓ works with many messages (493ms)
    Call methods
      ✓ responds to sayMyName() (128ms)
      ✓ responds to saveMyName() (113ms)
      ✓ responds to saveMyMessage() (106ms)
    Cross-contract calls()
      ✎ todo add cross contract call examples

Test Suites: 1 passed, 1 total
Tests:       1 todo, 8 passed, 9 total
Snapshots:   0 total
Time:        3.313s
Ran all test suites matching /simulate.spec/i.
✨  Done in 9.88s.
```

Feel free to explore the file `__tests__/greeting.simulate.spec.js` for details.

**A brief aside on contracts and accounts**

You may have noticed that the words `contract` and `account` are sometimes interchangeable. This is because NEAR accounts can only hold zero or one contracts while a contract can be deployed to multiple accounts.

In the previous sections, since we were only testing and simulating and had not deployed anything to the network, the words `contract` and `account` were basically the same, although you may have already noticed this distinction if you took a close look at the `simulate.spec` file a moment ago.

In the next section about integration tests where we will be working with a live network, the distinction between **contract accounts** vs. **user accounts** will become useful and important.

We will deploy the contract to a specific account (ie. the contract account) on the network (ie. TestNet) and call contract methods from a **different** account (ie. our user account).

You can read more about [accounts on NEAR Protocol here](https://docs.near.org/docs/concepts/account).

### Integration Tests

There are two types of integration tests we can expect to use:

- **NEAR Shell** serves as a console Swiss army knife with the ability to manage accounts, contracts and more
- **`near-api-js`** (our JavaScript API) wraps the NEAR JSON RPC API and exposes NEAR Wallet authentication

Only the first, using NEAR Shell, will be addressed here in any depth. Its key limitation is that we cannot orchestrate cross-contract calls.

We will use NEAR Shell to login to our own user account and then use it again to create a new account for our contract before we deploy, verify, and invoke methods on the contract. Finally, we will delete the contract account to clean up after ourselves. We will rely on other tools like [NEAR Explorer](https://explorer.testnet.near.org/) for transaction visibility, history and more.

#### Integration Tests with NEAR Shell

**HEADS UP** -- if this is your first time using NEAR Shell to deploy a contract to TestNet, this may feel like a long and confusing process but once you've done it 3 times, it should only take about a minute from end to end and can be automated in a shell script.

But first the tldr; for anyone who wants to start running before they walk.

---

**tldr;**

We use the symbol `<???>` to represent text that is **unique to your account name**, whatever that is (or will be when you make it up). After this brief list of steps, each of these commands is described in greater detail including expected output and possible errors.

Note that all of this happening **on the command line.**

**(0) Confirm NEAR Shell is installed**

```text
near --version
```

_Expected output_

```text
0.21.0    (or any higher version number)
```

**(1) Authorize NEAR Shell to use your account**

- You must create an account in this step if you don't already have one
- _Using Gitpod?_
  - Click **Open Preview** button (will appear in the middle of 3 blue buttons)

```text
near login
```

**(2) Create an account for the contract**

- By design there is a limit of max 1 contract per account
- Account names follow a pattern similar to DNS
- We assume you already created `<???>.testnet` in the previous step

```text
near create_account greeting.<???>.testnet --master-account <???>.testnet --helper-url https://helper.testnet.near.org
```

_Expected output_

```text
Account greeting.<???>.testnet for network "default" was created.
```

**(3) Build the contract**

- The Wasm file will appear as `out/greeting.wasm`
- To silence metrics reporting during compilation, comment out all (2) instances of `"--measure"` in the file `asconfig.js`

```text
yarn build greeting
```

_Expected output_

```text
compiling contract [ 01.greeting/main.ts         ] to [ out/greeting.wasm ]
```

**(4) Deploy the contract to the contract account**

- We assume you already created `greeting.<???>.testnet` in a previous step

```text
near deploy --wasm-file out/greeting.wasm --account-id greeting.<???>.testnet
```

_Expected output_

```text
Starting deployment. Account id: greeting.<???>.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: out/greeting.wasm
```

**(5) Verify deployment of the correct contract to the intended**

- The account name `greeting.<???>.testnet` should match the intended contract account
- The value of `code_hash` should match _exactly_ (starting with `63tSDQ...`) **unless the contract code has changed**, in which case it will almost certainly be different.
- Other values in this response are unlikely to match

```text
near state greeting.<???>.testnet
```

_Expected output_

```text
Account greeting.<???>.testnet
```

```json
{
  "amount": "99999999949722583262485000",
  "locked": "0",
  "code_hash": "63tSDQc9K5Nt9C8b1HDkv3VBnMFev9hXB589dZ9adsKA",
  "storage_usage": 14912,
  "storage_paid_at": 0,
  "block_height": 2048367,
  "block_hash": "AbYg6aAbv4e1h2rwKG2vMsWphXm27Ehhde6xUKYzYjsT",
  "formattedAmount": "99.999999949722583262485"
}
```

**(6) For each method of the contract, test it and observe the response**

- _Using Gitpod?_
  - Replace all instances of `<???>` to make the lines below match your new account for a smooth workflow

**Test `showYouKnow()`**

```text
near view greeting.<???>.testnet showYouKnow --account-id <???>.testnet
```

_Expected outcome_

```text
View call: greeting.<???>.testnet.showYouKnow()
[greeting.<???>.testnet]: showYouKnow() was called
false
```

**Test `sayHello()`**

```text
near view greeting.<???>.testnet sayHello --account-id <???>.testnet
```

_Expected outcome_

```text
View call: greeting.<???>.testnet.sayHello()
[greeting.<???>.testnet]: sayHello() was called
'Hello!'
```

**Test `sayMyName()`**

```text
near call greeting.<???>.testnet sayMyName --account-id <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.sayMyName()
[greeting.<???>.testnet]: sayMyName() was called
'Hello, <???>.testnet!'
```

**Test `saveMyName()`**

```text
near call greeting.<???>.testnet saveMyName --account-id <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.saveMyName()
[greeting.<???>.testnet]: saveMyName() was called
''
```

**Test `saveMyMessage()`**

```text
near call greeting.<???>.testnet saveMyMessage '{"message": "bob? you in there?"}' --account-id <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.saveMyMessage({"message": "bob? you in there?"})
[greeting.<???>.testnet]: saveMyMessage() was called
true
```

**Test `getAllMessages()`**

```text
near call greeting.<???>.testnet getAllMessages --account-id <???>.testnet
```

_Expected outcome_

```text
Scheduling a call: greeting.<???>.testnet.getAllMessages()
[greeting.<???>.testnet]: getAllMessages() was called
[ '<???>.testnet says bob? you in there?' ]
```

**(7) Cleanup by deleting the contract account**

```text
near delete greeting.<???>.testnet <???>.testnet
```

_Expected outcome_

```text
Deleting account. Account id: greeting.<???>.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, beneficiary: <???>.testnet
Account greeting.<???>.testnet for network "default" was deleted.

```

**END tldr;**

For more support using the commands above, see [help with NEAR Shell integration tests](near-shell-help.md).

#### Integration Tests with `near-api-js`

`near-api-js` is a JavaScript / TypeScript library for development of dApps on the NEAR platform that can be used from any client or server-side JavaScript environment.

For context, it's worth knowing that the core NEAR platform API is a JSON-RPC interface. `near-api-js` wraps this RPC interface with convenience functions and exposes NEAR primitives as first class JavaScript objects.

We use `near-api-js` internally in tools like NEAR Shell and NEAR Wallet.

You would use `near-api-js` as your primary interface with the NEAR platform anytime you are writing JavaScript (client or server-side).

See our [documentation for more details](https://docs.near.org/docs/develop/front-end/introduction).

'''
'''--- assembly/A.sample-projects/01.greeting/__tests__/greeting.simulate.spec.js ---
const {
  Runtime
} = require("near-sdk-simulator");

const WASM_FILE = __dirname + "../../../../out/debug/01.greeting.wasm";

describe("Greeting ", () => {
  const users = ["alice", "bob", "carol"];
  const messages = ["awesomesauce!", "yashilsin!", "beleza!"];

  let runtime;
  let greeting;

  beforeAll(() => {
    runtime = new Runtime();
    greeting = runtime.newAccount("greeting", WASM_FILE);

    accounts = users
      .map((name) => runtime.newAccount(name))
      .reduce((acc, user) => {
        acc[user.account_id] = user;
        return acc;
      }, {});
  });

  afterEach(() => {
    greeting.state = {};
  });

  describe("View methods", () => {
    it("responds to showYouKnow()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "view",
          name: "showYouKnow",
        },
      };

      const {
        result
      } = simulate(transaction);

      expectToFind("showYouKnow() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to sayHello()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "view",
          name: "sayHello",
        },
      };

      const {
        result,
        data
      } = simulate(transaction);

      expect(data).toEqual("Hello!");
      expectToFind("sayHello() was called", {
        inArray: result.outcome.logs,
      });
    });

    describe("responds to getAllMessages()", () => {
      it("works with 0 messages", () => {
        const transaction = {
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        const {
          result,
          data
        } = simulate(transaction);

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });

      it("works with 1 message", () => {
        sendMessage(accounts.alice, {
          message: messages[0]
        });

        const transaction = {
          signer: accounts.alice,
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        // useful for visualizing contract state
        // console.log(greeting.state);

        const {
          result,
          data
        } = simulate(transaction);

        expectToFind("alice says awesomesauce!", {
          inArray: data,
        });

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });

      it("works with many messages", () => {
        let expectedMessages = [];

        Object.keys(accounts).map((user, idx) => {
          let signer = accounts[user];
          let message = messages[idx];

          sendMessage(signer, {
            message
          });
          expectedMessages.push(`${signer.account_id} says ${message}`);
        });

        const transaction = {
          contract: greeting,
          method: {
            type: "call",
            name: "getAllMessages",
          },
        };

        // useful for visualizing contract state
        // console.log(greeting.state);

        const {
          result,
          data
        } = simulate(transaction);

        expectedMessages.map((message) => {
          expectToFind(message, {
            inArray: data,
          });
        });

        expectToFind("getAllMessages() was called", {
          inArray: result.outcome.logs,
        });
      });
    });
  });

  describe("Call methods", () => {
    it("responds to sayMyName()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "sayMyName",
        },
      };

      const {
        data,
        result
      } = simulate(transaction);

      expect(data).toEqual(`Hello, ${accounts.alice.account_id}!`);
      expectToFind("sayMyName() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to saveMyName()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "saveMyName",
        },
      };

      const {
        result
      } = simulate(transaction);

      // "c2VuZGVy" is " in base64
      // "YWxpY2U=" is "alice" in base64
      expect(result.state).toHaveProperty("sender", "alice");

      expectToFind("saveMyName() was called", {
        inArray: result.outcome.logs,
      });
    });

    it("responds to saveMyMessage()", () => {
      const transaction = {
        signer: accounts.alice,
        contract: greeting,
        method: {
          type: "call",
          name: "saveMyMessage",
          params: {
            message: "awesomesauce"
          },
        },
      };

      const {
        data,
        result
      } = simulate(transaction);

      expect(data).toBeTruthy();

      // "bWVzc2FnZXM6Oi0x" is  in base64
      // "YWxpY2Ugc2F5cyBhd2Vzb21lc2F1Y2Uh" is "alice says awesomesauce" in base64
      expect(result.state).toHaveProperty(
        "messages::-1",
        "alice says awesomesauce"
      );

      expectToFind("saveMyMessage() was called", {
        inArray: result.outcome.logs,
      });
    });
  });

  describe("Cross-contract calls()", () => {
    test.todo("add cross contract call examples");
  });

  // ---------------------------------------------------------------
  // Helpers
  // ---------------------------------------------------------------

  function sendMessage(signer, params) {
    const transaction = {
      signer,
      contract: greeting,
      method: {
        type: "view",
        name: "saveMyMessage",
        params,
      },
    };

    const {
      data
    } = simulate(transaction);

    expect(data).toBeTruthy();
  }

  function expectToFind(target, {
    inArray
  }) {
    if (inArray) {
      expect(inArray).toEqual(expect.arrayContaining([target]));
    }
  }

  function simulate({
    signer,
    contract,
    method
  }, printResponse = false) {
    let response;

    if (signer) {
      response = signer.call_other(
        contract.account_id,
        method.name,
        method.params
      );
    } else {
      response = contract[method.type](method.name, method.params);
    }

    if (printResponse) {
      console.log("\n\n------ Near VM Response ------");
      console.log(JSON.stringify(response, null, 2));
    }

    return {
      data: response.return_data,
      error: response.err,
      result: response.result,
      results: response.results,
      calls: response.calls,
    };
  }

  function getContext() {
    return {
      input: "{}",
      output_data_receivers: [],
      prepaid_gas: 10 ** 15,
      attached_deposit: "0",
      is_view: false,
      block_index: 1,
      block_timestamp: 1585778575325000000,
      epoch_height: 1,
      storage_usage: 100,
      random_seed: "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
      current_account_id: "alice",
      signer_account_id: "alice",
      predecessor_account_id: "bob",
      account_balance: "1000",
      signer_account_pk: "KuTCtARNzxZQ3YvXDeLjx83FDqxv2SdQTSbiq876zR7",
      account_locked_balance: "10",
    };
  }
});

'''
'''--- assembly/A.sample-projects/01.greeting/__tests__/greeting.unit.spec.ts ---
import {
  showYouKnow,
  sayHello,
  sayMyName,
  saveMyName,
  saveMyMessage,
  getAllMessages,
} from "../assembly";
import { storage, PersistentDeque, VMContext, VM } from "near-sdk-as";

const contract = "greeting";
const alice = "alice";
const bob = "bob";
const carol = "carol";
const message1 = "awesomesauce!";
const message2 = "yashilsin!";
const message3 = "beleza!";

let messages: PersistentDeque<string>;

describe("01. Greeting", () => {
  beforeEach(() => {
    VMContext.setCurrent_account_id(contract);
    VMContext.setSigner_account_id(alice);
    messages = new PersistentDeque<string>("messages");
  });

  it("should respond to showYouKnow()", () => {
    showYouKnow();
    expect(showYouKnow).not.toThrow();
    expect(VM.logs()).toContainEqual("showYouKnow() was called");
  });

  it("should respond to sayHello()", () => {
    expect(sayHello()).toStrictEqual("Hello!");
    expect(VM.logs()).toContainEqual("sayHello() was called");
  });

  it("should respond to sayMyName()", () => {
    expect(sayMyName()).toStrictEqual("Hello, " + alice + "!");
    expect(VM.logs()).toContainEqual("sayMyName() was called");
  });

  it("should respond to saveMyName()", () => {
    expect(saveMyName).not.toThrow();
    expect(storage.getString("sender")).toStrictEqual(alice);
    expect(VM.logs()).toContainEqual("saveMyName() was called");

    // as-pect requires that we restore contract state between tests in the same file
    storage.delete("sender");
  });

  it("should respond to saveMyMessage()", () => {
    const expected = alice + " says " + message1;
    expect(saveMyMessage(message1)).toBeTruthy();
    expect(messages.first).toStrictEqual(expected);
    expect(VM.logs()).toContainEqual("saveMyMessage() was called");

    // as-pect requires that we restore contract state between tests in the same file
    messages.popFront();
  });

  it("should respond to getAllMessages()", () => {
    messages.pushFront(message1);
    messages.pushFront(message2);
    messages.pushFront(message3);

    const output = getAllMessages();
    expect(output).toHaveLength(3);
    expect(messages).toHaveLength(0);

    expect(VM.logs()).toContainEqual("getAllMessages() was called");

    // as-pect requires that we restore contract state between tests in the same file
    while (!messages.isEmpty) {
      messages.popBack();
    }
  });
});

'''
'''--- assembly/A.sample-projects/01.greeting/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- assembly/A.sample-projects/01.greeting/assembly/index.ts ---
import { context, logging, storage, PersistentDeque } from "near-sdk-as";

/**
 * showYouKnow is a
 * - "view" function (ie. does not alter state)
 * - that takes no parameters
 * - and returns nothing
 *
 * - it has the side effect of appending to the log
 */
export function showYouKnow(): void {
  logging.log("showYouKnow() was called");
}

/**
 * sayHello is a
 * - "view" function (ie. does not alter state)
 * - that takes no parameters
 * - and returns a string
 *
 * - it has the side effect of appending to the log
 */
export function sayHello(): string {
  logging.log("sayHello() was called");

  return "Hello!";
}

/**
 * sayMyName is a
 * - "call" function (although it does NOT alter state, it DOES read from context)
 * - that takes no parameters
 * - and returns a string
 *
 * - it has the side effect of appending to the log
 */
export function sayMyName(): string {
  logging.log("sayMyName() was called");

  return "Hello, " + context.sender + "!";
}

/**
 * saveMyName is a
 * - "call" function (ie. alters state)
 * - that takes no parameters
 * - saves the sender account name to contract state
 * - and returns nothing
 *
 * - it has the side effect of appending to the log
 */
export function saveMyName(): void {
  logging.log("saveMyName() was called");

  storage.setString("sender", context.sender);
}

/**
 * saveMyMessage is a
 * - "call" function (ie. alters state)
 * - that takes no parameters
 * - saves the sender account name and message to contract state
 * - and returns nothing
 *
 * - it has the side effect of appending to the log
 */
export function saveMyMessage(message: string): bool {
  logging.log("saveMyMessage() was called");

  assert(message.length > 0, "Message can not be blank.");
  const messages = new PersistentDeque<string>("messages");
  messages.pushFront(context.sender + " says " + message);

  return true;
}

/**
 * getAllMessages is a
 * - "view" function (ie. does not alter state)
 * - that takes no parameters
 * - reads all recorded messages from contract state (this can become expensive!)
 * - and returns an array of messages if any are found, otherwise empty array
 *
 * - it has the side effect of appending to the log
 */
export function getAllMessages(): Array<string> {
  logging.log("getAllMessages() was called");

  const messages = new PersistentDeque<string>("messages");
  let results = new Array<string>();

  while (!messages.isEmpty) {
    results.push(messages.popBack());
  }

  return results;
}

'''
'''--- assembly/A.sample-projects/01.greeting/near-shell-help.md ---
To use NEAR Shell you'll first need to install it. Please refer to the [documentation](https://docs.near.org/docs/tools/near-cli).

Make sure you're in this folder then login to NEAR Shell and authorize it to use your account.

```
near login
```

A webpage will open to NEAR Wallet where you can create an account (if you don't already have one) and authorize NEAR Shell to use this account (by giving it a `FullAccess` key). If you're on a Windows computer you will need to copy and paste the link from your console into your browser.

The result of logging in will look something like this (it may also be colorized depending on your terminal).

```text
Please authorize NEAR Shell on at least one of your accounts.

If your browser doesn't automatically open, please visit this URL
https://wallet.testnet.near.org/login/?title=NEAR+Shell&public_key=ed25519%3A3KHz9owcKkcx9Q4P8VNCYyhXHaHJNjjxCadMx26CDTxB&success_url=http%3A%2F%2F127.0.0.1%3A5000
Please authorize at least one account at the URL above.

Which account did you authorize for use with NEAR Shell?
Enter it here (if not redirected automatically):
Logged in as [ <???>.testnet ] with public key [ ed25519:3KHz9o... ] successfully
```

If you check your filesystem you should see a new folder structured like this. Your private keys are in the JSON file so don't share that or commit it to a repo or **you risk losing control of your account** to anyone that finds it. This repository ignores all `neardev/` folders by default.

```text
neardev
└── default
    └── <???>.testnet.json
```

Whether you created a new account or used an existing one, you can always check the state of the account using NEAR SHell as well

```
near state <your account name>
```

This should report something like the following

```json
Account <???>.testnet
{
   "amount":"100000000000000000000000000",
   "locked":"0",
   "code_hash":"11111111111111111111111111111111",
   "storage_usage":182,
   "storage_paid_at":0,
   "block_height":2009726,
   "block_hash":"AmEJfazX6vb3LLKeQtPXUGyXto7V9SaGoU4AYRxY8MNe",
   "formattedAmount":"100"
}
```

**Notice**

- the value of `amount` is the number of NEAR tokens this account controls in a vanishingly small unit of measurement called yoctoNEAR (10^-24) (you will also notice that `formattedAmount` has brought the amount back down to a human friendly format).
- the value of `code_hash` will be all `1`s if this is an account with NO contract, otherwise this hash will be a fingerprint of the contract code (you can use this hash to check whether a contract is already deployed to an account, for example)
- the value of `storage_usage` will change depending on the size of a deployed contract (which consumes account state) and data in storage.

Having logged into NEAR Shell and verified your account state, we can now use this authorized account to create a _new account_ on the network just for the contract we want to test. We will also delete this account once we've finished testing with it.

---

> _A brief word about working with accounts_
>
> _To avoid counterproductive confusion, read this part carefully. You must make a few choices here before running this in your terminal._
>
> _Your current account is `<???>.testnet` -- this is the account you just authorized using NEAR Shell_
>
> _NEAR account names are scoped (like DNS for the web) so you can create any "sub-names" by prepending anything you like to your account name._
>
> _We're about to create an account for your contract named `greeting.<???>.testnet`._

```text
near create_account <CONTRACT ACCOUNT> --master-account <YOUR ACCOUNT> --helper-url https://helper.testnet.near.org
```

If your account was `bob.testnet` then the contract account would be `greeting.bob.testnet`.

```text
near create_account greeting.bob.testnet --master-account bob.testnet --helper-url https://helper.testnet.near.org
```

For this to work you must have already authorized NEAR Shell with `FullAccess` rights to the account listed after `--master-account` in the command above.

**If it works**, this should report something like the following

```text
Account greeting.<???>.testnet for network "default" was created.
```

**If it fails**, this will most likely report one of the following 3 errors:

(1) The `--master-account` **doesn't exist on the network**. To resolve, fix the account name.

```text
Server error: account <???> does not exist while viewing
```

(2) The `--master-account` **is not authorized for use by NEAR Shell**. To resolve, `near login` again.

```text
TypedError: Can not sign transactions for account <???>, no matching key pair found in Signer.
```

(3) The account named `<???>` already exists on the network. To resolve, either rename the account or recognize that you may have run this command twice, in which case, don't worry, be happy, you're ready to move on.

```text
AccountAlreadyExists [Error]: Can't create a new account <???>, because it already exists
```

---

At this point the contract should be deployed to the account `greeting.<???>.testnet`. Let's confirm

```
near state greeting.<???>.testnet
```

**If it works**, this should report something like the following

Account greeting.<???>.testnet

```json
{
  "amount": "100000000000000000000000000",
  "locked": "0",
  "code_hash": "11111111111111111111111111111111",
  "storage_usage": 182,
  "storage_paid_at": 0,
  "block_height": 2013415,
  "block_hash": "9cYMm5NtQ37RZDuHZKwCXKqKdsmLfMRuxtxoGGkfcXuZ",
  "formattedAmount": "100"
}
```

**If it fails** then take a minute to carefully create the contract account because it's required to move on.

Since the account is created we can compile and deploy the contract like this

```text
yarn build greeting
```

Which should report something like this

```text
compiling contract [ 01.greeting/main.ts         ] to [ out/greeting.wasm ]
```

And then

```text
near deploy --wasm-file ./out/greeting.wasm --account-id greeting.<???>.testnet

```

Which should report something like this

```text
Starting deployment. Account id: greeting.<???>.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, file: ./out/greeting.wasm
```

And we can check the contract account state again to see if we've deployed it correctly.

Account greeting.<???>.testnet

```json
{
  "amount": "99999999983957639545840000",
  "locked": "0",
  "code_hash": "EiYRuKQaJtc61Rm7rffGqY4B4rEhNaCyz1VxLYAUq8oE",
  "storage_usage": 6415,
  "storage_paid_at": 0,
  "block_height": 2014205,
  "block_hash": "hSjzKCUsiuU6niEdFFoAwbLswUs5d55vaaHX4DRR46H",
  "formattedAmount": "99.99999998395763954584"
}
```

**Notice**

- the `account` balance went from 100 NEAR tokens to 99 tokens and change (deploying the contract cost a small amount of tokens (1.6 ^ 16 yoctoNEAR) to purchase the gas for processing the `DeployContract` action included in the deployment transaction.
- unless the contract code changed since time of writing, the `code_hash` in your output should start with `EiYRuK...`, matching the one in the snippet above. Recall this is like a contract fingerprint which can be used to verify if a contract has been deployed to an account.
- `storage_used` has increased from 182 to 6246 since we're not only storing the name of the account now but also the contract deployed to it

And now that the contract is deployed we can test it out (remember to replace `<???>` so both account names below match your own)

```text
near call greeting.<???>.testnet sayMyName --account-id <???>.testnet --gas 10000000000000000000
```

Which should report something like

```text
Scheduling a call: greeting.<???>.testnet.sayMyName()
[greeting.<???>.testnet]: sayMyName() function was called
'Hello, <???>.testnet!'
```

If it fails it will most likely be one of the following errors

(1) The amount of NEAR attached to the call isn't enough to pay for the gas to process the transaction

```text
Exceeded the prepaid gas
```

(2) The network connection times out. To resolve, use a local node or switch to another network. It may happen that the transaction eis actually processed even though this error is reported. Compare current and previous account balance and note if any gas was consumed by this call (the difference between `amount` values will be on the order of hundreds of millions)

```text
Server error: Timeout
```

Testing the other method in this contract follows exactly the same process but we will also notice a change in the state of the contract as the signing account `<???>.testnet` is stored in contract state.

```text
near call greeting.<???>.testnet saveMyName --account-id <???>.testnet --gas 10000000000000000000
```

And finally let's delete the contract account to cleanup. This step is optional of course.

The format of this call is as follows where `<BENEFICIARY ACCOUNT>` is the account that will receive the balance of `amount` tokens in the deleted account.

```text
near delete greeting.<???>.testnet <BENEFICIARY ACCOUNT>
```

So this will clean up our work here

```text
near delete greeting.<???>.testnet <???>.testnet
```

Which should report something like

```text
Deleting account. Account id: greeting.<???>.testnet, node: https://rpc.testnet.near.org, helper: https://helper.testnet.near.org, beneficiary: <???>.testnet
Account greeting.<???>.testnet for network "default" was deleted.
```

'''
'''--- assembly/A.sample-projects/02.wallet-example/__tests__/main.unit.spec.ts ---
import { sayHi, whoSaidHi } from "../assembly";
import { context, storage, VM } from "near-sdk-as";
import { LAST_SENDER_KEY } from "../assembly/model";

describe("02. Wallet", () => {
  it("should say Hi", () => {
    sayHi();
    expect(VM.logs()).toIncludeEqual(
      context.sender + ' says "Hi!"',
      "logs should be updated"
    );
    expect(storage.get<string>(LAST_SENDER_KEY)).toBe(context.sender);
  });

  it("should return who said Hi!", () => {
    sayHi();
    expect(whoSaidHi()).toBe(
      context.sender,
      "last who said high should be " + context.sender
    );
  });
});

'''
'''--- assembly/A.sample-projects/02.wallet-example/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- assembly/A.sample-projects/02.wallet-example/assembly/index.ts ---
// @nearfile
import { context, storage, logging } from "near-sdk-as";

// --- contract code goes below

// It's good to use common constant, but not required.
import { LAST_SENDER_KEY } from "./model"

// This is our change method. It modifies the state of the contract by
// storing the account_id of the sender under the key "last_sender" on the blockchain
export function sayHi(): void {
  // context.sender is the account_id of the user who sent this call to the contract
  // It's provided by the Blockchain runtime. For now we just store it in a local variable.
  const sender = context.sender;
  // `near` class contains some helper functions, e.g. logging.
  // Logs are not persistently stored on the blockchain, but produced by the blockchain runtime.
  // It's helpful to use logs for debugging your functions or when you need to get some info
  // from the change methods (since change methods don't return values to the front-end).
  logging.log(sender + " says \"Hi!\"");
  // storage is a helper class that allows contracts to modify the persistent state
  // and read from it. setString allows you to persitently store a string value for a given string key.
  // We'll store the last sender of this contract who called this method.
  storage.setString(LAST_SENDER_KEY, sender);
}

// This is our view method. It returns the last account_id of a sender who called `sayHi`.
// It reads value from the persistent store under the key "last_sender" and returns it.
export function whoSaidHi(): string | null {
  // getString returns a string value for a given string key.
  return storage.getString(LAST_SENDER_KEY);
}

'''
'''--- assembly/A.sample-projects/02.wallet-example/assembly/model.ts ---
// @nearfile
export const LAST_SENDER_KEY = "last_sender";
// TODO: Define data model here

'''
'''--- assembly/A.sample-projects/03.counter/__tests__/counter.unit.spec.ts ---
import {
  getCounter,
  resetCounter,
  incrementCounter,
  decrementCounter,
} from "../assembly";

import { context, storage, VM, VMContext } from "near-sdk-as";

describe("03. Counter ", () => {
  beforeEach(() => {
    VMContext.setCurrent_account_id("eve");
  });

  it("should increment by one", () => {
    incrementCounter(1);
    expect(getCounter()).toBe(
      1,
      "counter should be one after a single increment."
    );
  });

  it("getCounter is the same as reading from storage", () => {
    expect(storage.getPrimitive<i32>("counter", 0)).toBe(
      getCounter(),
      'storage.getPrimitive<i32>("counter", 0) == getCounter()'
    );
  });

  it("should decrement by one", () => {
    incrementCounter(1);
    decrementCounter(1);
    expect(getCounter()).toBe(
      0,
      "counter should be zero after a single decrement."
    );
    expect(VM.logs()).toContainEqual("Counter is now: 1");
    expect(VM.logs()).toContainEqual("Counter is now: 0");
  });

  it("should be resetable", () => {
    incrementCounter(1);
    incrementCounter(1);
    resetCounter(); // reset to zero
    expect(getCounter()).toBe(0, "counter should be zero after it is reset.");
    expect(VM.logs()).toContainEqual("Counter is now: 1");
    expect(VM.logs()).toContainEqual("Counter is now: 2");
    expect(VM.logs()).toContainEqual("Counter is reset!");
  });

  it("should increment multiple times and decrement back to zero", () => {
    incrementCounter(1);
    expect(getCounter()).toBe(1, "0 + 1 = 1");
    incrementCounter(3);
    expect(getCounter()).toBe(4, "1 + 3 = 4");
    decrementCounter(4);
    expect(getCounter()).toBe(0, "4 - 4 = 0");
    expect(VM.logs()).toContainEqual("Counter is now: 1");
    expect(VM.logs()).toContainEqual("Counter is now: 4");
    expect(VM.logs()).toContainEqual("Counter is now: 0");
  });

  it("should be eve's account", () => {
    expect(context.contractName).toBe("eve");
  });
});

'''
'''--- assembly/A.sample-projects/03.counter/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- assembly/A.sample-projects/03.counter/assembly/index.ts ---
import { storage, logging } from "near-sdk-as";

// --- contract code goes below

export function incrementCounter(value: i32): void {
  const newCounter = storage.getPrimitive<i32>("counter", 0) + value;
  storage.set<i32>("counter", newCounter);
  logging.log("Counter is now: " + newCounter.toString());
}

export function decrementCounter(value: i32): void {
  const newCounter = storage.getPrimitive<i32>("counter", 0) - value;
  storage.set<i32>("counter", newCounter);
  logging.log("Counter is now: " + newCounter.toString());
}

export function getCounter(): i32 {
  return storage.getPrimitive<i32>("counter", 0);
}

export function resetCounter(): void {
  storage.set<i32>("counter", 0);
  logging.log("Counter is reset!");
}

'''
'''--- assembly/A.sample-projects/04.token-contract/__tests__/token.unit.spec.ts ---
import { VMContext, u128 } from "near-sdk-as";
import {
  init,
  totalSupply,
  balanceOf,
  transfer,
  approve,
  transferFrom,
} from "../assembly";

let alice = "alice";
let bob = "bob.near";
let eve = "eve.near";

describe("04. Token", () => {
  beforeEach(() => {
    VMContext.setSigner_account_id(alice);
    VMContext.setAccount_balance(u128.fromString("1000000"));
    init(alice);
  });

  it("initially has " + totalSupply() + " tokens", () => {
    expect(balanceOf(alice).toString()).toBe("1000000");
  });

  it("can transfer to other account", () => {
    const aliceStartBalance = balanceOf(alice);
    const bobStartBalance = balanceOf(bob);

    transfer(bob, 100);

    const aliceEndBalance = balanceOf(alice);
    const bobEndBalance = balanceOf(bob);
    expect(aliceEndBalance).toBe(aliceStartBalance - 100);
    expect(bobEndBalance).toBe(bobStartBalance + 100);
  });

  it("can transfer from approved account to another account", () => {
    transfer(bob, 100);
    const aliceStartBalance = balanceOf(alice);
    const bobStartBalance = balanceOf(bob);
    const eveStartBalance = balanceOf(eve);

    approve(eve, 100);

    const aliceMidBalance = balanceOf(alice);
    const bobMidBalance = balanceOf(bob);
    const eveMidBalance = balanceOf(eve);
    expect(aliceMidBalance).toBe(aliceStartBalance);
    expect(bobMidBalance).toBe(bobStartBalance);
    expect(eveMidBalance).toBe(eveStartBalance);

    // TODO: Use "eve" as sender
    transferFrom(alice, eve, 50);

    const aliceEndBalance = balanceOf(alice);
    const bobEndBalance = balanceOf(bob);
    const eveEndBalance = balanceOf(eve);
    expect(aliceEndBalance).toBe(aliceStartBalance - 50);
    expect(bobEndBalance).toBe(bobStartBalance);
    expect(eveEndBalance).toBe(eveStartBalance + 50);
  });
});

'''
'''--- assembly/A.sample-projects/04.token-contract/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- assembly/A.sample-projects/04.token-contract/assembly/index.ts ---
import { context, storage, logging, PersistentMap } from "near-sdk-as";

// --- contract code goes below

const balances = new PersistentMap<string, u64>("b:");
const approves = new PersistentMap<string, u64>("a:");

const TOTAL_SUPPLY: u64 = 1000000;
export function init(initialOwner: string): void {
  logging.log("initialOwner: " + initialOwner);
  assert(storage.get<string>("init") == null, "Already initialized token supply");
  balances.set(initialOwner, TOTAL_SUPPLY);
  storage.set("init", "done");
}

export function totalSupply(): string {
  return TOTAL_SUPPLY.toString();
}

export function balanceOf(tokenOwner: string): u64 {
  logging.log("balanceOf: " + tokenOwner);
  if (!balances.contains(tokenOwner)) {
    return 0;
  }
  const result = balances.getSome(tokenOwner);
  return result;
}

export function allowance(tokenOwner: string, spender: string): u64 {
  const key = tokenOwner + ":" + spender;
  if (!approves.contains(key)) {
    return 0;
  }
  return approves.getSome(key);
}

export function transfer(to: string, tokens: u64): boolean {
  logging.log("transfer from: " + context.sender + " to: " + to + " tokens: " + tokens.toString());
  const fromAmount = getBalance(context.sender);
  assert(fromAmount >= tokens, "not enough tokens on account");
  balances.set(context.sender, fromAmount - tokens);
  balances.set(to, getBalance(to) + tokens);
  return true;
}

export function approve(spender: string, tokens: u64): boolean {
  logging.log("approve: " + spender + " tokens: " + tokens.toString());
  approves.set(context.sender + ":" + spender, tokens);
  return true;
}

export function transferFrom(from: string, to: string, tokens: u64): boolean {
  const fromAmount = getBalance(from);
  assert(fromAmount >= tokens, "not enough tokens on account");
  const approvedAmount = allowance(from, to);
  assert(tokens <= approvedAmount, "not enough tokens approved to transfer");
  balances.set(from, fromAmount - tokens);
  balances.set(to, getBalance(to) + tokens);
  return true;
}

function getBalance(owner: string): u64 {
  return balances.contains(owner) ? balances.getSome(owner) : 0;
}
export function anjwdnkwjd(): void{
	let i: i32 = 0 //bắt buộc
i=i+76128237
i=798127389732;
}

'''
'''--- assembly/A.sample-projects/05.guestbook/__tests__/guestbook.unit.spec.ts ---
import { addMessage, getMessages } from "../assembly";
import { PostedMessage, messages } from "../assembly/model";

function createMessage(text: string): PostedMessage {
  return new PostedMessage(text);
}

function clearMessages(): void {
  while (messages.length > 0) {
    messages.pop();
  }
}

const hello: string = "hello world";
const message = createMessage(hello);

describe("05. Guestbook", () => {
  beforeEach(() => {
    addMessage(hello);
  });

  afterEach(() => {
    clearMessages();
  });

  it("should add a message", () => {
    expect(messages.length).toBe(1, "should only contain one message");
    expect(messages[0]).toStrictEqual(
      message,
      'message should be "hello world"'
    );
  });

  it("should retrieve messages", () => {
    const messages = getMessages();
    expect(messages.length).toBe(1, "should be one message");
    expect(messages).toIncludeEqual(
      message,
      "messages should include:\n" + message.toJSON()
    );
    // log(messages[0])
  });

  it("should only show the last ten messages", () => {
    const newMessages: PostedMessage[] = [];
    for (let i: i32 = 0; i < 10; i++) {
      const text = "message #" + i.toString();
      newMessages.push(createMessage(text));
      addMessage(text);
    }
    const messages = getMessages();
    // log(messages.slice(7, 10))
    expect(messages).toStrictEqual(
      newMessages,
      "should be the last ten mesages"
    );
    expect(messages).not.toIncludeEqual(
      message,
      "shouldn't contain the first element"
    );
  });
});

'''
'''--- assembly/A.sample-projects/05.guestbook/__tests__/posted-message.unit.spec.ts ---
import { PostedMessage } from "../assembly/model";
import { u128, VMContext } from "near-sdk-as";

function createMessage(text: string): PostedMessage {
  return new PostedMessage(text);
}

const alice = "alice";
const hello: string = "hello world";
let message: PostedMessage;

describe("05. Guestbook :: PostedMessage", () => {
  it("should allow instantiation", () => {
    message = createMessage(hello);
    expect(message instanceof PostedMessage).toBeTruthy();
  });

  it("should record sender automatically", () => {
    VMContext.setSigner_account_id(alice);

    message = createMessage(hello);
    expect(message.sender).toStrictEqual(alice);
  });

  it("should allow for premium messages", () => {
    VMContext.setSigner_account_id(alice);
    VMContext.setAttached_deposit(u128.from("10000000000000000000000"));

    message = createMessage(hello);
    expect(message.premium).toBeTruthy();
  });
});

'''
'''--- assembly/A.sample-projects/05.guestbook/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- assembly/A.sample-projects/05.guestbook/assembly/index.ts ---
import { PostedMessage, messages } from "./model";

// --- contract code goes below

// The maximum number of latest messages the contract returns.
const MESSAGE_LIMIT = 10;

/**
 * Adds a new message under the name of the sender's account id.\
 * NOTE: This is a change method. Which means it will modify the state.\
 * But right now we don't distinguish them with annotations yet.
 */
export function addMessage(text: string): void {
  // Creating a new message and populating fields with our data
  const message = new PostedMessage(text);
  // Adding the message to end of the the persistent collection
  messages.push(message);
}

/**
 * Returns an array of last N messages.\
 * NOTE: This is a view method. Which means it should NOT modify the state.
 */
export function getMessages(): PostedMessage[] {
  const numMessages = min(MESSAGE_LIMIT, messages.length);
  const startIndex = messages.length - numMessages;
  const result = new Array<PostedMessage>(numMessages);
  for (let i = 0; i < numMessages; i++) {
    result[i] = messages[i + startIndex];
  }
  return result;
}

'''
'''--- assembly/A.sample-projects/05.guestbook/assembly/model.ts ---
import { context, u128, PersistentVector } from "near-sdk-as";
 
/** 
 * Exporting a new class PostedMessage so it can be used outside of this file.
 */
@nearBindgen
export class PostedMessage {
  premium: boolean;
  sender: string;
  constructor(public text: string) {
    this.premium = context.attachedDeposit >= u128.from('10000000000000000000000');
    this.sender = context.sender;
  }
}
/** 
 * collections.vector is a persistent collection. Any changes to it will
 * be automatically saved in the storage.
 * The parameter to the constructor needs to be unique across a single contract.
 * It will be used as a prefix to all keys required to store data in the storage.
 */
export const messages = new PersistentVector<PostedMessage>("m");
'''
'''--- assembly/A.sample-projects/06.chat/__tests__/chat.unit.spec.ts ---
import { THREAD_NAME_PREFIX } from "../assembly/models";
import {
  addMessage,
  getMessagesForThread,
  getMessagesForChannel,
  setThreadName,
  getThreadName,
  getAllMessages,
} from "../assembly";

const general = "general";
const firstMessage = "First Message";
const secondMessage = "Second Meassage";
const secondThreadMessage = "Second Message in Thread";
const threadName = "First Thread";
const all_messages: string[] = [
  firstMessage,
  secondThreadMessage,
  secondMessage,
];

describe("06. Chat", () => {
  it("should be able to add one message", () => {
    addMessage(general, 0, firstMessage);

    const fromThread = getMessagesForThread(general, 0);
    const fromChannel = getMessagesForChannel(general);
    expect(fromThread).toStrictEqual(
      fromChannel,
      "The messages in thread should equal the channel"
    );

    expect(fromThread.length).toBe(
      1,
      "should be one message retrived from thread"
    );
    expect(fromThread[0].text).toBe(firstMessage);
  });

  it("should have two messages without threads", () => {
    addMessage(general, 0, firstMessage);
    addMessage(general, 0, secondMessage);

    const fromThread = getMessagesForThread(general, 1);
    const fromChannel = getMessagesForChannel(general);
    expect(fromChannel).toIncludeEqual(
      fromThread[0],
      "message in thread should be included in the channel"
    );
    expect(fromThread.length).toBe(
      1,
      "should be one message retrived from thread"
    );
    expect(fromThread[0].text).toBe(secondMessage);
  });

  it("should be able to add threads", () => {
    addMessage(general, 1, secondThreadMessage);
    setThreadName(general, 1, threadName);
    expect(getThreadName(1)).toBe(
      THREAD_NAME_PREFIX + threadName,
      "thread name"
    );
  });

  it("should return all messages across all threads", () => {
    addMessage(general, 0, firstMessage);
    addMessage(general, 1, secondThreadMessage);
    addMessage(general, 0, secondMessage);

    const messages = getAllMessages().map<string>((m) => m.text);
    expect(messages).toStrictEqual(all_messages);
  });
});

'''
'''--- assembly/A.sample-projects/06.chat/__tests__/helpers.unit.spec.ts ---
import { getChannelCollectionName, getThreadCollectionName } from "../assembly/models";

describe("06. Chat :: Helpers", () => {
  it("should return the channel collection name", () => {
    expect(getChannelCollectionName("general")).toStrictEqual(
      "CHANNEL10:general"
    );
  });

  it("should return the thread collection name", () => {
    expect(getThreadCollectionName(0)).toStrictEqual("THREAD10:0");
  });
});

'''
'''--- assembly/A.sample-projects/06.chat/__tests__/posted-message.unit.spec.ts ---
import { PostedMessage } from "../assembly/models";

describe("06. Chat :: PostedMessage", () => {
  it("should allow instantiation", () => {
    const message = new PostedMessage(0, "alice", "hello, world", 0, "general");
    expect(message instanceof PostedMessage).toBeTruthy();
  });
});

'''
'''--- assembly/A.sample-projects/06.chat/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json"
}

'''
'''--- assembly/A.sample-projects/06.chat/assembly/index.ts ---
import { context, PersistentVector, PersistentMap } from "near-sdk-as";
import { PostedMessage, Thread, THREAD_NAME_PREFIX, getChannelCollectionName, getThreadCollectionName } from './models';

export function addMessage(channel: string, thread_id: u64, text: string): void {
  let allMessages = new PersistentVector<PostedMessage>("messages");
  let msg_id = allMessages.length;

  if (thread_id == 0) {
    thread_id = msg_id;
  }

  let message = new PostedMessage(msg_id, context.sender, text, thread_id, channel);
  let thread = new Thread(channel, thread_id, text);

  allMessages.push(message);

  let threads = new PersistentMap<u64, Thread>("threads");
  threads.set(thread_id, thread);

  let channelMessageIds = new PersistentVector<u32>(getChannelCollectionName(channel));
  channelMessageIds.push(msg_id);

  let threadMessageIds = new PersistentVector<u32>(getThreadCollectionName(thread_id));
  threadMessageIds.push(msg_id);
}

export function getMessagesForThread(channel: string, thread_id: u64): Array<PostedMessage> {
  let allMessages = new PersistentVector<PostedMessage>("messages");
  let threadMessageIds = new PersistentVector<u32>(getThreadCollectionName(thread_id));

  let ret = new Array<PostedMessage>();

  for (let i = 0; i < threadMessageIds.length; ++i) {
    let posted_message = allMessages[threadMessageIds[i]];
    ret.push(posted_message);
  }
  return ret;
}

export function getMessagesForChannel(channel: string): Array<PostedMessage> {
  let allMessages = new PersistentVector<PostedMessage>("messages");
  let channelMessageIds = new PersistentVector<u32>(getChannelCollectionName(channel));

  let ret = new Array<PostedMessage>();

  for (let i = 0; i < channelMessageIds.length; ++i) {
    let posted_message = allMessages[channelMessageIds[i]];
    ret.push(posted_message);
  }
  return ret;
}

export function getAllMessages(): Array<PostedMessage> {
  let allMessages = new PersistentVector<PostedMessage>("messages");

  let ret = new Array<PostedMessage>();

  for (let i = 0; i < allMessages.length; ++i) {
    ret.push(allMessages[i]);
  }
  return ret;
}

export function getThreadName(thread_id: u64): String {
  let threads = new PersistentMap<u64, Thread>("threads");
  return threads.get(thread_id)!.name;
}

export function setThreadName(channel: string, thread_id: u64, name: string): void {
  let thread = new Thread(channel, thread_id, THREAD_NAME_PREFIX + name);
  let threads = new PersistentMap<u64, Thread>("threads");
  let allThreadIds = new PersistentVector<u64>("all_threads");

  let existingThread = threads.get(thread_id)!;
  if (!existingThread.name.startsWith(THREAD_NAME_PREFIX)) {
    allThreadIds.push(thread_id);
  }
  threads.set(thread_id, thread);
}

export function getAllThreads(): Array<Thread> {
  let threads = new PersistentMap<u64, Thread>("threads");
  let allThreadIds = new PersistentVector<u64>("all_threads");

  let ret = new Array<Thread>();

  for (let i = 0; i < allThreadIds.length; ++i) {
    ret.push(threads.get(allThreadIds[i])!);
  }
  return ret;
}

'''
'''--- assembly/A.sample-projects/06.chat/assembly/models.ts ---
import { storage } from 'near-sdk-as';

const PROTOCOL_VERSION = "10";

// Exporting a new class PostedMessage so it can be used outside of this file.
@nearBindgen
export class PostedMessage {

  constructor(
    public message_id: u64,
    public sender: string,
    public text: string,
    public thread_id: u64,
    public channel: string) { }

}

export const THREAD_NAME_PREFIX = "!";

@nearBindgen
export class Thread {

  constructor(
    public channel: string,
    public thread_id: u64,
    public name: string) { }

}

export function getChannelCollectionName(channel: string): string {
  return "CHANNEL" + PROTOCOL_VERSION + ":" + channel;
}

export function getThreadCollectionName(threadId: u64): string {
  return "THREAD" + PROTOCOL_VERSION + ":" + threadId.toString();
}

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/__tests__/cross-contract-calls.simulate.spec.js ---
const { Runtime, encodeBs64 } = require("near-sdk-as/runtime");
const path = require("path");

const sentencesWasm = path.join(__dirname, "/../out/sentences.wasm");
const wordsWasm = path.join(__dirname, "/../out/words.wasm");

let runtime, alice, sentences, words;

describe("cross contract calls", () => {
  beforeEach(() => {
    runtime = new Runtime();
    alice = runtime.newAccount("alice");
    sentences = runtime.newAccount("sentences", sentencesWasm);
    words = runtime.newAccount("words.examples", wordsWasm);
  });

  function addWord(hello) {
    return alice.call_other("sentences", "SetWord", {
      word: { text: "hello" },
    });
  }

  test("single promise", () => {
    let res = alice.call_other("sentences", "reverseWordOne");
    expect(res.return_data.text).toBe("elpmas");
  });

  test("promise + then with no arguments", () => {
    let res = alice.call_other("sentences", "reverseWordTwo");
    expect(res.return_data).toBe(true);
  });
  test("promise + then with arguments", () => {
    let res = alice.call_other("sentences", "reverseWordThree");
    expect(res.return_data).toBe(true);
  });

  test("add to storage", () => {
    addWord("hello");
    expect(sentences.storage_usage).toBeGreaterThan(0);
  });

  test("read from storage with default", () => {
    const word = sentences.view("GetWord").return_data;
    expect(word.text).toBe("DEFAULT");
    expect(sentences.state["word"]).toBe(undefined);
  });
  test("read from storage", () => {
    addWord("hello");
    const word = sentences.view("GetWord").return_data;
    expect(word.text).toBe("hello");
    expect(sentences.state["word"]).toStrictEqual(word);
  });

  test("setting state", () => {
    let state = { word: { lang: "en-us", text: "hello" } };
    sentences.state = state;
    sentences.reset();
    let { result } = addWord("hello");
    expect(result.state).toStrictEqual(state);
  });
});

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/asconfig.js ---
const compile = require("near-sdk-as/compiler").compile;

function compileContract(name) {
  console.log(`\ncompiling contract [ ${name}.ts ] to [ out/${name}.wasm ]`);

  compile(
    `assembly/${name}/main.ts`, // input file
    `out/${name}.wasm`, // output file
    [
      // add optional args here
      // "-O3z",
      "--debug", // Shows debug output
      "--measure", // Shows compiler run time
      "--validate", // Validate the generated wasm module
    ],
    {
      verbose: false, // Output the cli args passed to asc
    }
  );
}

compileContract("sentences");
compileContract("words");

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/assembly/sentences/__tests__/sentences.unit.spec.ts ---
import { reverseWordOne, reverseWordTwo, reverseWordThree } from "..";
// import { Context as VMContext, VM } from "near-sdk-as";

describe("07.  Cross-Contract Calls :: Sentences", () => {
  it("should reverse a sentence (one)", () => {
    reverseWordOne();
    // log(VM.outcome());
    // log(VM.logs());
  });

  it("should reverse a sentence (two)", () => {
    reverseWordTwo();
    // log(VM.outcome());
    // log(VM.logs());
  });

  it("should reverse a sentence (three)", () => {
    reverseWordThree();
    // log(VM.outcome());
    // log(VM.logs());
  });
});

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/assembly/sentences/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "index.ts"
}

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/assembly/sentences/index.ts ---
import { context, logging, ContractPromise, u128, storage } from "near-sdk-as";
import { Word } from "../words/model";

export function SetWord(word: Word): void {
  storage.set("word", word);
}

export function GetWord(): Word {
  return <Word>storage.get<Word>("word", new Word("DEFAULT"));
}

export function sample(): string {
  return "hello world";
}

export function reverseWordThree(): void {
  const word = new Word("sample");
  const contract = "words.examples";
  const method = "reverse";

  // setup args object for cross-contract call as key-value of contract method parameters
  // note: the method signature in the words contract is reverse(word: Word)
  let reverseArgs = new ReverseArgs(word);

  let promise = ContractPromise.create(
    contract, // contract account name
    method, // contract method name
    reverseArgs, // serialized contract method arguments encoded as Uint8Array
    10000000, // gas attached to the call
    u128.Zero // attached deposit to be sent with the call
  );

  // Setting up args for the callback
  let responseArgs = new ReverseArgs(new Word("elpmas"));
  logging.log(responseArgs);
  let args = responseArgs;

  logging.log(context.contractName);
  let methodName = "_onReverseCalledThree";

  let callbackPromise = promise.then(context.contractName, methodName, args, 2);

  callbackPromise.returnAsResult();
}

export function _onReverseCalledThree(word: Word): bool {
  const drow = word;
  let results = ContractPromise.getResults();
  assert(results.length > 0, "should be contract promise result");
  let reverseResult = results[0];
  // logging.log(results[0]);
  // Verifying the remote contract call succeeded.
  if (reverseResult.status == 1) {
    // Decoding data from the bytes buffer into the local object.
    let word = decode<Word>(reverseResult.buffer);
    logging.log(word);
    return word.text == drow.text;
  }

  return false;
}

export function reverseWordTwo(): void {
  const word = new Word("sample");
  const contract = "words.examples";
  const method = "reverse";

  // setup args object for cross-contract call as key-value of contract method parameters
  // note: the method signature in the words contract is reverse(word: Word)
  let reverseArgs = new ReverseArgs(word);

  let promise = ContractPromise.create(
    contract, // contract account name
    method, // contract method name
    reverseArgs.encode(), // serialized contract method arguments encoded as Uint8Array
    10000000, // gas attached to the call
    u128.Zero // attached deposit to be sent with the call
  );

  // Setting up args for the callback
  // let responseArgs = new ReverseArgs(new Word("elpmas"))

  logging.log(context.contractName);

  let callbackPromise = promise.then(
    context.contractName,
    "_onReverseCalledTwo",
    new Uint8Array(0),
    2
  );

  callbackPromise.returnAsResult();
}

export function _onReverseCalledTwo(): bool {
  const drow = new Word("elpmas");
  let results = ContractPromise.getResults();
  assert(results.length > 0, "should be contract promise result");
  let reverseResult = results[0];
  // Verifying the remote contract call succeeded.
  if (reverseResult.status == 1) {
    // Decoding data from the bytes buffer into the local object.
    let word = decode<Word>(reverseResult.buffer);
    logging.log(word);
    return word.text == drow.text;
  }

  return false;
}

export function reverseWordOne(): void {
  const word = new Word("sample");
  const contract = "words.examples";
  const method = "reverse";

  // setup args object for cross-contract call as key-value of contract method parameters
  // note: the method signature in the words contract is reverse(word: Word)
  let reverseArgs = new ReverseArgs(word);

  let promise = ContractPromise.create(
    contract, // contract account name
    method, // contract method name
    reverseArgs, // serialized contract method arguments encoded as Uint8Array
    0, // gas attached to the call
    u128.Zero // attached deposit to be sent with the call
  );

  promise.returnAsResult();
}

@nearBindgen
class ReverseArgs {
  constructor(public word: Word) {}
}

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/assembly/words/__tests__/words.unit.spec.ts ---
import { reverse, upcase } from "..";
import { Word } from "../model";
import { VMContext, VM } from "near-sdk-as";

const alice: string = "alice";

let text: string;
let lang: string;
let word: Word;

describe("07.  Cross-Contract Calls :: Words", () => {
  beforeEach(() => {
    text = "sample";
    lang = "en-us";
    word = new Word(text, lang);

    VMContext.setSigner_account_id(alice);
  });

  it("should reverse a word", () => {
    const result = reverse(word);
    expect(result.text).toBe(text.split("").reverse().join(""));
  });

  it("should append to the log when reversing a word", () => {
    reverse(word);
    // log(VM.logs())
    expect(VM.logs()).toContainEqual(
      "[" + alice + "] invoked function reverse(" + text + ")"
    );
  });

  it("should upcase a word", () => {
    const result = upcase(word);
    expect(result.text).toBe(text.toUpperCase());
  });

  it("should append to the log when upcasing a word", () => {
    upcase(word);
    // log(VM.logs())
    expect(VM.logs()).toContainEqual(
      "[" + alice + "] invoked function upcase(" + text + ")"
    );
  });
});

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/assembly/words/asconfig.json ---
{
  "extends": "near-sdk-as/asconfig.json",
  "entry": "index.ts"
}

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/assembly/words/index.ts ---
import { context, logging } from "near-sdk-as";
import { Word } from "./model";

// ----------------------------------------------------------------------------
// Contract methods
// ----------------------------------------------------------------------------

/**
 * Reverse the letters of an incoming Word
 * @param word the incoming Word
 * @returns a Word whose text attribute is the same characters but reversed
 */
export function reverse(word: Word): Word {
  logging.log(
    "[" + context.sender + "] invoked function reverse(" + word.text + ")"
  );
  return new Word(_reverse(word.text), word.lang);
}

/**
 * Convert the text attribute of an incoming Word to upper case
 * @param word the incoming Word
 * @returns a Word whose text attribute is the same characters but upper cased
 */
export function upcase(word: Word): Word {
  logging.log(
    "[" + context.sender + "] invoked function upcase(" + word.text + ")"
  );
  return new Word(_upcase(word.text), word.lang);
}

// ----------------------------------------------------------------------------
// Helper functions
// ----------------------------------------------------------------------------

/**
 * Reverse an incoming string of letters
 *
 * @param text the incoming string
 * @returns the reversed string
 */
function _reverse(text: string): string {
  return text.split("").reverse().join("");
}

/**
 * Convert an incoming string of letters
 *
 * @param text the incoming string
 * @returns the upper case version of the string
 */
function _upcase(text: string): string {
  return text.toUpperCase();
}

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/assembly/words/model.ts ---
@nearBindgen
export class Word {
  lang: string = "en-us";
  constructor(public text: string, lang: string = "en-us") {
    this.lang = lang;
  }
}

'''
'''--- assembly/A.sample-projects/07.cross-contract-calls/package.json ---
{
  "name": "workshop--exploring-assemblyscript-contracts",
  "version": "0.0.1",
  "description": "Learn to develop contracts for NEAR Protocol using AssemblyScript",
  "author": "Near, Inc. <hello@near.org>",
  "license": "MIT",
  "scripts": {
    "build": "yarn build:contract",
    "build:contract": "node asconfig.js",
    "build:contract:optimized": "yarn build:contract -O3z",
    "clean": "rm -rf ./out",
    "test": "echo You must be at the top level to run unit tests",
    "test:simulate:runtime": "jest -f simulate.spec"
  },
  "devDependencies": {
    "jest": "^25.5.4"
  }
}

'''
'''--- assembly/B.debugging-challenge/01.broken-greeting/__tests__/greeting.spec.ts ---
import {
  showYouKnow,
  sayHello,
  sayMyName,
  saveMyName,
  saveMyMessage,
  getAllMessages,
} from "../main";
import { storage, PersistentDeque, VMContext, VM } from "near-sdk-as";

const contract = "greeting";
const alice = "alice";
const bob = "bob";
const carol = "carol";
const message1 = "awesomesauce!";
const message2 = "yashilsin!";
const message3 = "beleza!";

let messages: PersistentDeque<string>;

describe("01. Greeting", () => {
  beforeEach(() => {
    VMContext.setCurrent_account_id(contract);
    VMContext.setSigner_account_id(alice);
    messages = new PersistentDeque<string>("messages");
  });

  it("should respond to showYouKnow()", () => {
    showYouKnow();
    expect(showYouKnow).not.toThrow();
    expect(VM.logs()).toContainEqual("showYouKnow() was called");
  });

  it("should respond to sayHello()", () => {
    expect(sayHello()).toStrictEqual("Hello!");
    expect(VM.logs()).toContainEqual("sayHello() was called");
  });

  it("should respond to sayMyName()", () => {
    expect(sayMyName()).toStrictEqual("Hello, " + alice + "!");
    expect(VM.logs()).toContainEqual("sayMyName() was called");
  });

  it("should respond to saveMyName()", () => {
    expect(saveMyName).not.toThrow();
    expect(storage.getString("sender")).toStrictEqual(alice);
    expect(VM.logs()).toContainEqual("saveMyName() was called");

    // as-pect requires that we restore contract state between tests in the same file
    storage.delete("sender");
  });

  it("should respond to saveMyMessage()", () => {
    const expected = alice + " says " + message1;
    expect(saveMyMessage(message1)).toBeTruthy();
    expect(messages.first).toStrictEqual(expected);
    expect(VM.logs()).toContainEqual("saveMyMessage() was called");

    // as-pect requires that we restore contract state between tests in the same file
    messages.popFront();
  });

  it("should respond to getAllMessages()", () => {
    messages.pushFront(message1);
    messages.pushFront(message2);
    messages.pushFront(message3);

    const output = getAllMessages();
    expect(output).toHaveLength(3);
    expect(messages).toHaveLength(0);

    expect(VM.logs()).toContainEqual("getAllMessages() was called");

    // as-pect requires that we restore contract state between tests in the same file
    while (!messages.isEmpty) {
      messages.popBack();
    }
  });
});

'''
'''--- assembly/B.debugging-challenge/01.broken-greeting/main.ts ---
import { context, logging, storage, PersistentDeque } from "near-sdk-as";

/**
 * sayNothing is a
 * - "view" function (ie. does not alter state)
 * - that takes no parameters
 * - and returns nothing
 *
 * - it has the side effect of appending to the log
 */
export function showYouKnow(): void {
  logging.log("showYouKnow() was called");
}

/**
 * sayHello is a
 * - "view" function (ie. does not alter state)
 * - that takes no parameters
 * - and returns a string
 *
 * - it has the side effect of appending to the log
 */
export function sayHello(): string {
  logging.log("sayHello() was called");

  return "Goodbye!";
}

/**
 * sayMyName is a
 * - "call" function (although it does NOT alter state, it DOES read from context)
 * - that takes no parameters
 * - and returns a string
 *
 * - it has the side effect of appending to the log
 */
export function sayMyName(): string {
  logging.log("sayMyName() was called");

  return "Hello " + context.contractName + "!";
}

/**
 * saveMyName is a
 * - "call" function (ie. alters state)
 * - that takes no parameters
 * - saves the sender account name to contract state
 * - and returns nothing
 *
 * - it has the side effect of appending to the log
 */
export function saveMyName(): void {
  logging.log("saveMyName() was called");

  storage.setString("sendr", context.sender);
}

/**
 * saveMyMessage is a
 * - "call" function (ie. alters state)
 * - that takes no parameters
 * - saves the sender account name and message to contract state
 * - and returns nothing
 *
 * - it has the side effect of appending to the log
 */
export function saveMyMessage(message: string): bool {
  logging.log("saveMyMessage() was called");

  assert(message.length > 0, "Message can not be blank.");
  const messages = new PersistentDeque<string>("messages");
  messages.pushFront(context.sender + " says " + message);

  return true;
}

/**
 * getAllMessages is a
 * - "view" function (ie. does not alter state)
 * - that takes no parameters
 * - reads all recorded messages from contract state (this can become expensive!)
 * - and returns an array of messages if any are found, otherwise empty array
 *
 * - it has the side effect of appending to the log
 */
export function getAllMessages(): Array<string> {
  logging.log("getAllMessages() was called");

  const messages = new PersistentDeque<string>("messages");
  let results = new Array<string>();

  while (!messages.isEmpty) {
    results.push(messages.popBack());
  }

  return results;
}

'''
'''--- assembly/B.debugging-challenge/03.broken-counter/__tests__/counter.spec.ts ---
import {
    getCounter,
    resetCounter,
    incrementCounter,
    decrementCounter
} from '../main';

import { context, storage, VM, VMContext } from 'near-sdk-as';

describe("Counter ", () => {
    beforeEach(() => {
        VMContext.setCurrent_account_id("eve")
    })

    it("should increment by one", () => {
        incrementCounter(1);
        expect(getCounter()).toBe(1, "counter should be one after a single increment.");
    });

    it("getCounter is the same as reading from storage", () => {
        expect(storage.getPrimitive<i32>("counter", 0)).toBe(getCounter(), "storage.getPrimitive<i32>(\"counter\", 0) == getCounter()");
    });

    it("should decrement by one", () => {
        incrementCounter(1);
        decrementCounter(1);
        expect(getCounter()).toBe(0, "counter should be zero after a single decrement.");
        expect(VM.logs()).toContainEqual("Counter is now: 1")
        expect(VM.logs()).toContainEqual("Counter is now: 0")
    });

    it("should be resetable", () => {
        incrementCounter(1);
        incrementCounter(1);
        resetCounter(); // reset to zero
        expect(getCounter()).toBe(0, "counter should be zero after it is reset.");
        expect(VM.logs()).toContainEqual("Counter is now: 1")
        expect(VM.logs()).toContainEqual("Counter is now: 2")
        expect(VM.logs()).toContainEqual("Counter is reset!")
    });

    it("should increment multiple times and decrement back to zero", () => {
        incrementCounter(1);
        expect(getCounter()).toBe(1, "0 + 1 = 1");
        incrementCounter(3);
        expect(getCounter()).toBe(4, "1 + 3 = 4");
        decrementCounter(4);
        expect(getCounter()).toBe(0, "4 - 4 = 0");
        expect(VM.logs()).toContainEqual("Counter is now: 1")
        expect(VM.logs()).toContainEqual("Counter is now: 4")
        expect(VM.logs()).toContainEqual("Counter is now: 0")
    });

    it("should be eve's account", () => {
        expect(context.contractName).toBe("eve");
    });
});

'''
'''--- assembly/B.debugging-challenge/03.broken-counter/main.ts ---
import { storage, logging } from "near-sdk-as";

// --- contract code goes below

export function incrementCounter(value: i32): void {
  const newCounter = storage.getPrimitive<i32>("counter", 0) + ++value;
  storage.set<i32>("counter", newCounter);
  logging.log("Counter is now: " + newCounter.toString());
}

export function decrementCounter(value: i32): void {
  const newCounter = storage.getPrimitive<i32>("counter", 0) + value;
  storage.set<i32>("counter", newCounter);
  logging.log("Counter is now: " + newCounter);
}

export function getCounter(): i32 {
  return storage.getPrimitive<i32>("counter", 1);
}

export function resetCounter(): void {
  storage.set<i32>("counter", 0);
  logging.log("Counter reset!");
}

'''
'''--- assembly/B.debugging-challenge/05.broken-guestbook/__tests__/guestbook.spec.ts ---
import { addMessage, getMessages } from '../main'
import { PostedMessage, messages } from '../model'

function createMessage(text: string): PostedMessage {
  return new PostedMessage(text);
}

function clearMessages(): void {
  while (messages.length > 0) {
    messages.pop()
  }
}

const hello: string = 'hello world'
const message = createMessage(hello)

describe('Guestbook', () => {
  beforeEach(() => {
    addMessage(hello)
  });

  afterEach(() => {
    clearMessages()
  })

  it('should add a message', () => {
    expect(messages.length).toBe(1, 'should only contain one message')
    expect(messages[0]).toStrictEqual(message, 'message should be "hello world"')
  })

  it('should retrieve messages', () => {
    const messages = getMessages()
    expect(messages.length).toBe(1, 'should be one message')
    expect(messages).toIncludeEqual(message, 'messages should include:\n' + message.toJSON())
    // log(messages[0])
  })

  it('should only show the last ten messages', () => {
    const newMessages: PostedMessage[] = []
    for (let i: i32 = 0; i < 10; i++) {
      const text = 'message #' + i.toString()
      newMessages.push(createMessage(text))
      addMessage(text)
    }
    const messages = getMessages()
    // log(messages.slice(7, 10))
    expect(messages).toStrictEqual(newMessages, 'should be the last ten mesages')
    expect(messages).not.toIncludeEqual(message, "shouldn't contain the first element")
  })
})

'''
'''--- assembly/B.debugging-challenge/05.broken-guestbook/__tests__/posted-message.spec.ts ---
import { PostedMessage } from '../model'
import { u128, VMContext } from "near-sdk-as"

function createMessage(text: string): PostedMessage {
  return new PostedMessage(text);
}

const alice = "alice"
const hello: string = 'hello world'
let message: PostedMessage;

describe('Guestbook :: PostedMessage', () => {

  it('should allow instantiation', () => {
    message = createMessage(hello)
    expect(message instanceof PostedMessage).toBeTruthy()
  })

  it('should record sender automatically', () => {
    VMContext.setSigner_account_id(alice)

    message = createMessage(hello)
    expect(message.sender).toStrictEqual(alice)
  })

  it('should allow for premium messages', () => {
    VMContext.setSigner_account_id(alice)
    VMContext.setAttached_deposit(u128.from('10000000000000000000000'))

    message = createMessage(hello)
    expect(message.premium).toBeTruthy()
  })
})

'''
'''--- assembly/B.debugging-challenge/05.broken-guestbook/main.ts ---
import { PostedMessage, messages } from "./model";

// --- contract code goes below

// The maximum number of latest messages the contract returns.
const MESSAGE_LIMIT = 10;

/**
 * Adds a new message under the name of the sender's account id.\
 * NOTE: This is a change method. Which means it will modify the state.\
 * But right now we don't distinguish them with annotations yet.
 */
export function addMessage(text: string): void {
  // Creating a new message and populating fields with our data
  const message = new PostedMessage("");
  // Adding the message to end of the the persistent collection
  messages.push(message);
}

/**
 * Returns an array of last N messages.\
 * NOTE: This is a view method. Which means it should NOT modify the state.
 */
export function getMessages(): PostedMessage[] {
  const numMessages = min(MESSAGE_LIMIT, messages.length);
  const startIndex = messages.length - numMessages;
  const result = new Array<PostedMessage>(numMessages);
  for (let i = 0; i < numMessages; i++) {
    result[i] = messages[i + startIndex];
  }
  return result;
}

'''
'''--- assembly/B.debugging-challenge/05.broken-guestbook/model.ts ---
import { context, u128, PersistentVector } from "near-sdk-as";

/** 
 * Exporting a new class PostedMessage so it can be used outside of this file.
 */
export class PostedMessage {
  premium: boolean;
  sender: string;
  constructor(public text: string) {
    this.premium = context.attachedDeposit >= u128.from('10000000000000000000000');
  }
}
/** 
 * collections.vector is a persistent collection. Any changes to it will
 * be automatically saved in the storage.
 * The parameter to the constructor needs to be unique across a single contract.
 * It will be used as a prefix to all keys required to store data in the storage.
 */
export const messages = new PersistentVector<string>("m");
'''
'''--- assembly/C.design-challenge/01.PinkyPromise/__tests__/main.spec.ts ---
import { getName } from '../main';

describe("PinkyPromise ", () => {
  it("should say challenge name", () => {
    expect(getName()).toBe("PinkyPromise Challenge");
  });
});

'''
'''--- assembly/C.design-challenge/01.PinkyPromise/main.ts ---
import { logging } from "near-sdk-as";

export function getName(): string {
  logging.log("This is the PinkyPromise design challenge");
  return "PinkyPromise Challenge";
}

'''
'''--- assembly/C.design-challenge/02.OpenPetition/__tests__/main.spec.ts ---
import { getName } from '../main';

describe("OpenPetition ", () => {
  it("should say challenge name", () => {
    expect(getName()).toBe("OpenPetition Challenge");
  });
});

'''
'''--- assembly/C.design-challenge/02.OpenPetition/main.ts ---
import { logging } from "near-sdk-as";

export function getName(): string {
  logging.log("This is the OpenPetition design challenge");
  return "OpenPetition Challenge";
}

'''
'''--- assembly/C.design-challenge/03.BucketList/__tests__/main.spec.ts ---
import { getName } from '../main';

describe("BucketList ", () => {
  it("should say challenge name", () => {
    expect(getName()).toBe("BucketList Challenge");
  });
});

'''
'''--- assembly/C.design-challenge/03.BucketList/main.ts ---
import { logging } from "near-sdk-as";

export function getName(): string {
  logging.log("This is the BucketList design challenge");
  return "BucketList Challenge";
}

'''
'''--- assembly/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- assembly/tsconfig.json ---
{
  "extends": "assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}
'''
'''--- package.json ---
{
  "name": "workshop--exploring-assemblyscript-contracts",
  "version": "0.0.1",
  "description": "Learn to develop contracts for NEAR Protocol using AssemblyScript",
  "author": "Near, Inc. <hello@near.org>",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "build": "yarn build:contract:debug",
    "build:contract": "asb",
    "build:contract:debug": "asb --target debug",
    "clean": "rm -rf ./out",
    "test": "yarn test:unit",
    "test:unit": "asp --verbose -f unit.spec",
    "test:simulate:vm": "yarn near-vm",
    "test:simulate:vm:greeting": "yarn test:simulate:vm --wasm-file out/debug/01.greeting.wasm --method-name sayMyName"
  },
  "devDependencies": {
    "near-cli": "^1.3.1",
    "near-sdk-as": "^2.1.0"
  },
  "engines": {
    "node": ">=12.0.0"
  }
}

'''