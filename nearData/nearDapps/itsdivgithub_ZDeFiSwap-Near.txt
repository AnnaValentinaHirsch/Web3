*GitHub Repository "itsdivgithub/ZDeFiSwap-Near"*

'''--- README.md ---
# ENCODE X NEAR HORIZON 2023

## DEPLOYMENT NEAR ORG-  test.near.org
Introduction:
ZSwap is a decentralized exchange (DEX) that has tackled two significant challenges in the DeFi space: concentrated liquidity and centralized frontends. By enabling liquidity providers to focus on specific price ranges and integrating BOS on NEAR, ZSwap has achieved a fully decentralized and efficient liquidity DEX. However, this journey hasn't been without its challenges, particularly in terms of BOS integration and navigating the intricacies of cross-contract calling on NEAR.

Scaling with Near Protocol:
Scaling ZSwap with Near Protocol is a strategic move aimed at addressing the challenges and seizing new opportunities for growth. Here are our plans for scaling the project:

Leveraging Near's Infrastructure:
Near Protocol offers a highly scalable and efficient blockchain infrastructure that can handle a large number of transactions with low latency. ZSwap intends to harness Near's capabilities to enhance the speed and scalability of the platform, ensuring that users can execute trades quickly and without delays.

Expanding Liquidity Pools:
Near Protocol's smart contract capabilities make it easier to manage and expand liquidity pools. ZSwap plans to introduce more liquidity pairs and incentivize liquidity providers through rewards, attracting a broader range of assets and liquidity to the platform.

Ecosystem Integration:
Near Protocol has a growing ecosystem of DeFi projects and developers. ZSwap will actively engage with this ecosystem to foster collaborations, cross-integrations, and shared liquidity, creating a more interconnected DeFi environment on Near.

User-Friendly Interface:
ZSwap's commitment to decentralization includes providing a user-friendly interface that is easily accessible to both experienced DeFi users and newcomers. The Near ecosystem supports the development of user-friendly dApps, and ZSwap plans to take advantage of this to improve the user experience.

Security and Trustless Operations:
Near Protocol's focus on security and trustless operations aligns well with ZSwap's objectives. As the platform grows, ZSwap will continue to prioritize security by conducting regular audits and enhancing smart contract security.

Bridging to Other Networks:
Near Protocol's bridge capabilities enable interoperability with other blockchain networks. ZSwap intends to explore the possibilities of bridging assets to and from Near, expanding its reach and liquidity sources.

Conclusion:
Scaling with Near Protocol presents an exciting opportunity for ZSwap to address liquidity challenges, enhance user experiences, and tap into a growing DeFi ecosystem. While there have been hurdles along the way, the unique features and potential of Near Protocol offer a promising future for ZSwap as a fully decentralized and efficient liquidity DEX. As we move forward, we remain committed to overcoming challenges and providing innovative solutions to our users within the Near ecosystem.

'''
'''--- zswap-contracts-main/Cargo.toml ---
[workspace]
members = ["library", "pool", "manager", "factory", "integration-tests"]

[profile.dev]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- zswap-contracts-main/README.md ---
# ZSwap

## Step 0: Create a new account

0. Install near-cli

```sh
$ npm install --global near-cli
```

1. Create a new account on [MyNearWallet testnet](https://testnet.mynearwallet.com/)

2. Authorize NEAR CLI, following the commands it gives you:

```sh
# login to zswap.testnet account
$ near login --walletUrl https://testnet.mynearwallet.com
```

3. Create a subaccount (optional):

```sh
# create `sub.zswap.testnet` for `zswap.testnet` with 20 NEAR
$ near create-account sub.zswap.testnet --masterAccount zswap.testnet --initialBalance 20
```

## Step 1: Mint tokens

1. Mint `ZNEAR`

```sh
# mint 100000 ZNEAR for zswap.testnet
$ near call znear.zswap.testnet mint '{"receiver_id":"zswap.testnet", "amount": "100000"}' --deposit 1 --accountId zswap.testnet
```

2. Mint `ZUSD`

```sh
# mint 20000 ZUSD for zswap.testnet
$ near call zusd.zswap.testnet mint '{"receiver_id":"zswap.testnet", "amount": "200000"}' --deposit 1 --accountId zswap.testnet
```

## Step 2: Create Pool with Factory

If testing with `ZNEAR` and `ZUSD`, you can skip this step.

1. Create a new pool for ZNEAR - ZUSD. Factory only supports creating a new pool with 2 fee levels: 0.05% and 0.3%.

```sh
$ ZSWAP_FACTORY=factory3.zswap.testnet
$ ZSWAP_MANAGER=manager3.zswap.testnet

# 1 ZNEAR = 100 ZUSD, tick ~ 46054
$ SQRT_PRICE_X96="792281625142643375935439503360"
$ near call $ZSWAP_MANAGER create_pool \
  '{"token_0":"znear.zswap.testnet","token_1":"zusd.zswap.testnet","fee":3000,"sqrt_price_x96":"'$SQRT_PRICE_X96'"}' \
  --accountId zswap.testnet --gas 300000000000000 --deposit 25

# return pool address
'2e4e39194a383739.factory3.zswap.testnet'

$ ZSWAP_POOL="2e4e39194a383739.factory3.zswap.testnet"
```

- View pool state

```sh
$ near view $ZSWAP_FACTORY get_pool '{"token_0":"zusd.zswap.testnet", "token_1":"znear.zswap.testnet","fee":3000}'

{
  pool_id: '2e4e39194a383739.factory3.zswap.testnet',
  token_0: 'znear.zswap.testnet',
  token_1: 'zusd.zswap.testnet',
  fee: 3000,
  tick_spacing: 60
}

# view current price
$ near view $ZSWAP_POOL get_slot_0 '{}'

{ sqrt_price_x96: '792281625142643375935439503360', tick: 46054 }
```

2 (**Optional**). Initialize `sqrt_price` (token0 / token1), calling when current_price is ZERO.

```sh
# 1 ZNEAR = 100 ZUSD, tick ~ 46054
$ near call $ZSWAP_POOL initialize '{"sqrt_price_x96":"792281625142643375935439503360"}' --accountId zswap.testnet

# view current price
$ near view $ZSWAP_POOL get_slot_0 '{}'

{ sqrt_price_x96: '792281625142643375935439503360', tick: 46054 }

```

3. Get list of existed tokens in ZSwap Manager

```sh
$ near view $ZSWAP_MANAGER get_fungible_tokens

[ "znear.zswap.test", "zusd.zswap.testnet" ]
```

## Step 3: Mint Liquidity

1. Deposit ZNEAR into `ZswapPool`

```sh
$ ZNEAR_AMOUNT=10000000

$ MSG='{\"approve\":{\"account_id\":\"'$ZSWAP_MANAGER'\"}}'
$ near call $ZNEAR ft_transfer_call '{"receiver_id":"'$ZSWAP_POOL'", "amount":"'$ZNEAR_AMOUNT'", "msg":"'$MSG'"}' --depositYocto 1 --gas 300000000000000 --accountId zswap.testnet
```

2. Deposit ZUSD into `ZswapPool`

```sh
$ ZUSD_AMOUNT=100000000

$ MSG='{\"approve\":{\"account_id\":\"'$ZSWAP_MANAGER'\"}}'
$ near call $ZUSD ft_transfer_call '{"receiver_id":"'$ZSWAP_POOL'", "amount":"'$ZUSD_AMOUNT'", "msg":"'$MSG'"}' --depositYocto 1 --gas 300000000000000 --accountId zswap.testnet
```

3. Mint liquidity

- JSON schema example:

```json
{
  "params": {
    "token_0": "znear.zswap.testnet",
    "token_1": "zusd.zswap.testnet",
    "fee": 3000,
    "lower_tick": 42000,
    "upper_tick": 48000,
    "amount_0_desired": "10000000",
    "amount_1_desired": "100000000",
    "amount_0_min": "1",
    "amount_1_min": "100"
  }
}
```

- View the corresponding amount with the other.

```sh
$ SQRT_PRICE=792281625142643375935439503360

$ near view $ZSWAP_MANAGER calculate_amount_1_with_amount_0 '{"amount_0":"'$ZNEAR_AMOUNT'","sqrt_price_x96":"'$SQRT_PRICE'","lower_tick":42000,"upper_tick":48000}'

'1978918829' # returns amount_1

$ near view  $ZSWAP_MANAGER calculate_amount_0_with_amount_1 '{"amount_1":"'$ZUSD_AMOUNT'","sqrt_price_x96":"'$SQRT_PRICE'","lower_tick":42000,"upper_tick":48000}'

'505327' # returns amount_0
```

```sh
$ near call $ZSWAP_MANAGER mint '{"params":{"token_0":"'$ZNEAR'","token_1":"'$ZUSD'","fee":3000,"lower_tick":42000,"upper_tick":48000, "amount_0_desired":"'$ZNEAR_AMOUNT'","amount_1_desired":"'$ZUSD_AMOUNT'","amount_0_min":"100","amount_1_min":"100"}}' --gas 300000000000000 --accountId zswap.testnet --deposit 0.1

# Return amount_0 & amount_1
[ '505327', '100000000' ]
```

- After minting liquidity, you will get an NFT

## Step 4: Swap

This example will swap `ZNEAR` to `ZUSD`. If you need `ZNEAR` to test, following command:

```sh
$ TRADER=testz.testnet

$ near call $ZNEAR mint '{"receiver_id":"'$TRADER'", "amount": "100000"}' --deposit 1 --accountId $TRADER
```

1. Ensure register storage for trader account in FT contracts.

```sh
near call $ZUSD storage_deposit '{"account_id":"'$TRADER'"}' --deposit 1 --accountId $TRADER
```

2. Swap `ZNEAR` to `ZUSD`

```sh
$ ZNEAR_AMOUNT=100

$ SWAP_MSG='{\"swap_single\":{\"token_out\":\"'$ZUSD'\",\"fee\":3000}}'

$ near call $ZNEAR ft_transfer_call '{"receiver_id":"'$ZSWAP_MANAGER'", "amount":"'$ZNEAR_AMOUNT'", "msg":"'$SWAP_MSG'"}' --gas 300000000000000 --accountId $TRADER --depositYocto 1
```

## Step 5: Burn

```sh
# View current NFTs
$ near view $ZSWAP_MANAGER nft_tokens_for_owner '{"account_id":"zswap.testnet"}'

$ near call $ZSWAP_MANAGER burn '{"nft_id":"0"}' --gas 300000000000000 --accountId zswap.testnet
[ '505326', '99999999' ]
```

'''
'''--- zswap-contracts-main/build.sh ---
#!/bin/sh

echo ">> Building Zswap contracts..."

rustup target add wasm32-unknown-unknown
cargo build --package zswap-pool --target wasm32-unknown-unknown --release
cargo build --package zswap-manager --target wasm32-unknown-unknown --release
cargo build --package zswap-factory --target wasm32-unknown-unknown --release

cp target/wasm32-unknown-unknown/release/zswap_pool.wasm res/
cp target/wasm32-unknown-unknown/release/zswap_manager.wasm res/
cp target/wasm32-unknown-unknown/release/zswap_factory.wasm res/

'''
'''--- zswap-contracts-main/deploy.sh ---
#!/bin/sh

./build.sh

if [ $? -ne 0 ]; then
  echo ">> Error building Zswap contracts!"
  exit 1
fi

echo ">> Deploying Zswap contracts..."

# https://docs.near.org/tools/near-cli#near-dev-deploy
near dev-deploy --wasmFile ./res/zswap_pool.wasm
near dev-deploy --wasmFile ./res/zswap_manager.wasm
near dev-deploy --wasmFile ./res/zswap_factory.wasm

'''
'''--- zswap-contracts-main/factory/Cargo.toml ---
[package]
name = "zswap-factory"
version = "1.0.0"
authors = ["DV Lab"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }
zswap-math-library = { path = "../library" }

[dev-dependencies.cargo-husky]
version = "1"
default-features = false
features = ["user-hooks"]

'''
'''--- zswap-contracts-main/factory/src/dev.rs ---
use near_sdk::{env, log, near_bindgen, AccountId, Promise};

use crate::*;

#[near_bindgen]
impl Contract {
    #[private]
    pub fn remove_stored_contract(&mut self) {
        self.code.remove();
    }

    #[private]
    pub fn update_stored_contract(&mut self) {
        self.code
            .set(&env::input().expect("Error: No input").to_vec());
    }

    #[payable]
    #[private]
    pub fn redeploy_pool(
        &mut self,
        token_0: AccountId,
        token_1: AccountId,
        fee: u32,
        sqrt_price_x96: U128,
    ) -> Promise {
        let tick_spacing_opt = self.fees.get(&fee);
        if tick_spacing_opt.is_none() {
            env::panic_str(UNSUPPORTED_FEE);
        }

        let ordered_token_0;
        let ordered_token_1;
        match token_0.cmp(&token_1) {
            Ordering::Less => {
                ordered_token_0 = token_0;
                ordered_token_1 = token_1;
            }
            Ordering::Greater => {
                ordered_token_0 = token_1;
                ordered_token_1 = token_0;
            }
            Ordering::Equal => env::panic_str(TOKENS_MUST_BE_DIFFERENT),
        }

        let subaccount = pool_account::compute_account(
            &env::current_account_id(),
            &ordered_token_0,
            &ordered_token_1,
            fee,
        );

        if !env::is_valid_account_id(subaccount.as_bytes()) {
            env::panic_str(INVALID_SUBACCOUNT);
        }

        if !self.pools.get(&subaccount).unwrap_or_default() {
            env::panic_str("Pool does not exist");
        }

        self.pools.insert(&subaccount, &true);

        // Assert enough money is attached to create the account and deploy the contract
        let attached = env::attached_deposit();

        let code = self.code.get().unwrap();
        let contract_bytes = code.len() as u128;
        let minimum_needed = NEAR_PER_STORAGE * contract_bytes;

        if attached < minimum_needed {
            env::panic_str(&format!("Attach at least {} yⓃ", minimum_needed));
        }

        log!("Signer Public Key {:?}", env::signer_account_pk());

        let promise = Promise::new(subaccount.clone())
            .create_account()
            .add_full_access_key(env::signer_account_pk())
            .transfer(attached)
            .deploy_contract(code)
            .and(ext_zswap_pool::ext(subaccount.clone()).new(
                ordered_token_0.clone(),
                ordered_token_1.clone(),
                tick_spacing_opt.unwrap(),
                fee,
                sqrt_price_x96,
            ));

        // Add callback
        promise.then(
            Self::ext(env::current_account_id()).create_factory_subaccount_and_deploy_callback(
                subaccount,
                env::predecessor_account_id(),
                ordered_token_0,
                ordered_token_1,
                attached,
            ),
        )
    }
}

'''
'''--- zswap-contracts-main/factory/src/error.rs ---
pub const POOL_ALREADY_EXISTS: &str = "Pool already exists";
pub const TOKENS_MUST_BE_DIFFERENT: &str = "Tokens must be different";
pub const UNSUPPORTED_FEE: &str = "Unsupported fee";
pub const INVALID_SUBACCOUNT: &str = "Invalid subaccount";

'''
'''--- zswap-contracts-main/factory/src/ft_storage.rs ---
use near_contract_standards::storage_management::StorageBalance;
use near_sdk::{ext_contract, AccountId};

#[ext_contract(ext_ft_storage)]
pub trait StorageManagement {
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;
}

'''
'''--- zswap-contracts-main/factory/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedSet};
use near_sdk::json_types::U128;
use near_sdk::{
    env, log, near_bindgen, AccountId, Balance, BorshStorageKey, PanicOnDefault, Promise,
    PromiseResult,
};
use std::cmp::Ordering;
use zswap_math_library::pool_account;

use crate::ft_storage::ext_ft_storage;
use error::*;
use pool::*;

mod error;
mod ft_storage;
pub mod pool;

mod dev; // Disable this line on production

const NEAR_PER_STORAGE: Balance = 10_000_000_000_000_000_000; // 10e18yⓃ
const FT_STORAGE_DEPOSIT: Balance = 1500 * NEAR_PER_STORAGE;
const ZSWAP_POOL_CONTRACT: &[u8] = include_bytes!("../../res/zswap_pool.wasm");

#[derive(BorshDeserialize, BorshSerialize)]
pub struct Pool {
    pub token_0: AccountId,
    pub token_1: AccountId,
    pub fee: u32,
}

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    fees: LookupMap<u32, u32>,
    pools: LookupMap<AccountId, bool>,
    tokens: UnorderedSet<AccountId>,
    // Since a contract is something big to store, we use LazyOptions
    // this way it is not deserialized on each method call
    code: LazyOption<Vec<u8>>,
}

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    Fees,
    Pools,
    Tokens,
    Code,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new() -> Self {
        let mut fees = LookupMap::new(StorageKey::Fees);
        fees.insert(&500, &10);
        fees.insert(&3000, &60);

        Self {
            fees,
            pools: LookupMap::new(StorageKey::Pools),
            tokens: UnorderedSet::new(StorageKey::Tokens),
            code: LazyOption::new(StorageKey::Code, Some(&ZSWAP_POOL_CONTRACT.to_vec())),
        }
    }

    #[payable]
    pub fn create_pool(
        &mut self,
        token_0: AccountId,
        token_1: AccountId,
        fee: u32,
        sqrt_price_x96: U128,
    ) -> Promise {
        let tick_spacing_opt = self.fees.get(&fee);
        if tick_spacing_opt.is_none() {
            env::panic_str(UNSUPPORTED_FEE);
        }

        let ordered_token_0;
        let ordered_token_1;
        match token_0.cmp(&token_1) {
            Ordering::Less => {
                ordered_token_0 = token_0;
                ordered_token_1 = token_1;
            }
            Ordering::Greater => {
                ordered_token_0 = token_1;
                ordered_token_1 = token_0;
            }
            Ordering::Equal => env::panic_str(TOKENS_MUST_BE_DIFFERENT),
        }

        let subaccount = pool_account::compute_account(
            &env::current_account_id(),
            &ordered_token_0.clone(),
            &ordered_token_1.clone(),
            fee,
        );

        if !env::is_valid_account_id(subaccount.as_bytes()) {
            env::panic_str(INVALID_SUBACCOUNT);
        }

        if self.pools.get(&subaccount).unwrap_or_default() {
            env::panic_str(POOL_ALREADY_EXISTS);
        }

        self.pools.insert(&subaccount, &true);
        self.tokens.insert(&ordered_token_0);
        self.tokens.insert(&ordered_token_1);

        // Assert enough money is attached to create the account and deploy the contract
        let attached = env::attached_deposit();

        let code = self.code.get().unwrap();
        let contract_bytes = code.len() as u128;
        let minimum_needed = NEAR_PER_STORAGE * contract_bytes;

        if attached < minimum_needed {
            env::panic_str(&format!("Attach at least {} yⓃ", minimum_needed));
        }

        let pool_storage_staking = attached - FT_STORAGE_DEPOSIT * 2;

        let create_pool_promise = Promise::new(subaccount.clone())
            .create_account()
            .add_full_access_key(env::signer_account_pk())
            .transfer(pool_storage_staking)
            .deploy_contract(code);

        let init_pool_promise = ext_zswap_pool::ext(subaccount.clone()).new(
            ordered_token_0.clone(),
            ordered_token_1.clone(),
            tick_spacing_opt.unwrap(),
            fee,
            sqrt_price_x96,
        );

        let token_0_storage_deposit_promise = ext_ft_storage::ext(ordered_token_0.clone())
            .with_attached_deposit(FT_STORAGE_DEPOSIT)
            .storage_deposit(Some(subaccount.clone()), None);
        let token_1_storage_deposit_promise = ext_ft_storage::ext(ordered_token_1.clone())
            .with_attached_deposit(FT_STORAGE_DEPOSIT)
            .storage_deposit(Some(subaccount.clone()), None);

        // Add callback
        create_pool_promise
            .and(init_pool_promise)
            .and(token_0_storage_deposit_promise)
            .and(token_1_storage_deposit_promise)
            .then(
                Self::ext(env::current_account_id()).create_factory_subaccount_and_deploy_callback(
                    subaccount,
                    env::predecessor_account_id(),
                    ordered_token_0,
                    ordered_token_1,
                    attached,
                ),
            )
    }

    #[private]
    pub fn create_factory_subaccount_and_deploy_callback(
        &mut self,
        account: AccountId,
        deployer: AccountId,
        token_0: AccountId,
        token_1: AccountId,
        attached: Balance,
    ) -> Option<AccountId> {
        let create_deploy_promise_idx = 0;
        let token_0_storage_deposit_promise_idx = 2;
        let token_1_storage_deposit_promise_idx = 3;

        match env::promise_result(create_deploy_promise_idx) {
            PromiseResult::Successful(_) => {
                log!("Correctly created and deployed to {}", account);

                match env::promise_result(token_0_storage_deposit_promise_idx) {
                    PromiseResult::Successful(_) => {
                        log!("Correctly deposited storage into token 0 {}", token_0);
                    }
                    _ => {
                        log!("Failed to deposit storage {}", token_0);
                    }
                }

                match env::promise_result(token_1_storage_deposit_promise_idx) {
                    PromiseResult::Successful(_) => {
                        log!("Correctly deposited storage into token 1 {}", token_1);
                    }
                    _ => {
                        log!("Failed to deposit storage {}", token_1);
                    }
                }

                Some(account)
            }
            _ => {
                log!("Error creating {account}, returning {attached}yⓃ to {deployer}");

                Promise::new(deployer).transfer(attached);
                None
            }
        }
    }

    pub fn get_pool(&self, token_0: AccountId, token_1: AccountId, fee: u32) -> Option<PoolView> {
        let ordered_token_0;
        let ordered_token_1;
        match token_0.cmp(&token_1) {
            Ordering::Less => {
                ordered_token_0 = token_0;
                ordered_token_1 = token_1;
            }
            Ordering::Greater => {
                ordered_token_0 = token_1;
                ordered_token_1 = token_0;
            }
            Ordering::Equal => return None,
        }

        let pool_id = pool_account::compute_account(
            &env::current_account_id(),
            &ordered_token_0,
            &ordered_token_1,
            fee,
        );

        if !self.pools.get(&pool_id).unwrap_or_default() {
            return None;
        }

        let pool_view = PoolView {
            pool_id,
            token_0: ordered_token_0,
            token_1: ordered_token_1,
            fee,
            tick_spacing: self.fees.get(&fee).unwrap(),
        };

        Some(pool_view)
    }

    pub fn get_tokens(&self) -> Vec<AccountId> {
        self.tokens.to_vec()
    }
}

'''
'''--- zswap-contracts-main/factory/src/pool.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{ext_contract, AccountId};

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct PoolView {
    pub pool_id: AccountId,
    pub token_0: AccountId,
    pub token_1: AccountId,
    pub fee: u32,
    pub tick_spacing: u32,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct PoolInitArgs {
    pub token_0: AccountId,
    pub token_1: AccountId,
    pub tick_spacing: u32,
    pub fee: u32,
}

#[ext_contract(ext_zswap_pool)]
pub trait FtZswapPool {
    fn new(
        token_0: AccountId,
        token_1: AccountId,
        tick_spacing: u32,
        fee: u32,
        sqrt_price_x96: U128,
    ) -> Self;
}

'''
'''--- zswap-contracts-main/integration-tests/Cargo.toml ---
[package]
name = "zswap-integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
# contracts
zswap-manager = { path = "../manager" }
zswap-pool = { path = "../pool" }
zswap-factory = { path = "../factory" }
near-contract-standards = "4.0.0"

anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
near-sdk = "4.0.0"
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.6.0"
pkg-config = "0.3.1"

# [[example]]
# name = "integration-tests"
# path = "src/tests.rs"

'''
'''--- zswap-contracts-main/integration-tests/tests/burn.rs ---
use near_sdk::{json_types::U128, ONE_YOCTO};
use near_units::parse_near;
use serde_json::json;

use zswap_manager::utils::MintParams;

use helper::*;
use zswap_pool::ft_receiver::TokenReceiverMessage as PoolTokenReceiverMessage;
use zswap_pool::utils::Slot0;

mod helper;

#[tokio::test]
async fn test_burn_properly() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    println!("\nContracts setup...");
    let context = init(&worker).await?;
    let liquidity_provider = context.deployer;
    println!("✅ Setup done");

    // deposit token 0 & 1 into deployer
    let token_0_amount = U128::from(10_000_000);
    let token_1_amount = U128::from(100_000_000);

    let approve_msg = PoolTokenReceiverMessage::Approve {
        account_id: context.manager_contract.id().to_string().parse().unwrap(),
    };

    liquidity_provider
        .call(context.token_0_contract.id(), "ft_transfer_call")
        .args_json((
            context.pool_id.clone(),
            token_0_amount,
            None::<String>,
            near_sdk::serde_json::to_string(&approve_msg).unwrap(),
        ))
        .deposit(ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    liquidity_provider
        .call(context.token_1_contract.id(), "ft_transfer_call")
        .args_json((
            context.pool_id.clone(),
            token_1_amount,
            None::<String>,
            near_sdk::serde_json::to_string(&approve_msg).unwrap(),
        ))
        .deposit(ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("✅ Deposited token 0 & 1 into `ZswapPool`");

    let before_slot_0 = liquidity_provider
        .call(&context.pool_id, "get_slot_0")
        .view()
        .await?
        .json::<Slot0>()?;

    let mint_params = MintParams {
        token_0: context.token_0_contract.id().parse().unwrap(),
        token_1: context.token_1_contract.id().parse().unwrap(),
        fee: POOL_FEE,
        lower_tick: 42000,
        upper_tick: 48000,
        amount_0_desired: token_0_amount,
        amount_1_desired: token_1_amount,
        amount_0_min: U128::from(0),
        amount_1_min: U128::from(0),
    };

    let added_amounts = liquidity_provider
        .call(context.manager_contract.id(), "mint")
        .args_json(json!({ "params": mint_params }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?
        .json::<[U128; 2]>()?;
    println!("\tMinted amount 0: {}", added_amounts[0].0);
    println!("\tMinted amount 1: {}", added_amounts[1].0);

    let after_slot_0 = liquidity_provider
        .call(&context.pool_id, "get_slot_0")
        .view()
        .await?
        .json::<Slot0>()?;
    assert_eq!(before_slot_0.tick, after_slot_0.tick);
    assert_eq!(before_slot_0.sqrt_price_x96, after_slot_0.sqrt_price_x96);

    println!("✅ Minted liquidity");

    let balance_token_0_before = liquidity_provider
        .call(context.token_0_contract.id(), "ft_balance_of")
        .args_json(json!({ "account_id": liquidity_provider.id() }))
        .view()
        .await?
        .json::<U128>()?;
    let balance_token_1_before = liquidity_provider
        .call(context.token_1_contract.id(), "ft_balance_of")
        .args_json(json!({"account_id": liquidity_provider.id()}))
        .view()
        .await?
        .json::<U128>()?;

    let collected_amounts = liquidity_provider
        .call(context.manager_contract.id(), "burn")
        .args_json(json!({"nft_id": "0"}))
        .max_gas()
        .transact()
        .await?
        .json::<[U128; 2]>()?;
    println!("\tCollected amount: {}", collected_amounts[0].0);
    println!("\tCollected amount: {}", collected_amounts[1].0);

    let balance_token_0_after = liquidity_provider
        .call(context.token_0_contract.id(), "ft_balance_of")
        .args_json(json!({"account_id": liquidity_provider.id()}))
        .view()
        .await?
        .json::<U128>()?;
    let balance_token_1_after = liquidity_provider
        .call(context.token_1_contract.id(), "ft_balance_of")
        .args_json(json!({"account_id": liquidity_provider.id()}))
        .view()
        .await?
        .json::<U128>()?;
    assert_eq!(
        balance_token_0_before.0 + collected_amounts[0].0,
        balance_token_0_after.0
    );
    assert_eq!(
        balance_token_1_before.0 + collected_amounts[1].0,
        balance_token_1_after.0
    );

    println!("✅ Burned liquidity and collected tokens");

    Ok(())
}

'''
'''--- zswap-contracts-main/integration-tests/tests/helper.rs ---
use near_sdk::json_types::U128;
use near_units::parse_near;
use serde_json::json;
use workspaces::{Account, AccountId, Contract, DevNetwork, Worker};
use zswap_factory::pool::PoolView;

const FT_CONTRACT: &[u8] = include_bytes!("../../res/mock/fungible_token.wasm");
const ZSWAP_MANAGER_CONTRACT: &[u8] = include_bytes!("../../res/zswap_manager.wasm");
const ZSWAP_FACTORY_CONTRACT: &[u8] = include_bytes!("../../res/zswap_factory.wasm");

pub const POOL_FEE: u32 = 3000;

#[derive(Debug, Clone)]
pub struct TestContext {
    pub token_0_contract: Contract,
    pub token_1_contract: Contract,
    pub factory_contract: Contract,
    pub manager_contract: Contract,
    pub pool_id: AccountId,
    pub deployer: Account,
}

pub async fn init(worker: &Worker<impl DevNetwork>) -> anyhow::Result<TestContext> {
    let token_0_contract = worker.dev_deploy(&FT_CONTRACT).await?;
    let token_1_contract = worker.dev_deploy(&FT_CONTRACT).await?;
    let factory_contract = worker.dev_deploy(&ZSWAP_FACTORY_CONTRACT).await?;
    let manager_contract = worker.dev_deploy(&ZSWAP_MANAGER_CONTRACT).await?;

    let support_fee_account = worker.dev_create_account().await?;
    let deployer = worker.dev_create_account().await?;
    support_fee_account
        .transfer_near(&deployer.id(), parse_near!("95 N"))
        .await?
        .into_result()?;
    println!("\tDeployer account: {}", deployer.id());

    let initial_balance = U128::from(1_000_000_000_000);
    token_0_contract
        .call("new_default_meta")
        .args_json((deployer.id(), initial_balance))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    token_1_contract
        .call("new_default_meta")
        .args_json((deployer.id(), initial_balance))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("\tToken 0 contract: {}", token_0_contract.id(),);
    println!("\tToken 1 contract: {}", token_1_contract.id(),);

    factory_contract
        .call("new")
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("\tFactory contract: {}", factory_contract.id());

    manager_contract
        .call("new")
        .args_json(json!({"factory": factory_contract.id()}))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("\tManager contract: {}", manager_contract.id());

    let initial_sqrt_price_x96 = U128::from(10 * (2_u128).pow(96));
    deployer
        .call(manager_contract.id(), "create_pool")
        .args_json((
            token_0_contract.id(),
            token_1_contract.id(),
            POOL_FEE,
            initial_sqrt_price_x96,
        ))
        .deposit(parse_near!("30 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    let pool = deployer
        .call(factory_contract.id(), "get_pool")
        .args_json((token_0_contract.id(), token_1_contract.id(), POOL_FEE))
        .view()
        .await?
        .json::<PoolView>()?;
    let pool_id: AccountId = pool.pool_id.to_string().parse().unwrap();
    println!("\tPool contract: {}", pool_id);
    println!("\tInitialized with token_1/token_0: 100");

    Ok(TestContext {
        token_0_contract,
        token_1_contract,
        factory_contract,
        pool_id,
        manager_contract,
        deployer,
    })
}

'''
'''--- zswap-contracts-main/integration-tests/tests/mint.rs ---
use near_contract_standards::non_fungible_token::Token as NFT;
use near_sdk::json_types::U128;
use near_sdk::ONE_YOCTO;
use near_units::parse_near;
use serde_json::json;

use zswap_manager::utils::MintParams;

use helper::*;
use zswap_pool::ft_receiver::TokenReceiverMessage as PoolTokenReceiverMessage;
use zswap_pool::utils::Slot0;

mod helper;

#[tokio::test]
async fn test_mint_properly() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    println!("\nContracts setup...");
    let context = init(&worker).await?;
    let liquidity_provider = context.deployer;
    println!("✅ Setup done");

    // deposit token 0 & 1 into deployer
    let token_0_amount = U128::from(10_000_000);
    let token_1_amount = U128::from(100_000_000);

    let approve_msg = PoolTokenReceiverMessage::Approve {
        account_id: context.manager_contract.id().to_string().parse().unwrap(),
    };

    liquidity_provider
        .call(context.token_0_contract.id(), "ft_transfer_call")
        .args_json((
            context.pool_id.clone(),
            token_0_amount,
            None::<String>,
            near_sdk::serde_json::to_string(&approve_msg).unwrap(),
        ))
        .deposit(ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    liquidity_provider
        .call(context.token_1_contract.id(), "ft_transfer_call")
        .args_json((
            context.pool_id.clone(),
            token_1_amount,
            None::<String>,
            near_sdk::serde_json::to_string(&approve_msg).unwrap(),
        ))
        .deposit(ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("✅ Deposited token 0 & 1 into `ZswapPool`");

    let before_slot_0 = liquidity_provider
        .call(&context.pool_id, "get_slot_0")
        .view()
        .await?
        .json::<Slot0>()?;

    let mint_params = MintParams {
        token_0: context.token_0_contract.id().parse().unwrap(),
        token_1: context.token_1_contract.id().parse().unwrap(),
        fee: POOL_FEE,
        lower_tick: 42000,
        upper_tick: 48000,
        amount_0_desired: token_0_amount,
        amount_1_desired: token_1_amount,
        amount_0_min: U128::from(0),
        amount_1_min: U128::from(0),
    };

    let added_amounts = liquidity_provider
        .call(context.manager_contract.id(), "mint")
        .args_json(json!({ "params": mint_params }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?
        .json::<[U128; 2]>()?;
    println!("\tMinted amount 0: {}", added_amounts[0].0);
    println!("\tMinted amount 1: {}", added_amounts[1].0);

    let nfts = liquidity_provider
        .call(context.manager_contract.id(), "nft_tokens_for_owner")
        .args_json(json!({"account_id":liquidity_provider.id()}))
        .view()
        .await?
        .json::<Vec<NFT>>();
    assert_eq!(nfts.unwrap().len(), 1);

    let after_slot_0 = liquidity_provider
        .call(&context.pool_id, "get_slot_0")
        .view()
        .await?
        .json::<Slot0>()?;
    assert_eq!(before_slot_0.tick, after_slot_0.tick);
    assert_eq!(before_slot_0.sqrt_price_x96, after_slot_0.sqrt_price_x96);

    println!("✅ Minted liquidity tokens");

    Ok(())
}

#[tokio::test]
async fn test_mint_failed() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    println!("\nContracts setup...");
    let context = init(&worker).await?;
    let liquidity_provider = context.deployer;
    println!("✅ Setup done");

    // deposit token 0 & 1 into deployer
    let token_0_amount = U128::from(10_000_000);
    let token_1_amount = U128::from(100_000_000);

    let before_slot_0 = liquidity_provider
        .call(&context.pool_id, "get_slot_0")
        .view()
        .await?
        .json::<Slot0>()?;

    let mint_params = MintParams {
        token_0: context.token_0_contract.id().parse().unwrap(),
        token_1: context.token_1_contract.id().parse().unwrap(),
        fee: POOL_FEE,
        lower_tick: 42000,
        upper_tick: 48000,
        amount_0_desired: token_0_amount,
        amount_1_desired: token_1_amount,
        amount_0_min: U128::from(0),
        amount_1_min: U128::from(0),
    };

    let mint_res = liquidity_provider
        .call(context.manager_contract.id(), "mint")
        .args_json(json!({ "params": mint_params }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result();
    assert!(mint_res.is_err());

    let nfts = liquidity_provider
        .call(context.manager_contract.id(), "nft_tokens_for_owner")
        .args_json(json!({"account_id":liquidity_provider.id()}))
        .view()
        .await?
        .json::<Vec<NFT>>();
    assert_eq!(nfts.unwrap().len(), 0);

    let after_slot_0 = liquidity_provider
        .call(&context.pool_id, "get_slot_0")
        .view()
        .await?
        .json::<Slot0>()?;
    assert_eq!(before_slot_0.tick, after_slot_0.tick);
    assert_eq!(before_slot_0.sqrt_price_x96, after_slot_0.sqrt_price_x96);

    println!("✅ Don't mint NFT if tx failed");

    Ok(())
}

'''
'''--- zswap-contracts-main/integration-tests/tests/swap.rs ---
use near_sdk::{json_types::U128, ONE_YOCTO};
use near_units::parse_near;
use serde_json::json;

use zswap_manager::ft_receiver::TokenReceiverMessage as ManagerTokenReceiverMessage;
use zswap_manager::utils::MintParams;
use zswap_pool::ft_receiver::TokenReceiverMessage as PoolTokenReceiverMessage;

use helper::*;

mod helper;

#[tokio::test]
async fn test_mint_properly() -> anyhow::Result<()> {
    let worker = workspaces::sandbox().await?;
    println!("\nContracts setup...");
    let context = init(&worker).await?;
    let liquidity_provider = context.deployer;
    println!("✅ Setup done");

    // deposit token 0 & 1 into deployer
    let token_0_amount = U128::from(100_000);
    let token_1_amount = U128::from(500_000);

    let approve_msg = PoolTokenReceiverMessage::Approve {
        account_id: context.manager_contract.id().to_string().parse().unwrap(),
    };

    liquidity_provider
        .call(context.token_0_contract.id(), "ft_transfer_call")
        .args_json((
            context.pool_id.clone(),
            token_0_amount,
            None::<String>,
            near_sdk::serde_json::to_string(&approve_msg).unwrap(),
        ))
        .deposit(ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    liquidity_provider
        .call(context.token_1_contract.id(), "ft_transfer_call")
        .args_json((
            context.pool_id.clone(),
            token_1_amount,
            None::<String>,
            near_sdk::serde_json::to_string(&approve_msg).unwrap(),
        ))
        .deposit(ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("✅ Deposited token 0 & 1 into `ZswapPool`");

    let mint_params = MintParams {
        token_0: context.token_0_contract.id().parse().unwrap(),
        token_1: context.token_1_contract.id().parse().unwrap(),
        fee: POOL_FEE,
        lower_tick: 42000,
        upper_tick: 48000,
        amount_0_desired: token_0_amount,
        amount_1_desired: token_1_amount,
        amount_0_min: U128::from(0),
        amount_1_min: U128::from(0),
    };
    liquidity_provider
        .call(context.manager_contract.id(), "mint")
        .args_json(json!({ "params": mint_params }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("✅ Minted liquidity tokens");

    // swap
    let token_0_balance_before_swap = liquidity_provider
        .call(context.token_0_contract.id(), "ft_balance_of")
        .args_json(json!({"account_id": liquidity_provider.id()}))
        .view()
        .await?
        .json::<U128>()?;

    let token_1_balance_before_swap = liquidity_provider
        .call(context.token_1_contract.id(), "ft_balance_of")
        .args_json(json!({"account_id": liquidity_provider.id()}))
        .view()
        .await?
        .json::<U128>()?;

    let msg = ManagerTokenReceiverMessage::SwapSingle {
        token_out: context.token_1_contract.id().parse().unwrap(),
        fee: POOL_FEE,
        sqrt_price_limit_x96: None,
    };
    liquidity_provider
        .call(context.token_0_contract.id(), "ft_transfer_call")
        .args_json((
            context.manager_contract.id(),
            U128::from(777),
            None::<String>,
            near_sdk::serde_json::to_string(&msg).unwrap(),
        ))
        .deposit(ONE_YOCTO)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let token_0_balance_after_swap = liquidity_provider
        .call(context.token_0_contract.id(), "ft_balance_of")
        .args_json(json!({"account_id": liquidity_provider.id()}))
        .view()
        .await?
        .json::<U128>()?;
    let token_1_balance_after_swap = liquidity_provider
        .call(context.token_1_contract.id(), "ft_balance_of")
        .args_json(json!({"account_id": liquidity_provider.id()}))
        .view()
        .await?
        .json::<U128>()?;

    assert!(token_0_balance_before_swap.0 > token_0_balance_after_swap.0);
    assert!(token_1_balance_before_swap.0 < token_1_balance_after_swap.0);

    println!("✅ Swapped token 0 to token 1");

    Ok(())
}

'''
'''--- zswap-contracts-main/library/Cargo.toml ---
[package]
name = "zswap-math-library"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "4.1.1"
ethnum = "1.3.2"
uint = { version = "0.9.3", default-features = false }
hex = "0.4.3"

[dev-dependencies.cargo-husky]
version = "1"
default-features = false
features = ["user-hooks"]

'''
'''--- zswap-contracts-main/library/src/bit_math.rs ---
use std::str::FromStr;

use crate::num256::U256;

pub trait BitMathTrait {
    fn most_significant_bit(&self) -> u8;
    fn least_significant_bit(&self) -> u8;
}

impl BitMathTrait for U256 {
    /// @notice Returns the index of the most significant bit of the number,
    ///     where the least significant bit is at index 0 and the most significant bit is at index 255
    /// @dev The function satisfies the property:
    ///     x >= 2**most_significant_bit(x) and x < 2**(most_significant_bit(x)+1)
    /// @param x the value for which to compute the most significant bit, must be greater than 0
    /// @return r the index of the most significant bit
    fn most_significant_bit(&self) -> u8 {
        let mut x = *self;
        assert!(x > U256::zero(), "Value must be greater than 0");

        let mut r: u8 = 0;
        if x >= U256::from_str("0x100000000000000000000000000000000").unwrap() {
            x >>= 128;
            r += 128;
        }
        if x >= U256::from_str("0x10000000000000000").unwrap() {
            x >>= 64;
            r += 64;
        }
        if x >= U256::from_str("0x100000000").unwrap() {
            x >>= 32;
            r += 32;
        }
        if x >= U256::from_str("0x10000").unwrap() {
            x >>= 16;
            r += 16;
        }
        if x >= U256::from_str("0x100").unwrap() {
            x >>= 8;
            r += 8;
        }
        if x >= U256::from_str("0x10").unwrap() {
            x >>= 4;
            r += 4;
        }
        if x >= U256::from_str("0x4").unwrap() {
            x >>= 2;
            r += 2;
        }
        if x >= U256::from_str("0x2").unwrap() {
            r += 1;
        }
        r
    }

    /// @notice Returns the index of the least significant bit of the number,
    ///     where the least significant bit is at index 0 and the most significant bit is at index 255
    /// @dev The function satisfies the property:
    ///     (x & 2**least_significant_bit(x)) != 0 and (x & (2**(least_significant_bit(x)) - 1)) == 0)
    /// @param x the value for which to compute the least significant bit, must be greater than 0
    /// @return r the index of the least significant bit
    fn least_significant_bit(&self) -> u8 {
        let mut x: U256 = *self;
        assert!(x > U256::zero(), "Value must be greater than 0");

        let mut r: u8 = 255;
        if (x & (U256::MAX >> 128)) > U256::zero() {
            r -= 128;
        } else {
            x >>= 128;
        }
        if x & U256::MAX >> 64 > U256::zero() {
            r -= 64;
        } else {
            x >>= 64;
        }
        if x & U256::MAX >> 32 > U256::zero() {
            r -= 32;
        } else {
            x >>= 32;
        }
        if x & U256::MAX >> 16 > U256::zero() {
            r -= 16;
        } else {
            x >>= 16;
        }
        if x & U256::MAX >> 8 > U256::zero() {
            r -= 8;
        } else {
            x >>= 8;
        }
        if x & U256::from(0xf) > U256::zero() {
            r -= 4;
        } else {
            x >>= 4;
        }
        if x & U256::from(0x3) > U256::zero() {
            r -= 2;
        } else {
            x >>= 2;
        }
        if x & U256::from(0x1) > U256::zero() {
            r -= 1;
        }
        r
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_bit_math() {
        let values = [
            U256::from(1234567890u128),
            U256::from_dec_str(
                "57896044618658097711785492504343953926634992332820282019728792004938939802342",
            )
            .unwrap(),
            U256::from_dec_str("1606938044259977626524336601268507632356953233627996783863721")
                .unwrap(),
            U256::from_dec_str("1037042214541001286141").unwrap(),
            !U256::zero(),
            U256::from_dec_str(
                "97896044618658097711785492504343953926634992332820282019728792004938939802342",
            )
            .unwrap(),
        ];

        let n = values.len();
        for i in 0..n {
            let x = values[i];
            let mut lsb = 0;
            let mut msb = 0;
            for j in 0..=255 {
                if ((x >> j) & U256::one()) == U256::one() {
                    lsb = j;
                    break;
                }
            }
            for j in 0..=255 {
                if ((x >> j) & U256::one()) == U256::one() {
                    msb = j;
                }
            }
            println!("{} {} {}", x, lsb, msb);
            assert_eq!(lsb, x.least_significant_bit());
            assert_eq!(msb, x.most_significant_bit());
        }
    }
}

'''
'''--- zswap-contracts-main/library/src/fixed_point_128.rs ---
use crate::num256::U256;

pub const RESOLUTION: u8 = 128;
pub fn get_q128() -> U256 {
    U256::from(2).pow(U256::from(128))
}

//
// fn main() {
//   // Accessing the constants
//   let resolution = fixed_point_128::RESOLUTION;
//   let q128 = fixed_point_128::get_q128();
//
//   println!("Resolution: {}", resolution);
//   println!("get_q128: {}", q128);
// }

'''
'''--- zswap-contracts-main/library/src/fixed_point_96.rs ---
use crate::num256::U256;

pub const RESOLUTION: u8 = 96;
pub fn get_q96() -> U256 {
    U256::from(2).pow(U256::from(96))
}

'''
'''--- zswap-contracts-main/library/src/full_math.rs ---
use crate::num256::U256;

pub struct FullMath;

pub trait MathOps {
    fn gt(self, other: Self) -> Self;
    fn lt(self, other: Self) -> Self;
    fn sub(self, other: Self) -> Self;
    fn add(self, other: Self) -> Self;
    fn div(self, other: Self) -> Self;
    fn modulo(self, other: Self) -> Self;
    fn mul(self, other: Self) -> Self;
    fn mulmod(self, other: Self, modulo: Self) -> Self;
    fn unsafe_muldiv(self, other: Self, modulo: Self) -> Self;
    fn addmod(self, other: Self, modulo: Self) -> Self;
}

impl MathOps for U256 {
    fn gt(self, other: Self) -> Self {
        if self > other {
            U256::one()
        } else {
            U256::zero()
        }
    }
    fn lt(self, other: Self) -> Self {
        if self < other {
            U256::one()
        } else {
            U256::zero()
        }
    }
    fn sub(self, other: Self) -> Self {
        self.overflowing_sub(other).0
    }
    fn add(self, other: Self) -> Self {
        self.overflowing_add(other).0
    }
    fn div(self, other: Self) -> Self {
        self / other
    }
    fn modulo(self, other: Self) -> Self {
        self % other
    }
    fn mul(self, other: Self) -> Self {
        self.overflowing_mul(other).0
    }
    // https://locklessinc.com/articles/256bit_arithmetic/

    // binary multiplication
    fn mulmod(self, other: Self, modulo: Self) -> Self {
        let mut a = self;
        let mut b = other;
        a %= modulo;
        b %= modulo;
        let mut result: U256 = U256::from(0);
        while b > U256::zero() {
            if (b & U256::one()) == U256::one() {
                result = MathOps::addmod(result, a, modulo);
            }
            a = MathOps::addmod(a, a, modulo);
            b >>= 1;
        }

        result
    }
    fn unsafe_muldiv(self, other: Self, modulo: Self) -> Self {
        (self * other) / modulo
    }
    fn addmod(self, other: Self, modulo: Self) -> Self {
        let a = self % modulo;
        let b = other % modulo;
        let remaining_a = modulo - a;
        if remaining_a <= b {
            b - remaining_a
        } else {
            a + b
        }
    }
}

/// SPDX-License-Identifier: MIT
///! Contains 512-bit math functions
///! Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision
///! Handles "phantom overflow" i.e., allows multiplication and division where an intermediate value overflows 256 bits
pub trait FullMathTrait {
    fn mul_div(a: U256, b: U256, denominator: U256) -> U256;
    fn mul_div_rounding_up(a: U256, b: U256, denominator: U256) -> U256;
    fn unsafe_div_rounding_up(x: U256, y: U256) -> U256;
}

impl FullMathTrait for FullMath {
    // Note: https://notes.ethereum.org/@solidity/ryNbZ2xEq

    // @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    // @param a The multiplicand
    // @param b The multiplier
    // @param denominator The divisor
    // @return result The 256-bit result
    fn mul_div(a: U256, b: U256, mut denominator: U256) -> U256 {
        assert!(denominator > U256::zero());
        // 512-bit multiply [prod1 prod0] = a * b
        // Compute the product mod 2**256 and mod 2**256 - 1
        // then use the Chinese Remainder Theorem to reconstruct
        // the 512 bit result. The result is stored in two 256
        // variables such that product = prod1 * 2**256 + prod0
        // let prod0: U256; // Least significant 256 bits of the product
        // let prod1: U256; // Most significant 256 bits of the product

        let mm = MathOps::mulmod(a, b, !U256::zero());
        let mut prod0 = MathOps::mul(a, b);
        let mut prod1 =
            U256::overflowing_sub(U256::overflowing_sub(mm, prod0).0, MathOps::lt(mm, prod0)).0;

        // Handle non-overflow cases, 256 by 256 division
        if prod1.is_zero() {
            assert!(denominator > U256::zero());
            let result = MathOps::div(prod0, denominator);
            return result;
        }

        // Make sure the result is less than 2**256.
        // Also prevents denominator == 0
        assert!(denominator > prod1);

        ///////////////////////////////////////////////
        // 512 by 256 division.
        ///////////////////////////////////////////////

        // Make division exact by subtracting the remainder from [prod1 prod0]
        // Compute remainder using mulmod
        let remainder = MathOps::mulmod(a, b, denominator);
        // Subtract 256 bit number from 512 bit number
        prod1 = MathOps::sub(prod1, MathOps::gt(remainder, prod0));
        prod0 = MathOps::sub(prod0, remainder);

        // Factor powers of two out of denominator
        // Compute largest power of two divisor of denominator.
        // Always >= 1.
        let mut twos = (!denominator + 1) & denominator; // denominator must be greater than 0

        // Divide denominator by power of two
        denominator = MathOps::div(denominator, twos);

        // Divide [prod1 prod0] by the factors of two
        prod0 = MathOps::div(prod0, twos);
        // Shift in bits from prod1 into prod0. For this we need
        // to flip `twos` such that it is 2**256 / twos.
        // If twos is zero(), then it becomes one

        twos = MathOps::add(
            MathOps::div(MathOps::sub(U256::zero(), twos), twos),
            U256::one(),
        );
        prod0 |= MathOps::mul(prod1, twos);

        // Invert denominator mod 2**256
        // Now that denominator is an odd number, it has an inverse
        // modulo 2**256 such that denominator * inv = 1 mod 2**256.
        // Compute the inverse by starting with a seed that is correct
        // correct for four bits. That is, denominator * inv = 1 mod 2**4
        let mut inv = MathOps::mul(U256::from(3), denominator) ^ U256::from(2);
        // Now use Newton-Raphson iteration to improve the precision.
        // Thanks to Hensel's lifting lemma, this also works in modular
        // arithmetic, doubling the correct bits in each step.
        inv = MathOps::mul(
            inv,
            MathOps::sub(U256::from(2), MathOps::mul(denominator, inv)),
        ); // inverse mod 2**8
        inv = MathOps::mul(
            inv,
            MathOps::sub(U256::from(2), MathOps::mul(denominator, inv)),
        ); // inverse mod 2**16
        inv = MathOps::mul(
            inv,
            MathOps::sub(U256::from(2), MathOps::mul(denominator, inv)),
        ); // inverse mod 2**32
        inv = MathOps::mul(
            inv,
            MathOps::sub(U256::from(2), MathOps::mul(denominator, inv)),
        ); // inverse mod 2**64
        inv = MathOps::mul(
            inv,
            MathOps::sub(U256::from(2), MathOps::mul(denominator, inv)),
        ); // inverse mod 2**128
        inv = MathOps::mul(
            inv,
            MathOps::sub(U256::from(2), MathOps::mul(denominator, inv)),
        ); // inverse mod 2**256

        // Because the division is now exact we can divide by multiplying
        // with the modular inverse of denominator. This will give us the
        // correct result modulo 2**256. Since the precoditions guarantee
        // that the outcome is less than 2**256, this is the final result.
        // We don't need to compute the high bits of the result and prod1
        // is no longer required.
        MathOps::mul(prod0, inv)
    }

    // @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0
    // @param a The multiplicand
    // @param b The multiplier
    // @param denominator The divisor
    // @return result The 256-bit result
    fn mul_div_rounding_up(a: U256, b: U256, denominator: U256) -> U256 {
        let result = FullMath::mul_div(a, b, denominator);
        if MathOps::mulmod(a, b, denominator) > U256::zero() {
            assert!(result < U256::MAX);
            result + 1
        } else {
            result
        }
    }

    fn unsafe_div_rounding_up(x: U256, y: U256) -> U256 {
        MathOps::add(
            MathOps::div(x, y),
            MathOps::gt(MathOps::modulo(x, y), U256::zero()),
        )
    }
}

///// For testing

struct FullMathTestEngine;

pub trait FullMathEchidnaTest {
    fn check_mul_div_rounding(x: U256, y: U256, d: U256);
    fn check_mul_div(x: U256, y: U256, d: U256);
    fn check_mul_div_rounding_up(x: U256, y: U256, d: U256);
    fn unsafe_div_round_up(x: U256, y: U256) -> U256;
}

impl FullMathEchidnaTest for FullMathTestEngine {
    fn check_mul_div_rounding(x: U256, y: U256, d: U256) {
        assert!(d > U256::zero());

        let ceiled = FullMath::mul_div_rounding_up(x, y, d);
        let floored = FullMath::mul_div(x, y, d);

        if x.checked_mul(y).unwrap() % d > U256::zero() {
            assert_eq!(ceiled - floored, U256::one());
        } else {
            assert_eq!(ceiled, floored);
        }
    }

    fn check_mul_div(x: U256, y: U256, d: U256) {
        assert!(d > U256::zero());
        let z = FullMath::mul_div(x, y, d);
        if x == U256::zero() || y == U256::zero() {
            assert_eq!(z, U256::zero());
            return;
        }

        // recompute x and y via mul_div of the result of floor(x*y/d), should always be less than original inputs by < d
        let x2 = FullMath::mul_div(z, d, y);
        let y2 = FullMath::mul_div(z, d, x);
        assert!(x2 <= x);
        assert!(y2 <= y);

        assert!(x.checked_sub(x2).unwrap() < d);
        assert!(y.checked_sub(y2).unwrap() < d);
    }

    fn check_mul_div_rounding_up(x: U256, y: U256, d: U256) {
        assert!(d > U256::zero());
        let z = FullMath::mul_div_rounding_up(x, y, d);
        if x == U256::zero() || y == U256::zero() {
            assert_eq!(z, U256::zero());
            return;
        }

        // recompute x and y via mul_div of the result of floor(x*y/d), should always be less than original inputs by < d
        let x2 = FullMath::mul_div(z, d, y);
        let y2 = FullMath::mul_div(z, d, x);
        assert!(x2 >= x);
        assert!(y2 >= y);

        assert!(x2.checked_sub(x).unwrap() < d);
        assert!(y2.checked_sub(y).unwrap() < d);
    }

    /// @notice Returns ceil(x / y)
    /// @dev division by 0 has unspecified behavior, and must be checked externally
    /// @param x The dividend
    /// @param y The divisor
    /// @return z The quotient, ceil(x / y)
    fn unsafe_div_round_up(x: U256, y: U256) -> U256 {
        MathOps::add(
            MathOps::div(x, y),
            MathOps::gt(MathOps::modulo(x, y), U256::zero()),
        )
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    use crate::full_math::MathOps;

    #[test]
    fn test_mulmod() {
        assert_eq!(
            MathOps::mulmod(
                U256::from(314159265),
                U256::from(314159265),
                U256::from(314159265)
            ),
            U256::zero()
        );
        assert_eq!(
            MathOps::mulmod(
                U256::from(3141592653589793232_u128),
                U256::from(2718281828459045233_u128),
                U256::from(987234987230498234234_u128)
            ),
            U256::from(878515112163912297716_u128)
        );
        assert_eq!(
            MathOps::mulmod(
                U256::from(123456789),
                U256::from(101112131415_u128),
                U256::from(981238791623981726391827_u128)
            ),
            U256::from(12482979073441926435_u128)
        );

        assert_eq!(
            MathOps::mulmod(
                U256::from_dec_str(
                    "11579208923731619542357098500868790785326998466564056403945758400791312963993"
                )
                .unwrap(),
                U256::from_dec_str(
                    "57896044618658097711785492504343953926634992332820282019728792003956564819968"
                )
                .unwrap(),
                U256::from_dec_str(
                    "7257920892373161954235709850086879078532699846656405640394575840079131296399"
                )
                .unwrap()
            ),
            U256::from_dec_str(
                "6027955390367321265543803621229480096361388853679971715171647694262792444634"
            )
            .unwrap()
        );
    }

    use crate::fixed_point_128;
    use std::panic;

    #[test]
    fn test_mul_div() {
        // reverts if denominator is 0
        assert!(panic::catch_unwind(|| {
            FullMath::mul_div(fixed_point_128::get_q128(), U256::from(5), U256::from(0));
        })
        .is_err());
        // reverts if denominator is 0 and numerator overflows
        assert!(panic::catch_unwind(|| {
            FullMath::mul_div(
                fixed_point_128::get_q128(),
                fixed_point_128::get_q128(),
                U256::from(0),
            );
        })
        .is_err());
        assert_eq!(
            FullMath::mul_div(
                fixed_point_128::get_q128(),
                fixed_point_128::get_q128(),
                U256::MAX
            ),
            U256::from(1)
        );
        // overflow
        assert!(panic::catch_unwind(|| {
            FullMath::mul_div(U256::MAX, U256::MAX, U256::MAX - 1);
        })
        .is_err());
        assert!(panic::catch_unwind(|| {
            FullMath::mul_div(U256::MAX, U256::MAX, U256::MAX - 1);
        })
        .is_err());
        // all max inputs
        assert_eq!(
            FullMath::mul_div(U256::MAX, U256::MAX, U256::MAX),
            U256::MAX
        );

        // accurate without phantom overflow
        {
            let x = fixed_point_128::get_q128();
            let y = FullMath::mul_div(U256::from(50), fixed_point_128::get_q128(), U256::from(100));
            let modulo = FullMath::mul_div(
                U256::from(150),
                fixed_point_128::get_q128(),
                U256::from(100),
            );
            let answer = fixed_point_128::get_q128() / U256::from(3);
            assert_eq!(FullMath::mul_div(x, y, modulo), answer);
        }

        // accurate with phantom overflow
        {
            let x = fixed_point_128::get_q128();
            let y = x * U256::from(35);
            let modulo = x * U256::from(8);
            let answer = (U256::from(4375) * fixed_point_128::get_q128()) / U256::from(1000);
            assert_eq!(FullMath::mul_div(x, y, modulo), answer);
        }
        // accurate with phantom overflow and repeating decimal
        {
            let x = fixed_point_128::get_q128();
            let y = x * U256::from(1000);
            let modulo = x * U256::from(3000);
            let answer = (U256::from(1) * fixed_point_128::get_q128()) / U256::from(3);
            assert_eq!(FullMath::mul_div(x, y, modulo), answer);
        }
    }

    #[test]
    fn test_mul_div_rounding_up() {
        // reverts if denominator is 0
        assert!(panic::catch_unwind(|| {
            FullMath::mul_div_rounding_up(
                fixed_point_128::get_q128(),
                U256::from(5),
                U256::from(0),
            );
        })
        .is_err());
        // reverts if denominator is 0 and numerator overflows
        assert!(panic::catch_unwind(|| {
            FullMath::mul_div_rounding_up(
                fixed_point_128::get_q128(),
                fixed_point_128::get_q128(),
                U256::from(0),
            );
        })
        .is_err());
        // reverts if output overflows uint256
        assert!(panic::catch_unwind(|| {
            FullMath::mul_div_rounding_up(
                fixed_point_128::get_q128(),
                fixed_point_128::get_q128(),
                U256::from(1),
            );
        })
        .is_err());
        // reverts on overflow with all max inputs
        assert!(panic::catch_unwind(|| {
            FullMath::mul_div_rounding_up(U256::MAX, U256::MAX, U256::MAX.sub(U256::one()));
        })
        .is_err());
        // reverts if mulDiv overflows 256 bits after rounding up
        assert!(panic::catch_unwind(|| {
            FullMath::mul_div_rounding_up(
                U256::from(535006138814359_u64),
                U256::from_dec_str(
                    "432862656469423142931042426214547535783388063929571229938474969",
                )
                .unwrap(),
                U256::from(2),
            );
        })
        .is_err());
        // reverts if mulDiv overflows 256 bits after rounding up case 2
        assert!(
            panic
                ::catch_unwind(|| {
                    FullMath::mul_div_rounding_up(
                        U256::from_dec_str(
                            "115792089237316195423570985008687907853269984659341747863450311749907997002549"
                        ).unwrap(),
                        U256::from_dec_str(
                            "115792089237316195423570985008687907853269984659341747863450311749907997002550"
                        ).unwrap(),
                        U256::from_dec_str(
                            "115792089237316195423570985008687907853269984653042931687443039491902864365164"
                        ).unwrap()
                    );
                })
                .is_err()
        );
        // all max inputs
        {
            let x = U256::MAX;
            let y = x;
            let modulo = x;
            let answer = x;
            assert_eq!(FullMath::mul_div_rounding_up(x, y, modulo), answer);
        }
        // accurate without phantom overflow
        {
            let x = fixed_point_128::get_q128();
            let y = FullMath::mul_div(U256::from(50), fixed_point_128::get_q128(), U256::from(100));
            let modulo = FullMath::mul_div(
                U256::from(150),
                fixed_point_128::get_q128(),
                U256::from(100),
            );
            let answer = fixed_point_128::get_q128() / U256::from(3) + U256::one();
            assert_eq!(FullMath::mul_div_rounding_up(x, y, modulo), answer);
        }
        // accurate with phantom overflow
        {
            let x = fixed_point_128::get_q128();
            let y = x * U256::from(35);
            let modulo = x * U256::from(8);
            let answer = (U256::from(4375) * fixed_point_128::get_q128()) / U256::from(1000);
            assert_eq!(FullMath::mul_div_rounding_up(x, y, modulo), answer);
        }
        // accurate with phantom overflow and repeating decimal
        {
            let x = fixed_point_128::get_q128();
            let y = x * U256::from(1000);
            let modulo = x * U256::from(3000);
            let answer =
                (U256::from(1) * fixed_point_128::get_q128()) / U256::from(3) + U256::one();
            assert_eq!(FullMath::mul_div_rounding_up(x, y, modulo), answer);
        }
    }

    fn pseudo_random_big_number(seed: U256) -> U256 {
        let mut res = U256::zero();
        let mut tmp = seed;
        for i in 0..100 {
            res = res.overflowing_add(tmp).0;
            tmp = tmp.overflowing_mul(tmp.overflowing_add(U256::from(i)).0).0;
        }
        tmp
    }

    #[test]
    fn check_random_inputs() {
        let mut tests = Vec::new();

        for i in 2..3 {
            let x = pseudo_random_big_number(U256::from(i) + pseudo_random_big_number(U256::one()));
            let y =
                pseudo_random_big_number(U256::from(i) + pseudo_random_big_number(U256::from(2)));
            let d =
                pseudo_random_big_number(U256::from(i) + pseudo_random_big_number(U256::from(3)));
            tests.push((x, y, d));
        }

        for (x, y, d) in tests {
            if d <= U256::zero() {
                assert!(panic::catch_unwind(|| {
                    FullMath::mul_div(x, y, d);
                })
                .is_err());
                assert!(panic::catch_unwind(|| {
                    FullMath::mul_div_rounding_up(x, y, d);
                })
                .is_err());
            } else if x == U256::zero() || y == U256::zero() {
                assert_eq!(FullMath::mul_div(x, y, d), U256::zero());
                assert_eq!(FullMath::mul_div_rounding_up(x, y, d), U256::zero());
                // } else if x * y / d > U256::max_value() {
                //   expect(full_math_mul_div(x, y, d).is_err());
                //   expect(full_math_mul_div_rounding_up(x, y, d).is_err());
            } else {
                let result = panic::catch_unwind(|| {
                    let floored = FullMath::mul_div(x, y, d);
                    let ceiled = FullMath::mul_div_rounding_up(x, y, d);

                    let remainder = MathOps::mulmod(x, y, d);

                    if remainder > U256::zero() {
                        floored + U256::one() == ceiled
                    } else {
                        floored == ceiled
                    }
                });

                match result {
                    Ok(diff_less_than_or_equal_to_1) => {
                        assert_eq!(diff_less_than_or_equal_to_1, true);
                    }
                    Err(_) => {}
                }
            }
        }
    }
}

'''
'''--- zswap-contracts-main/library/src/lib.rs ---
pub mod bit_math;
pub mod fixed_point_128;
pub mod fixed_point_96;
pub mod full_math;
pub mod liquidity_math;
pub mod num160;
pub mod num24;
pub mod num256;
pub mod num512;
pub mod num56;
pub mod pool_account;
pub mod position;
pub mod sqrt_price_math;
pub mod swap_math;
pub mod tick;
pub mod tick_bitmap;
pub mod tick_math;
pub mod utils;

#[cfg(test)]
mod tests {
    // use super::*;

    // use crate::lib::Math;
    // use crate::lib::TickMath;
    //
    // #[test]
    // fn test_calc_amount_0_delta() {
    //   let amount0 = Math::calc_amount_0_delta(
    //     TickMath::get_sqrt_ratio_at_tick(85176),
    //     TickMath::get_sqrt_ratio_at_tick(86129),
    //     1517882343751509868544,
    //   );
    //
    //   assert_eq!(amount0, 0.998833192822975409);
    // }
    //
    // #[test]
    // fn test_calc_amount_1_delta() {
    //   let amount1 = Math::calc_amount_1_delta(
    //     TickMath::get_sqrt_ratio_at_tick(84222),
    //     TickMath::get_sqrt_ratio_at_tick(85176),
    //     1517882343751509868544,
    //   );
    //
    //   assert_eq!(amount1, 4999.187247111820044641);
    // }
    //
    // #[test]
    // fn test_calc_amount_0_delta_negative() {
    //   let amount0 = Math::calc_amount_0_delta(
    //     TickMath::get_sqrt_ratio_at_tick(85176),
    //     TickMath::get_sqrt_ratio_at_tick(86129),
    //     -1517882343751509868544,
    //   );
    //
    //   assert_eq!(amount0, -0.998833192822975408);
    // }
    //
    // #[test]
    // fn test_calc_amount_1_delta_negative() {
    //   let amount1 = Math::calc_amount_1_delta(
    //     TickMath::get_sqrt_ratio_at_tick(84222),
    //     TickMath::get_sqrt_ratio_at_tick(85176),
    //     -1517882343751509868544,
    //   );
    //
    //   assert_eq!(amount1, -4999.187247111820044640);
    // }
}

'''
'''--- zswap-contracts-main/library/src/liquidity_math.rs ---
use crate::fixed_point_96;
use crate::num256::U256;
use crate::num512::U512;

/// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows
/// @param x The liquidity before change
/// @param y The delta by which liquidity should be changed
/// @return z The liquidity delta
pub fn add_delta(x: u128, y: i128) -> u128 {
    let z;
    if y < 0 {
        z = x - ((0 - y) as u128);
        assert!(z < x);
    } else {
        z = x + (y as u128);
        assert!(z >= x);
    }
    z
}

/// $L = \frac{\Delta x \sqrt{P_u} \sqrt{P_l}}{\Delta \sqrt{P}}$
pub fn get_liquidity_for_amount_0(
    _sqrt_price_a_x96: U256,
    _sqrt_price_b_x96: U256,
    amount_0: u128,
) -> u128 {
    let (sqrt_price_a_x96, sqrt_price_b_x96) = if _sqrt_price_a_x96 > _sqrt_price_b_x96 {
        (_sqrt_price_b_x96, _sqrt_price_a_x96)
    } else {
        (_sqrt_price_a_x96, _sqrt_price_b_x96)
    };

    let amount_0 = U512::from_dec_str(&amount_0.to_string()).unwrap();
    let sqrt_price_a_x96 = U512::from_dec_str(&sqrt_price_a_x96.to_string()).unwrap();
    let sqrt_price_b_x96 = U512::from_dec_str(&sqrt_price_b_x96.to_string()).unwrap();
    let fixed_point_96 = U512::from_dec_str(&fixed_point_96::get_q96().to_string()).unwrap();

    let intermediate = (sqrt_price_a_x96 * sqrt_price_b_x96) / fixed_point_96;
    let liquidity = (amount_0 * intermediate) / (sqrt_price_b_x96 - sqrt_price_a_x96);

    // let intermediate = FullMath::mul_div(
    //     sqrt_price_a_x96,
    //     sqrt_price_b_x96,
    //     fixed_point_96::get_q96(),
    // );
    // let liquidity = FullMath::mul_div(
    //     amount_0,
    //     intermediate,
    //     sqrt_price_b_x96.sub(sqrt_price_a_x96),
    // );
    liquidity.as_u128()
}

/// $L = \frac{\Delta y}{\Delta \sqrt{P}}$
pub fn get_liquidity_for_amount_1(
    _sqrt_price_a_x96: U256,
    _sqrt_price_b_x96: U256,
    amount_1: u128,
) -> u128 {
    let (sqrt_price_a_x96, sqrt_price_b_x96) = if _sqrt_price_a_x96 > _sqrt_price_b_x96 {
        (_sqrt_price_b_x96, _sqrt_price_a_x96)
    } else {
        (_sqrt_price_a_x96, _sqrt_price_b_x96)
    };

    let amount_1 = U512::from_dec_str(&amount_1.to_string()).unwrap();
    let sqrt_price_a_x96 = U512::from_dec_str(&sqrt_price_a_x96.to_string()).unwrap();
    let sqrt_price_b_x96 = U512::from_dec_str(&sqrt_price_b_x96.to_string()).unwrap();
    let fixed_point_96 = U512::from_dec_str(&fixed_point_96::get_q96().to_string()).unwrap();
    let liquidity = (amount_1 * fixed_point_96) / (sqrt_price_b_x96 - sqrt_price_a_x96);

    // let liquidity = FullMath::mul_div(
    //     amount_1,
    //     fixed_point_96::get_q96(),
    //     sqrt_price_b_x96.sub(sqrt_price_a_x96),
    // );
    liquidity.as_u128()
}

pub fn get_liquidity_for_amounts(
    sqrt_price_x96: U256,
    _sqrt_price_a_x96: U256,
    _sqrt_price_b_x96: U256,
    amount_0: u128,
    amount_1: u128,
) -> u128 {
    let (sqrt_price_a_x96, sqrt_price_b_x96) = if _sqrt_price_a_x96 > _sqrt_price_b_x96 {
        (_sqrt_price_b_x96, _sqrt_price_a_x96)
    } else {
        (_sqrt_price_a_x96, _sqrt_price_b_x96)
    };

    let liquidity: u128;
    if sqrt_price_x96 <= sqrt_price_a_x96 {
        liquidity = get_liquidity_for_amount_0(sqrt_price_a_x96, sqrt_price_b_x96, amount_0);
    } else if sqrt_price_x96 <= sqrt_price_b_x96 {
        let liquidity_0 = get_liquidity_for_amount_0(sqrt_price_x96, sqrt_price_b_x96, amount_0);
        let liquidity_1 = get_liquidity_for_amount_1(sqrt_price_a_x96, sqrt_price_x96, amount_1);

        liquidity = if liquidity_0 < liquidity_1 {
            liquidity_0
        } else {
            liquidity_1
        };
    } else {
        liquidity = get_liquidity_for_amount_1(sqrt_price_a_x96, sqrt_price_b_x96, amount_1);
    }
    liquidity
}

pub fn add_liquidity(x: u128, y: i128) -> u128 {
    let z: u128 = if y < 0 {
        x - y.unsigned_abs()
    } else {
        x + (y as u128)
    };
    z
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::panic;

    #[test]
    fn test_add_delta() {
        assert_eq!(add_delta(1, 0), 1);
        assert_eq!(add_delta(1, -1), 0);
        assert_eq!(add_delta(1, 1), 2);
        // 2**128-15 + 15 overflows
        assert!(panic::catch_unwind(|| {
            add_delta(
                (U256::from(2).pow(U256::from(128)) - U256::from(15)).as_u128(),
                15,
            );
        })
        .is_err());
        // 0 + -1 underflows
        assert!(panic::catch_unwind(|| {
            add_delta(0, -1);
        })
        .is_err());
        // 3 + -4 underflows
        assert!(panic::catch_unwind(|| {
            add_delta(3, -4);
        })
        .is_err());
    }

    #[test]
    fn test_get_liquidity_for_amount_0() {
        // TODO: @galin-chung-nguyen
    }

    #[test]
    fn test_get_liquidity_for_amount_1() {
        // TODO: @galin-chung-nguyen
    }

    #[test]
    fn test_get_liquidity_for_amounts() {
        let sqrt_price_x96 = U256::from_dec_str("792281450588003167884250659085").unwrap(); // amount_0/amount_1 = 100, tick = 46056
        let sqrt_price_a_x96 = U256::from_dec_str("646922711029656030980122427077").unwrap(); // tick = 42000
        let sqrt_price_b_x96 = U256::from_dec_str("873241221460953509178849710283").unwrap(); // tick = 48000
        let amount_0 = 1_000;
        let amount_1 = 100_000;
        let liquidity = get_liquidity_for_amounts(
            sqrt_price_x96,
            sqrt_price_a_x96,
            sqrt_price_b_x96,
            amount_0,
            amount_1,
        );
        assert_eq!(liquidity, 54505);
    }

    #[test]
    fn test_add_liquidity() {
        // TODO: @galin-chung-nguyen
    }
}

'''
'''--- zswap-contracts-main/library/src/num160.rs ---
use ethnum::I256;
use std::str::FromStr;

use crate::num256::U256;

pub type U160 = U256;
pub type I160 = I256;

pub struct Constants;

impl Constants {
    fn get_u160_max() -> U160 {
        (U160::one() << 160) - U160::one()
    }

    fn get_i160_max() -> I160 {
        (I160::ONE << I160::new(59)) - I160::new(2)
    }
}

////////////////////////////////////////////
pub trait AsU160 {
    fn as_u160(&self) -> U160;
}

impl AsU160 for U256 {
    fn as_u160(&self) -> U160 {
        *self & Constants::get_u160_max()
    }
}

////////////////////////////////////////////

pub trait AsI160 {
    fn as_i160(&self) -> I160;
}

impl AsI160 for I256 {
    fn as_i160(&self) -> I160 {
        let u160_max = I256::from_str(&Constants::get_u160_max().to_string()).unwrap();
        let x = self & u160_max;
        if (x & (I256::ONE << 159)) == I256::ZERO {
            x as I160
        } else {
            (x | (!u160_max)) as I160
        }
    }
}

pub trait Num160Trait {
    fn add160(&self, other: Self) -> Self;
}

impl Num160Trait for U160 {
    fn add160(&self, other: Self) -> Self {
        let sum = self.as_u160() + other.as_u160();
        assert!(
            sum <= Constants::get_u160_max(),
            "U160 overflow when adding"
        );
        sum.as_u160()
    }
}

impl Num160Trait for I160 {
    fn add160(&self, other: Self) -> Self {
        let sum = self.as_i160() + other.as_i160();
        assert!(
            sum <= Constants::get_i160_max(),
            "U160 overflow when adding"
        );
        sum.as_i160()
    }
}

// fn printBits2160(x: I2160) {
//   print!("{} => ", x);
//   for i in 0..=255 {
//     print!("{}", (x >> (255 - i)) & I2160::ONE);
//   }
//   println!();
// }
//
// fn printBits128(x: i128) {
//   print!("{} => ", x);
//   for i in 0..=127 {
//     print!("{}", (x >> (127 - i)) & 1);
//   }
//   println!();
// }
// fn printBits32(x: i32) {
//   print!("{} => ", x);
//   for i in 0..=31 {
//     print!("{}", (x >> (31 - i)) & 1);
//   }
//   println!();
// }

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    #[test]
    fn test_to160bit() {
        assert_eq!(
            I256::from_str("-23498273401982347190234691872346918723461234")
                .unwrap()
                .as_i160(),
            I256::from_str("-23498273401982347190234691872346918723461234").unwrap()
        );
        assert_eq!(
            I256::from_str("-982734092364982734698273649283746928736496873469")
                .unwrap()
                .as_i160(),
            I256::from_str("478767544965920183505411183432536090919435669507").unwrap()
        );
        assert_eq!(
            I256::from_str("-1082734092364982342734698273649283746928736496873469")
                .unwrap()
                .as_i160(),
            I256::from_str("238620897216719654232187393481970636309517471747").unwrap()
        );
        assert_eq!(
            I256::from_str("23498273401982347190234691872346918723461234")
                .unwrap()
                .as_i160(),
            I256::from_str("23498273401982347190234691872346918723461234").unwrap()
        );
        assert_eq!(
            I256::from_str("982734092364982734698273649283746928736496873469")
                .unwrap()
                .as_i160(),
            I256::from_str("-478767544965920183505411183432536090919435669507").unwrap()
        );
        assert_eq!(
            I256::from_str("1082734092364982342734698273649283746928736496873469")
                .unwrap()
                .as_i160(),
            I256::from_str("-238620897216719654232187393481970636309517471747").unwrap()
        );

        assert_eq!(
            U256::from_dec_str("823498273401982347190234691872346918723461234")
                .unwrap()
                .as_u160(),
            U256::from_dec_str("823498273401982347190234691872346918723461234")
                .unwrap()
                .as_u160()
        );
        assert_eq!(
            U256::from_dec_str("1082734092364982342734698273649283746928736496873469")
                .unwrap()
                .as_u160(),
            U256::from_dec_str("1222880740114183263971497439234312383346415071229")
                .unwrap()
                .as_u160()
        );
        assert_eq!(
            U256::from_dec_str("982734092364982734698273649283746928736496873469")
                .unwrap()
                .as_u160(),
            U256::from_dec_str("982734092364982734698273649283746928736496873469")
                .unwrap()
                .as_u160()
        );
        assert_eq!(
            U256::from_dec_str("1239876193874612398476123784969871623498716234987612")
                .unwrap()
                .as_u160(),
            U256::from_dec_str("522805418006723839399046826463622830485438543964")
                .unwrap()
                .as_u160()
        );
        assert_eq!(
            U256::from_dec_str("6774691723649127834918235491823549126345912378401234501")
                .unwrap()
                .as_u160(),
            U256::from_dec_str("265913065858983492300335843895976173678848908869")
                .unwrap()
                .as_u160()
        );
        assert_eq!(
            U256::from_dec_str("54789234659871623407126349875123497180162340162340098162")
                .unwrap()
                .as_u160(),
            U256::from_dec_str("906594975575087378705533173710149549372504772722")
                .unwrap()
                .as_u160()
        );
    }
}

'''
'''--- zswap-contracts-main/library/src/num24.rs ---
use ethnum::{AsI256, I256};

use crate::num256::U256;

pub type U24 = u32;
pub type I24 = i32;

pub struct Constants;

impl Constants {
    fn get_u24_max() -> U24 {
        (1 << 24) - 1
    }

    fn get_i24_max() -> I24 {
        let tmp: u32 = 1 << 23;
        (tmp as I24) - 2
    }
}

////////////////////////////////////////////
pub trait AsU24 {
    fn as_u24(&self) -> U24;
}

impl AsU24 for U24 {
    fn as_u24(&self) -> U24 {
        self & Constants::get_u24_max()
    }
}

impl AsU24 for u128 {
    fn as_u24(&self) -> U24 {
        (self & Constants::get_u24_max() as u128) as U24
    }
}

impl AsU24 for U256 {
    fn as_u24(&self) -> U24 {
        (*self & U256::from(Constants::get_u24_max())).as_u32() as U24
    }
}

////////////////////////////////////////////

pub trait AsI24 {
    fn as_i24(&self) -> I24;
}

impl AsI24 for I24 {
    fn as_i24(&self) -> I24 {
        let x = self & Constants::get_u24_max() as I24;
        if (x & (1 << 23)) == 0 {
            x as I24
        } else {
            x | (!Constants::get_u24_max() as I24)
        }
    }
}

impl AsI24 for i128 {
    fn as_i24(&self) -> I24 {
        let x = (self & Constants::get_u24_max() as i128) as i32;
        if (x & (1 << 23)) == 0 {
            x as I24
        } else {
            x | (!Constants::get_u24_max() as I24)
        }
    }
}

impl AsI24 for I256 {
    fn as_i24(&self) -> I24 {
        let x = self & Constants::get_u24_max().as_i256();
        if (x & (1 << 23)) == 0 {
            x.as_i32() as I24
        } else {
            (x | (!Constants::get_u24_max().as_i256())).as_i32() as I24
        }
    }
}

pub trait Num24Trait {
    fn add24(self, other: Self) -> Self;
}

impl Num24Trait for U24 {
    fn add24(self, other: Self) -> Self {
        let sum: u32 = self.as_u24() + other.as_u24();
        assert!(sum <= Constants::get_u24_max(), "U24 overflow when adding");
        sum.as_u24()
    }
}

impl Num24Trait for I24 {
    fn add24(self, other: Self) -> Self {
        let sum: i32 = self.as_i24() + other.as_i24();
        assert!(sum <= Constants::get_i24_max(), "U24 overflow when adding");
        sum.as_i24()
    }
}
//
// fn printBits256(x: I256) {
//   print!("{} => ", x);
//   for i in 0..=255 {
//     print!("{}", (x >> (255 - i)) & I256::ONE);
//   }
//   println!();
// }
//
// fn printBits32(x: i32) {
//   print!("{} => ", x);
//   for i in 0..=31 {
//     print!("{}", (x >> (31 - i)) & 1);
//   }
//   println!();
// }

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    #[test]
    fn test_to24bit() {
        assert_eq!(
            I256::from_str("-23498273401982347190234691872346918723461234")
                .unwrap()
                .as_i24(),
            I256::from_str("6872974").unwrap().as_i32()
        );
        assert_eq!(
            I256::from_str("-982734092364982734698273649283746928736496873469")
                .unwrap()
                .as_i24(),
            I256::from_str("6721539").unwrap().as_i32()
        );
        assert_eq!(
            I256::from_str("-1082734092364982342734698273649283746928736496873469")
                .unwrap()
                .as_i24(),
            I256::from_str("6721539").unwrap().as_i32()
        );
        assert_eq!(
            I256::from_str("23498273401982347190234691872346918723461234")
                .unwrap()
                .as_i24(),
            I256::from_str("-6872974").unwrap().as_i32()
        );
        assert_eq!(
            I256::from_str("982734092364982734698273649283746928736496873469")
                .unwrap()
                .as_i24(),
            I256::from_str("-6721539").unwrap().as_i32()
        );
        assert_eq!(
            I256::from_str("1082734092364982342734698273649283746928736496873469")
                .unwrap()
                .as_i24(),
            I256::from_str("-6721539").unwrap().as_i32()
        );

        assert_eq!(
            U256::from_dec_str("823498273401982347190234691872346918723461234")
                .unwrap()
                .as_u24(),
            U256::from_dec_str("9904242").unwrap().as_u24()
        );
        assert_eq!(
            U256::from_dec_str("1082734092364982342734698273649283746928736496873469")
                .unwrap()
                .as_u24(),
            U256::from_dec_str("10055677").unwrap().as_u24()
        );
        assert_eq!(
            U256::from_dec_str("982734092364982734698273649283746928736496873469")
                .unwrap()
                .as_u24(),
            U256::from_dec_str("10055677").unwrap().as_u24()
        );
        assert_eq!(
            U256::from_dec_str("1239876193874612398476123784969871623498716234987612")
                .unwrap()
                .as_u24(),
            U256::from_dec_str("16070748").unwrap().as_u24()
        );
        assert_eq!(
            U256::from_dec_str("6774691723649127834918235491823549126345912378401234501")
                .unwrap()
                .as_u24(),
            U256::from_dec_str("6037061").unwrap().as_u24()
        );
        assert_eq!(
            U256::from_dec_str("54789234659871623407126349875123497180162340162340098162")
                .unwrap()
                .as_u24(),
            U256::from_dec_str("16748658").unwrap().as_u24()
        );
    }
}

'''
'''--- zswap-contracts-main/library/src/num256.rs ---
#![allow(clippy::assign_op_pattern)]

use ethnum::I256;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use uint::construct_uint;

construct_uint! {
    /// 256-bit unsigned integer.
    #[allow(clippy::assign_op_pattern)]
    #[derive(BorshDeserialize, BorshSerialize)]
    pub struct U256(4);
}

pub trait AsI256 {
    fn as_i256(&self) -> I256;
}

impl AsI256 for U256 {
    fn as_i256(&self) -> I256 {
        I256::from_str_radix(&self.to_string(), 10).unwrap()
    }
}

pub trait ToU256 {
    fn to_u256(&self) -> U256;
}

impl ToU256 for I256 {
    fn to_u256(&self) -> U256 {
        U256::from_str_radix(&self.abs().to_string(), 10).unwrap()
    }
}

'''
'''--- zswap-contracts-main/library/src/num512.rs ---
#![allow(clippy::assign_op_pattern)]

use uint::construct_uint;

construct_uint! {
    /// 512-bit unsigned integer.
    pub struct U512(8);
}

'''
'''--- zswap-contracts-main/library/src/num56.rs ---
use ethnum::{AsI256, I256};

use crate::num256::U256;

pub type U56 = u128;
pub type I56 = i128;

pub struct Constants;

impl Constants {
    fn get_u56_max() -> U56 {
        (1 << 56) - 1
    }

    fn get_i56_max() -> I56 {
        let tmp: u128 = 1 << 55;
        (tmp as I56) - 2
    }
}

////////////////////////////////////////////
pub trait AsU56 {
    fn as_u56(&self) -> U56;
}

impl AsU56 for u128 {
    fn as_u56(&self) -> U56 {
        (self & Constants::get_u56_max()) as U56
    }
}

impl AsU56 for U256 {
    fn as_u56(&self) -> U56 {
        (*self & U256::from(Constants::get_u56_max())).as_u128() as U56
    }
}

////////////////////////////////////////////

pub trait AsI56 {
    fn as_i56(&self) -> I56;
}

impl AsI56 for i128 {
    fn as_i56(&self) -> I56 {
        let x = self & Constants::get_u56_max() as i128;
        if (x & (1 << 55)) == 0 {
            x as I56
        } else {
            x | (!Constants::get_u56_max() as I56)
        }
    }
}

impl AsI56 for I256 {
    fn as_i56(&self) -> I56 {
        let x = self & Constants::get_u56_max().as_i256();
        if (x & (1 << 55)) == 0 {
            x.as_i128() as I56
        } else {
            (x | (!Constants::get_u56_max().as_i256())).as_i128() as I56
        }
    }
}

pub trait Num56Trait {
    fn add56(self, other: Self) -> Self;
}

impl Num56Trait for U56 {
    fn add56(self, other: Self) -> Self {
        let sum: u128 = self.as_u56() + other.as_u56();
        assert!(sum <= Constants::get_u56_max(), "U56 overflow when adding");
        sum.as_u56()
    }
}

impl Num56Trait for I56 {
    fn add56(self, other: Self) -> Self {
        let sum: i128 = self.as_i56() + other.as_i56();
        assert!(sum <= Constants::get_i56_max(), "U56 overflow when adding");
        sum.as_i56()
    }
}

// fn printBits256(x: I256) {
//   print!("{} => ", x);
//   for i in 0..=255 {
//     print!("{}", (x >> (255 - i)) & I256::ONE);
//   }
//   println!();
// }
//
// fn printBits128(x: i128) {
//   print!("{} => ", x);
//   for i in 0..=127 {
//     print!("{}", (x >> (127 - i)) & 1);
//   }
//   println!();
// }
// fn printBits32(x: i32) {
//   print!("{} => ", x);
//   for i in 0..=31 {
//     print!("{}", (x >> (31 - i)) & 1);
//   }
//   println!();
// }

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use std::str::FromStr;

    #[test]
    fn test_to56bit() {
        assert_eq!(
            I256::from_str("-23498273401982347190234691872346918723461234")
                .unwrap()
                .as_i56(),
            I256::from_str("9649415604723598").unwrap().as_i128()
        );
        assert_eq!(
            I256::from_str("-982734092364982734698273649283746928736496873469")
                .unwrap()
                .as_i56(),
            I256::from_str("32816923106775043").unwrap().as_i128()
        );
        assert_eq!(
            I256::from_str("-1082734092364982342734698273649283746928736496873469")
                .unwrap()
                .as_i56(),
            I256::from_str("-9830521594540029").unwrap().as_i128()
        );
        assert_eq!(
            I256::from_str("23498273401982347190234691872346918723461234")
                .unwrap()
                .as_i56(),
            I256::from_str("-9649415604723598").unwrap().as_i128()
        );
        assert_eq!(
            I256::from_str("982734092364982734698273649283746928736496873469")
                .unwrap()
                .as_i56(),
            I256::from_str("-32816923106775043").unwrap().as_i128()
        );
        assert_eq!(
            I256::from_str("1082734092364982342734698273649283746928736496873469")
                .unwrap()
                .as_i56(),
            I256::from_str("9830521594540029").unwrap().as_i128()
        );

        assert_eq!(
            U256::from_dec_str("823498273401982347190234691872346918723461234")
                .unwrap()
                .as_u56(),
            U256::from_dec_str("55793516480503922").unwrap().as_u56()
        );
        assert_eq!(
            U256::from_dec_str("1082734092364982342734698273649283746928736496873469")
                .unwrap()
                .as_u56(),
            U256::from_dec_str("9830521594540029").unwrap().as_u56()
        );
        assert_eq!(
            U256::from_dec_str("982734092364982734698273649283746928736496873469")
                .unwrap()
                .as_u56(),
            U256::from_dec_str("39240670931152893").unwrap().as_u56()
        );
        assert_eq!(
            U256::from_dec_str("1239876193874612398476123784969871623498716234987612")
                .unwrap()
                .as_u56(),
            U256::from_dec_str("15640935760476252").unwrap().as_u56()
        );
        assert_eq!(
            U256::from_dec_str("6774691723649127834918235491823549126345912378401234501")
                .unwrap()
                .as_u56(),
            U256::from_dec_str("38319641664953925").unwrap().as_u56()
        );
        assert_eq!(
            U256::from_dec_str("54789234659871623407126349875123497180162340162340098162")
                .unwrap()
                .as_u56(),
            U256::from_dec_str("46021751246655602").unwrap().as_u56()
        );
    }
}

'''
'''--- zswap-contracts-main/library/src/pool_account.rs ---
use near_sdk::{env, AccountId};

pub fn compute_account(
    factory: &AccountId,
    token_0: &AccountId,
    token_1: &AccountId,
    fee: u32,
) -> AccountId {
    let hash_data = env::keccak256(
        [token_0.as_bytes(), token_1.as_bytes(), &fee.to_le_bytes()]
            .concat()
            .as_slice(),
    );

    let subaccount: AccountId = format!("{}.{}", hex::encode(&hash_data[0..8]), factory)
        .parse()
        .unwrap();

    subaccount
}

'''
'''--- zswap-contracts-main/library/src/position.rs ---
use crate::num256::U256;
use crate::{fixed_point_128, liquidity_math};

use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

use super::full_math::FullMath;
use crate::full_math::FullMathTrait;

// info stored for each user's position
#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, Debug, Default)]
pub struct PositionInfo {
    // the amount of liquidity owned by this position
    pub liquidity: u128,
    // fee growth per unit of liquidity as of the last update to liquidity or fees owed
    pub fee_growth_inside_0_last_x128: u128,
    pub fee_growth_inside_1_last_x128: u128,
    // the fees owed to the position owner in token0/token1
    pub tokens_owed_0: u128,
    pub tokens_owed_1: u128,
}

impl PositionInfo {
    /// Credits accumulated fees to a user's position
    pub fn update(
        &mut self,
        liquidity_delta: i128,
        fee_growth_inside_0_x128: u128,
        fee_growth_inside_1_x128: u128,
    ) {
        let liquidity_next: u128 = if liquidity_delta == 0 && self.liquidity > 0 {
            self.liquidity
        } else {
            liquidity_math::add_delta(self.liquidity, liquidity_delta)
        };

        // calculate accumulated fees
        let tokens_owed_0 = FullMath::mul_div(
            U256::from(fee_growth_inside_0_x128 - self.fee_growth_inside_0_last_x128),
            U256::from(self.liquidity),
            fixed_point_128::get_q128(),
        )
        .as_u128();

        let tokens_owed_1 = FullMath::mul_div(
            U256::from(fee_growth_inside_1_x128 - self.fee_growth_inside_1_last_x128),
            U256::from(self.liquidity),
            fixed_point_128::get_q128(),
        )
        .as_u128();

        // update the position
        if liquidity_delta != 0 {
            self.liquidity = liquidity_next;
        }
        self.fee_growth_inside_0_last_x128 = fee_growth_inside_0_x128;
        self.fee_growth_inside_1_last_x128 = fee_growth_inside_1_x128;

        if tokens_owed_0 > 0 || tokens_owed_1 > 0 {
            // overflow is acceptable, have to withdraw before you hit type(uint128).max fees
            self.tokens_owed_0 = self.tokens_owed_0.overflowing_add(tokens_owed_0).0;
            self.tokens_owed_1 = self.tokens_owed_1.overflowing_add(tokens_owed_1).0;
        }
    }
}

#[cfg(test)]
mod tests {
    // use ethnum::U256;
    // use std::panic;

    #[test]
    fn test_update() {
        // TODO: @galin-chung-nguyen
    }
}

'''
'''--- zswap-contracts-main/library/src/sqrt_price_math.rs ---
use ethnum::I256;

use crate::fixed_point_96;
use crate::full_math::{FullMath, FullMathTrait, MathOps};
use crate::num160::{AsU160, Num160Trait, U160};
use crate::num256::{AsI256, U256};

/// Gets the next sqrt price given a delta of token0
/// Always rounds up, because in the exact output case (increasing price) we need to move the price at least
/// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the
/// price less in order to not send too much output.
/// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),
/// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).
///
/// Return The price after adding or removing amount, depending on add
pub fn get_next_sqrt_price_from_amount_0_rounding_up(
    sqrt_px96: U160,
    liquidity: u128,
    amount: U256,
    add: bool,
) -> U160 {
    // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price
    if amount == U256::zero() {
        return sqrt_px96;
    }

    let numerator1 = U256::from(liquidity) << fixed_point_96::RESOLUTION;

    if add {
        if let Some(product) = amount.checked_mul(sqrt_px96) {
            let denominator = MathOps::add(numerator1, product);
            if denominator >= numerator1 {
                // always fits in 160 bits
                // always fits in 160 bits
                return (FullMath::mul_div_rounding_up(numerator1, sqrt_px96, denominator) as U160)
                    .as_u160();
            }
        }
        FullMath::unsafe_div_rounding_up(numerator1, (numerator1 / sqrt_px96).add(amount)).as_u160()
    } else {
        if let Some(product) = amount.checked_mul(sqrt_px96) {
            if numerator1 > product {
                if let Some(denominator) = numerator1.checked_sub(product) {
                    return FullMath::mul_div_rounding_up(numerator1, sqrt_px96, denominator)
                        .as_u160();
                }
            }
        }
        panic!("Denominator underflow");
    }
}

/// Gets the next sqrt price given a delta of token1
/// Always rounds down, because in the exact output case (decreasing price) we need to move the price at least
/// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the
/// price less in order to not send too much output.
/// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity
///
/// Return The price after adding or removing `amount`
pub fn get_next_sqrt_price_from_amount_1_rounding_down(
    sqrt_px96: U160,
    liquidity: u128,
    amount: U256,
    add: bool,
) -> U160 {
    // if we're adding (subtracting), rounding down requires rounding the quotient down (up)
    // in both cases, avoid a mulDiv for most inputs
    if add {
        let quotient = if amount <= (U256::one() << 160) - U256::one() {
            (amount << fixed_point_96::RESOLUTION) / liquidity
        } else {
            FullMath::mul_div(amount, fixed_point_96::get_q96(), U256::from(liquidity))
        };

        (sqrt_px96.add160(quotient) as U160).as_u160()
    } else {
        let quotient = if amount <= (U256::one() << 160) - U256::one() {
            FullMath::unsafe_div_rounding_up(
                amount << fixed_point_96::RESOLUTION,
                U256::from(liquidity),
            )
        } else {
            FullMath::mul_div_rounding_up(amount, fixed_point_96::get_q96(), U256::from(liquidity))
        };

        if sqrt_px96 > quotient {
            // always fits 160 bits
            sqrt_px96.sub(quotient).as_u160()
        } else {
            panic!("Sqrt price must be greater than quotient");
        }
    }
}

/// Gets the next sqrt price given an input amount of token0 or token1
/// Throws if price or liquidity are 0, or if the next price is out of bounds
///
/// Retun the price after adding the input amount to token0 or token1
pub fn get_next_sqrt_price_from_input(
    sqrt_px96: U160,
    liquidity: u128,
    amount_in: U256,
    zero_for_one: bool,
) -> U160 {
    assert!(sqrt_px96 > U160::zero() && liquidity > 0);

    if zero_for_one {
        get_next_sqrt_price_from_amount_0_rounding_up(sqrt_px96, liquidity, amount_in, true)
    } else {
        get_next_sqrt_price_from_amount_1_rounding_down(sqrt_px96, liquidity, amount_in, true)
    }
}

/// Gets the next sqrt price given an output amount of token0 or token1
/// Throws if price or liquidity are 0 or the next price is out of bounds
///
/// Return the price after removing the output amount of token0 or token1
pub fn get_next_sqrt_price_from_output(
    sqrt_px96: U160,
    liquidity: u128,
    amount_out: U256,
    zero_for_one: bool,
) -> U160 {
    assert!(sqrt_px96 > U160::zero() && liquidity > 0);

    if zero_for_one {
        get_next_sqrt_price_from_amount_1_rounding_down(sqrt_px96, liquidity, amount_out, false)
    } else {
        get_next_sqrt_price_from_amount_0_rounding_up(sqrt_px96, liquidity, amount_out, false)
    }
}

/// Gets the amount_0 delta between two prices
/// Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),
/// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))
///
/// Return amount of token0 required to cover a position of size liquidity between the two passed prices
pub fn get_amount_0_delta(
    _sqrt_ratio_a_x96: U160,
    _sqrt_ratio_b_x96: U160,
    liquidity: u128,
    round_up: bool,
) -> U256 {
    let (mut sqrt_ratio_a_x96, mut sqrt_ratio_b_x96) = (_sqrt_ratio_a_x96, _sqrt_ratio_b_x96);

    if sqrt_ratio_a_x96 > sqrt_ratio_b_x96 {
        std::mem::swap(&mut sqrt_ratio_a_x96, &mut sqrt_ratio_b_x96);
    }

    let numerator1 = U256::from(liquidity) << fixed_point_96::RESOLUTION;
    let numerator2 = sqrt_ratio_b_x96.sub(sqrt_ratio_a_x96);

    assert!(sqrt_ratio_a_x96 > U160::zero());

    if round_up {
        FullMath::unsafe_div_rounding_up(
            FullMath::mul_div_rounding_up(numerator1, numerator2, sqrt_ratio_b_x96),
            sqrt_ratio_a_x96,
        )
    } else {
        FullMath::mul_div(numerator1, numerator2, sqrt_ratio_b_x96) / sqrt_ratio_a_x96
    }
}

/// Gets the amount1 delta between two prices
/// Calculates liquidity * (sqrt(upper) - sqrt(lower))
///
/// Return amount of token1 required to cover a position of size liquidity between the two passed prices
pub fn get_amount_1_delta(
    _sqrt_ratio_a_x96: U160,
    _sqrt_ratio_b_x96: U160,
    liquidity: u128,
    round_up: bool,
) -> U256 {
    let (mut sqrt_ratio_a_x96, mut sqrt_ratio_b_x96) = (_sqrt_ratio_a_x96, _sqrt_ratio_b_x96);

    if sqrt_ratio_a_x96 > sqrt_ratio_b_x96 {
        std::mem::swap(&mut sqrt_ratio_a_x96, &mut sqrt_ratio_b_x96);
    }

    if round_up {
        FullMath::mul_div_rounding_up(
            U256::from(liquidity),
            sqrt_ratio_b_x96.sub(sqrt_ratio_a_x96),
            fixed_point_96::get_q96(),
        )
    } else {
        FullMath::mul_div(
            U256::from(liquidity),
            sqrt_ratio_b_x96.sub(sqrt_ratio_a_x96),
            fixed_point_96::get_q96(),
        )
    }
}

/// Helper that gets signed token0 delta

/// amount_0 Amount of token0 corresponding to the passed liquidityDelta between the two prices
pub fn get_amount_0_delta_signed(
    sqrt_ratio_a_x96: U160,
    sqrt_ratio_b_x96: U160,
    liquidity: i128,
) -> I256 {
    if liquidity < 0 {
        -get_amount_0_delta(
            sqrt_ratio_a_x96,
            sqrt_ratio_b_x96,
            liquidity.unsigned_abs(),
            false,
        )
        .as_i256()
    } else {
        get_amount_0_delta(sqrt_ratio_a_x96, sqrt_ratio_b_x96, liquidity as u128, true).as_i256()
    }
}

/// Helper that gets signed token1 delta
/// amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices
pub fn get_amount_1_delta_signed(
    sqrt_ratio_a_x96: U160,
    sqrt_ratio_b_x96: U160,
    liquidity: i128,
) -> I256 {
    if liquidity < 0 {
        -get_amount_1_delta(
            sqrt_ratio_a_x96,
            sqrt_ratio_b_x96,
            -liquidity as u128,
            false,
        )
        .as_i256()
    } else {
        get_amount_1_delta(sqrt_ratio_a_x96, sqrt_ratio_b_x96, liquidity as u128, true).as_i256()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::full_math::MathOps;
    use crate::num160::AsU160;
    use crate::utils;
    use std::ops::Shl;
    use std::panic;

    #[test]
    fn test_get_signed_amount_0() {
        let amount_0 = get_amount_0_delta_signed(
            U256::from(792281450588003167884250659085_u128),
            U256::from(794105703800257843709031641053_u128),
            3708891,
        );
        assert_eq!(amount_0, 853);
    }

    #[test]
    fn test_get_signed_amount_1() {
        let amount_1 = get_amount_1_delta_signed(
            U256::from(790145282602472263393995913049_u128),
            U256::from(792281450588003167884250659085_u128),
            3708891,
        );
        assert_eq!(amount_1, 100000);
    }

    #[test]
    fn test_get_next_sqrt_price_from_input() {
        // Fails if price is zero
        assert!(panic::catch_unwind(|| {
            get_next_sqrt_price_from_input(
                U160::zero(),
                0 as u128,
                MathOps::div(utils::expand_to_18_decimals(1), U256::from(10)),
                false,
            );
        })
        .is_err(),);

        // Fails if liquidity is zero
        assert!(panic::catch_unwind(|| {
            get_next_sqrt_price_from_input(
                U160::one(),
                0 as u128,
                MathOps::div(utils::expand_to_18_decimals(1), U256::from(10)),
                true,
            );
        })
        .is_err(),);

        // Fails if input amount overflows the price
        {
            let price = U256::from(2)
                .pow(U256::from(160))
                .sub(U256::one())
                .as_u160();
            let liquidity = 1024;
            let amount_in = U256::from(1024);
            assert!(panic::catch_unwind(|| {
                get_next_sqrt_price_from_input(price, liquidity, amount_in, false);
            })
            .is_err(),);
        }

        // Returns input price if amount in is zero and zeroForOne = true
        {
            let price = utils::encode_price_sqrt_u128(1, 1);
            assert_eq!(
                get_next_sqrt_price_from_input(
                    price,
                    MathOps::div(utils::expand_to_18_decimals(1), U256::from(10)).as_u128(),
                    U256::zero(),
                    true
                ),
                price,
            );
        }

        // Returns input price if amount in is zero and zeroForOne = false
        {
            let price = utils::encode_price_sqrt_u128(1, 1);
            assert_eq!(
                get_next_sqrt_price_from_input(
                    price,
                    MathOps::div(utils::expand_to_18_decimals(1), U256::from(10)).as_u128(),
                    U256::zero(),
                    false
                ),
                price,
            );
        }

        // Returns the minimum price for max inputs
        {
            let sqrt_p = U256::from(2).pow(U256::from(160)) - U256::one();
            let liquidity = U256::from(u128::MAX);

            let max_amount_no_overflow = U256::MAX - liquidity.shl(U256::from(96)).div(sqrt_p);

            assert_eq!(
                get_next_sqrt_price_from_input(
                    sqrt_p,
                    liquidity.as_u128(),
                    max_amount_no_overflow,
                    true
                ),
                U256::one()
            );
        }

        // Input amount of 0.1 token1
        {
            let sqrt_q = get_next_sqrt_price_from_input(
                utils::encode_price_sqrt_u128(1, 1),
                utils::expand_to_18_decimals(1).as_u128(),
                MathOps::div(utils::expand_to_18_decimals(1), U256::from(10)),
                false,
            );
            assert_eq!(
                sqrt_q,
                U256::from_dec_str("87150978765690771352898345369").unwrap(),
            );
        }

        // Input amount of 0.1 token0
        {
            let sqrt_q = get_next_sqrt_price_from_input(
                utils::encode_price_sqrt_u128(1, 1),
                utils::expand_to_18_decimals(1).as_u128(),
                MathOps::div(utils::expand_to_18_decimals(1), U256::from(10)),
                true,
            );
            assert_eq!(
                sqrt_q,
                U256::from_dec_str("72025602285694852357767227579").unwrap()
            );
        }

        // amountIn > type(uint96).max and zeroForOne = true
        assert_eq!(
            get_next_sqrt_price_from_input(
                utils::encode_price_sqrt_u128(1, 1),
                utils::expand_to_18_decimals(10).as_u128(),
                U256::from(2).pow(U256::from(100)),
                true,
            ),
            U256::from_dec_str("624999999995069620").unwrap()
        );

        // Can return 1 with enough amountIn and zeroForOne = true
        assert_eq!(
            get_next_sqrt_price_from_input(
                utils::encode_price_sqrt_u128(1, 1),
                1,
                U256::MAX.div(U256::from(2)),
                true,
            ),
            U256::one()
        );
    }

    #[test]
    fn test_get_next_sqrt_price_from_output() {
        //fails if price is zero
        assert!(panic::catch_unwind(|| {
            get_next_sqrt_price_from_output(
                U256::zero(),
                0,
                utils::expand_to_18_decimals(1).div(U256::from(10)),
                false,
            );
        })
        .is_err());

        // fails if liquidity is zero
        assert!(panic::catch_unwind(|| {
            get_next_sqrt_price_from_output(
                U256::one(),
                0,
                utils::expand_to_18_decimals(1).div(U256::from(10)),
                true,
            );
        })
        .is_err());

        // fails if output amount is exactly the virtual reserves of token0
        assert!(panic::catch_unwind(|| {
            let price = U256::from_dec_str("20282409603651670423947251286016").unwrap();
            let liquidity = 1024 as u128;
            let amount_out = U256::from(4);
            get_next_sqrt_price_from_output(price, liquidity, amount_out, false);
        })
        .is_err());

        // fails if output amount is greater than virtual reserves of token1
        assert!(panic::catch_unwind(|| {
            let price = U256::from_dec_str("20282409603651670423947251286016").unwrap();
            let liquidity = 1024 as u128;
            let amount_out = U256::from(262145);
            get_next_sqrt_price_from_output(price, liquidity, amount_out, true);
        })
        .is_err());

        // fails if output amount is exactly the virtual reserves of token1
        assert!(panic::catch_unwind(|| {
            let price = U256::from_dec_str("20282409603651670423947251286016").unwrap();
            let liquidity = 1024 as u128;
            let amount_out = U256::from(262144);
            get_next_sqrt_price_from_output(price, liquidity, amount_out, true);
        })
        .is_err());

        //succeeds if output amount is just less than the virtual reserves of token1
        {
            let price = U256::from_dec_str("20282409603651670423947251286016").unwrap();
            let liquidity = 1024 as u128;
            let amount_out = U256::from(262143);
            assert_eq!(
                get_next_sqrt_price_from_output(price, liquidity, amount_out, true),
                U160::from_dec_str("77371252455336267181195264").unwrap()
            );
        }
        // puzzling echidna test
        assert!(panic::catch_unwind(|| {
            let price = U256::from_dec_str("20282409603651670423947251286016").unwrap();
            let liquidity = 1024 as u128;
            let amount_out = U256::from(4);
            get_next_sqrt_price_from_output(price, liquidity, amount_out, false);
        })
        .is_err());

        // returns input price if amount in is zero and zeroForOne = true
        {
            let price = utils::encode_price_sqrt_u128(1, 1);
            let liquidity = utils::expand_to_18_decimals(1)
                .div(U256::from(10))
                .as_u128();
            let amount_out = U256::from(0);
            assert_eq!(
                get_next_sqrt_price_from_output(price, liquidity, amount_out, true),
                price
            );
        }

        // returns input price if amount in is zero and zeroForOne = false
        {
            let price = utils::encode_price_sqrt_u128(1, 1);
            let liquidity = utils::expand_to_18_decimals(1)
                .div(U256::from(10))
                .as_u128();
            let amount_out = U256::from(0);
            assert_eq!(
                get_next_sqrt_price_from_output(price, liquidity, amount_out, false),
                price
            );
        }

        // returns input price if amount in is zero and zeroForOne = false
        {
            let price = utils::encode_price_sqrt_u128(1, 1);
            let liquidity = utils::expand_to_18_decimals(1).as_u128();
            let amount_out = utils::expand_to_18_decimals(1).div(U256::from(10));
            assert_eq!(
                get_next_sqrt_price_from_output(price, liquidity, amount_out, false),
                U160::from_dec_str("88031291682515930659493278152").unwrap()
            );
        }

        // output amount of 0.1 token1
        {
            let price = utils::encode_price_sqrt_u128(1, 1);
            let liquidity = utils::expand_to_18_decimals(1).as_u128();
            let amount_out = utils::expand_to_18_decimals(1).div(U256::from(10));
            assert_eq!(
                get_next_sqrt_price_from_output(price, liquidity, amount_out, true),
                U160::from_dec_str("71305346262837903834189555302").unwrap()
            );
        }

        // reverts if amountOut is impossible in zero for one direction
        assert!(panic::catch_unwind(|| {
            let price = utils::encode_price_sqrt_u128(1, 1);
            let liquidity = 1 as u128;
            let amount_out = U256::MAX;
            get_next_sqrt_price_from_output(price, liquidity, amount_out, true);
        })
        .is_err());

        // reverts if amountOut is impossible in one for zero direction
        assert!(panic::catch_unwind(|| {
            let price = utils::encode_price_sqrt_u128(1, 1);
            let liquidity = 1 as u128;
            let amount_out = U256::MAX;
            get_next_sqrt_price_from_output(price, liquidity, amount_out, false);
        })
        .is_err());
    }

    #[test]
    fn test_get_amount_0_delta() {
        // returns 0 if liquidity is 0
        assert_eq!(
            get_amount_0_delta(
                utils::encode_price_sqrt_u128(1, 1),
                utils::encode_price_sqrt_u128(2, 1),
                0,
                true
            ),
            U256::zero()
        );

        // returns 0 if prices are equal
        assert_eq!(
            get_amount_0_delta(
                utils::encode_price_sqrt_u128(1, 1),
                utils::encode_price_sqrt_u128(1, 1),
                0,
                true
            ),
            U256::zero()
        );

        {
            // returns 0.1 amount_0 for price of 1 to 1.21
            let amount_0 = get_amount_0_delta(
                utils::encode_price_sqrt_u128(1, 1),
                utils::encode_price_sqrt_u128(121, 100),
                utils::expand_to_18_decimals(1).as_u128(),
                true,
            );
            assert_eq!(amount_0, U256::from(90909090909090910 as u128));

            let amount_0_rounded_down = get_amount_0_delta(
                utils::encode_price_sqrt_u128(1, 1),
                utils::encode_price_sqrt_u128(121, 100),
                utils::expand_to_18_decimals(1).as_u128(),
                false,
            );
            assert_eq!(amount_0_rounded_down, amount_0.sub(U256::one()));
        }

        {
            // works for prices that overflow
            let amount_0_up = get_amount_0_delta(
                utils::encode_price_sqrt_u128(2_u128.pow(90), 1),
                utils::encode_price_sqrt_u128(2_u128.pow(96), 1),
                utils::expand_to_18_decimals(1).as_u128(),
                true,
            );
            let amount_0_down = get_amount_0_delta(
                utils::encode_price_sqrt_u128(2_u128.pow(90), 1),
                utils::encode_price_sqrt_u128(2_u128.pow(96), 1),
                utils::expand_to_18_decimals(1).as_u128(),
                false,
            );

            assert_eq!(amount_0_up, amount_0_down.add(U256::one()));
        }
        // gas cost tests ...
    }

    #[test]
    fn test_get_amount_1_delta() {
        // returns 0 if liquidity is 0
        assert_eq!(
            get_amount_1_delta(
                utils::encode_price_sqrt_u128(1, 1),
                utils::encode_price_sqrt_u128(2, 1),
                0,
                true
            ),
            U256::zero()
        );

        // returns 0 if prices are equal
        assert_eq!(
            get_amount_0_delta(
                utils::encode_price_sqrt_u128(1, 1),
                utils::encode_price_sqrt_u128(1, 1),
                0,
                true
            ),
            U256::zero()
        );

        // returns 0.1 amount1 for price of 1 to 1.21
        {
            let amount_1 = get_amount_1_delta(
                utils::encode_price_sqrt_u128(1, 1),
                utils::encode_price_sqrt_u128(121, 100),
                utils::expand_to_18_decimals(1).as_u128(),
                true,
            );
            assert_eq!(amount_1, U256::from(100000000000000000 as u128));

            let amount_1_rounded_down = get_amount_1_delta(
                utils::encode_price_sqrt_u128(1, 1),
                utils::encode_price_sqrt_u128(121, 100),
                utils::expand_to_18_decimals(1).as_u128(),
                false,
            );
            assert_eq!(amount_1_rounded_down, amount_1.sub(U256::one()));
        }
    }

    #[test]
    fn test_swap_computation() {
        // sqrtP * sqrtQ overflows
        // getNextSqrtPriceInvariants(1025574284609383690408304870162715216695788925244,50015962439936049619261659728067971248,406,true)
        let sqrt_p =
            U256::from_dec_str("1025574284609383690408304870162715216695788925244").unwrap();
        let liquidity = 50015962439936049619261659728067971248_u128;
        let zero_for_one = true;
        let amount_in = U256::from(406);

        let sqrt_q = get_next_sqrt_price_from_input(sqrt_p, liquidity, amount_in, zero_for_one);
        assert_eq!(
            sqrt_q,
            U160::from_dec_str("1025574284609383582644711336373707553698163132913").unwrap()
        );

        let amount_0_delta = get_amount_0_delta(sqrt_q, sqrt_p, liquidity as u128, true);
        assert_eq!(amount_0_delta, amount_in);

        // The remaining assertions related to gas cost can also be adapted in a similar manner.
    }
}

'''
'''--- zswap-contracts-main/library/src/swap_math.rs ---
use ethnum::I256;

use crate::full_math::{FullMath, FullMathTrait};
use crate::num160::U160;
use crate::num24::U24;
use crate::num256::{ToU256, U256};
use crate::sqrt_price_math;

/// Computes the result of swapping some amount in, or amount out, given the parameters of the swap
/// The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive
// @param sqrtRatioCurrentX96 The current sqrt price of the pool
// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred
// @param liquidity The usable liquidity
// @param amountRemaining How much input or output amount is remaining to be swapped in/out
// @param feePips The fee taken from the input amount, expressed in hundredths of a bip
/// - @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target
/// - @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap
/// - @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap
/// - @return feeAmount The amount of input that will be taken as a fee
pub fn compute_swap_step(
    sqrt_ratio_current_x96: U160,
    sqrt_ratio_target_x96: U160,
    liquidity: u128,
    amount_remaining: I256,
    fee_pips: U24,
) -> (U160, U256, U256, U256) {
    let zero_for_one = sqrt_ratio_current_x96 >= sqrt_ratio_target_x96;
    let exact_in = amount_remaining >= 0;

    let sqrt_ratio_next_x96;
    let mut amount_in = U256::zero();
    let mut amount_out = U256::zero();
    if exact_in {
        let amount_remaining_less_fee = FullMath::mul_div(
            amount_remaining.to_u256(),
            U256::from((1_000_000 - fee_pips) as u128),
            U256::from(1_000_000),
        );
        amount_in = if zero_for_one {
            sqrt_price_math::get_amount_0_delta(
                sqrt_ratio_target_x96,
                sqrt_ratio_current_x96,
                liquidity,
                true,
            )
        } else {
            sqrt_price_math::get_amount_1_delta(
                sqrt_ratio_current_x96,
                sqrt_ratio_target_x96,
                liquidity,
                true,
            )
        };

        if amount_remaining_less_fee >= amount_in {
            sqrt_ratio_next_x96 = sqrt_ratio_target_x96;
        } else {
            sqrt_ratio_next_x96 = sqrt_price_math::get_next_sqrt_price_from_input(
                sqrt_ratio_current_x96,
                liquidity,
                amount_remaining_less_fee,
                zero_for_one,
            );
        }
    } else {
        amount_out = if zero_for_one {
            sqrt_price_math::get_amount_1_delta(
                sqrt_ratio_target_x96,
                sqrt_ratio_current_x96,
                liquidity,
                false,
            )
        } else {
            sqrt_price_math::get_amount_0_delta(
                sqrt_ratio_current_x96,
                sqrt_ratio_target_x96,
                liquidity,
                false,
            )
        };

        if (I256::ZERO - amount_remaining).to_u256() >= amount_out {
            sqrt_ratio_next_x96 = sqrt_ratio_target_x96;
        } else {
            sqrt_ratio_next_x96 = sqrt_price_math::get_next_sqrt_price_from_output(
                sqrt_ratio_current_x96,
                liquidity,
                (I256::ZERO - amount_remaining).to_u256(),
                zero_for_one,
            );
        }
    }

    let max = sqrt_ratio_target_x96 == sqrt_ratio_next_x96;
    // get the input/output amounts
    if zero_for_one {
        amount_in = if max && exact_in {
            amount_in
        } else {
            sqrt_price_math::get_amount_0_delta(
                sqrt_ratio_next_x96,
                sqrt_ratio_current_x96,
                liquidity,
                true,
            )
        };

        amount_out = if max && !exact_in {
            amount_out
        } else {
            sqrt_price_math::get_amount_1_delta(
                sqrt_ratio_next_x96,
                sqrt_ratio_current_x96,
                liquidity,
                false,
            )
        };
    } else {
        amount_in = if max && exact_in {
            amount_in
        } else {
            sqrt_price_math::get_amount_1_delta(
                sqrt_ratio_current_x96,
                sqrt_ratio_next_x96,
                liquidity,
                true,
            )
        };

        amount_out = if max && !exact_in {
            amount_out
        } else {
            sqrt_price_math::get_amount_0_delta(
                sqrt_ratio_current_x96,
                sqrt_ratio_next_x96,
                liquidity,
                false,
            )
        };
    }

    // cap the output amount to not exceed the remaining output amount
    if !exact_in && amount_out > (I256::ZERO - amount_remaining).to_u256() {
        amount_out = (I256::ZERO - amount_remaining).to_u256();
    }

    let fee_amount: U256 = if exact_in && sqrt_ratio_next_x96 != sqrt_ratio_target_x96 {
        (I256::ZERO - amount_remaining).to_u256() - amount_in
    } else {
        FullMath::mul_div_rounding_up(
            amount_in,
            U256::from(fee_pips),
            U256::from(1_000_000 - fee_pips),
        )
    };
    (sqrt_ratio_next_x96, amount_in, amount_out, fee_amount)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::full_math::{FullMath, FullMathTrait, MathOps};
    use crate::num24::AsU24;
    use crate::num256::AsI256;
    use crate::sqrt_price_math::{get_next_sqrt_price_from_input, get_next_sqrt_price_from_output};
    use crate::swap_math::compute_swap_step;
    use crate::utils::{encode_price_sqrt_u128, expand_to_18_decimals};

    use ethnum::I256;
    use std::ops::Sub;
    use std::str::FromStr;

    #[test]
    fn test_compute_swap_step() {
        // exact amount in that gets capped at price target in one for zero
        {
            let price = encode_price_sqrt_u128(1, 1);
            let price_target = encode_price_sqrt_u128(101, 100);
            let liquidity = expand_to_18_decimals(2);
            let amount = expand_to_18_decimals(1).as_i256();
            let fee = 600_u128.as_u24();
            let zero_for_one = false;

            let (sqrt_q, amount_in, amount_out, fee_amount) =
                compute_swap_step(price, price_target, liquidity.as_u128(), amount, fee);

            assert_eq!(amount_in, U256::from(9975124224178055 as u128));
            assert_eq!(fee_amount, U256::from(5988667735148 as u128));
            assert_eq!(amount_out, U256::from(9925619580021728 as u128));
            assert!(amount_in.add(fee_amount).as_i256() < amount);

            let price_after_whole_input_amount = get_next_sqrt_price_from_input(
                price,
                liquidity.as_u128(),
                amount.to_u256(),
                zero_for_one,
            );

            // price is capped at price target
            assert_eq!(sqrt_q, price_target);
            // price is less than price after whole input amount
            assert!(sqrt_q < price_after_whole_input_amount);
        }

        // exact amount out that gets capped at price target in one for zero
        {
            let price = encode_price_sqrt_u128(1, 1);
            let price_target = encode_price_sqrt_u128(101, 100);
            let liquidity = expand_to_18_decimals(2);
            let amount = expand_to_18_decimals(1).as_i256() * I256::from(-1);
            let fee = 600_u128.as_u24();
            let zero_for_one = false;

            let (sqrt_q, amount_in, amount_out, fee_amount) =
                compute_swap_step(price, price_target, liquidity.as_u128(), amount, fee);

            assert_eq!(amount_in, U256::from(9975124224178055 as u128));
            assert_eq!(fee_amount, U256::from(5988667735148 as u128));
            assert_eq!(amount_out, U256::from(9925619580021728 as u128));
            assert!(amount_out < (amount * I256::from(-1)).to_u256());

            let price_after_whole_output_amount = get_next_sqrt_price_from_output(
                price,
                liquidity.as_u128(),
                (amount * I256::from(-1)).to_u256(),
                zero_for_one,
            );

            assert_eq!(sqrt_q, price_target);
            assert!(sqrt_q < price_after_whole_output_amount);
        }
        // exact amount in that is fully spent in one for zero
        {
            let price = encode_price_sqrt_u128(1, 1);
            let price_target = encode_price_sqrt_u128(1000, 100);
            let liquidity = expand_to_18_decimals(2);
            let amount = expand_to_18_decimals(1).as_i256();
            let fee = 600_u128.as_u24();
            let zero_for_one = false;

            let (sqrt_q, amount_in, amount_out, fee_amount) =
                compute_swap_step(price, price_target, liquidity.as_u128(), amount, fee);

            assert_eq!(amount_in, U256::from(999400000000000000 as u128));
            assert_eq!(fee_amount, U256::from(600000000000000 as u128));
            assert_eq!(amount_out, U256::from(666399946655997866 as u128));
            assert_eq!(amount_in.add(fee_amount), amount.to_u256());

            let price_after_whole_input_amount_less_fee = get_next_sqrt_price_from_input(
                price,
                liquidity.as_u128(),
                amount.sub(fee_amount.as_i256()).to_u256(),
                zero_for_one,
            );

            assert!(sqrt_q < price_target);
            assert_eq!(sqrt_q, price_after_whole_input_amount_less_fee);
        }
        // exact amount out that is fully received in one for zero
        {
            let price = encode_price_sqrt_u128(1, 1);
            let price_target = encode_price_sqrt_u128(10000, 100);
            let liquidity = expand_to_18_decimals(2);
            let amount = expand_to_18_decimals(1).as_i256() * I256::new(-1);
            let fee = 600_u128.as_u24();
            let zero_for_one = false;

            let (sqrt_q, amount_in, amount_out, fee_amount) =
                compute_swap_step(price, price_target, liquidity.as_u128(), amount, fee);

            assert_eq!(amount_in, U256::from(2000000000000000000 as u128));
            assert_eq!(fee_amount, U256::from(1200720432259356 as u128));
            assert_eq!(amount_out, (amount * I256::from(-1)).to_u256());

            let price_after_whole_output_amount = get_next_sqrt_price_from_output(
                price,
                liquidity.as_u128(),
                (amount * I256::from(-1)).to_u256(),
                zero_for_one,
            );

            assert!(sqrt_q < price_target);
            assert_eq!(sqrt_q, price_after_whole_output_amount);
        }
        // amount out is capped at the desired amount out
        {
            let price = U256::from_dec_str("417332158212080721273783715441582").unwrap();
            let price_target = U256::from_dec_str("1452870262520218020823638996").unwrap();
            let liquidity = U256::from_dec_str("159344665391607089467575320103").unwrap();
            let amount = I256::new(-1);
            let fee = 1_u128.as_u24();

            let (sqrt_q, amount_in, amount_out, fee_amount) =
                compute_swap_step(price, price_target, liquidity.as_u128(), amount, fee);

            assert_eq!(amount_in, U256::one());
            assert_eq!(fee_amount, U256::one());
            assert_eq!(amount_out, U256::one());
            assert_eq!(
                sqrt_q,
                U256::from_dec_str("417332158212080721273783715441581").unwrap()
            );
        }

        // target price of 1 uses partial input amount
        {
            let price = U256::from_dec_str("2").unwrap();
            let price_target = U256::from_dec_str("1").unwrap();
            let liquidity = U256::from_dec_str("1").unwrap();
            let amount = I256::from_str("3915081100057732413702495386755767").unwrap();
            let fee = 1_u128.as_u24();

            let (sqrt_q, amount_in, amount_out, fee_amount) =
                compute_swap_step(price, price_target, liquidity.as_u128(), amount, fee);

            assert_eq!(
                amount_in,
                U256::from_dec_str("39614081257132168796771975168").unwrap()
            );
            assert_eq!(
                fee_amount,
                U256::from_dec_str("39614120871253040049813").unwrap()
            );
            assert!(
                amount_in.add(fee_amount)
                    <= U256::from_dec_str("3915081100057732413702495386755767").unwrap()
            );
            assert_eq!(amount_out, U256::from_dec_str("0").unwrap());
            assert_eq!(sqrt_q, U256::from_dec_str("1").unwrap());
        }

        // entire input amount taken as fee
        {
            let price = U256::from_dec_str("2413").unwrap();
            let price_target = U256::from_dec_str("79887613182836312").unwrap();
            let liquidity = U256::from_dec_str("1985041575832132834610021537970").unwrap();
            let amount = I256::from_str("10").unwrap();
            let fee = 1872_u128.as_u24();

            let (sqrt_q, amount_in, amount_out, fee_amount) =
                compute_swap_step(price, price_target, liquidity.as_u128(), amount, fee);
            assert_eq!(amount_in, U256::from_dec_str("0").unwrap());
            assert_eq!(fee_amount, U256::from_dec_str("10").unwrap());
            assert_eq!(amount_out, U256::from_dec_str("0").unwrap());
            assert_eq!(sqrt_q, U256::from_dec_str("2413").unwrap());
        }

        // handles intermediate insufficient liquidity in zero for one exact output case
        {
            let sqrt_p = U256::from_dec_str("20282409603651670423947251286016").unwrap();
            let sqrt_p_target = FullMath::mul_div(sqrt_p, U256::from(11), U256::from(10));
            let liquidity = U256::from(1024);
            // virtual reserves of one are only 4
            // https://www.wolframalpha.com/input/?i=1024+%2F+%2820282409603651670423947251286016+%2F+2**96%29
            let amount_remaining = I256::from(-4);
            let fee_pips = 3000_u128.as_u24();

            let (sqrt_q, amount_in, amount_out, fee_amount) = compute_swap_step(
                sqrt_p,
                sqrt_p_target,
                liquidity.as_u128(),
                amount_remaining,
                fee_pips,
            );

            assert_eq!(amount_out, U256::from_dec_str("0").unwrap());
            assert_eq!(sqrt_q, sqrt_p_target);
            assert_eq!(amount_in, U256::from_dec_str("26215").unwrap());
            assert_eq!(fee_amount, U256::from_dec_str("79").unwrap());
        }

        // handles intermediate insufficient liquidity in one for zero exact output case
        {
            let sqrt_p = U256::from_dec_str("20282409603651670423947251286016").unwrap();
            let sqrt_p_target = FullMath::mul_div(sqrt_p, U256::from(9), U256::from(10));
            let liquidity = U256::from(1024);
            // virtual reserves of zero are only 262144
            // https://www.wolframalpha.com/input/?i=1024+*+%2820282409603651670423947251286016+%2F+2**96%29
            let amount_remaining = I256::from(-263000);
            let fee_pips = 3000_u128.as_u24();

            let (sqrt_q, amount_in, amount_out, fee_amount) = compute_swap_step(
                sqrt_p,
                sqrt_p_target,
                liquidity.as_u128(),
                amount_remaining,
                fee_pips,
            );

            assert_eq!(amount_out, U256::from_dec_str("26214").unwrap());
            assert_eq!(sqrt_q, sqrt_p_target);
            assert_eq!(amount_in, U256::from_dec_str("1").unwrap());
            assert_eq!(fee_amount, U256::from_dec_str("1").unwrap());
        }
    }
}

'''
'''--- zswap-contracts-main/library/src/tick.rs ---
use ethnum::AsI256;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};

use crate::liquidity_math;
use crate::num160::U160;
use crate::num24::{AsI24, AsU24, I24};
use crate::num256::U256;
use crate::num56::I56;
use crate::tick_math::TickConstants;

// info stored for each initialized individual tick
#[derive(BorshDeserialize, BorshSerialize, Clone, Copy, Debug, Default)]
pub struct TickInfo {
    // the total position liquidity that references this tick
    pub liquidity_gross: u128,
    // amount of net liquidity added (subtracted) when tick is crossed from left to right (right to left),
    pub liquidity_net: i128,
    // fee growth per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    pub fee_growth_outside_0_x128: u128,
    pub fee_growth_outside_1_x128: u128,
    // the cumulative tick value on the other side of the tick
    pub tick_cumulative_outside: I56,
    // the seconds per unit of liquidity on the _other_ side of this tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    pub seconds_per_liquidity_outside_x128: U160,
    // the seconds spent on the other side of the tick (relative to the current tick)
    // only has relative meaning, not absolute — the value depends on when the tick is initialized
    pub seconds_outside: u32,
    // true iff the tick is initialized, i.e. the value is exactly equivalent to the expression liquidityGross != 0
    // these 8 bits are set to prevent fresh stores when crossing newly initialized ticks
    pub initialized: bool,
}

impl TickInfo {
    /// Updates a tick and returns true if the tick was flipped from initialized to uninitialized, or vice versa
    ///
    /// Return flipped whether the tick was flipped from initialized to uninitialized, or vice versa
    pub fn update(
        &mut self,
        tick: I24,
        current_tick: I24,
        liquidity_delta: i128,
        fee_growth_global_0_x128: u128,
        fee_growth_global_1_x128: u128,
        upper: bool,
    ) -> bool {
        let liquidity_gross_before = self.liquidity_gross;
        let liquidity_gross_after =
            liquidity_math::add_delta(liquidity_gross_before, liquidity_delta);

        // assert!(liquidity_gross_after <= max_liquidity, "LO");

        let flipped = (liquidity_gross_after == 0) != (liquidity_gross_before == 0);

        if liquidity_gross_before == 0 {
            // by convention, we assume that all growth before a tick was initialized happened _below_ the tick
            if tick <= current_tick {
                self.fee_growth_outside_0_x128 = fee_growth_global_0_x128;
                self.fee_growth_outside_1_x128 = fee_growth_global_1_x128;
                // self.seconds_per_liquidity_outside_x128 = seconds_per_liquidity_cumulative_x128;
                // self.tick_cumulative_outside = tick_cumulative;
                // self.seconds_outside = time;
            }
            self.initialized = true;
        }

        self.liquidity_gross = liquidity_gross_after;

        // when the lower (upper) tick is crossed left to right (right to left), liquidity must be added (removed)
        self.liquidity_net = if upper {
            self.liquidity_net
                .as_i256()
                .checked_sub(liquidity_delta.as_i256())
                .unwrap()
                .as_i128()
        } else {
            self.liquidity_net
                .as_i256()
                .checked_add(liquidity_delta.as_i256())
                .unwrap()
                .as_i128()
        };

        flipped
    }

    /// @notice Transitions to next tick as needed by price movement
    /// @param self The mapping containing all tick information for initialized ticks
    /// @param tick The destination tick of the transition
    /// @param feeGrowthGlobal0X128 The all-time global fee growth, per unit of liquidity, in token0
    /// @param feeGrowthGlobal1X128 The all-time global fee growth, per unit of liquidity, in token1
    /// @param secondsPerLiquidityCumulativeX128 The current seconds per liquidity
    /// @param tickCumulative The tick * time elapsed since the pool was first initialized
    /// @param time The current block.timestamp
    /// @return liquidityNet The amount of liquidity added (subtracted) when tick is crossed from left to right (right to left)
    pub fn cross(
        &mut self,
        fee_growth_global_0_x128: u128,
        fee_growth_global_1_x128: u128,
        // seconds_per_liquidity_cumulative_x128: U160,
        // tick_cumulative: I56,
        // time: u32,
    ) -> i128 {
        self.fee_growth_outside_0_x128 = fee_growth_global_0_x128 - self.fee_growth_outside_0_x128;
        self.fee_growth_outside_1_x128 = fee_growth_global_1_x128 - self.fee_growth_outside_1_x128;
        // self.seconds_per_liquidity_outside_x128 =
        //     seconds_per_liquidity_cumulative_x128 - self.seconds_per_liquidity_outside_x128;
        // self.tick_cumulative_outside = tick_cumulative - self.tick_cumulative_outside;
        // self.seconds_outside = time - self.seconds_outside;
        self.liquidity_net
    }
}

/// @title Tick
/// @notice Contains functions for managing tick processes and relevant calculations

/// @notice Derives max liquidity per tick from given tick spacing
/// @dev Executed within the pool constructor
/// @param tickSpacing The amount of required tick separation, realized in multiples of `tickSpacing`
///     e.g., a tickSpacing of 3 requires ticks to be initialized every 3rd tick i.e., ..., -6, -3, 0, 3, 6, ...
/// @return The max liquidity per tick
pub fn tick_spacing_to_max_liquidity_per_tick(tick_spacing: I24) -> u128 {
    let min_tick = ((TickConstants::MIN_TICK.as_i256() / tick_spacing.as_i256())
        * tick_spacing.as_i256())
    .as_i24();
    let max_tick = ((TickConstants::MAX_TICK.as_i256() / tick_spacing.as_i256())
        * tick_spacing.as_i256())
    .as_i24();
    let num_ticks = U256::from((max_tick - min_tick) / tick_spacing + 1).as_u24();
    u128::MAX / (num_ticks as u128)
}

/// Retrieves fee growth data
///
/// Return `fee_growth_inside_0_x128` & `fee_growth_inside_1_x128`
/// The all-time fee growth in token_0 and token_1,
/// per unit of liquidity, inside the position's tick boundaries
pub fn get_fee_growth_inside(
    lower_tick: I24,
    upper_tick: I24,
    lower: &TickInfo,
    upper: &TickInfo,
    current_tick: I24,
    fee_growth_global_0_x128: u128,
    fee_growth_global_1_x128: u128,
) -> [u128; 2] {
    // calculate fee growth below
    let fee_growth_below0_x128;
    let fee_growth_below1_x128;
    if current_tick >= lower_tick {
        fee_growth_below0_x128 = lower.fee_growth_outside_0_x128;
        fee_growth_below1_x128 = lower.fee_growth_outside_1_x128;
    } else {
        fee_growth_below0_x128 = fee_growth_global_0_x128 - lower.fee_growth_outside_0_x128;
        fee_growth_below1_x128 = fee_growth_global_1_x128 - lower.fee_growth_outside_1_x128;
    }

    // Calculate fee growth above
    let fee_growth_above0_x128;
    let fee_growth_above1_x128;
    if current_tick < upper_tick {
        fee_growth_above0_x128 = upper.fee_growth_outside_0_x128;
        fee_growth_above1_x128 = upper.fee_growth_outside_1_x128;
    } else {
        fee_growth_above0_x128 = fee_growth_global_0_x128 - upper.fee_growth_outside_0_x128;
        fee_growth_above1_x128 = fee_growth_global_1_x128 - upper.fee_growth_outside_1_x128;
    }

    let fee_growth_inside_0_x128 =
        (fee_growth_global_0_x128 - fee_growth_below0_x128) - fee_growth_above0_x128;
    let fee_growth_inside_1_x128 =
        (fee_growth_global_1_x128 - fee_growth_below1_x128) - fee_growth_above1_x128;

    [fee_growth_inside_0_x128, fee_growth_inside_1_x128]
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use ethnum::AsI256;
    use std::collections::HashMap;

    use crate::num160::U160;
    use crate::num24::AsI24;
    use crate::tick;
    use crate::tick::{get_fee_growth_inside, TickInfo};

    const LOW: u128 = 500;
    const MEDIUM: u128 = 3000;
    const HIGH: u128 = 10000;

    fn create_tick_spacings() -> HashMap<u128, u128> {
        let mut map = HashMap::new();
        map.insert(LOW, 10);
        map.insert(MEDIUM, 60);
        map.insert(HIGH, 200);
        map
    }

    #[test]
    fn test_tick_spacing_to_max_liquidity_per_tick() {
        let tick_spacings = create_tick_spacings();
        let expected_values: [(u128, u128); 5] = [
            (
                *tick_spacings.get(&LOW).unwrap(),
                1917569901783203986719870431555990,
            ),
            (
                *tick_spacings.get(&MEDIUM).unwrap(),
                11505743598341114571880798222544994,
            ),
            (
                *tick_spacings.get(&HIGH).unwrap(),
                38350317471085141830651933667504588,
            ),
            (887272, u128::MAX / 3),
            (2302, 441351967472034323558203122479595605),
        ];

        for (tick_spacing, expected) in expected_values.iter() {
            let max_liquidity_per_tick =
                tick::tick_spacing_to_max_liquidity_per_tick(tick_spacing.as_i256().as_i24());
            let expected_liquidity: u128 = (*expected).into();
            assert_eq!(max_liquidity_per_tick, expected_liquidity);
        }
    }

    #[test]
    fn test_fee_growth_inside_uninitialized_ticks_above() {
        {
            // returns all for two uninitialized ticks if tick is inside
            let [fee_growth_inside_0_x128, fee_growth_inside_1_x128] =
                get_fee_growth_inside(-2, 2, &TickInfo::default(), &TickInfo::default(), 0, 15, 15);
            assert_eq!(fee_growth_inside_0_x128, 15);
            assert_eq!(fee_growth_inside_1_x128, 15);
        }
        {
            // returns 0 for two uninitialized ticks if tick is above
            let [fee_growth_inside_0_x128, fee_growth_inside_1_x128] =
                get_fee_growth_inside(-2, 2, &TickInfo::default(), &TickInfo::default(), 4, 15, 15);
            assert_eq!(fee_growth_inside_0_x128, 0);
            assert_eq!(fee_growth_inside_1_x128, 0);
        }
        {
            // returns 0 for two uninitialized ticks if tick is below
            let [fee_growth_inside_0_x128, fee_growth_inside_1_x128] = get_fee_growth_inside(
                -2,
                2,
                &TickInfo::default(),
                &TickInfo::default(),
                -4,
                15,
                15,
            );
            assert_eq!(fee_growth_inside_0_x128, 0);
            assert_eq!(fee_growth_inside_1_x128, 0);
        }
        {
            // subtracts upper tick if below
            let lower = TickInfo::default();
            let upper = TickInfo {
                fee_growth_outside_0_x128: 2,
                fee_growth_outside_1_x128: 3,
                liquidity_gross: 0,
                liquidity_net: 0,
                seconds_per_liquidity_outside_x128: U160::zero(),
                tick_cumulative_outside: 0,
                seconds_outside: 0,
                initialized: true,
            };

            let [fee_growth_inside_0_x128, fee_growth_inside_1_x128] =
                get_fee_growth_inside(-2, 2, &lower, &upper, 0, 15, 15);
            assert_eq!(fee_growth_inside_0_x128, 13);
            assert_eq!(fee_growth_inside_1_x128, 12);
        }
        {
            // subtracts upper tick if above
            let upper = TickInfo::default();
            let lower = TickInfo {
                fee_growth_outside_0_x128: 2,
                fee_growth_outside_1_x128: 3,
                liquidity_gross: 0,
                liquidity_net: 0,
                seconds_per_liquidity_outside_x128: U160::zero(),
                tick_cumulative_outside: 0,
                seconds_outside: 0,
                initialized: true,
            };

            let [fee_growth_inside_0_x128, fee_growth_inside_1_x128] =
                get_fee_growth_inside(-2, 2, &lower, &upper, 0, 15, 15);
            assert_eq!(fee_growth_inside_0_x128, 13);
            assert_eq!(fee_growth_inside_1_x128, 12);
        }
        {
            // subtracts upper and lower tick if inside
            let lower = TickInfo {
                fee_growth_outside_0_x128: 2,
                fee_growth_outside_1_x128: 3,
                liquidity_gross: 0,
                liquidity_net: 0,
                seconds_per_liquidity_outside_x128: U160::zero(),
                tick_cumulative_outside: 0,
                seconds_outside: 0,
                initialized: true,
            };
            let upper = TickInfo {
                fee_growth_outside_0_x128: 4,
                fee_growth_outside_1_x128: 1,
                liquidity_gross: 0,
                liquidity_net: 0,
                seconds_per_liquidity_outside_x128: U160::zero(),
                tick_cumulative_outside: 0,
                seconds_outside: 0,
                initialized: true,
            };

            let [fee_growth_inside_0_x128, fee_growth_inside_1_x128] =
                get_fee_growth_inside(-2, 2, &lower, &upper, 0, 15, 15);
            assert_eq!(fee_growth_inside_0_x128, 9);
            assert_eq!(fee_growth_inside_1_x128, 11);
        }
        // UPDATED: Does not work with overflow on inside tick
        // {
        //     // works correctly with overflow on inside tick
        //     let lower = TickInfo {
        //         fee_growth_outside_0_x128: u128::MAX - 3,
        //         fee_growth_outside_1_x128: u128::MAX - 2,
        //         liquidity_gross: 0,
        //         liquidity_net: 0,
        //         seconds_per_liquidity_outside_x128: U160::zero(),
        //         tick_cumulative_outside: 0,
        //         seconds_outside: 0,
        //         initialized: true,
        //     };
        //     let upper = TickInfo {
        //         fee_growth_outside_0_x128: 3,
        //         fee_growth_outside_1_x128: 5,
        //         liquidity_gross: 0,
        //         liquidity_net: 0,
        //         seconds_per_liquidity_outside_x128: U160::zero(),
        //         tick_cumulative_outside: 0,
        //         seconds_outside: 0,
        //         initialized: true,
        //     };

        //     let [fee_growth_inside_0_x128, fee_growth_inside_1_x128] =
        //         get_fee_growth_inside(-2, 2, &lower, &upper, 0, 15, 15);
        //     assert_eq!(fee_growth_inside_0_x128, 16);
        //     assert_eq!(fee_growth_inside_1_x128, 13);
        // }
    }

    #[test]
    fn test_cross() {
        {
            // flips the growth variables
            let mut tick = TickInfo {
                fee_growth_outside_0_x128: 1,
                fee_growth_outside_1_x128: 2,
                liquidity_gross: 3,
                liquidity_net: 4,
                seconds_per_liquidity_outside_x128: U160::from(5),
                tick_cumulative_outside: 6,
                seconds_outside: 7,
                initialized: true,
            };

            // tick.cross(7, 9, U160::from(8), 15, 10);
            tick.cross(7, 9);

            assert_eq!(tick.fee_growth_outside_0_x128, 6);
            assert_eq!(tick.fee_growth_outside_1_x128, 7);
            // assert_eq!(tick.seconds_per_liquidity_outside_x128, 3);
            // assert_eq!(tick.tick_cumulative_outside, 9);
            // assert_eq!(tick.seconds_outside, 3);
        }
        {
            // two flips are no op
            let mut tick = TickInfo {
                fee_growth_outside_0_x128: 1,
                fee_growth_outside_1_x128: 2,
                liquidity_gross: 3,
                liquidity_net: 4,
                seconds_per_liquidity_outside_x128: U160::from(5),
                tick_cumulative_outside: 6,
                seconds_outside: 7,
                initialized: true,
            };

            // tick.cross(7, 9, U160::from(8), 15, 10);
            // tick.cross(7, 9, U160::from(8), 15, 10);
            tick.cross(7, 9);
            tick.cross(7, 9);

            assert_eq!(tick.fee_growth_outside_0_x128, 1);
            assert_eq!(tick.fee_growth_outside_1_x128, 2);
            // assert_eq!(tick.seconds_per_liquidity_outside_x128, U256::from(5));
            // assert_eq!(tick.tick_cumulative_outside, 6);
            // assert_eq!(tick.seconds_outside, 7);
        }
    }

    #[test]
    fn test_update() {
        // TODO: @galin-chung-nguyen
    }

    #[test]
    fn test_clear() {
        // TODO: @galin-chung-nguyen
    }
}

'''
'''--- zswap-contracts-main/library/src/tick_bitmap.rs ---
use near_sdk::collections::LookupMap;

use crate::bit_math::BitMathTrait;
use crate::num24::I24;
use crate::num256::U256;
use crate::tick_math::TickConstants;

/// @title Packed tick initialized state library
/// @notice Stores a packed mapping of tick index to its initialized state
/// @dev The mapping uses int16 for keys since ticks are represented as int24 and there are 256 (2^8) values per word.

/// @notice Computes the position in the mapping where the initialized bit for a tick lives
/// @param tick The tick for which to compute the position
/// @return wordPos The key in the mapping containing the word in which the bit is stored
/// @return bitPos The bit position in the word where the flag is stored
pub fn position(tick: i32) -> (i16, u8) {
    assert!(
        (TickConstants::MIN_TICK..=TickConstants::MAX_TICK).contains(&tick),
        "INVALID TICK RANGE",
    );
    let word_pos = (tick >> 8) as i16;
    let bit_pos = (tick % 256) as u8;
    (word_pos, bit_pos)
}

/// !MODIFIED
/// @notice Flips the initialized state for a given tick from false to true, or vice versa
/// @param self The mapping in which to flip the tick
/// @param tick The tick to flip
/// @param
/// @param tickSpacing The spacing between usable ticks
pub fn flip_tick(tick_bitmap: &mut LookupMap<i16, U256>, tick: i32, tick_spacing: i32) {
    assert!(
        (TickConstants::MIN_TICK..=TickConstants::MAX_TICK).contains(&tick),
        "INVALID TICK RANGE",
    );
    assert_eq!(tick % tick_spacing, 0); // ensure that the tick is spaced
    let (word_pos, bit_pos) = position(tick / tick_spacing);
    let mask = U256::one() << bit_pos;
    let mut current = tick_bitmap.get(&word_pos).unwrap_or_default();
    current ^= mask;
    tick_bitmap.insert(&word_pos, &current);
}

/// !MODIFIED
/// @notice Returns the next initialized tick contained in the same word (or adjacent word) as the tick that is either
/// to the left (less than or equal to) or right (greater than) of the given tick
/// @param self The mapping in which to compute the next initialized tick
/// @param tick The starting tick
/// @param tickSpacing The spacing between usable ticks
/// @param lte Whether to search for the next initialized tick to the left (less than or equal to the starting tick)
/// !@param get_word A function to get word by word position from a tick bitmap
/// @return next The next initialized or uninitialized tick up to 256 ticks away from the current tick
/// @return initialized Whether the next tick is initialized, as the function only searches within up to 256 ticks
pub fn next_initialized_tick_within_one_word(
    tick_bitmap: &LookupMap<i16, U256>,
    tick: i32,
    tick_spacing: i32,
    lte: bool,
) -> (i32, bool) {
    assert!(
        (TickConstants::MIN_TICK..=TickConstants::MAX_TICK).contains(&tick),
        "INVALID TICK RANGE",
    );
    assert_ne!(tick_spacing, 0);
    let mut compressed = tick / tick_spacing;
    if tick < 0 && tick % tick_spacing != 0 {
        // round towards negative infinity
        compressed -= 1;
    }
    let initialized: bool;
    let next: I24;

    if lte {
        let (word_pos, bit_pos) = position(compressed);
        // all the 1s at or to the right of the current bitPos
        let mask = (U256::one() << bit_pos) - U256::one() + (U256::one() << bit_pos);
        let masked = tick_bitmap.get(&word_pos).unwrap_or_default() & mask;

        // if there are no initialized ticks to the right of or at the current tick, return rightmost in the word
        initialized = masked != U256::zero();
        // overflow/underflow is possible, but prevented externally by limiting both tickSpacing and tick
        next = if initialized {
            ((compressed - (bit_pos as I24 - masked.most_significant_bit() as I24)) as I24)
                * tick_spacing
        } else {
            (compressed - (bit_pos as I24)) * tick_spacing
        };
    } else {
        // start from the word of the next tick, since the current tick state doesn't matter
        let (word_pos, bit_pos) = position(compressed + 1);
        // all the 1s at or to the left of the bitPos
        let mask = !((U256::one() << bit_pos) - U256::one());
        let masked = tick_bitmap.get(&word_pos).unwrap_or_default() & mask;

        // if there are no initialized ticks to the left of the current tick, return leftmost in the word
        initialized = masked != U256::zero();
        next = if initialized {
            (compressed + 1 + (masked.least_significant_bit() as I24 - bit_pos as I24))
                * tick_spacing
        } else {
            (compressed + 1 + (u8::MAX as I24 - bit_pos as I24)) * tick_spacing
        };
    }

    (next, initialized)
}

#[cfg(test)]
mod tests {
    #[test]
    fn test_position() {
        // TODO: @galin-chung-nguyen
    }

    #[test]
    fn test_flip_tick() {
        // TODO: @galin-chung-nguyen
    }

    #[test]
    fn test_next_initialized_tick_within_one_word() {
        // TODO: @galin-chung-nguyen
    }
}

'''
'''--- zswap-contracts-main/library/src/tick_math.rs ---
use ethnum::I256;
use std::str::FromStr;
// use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
// use near_sdk::{env, log};
// use near_sdk::ext_contract;

use crate::num160::{AsU160, U160};
use crate::num24::{AsI24, I24};
use crate::num256::{AsI256, ToU256, U256};

pub struct TickConstants;

impl TickConstants {
    pub const MIN_TICK: I24 = -887272;
    pub const MAX_TICK: I24 = -TickConstants::MIN_TICK;

    pub fn min_sqrt_ratio() -> U160 {
        U160::from_dec_str("4295128739").unwrap_or(U160::zero())
    }

    pub fn max_sqrt_ratio() -> U160 {
        U160::from_dec_str("1461446703485210103287273052203988822378723970342")
            .unwrap_or(U160::zero())
    }
}
//
// fn printBits256(x: I256) {
//   print!("{} => ", x);
//   for i in 0..=255{
//     print!("{}", (x >> (255 - i)) & I256::ONE);
//   }
//   println!();
// }
// fn printBits32(x: i32) {
//   print!("{} => ", x);
//   for i in 0..=31{
//     print!("{}", (x >> (31 - i)) & 1);
//   }
//   println!();
// }

/// @title Math library for computing sqrt prices from ticks and vice versa
/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports
/// prices between 2**-128 and 2**128

/// @notice Calculates sqrt(1.0001^tick) * 2^96
/// @dev Throws if |tick| > max tick
/// @param tick The input tick for the above formula
/// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)
/// at the given tick
pub fn get_sqrt_ratio_at_tick(tick: I24) -> U160 {
    // second inequality must be < because the price can never reach the price at the max tick
    let abs_tick = U256::from(tick.abs());
    // println!("{} {} {} {}", tick, abs_tick, TickConstants::max_sqrt_ratio(), TickConstants::MIN_TICK - 1);
    assert!(
        abs_tick <= U256::from(TickConstants::MAX_TICK),
        "Tick out of range"
    );

    let mut ratio = if (abs_tick & U256::one()) != U256::zero() {
        U256::from(0xfffcb933bd6fad37aa2d162d1a594001_u128)
    } else {
        U256::from_str_radix("0x100000000000000000000000000000000", 16).unwrap()
    };

    if (abs_tick & U256::from(0x2)) != U256::zero() {
        ratio = (ratio * U256::from(0xfff97272373d413259a46990580e213a_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x4)) != U256::zero() {
        ratio = (ratio * U256::from(0xfff2e50f5f656932ef12357cf3c7fdcc_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x8)) != U256::zero() {
        ratio = (ratio * U256::from(0xffe5caca7e10e4e61c3624eaa0941cd0_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x10)) != U256::zero() {
        ratio = (ratio * U256::from(0xffcb9843d60f6159c9db58835c926644_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x20)) != U256::zero() {
        ratio = (ratio * U256::from(0xff973b41fa98c081472e6896dfb254c0_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x40)) != U256::zero() {
        ratio = (ratio * U256::from(0xff2ea16466c96a3843ec78b326b52861_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x80)) != U256::zero() {
        ratio = (ratio * U256::from(0xfe5dee046a99a2a811c461f1969c3053_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x100)) != U256::zero() {
        ratio = (ratio * U256::from(0xfcbe86c7900a88aedcffc83b479aa3a4_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x200)) != U256::zero() {
        ratio = (ratio * U256::from(0xf987a7253ac413176f2b074cf7815e54_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x400)) != U256::zero() {
        ratio = (ratio * U256::from(0xf3392b0822b70005940c7a398e4b70f3_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x800)) != U256::zero() {
        ratio = (ratio * U256::from(0xe7159475a2c29b7443b29c7fa6e889d9_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x1000)) != U256::zero() {
        ratio = (ratio * U256::from(0xd097f3bdfd2022b8845ad8f792aa5825_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x2000)) != U256::zero() {
        ratio = (ratio * U256::from(0xa9f746462d870fdf8a65dc1f90e061e5_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x4000)) != U256::zero() {
        ratio = (ratio * U256::from(0x70d869a156d2a1b890bb3df62baf32f7_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x8000)) != U256::zero() {
        ratio = (ratio * U256::from(0x31be135f97d08fd981231505542fcfa6_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x10000)) != U256::zero() {
        ratio = (ratio * U256::from(0x9aa508b5b7a84e1c677de54f3e99bc9_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x20000)) != U256::zero() {
        ratio = (ratio * U256::from(0x5d6af8dedb81196699c329225ee604_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x40000)) != U256::zero() {
        ratio = (ratio * U256::from(0x2216e584f5fa1ea926041bedfe98_u128)) >> 128;
    }
    if (abs_tick & U256::from(0x80000)) != U256::zero() {
        ratio = (ratio * U256::from(0x48a170391f7dc42444e8fa2_u128)) >> 128;
    }

    if tick > 0 {
        ratio = U256::MAX / ratio;
    }

    // this divides by 1<<32 rounding up to go from a get_q128.128 to a get_q128.96.
    // we then downcast because we know the result always fits within 160 bits due to our tick input constraint
    // we round up in the division so get_tick_at_sqrt_ratio of the output price is always consistent
    (((ratio >> 32)
        + U256::from(if ratio % (1u128 << 32) == U256::zero() {
            0
        } else {
            1
        })) as U256)
        .as_u160()
}

/// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio
/// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may
/// ever return.
/// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96
/// @return tick The greatest tick for which the ratio is less than or equal to the input ratio
pub fn get_tick_at_sqrt_ratio(sqrt_price_x96: U160) -> I24 {
    // second inequality must be < because the price can never reach the price at the max tick
    assert!(
        sqrt_price_x96 >= TickConstants::min_sqrt_ratio()
            && sqrt_price_x96 < TickConstants::max_sqrt_ratio(),
        "Sqrt ratio out of range"
    );

    let ratio: U256 = sqrt_price_x96 << 32;
    let mut r = ratio;
    let mut msb: U256 = U256::from(0);

    let f = U256::from(u128::from(
        r > U256::from_str_radix("0xffffffffffffffffffffffffffffffff", 16).unwrap(),
    )) << 7;
    msb |= f;
    r >>= f;

    let f = U256::from(u128::from(
        r > U256::from_str_radix("0xffffffffffffffff", 16).unwrap(),
    )) << 6;
    msb |= f;
    r >>= f;

    let f = U256::from(u128::from(
        r > U256::from_str_radix("0xffffffff", 16).unwrap(),
    )) << 5;
    msb |= f;
    r >>= f;

    let f = U256::from(u128::from(r > U256::from(0xffff))) << 4;
    msb |= f;
    r >>= f;

    let f = U256::from(u128::from(r > U256::from(0xff))) << 3;
    msb |= f;
    r >>= f;

    let f = U256::from(u128::from(r > U256::from(0xf))) << 2;
    msb |= f;
    r >>= f;

    let f = U256::from(u128::from(r > U256::from(0x3))) << 1;
    msb |= f;
    r >>= f;

    let f = U256::from(u128::from(r > U256::from(0x1)));
    msb |= f;

    if msb >= U256::from(128) {
        r = ratio >> (msb - 127);
    } else {
        r = ratio << (U256::from(127) - msb);
    }

    let mut log_2: I256 = (msb.as_i256() - 128) << 64;

    for i in 0..14 {
        r = (r * r) >> 127;
        let f = I256::from(((r >> 128) as U256).as_u128());
        log_2 |= f << (63 - i);
        if i < 13 {
            r >>= f.to_u256();
        }
    }

    let log_sqrt10001: I256 = log_2 * 255738958999603826347141; // 128.128 number
    let tick_low =
        (((log_sqrt10001 - 3402992956809132418596140100660247210i128) >> 128) as I256).as_i24();
    let tick_hi = (((log_sqrt10001
        + I256::from_str("291339464771989622907027621153398088495").unwrap())
        >> 128) as I256)
        .as_i24();

    // let mut l = -887272;
    // let mut r = 887272;
    // let mut res = -1;
    // while l <= r {
    //   let mid = (l + r) >> 1;
    //   let tmp = get_sqrt_ratio_at_tick(mid);
    //   if (tmp <= sqrt_price_x96) {
    //     res = mid;
    //     l = mid + 1;
    //   } else { r = mid - 1 };
    // }

    if tick_low == tick_hi {
        tick_low
    } else if get_sqrt_ratio_at_tick(tick_hi) <= sqrt_price_x96 {
        tick_hi
    } else {
        tick_low
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod tests {
    use super::*;
    use crate::full_math::MathOps;
    use std::panic;

    #[test]
    fn test_get_sqrt_ratio_at_tick() {
        assert!(panic::catch_unwind(|| {
            get_sqrt_ratio_at_tick(TickConstants::MIN_TICK - 1);
        })
        .is_err());
        //throws for too high
        assert!(panic::catch_unwind(|| {
            get_sqrt_ratio_at_tick(TickConstants::MAX_TICK + 1);
        })
        .is_err());

        assert_eq!(
            get_sqrt_ratio_at_tick(TickConstants::MIN_TICK),
            U160::from(4295128739 as u64)
        );
        assert_eq!(
            get_sqrt_ratio_at_tick(TickConstants::MIN_TICK + 1),
            U160::from(4295343490 as u64)
        );
        assert_eq!(
            get_sqrt_ratio_at_tick(TickConstants::MAX_TICK - 1),
            U160::from_dec_str("1461373636630004318706518188784493106690254656249").unwrap()
        );
        // // min tick ratio is less than js implementation // TODO: build Js integration test
        // // max tick ratio is greater than js implementation
        assert_eq!(
            get_sqrt_ratio_at_tick(TickConstants::MAX_TICK),
            U160::from_dec_str("1461446703485210103287273052203988822378723970342").unwrap()
        );
        assert_eq!(
            get_sqrt_ratio_at_tick(TickConstants::MIN_TICK),
            TickConstants::min_sqrt_ratio()
        );
        assert_eq!(
            get_sqrt_ratio_at_tick(TickConstants::MAX_TICK),
            TickConstants::max_sqrt_ratio()
        );
    }

    #[test]
    fn test_get_tick_at_sqrt_ratio() {
        // //throws for too low
        assert!(panic::catch_unwind(|| {
            get_tick_at_sqrt_ratio(TickConstants::min_sqrt_ratio() - U160::one());
        })
        .is_err());
        //throws for too high
        assert!(panic::catch_unwind(|| {
            get_tick_at_sqrt_ratio(TickConstants::max_sqrt_ratio());
        })
        .is_err());
        //
        assert_eq!(
            get_tick_at_sqrt_ratio(TickConstants::min_sqrt_ratio()),
            TickConstants::MIN_TICK
        );
        assert_eq!(
            get_tick_at_sqrt_ratio(U160::from_dec_str("4295343490").unwrap()),
            TickConstants::MIN_TICK + 1
        );
        assert_eq!(
            get_tick_at_sqrt_ratio(
                U160::from_dec_str("1461373636630004318706518188784493106690254656249").unwrap()
            ),
            TickConstants::MAX_TICK - 1
        );
        assert_eq!(
            get_tick_at_sqrt_ratio(TickConstants::max_sqrt_ratio().sub(U160::one())),
            TickConstants::MAX_TICK - 1
        );
    }
}

'''
'''--- zswap-contracts-main/library/src/utils.rs ---
use crate::full_math::{FullMath, FullMathTrait};
use crate::num256::U256;

// returns the sqrt price as a 64x96
pub fn encode_price_sqrt(reserve1: U256, reserve0: U256) -> U256 {
    let a = reserve1;
    let b = reserve0;
    let c = U256::one() << U256::from(96);
    // res = sqrt(a/b) * c
    // res^2 <= a / b * c^2
    // res <= (a * c^2 / (res * b))
    let mut l = U256::from(4295128739_u64);
    let mut r = U256::one() << U256::from(160);
    let mut res = U256::zero();

    while l <= r {
        let mid: U256 = (l + r) >> 1;
        // TODO: @galin-chung-nguyen: use safer formulation since res * b might overflows
        let x = FullMath::mul_div(a, c.pow(U256::from(2)), mid.overflowing_mul(b).0);
        if mid <= x {
            res = mid;
            l = mid + 1;
        } else {
            r = mid - 1;
        }
    }
    res
}

pub fn encode_price_sqrt_u128(reserve1: u128, reserve0: u128) -> U256 {
    encode_price_sqrt(U256::from(reserve1), U256::from(reserve0))
}

pub fn expand_to_18_decimals(amount: u128) -> U256 {
    U256::from(amount) * U256::from(10).pow(U256::from(18))
}

'''
'''--- zswap-contracts-main/manager/Cargo.toml ---
[package]
name = "zswap-manager"
version = "1.0.0"
authors = ["DV Lab"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }
base64 = "0.21.2"
hex = "0.4.3"
zswap-math-library = { path = "../library" }

[dev-dependencies.cargo-husky]
version = "1"
default-features = false
features = ["user-hooks"]

'''
'''--- zswap-contracts-main/manager/deploy.sh ---
#!/bin/sh

# ./build.sh

# if [ $? -ne 0 ]; then
#   echo ">> Error building Zswap contracts!"
#   exit 1
# fi

echo ">> Deploying Zswap Manager contract..."

# https://docs.near.org/tools/near-cli#near-dev-deploy
near dev-deploy --wasmFile ../res/zswap_manager.wasm

'''
'''--- zswap-contracts-main/manager/src/callback.rs ---
use near_contract_standards::non_fungible_token::metadata::TokenMetadata as NftMetadata;
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::{env, near_bindgen, serde_json, Promise, PromiseError};
use zswap_math_library::pool_account;

use crate::error::{MINT_CALLBACK_ERROR, SLIPPAGE_CHECK_FAILED};
use crate::nft::NftPosition;
use crate::utils::{generate_nft_media, MintCallbackParams, NftLiquidityInfo};
use crate::Contract;
use crate::ContractExt;

pub trait ManagerCallback {
    fn mint_callback(
        &mut self,
        used_amounts_res: Result<[U128; 2], PromiseError>,
        params: MintCallbackParams,
    ) -> [U128; 2];

    fn manager_swap_callback(
        &mut self,
        amount_out_min: U128,
        amount_received: Result<U128, PromiseError>,
    );
}

#[near_bindgen]
impl ManagerCallback for Contract {
    #[private]
    #[payable]
    fn mint_callback(
        &mut self,
        #[callback_result] used_amounts_res: Result<[U128; 2], PromiseError>,
        params: MintCallbackParams,
    ) -> [U128; 2] {
        if used_amounts_res.is_err() {
            Promise::new(params.recipient).transfer(env::attached_deposit());
            env::panic_str(MINT_CALLBACK_ERROR)
        }

        let received_amounts = used_amounts_res.unwrap();
        let amount_0 = received_amounts[0];
        let amount_1 = received_amounts[1];

        if amount_0 < params.amount_0_min || amount_1 < params.amount_1_min {
            Promise::new(params.recipient).transfer(env::attached_deposit());
            env::panic_str(SLIPPAGE_CHECK_FAILED)
        }

        // mint nft
        let symbol_0 = &params.symbol_0;
        let symbol_1 = &params.symbol_1;
        assert!(params.token_0 < params.token_1);
        let pool = pool_account::compute_account(
            &self.factory,
            &params.token_0,
            &params.token_1,
            params.fee,
        );

        let nft_title = format!("{}/{}", symbol_0, symbol_1);
        let nft_description = format!("ZSwap Liquidity NFT for {}", &pool);
        let nft_media = generate_nft_media(
            self.nft_id,
            symbol_0,
            symbol_1,
            params.lower_tick,
            params.upper_tick,
            params.fee,
        );
        let nft_media_hash = env::sha256(nft_media.as_bytes());
        let liquidity_info = NftLiquidityInfo {
            token_0: params.token_0.clone(),
            token_1: params.token_1.clone(),
            fee: params.fee,
            lower_tick: params.lower_tick,
            upper_tick: params.upper_tick,
            liquidity: params.liquidity,
        };

        let liquidity_nft_metadata = NftMetadata {
            title: Some(nft_title),
            description: Some(nft_description),
            media: Some(nft_media),
            media_hash: Some(Base64VecU8::from(nft_media_hash)),
            copies: None,
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: Some(serde_json::to_string(&liquidity_info).unwrap()),
            reference: None,
            reference_hash: None,
        };

        self.nft.internal_mint(
            self.nft_id.to_string(),
            params.recipient,
            Some(liquidity_nft_metadata),
        );
        self.nft_positions.insert(
            &self.nft_id,
            &NftPosition {
                pool,
                lower_tick: params.lower_tick,
                upper_tick: params.upper_tick,
                liquidity: params.liquidity,
            },
        );
        self.nft_id += 1;

        [amount_0, amount_1]
    }

    #[allow(unused)]
    #[private]
    fn manager_swap_callback(
        &mut self,
        amount_out_min: U128,
        #[callback_result] amount_received: Result<U128, PromiseError>,
    ) {
        todo!("check output amount is enough or not")
    }
}

'''
'''--- zswap-contracts-main/manager/src/error.rs ---
pub const SLIPPAGE_CHECK_FAILED: &str = "Slippage check failed";
// pub const TOO_LITTLE_RECEIVED: &str = "Too little received";
pub const TOKENS_MUST_BE_DIFFERENT: &str = "Tokens must be different";
pub const MINT_CALLBACK_ERROR: &str = "Mint callback error";
pub const WRONG_MSG_FORMAT: &str = "Wrong msg format";
pub const POOL_ALREADY_EXISTS: &str = "Pool already exists";

pub const NFT_NOT_OWNED_BY_CALLER: &str = "NFT not owned by caller";
pub const NFT_NOT_FOUND: &str = "NFT not found";

pub const INVALID_FT_METADATA: &str = "Invalid FT metadata";

'''
'''--- zswap-contracts-main/manager/src/factory.rs ---
use near_sdk::{ext_contract, json_types::U128, AccountId, Promise};

#[ext_contract(ext_zswap_factory)]
pub trait ZswapFactory {
    fn create_pool(
        &mut self,
        token_0: AccountId,
        token_1: AccountId,
        fee: u32,
        sqrt_price_x96: U128,
    ) -> Promise;
}

'''
'''--- zswap-contracts-main/manager/src/ft_receiver.rs ---
use near_contract_standards::fungible_token::core::ext_ft_core;
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::ONE_YOCTO;
use near_sdk::{env, json_types::U128, near_bindgen, serde_json, AccountId, PromiseOrValue};
use zswap_math_library::pool_account;

use crate::error::*;
use crate::pool::ext_zswap_pool;
use crate::{Contract, ContractExt};

/// Message parameters to receive via token function call.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(rename_all = "snake_case")]
pub enum TokenReceiverMessage {
    /// Alternative to deposit + execute actions call.
    SwapSingle {
        token_out: AccountId,
        fee: u32,
        sqrt_price_limit_x96: Option<U128>,
    },
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let token_in = env::predecessor_account_id();
        let amount_in = amount;

        let message = serde_json::from_str::<TokenReceiverMessage>(&msg).expect(WRONG_MSG_FORMAT);
        match message {
            TokenReceiverMessage::SwapSingle {
                token_out,
                fee,
                sqrt_price_limit_x96,
            } => {
                let receipient = sender_id;
                let zero_for_one = token_in < token_out;
                let pool_id =
                    pool_account::compute_account(&self.factory, &token_in, &token_out, fee);
                ext_ft_core::ext(token_in)
                    .with_attached_deposit(ONE_YOCTO)
                    .ft_transfer_call(pool_id.clone(), amount_in, None, String::from(""))
                    .then(ext_zswap_pool::ext(pool_id).swap(
                        receipient,
                        zero_for_one,
                        amount_in,
                        sqrt_price_limit_x96,
                    ));
            }
        }

        let unused_amount = U128(0);
        PromiseOrValue::Value(unused_amount)
    }
}

// impl Contract {
//     fn internal_deposit(&mut self, sender_id: &AccountId, token_id: &AccountId, amount: u128) {
//         let token_key = get_token_key(sender_id, token_id);
//         let token_opt = self.account_tokens.get(&token_key);
//         match token_opt {
//             Some(deposistted) => {
//                 self.account_tokens
//                     .insert(&token_key, &(deposistted + amount));
//             }
//             None => {
//                 self.account_tokens.insert(&token_key, &amount);
//             }
//         }
//     }
// }

'''
'''--- zswap-contracts-main/manager/src/ft_storage.rs ---
use near_contract_standards::storage_management::StorageBalance;
use near_sdk::{ext_contract, AccountId};

#[ext_contract(ext_ft_storage)]
pub trait StorageManagement {
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;
}

'''
'''--- zswap-contracts-main/manager/src/internal.rs ---
use std::cmp::Ordering;

use near_sdk::{env, AccountId};
use zswap_math_library::num256::U256;
use zswap_math_library::{liquidity_math, pool_account, tick_math};

use crate::error::TOKENS_MUST_BE_DIFFERENT;
use crate::pool::Slot0;
use crate::Contract;

impl Contract {
    pub fn internal_get_pool(
        &self,
        token_0: &AccountId,
        token_1: &AccountId,
        fee: u32,
    ) -> AccountId {
        let ordered_token_0;
        let ordered_token_1;
        match token_0.cmp(token_1) {
            Ordering::Less => {
                ordered_token_0 = token_0;
                ordered_token_1 = token_1;
            }
            Ordering::Greater => {
                ordered_token_0 = token_1;
                ordered_token_1 = token_0;
            }
            Ordering::Equal => env::panic_str(TOKENS_MUST_BE_DIFFERENT),
        }

        pool_account::compute_account(&self.factory, ordered_token_0, ordered_token_1, fee)
    }

    pub fn internal_calculate_liquidity(
        &self,
        slot_0: Slot0,
        lower_tick: i32,
        upper_tick: i32,
        amount_0: u128,
        amount_1: u128,
    ) -> u128 {
        let sqrt_price_x96 = slot_0.sqrt_price_x96;
        let sqrt_price_lower_x96 = tick_math::get_sqrt_ratio_at_tick(lower_tick);
        let sqrt_price_upper_x96 = tick_math::get_sqrt_ratio_at_tick(upper_tick);
        liquidity_math::get_liquidity_for_amounts(
            U256::from(sqrt_price_x96.0),
            sqrt_price_lower_x96,
            sqrt_price_upper_x96,
            amount_0,
            amount_1,
        )
    }
}

'''
'''--- zswap-contracts-main/manager/src/lib.rs ---
use ft_storage::ext_ft_storage;
use near_contract_standards::fungible_token::metadata::{ext_ft_metadata, FungibleTokenMetadata};
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedSet};
use near_sdk::json_types::{I128, U128};
use near_sdk::{
    env, log, near_bindgen, AccountId, Balance, BorshStorageKey, CryptoHash, PanicOnDefault,
    Promise, PromiseError,
};
use zswap_math_library::num256::U256;
use zswap_math_library::{liquidity_math, sqrt_price_math, tick_math};

use crate::error::*;
use crate::factory::ext_zswap_factory;
use crate::nft::*;
use crate::pool::{ext_zswap_pool, Slot0};
use crate::utils::*;

mod callback;
mod error;
mod factory;
pub mod ft_receiver;
mod ft_storage;
mod internal;
mod nft;
mod pool;
pub mod utils;

const NEAR_PER_STORAGE: Balance = 10_000_000_000_000_000_000; // 10e18yⓃ
const FT_STORAGE_DEPOSIT: Balance = 1500 * NEAR_PER_STORAGE;

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    factory: AccountId,
    account_tokens: LookupMap<CryptoHash, u128>,
    fungible_tokens: UnorderedSet<AccountId>,
    nft_positions: LookupMap<u128, NftPosition>,
    nft: NonFungibleToken,
    nft_id: u128,
    metadata: LazyOption<NFTContractMetadata>,
}

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    AccountTokens,
    FungibleTokens,
    NftPositions,
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

// Implement the contract structure
#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(factory: AccountId) -> Self {
        let nft = NonFungibleToken::new(
            StorageKey::NonFungibleToken,
            env::current_account_id(),
            Some(StorageKey::TokenMetadata),
            Some(StorageKey::Enumeration),
            Some(StorageKey::Approval),
        );
        let metadata = NFTContractMetadata {
            spec: NFT_METADATA_SPEC.to_string(),
            name: "ZSwap Liquidity Management".to_string(),
            symbol: "ZLM".to_string(),
            icon: None,
            base_uri: None,
            reference: None,
            reference_hash: None,
        };
        Self {
            factory,
            account_tokens: LookupMap::new(StorageKey::AccountTokens),
            fungible_tokens: UnorderedSet::new(StorageKey::FungibleTokens),
            nft_positions: LookupMap::new(StorageKey::NftPositions),
            nft,
            nft_id: 0,
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    #[payable]
    pub fn create_pool(
        &mut self,
        token_0: AccountId,
        token_1: AccountId,
        fee: u32,
        sqrt_price_x96: U128,
    ) -> Promise {
        let is_new_token_0 = self.fungible_tokens.insert(&token_0);
        let is_new_token_1 = self.fungible_tokens.insert(&token_1);
        if !is_new_token_0 && !is_new_token_1 {
            env::panic_str(POOL_ALREADY_EXISTS);
        }

        let create_pool_promise = ext_zswap_factory::ext(self.factory.clone())
            .with_attached_deposit(env::attached_deposit() - 2 * FT_STORAGE_DEPOSIT)
            .with_unused_gas_weight(30)
            .create_pool(token_0.clone(), token_1.clone(), fee, sqrt_price_x96);

        let token_0_storage_deposit_promise = ext_ft_storage::ext(token_0.clone())
            .with_attached_deposit(FT_STORAGE_DEPOSIT)
            .storage_deposit(Some(env::current_account_id()), None);
        let token_1_storage_deposit_promise = ext_ft_storage::ext(token_1.clone())
            .with_attached_deposit(FT_STORAGE_DEPOSIT)
            .storage_deposit(Some(env::current_account_id()), None);

        if is_new_token_0 && is_new_token_1 {
            token_0_storage_deposit_promise
                .and(token_1_storage_deposit_promise)
                .then(create_pool_promise)
        } else if is_new_token_0 {
            token_0_storage_deposit_promise.then(create_pool_promise)
        } else {
            token_1_storage_deposit_promise.then(create_pool_promise)
        }
    }

    #[payable]
    pub fn mint(&mut self, params: MintParams) -> Promise {
        let pool = self.internal_get_pool(&params.token_0, &params.token_1, params.fee);
        let slot_0_promise = ext_zswap_pool::ext(pool.clone()).get_slot_0();

        let token_0_meta_promise = ext_ft_metadata::ext(params.token_0.clone()).ft_metadata();
        let token_1_meta_promise = ext_ft_metadata::ext(params.token_1.clone()).ft_metadata();

        let recipient = env::predecessor_account_id();

        slot_0_promise
            .and(token_0_meta_promise)
            .and(token_1_meta_promise)
            .then(
                Self::ext(env::current_account_id())
                    .with_attached_deposit(env::attached_deposit())
                    .mint_calculate_liquidity(pool, recipient, params),
            )
    }

    #[payable]
    #[private]
    pub fn mint_calculate_liquidity(
        &mut self,
        #[callback_result] slot_0_res: Result<Slot0, PromiseError>,
        #[callback_result] token_0_meta_res: Result<FungibleTokenMetadata, PromiseError>,
        #[callback_result] token_1_meta_res: Result<FungibleTokenMetadata, PromiseError>,
        pool: AccountId,
        recipient: AccountId,
        params: MintParams,
    ) -> Promise {
        let slot_0 = slot_0_res.unwrap();
        let liquidity = self.internal_calculate_liquidity(
            slot_0,
            params.lower_tick,
            params.upper_tick,
            params.amount_0_desired.0,
            params.amount_1_desired.0,
        );
        log!("Liquidity: {}", liquidity);

        if token_0_meta_res.is_err() || token_1_meta_res.is_err() {
            env::panic_str(INVALID_FT_METADATA);
        }

        let mint_callback_params = MintCallbackParams {
            token_0: params.token_0,
            token_1: params.token_1,
            lower_tick: params.lower_tick,
            upper_tick: params.upper_tick,
            fee: params.fee,
            liquidity,
            symbol_0: token_0_meta_res.unwrap().symbol,
            symbol_1: token_1_meta_res.unwrap().symbol,
            recipient: recipient.clone(),
            amount_0_min: params.amount_0_min,
            amount_1_min: params.amount_1_min,
        };

        ext_zswap_pool::ext(pool)
            .mint(
                recipient,
                env::current_account_id(), // manager owns liquidity, recipient owns NFT
                params.lower_tick,
                params.upper_tick,
                U128::from(liquidity),
            )
            .then(
                Self::ext(env::current_account_id())
                    .with_attached_deposit(env::attached_deposit())
                    .mint_callback(mint_callback_params),
            )
    }

    #[private]
    pub fn calculate_amount_out(
        &mut self,
        #[callback_result] amounts_res: Result<[I128; 2], PromiseError>,
        zero_for_one: bool,
    ) -> U128 {
        let amounts = amounts_res.unwrap();
        if zero_for_one {
            let amount_1 = -amounts[1].0 as u128;
            U128::from(amount_1)
        } else {
            let amount_0 = -amounts[0].0 as u128;
            U128::from(amount_0)
        }
    }

    #[payable]
    pub fn burn(&mut self, nft_id: U128) -> Promise {
        let nft_position = self.nft_positions.get(&nft_id.0);
        if nft_position.is_none() {
            env::panic_str(NFT_NOT_FOUND);
        }

        let nft_position = nft_position.unwrap();
        let owner = self.nft.owner_by_id.get(&nft_id.0.to_string()).unwrap();
        if owner != env::predecessor_account_id() {
            env::panic_str(NFT_NOT_OWNED_BY_CALLER);
        }

        ext_zswap_pool::ext(nft_position.pool.clone())
            .burn(
                nft_position.lower_tick,
                nft_position.upper_tick,
                nft_position.liquidity.into(),
            )
            .then(Self::ext(env::current_account_id()).burn_callback(
                nft_position.pool,
                owner,
                nft_id,
                nft_position.lower_tick,
                nft_position.upper_tick,
            ))
    }

    #[private]
    pub fn burn_callback(
        &mut self,
        #[callback_result] token_amounts_res: Result<[U128; 2], PromiseError>,
        pool: AccountId,
        recipient: AccountId,
        nft_id: U128,
        lower_tick: i32,
        upper_tick: i32,
    ) -> Promise {
        self.nft.internal_burn(nft_id.0.to_string(), &recipient);
        self.nft_positions.remove(&nft_id.0);

        log!("Burned NFT {:?}", nft_id);

        let token_amounts = token_amounts_res.unwrap();

        ext_zswap_pool::ext(pool).collect(
            recipient,
            lower_tick,
            upper_tick,
            token_amounts[0],
            token_amounts[1],
        )
    }

    pub fn get_liquidity_for_amounts(
        &self,
        slot_0: Slot0,
        lower_tick: i32,
        upper_tick: i32,
        amount_0_desired: U128,
        amount_1_desired: U128,
    ) -> U128 {
        self.internal_calculate_liquidity(
            slot_0,
            lower_tick,
            upper_tick,
            amount_0_desired.0,
            amount_1_desired.0,
        )
        .into()
    }

    pub fn calculate_amount_1_with_amount_0(
        &self,
        amount_0: U128,
        sqrt_price_x96: U128,
        lower_tick: i32,
        upper_tick: i32,
    ) -> U128 {
        let sqrt_price_x96 = U256::from(sqrt_price_x96.0);
        let sqrt_price_lower_x96 = tick_math::get_sqrt_ratio_at_tick(lower_tick);
        let sqrt_price_upper_x96 = tick_math::get_sqrt_ratio_at_tick(upper_tick);

        if !(sqrt_price_lower_x96..=sqrt_price_upper_x96).contains(&sqrt_price_x96) {
            return U128::from(0);
        }

        let liquidity = liquidity_math::get_liquidity_for_amount_0(
            sqrt_price_x96,
            sqrt_price_upper_x96,
            amount_0.0,
        );

        sqrt_price_math::get_amount_1_delta_signed(
            sqrt_price_lower_x96,
            sqrt_price_x96,
            liquidity as i128,
        )
        .abs()
        .as_u128()
        .into()
    }

    pub fn calculate_amount_0_with_amount_1(
        &self,
        amount_1: U128,
        sqrt_price_x96: U128,
        lower_tick: i32,
        upper_tick: i32,
    ) -> U128 {
        let sqrt_price_x96 = U256::from(sqrt_price_x96.0);
        let sqrt_price_lower_x96 = tick_math::get_sqrt_ratio_at_tick(lower_tick);
        let sqrt_price_upper_x96 = tick_math::get_sqrt_ratio_at_tick(upper_tick);

        if !(sqrt_price_lower_x96..=sqrt_price_upper_x96).contains(&sqrt_price_x96) {
            return U128::from(0);
        }

        let liquidity = liquidity_math::get_liquidity_for_amount_1(
            sqrt_price_lower_x96,
            sqrt_price_x96,
            amount_1.0,
        );

        sqrt_price_math::get_amount_0_delta_signed(
            sqrt_price_x96,
            sqrt_price_upper_x96,
            liquidity as i128,
        )
        .abs()
        .as_u128()
        .into()
    }

    pub fn get_fungible_tokens(&self) -> Vec<AccountId> {
        self.fungible_tokens.to_vec()
    }
}

/*
 * The rest of this file holds the inline tests for the code above
 * Learn more about Rust tests: https://doc.rust-lang.org/book/ch11-01-writing-tests.html
 */
#[cfg(test)]
mod tests {
    use super::*;

    use near_sdk::{test_utils::VMContextBuilder, testing_env};

    #[test]
    fn test_calculate_amount_0_and_amount_1() {
        let factory_id = AccountId::new_unchecked("factory.testnet".to_string());
        testing_env!(VMContextBuilder::new().build());

        let contract = Contract::new(factory_id);
        let sqrt_price_x96 = U128::from(10 * (2_u128).pow(96));
        let lower_tick = 42000;
        let upper_tick = 48000;
        let amount_0 = U128::from(505327);
        let amount_1 = U128::from(100_000_111);

        let calculated_amount_1 = contract.calculate_amount_1_with_amount_0(
            amount_0,
            sqrt_price_x96,
            lower_tick,
            upper_tick,
        );

        assert_eq!(calculated_amount_1, amount_1);

        let calculated_amount_0 = contract.calculate_amount_0_with_amount_1(
            amount_1,
            sqrt_price_x96,
            lower_tick,
            upper_tick,
        );

        assert_eq!(calculated_amount_0, amount_0);
    }
}

'''
'''--- zswap-contracts-main/manager/src/nft.rs ---
use near_contract_standards::non_fungible_token::{
    metadata::{NFTContractMetadata, NonFungibleTokenMetadataProvider},
    NonFungibleToken, Token, TokenId,
};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::{near_bindgen, AccountId, Promise, PromiseOrValue};

use crate::{Contract, ContractExt};

near_contract_standards::impl_non_fungible_token_core!(Contract, nft);
near_contract_standards::impl_non_fungible_token_approval!(Contract, nft);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, nft);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct NftPosition {
    pub pool: AccountId,
    pub lower_tick: i32,
    pub upper_tick: i32,
    pub liquidity: u128,
}

pub trait BurnNFT {
    fn internal_burn(&mut self, nft_id: String, nft_owner: &AccountId);
}

impl BurnNFT for NonFungibleToken {
    fn internal_burn(&mut self, nft_id: String, nft_owner: &AccountId) {
        if let Some(next_approval_id_by_id) = &mut self.next_approval_id_by_id {
            next_approval_id_by_id.remove(&nft_id);
        }
        if let Some(approvals_by_id) = &mut self.approvals_by_id {
            approvals_by_id.remove(&nft_id);
        }
        if let Some(tokens_per_owner) = &mut self.tokens_per_owner {
            let mut u = tokens_per_owner.remove(nft_owner).unwrap();
            u.remove(&nft_id);
        }
        if let Some(token_metadata_by_id) = &mut self.token_metadata_by_id {
            token_metadata_by_id.remove(&nft_id);
        }
        self.owner_by_id.remove(&nft_id);
    }
}

'''
'''--- zswap-contracts-main/manager/src/pool.rs ---
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::PromiseOrValue;
use near_sdk::{ext_contract, json_types::U128, AccountId};

#[derive(Serialize, Deserialize, Debug, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Slot0 {
    pub sqrt_price_x96: U128,
    pub tick: i32,
}

#[ext_contract(ext_zswap_pool)]
pub trait ZswapPool {
    fn mint(
        &mut self,
        payer: AccountId,
        recipient: AccountId,
        lower_tick: i32,
        upper_tick: i32,
        amount: U128,
    ) -> [U128; 2];

    fn swap(
        &mut self,
        recipient: AccountId,
        zero_for_one: bool,
        amount_specified: U128,
        sqrt_price_limit_x96: Option<U128>,
    ) -> PromiseOrValue<U128>;

    fn burn(&mut self, lower_tick: i32, upper_tick: i32, amount: U128) -> [U128; 2];

    fn collect(
        &mut self,
        recipient: AccountId,
        lower_tick: i32,
        upper_tick: i32,
        amount_0_requested: U128,
        amount_1_requested: U128,
    ) -> [U128; 2];

    fn get_slot_0(&self) -> Slot0;
}

'''
'''--- zswap-contracts-main/manager/src/utils.rs ---
use base64::engine::general_purpose;
use base64::Engine;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId};

// pub struct GetPositionParams {
//     pub token_0: AccountId,
//     pub token_1: AccountId,
//     pub fee: u32,
//     pub owner: AccountId,
//     pub lower_tick: i32,
//     pub upper_tick: i32,
// }

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MintParams {
    pub token_0: AccountId,
    pub token_1: AccountId,
    pub fee: u32,
    pub lower_tick: i32,
    pub upper_tick: i32,
    pub amount_0_desired: U128,
    pub amount_1_desired: U128,
    pub amount_0_min: U128,
    pub amount_1_min: U128,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct MintCallbackParams {
    pub token_0: AccountId,
    pub token_1: AccountId,
    pub lower_tick: i32,
    pub upper_tick: i32,
    pub fee: u32,
    pub liquidity: u128,
    pub symbol_0: String,
    pub symbol_1: String,
    pub recipient: AccountId,
    pub amount_0_min: U128,
    pub amount_1_min: U128,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SwapSingleParams {
    pub token_in: AccountId,
    pub token_out: AccountId,
    pub fee: u32,
    pub amount_in: U128,
    pub sqrt_price_limit_x96: Option<U128>,
}

#[allow(unused)]
pub struct SwapParams {
    tokens: Vec<AccountId>,
    fees: Vec<u32>,
    recipient: AccountId,
    amount_in: u128,
    amount_out_min: u128,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SwapCallbackData {
    pub token_0: AccountId,
    pub token_1: AccountId,
    pub fee: u32,
    pub payer: AccountId,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct NftLiquidityInfo {
    pub token_0: AccountId,
    pub token_1: AccountId,
    pub fee: u32,
    pub lower_tick: i32,
    pub upper_tick: i32,
    pub liquidity: u128,
}

// #[derive(Serialize, Deserialize, Debug)]
// #[serde(crate = "near_sdk::serde")]
// pub struct PoolCallbackData {
//     pub token_0: AccountId,
//     pub token_1: AccountId,
//     pub payer: AccountId,
// }

// pub fn get_token_key(owner: &AccountId, token_id: &AccountId) -> CryptoHash {
//     env::keccak256_array(&[owner.as_bytes(), token_id.as_bytes()].concat())
// }

pub fn generate_nft_media(
    nft_id: u128,
    symbol_0: &str,
    symbol_1: &str,
    lower_tick: i32,
    upper_tick: i32,
    fee: u32,
) -> String {
    let image = [
        "<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 300 480'>",
        "<style>.tokens { font: bold 30px sans-serif; }",
        ".fee { font: normal 26px sans-serif; }",
        ".tick { font: normal 18px sans-serif; }</style>",
        &render_background(nft_id, lower_tick, upper_tick),
        &render_top(symbol_0, symbol_1, fee),
        &render_bottom(lower_tick, upper_tick),
        "</svg>",
    ]
    .join("");

    let image_base64 = general_purpose::STANDARD.encode(image);

    ["data:image/svg+xml;base64,", &image_base64].join("")
}

fn render_background(nft_id: u128, lower_tick: i32, upper_tick: i32) -> String {
    let key = env::keccak256_array(
        &[
            &nft_id.to_le_bytes() as &[u8],
            &lower_tick.to_le_bytes(),
            &upper_tick.to_le_bytes(),
        ]
        .concat(),
    );
    let hue = (u128::from_le_bytes((&key[0..16]).try_into().unwrap()) % 360).to_string();

    [
        "<rect width=\"300\" height=\"480\" fill=\"hsl(",
        &hue,
        ",40%,40%)\"/>",
        "<rect x=\"30\" y=\"30\" width=\"240\" height=\"420\" rx=\"15\" ry=\"15\" fill=\"hsl(",
        &hue,
        ",100%,50%)\" stroke=\"#000\"/>",
    ]
    .join("")
}
fn render_top(symbol_0: &str, symbol_1: &str, fee: u32) -> String {
    [
        "<rect x=\"30\" y=\"87\" width=\"240\" height=\"42\"/>",
        "<text x=\"39\" y=\"120\" class=\"tokens\" fill=\"#fff\">",
        symbol_0,
        "/",
        symbol_1,
        "</text>",
        "<rect x=\"30\" y=\"132\" width=\"240\" height=\"30\"/>",
        "<text x=\"39\" y=\"120\" dy=\"36\" class=\"fee\" fill=\"#fff\">",
        &fee.to_string(),
        "</text>",
    ]
    .join("")
}
fn render_bottom(lower_tick: i32, upper_tick: i32) -> String {
    [
        "<rect x=\"30\" y=\"342\" width=\"240\" height=\"24\"/>",
        "<text x=\"39\" y=\"360\" class=\"tick\" fill=\"#fff\">Lower tick: ",
        &lower_tick.to_string(),
        "</text>",
        "<rect x=\"30\" y=\"372\" width=\"240\" height=\"24\"/>",
        "<text x=\"39\" y=\"360\" dy=\"30\" class=\"tick\" fill=\"#fff\">Upper tick: ",
        &upper_tick.to_string(),
        "</text>",
    ]
    .join("")
}

'''
'''--- zswap-contracts-main/package.json ---
{
  "name": "zswap-contracts",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "deploy": "./deploy.sh",
    "build": "./build.sh",
    "update": "./scripts/update3.sh",
    "test": "npm run test:unit && npm run test:integration",
    "test:unit": "echo no unit test",
    "test:integration": "npm run build && cargo test --package zswap-integration-tests -- --nocapture",
    "test:integration:swap": "npm run build && cargo test --package zswap-integration-tests --test swap -- --nocapture",
    "test:integration:mint": "npm run build && cargo test --package zswap-integration-tests --test mint -- --nocapture",
    "test:integration:burn": "npm run build && cargo test --package zswap-integration-tests --test burn -- --nocapture",
    "postinstall": "echo no frontend && echo rs tests && echo rs contract"
  },
  "devDependencies": {
    "near-cli": "^3.3.0"
  },
  "dependencies": {}
}

'''
'''--- zswap-contracts-main/pool/Cargo.toml ---
[package]
name = "zswap-pool"
version = "1.0.0"
authors = ["DV Lab"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }
ethnum = "1.3.2"
zswap-math-library = { path = "../library" }

[dev-dependencies.cargo-husky]
version = "1"
default-features = false
features = ["user-hooks"]

'''
'''--- zswap-contracts-main/pool/src/callback.rs ---
// use near_sdk::json_types::U128;
// use near_sdk::{env, near_bindgen, Promise, PromiseError};

// use crate::error::{CAN_NOT_COLLECT_TOKENS, INSUFFICIENT_INPUT_AMOUNT};
// use crate::Contract;
// use crate::ContractExt;

// pub trait PoolCallback {
//     fn mint_callback_post_collected_tokens(
//         &self,
//         balance_0_before_res: Result<U128, PromiseError>,
//         balance_1_before_res: Result<U128, PromiseError>,
//         collected_tokens_res: Result<(), PromiseError>,
//         amount_0: u128,
//         amount_1: u128,
//     ) -> Promise;

//     fn check_mint_callback(
//         &self,
//         balance_0_after_res: Result<U128, PromiseError>,
//         balance_1_after_res: Result<U128, PromiseError>,
//         balance_0_before: u128,
//         balance_1_before: u128,
//         amount_0: u128,
//         amount_1: u128,
//     ) -> [U128; 2];

//     fn swap_callback_post_collected_token(amount: Result<U128, PromiseError>, zero_for_one: bool);
// }

// #[near_bindgen]
// impl PoolCallback for Contract {
//     #[private]
//     fn mint_callback_post_collected_tokens(
//         &self,
//         #[callback_result] amount_0_before_res: Result<U128, PromiseError>,
//         #[callback_result] amount_1_before_res: Result<U128, PromiseError>,
//         #[callback_result] collected_tokens_res: Result<(), PromiseError>,
//         amount_0: u128,
//         amount_1: u128,
//     ) -> Promise {
//         if collected_tokens_res.is_err() {
//             env::panic_str(&format!(
//                 "{}: {:?}",
//                 CAN_NOT_COLLECT_TOKENS,
//                 collected_tokens_res.unwrap_err()
//             ))
//         }

//         self.get_balance_0_promise()
//             .and(self.get_balance_1_promise())
//             .then(Self::ext(env::current_account_id()).check_mint_callback(
//                 amount_0_before_res.unwrap().0,
//                 amount_1_before_res.unwrap().0,
//                 amount_0,
//                 amount_1,
//             ))
//     }

//     #[private]
//     fn check_mint_callback(
//         &self,
//         #[callback_result] balance_0_after_res: Result<U128, PromiseError>,
//         #[callback_result] balance_1_after_res: Result<U128, PromiseError>,
//         balance_0_before: u128,
//         balance_1_before: u128,
//         amount_0: u128,
//         amount_1: u128,
//     ) -> [U128; 2] {
//         if amount_0 > 0 && balance_0_before + amount_0 > balance_0_after_res.unwrap().0 {
//             env::panic_str(INSUFFICIENT_INPUT_AMOUNT)
//         }

//         if amount_1 > 0 && balance_1_before + amount_1 > balance_1_after_res.unwrap().0 {
//             env::panic_str(INSUFFICIENT_INPUT_AMOUNT)
//         }

//         [U128::from(amount_0), U128::from(amount_1)]
//     }

//     #[allow(unused)]
//     #[private]
//     fn swap_callback_post_collected_token(
//         #[callback_result] amount: Result<U128, PromiseError>,
//         zero_for_one: bool,
//     ) {
//         todo!("check input amount is enough or not")
//     }
// }

'''
'''--- zswap-contracts-main/pool/src/core_trait.rs ---
use near_sdk::{ext_contract, json_types::U128, AccountId, PromiseOrValue};

use crate::utils::Slot0;

#[ext_contract(ext_zswap_pool_core)]
pub trait CoreZswapPool {
    fn mint(
        &mut self,
        payer: AccountId,
        recipient: AccountId,
        lower_tick: i32,
        upper_tick: i32,
        amount: U128,
        // data: Vec<u8>,
    ) -> [U128; 2];

    fn swap(
        &mut self,
        recipient: AccountId,
        zero_for_one: bool,
        amount_specified: U128,
        sqrt_price_limit_x96: Option<U128>,
    ) -> PromiseOrValue<U128>;

    fn burn(&mut self, lower_tick: i32, upper_tick: i32, amount: U128) -> [U128; 2];

    fn collect(
        &mut self,
        recipient: AccountId,
        lower_tick: i32,
        upper_tick: i32,
        amount_0_requested: U128,
        amount_1_requested: U128,
    ) -> [U128; 2];

    fn get_slot_0(&self) -> Slot0;
}

'''
'''--- zswap-contracts-main/pool/src/error.rs ---
pub const ALREADY_INITIALIZED: &str = "Already initialized";
pub const INVALID_PRICE_LIMIT: &str = "Invalid price limit";
pub const INVALID_TICK_RANGE: &str = "Invalid tick range";
pub const NOT_ENOUGH_LIQUIDITY: &str = "Not enough liquidity";
pub const ZERO_LIQUIDITY: &str = "Zero liquidity";

pub const INSUFFICIENT_INPUT_AMOUNT: &str = "Insufficient input amount";
pub const NOT_AUTHORIZED: &str = "Not authorized";

// FTReceiver
pub const UNSUPPORTED_TOKEN: &str = "Unsupported token";
pub const WRONG_MSG_FORMAT: &str = "Wrong message format";

'''
'''--- zswap-contracts-main/pool/src/ft_receiver.rs ---
use near_contract_standards::fungible_token::receiver::FungibleTokenReceiver;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, json_types::U128, near_bindgen, serde_json, AccountId, PromiseOrValue};

use crate::error::*;
use crate::{Contract, ContractExt};

/// Message parameters to receive via token function call.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[serde(rename_all = "snake_case")]
pub enum TokenReceiverMessage {
    /// Alternative to deposit + execute actions call.
    Approve { account_id: AccountId },
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        let token_in = &env::predecessor_account_id();
        if msg.is_empty() {
            if token_in == &self.token_0 {
                self.token_0_deposit(&sender_id, amount.into());
            } else if token_in == &self.token_1 {
                self.token_1_deposit(&sender_id, amount.into());
            } else {
                env::panic_str(UNSUPPORTED_TOKEN)
            }
            let unused_amount = U128(0);
            PromiseOrValue::Value(unused_amount)
        } else {
            let message =
                serde_json::from_str::<TokenReceiverMessage>(&msg).expect(WRONG_MSG_FORMAT);
            match message {
                TokenReceiverMessage::Approve { account_id } => {
                    if token_in == &self.token_0 {
                        self.token_0_deposit(&sender_id, amount.into());
                        self.token_0_approve(&sender_id, &account_id);
                    } else if token_in == &self.token_1 {
                        self.token_1_deposit(&sender_id, amount.into());
                        self.token_1_approve(&sender_id, &account_id);
                    } else {
                        env::panic_str(UNSUPPORTED_TOKEN)
                    }

                    let unused_amount = U128(0);
                    PromiseOrValue::Value(unused_amount)
                }
            }
        }
    }
}

impl Contract {
    fn token_0_deposit(&mut self, sender_id: &AccountId, amount: u128) {
        let deposited_token_opt = self.deposited_token_0.get(sender_id);
        match deposited_token_opt {
            Some(deposited) => {
                self.deposited_token_0
                    .insert(sender_id, &(deposited + amount));
            }
            None => {
                self.deposited_token_0.insert(sender_id, &amount);
            }
        }
    }

    fn token_1_deposit(&mut self, sender_id: &AccountId, amount: u128) {
        let deposited_token_opt = self.deposited_token_1.get(sender_id);
        match deposited_token_opt {
            Some(deposited) => {
                self.deposited_token_1
                    .insert(sender_id, &(deposited + amount));
            }
            None => {
                self.deposited_token_1.insert(sender_id, &amount);
            }
        }
    }

    fn token_0_approve(&mut self, owner_id: &AccountId, account_id: &AccountId) {
        self.approved_token_0.insert(owner_id, account_id);
    }

    fn token_1_approve(&mut self, owner_id: &AccountId, account_id: &AccountId) {
        self.approved_token_1.insert(owner_id, account_id);
    }
}

'''
'''--- zswap-contracts-main/pool/src/internal.rs ---
use ethnum::I256;
use near_contract_standards::fungible_token::core::ext_ft_core;
use near_sdk::{env, AccountId, CryptoHash, Promise};
use zswap_math_library::{
    liquidity_math, num256::U256, sqrt_price_math, tick, tick_bitmap::flip_tick, tick_math,
};

use crate::{
    error::{INSUFFICIENT_INPUT_AMOUNT, NOT_AUTHORIZED},
    Contract,
};

impl Contract {
    pub fn get_balance_0_promise(&self) -> Promise {
        ext_ft_core::ext(self.token_0.clone()).ft_balance_of(env::current_account_id())
    }

    pub fn get_balance_1_promise(&self) -> Promise {
        ext_ft_core::ext(self.token_1.clone()).ft_balance_of(env::current_account_id())
    }

    pub fn get_position_key(
        &self,
        owner: &AccountId,
        lower_tick: i32,
        upper_tick: i32,
    ) -> CryptoHash {
        env::keccak256_array(
            [
                owner.as_bytes(),
                &lower_tick.to_le_bytes(),
                &upper_tick.to_le_bytes(),
            ]
            .concat()
            .as_slice(),
        )
    }

    pub fn modify_position(
        &mut self,
        owner: &AccountId,
        lower_tick: i32,
        upper_tick: i32,
        liquidity_delta: i128,
    ) -> [i128; 2] {
        let position_key = self.get_position_key(owner, lower_tick, upper_tick);
        let mut position = self.positions.get(&position_key).unwrap_or_default();

        let current_tick = self.slot_0.tick;
        let fee_growth_global_0_x128 = self.fee_growth_global_0_x128;
        let fee_growth_global_1_x128 = self.fee_growth_global_1_x128;

        let mut lower_tick_info = self.ticks.get(&lower_tick).unwrap_or_default();
        let flipped_lower = lower_tick_info.update(
            lower_tick,
            current_tick,
            liquidity_delta,
            fee_growth_global_0_x128,
            fee_growth_global_1_x128,
            false,
        );
        self.ticks.insert(&lower_tick, &lower_tick_info);

        let mut upper_tick_info = self.ticks.get(&upper_tick).unwrap_or_default();
        let flipped_upper = upper_tick_info.update(
            upper_tick,
            current_tick,
            liquidity_delta,
            fee_growth_global_0_x128,
            fee_growth_global_1_x128,
            true,
        );
        self.ticks.insert(&upper_tick, &upper_tick_info);

        if flipped_lower {
            flip_tick(&mut self.tick_bitmap, lower_tick, self.tick_spacing as i32);
        }

        if flipped_upper {
            flip_tick(&mut self.tick_bitmap, upper_tick, self.tick_spacing as i32);
        }

        let fees_growth_inside_x128 = tick::get_fee_growth_inside(
            lower_tick,
            upper_tick,
            &lower_tick_info,
            &upper_tick_info,
            current_tick,
            fee_growth_global_0_x128,
            fee_growth_global_1_x128,
        );

        position.update(
            liquidity_delta,
            fees_growth_inside_x128[0],
            fees_growth_inside_x128[1],
        );
        self.positions.insert(&position_key, &position);

        let sqrt_current_price = self.slot_0.sqrt_price_x96.0;
        let mut amount_0 = I256::ZERO;
        let mut amount_1 = I256::ZERO;
        if current_tick < lower_tick {
            amount_0 = sqrt_price_math::get_amount_0_delta_signed(
                tick_math::get_sqrt_ratio_at_tick(lower_tick),
                tick_math::get_sqrt_ratio_at_tick(upper_tick),
                liquidity_delta,
            );
        } else if current_tick < upper_tick {
            amount_0 = sqrt_price_math::get_amount_0_delta_signed(
                U256::from(sqrt_current_price),
                tick_math::get_sqrt_ratio_at_tick(upper_tick),
                liquidity_delta,
            );
            amount_1 = sqrt_price_math::get_amount_1_delta_signed(
                tick_math::get_sqrt_ratio_at_tick(lower_tick),
                U256::from(sqrt_current_price),
                liquidity_delta,
            );
            self.liquidity = liquidity_math::add_liquidity(self.liquidity, liquidity_delta);
        } else {
            amount_1 = sqrt_price_math::get_amount_1_delta_signed(
                tick_math::get_sqrt_ratio_at_tick(lower_tick),
                tick_math::get_sqrt_ratio_at_tick(upper_tick),
                liquidity_delta,
            );
        }

        [amount_0.as_i128(), amount_1.as_i128()]
    }

    pub fn internal_collect_token_0_to_mint(
        &mut self,
        owner: &AccountId,
        caller: &AccountId,
        amount: u128,
    ) {
        if owner != caller {
            let approval = self.approved_token_0.get(owner);
            match approval {
                Some(approved) => {
                    if &approved != caller {
                        env::panic_str(NOT_AUTHORIZED);
                    }
                }
                None => {
                    env::panic_str(NOT_AUTHORIZED);
                }
            }
        }

        let deposited_token_opt = self.deposited_token_0.get(owner);
        match deposited_token_opt {
            Some(deposited) => {
                if deposited < amount {
                    env::panic_str(INSUFFICIENT_INPUT_AMOUNT);
                }

                self.deposited_token_0.insert(owner, &(deposited - amount));
            }
            None => {
                env::panic_str(INSUFFICIENT_INPUT_AMOUNT);
            }
        }
    }

    pub fn internal_collect_token_1_to_mint(
        &mut self,
        owner: &AccountId,
        caller: &AccountId,
        amount: u128,
    ) {
        if owner != caller {
            let approval = self.approved_token_1.get(owner);
            match approval {
                Some(approved) => {
                    if &approved != caller {
                        env::panic_str(NOT_AUTHORIZED);
                    }
                }
                None => {
                    env::panic_str(NOT_AUTHORIZED);
                }
            }
        }

        let deposited_token_opt = self.deposited_token_1.get(owner);
        match deposited_token_opt {
            Some(deposited) => {
                if deposited < amount {
                    env::panic_str(INSUFFICIENT_INPUT_AMOUNT);
                }

                self.deposited_token_1.insert(owner, &(deposited - amount));
            }
            None => {
                env::panic_str(INSUFFICIENT_INPUT_AMOUNT);
            }
        }
    }
}

'''
'''--- zswap-contracts-main/pool/src/lib.rs ---
use ethnum::I256;
use near_contract_standards::fungible_token::core::ext_ft_core;
// Find all our documentation at https://docs.near.org
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, log, near_bindgen, AccountId, BorshStorageKey, CryptoHash, PanicOnDefault, PromiseOrValue,
    ONE_YOCTO,
};

use zswap_math_library::full_math::{FullMath, FullMathTrait};
use zswap_math_library::num160::AsU160;
use zswap_math_library::num256::U256;
use zswap_math_library::position::PositionInfo;
use zswap_math_library::tick::TickInfo;
use zswap_math_library::tick_math::TickConstants;
use zswap_math_library::{fixed_point_128, liquidity_math, swap_math, tick_bitmap, tick_math};

use crate::core_trait::CoreZswapPool;
use crate::error::*;
use crate::utils::*;

// mod callback;
pub mod core_trait;
mod error;
pub mod ft_receiver;
mod internal;
mod manager;
pub mod utils;

// Define the contract structure
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    factory: AccountId,
    token_0: AccountId,
    token_1: AccountId,
    deposited_token_0: LookupMap<AccountId, u128>,
    deposited_token_1: LookupMap<AccountId, u128>,
    approved_token_0: LookupMap<AccountId, AccountId>, // improve to use HashMap later
    approved_token_1: LookupMap<AccountId, AccountId>, // improve to use HashMap later

    tick_spacing: u32,
    fee: u32,

    fee_growth_global_0_x128: u128,
    fee_growth_global_1_x128: u128,

    slot_0: Slot0,
    liquidity: u128,

    ticks: LookupMap<i32, TickInfo>,
    tick_bitmap: LookupMap<i16, U256>,
    positions: LookupMap<CryptoHash, PositionInfo>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Pools,
    Accounts,
    FeeToTickSpacing,
    Shares { pool_id: u32 },
    DepositedToken { token_id: AccountId },
    ApprovedToken { token_id: AccountId },
}

#[derive(Deserialize, Serialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct PoolView {
    pub token_0: AccountId,
    pub token_1: AccountId,
    pub fee: u32,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        token_0: AccountId,
        token_1: AccountId,
        tick_spacing: u32,
        fee: u32,
        sqrt_price_x96: U128,
    ) -> Self {
        Self {
            factory: env::predecessor_account_id(),
            token_0: token_0.clone(),
            token_1: token_1.clone(),
            deposited_token_0: LookupMap::new(StorageKey::DepositedToken {
                token_id: token_0.clone(),
            }),
            deposited_token_1: LookupMap::new(StorageKey::DepositedToken {
                token_id: token_1.clone(),
            }),
            approved_token_0: LookupMap::new(StorageKey::ApprovedToken { token_id: token_0 }),
            approved_token_1: LookupMap::new(StorageKey::ApprovedToken { token_id: token_1 }),

            tick_spacing,
            fee,
            fee_growth_global_0_x128: 0,
            fee_growth_global_1_x128: 0,
            slot_0: Slot0 {
                sqrt_price_x96,
                tick: tick_math::get_tick_at_sqrt_ratio(U256::from(sqrt_price_x96.0)),
            },
            liquidity: 0,
            ticks: LookupMap::new(StorageKey::Pools),
            tick_bitmap: LookupMap::new(StorageKey::Pools),
            positions: LookupMap::new(StorageKey::Pools),
        }
    }

    #[payable]
    pub fn initialize(&mut self, sqrt_price_x96: U128) {
        if self.slot_0.sqrt_price_x96.0 != 0 {
            env::panic_str(ALREADY_INITIALIZED);
        }
        let tick = tick_math::get_tick_at_sqrt_ratio(U256::from(sqrt_price_x96.0));

        self.slot_0 = Slot0 {
            sqrt_price_x96,
            tick,
        };
    }
}

// Implement the contract structure
#[near_bindgen]
impl CoreZswapPool for Contract {
    /// Mint liquidity for the given account
    ///
    /// Note: This function is not called by user directly, but by ZswapManager
    #[payable]
    fn mint(
        &mut self,
        payer: AccountId,
        recipient: AccountId,
        lower_tick: i32,
        upper_tick: i32,
        amount: U128,
    ) -> [U128; 2] {
        if lower_tick >= upper_tick
            || lower_tick < TickConstants::MIN_TICK
            || upper_tick > TickConstants::MAX_TICK
        {
            env::panic_str(INVALID_TICK_RANGE);
        }

        if amount.0 == 0 {
            env::panic_str(ZERO_LIQUIDITY);
        }
        let amounts = self.modify_position(&recipient, lower_tick, upper_tick, amount.0 as i128);
        let amount_0 = amounts[0] as u128;
        let amount_1 = amounts[1] as u128;
        log!("Used amount_0: {}", amount_0);
        log!("Used amount_1: {}", amount_1);

        if amount_0 > 0 {
            self.internal_collect_token_0_to_mint(&payer, &env::predecessor_account_id(), amount_0);
        }

        if amount_1 > 0 {
            self.internal_collect_token_1_to_mint(&payer, &env::predecessor_account_id(), amount_1);
        }

        [U128::from(amount_0), U128::from(amount_1)]
    }

    #[payable]
    fn swap(
        &mut self,
        recipient: AccountId,
        zero_for_one: bool,
        amount_specified: U128,
        sqrt_price_limit_x96: Option<U128>,
    ) -> PromiseOrValue<U128> {
        let sqrt_price_limit_x96 = match sqrt_price_limit_x96 {
            Some(sqrt_price_limit) => {
                if zero_for_one && (sqrt_price_limit.0 > self.slot_0.sqrt_price_x96.0) {
                    env::panic_str(INVALID_PRICE_LIMIT);
                }

                if !zero_for_one && (sqrt_price_limit.0 < self.slot_0.sqrt_price_x96.0) {
                    env::panic_str(INVALID_PRICE_LIMIT);
                }

                U256::from(sqrt_price_limit.0).as_u160()
            }
            None => {
                if zero_for_one {
                    TickConstants::min_sqrt_ratio()
                } else {
                    TickConstants::max_sqrt_ratio()
                }
            }
        };

        let mut state = SwapState {
            amount_specified_remaining: amount_specified.0,
            amount_calculated: 0,
            sqrt_price_x96: self.slot_0.sqrt_price_x96.0,
            tick: self.slot_0.tick,
            fee_growth_global_x128: if zero_for_one {
                self.fee_growth_global_0_x128
            } else {
                self.fee_growth_global_1_x128
            },
            liquidity: self.liquidity,
        };

        while state.amount_specified_remaining > 0
            && state.sqrt_price_x96 != sqrt_price_limit_x96.as_u128()
        {
            let mut step = StepState::default();

            (step.next_tick, _) = tick_bitmap::next_initialized_tick_within_one_word(
                &self.tick_bitmap,
                state.tick,
                self.tick_spacing as i32,
                zero_for_one,
            );

            step.sqrt_price_start_x96 = state.sqrt_price_x96;
            step.sqrt_price_next_x96 = tick_math::get_sqrt_ratio_at_tick(step.next_tick).as_u128();

            let sqrt_target_price_x96 = if (zero_for_one
                && step.sqrt_price_next_x96 < sqrt_price_limit_x96.as_u128())
                || (!zero_for_one && step.sqrt_price_next_x96 > sqrt_price_limit_x96.as_u128())
            {
                sqrt_price_limit_x96
            } else {
                U256::from(step.sqrt_price_next_x96).as_u160()
            };

            let (sqrt_price_x96, amount_in, amount_out, fee_amount) = swap_math::compute_swap_step(
                U256::from(state.sqrt_price_x96),
                sqrt_target_price_x96,
                state.liquidity,
                I256::from(state.amount_specified_remaining),
                self.fee,
            );

            (
                state.sqrt_price_x96,
                step.amount_in,
                step.amount_out,
                step.fee_amount,
            ) = (
                sqrt_price_x96.as_u128(),
                amount_in.as_u128(),
                amount_out.as_u128(),
                fee_amount.as_u128(),
            );

            state.amount_specified_remaining -= step.amount_in + step.fee_amount;
            state.amount_calculated += step.amount_out;

            if state.liquidity > 0 {
                state.fee_growth_global_x128 += FullMath::mul_div(
                    U256::from(step.fee_amount),
                    fixed_point_128::get_q128(),
                    U256::from(state.liquidity),
                )
                .as_u128();
            }

            if state.sqrt_price_x96 == step.sqrt_price_next_x96 {
                let mut tick = self.ticks.get(&step.next_tick).unwrap_or_default();

                let fee_growth_global_0_x128 = if zero_for_one {
                    state.fee_growth_global_x128
                } else {
                    self.fee_growth_global_0_x128
                };

                let fee_growth_global_1_x128 = if zero_for_one {
                    self.fee_growth_global_1_x128
                } else {
                    state.fee_growth_global_x128
                };

                let mut liquidity_delta =
                    tick.cross(fee_growth_global_0_x128, fee_growth_global_1_x128);
                self.ticks.insert(&step.next_tick, &tick);

                if zero_for_one {
                    liquidity_delta = -liquidity_delta;
                }

                state.liquidity = liquidity_math::add_delta(state.liquidity, liquidity_delta);

                if state.liquidity == 0 {
                    env::panic_str(NOT_ENOUGH_LIQUIDITY)
                }

                state.tick = if zero_for_one {
                    step.next_tick - 1
                } else {
                    step.next_tick
                }
            } else if state.sqrt_price_x96 != step.sqrt_price_next_x96 {
                state.tick = tick_math::get_tick_at_sqrt_ratio(U256::from(state.sqrt_price_x96));
            }
        }

        if state.tick != self.slot_0.tick {
            self.slot_0.sqrt_price_x96 = U128::from(state.sqrt_price_x96);
            self.slot_0.tick = state.tick;
        } else {
            self.slot_0.sqrt_price_x96 = U128::from(state.sqrt_price_x96);
        }

        if self.liquidity != state.liquidity {
            self.liquidity = state.liquidity;
        }

        if zero_for_one {
            self.fee_growth_global_0_x128 = state.fee_growth_global_x128;
        } else {
            self.fee_growth_global_1_x128 = state.fee_growth_global_x128;
        }

        let amount_in = amount_specified.0 - state.amount_specified_remaining;
        let amount_out = state.amount_calculated;
        let caller = env::predecessor_account_id();

        if zero_for_one {
            let deposited_token_0 = self.deposited_token_0.get(&caller).unwrap_or_default();
            if deposited_token_0 < amount_in {
                env::panic_str(INSUFFICIENT_INPUT_AMOUNT);
            }
            self.deposited_token_0
                .insert(&caller, &(deposited_token_0 - amount_in));

            ext_ft_core::ext(self.token_1.clone())
                .with_attached_deposit(ONE_YOCTO)
                .ft_transfer(recipient, U128::from(amount_out), None);
        } else {
            let deposited_token_1 = self.deposited_token_1.get(&caller).unwrap_or_default();
            if deposited_token_1 < amount_in {
                env::panic_str(INSUFFICIENT_INPUT_AMOUNT);
            }
            self.deposited_token_1
                .insert(&caller, &(deposited_token_1 - amount_in));

            ext_ft_core::ext(self.token_0.clone())
                .with_attached_deposit(ONE_YOCTO)
                .ft_transfer(recipient, U128::from(amount_out), None);
        }

        PromiseOrValue::Value(U128::from(amount_out))
    }

    #[payable]
    fn burn(&mut self, lower_tick: i32, upper_tick: i32, amount: U128) -> [U128; 2] {
        if lower_tick >= upper_tick
            || lower_tick < TickConstants::MIN_TICK
            || upper_tick > TickConstants::MAX_TICK
        {
            env::panic_str(INVALID_TICK_RANGE);
        }

        if amount.0 == 0 {
            env::panic_str(ZERO_LIQUIDITY);
        }

        let owner = env::predecessor_account_id();
        let amounts = self.modify_position(&owner, lower_tick, upper_tick, -(amount.0 as i128));
        let amount_0 = amounts[0].unsigned_abs();
        let amount_1 = amounts[1].unsigned_abs();

        if amount_0 > 0 || amount_1 > 0 {
            let position_key = self.get_position_key(&owner, lower_tick, upper_tick);
            let mut position = self.positions.get(&position_key).unwrap();
            position.tokens_owed_0 += amount_0;
            position.tokens_owed_1 += amount_1;

            self.positions.insert(&position_key, &position);
        }

        [U128::from(amount_0), U128::from(amount_1)]
    }

    #[payable]
    fn collect(
        &mut self,
        recipient: AccountId,
        lower_tick: i32,
        upper_tick: i32,
        amount_0_requested: U128,
        amount_1_requested: U128,
    ) -> [U128; 2] {
        if lower_tick >= upper_tick
            || lower_tick < TickConstants::MIN_TICK
            || upper_tick > TickConstants::MAX_TICK
        {
            env::panic_str(INVALID_TICK_RANGE);
        }

        let owner = env::predecessor_account_id();
        let position_key = self.get_position_key(&owner, lower_tick, upper_tick);
        let mut position = self.positions.get(&position_key).unwrap();

        let amount_0 = position.tokens_owed_0.min(amount_0_requested.0);
        let amount_1 = position.tokens_owed_1.min(amount_1_requested.0);

        log!("Collected amount 0: {}", amount_0);
        log!("Collected amount 1: {}", amount_1);

        if amount_0 > 0 {
            position.tokens_owed_0 -= amount_0;
            ext_ft_core::ext(self.token_0.clone())
                .with_attached_deposit(ONE_YOCTO)
                .ft_transfer(recipient.clone(), amount_0.into(), None);
        }

        if amount_1 > 0 {
            position.tokens_owed_1 -= amount_1;
            ext_ft_core::ext(self.token_1.clone())
                .with_attached_deposit(ONE_YOCTO)
                .ft_transfer(recipient, amount_1.into(), None);
        }

        self.positions.insert(&position_key, &position);

        [U128::from(amount_0), U128::from(amount_1)]
    }

    fn get_slot_0(&self) -> Slot0 {
        self.slot_0.clone()
    }
}

/*
 * The rest of this file holds the inline tests for the code above
 * Learn more about Rust tests: https://doc.rust-lang.org/book/ch11-01-writing-tests.html
 */
#[cfg(test)]
mod tests {}

'''
'''--- zswap-contracts-main/pool/src/manager.rs ---
use near_sdk::{ext_contract, json_types::U128, Promise};

#[ext_contract(ext_ft_zswap_manager)]
pub trait FtZswapManager {
    fn collect_approved_tokens_to_mint(amount_0: U128, amount_1: U128, data: Vec<u8>) -> Promise;
    fn collect_approved_tokens_to_swap(amount_0: U128, amount_1: U128, data: Vec<u8>);
}

'''
'''--- zswap-contracts-main/pool/src/utils.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};

// First slot will contain essential data
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct Slot0 {
    // Current sqrt(P)
    pub sqrt_price_x96: U128,
    // Current tick
    pub tick: i32,
}

pub struct SwapState {
    pub amount_specified_remaining: u128,
    pub amount_calculated: u128,
    pub sqrt_price_x96: u128,
    pub tick: i32,
    pub fee_growth_global_x128: u128,
    pub liquidity: u128,
}

#[derive(Default)]
pub struct StepState {
    pub sqrt_price_start_x96: u128,
    pub next_tick: i32,
    pub initialized: bool,
    pub sqrt_price_next_x96: u128,
    pub amount_in: u128,
    pub amount_out: u128,
    pub fee_amount: u128,
}

'''
'''--- zswap-contracts-main/rust-toolchain.toml ---
[toolchain]
channel = "1.69"

'''
'''--- zswap-contracts-main/scripts/update.sh ---
#!/bin/sh

ZSWAP=zswap.testnet
MANAGER=manager.zswap.testnet
FACTORY=factory2.zswap.testnet
POOL="2e4e39194a383739.factory2.zswap.testnet"
ZNEAR=znear.zswap.testnet
ZUSD=zusd.zswap.testnet
POOL_FEE=3000

# ===== UPDATE POOL =====
# 1. Delete old pool account
echo -e "\nDeleting old pool account..."
near delete $POOL $FACTORY

# 2. Re-create pool account
echo -e "\nRe-create pool account..."
near create-account 2e4e39194a383739.factory2.zswap.testnet --masterAccount $FACTORY --initialBalance 50

3. Deploy pool contract
echo -e "\nDeploying pool contract..."
near deploy --wasmFile ../res/zswap_pool.wasm --accountId $POOL

# 4. Initialize pool contract
echo -e "\nInitializing pool contract..."
near call $POOL new '{"token_0":"'$ZNEAR'","token_1":"'$ZUSD'","fee":'$POOL_FEE',"tick_spacing":60}' --accountId $POOL --gas 300000000000000

# NEAR/ZUSD = 100, tick ~ 46054
near call $POOL initialize '{"sqrt_price_x96":"792281625142643375935439503360"}' --accountId $ZSWAP

# 5. Add liquidity to pool
ZNEAR_AMOUNT=1000
ZUSD_AMOUNT=100000
echo -e "\nAdding liquidity to pool..."

near call $ZNEAR ft_transfer_call '{"receiver_id":"'$POOL'", "amount":"'$ZNEAR_AMOUNT'", "msg":""}' --depositYocto 1 --gas 300000000000000 --accountId $ZSWAP
near call $ZUSD ft_transfer_call '{"receiver_id":"'$POOL'", "amount":"'$ZUSD_AMOUNT'", "msg":""}' --depositYocto 1 --gas 300000000000000 --accountId $ZSWAP

near call $MANAGER mint '{"params":{"token_0":"'$ZNEAR'","token_1":"'$ZUSD'","fee":'$POOL_FEE',"lower_tick":42000,"upper_tick":48000, "amount_0_desired":"'$ZNEAR_AMOUNT'","amount_1_desired":"'$ZUSD_AMOUNT'","amount_0_min":"100","amount_1_min":"100"}}' --gas 300000000000000 --accountId $ZSWAP --deposit 0.1
'''
'''--- zswap-contracts-main/scripts/update3.sh ---
#!/bin/sh

ZSWAP=zswap.testnet
MANAGER=manager3.zswap.testnet
FACTORY=factory3.zswap.testnet
POOL="2e4e39194a383739.factory3.zswap.testnet"
ZNEAR=znear.zswap.testnet
ZUSD=zusd.zswap.testnet
POOL_FEE=3000
MAX_GAS=300000000000000

# ===== UPDATE FACTORY =====
# 1. Delete pool code in factory
echo ""
echo "Deleting pool code in factory..."
near call $FACTORY remove_stored_contract '{}' --accountId $FACTORY --gas $MAX_GAS

# 2. Delete old factory
echo ""
echo "Deleting old factory..."
near delete $FACTORY $ZSWAP

# 3. Re-create factory
echo ""
echo "Creating factory account again..."
near create-account $FACTORY --masterAccount $ZSWAP --initialBalance 120

# 4. Deploy & Init factory contract
echo "Deploying & Initializing factory contract..."
near deploy --wasmFile ./res/zswap_factory.wasm --accountId $FACTORY --initFunction new --initArgs '{}' --initGas $MAX_GAS

# ===== DELETE POOL =====
# 1. Delete old pool account
echo ""
echo "Deleting old pool account..."
near delete $POOL $FACTORY

# ===== UPDATE MANAGER =====
# 1. Delete old manager
echo ""
echo "Deleting old manager..."
near delete $MANAGER $ZSWAP

# 2. Re-create manager
echo ""
echo "Creating manager account again..."
near create-account $MANAGER --masterAccount $ZSWAP --initialBalance 120

# 3. Deploy & Init manager contract
echo ""
echo "Deploying & Initializing manager contract..."
near deploy --wasmFile ./res/zswap_manager.wasm --accountId $MANAGER --initFunction new --initArgs '{"factory":"'$FACTORY'"}' --initGas $MAX_GAS

# 4. Re-create pool
echo ""
echo "Re-creating pool..."
near call $MANAGER create_pool '{"token_0":"'$ZNEAR'","token_1":"'$ZUSD'","fee":'$POOL_FEE',"sqrt_price_x96":"792281625142643375935439503360"}' --accountId $ZSWAP --gas $MAX_GAS --deposit 25

'''
'''--- zswap-frontend-bos-main/README.md ---
# ZSwap BOS Frontend Components 

[ZSwap Protocol](https://ZSwapprotocol.org/) is a liquid staking solution built on the NEAR Protocol. ZSwap unlocks liquidity of the staked NEAR by creating a staking derivative to be engaged with various DeFi protocols on NEAR and Aurora, while also enjoying over 10% APY staking rewards of the underlying base tokens. ZSwap is the cornerstone piece of the NEAR-Aurora DeFi ecosystem.

This repository holds [ZSwap BOS components](https://near.org/ZSwapprotocol.near/widget/ZSwap) hosted on NEAR BOS (Blockchain Operating System), to interact with [ZSwap smart contract](https://github.com/ZSwap-protocol/ZSwap).

## Setup Local Environment

We use [BOS Loader](https://docs.near.org/bos/dev/bos-loader) to enable instant preview in local environment, so you don't have to deploy all your components to mainnet to preview and test your changes.

1. [Download and install BOS Loader](https://github.com/near/bos-loader/releases)

- Linux / Mac: Install prebuilt binaries via shell script

```bash
curl --proto '=https' --tlsv1.2 -LsSf https://github.com/mpeterdev/bos-loader/releases/download/v0.6.0/bos-loader-v0.6.0-installer.sh | sh
```

2. Open https://test.near.org/flags, and set the loader URL to 
```bash
http://127.0.0.1:3030
```
3. Clone repository: 
```bash
git clone git@github.com:DV-Lab/zswap-frontend-bos.git
```
4. Install and run
```bash
yarn install
```

```bash
yarn dev
```
5. Launch testnet [preview page](https://test.near.org/zswap.testnet/widget/ZSwap)
6. Modify ZSwap components code, and refresh preview page to view the latest change. Please notice that because **hot reload** is not ready in BOS loader, you need to refresh the preview page in browser after code change.

7. [`prettier`](https://prettier.io/) is configured in Git pre-commit hook with [husky](https://github.com/typicode/husky) and [lint-staged](https://github.com/okonet/lint-staged) to automatically format the modified components code.

## Folder Structure

The source code of ZSwap components are available in the `src` folder, and organized by sub-folders. For example, the `ZSwapprotocol.near/widget/ZSwap.Element.Button` component is available in `src/ZSwap/Element/Button.jsx`. BOS Loader and BOS CLI both use `.` delimiter when converting local file path to component name, and vice versa.

## Continuous Integration & Delivery

We use [BOS CLI](https://github.com/FroVolod/bos-cli-rs) and its [GitHub actions](https://github.com/FroVolod/bos-cli-rs/tree/master/.github/workflows) for continuous integration and delivery.

1. We have set up one [testnet GitHub action](https://github.com/DV-Lab/zswap-frontend-bos/blob/main/.github/workflows/testnet-preview.yml) to deploy latest commit in pull request to testnet for preview and testing once the PR is submitted. (However, since now we have only configured on `TESTNET_DEPLOY_ACCOUNT`, if you have multiple open PRs, they may conflict with each other. This will be fixed later.)
2. We have another [mainnet GitHub action](https://github.com/DV-Lab/zswap-frontend-bos/blob/main/.github/workflows/mainnet-release.yml) to deploy the latest `main branch` components code to mainnet.

To make the CI workflow work, we need to create function call keys for testnet and mainnet deployment, following the instructions in [BOS CLI](https://github.com/FroVolod/bos-cli-rs), and set up below GitHub actions [variables and secrets](https://docs.github.com/en/actions/learn-github-actions/variables#creating-configuration-variables-for-a-repository).

- `TESTNET_DEPLOY_ACCOUNT` / `TESTNET_SIGNER_PUBLIC_KEY` / `TESTNET_SIGNER_PRIVATE_KEY`
- `MAINNET_DEPLOY_ACCOUNT` / `MAINNET_SIGNER_PUBLIC_KEY` / `MAINNET_SIGNER_PRIVATE_KEY`

## Testing

1. We recommend testing locally with BOS Loader first, before submit pull request for code review and testnet testing.
2. Once a PR is submitted, it will be automatically deployed to testnet, which makes it easy for others to test and provide feedback.
3. Only after a PR is well tested and reviewed, it will be merged and the latest `main branch` commit will be deployed to mainnet.

## License

MIT License

'''
'''--- zswap-frontend-bos-main/package.json ---
{
  "name": "zswap-bos-components",
  "version": "0.0.1",
  "description": "ZSwap BOS Components",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "prepare": "husky install",
    "start:testnet": "ZSWAP_BOS_URL=https://test.near.org/zswap.testnet/widget/ZSwap && open $ZSWAP_BOS_URL && echo \"Preview at: $ZSWAP_BOS_URL\"",
    "dev": "yarn start:testnet && bos-loader zswap.testnet --path src"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/DV-Lab/zswap-frontend-bos.git"
  },
  "keywords": [
    "zswap",
    "bos",
    "component"
  ],
  "author": "ZSwap Protocol",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/DV-Lab/zswap-frontend-bos/issues"
  },
  "homepage": "https://github.com/DV-Lab/zswap-frontend-bos#readme",
  "engines": {
    "node": ">=14"
  },
  "prettier": {
    "printWidth": 80,
    "semi": true,
    "singleQuote": false,
    "trailingComma": "es5"
  },
  "devDependencies": {
    "husky": "^8.0.3",
    "lint-staged": "^13.2.2",
    "prettier": "^3.0.2"
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap.metadata.json ---
{
  "description": "ZSwap Protocol is a decentralized exchange solution built on the NEAR Protocol.",
  "image": {
    "ipfs_cid": "bafkreigio67zz63ozsrtl2ydvczmbsx2dgblv2rqzxrizry7zycs3yco7q"
  },
  "name": "ZSwap -- Decentralized exchange on NEAR Protocol",
  "tags": {
    "defi": "",
    "near": "",
    "liquid": "",
    "staking": "",
    "app": "",
    "zswap": ""
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap/Element/Button.metadata.json ---
{
  "description": "ZSwap Button",
  "image": {
    "ipfs_cid": "bafkreihszlp5bu7xe3pwn4x3xmhazcxjxo4d5gsnhr2a4kthnzn6fzhn5i"
  },
  "name": "Button | ZSwap",
  "tags": {
    "zswap": "",
    "widget": "",
    "component": "",
    "button": ""
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap/Element/CustomSelect.metadata.json ---
{
  "description": "ZSwap Select",
  "name": "Custom Select | ZSwap",
  "tags": {
    "zswap": "",
    "widget": "",
    "component": "",
    "button": ""
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap/Element/Input.metadata.json ---
{
  "description": "ZSwap Input",
  "image": {
    "ipfs_cid": "bafkreihszlp5bu7xe3pwn4x3xmhazcxjxo4d5gsnhr2a4kthnzn6fzhn5i"
  },
  "name": "Input | ZSwap",
  "tags": {
    "zswap": "",
    "widget": "",
    "component": "",
    "input": ""
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap/Element/TitleAndDescription.metadata.json ---
{
  "description": "ZSwap Title and Description",
  "image": {
    "ipfs_cid": "bafkreihszlp5bu7xe3pwn4x3xmhazcxjxo4d5gsnhr2a4kthnzn6fzhn5i"
  },
  "name": "Title & Description | ZSwap",
  "tags": {
    "zswap": "",
    "widget": "",
    "component": "",
    "title": "",
    "description": ""
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap/Element/Tooltip.metadata.json ---
{
  "description": "ZSwap Tooltip",
  "image": {
    "ipfs_cid": "bafkreihszlp5bu7xe3pwn4x3xmhazcxjxo4d5gsnhr2a4kthnzn6fzhn5i"
  },
  "name": "Tooltip | ZSwap",
  "tags": {
    "zswap": "",
    "widget": "",
    "component": "",
    "tooltip": ""
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap/Layout/Navigation.metadata.json ---
{
  "description": "ZSwap Navigation",
  "image": {
    "ipfs_cid": "bafkreihszlp5bu7xe3pwn4x3xmhazcxjxo4d5gsnhr2a4kthnzn6fzhn5i"
  },
  "name": "Navigation | ZSwap",
  "tags": {
    "zswap": "",
    "widget": "",
    "component": "",
    "navigation": ""
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap/Page/NFTs/NFTs.metadata.json ---
{
  "description": "NFTs",
  "name": "NFTs Component | ZSwap",
  "tags": {
    "defi": "",
    "zswap": "",
    "widget": "",
    "component": "",
    "data": ""
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap/Page/Pools/Pools.metadata.json ---
{
  "description": "Pools",
  "name": "Pools Component | ZSwap",
  "tags": {
    "defi": "",
    "zswap": "",
    "widget": "",
    "component": "",
    "data": ""
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap/Page/Swap/MainSwap.metadata.json ---
{
  "description": "ZSwap Swap Component",
  "name": "Swap | ZSwap",
  "tags": {
    "zswap": "",
    "widget": "",
    "component": "",
    "stake": ""
  }
}

'''
'''--- zswap-frontend-bos-main/src/ZSwap/Page/Tokens/Tokens.json ---
{
  "description": "Account",
  "image": {
    "ipfs_cid": "bafkreihszlp5bu7xe3pwn4x3xmhazcxjxo4d5gsnhr2a4kthnzn6fzhn5i"
  },
  "name": "Account Component | ZSwap",
  "tags": {
    "defi": "",
    "zswap": "",
    "widget": "",
    "component": "",
    "data": ""
  }
}

'''