*GitHub Repository "izrake/PWPEvents"*

'''--- README-Gitpod.md ---
Guest Book - Gitpod version
===========================

Sign in with [NEAR] and add a message to the guest book! A starter app built with an [AssemblyScript] backend and a [React] frontend.

This README is specific to Gitpod and this example. For local development, please see [README.md](README.md).

Exploring The Code
==================

1. The backend code lives in the `/assembly` folder. This code gets deployed to
   the NEAR blockchain when you run `yarn deploy:contract`. This sort of
   code-that-runs-on-a-blockchain is called a "smart contract" – [learn more
   about NEAR smart contracts][smart contract docs].
2. The frontend code lives in the `/src` folder.
   [/src/index.html](/src/index.html) is a great place to start exploring. Note
   that it loads in `/src/index.js`, where you can learn how the frontend
   connects to the NEAR blockchain.
3. Tests: there are different kinds of tests for the frontend and backend. The
   backend code gets tested with the [asp] command for running the backend
   AssemblyScript tests, and [jest] for running frontend tests. You can run
   both of these at once with `yarn test`.

Both contract and client-side code will auto-reload as you change source files.

Using
======

Gitpod has taken care of installing all the necessary tools and dependencies. At the bottom of Gitpod is a terminal which will display a link to follow:

    Server running at http://localhost:1234

A small dialog appears showing options similar to this:

![A Gitpod dialog box saying 'A service is available on port 1234' and giving options to 'Open Preview' or 'Open Browser'](assets/gitpod-port-1234.jpg)

The "Open Preview" option will open the site in a tab within the IDE. Note that Gitpod may need a little time to spin up the website. It's possible this step might require reloading after a brief pause.

The "Open Browser" option will open a new tab in your browser. Either option will work and is up to your preference.

Once you've opened the web app in your browser, log in and experiment with the simple "guest book" smart contract. Note that there are two buttons, "Save" and "Save & Donate" here. 

The "Save" button sends the text input to the blockchain, storing it as a string. The web app will reload with the new guest book messages automatically.

The "Save & Donate" button demonstrates attaching NEAR and a gas price when calling the smart contract's method `addMessage`. When the web app refreshes with "paid" messages, the user interface highlights them.

  [smart contract docs]: https://docs.nearprotocol.com/docs/roles/developer/contracts/assemblyscript
  [asp]: https://www.npmjs.com/package/@as-pect/cli
  [jest]: https://jestjs.io/
  [NEAR]: https://nearprotocol.com/
  [AssemblyScript]: https://docs.assemblyscript.org/
  [React]: https://reactjs.org

'''
'''--- README.md ---
<p align="center">
	<img src="https://github.com/izrake/PWPEvents/blob/master/screenshots/banner.png" alt="weve showcase">
</p>

# PWPEvents

Provide single platform for protest organizers to create events and allow others to join the event without publishing the location.

## Why PWPEvents?

It's always a challenge for the protest organizers to track how many people are willing to participate in the protest.
There are several scenarios in which general public don’t feel the same way as protest organizers, that can lead to very less participation once protest starts at some specific location.
PWPEvents will help protest organizers to test their protest purpose with general public.
PWPEvents will also help organizers to view the number of subscriber to the event.

## What are we protecting?

We are protecting the events location or protest location. If people are really interested in the cause it doesn’t matter how far the event is happening people will try to reach the location if it is within certain range.
PWPEvents will ensure to show event locations only those who have subscribed to the event once a specified quorum is reached as specified by the organizer.

## Tech Stack Under the Hood

### Near Protocol & Nucypher & Flask API & ReactJs

PWPEvents is using Near Protocol for user verification, smart contract and data persistent <br>
Nucypher to encrypt, store location data, policy assignment and decrypting data <br>
Flask API to enable communication between React Web App and Nucypher node

## PWPEvents 50000 ft Bird Eye View

![](assets/ss1.png)
<br>
![](assets/saveevntflow.png)
<br>
![](assets/retrieveeventflow.png)

## Steps to get started with PWPEvents

- Clone PWPEvents repository in the local machine
- Install [Python](%28https://docs.python-guide.org/starting/install3/osx/%29) in local machine
- Install [pipenv](https://pipenv-fork.readthedocs.io/en/latest/install.html)
  Once installation is completed it's time to create python virtual environment for flask api to start working

#### Follow these steps to activate virtual environment

- Activate virual environment by executing `pipenv shell` from the apiflask root folder
- Once activation is done run `pip install -e .` from the root apiflask app

#### Configure Flask APP

- It's time to export variables to make flask api up and running
- Run `export FLASK_APP=zkdonation.py`
- Run `export FLASK_ENV=development`
  Before running flask app, make sure ursula is up and running at localhost port `10151`

### Setup Ursula

- Clone [nucypher](https://github.com/nucypher/nucypher) code repo
- Activate virtual environment from nucypher root folder
- Run ursula by running `nucypher ursula run --dev --federated-only`
- If command fails then install nucypher by running `pip install nucypher`
- Re-run step 3 command
- Once command executed successfully ursula will be running on port `10151`

#### Run Flask App

- Run flask app by running `flask run`
- Flask API will start running on port `5000`
  Once Flask API and Ursula starts running, it's time to run our UI

#### Run React App

- Navigate to PWPEvents root folder
- Open command line or terminal
- Run `yarn`
- Run `yarn dev:start`
- React app will start on localhost port `1234`

## Test it by yourself

Note: Our server running cost is much so we have decided to run the server for the specific timings
If you need server up ping either @rekpero#3898 or @prashantmaurya#6839
[PWPEvents](pwpevents.centralus.cloudapp.azure.com) website http://pwpevents.centralus.cloudapp.azure.com/

## Meet PWPEvents

[https://www.loom.com/share/62970bc5955f49e78f40122401c8373a)](https://www.loom.com/share/62970bc5955f49e78f40122401c8373a)

## Special Thanks

IlliaAtNear and Mike Purvis for extending their helping hands when we ran into multiple NEAR protocol issue.
Kprasch and maclane for making sure all active query resolution on the nucypher discord groups

'''
'''--- apiflask/requirements.txt ---
click==7.1.2
Flask==1.1.2
itsdangerous== 2.0.0a1
Jinja2==3.0.0a1
MarkupSafe==2.0.0a1
Werkzeug==1.0.1

'''
'''--- apiflask/setup.py ---
from setuptools import find_packages, setup

setup(
    name='flaskr',
    version='1.0.0',
    packages=find_packages(),
    include_package_data=True,
    zip_safe=False,
    install_requires=[
        'flask',
        'nucypher',
        'flask_cors'
    ],
)
'''
'''--- apiflask/utils.py ---
import json
import os
import shutil

from flask import make_response
from functools import wraps, update_wrapper
from datetime import datetime

from nucypher.characters.lawful import Ursula
from nucypher.config.characters import AliceConfiguration
from nucypher.config.constants import TEMPORARY_DOMAIN
from umbral.keys import UmbralPrivateKey

SEEDNODE_URI = "127.0.0.1:10151"
def nocache(view):
    @wraps(view)
    def no_cache(*args, **kwargs):
        response = make_response(view(*args, **kwargs))
        response.headers['Last-Modified'] = datetime.now()
        response.headers['Cache-Control'] = 'no-store, no-cache, must-revalidate, post-check=0, pre-check=0, max-age=0'
        response.headers['Pragma'] = 'no-cache'
        response.headers['Expires'] = '-1'
        return response

    return update_wrapper(no_cache, view)

def createGenericAlicia(passphrase):
    print('createGenericAlicia')
    TEMP_ALICE_DIR = os.path.join('/', 'tmp', 'zkDonationFlaskApp')
    shutil.rmtree(TEMP_ALICE_DIR, ignore_errors=True)

    ursula = Ursula.from_seed_and_stake_info(seed_uri=SEEDNODE_URI,
                                             federated_only=True,
                                             minimum_stake=0)

    alice_config = AliceConfiguration(
        config_root=os.path.join(TEMP_ALICE_DIR),
        domains={TEMPORARY_DOMAIN},
        known_nodes={ursula},
        start_learning_now=False,
        federated_only=True,
        learn_on_same_thread=True,
    )

    alice_config.initialize(password=passphrase)

    alice_config.keyring.unlock(password=passphrase)
    alicia = alice_config.produce()

    alice_config.to_configuration_file()

    alicia.start_learning_loop(now=True)

    return alicia

def generate_subscribers_keys(uuid):
    enc_privkey = UmbralPrivateKey.gen_key()
    sig_privkey = UmbralPrivateKey.gen_key()

    subscriberPrivateKey = f"{uuid}.private.json"

    subscriberPublicKey  = f"{uuid}.public.json"
    subscriber_privkeys = {
        'enc': enc_privkey.to_bytes().hex(),
        'sig': sig_privkey.to_bytes().hex(),
    }

    enc_pubkey = enc_privkey.get_pubkey()
    sig_pubkey = sig_privkey.get_pubkey()
    subscriber_pubkeys = {
        'enc': enc_pubkey.to_bytes().hex(),
        'sig': sig_pubkey.to_bytes().hex()
    }
    return subscriber_pubkeys,subscriber_privkeys
'''
'''--- apiflask/zkdonation.py ---
import datetime
import json
import os
import shutil
import time
import traceback

import maya
import msgpack
from flask import Flask, jsonify, make_response, request
from nucypher.characters.lawful import Ursula, Enrico, Bob
from nucypher.config.characters import AliceConfiguration
from nucypher.config.constants import TEMPORARY_DOMAIN
from nucypher.crypto.kits import UmbralMessageKit
from nucypher.crypto.powers import DecryptingPower, SigningPower
from nucypher.datastore.keypairs import DecryptingKeypair, SigningKeypair
from nucypher.network.middleware import RestMiddleware
from umbral.keys import UmbralPublicKey, UmbralPrivateKey
from flask_cors import CORS, cross_origin

from utils import nocache, createGenericAlicia, generate_subscribers_keys

app = Flask(__name__)
CORS(app)

@ app.route("/")
def welcome():
    return "welcome to zkDonation"

@app.route("/api/encrypt/", methods=["POST"])
@nocache
def encrypt_location():
    req = request.get_json()
    print(req)
    print("i am from encryption data")
    createAliciaAndEncrypt(req["event_uuid"], req["data_enc"], req["sender"])

    return make_response(req)

@app.route("/api/generate_keys/", methods=["POST"])
def generate_keys():
    req = request.get_json()
    sub_pub, sub_pvt = generate_subscribers_keys(req["user_uuid"])
    print("i am going to generate key for")
    jsonData = {
        "pub": sub_pub,
        "pvt": sub_pvt
    }
    return make_response(jsonData)

@app.route("/api/assign_policy/", methods=["POST"])
def assign_policy():
    req = request.get_json()
    res = assignPolicyToSubscriber(req["subscriber"], req["sub_uuid"],
                                   req["event_uuid"], req["public_key_user"], req["public_sign_user"])
    return make_response(res)

@app.route("/api/decrypt_data/", methods=["POST"])
def decrypt_data():
    req = request.get_json()
    text = createBobToResolveData(req["sub_uuid"], req["subscriber"], req["event_uuid"], req["sub_private_key"],
                                  req["sub_signer_key"], req["policy_pub_key"], req["policy_sign_key"], req["label"])

    dec_data = {
        'data': text
    }
    return make_response(dec_data)

def createAliciaAndEncrypt(event_uuid, dataToEnc, sender):

    # we have to create polices for every
    label = event_uuid.encode()
    policy_pubkey = alicia.get_policy_encrypting_key_from_label(label)
    print("The policy public key for "
          "label '{}' is {}".format(label.decode("utf-8"), policy_pubkey.to_bytes().hex()))
    enc_data = generateEncDataUsingEnrico(
        policy_pubkey, dataToEnc, sender, event_uuid, True)
    return enc_data

def generateEncDataUsingEnrico(pub_policy_key, dataToEnc, sender, uuid, save_as_file: bool = False):
    data_source = Enrico(policy_encrypting_key=pub_policy_key)
    now = time.time()
    data_source_public_key = bytes(data_source.stamp)
    # create json formatted data of the location for specific user
    location_data = {
        'data_enc': dataToEnc,
        'timestamp': now,
        'sender': sender
    }

    plaintext = msgpack.dumps(location_data, use_bin_type=True)
    message_kit, _signature = data_source.encrypt_message(plaintext)
    location_bytes = message_kit.to_bytes()
    data = {
        'data_source': data_source_public_key,
        'data': location_bytes
    }

    enc_data_alicia = uuid + '.msgpack'

    if save_as_file:
        with open(enc_data_alicia, "wb") as file:
            msgpack.dump(data, file, use_bin_type=True)

    return data

def assignPolicyToSubscriber(subsriber, sub_uuid, event_uuid, publicEnc, publicSign):
    label = event_uuid.encode()
    m, n = 1, 1
    subenc = UmbralPublicKey.from_bytes(bytes.fromhex(publicEnc))
    subsig = UmbralPublicKey.from_bytes(bytes.fromhex(publicSign))
    ourCurrentSubscriber = Bob.from_public_keys(verifying_key=subsig,
                                                encrypting_key=subenc,
                                                federated_only=True)
    policy_end_datetime = maya.now() + datetime.timedelta(days=5)
    print("Creating access policy for the Doctor...")
    policy = alicia.grant(bob=ourCurrentSubscriber,
                          label=label,
                          m=m,
                          n=n,
                          expiration=policy_end_datetime)
    print("Done!")

    print(ourCurrentSubscriber)

    policy_info = {
        "policy_pub_key": policy.public_key.to_bytes().hex(),
        "policy_sig_key": bytes(alicia.stamp).hex(),
        "label": label.decode("utf-8"),
    }

    return policy_info

def createBobToResolveData(sub_uuid, sender, event_uuid, sub_private_key, sub_signer_key, policy_pub_key, policy_sign_key, label):
    SEEDNODE_URI = "127.0.0.1:10151"
    # TODO: path joins?
    TEMP_DOCTOR_DIR = "{}/doctor-files".format(
        os.path.dirname(os.path.abspath(__file__)))

    # Remove previous demo files and create new ones
    shutil.rmtree(TEMP_DOCTOR_DIR, ignore_errors=True)

    ursula = Ursula.from_seed_and_stake_info(seed_uri=SEEDNODE_URI,
                                             federated_only=True,
                                             minimum_stake=0)
    # doctor private key

    encdoctor = UmbralPrivateKey.from_bytes(bytes.fromhex(sub_private_key))
    signdoctor = UmbralPrivateKey.from_bytes(bytes.fromhex(sub_signer_key))

    bob_enc_keypair = DecryptingKeypair(private_key=encdoctor)
    bob_sig_keypair = SigningKeypair(private_key=signdoctor)
    enc_power = DecryptingPower(keypair=bob_enc_keypair)
    sig_power = SigningPower(keypair=bob_sig_keypair)
    power_ups = [enc_power, sig_power]

    print("Creating the Doctor ...")

    doctor = Bob(
        domains={TEMPORARY_DOMAIN},
        federated_only=True,
        crypto_power_ups=power_ups,
        start_learning_now=True,
        abort_on_learning_error=True,
        known_nodes=[ursula],
        save_metadata=False,
        network_middleware=RestMiddleware(),
    )

    print("Doctor = ", doctor)

    policy_pub_keys = UmbralPublicKey.from_bytes(bytes.fromhex(policy_pub_key))
    policy_sign_keys = UmbralPublicKey.from_bytes(
        bytes.fromhex(policy_sign_key))
    label = label.encode()

    print("The Doctor joins policy for label '{}'".format(label.decode("utf-8")))
    doctor.join_policy(label, policy_sign_keys)

    data = msgpack.load(open(event_uuid + ".msgpack", "rb"), raw=False)
    message_kits = UmbralMessageKit.from_bytes(data['data'])
    data_source = Enrico.from_public_keys(
        verifying_key=data['data_source'],
        policy_encrypting_key=policy_pub_keys
    )

    try:
        retrieved_plaintexts = doctor.retrieve(
            message_kits,
            label=label,
            enrico=data_source,
            alice_verifying_key=policy_sign_keys
        )

        plaintext = msgpack.loads(retrieved_plaintexts[0], raw=False)

        # Now we can get the heart rate and the associated timestamp,
        # generated by the heart rate monitor.
        location_decrypted = plaintext['data_enc']
        print(location_decrypted)
    except Exception as e:
            # We just want to know what went wrong and continue the demo
        traceback.print_exc()

    return location_decrypted

alicia = createGenericAlicia('i_am_new_alicia_from_bangalore_india')

'''
'''--- as-pect.config.js ---
module.exports = require('near-sdk-as/imports')

'''
'''--- asconfig.js ---
const compile = require('near-sdk-as/compiler').compile

compile('assembly/main.ts', // input file
  'out/main.wasm', // output file
  [
    //   "-O1",          // Optional arguments
    '--debug',
    '--measure', // Shows compiler runtime
    '--validate' // Validate the generated wasm module
  ], {
    verbose: true // Output the cli args passed to asc
  })

'''
'''--- assembly/__tests__/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />

'''
'''--- assembly/__tests__/guestbook.spec.ts ---
import { addMessage, getMessages } from '../main'
import { PostedMessage, messages } from '../model'

function createMessage (text: string): PostedMessage {
  return new PostedMessage(text);
}

const hello: string = 'hello world'
const message = createMessage(hello)

describe('messages should be able to', () => {
  beforeEach(()  => {
    addMessage(hello)
  });

  afterEach( () => {
    while (messages.length > 0) {
      messages.pop()
    }
  })

  it('add a message', () => {
    expect(messages.length).toBe(1, 'should only contain one message')
    expect(messages[0]).toStrictEqual(message, 'message should be "hello world"')
  })

  it('retrive messages', () => {
    const messagesArr = getMessages()
    expect(messagesArr.length).toBe(1, 'should be one message')
    expect(messagesArr).toIncludeEqual(message, 'messages should include:\n' + message.toJSON())
    log(messagesArr[0])
  })

  it('only show the last ten messages', () => {
    const newMessages: PostedMessage[] = []
    for (let i: i32 = 0; i < 10; i++) {
      const text = 'message #' + i.toString()
      newMessages.push(createMessage(text))
      addMessage(text)
    }
    const messages = getMessages()
    log(messages.slice(7, 10))
    expect(messages).toStrictEqual(newMessages, 'should be the last ten mesages')
    expect(messages).not.toIncludeEqual(message, "shouldn't contain the first element")
  })
})

'''
'''--- assembly/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />

'''
'''--- assembly/main.ts ---
// import {EventModel, events } from "./model";

import {
  User,
  users,
  userMap,
  EventRegistration,
  events,
  eventsMap,
  subscribers,
  DonationEventRegistration,
  donationEvents,
  mainEventToDonationEventMap,
  donationEventMap,
  donationToDonationEventMap,
  Donation,
  donationMap,
  donations,
  localities,
  localityToEventMap,
  policyMap,
  Policy,
} from "./model";
import { storage, context, logging } from "near-sdk-as";

// --- contract code goes below

// The maximum number of latest messages the contract returns.
const MESSAGE_LIMIT = 1000;

export function addUser(
  uuid: string,
  firstName: string,
  lastName: string,
  dateOfBirth: string,
  emailId: string,
  phoneNumber: string,
  sender: string,
  senderPublicEncKey: string,
  senderPublicSigKey: string
): void {
  let updateValue = new User(
    uuid,
    firstName,
    lastName,
    dateOfBirth,
    emailId,
    phoneNumber,
    true,
    sender,
    senderPublicEncKey,
    senderPublicSigKey
  );
  users.push(updateValue);
  userMap.set(context.sender, updateValue);
}

export function addEvent(
  uuid: string,
  title: string,
  purpose: string,
  date: string,
  minSubscribers: string,
  sender: string,
  locality: string
): boolean {
  let sub = new Array<string>();
  let donationEvents = new Array<string>();
  sub.push(context.sender);
  let eventRegistration = new EventRegistration(
    uuid,
    title,
    purpose,
    date,
    minSubscribers,
    sub,
    donationEvents,
    sender
  );
  eventsMap.set(uuid, eventRegistration);
  events.push(eventRegistration);
  localities.push(locality);
  let eventsInLocalities = localityToEventMap.get(locality);
  if (eventsInLocalities != null && eventsInLocalities.length) {
    eventsInLocalities.push(uuid);
    localityToEventMap.set(locality, eventsInLocalities);
  } else {
    localityToEventMap.set(locality, [uuid]);
  }
  return true;
}

export function addDonationEvent(
  donationEventUUID: string,
  mainEventUUID: string,
  title: string,
  purpose: string,
  date: string,
  validDate: string,
  minAmount: string,
  receiverAddress: string,
  sender: string
): boolean {
  let donations = new Array<string>();
  let donationEvent = new DonationEventRegistration(
    donationEventUUID,
    mainEventUUID,
    title,
    purpose,
    date,
    validDate,
    minAmount,
    donations,
    receiverAddress,
    sender
  );
  donationEventMap.set(donationEventUUID, donationEvent);
  donationEvents.push(donationEvent);
  let donationEventsNew = mainEventToDonationEventMap.get(mainEventUUID);
  if (donationEventsNew !== null && donationEventsNew.length) {
    donationEventsNew.push(donationEventUUID);
    mainEventToDonationEventMap.set(mainEventUUID, donationEventsNew);
  } else {
    mainEventToDonationEventMap.set(mainEventUUID, [donationEventUUID]);
  }
  return true;
}

export function getUsers(): User[] {
  const numMessages = min(MESSAGE_LIMIT, users.length);
  const startIndex = users.length - numMessages;
  const result = new Array<User>(numMessages);
  for (let i = 0; i < numMessages; i++) {
    result[i] = users[i + startIndex];
  }
  return result;
}

export function getUserBySender(currentUser: string): User {
  let getUserByName = userMap.get(currentUser);
  if (getUserByName != null) {
    return getUserByName;
  }
  return new User("", "", "", "", "", "", false, currentUser, "", "");
}

export function getEvents(): EventRegistration[] {
  const numMessages = min(MESSAGE_LIMIT, events.length);
  const startIndex = events.length - numMessages;
  const result = new Array<EventRegistration>(numMessages);
  for (let i = 0; i < numMessages; i++) {
    result[i] = events[i + startIndex];
    // update subsribers
    let subscribedUsers = subscribers.get(result[i].uuid);
    if (subscribedUsers !== null) {
      result[i].subscriber = subscribedUsers;
    }
    let donationEvents = mainEventToDonationEventMap.get(result[i].uuid);
    if (donationEvents !== null) {
      result[i].donationEvents = donationEvents;
    } else {
      result[i].donationEvents = [];
    }
  }
  return result;
}

export function getEventsByLocality(locality: string): string[] {
  let eventsInLocalities = localityToEventMap.get(locality);
  if (eventsInLocalities != null && eventsInLocalities.length) {
    const numMessages = min(MESSAGE_LIMIT, eventsInLocalities.length);
    const startIndex = eventsInLocalities.length - numMessages;
    const result = new Array<string>(numMessages);
    for (let i = 0; i < numMessages; i++) {
      result[i] = eventsInLocalities[i + startIndex];
    }
    return result;
  } else {
    return [];
  }
}

export function getEventByUUID(uuid: string): EventRegistration {
  let getEvent = eventsMap.get(uuid);

  if (getEvent != null) {
    let donationEvents = mainEventToDonationEventMap.get(uuid);
    if (donationEvents !== null) {
      getEvent.donationEvents = donationEvents;
    } else {
      getEvent.donationEvents = [];
    }
    return getEvent;
  }
  return new EventRegistration("", "", "", "", "", [], [], "");
}

export function getDonationEvents(): DonationEventRegistration[] {
  const numMessages = min(MESSAGE_LIMIT, donationEvents.length);
  const startIndex = donationEvents.length - numMessages;
  const result = new Array<DonationEventRegistration>(numMessages);
  for (let i = 0; i < numMessages; i++) {
    result[i] = donationEvents[i + startIndex];
    let donations = donationToDonationEventMap.get(result[i].uuid);
    if (donations != null) {
      result[i].donations = donations;
    } else {
      result[i].donations = [];
    }
  }
  return result;
}

export function getDonationEventByUUID(
  donationEventUUID: string
): DonationEventRegistration {
  let donationEvent = donationEventMap.get(donationEventUUID);
  if (donationEvent != null) {
    let donations = donationToDonationEventMap.get(donationEventUUID);
    if (donations != null) {
      donationEvent.donations = donations;
    } else {
      donationEvent.donations = [];
    }
    return donationEvent;
  }
  return new DonationEventRegistration("", "", "", "", "", "", "", [], "", "");
}

export function getDonationByUUID(donationUUID: string): Donation {
  let donation = donationMap.get(donationUUID);
  if (donation != null) {
    return donation;
  }
  return new Donation("", "", "", "");
}

export function getPolicy(key: string): Policy {
  let policy = policyMap.get(key);
  if (policy != null) {
    return policy;
  }
  return new Policy("", "", "");
}

export function getLocalities(): string[] {
  const result = new Array<string>(localities.length);
  for (let i = 0; i < localities.length; i++) {
    result[i] = localities[i];
  }
  return result;
}

export function subscribeEvent(
  uuid: string,
  sender: string,
  label: string,
  policyPubKey: string,
  policySigKey: string
): boolean {
  let getEvent = eventsMap.get(uuid);
  if (getEvent != null) {
    getEvent.subscriber.push(sender);
    subscribers.set(uuid, getEvent.subscriber);
    eventsMap.set(uuid, getEvent);
    let policy = new Policy(label, policyPubKey, policySigKey);
    policyMap.set(uuid + "_" + sender, policy);
    return true;
  }
  return false;
}

export function donateEvent(
  donationUUID: string,
  donationEventUUID: string,
  donorsAddress: string,
  amount: string
): boolean {
  let donation = new Donation(
    donationUUID,
    donationEventUUID,
    donorsAddress,
    amount
  );
  donationMap.set(donationUUID, donation);
  donations.push(donation);
  let donationsDone = donationToDonationEventMap.get(donationEventUUID);
  if (donationsDone !== null && donationsDone.length) {
    donationsDone.push(donationUUID);
    donationToDonationEventMap.set(donationEventUUID, donationsDone);
  } else {
    donationToDonationEventMap.set(donationEventUUID, [donationUUID]);
  }
  return true;
}

'''
'''--- assembly/model.ts ---
import {
  context,
  u128,
  PersistentVector,
  PersistentMap,
  PersistentSet,
} from "near-sdk-as";

// /**
//  * collections.vector is a persistent collection. Any changes to it will
//  * be automatically saved in the storage.
//  * The parameter to the constructor needs to be unique across a single contract.
//  * It will be used as a prefix to all keys required to store data in the storage.
//  */

// export const events = new PersistentVector<EventModel>("m");

/**
 * Register user details once new user logs into the application
 * this maintains the state of the current logged users
 */

@nearBindgen
export class User {
  constructor(
    public uuid: string,
    public firstName: string,
    public lastName: string,
    public dateOfBirth: string,
    public emailId: string,
    public phoneNumber: string,
    public isRegistered: bool,
    public username: string,
    public publicEncKey: string,
    public publicSigKey: string
  ) {}
}

@nearBindgen
export class EventRegistration {
  isActive: bool;
  constructor(
    public uuid: string,
    public title: string,
    public purpose: string,
    public date: string,
    public minSubscribers: string,
    public subscriber: string[],
    public donationEvents: string[],
    public owner: string
  ) {
    this.isActive = true;
  }
}

@nearBindgen
export class DonationEventRegistration {
  isActive: bool;
  constructor(
    public uuid: string,
    public mainEventUUID: string,
    public title: string,
    public purpose: string,
    public date: string,
    public validDate: string,
    public minAmount: string,
    public donations: string[],
    public receiverAddress: string,
    public owner: string
  ) {
    this.isActive = true;
  }
}

@nearBindgen
export class Donation {
  constructor(
    public uuid: string,
    public donationEventUUID: string,
    public donorsAddress: string,
    public amount: string
  ) {}
}

@nearBindgen
export class Policy {
  constructor(
    public label: string,
    public policyPubKey: string,
    public policySigKey: string
  ) {}
}

export const userMap = new PersistentMap<string, User>("a");

export const eventsMap = new PersistentMap<string, EventRegistration>("b");

export const donationEventMap = new PersistentMap<
  string,
  DonationEventRegistration
>("c");

export const donationMap = new PersistentMap<string, Donation>("d");

export const policyMap = new PersistentMap<string, Policy>("n");

export const users = new PersistentVector<User>("e");

export const events = new PersistentVector<EventRegistration>("f");

export const localities = new PersistentVector<string>("g");

export const donationEvents = new PersistentVector<DonationEventRegistration>(
  "h"
);

export const donations = new PersistentVector<Donation>("i");

export const localityToEventMap = new PersistentMap<string, string[]>("j");

export const mainEventToDonationEventMap = new PersistentMap<string, string[]>(
  "k"
);

export const donationToDonationEventMap = new PersistentMap<string, string[]>(
  "l"
);

export const subscribers = new PersistentMap<string, string[]>("m");

'''
'''--- assembly/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": [
    "./**/*.ts"
  ]
}

'''
'''--- babel.config.js ---
module.exports = {
  presets: ['@babel/preset-env', '@babel/preset-react']
}

'''
'''--- neardev/dev-account.env ---
CONTRACT_NAME=dev-1594151506360
'''
'''--- neardev/shared-test-staging/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- neardev/shared-test/test.near.json ---
{"account_id":"test.near","private_key":"ed25519:2wyRcSwSuHtRVmkMCGjPwnzZmQLeXLzLLyED1NDMt4BjnKgQL6tF85yBx6Jr26D2dUNeC716RBoTxntVHsegogYw"}

'''
'''--- package.json ---
{
  "name": "guest-book",
  "version": "0.1.0",
  "license": "MIT",
  "scripts": {
    "build": "yarn build:contract && yarn build:web",
    "build:contract": "node asconfig.js",
    "build:web": "parcel build src/index.html --public-url ./",
    "deploy": "yarn build && near deploy && gh-pages -d dist/",
    "dev": "yarn build:contract && near dev-deploy && nodemon --watch assembly -e ts --exec yarn dev:start",
    "lint": "eslint .",
    "start": "yarn deploy && parcel src/index.html",
    "dev:start": "env-cmd -f ./neardev/dev-account.env parcel src/index.html",
    "test": "yarn build:contract && asp && jest",
    "buildui": "parcel src/index.html"
  },
  "devDependencies": {
    "@babel/core": "^7.10.2",
    "@babel/preset-env": "^7.10.2",
    "@babel/preset-react": "^7.10.1",
    "@typescript-eslint/eslint-plugin": "^2.34.0",
    "@typescript-eslint/parser": "^2.34.0",
    "babel-jest": "^26.0.1",
    "eslint": "^6.8.0",
    "eslint-config-standard": "^14.1.1",
    "eslint-plugin-import": "^2.21.2",
    "eslint-plugin-jest": "^23.13.2",
    "eslint-plugin-node": "^11.1.0",
    "eslint-plugin-promise": "^4.2.1",
    "eslint-plugin-react": "^7.20.0",
    "eslint-plugin-standard": "^4.0.1",
    "gh-pages": "^3.0.0",
    "jest": "^26.0.1",
    "jest-environment-node": "^26.0.1",
    "near-sdk-as": "^0.4.2",
    "near-shell": "^0.24.2",
    "nodemon": "^2.0.4",
    "parcel-bundler": "^1.12.4",
    "react-test-renderer": "^16.13.1",
    "sass": "^1.26.7",
    "typescript": "^3.9.3"
  },
  "dependencies": {
    "big.js": "^5.2.2",
    "draft-js": "^0.11.6",
    "draftjs-to-html": "^0.9.1",
    "env-cmd": "^10.1.0",
    "ethereum-blockies-base64": "^1.0.2",
    "moment": "^2.26.0",
    "near-api-js": "^0.25.1",
    "react": "^16.13.1",
    "react-anchor-link-smooth-scroll": "^1.0.12",
    "react-countdown": "^2.2.1",
    "react-datepicker": "^3.0.0",
    "react-dom": "^16.13.1",
    "react-draft-wysiwyg": "^1.14.5",
    "react-feather": "^2.0.8",
    "react-geocode": "^0.2.1",
    "react-loader-spinner": "^3.1.14",
    "react-notifications-component": "^2.4.0",
    "react-places-autocomplete": "^7.2.1",
    "react-router-dom": "^5.2.0",
    "react-select": "^3.1.0",
    "regenerator-runtime": "^0.13.5",
    "rxjs": "^6.5.5",
    "textversionjs": "^1.1.3"
  },
  "jest": {
    "projects": [
      {
        "displayName": "User interface tests",
        "testEnvironment": "jsdom",
        "testMatch": [
          "<rootDir>/src/tests/ui/*.js"
        ]
      },
      {
        "displayName": "Integration tests",
        "testEnvironment": "near-shell/test_environment",
        "testMatch": [
          "<rootDir>/src/tests/integration/*.js"
        ]
      }
    ],
    "testPathIgnorePatterns": [
      "assembly/*"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- src/App.js ---
import "regenerator-runtime/runtime";
import React, { useEffect } from "react";
import "./App.scss";
import { BrowserRouter as Router, Route } from "react-router-dom";
import Home from "./components/Home";
import EventRegistration from "./components/EventRegistration";
import UserRegistration from "./components/UserRegistration";
import { StateContext, ActionContext } from "./hooks";
import Header from "./components/Header";
import Modal from "./components/Modal/Modal";
import EventSingle from "./components/EventSingle/EventSingle";
import DonationRegistration from "./components/DonationRegistration";
import DonationSingle from "./components/DonationSingle";
import "react-loader-spinner/dist/loader/css/react-spinner-loader.css";
import DonationHome from "./components/DonationHome";
import EventHome from "./components/EventHome";
import ReactNotification from "react-notifications-component";
import "react-notifications-component/dist/theme.css";

const App = ({ contract, currentUser, nearConfig, wallet }) => {
  const { loadNearConfig, setModalConfig, setUserDetails } = React.useContext(
    ActionContext
  );
  useEffect(() => {
    console.log(contract);
    loadNearConfig(contract, currentUser, nearConfig, wallet);
    if (contract && currentUser) {
      console.log(currentUser.accountId);
      contract
        .getUserBySender({ currentUser: currentUser.accountId.toString() })
        .then((user) => {
          console.log(user);
          if (!user.isRegistered) {
            setModalConfig(true, { type: "registration" });
          } else {
            if (localStorage.getItem("userEncCreds") !== null) {
              setModalConfig(true, { type: "user-encryption" });
            }
          }
          setUserDetails(user);
        });
    }
    // setModalConfig(true, { type: "user-encryption" })
  }, [contract, currentUser, nearConfig, wallet]);

  return (
    <div className="App">
      <Router>
        <ReactNotification />
        <Header />
        <Modal />
        <Route path="/" exact render={() => <Home />} />
        <Route path="/events" exact render={() => <EventHome />} />
        <Route path="/donations" exact render={() => <DonationHome />} />
        <Route path="/events/:id" exact render={() => <EventSingle />} />
        <Route path="/donations/:id" exact render={() => <DonationSingle />} />
        <Route
          path="/event-registration"
          exact
          render={() => <EventRegistration />}
        />
        <Route
          path="/events/:id/create-donation"
          exact
          render={() => <DonationRegistration />}
        />
        <Route
          path="/user-registration"
          exact
          render={() => <UserRegistration />}
        />
      </Router>
    </div>
  );
};

export default App;

'''
'''--- src/components/DonateWidget/index.js ---
import DonateWidget from "./DonateWidget";
export default DonateWidget;

'''
'''--- src/components/DonationHome/index.js ---
import DonationHome from "./DonationHome";
export default DonationHome;

'''
'''--- src/components/DonationRegistration/index.js ---
import DonationRegistration from "./DonationRegistration";
export default DonationRegistration;

'''
'''--- src/components/DonationSingle/index.js ---
import DonationSingle from "./DonationSingle";
export default DonationSingle;

'''
'''--- src/components/EventHome/index.js ---
import EventHome from "./EventHome";
export default EventHome;

'''
'''--- src/components/EventRegistration/index.js ---
import EventRegistration from "./EventRegistration";
export default EventRegistration;

'''
'''--- src/components/EventSingle/index.js ---
import EventSingle from "./EventSingle";
export default EventSingle;

'''
'''--- src/components/Header/index.js ---
import Header from "./Header";
export default Header;

'''
'''--- src/components/Home/index.js ---
import Home from "./Home";
export default Home;

'''
'''--- src/components/Modal/index.js ---
import Modal from "./Modal";

export default Modal;

'''
'''--- src/components/UploadEncryptionCreds/index.js ---
import UploadEncryptionCreds from "./UploadEncryptionCreds";
export default UploadEncryptionCreds;

'''
'''--- src/components/UserEncryptionCreds/index.js ---
import UserEncryptionCreds from "./UserEncryptionCreds";
export default UserEncryptionCreds;

'''
'''--- src/components/UserRegistration/index.js ---
import UserRegistration from "./UserRegistration";
export default UserRegistration;

'''
'''--- src/config.js ---
const CONTRACT_NAME = process.env.CONTRACT_NAME || "dev-1594144238344";
console.log(CONTRACT_NAME);
function getConfig(env) {
  switch (env) {
    case "production":
    case "mainnet":
      return {
        networkId: "mainnet",
        nodeUrl: "https://rpc.mainnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.near.org",
        helperUrl: "https://helper.mainnet.near.org",
      };
    case "development":
    case "testnet":
      return {
        networkId: "default",
        nodeUrl: "https://rpc.testnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.testnet.near.org",
        helperUrl: "https://helper.testnet.near.org",
      };
    case "devnet":
      return {
        networkId: "devnet",
        nodeUrl: "https://rpc.devnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.devnet.near.org",
        helperUrl: "https://helper.devnet.near.org",
      };
    case "betanet":
      return {
        networkId: "betanet",
        nodeUrl: "https://rpc.betanet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.betanet.near.org",
        helperUrl: "https://helper.betanet.near.org",
      };
    case "local":
      return {
        networkId: "local",
        nodeUrl: "http://localhost:3030",
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: "http://localhost:4000/wallet",
        contractName: CONTRACT_NAME,
      };
    case "test":
    case "ci":
      return {
        networkId: "shared-test",
        nodeUrl: "https://rpc.ci-testnet.near.org",
        contractName: CONTRACT_NAME,
        masterAccount: "test.near",
      };
    case "ci-betanet":
      return {
        networkId: "shared-test-staging",
        nodeUrl: "https://rpc.ci-betanet.near.org",
        contractName: CONTRACT_NAME,
        masterAccount: "test.near",
      };
    default:
      throw Error(
        `Unconfigured environment '${env}'. Can be configured in src/config.js.`
      );
  }
}

module.exports = getConfig;

'''
'''--- src/config/index.js ---

'''
'''--- src/hooks/index.js ---
import React, { createContext, useMemo } from "react";

export const ActionContext = createContext();
export const StateContext = createContext();

export const AppProvider = (props) => {
  const [state, dispatch] = React.useReducer(
    (prevState, action) => {
      switch (action.type) {
        case "LOAD_NEAR":
          return {
            ...prevState,
            contract: action.contract,
            currentUser: action.currentUser,
            nearConfig: action.nearConfig,
            wallet: action.wallet,
          };
        case "TOGGLE_MODAL":
          return {
            ...prevState,
            openModal: action.openModal,
            modalConfig: action.modalConfig,
          };
        case "SET_USER_ENCRYPTION_CREDS":
          return {
            ...prevState,
            userEncryptionCreds: action.userEncryptionCreds,
          };
        case "SET_USER_DETAILS":
          return {
            ...prevState,
            userDetails: action.userDetails,
          };
        case "SET_DECRYPT_LOCATION_EVENT_UUID":
          return {
            ...prevState,
            decryptLocationEventUuid: action.decryptLocationEventUuid,
          };
        case "SET_EVENTS":
          return {
            ...prevState,
            events: action.events,
          };
        case "SET_DONATION_EVENTS":
          return {
            ...prevState,
            donationEvents: action.donationEvents,
          };
        case "SET_SELECTED_EVENT":
          return {
            ...prevState,
            selectedEvent: action.selectedEvent,
          };
        case "SET_SELECTED_DONATION":
          return {
            ...prevState,
            selectedDonation: action.selectedDonation,
          };
        case "SET_SELECTED_DONATION_FOR_DONATE":
          return {
            ...prevState,
            selectedDonationForDonate: action.selectedDonationForDonate,
          };
        default:
      }
    },
    {
      contract: null,
      currentUser: null,
      nearConfig: null,
      wallet: null,
      openModal: false,
      modalConfig: { type: "" },
      userEncryptionCreds: localStorage.getItem("userEncCreds")
        ? JSON.parse(localStorage.getItem("userEncCreds"))
        : null,
      userDetails: null,
      decryptLocationEventUuid: "",
      events: [],
      donationEvents: [],
      selectedEvent: null,
      selectedDonation: null,
      selectedDonationForDonate: null,
    }
  );

  const actionContext = useMemo(
    () => ({
      loadNearConfig: async (contract, currentUser, nearConfig, wallet) => {
        dispatch({
          type: "LOAD_NEAR",
          contract,
          currentUser,
          nearConfig,
          wallet,
        });
      },
      setModalConfig: (openModal, modalConfig) => {
        dispatch({ type: "TOGGLE_MODAL", openModal, modalConfig });
      },
      setEvents: (events) => {
        dispatch({ type: "SET_EVENTS", events });
      },
      setDonationEvents: (donationEvents) => {
        dispatch({ type: "SET_DONATION_EVENTS", donationEvents });
      },
      setSelectedEvent: (selectedEvent) => {
        dispatch({ type: "SET_SELECTED_EVENT", selectedEvent });
      },
      setSelectedDonation: (selectedDonation) => {
        dispatch({ type: "SET_SELECTED_DONATION", selectedDonation });
      },
      setUserDetails: (userDetails) => {
        dispatch({ type: "SET_USER_DETAILS", userDetails });
      },
      setUserEncryptionCreds: (userEncryptionCreds) => {
        localStorage.setItem(
          "userEncCreds",
          JSON.stringify(userEncryptionCreds)
        );

        dispatch({ type: "SET_USER_ENCRYPTION_CREDS", userEncryptionCreds });
      },
      setDecryptLocationEventUuid: (decryptLocationEventUuid) => {
        dispatch({
          type: "SET_DECRYPT_LOCATION_EVENT_UUID",
          decryptLocationEventUuid,
        });
      },
      setSelectedDonationForDonate: (selectedDonationForDonate) => {
        dispatch({
          type: "SET_SELECTED_DONATION_FOR_DONATE",
          selectedDonationForDonate,
        });
      },
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  );
  return (
    <ActionContext.Provider value={actionContext}>
      <StateContext.Provider value={state}>
        {props.children}
      </StateContext.Provider>
    </ActionContext.Provider>
  );
};

'''
'''--- src/index.html ---
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="./favicon.ico" type="image/x-icon" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#ff8a00" />
    <link rel="apple-touch-icon" href="./favicon.ico" type="image/x-icon" />
    <title>PWPEvents</title>
    <meta property="og:title" content="PWPEvents" />
    <meta
      property="og:description"
      content="Provide single platform for protest organizers to create events and
      allow others to join the event without publishing the location."
    />
    <!-- <meta property="og:image" content=""> -->
    <!-- <meta property="og:url" content=""> -->
    <!-- <meta name="twitter:card" content="summary_large_image"> -->
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `yarn dev`.
      To create a production bundle, use `yarn build`.
    -->
    <script src="./index.js"></script>
    <script src="https://maps.googleapis.com/maps/api/js?key={useyourkey}&libraries=places"></script>
  </body>
</html>

'''
'''--- src/index.js ---
import React from "react";
import ReactDOM from "react-dom";
import "./index.scss";
import App from "./App";
import getConfig from "./config.js";
import * as nearAPI from "near-api-js";
import { AppProvider } from "./hooks";

// Initializing contract
async function initContract() {
  const nearConfig = getConfig(process.env.NODE_ENV || "development");

  // Initializing connection to the NEAR DevNet
  console.log(new nearAPI.keyStores.BrowserLocalStorageKeyStore());
  const near = await nearAPI.connect({
    deps: {
      keyStore: new nearAPI.keyStores.BrowserLocalStorageKeyStore(),
    },
    ...nearConfig,
  });

  // Needed to access wallet
  const walletConnection = new nearAPI.WalletConnection(near);

  // Load in account data
  let currentUser;
  if (walletConnection.getAccountId()) {
    currentUser = {
      accountId: walletConnection.getAccountId(),
      balance: (await walletConnection.account().state()).amount,
    };
  }

  // Initializing our contract APIs by contract name and configuration
  const contract = new nearAPI.Contract(
    walletConnection.account(),
    nearConfig.contractName,
    {
      // View methods are read-only – they don't modify the state, but usually return some value
      viewMethods: [
        "getUsers",
        "getUserBySender",
        "getEvents",
        "getEventsByLocality",
        "getEventByUUID",
        "getDonationEvents",
        "getDonationEventByUUID",
        "getDonationByUUID",
        "getPolicy",
        "getLocalities",
      ],
      // Change methods can modify the state, but you don't receive the returned value when called
      changeMethods: [
        "addUser",
        "addEvent",
        "addDonationEvent",
        "subscribeEvent",
        "donateEvent",
      ],
      // Sender is the account ID to initialize transactions.
      // getAccountId() will return empty string if user is still unauthorized
      sender: walletConnection.getAccountId(),
    }
  );

  return { contract, currentUser, nearConfig, walletConnection };
}
window.nearInitPromise = initContract().then(
  ({ contract, currentUser, nearConfig, walletConnection }) => {
    ReactDOM.render(
      <AppProvider>
        <App
          contract={contract}
          currentUser={currentUser}
          nearConfig={nearConfig}
          wallet={walletConnection}
        />
      </AppProvider>,
      document.getElementById("root")
    );
  }
);

'''
'''--- src/services/NuCypherService.js ---
const ROOT_URL = "http://localhost:5000";

export default class NuCypherService {
  static getEncryptionKey = async (user_uuid) => {
    return fetch(`${ROOT_URL}/api/generate_keys/`, {
      headers: {
        "Content-Type": "application/json; charset=utf-8",
      },
      method: "POST",
      body: JSON.stringify({
        user_uuid,
      }),
    })
      .then((res) => res.json())
      .catch((err) => console.log(err));
  };

  static encryptData = async (data_enc, sender, event_uuid) => {
    return fetch(`${ROOT_URL}/api/encrypt/`, {
      headers: {
        "Content-Type": "application/json; charset=utf-8",
      },
      method: "POST",
      body: JSON.stringify({
        data_enc,
        sender,
        event_uuid,
      }),
    })
      .then((res) => res.json())
      .catch((err) => console.log(err));
  };

  static assignPolicy = async (
    subscriber,
    sub_uuid,
    event_uuid,
    public_key_user,
    public_sign_user
  ) => {
    return fetch(`${ROOT_URL}/api/assign_policy/`, {
      headers: { "Content-Type": "application/json; charset=utf-8" },
      method: "POST",
      body: JSON.stringify({
        subscriber,
        sub_uuid,
        event_uuid,
        public_key_user,
        public_sign_user,
      }),
    })
      .then((res) => res.json())
      .catch((err) => console.log(err));
  };

  static decryptData = async (
    subscriber,
    sub_uuid,
    event_uuid,
    sub_private_key,
    sub_signer_key,
    policy_pub_key,
    policy_sign_key,
    label
  ) => {
    return fetch(`${ROOT_URL}/api/decrypt_data/`, {
      headers: { "Content-Type": "application/json; charset=utf-8" },
      method: "POST",
      body: JSON.stringify({
        subscriber,
        sub_uuid,
        event_uuid,
        sub_private_key,
        sub_signer_key,
        policy_pub_key,
        policy_sign_key,
        label,
      }),
    })
      .then((res) => res.json())
      .catch((err) => console.log(err));
  };
}

'''
'''--- src/services/index.js ---
import NuCypherService from "./NuCypherService";

export { NuCypherService };

'''
'''--- src/tests/integration/App-integration.test.js ---
// these are made available by near-shell/test_environment
// note: do not remove the line below as it is needed for these tests
/* global nearlib, nearConfig */

import 'regenerator-runtime/runtime'

let near
let contract
let accountId

beforeAll(async function () {
  near = await nearlib.connect(nearConfig)
  accountId = nearConfig.contractName
  contract = await near.loadContract(nearConfig.contractName, {
    viewMethods: ['getMessages'],
    changeMethods: ['addMessage'],
    sender: accountId
  })
})

it('send one message and retrieve it', async () => {
  await contract.addMessage({ text: 'aloha' })
  const msgs = await contract.getMessages()
  const expectedMessagesResult = [{
    premium: false,
    sender: accountId,
    text: 'aloha'
  }]
  expect(msgs).toEqual(expectedMessagesResult)
})

it('send two more messages and expect three total', async () => {
  await contract.addMessage({ text: 'foo' })
  await contract.addMessage({ text: 'bar' })
  const msgs = await contract.getMessages()
  expect(msgs.length).toEqual(3)
})

'''
'''--- src/tests/ui/App-ui.test.js ---
import 'regenerator-runtime/runtime'
import React from 'react'
import TestRenderer from 'react-test-renderer'
import App from '../../App'
const { act } = TestRenderer

// Declare stubs for contract, walletConnection, and nearConfig
const contract = {
  account: {
    connection: {},
    accountId: 'test.near'
  },
  contractId: 'test.near',
  getMessages: () => new Promise(() => {}),
  addMessage: () => ''
}
const walletConnection = {
  account: () => ({ _state: { amount: '1' + '0'.repeat(25) } }),
  requestSignIn: () => null,
  signOut: () => null,
  isSignedIn: () => false,
  getAccountId: () => 'test.near'
}
const nearConfig = {
  networkId: 'default',
  nodeUrl: 'https://rpc.nearprotocol.com',
  contractName: 'test.near',
  walletUrl: 'https://wallet.nearprotocol.com',
  helperUrl: 'https://near-contract-helper.onrender.com'
}

// For UI tests, use pattern from: https://reactjs.org/docs/test-renderer.html
let container

beforeEach(() => {
  container = document.createElement('div')
  document.body.appendChild(container)
})

afterEach(() => {
  document.body.removeChild(container)
  container = null
})

it('renders with proper title', () => {
  let testRenderer

  act(() => {
    testRenderer = TestRenderer.create(
      <App contract={contract} wallet={walletConnection} nearConfig={nearConfig} />
    )
  })

  const testInstance = testRenderer.root

  expect(testInstance.findByType('h1').children).toEqual(['NEAR Guest Book'])
})

'''
'''--- src/utils/index.js ---
export const isJoined = (event, currentUser) => {
  if (currentUser) {
    return (
      event.subscriber.filter((sub) => sub === currentUser.accountId).length !==
      0
    );
  }
  return false;
};

export const isQuotaFilled = (event) => {
  return event.subscriber.length >= Number.parseInt(event.minSubscribers);
};

export const isDonationNeeded = (donationEvent) => {
  const donationAmtDone =
    donationEvent.donations.length === 0
      ? 0
      : Number.parseFloat(
          donationEvent.donations
            .map((donation) => Number.parseFloat(donation.amount))
            .reduce((prev, curr) => prev + curr)
        );
  return Number.parseFloat(donationEvent.minAmount) !== donationAmtDone;
};

export const convertTwoDigits = (pValue) => {
  if (pValue < 10) return `0${pValue}`;
  return pValue;
};

'''