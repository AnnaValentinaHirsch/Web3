*GitHub Repository "onmachina/nearauth-backend"*

'''--- .well-known/jwks.json ---
{
    "keys": [
        {
            "kty": "EC",
            "crv": "P-256",
            "x": "UDvJx5LEkCo8iyTuqVH4k1EW65vvyMLwFbIMQ5lOzo8",
            "y": "giA9hCkL3ZmlB6G3kb+bXOqMwEm5WsS7LX71apF3orA",
            "ext": true,
            "kid": "ef3f9a6b3681ba62e5ea",
            "alg": "ES256",
            "use": "sig"
        }
    ]
}
'''
'''--- README.md ---
# OnMachina authentication demo with NEAR credentials

A simple authentication server with NEAR credentials built on ExpressJS.

The authentication server introduces a GET HTTP endpoint which is compatible with a standard `swift` CLI.

```bash
curl localhost:5000/auth/v1 -H 'x-auth-user: any' -H 'x-auth-key: <base64 credentials>'
```

## Prerequisites

Install `./node_modules`.

```bash
npm i
```

Need to login with a NEAR account.

```
npm i -g near-cli
near login
```

## (Optional) Start the local server

```bash
npm start
```

1. It's gonna use a **NEAR sandbox**.
2. For testing on the **NEAR sandbox** see instructions below.
3. For testing on the **NEAR testnet** define `NEAR_ENV=testnet` (use `.env` file).
4. Local server will listen on `http://localhost:5000`.

## Obtain base64 user credentials

`<base64 credentials>` is like a "password" derived from NEAR account secret key.

**Credentials** can be obtained with the following command:

```bash
CRED=`npm run --silent auth -- alice.testnet`
```

Output is a base64 **secret** string. Use it to obtain the JWT token.

## Use credentials to get authenticated

### `swift`

Authenticate using a `swift` tool:

```bash
eval $(swift -A http://127.0.0.1:5000/auth/v1.0 -U any -K ${CRED} auth)
```

It will _automatically_ set up `OS_AUTH_TOKEN` and `OS_STORAGE_URL` environment variables.

### `curl`

An advanced way is sending an HTTP request via `curl`:

```bash
curl localhost:5000/auth/v1 -H 'x-auth-user: any' -H 'x-auth-key: <base64 credentials>'
```

Output is an `x-auth-token` header with JWT token which is used
on the Swift proxy server. `x-storage-url` header is also returned.

```bash
export OS_AUTH_TOKEN=<x-auth-token header>
export OS_STORAGE_URL=<x-storage-url header>
```

## Persistance

```bash
npm install pm2 -g

pm2 start src/index.js
pm2 save
```

## How to Run Tests

```bash
npm run test
npm run test:e2e
```

## How to Test with NEAR Sandbox

Start the server.

```bash
npm run start
```

Start the NEAR sandbox.

```bash
npm run sandbox
```

Create an `alice.test.near` account.

```bash
near create-account alice.test.near --masterAccount test.near --initialBalance 10 --nodeUrl http://localhost:3030 --keyPath /tmp/near-auth-test-sandbox/validator_key.json --networkId sandbox
```

Generate login credentials.

```bash
CREDS=`npm run auth -- alice.test.near --networkId sandbox`
```

Login.

```bash
curl localhost:5000/auth/v1 -H 'x-auth-user: any' -H "x-auth-key: ${CREDS}" -v
```

Extract the JWT token from the `x-auth-token` response header.

```bash
JWT=<x-auth-token>
```

Test a backend API.

```bash
curl localhost:5001/metrics -H "Authorization: Bearer ${JWT}" -v
```

## How to Change Configuration

Define `.env` file. Example:

```
NEAR_ENV=testnet
ISSUER=https://auth.global01.onmachina.io/
AUDIENCE=https://api.global01.onmachina.io/
SERVER_STORAGE_DOMAIN=147.28.148.225:8080
```

## How to Generate a Test Keypair and `jwks.json`

Generate a private key for a EC curve (ES256):

```bash
openssl ecparam -name prime256v1 -genkey -noout -out prime256v1-private-key.pem
```

Generate a corresponding public key:

```bash
openssl ec -in prime256v1-private-key.pem -pubout -out prime256v1-public-key.pem
```

Put them the the `./test` directory.

Extract `x` and `y` from the public key PEM to use them in the `jwks.json`:

```bash
openssl pkey -pubin -in test/prime256v1-public-key.pem -pubout -outform der -out pubout
xxd -plain -s -64 -l 32 pubout | xxd -r -p | base64 # x
xxd -plain -s -32 -l 32 pubout | xxd -r -p | base64 # y
```

_Remove "=" padding symbol from the `x` and `y` base64 output!_

Paste `x` and `y` to `./.well-known/jwks.json`.

'''
'''--- package.json ---
{
  "name": "nearauth-backend",
  "version": "1.0.0",
  "scripts": {
    "start": "node src/index.js",
    "debug": "nodemon src/index.js",
    "sandbox": "rm -rf ${SANDBOX_PATH:-/tmp/near-auth-test-sandbox} && near-sandbox --home ${SANDBOX_PATH:-/tmp/near-auth-test-sandbox} init && near-sandbox --home ${SANDBOX_PATH:-/tmp/near-auth-test-sandbox} run",
    "test": "mocha --require test/spawn-app-and-near.js --require test/setup-near.js test",
    "auth": "node scripts/generate-auth-key.js"
  },
  "dependencies": {
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-async-errors": "^3.1.1",
    "http-status-codes": "^2.2.0",
    "js-sha256": "^0.9.0",
    "jsonwebtoken": "^9.0.0",
    "morgan": "^1.10.0",
    "near-api-js": "^3.0.2",
    "winston": "^3.8.2"
  },
  "devDependencies": {
    "axios": "^1.3.2",
    "bn.js": "^5.2.1",
    "chai": "^4.3.7",
    "chai-as-promised": "^7.1.1",
    "mocha": "^10.2.0",
    "near-sandbox": "^0.0.17",
    "nodemon": "^2.0.20",
    "port-used": "^2.0.8",
    "tree-kill": "^1.2.2",
    "yargs": "^17.6.2"
  }
}
'''
'''--- scripts/generate-auth-key.js ---
#!/usr/bin/env node

'use strict';
const nearAPI = require('near-api-js');
const yargs = require('yargs/yargs');
const { hideBin } = require('yargs/helpers');

const generate_auth_token = async (accountId, networkId) => {
  let nodeUrl;
  if (networkId === 'sandbox') {
    nodeUrl = `http://localhost:3030`;
  } else {
    nodeUrl = `https://rpc.${networkId}.near.org`;
  }
  const keyFileName = `${require('os').homedir()}/.near-credentials/${networkId}/${accountId}.json`;

  let keyFile;

  try {
    keyFile = require(keyFileName);
  } catch (err) {
    console.error(
      `Account ${accountId} is not found for the ${networkId}. Please, login with near CLI and try again.`
    );
    console.error(`File not found: ${keyFileName}.`);
    process.exit(1);
  }

  const privKey = nearAPI.utils.KeyPair.fromString(
    keyFile.secret_key || keyFile.private_key
  );

  const keyStore = new nearAPI.keyStores.InMemoryKeyStore();
  keyStore.setKey(networkId, accountId, privKey);

  const near = await nearAPI.connect({ keyStore, networkId, nodeUrl });

  const signer = near.connection.signer;

  const signerPublicKey = (
    await signer.getPublicKey(accountId, networkId)
  ).toString();

  const account = new nearAPI.Account(near.connection, accountId);

  const nonce = (await account.getAccessKeys())
    .find((k) => k.public_key === signerPublicKey)
    .access_key.nonce.toString();

  const accountData = Buffer.from(JSON.stringify({ id: accountId, nonce }));
  const signatureData = await signer.signMessage(
    accountData,
    accountId,
    networkId
  );

  const publicKey = Buffer.from(signatureData.publicKey.toString());
  const signature = Buffer.from(signatureData.signature);

  const credentials = Buffer.from(
    JSON.stringify({
      account: accountData.toString('base64'),
      publicKey: publicKey.toString('base64'),
      signature: signature.toString('base64'),
    })
  ).toString('base64');

  console.log(credentials);
};

(async function () {
  yargs(hideBin(process.argv))
    .usage('Usage: $0 <accountId> [--networkId <sandbox|testnet|mainnet>]')
    .command(
      '$0 <accountId>',
      'generate an authentication JWT token',
      (yargs) => {
        return yargs.positional('accountId', {
          describe: 'NEAR account identifier',
          type: 'string',
        });
      },
      async (argv) => {
        await generate_auth_token(argv.accountId, argv.networkId);
      }
    )
    .option('networkId', {
      describe: 'NEAR network',
      choices: ['sandbox', 'testnet', 'mainnet'],
      default: 'testnet',
    })
    .parse();
})();

'''
'''--- src/auth.js ---
'use strict';

const express = require('express');
const jwt = require('jsonwebtoken');
const fs = require('fs');
const nearAPI = require('near-api-js');
const sha256 = require('js-sha256').sha256;

const env = require('./env');
const logger = require('./logger');

const {
  methodNotAllowed,
  BadRequestError,
  UnauthenticatedError,
} = require('./errors');

const JWT_PRIVATE_KEY = fs.readFileSync(env.PRIVATE_KEY_PATH);
const JWT_ALG = 'ES256';
const JWT_LIFETIME = 60 * 60; // 60 minutes
const JWT_KID = 'ef3f9a6b3681ba62e5ea'; // same as ./.well-known/jwks.json

const configSandbox = {
  networkId: 'sandbox',
  nodeUrl: 'http://0.0.0.0:3030',
  contractId: '',
};

const configTestnet = {
  networkId: 'testnet',
  nodeUrl: 'https://rpc.testnet.near.org',
  machinaId: 'dev-1684076402429-48753957150583',
};

const configMainnet = {
  networkId: 'mainnet',
  nodeUrl: 'https://rpc.mainnet.near.org',
  machinaId: '',
};

const config =
  env.NEAR_ENV == 'mainnet'
    ? configMainnet
    : env.NEAR_ENV == 'testnet'
    ? configTestnet
    : configSandbox;

const login = async (req, res) => {
  const user = req.header('x-auth-user');
  const base64auth = req.header('x-auth-key');

  if (!user || !base64auth) {
    throw new BadRequestError();
  }

  const auth = JSON.parse(Buffer.from(base64auth, 'base64').toString('ascii'));

  const account = Buffer.from(auth.account, 'base64').toString('ascii');
  const publicKey = Buffer.from(auth.publicKey, 'base64').toString('ascii');
  const signature = Buffer.from(auth.signature, 'base64');

  logger.debug(`Authentication request: ${account}, ${publicKey}`);

  const verificationKey = nearAPI.utils.PublicKey.fromString(publicKey);
  const signedData = Buffer.from(sha256.array(Buffer.from(account)));

  if (!verificationKey.verify(signedData, signature)) {
    throw new UnauthenticatedError('Signature is not valid');
  }

  const accountDetails = JSON.parse(account);

  const near = await nearAPI.connect(config);
  const nearAccount = new nearAPI.Account(near.connection, accountDetails.id);

  const accessKey = (await nearAccount.getAccessKeys()).find(
    (k) => k.public_key === publicKey
  );

  if (!accessKey) {
    throw new UnauthenticatedError("Public key doesn't belong to the account");
  }

  if (accessKey.access_key.nonce.toString() != accountDetails.nonce) {
    throw new UnauthenticatedError('Nonce is outdated');
  }

  let role = 'user';

  // URI: /api/v1/:node
  if (req.params.node == 'node') {
    const contract = new nearAPI.Contract(nearAccount, config.machinaId, {
      viewMethods: ['node_info'],
    });

    const info = await contract.node_info({ node_id: accountDetails.id });

    if (Object.keys(info).length === 0) {
      throw new UnauthenticatedError("Node doesn't have a deposit");
    }

    role = 'node';
  }

  const customer = nearAccount.accountId;
  const subscription = 'unknown';

  const auth_token = jwt.sign(
    { role, customer, subscription },
    JWT_PRIVATE_KEY,
    {
      subject: customer,
      algorithm: JWT_ALG,
      notBefore: 0,
      expiresIn: JWT_LIFETIME,
      issuer: env.ISSUER,
      audience: env.AUDIENCE,
      keyid: JWT_KID,
    }
  );

  logger.info(`Authenticated as ${role}: ${nearAccount.accountId}`);

  const scheme = req.header('x-forwarded-proto') || req.protocol || 'https';
  const storage_url = `${scheme}://${env.SERVER_STORAGE_DOMAIN}/v1/${nearAccount.accountId}`;

  res.header('x-auth-token', auth_token);
  res.header('x-storage-url', storage_url);
  res.send();
};

const router = express.Router();

// GET method is compatible with Swift /auth/v1.0.
router.route('/').get(login).all(methodNotAllowed);
router.route('/:node').get(login).all(methodNotAllowed);

module.exports = router;

'''
'''--- src/env.js ---
require('dotenv').config();

const DEFAULT_PORT = 5000;

const env = {
  LOG_LEVEL: process.env.LOG_LEVEL || 'info',
  NEAR_ENV: process.env.NEAR_ENV || 'sandbox', // 'testnet', 'mainnet'
  SERVER_PORT: process.env.SERVER_PORT || DEFAULT_PORT,
  PRIVATE_KEY_PATH:
    process.env.PRIVATE_KEY_PATH || 'test/prime256v1-private-key.pem',
  ISSUER: process.env.ISSUER || `http://localhost:${DEFAULT_PORT}/`,
  AUDIENCE: process.env.AUDIENCE || 'http://localhost:5001/',
  SERVER_STORAGE_DOMAIN: process.env.SERVER_STORAGE_DOMAIN || 'localhost:5002',
};

module.exports = env;

'''
'''--- src/errors.js ---
const { StatusCodes } = require('http-status-codes');

const logger = require('./logger');

const errorHandler = (err, _req, res, _next) => {
  if (err.message) {
    logger.debug(err.message);
    logger.silly(err.stack);
  }

  res.sendStatus(err.statusCode || StatusCodes.INTERNAL_SERVER_ERROR);
};

const methodNotAllowed = (_req, _res) => {
  throw new MethodNotAllowedError();
};

const notFound = (_req, _res) => {
  throw new NotFoundError();
};

class NotFoundError extends Error {
  constructor() {
    super();
    this.statusCode = StatusCodes.NOT_FOUND;
  }
}

class MethodNotAllowedError extends Error {
  constructor() {
    super();
    this.statusCode = StatusCodes.METHOD_NOT_ALLOWED;
  }
}

class BadRequestError extends Error {
  constructor() {
    super();
    this.statusCode = StatusCodes.BAD_REQUEST;
  }
}

class UnauthenticatedError extends Error {
  constructor(message) {
    super(message);
    this.statusCode = StatusCodes.UNAUTHORIZED;
  }
}

module.exports = {
  errorHandler,
  notFound,
  methodNotAllowed,
  NotFoundError,
  MethodNotAllowedError,
  BadRequestError,
  UnauthenticatedError,
};

'''
'''--- src/index.js ---
'use strict';

require('express-async-errors');

const cors = require('cors');
const express = require('express');
const morgan = require('morgan');

const auth = require('./auth');
const env = require('./env');
const logger = require('./logger');
const { errorHandler, notFound } = require('./errors');

const app = express();

app.use(morgan('tiny'));
app.use(express.json());
app.use(cors());
app.use('/.well-known', express.static('.well-known'));
app.use('/auth/v1', auth);
app.use('/auth/v1.0', auth);
app.use(notFound);
app.use(errorHandler);

const start = async () => {
  try {
    app.listen(env.SERVER_PORT, () =>
      logger.info(`Server is listening on port ${env.SERVER_PORT}...`)
    );
  } catch (error) {
    logger.info(error);
  }
};

start();

'''
'''--- src/logger.js ---
const winston = require('winston');
const env = require('./env');

const myFormat = winston.format.printf(({ level, message, timestamp }) => {
  return `${timestamp} ${level}: ${message}`;
});

module.exports = winston.createLogger({
  level: env.LOG_LEVEL,
  transports: [new winston.transports.Console()],
  format: winston.format.combine(
    winston.format.colorize(),
    winston.format.timestamp(),
    myFormat
  ),
});

'''
'''--- test/setup-near.js ---
const nearAPI = require('near-api-js');
const BN = require('bn.js');
const portUsed = require('port-used');

process.env.NEAR_NO_LOGS = 'defined';

const SANDBOX_PATH = process.env.SANDBOX_PATH || '/tmp/near-auth-test-sandbox';
const SANDBOX_PORT = process.env.SANDBOX_PORT || 3030;

const config = {
  sandboxDomain: '0.0.0.0',
  sandboxPort: SANDBOX_PORT,
  sandboxPath: SANDBOX_PATH,
  sandboxNetworkId: 'sandbox',
  sandboxKeypath: `${SANDBOX_PATH}/validator_key.json`,
  sandboxAmount: new BN('300000000000000000000000000', 10), // 26 digits, 300 NEAR
  masterId: 'test.near',
  aliceId: 'alice.test.near',
};

async function sandboxSetup() {
  portUsed.check(config.sandboxPort, config.sandboxDomain).then(
    (inUse) => {
      if (!inUse) {
        throw new Error('Run NEAR sandbox first: `npm run sandbox`!');
      }
    },
    (err) => {
      console.error('Error on check:', err.message);
    }
  );

  const keyFile = require(config.sandboxKeypath);
  const privKey = nearAPI.utils.KeyPair.fromString(keyFile.secret_key);
  const pubKey = nearAPI.utils.PublicKey.fromString(keyFile.public_key);

  const keyStore = new nearAPI.keyStores.InMemoryKeyStore();
  keyStore.setKey(config.sandboxNetworkId, config.masterId, privKey);

  const near = await nearAPI.connect({
    keyStore,
    networkId: config.sandboxNetworkId,
    nodeUrl: 'http://' + config.sandboxDomain + ':' + config.sandboxPort,
  });

  let masterAccount = new nearAPI.Account(near.connection, config.masterId);

  // Create test accounts.
  await masterAccount.createAccount(
    config.aliceId,
    pubKey,
    config.sandboxAmount
  );
  keyStore.setKey(config.sandboxNetworkId, config.aliceId, privKey);
  const aliceAccount = new nearAPI.Account(near.connection, config.aliceId);

  global.aliceAccount = aliceAccount;
}

async function sandboxTeardown() {}

module.exports = { sandboxSetup, sandboxTeardown };

module.exports.mochaHooks = {
  beforeAll: async function () {
    this.timeout(50000);
    await sandboxSetup();
  },
  afterAll: async function () {
    this.timeout(10000);
    await sandboxTeardown();
  },
};

'''
'''--- test/spawn-app-and-near.js ---
const exec = require('child_process').exec;
const fs = require('fs');
const sleep = require('util').promisify(setTimeout);
const kill = require('tree-kill');

// NOTE: Not cool but easy.
const logger = require('../src/logger');

let server;
let sandbox;

const mochaGlobalSetup = async () => {
  if (fs.existsSync('.env')) {
    console.log(
      'Error: .env file is present. Please remove it, because it can affect the tests.'
    );
    process.exit(1);
  }

  console.log('Start NEAR sandbox...');
  sandbox = exec('npm run sandbox');

  console.log('Start server...');
  server = exec('npm start', (_error, stdout, _stderr) => logger.debug(stdout));

  await sleep(5000);
};

const mochaGlobalTeardown = async () => {
  if (sandbox.exitCode === 1) {
    console.log('Error: NEAR sandbox failure. Probably, it failed to start.');
  }

  if (server.exitCode === 1) {
    console.log('Error: Server failure. Probably, it failed to start.');
  }

  console.log('Stop NEAR sandbox...');
  kill(sandbox.pid);

  console.log('Stop server...');
  kill(server.pid);
};

module.exports = { mochaGlobalSetup, mochaGlobalTeardown };

'''
'''--- test/test-auth.js ---
'use strict';
const axios = require('axios');
const chai = require('chai');
const chaiAsPromised = require('chai-as-promised');
const jwt = require('jsonwebtoken');
const fs = require('fs');

chai.config.truncateThreshold = 0;
chai.use(chaiAsPromised);
const expect = chai.expect;

const client = axios.create({
  baseURL: 'http://localhost:5000',
});

const JWT_PUBLIC_KEY = fs.readFileSync('test/prime256v1-public-key.pem');

describe('Smoke Test', function () {
  it('should get a meaningful response', async () => {
    await expect(client.get(`/auth/v1.0`)).to.be.rejectedWith(/400/);
    await expect(client.get(`/auth/v2.0`)).to.be.rejectedWith(/404/);
    await expect(client.post(`/auth/v1.0`)).to.be.rejectedWith(/405/);
  });
});

describe('Client', function () {
  it('should get authenticated with NEAR account', async () => {
    const aliceAccount = global.aliceAccount;

    // The same as `walletConnection.connection` using the Wallet API.
    const connection = aliceAccount.connection;
    const aliceId = aliceAccount.accountId;

    const signer = connection.signer;
    const networkId = connection.networkId;

    const signerPublicKey = (
      await signer.getPublicKey(aliceId, networkId)
    ).toString();

    const nonce = (await aliceAccount.getAccessKeys())
      .find((k) => k.public_key === signerPublicKey)
      .access_key.nonce.toString();

    expect(nonce).is.not.null;

    const account = Buffer.from(JSON.stringify({ id: aliceId, nonce }));

    const signature_data = await signer.signMessage(
      account,
      aliceId,
      networkId
    );

    const publicKey = Buffer.from(signature_data.publicKey.toString());
    const signature = Buffer.from(signature_data.signature);

    const credentials = Buffer.from(
      JSON.stringify({
        account: account.toString('base64'),
        publicKey: publicKey.toString('base64'),
        signature: signature.toString('base64'),
      })
    ).toString('base64');

    const response = await expect(
      client.get('/auth/v1.0', {
        headers: {
          'x-auth-user': 'any',
          'x-auth-key': credentials,
        },
      })
    ).not.to.be.eventually.rejected;

    const x_auth_token = response.headers['x-auth-token'];
    const payload = jwt.verify(x_auth_token, JWT_PUBLIC_KEY);
    expect(payload).not.null;
    expect(payload.sub).to.be.equal(aliceId);
    expect(payload.exp - payload.nbf).to.be.equal(60 * 60);
    expect(payload.iss).to.not.be.empty;
    expect(payload.aud).to.not.be.empty;
    expect(payload.sub).to.be.equal(payload.customer);
    expect(payload.subscription).to.be.equal('unknown');

    const x_storage_url = response.headers['x-storage-url'];
    expect(x_storage_url).is.not.undefined;
    expect(x_storage_url).contains(`http://localhost:5002/v1/${aliceId}`);
  });
});

'''