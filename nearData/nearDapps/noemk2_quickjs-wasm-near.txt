*GitHub Repository "noemk2/quickjs-wasm-near"*

'''--- .github/FUNDING.yml ---
# These are supported funding model platforms

github: [petersalomonsen]

'''
'''--- .github/workflows/main.yml ---
name: CI
on:
  push:
    branches: [master]
  pull_request:
    branches: [master]
jobs:
  detectonly:
    name: Detect use of .only
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Detect use of .only
        run: |
          grep -rq --include '*.spec.js' \.only\( . && echo 'You have .only() in your tests!' && exit 1
          exit 0
  chromeheadless:
    name: Chrome headless
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Chrome headless
        run: |
          git clone https://github.com/emscripten-core/emsdk.git
          cd emsdk
          ./emsdk install latest
          ./emsdk activate latest
          cd ..
          npm i -g wasm-opt
          (cd wasmlib && source ../emsdk/emsdk_env.sh && ./build.sh)          
          cd web
          yarn install
          yarn test

'''
'''--- .gitpod.yml ---
# This configuration file was automatically generated by Gitpod.
# Please adjust to your needs (see https://www.gitpod.io/docs/config-gitpod-file)
# and commit this file to your remote git repository to share the goodness with others.

tasks:
  - init: |
      git clone https://github.com/emscripten-core/emsdk.git
      cd emsdk
      ./emsdk install latest
      ./emsdk activate latest
      cd ..
      npm i -g wasm-opt
      (cd wasmlib && source ../emsdk/emsdk_env.sh && ./build.sh)                    
      cd ../web
      yarn install

'''
'''--- README.md ---
QuickJS for WebAssembly on NEAR protocol
========================================

QuickJS compiled to WebAssembly and a Web application for creating NEAR smart contracts in Javascript to run on smart contract VMs created with near-js-sdk.

[near-sdk-js](https://github.com/near/near-sdk-js>) makes it possible to deploy Javascript smart contracts on NEAR protocol.

This web application let you write, simulate, deploy and call your javascript smart contracts in the web browser.                    

Note: Currently you can only create low-level ( [see examples here](https://github.com/near/near-sdk-js/tree/master/examples/low-level) ) contracts from here.

# How to use?

Check out the deployment at https://petersalomonsen.github.io/quickjs-wasm-near/dist/index.html where you can choose between coding or calling contract in the left menu.

Choose `Code` and enter some source code in the code editor:

```
export function hello() {
    env.log("Hello Near");
}
```

Now click `save` and you'll see that the `hello` method shows up in the method dropdown under `Simulation`. Click the `run` button to see the simulation output. You can also add arguments, deposits and storage to the simulation. If your code alters storage then that will affect the storage items after running.

Finally click `deploy` to upload your code on-chain. Note that deploying needs deposit, read more about it here: https://github.com/near/near-sdk-js#usage

After deploying you can call your contract, and test with arguments and deposit.

# Building

Building this projects involves compiling QuickJS as a static library using [emscripten](https://emscripten.org) and link to a Webassembly binary with the simple wrapper library in the [wasmlib](wasmlib) folder. This provides the in-browser simulation capacity.

The web application itself is in the [web](web) folder and is a pure web component app without any framework like React or Angular. For UI components [Material Design Web Components](https://github.com/material-components/material-web) is used, and for the code editor [CodeMirror 6](https://codemirror.net/6/). To be able to use these with "bare module imports" ( e.g. `import '@material/mwc-top-app-bar';` ), an [import map](https://github.com/WICG/import-maps) is needed, which is generated using the [JSPM Import Map Generator](https://github.com/jspm/generator). Given this it's possible to host the web app directly from the source files with static hosting, no development bundler like webpack is needed. Finally also a [rollup configuration](web/rollup.config.js) is provided for single js bundle production builds, which can be found in the [dist](dist) folder and is used for the hosted version.

Also see the [github actions pipeline](.github/workflows/main.yml) for commands to build and run the tests.

'''
'''--- cutils.c ---
/*
 * C utilities
 * 
 * Copyright (c) 2017 Fabrice Bellard
 * Copyright (c) 2018 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

#include "cutils.h"

void pstrcpy(char *buf, int buf_size, const char *str)
{
    int c;
    char *q = buf;

    if (buf_size <= 0)
        return;

    for(;;) {
        c = *str++;
        if (c == 0 || q >= buf + buf_size - 1)
            break;
        *q++ = c;
    }
    *q = '\0';
}

/* strcat and truncate. */
char *pstrcat(char *buf, int buf_size, const char *s)
{
    int len;
    len = strlen(buf);
    if (len < buf_size)
        pstrcpy(buf + len, buf_size - len, s);
    return buf;
}

int strstart(const char *str, const char *val, const char **ptr)
{
    const char *p, *q;
    p = str;
    q = val;
    while (*q != '\0') {
        if (*p != *q)
            return 0;
        p++;
        q++;
    }
    if (ptr)
        *ptr = p;
    return 1;
}

int has_suffix(const char *str, const char *suffix)
{
    size_t len = strlen(str);
    size_t slen = strlen(suffix);
    return (len >= slen && !memcmp(str + len - slen, suffix, slen));
}

/* Dynamic buffer package */

static void *dbuf_default_realloc(void *opaque, void *ptr, size_t size)
{
    return realloc(ptr, size);
}

void dbuf_init2(DynBuf *s, void *opaque, DynBufReallocFunc *realloc_func)
{
    memset(s, 0, sizeof(*s));
    if (!realloc_func)
        realloc_func = dbuf_default_realloc;
    s->opaque = opaque;
    s->realloc_func = realloc_func;
}

void dbuf_init(DynBuf *s)
{
    dbuf_init2(s, NULL, NULL);
}

/* return < 0 if error */
int dbuf_realloc(DynBuf *s, size_t new_size)
{
    size_t size;
    uint8_t *new_buf;
    if (new_size > s->allocated_size) {
        if (s->error)
            return -1;
        size = s->allocated_size * 3 / 2;
        if (size > new_size)
            new_size = size;
        new_buf = s->realloc_func(s->opaque, s->buf, new_size);
        if (!new_buf) {
            s->error = TRUE;
            return -1;
        }
        s->buf = new_buf;
        s->allocated_size = new_size;
    }
    return 0;
}

int dbuf_write(DynBuf *s, size_t offset, const uint8_t *data, size_t len)
{
    size_t end;
    end = offset + len;
    if (dbuf_realloc(s, end))
        return -1;
    memcpy(s->buf + offset, data, len);
    if (end > s->size)
        s->size = end;
    return 0;
}

int dbuf_put(DynBuf *s, const uint8_t *data, size_t len)
{
    if (unlikely((s->size + len) > s->allocated_size)) {
        if (dbuf_realloc(s, s->size + len))
            return -1;
    }
    memcpy(s->buf + s->size, data, len);
    s->size += len;
    return 0;
}

int dbuf_put_self(DynBuf *s, size_t offset, size_t len)
{
    if (unlikely((s->size + len) > s->allocated_size)) {
        if (dbuf_realloc(s, s->size + len))
            return -1;
    }
    memcpy(s->buf + s->size, s->buf + offset, len);
    s->size += len;
    return 0;
}

int dbuf_putc(DynBuf *s, uint8_t c)
{
    return dbuf_put(s, &c, 1);
}

int dbuf_putstr(DynBuf *s, const char *str)
{
    return dbuf_put(s, (const uint8_t *)str, strlen(str));
}

int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
                                                      const char *fmt, ...)
{
    va_list ap;
    char buf[128];
    int len;
    
    va_start(ap, fmt);
    len = vsnprintf(buf, sizeof(buf), fmt, ap);
    va_end(ap);
    if (len < sizeof(buf)) {
        /* fast case */
        return dbuf_put(s, (uint8_t *)buf, len);
    } else {
        if (dbuf_realloc(s, s->size + len + 1))
            return -1;
        va_start(ap, fmt);
        vsnprintf((char *)(s->buf + s->size), s->allocated_size - s->size,
                  fmt, ap);
        va_end(ap);
        s->size += len;
    }
    return 0;
}

void dbuf_free(DynBuf *s)
{
    /* we test s->buf as a fail safe to avoid crashing if dbuf_free()
       is called twice */
    if (s->buf) {
        s->realloc_func(s->opaque, s->buf, 0);
    }
    memset(s, 0, sizeof(*s));
}

/* Note: at most 31 bits are encoded. At most UTF8_CHAR_LEN_MAX bytes
   are output. */
int unicode_to_utf8(uint8_t *buf, unsigned int c)
{
    uint8_t *q = buf;

    if (c < 0x80) {
        *q++ = c;
    } else {
        if (c < 0x800) {
            *q++ = (c >> 6) | 0xc0;
        } else {
            if (c < 0x10000) {
                *q++ = (c >> 12) | 0xe0;
            } else {
                if (c < 0x00200000) {
                    *q++ = (c >> 18) | 0xf0;
                } else {
                    if (c < 0x04000000) {
                        *q++ = (c >> 24) | 0xf8;
                    } else if (c < 0x80000000) {
                        *q++ = (c >> 30) | 0xfc;
                        *q++ = ((c >> 24) & 0x3f) | 0x80;
                    } else {
                        return 0;
                    }
                    *q++ = ((c >> 18) & 0x3f) | 0x80;
                }
                *q++ = ((c >> 12) & 0x3f) | 0x80;
            }
            *q++ = ((c >> 6) & 0x3f) | 0x80;
        }
        *q++ = (c & 0x3f) | 0x80;
    }
    return q - buf;
}

static const unsigned int utf8_min_code[5] = {
    0x80, 0x800, 0x10000, 0x00200000, 0x04000000,
};

static const unsigned char utf8_first_code_mask[5] = {
    0x1f, 0xf, 0x7, 0x3, 0x1,
};

/* return -1 if error. *pp is not updated in this case. max_len must
   be >= 1. The maximum length for a UTF8 byte sequence is 6 bytes. */
int unicode_from_utf8(const uint8_t *p, int max_len, const uint8_t **pp)
{
    int l, c, b, i;

    c = *p++;
    if (c < 0x80) {
        *pp = p;
        return c;
    }
    switch(c) {
    case 0xc0: case 0xc1: case 0xc2: case 0xc3:
    case 0xc4: case 0xc5: case 0xc6: case 0xc7:
    case 0xc8: case 0xc9: case 0xca: case 0xcb:
    case 0xcc: case 0xcd: case 0xce: case 0xcf:
    case 0xd0: case 0xd1: case 0xd2: case 0xd3:
    case 0xd4: case 0xd5: case 0xd6: case 0xd7:
    case 0xd8: case 0xd9: case 0xda: case 0xdb:
    case 0xdc: case 0xdd: case 0xde: case 0xdf:
        l = 1;
        break;
    case 0xe0: case 0xe1: case 0xe2: case 0xe3:
    case 0xe4: case 0xe5: case 0xe6: case 0xe7:
    case 0xe8: case 0xe9: case 0xea: case 0xeb:
    case 0xec: case 0xed: case 0xee: case 0xef:
        l = 2;
        break;
    case 0xf0: case 0xf1: case 0xf2: case 0xf3:
    case 0xf4: case 0xf5: case 0xf6: case 0xf7:
        l = 3;
        break;
    case 0xf8: case 0xf9: case 0xfa: case 0xfb:
        l = 4;
        break;
    case 0xfc: case 0xfd:
        l = 5;
        break;
    default:
        return -1;
    }
    /* check that we have enough characters */
    if (l > (max_len - 1))
        return -1;
    c &= utf8_first_code_mask[l - 1];
    for(i = 0; i < l; i++) {
        b = *p++;
        if (b < 0x80 || b >= 0xc0)
            return -1;
        c = (c << 6) | (b & 0x3f);
    }
    if (c < utf8_min_code[l - 1])
        return -1;
    *pp = p;
    return c;
}

#if 0

#if defined(EMSCRIPTEN) || defined(__ANDROID__)

static void *rqsort_arg;
static int (*rqsort_cmp)(const void *, const void *, void *);

static int rqsort_cmp2(const void *p1, const void *p2)
{
    return rqsort_cmp(p1, p2, rqsort_arg);
}

/* not reentrant, but not needed with emscripten */
void rqsort(void *base, size_t nmemb, size_t size,
            int (*cmp)(const void *, const void *, void *),
            void *arg)
{
    rqsort_arg = arg;
    rqsort_cmp = cmp;
    qsort(base, nmemb, size, rqsort_cmp2);
}

#endif

#else

typedef void (*exchange_f)(void *a, void *b, size_t size);
typedef int (*cmp_f)(const void *, const void *, void *opaque);

static void exchange_bytes(void *a, void *b, size_t size) {
    uint8_t *ap = (uint8_t *)a;
    uint8_t *bp = (uint8_t *)b;

    while (size-- != 0) {
        uint8_t t = *ap;
        *ap++ = *bp;
        *bp++ = t;
    }
}

static void exchange_one_byte(void *a, void *b, size_t size) {
    uint8_t *ap = (uint8_t *)a;
    uint8_t *bp = (uint8_t *)b;
    uint8_t t = *ap;
    *ap = *bp;
    *bp = t;
}

static void exchange_int16s(void *a, void *b, size_t size) {
    uint16_t *ap = (uint16_t *)a;
    uint16_t *bp = (uint16_t *)b;

    for (size /= sizeof(uint16_t); size-- != 0;) {
        uint16_t t = *ap;
        *ap++ = *bp;
        *bp++ = t;
    }
}

static void exchange_one_int16(void *a, void *b, size_t size) {
    uint16_t *ap = (uint16_t *)a;
    uint16_t *bp = (uint16_t *)b;
    uint16_t t = *ap;
    *ap = *bp;
    *bp = t;
}

static void exchange_int32s(void *a, void *b, size_t size) {
    uint32_t *ap = (uint32_t *)a;
    uint32_t *bp = (uint32_t *)b;

    for (size /= sizeof(uint32_t); size-- != 0;) {
        uint32_t t = *ap;
        *ap++ = *bp;
        *bp++ = t;
    }
}

static void exchange_one_int32(void *a, void *b, size_t size) {
    uint32_t *ap = (uint32_t *)a;
    uint32_t *bp = (uint32_t *)b;
    uint32_t t = *ap;
    *ap = *bp;
    *bp = t;
}

static void exchange_int64s(void *a, void *b, size_t size) {
    uint64_t *ap = (uint64_t *)a;
    uint64_t *bp = (uint64_t *)b;

    for (size /= sizeof(uint64_t); size-- != 0;) {
        uint64_t t = *ap;
        *ap++ = *bp;
        *bp++ = t;
    }
}

static void exchange_one_int64(void *a, void *b, size_t size) {
    uint64_t *ap = (uint64_t *)a;
    uint64_t *bp = (uint64_t *)b;
    uint64_t t = *ap;
    *ap = *bp;
    *bp = t;
}

static void exchange_int128s(void *a, void *b, size_t size) {
    uint64_t *ap = (uint64_t *)a;
    uint64_t *bp = (uint64_t *)b;

    for (size /= sizeof(uint64_t) * 2; size-- != 0; ap += 2, bp += 2) {
        uint64_t t = ap[0];
        uint64_t u = ap[1];
        ap[0] = bp[0];
        ap[1] = bp[1];
        bp[0] = t;
        bp[1] = u;
    }
}

static void exchange_one_int128(void *a, void *b, size_t size) {
    uint64_t *ap = (uint64_t *)a;
    uint64_t *bp = (uint64_t *)b;
    uint64_t t = ap[0];
    uint64_t u = ap[1];
    ap[0] = bp[0];
    ap[1] = bp[1];
    bp[0] = t;
    bp[1] = u;
}

static inline exchange_f exchange_func(const void *base, size_t size) {
    switch (((uintptr_t)base | (uintptr_t)size) & 15) {
    case 0:
        if (size == sizeof(uint64_t) * 2)
            return exchange_one_int128;
        else
            return exchange_int128s;
    case 8:
        if (size == sizeof(uint64_t))
            return exchange_one_int64;
        else
            return exchange_int64s;
    case 4:
    case 12:
        if (size == sizeof(uint32_t))
            return exchange_one_int32;
        else
            return exchange_int32s;
    case 2:
    case 6:
    case 10:
    case 14:
        if (size == sizeof(uint16_t))
            return exchange_one_int16;
        else
            return exchange_int16s;
    default:
        if (size == 1)
            return exchange_one_byte;
        else
            return exchange_bytes;
    }
}

static void heapsortx(void *base, size_t nmemb, size_t size, cmp_f cmp, void *opaque)
{
    uint8_t *basep = (uint8_t *)base;
    size_t i, n, c, r;
    exchange_f swap = exchange_func(base, size);

    if (nmemb > 1) {
        i = (nmemb / 2) * size;
        n = nmemb * size;

        while (i > 0) {
            i -= size;
            for (r = i; (c = r * 2 + size) < n; r = c) {
                if (c < n - size && cmp(basep + c, basep + c + size, opaque) <= 0)
                    c += size;
                if (cmp(basep + r, basep + c, opaque) > 0)
                    break;
                swap(basep + r, basep + c, size);
            }
        }
        for (i = n - size; i > 0; i -= size) {
            swap(basep, basep + i, size);

            for (r = 0; (c = r * 2 + size) < i; r = c) {
                if (c < i - size && cmp(basep + c, basep + c + size, opaque) <= 0)
                    c += size;
                if (cmp(basep + r, basep + c, opaque) > 0)
                    break;
                swap(basep + r, basep + c, size);
            }
        }
    }
}

static inline void *med3(void *a, void *b, void *c, cmp_f cmp, void *opaque)
{
    return cmp(a, b, opaque) < 0 ?
        (cmp(b, c, opaque) < 0 ? b : (cmp(a, c, opaque) < 0 ? c : a )) :
        (cmp(b, c, opaque) > 0 ? b : (cmp(a, c, opaque) < 0 ? a : c ));
}

/* pointer based version with local stack and insertion sort threshhold */
void rqsort(void *base, size_t nmemb, size_t size, cmp_f cmp, void *opaque)
{
    struct { uint8_t *base; size_t count; int depth; } stack[50], *sp = stack;
    uint8_t *ptr, *pi, *pj, *plt, *pgt, *top, *m;
    size_t m4, i, lt, gt, span, span2;
    int c, depth;
    exchange_f swap = exchange_func(base, size);
    exchange_f swap_block = exchange_func(base, size | 128);

    if (nmemb < 2 || size <= 0)
        return;

    sp->base = (uint8_t *)base;
    sp->count = nmemb;
    sp->depth = 0;
    sp++;

    while (sp > stack) {
        sp--;
        ptr = sp->base;
        nmemb = sp->count;
        depth = sp->depth;

        while (nmemb > 6) {
            if (++depth > 50) {
                /* depth check to ensure worst case logarithmic time */
                heapsortx(ptr, nmemb, size, cmp, opaque);
                nmemb = 0;
                break;
            }
            /* select median of 3 from 1/4, 1/2, 3/4 positions */
            /* should use median of 5 or 9? */
            m4 = (nmemb >> 2) * size;
            m = med3(ptr + m4, ptr + 2 * m4, ptr + 3 * m4, cmp, opaque);
            swap(ptr, m, size);  /* move the pivot to the start or the array */
            i = lt = 1;
            pi = plt = ptr + size;
            gt = nmemb;
            pj = pgt = top = ptr + nmemb * size;
            for (;;) {
                while (pi < pj && (c = cmp(ptr, pi, opaque)) >= 0) {
                    if (c == 0) {
                        swap(plt, pi, size);
                        lt++;
                        plt += size;
                    }
                    i++;
                    pi += size;
                }
                while (pi < (pj -= size) && (c = cmp(ptr, pj, opaque)) <= 0) {
                    if (c == 0) {
                        gt--;
                        pgt -= size;
                        swap(pgt, pj, size);
                    }
                }
                if (pi >= pj)
                    break;
                swap(pi, pj, size);
                i++;
                pi += size;
            }
            /* array has 4 parts:
             * from 0 to lt excluded: elements identical to pivot
             * from lt to pi excluded: elements smaller than pivot
             * from pi to gt excluded: elements greater than pivot
             * from gt to n excluded: elements identical to pivot
             */
            /* move elements identical to pivot in the middle of the array: */
            /* swap values in ranges [0..lt[ and [i-lt..i[
               swapping the smallest span between lt and i-lt is sufficient
             */
            span = plt - ptr;
            span2 = pi - plt;
            lt = i - lt;
            if (span > span2)
                span = span2;
            swap_block(ptr, pi - span, span);
            /* swap values in ranges [gt..top[ and [i..top-(top-gt)[
               swapping the smallest span between top-gt and gt-i is sufficient
             */
            span = top - pgt;
            span2 = pgt - pi;
            pgt = top - span2;
            gt = nmemb - (gt - i);
            if (span > span2)
                span = span2;
            swap_block(pi, top - span, span);

            /* now array has 3 parts:
             * from 0 to lt excluded: elements smaller than pivot
             * from lt to gt excluded: elements identical to pivot
             * from gt to n excluded: elements greater than pivot
             */
            /* stack the larger segment and keep processing the smaller one
               to minimize stack use for pathological distributions */
            if (lt > nmemb - gt) {
                sp->base = ptr;
                sp->count = lt;
                sp->depth = depth;
                sp++;
                ptr = pgt;
                nmemb -= gt;
            } else {
                sp->base = pgt;
                sp->count = nmemb - gt;
                sp->depth = depth;
                sp++;
                nmemb = lt;
            }
        }
        /* Use insertion sort for small fragments */
        for (pi = ptr + size, top = ptr + nmemb * size; pi < top; pi += size) {
            for (pj = pi; pj > ptr && cmp(pj - size, pj, opaque) > 0; pj -= size)
                swap(pj, pj - size, size);
        }
    }
}

#endif

'''
'''--- cutils.h ---
/*
 * C utilities
 * 
 * Copyright (c) 2017 Fabrice Bellard
 * Copyright (c) 2018 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef CUTILS_H
#define CUTILS_H

#include <stdlib.h>
#include <inttypes.h>

/* set if CPU is big endian */
#undef WORDS_BIGENDIAN

#define likely(x)       __builtin_expect(!!(x), 1)
#define unlikely(x)     __builtin_expect(!!(x), 0)
#define force_inline inline __attribute__((always_inline))
#define no_inline __attribute__((noinline))
#define __maybe_unused __attribute__((unused))

#define xglue(x, y) x ## y
#define glue(x, y) xglue(x, y)
#define stringify(s)    tostring(s)
#define tostring(s)     #s

#ifndef offsetof
#define offsetof(type, field) ((size_t) &((type *)0)->field)
#endif
#ifndef countof
#define countof(x) (sizeof(x) / sizeof((x)[0]))
#endif

typedef int BOOL;

#ifndef FALSE
enum {
    FALSE = 0,
    TRUE = 1,
};
#endif

void pstrcpy(char *buf, int buf_size, const char *str);
char *pstrcat(char *buf, int buf_size, const char *s);
int strstart(const char *str, const char *val, const char **ptr);
int has_suffix(const char *str, const char *suffix);

static inline int max_int(int a, int b)
{
    if (a > b)
        return a;
    else
        return b;
}

static inline int min_int(int a, int b)
{
    if (a < b)
        return a;
    else
        return b;
}

static inline uint32_t max_uint32(uint32_t a, uint32_t b)
{
    if (a > b)
        return a;
    else
        return b;
}

static inline uint32_t min_uint32(uint32_t a, uint32_t b)
{
    if (a < b)
        return a;
    else
        return b;
}

static inline int64_t max_int64(int64_t a, int64_t b)
{
    if (a > b)
        return a;
    else
        return b;
}

static inline int64_t min_int64(int64_t a, int64_t b)
{
    if (a < b)
        return a;
    else
        return b;
}

/* WARNING: undefined if a = 0 */
static inline int clz32(unsigned int a)
{
    return __builtin_clz(a);
}

/* WARNING: undefined if a = 0 */
static inline int clz64(uint64_t a)
{
    return __builtin_clzll(a);
}

/* WARNING: undefined if a = 0 */
static inline int ctz32(unsigned int a)
{
    return __builtin_ctz(a);
}

/* WARNING: undefined if a = 0 */
static inline int ctz64(uint64_t a)
{
    return __builtin_ctzll(a);
}

struct __attribute__((packed)) packed_u64 {
    uint64_t v;
};

struct __attribute__((packed)) packed_u32 {
    uint32_t v;
};

struct __attribute__((packed)) packed_u16 {
    uint16_t v;
};

static inline uint64_t get_u64(const uint8_t *tab)
{
    return ((const struct packed_u64 *)tab)->v;
}

static inline int64_t get_i64(const uint8_t *tab)
{
    return (int64_t)((const struct packed_u64 *)tab)->v;
}

static inline void put_u64(uint8_t *tab, uint64_t val)
{
    ((struct packed_u64 *)tab)->v = val;
}

static inline uint32_t get_u32(const uint8_t *tab)
{
    return ((const struct packed_u32 *)tab)->v;
}

static inline int32_t get_i32(const uint8_t *tab)
{
    return (int32_t)((const struct packed_u32 *)tab)->v;
}

static inline void put_u32(uint8_t *tab, uint32_t val)
{
    ((struct packed_u32 *)tab)->v = val;
}

static inline uint32_t get_u16(const uint8_t *tab)
{
    return ((const struct packed_u16 *)tab)->v;
}

static inline int32_t get_i16(const uint8_t *tab)
{
    return (int16_t)((const struct packed_u16 *)tab)->v;
}

static inline void put_u16(uint8_t *tab, uint16_t val)
{
    ((struct packed_u16 *)tab)->v = val;
}

static inline uint32_t get_u8(const uint8_t *tab)
{
    return *tab;
}

static inline int32_t get_i8(const uint8_t *tab)
{
    return (int8_t)*tab;
}

static inline void put_u8(uint8_t *tab, uint8_t val)
{
    *tab = val;
}

static inline uint16_t bswap16(uint16_t x)
{
    return (x >> 8) | (x << 8);
}

static inline uint32_t bswap32(uint32_t v)
{
    return ((v & 0xff000000) >> 24) | ((v & 0x00ff0000) >>  8) |
        ((v & 0x0000ff00) <<  8) | ((v & 0x000000ff) << 24);
}

static inline uint64_t bswap64(uint64_t v)
{
    return ((v & ((uint64_t)0xff << (7 * 8))) >> (7 * 8)) | 
        ((v & ((uint64_t)0xff << (6 * 8))) >> (5 * 8)) | 
        ((v & ((uint64_t)0xff << (5 * 8))) >> (3 * 8)) | 
        ((v & ((uint64_t)0xff << (4 * 8))) >> (1 * 8)) | 
        ((v & ((uint64_t)0xff << (3 * 8))) << (1 * 8)) | 
        ((v & ((uint64_t)0xff << (2 * 8))) << (3 * 8)) | 
        ((v & ((uint64_t)0xff << (1 * 8))) << (5 * 8)) | 
        ((v & ((uint64_t)0xff << (0 * 8))) << (7 * 8));
}

/* XXX: should take an extra argument to pass slack information to the caller */
typedef void *DynBufReallocFunc(void *opaque, void *ptr, size_t size);

typedef struct DynBuf {
    uint8_t *buf;
    size_t size;
    size_t allocated_size;
    BOOL error; /* true if a memory allocation error occurred */
    DynBufReallocFunc *realloc_func;
    void *opaque; /* for realloc_func */
} DynBuf;

void dbuf_init(DynBuf *s);
void dbuf_init2(DynBuf *s, void *opaque, DynBufReallocFunc *realloc_func);
int dbuf_realloc(DynBuf *s, size_t new_size);
int dbuf_write(DynBuf *s, size_t offset, const uint8_t *data, size_t len);
int dbuf_put(DynBuf *s, const uint8_t *data, size_t len);
int dbuf_put_self(DynBuf *s, size_t offset, size_t len);
int dbuf_putc(DynBuf *s, uint8_t c);
int dbuf_putstr(DynBuf *s, const char *str);
static inline int dbuf_put_u16(DynBuf *s, uint16_t val)
{
    return dbuf_put(s, (uint8_t *)&val, 2);
}
static inline int dbuf_put_u32(DynBuf *s, uint32_t val)
{
    return dbuf_put(s, (uint8_t *)&val, 4);
}
static inline int dbuf_put_u64(DynBuf *s, uint64_t val)
{
    return dbuf_put(s, (uint8_t *)&val, 8);
}
int __attribute__((format(printf, 2, 3))) dbuf_printf(DynBuf *s,
                                                      const char *fmt, ...);
void dbuf_free(DynBuf *s);
static inline BOOL dbuf_error(DynBuf *s) {
    return s->error;
}
static inline void dbuf_set_error(DynBuf *s)
{
    s->error = TRUE;
}

#define UTF8_CHAR_LEN_MAX 6

int unicode_to_utf8(uint8_t *buf, unsigned int c);
int unicode_from_utf8(const uint8_t *p, int max_len, const uint8_t **pp);

static inline int from_hex(int c)
{
    if (c >= '0' && c <= '9')
        return c - '0';
    else if (c >= 'A' && c <= 'F')
        return c - 'A' + 10;
    else if (c >= 'a' && c <= 'f')
        return c - 'a' + 10;
    else
        return -1;
}

void rqsort(void *base, size_t nmemb, size_t size,
            int (*cmp)(const void *, const void *, void *),
            void *arg);

#endif  /* CUTILS_H */

'''
'''--- dist/index.html ---
<!doctype html><html><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin=""><link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet"><link href="https://fonts.googleapis.com/css?family=Material+Icons&amp;display=block" rel="stylesheet"><style>body{margin:0;font-family:Roboto,sans-serif}</style></head><body><app-root></app-root><script type="module" src="./app.2773d133.js"></script></body></html>
'''
'''--- examples/fib.c ---
/*
 * QuickJS: Example of C module
 * 
 * Copyright (c) 2017-2018 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include "../quickjs.h"

#define countof(x) (sizeof(x) / sizeof((x)[0]))

static int fib(int n)
{
    if (n <= 0)
        return 0;
    else if (n == 1)
        return 1;
    else
        return fib(n - 1) + fib(n - 2);
}

static JSValue js_fib(JSContext *ctx, JSValueConst this_val,
                      int argc, JSValueConst *argv)
{
    int n, res;
    if (JS_ToInt32(ctx, &n, argv[0]))
        return JS_EXCEPTION;
    res = fib(n);
    return JS_NewInt32(ctx, res);
}

static const JSCFunctionListEntry js_fib_funcs[] = {
    JS_CFUNC_DEF("fib", 1, js_fib ),
};

static int js_fib_init(JSContext *ctx, JSModuleDef *m)
{
    return JS_SetModuleExportList(ctx, m, js_fib_funcs,
                                  countof(js_fib_funcs));
}

#ifdef JS_SHARED_LIBRARY
#define JS_INIT_MODULE js_init_module
#else
#define JS_INIT_MODULE js_init_module_fib
#endif

JSModuleDef *JS_INIT_MODULE(JSContext *ctx, const char *module_name)
{
    JSModuleDef *m;
    m = JS_NewCModule(ctx, module_name, js_fib_init);
    if (!m)
        return NULL;
    JS_AddModuleExportList(ctx, m, js_fib_funcs, countof(js_fib_funcs));
    return m;
}

'''
'''--- examples/fib_module.js ---
/* fib module */
export function fib(n)
{
    if (n <= 0)
        return 0;
    else if (n == 1)
        return 1;
    else
        return fib(n - 1) + fib(n - 2);
}

'''
'''--- examples/hello.js ---
console.log("Hello World");

'''
'''--- examples/hello_module.js ---
/* example of JS module */

import { fib } from "./fib_module.js";

console.log("Hello World");
console.log("fib(10)=", fib(10));

'''
'''--- examples/pi_bigdecimal.js ---
/*
 * PI computation in Javascript using the QuickJS bigdecimal type
 * (decimal floating point)
 */
"use strict";

/* compute PI with a precision of 'prec' digits */
function calc_pi(prec) {
    const CHUD_A = 13591409m;
    const CHUD_B = 545140134m;
    const CHUD_C = 640320m;
    const CHUD_C3 = 10939058860032000m; /* C^3/24 */
    const CHUD_DIGITS_PER_TERM = 14.18164746272548; /* log10(C/12)*3 */
    
    /* return [P, Q, G] */
    function chud_bs(a, b, need_G) {
        var c, P, Q, G, P1, Q1, G1, P2, Q2, G2, b1;
        if (a == (b - 1n)) {
            b1 = BigDecimal(b);
            G = (2m * b1 - 1m) * (6m * b1 - 1m) * (6m * b1 - 5m);
            P = G * (CHUD_B * b1 + CHUD_A);
            if (b & 1n)
                P = -P;
            G = G;
            Q = b1 * b1 * b1 * CHUD_C3;
        } else {
            c = (a + b) >> 1n;
            [P1, Q1, G1] = chud_bs(a, c, true);
            [P2, Q2, G2] = chud_bs(c, b, need_G);
            P = P1 * Q2 + P2 * G1;
            Q = Q1 * Q2;
            if (need_G)
                G = G1 * G2;
            else
                G = 0m;
        }
        return [P, Q, G];
    }

    var n, P, Q, G;
    /* number of serie terms */
    n = BigInt(Math.ceil(prec / CHUD_DIGITS_PER_TERM)) + 10n;
    [P, Q, G] = chud_bs(0n, n, false);
    Q = BigDecimal.div(Q, (P + Q * CHUD_A),
                       { roundingMode: "half-even",
                         maximumSignificantDigits: prec });
    G = (CHUD_C / 12m) * BigDecimal.sqrt(CHUD_C,
                                         { roundingMode: "half-even",
                                           maximumSignificantDigits: prec });
    return Q * G;
}

(function() {
    var r, n_digits, n_bits;
    if (typeof scriptArgs != "undefined") {
        if (scriptArgs.length < 2) {
            print("usage: pi n_digits");
            return;
        }
        n_digits = scriptArgs[1] | 0;
    } else {
        n_digits = 1000;
    }
    /* we add more digits to reduce the probability of bad rounding for
       the last digits */
    r = calc_pi(n_digits + 20);
    print(r.toFixed(n_digits, "down"));
})();

'''
'''--- examples/pi_bigfloat.js ---
/*
 * PI computation in Javascript using the QuickJS bigfloat type
 * (binary floating point)
 */
"use strict";

/* compute PI with a precision of 'prec' bits */
function calc_pi() {
    const CHUD_A = 13591409n;
    const CHUD_B = 545140134n;
    const CHUD_C = 640320n;
    const CHUD_C3 = 10939058860032000n; /* C^3/24 */
    const CHUD_BITS_PER_TERM = 47.11041313821584202247; /* log2(C/12)*3 */
    
    /* return [P, Q, G] */
    function chud_bs(a, b, need_G) {
        var c, P, Q, G, P1, Q1, G1, P2, Q2, G2;
        if (a == (b - 1n)) {
            G = (2n * b - 1n) * (6n * b - 1n) * (6n * b - 5n);
            P = BigFloat(G * (CHUD_B * b + CHUD_A));
            if (b & 1n)
                P = -P;
            G = BigFloat(G);
            Q = BigFloat(b * b * b * CHUD_C3);
        } else {
            c = (a + b) >> 1n;
            [P1, Q1, G1] = chud_bs(a, c, true);
            [P2, Q2, G2] = chud_bs(c, b, need_G);
            P = P1 * Q2 + P2 * G1;
            Q = Q1 * Q2;
            if (need_G)
                G = G1 * G2;
            else
                G = 0l;
        }
        return [P, Q, G];
    }

    var n, P, Q, G;
    /* number of serie terms */
    n = BigInt(Math.ceil(BigFloatEnv.prec / CHUD_BITS_PER_TERM)) + 10n;
    [P, Q, G] = chud_bs(0n, n, false);
    Q = Q / (P + Q * BigFloat(CHUD_A));
    G = BigFloat((CHUD_C / 12n)) * BigFloat.sqrt(BigFloat(CHUD_C));
    return Q * G;
}

(function() {
    var r, n_digits, n_bits;
    if (typeof scriptArgs != "undefined") {
        if (scriptArgs.length < 2) {
            print("usage: pi n_digits");
            return;
        }
        n_digits = scriptArgs[1];
    } else {
        n_digits = 1000;
    }
    n_bits = Math.ceil(n_digits * Math.log2(10));
    /* we add more bits to reduce the probability of bad rounding for
       the last digits */
    BigFloatEnv.setPrec( () => {
        r = calc_pi();
        print(r.toFixed(n_digits, BigFloatEnv.RNDZ));
    }, n_bits + 32);
})();

'''
'''--- examples/pi_bigint.js ---
/*
 * PI computation in Javascript using the BigInt type
 */
"use strict";

/* return floor(log2(a)) for a > 0 and 0 for a = 0 */
function floor_log2(a)
{
    var k_max, a1, k, i;
    k_max = 0n;
    while ((a >> (2n ** k_max)) != 0n) {
        k_max++;
    }
    k = 0n;
    a1 = a;
    for(i = k_max - 1n; i >= 0n; i--) {
        a1 = a >> (2n ** i);
        if (a1 != 0n) {
            a = a1;
            k |= (1n << i);
        }
    }
    return k;
}

/* return ceil(log2(a)) for a > 0 */
function ceil_log2(a)
{
    return floor_log2(a - 1n) + 1n;
}

/* return floor(sqrt(a)) (not efficient but simple) */
function int_sqrt(a)
{
    var l, u, s;
    if (a == 0n)
        return a;
    l = ceil_log2(a);
    u = 1n << ((l + 1n) / 2n);
    /* u >= floor(sqrt(a)) */
    for(;;) {
        s = u;
        u = ((a / s) + s) / 2n;
        if (u >= s)
            break;
    }
    return s;
}

/* return pi * 2**prec */
function calc_pi(prec) {
    const CHUD_A = 13591409n;
    const CHUD_B = 545140134n;
    const CHUD_C = 640320n;
    const CHUD_C3 = 10939058860032000n; /* C^3/24 */
    const CHUD_BITS_PER_TERM = 47.11041313821584202247; /* log2(C/12)*3 */
    
    /* return [P, Q, G] */
    function chud_bs(a, b, need_G) {
        var c, P, Q, G, P1, Q1, G1, P2, Q2, G2;
        if (a == (b - 1n)) {
            G = (2n * b - 1n) * (6n * b - 1n) * (6n * b - 5n);
            P = G * (CHUD_B * b + CHUD_A);
            if (b & 1n)
                P = -P;
            Q = b * b * b * CHUD_C3;
        } else {
            c = (a + b) >> 1n;
            [P1, Q1, G1] = chud_bs(a, c, true);
            [P2, Q2, G2] = chud_bs(c, b, need_G);
            P = P1 * Q2 + P2 * G1;
            Q = Q1 * Q2;
            if (need_G)
                G = G1 * G2;
            else
                G = 0n;
        }
        return [P, Q, G];
    }

    var n, P, Q, G;
    /* number of serie terms */
    n = BigInt(Math.ceil(Number(prec) / CHUD_BITS_PER_TERM)) + 10n;
    [P, Q, G] = chud_bs(0n, n, false);
    Q = (CHUD_C / 12n) * (Q << prec) / (P + Q * CHUD_A);
    G = int_sqrt(CHUD_C << (2n * prec));
    return (Q * G) >> prec;
}

function main(args) {
    var r, n_digits, n_bits, out;
    if (args.length < 1) {
        print("usage: pi n_digits");
        return;
    }
    n_digits = args[0] | 0;

    /* we add more bits to reduce the probability of bad rounding for
      the last digits */
    n_bits = BigInt(Math.ceil(n_digits * Math.log2(10))) + 32n;
    r = calc_pi(n_bits);
    r = ((10n ** BigInt(n_digits)) * r) >> n_bits;
    out = r.toString();
    print(out[0] + "." + out.slice(1));
}

var args;
if (typeof scriptArgs != "undefined") {
    args = scriptArgs;
    args.shift();
} else if (typeof arguments != "undefined") {
    args = arguments;
} else {
    /* default: 1000 digits */
    args=[1000];
}

main(args);

'''
'''--- examples/point.c ---
/*
 * QuickJS: Example of C module with a class
 * 
 * Copyright (c) 2019 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include "../quickjs.h"
#include <math.h>

#define countof(x) (sizeof(x) / sizeof((x)[0]))

/* Point Class */

typedef struct {
    int x;
    int y;
} JSPointData;

static JSClassID js_point_class_id;

static void js_point_finalizer(JSRuntime *rt, JSValue val)
{
    JSPointData *s = JS_GetOpaque(val, js_point_class_id);
    /* Note: 's' can be NULL in case JS_SetOpaque() was not called */
    js_free_rt(rt, s);
}

static JSValue js_point_ctor(JSContext *ctx,
                             JSValueConst new_target,
                             int argc, JSValueConst *argv)
{
    JSPointData *s;
    JSValue obj = JS_UNDEFINED;
    JSValue proto;
    
    s = js_mallocz(ctx, sizeof(*s));
    if (!s)
        return JS_EXCEPTION;
    if (JS_ToInt32(ctx, &s->x, argv[0]))
        goto fail;
    if (JS_ToInt32(ctx, &s->y, argv[1]))
        goto fail;
    /* using new_target to get the prototype is necessary when the
       class is extended. */
    proto = JS_GetPropertyStr(ctx, new_target, "prototype");
    if (JS_IsException(proto))
        goto fail;
    obj = JS_NewObjectProtoClass(ctx, proto, js_point_class_id);
    JS_FreeValue(ctx, proto);
    if (JS_IsException(obj))
        goto fail;
    JS_SetOpaque(obj, s);
    return obj;
 fail:
    js_free(ctx, s);
    JS_FreeValue(ctx, obj);
    return JS_EXCEPTION;
}

static JSValue js_point_get_xy(JSContext *ctx, JSValueConst this_val, int magic)
{
    JSPointData *s = JS_GetOpaque2(ctx, this_val, js_point_class_id);
    if (!s)
        return JS_EXCEPTION;
    if (magic == 0)
        return JS_NewInt32(ctx, s->x);
    else
        return JS_NewInt32(ctx, s->y);
}

static JSValue js_point_set_xy(JSContext *ctx, JSValueConst this_val, JSValue val, int magic)
{
    JSPointData *s = JS_GetOpaque2(ctx, this_val, js_point_class_id);
    int v;
    if (!s)
        return JS_EXCEPTION;
    if (JS_ToInt32(ctx, &v, val))
        return JS_EXCEPTION;
    if (magic == 0)
        s->x = v;
    else
        s->y = v;
    return JS_UNDEFINED;
}

static JSValue js_point_norm(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
{
    JSPointData *s = JS_GetOpaque2(ctx, this_val, js_point_class_id);
    if (!s)
        return JS_EXCEPTION;
    return JS_NewFloat64(ctx, sqrt((double)s->x * s->x + (double)s->y * s->y));
}

static JSClassDef js_point_class = {
    "Point",
    .finalizer = js_point_finalizer,
}; 

static const JSCFunctionListEntry js_point_proto_funcs[] = {
    JS_CGETSET_MAGIC_DEF("x", js_point_get_xy, js_point_set_xy, 0),
    JS_CGETSET_MAGIC_DEF("y", js_point_get_xy, js_point_set_xy, 1),
    JS_CFUNC_DEF("norm", 0, js_point_norm),
};

static int js_point_init(JSContext *ctx, JSModuleDef *m)
{
    JSValue point_proto, point_class;
    
    /* create the Point class */
    JS_NewClassID(&js_point_class_id);
    JS_NewClass(JS_GetRuntime(ctx), js_point_class_id, &js_point_class);

    point_proto = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(ctx, point_proto, js_point_proto_funcs, countof(js_point_proto_funcs));
    
    point_class = JS_NewCFunction2(ctx, js_point_ctor, "Point", 2, JS_CFUNC_constructor, 0);
    /* set proto.constructor and ctor.prototype */
    JS_SetConstructor(ctx, point_class, point_proto);
    JS_SetClassProto(ctx, js_point_class_id, point_proto);
                      
    JS_SetModuleExport(ctx, m, "Point", point_class);
    return 0;
}

JSModuleDef *js_init_module(JSContext *ctx, const char *module_name)
{
    JSModuleDef *m;
    m = JS_NewCModule(ctx, module_name, js_point_init);
    if (!m)
        return NULL;
    JS_AddModuleExport(ctx, m, "Point");
    return m;
}

'''
'''--- examples/test_fib.js ---
/* example of JS module importing a C module */

import { fib } from "./fib.so";

console.log("Hello World");
console.log("fib(10)=", fib(10));

'''
'''--- examples/test_point.js ---
/* example of JS module importing a C module */
import { Point } from "./point.so";

function assert(b, str)
{
    if (b) {
        return;
    } else {
        throw Error("assertion failed: " + str);
    }
}

class ColorPoint extends Point {
    constructor(x, y, color) {
        super(x, y);
        this.color = color;
    }
    get_color() {
        return this.color;
    }
};

function main()
{
    var pt, pt2;

    pt = new Point(2, 3);
    assert(pt.x === 2);
    assert(pt.y === 3);
    pt.x = 4;
    assert(pt.x === 4);
    assert(pt.norm() == 5);

    pt2 = new ColorPoint(2, 3, 0xffffff);
    assert(pt2.x === 2);
    assert(pt2.color === 0xffffff);
    assert(pt2.get_color() === 0xffffff);
}

main();

'''
'''--- libbf.c ---
/*
 * Tiny arbitrary precision floating point library
 * 
 * Copyright (c) 2017-2021 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdio.h>
#include <inttypes.h>
#include <math.h>
#include <string.h>
#include <assert.h>

#ifdef __AVX2__
#include <immintrin.h>
#endif

#include "cutils.h"
#include "libbf.h"

/* enable it to check the multiplication result */
//#define USE_MUL_CHECK
/* enable it to use FFT/NTT multiplication */
#define USE_FFT_MUL
/* enable decimal floating point support */
#define USE_BF_DEC

//#define inline __attribute__((always_inline))

#ifdef __AVX2__
#define FFT_MUL_THRESHOLD 100 /* in limbs of the smallest factor */
#else
#define FFT_MUL_THRESHOLD 100 /* in limbs of the smallest factor */
#endif

/* XXX: adjust */
#define DIVNORM_LARGE_THRESHOLD 50
#define UDIV1NORM_THRESHOLD 3

#if LIMB_BITS == 64
#define FMT_LIMB1 "%" PRIx64 
#define FMT_LIMB "%016" PRIx64 
#define PRId_LIMB PRId64
#define PRIu_LIMB PRIu64

#else

#define FMT_LIMB1 "%x"
#define FMT_LIMB "%08x"
#define PRId_LIMB "d"
#define PRIu_LIMB "u"

#endif

typedef intptr_t mp_size_t;

typedef int bf_op2_func_t(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
                          bf_flags_t flags);

#ifdef USE_FFT_MUL

#define FFT_MUL_R_OVERLAP_A (1 << 0)
#define FFT_MUL_R_OVERLAP_B (1 << 1)
#define FFT_MUL_R_NORESIZE  (1 << 2)

static no_inline int fft_mul(bf_context_t *s,
                             bf_t *res, limb_t *a_tab, limb_t a_len,
                             limb_t *b_tab, limb_t b_len, int mul_flags);
static void fft_clear_cache(bf_context_t *s);
#endif
#ifdef USE_BF_DEC
static limb_t get_digit(const limb_t *tab, limb_t len, slimb_t pos);
#endif

/* could leading zeros */
static inline int clz(limb_t a)
{
    if (a == 0) {
        return LIMB_BITS;
    } else {
#if LIMB_BITS == 64
        return clz64(a);
#else
        return clz32(a);
#endif
    }
}

static inline int ctz(limb_t a)
{
    if (a == 0) {
        return LIMB_BITS;
    } else {
#if LIMB_BITS == 64
        return ctz64(a);
#else
        return ctz32(a);
#endif
    }
}

static inline int ceil_log2(limb_t a)
{
    if (a <= 1)
        return 0;
    else
        return LIMB_BITS - clz(a - 1);
}

/* b must be >= 1 */
static inline slimb_t ceil_div(slimb_t a, slimb_t b)
{
    if (a >= 0)
        return (a + b - 1) / b;
    else
        return a / b;
}

/* b must be >= 1 */
static inline slimb_t floor_div(slimb_t a, slimb_t b)
{
    if (a >= 0) {
        return a / b;
    } else {
        return (a - b + 1) / b;
    }
}

/* return r = a modulo b (0 <= r <= b - 1. b must be >= 1 */
static inline limb_t smod(slimb_t a, slimb_t b)
{
    a = a % (slimb_t)b;
    if (a < 0)
        a += b;
    return a;
}

/* signed addition with saturation */
static inline slimb_t sat_add(slimb_t a, slimb_t b)
{
    slimb_t r;
    r = a + b;
    /* overflow ? */
    if (((a ^ r) & (b ^ r)) < 0)
        r = (a >> (LIMB_BITS - 1)) ^ (((limb_t)1 << (LIMB_BITS - 1)) - 1);
    return r;
}

#define malloc(s) malloc_is_forbidden(s)
#define free(p) free_is_forbidden(p)
#define realloc(p, s) realloc_is_forbidden(p, s)

void bf_context_init(bf_context_t *s, bf_realloc_func_t *realloc_func,
                     void *realloc_opaque)
{
    memset(s, 0, sizeof(*s));
    s->realloc_func = realloc_func;
    s->realloc_opaque = realloc_opaque;
}

void bf_context_end(bf_context_t *s)
{
    bf_clear_cache(s);
}

void bf_init(bf_context_t *s, bf_t *r)
{
    r->ctx = s;
    r->sign = 0;
    r->expn = BF_EXP_ZERO;
    r->len = 0;
    r->tab = NULL;
}

/* return 0 if OK, -1 if alloc error */
int bf_resize(bf_t *r, limb_t len)
{
    limb_t *tab;
    
    if (len != r->len) {
        tab = bf_realloc(r->ctx, r->tab, len * sizeof(limb_t));
        if (!tab && len != 0)
            return -1;
        r->tab = tab;
        r->len = len;
    }
    return 0;
}

/* return 0 or BF_ST_MEM_ERROR */
int bf_set_ui(bf_t *r, uint64_t a)
{
    r->sign = 0;
    if (a == 0) {
        r->expn = BF_EXP_ZERO;
        bf_resize(r, 0); /* cannot fail */
    } 
#if LIMB_BITS == 32
    else if (a <= 0xffffffff)
#else
    else
#endif
    {
        int shift;
        if (bf_resize(r, 1))
            goto fail;
        shift = clz(a);
        r->tab[0] = a << shift;
        r->expn = LIMB_BITS - shift;
    }
#if LIMB_BITS == 32
    else {
        uint32_t a1, a0;
        int shift;
        if (bf_resize(r, 2))
            goto fail;
        a0 = a;
        a1 = a >> 32;
        shift = clz(a1);
        r->tab[0] = a0 << shift;
        r->tab[1] = (a1 << shift) | (a0 >> (LIMB_BITS - shift));
        r->expn = 2 * LIMB_BITS - shift;
    }
#endif
    return 0;
 fail:
    bf_set_nan(r);
    return BF_ST_MEM_ERROR;
}

/* return 0 or BF_ST_MEM_ERROR */
int bf_set_si(bf_t *r, int64_t a)
{
    int ret;

    if (a < 0) {
        ret = bf_set_ui(r, -a);
        r->sign = 1;
    } else {
        ret = bf_set_ui(r, a);
    }
    return ret;
}

void bf_set_nan(bf_t *r)
{
    bf_resize(r, 0); /* cannot fail */
    r->expn = BF_EXP_NAN;
    r->sign = 0;
}

void bf_set_zero(bf_t *r, int is_neg)
{
    bf_resize(r, 0); /* cannot fail */
    r->expn = BF_EXP_ZERO;
    r->sign = is_neg;
}

void bf_set_inf(bf_t *r, int is_neg)
{
    bf_resize(r, 0); /* cannot fail */
    r->expn = BF_EXP_INF;
    r->sign = is_neg;
}

/* return 0 or BF_ST_MEM_ERROR */
int bf_set(bf_t *r, const bf_t *a)
{
    if (r == a)
        return 0;
    if (bf_resize(r, a->len)) {
        bf_set_nan(r);
        return BF_ST_MEM_ERROR;
    }
    r->sign = a->sign;
    r->expn = a->expn;
    memcpy(r->tab, a->tab, a->len * sizeof(limb_t));
    return 0;
}

/* equivalent to bf_set(r, a); bf_delete(a) */
void bf_move(bf_t *r, bf_t *a)
{
    bf_context_t *s = r->ctx;
    if (r == a)
        return;
    bf_free(s, r->tab);
    *r = *a;
}

static limb_t get_limbz(const bf_t *a, limb_t idx)
{
    if (idx >= a->len)
        return 0;
    else
        return a->tab[idx];
}

/* get LIMB_BITS at bit position 'pos' in tab */
static inline limb_t get_bits(const limb_t *tab, limb_t len, slimb_t pos)
{
    limb_t i, a0, a1;
    int p;

    i = pos >> LIMB_LOG2_BITS;
    p = pos & (LIMB_BITS - 1);
    if (i < len)
        a0 = tab[i];
    else
        a0 = 0;
    if (p == 0) {
        return a0;
    } else {
        i++;
        if (i < len)
            a1 = tab[i];
        else
            a1 = 0;
        return (a0 >> p) | (a1 << (LIMB_BITS - p));
    }
}

static inline limb_t get_bit(const limb_t *tab, limb_t len, slimb_t pos)
{
    slimb_t i;
    i = pos >> LIMB_LOG2_BITS;
    if (i < 0 || i >= len)
        return 0;
    return (tab[i] >> (pos & (LIMB_BITS - 1))) & 1;
}

static inline limb_t limb_mask(int start, int last)
{
    limb_t v;
    int n;
    n = last - start + 1;
    if (n == LIMB_BITS)
        v = -1;
    else
        v = (((limb_t)1 << n) - 1) << start;
    return v;
}

static limb_t mp_scan_nz(const limb_t *tab, mp_size_t n)
{
    mp_size_t i;
    for(i = 0; i < n; i++) {
        if (tab[i] != 0)
            return 1;
    }
    return 0;
}

/* return != 0 if one bit between 0 and bit_pos inclusive is not zero. */
static inline limb_t scan_bit_nz(const bf_t *r, slimb_t bit_pos)
{
    slimb_t pos;
    limb_t v;
    
    pos = bit_pos >> LIMB_LOG2_BITS;
    if (pos < 0)
        return 0;
    v = r->tab[pos] & limb_mask(0, bit_pos & (LIMB_BITS - 1));
    if (v != 0)
        return 1;
    pos--;
    while (pos >= 0) {
        if (r->tab[pos] != 0)
            return 1;
        pos--;
    }
    return 0;
}

/* return the addend for rounding. Note that prec can be <= 0 (for
   BF_FLAG_RADPNT_PREC) */
static int bf_get_rnd_add(int *pret, const bf_t *r, limb_t l,
                          slimb_t prec, int rnd_mode)
{
    int add_one, inexact;
    limb_t bit1, bit0;
    
    if (rnd_mode == BF_RNDF) {
        bit0 = 1; /* faithful rounding does not honor the INEXACT flag */
    } else {
        /* starting limb for bit 'prec + 1' */
        bit0 = scan_bit_nz(r, l * LIMB_BITS - 1 - bf_max(0, prec + 1));
    }

    /* get the bit at 'prec' */
    bit1 = get_bit(r->tab, l, l * LIMB_BITS - 1 - prec);
    inexact = (bit1 | bit0) != 0;
    
    add_one = 0;
    switch(rnd_mode) {
    case BF_RNDZ:
        break;
    case BF_RNDN:
        if (bit1) {
            if (bit0) {
                add_one = 1;
            } else {
                /* round to even */
                add_one =
                    get_bit(r->tab, l, l * LIMB_BITS - 1 - (prec - 1));
            }
        }
        break;
    case BF_RNDD:
    case BF_RNDU:
        if (r->sign == (rnd_mode == BF_RNDD))
            add_one = inexact;
        break;
    case BF_RNDA:
        add_one = inexact;
        break;
    case BF_RNDNA:
    case BF_RNDF:
        add_one = bit1;
        break;
    default:
        abort();
    }
    
    if (inexact)
        *pret |= BF_ST_INEXACT;
    return add_one;
}

static int bf_set_overflow(bf_t *r, int sign, limb_t prec, bf_flags_t flags)
{
    slimb_t i, l, e_max;
    int rnd_mode;
    
    rnd_mode = flags & BF_RND_MASK;
    if (prec == BF_PREC_INF ||
        rnd_mode == BF_RNDN ||
        rnd_mode == BF_RNDNA ||
        rnd_mode == BF_RNDA ||
        (rnd_mode == BF_RNDD && sign == 1) ||
        (rnd_mode == BF_RNDU && sign == 0)) {
        bf_set_inf(r, sign);
    } else {
        /* set to maximum finite number */
        l = (prec + LIMB_BITS - 1) / LIMB_BITS;
        if (bf_resize(r, l)) {
            bf_set_nan(r);
            return BF_ST_MEM_ERROR;
        }
        r->tab[0] = limb_mask((-prec) & (LIMB_BITS - 1),
                              LIMB_BITS - 1);
        for(i = 1; i < l; i++)
            r->tab[i] = (limb_t)-1;
        e_max = (limb_t)1 << (bf_get_exp_bits(flags) - 1);
        r->expn = e_max;
        r->sign = sign;
    }
    return BF_ST_OVERFLOW | BF_ST_INEXACT;
}

/* round to prec1 bits assuming 'r' is non zero and finite. 'r' is
   assumed to have length 'l' (1 <= l <= r->len). Note: 'prec1' can be
   infinite (BF_PREC_INF). 'ret' is 0 or BF_ST_INEXACT if the result
   is known to be inexact. Can fail with BF_ST_MEM_ERROR in case of
   overflow not returning infinity. */
static int __bf_round(bf_t *r, limb_t prec1, bf_flags_t flags, limb_t l,
                      int ret)
{
    limb_t v, a;
    int shift, add_one, rnd_mode;
    slimb_t i, bit_pos, pos, e_min, e_max, e_range, prec;

    /* e_min and e_max are computed to match the IEEE 754 conventions */
    e_range = (limb_t)1 << (bf_get_exp_bits(flags) - 1);
    e_min = -e_range + 3;
    e_max = e_range;
    
    if (flags & BF_FLAG_RADPNT_PREC) {
        /* 'prec' is the precision after the radix point */
        if (prec1 != BF_PREC_INF)
            prec = r->expn + prec1;
        else
            prec = prec1;
    } else if (unlikely(r->expn < e_min) && (flags & BF_FLAG_SUBNORMAL)) {
        /* restrict the precision in case of potentially subnormal
           result */
        assert(prec1 != BF_PREC_INF);
        prec = prec1 - (e_min - r->expn);
    } else {
        prec = prec1;
    }

    /* round to prec bits */
    rnd_mode = flags & BF_RND_MASK;
    add_one = bf_get_rnd_add(&ret, r, l, prec, rnd_mode);
    
    if (prec <= 0) {
        if (add_one) {
            bf_resize(r, 1); /* cannot fail */
            r->tab[0] = (limb_t)1 << (LIMB_BITS - 1);
            r->expn += 1 - prec;
            ret |= BF_ST_UNDERFLOW | BF_ST_INEXACT;
            return ret;
        } else {
            goto underflow;
        }
    } else if (add_one) {
        limb_t carry;
        
        /* add one starting at digit 'prec - 1' */
        bit_pos = l * LIMB_BITS - 1 - (prec - 1);
        pos = bit_pos >> LIMB_LOG2_BITS;
        carry = (limb_t)1 << (bit_pos & (LIMB_BITS - 1));
        
        for(i = pos; i < l; i++) {
            v = r->tab[i] + carry;
            carry = (v < carry);
            r->tab[i] = v;
            if (carry == 0)
                break;
        }
        if (carry) {
            /* shift right by one digit */
            v = 1;
            for(i = l - 1; i >= pos; i--) {
                a = r->tab[i];
                r->tab[i] = (a >> 1) | (v << (LIMB_BITS - 1));
                v = a;
            }
            r->expn++;
        }
    }
    
    /* check underflow */
    if (unlikely(r->expn < e_min)) {
        if (flags & BF_FLAG_SUBNORMAL) {
            /* if inexact, also set the underflow flag */
            if (ret & BF_ST_INEXACT)
                ret |= BF_ST_UNDERFLOW;
        } else {
        underflow:
            ret |= BF_ST_UNDERFLOW | BF_ST_INEXACT;
            bf_set_zero(r, r->sign);
            return ret;
        }
    }
    
    /* check overflow */
    if (unlikely(r->expn > e_max))
        return bf_set_overflow(r, r->sign, prec1, flags);
    
    /* keep the bits starting at 'prec - 1' */
    bit_pos = l * LIMB_BITS - 1 - (prec - 1);
    i = bit_pos >> LIMB_LOG2_BITS;
    if (i >= 0) {
        shift = bit_pos & (LIMB_BITS - 1);
        if (shift != 0)
            r->tab[i] &= limb_mask(shift, LIMB_BITS - 1);
    } else {
        i = 0;
    }
    /* remove trailing zeros */
    while (r->tab[i] == 0)
        i++;
    if (i > 0) {
        l -= i;
        memmove(r->tab, r->tab + i, l * sizeof(limb_t));
    }
    bf_resize(r, l); /* cannot fail */
    return ret;
}

/* 'r' must be a finite number. */
int bf_normalize_and_round(bf_t *r, limb_t prec1, bf_flags_t flags)
{
    limb_t l, v, a;
    int shift, ret;
    slimb_t i;
    
    //    bf_print_str("bf_renorm", r);
    l = r->len;
    while (l > 0 && r->tab[l - 1] == 0)
        l--;
    if (l == 0) {
        /* zero */
        r->expn = BF_EXP_ZERO;
        bf_resize(r, 0); /* cannot fail */
        ret = 0;
    } else {
        r->expn -= (r->len - l) * LIMB_BITS;
        /* shift to have the MSB set to '1' */
        v = r->tab[l - 1];
        shift = clz(v);
        if (shift != 0) {
            v = 0;
            for(i = 0; i < l; i++) {
                a = r->tab[i];
                r->tab[i] = (a << shift) | (v >> (LIMB_BITS - shift));
                v = a;
            }
            r->expn -= shift;
        }
        ret = __bf_round(r, prec1, flags, l, 0);
    }
    //    bf_print_str("r_final", r);
    return ret;
}

/* return true if rounding can be done at precision 'prec' assuming
   the exact result r is such that |r-a| <= 2^(EXP(a)-k). */
/* XXX: check the case where the exponent would be incremented by the
   rounding */
int bf_can_round(const bf_t *a, slimb_t prec, bf_rnd_t rnd_mode, slimb_t k)
{
    BOOL is_rndn;
    slimb_t bit_pos, n;
    limb_t bit;
    
    if (a->expn == BF_EXP_INF || a->expn == BF_EXP_NAN)
        return FALSE;
    if (rnd_mode == BF_RNDF) {
        return (k >= (prec + 1));
    }
    if (a->expn == BF_EXP_ZERO)
        return FALSE;
    is_rndn = (rnd_mode == BF_RNDN || rnd_mode == BF_RNDNA);
    if (k < (prec + 2))
        return FALSE;
    bit_pos = a->len * LIMB_BITS - 1 - prec;
    n = k - prec;
    /* bit pattern for RNDN or RNDNA: 0111.. or 1000...
       for other rounding modes: 000... or 111... 
    */
    bit = get_bit(a->tab, a->len, bit_pos);
    bit_pos--;
    n--;
    bit ^= is_rndn;
    /* XXX: slow, but a few iterations on average */
    while (n != 0) {
        if (get_bit(a->tab, a->len, bit_pos) != bit)
            return TRUE;
        bit_pos--;
        n--;
    }
    return FALSE;
}

/* Cannot fail with BF_ST_MEM_ERROR. */
int bf_round(bf_t *r, limb_t prec, bf_flags_t flags)
{
    if (r->len == 0)
        return 0;
    return __bf_round(r, prec, flags, r->len, 0);
}

/* for debugging */
static __maybe_unused void dump_limbs(const char *str, const limb_t *tab, limb_t n)
{
    limb_t i;
    printf("%s: len=%" PRId_LIMB "\n", str, n);
    for(i = 0; i < n; i++) {
        printf("%" PRId_LIMB ": " FMT_LIMB "\n",
               i, tab[i]);
    }
}

void mp_print_str(const char *str, const limb_t *tab, limb_t n)
{
    slimb_t i;
    printf("%s= 0x", str);
    for(i = n - 1; i >= 0; i--) {
        if (i != (n - 1))
            printf("_");
        printf(FMT_LIMB, tab[i]);
    }
    printf("\n");
}

static __maybe_unused void mp_print_str_h(const char *str,
                                          const limb_t *tab, limb_t n,
                                          limb_t high)
{
    slimb_t i;
    printf("%s= 0x", str);
    printf(FMT_LIMB, high);
    for(i = n - 1; i >= 0; i--) {
        printf("_");
        printf(FMT_LIMB, tab[i]);
    }
    printf("\n");
}

/* for debugging */
void bf_print_str(const char *str, const bf_t *a)
{
    slimb_t i;
    printf("%s=", str);

    if (a->expn == BF_EXP_NAN) {
        printf("NaN");
    } else {
        if (a->sign)
            putchar('-');
        if (a->expn == BF_EXP_ZERO) {
            putchar('0');
        } else if (a->expn == BF_EXP_INF) {
            printf("Inf");
        } else {
            printf("0x0.");
            for(i = a->len - 1; i >= 0; i--)
                printf(FMT_LIMB, a->tab[i]);
            printf("p%" PRId_LIMB, a->expn);
        }
    }
    printf("\n");
}

/* compare the absolute value of 'a' and 'b'. Return < 0 if a < b, 0
   if a = b and > 0 otherwise. */
int bf_cmpu(const bf_t *a, const bf_t *b)
{
    slimb_t i;
    limb_t len, v1, v2;
    
    if (a->expn != b->expn) {
        if (a->expn < b->expn)
            return -1;
        else
            return 1;
    }
    len = bf_max(a->len, b->len);
    for(i = len - 1; i >= 0; i--) {
        v1 = get_limbz(a, a->len - len + i);
        v2 = get_limbz(b, b->len - len + i);
        if (v1 != v2) {
            if (v1 < v2)
                return -1;
            else
                return 1;
        }
    }
    return 0;
}

/* Full order: -0 < 0, NaN == NaN and NaN is larger than all other numbers */
int bf_cmp_full(const bf_t *a, const bf_t *b)
{
    int res;
    
    if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {
        if (a->expn == b->expn)
            res = 0;
        else if (a->expn == BF_EXP_NAN)
            res = 1;
        else
            res = -1;
    } else if (a->sign != b->sign) {
        res = 1 - 2 * a->sign;
    } else {
        res = bf_cmpu(a, b);
        if (a->sign)
            res = -res;
    }
    return res;
}

/* Standard floating point comparison: return 2 if one of the operands
   is NaN (unordered) or -1, 0, 1 depending on the ordering assuming
   -0 == +0 */
int bf_cmp(const bf_t *a, const bf_t *b)
{
    int res;
    
    if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {
        res = 2;
    } else if (a->sign != b->sign) {
        if (a->expn == BF_EXP_ZERO && b->expn == BF_EXP_ZERO)
            res = 0;
        else
            res = 1 - 2 * a->sign;
    } else {
        res = bf_cmpu(a, b);
        if (a->sign)
            res = -res;
    }
    return res;
}

/* Compute the number of bits 'n' matching the pattern:
   a= X1000..0
   b= X0111..1
              
   When computing a-b, the result will have at least n leading zero
   bits.

   Precondition: a > b and a.expn - b.expn = 0 or 1
*/
static limb_t count_cancelled_bits(const bf_t *a, const bf_t *b)
{
    slimb_t bit_offset, b_offset, n;
    int p, p1;
    limb_t v1, v2, mask;

    bit_offset = a->len * LIMB_BITS - 1;
    b_offset = (b->len - a->len) * LIMB_BITS - (LIMB_BITS - 1) +
        a->expn - b->expn;
    n = 0;

    /* first search the equals bits */
    for(;;) {
        v1 = get_limbz(a, bit_offset >> LIMB_LOG2_BITS);
        v2 = get_bits(b->tab, b->len, bit_offset + b_offset);
        //        printf("v1=" FMT_LIMB " v2=" FMT_LIMB "\n", v1, v2);
        if (v1 != v2)
            break;
        n += LIMB_BITS;
        bit_offset -= LIMB_BITS;
    }
    /* find the position of the first different bit */
    p = clz(v1 ^ v2) + 1;
    n += p;
    /* then search for '0' in a and '1' in b */
    p = LIMB_BITS - p;
    if (p > 0) {
        /* search in the trailing p bits of v1 and v2 */
        mask = limb_mask(0, p - 1);
        p1 = bf_min(clz(v1 & mask), clz((~v2) & mask)) - (LIMB_BITS - p);
        n += p1;
        if (p1 != p)
            goto done;
    }
    bit_offset -= LIMB_BITS;
    for(;;) {
        v1 = get_limbz(a, bit_offset >> LIMB_LOG2_BITS);
        v2 = get_bits(b->tab, b->len, bit_offset + b_offset);
        //        printf("v1=" FMT_LIMB " v2=" FMT_LIMB "\n", v1, v2);
        if (v1 != 0 || v2 != -1) {
            /* different: count the matching bits */
            p1 = bf_min(clz(v1), clz(~v2));
            n += p1;
            break;
        }
        n += LIMB_BITS;
        bit_offset -= LIMB_BITS;
    }
 done:
    return n;
}

static int bf_add_internal(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
                           bf_flags_t flags, int b_neg)
{
    const bf_t *tmp;
    int is_sub, ret, cmp_res, a_sign, b_sign;

    a_sign = a->sign;
    b_sign = b->sign ^ b_neg;
    is_sub = a_sign ^ b_sign;
    cmp_res = bf_cmpu(a, b);
    if (cmp_res < 0) {
        tmp = a;
        a = b;
        b = tmp;
        a_sign = b_sign; /* b_sign is never used later */
    }
    /* abs(a) >= abs(b) */
    if (cmp_res == 0 && is_sub && a->expn < BF_EXP_INF) {
        /* zero result */
        bf_set_zero(r, (flags & BF_RND_MASK) == BF_RNDD);
        ret = 0;
    } else if (a->len == 0 || b->len == 0) {
        ret = 0;
        if (a->expn >= BF_EXP_INF) {
            if (a->expn == BF_EXP_NAN) {
                /* at least one operand is NaN */
                bf_set_nan(r);
            } else if (b->expn == BF_EXP_INF && is_sub) {
                /* infinities with different signs */
                bf_set_nan(r);
                ret = BF_ST_INVALID_OP;
            } else {
                bf_set_inf(r, a_sign);
            }
        } else {
            /* at least one zero and not subtract */
            bf_set(r, a);
            r->sign = a_sign;
            goto renorm;
        }
    } else {
        slimb_t d, a_offset, b_bit_offset, i, cancelled_bits;
        limb_t carry, v1, v2, u, r_len, carry1, precl, tot_len, z, sub_mask;

        r->sign = a_sign;
        r->expn = a->expn;
        d = a->expn - b->expn;
        /* must add more precision for the leading cancelled bits in
           subtraction */
        if (is_sub) {
            if (d <= 1)
                cancelled_bits = count_cancelled_bits(a, b);
            else
                cancelled_bits = 1;
        } else {
            cancelled_bits = 0;
        }
        
        /* add two extra bits for rounding */
        precl = (cancelled_bits + prec + 2 + LIMB_BITS - 1) / LIMB_BITS;
        tot_len = bf_max(a->len, b->len + (d + LIMB_BITS - 1) / LIMB_BITS);
        r_len = bf_min(precl, tot_len);
        if (bf_resize(r, r_len))
            goto fail;
        a_offset = a->len - r_len;
        b_bit_offset = (b->len - r_len) * LIMB_BITS + d;

        /* compute the bits before for the rounding */
        carry = is_sub;
        z = 0;
        sub_mask = -is_sub;
        i = r_len - tot_len;
        while (i < 0) {
            slimb_t ap, bp;
            BOOL inflag;
            
            ap = a_offset + i;
            bp = b_bit_offset + i * LIMB_BITS;
            inflag = FALSE;
            if (ap >= 0 && ap < a->len) {
                v1 = a->tab[ap];
                inflag = TRUE;
            } else {
                v1 = 0;
            }
            if (bp + LIMB_BITS > 0 && bp < (slimb_t)(b->len * LIMB_BITS)) {
                v2 = get_bits(b->tab, b->len, bp);
                inflag = TRUE;
            } else {
                v2 = 0;
            }
            if (!inflag) {
                /* outside 'a' and 'b': go directly to the next value
                   inside a or b so that the running time does not
                   depend on the exponent difference */
                i = 0;
                if (ap < 0)
                    i = bf_min(i, -a_offset);
                /* b_bit_offset + i * LIMB_BITS + LIMB_BITS >= 1
                   equivalent to 
                   i >= ceil(-b_bit_offset + 1 - LIMB_BITS) / LIMB_BITS)
                */
                if (bp + LIMB_BITS <= 0)
                    i = bf_min(i, (-b_bit_offset) >> LIMB_LOG2_BITS);
            } else {
                i++;
            }
            v2 ^= sub_mask;
            u = v1 + v2;
            carry1 = u < v1;
            u += carry;
            carry = (u < carry) | carry1;
            z |= u;
        }
        /* and the result */
        for(i = 0; i < r_len; i++) {
            v1 = get_limbz(a, a_offset + i);
            v2 = get_bits(b->tab, b->len, b_bit_offset + i * LIMB_BITS);
            v2 ^= sub_mask;
            u = v1 + v2;
            carry1 = u < v1;
            u += carry;
            carry = (u < carry) | carry1;
            r->tab[i] = u;
        }
        /* set the extra bits for the rounding */
        r->tab[0] |= (z != 0);

        /* carry is only possible in add case */
        if (!is_sub && carry) {
            if (bf_resize(r, r_len + 1))
                goto fail;
            r->tab[r_len] = 1;
            r->expn += LIMB_BITS;
        }
    renorm:
        ret = bf_normalize_and_round(r, prec, flags);
    }
    return ret;
 fail:
    bf_set_nan(r);
    return BF_ST_MEM_ERROR;
}

static int __bf_add(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
                     bf_flags_t flags)
{
    return bf_add_internal(r, a, b, prec, flags, 0);
}

static int __bf_sub(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
                     bf_flags_t flags)
{
    return bf_add_internal(r, a, b, prec, flags, 1);
}

limb_t mp_add(limb_t *res, const limb_t *op1, const limb_t *op2, 
              limb_t n, limb_t carry)
{
    slimb_t i;
    limb_t k, a, v, k1;
    
    k = carry;
    for(i=0;i<n;i++) {
        v = op1[i];
        a = v + op2[i];
        k1 = a < v;
        a = a + k;
        k = (a < k) | k1;
        res[i] = a;
    }
    return k;
}

limb_t mp_add_ui(limb_t *tab, limb_t b, size_t n)
{
    size_t i;
    limb_t k, a;

    k=b;
    for(i=0;i<n;i++) {
        if (k == 0)
            break;
        a = tab[i] + k;
        k = (a < k);
        tab[i] = a;
    }
    return k;
}

limb_t mp_sub(limb_t *res, const limb_t *op1, const limb_t *op2, 
              mp_size_t n, limb_t carry)
{
    int i;
    limb_t k, a, v, k1;
    
    k = carry;
    for(i=0;i<n;i++) {
        v = op1[i];
        a = v - op2[i];
        k1 = a > v;
        v = a - k;
        k = (v > a) | k1;
        res[i] = v;
    }
    return k;
}

/* compute 0 - op2 */
static limb_t mp_neg(limb_t *res, const limb_t *op2, mp_size_t n, limb_t carry)
{
    int i;
    limb_t k, a, v, k1;
    
    k = carry;
    for(i=0;i<n;i++) {
        v = 0;
        a = v - op2[i];
        k1 = a > v;
        v = a - k;
        k = (v > a) | k1;
        res[i] = v;
    }
    return k;
}

limb_t mp_sub_ui(limb_t *tab, limb_t b, mp_size_t n)
{
    mp_size_t i;
    limb_t k, a, v;
    
    k=b;
    for(i=0;i<n;i++) {
        v = tab[i];
        a = v - k;
        k = a > v;
        tab[i] = a;
        if (k == 0)
            break;
    }
    return k;
}

/* r = (a + high*B^n) >> shift. Return the remainder r (0 <= r < 2^shift). 
   1 <= shift <= LIMB_BITS - 1 */
static limb_t mp_shr(limb_t *tab_r, const limb_t *tab, mp_size_t n, 
                     int shift, limb_t high)
{
    mp_size_t i;
    limb_t l, a;

    assert(shift >= 1 && shift < LIMB_BITS);
    l = high;
    for(i = n - 1; i >= 0; i--) {
        a = tab[i];
        tab_r[i] = (a >> shift) | (l << (LIMB_BITS - shift));
        l = a;
    }
    return l & (((limb_t)1 << shift) - 1);
}

/* tabr[] = taba[] * b + l. Return the high carry */
static limb_t mp_mul1(limb_t *tabr, const limb_t *taba, limb_t n, 
                      limb_t b, limb_t l)
{
    limb_t i;
    dlimb_t t;

    for(i = 0; i < n; i++) {
        t = (dlimb_t)taba[i] * (dlimb_t)b + l;
        tabr[i] = t;
        l = t >> LIMB_BITS;
    }
    return l;
}

/* tabr[] += taba[] * b, return the high word. */
static limb_t mp_add_mul1(limb_t *tabr, const limb_t *taba, limb_t n,
                          limb_t b)
{
    limb_t i, l;
    dlimb_t t;
    
    l = 0;
    for(i = 0; i < n; i++) {
        t = (dlimb_t)taba[i] * (dlimb_t)b + l + tabr[i];
        tabr[i] = t;
        l = t >> LIMB_BITS;
    }
    return l;
}

/* size of the result : op1_size + op2_size. */
static void mp_mul_basecase(limb_t *result, 
                            const limb_t *op1, limb_t op1_size, 
                            const limb_t *op2, limb_t op2_size) 
{
    limb_t i, r;
    
    result[op1_size] = mp_mul1(result, op1, op1_size, op2[0], 0);
    for(i=1;i<op2_size;i++) {
        r = mp_add_mul1(result + i, op1, op1_size, op2[i]);
        result[i + op1_size] = r;
    }
}

/* return 0 if OK, -1 if memory error */
/* XXX: change API so that result can be allocated */
int mp_mul(bf_context_t *s, limb_t *result, 
           const limb_t *op1, limb_t op1_size, 
           const limb_t *op2, limb_t op2_size) 
{
#ifdef USE_FFT_MUL
    if (unlikely(bf_min(op1_size, op2_size) >= FFT_MUL_THRESHOLD)) {
        bf_t r_s, *r = &r_s;
        r->tab = result;
        /* XXX: optimize memory usage in API */
        if (fft_mul(s, r, (limb_t *)op1, op1_size,
                    (limb_t *)op2, op2_size, FFT_MUL_R_NORESIZE))
            return -1;
    } else
#endif
    {
        mp_mul_basecase(result, op1, op1_size, op2, op2_size);
    }
    return 0;
}

/* tabr[] -= taba[] * b. Return the value to substract to the high
   word. */
static limb_t mp_sub_mul1(limb_t *tabr, const limb_t *taba, limb_t n,
                          limb_t b)
{
    limb_t i, l;
    dlimb_t t;
    
    l = 0;
    for(i = 0; i < n; i++) {
        t = tabr[i] - (dlimb_t)taba[i] * (dlimb_t)b - l;
        tabr[i] = t;
        l = -(t >> LIMB_BITS);
    }
    return l;
}

/* WARNING: d must be >= 2^(LIMB_BITS-1) */
static inline limb_t udiv1norm_init(limb_t d)
{
    limb_t a0, a1;
    a1 = -d - 1;
    a0 = -1;
    return (((dlimb_t)a1 << LIMB_BITS) | a0) / d;
}

/* return the quotient and the remainder in '*pr'of 'a1*2^LIMB_BITS+a0
   / d' with 0 <= a1 < d. */
static inline limb_t udiv1norm(limb_t *pr, limb_t a1, limb_t a0,
                                limb_t d, limb_t d_inv)
{
    limb_t n1m, n_adj, q, r, ah;
    dlimb_t a;
    n1m = ((slimb_t)a0 >> (LIMB_BITS - 1));
    n_adj = a0 + (n1m & d);
    a = (dlimb_t)d_inv * (a1 - n1m) + n_adj;
    q = (a >> LIMB_BITS) + a1;
    /* compute a - q * r and update q so that the remainder is\
       between 0 and d - 1 */
    a = ((dlimb_t)a1 << LIMB_BITS) | a0;
    a = a - (dlimb_t)q * d - d;
    ah = a >> LIMB_BITS;
    q += 1 + ah;
    r = (limb_t)a + (ah & d);
    *pr = r;
    return q;
}

/* b must be >= 1 << (LIMB_BITS - 1) */
static limb_t mp_div1norm(limb_t *tabr, const limb_t *taba, limb_t n,
                          limb_t b, limb_t r)
{
    slimb_t i;

    if (n >= UDIV1NORM_THRESHOLD) {
        limb_t b_inv;
        b_inv = udiv1norm_init(b);
        for(i = n - 1; i >= 0; i--) {
            tabr[i] = udiv1norm(&r, r, taba[i], b, b_inv);
        }
    } else {
        dlimb_t a1;
        for(i = n - 1; i >= 0; i--) {
            a1 = ((dlimb_t)r << LIMB_BITS) | taba[i];
            tabr[i] = a1 / b;
            r = a1 % b;
        }
    }
    return r;
}

static int mp_divnorm_large(bf_context_t *s, 
                            limb_t *tabq, limb_t *taba, limb_t na, 
                            const limb_t *tabb, limb_t nb);

/* base case division: divides taba[0..na-1] by tabb[0..nb-1]. tabb[nb
   - 1] must be >= 1 << (LIMB_BITS - 1). na - nb must be >= 0. 'taba'
   is modified and contains the remainder (nb limbs). tabq[0..na-nb]
   contains the quotient with tabq[na - nb] <= 1. */
static int mp_divnorm(bf_context_t *s, limb_t *tabq, limb_t *taba, limb_t na, 
                      const limb_t *tabb, limb_t nb)
{
    limb_t r, a, c, q, v, b1, b1_inv, n, dummy_r;
    slimb_t i, j;

    b1 = tabb[nb - 1];
    if (nb == 1) {
        taba[0] = mp_div1norm(tabq, taba, na, b1, 0);
        return 0;
    }
    n = na - nb;
    if (bf_min(n, nb) >= DIVNORM_LARGE_THRESHOLD) {
        return mp_divnorm_large(s, tabq, taba, na, tabb, nb);
    }
    
    if (n >= UDIV1NORM_THRESHOLD)
        b1_inv = udiv1norm_init(b1);
    else
        b1_inv = 0;

    /* first iteration: the quotient is only 0 or 1 */
    q = 1;
    for(j = nb - 1; j >= 0; j--) {
        if (taba[n + j] != tabb[j]) {
            if (taba[n + j] < tabb[j])
                q = 0;
            break;
        }
    }
    tabq[n] = q;
    if (q) {
        mp_sub(taba + n, taba + n, tabb, nb, 0);
    }
    
    for(i = n - 1; i >= 0; i--) {
        if (unlikely(taba[i + nb] >= b1)) {
            q = -1;
        } else if (b1_inv) {
            q = udiv1norm(&dummy_r, taba[i + nb], taba[i + nb - 1], b1, b1_inv);
        } else {
            dlimb_t al;
            al = ((dlimb_t)taba[i + nb] << LIMB_BITS) | taba[i + nb - 1];
            q = al / b1;
            r = al % b1;
        }
        r = mp_sub_mul1(taba + i, tabb, nb, q);

        v = taba[i + nb];
        a = v - r;
        c = (a > v);
        taba[i + nb] = a;

        if (c != 0) {
            /* negative result */
            for(;;) {
                q--;
                c = mp_add(taba + i, taba + i, tabb, nb, 0);
                /* propagate carry and test if positive result */
                if (c != 0) {
                    if (++taba[i + nb] == 0) {
                        break;
                    }
                }
            }
        }
        tabq[i] = q;
    }
    return 0;
}

/* compute r=B^(2*n)/a such as a*r < B^(2*n) < a*r + 2 with n >= 1. 'a'
   has n limbs with a[n-1] >= B/2 and 'r' has n+1 limbs with r[n] = 1.
   
   See Modern Computer Arithmetic by Richard P. Brent and Paul
   Zimmermann, algorithm 3.5 */
int mp_recip(bf_context_t *s, limb_t *tabr, const limb_t *taba, limb_t n)
{
    mp_size_t l, h, k, i;
    limb_t *tabxh, *tabt, c, *tabu;
    
    if (n <= 2) {
        /* return ceil(B^(2*n)/a) - 1 */
        /* XXX: could avoid allocation */
        tabu = bf_malloc(s, sizeof(limb_t) * (2 * n + 1));
        tabt = bf_malloc(s, sizeof(limb_t) * (n + 2));
        if (!tabt || !tabu)
            goto fail;
        for(i = 0; i < 2 * n; i++)
            tabu[i] = 0;
        tabu[2 * n] = 1;
        if (mp_divnorm(s, tabt, tabu, 2 * n + 1, taba, n))
            goto fail;
        for(i = 0; i < n + 1; i++)
            tabr[i] = tabt[i];
        if (mp_scan_nz(tabu, n) == 0) {
            /* only happens for a=B^n/2 */
            mp_sub_ui(tabr, 1, n + 1);
        }
    } else {
        l = (n - 1) / 2;
        h = n - l;
        /* n=2p  -> l=p-1, h = p + 1, k = p + 3
           n=2p+1-> l=p,  h = p + 1; k = p + 2
        */
        tabt = bf_malloc(s, sizeof(limb_t) * (n + h + 1));
        tabu = bf_malloc(s, sizeof(limb_t) * (n + 2 * h - l + 2));
        if (!tabt || !tabu)
            goto fail;
        tabxh = tabr + l;
        if (mp_recip(s, tabxh, taba + l, h))
            goto fail;
        if (mp_mul(s, tabt, taba, n, tabxh, h + 1)) /* n + h + 1 limbs */
            goto fail;
        while (tabt[n + h] != 0) {
            mp_sub_ui(tabxh, 1, h + 1);
            c = mp_sub(tabt, tabt, taba, n, 0);
            mp_sub_ui(tabt + n, c, h + 1);
        }
        /* T = B^(n+h) - T */
        mp_neg(tabt, tabt, n + h + 1, 0);
        tabt[n + h]++;
        if (mp_mul(s, tabu, tabt + l, n + h + 1 - l, tabxh, h + 1))
            goto fail;
        /* n + 2*h - l + 2 limbs */
        k = 2 * h - l;
        for(i = 0; i < l; i++)
            tabr[i] = tabu[i + k];
        mp_add(tabr + l, tabr + l, tabu + 2 * h, h, 0);
    }
    bf_free(s, tabt);
    bf_free(s, tabu);
    return 0;
 fail:
    bf_free(s, tabt);
    bf_free(s, tabu);
    return -1;
}

/* return -1, 0 or 1 */
static int mp_cmp(const limb_t *taba, const limb_t *tabb, mp_size_t n)
{
    mp_size_t i;
    for(i = n - 1; i >= 0; i--) {
        if (taba[i] != tabb[i]) {
            if (taba[i] < tabb[i])
                return -1;
            else
                return 1;
        }
    }
    return 0;
}

//#define DEBUG_DIVNORM_LARGE
//#define DEBUG_DIVNORM_LARGE2

/* subquadratic divnorm */
static int mp_divnorm_large(bf_context_t *s, 
                            limb_t *tabq, limb_t *taba, limb_t na, 
                            const limb_t *tabb, limb_t nb)
{
    limb_t *tabb_inv, nq, *tabt, i, n;
    nq = na - nb;
#ifdef DEBUG_DIVNORM_LARGE
    printf("na=%d nb=%d nq=%d\n", (int)na, (int)nb, (int)nq);
    mp_print_str("a", taba, na);
    mp_print_str("b", tabb, nb);
#endif
    assert(nq >= 1);
    n = nq;
    if (nq < nb)
        n++; 
    tabb_inv = bf_malloc(s, sizeof(limb_t) * (n + 1));
    tabt = bf_malloc(s, sizeof(limb_t) * 2 * (n + 1));
    if (!tabb_inv || !tabt)
        goto fail;

    if (n >= nb) {
        for(i = 0; i < n - nb; i++)
            tabt[i] = 0;
        for(i = 0; i < nb; i++)
            tabt[i + n - nb] = tabb[i];
    } else {
        /* truncate B: need to increment it so that the approximate
           inverse is smaller that the exact inverse */
        for(i = 0; i < n; i++)
            tabt[i] = tabb[i + nb - n];
        if (mp_add_ui(tabt, 1, n)) {
            /* tabt = B^n : tabb_inv = B^n */
            memset(tabb_inv, 0, n * sizeof(limb_t));
            tabb_inv[n] = 1;
            goto recip_done;
        }
    }
    if (mp_recip(s, tabb_inv, tabt, n))
        goto fail;
 recip_done:
    /* Q=A*B^-1 */
    if (mp_mul(s, tabt, tabb_inv, n + 1, taba + na - (n + 1), n + 1))
        goto fail;
    
    for(i = 0; i < nq + 1; i++)
        tabq[i] = tabt[i + 2 * (n + 1) - (nq + 1)];
#ifdef DEBUG_DIVNORM_LARGE
    mp_print_str("q", tabq, nq + 1);
#endif

    bf_free(s, tabt);
    bf_free(s, tabb_inv);
    tabb_inv = NULL;
    
    /* R=A-B*Q */
    tabt = bf_malloc(s, sizeof(limb_t) * (na + 1));
    if (!tabt)
        goto fail;
    if (mp_mul(s, tabt, tabq, nq + 1, tabb, nb))
        goto fail;
    /* we add one more limb for the result */
    mp_sub(taba, taba, tabt, nb + 1, 0);
    bf_free(s, tabt);
    /* the approximated quotient is smaller than than the exact one,
       hence we may have to increment it */
#ifdef DEBUG_DIVNORM_LARGE2
    int cnt = 0;
    static int cnt_max;
#endif
    for(;;) {
        if (taba[nb] == 0 && mp_cmp(taba, tabb, nb) < 0)
            break;
        taba[nb] -= mp_sub(taba, taba, tabb, nb, 0);
        mp_add_ui(tabq, 1, nq + 1);
#ifdef DEBUG_DIVNORM_LARGE2
        cnt++;
#endif
    }
#ifdef DEBUG_DIVNORM_LARGE2
    if (cnt > cnt_max) {
        cnt_max = cnt;
        printf("\ncnt=%d nq=%d nb=%d\n", cnt_max, (int)nq, (int)nb);
    }
#endif
    return 0;
 fail:
    bf_free(s, tabb_inv);
    bf_free(s, tabt);
    return -1;
}

int bf_mul(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
           bf_flags_t flags)
{
    int ret, r_sign;

    if (a->len < b->len) {
        const bf_t *tmp = a;
        a = b;
        b = tmp;
    }
    r_sign = a->sign ^ b->sign;
    /* here b->len <= a->len */
    if (b->len == 0) {
        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {
            bf_set_nan(r);
            ret = 0;
        } else if (a->expn == BF_EXP_INF || b->expn == BF_EXP_INF) {
            if ((a->expn == BF_EXP_INF && b->expn == BF_EXP_ZERO) ||
                (a->expn == BF_EXP_ZERO && b->expn == BF_EXP_INF)) {
                bf_set_nan(r);
                ret = BF_ST_INVALID_OP;
            } else {
                bf_set_inf(r, r_sign);
                ret = 0;
            }
        } else {
            bf_set_zero(r, r_sign);
            ret = 0;
        }
    } else {
        bf_t tmp, *r1 = NULL;
        limb_t a_len, b_len, precl;
        limb_t *a_tab, *b_tab;
            
        a_len = a->len;
        b_len = b->len;
        
        if ((flags & BF_RND_MASK) == BF_RNDF) {
            /* faithful rounding does not require using the full inputs */
            precl = (prec + 2 + LIMB_BITS - 1) / LIMB_BITS;
            a_len = bf_min(a_len, precl);
            b_len = bf_min(b_len, precl);
        }
        a_tab = a->tab + a->len - a_len;
        b_tab = b->tab + b->len - b_len;
        
#ifdef USE_FFT_MUL
        if (b_len >= FFT_MUL_THRESHOLD) {
            int mul_flags = 0;
            if (r == a)
                mul_flags |= FFT_MUL_R_OVERLAP_A;
            if (r == b)
                mul_flags |= FFT_MUL_R_OVERLAP_B;
            if (fft_mul(r->ctx, r, a_tab, a_len, b_tab, b_len, mul_flags))
                goto fail;
        } else
#endif
        {
            if (r == a || r == b) {
                bf_init(r->ctx, &tmp);
                r1 = r;
                r = &tmp;
            }
            if (bf_resize(r, a_len + b_len)) {
            fail:
                bf_set_nan(r);
                ret = BF_ST_MEM_ERROR;
                goto done;
            }
            mp_mul_basecase(r->tab, a_tab, a_len, b_tab, b_len);
        }
        r->sign = r_sign;
        r->expn = a->expn + b->expn;
        ret = bf_normalize_and_round(r, prec, flags);
    done:
        if (r == &tmp)
            bf_move(r1, &tmp);
    }
    return ret;
}

/* multiply 'r' by 2^e */
int bf_mul_2exp(bf_t *r, slimb_t e, limb_t prec, bf_flags_t flags)
{
    slimb_t e_max;
    if (r->len == 0)
        return 0;
    e_max = ((limb_t)1 << BF_EXT_EXP_BITS_MAX) - 1;
    e = bf_max(e, -e_max);
    e = bf_min(e, e_max);
    r->expn += e;
    return __bf_round(r, prec, flags, r->len, 0);
}

/* Return e such as a=m*2^e with m odd integer. return 0 if a is zero,
   Infinite or Nan. */
slimb_t bf_get_exp_min(const bf_t *a)
{
    slimb_t i;
    limb_t v;
    int k;
    
    for(i = 0; i < a->len; i++) {
        v = a->tab[i];
        if (v != 0) {
            k = ctz(v);
            return a->expn - (a->len - i) * LIMB_BITS + k;
        }
    }
    return 0;
}

/* a and b must be finite numbers with a >= 0 and b > 0. 'q' is the
   integer defined as floor(a/b) and r = a - q * b. */
static void bf_tdivremu(bf_t *q, bf_t *r,
                        const bf_t *a, const bf_t *b)
{
    if (bf_cmpu(a, b) < 0) {
        bf_set_ui(q, 0);
        bf_set(r, a);
    } else {
        bf_div(q, a, b, bf_max(a->expn - b->expn + 1, 2), BF_RNDZ);
        bf_rint(q, BF_RNDZ);
        bf_mul(r, q, b, BF_PREC_INF, BF_RNDZ);
        bf_sub(r, a, r, BF_PREC_INF, BF_RNDZ);
    }
}

static int __bf_div(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
                    bf_flags_t flags)
{
    bf_context_t *s = r->ctx;
    int ret, r_sign;
    limb_t n, nb, precl;
    
    r_sign = a->sign ^ b->sign;
    if (a->expn >= BF_EXP_INF || b->expn >= BF_EXP_INF) {
        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {
            bf_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF && b->expn == BF_EXP_INF) {
            bf_set_nan(r);
            return BF_ST_INVALID_OP;
        } else if (a->expn == BF_EXP_INF) {
            bf_set_inf(r, r_sign);
            return 0;
        } else {
            bf_set_zero(r, r_sign);
            return 0;
        }
    } else if (a->expn == BF_EXP_ZERO) {
        if (b->expn == BF_EXP_ZERO) {
            bf_set_nan(r);
            return BF_ST_INVALID_OP;
        } else {
            bf_set_zero(r, r_sign);
            return 0;
        }
    } else if (b->expn == BF_EXP_ZERO) {
        bf_set_inf(r, r_sign);
        return BF_ST_DIVIDE_ZERO;
    }

    /* number of limbs of the quotient (2 extra bits for rounding) */
    precl = (prec + 2 + LIMB_BITS - 1) / LIMB_BITS;
    nb = b->len;
    n = bf_max(a->len, precl);
    
    {
        limb_t *taba, na;
        slimb_t d;
        
        na = n + nb;
        taba = bf_malloc(s, (na + 1) * sizeof(limb_t));
        if (!taba)
            goto fail;
        d = na - a->len;
        memset(taba, 0, d * sizeof(limb_t));
        memcpy(taba + d, a->tab, a->len * sizeof(limb_t));
        if (bf_resize(r, n + 1))
            goto fail1;
        if (mp_divnorm(s, r->tab, taba, na, b->tab, nb)) {
        fail1:
            bf_free(s, taba);
            goto fail;
        }
        /* see if non zero remainder */
        if (mp_scan_nz(taba, nb))
            r->tab[0] |= 1;
        bf_free(r->ctx, taba);
        r->expn = a->expn - b->expn + LIMB_BITS;
        r->sign = r_sign;
        ret = bf_normalize_and_round(r, prec, flags);
    }
    return ret;
 fail:
    bf_set_nan(r);
    return BF_ST_MEM_ERROR;
}

/* division and remainder. 
   
   rnd_mode is the rounding mode for the quotient. The additional
   rounding mode BF_RND_EUCLIDIAN is supported.

   'q' is an integer. 'r' is rounded with prec and flags (prec can be
   BF_PREC_INF).
*/
int bf_divrem(bf_t *q, bf_t *r, const bf_t *a, const bf_t *b,
              limb_t prec, bf_flags_t flags, int rnd_mode)
{
    bf_t a1_s, *a1 = &a1_s;
    bf_t b1_s, *b1 = &b1_s;
    int q_sign, ret;
    BOOL is_ceil, is_rndn;
    
    assert(q != a && q != b);
    assert(r != a && r != b);
    assert(q != r);
    
    if (a->len == 0 || b->len == 0) {
        bf_set_zero(q, 0);
        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {
            bf_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF || b->expn == BF_EXP_ZERO) {
            bf_set_nan(r);
            return BF_ST_INVALID_OP;
        } else {
            bf_set(r, a);
            return bf_round(r, prec, flags);
        }
    }

    q_sign = a->sign ^ b->sign;
    is_rndn = (rnd_mode == BF_RNDN || rnd_mode == BF_RNDNA);
    switch(rnd_mode) {
    default:
    case BF_RNDZ:
    case BF_RNDN:
    case BF_RNDNA:
        is_ceil = FALSE;
        break;
    case BF_RNDD:
        is_ceil = q_sign;
        break;
    case BF_RNDU:
        is_ceil = q_sign ^ 1;
        break;
    case BF_RNDA:
        is_ceil = TRUE;
        break;
    case BF_DIVREM_EUCLIDIAN:
        is_ceil = a->sign;
        break;
    }

    a1->expn = a->expn;
    a1->tab = a->tab;
    a1->len = a->len;
    a1->sign = 0;
    
    b1->expn = b->expn;
    b1->tab = b->tab;
    b1->len = b->len;
    b1->sign = 0;

    /* XXX: could improve to avoid having a large 'q' */
    bf_tdivremu(q, r, a1, b1);
    if (bf_is_nan(q) || bf_is_nan(r))
        goto fail;

    if (r->len != 0) {
        if (is_rndn) {
            int res;
            b1->expn--;
            res = bf_cmpu(r, b1);
            b1->expn++;
            if (res > 0 ||
                (res == 0 &&
                 (rnd_mode == BF_RNDNA ||
                  get_bit(q->tab, q->len, q->len * LIMB_BITS - q->expn)))) {
                goto do_sub_r;
            }
        } else if (is_ceil) {
        do_sub_r:
            ret = bf_add_si(q, q, 1, BF_PREC_INF, BF_RNDZ);
            ret |= bf_sub(r, r, b1, BF_PREC_INF, BF_RNDZ);
            if (ret & BF_ST_MEM_ERROR)
                goto fail;
        }
    }

    r->sign ^= a->sign;
    q->sign = q_sign;
    return bf_round(r, prec, flags);
 fail:
    bf_set_nan(q);
    bf_set_nan(r);
    return BF_ST_MEM_ERROR;
}

int bf_rem(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
           bf_flags_t flags, int rnd_mode)
{
    bf_t q_s, *q = &q_s;
    int ret;
    
    bf_init(r->ctx, q);
    ret = bf_divrem(q, r, a, b, prec, flags, rnd_mode);
    bf_delete(q);
    return ret;
}

static inline int bf_get_limb(slimb_t *pres, const bf_t *a, int flags)
{
#if LIMB_BITS == 32
    return bf_get_int32(pres, a, flags);
#else
    return bf_get_int64(pres, a, flags);
#endif
}

int bf_remquo(slimb_t *pq, bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
              bf_flags_t flags, int rnd_mode)
{
    bf_t q_s, *q = &q_s;
    int ret;
    
    bf_init(r->ctx, q);
    ret = bf_divrem(q, r, a, b, prec, flags, rnd_mode);
    bf_get_limb(pq, q, BF_GET_INT_MOD);
    bf_delete(q);
    return ret;
}

static __maybe_unused inline limb_t mul_mod(limb_t a, limb_t b, limb_t m)
{
    dlimb_t t;
    t = (dlimb_t)a * (dlimb_t)b;
    return t % m;
}

#if defined(USE_MUL_CHECK)
static limb_t mp_mod1(const limb_t *tab, limb_t n, limb_t m, limb_t r)
{
    slimb_t i;
    dlimb_t t;

    for(i = n - 1; i >= 0; i--) {
        t = ((dlimb_t)r << LIMB_BITS) | tab[i];
        r = t % m;
    }
    return r;
}
#endif

static const uint16_t sqrt_table[192] = {
128,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,144,145,146,147,148,149,150,150,151,152,153,154,155,155,156,157,158,159,160,160,161,162,163,163,164,165,166,167,167,168,169,170,170,171,172,173,173,174,175,176,176,177,178,178,179,180,181,181,182,183,183,184,185,185,186,187,187,188,189,189,190,191,192,192,193,193,194,195,195,196,197,197,198,199,199,200,201,201,202,203,203,204,204,205,206,206,207,208,208,209,209,210,211,211,212,212,213,214,214,215,215,216,217,217,218,218,219,219,220,221,221,222,222,223,224,224,225,225,226,226,227,227,228,229,229,230,230,231,231,232,232,233,234,234,235,235,236,236,237,237,238,238,239,240,240,241,241,242,242,243,243,244,244,245,245,246,246,247,247,248,248,249,249,250,250,251,251,252,252,253,253,254,254,255,
};

/* a >= 2^(LIMB_BITS - 2).  Return (s, r) with s=floor(sqrt(a)) and
   r=a-s^2. 0 <= r <= 2 * s */
static limb_t mp_sqrtrem1(limb_t *pr, limb_t a)
{
    limb_t s1, r1, s, r, q, u, num;
    
    /* use a table for the 16 -> 8 bit sqrt */
    s1 = sqrt_table[(a >> (LIMB_BITS - 8)) - 64];
    r1 = (a >> (LIMB_BITS - 16)) - s1 * s1;
    if (r1 > 2 * s1) {
        r1 -= 2 * s1 + 1;
        s1++;
    }
    
    /* one iteration to get a 32 -> 16 bit sqrt */
    num = (r1 << 8) | ((a >> (LIMB_BITS - 32 + 8)) & 0xff);
    q = num / (2 * s1); /* q <= 2^8 */
    u = num % (2 * s1);
    s = (s1 << 8) + q;
    r = (u << 8) | ((a >> (LIMB_BITS - 32)) & 0xff);
    r -= q * q;
    if ((slimb_t)r < 0) {
        s--;
        r += 2 * s + 1;
    }

#if LIMB_BITS == 64
    s1 = s;
    r1 = r;
    /* one more iteration for 64 -> 32 bit sqrt */
    num = (r1 << 16) | ((a >> (LIMB_BITS - 64 + 16)) & 0xffff);
    q = num / (2 * s1); /* q <= 2^16 */
    u = num % (2 * s1);
    s = (s1 << 16) + q;
    r = (u << 16) | ((a >> (LIMB_BITS - 64)) & 0xffff);
    r -= q * q;
    if ((slimb_t)r < 0) {
        s--;
        r += 2 * s + 1;
    }
#endif
    *pr = r;
    return s;
}

/* return floor(sqrt(a)) */
limb_t bf_isqrt(limb_t a)
{
    limb_t s, r;
    int k;

    if (a == 0)
        return 0;
    k = clz(a) & ~1;
    s = mp_sqrtrem1(&r, a << k);
    s >>= (k >> 1);
    return s;
}

static limb_t mp_sqrtrem2(limb_t *tabs, limb_t *taba)
{
    limb_t s1, r1, s, q, u, a0, a1;
    dlimb_t r, num;
    int l;

    a0 = taba[0];
    a1 = taba[1];
    s1 = mp_sqrtrem1(&r1, a1);
    l = LIMB_BITS / 2;
    num = ((dlimb_t)r1 << l) | (a0 >> l);
    q = num / (2 * s1);
    u = num % (2 * s1);
    s = (s1 << l) + q;
    r = ((dlimb_t)u << l) | (a0 & (((limb_t)1 << l) - 1));
    if (unlikely((q >> l) != 0))
        r -= (dlimb_t)1 << LIMB_BITS; /* special case when q=2^l */
    else
        r -= q * q;
    if ((slimb_t)(r >> LIMB_BITS) < 0) {
        s--;
        r += 2 * (dlimb_t)s + 1;
    }
    tabs[0] = s;
    taba[0] = r;
    return r >> LIMB_BITS;
}

//#define DEBUG_SQRTREM

/* tmp_buf must contain (n / 2 + 1 limbs). *prh contains the highest
   limb of the remainder. */
static int mp_sqrtrem_rec(bf_context_t *s, limb_t *tabs, limb_t *taba, limb_t n,
                          limb_t *tmp_buf, limb_t *prh)
{
    limb_t l, h, rh, ql, qh, c, i;
    
    if (n == 1) {
        *prh = mp_sqrtrem2(tabs, taba);
        return 0;
    }
#ifdef DEBUG_SQRTREM
    mp_print_str("a", taba, 2 * n);
#endif
    l = n / 2;
    h = n - l;
    if (mp_sqrtrem_rec(s, tabs + l, taba + 2 * l, h, tmp_buf, &qh))
        return -1;
#ifdef DEBUG_SQRTREM
    mp_print_str("s1", tabs + l, h);
    mp_print_str_h("r1", taba + 2 * l, h, qh);
    mp_print_str_h("r2", taba + l, n, qh);
#endif
    
    /* the remainder is in taba + 2 * l. Its high bit is in qh */
    if (qh) {
        mp_sub(taba + 2 * l, taba + 2 * l, tabs + l, h, 0);
    }
    /* instead of dividing by 2*s, divide by s (which is normalized)
       and update q and r */
    if (mp_divnorm(s, tmp_buf, taba + l, n, tabs + l, h))
        return -1;
    qh += tmp_buf[l];
    for(i = 0; i < l; i++)
        tabs[i] = tmp_buf[i];
    ql = mp_shr(tabs, tabs, l, 1, qh & 1);
    qh = qh >> 1; /* 0 or 1 */
    if (ql)
        rh = mp_add(taba + l, taba + l, tabs + l, h, 0);
    else
        rh = 0;
#ifdef DEBUG_SQRTREM
    mp_print_str_h("q", tabs, l, qh);
    mp_print_str_h("u", taba + l, h, rh);
#endif
    
    mp_add_ui(tabs + l, qh, h);
#ifdef DEBUG_SQRTREM
    mp_print_str_h("s2", tabs, n, sh);
#endif
    
    /* q = qh, tabs[l - 1 ... 0], r = taba[n - 1 ... l] */
    /* subtract q^2. if qh = 1 then q = B^l, so we can take shortcuts */
    if (qh) {
        c = qh;
    } else {
        if (mp_mul(s, taba + n, tabs, l, tabs, l))
            return -1;
        c = mp_sub(taba, taba, taba + n, 2 * l, 0);
    }
    rh -= mp_sub_ui(taba + 2 * l, c, n - 2 * l);
    if ((slimb_t)rh < 0) {
        mp_sub_ui(tabs, 1, n);
        rh += mp_add_mul1(taba, tabs, n, 2);
        rh += mp_add_ui(taba, 1, n);
    }
    *prh = rh;
    return 0;
}

/* 'taba' has 2*n limbs with n >= 1 and taba[2*n-1] >= 2 ^ (LIMB_BITS
   - 2). Return (s, r) with s=floor(sqrt(a)) and r=a-s^2. 0 <= r <= 2
   * s. tabs has n limbs. r is returned in the lower n limbs of
   taba. Its r[n] is the returned value of the function. */
/* Algorithm from the article "Karatsuba Square Root" by Paul Zimmermann and
   inspirated from its GMP implementation */
int mp_sqrtrem(bf_context_t *s, limb_t *tabs, limb_t *taba, limb_t n)
{
    limb_t tmp_buf1[8];
    limb_t *tmp_buf;
    mp_size_t n2;
    int ret;
    n2 = n / 2 + 1;
    if (n2 <= countof(tmp_buf1)) {
        tmp_buf = tmp_buf1;
    } else {
        tmp_buf = bf_malloc(s, sizeof(limb_t) * n2);
        if (!tmp_buf)
            return -1;
    }
    ret = mp_sqrtrem_rec(s, tabs, taba, n, tmp_buf, taba + n);
    if (tmp_buf != tmp_buf1)
        bf_free(s, tmp_buf);
    return ret;
}

/* Integer square root with remainder. 'a' must be an integer. r =
   floor(sqrt(a)) and rem = a - r^2.  BF_ST_INEXACT is set if the result
   is inexact. 'rem' can be NULL if the remainder is not needed. */
int bf_sqrtrem(bf_t *r, bf_t *rem1, const bf_t *a)
{
    int ret;
    
    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bf_set_nan(r);
        } else if (a->expn == BF_EXP_INF && a->sign) {
            goto invalid_op;
        } else {
            bf_set(r, a);
        }
        if (rem1)
            bf_set_ui(rem1, 0);
        ret = 0;
    } else if (a->sign) {
 invalid_op:
        bf_set_nan(r);
        if (rem1)
            bf_set_ui(rem1, 0);
        ret = BF_ST_INVALID_OP;
    } else {
        bf_t rem_s, *rem;
        
        bf_sqrt(r, a, (a->expn + 1) / 2, BF_RNDZ);
        bf_rint(r, BF_RNDZ);
        /* see if the result is exact by computing the remainder */
        if (rem1) {
            rem = rem1;
        } else {
            rem = &rem_s;
            bf_init(r->ctx, rem);
        }
        /* XXX: could avoid recomputing the remainder */
        bf_mul(rem, r, r, BF_PREC_INF, BF_RNDZ);
        bf_neg(rem);
        bf_add(rem, rem, a, BF_PREC_INF, BF_RNDZ);
        if (bf_is_nan(rem)) {
            ret = BF_ST_MEM_ERROR;
            goto done;
        }
        if (rem->len != 0) {
            ret = BF_ST_INEXACT;
        } else {
            ret = 0;
        }
    done:
        if (!rem1)
            bf_delete(rem);
    }
    return ret;
}

int bf_sqrt(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)
{
    bf_context_t *s = a->ctx;
    int ret;

    assert(r != a);

    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bf_set_nan(r);
        } else if (a->expn == BF_EXP_INF && a->sign) {
            goto invalid_op;
        } else {
            bf_set(r, a);
        }
        ret = 0;
    } else if (a->sign) {
 invalid_op:
        bf_set_nan(r);
        ret = BF_ST_INVALID_OP;
    } else {
        limb_t *a1;
        slimb_t n, n1;
        limb_t res;
        
        /* convert the mantissa to an integer with at least 2 *
           prec + 4 bits */
        n = (2 * (prec + 2) + 2 * LIMB_BITS - 1) / (2 * LIMB_BITS);
        if (bf_resize(r, n))
            goto fail;
        a1 = bf_malloc(s, sizeof(limb_t) * 2 * n);
        if (!a1)
            goto fail;
        n1 = bf_min(2 * n, a->len);
        memset(a1, 0, (2 * n - n1) * sizeof(limb_t));
        memcpy(a1 + 2 * n - n1, a->tab + a->len - n1, n1 * sizeof(limb_t));
        if (a->expn & 1) {
            res = mp_shr(a1, a1, 2 * n, 1, 0);
        } else {
            res = 0;
        }
        if (mp_sqrtrem(s, r->tab, a1, n)) {
            bf_free(s, a1);
            goto fail;
        }
        if (!res) {
            res = mp_scan_nz(a1, n + 1);
        }
        bf_free(s, a1);
        if (!res) {
            res = mp_scan_nz(a->tab, a->len - n1);
        }
        if (res != 0)
            r->tab[0] |= 1;
        r->sign = 0;
        r->expn = (a->expn + 1) >> 1;
        ret = bf_round(r, prec, flags);
    }
    return ret;
 fail:
    bf_set_nan(r);
    return BF_ST_MEM_ERROR;
}

static no_inline int bf_op2(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
                            bf_flags_t flags, bf_op2_func_t *func)
{
    bf_t tmp;
    int ret;
    
    if (r == a || r == b) {
        bf_init(r->ctx, &tmp);
        ret = func(&tmp, a, b, prec, flags);
        bf_move(r, &tmp);
    } else {
        ret = func(r, a, b, prec, flags);
    }
    return ret;
}

int bf_add(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
            bf_flags_t flags)
{
    return bf_op2(r, a, b, prec, flags, __bf_add);
}

int bf_sub(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
            bf_flags_t flags)
{
    return bf_op2(r, a, b, prec, flags, __bf_sub);
}

int bf_div(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
           bf_flags_t flags)
{
    return bf_op2(r, a, b, prec, flags, __bf_div);
}

int bf_mul_ui(bf_t *r, const bf_t *a, uint64_t b1, limb_t prec,
               bf_flags_t flags)
{
    bf_t b;
    int ret;
    bf_init(r->ctx, &b);
    ret = bf_set_ui(&b, b1);
    ret |= bf_mul(r, a, &b, prec, flags);
    bf_delete(&b);
    return ret;
}

int bf_mul_si(bf_t *r, const bf_t *a, int64_t b1, limb_t prec,
               bf_flags_t flags)
{
    bf_t b;
    int ret;
    bf_init(r->ctx, &b);
    ret = bf_set_si(&b, b1);
    ret |= bf_mul(r, a, &b, prec, flags);
    bf_delete(&b);
    return ret;
}

int bf_add_si(bf_t *r, const bf_t *a, int64_t b1, limb_t prec,
              bf_flags_t flags)
{
    bf_t b;
    int ret;
    
    bf_init(r->ctx, &b);
    ret = bf_set_si(&b, b1);
    ret |= bf_add(r, a, &b, prec, flags);
    bf_delete(&b);
    return ret;
}

static int bf_pow_ui(bf_t *r, const bf_t *a, limb_t b, limb_t prec,
                     bf_flags_t flags)
{
    int ret, n_bits, i;
    
    assert(r != a);
    if (b == 0)
        return bf_set_ui(r, 1);
    ret = bf_set(r, a);
    n_bits = LIMB_BITS - clz(b);
    for(i = n_bits - 2; i >= 0; i--) {
        ret |= bf_mul(r, r, r, prec, flags);
        if ((b >> i) & 1)
            ret |= bf_mul(r, r, a, prec, flags);
    }
    return ret;
}

static int bf_pow_ui_ui(bf_t *r, limb_t a1, limb_t b,
                        limb_t prec, bf_flags_t flags)
{
    bf_t a;
    int ret;
    
    if (a1 == 10 && b <= LIMB_DIGITS) {
        /* use precomputed powers. We do not round at this point
           because we expect the caller to do it */
        ret = bf_set_ui(r, mp_pow_dec[b]);
    } else {
        bf_init(r->ctx, &a);
        ret = bf_set_ui(&a, a1);
        ret |= bf_pow_ui(r, &a, b, prec, flags);
        bf_delete(&a);
    }
    return ret;
}

/* convert to integer (infinite precision) */
int bf_rint(bf_t *r, int rnd_mode)
{
    return bf_round(r, 0, rnd_mode | BF_FLAG_RADPNT_PREC);
}

/* logical operations */
#define BF_LOGIC_OR  0
#define BF_LOGIC_XOR 1
#define BF_LOGIC_AND 2

static inline limb_t bf_logic_op1(limb_t a, limb_t b, int op)
{
    switch(op) {
    case BF_LOGIC_OR:
        return a | b;
    case BF_LOGIC_XOR:
        return a ^ b;
    default:
    case BF_LOGIC_AND:
        return a & b;
    }
}

static int bf_logic_op(bf_t *r, const bf_t *a1, const bf_t *b1, int op)
{
    bf_t b1_s, a1_s, *a, *b;
    limb_t a_sign, b_sign, r_sign;
    slimb_t l, i, a_bit_offset, b_bit_offset;
    limb_t v1, v2, v1_mask, v2_mask, r_mask;
    int ret;
    
    assert(r != a1 && r != b1);

    if (a1->expn <= 0)
        a_sign = 0; /* minus zero is considered as positive */
    else
        a_sign = a1->sign;

    if (b1->expn <= 0)
        b_sign = 0; /* minus zero is considered as positive */
    else
        b_sign = b1->sign;
    
    if (a_sign) {
        a = &a1_s;
        bf_init(r->ctx, a);
        if (bf_add_si(a, a1, 1, BF_PREC_INF, BF_RNDZ)) {
            b = NULL;
            goto fail;
        }
    } else {
        a = (bf_t *)a1;
    }

    if (b_sign) {
        b = &b1_s;
        bf_init(r->ctx, b);
        if (bf_add_si(b, b1, 1, BF_PREC_INF, BF_RNDZ))
            goto fail;
    } else {
        b = (bf_t *)b1;
    }
    
    r_sign = bf_logic_op1(a_sign, b_sign, op);
    if (op == BF_LOGIC_AND && r_sign == 0) {
        /* no need to compute extra zeros for and */
        if (a_sign == 0 && b_sign == 0)
            l = bf_min(a->expn, b->expn);
        else if (a_sign == 0)
            l = a->expn;
        else
            l = b->expn;
    } else {
        l = bf_max(a->expn, b->expn);
    }
    /* Note: a or b can be zero */
    l = (bf_max(l, 1) + LIMB_BITS - 1) / LIMB_BITS;
    if (bf_resize(r, l))
        goto fail;
    a_bit_offset = a->len * LIMB_BITS - a->expn;
    b_bit_offset = b->len * LIMB_BITS - b->expn;
    v1_mask = -a_sign;
    v2_mask = -b_sign;
    r_mask = -r_sign;
    for(i = 0; i < l; i++) {
        v1 = get_bits(a->tab, a->len, a_bit_offset + i * LIMB_BITS) ^ v1_mask;
        v2 = get_bits(b->tab, b->len, b_bit_offset + i * LIMB_BITS) ^ v2_mask;
        r->tab[i] = bf_logic_op1(v1, v2, op) ^ r_mask;
    }
    r->expn = l * LIMB_BITS;
    r->sign = r_sign;
    bf_normalize_and_round(r, BF_PREC_INF, BF_RNDZ); /* cannot fail */
    if (r_sign) {
        if (bf_add_si(r, r, -1, BF_PREC_INF, BF_RNDZ))
            goto fail;
    }
    ret = 0;
 done:
    if (a == &a1_s)
        bf_delete(a);
    if (b == &b1_s)
        bf_delete(b);
    return ret;
 fail:
    bf_set_nan(r);
    ret = BF_ST_MEM_ERROR;
    goto done;
}

/* 'a' and 'b' must be integers. Return 0 or BF_ST_MEM_ERROR. */
int bf_logic_or(bf_t *r, const bf_t *a, const bf_t *b)
{
    return bf_logic_op(r, a, b, BF_LOGIC_OR);
}

/* 'a' and 'b' must be integers. Return 0 or BF_ST_MEM_ERROR. */
int bf_logic_xor(bf_t *r, const bf_t *a, const bf_t *b)
{
    return bf_logic_op(r, a, b, BF_LOGIC_XOR);
}

/* 'a' and 'b' must be integers. Return 0 or BF_ST_MEM_ERROR. */
int bf_logic_and(bf_t *r, const bf_t *a, const bf_t *b)
{
    return bf_logic_op(r, a, b, BF_LOGIC_AND);
}

/* conversion between fixed size types */

typedef union {
    double d;
    uint64_t u;
} Float64Union;

int bf_get_float64(const bf_t *a, double *pres, bf_rnd_t rnd_mode)
{
    Float64Union u;
    int e, ret;
    uint64_t m;
    
    ret = 0;
    if (a->expn == BF_EXP_NAN) {
        u.u = 0x7ff8000000000000; /* quiet nan */
    } else {
        bf_t b_s, *b = &b_s;
        
        bf_init(a->ctx, b);
        bf_set(b, a);
        if (bf_is_finite(b)) {
            ret = bf_round(b, 53, rnd_mode | BF_FLAG_SUBNORMAL | bf_set_exp_bits(11));
        }
        if (b->expn == BF_EXP_INF) {
            e = (1 << 11) - 1;
            m = 0;
        } else if (b->expn == BF_EXP_ZERO) {
            e = 0;
            m = 0;
        } else {
            e = b->expn + 1023 - 1;
#if LIMB_BITS == 32
            if (b->len == 2) {
                m = ((uint64_t)b->tab[1] << 32) | b->tab[0];
            } else {
                m = ((uint64_t)b->tab[0] << 32);
            }
#else
            m = b->tab[0];
#endif
            if (e <= 0) {
                /* subnormal */
                m = m >> (12 - e);
                e = 0;
            } else {
                m = (m << 1) >> 12;
            }
        }
        u.u = m | ((uint64_t)e << 52) | ((uint64_t)b->sign << 63);
        bf_delete(b);
    }
    *pres = u.d;
    return ret;
}

int bf_set_float64(bf_t *a, double d)
{
    Float64Union u;
    uint64_t m;
    int shift, e, sgn;
    
    u.d = d;
    sgn = u.u >> 63;
    e = (u.u >> 52) & ((1 << 11) - 1);
    m = u.u & (((uint64_t)1 << 52) - 1);
    if (e == ((1 << 11) - 1)) {
        if (m != 0) {
            bf_set_nan(a);
        } else {
            bf_set_inf(a, sgn);
        }
    } else if (e == 0) {
        if (m == 0) {
            bf_set_zero(a, sgn);
        } else {
            /* subnormal number */
            m <<= 12;
            shift = clz64(m);
            m <<= shift;
            e = -shift;
            goto norm;
        }
    } else {
        m = (m << 11) | ((uint64_t)1 << 63);
    norm:
        a->expn = e - 1023 + 1;
#if LIMB_BITS == 32
        if (bf_resize(a, 2))
            goto fail;
        a->tab[0] = m;
        a->tab[1] = m >> 32;
#else
        if (bf_resize(a, 1))
            goto fail;
        a->tab[0] = m;
#endif
        a->sign = sgn;
    }
    return 0;
fail:
    bf_set_nan(a);
    return BF_ST_MEM_ERROR;
}

/* The rounding mode is always BF_RNDZ. Return BF_ST_INVALID_OP if there
   is an overflow and 0 otherwise. */
int bf_get_int32(int *pres, const bf_t *a, int flags)
{
    uint32_t v;
    int ret;
    if (a->expn >= BF_EXP_INF) {
        ret = BF_ST_INVALID_OP;
        if (flags & BF_GET_INT_MOD) {
            v = 0;
        } else if (a->expn == BF_EXP_INF) {
            v = (uint32_t)INT32_MAX + a->sign;
        } else {
            v = INT32_MAX;
        }
    } else if (a->expn <= 0) {
        v = 0;
        ret = 0;
    } else if (a->expn <= 31) {
        v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);
        if (a->sign)
            v = -v;
        ret = 0;
    } else if (!(flags & BF_GET_INT_MOD)) {
        ret = BF_ST_INVALID_OP;
        if (a->sign) {
            v = (uint32_t)INT32_MAX + 1;
            if (a->expn == 32 && 
                (a->tab[a->len - 1] >> (LIMB_BITS - 32)) == v) {
                ret = 0;
            }
        } else {
            v = INT32_MAX;
        }
    } else {
        v = get_bits(a->tab, a->len, a->len * LIMB_BITS - a->expn); 
        if (a->sign)
            v = -v;
        ret = 0;
    }
    *pres = v;
    return ret;
}

/* The rounding mode is always BF_RNDZ. Return BF_ST_INVALID_OP if there
   is an overflow and 0 otherwise. */
int bf_get_int64(int64_t *pres, const bf_t *a, int flags)
{
    uint64_t v;
    int ret;
    if (a->expn >= BF_EXP_INF) {
        ret = BF_ST_INVALID_OP;
        if (flags & BF_GET_INT_MOD) {
            v = 0;
        } else if (a->expn == BF_EXP_INF) {
            v = (uint64_t)INT64_MAX + a->sign;
        } else {
            v = INT64_MAX;
        }
    } else if (a->expn <= 0) {
        v = 0;
        ret = 0;
    } else if (a->expn <= 63) {
#if LIMB_BITS == 32
        if (a->expn <= 32)
            v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);
        else
            v = (((uint64_t)a->tab[a->len - 1] << 32) |
                 get_limbz(a, a->len - 2)) >> (64 - a->expn);
#else
        v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);
#endif
        if (a->sign)
            v = -v;
        ret = 0;
    } else if (!(flags & BF_GET_INT_MOD)) {
        ret = BF_ST_INVALID_OP;
        if (a->sign) {
            uint64_t v1;
            v = (uint64_t)INT64_MAX + 1;
            if (a->expn == 64) {
                v1 = a->tab[a->len - 1];
#if LIMB_BITS == 32
                v1 = (v1 << 32) | get_limbz(a, a->len - 2);
#endif
                if (v1 == v)
                    ret = 0;
            }
        } else {
            v = INT64_MAX;
        }
    } else {
        slimb_t bit_pos = a->len * LIMB_BITS - a->expn;
        v = get_bits(a->tab, a->len, bit_pos); 
#if LIMB_BITS == 32
        v |= (uint64_t)get_bits(a->tab, a->len, bit_pos + 32) << 32;
#endif
        if (a->sign)
            v = -v;
        ret = 0;
    }
    *pres = v;
    return ret;
}

/* The rounding mode is always BF_RNDZ. Return BF_ST_INVALID_OP if there
   is an overflow and 0 otherwise. */
int bf_get_uint64(uint64_t *pres, const bf_t *a)
{
    uint64_t v;
    int ret;
    if (a->expn == BF_EXP_NAN) {
        goto overflow;
    } else if (a->expn <= 0) {
        v = 0;
        ret = 0;
    } else if (a->sign) {
        v = 0;
        ret = BF_ST_INVALID_OP;
    } else if (a->expn <= 64) {
#if LIMB_BITS == 32
        if (a->expn <= 32)
            v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);
        else
            v = (((uint64_t)a->tab[a->len - 1] << 32) |
                 get_limbz(a, a->len - 2)) >> (64 - a->expn);
#else
        v = a->tab[a->len - 1] >> (LIMB_BITS - a->expn);
#endif
        ret = 0;
    } else {
    overflow:
        v = UINT64_MAX;
        ret = BF_ST_INVALID_OP;
    }
    *pres = v;
    return ret;
}

/* base conversion from radix */

static const uint8_t digits_per_limb_table[BF_RADIX_MAX - 1] = {
#if LIMB_BITS == 32
32,20,16,13,12,11,10,10, 9, 9, 8, 8, 8, 8, 8, 7, 7, 7, 7, 7, 7, 7, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
#else
64,40,32,27,24,22,21,20,19,18,17,17,16,16,16,15,15,15,14,14,14,14,13,13,13,13,13,13,13,12,12,12,12,12,12,
#endif
};

static limb_t get_limb_radix(int radix)
{
    int i, k;
    limb_t radixl;
    
    k = digits_per_limb_table[radix - 2];
    radixl = radix;
    for(i = 1; i < k; i++)
        radixl *= radix;
    return radixl;
}

/* return != 0 if error */
static int bf_integer_from_radix_rec(bf_t *r, const limb_t *tab,
                                     limb_t n, int level, limb_t n0,
                                     limb_t radix, bf_t *pow_tab)
{
    int ret;
    if (n == 1) {
        ret = bf_set_ui(r, tab[0]);
    } else {
        bf_t T_s, *T = &T_s, *B;
        limb_t n1, n2;
        
        n2 = (((n0 * 2) >> (level + 1)) + 1) / 2;
        n1 = n - n2;
        //        printf("level=%d n0=%ld n1=%ld n2=%ld\n", level, n0, n1, n2);
        B = &pow_tab[level];
        if (B->len == 0) {
            ret = bf_pow_ui_ui(B, radix, n2, BF_PREC_INF, BF_RNDZ);
            if (ret)
                return ret;
        }
        ret = bf_integer_from_radix_rec(r, tab + n2, n1, level + 1, n0,
                                        radix, pow_tab);
        if (ret)
            return ret;
        ret = bf_mul(r, r, B, BF_PREC_INF, BF_RNDZ);
        if (ret)
            return ret;
        bf_init(r->ctx, T);
        ret = bf_integer_from_radix_rec(T, tab, n2, level + 1, n0,
                                        radix, pow_tab);
        if (!ret)
            ret = bf_add(r, r, T, BF_PREC_INF, BF_RNDZ);
        bf_delete(T);
    }
    return ret;
    //    bf_print_str("  r=", r);
}

/* return 0 if OK != 0 if memory error */
static int bf_integer_from_radix(bf_t *r, const limb_t *tab,
                                 limb_t n, limb_t radix)
{
    bf_context_t *s = r->ctx;
    int pow_tab_len, i, ret;
    limb_t radixl;
    bf_t *pow_tab;
    
    radixl = get_limb_radix(radix);
    pow_tab_len = ceil_log2(n) + 2; /* XXX: check */
    pow_tab = bf_malloc(s, sizeof(pow_tab[0]) * pow_tab_len);
    if (!pow_tab)
        return -1;
    for(i = 0; i < pow_tab_len; i++)
        bf_init(r->ctx, &pow_tab[i]);
    ret = bf_integer_from_radix_rec(r, tab, n, 0, n, radixl, pow_tab);
    for(i = 0; i < pow_tab_len; i++) {
        bf_delete(&pow_tab[i]);
    }
    bf_free(s, pow_tab);
    return ret;
}

/* compute and round T * radix^expn. */
int bf_mul_pow_radix(bf_t *r, const bf_t *T, limb_t radix,
                     slimb_t expn, limb_t prec, bf_flags_t flags)
{
    int ret, expn_sign, overflow;
    slimb_t e, extra_bits, prec1, ziv_extra_bits;
    bf_t B_s, *B = &B_s;

    if (T->len == 0) {
        return bf_set(r, T);
    } else if (expn == 0) {
        ret = bf_set(r, T);
        ret |= bf_round(r, prec, flags);
        return ret;
    }

    e = expn;
    expn_sign = 0;
    if (e < 0) {
        e = -e;
        expn_sign = 1;
    }
    bf_init(r->ctx, B);
    if (prec == BF_PREC_INF) {
        /* infinite precision: only used if the result is known to be exact */
        ret = bf_pow_ui_ui(B, radix, e, BF_PREC_INF, BF_RNDN);
        if (expn_sign) {
            ret |= bf_div(r, T, B, T->len * LIMB_BITS, BF_RNDN);
        } else {
            ret |= bf_mul(r, T, B, BF_PREC_INF, BF_RNDN);
        }
    } else {
        ziv_extra_bits = 16;
        for(;;) {
            prec1 = prec + ziv_extra_bits;
            /* XXX: correct overflow/underflow handling */
            /* XXX: rigorous error analysis needed */
            extra_bits = ceil_log2(e) * 2 + 1;
            ret = bf_pow_ui_ui(B, radix, e, prec1 + extra_bits, BF_RNDN | BF_FLAG_EXT_EXP);
            overflow = !bf_is_finite(B);
            /* XXX: if bf_pow_ui_ui returns an exact result, can stop
               after the next operation */
            if (expn_sign)
                ret |= bf_div(r, T, B, prec1 + extra_bits, BF_RNDN | BF_FLAG_EXT_EXP);
            else
                ret |= bf_mul(r, T, B, prec1 + extra_bits, BF_RNDN | BF_FLAG_EXT_EXP);
            if (ret & BF_ST_MEM_ERROR)
                break;
            if ((ret & BF_ST_INEXACT) &&
                !bf_can_round(r, prec, flags & BF_RND_MASK, prec1) &&
                !overflow) {
                /* and more precision and retry */
                ziv_extra_bits = ziv_extra_bits  + (ziv_extra_bits / 2);
            } else {
                /* XXX: need to use __bf_round() to pass the inexact
                   flag for the subnormal case */
                ret = bf_round(r, prec, flags) | (ret & BF_ST_INEXACT);
                break;
            }
        }
    }
    bf_delete(B);
    return ret;
}

static inline int to_digit(int c)
{
    if (c >= '0' && c <= '9')
        return c - '0';
    else if (c >= 'A' && c <= 'Z')
        return c - 'A' + 10;
    else if (c >= 'a' && c <= 'z')
        return c - 'a' + 10;
    else
        return 36;
}

/* add a limb at 'pos' and decrement pos. new space is created if
   needed. Return 0 if OK, -1 if memory error */
static int bf_add_limb(bf_t *a, slimb_t *ppos, limb_t v)
{
    slimb_t pos;
    pos = *ppos;
    if (unlikely(pos < 0)) {
        limb_t new_size, d, *new_tab;
        new_size = bf_max(a->len + 1, a->len * 3 / 2);
        new_tab = bf_realloc(a->ctx, a->tab, sizeof(limb_t) * new_size);
        if (!new_tab)
            return -1;
        a->tab = new_tab;
        d = new_size - a->len;
        memmove(a->tab + d, a->tab, a->len * sizeof(limb_t));
        a->len = new_size;
        pos += d;
    }
    a->tab[pos--] = v;
    *ppos = pos;
    return 0;
}

static int bf_tolower(int c)
{
    if (c >= 'A' && c <= 'Z')
        c = c - 'A' + 'a';
    return c;
}

static int strcasestart(const char *str, const char *val, const char **ptr)
{
    const char *p, *q;
    p = str;
    q = val;
    while (*q != '\0') {
        if (bf_tolower(*p) != *q)
            return 0;
        p++;
        q++;
    }
    if (ptr)
        *ptr = p;
    return 1;
}

static int bf_atof_internal(bf_t *r, slimb_t *pexponent,
                            const char *str, const char **pnext, int radix,
                            limb_t prec, bf_flags_t flags, BOOL is_dec)
{
    const char *p, *p_start;
    int is_neg, radix_bits, exp_is_neg, ret, digits_per_limb, shift;
    limb_t cur_limb;
    slimb_t pos, expn, int_len, digit_count;
    BOOL has_decpt, is_bin_exp;
    bf_t a_s, *a;
    
    *pexponent = 0;
    p = str;
    if (!(flags & BF_ATOF_NO_NAN_INF) && radix <= 16 &&
        strcasestart(p, "nan", &p)) {
        bf_set_nan(r);
        ret = 0;
        goto done;
    }
    is_neg = 0;
    
    if (p[0] == '+') {
        p++;
        p_start = p;
    } else if (p[0] == '-') {
        is_neg = 1;
        p++;
        p_start = p;
    } else {
        p_start = p;
    }
    if (p[0] == '0') {
        if ((p[1] == 'x' || p[1] == 'X') &&
            (radix == 0 || radix == 16) &&
            !(flags & BF_ATOF_NO_HEX)) {
            radix = 16;
            p += 2;
        } else if ((p[1] == 'o' || p[1] == 'O') &&
                   radix == 0 && (flags & BF_ATOF_BIN_OCT)) {
            p += 2;
            radix = 8;
        } else if ((p[1] == 'b' || p[1] == 'B') &&
                   radix == 0 && (flags & BF_ATOF_BIN_OCT)) {
            p += 2;
            radix = 2;
        } else {
            goto no_prefix;
        }
        /* there must be a digit after the prefix */
        if (to_digit((uint8_t)*p) >= radix) {
            bf_set_nan(r);
            ret = 0;
            goto done;
        }
    no_prefix: ;
    } else {
        if (!(flags & BF_ATOF_NO_NAN_INF) && radix <= 16 &&
            strcasestart(p, "inf", &p)) {
            bf_set_inf(r, is_neg);
            ret = 0;
            goto done;
        }
    }
    
    if (radix == 0)
        radix = 10;
    if (is_dec) {
        assert(radix == 10);
        radix_bits = 0;
        a = r;
    } else if ((radix & (radix - 1)) != 0) {
        radix_bits = 0; /* base is not a power of two */
        a = &a_s;
        bf_init(r->ctx, a);
    } else {
        radix_bits = ceil_log2(radix);
        a = r;
    }

    /* skip leading zeros */
    /* XXX: could also skip zeros after the decimal point */
    while (*p == '0')
        p++;

    if (radix_bits) {
        shift = digits_per_limb = LIMB_BITS;
    } else {
        radix_bits = 0;
        shift = digits_per_limb = digits_per_limb_table[radix - 2];
    }
    cur_limb = 0;
    bf_resize(a, 1);
    pos = 0;
    has_decpt = FALSE;
    int_len = digit_count = 0;
    for(;;) {
        limb_t c;
        if (*p == '.' && (p > p_start || to_digit(p[1]) < radix)) {
            if (has_decpt)
                break;
            has_decpt = TRUE;
            int_len = digit_count;
            p++;
        }
        c = to_digit(*p);
        if (c >= radix)
            break;
        digit_count++;
        p++;
        if (radix_bits) {
            shift -= radix_bits;
            if (shift <= 0) {
                cur_limb |= c >> (-shift);
                if (bf_add_limb(a, &pos, cur_limb))
                    goto mem_error;
                if (shift < 0)
                    cur_limb = c << (LIMB_BITS + shift);
                else
                    cur_limb = 0;
                shift += LIMB_BITS;
            } else {
                cur_limb |= c << shift;
            }
        } else {
            cur_limb = cur_limb * radix + c;
            shift--;
            if (shift == 0) {
                if (bf_add_limb(a, &pos, cur_limb))
                    goto mem_error;
                shift = digits_per_limb;
                cur_limb = 0;
            }
        }
    }
    if (!has_decpt)
        int_len = digit_count;

    /* add the last limb and pad with zeros */
    if (shift != digits_per_limb) {
        if (radix_bits == 0) {
            while (shift != 0) {
                cur_limb *= radix;
                shift--;
            }
        }
        if (bf_add_limb(a, &pos, cur_limb)) {
        mem_error:
            ret = BF_ST_MEM_ERROR;
            if (!radix_bits)
                bf_delete(a);
            bf_set_nan(r);
            goto done;
        }
    }
            
    /* reset the next limbs to zero (we prefer to reallocate in the
       renormalization) */
    memset(a->tab, 0, (pos + 1) * sizeof(limb_t));

    if (p == p_start) {
        ret = 0;
        if (!radix_bits)
            bf_delete(a);
        bf_set_nan(r);
        goto done;
    }

    /* parse the exponent, if any */
    expn = 0;
    is_bin_exp = FALSE;
    if (((radix == 10 && (*p == 'e' || *p == 'E')) ||
         (radix != 10 && (*p == '@' ||
                          (radix_bits && (*p == 'p' || *p == 'P'))))) &&
        p > p_start) {
        is_bin_exp = (*p == 'p' || *p == 'P');
        p++;
        exp_is_neg = 0;
        if (*p == '+') {
            p++;
        } else if (*p == '-') {
            exp_is_neg = 1;
            p++;
        }
        for(;;) {
            int c;
            c = to_digit(*p);
            if (c >= 10)
                break;
            if (unlikely(expn > ((BF_RAW_EXP_MAX - 2 - 9) / 10))) {
                /* exponent overflow */
                if (exp_is_neg) {
                    bf_set_zero(r, is_neg);
                    ret = BF_ST_UNDERFLOW | BF_ST_INEXACT;
                } else {
                    bf_set_inf(r, is_neg);
                    ret = BF_ST_OVERFLOW | BF_ST_INEXACT;
                }
                goto done;
            }
            p++;
            expn = expn * 10 + c;
        }
        if (exp_is_neg)
            expn = -expn;
    }
    if (is_dec) {
        a->expn = expn + int_len;
        a->sign = is_neg;
        ret = bfdec_normalize_and_round((bfdec_t *)a, prec, flags);
    } else if (radix_bits) {
        /* XXX: may overflow */
        if (!is_bin_exp)
            expn *= radix_bits; 
        a->expn = expn + (int_len * radix_bits);
        a->sign = is_neg;
        ret = bf_normalize_and_round(a, prec, flags);
    } else {
        limb_t l;
        pos++;
        l = a->len - pos; /* number of limbs */
        if (l == 0) {
            bf_set_zero(r, is_neg);
            ret = 0;
        } else {
            bf_t T_s, *T = &T_s;

            expn -= l * digits_per_limb - int_len;
            bf_init(r->ctx, T);
            if (bf_integer_from_radix(T, a->tab + pos, l, radix)) {
                bf_set_nan(r);
                ret = BF_ST_MEM_ERROR;
            } else {
                T->sign = is_neg;
                if (flags & BF_ATOF_EXPONENT) {
                    /* return the exponent */
                    *pexponent = expn;
                    ret = bf_set(r, T);
                } else {
                    ret = bf_mul_pow_radix(r, T, radix, expn, prec, flags);
                }
            }
            bf_delete(T);
        }
        bf_delete(a);
    }
 done:
    if (pnext)
        *pnext = p;
    return ret;
}

/* 
   Return (status, n, exp). 'status' is the floating point status. 'n'
   is the parsed number. 

   If (flags & BF_ATOF_EXPONENT) and if the radix is not a power of
   two, the parsed number is equal to r *
   (*pexponent)^radix. Otherwise *pexponent = 0.
*/
int bf_atof2(bf_t *r, slimb_t *pexponent,
             const char *str, const char **pnext, int radix,
             limb_t prec, bf_flags_t flags)
{
    return bf_atof_internal(r, pexponent, str, pnext, radix, prec, flags,
                            FALSE);
}

int bf_atof(bf_t *r, const char *str, const char **pnext, int radix,
            limb_t prec, bf_flags_t flags)
{
    slimb_t dummy_exp;
    return bf_atof_internal(r, &dummy_exp, str, pnext, radix, prec, flags, FALSE);
}

/* base conversion to radix */

#if LIMB_BITS == 64
#define RADIXL_10 UINT64_C(10000000000000000000)
#else
#define RADIXL_10 UINT64_C(1000000000)
#endif

static const uint32_t inv_log2_radix[BF_RADIX_MAX - 1][LIMB_BITS / 32 + 1] = {
#if LIMB_BITS == 32
{ 0x80000000, 0x00000000,},
{ 0x50c24e60, 0xd4d4f4a7,},
{ 0x40000000, 0x00000000,},
{ 0x372068d2, 0x0a1ee5ca,},
{ 0x3184648d, 0xb8153e7a,},
{ 0x2d983275, 0x9d5369c4,},
{ 0x2aaaaaaa, 0xaaaaaaab,},
{ 0x28612730, 0x6a6a7a54,},
{ 0x268826a1, 0x3ef3fde6,},
{ 0x25001383, 0xbac8a744,},
{ 0x23b46706, 0x82c0c709,},
{ 0x229729f1, 0xb2c83ded,},
{ 0x219e7ffd, 0xa5ad572b,},
{ 0x20c33b88, 0xda7c29ab,},
{ 0x20000000, 0x00000000,},
{ 0x1f50b57e, 0xac5884b3,},
{ 0x1eb22cc6, 0x8aa6e26f,},
{ 0x1e21e118, 0x0c5daab2,},
{ 0x1d9dcd21, 0x439834e4,},
{ 0x1d244c78, 0x367a0d65,},
{ 0x1cb40589, 0xac173e0c,},
{ 0x1c4bd95b, 0xa8d72b0d,},
{ 0x1bead768, 0x98f8ce4c,},
{ 0x1b903469, 0x050f72e5,},
{ 0x1b3b433f, 0x2eb06f15,},
{ 0x1aeb6f75, 0x9c46fc38,},
{ 0x1aa038eb, 0x0e3bfd17,},
{ 0x1a593062, 0xb38d8c56,},
{ 0x1a15f4c3, 0x2b95a2e6,},
{ 0x19d630dc, 0xcc7ddef9,},
{ 0x19999999, 0x9999999a,},
{ 0x195fec80, 0x8a609431,},
{ 0x1928ee7b, 0x0b4f22f9,},
{ 0x18f46acf, 0x8c06e318,},
{ 0x18c23246, 0xdc0a9f3d,},
#else
{ 0x80000000, 0x00000000, 0x00000000,},
{ 0x50c24e60, 0xd4d4f4a7, 0x021f57bc,},
{ 0x40000000, 0x00000000, 0x00000000,},
{ 0x372068d2, 0x0a1ee5ca, 0x19ea911b,},
{ 0x3184648d, 0xb8153e7a, 0x7fc2d2e1,},
{ 0x2d983275, 0x9d5369c4, 0x4dec1661,},
{ 0x2aaaaaaa, 0xaaaaaaaa, 0xaaaaaaab,},
{ 0x28612730, 0x6a6a7a53, 0x810fabde,},
{ 0x268826a1, 0x3ef3fde6, 0x23e2566b,},
{ 0x25001383, 0xbac8a744, 0x385a3349,},
{ 0x23b46706, 0x82c0c709, 0x3f891718,},
{ 0x229729f1, 0xb2c83ded, 0x15fba800,},
{ 0x219e7ffd, 0xa5ad572a, 0xe169744b,},
{ 0x20c33b88, 0xda7c29aa, 0x9bddee52,},
{ 0x20000000, 0x00000000, 0x00000000,},
{ 0x1f50b57e, 0xac5884b3, 0x70e28eee,},
{ 0x1eb22cc6, 0x8aa6e26f, 0x06d1a2a2,},
{ 0x1e21e118, 0x0c5daab1, 0x81b4f4bf,},
{ 0x1d9dcd21, 0x439834e3, 0x81667575,},
{ 0x1d244c78, 0x367a0d64, 0xc8204d6d,},
{ 0x1cb40589, 0xac173e0c, 0x3b7b16ba,},
{ 0x1c4bd95b, 0xa8d72b0d, 0x5879f25a,},
{ 0x1bead768, 0x98f8ce4c, 0x66cc2858,},
{ 0x1b903469, 0x050f72e5, 0x0cf5488e,},
{ 0x1b3b433f, 0x2eb06f14, 0x8c89719c,},
{ 0x1aeb6f75, 0x9c46fc37, 0xab5fc7e9,},
{ 0x1aa038eb, 0x0e3bfd17, 0x1bd62080,},
{ 0x1a593062, 0xb38d8c56, 0x7998ab45,},
{ 0x1a15f4c3, 0x2b95a2e6, 0x46aed6a0,},
{ 0x19d630dc, 0xcc7ddef9, 0x5aadd61b,},
{ 0x19999999, 0x99999999, 0x9999999a,},
{ 0x195fec80, 0x8a609430, 0xe1106014,},
{ 0x1928ee7b, 0x0b4f22f9, 0x5f69791d,},
{ 0x18f46acf, 0x8c06e318, 0x4d2aeb2c,},
{ 0x18c23246, 0xdc0a9f3d, 0x3fe16970,},
#endif
};

static const limb_t log2_radix[BF_RADIX_MAX - 1] = {
#if LIMB_BITS == 32
0x20000000,
0x32b80347,
0x40000000,
0x4a4d3c26,
0x52b80347,
0x59d5d9fd,
0x60000000,
0x6570068e,
0x6a4d3c26,
0x6eb3a9f0,
0x72b80347,
0x766a008e,
0x79d5d9fd,
0x7d053f6d,
0x80000000,
0x82cc7edf,
0x8570068e,
0x87ef05ae,
0x8a4d3c26,
0x8c8ddd45,
0x8eb3a9f0,
0x90c10501,
0x92b80347,
0x949a784c,
0x966a008e,
0x982809d6,
0x99d5d9fd,
0x9b74948f,
0x9d053f6d,
0x9e88c6b3,
0xa0000000,
0xa16bad37,
0xa2cc7edf,
0xa4231623,
0xa570068e,
#else
0x2000000000000000,
0x32b803473f7ad0f4,
0x4000000000000000,
0x4a4d3c25e68dc57f,
0x52b803473f7ad0f4,
0x59d5d9fd5010b366,
0x6000000000000000,
0x6570068e7ef5a1e8,
0x6a4d3c25e68dc57f,
0x6eb3a9f01975077f,
0x72b803473f7ad0f4,
0x766a008e4788cbcd,
0x79d5d9fd5010b366,
0x7d053f6d26089673,
0x8000000000000000,
0x82cc7edf592262d0,
0x8570068e7ef5a1e8,
0x87ef05ae409a0289,
0x8a4d3c25e68dc57f,
0x8c8ddd448f8b845a,
0x8eb3a9f01975077f,
0x90c10500d63aa659,
0x92b803473f7ad0f4,
0x949a784bcd1b8afe,
0x966a008e4788cbcd,
0x982809d5be7072dc,
0x99d5d9fd5010b366,
0x9b74948f5532da4b,
0x9d053f6d26089673,
0x9e88c6b3626a72aa,
0xa000000000000000,
0xa16bad3758efd873,
0xa2cc7edf592262d0,
0xa4231623369e78e6,
0xa570068e7ef5a1e8,
#endif
};

/* compute floor(a*b) or ceil(a*b) with b = log2(radix) or
   b=1/log2(radix). For is_inv = 0, strict accuracy is not guaranteed
   when radix is not a power of two. */
slimb_t bf_mul_log2_radix(slimb_t a1, unsigned int radix, int is_inv,
                          int is_ceil1)
{
    int is_neg;
    limb_t a;
    BOOL is_ceil;

    is_ceil = is_ceil1;
    a = a1;
    if (a1 < 0) {
        a = -a;
        is_neg = 1;
    } else {
        is_neg = 0;
    }
    is_ceil ^= is_neg;
    if ((radix & (radix - 1)) == 0) {
        int radix_bits;
        /* radix is a power of two */
        radix_bits = ceil_log2(radix);
        if (is_inv) {
            if (is_ceil)
                a += radix_bits - 1;
            a = a / radix_bits;
        } else {
            a = a * radix_bits;
        }
    } else {
        const uint32_t *tab;
        limb_t b0, b1;
        dlimb_t t;
        
        if (is_inv) {
            tab = inv_log2_radix[radix - 2];
#if LIMB_BITS == 32
            b1 = tab[0];
            b0 = tab[1];
#else
            b1 = ((limb_t)tab[0] << 32) | tab[1];
            b0 = (limb_t)tab[2] << 32;
#endif
            t = (dlimb_t)b0 * (dlimb_t)a;
            t = (dlimb_t)b1 * (dlimb_t)a + (t >> LIMB_BITS);
            a = t >> (LIMB_BITS - 1);
        } else {
            b0 = log2_radix[radix - 2];
            t = (dlimb_t)b0 * (dlimb_t)a;
            a = t >> (LIMB_BITS - 3);
        }
        /* a = floor(result) and 'result' cannot be an integer */
        a += is_ceil;
    }
    if (is_neg)
        a = -a;
    return a;
}

/* 'n' is the number of output limbs */
static int bf_integer_to_radix_rec(bf_t *pow_tab,
                                   limb_t *out, const bf_t *a, limb_t n,
                                   int level, limb_t n0, limb_t radixl,
                                   unsigned int radixl_bits)
{
    limb_t n1, n2, q_prec;
    int ret;
    
    assert(n >= 1);
    if (n == 1) {
        out[0] = get_bits(a->tab, a->len, a->len * LIMB_BITS - a->expn);
    } else if (n == 2) {
        dlimb_t t;
        slimb_t pos;
        pos = a->len * LIMB_BITS - a->expn;
        t = ((dlimb_t)get_bits(a->tab, a->len, pos + LIMB_BITS) << LIMB_BITS) |
            get_bits(a->tab, a->len, pos);
        if (likely(radixl == RADIXL_10)) {
            /* use division by a constant when possible */
            out[0] = t % RADIXL_10;
            out[1] = t / RADIXL_10;
        } else {
            out[0] = t % radixl;
            out[1] = t / radixl;
        }
    } else {
        bf_t Q, R, *B, *B_inv;
        int q_add;
        bf_init(a->ctx, &Q);
        bf_init(a->ctx, &R);
        n2 = (((n0 * 2) >> (level + 1)) + 1) / 2;
        n1 = n - n2;
        B = &pow_tab[2 * level];
        B_inv = &pow_tab[2 * level + 1];
        ret = 0;
        if (B->len == 0) {
            /* compute BASE^n2 */
            ret |= bf_pow_ui_ui(B, radixl, n2, BF_PREC_INF, BF_RNDZ);
            /* we use enough bits for the maximum possible 'n1' value,
               i.e. n2 + 1 */
            ret |= bf_set_ui(&R, 1);
            ret |= bf_div(B_inv, &R, B, (n2 + 1) * radixl_bits + 2, BF_RNDN);
        }
        //        printf("%d: n1=% " PRId64 " n2=%" PRId64 "\n", level, n1, n2);
        q_prec = n1 * radixl_bits;
        ret |= bf_mul(&Q, a, B_inv, q_prec, BF_RNDN);
        ret |= bf_rint(&Q, BF_RNDZ);
        
        ret |= bf_mul(&R, &Q, B, BF_PREC_INF, BF_RNDZ);
        ret |= bf_sub(&R, a, &R, BF_PREC_INF, BF_RNDZ);

        if (ret & BF_ST_MEM_ERROR)
            goto fail;
        /* adjust if necessary */
        q_add = 0;
        while (R.sign && R.len != 0) {
            if (bf_add(&R, &R, B, BF_PREC_INF, BF_RNDZ))
                goto fail;
            q_add--;
        }
        while (bf_cmpu(&R, B) >= 0) {
            if (bf_sub(&R, &R, B, BF_PREC_INF, BF_RNDZ))
                goto fail;
            q_add++;
        }
        if (q_add != 0) {
            if (bf_add_si(&Q, &Q, q_add, BF_PREC_INF, BF_RNDZ))
                goto fail;
        }
        if (bf_integer_to_radix_rec(pow_tab, out + n2, &Q, n1, level + 1, n0,
                                    radixl, radixl_bits))
            goto fail;
        if (bf_integer_to_radix_rec(pow_tab, out, &R, n2, level + 1, n0,
                                    radixl, radixl_bits)) {
        fail:
            bf_delete(&Q);
            bf_delete(&R);
            return -1;
        }
        bf_delete(&Q);
        bf_delete(&R);
    }
    return 0;
}

/* return 0 if OK != 0 if memory error */
static int bf_integer_to_radix(bf_t *r, const bf_t *a, limb_t radixl)
{
    bf_context_t *s = r->ctx;
    limb_t r_len;
    bf_t *pow_tab;
    int i, pow_tab_len, ret;
    
    r_len = r->len;
    pow_tab_len = (ceil_log2(r_len) + 2) * 2; /* XXX: check */
    pow_tab = bf_malloc(s, sizeof(pow_tab[0]) * pow_tab_len);
    if (!pow_tab)
        return -1;
    for(i = 0; i < pow_tab_len; i++)
        bf_init(r->ctx, &pow_tab[i]);

    ret = bf_integer_to_radix_rec(pow_tab, r->tab, a, r_len, 0, r_len, radixl,
                                  ceil_log2(radixl));

    for(i = 0; i < pow_tab_len; i++) {
        bf_delete(&pow_tab[i]);
    }
    bf_free(s, pow_tab);
    return ret;
}

/* a must be >= 0. 'P' is the wanted number of digits in radix
   'radix'. 'r' is the mantissa represented as an integer. *pE
   contains the exponent. Return != 0 if memory error. */
static int bf_convert_to_radix(bf_t *r, slimb_t *pE,
                               const bf_t *a, int radix,
                               limb_t P, bf_rnd_t rnd_mode,
                               BOOL is_fixed_exponent)
{
    slimb_t E, e, prec, extra_bits, ziv_extra_bits, prec0;
    bf_t B_s, *B = &B_s;
    int e_sign, ret, res;
    
    if (a->len == 0) {
        /* zero case */
        *pE = 0;
        return bf_set(r, a);
    }

    if (is_fixed_exponent) {
        E = *pE;
    } else {
        /* compute the new exponent */
        E = 1 + bf_mul_log2_radix(a->expn - 1, radix, TRUE, FALSE);
    }
    //    bf_print_str("a", a);
    //    printf("E=%ld P=%ld radix=%d\n", E, P, radix);
    
    for(;;) {
        e = P - E;
        e_sign = 0;
        if (e < 0) {
            e = -e;
            e_sign = 1;
        }
        /* Note: precision for log2(radix) is not critical here */
        prec0 = bf_mul_log2_radix(P, radix, FALSE, TRUE);
        ziv_extra_bits = 16;
        for(;;) {
            prec = prec0 + ziv_extra_bits;
            /* XXX: rigorous error analysis needed */
            extra_bits = ceil_log2(e) * 2 + 1;
            ret = bf_pow_ui_ui(r, radix, e, prec + extra_bits,
                               BF_RNDN | BF_FLAG_EXT_EXP);
            if (!e_sign)
                ret |= bf_mul(r, r, a, prec + extra_bits,
                              BF_RNDN | BF_FLAG_EXT_EXP);
            else
                ret |= bf_div(r, a, r, prec + extra_bits,
                              BF_RNDN | BF_FLAG_EXT_EXP);
            if (ret & BF_ST_MEM_ERROR)
                return BF_ST_MEM_ERROR;
            /* if the result is not exact, check that it can be safely
               rounded to an integer */
            if ((ret & BF_ST_INEXACT) &&
                !bf_can_round(r, r->expn, rnd_mode, prec)) {
                /* and more precision and retry */
                ziv_extra_bits = ziv_extra_bits  + (ziv_extra_bits / 2);
                continue;
            } else {
                ret = bf_rint(r, rnd_mode);
                if (ret & BF_ST_MEM_ERROR)
                    return BF_ST_MEM_ERROR;
                break;
            }
        }
        if (is_fixed_exponent)
            break;
        /* check that the result is < B^P */
        /* XXX: do a fast approximate test first ? */
        bf_init(r->ctx, B);
        ret = bf_pow_ui_ui(B, radix, P, BF_PREC_INF, BF_RNDZ);
        if (ret) {
            bf_delete(B);
            return ret;
        }
        res = bf_cmpu(r, B);
        bf_delete(B);
        if (res < 0)
            break;
        /* try a larger exponent */
        E++;
    }
    *pE = E;
    return 0;
}

static void limb_to_a(char *buf, limb_t n, unsigned int radix, int len)
{
    int digit, i;

    if (radix == 10) {
        /* specific case with constant divisor */
        for(i = len - 1; i >= 0; i--) {
            digit = (limb_t)n % 10;
            n = (limb_t)n / 10;
            buf[i] = digit + '0';
        }
    } else {
        for(i = len - 1; i >= 0; i--) {
            digit = (limb_t)n % radix;
            n = (limb_t)n / radix;
            if (digit < 10)
                digit += '0';
            else
                digit += 'a' - 10;
            buf[i] = digit;
        }
    }
}

/* for power of 2 radixes */
static void limb_to_a2(char *buf, limb_t n, unsigned int radix_bits, int len)
{
    int digit, i;
    unsigned int mask;

    mask = (1 << radix_bits) - 1;
    for(i = len - 1; i >= 0; i--) {
        digit = n & mask;
        n >>= radix_bits;
        if (digit < 10)
            digit += '0';
        else
            digit += 'a' - 10;
        buf[i] = digit;
    }
}

/* 'a' must be an integer if the is_dec = FALSE or if the radix is not
   a power of two. A dot is added before the 'dot_pos' digit. dot_pos
   = n_digits does not display the dot. 0 <= dot_pos <=
   n_digits. n_digits >= 1. */
static void output_digits(DynBuf *s, const bf_t *a1, int radix, limb_t n_digits,
                          limb_t dot_pos, BOOL is_dec)
{
    limb_t i, v, l;
    slimb_t pos, pos_incr;
    int digits_per_limb, buf_pos, radix_bits, first_buf_pos;
    char buf[65];
    bf_t a_s, *a;

    if (is_dec) {
        digits_per_limb = LIMB_DIGITS;
        a = (bf_t *)a1;
        radix_bits = 0;
        pos = a->len;
        pos_incr = 1;
        first_buf_pos = 0;
    } else if ((radix & (radix - 1)) == 0) {
        a = (bf_t *)a1;
        radix_bits = ceil_log2(radix);
        digits_per_limb = LIMB_BITS / radix_bits;
        pos_incr = digits_per_limb * radix_bits;
        /* digits are aligned relative to the radix point */
        pos = a->len * LIMB_BITS + smod(-a->expn, radix_bits);
        first_buf_pos = 0;
    } else {
        limb_t n, radixl;

        digits_per_limb = digits_per_limb_table[radix - 2];
        radixl = get_limb_radix(radix);
        a = &a_s;
        bf_init(a1->ctx, a);
        n = (n_digits + digits_per_limb - 1) / digits_per_limb;
        if (bf_resize(a, n)) {
            dbuf_set_error(s);
            goto done;
        }
        if (bf_integer_to_radix(a, a1, radixl)) {
            dbuf_set_error(s);
            goto done;
        }
        radix_bits = 0;
        pos = n;
        pos_incr = 1;
        first_buf_pos = pos * digits_per_limb - n_digits;
    }
    buf_pos = digits_per_limb;
    i = 0;
    while (i < n_digits) {
        if (buf_pos == digits_per_limb) {
            pos -= pos_incr;
            if (radix_bits == 0) {
                v = get_limbz(a, pos);
                limb_to_a(buf, v, radix, digits_per_limb);
            } else {
                v = get_bits(a->tab, a->len, pos);
                limb_to_a2(buf, v, radix_bits, digits_per_limb);
            }
            buf_pos = first_buf_pos;
            first_buf_pos = 0;
        }
        if (i < dot_pos) {
            l = dot_pos;
        } else {
            if (i == dot_pos)
                dbuf_putc(s, '.');
            l = n_digits;
        }
        l = bf_min(digits_per_limb - buf_pos, l - i);
        dbuf_put(s, (uint8_t *)(buf + buf_pos), l);
        buf_pos += l;
        i += l;
    }
 done:
    if (a != a1)
        bf_delete(a);
}

static void *bf_dbuf_realloc(void *opaque, void *ptr, size_t size)
{
    bf_context_t *s = opaque;
    return bf_realloc(s, ptr, size);
}

/* return the length in bytes. A trailing '\0' is added */
static char *bf_ftoa_internal(size_t *plen, const bf_t *a2, int radix,
                              limb_t prec, bf_flags_t flags, BOOL is_dec)
{
    bf_context_t *ctx = a2->ctx;
    DynBuf s_s, *s = &s_s;
    int radix_bits;
    
    //    bf_print_str("ftoa", a2);
    //    printf("radix=%d\n", radix);
    dbuf_init2(s, ctx, bf_dbuf_realloc);
    if (a2->expn == BF_EXP_NAN) {
        dbuf_putstr(s, "NaN");
    } else {
        if (a2->sign)
            dbuf_putc(s, '-');
        if (a2->expn == BF_EXP_INF) {
            if (flags & BF_FTOA_JS_QUIRKS)
                dbuf_putstr(s, "Infinity");
            else
                dbuf_putstr(s, "Inf");
        } else {
            int fmt, ret;
            slimb_t n_digits, n, i, n_max, n1;
            bf_t a1_s, *a1 = &a1_s;

            if ((radix & (radix - 1)) != 0)
                radix_bits = 0;
            else
                radix_bits = ceil_log2(radix);

            fmt = flags & BF_FTOA_FORMAT_MASK;
            bf_init(ctx, a1);
            if (fmt == BF_FTOA_FORMAT_FRAC) {
                if (is_dec || radix_bits != 0) {
                    if (bf_set(a1, a2))
                        goto fail1;
#ifdef USE_BF_DEC
                    if (is_dec) {
                        if (bfdec_round((bfdec_t *)a1, prec, (flags & BF_RND_MASK) | BF_FLAG_RADPNT_PREC) & BF_ST_MEM_ERROR)
                            goto fail1;
                        n = a1->expn;
                    } else
#endif
                    {
                        if (bf_round(a1, prec * radix_bits, (flags & BF_RND_MASK) | BF_FLAG_RADPNT_PREC) & BF_ST_MEM_ERROR)
                            goto fail1;
                        n = ceil_div(a1->expn, radix_bits);
                    }
                    if (flags & BF_FTOA_ADD_PREFIX) {
                        if (radix == 16)
                            dbuf_putstr(s, "0x");
                        else if (radix == 8)
                            dbuf_putstr(s, "0o");
                        else if (radix == 2)
                            dbuf_putstr(s, "0b");
                    }
                    if (a1->expn == BF_EXP_ZERO) {
                        dbuf_putstr(s, "0");
                        if (prec > 0) {
                            dbuf_putstr(s, ".");
                            for(i = 0; i < prec; i++) {
                                dbuf_putc(s, '0');
                            }
                        }
                    } else {
                        n_digits = prec + n;
                        if (n <= 0) {
                            /* 0.x */
                            dbuf_putstr(s, "0.");
                            for(i = 0; i < -n; i++) {
                                dbuf_putc(s, '0');
                            }
                            if (n_digits > 0) {
                                output_digits(s, a1, radix, n_digits, n_digits, is_dec);
                            }
                        } else {
                            output_digits(s, a1, radix, n_digits, n, is_dec);
                        }
                    }
                } else {
                    size_t pos, start;
                    bf_t a_s, *a = &a_s;

                    /* make a positive number */
                    a->tab = a2->tab;
                    a->len = a2->len;
                    a->expn = a2->expn;
                    a->sign = 0;
                    
                    /* one more digit for the rounding */
                    n = 1 + bf_mul_log2_radix(bf_max(a->expn, 0), radix, TRUE, TRUE);
                    n_digits = n + prec;
                    n1 = n;
                    if (bf_convert_to_radix(a1, &n1, a, radix, n_digits,
                                            flags & BF_RND_MASK, TRUE))
                        goto fail1;
                    start = s->size;
                    output_digits(s, a1, radix, n_digits, n, is_dec);
                    /* remove leading zeros because we allocated one more digit */
                    pos = start;
                    while ((pos + 1) < s->size && s->buf[pos] == '0' &&
                           s->buf[pos + 1] != '.')
                        pos++;
                    if (pos > start) {
                        memmove(s->buf + start, s->buf + pos, s->size - pos);
                        s->size -= (pos - start);
                    }
                }
            } else {
#ifdef USE_BF_DEC
                if (is_dec) {
                    if (bf_set(a1, a2))
                        goto fail1;
                    if (fmt == BF_FTOA_FORMAT_FIXED) {
                        n_digits = prec;
                        n_max = n_digits;
                        if (bfdec_round((bfdec_t *)a1, prec, (flags & BF_RND_MASK)) & BF_ST_MEM_ERROR)
                            goto fail1;
                    } else {
                        /* prec is ignored */
                        prec = n_digits = a1->len * LIMB_DIGITS;
                        /* remove the trailing zero digits */
                        while (n_digits > 1 &&
                               get_digit(a1->tab, a1->len, prec - n_digits) == 0) {
                            n_digits--;
                        }
                        n_max = n_digits + 4;
                    }
                    n = a1->expn;
                } else
#endif
                if (radix_bits != 0) {
                    if (bf_set(a1, a2))
                        goto fail1;
                    if (fmt == BF_FTOA_FORMAT_FIXED) {
                        slimb_t prec_bits;
                        n_digits = prec;
                        n_max = n_digits;
                        /* align to the radix point */
                        prec_bits = prec * radix_bits -
                            smod(-a1->expn, radix_bits);
                        if (bf_round(a1, prec_bits,
                                     (flags & BF_RND_MASK)) & BF_ST_MEM_ERROR)
                            goto fail1;
                    } else {
                        limb_t digit_mask;
                        slimb_t pos;
                        /* position of the digit before the most
                           significant digit in bits */
                        pos = a1->len * LIMB_BITS +
                            smod(-a1->expn, radix_bits);
                        n_digits = ceil_div(pos, radix_bits);
                        /* remove the trailing zero digits */
                        digit_mask = ((limb_t)1 << radix_bits) - 1;
                        while (n_digits > 1 &&
                               (get_bits(a1->tab, a1->len, pos - n_digits * radix_bits) & digit_mask) == 0) {
                            n_digits--;
                        }
                        n_max = n_digits + 4;
                    }
                    n = ceil_div(a1->expn, radix_bits);
                } else {
                    bf_t a_s, *a = &a_s;
                    
                    /* make a positive number */
                    a->tab = a2->tab;
                    a->len = a2->len;
                    a->expn = a2->expn;
                    a->sign = 0;
                    
                    if (fmt == BF_FTOA_FORMAT_FIXED) {
                        n_digits = prec;
                        n_max = n_digits;
                    } else {
                        slimb_t n_digits_max, n_digits_min;
                        
                        assert(prec != BF_PREC_INF);
                        n_digits = 1 + bf_mul_log2_radix(prec, radix, TRUE, TRUE);
                        /* max number of digits for non exponential
                           notation. The rational is to have the same rule
                           as JS i.e. n_max = 21 for 64 bit float in base 10. */
                        n_max = n_digits + 4;
                        if (fmt == BF_FTOA_FORMAT_FREE_MIN) {
                            bf_t b_s, *b = &b_s;
                            
                            /* find the minimum number of digits by
                               dichotomy. */
                            /* XXX: inefficient */
                            n_digits_max = n_digits;
                            n_digits_min = 1;
                            bf_init(ctx, b);
                            while (n_digits_min < n_digits_max) {
                                n_digits = (n_digits_min + n_digits_max) / 2;
                                if (bf_convert_to_radix(a1, &n, a, radix, n_digits,
                                                        flags & BF_RND_MASK, FALSE)) {
                                    bf_delete(b);
                                    goto fail1;
                                }
                                /* convert back to a number and compare */
                                ret = bf_mul_pow_radix(b, a1, radix, n - n_digits,
                                                       prec,
                                                       (flags & ~BF_RND_MASK) |
                                                       BF_RNDN);
                                if (ret & BF_ST_MEM_ERROR) {
                                    bf_delete(b);
                                    goto fail1;
                                }
                                if (bf_cmpu(b, a) == 0) {
                                    n_digits_max = n_digits;
                                } else {
                                    n_digits_min = n_digits + 1;
                                }
                            }
                            bf_delete(b);
                            n_digits = n_digits_max;
                        }
                    }
                    if (bf_convert_to_radix(a1, &n, a, radix, n_digits,
                                            flags & BF_RND_MASK, FALSE)) {
                    fail1:
                        bf_delete(a1);
                        goto fail;
                    }
                }
                if (a1->expn == BF_EXP_ZERO &&
                    fmt != BF_FTOA_FORMAT_FIXED &&
                    !(flags & BF_FTOA_FORCE_EXP)) {
                    /* just output zero */
                    dbuf_putstr(s, "0");
                } else {
                    if (flags & BF_FTOA_ADD_PREFIX) {
                        if (radix == 16)
                            dbuf_putstr(s, "0x");
                        else if (radix == 8)
                            dbuf_putstr(s, "0o");
                        else if (radix == 2)
                            dbuf_putstr(s, "0b");
                    }
                    if (a1->expn == BF_EXP_ZERO)
                        n = 1;
                    if ((flags & BF_FTOA_FORCE_EXP) ||
                        n <= -6 || n > n_max) {
                        const char *fmt;
                        /* exponential notation */
                        output_digits(s, a1, radix, n_digits, 1, is_dec);
                        if (radix_bits != 0 && radix <= 16) {
                            if (flags & BF_FTOA_JS_QUIRKS)
                                fmt = "p%+" PRId_LIMB;
                            else
                                fmt = "p%" PRId_LIMB;
                            dbuf_printf(s, fmt, (n - 1) * radix_bits);
                        } else {
                            if (flags & BF_FTOA_JS_QUIRKS)
                                fmt = "%c%+" PRId_LIMB;
                            else
                                fmt = "%c%" PRId_LIMB;
                            dbuf_printf(s, fmt,
                                        radix <= 10 ? 'e' : '@', n - 1);
                        }
                    } else if (n <= 0) {
                        /* 0.x */
                        dbuf_putstr(s, "0.");
                        for(i = 0; i < -n; i++) {
                            dbuf_putc(s, '0');
                        }
                        output_digits(s, a1, radix, n_digits, n_digits, is_dec);
                    } else {
                        if (n_digits <= n) {
                            /* no dot */
                            output_digits(s, a1, radix, n_digits, n_digits, is_dec);
                            for(i = 0; i < (n - n_digits); i++)
                                dbuf_putc(s, '0');
                        } else {
                            output_digits(s, a1, radix, n_digits, n, is_dec);
                        }
                    }
                }
            }
            bf_delete(a1);
        }
    }
    dbuf_putc(s, '\0');
    if (dbuf_error(s))
        goto fail;
    if (plen)
        *plen = s->size - 1;
    return (char *)s->buf;
 fail:
    bf_free(ctx, s->buf);
    if (plen)
        *plen = 0;
    return NULL;
}

char *bf_ftoa(size_t *plen, const bf_t *a, int radix, limb_t prec,
              bf_flags_t flags)
{
    return bf_ftoa_internal(plen, a, radix, prec, flags, FALSE);
}

/***************************************************************/
/* transcendental functions */

/* Note: the algorithm is from MPFR */
static void bf_const_log2_rec(bf_t *T, bf_t *P, bf_t *Q, limb_t n1,
                              limb_t n2, BOOL need_P)
{
    bf_context_t *s = T->ctx;
    if ((n2 - n1) == 1) {
        if (n1 == 0) {
            bf_set_ui(P, 3);
        } else {
            bf_set_ui(P, n1);
            P->sign = 1;
        }
        bf_set_ui(Q, 2 * n1 + 1);
        Q->expn += 2;
        bf_set(T, P);
    } else {
        limb_t m;
        bf_t T1_s, *T1 = &T1_s;
        bf_t P1_s, *P1 = &P1_s;
        bf_t Q1_s, *Q1 = &Q1_s;
        
        m = n1 + ((n2 - n1) >> 1);
        bf_const_log2_rec(T, P, Q, n1, m, TRUE);
        bf_init(s, T1);
        bf_init(s, P1);
        bf_init(s, Q1);
        bf_const_log2_rec(T1, P1, Q1, m, n2, need_P);
        bf_mul(T, T, Q1, BF_PREC_INF, BF_RNDZ);
        bf_mul(T1, T1, P, BF_PREC_INF, BF_RNDZ);
        bf_add(T, T, T1, BF_PREC_INF, BF_RNDZ);
        if (need_P)
            bf_mul(P, P, P1, BF_PREC_INF, BF_RNDZ);
        bf_mul(Q, Q, Q1, BF_PREC_INF, BF_RNDZ);
        bf_delete(T1);
        bf_delete(P1);
        bf_delete(Q1);
    }
}

/* compute log(2) with faithful rounding at precision 'prec' */
static void bf_const_log2_internal(bf_t *T, limb_t prec)
{
    limb_t w, N;
    bf_t P_s, *P = &P_s;
    bf_t Q_s, *Q = &Q_s;

    w = prec + 15;
    N = w / 3 + 1;
    bf_init(T->ctx, P);
    bf_init(T->ctx, Q);
    bf_const_log2_rec(T, P, Q, 0, N, FALSE);
    bf_div(T, T, Q, prec, BF_RNDN);
    bf_delete(P);
    bf_delete(Q);
}

/* PI constant */

#define CHUD_A 13591409
#define CHUD_B 545140134
#define CHUD_C 640320
#define CHUD_BITS_PER_TERM 47

static void chud_bs(bf_t *P, bf_t *Q, bf_t *G, int64_t a, int64_t b, int need_g,
                    limb_t prec)
{
    bf_context_t *s = P->ctx;
    int64_t c;

    if (a == (b - 1)) {
        bf_t T0, T1;
        
        bf_init(s, &T0);
        bf_init(s, &T1);
        bf_set_ui(G, 2 * b - 1);
        bf_mul_ui(G, G, 6 * b - 1, prec, BF_RNDN);
        bf_mul_ui(G, G, 6 * b - 5, prec, BF_RNDN);
        bf_set_ui(&T0, CHUD_B);
        bf_mul_ui(&T0, &T0, b, prec, BF_RNDN);
        bf_set_ui(&T1, CHUD_A);
        bf_add(&T0, &T0, &T1, prec, BF_RNDN);
        bf_mul(P, G, &T0, prec, BF_RNDN);
        P->sign = b & 1;

        bf_set_ui(Q, b);
        bf_mul_ui(Q, Q, b, prec, BF_RNDN);
        bf_mul_ui(Q, Q, b, prec, BF_RNDN);
        bf_mul_ui(Q, Q, (uint64_t)CHUD_C * CHUD_C * CHUD_C / 24, prec, BF_RNDN);
        bf_delete(&T0);
        bf_delete(&T1);
    } else {
        bf_t P2, Q2, G2;
        
        bf_init(s, &P2);
        bf_init(s, &Q2);
        bf_init(s, &G2);

        c = (a + b) / 2;
        chud_bs(P, Q, G, a, c, 1, prec);
        chud_bs(&P2, &Q2, &G2, c, b, need_g, prec);
        
        /* Q = Q1 * Q2 */
        /* G = G1 * G2 */
        /* P = P1 * Q2 + P2 * G1 */
        bf_mul(&P2, &P2, G, prec, BF_RNDN);
        if (!need_g)
            bf_set_ui(G, 0);
        bf_mul(P, P, &Q2, prec, BF_RNDN);
        bf_add(P, P, &P2, prec, BF_RNDN);
        bf_delete(&P2);

        bf_mul(Q, Q, &Q2, prec, BF_RNDN);
        bf_delete(&Q2);
        if (need_g)
            bf_mul(G, G, &G2, prec, BF_RNDN);
        bf_delete(&G2);
    }
}

/* compute Pi with faithful rounding at precision 'prec' using the
   Chudnovsky formula */
static void bf_const_pi_internal(bf_t *Q, limb_t prec)
{
    bf_context_t *s = Q->ctx;
    int64_t n, prec1;
    bf_t P, G;

    /* number of serie terms */
    n = prec / CHUD_BITS_PER_TERM + 1;
    /* XXX: precision analysis */
    prec1 = prec + 32;

    bf_init(s, &P);
    bf_init(s, &G);

    chud_bs(&P, Q, &G, 0, n, 0, BF_PREC_INF);
    
    bf_mul_ui(&G, Q, CHUD_A, prec1, BF_RNDN);
    bf_add(&P, &G, &P, prec1, BF_RNDN);
    bf_div(Q, Q, &P, prec1, BF_RNDF);
 
    bf_set_ui(&P, CHUD_C);
    bf_sqrt(&G, &P, prec1, BF_RNDF);
    bf_mul_ui(&G, &G, (uint64_t)CHUD_C / 12, prec1, BF_RNDF);
    bf_mul(Q, Q, &G, prec, BF_RNDN);
    bf_delete(&P);
    bf_delete(&G);
}

static int bf_const_get(bf_t *T, limb_t prec, bf_flags_t flags,
                        BFConstCache *c,
                        void (*func)(bf_t *res, limb_t prec), int sign)
{
    limb_t ziv_extra_bits, prec1;

    ziv_extra_bits = 32;
    for(;;) {
        prec1 = prec + ziv_extra_bits;
        if (c->prec < prec1) {
            if (c->val.len == 0)
                bf_init(T->ctx, &c->val);
            func(&c->val, prec1);
            c->prec = prec1;
        } else {
            prec1 = c->prec;
        }
        bf_set(T, &c->val);
        T->sign = sign;
        if (!bf_can_round(T, prec, flags & BF_RND_MASK, prec1)) {
            /* and more precision and retry */
            ziv_extra_bits = ziv_extra_bits  + (ziv_extra_bits / 2);
        } else {
            break;
        }
    }
    return bf_round(T, prec, flags);
}

static void bf_const_free(BFConstCache *c)
{
    bf_delete(&c->val);
    memset(c, 0, sizeof(*c));
}

int bf_const_log2(bf_t *T, limb_t prec, bf_flags_t flags)
{
    bf_context_t *s = T->ctx;
    return bf_const_get(T, prec, flags, &s->log2_cache, bf_const_log2_internal, 0);
}

/* return rounded pi * (1 - 2 * sign) */
static int bf_const_pi_signed(bf_t *T, int sign, limb_t prec, bf_flags_t flags)
{
    bf_context_t *s = T->ctx;
    return bf_const_get(T, prec, flags, &s->pi_cache, bf_const_pi_internal,
                        sign);
}

int bf_const_pi(bf_t *T, limb_t prec, bf_flags_t flags)
{
    return bf_const_pi_signed(T, 0, prec, flags);
}

void bf_clear_cache(bf_context_t *s)
{
#ifdef USE_FFT_MUL
    fft_clear_cache(s);
#endif
    bf_const_free(&s->log2_cache);
    bf_const_free(&s->pi_cache);
}

/* ZivFunc should compute the result 'r' with faithful rounding at
   precision 'prec'. For efficiency purposes, the final bf_round()
   does not need to be done in the function. */
typedef int ZivFunc(bf_t *r, const bf_t *a, limb_t prec, void *opaque);

static int bf_ziv_rounding(bf_t *r, const bf_t *a,
                           limb_t prec, bf_flags_t flags,
                           ZivFunc *f, void *opaque)
{
    int rnd_mode, ret;
    slimb_t prec1, ziv_extra_bits;
    
    rnd_mode = flags & BF_RND_MASK;
    if (rnd_mode == BF_RNDF) {
        /* no need to iterate */
        f(r, a, prec, opaque);
        ret = 0;
    } else {
        ziv_extra_bits = 32;
        for(;;) {
            prec1 = prec + ziv_extra_bits;
            ret = f(r, a, prec1, opaque);
            if (ret & (BF_ST_OVERFLOW | BF_ST_UNDERFLOW | BF_ST_MEM_ERROR)) {
                /* overflow or underflow should never happen because
                   it indicates the rounding cannot be done correctly,
                   but we do not catch all the cases */
                return ret;
            }
            /* if the result is exact, we can stop */
            if (!(ret & BF_ST_INEXACT)) {
                ret = 0;
                break;
            }
            if (bf_can_round(r, prec, rnd_mode, prec1)) {
                ret = BF_ST_INEXACT;
                break;
            }
            ziv_extra_bits = ziv_extra_bits * 2;
            //            printf("ziv_extra_bits=%" PRId64 "\n", (int64_t)ziv_extra_bits);
        }
    }
    if (r->len == 0)
        return ret;
    else
        return __bf_round(r, prec, flags, r->len, ret);
}

/* add (1 - 2*e_sign) * 2^e */
static int bf_add_epsilon(bf_t *r, const bf_t *a, slimb_t e, int e_sign,
                          limb_t prec, int flags)
{
    bf_t T_s, *T = &T_s;
    int ret;
    /* small argument case: result = 1 + epsilon * sign(x) */
    bf_init(a->ctx, T);
    bf_set_ui(T, 1);
    T->sign = e_sign;
    T->expn += e;
    ret = bf_add(r, r, T, prec, flags);
    bf_delete(T);
    return ret;
}

/* Compute the exponential using faithful rounding at precision 'prec'.
   Note: the algorithm is from MPFR */
static int bf_exp_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)
{
    bf_context_t *s = r->ctx;
    bf_t T_s, *T = &T_s;
    slimb_t n, K, l, i, prec1;
    
    assert(r != a);

    /* argument reduction:
       T = a - n*log(2) with 0 <= T < log(2) and n integer.
    */
    bf_init(s, T);
    if (a->expn <= -1) {
        /* 0 <= abs(a) <= 0.5 */
        if (a->sign)
            n = -1;
        else
            n = 0;
    } else {
        bf_const_log2(T, LIMB_BITS, BF_RNDZ);
        bf_div(T, a, T, LIMB_BITS, BF_RNDD);
        bf_get_limb(&n, T, 0);
    }

    K = bf_isqrt((prec + 1) / 2);
    l = (prec - 1) / K + 1;
    /* XXX: precision analysis ? */
    prec1 = prec + (K + 2 * l + 18) + K + 8;
    if (a->expn > 0)
        prec1 += a->expn;
    //    printf("n=%ld K=%ld prec1=%ld\n", n, K, prec1);

    bf_const_log2(T, prec1, BF_RNDF);
    bf_mul_si(T, T, n, prec1, BF_RNDN);
    bf_sub(T, a, T, prec1, BF_RNDN);

    /* reduce the range of T */
    bf_mul_2exp(T, -K, BF_PREC_INF, BF_RNDZ);
    
    /* Taylor expansion around zero :
     1 + x + x^2/2 + ... + x^n/n! 
     = (1 + x * (1 + x/2 * (1 + ... (x/n))))
    */
    {
        bf_t U_s, *U = &U_s;
        
        bf_init(s, U);
        bf_set_ui(r, 1);
        for(i = l ; i >= 1; i--) {
            bf_set_ui(U, i);
            bf_div(U, T, U, prec1, BF_RNDN);
            bf_mul(r, r, U, prec1, BF_RNDN);
            bf_add_si(r, r, 1, prec1, BF_RNDN);
        }
        bf_delete(U);
    }
    bf_delete(T);
    
    /* undo the range reduction */
    for(i = 0; i < K; i++) {
        bf_mul(r, r, r, prec1, BF_RNDN | BF_FLAG_EXT_EXP);
    }

    /* undo the argument reduction */
    bf_mul_2exp(r, n, BF_PREC_INF, BF_RNDZ | BF_FLAG_EXT_EXP);

    return BF_ST_INEXACT;
}

/* crude overflow and underflow tests for exp(a). a_low <= a <= a_high */
static int check_exp_underflow_overflow(bf_context_t *s, bf_t *r,
                                        const bf_t *a_low, const bf_t *a_high,
                                        limb_t prec, bf_flags_t flags)
{
    bf_t T_s, *T = &T_s;
    bf_t log2_s, *log2 = &log2_s;
    slimb_t e_min, e_max;
    
    if (a_high->expn <= 0)
        return 0;

    e_max = (limb_t)1 << (bf_get_exp_bits(flags) - 1);
    e_min = -e_max + 3;
    if (flags & BF_FLAG_SUBNORMAL)
        e_min -= (prec - 1);
    
    bf_init(s, T);
    bf_init(s, log2);
    bf_const_log2(log2, LIMB_BITS, BF_RNDU);
    bf_mul_ui(T, log2, e_max, LIMB_BITS, BF_RNDU);
    /* a_low > e_max * log(2) implies exp(a) > e_max */
    if (bf_cmp_lt(T, a_low) > 0) {
        /* overflow */
        bf_delete(T);
        bf_delete(log2);
        return bf_set_overflow(r, 0, prec, flags);
    }
    /* a_high < (e_min - 2) * log(2) implies exp(a) < (e_min - 2) */
    bf_const_log2(log2, LIMB_BITS, BF_RNDD);
    bf_mul_si(T, log2, e_min - 2, LIMB_BITS, BF_RNDD);
    if (bf_cmp_lt(a_high, T)) {
        int rnd_mode = flags & BF_RND_MASK;
        
        /* underflow */
        bf_delete(T);
        bf_delete(log2);
        if (rnd_mode == BF_RNDU) {
            /* set the smallest value */
            bf_set_ui(r, 1);
            r->expn = e_min;
        } else {
            bf_set_zero(r, 0);
        }
        return BF_ST_UNDERFLOW | BF_ST_INEXACT;
    }
    bf_delete(log2);
    bf_delete(T);
    return 0;
}

int bf_exp(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)
{
    bf_context_t *s = r->ctx;
    int ret;
    assert(r != a);
    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bf_set_nan(r);
        } else if (a->expn == BF_EXP_INF) {
            if (a->sign)
                bf_set_zero(r, 0);
            else
                bf_set_inf(r, 0);
        } else {
            bf_set_ui(r, 1);
        }
        return 0;
    }

    ret = check_exp_underflow_overflow(s, r, a, a, prec, flags);
    if (ret)
        return ret;
    if (a->expn < 0 && (-a->expn) >= (prec + 2)) { 
        /* small argument case: result = 1 + epsilon * sign(x) */
        bf_set_ui(r, 1);
        return bf_add_epsilon(r, r, -(prec + 2), a->sign, prec, flags);
    }
                         
    return bf_ziv_rounding(r, a, prec, flags, bf_exp_internal, NULL);
}

static int bf_log_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)
{
    bf_context_t *s = r->ctx;
    bf_t T_s, *T = &T_s;
    bf_t U_s, *U = &U_s;
    bf_t V_s, *V = &V_s;
    slimb_t n, prec1, l, i, K;
    
    assert(r != a);

    bf_init(s, T);
    /* argument reduction 1 */
    /* T=a*2^n with 2/3 <= T <= 4/3 */
    {
        bf_t U_s, *U = &U_s;
        bf_set(T, a);
        n = T->expn;
        T->expn = 0;
        /* U= ~ 2/3 */
        bf_init(s, U);
        bf_set_ui(U, 0xaaaaaaaa); 
        U->expn = 0;
        if (bf_cmp_lt(T, U)) {
            T->expn++;
            n--;
        }
        bf_delete(U);
    }
    //    printf("n=%ld\n", n);
    //    bf_print_str("T", T);

    /* XXX: precision analysis */
    /* number of iterations for argument reduction 2 */
    K = bf_isqrt((prec + 1) / 2); 
    /* order of Taylor expansion */
    l = prec / (2 * K) + 1; 
    /* precision of the intermediate computations */
    prec1 = prec + K + 2 * l + 32;

    bf_init(s, U);
    bf_init(s, V);
    
    /* Note: cancellation occurs here, so we use more precision (XXX:
       reduce the precision by computing the exact cancellation) */
    bf_add_si(T, T, -1, BF_PREC_INF, BF_RNDN); 

    /* argument reduction 2 */
    for(i = 0; i < K; i++) {
        /* T = T / (1 + sqrt(1 + T)) */
        bf_add_si(U, T, 1, prec1, BF_RNDN);
        bf_sqrt(V, U, prec1, BF_RNDF);
        bf_add_si(U, V, 1, prec1, BF_RNDN);
        bf_div(T, T, U, prec1, BF_RNDN);
    }

    {
        bf_t Y_s, *Y = &Y_s;
        bf_t Y2_s, *Y2 = &Y2_s;
        bf_init(s, Y);
        bf_init(s, Y2);

        /* compute ln(1+x) = ln((1+y)/(1-y)) with y=x/(2+x)
           = y + y^3/3 + ... + y^(2*l + 1) / (2*l+1) 
           with Y=Y^2
           = y*(1+Y/3+Y^2/5+...) = y*(1+Y*(1/3+Y*(1/5 + ...)))
        */
        bf_add_si(Y, T, 2, prec1, BF_RNDN);
        bf_div(Y, T, Y, prec1, BF_RNDN);

        bf_mul(Y2, Y, Y, prec1, BF_RNDN);
        bf_set_ui(r, 0);
        for(i = l; i >= 1; i--) {
            bf_set_ui(U, 1);
            bf_set_ui(V, 2 * i + 1);
            bf_div(U, U, V, prec1, BF_RNDN);
            bf_add(r, r, U, prec1, BF_RNDN);
            bf_mul(r, r, Y2, prec1, BF_RNDN);
        }
        bf_add_si(r, r, 1, prec1, BF_RNDN);
        bf_mul(r, r, Y, prec1, BF_RNDN);
        bf_delete(Y);
        bf_delete(Y2);
    }
    bf_delete(V);
    bf_delete(U);

    /* multiplication by 2 for the Taylor expansion and undo the
       argument reduction 2*/
    bf_mul_2exp(r, K + 1, BF_PREC_INF, BF_RNDZ);
    
    /* undo the argument reduction 1 */
    bf_const_log2(T, prec1, BF_RNDF);
    bf_mul_si(T, T, n, prec1, BF_RNDN);
    bf_add(r, r, T, prec1, BF_RNDN);
    
    bf_delete(T);
    return BF_ST_INEXACT;
}

int bf_log(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)
{
    bf_context_t *s = r->ctx;
    bf_t T_s, *T = &T_s;
    
    assert(r != a);
    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bf_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF) {
            if (a->sign) {
                bf_set_nan(r);
                return BF_ST_INVALID_OP;
            } else {
                bf_set_inf(r, 0);
                return 0;
            }
        } else {
            bf_set_inf(r, 1);
            return 0;
        }
    }
    if (a->sign) {
        bf_set_nan(r);
        return BF_ST_INVALID_OP;
    }
    bf_init(s, T);
    bf_set_ui(T, 1);
    if (bf_cmp_eq(a, T)) {
        bf_set_zero(r, 0);
        bf_delete(T);
        return 0;
    }
    bf_delete(T);

    return bf_ziv_rounding(r, a, prec, flags, bf_log_internal, NULL);
}

/* x and y finite and x > 0 */
static int bf_pow_generic(bf_t *r, const bf_t *x, limb_t prec, void *opaque)
{
    bf_context_t *s = r->ctx;
    const bf_t *y = opaque;
    bf_t T_s, *T = &T_s;
    limb_t prec1;

    bf_init(s, T);
    /* XXX: proof for the added precision */
    prec1 = prec + 32;
    bf_log(T, x, prec1, BF_RNDF | BF_FLAG_EXT_EXP);
    bf_mul(T, T, y, prec1, BF_RNDF | BF_FLAG_EXT_EXP);
    if (bf_is_nan(T))
        bf_set_nan(r);
    else
        bf_exp_internal(r, T, prec1, NULL); /* no overflow/underlow test needed */
    bf_delete(T);
    return BF_ST_INEXACT;
}

/* x and y finite, x > 0, y integer and y fits on one limb */
static int bf_pow_int(bf_t *r, const bf_t *x, limb_t prec, void *opaque)
{
    bf_context_t *s = r->ctx;
    const bf_t *y = opaque;
    bf_t T_s, *T = &T_s;
    limb_t prec1;
    int ret;
    slimb_t y1;
    
    bf_get_limb(&y1, y, 0);
    if (y1 < 0)
        y1 = -y1;
    /* XXX: proof for the added precision */
    prec1 = prec + ceil_log2(y1) * 2 + 8;
    ret = bf_pow_ui(r, x, y1 < 0 ? -y1 : y1, prec1, BF_RNDN | BF_FLAG_EXT_EXP);
    if (y->sign) {
        bf_init(s, T);
        bf_set_ui(T, 1);
        ret |= bf_div(r, T, r, prec1, BF_RNDN | BF_FLAG_EXT_EXP);
        bf_delete(T);
    }
    return ret;
}

/* x must be a finite non zero float. Return TRUE if there is a
   floating point number r such as x=r^(2^n) and return this floating
   point number 'r'. Otherwise return FALSE and r is undefined. */
static BOOL check_exact_power2n(bf_t *r, const bf_t *x, slimb_t n)
{
    bf_context_t *s = r->ctx;
    bf_t T_s, *T = &T_s;
    slimb_t e, i, er;
    limb_t v;
    
    /* x = m*2^e with m odd integer */
    e = bf_get_exp_min(x);
    /* fast check on the exponent */
    if (n > (LIMB_BITS - 1)) {
        if (e != 0)
            return FALSE;
        er = 0;
    } else {
        if ((e & (((limb_t)1 << n) - 1)) != 0)
            return FALSE;
        er = e >> n;
    }
    /* every perfect odd square = 1 modulo 8 */
    v = get_bits(x->tab, x->len, x->len * LIMB_BITS - x->expn + e);
    if ((v & 7) != 1)
        return FALSE;

    bf_init(s, T);
    bf_set(T, x);
    T->expn -= e;
    for(i = 0; i < n; i++) {
        if (i != 0)
            bf_set(T, r);
        if (bf_sqrtrem(r, NULL, T) != 0)
            return FALSE;
    }
    r->expn += er;
    return TRUE;
}

/* prec = BF_PREC_INF is accepted for x and y integers and y >= 0 */
int bf_pow(bf_t *r, const bf_t *x, const bf_t *y, limb_t prec, bf_flags_t flags)
{
    bf_context_t *s = r->ctx;
    bf_t T_s, *T = &T_s;
    bf_t ytmp_s;
    BOOL y_is_int, y_is_odd;
    int r_sign, ret, rnd_mode;
    slimb_t y_emin;
    
    if (x->len == 0 || y->len == 0) {
        if (y->expn == BF_EXP_ZERO) {
            /* pow(x, 0) = 1 */
            bf_set_ui(r, 1);
        } else if (x->expn == BF_EXP_NAN) {
            bf_set_nan(r);
        } else {
            int cmp_x_abs_1;
            bf_set_ui(r, 1);
            cmp_x_abs_1 = bf_cmpu(x, r);
            if (cmp_x_abs_1 == 0 && (flags & BF_POW_JS_QUIRKS) &&
                (y->expn >= BF_EXP_INF)) {
                bf_set_nan(r);
            } else if (cmp_x_abs_1 == 0 &&
                       (!x->sign || y->expn != BF_EXP_NAN)) {
                /* pow(1, y) = 1 even if y = NaN */
                /* pow(-1, +/-inf) = 1 */
            } else if (y->expn == BF_EXP_NAN) {
                bf_set_nan(r);
            } else if (y->expn == BF_EXP_INF) {
                if (y->sign == (cmp_x_abs_1 > 0)) {
                    bf_set_zero(r, 0);
                } else {
                    bf_set_inf(r, 0);
                }
            } else {
                y_emin = bf_get_exp_min(y);
                y_is_odd = (y_emin == 0);
                if (y->sign == (x->expn == BF_EXP_ZERO)) {
                    bf_set_inf(r, y_is_odd & x->sign);
                    if (y->sign) {
                        /* pow(0, y) with y < 0 */
                        return BF_ST_DIVIDE_ZERO;
                    }
                } else {
                    bf_set_zero(r, y_is_odd & x->sign);
                }
            }
        }
        return 0;
    }
    bf_init(s, T);
    bf_set(T, x);
    y_emin = bf_get_exp_min(y);
    y_is_int = (y_emin >= 0);
    rnd_mode = flags & BF_RND_MASK;
    if (x->sign) {
        if (!y_is_int) {
            bf_set_nan(r);
            bf_delete(T);
            return BF_ST_INVALID_OP;
        }
        y_is_odd = (y_emin == 0);
        r_sign = y_is_odd;
        /* change the directed rounding mode if the sign of the result
           is changed */
        if (r_sign && (rnd_mode == BF_RNDD || rnd_mode == BF_RNDU))
            flags ^= 1;
        bf_neg(T);
    } else {
        r_sign = 0;
    }

    bf_set_ui(r, 1);
    if (bf_cmp_eq(T, r)) {
        /* abs(x) = 1: nothing more to do */
        ret = 0;
    } else {
        /* check the overflow/underflow cases */
        {
            bf_t al_s, *al = &al_s;
            bf_t ah_s, *ah = &ah_s;
            limb_t precl = LIMB_BITS;
            
            bf_init(s, al);
            bf_init(s, ah);
            /* compute bounds of log(abs(x)) * y with a low precision */
            /* XXX: compute bf_log() once */
            /* XXX: add a fast test before this slow test */
            bf_log(al, T, precl, BF_RNDD);
            bf_log(ah, T, precl, BF_RNDU);
            bf_mul(al, al, y, precl, BF_RNDD ^ y->sign);
            bf_mul(ah, ah, y, precl, BF_RNDU ^ y->sign);
            ret = check_exp_underflow_overflow(s, r, al, ah, prec, flags);
            bf_delete(al);
            bf_delete(ah);
            if (ret)
                goto done;
        }
        
        if (y_is_int) {
            slimb_t T_bits, e;
        int_pow:
            T_bits = T->expn - bf_get_exp_min(T);
            if (T_bits == 1) {
                /* pow(2^b, y) = 2^(b*y) */
                bf_mul_si(T, y, T->expn - 1, LIMB_BITS, BF_RNDZ);
                bf_get_limb(&e, T, 0);
                bf_set_ui(r, 1);
                ret = bf_mul_2exp(r, e, prec, flags);
            } else if (prec == BF_PREC_INF) {
                slimb_t y1;
                /* specific case for infinite precision (integer case) */
                bf_get_limb(&y1, y, 0);
                assert(!y->sign);
                /* x must be an integer, so abs(x) >= 2 */
                if (y1 >= ((slimb_t)1 << BF_EXP_BITS_MAX)) {
                    bf_delete(T);
                    return bf_set_overflow(r, 0, BF_PREC_INF, flags);
                }
                ret = bf_pow_ui(r, T, y1, BF_PREC_INF, BF_RNDZ);
            } else {
                if (y->expn <= 31) {
                    /* small enough power: use exponentiation in all cases */
                } else if (y->sign) {
                    /* cannot be exact */
                    goto general_case;
                } else {
                    if (rnd_mode == BF_RNDF)
                        goto general_case; /* no need to track exact results */
                    /* see if the result has a chance to be exact:
                       if x=a*2^b (a odd), x^y=a^y*2^(b*y)
                       x^y needs a precision of at least floor_log2(a)*y bits
                    */
                    bf_mul_si(r, y, T_bits - 1, LIMB_BITS, BF_RNDZ);
                    bf_get_limb(&e, r, 0);
                    if (prec < e)
                        goto general_case;
                }
                ret = bf_ziv_rounding(r, T, prec, flags, bf_pow_int, (void *)y);
            }
        } else {
            if (rnd_mode != BF_RNDF) {
                bf_t *y1;
                if (y_emin < 0 && check_exact_power2n(r, T, -y_emin)) {
                    /* the problem is reduced to a power to an integer */
#if 0
                    printf("\nn=%" PRId64 "\n", -(int64_t)y_emin);
                    bf_print_str("T", T);
                    bf_print_str("r", r);
#endif
                    bf_set(T, r);
                    y1 = &ytmp_s;
                    y1->tab = y->tab;
                    y1->len = y->len;
                    y1->sign = y->sign;
                    y1->expn = y->expn - y_emin;
                    y = y1;
                    goto int_pow;
                }
            }
        general_case:
            ret = bf_ziv_rounding(r, T, prec, flags, bf_pow_generic, (void *)y);
        }
    }
 done:
    bf_delete(T);
    r->sign = r_sign;
    return ret;
}

/* compute sqrt(-2*x-x^2) to get |sin(x)| from cos(x) - 1. */
static void bf_sqrt_sin(bf_t *r, const bf_t *x, limb_t prec1)
{
    bf_context_t *s = r->ctx;
    bf_t T_s, *T = &T_s;
    bf_init(s, T);
    bf_set(T, x);
    bf_mul(r, T, T, prec1, BF_RNDN);
    bf_mul_2exp(T, 1, BF_PREC_INF, BF_RNDZ);
    bf_add(T, T, r, prec1, BF_RNDN);
    bf_neg(T);
    bf_sqrt(r, T, prec1, BF_RNDF);
    bf_delete(T);
}

static int bf_sincos(bf_t *s, bf_t *c, const bf_t *a, limb_t prec)
{
    bf_context_t *s1 = a->ctx;
    bf_t T_s, *T = &T_s;
    bf_t U_s, *U = &U_s;
    bf_t r_s, *r = &r_s;
    slimb_t K, prec1, i, l, mod, prec2;
    int is_neg;
    
    assert(c != a && s != a);

    bf_init(s1, T);
    bf_init(s1, U);
    bf_init(s1, r);
    
    /* XXX: precision analysis */
    K = bf_isqrt(prec / 2);
    l = prec / (2 * K) + 1;
    prec1 = prec + 2 * K + l + 8;
    
    /* after the modulo reduction, -pi/4 <= T <= pi/4 */
    if (a->expn <= -1) {
        /* abs(a) <= 0.25: no modulo reduction needed */
        bf_set(T, a);
        mod = 0;
    } else {
        slimb_t cancel;
        cancel = 0;
        for(;;) {
            prec2 = prec1 + a->expn + cancel;
            bf_const_pi(U, prec2, BF_RNDF);
            bf_mul_2exp(U, -1, BF_PREC_INF, BF_RNDZ);
            bf_remquo(&mod, T, a, U, prec2, BF_RNDN, BF_RNDN);
            //            printf("T.expn=%ld prec2=%ld\n", T->expn, prec2);
            if (mod == 0 || (T->expn != BF_EXP_ZERO &&
                             (T->expn + prec2) >= (prec1 - 1)))
                break;
            /* increase the number of bits until the precision is good enough */
            cancel = bf_max(-T->expn, (cancel + 1) * 3 / 2);
        }
        mod &= 3;
    }
    
    is_neg = T->sign;
        
    /* compute cosm1(x) = cos(x) - 1 */
    bf_mul(T, T, T, prec1, BF_RNDN);
    bf_mul_2exp(T, -2 * K, BF_PREC_INF, BF_RNDZ);
    
    /* Taylor expansion:
       -x^2/2 + x^4/4! - x^6/6! + ...
    */
    bf_set_ui(r, 1);
    for(i = l ; i >= 1; i--) {
        bf_set_ui(U, 2 * i - 1);
        bf_mul_ui(U, U, 2 * i, BF_PREC_INF, BF_RNDZ);
        bf_div(U, T, U, prec1, BF_RNDN);
        bf_mul(r, r, U, prec1, BF_RNDN);
        bf_neg(r);
        if (i != 1)
            bf_add_si(r, r, 1, prec1, BF_RNDN);
    }
    bf_delete(U);

    /* undo argument reduction:
       cosm1(2*x)= 2*(2*cosm1(x)+cosm1(x)^2)
    */
    for(i = 0; i < K; i++) {
        bf_mul(T, r, r, prec1, BF_RNDN);
        bf_mul_2exp(r, 1, BF_PREC_INF, BF_RNDZ);
        bf_add(r, r, T, prec1, BF_RNDN);
        bf_mul_2exp(r, 1, BF_PREC_INF, BF_RNDZ);
    }
    bf_delete(T);

    if (c) {
        if ((mod & 1) == 0) {
            bf_add_si(c, r, 1, prec1, BF_RNDN);
        } else {
            bf_sqrt_sin(c, r, prec1);
            c->sign = is_neg ^ 1;
        }
        c->sign ^= mod >> 1;
    }
    if (s) {
        if ((mod & 1) == 0) {
            bf_sqrt_sin(s, r, prec1);
            s->sign = is_neg;
        } else {
            bf_add_si(s, r, 1, prec1, BF_RNDN);
        }
        s->sign ^= mod >> 1;
    }
    bf_delete(r);
    return BF_ST_INEXACT;
}

static int bf_cos_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)
{
    return bf_sincos(NULL, r, a, prec);
}

int bf_cos(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)
{
    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bf_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF) {
            bf_set_nan(r);
            return BF_ST_INVALID_OP;
        } else {
            bf_set_ui(r, 1);
            return 0;
        }
    }

    /* small argument case: result = 1+r(x) with r(x) = -x^2/2 +
       O(X^4). We assume r(x) < 2^(2*EXP(x) - 1). */
    if (a->expn < 0) {
        slimb_t e;
        e = 2 * a->expn - 1;
        if (e < -(prec + 2)) {
            bf_set_ui(r, 1);
            return bf_add_epsilon(r, r, e, 1, prec, flags);
        }
    }
    
    return bf_ziv_rounding(r, a, prec, flags, bf_cos_internal, NULL);
}

static int bf_sin_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)
{
    return bf_sincos(r, NULL, a, prec);
}

int bf_sin(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)
{
    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bf_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF) {
            bf_set_nan(r);
            return BF_ST_INVALID_OP;
        } else {
            bf_set_zero(r, a->sign);
            return 0;
        }
    }

    /* small argument case: result = x+r(x) with r(x) = -x^3/6 +
       O(X^5). We assume r(x) < 2^(3*EXP(x) - 2). */
    if (a->expn < 0) {
        slimb_t e;
        e = sat_add(2 * a->expn, a->expn - 2);
        if (e < a->expn - bf_max(prec + 2, a->len * LIMB_BITS + 2)) {
            bf_set(r, a);
            return bf_add_epsilon(r, r, e, 1 - a->sign, prec, flags);
        }
    }

    return bf_ziv_rounding(r, a, prec, flags, bf_sin_internal, NULL);
}

static int bf_tan_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)
{
    bf_context_t *s = r->ctx;
    bf_t T_s, *T = &T_s;
    limb_t prec1;
    
    /* XXX: precision analysis */
    prec1 = prec + 8;
    bf_init(s, T);
    bf_sincos(r, T, a, prec1);
    bf_div(r, r, T, prec1, BF_RNDF);
    bf_delete(T);
    return BF_ST_INEXACT;
}

int bf_tan(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)
{
    assert(r != a);
    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bf_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF) {
            bf_set_nan(r);
            return BF_ST_INVALID_OP;
        } else {
            bf_set_zero(r, a->sign);
            return 0;
        }
    }

    /* small argument case: result = x+r(x) with r(x) = x^3/3 +
       O(X^5). We assume r(x) < 2^(3*EXP(x) - 1). */
    if (a->expn < 0) {
        slimb_t e;
        e = sat_add(2 * a->expn, a->expn - 1);
        if (e < a->expn - bf_max(prec + 2, a->len * LIMB_BITS + 2)) {
            bf_set(r, a);
            return bf_add_epsilon(r, r, e, a->sign, prec, flags);
        }
    }
            
    return bf_ziv_rounding(r, a, prec, flags, bf_tan_internal, NULL);
}

/* if add_pi2 is true, add pi/2 to the result (used for acos(x) to
   avoid cancellation) */
static int bf_atan_internal(bf_t *r, const bf_t *a, limb_t prec,
                            void *opaque)
{
    bf_context_t *s = r->ctx;
    BOOL add_pi2 = (BOOL)(intptr_t)opaque;
    bf_t T_s, *T = &T_s;
    bf_t U_s, *U = &U_s;
    bf_t V_s, *V = &V_s;
    bf_t X2_s, *X2 = &X2_s;
    int cmp_1;
    slimb_t prec1, i, K, l;
    
    /* XXX: precision analysis */
    K = bf_isqrt((prec + 1) / 2);
    l = prec / (2 * K) + 1;
    prec1 = prec + K + 2 * l + 32;
    //    printf("prec=%d K=%d l=%d prec1=%d\n", (int)prec, (int)K, (int)l, (int)prec1);
    
    bf_init(s, T);
    cmp_1 = (a->expn >= 1); /* a >= 1 */
    if (cmp_1) {
        bf_set_ui(T, 1);
        bf_div(T, T, a, prec1, BF_RNDN);
    } else {
        bf_set(T, a);
    }

    /* abs(T) <= 1 */

    /* argument reduction */

    bf_init(s, U);
    bf_init(s, V);
    bf_init(s, X2);
    for(i = 0; i < K; i++) {
        /* T = T / (1 + sqrt(1 + T^2)) */
        bf_mul(U, T, T, prec1, BF_RNDN);
        bf_add_si(U, U, 1, prec1, BF_RNDN);
        bf_sqrt(V, U, prec1, BF_RNDN);
        bf_add_si(V, V, 1, prec1, BF_RNDN);
        bf_div(T, T, V, prec1, BF_RNDN);
    }

    /* Taylor series: 
       x - x^3/3 + ... + (-1)^ l * y^(2*l + 1) / (2*l+1) 
    */
    bf_mul(X2, T, T, prec1, BF_RNDN);
    bf_set_ui(r, 0);
    for(i = l; i >= 1; i--) {
        bf_set_si(U, 1);
        bf_set_ui(V, 2 * i + 1);
        bf_div(U, U, V, prec1, BF_RNDN);
        bf_neg(r);
        bf_add(r, r, U, prec1, BF_RNDN);
        bf_mul(r, r, X2, prec1, BF_RNDN);
    }
    bf_neg(r);
    bf_add_si(r, r, 1, prec1, BF_RNDN);
    bf_mul(r, r, T, prec1, BF_RNDN);

    /* undo the argument reduction */
    bf_mul_2exp(r, K, BF_PREC_INF, BF_RNDZ);
    
    bf_delete(U);
    bf_delete(V);
    bf_delete(X2);

    i = add_pi2;
    if (cmp_1 > 0) {
        /* undo the inversion : r = sign(a)*PI/2 - r */
        bf_neg(r);
        i += 1 - 2 * a->sign;
    }
    /* add i*(pi/2) with -1 <= i <= 2 */
    if (i != 0) {
        bf_const_pi(T, prec1, BF_RNDF);
        if (i != 2)
            bf_mul_2exp(T, -1, BF_PREC_INF, BF_RNDZ);
        T->sign = (i < 0);
        bf_add(r, T, r, prec1, BF_RNDN);
    }
    
    bf_delete(T);
    return BF_ST_INEXACT;
}

int bf_atan(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)
{
    bf_context_t *s = r->ctx;
    bf_t T_s, *T = &T_s;
    int res;
    
    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bf_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF)  {
            /* -PI/2 or PI/2 */
            bf_const_pi_signed(r, a->sign, prec, flags);
            bf_mul_2exp(r, -1, BF_PREC_INF, BF_RNDZ);
            return BF_ST_INEXACT;
        } else {
            bf_set_zero(r, a->sign);
            return 0;
        }
    }
    
    bf_init(s, T);
    bf_set_ui(T, 1);
    res = bf_cmpu(a, T);
    bf_delete(T);
    if (res == 0) {
        /* short cut: abs(a) == 1 -> +/-pi/4 */
        bf_const_pi_signed(r, a->sign, prec, flags);
        bf_mul_2exp(r, -2, BF_PREC_INF, BF_RNDZ);
        return BF_ST_INEXACT;
    }

    /* small argument case: result = x+r(x) with r(x) = -x^3/3 +
       O(X^5). We assume r(x) < 2^(3*EXP(x) - 1). */
    if (a->expn < 0) {
        slimb_t e;
        e = sat_add(2 * a->expn, a->expn - 1);
        if (e < a->expn - bf_max(prec + 2, a->len * LIMB_BITS + 2)) {
            bf_set(r, a);
            return bf_add_epsilon(r, r, e, 1 - a->sign, prec, flags);
        }
    }
    
    return bf_ziv_rounding(r, a, prec, flags, bf_atan_internal, (void *)FALSE);
}

static int bf_atan2_internal(bf_t *r, const bf_t *y, limb_t prec, void *opaque)
{
    bf_context_t *s = r->ctx;
    const bf_t *x = opaque;
    bf_t T_s, *T = &T_s;
    limb_t prec1;
    int ret;
    
    if (y->expn == BF_EXP_NAN || x->expn == BF_EXP_NAN) {
        bf_set_nan(r);
        return 0;
    }

    /* compute atan(y/x) assumming inf/inf = 1 and 0/0 = 0 */
    bf_init(s, T);
    prec1 = prec + 32;
    if (y->expn == BF_EXP_INF && x->expn == BF_EXP_INF) {
        bf_set_ui(T, 1);
        T->sign = y->sign ^ x->sign;
    } else if (y->expn == BF_EXP_ZERO && x->expn == BF_EXP_ZERO) {
        bf_set_zero(T, y->sign ^ x->sign);
    } else {
        bf_div(T, y, x, prec1, BF_RNDF);
    }
    ret = bf_atan(r, T, prec1, BF_RNDF);

    if (x->sign) {
        /* if x < 0 (it includes -0), return sign(y)*pi + atan(y/x) */
        bf_const_pi(T, prec1, BF_RNDF);
        T->sign = y->sign;
        bf_add(r, r, T, prec1, BF_RNDN);
        ret |= BF_ST_INEXACT;
    }

    bf_delete(T);
    return ret;
}

int bf_atan2(bf_t *r, const bf_t *y, const bf_t *x,
             limb_t prec, bf_flags_t flags)
{
    return bf_ziv_rounding(r, y, prec, flags, bf_atan2_internal, (void *)x);
}

static int bf_asin_internal(bf_t *r, const bf_t *a, limb_t prec, void *opaque)
{
    bf_context_t *s = r->ctx;
    BOOL is_acos = (BOOL)(intptr_t)opaque;
    bf_t T_s, *T = &T_s;
    limb_t prec1, prec2;
    
    /* asin(x) = atan(x/sqrt(1-x^2)) 
       acos(x) = pi/2 - asin(x) */
    prec1 = prec + 8;
    /* increase the precision in x^2 to compensate the cancellation in
       (1-x^2) if x is close to 1 */
    /* XXX: use less precision when possible */
    if (a->expn >= 0)
        prec2 = BF_PREC_INF;
    else
        prec2 = prec1;
    bf_init(s, T);
    bf_mul(T, a, a, prec2, BF_RNDN);
    bf_neg(T);
    bf_add_si(T, T, 1, prec2, BF_RNDN);

    bf_sqrt(r, T, prec1, BF_RNDN);
    bf_div(T, a, r, prec1, BF_RNDN);
    if (is_acos)
        bf_neg(T);
    bf_atan_internal(r, T, prec1, (void *)(intptr_t)is_acos);
    bf_delete(T);
    return BF_ST_INEXACT;
}

int bf_asin(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)
{
    bf_context_t *s = r->ctx;
    bf_t T_s, *T = &T_s;
    int res;

    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bf_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF) {
            bf_set_nan(r);
            return BF_ST_INVALID_OP;
        } else {
            bf_set_zero(r, a->sign);
            return 0;
        }
    }
    bf_init(s, T);
    bf_set_ui(T, 1);
    res = bf_cmpu(a, T);
    bf_delete(T);
    if (res > 0) {
        bf_set_nan(r);
        return BF_ST_INVALID_OP;
    }
    
    /* small argument case: result = x+r(x) with r(x) = x^3/6 +
       O(X^5). We assume r(x) < 2^(3*EXP(x) - 2). */
    if (a->expn < 0) {
        slimb_t e;
        e = sat_add(2 * a->expn, a->expn - 2);
        if (e < a->expn - bf_max(prec + 2, a->len * LIMB_BITS + 2)) {
            bf_set(r, a);
            return bf_add_epsilon(r, r, e, a->sign, prec, flags);
        }
    }

    return bf_ziv_rounding(r, a, prec, flags, bf_asin_internal, (void *)FALSE);
}

int bf_acos(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags)
{
    bf_context_t *s = r->ctx;
    bf_t T_s, *T = &T_s;
    int res;

    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bf_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF) {
            bf_set_nan(r);
            return BF_ST_INVALID_OP;
        } else {
            bf_const_pi(r, prec, flags);
            bf_mul_2exp(r, -1, BF_PREC_INF, BF_RNDZ);
            return BF_ST_INEXACT;
        }
    }
    bf_init(s, T);
    bf_set_ui(T, 1);
    res = bf_cmpu(a, T);
    bf_delete(T);
    if (res > 0) {
        bf_set_nan(r);
        return BF_ST_INVALID_OP;
    } else if (res == 0 && a->sign == 0) {
        bf_set_zero(r, 0);
        return 0;
    }
    
    return bf_ziv_rounding(r, a, prec, flags, bf_asin_internal, (void *)TRUE);
}

/***************************************************************/
/* decimal floating point numbers */

#ifdef USE_BF_DEC

#define adddq(r1, r0, a1, a0)                   \
    do {                                        \
        limb_t __t = r0;                        \
        r0 += (a0);                             \
        r1 += (a1) + (r0 < __t);                \
    } while (0)

#define subdq(r1, r0, a1, a0)                   \
    do {                                        \
        limb_t __t = r0;                        \
        r0 -= (a0);                             \
        r1 -= (a1) + (r0 > __t);                \
    } while (0)

#if LIMB_BITS == 64

/* Note: we assume __int128 is available */
#define muldq(r1, r0, a, b)                     \
    do {                                        \
        unsigned __int128 __t;                          \
        __t = (unsigned __int128)(a) * (unsigned __int128)(b);  \
        r0 = __t;                               \
        r1 = __t >> 64;                         \
    } while (0)

#define divdq(q, r, a1, a0, b)                  \
    do {                                        \
        unsigned __int128 __t;                  \
        limb_t __b = (b);                       \
        __t = ((unsigned __int128)(a1) << 64) | (a0);   \
        q = __t / __b;                                  \
        r = __t % __b;                                  \
    } while (0)

#else

#define muldq(r1, r0, a, b)                     \
    do {                                        \
        uint64_t __t;                          \
        __t = (uint64_t)(a) * (uint64_t)(b);  \
        r0 = __t;                               \
        r1 = __t >> 32;                         \
    } while (0)

#define divdq(q, r, a1, a0, b)                  \
    do {                                        \
        uint64_t __t;                  \
        limb_t __b = (b);                       \
        __t = ((uint64_t)(a1) << 32) | (a0);   \
        q = __t / __b;                                  \
        r = __t % __b;                                  \
    } while (0)

#endif /* LIMB_BITS != 64 */

static inline __maybe_unused limb_t shrd(limb_t low, limb_t high, long shift)
{
    if (shift != 0)
        low = (low >> shift) | (high << (LIMB_BITS - shift));
    return low;
}

static inline __maybe_unused limb_t shld(limb_t a1, limb_t a0, long shift)
{
    if (shift != 0)
        return (a1 << shift) | (a0 >> (LIMB_BITS - shift));
    else
        return a1;
}

#if LIMB_DIGITS == 19

/* WARNING: hardcoded for b = 1e19. It is assumed that:
   0 <= a1 < 2^63 */
#define divdq_base(q, r, a1, a0)\
do {\
    uint64_t __a0, __a1, __t0, __t1, __b = BF_DEC_BASE; \
    __a0 = a0;\
    __a1 = a1;\
    __t0 = __a1;\
    __t0 = shld(__t0, __a0, 1);\
    muldq(q, __t1, __t0, UINT64_C(17014118346046923173)); \
    muldq(__t1, __t0, q, __b);\
    subdq(__a1, __a0, __t1, __t0);\
    subdq(__a1, __a0, 1, __b * 2);    \
    __t0 = (slimb_t)__a1 >> 1; \
    q += 2 + __t0;\
    adddq(__a1, __a0, 0, __b & __t0);\
    q += __a1;                  \
    __a0 += __b & __a1;           \
    r = __a0;\
} while(0)

#elif LIMB_DIGITS == 9

/* WARNING: hardcoded for b = 1e9. It is assumed that:
   0 <= a1 < 2^29 */
#define divdq_base(q, r, a1, a0)\
do {\
    uint32_t __t0, __t1, __b = BF_DEC_BASE; \
    __t0 = a1;\
    __t1 = a0;\
    __t0 = (__t0 << 3) | (__t1 >> (32 - 3));    \
    muldq(q, __t1, __t0, 2305843009U);\
    r = a0 - q * __b;\
    __t1 = (r >= __b);\
    q += __t1;\
    if (__t1)\
        r -= __b;\
} while(0)

#endif

/* fast integer division by a fixed constant */

typedef struct FastDivData {
    limb_t m1; /* multiplier */
    int8_t shift1;
    int8_t shift2;
} FastDivData;

/* From "Division by Invariant Integers using Multiplication" by
   Torborn Granlund and Peter L. Montgomery */
/* d must be != 0 */
static inline __maybe_unused void fast_udiv_init(FastDivData *s, limb_t d)
{
    int l;
    limb_t q, r, m1;
    if (d == 1)
        l = 0;
    else
        l = 64 - clz64(d - 1);
    divdq(q, r, ((limb_t)1 << l) - d, 0, d);
    (void)r;
    m1 = q + 1;
    //    printf("d=%lu l=%d m1=0x%016lx\n", d, l, m1);
    s->m1 = m1;
    s->shift1 = l;
    if (s->shift1 > 1)
        s->shift1 = 1;
    s->shift2 = l - 1;
    if (s->shift2 < 0)
        s->shift2 = 0;
}

static inline limb_t fast_udiv(limb_t a, const FastDivData *s)
{
    limb_t t0, t1;
    muldq(t1, t0, s->m1, a);
    t0 = (a - t1) >> s->shift1;
    return (t1 + t0) >> s->shift2;
}

/* contains 10^i */
const limb_t mp_pow_dec[LIMB_DIGITS + 1] = {
    1U,
    10U,
    100U,
    1000U,
    10000U,
    100000U,
    1000000U,
    10000000U,
    100000000U,
    1000000000U,
#if LIMB_BITS == 64
    10000000000U,
    100000000000U,
    1000000000000U,
    10000000000000U,
    100000000000000U,
    1000000000000000U,
    10000000000000000U,
    100000000000000000U,
    1000000000000000000U,
    10000000000000000000U,
#endif
};

/* precomputed from fast_udiv_init(10^i) */
static const FastDivData mp_pow_div[LIMB_DIGITS + 1] = {
#if LIMB_BITS == 32
    { 0x00000001, 0, 0 },
    { 0x9999999a, 1, 3 },
    { 0x47ae147b, 1, 6 },
    { 0x0624dd30, 1, 9 },
    { 0xa36e2eb2, 1, 13 },
    { 0x4f8b588f, 1, 16 },
    { 0x0c6f7a0c, 1, 19 },
    { 0xad7f29ac, 1, 23 },
    { 0x5798ee24, 1, 26 },
    { 0x12e0be83, 1, 29 },
#else
    { 0x0000000000000001, 0, 0 },
    { 0x999999999999999a, 1, 3 },
    { 0x47ae147ae147ae15, 1, 6 },
    { 0x0624dd2f1a9fbe77, 1, 9 },
    { 0xa36e2eb1c432ca58, 1, 13 },
    { 0x4f8b588e368f0847, 1, 16 },
    { 0x0c6f7a0b5ed8d36c, 1, 19 },
    { 0xad7f29abcaf48579, 1, 23 },
    { 0x5798ee2308c39dfa, 1, 26 },
    { 0x12e0be826d694b2f, 1, 29 },
    { 0xb7cdfd9d7bdbab7e, 1, 33 },
    { 0x5fd7fe17964955fe, 1, 36 },
    { 0x19799812dea11198, 1, 39 },
    { 0xc25c268497681c27, 1, 43 },
    { 0x6849b86a12b9b01f, 1, 46 },
    { 0x203af9ee756159b3, 1, 49 },
    { 0xcd2b297d889bc2b7, 1, 53 },
    { 0x70ef54646d496893, 1, 56 },
    { 0x2725dd1d243aba0f, 1, 59 },
    { 0xd83c94fb6d2ac34d, 1, 63 },
#endif
};

/* divide by 10^shift with 0 <= shift <= LIMB_DIGITS */
static inline limb_t fast_shr_dec(limb_t a, int shift)
{
    return fast_udiv(a, &mp_pow_div[shift]);
}

/* division and remainder by 10^shift */
#define fast_shr_rem_dec(q, r, a, shift) q = fast_shr_dec(a, shift), r = a - q * mp_pow_dec[shift]
    
limb_t mp_add_dec(limb_t *res, const limb_t *op1, const limb_t *op2, 
                  mp_size_t n, limb_t carry)
{
    limb_t base = BF_DEC_BASE;
    mp_size_t i;
    limb_t k, a, v;

    k=carry;
    for(i=0;i<n;i++) {
        /* XXX: reuse the trick in add_mod */
        v = op1[i];
        a = v + op2[i] + k - base;
        k = a <= v;
        if (!k) 
            a += base;
        res[i]=a;
    }
    return k;
}

limb_t mp_add_ui_dec(limb_t *tab, limb_t b, mp_size_t n)
{
    limb_t base = BF_DEC_BASE;
    mp_size_t i;
    limb_t k, a, v;

    k=b;
    for(i=0;i<n;i++) {
        v = tab[i];
        a = v + k - base;
        k = a <= v;
        if (!k) 
            a += base;
        tab[i] = a;
        if (k == 0)
            break;
    }
    return k;
}

limb_t mp_sub_dec(limb_t *res, const limb_t *op1, const limb_t *op2, 
                  mp_size_t n, limb_t carry)
{
    limb_t base = BF_DEC_BASE;
    mp_size_t i;
    limb_t k, v, a;

    k=carry;
    for(i=0;i<n;i++) {
        v = op1[i];
        a = v - op2[i] - k;
        k = a > v;
        if (k)
            a += base;
        res[i] = a;
    }
    return k;
}

limb_t mp_sub_ui_dec(limb_t *tab, limb_t b, mp_size_t n)
{
    limb_t base = BF_DEC_BASE;
    mp_size_t i;
    limb_t k, v, a;
    
    k=b;
    for(i=0;i<n;i++) {
        v = tab[i];
        a = v - k;
        k = a > v;
        if (k)
            a += base;
        tab[i]=a;
        if (k == 0)
            break;
    }
    return k;
}

/* taba[] = taba[] * b + l. 0 <= b, l <= base - 1. Return the high carry */
limb_t mp_mul1_dec(limb_t *tabr, const limb_t *taba, mp_size_t n, 
                   limb_t b, limb_t l)
{
    mp_size_t i;
    limb_t t0, t1, r;

    for(i = 0; i < n; i++) {
        muldq(t1, t0, taba[i], b);
        adddq(t1, t0, 0, l);
        divdq_base(l, r, t1, t0);
        tabr[i] = r;
    }
    return l;
}

/* tabr[] += taba[] * b. 0 <= b <= base - 1. Return the value to add
   to the high word */
limb_t mp_add_mul1_dec(limb_t *tabr, const limb_t *taba, mp_size_t n,
                       limb_t b)
{
    mp_size_t i;
    limb_t l, t0, t1, r;

    l = 0;
    for(i = 0; i < n; i++) {
        muldq(t1, t0, taba[i], b);
        adddq(t1, t0, 0, l);
        adddq(t1, t0, 0, tabr[i]);
        divdq_base(l, r, t1, t0);
        tabr[i] = r;
    }
    return l;
}

/* tabr[] -= taba[] * b. 0 <= b <= base - 1. Return the value to
   substract to the high word. */
limb_t mp_sub_mul1_dec(limb_t *tabr, const limb_t *taba, mp_size_t n,
                       limb_t b)
{
    limb_t base = BF_DEC_BASE;
    mp_size_t i;
    limb_t l, t0, t1, r, a, v, c;

    /* XXX: optimize */
    l = 0;
    for(i = 0; i < n; i++) {
        muldq(t1, t0, taba[i], b);
        adddq(t1, t0, 0, l);
        divdq_base(l, r, t1, t0);
        v = tabr[i];
        a = v - r;
        c = a > v;
        if (c)
            a += base;
        /* never bigger than base because r = 0 when l = base - 1 */
        l += c;
        tabr[i] = a;
    }
    return l;
}

/* size of the result : op1_size + op2_size. */
void mp_mul_basecase_dec(limb_t *result, 
                         const limb_t *op1, mp_size_t op1_size, 
                         const limb_t *op2, mp_size_t op2_size) 
{
    mp_size_t i;
    limb_t r;
    
    result[op1_size] = mp_mul1_dec(result, op1, op1_size, op2[0], 0);

    for(i=1;i<op2_size;i++) {
        r = mp_add_mul1_dec(result + i, op1, op1_size, op2[i]);
        result[i + op1_size] = r;
    }
}

/* taba[] = (taba[] + r*base^na) / b. 0 <= b < base. 0 <= r <
   b. Return the remainder. */
limb_t mp_div1_dec(limb_t *tabr, const limb_t *taba, mp_size_t na, 
                   limb_t b, limb_t r)
{
    limb_t base = BF_DEC_BASE;
    mp_size_t i;
    limb_t t0, t1, q;
    int shift;

#if (BF_DEC_BASE % 2) == 0
    if (b == 2) {
        limb_t base_div2;
        /* Note: only works if base is even */
        base_div2 = base >> 1;
        if (r)
            r = base_div2;
        for(i = na - 1; i >= 0; i--) {
            t0 = taba[i];
            tabr[i] = (t0 >> 1) + r;
            r = 0;
            if (t0 & 1)
                r = base_div2;
        }
        if (r)
            r = 1;
    } else 
#endif
    if (na >= UDIV1NORM_THRESHOLD) {
        shift = clz(b);
        if (shift == 0) {
            /* normalized case: b >= 2^(LIMB_BITS-1) */
            limb_t b_inv;
            b_inv = udiv1norm_init(b);
            for(i = na - 1; i >= 0; i--) {
                muldq(t1, t0, r, base);
                adddq(t1, t0, 0, taba[i]);
                q = udiv1norm(&r, t1, t0, b, b_inv);
                tabr[i] = q;
            }
        } else {
            limb_t b_inv;
            b <<= shift;
            b_inv = udiv1norm_init(b);
            for(i = na - 1; i >= 0; i--) {
                muldq(t1, t0, r, base);
                adddq(t1, t0, 0, taba[i]);
                t1 = (t1 << shift) | (t0 >> (LIMB_BITS - shift));
                t0 <<= shift;
                q = udiv1norm(&r, t1, t0, b, b_inv);
                r >>= shift;
                tabr[i] = q;
            }
        }
    } else {
        for(i = na - 1; i >= 0; i--) {
            muldq(t1, t0, r, base);
            adddq(t1, t0, 0, taba[i]);
            divdq(q, r, t1, t0, b);
            tabr[i] = q;
        }
    }
    return r;
}

static __maybe_unused void mp_print_str_dec(const char *str,
                                       const limb_t *tab, slimb_t n)
{
    slimb_t i;
    printf("%s=", str);
    for(i = n - 1; i >= 0; i--) {
        if (i != n - 1)
            printf("_");
        printf("%0*" PRIu_LIMB, LIMB_DIGITS, tab[i]);
    }
    printf("\n");
}

static __maybe_unused void mp_print_str_h_dec(const char *str,
                                              const limb_t *tab, slimb_t n,
                                              limb_t high)
{
    slimb_t i;
    printf("%s=", str);
    printf("%0*" PRIu_LIMB, LIMB_DIGITS, high);
    for(i = n - 1; i >= 0; i--) {
        printf("_");
        printf("%0*" PRIu_LIMB, LIMB_DIGITS, tab[i]);
    }
    printf("\n");
}

//#define DEBUG_DIV_SLOW

#define DIV_STATIC_ALLOC_LEN 16

/* return q = a / b and r = a % b. 

   taba[na] must be allocated if tabb1[nb - 1] < B / 2.  tabb1[nb - 1]
   must be != zero. na must be >= nb. 's' can be NULL if tabb1[nb - 1]
   >= B / 2.

   The remainder is is returned in taba and contains nb libms. tabq
   contains na - nb + 1 limbs. No overlap is permitted.

   Running time of the standard method: (na - nb + 1) * nb
   Return 0 if OK, -1 if memory alloc error
*/
/* XXX: optimize */
static int mp_div_dec(bf_context_t *s, limb_t *tabq,
                      limb_t *taba, mp_size_t na, 
                      const limb_t *tabb1, mp_size_t nb)
{
    limb_t base = BF_DEC_BASE;
    limb_t r, mult, t0, t1, a, c, q, v, *tabb;
    mp_size_t i, j;
    limb_t static_tabb[DIV_STATIC_ALLOC_LEN];
    
#ifdef DEBUG_DIV_SLOW
    mp_print_str_dec("a", taba, na);
    mp_print_str_dec("b", tabb1, nb);
#endif

    /* normalize tabb */
    r = tabb1[nb - 1];
    assert(r != 0);
    i = na - nb;
    if (r >= BF_DEC_BASE / 2) {
        mult = 1;
        tabb = (limb_t *)tabb1;
        q = 1;
        for(j = nb - 1; j >= 0; j--) {
            if (taba[i + j] != tabb[j]) {
                if (taba[i + j] < tabb[j])
                    q = 0;
                break;
            }
        }
        tabq[i] = q;
        if (q) {
            mp_sub_dec(taba + i, taba + i, tabb, nb, 0);
        }
        i--;
    } else {
        mult = base / (r + 1);
        if (likely(nb <= DIV_STATIC_ALLOC_LEN)) {
            tabb = static_tabb;
        } else {
            tabb = bf_malloc(s, sizeof(limb_t) * nb);
            if (!tabb)
                return -1;
        }
        mp_mul1_dec(tabb, tabb1, nb, mult, 0);
        taba[na] = mp_mul1_dec(taba, taba, na, mult, 0);
    }

#ifdef DEBUG_DIV_SLOW
    printf("mult=" FMT_LIMB "\n", mult);
    mp_print_str_dec("a_norm", taba, na + 1);
    mp_print_str_dec("b_norm", tabb, nb);
#endif

    for(; i >= 0; i--) {
        if (unlikely(taba[i + nb] >= tabb[nb - 1])) {
            /* XXX: check if it is really possible */
            q = base - 1;
        } else {
            muldq(t1, t0, taba[i + nb], base);
            adddq(t1, t0, 0, taba[i + nb - 1]);
            divdq(q, r, t1, t0, tabb[nb - 1]);
        }
        //        printf("i=%d q1=%ld\n", i, q);

        r = mp_sub_mul1_dec(taba + i, tabb, nb, q);
        //        mp_dump("r1", taba + i, nb, bd);
        //        printf("r2=%ld\n", r);

        v = taba[i + nb];
        a = v - r;
        c = a > v;
        if (c)
            a += base;
        taba[i + nb] = a;

        if (c != 0) {
            /* negative result */
            for(;;) {
                q--;
                c = mp_add_dec(taba + i, taba + i, tabb, nb, 0);
                /* propagate carry and test if positive result */
                if (c != 0) {
                    if (++taba[i + nb] == base) {
                        break;
                    }
                }
            }
        }
        tabq[i] = q;
    }

#ifdef DEBUG_DIV_SLOW
    mp_print_str_dec("q", tabq, na - nb + 1);
    mp_print_str_dec("r", taba, nb);
#endif

    /* remove the normalization */
    if (mult != 1) {
        mp_div1_dec(taba, taba, nb, mult, 0);
        if (unlikely(tabb != static_tabb))
            bf_free(s, tabb);
    }
    return 0;
}

/* divide by 10^shift */
static limb_t mp_shr_dec(limb_t *tab_r, const limb_t *tab, mp_size_t n, 
                         limb_t shift, limb_t high)
{
    mp_size_t i;
    limb_t l, a, q, r;

    assert(shift >= 1 && shift < LIMB_DIGITS);
    l = high;
    for(i = n - 1; i >= 0; i--) {
        a = tab[i];
        fast_shr_rem_dec(q, r, a, shift);
        tab_r[i] = q + l * mp_pow_dec[LIMB_DIGITS - shift];
        l = r;
    }
    return l;
}

/* multiply by 10^shift */
static limb_t mp_shl_dec(limb_t *tab_r, const limb_t *tab, mp_size_t n, 
                         limb_t shift, limb_t low)
{
    mp_size_t i;
    limb_t l, a, q, r;

    assert(shift >= 1 && shift < LIMB_DIGITS);
    l = low;
    for(i = 0; i < n; i++) {
        a = tab[i];
        fast_shr_rem_dec(q, r, a, LIMB_DIGITS - shift);
        tab_r[i] = r * mp_pow_dec[shift] + l;
        l = q;
    }
    return l;
}

static limb_t mp_sqrtrem2_dec(limb_t *tabs, limb_t *taba)
{
    int k;
    dlimb_t a, b, r;
    limb_t taba1[2], s, r0, r1;

    /* convert to binary and normalize */
    a = (dlimb_t)taba[1] * BF_DEC_BASE + taba[0];
    k = clz(a >> LIMB_BITS) & ~1;
    b = a << k;
    taba1[0] = b;
    taba1[1] = b >> LIMB_BITS;
    mp_sqrtrem2(&s, taba1);
    s >>= (k >> 1);
    /* convert the remainder back to decimal */
    r = a - (dlimb_t)s * (dlimb_t)s;
    divdq_base(r1, r0, r >> LIMB_BITS, r);
    taba[0] = r0;
    tabs[0] = s;
    return r1;
}

//#define DEBUG_SQRTREM_DEC

/* tmp_buf must contain (n / 2 + 1 limbs) */
static limb_t mp_sqrtrem_rec_dec(limb_t *tabs, limb_t *taba, limb_t n,
                                 limb_t *tmp_buf)
{
    limb_t l, h, rh, ql, qh, c, i;
    
    if (n == 1)
        return mp_sqrtrem2_dec(tabs, taba);
#ifdef DEBUG_SQRTREM_DEC
    mp_print_str_dec("a", taba, 2 * n);
#endif
    l = n / 2;
    h = n - l;
    qh = mp_sqrtrem_rec_dec(tabs + l, taba + 2 * l, h, tmp_buf);
#ifdef DEBUG_SQRTREM_DEC
    mp_print_str_dec("s1", tabs + l, h);
    mp_print_str_h_dec("r1", taba + 2 * l, h, qh);
    mp_print_str_h_dec("r2", taba + l, n, qh);
#endif
    
    /* the remainder is in taba + 2 * l. Its high bit is in qh */
    if (qh) {
        mp_sub_dec(taba + 2 * l, taba + 2 * l, tabs + l, h, 0);
    }
    /* instead of dividing by 2*s, divide by s (which is normalized)
       and update q and r */
    mp_div_dec(NULL, tmp_buf, taba + l, n, tabs + l, h);
    qh += tmp_buf[l];
    for(i = 0; i < l; i++)
        tabs[i] = tmp_buf[i];
    ql = mp_div1_dec(tabs, tabs, l, 2, qh & 1);
    qh = qh >> 1; /* 0 or 1 */
    if (ql)
        rh = mp_add_dec(taba + l, taba + l, tabs + l, h, 0);
    else
        rh = 0;
#ifdef DEBUG_SQRTREM_DEC
    mp_print_str_h_dec("q", tabs, l, qh);
    mp_print_str_h_dec("u", taba + l, h, rh);
#endif
    
    mp_add_ui_dec(tabs + l, qh, h);
#ifdef DEBUG_SQRTREM_DEC
    mp_print_str_dec("s2", tabs, n);
#endif
    
    /* q = qh, tabs[l - 1 ... 0], r = taba[n - 1 ... l] */
    /* subtract q^2. if qh = 1 then q = B^l, so we can take shortcuts */
    if (qh) {
        c = qh;
    } else {
        mp_mul_basecase_dec(taba + n, tabs, l, tabs, l);
        c = mp_sub_dec(taba, taba, taba + n, 2 * l, 0);
    }
    rh -= mp_sub_ui_dec(taba + 2 * l, c, n - 2 * l);
    if ((slimb_t)rh < 0) {
        mp_sub_ui_dec(tabs, 1, n);
        rh += mp_add_mul1_dec(taba, tabs, n, 2);
        rh += mp_add_ui_dec(taba, 1, n);
    }
    return rh;
}

/* 'taba' has 2*n limbs with n >= 1 and taba[2*n-1] >= B/4. Return (s,
   r) with s=floor(sqrt(a)) and r=a-s^2. 0 <= r <= 2 * s. tabs has n
   limbs. r is returned in the lower n limbs of taba. Its r[n] is the
   returned value of the function. */
int mp_sqrtrem_dec(bf_context_t *s, limb_t *tabs, limb_t *taba, limb_t n)
{
    limb_t tmp_buf1[8];
    limb_t *tmp_buf;
    mp_size_t n2;
    n2 = n / 2 + 1;
    if (n2 <= countof(tmp_buf1)) {
        tmp_buf = tmp_buf1;
    } else {
        tmp_buf = bf_malloc(s, sizeof(limb_t) * n2);
        if (!tmp_buf)
            return -1;
    }
    taba[n] = mp_sqrtrem_rec_dec(tabs, taba, n, tmp_buf);
    if (tmp_buf != tmp_buf1)
        bf_free(s, tmp_buf);
    return 0;
}

/* return the number of leading zero digits, from 0 to LIMB_DIGITS */
static int clz_dec(limb_t a)
{
    if (a == 0)
        return LIMB_DIGITS;
    switch(LIMB_BITS - 1 - clz(a)) {
    case 0: /* 1-1 */
        return LIMB_DIGITS - 1;
    case 1: /* 2-3 */
        return LIMB_DIGITS - 1;
    case 2: /* 4-7 */
        return LIMB_DIGITS - 1;
    case 3: /* 8-15 */
        if (a < 10)
            return LIMB_DIGITS - 1;
        else
            return LIMB_DIGITS - 2;
    case 4: /* 16-31 */
        return LIMB_DIGITS - 2;
    case 5: /* 32-63 */
        return LIMB_DIGITS - 2;
    case 6: /* 64-127 */
        if (a < 100)
            return LIMB_DIGITS - 2;
        else
            return LIMB_DIGITS - 3;
    case 7: /* 128-255 */
        return LIMB_DIGITS - 3;
    case 8: /* 256-511 */
        return LIMB_DIGITS - 3;
    case 9: /* 512-1023 */
        if (a < 1000)
            return LIMB_DIGITS - 3;
        else
            return LIMB_DIGITS - 4;
    case 10: /* 1024-2047 */
        return LIMB_DIGITS - 4;
    case 11: /* 2048-4095 */
        return LIMB_DIGITS - 4;
    case 12: /* 4096-8191 */
        return LIMB_DIGITS - 4;
    case 13: /* 8192-16383 */
        if (a < 10000)
            return LIMB_DIGITS - 4;
        else
            return LIMB_DIGITS - 5;
    case 14: /* 16384-32767 */
        return LIMB_DIGITS - 5;
    case 15: /* 32768-65535 */
        return LIMB_DIGITS - 5;
    case 16: /* 65536-131071 */
        if (a < 100000)
            return LIMB_DIGITS - 5;
        else
            return LIMB_DIGITS - 6;
    case 17: /* 131072-262143 */
        return LIMB_DIGITS - 6;
    case 18: /* 262144-524287 */
        return LIMB_DIGITS - 6;
    case 19: /* 524288-1048575 */
        if (a < 1000000)
            return LIMB_DIGITS - 6;
        else
            return LIMB_DIGITS - 7;
    case 20: /* 1048576-2097151 */
        return LIMB_DIGITS - 7;
    case 21: /* 2097152-4194303 */
        return LIMB_DIGITS - 7;
    case 22: /* 4194304-8388607 */
        return LIMB_DIGITS - 7;
    case 23: /* 8388608-16777215 */
        if (a < 10000000)
            return LIMB_DIGITS - 7;
        else
            return LIMB_DIGITS - 8;
    case 24: /* 16777216-33554431 */
        return LIMB_DIGITS - 8;
    case 25: /* 33554432-67108863 */
        return LIMB_DIGITS - 8;
    case 26: /* 67108864-134217727 */
        if (a < 100000000)
            return LIMB_DIGITS - 8;
        else
            return LIMB_DIGITS - 9;
#if LIMB_BITS == 64
    case 27: /* 134217728-268435455 */
        return LIMB_DIGITS - 9;
    case 28: /* 268435456-536870911 */
        return LIMB_DIGITS - 9;
    case 29: /* 536870912-1073741823 */
        if (a < 1000000000)
            return LIMB_DIGITS - 9;
        else
            return LIMB_DIGITS - 10;
    case 30: /* 1073741824-2147483647 */
        return LIMB_DIGITS - 10;
    case 31: /* 2147483648-4294967295 */
        return LIMB_DIGITS - 10;
    case 32: /* 4294967296-8589934591 */
        return LIMB_DIGITS - 10;
    case 33: /* 8589934592-17179869183 */
        if (a < 10000000000)
            return LIMB_DIGITS - 10;
        else
            return LIMB_DIGITS - 11;
    case 34: /* 17179869184-34359738367 */
        return LIMB_DIGITS - 11;
    case 35: /* 34359738368-68719476735 */
        return LIMB_DIGITS - 11;
    case 36: /* 68719476736-137438953471 */
        if (a < 100000000000)
            return LIMB_DIGITS - 11;
        else
            return LIMB_DIGITS - 12;
    case 37: /* 137438953472-274877906943 */
        return LIMB_DIGITS - 12;
    case 38: /* 274877906944-549755813887 */
        return LIMB_DIGITS - 12;
    case 39: /* 549755813888-1099511627775 */
        if (a < 1000000000000)
            return LIMB_DIGITS - 12;
        else
            return LIMB_DIGITS - 13;
    case 40: /* 1099511627776-2199023255551 */
        return LIMB_DIGITS - 13;
    case 41: /* 2199023255552-4398046511103 */
        return LIMB_DIGITS - 13;
    case 42: /* 4398046511104-8796093022207 */
        return LIMB_DIGITS - 13;
    case 43: /* 8796093022208-17592186044415 */
        if (a < 10000000000000)
            return LIMB_DIGITS - 13;
        else
            return LIMB_DIGITS - 14;
    case 44: /* 17592186044416-35184372088831 */
        return LIMB_DIGITS - 14;
    case 45: /* 35184372088832-70368744177663 */
        return LIMB_DIGITS - 14;
    case 46: /* 70368744177664-140737488355327 */
        if (a < 100000000000000)
            return LIMB_DIGITS - 14;
        else
            return LIMB_DIGITS - 15;
    case 47: /* 140737488355328-281474976710655 */
        return LIMB_DIGITS - 15;
    case 48: /* 281474976710656-562949953421311 */
        return LIMB_DIGITS - 15;
    case 49: /* 562949953421312-1125899906842623 */
        if (a < 1000000000000000)
            return LIMB_DIGITS - 15;
        else
            return LIMB_DIGITS - 16;
    case 50: /* 1125899906842624-2251799813685247 */
        return LIMB_DIGITS - 16;
    case 51: /* 2251799813685248-4503599627370495 */
        return LIMB_DIGITS - 16;
    case 52: /* 4503599627370496-9007199254740991 */
        return LIMB_DIGITS - 16;
    case 53: /* 9007199254740992-18014398509481983 */
        if (a < 10000000000000000)
            return LIMB_DIGITS - 16;
        else
            return LIMB_DIGITS - 17;
    case 54: /* 18014398509481984-36028797018963967 */
        return LIMB_DIGITS - 17;
    case 55: /* 36028797018963968-72057594037927935 */
        return LIMB_DIGITS - 17;
    case 56: /* 72057594037927936-144115188075855871 */
        if (a < 100000000000000000)
            return LIMB_DIGITS - 17;
        else
            return LIMB_DIGITS - 18;
    case 57: /* 144115188075855872-288230376151711743 */
        return LIMB_DIGITS - 18;
    case 58: /* 288230376151711744-576460752303423487 */
        return LIMB_DIGITS - 18;
    case 59: /* 576460752303423488-1152921504606846975 */
        if (a < 1000000000000000000)
            return LIMB_DIGITS - 18;
        else
            return LIMB_DIGITS - 19;
#endif
    default:
        return 0;
    }
}

/* for debugging */
void bfdec_print_str(const char *str, const bfdec_t *a)
{
    slimb_t i;
    printf("%s=", str);

    if (a->expn == BF_EXP_NAN) {
        printf("NaN");
    } else {
        if (a->sign)
            putchar('-');
        if (a->expn == BF_EXP_ZERO) {
            putchar('0');
        } else if (a->expn == BF_EXP_INF) {
            printf("Inf");
        } else {
            printf("0.");
            for(i = a->len - 1; i >= 0; i--)
                printf("%0*" PRIu_LIMB, LIMB_DIGITS, a->tab[i]);
            printf("e%" PRId_LIMB, a->expn);
        }
    }
    printf("\n");
}

/* return != 0 if one digit between 0 and bit_pos inclusive is not zero. */
static inline limb_t scan_digit_nz(const bfdec_t *r, slimb_t bit_pos)
{
    slimb_t pos;
    limb_t v, q;
    int shift;

    if (bit_pos < 0)
        return 0;
    pos = (limb_t)bit_pos / LIMB_DIGITS;
    shift = (limb_t)bit_pos % LIMB_DIGITS;
    fast_shr_rem_dec(q, v, r->tab[pos], shift + 1);
    (void)q;
    if (v != 0)
        return 1;
    pos--;
    while (pos >= 0) {
        if (r->tab[pos] != 0)
            return 1;
        pos--;
    }
    return 0;
}

static limb_t get_digit(const limb_t *tab, limb_t len, slimb_t pos)
{
    slimb_t i;
    int shift;
    i = floor_div(pos, LIMB_DIGITS);
    if (i < 0 || i >= len)
        return 0;
    shift = pos - i * LIMB_DIGITS;
    return fast_shr_dec(tab[i], shift) % 10;
}

#if 0
static limb_t get_digits(const limb_t *tab, limb_t len, slimb_t pos)
{
    limb_t a0, a1;
    int shift;
    slimb_t i;
    
    i = floor_div(pos, LIMB_DIGITS);
    shift = pos - i * LIMB_DIGITS;
    if (i >= 0 && i < len)
        a0 = tab[i];
    else
        a0 = 0;
    if (shift == 0) {
        return a0;
    } else {
        i++;
        if (i >= 0 && i < len)
            a1 = tab[i];
        else
            a1 = 0;
        return fast_shr_dec(a0, shift) +
            fast_urem(a1, &mp_pow_div[LIMB_DIGITS - shift]) *
            mp_pow_dec[shift];
    }
}
#endif

/* return the addend for rounding. Note that prec can be <= 0 for bf_rint() */
static int bfdec_get_rnd_add(int *pret, const bfdec_t *r, limb_t l,
                             slimb_t prec, int rnd_mode)
{
    int add_one, inexact;
    limb_t digit1, digit0;
    
    //    bfdec_print_str("get_rnd_add", r);
    if (rnd_mode == BF_RNDF) {
        digit0 = 1; /* faithful rounding does not honor the INEXACT flag */
    } else {
        /* starting limb for bit 'prec + 1' */
        digit0 = scan_digit_nz(r, l * LIMB_DIGITS - 1 - bf_max(0, prec + 1));
    }

    /* get the digit at 'prec' */
    digit1 = get_digit(r->tab, l, l * LIMB_DIGITS - 1 - prec);
    inexact = (digit1 | digit0) != 0;
    
    add_one = 0;
    switch(rnd_mode) {
    case BF_RNDZ:
        break;
    case BF_RNDN:
        if (digit1 == 5) {
            if (digit0) {
                add_one = 1;
            } else {
                /* round to even */
                add_one =
                    get_digit(r->tab, l, l * LIMB_DIGITS - 1 - (prec - 1)) & 1;
            }
        } else if (digit1 > 5) {
            add_one = 1;
        }
        break;
    case BF_RNDD:
    case BF_RNDU:
        if (r->sign == (rnd_mode == BF_RNDD))
            add_one = inexact;
        break;
    case BF_RNDNA:
    case BF_RNDF:
        add_one = (digit1 >= 5);
        break;
    case BF_RNDA:
        add_one = inexact;
        break;
    default:
        abort();
    }
    
    if (inexact)
        *pret |= BF_ST_INEXACT;
    return add_one;
}

/* round to prec1 bits assuming 'r' is non zero and finite. 'r' is
   assumed to have length 'l' (1 <= l <= r->len). prec1 can be
   BF_PREC_INF. BF_FLAG_SUBNORMAL is not supported. Cannot fail with
   BF_ST_MEM_ERROR.
 */
static int __bfdec_round(bfdec_t *r, limb_t prec1, bf_flags_t flags, limb_t l)
{
    int shift, add_one, rnd_mode, ret;
    slimb_t i, bit_pos, pos, e_min, e_max, e_range, prec;

    /* XXX: align to IEEE 754 2008 for decimal numbers ? */
    e_range = (limb_t)1 << (bf_get_exp_bits(flags) - 1);
    e_min = -e_range + 3;
    e_max = e_range;
    
    if (flags & BF_FLAG_RADPNT_PREC) {
        /* 'prec' is the precision after the decimal point */
        if (prec1 != BF_PREC_INF)
            prec = r->expn + prec1;
        else
            prec = prec1;
    } else if (unlikely(r->expn < e_min) && (flags & BF_FLAG_SUBNORMAL)) {
        /* restrict the precision in case of potentially subnormal
           result */
        assert(prec1 != BF_PREC_INF);
        prec = prec1 - (e_min - r->expn);
    } else {
        prec = prec1;
    }
    
    /* round to prec bits */
    rnd_mode = flags & BF_RND_MASK;
    ret = 0;
    add_one = bfdec_get_rnd_add(&ret, r, l, prec, rnd_mode);
    
    if (prec <= 0) {
        if (add_one) {
            bfdec_resize(r, 1); /* cannot fail because r is non zero */
            r->tab[0] = BF_DEC_BASE / 10;
            r->expn += 1 - prec;
            ret |= BF_ST_UNDERFLOW | BF_ST_INEXACT;
            return ret;
        } else {
            goto underflow;
        }
    } else if (add_one) {
        limb_t carry;
        
        /* add one starting at digit 'prec - 1' */
        bit_pos = l * LIMB_DIGITS - 1 - (prec - 1);
        pos = bit_pos / LIMB_DIGITS;
        carry = mp_pow_dec[bit_pos % LIMB_DIGITS];
        carry = mp_add_ui_dec(r->tab + pos, carry, l - pos);
        if (carry) {
            /* shift right by one digit */
            mp_shr_dec(r->tab + pos, r->tab + pos, l - pos, 1, 1);
            r->expn++;
        }
    }
    
    /* check underflow */
    if (unlikely(r->expn < e_min)) {
        if (flags & BF_FLAG_SUBNORMAL) {
            /* if inexact, also set the underflow flag */
            if (ret & BF_ST_INEXACT)
                ret |= BF_ST_UNDERFLOW;
        } else {
        underflow:
            bfdec_set_zero(r, r->sign);
            ret |= BF_ST_UNDERFLOW | BF_ST_INEXACT;
            return ret;
        }
    }
    
    /* check overflow */
    if (unlikely(r->expn > e_max)) {
        bfdec_set_inf(r, r->sign);
        ret |= BF_ST_OVERFLOW | BF_ST_INEXACT;
        return ret;
    }
    
    /* keep the bits starting at 'prec - 1' */
    bit_pos = l * LIMB_DIGITS - 1 - (prec - 1);
    i = floor_div(bit_pos, LIMB_DIGITS);
    if (i >= 0) {
        shift = smod(bit_pos, LIMB_DIGITS);
        if (shift != 0) {
            r->tab[i] = fast_shr_dec(r->tab[i], shift) *
                mp_pow_dec[shift];
        }
    } else {
        i = 0;
    }
    /* remove trailing zeros */
    while (r->tab[i] == 0)
        i++;
    if (i > 0) {
        l -= i;
        memmove(r->tab, r->tab + i, l * sizeof(limb_t));
    }
    bfdec_resize(r, l); /* cannot fail */
    return ret;
}

/* Cannot fail with BF_ST_MEM_ERROR. */
int bfdec_round(bfdec_t *r, limb_t prec, bf_flags_t flags)
{
    if (r->len == 0)
        return 0;
    return __bfdec_round(r, prec, flags, r->len);
}

/* 'r' must be a finite number. Cannot fail with BF_ST_MEM_ERROR.  */
int bfdec_normalize_and_round(bfdec_t *r, limb_t prec1, bf_flags_t flags)
{
    limb_t l, v;
    int shift, ret;
    
    //    bfdec_print_str("bf_renorm", r);
    l = r->len;
    while (l > 0 && r->tab[l - 1] == 0)
        l--;
    if (l == 0) {
        /* zero */
        r->expn = BF_EXP_ZERO;
        bfdec_resize(r, 0); /* cannot fail */
        ret = 0;
    } else {
        r->expn -= (r->len - l) * LIMB_DIGITS;
        /* shift to have the MSB set to '1' */
        v = r->tab[l - 1];
        shift = clz_dec(v);
        if (shift != 0) {
            mp_shl_dec(r->tab, r->tab, l, shift, 0);
            r->expn -= shift;
        }
        ret = __bfdec_round(r, prec1, flags, l);
    }
    //    bf_print_str("r_final", r);
    return ret;
}

int bfdec_set_ui(bfdec_t *r, uint64_t v)
{
#if LIMB_BITS == 32
    if (v >= BF_DEC_BASE * BF_DEC_BASE) {
        if (bfdec_resize(r, 3))
            goto fail;
        r->tab[0] = v % BF_DEC_BASE;
        v /= BF_DEC_BASE;
        r->tab[1] = v % BF_DEC_BASE;
        r->tab[2] = v / BF_DEC_BASE;
        r->expn = 3 * LIMB_DIGITS;
    } else
#endif
    if (v >= BF_DEC_BASE) {
        if (bfdec_resize(r, 2))
            goto fail;
        r->tab[0] = v % BF_DEC_BASE;
        r->tab[1] = v / BF_DEC_BASE;
        r->expn = 2 * LIMB_DIGITS;
    } else {
        if (bfdec_resize(r, 1))
            goto fail;
        r->tab[0] = v;
        r->expn = LIMB_DIGITS;
    }
    r->sign = 0;
    return bfdec_normalize_and_round(r, BF_PREC_INF, 0);
 fail:
    bfdec_set_nan(r);
    return BF_ST_MEM_ERROR;
}

int bfdec_set_si(bfdec_t *r, int64_t v)
{
    int ret;
    if (v < 0) {
        ret = bfdec_set_ui(r, -v);
        r->sign = 1;
    } else {
        ret = bfdec_set_ui(r, v);
    }
    return ret;
}

static int bfdec_add_internal(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec, bf_flags_t flags, int b_neg)
{
    bf_context_t *s = r->ctx;
    int is_sub, cmp_res, a_sign, b_sign, ret;

    a_sign = a->sign;
    b_sign = b->sign ^ b_neg;
    is_sub = a_sign ^ b_sign;
    cmp_res = bfdec_cmpu(a, b);
    if (cmp_res < 0) {
        const bfdec_t *tmp;
        tmp = a;
        a = b;
        b = tmp;
        a_sign = b_sign; /* b_sign is never used later */
    }
    /* abs(a) >= abs(b) */
    if (cmp_res == 0 && is_sub && a->expn < BF_EXP_INF) {
        /* zero result */
        bfdec_set_zero(r, (flags & BF_RND_MASK) == BF_RNDD);
        ret = 0;
    } else if (a->len == 0 || b->len == 0) {
        ret = 0;
        if (a->expn >= BF_EXP_INF) {
            if (a->expn == BF_EXP_NAN) {
                /* at least one operand is NaN */
                bfdec_set_nan(r);
                ret = 0;
            } else if (b->expn == BF_EXP_INF && is_sub) {
                /* infinities with different signs */
                bfdec_set_nan(r);
                ret = BF_ST_INVALID_OP;
            } else {
                bfdec_set_inf(r, a_sign);
            }
        } else {
            /* at least one zero and not subtract */
            if (bfdec_set(r, a))
                return BF_ST_MEM_ERROR;
            r->sign = a_sign;
            goto renorm;
        }
    } else {
        slimb_t d, a_offset, b_offset, i, r_len;
        limb_t carry;
        limb_t *b1_tab;
        int b_shift;
        mp_size_t b1_len;
        
        d = a->expn - b->expn;

        /* XXX: not efficient in time and memory if the precision is
           not infinite */
        r_len = bf_max(a->len, b->len + (d + LIMB_DIGITS - 1) / LIMB_DIGITS);
        if (bfdec_resize(r, r_len))
            goto fail;
        r->sign = a_sign;
        r->expn = a->expn;

        a_offset = r_len - a->len;
        for(i = 0; i < a_offset; i++)
            r->tab[i] = 0;
        for(i = 0; i < a->len; i++)
            r->tab[a_offset + i] = a->tab[i];
        
        b_shift = d % LIMB_DIGITS;
        if (b_shift == 0) {
            b1_len = b->len;
            b1_tab = (limb_t *)b->tab;
        } else {
            b1_len = b->len + 1;
            b1_tab = bf_malloc(s, sizeof(limb_t) * b1_len);
            if (!b1_tab)
                goto fail;
            b1_tab[0] = mp_shr_dec(b1_tab + 1, b->tab, b->len, b_shift, 0) *
                mp_pow_dec[LIMB_DIGITS - b_shift];
        }
        b_offset = r_len - (b->len + (d + LIMB_DIGITS - 1) / LIMB_DIGITS);
        
        if (is_sub) {
            carry = mp_sub_dec(r->tab + b_offset, r->tab + b_offset,
                               b1_tab, b1_len, 0);
            if (carry != 0) {
                carry = mp_sub_ui_dec(r->tab + b_offset + b1_len, carry,
                                      r_len - (b_offset + b1_len));
                assert(carry == 0);
            }
        } else {
            carry = mp_add_dec(r->tab + b_offset, r->tab + b_offset,
                               b1_tab, b1_len, 0);
            if (carry != 0) {
                carry = mp_add_ui_dec(r->tab + b_offset + b1_len, carry,
                                      r_len - (b_offset + b1_len));
            }
            if (carry != 0) {
                if (bfdec_resize(r, r_len + 1)) {
                    if (b_shift != 0)
                        bf_free(s, b1_tab);
                    goto fail;
                }
                r->tab[r_len] = 1;
                r->expn += LIMB_DIGITS;
            }
        }
        if (b_shift != 0)
            bf_free(s, b1_tab);
    renorm:
        ret = bfdec_normalize_and_round(r, prec, flags);
    }
    return ret;
 fail:
    bfdec_set_nan(r);
    return BF_ST_MEM_ERROR;
}

static int __bfdec_add(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
                     bf_flags_t flags)
{
    return bfdec_add_internal(r, a, b, prec, flags, 0);
}

static int __bfdec_sub(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
                     bf_flags_t flags)
{
    return bfdec_add_internal(r, a, b, prec, flags, 1);
}

int bfdec_add(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
              bf_flags_t flags)
{
    return bf_op2((bf_t *)r, (bf_t *)a, (bf_t *)b, prec, flags,
                  (bf_op2_func_t *)__bfdec_add);
}

int bfdec_sub(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
              bf_flags_t flags)
{
    return bf_op2((bf_t *)r, (bf_t *)a, (bf_t *)b, prec, flags,
                  (bf_op2_func_t *)__bfdec_sub);
}

int bfdec_mul(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
              bf_flags_t flags)
{
    int ret, r_sign;

    if (a->len < b->len) {
        const bfdec_t *tmp = a;
        a = b;
        b = tmp;
    }
    r_sign = a->sign ^ b->sign;
    /* here b->len <= a->len */
    if (b->len == 0) {
        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {
            bfdec_set_nan(r);
            ret = 0;
        } else if (a->expn == BF_EXP_INF || b->expn == BF_EXP_INF) {
            if ((a->expn == BF_EXP_INF && b->expn == BF_EXP_ZERO) ||
                (a->expn == BF_EXP_ZERO && b->expn == BF_EXP_INF)) {
                bfdec_set_nan(r);
                ret = BF_ST_INVALID_OP;
            } else {
                bfdec_set_inf(r, r_sign);
                ret = 0;
            }
        } else {
            bfdec_set_zero(r, r_sign);
            ret = 0;
        }
    } else {
        bfdec_t tmp, *r1 = NULL;
        limb_t a_len, b_len;
        limb_t *a_tab, *b_tab;
            
        a_len = a->len;
        b_len = b->len;
        a_tab = a->tab;
        b_tab = b->tab;
        
        if (r == a || r == b) {
            bfdec_init(r->ctx, &tmp);
            r1 = r;
            r = &tmp;
        }
        if (bfdec_resize(r, a_len + b_len)) {
            bfdec_set_nan(r);
            ret = BF_ST_MEM_ERROR;
            goto done;
        }
        mp_mul_basecase_dec(r->tab, a_tab, a_len, b_tab, b_len);
        r->sign = r_sign;
        r->expn = a->expn + b->expn;
        ret = bfdec_normalize_and_round(r, prec, flags);
    done:
        if (r == &tmp)
            bfdec_move(r1, &tmp);
    }
    return ret;
}

int bfdec_mul_si(bfdec_t *r, const bfdec_t *a, int64_t b1, limb_t prec,
                 bf_flags_t flags)
{
    bfdec_t b;
    int ret;
    bfdec_init(r->ctx, &b);
    ret = bfdec_set_si(&b, b1);
    ret |= bfdec_mul(r, a, &b, prec, flags);
    bfdec_delete(&b);
    return ret;
}

int bfdec_add_si(bfdec_t *r, const bfdec_t *a, int64_t b1, limb_t prec,
                 bf_flags_t flags)
{
    bfdec_t b;
    int ret;
    
    bfdec_init(r->ctx, &b);
    ret = bfdec_set_si(&b, b1);
    ret |= bfdec_add(r, a, &b, prec, flags);
    bfdec_delete(&b);
    return ret;
}

static int __bfdec_div(bfdec_t *r, const bfdec_t *a, const bfdec_t *b,
                       limb_t prec, bf_flags_t flags)
{
    int ret, r_sign;
    limb_t n, nb, precl;
    
    r_sign = a->sign ^ b->sign;
    if (a->expn >= BF_EXP_INF || b->expn >= BF_EXP_INF) {
        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {
            bfdec_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF && b->expn == BF_EXP_INF) {
            bfdec_set_nan(r);
            return BF_ST_INVALID_OP;
        } else if (a->expn == BF_EXP_INF) {
            bfdec_set_inf(r, r_sign);
            return 0;
        } else {
            bfdec_set_zero(r, r_sign);
            return 0;
        }
    } else if (a->expn == BF_EXP_ZERO) {
        if (b->expn == BF_EXP_ZERO) {
            bfdec_set_nan(r);
            return BF_ST_INVALID_OP;
        } else {
            bfdec_set_zero(r, r_sign);
            return 0;
        }
    } else if (b->expn == BF_EXP_ZERO) {
        bfdec_set_inf(r, r_sign);
        return BF_ST_DIVIDE_ZERO;
    }

    nb = b->len;
    if (prec == BF_PREC_INF) {
        /* infinite precision: return BF_ST_INVALID_OP if not an exact
           result */
        /* XXX: check */
        precl = nb + 1;
    } else if (flags & BF_FLAG_RADPNT_PREC) {
        /* number of digits after the decimal point */
        /* XXX: check (2 extra digits for rounding + 2 digits) */
        precl = (bf_max(a->expn - b->expn, 0) + 2 +
                 prec + 2 + LIMB_DIGITS - 1) / LIMB_DIGITS;
    } else {
        /* number of limbs of the quotient (2 extra digits for rounding) */
        precl = (prec + 2 + LIMB_DIGITS - 1) / LIMB_DIGITS;
    }
    n = bf_max(a->len, precl);
    
    {
        limb_t *taba, na, i;
        slimb_t d;
        
        na = n + nb;
        taba = bf_malloc(r->ctx, (na + 1) * sizeof(limb_t));
        if (!taba)
            goto fail;
        d = na - a->len;
        memset(taba, 0, d * sizeof(limb_t));
        memcpy(taba + d, a->tab, a->len * sizeof(limb_t));
        if (bfdec_resize(r, n + 1))
            goto fail1;
        if (mp_div_dec(r->ctx, r->tab, taba, na, b->tab, nb)) {
        fail1:
            bf_free(r->ctx, taba);
            goto fail;
        }
        /* see if non zero remainder */
        for(i = 0; i < nb; i++) {
            if (taba[i] != 0)
                break;
        }
        bf_free(r->ctx, taba);
        if (i != nb) {
            if (prec == BF_PREC_INF) {
                bfdec_set_nan(r);
                return BF_ST_INVALID_OP;
            } else {
                r->tab[0] |= 1;
            }
        }
        r->expn = a->expn - b->expn + LIMB_DIGITS;
        r->sign = r_sign;
        ret = bfdec_normalize_and_round(r, prec, flags);
    }
    return ret;
 fail:
    bfdec_set_nan(r);
    return BF_ST_MEM_ERROR;
}

int bfdec_div(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
              bf_flags_t flags)
{
    return bf_op2((bf_t *)r, (bf_t *)a, (bf_t *)b, prec, flags,
                  (bf_op2_func_t *)__bfdec_div);
}

/* a and b must be finite numbers with a >= 0 and b > 0. 'q' is the
   integer defined as floor(a/b) and r = a - q * b. */
static void bfdec_tdivremu(bf_context_t *s, bfdec_t *q, bfdec_t *r,
                           const bfdec_t *a, const bfdec_t *b)
{
    if (bfdec_cmpu(a, b) < 0) {
        bfdec_set_ui(q, 0);
        bfdec_set(r, a);
    } else {
        bfdec_div(q, a, b, 0, BF_RNDZ | BF_FLAG_RADPNT_PREC);
        bfdec_mul(r, q, b, BF_PREC_INF, BF_RNDZ);
        bfdec_sub(r, a, r, BF_PREC_INF, BF_RNDZ);
    }
}

/* division and remainder. 
   
   rnd_mode is the rounding mode for the quotient. The additional
   rounding mode BF_RND_EUCLIDIAN is supported.

   'q' is an integer. 'r' is rounded with prec and flags (prec can be
   BF_PREC_INF).
*/
int bfdec_divrem(bfdec_t *q, bfdec_t *r, const bfdec_t *a, const bfdec_t *b,
                 limb_t prec, bf_flags_t flags, int rnd_mode)
{
    bf_context_t *s = q->ctx;
    bfdec_t a1_s, *a1 = &a1_s;
    bfdec_t b1_s, *b1 = &b1_s;
    bfdec_t r1_s, *r1 = &r1_s;
    int q_sign, res;
    BOOL is_ceil, is_rndn;
    
    assert(q != a && q != b);
    assert(r != a && r != b);
    assert(q != r);
    
    if (a->len == 0 || b->len == 0) {
        bfdec_set_zero(q, 0);
        if (a->expn == BF_EXP_NAN || b->expn == BF_EXP_NAN) {
            bfdec_set_nan(r);
            return 0;
        } else if (a->expn == BF_EXP_INF || b->expn == BF_EXP_ZERO) {
            bfdec_set_nan(r);
            return BF_ST_INVALID_OP;
        } else {
            bfdec_set(r, a);
            return bfdec_round(r, prec, flags);
        }
    }

    q_sign = a->sign ^ b->sign;
    is_rndn = (rnd_mode == BF_RNDN || rnd_mode == BF_RNDNA);
    switch(rnd_mode) {
    default:
    case BF_RNDZ:
    case BF_RNDN:
    case BF_RNDNA:
        is_ceil = FALSE;
        break;
    case BF_RNDD:
        is_ceil = q_sign;
        break;
    case BF_RNDU:
        is_ceil = q_sign ^ 1;
        break;
    case BF_RNDA:
        is_ceil = TRUE;
        break;
    case BF_DIVREM_EUCLIDIAN:
        is_ceil = a->sign;
        break;
    }

    a1->expn = a->expn;
    a1->tab = a->tab;
    a1->len = a->len;
    a1->sign = 0;
    
    b1->expn = b->expn;
    b1->tab = b->tab;
    b1->len = b->len;
    b1->sign = 0;

    //    bfdec_print_str("a1", a1);
    //    bfdec_print_str("b1", b1);
    /* XXX: could improve to avoid having a large 'q' */
    bfdec_tdivremu(s, q, r, a1, b1);
    if (bfdec_is_nan(q) || bfdec_is_nan(r))
        goto fail;
    //    bfdec_print_str("q", q);
    //    bfdec_print_str("r", r);
    
    if (r->len != 0) {
        if (is_rndn) {
            bfdec_init(s, r1);
            if (bfdec_set(r1, r))
                goto fail;
            if (bfdec_mul_si(r1, r1, 2, BF_PREC_INF, BF_RNDZ)) {
                bfdec_delete(r1);
                goto fail;
            }
            res = bfdec_cmpu(r1, b);
            bfdec_delete(r1);
            if (res > 0 ||
                (res == 0 &&
                 (rnd_mode == BF_RNDNA ||
                  (get_digit(q->tab, q->len, q->len * LIMB_DIGITS - q->expn) & 1) != 0))) {
                goto do_sub_r;
            }
        } else if (is_ceil) {
        do_sub_r:
            res = bfdec_add_si(q, q, 1, BF_PREC_INF, BF_RNDZ);
            res |= bfdec_sub(r, r, b1, BF_PREC_INF, BF_RNDZ);
            if (res & BF_ST_MEM_ERROR)
                goto fail;
        }
    }

    r->sign ^= a->sign;
    q->sign = q_sign;
    return bfdec_round(r, prec, flags);
 fail:
    bfdec_set_nan(q);
    bfdec_set_nan(r);
    return BF_ST_MEM_ERROR;
}

int bfdec_rem(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
              bf_flags_t flags, int rnd_mode)
{
    bfdec_t q_s, *q = &q_s;
    int ret;
    
    bfdec_init(r->ctx, q);
    ret = bfdec_divrem(q, r, a, b, prec, flags, rnd_mode);
    bfdec_delete(q);
    return ret;
}

/* convert to integer (infinite precision) */
int bfdec_rint(bfdec_t *r, int rnd_mode)
{
    return bfdec_round(r, 0, rnd_mode | BF_FLAG_RADPNT_PREC);
}

int bfdec_sqrt(bfdec_t *r, const bfdec_t *a, limb_t prec, bf_flags_t flags)
{
    bf_context_t *s = a->ctx;
    int ret, k;
    limb_t *a1, v;
    slimb_t n, n1, prec1;
    limb_t res;

    assert(r != a);

    if (a->len == 0) {
        if (a->expn == BF_EXP_NAN) {
            bfdec_set_nan(r);
        } else if (a->expn == BF_EXP_INF && a->sign) {
            goto invalid_op;
        } else {
            bfdec_set(r, a);
        }
        ret = 0;
    } else if (a->sign || prec == BF_PREC_INF) {
 invalid_op:
        bfdec_set_nan(r);
        ret = BF_ST_INVALID_OP;
    } else {
        if (flags & BF_FLAG_RADPNT_PREC) {
            prec1 = bf_max(floor_div(a->expn + 1, 2) + prec, 1);
        } else {
            prec1 = prec;
        }
        /* convert the mantissa to an integer with at least 2 *
           prec + 4 digits */
        n = (2 * (prec1 + 2) + 2 * LIMB_DIGITS - 1) / (2 * LIMB_DIGITS);
        if (bfdec_resize(r, n))
            goto fail;
        a1 = bf_malloc(s, sizeof(limb_t) * 2 * n);
        if (!a1)
            goto fail;
        n1 = bf_min(2 * n, a->len);
        memset(a1, 0, (2 * n - n1) * sizeof(limb_t));
        memcpy(a1 + 2 * n - n1, a->tab + a->len - n1, n1 * sizeof(limb_t));
        if (a->expn & 1) {
            res = mp_shr_dec(a1, a1, 2 * n, 1, 0);
        } else {
            res = 0;
        }
        /* normalize so that a1 >= B^(2*n)/4. Not need for n = 1
           because mp_sqrtrem2_dec already does it */
        k = 0;
        if (n > 1) {
            v = a1[2 * n - 1];
            while (v < BF_DEC_BASE / 4) {
                k++;
                v *= 4;
            }
            if (k != 0)
                mp_mul1_dec(a1, a1, 2 * n, 1 << (2 * k), 0);
        }
        if (mp_sqrtrem_dec(s, r->tab, a1, n)) {
            bf_free(s, a1);
            goto fail;
        }
        if (k != 0)
            mp_div1_dec(r->tab, r->tab, n, 1 << k, 0);
        if (!res) {
            res = mp_scan_nz(a1, n + 1);
        }
        bf_free(s, a1);
        if (!res) {
            res = mp_scan_nz(a->tab, a->len - n1);
        }
        if (res != 0)
            r->tab[0] |= 1;
        r->sign = 0;
        r->expn = (a->expn + 1) >> 1;
        ret = bfdec_round(r, prec, flags);
    }
    return ret;
 fail:
    bfdec_set_nan(r);
    return BF_ST_MEM_ERROR;
}

/* The rounding mode is always BF_RNDZ. Return BF_ST_OVERFLOW if there
   is an overflow and 0 otherwise. No memory error is possible. */
int bfdec_get_int32(int *pres, const bfdec_t *a)
{
    uint32_t v;
    int ret;
    if (a->expn >= BF_EXP_INF) {
        ret = 0;
        if (a->expn == BF_EXP_INF) {
            v = (uint32_t)INT32_MAX + a->sign;
             /* XXX: return overflow ? */
        } else {
            v = INT32_MAX;
        }
    } else if (a->expn <= 0) {
        v = 0;
        ret = 0;
    } else if (a->expn <= 9) {
        v = fast_shr_dec(a->tab[a->len - 1], LIMB_DIGITS - a->expn);
        if (a->sign)
            v = -v;
        ret = 0;
    } else if (a->expn == 10) {
        uint64_t v1;
        uint32_t v_max;
#if LIMB_BITS == 64
        v1 = fast_shr_dec(a->tab[a->len - 1], LIMB_DIGITS - a->expn);
#else
        v1 = (uint64_t)a->tab[a->len - 1] * 10 +
            get_digit(a->tab, a->len, (a->len - 1) * LIMB_DIGITS - 1);
#endif
        v_max = (uint32_t)INT32_MAX + a->sign;
        if (v1 > v_max) {
            v = v_max;
            ret = BF_ST_OVERFLOW;
        } else {
            v = v1;
            if (a->sign)
                v = -v;
            ret = 0;
        }
    } else {
        v = (uint32_t)INT32_MAX + a->sign;
        ret = BF_ST_OVERFLOW;
    }
    *pres = v;
    return ret;
}

/* power to an integer with infinite precision */
int bfdec_pow_ui(bfdec_t *r, const bfdec_t *a, limb_t b)
{
    int ret, n_bits, i;
    
    assert(r != a);
    if (b == 0)
        return bfdec_set_ui(r, 1);
    ret = bfdec_set(r, a);
    n_bits = LIMB_BITS - clz(b);
    for(i = n_bits - 2; i >= 0; i--) {
        ret |= bfdec_mul(r, r, r, BF_PREC_INF, BF_RNDZ);
        if ((b >> i) & 1)
            ret |= bfdec_mul(r, r, a, BF_PREC_INF, BF_RNDZ);
    }
    return ret;
}

char *bfdec_ftoa(size_t *plen, const bfdec_t *a, limb_t prec, bf_flags_t flags)
{
    return bf_ftoa_internal(plen, (const bf_t *)a, 10, prec, flags, TRUE);
}

int bfdec_atof(bfdec_t *r, const char *str, const char **pnext,
               limb_t prec, bf_flags_t flags)
{
    slimb_t dummy_exp;
    return bf_atof_internal((bf_t *)r, &dummy_exp, str, pnext, 10, prec,
                            flags, TRUE);
}

#endif /* USE_BF_DEC */

#ifdef USE_FFT_MUL
/***************************************************************/
/* Integer multiplication with FFT */

/* or LIMB_BITS at bit position 'pos' in tab */
static inline void put_bits(limb_t *tab, limb_t len, slimb_t pos, limb_t val)
{
    limb_t i;
    int p;

    i = pos >> LIMB_LOG2_BITS;
    p = pos & (LIMB_BITS - 1);
    if (i < len)
        tab[i] |= val << p;
    if (p != 0) {
        i++;
        if (i < len) {
            tab[i] |= val >> (LIMB_BITS - p);
        }
    }
}

#if defined(__AVX2__)

typedef double NTTLimb;

/* we must have: modulo >= 1 << NTT_MOD_LOG2_MIN */
#define NTT_MOD_LOG2_MIN 50
#define NTT_MOD_LOG2_MAX 51
#define NB_MODS 5
#define NTT_PROOT_2EXP 39
static const int ntt_int_bits[NB_MODS] = { 254, 203, 152, 101, 50, };

static const limb_t ntt_mods[NB_MODS] = { 0x00073a8000000001, 0x0007858000000001, 0x0007a38000000001, 0x0007a68000000001, 0x0007fd8000000001,
};

static const limb_t ntt_proot[2][NB_MODS] = {
    { 0x00056198d44332c8, 0x0002eb5d640aad39, 0x00047e31eaa35fd0, 0x0005271ac118a150, 0x00075e0ce8442bd5, },
    { 0x000461169761bcc5, 0x0002dac3cb2da688, 0x0004abc97751e3bf, 0x000656778fc8c485, 0x0000dc6469c269fa, },
};

static const limb_t ntt_mods_cr[NB_MODS * (NB_MODS - 1) / 2] = {
 0x00020e4da740da8e, 0x0004c3dc09c09c1d, 0x000063bd097b4271, 0x000799d8f18f18fd,
 0x0005384222222264, 0x000572b07c1f07fe, 0x00035cd08888889a,
 0x00066015555557e3, 0x000725960b60b623,
 0x0002fc1fa1d6ce12,
};

#else

typedef limb_t NTTLimb;

#if LIMB_BITS == 64

#define NTT_MOD_LOG2_MIN 61
#define NTT_MOD_LOG2_MAX 62
#define NB_MODS 5
#define NTT_PROOT_2EXP 51
static const int ntt_int_bits[NB_MODS] = { 307, 246, 185, 123, 61, };

static const limb_t ntt_mods[NB_MODS] = { 0x28d8000000000001, 0x2a88000000000001, 0x2ed8000000000001, 0x3508000000000001, 0x3aa8000000000001,
};

static const limb_t ntt_proot[2][NB_MODS] = {
    { 0x1b8ea61034a2bea7, 0x21a9762de58206fb, 0x02ca782f0756a8ea, 0x278384537a3e50a1, 0x106e13fee74ce0ab, },
    { 0x233513af133e13b8, 0x1d13140d1c6f75f1, 0x12cde57f97e3eeda, 0x0d6149e23cbe654f, 0x36cd204f522a1379, },
};

static const limb_t ntt_mods_cr[NB_MODS * (NB_MODS - 1) / 2] = {
 0x08a9ed097b425eea, 0x18a44aaaaaaaaab3, 0x2493f57f57f57f5d, 0x126b8d0649a7f8d4,
 0x09d80ed7303b5ccc, 0x25b8bcf3cf3cf3d5, 0x2ce6ce63398ce638,
 0x0e31fad40a57eb59, 0x02a3529fd4a7f52f,
 0x3a5493e93e93e94a,
};

#elif LIMB_BITS == 32

/* we must have: modulo >= 1 << NTT_MOD_LOG2_MIN */
#define NTT_MOD_LOG2_MIN 29
#define NTT_MOD_LOG2_MAX 30
#define NB_MODS 5
#define NTT_PROOT_2EXP 20
static const int ntt_int_bits[NB_MODS] = { 148, 119, 89, 59, 29, };

static const limb_t ntt_mods[NB_MODS] = { 0x0000000032b00001, 0x0000000033700001, 0x0000000036d00001, 0x0000000037300001, 0x000000003e500001,
};

static const limb_t ntt_proot[2][NB_MODS] = {
    { 0x0000000032525f31, 0x0000000005eb3b37, 0x00000000246eda9f, 0x0000000035f25901, 0x00000000022f5768, },
    { 0x00000000051eba1a, 0x00000000107be10e, 0x000000001cd574e0, 0x00000000053806e6, 0x000000002cd6bf98, },
};

static const limb_t ntt_mods_cr[NB_MODS * (NB_MODS - 1) / 2] = {
 0x000000000449559a, 0x000000001eba6ca9, 0x000000002ec18e46, 0x000000000860160b,
 0x000000000d321307, 0x000000000bf51120, 0x000000000f662938,
 0x000000000932ab3e, 0x000000002f40eef8,
 0x000000002e760905,
};

#endif /* LIMB_BITS */

#endif /* !AVX2 */

#if defined(__AVX2__)
#define NTT_TRIG_K_MAX 18
#else
#define NTT_TRIG_K_MAX 19
#endif

typedef struct BFNTTState {
    bf_context_t *ctx;
    
    /* used for mul_mod_fast() */
    limb_t ntt_mods_div[NB_MODS];

    limb_t ntt_proot_pow[NB_MODS][2][NTT_PROOT_2EXP + 1];
    limb_t ntt_proot_pow_inv[NB_MODS][2][NTT_PROOT_2EXP + 1];
    NTTLimb *ntt_trig[NB_MODS][2][NTT_TRIG_K_MAX + 1];
    /* 1/2^n mod m */
    limb_t ntt_len_inv[NB_MODS][NTT_PROOT_2EXP + 1][2];
#if defined(__AVX2__)
    __m256d ntt_mods_cr_vec[NB_MODS * (NB_MODS - 1) / 2];
    __m256d ntt_mods_vec[NB_MODS];
    __m256d ntt_mods_inv_vec[NB_MODS];
#else
    limb_t ntt_mods_cr_inv[NB_MODS * (NB_MODS - 1) / 2];
#endif
} BFNTTState;

static NTTLimb *get_trig(BFNTTState *s, int k, int inverse, int m_idx);

/* add modulo with up to (LIMB_BITS-1) bit modulo */
static inline limb_t add_mod(limb_t a, limb_t b, limb_t m)
{
    limb_t r;
    r = a + b;
    if (r >= m)
        r -= m;
    return r;
}

/* sub modulo with up to LIMB_BITS bit modulo */
static inline limb_t sub_mod(limb_t a, limb_t b, limb_t m)
{
    limb_t r;
    r = a - b;
    if (r > a)
        r += m;
    return r;
}

/* return (r0+r1*B) mod m 
   precondition: 0 <= r0+r1*B < 2^(64+NTT_MOD_LOG2_MIN) 
*/
static inline limb_t mod_fast(dlimb_t r, 
                                limb_t m, limb_t m_inv)
{
    limb_t a1, q, t0, r1, r0;
    
    a1 = r >> NTT_MOD_LOG2_MIN;
    
    q = ((dlimb_t)a1 * m_inv) >> LIMB_BITS;
    r = r - (dlimb_t)q * m - m * 2;
    r1 = r >> LIMB_BITS;
    t0 = (slimb_t)r1 >> 1;
    r += m & t0;
    r0 = r;
    r1 = r >> LIMB_BITS;
    r0 += m & r1;
    return r0;
}

/* faster version using precomputed modulo inverse. 
   precondition: 0 <= a * b < 2^(64+NTT_MOD_LOG2_MIN) */
static inline limb_t mul_mod_fast(limb_t a, limb_t b, 
                                    limb_t m, limb_t m_inv)
{
    dlimb_t r;
    r = (dlimb_t)a * (dlimb_t)b;
    return mod_fast(r, m, m_inv);
}

static inline limb_t init_mul_mod_fast(limb_t m)
{
    dlimb_t t;
    assert(m < (limb_t)1 << NTT_MOD_LOG2_MAX);
    assert(m >= (limb_t)1 << NTT_MOD_LOG2_MIN);
    t = (dlimb_t)1 << (LIMB_BITS + NTT_MOD_LOG2_MIN);
    return t / m;
}

/* Faster version used when the multiplier is constant. 0 <= a < 2^64,
   0 <= b < m. */
static inline limb_t mul_mod_fast2(limb_t a, limb_t b, 
                                     limb_t m, limb_t b_inv)
{
    limb_t r, q;

    q = ((dlimb_t)a * (dlimb_t)b_inv) >> LIMB_BITS;
    r = a * b - q * m;
    if (r >= m)
        r -= m;
    return r;
}

/* Faster version used when the multiplier is constant. 0 <= a < 2^64,
   0 <= b < m. Let r = a * b mod m. The return value is 'r' or 'r +
   m'. */
static inline limb_t mul_mod_fast3(limb_t a, limb_t b, 
                                     limb_t m, limb_t b_inv)
{
    limb_t r, q;

    q = ((dlimb_t)a * (dlimb_t)b_inv) >> LIMB_BITS;
    r = a * b - q * m;
    return r;
}

static inline limb_t init_mul_mod_fast2(limb_t b, limb_t m)
{
    return ((dlimb_t)b << LIMB_BITS) / m;
}

#ifdef __AVX2__

static inline limb_t ntt_limb_to_int(NTTLimb a, limb_t m)
{
    slimb_t v;
    v = a;
    if (v < 0)
        v += m;
    if (v >= m)
        v -= m;
    return v;
}

static inline NTTLimb int_to_ntt_limb(limb_t a, limb_t m)
{
    return (slimb_t)a;
}

static inline NTTLimb int_to_ntt_limb2(limb_t a, limb_t m)
{
    if (a >= (m / 2))
        a -= m;
    return (slimb_t)a;
}

/* return r + m if r < 0 otherwise r. */
static inline __m256d ntt_mod1(__m256d r, __m256d m)
{
    return _mm256_blendv_pd(r, r + m, r);
}

/* input: abs(r) < 2 * m. Output: abs(r) < m */
static inline __m256d ntt_mod(__m256d r, __m256d mf, __m256d m2f)
{
    return _mm256_blendv_pd(r, r + m2f, r) - mf;
}

/* input: abs(a*b) < 2 * m^2, output: abs(r) < m */
static inline __m256d ntt_mul_mod(__m256d a, __m256d b, __m256d mf,
                                  __m256d m_inv)
{
    __m256d r, q, ab1, ab0, qm0, qm1;
    ab1 = a * b;
    q = _mm256_round_pd(ab1 * m_inv, 0); /* round to nearest */
    qm1 = q * mf;
    qm0 = _mm256_fmsub_pd(q, mf, qm1); /* low part */
    ab0 = _mm256_fmsub_pd(a, b, ab1); /* low part */
    r = (ab1 - qm1) + (ab0 - qm0);
    return r;
}

static void *bf_aligned_malloc(bf_context_t *s, size_t size, size_t align)
{
    void *ptr;
    void **ptr1;
    ptr = bf_malloc(s, size + sizeof(void *) + align - 1);
    if (!ptr)
        return NULL;
    ptr1 = (void **)(((uintptr_t)ptr + sizeof(void *) + align - 1) &
                     ~(align - 1));
    ptr1[-1] = ptr;
    return ptr1;
}

static void bf_aligned_free(bf_context_t *s, void *ptr)
{
    if (!ptr)
        return;
    bf_free(s, ((void **)ptr)[-1]);
}

static void *ntt_malloc(BFNTTState *s, size_t size)
{
    return bf_aligned_malloc(s->ctx, size, 64);
}

static void ntt_free(BFNTTState *s, void *ptr)
{
    bf_aligned_free(s->ctx, ptr);
}

static no_inline int ntt_fft(BFNTTState *s,
                             NTTLimb *out_buf, NTTLimb *in_buf,
                             NTTLimb *tmp_buf, int fft_len_log2,
                             int inverse, int m_idx)
{
    limb_t nb_blocks, fft_per_block, p, k, n, stride_in, i, j;
    NTTLimb *tab_in, *tab_out, *tmp, *trig;
    __m256d m_inv, mf, m2f, c, a0, a1, b0, b1;
    limb_t m;
    int l;
    
    m = ntt_mods[m_idx];
    
    m_inv = _mm256_set1_pd(1.0 / (double)m);
    mf = _mm256_set1_pd(m);
    m2f = _mm256_set1_pd(m * 2);

    n = (limb_t)1 << fft_len_log2;
    assert(n >= 8);
    stride_in = n / 2;

    tab_in = in_buf;
    tab_out = tmp_buf;
    trig = get_trig(s, fft_len_log2, inverse, m_idx);
    if (!trig)
        return -1;
    p = 0;
    for(k = 0; k < stride_in; k += 4) {
        a0 = _mm256_load_pd(&tab_in[k]);
        a1 = _mm256_load_pd(&tab_in[k + stride_in]);
        c = _mm256_load_pd(trig);
        trig += 4;
        b0 = ntt_mod(a0 + a1, mf, m2f);
        b1 = ntt_mul_mod(a0 - a1, c, mf, m_inv);
        a0 = _mm256_permute2f128_pd(b0, b1, 0x20);
        a1 = _mm256_permute2f128_pd(b0, b1, 0x31);
        a0 = _mm256_permute4x64_pd(a0, 0xd8);
        a1 = _mm256_permute4x64_pd(a1, 0xd8);
        _mm256_store_pd(&tab_out[p], a0);
        _mm256_store_pd(&tab_out[p + 4], a1);
        p += 2 * 4;
    }
    tmp = tab_in;
    tab_in = tab_out;
    tab_out = tmp;

    trig = get_trig(s, fft_len_log2 - 1, inverse, m_idx);
    if (!trig)
        return -1;
    p = 0;
    for(k = 0; k < stride_in; k += 4) {
        a0 = _mm256_load_pd(&tab_in[k]);
        a1 = _mm256_load_pd(&tab_in[k + stride_in]);
        c = _mm256_setr_pd(trig[0], trig[0], trig[1], trig[1]);
        trig += 2;
        b0 = ntt_mod(a0 + a1, mf, m2f);
        b1 = ntt_mul_mod(a0 - a1, c, mf, m_inv);
        a0 = _mm256_permute2f128_pd(b0, b1, 0x20);
        a1 = _mm256_permute2f128_pd(b0, b1, 0x31);
        _mm256_store_pd(&tab_out[p], a0);
        _mm256_store_pd(&tab_out[p + 4], a1);
        p += 2 * 4;
    }
    tmp = tab_in;
    tab_in = tab_out;
    tab_out = tmp;
    
    nb_blocks = n / 4;
    fft_per_block = 4;

    l = fft_len_log2 - 2;
    while (nb_blocks != 2) {
        nb_blocks >>= 1;
        p = 0;
        k = 0;
        trig = get_trig(s, l, inverse, m_idx);
        if (!trig)
            return -1;
        for(i = 0; i < nb_blocks; i++) {
            c = _mm256_set1_pd(trig[0]);
            trig++;
            for(j = 0; j < fft_per_block; j += 4) {
                a0 = _mm256_load_pd(&tab_in[k + j]);
                a1 = _mm256_load_pd(&tab_in[k + j + stride_in]);
                b0 = ntt_mod(a0 + a1, mf, m2f);
                b1 = ntt_mul_mod(a0 - a1, c, mf, m_inv);
                _mm256_store_pd(&tab_out[p + j], b0);
                _mm256_store_pd(&tab_out[p + j + fft_per_block], b1);
            }
            k += fft_per_block;
            p += 2 * fft_per_block;
        }
        fft_per_block <<= 1;
        l--;
        tmp = tab_in;
        tab_in = tab_out;
        tab_out = tmp;
    }

    tab_out = out_buf;
    for(k = 0; k < stride_in; k += 4) {
        a0 = _mm256_load_pd(&tab_in[k]);
        a1 = _mm256_load_pd(&tab_in[k + stride_in]);
        b0 = ntt_mod(a0 + a1, mf, m2f);
        b1 = ntt_mod(a0 - a1, mf, m2f);
        _mm256_store_pd(&tab_out[k], b0);
        _mm256_store_pd(&tab_out[k + stride_in], b1);
    }
    return 0;
}

static void ntt_vec_mul(BFNTTState *s,
                        NTTLimb *tab1, NTTLimb *tab2, limb_t fft_len_log2,
                        int k_tot, int m_idx)
{
    limb_t i, c_inv, n, m;
    __m256d m_inv, mf, a, b, c;
    
    m = ntt_mods[m_idx];
    c_inv = s->ntt_len_inv[m_idx][k_tot][0];
    m_inv = _mm256_set1_pd(1.0 / (double)m);
    mf = _mm256_set1_pd(m);
    c = _mm256_set1_pd(int_to_ntt_limb(c_inv, m));
    n = (limb_t)1 << fft_len_log2;
    for(i = 0; i < n; i += 4) {
        a = _mm256_load_pd(&tab1[i]);
        b = _mm256_load_pd(&tab2[i]);
        a = ntt_mul_mod(a, b, mf, m_inv);
        a = ntt_mul_mod(a, c, mf, m_inv);
        _mm256_store_pd(&tab1[i], a);
    }
}

static no_inline void mul_trig(NTTLimb *buf,
                               limb_t n, limb_t c1, limb_t m, limb_t m_inv1)
{
    limb_t i, c2, c3, c4;
    __m256d c, c_mul, a0, mf, m_inv;
    assert(n >= 2);
    
    mf = _mm256_set1_pd(m);
    m_inv = _mm256_set1_pd(1.0 / (double)m);

    c2 = mul_mod_fast(c1, c1, m, m_inv1);
    c3 = mul_mod_fast(c2, c1, m, m_inv1);
    c4 = mul_mod_fast(c2, c2, m, m_inv1);
    c = _mm256_setr_pd(1, int_to_ntt_limb(c1, m),
                       int_to_ntt_limb(c2, m), int_to_ntt_limb(c3, m));
    c_mul = _mm256_set1_pd(int_to_ntt_limb(c4, m));
    for(i = 0; i < n; i += 4) {
        a0 = _mm256_load_pd(&buf[i]);
        a0 = ntt_mul_mod(a0, c, mf, m_inv);
        _mm256_store_pd(&buf[i], a0);
        c = ntt_mul_mod(c, c_mul, mf, m_inv);
    }
}

#else

static void *ntt_malloc(BFNTTState *s, size_t size)
{
    return bf_malloc(s->ctx, size);
}

static void ntt_free(BFNTTState *s, void *ptr)
{
    bf_free(s->ctx, ptr);
}

static inline limb_t ntt_limb_to_int(NTTLimb a, limb_t m)
{
    if (a >= m)
        a -= m;
    return a;
}

static inline NTTLimb int_to_ntt_limb(slimb_t a, limb_t m)
{
    return a;
}

static no_inline int ntt_fft(BFNTTState *s, NTTLimb *out_buf, NTTLimb *in_buf,
                             NTTLimb *tmp_buf, int fft_len_log2,
                             int inverse, int m_idx)
{
    limb_t nb_blocks, fft_per_block, p, k, n, stride_in, i, j, m, m2;
    NTTLimb *tab_in, *tab_out, *tmp, a0, a1, b0, b1, c, *trig, c_inv;
    int l;
    
    m = ntt_mods[m_idx];
    m2 = 2 * m;
    n = (limb_t)1 << fft_len_log2;
    nb_blocks = n;
    fft_per_block = 1;
    stride_in = n / 2;
    tab_in = in_buf;
    tab_out = tmp_buf;
    l = fft_len_log2;
    while (nb_blocks != 2) {
        nb_blocks >>= 1;
        p = 0;
        k = 0;
        trig = get_trig(s, l, inverse, m_idx);
        if (!trig)
            return -1;
        for(i = 0; i < nb_blocks; i++) {
            c = trig[0];
            c_inv = trig[1];
            trig += 2;
            for(j = 0; j < fft_per_block; j++) {
                a0 = tab_in[k + j];
                a1 = tab_in[k + j + stride_in];
                b0 = add_mod(a0, a1, m2);
                b1 = a0 - a1 + m2;
                b1 = mul_mod_fast3(b1, c, m, c_inv);
                tab_out[p + j] = b0;
                tab_out[p + j + fft_per_block] = b1;
            }
            k += fft_per_block;
            p += 2 * fft_per_block;
        }
        fft_per_block <<= 1;
        l--;
        tmp = tab_in;
        tab_in = tab_out;
        tab_out = tmp;
    }
    /* no twiddle in last step */
    tab_out = out_buf; 
    for(k = 0; k < stride_in; k++) {
        a0 = tab_in[k];
        a1 = tab_in[k + stride_in];
        b0 = add_mod(a0, a1, m2);
        b1 = sub_mod(a0, a1, m2);
        tab_out[k] = b0;
        tab_out[k + stride_in] = b1;
    }
    return 0;
}

static void ntt_vec_mul(BFNTTState *s,
                        NTTLimb *tab1, NTTLimb *tab2, int fft_len_log2,
                        int k_tot, int m_idx)
{
    limb_t i, norm, norm_inv, a, n, m, m_inv;
    
    m = ntt_mods[m_idx];
    m_inv = s->ntt_mods_div[m_idx];
    norm = s->ntt_len_inv[m_idx][k_tot][0];
    norm_inv = s->ntt_len_inv[m_idx][k_tot][1];
    n = (limb_t)1 << fft_len_log2;
    for(i = 0; i < n; i++) {
        a = tab1[i];
        /* need to reduce the range so that the product is <
           2^(LIMB_BITS+NTT_MOD_LOG2_MIN) */
        if (a >= m)
            a -= m;
        a = mul_mod_fast(a, tab2[i], m, m_inv);
        a = mul_mod_fast3(a, norm, m, norm_inv);
        tab1[i] = a;
    }
}

static no_inline void mul_trig(NTTLimb *buf,
                               limb_t n, limb_t c_mul, limb_t m, limb_t m_inv)
{
    limb_t i, c0, c_mul_inv;
    
    c0 = 1;
    c_mul_inv = init_mul_mod_fast2(c_mul, m);
    for(i = 0; i < n; i++) {
        buf[i] = mul_mod_fast(buf[i], c0, m, m_inv);
        c0 = mul_mod_fast2(c0, c_mul, m, c_mul_inv);
    }
}

#endif /* !AVX2 */

static no_inline NTTLimb *get_trig(BFNTTState *s,
                                   int k, int inverse, int m_idx)
{
    NTTLimb *tab;
    limb_t i, n2, c, c_mul, m, c_mul_inv;
    
    if (k > NTT_TRIG_K_MAX)
        return NULL;

    tab = s->ntt_trig[m_idx][inverse][k];
    if (tab)
        return tab;
    n2 = (limb_t)1 << (k - 1);
    m = ntt_mods[m_idx];
#ifdef __AVX2__
    tab = ntt_malloc(s, sizeof(NTTLimb) * n2);
#else
    tab = ntt_malloc(s, sizeof(NTTLimb) * n2 * 2);
#endif
    if (!tab)
        return NULL;
    c = 1;
    c_mul = s->ntt_proot_pow[m_idx][inverse][k];
    c_mul_inv = s->ntt_proot_pow_inv[m_idx][inverse][k];
    for(i = 0; i < n2; i++) {
#ifdef __AVX2__
        tab[i] = int_to_ntt_limb2(c, m);
#else
        tab[2 * i] = int_to_ntt_limb(c, m);
        tab[2 * i + 1] = init_mul_mod_fast2(c, m);
#endif
        c = mul_mod_fast2(c, c_mul, m, c_mul_inv);
    }
    s->ntt_trig[m_idx][inverse][k] = tab;
    return tab;
}

void fft_clear_cache(bf_context_t *s1)
{
    int m_idx, inverse, k;
    BFNTTState *s = s1->ntt_state;
    if (s) {
        for(m_idx = 0; m_idx < NB_MODS; m_idx++) {
            for(inverse = 0; inverse < 2; inverse++) {
                for(k = 0; k < NTT_TRIG_K_MAX + 1; k++) {
                    if (s->ntt_trig[m_idx][inverse][k]) {
                        ntt_free(s, s->ntt_trig[m_idx][inverse][k]);
                        s->ntt_trig[m_idx][inverse][k] = NULL;
                    }
                }
            }
        }
#if defined(__AVX2__)
        bf_aligned_free(s1, s);
#else
        bf_free(s1, s);
#endif
        s1->ntt_state = NULL;
    }
}

#define STRIP_LEN 16

/* dst = buf1, src = buf2 */
static int ntt_fft_partial(BFNTTState *s, NTTLimb *buf1,
                           int k1, int k2, limb_t n1, limb_t n2, int inverse,
                           limb_t m_idx)
{
    limb_t i, j, c_mul, c0, m, m_inv, strip_len, l;
    NTTLimb *buf2, *buf3;
    
    buf2 = NULL;
    buf3 = ntt_malloc(s, sizeof(NTTLimb) * n1);
    if (!buf3)
        goto fail;
    if (k2 == 0) {
        if (ntt_fft(s, buf1, buf1, buf3, k1, inverse, m_idx))
            goto fail;
    } else {
        strip_len = STRIP_LEN;
        buf2 = ntt_malloc(s, sizeof(NTTLimb) * n1 * strip_len);
        if (!buf2)
            goto fail;
        m = ntt_mods[m_idx];
        m_inv = s->ntt_mods_div[m_idx];
        c0 = s->ntt_proot_pow[m_idx][inverse][k1 + k2];
        c_mul = 1;
        assert((n2 % strip_len) == 0);
        for(j = 0; j < n2; j += strip_len) {
            for(i = 0; i < n1; i++) {
                for(l = 0; l < strip_len; l++) {
                    buf2[i + l * n1] = buf1[i * n2 + (j + l)];
                }
            }
            for(l = 0; l < strip_len; l++) {
                if (inverse)
                    mul_trig(buf2 + l * n1, n1, c_mul, m, m_inv);
                if (ntt_fft(s, buf2 + l * n1, buf2 + l * n1, buf3, k1, inverse, m_idx))
                    goto fail;
                if (!inverse)
                    mul_trig(buf2 + l * n1, n1, c_mul, m, m_inv);
                c_mul = mul_mod_fast(c_mul, c0, m, m_inv);
            }
            
            for(i = 0; i < n1; i++) {
                for(l = 0; l < strip_len; l++) {
                    buf1[i * n2 + (j + l)] = buf2[i + l *n1];
                }
            }
        }
        ntt_free(s, buf2);
    }
    ntt_free(s, buf3);
    return 0;
 fail:
    ntt_free(s, buf2);
    ntt_free(s, buf3);
    return -1;
}

/* dst = buf1, src = buf2, tmp = buf3 */
static int ntt_conv(BFNTTState *s, NTTLimb *buf1, NTTLimb *buf2,
                    int k, int k_tot, limb_t m_idx)
{
    limb_t n1, n2, i;
    int k1, k2;
    
    if (k <= NTT_TRIG_K_MAX) {
        k1 = k;
    } else {
        /* recursive split of the FFT */
        k1 = bf_min(k / 2, NTT_TRIG_K_MAX);
    }
    k2 = k - k1;
    n1 = (limb_t)1 << k1;
    n2 = (limb_t)1 << k2;
    
    if (ntt_fft_partial(s, buf1, k1, k2, n1, n2, 0, m_idx))
        return -1;
    if (ntt_fft_partial(s, buf2, k1, k2, n1, n2, 0, m_idx))
        return -1;
    if (k2 == 0) {
        ntt_vec_mul(s, buf1, buf2, k, k_tot, m_idx);
    } else {
        for(i = 0; i < n1; i++) {
            ntt_conv(s, buf1 + i * n2, buf2 + i * n2, k2, k_tot, m_idx);
        }
    }
    if (ntt_fft_partial(s, buf1, k1, k2, n1, n2, 1, m_idx))
        return -1;
    return 0;
}

static no_inline void limb_to_ntt(BFNTTState *s,
                                  NTTLimb *tabr, limb_t fft_len,
                                  const limb_t *taba, limb_t a_len, int dpl,
                                  int first_m_idx, int nb_mods)
{
    slimb_t i, n;
    dlimb_t a, b;
    int j, shift;
    limb_t base_mask1, a0, a1, a2, r, m, m_inv;
    
#if 0
    for(i = 0; i < a_len; i++) {
        printf("%" PRId64 ": " FMT_LIMB "\n",
               (int64_t)i, taba[i]);
    }
#endif   
    memset(tabr, 0, sizeof(NTTLimb) * fft_len * nb_mods);
    shift = dpl & (LIMB_BITS - 1);
    if (shift == 0)
        base_mask1 = -1;
    else
        base_mask1 = ((limb_t)1 << shift) - 1;
    n = bf_min(fft_len, (a_len * LIMB_BITS + dpl - 1) / dpl);
    for(i = 0; i < n; i++) {
        a0 = get_bits(taba, a_len, i * dpl);
        if (dpl <= LIMB_BITS) {
            a0 &= base_mask1;
            a = a0;
        } else {
            a1 = get_bits(taba, a_len, i * dpl + LIMB_BITS);
            if (dpl <= (LIMB_BITS + NTT_MOD_LOG2_MIN)) {
                a = a0 | ((dlimb_t)(a1 & base_mask1) << LIMB_BITS);
            } else {
                if (dpl > 2 * LIMB_BITS) {
                    a2 = get_bits(taba, a_len, i * dpl + LIMB_BITS * 2) &
                        base_mask1;
                } else {
                    a1 &= base_mask1;
                    a2 = 0;
                }
                //            printf("a=0x%016lx%016lx%016lx\n", a2, a1, a0);
                a = (a0 >> (LIMB_BITS - NTT_MOD_LOG2_MAX + NTT_MOD_LOG2_MIN)) |
                    ((dlimb_t)a1 << (NTT_MOD_LOG2_MAX - NTT_MOD_LOG2_MIN)) |
                    ((dlimb_t)a2 << (LIMB_BITS + NTT_MOD_LOG2_MAX - NTT_MOD_LOG2_MIN));
                a0 &= ((limb_t)1 << (LIMB_BITS - NTT_MOD_LOG2_MAX + NTT_MOD_LOG2_MIN)) - 1;
            }
        }
        for(j = 0; j < nb_mods; j++) {
            m = ntt_mods[first_m_idx + j];
            m_inv = s->ntt_mods_div[first_m_idx + j];
            r = mod_fast(a, m, m_inv);
            if (dpl > (LIMB_BITS + NTT_MOD_LOG2_MIN)) {
                b = ((dlimb_t)r << (LIMB_BITS - NTT_MOD_LOG2_MAX + NTT_MOD_LOG2_MIN)) | a0;
                r = mod_fast(b, m, m_inv);
            }
            tabr[i + j * fft_len] = int_to_ntt_limb(r, m);
        }
    }
}

#if defined(__AVX2__)

#define VEC_LEN 4

typedef union {
    __m256d v;
    double d[4];
} VecUnion;

static no_inline void ntt_to_limb(BFNTTState *s, limb_t *tabr, limb_t r_len,
                                  const NTTLimb *buf, int fft_len_log2, int dpl,
                                  int nb_mods)
{
    const limb_t *mods = ntt_mods + NB_MODS - nb_mods;
    const __m256d *mods_cr_vec, *mf, *m_inv;
    VecUnion y[NB_MODS];
    limb_t u[NB_MODS], carry[NB_MODS], fft_len, base_mask1, r;
    slimb_t i, len, pos;
    int j, k, l, shift, n_limb1, p;
    dlimb_t t;
        
    j = NB_MODS * (NB_MODS - 1) / 2 - nb_mods * (nb_mods - 1) / 2;
    mods_cr_vec = s->ntt_mods_cr_vec + j;
    mf = s->ntt_mods_vec + NB_MODS - nb_mods;
    m_inv = s->ntt_mods_inv_vec + NB_MODS - nb_mods;
        
    shift = dpl & (LIMB_BITS - 1);
    if (shift == 0)
        base_mask1 = -1;
    else
        base_mask1 = ((limb_t)1 << shift) - 1;
    n_limb1 = ((unsigned)dpl - 1) / LIMB_BITS;
    for(j = 0; j < NB_MODS; j++) 
        carry[j] = 0;
    for(j = 0; j < NB_MODS; j++) 
        u[j] = 0; /* avoid warnings */
    memset(tabr, 0, sizeof(limb_t) * r_len);
    fft_len = (limb_t)1 << fft_len_log2;
    len = bf_min(fft_len, (r_len * LIMB_BITS + dpl - 1) / dpl);
    len = (len + VEC_LEN - 1) & ~(VEC_LEN - 1);
    i = 0;
    while (i < len) {
        for(j = 0; j < nb_mods; j++)
            y[j].v = *(__m256d *)&buf[i + fft_len * j];

        /* Chinese remainder to get mixed radix representation */
        l = 0;
        for(j = 0; j < nb_mods - 1; j++) {
            y[j].v = ntt_mod1(y[j].v, mf[j]);
            for(k = j + 1; k < nb_mods; k++) {
                y[k].v = ntt_mul_mod(y[k].v - y[j].v,
                                     mods_cr_vec[l], mf[k], m_inv[k]);
                l++;
            }
        }
        y[j].v = ntt_mod1(y[j].v, mf[j]);
        
        for(p = 0; p < VEC_LEN; p++) {
            /* back to normal representation */
            u[0] = (int64_t)y[nb_mods - 1].d[p];
            l = 1;
            for(j = nb_mods - 2; j >= 1; j--) {
                r = (int64_t)y[j].d[p];
                for(k = 0; k < l; k++) {
                    t = (dlimb_t)u[k] * mods[j] + r;
                    r = t >> LIMB_BITS;
                    u[k] = t;
                }
                u[l] = r;
                l++;
            }
            /* XXX: for nb_mods = 5, l should be 4 */
            
            /* last step adds the carry */
            r = (int64_t)y[0].d[p];
            for(k = 0; k < l; k++) {
                t = (dlimb_t)u[k] * mods[j] + r + carry[k];
                r = t >> LIMB_BITS;
                u[k] = t;
            }
            u[l] = r + carry[l];

#if 0
            printf("%" PRId64 ": ", i);
            for(j = nb_mods - 1; j >= 0; j--) {
                printf(" %019" PRIu64, u[j]);
            }
            printf("\n");
#endif
            
            /* write the digits */
            pos = i * dpl;
            for(j = 0; j < n_limb1; j++) {
                put_bits(tabr, r_len, pos, u[j]);
                pos += LIMB_BITS;
            }
            put_bits(tabr, r_len, pos, u[n_limb1] & base_mask1);
            /* shift by dpl digits and set the carry */
            if (shift == 0) {
                for(j = n_limb1 + 1; j < nb_mods; j++)
                    carry[j - (n_limb1 + 1)] = u[j];
            } else {
                for(j = n_limb1; j < nb_mods - 1; j++) {
                    carry[j - n_limb1] = (u[j] >> shift) |
                        (u[j + 1] << (LIMB_BITS - shift));
                }
                carry[nb_mods - 1 - n_limb1] = u[nb_mods - 1] >> shift;
            }
            i++;
        }
    }
}
#else
static no_inline void ntt_to_limb(BFNTTState *s, limb_t *tabr, limb_t r_len,
                                  const NTTLimb *buf, int fft_len_log2, int dpl,
                                  int nb_mods)
{
    const limb_t *mods = ntt_mods + NB_MODS - nb_mods;
    const limb_t *mods_cr, *mods_cr_inv;
    limb_t y[NB_MODS], u[NB_MODS], carry[NB_MODS], fft_len, base_mask1, r;
    slimb_t i, len, pos;
    int j, k, l, shift, n_limb1;
    dlimb_t t;
        
    j = NB_MODS * (NB_MODS - 1) / 2 - nb_mods * (nb_mods - 1) / 2;
    mods_cr = ntt_mods_cr + j;
    mods_cr_inv = s->ntt_mods_cr_inv + j;

    shift = dpl & (LIMB_BITS - 1);
    if (shift == 0)
        base_mask1 = -1;
    else
        base_mask1 = ((limb_t)1 << shift) - 1;
    n_limb1 = ((unsigned)dpl - 1) / LIMB_BITS;
    for(j = 0; j < NB_MODS; j++) 
        carry[j] = 0;
    for(j = 0; j < NB_MODS; j++) 
        u[j] = 0; /* avoid warnings */
    memset(tabr, 0, sizeof(limb_t) * r_len);
    fft_len = (limb_t)1 << fft_len_log2;
    len = bf_min(fft_len, (r_len * LIMB_BITS + dpl - 1) / dpl);
    for(i = 0; i < len; i++) {
        for(j = 0; j < nb_mods; j++)  {
            y[j] = ntt_limb_to_int(buf[i + fft_len * j], mods[j]);
        }

        /* Chinese remainder to get mixed radix representation */
        l = 0;
        for(j = 0; j < nb_mods - 1; j++) {
            for(k = j + 1; k < nb_mods; k++) {
                limb_t m;
                m = mods[k];
                /* Note: there is no overflow in the sub_mod() because
                   the modulos are sorted by increasing order */
                y[k] = mul_mod_fast2(y[k] - y[j] + m, 
                                     mods_cr[l], m, mods_cr_inv[l]);
                l++;
            }
        }
        
        /* back to normal representation */
        u[0] = y[nb_mods - 1];
        l = 1;
        for(j = nb_mods - 2; j >= 1; j--) {
            r = y[j];
            for(k = 0; k < l; k++) {
                t = (dlimb_t)u[k] * mods[j] + r;
                r = t >> LIMB_BITS;
                u[k] = t;
            }
            u[l] = r;
            l++;
        }
        
        /* last step adds the carry */
        r = y[0];
        for(k = 0; k < l; k++) {
            t = (dlimb_t)u[k] * mods[j] + r + carry[k];
            r = t >> LIMB_BITS;
            u[k] = t;
        }
        u[l] = r + carry[l];

#if 0
        printf("%" PRId64 ": ", (int64_t)i);
        for(j = nb_mods - 1; j >= 0; j--) {
            printf(" " FMT_LIMB, u[j]);
        }
        printf("\n");
#endif
        
        /* write the digits */
        pos = i * dpl;
        for(j = 0; j < n_limb1; j++) {
            put_bits(tabr, r_len, pos, u[j]);
            pos += LIMB_BITS;
        }
        put_bits(tabr, r_len, pos, u[n_limb1] & base_mask1);
        /* shift by dpl digits and set the carry */
        if (shift == 0) {
            for(j = n_limb1 + 1; j < nb_mods; j++)
                carry[j - (n_limb1 + 1)] = u[j];
        } else {
            for(j = n_limb1; j < nb_mods - 1; j++) {
                carry[j - n_limb1] = (u[j] >> shift) |
                    (u[j + 1] << (LIMB_BITS - shift));
            }
            carry[nb_mods - 1 - n_limb1] = u[nb_mods - 1] >> shift;
        }
    }
}
#endif

static int ntt_static_init(bf_context_t *s1)
{
    BFNTTState *s;
    int inverse, i, j, k, l;
    limb_t c, c_inv, c_inv2, m, m_inv;

    if (s1->ntt_state)
        return 0;
#if defined(__AVX2__)
    s = bf_aligned_malloc(s1, sizeof(*s), 64);
#else
    s = bf_malloc(s1, sizeof(*s));
#endif
    if (!s)
        return -1;
    memset(s, 0, sizeof(*s));
    s1->ntt_state = s;
    s->ctx = s1;
    
    for(j = 0; j < NB_MODS; j++) {
        m = ntt_mods[j];
        m_inv = init_mul_mod_fast(m);
        s->ntt_mods_div[j] = m_inv;
#if defined(__AVX2__)
        s->ntt_mods_vec[j] = _mm256_set1_pd(m);
        s->ntt_mods_inv_vec[j] = _mm256_set1_pd(1.0 / (double)m);
#endif
        c_inv2 = (m + 1) / 2; /* 1/2 */
        c_inv = 1;
        for(i = 0; i <= NTT_PROOT_2EXP; i++) {
            s->ntt_len_inv[j][i][0] = c_inv;
            s->ntt_len_inv[j][i][1] = init_mul_mod_fast2(c_inv, m);
            c_inv = mul_mod_fast(c_inv, c_inv2, m, m_inv);
        }

        for(inverse = 0; inverse < 2; inverse++) {
            c = ntt_proot[inverse][j];
            for(i = 0; i < NTT_PROOT_2EXP; i++) {
                s->ntt_proot_pow[j][inverse][NTT_PROOT_2EXP - i] = c;
                s->ntt_proot_pow_inv[j][inverse][NTT_PROOT_2EXP - i] =
                    init_mul_mod_fast2(c, m);
                c = mul_mod_fast(c, c, m, m_inv);
            }
        }
    }

    l = 0;
    for(j = 0; j < NB_MODS - 1; j++) {
        for(k = j + 1; k < NB_MODS; k++) {
#if defined(__AVX2__)
            s->ntt_mods_cr_vec[l] = _mm256_set1_pd(int_to_ntt_limb2(ntt_mods_cr[l],
                                                                    ntt_mods[k]));
#else
            s->ntt_mods_cr_inv[l] = init_mul_mod_fast2(ntt_mods_cr[l],
                                                       ntt_mods[k]);
#endif
            l++;
        }
    }
    return 0;
}

int bf_get_fft_size(int *pdpl, int *pnb_mods, limb_t len)
{
    int dpl, fft_len_log2, n_bits, nb_mods, dpl_found, fft_len_log2_found;
    int int_bits, nb_mods_found;
    limb_t cost, min_cost;
    
    min_cost = -1;
    dpl_found = 0;
    nb_mods_found = 4;
    fft_len_log2_found = 0;
    for(nb_mods = 3; nb_mods <= NB_MODS; nb_mods++) {
        int_bits = ntt_int_bits[NB_MODS - nb_mods];
        dpl = bf_min((int_bits - 4) / 2,
                     2 * LIMB_BITS + 2 * NTT_MOD_LOG2_MIN - NTT_MOD_LOG2_MAX);
        for(;;) {
            fft_len_log2 = ceil_log2((len * LIMB_BITS + dpl - 1) / dpl);
            if (fft_len_log2 > NTT_PROOT_2EXP)
                goto next;
            n_bits = fft_len_log2 + 2 * dpl;
            if (n_bits <= int_bits) {
                cost = ((limb_t)(fft_len_log2 + 1) << fft_len_log2) * nb_mods;
                //                printf("n=%d dpl=%d: cost=%" PRId64 "\n", nb_mods, dpl, (int64_t)cost);
                if (cost < min_cost) {
                    min_cost = cost;
                    dpl_found = dpl;
                    nb_mods_found = nb_mods;
                    fft_len_log2_found = fft_len_log2;
                }
                break;
            }
            dpl--;
            if (dpl == 0)
                break;
        }
    next: ;
    }
    if (!dpl_found)
        abort();
    /* limit dpl if possible to reduce fixed cost of limb/NTT conversion */
    if (dpl_found > (LIMB_BITS + NTT_MOD_LOG2_MIN) &&
        ((limb_t)(LIMB_BITS + NTT_MOD_LOG2_MIN) << fft_len_log2_found) >=
        len * LIMB_BITS) {
        dpl_found = LIMB_BITS + NTT_MOD_LOG2_MIN;
    }
    *pnb_mods = nb_mods_found;
    *pdpl = dpl_found;
    return fft_len_log2_found;
}

/* return 0 if OK, -1 if memory error */
static no_inline int fft_mul(bf_context_t *s1,
                             bf_t *res, limb_t *a_tab, limb_t a_len,
                             limb_t *b_tab, limb_t b_len, int mul_flags)
{
    BFNTTState *s;
    int dpl, fft_len_log2, j, nb_mods, reduced_mem;
    slimb_t len, fft_len;
    NTTLimb *buf1, *buf2, *ptr;
#if defined(USE_MUL_CHECK)
    limb_t ha, hb, hr, h_ref;
#endif
    
    if (ntt_static_init(s1))
        return -1;
    s = s1->ntt_state;
    
    /* find the optimal number of digits per limb (dpl) */
    len = a_len + b_len;
    fft_len_log2 = bf_get_fft_size(&dpl, &nb_mods, len);
    fft_len = (uint64_t)1 << fft_len_log2;
    //    printf("len=%" PRId64 " fft_len_log2=%d dpl=%d\n", len, fft_len_log2, dpl);
#if defined(USE_MUL_CHECK)
    ha = mp_mod1(a_tab, a_len, BF_CHKSUM_MOD, 0);
    hb = mp_mod1(b_tab, b_len, BF_CHKSUM_MOD, 0);
#endif
    if ((mul_flags & (FFT_MUL_R_OVERLAP_A | FFT_MUL_R_OVERLAP_B)) == 0) {
        if (!(mul_flags & FFT_MUL_R_NORESIZE))
            bf_resize(res, 0);
    } else if (mul_flags & FFT_MUL_R_OVERLAP_B) {
        limb_t *tmp_tab, tmp_len;
        /* it is better to free 'b' first */
        tmp_tab = a_tab;
        a_tab = b_tab;
        b_tab = tmp_tab;
        tmp_len = a_len;
        a_len = b_len;
        b_len = tmp_len;
    }
    buf1 = ntt_malloc(s, sizeof(NTTLimb) * fft_len * nb_mods);
    if (!buf1)
        return -1;
    limb_to_ntt(s, buf1, fft_len, a_tab, a_len, dpl,
                NB_MODS - nb_mods, nb_mods);
    if ((mul_flags & (FFT_MUL_R_OVERLAP_A | FFT_MUL_R_OVERLAP_B)) == 
        FFT_MUL_R_OVERLAP_A) {
        if (!(mul_flags & FFT_MUL_R_NORESIZE))
            bf_resize(res, 0);
    }
    reduced_mem = (fft_len_log2 >= 14);
    if (!reduced_mem) {
        buf2 = ntt_malloc(s, sizeof(NTTLimb) * fft_len * nb_mods);
        if (!buf2)
            goto fail;
        limb_to_ntt(s, buf2, fft_len, b_tab, b_len, dpl,
                    NB_MODS - nb_mods, nb_mods);
        if (!(mul_flags & FFT_MUL_R_NORESIZE))
            bf_resize(res, 0); /* in case res == b */
    } else {
        buf2 = ntt_malloc(s, sizeof(NTTLimb) * fft_len);
        if (!buf2)
            goto fail;
    }
    for(j = 0; j < nb_mods; j++) {
        if (reduced_mem) {
            limb_to_ntt(s, buf2, fft_len, b_tab, b_len, dpl,
                        NB_MODS - nb_mods + j, 1);
            ptr = buf2;
        } else {
            ptr = buf2 + fft_len * j;
        }
        if (ntt_conv(s, buf1 + fft_len * j, ptr,
                     fft_len_log2, fft_len_log2, j + NB_MODS - nb_mods))
            goto fail;
    }
    if (!(mul_flags & FFT_MUL_R_NORESIZE))
        bf_resize(res, 0); /* in case res == b and reduced mem */
    ntt_free(s, buf2);
    buf2 = NULL;
    if (!(mul_flags & FFT_MUL_R_NORESIZE)) {
        if (bf_resize(res, len))
            goto fail;
    }
    ntt_to_limb(s, res->tab, len, buf1, fft_len_log2, dpl, nb_mods);
    ntt_free(s, buf1);
#if defined(USE_MUL_CHECK)
    hr = mp_mod1(res->tab, len, BF_CHKSUM_MOD, 0);
    h_ref = mul_mod(ha, hb, BF_CHKSUM_MOD);
    if (hr != h_ref) {
        printf("ntt_mul_error: len=%" PRId_LIMB " fft_len_log2=%d dpl=%d nb_mods=%d\n",
               len, fft_len_log2, dpl, nb_mods);
        //        printf("ha=0x" FMT_LIMB" hb=0x" FMT_LIMB " hr=0x" FMT_LIMB " expected=0x" FMT_LIMB "\n", ha, hb, hr, h_ref);
        exit(1);
    }
#endif    
    return 0;
 fail:
    ntt_free(s, buf1);
    ntt_free(s, buf2);
    return -1;
}

#else /* USE_FFT_MUL */

int bf_get_fft_size(int *pdpl, int *pnb_mods, limb_t len)
{
    return 0;
}

#endif /* !USE_FFT_MUL */

'''
'''--- libbf.h ---
/*
 * Tiny arbitrary precision floating point library
 * 
 * Copyright (c) 2017-2021 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef LIBBF_H
#define LIBBF_H

#include <stddef.h>
#include <stdint.h>

#if INTPTR_MAX >= INT64_MAX
#define LIMB_LOG2_BITS 6
#else
#define LIMB_LOG2_BITS 5
#endif

#define LIMB_BITS (1 << LIMB_LOG2_BITS)

#if LIMB_BITS == 64
typedef __int128 int128_t;
typedef unsigned __int128 uint128_t;
typedef int64_t slimb_t;
typedef uint64_t limb_t;
typedef uint128_t dlimb_t;
#define BF_RAW_EXP_MIN INT64_MIN
#define BF_RAW_EXP_MAX INT64_MAX

#define LIMB_DIGITS 19
#define BF_DEC_BASE UINT64_C(10000000000000000000)

#else

typedef int32_t slimb_t;
typedef uint32_t limb_t;
typedef uint64_t dlimb_t;
#define BF_RAW_EXP_MIN INT32_MIN
#define BF_RAW_EXP_MAX INT32_MAX

#define LIMB_DIGITS 9
#define BF_DEC_BASE 1000000000U

#endif

/* in bits */
/* minimum number of bits for the exponent */
#define BF_EXP_BITS_MIN 3
/* maximum number of bits for the exponent */
#define BF_EXP_BITS_MAX (LIMB_BITS - 3)
/* extended range for exponent, used internally */
#define BF_EXT_EXP_BITS_MAX (BF_EXP_BITS_MAX + 1)
/* minimum possible precision */
#define BF_PREC_MIN 2
/* minimum possible precision */
#define BF_PREC_MAX (((limb_t)1 << (LIMB_BITS - 2)) - 2)
/* some operations support infinite precision */
#define BF_PREC_INF (BF_PREC_MAX + 1) /* infinite precision */

#if LIMB_BITS == 64
#define BF_CHKSUM_MOD (UINT64_C(975620677) * UINT64_C(9795002197))
#else
#define BF_CHKSUM_MOD 975620677U
#endif

#define BF_EXP_ZERO BF_RAW_EXP_MIN
#define BF_EXP_INF (BF_RAW_EXP_MAX - 1)
#define BF_EXP_NAN BF_RAW_EXP_MAX

/* +/-zero is represented with expn = BF_EXP_ZERO and len = 0,
   +/-infinity is represented with expn = BF_EXP_INF and len = 0,
   NaN is represented with expn = BF_EXP_NAN and len = 0 (sign is ignored)
 */
typedef struct {
    struct bf_context_t *ctx;
    int sign;
    slimb_t expn;
    limb_t len;
    limb_t *tab;
} bf_t;

typedef struct {
    /* must be kept identical to bf_t */
    struct bf_context_t *ctx;
    int sign;
    slimb_t expn;
    limb_t len;
    limb_t *tab;
} bfdec_t;

typedef enum {
    BF_RNDN, /* round to nearest, ties to even */
    BF_RNDZ, /* round to zero */
    BF_RNDD, /* round to -inf (the code relies on (BF_RNDD xor BF_RNDU) = 1) */
    BF_RNDU, /* round to +inf */
    BF_RNDNA, /* round to nearest, ties away from zero */
    BF_RNDA, /* round away from zero */
    BF_RNDF, /* faithful rounding (nondeterministic, either RNDD or RNDU,
                inexact flag is always set)  */
} bf_rnd_t;

/* allow subnormal numbers. Only available if the number of exponent
   bits is <= BF_EXP_BITS_USER_MAX and prec != BF_PREC_INF. */
#define BF_FLAG_SUBNORMAL (1 << 3)
/* 'prec' is the precision after the radix point instead of the whole
   mantissa. Can only be used with bf_round() and
   bfdec_[add|sub|mul|div|sqrt|round](). */
#define BF_FLAG_RADPNT_PREC (1 << 4)

#define BF_RND_MASK 0x7
#define BF_EXP_BITS_SHIFT 5
#define BF_EXP_BITS_MASK 0x3f

/* shortcut for bf_set_exp_bits(BF_EXT_EXP_BITS_MAX) */
#define BF_FLAG_EXT_EXP (BF_EXP_BITS_MASK << BF_EXP_BITS_SHIFT)

/* contains the rounding mode and number of exponents bits */
typedef uint32_t bf_flags_t;

typedef void *bf_realloc_func_t(void *opaque, void *ptr, size_t size);

typedef struct {
    bf_t val;
    limb_t prec;
} BFConstCache;

typedef struct bf_context_t {
    void *realloc_opaque;
    bf_realloc_func_t *realloc_func;
    BFConstCache log2_cache;
    BFConstCache pi_cache;
    struct BFNTTState *ntt_state;
} bf_context_t;

static inline int bf_get_exp_bits(bf_flags_t flags)
{
    int e;
    e = (flags >> BF_EXP_BITS_SHIFT) & BF_EXP_BITS_MASK;
    if (e == BF_EXP_BITS_MASK)
        return BF_EXP_BITS_MAX + 1;
    else
        return BF_EXP_BITS_MAX - e;
}

static inline bf_flags_t bf_set_exp_bits(int n)
{
    return ((BF_EXP_BITS_MAX - n) & BF_EXP_BITS_MASK) << BF_EXP_BITS_SHIFT;
}

/* returned status */
#define BF_ST_INVALID_OP  (1 << 0)
#define BF_ST_DIVIDE_ZERO (1 << 1)
#define BF_ST_OVERFLOW    (1 << 2)
#define BF_ST_UNDERFLOW   (1 << 3)
#define BF_ST_INEXACT     (1 << 4)
/* indicate that a memory allocation error occured. NaN is returned */
#define BF_ST_MEM_ERROR   (1 << 5) 

#define BF_RADIX_MAX 36 /* maximum radix for bf_atof() and bf_ftoa() */

static inline slimb_t bf_max(slimb_t a, slimb_t b)
{
    if (a > b)
        return a;
    else
        return b;
}

static inline slimb_t bf_min(slimb_t a, slimb_t b)
{
    if (a < b)
        return a;
    else
        return b;
}

void bf_context_init(bf_context_t *s, bf_realloc_func_t *realloc_func,
                     void *realloc_opaque);
void bf_context_end(bf_context_t *s);
/* free memory allocated for the bf cache data */
void bf_clear_cache(bf_context_t *s);

static inline void *bf_realloc(bf_context_t *s, void *ptr, size_t size)
{
    return s->realloc_func(s->realloc_opaque, ptr, size);
}

/* 'size' must be != 0 */
static inline void *bf_malloc(bf_context_t *s, size_t size)
{
    return bf_realloc(s, NULL, size);
}

static inline void bf_free(bf_context_t *s, void *ptr)
{
    /* must test ptr otherwise equivalent to malloc(0) */
    if (ptr)
        bf_realloc(s, ptr, 0);
}

void bf_init(bf_context_t *s, bf_t *r);

static inline void bf_delete(bf_t *r)
{
    bf_context_t *s = r->ctx;
    /* we accept to delete a zeroed bf_t structure */
    if (s && r->tab) {
        bf_realloc(s, r->tab, 0);
    }
}

static inline void bf_neg(bf_t *r)
{
    r->sign ^= 1;
}

static inline int bf_is_finite(const bf_t *a)
{
    return (a->expn < BF_EXP_INF);
}

static inline int bf_is_nan(const bf_t *a)
{
    return (a->expn == BF_EXP_NAN);
}

static inline int bf_is_zero(const bf_t *a)
{
    return (a->expn == BF_EXP_ZERO);
}

static inline void bf_memcpy(bf_t *r, const bf_t *a)
{
    *r = *a;
}

int bf_set_ui(bf_t *r, uint64_t a);
int bf_set_si(bf_t *r, int64_t a);
void bf_set_nan(bf_t *r);
void bf_set_zero(bf_t *r, int is_neg);
void bf_set_inf(bf_t *r, int is_neg);
int bf_set(bf_t *r, const bf_t *a);
void bf_move(bf_t *r, bf_t *a);
int bf_get_float64(const bf_t *a, double *pres, bf_rnd_t rnd_mode);
int bf_set_float64(bf_t *a, double d);

int bf_cmpu(const bf_t *a, const bf_t *b);
int bf_cmp_full(const bf_t *a, const bf_t *b);
int bf_cmp(const bf_t *a, const bf_t *b);
static inline int bf_cmp_eq(const bf_t *a, const bf_t *b)
{
    return bf_cmp(a, b) == 0;
}

static inline int bf_cmp_le(const bf_t *a, const bf_t *b)
{
    return bf_cmp(a, b) <= 0;
}

static inline int bf_cmp_lt(const bf_t *a, const bf_t *b)
{
    return bf_cmp(a, b) < 0;
}

int bf_add(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec, bf_flags_t flags);
int bf_sub(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec, bf_flags_t flags);
int bf_add_si(bf_t *r, const bf_t *a, int64_t b1, limb_t prec, bf_flags_t flags);
int bf_mul(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec, bf_flags_t flags);
int bf_mul_ui(bf_t *r, const bf_t *a, uint64_t b1, limb_t prec, bf_flags_t flags);
int bf_mul_si(bf_t *r, const bf_t *a, int64_t b1, limb_t prec, 
              bf_flags_t flags);
int bf_mul_2exp(bf_t *r, slimb_t e, limb_t prec, bf_flags_t flags);
int bf_div(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec, bf_flags_t flags);
#define BF_DIVREM_EUCLIDIAN BF_RNDF
int bf_divrem(bf_t *q, bf_t *r, const bf_t *a, const bf_t *b,
              limb_t prec, bf_flags_t flags, int rnd_mode);
int bf_rem(bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
           bf_flags_t flags, int rnd_mode);
int bf_remquo(slimb_t *pq, bf_t *r, const bf_t *a, const bf_t *b, limb_t prec,
              bf_flags_t flags, int rnd_mode);
/* round to integer with infinite precision */
int bf_rint(bf_t *r, int rnd_mode);
int bf_round(bf_t *r, limb_t prec, bf_flags_t flags);
int bf_sqrtrem(bf_t *r, bf_t *rem1, const bf_t *a);
int bf_sqrt(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);
slimb_t bf_get_exp_min(const bf_t *a);
int bf_logic_or(bf_t *r, const bf_t *a, const bf_t *b);
int bf_logic_xor(bf_t *r, const bf_t *a, const bf_t *b);
int bf_logic_and(bf_t *r, const bf_t *a, const bf_t *b);

/* additional flags for bf_atof */
/* do not accept hex radix prefix (0x or 0X) if radix = 0 or radix = 16 */
#define BF_ATOF_NO_HEX       (1 << 16)
/* accept binary (0b or 0B) or octal (0o or 0O) radix prefix if radix = 0 */
#define BF_ATOF_BIN_OCT      (1 << 17)
/* Do not parse NaN or Inf */
#define BF_ATOF_NO_NAN_INF   (1 << 18)
/* return the exponent separately */
#define BF_ATOF_EXPONENT       (1 << 19)

int bf_atof(bf_t *a, const char *str, const char **pnext, int radix,
            limb_t prec, bf_flags_t flags);
/* this version accepts prec = BF_PREC_INF and returns the radix
   exponent */
int bf_atof2(bf_t *r, slimb_t *pexponent,
             const char *str, const char **pnext, int radix,
             limb_t prec, bf_flags_t flags);
int bf_mul_pow_radix(bf_t *r, const bf_t *T, limb_t radix,
                     slimb_t expn, limb_t prec, bf_flags_t flags);

/* Conversion of floating point number to string. Return a null
   terminated string or NULL if memory error. *plen contains its
   length if plen != NULL.  The exponent letter is "e" for base 10,
   "p" for bases 2, 8, 16 with a binary exponent and "@" for the other
   bases. */

#define BF_FTOA_FORMAT_MASK (3 << 16)

/* fixed format: prec significant digits rounded with (flags &
   BF_RND_MASK). Exponential notation is used if too many zeros are
   needed.*/
#define BF_FTOA_FORMAT_FIXED (0 << 16)
/* fractional format: prec digits after the decimal point rounded with
   (flags & BF_RND_MASK) */
#define BF_FTOA_FORMAT_FRAC  (1 << 16)
/* free format: 
   
   For binary radices with bf_ftoa() and for bfdec_ftoa(): use the minimum
   number of digits to represent 'a'. The precision and the rounding
   mode are ignored.
   
   For the non binary radices with bf_ftoa(): use as many digits as
   necessary so that bf_atof() return the same number when using
   precision 'prec', rounding to nearest and the subnormal
   configuration of 'flags'. The result is meaningful only if 'a' is
   already rounded to 'prec' bits. If the subnormal flag is set, the
   exponent in 'flags' must also be set to the desired exponent range.
*/
#define BF_FTOA_FORMAT_FREE  (2 << 16)
/* same as BF_FTOA_FORMAT_FREE but uses the minimum number of digits
   (takes more computation time). Identical to BF_FTOA_FORMAT_FREE for
   binary radices with bf_ftoa() and for bfdec_ftoa(). */
#define BF_FTOA_FORMAT_FREE_MIN (3 << 16)

/* force exponential notation for fixed or free format */
#define BF_FTOA_FORCE_EXP    (1 << 20)
/* add 0x prefix for base 16, 0o prefix for base 8 or 0b prefix for
   base 2 if non zero value */
#define BF_FTOA_ADD_PREFIX   (1 << 21)
/* return "Infinity" instead of "Inf" and add a "+" for positive
   exponents */
#define BF_FTOA_JS_QUIRKS    (1 << 22)

char *bf_ftoa(size_t *plen, const bf_t *a, int radix, limb_t prec,
              bf_flags_t flags);

/* modulo 2^n instead of saturation. NaN and infinity return 0 */
#define BF_GET_INT_MOD (1 << 0) 
int bf_get_int32(int *pres, const bf_t *a, int flags);
int bf_get_int64(int64_t *pres, const bf_t *a, int flags);
int bf_get_uint64(uint64_t *pres, const bf_t *a);

/* the following functions are exported for testing only. */
void mp_print_str(const char *str, const limb_t *tab, limb_t n);
void bf_print_str(const char *str, const bf_t *a);
int bf_resize(bf_t *r, limb_t len);
int bf_get_fft_size(int *pdpl, int *pnb_mods, limb_t len);
int bf_normalize_and_round(bf_t *r, limb_t prec1, bf_flags_t flags);
int bf_can_round(const bf_t *a, slimb_t prec, bf_rnd_t rnd_mode, slimb_t k);
slimb_t bf_mul_log2_radix(slimb_t a1, unsigned int radix, int is_inv,
                          int is_ceil1);
int mp_mul(bf_context_t *s, limb_t *result, 
           const limb_t *op1, limb_t op1_size, 
           const limb_t *op2, limb_t op2_size);
limb_t mp_add(limb_t *res, const limb_t *op1, const limb_t *op2, 
              limb_t n, limb_t carry);
limb_t mp_add_ui(limb_t *tab, limb_t b, size_t n);
int mp_sqrtrem(bf_context_t *s, limb_t *tabs, limb_t *taba, limb_t n);
int mp_recip(bf_context_t *s, limb_t *tabr, const limb_t *taba, limb_t n);
limb_t bf_isqrt(limb_t a);

/* transcendental functions */
int bf_const_log2(bf_t *T, limb_t prec, bf_flags_t flags);
int bf_const_pi(bf_t *T, limb_t prec, bf_flags_t flags);
int bf_exp(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);
int bf_log(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);
#define BF_POW_JS_QUIRKS (1 << 16) /* (+/-1)^(+/-Inf) = NaN, 1^NaN = NaN */
int bf_pow(bf_t *r, const bf_t *x, const bf_t *y, limb_t prec, bf_flags_t flags);
int bf_cos(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);
int bf_sin(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);
int bf_tan(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);
int bf_atan(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);
int bf_atan2(bf_t *r, const bf_t *y, const bf_t *x,
             limb_t prec, bf_flags_t flags);
int bf_asin(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);
int bf_acos(bf_t *r, const bf_t *a, limb_t prec, bf_flags_t flags);

/* decimal floating point */

static inline void bfdec_init(bf_context_t *s, bfdec_t *r)
{
    bf_init(s, (bf_t *)r);
}
static inline void bfdec_delete(bfdec_t *r)
{
    bf_delete((bf_t *)r);
}

static inline void bfdec_neg(bfdec_t *r)
{
    r->sign ^= 1;
}

static inline int bfdec_is_finite(const bfdec_t *a)
{
    return (a->expn < BF_EXP_INF);
}

static inline int bfdec_is_nan(const bfdec_t *a)
{
    return (a->expn == BF_EXP_NAN);
}

static inline int bfdec_is_zero(const bfdec_t *a)
{
    return (a->expn == BF_EXP_ZERO);
}

static inline void bfdec_memcpy(bfdec_t *r, const bfdec_t *a)
{
    bf_memcpy((bf_t *)r, (const bf_t *)a);
}

int bfdec_set_ui(bfdec_t *r, uint64_t a);
int bfdec_set_si(bfdec_t *r, int64_t a);

static inline void bfdec_set_nan(bfdec_t *r)
{
    bf_set_nan((bf_t *)r);
}
static inline void bfdec_set_zero(bfdec_t *r, int is_neg)
{
    bf_set_zero((bf_t *)r, is_neg);
}
static inline void bfdec_set_inf(bfdec_t *r, int is_neg)
{
    bf_set_inf((bf_t *)r, is_neg);
}
static inline int bfdec_set(bfdec_t *r, const bfdec_t *a)
{
    return bf_set((bf_t *)r, (bf_t *)a);
}
static inline void bfdec_move(bfdec_t *r, bfdec_t *a)
{
    bf_move((bf_t *)r, (bf_t *)a);
}
static inline int bfdec_cmpu(const bfdec_t *a, const bfdec_t *b)
{
    return bf_cmpu((const bf_t *)a, (const bf_t *)b);
}
static inline int bfdec_cmp_full(const bfdec_t *a, const bfdec_t *b)
{
    return bf_cmp_full((const bf_t *)a, (const bf_t *)b);
}
static inline int bfdec_cmp(const bfdec_t *a, const bfdec_t *b)
{
    return bf_cmp((const bf_t *)a, (const bf_t *)b);
}
static inline int bfdec_cmp_eq(const bfdec_t *a, const bfdec_t *b)
{
    return bfdec_cmp(a, b) == 0;
}
static inline int bfdec_cmp_le(const bfdec_t *a, const bfdec_t *b)
{
    return bfdec_cmp(a, b) <= 0;
}
static inline int bfdec_cmp_lt(const bfdec_t *a, const bfdec_t *b)
{
    return bfdec_cmp(a, b) < 0;
}

int bfdec_add(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
              bf_flags_t flags);
int bfdec_sub(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
              bf_flags_t flags);
int bfdec_add_si(bfdec_t *r, const bfdec_t *a, int64_t b1, limb_t prec,
                 bf_flags_t flags);
int bfdec_mul(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
              bf_flags_t flags);
int bfdec_mul_si(bfdec_t *r, const bfdec_t *a, int64_t b1, limb_t prec,
                 bf_flags_t flags);
int bfdec_div(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
              bf_flags_t flags);
int bfdec_divrem(bfdec_t *q, bfdec_t *r, const bfdec_t *a, const bfdec_t *b,
                 limb_t prec, bf_flags_t flags, int rnd_mode);
int bfdec_rem(bfdec_t *r, const bfdec_t *a, const bfdec_t *b, limb_t prec,
              bf_flags_t flags, int rnd_mode);
int bfdec_rint(bfdec_t *r, int rnd_mode);
int bfdec_sqrt(bfdec_t *r, const bfdec_t *a, limb_t prec, bf_flags_t flags);
int bfdec_round(bfdec_t *r, limb_t prec, bf_flags_t flags);
int bfdec_get_int32(int *pres, const bfdec_t *a);
int bfdec_pow_ui(bfdec_t *r, const bfdec_t *a, limb_t b);

char *bfdec_ftoa(size_t *plen, const bfdec_t *a, limb_t prec, bf_flags_t flags);
int bfdec_atof(bfdec_t *r, const char *str, const char **pnext,
               limb_t prec, bf_flags_t flags);

/* the following functions are exported for testing only. */
extern const limb_t mp_pow_dec[LIMB_DIGITS + 1];
void bfdec_print_str(const char *str, const bfdec_t *a);
static inline int bfdec_resize(bfdec_t *r, limb_t len)
{
    return bf_resize((bf_t *)r, len);
}
int bfdec_normalize_and_round(bfdec_t *r, limb_t prec1, bf_flags_t flags);

#endif /* LIBBF_H */

'''
'''--- libregexp-opcode.h ---
/*
 * Regular Expression Engine
 * 
 * Copyright (c) 2017-2018 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifdef DEF

DEF(invalid, 1) /* never used */
DEF(char, 3)
DEF(char32, 5)
DEF(dot, 1)
DEF(any, 1) /* same as dot but match any character including line terminator */
DEF(line_start, 1)
DEF(line_end, 1)
DEF(goto, 5)
DEF(split_goto_first, 5)
DEF(split_next_first, 5)
DEF(match, 1)
DEF(save_start, 2) /* save start position */
DEF(save_end, 2) /* save end position, must come after saved_start */
DEF(save_reset, 3) /* reset save positions */
DEF(loop, 5) /* decrement the top the stack and goto if != 0 */
DEF(push_i32, 5) /* push integer on the stack */
DEF(drop, 1)
DEF(word_boundary, 1)
DEF(not_word_boundary, 1)
DEF(back_reference, 2)
DEF(backward_back_reference, 2) /* must come after back_reference */
DEF(range, 3) /* variable length */
DEF(range32, 3) /* variable length */
DEF(lookahead, 5)
DEF(negative_lookahead, 5)
DEF(push_char_pos, 1) /* push the character position on the stack */
DEF(bne_char_pos, 5) /* pop one stack element and jump if equal to the character
 position */
DEF(prev, 1) /* go to the previous char */
DEF(simple_greedy_quant, 17)

#endif /* DEF */

'''
'''--- libregexp.c ---
/*
 * Regular Expression Engine
 * 
 * Copyright (c) 2017-2018 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <inttypes.h>
#include <string.h>
#include <assert.h>

#include "cutils.h"
#include "libregexp.h"

/*
  TODO:

  - Add full unicode canonicalize rules for character ranges (not
    really useful but needed for exact "ignorecase" compatibility).

  - Add a lock step execution mode (=linear time execution guaranteed)
    when the regular expression is "simple" i.e. no backreference nor
    complicated lookahead. The opcodes are designed for this execution
    model.
*/

#if defined(TEST)
#define DUMP_REOP
#endif

typedef enum {
#define DEF(id, size) REOP_ ## id,
#include "libregexp-opcode.h"
#undef DEF
    REOP_COUNT,
} REOPCodeEnum;

#define CAPTURE_COUNT_MAX 255
#define STACK_SIZE_MAX 255

/* unicode code points */
#define CP_LS   0x2028
#define CP_PS   0x2029

#define TMP_BUF_SIZE 128

typedef struct {
    DynBuf byte_code;
    const uint8_t *buf_ptr;
    const uint8_t *buf_end;
    const uint8_t *buf_start;
    int re_flags;
    BOOL is_utf16;
    BOOL ignore_case;
    BOOL dotall;
    int capture_count;
    int total_capture_count; /* -1 = not computed yet */
    int has_named_captures; /* -1 = don't know, 0 = no, 1 = yes */
    void *opaque;
    DynBuf group_names;
    union {
        char error_msg[TMP_BUF_SIZE];
        char tmp_buf[TMP_BUF_SIZE];
    } u;
} REParseState;

typedef struct {
#ifdef DUMP_REOP
    const char *name;
#endif
    uint8_t size;
} REOpCode;

static const REOpCode reopcode_info[REOP_COUNT] = {
#ifdef DUMP_REOP
#define DEF(id, size) { #id, size },
#else
#define DEF(id, size) { size },
#endif
#include "libregexp-opcode.h"
#undef DEF
};

#define RE_HEADER_FLAGS         0
#define RE_HEADER_CAPTURE_COUNT 1
#define RE_HEADER_STACK_SIZE    2

#define RE_HEADER_LEN 7

static inline int is_digit(int c) {
    return c >= '0' && c <= '9';
}

/* insert 'len' bytes at position 'pos'. Return < 0 if error. */
static int dbuf_insert(DynBuf *s, int pos, int len)
{
    if (dbuf_realloc(s, s->size + len))
        return -1;
    memmove(s->buf + pos + len, s->buf + pos, s->size - pos);
    s->size += len;
    return 0;
}

/* canonicalize with the specific JS regexp rules */
static uint32_t lre_canonicalize(uint32_t c, BOOL is_utf16)
{
    uint32_t res[LRE_CC_RES_LEN_MAX];
    int len;
    if (is_utf16) {
        if (likely(c < 128)) {
            if (c >= 'A' && c <= 'Z')
                c = c - 'A' + 'a';
        } else {
            lre_case_conv(res, c, 2);
            c = res[0];
        }
    } else {
        if (likely(c < 128)) {
            if (c >= 'a' && c <= 'z')
                c = c - 'a' + 'A';
        } else {
            /* legacy regexp: to upper case if single char >= 128 */
            len = lre_case_conv(res, c, FALSE);
            if (len == 1 && res[0] >= 128)
                c = res[0];
        }
    }
    return c;
}

static const uint16_t char_range_d[] = {
    1,
    0x0030, 0x0039 + 1,
};

/* code point ranges for Zs,Zl or Zp property */
static const uint16_t char_range_s[] = {
    10,
    0x0009, 0x000D + 1,
    0x0020, 0x0020 + 1,
    0x00A0, 0x00A0 + 1,
    0x1680, 0x1680 + 1,
    0x2000, 0x200A + 1,
    /* 2028;LINE SEPARATOR;Zl;0;WS;;;;;N;;;;; */
    /* 2029;PARAGRAPH SEPARATOR;Zp;0;B;;;;;N;;;;; */
    0x2028, 0x2029 + 1,
    0x202F, 0x202F + 1,
    0x205F, 0x205F + 1,
    0x3000, 0x3000 + 1,
    /* FEFF;ZERO WIDTH NO-BREAK SPACE;Cf;0;BN;;;;;N;BYTE ORDER MARK;;;; */
    0xFEFF, 0xFEFF + 1,
};

BOOL lre_is_space(int c)
{
    int i, n, low, high;
    n = (countof(char_range_s) - 1) / 2;
    for(i = 0; i < n; i++) {
        low = char_range_s[2 * i + 1];
        if (c < low)
            return FALSE;
        high = char_range_s[2 * i + 2];
        if (c < high)
            return TRUE;
    }
    return FALSE;
}

uint32_t const lre_id_start_table_ascii[4] = {
    /* $ A-Z _ a-z */
    0x00000000, 0x00000010, 0x87FFFFFE, 0x07FFFFFE
};

uint32_t const lre_id_continue_table_ascii[4] = {
    /* $ 0-9 A-Z _ a-z */
    0x00000000, 0x03FF0010, 0x87FFFFFE, 0x07FFFFFE
};

static const uint16_t char_range_w[] = {
    4,
    0x0030, 0x0039 + 1,
    0x0041, 0x005A + 1,
    0x005F, 0x005F + 1,
    0x0061, 0x007A + 1,
};

#define CLASS_RANGE_BASE 0x40000000

typedef enum {
    CHAR_RANGE_d,
    CHAR_RANGE_D,
    CHAR_RANGE_s,
    CHAR_RANGE_S,
    CHAR_RANGE_w,
    CHAR_RANGE_W,
} CharRangeEnum;

static const uint16_t *char_range_table[] = {
    char_range_d,
    char_range_s,
    char_range_w,
};

static int cr_init_char_range(REParseState *s, CharRange *cr, uint32_t c)
{
    BOOL invert;
    const uint16_t *c_pt;
    int len, i;
    
    invert = c & 1;
    c_pt = char_range_table[c >> 1];
    len = *c_pt++;
    cr_init(cr, s->opaque, lre_realloc);
    for(i = 0; i < len * 2; i++) {
        if (cr_add_point(cr, c_pt[i]))
            goto fail;
    }
    if (invert) {
        if (cr_invert(cr))
            goto fail;
    }
    return 0;
 fail:
    cr_free(cr);
    return -1;
}

static int cr_canonicalize(CharRange *cr)
{
    CharRange a;
    uint32_t pt[2];
    int i, ret;

    cr_init(&a, cr->mem_opaque, lre_realloc);
    pt[0] = 'a';
    pt[1] = 'z' + 1;
    ret = cr_op(&a, cr->points, cr->len, pt, 2, CR_OP_INTER);
    if (ret)
        goto fail;
    /* convert to upper case */
    /* XXX: the generic unicode case would be much more complicated
       and not really useful */
    for(i = 0; i < a.len; i++) {
        a.points[i] += 'A' - 'a';
    }
    /* Note: for simplicity we keep the lower case ranges */
    ret = cr_union1(cr, a.points, a.len);
 fail:
    cr_free(&a);
    return ret;
}

#ifdef DUMP_REOP
static __maybe_unused void lre_dump_bytecode(const uint8_t *buf,
                                                     int buf_len)
{
    int pos, len, opcode, bc_len, re_flags, i;
    uint32_t val;
    
    assert(buf_len >= RE_HEADER_LEN);

    re_flags=  buf[0];
    bc_len = get_u32(buf + 3);
    assert(bc_len + RE_HEADER_LEN <= buf_len);
    printf("flags: 0x%x capture_count=%d stack_size=%d\n",
           re_flags, buf[1], buf[2]);
    if (re_flags & LRE_FLAG_NAMED_GROUPS) {
        const char *p;
        p = (char *)buf + RE_HEADER_LEN + bc_len;
        printf("named groups: ");
        for(i = 1; i < buf[1]; i++) {
            if (i != 1)
                printf(",");
            printf("<%s>", p);
            p += strlen(p) + 1;
        }
        printf("\n");
        assert(p == (char *)(buf + buf_len));
    }
    printf("bytecode_len=%d\n", bc_len);

    buf += RE_HEADER_LEN;
    pos = 0;
    while (pos < bc_len) {
        printf("%5u: ", pos);
        opcode = buf[pos];
        len = reopcode_info[opcode].size;
        if (opcode >= REOP_COUNT) {
            printf(" invalid opcode=0x%02x\n", opcode);
            break;
        }
        if ((pos + len) > bc_len) {
            printf(" buffer overflow (opcode=0x%02x)\n", opcode);
            break;
        }
        printf("%s", reopcode_info[opcode].name);
        switch(opcode) {
        case REOP_char:
            val = get_u16(buf + pos + 1);
            if (val >= ' ' && val <= 126)
                printf(" '%c'", val);
            else
                printf(" 0x%04x", val);
            break;
        case REOP_char32:
            val = get_u32(buf + pos + 1);
            if (val >= ' ' && val <= 126)
                printf(" '%c'", val);
            else
                printf(" 0x%08x", val);
            break;
        case REOP_goto:
        case REOP_split_goto_first:
        case REOP_split_next_first:
        case REOP_loop:
        case REOP_lookahead:
        case REOP_negative_lookahead:
        case REOP_bne_char_pos:
            val = get_u32(buf + pos + 1);
            val += (pos + 5);
            printf(" %u", val);
            break;
        case REOP_simple_greedy_quant:
            printf(" %u %u %u %u",
                   get_u32(buf + pos + 1) + (pos + 17),
                   get_u32(buf + pos + 1 + 4),
                   get_u32(buf + pos + 1 + 8),
                   get_u32(buf + pos + 1 + 12));
            break;
        case REOP_save_start:
        case REOP_save_end:
        case REOP_back_reference:
        case REOP_backward_back_reference:
            printf(" %u", buf[pos + 1]);
            break;
        case REOP_save_reset:
            printf(" %u %u", buf[pos + 1], buf[pos + 2]);
            break;
        case REOP_push_i32:
            val = get_u32(buf + pos + 1);
            printf(" %d", val);
            break;
        case REOP_range:
            {
                int n, i;
                n = get_u16(buf + pos + 1);
                len += n * 4;
                for(i = 0; i < n * 2; i++) {
                    val = get_u16(buf + pos + 3 + i * 2);
                    printf(" 0x%04x", val);
                }
            }
            break;
        case REOP_range32:
            {
                int n, i;
                n = get_u16(buf + pos + 1);
                len += n * 8;
                for(i = 0; i < n * 2; i++) {
                    val = get_u32(buf + pos + 3 + i * 4);
                    printf(" 0x%08x", val);
                }
            }
            break;
        default:
            break;
        }
        printf("\n");
        pos += len;
    }
}
#endif

static void re_emit_op(REParseState *s, int op)
{
    dbuf_putc(&s->byte_code, op);
}

/* return the offset of the u32 value */
static int re_emit_op_u32(REParseState *s, int op, uint32_t val)
{
    int pos;
    dbuf_putc(&s->byte_code, op);
    pos = s->byte_code.size;
    dbuf_put_u32(&s->byte_code, val);
    return pos;
}

static int re_emit_goto(REParseState *s, int op, uint32_t val)
{
    int pos;
    dbuf_putc(&s->byte_code, op);
    pos = s->byte_code.size;
    dbuf_put_u32(&s->byte_code, val - (pos + 4));
    return pos;
}

static void re_emit_op_u8(REParseState *s, int op, uint32_t val)
{
    dbuf_putc(&s->byte_code, op);
    dbuf_putc(&s->byte_code, val);
}

static void re_emit_op_u16(REParseState *s, int op, uint32_t val)
{
    dbuf_putc(&s->byte_code, op);
    dbuf_put_u16(&s->byte_code, val);
}

static int __attribute__((format(printf, 2, 3))) re_parse_error(REParseState *s, const char *fmt, ...)
{
    va_list ap;
    va_start(ap, fmt);
    vsnprintf(s->u.error_msg, sizeof(s->u.error_msg), fmt, ap);
    va_end(ap);
    return -1;
}

static int re_parse_out_of_memory(REParseState *s)
{
    return re_parse_error(s, "out of memory");
}

/* If allow_overflow is false, return -1 in case of
   overflow. Otherwise return INT32_MAX. */
static int parse_digits(const uint8_t **pp, BOOL allow_overflow)
{
    const uint8_t *p;
    uint64_t v;
    int c;
    
    p = *pp;
    v = 0;
    for(;;) {
        c = *p;
        if (c < '0' || c > '9')
            break;
        v = v * 10 + c - '0';
        if (v >= INT32_MAX) {
            if (allow_overflow)
                v = INT32_MAX;
            else
                return -1;
        }
        p++;
    }
    *pp = p;
    return v;
}

static int re_parse_expect(REParseState *s, const uint8_t **pp, int c)
{
    const uint8_t *p;
    p = *pp;
    if (*p != c)
        return re_parse_error(s, "expecting '%c'", c);
    p++;
    *pp = p;
    return 0;
}

/* Parse an escape sequence, *pp points after the '\':
   allow_utf16 value:
   0 : no UTF-16 escapes allowed
   1 : UTF-16 escapes allowed
   2 : UTF-16 escapes allowed and escapes of surrogate pairs are
   converted to a unicode character (unicode regexp case).

   Return the unicode char and update *pp if recognized,
   return -1 if malformed escape,
   return -2 otherwise. */
int lre_parse_escape(const uint8_t **pp, int allow_utf16)
{
    const uint8_t *p;
    uint32_t c;

    p = *pp;
    c = *p++;
    switch(c) {
    case 'b':
        c = '\b';
        break;
    case 'f':
        c = '\f';
        break;
    case 'n':
        c = '\n';
        break;
    case 'r':
        c = '\r';
        break;
    case 't':
        c = '\t';
        break;
    case 'v':
        c = '\v';
        break;
    case 'x':
    case 'u':
        {
            int h, n, i;
            uint32_t c1;
            
            if (*p == '{' && allow_utf16) {
                p++;
                c = 0;
                for(;;) {
                    h = from_hex(*p++);
                    if (h < 0)
                        return -1;
                    c = (c << 4) | h;
                    if (c > 0x10FFFF)
                        return -1;
                    if (*p == '}')
                        break;
                }
                p++;
            } else {
                if (c == 'x') {
                    n = 2;
                } else {
                    n = 4;
                }

                c = 0;
                for(i = 0; i < n; i++) {
                    h = from_hex(*p++);
                    if (h < 0) {
                        return -1;
                    }
                    c = (c << 4) | h;
                }
                if (c >= 0xd800 && c < 0xdc00 &&
                    allow_utf16 == 2 && p[0] == '\\' && p[1] == 'u') {
                    /* convert an escaped surrogate pair into a
                       unicode char */
                    c1 = 0;
                    for(i = 0; i < 4; i++) {
                        h = from_hex(p[2 + i]);
                        if (h < 0)
                            break;
                        c1 = (c1 << 4) | h;
                    }
                    if (i == 4 && c1 >= 0xdc00 && c1 < 0xe000) {
                        p += 6;
                        c = (((c & 0x3ff) << 10) | (c1 & 0x3ff)) + 0x10000;
                    }
                }
            }
        }
        break;
    case '0': case '1': case '2': case '3':
    case '4': case '5': case '6': case '7':
        c -= '0';
        if (allow_utf16 == 2) {
            /* only accept \0 not followed by digit */
            if (c != 0 || is_digit(*p))
                return -1;
        } else {
            /* parse a legacy octal sequence */
            uint32_t v;
            v = *p - '0';
            if (v > 7)
                break;
            c = (c << 3) | v;
            p++;
            if (c >= 32)
                break;
            v = *p - '0';
            if (v > 7)
                break;
            c = (c << 3) | v;
            p++;
        }
        break;
    default:
        return -2;
    }
    *pp = p;
    return c;
}

#ifdef CONFIG_ALL_UNICODE
/* XXX: we use the same chars for name and value */
static BOOL is_unicode_char(int c)
{
    return ((c >= '0' && c <= '9') ||
            (c >= 'A' && c <= 'Z') ||
            (c >= 'a' && c <= 'z') ||
            (c == '_'));
}

static int parse_unicode_property(REParseState *s, CharRange *cr,
                                  const uint8_t **pp, BOOL is_inv)
{
    const uint8_t *p;
    char name[64], value[64];
    char *q;
    BOOL script_ext;
    int ret;

    p = *pp;
    if (*p != '{')
        return re_parse_error(s, "expecting '{' after \\p");
    p++;
    q = name;
    while (is_unicode_char(*p)) {
        if ((q - name) >= sizeof(name) - 1)
            goto unknown_property_name;
        *q++ = *p++;
    }
    *q = '\0';
    q = value;
    if (*p == '=') {
        p++;
        while (is_unicode_char(*p)) {
            if ((q - value) >= sizeof(value) - 1)
                return re_parse_error(s, "unknown unicode property value");
            *q++ = *p++;
        }
    }
    *q = '\0';
    if (*p != '}')
        return re_parse_error(s, "expecting '}'");
    p++;
    //    printf("name=%s value=%s\n", name, value);

    if (!strcmp(name, "Script") || !strcmp(name, "sc")) {
        script_ext = FALSE;
        goto do_script;
    } else if (!strcmp(name, "Script_Extensions") || !strcmp(name, "scx")) {
        script_ext = TRUE;
    do_script:
        cr_init(cr, s->opaque, lre_realloc);
        ret = unicode_script(cr, value, script_ext);
        if (ret) {
            cr_free(cr);
            if (ret == -2)
                return re_parse_error(s, "unknown unicode script");
            else
                goto out_of_memory;
        }
    } else if (!strcmp(name, "General_Category") || !strcmp(name, "gc")) {
        cr_init(cr, s->opaque, lre_realloc);
        ret = unicode_general_category(cr, value);
        if (ret) {
            cr_free(cr);
            if (ret == -2)
                return re_parse_error(s, "unknown unicode general category");
            else
                goto out_of_memory;
        }
    } else if (value[0] == '\0') {
        cr_init(cr, s->opaque, lre_realloc);
        ret = unicode_general_category(cr, name);
        if (ret == -1) {
            cr_free(cr);
            goto out_of_memory;
        }
        if (ret < 0) {
            ret = unicode_prop(cr, name);
            if (ret) {
                cr_free(cr);
                if (ret == -2)
                    goto unknown_property_name;
                else
                    goto out_of_memory;
            }
        }
    } else {
    unknown_property_name:
        return re_parse_error(s, "unknown unicode property name");
    }

    if (is_inv) {
        if (cr_invert(cr)) {
            cr_free(cr);
            return -1;
        }
    }
    *pp = p;
    return 0;
 out_of_memory:
    return re_parse_out_of_memory(s);
}
#endif /* CONFIG_ALL_UNICODE */

/* return -1 if error otherwise the character or a class range
   (CLASS_RANGE_BASE). In case of class range, 'cr' is
   initialized. Otherwise, it is ignored. */
static int get_class_atom(REParseState *s, CharRange *cr,
                          const uint8_t **pp, BOOL inclass)
{
    const uint8_t *p;
    uint32_t c;
    int ret;
    
    p = *pp;

    c = *p;
    switch(c) {
    case '\\':
        p++;
        if (p >= s->buf_end)
            goto unexpected_end;
        c = *p++;
        switch(c) {
        case 'd':
            c = CHAR_RANGE_d;
            goto class_range;
        case 'D':
            c = CHAR_RANGE_D;
            goto class_range;
        case 's':
            c = CHAR_RANGE_s;
            goto class_range;
        case 'S':
            c = CHAR_RANGE_S;
            goto class_range;
        case 'w':
            c = CHAR_RANGE_w;
            goto class_range;
        case 'W':
            c = CHAR_RANGE_W;
        class_range:
            if (cr_init_char_range(s, cr, c))
                return -1;
            c = CLASS_RANGE_BASE;
            break;
        case 'c':
            c = *p;
            if ((c >= 'a' && c <= 'z') ||
                (c >= 'A' && c <= 'Z') ||
                (((c >= '0' && c <= '9') || c == '_') &&
                 inclass && !s->is_utf16)) {   /* Annex B.1.4 */
                c &= 0x1f;
                p++;
            } else if (s->is_utf16) {
                goto invalid_escape;
            } else {
                /* otherwise return '\' and 'c' */
                p--;
                c = '\\';
            }
            break;
#ifdef CONFIG_ALL_UNICODE
        case 'p':
        case 'P':
            if (s->is_utf16) {
                if (parse_unicode_property(s, cr, &p, (c == 'P')))
                    return -1;
                c = CLASS_RANGE_BASE;
                break;
            }
            /* fall thru */
#endif
        default:
            p--;
            ret = lre_parse_escape(&p, s->is_utf16 * 2);
            if (ret >= 0) {
                c = ret;
            } else {
                if (ret == -2 && *p != '\0' && strchr("^$\\.*+?()[]{}|/", *p)) {
                    /* always valid to escape these characters */
                    goto normal_char;
                } else if (s->is_utf16) {
                invalid_escape:
                    return re_parse_error(s, "invalid escape sequence in regular expression");
                } else {
                    /* just ignore the '\' */
                    goto normal_char;
                }
            }
            break;
        }
        break;
    case '\0':
        if (p >= s->buf_end) {
        unexpected_end:
            return re_parse_error(s, "unexpected end");
        }
        /* fall thru */
    default:
    normal_char:
        /* normal char */
        if (c >= 128) {
            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
            if ((unsigned)c > 0xffff && !s->is_utf16) {
                /* XXX: should handle non BMP-1 code points */
                return re_parse_error(s, "malformed unicode char");
            }
        } else {
            p++;
        }
        break;
    }
    *pp = p;
    return c;
}

static int re_emit_range(REParseState *s, const CharRange *cr)
{
    int len, i;
    uint32_t high;
    
    len = (unsigned)cr->len / 2;
    if (len >= 65535)
        return re_parse_error(s, "too many ranges");
    if (len == 0) {
        /* not sure it can really happen. Emit a match that is always
           false */
        re_emit_op_u32(s, REOP_char32, -1);
    } else {
        high = cr->points[cr->len - 1];
        if (high == UINT32_MAX)
            high = cr->points[cr->len - 2];
        if (high <= 0xffff) {
            /* can use 16 bit ranges with the conversion that 0xffff =
               infinity */
            re_emit_op_u16(s, REOP_range, len);
            for(i = 0; i < cr->len; i += 2) {
                dbuf_put_u16(&s->byte_code, cr->points[i]);
                high = cr->points[i + 1] - 1;
                if (high == UINT32_MAX - 1)
                    high = 0xffff;
                dbuf_put_u16(&s->byte_code, high);
            }
        } else {
            re_emit_op_u16(s, REOP_range32, len);
            for(i = 0; i < cr->len; i += 2) {
                dbuf_put_u32(&s->byte_code, cr->points[i]);
                dbuf_put_u32(&s->byte_code, cr->points[i + 1] - 1);
            }
        }
    }
    return 0;
}

static int re_parse_char_class(REParseState *s, const uint8_t **pp)
{
    const uint8_t *p;
    uint32_t c1, c2;
    CharRange cr_s, *cr = &cr_s;
    CharRange cr1_s, *cr1 = &cr1_s;
    BOOL invert;
    
    cr_init(cr, s->opaque, lre_realloc);
    p = *pp;
    p++;    /* skip '[' */
    invert = FALSE;
    if (*p == '^') {
        p++;
        invert = TRUE;
    }
    for(;;) {
        if (*p == ']')
            break;
        c1 = get_class_atom(s, cr1, &p, TRUE);
        if ((int)c1 < 0)
            goto fail;
        if (*p == '-' && p[1] != ']') {
            const uint8_t *p0 = p + 1;
            if (c1 >= CLASS_RANGE_BASE) {
                if (s->is_utf16) {
                    cr_free(cr1);
                    goto invalid_class_range;
                }
                /* Annex B: match '-' character */
                goto class_atom;
            }
            c2 = get_class_atom(s, cr1, &p0, TRUE);
            if ((int)c2 < 0)
                goto fail;
            if (c2 >= CLASS_RANGE_BASE) {
                cr_free(cr1);
                if (s->is_utf16) {
                    goto invalid_class_range;
                }
                /* Annex B: match '-' character */
                goto class_atom;
            }
            p = p0;
            if (c2 < c1) {
            invalid_class_range:
                re_parse_error(s, "invalid class range");
                goto fail;
            }
            if (cr_union_interval(cr, c1, c2))
                goto memory_error;
        } else {
        class_atom:
            if (c1 >= CLASS_RANGE_BASE) {
                int ret;
                ret = cr_union1(cr, cr1->points, cr1->len);
                cr_free(cr1);
                if (ret)
                    goto memory_error;
            } else {
                if (cr_union_interval(cr, c1, c1))
                    goto memory_error;
            }
        }
    }
    if (s->ignore_case) {
        if (cr_canonicalize(cr))
            goto memory_error;
    }
    if (invert) {
        if (cr_invert(cr))
            goto memory_error;
    }
    if (re_emit_range(s, cr))
        goto fail;
    cr_free(cr);
    p++;    /* skip ']' */
    *pp = p;
    return 0;
 memory_error:
    re_parse_out_of_memory(s);
 fail:
    cr_free(cr);
    return -1;
}

/* Return:
   1 if the opcodes in bc_buf[] always advance the character pointer.
   0 if the character pointer may not be advanced.
   -1 if the code may depend on side effects of its previous execution (backreference)
*/
static int re_check_advance(const uint8_t *bc_buf, int bc_buf_len)
{
    int pos, opcode, ret, len, i;
    uint32_t val, last;
    BOOL has_back_reference;
    uint8_t capture_bitmap[CAPTURE_COUNT_MAX];
    
    ret = -2; /* not known yet */
    pos = 0;
    has_back_reference = FALSE;
    memset(capture_bitmap, 0, sizeof(capture_bitmap));
    
    while (pos < bc_buf_len) {
        opcode = bc_buf[pos];
        len = reopcode_info[opcode].size;
        switch(opcode) {
        case REOP_range:
            val = get_u16(bc_buf + pos + 1);
            len += val * 4;
            goto simple_char;
        case REOP_range32:
            val = get_u16(bc_buf + pos + 1);
            len += val * 8;
            goto simple_char;
        case REOP_char:
        case REOP_char32:
        case REOP_dot:
        case REOP_any:
        simple_char:
            if (ret == -2)
                ret = 1;
            break;
        case REOP_line_start:
        case REOP_line_end:
        case REOP_push_i32:
        case REOP_push_char_pos:
        case REOP_drop:
        case REOP_word_boundary:
        case REOP_not_word_boundary:
        case REOP_prev:
            /* no effect */
            break;
        case REOP_save_start:
        case REOP_save_end:
            val = bc_buf[pos + 1];
            capture_bitmap[val] |= 1;
            break;
        case REOP_save_reset:
            {
                val = bc_buf[pos + 1];
                last = bc_buf[pos + 2];
                while (val < last)
                    capture_bitmap[val++] |= 1;
            }
            break;
        case REOP_back_reference:
        case REOP_backward_back_reference:
            val = bc_buf[pos + 1];
            capture_bitmap[val] |= 2;
            has_back_reference = TRUE;
            break;
        default:
            /* safe behvior: we cannot predict the outcome */
            if (ret == -2)
                ret = 0;
            break;
        }
        pos += len;
    }
    if (has_back_reference) {
        /* check if there is back reference which references a capture
           made in the some code */
        for(i = 0; i < CAPTURE_COUNT_MAX; i++) {
            if (capture_bitmap[i] == 3)
                return -1;
        }
    }
    if (ret == -2)
        ret = 0;
    return ret;
}

/* return -1 if a simple quantifier cannot be used. Otherwise return
   the number of characters in the atom. */
static int re_is_simple_quantifier(const uint8_t *bc_buf, int bc_buf_len)
{
    int pos, opcode, len, count;
    uint32_t val;
    
    count = 0;
    pos = 0;
    while (pos < bc_buf_len) {
        opcode = bc_buf[pos];
        len = reopcode_info[opcode].size;
        switch(opcode) {
        case REOP_range:
            val = get_u16(bc_buf + pos + 1);
            len += val * 4;
            goto simple_char;
        case REOP_range32:
            val = get_u16(bc_buf + pos + 1);
            len += val * 8;
            goto simple_char;
        case REOP_char:
        case REOP_char32:
        case REOP_dot:
        case REOP_any:
        simple_char:
            count++;
            break;
        case REOP_line_start:
        case REOP_line_end:
        case REOP_word_boundary:
        case REOP_not_word_boundary:
            break;
        default:
            return -1;
        }
        pos += len;
    }
    return count;
}

/* '*pp' is the first char after '<' */
static int re_parse_group_name(char *buf, int buf_size,
                               const uint8_t **pp, BOOL is_utf16)
{
    const uint8_t *p;
    uint32_t c;
    char *q;

    p = *pp;
    q = buf;
    for(;;) {
        c = *p;
        if (c == '\\') {
            p++;
            if (*p != 'u')
                return -1;
            c = lre_parse_escape(&p, is_utf16 * 2);
        } else if (c == '>') {
            break;
        } else if (c >= 128) {
            c = unicode_from_utf8(p, UTF8_CHAR_LEN_MAX, &p);
        } else {
            p++;
        }
        if (c > 0x10FFFF)
            return -1;
        if (q == buf) {
            if (!lre_js_is_ident_first(c))
                return -1;
        } else {
            if (!lre_js_is_ident_next(c))
                return -1;
        }
        if ((q - buf + UTF8_CHAR_LEN_MAX + 1) > buf_size)
            return -1;
        if (c < 128) {
            *q++ = c;
        } else {
            q += unicode_to_utf8((uint8_t*)q, c);
        }
    }
    if (q == buf)
        return -1;
    *q = '\0';
    p++;
    *pp = p;
    return 0;
}

/* if capture_name = NULL: return the number of captures + 1.
   Otherwise, return the capture index corresponding to capture_name
   or -1 if none */
static int re_parse_captures(REParseState *s, int *phas_named_captures,
                             const char *capture_name)
{
    const uint8_t *p;
    int capture_index;
    char name[TMP_BUF_SIZE];

    capture_index = 1;
    *phas_named_captures = 0;
    for (p = s->buf_start; p < s->buf_end; p++) {
        switch (*p) {
        case '(':
            if (p[1] == '?') {
                if (p[2] == '<' && p[3] != '=' && p[3] != '!') {
                    *phas_named_captures = 1;
                    /* potential named capture */
                    if (capture_name) {
                        p += 3;
                        if (re_parse_group_name(name, sizeof(name), &p,
                                                s->is_utf16) == 0) {
                            if (!strcmp(name, capture_name))
                                return capture_index;
                        }
                    }
                    capture_index++;
                    if (capture_index >= CAPTURE_COUNT_MAX)
                        goto done;
                }
            } else {
                capture_index++;
                if (capture_index >= CAPTURE_COUNT_MAX)
                    goto done;
            }
            break;
        case '\\':
            p++;
            break;
        case '[':
            for (p += 1 + (*p == ']'); p < s->buf_end && *p != ']'; p++) {
                if (*p == '\\')
                    p++;
            }
            break;
        }
    }
 done:
    if (capture_name)
        return -1;
    else
        return capture_index;
}

static int re_count_captures(REParseState *s)
{
    if (s->total_capture_count < 0) {
        s->total_capture_count = re_parse_captures(s, &s->has_named_captures,
                                                   NULL);
    }
    return s->total_capture_count;
}

static BOOL re_has_named_captures(REParseState *s)
{
    if (s->has_named_captures < 0)
        re_count_captures(s);
    return s->has_named_captures;
}

static int find_group_name(REParseState *s, const char *name)
{
    const char *p, *buf_end;
    size_t len, name_len;
    int capture_index;
    
    name_len = strlen(name);
    p = (char *)s->group_names.buf;
    buf_end = (char *)s->group_names.buf + s->group_names.size;
    capture_index = 1;
    while (p < buf_end) {
        len = strlen(p);
        if (len == name_len && memcmp(name, p, name_len) == 0)
            return capture_index;
        p += len + 1;
        capture_index++;
    }
    return -1;
}

static int re_parse_disjunction(REParseState *s, BOOL is_backward_dir);

static int re_parse_term(REParseState *s, BOOL is_backward_dir)
{
    const uint8_t *p;
    int c, last_atom_start, quant_min, quant_max, last_capture_count;
    BOOL greedy, add_zero_advance_check, is_neg, is_backward_lookahead;
    CharRange cr_s, *cr = &cr_s;
    
    last_atom_start = -1;
    last_capture_count = 0;
    p = s->buf_ptr;
    c = *p;
    switch(c) {
    case '^':
        p++;
        re_emit_op(s, REOP_line_start);
        break;
    case '$':
        p++;
        re_emit_op(s, REOP_line_end);
        break;
    case '.':
        p++;
        last_atom_start = s->byte_code.size;
        last_capture_count = s->capture_count;
        if (is_backward_dir)
            re_emit_op(s, REOP_prev);
        re_emit_op(s, s->dotall ? REOP_any : REOP_dot);
        if (is_backward_dir)
            re_emit_op(s, REOP_prev);
        break;
    case '{':
        if (s->is_utf16) {
            return re_parse_error(s, "syntax error");
        } else if (!is_digit(p[1])) {
            /* Annex B: we accept '{' not followed by digits as a
               normal atom */
            goto parse_class_atom;
        } else {
            const uint8_t *p1 = p + 1;
            /* Annex B: error if it is like a repetition count */
            parse_digits(&p1, TRUE);
            if (*p1 == ',') {
                p1++;
                if (is_digit(*p1)) {
                    parse_digits(&p1, TRUE);
                }
            }
            if (*p1 != '}') {
                goto parse_class_atom;
            }
        }
        /* fall thru */
    case '*':
    case '+':
    case '?':
        return re_parse_error(s, "nothing to repeat");
    case '(':
        if (p[1] == '?') {
            if (p[2] == ':') {
                p += 3;
                last_atom_start = s->byte_code.size;
                last_capture_count = s->capture_count;
                s->buf_ptr = p;
                if (re_parse_disjunction(s, is_backward_dir))
                    return -1;
                p = s->buf_ptr;
                if (re_parse_expect(s, &p, ')'))
                    return -1;
            } else if ((p[2] == '=' || p[2] == '!')) {
                is_neg = (p[2] == '!');
                is_backward_lookahead = FALSE;
                p += 3;
                goto lookahead;
            } else if (p[2] == '<' &&
                       (p[3] == '=' || p[3] == '!')) {
                int pos;
                is_neg = (p[3] == '!');
                is_backward_lookahead = TRUE;
                p += 4;
                /* lookahead */
            lookahead:
                /* Annex B allows lookahead to be used as an atom for
                   the quantifiers */
                if (!s->is_utf16 && !is_backward_lookahead)  {
                    last_atom_start = s->byte_code.size;
                    last_capture_count = s->capture_count;
                }
                pos = re_emit_op_u32(s, REOP_lookahead + is_neg, 0);
                s->buf_ptr = p;
                if (re_parse_disjunction(s, is_backward_lookahead))
                    return -1;
                p = s->buf_ptr;
                if (re_parse_expect(s, &p, ')'))
                    return -1;
                re_emit_op(s, REOP_match);
                /* jump after the 'match' after the lookahead is successful */
                if (dbuf_error(&s->byte_code))
                    return -1;
                put_u32(s->byte_code.buf + pos, s->byte_code.size - (pos + 4));
            } else if (p[2] == '<') {
                p += 3;
                if (re_parse_group_name(s->u.tmp_buf, sizeof(s->u.tmp_buf),
                                        &p, s->is_utf16)) {
                    return re_parse_error(s, "invalid group name");
                }
                if (find_group_name(s, s->u.tmp_buf) > 0) {
                    return re_parse_error(s, "duplicate group name");
                }
                /* group name with a trailing zero */
                dbuf_put(&s->group_names, (uint8_t *)s->u.tmp_buf,
                         strlen(s->u.tmp_buf) + 1);
                s->has_named_captures = 1;
                goto parse_capture;
            } else {
                return re_parse_error(s, "invalid group");
            }
        } else {
            int capture_index;
            p++;
            /* capture without group name */
            dbuf_putc(&s->group_names, 0);
        parse_capture:
            if (s->capture_count >= CAPTURE_COUNT_MAX)
                return re_parse_error(s, "too many captures");
            last_atom_start = s->byte_code.size;
            last_capture_count = s->capture_count;
            capture_index = s->capture_count++;
            re_emit_op_u8(s, REOP_save_start + is_backward_dir,
                          capture_index);
            
            s->buf_ptr = p;
            if (re_parse_disjunction(s, is_backward_dir))
                return -1;
            p = s->buf_ptr;
            
            re_emit_op_u8(s, REOP_save_start + 1 - is_backward_dir,
                          capture_index);
            
            if (re_parse_expect(s, &p, ')'))
                return -1;
        }
        break;
    case '\\':
        switch(p[1]) {
        case 'b':
        case 'B':
            re_emit_op(s, REOP_word_boundary + (p[1] != 'b'));
            p += 2;
            break;
        case 'k':
            {
                const uint8_t *p1;
                int dummy_res;
                
                p1 = p;
                if (p1[2] != '<') {
                    /* annex B: we tolerate invalid group names in non
                       unicode mode if there is no named capture
                       definition */
                    if (s->is_utf16 || re_has_named_captures(s))
                        return re_parse_error(s, "expecting group name");
                    else
                        goto parse_class_atom;
                }
                p1 += 3;
                if (re_parse_group_name(s->u.tmp_buf, sizeof(s->u.tmp_buf),
                                        &p1, s->is_utf16)) {
                    if (s->is_utf16 || re_has_named_captures(s))
                        return re_parse_error(s, "invalid group name");
                    else
                        goto parse_class_atom;
                }
                c = find_group_name(s, s->u.tmp_buf);
                if (c < 0) {
                    /* no capture name parsed before, try to look
                       after (inefficient, but hopefully not common */
                    c = re_parse_captures(s, &dummy_res, s->u.tmp_buf);
                    if (c < 0) {
                        if (s->is_utf16 || re_has_named_captures(s))
                            return re_parse_error(s, "group name not defined");
                        else
                            goto parse_class_atom;
                    }
                }
                p = p1;
            }
            goto emit_back_reference;
        case '0':
            p += 2;
            c = 0;
            if (s->is_utf16) {
                if (is_digit(*p)) {
                    return re_parse_error(s, "invalid decimal escape in regular expression");
                }
            } else {
                /* Annex B.1.4: accept legacy octal */
                if (*p >= '0' && *p <= '7') {
                    c = *p++ - '0';
                    if (*p >= '0' && *p <= '7') {
                        c = (c << 3) + *p++ - '0';
                    }
                }
            }
            goto normal_char;
        case '1': case '2': case '3': case '4':
        case '5': case '6': case '7': case '8':
        case '9': 
            {
                const uint8_t *q = ++p;
                
                c = parse_digits(&p, FALSE);
                if (c < 0 || (c >= s->capture_count && c >= re_count_captures(s))) {
                    if (!s->is_utf16) {
                        /* Annex B.1.4: accept legacy octal */
                        p = q;
                        if (*p <= '7') {
                            c = 0;
                            if (*p <= '3')
                                c = *p++ - '0';
                            if (*p >= '0' && *p <= '7') {
                                c = (c << 3) + *p++ - '0';
                                if (*p >= '0' && *p <= '7') {
                                    c = (c << 3) + *p++ - '0';
                                }
                            }
                        } else {
                            c = *p++;
                        }
                        goto normal_char;
                    }
                    return re_parse_error(s, "back reference out of range in regular expression");
                }
            emit_back_reference:
                last_atom_start = s->byte_code.size;
                last_capture_count = s->capture_count;
                re_emit_op_u8(s, REOP_back_reference + is_backward_dir, c);
            }
            break;
        default:
            goto parse_class_atom;
        }
        break;
    case '[':
        last_atom_start = s->byte_code.size;
        last_capture_count = s->capture_count;
        if (is_backward_dir)
            re_emit_op(s, REOP_prev);
        if (re_parse_char_class(s, &p))
            return -1;
        if (is_backward_dir)
            re_emit_op(s, REOP_prev);
        break;
    case ']':
    case '}':
        if (s->is_utf16)
            return re_parse_error(s, "syntax error");
        goto parse_class_atom;
    default:
    parse_class_atom:
        c = get_class_atom(s, cr, &p, FALSE);
        if ((int)c < 0)
            return -1;
    normal_char:
        last_atom_start = s->byte_code.size;
        last_capture_count = s->capture_count;
        if (is_backward_dir)
            re_emit_op(s, REOP_prev);
        if (c >= CLASS_RANGE_BASE) {
            int ret;
            /* Note: canonicalization is not needed */
            ret = re_emit_range(s, cr);
            cr_free(cr);
            if (ret)
                return -1;
        } else {
            if (s->ignore_case)
                c = lre_canonicalize(c, s->is_utf16);
            if (c <= 0xffff)
                re_emit_op_u16(s, REOP_char, c);
            else
                re_emit_op_u32(s, REOP_char32, c);
        }
        if (is_backward_dir)
            re_emit_op(s, REOP_prev);
        break;
    }

    /* quantifier */
    if (last_atom_start >= 0) {
        c = *p;
        switch(c) {
        case '*':
            p++;
            quant_min = 0;
            quant_max = INT32_MAX;
            goto quantifier;
        case '+':
            p++;
            quant_min = 1;
            quant_max = INT32_MAX;
            goto quantifier;
        case '?':
            p++;
            quant_min = 0;
            quant_max = 1;
            goto quantifier;
        case '{':
            {
                const uint8_t *p1 = p;
                /* As an extension (see ES6 annex B), we accept '{' not
                   followed by digits as a normal atom */
                if (!is_digit(p[1])) {
                    if (s->is_utf16)
                        goto invalid_quant_count;
                    break;
                }
                p++;
                quant_min = parse_digits(&p, TRUE);
                quant_max = quant_min;
                if (*p == ',') {
                    p++;
                    if (is_digit(*p)) {
                        quant_max = parse_digits(&p, TRUE);
                        if (quant_max < quant_min) {
                        invalid_quant_count:
                            return re_parse_error(s, "invalid repetition count");
                        }
                    } else {
                        quant_max = INT32_MAX; /* infinity */
                    }
                }
                if (*p != '}' && !s->is_utf16) {
                    /* Annex B: normal atom if invalid '{' syntax */
                    p = p1;
                    break;
                }
                if (re_parse_expect(s, &p, '}'))
                    return -1;
            }
        quantifier:
            greedy = TRUE;
            if (*p == '?') {
                p++;
                greedy = FALSE;
            }
            if (last_atom_start < 0) {
                return re_parse_error(s, "nothing to repeat");
            }
            if (greedy) {
                int len, pos;
                
                if (quant_max > 0) {
                    /* specific optimization for simple quantifiers */
                    if (dbuf_error(&s->byte_code))
                        goto out_of_memory;
                    len = re_is_simple_quantifier(s->byte_code.buf + last_atom_start,
                                                 s->byte_code.size - last_atom_start);
                    if (len > 0) {
                        re_emit_op(s, REOP_match);
                        
                        if (dbuf_insert(&s->byte_code, last_atom_start, 17))
                            goto out_of_memory;
                        pos = last_atom_start;
                        s->byte_code.buf[pos++] = REOP_simple_greedy_quant;
                        put_u32(&s->byte_code.buf[pos],
                                s->byte_code.size - last_atom_start - 17);
                        pos += 4;
                        put_u32(&s->byte_code.buf[pos], quant_min);
                        pos += 4;
                        put_u32(&s->byte_code.buf[pos], quant_max);
                        pos += 4;
                        put_u32(&s->byte_code.buf[pos], len);
                        pos += 4;
                        goto done;
                    }
                }
                
                if (dbuf_error(&s->byte_code))
                    goto out_of_memory;
                add_zero_advance_check = (re_check_advance(s->byte_code.buf + last_atom_start,
                                                           s->byte_code.size - last_atom_start) == 0);
            } else {
                add_zero_advance_check = FALSE;
            }
            
            {
                int len, pos;
                len = s->byte_code.size - last_atom_start;
                if (quant_min == 0) {
                    /* need to reset the capture in case the atom is
                       not executed */
                    if (last_capture_count != s->capture_count) {
                        if (dbuf_insert(&s->byte_code, last_atom_start, 3))
                            goto out_of_memory;
                        s->byte_code.buf[last_atom_start++] = REOP_save_reset;
                        s->byte_code.buf[last_atom_start++] = last_capture_count;
                        s->byte_code.buf[last_atom_start++] = s->capture_count - 1;
                    }
                    if (quant_max == 0) {
                        s->byte_code.size = last_atom_start;
                    } else if (quant_max == 1) {
                        if (dbuf_insert(&s->byte_code, last_atom_start, 5))
                            goto out_of_memory;
                        s->byte_code.buf[last_atom_start] = REOP_split_goto_first +
                            greedy;
                        put_u32(s->byte_code.buf + last_atom_start + 1, len);
                    } else if (quant_max == INT32_MAX) {
                        if (dbuf_insert(&s->byte_code, last_atom_start, 5 + add_zero_advance_check))
                            goto out_of_memory;
                        s->byte_code.buf[last_atom_start] = REOP_split_goto_first +
                            greedy;
                        put_u32(s->byte_code.buf + last_atom_start + 1,
                                len + 5 + add_zero_advance_check);
                        if (add_zero_advance_check) {
                            /* avoid infinite loop by stoping the
                               recursion if no advance was made in the
                               atom (only works if the atom has no
                               side effect) */
                            s->byte_code.buf[last_atom_start + 1 + 4] = REOP_push_char_pos;
                            re_emit_goto(s, REOP_bne_char_pos, last_atom_start); 
                        } else {
                            re_emit_goto(s, REOP_goto, last_atom_start);
                        }
                    } else {
                        if (dbuf_insert(&s->byte_code, last_atom_start, 10))
                            goto out_of_memory;
                        pos = last_atom_start;
                        s->byte_code.buf[pos++] = REOP_push_i32;
                        put_u32(s->byte_code.buf + pos, quant_max);
                        pos += 4;
                        s->byte_code.buf[pos++] = REOP_split_goto_first + greedy;
                        put_u32(s->byte_code.buf + pos, len + 5);
                        re_emit_goto(s, REOP_loop, last_atom_start + 5);
                        re_emit_op(s, REOP_drop);
                    }
                } else if (quant_min == 1 && quant_max == INT32_MAX &&
                           !add_zero_advance_check) {
                    re_emit_goto(s, REOP_split_next_first - greedy,
                                 last_atom_start);
                } else {
                    if (quant_min == 1) {
                        /* nothing to add */
                    } else {
                        if (dbuf_insert(&s->byte_code, last_atom_start, 5))
                            goto out_of_memory;
                        s->byte_code.buf[last_atom_start] = REOP_push_i32;
                        put_u32(s->byte_code.buf + last_atom_start + 1,
                                quant_min);
                        last_atom_start += 5;
                        re_emit_goto(s, REOP_loop, last_atom_start);
                        re_emit_op(s, REOP_drop);
                    }
                    if (quant_max == INT32_MAX) {
                        pos = s->byte_code.size;
                        re_emit_op_u32(s, REOP_split_goto_first + greedy,
                                       len + 5 + add_zero_advance_check);
                        if (add_zero_advance_check)
                            re_emit_op(s, REOP_push_char_pos);
                        /* copy the atom */
                        dbuf_put_self(&s->byte_code, last_atom_start, len);
                        if (add_zero_advance_check)
                            re_emit_goto(s, REOP_bne_char_pos, pos);
                        else
                            re_emit_goto(s, REOP_goto, pos);
                    } else if (quant_max > quant_min) {
                        re_emit_op_u32(s, REOP_push_i32, quant_max - quant_min);
                        pos = s->byte_code.size;
                        re_emit_op_u32(s, REOP_split_goto_first + greedy, len + 5);
                        /* copy the atom */
                        dbuf_put_self(&s->byte_code, last_atom_start, len);
                        
                        re_emit_goto(s, REOP_loop, pos);
                        re_emit_op(s, REOP_drop);
                    }
                }
                last_atom_start = -1;
            }
            break;
        default:
            break;
        }
    }
 done:
    s->buf_ptr = p;
    return 0;
 out_of_memory:
    return re_parse_out_of_memory(s);
}

static int re_parse_alternative(REParseState *s, BOOL is_backward_dir)
{
    const uint8_t *p;
    int ret;
    size_t start, term_start, end, term_size;

    start = s->byte_code.size;
    for(;;) {
        p = s->buf_ptr;
        if (p >= s->buf_end)
            break;
        if (*p == '|' || *p == ')')
            break;
        term_start = s->byte_code.size;
        ret = re_parse_term(s, is_backward_dir);
        if (ret)
            return ret;
        if (is_backward_dir) {
            /* reverse the order of the terms (XXX: inefficient, but
               speed is not really critical here) */
            end = s->byte_code.size;
            term_size = end - term_start;
            if (dbuf_realloc(&s->byte_code, end + term_size))
                return -1;
            memmove(s->byte_code.buf + start + term_size,
                    s->byte_code.buf + start,
                    end - start);
            memcpy(s->byte_code.buf + start, s->byte_code.buf + end,
                   term_size);
        }
    }
    return 0;
}
    
static int re_parse_disjunction(REParseState *s, BOOL is_backward_dir)
{
    int start, len, pos;

    if (lre_check_stack_overflow(s->opaque, 0))
        return re_parse_error(s, "stack overflow");
    
    start = s->byte_code.size;
    if (re_parse_alternative(s, is_backward_dir))
        return -1;
    while (*s->buf_ptr == '|') {
        s->buf_ptr++;

        len = s->byte_code.size - start;

        /* insert a split before the first alternative */
        if (dbuf_insert(&s->byte_code, start, 5)) {
            return re_parse_out_of_memory(s);
        }
        s->byte_code.buf[start] = REOP_split_next_first;
        put_u32(s->byte_code.buf + start + 1, len + 5);

        pos = re_emit_op_u32(s, REOP_goto, 0);

        if (re_parse_alternative(s, is_backward_dir))
            return -1;
        
        /* patch the goto */
        len = s->byte_code.size - (pos + 4);
        put_u32(s->byte_code.buf + pos, len);
    }
    return 0;
}

/* the control flow is recursive so the analysis can be linear */
static int compute_stack_size(const uint8_t *bc_buf, int bc_buf_len)
{
    int stack_size, stack_size_max, pos, opcode, len;
    uint32_t val;
    
    stack_size = 0;
    stack_size_max = 0;
    bc_buf += RE_HEADER_LEN;
    bc_buf_len -= RE_HEADER_LEN;
    pos = 0;
    while (pos < bc_buf_len) {
        opcode = bc_buf[pos];
        len = reopcode_info[opcode].size;
        assert(opcode < REOP_COUNT);
        assert((pos + len) <= bc_buf_len);
        switch(opcode) {
        case REOP_push_i32:
        case REOP_push_char_pos:
            stack_size++;
            if (stack_size > stack_size_max) {
                if (stack_size > STACK_SIZE_MAX)
                    return -1;
                stack_size_max = stack_size;
            }
            break;
        case REOP_drop:
        case REOP_bne_char_pos:
            assert(stack_size > 0);
            stack_size--;
            break;
        case REOP_range:
            val = get_u16(bc_buf + pos + 1);
            len += val * 4;
            break;
        case REOP_range32:
            val = get_u16(bc_buf + pos + 1);
            len += val * 8;
            break;
        }
        pos += len;
    }
    return stack_size_max;
}

/* 'buf' must be a zero terminated UTF-8 string of length buf_len.
   Return NULL if error and allocate an error message in *perror_msg,
   otherwise the compiled bytecode and its length in plen.
*/
uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
                     const char *buf, size_t buf_len, int re_flags,
                     void *opaque)
{
    REParseState s_s, *s = &s_s;
    int stack_size;
    BOOL is_sticky;
    
    memset(s, 0, sizeof(*s));
    s->opaque = opaque;
    s->buf_ptr = (const uint8_t *)buf;
    s->buf_end = s->buf_ptr + buf_len;
    s->buf_start = s->buf_ptr;
    s->re_flags = re_flags;
    s->is_utf16 = ((re_flags & LRE_FLAG_UTF16) != 0);
    is_sticky = ((re_flags & LRE_FLAG_STICKY) != 0);
    s->ignore_case = ((re_flags & LRE_FLAG_IGNORECASE) != 0);
    s->dotall = ((re_flags & LRE_FLAG_DOTALL) != 0);
    s->capture_count = 1;
    s->total_capture_count = -1;
    s->has_named_captures = -1;
    
    dbuf_init2(&s->byte_code, opaque, lre_realloc);
    dbuf_init2(&s->group_names, opaque, lre_realloc);

    dbuf_putc(&s->byte_code, re_flags); /* first element is the flags */
    dbuf_putc(&s->byte_code, 0); /* second element is the number of captures */
    dbuf_putc(&s->byte_code, 0); /* stack size */
    dbuf_put_u32(&s->byte_code, 0); /* bytecode length */
    
    if (!is_sticky) {
        /* iterate thru all positions (about the same as .*?( ... ) )
           .  We do it without an explicit loop so that lock step
           thread execution will be possible in an optimized
           implementation */
        re_emit_op_u32(s, REOP_split_goto_first, 1 + 5);
        re_emit_op(s, REOP_any);
        re_emit_op_u32(s, REOP_goto, -(5 + 1 + 5));
    }
    re_emit_op_u8(s, REOP_save_start, 0);

    if (re_parse_disjunction(s, FALSE)) {
    error:
        dbuf_free(&s->byte_code);
        dbuf_free(&s->group_names);
        pstrcpy(error_msg, error_msg_size, s->u.error_msg);
        *plen = 0;
        return NULL;
    }

    re_emit_op_u8(s, REOP_save_end, 0);
    
    re_emit_op(s, REOP_match);

    if (*s->buf_ptr != '\0') {
        re_parse_error(s, "extraneous characters at the end");
        goto error;
    }

    if (dbuf_error(&s->byte_code)) {
        re_parse_out_of_memory(s);
        goto error;
    }
    
    stack_size = compute_stack_size(s->byte_code.buf, s->byte_code.size);
    if (stack_size < 0) {
        re_parse_error(s, "too many imbricated quantifiers");
        goto error;
    }
    
    s->byte_code.buf[RE_HEADER_CAPTURE_COUNT] = s->capture_count;
    s->byte_code.buf[RE_HEADER_STACK_SIZE] = stack_size;
    put_u32(s->byte_code.buf + 3, s->byte_code.size - RE_HEADER_LEN);

    /* add the named groups if needed */
    if (s->group_names.size > (s->capture_count - 1)) {
        dbuf_put(&s->byte_code, s->group_names.buf, s->group_names.size);
        s->byte_code.buf[RE_HEADER_FLAGS] |= LRE_FLAG_NAMED_GROUPS;
    }
    dbuf_free(&s->group_names);
    
#ifdef DUMP_REOP
    lre_dump_bytecode(s->byte_code.buf, s->byte_code.size);
#endif
    
    error_msg[0] = '\0';
    *plen = s->byte_code.size;
    return s->byte_code.buf;
}

static BOOL is_line_terminator(uint32_t c)
{
    return (c == '\n' || c == '\r' || c == CP_LS || c == CP_PS);
}

static BOOL is_word_char(uint32_t c)
{
    return ((c >= '0' && c <= '9') ||
            (c >= 'a' && c <= 'z') ||
            (c >= 'A' && c <= 'Z') ||
            (c == '_'));
}

#define GET_CHAR(c, cptr, cbuf_end)                                     \
    do {                                                                \
        if (cbuf_type == 0) {                                           \
            c = *cptr++;                                                \
        } else {                                                        \
            uint32_t __c1;                                              \
            c = *(uint16_t *)cptr;                                      \
            cptr += 2;                                                  \
            if (c >= 0xd800 && c < 0xdc00 &&                            \
                cbuf_type == 2 && cptr < cbuf_end) {                    \
                __c1 = *(uint16_t *)cptr;                               \
                if (__c1 >= 0xdc00 && __c1 < 0xe000) {                  \
                    c = (((c & 0x3ff) << 10) | (__c1 & 0x3ff)) + 0x10000; \
                    cptr += 2;                                          \
                }                                                       \
            }                                                           \
        }                                                               \
    } while (0)

#define PEEK_CHAR(c, cptr, cbuf_end)             \
    do {                                         \
        if (cbuf_type == 0) {                    \
            c = cptr[0];                         \
        } else {                                 \
            uint32_t __c1;                                              \
            c = ((uint16_t *)cptr)[0];                                  \
            if (c >= 0xd800 && c < 0xdc00 &&                            \
                cbuf_type == 2 && (cptr + 2) < cbuf_end) {              \
                __c1 = ((uint16_t *)cptr)[1];                           \
                if (__c1 >= 0xdc00 && __c1 < 0xe000) {                  \
                    c = (((c & 0x3ff) << 10) | (__c1 & 0x3ff)) + 0x10000; \
                }                                                       \
            }                                                           \
        }                                        \
    } while (0)

#define PEEK_PREV_CHAR(c, cptr, cbuf_start)                 \
    do {                                         \
        if (cbuf_type == 0) {                    \
            c = cptr[-1];                        \
        } else {                                 \
            uint32_t __c1;                                              \
            c = ((uint16_t *)cptr)[-1];                                 \
            if (c >= 0xdc00 && c < 0xe000 &&                            \
                cbuf_type == 2 && (cptr - 4) >= cbuf_start) {              \
                __c1 = ((uint16_t *)cptr)[-2];                          \
                if (__c1 >= 0xd800 && __c1 < 0xdc00 ) {                 \
                    c = (((__c1 & 0x3ff) << 10) | (c & 0x3ff)) + 0x10000; \
                }                                                       \
            }                                                           \
        }                                                               \
    } while (0)

#define GET_PREV_CHAR(c, cptr, cbuf_start)       \
    do {                                         \
        if (cbuf_type == 0) {                    \
            cptr--;                              \
            c = cptr[0];                         \
        } else {                                 \
            uint32_t __c1;                                              \
            cptr -= 2;                                                  \
            c = ((uint16_t *)cptr)[0];                                 \
            if (c >= 0xdc00 && c < 0xe000 &&                            \
                cbuf_type == 2 && cptr > cbuf_start) {                  \
                __c1 = ((uint16_t *)cptr)[-1];                          \
                if (__c1 >= 0xd800 && __c1 < 0xdc00 ) {                 \
                    cptr -= 2;                                          \
                    c = (((__c1 & 0x3ff) << 10) | (c & 0x3ff)) + 0x10000; \
                }                                                       \
            }                                                           \
        }                                                               \
    } while (0)

#define PREV_CHAR(cptr, cbuf_start)       \
    do {                                  \
        if (cbuf_type == 0) {             \
            cptr--;                       \
        } else {                          \
            cptr -= 2;                          \
            if (cbuf_type == 2) {                                       \
                c = ((uint16_t *)cptr)[0];                              \
                if (c >= 0xdc00 && c < 0xe000 && cptr > cbuf_start) {   \
                    c = ((uint16_t *)cptr)[-1];                         \
                    if (c >= 0xd800 && c < 0xdc00)                      \
                        cptr -= 2;                                      \
                }                                                       \
            }                                                           \
        }                                                               \
    } while (0)

typedef uintptr_t StackInt;

typedef enum {
    RE_EXEC_STATE_SPLIT,
    RE_EXEC_STATE_LOOKAHEAD,
    RE_EXEC_STATE_NEGATIVE_LOOKAHEAD,
    RE_EXEC_STATE_GREEDY_QUANT,
} REExecStateEnum;

typedef struct REExecState {
    REExecStateEnum type : 8;
    uint8_t stack_len;
    size_t count; /* only used for RE_EXEC_STATE_GREEDY_QUANT */
    const uint8_t *cptr;
    const uint8_t *pc;
    void *buf[0];
} REExecState;

typedef struct {
    const uint8_t *cbuf;
    const uint8_t *cbuf_end;
    /* 0 = 8 bit chars, 1 = 16 bit chars, 2 = 16 bit chars, UTF-16 */
    int cbuf_type; 
    int capture_count;
    int stack_size_max;
    BOOL multi_line;
    BOOL ignore_case;
    BOOL is_utf16;
    void *opaque; /* used for stack overflow check */

    size_t state_size;
    uint8_t *state_stack;
    size_t state_stack_size;
    size_t state_stack_len;
} REExecContext;

static int push_state(REExecContext *s,
                      uint8_t **capture,
                      StackInt *stack, size_t stack_len,
                      const uint8_t *pc, const uint8_t *cptr,
                      REExecStateEnum type, size_t count)
{
    REExecState *rs;
    uint8_t *new_stack;
    size_t new_size, i, n;
    StackInt *stack_buf;

    if (unlikely((s->state_stack_len + 1) > s->state_stack_size)) {
        /* reallocate the stack */
        new_size = s->state_stack_size * 3 / 2;
        if (new_size < 8)
            new_size = 8;
        new_stack = lre_realloc(s->opaque, s->state_stack, new_size * s->state_size);
        if (!new_stack)
            return -1;
        s->state_stack_size = new_size;
        s->state_stack = new_stack;
    }
    rs = (REExecState *)(s->state_stack + s->state_stack_len * s->state_size);
    s->state_stack_len++;
    rs->type = type;
    rs->count = count;
    rs->stack_len = stack_len;
    rs->cptr = cptr;
    rs->pc = pc;
    n = 2 * s->capture_count;
    for(i = 0; i < n; i++)
        rs->buf[i] = capture[i];
    stack_buf = (StackInt *)(rs->buf + n);
    for(i = 0; i < stack_len; i++)
        stack_buf[i] = stack[i];
    return 0;
}

/* return 1 if match, 0 if not match or -1 if error. */
static intptr_t lre_exec_backtrack(REExecContext *s, uint8_t **capture,
                                   StackInt *stack, int stack_len,
                                   const uint8_t *pc, const uint8_t *cptr,
                                   BOOL no_recurse)
{
    int opcode, ret;
    int cbuf_type;
    uint32_t val, c;
    const uint8_t *cbuf_end;
    
    cbuf_type = s->cbuf_type;
    cbuf_end = s->cbuf_end;

    for(;;) {
        //        printf("top=%p: pc=%d\n", th_list.top, (int)(pc - (bc_buf + RE_HEADER_LEN)));
        opcode = *pc++;
        switch(opcode) {
        case REOP_match:
            {
                REExecState *rs;
                if (no_recurse)
                    return (intptr_t)cptr;
                ret = 1;
                goto recurse;
            no_match:
                if (no_recurse)
                    return 0;
                ret = 0;
            recurse:
                for(;;) {
                    if (s->state_stack_len == 0)
                        return ret;
                    rs = (REExecState *)(s->state_stack +
                                         (s->state_stack_len - 1) * s->state_size);
                    if (rs->type == RE_EXEC_STATE_SPLIT) {
                        if (!ret) {
                        pop_state:
                            memcpy(capture, rs->buf,
                                   sizeof(capture[0]) * 2 * s->capture_count);
                        pop_state1:
                            pc = rs->pc;
                            cptr = rs->cptr;
                            stack_len = rs->stack_len;
                            memcpy(stack, rs->buf + 2 * s->capture_count,
                                   stack_len * sizeof(stack[0]));
                            s->state_stack_len--;
                            break;
                        }
                    } else if (rs->type == RE_EXEC_STATE_GREEDY_QUANT) {
                        if (!ret) {
                            uint32_t char_count, i;
                            memcpy(capture, rs->buf,
                                   sizeof(capture[0]) * 2 * s->capture_count);
                            stack_len = rs->stack_len;
                            memcpy(stack, rs->buf + 2 * s->capture_count,
                                   stack_len * sizeof(stack[0]));
                            pc = rs->pc;
                            cptr = rs->cptr;
                            /* go backward */
                            char_count = get_u32(pc + 12);
                            for(i = 0; i < char_count; i++) {
                                PREV_CHAR(cptr, s->cbuf);
                            }
                            pc = (pc + 16) + (int)get_u32(pc);
                            rs->cptr = cptr;
                            rs->count--;
                            if (rs->count == 0) {
                                s->state_stack_len--;
                            }
                            break;
                        }
                    } else {
                        ret = ((rs->type == RE_EXEC_STATE_LOOKAHEAD && ret) ||
                               (rs->type == RE_EXEC_STATE_NEGATIVE_LOOKAHEAD && !ret));
                        if (ret) {
                            /* keep the capture in case of positive lookahead */
                            if (rs->type == RE_EXEC_STATE_LOOKAHEAD)
                                goto pop_state1;
                            else
                                goto pop_state;
                        }
                    }
                    s->state_stack_len--;
                }
            }
            break;
        case REOP_char32:
            val = get_u32(pc);
            pc += 4;
            goto test_char;
        case REOP_char:
            val = get_u16(pc);
            pc += 2;
        test_char:
            if (cptr >= cbuf_end)
                goto no_match;
            GET_CHAR(c, cptr, cbuf_end);
            if (s->ignore_case) {
                c = lre_canonicalize(c, s->is_utf16);
            }
            if (val != c)
                goto no_match;
            break;
        case REOP_split_goto_first:
        case REOP_split_next_first:
            {
                const uint8_t *pc1;
                
                val = get_u32(pc);
                pc += 4;
                if (opcode == REOP_split_next_first) {
                    pc1 = pc + (int)val;
                } else {
                    pc1 = pc;
                    pc = pc + (int)val;
                }
                ret = push_state(s, capture, stack, stack_len,
                                 pc1, cptr, RE_EXEC_STATE_SPLIT, 0);
                if (ret < 0)
                    return -1;
                break;
            }
        case REOP_lookahead:
        case REOP_negative_lookahead:
            val = get_u32(pc);
            pc += 4;
            ret = push_state(s, capture, stack, stack_len,
                             pc + (int)val, cptr,
                             RE_EXEC_STATE_LOOKAHEAD + opcode - REOP_lookahead,
                             0);
            if (ret < 0)
                return -1;
            break;
            
        case REOP_goto:
            val = get_u32(pc);
            pc += 4 + (int)val;
            break;
        case REOP_line_start:
            if (cptr == s->cbuf)
                break;
            if (!s->multi_line)
                goto no_match;
            PEEK_PREV_CHAR(c, cptr, s->cbuf);
            if (!is_line_terminator(c))
                goto no_match;
            break;
        case REOP_line_end:
            if (cptr == cbuf_end)
                break;
            if (!s->multi_line)
                goto no_match;
            PEEK_CHAR(c, cptr, cbuf_end);
            if (!is_line_terminator(c))
                goto no_match;
            break;
        case REOP_dot:
            if (cptr == cbuf_end)
                goto no_match;
            GET_CHAR(c, cptr, cbuf_end);
            if (is_line_terminator(c))
                goto no_match;
            break;
        case REOP_any:
            if (cptr == cbuf_end)
                goto no_match;
            GET_CHAR(c, cptr, cbuf_end);
            break;
        case REOP_save_start:
        case REOP_save_end:
            val = *pc++;
            assert(val < s->capture_count);
            capture[2 * val + opcode - REOP_save_start] = (uint8_t *)cptr;
            break;
        case REOP_save_reset:
            {
                uint32_t val2;
                val = pc[0];
                val2 = pc[1];
                pc += 2;
                assert(val2 < s->capture_count);
                while (val <= val2) {
                    capture[2 * val] = NULL;
                    capture[2 * val + 1] = NULL;
                    val++;
                }
            }
            break;
        case REOP_push_i32:
            val = get_u32(pc);
            pc += 4;
            stack[stack_len++] = val;
            break;
        case REOP_drop:
            stack_len--;
            break;
        case REOP_loop:
            val = get_u32(pc);
            pc += 4;
            if (--stack[stack_len - 1] != 0) {
                pc += (int)val;
            }
            break;
        case REOP_push_char_pos:
            stack[stack_len++] = (uintptr_t)cptr;
            break;
        case REOP_bne_char_pos:
            val = get_u32(pc);
            pc += 4;
            if (stack[--stack_len] != (uintptr_t)cptr)
                pc += (int)val;
            break;
        case REOP_word_boundary:
        case REOP_not_word_boundary:
            {
                BOOL v1, v2;
                /* char before */
                if (cptr == s->cbuf) {
                    v1 = FALSE;
                } else {
                    PEEK_PREV_CHAR(c, cptr, s->cbuf);
                    v1 = is_word_char(c);
                }
                /* current char */
                if (cptr >= cbuf_end) {
                    v2 = FALSE;
                } else {
                    PEEK_CHAR(c, cptr, cbuf_end);
                    v2 = is_word_char(c);
                }
                if (v1 ^ v2 ^ (REOP_not_word_boundary - opcode))
                    goto no_match;
            }
            break;
        case REOP_back_reference:
        case REOP_backward_back_reference:
            {
                const uint8_t *cptr1, *cptr1_end, *cptr1_start;
                uint32_t c1, c2;
                
                val = *pc++;
                if (val >= s->capture_count)
                    goto no_match;
                cptr1_start = capture[2 * val];
                cptr1_end = capture[2 * val + 1];
                if (!cptr1_start || !cptr1_end)
                    break;
                if (opcode == REOP_back_reference) {
                    cptr1 = cptr1_start;
                    while (cptr1 < cptr1_end) {
                        if (cptr >= cbuf_end)
                            goto no_match;
                        GET_CHAR(c1, cptr1, cptr1_end);
                        GET_CHAR(c2, cptr, cbuf_end);
                        if (s->ignore_case) {
                            c1 = lre_canonicalize(c1, s->is_utf16);
                            c2 = lre_canonicalize(c2, s->is_utf16);
                        }
                        if (c1 != c2)
                            goto no_match;
                    }
                } else {
                    cptr1 = cptr1_end;
                    while (cptr1 > cptr1_start) {
                        if (cptr == s->cbuf)
                            goto no_match;
                        GET_PREV_CHAR(c1, cptr1, cptr1_start);
                        GET_PREV_CHAR(c2, cptr, s->cbuf);
                        if (s->ignore_case) {
                            c1 = lre_canonicalize(c1, s->is_utf16);
                            c2 = lre_canonicalize(c2, s->is_utf16);
                        }
                        if (c1 != c2)
                            goto no_match;
                    }
                }
            }
            break;
        case REOP_range:
            {
                int n;
                uint32_t low, high, idx_min, idx_max, idx;
                
                n = get_u16(pc); /* n must be >= 1 */
                pc += 2;
                if (cptr >= cbuf_end)
                    goto no_match;
                GET_CHAR(c, cptr, cbuf_end);
                if (s->ignore_case) {
                    c = lre_canonicalize(c, s->is_utf16);
                }
                idx_min = 0;
                low = get_u16(pc + 0 * 4);
                if (c < low)
                    goto no_match;
                idx_max = n - 1;
                high = get_u16(pc + idx_max * 4 + 2);
                /* 0xffff in for last value means +infinity */
                if (unlikely(c >= 0xffff) && high == 0xffff)
                    goto range_match;
                if (c > high)
                    goto no_match;
                while (idx_min <= idx_max) {
                    idx = (idx_min + idx_max) / 2;
                    low = get_u16(pc + idx * 4);
                    high = get_u16(pc + idx * 4 + 2);
                    if (c < low)
                        idx_max = idx - 1;
                    else if (c > high)
                        idx_min = idx + 1;
                    else
                        goto range_match;
                }
                goto no_match;
            range_match:
                pc += 4 * n;
            }
            break;
        case REOP_range32:
            {
                int n;
                uint32_t low, high, idx_min, idx_max, idx;
                
                n = get_u16(pc); /* n must be >= 1 */
                pc += 2;
                if (cptr >= cbuf_end)
                    goto no_match;
                GET_CHAR(c, cptr, cbuf_end);
                if (s->ignore_case) {
                    c = lre_canonicalize(c, s->is_utf16);
                }
                idx_min = 0;
                low = get_u32(pc + 0 * 8);
                if (c < low)
                    goto no_match;
                idx_max = n - 1;
                high = get_u32(pc + idx_max * 8 + 4);
                if (c > high)
                    goto no_match;
                while (idx_min <= idx_max) {
                    idx = (idx_min + idx_max) / 2;
                    low = get_u32(pc + idx * 8);
                    high = get_u32(pc + idx * 8 + 4);
                    if (c < low)
                        idx_max = idx - 1;
                    else if (c > high)
                        idx_min = idx + 1;
                    else
                        goto range32_match;
                }
                goto no_match;
            range32_match:
                pc += 8 * n;
            }
            break;
        case REOP_prev:
            /* go to the previous char */
            if (cptr == s->cbuf)
                goto no_match;
            PREV_CHAR(cptr, s->cbuf);
            break;
        case REOP_simple_greedy_quant:
            {
                uint32_t next_pos, quant_min, quant_max;
                size_t q;
                intptr_t res;
                const uint8_t *pc1;
                
                next_pos = get_u32(pc);
                quant_min = get_u32(pc + 4);
                quant_max = get_u32(pc + 8);
                pc += 16;
                pc1 = pc;
                pc += (int)next_pos;
                
                q = 0;
                for(;;) {
                    res = lre_exec_backtrack(s, capture, stack, stack_len,
                                             pc1, cptr, TRUE);
                    if (res == -1)
                        return res;
                    if (!res)
                        break;
                    cptr = (uint8_t *)res;
                    q++;
                    if (q >= quant_max && quant_max != INT32_MAX)
                        break;
                }
                if (q < quant_min)
                    goto no_match;
                if (q > quant_min) {
                    /* will examine all matches down to quant_min */
                    ret = push_state(s, capture, stack, stack_len,
                                     pc1 - 16, cptr,
                                     RE_EXEC_STATE_GREEDY_QUANT,
                                     q - quant_min);
                    if (ret < 0)
                        return -1;
                }
            }
            break;
        default:
            abort();
        }
    }
}

/* Return 1 if match, 0 if not match or -1 if error. cindex is the
   starting position of the match and must be such as 0 <= cindex <=
   clen. */
int lre_exec(uint8_t **capture,
             const uint8_t *bc_buf, const uint8_t *cbuf, int cindex, int clen,
             int cbuf_type, void *opaque)
{
    REExecContext s_s, *s = &s_s;
    int re_flags, i, alloca_size, ret;
    StackInt *stack_buf;
    
    re_flags = bc_buf[RE_HEADER_FLAGS];
    s->multi_line = (re_flags & LRE_FLAG_MULTILINE) != 0;
    s->ignore_case = (re_flags & LRE_FLAG_IGNORECASE) != 0;
    s->is_utf16 = (re_flags & LRE_FLAG_UTF16) != 0;
    s->capture_count = bc_buf[RE_HEADER_CAPTURE_COUNT];
    s->stack_size_max = bc_buf[RE_HEADER_STACK_SIZE];
    s->cbuf = cbuf;
    s->cbuf_end = cbuf + (clen << cbuf_type);
    s->cbuf_type = cbuf_type;
    if (s->cbuf_type == 1 && s->is_utf16)
        s->cbuf_type = 2;
    s->opaque = opaque;

    s->state_size = sizeof(REExecState) +
        s->capture_count * sizeof(capture[0]) * 2 +
        s->stack_size_max * sizeof(stack_buf[0]);
    s->state_stack = NULL;
    s->state_stack_len = 0;
    s->state_stack_size = 0;
    
    for(i = 0; i < s->capture_count * 2; i++)
        capture[i] = NULL;
    alloca_size = s->stack_size_max * sizeof(stack_buf[0]);
    stack_buf = alloca(alloca_size);
    ret = lre_exec_backtrack(s, capture, stack_buf, 0, bc_buf + RE_HEADER_LEN,
                             cbuf + (cindex << cbuf_type), FALSE);
    lre_realloc(s->opaque, s->state_stack, 0);
    return ret;
}

int lre_get_capture_count(const uint8_t *bc_buf)
{
    return bc_buf[RE_HEADER_CAPTURE_COUNT];
}

int lre_get_flags(const uint8_t *bc_buf)
{
    return bc_buf[RE_HEADER_FLAGS];
}

/* Return NULL if no group names. Otherwise, return a pointer to
   'capture_count - 1' zero terminated UTF-8 strings. */
const char *lre_get_groupnames(const uint8_t *bc_buf)
{
    uint32_t re_bytecode_len;
    if ((lre_get_flags(bc_buf) & LRE_FLAG_NAMED_GROUPS) == 0)
        return NULL;
    re_bytecode_len = get_u32(bc_buf + 3);
    return (const char *)(bc_buf + 7 + re_bytecode_len);
}

#ifdef TEST

BOOL lre_check_stack_overflow(void *opaque, size_t alloca_size)
{
    return FALSE;
}

void *lre_realloc(void *opaque, void *ptr, size_t size)
{
    return realloc(ptr, size);
}

int main(int argc, char **argv)
{
    int len, ret, i;
    uint8_t *bc;
    char error_msg[64];
    uint8_t *capture[CAPTURE_COUNT_MAX * 2];
    const char *input;
    int input_len, capture_count;
    
    if (argc < 3) {
        printf("usage: %s regexp input\n", argv[0]);
        exit(1);
    }
    bc = lre_compile(&len, error_msg, sizeof(error_msg), argv[1],
                     strlen(argv[1]), 0, NULL);
    if (!bc) {
        fprintf(stderr, "error: %s\n", error_msg);
        exit(1);
    }

    input = argv[2];
    input_len = strlen(input);
    
    ret = lre_exec(capture, bc, (uint8_t *)input, 0, input_len, 0, NULL);
    printf("ret=%d\n", ret);
    if (ret == 1) {
        capture_count = lre_get_capture_count(bc);
        for(i = 0; i < 2 * capture_count; i++) {
            uint8_t *ptr;
            ptr = capture[i];
            printf("%d: ", i);
            if (!ptr)
                printf("<nil>");
            else
                printf("%u", (int)(ptr - (uint8_t *)input));
            printf("\n");
        }
    }
    return 0;
}
#endif

'''
'''--- libregexp.h ---
/*
 * Regular Expression Engine
 * 
 * Copyright (c) 2017-2018 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef LIBREGEXP_H
#define LIBREGEXP_H

#include <stddef.h>

#include "libunicode.h"

#define LRE_BOOL  int       /* for documentation purposes */

#define LRE_FLAG_GLOBAL     (1 << 0)
#define LRE_FLAG_IGNORECASE (1 << 1)
#define LRE_FLAG_MULTILINE  (1 << 2)
#define LRE_FLAG_DOTALL     (1 << 3)
#define LRE_FLAG_UTF16      (1 << 4)
#define LRE_FLAG_STICKY     (1 << 5)

#define LRE_FLAG_NAMED_GROUPS (1 << 7) /* named groups are present in the regexp */

uint8_t *lre_compile(int *plen, char *error_msg, int error_msg_size,
                     const char *buf, size_t buf_len, int re_flags,
                     void *opaque);
int lre_get_capture_count(const uint8_t *bc_buf);
int lre_get_flags(const uint8_t *bc_buf);
const char *lre_get_groupnames(const uint8_t *bc_buf);
int lre_exec(uint8_t **capture,
             const uint8_t *bc_buf, const uint8_t *cbuf, int cindex, int clen,
             int cbuf_type, void *opaque);

int lre_parse_escape(const uint8_t **pp, int allow_utf16);
LRE_BOOL lre_is_space(int c);

/* must be provided by the user */
LRE_BOOL lre_check_stack_overflow(void *opaque, size_t alloca_size); 
void *lre_realloc(void *opaque, void *ptr, size_t size);

/* JS identifier test */
extern uint32_t const lre_id_start_table_ascii[4];
extern uint32_t const lre_id_continue_table_ascii[4];

static inline int lre_js_is_ident_first(int c)
{
    if ((uint32_t)c < 128) {
        return (lre_id_start_table_ascii[c >> 5] >> (c & 31)) & 1;
    } else {
#ifdef CONFIG_ALL_UNICODE
        return lre_is_id_start(c);
#else
        return !lre_is_space(c);
#endif
    }
}

static inline int lre_js_is_ident_next(int c)
{
    if ((uint32_t)c < 128) {
        return (lre_id_continue_table_ascii[c >> 5] >> (c & 31)) & 1;
    } else {
        /* ZWNJ and ZWJ are accepted in identifiers */
#ifdef CONFIG_ALL_UNICODE
        return lre_is_id_continue(c) || c == 0x200C || c == 0x200D;
#else
        return !lre_is_space(c) || c == 0x200C || c == 0x200D;
#endif
    }
}

#undef LRE_BOOL

#endif /* LIBREGEXP_H */

'''
'''--- libunicode-table.h ---
/* Compressed unicode tables */
/* Automatically generated file - do not edit */

#include <stdint.h>

static const uint32_t case_conv_table1[370] = {
    0x00209a30, 0x00309a00, 0x005a8173, 0x00601730,
    0x006c0730, 0x006f81b3, 0x00701700, 0x007c0700,
    0x007f8100, 0x00803040, 0x009801c3, 0x00988190,
    0x00990640, 0x009c9040, 0x00a481b4, 0x00a52e40,
    0x00bc0130, 0x00bc8640, 0x00bf8170, 0x00c00100,
    0x00c08130, 0x00c10440, 0x00c30130, 0x00c38240,
    0x00c48230, 0x00c58240, 0x00c70130, 0x00c78130,
    0x00c80130, 0x00c88240, 0x00c98130, 0x00ca0130,
    0x00ca8100, 0x00cb0130, 0x00cb8130, 0x00cc0240,
    0x00cd0100, 0x00ce0130, 0x00ce8130, 0x00cf0100,
    0x00cf8130, 0x00d00640, 0x00d30130, 0x00d38240,
    0x00d48130, 0x00d60240, 0x00d70130, 0x00d78240,
    0x00d88230, 0x00d98440, 0x00db8130, 0x00dc0240,
    0x00de0240, 0x00df8100, 0x00e20350, 0x00e38350,
    0x00e50350, 0x00e69040, 0x00ee8100, 0x00ef1240,
    0x00f801b4, 0x00f88350, 0x00fa0240, 0x00fb0130,
    0x00fb8130, 0x00fc2840, 0x01100130, 0x01111240,
    0x011d0131, 0x011d8240, 0x011e8130, 0x011f0131,
    0x011f8201, 0x01208240, 0x01218130, 0x01220130,
    0x01228130, 0x01230a40, 0x01280101, 0x01288101,
    0x01290101, 0x01298100, 0x012a0100, 0x012b0200,
    0x012c8100, 0x012d8100, 0x012e0101, 0x01300100,
    0x01308101, 0x01318100, 0x01328101, 0x01330101,
    0x01340100, 0x01348100, 0x01350101, 0x01358101,
    0x01360101, 0x01378100, 0x01388101, 0x01390100,
    0x013a8100, 0x013e8101, 0x01400100, 0x01410101,
    0x01418100, 0x01438101, 0x01440100, 0x01448100,
    0x01450200, 0x01460100, 0x01490100, 0x014e8101,
    0x014f0101, 0x01a28173, 0x01b80440, 0x01bb0240,
    0x01bd8300, 0x01bf8130, 0x01c30130, 0x01c40330,
    0x01c60130, 0x01c70230, 0x01c801d0, 0x01c89130,
    0x01d18930, 0x01d60100, 0x01d68300, 0x01d801d3,
    0x01d89100, 0x01e10173, 0x01e18900, 0x01e60100,
    0x01e68200, 0x01e78130, 0x01e80173, 0x01e88173,
    0x01ea8173, 0x01eb0173, 0x01eb8100, 0x01ec1840,
    0x01f80173, 0x01f88173, 0x01f90100, 0x01f98100,
    0x01fa01a0, 0x01fa8173, 0x01fb8240, 0x01fc8130,
    0x01fd0240, 0x01fe8330, 0x02001030, 0x02082030,
    0x02182000, 0x02281000, 0x02302240, 0x02453640,
    0x02600130, 0x02608e40, 0x02678100, 0x02686040,
    0x0298a630, 0x02b0a600, 0x02c381b5, 0x08502631,
    0x08638131, 0x08668131, 0x08682b00, 0x087e8300,
    0x09d05011, 0x09f80610, 0x09fc0620, 0x0e400174,
    0x0e408174, 0x0e410174, 0x0e418174, 0x0e420174,
    0x0e428174, 0x0e430174, 0x0e438180, 0x0e440180,
    0x0e482b30, 0x0e5e8330, 0x0ebc8101, 0x0ebe8101,
    0x0ec70101, 0x0f007e40, 0x0f3f1840, 0x0f4b01b5,
    0x0f4b81b6, 0x0f4c01b6, 0x0f4c81b6, 0x0f4d01b7,
    0x0f4d8180, 0x0f4f0130, 0x0f506040, 0x0f800800,
    0x0f840830, 0x0f880600, 0x0f8c0630, 0x0f900800,
    0x0f940830, 0x0f980800, 0x0f9c0830, 0x0fa00600,
    0x0fa40630, 0x0fa801b0, 0x0fa88100, 0x0fa901d3,
    0x0fa98100, 0x0faa01d3, 0x0faa8100, 0x0fab01d3,
    0x0fab8100, 0x0fac8130, 0x0fad8130, 0x0fae8130,
    0x0faf8130, 0x0fb00800, 0x0fb40830, 0x0fb80200,
    0x0fb90400, 0x0fbb0200, 0x0fbc0201, 0x0fbd0201,
    0x0fbe0201, 0x0fc008b7, 0x0fc40867, 0x0fc808b8,
    0x0fcc0868, 0x0fd008b8, 0x0fd40868, 0x0fd80200,
    0x0fd901b9, 0x0fd981b1, 0x0fda01b9, 0x0fdb01b1,
    0x0fdb81d7, 0x0fdc0230, 0x0fdd0230, 0x0fde0161,
    0x0fdf0173, 0x0fe101b9, 0x0fe181b2, 0x0fe201ba,
    0x0fe301b2, 0x0fe381d8, 0x0fe40430, 0x0fe60162,
    0x0fe80200, 0x0fe901d0, 0x0fe981d0, 0x0feb01b0,
    0x0feb81d0, 0x0fec0230, 0x0fed0230, 0x0ff00201,
    0x0ff101d3, 0x0ff181d3, 0x0ff201ba, 0x0ff28101,
    0x0ff301b0, 0x0ff381d3, 0x0ff40230, 0x0ff50230,
    0x0ff60131, 0x0ff901ba, 0x0ff981b2, 0x0ffa01bb,
    0x0ffb01b2, 0x0ffb81d9, 0x0ffc0230, 0x0ffd0230,
    0x0ffe0162, 0x109301a0, 0x109501a0, 0x109581a0,
    0x10990131, 0x10a70101, 0x10b01031, 0x10b81001,
    0x10c18240, 0x125b1a31, 0x12681a01, 0x16003031,
    0x16183001, 0x16300240, 0x16310130, 0x16318130,
    0x16320130, 0x16328100, 0x16330100, 0x16338640,
    0x16368130, 0x16370130, 0x16378130, 0x16380130,
    0x16390240, 0x163a8240, 0x163f0230, 0x16406440,
    0x16758440, 0x16790240, 0x16802600, 0x16938100,
    0x16968100, 0x53202e40, 0x53401c40, 0x53910e40,
    0x53993e40, 0x53bc8440, 0x53be8130, 0x53bf0a40,
    0x53c58240, 0x53c68130, 0x53c80440, 0x53ca0101,
    0x53cb1440, 0x53d50130, 0x53d58130, 0x53d60130,
    0x53d68130, 0x53d70130, 0x53d80130, 0x53d88130,
    0x53d90130, 0x53d98131, 0x53da1040, 0x53e20131,
    0x53e28130, 0x53e30130, 0x53e38440, 0x53e80240,
    0x53eb0440, 0x53fa8240, 0x55a98101, 0x55b85020,
    0x7d8001b2, 0x7d8081b2, 0x7d8101b2, 0x7d8181da,
    0x7d8201da, 0x7d8281b3, 0x7d8301b3, 0x7d8981bb,
    0x7d8a01bb, 0x7d8a81bb, 0x7d8b01bc, 0x7d8b81bb,
    0x7f909a31, 0x7fa09a01, 0x82002831, 0x82142801,
    0x82582431, 0x826c2401, 0x82b80b31, 0x82be0f31,
    0x82c60731, 0x82ca0231, 0x82cb8b01, 0x82d18f01,
    0x82d98701, 0x82dd8201, 0x86403331, 0x86603301,
    0x8c502031, 0x8c602001, 0xb7202031, 0xb7302001,
    0xf4802231, 0xf4912201,
};

static const uint8_t case_conv_table2[370] = {
    0x01, 0x00, 0x9c, 0x06, 0x07, 0x4d, 0x03, 0x04,
    0x10, 0x00, 0x8f, 0x0b, 0x00, 0x00, 0x11, 0x00,
    0x08, 0x00, 0x53, 0x4a, 0x51, 0x00, 0x52, 0x00,
    0x53, 0x00, 0x3a, 0x54, 0x55, 0x00, 0x57, 0x59,
    0x3f, 0x5d, 0x5c, 0x00, 0x46, 0x61, 0x63, 0x42,
    0x64, 0x00, 0x66, 0x00, 0x68, 0x00, 0x6a, 0x00,
    0x6c, 0x00, 0x6e, 0x00, 0x00, 0x40, 0x00, 0x00,
    0x00, 0x00, 0x1a, 0x00, 0x93, 0x00, 0x00, 0x20,
    0x35, 0x00, 0x27, 0x00, 0x21, 0x00, 0x24, 0x22,
    0x2a, 0x00, 0x13, 0x6b, 0x6d, 0x00, 0x26, 0x24,
    0x27, 0x14, 0x16, 0x18, 0x1b, 0x1c, 0x3e, 0x1e,
    0x3f, 0x1f, 0x39, 0x3d, 0x22, 0x21, 0x41, 0x1e,
    0x40, 0x25, 0x25, 0x26, 0x28, 0x20, 0x2a, 0x48,
    0x2c, 0x43, 0x2e, 0x4b, 0x30, 0x4c, 0x32, 0x44,
    0x42, 0x99, 0x00, 0x00, 0x95, 0x8f, 0x7d, 0x7e,
    0x83, 0x84, 0x12, 0x80, 0x82, 0x76, 0x77, 0x12,
    0x7b, 0xa3, 0x7c, 0x78, 0x79, 0x8a, 0x92, 0x98,
    0xa6, 0xa0, 0x85, 0x00, 0x9a, 0xa1, 0x93, 0x75,
    0x33, 0x95, 0x00, 0x8e, 0x00, 0x74, 0x99, 0x98,
    0x97, 0x96, 0x00, 0x00, 0x9e, 0x00, 0x9c, 0x00,
    0xa1, 0xa0, 0x15, 0x2e, 0x2f, 0x30, 0xb4, 0xb5,
    0x4f, 0xaa, 0xa9, 0x12, 0x14, 0x1e, 0x21, 0x22,
    0x22, 0x2a, 0x34, 0x35, 0xa6, 0xa7, 0x36, 0x1f,
    0x49, 0x00, 0x00, 0x97, 0x01, 0x5a, 0xda, 0x1d,
    0x36, 0x05, 0x00, 0xc4, 0xc3, 0xc6, 0xc5, 0xc8,
    0xc7, 0xca, 0xc9, 0xcc, 0xcb, 0xc4, 0xd5, 0x45,
    0xd6, 0x42, 0xd7, 0x46, 0xd8, 0xce, 0xd0, 0xd2,
    0xd4, 0xda, 0xd9, 0xee, 0xf6, 0xfe, 0x0e, 0x07,
    0x0f, 0x80, 0x9f, 0x00, 0x21, 0x80, 0xa3, 0xed,
    0x00, 0xc0, 0x40, 0xc6, 0x60, 0xe7, 0xdb, 0xe6,
    0x99, 0xc0, 0x00, 0x00, 0x06, 0x60, 0xdc, 0x29,
    0xfd, 0x15, 0x12, 0x06, 0x16, 0xf8, 0xdd, 0x06,
    0x15, 0x12, 0x84, 0x08, 0xc6, 0x16, 0xff, 0xdf,
    0x03, 0xc0, 0x40, 0x00, 0x46, 0x60, 0xde, 0xe0,
    0x6d, 0x37, 0x38, 0x39, 0x15, 0x14, 0x17, 0x16,
    0x00, 0x1a, 0x19, 0x1c, 0x1b, 0x00, 0x5f, 0xb7,
    0x65, 0x44, 0x47, 0x00, 0x4f, 0x62, 0x4e, 0x50,
    0x00, 0x00, 0x48, 0x00, 0x00, 0x00, 0xa3, 0xa4,
    0xa5, 0x00, 0x00, 0x00, 0x00, 0x00, 0xb6, 0x00,
    0x00, 0x5a, 0x00, 0x47, 0x00, 0x5b, 0x56, 0x58,
    0x60, 0x5e, 0x70, 0x69, 0x6f, 0x4e, 0x00, 0x3b,
    0x67, 0xb8, 0x00, 0x00, 0x00, 0x00, 0x45, 0xa8,
    0x8a, 0x8b, 0x8c, 0xab, 0xac, 0x58, 0x58, 0xaf,
    0x94, 0xb0, 0x6f, 0xb2, 0x5d, 0x5c, 0x5f, 0x5e,
    0x61, 0x60, 0x66, 0x67, 0x68, 0x69, 0x62, 0x63,
    0x64, 0x65, 0x6b, 0x6a, 0x6d, 0x6c, 0x6f, 0x6e,
    0x71, 0x70,
};

static const uint16_t case_conv_ext[58] = {
    0x0399, 0x0308, 0x0301, 0x03a5, 0x0313, 0x0300, 0x0342, 0x0391,
    0x0397, 0x03a9, 0x0046, 0x0049, 0x004c, 0x0053, 0x0069, 0x0307,
    0x02bc, 0x004e, 0x004a, 0x030c, 0x0535, 0x0552, 0x0048, 0x0331,
    0x0054, 0x0057, 0x030a, 0x0059, 0x0041, 0x02be, 0x1f08, 0x1f80,
    0x1f28, 0x1f90, 0x1f68, 0x1fa0, 0x1fba, 0x0386, 0x1fb3, 0x1fca,
    0x0389, 0x1fc3, 0x03a1, 0x1ffa, 0x038f, 0x1ff3, 0x0544, 0x0546,
    0x053b, 0x054e, 0x053d, 0x03b8, 0x0462, 0xa64a, 0x1e60, 0x03c9,
    0x006b, 0x00e5,
};

static const uint8_t unicode_prop_Cased1_table[188] = {
    0x40, 0xa9, 0x80, 0x8e, 0x80, 0xfc, 0x80, 0xd3,
    0x80, 0x8c, 0x80, 0x8d, 0x81, 0x8d, 0x02, 0x80,
    0xe1, 0x80, 0x91, 0x85, 0x9a, 0x01, 0x00, 0x01,
    0x11, 0x00, 0x01, 0x04, 0x08, 0x01, 0x08, 0x30,
    0x08, 0x01, 0x15, 0x20, 0x00, 0x39, 0x99, 0x31,
    0x9d, 0x84, 0x40, 0x94, 0x80, 0xd6, 0x82, 0xa6,
    0x80, 0x41, 0x62, 0x80, 0xa6, 0x80, 0x57, 0x76,
    0xf8, 0x02, 0x80, 0x8f, 0x80, 0xb0, 0x40, 0xdb,
    0x08, 0x80, 0x41, 0xd0, 0x80, 0x8c, 0x80, 0x8f,
    0x8c, 0xe4, 0x03, 0x01, 0x89, 0x00, 0x14, 0x28,
    0x10, 0x11, 0x02, 0x01, 0x18, 0x0b, 0x24, 0x4b,
    0x26, 0x01, 0x01, 0x86, 0xe5, 0x80, 0x60, 0x79,
    0xb6, 0x81, 0x40, 0x91, 0x81, 0xbd, 0x88, 0x94,
    0x05, 0x80, 0x98, 0x80, 0xa2, 0x00, 0x80, 0xa1,
    0x82, 0x43, 0x34, 0xa2, 0x06, 0x80, 0x8c, 0x60,
    0x5c, 0x16, 0x01, 0x10, 0xa9, 0x80, 0x88, 0x60,
    0xcc, 0x44, 0xd4, 0x80, 0xc6, 0x01, 0x08, 0x09,
    0x0b, 0x80, 0x8b, 0x00, 0x06, 0x80, 0xc0, 0x03,
    0x0f, 0x06, 0x80, 0x9b, 0x03, 0x04, 0x00, 0x16,
    0x80, 0x41, 0x53, 0x81, 0x98, 0x80, 0x98, 0x80,
    0x9e, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,
    0x9e, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x07,
    0x47, 0x33, 0x89, 0x80, 0x93, 0x52, 0x10, 0x99,
    0x85, 0x99, 0x85, 0x99,
};

static const uint8_t unicode_prop_Cased1_index[18] = {
    0xb9, 0x02, 0xe0, 0xa0, 0x1e, 0x40, 0x9e, 0xa6,
    0x40, 0x55, 0xd4, 0x61, 0xfb, 0xd6, 0x21, 0x8a,
    0xf1, 0x01,
};

static const uint8_t unicode_prop_Case_Ignorable_table[720] = {
    0xa6, 0x05, 0x80, 0x8a, 0x80, 0xa2, 0x00, 0x80,
    0xc6, 0x03, 0x00, 0x03, 0x01, 0x81, 0x41, 0xf6,
    0x40, 0xbf, 0x19, 0x18, 0x88, 0x08, 0x80, 0x40,
    0xfa, 0x86, 0x40, 0xce, 0x04, 0x80, 0xb0, 0xac,
    0x00, 0x01, 0x01, 0x00, 0xab, 0x80, 0x8a, 0x85,
    0x89, 0x8a, 0x00, 0xa2, 0x80, 0x89, 0x94, 0x8f,
    0x80, 0xe4, 0x38, 0x89, 0x03, 0xa0, 0x00, 0x80,
    0x9d, 0x9a, 0xda, 0x8a, 0xb9, 0x8a, 0x18, 0x08,
    0x97, 0x97, 0xaa, 0x82, 0xab, 0x06, 0x0d, 0x87,
    0xa8, 0xb9, 0xb6, 0x00, 0x03, 0x3b, 0x02, 0x86,
    0x89, 0x81, 0x8c, 0x80, 0x8e, 0x80, 0xb9, 0x03,
    0x1f, 0x80, 0x93, 0x81, 0x99, 0x01, 0x81, 0xb8,
    0x03, 0x0b, 0x09, 0x12, 0x80, 0x9d, 0x0a, 0x80,
    0x8a, 0x81, 0xb8, 0x03, 0x20, 0x0b, 0x80, 0x93,
    0x81, 0x95, 0x28, 0x80, 0xb9, 0x01, 0x00, 0x1f,
    0x06, 0x81, 0x8a, 0x81, 0x9d, 0x80, 0xbc, 0x80,
    0x8b, 0x80, 0xb1, 0x02, 0x80, 0xb6, 0x00, 0x14,
    0x10, 0x1e, 0x81, 0x8a, 0x81, 0x9c, 0x80, 0xb9,
    0x01, 0x05, 0x04, 0x81, 0x93, 0x81, 0x9b, 0x81,
    0xb8, 0x0b, 0x1f, 0x80, 0x93, 0x81, 0x9c, 0x80,
    0xc7, 0x06, 0x10, 0x80, 0xd9, 0x01, 0x86, 0x8a,
    0x88, 0xe1, 0x01, 0x88, 0x88, 0x00, 0x85, 0xc9,
    0x81, 0x9a, 0x00, 0x00, 0x80, 0xb6, 0x8d, 0x04,
    0x01, 0x84, 0x8a, 0x80, 0xa3, 0x88, 0x80, 0xe5,
    0x18, 0x28, 0x09, 0x81, 0x98, 0x0b, 0x82, 0x8f,
    0x83, 0x8c, 0x01, 0x0d, 0x80, 0x8e, 0x80, 0xdd,
    0x80, 0x42, 0x5f, 0x82, 0x43, 0xb1, 0x82, 0x9c,
    0x81, 0x9d, 0x81, 0x9d, 0x81, 0xbf, 0x08, 0x37,
    0x01, 0x8a, 0x10, 0x20, 0xac, 0x84, 0xb2, 0x80,
    0xc0, 0x81, 0xa1, 0x80, 0xf5, 0x13, 0x81, 0x88,
    0x05, 0x82, 0x40, 0xda, 0x09, 0x80, 0xb9, 0x00,
    0x30, 0x00, 0x01, 0x3d, 0x89, 0x08, 0xa6, 0x07,
    0x9e, 0xb0, 0x83, 0xaf, 0x00, 0x20, 0x04, 0x80,
    0xa7, 0x88, 0x8b, 0x81, 0x9f, 0x19, 0x08, 0x82,
    0xb7, 0x00, 0x0a, 0x00, 0x82, 0xb9, 0x39, 0x81,
    0xbf, 0x85, 0xd1, 0x10, 0x8c, 0x06, 0x18, 0x28,
    0x11, 0xb1, 0xbe, 0x8c, 0x80, 0xa1, 0xe4, 0x41,
    0xbc, 0x00, 0x82, 0x8a, 0x82, 0x8c, 0x82, 0x8c,
    0x82, 0x8c, 0x81, 0x8b, 0x27, 0x81, 0x89, 0x01,
    0x01, 0x84, 0xb0, 0x20, 0x89, 0x00, 0x8c, 0x80,
    0x8f, 0x8c, 0xb2, 0xa0, 0x4b, 0x8a, 0x81, 0xf0,
    0x82, 0xfc, 0x80, 0x8e, 0x80, 0xdf, 0x9f, 0xae,
    0x80, 0x41, 0xd4, 0x80, 0xa3, 0x1a, 0x24, 0x80,
    0xdc, 0x85, 0xdc, 0x82, 0x60, 0x6f, 0x15, 0x80,
    0x44, 0xe1, 0x85, 0x41, 0x0d, 0x80, 0xe1, 0x18,
    0x89, 0x00, 0x9b, 0x83, 0xcf, 0x81, 0x8d, 0xa1,
    0xcd, 0x80, 0x96, 0x82, 0xe6, 0x12, 0x0f, 0x02,
    0x03, 0x80, 0x98, 0x0c, 0x80, 0x40, 0x96, 0x81,
    0x99, 0x91, 0x8c, 0x80, 0xa5, 0x87, 0x98, 0x8a,
    0xad, 0x82, 0xaf, 0x01, 0x19, 0x81, 0x90, 0x80,
    0x94, 0x81, 0xc1, 0x29, 0x09, 0x81, 0x8b, 0x07,
    0x80, 0xa2, 0x80, 0x8a, 0x80, 0xb2, 0x00, 0x11,
    0x0c, 0x08, 0x80, 0x9a, 0x80, 0x8d, 0x0c, 0x08,
    0x80, 0xe3, 0x84, 0x88, 0x82, 0xf8, 0x01, 0x03,
    0x80, 0x60, 0x4f, 0x2f, 0x80, 0x40, 0x92, 0x90,
    0x42, 0x3c, 0x8f, 0x10, 0x8b, 0x8f, 0xa1, 0x01,
    0x80, 0x40, 0xa8, 0x06, 0x05, 0x80, 0x8a, 0x80,
    0xa2, 0x00, 0x80, 0xae, 0x80, 0xac, 0x81, 0xc2,
    0x80, 0x94, 0x82, 0x42, 0x00, 0x80, 0x40, 0xe1,
    0x80, 0x40, 0x94, 0x84, 0x44, 0x04, 0x28, 0xa9,
    0x80, 0x88, 0x42, 0x45, 0x10, 0x0c, 0x83, 0xa7,
    0x13, 0x80, 0x40, 0xa4, 0x81, 0x42, 0x3c, 0x83,
    0x41, 0x82, 0x81, 0x40, 0x98, 0x8a, 0xb0, 0x83,
    0xfa, 0x80, 0xb5, 0x8e, 0xa8, 0x01, 0x81, 0x89,
    0x82, 0xb0, 0x19, 0x09, 0x03, 0x80, 0x89, 0x80,
    0xb1, 0x82, 0xa3, 0x20, 0x87, 0xbd, 0x80, 0x8b,
    0x81, 0xb3, 0x88, 0x89, 0x19, 0x80, 0xde, 0x11,
    0x00, 0x0d, 0x80, 0x40, 0x9f, 0x02, 0x87, 0x94,
    0x81, 0xb8, 0x0a, 0x80, 0xa4, 0x32, 0x84, 0x40,
    0xc2, 0x39, 0x10, 0x80, 0x96, 0x80, 0xd3, 0x28,
    0x03, 0x08, 0x81, 0x40, 0xed, 0x1d, 0x08, 0x81,
    0x9a, 0x81, 0xd4, 0x39, 0x00, 0x81, 0xe9, 0x00,
    0x01, 0x28, 0x80, 0xe4, 0x11, 0x18, 0x84, 0x41,
    0x02, 0x88, 0x01, 0x40, 0xff, 0x08, 0x03, 0x80,
    0x40, 0x8f, 0x19, 0x0b, 0x80, 0x9f, 0x89, 0xa7,
    0x29, 0x1f, 0x80, 0x88, 0x29, 0x82, 0xad, 0x8c,
    0x01, 0x41, 0x95, 0x30, 0x28, 0x80, 0xd1, 0x95,
    0x0e, 0x01, 0x01, 0xf9, 0x2a, 0x00, 0x08, 0x30,
    0x80, 0xc7, 0x0a, 0x00, 0x80, 0x41, 0x5a, 0x81,
    0x55, 0x3a, 0x88, 0x60, 0x36, 0xb6, 0x84, 0xba,
    0x86, 0x88, 0x83, 0x44, 0x0a, 0x80, 0xbe, 0x90,
    0xbf, 0x08, 0x81, 0x60, 0x40, 0x0a, 0x18, 0x30,
    0x81, 0x4c, 0x9d, 0x08, 0x83, 0x52, 0x5b, 0xad,
    0x81, 0x96, 0x42, 0x1f, 0x82, 0x88, 0x8f, 0x0e,
    0x9d, 0x83, 0x40, 0x93, 0x82, 0x47, 0xba, 0xb6,
    0x83, 0xb1, 0x38, 0x8d, 0x80, 0x95, 0x20, 0x8e,
    0x45, 0x4f, 0x30, 0x90, 0x0e, 0x01, 0x04, 0x41,
    0x04, 0x8d, 0x41, 0x6f, 0x80, 0xbc, 0x83, 0x45,
    0xdf, 0x86, 0xec, 0x87, 0x4a, 0xae, 0x84, 0x6c,
    0x0c, 0x00, 0x80, 0x9d, 0xdf, 0xff, 0x40, 0xef,
};

static const uint8_t unicode_prop_Case_Ignorable_index[69] = {
    0xbe, 0x05, 0x00, 0xfe, 0x07, 0x00, 0x52, 0x0a,
    0xa0, 0xc1, 0x0b, 0x00, 0x82, 0x0d, 0x00, 0x3f,
    0x10, 0x80, 0xd4, 0x17, 0x40, 0xcf, 0x1a, 0x20,
    0xf5, 0x1c, 0x00, 0x80, 0x20, 0x00, 0x16, 0xa0,
    0x00, 0xc6, 0xa8, 0x00, 0xc2, 0xaa, 0x60, 0x56,
    0xfe, 0x20, 0xb1, 0x07, 0x01, 0x82, 0x10, 0x21,
    0x02, 0x13, 0x21, 0xb8, 0x16, 0x61, 0x97, 0x1a,
    0x01, 0x37, 0x6b, 0x21, 0x8c, 0xd1, 0x01, 0xd7,
    0xe8, 0x41, 0xf0, 0x01, 0x0e,
};

static const uint8_t unicode_prop_ID_Start_table[1079] = {
    0xc0, 0x99, 0x85, 0x99, 0xae, 0x80, 0x89, 0x03,
    0x04, 0x96, 0x80, 0x9e, 0x80, 0x41, 0xc9, 0x83,
    0x8b, 0x8d, 0x26, 0x00, 0x80, 0x40, 0x80, 0x20,
    0x09, 0x18, 0x05, 0x00, 0x10, 0x00, 0x93, 0x80,
    0xd2, 0x80, 0x40, 0x8a, 0x87, 0x40, 0xa5, 0x80,
    0xa5, 0x08, 0x85, 0xa8, 0xc6, 0x9a, 0x1b, 0xac,
    0xaa, 0xa2, 0x08, 0xe2, 0x00, 0x8e, 0x0e, 0x81,
    0x89, 0x11, 0x80, 0x8f, 0x00, 0x9d, 0x9c, 0xd8,
    0x8a, 0x80, 0x97, 0xa0, 0x88, 0x0b, 0x04, 0x95,
    0x18, 0x88, 0x02, 0x80, 0x96, 0x98, 0x86, 0x8a,
    0x84, 0x97, 0x05, 0x90, 0xa9, 0xb9, 0xb5, 0x10,
    0x91, 0x06, 0x89, 0x8e, 0x8f, 0x1f, 0x09, 0x81,
    0x95, 0x06, 0x00, 0x13, 0x10, 0x8f, 0x80, 0x8c,
    0x08, 0x82, 0x8d, 0x81, 0x89, 0x07, 0x2b, 0x09,
    0x95, 0x06, 0x01, 0x01, 0x01, 0x9e, 0x18, 0x80,
    0x92, 0x82, 0x8f, 0x88, 0x02, 0x80, 0x95, 0x06,
    0x01, 0x04, 0x10, 0x91, 0x80, 0x8e, 0x81, 0x96,
    0x80, 0x8a, 0x39, 0x09, 0x95, 0x06, 0x01, 0x04,
    0x10, 0x9d, 0x08, 0x82, 0x8e, 0x80, 0x90, 0x00,
    0x2a, 0x10, 0x1a, 0x08, 0x00, 0x0a, 0x0a, 0x12,
    0x8b, 0x95, 0x80, 0xb3, 0x38, 0x10, 0x96, 0x80,
    0x8f, 0x10, 0x99, 0x11, 0x01, 0x81, 0x9d, 0x03,
    0x38, 0x10, 0x96, 0x80, 0x89, 0x04, 0x10, 0x9e,
    0x08, 0x81, 0x8e, 0x81, 0x90, 0x88, 0x02, 0x80,
    0xa8, 0x08, 0x8f, 0x04, 0x17, 0x82, 0x97, 0x2c,
    0x91, 0x82, 0x97, 0x80, 0x88, 0x00, 0x0e, 0xb9,
    0xaf, 0x01, 0x8b, 0x86, 0xb9, 0x08, 0x00, 0x20,
    0x97, 0x00, 0x80, 0x89, 0x01, 0x88, 0x01, 0x20,
    0x80, 0x94, 0x83, 0x9f, 0x80, 0xbe, 0x38, 0xa3,
    0x9a, 0x84, 0xf2, 0xaa, 0x93, 0x80, 0x8f, 0x2b,
    0x1a, 0x02, 0x0e, 0x13, 0x8c, 0x8b, 0x80, 0x90,
    0xa5, 0x00, 0x20, 0x81, 0xaa, 0x80, 0x41, 0x4c,
    0x03, 0x0e, 0x00, 0x03, 0x81, 0xa8, 0x03, 0x81,
    0xa0, 0x03, 0x0e, 0x00, 0x03, 0x81, 0x8e, 0x80,
    0xb8, 0x03, 0x81, 0xc2, 0xa4, 0x8f, 0x8f, 0xd5,
    0x0d, 0x82, 0x42, 0x6b, 0x81, 0x90, 0x80, 0x99,
    0x84, 0xca, 0x82, 0x8a, 0x86, 0x91, 0x8c, 0x92,
    0x8d, 0x91, 0x8d, 0x8c, 0x02, 0x8e, 0xb3, 0xa2,
    0x03, 0x80, 0xc2, 0xd8, 0x86, 0xa8, 0x00, 0x84,
    0xc5, 0x89, 0x9e, 0xb0, 0x9d, 0x0c, 0x8a, 0xab,
    0x83, 0x99, 0xb5, 0x96, 0x88, 0xb4, 0xd1, 0x80,
    0xdc, 0xae, 0x90, 0x87, 0xb5, 0x9d, 0x8c, 0x81,
    0x89, 0xab, 0x99, 0xa3, 0xa8, 0x82, 0x89, 0xa3,
    0x81, 0x88, 0x86, 0xaa, 0x0a, 0xa8, 0x18, 0x28,
    0x0a, 0x04, 0x40, 0xbf, 0xbf, 0x41, 0x15, 0x0d,
    0x81, 0xa5, 0x0d, 0x0f, 0x00, 0x00, 0x00, 0x80,
    0x9e, 0x81, 0xb4, 0x06, 0x00, 0x12, 0x06, 0x13,
    0x0d, 0x83, 0x8c, 0x22, 0x06, 0xf3, 0x80, 0x8c,
    0x80, 0x8f, 0x8c, 0xe4, 0x03, 0x01, 0x89, 0x00,
    0x0d, 0x28, 0x00, 0x00, 0x80, 0x8f, 0x0b, 0x24,
    0x18, 0x90, 0xa8, 0x4a, 0x76, 0x40, 0xe4, 0x2b,
    0x11, 0x8b, 0xa5, 0x00, 0x20, 0x81, 0xb7, 0x30,
    0x8f, 0x96, 0x88, 0x30, 0x30, 0x30, 0x30, 0x30,
    0x30, 0x30, 0x86, 0x42, 0x25, 0x82, 0x98, 0x88,
    0x34, 0x0c, 0x83, 0xd5, 0x1c, 0x80, 0xd9, 0x03,
    0x84, 0xaa, 0x80, 0xdd, 0x90, 0x9f, 0xaf, 0x8f,
    0x41, 0xff, 0x59, 0xbf, 0xbf, 0x60, 0x56, 0x8c,
    0xc2, 0xad, 0x81, 0x41, 0x0c, 0x82, 0x8f, 0x89,
    0x81, 0x93, 0xae, 0x8f, 0x9e, 0x81, 0xcf, 0xa6,
    0x88, 0x81, 0xe6, 0x81, 0xbf, 0x21, 0x00, 0x04,
    0x97, 0x8f, 0x02, 0x03, 0x80, 0x96, 0x9c, 0xb3,
    0x8d, 0xb1, 0xbd, 0x2a, 0x00, 0x81, 0x8a, 0x9b,
    0x89, 0x96, 0x98, 0x9c, 0x86, 0xae, 0x9b, 0x80,
    0x8f, 0x20, 0x89, 0x89, 0x20, 0xa8, 0x96, 0x10,
    0x87, 0x93, 0x96, 0x10, 0x82, 0xb1, 0x00, 0x11,
    0x0c, 0x08, 0x00, 0x97, 0x11, 0x8a, 0x32, 0x8b,
    0x29, 0x29, 0x85, 0x88, 0x30, 0x30, 0xaa, 0x80,
    0x8d, 0x85, 0xf2, 0x9c, 0x60, 0x2b, 0xa3, 0x8b,
    0x96, 0x83, 0xb0, 0x60, 0x21, 0x03, 0x41, 0x6d,
    0x81, 0xe9, 0xa5, 0x86, 0x8b, 0x24, 0x00, 0x89,
    0x80, 0x8c, 0x04, 0x00, 0x01, 0x01, 0x80, 0xeb,
    0xa0, 0x41, 0x6a, 0x91, 0xbf, 0x81, 0xb5, 0xa7,
    0x8b, 0xf3, 0x20, 0x40, 0x86, 0xa3, 0x99, 0x85,
    0x99, 0x8a, 0xd8, 0x15, 0x0d, 0x0d, 0x0a, 0xa2,
    0x8b, 0x80, 0x99, 0x80, 0x92, 0x01, 0x80, 0x8e,
    0x81, 0x8d, 0xa1, 0xfa, 0xc4, 0xb4, 0x41, 0x0a,
    0x9c, 0x82, 0xb0, 0xae, 0x9f, 0x8c, 0x9d, 0x84,
    0xa5, 0x89, 0x9d, 0x81, 0xa3, 0x1f, 0x04, 0xa9,
    0x40, 0x9d, 0x91, 0xa3, 0x83, 0xa3, 0x83, 0xa7,
    0x87, 0xb3, 0x8b, 0x8a, 0x80, 0x8e, 0x06, 0x01,
    0x80, 0x8a, 0x80, 0x8e, 0x06, 0x01, 0xc2, 0x41,
    0x36, 0x88, 0x95, 0x89, 0x87, 0x97, 0x28, 0xa9,
    0x80, 0x88, 0xc4, 0x29, 0x00, 0xab, 0x01, 0x10,
    0x81, 0x96, 0x89, 0x96, 0x88, 0x9e, 0xc0, 0x92,
    0x01, 0x89, 0x95, 0x89, 0x99, 0xc5, 0xb7, 0x29,
    0xbf, 0x80, 0x8e, 0x18, 0x10, 0x9c, 0xa9, 0x9c,
    0x82, 0x9c, 0xa2, 0x38, 0x9b, 0x9a, 0xb5, 0x89,
    0x95, 0x89, 0x92, 0x8c, 0x91, 0xed, 0xc8, 0xb6,
    0xb2, 0x8c, 0xb2, 0x8c, 0xa3, 0x41, 0x5b, 0xa9,
    0x29, 0xcd, 0x9c, 0x89, 0x07, 0x95, 0xa9, 0x91,
    0xad, 0x94, 0x9a, 0x96, 0x8b, 0xb4, 0xb8, 0x09,
    0x80, 0x8c, 0xac, 0x9f, 0x98, 0x99, 0xa3, 0x9c,
    0x01, 0x07, 0xa2, 0x10, 0x8b, 0xaf, 0x8d, 0x83,
    0x94, 0x00, 0x80, 0xa2, 0x91, 0x80, 0x98, 0xd3,
    0x30, 0x00, 0x18, 0x8e, 0x80, 0x89, 0x86, 0xae,
    0xa5, 0x39, 0x09, 0x95, 0x06, 0x01, 0x04, 0x10,
    0x91, 0x80, 0x8b, 0x84, 0x40, 0x9d, 0xb4, 0x91,
    0x83, 0x93, 0x82, 0x9d, 0xaf, 0x93, 0x08, 0x80,
    0x40, 0xb7, 0xae, 0xa8, 0x83, 0xa3, 0xaf, 0x93,
    0x80, 0xba, 0xaa, 0x8c, 0x80, 0xc6, 0x9a, 0xa4,
    0x86, 0x40, 0xb8, 0xab, 0xf3, 0xbf, 0x9e, 0x39,
    0x01, 0x38, 0x08, 0x97, 0x8e, 0x00, 0x80, 0xdd,
    0x39, 0xa6, 0x8f, 0x00, 0x80, 0x9b, 0x80, 0x89,
    0xa7, 0x30, 0x94, 0x80, 0x8a, 0xad, 0x92, 0x80,
    0x91, 0xc8, 0x41, 0x06, 0x88, 0x80, 0xa4, 0x90,
    0x80, 0xb0, 0x9d, 0xef, 0x30, 0x08, 0xa5, 0x94,
    0x80, 0x98, 0x28, 0x08, 0x9f, 0x8d, 0x80, 0x41,
    0x46, 0x92, 0x40, 0xbc, 0x80, 0xce, 0x43, 0x99,
    0xe5, 0xee, 0x90, 0x40, 0xc3, 0x4a, 0x4b, 0xe0,
    0x8e, 0x44, 0x2e, 0x4f, 0xd0, 0x42, 0x46, 0x60,
    0x21, 0xb8, 0x42, 0x38, 0x86, 0x9e, 0x90, 0xce,
    0x90, 0x9d, 0x91, 0xaf, 0x8f, 0x83, 0x9e, 0x94,
    0x84, 0x92, 0x42, 0xaf, 0xbf, 0xff, 0xca, 0x20,
    0xc1, 0x8c, 0xbf, 0x08, 0x80, 0x9b, 0x57, 0xf7,
    0x87, 0x44, 0xd5, 0xa9, 0x88, 0x60, 0x22, 0xe6,
    0x18, 0x30, 0x08, 0x41, 0x22, 0xac, 0x82, 0x90,
    0x1f, 0x41, 0x8b, 0x49, 0x03, 0xea, 0x84, 0x8c,
    0x82, 0x88, 0x86, 0x89, 0x57, 0x65, 0xd4, 0x80,
    0xc6, 0x01, 0x08, 0x09, 0x0b, 0x80, 0x8b, 0x00,
    0x06, 0x80, 0xc0, 0x03, 0x0f, 0x06, 0x80, 0x9b,
    0x03, 0x04, 0x00, 0x16, 0x80, 0x41, 0x53, 0x81,
    0x98, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,
    0x9e, 0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80,
    0x9e, 0x80, 0x98, 0x07, 0x47, 0x33, 0x9e, 0x41,
    0xe0, 0xac, 0x89, 0x86, 0x8f, 0x80, 0x41, 0x40,
    0x9d, 0x91, 0xab, 0x44, 0xf3, 0x30, 0x18, 0x08,
    0x8e, 0x80, 0x40, 0xc4, 0xba, 0xc3, 0x30, 0x44,
    0xb3, 0x18, 0x9a, 0x01, 0x00, 0x08, 0x80, 0x89,
    0x03, 0x00, 0x00, 0x28, 0x18, 0x00, 0x00, 0x02,
    0x01, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x0b, 0x06, 0x03, 0x03, 0x00, 0x80, 0x89,
    0x80, 0x90, 0x22, 0x04, 0x80, 0x90, 0x51, 0x43,
    0x60, 0xa6, 0xdf, 0x9f, 0x50, 0x38, 0x86, 0x40,
    0xdd, 0x81, 0x56, 0x81, 0x8d, 0x5d, 0x30, 0x4c,
    0x1e, 0x42, 0x1d, 0x45, 0xe1, 0x53, 0x4a,
};

static const uint8_t unicode_prop_ID_Start_index[102] = {
    0xf6, 0x03, 0x20, 0xa6, 0x07, 0x00, 0xa9, 0x09,
    0x20, 0xb1, 0x0a, 0x00, 0xba, 0x0b, 0x20, 0x3b,
    0x0d, 0x20, 0xc7, 0x0e, 0x20, 0x49, 0x12, 0x00,
    0x9b, 0x16, 0x00, 0xac, 0x19, 0x00, 0xc0, 0x1d,
    0x80, 0x80, 0x20, 0x20, 0x70, 0x2d, 0x00, 0x00,
    0x32, 0x00, 0xda, 0xa7, 0x00, 0x4c, 0xaa, 0x20,
    0xc7, 0xd7, 0x20, 0xfc, 0xfd, 0x20, 0x9d, 0x02,
    0x21, 0x96, 0x05, 0x01, 0xf3, 0x08, 0x01, 0xb3,
    0x0c, 0x21, 0x73, 0x11, 0x61, 0x3e, 0x13, 0x01,
    0x47, 0x17, 0x21, 0x9e, 0x1a, 0x01, 0x9a, 0x23,
    0x01, 0x78, 0x6b, 0x01, 0xfc, 0xb2, 0x61, 0x3a,
    0xd5, 0x01, 0x2d, 0xe1, 0x41, 0x33, 0xee, 0x01,
    0xe0, 0xa6, 0x62, 0x4b, 0x13, 0x03,
};

static const uint8_t unicode_prop_ID_Continue1_table[640] = {
    0xaf, 0x89, 0xa4, 0x80, 0xd6, 0x80, 0x42, 0x47,
    0xef, 0x96, 0x80, 0x40, 0xfa, 0x84, 0x41, 0x08,
    0xac, 0x00, 0x01, 0x01, 0x00, 0xc7, 0x8a, 0xaf,
    0x9e, 0x28, 0xe4, 0x31, 0x29, 0x08, 0x19, 0x89,
    0x96, 0x80, 0x9d, 0x9a, 0xda, 0x8a, 0x8e, 0x89,
    0xa0, 0x88, 0x88, 0x80, 0x97, 0x18, 0x88, 0x02,
    0x04, 0xaa, 0x82, 0xbb, 0x87, 0xa9, 0x97, 0x80,
    0xa0, 0xb5, 0x10, 0x91, 0x06, 0x89, 0x09, 0x89,
    0x90, 0x82, 0xb7, 0x00, 0x31, 0x09, 0x82, 0x88,
    0x80, 0x89, 0x09, 0x89, 0x8d, 0x01, 0x82, 0xb7,
    0x00, 0x23, 0x09, 0x12, 0x80, 0x93, 0x8b, 0x10,
    0x8a, 0x82, 0xb7, 0x00, 0x38, 0x10, 0x82, 0x93,
    0x09, 0x89, 0x89, 0x28, 0x82, 0xb7, 0x00, 0x31,
    0x09, 0x16, 0x82, 0x89, 0x09, 0x89, 0x91, 0x80,
    0xba, 0x22, 0x10, 0x83, 0x88, 0x80, 0x8d, 0x89,
    0x8f, 0x84, 0xb6, 0x00, 0x30, 0x10, 0x1e, 0x81,
    0x8a, 0x09, 0x89, 0x90, 0x82, 0xb7, 0x00, 0x30,
    0x10, 0x1e, 0x81, 0x8a, 0x09, 0x89, 0x8f, 0x83,
    0xb6, 0x08, 0x30, 0x10, 0x83, 0x88, 0x80, 0x89,
    0x09, 0x89, 0x90, 0x82, 0xc5, 0x03, 0x28, 0x00,
    0x3d, 0x89, 0x09, 0xbc, 0x01, 0x86, 0x8b, 0x38,
    0x89, 0xd6, 0x01, 0x88, 0x8a, 0x29, 0x89, 0xbd,
    0x0d, 0x89, 0x8a, 0x00, 0x00, 0x03, 0x81, 0xb0,
    0x93, 0x01, 0x84, 0x8a, 0x80, 0xa3, 0x88, 0x80,
    0xe3, 0x93, 0x80, 0x89, 0x8b, 0x1b, 0x10, 0x11,
    0x32, 0x83, 0x8c, 0x8b, 0x80, 0x8e, 0x42, 0xbe,
    0x82, 0x88, 0x88, 0x43, 0x9f, 0x83, 0x9b, 0x82,
    0x9c, 0x81, 0x9d, 0x81, 0xbf, 0x9f, 0x88, 0x01,
    0x89, 0xa0, 0x10, 0x8a, 0x40, 0x8e, 0x80, 0xf5,
    0x8b, 0x83, 0x8b, 0x89, 0x89, 0xff, 0x8a, 0xbb,
    0x84, 0xb8, 0x89, 0x80, 0x9c, 0x81, 0x8a, 0x85,
    0x89, 0x95, 0x8d, 0x80, 0x8f, 0xb0, 0x84, 0xae,
    0x90, 0x8a, 0x89, 0x90, 0x88, 0x8b, 0x82, 0x9d,
    0x8c, 0x81, 0x89, 0xab, 0x8d, 0xaf, 0x93, 0x87,
    0x89, 0x85, 0x89, 0xf5, 0x10, 0x94, 0x18, 0x28,
    0x0a, 0x40, 0xc5, 0xbf, 0x42, 0x3e, 0x81, 0x92,
    0x80, 0xfa, 0x8c, 0x18, 0x82, 0x8b, 0x4b, 0xfd,
    0x82, 0x40, 0x8c, 0x80, 0xdf, 0x9f, 0x42, 0x29,
    0x85, 0xe8, 0x81, 0x60, 0x75, 0x84, 0x89, 0xc4,
    0x03, 0x89, 0x9f, 0x81, 0xcf, 0x81, 0x41, 0x0f,
    0x02, 0x03, 0x80, 0x96, 0x23, 0x80, 0xd2, 0x81,
    0xb1, 0x91, 0x89, 0x89, 0x85, 0x91, 0x8c, 0x8a,
    0x9b, 0x87, 0x98, 0x8c, 0xab, 0x83, 0xae, 0x8d,
    0x8e, 0x89, 0x8a, 0x80, 0x89, 0x89, 0xae, 0x8d,
    0x8b, 0x07, 0x09, 0x89, 0xa0, 0x82, 0xb1, 0x00,
    0x11, 0x0c, 0x08, 0x80, 0xa8, 0x24, 0x81, 0x40,
    0xeb, 0x38, 0x09, 0x89, 0x60, 0x4f, 0x23, 0x80,
    0x42, 0xe0, 0x8f, 0x8f, 0x8f, 0x11, 0x97, 0x82,
    0x40, 0xbf, 0x89, 0xa4, 0x80, 0x42, 0xbc, 0x80,
    0x40, 0xe1, 0x80, 0x40, 0x94, 0x84, 0x41, 0x24,
    0x89, 0x45, 0x56, 0x10, 0x0c, 0x83, 0xa7, 0x13,
    0x80, 0x40, 0xa4, 0x81, 0x42, 0x3c, 0x1f, 0x89,
    0x41, 0x70, 0x81, 0x40, 0x98, 0x8a, 0xb0, 0x83,
    0xf9, 0x82, 0xb4, 0x8e, 0x9e, 0x8a, 0x09, 0x89,
    0x83, 0xac, 0x8a, 0x30, 0xac, 0x89, 0x2a, 0xa3,
    0x8d, 0x80, 0x89, 0x21, 0xab, 0x80, 0x8b, 0x82,
    0xaf, 0x8d, 0x3b, 0x80, 0x8b, 0xd1, 0x8b, 0x28,
    0x40, 0x9f, 0x8b, 0x84, 0x89, 0x2b, 0xb6, 0x08,
    0x31, 0x09, 0x82, 0x88, 0x80, 0x89, 0x09, 0x32,
    0x84, 0x40, 0xbf, 0x91, 0x88, 0x89, 0x18, 0xd0,
    0x93, 0x8b, 0x89, 0x40, 0xd4, 0x31, 0x88, 0x9a,
    0x81, 0xd1, 0x90, 0x8e, 0x89, 0xd0, 0x8c, 0x87,
    0x89, 0xd2, 0x8e, 0x83, 0x89, 0x40, 0xf1, 0x8e,
    0x40, 0xa4, 0x89, 0xc5, 0x28, 0x09, 0x18, 0x00,
    0x81, 0x8b, 0x89, 0xf6, 0x31, 0x32, 0x80, 0x9b,
    0x89, 0xa7, 0x30, 0x1f, 0x80, 0x88, 0x8a, 0xad,
    0x8f, 0x41, 0x94, 0x38, 0x87, 0x8f, 0x89, 0xb7,
    0x95, 0x80, 0x8d, 0xf9, 0x2a, 0x00, 0x08, 0x30,
    0x07, 0x89, 0xaf, 0x20, 0x08, 0x27, 0x89, 0x41,
    0x48, 0x83, 0x60, 0x4b, 0x68, 0x89, 0xd5, 0x89,
    0xa5, 0x84, 0xba, 0x86, 0x98, 0x89, 0x43, 0xf4,
    0x00, 0xb6, 0x33, 0xd0, 0x80, 0x8a, 0x81, 0x60,
    0x4c, 0xaa, 0x81, 0x52, 0x60, 0xad, 0x81, 0x96,
    0x42, 0x1d, 0x22, 0x2f, 0x39, 0x86, 0x9d, 0x83,
    0x40, 0x93, 0x82, 0x45, 0x88, 0xb1, 0x41, 0xff,
    0xb6, 0x83, 0xb1, 0x38, 0x8d, 0x80, 0x95, 0x20,
    0x8e, 0x45, 0x4f, 0x30, 0x90, 0x0e, 0x01, 0x04,
    0x41, 0x04, 0x86, 0x88, 0x89, 0x41, 0x63, 0x80,
    0xbc, 0x8d, 0x45, 0xd5, 0x86, 0xec, 0x34, 0x89,
    0x52, 0x95, 0x89, 0x6c, 0x05, 0x05, 0x40, 0xef,
};

static const uint8_t unicode_prop_ID_Continue1_index[60] = {
    0xfa, 0x06, 0x00, 0x70, 0x09, 0x00, 0xf0, 0x0a,
    0x40, 0x57, 0x0c, 0x00, 0xf0, 0x0d, 0x40, 0xc7,
    0x0f, 0x00, 0xea, 0x17, 0x20, 0x45, 0x1b, 0x20,
    0x55, 0x20, 0x20, 0x0c, 0xa8, 0x60, 0x37, 0xaa,
    0x00, 0x50, 0xfe, 0x00, 0x3a, 0x0d, 0x01, 0x83,
    0x11, 0x01, 0xc4, 0x14, 0x21, 0x44, 0x19, 0x21,
    0x5a, 0x1d, 0x41, 0x9f, 0xbc, 0x61, 0xb0, 0xda,
    0x21, 0xf0, 0x01, 0x0e,
};

#ifdef CONFIG_ALL_UNICODE

static const uint8_t unicode_cc_table[881] = {
    0xb2, 0xcf, 0xd4, 0x00, 0xe8, 0x03, 0xdc, 0x00,
    0xe8, 0x00, 0xd8, 0x04, 0xdc, 0x01, 0xca, 0x03,
    0xdc, 0x01, 0xca, 0x0a, 0xdc, 0x04, 0x01, 0x03,
    0xdc, 0xc7, 0x00, 0xf0, 0xc0, 0x02, 0xdc, 0xc2,
    0x01, 0xdc, 0x80, 0xc2, 0x03, 0xdc, 0xc0, 0x00,
    0xe8, 0x01, 0xdc, 0xc0, 0x41, 0xe9, 0x00, 0xea,
    0x41, 0xe9, 0x00, 0xea, 0x00, 0xe9, 0xcc, 0xb0,
    0xe2, 0xc4, 0xb0, 0xd8, 0x00, 0xdc, 0xc3, 0x00,
    0xdc, 0xc2, 0x00, 0xde, 0x00, 0xdc, 0xc5, 0x05,
    0xdc, 0xc1, 0x00, 0xdc, 0xc1, 0x00, 0xde, 0x00,
    0xe4, 0xc0, 0x49, 0x0a, 0x43, 0x13, 0x80, 0x00,
    0x17, 0x80, 0x41, 0x18, 0x80, 0xc0, 0x00, 0xdc,
    0x80, 0x00, 0x12, 0xb0, 0x17, 0xc7, 0x42, 0x1e,
    0xaf, 0x47, 0x1b, 0xc1, 0x01, 0xdc, 0xc4, 0x00,
    0xdc, 0xc1, 0x00, 0xdc, 0x8f, 0x00, 0x23, 0xb0,
    0x34, 0xc6, 0x81, 0xc3, 0x00, 0xdc, 0xc0, 0x81,
    0xc1, 0x80, 0x00, 0xdc, 0xc1, 0x00, 0xdc, 0xa2,
    0x00, 0x24, 0x9d, 0xc0, 0x00, 0xdc, 0xc1, 0x00,
    0xdc, 0xc1, 0x02, 0xdc, 0xc0, 0x01, 0xdc, 0xc0,
    0x00, 0xdc, 0xc2, 0x00, 0xdc, 0xc0, 0x00, 0xdc,
    0xc0, 0x00, 0xdc, 0xc0, 0x00, 0xdc, 0xc1, 0xb0,
    0x6f, 0xc6, 0x00, 0xdc, 0xc0, 0x88, 0x00, 0xdc,
    0x97, 0xc3, 0x80, 0xc8, 0x80, 0xc2, 0x80, 0xc4,
    0xaa, 0x02, 0xdc, 0xb0, 0x0b, 0xc0, 0x02, 0xdc,
    0xc3, 0xa9, 0xc4, 0x04, 0xdc, 0xcd, 0x80, 0x00,
    0xdc, 0xc1, 0x00, 0xdc, 0xc1, 0x00, 0xdc, 0xc2,
    0x02, 0xdc, 0x42, 0x1b, 0xc2, 0x00, 0xdc, 0xc1,
    0x01, 0xdc, 0xc4, 0xb0, 0x0b, 0x00, 0x07, 0x8f,
    0x00, 0x09, 0x82, 0xc0, 0x00, 0xdc, 0xc1, 0xb0,
    0x36, 0x00, 0x07, 0x8f, 0x00, 0x09, 0xaf, 0xc0,
    0xb0, 0x0c, 0x00, 0x07, 0x8f, 0x00, 0x09, 0xb0,
    0x3d, 0x00, 0x07, 0x8f, 0x00, 0x09, 0xb0, 0x3d,
    0x00, 0x07, 0x8f, 0x00, 0x09, 0xb0, 0x4e, 0x00,
    0x09, 0xb0, 0x3d, 0x00, 0x07, 0x8f, 0x00, 0x09,
    0x86, 0x00, 0x54, 0x00, 0x5b, 0xb0, 0x34, 0x00,
    0x07, 0x8f, 0x00, 0x09, 0xb0, 0x3c, 0x01, 0x09,
    0x8f, 0x00, 0x09, 0xb0, 0x4b, 0x00, 0x09, 0xb0,
    0x3c, 0x01, 0x67, 0x00, 0x09, 0x8c, 0x03, 0x6b,
    0xb0, 0x3b, 0x01, 0x76, 0x00, 0x09, 0x8c, 0x03,
    0x7a, 0xb0, 0x1b, 0x01, 0xdc, 0x9a, 0x00, 0xdc,
    0x80, 0x00, 0xdc, 0x80, 0x00, 0xd8, 0xb0, 0x06,
    0x41, 0x81, 0x80, 0x00, 0x84, 0x84, 0x03, 0x82,
    0x81, 0x00, 0x82, 0x80, 0xc1, 0x00, 0x09, 0x80,
    0xc1, 0xb0, 0x0d, 0x00, 0xdc, 0xb0, 0x3f, 0x00,
    0x07, 0x80, 0x01, 0x09, 0xb0, 0x21, 0x00, 0xdc,
    0xb2, 0x9e, 0xc2, 0xb3, 0x83, 0x01, 0x09, 0x9d,
    0x00, 0x09, 0xb0, 0x6c, 0x00, 0x09, 0x89, 0xc0,
    0xb0, 0x9a, 0x00, 0xe4, 0xb0, 0x5e, 0x00, 0xde,
    0xc0, 0x00, 0xdc, 0xb0, 0xaa, 0xc0, 0x00, 0xdc,
    0xb0, 0x16, 0x00, 0x09, 0x93, 0xc7, 0x81, 0x00,
    0xdc, 0xaf, 0xc4, 0x05, 0xdc, 0xc1, 0x00, 0xdc,
    0x80, 0x01, 0xdc, 0xc1, 0x01, 0xdc, 0xc4, 0x00,
    0xdc, 0xc3, 0xb0, 0x34, 0x00, 0x07, 0x8e, 0x00,
    0x09, 0xa5, 0xc0, 0x00, 0xdc, 0xc6, 0xb0, 0x05,
    0x01, 0x09, 0xb0, 0x09, 0x00, 0x07, 0x8a, 0x01,
    0x09, 0xb0, 0x12, 0x00, 0x07, 0xb0, 0x67, 0xc2,
    0x41, 0x00, 0x04, 0xdc, 0xc1, 0x03, 0xdc, 0xc0,
    0x41, 0x00, 0x05, 0x01, 0x83, 0x00, 0xdc, 0x85,
    0xc0, 0x82, 0xc1, 0xb0, 0x95, 0xc1, 0x00, 0xdc,
    0xc6, 0x00, 0xdc, 0xc1, 0x00, 0xea, 0x00, 0xd6,
    0x00, 0xdc, 0x00, 0xca, 0xe4, 0x00, 0xe8, 0x01,
    0xe4, 0x00, 0xdc, 0x00, 0xda, 0xc0, 0x00, 0xe9,
    0x00, 0xdc, 0xc0, 0x00, 0xdc, 0xb2, 0x9f, 0xc1,
    0x01, 0x01, 0xc3, 0x02, 0x01, 0xc1, 0x83, 0xc0,
    0x82, 0x01, 0x01, 0xc0, 0x00, 0xdc, 0xc0, 0x01,
    0x01, 0x03, 0xdc, 0xc0, 0xb8, 0x03, 0xcd, 0xc2,
    0xb0, 0x5c, 0x00, 0x09, 0xb0, 0x2f, 0xdf, 0xb1,
    0xf9, 0x00, 0xda, 0x00, 0xe4, 0x00, 0xe8, 0x00,
    0xde, 0x01, 0xe0, 0xb0, 0x38, 0x01, 0x08, 0xb8,
    0x6d, 0xa3, 0xc0, 0x83, 0xc9, 0x9f, 0xc1, 0xb0,
    0x1f, 0xc1, 0xb0, 0xe3, 0x00, 0x09, 0xa4, 0x00,
    0x09, 0xb0, 0x66, 0x00, 0x09, 0x9a, 0xd1, 0xb0,
    0x08, 0x02, 0xdc, 0xa4, 0x00, 0x09, 0xb0, 0x2e,
    0x00, 0x07, 0x8b, 0x00, 0x09, 0xb0, 0xbe, 0xc0,
    0x80, 0xc1, 0x00, 0xdc, 0x81, 0xc1, 0x84, 0xc1,
    0x80, 0xc0, 0xb0, 0x03, 0x00, 0x09, 0xb0, 0xc5,
    0x00, 0x09, 0xb8, 0x46, 0xff, 0x00, 0x1a, 0xb2,
    0xd0, 0xc6, 0x06, 0xdc, 0xc1, 0xb3, 0x9c, 0x00,
    0xdc, 0xb0, 0xb1, 0x00, 0xdc, 0xb0, 0x64, 0xc4,
    0xb6, 0x61, 0x00, 0xdc, 0x80, 0xc0, 0xa7, 0xc0,
    0x00, 0x01, 0x00, 0xdc, 0x83, 0x00, 0x09, 0xb0,
    0x74, 0xc0, 0x00, 0xdc, 0xb2, 0x0c, 0xc3, 0xb1,
    0x52, 0xc1, 0xb0, 0x68, 0x01, 0xdc, 0xc2, 0x00,
    0xdc, 0xc0, 0x03, 0xdc, 0xb0, 0x00, 0xc0, 0x00,
    0xdc, 0xc0, 0x00, 0xdc, 0xb0, 0x8f, 0x00, 0x09,
    0xa8, 0x00, 0x09, 0x8d, 0x00, 0x09, 0xb0, 0x08,
    0x00, 0x09, 0x00, 0x07, 0xb0, 0x14, 0xc2, 0xaf,
    0x01, 0x09, 0xb0, 0x0d, 0x00, 0x07, 0xb0, 0x1b,
    0x00, 0x09, 0x88, 0x00, 0x07, 0xb0, 0x39, 0x00,
    0x09, 0x00, 0x07, 0xb0, 0x81, 0x00, 0x07, 0x00,
    0x09, 0xb0, 0x1f, 0x01, 0x07, 0x8f, 0x00, 0x09,
    0x97, 0xc6, 0x82, 0xc4, 0xb0, 0x9c, 0x00, 0x09,
    0x82, 0x00, 0x07, 0x96, 0xc0, 0xb0, 0x32, 0x00,
    0x09, 0x00, 0x07, 0xb0, 0xca, 0x00, 0x09, 0x00,
    0x07, 0xb0, 0x4d, 0x00, 0x09, 0xb0, 0x45, 0x00,
    0x09, 0x00, 0x07, 0xb0, 0x42, 0x00, 0x09, 0xb0,
    0xdc, 0x00, 0x09, 0x00, 0x07, 0xb0, 0xd1, 0x01,
    0x09, 0x83, 0x00, 0x07, 0xb0, 0x6b, 0x00, 0x09,
    0xb0, 0x22, 0x00, 0x09, 0x91, 0x00, 0x09, 0xb0,
    0x20, 0x00, 0x09, 0xb1, 0x74, 0x00, 0x09, 0xb0,
    0xd1, 0x00, 0x07, 0x80, 0x01, 0x09, 0xb0, 0x20,
    0x00, 0x09, 0xb8, 0x45, 0x27, 0x04, 0x01, 0xb0,
    0x0a, 0xc6, 0xb4, 0x88, 0x01, 0x06, 0xb8, 0x44,
    0x7b, 0x00, 0x01, 0xb8, 0x0c, 0x95, 0x01, 0xd8,
    0x02, 0x01, 0x82, 0x00, 0xe2, 0x04, 0xd8, 0x87,
    0x07, 0xdc, 0x81, 0xc4, 0x01, 0xdc, 0x9d, 0xc3,
    0xb0, 0x63, 0xc2, 0xb8, 0x05, 0x8a, 0xc6, 0x80,
    0xd0, 0x81, 0xc6, 0x80, 0xc1, 0x80, 0xc4, 0xb0,
    0xd4, 0xc6, 0xb1, 0x46, 0xc0, 0xb0, 0x0c, 0xc3,
    0xb5, 0xaf, 0x06, 0xdc, 0xb0, 0x3c, 0xc5, 0x00,
    0x07,
};

static const uint8_t unicode_cc_index[84] = {
    0x4d, 0x03, 0x00, 0x97, 0x05, 0x20, 0xc6, 0x05,
    0x00, 0xe7, 0x06, 0x00, 0x45, 0x07, 0x00, 0x9c,
    0x08, 0x00, 0x4d, 0x09, 0x00, 0x3c, 0x0b, 0x00,
    0x3d, 0x0d, 0x00, 0x36, 0x0f, 0x00, 0x38, 0x10,
    0x20, 0x3a, 0x19, 0x00, 0xcb, 0x1a, 0x20, 0xd3,
    0x1c, 0x00, 0xcf, 0x1d, 0x00, 0xe2, 0x20, 0x00,
    0x2e, 0x30, 0x20, 0x2b, 0xa9, 0x20, 0xed, 0xab,
    0x00, 0x39, 0x0a, 0x01, 0x84, 0x0f, 0x21, 0xc0,
    0x11, 0x01, 0x43, 0x14, 0x01, 0x39, 0x18, 0x21,
    0x42, 0x1d, 0x21, 0x67, 0xd1, 0x01, 0x30, 0xe1,
    0x21, 0x4b, 0xe9, 0x01,
};

static const uint32_t unicode_decomp_table1[693] = {
    0x00280081, 0x002a0097, 0x002a8081, 0x002bc097,
    0x002c8115, 0x002d0097, 0x002d4081, 0x002e0097,
    0x002e4115, 0x002f0199, 0x00302016, 0x00400842,
    0x00448a42, 0x004a0442, 0x004c0096, 0x004c8117,
    0x004d0242, 0x004e4342, 0x004fc12f, 0x0050c342,
    0x005240bf, 0x00530342, 0x00550942, 0x005a0842,
    0x005e0096, 0x005e4342, 0x005fc081, 0x00680142,
    0x006bc142, 0x00710185, 0x0071c317, 0x00734844,
    0x00778344, 0x00798342, 0x007b02be, 0x007c4197,
    0x007d0142, 0x007e0444, 0x00800e42, 0x00878142,
    0x00898744, 0x00ac0483, 0x00b60317, 0x00b80283,
    0x00d00214, 0x00d10096, 0x00dd0080, 0x00de8097,
    0x00df8080, 0x00e10097, 0x00e1413e, 0x00e1c080,
    0x00e204be, 0x00ea83ae, 0x00f282ae, 0x00f401ad,
    0x00f4c12e, 0x00f54103, 0x00fc0303, 0x00fe4081,
    0x0100023e, 0x0101c0be, 0x010301be, 0x010640be,
    0x010e40be, 0x0114023e, 0x0115c0be, 0x011701be,
    0x011d8144, 0x01304144, 0x01340244, 0x01358144,
    0x01368344, 0x01388344, 0x013a8644, 0x013e0144,
    0x0161c085, 0x018882ae, 0x019d422f, 0x01b00184,
    0x01b4c084, 0x024a4084, 0x024c4084, 0x024d0084,
    0x0256042e, 0x0272c12e, 0x02770120, 0x0277c084,
    0x028cc084, 0x028d8084, 0x029641ae, 0x02978084,
    0x02d20084, 0x02d2c12e, 0x02d70120, 0x02e50084,
    0x02f281ae, 0x03120084, 0x03300084, 0x0331c122,
    0x0332812e, 0x035281ae, 0x03768084, 0x037701ae,
    0x038cc085, 0x03acc085, 0x03b7012f, 0x03c30081,
    0x03d0c084, 0x03d34084, 0x03d48084, 0x03d5c084,
    0x03d70084, 0x03da4084, 0x03dcc084, 0x03dd412e,
    0x03ddc085, 0x03de0084, 0x03de4085, 0x03e04084,
    0x03e4c084, 0x03e74084, 0x03e88084, 0x03e9c084,
    0x03eb0084, 0x03ee4084, 0x04098084, 0x043f0081,
    0x06c18484, 0x06c48084, 0x06cec184, 0x06d00120,
    0x06d0c084, 0x074b0383, 0x074cc41f, 0x074f1783,
    0x075e0081, 0x0766d283, 0x07801d44, 0x078e8942,
    0x07931844, 0x079f0d42, 0x07a58216, 0x07a68085,
    0x07a6c0be, 0x07a80d44, 0x07aea044, 0x07c00122,
    0x07c08344, 0x07c20122, 0x07c28344, 0x07c40122,
    0x07c48244, 0x07c60122, 0x07c68244, 0x07c8113e,
    0x07d08244, 0x07d20122, 0x07d28244, 0x07d40122,
    0x07d48344, 0x07d64c3e, 0x07dc4080, 0x07dc80be,
    0x07dcc080, 0x07dd00be, 0x07dd4080, 0x07dd80be,
    0x07ddc080, 0x07de00be, 0x07de4080, 0x07de80be,
    0x07dec080, 0x07df00be, 0x07df4080, 0x07e00820,
    0x07e40820, 0x07e80820, 0x07ec05be, 0x07eec080,
    0x07ef00be, 0x07ef4097, 0x07ef8080, 0x07efc117,
    0x07f0443e, 0x07f24080, 0x07f280be, 0x07f2c080,
    0x07f303be, 0x07f4c080, 0x07f582ae, 0x07f6c080,
    0x07f7433e, 0x07f8c080, 0x07f903ae, 0x07fac080,
    0x07fb013e, 0x07fb8102, 0x07fc83be, 0x07fe4080,
    0x07fe80be, 0x07fec080, 0x07ff00be, 0x07ff4080,
    0x07ff8097, 0x0800011e, 0x08008495, 0x08044081,
    0x0805c097, 0x08090081, 0x08094097, 0x08098099,
    0x080bc081, 0x080cc085, 0x080d00b1, 0x080d8085,
    0x080dc0b1, 0x080f0197, 0x0811c197, 0x0815c0b3,
    0x0817c081, 0x081c0595, 0x081ec081, 0x081f0215,
    0x0820051f, 0x08228583, 0x08254415, 0x082a0097,
    0x08400119, 0x08408081, 0x0840c0bf, 0x08414119,
    0x0841c081, 0x084240bf, 0x0842852d, 0x08454081,
    0x08458097, 0x08464295, 0x08480097, 0x08484099,
    0x08488097, 0x08490081, 0x08498080, 0x084a0081,
    0x084a8102, 0x084b0495, 0x084d421f, 0x084e4081,
    0x084ec099, 0x084f0283, 0x08514295, 0x08540119,
    0x0854809b, 0x0854c619, 0x0857c097, 0x08580081,
    0x08584097, 0x08588099, 0x0858c097, 0x08590081,
    0x08594097, 0x08598099, 0x0859c09b, 0x085a0097,
    0x085a4081, 0x085a8097, 0x085ac099, 0x085b0295,
    0x085c4097, 0x085c8099, 0x085cc097, 0x085d0081,
    0x085d4097, 0x085d8099, 0x085dc09b, 0x085e0097,
    0x085e4081, 0x085e8097, 0x085ec099, 0x085f0215,
    0x08624099, 0x0866813e, 0x086b80be, 0x087341be,
    0x088100be, 0x088240be, 0x088300be, 0x088901be,
    0x088b0085, 0x088b40b1, 0x088bc085, 0x088c00b1,
    0x089040be, 0x089100be, 0x0891c1be, 0x089801be,
    0x089b42be, 0x089d0144, 0x089e0144, 0x08a00144,
    0x08a10144, 0x08a20144, 0x08ab023e, 0x08b80244,
    0x08ba8220, 0x08ca411e, 0x0918049f, 0x091a4523,
    0x091cc097, 0x091d04a5, 0x091f452b, 0x0921c09b,
    0x092204a1, 0x09244525, 0x0926c099, 0x09270d25,
    0x092d8d1f, 0x09340d1f, 0x093a8081, 0x0a8300b3,
    0x0a9d0099, 0x0a9d4097, 0x0a9d8099, 0x0ab700be,
    0x0b1f0115, 0x0b5bc081, 0x0ba7c081, 0x0bbcc081,
    0x0bc004ad, 0x0bc244ad, 0x0bc484ad, 0x0bc6f383,
    0x0be0852d, 0x0be31d03, 0x0bf1882d, 0x0c000081,
    0x0c0d8283, 0x0c130b84, 0x0c194284, 0x0c1c0122,
    0x0c1cc122, 0x0c1d8122, 0x0c1e4122, 0x0c1f0122,
    0x0c250084, 0x0c26c123, 0x0c278084, 0x0c27c085,
    0x0c2b0b84, 0x0c314284, 0x0c340122, 0x0c34c122,
    0x0c358122, 0x0c364122, 0x0c370122, 0x0c3d0084,
    0x0c3dc220, 0x0c3f8084, 0x0c3fc085, 0x0c4c4a2d,
    0x0c51451f, 0x0c53ca9f, 0x0c5915ad, 0x0c648703,
    0x0c800741, 0x0c838089, 0x0c83c129, 0x0c8441a9,
    0x0c850089, 0x0c854129, 0x0c85c2a9, 0x0c870089,
    0x0c87408f, 0x0c87808d, 0x0c881241, 0x0c910203,
    0x0c940099, 0x0c9444a3, 0x0c968323, 0x0c98072d,
    0x0c9b84af, 0x0c9dc2a1, 0x0c9f00b5, 0x0c9f40b3,
    0x0c9f8085, 0x0ca01883, 0x0cac4223, 0x0cad4523,
    0x0cafc097, 0x0cb004a1, 0x0cb241a5, 0x0cb30097,
    0x0cb34099, 0x0cb38097, 0x0cb3c099, 0x0cb417ad,
    0x0cbfc085, 0x0cc001b3, 0x0cc0c0b1, 0x0cc100b3,
    0x0cc14131, 0x0cc1c0b5, 0x0cc200b3, 0x0cc241b1,
    0x0cc30133, 0x0cc38131, 0x0cc40085, 0x0cc440b1,
    0x0cc48133, 0x0cc50085, 0x0cc540b5, 0x0cc580b7,
    0x0cc5c0b5, 0x0cc600b1, 0x0cc64135, 0x0cc6c0b3,
    0x0cc701b1, 0x0cc7c0b3, 0x0cc800b5, 0x0cc840b3,
    0x0cc881b1, 0x0cc9422f, 0x0cca4131, 0x0ccac0b5,
    0x0ccb00b1, 0x0ccb40b3, 0x0ccb80b5, 0x0ccbc0b1,
    0x0ccc012f, 0x0ccc80b5, 0x0cccc0b3, 0x0ccd00b5,
    0x0ccd40b1, 0x0ccd80b5, 0x0ccdc085, 0x0cce02b1,
    0x0ccf40b3, 0x0ccf80b1, 0x0ccfc085, 0x0cd001b1,
    0x0cd0c0b3, 0x0cd101b1, 0x0cd1c0b5, 0x0cd200b3,
    0x0cd24085, 0x0cd280b5, 0x0cd2c085, 0x0cd30133,
    0x0cd381b1, 0x0cd440b3, 0x0cd48085, 0x0cd4c0b1,
    0x0cd500b3, 0x0cd54085, 0x0cd580b5, 0x0cd5c0b1,
    0x0cd60521, 0x0cd88525, 0x0cdb02a5, 0x0cdc4099,
    0x0cdc8117, 0x0cdd0099, 0x0cdd4197, 0x0cde0127,
    0x0cde8285, 0x0cdfc089, 0x0ce0043f, 0x0ce20099,
    0x0ce2409b, 0x0ce283bf, 0x0ce44219, 0x0ce54205,
    0x0ce6433f, 0x0ce7c131, 0x0ce84085, 0x0ce881b1,
    0x0ce94085, 0x0ce98107, 0x0cea0089, 0x0cea4097,
    0x0cea8219, 0x0ceb809d, 0x0cebc08d, 0x0cec083f,
    0x0cf00105, 0x0cf0809b, 0x0cf0c197, 0x0cf1809b,
    0x0cf1c099, 0x0cf20517, 0x0cf48099, 0x0cf4c117,
    0x0cf54119, 0x0cf5c097, 0x0cf6009b, 0x0cf64099,
    0x0cf68217, 0x0cf78119, 0x0cf804a1, 0x0cfa4525,
    0x0cfcc525, 0x0cff4125, 0x0cffc099, 0x29a70103,
    0x29dc0081, 0x29fc8195, 0x29fe0103, 0x2ad70203,
    0x2ada4081, 0x3e401482, 0x3e4a7f82, 0x3e6a3f82,
    0x3e8aa102, 0x3e9b0110, 0x3e9c2f82, 0x3eb3c590,
    0x3ec00197, 0x3ec0c119, 0x3ec1413f, 0x3ec4c2af,
    0x3ec74184, 0x3ec804ad, 0x3eca4081, 0x3eca8304,
    0x3ecc03a0, 0x3ece02a0, 0x3ecf8084, 0x3ed00120,
    0x3ed0c120, 0x3ed184ae, 0x3ed3c085, 0x3ed4312d,
    0x3ef4cbad, 0x3efa892f, 0x3eff022d, 0x3f002f2f,
    0x3f1782a5, 0x3f18c0b1, 0x3f1907af, 0x3f1cffaf,
    0x3f3c81a5, 0x3f3d64af, 0x3f542031, 0x3f649b31,
    0x3f7c0131, 0x3f7c83b3, 0x3f7e40b1, 0x3f7e80bd,
    0x3f7ec0bb, 0x3f7f00b3, 0x3f840503, 0x3f8c01ad,
    0x3f8cc315, 0x3f8e462d, 0x3f91cc03, 0x3f97c695,
    0x3f9c01af, 0x3f9d0085, 0x3f9d852f, 0x3fa03aad,
    0x3fbd442f, 0x3fc06f1f, 0x3fd7c11f, 0x3fd85fad,
    0x3fe80081, 0x3fe84f1f, 0x3ff0831f, 0x3ff2831f,
    0x3ff4831f, 0x3ff6819f, 0x3ff80783, 0x41e04d83,
    0x41e70f91, 0x44268192, 0x442ac092, 0x444b8112,
    0x44d2c112, 0x452ec212, 0x456e8112, 0x464e0092,
    0x74578392, 0x746ec312, 0x75000d1f, 0x75068d1f,
    0x750d0d1f, 0x7513839f, 0x7515891f, 0x751a0d1f,
    0x75208d1f, 0x75271015, 0x752f439f, 0x7531459f,
    0x75340d1f, 0x753a8d1f, 0x75410395, 0x7543441f,
    0x7545839f, 0x75478d1f, 0x754e0795, 0x7552839f,
    0x75548d1f, 0x755b0d1f, 0x75618d1f, 0x75680d1f,
    0x756e8d1f, 0x75750d1f, 0x757b8d1f, 0x75820d1f,
    0x75888d1f, 0x758f0d1f, 0x75958d1f, 0x759c0d1f,
    0x75a28d1f, 0x75a90103, 0x75aa089f, 0x75ae4081,
    0x75ae839f, 0x75b04081, 0x75b08c9f, 0x75b6c081,
    0x75b7032d, 0x75b8889f, 0x75bcc081, 0x75bd039f,
    0x75bec081, 0x75bf0c9f, 0x75c54081, 0x75c5832d,
    0x75c7089f, 0x75cb4081, 0x75cb839f, 0x75cd4081,
    0x75cd8c9f, 0x75d3c081, 0x75d4032d, 0x75d5889f,
    0x75d9c081, 0x75da039f, 0x75dbc081, 0x75dc0c9f,
    0x75e24081, 0x75e2832d, 0x75e4089f, 0x75e84081,
    0x75e8839f, 0x75ea4081, 0x75ea8c9f, 0x75f0c081,
    0x75f1042d, 0x75f3851f, 0x75f6051f, 0x75f8851f,
    0x75fb051f, 0x75fd851f, 0x7b80022d, 0x7b814dad,
    0x7b884203, 0x7b89c081, 0x7b8a452d, 0x7b8d0403,
    0x7b908081, 0x7b91dc03, 0x7ba0052d, 0x7ba2c8ad,
    0x7ba84483, 0x7baac8ad, 0x7c400097, 0x7c404521,
    0x7c440d25, 0x7c4a8087, 0x7c4ac115, 0x7c4b4117,
    0x7c4c0d1f, 0x7c528217, 0x7c538099, 0x7c53c097,
    0x7c5a8197, 0x7c640097, 0x7c80012f, 0x7c808081,
    0x7c841603, 0x7c9004c1, 0x7c940103, 0x7efc051f,
    0xbe0001ac, 0xbe00d110, 0xbe0947ac, 0xbe0d3910,
    0xbe29872c, 0xbe2d022c, 0xbe2e3790, 0xbe49ff90,
    0xbe69bc10,
};

static const uint16_t unicode_decomp_table2[693] = {
    0x0020, 0x0000, 0x0061, 0x0002, 0x0004, 0x0006, 0x03bc, 0x0008,
    0x000a, 0x000c, 0x0015, 0x0095, 0x00a5, 0x00b9, 0x00c1, 0x00c3,
    0x00c7, 0x00cb, 0x00d1, 0x00d7, 0x00dd, 0x00e0, 0x00e6, 0x00f8,
    0x0108, 0x010a, 0x0073, 0x0110, 0x0112, 0x0114, 0x0120, 0x012c,
    0x0144, 0x014d, 0x0153, 0x0162, 0x0168, 0x016a, 0x0176, 0x0192,
    0x0194, 0x01a9, 0x01bb, 0x01c7, 0x01d1, 0x01d5, 0x02b9, 0x01d7,
    0x003b, 0x01d9, 0x01db, 0x00b7, 0x01e1, 0x01fc, 0x020c, 0x0218,
    0x021d, 0x0223, 0x0227, 0x03a3, 0x0233, 0x023f, 0x0242, 0x024b,
    0x024e, 0x0251, 0x025d, 0x0260, 0x0269, 0x026c, 0x026f, 0x0275,
    0x0278, 0x0281, 0x028a, 0x029c, 0x029f, 0x02a3, 0x02af, 0x02b9,
    0x02c5, 0x02c9, 0x02cd, 0x02d1, 0x02d5, 0x02e7, 0x02ed, 0x02f1,
    0x02f5, 0x02f9, 0x02fd, 0x0305, 0x0309, 0x030d, 0x0313, 0x0317,
    0x031b, 0x0323, 0x0327, 0x032b, 0x032f, 0x0335, 0x033d, 0x0341,
    0x0349, 0x034d, 0x0351, 0x0f0b, 0x0357, 0x035b, 0x035f, 0x0363,
    0x0367, 0x036b, 0x036f, 0x0373, 0x0379, 0x037d, 0x0381, 0x0385,
    0x0389, 0x038d, 0x0391, 0x0395, 0x0399, 0x039d, 0x03a1, 0x10dc,
    0x03a5, 0x03c9, 0x03cd, 0x03d9, 0x03dd, 0x03e1, 0x03ef, 0x03f1,
    0x043d, 0x044f, 0x0499, 0x04f0, 0x0502, 0x054a, 0x0564, 0x056c,
    0x0570, 0x0573, 0x059a, 0x05fa, 0x05fe, 0x0607, 0x060b, 0x0614,
    0x0618, 0x061e, 0x0622, 0x0628, 0x068e, 0x0694, 0x0698, 0x069e,
    0x06a2, 0x06ab, 0x03ac, 0x06f3, 0x03ad, 0x06f6, 0x03ae, 0x06f9,
    0x03af, 0x06fc, 0x03cc, 0x06ff, 0x03cd, 0x0702, 0x03ce, 0x0705,
    0x0709, 0x070d, 0x0711, 0x0386, 0x0732, 0x0735, 0x03b9, 0x0737,
    0x073b, 0x0388, 0x0753, 0x0389, 0x0756, 0x0390, 0x076b, 0x038a,
    0x0777, 0x03b0, 0x0789, 0x038e, 0x0799, 0x079f, 0x07a3, 0x038c,
    0x07b8, 0x038f, 0x07bb, 0x00b4, 0x07be, 0x07c0, 0x07c2, 0x2010,
    0x07cb, 0x002e, 0x07cd, 0x07cf, 0x0020, 0x07d2, 0x07d6, 0x07db,
    0x07df, 0x07e4, 0x07ea, 0x07f0, 0x0020, 0x07f6, 0x2212, 0x0801,
    0x0805, 0x0807, 0x081d, 0x0825, 0x0827, 0x0043, 0x082d, 0x0830,
    0x0190, 0x0836, 0x0839, 0x004e, 0x0845, 0x0847, 0x084c, 0x084e,
    0x0851, 0x005a, 0x03a9, 0x005a, 0x0853, 0x0857, 0x0860, 0x0069,
    0x0862, 0x0865, 0x086f, 0x0874, 0x087a, 0x087e, 0x08a2, 0x0049,
    0x08a4, 0x08a6, 0x08a9, 0x0056, 0x08ab, 0x08ad, 0x08b0, 0x08b4,
    0x0058, 0x08b6, 0x08b8, 0x08bb, 0x08c0, 0x08c2, 0x08c5, 0x0076,
    0x08c7, 0x08c9, 0x08cc, 0x08d0, 0x0078, 0x08d2, 0x08d4, 0x08d7,
    0x08db, 0x08de, 0x08e4, 0x08e7, 0x08f0, 0x08f3, 0x08f6, 0x08f9,
    0x0902, 0x0906, 0x090b, 0x090f, 0x0914, 0x0917, 0x091a, 0x0923,
    0x092c, 0x093b, 0x093e, 0x0941, 0x0944, 0x0947, 0x094a, 0x0956,
    0x095c, 0x0960, 0x0962, 0x0964, 0x0968, 0x096a, 0x0970, 0x0978,
    0x097c, 0x0980, 0x0986, 0x0989, 0x098f, 0x0991, 0x0030, 0x0993,
    0x0999, 0x099c, 0x099e, 0x09a1, 0x09a4, 0x2d61, 0x6bcd, 0x9f9f,
    0x09a6, 0x09b1, 0x09bc, 0x09c7, 0x0a95, 0x0aa1, 0x0b15, 0x0020,
    0x0b27, 0x0b31, 0x0b8d, 0x0ba1, 0x0ba5, 0x0ba9, 0x0bad, 0x0bb1,
    0x0bb5, 0x0bb9, 0x0bbd, 0x0bc1, 0x0bc5, 0x0c21, 0x0c35, 0x0c39,
    0x0c3d, 0x0c41, 0x0c45, 0x0c49, 0x0c4d, 0x0c51, 0x0c55, 0x0c59,
    0x0c6f, 0x0c71, 0x0c73, 0x0ca0, 0x0cbc, 0x0cdc, 0x0ce4, 0x0cec,
    0x0cf4, 0x0cfc, 0x0d04, 0x0d0c, 0x0d14, 0x0d22, 0x0d2e, 0x0d7a,
    0x0d82, 0x0d85, 0x0d89, 0x0d8d, 0x0d9d, 0x0db1, 0x0db5, 0x0dbc,
    0x0dc2, 0x0dc6, 0x0e28, 0x0e2c, 0x0e30, 0x0e32, 0x0e36, 0x0e3c,
    0x0e3e, 0x0e41, 0x0e43, 0x0e46, 0x0e77, 0x0e7b, 0x0e89, 0x0e8e,
    0x0e94, 0x0e9c, 0x0ea3, 0x0ea9, 0x0eb4, 0x0ebe, 0x0ec6, 0x0eca,
    0x0ecf, 0x0ed9, 0x0edd, 0x0ee4, 0x0eec, 0x0ef3, 0x0ef8, 0x0f04,
    0x0f0a, 0x0f15, 0x0f1b, 0x0f22, 0x0f28, 0x0f33, 0x0f3d, 0x0f45,
    0x0f4c, 0x0f51, 0x0f57, 0x0f5e, 0x0f63, 0x0f69, 0x0f70, 0x0f76,
    0x0f7d, 0x0f82, 0x0f89, 0x0f8d, 0x0f9e, 0x0fa4, 0x0fa9, 0x0fad,
    0x0fb8, 0x0fbe, 0x0fc9, 0x0fd0, 0x0fd6, 0x0fda, 0x0fe1, 0x0fe5,
    0x0fef, 0x0ffa, 0x1000, 0x1004, 0x1009, 0x100f, 0x1013, 0x101a,
    0x101f, 0x1023, 0x1029, 0x102f, 0x1032, 0x1036, 0x1039, 0x103f,
    0x1045, 0x1059, 0x1061, 0x1079, 0x107c, 0x1080, 0x1095, 0x10a1,
    0x10b1, 0x10c3, 0x10cb, 0x10cf, 0x10da, 0x10de, 0x10ea, 0x10f2,
    0x10f4, 0x1100, 0x1105, 0x1111, 0x1141, 0x1149, 0x114d, 0x1153,
    0x1157, 0x115a, 0x116e, 0x1171, 0x1175, 0x117b, 0x117d, 0x1181,
    0x1184, 0x118c, 0x1192, 0x1196, 0x119c, 0x11a2, 0x11a8, 0x11ab,
    0xa76f, 0x11af, 0x11b2, 0x11b6, 0x028d, 0x11be, 0x1210, 0x130e,
    0x140c, 0x1490, 0x1495, 0x1553, 0x156c, 0x1572, 0x1578, 0x157e,
    0x158a, 0x1596, 0x002b, 0x15a1, 0x15b9, 0x15bd, 0x15c1, 0x15c5,
    0x15c9, 0x15cd, 0x15e1, 0x15e5, 0x1649, 0x1662, 0x1688, 0x168e,
    0x174c, 0x1752, 0x1757, 0x1777, 0x1877, 0x187d, 0x1911, 0x19d3,
    0x1a77, 0x1a7f, 0x1a9d, 0x1aa2, 0x1ab6, 0x1ac0, 0x1ac6, 0x1ada,
    0x1adf, 0x1ae5, 0x1af3, 0x1b23, 0x1b30, 0x1b38, 0x1b3c, 0x1b52,
    0x1bc9, 0x1bdb, 0x1bdd, 0x1bdf, 0x3164, 0x1c20, 0x1c22, 0x1c24,
    0x1c26, 0x1c28, 0x1c2a, 0x1c48, 0x1c7e, 0x1cc4, 0x1cd2, 0x1cd7,
    0x1ce0, 0x1ce9, 0x1cfb, 0x1d04, 0x1d09, 0x1d29, 0x1d44, 0x1d46,
    0x1d48, 0x1d4a, 0x1d4c, 0x1d4e, 0x1d50, 0x1d52, 0x1d72, 0x1d74,
    0x1d76, 0x1d78, 0x1d7a, 0x1d81, 0x1d83, 0x1d85, 0x1d87, 0x1d96,
    0x1d98, 0x1d9a, 0x1d9c, 0x1d9e, 0x1da0, 0x1da2, 0x1da4, 0x1da6,
    0x1da8, 0x1daa, 0x1dac, 0x1dae, 0x1db0, 0x1db2, 0x1db6, 0x03f4,
    0x1db8, 0x2207, 0x1dba, 0x2202, 0x1dbc, 0x1dc4, 0x03f4, 0x1dc6,
    0x2207, 0x1dc8, 0x2202, 0x1dca, 0x1dd2, 0x03f4, 0x1dd4, 0x2207,
    0x1dd6, 0x2202, 0x1dd8, 0x1de0, 0x03f4, 0x1de2, 0x2207, 0x1de4,
    0x2202, 0x1de6, 0x1dee, 0x03f4, 0x1df0, 0x2207, 0x1df2, 0x2202,
    0x1df4, 0x1dfe, 0x1e00, 0x1e02, 0x1e04, 0x1e06, 0x1e08, 0x1e0e,
    0x1e2b, 0x062d, 0x1e33, 0x1e3f, 0x062c, 0x1e4f, 0x1ebf, 0x1ecb,
    0x1ede, 0x1ef0, 0x1f03, 0x1f05, 0x1f09, 0x1f0f, 0x1f15, 0x1f17,
    0x1f1b, 0x1f1d, 0x1f25, 0x1f28, 0x1f2a, 0x1f30, 0x1f32, 0x30b5,
    0x1f38, 0x1f90, 0x1fa6, 0x1faa, 0x1fac, 0x1fb1, 0x1ffe, 0x200f,
    0x2110, 0x2120, 0x2126, 0x2220, 0x233e,
};

static const uint8_t unicode_decomp_data[9292] = {
    0x20, 0x88, 0x20, 0x84, 0x32, 0x33, 0x20, 0x81,
    0x20, 0xa7, 0x31, 0x6f, 0x31, 0xd0, 0x34, 0x31,
    0xd0, 0x32, 0x33, 0xd0, 0x34, 0x41, 0x80, 0x41,
    0x81, 0x41, 0x82, 0x41, 0x83, 0x41, 0x88, 0x41,
    0x8a, 0x00, 0x00, 0x43, 0xa7, 0x45, 0x80, 0x45,
    0x81, 0x45, 0x82, 0x45, 0x88, 0x49, 0x80, 0x49,
    0x81, 0x49, 0x82, 0x49, 0x88, 0x00, 0x00, 0x4e,
    0x83, 0x4f, 0x80, 0x4f, 0x81, 0x4f, 0x82, 0x4f,
    0x83, 0x4f, 0x88, 0x00, 0x00, 0x00, 0x00, 0x55,
    0x80, 0x55, 0x81, 0x55, 0x82, 0x55, 0x88, 0x59,
    0x81, 0x00, 0x00, 0x00, 0x00, 0x61, 0x80, 0x61,
    0x81, 0x61, 0x82, 0x61, 0x83, 0x61, 0x88, 0x61,
    0x8a, 0x00, 0x00, 0x63, 0xa7, 0x65, 0x80, 0x65,
    0x81, 0x65, 0x82, 0x65, 0x88, 0x69, 0x80, 0x69,
    0x81, 0x69, 0x82, 0x69, 0x88, 0x00, 0x00, 0x6e,
    0x83, 0x6f, 0x80, 0x6f, 0x81, 0x6f, 0x82, 0x6f,
    0x83, 0x6f, 0x88, 0x00, 0x00, 0x00, 0x00, 0x75,
    0x80, 0x75, 0x81, 0x75, 0x82, 0x75, 0x88, 0x79,
    0x81, 0x00, 0x00, 0x79, 0x88, 0x41, 0x84, 0x41,
    0x86, 0x41, 0xa8, 0x43, 0x81, 0x43, 0x82, 0x43,
    0x87, 0x43, 0x8c, 0x44, 0x8c, 0x45, 0x84, 0x45,
    0x86, 0x45, 0x87, 0x45, 0xa8, 0x45, 0x8c, 0x47,
    0x82, 0x47, 0x86, 0x47, 0x87, 0x47, 0xa7, 0x48,
    0x82, 0x49, 0x83, 0x49, 0x84, 0x49, 0x86, 0x49,
    0xa8, 0x49, 0x87, 0x49, 0x4a, 0x69, 0x6a, 0x4a,
    0x82, 0x4b, 0xa7, 0x4c, 0x81, 0x4c, 0xa7, 0x4c,
    0x8c, 0x4c, 0x00, 0x00, 0x6b, 0x20, 0x6b, 0x4e,
    0x81, 0x4e, 0xa7, 0x4e, 0x8c, 0xbc, 0x02, 0x6e,
    0x4f, 0x84, 0x4f, 0x86, 0x4f, 0x8b, 0x52, 0x81,
    0x52, 0xa7, 0x52, 0x8c, 0x53, 0x81, 0x53, 0x82,
    0x53, 0xa7, 0x53, 0x8c, 0x54, 0xa7, 0x54, 0x8c,
    0x55, 0x83, 0x55, 0x84, 0x55, 0x86, 0x55, 0x8a,
    0x55, 0x8b, 0x55, 0xa8, 0x57, 0x82, 0x59, 0x82,
    0x59, 0x88, 0x5a, 0x81, 0x5a, 0x87, 0x5a, 0x8c,
    0x4f, 0x9b, 0x55, 0x9b, 0x44, 0x00, 0x7d, 0x01,
    0x44, 0x00, 0x7e, 0x01, 0x64, 0x00, 0x7e, 0x01,
    0x4c, 0x4a, 0x4c, 0x6a, 0x6c, 0x6a, 0x4e, 0x4a,
    0x4e, 0x6a, 0x6e, 0x6a, 0x41, 0x00, 0x8c, 0x49,
    0x00, 0x8c, 0x4f, 0x00, 0x8c, 0x55, 0x00, 0x8c,
    0xdc, 0x00, 0x84, 0xdc, 0x00, 0x81, 0xdc, 0x00,
    0x8c, 0xdc, 0x00, 0x80, 0xc4, 0x00, 0x84, 0x26,
    0x02, 0x84, 0xc6, 0x00, 0x84, 0x47, 0x8c, 0x4b,
    0x8c, 0x4f, 0xa8, 0xea, 0x01, 0x84, 0xeb, 0x01,
    0x84, 0xb7, 0x01, 0x8c, 0x92, 0x02, 0x8c, 0x6a,
    0x00, 0x8c, 0x44, 0x5a, 0x44, 0x7a, 0x64, 0x7a,
    0x47, 0x81, 0x4e, 0x00, 0x80, 0xc5, 0x00, 0x81,
    0xc6, 0x00, 0x81, 0xd8, 0x00, 0x81, 0x41, 0x8f,
    0x41, 0x91, 0x45, 0x8f, 0x45, 0x91, 0x49, 0x8f,
    0x49, 0x91, 0x4f, 0x8f, 0x4f, 0x91, 0x52, 0x8f,
    0x52, 0x91, 0x55, 0x8f, 0x55, 0x91, 0x53, 0xa6,
    0x54, 0xa6, 0x48, 0x8c, 0x41, 0x00, 0x87, 0x45,
    0x00, 0xa7, 0xd6, 0x00, 0x84, 0xd5, 0x00, 0x84,
    0x4f, 0x00, 0x87, 0x2e, 0x02, 0x84, 0x59, 0x00,
    0x84, 0x68, 0x00, 0x66, 0x02, 0x6a, 0x00, 0x72,
    0x00, 0x79, 0x02, 0x7b, 0x02, 0x81, 0x02, 0x77,
    0x00, 0x79, 0x00, 0x20, 0x86, 0x20, 0x87, 0x20,
    0x8a, 0x20, 0xa8, 0x20, 0x83, 0x20, 0x8b, 0x63,
    0x02, 0x6c, 0x00, 0x73, 0x00, 0x78, 0x00, 0x95,
    0x02, 0x80, 0x81, 0x00, 0x93, 0x88, 0x81, 0x20,
    0xc5, 0x20, 0x81, 0xa8, 0x00, 0x81, 0x91, 0x03,
    0x81, 0x95, 0x03, 0x81, 0x97, 0x03, 0x81, 0x99,
    0x03, 0x81, 0x00, 0x00, 0x00, 0x9f, 0x03, 0x81,
    0x00, 0x00, 0x00, 0xa5, 0x03, 0x81, 0xa9, 0x03,
    0x81, 0xca, 0x03, 0x81, 0x01, 0x03, 0x98, 0x07,
    0xa4, 0x07, 0xb0, 0x00, 0xb4, 0x00, 0xb6, 0x00,
    0xb8, 0x00, 0xca, 0x00, 0x01, 0x03, 0xb8, 0x07,
    0xc4, 0x07, 0xbe, 0x00, 0xc4, 0x00, 0xc8, 0x00,
    0xa5, 0x03, 0x0d, 0x13, 0x00, 0x01, 0x03, 0xd1,
    0x00, 0xd1, 0x07, 0xc6, 0x03, 0xc0, 0x03, 0xba,
    0x03, 0xc1, 0x03, 0xc2, 0x03, 0x00, 0x00, 0x98,
    0x03, 0xb5, 0x03, 0x15, 0x04, 0x80, 0x15, 0x04,
    0x88, 0x00, 0x00, 0x00, 0x13, 0x04, 0x81, 0x06,
    0x04, 0x88, 0x1a, 0x04, 0x81, 0x18, 0x04, 0x80,
    0x23, 0x04, 0x86, 0x18, 0x04, 0x86, 0x38, 0x04,
    0x86, 0x35, 0x04, 0x80, 0x35, 0x04, 0x88, 0x00,
    0x00, 0x00, 0x33, 0x04, 0x81, 0x56, 0x04, 0x88,
    0x3a, 0x04, 0x81, 0x38, 0x04, 0x80, 0x43, 0x04,
    0x86, 0x74, 0x04, 0x8f, 0x16, 0x04, 0x86, 0x10,
    0x04, 0x86, 0x10, 0x04, 0x88, 0x15, 0x04, 0x86,
    0xd8, 0x04, 0x88, 0x16, 0x04, 0x88, 0x17, 0x04,
    0x88, 0x18, 0x04, 0x84, 0x18, 0x04, 0x88, 0x1e,
    0x04, 0x88, 0xe8, 0x04, 0x88, 0x2d, 0x04, 0x88,
    0x23, 0x04, 0x84, 0x23, 0x04, 0x88, 0x23, 0x04,
    0x8b, 0x27, 0x04, 0x88, 0x2b, 0x04, 0x88, 0x65,
    0x05, 0x82, 0x05, 0x27, 0x06, 0x00, 0x2c, 0x00,
    0x2d, 0x21, 0x2d, 0x00, 0x2e, 0x23, 0x2d, 0x27,
    0x06, 0x00, 0x4d, 0x21, 0x4d, 0xa0, 0x4d, 0x23,
    0x4d, 0xd5, 0x06, 0x54, 0x06, 0x00, 0x00, 0x00,
    0x00, 0xc1, 0x06, 0x54, 0x06, 0xd2, 0x06, 0x54,
    0x06, 0x28, 0x09, 0x3c, 0x09, 0x30, 0x09, 0x3c,
    0x09, 0x33, 0x09, 0x3c, 0x09, 0x15, 0x09, 0x00,
    0x27, 0x01, 0x27, 0x02, 0x27, 0x07, 0x27, 0x0c,
    0x27, 0x0d, 0x27, 0x16, 0x27, 0x1a, 0x27, 0xbe,
    0x09, 0x09, 0x00, 0x09, 0x19, 0xa1, 0x09, 0xbc,
    0x09, 0xaf, 0x09, 0xbc, 0x09, 0x32, 0x0a, 0x3c,
    0x0a, 0x38, 0x0a, 0x3c, 0x0a, 0x16, 0x0a, 0x00,
    0x26, 0x01, 0x26, 0x06, 0x26, 0x2b, 0x0a, 0x3c,
    0x0a, 0x47, 0x0b, 0x56, 0x0b, 0x3e, 0x0b, 0x09,
    0x00, 0x09, 0x19, 0x21, 0x0b, 0x3c, 0x0b, 0x92,
    0x0b, 0xd7, 0x0b, 0xbe, 0x0b, 0x08, 0x00, 0x09,
    0x00, 0x08, 0x19, 0x46, 0x0c, 0x56, 0x0c, 0xbf,
    0x0c, 0xd5, 0x0c, 0xc6, 0x0c, 0xd5, 0x0c, 0xc2,
    0x0c, 0x04, 0x00, 0x08, 0x13, 0x3e, 0x0d, 0x08,
    0x00, 0x09, 0x00, 0x08, 0x19, 0xd9, 0x0d, 0xca,
    0x0d, 0xca, 0x0d, 0x0f, 0x05, 0x12, 0x00, 0x0f,
    0x15, 0x4d, 0x0e, 0x32, 0x0e, 0xcd, 0x0e, 0xb2,
    0x0e, 0x99, 0x0e, 0x12, 0x00, 0x12, 0x08, 0x42,
    0x0f, 0xb7, 0x0f, 0x4c, 0x0f, 0xb7, 0x0f, 0x51,
    0x0f, 0xb7, 0x0f, 0x56, 0x0f, 0xb7, 0x0f, 0x5b,
    0x0f, 0xb7, 0x0f, 0x40, 0x0f, 0xb5, 0x0f, 0x71,
    0x0f, 0x72, 0x0f, 0x71, 0x0f, 0x00, 0x03, 0x41,
    0x0f, 0xb2, 0x0f, 0x81, 0x0f, 0xb3, 0x0f, 0x80,
    0x0f, 0xb3, 0x0f, 0x81, 0x0f, 0x71, 0x0f, 0x80,
    0x0f, 0x92, 0x0f, 0xb7, 0x0f, 0x9c, 0x0f, 0xb7,
    0x0f, 0xa1, 0x0f, 0xb7, 0x0f, 0xa6, 0x0f, 0xb7,
    0x0f, 0xab, 0x0f, 0xb7, 0x0f, 0x90, 0x0f, 0xb5,
    0x0f, 0x25, 0x10, 0x2e, 0x10, 0x05, 0x1b, 0x35,
    0x1b, 0x00, 0x00, 0x00, 0x00, 0x07, 0x1b, 0x35,
    0x1b, 0x00, 0x00, 0x00, 0x00, 0x09, 0x1b, 0x35,
    0x1b, 0x00, 0x00, 0x00, 0x00, 0x0b, 0x1b, 0x35,
    0x1b, 0x00, 0x00, 0x00, 0x00, 0x0d, 0x1b, 0x35,
    0x1b, 0x11, 0x1b, 0x35, 0x1b, 0x3a, 0x1b, 0x35,
    0x1b, 0x00, 0x00, 0x00, 0x00, 0x3c, 0x1b, 0x35,
    0x1b, 0x3e, 0x1b, 0x35, 0x1b, 0x42, 0x1b, 0x35,
    0x1b, 0x41, 0x00, 0xc6, 0x00, 0x42, 0x00, 0x00,
    0x00, 0x44, 0x00, 0x45, 0x00, 0x8e, 0x01, 0x47,
    0x00, 0x4f, 0x00, 0x22, 0x02, 0x50, 0x00, 0x52,
    0x00, 0x54, 0x00, 0x55, 0x00, 0x57, 0x00, 0x61,
    0x00, 0x50, 0x02, 0x51, 0x02, 0x02, 0x1d, 0x62,
    0x00, 0x64, 0x00, 0x65, 0x00, 0x59, 0x02, 0x5b,
    0x02, 0x5c, 0x02, 0x67, 0x00, 0x00, 0x00, 0x6b,
    0x00, 0x6d, 0x00, 0x4b, 0x01, 0x6f, 0x00, 0x54,
    0x02, 0x16, 0x1d, 0x17, 0x1d, 0x70, 0x00, 0x74,
    0x00, 0x75, 0x00, 0x1d, 0x1d, 0x6f, 0x02, 0x76,
    0x00, 0x25, 0x1d, 0xb2, 0x03, 0xb3, 0x03, 0xb4,
    0x03, 0xc6, 0x03, 0xc7, 0x03, 0x69, 0x00, 0x72,
    0x00, 0x75, 0x00, 0x76, 0x00, 0xb2, 0x03, 0xb3,
    0x03, 0xc1, 0x03, 0xc6, 0x03, 0xc7, 0x03, 0x52,
    0x02, 0x63, 0x00, 0x55, 0x02, 0xf0, 0x00, 0x5c,
    0x02, 0x66, 0x00, 0x5f, 0x02, 0x61, 0x02, 0x65,
    0x02, 0x68, 0x02, 0x69, 0x02, 0x6a, 0x02, 0x7b,
    0x1d, 0x9d, 0x02, 0x6d, 0x02, 0x85, 0x1d, 0x9f,
    0x02, 0x71, 0x02, 0x70, 0x02, 0x72, 0x02, 0x73,
    0x02, 0x74, 0x02, 0x75, 0x02, 0x78, 0x02, 0x82,
    0x02, 0x83, 0x02, 0xab, 0x01, 0x89, 0x02, 0x8a,
    0x02, 0x1c, 0x1d, 0x8b, 0x02, 0x8c, 0x02, 0x7a,
    0x00, 0x90, 0x02, 0x91, 0x02, 0x92, 0x02, 0xb8,
    0x03, 0x41, 0x00, 0xa5, 0x42, 0x00, 0x87, 0x42,
    0x00, 0xa3, 0x42, 0x00, 0xb1, 0xc7, 0x00, 0x81,
    0x44, 0x00, 0x87, 0x44, 0x00, 0xa3, 0x44, 0x00,
    0xb1, 0x44, 0x00, 0xa7, 0x44, 0x00, 0xad, 0x12,
    0x01, 0x80, 0x12, 0x01, 0x81, 0x45, 0x00, 0xad,
    0x45, 0x00, 0xb0, 0x28, 0x02, 0x86, 0x46, 0x00,
    0x87, 0x47, 0x00, 0x84, 0x48, 0x00, 0x87, 0x48,
    0x00, 0xa3, 0x48, 0x00, 0x88, 0x48, 0x00, 0xa7,
    0x48, 0x00, 0xae, 0x49, 0x00, 0xb0, 0xcf, 0x00,
    0x81, 0x4b, 0x00, 0x81, 0x4b, 0x00, 0xa3, 0x4b,
    0x00, 0xb1, 0x4c, 0x00, 0xa3, 0x36, 0x1e, 0x84,
    0x4c, 0xb1, 0x4c, 0xad, 0x4d, 0x81, 0x4d, 0x87,
    0x4d, 0xa3, 0x4e, 0x87, 0x4e, 0xa3, 0x4e, 0xb1,
    0x4e, 0xad, 0xd5, 0x00, 0x81, 0xd5, 0x00, 0x88,
    0x4c, 0x01, 0x80, 0x4c, 0x01, 0x81, 0x50, 0x00,
    0x81, 0x50, 0x00, 0x87, 0x52, 0x00, 0x87, 0x52,
    0x00, 0xa3, 0x5a, 0x1e, 0x84, 0x52, 0x00, 0xb1,
    0x53, 0x00, 0x87, 0x53, 0x00, 0xa3, 0x5a, 0x01,
    0x87, 0x60, 0x01, 0x87, 0x62, 0x1e, 0x87, 0x54,
    0x00, 0x87, 0x54, 0x00, 0xa3, 0x54, 0x00, 0xb1,
    0x54, 0x00, 0xad, 0x55, 0x00, 0xa4, 0x55, 0x00,
    0xb0, 0x55, 0x00, 0xad, 0x68, 0x01, 0x81, 0x6a,
    0x01, 0x88, 0x56, 0x83, 0x56, 0xa3, 0x57, 0x80,
    0x57, 0x81, 0x57, 0x88, 0x57, 0x87, 0x57, 0xa3,
    0x58, 0x87, 0x58, 0x88, 0x59, 0x87, 0x5a, 0x82,
    0x5a, 0xa3, 0x5a, 0xb1, 0x68, 0xb1, 0x74, 0x88,
    0x77, 0x8a, 0x79, 0x8a, 0x61, 0x00, 0xbe, 0x02,
    0x7f, 0x01, 0x87, 0x41, 0x00, 0xa3, 0x41, 0x00,
    0x89, 0xc2, 0x00, 0x81, 0xc2, 0x00, 0x80, 0xc2,
    0x00, 0x89, 0xc2, 0x00, 0x83, 0xa0, 0x1e, 0x82,
    0x02, 0x01, 0x81, 0x02, 0x01, 0x80, 0x02, 0x01,
    0x89, 0x02, 0x01, 0x83, 0xa0, 0x1e, 0x86, 0x45,
    0x00, 0xa3, 0x45, 0x00, 0x89, 0x45, 0x00, 0x83,
    0xca, 0x00, 0x81, 0xca, 0x00, 0x80, 0xca, 0x00,
    0x89, 0xca, 0x00, 0x83, 0xb8, 0x1e, 0x82, 0x49,
    0x00, 0x89, 0x49, 0x00, 0xa3, 0x4f, 0x00, 0xa3,
    0x4f, 0x00, 0x89, 0xd4, 0x00, 0x81, 0xd4, 0x00,
    0x80, 0xd4, 0x00, 0x89, 0xd4, 0x00, 0x83, 0xcc,
    0x1e, 0x82, 0xa0, 0x01, 0x81, 0xa0, 0x01, 0x80,
    0xa0, 0x01, 0x89, 0xa0, 0x01, 0x83, 0xa0, 0x01,
    0xa3, 0x55, 0x00, 0xa3, 0x55, 0x00, 0x89, 0xaf,
    0x01, 0x81, 0xaf, 0x01, 0x80, 0xaf, 0x01, 0x89,
    0xaf, 0x01, 0x83, 0xaf, 0x01, 0xa3, 0x59, 0x00,
    0x80, 0x59, 0x00, 0xa3, 0x59, 0x00, 0x89, 0x59,
    0x00, 0x83, 0xb1, 0x03, 0x13, 0x03, 0x00, 0x1f,
    0x80, 0x00, 0x1f, 0x81, 0x00, 0x1f, 0xc2, 0x91,
    0x03, 0x13, 0x03, 0x08, 0x1f, 0x80, 0x08, 0x1f,
    0x81, 0x08, 0x1f, 0xc2, 0xb5, 0x03, 0x13, 0x03,
    0x10, 0x1f, 0x80, 0x10, 0x1f, 0x81, 0x95, 0x03,
    0x13, 0x03, 0x18, 0x1f, 0x80, 0x18, 0x1f, 0x81,
    0xb7, 0x03, 0x93, 0xb7, 0x03, 0x94, 0x20, 0x1f,
    0x80, 0x21, 0x1f, 0x80, 0x20, 0x1f, 0x81, 0x21,
    0x1f, 0x81, 0x20, 0x1f, 0xc2, 0x21, 0x1f, 0xc2,
    0x97, 0x03, 0x93, 0x97, 0x03, 0x94, 0x28, 0x1f,
    0x80, 0x29, 0x1f, 0x80, 0x28, 0x1f, 0x81, 0x29,
    0x1f, 0x81, 0x28, 0x1f, 0xc2, 0x29, 0x1f, 0xc2,
    0xb9, 0x03, 0x93, 0xb9, 0x03, 0x94, 0x30, 0x1f,
    0x80, 0x31, 0x1f, 0x80, 0x30, 0x1f, 0x81, 0x31,
    0x1f, 0x81, 0x30, 0x1f, 0xc2, 0x31, 0x1f, 0xc2,
    0x99, 0x03, 0x93, 0x99, 0x03, 0x94, 0x38, 0x1f,
    0x80, 0x39, 0x1f, 0x80, 0x38, 0x1f, 0x81, 0x39,
    0x1f, 0x81, 0x38, 0x1f, 0xc2, 0x39, 0x1f, 0xc2,
    0xbf, 0x03, 0x93, 0xbf, 0x03, 0x94, 0x40, 0x1f,
    0x80, 0x40, 0x1f, 0x81, 0x9f, 0x03, 0x13, 0x03,
    0x48, 0x1f, 0x80, 0x48, 0x1f, 0x81, 0xc5, 0x03,
    0x13, 0x03, 0x50, 0x1f, 0x80, 0x50, 0x1f, 0x81,
    0x50, 0x1f, 0xc2, 0xa5, 0x03, 0x94, 0x00, 0x00,
    0x00, 0x59, 0x1f, 0x80, 0x00, 0x00, 0x00, 0x59,
    0x1f, 0x81, 0x00, 0x00, 0x00, 0x59, 0x1f, 0xc2,
    0xc9, 0x03, 0x93, 0xc9, 0x03, 0x94, 0x60, 0x1f,
    0x80, 0x61, 0x1f, 0x80, 0x60, 0x1f, 0x81, 0x61,
    0x1f, 0x81, 0x60, 0x1f, 0xc2, 0x61, 0x1f, 0xc2,
    0xa9, 0x03, 0x93, 0xa9, 0x03, 0x94, 0x68, 0x1f,
    0x80, 0x69, 0x1f, 0x80, 0x68, 0x1f, 0x81, 0x69,
    0x1f, 0x81, 0x68, 0x1f, 0xc2, 0x69, 0x1f, 0xc2,
    0xb1, 0x03, 0x80, 0xb5, 0x03, 0x80, 0xb7, 0x03,
    0x80, 0xb9, 0x03, 0x80, 0xbf, 0x03, 0x80, 0xc5,
    0x03, 0x80, 0xc9, 0x03, 0x80, 0x00, 0x1f, 0x45,
    0x03, 0x20, 0x1f, 0x45, 0x03, 0x60, 0x1f, 0x45,
    0x03, 0xb1, 0x03, 0x86, 0xb1, 0x03, 0x84, 0x70,
    0x1f, 0xc5, 0xb1, 0x03, 0xc5, 0xac, 0x03, 0xc5,
    0x00, 0x00, 0x00, 0xb1, 0x03, 0xc2, 0xb6, 0x1f,
    0xc5, 0x91, 0x03, 0x86, 0x91, 0x03, 0x84, 0x91,
    0x03, 0x80, 0x91, 0x03, 0xc5, 0x20, 0x93, 0x20,
    0x93, 0x20, 0xc2, 0xa8, 0x00, 0xc2, 0x74, 0x1f,
    0xc5, 0xb7, 0x03, 0xc5, 0xae, 0x03, 0xc5, 0x00,
    0x00, 0x00, 0xb7, 0x03, 0xc2, 0xc6, 0x1f, 0xc5,
    0x95, 0x03, 0x80, 0x97, 0x03, 0x80, 0x97, 0x03,
    0xc5, 0xbf, 0x1f, 0x80, 0xbf, 0x1f, 0x81, 0xbf,
    0x1f, 0xc2, 0xb9, 0x03, 0x86, 0xb9, 0x03, 0x84,
    0xca, 0x03, 0x80, 0x00, 0x03, 0xb9, 0x42, 0xca,
    0x42, 0x99, 0x06, 0x99, 0x04, 0x99, 0x00, 0xfe,
    0x1f, 0x80, 0xfe, 0x1f, 0x81, 0xfe, 0x1f, 0xc2,
    0xc5, 0x03, 0x86, 0xc5, 0x03, 0x84, 0xcb, 0x03,
    0x80, 0x00, 0x03, 0xc1, 0x13, 0xc1, 0x14, 0xc5,
    0x42, 0xcb, 0x42, 0xa5, 0x06, 0xa5, 0x04, 0xa5,
    0x00, 0xa1, 0x03, 0x94, 0xa8, 0x00, 0x80, 0x85,
    0x03, 0x60, 0x00, 0x7c, 0x1f, 0xc5, 0xc9, 0x03,
    0xc5, 0xce, 0x03, 0xc5, 0x00, 0x00, 0x00, 0xc9,
    0x03, 0xc2, 0xf6, 0x1f, 0xc5, 0x9f, 0x03, 0x80,
    0xa9, 0x03, 0x80, 0xa9, 0x03, 0xc5, 0x20, 0x94,
    0x02, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
    0x20, 0x20, 0x20, 0x20, 0xb3, 0x2e, 0x2e, 0x2e,
    0x2e, 0x2e, 0x32, 0x20, 0x32, 0x20, 0x32, 0x20,
    0x00, 0x00, 0x00, 0x35, 0x20, 0x35, 0x20, 0x35,
    0x20, 0x00, 0x00, 0x00, 0x21, 0x21, 0x00, 0x00,
    0x20, 0x85, 0x3f, 0x3f, 0x3f, 0x21, 0x21, 0x3f,
    0x32, 0x20, 0x00, 0x00, 0x00, 0x00, 0x30, 0x69,
    0x00, 0x00, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
    0x2b, 0x3d, 0x28, 0x29, 0x6e, 0x30, 0x00, 0x2b,
    0x00, 0x12, 0x22, 0x3d, 0x00, 0x28, 0x00, 0x29,
    0x00, 0x00, 0x00, 0x61, 0x00, 0x65, 0x00, 0x6f,
    0x00, 0x78, 0x00, 0x59, 0x02, 0x68, 0x6b, 0x6c,
    0x6d, 0x6e, 0x70, 0x73, 0x74, 0x52, 0x73, 0x61,
    0x2f, 0x63, 0x61, 0x2f, 0x73, 0xb0, 0x00, 0x43,
    0x63, 0x2f, 0x6f, 0x63, 0x2f, 0x75, 0xb0, 0x00,
    0x46, 0x48, 0x00, 0x1f, 0x00, 0x00, 0x00, 0x20,
    0xdf, 0x01, 0x01, 0x04, 0x24, 0x4e, 0x6f, 0x50,
    0x51, 0x52, 0x52, 0x52, 0x53, 0x4d, 0x54, 0x45,
    0x4c, 0x54, 0x4d, 0x4b, 0x00, 0xc5, 0x00, 0x42,
    0x43, 0x00, 0x65, 0x45, 0x46, 0x00, 0x4d, 0x6f,
    0xd0, 0x05, 0x46, 0x41, 0x58, 0xc0, 0x03, 0xb3,
    0x03, 0x93, 0x03, 0xa0, 0x03, 0x11, 0x22, 0x44,
    0x64, 0x65, 0x69, 0x6a, 0x31, 0xd0, 0x37, 0x31,
    0xd0, 0x39, 0x31, 0xd0, 0x31, 0x30, 0x31, 0xd0,
    0x33, 0x32, 0xd0, 0x33, 0x31, 0xd0, 0x35, 0x32,
    0xd0, 0x35, 0x33, 0xd0, 0x35, 0x34, 0xd0, 0x35,
    0x31, 0xd0, 0x36, 0x35, 0xd0, 0x36, 0x31, 0xd0,
    0x38, 0x33, 0xd0, 0x38, 0x35, 0xd0, 0x38, 0x37,
    0xd0, 0x38, 0x31, 0xd0, 0x49, 0x49, 0x49, 0x49,
    0x49, 0x49, 0x56, 0x56, 0x49, 0x56, 0x49, 0x49,
    0x56, 0x49, 0x49, 0x49, 0x49, 0x58, 0x58, 0x49,
    0x58, 0x49, 0x49, 0x4c, 0x43, 0x44, 0x4d, 0x69,
    0x69, 0x69, 0x69, 0x69, 0x69, 0x69, 0x76, 0x76,
    0x69, 0x76, 0x69, 0x69, 0x76, 0x69, 0x69, 0x69,
    0x69, 0x78, 0x78, 0x69, 0x78, 0x69, 0x69, 0x6c,
    0x63, 0x64, 0x6d, 0x30, 0xd0, 0x33, 0x90, 0x21,
    0xb8, 0x92, 0x21, 0xb8, 0x94, 0x21, 0xb8, 0xd0,
    0x21, 0xb8, 0xd4, 0x21, 0xb8, 0xd2, 0x21, 0xb8,
    0x03, 0x22, 0xb8, 0x08, 0x22, 0xb8, 0x0b, 0x22,
    0xb8, 0x23, 0x22, 0xb8, 0x00, 0x00, 0x00, 0x25,
    0x22, 0xb8, 0x2b, 0x22, 0x2b, 0x22, 0x2b, 0x22,
    0x00, 0x00, 0x00, 0x2e, 0x22, 0x2e, 0x22, 0x2e,
    0x22, 0x00, 0x00, 0x00, 0x3c, 0x22, 0xb8, 0x43,
    0x22, 0xb8, 0x45, 0x22, 0xb8, 0x00, 0x00, 0x00,
    0x48, 0x22, 0xb8, 0x3d, 0x00, 0xb8, 0x00, 0x00,
    0x00, 0x61, 0x22, 0xb8, 0x4d, 0x22, 0xb8, 0x3c,
    0x00, 0xb8, 0x3e, 0x00, 0xb8, 0x64, 0x22, 0xb8,
    0x65, 0x22, 0xb8, 0x72, 0x22, 0xb8, 0x76, 0x22,
    0xb8, 0x7a, 0x22, 0xb8, 0x82, 0x22, 0xb8, 0x86,
    0x22, 0xb8, 0xa2, 0x22, 0xb8, 0xa8, 0x22, 0xb8,
    0xa9, 0x22, 0xb8, 0xab, 0x22, 0xb8, 0x7c, 0x22,
    0xb8, 0x91, 0x22, 0xb8, 0xb2, 0x22, 0x38, 0x03,
    0x08, 0x30, 0x31, 0x00, 0x31, 0x00, 0x30, 0x00,
    0x32, 0x30, 0x28, 0x00, 0x31, 0x00, 0x29, 0x00,
    0x28, 0x00, 0x31, 0x00, 0x30, 0x00, 0x29, 0x00,
    0x28, 0x32, 0x30, 0x29, 0x31, 0x00, 0x2e, 0x00,
    0x31, 0x00, 0x30, 0x00, 0x2e, 0x00, 0x32, 0x30,
    0x2e, 0x28, 0x00, 0x61, 0x00, 0x29, 0x00, 0x41,
    0x00, 0x61, 0x00, 0x2b, 0x22, 0x00, 0x00, 0x00,
    0x00, 0x3a, 0x3a, 0x3d, 0x3d, 0x3d, 0x3d, 0x3d,
    0x3d, 0xdd, 0x2a, 0xb8, 0x6a, 0x56, 0x00, 0x4e,
    0x00, 0x28, 0x36, 0x3f, 0x59, 0x85, 0x8c, 0xa0,
    0xba, 0x3f, 0x51, 0x00, 0x26, 0x2c, 0x43, 0x57,
    0x6c, 0xa1, 0xb6, 0xc1, 0x9b, 0x52, 0x00, 0x5e,
    0x7a, 0x7f, 0x9d, 0xa6, 0xc1, 0xce, 0xe7, 0xb6,
    0x53, 0xc8, 0x53, 0xe3, 0x53, 0xd7, 0x56, 0x1f,
    0x57, 0xeb, 0x58, 0x02, 0x59, 0x0a, 0x59, 0x15,
    0x59, 0x27, 0x59, 0x73, 0x59, 0x50, 0x5b, 0x80,
    0x5b, 0xf8, 0x5b, 0x0f, 0x5c, 0x22, 0x5c, 0x38,
    0x5c, 0x6e, 0x5c, 0x71, 0x5c, 0xdb, 0x5d, 0xe5,
    0x5d, 0xf1, 0x5d, 0xfe, 0x5d, 0x72, 0x5e, 0x7a,
    0x5e, 0x7f, 0x5e, 0xf4, 0x5e, 0xfe, 0x5e, 0x0b,
    0x5f, 0x13, 0x5f, 0x50, 0x5f, 0x61, 0x5f, 0x73,
    0x5f, 0xc3, 0x5f, 0x08, 0x62, 0x36, 0x62, 0x4b,
    0x62, 0x2f, 0x65, 0x34, 0x65, 0x87, 0x65, 0x97,
    0x65, 0xa4, 0x65, 0xb9, 0x65, 0xe0, 0x65, 0xe5,
    0x65, 0xf0, 0x66, 0x08, 0x67, 0x28, 0x67, 0x20,
    0x6b, 0x62, 0x6b, 0x79, 0x6b, 0xb3, 0x6b, 0xcb,
    0x6b, 0xd4, 0x6b, 0xdb, 0x6b, 0x0f, 0x6c, 0x14,
    0x6c, 0x34, 0x6c, 0x6b, 0x70, 0x2a, 0x72, 0x36,
    0x72, 0x3b, 0x72, 0x3f, 0x72, 0x47, 0x72, 0x59,
    0x72, 0x5b, 0x72, 0xac, 0x72, 0x84, 0x73, 0x89,
    0x73, 0xdc, 0x74, 0xe6, 0x74, 0x18, 0x75, 0x1f,
    0x75, 0x28, 0x75, 0x30, 0x75, 0x8b, 0x75, 0x92,
    0x75, 0x76, 0x76, 0x7d, 0x76, 0xae, 0x76, 0xbf,
    0x76, 0xee, 0x76, 0xdb, 0x77, 0xe2, 0x77, 0xf3,
    0x77, 0x3a, 0x79, 0xb8, 0x79, 0xbe, 0x79, 0x74,
    0x7a, 0xcb, 0x7a, 0xf9, 0x7a, 0x73, 0x7c, 0xf8,
    0x7c, 0x36, 0x7f, 0x51, 0x7f, 0x8a, 0x7f, 0xbd,
    0x7f, 0x01, 0x80, 0x0c, 0x80, 0x12, 0x80, 0x33,
    0x80, 0x7f, 0x80, 0x89, 0x80, 0xe3, 0x81, 0x00,
    0x07, 0x10, 0x19, 0x29, 0x38, 0x3c, 0x8b, 0x8f,
    0x95, 0x4d, 0x86, 0x6b, 0x86, 0x40, 0x88, 0x4c,
    0x88, 0x63, 0x88, 0x7e, 0x89, 0x8b, 0x89, 0xd2,
    0x89, 0x00, 0x8a, 0x37, 0x8c, 0x46, 0x8c, 0x55,
    0x8c, 0x78, 0x8c, 0x9d, 0x8c, 0x64, 0x8d, 0x70,
    0x8d, 0xb3, 0x8d, 0xab, 0x8e, 0xca, 0x8e, 0x9b,
    0x8f, 0xb0, 0x8f, 0xb5, 0x8f, 0x91, 0x90, 0x49,
    0x91, 0xc6, 0x91, 0xcc, 0x91, 0xd1, 0x91, 0x77,
    0x95, 0x80, 0x95, 0x1c, 0x96, 0xb6, 0x96, 0xb9,
    0x96, 0xe8, 0x96, 0x51, 0x97, 0x5e, 0x97, 0x62,
    0x97, 0x69, 0x97, 0xcb, 0x97, 0xed, 0x97, 0xf3,
    0x97, 0x01, 0x98, 0xa8, 0x98, 0xdb, 0x98, 0xdf,
    0x98, 0x96, 0x99, 0x99, 0x99, 0xac, 0x99, 0xa8,
    0x9a, 0xd8, 0x9a, 0xdf, 0x9a, 0x25, 0x9b, 0x2f,
    0x9b, 0x32, 0x9b, 0x3c, 0x9b, 0x5a, 0x9b, 0xe5,
    0x9c, 0x75, 0x9e, 0x7f, 0x9e, 0xa5, 0x9e, 0x00,
    0x16, 0x1e, 0x28, 0x2c, 0x54, 0x58, 0x69, 0x6e,
    0x7b, 0x96, 0xa5, 0xad, 0xe8, 0xf7, 0xfb, 0x12,
    0x30, 0x00, 0x00, 0x41, 0x53, 0x44, 0x53, 0x45,
    0x53, 0x4b, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x4d, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x4f, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x51, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x53, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x55, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x57, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x59, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x5b, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x5d, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x5f, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0x61, 0x30, 0x99, 0x30, 0x64, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x66, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0x68, 0x30, 0x99,
    0x30, 0x6f, 0x30, 0x99, 0x30, 0x72, 0x30, 0x99,
    0x30, 0x75, 0x30, 0x99, 0x30, 0x78, 0x30, 0x99,
    0x30, 0x7b, 0x30, 0x99, 0x30, 0x46, 0x30, 0x99,
    0x30, 0x20, 0x00, 0x99, 0x30, 0x9d, 0x30, 0x99,
    0x30, 0x88, 0x30, 0x8a, 0x30, 0xab, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xad, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xaf, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xb1, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xb3, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xb5, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xb7, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xbb, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xbd, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xbf, 0x30, 0x99,
    0x30, 0x00, 0x00, 0x00, 0x00, 0xc1, 0x30, 0x99,
    0x30, 0xc4, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0xc6, 0x30, 0x99, 0x30, 0x00, 0x00, 0x00,
    0x00, 0xc8, 0x30, 0x99, 0x30, 0xcf, 0x30, 0x99,
    0x30, 0xd2, 0x30, 0x99, 0x30, 0xd5, 0x30, 0x99,
    0x30, 0xd8, 0x30, 0x99, 0x30, 0xdb, 0x30, 0x99,
    0x30, 0xa6, 0x30, 0x99, 0x30, 0xef, 0x30, 0x99,
    0x30, 0xfd, 0x30, 0x99, 0x30, 0xb3, 0x30, 0xc8,
    0x30, 0x00, 0x11, 0x00, 0x01, 0xaa, 0x02, 0xac,
    0xad, 0x03, 0x04, 0x05, 0xb0, 0xb1, 0xb2, 0xb3,
    0xb4, 0xb5, 0x1a, 0x06, 0x07, 0x08, 0x21, 0x09,
    0x11, 0x61, 0x11, 0x14, 0x11, 0x4c, 0x00, 0x01,
    0xb3, 0xb4, 0xb8, 0xba, 0xbf, 0xc3, 0xc5, 0x08,
    0xc9, 0xcb, 0x09, 0x0a, 0x0c, 0x0e, 0x0f, 0x13,
    0x15, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1e, 0x22,
    0x2c, 0x33, 0x38, 0xdd, 0xde, 0x43, 0x44, 0x45,
    0x70, 0x71, 0x74, 0x7d, 0x7e, 0x80, 0x8a, 0x8d,
    0x00, 0x4e, 0x8c, 0x4e, 0x09, 0x4e, 0xdb, 0x56,
    0x0a, 0x4e, 0x2d, 0x4e, 0x0b, 0x4e, 0x32, 0x75,
    0x59, 0x4e, 0x19, 0x4e, 0x01, 0x4e, 0x29, 0x59,
    0x30, 0x57, 0xba, 0x4e, 0x28, 0x00, 0x29, 0x00,
    0x00, 0x11, 0x02, 0x11, 0x03, 0x11, 0x05, 0x11,
    0x06, 0x11, 0x07, 0x11, 0x09, 0x11, 0x0b, 0x11,
    0x0c, 0x11, 0x0e, 0x11, 0x0f, 0x11, 0x10, 0x11,
    0x11, 0x11, 0x12, 0x11, 0x28, 0x00, 0x00, 0x11,
    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x02, 0x11,
    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x05, 0x11,
    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x09, 0x11,
    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x0b, 0x11,
    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x0e, 0x11,
    0x61, 0x11, 0x29, 0x00, 0x28, 0x00, 0x0c, 0x11,
    0x6e, 0x11, 0x29, 0x00, 0x28, 0x00, 0x0b, 0x11,
    0x69, 0x11, 0x0c, 0x11, 0x65, 0x11, 0xab, 0x11,
    0x29, 0x00, 0x28, 0x00, 0x0b, 0x11, 0x69, 0x11,
    0x12, 0x11, 0x6e, 0x11, 0x29, 0x00, 0x28, 0x00,
    0x29, 0x00, 0x00, 0x4e, 0x8c, 0x4e, 0x09, 0x4e,
    0xdb, 0x56, 0x94, 0x4e, 0x6d, 0x51, 0x03, 0x4e,
    0x6b, 0x51, 0x5d, 0x4e, 0x41, 0x53, 0x08, 0x67,
    0x6b, 0x70, 0x34, 0x6c, 0x28, 0x67, 0xd1, 0x91,
    0x1f, 0x57, 0xe5, 0x65, 0x2a, 0x68, 0x09, 0x67,
    0x3e, 0x79, 0x0d, 0x54, 0x79, 0x72, 0xa1, 0x8c,
    0x5d, 0x79, 0xb4, 0x52, 0xe3, 0x4e, 0x7c, 0x54,
    0x66, 0x5b, 0xe3, 0x76, 0x01, 0x4f, 0xc7, 0x8c,
    0x54, 0x53, 0x6d, 0x79, 0x11, 0x4f, 0xea, 0x81,
    0xf3, 0x81, 0x4f, 0x55, 0x7c, 0x5e, 0x87, 0x65,
    0x8f, 0x7b, 0x50, 0x54, 0x45, 0x32, 0x00, 0x31,
    0x00, 0x33, 0x00, 0x30, 0x00, 0x00, 0x11, 0x00,
    0x02, 0x03, 0x05, 0x06, 0x07, 0x09, 0x0b, 0x0c,
    0x0e, 0x0f, 0x10, 0x11, 0x12, 0x00, 0x11, 0x00,
    0x61, 0x02, 0x61, 0x03, 0x61, 0x05, 0x61, 0x06,
    0x61, 0x07, 0x61, 0x09, 0x61, 0x0b, 0x61, 0x0c,
    0x61, 0x0e, 0x11, 0x61, 0x11, 0x00, 0x11, 0x0e,
    0x61, 0xb7, 0x00, 0x69, 0x0b, 0x11, 0x01, 0x63,
    0x00, 0x69, 0x0b, 0x11, 0x6e, 0x11, 0x00, 0x4e,
    0x8c, 0x4e, 0x09, 0x4e, 0xdb, 0x56, 0x94, 0x4e,
    0x6d, 0x51, 0x03, 0x4e, 0x6b, 0x51, 0x5d, 0x4e,
    0x41, 0x53, 0x08, 0x67, 0x6b, 0x70, 0x34, 0x6c,
    0x28, 0x67, 0xd1, 0x91, 0x1f, 0x57, 0xe5, 0x65,
    0x2a, 0x68, 0x09, 0x67, 0x3e, 0x79, 0x0d, 0x54,
    0x79, 0x72, 0xa1, 0x8c, 0x5d, 0x79, 0xb4, 0x52,
    0xd8, 0x79, 0x37, 0x75, 0x73, 0x59, 0x69, 0x90,
    0x2a, 0x51, 0x70, 0x53, 0xe8, 0x6c, 0x05, 0x98,
    0x11, 0x4f, 0x99, 0x51, 0x63, 0x6b, 0x0a, 0x4e,
    0x2d, 0x4e, 0x0b, 0x4e, 0xe6, 0x5d, 0xf3, 0x53,
    0x3b, 0x53, 0x97, 0x5b, 0x66, 0x5b, 0xe3, 0x76,
    0x01, 0x4f, 0xc7, 0x8c, 0x54, 0x53, 0x1c, 0x59,
    0x33, 0x00, 0x36, 0x00, 0x34, 0x00, 0x30, 0x00,
    0x35, 0x30, 0x31, 0x00, 0x08, 0x67, 0x31, 0x00,
    0x30, 0x00, 0x08, 0x67, 0x48, 0x67, 0x65, 0x72,
    0x67, 0x65, 0x56, 0x4c, 0x54, 0x44, 0xa2, 0x30,
    0x00, 0x02, 0x04, 0x06, 0x08, 0x09, 0x0b, 0x0d,
    0x0f, 0x11, 0x13, 0x15, 0x17, 0x19, 0x1b, 0x1d,
    0x1f, 0x22, 0x24, 0x26, 0x28, 0x29, 0x2a, 0x2b,
    0x2c, 0x2d, 0x30, 0x33, 0x36, 0x39, 0x3c, 0x3d,
    0x3e, 0x3f, 0x40, 0x42, 0x44, 0x46, 0x47, 0x48,
    0x49, 0x4a, 0x4b, 0x4d, 0x4e, 0x4f, 0x50, 0xe4,
    0x4e, 0x8c, 0x54, 0xa1, 0x30, 0x01, 0x30, 0x5b,
    0x27, 0x01, 0x4a, 0x34, 0x00, 0x01, 0x52, 0x39,
    0x01, 0xa2, 0x30, 0x00, 0x5a, 0x49, 0xa4, 0x30,
    0x00, 0x27, 0x4f, 0x0c, 0xa4, 0x30, 0x00, 0x4f,
    0x1d, 0x02, 0x05, 0x4f, 0xa8, 0x30, 0x00, 0x11,
    0x07, 0x54, 0x21, 0xa8, 0x30, 0x00, 0x54, 0x03,
    0x54, 0xa4, 0x30, 0x06, 0x4f, 0x15, 0x06, 0x58,
    0x3c, 0x07, 0x00, 0x46, 0xab, 0x30, 0x00, 0x3e,
    0x18, 0x1d, 0x00, 0x42, 0x3f, 0x51, 0xac, 0x30,
    0x00, 0x41, 0x47, 0x00, 0x47, 0x32, 0xae, 0x30,
    0xac, 0x30, 0xae, 0x30, 0x00, 0x1d, 0x4e, 0xad,
    0x30, 0x00, 0x38, 0x3d, 0x4f, 0x01, 0x3e, 0x13,
    0x4f, 0xad, 0x30, 0xed, 0x30, 0xad, 0x30, 0x00,
    0x40, 0x03, 0x3c, 0x33, 0xad, 0x30, 0x00, 0x40,
    0x34, 0x4f, 0x1b, 0x3e, 0xad, 0x30, 0x00, 0x40,
    0x42, 0x16, 0x1b, 0xb0, 0x30, 0x00, 0x39, 0x30,
    0xa4, 0x30, 0x0c, 0x45, 0x3c, 0x24, 0x4f, 0x0b,
    0x47, 0x18, 0x00, 0x49, 0xaf, 0x30, 0x00, 0x3e,
    0x4d, 0x1e, 0xb1, 0x30, 0x00, 0x4b, 0x08, 0x02,
    0x3a, 0x19, 0x02, 0x4b, 0x2c, 0xa4, 0x30, 0x11,
    0x00, 0x0b, 0x47, 0xb5, 0x30, 0x00, 0x3e, 0x0c,
    0x47, 0x2b, 0xb0, 0x30, 0x07, 0x3a, 0x43, 0x00,
    0xb9, 0x30, 0x02, 0x3a, 0x08, 0x02, 0x3a, 0x0f,
    0x07, 0x43, 0x00, 0xb7, 0x30, 0x10, 0x00, 0x12,
    0x34, 0x11, 0x3c, 0x13, 0x17, 0xa4, 0x30, 0x2a,
    0x1f, 0x24, 0x2b, 0x00, 0x20, 0xbb, 0x30, 0x16,
    0x41, 0x00, 0x38, 0x0d, 0xc4, 0x30, 0x0d, 0x38,
    0x00, 0xd0, 0x30, 0x00, 0x2c, 0x1c, 0x1b, 0xa2,
    0x30, 0x32, 0x00, 0x17, 0x26, 0x49, 0xaf, 0x30,
    0x25, 0x00, 0x3c, 0xb3, 0x30, 0x21, 0x00, 0x20,
    0x38, 0xa1, 0x30, 0x34, 0x00, 0x48, 0x22, 0x28,
    0xa3, 0x30, 0x32, 0x00, 0x59, 0x25, 0xa7, 0x30,
    0x2f, 0x1c, 0x10, 0x00, 0x44, 0xd5, 0x30, 0x00,
    0x14, 0x1e, 0xaf, 0x30, 0x29, 0x00, 0x10, 0x4d,
    0x3c, 0xda, 0x30, 0xbd, 0x30, 0xb8, 0x30, 0x22,
    0x13, 0x1a, 0x20, 0x33, 0x0c, 0x22, 0x3b, 0x01,
    0x22, 0x44, 0x00, 0x21, 0x44, 0x07, 0xa4, 0x30,
    0x39, 0x00, 0x4f, 0x24, 0xc8, 0x30, 0x14, 0x23,
    0x00, 0xdb, 0x30, 0xf3, 0x30, 0xc9, 0x30, 0x14,
    0x2a, 0x00, 0x12, 0x33, 0x22, 0x12, 0x33, 0x2a,
    0xa4, 0x30, 0x3a, 0x00, 0x0b, 0x49, 0xa4, 0x30,
    0x3a, 0x00, 0x47, 0x3a, 0x1f, 0x2b, 0x3a, 0x47,
    0x0b, 0xb7, 0x30, 0x27, 0x3c, 0x00, 0x30, 0x3c,
    0xaf, 0x30, 0x30, 0x00, 0x3e, 0x44, 0xdf, 0x30,
    0xea, 0x30, 0xd0, 0x30, 0x0f, 0x1a, 0x00, 0x2c,
    0x1b, 0xe1, 0x30, 0xac, 0x30, 0xac, 0x30, 0x35,
    0x00, 0x1c, 0x47, 0x35, 0x50, 0x1c, 0x3f, 0xa2,
    0x30, 0x42, 0x5a, 0x27, 0x42, 0x5a, 0x49, 0x44,
    0x00, 0x51, 0xc3, 0x30, 0x27, 0x00, 0x05, 0x28,
    0xea, 0x30, 0xe9, 0x30, 0xd4, 0x30, 0x17, 0x00,
    0x28, 0xd6, 0x30, 0x15, 0x26, 0x00, 0x15, 0xec,
    0x30, 0xe0, 0x30, 0xb2, 0x30, 0x3a, 0x41, 0x16,
    0x00, 0x41, 0xc3, 0x30, 0x2c, 0x00, 0x05, 0x30,
    0x00, 0xb9, 0x70, 0x31, 0x00, 0x30, 0x00, 0xb9,
    0x70, 0x32, 0x00, 0x30, 0x00, 0xb9, 0x70, 0x68,
    0x50, 0x61, 0x64, 0x61, 0x41, 0x55, 0x62, 0x61,
    0x72, 0x6f, 0x56, 0x70, 0x63, 0x64, 0x6d, 0x64,
    0x00, 0x6d, 0x00, 0xb2, 0x00, 0x49, 0x00, 0x55,
    0x00, 0x73, 0x5e, 0x10, 0x62, 0x2d, 0x66, 0x8c,
    0x54, 0x27, 0x59, 0x63, 0x6b, 0x0e, 0x66, 0xbb,
    0x6c, 0x2a, 0x68, 0x0f, 0x5f, 0x1a, 0x4f, 0x3e,
    0x79, 0x70, 0x00, 0x41, 0x6e, 0x00, 0x41, 0xbc,
    0x03, 0x41, 0x6d, 0x00, 0x41, 0x6b, 0x00, 0x41,
    0x4b, 0x00, 0x42, 0x4d, 0x00, 0x42, 0x47, 0x00,
    0x42, 0x63, 0x61, 0x6c, 0x6b, 0x63, 0x61, 0x6c,
    0x70, 0x00, 0x46, 0x6e, 0x00, 0x46, 0xbc, 0x03,
    0x46, 0xbc, 0x03, 0x67, 0x6d, 0x00, 0x67, 0x6b,
    0x00, 0x67, 0x48, 0x00, 0x7a, 0x6b, 0x48, 0x7a,
    0x4d, 0x48, 0x7a, 0x47, 0x48, 0x7a, 0x54, 0x48,
    0x7a, 0xbc, 0x03, 0x13, 0x21, 0x6d, 0x00, 0x13,
    0x21, 0x64, 0x00, 0x13, 0x21, 0x6b, 0x00, 0x13,
    0x21, 0x66, 0x00, 0x6d, 0x6e, 0x00, 0x6d, 0xbc,
    0x03, 0x6d, 0x6d, 0x00, 0x6d, 0x63, 0x00, 0x6d,
    0x6b, 0x00, 0x6d, 0x63, 0x00, 0x0a, 0x0a, 0x4f,
    0x00, 0x0a, 0x4f, 0x6d, 0x00, 0xb2, 0x00, 0x63,
    0x00, 0x08, 0x0a, 0x4f, 0x0a, 0x0a, 0x50, 0x00,
    0x0a, 0x50, 0x6d, 0x00, 0xb3, 0x00, 0x6b, 0x00,
    0x6d, 0x00, 0xb3, 0x00, 0x6d, 0x00, 0x15, 0x22,
    0x73, 0x00, 0x6d, 0x00, 0x15, 0x22, 0x73, 0x00,
    0xb2, 0x00, 0x50, 0x61, 0x6b, 0x50, 0x61, 0x4d,
    0x50, 0x61, 0x47, 0x50, 0x61, 0x72, 0x61, 0x64,
    0x72, 0x61, 0x64, 0xd1, 0x73, 0x72, 0x00, 0x61,
    0x00, 0x64, 0x00, 0x15, 0x22, 0x73, 0x00, 0xb2,
    0x00, 0x70, 0x00, 0x73, 0x6e, 0x00, 0x73, 0xbc,
    0x03, 0x73, 0x6d, 0x00, 0x73, 0x70, 0x00, 0x56,
    0x6e, 0x00, 0x56, 0xbc, 0x03, 0x56, 0x6d, 0x00,
    0x56, 0x6b, 0x00, 0x56, 0x4d, 0x00, 0x56, 0x70,
    0x00, 0x57, 0x6e, 0x00, 0x57, 0xbc, 0x03, 0x57,
    0x6d, 0x00, 0x57, 0x6b, 0x00, 0x57, 0x4d, 0x00,
    0x57, 0x6b, 0x00, 0xa9, 0x03, 0x4d, 0x00, 0xa9,
    0x03, 0x61, 0x2e, 0x6d, 0x2e, 0x42, 0x71, 0x63,
    0x63, 0x63, 0x64, 0x43, 0xd1, 0x6b, 0x67, 0x43,
    0x6f, 0x2e, 0x64, 0x42, 0x47, 0x79, 0x68, 0x61,
    0x48, 0x50, 0x69, 0x6e, 0x4b, 0x4b, 0x4b, 0x4d,
    0x6b, 0x74, 0x6c, 0x6d, 0x6c, 0x6e, 0x6c, 0x6f,
    0x67, 0x6c, 0x78, 0x6d, 0x62, 0x6d, 0x69, 0x6c,
    0x6d, 0x6f, 0x6c, 0x50, 0x48, 0x70, 0x2e, 0x6d,
    0x2e, 0x50, 0x50, 0x4d, 0x50, 0x52, 0x73, 0x72,
    0x53, 0x76, 0x57, 0x62, 0x56, 0xd1, 0x6d, 0x41,
    0xd1, 0x6d, 0x31, 0x00, 0xe5, 0x65, 0x31, 0x00,
    0x30, 0x00, 0xe5, 0x65, 0x32, 0x00, 0x30, 0x00,
    0xe5, 0x65, 0x33, 0x00, 0x30, 0x00, 0xe5, 0x65,
    0x67, 0x61, 0x6c, 0x4a, 0x04, 0x4c, 0x04, 0x43,
    0x46, 0x51, 0x26, 0x01, 0x53, 0x01, 0x27, 0xa7,
    0x37, 0xab, 0x6b, 0x02, 0x52, 0xab, 0x48, 0x8c,
    0xf4, 0x66, 0xca, 0x8e, 0xc8, 0x8c, 0xd1, 0x6e,
    0x32, 0x4e, 0xe5, 0x53, 0x9c, 0x9f, 0x9c, 0x9f,
    0x51, 0x59, 0xd1, 0x91, 0x87, 0x55, 0x48, 0x59,
    0xf6, 0x61, 0x69, 0x76, 0x85, 0x7f, 0x3f, 0x86,
    0xba, 0x87, 0xf8, 0x88, 0x8f, 0x90, 0x02, 0x6a,
    0x1b, 0x6d, 0xd9, 0x70, 0xde, 0x73, 0x3d, 0x84,
    0x6a, 0x91, 0xf1, 0x99, 0x82, 0x4e, 0x75, 0x53,
    0x04, 0x6b, 0x1b, 0x72, 0x2d, 0x86, 0x1e, 0x9e,
    0x50, 0x5d, 0xeb, 0x6f, 0xcd, 0x85, 0x64, 0x89,
    0xc9, 0x62, 0xd8, 0x81, 0x1f, 0x88, 0xca, 0x5e,
    0x17, 0x67, 0x6a, 0x6d, 0xfc, 0x72, 0xce, 0x90,
    0x86, 0x4f, 0xb7, 0x51, 0xde, 0x52, 0xc4, 0x64,
    0xd3, 0x6a, 0x10, 0x72, 0xe7, 0x76, 0x01, 0x80,
    0x06, 0x86, 0x5c, 0x86, 0xef, 0x8d, 0x32, 0x97,
    0x6f, 0x9b, 0xfa, 0x9d, 0x8c, 0x78, 0x7f, 0x79,
    0xa0, 0x7d, 0xc9, 0x83, 0x04, 0x93, 0x7f, 0x9e,
    0xd6, 0x8a, 0xdf, 0x58, 0x04, 0x5f, 0x60, 0x7c,
    0x7e, 0x80, 0x62, 0x72, 0xca, 0x78, 0xc2, 0x8c,
    0xf7, 0x96, 0xd8, 0x58, 0x62, 0x5c, 0x13, 0x6a,
    0xda, 0x6d, 0x0f, 0x6f, 0x2f, 0x7d, 0x37, 0x7e,
    0x4b, 0x96, 0xd2, 0x52, 0x8b, 0x80, 0xdc, 0x51,
    0xcc, 0x51, 0x1c, 0x7a, 0xbe, 0x7d, 0xf1, 0x83,
    0x75, 0x96, 0x80, 0x8b, 0xcf, 0x62, 0x02, 0x6a,
    0xfe, 0x8a, 0x39, 0x4e, 0xe7, 0x5b, 0x12, 0x60,
    0x87, 0x73, 0x70, 0x75, 0x17, 0x53, 0xfb, 0x78,
    0xbf, 0x4f, 0xa9, 0x5f, 0x0d, 0x4e, 0xcc, 0x6c,
    0x78, 0x65, 0x22, 0x7d, 0xc3, 0x53, 0x5e, 0x58,
    0x01, 0x77, 0x49, 0x84, 0xaa, 0x8a, 0xba, 0x6b,
    0xb0, 0x8f, 0x88, 0x6c, 0xfe, 0x62, 0xe5, 0x82,
    0xa0, 0x63, 0x65, 0x75, 0xae, 0x4e, 0x69, 0x51,
    0xc9, 0x51, 0x81, 0x68, 0xe7, 0x7c, 0x6f, 0x82,
    0xd2, 0x8a, 0xcf, 0x91, 0xf5, 0x52, 0x42, 0x54,
    0x73, 0x59, 0xec, 0x5e, 0xc5, 0x65, 0xfe, 0x6f,
    0x2a, 0x79, 0xad, 0x95, 0x6a, 0x9a, 0x97, 0x9e,
    0xce, 0x9e, 0x9b, 0x52, 0xc6, 0x66, 0x77, 0x6b,
    0x62, 0x8f, 0x74, 0x5e, 0x90, 0x61, 0x00, 0x62,
    0x9a, 0x64, 0x23, 0x6f, 0x49, 0x71, 0x89, 0x74,
    0xca, 0x79, 0xf4, 0x7d, 0x6f, 0x80, 0x26, 0x8f,
    0xee, 0x84, 0x23, 0x90, 0x4a, 0x93, 0x17, 0x52,
    0xa3, 0x52, 0xbd, 0x54, 0xc8, 0x70, 0xc2, 0x88,
    0xaa, 0x8a, 0xc9, 0x5e, 0xf5, 0x5f, 0x7b, 0x63,
    0xae, 0x6b, 0x3e, 0x7c, 0x75, 0x73, 0xe4, 0x4e,
    0xf9, 0x56, 0xe7, 0x5b, 0xba, 0x5d, 0x1c, 0x60,
    0xb2, 0x73, 0x69, 0x74, 0x9a, 0x7f, 0x46, 0x80,
    0x34, 0x92, 0xf6, 0x96, 0x48, 0x97, 0x18, 0x98,
    0x8b, 0x4f, 0xae, 0x79, 0xb4, 0x91, 0xb8, 0x96,
    0xe1, 0x60, 0x86, 0x4e, 0xda, 0x50, 0xee, 0x5b,
    0x3f, 0x5c, 0x99, 0x65, 0x02, 0x6a, 0xce, 0x71,
    0x42, 0x76, 0xfc, 0x84, 0x7c, 0x90, 0x8d, 0x9f,
    0x88, 0x66, 0x2e, 0x96, 0x89, 0x52, 0x7b, 0x67,
    0xf3, 0x67, 0x41, 0x6d, 0x9c, 0x6e, 0x09, 0x74,
    0x59, 0x75, 0x6b, 0x78, 0x10, 0x7d, 0x5e, 0x98,
    0x6d, 0x51, 0x2e, 0x62, 0x78, 0x96, 0x2b, 0x50,
    0x19, 0x5d, 0xea, 0x6d, 0x2a, 0x8f, 0x8b, 0x5f,
    0x44, 0x61, 0x17, 0x68, 0x87, 0x73, 0x86, 0x96,
    0x29, 0x52, 0x0f, 0x54, 0x65, 0x5c, 0x13, 0x66,
    0x4e, 0x67, 0xa8, 0x68, 0xe5, 0x6c, 0x06, 0x74,
    0xe2, 0x75, 0x79, 0x7f, 0xcf, 0x88, 0xe1, 0x88,
    0xcc, 0x91, 0xe2, 0x96, 0x3f, 0x53, 0xba, 0x6e,
    0x1d, 0x54, 0xd0, 0x71, 0x98, 0x74, 0xfa, 0x85,
    0xa3, 0x96, 0x57, 0x9c, 0x9f, 0x9e, 0x97, 0x67,
    0xcb, 0x6d, 0xe8, 0x81, 0xcb, 0x7a, 0x20, 0x7b,
    0x92, 0x7c, 0xc0, 0x72, 0x99, 0x70, 0x58, 0x8b,
    0xc0, 0x4e, 0x36, 0x83, 0x3a, 0x52, 0x07, 0x52,
    0xa6, 0x5e, 0xd3, 0x62, 0xd6, 0x7c, 0x85, 0x5b,
    0x1e, 0x6d, 0xb4, 0x66, 0x3b, 0x8f, 0x4c, 0x88,
    0x4d, 0x96, 0x8b, 0x89, 0xd3, 0x5e, 0x40, 0x51,
    0xc0, 0x55, 0x00, 0x00, 0x00, 0x00, 0x5a, 0x58,
    0x00, 0x00, 0x74, 0x66, 0x00, 0x00, 0x00, 0x00,
    0xde, 0x51, 0x2a, 0x73, 0xca, 0x76, 0x3c, 0x79,
    0x5e, 0x79, 0x65, 0x79, 0x8f, 0x79, 0x56, 0x97,
    0xbe, 0x7c, 0xbd, 0x7f, 0x00, 0x00, 0x12, 0x86,
    0x00, 0x00, 0xf8, 0x8a, 0x00, 0x00, 0x00, 0x00,
    0x38, 0x90, 0xfd, 0x90, 0xef, 0x98, 0xfc, 0x98,
    0x28, 0x99, 0xb4, 0x9d, 0xde, 0x90, 0xb7, 0x96,
    0xae, 0x4f, 0xe7, 0x50, 0x4d, 0x51, 0xc9, 0x52,
    0xe4, 0x52, 0x51, 0x53, 0x9d, 0x55, 0x06, 0x56,
    0x68, 0x56, 0x40, 0x58, 0xa8, 0x58, 0x64, 0x5c,
    0x6e, 0x5c, 0x94, 0x60, 0x68, 0x61, 0x8e, 0x61,
    0xf2, 0x61, 0x4f, 0x65, 0xe2, 0x65, 0x91, 0x66,
    0x85, 0x68, 0x77, 0x6d, 0x1a, 0x6e, 0x22, 0x6f,
    0x6e, 0x71, 0x2b, 0x72, 0x22, 0x74, 0x91, 0x78,
    0x3e, 0x79, 0x49, 0x79, 0x48, 0x79, 0x50, 0x79,
    0x56, 0x79, 0x5d, 0x79, 0x8d, 0x79, 0x8e, 0x79,
    0x40, 0x7a, 0x81, 0x7a, 0xc0, 0x7b, 0xf4, 0x7d,
    0x09, 0x7e, 0x41, 0x7e, 0x72, 0x7f, 0x05, 0x80,
    0xed, 0x81, 0x79, 0x82, 0x79, 0x82, 0x57, 0x84,
    0x10, 0x89, 0x96, 0x89, 0x01, 0x8b, 0x39, 0x8b,
    0xd3, 0x8c, 0x08, 0x8d, 0xb6, 0x8f, 0x38, 0x90,
    0xe3, 0x96, 0xff, 0x97, 0x3b, 0x98, 0x75, 0x60,
    0xee, 0x42, 0x18, 0x82, 0x02, 0x26, 0x4e, 0xb5,
    0x51, 0x68, 0x51, 0x80, 0x4f, 0x45, 0x51, 0x80,
    0x51, 0xc7, 0x52, 0xfa, 0x52, 0x9d, 0x55, 0x55,
    0x55, 0x99, 0x55, 0xe2, 0x55, 0x5a, 0x58, 0xb3,
    0x58, 0x44, 0x59, 0x54, 0x59, 0x62, 0x5a, 0x28,
    0x5b, 0xd2, 0x5e, 0xd9, 0x5e, 0x69, 0x5f, 0xad,
    0x5f, 0xd8, 0x60, 0x4e, 0x61, 0x08, 0x61, 0x8e,
    0x61, 0x60, 0x61, 0xf2, 0x61, 0x34, 0x62, 0xc4,
    0x63, 0x1c, 0x64, 0x52, 0x64, 0x56, 0x65, 0x74,
    0x66, 0x17, 0x67, 0x1b, 0x67, 0x56, 0x67, 0x79,
    0x6b, 0xba, 0x6b, 0x41, 0x6d, 0xdb, 0x6e, 0xcb,
    0x6e, 0x22, 0x6f, 0x1e, 0x70, 0x6e, 0x71, 0xa7,
    0x77, 0x35, 0x72, 0xaf, 0x72, 0x2a, 0x73, 0x71,
    0x74, 0x06, 0x75, 0x3b, 0x75, 0x1d, 0x76, 0x1f,
    0x76, 0xca, 0x76, 0xdb, 0x76, 0xf4, 0x76, 0x4a,
    0x77, 0x40, 0x77, 0xcc, 0x78, 0xb1, 0x7a, 0xc0,
    0x7b, 0x7b, 0x7c, 0x5b, 0x7d, 0xf4, 0x7d, 0x3e,
    0x7f, 0x05, 0x80, 0x52, 0x83, 0xef, 0x83, 0x79,
    0x87, 0x41, 0x89, 0x86, 0x89, 0x96, 0x89, 0xbf,
    0x8a, 0xf8, 0x8a, 0xcb, 0x8a, 0x01, 0x8b, 0xfe,
    0x8a, 0xed, 0x8a, 0x39, 0x8b, 0x8a, 0x8b, 0x08,
    0x8d, 0x38, 0x8f, 0x72, 0x90, 0x99, 0x91, 0x76,
    0x92, 0x7c, 0x96, 0xe3, 0x96, 0x56, 0x97, 0xdb,
    0x97, 0xff, 0x97, 0x0b, 0x98, 0x3b, 0x98, 0x12,
    0x9b, 0x9c, 0x9f, 0x4a, 0x28, 0x44, 0x28, 0xd5,
    0x33, 0x9d, 0x3b, 0x18, 0x40, 0x39, 0x40, 0x49,
    0x52, 0xd0, 0x5c, 0xd3, 0x7e, 0x43, 0x9f, 0x8e,
    0x9f, 0x2a, 0xa0, 0x02, 0x66, 0x66, 0x66, 0x69,
    0x66, 0x6c, 0x66, 0x66, 0x69, 0x66, 0x66, 0x6c,
    0x7f, 0x01, 0x74, 0x73, 0x00, 0x74, 0x65, 0x05,
    0x0f, 0x11, 0x0f, 0x00, 0x0f, 0x06, 0x19, 0x11,
    0x0f, 0x08, 0xd9, 0x05, 0xb4, 0x05, 0x00, 0x00,
    0x00, 0x00, 0xf2, 0x05, 0xb7, 0x05, 0xd0, 0x05,
    0x12, 0x00, 0x03, 0x04, 0x0b, 0x0c, 0x0d, 0x18,
    0x1a, 0xe9, 0x05, 0xc1, 0x05, 0xe9, 0x05, 0xc2,
    0x05, 0x49, 0xfb, 0xc1, 0x05, 0x49, 0xfb, 0xc2,
    0x05, 0xd0, 0x05, 0xb7, 0x05, 0xd0, 0x05, 0xb8,
    0x05, 0xd0, 0x05, 0xbc, 0x05, 0xd8, 0x05, 0xbc,
    0x05, 0xde, 0x05, 0xbc, 0x05, 0xe0, 0x05, 0xbc,
    0x05, 0xe3, 0x05, 0xbc, 0x05, 0xb9, 0x05, 0x2d,
    0x03, 0x2e, 0x03, 0x2f, 0x03, 0x30, 0x03, 0x31,
    0x03, 0x1c, 0x00, 0x18, 0x06, 0x22, 0x06, 0x2b,
    0x06, 0xd0, 0x05, 0xdc, 0x05, 0x71, 0x06, 0x00,
    0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0d, 0x0d, 0x0d,
    0x0d, 0x0f, 0x0f, 0x0f, 0x0f, 0x09, 0x09, 0x09,
    0x09, 0x0e, 0x0e, 0x0e, 0x0e, 0x08, 0x08, 0x08,
    0x08, 0x33, 0x33, 0x33, 0x33, 0x35, 0x35, 0x35,
    0x35, 0x13, 0x13, 0x13, 0x13, 0x12, 0x12, 0x12,
    0x12, 0x15, 0x15, 0x15, 0x15, 0x16, 0x16, 0x16,
    0x16, 0x1c, 0x1c, 0x1b, 0x1b, 0x1d, 0x1d, 0x17,
    0x17, 0x27, 0x27, 0x20, 0x20, 0x38, 0x38, 0x38,
    0x38, 0x3e, 0x3e, 0x3e, 0x3e, 0x42, 0x42, 0x42,
    0x42, 0x40, 0x40, 0x40, 0x40, 0x49, 0x49, 0x4a,
    0x4a, 0x4a, 0x4a, 0x4f, 0x4f, 0x50, 0x50, 0x50,
    0x50, 0x4d, 0x4d, 0x4d, 0x4d, 0x61, 0x61, 0x62,
    0x62, 0x49, 0x06, 0x64, 0x64, 0x64, 0x64, 0x7e,
    0x7e, 0x7d, 0x7d, 0x7f, 0x7f, 0x2e, 0x82, 0x82,
    0x7c, 0x7c, 0x80, 0x80, 0x87, 0x87, 0x87, 0x87,
    0x00, 0x00, 0x26, 0x06, 0x00, 0x01, 0x00, 0x01,
    0x00, 0xaf, 0x00, 0xaf, 0x00, 0x22, 0x00, 0x22,
    0x00, 0xa1, 0x00, 0xa1, 0x00, 0xa0, 0x00, 0xa0,
    0x00, 0xa2, 0x00, 0xa2, 0x00, 0xaa, 0x00, 0xaa,
    0x00, 0xaa, 0x00, 0x23, 0x00, 0x23, 0x00, 0x23,
    0xcc, 0x06, 0x00, 0x00, 0x00, 0x00, 0x26, 0x06,
    0x00, 0x06, 0x00, 0x07, 0x00, 0x1f, 0x00, 0x23,
    0x00, 0x24, 0x02, 0x06, 0x02, 0x07, 0x02, 0x08,
    0x02, 0x1f, 0x02, 0x23, 0x02, 0x24, 0x04, 0x06,
    0x04, 0x07, 0x04, 0x08, 0x04, 0x1f, 0x04, 0x23,
    0x04, 0x24, 0x05, 0x06, 0x05, 0x1f, 0x05, 0x23,
    0x05, 0x24, 0x06, 0x07, 0x06, 0x1f, 0x07, 0x06,
    0x07, 0x1f, 0x08, 0x06, 0x08, 0x07, 0x08, 0x1f,
    0x0d, 0x06, 0x0d, 0x07, 0x0d, 0x08, 0x0d, 0x1f,
    0x0f, 0x07, 0x0f, 0x1f, 0x10, 0x06, 0x10, 0x07,
    0x10, 0x08, 0x10, 0x1f, 0x11, 0x07, 0x11, 0x1f,
    0x12, 0x1f, 0x13, 0x06, 0x13, 0x1f, 0x14, 0x06,
    0x14, 0x1f, 0x1b, 0x06, 0x1b, 0x07, 0x1b, 0x08,
    0x1b, 0x1f, 0x1b, 0x23, 0x1b, 0x24, 0x1c, 0x07,
    0x1c, 0x1f, 0x1c, 0x23, 0x1c, 0x24, 0x1d, 0x01,
    0x1d, 0x06, 0x1d, 0x07, 0x1d, 0x08, 0x1d, 0x1e,
    0x1d, 0x1f, 0x1d, 0x23, 0x1d, 0x24, 0x1e, 0x06,
    0x1e, 0x07, 0x1e, 0x08, 0x1e, 0x1f, 0x1e, 0x23,
    0x1e, 0x24, 0x1f, 0x06, 0x1f, 0x07, 0x1f, 0x08,
    0x1f, 0x1f, 0x1f, 0x23, 0x1f, 0x24, 0x20, 0x06,
    0x20, 0x07, 0x20, 0x08, 0x20, 0x1f, 0x20, 0x23,
    0x20, 0x24, 0x21, 0x06, 0x21, 0x1f, 0x21, 0x23,
    0x21, 0x24, 0x24, 0x06, 0x24, 0x07, 0x24, 0x08,
    0x24, 0x1f, 0x24, 0x23, 0x24, 0x24, 0x0a, 0x4a,
    0x0b, 0x4a, 0x23, 0x4a, 0x20, 0x00, 0x4c, 0x06,
    0x51, 0x06, 0x51, 0x06, 0xff, 0x00, 0x1f, 0x26,
    0x06, 0x00, 0x0b, 0x00, 0x0c, 0x00, 0x1f, 0x00,
    0x20, 0x00, 0x23, 0x00, 0x24, 0x02, 0x0b, 0x02,
    0x0c, 0x02, 0x1f, 0x02, 0x20, 0x02, 0x23, 0x02,
    0x24, 0x04, 0x0b, 0x04, 0x0c, 0x04, 0x1f, 0x26,
    0x06, 0x04, 0x20, 0x04, 0x23, 0x04, 0x24, 0x05,
    0x0b, 0x05, 0x0c, 0x05, 0x1f, 0x05, 0x20, 0x05,
    0x23, 0x05, 0x24, 0x1b, 0x23, 0x1b, 0x24, 0x1c,
    0x23, 0x1c, 0x24, 0x1d, 0x01, 0x1d, 0x1e, 0x1d,
    0x1f, 0x1d, 0x23, 0x1d, 0x24, 0x1e, 0x1f, 0x1e,
    0x23, 0x1e, 0x24, 0x1f, 0x01, 0x1f, 0x1f, 0x20,
    0x0b, 0x20, 0x0c, 0x20, 0x1f, 0x20, 0x20, 0x20,
    0x23, 0x20, 0x24, 0x23, 0x4a, 0x24, 0x0b, 0x24,
    0x0c, 0x24, 0x1f, 0x24, 0x20, 0x24, 0x23, 0x24,
    0x24, 0x00, 0x06, 0x00, 0x07, 0x00, 0x08, 0x00,
    0x1f, 0x00, 0x21, 0x02, 0x06, 0x02, 0x07, 0x02,
    0x08, 0x02, 0x1f, 0x02, 0x21, 0x04, 0x06, 0x04,
    0x07, 0x04, 0x08, 0x04, 0x1f, 0x04, 0x21, 0x05,
    0x1f, 0x06, 0x07, 0x06, 0x1f, 0x07, 0x06, 0x07,
    0x1f, 0x08, 0x06, 0x08, 0x1f, 0x0d, 0x06, 0x0d,
    0x07, 0x0d, 0x08, 0x0d, 0x1f, 0x0f, 0x07, 0x0f,
    0x08, 0x0f, 0x1f, 0x10, 0x06, 0x10, 0x07, 0x10,
    0x08, 0x10, 0x1f, 0x11, 0x07, 0x12, 0x1f, 0x13,
    0x06, 0x13, 0x1f, 0x14, 0x06, 0x14, 0x1f, 0x1b,
    0x06, 0x1b, 0x07, 0x1b, 0x08, 0x1b, 0x1f, 0x1c,
    0x07, 0x1c, 0x1f, 0x1d, 0x06, 0x1d, 0x07, 0x1d,
    0x08, 0x1d, 0x1e, 0x1d, 0x1f, 0x1e, 0x06, 0x1e,
    0x07, 0x1e, 0x08, 0x1e, 0x1f, 0x1e, 0x21, 0x1f,
    0x06, 0x1f, 0x07, 0x1f, 0x08, 0x1f, 0x1f, 0x20,
    0x06, 0x20, 0x07, 0x20, 0x08, 0x20, 0x1f, 0x20,
    0x21, 0x21, 0x06, 0x21, 0x1f, 0x21, 0x4a, 0x24,
    0x06, 0x24, 0x07, 0x24, 0x08, 0x24, 0x1f, 0x24,
    0x21, 0x00, 0x1f, 0x00, 0x21, 0x02, 0x1f, 0x02,
    0x21, 0x04, 0x1f, 0x04, 0x21, 0x05, 0x1f, 0x05,
    0x21, 0x0d, 0x1f, 0x0d, 0x21, 0x0e, 0x1f, 0x0e,
    0x21, 0x1d, 0x1e, 0x1d, 0x1f, 0x1e, 0x1f, 0x20,
    0x1f, 0x20, 0x21, 0x24, 0x1f, 0x24, 0x21, 0x40,
    0x06, 0x4e, 0x06, 0x51, 0x06, 0x27, 0x06, 0x10,
    0x22, 0x10, 0x23, 0x12, 0x22, 0x12, 0x23, 0x13,
    0x22, 0x13, 0x23, 0x0c, 0x22, 0x0c, 0x23, 0x0d,
    0x22, 0x0d, 0x23, 0x06, 0x22, 0x06, 0x23, 0x05,
    0x22, 0x05, 0x23, 0x07, 0x22, 0x07, 0x23, 0x0e,
    0x22, 0x0e, 0x23, 0x0f, 0x22, 0x0f, 0x23, 0x0d,
    0x05, 0x0d, 0x06, 0x0d, 0x07, 0x0d, 0x1e, 0x0d,
    0x0a, 0x0c, 0x0a, 0x0e, 0x0a, 0x0f, 0x0a, 0x10,
    0x22, 0x10, 0x23, 0x12, 0x22, 0x12, 0x23, 0x13,
    0x22, 0x13, 0x23, 0x0c, 0x22, 0x0c, 0x23, 0x0d,
    0x22, 0x0d, 0x23, 0x06, 0x22, 0x06, 0x23, 0x05,
    0x22, 0x05, 0x23, 0x07, 0x22, 0x07, 0x23, 0x0e,
    0x22, 0x0e, 0x23, 0x0f, 0x22, 0x0f, 0x23, 0x0d,
    0x05, 0x0d, 0x06, 0x0d, 0x07, 0x0d, 0x1e, 0x0d,
    0x0a, 0x0c, 0x0a, 0x0e, 0x0a, 0x0f, 0x0a, 0x0d,
    0x05, 0x0d, 0x06, 0x0d, 0x07, 0x0d, 0x1e, 0x0c,
    0x20, 0x0d, 0x20, 0x10, 0x1e, 0x0c, 0x05, 0x0c,
    0x06, 0x0c, 0x07, 0x0d, 0x05, 0x0d, 0x06, 0x0d,
    0x07, 0x10, 0x1e, 0x11, 0x1e, 0x00, 0x24, 0x00,
    0x24, 0x2a, 0x06, 0x00, 0x02, 0x1b, 0x00, 0x03,
    0x02, 0x00, 0x03, 0x02, 0x00, 0x03, 0x1b, 0x00,
    0x04, 0x1b, 0x00, 0x1b, 0x02, 0x00, 0x1b, 0x03,
    0x00, 0x1b, 0x04, 0x02, 0x1b, 0x03, 0x02, 0x1b,
    0x03, 0x03, 0x1b, 0x20, 0x03, 0x1b, 0x1f, 0x09,
    0x03, 0x02, 0x09, 0x02, 0x03, 0x09, 0x02, 0x1f,
    0x09, 0x1b, 0x03, 0x09, 0x1b, 0x03, 0x09, 0x1b,
    0x02, 0x09, 0x1b, 0x1b, 0x09, 0x1b, 0x1b, 0x0b,
    0x03, 0x03, 0x0b, 0x03, 0x03, 0x0b, 0x1b, 0x1b,
    0x0a, 0x03, 0x1b, 0x0a, 0x03, 0x1b, 0x0a, 0x02,
    0x20, 0x0a, 0x1b, 0x04, 0x0a, 0x1b, 0x04, 0x0a,
    0x1b, 0x1b, 0x0a, 0x1b, 0x1b, 0x0c, 0x03, 0x1f,
    0x0c, 0x04, 0x1b, 0x0c, 0x04, 0x1b, 0x0d, 0x1b,
    0x03, 0x0d, 0x1b, 0x03, 0x0d, 0x1b, 0x1b, 0x0d,
    0x1b, 0x20, 0x0f, 0x02, 0x1b, 0x0f, 0x1b, 0x1b,
    0x0f, 0x1b, 0x1b, 0x0f, 0x1b, 0x1f, 0x10, 0x1b,
    0x1b, 0x10, 0x1b, 0x20, 0x10, 0x1b, 0x1f, 0x17,
    0x04, 0x1b, 0x17, 0x04, 0x1b, 0x18, 0x1b, 0x03,
    0x18, 0x1b, 0x1b, 0x1a, 0x03, 0x1b, 0x1a, 0x03,
    0x20, 0x1a, 0x03, 0x1f, 0x1a, 0x02, 0x02, 0x1a,
    0x02, 0x02, 0x1a, 0x04, 0x1b, 0x1a, 0x04, 0x1b,
    0x1a, 0x1b, 0x03, 0x1a, 0x1b, 0x03, 0x1b, 0x03,
    0x02, 0x1b, 0x03, 0x1b, 0x1b, 0x03, 0x20, 0x1b,
    0x02, 0x03, 0x1b, 0x02, 0x1b, 0x1b, 0x04, 0x02,
    0x1b, 0x04, 0x1b, 0x28, 0x06, 0x1d, 0x04, 0x06,
    0x1f, 0x1d, 0x04, 0x1f, 0x1d, 0x1d, 0x1e, 0x05,
    0x1d, 0x1e, 0x05, 0x21, 0x1e, 0x04, 0x1d, 0x1e,
    0x04, 0x1d, 0x1e, 0x04, 0x21, 0x1e, 0x1d, 0x22,
    0x1e, 0x1d, 0x21, 0x22, 0x1d, 0x1d, 0x22, 0x1d,
    0x1d, 0x00, 0x06, 0x22, 0x02, 0x04, 0x22, 0x02,
    0x04, 0x21, 0x02, 0x06, 0x22, 0x02, 0x06, 0x21,
    0x02, 0x1d, 0x22, 0x02, 0x1d, 0x21, 0x04, 0x1d,
    0x22, 0x04, 0x05, 0x21, 0x04, 0x1d, 0x21, 0x0b,
    0x06, 0x21, 0x0d, 0x05, 0x22, 0x0c, 0x05, 0x22,
    0x0e, 0x05, 0x22, 0x1c, 0x04, 0x22, 0x1c, 0x1d,
    0x22, 0x22, 0x05, 0x22, 0x22, 0x04, 0x22, 0x22,
    0x1d, 0x22, 0x1d, 0x1d, 0x22, 0x1a, 0x1d, 0x22,
    0x1e, 0x05, 0x22, 0x1a, 0x1d, 0x05, 0x1c, 0x05,
    0x1d, 0x11, 0x1d, 0x22, 0x1b, 0x1d, 0x22, 0x1e,
    0x04, 0x05, 0x1d, 0x06, 0x22, 0x1c, 0x04, 0x1d,
    0x1b, 0x1d, 0x1d, 0x1c, 0x04, 0x1d, 0x1e, 0x04,
    0x05, 0x04, 0x05, 0x22, 0x05, 0x04, 0x22, 0x1d,
    0x04, 0x22, 0x19, 0x1d, 0x22, 0x00, 0x05, 0x22,
    0x1b, 0x1d, 0x1d, 0x11, 0x04, 0x1d, 0x0d, 0x1d,
    0x1d, 0x0b, 0x06, 0x22, 0x1e, 0x04, 0x22, 0x35,
    0x06, 0x00, 0x0f, 0x9d, 0x0d, 0x0f, 0x9d, 0x27,
    0x06, 0x00, 0x1d, 0x1d, 0x20, 0x00, 0x1c, 0x01,
    0x0a, 0x1e, 0x06, 0x1e, 0x08, 0x0e, 0x1d, 0x12,
    0x1e, 0x0a, 0x0c, 0x21, 0x1d, 0x12, 0x1d, 0x23,
    0x20, 0x21, 0x0c, 0x1d, 0x1e, 0x35, 0x06, 0x00,
    0x0f, 0x14, 0x27, 0x06, 0x0e, 0x1d, 0x22, 0xff,
    0x00, 0x1d, 0x1d, 0x20, 0xff, 0x12, 0x1d, 0x23,
    0x20, 0xff, 0x21, 0x0c, 0x1d, 0x1e, 0x27, 0x06,
    0x05, 0x1d, 0xff, 0x05, 0x1d, 0x00, 0x1d, 0x20,
    0x27, 0x06, 0x0a, 0xa5, 0x00, 0x1d, 0x2c, 0x00,
    0x01, 0x30, 0x02, 0x30, 0x3a, 0x00, 0x3b, 0x00,
    0x21, 0x00, 0x3f, 0x00, 0x16, 0x30, 0x17, 0x30,
    0x26, 0x20, 0x13, 0x20, 0x12, 0x01, 0x00, 0x5f,
    0x5f, 0x28, 0x29, 0x7b, 0x7d, 0x08, 0x30, 0x0c,
    0x0d, 0x08, 0x09, 0x02, 0x03, 0x00, 0x01, 0x04,
    0x05, 0x06, 0x07, 0x5b, 0x00, 0x5d, 0x00, 0x3e,
    0x20, 0x3e, 0x20, 0x3e, 0x20, 0x3e, 0x20, 0x5f,
    0x00, 0x5f, 0x00, 0x5f, 0x00, 0x2c, 0x00, 0x01,
    0x30, 0x2e, 0x00, 0x00, 0x00, 0x3b, 0x00, 0x3a,
    0x00, 0x3f, 0x00, 0x21, 0x00, 0x14, 0x20, 0x28,
    0x00, 0x29, 0x00, 0x7b, 0x00, 0x7d, 0x00, 0x14,
    0x30, 0x15, 0x30, 0x23, 0x26, 0x2a, 0x2b, 0x2d,
    0x3c, 0x3e, 0x3d, 0x00, 0x5c, 0x24, 0x25, 0x40,
    0x40, 0x06, 0xff, 0x0b, 0x00, 0x0b, 0xff, 0x0c,
    0x20, 0x00, 0x4d, 0x06, 0x40, 0x06, 0xff, 0x0e,
    0x00, 0x0e, 0xff, 0x0f, 0x00, 0x0f, 0xff, 0x10,
    0x00, 0x10, 0xff, 0x11, 0x00, 0x11, 0xff, 0x12,
    0x00, 0x12, 0x21, 0x06, 0x00, 0x01, 0x01, 0x02,
    0x02, 0x03, 0x03, 0x04, 0x04, 0x05, 0x05, 0x05,
    0x05, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x08,
    0x08, 0x09, 0x09, 0x09, 0x09, 0x0a, 0x0a, 0x0a,
    0x0a, 0x0b, 0x0b, 0x0b, 0x0b, 0x0c, 0x0c, 0x0c,
    0x0c, 0x0d, 0x0d, 0x0d, 0x0d, 0x0e, 0x0e, 0x0f,
    0x0f, 0x10, 0x10, 0x11, 0x11, 0x12, 0x12, 0x12,
    0x12, 0x13, 0x13, 0x13, 0x13, 0x14, 0x14, 0x14,
    0x14, 0x15, 0x15, 0x15, 0x15, 0x16, 0x16, 0x16,
    0x16, 0x17, 0x17, 0x17, 0x17, 0x18, 0x18, 0x18,
    0x18, 0x19, 0x19, 0x19, 0x19, 0x20, 0x20, 0x20,
    0x20, 0x21, 0x21, 0x21, 0x21, 0x22, 0x22, 0x22,
    0x22, 0x23, 0x23, 0x23, 0x23, 0x24, 0x24, 0x24,
    0x24, 0x25, 0x25, 0x25, 0x25, 0x26, 0x26, 0x26,
    0x26, 0x27, 0x27, 0x28, 0x28, 0x29, 0x29, 0x29,
    0x29, 0x22, 0x06, 0x22, 0x00, 0x22, 0x00, 0x22,
    0x01, 0x22, 0x01, 0x22, 0x03, 0x22, 0x03, 0x22,
    0x05, 0x22, 0x05, 0x21, 0x00, 0x85, 0x29, 0x01,
    0x30, 0x01, 0x0b, 0x0c, 0x00, 0xfa, 0xf1, 0xa0,
    0xa2, 0xa4, 0xa6, 0xa8, 0xe2, 0xe4, 0xe6, 0xc2,
    0xfb, 0xa1, 0xa3, 0xa5, 0xa7, 0xa9, 0xaa, 0xac,
    0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc,
    0xbe, 0xc0, 0xc3, 0xc5, 0xc7, 0xc9, 0xca, 0xcb,
    0xcc, 0xcd, 0xce, 0xd1, 0xd4, 0xd7, 0xda, 0xdd,
    0xde, 0xdf, 0xe0, 0xe1, 0xe3, 0xe5, 0xe7, 0xe8,
    0xe9, 0xea, 0xeb, 0xec, 0xee, 0xf2, 0x98, 0x99,
    0x31, 0x31, 0x4f, 0x31, 0x55, 0x31, 0x5b, 0x31,
    0x61, 0x31, 0xa2, 0x00, 0xa3, 0x00, 0xac, 0x00,
    0xaf, 0x00, 0xa6, 0x00, 0xa5, 0x00, 0xa9, 0x20,
    0x00, 0x00, 0x02, 0x25, 0x90, 0x21, 0x91, 0x21,
    0x92, 0x21, 0x93, 0x21, 0xa0, 0x25, 0xcb, 0x25,
    0xd0, 0x02, 0xd1, 0x02, 0xe6, 0x00, 0x99, 0x02,
    0x53, 0x02, 0x00, 0x00, 0xa3, 0x02, 0x66, 0xab,
    0xa5, 0x02, 0xa4, 0x02, 0x56, 0x02, 0x57, 0x02,
    0x91, 0x1d, 0x58, 0x02, 0x5e, 0x02, 0xa9, 0x02,
    0x64, 0x02, 0x62, 0x02, 0x60, 0x02, 0x9b, 0x02,
    0x27, 0x01, 0x9c, 0x02, 0x67, 0x02, 0x84, 0x02,
    0xaa, 0x02, 0xab, 0x02, 0x6c, 0x02, 0x04, 0xdf,
    0x8e, 0xa7, 0x6e, 0x02, 0x05, 0xdf, 0x8e, 0x02,
    0x06, 0xdf, 0xf8, 0x00, 0x76, 0x02, 0x77, 0x02,
    0x71, 0x00, 0x7a, 0x02, 0x08, 0xdf, 0x7d, 0x02,
    0x7e, 0x02, 0x80, 0x02, 0xa8, 0x02, 0xa6, 0x02,
    0x67, 0xab, 0xa7, 0x02, 0x88, 0x02, 0x71, 0x2c,
    0x00, 0x00, 0x8f, 0x02, 0xa1, 0x02, 0xa2, 0x02,
    0x98, 0x02, 0xc0, 0x01, 0xc1, 0x01, 0xc2, 0x01,
    0x0a, 0xdf, 0x1e, 0xdf, 0x41, 0x04, 0x40, 0x00,
    0x00, 0x00, 0x00, 0x14, 0x99, 0x10, 0xba, 0x10,
    0x00, 0x00, 0x00, 0x00, 0x9b, 0x10, 0xba, 0x10,
    0x05, 0x05, 0xa5, 0x10, 0xba, 0x10, 0x05, 0x31,
    0x11, 0x27, 0x11, 0x32, 0x11, 0x27, 0x11, 0x55,
    0x47, 0x13, 0x3e, 0x13, 0x47, 0x13, 0x57, 0x13,
    0x55, 0xb9, 0x14, 0xba, 0x14, 0xb9, 0x14, 0xb0,
    0x14, 0x00, 0x00, 0x00, 0x00, 0xb9, 0x14, 0xbd,
    0x14, 0x55, 0x50, 0xb8, 0x15, 0xaf, 0x15, 0xb9,
    0x15, 0xaf, 0x15, 0x55, 0x35, 0x19, 0x30, 0x19,
    0x05, 0x57, 0xd1, 0x65, 0xd1, 0x58, 0xd1, 0x65,
    0xd1, 0x5f, 0xd1, 0x6e, 0xd1, 0x5f, 0xd1, 0x6f,
    0xd1, 0x5f, 0xd1, 0x70, 0xd1, 0x5f, 0xd1, 0x71,
    0xd1, 0x5f, 0xd1, 0x72, 0xd1, 0x55, 0x55, 0x55,
    0x05, 0xb9, 0xd1, 0x65, 0xd1, 0xba, 0xd1, 0x65,
    0xd1, 0xbb, 0xd1, 0x6e, 0xd1, 0xbc, 0xd1, 0x6e,
    0xd1, 0xbb, 0xd1, 0x6f, 0xd1, 0xbc, 0xd1, 0x6f,
    0xd1, 0x55, 0x55, 0x55, 0x41, 0x00, 0x61, 0x00,
    0x41, 0x00, 0x61, 0x00, 0x69, 0x00, 0x41, 0x00,
    0x61, 0x00, 0x41, 0x00, 0x43, 0x44, 0x00, 0x00,
    0x47, 0x00, 0x00, 0x4a, 0x4b, 0x00, 0x00, 0x4e,
    0x4f, 0x50, 0x51, 0x00, 0x53, 0x54, 0x55, 0x56,
    0x57, 0x58, 0x59, 0x5a, 0x61, 0x62, 0x63, 0x64,
    0x00, 0x66, 0x68, 0x00, 0x70, 0x00, 0x41, 0x00,
    0x61, 0x00, 0x41, 0x42, 0x00, 0x44, 0x45, 0x46,
    0x47, 0x4a, 0x00, 0x53, 0x00, 0x61, 0x00, 0x41,
    0x42, 0x00, 0x44, 0x45, 0x46, 0x47, 0x00, 0x49,
    0x4a, 0x4b, 0x4c, 0x4d, 0x00, 0x4f, 0x53, 0x00,
    0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41, 0x00,
    0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41, 0x00,
    0x61, 0x00, 0x41, 0x00, 0x61, 0x00, 0x41, 0x00,
    0x61, 0x00, 0x31, 0x01, 0x37, 0x02, 0x91, 0x03,
    0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03, 0x24, 0x00,
    0x1f, 0x04, 0x20, 0x05, 0x91, 0x03, 0xa3, 0x03,
    0xb1, 0x03, 0xd1, 0x03, 0x24, 0x00, 0x1f, 0x04,
    0x20, 0x05, 0x91, 0x03, 0xa3, 0x03, 0xb1, 0x03,
    0xd1, 0x03, 0x24, 0x00, 0x1f, 0x04, 0x20, 0x05,
    0x91, 0x03, 0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03,
    0x24, 0x00, 0x1f, 0x04, 0x20, 0x05, 0x91, 0x03,
    0xa3, 0x03, 0xb1, 0x03, 0xd1, 0x03, 0x24, 0x00,
    0x1f, 0x04, 0x20, 0x05, 0x0b, 0x0c, 0x30, 0x00,
    0x30, 0x00, 0x30, 0x00, 0x30, 0x00, 0x30, 0x00,
    0x27, 0x06, 0x00, 0x01, 0x05, 0x08, 0x2a, 0x06,
    0x1e, 0x08, 0x03, 0x0d, 0x20, 0x19, 0x1a, 0x1b,
    0x1c, 0x09, 0x0f, 0x17, 0x0b, 0x18, 0x07, 0x0a,
    0x00, 0x01, 0x04, 0x06, 0x0c, 0x0e, 0x10, 0x44,
    0x90, 0x77, 0x45, 0x28, 0x06, 0x2c, 0x06, 0x00,
    0x00, 0x47, 0x06, 0x33, 0x06, 0x17, 0x10, 0x11,
    0x12, 0x13, 0x00, 0x06, 0x0e, 0x02, 0x0f, 0x34,
    0x06, 0x2a, 0x06, 0x2b, 0x06, 0x2e, 0x06, 0x00,
    0x00, 0x36, 0x06, 0x00, 0x00, 0x3a, 0x06, 0x2d,
    0x06, 0x00, 0x00, 0x4a, 0x06, 0x00, 0x00, 0x44,
    0x06, 0x00, 0x00, 0x46, 0x06, 0x33, 0x06, 0x39,
    0x06, 0x00, 0x00, 0x35, 0x06, 0x42, 0x06, 0x00,
    0x00, 0x34, 0x06, 0x00, 0x00, 0x00, 0x00, 0x2e,
    0x06, 0x00, 0x00, 0x36, 0x06, 0x00, 0x00, 0x3a,
    0x06, 0x00, 0x00, 0xba, 0x06, 0x00, 0x00, 0x6f,
    0x06, 0x00, 0x00, 0x28, 0x06, 0x2c, 0x06, 0x00,
    0x00, 0x47, 0x06, 0x00, 0x00, 0x00, 0x00, 0x2d,
    0x06, 0x37, 0x06, 0x4a, 0x06, 0x43, 0x06, 0x00,
    0x00, 0x45, 0x06, 0x46, 0x06, 0x33, 0x06, 0x39,
    0x06, 0x41, 0x06, 0x35, 0x06, 0x42, 0x06, 0x00,
    0x00, 0x34, 0x06, 0x2a, 0x06, 0x2b, 0x06, 0x2e,
    0x06, 0x00, 0x00, 0x36, 0x06, 0x38, 0x06, 0x3a,
    0x06, 0x6e, 0x06, 0x00, 0x00, 0xa1, 0x06, 0x27,
    0x06, 0x00, 0x01, 0x05, 0x08, 0x20, 0x21, 0x0b,
    0x06, 0x10, 0x23, 0x2a, 0x06, 0x1a, 0x1b, 0x1c,
    0x09, 0x0f, 0x17, 0x0b, 0x18, 0x07, 0x0a, 0x00,
    0x01, 0x04, 0x06, 0x0c, 0x0e, 0x10, 0x28, 0x06,
    0x2c, 0x06, 0x2f, 0x06, 0x00, 0x00, 0x48, 0x06,
    0x32, 0x06, 0x2d, 0x06, 0x37, 0x06, 0x4a, 0x06,
    0x2a, 0x06, 0x1a, 0x1b, 0x1c, 0x09, 0x0f, 0x17,
    0x0b, 0x18, 0x07, 0x0a, 0x00, 0x01, 0x04, 0x06,
    0x0c, 0x0e, 0x10, 0x30, 0x2e, 0x30, 0x00, 0x2c,
    0x00, 0x28, 0x00, 0x41, 0x00, 0x29, 0x00, 0x14,
    0x30, 0x53, 0x00, 0x15, 0x30, 0x43, 0x52, 0x43,
    0x44, 0x57, 0x5a, 0x41, 0x00, 0x48, 0x56, 0x4d,
    0x56, 0x53, 0x44, 0x53, 0x53, 0x50, 0x50, 0x56,
    0x57, 0x43, 0x4d, 0x43, 0x4d, 0x44, 0x4d, 0x52,
    0x44, 0x4a, 0x4b, 0x30, 0x30, 0x00, 0x68, 0x68,
    0x4b, 0x62, 0x57, 0x5b, 0xcc, 0x53, 0xc7, 0x30,
    0x8c, 0x4e, 0x1a, 0x59, 0xe3, 0x89, 0x29, 0x59,
    0xa4, 0x4e, 0x20, 0x66, 0x21, 0x71, 0x99, 0x65,
    0x4d, 0x52, 0x8c, 0x5f, 0x8d, 0x51, 0xb0, 0x65,
    0x1d, 0x52, 0x42, 0x7d, 0x1f, 0x75, 0xa9, 0x8c,
    0xf0, 0x58, 0x39, 0x54, 0x14, 0x6f, 0x95, 0x62,
    0x55, 0x63, 0x00, 0x4e, 0x09, 0x4e, 0x4a, 0x90,
    0xe6, 0x5d, 0x2d, 0x4e, 0xf3, 0x53, 0x07, 0x63,
    0x70, 0x8d, 0x53, 0x62, 0x81, 0x79, 0x7a, 0x7a,
    0x08, 0x54, 0x80, 0x6e, 0x09, 0x67, 0x08, 0x67,
    0x33, 0x75, 0x72, 0x52, 0xb6, 0x55, 0x4d, 0x91,
    0x14, 0x30, 0x15, 0x30, 0x2c, 0x67, 0x09, 0x4e,
    0x8c, 0x4e, 0x89, 0x5b, 0xb9, 0x70, 0x53, 0x62,
    0xd7, 0x76, 0xdd, 0x52, 0x57, 0x65, 0x97, 0x5f,
    0xef, 0x53, 0x30, 0x00, 0x38, 0x4e, 0x05, 0x00,
    0x09, 0x22, 0x01, 0x60, 0x4f, 0xae, 0x4f, 0xbb,
    0x4f, 0x02, 0x50, 0x7a, 0x50, 0x99, 0x50, 0xe7,
    0x50, 0xcf, 0x50, 0x9e, 0x34, 0x3a, 0x06, 0x4d,
    0x51, 0x54, 0x51, 0x64, 0x51, 0x77, 0x51, 0x1c,
    0x05, 0xb9, 0x34, 0x67, 0x51, 0x8d, 0x51, 0x4b,
    0x05, 0x97, 0x51, 0xa4, 0x51, 0xcc, 0x4e, 0xac,
    0x51, 0xb5, 0x51, 0xdf, 0x91, 0xf5, 0x51, 0x03,
    0x52, 0xdf, 0x34, 0x3b, 0x52, 0x46, 0x52, 0x72,
    0x52, 0x77, 0x52, 0x15, 0x35, 0x02, 0x00, 0x20,
    0x80, 0x80, 0x00, 0x08, 0x00, 0x00, 0xc7, 0x52,
    0x00, 0x02, 0x1d, 0x33, 0x3e, 0x3f, 0x50, 0x82,
    0x8a, 0x93, 0xac, 0xb6, 0xb8, 0xb8, 0xb8, 0x2c,
    0x0a, 0x70, 0x70, 0xca, 0x53, 0xdf, 0x53, 0x63,
    0x0b, 0xeb, 0x53, 0xf1, 0x53, 0x06, 0x54, 0x9e,
    0x54, 0x38, 0x54, 0x48, 0x54, 0x68, 0x54, 0xa2,
    0x54, 0xf6, 0x54, 0x10, 0x55, 0x53, 0x55, 0x63,
    0x55, 0x84, 0x55, 0x84, 0x55, 0x99, 0x55, 0xab,
    0x55, 0xb3, 0x55, 0xc2, 0x55, 0x16, 0x57, 0x06,
    0x56, 0x17, 0x57, 0x51, 0x56, 0x74, 0x56, 0x07,
    0x52, 0xee, 0x58, 0xce, 0x57, 0xf4, 0x57, 0x0d,
    0x58, 0x8b, 0x57, 0x32, 0x58, 0x31, 0x58, 0xac,
    0x58, 0xe4, 0x14, 0xf2, 0x58, 0xf7, 0x58, 0x06,
    0x59, 0x1a, 0x59, 0x22, 0x59, 0x62, 0x59, 0xa8,
    0x16, 0xea, 0x16, 0xec, 0x59, 0x1b, 0x5a, 0x27,
    0x5a, 0xd8, 0x59, 0x66, 0x5a, 0xee, 0x36, 0xfc,
    0x36, 0x08, 0x5b, 0x3e, 0x5b, 0x3e, 0x5b, 0xc8,
    0x19, 0xc3, 0x5b, 0xd8, 0x5b, 0xe7, 0x5b, 0xf3,
    0x5b, 0x18, 0x1b, 0xff, 0x5b, 0x06, 0x5c, 0x53,
    0x5f, 0x22, 0x5c, 0x81, 0x37, 0x60, 0x5c, 0x6e,
    0x5c, 0xc0, 0x5c, 0x8d, 0x5c, 0xe4, 0x1d, 0x43,
    0x5d, 0xe6, 0x1d, 0x6e, 0x5d, 0x6b, 0x5d, 0x7c,
    0x5d, 0xe1, 0x5d, 0xe2, 0x5d, 0x2f, 0x38, 0xfd,
    0x5d, 0x28, 0x5e, 0x3d, 0x5e, 0x69, 0x5e, 0x62,
    0x38, 0x83, 0x21, 0x7c, 0x38, 0xb0, 0x5e, 0xb3,
    0x5e, 0xb6, 0x5e, 0xca, 0x5e, 0x92, 0xa3, 0xfe,
    0x5e, 0x31, 0x23, 0x31, 0x23, 0x01, 0x82, 0x22,
    0x5f, 0x22, 0x5f, 0xc7, 0x38, 0xb8, 0x32, 0xda,
    0x61, 0x62, 0x5f, 0x6b, 0x5f, 0xe3, 0x38, 0x9a,
    0x5f, 0xcd, 0x5f, 0xd7, 0x5f, 0xf9, 0x5f, 0x81,
    0x60, 0x3a, 0x39, 0x1c, 0x39, 0x94, 0x60, 0xd4,
    0x26, 0xc7, 0x60, 0x02, 0x02, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x08, 0x00, 0x0a, 0x00,
    0x00, 0x02, 0x08, 0x00, 0x80, 0x08, 0x00, 0x00,
    0x08, 0x80, 0x28, 0x80, 0x02, 0x00, 0x00, 0x02,
    0x48, 0x61, 0x00, 0x04, 0x06, 0x04, 0x32, 0x46,
    0x6a, 0x5c, 0x67, 0x96, 0xaa, 0xae, 0xc8, 0xd3,
    0x5d, 0x62, 0x00, 0x54, 0x77, 0xf3, 0x0c, 0x2b,
    0x3d, 0x63, 0xfc, 0x62, 0x68, 0x63, 0x83, 0x63,
    0xe4, 0x63, 0xf1, 0x2b, 0x22, 0x64, 0xc5, 0x63,
    0xa9, 0x63, 0x2e, 0x3a, 0x69, 0x64, 0x7e, 0x64,
    0x9d, 0x64, 0x77, 0x64, 0x6c, 0x3a, 0x4f, 0x65,
    0x6c, 0x65, 0x0a, 0x30, 0xe3, 0x65, 0xf8, 0x66,
    0x49, 0x66, 0x19, 0x3b, 0x91, 0x66, 0x08, 0x3b,
    0xe4, 0x3a, 0x92, 0x51, 0x95, 0x51, 0x00, 0x67,
    0x9c, 0x66, 0xad, 0x80, 0xd9, 0x43, 0x17, 0x67,
    0x1b, 0x67, 0x21, 0x67, 0x5e, 0x67, 0x53, 0x67,
    0xc3, 0x33, 0x49, 0x3b, 0xfa, 0x67, 0x85, 0x67,
    0x52, 0x68, 0x85, 0x68, 0x6d, 0x34, 0x8e, 0x68,
    0x1f, 0x68, 0x14, 0x69, 0x9d, 0x3b, 0x42, 0x69,
    0xa3, 0x69, 0xea, 0x69, 0xa8, 0x6a, 0xa3, 0x36,
    0xdb, 0x6a, 0x18, 0x3c, 0x21, 0x6b, 0xa7, 0x38,
    0x54, 0x6b, 0x4e, 0x3c, 0x72, 0x6b, 0x9f, 0x6b,
    0xba, 0x6b, 0xbb, 0x6b, 0x8d, 0x3a, 0x0b, 0x1d,
    0xfa, 0x3a, 0x4e, 0x6c, 0xbc, 0x3c, 0xbf, 0x6c,
    0xcd, 0x6c, 0x67, 0x6c, 0x16, 0x6d, 0x3e, 0x6d,
    0x77, 0x6d, 0x41, 0x6d, 0x69, 0x6d, 0x78, 0x6d,
    0x85, 0x6d, 0x1e, 0x3d, 0x34, 0x6d, 0x2f, 0x6e,
    0x6e, 0x6e, 0x33, 0x3d, 0xcb, 0x6e, 0xc7, 0x6e,
    0xd1, 0x3e, 0xf9, 0x6d, 0x6e, 0x6f, 0x5e, 0x3f,
    0x8e, 0x3f, 0xc6, 0x6f, 0x39, 0x70, 0x1e, 0x70,
    0x1b, 0x70, 0x96, 0x3d, 0x4a, 0x70, 0x7d, 0x70,
    0x77, 0x70, 0xad, 0x70, 0x25, 0x05, 0x45, 0x71,
    0x63, 0x42, 0x9c, 0x71, 0xab, 0x43, 0x28, 0x72,
    0x35, 0x72, 0x50, 0x72, 0x08, 0x46, 0x80, 0x72,
    0x95, 0x72, 0x35, 0x47, 0x02, 0x20, 0x00, 0x00,
    0x20, 0x00, 0x00, 0x00, 0x00, 0x08, 0x80, 0x00,
    0x00, 0x02, 0x02, 0x80, 0x8a, 0x00, 0x00, 0x20,
    0x00, 0x08, 0x0a, 0x00, 0x80, 0x88, 0x80, 0x20,
    0x14, 0x48, 0x7a, 0x73, 0x8b, 0x73, 0xac, 0x3e,
    0xa5, 0x73, 0xb8, 0x3e, 0xb8, 0x3e, 0x47, 0x74,
    0x5c, 0x74, 0x71, 0x74, 0x85, 0x74, 0xca, 0x74,
    0x1b, 0x3f, 0x24, 0x75, 0x36, 0x4c, 0x3e, 0x75,
    0x92, 0x4c, 0x70, 0x75, 0x9f, 0x21, 0x10, 0x76,
    0xa1, 0x4f, 0xb8, 0x4f, 0x44, 0x50, 0xfc, 0x3f,
    0x08, 0x40, 0xf4, 0x76, 0xf3, 0x50, 0xf2, 0x50,
    0x19, 0x51, 0x33, 0x51, 0x1e, 0x77, 0x1f, 0x77,
    0x1f, 0x77, 0x4a, 0x77, 0x39, 0x40, 0x8b, 0x77,
    0x46, 0x40, 0x96, 0x40, 0x1d, 0x54, 0x4e, 0x78,
    0x8c, 0x78, 0xcc, 0x78, 0xe3, 0x40, 0x26, 0x56,
    0x56, 0x79, 0x9a, 0x56, 0xc5, 0x56, 0x8f, 0x79,
    0xeb, 0x79, 0x2f, 0x41, 0x40, 0x7a, 0x4a, 0x7a,
    0x4f, 0x7a, 0x7c, 0x59, 0xa7, 0x5a, 0xa7, 0x5a,
    0xee, 0x7a, 0x02, 0x42, 0xab, 0x5b, 0xc6, 0x7b,
    0xc9, 0x7b, 0x27, 0x42, 0x80, 0x5c, 0xd2, 0x7c,
    0xa0, 0x42, 0xe8, 0x7c, 0xe3, 0x7c, 0x00, 0x7d,
    0x86, 0x5f, 0x63, 0x7d, 0x01, 0x43, 0xc7, 0x7d,
    0x02, 0x7e, 0x45, 0x7e, 0x34, 0x43, 0x28, 0x62,
    0x47, 0x62, 0x59, 0x43, 0xd9, 0x62, 0x7a, 0x7f,
    0x3e, 0x63, 0x95, 0x7f, 0xfa, 0x7f, 0x05, 0x80,
    0xda, 0x64, 0x23, 0x65, 0x60, 0x80, 0xa8, 0x65,
    0x70, 0x80, 0x5f, 0x33, 0xd5, 0x43, 0xb2, 0x80,
    0x03, 0x81, 0x0b, 0x44, 0x3e, 0x81, 0xb5, 0x5a,
    0xa7, 0x67, 0xb5, 0x67, 0x93, 0x33, 0x9c, 0x33,
    0x01, 0x82, 0x04, 0x82, 0x9e, 0x8f, 0x6b, 0x44,
    0x91, 0x82, 0x8b, 0x82, 0x9d, 0x82, 0xb3, 0x52,
    0xb1, 0x82, 0xb3, 0x82, 0xbd, 0x82, 0xe6, 0x82,
    0x3c, 0x6b, 0xe5, 0x82, 0x1d, 0x83, 0x63, 0x83,
    0xad, 0x83, 0x23, 0x83, 0xbd, 0x83, 0xe7, 0x83,
    0x57, 0x84, 0x53, 0x83, 0xca, 0x83, 0xcc, 0x83,
    0xdc, 0x83, 0x36, 0x6c, 0x6b, 0x6d, 0x02, 0x00,
    0x00, 0x20, 0x22, 0x2a, 0xa0, 0x0a, 0x00, 0x20,
    0x80, 0x28, 0x00, 0xa8, 0x20, 0x20, 0x00, 0x02,
    0x80, 0x22, 0x02, 0x8a, 0x08, 0x00, 0xaa, 0x00,
    0x00, 0x00, 0x02, 0x00, 0x00, 0x28, 0xd5, 0x6c,
    0x2b, 0x45, 0xf1, 0x84, 0xf3, 0x84, 0x16, 0x85,
    0xca, 0x73, 0x64, 0x85, 0x2c, 0x6f, 0x5d, 0x45,
    0x61, 0x45, 0xb1, 0x6f, 0xd2, 0x70, 0x6b, 0x45,
    0x50, 0x86, 0x5c, 0x86, 0x67, 0x86, 0x69, 0x86,
    0xa9, 0x86, 0x88, 0x86, 0x0e, 0x87, 0xe2, 0x86,
    0x79, 0x87, 0x28, 0x87, 0x6b, 0x87, 0x86, 0x87,
    0xd7, 0x45, 0xe1, 0x87, 0x01, 0x88, 0xf9, 0x45,
    0x60, 0x88, 0x63, 0x88, 0x67, 0x76, 0xd7, 0x88,
    0xde, 0x88, 0x35, 0x46, 0xfa, 0x88, 0xbb, 0x34,
    0xae, 0x78, 0x66, 0x79, 0xbe, 0x46, 0xc7, 0x46,
    0xa0, 0x8a, 0xed, 0x8a, 0x8a, 0x8b, 0x55, 0x8c,
    0xa8, 0x7c, 0xab, 0x8c, 0xc1, 0x8c, 0x1b, 0x8d,
    0x77, 0x8d, 0x2f, 0x7f, 0x04, 0x08, 0xcb, 0x8d,
    0xbc, 0x8d, 0xf0, 0x8d, 0xde, 0x08, 0xd4, 0x8e,
    0x38, 0x8f, 0xd2, 0x85, 0xed, 0x85, 0x94, 0x90,
    0xf1, 0x90, 0x11, 0x91, 0x2e, 0x87, 0x1b, 0x91,
    0x38, 0x92, 0xd7, 0x92, 0xd8, 0x92, 0x7c, 0x92,
    0xf9, 0x93, 0x15, 0x94, 0xfa, 0x8b, 0x8b, 0x95,
    0x95, 0x49, 0xb7, 0x95, 0x77, 0x8d, 0xe6, 0x49,
    0xc3, 0x96, 0xb2, 0x5d, 0x23, 0x97, 0x45, 0x91,
    0x1a, 0x92, 0x6e, 0x4a, 0x76, 0x4a, 0xe0, 0x97,
    0x0a, 0x94, 0xb2, 0x4a, 0x96, 0x94, 0x0b, 0x98,
    0x0b, 0x98, 0x29, 0x98, 0xb6, 0x95, 0xe2, 0x98,
    0x33, 0x4b, 0x29, 0x99, 0xa7, 0x99, 0xc2, 0x99,
    0xfe, 0x99, 0xce, 0x4b, 0x30, 0x9b, 0x12, 0x9b,
    0x40, 0x9c, 0xfd, 0x9c, 0xce, 0x4c, 0xed, 0x4c,
    0x67, 0x9d, 0xce, 0xa0, 0xf8, 0x4c, 0x05, 0xa1,
    0x0e, 0xa2, 0x91, 0xa2, 0xbb, 0x9e, 0x56, 0x4d,
    0xf9, 0x9e, 0xfe, 0x9e, 0x05, 0x9f, 0x0f, 0x9f,
    0x16, 0x9f, 0x3b, 0x9f, 0x00, 0xa6, 0x02, 0x88,
    0xa0, 0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x28,
    0x00, 0x08, 0xa0, 0x80, 0xa0, 0x80, 0x00, 0x80,
    0x80, 0x00, 0x0a, 0x88, 0x80, 0x00, 0x80, 0x00,
    0x20, 0x2a, 0x00, 0x80,
};

static const uint16_t unicode_comp_table[945] = {
    0x4a01, 0x49c0, 0x4a02, 0x0280, 0x0281, 0x0282, 0x0283, 0x02c0,
    0x02c2, 0x0a00, 0x0284, 0x2442, 0x0285, 0x07c0, 0x0980, 0x0982,
    0x2440, 0x2280, 0x02c4, 0x2282, 0x2284, 0x2286, 0x02c6, 0x02c8,
    0x02ca, 0x02cc, 0x0287, 0x228a, 0x02ce, 0x228c, 0x2290, 0x2292,
    0x228e, 0x0288, 0x0289, 0x028a, 0x2482, 0x0300, 0x0302, 0x0304,
    0x028b, 0x2480, 0x0308, 0x0984, 0x0986, 0x2458, 0x0a02, 0x0306,
    0x2298, 0x229a, 0x229e, 0x0900, 0x030a, 0x22a0, 0x030c, 0x030e,
    0x0840, 0x0310, 0x0312, 0x22a2, 0x22a6, 0x09c0, 0x22a4, 0x22a8,
    0x22aa, 0x028c, 0x028d, 0x028e, 0x0340, 0x0342, 0x0344, 0x0380,
    0x028f, 0x248e, 0x07c2, 0x0988, 0x098a, 0x2490, 0x0346, 0x22ac,
    0x0400, 0x22b0, 0x0842, 0x22b2, 0x0402, 0x22b4, 0x0440, 0x0444,
    0x22b6, 0x0442, 0x22c2, 0x22c0, 0x22c4, 0x22c6, 0x22c8, 0x0940,
    0x04c0, 0x0291, 0x22ca, 0x04c4, 0x22cc, 0x04c2, 0x22d0, 0x22ce,
    0x0292, 0x0293, 0x0294, 0x0295, 0x0540, 0x0542, 0x0a08, 0x0296,
    0x2494, 0x0544, 0x07c4, 0x098c, 0x098e, 0x06c0, 0x2492, 0x0844,
    0x2308, 0x230a, 0x0580, 0x230c, 0x0584, 0x0990, 0x0992, 0x230e,
    0x0582, 0x2312, 0x0586, 0x0588, 0x2314, 0x058c, 0x2316, 0x0998,
    0x058a, 0x231e, 0x0590, 0x2320, 0x099a, 0x058e, 0x2324, 0x2322,
    0x0299, 0x029a, 0x029b, 0x05c0, 0x05c2, 0x05c4, 0x029c, 0x24ac,
    0x05c6, 0x05c8, 0x07c6, 0x0994, 0x0996, 0x0700, 0x24aa, 0x2326,
    0x05ca, 0x232a, 0x2328, 0x2340, 0x2342, 0x2344, 0x2346, 0x05cc,
    0x234a, 0x2348, 0x234c, 0x234e, 0x2350, 0x24b8, 0x029d, 0x05ce,
    0x24be, 0x0a0c, 0x2352, 0x0600, 0x24bc, 0x24ba, 0x0640, 0x2354,
    0x0642, 0x0644, 0x2356, 0x2358, 0x02a0, 0x02a1, 0x02a2, 0x02a3,
    0x02c1, 0x02c3, 0x0a01, 0x02a4, 0x2443, 0x02a5, 0x07c1, 0x0981,
    0x0983, 0x2441, 0x2281, 0x02c5, 0x2283, 0x2285, 0x2287, 0x02c7,
    0x02c9, 0x02cb, 0x02cd, 0x02a7, 0x228b, 0x02cf, 0x228d, 0x2291,
    0x2293, 0x228f, 0x02a8, 0x02a9, 0x02aa, 0x2483, 0x0301, 0x0303,
    0x0305, 0x02ab, 0x2481, 0x0309, 0x0985, 0x0987, 0x2459, 0x0a03,
    0x0307, 0x2299, 0x229b, 0x229f, 0x0901, 0x030b, 0x22a1, 0x030d,
    0x030f, 0x0841, 0x0311, 0x0313, 0x22a3, 0x22a7, 0x09c1, 0x22a5,
    0x22a9, 0x22ab, 0x2380, 0x02ac, 0x02ad, 0x02ae, 0x0341, 0x0343,
    0x0345, 0x02af, 0x248f, 0x07c3, 0x0989, 0x098b, 0x2491, 0x0347,
    0x22ad, 0x0401, 0x0884, 0x22b1, 0x0843, 0x22b3, 0x0403, 0x22b5,
    0x0441, 0x0445, 0x22b7, 0x0443, 0x22c3, 0x22c1, 0x22c5, 0x22c7,
    0x22c9, 0x0941, 0x04c1, 0x02b1, 0x22cb, 0x04c5, 0x22cd, 0x04c3,
    0x22d1, 0x22cf, 0x02b2, 0x02b3, 0x02b4, 0x02b5, 0x0541, 0x0543,
    0x0a09, 0x02b6, 0x2495, 0x0545, 0x07c5, 0x098d, 0x098f, 0x06c1,
    0x2493, 0x0845, 0x2309, 0x230b, 0x0581, 0x230d, 0x0585, 0x0991,
    0x0993, 0x230f, 0x0583, 0x2313, 0x0587, 0x0589, 0x2315, 0x058d,
    0x2317, 0x0999, 0x058b, 0x231f, 0x2381, 0x0591, 0x2321, 0x099b,
    0x058f, 0x2325, 0x2323, 0x02b9, 0x02ba, 0x02bb, 0x05c1, 0x05c3,
    0x05c5, 0x02bc, 0x24ad, 0x05c7, 0x05c9, 0x07c7, 0x0995, 0x0997,
    0x0701, 0x24ab, 0x2327, 0x05cb, 0x232b, 0x2329, 0x2341, 0x2343,
    0x2345, 0x2347, 0x05cd, 0x234b, 0x2349, 0x2382, 0x234d, 0x234f,
    0x2351, 0x24b9, 0x02bd, 0x05cf, 0x24bf, 0x0a0d, 0x2353, 0x02bf,
    0x24bd, 0x2383, 0x24bb, 0x0641, 0x2355, 0x0643, 0x0645, 0x2357,
    0x2359, 0x3101, 0x0c80, 0x2e00, 0x2446, 0x2444, 0x244a, 0x2448,
    0x0800, 0x0942, 0x0944, 0x0804, 0x2288, 0x2486, 0x2484, 0x248a,
    0x2488, 0x22ae, 0x2498, 0x2496, 0x249c, 0x249a, 0x2300, 0x0a06,
    0x2302, 0x0a04, 0x0946, 0x07ce, 0x07ca, 0x07c8, 0x07cc, 0x2447,
    0x2445, 0x244b, 0x2449, 0x0801, 0x0943, 0x0945, 0x0805, 0x2289,
    0x2487, 0x2485, 0x248b, 0x2489, 0x22af, 0x2499, 0x2497, 0x249d,
    0x249b, 0x2301, 0x0a07, 0x2303, 0x0a05, 0x0947, 0x07cf, 0x07cb,
    0x07c9, 0x07cd, 0x2450, 0x244e, 0x2454, 0x2452, 0x2451, 0x244f,
    0x2455, 0x2453, 0x2294, 0x2296, 0x2295, 0x2297, 0x2304, 0x2306,
    0x2305, 0x2307, 0x2318, 0x2319, 0x231a, 0x231b, 0x232c, 0x232d,
    0x232e, 0x232f, 0x2400, 0x24a2, 0x24a0, 0x24a6, 0x24a4, 0x24a8,
    0x24a3, 0x24a1, 0x24a7, 0x24a5, 0x24a9, 0x24b0, 0x24ae, 0x24b4,
    0x24b2, 0x24b6, 0x24b1, 0x24af, 0x24b5, 0x24b3, 0x24b7, 0x0882,
    0x0880, 0x0881, 0x0802, 0x0803, 0x229c, 0x229d, 0x0a0a, 0x0a0b,
    0x0883, 0x0b40, 0x2c8a, 0x0c81, 0x2c89, 0x2c88, 0x2540, 0x2541,
    0x2d00, 0x2e07, 0x0d00, 0x2640, 0x2641, 0x2e80, 0x0d01, 0x26c8,
    0x26c9, 0x2f00, 0x2f84, 0x0d02, 0x2f83, 0x2f82, 0x0d40, 0x26d8,
    0x26d9, 0x3186, 0x0d04, 0x2740, 0x2741, 0x3100, 0x3086, 0x0d06,
    0x3085, 0x3084, 0x0d41, 0x2840, 0x3200, 0x0d07, 0x284f, 0x2850,
    0x3280, 0x2c84, 0x2e03, 0x2857, 0x0d42, 0x2c81, 0x2c80, 0x24c0,
    0x24c1, 0x2c86, 0x2c83, 0x28c0, 0x0d43, 0x25c0, 0x25c1, 0x2940,
    0x0d44, 0x26c0, 0x26c1, 0x2e05, 0x2e02, 0x29c0, 0x0d45, 0x2f05,
    0x2f04, 0x0d80, 0x26d0, 0x26d1, 0x2f80, 0x2a40, 0x0d82, 0x26e0,
    0x26e1, 0x3080, 0x3081, 0x2ac0, 0x0d83, 0x3004, 0x3003, 0x0d81,
    0x27c0, 0x27c1, 0x3082, 0x2b40, 0x0d84, 0x2847, 0x2848, 0x3184,
    0x3181, 0x2f06, 0x0d08, 0x2f81, 0x3005, 0x0d46, 0x3083, 0x3182,
    0x0e00, 0x0e01, 0x0f40, 0x1180, 0x1182, 0x0f03, 0x0f00, 0x11c0,
    0x0f01, 0x1140, 0x1202, 0x1204, 0x0f81, 0x1240, 0x0fc0, 0x1242,
    0x0f80, 0x1244, 0x1284, 0x0f82, 0x1286, 0x1288, 0x128a, 0x12c0,
    0x1282, 0x1181, 0x1183, 0x1043, 0x1040, 0x11c1, 0x1041, 0x1141,
    0x1203, 0x1205, 0x10c1, 0x1241, 0x1000, 0x1243, 0x10c0, 0x1245,
    0x1285, 0x10c2, 0x1287, 0x1289, 0x128b, 0x12c1, 0x1283, 0x1080,
    0x1100, 0x1101, 0x1200, 0x1201, 0x1280, 0x1281, 0x1340, 0x1341,
    0x1343, 0x1342, 0x1344, 0x13c2, 0x1400, 0x13c0, 0x1440, 0x1480,
    0x14c0, 0x1540, 0x1541, 0x1740, 0x1700, 0x1741, 0x17c0, 0x1800,
    0x1802, 0x1801, 0x1840, 0x1880, 0x1900, 0x18c0, 0x18c1, 0x1901,
    0x1940, 0x1942, 0x1941, 0x1980, 0x19c0, 0x19c2, 0x19c1, 0x1c80,
    0x1cc0, 0x1dc0, 0x1f80, 0x2000, 0x2002, 0x2004, 0x2006, 0x2008,
    0x2040, 0x2080, 0x2082, 0x20c0, 0x20c1, 0x2100, 0x22b8, 0x22b9,
    0x2310, 0x2311, 0x231c, 0x231d, 0x244c, 0x2456, 0x244d, 0x2457,
    0x248c, 0x248d, 0x249e, 0x249f, 0x2500, 0x2502, 0x2504, 0x2bc0,
    0x2501, 0x2503, 0x2505, 0x2bc1, 0x2bc2, 0x2bc3, 0x2bc4, 0x2bc5,
    0x2bc6, 0x2bc7, 0x2580, 0x2582, 0x2584, 0x2bc8, 0x2581, 0x2583,
    0x2585, 0x2bc9, 0x2bca, 0x2bcb, 0x2bcc, 0x2bcd, 0x2bce, 0x2bcf,
    0x2600, 0x2602, 0x2601, 0x2603, 0x2680, 0x2682, 0x2681, 0x2683,
    0x26c2, 0x26c4, 0x26c6, 0x2c00, 0x26c3, 0x26c5, 0x26c7, 0x2c01,
    0x2c02, 0x2c03, 0x2c04, 0x2c05, 0x2c06, 0x2c07, 0x26ca, 0x26cc,
    0x26ce, 0x2c08, 0x26cb, 0x26cd, 0x26cf, 0x2c09, 0x2c0a, 0x2c0b,
    0x2c0c, 0x2c0d, 0x2c0e, 0x2c0f, 0x26d2, 0x26d4, 0x26d6, 0x26d3,
    0x26d5, 0x26d7, 0x26da, 0x26dc, 0x26de, 0x26db, 0x26dd, 0x26df,
    0x2700, 0x2702, 0x2701, 0x2703, 0x2780, 0x2782, 0x2781, 0x2783,
    0x2800, 0x2802, 0x2804, 0x2801, 0x2803, 0x2805, 0x2842, 0x2844,
    0x2846, 0x2849, 0x284b, 0x284d, 0x2c40, 0x284a, 0x284c, 0x284e,
    0x2c41, 0x2c42, 0x2c43, 0x2c44, 0x2c45, 0x2c46, 0x2c47, 0x2851,
    0x2853, 0x2855, 0x2c48, 0x2852, 0x2854, 0x2856, 0x2c49, 0x2c4a,
    0x2c4b, 0x2c4c, 0x2c4d, 0x2c4e, 0x2c4f, 0x2c82, 0x2e01, 0x3180,
    0x2c87, 0x2f01, 0x2f02, 0x2f03, 0x2e06, 0x3185, 0x3000, 0x3001,
    0x3002, 0x4640, 0x4641, 0x4680, 0x46c0, 0x46c2, 0x46c1, 0x4700,
    0x4740, 0x4780, 0x47c0, 0x47c2, 0x4900, 0x4940, 0x4980, 0x4982,
    0x4a00, 0x49c2, 0x4a03, 0x4a04, 0x4a40, 0x4a41, 0x4a80, 0x4a81,
    0x4ac0, 0x4ac1, 0x4bc0, 0x4bc1, 0x4b00, 0x4b01, 0x4b40, 0x4b41,
    0x4bc2, 0x4bc3, 0x4b80, 0x4b81, 0x4b82, 0x4b83, 0x4c00, 0x4c01,
    0x4c02, 0x4c03, 0x5600, 0x5440, 0x5442, 0x5444, 0x5446, 0x5448,
    0x544a, 0x544c, 0x544e, 0x5450, 0x5452, 0x5454, 0x5456, 0x5480,
    0x5482, 0x5484, 0x54c0, 0x54c1, 0x5500, 0x5501, 0x5540, 0x5541,
    0x5580, 0x5581, 0x55c0, 0x55c1, 0x5680, 0x58c0, 0x5700, 0x5702,
    0x5704, 0x5706, 0x5708, 0x570a, 0x570c, 0x570e, 0x5710, 0x5712,
    0x5714, 0x5716, 0x5740, 0x5742, 0x5744, 0x5780, 0x5781, 0x57c0,
    0x57c1, 0x5800, 0x5801, 0x5840, 0x5841, 0x5880, 0x5881, 0x5900,
    0x5901, 0x5902, 0x5903, 0x5940, 0x8f40, 0x8f42, 0x8f80, 0x8fc0,
    0x8fc1, 0x9000, 0x9001, 0x9041, 0x9040, 0x9043, 0x9080, 0x9081,
    0x90c0,
};

typedef enum {
    UNICODE_GC_Cn,
    UNICODE_GC_Lu,
    UNICODE_GC_Ll,
    UNICODE_GC_Lt,
    UNICODE_GC_Lm,
    UNICODE_GC_Lo,
    UNICODE_GC_Mn,
    UNICODE_GC_Mc,
    UNICODE_GC_Me,
    UNICODE_GC_Nd,
    UNICODE_GC_Nl,
    UNICODE_GC_No,
    UNICODE_GC_Sm,
    UNICODE_GC_Sc,
    UNICODE_GC_Sk,
    UNICODE_GC_So,
    UNICODE_GC_Pc,
    UNICODE_GC_Pd,
    UNICODE_GC_Ps,
    UNICODE_GC_Pe,
    UNICODE_GC_Pi,
    UNICODE_GC_Pf,
    UNICODE_GC_Po,
    UNICODE_GC_Zs,
    UNICODE_GC_Zl,
    UNICODE_GC_Zp,
    UNICODE_GC_Cc,
    UNICODE_GC_Cf,
    UNICODE_GC_Cs,
    UNICODE_GC_Co,
    UNICODE_GC_LC,
    UNICODE_GC_L,
    UNICODE_GC_M,
    UNICODE_GC_N,
    UNICODE_GC_S,
    UNICODE_GC_P,
    UNICODE_GC_Z,
    UNICODE_GC_C,
    UNICODE_GC_COUNT,
} UnicodeGCEnum;

static const char unicode_gc_name_table[] =
    "Cn,Unassigned"            "\0"
    "Lu,Uppercase_Letter"      "\0"
    "Ll,Lowercase_Letter"      "\0"
    "Lt,Titlecase_Letter"      "\0"
    "Lm,Modifier_Letter"       "\0"
    "Lo,Other_Letter"          "\0"
    "Mn,Nonspacing_Mark"       "\0"
    "Mc,Spacing_Mark"          "\0"
    "Me,Enclosing_Mark"        "\0"
    "Nd,Decimal_Number,digit"  "\0"
    "Nl,Letter_Number"         "\0"
    "No,Other_Number"          "\0"
    "Sm,Math_Symbol"           "\0"
    "Sc,Currency_Symbol"       "\0"
    "Sk,Modifier_Symbol"       "\0"
    "So,Other_Symbol"          "\0"
    "Pc,Connector_Punctuation" "\0"
    "Pd,Dash_Punctuation"      "\0"
    "Ps,Open_Punctuation"      "\0"
    "Pe,Close_Punctuation"     "\0"
    "Pi,Initial_Punctuation"   "\0"
    "Pf,Final_Punctuation"     "\0"
    "Po,Other_Punctuation"     "\0"
    "Zs,Space_Separator"       "\0"
    "Zl,Line_Separator"        "\0"
    "Zp,Paragraph_Separator"   "\0"
    "Cc,Control,cntrl"         "\0"
    "Cf,Format"                "\0"
    "Cs,Surrogate"             "\0"
    "Co,Private_Use"           "\0"
    "LC,Cased_Letter"          "\0"
    "L,Letter"                 "\0"
    "M,Mark,Combining_Mark"    "\0"
    "N,Number"                 "\0"
    "S,Symbol"                 "\0"
    "P,Punctuation,punct"      "\0"
    "Z,Separator"              "\0"
    "C,Other"                  "\0"
;

static const uint8_t unicode_gc_table[3897] = {
    0xfa, 0x18, 0x17, 0x56, 0x0d, 0x56, 0x12, 0x13,
    0x16, 0x0c, 0x16, 0x11, 0x36, 0xe9, 0x02, 0x36,
    0x4c, 0x36, 0xe1, 0x12, 0x12, 0x16, 0x13, 0x0e,
    0x10, 0x0e, 0xe2, 0x12, 0x12, 0x0c, 0x13, 0x0c,
    0xfa, 0x19, 0x17, 0x16, 0x6d, 0x0f, 0x16, 0x0e,
    0x0f, 0x05, 0x14, 0x0c, 0x1b, 0x0f, 0x0e, 0x0f,
    0x0c, 0x2b, 0x0e, 0x02, 0x36, 0x0e, 0x0b, 0x05,
    0x15, 0x4b, 0x16, 0xe1, 0x0f, 0x0c, 0xc1, 0xe2,
    0x10, 0x0c, 0xe2, 0x00, 0xff, 0x30, 0x02, 0xff,
    0x08, 0x02, 0xff, 0x27, 0xbf, 0x22, 0x21, 0x02,
    0x5f, 0x5f, 0x21, 0x22, 0x61, 0x02, 0x21, 0x02,
    0x41, 0x42, 0x21, 0x02, 0x21, 0x02, 0x9f, 0x7f,
    0x02, 0x5f, 0x5f, 0x21, 0x02, 0x5f, 0x3f, 0x02,
    0x05, 0x3f, 0x22, 0x65, 0x01, 0x03, 0x02, 0x01,
    0x03, 0x02, 0x01, 0x03, 0x02, 0xff, 0x08, 0x02,
    0xff, 0x0a, 0x02, 0x01, 0x03, 0x02, 0x5f, 0x21,
    0x02, 0xff, 0x32, 0xa2, 0x21, 0x02, 0x21, 0x22,
    0x5f, 0x41, 0x02, 0xff, 0x00, 0xe2, 0x3c, 0x05,
    0xe2, 0x13, 0xe4, 0x0a, 0x6e, 0xe4, 0x04, 0xee,
    0x06, 0x84, 0xce, 0x04, 0x0e, 0x04, 0xee, 0x09,
    0xe6, 0x68, 0x7f, 0x04, 0x0e, 0x3f, 0x20, 0x04,
    0x42, 0x16, 0x01, 0x60, 0x2e, 0x01, 0x16, 0x41,
    0x00, 0x01, 0x00, 0x21, 0x02, 0xe1, 0x09, 0x00,
    0xe1, 0x01, 0xe2, 0x1b, 0x3f, 0x02, 0x41, 0x42,
    0xff, 0x10, 0x62, 0x3f, 0x0c, 0x5f, 0x3f, 0x02,
    0xe1, 0x2b, 0xe2, 0x28, 0xff, 0x1a, 0x0f, 0x86,
    0x28, 0xff, 0x2f, 0xff, 0x06, 0x02, 0xff, 0x58,
    0x00, 0xe1, 0x1e, 0x20, 0x04, 0xb6, 0xe2, 0x21,
    0x16, 0x11, 0x20, 0x2f, 0x0d, 0x00, 0xe6, 0x25,
    0x11, 0x06, 0x16, 0x26, 0x16, 0x26, 0x16, 0x06,
    0xe0, 0x00, 0xe5, 0x13, 0x60, 0x65, 0x36, 0xe0,
    0x03, 0xbb, 0x4c, 0x36, 0x0d, 0x36, 0x2f, 0xe6,
    0x03, 0x16, 0x1b, 0x56, 0xe5, 0x18, 0x04, 0xe5,
    0x02, 0xe6, 0x0d, 0xe9, 0x02, 0x76, 0x25, 0x06,
    0xe5, 0x5b, 0x16, 0x05, 0xc6, 0x1b, 0x0f, 0xa6,
    0x24, 0x26, 0x0f, 0x66, 0x25, 0xe9, 0x02, 0x45,
    0x2f, 0x05, 0xf6, 0x06, 0x00, 0x1b, 0x05, 0x06,
    0xe5, 0x16, 0xe6, 0x13, 0x20, 0xe5, 0x51, 0xe6,
    0x03, 0x05, 0xe0, 0x06, 0xe9, 0x02, 0xe5, 0x19,
    0xe6, 0x01, 0x24, 0x0f, 0x56, 0x04, 0x20, 0x06,
    0x2d, 0xe5, 0x0e, 0x66, 0x04, 0xe6, 0x01, 0x04,
    0x46, 0x04, 0x86, 0x20, 0xf6, 0x07, 0x00, 0xe5,
    0x11, 0x46, 0x20, 0x16, 0x00, 0xe5, 0x03, 0x80,
    0xe5, 0x10, 0x0e, 0xa5, 0x00, 0x3b, 0xa0, 0xe6,
    0x00, 0xe5, 0x21, 0x04, 0xe6, 0x10, 0x1b, 0xe6,
    0x18, 0x07, 0xe5, 0x2e, 0x06, 0x07, 0x06, 0x05,
    0x47, 0xe6, 0x00, 0x67, 0x06, 0x27, 0x05, 0xc6,
    0xe5, 0x02, 0x26, 0x36, 0xe9, 0x02, 0x16, 0x04,
    0xe5, 0x07, 0x06, 0x27, 0x00, 0xe5, 0x00, 0x20,
    0x25, 0x20, 0xe5, 0x0e, 0x00, 0xc5, 0x00, 0x05,
    0x40, 0x65, 0x20, 0x06, 0x05, 0x47, 0x66, 0x20,
    0x27, 0x20, 0x27, 0x06, 0x05, 0xe0, 0x00, 0x07,
    0x60, 0x25, 0x00, 0x45, 0x26, 0x20, 0xe9, 0x02,
    0x25, 0x2d, 0xab, 0x0f, 0x0d, 0x05, 0x16, 0x06,
    0x20, 0x26, 0x07, 0x00, 0xa5, 0x60, 0x25, 0x20,
    0xe5, 0x0e, 0x00, 0xc5, 0x00, 0x25, 0x00, 0x25,
    0x00, 0x25, 0x20, 0x06, 0x00, 0x47, 0x26, 0x60,
    0x26, 0x20, 0x46, 0x40, 0x06, 0xc0, 0x65, 0x00,
    0x05, 0xc0, 0xe9, 0x02, 0x26, 0x45, 0x06, 0x16,
    0xe0, 0x02, 0x26, 0x07, 0x00, 0xe5, 0x01, 0x00,
    0x45, 0x00, 0xe5, 0x0e, 0x00, 0xc5, 0x00, 0x25,
    0x00, 0x85, 0x20, 0x06, 0x05, 0x47, 0x86, 0x00,
    0x26, 0x07, 0x00, 0x27, 0x06, 0x20, 0x05, 0xe0,
    0x07, 0x25, 0x26, 0x20, 0xe9, 0x02, 0x16, 0x0d,
    0xc0, 0x05, 0xa6, 0x00, 0x06, 0x27, 0x00, 0xe5,
    0x00, 0x20, 0x25, 0x20, 0xe5, 0x0e, 0x00, 0xc5,
    0x00, 0x25, 0x00, 0x85, 0x20, 0x06, 0x05, 0x07,
    0x06, 0x07, 0x66, 0x20, 0x27, 0x20, 0x27, 0x06,
    0xc0, 0x26, 0x07, 0x60, 0x25, 0x00, 0x45, 0x26,
    0x20, 0xe9, 0x02, 0x0f, 0x05, 0xab, 0xe0, 0x02,
    0x06, 0x05, 0x00, 0xa5, 0x40, 0x45, 0x00, 0x65,
    0x40, 0x25, 0x00, 0x05, 0x00, 0x25, 0x40, 0x25,
    0x40, 0x45, 0x40, 0xe5, 0x04, 0x60, 0x27, 0x06,
    0x27, 0x40, 0x47, 0x00, 0x47, 0x06, 0x20, 0x05,
    0xa0, 0x07, 0xe0, 0x06, 0xe9, 0x02, 0x4b, 0xaf,
    0x0d, 0x0f, 0x80, 0x06, 0x47, 0x06, 0xe5, 0x00,
    0x00, 0x45, 0x00, 0xe5, 0x0f, 0x00, 0xe5, 0x08,
    0x20, 0x06, 0x05, 0x46, 0x67, 0x00, 0x46, 0x00,
    0x66, 0xc0, 0x26, 0x00, 0x45, 0x20, 0x05, 0x20,
    0x25, 0x26, 0x20, 0xe9, 0x02, 0xc0, 0x16, 0xcb,
    0x0f, 0x05, 0x06, 0x27, 0x16, 0xe5, 0x00, 0x00,
    0x45, 0x00, 0xe5, 0x0f, 0x00, 0xe5, 0x02, 0x00,
    0x85, 0x20, 0x06, 0x05, 0x07, 0x06, 0x87, 0x00,
    0x06, 0x27, 0x00, 0x27, 0x26, 0xc0, 0x27, 0xa0,
    0x25, 0x00, 0x25, 0x26, 0x20, 0xe9, 0x02, 0x00,
    0x25, 0xe0, 0x05, 0x26, 0x27, 0xe5, 0x01, 0x00,
    0x45, 0x00, 0xe5, 0x21, 0x26, 0x05, 0x47, 0x66,
    0x00, 0x47, 0x00, 0x47, 0x06, 0x05, 0x0f, 0x60,
    0x45, 0x07, 0xcb, 0x45, 0x26, 0x20, 0xe9, 0x02,
    0xeb, 0x01, 0x0f, 0xa5, 0x00, 0x06, 0x27, 0x00,
    0xe5, 0x0a, 0x40, 0xe5, 0x10, 0x00, 0xe5, 0x01,
    0x00, 0x05, 0x20, 0xc5, 0x40, 0x06, 0x60, 0x47,
    0x46, 0x00, 0x06, 0x00, 0xe7, 0x00, 0xa0, 0xe9,
    0x02, 0x20, 0x27, 0x16, 0xe0, 0x04, 0xe5, 0x28,
    0x06, 0x25, 0xc6, 0x60, 0x0d, 0xa5, 0x04, 0xe6,
    0x00, 0x16, 0xe9, 0x02, 0x36, 0xe0, 0x1d, 0x25,
    0x00, 0x05, 0x00, 0x85, 0x00, 0xe5, 0x10, 0x00,
    0x05, 0x00, 0xe5, 0x02, 0x06, 0x25, 0xe6, 0x01,
    0x05, 0x20, 0x85, 0x00, 0x04, 0x00, 0xa6, 0x20,
    0xe9, 0x02, 0x20, 0x65, 0xe0, 0x18, 0x05, 0x4f,
    0xf6, 0x07, 0x0f, 0x16, 0x4f, 0x26, 0xaf, 0xe9,
    0x02, 0xeb, 0x02, 0x0f, 0x06, 0x0f, 0x06, 0x0f,
    0x06, 0x12, 0x13, 0x12, 0x13, 0x27, 0xe5, 0x00,
    0x00, 0xe5, 0x1c, 0x60, 0xe6, 0x06, 0x07, 0x86,
    0x16, 0x26, 0x85, 0xe6, 0x03, 0x00, 0xe6, 0x1c,
    0x00, 0xef, 0x00, 0x06, 0xaf, 0x00, 0x2f, 0x96,
    0x6f, 0x36, 0xe0, 0x1d, 0xe5, 0x23, 0x27, 0x66,
    0x07, 0xa6, 0x07, 0x26, 0x27, 0x26, 0x05, 0xe9,
    0x02, 0xb6, 0xa5, 0x27, 0x26, 0x65, 0x46, 0x05,
    0x47, 0x25, 0xc7, 0x45, 0x66, 0xe5, 0x05, 0x06,
    0x27, 0x26, 0xa7, 0x06, 0x05, 0x07, 0xe9, 0x02,
    0x47, 0x06, 0x2f, 0xe1, 0x1e, 0x00, 0x01, 0x80,
    0x01, 0x20, 0xe2, 0x23, 0x16, 0x04, 0x42, 0xe5,
    0x80, 0xc1, 0x00, 0x65, 0x20, 0xc5, 0x00, 0x05,
    0x00, 0x65, 0x20, 0xe5, 0x21, 0x00, 0x65, 0x20,
    0xe5, 0x19, 0x00, 0x65, 0x20, 0xc5, 0x00, 0x05,
    0x00, 0x65, 0x20, 0xe5, 0x07, 0x00, 0xe5, 0x31,
    0x00, 0x65, 0x20, 0xe5, 0x3b, 0x20, 0x46, 0xf6,
    0x01, 0xeb, 0x0c, 0x40, 0xe5, 0x08, 0xef, 0x02,
    0xa0, 0xe1, 0x4e, 0x20, 0xa2, 0x20, 0x11, 0xe5,
    0x81, 0xe4, 0x0f, 0x16, 0xe5, 0x09, 0x17, 0xe5,
    0x12, 0x12, 0x13, 0x40, 0xe5, 0x43, 0x56, 0x4a,
    0xe5, 0x00, 0xc0, 0xe5, 0x0a, 0x46, 0x07, 0xe0,
    0x01, 0xe5, 0x0b, 0x26, 0x07, 0x36, 0xe0, 0x01,
    0xe5, 0x0a, 0x26, 0xe0, 0x04, 0xe5, 0x05, 0x00,
    0x45, 0x00, 0x26, 0xe0, 0x04, 0xe5, 0x2c, 0x26,
    0x07, 0xc6, 0xe7, 0x00, 0x06, 0x27, 0xe6, 0x03,
    0x56, 0x04, 0x56, 0x0d, 0x05, 0x06, 0x20, 0xe9,
    0x02, 0xa0, 0xeb, 0x02, 0xa0, 0xb6, 0x11, 0x76,
    0x46, 0x1b, 0x06, 0xe9, 0x02, 0xa0, 0xe5, 0x1b,
    0x04, 0xe5, 0x2d, 0xc0, 0x85, 0x26, 0xe5, 0x1a,
    0x06, 0x05, 0x80, 0xe5, 0x3e, 0xe0, 0x02, 0xe5,
    0x17, 0x00, 0x46, 0x67, 0x26, 0x47, 0x60, 0x27,
    0x06, 0xa7, 0x46, 0x60, 0x0f, 0x40, 0x36, 0xe9,
    0x02, 0xe5, 0x16, 0x20, 0x85, 0xe0, 0x03, 0xe5,
    0x24, 0x60, 0xe5, 0x12, 0xa0, 0xe9, 0x02, 0x0b,
    0x40, 0xef, 0x1a, 0xe5, 0x0f, 0x26, 0x27, 0x06,
    0x20, 0x36, 0xe5, 0x2d, 0x07, 0x06, 0x07, 0xc6,
    0x00, 0x06, 0x07, 0x06, 0x27, 0xe6, 0x00, 0xa7,
    0xe6, 0x02, 0x20, 0x06, 0xe9, 0x02, 0xa0, 0xe9,
    0x02, 0xa0, 0xd6, 0x04, 0xb6, 0x20, 0xe6, 0x06,
    0x08, 0xe6, 0x08, 0xe0, 0x29, 0x66, 0x07, 0xe5,
    0x27, 0x06, 0x07, 0x86, 0x07, 0x06, 0x87, 0x06,
    0x27, 0xe5, 0x00, 0x40, 0xe9, 0x02, 0xd6, 0xef,
    0x02, 0xe6, 0x01, 0xef, 0x01, 0x36, 0x00, 0x26,
    0x07, 0xe5, 0x16, 0x07, 0x66, 0x27, 0x26, 0x07,
    0x46, 0x25, 0xe9, 0x02, 0xe5, 0x24, 0x06, 0x07,
    0x26, 0x47, 0x06, 0x07, 0x46, 0x27, 0xe0, 0x00,
    0x76, 0xe5, 0x1c, 0xe7, 0x00, 0xe6, 0x00, 0x27,
    0x26, 0x40, 0x96, 0xe9, 0x02, 0x40, 0x45, 0xe9,
    0x02, 0xe5, 0x16, 0xa4, 0x36, 0xe2, 0x01, 0xc0,
    0xe1, 0x23, 0x20, 0x41, 0xf6, 0x00, 0xe0, 0x00,
    0x46, 0x16, 0xe6, 0x05, 0x07, 0xc6, 0x65, 0x06,
    0xa5, 0x06, 0x25, 0x07, 0x26, 0x05, 0x80, 0xe2,
    0x24, 0xe4, 0x37, 0xe2, 0x05, 0x04, 0xe2, 0x1a,
    0xe4, 0x1d, 0xe6, 0x38, 0xff, 0x80, 0x0e, 0xe2,
    0x00, 0xff, 0x5a, 0xe2, 0x00, 0xe1, 0x00, 0xa2,
    0x20, 0xa1, 0x20, 0xe2, 0x00, 0xe1, 0x00, 0xe2,
    0x00, 0xe1, 0x00, 0xa2, 0x20, 0xa1, 0x20, 0xe2,
    0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x01, 0x00,
    0x3f, 0xc2, 0xe1, 0x00, 0xe2, 0x06, 0x20, 0xe2,
    0x00, 0xe3, 0x00, 0xe2, 0x00, 0xe3, 0x00, 0xe2,
    0x00, 0xe3, 0x00, 0x82, 0x00, 0x22, 0x61, 0x03,
    0x0e, 0x02, 0x4e, 0x42, 0x00, 0x22, 0x61, 0x03,
    0x4e, 0x62, 0x20, 0x22, 0x61, 0x00, 0x4e, 0xe2,
    0x00, 0x81, 0x4e, 0x20, 0x42, 0x00, 0x22, 0x61,
    0x03, 0x2e, 0x00, 0xf7, 0x03, 0x9b, 0xb1, 0x36,
    0x14, 0x15, 0x12, 0x34, 0x15, 0x12, 0x14, 0xf6,
    0x00, 0x18, 0x19, 0x9b, 0x17, 0xf6, 0x01, 0x14,
    0x15, 0x76, 0x30, 0x56, 0x0c, 0x12, 0x13, 0xf6,
    0x03, 0x0c, 0x16, 0x10, 0xf6, 0x02, 0x17, 0x9b,
    0x00, 0xfb, 0x02, 0x0b, 0x04, 0x20, 0xab, 0x4c,
    0x12, 0x13, 0x04, 0xeb, 0x02, 0x4c, 0x12, 0x13,
    0x00, 0xe4, 0x05, 0x40, 0xed, 0x19, 0xe0, 0x07,
    0xe6, 0x05, 0x68, 0x06, 0x48, 0xe6, 0x04, 0xe0,
    0x07, 0x2f, 0x01, 0x6f, 0x01, 0x2f, 0x02, 0x41,
    0x22, 0x41, 0x02, 0x0f, 0x01, 0x2f, 0x0c, 0x81,
    0xaf, 0x01, 0x0f, 0x01, 0x0f, 0x01, 0x0f, 0x61,
    0x0f, 0x02, 0x61, 0x02, 0x65, 0x02, 0x2f, 0x22,
    0x21, 0x8c, 0x3f, 0x42, 0x0f, 0x0c, 0x2f, 0x02,
    0x0f, 0xeb, 0x08, 0xea, 0x1b, 0x3f, 0x6a, 0x0b,
    0x2f, 0x60, 0x8c, 0x8f, 0x2c, 0x6f, 0x0c, 0x2f,
    0x0c, 0x2f, 0x0c, 0xcf, 0x0c, 0xef, 0x17, 0x2c,
    0x2f, 0x0c, 0x0f, 0x0c, 0xef, 0x17, 0xec, 0x80,
    0x84, 0xef, 0x00, 0x12, 0x13, 0x12, 0x13, 0xef,
    0x0c, 0x2c, 0xcf, 0x12, 0x13, 0xef, 0x49, 0x0c,
    0xef, 0x16, 0xec, 0x11, 0xef, 0x20, 0xac, 0xef,
    0x3d, 0xe0, 0x11, 0xef, 0x03, 0xe0, 0x0d, 0xeb,
    0x34, 0xef, 0x46, 0xeb, 0x0e, 0xef, 0x80, 0x2f,
    0x0c, 0xef, 0x01, 0x0c, 0xef, 0x2e, 0xec, 0x00,
    0xef, 0x67, 0x0c, 0xef, 0x80, 0x70, 0x12, 0x13,
    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
    0x12, 0x13, 0x12, 0x13, 0xeb, 0x16, 0xef, 0x24,
    0x8c, 0x12, 0x13, 0xec, 0x17, 0x12, 0x13, 0x12,
    0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0xec,
    0x08, 0xef, 0x80, 0x78, 0xec, 0x7b, 0x12, 0x13,
    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
    0x12, 0x13, 0x12, 0x13, 0xec, 0x37, 0x12, 0x13,
    0x12, 0x13, 0xec, 0x18, 0x12, 0x13, 0xec, 0x80,
    0x7a, 0xef, 0x28, 0xec, 0x0d, 0x2f, 0xac, 0xef,
    0x1f, 0x20, 0xef, 0x18, 0x00, 0xef, 0x61, 0xe1,
    0x28, 0xe2, 0x28, 0x5f, 0x21, 0x22, 0xdf, 0x41,
    0x02, 0x3f, 0x02, 0x3f, 0x82, 0x24, 0x41, 0x02,
    0xff, 0x5a, 0x02, 0xaf, 0x7f, 0x46, 0x3f, 0x80,
    0x76, 0x0b, 0x36, 0xe2, 0x1e, 0x00, 0x02, 0x80,
    0x02, 0x20, 0xe5, 0x30, 0xc0, 0x04, 0x16, 0xe0,
    0x06, 0x06, 0xe5, 0x0f, 0xe0, 0x01, 0xc5, 0x00,
    0xc5, 0x00, 0xc5, 0x00, 0xc5, 0x00, 0xc5, 0x00,
    0xc5, 0x00, 0xc5, 0x00, 0xc5, 0x00, 0xe6, 0x18,
    0x36, 0x14, 0x15, 0x14, 0x15, 0x56, 0x14, 0x15,
    0x16, 0x14, 0x15, 0xf6, 0x01, 0x11, 0x36, 0x11,
    0x16, 0x14, 0x15, 0x36, 0x14, 0x15, 0x12, 0x13,
    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x96, 0x04,
    0xf6, 0x02, 0x31, 0x76, 0x11, 0x16, 0x12, 0xf6,
    0x05, 0x2f, 0x56, 0x12, 0x13, 0x12, 0x13, 0x12,
    0x13, 0x12, 0x13, 0x11, 0xe0, 0x1a, 0xef, 0x12,
    0x00, 0xef, 0x51, 0xe0, 0x04, 0xef, 0x80, 0x4e,
    0xe0, 0x12, 0xef, 0x04, 0x60, 0x17, 0x56, 0x0f,
    0x04, 0x05, 0x0a, 0x12, 0x13, 0x12, 0x13, 0x12,
    0x13, 0x12, 0x13, 0x12, 0x13, 0x2f, 0x12, 0x13,
    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x11, 0x12,
    0x33, 0x0f, 0xea, 0x01, 0x66, 0x27, 0x11, 0x84,
    0x2f, 0x4a, 0x04, 0x05, 0x16, 0x2f, 0x00, 0xe5,
    0x4e, 0x20, 0x26, 0x2e, 0x24, 0x05, 0x11, 0xe5,
    0x52, 0x16, 0x44, 0x05, 0x80, 0xe5, 0x23, 0x00,
    0xe5, 0x56, 0x00, 0x2f, 0x6b, 0xef, 0x02, 0xe5,
    0x18, 0xef, 0x1c, 0xe0, 0x04, 0xe5, 0x08, 0xef,
    0x17, 0x00, 0xeb, 0x02, 0xef, 0x16, 0xeb, 0x00,
    0x0f, 0xeb, 0x07, 0xef, 0x18, 0xeb, 0x02, 0xef,
    0x1f, 0xeb, 0x07, 0xef, 0x80, 0xb8, 0xe5, 0x99,
    0x38, 0xef, 0x38, 0xe5, 0xc0, 0x11, 0x8d, 0x04,
    0xe5, 0x83, 0xef, 0x40, 0xef, 0x2f, 0xe0, 0x01,
    0xe5, 0x20, 0xa4, 0x36, 0xe5, 0x80, 0x84, 0x04,
    0x56, 0xe5, 0x08, 0xe9, 0x02, 0x25, 0xe0, 0x0c,
    0xff, 0x26, 0x05, 0x06, 0x48, 0x16, 0xe6, 0x02,
    0x16, 0x04, 0xff, 0x14, 0x24, 0x26, 0xe5, 0x3e,
    0xea, 0x02, 0x26, 0xb6, 0xe0, 0x00, 0xee, 0x0f,
    0xe4, 0x01, 0x2e, 0xff, 0x06, 0x22, 0xff, 0x36,
    0x04, 0xe2, 0x00, 0x9f, 0xff, 0x02, 0x04, 0x2e,
    0x7f, 0x05, 0x7f, 0x22, 0xff, 0x0d, 0x61, 0x02,
    0x81, 0x02, 0xff, 0x07, 0x41, 0x02, 0x3f, 0x80,
    0x3f, 0x00, 0x02, 0x00, 0x02, 0x7f, 0xe0, 0x10,
    0x44, 0x3f, 0x05, 0x24, 0x02, 0xc5, 0x06, 0x45,
    0x06, 0x65, 0x06, 0xe5, 0x0f, 0x27, 0x26, 0x07,
    0x6f, 0x06, 0x40, 0xab, 0x2f, 0x0d, 0x0f, 0xa0,
    0xe5, 0x2c, 0x76, 0xe0, 0x00, 0x27, 0xe5, 0x2a,
    0xe7, 0x08, 0x26, 0xe0, 0x00, 0x36, 0xe9, 0x02,
    0xa0, 0xe6, 0x0a, 0xa5, 0x56, 0x05, 0x16, 0x25,
    0x06, 0xe9, 0x02, 0xe5, 0x14, 0xe6, 0x00, 0x36,
    0xe5, 0x0f, 0xe6, 0x03, 0x27, 0xe0, 0x03, 0x16,
    0xe5, 0x15, 0x40, 0x46, 0x07, 0xe5, 0x27, 0x06,
    0x27, 0x66, 0x27, 0x26, 0x47, 0xf6, 0x05, 0x00,
    0x04, 0xe9, 0x02, 0x60, 0x36, 0x85, 0x06, 0x04,
    0xe5, 0x01, 0xe9, 0x02, 0x85, 0x00, 0xe5, 0x21,
    0xa6, 0x27, 0x26, 0x27, 0x26, 0xe0, 0x01, 0x45,
    0x06, 0xe5, 0x00, 0x06, 0x07, 0x20, 0xe9, 0x02,
    0x20, 0x76, 0xe5, 0x08, 0x04, 0xa5, 0x4f, 0x05,
    0x07, 0x06, 0x07, 0xe5, 0x2a, 0x06, 0x05, 0x46,
    0x25, 0x26, 0x85, 0x26, 0x05, 0x06, 0x05, 0xe0,
    0x10, 0x25, 0x04, 0x36, 0xe5, 0x03, 0x07, 0x26,
    0x27, 0x36, 0x05, 0x24, 0x07, 0x06, 0xe0, 0x02,
    0xa5, 0x20, 0xa5, 0x20, 0xa5, 0xe0, 0x01, 0xc5,
    0x00, 0xc5, 0x00, 0xe2, 0x23, 0x0e, 0x64, 0xe2,
    0x01, 0x04, 0x2e, 0x60, 0xe2, 0x48, 0xe5, 0x1b,
    0x27, 0x06, 0x27, 0x06, 0x27, 0x16, 0x07, 0x06,
    0x20, 0xe9, 0x02, 0xa0, 0xe5, 0xab, 0x1c, 0xe0,
    0x04, 0xe5, 0x0f, 0x60, 0xe5, 0x29, 0x60, 0xfc,
    0x87, 0x78, 0xfd, 0x98, 0x78, 0xe5, 0x80, 0xe6,
    0x20, 0xe5, 0x62, 0xe0, 0x1e, 0xc2, 0xe0, 0x04,
    0x82, 0x80, 0x05, 0x06, 0xe5, 0x02, 0x0c, 0xe5,
    0x05, 0x00, 0x85, 0x00, 0x05, 0x00, 0x25, 0x00,
    0x25, 0x00, 0xe5, 0x64, 0xee, 0x09, 0xe0, 0x08,
    0xe5, 0x80, 0xe3, 0x13, 0x12, 0xef, 0x08, 0xe5,
    0x38, 0x20, 0xe5, 0x2e, 0xc0, 0x0f, 0xe0, 0x18,
    0xe5, 0x04, 0x0d, 0x4f, 0xe6, 0x08, 0xd6, 0x12,
    0x13, 0x16, 0xa0, 0xe6, 0x08, 0x16, 0x31, 0x30,
    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
    0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13,
    0x36, 0x12, 0x13, 0x76, 0x50, 0x56, 0x00, 0x76,
    0x11, 0x12, 0x13, 0x12, 0x13, 0x12, 0x13, 0x56,
    0x0c, 0x11, 0x4c, 0x00, 0x16, 0x0d, 0x36, 0x60,
    0x85, 0x00, 0xe5, 0x7f, 0x20, 0x1b, 0x00, 0x56,
    0x0d, 0x56, 0x12, 0x13, 0x16, 0x0c, 0x16, 0x11,
    0x36, 0xe9, 0x02, 0x36, 0x4c, 0x36, 0xe1, 0x12,
    0x12, 0x16, 0x13, 0x0e, 0x10, 0x0e, 0xe2, 0x12,
    0x12, 0x0c, 0x13, 0x0c, 0x12, 0x13, 0x16, 0x12,
    0x13, 0x36, 0xe5, 0x02, 0x04, 0xe5, 0x25, 0x24,
    0xe5, 0x17, 0x40, 0xa5, 0x20, 0xa5, 0x20, 0xa5,
    0x20, 0x45, 0x40, 0x2d, 0x0c, 0x0e, 0x0f, 0x2d,
    0x00, 0x0f, 0x6c, 0x2f, 0xe0, 0x02, 0x5b, 0x2f,
    0x20, 0xe5, 0x04, 0x00, 0xe5, 0x12, 0x00, 0xe5,
    0x0b, 0x00, 0x25, 0x00, 0xe5, 0x07, 0x20, 0xe5,
    0x06, 0xe0, 0x1a, 0xe5, 0x73, 0x80, 0x56, 0x60,
    0xeb, 0x25, 0x40, 0xef, 0x01, 0xea, 0x2d, 0x6b,
    0xef, 0x09, 0x2b, 0x4f, 0x00, 0xef, 0x05, 0x40,
    0x0f, 0xe0, 0x27, 0xef, 0x25, 0x06, 0xe0, 0x7a,
    0xe5, 0x15, 0x40, 0xe5, 0x29, 0xe0, 0x07, 0x06,
    0xeb, 0x13, 0x60, 0xe5, 0x18, 0x6b, 0xe0, 0x01,
    0xe5, 0x0c, 0x0a, 0xe5, 0x00, 0x0a, 0x80, 0xe5,
    0x1e, 0x86, 0x80, 0xe5, 0x16, 0x00, 0x16, 0xe5,
    0x1c, 0x60, 0xe5, 0x00, 0x16, 0x8a, 0xe0, 0x22,
    0xe1, 0x20, 0xe2, 0x20, 0xe5, 0x46, 0x20, 0xe9,
    0x02, 0xa0, 0xe1, 0x1c, 0x60, 0xe2, 0x1c, 0x60,
    0xe5, 0x20, 0xe0, 0x00, 0xe5, 0x2c, 0xe0, 0x03,
    0x16, 0xe1, 0x03, 0x00, 0xe1, 0x07, 0x00, 0xc1,
    0x00, 0x21, 0x00, 0xe2, 0x03, 0x00, 0xe2, 0x07,
    0x00, 0xc2, 0x00, 0x22, 0xe0, 0x3b, 0xe5, 0x80,
    0xaf, 0xe0, 0x01, 0xe5, 0x0e, 0xe0, 0x02, 0xe5,
    0x00, 0xe0, 0x10, 0xa4, 0x00, 0xe4, 0x22, 0x00,
    0xe4, 0x01, 0xe0, 0x3d, 0xa5, 0x20, 0x05, 0x00,
    0xe5, 0x24, 0x00, 0x25, 0x40, 0x05, 0x20, 0xe5,
    0x0f, 0x00, 0x16, 0xeb, 0x00, 0xe5, 0x0f, 0x2f,
    0xcb, 0xe5, 0x17, 0xe0, 0x00, 0xeb, 0x01, 0xe0,
    0x28, 0xe5, 0x0b, 0x00, 0x25, 0x80, 0x8b, 0xe5,
    0x0e, 0xab, 0x40, 0x16, 0xe5, 0x12, 0x80, 0x16,
    0xe0, 0x38, 0xe5, 0x30, 0x60, 0x2b, 0x25, 0xeb,
    0x08, 0x20, 0xeb, 0x26, 0x05, 0x46, 0x00, 0x26,
    0x80, 0x66, 0x65, 0x00, 0x45, 0x00, 0xe5, 0x15,
    0x20, 0x46, 0x60, 0x06, 0xeb, 0x01, 0xc0, 0xf6,
    0x01, 0xc0, 0xe5, 0x15, 0x2b, 0x16, 0xe5, 0x15,
    0x4b, 0xe0, 0x18, 0xe5, 0x00, 0x0f, 0xe5, 0x14,
    0x26, 0x60, 0x8b, 0xd6, 0xe0, 0x01, 0xe5, 0x2e,
    0x40, 0xd6, 0xe5, 0x0e, 0x20, 0xeb, 0x00, 0xe5,
    0x0b, 0x80, 0xeb, 0x00, 0xe5, 0x0a, 0xc0, 0x76,
    0xe0, 0x04, 0xcb, 0xe0, 0x48, 0xe5, 0x41, 0xe0,
    0x2f, 0xe1, 0x2b, 0xe0, 0x05, 0xe2, 0x2b, 0xc0,
    0xab, 0xe5, 0x1c, 0x66, 0xe0, 0x00, 0xe9, 0x02,
    0xe0, 0x80, 0x9e, 0xeb, 0x17, 0x00, 0xe5, 0x22,
    0x00, 0x26, 0x11, 0x20, 0x25, 0xe0, 0x46, 0xe5,
    0x15, 0xeb, 0x02, 0x05, 0xe0, 0x00, 0xe5, 0x0e,
    0xe6, 0x03, 0x6b, 0x96, 0xe0, 0x0e, 0xe5, 0x0a,
    0x66, 0x76, 0xe0, 0x1e, 0xe5, 0x0d, 0xcb, 0xe0,
    0x0c, 0xe5, 0x0f, 0xe0, 0x01, 0x07, 0x06, 0x07,
    0xe5, 0x2d, 0xe6, 0x07, 0xd6, 0x60, 0xeb, 0x0c,
    0xe9, 0x02, 0x06, 0x25, 0x26, 0x05, 0xe0, 0x01,
    0x46, 0x07, 0xe5, 0x25, 0x47, 0x66, 0x27, 0x26,
    0x36, 0x1b, 0x76, 0x06, 0xe0, 0x02, 0x1b, 0x20,
    0xe5, 0x11, 0xc0, 0xe9, 0x02, 0xa0, 0x46, 0xe5,
    0x1c, 0x86, 0x07, 0xe6, 0x00, 0x00, 0xe9, 0x02,
    0x76, 0x05, 0x27, 0x05, 0xe0, 0x00, 0xe5, 0x1b,
    0x06, 0x36, 0x05, 0xe0, 0x01, 0x26, 0x07, 0xe5,
    0x28, 0x47, 0xe6, 0x01, 0x27, 0x65, 0x76, 0x66,
    0x16, 0x07, 0x06, 0xe9, 0x02, 0x05, 0x16, 0x05,
    0x56, 0x00, 0xeb, 0x0c, 0xe0, 0x03, 0xe5, 0x0a,
    0x00, 0xe5, 0x11, 0x47, 0x46, 0x27, 0x06, 0x07,
    0x26, 0xb6, 0x06, 0xe0, 0x39, 0xc5, 0x00, 0x05,
    0x00, 0x65, 0x00, 0xe5, 0x07, 0x00, 0xe5, 0x02,
    0x16, 0xa0, 0xe5, 0x27, 0x06, 0x47, 0xe6, 0x00,
    0x80, 0xe9, 0x02, 0xa0, 0x26, 0x27, 0x00, 0xe5,
    0x00, 0x20, 0x25, 0x20, 0xe5, 0x0e, 0x00, 0xc5,
    0x00, 0x25, 0x00, 0x85, 0x00, 0x26, 0x05, 0x27,
    0x06, 0x67, 0x20, 0x27, 0x20, 0x47, 0x20, 0x05,
    0xa0, 0x07, 0x80, 0x85, 0x27, 0x20, 0xc6, 0x40,
    0x86, 0xe0, 0x80, 0x03, 0xe5, 0x2d, 0x47, 0xe6,
    0x00, 0x27, 0x46, 0x07, 0x06, 0x65, 0x96, 0xe9,
    0x02, 0x36, 0x00, 0x16, 0x06, 0x45, 0xe0, 0x16,
    0xe5, 0x28, 0x47, 0xa6, 0x07, 0x06, 0x67, 0x26,
    0x07, 0x26, 0x25, 0x16, 0x05, 0xe0, 0x00, 0xe9,
    0x02, 0xe0, 0x80, 0x1e, 0xe5, 0x27, 0x47, 0x66,
    0x20, 0x67, 0x26, 0x07, 0x26, 0xf6, 0x0f, 0x65,
    0x26, 0xe0, 0x1a, 0xe5, 0x28, 0x47, 0xe6, 0x00,
    0x27, 0x06, 0x07, 0x26, 0x56, 0x05, 0xe0, 0x03,
    0xe9, 0x02, 0xa0, 0xf6, 0x05, 0xe0, 0x0b, 0xe5,
    0x23, 0x06, 0x07, 0x06, 0x27, 0xa6, 0x07, 0x06,
    0x05, 0x16, 0xa0, 0xe9, 0x02, 0xe0, 0x2e, 0xe5,
    0x13, 0x20, 0x46, 0x27, 0x66, 0x07, 0x86, 0x60,
    0xe9, 0x02, 0x2b, 0x56, 0x0f, 0xc5, 0xe0, 0x80,
    0x31, 0xe5, 0x24, 0x47, 0xe6, 0x01, 0x07, 0x26,
    0x16, 0xe0, 0x5c, 0xe1, 0x18, 0xe2, 0x18, 0xe9,
    0x02, 0xeb, 0x01, 0xe0, 0x04, 0xe5, 0x00, 0x20,
    0x05, 0x20, 0xe5, 0x00, 0x00, 0x25, 0x00, 0xe5,
    0x10, 0xa7, 0x00, 0x27, 0x20, 0x26, 0x07, 0x06,
    0x05, 0x07, 0x05, 0x07, 0x06, 0x56, 0xe0, 0x01,
    0xe9, 0x02, 0xe0, 0x3e, 0xe5, 0x00, 0x20, 0xe5,
    0x1f, 0x47, 0x66, 0x20, 0x26, 0x67, 0x06, 0x05,
    0x16, 0x05, 0x07, 0xe0, 0x13, 0x05, 0xe6, 0x02,
    0xe5, 0x20, 0xa6, 0x07, 0x05, 0x66, 0xf6, 0x00,
    0x06, 0xe0, 0x00, 0x05, 0xa6, 0x27, 0x46, 0xe5,
    0x26, 0xe6, 0x05, 0x07, 0x26, 0x56, 0x05, 0x96,
    0xe0, 0x05, 0xe5, 0x41, 0xe0, 0x80, 0x7f, 0xe5,
    0x01, 0x00, 0xe5, 0x1d, 0x07, 0xc6, 0x00, 0xa6,
    0x07, 0x06, 0x05, 0x96, 0xe0, 0x02, 0xe9, 0x02,
    0xeb, 0x0b, 0x40, 0x36, 0xe5, 0x16, 0x20, 0xe6,
    0x0e, 0x00, 0x07, 0xc6, 0x07, 0x26, 0x07, 0x26,
    0xe0, 0x41, 0xc5, 0x00, 0x25, 0x00, 0xe5, 0x1e,
    0xa6, 0x40, 0x06, 0x00, 0x26, 0x00, 0xc6, 0x05,
    0x06, 0xe0, 0x00, 0xe9, 0x02, 0xa0, 0xa5, 0x00,
    0x25, 0x00, 0xe5, 0x18, 0x87, 0x00, 0x26, 0x00,
    0x27, 0x06, 0x07, 0x06, 0x05, 0xc0, 0xe9, 0x02,
    0xe0, 0x80, 0xae, 0xe5, 0x0b, 0x26, 0x27, 0x36,
    0xe0, 0x80, 0x2f, 0x05, 0xe0, 0x07, 0xeb, 0x0d,
    0xef, 0x00, 0x6d, 0xef, 0x09, 0xe0, 0x05, 0x16,
    0xe5, 0x83, 0x12, 0xe0, 0x5e, 0xea, 0x67, 0x00,
    0x96, 0xe0, 0x03, 0xe5, 0x80, 0x3c, 0xe0, 0x89,
    0xc4, 0xe5, 0x59, 0x36, 0xe0, 0x05, 0xe5, 0x83,
    0xa7, 0x00, 0xfb, 0x01, 0xe0, 0x8f, 0x3f, 0xe5,
    0x81, 0xbf, 0xe0, 0xa1, 0x31, 0xe5, 0x81, 0xb1,
    0xc0, 0xe5, 0x17, 0x00, 0xe9, 0x02, 0x60, 0x36,
    0xe5, 0x47, 0x00, 0xe9, 0x02, 0xa0, 0xe5, 0x16,
    0x20, 0x86, 0x16, 0xe0, 0x02, 0xe5, 0x28, 0xc6,
    0x96, 0x6f, 0x64, 0x16, 0x0f, 0xe0, 0x02, 0xe9,
    0x02, 0x00, 0xcb, 0x00, 0xe5, 0x0d, 0x80, 0xe5,
    0x0b, 0xe0, 0x82, 0x28, 0xe1, 0x18, 0xe2, 0x18,
    0xeb, 0x0f, 0x76, 0xe0, 0x5d, 0xe5, 0x43, 0x60,
    0x06, 0x05, 0xe7, 0x2f, 0xc0, 0x66, 0xe4, 0x05,
    0xe0, 0x38, 0x24, 0x16, 0x04, 0x06, 0xe0, 0x03,
    0x27, 0xe0, 0x06, 0xe5, 0x97, 0x70, 0xe0, 0x00,
    0xe5, 0x84, 0x4e, 0xe0, 0x22, 0xe5, 0x01, 0xe0,
    0xa2, 0x5f, 0x64, 0x00, 0xc4, 0x00, 0x24, 0x00,
    0xe5, 0x80, 0x9b, 0xe0, 0x25, 0x45, 0xe0, 0x09,
    0x65, 0xe0, 0x00, 0xe5, 0x81, 0x04, 0xe0, 0x88,
    0x7c, 0xe5, 0x63, 0x80, 0xe5, 0x05, 0x40, 0xe5,
    0x01, 0xc0, 0xe5, 0x02, 0x20, 0x0f, 0x26, 0x16,
    0x7b, 0xe0, 0x91, 0xd4, 0xe6, 0x26, 0x20, 0xe6,
    0x0f, 0xe0, 0x01, 0xef, 0x6c, 0xe0, 0x34, 0xef,
    0x80, 0x6e, 0xe0, 0x02, 0xef, 0x1f, 0x20, 0xef,
    0x34, 0x27, 0x46, 0x4f, 0xa7, 0xfb, 0x00, 0xe6,
    0x00, 0x2f, 0xc6, 0xef, 0x16, 0x66, 0xef, 0x35,
    0xe0, 0x0d, 0xef, 0x3a, 0x46, 0x0f, 0xe0, 0x80,
    0x12, 0xeb, 0x0c, 0xe0, 0x04, 0xef, 0x4f, 0xe0,
    0x01, 0xeb, 0x11, 0xe0, 0x7f, 0xe1, 0x12, 0xe2,
    0x12, 0xe1, 0x12, 0xc2, 0x00, 0xe2, 0x0a, 0xe1,
    0x12, 0xe2, 0x12, 0x01, 0x00, 0x21, 0x20, 0x01,
    0x20, 0x21, 0x20, 0x61, 0x00, 0xe1, 0x00, 0x62,
    0x00, 0x02, 0x00, 0xc2, 0x00, 0xe2, 0x03, 0xe1,
    0x12, 0xe2, 0x12, 0x21, 0x00, 0x61, 0x20, 0xe1,
    0x00, 0x00, 0xc1, 0x00, 0xe2, 0x12, 0x21, 0x00,
    0x61, 0x00, 0x81, 0x00, 0x01, 0x40, 0xc1, 0x00,
    0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12,
    0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12,
    0xe2, 0x12, 0xe1, 0x12, 0xe2, 0x12, 0xe1, 0x12,
    0xe2, 0x14, 0x20, 0xe1, 0x11, 0x0c, 0xe2, 0x11,
    0x0c, 0xa2, 0xe1, 0x11, 0x0c, 0xe2, 0x11, 0x0c,
    0xa2, 0xe1, 0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2,
    0xe1, 0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0xe1,
    0x11, 0x0c, 0xe2, 0x11, 0x0c, 0xa2, 0x3f, 0x20,
    0xe9, 0x2a, 0xef, 0x81, 0x78, 0xe6, 0x2f, 0x6f,
    0xe6, 0x2a, 0xef, 0x00, 0x06, 0xef, 0x06, 0x06,
    0x2f, 0x96, 0xe0, 0x07, 0x86, 0x00, 0xe6, 0x07,
    0xe0, 0x83, 0xc8, 0xe2, 0x02, 0x05, 0xe2, 0x0c,
    0xe0, 0x80, 0x59, 0xc6, 0x00, 0xe6, 0x09, 0x20,
    0xc6, 0x00, 0x26, 0x00, 0x86, 0xe0, 0x80, 0x4d,
    0xe5, 0x25, 0x40, 0xc6, 0xc4, 0x20, 0xe9, 0x02,
    0x60, 0x05, 0x0f, 0xe0, 0x80, 0xb8, 0xe5, 0x16,
    0x06, 0xe0, 0x09, 0xe5, 0x24, 0x66, 0xe9, 0x02,
    0x80, 0x0d, 0xe0, 0x84, 0x58, 0xc5, 0x00, 0x65,
    0x00, 0x25, 0x00, 0xe5, 0x07, 0x00, 0xe5, 0x80,
    0x3d, 0x20, 0xeb, 0x01, 0xc6, 0xe0, 0x21, 0xe1,
    0x1a, 0xe2, 0x1a, 0xc6, 0x04, 0x60, 0xe9, 0x02,
    0x60, 0x36, 0xe0, 0x82, 0x89, 0xeb, 0x33, 0x0f,
    0x4b, 0x0d, 0x6b, 0xe0, 0x44, 0xeb, 0x25, 0x0f,
    0xeb, 0x07, 0xe0, 0x80, 0x3a, 0x65, 0x00, 0xe5,
    0x13, 0x00, 0x25, 0x00, 0x05, 0x20, 0x05, 0x00,
    0xe5, 0x02, 0x00, 0x65, 0x00, 0x05, 0x00, 0x05,
    0xa0, 0x05, 0x60, 0x05, 0x00, 0x05, 0x00, 0x05,
    0x00, 0x45, 0x00, 0x25, 0x00, 0x05, 0x20, 0x05,
    0x00, 0x05, 0x00, 0x05, 0x00, 0x05, 0x00, 0x05,
    0x00, 0x25, 0x00, 0x05, 0x20, 0x65, 0x00, 0xc5,
    0x00, 0x65, 0x00, 0x65, 0x00, 0x05, 0x00, 0xe5,
    0x02, 0x00, 0xe5, 0x09, 0x80, 0x45, 0x00, 0x85,
    0x00, 0xe5, 0x09, 0xe0, 0x2c, 0x2c, 0xe0, 0x80,
    0x86, 0xef, 0x24, 0x60, 0xef, 0x5c, 0xe0, 0x04,
    0xef, 0x07, 0x20, 0xef, 0x07, 0x00, 0xef, 0x07,
    0x00, 0xef, 0x1d, 0xe0, 0x02, 0xeb, 0x05, 0xef,
    0x80, 0x19, 0xe0, 0x30, 0xef, 0x15, 0xe0, 0x05,
    0xef, 0x24, 0x60, 0xef, 0x01, 0xc0, 0x2f, 0xe0,
    0x06, 0xaf, 0xe0, 0x80, 0x12, 0xef, 0x80, 0x73,
    0x8e, 0xef, 0x82, 0x50, 0x80, 0xef, 0x08, 0x40,
    0xef, 0x05, 0x40, 0xef, 0x6c, 0xe0, 0x04, 0xef,
    0x51, 0xc0, 0xef, 0x04, 0x60, 0x0f, 0xe0, 0x07,
    0xef, 0x04, 0x60, 0xef, 0x30, 0xe0, 0x00, 0xef,
    0x02, 0xa0, 0xef, 0x20, 0xe0, 0x00, 0xef, 0x16,
    0x20, 0x2f, 0xe0, 0x46, 0xef, 0x80, 0xcc, 0xe0,
    0x04, 0xef, 0x06, 0x20, 0x8f, 0x40, 0x8f, 0x40,
    0xcf, 0xe0, 0x01, 0xef, 0x15, 0x40, 0xef, 0x03,
    0x80, 0xaf, 0xe0, 0x02, 0xef, 0x02, 0xa0, 0xef,
    0x00, 0xe0, 0x00, 0xcf, 0xe0, 0x01, 0xef, 0x80,
    0x0b, 0x00, 0xef, 0x2f, 0xe0, 0x1d, 0xe9, 0x02,
    0xe0, 0x83, 0x7e, 0xe5, 0xc0, 0x66, 0x58, 0xe0,
    0x18, 0xe5, 0x8f, 0xb1, 0xc0, 0xe5, 0x80, 0x56,
    0x20, 0xe5, 0x95, 0xfa, 0xe0, 0x06, 0xe5, 0x9c,
    0xa9, 0xe0, 0x8b, 0x97, 0xe5, 0x81, 0x96, 0xe0,
    0x85, 0x5a, 0xe5, 0x92, 0xc3, 0xe0, 0xca, 0xac,
    0x2e, 0x1b, 0xe0, 0x16, 0xfb, 0x58, 0xe0, 0x78,
    0xe6, 0x80, 0x68, 0xe0, 0xc0, 0xbd, 0x88, 0xfd,
    0xc0, 0xbf, 0x76, 0x20, 0xfd, 0xc0, 0xbf, 0x76,
    0x20,
};

typedef enum {
    UNICODE_SCRIPT_Unknown,
    UNICODE_SCRIPT_Adlam,
    UNICODE_SCRIPT_Ahom,
    UNICODE_SCRIPT_Anatolian_Hieroglyphs,
    UNICODE_SCRIPT_Arabic,
    UNICODE_SCRIPT_Armenian,
    UNICODE_SCRIPT_Avestan,
    UNICODE_SCRIPT_Balinese,
    UNICODE_SCRIPT_Bamum,
    UNICODE_SCRIPT_Bassa_Vah,
    UNICODE_SCRIPT_Batak,
    UNICODE_SCRIPT_Bengali,
    UNICODE_SCRIPT_Bhaiksuki,
    UNICODE_SCRIPT_Bopomofo,
    UNICODE_SCRIPT_Brahmi,
    UNICODE_SCRIPT_Braille,
    UNICODE_SCRIPT_Buginese,
    UNICODE_SCRIPT_Buhid,
    UNICODE_SCRIPT_Canadian_Aboriginal,
    UNICODE_SCRIPT_Carian,
    UNICODE_SCRIPT_Caucasian_Albanian,
    UNICODE_SCRIPT_Chakma,
    UNICODE_SCRIPT_Cham,
    UNICODE_SCRIPT_Cherokee,
    UNICODE_SCRIPT_Chorasmian,
    UNICODE_SCRIPT_Common,
    UNICODE_SCRIPT_Coptic,
    UNICODE_SCRIPT_Cuneiform,
    UNICODE_SCRIPT_Cypriot,
    UNICODE_SCRIPT_Cyrillic,
    UNICODE_SCRIPT_Cypro_Minoan,
    UNICODE_SCRIPT_Deseret,
    UNICODE_SCRIPT_Devanagari,
    UNICODE_SCRIPT_Dives_Akuru,
    UNICODE_SCRIPT_Dogra,
    UNICODE_SCRIPT_Duployan,
    UNICODE_SCRIPT_Egyptian_Hieroglyphs,
    UNICODE_SCRIPT_Elbasan,
    UNICODE_SCRIPT_Elymaic,
    UNICODE_SCRIPT_Ethiopic,
    UNICODE_SCRIPT_Georgian,
    UNICODE_SCRIPT_Glagolitic,
    UNICODE_SCRIPT_Gothic,
    UNICODE_SCRIPT_Grantha,
    UNICODE_SCRIPT_Greek,
    UNICODE_SCRIPT_Gujarati,
    UNICODE_SCRIPT_Gunjala_Gondi,
    UNICODE_SCRIPT_Gurmukhi,
    UNICODE_SCRIPT_Han,
    UNICODE_SCRIPT_Hangul,
    UNICODE_SCRIPT_Hanifi_Rohingya,
    UNICODE_SCRIPT_Hanunoo,
    UNICODE_SCRIPT_Hatran,
    UNICODE_SCRIPT_Hebrew,
    UNICODE_SCRIPT_Hiragana,
    UNICODE_SCRIPT_Imperial_Aramaic,
    UNICODE_SCRIPT_Inherited,
    UNICODE_SCRIPT_Inscriptional_Pahlavi,
    UNICODE_SCRIPT_Inscriptional_Parthian,
    UNICODE_SCRIPT_Javanese,
    UNICODE_SCRIPT_Kaithi,
    UNICODE_SCRIPT_Kannada,
    UNICODE_SCRIPT_Katakana,
    UNICODE_SCRIPT_Kayah_Li,
    UNICODE_SCRIPT_Kharoshthi,
    UNICODE_SCRIPT_Khmer,
    UNICODE_SCRIPT_Khojki,
    UNICODE_SCRIPT_Khitan_Small_Script,
    UNICODE_SCRIPT_Khudawadi,
    UNICODE_SCRIPT_Lao,
    UNICODE_SCRIPT_Latin,
    UNICODE_SCRIPT_Lepcha,
    UNICODE_SCRIPT_Limbu,
    UNICODE_SCRIPT_Linear_A,
    UNICODE_SCRIPT_Linear_B,
    UNICODE_SCRIPT_Lisu,
    UNICODE_SCRIPT_Lycian,
    UNICODE_SCRIPT_Lydian,
    UNICODE_SCRIPT_Makasar,
    UNICODE_SCRIPT_Mahajani,
    UNICODE_SCRIPT_Malayalam,
    UNICODE_SCRIPT_Mandaic,
    UNICODE_SCRIPT_Manichaean,
    UNICODE_SCRIPT_Marchen,
    UNICODE_SCRIPT_Masaram_Gondi,
    UNICODE_SCRIPT_Medefaidrin,
    UNICODE_SCRIPT_Meetei_Mayek,
    UNICODE_SCRIPT_Mende_Kikakui,
    UNICODE_SCRIPT_Meroitic_Cursive,
    UNICODE_SCRIPT_Meroitic_Hieroglyphs,
    UNICODE_SCRIPT_Miao,
    UNICODE_SCRIPT_Modi,
    UNICODE_SCRIPT_Mongolian,
    UNICODE_SCRIPT_Mro,
    UNICODE_SCRIPT_Multani,
    UNICODE_SCRIPT_Myanmar,
    UNICODE_SCRIPT_Nabataean,
    UNICODE_SCRIPT_Nandinagari,
    UNICODE_SCRIPT_New_Tai_Lue,
    UNICODE_SCRIPT_Newa,
    UNICODE_SCRIPT_Nko,
    UNICODE_SCRIPT_Nushu,
    UNICODE_SCRIPT_Nyiakeng_Puachue_Hmong,
    UNICODE_SCRIPT_Ogham,
    UNICODE_SCRIPT_Ol_Chiki,
    UNICODE_SCRIPT_Old_Hungarian,
    UNICODE_SCRIPT_Old_Italic,
    UNICODE_SCRIPT_Old_North_Arabian,
    UNICODE_SCRIPT_Old_Permic,
    UNICODE_SCRIPT_Old_Persian,
    UNICODE_SCRIPT_Old_Sogdian,
    UNICODE_SCRIPT_Old_South_Arabian,
    UNICODE_SCRIPT_Old_Turkic,
    UNICODE_SCRIPT_Old_Uyghur,
    UNICODE_SCRIPT_Oriya,
    UNICODE_SCRIPT_Osage,
    UNICODE_SCRIPT_Osmanya,
    UNICODE_SCRIPT_Pahawh_Hmong,
    UNICODE_SCRIPT_Palmyrene,
    UNICODE_SCRIPT_Pau_Cin_Hau,
    UNICODE_SCRIPT_Phags_Pa,
    UNICODE_SCRIPT_Phoenician,
    UNICODE_SCRIPT_Psalter_Pahlavi,
    UNICODE_SCRIPT_Rejang,
    UNICODE_SCRIPT_Runic,
    UNICODE_SCRIPT_Samaritan,
    UNICODE_SCRIPT_Saurashtra,
    UNICODE_SCRIPT_Sharada,
    UNICODE_SCRIPT_Shavian,
    UNICODE_SCRIPT_Siddham,
    UNICODE_SCRIPT_SignWriting,
    UNICODE_SCRIPT_Sinhala,
    UNICODE_SCRIPT_Sogdian,
    UNICODE_SCRIPT_Sora_Sompeng,
    UNICODE_SCRIPT_Soyombo,
    UNICODE_SCRIPT_Sundanese,
    UNICODE_SCRIPT_Syloti_Nagri,
    UNICODE_SCRIPT_Syriac,
    UNICODE_SCRIPT_Tagalog,
    UNICODE_SCRIPT_Tagbanwa,
    UNICODE_SCRIPT_Tai_Le,
    UNICODE_SCRIPT_Tai_Tham,
    UNICODE_SCRIPT_Tai_Viet,
    UNICODE_SCRIPT_Takri,
    UNICODE_SCRIPT_Tamil,
    UNICODE_SCRIPT_Tangut,
    UNICODE_SCRIPT_Telugu,
    UNICODE_SCRIPT_Thaana,
    UNICODE_SCRIPT_Thai,
    UNICODE_SCRIPT_Tibetan,
    UNICODE_SCRIPT_Tifinagh,
    UNICODE_SCRIPT_Tirhuta,
    UNICODE_SCRIPT_Tangsa,
    UNICODE_SCRIPT_Toto,
    UNICODE_SCRIPT_Ugaritic,
    UNICODE_SCRIPT_Vai,
    UNICODE_SCRIPT_Vithkuqi,
    UNICODE_SCRIPT_Wancho,
    UNICODE_SCRIPT_Warang_Citi,
    UNICODE_SCRIPT_Yezidi,
    UNICODE_SCRIPT_Yi,
    UNICODE_SCRIPT_Zanabazar_Square,
    UNICODE_SCRIPT_COUNT,
} UnicodeScriptEnum;

static const char unicode_script_name_table[] =
    "Adlam,Adlm"                  "\0"
    "Ahom,Ahom"                   "\0"
    "Anatolian_Hieroglyphs,Hluw"  "\0"
    "Arabic,Arab"                 "\0"
    "Armenian,Armn"               "\0"
    "Avestan,Avst"                "\0"
    "Balinese,Bali"               "\0"
    "Bamum,Bamu"                  "\0"
    "Bassa_Vah,Bass"              "\0"
    "Batak,Batk"                  "\0"
    "Bengali,Beng"                "\0"
    "Bhaiksuki,Bhks"              "\0"
    "Bopomofo,Bopo"               "\0"
    "Brahmi,Brah"                 "\0"
    "Braille,Brai"                "\0"
    "Buginese,Bugi"               "\0"
    "Buhid,Buhd"                  "\0"
    "Canadian_Aboriginal,Cans"    "\0"
    "Carian,Cari"                 "\0"
    "Caucasian_Albanian,Aghb"     "\0"
    "Chakma,Cakm"                 "\0"
    "Cham,Cham"                   "\0"
    "Cherokee,Cher"               "\0"
    "Chorasmian,Chrs"             "\0"
    "Common,Zyyy"                 "\0"
    "Coptic,Copt,Qaac"            "\0"
    "Cuneiform,Xsux"              "\0"
    "Cypriot,Cprt"                "\0"
    "Cyrillic,Cyrl"               "\0"
    "Cypro_Minoan,Cpmn"           "\0"
    "Deseret,Dsrt"                "\0"
    "Devanagari,Deva"             "\0"
    "Dives_Akuru,Diak"            "\0"
    "Dogra,Dogr"                  "\0"
    "Duployan,Dupl"               "\0"
    "Egyptian_Hieroglyphs,Egyp"   "\0"
    "Elbasan,Elba"                "\0"
    "Elymaic,Elym"                "\0"
    "Ethiopic,Ethi"               "\0"
    "Georgian,Geor"               "\0"
    "Glagolitic,Glag"             "\0"
    "Gothic,Goth"                 "\0"
    "Grantha,Gran"                "\0"
    "Greek,Grek"                  "\0"
    "Gujarati,Gujr"               "\0"
    "Gunjala_Gondi,Gong"          "\0"
    "Gurmukhi,Guru"               "\0"
    "Han,Hani"                    "\0"
    "Hangul,Hang"                 "\0"
    "Hanifi_Rohingya,Rohg"        "\0"
    "Hanunoo,Hano"                "\0"
    "Hatran,Hatr"                 "\0"
    "Hebrew,Hebr"                 "\0"
    "Hiragana,Hira"               "\0"
    "Imperial_Aramaic,Armi"       "\0"
    "Inherited,Zinh,Qaai"         "\0"
    "Inscriptional_Pahlavi,Phli"  "\0"
    "Inscriptional_Parthian,Prti" "\0"
    "Javanese,Java"               "\0"
    "Kaithi,Kthi"                 "\0"
    "Kannada,Knda"                "\0"
    "Katakana,Kana"               "\0"
    "Kayah_Li,Kali"               "\0"
    "Kharoshthi,Khar"             "\0"
    "Khmer,Khmr"                  "\0"
    "Khojki,Khoj"                 "\0"
    "Khitan_Small_Script,Kits"    "\0"
    "Khudawadi,Sind"              "\0"
    "Lao,Laoo"                    "\0"
    "Latin,Latn"                  "\0"
    "Lepcha,Lepc"                 "\0"
    "Limbu,Limb"                  "\0"
    "Linear_A,Lina"               "\0"
    "Linear_B,Linb"               "\0"
    "Lisu,Lisu"                   "\0"
    "Lycian,Lyci"                 "\0"
    "Lydian,Lydi"                 "\0"
    "Makasar,Maka"                "\0"
    "Mahajani,Mahj"               "\0"
    "Malayalam,Mlym"              "\0"
    "Mandaic,Mand"                "\0"
    "Manichaean,Mani"             "\0"
    "Marchen,Marc"                "\0"
    "Masaram_Gondi,Gonm"          "\0"
    "Medefaidrin,Medf"            "\0"
    "Meetei_Mayek,Mtei"           "\0"
    "Mende_Kikakui,Mend"          "\0"
    "Meroitic_Cursive,Merc"       "\0"
    "Meroitic_Hieroglyphs,Mero"   "\0"
    "Miao,Plrd"                   "\0"
    "Modi,Modi"                   "\0"
    "Mongolian,Mong"              "\0"
    "Mro,Mroo"                    "\0"
    "Multani,Mult"                "\0"
    "Myanmar,Mymr"                "\0"
    "Nabataean,Nbat"              "\0"
    "Nandinagari,Nand"            "\0"
    "New_Tai_Lue,Talu"            "\0"
    "Newa,Newa"                   "\0"
    "Nko,Nkoo"                    "\0"
    "Nushu,Nshu"                  "\0"
    "Nyiakeng_Puachue_Hmong,Hmnp" "\0"
    "Ogham,Ogam"                  "\0"
    "Ol_Chiki,Olck"               "\0"
    "Old_Hungarian,Hung"          "\0"
    "Old_Italic,Ital"             "\0"
    "Old_North_Arabian,Narb"      "\0"
    "Old_Permic,Perm"             "\0"
    "Old_Persian,Xpeo"            "\0"
    "Old_Sogdian,Sogo"            "\0"
    "Old_South_Arabian,Sarb"      "\0"
    "Old_Turkic,Orkh"             "\0"
    "Old_Uyghur,Ougr"             "\0"
    "Oriya,Orya"                  "\0"
    "Osage,Osge"                  "\0"
    "Osmanya,Osma"                "\0"
    "Pahawh_Hmong,Hmng"           "\0"
    "Palmyrene,Palm"              "\0"
    "Pau_Cin_Hau,Pauc"            "\0"
    "Phags_Pa,Phag"               "\0"
    "Phoenician,Phnx"             "\0"
    "Psalter_Pahlavi,Phlp"        "\0"
    "Rejang,Rjng"                 "\0"
    "Runic,Runr"                  "\0"
    "Samaritan,Samr"              "\0"
    "Saurashtra,Saur"             "\0"
    "Sharada,Shrd"                "\0"
    "Shavian,Shaw"                "\0"
    "Siddham,Sidd"                "\0"
    "SignWriting,Sgnw"            "\0"
    "Sinhala,Sinh"                "\0"
    "Sogdian,Sogd"                "\0"
    "Sora_Sompeng,Sora"           "\0"
    "Soyombo,Soyo"                "\0"
    "Sundanese,Sund"              "\0"
    "Syloti_Nagri,Sylo"           "\0"
    "Syriac,Syrc"                 "\0"
    "Tagalog,Tglg"                "\0"
    "Tagbanwa,Tagb"               "\0"
    "Tai_Le,Tale"                 "\0"
    "Tai_Tham,Lana"               "\0"
    "Tai_Viet,Tavt"               "\0"
    "Takri,Takr"                  "\0"
    "Tamil,Taml"                  "\0"
    "Tangut,Tang"                 "\0"
    "Telugu,Telu"                 "\0"
    "Thaana,Thaa"                 "\0"
    "Thai,Thai"                   "\0"
    "Tibetan,Tibt"                "\0"
    "Tifinagh,Tfng"               "\0"
    "Tirhuta,Tirh"                "\0"
    "Tangsa,Tnsa"                 "\0"
    "Toto,Toto"                   "\0"
    "Ugaritic,Ugar"               "\0"
    "Vai,Vaii"                    "\0"
    "Vithkuqi,Vith"               "\0"
    "Wancho,Wcho"                 "\0"
    "Warang_Citi,Wara"            "\0"
    "Yezidi,Yezi"                 "\0"
    "Yi,Yiii"                     "\0"
    "Zanabazar_Square,Zanb"       "\0"
;

static const uint8_t unicode_script_table[2690] = {
    0xc0, 0x19, 0x99, 0x46, 0x85, 0x19, 0x99, 0x46,
    0xae, 0x19, 0x80, 0x46, 0x8e, 0x19, 0x80, 0x46,
    0x84, 0x19, 0x96, 0x46, 0x80, 0x19, 0x9e, 0x46,
    0x80, 0x19, 0xe1, 0x60, 0x46, 0xa6, 0x19, 0x84,
    0x46, 0x84, 0x19, 0x81, 0x0d, 0x93, 0x19, 0xe0,
    0x0f, 0x38, 0x83, 0x2c, 0x80, 0x19, 0x82, 0x2c,
    0x01, 0x83, 0x2c, 0x80, 0x19, 0x80, 0x2c, 0x03,
    0x80, 0x2c, 0x80, 0x19, 0x80, 0x2c, 0x80, 0x19,
    0x82, 0x2c, 0x00, 0x80, 0x2c, 0x00, 0x93, 0x2c,
    0x00, 0xbe, 0x2c, 0x8d, 0x1a, 0x8f, 0x2c, 0xe0,
    0x24, 0x1d, 0x81, 0x38, 0xe0, 0x48, 0x1d, 0x00,
    0xa5, 0x05, 0x01, 0xb1, 0x05, 0x01, 0x82, 0x05,
    0x00, 0xb6, 0x35, 0x07, 0x9a, 0x35, 0x03, 0x85,
    0x35, 0x0a, 0x84, 0x04, 0x80, 0x19, 0x85, 0x04,
    0x80, 0x19, 0x8d, 0x04, 0x80, 0x19, 0x82, 0x04,
    0x80, 0x19, 0x9f, 0x04, 0x80, 0x19, 0x89, 0x04,
    0x8a, 0x38, 0x99, 0x04, 0x80, 0x38, 0xe0, 0x0b,
    0x04, 0x80, 0x19, 0xa1, 0x04, 0x8d, 0x89, 0x00,
    0xbb, 0x89, 0x01, 0x82, 0x89, 0xaf, 0x04, 0xb1,
    0x93, 0x0d, 0xba, 0x64, 0x01, 0x82, 0x64, 0xad,
    0x7d, 0x01, 0x8e, 0x7d, 0x00, 0x9b, 0x51, 0x01,
    0x80, 0x51, 0x00, 0x8a, 0x89, 0x04, 0x9e, 0x04,
    0x00, 0x81, 0x04, 0x05, 0xc9, 0x04, 0x80, 0x19,
    0x9c, 0x04, 0xd0, 0x20, 0x83, 0x38, 0x8e, 0x20,
    0x81, 0x19, 0x99, 0x20, 0x83, 0x0b, 0x00, 0x87,
    0x0b, 0x01, 0x81, 0x0b, 0x01, 0x95, 0x0b, 0x00,
    0x86, 0x0b, 0x00, 0x80, 0x0b, 0x02, 0x83, 0x0b,
    0x01, 0x88, 0x0b, 0x01, 0x81, 0x0b, 0x01, 0x83,
    0x0b, 0x07, 0x80, 0x0b, 0x03, 0x81, 0x0b, 0x00,
    0x84, 0x0b, 0x01, 0x98, 0x0b, 0x01, 0x82, 0x2f,
    0x00, 0x85, 0x2f, 0x03, 0x81, 0x2f, 0x01, 0x95,
    0x2f, 0x00, 0x86, 0x2f, 0x00, 0x81, 0x2f, 0x00,
    0x81, 0x2f, 0x00, 0x81, 0x2f, 0x01, 0x80, 0x2f,
    0x00, 0x84, 0x2f, 0x03, 0x81, 0x2f, 0x01, 0x82,
    0x2f, 0x02, 0x80, 0x2f, 0x06, 0x83, 0x2f, 0x00,
    0x80, 0x2f, 0x06, 0x90, 0x2f, 0x09, 0x82, 0x2d,
    0x00, 0x88, 0x2d, 0x00, 0x82, 0x2d, 0x00, 0x95,
    0x2d, 0x00, 0x86, 0x2d, 0x00, 0x81, 0x2d, 0x00,
    0x84, 0x2d, 0x01, 0x89, 0x2d, 0x00, 0x82, 0x2d,
    0x00, 0x82, 0x2d, 0x01, 0x80, 0x2d, 0x0e, 0x83,
    0x2d, 0x01, 0x8b, 0x2d, 0x06, 0x86, 0x2d, 0x00,
    0x82, 0x72, 0x00, 0x87, 0x72, 0x01, 0x81, 0x72,
    0x01, 0x95, 0x72, 0x00, 0x86, 0x72, 0x00, 0x81,
    0x72, 0x00, 0x84, 0x72, 0x01, 0x88, 0x72, 0x01,
    0x81, 0x72, 0x01, 0x82, 0x72, 0x06, 0x82, 0x72,
    0x03, 0x81, 0x72, 0x00, 0x84, 0x72, 0x01, 0x91,
    0x72, 0x09, 0x81, 0x90, 0x00, 0x85, 0x90, 0x02,
    0x82, 0x90, 0x00, 0x83, 0x90, 0x02, 0x81, 0x90,
    0x00, 0x80, 0x90, 0x00, 0x81, 0x90, 0x02, 0x81,
    0x90, 0x02, 0x82, 0x90, 0x02, 0x8b, 0x90, 0x03,
    0x84, 0x90, 0x02, 0x82, 0x90, 0x00, 0x83, 0x90,
    0x01, 0x80, 0x90, 0x05, 0x80, 0x90, 0x0d, 0x94,
    0x90, 0x04, 0x8c, 0x92, 0x00, 0x82, 0x92, 0x00,
    0x96, 0x92, 0x00, 0x8f, 0x92, 0x01, 0x88, 0x92,
    0x00, 0x82, 0x92, 0x00, 0x83, 0x92, 0x06, 0x81,
    0x92, 0x00, 0x82, 0x92, 0x01, 0x80, 0x92, 0x01,
    0x83, 0x92, 0x01, 0x89, 0x92, 0x06, 0x88, 0x92,
    0x8c, 0x3d, 0x00, 0x82, 0x3d, 0x00, 0x96, 0x3d,
    0x00, 0x89, 0x3d, 0x00, 0x84, 0x3d, 0x01, 0x88,
    0x3d, 0x00, 0x82, 0x3d, 0x00, 0x83, 0x3d, 0x06,
    0x81, 0x3d, 0x05, 0x81, 0x3d, 0x00, 0x83, 0x3d,
    0x01, 0x89, 0x3d, 0x00, 0x81, 0x3d, 0x0c, 0x8c,
    0x50, 0x00, 0x82, 0x50, 0x00, 0xb2, 0x50, 0x00,
    0x82, 0x50, 0x00, 0x85, 0x50, 0x03, 0x8f, 0x50,
    0x01, 0x99, 0x50, 0x00, 0x82, 0x83, 0x00, 0x91,
    0x83, 0x02, 0x97, 0x83, 0x00, 0x88, 0x83, 0x00,
    0x80, 0x83, 0x01, 0x86, 0x83, 0x02, 0x80, 0x83,
    0x03, 0x85, 0x83, 0x00, 0x80, 0x83, 0x00, 0x87,
    0x83, 0x05, 0x89, 0x83, 0x01, 0x82, 0x83, 0x0b,
    0xb9, 0x94, 0x03, 0x80, 0x19, 0x9b, 0x94, 0x24,
    0x81, 0x45, 0x00, 0x80, 0x45, 0x00, 0x84, 0x45,
    0x00, 0x97, 0x45, 0x00, 0x80, 0x45, 0x00, 0x96,
    0x45, 0x01, 0x84, 0x45, 0x00, 0x80, 0x45, 0x00,
    0x85, 0x45, 0x01, 0x89, 0x45, 0x01, 0x83, 0x45,
    0x1f, 0xc7, 0x95, 0x00, 0xa3, 0x95, 0x03, 0xa6,
    0x95, 0x00, 0xa3, 0x95, 0x00, 0x8e, 0x95, 0x00,
    0x86, 0x95, 0x83, 0x19, 0x81, 0x95, 0x24, 0xe0,
    0x3f, 0x5f, 0xa5, 0x28, 0x00, 0x80, 0x28, 0x04,
    0x80, 0x28, 0x01, 0xaa, 0x28, 0x80, 0x19, 0x83,
    0x28, 0xe0, 0x9f, 0x31, 0xc8, 0x27, 0x00, 0x83,
    0x27, 0x01, 0x86, 0x27, 0x00, 0x80, 0x27, 0x00,
    0x83, 0x27, 0x01, 0xa8, 0x27, 0x00, 0x83, 0x27,
    0x01, 0xa0, 0x27, 0x00, 0x83, 0x27, 0x01, 0x86,
    0x27, 0x00, 0x80, 0x27, 0x00, 0x83, 0x27, 0x01,
    0x8e, 0x27, 0x00, 0xb8, 0x27, 0x00, 0x83, 0x27,
    0x01, 0xc2, 0x27, 0x01, 0x9f, 0x27, 0x02, 0x99,
    0x27, 0x05, 0xd5, 0x17, 0x01, 0x85, 0x17, 0x01,
    0xe2, 0x1f, 0x12, 0x9c, 0x67, 0x02, 0xca, 0x7c,
    0x82, 0x19, 0x8a, 0x7c, 0x06, 0x95, 0x8a, 0x08,
    0x80, 0x8a, 0x94, 0x33, 0x81, 0x19, 0x08, 0x93,
    0x11, 0x0b, 0x8c, 0x8b, 0x00, 0x82, 0x8b, 0x00,
    0x81, 0x8b, 0x0b, 0xdd, 0x41, 0x01, 0x89, 0x41,
    0x05, 0x89, 0x41, 0x05, 0x81, 0x5c, 0x81, 0x19,
    0x80, 0x5c, 0x80, 0x19, 0x93, 0x5c, 0x05, 0xd8,
    0x5c, 0x06, 0xaa, 0x5c, 0x04, 0xc5, 0x12, 0x09,
    0x9e, 0x48, 0x00, 0x8b, 0x48, 0x03, 0x8b, 0x48,
    0x03, 0x80, 0x48, 0x02, 0x8b, 0x48, 0x9d, 0x8c,
    0x01, 0x84, 0x8c, 0x0a, 0xab, 0x62, 0x03, 0x99,
    0x62, 0x05, 0x8a, 0x62, 0x02, 0x81, 0x62, 0x9f,
    0x41, 0x9b, 0x10, 0x01, 0x81, 0x10, 0xbe, 0x8d,
    0x00, 0x9c, 0x8d, 0x01, 0x8a, 0x8d, 0x05, 0x89,
    0x8d, 0x05, 0x8d, 0x8d, 0x01, 0x9e, 0x38, 0x30,
    0xcc, 0x07, 0x02, 0xae, 0x07, 0x00, 0xbf, 0x87,
    0xb3, 0x0a, 0x07, 0x83, 0x0a, 0xb7, 0x47, 0x02,
    0x8e, 0x47, 0x02, 0x82, 0x47, 0xaf, 0x68, 0x88,
    0x1d, 0x06, 0xaa, 0x28, 0x01, 0x82, 0x28, 0x87,
    0x87, 0x07, 0x82, 0x38, 0x80, 0x19, 0x8c, 0x38,
    0x80, 0x19, 0x86, 0x38, 0x83, 0x19, 0x80, 0x38,
    0x85, 0x19, 0x80, 0x38, 0x82, 0x19, 0x81, 0x38,
    0x80, 0x19, 0x04, 0xa5, 0x46, 0x84, 0x2c, 0x80,
    0x1d, 0xb0, 0x46, 0x84, 0x2c, 0x83, 0x46, 0x84,
    0x2c, 0x8c, 0x46, 0x80, 0x1d, 0xc5, 0x46, 0x80,
    0x2c, 0xbf, 0x38, 0xe0, 0x9f, 0x46, 0x95, 0x2c,
    0x01, 0x85, 0x2c, 0x01, 0xa5, 0x2c, 0x01, 0x85,
    0x2c, 0x01, 0x87, 0x2c, 0x00, 0x80, 0x2c, 0x00,
    0x80, 0x2c, 0x00, 0x80, 0x2c, 0x00, 0x9e, 0x2c,
    0x01, 0xb4, 0x2c, 0x00, 0x8e, 0x2c, 0x00, 0x8d,
    0x2c, 0x01, 0x85, 0x2c, 0x00, 0x92, 0x2c, 0x01,
    0x82, 0x2c, 0x00, 0x88, 0x2c, 0x00, 0x8b, 0x19,
    0x81, 0x38, 0xd6, 0x19, 0x00, 0x8a, 0x19, 0x80,
    0x46, 0x01, 0x8a, 0x19, 0x80, 0x46, 0x8e, 0x19,
    0x00, 0x8c, 0x46, 0x02, 0xa0, 0x19, 0x0e, 0xa0,
    0x38, 0x0e, 0xa5, 0x19, 0x80, 0x2c, 0x82, 0x19,
    0x81, 0x46, 0x85, 0x19, 0x80, 0x46, 0x9a, 0x19,
    0x80, 0x46, 0x90, 0x19, 0xa8, 0x46, 0x82, 0x19,
    0x03, 0xe2, 0x36, 0x19, 0x18, 0x8a, 0x19, 0x14,
    0xe3, 0x3f, 0x19, 0xe0, 0x9f, 0x0f, 0xe2, 0x13,
    0x19, 0x01, 0x9f, 0x19, 0x00, 0xe0, 0x08, 0x19,
    0xdf, 0x29, 0x9f, 0x46, 0xe0, 0x13, 0x1a, 0x04,
    0x86, 0x1a, 0xa5, 0x28, 0x00, 0x80, 0x28, 0x04,
    0x80, 0x28, 0x01, 0xb7, 0x96, 0x06, 0x81, 0x96,
    0x0d, 0x80, 0x96, 0x96, 0x27, 0x08, 0x86, 0x27,
    0x00, 0x86, 0x27, 0x00, 0x86, 0x27, 0x00, 0x86,
    0x27, 0x00, 0x86, 0x27, 0x00, 0x86, 0x27, 0x00,
    0x86, 0x27, 0x00, 0x86, 0x27, 0x00, 0x9f, 0x1d,
    0xdd, 0x19, 0x21, 0x99, 0x30, 0x00, 0xd8, 0x30,
    0x0b, 0xe0, 0x75, 0x30, 0x19, 0x8b, 0x19, 0x03,
    0x84, 0x19, 0x80, 0x30, 0x80, 0x19, 0x80, 0x30,
    0x98, 0x19, 0x88, 0x30, 0x83, 0x38, 0x81, 0x31,
    0x87, 0x19, 0x83, 0x30, 0x83, 0x19, 0x00, 0xd5,
    0x36, 0x01, 0x81, 0x38, 0x81, 0x19, 0x82, 0x36,
    0x80, 0x19, 0xd9, 0x3e, 0x81, 0x19, 0x82, 0x3e,
    0x04, 0xaa, 0x0d, 0x00, 0xdd, 0x31, 0x00, 0x8f,
    0x19, 0x9f, 0x0d, 0xa3, 0x19, 0x0b, 0x8f, 0x3e,
    0x9e, 0x31, 0x00, 0xbf, 0x19, 0x9e, 0x31, 0xd0,
    0x19, 0xae, 0x3e, 0x80, 0x19, 0xd7, 0x3e, 0xe0,
    0x47, 0x19, 0xf0, 0x09, 0x5f, 0x30, 0xbf, 0x19,
    0xf0, 0x41, 0x9f, 0x30, 0xe4, 0x2c, 0xa0, 0x02,
    0xb6, 0xa0, 0x08, 0xaf, 0x4b, 0xe0, 0xcb, 0x9b,
    0x13, 0xdf, 0x1d, 0xd7, 0x08, 0x07, 0xa1, 0x19,
    0xe0, 0x05, 0x46, 0x82, 0x19, 0xbf, 0x46, 0x04,
    0x81, 0x46, 0x00, 0x80, 0x46, 0x00, 0x84, 0x46,
    0x17, 0x8d, 0x46, 0xac, 0x88, 0x02, 0x89, 0x19,
    0x05, 0xb7, 0x78, 0x07, 0xc5, 0x7e, 0x07, 0x8b,
    0x7e, 0x05, 0x9f, 0x20, 0xad, 0x3f, 0x80, 0x19,
    0x80, 0x3f, 0xa3, 0x7b, 0x0a, 0x80, 0x7b, 0x9c,
    0x31, 0x02, 0xcd, 0x3b, 0x00, 0x80, 0x19, 0x89,
    0x3b, 0x03, 0x81, 0x3b, 0x9e, 0x5f, 0x00, 0xb6,
    0x16, 0x08, 0x8d, 0x16, 0x01, 0x89, 0x16, 0x01,
    0x83, 0x16, 0x9f, 0x5f, 0xc2, 0x8e, 0x17, 0x84,
    0x8e, 0x96, 0x56, 0x09, 0x85, 0x27, 0x01, 0x85,
    0x27, 0x01, 0x85, 0x27, 0x08, 0x86, 0x27, 0x00,
    0x86, 0x27, 0x00, 0xaa, 0x46, 0x80, 0x19, 0x88,
    0x46, 0x80, 0x2c, 0x83, 0x46, 0x81, 0x19, 0x03,
    0xcf, 0x17, 0xad, 0x56, 0x01, 0x89, 0x56, 0x05,
    0xf0, 0x1b, 0x43, 0x31, 0x0b, 0x96, 0x31, 0x03,
    0xb0, 0x31, 0x70, 0x10, 0xa3, 0xe1, 0x0d, 0x30,
    0x01, 0xe0, 0x09, 0x30, 0x25, 0x86, 0x46, 0x0b,
    0x84, 0x05, 0x04, 0x99, 0x35, 0x00, 0x84, 0x35,
    0x00, 0x80, 0x35, 0x00, 0x81, 0x35, 0x00, 0x81,
    0x35, 0x00, 0x89, 0x35, 0xe0, 0x12, 0x04, 0x0f,
    0xe1, 0x0a, 0x04, 0x81, 0x19, 0xcf, 0x04, 0x01,
    0xb5, 0x04, 0x06, 0x80, 0x04, 0x1f, 0x8f, 0x04,
    0x8f, 0x38, 0x89, 0x19, 0x05, 0x8d, 0x38, 0x81,
    0x1d, 0xa2, 0x19, 0x00, 0x92, 0x19, 0x00, 0x83,
    0x19, 0x03, 0x84, 0x04, 0x00, 0xe0, 0x26, 0x04,
    0x01, 0x80, 0x19, 0x00, 0x9f, 0x19, 0x99, 0x46,
    0x85, 0x19, 0x99, 0x46, 0x8a, 0x19, 0x89, 0x3e,
    0x80, 0x19, 0xac, 0x3e, 0x81, 0x19, 0x9e, 0x31,
    0x02, 0x85, 0x31, 0x01, 0x85, 0x31, 0x01, 0x85,
    0x31, 0x01, 0x82, 0x31, 0x02, 0x86, 0x19, 0x00,
    0x86, 0x19, 0x09, 0x84, 0x19, 0x01, 0x8b, 0x4a,
    0x00, 0x99, 0x4a, 0x00, 0x92, 0x4a, 0x00, 0x81,
    0x4a, 0x00, 0x8e, 0x4a, 0x01, 0x8d, 0x4a, 0x21,
    0xe0, 0x1a, 0x4a, 0x04, 0x82, 0x19, 0x03, 0xac,
    0x19, 0x02, 0x88, 0x19, 0xce, 0x2c, 0x00, 0x8c,
    0x19, 0x02, 0x80, 0x2c, 0x2e, 0xac, 0x19, 0x80,
    0x38, 0x60, 0x21, 0x9c, 0x4c, 0x02, 0xb0, 0x13,
    0x0e, 0x80, 0x38, 0x9a, 0x19, 0x03, 0xa3, 0x6a,
    0x08, 0x82, 0x6a, 0x9a, 0x2a, 0x04, 0xaa, 0x6c,
    0x04, 0x9d, 0x9a, 0x00, 0x80, 0x9a, 0xa3, 0x6d,
    0x03, 0x8d, 0x6d, 0x29, 0xcf, 0x1f, 0xaf, 0x80,
    0x9d, 0x74, 0x01, 0x89, 0x74, 0x05, 0xa3, 0x73,
    0x03, 0xa3, 0x73, 0x03, 0xa7, 0x25, 0x07, 0xb3,
    0x14, 0x0a, 0x80, 0x14, 0x8a, 0x9c, 0x00, 0x8e,
    0x9c, 0x00, 0x86, 0x9c, 0x00, 0x81, 0x9c, 0x00,
    0x8a, 0x9c, 0x00, 0x8e, 0x9c, 0x00, 0x86, 0x9c,
    0x00, 0x81, 0x9c, 0x42, 0xe0, 0xd6, 0x49, 0x08,
    0x95, 0x49, 0x09, 0x87, 0x49, 0x17, 0x85, 0x46,
    0x00, 0xa9, 0x46, 0x00, 0x88, 0x46, 0x44, 0x85,
    0x1c, 0x01, 0x80, 0x1c, 0x00, 0xab, 0x1c, 0x00,
    0x81, 0x1c, 0x02, 0x80, 0x1c, 0x01, 0x80, 0x1c,
    0x95, 0x37, 0x00, 0x88, 0x37, 0x9f, 0x76, 0x9e,
    0x60, 0x07, 0x88, 0x60, 0x2f, 0x92, 0x34, 0x00,
    0x81, 0x34, 0x04, 0x84, 0x34, 0x9b, 0x79, 0x02,
    0x80, 0x79, 0x99, 0x4d, 0x04, 0x80, 0x4d, 0x3f,
    0x9f, 0x59, 0x97, 0x58, 0x03, 0x93, 0x58, 0x01,
    0xad, 0x58, 0x83, 0x40, 0x00, 0x81, 0x40, 0x04,
    0x87, 0x40, 0x00, 0x82, 0x40, 0x00, 0x9c, 0x40,
    0x01, 0x82, 0x40, 0x03, 0x89, 0x40, 0x06, 0x88,
    0x40, 0x06, 0x9f, 0x6f, 0x9f, 0x6b, 0x1f, 0xa6,
    0x52, 0x03, 0x8b, 0x52, 0x08, 0xb5, 0x06, 0x02,
    0x86, 0x06, 0x95, 0x3a, 0x01, 0x87, 0x3a, 0x92,
    0x39, 0x04, 0x87, 0x39, 0x91, 0x7a, 0x06, 0x83,
    0x7a, 0x0b, 0x86, 0x7a, 0x4f, 0xc8, 0x70, 0x36,
    0xb2, 0x69, 0x0c, 0xb2, 0x69, 0x06, 0x85, 0x69,
    0xa7, 0x32, 0x07, 0x89, 0x32, 0x60, 0xc5, 0x9e,
    0x04, 0x00, 0xa9, 0x9f, 0x00, 0x82, 0x9f, 0x01,
    0x81, 0x9f, 0x4d, 0xa7, 0x6e, 0x07, 0xa9, 0x84,
    0x15, 0x99, 0x71, 0x25, 0x9b, 0x18, 0x13, 0x96,
    0x26, 0x08, 0xcd, 0x0e, 0x03, 0xa3, 0x0e, 0x08,
    0x80, 0x0e, 0xc2, 0x3c, 0x09, 0x80, 0x3c, 0x01,
    0x98, 0x85, 0x06, 0x89, 0x85, 0x05, 0xb4, 0x15,
    0x00, 0x91, 0x15, 0x07, 0xa6, 0x4f, 0x08, 0xdf,
    0x7f, 0x00, 0x93, 0x83, 0x0a, 0x91, 0x42, 0x00,
    0xab, 0x42, 0x40, 0x86, 0x5e, 0x00, 0x80, 0x5e,
    0x00, 0x83, 0x5e, 0x00, 0x8e, 0x5e, 0x00, 0x8a,
    0x5e, 0x05, 0xba, 0x44, 0x04, 0x89, 0x44, 0x05,
    0x83, 0x2b, 0x00, 0x87, 0x2b, 0x01, 0x81, 0x2b,
    0x01, 0x95, 0x2b, 0x00, 0x86, 0x2b, 0x00, 0x81,
    0x2b, 0x00, 0x84, 0x2b, 0x00, 0x80, 0x38, 0x88,
    0x2b, 0x01, 0x81, 0x2b, 0x01, 0x82, 0x2b, 0x01,
    0x80, 0x2b, 0x05, 0x80, 0x2b, 0x04, 0x86, 0x2b,
    0x01, 0x86, 0x2b, 0x02, 0x84, 0x2b, 0x60, 0x2a,
    0xdb, 0x63, 0x00, 0x84, 0x63, 0x1d, 0xc7, 0x97,
    0x07, 0x89, 0x97, 0x60, 0x45, 0xb5, 0x81, 0x01,
    0xa5, 0x81, 0x21, 0xc4, 0x5b, 0x0a, 0x89, 0x5b,
    0x05, 0x8c, 0x5c, 0x12, 0xb9, 0x8f, 0x05, 0x89,
    0x8f, 0x35, 0x9a, 0x02, 0x01, 0x8e, 0x02, 0x03,
    0x96, 0x02, 0x60, 0x58, 0xbb, 0x22, 0x60, 0x03,
    0xd2, 0x9e, 0x0b, 0x80, 0x9e, 0x86, 0x21, 0x01,
    0x80, 0x21, 0x01, 0x87, 0x21, 0x00, 0x81, 0x21,
    0x00, 0x9d, 0x21, 0x00, 0x81, 0x21, 0x01, 0x8b,
    0x21, 0x08, 0x89, 0x21, 0x45, 0x87, 0x61, 0x01,
    0xad, 0x61, 0x01, 0x8a, 0x61, 0x1a, 0xc7, 0xa1,
    0x07, 0xd2, 0x86, 0x0c, 0x8f, 0x12, 0xb8, 0x77,
    0x60, 0xa6, 0x88, 0x0c, 0x00, 0xac, 0x0c, 0x00,
    0x8d, 0x0c, 0x09, 0x9c, 0x0c, 0x02, 0x9f, 0x53,
    0x01, 0x95, 0x53, 0x00, 0x8d, 0x53, 0x48, 0x86,
    0x54, 0x00, 0x81, 0x54, 0x00, 0xab, 0x54, 0x02,
    0x80, 0x54, 0x00, 0x81, 0x54, 0x00, 0x88, 0x54,
    0x07, 0x89, 0x54, 0x05, 0x85, 0x2e, 0x00, 0x81,
    0x2e, 0x00, 0xa4, 0x2e, 0x00, 0x81, 0x2e, 0x00,
    0x85, 0x2e, 0x06, 0x89, 0x2e, 0x60, 0xd5, 0x98,
    0x4e, 0x60, 0x56, 0x80, 0x4b, 0x0e, 0xb1, 0x90,
    0x0c, 0x80, 0x90, 0xe3, 0x39, 0x1b, 0x60, 0x05,
    0xe0, 0x0e, 0x1b, 0x00, 0x84, 0x1b, 0x0a, 0xe0,
    0x63, 0x1b, 0x69, 0xeb, 0xe0, 0x02, 0x1e, 0x0c,
    0xe3, 0xce, 0x24, 0x00, 0x88, 0x24, 0x6f, 0x66,
    0xe1, 0xe6, 0x03, 0x70, 0x11, 0x58, 0xe1, 0xd8,
    0x08, 0x06, 0x9e, 0x5d, 0x00, 0x89, 0x5d, 0x03,
    0x81, 0x5d, 0xce, 0x98, 0x00, 0x89, 0x98, 0x05,
    0x9d, 0x09, 0x01, 0x85, 0x09, 0x09, 0xc5, 0x75,
    0x09, 0x89, 0x75, 0x00, 0x86, 0x75, 0x00, 0x94,
    0x75, 0x04, 0x92, 0x75, 0x62, 0x4f, 0xda, 0x55,
    0x60, 0x04, 0xca, 0x5a, 0x03, 0xb8, 0x5a, 0x06,
    0x90, 0x5a, 0x3f, 0x80, 0x91, 0x80, 0x65, 0x81,
    0x30, 0x80, 0x43, 0x0a, 0x81, 0x30, 0x0d, 0xf0,
    0x07, 0x97, 0x91, 0x07, 0xe2, 0x9f, 0x91, 0xe1,
    0x75, 0x43, 0x29, 0x88, 0x91, 0x70, 0x12, 0x86,
    0x83, 0x3e, 0x00, 0x86, 0x3e, 0x00, 0x81, 0x3e,
    0x00, 0x80, 0x3e, 0xe0, 0xbe, 0x36, 0x82, 0x3e,
    0x2c, 0x82, 0x36, 0x10, 0x83, 0x3e, 0x07, 0xe1,
    0x2b, 0x65, 0x68, 0xa3, 0xe0, 0x0a, 0x23, 0x04,
    0x8c, 0x23, 0x02, 0x88, 0x23, 0x06, 0x89, 0x23,
    0x01, 0x83, 0x23, 0x83, 0x19, 0x70, 0x01, 0xfb,
    0xad, 0x38, 0x01, 0x96, 0x38, 0x08, 0xe0, 0x13,
    0x19, 0x3b, 0xe0, 0x95, 0x19, 0x09, 0xa6, 0x19,
    0x01, 0xbd, 0x19, 0x82, 0x38, 0x90, 0x19, 0x87,
    0x38, 0x81, 0x19, 0x86, 0x38, 0x9d, 0x19, 0x83,
    0x38, 0xbc, 0x19, 0x14, 0xc5, 0x2c, 0x60, 0x39,
    0x93, 0x19, 0x0b, 0xd6, 0x19, 0x08, 0x98, 0x19,
    0x60, 0x26, 0xd4, 0x19, 0x00, 0xc6, 0x19, 0x00,
    0x81, 0x19, 0x01, 0x80, 0x19, 0x01, 0x81, 0x19,
    0x01, 0x83, 0x19, 0x00, 0x8b, 0x19, 0x00, 0x80,
    0x19, 0x00, 0x86, 0x19, 0x00, 0xc0, 0x19, 0x00,
    0x83, 0x19, 0x01, 0x87, 0x19, 0x00, 0x86, 0x19,
    0x00, 0x9b, 0x19, 0x00, 0x83, 0x19, 0x00, 0x84,
    0x19, 0x00, 0x80, 0x19, 0x02, 0x86, 0x19, 0x00,
    0xe0, 0xf3, 0x19, 0x01, 0xe0, 0xc3, 0x19, 0x01,
    0xb1, 0x19, 0xe2, 0x2b, 0x82, 0x0e, 0x84, 0x82,
    0x00, 0x8e, 0x82, 0x63, 0xef, 0x9e, 0x46, 0x60,
    0x80, 0x86, 0x29, 0x00, 0x90, 0x29, 0x01, 0x86,
    0x29, 0x00, 0x81, 0x29, 0x00, 0x84, 0x29, 0x60,
    0x74, 0xac, 0x66, 0x02, 0x8d, 0x66, 0x01, 0x89,
    0x66, 0x03, 0x81, 0x66, 0x60, 0xdf, 0x9e, 0x99,
    0x10, 0xb9, 0x9d, 0x04, 0x80, 0x9d, 0x64, 0x7f,
    0x86, 0x27, 0x00, 0x83, 0x27, 0x00, 0x81, 0x27,
    0x00, 0x8e, 0x27, 0x00, 0xe0, 0x64, 0x57, 0x01,
    0x8f, 0x57, 0x28, 0xcb, 0x01, 0x03, 0x89, 0x01,
    0x03, 0x81, 0x01, 0x62, 0xb0, 0xc3, 0x19, 0x4b,
    0xbc, 0x19, 0x60, 0x61, 0x83, 0x04, 0x00, 0x9a,
    0x04, 0x00, 0x81, 0x04, 0x00, 0x80, 0x04, 0x01,
    0x80, 0x04, 0x00, 0x89, 0x04, 0x00, 0x83, 0x04,
    0x00, 0x80, 0x04, 0x00, 0x80, 0x04, 0x05, 0x80,
    0x04, 0x03, 0x80, 0x04, 0x00, 0x80, 0x04, 0x00,
    0x80, 0x04, 0x00, 0x82, 0x04, 0x00, 0x81, 0x04,
    0x00, 0x80, 0x04, 0x01, 0x80, 0x04, 0x00, 0x80,
    0x04, 0x00, 0x80, 0x04, 0x00, 0x80, 0x04, 0x00,
    0x80, 0x04, 0x00, 0x81, 0x04, 0x00, 0x80, 0x04,
    0x01, 0x83, 0x04, 0x00, 0x86, 0x04, 0x00, 0x83,
    0x04, 0x00, 0x83, 0x04, 0x00, 0x80, 0x04, 0x00,
    0x89, 0x04, 0x00, 0x90, 0x04, 0x04, 0x82, 0x04,
    0x00, 0x84, 0x04, 0x00, 0x90, 0x04, 0x33, 0x81,
    0x04, 0x60, 0xad, 0xab, 0x19, 0x03, 0xe0, 0x03,
    0x19, 0x0b, 0x8e, 0x19, 0x01, 0x8e, 0x19, 0x00,
    0x8e, 0x19, 0x00, 0xa4, 0x19, 0x09, 0xe0, 0x4d,
    0x19, 0x37, 0x99, 0x19, 0x80, 0x36, 0x81, 0x19,
    0x0c, 0xab, 0x19, 0x03, 0x88, 0x19, 0x06, 0x81,
    0x19, 0x0d, 0x85, 0x19, 0x60, 0x39, 0xe3, 0x77,
    0x19, 0x04, 0x8f, 0x19, 0x02, 0x8c, 0x19, 0x02,
    0xe0, 0x13, 0x19, 0x0b, 0xd8, 0x19, 0x06, 0x8b,
    0x19, 0x03, 0x80, 0x19, 0x0e, 0x8b, 0x19, 0x03,
    0xb7, 0x19, 0x07, 0x89, 0x19, 0x05, 0xa7, 0x19,
    0x07, 0x9d, 0x19, 0x01, 0x81, 0x19, 0x4d, 0xe0,
    0xf3, 0x19, 0x0b, 0x8d, 0x19, 0x01, 0x84, 0x19,
    0x02, 0x84, 0x19, 0x02, 0x86, 0x19, 0x08, 0x9c,
    0x19, 0x02, 0x8a, 0x19, 0x04, 0x85, 0x19, 0x09,
    0x89, 0x19, 0x05, 0x87, 0x19, 0x07, 0x86, 0x19,
    0x08, 0xe0, 0x32, 0x19, 0x00, 0xb6, 0x19, 0x24,
    0x89, 0x19, 0x63, 0xa5, 0xf0, 0x96, 0x7f, 0x30,
    0x1f, 0xef, 0xd8, 0x30, 0x06, 0xe0, 0x7d, 0x30,
    0x01, 0xf0, 0x06, 0x21, 0x30, 0x0d, 0xf0, 0x0c,
    0xd0, 0x30, 0x6b, 0xbe, 0xe1, 0xbd, 0x30, 0x65,
    0x81, 0xf0, 0x02, 0xea, 0x30, 0x7a, 0xdc, 0x55,
    0x80, 0x19, 0x1d, 0xdf, 0x19, 0x60, 0x1f, 0xe0,
    0x8f, 0x38,
};

static const uint8_t unicode_script_ext_table[828] = {
    0x82, 0xc1, 0x00, 0x00, 0x01, 0x2c, 0x01, 0x00,
    0x00, 0x01, 0x2c, 0x1c, 0x00, 0x0c, 0x01, 0x46,
    0x80, 0x92, 0x00, 0x00, 0x02, 0x1d, 0x6c, 0x00,
    0x02, 0x1d, 0x29, 0x01, 0x02, 0x1d, 0x46, 0x00,
    0x02, 0x1d, 0x29, 0x81, 0x03, 0x00, 0x00, 0x06,
    0x04, 0x64, 0x32, 0x89, 0x93, 0x9f, 0x0d, 0x00,
    0x00, 0x06, 0x04, 0x64, 0x32, 0x89, 0x93, 0x9f,
    0x00, 0x03, 0x04, 0x89, 0x93, 0x01, 0x00, 0x00,
    0x07, 0x01, 0x04, 0x64, 0x32, 0x89, 0x93, 0x9f,
    0x1f, 0x00, 0x00, 0x09, 0x01, 0x04, 0x51, 0x52,
    0x71, 0x7a, 0x32, 0x84, 0x89, 0x09, 0x00, 0x0a,
    0x02, 0x04, 0x89, 0x09, 0x00, 0x09, 0x03, 0x04,
    0x93, 0x9f, 0x05, 0x00, 0x00, 0x02, 0x04, 0x89,
    0x62, 0x00, 0x00, 0x02, 0x04, 0x32, 0x81, 0xfb,
    0x00, 0x00, 0x0d, 0x0b, 0x20, 0x2b, 0x2d, 0x2f,
    0x3d, 0x46, 0x50, 0x72, 0x7f, 0x90, 0x92, 0x97,
    0x00, 0x0c, 0x0b, 0x20, 0x2b, 0x2d, 0x2f, 0x3d,
    0x46, 0x50, 0x72, 0x90, 0x92, 0x97, 0x10, 0x00,
    0x00, 0x14, 0x0b, 0x20, 0x22, 0x2e, 0x54, 0x2b,
    0x2d, 0x2f, 0x3d, 0x4f, 0x50, 0x61, 0x72, 0x44,
    0x83, 0x88, 0x8f, 0x90, 0x92, 0x97, 0x00, 0x15,
    0x0b, 0x20, 0x22, 0x2e, 0x54, 0x2b, 0x2d, 0x2f,
    0x3d, 0x48, 0x4f, 0x50, 0x61, 0x72, 0x44, 0x83,
    0x88, 0x8f, 0x90, 0x92, 0x97, 0x09, 0x04, 0x20,
    0x22, 0x3c, 0x4f, 0x75, 0x00, 0x09, 0x03, 0x0b,
    0x15, 0x88, 0x75, 0x00, 0x09, 0x02, 0x2f, 0x5e,
    0x75, 0x00, 0x09, 0x02, 0x2d, 0x42, 0x80, 0x75,
    0x00, 0x0d, 0x02, 0x2b, 0x90, 0x80, 0x71, 0x00,
    0x09, 0x02, 0x3d, 0x61, 0x82, 0xcf, 0x00, 0x09,
    0x03, 0x15, 0x5f, 0x8c, 0x80, 0x30, 0x00, 0x00,
    0x02, 0x28, 0x46, 0x85, 0xb8, 0x00, 0x01, 0x04,
    0x11, 0x33, 0x8b, 0x8a, 0x80, 0x4a, 0x00, 0x01,
    0x02, 0x5c, 0x78, 0x00, 0x00, 0x00, 0x02, 0x5c,
    0x78, 0x84, 0x49, 0x00, 0x00, 0x04, 0x0b, 0x20,
    0x2b, 0x3d, 0x00, 0x01, 0x20, 0x00, 0x04, 0x0b,
    0x20, 0x2b, 0x3d, 0x00, 0x02, 0x20, 0x2b, 0x00,
    0x01, 0x20, 0x01, 0x02, 0x0b, 0x20, 0x00, 0x02,
    0x20, 0x7f, 0x00, 0x02, 0x0b, 0x20, 0x00, 0x02,
    0x20, 0x7f, 0x00, 0x06, 0x20, 0x3d, 0x50, 0x72,
    0x90, 0x92, 0x00, 0x01, 0x20, 0x01, 0x02, 0x20,
    0x7f, 0x01, 0x01, 0x20, 0x00, 0x02, 0x20, 0x7f,
    0x00, 0x02, 0x0b, 0x20, 0x06, 0x01, 0x20, 0x00,
    0x02, 0x20, 0x61, 0x00, 0x02, 0x0b, 0x20, 0x01,
    0x01, 0x20, 0x00, 0x02, 0x0b, 0x20, 0x03, 0x01,
    0x20, 0x00, 0x08, 0x0b, 0x20, 0x2b, 0x3d, 0x61,
    0x72, 0x92, 0x97, 0x00, 0x02, 0x20, 0x2b, 0x00,
    0x03, 0x20, 0x2b, 0x3d, 0x01, 0x02, 0x0b, 0x20,
    0x00, 0x01, 0x0b, 0x01, 0x02, 0x20, 0x2b, 0x00,
    0x01, 0x61, 0x80, 0x44, 0x00, 0x01, 0x01, 0x2c,
    0x35, 0x00, 0x00, 0x02, 0x1d, 0x89, 0x00, 0x00,
    0x00, 0x01, 0x89, 0x81, 0xb3, 0x00, 0x00, 0x02,
    0x46, 0x5c, 0x80, 0x3f, 0x00, 0x00, 0x03, 0x20,
    0x2b, 0x46, 0x8c, 0xd1, 0x00, 0x00, 0x02, 0x1d,
    0x29, 0x81, 0x3c, 0x00, 0x01, 0x06, 0x0d, 0x31,
    0x30, 0x36, 0x3e, 0xa0, 0x00, 0x05, 0x0d, 0x31,
    0x30, 0x36, 0x3e, 0x01, 0x00, 0x00, 0x01, 0x30,
    0x00, 0x00, 0x09, 0x06, 0x0d, 0x31, 0x30, 0x36,
    0x3e, 0xa0, 0x00, 0x00, 0x00, 0x05, 0x0d, 0x31,
    0x30, 0x36, 0x3e, 0x07, 0x06, 0x0d, 0x31, 0x30,
    0x36, 0x3e, 0xa0, 0x03, 0x05, 0x0d, 0x31, 0x30,
    0x36, 0x3e, 0x09, 0x00, 0x03, 0x02, 0x0d, 0x30,
    0x01, 0x00, 0x00, 0x05, 0x0d, 0x31, 0x30, 0x36,
    0x3e, 0x04, 0x02, 0x36, 0x3e, 0x00, 0x00, 0x00,
    0x05, 0x0d, 0x31, 0x30, 0x36, 0x3e, 0x03, 0x00,
    0x01, 0x03, 0x30, 0x36, 0x3e, 0x01, 0x01, 0x30,
    0x58, 0x00, 0x03, 0x02, 0x36, 0x3e, 0x02, 0x00,
    0x00, 0x02, 0x36, 0x3e, 0x59, 0x00, 0x00, 0x06,
    0x0d, 0x31, 0x30, 0x36, 0x3e, 0xa0, 0x00, 0x02,
    0x36, 0x3e, 0x80, 0x12, 0x00, 0x0f, 0x01, 0x30,
    0x1f, 0x00, 0x23, 0x01, 0x30, 0x3b, 0x00, 0x27,
    0x01, 0x30, 0x37, 0x00, 0x30, 0x01, 0x30, 0x0e,
    0x00, 0x0b, 0x01, 0x30, 0x32, 0x00, 0x00, 0x01,
    0x30, 0x57, 0x00, 0x18, 0x01, 0x30, 0x09, 0x00,
    0x04, 0x01, 0x30, 0x5f, 0x00, 0x1e, 0x01, 0x30,
    0xc0, 0x31, 0xef, 0x00, 0x00, 0x02, 0x1d, 0x29,
    0x80, 0x0f, 0x00, 0x07, 0x02, 0x30, 0x46, 0x80,
    0xa7, 0x00, 0x02, 0x0e, 0x20, 0x22, 0x2d, 0x2f,
    0x42, 0x3d, 0x3c, 0x4f, 0x50, 0x5b, 0x61, 0x44,
    0x8f, 0x97, 0x02, 0x0d, 0x20, 0x22, 0x2d, 0x2f,
    0x42, 0x3d, 0x3c, 0x4f, 0x5b, 0x61, 0x44, 0x8f,
    0x97, 0x03, 0x0b, 0x20, 0x22, 0x2d, 0x2f, 0x42,
    0x3c, 0x4f, 0x5b, 0x44, 0x8f, 0x97, 0x80, 0x36,
    0x00, 0x00, 0x02, 0x0b, 0x20, 0x00, 0x00, 0x00,
    0x02, 0x20, 0x90, 0x39, 0x00, 0x00, 0x03, 0x3f,
    0x46, 0x5f, 0x80, 0x1f, 0x00, 0x00, 0x02, 0x10,
    0x3b, 0xc0, 0x12, 0xed, 0x00, 0x01, 0x02, 0x04,
    0x64, 0x80, 0x31, 0x00, 0x00, 0x02, 0x04, 0x93,
    0x09, 0x00, 0x00, 0x02, 0x04, 0x93, 0x46, 0x00,
    0x01, 0x05, 0x0d, 0x31, 0x30, 0x36, 0x3e, 0x80,
    0x99, 0x00, 0x04, 0x06, 0x0d, 0x31, 0x30, 0x36,
    0x3e, 0xa0, 0x09, 0x00, 0x00, 0x02, 0x36, 0x3e,
    0x2c, 0x00, 0x01, 0x02, 0x36, 0x3e, 0x80, 0xdf,
    0x00, 0x01, 0x03, 0x1e, 0x1c, 0x4a, 0x00, 0x02,
    0x1c, 0x4a, 0x03, 0x00, 0x2c, 0x03, 0x1c, 0x49,
    0x4a, 0x02, 0x00, 0x08, 0x02, 0x1c, 0x4a, 0x81,
    0x1f, 0x00, 0x1b, 0x02, 0x04, 0x1a, 0x87, 0x75,
    0x00, 0x00, 0x02, 0x52, 0x71, 0x87, 0x8d, 0x00,
    0x00, 0x02, 0x2b, 0x90, 0x00, 0x00, 0x00, 0x02,
    0x2b, 0x90, 0x36, 0x00, 0x01, 0x02, 0x2b, 0x90,
    0x8c, 0x12, 0x00, 0x01, 0x02, 0x2b, 0x90, 0x00,
    0x00, 0x00, 0x02, 0x2b, 0x90, 0xc0, 0x5c, 0x4b,
    0x00, 0x03, 0x01, 0x23, 0x96, 0x3b, 0x00, 0x11,
    0x01, 0x30, 0x9e, 0x5d, 0x00, 0x01, 0x01, 0x30,
    0xce, 0xcd, 0x2d, 0x00,
};

static const uint8_t unicode_prop_Hyphen_table[28] = {
    0xac, 0x80, 0xfe, 0x80, 0x44, 0xdb, 0x80, 0x52,
    0x7a, 0x80, 0x48, 0x08, 0x81, 0x4e, 0x04, 0x80,
    0x42, 0xe2, 0x80, 0x60, 0xcd, 0x66, 0x80, 0x40,
    0xa8, 0x80, 0xd6, 0x80,
};

static const uint8_t unicode_prop_Other_Math_table[200] = {
    0xdd, 0x80, 0x43, 0x70, 0x11, 0x80, 0x99, 0x09,
    0x81, 0x5c, 0x1f, 0x80, 0x9a, 0x82, 0x8a, 0x80,
    0x9f, 0x83, 0x97, 0x81, 0x8d, 0x81, 0xc0, 0x8c,
    0x18, 0x11, 0x1c, 0x91, 0x03, 0x01, 0x89, 0x00,
    0x14, 0x28, 0x11, 0x09, 0x02, 0x05, 0x13, 0x24,
    0xca, 0x21, 0x18, 0x08, 0x08, 0x00, 0x21, 0x0b,
    0x0b, 0x91, 0x09, 0x00, 0x06, 0x00, 0x29, 0x41,
    0x21, 0x83, 0x40, 0xa7, 0x08, 0x80, 0x97, 0x80,
    0x90, 0x80, 0x41, 0xbc, 0x81, 0x8b, 0x88, 0x24,
    0x21, 0x09, 0x14, 0x8d, 0x00, 0x01, 0x85, 0x97,
    0x81, 0xb8, 0x00, 0x80, 0x9c, 0x83, 0x88, 0x81,
    0x41, 0x55, 0x81, 0x9e, 0x89, 0x41, 0x92, 0x95,
    0xbe, 0x83, 0x9f, 0x81, 0x60, 0xd4, 0x62, 0x00,
    0x03, 0x80, 0x40, 0xd2, 0x00, 0x80, 0x60, 0xd4,
    0xc0, 0xd4, 0x80, 0xc6, 0x01, 0x08, 0x09, 0x0b,
    0x80, 0x8b, 0x00, 0x06, 0x80, 0xc0, 0x03, 0x0f,
    0x06, 0x80, 0x9b, 0x03, 0x04, 0x00, 0x16, 0x80,
    0x41, 0x53, 0x81, 0x98, 0x80, 0x98, 0x80, 0x9e,
    0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x80, 0x9e,
    0x80, 0x98, 0x80, 0x9e, 0x80, 0x98, 0x07, 0x81,
    0xb1, 0x55, 0xff, 0x18, 0x9a, 0x01, 0x00, 0x08,
    0x80, 0x89, 0x03, 0x00, 0x00, 0x28, 0x18, 0x00,
    0x00, 0x02, 0x01, 0x00, 0x08, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x0b, 0x06, 0x03, 0x03, 0x00,
    0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80, 0x90,
};

static const uint8_t unicode_prop_Other_Alphabetic_table[417] = {
    0x43, 0x44, 0x80, 0x42, 0x69, 0x8d, 0x00, 0x01,
    0x01, 0x00, 0xc7, 0x8a, 0xaf, 0x8c, 0x06, 0x8f,
    0x80, 0xe4, 0x33, 0x19, 0x0b, 0x80, 0xa2, 0x80,
    0x9d, 0x8f, 0xe5, 0x8a, 0xe4, 0x0a, 0x88, 0x02,
    0x03, 0x40, 0xa6, 0x8b, 0x16, 0x85, 0x93, 0xb5,
    0x09, 0x8e, 0x01, 0x22, 0x89, 0x81, 0x9c, 0x82,
    0xb9, 0x31, 0x09, 0x81, 0x89, 0x80, 0x89, 0x81,
    0x9c, 0x82, 0xb9, 0x23, 0x09, 0x0b, 0x80, 0x9d,
    0x0a, 0x80, 0x8a, 0x82, 0xb9, 0x38, 0x10, 0x81,
    0x94, 0x81, 0x95, 0x13, 0x82, 0xb9, 0x31, 0x09,
    0x81, 0x88, 0x81, 0x89, 0x81, 0x9d, 0x80, 0xba,
    0x22, 0x10, 0x82, 0x89, 0x80, 0xa7, 0x83, 0xb9,
    0x30, 0x10, 0x17, 0x81, 0x8a, 0x81, 0x9c, 0x82,
    0xb9, 0x30, 0x10, 0x17, 0x81, 0x8a, 0x81, 0x9b,
    0x83, 0xb9, 0x30, 0x10, 0x82, 0x89, 0x80, 0x89,
    0x81, 0x9c, 0x82, 0xca, 0x28, 0x00, 0x87, 0x91,
    0x81, 0xbc, 0x01, 0x86, 0x91, 0x80, 0xe2, 0x01,
    0x28, 0x81, 0x8f, 0x80, 0x40, 0xa2, 0x90, 0x8a,
    0x8a, 0x80, 0xa3, 0xed, 0x8b, 0x00, 0x0b, 0x96,
    0x1b, 0x10, 0x11, 0x32, 0x83, 0x8c, 0x8b, 0x00,
    0x89, 0x83, 0x46, 0x73, 0x81, 0x9d, 0x81, 0x9d,
    0x81, 0x9d, 0x81, 0xc1, 0x92, 0x40, 0xbb, 0x81,
    0xa1, 0x80, 0xf5, 0x8b, 0x83, 0x88, 0x40, 0xdd,
    0x84, 0xb8, 0x89, 0x81, 0x93, 0xc9, 0x81, 0x8a,
    0x82, 0xb0, 0x84, 0xaf, 0x8e, 0xbb, 0x82, 0x9d,
    0x88, 0x09, 0xb8, 0x8a, 0xb1, 0x92, 0x41, 0xaf,
    0x8d, 0x46, 0xc0, 0xb3, 0x48, 0xf5, 0x9f, 0x60,
    0x78, 0x73, 0x87, 0xa1, 0x81, 0x41, 0x61, 0x07,
    0x80, 0x96, 0x84, 0xd7, 0x81, 0xb1, 0x8f, 0x00,
    0xb8, 0x80, 0xa5, 0x84, 0x9b, 0x8b, 0xac, 0x83,
    0xaf, 0x8b, 0xa4, 0x80, 0xc2, 0x8d, 0x8b, 0x07,
    0x81, 0xac, 0x82, 0xb1, 0x00, 0x11, 0x0c, 0x80,
    0xab, 0x24, 0x80, 0x40, 0xec, 0x87, 0x60, 0x4f,
    0x32, 0x80, 0x48, 0x56, 0x84, 0x46, 0x85, 0x10,
    0x0c, 0x83, 0x43, 0x13, 0x83, 0x41, 0x82, 0x81,
    0x41, 0x52, 0x82, 0xb4, 0x8d, 0xac, 0x81, 0x8c,
    0x80, 0xac, 0x88, 0x88, 0x80, 0xbc, 0x82, 0xa3,
    0x8b, 0x91, 0x81, 0xb8, 0x82, 0xaf, 0x8c, 0x8d,
    0x81, 0xdb, 0x88, 0x08, 0x28, 0x40, 0x9f, 0x89,
    0x96, 0x83, 0xb9, 0x31, 0x09, 0x81, 0x89, 0x80,
    0x89, 0x81, 0x40, 0xd0, 0x8c, 0x02, 0xe9, 0x91,
    0x40, 0xec, 0x31, 0x86, 0x9c, 0x81, 0xd1, 0x8e,
    0x00, 0xe9, 0x8a, 0xe6, 0x8d, 0x41, 0x00, 0x8c,
    0x40, 0xf6, 0x28, 0x09, 0x0a, 0x00, 0x80, 0x40,
    0x8d, 0x31, 0x2b, 0x80, 0x9b, 0x89, 0xa9, 0x20,
    0x83, 0x91, 0x8a, 0xad, 0x8d, 0x41, 0x96, 0x38,
    0x86, 0xd2, 0x95, 0x80, 0x8d, 0xf9, 0x2a, 0x00,
    0x08, 0x10, 0x02, 0x80, 0xc1, 0x20, 0x08, 0x83,
    0x41, 0x5b, 0x83, 0x60, 0x50, 0x57, 0x00, 0xb6,
    0x33, 0xdc, 0x81, 0x60, 0x4c, 0xab, 0x80, 0x60,
    0x23, 0x60, 0x30, 0x90, 0x0e, 0x01, 0x04, 0x49,
    0x1b, 0x80, 0x47, 0xe7, 0x99, 0x85, 0x99, 0x85,
    0x99,
};

static const uint8_t unicode_prop_Other_Lowercase_table[59] = {
    0x40, 0xa9, 0x80, 0x8e, 0x80, 0x41, 0xf4, 0x88,
    0x31, 0x9d, 0x84, 0xdf, 0x80, 0xb3, 0x80, 0x59,
    0xb0, 0xbe, 0x8c, 0x80, 0xa1, 0xa4, 0x42, 0xb0,
    0x80, 0x8c, 0x80, 0x8f, 0x8c, 0x40, 0xd2, 0x8f,
    0x43, 0x4f, 0x99, 0x47, 0x91, 0x81, 0x60, 0x7a,
    0x1d, 0x81, 0x40, 0xd1, 0x80, 0x40, 0x86, 0x81,
    0x43, 0x61, 0x83, 0x60, 0x5c, 0x1f, 0x01, 0x10,
    0xa9, 0x80, 0x88,
};

static const uint8_t unicode_prop_Other_Uppercase_table[15] = {
    0x60, 0x21, 0x5f, 0x8f, 0x43, 0x45, 0x99, 0x61,
    0xcc, 0x5f, 0x99, 0x85, 0x99, 0x85, 0x99,
};

static const uint8_t unicode_prop_Other_Grapheme_Extend_table[65] = {
    0x49, 0xbd, 0x80, 0x97, 0x80, 0x41, 0x65, 0x80,
    0x97, 0x80, 0xe5, 0x80, 0x97, 0x80, 0x40, 0xe9,
    0x80, 0x91, 0x81, 0xe6, 0x80, 0x97, 0x80, 0xf6,
    0x80, 0x8e, 0x80, 0x4d, 0x54, 0x80, 0x44, 0xd5,
    0x80, 0x50, 0x20, 0x81, 0x60, 0xcf, 0x6d, 0x81,
    0x53, 0x9d, 0x80, 0x97, 0x80, 0x41, 0x57, 0x80,
    0x8b, 0x80, 0x40, 0xf0, 0x80, 0x43, 0x7f, 0x80,
    0x60, 0xb8, 0x33, 0x07, 0x84, 0x6c, 0x2e, 0xac,
    0xdf,
};

static const uint8_t unicode_prop_Other_Default_Ignorable_Code_Point_table[32] = {
    0x43, 0x4e, 0x80, 0x4e, 0x0e, 0x81, 0x46, 0x52,
    0x81, 0x48, 0xae, 0x80, 0x50, 0xfd, 0x80, 0x60,
    0xce, 0x3a, 0x80, 0xce, 0x88, 0x6d, 0x00, 0x06,
    0x00, 0x9d, 0xdf, 0xff, 0x40, 0xef, 0x4e, 0x0f,
};

static const uint8_t unicode_prop_Other_ID_Start_table[11] = {
    0x58, 0x84, 0x81, 0x48, 0x90, 0x80, 0x94, 0x80,
    0x4f, 0x6b, 0x81,
};

static const uint8_t unicode_prop_Other_ID_Continue_table[12] = {
    0x40, 0xb6, 0x80, 0x42, 0xce, 0x80, 0x4f, 0xe0,
    0x88, 0x46, 0x67, 0x80,
};

static const uint8_t unicode_prop_Prepended_Concatenation_Mark_table[19] = {
    0x45, 0xff, 0x85, 0x40, 0xd6, 0x80, 0xb0, 0x80,
    0x41, 0x7f, 0x81, 0xcf, 0x80, 0x61, 0x07, 0xd9,
    0x80, 0x8e, 0x80,
};

static const uint8_t unicode_prop_XID_Start1_table[31] = {
    0x43, 0x79, 0x80, 0x4a, 0xb7, 0x80, 0xfe, 0x80,
    0x60, 0x21, 0xe6, 0x81, 0x60, 0xcb, 0xc0, 0x85,
    0x41, 0x95, 0x81, 0xf3, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x80, 0x41, 0x1e, 0x81,
};

static const uint8_t unicode_prop_XID_Continue1_table[23] = {
    0x43, 0x79, 0x80, 0x60, 0x2d, 0x1f, 0x81, 0x60,
    0xcb, 0xc0, 0x85, 0x41, 0x95, 0x81, 0xf3, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
};

static const uint8_t unicode_prop_Changes_When_Titlecased1_table[22] = {
    0x41, 0xc3, 0x08, 0x08, 0x81, 0xa4, 0x81, 0x4e,
    0xdc, 0xaa, 0x0a, 0x4e, 0x87, 0x3f, 0x3f, 0x87,
    0x8b, 0x80, 0x8e, 0x80, 0xae, 0x80,
};

static const uint8_t unicode_prop_Changes_When_Casefolded1_table[33] = {
    0x40, 0xde, 0x80, 0xcf, 0x80, 0x97, 0x80, 0x44,
    0x3c, 0x80, 0x59, 0x11, 0x80, 0x40, 0xe4, 0x3f,
    0x3f, 0x87, 0x89, 0x11, 0x05, 0x02, 0x11, 0x80,
    0xa9, 0x11, 0x80, 0x60, 0xdb, 0x07, 0x86, 0x8b,
    0x84,
};

static const uint8_t unicode_prop_Changes_When_NFKC_Casefolded1_table[448] = {
    0x40, 0x9f, 0x06, 0x00, 0x01, 0x00, 0x01, 0x12,
    0x10, 0x82, 0x9f, 0x80, 0xcf, 0x01, 0x80, 0x8b,
    0x07, 0x80, 0xfb, 0x01, 0x01, 0x80, 0xa5, 0x80,
    0x40, 0xbb, 0x88, 0x9e, 0x29, 0x84, 0xda, 0x08,
    0x81, 0x89, 0x80, 0xa3, 0x04, 0x02, 0x04, 0x08,
    0x80, 0xc9, 0x82, 0x9c, 0x80, 0x41, 0x93, 0x80,
    0x40, 0x93, 0x80, 0xd7, 0x83, 0x42, 0xde, 0x87,
    0xfb, 0x08, 0x80, 0xd2, 0x01, 0x80, 0xa1, 0x11,
    0x80, 0x40, 0xfc, 0x81, 0x42, 0xd4, 0x80, 0xfe,
    0x80, 0xa7, 0x81, 0xad, 0x80, 0xb5, 0x80, 0x88,
    0x03, 0x03, 0x03, 0x80, 0x8b, 0x80, 0x88, 0x00,
    0x26, 0x80, 0x90, 0x80, 0x88, 0x03, 0x03, 0x03,
    0x80, 0x8b, 0x80, 0x41, 0x41, 0x80, 0xe1, 0x81,
    0x46, 0x52, 0x81, 0xd4, 0x84, 0x45, 0x1b, 0x10,
    0x8a, 0x80, 0x91, 0x80, 0x9b, 0x8c, 0x80, 0xa1,
    0xa4, 0x40, 0xd9, 0x80, 0x40, 0xd5, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x01, 0x3f, 0x3f, 0x87,
    0x89, 0x11, 0x04, 0x00, 0x29, 0x04, 0x12, 0x80,
    0x88, 0x12, 0x80, 0x88, 0x11, 0x11, 0x04, 0x08,
    0x8f, 0x00, 0x20, 0x8b, 0x12, 0x2a, 0x08, 0x0b,
    0x00, 0x07, 0x82, 0x8c, 0x06, 0x92, 0x81, 0x9a,
    0x80, 0x8c, 0x8a, 0x80, 0xd6, 0x18, 0x10, 0x8a,
    0x01, 0x0c, 0x0a, 0x00, 0x10, 0x11, 0x02, 0x06,
    0x05, 0x1c, 0x85, 0x8f, 0x8f, 0x8f, 0x88, 0x80,
    0x40, 0xa1, 0x08, 0x81, 0x40, 0xf7, 0x81, 0x41,
    0x34, 0xd5, 0x99, 0x9a, 0x45, 0x20, 0x80, 0xe6,
    0x82, 0xe4, 0x80, 0x41, 0x9e, 0x81, 0x40, 0xf0,
    0x80, 0x41, 0x2e, 0x80, 0xd2, 0x80, 0x8b, 0x40,
    0xd5, 0xa9, 0x80, 0xb4, 0x00, 0x82, 0xdf, 0x09,
    0x80, 0xde, 0x80, 0xb0, 0xdd, 0x82, 0x8d, 0xdf,
    0x9e, 0x80, 0xa7, 0x87, 0xae, 0x80, 0x41, 0x7f,
    0x60, 0x72, 0x9b, 0x81, 0x40, 0xd1, 0x80, 0x40,
    0x80, 0x12, 0x81, 0x43, 0x61, 0x83, 0x88, 0x80,
    0x60, 0x4d, 0x95, 0x41, 0x0d, 0x08, 0x00, 0x81,
    0x89, 0x00, 0x00, 0x09, 0x82, 0xc3, 0x81, 0xe9,
    0xa5, 0x86, 0x8b, 0x24, 0x00, 0x97, 0x04, 0x00,
    0x01, 0x01, 0x80, 0xeb, 0xa0, 0x41, 0x6a, 0x91,
    0xbf, 0x81, 0xb5, 0xa7, 0x8c, 0x82, 0x99, 0x95,
    0x94, 0x81, 0x8b, 0x80, 0x92, 0x03, 0x1a, 0x00,
    0x80, 0x40, 0x86, 0x08, 0x80, 0x9f, 0x99, 0x40,
    0x83, 0x15, 0x0d, 0x0d, 0x0a, 0x16, 0x06, 0x80,
    0x88, 0x47, 0x87, 0x20, 0xa9, 0x80, 0x88, 0x60,
    0xb4, 0xe4, 0x83, 0x54, 0xb9, 0x86, 0x8d, 0x87,
    0xbf, 0x85, 0x42, 0x3e, 0xd4, 0x80, 0xc6, 0x01,
    0x08, 0x09, 0x0b, 0x80, 0x8b, 0x00, 0x06, 0x80,
    0xc0, 0x03, 0x0f, 0x06, 0x80, 0x9b, 0x03, 0x04,
    0x00, 0x16, 0x80, 0x41, 0x53, 0x81, 0x41, 0x23,
    0x81, 0xb1, 0x55, 0xff, 0x18, 0x9a, 0x01, 0x00,
    0x08, 0x80, 0x89, 0x03, 0x00, 0x00, 0x28, 0x18,
    0x00, 0x00, 0x02, 0x01, 0x00, 0x08, 0x00, 0x00,
    0x00, 0x00, 0x01, 0x00, 0x0b, 0x06, 0x03, 0x03,
    0x00, 0x80, 0x89, 0x80, 0x90, 0x22, 0x04, 0x80,
    0x90, 0x42, 0x43, 0x8a, 0x84, 0x9e, 0x80, 0x9f,
    0x99, 0x82, 0xa2, 0x80, 0xee, 0x82, 0x8c, 0xab,
    0x83, 0x88, 0x31, 0x49, 0x9d, 0x89, 0x60, 0xfc,
    0x05, 0x42, 0x1d, 0x6b, 0x05, 0xe1, 0x4f, 0xff,
};

static const uint8_t unicode_prop_ASCII_Hex_Digit_table[5] = {
    0xaf, 0x89, 0x35, 0x99, 0x85,
};

static const uint8_t unicode_prop_Bidi_Control_table[10] = {
    0x46, 0x1b, 0x80, 0x59, 0xf0, 0x81, 0x99, 0x84,
    0xb6, 0x83,
};

static const uint8_t unicode_prop_Dash_table[55] = {
    0xac, 0x80, 0x45, 0x5b, 0x80, 0xb2, 0x80, 0x4e,
    0x40, 0x80, 0x44, 0x04, 0x80, 0x48, 0x08, 0x85,
    0xbc, 0x80, 0xa6, 0x80, 0x8e, 0x80, 0x41, 0x85,
    0x80, 0x4c, 0x03, 0x01, 0x80, 0x9e, 0x0b, 0x80,
    0x9b, 0x80, 0x41, 0xbd, 0x80, 0x92, 0x80, 0xee,
    0x80, 0x60, 0xcd, 0x8f, 0x81, 0xa4, 0x80, 0x89,
    0x80, 0x40, 0xa8, 0x80, 0x4f, 0x9e, 0x80,
};

static const uint8_t unicode_prop_Deprecated_table[23] = {
    0x41, 0x48, 0x80, 0x45, 0x28, 0x80, 0x49, 0x02,
    0x00, 0x80, 0x48, 0x28, 0x81, 0x48, 0xc4, 0x85,
    0x42, 0xb8, 0x81, 0x6d, 0xdc, 0xd5, 0x80,
};

static const uint8_t unicode_prop_Diacritic_table[391] = {
    0xdd, 0x00, 0x80, 0xc6, 0x05, 0x03, 0x01, 0x81,
    0x41, 0xf6, 0x40, 0x9e, 0x07, 0x25, 0x90, 0x0b,
    0x80, 0x88, 0x81, 0x40, 0xfc, 0x84, 0x40, 0xd0,
    0x80, 0xb6, 0x90, 0x80, 0x9a, 0x00, 0x01, 0x00,
    0x40, 0x85, 0x3b, 0x81, 0x40, 0x85, 0x0b, 0x0a,
    0x82, 0xc2, 0x9a, 0xda, 0x8a, 0xb9, 0x8a, 0xa1,
    0x81, 0xfd, 0x87, 0xa8, 0x89, 0x8f, 0x9b, 0xbc,
    0x80, 0x8f, 0x02, 0x83, 0x9b, 0x80, 0xc9, 0x80,
    0x8f, 0x80, 0xed, 0x80, 0x8f, 0x80, 0xed, 0x80,
    0x8f, 0x80, 0xae, 0x82, 0xbb, 0x80, 0x8f, 0x06,
    0x80, 0xf6, 0x80, 0xed, 0x80, 0x8f, 0x80, 0xed,
    0x80, 0x8f, 0x80, 0xec, 0x81, 0x8f, 0x80, 0xfb,
    0x80, 0xfb, 0x28, 0x80, 0xea, 0x80, 0x8c, 0x84,
    0xca, 0x81, 0x9a, 0x00, 0x00, 0x03, 0x81, 0xc1,
    0x10, 0x81, 0xbd, 0x80, 0xef, 0x00, 0x81, 0xa7,
    0x0b, 0x84, 0x98, 0x30, 0x80, 0x89, 0x81, 0x42,
    0xc0, 0x82, 0x43, 0xb3, 0x81, 0x40, 0xb2, 0x8a,
    0x88, 0x80, 0x41, 0x5a, 0x82, 0x41, 0x38, 0x39,
    0x80, 0xaf, 0x8e, 0x81, 0x8a, 0xe7, 0x80, 0x8e,
    0x80, 0xa5, 0x88, 0xb5, 0x81, 0x40, 0x89, 0x81,
    0xbf, 0x85, 0xd1, 0x98, 0x18, 0x28, 0x0a, 0xb1,
    0xbe, 0xd8, 0x8b, 0xa4, 0x8a, 0x41, 0xbc, 0x00,
    0x82, 0x8a, 0x82, 0x8c, 0x82, 0x8c, 0x82, 0x8c,
    0x81, 0x4c, 0xef, 0x82, 0x41, 0x3c, 0x80, 0x41,
    0xf9, 0x85, 0xe8, 0x83, 0xde, 0x80, 0x60, 0x75,
    0x71, 0x80, 0x8b, 0x08, 0x80, 0x9b, 0x81, 0xd1,
    0x81, 0x8d, 0xa1, 0xe5, 0x82, 0xec, 0x81, 0x40,
    0xc9, 0x80, 0x9a, 0x91, 0xb8, 0x83, 0xa3, 0x80,
    0xde, 0x80, 0x8b, 0x80, 0xa3, 0x80, 0x40, 0x94,
    0x82, 0xc0, 0x83, 0xb2, 0x80, 0xe3, 0x84, 0x88,
    0x82, 0xff, 0x81, 0x60, 0x4f, 0x2f, 0x80, 0x43,
    0x00, 0x8f, 0x41, 0x0d, 0x00, 0x80, 0xae, 0x80,
    0xac, 0x81, 0xc2, 0x80, 0x42, 0xfb, 0x80, 0x44,
    0x9e, 0x28, 0xa9, 0x80, 0x88, 0x43, 0x29, 0x81,
    0x42, 0x3a, 0x85, 0x42, 0x1d, 0x8a, 0xb0, 0x83,
    0x40, 0xbf, 0x80, 0xa8, 0x80, 0xc7, 0x81, 0xf7,
    0x81, 0xbd, 0x80, 0xcb, 0x80, 0x88, 0x82, 0xe7,
    0x81, 0x40, 0xb1, 0x81, 0xd0, 0x80, 0x8f, 0x80,
    0x97, 0x32, 0x84, 0x40, 0xcc, 0x02, 0x80, 0xfa,
    0x81, 0x40, 0xfa, 0x81, 0xfd, 0x80, 0xf5, 0x81,
    0xf2, 0x80, 0x41, 0x0c, 0x81, 0x41, 0x01, 0x0b,
    0x80, 0x40, 0x9b, 0x80, 0xd2, 0x80, 0x91, 0x80,
    0xd0, 0x80, 0x41, 0xa4, 0x80, 0x41, 0x01, 0x00,
    0x81, 0xd0, 0x80, 0x60, 0x4d, 0x57, 0x84, 0xba,
    0x86, 0x44, 0x57, 0x90, 0xcf, 0x81, 0x60, 0x3f,
    0xfd, 0x18, 0x30, 0x81, 0x5f, 0x00, 0xad, 0x81,
    0x96, 0x42, 0x1f, 0x12, 0x2f, 0x39, 0x86, 0x9d,
    0x83, 0x4f, 0x81, 0x86, 0x41, 0x76, 0x80, 0xbc,
    0x83, 0x45, 0xdf, 0x86, 0xec, 0x10, 0x82,
};

static const uint8_t unicode_prop_Extender_table[92] = {
    0x40, 0xb6, 0x80, 0x42, 0x17, 0x81, 0x43, 0x6d,
    0x80, 0x41, 0xb8, 0x80, 0x43, 0x59, 0x80, 0x42,
    0xef, 0x80, 0xfe, 0x80, 0x49, 0x42, 0x80, 0xb7,
    0x80, 0x42, 0x62, 0x80, 0x41, 0x8d, 0x80, 0xc3,
    0x80, 0x53, 0x88, 0x80, 0xaa, 0x84, 0xe6, 0x81,
    0xdc, 0x82, 0x60, 0x6f, 0x15, 0x80, 0x45, 0xf5,
    0x80, 0x43, 0xc1, 0x80, 0x95, 0x80, 0x40, 0x88,
    0x80, 0xeb, 0x80, 0x94, 0x81, 0x60, 0x54, 0x7a,
    0x80, 0x48, 0x0f, 0x81, 0x4b, 0xd9, 0x80, 0x42,
    0x67, 0x82, 0x44, 0xce, 0x80, 0x60, 0x50, 0xa8,
    0x81, 0x44, 0x9b, 0x08, 0x80, 0x60, 0x71, 0x57,
    0x81, 0x48, 0x05, 0x82,
};

static const uint8_t unicode_prop_Hex_Digit_table[12] = {
    0xaf, 0x89, 0x35, 0x99, 0x85, 0x60, 0xfe, 0xa8,
    0x89, 0x35, 0x99, 0x85,
};

static const uint8_t unicode_prop_IDS_Binary_Operator_table[5] = {
    0x60, 0x2f, 0xef, 0x09, 0x87,
};

static const uint8_t unicode_prop_IDS_Trinary_Operator_table[4] = {
    0x60, 0x2f, 0xf1, 0x81,
};

static const uint8_t unicode_prop_Ideographic_table[66] = {
    0x60, 0x30, 0x05, 0x81, 0x98, 0x88, 0x8d, 0x82,
    0x43, 0xc4, 0x59, 0xbf, 0xbf, 0x60, 0x51, 0xff,
    0x60, 0x58, 0xff, 0x41, 0x6d, 0x81, 0xe9, 0x60,
    0x75, 0x09, 0x80, 0x9a, 0x57, 0xf7, 0x87, 0x44,
    0xd5, 0xa9, 0x88, 0x60, 0x24, 0x66, 0x41, 0x8b,
    0x60, 0x4d, 0x03, 0x60, 0xa6, 0xdf, 0x9f, 0x50,
    0x38, 0x86, 0x40, 0xdd, 0x81, 0x56, 0x81, 0x8d,
    0x5d, 0x30, 0x4c, 0x1e, 0x42, 0x1d, 0x45, 0xe1,
    0x53, 0x4a,
};

static const uint8_t unicode_prop_Join_Control_table[4] = {
    0x60, 0x20, 0x0b, 0x81,
};

static const uint8_t unicode_prop_Logical_Order_Exception_table[15] = {
    0x4e, 0x3f, 0x84, 0xfa, 0x84, 0x4a, 0xef, 0x11,
    0x80, 0x60, 0x90, 0xf9, 0x09, 0x00, 0x81,
};

static const uint8_t unicode_prop_Noncharacter_Code_Point_table[71] = {
    0x60, 0xfd, 0xcf, 0x9f, 0x42, 0x0d, 0x81, 0x60,
    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,
    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,
    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,
    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,
    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,
    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,
    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81, 0x60,
    0xff, 0xfd, 0x81, 0x60, 0xff, 0xfd, 0x81,
};

static const uint8_t unicode_prop_Pattern_Syntax_table[58] = {
    0xa0, 0x8e, 0x89, 0x86, 0x99, 0x18, 0x80, 0x99,
    0x83, 0xa1, 0x30, 0x00, 0x08, 0x00, 0x0b, 0x03,
    0x02, 0x80, 0x96, 0x80, 0x9e, 0x80, 0x5f, 0x17,
    0x97, 0x87, 0x8e, 0x81, 0x92, 0x80, 0x89, 0x41,
    0x30, 0x42, 0xcf, 0x40, 0x9f, 0x42, 0x75, 0x9d,
    0x44, 0x6b, 0x41, 0xff, 0xff, 0x41, 0x80, 0x13,
    0x98, 0x8e, 0x80, 0x60, 0xcd, 0x0c, 0x81, 0x41,
    0x04, 0x81,
};

static const uint8_t unicode_prop_Pattern_White_Space_table[11] = {
    0x88, 0x84, 0x91, 0x80, 0xe3, 0x80, 0x5f, 0x87,
    0x81, 0x97, 0x81,
};

static const uint8_t unicode_prop_Quotation_Mark_table[31] = {
    0xa1, 0x03, 0x80, 0x40, 0x82, 0x80, 0x8e, 0x80,
    0x5f, 0x5b, 0x87, 0x98, 0x81, 0x4e, 0x06, 0x80,
    0x41, 0xc8, 0x83, 0x8c, 0x82, 0x60, 0xce, 0x20,
    0x83, 0x40, 0xbc, 0x03, 0x80, 0xd9, 0x81,
};

static const uint8_t unicode_prop_Radical_table[9] = {
    0x60, 0x2e, 0x7f, 0x99, 0x80, 0xd8, 0x8b, 0x40,
    0xd5,
};

static const uint8_t unicode_prop_Regional_Indicator_table[4] = {
    0x61, 0xf1, 0xe5, 0x99,
};

static const uint8_t unicode_prop_Sentence_Terminal_table[194] = {
    0xa0, 0x80, 0x8b, 0x80, 0x8f, 0x80, 0x45, 0x48,
    0x80, 0x40, 0x92, 0x82, 0x40, 0xb3, 0x80, 0xaa,
    0x82, 0x40, 0xf5, 0x80, 0xbc, 0x00, 0x02, 0x81,
    0x41, 0x24, 0x81, 0x46, 0xe3, 0x81, 0x43, 0x15,
    0x03, 0x81, 0x43, 0x04, 0x80, 0x40, 0xc5, 0x81,
    0x40, 0xcb, 0x04, 0x80, 0x41, 0x39, 0x81, 0x41,
    0x61, 0x83, 0x40, 0xad, 0x09, 0x81, 0x9c, 0x81,
    0x40, 0xbb, 0x81, 0xc0, 0x81, 0x43, 0xbb, 0x81,
    0x88, 0x82, 0x4d, 0xe3, 0x80, 0x8c, 0x80, 0x95,
    0x81, 0x41, 0xac, 0x80, 0x60, 0x74, 0xfb, 0x80,
    0x41, 0x0d, 0x81, 0x40, 0xe2, 0x02, 0x80, 0x41,
    0x7d, 0x81, 0xd5, 0x81, 0xde, 0x80, 0x40, 0x97,
    0x81, 0x40, 0x92, 0x82, 0x40, 0x8f, 0x81, 0x40,
    0xf8, 0x80, 0x60, 0x52, 0x65, 0x02, 0x81, 0x40,
    0xa8, 0x80, 0x8b, 0x80, 0x8f, 0x80, 0xc0, 0x80,
    0x4a, 0xf3, 0x81, 0x44, 0xfc, 0x84, 0xab, 0x83,
    0x40, 0xbc, 0x81, 0xf4, 0x83, 0xfe, 0x82, 0x40,
    0x80, 0x0d, 0x80, 0x8f, 0x81, 0xd7, 0x08, 0x81,
    0xeb, 0x80, 0x41, 0xa0, 0x81, 0x41, 0x74, 0x0c,
    0x8e, 0xe8, 0x81, 0x40, 0xf8, 0x82, 0x42, 0x04,
    0x00, 0x80, 0x40, 0xfa, 0x81, 0xd6, 0x81, 0x41,
    0xa3, 0x81, 0x42, 0xb3, 0x81, 0x60, 0x4b, 0x74,
    0x81, 0x40, 0x84, 0x80, 0xc0, 0x81, 0x8a, 0x80,
    0x43, 0x52, 0x80, 0x60, 0x4e, 0x05, 0x80, 0x5d,
    0xe7, 0x80,
};

static const uint8_t unicode_prop_Soft_Dotted_table[74] = {
    0xe8, 0x81, 0x40, 0xc3, 0x80, 0x41, 0x18, 0x80,
    0x9d, 0x80, 0xb3, 0x80, 0x93, 0x80, 0x41, 0x3f,
    0x80, 0xe1, 0x00, 0x80, 0x59, 0x08, 0x80, 0xb2,
    0x80, 0x8c, 0x02, 0x80, 0x40, 0x83, 0x80, 0x40,
    0x9c, 0x80, 0x41, 0xa4, 0x80, 0x40, 0xd5, 0x81,
    0x4b, 0x31, 0x80, 0x61, 0xa7, 0xa4, 0x81, 0xb1,
    0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1,
    0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1,
    0x81, 0xb1, 0x81, 0xb1, 0x81, 0xb1, 0x81, 0x48,
    0x85, 0x80,
};

static const uint8_t unicode_prop_Terminal_Punctuation_table[246] = {
    0xa0, 0x80, 0x89, 0x00, 0x80, 0x8a, 0x0a, 0x80,
    0x43, 0x3d, 0x07, 0x80, 0x42, 0x00, 0x80, 0xb8,
    0x80, 0xc7, 0x80, 0x8d, 0x00, 0x82, 0x40, 0xb3,
    0x80, 0xaa, 0x8a, 0x00, 0x40, 0xea, 0x81, 0xb5,
    0x8e, 0x9e, 0x80, 0x41, 0x04, 0x81, 0x44, 0xf3,
    0x81, 0x40, 0xab, 0x03, 0x85, 0x41, 0x36, 0x81,
    0x43, 0x14, 0x87, 0x43, 0x04, 0x80, 0xfb, 0x82,
    0xc6, 0x81, 0x40, 0x9c, 0x12, 0x80, 0xa6, 0x19,
    0x81, 0x41, 0x39, 0x81, 0x41, 0x61, 0x83, 0x40,
    0xad, 0x08, 0x82, 0x9c, 0x81, 0x40, 0xbb, 0x84,
    0xbd, 0x81, 0x43, 0xbb, 0x81, 0x88, 0x82, 0x4d,
    0xe3, 0x80, 0x8c, 0x03, 0x80, 0x89, 0x00, 0x0a,
    0x81, 0x41, 0xab, 0x81, 0x60, 0x74, 0xfa, 0x81,
    0x41, 0x0c, 0x82, 0x40, 0xe2, 0x84, 0x41, 0x7d,
    0x81, 0xd5, 0x81, 0xde, 0x80, 0x40, 0x96, 0x82,
    0x40, 0x92, 0x82, 0xfe, 0x80, 0x8f, 0x81, 0x40,
    0xf8, 0x80, 0x60, 0x52, 0x63, 0x10, 0x83, 0x40,
    0xa8, 0x80, 0x89, 0x00, 0x80, 0x8a, 0x0a, 0x80,
    0xc0, 0x01, 0x80, 0x44, 0x39, 0x80, 0xaf, 0x80,
    0x44, 0x85, 0x80, 0x40, 0xc6, 0x80, 0x41, 0x35,
    0x81, 0x40, 0x97, 0x85, 0xc3, 0x85, 0xd8, 0x83,
    0x43, 0xb7, 0x84, 0xab, 0x83, 0x40, 0xbc, 0x86,
    0xef, 0x83, 0xfe, 0x82, 0x40, 0x80, 0x0d, 0x80,
    0x8f, 0x81, 0xd7, 0x84, 0xeb, 0x80, 0x41, 0xa0,
    0x82, 0x8b, 0x81, 0x41, 0x65, 0x1a, 0x8e, 0xe8,
    0x81, 0x40, 0xf8, 0x82, 0x42, 0x04, 0x00, 0x80,
    0x40, 0xfa, 0x81, 0xd6, 0x0b, 0x81, 0x41, 0x9d,
    0x82, 0xac, 0x80, 0x42, 0x84, 0x81, 0x45, 0x76,
    0x84, 0x60, 0x45, 0xf8, 0x81, 0x40, 0x84, 0x80,
    0xc0, 0x82, 0x89, 0x80, 0x43, 0x51, 0x81, 0x60,
    0x4e, 0x05, 0x80, 0x5d, 0xe6, 0x83,
};

static const uint8_t unicode_prop_Unified_Ideograph_table[42] = {
    0x60, 0x33, 0xff, 0x59, 0xbf, 0xbf, 0x60, 0x51,
    0xff, 0x60, 0x5a, 0x0d, 0x08, 0x00, 0x81, 0x89,
    0x00, 0x00, 0x09, 0x82, 0x61, 0x05, 0xd5, 0x60,
    0xa6, 0xdf, 0x9f, 0x50, 0x38, 0x86, 0x40, 0xdd,
    0x81, 0x56, 0x81, 0x8d, 0x5d, 0x30, 0x54, 0x1e,
    0x53, 0x4a,
};

static const uint8_t unicode_prop_Variation_Selector_table[13] = {
    0x58, 0x0a, 0x10, 0x80, 0x60, 0xe5, 0xef, 0x8f,
    0x6d, 0x02, 0xef, 0x40, 0xef,
};

static const uint8_t unicode_prop_White_Space_table[22] = {
    0x88, 0x84, 0x91, 0x80, 0xe3, 0x80, 0x99, 0x80,
    0x55, 0xde, 0x80, 0x49, 0x7e, 0x8a, 0x9c, 0x0c,
    0x80, 0xae, 0x80, 0x4f, 0x9f, 0x80,
};

static const uint8_t unicode_prop_Bidi_Mirrored_table[173] = {
    0xa7, 0x81, 0x91, 0x00, 0x80, 0x9b, 0x00, 0x80,
    0x9c, 0x00, 0x80, 0xac, 0x80, 0x8e, 0x80, 0x4e,
    0x7d, 0x83, 0x47, 0x5c, 0x81, 0x49, 0x9b, 0x81,
    0x89, 0x81, 0xb5, 0x81, 0x8d, 0x81, 0x40, 0xb0,
    0x80, 0x40, 0xbf, 0x1a, 0x2a, 0x02, 0x0a, 0x18,
    0x18, 0x00, 0x03, 0x88, 0x20, 0x80, 0x91, 0x23,
    0x88, 0x08, 0x00, 0x39, 0x9e, 0x0b, 0x20, 0x88,
    0x09, 0x92, 0x21, 0x88, 0x21, 0x0b, 0x97, 0x81,
    0x8f, 0x3b, 0x93, 0x0e, 0x81, 0x44, 0x3c, 0x8d,
    0xc9, 0x01, 0x18, 0x08, 0x14, 0x1c, 0x12, 0x8d,
    0x41, 0x92, 0x95, 0x0d, 0x80, 0x8d, 0x38, 0x35,
    0x10, 0x1c, 0x01, 0x0c, 0x18, 0x02, 0x09, 0x89,
    0x29, 0x81, 0x8b, 0x92, 0x03, 0x08, 0x00, 0x08,
    0x03, 0x21, 0x2a, 0x97, 0x81, 0x8a, 0x0b, 0x18,
    0x09, 0x0b, 0xaa, 0x0f, 0x80, 0xa7, 0x20, 0x00,
    0x14, 0x22, 0x18, 0x14, 0x00, 0x40, 0xff, 0x80,
    0x42, 0x02, 0x1a, 0x08, 0x81, 0x8d, 0x09, 0x89,
    0xaa, 0x87, 0x41, 0xaa, 0x89, 0x0f, 0x60, 0xce,
    0x3c, 0x2c, 0x81, 0x40, 0xa1, 0x81, 0x91, 0x00,
    0x80, 0x9b, 0x00, 0x80, 0x9c, 0x00, 0x00, 0x08,
    0x81, 0x60, 0xd7, 0x76, 0x80, 0xb8, 0x80, 0xb8,
    0x80, 0xb8, 0x80, 0xb8, 0x80,
};

static const uint8_t unicode_prop_Emoji_table[239] = {
    0xa2, 0x05, 0x04, 0x89, 0xee, 0x03, 0x80, 0x5f,
    0x8c, 0x80, 0x8b, 0x80, 0x40, 0xd7, 0x80, 0x95,
    0x80, 0xd9, 0x85, 0x8e, 0x81, 0x41, 0x6e, 0x81,
    0x8b, 0x80, 0x40, 0xa5, 0x80, 0x98, 0x8a, 0x1a,
    0x40, 0xc6, 0x80, 0x40, 0xe6, 0x81, 0x89, 0x80,
    0x88, 0x80, 0xb9, 0x18, 0x84, 0x88, 0x01, 0x01,
    0x09, 0x03, 0x01, 0x00, 0x09, 0x02, 0x02, 0x0f,
    0x14, 0x00, 0x04, 0x8b, 0x8a, 0x09, 0x00, 0x08,
    0x80, 0x91, 0x01, 0x81, 0x91, 0x28, 0x00, 0x0a,
    0x0c, 0x01, 0x0b, 0x81, 0x8a, 0x0c, 0x09, 0x04,
    0x08, 0x00, 0x81, 0x93, 0x0c, 0x28, 0x19, 0x03,
    0x01, 0x01, 0x28, 0x01, 0x00, 0x00, 0x05, 0x02,
    0x05, 0x80, 0x89, 0x81, 0x8e, 0x01, 0x03, 0x00,
    0x03, 0x10, 0x80, 0x8a, 0x81, 0xaf, 0x82, 0x88,
    0x80, 0x8d, 0x80, 0x8d, 0x80, 0x41, 0x73, 0x81,
    0x41, 0xce, 0x82, 0x92, 0x81, 0xb2, 0x03, 0x80,
    0x44, 0xd9, 0x80, 0x8b, 0x80, 0x42, 0x58, 0x00,
    0x80, 0x61, 0xbd, 0x69, 0x80, 0x40, 0xc9, 0x80,
    0x40, 0x9f, 0x81, 0x8b, 0x81, 0x8d, 0x01, 0x89,
    0xca, 0x99, 0x01, 0x96, 0x80, 0x93, 0x01, 0x88,
    0x94, 0x81, 0x40, 0xad, 0xa1, 0x81, 0xef, 0x09,
    0x02, 0x81, 0xd2, 0x0a, 0x80, 0x41, 0x06, 0x80,
    0xbe, 0x8a, 0x28, 0x97, 0x31, 0x0f, 0x8b, 0x01,
    0x19, 0x03, 0x81, 0x8c, 0x09, 0x07, 0x81, 0x88,
    0x04, 0x82, 0x8b, 0x17, 0x11, 0x00, 0x03, 0x05,
    0x02, 0x05, 0xd5, 0xaf, 0xc5, 0x27, 0x0a, 0x84,
    0x88, 0x10, 0x01, 0x10, 0x81, 0x89, 0x40, 0xe2,
    0x8b, 0x18, 0x41, 0x1a, 0xae, 0x80, 0x89, 0x80,
    0x40, 0xb8, 0xef, 0x22, 0x22, 0x86, 0x88, 0x9c,
    0x82, 0x8a, 0x25, 0x89, 0x89, 0x2f, 0x3e,
};

static const uint8_t unicode_prop_Emoji_Component_table[28] = {
    0xa2, 0x05, 0x04, 0x89, 0x5f, 0xd2, 0x80, 0x40,
    0xd4, 0x80, 0x60, 0xdd, 0x2a, 0x80, 0x60, 0xf3,
    0xd5, 0x99, 0x41, 0xfa, 0x84, 0x45, 0xaf, 0x83,
    0x6c, 0x06, 0x6b, 0xdf,
};

static const uint8_t unicode_prop_Emoji_Modifier_table[4] = {
    0x61, 0xf3, 0xfa, 0x84,
};

static const uint8_t unicode_prop_Emoji_Modifier_Base_table[71] = {
    0x60, 0x26, 0x1c, 0x80, 0x40, 0xda, 0x80, 0x8f,
    0x83, 0x61, 0xcc, 0x76, 0x80, 0xbb, 0x11, 0x01,
    0x82, 0xf4, 0x09, 0x8a, 0x94, 0x92, 0x10, 0x1a,
    0x02, 0x30, 0x00, 0x97, 0x80, 0x40, 0xc8, 0x0b,
    0x80, 0x94, 0x03, 0x81, 0x40, 0xad, 0x12, 0x84,
    0xd2, 0x80, 0x8f, 0x82, 0x88, 0x80, 0x8a, 0x80,
    0x42, 0x3e, 0x01, 0x07, 0x3d, 0x80, 0x88, 0x89,
    0x0a, 0xb7, 0x80, 0xbc, 0x08, 0x08, 0x80, 0x90,
    0x10, 0x8c, 0x40, 0xe4, 0x82, 0xa9, 0x86,
};

static const uint8_t unicode_prop_Emoji_Presentation_table[145] = {
    0x60, 0x23, 0x19, 0x81, 0x40, 0xcc, 0x1a, 0x01,
    0x80, 0x42, 0x08, 0x81, 0x94, 0x81, 0xb1, 0x8b,
    0xaa, 0x80, 0x92, 0x80, 0x8c, 0x07, 0x81, 0x90,
    0x0c, 0x0f, 0x04, 0x80, 0x94, 0x06, 0x08, 0x03,
    0x01, 0x06, 0x03, 0x81, 0x9b, 0x80, 0xa2, 0x00,
    0x03, 0x10, 0x80, 0xbc, 0x82, 0x97, 0x80, 0x8d,
    0x80, 0x43, 0x5a, 0x81, 0xb2, 0x03, 0x80, 0x61,
    0xc4, 0xad, 0x80, 0x40, 0xc9, 0x80, 0x40, 0xbd,
    0x01, 0x89, 0xca, 0x99, 0x00, 0x97, 0x80, 0x93,
    0x01, 0x20, 0x82, 0x94, 0x81, 0x40, 0xad, 0xa0,
    0x8b, 0x88, 0x80, 0xc5, 0x80, 0x95, 0x8b, 0xaa,
    0x1c, 0x8b, 0x90, 0x10, 0x82, 0xc6, 0x00, 0x80,
    0x40, 0xba, 0x81, 0xbe, 0x8c, 0x18, 0x97, 0x91,
    0x80, 0x99, 0x81, 0x8c, 0x80, 0xd5, 0xd4, 0xaf,
    0xc5, 0x28, 0x12, 0x0a, 0x22, 0x8a, 0x0e, 0x88,
    0x40, 0xe2, 0x8b, 0x18, 0x41, 0x1a, 0xae, 0x80,
    0x89, 0x80, 0x40, 0xb8, 0xef, 0x22, 0x22, 0x86,
    0x88, 0x9c, 0x82, 0x8a, 0x25, 0x89, 0x89, 0x2f,
    0x3e,
};

static const uint8_t unicode_prop_Extended_Pictographic_table[156] = {
    0x40, 0xa8, 0x03, 0x80, 0x5f, 0x8c, 0x80, 0x8b,
    0x80, 0x40, 0xd7, 0x80, 0x95, 0x80, 0xd9, 0x85,
    0x8e, 0x81, 0x41, 0x6e, 0x81, 0x8b, 0x80, 0xde,
    0x80, 0xc5, 0x80, 0x98, 0x8a, 0x1a, 0x40, 0xc6,
    0x80, 0x40, 0xe6, 0x81, 0x89, 0x80, 0x88, 0x80,
    0xb9, 0x18, 0x28, 0x8b, 0x80, 0xf1, 0x89, 0xf5,
    0x81, 0x8a, 0x00, 0x00, 0x28, 0x10, 0x28, 0x89,
    0x81, 0x8e, 0x01, 0x03, 0x00, 0x03, 0x10, 0x80,
    0x8a, 0x84, 0xac, 0x82, 0x88, 0x80, 0x8d, 0x80,
    0x8d, 0x80, 0x41, 0x73, 0x81, 0x41, 0xce, 0x82,
    0x92, 0x81, 0xb2, 0x03, 0x80, 0x44, 0xd9, 0x80,
    0x8b, 0x80, 0x42, 0x58, 0x00, 0x80, 0x61, 0xbd,
    0x65, 0x40, 0xff, 0x8c, 0x82, 0x9e, 0x80, 0xbb,
    0x85, 0x8b, 0x81, 0x8d, 0x01, 0x89, 0x91, 0xb8,
    0x9a, 0x8e, 0x89, 0x80, 0x93, 0x01, 0x88, 0x03,
    0x88, 0x41, 0xb1, 0x84, 0x41, 0x3d, 0x87, 0x41,
    0x09, 0xaf, 0xff, 0xf3, 0x8b, 0xd4, 0xaa, 0x8b,
    0x83, 0xb7, 0x87, 0x89, 0x85, 0xa7, 0x87, 0x9d,
    0xd1, 0x8b, 0xae, 0x80, 0x89, 0x80, 0x41, 0xb8,
    0x40, 0xff, 0x43, 0xfd,
};

static const uint8_t unicode_prop_Default_Ignorable_Code_Point_table[51] = {
    0x40, 0xac, 0x80, 0x42, 0xa0, 0x80, 0x42, 0xcb,
    0x80, 0x4b, 0x41, 0x81, 0x46, 0x52, 0x81, 0xd4,
    0x84, 0x47, 0xfa, 0x84, 0x99, 0x84, 0xb0, 0x8f,
    0x50, 0xf3, 0x80, 0x60, 0xcc, 0x9a, 0x8f, 0x40,
    0xee, 0x80, 0x40, 0x9f, 0x80, 0xce, 0x88, 0x60,
    0xbc, 0xa6, 0x83, 0x54, 0xce, 0x87, 0x6c, 0x2e,
    0x84, 0x4f, 0xff,
};

typedef enum {
    UNICODE_PROP_Hyphen,
    UNICODE_PROP_Other_Math,
    UNICODE_PROP_Other_Alphabetic,
    UNICODE_PROP_Other_Lowercase,
    UNICODE_PROP_Other_Uppercase,
    UNICODE_PROP_Other_Grapheme_Extend,
    UNICODE_PROP_Other_Default_Ignorable_Code_Point,
    UNICODE_PROP_Other_ID_Start,
    UNICODE_PROP_Other_ID_Continue,
    UNICODE_PROP_Prepended_Concatenation_Mark,
    UNICODE_PROP_ID_Continue1,
    UNICODE_PROP_XID_Start1,
    UNICODE_PROP_XID_Continue1,
    UNICODE_PROP_Changes_When_Titlecased1,
    UNICODE_PROP_Changes_When_Casefolded1,
    UNICODE_PROP_Changes_When_NFKC_Casefolded1,
    UNICODE_PROP_ASCII_Hex_Digit,
    UNICODE_PROP_Bidi_Control,
    UNICODE_PROP_Dash,
    UNICODE_PROP_Deprecated,
    UNICODE_PROP_Diacritic,
    UNICODE_PROP_Extender,
    UNICODE_PROP_Hex_Digit,
    UNICODE_PROP_IDS_Binary_Operator,
    UNICODE_PROP_IDS_Trinary_Operator,
    UNICODE_PROP_Ideographic,
    UNICODE_PROP_Join_Control,
    UNICODE_PROP_Logical_Order_Exception,
    UNICODE_PROP_Noncharacter_Code_Point,
    UNICODE_PROP_Pattern_Syntax,
    UNICODE_PROP_Pattern_White_Space,
    UNICODE_PROP_Quotation_Mark,
    UNICODE_PROP_Radical,
    UNICODE_PROP_Regional_Indicator,
    UNICODE_PROP_Sentence_Terminal,
    UNICODE_PROP_Soft_Dotted,
    UNICODE_PROP_Terminal_Punctuation,
    UNICODE_PROP_Unified_Ideograph,
    UNICODE_PROP_Variation_Selector,
    UNICODE_PROP_White_Space,
    UNICODE_PROP_Bidi_Mirrored,
    UNICODE_PROP_Emoji,
    UNICODE_PROP_Emoji_Component,
    UNICODE_PROP_Emoji_Modifier,
    UNICODE_PROP_Emoji_Modifier_Base,
    UNICODE_PROP_Emoji_Presentation,
    UNICODE_PROP_Extended_Pictographic,
    UNICODE_PROP_Default_Ignorable_Code_Point,
    UNICODE_PROP_ID_Start,
    UNICODE_PROP_Case_Ignorable,
    UNICODE_PROP_ASCII,
    UNICODE_PROP_Alphabetic,
    UNICODE_PROP_Any,
    UNICODE_PROP_Assigned,
    UNICODE_PROP_Cased,
    UNICODE_PROP_Changes_When_Casefolded,
    UNICODE_PROP_Changes_When_Casemapped,
    UNICODE_PROP_Changes_When_Lowercased,
    UNICODE_PROP_Changes_When_NFKC_Casefolded,
    UNICODE_PROP_Changes_When_Titlecased,
    UNICODE_PROP_Changes_When_Uppercased,
    UNICODE_PROP_Grapheme_Base,
    UNICODE_PROP_Grapheme_Extend,
    UNICODE_PROP_ID_Continue,
    UNICODE_PROP_Lowercase,
    UNICODE_PROP_Math,
    UNICODE_PROP_Uppercase,
    UNICODE_PROP_XID_Continue,
    UNICODE_PROP_XID_Start,
    UNICODE_PROP_Cased1,
    UNICODE_PROP_COUNT,
} UnicodePropertyEnum;

static const char unicode_prop_name_table[] =
    "ASCII_Hex_Digit,AHex"               "\0"
    "Bidi_Control,Bidi_C"                "\0"
    "Dash"                               "\0"
    "Deprecated,Dep"                     "\0"
    "Diacritic,Dia"                      "\0"
    "Extender,Ext"                       "\0"
    "Hex_Digit,Hex"                      "\0"
    "IDS_Binary_Operator,IDSB"           "\0"
    "IDS_Trinary_Operator,IDST"          "\0"
    "Ideographic,Ideo"                   "\0"
    "Join_Control,Join_C"                "\0"
    "Logical_Order_Exception,LOE"        "\0"
    "Noncharacter_Code_Point,NChar"      "\0"
    "Pattern_Syntax,Pat_Syn"             "\0"
    "Pattern_White_Space,Pat_WS"         "\0"
    "Quotation_Mark,QMark"               "\0"
    "Radical"                            "\0"
    "Regional_Indicator,RI"              "\0"
    "Sentence_Terminal,STerm"            "\0"
    "Soft_Dotted,SD"                     "\0"
    "Terminal_Punctuation,Term"          "\0"
    "Unified_Ideograph,UIdeo"            "\0"
    "Variation_Selector,VS"              "\0"
    "White_Space,space"                  "\0"
    "Bidi_Mirrored,Bidi_M"               "\0"
    "Emoji"                              "\0"
    "Emoji_Component,EComp"              "\0"
    "Emoji_Modifier,EMod"                "\0"
    "Emoji_Modifier_Base,EBase"          "\0"
    "Emoji_Presentation,EPres"           "\0"
    "Extended_Pictographic,ExtPict"      "\0"
    "Default_Ignorable_Code_Point,DI"    "\0"
    "ID_Start,IDS"                       "\0"
    "Case_Ignorable,CI"                  "\0"
    "ASCII"                              "\0"
    "Alphabetic,Alpha"                   "\0"
    "Any"                                "\0"
    "Assigned"                           "\0"
    "Cased"                              "\0"
    "Changes_When_Casefolded,CWCF"       "\0"
    "Changes_When_Casemapped,CWCM"       "\0"
    "Changes_When_Lowercased,CWL"        "\0"
    "Changes_When_NFKC_Casefolded,CWKCF" "\0"
    "Changes_When_Titlecased,CWT"        "\0"
    "Changes_When_Uppercased,CWU"        "\0"
    "Grapheme_Base,Gr_Base"              "\0"
    "Grapheme_Extend,Gr_Ext"             "\0"
    "ID_Continue,IDC"                    "\0"
    "Lowercase,Lower"                    "\0"
    "Math"                               "\0"
    "Uppercase,Upper"                    "\0"
    "XID_Continue,XIDC"                  "\0"
    "XID_Start,XIDS"                     "\0"
;

static const uint8_t * const unicode_prop_table[] = {
    unicode_prop_Hyphen_table,
    unicode_prop_Other_Math_table,
    unicode_prop_Other_Alphabetic_table,
    unicode_prop_Other_Lowercase_table,
    unicode_prop_Other_Uppercase_table,
    unicode_prop_Other_Grapheme_Extend_table,
    unicode_prop_Other_Default_Ignorable_Code_Point_table,
    unicode_prop_Other_ID_Start_table,
    unicode_prop_Other_ID_Continue_table,
    unicode_prop_Prepended_Concatenation_Mark_table,
    unicode_prop_ID_Continue1_table,
    unicode_prop_XID_Start1_table,
    unicode_prop_XID_Continue1_table,
    unicode_prop_Changes_When_Titlecased1_table,
    unicode_prop_Changes_When_Casefolded1_table,
    unicode_prop_Changes_When_NFKC_Casefolded1_table,
    unicode_prop_ASCII_Hex_Digit_table,
    unicode_prop_Bidi_Control_table,
    unicode_prop_Dash_table,
    unicode_prop_Deprecated_table,
    unicode_prop_Diacritic_table,
    unicode_prop_Extender_table,
    unicode_prop_Hex_Digit_table,
    unicode_prop_IDS_Binary_Operator_table,
    unicode_prop_IDS_Trinary_Operator_table,
    unicode_prop_Ideographic_table,
    unicode_prop_Join_Control_table,
    unicode_prop_Logical_Order_Exception_table,
    unicode_prop_Noncharacter_Code_Point_table,
    unicode_prop_Pattern_Syntax_table,
    unicode_prop_Pattern_White_Space_table,
    unicode_prop_Quotation_Mark_table,
    unicode_prop_Radical_table,
    unicode_prop_Regional_Indicator_table,
    unicode_prop_Sentence_Terminal_table,
    unicode_prop_Soft_Dotted_table,
    unicode_prop_Terminal_Punctuation_table,
    unicode_prop_Unified_Ideograph_table,
    unicode_prop_Variation_Selector_table,
    unicode_prop_White_Space_table,
    unicode_prop_Bidi_Mirrored_table,
    unicode_prop_Emoji_table,
    unicode_prop_Emoji_Component_table,
    unicode_prop_Emoji_Modifier_table,
    unicode_prop_Emoji_Modifier_Base_table,
    unicode_prop_Emoji_Presentation_table,
    unicode_prop_Extended_Pictographic_table,
    unicode_prop_Default_Ignorable_Code_Point_table,
    unicode_prop_ID_Start_table,
    unicode_prop_Case_Ignorable_table,
};

static const uint16_t unicode_prop_len_table[] = {
    countof(unicode_prop_Hyphen_table),
    countof(unicode_prop_Other_Math_table),
    countof(unicode_prop_Other_Alphabetic_table),
    countof(unicode_prop_Other_Lowercase_table),
    countof(unicode_prop_Other_Uppercase_table),
    countof(unicode_prop_Other_Grapheme_Extend_table),
    countof(unicode_prop_Other_Default_Ignorable_Code_Point_table),
    countof(unicode_prop_Other_ID_Start_table),
    countof(unicode_prop_Other_ID_Continue_table),
    countof(unicode_prop_Prepended_Concatenation_Mark_table),
    countof(unicode_prop_ID_Continue1_table),
    countof(unicode_prop_XID_Start1_table),
    countof(unicode_prop_XID_Continue1_table),
    countof(unicode_prop_Changes_When_Titlecased1_table),
    countof(unicode_prop_Changes_When_Casefolded1_table),
    countof(unicode_prop_Changes_When_NFKC_Casefolded1_table),
    countof(unicode_prop_ASCII_Hex_Digit_table),
    countof(unicode_prop_Bidi_Control_table),
    countof(unicode_prop_Dash_table),
    countof(unicode_prop_Deprecated_table),
    countof(unicode_prop_Diacritic_table),
    countof(unicode_prop_Extender_table),
    countof(unicode_prop_Hex_Digit_table),
    countof(unicode_prop_IDS_Binary_Operator_table),
    countof(unicode_prop_IDS_Trinary_Operator_table),
    countof(unicode_prop_Ideographic_table),
    countof(unicode_prop_Join_Control_table),
    countof(unicode_prop_Logical_Order_Exception_table),
    countof(unicode_prop_Noncharacter_Code_Point_table),
    countof(unicode_prop_Pattern_Syntax_table),
    countof(unicode_prop_Pattern_White_Space_table),
    countof(unicode_prop_Quotation_Mark_table),
    countof(unicode_prop_Radical_table),
    countof(unicode_prop_Regional_Indicator_table),
    countof(unicode_prop_Sentence_Terminal_table),
    countof(unicode_prop_Soft_Dotted_table),
    countof(unicode_prop_Terminal_Punctuation_table),
    countof(unicode_prop_Unified_Ideograph_table),
    countof(unicode_prop_Variation_Selector_table),
    countof(unicode_prop_White_Space_table),
    countof(unicode_prop_Bidi_Mirrored_table),
    countof(unicode_prop_Emoji_table),
    countof(unicode_prop_Emoji_Component_table),
    countof(unicode_prop_Emoji_Modifier_table),
    countof(unicode_prop_Emoji_Modifier_Base_table),
    countof(unicode_prop_Emoji_Presentation_table),
    countof(unicode_prop_Extended_Pictographic_table),
    countof(unicode_prop_Default_Ignorable_Code_Point_table),
    countof(unicode_prop_ID_Start_table),
    countof(unicode_prop_Case_Ignorable_table),
};

#endif /* CONFIG_ALL_UNICODE */

'''
'''--- libunicode.c ---
/*
 * Unicode utilities
 * 
 * Copyright (c) 2017-2018 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>
#include <assert.h>

#include "cutils.h"
#include "libunicode.h"
#include "libunicode-table.h"

enum {
    RUN_TYPE_U,
    RUN_TYPE_L,
    RUN_TYPE_UF,
    RUN_TYPE_LF,
    RUN_TYPE_UL,
    RUN_TYPE_LSU,
    RUN_TYPE_U2L_399_EXT2,
    RUN_TYPE_UF_D20,
    RUN_TYPE_UF_D1_EXT,
    RUN_TYPE_U_EXT,
    RUN_TYPE_LF_EXT,
    RUN_TYPE_U_EXT2,
    RUN_TYPE_L_EXT2,
    RUN_TYPE_U_EXT3,
};

/* conv_type:
   0 = to upper 
   1 = to lower
   2 = case folding (= to lower with modifications) 
*/
int lre_case_conv(uint32_t *res, uint32_t c, int conv_type)
{
    if (c < 128) {
        if (conv_type) {
            if (c >= 'A' && c <= 'Z') {
                c = c - 'A' + 'a';
            }
        } else {
            if (c >= 'a' && c <= 'z') {
                c = c - 'a' + 'A';
            }
        }
    } else {
        uint32_t v, code, data, type, len, a, is_lower;
        int idx, idx_min, idx_max;
        
        is_lower = (conv_type != 0);
        idx_min = 0;
        idx_max = countof(case_conv_table1) - 1;
        while (idx_min <= idx_max) {
            idx = (unsigned)(idx_max + idx_min) / 2;
            v = case_conv_table1[idx];
            code = v >> (32 - 17);
            len = (v >> (32 - 17 - 7)) & 0x7f;
            if (c < code) {
                idx_max = idx - 1;
            } else if (c >= code + len) {
                idx_min = idx + 1;
            } else {
                type = (v >> (32 - 17 - 7 - 4)) & 0xf;
                data = ((v & 0xf) << 8) | case_conv_table2[idx];
                switch(type) {
                case RUN_TYPE_U:
                case RUN_TYPE_L:
                case RUN_TYPE_UF:
                case RUN_TYPE_LF:
                    if (conv_type == (type & 1) ||
                        (type >= RUN_TYPE_UF && conv_type == 2)) {
                        c = c - code + (case_conv_table1[data] >> (32 - 17));
                    }
                    break;
                case RUN_TYPE_UL:
                    a = c - code;
                    if ((a & 1) != (1 - is_lower))
                        break;
                    c = (a ^ 1) + code;
                    break;
                case RUN_TYPE_LSU:
                    a = c - code;
                    if (a == 1) {
                        c += 2 * is_lower - 1;
                    } else if (a == (1 - is_lower) * 2) {
                        c += (2 * is_lower - 1) * 2;
                    }
                    break;
                case RUN_TYPE_U2L_399_EXT2:
                    if (!is_lower) {
                        res[0] = c - code + case_conv_ext[data >> 6];
                        res[1] = 0x399;
                        return 2;
                    } else {
                        c = c - code + case_conv_ext[data & 0x3f];
                    }
                    break;
                case RUN_TYPE_UF_D20:
                    if (conv_type == 1)
                        break;
                    c = data + (conv_type == 2) * 0x20;
                    break;
                case RUN_TYPE_UF_D1_EXT:
                    if (conv_type == 1)
                        break;
                    c = case_conv_ext[data] + (conv_type == 2);
                    break;
                case RUN_TYPE_U_EXT:
                case RUN_TYPE_LF_EXT:
                    if (is_lower != (type - RUN_TYPE_U_EXT))
                        break;
                    c = case_conv_ext[data];
                    break;
                case RUN_TYPE_U_EXT2:
                case RUN_TYPE_L_EXT2:
                    if (conv_type != (type - RUN_TYPE_U_EXT2))
                        break;
                    res[0] = c - code + case_conv_ext[data >> 6];
                    res[1] = case_conv_ext[data & 0x3f];
                    return 2;
                default:
                case RUN_TYPE_U_EXT3:
                    if (conv_type != 0)
                        break;
                    res[0] = case_conv_ext[data >> 8];
                    res[1] = case_conv_ext[(data >> 4) & 0xf];
                    res[2] = case_conv_ext[data & 0xf];
                    return 3;
                }
                break;
            }
        }
    }
    res[0] = c;
    return 1;
}

static uint32_t get_le24(const uint8_t *ptr)
{
#if defined(__x86__) || defined(__x86_64__)
    return *(uint16_t *)ptr | (ptr[2] << 16);
#else
    return ptr[0] | (ptr[1] << 8) | (ptr[2] << 16);
#endif
}

#define UNICODE_INDEX_BLOCK_LEN 32

/* return -1 if not in table, otherwise the offset in the block */
static int get_index_pos(uint32_t *pcode, uint32_t c,
                         const uint8_t *index_table, int index_table_len)
{
    uint32_t code, v;
    int idx_min, idx_max, idx;

    idx_min = 0;
    v = get_le24(index_table);
    code = v & ((1 << 21) - 1);
    if (c < code) {
        *pcode = 0;
        return 0;
    }
    idx_max = index_table_len - 1;
    code = get_le24(index_table + idx_max * 3);
    if (c >= code)
        return -1;
    /* invariant: tab[idx_min] <= c < tab2[idx_max] */
    while ((idx_max - idx_min) > 1) {
        idx = (idx_max + idx_min) / 2;
        v = get_le24(index_table + idx * 3);
        code = v & ((1 << 21) - 1);
        if (c < code) {
            idx_max = idx;
        } else {
            idx_min = idx;
        }
    }
    v = get_le24(index_table + idx_min * 3);
    *pcode = v & ((1 << 21) - 1);
    return (idx_min + 1) * UNICODE_INDEX_BLOCK_LEN + (v >> 21);
}

static BOOL lre_is_in_table(uint32_t c, const uint8_t *table,
                            const uint8_t *index_table, int index_table_len)
{
    uint32_t code, b, bit;
    int pos;
    const uint8_t *p;
    
    pos = get_index_pos(&code, c, index_table, index_table_len);
    if (pos < 0)
        return FALSE; /* outside the table */
    p = table + pos;
    bit = 0;
    for(;;) {
        b = *p++;
        if (b < 64) {
            code += (b >> 3) + 1;
            if (c < code)
                return bit;
            bit ^= 1;
            code += (b & 7) + 1;
        } else if (b >= 0x80) {
            code += b - 0x80 + 1;
        } else if (b < 0x60) {
            code += (((b - 0x40) << 8) | p[0]) + 1;
            p++;
        } else {
            code += (((b - 0x60) << 16) | (p[0] << 8) | p[1]) + 1;
            p += 2;
        }
        if (c < code)
            return bit;
        bit ^= 1;
    }
}

BOOL lre_is_cased(uint32_t c)
{
    uint32_t v, code, len;
    int idx, idx_min, idx_max;
        
    idx_min = 0;
    idx_max = countof(case_conv_table1) - 1;
    while (idx_min <= idx_max) {
        idx = (unsigned)(idx_max + idx_min) / 2;
        v = case_conv_table1[idx];
        code = v >> (32 - 17);
        len = (v >> (32 - 17 - 7)) & 0x7f;
        if (c < code) {
            idx_max = idx - 1;
        } else if (c >= code + len) {
            idx_min = idx + 1;
        } else {
            return TRUE;
        }
    }
    return lre_is_in_table(c, unicode_prop_Cased1_table,
                           unicode_prop_Cased1_index,
                           sizeof(unicode_prop_Cased1_index) / 3);
}

BOOL lre_is_case_ignorable(uint32_t c)
{
    return lre_is_in_table(c, unicode_prop_Case_Ignorable_table,
                           unicode_prop_Case_Ignorable_index,
                           sizeof(unicode_prop_Case_Ignorable_index) / 3);
}

/* character range */

static __maybe_unused void cr_dump(CharRange *cr)
{
    int i;
    for(i = 0; i < cr->len; i++)
        printf("%d: 0x%04x\n", i, cr->points[i]);
}

static void *cr_default_realloc(void *opaque, void *ptr, size_t size)
{
    return realloc(ptr, size);
}

void cr_init(CharRange *cr, void *mem_opaque, DynBufReallocFunc *realloc_func)
{
    cr->len = cr->size = 0;
    cr->points = NULL;
    cr->mem_opaque = mem_opaque;
    cr->realloc_func = realloc_func ? realloc_func : cr_default_realloc;
}

void cr_free(CharRange *cr)
{
    cr->realloc_func(cr->mem_opaque, cr->points, 0);
}

int cr_realloc(CharRange *cr, int size)
{
    int new_size;
    uint32_t *new_buf;
    
    if (size > cr->size) {
        new_size = max_int(size, cr->size * 3 / 2);
        new_buf = cr->realloc_func(cr->mem_opaque, cr->points,
                                   new_size * sizeof(cr->points[0]));
        if (!new_buf)
            return -1;
        cr->points = new_buf;
        cr->size = new_size;
    }
    return 0;
}

int cr_copy(CharRange *cr, const CharRange *cr1)
{
    if (cr_realloc(cr, cr1->len))
        return -1;
    memcpy(cr->points, cr1->points, sizeof(cr->points[0]) * cr1->len);
    cr->len = cr1->len;
    return 0;
}

/* merge consecutive intervals and remove empty intervals */
static void cr_compress(CharRange *cr)
{
    int i, j, k, len;
    uint32_t *pt;
    
    pt = cr->points;
    len = cr->len;
    i = 0;
    j = 0;
    k = 0;
    while ((i + 1) < len) {
        if (pt[i] == pt[i + 1]) {
            /* empty interval */
            i += 2;
        } else {
            j = i;
            while ((j + 3) < len && pt[j + 1] == pt[j + 2])
                j += 2;
            /* just copy */
            pt[k] = pt[i];
            pt[k + 1] = pt[j + 1];
            k += 2;
            i = j + 2;
        }
    }
    cr->len = k;
}

/* union or intersection */
int cr_op(CharRange *cr, const uint32_t *a_pt, int a_len,
          const uint32_t *b_pt, int b_len, int op)
{
    int a_idx, b_idx, is_in;
    uint32_t v;
    
    a_idx = 0;
    b_idx = 0;
    for(;;) {
        /* get one more point from a or b in increasing order */
        if (a_idx < a_len && b_idx < b_len) {
            if (a_pt[a_idx] < b_pt[b_idx]) {
                goto a_add;
            } else if (a_pt[a_idx] == b_pt[b_idx]) {
                v = a_pt[a_idx];
                a_idx++;
                b_idx++;
            } else {
                goto b_add;
            }
        } else if (a_idx < a_len) {
        a_add:
            v = a_pt[a_idx++];
        } else if (b_idx < b_len) {
        b_add:
            v = b_pt[b_idx++];
        } else {
            break;
        }
        /* add the point if the in/out status changes */
        switch(op) {
        case CR_OP_UNION:
            is_in = (a_idx & 1) | (b_idx & 1);
            break;
        case CR_OP_INTER:
            is_in = (a_idx & 1) & (b_idx & 1);
            break;
        case CR_OP_XOR:
            is_in = (a_idx & 1) ^ (b_idx & 1);
            break;
        default:
            abort();
        }
        if (is_in != (cr->len & 1)) {
            if (cr_add_point(cr, v))
                return -1;
        }
    }
    cr_compress(cr);
    return 0;
}

int cr_union1(CharRange *cr, const uint32_t *b_pt, int b_len)
{
    CharRange a = *cr;
    int ret;
    cr->len = 0;
    cr->size = 0;
    cr->points = NULL;
    ret = cr_op(cr, a.points, a.len, b_pt, b_len, CR_OP_UNION);
    cr_free(&a);
    return ret;
}

int cr_invert(CharRange *cr)
{
    int len;
    len = cr->len;
    if (cr_realloc(cr, len + 2))
        return -1;
    memmove(cr->points + 1, cr->points, len * sizeof(cr->points[0]));
    cr->points[0] = 0;
    cr->points[len + 1] = UINT32_MAX;
    cr->len = len + 2;
    cr_compress(cr);
    return 0;
}

#ifdef CONFIG_ALL_UNICODE

BOOL lre_is_id_start(uint32_t c)
{
    return lre_is_in_table(c, unicode_prop_ID_Start_table,
                           unicode_prop_ID_Start_index,
                           sizeof(unicode_prop_ID_Start_index) / 3);
}

BOOL lre_is_id_continue(uint32_t c)
{
    return lre_is_id_start(c) ||
        lre_is_in_table(c, unicode_prop_ID_Continue1_table,
                        unicode_prop_ID_Continue1_index,
                        sizeof(unicode_prop_ID_Continue1_index) / 3);
}

#define UNICODE_DECOMP_LEN_MAX 18

typedef enum {
    DECOMP_TYPE_C1, /* 16 bit char */
    DECOMP_TYPE_L1, /* 16 bit char table */
    DECOMP_TYPE_L2,
    DECOMP_TYPE_L3,
    DECOMP_TYPE_L4,
    DECOMP_TYPE_L5, /* XXX: not used */
    DECOMP_TYPE_L6, /* XXX: could remove */
    DECOMP_TYPE_L7, /* XXX: could remove */
    DECOMP_TYPE_LL1, /* 18 bit char table */
    DECOMP_TYPE_LL2,
    DECOMP_TYPE_S1, /* 8 bit char table */
    DECOMP_TYPE_S2,
    DECOMP_TYPE_S3,
    DECOMP_TYPE_S4,
    DECOMP_TYPE_S5,
    DECOMP_TYPE_I1, /* increment 16 bit char value */
    DECOMP_TYPE_I2_0,
    DECOMP_TYPE_I2_1,
    DECOMP_TYPE_I3_1,
    DECOMP_TYPE_I3_2,
    DECOMP_TYPE_I4_1,
    DECOMP_TYPE_I4_2,
    DECOMP_TYPE_B1, /* 16 bit base + 8 bit offset */
    DECOMP_TYPE_B2,
    DECOMP_TYPE_B3,
    DECOMP_TYPE_B4,
    DECOMP_TYPE_B5,
    DECOMP_TYPE_B6,
    DECOMP_TYPE_B7,
    DECOMP_TYPE_B8,
    DECOMP_TYPE_B18,
    DECOMP_TYPE_LS2,
    DECOMP_TYPE_PAT3,
    DECOMP_TYPE_S2_UL,
    DECOMP_TYPE_LS2_UL,
} DecompTypeEnum;

static uint32_t unicode_get_short_code(uint32_t c)
{
    static const uint16_t unicode_short_table[2] = { 0x2044, 0x2215 };

    if (c < 0x80)
        return c;
    else if (c < 0x80 + 0x50)
        return c - 0x80 + 0x300;
    else
        return unicode_short_table[c - 0x80 - 0x50];
}

static uint32_t unicode_get_lower_simple(uint32_t c)
{
    if (c < 0x100 || (c >= 0x410 && c <= 0x42f))
        c += 0x20;
    else
        c++;
    return c;
}

static uint16_t unicode_get16(const uint8_t *p)
{
    return p[0] | (p[1] << 8);
}

static int unicode_decomp_entry(uint32_t *res, uint32_t c,
                                int idx, uint32_t code, uint32_t len,
                                uint32_t type)
{
    uint32_t c1;
    int l, i, p;
    const uint8_t *d;

    if (type == DECOMP_TYPE_C1) {
        res[0] = unicode_decomp_table2[idx];
        return 1;
    } else {
        d = unicode_decomp_data + unicode_decomp_table2[idx];
        switch(type) {
        case DECOMP_TYPE_L1:
        case DECOMP_TYPE_L2:
        case DECOMP_TYPE_L3:
        case DECOMP_TYPE_L4:
        case DECOMP_TYPE_L5:
        case DECOMP_TYPE_L6:
        case DECOMP_TYPE_L7:
            l = type - DECOMP_TYPE_L1 + 1;
            d += (c - code) * l * 2;
            for(i = 0; i < l; i++) {
                if ((res[i] = unicode_get16(d + 2 * i)) == 0)
                    return 0;
            }
            return l;
        case DECOMP_TYPE_LL1:
        case DECOMP_TYPE_LL2:
            {
                uint32_t k, p;
                l = type - DECOMP_TYPE_LL1 + 1;
                k = (c - code) * l;
                p = len * l * 2;
                for(i = 0; i < l; i++) {
                    c1 = unicode_get16(d + 2 * k) |
                        (((d[p + (k / 4)] >> ((k % 4) * 2)) & 3) << 16);
                    if (!c1)
                        return 0;
                    res[i] = c1;
                    k++;
                }
            }
            return l;
        case DECOMP_TYPE_S1:
        case DECOMP_TYPE_S2:
        case DECOMP_TYPE_S3:
        case DECOMP_TYPE_S4:
        case DECOMP_TYPE_S5:
            l = type - DECOMP_TYPE_S1 + 1;
            d += (c - code) * l;
            for(i = 0; i < l; i++) {
                if ((res[i] = unicode_get_short_code(d[i])) == 0)
                    return 0;
            }
            return l;
        case DECOMP_TYPE_I1:
            l = 1;
            p = 0;
            goto decomp_type_i;
        case DECOMP_TYPE_I2_0:
        case DECOMP_TYPE_I2_1:
        case DECOMP_TYPE_I3_1:
        case DECOMP_TYPE_I3_2:
        case DECOMP_TYPE_I4_1:
        case DECOMP_TYPE_I4_2:
            l = 2 + ((type - DECOMP_TYPE_I2_0) >> 1);
            p = ((type - DECOMP_TYPE_I2_0) & 1) + (l > 2);
        decomp_type_i:
            for(i = 0; i < l; i++) {
                c1 = unicode_get16(d + 2 * i);
                if (i == p)
                    c1 += c - code;
                res[i] = c1;
            }
            return l;
        case DECOMP_TYPE_B18:
            l = 18;
            goto decomp_type_b;
        case DECOMP_TYPE_B1:
        case DECOMP_TYPE_B2:
        case DECOMP_TYPE_B3:
        case DECOMP_TYPE_B4:
        case DECOMP_TYPE_B5:
        case DECOMP_TYPE_B6:
        case DECOMP_TYPE_B7:
        case DECOMP_TYPE_B8:
            l = type - DECOMP_TYPE_B1 + 1;
        decomp_type_b:
            {
                uint32_t c_min;
                c_min = unicode_get16(d);
                d += 2 + (c - code) * l;
                for(i = 0; i < l; i++) {
                    c1 = d[i];
                    if (c1 == 0xff)
                        c1 = 0x20;
                    else
                        c1 += c_min;
                    res[i] = c1;
                }
            }
            return l;
        case DECOMP_TYPE_LS2:
            d += (c - code) * 3;
            if (!(res[0] = unicode_get16(d)))
                return 0;
            res[1] = unicode_get_short_code(d[2]);
            return 2;
        case DECOMP_TYPE_PAT3:
            res[0] = unicode_get16(d);
            res[2] = unicode_get16(d + 2);
            d += 4 + (c - code) * 2;
            res[1] = unicode_get16(d);
            return 3;
        case DECOMP_TYPE_S2_UL:
        case DECOMP_TYPE_LS2_UL:
            c1 = c - code;
            if (type == DECOMP_TYPE_S2_UL) {
                d += c1 & ~1;
                c = unicode_get_short_code(*d);
                d++;
            } else {
                d += (c1 >> 1) * 3;
                c = unicode_get16(d);
                d += 2;
            }
            if (c1 & 1)
                c = unicode_get_lower_simple(c);
            res[0] = c;
            res[1] = unicode_get_short_code(*d);
            return 2;
        }
    }
    return 0;
}

/* return the length of the decomposition (length <=
   UNICODE_DECOMP_LEN_MAX) or 0 if no decomposition */
static int unicode_decomp_char(uint32_t *res, uint32_t c, BOOL is_compat1)
{
    uint32_t v, type, is_compat, code, len;
    int idx_min, idx_max, idx;
    
    idx_min = 0;
    idx_max = countof(unicode_decomp_table1) - 1;
    while (idx_min <= idx_max) {
        idx = (idx_max + idx_min) / 2;
        v = unicode_decomp_table1[idx];
        code = v >> (32 - 18);
        len = (v >> (32 - 18 - 7)) & 0x7f;
        //        printf("idx=%d code=%05x len=%d\n", idx, code, len);
        if (c < code) {
            idx_max = idx - 1;
        } else if (c >= code + len) {
            idx_min = idx + 1;
        } else {
            is_compat = v & 1;
            if (is_compat1 < is_compat)
                break;
            type = (v >> (32 - 18 - 7 - 6)) & 0x3f;
            return unicode_decomp_entry(res, c, idx, code, len, type);
        }
    }
    return 0;
}

/* return 0 if no pair found */
static int unicode_compose_pair(uint32_t c0, uint32_t c1)
{
    uint32_t code, len, type, v, idx1, d_idx, d_offset, ch;
    int idx_min, idx_max, idx, d;
    uint32_t pair[2];
    
    idx_min = 0;
    idx_max = countof(unicode_comp_table) - 1;
    while (idx_min <= idx_max) {
        idx = (idx_max + idx_min) / 2;
        idx1 = unicode_comp_table[idx];

        /* idx1 represent an entry of the decomposition table */
        d_idx = idx1 >> 6;
        d_offset = idx1 & 0x3f;
        v = unicode_decomp_table1[d_idx];
        code = v >> (32 - 18);
        len = (v >> (32 - 18 - 7)) & 0x7f;
        type = (v >> (32 - 18 - 7 - 6)) & 0x3f;
        ch = code + d_offset;
        unicode_decomp_entry(pair, ch, d_idx, code, len, type);
        d = c0 - pair[0];
        if (d == 0)
            d = c1 - pair[1];
        if (d < 0) {
            idx_max = idx - 1;
        } else if (d > 0) {
            idx_min = idx + 1;
        } else {
            return ch;
        }
    }
    return 0;
}

/* return the combining class of character c (between 0 and 255) */
static int unicode_get_cc(uint32_t c)
{
    uint32_t code, n, type, cc, c1, b;
    int pos;
    const uint8_t *p;
    
    pos = get_index_pos(&code, c,
                        unicode_cc_index, sizeof(unicode_cc_index) / 3);
    if (pos < 0)
        return 0;
    p = unicode_cc_table + pos;
    for(;;) {
        b = *p++;
        type = b >> 6;
        n = b & 0x3f;
        if (n < 48) {
        } else if (n < 56) {
            n = (n - 48) << 8;
            n |= *p++;
            n += 48;
        } else {
            n = (n - 56) << 8;
            n |= *p++ << 8;
            n |= *p++;
            n += 48 + (1 << 11);
        }
        if (type <= 1)
            p++;
        c1 = code + n + 1;
        if (c < c1) {
            switch(type) {
            case 0:
                cc = p[-1];
                break;
            case 1:
                cc = p[-1] + c - code;
                break;
            case 2:
                cc = 0;
                break;
            default:
            case 3:
                cc = 230;
                break;
            }
            return cc;
        }
        code = c1;
    }
}

static void sort_cc(int *buf, int len)
{
    int i, j, k, cc, cc1, start, ch1;
    
    for(i = 0; i < len; i++) {
        cc = unicode_get_cc(buf[i]);
        if (cc != 0) {
            start = i;
            j = i + 1;
            while (j < len) {
                ch1 = buf[j];
                cc1 = unicode_get_cc(ch1);
                if (cc1 == 0)
                    break;
                k = j - 1;
                while (k >= start) {
                    if (unicode_get_cc(buf[k]) <= cc1)
                        break;
                    buf[k + 1] = buf[k];
                    k--;
                }
                buf[k + 1] = ch1;
                j++;
            }
#if 0
            printf("cc:");
            for(k = start; k < j; k++) {
                printf(" %3d", unicode_get_cc(buf[k]));
            }
            printf("\n");
#endif
            i = j;
        }
    }
}

static void to_nfd_rec(DynBuf *dbuf,
                       const int *src, int src_len, int is_compat)
{
    uint32_t c, v;
    int i, l;
    uint32_t res[UNICODE_DECOMP_LEN_MAX];
    
    for(i = 0; i < src_len; i++) {
        c = src[i];
        if (c >= 0xac00 && c < 0xd7a4) {
            /* Hangul decomposition */
            c -= 0xac00;
            dbuf_put_u32(dbuf, 0x1100 + c / 588);
            dbuf_put_u32(dbuf, 0x1161 + (c % 588) / 28);
            v = c % 28;
            if (v != 0)
                dbuf_put_u32(dbuf, 0x11a7 + v);
        } else {
            l = unicode_decomp_char(res, c, is_compat);
            if (l) {
                to_nfd_rec(dbuf, (int *)res, l, is_compat);
            } else {
                dbuf_put_u32(dbuf, c);
            }
        }
    }
}

/* return 0 if not found */
static int compose_pair(uint32_t c0, uint32_t c1)
{
    /* Hangul composition */
    if (c0 >= 0x1100 && c0 < 0x1100 + 19 &&
        c1 >= 0x1161 && c1 < 0x1161 + 21) {
        return 0xac00 + (c0 - 0x1100) * 588 + (c1 - 0x1161) * 28;
    } else if (c0 >= 0xac00 && c0 < 0xac00 + 11172 &&
               (c0 - 0xac00) % 28 == 0 &&
               c1 >= 0x11a7 && c1 < 0x11a7 + 28) {
        return c0 + c1 - 0x11a7;
    } else {
        return unicode_compose_pair(c0, c1);
    }
}

int unicode_normalize(uint32_t **pdst, const uint32_t *src, int src_len,
                      UnicodeNormalizationEnum n_type,
                      void *opaque, DynBufReallocFunc *realloc_func)
{
    int *buf, buf_len, i, p, starter_pos, cc, last_cc, out_len;
    BOOL is_compat;
    DynBuf dbuf_s, *dbuf = &dbuf_s;
    
    is_compat = n_type >> 1;

    dbuf_init2(dbuf, opaque, realloc_func);
    if (dbuf_realloc(dbuf, sizeof(int) * src_len))
        goto fail;

    /* common case: latin1 is unaffected by NFC */
    if (n_type == UNICODE_NFC) {
        for(i = 0; i < src_len; i++) {
            if (src[i] >= 0x100)
                goto not_latin1;
        }
        buf = (int *)dbuf->buf;
        memcpy(buf, src, src_len * sizeof(int));
        *pdst = (uint32_t *)buf;
        return src_len;
    not_latin1: ;
    }

    to_nfd_rec(dbuf, (const int *)src, src_len, is_compat);
    if (dbuf_error(dbuf)) {
    fail:
        *pdst = NULL;
        return -1;
    }
    buf = (int *)dbuf->buf;
    buf_len = dbuf->size / sizeof(int);
        
    sort_cc(buf, buf_len);
    
    if (buf_len <= 1 || (n_type & 1) != 0) {
        /* NFD / NFKD */
        *pdst = (uint32_t *)buf;
        return buf_len;
    }
    
    i = 1;
    out_len = 1;
    while (i < buf_len) {
        /* find the starter character and test if it is blocked from
           the character at 'i' */
        last_cc = unicode_get_cc(buf[i]);
        starter_pos = out_len - 1;
        while (starter_pos >= 0) {
            cc = unicode_get_cc(buf[starter_pos]);
            if (cc == 0)
                break;
            if (cc >= last_cc)
                goto next;
            last_cc = 256;
            starter_pos--;
        }
        if (starter_pos >= 0 &&
            (p = compose_pair(buf[starter_pos], buf[i])) != 0) {
            buf[starter_pos] = p;
            i++;
        } else {
        next:
            buf[out_len++] = buf[i++];
        }
    }
    *pdst = (uint32_t *)buf;
    return out_len;
}

/* char ranges for various unicode properties */

static int unicode_find_name(const char *name_table, const char *name)
{
    const char *p, *r;
    int pos;
    size_t name_len, len;
    
    p = name_table;
    pos = 0;
    name_len = strlen(name);
    while (*p) {
        for(;;) {
            r = strchr(p, ',');
            if (!r)
                len = strlen(p);
            else
                len = r - p;
            if (len == name_len && !memcmp(p, name, name_len))
                return pos;
            p += len + 1;
            if (!r)
                break;
        }
        pos++;
    }
    return -1;
}

/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2
   if not found */
int unicode_script(CharRange *cr,
                   const char *script_name, BOOL is_ext)
{
    int script_idx;
    const uint8_t *p, *p_end;
    uint32_t c, c1, b, n, v, v_len, i, type;
    CharRange cr1_s, *cr1;
    CharRange cr2_s, *cr2 = &cr2_s;
    BOOL is_common;
    
    script_idx = unicode_find_name(unicode_script_name_table, script_name);
    if (script_idx < 0)
        return -2;
    /* Note: we remove the "Unknown" Script */
    script_idx += UNICODE_SCRIPT_Unknown + 1;
        
    is_common = (script_idx == UNICODE_SCRIPT_Common ||
                 script_idx == UNICODE_SCRIPT_Inherited);
    if (is_ext) {
        cr1 = &cr1_s;
        cr_init(cr1, cr->mem_opaque, cr->realloc_func);
        cr_init(cr2, cr->mem_opaque, cr->realloc_func);
    } else {
        cr1 = cr;
    }

    p = unicode_script_table;
    p_end = unicode_script_table + countof(unicode_script_table);
    c = 0;
    while (p < p_end) {
        b = *p++;
        type = b >> 7;
        n = b & 0x7f;
        if (n < 96) {
        } else if (n < 112) {
            n = (n - 96) << 8;
            n |= *p++;
            n += 96;
        } else {
            n = (n - 112) << 16;
            n |= *p++ << 8;
            n |= *p++;
            n += 96 + (1 << 12);
        }
        if (type == 0)
            v = 0;
        else
            v = *p++;
        c1 = c + n + 1;
        if (v == script_idx) {
            if (cr_add_interval(cr1, c, c1))
                goto fail;
        }
        c = c1;
    }

    if (is_ext) {
        /* add the script extensions */
        p = unicode_script_ext_table;
        p_end = unicode_script_ext_table + countof(unicode_script_ext_table);
        c = 0;
        while (p < p_end) {
            b = *p++;
            if (b < 128) {
                n = b;
            } else if (b < 128 + 64) {
                n = (b - 128) << 8;
                n |= *p++;
                n += 128;
            } else {
                n = (b - 128 - 64) << 16;
                n |= *p++ << 8;
                n |= *p++;
                n += 128 + (1 << 14);
            }
            c1 = c + n + 1;
            v_len = *p++;
            if (is_common) {
                if (v_len != 0) {
                    if (cr_add_interval(cr2, c, c1))
                        goto fail;
                }
            } else {
                for(i = 0; i < v_len; i++) {
                    if (p[i] == script_idx) {
                        if (cr_add_interval(cr2, c, c1))
                            goto fail;
                        break;
                    }
                }
            }
            p += v_len;
            c = c1;
        }
        if (is_common) {
            /* remove all the characters with script extensions */
            if (cr_invert(cr2))
                goto fail;
            if (cr_op(cr, cr1->points, cr1->len, cr2->points, cr2->len,
                      CR_OP_INTER))
                goto fail;
        } else {
            if (cr_op(cr, cr1->points, cr1->len, cr2->points, cr2->len,
                      CR_OP_UNION))
                goto fail;
        }
        cr_free(cr1);
        cr_free(cr2);
    }
    return 0;
 fail:
    if (is_ext) {
        cr_free(cr1);
        cr_free(cr2);
    }
    goto fail;
}

#define M(id) (1U << UNICODE_GC_ ## id)

static int unicode_general_category1(CharRange *cr, uint32_t gc_mask)
{
    const uint8_t *p, *p_end;
    uint32_t c, c0, b, n, v;

    p = unicode_gc_table;
    p_end = unicode_gc_table + countof(unicode_gc_table);
    c = 0;
    while (p < p_end) {
        b = *p++;
        n = b >> 5;
        v = b & 0x1f;
        if (n == 7) {
            n = *p++;
            if (n < 128) {
                n += 7;
            } else if (n < 128 + 64) {
                n = (n - 128) << 8;
                n |= *p++;
                n += 7 + 128;
            } else {
                n = (n - 128 - 64) << 16;
                n |= *p++ << 8;
                n |= *p++;
                n += 7 + 128 + (1 << 14);
            }
        }
        c0 = c;
        c += n + 1;
        if (v == 31) {
            /* run of Lu / Ll */
            b = gc_mask & (M(Lu) | M(Ll));
            if (b != 0) {
                if (b == (M(Lu) | M(Ll))) {
                    goto add_range;
                } else {
                    c0 += ((gc_mask & M(Ll)) != 0);
                    for(; c0 < c; c0 += 2) {
                        if (cr_add_interval(cr, c0, c0 + 1))
                            return -1;
                    }
                }
            }
        } else if ((gc_mask >> v) & 1) {
        add_range:
            if (cr_add_interval(cr, c0, c))
                return -1;
        }
    }
    return 0;
}

static int unicode_prop1(CharRange *cr, int prop_idx)
{
    const uint8_t *p, *p_end;
    uint32_t c, c0, b, bit;

    p = unicode_prop_table[prop_idx];
    p_end = p + unicode_prop_len_table[prop_idx];
    c = 0;
    bit = 0;
    while (p < p_end) {
        c0 = c;
        b = *p++;
        if (b < 64) {
            c += (b >> 3) + 1;
            if (bit)  {
                if (cr_add_interval(cr, c0, c))
                    return -1;
            }
            bit ^= 1;
            c0 = c;
            c += (b & 7) + 1;
        } else if (b >= 0x80) {
            c += b - 0x80 + 1;
        } else if (b < 0x60) {
            c += (((b - 0x40) << 8) | p[0]) + 1;
            p++;
        } else {
            c += (((b - 0x60) << 16) | (p[0] << 8) | p[1]) + 1;
            p += 2;
        }
        if (bit)  {
            if (cr_add_interval(cr, c0, c))
                return -1;
        }
        bit ^= 1;
    }
    return 0;
}

#define CASE_U (1 << 0)
#define CASE_L (1 << 1)
#define CASE_F (1 << 2)

/* use the case conversion table to generate range of characters.
   CASE_U: set char if modified by uppercasing,
   CASE_L: set char if modified by lowercasing,
   CASE_F: set char if modified by case folding,
 */
static int unicode_case1(CharRange *cr, int case_mask)
{
#define MR(x) (1 << RUN_TYPE_ ## x)
    const uint32_t tab_run_mask[3] = {
        MR(U) | MR(UF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(UF_D20) |
        MR(UF_D1_EXT) | MR(U_EXT) | MR(U_EXT2) | MR(U_EXT3),

        MR(L) | MR(LF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(LF_EXT) | MR(L_EXT2),

        MR(UF) | MR(LF) | MR(UL) | MR(LSU) | MR(U2L_399_EXT2) | MR(LF_EXT) | MR(UF_D20) | MR(UF_D1_EXT) | MR(LF_EXT),
    };
#undef MR
    uint32_t mask, v, code, type, len, i, idx;

    if (case_mask == 0)
        return 0;
    mask = 0;
    for(i = 0; i < 3; i++) {
        if ((case_mask >> i) & 1)
            mask |= tab_run_mask[i];
    }
    for(idx = 0; idx < countof(case_conv_table1); idx++) {
        v = case_conv_table1[idx];
        type = (v >> (32 - 17 - 7 - 4)) & 0xf;
        code = v >> (32 - 17);
        len = (v >> (32 - 17 - 7)) & 0x7f;
        if ((mask >> type) & 1) {
            //            printf("%d: type=%d %04x %04x\n", idx, type, code, code + len - 1);
            switch(type) {
            case RUN_TYPE_UL:
                if ((case_mask & CASE_U) && (case_mask & (CASE_L | CASE_F)))
                    goto def_case;
                code += ((case_mask & CASE_U) != 0);
                for(i = 0; i < len; i += 2) {
                    if (cr_add_interval(cr, code + i, code + i + 1))
                        return -1;
                }
                break;
            case RUN_TYPE_LSU:
                if ((case_mask & CASE_U) && (case_mask & (CASE_L | CASE_F)))
                    goto def_case;
                if (!(case_mask & CASE_U)) {
                    if (cr_add_interval(cr, code, code + 1))
                        return -1;
                }
                if (cr_add_interval(cr, code + 1, code + 2))
                    return -1;
                if (case_mask & CASE_U) {
                    if (cr_add_interval(cr, code + 2, code + 3))
                        return -1;
                }
                break;
            default:
            def_case:
                if (cr_add_interval(cr, code, code + len))
                    return -1;
                break;
            }
        }
    }
    return 0;
}
        
typedef enum {
    POP_GC,
    POP_PROP,
    POP_CASE,
    POP_UNION,
    POP_INTER,
    POP_XOR,
    POP_INVERT,
    POP_END,
} PropOPEnum;

#define POP_STACK_LEN_MAX 4

static int unicode_prop_ops(CharRange *cr, ...)
{
    va_list ap;
    CharRange stack[POP_STACK_LEN_MAX];
    int stack_len, op, ret, i;
    uint32_t a;
    
    va_start(ap, cr);
    stack_len = 0;
    for(;;) {
        op = va_arg(ap, int);
        switch(op) {
        case POP_GC:
            assert(stack_len < POP_STACK_LEN_MAX);
            a = va_arg(ap, int);
            cr_init(&stack[stack_len++], cr->mem_opaque, cr->realloc_func);
            if (unicode_general_category1(&stack[stack_len - 1], a))
                goto fail;
            break;
        case POP_PROP:
            assert(stack_len < POP_STACK_LEN_MAX);
            a = va_arg(ap, int);
            cr_init(&stack[stack_len++], cr->mem_opaque, cr->realloc_func);
            if (unicode_prop1(&stack[stack_len - 1], a))
                goto fail;
            break;
        case POP_CASE:
            assert(stack_len < POP_STACK_LEN_MAX);
            a = va_arg(ap, int);
            cr_init(&stack[stack_len++], cr->mem_opaque, cr->realloc_func);
            if (unicode_case1(&stack[stack_len - 1], a))
                goto fail;
            break;
        case POP_UNION:
        case POP_INTER:
        case POP_XOR:
            {
                CharRange *cr1, *cr2, *cr3;
                assert(stack_len >= 2);
                assert(stack_len < POP_STACK_LEN_MAX);
                cr1 = &stack[stack_len - 2];
                cr2 = &stack[stack_len - 1];
                cr3 = &stack[stack_len++];
                cr_init(cr3, cr->mem_opaque, cr->realloc_func);
                if (cr_op(cr3, cr1->points, cr1->len,
                          cr2->points, cr2->len, op - POP_UNION + CR_OP_UNION))
                    goto fail;
                cr_free(cr1);
                cr_free(cr2);
                *cr1 = *cr3;
                stack_len -= 2;
            }
            break;
        case POP_INVERT:
            assert(stack_len >= 1);
            if (cr_invert(&stack[stack_len - 1]))
                goto fail;
            break;
        case POP_END:
            goto done;
        default:
            abort();
        }
    }
 done:
    assert(stack_len == 1);
    ret = cr_copy(cr, &stack[0]);
    cr_free(&stack[0]);
    return ret;
 fail:
    for(i = 0; i < stack_len; i++)
        cr_free(&stack[i]);
    return -1;
}

static const uint32_t unicode_gc_mask_table[] = {
    M(Lu) | M(Ll) | M(Lt), /* LC */
    M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo), /* L */
    M(Mn) | M(Mc) | M(Me), /* M */
    M(Nd) | M(Nl) | M(No), /* N */
    M(Sm) | M(Sc) | M(Sk) | M(So), /* S */
    M(Pc) | M(Pd) | M(Ps) | M(Pe) | M(Pi) | M(Pf) | M(Po), /* P */
    M(Zs) | M(Zl) | M(Zp), /* Z */
    M(Cc) | M(Cf) | M(Cs) | M(Co) | M(Cn), /* C */
};

/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2
   if not found */
int unicode_general_category(CharRange *cr, const char *gc_name)
{
    int gc_idx;
    uint32_t gc_mask;
    
    gc_idx = unicode_find_name(unicode_gc_name_table, gc_name);
    if (gc_idx < 0)
        return -2;
    if (gc_idx <= UNICODE_GC_Co) {
        gc_mask = (uint64_t)1 << gc_idx;
    } else {
        gc_mask = unicode_gc_mask_table[gc_idx - UNICODE_GC_LC];
    }
    return unicode_general_category1(cr, gc_mask);
}

/* 'cr' must be initialized and empty. Return 0 if OK, -1 if error, -2
   if not found */
int unicode_prop(CharRange *cr, const char *prop_name)
{
    int prop_idx, ret;
    
    prop_idx = unicode_find_name(unicode_prop_name_table, prop_name);
    if (prop_idx < 0)
        return -2;
    prop_idx += UNICODE_PROP_ASCII_Hex_Digit;

    ret = 0;
    switch(prop_idx) {
    case UNICODE_PROP_ASCII:
        if (cr_add_interval(cr, 0x00, 0x7f + 1))
            return -1;
        break;
    case UNICODE_PROP_Any:
        if (cr_add_interval(cr, 0x00000, 0x10ffff + 1))
            return -1;
        break;
    case UNICODE_PROP_Assigned:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Cn),
                               POP_INVERT,
                               POP_END);
        break;
    case UNICODE_PROP_Math:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Sm),
                               POP_PROP, UNICODE_PROP_Other_Math,
                               POP_UNION,
                               POP_END);
        break;
    case UNICODE_PROP_Lowercase:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Ll),
                               POP_PROP, UNICODE_PROP_Other_Lowercase,
                               POP_UNION,
                               POP_END);
        break;
    case UNICODE_PROP_Uppercase:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Lu),
                               POP_PROP, UNICODE_PROP_Other_Uppercase,
                               POP_UNION,
                               POP_END);
        break;
    case UNICODE_PROP_Cased:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Lu) | M(Ll) | M(Lt),
                               POP_PROP, UNICODE_PROP_Other_Uppercase,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_Other_Lowercase,
                               POP_UNION,
                               POP_END);
        break;
    case UNICODE_PROP_Alphabetic:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),
                               POP_PROP, UNICODE_PROP_Other_Uppercase,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_Other_Lowercase,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_Other_Alphabetic,
                               POP_UNION,
                               POP_END);
        break;
    case UNICODE_PROP_Grapheme_Base:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Cc) | M(Cf) | M(Cs) | M(Co) | M(Cn) | M(Zl) | M(Zp) | M(Me) | M(Mn),
                               POP_PROP, UNICODE_PROP_Other_Grapheme_Extend,
                               POP_UNION,
                               POP_INVERT,
                               POP_END);
        break;
    case UNICODE_PROP_Grapheme_Extend:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Me) | M(Mn),
                               POP_PROP, UNICODE_PROP_Other_Grapheme_Extend,
                               POP_UNION,
                               POP_END);
        break;
    case UNICODE_PROP_XID_Start:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),
                               POP_PROP, UNICODE_PROP_Other_ID_Start,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_Pattern_Syntax,
                               POP_PROP, UNICODE_PROP_Pattern_White_Space,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_XID_Start1,
                               POP_UNION,
                               POP_INVERT,
                               POP_INTER,
                               POP_END);
        break;
    case UNICODE_PROP_XID_Continue:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl) |
                               M(Mn) | M(Mc) | M(Nd) | M(Pc),
                               POP_PROP, UNICODE_PROP_Other_ID_Start,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_Other_ID_Continue,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_Pattern_Syntax,
                               POP_PROP, UNICODE_PROP_Pattern_White_Space,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_XID_Continue1,
                               POP_UNION,
                               POP_INVERT,
                               POP_INTER,
                               POP_END);
        break;
    case UNICODE_PROP_Changes_When_Uppercased:
        ret = unicode_case1(cr, CASE_U);
        break;
    case UNICODE_PROP_Changes_When_Lowercased:
        ret = unicode_case1(cr, CASE_L);
        break;
    case UNICODE_PROP_Changes_When_Casemapped:
        ret = unicode_case1(cr, CASE_U | CASE_L | CASE_F);
        break;
    case UNICODE_PROP_Changes_When_Titlecased:
        ret = unicode_prop_ops(cr,
                               POP_CASE, CASE_U,
                               POP_PROP, UNICODE_PROP_Changes_When_Titlecased1,
                               POP_XOR,
                               POP_END);
        break;
    case UNICODE_PROP_Changes_When_Casefolded:
        ret = unicode_prop_ops(cr,
                               POP_CASE, CASE_F,
                               POP_PROP, UNICODE_PROP_Changes_When_Casefolded1,
                               POP_XOR,
                               POP_END);
        break;
    case UNICODE_PROP_Changes_When_NFKC_Casefolded:
        ret = unicode_prop_ops(cr,
                               POP_CASE, CASE_F,
                               POP_PROP, UNICODE_PROP_Changes_When_NFKC_Casefolded1,
                               POP_XOR,
                               POP_END);
        break;
#if 0
    case UNICODE_PROP_ID_Start:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl),
                               POP_PROP, UNICODE_PROP_Other_ID_Start,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_Pattern_Syntax,
                               POP_PROP, UNICODE_PROP_Pattern_White_Space,
                               POP_UNION,
                               POP_INVERT,
                               POP_INTER,
                               POP_END);
        break;
    case UNICODE_PROP_ID_Continue:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Lu) | M(Ll) | M(Lt) | M(Lm) | M(Lo) | M(Nl) |
                               M(Mn) | M(Mc) | M(Nd) | M(Pc),
                               POP_PROP, UNICODE_PROP_Other_ID_Start,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_Other_ID_Continue,
                               POP_UNION,
                               POP_PROP, UNICODE_PROP_Pattern_Syntax,
                               POP_PROP, UNICODE_PROP_Pattern_White_Space,
                               POP_UNION,
                               POP_INVERT,
                               POP_INTER,
                               POP_END);
        break;
    case UNICODE_PROP_Case_Ignorable:
        ret = unicode_prop_ops(cr,
                               POP_GC, M(Mn) | M(Cf) | M(Lm) | M(Sk),
                               POP_PROP, UNICODE_PROP_Case_Ignorable1,
                               POP_XOR,
                               POP_END);
        break;
#else
        /* we use the existing tables */
    case UNICODE_PROP_ID_Continue:
        ret = unicode_prop_ops(cr,
                               POP_PROP, UNICODE_PROP_ID_Start,
                               POP_PROP, UNICODE_PROP_ID_Continue1,
                               POP_XOR,
                               POP_END);
        break;
#endif
    default:
        if (prop_idx >= countof(unicode_prop_table))
            return -2;
        ret = unicode_prop1(cr, prop_idx);
        break;
    }
    return ret;
}

#endif /* CONFIG_ALL_UNICODE */

'''
'''--- libunicode.h ---
/*
 * Unicode utilities
 * 
 * Copyright (c) 2017-2018 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef LIBUNICODE_H
#define LIBUNICODE_H

#include <inttypes.h>

#define LRE_BOOL  int       /* for documentation purposes */

/* define it to include all the unicode tables (40KB larger) */
#define CONFIG_ALL_UNICODE

#define LRE_CC_RES_LEN_MAX 3

typedef enum {
    UNICODE_NFC,
    UNICODE_NFD,
    UNICODE_NFKC,
    UNICODE_NFKD,
} UnicodeNormalizationEnum;

int lre_case_conv(uint32_t *res, uint32_t c, int conv_type);
LRE_BOOL lre_is_cased(uint32_t c);
LRE_BOOL lre_is_case_ignorable(uint32_t c);

/* char ranges */

typedef struct {
    int len; /* in points, always even */
    int size;
    uint32_t *points; /* points sorted by increasing value */
    void *mem_opaque;
    void *(*realloc_func)(void *opaque, void *ptr, size_t size);
} CharRange;

typedef enum {
    CR_OP_UNION,
    CR_OP_INTER,
    CR_OP_XOR,
} CharRangeOpEnum;

void cr_init(CharRange *cr, void *mem_opaque, void *(*realloc_func)(void *opaque, void *ptr, size_t size));
void cr_free(CharRange *cr);
int cr_realloc(CharRange *cr, int size);
int cr_copy(CharRange *cr, const CharRange *cr1);

static inline int cr_add_point(CharRange *cr, uint32_t v)
{
    if (cr->len >= cr->size) {
        if (cr_realloc(cr, cr->len + 1))
            return -1;
    }
    cr->points[cr->len++] = v;
    return 0;
}

static inline int cr_add_interval(CharRange *cr, uint32_t c1, uint32_t c2)
{
    if ((cr->len + 2) > cr->size) {
        if (cr_realloc(cr, cr->len + 2))
            return -1;
    }
    cr->points[cr->len++] = c1;
    cr->points[cr->len++] = c2;
    return 0;
}

int cr_union1(CharRange *cr, const uint32_t *b_pt, int b_len);

static inline int cr_union_interval(CharRange *cr, uint32_t c1, uint32_t c2)
{
    uint32_t b_pt[2];
    b_pt[0] = c1;
    b_pt[1] = c2 + 1;
    return cr_union1(cr, b_pt, 2);
}

int cr_op(CharRange *cr, const uint32_t *a_pt, int a_len,
          const uint32_t *b_pt, int b_len, int op);

int cr_invert(CharRange *cr);

#ifdef CONFIG_ALL_UNICODE

LRE_BOOL lre_is_id_start(uint32_t c);
LRE_BOOL lre_is_id_continue(uint32_t c);

int unicode_normalize(uint32_t **pdst, const uint32_t *src, int src_len,
                      UnicodeNormalizationEnum n_type,
                      void *opaque, void *(*realloc_func)(void *opaque, void *ptr, size_t size));

/* Unicode character range functions */

int unicode_script(CharRange *cr,
                   const char *script_name, LRE_BOOL is_ext);
int unicode_general_category(CharRange *cr, const char *gc_name);
int unicode_prop(CharRange *cr, const char *prop_name);

#endif /* CONFIG_ALL_UNICODE */

#undef LRE_BOOL

#endif /* LIBUNICODE_H */

'''
'''--- list.h ---
/*
 * Linux klist like system
 * 
 * Copyright (c) 2016-2017 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef LIST_H
#define LIST_H

#ifndef NULL
#include <stddef.h>
#endif

struct list_head {
    struct list_head *prev;
    struct list_head *next;
};

#define LIST_HEAD_INIT(el) { &(el), &(el) }

/* return the pointer of type 'type *' containing 'el' as field 'member' */
#define list_entry(el, type, member) \
    ((type *)((uint8_t *)(el) - offsetof(type, member)))

static inline void init_list_head(struct list_head *head)
{
    head->prev = head;
    head->next = head;
}

/* insert 'el' between 'prev' and 'next' */
static inline void __list_add(struct list_head *el, 
                              struct list_head *prev, struct list_head *next)
{
    prev->next = el;
    el->prev = prev;
    el->next = next;
    next->prev = el;
}

/* add 'el' at the head of the list 'head' (= after element head) */
static inline void list_add(struct list_head *el, struct list_head *head)
{
    __list_add(el, head, head->next);
}

/* add 'el' at the end of the list 'head' (= before element head) */
static inline void list_add_tail(struct list_head *el, struct list_head *head)
{
    __list_add(el, head->prev, head);
}

static inline void list_del(struct list_head *el)
{
    struct list_head *prev, *next;
    prev = el->prev;
    next = el->next;
    prev->next = next;
    next->prev = prev;
    el->prev = NULL; /* fail safe */
    el->next = NULL; /* fail safe */
}

static inline int list_empty(struct list_head *el)
{
    return el->next == el;
}

#define list_for_each(el, head) \
  for(el = (head)->next; el != (head); el = el->next)

#define list_for_each_safe(el, el1, head)                \
    for(el = (head)->next, el1 = el->next; el != (head); \
        el = el1, el1 = el->next)

#define list_for_each_prev(el, head) \
  for(el = (head)->prev; el != (head); el = el->prev)

#define list_for_each_prev_safe(el, el1, head)           \
    for(el = (head)->prev, el1 = el->prev; el != (head); \
        el = el1, el1 = el->prev)

#endif /* LIST_H */

'''
'''--- qjs.c ---
/*
 * QuickJS stand alone interpreter
 * 
 * Copyright (c) 2017-2021 Fabrice Bellard
 * Copyright (c) 2017-2021 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <inttypes.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <time.h>
#if defined(__APPLE__)
#include <malloc/malloc.h>
#elif defined(__linux__)
#include <malloc.h>
#endif

#include "cutils.h"
#include "quickjs-libc.h"

extern const uint8_t qjsc_repl[];
extern const uint32_t qjsc_repl_size;
#ifdef CONFIG_BIGNUM
extern const uint8_t qjsc_qjscalc[];
extern const uint32_t qjsc_qjscalc_size;
static int bignum_ext;
#endif

static int eval_buf(JSContext *ctx, const void *buf, int buf_len,
                    const char *filename, int eval_flags)
{
    JSValue val;
    int ret;

    if ((eval_flags & JS_EVAL_TYPE_MASK) == JS_EVAL_TYPE_MODULE) {
        /* for the modules, we compile then run to be able to set
           import.meta */
        val = JS_Eval(ctx, buf, buf_len, filename,
                      eval_flags | JS_EVAL_FLAG_COMPILE_ONLY);
        if (!JS_IsException(val)) {
            js_module_set_import_meta(ctx, val, TRUE, TRUE);
            val = JS_EvalFunction(ctx, val);
        }
    } else {
        val = JS_Eval(ctx, buf, buf_len, filename, eval_flags);
    }
    if (JS_IsException(val)) {
        js_std_dump_error(ctx);
        ret = -1;
    } else {
        ret = 0;
    }
    JS_FreeValue(ctx, val);
    return ret;
}

static int eval_file(JSContext *ctx, const char *filename, int module)
{
    uint8_t *buf;
    int ret, eval_flags;
    size_t buf_len;
    
    buf = js_load_file(ctx, &buf_len, filename);
    if (!buf) {
        perror(filename);
        exit(1);
    }

    if (module < 0) {
        module = (has_suffix(filename, ".mjs") ||
                  JS_DetectModule((const char *)buf, buf_len));
    }
    if (module)
        eval_flags = JS_EVAL_TYPE_MODULE;
    else
        eval_flags = JS_EVAL_TYPE_GLOBAL;
    ret = eval_buf(ctx, buf, buf_len, filename, eval_flags);
    js_free(ctx, buf);
    return ret;
}

/* also used to initialize the worker context */
static JSContext *JS_NewCustomContext(JSRuntime *rt)
{
    JSContext *ctx;
    ctx = JS_NewContext(rt);
    if (!ctx)
        return NULL;
#ifdef CONFIG_BIGNUM
    if (bignum_ext) {
        JS_AddIntrinsicBigFloat(ctx);
        JS_AddIntrinsicBigDecimal(ctx);
        JS_AddIntrinsicOperators(ctx);
        JS_EnableBignumExt(ctx, TRUE);
    }
#endif
    /* system modules */
    js_init_module_std(ctx, "std");
    js_init_module_os(ctx, "os");
    return ctx;
}

#if defined(__APPLE__)
#define MALLOC_OVERHEAD  0
#else
#define MALLOC_OVERHEAD  8
#endif

struct trace_malloc_data {
    uint8_t *base;
};

static inline unsigned long long js_trace_malloc_ptr_offset(uint8_t *ptr,
                                                struct trace_malloc_data *dp)
{
    return ptr - dp->base;
}

/* default memory allocation functions with memory limitation */
static inline size_t js_trace_malloc_usable_size(void *ptr)
{
#if defined(__APPLE__)
    return malloc_size(ptr);
#elif defined(_WIN32)
    return _msize(ptr);
#elif defined(EMSCRIPTEN)
    return 0;
#elif defined(__linux__)
    return malloc_usable_size(ptr);
#else
    /* change this to `return 0;` if compilation fails */
    return malloc_usable_size(ptr);
#endif
}

static void
#ifdef _WIN32
/* mingw printf is used */
__attribute__((format(gnu_printf, 2, 3)))
#else
__attribute__((format(printf, 2, 3)))
#endif
    js_trace_malloc_printf(JSMallocState *s, const char *fmt, ...)
{
    va_list ap;
    int c;

    va_start(ap, fmt);
    while ((c = *fmt++) != '\0') {
        if (c == '%') {
            /* only handle %p and %zd */
            if (*fmt == 'p') {
                uint8_t *ptr = va_arg(ap, void *);
                if (ptr == NULL) {
                    printf("NULL");
                } else {
                    printf("H%+06lld.%zd",
                           js_trace_malloc_ptr_offset(ptr, s->opaque),
                           js_trace_malloc_usable_size(ptr));
                }
                fmt++;
                continue;
            }
            if (fmt[0] == 'z' && fmt[1] == 'd') {
                size_t sz = va_arg(ap, size_t);
                printf("%zd", sz);
                fmt += 2;
                continue;
            }
        }
        putc(c, stdout);
    }
    va_end(ap);
}

static void js_trace_malloc_init(struct trace_malloc_data *s)
{
    free(s->base = malloc(8));
}

static void *js_trace_malloc(JSMallocState *s, size_t size)
{
    void *ptr;

    /* Do not allocate zero bytes: behavior is platform dependent */
    assert(size != 0);

    if (unlikely(s->malloc_size + size > s->malloc_limit))
        return NULL;
    ptr = malloc(size);
    js_trace_malloc_printf(s, "A %zd -> %p\n", size, ptr);
    if (ptr) {
        s->malloc_count++;
        s->malloc_size += js_trace_malloc_usable_size(ptr) + MALLOC_OVERHEAD;
    }
    return ptr;
}

static void js_trace_free(JSMallocState *s, void *ptr)
{
    if (!ptr)
        return;

    js_trace_malloc_printf(s, "F %p\n", ptr);
    s->malloc_count--;
    s->malloc_size -= js_trace_malloc_usable_size(ptr) + MALLOC_OVERHEAD;
    free(ptr);
}

static void *js_trace_realloc(JSMallocState *s, void *ptr, size_t size)
{
    size_t old_size;

    if (!ptr) {
        if (size == 0)
            return NULL;
        return js_trace_malloc(s, size);
    }
    old_size = js_trace_malloc_usable_size(ptr);
    if (size == 0) {
        js_trace_malloc_printf(s, "R %zd %p\n", size, ptr);
        s->malloc_count--;
        s->malloc_size -= old_size + MALLOC_OVERHEAD;
        free(ptr);
        return NULL;
    }
    if (s->malloc_size + size - old_size > s->malloc_limit)
        return NULL;

    js_trace_malloc_printf(s, "R %zd %p", size, ptr);

    ptr = realloc(ptr, size);
    js_trace_malloc_printf(s, " -> %p\n", ptr);
    if (ptr) {
        s->malloc_size += js_trace_malloc_usable_size(ptr) - old_size;
    }
    return ptr;
}

static const JSMallocFunctions trace_mf = {
    js_trace_malloc,
    js_trace_free,
    js_trace_realloc,
#if defined(__APPLE__)
    malloc_size,
#elif defined(_WIN32)
    (size_t (*)(const void *))_msize,
#elif defined(EMSCRIPTEN)
    NULL,
#elif defined(__linux__)
    (size_t (*)(const void *))malloc_usable_size,
#else
    /* change this to `NULL,` if compilation fails */
    malloc_usable_size,
#endif
};

#define PROG_NAME "qjs"

void help(void)
{
    printf("QuickJS version " CONFIG_VERSION "\n"
           "usage: " PROG_NAME " [options] [file [args]]\n"
           "-h  --help         list options\n"
           "-e  --eval EXPR    evaluate EXPR\n"
           "-i  --interactive  go to interactive mode\n"
           "-m  --module       load as ES6 module (default=autodetect)\n"
           "    --script       load as ES6 script (default=autodetect)\n"
           "-I  --include file include an additional file\n"
           "    --std          make 'std' and 'os' available to the loaded script\n"
#ifdef CONFIG_BIGNUM
           "    --bignum       enable the bignum extensions (BigFloat, BigDecimal)\n"
           "    --qjscalc      load the QJSCalc runtime (default if invoked as qjscalc)\n"
#endif
           "-T  --trace        trace memory allocation\n"
           "-d  --dump         dump the memory usage stats\n"
           "    --memory-limit n       limit the memory usage to 'n' bytes\n"
           "    --stack-size n         limit the stack size to 'n' bytes\n"
           "    --unhandled-rejection  dump unhandled promise rejections\n"
           "-q  --quit         just instantiate the interpreter and quit\n");
    exit(1);
}

int main(int argc, char **argv)
{
    JSRuntime *rt;
    JSContext *ctx;
    struct trace_malloc_data trace_data = { NULL };
    int optind;
    char *expr = NULL;
    int interactive = 0;
    int dump_memory = 0;
    int trace_memory = 0;
    int empty_run = 0;
    int module = -1;
    int load_std = 0;
    int dump_unhandled_promise_rejection = 0;
    size_t memory_limit = 0;
    char *include_list[32];
    int i, include_count = 0;
#ifdef CONFIG_BIGNUM
    int load_jscalc;
#endif
    size_t stack_size = 0;
    
#ifdef CONFIG_BIGNUM
    /* load jscalc runtime if invoked as 'qjscalc' */
    {
        const char *p, *exename;
        exename = argv[0];
        p = strrchr(exename, '/');
        if (p)
            exename = p + 1;
        load_jscalc = !strcmp(exename, "qjscalc");
    }
#endif
    
    /* cannot use getopt because we want to pass the command line to
       the script */
    optind = 1;
    while (optind < argc && *argv[optind] == '-') {
        char *arg = argv[optind] + 1;
        const char *longopt = "";
        /* a single - is not an option, it also stops argument scanning */
        if (!*arg)
            break;
        optind++;
        if (*arg == '-') {
            longopt = arg + 1;
            arg += strlen(arg);
            /* -- stops argument scanning */
            if (!*longopt)
                break;
        }
        for (; *arg || *longopt; longopt = "") {
            char opt = *arg;
            if (opt)
                arg++;
            if (opt == 'h' || opt == '?' || !strcmp(longopt, "help")) {
                help();
                continue;
            }
            if (opt == 'e' || !strcmp(longopt, "eval")) {
                if (*arg) {
                    expr = arg;
                    break;
                }
                if (optind < argc) {
                    expr = argv[optind++];
                    break;
                }
                fprintf(stderr, "qjs: missing expression for -e\n");
                exit(2);
            }
            if (opt == 'I' || !strcmp(longopt, "include")) {
                if (optind >= argc) {
                    fprintf(stderr, "expecting filename");
                    exit(1);
                }
                if (include_count >= countof(include_list)) {
                    fprintf(stderr, "too many included files");
                    exit(1);
                }
                include_list[include_count++] = argv[optind++];
                continue;
            }
            if (opt == 'i' || !strcmp(longopt, "interactive")) {
                interactive++;
                continue;
            }
            if (opt == 'm' || !strcmp(longopt, "module")) {
                module = 1;
                continue;
            }
            if (!strcmp(longopt, "script")) {
                module = 0;
                continue;
            }
            if (opt == 'd' || !strcmp(longopt, "dump")) {
                dump_memory++;
                continue;
            }
            if (opt == 'T' || !strcmp(longopt, "trace")) {
                trace_memory++;
                continue;
            }
            if (!strcmp(longopt, "std")) {
                load_std = 1;
                continue;
            }
            if (!strcmp(longopt, "unhandled-rejection")) {
                dump_unhandled_promise_rejection = 1;
                continue;
            }
#ifdef CONFIG_BIGNUM
            if (!strcmp(longopt, "bignum")) {
                bignum_ext = 1;
                continue;
            }
            if (!strcmp(longopt, "qjscalc")) {
                load_jscalc = 1;
                continue;
            }
#endif
            if (opt == 'q' || !strcmp(longopt, "quit")) {
                empty_run++;
                continue;
            }
            if (!strcmp(longopt, "memory-limit")) {
                if (optind >= argc) {
                    fprintf(stderr, "expecting memory limit");
                    exit(1);
                }
                memory_limit = (size_t)strtod(argv[optind++], NULL);
                continue;
            }
            if (!strcmp(longopt, "stack-size")) {
                if (optind >= argc) {
                    fprintf(stderr, "expecting stack size");
                    exit(1);
                }
                stack_size = (size_t)strtod(argv[optind++], NULL);
                continue;
            }
            if (opt) {
                fprintf(stderr, "qjs: unknown option '-%c'\n", opt);
            } else {
                fprintf(stderr, "qjs: unknown option '--%s'\n", longopt);
            }
            help();
        }
    }

    if (load_jscalc)
        bignum_ext = 1;

    if (trace_memory) {
        js_trace_malloc_init(&trace_data);
        rt = JS_NewRuntime2(&trace_mf, &trace_data);
    } else {
        rt = JS_NewRuntime();
    }
    if (!rt) {
        fprintf(stderr, "qjs: cannot allocate JS runtime\n");
        exit(2);
    }
    if (memory_limit != 0)
        JS_SetMemoryLimit(rt, memory_limit);
    if (stack_size != 0)
        JS_SetMaxStackSize(rt, stack_size);
    js_std_set_worker_new_context_func(JS_NewCustomContext);
    js_std_init_handlers(rt);
    ctx = JS_NewCustomContext(rt);
    if (!ctx) {
        fprintf(stderr, "qjs: cannot allocate JS context\n");
        exit(2);
    }

    /* loader for ES6 modules */
    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);

    if (dump_unhandled_promise_rejection) {
        JS_SetHostPromiseRejectionTracker(rt, js_std_promise_rejection_tracker,
                                          NULL);
    }
    
    if (!empty_run) {
#ifdef CONFIG_BIGNUM
        if (load_jscalc) {
            js_std_eval_binary(ctx, qjsc_qjscalc, qjsc_qjscalc_size, 0);
        }
#endif
        js_std_add_helpers(ctx, argc - optind, argv + optind);

        /* make 'std' and 'os' visible to non module code */
        if (load_std) {
            const char *str = "import * as std from 'std';\n"
                "import * as os from 'os';\n"
                "globalThis.std = std;\n"
                "globalThis.os = os;\n";
            eval_buf(ctx, str, strlen(str), "<input>", JS_EVAL_TYPE_MODULE);
        }

        for(i = 0; i < include_count; i++) {
            if (eval_file(ctx, include_list[i], module))
                goto fail;
        }

        if (expr) {
            if (eval_buf(ctx, expr, strlen(expr), "<cmdline>", 0))
                goto fail;
        } else
        if (optind >= argc) {
            /* interactive mode */
            interactive = 1;
        } else {
            const char *filename;
            filename = argv[optind];
            if (eval_file(ctx, filename, module))
                goto fail;
        }
        if (interactive) {
            js_std_eval_binary(ctx, qjsc_repl, qjsc_repl_size, 0);
        }
        js_std_loop(ctx);
    }
    
    if (dump_memory) {
        JSMemoryUsage stats;
        JS_ComputeMemoryUsage(rt, &stats);
        JS_DumpMemoryUsage(stdout, &stats, rt);
    }
    js_std_free_handlers(rt);
    JS_FreeContext(ctx);
    JS_FreeRuntime(rt);

    if (empty_run && dump_memory) {
        clock_t t[5];
        double best[5];
        int i, j;
        for (i = 0; i < 100; i++) {
            t[0] = clock();
            rt = JS_NewRuntime();
            t[1] = clock();
            ctx = JS_NewContext(rt);
            t[2] = clock();
            JS_FreeContext(ctx);
            t[3] = clock();
            JS_FreeRuntime(rt);
            t[4] = clock();
            for (j = 4; j > 0; j--) {
                double ms = 1000.0 * (t[j] - t[j - 1]) / CLOCKS_PER_SEC;
                if (i == 0 || best[j] > ms)
                    best[j] = ms;
            }
        }
        printf("\nInstantiation times (ms): %.3f = %.3f+%.3f+%.3f+%.3f\n",
               best[1] + best[2] + best[3] + best[4],
               best[1], best[2], best[3], best[4]);
    }
    return 0;
 fail:
    js_std_free_handlers(rt);
    JS_FreeContext(ctx);
    JS_FreeRuntime(rt);
    return 1;
}

'''
'''--- qjsc.c ---
/*
 * QuickJS command line compiler
 * 
 * Copyright (c) 2018-2021 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <inttypes.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <errno.h>
#if !defined(_WIN32)
#include <sys/wait.h>
#endif

#include "cutils.h"
#include "quickjs-libc.h"

typedef struct {
    char *name;
    char *short_name;
    int flags;
} namelist_entry_t;

typedef struct namelist_t {
    namelist_entry_t *array;
    int count;
    int size;
} namelist_t;

typedef struct {
    const char *option_name;
    const char *init_name;
} FeatureEntry;

static namelist_t cname_list;
static namelist_t cmodule_list;
static namelist_t init_module_list;
static uint64_t feature_bitmap;
static FILE *outfile;
static BOOL byte_swap;
static BOOL dynamic_export;
static const char *c_ident_prefix = "qjsc_";

#define FE_ALL (-1)

static const FeatureEntry feature_list[] = {
    { "date", "Date" },
    { "eval", "Eval" },
    { "string-normalize", "StringNormalize" },
    { "regexp", "RegExp" },
    { "json", "JSON" },
    { "proxy", "Proxy" },
    { "map", "MapSet" },
    { "typedarray", "TypedArrays" },
    { "promise", "Promise" },
#define FE_MODULE_LOADER 9
    { "module-loader", NULL },
#ifdef CONFIG_BIGNUM
    { "bigint", "BigInt" },
#endif
};

void namelist_add(namelist_t *lp, const char *name, const char *short_name,
                  int flags)
{
    namelist_entry_t *e;
    if (lp->count == lp->size) {
        size_t newsize = lp->size + (lp->size >> 1) + 4;
        namelist_entry_t *a =
            realloc(lp->array, sizeof(lp->array[0]) * newsize);
        /* XXX: check for realloc failure */
        lp->array = a;
        lp->size = newsize;
    }
    e =  &lp->array[lp->count++];
    e->name = strdup(name);
    if (short_name)
        e->short_name = strdup(short_name);
    else
        e->short_name = NULL;
    e->flags = flags;
}

void namelist_free(namelist_t *lp)
{
    while (lp->count > 0) {
        namelist_entry_t *e = &lp->array[--lp->count];
        free(e->name);
        free(e->short_name);
    }
    free(lp->array);
    lp->array = NULL;
    lp->size = 0;
}

namelist_entry_t *namelist_find(namelist_t *lp, const char *name)
{
    int i;
    for(i = 0; i < lp->count; i++) {
        namelist_entry_t *e = &lp->array[i];
        if (!strcmp(e->name, name))
            return e;
    }
    return NULL;
}

static void get_c_name(char *buf, size_t buf_size, const char *file)
{
    const char *p, *r;
    size_t len, i;
    int c;
    char *q;
    
    p = strrchr(file, '/');
    if (!p)
        p = file;
    else
        p++;
    r = strrchr(p, '.');
    if (!r)
        len = strlen(p);
    else
        len = r - p;
    pstrcpy(buf, buf_size, c_ident_prefix);
    q = buf + strlen(buf);
    for(i = 0; i < len; i++) {
        c = p[i];
        if (!((c >= '0' && c <= '9') ||
              (c >= 'A' && c <= 'Z') ||
              (c >= 'a' && c <= 'z'))) {
            c = '_';
        }
        if ((q - buf) < buf_size - 1)
            *q++ = c;
    }
    *q = '\0';
}

static void dump_hex(FILE *f, const uint8_t *buf, size_t len)
{
    size_t i, col;
    col = 0;
    for(i = 0; i < len; i++) {
        fprintf(f, " 0x%02x,", buf[i]);
        if (++col == 8) {
            fprintf(f, "\n");
            col = 0;
        }
    }
    if (col != 0)
        fprintf(f, "\n");
}

static void output_object_code(JSContext *ctx,
                               FILE *fo, JSValueConst obj, const char *c_name,
                               BOOL load_only)
{
    uint8_t *out_buf;
    size_t out_buf_len;
    int flags;
    flags = JS_WRITE_OBJ_BYTECODE;
    if (byte_swap)
        flags |= JS_WRITE_OBJ_BSWAP;
    out_buf = JS_WriteObject(ctx, &out_buf_len, obj, flags);
    if (!out_buf) {
        js_std_dump_error(ctx);
        exit(1);
    }

    namelist_add(&cname_list, c_name, NULL, load_only);
    
    fprintf(fo, "const uint32_t %s_size = %u;\n\n", 
            c_name, (unsigned int)out_buf_len);
    fprintf(fo, "const uint8_t %s[%u] = {\n",
            c_name, (unsigned int)out_buf_len);
    dump_hex(fo, out_buf, out_buf_len);
    fprintf(fo, "};\n\n");

    js_free(ctx, out_buf);
}

static int js_module_dummy_init(JSContext *ctx, JSModuleDef *m)
{
    /* should never be called when compiling JS code */
    abort();
}

static void find_unique_cname(char *cname, size_t cname_size)
{
    char cname1[1024];
    int suffix_num;
    size_t len, max_len;
    assert(cname_size >= 32);
    /* find a C name not matching an existing module C name by
       adding a numeric suffix */
    len = strlen(cname);
    max_len = cname_size - 16;
    if (len > max_len)
        cname[max_len] = '\0';
    suffix_num = 1;
    for(;;) {
        snprintf(cname1, sizeof(cname1), "%s_%d", cname, suffix_num);
        if (!namelist_find(&cname_list, cname1))
            break;
        suffix_num++;
    }
    pstrcpy(cname, cname_size, cname1);
}

JSModuleDef *jsc_module_loader(JSContext *ctx,
                              const char *module_name, void *opaque)
{
    JSModuleDef *m;
    namelist_entry_t *e;

    /* check if it is a declared C or system module */
    e = namelist_find(&cmodule_list, module_name);
    if (e) {
        /* add in the static init module list */
        namelist_add(&init_module_list, e->name, e->short_name, 0);
        /* create a dummy module */
        m = JS_NewCModule(ctx, module_name, js_module_dummy_init);
    } else if (has_suffix(module_name, ".so")) {
        fprintf(stderr, "Warning: binary module '%s' will be dynamically loaded\n", module_name);
        /* create a dummy module */
        m = JS_NewCModule(ctx, module_name, js_module_dummy_init);
        /* the resulting executable will export its symbols for the
           dynamic library */
        dynamic_export = TRUE;
    } else {
        size_t buf_len;
        uint8_t *buf;
        JSValue func_val;
        char cname[1024];
        
        buf = js_load_file(ctx, &buf_len, module_name);
        if (!buf) {
            JS_ThrowReferenceError(ctx, "could not load module filename '%s'",
                                   module_name);
            return NULL;
        }
        
        /* compile the module */
        func_val = JS_Eval(ctx, (char *)buf, buf_len, module_name,
                           JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);
        js_free(ctx, buf);
        if (JS_IsException(func_val))
            return NULL;
        get_c_name(cname, sizeof(cname), module_name);
        if (namelist_find(&cname_list, cname)) {
            find_unique_cname(cname, sizeof(cname));
        }
        output_object_code(ctx, outfile, func_val, cname, TRUE);
        
        /* the module is already referenced, so we must free it */
        m = JS_VALUE_GET_PTR(func_val);
        JS_FreeValue(ctx, func_val);
    }
    return m;
}

static void compile_file(JSContext *ctx, FILE *fo,
                         const char *filename,
                         const char *c_name1,
                         int module)
{
    uint8_t *buf;
    char c_name[1024];
    int eval_flags;
    JSValue obj;
    size_t buf_len;
    
    buf = js_load_file(ctx, &buf_len, filename);
    if (!buf) {
        fprintf(stderr, "Could not load '%s'\n", filename);
        exit(1);
    }
    eval_flags = JS_EVAL_FLAG_COMPILE_ONLY;
    if (module < 0) {
        module = (has_suffix(filename, ".mjs") ||
                  JS_DetectModule((const char *)buf, buf_len));
    }
    if (module)
        eval_flags |= JS_EVAL_TYPE_MODULE;
    else
        eval_flags |= JS_EVAL_TYPE_GLOBAL;
    obj = JS_Eval(ctx, (const char *)buf, buf_len, filename, eval_flags);
    if (JS_IsException(obj)) {
        js_std_dump_error(ctx);
        exit(1);
    }
    js_free(ctx, buf);
    if (c_name1) {
        pstrcpy(c_name, sizeof(c_name), c_name1);
    } else {
        get_c_name(c_name, sizeof(c_name), filename);
    }
    output_object_code(ctx, fo, obj, c_name, FALSE);
    JS_FreeValue(ctx, obj);
}

static const char main_c_template1[] =
    "int main(int argc, char **argv)\n"
    "{\n"
    "  JSRuntime *rt;\n"
    "  JSContext *ctx;\n"
    "  rt = JS_NewRuntime();\n"
    "  js_std_set_worker_new_context_func(JS_NewCustomContext);\n"
    "  js_std_init_handlers(rt);\n"
    ;

static const char main_c_template2[] =
    "  js_std_loop(ctx);\n"
    "  JS_FreeContext(ctx);\n"
    "  JS_FreeRuntime(rt);\n"
    "  return 0;\n"
    "}\n";

#define PROG_NAME "qjsc"

void help(void)
{
    printf("QuickJS Compiler version " CONFIG_VERSION "\n"
           "usage: " PROG_NAME " [options] [files]\n"
           "\n"
           "options are:\n"
           "-c          only output bytecode in a C file\n"
           "-e          output main() and bytecode in a C file (default = executable output)\n"
           "-o output   set the output filename\n"
           "-N cname    set the C name of the generated data\n"
           "-m          compile as Javascript module (default=autodetect)\n"
           "-D module_name         compile a dynamically loaded module or worker\n"
           "-M module_name[,cname] add initialization code for an external C module\n"
           "-x          byte swapped output\n"
           "-p prefix   set the prefix of the generated C names\n"
           "-S n        set the maximum stack size to 'n' bytes (default=%d)\n",
           JS_DEFAULT_STACK_SIZE);
#ifdef CONFIG_LTO
    {
        int i;
        printf("-flto       use link time optimization\n");
        printf("-fbignum    enable bignum extensions\n");
        printf("-fno-[");
        for(i = 0; i < countof(feature_list); i++) {
            if (i != 0)
                printf("|");
            printf("%s", feature_list[i].option_name);
        }
        printf("]\n"
               "            disable selected language features (smaller code size)\n");
    }
#endif
    exit(1);
}

#if defined(CONFIG_CC) && !defined(_WIN32)

int exec_cmd(char **argv)
{
    int pid, status, ret;

    pid = fork();
    if (pid == 0) {
        execvp(argv[0], argv);
        exit(1);
    } 

    for(;;) {
        ret = waitpid(pid, &status, 0);
        if (ret == pid && WIFEXITED(status))
            break;
    }
    return WEXITSTATUS(status);
}

static int output_executable(const char *out_filename, const char *cfilename,
                             BOOL use_lto, BOOL verbose, const char *exename)
{
    const char *argv[64];
    const char **arg, *bn_suffix, *lto_suffix;
    char libjsname[1024];
    char exe_dir[1024], inc_dir[1024], lib_dir[1024], buf[1024], *p;
    int ret;
    
    /* get the directory of the executable */
    pstrcpy(exe_dir, sizeof(exe_dir), exename);
    p = strrchr(exe_dir, '/');
    if (p) {
        *p = '\0';
    } else {
        pstrcpy(exe_dir, sizeof(exe_dir), ".");
    }

    /* if 'quickjs.h' is present at the same path as the executable, we
       use it as include and lib directory */
    snprintf(buf, sizeof(buf), "%s/quickjs.h", exe_dir);
    if (access(buf, R_OK) == 0) {
        pstrcpy(inc_dir, sizeof(inc_dir), exe_dir);
        pstrcpy(lib_dir, sizeof(lib_dir), exe_dir);
    } else {
        snprintf(inc_dir, sizeof(inc_dir), "%s/include/quickjs", CONFIG_PREFIX);
        snprintf(lib_dir, sizeof(lib_dir), "%s/lib/quickjs", CONFIG_PREFIX);
    }
    
    lto_suffix = "";
    bn_suffix = "";
    
    arg = argv;
    *arg++ = CONFIG_CC;
    *arg++ = "-O2";
#ifdef CONFIG_LTO
    if (use_lto) {
        *arg++ = "-flto";
        lto_suffix = ".lto";
    }
#endif
    /* XXX: use the executable path to find the includes files and
       libraries */
    *arg++ = "-D";
    *arg++ = "_GNU_SOURCE";
    *arg++ = "-I";
    *arg++ = inc_dir;
    *arg++ = "-o";
    *arg++ = out_filename;
    if (dynamic_export)
        *arg++ = "-rdynamic";
    *arg++ = cfilename;
    snprintf(libjsname, sizeof(libjsname), "%s/libquickjs%s%s.a",
             lib_dir, bn_suffix, lto_suffix);
    *arg++ = libjsname;
    *arg++ = "-lm";
    *arg++ = "-ldl";
    *arg++ = "-lpthread";
    *arg = NULL;
    
    if (verbose) {
        for(arg = argv; *arg != NULL; arg++)
            printf("%s ", *arg);
        printf("\n");
    }
    
    ret = exec_cmd((char **)argv);
    unlink(cfilename);
    return ret;
}
#else
static int output_executable(const char *out_filename, const char *cfilename,
                             BOOL use_lto, BOOL verbose, const char *exename)
{
    fprintf(stderr, "Executable output is not supported for this target\n");
    exit(1);
    return 0;
}
#endif

typedef enum {
    OUTPUT_C,
    OUTPUT_C_MAIN,
    OUTPUT_EXECUTABLE,
} OutputTypeEnum;

int main(int argc, char **argv)
{
    int c, i, verbose;
    const char *out_filename, *cname;
    char cfilename[1024];
    FILE *fo;
    JSRuntime *rt;
    JSContext *ctx;
    BOOL use_lto;
    int module;
    OutputTypeEnum output_type;
    size_t stack_size;
#ifdef CONFIG_BIGNUM
    BOOL bignum_ext = FALSE;
#endif
    namelist_t dynamic_module_list;
    
    out_filename = NULL;
    output_type = OUTPUT_EXECUTABLE;
    cname = NULL;
    feature_bitmap = FE_ALL;
    module = -1;
    byte_swap = FALSE;
    verbose = 0;
    use_lto = FALSE;
    stack_size = 0;
    memset(&dynamic_module_list, 0, sizeof(dynamic_module_list));
    
    /* add system modules */
    namelist_add(&cmodule_list, "std", "std", 0);
    namelist_add(&cmodule_list, "os", "os", 0);

    for(;;) {
        c = getopt(argc, argv, "ho:cN:f:mxevM:p:S:D:");
        if (c == -1)
            break;
        switch(c) {
        case 'h':
            help();
        case 'o':
            out_filename = optarg;
            break;
        case 'c':
            output_type = OUTPUT_C;
            break;
        case 'e':
            output_type = OUTPUT_C_MAIN;
            break;
        case 'N':
            cname = optarg;
            break;
        case 'f':
            {
                const char *p;
                p = optarg;
                if (!strcmp(optarg, "lto")) {
                    use_lto = TRUE;
                } else if (strstart(p, "no-", &p)) {
                    use_lto = TRUE;
                    for(i = 0; i < countof(feature_list); i++) {
                        if (!strcmp(p, feature_list[i].option_name)) {
                            feature_bitmap &= ~((uint64_t)1 << i);
                            break;
                        }
                    }
                    if (i == countof(feature_list))
                        goto bad_feature;
                } else
#ifdef CONFIG_BIGNUM
                if (!strcmp(optarg, "bignum")) {
                    bignum_ext = TRUE;
                } else
#endif
                {
                bad_feature:
                    fprintf(stderr, "unsupported feature: %s\n", optarg);
                    exit(1);
                }
            }
            break;
        case 'm':
            module = 1;
            break;
        case 'M':
            {
                char *p;
                char path[1024];
                char cname[1024];
                pstrcpy(path, sizeof(path), optarg);
                p = strchr(path, ',');
                if (p) {
                    *p = '\0';
                    pstrcpy(cname, sizeof(cname), p + 1);
                } else {
                    get_c_name(cname, sizeof(cname), path);
                }
                namelist_add(&cmodule_list, path, cname, 0);
            }
            break;
        case 'D':
            namelist_add(&dynamic_module_list, optarg, NULL, 0);
            break;
        case 'x':
            byte_swap = TRUE;
            break;
        case 'v':
            verbose++;
            break;
        case 'p':
            c_ident_prefix = optarg;
            break;
        case 'S':
            stack_size = (size_t)strtod(optarg, NULL);
            break;
        default:
            break;
        }
    }

    if (optind >= argc)
        help();

    if (!out_filename) {
        if (output_type == OUTPUT_EXECUTABLE) {
            out_filename = "a.out";
        } else {
            out_filename = "out.c";
        }
    }

    if (output_type == OUTPUT_EXECUTABLE) {
#if defined(_WIN32) || defined(__ANDROID__)
        /* XXX: find a /tmp directory ? */
        snprintf(cfilename, sizeof(cfilename), "out%d.c", getpid());
#else
        snprintf(cfilename, sizeof(cfilename), "/tmp/out%d.c", getpid());
#endif
    } else {
        pstrcpy(cfilename, sizeof(cfilename), out_filename);
    }
    
    fo = fopen(cfilename, "w");
    if (!fo) {
        perror(cfilename);
        exit(1);
    }
    outfile = fo;
    
    rt = JS_NewRuntime();
    ctx = JS_NewContext(rt);
#ifdef CONFIG_BIGNUM
    if (bignum_ext) {
        JS_AddIntrinsicBigFloat(ctx);
        JS_AddIntrinsicBigDecimal(ctx);
        JS_AddIntrinsicOperators(ctx);
        JS_EnableBignumExt(ctx, TRUE);
    }
#endif
    
    /* loader for ES6 modules */
    JS_SetModuleLoaderFunc(rt, NULL, jsc_module_loader, NULL);

    fprintf(fo, "/* File generated automatically by the QuickJS compiler. */\n"
            "\n"
            );
    
    if (output_type != OUTPUT_C) {
        fprintf(fo, "#include \"quickjs-libc.h\"\n"
                "\n"
                );
    } else {
        fprintf(fo, "#include <inttypes.h>\n"
                "\n"
                );
    }

    for(i = optind; i < argc; i++) {
        const char *filename = argv[i];
        compile_file(ctx, fo, filename, cname, module);
        cname = NULL;
    }

    for(i = 0; i < dynamic_module_list.count; i++) {
        if (!jsc_module_loader(ctx, dynamic_module_list.array[i].name, NULL)) {
            fprintf(stderr, "Could not load dynamic module '%s'\n",
                    dynamic_module_list.array[i].name);
            exit(1);
        }
    }
    
    if (output_type != OUTPUT_C) {
        fprintf(fo,
                "static JSContext *JS_NewCustomContext(JSRuntime *rt)\n"
                "{\n"
                "  JSContext *ctx = JS_NewContextRaw(rt);\n"
                "  if (!ctx)\n"
                "    return NULL;\n");
        /* add the basic objects */
        fprintf(fo, "  JS_AddIntrinsicBaseObjects(ctx);\n");
        for(i = 0; i < countof(feature_list); i++) {
            if ((feature_bitmap & ((uint64_t)1 << i)) &&
                feature_list[i].init_name) {
                fprintf(fo, "  JS_AddIntrinsic%s(ctx);\n",
                        feature_list[i].init_name);
            }
        }
#ifdef CONFIG_BIGNUM
        if (bignum_ext) {
            fprintf(fo,
                    "  JS_AddIntrinsicBigFloat(ctx);\n"
                    "  JS_AddIntrinsicBigDecimal(ctx);\n"
                    "  JS_AddIntrinsicOperators(ctx);\n"
                    "  JS_EnableBignumExt(ctx, 1);\n");
        }
#endif
        /* add the precompiled modules (XXX: could modify the module
           loader instead) */
        for(i = 0; i < init_module_list.count; i++) {
            namelist_entry_t *e = &init_module_list.array[i];
            /* initialize the static C modules */
            
            fprintf(fo,
                    "  {\n"
                    "    extern JSModuleDef *js_init_module_%s(JSContext *ctx, const char *name);\n"
                    "    js_init_module_%s(ctx, \"%s\");\n"
                    "  }\n",
                    e->short_name, e->short_name, e->name);
        }
        for(i = 0; i < cname_list.count; i++) {
            namelist_entry_t *e = &cname_list.array[i];
            if (e->flags) {
                fprintf(fo, "  js_std_eval_binary(ctx, %s, %s_size, 1);\n",
                        e->name, e->name);
            }
        }
        fprintf(fo,
                "  return ctx;\n"
                "}\n\n");
        
        fputs(main_c_template1, fo);

        if (stack_size != 0) {
            fprintf(fo, "  JS_SetMaxStackSize(rt, %u);\n",
                    (unsigned int)stack_size);
        }
        
        /* add the module loader if necessary */
        if (feature_bitmap & (1 << FE_MODULE_LOADER)) {
            fprintf(fo, "  JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);\n");
        }
        
        fprintf(fo,
                "  ctx = JS_NewCustomContext(rt);\n"
                "  js_std_add_helpers(ctx, argc, argv);\n");

        for(i = 0; i < cname_list.count; i++) {
            namelist_entry_t *e = &cname_list.array[i];
            if (!e->flags) {
                fprintf(fo, "  js_std_eval_binary(ctx, %s, %s_size, 0);\n",
                        e->name, e->name);
            }
        }
        fputs(main_c_template2, fo);
    }
    
    JS_FreeContext(ctx);
    JS_FreeRuntime(rt);

    fclose(fo);

    if (output_type == OUTPUT_EXECUTABLE) {
        return output_executable(out_filename, cfilename, use_lto, verbose,
                                 argv[0]);
    }
    namelist_free(&cname_list);
    namelist_free(&cmodule_list);
    namelist_free(&init_module_list);
    return 0;
}

'''
'''--- qjscalc.js ---
/*
 * QuickJS Javascript Calculator
 * 
 * Copyright (c) 2017-2020 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
"use strict";
"use math";

var Integer, Float, Fraction, Complex, Mod, Polynomial, PolyMod, RationalFunction, Series, Matrix;

(function(global) {
    global.Integer = global.BigInt;
    global.Float = global.BigFloat;
    global.algebraicMode = true;
    
    /* add non enumerable properties */
    function add_props(obj, props) {
        var i, val, prop, tab, desc;
        tab = Reflect.ownKeys(props);
        for(i = 0; i < tab.length; i++) {
            prop = tab[i];
            desc = Object.getOwnPropertyDescriptor(props, prop);
            desc.enumerable = false;
            if ("value" in desc) {
                if (typeof desc.value !== "function") {
                    desc.writable = false;
                    desc.configurable = false;
                }
            } else {
                /* getter/setter */
                desc.configurable = false;
            }
            Object.defineProperty(obj, prop, desc);
        }
    }

    /* same as proto[Symbol.operatorSet] = Operators.create(..op_list)
       but allow shortcuts: left: [], right: [] or both
    */
    function operators_set(proto, ...op_list)
    {
        var new_op_list, i, a, j, b, k, obj, tab;
        var fields = [ "left", "right" ];
        new_op_list = [];
        for(i = 0; i < op_list.length; i++) {
            a = op_list[i];
            if (a.left || a.right) {
                tab = [ a.left, a.right ];
                delete a.left;
                delete a.right;
                for(k = 0; k < 2; k++) {
                    obj = tab[k];
                    if (obj) {
                        if (!Array.isArray(obj)) {
                            obj = [ obj ];
                        }
                        for(j = 0; j < obj.length; j++) {
                            b = {};
                            Object.assign(b, a);
                            b[fields[k]] = obj[j];
                            new_op_list.push(b);
                        }
                    }
                }
            } else {
                new_op_list.push(a);
            }
        }
        proto[Symbol.operatorSet] =
            Operators.create.call(null, ...new_op_list); 
    }
    
    /* Integer */

    function generic_pow(a, b) {
        var r, is_neg, i;
        if (!Integer.isInteger(b)) {
            return exp(log(a) * b);
        }
        if (Array.isArray(a) && !(a instanceof Polynomial ||
                                  a instanceof Series)) {
            r = idn(Matrix.check_square(a));
        } else {
            r = 1;
        }
        if (b == 0)
            return r;
        is_neg = false;
        if (b < 0) {
            is_neg = true;
            b = -b;
        }
        r = a;
        for(i = Integer.floorLog2(b) - 1; i >= 0; i--) {
            r *= r;
            if ((b >> i) & 1)
                r *= a;
        }
        if (is_neg) {
            if (typeof r.inverse != "function")
                throw "negative powers are not supported for this type";
            r = r.inverse();
        }
        return r;
    }
    
    var small_primes = [ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499 ];

    function miller_rabin_test(n, t) {
        var d, r, s, i, j, a;
        d = n - 1;
        s = 0;
        while ((d & 1) == 0) {
            d >>= 1;
            s++;
        }
        if (small_primes.length < t)
            t = small_primes.length;
        loop: for(j = 0; j < t; j++) {
            a = small_primes[j];
            r = Integer.pmod(a, d, n);
            if (r == 1 || r == (n - 1))
                continue;
            for(i = 1; i < s; i++) {
                r = (r * r) % n;
                if (r == 1)
                    return false;
                if (r == (n - 1))
                    continue loop;
            }
            return false; /* n is composite */
        }
        return true; /* n is probably prime with probability (1-0.5^t) */
    }

    function fact_rec(a, b) {  /* assumes a <= b */
        var i, r;
        if ((b - a) <= 5) {
            r = a;
            for(i = a + 1; i <= b; i++)
                r *= i;
            return r;
        } else {
            /* to avoid a quadratic running time it is better to
               multiply numbers of similar size */
            i = (a + b) >> 1;
            return fact_rec(a, i) * fact_rec(i + 1, b);
        }
    }

    /* math mode specific quirk to overload the integer division and power */
    Operators.updateBigIntOperators(
        {
            "/"(a, b) {
                if (algebraicMode) {
                    return Fraction.toFraction(a, b);
                } else {
                    return Float(a) / Float(b);
                }
            },
            "**"(a, b) {
                if (algebraicMode) {
                    return generic_pow(a, b);
                } else {
                    return Float(a) ** Float(b);
                }
            }
        });
            
    add_props(Integer, {
        isInteger(a) {
            /* integers are represented either as bigint or as number */
            return typeof a === "bigint" ||
                (typeof a === "number" && Number.isSafeInteger(a));
        },
        gcd(a, b) {
            var r;
            while (b != 0) {
                r = a % b;
                a = b;
                b = r;
            }
            return a;
        },
        fact(n) {
            return n <= 0 ? 1 : fact_rec(1, n);
        },
        /* binomial coefficient */
        comb(n, k) {
            if (k < 0 || k > n)
                return 0;
            if (k > n - k)
                k = n - k;
            if (k == 0)
                return 1;
            return Integer.tdiv(fact_rec(n - k + 1, n), fact_rec(1, k));
        },
        /* inverse of x modulo y */
        invmod(x, y) {
            var q, u, v, a, c, t;
            u = x;
            v = y;
            c = 1;
            a = 0;
            while (u != 0) {
                t = Integer.fdivrem(v, u);
                q = t[0];
                v = u;
                u = t[1];
                t = c;
                c = a - q * c;
                a = t;
            }
            /* v = gcd(x, y) */
            if (v != 1)
                throw RangeError("not invertible");
            return a % y;
        },
        /* return a ^ b modulo m */
        pmod(a, b, m) {
            var r;
            if (b == 0)
                return 1;
            if (b < 0) {
                a = Integer.invmod(a, m);
                b = -b;
            }
            r = 1;
            for(;;) {
                if (b & 1) {
                    r = (r * a) % m;
                }
                b >>= 1;
                if (b == 0)
                    break;
                a = (a * a) % m;
            }
            return r;
        },

        /* return true if n is prime (or probably prime with
           probability 1-0.5^t) */
        isPrime(n, t) {
            var i, d, n1;
            if (!Integer.isInteger(n))
                throw TypeError("invalid type");
            if (n <= 1)
                return false;
            n1 = small_primes.length;
            /* XXX: need Integer.sqrt() */
            for(i = 0; i < n1; i++) {
                d = small_primes[i];
                if (d == n)
                    return true;
                if (d > n)
                    return false;
                if ((n % d) == 0)
                    return false;
            }
            if (n < d * d)
                return true;
            if (typeof t == "undefined")
                t = 64;
            return miller_rabin_test(n, t);
        },
        nextPrime(n) {
            if (!Integer.isInteger(n))
                throw TypeError("invalid type");
            if (n < 1)
                n = 1;
            for(;;) {
                n++;
                if (Integer.isPrime(n))
                    return n;
            }
        },
        factor(n) {
            var r, d;
            if (!Integer.isInteger(n))
                throw TypeError("invalid type");
            r = [];
            if (abs(n) <= 1) {
                r.push(n);
                return r;
            }
            if (n < 0) {
                r.push(-1);
                n = -n;
            }
            
            while ((n % 2) == 0) {
                n >>= 1;
                r.push(2);
            }

            d = 3;
            while (n != 1) {
                if (Integer.isPrime(n)) {
                    r.push(n);
                    break;
                }
                /* we are sure there is at least one divisor, so one test */
                for(;;) {
                    if ((n % d) == 0)
                        break;
                    d += 2;
                }
                for(;;) {
                    r.push(d);
                    n = Integer.tdiv(n, d);
                    if ((n % d) != 0)
                        break;
                }
            }
            return r;
        },
    });

    add_props(Integer.prototype, {
        inverse() {
            return 1 / this;
        },
        norm2() {
            return this * this;
        },
        abs() {
            var v = this;
            if (v < 0)
                v = -v;
            return v;
        },
        conj() {
            return this;
        },
        arg() {
            if (this >= 0)
                return 0;
            else
                return Float.PI;
        },
        exp() {
            if (this == 0)
                return 1;
            else
                return Float.exp(this);
        },
        log() {
            if (this == 1)
                return 0;
            else
                return Float(this).log();
        },
    });

    /* Fraction */

    Fraction = function Fraction(a, b)
    {
        var d, r, obj;

        if (new.target)
            throw TypeError("not a constructor");
        if (a instanceof Fraction)
            return a;
        if (!Integer.isInteger(a))
            throw TypeError("integer expected");
        if (typeof b === "undefined") {
            b = 1;
        } else {
            if (!Integer.isInteger(b))
                throw TypeError("integer expected");
            if (b == 0)
                throw RangeError("division by zero");
            d = Integer.gcd(a, b);
            if (d != 1) {
                a = Integer.tdiv(a, d);
                b = Integer.tdiv(b, d);
            }
            
            /* the fractions are normalized with den > 0 */
            if (b < 0) {
                a = -a;
                b = -b;
            }
        }
        obj = Object.create(Fraction.prototype);
        obj.num = a;
        obj.den = b;
        return obj;
    }

    function fraction_add(a, b) {
        a = Fraction(a);
        b = Fraction(b);
        return Fraction.toFraction(a.num * b.den + a.den * b.num, a.den * b.den);
    }
    function fraction_sub(a, b) {
        a = Fraction(a);
        b = Fraction(b);
        return Fraction.toFraction(a.num * b.den - a.den * b.num, a.den * b.den);
    }
    function fraction_mul(a, b) {
        a = Fraction(a);
        b = Fraction(b);
        return Fraction.toFraction(a.num * b.num, a.den * b.den);
    }
    function fraction_div(a, b) {
        a = Fraction(a);
        b = Fraction(b);
        return Fraction.toFraction(a.num * b.den, a.den * b.num);
    }
    function fraction_mod(a, b) {
        var a1 = Fraction(a);
        var b1 = Fraction(b);
        return a - Integer.ediv(a1.num * b1.den, a1.den * b1.num) * b;
    }
    function fraction_eq(a, b) {
        a = Fraction(a);
        b = Fraction(b);
        /* we assume the fractions are normalized */
        return (a.num == b.num && a.den == b.den);
    }
    function fraction_lt(a, b) {
        a = Fraction(a);
        b = Fraction(b);
        return (a.num * b.den < b.num * a.den);
    }

    /* operators are needed for fractions */
    function float_add(a, b) {
        return Float(a) + Float(b);
    }
    function float_sub(a, b) {
        return Float(a) - Float(b);
    }
    function float_mul(a, b) {
        return Float(a) * Float(b);
    }
    function float_div(a, b) {
        return Float(a) / Float(b);
    }
    function float_mod(a, b) {
        return Float(a) % Float(b);
    }
    function float_pow(a, b) {
        return Float(a) ** Float(b);
    }
    function float_eq(a, b) {
        /* XXX: may be better to use infinite precision for the comparison */
        return Float(a) === Float(b);
    }
    function float_lt(a, b) {
        a = Float(a);
        b = Float(b);
        /* XXX: may be better to use infinite precision for the comparison */
        if (Float.isNaN(a) || Float.isNaN(b))
            return undefined;
        else
            return a < b;
    }
    
    operators_set(Fraction.prototype,
        {
            "+": fraction_add,
            "-": fraction_sub,
            "*": fraction_mul,
            "/": fraction_div,
            "%": fraction_mod,
            "**": generic_pow,
            "==": fraction_eq,
            "<": fraction_lt,
            "pos"(a) {
                return a;
            },
            "neg"(a) {
                return Fraction(-a.num, a.den);
            },
        },
        {
            left: [Number, BigInt],
            right: [Number, BigInt],
            "+": fraction_add,
            "-": fraction_sub,
            "*": fraction_mul,
            "/": fraction_div,
            "%": fraction_mod,
            "**": generic_pow,
            "==": fraction_eq,
            "<": fraction_lt,
        },
        {
            left: Float,
            right: Float,
            "+": float_add,
            "-": float_sub,
            "*": float_mul,
            "/": float_div,
            "%": float_mod,
            "**": float_pow,
            "==": float_eq,
            "<": float_lt,
        });
    
    add_props(Fraction, {
        /* (internal use) simplify 'a' to an integer when possible */
        toFraction(a, b) {
            var r = Fraction(a, b);
            if (algebraicMode && r.den == 1)
                return r.num;
            else
                return r;
        },
    });

    add_props(Fraction.prototype, {
        [Symbol.toPrimitive](hint) {
            if (hint === "string") {
                return this.toString();
            } else {
                return Float(this.num) / this.den;
            }
        },
        inverse() {
            return Fraction(this.den, this.num);
        },
        toString() {
            return this.num + "/" + this.den;
        },
        norm2() {
            return this * this;
        },
        abs() {
            if (this.num < 0)
                return -this;
            else
                return this;
        },
        conj() {
            return this;
        },
        arg() {
            if (this.num >= 0)
                return 0;
            else
                return Float.PI;
        },
        exp() {
            return Float.exp(Float(this));
        },
        log() {
            return Float(this).log();
        },
    });

    /* Number (Float64) */

    add_props(Number.prototype, {
        inverse() {
            return 1 / this;
        },
        norm2() {
            return this * this;
        },
        abs() {
            return Math.abs(this);
        },
        conj() {
            return this;
        },
        arg() {
            if (this >= 0)
                return 0;
            else
                return Float.PI;
        },
        exp() {
            return Float.exp(this);
        },
        log() {
            if (this < 0) {
                return Complex(this).log();
            } else {
                return Float.log(this);
            }
        },
    });
    
    /* Float */

    var const_tab = [];
    
    /* we cache the constants for small precisions */
    function get_const(n) {
        var t, c, p;
        t = const_tab[n];
        p = BigFloatEnv.prec;
        if (t && t.prec == p) {
            return t.val;
        } else {
            switch(n) {
            case 0: c = Float.exp(1); break;
            case 1: c = Float.log(10); break;
//            case 2: c = Float.log(2); break;
            case 3: c = 1/Float.log(2); break;
            case 4: c = 1/Float.log(10); break;
//            case 5: c = Float.atan(1) * 4; break;
            case 6: c = Float.sqrt(0.5); break;
            case 7: c = Float.sqrt(2); break;
            }
            if (p <= 1024) {
                const_tab[n] = { prec: p, val: c };
            }
            return c;
        }
    }
    
    add_props(Float, {
        isFloat(a) {
            return typeof a === "number" || typeof a === "bigfloat";
        },
        bestappr(u, b) {
            var num1, num0, den1, den0, u, num, den, n;

            if (typeof b === "undefined")
                throw TypeError("second argument expected");
            num1 = 1;
            num0 = 0;
            den1 = 0;
            den0 = 1;
            for(;;) {
                n = Integer(Float.floor(u));
                num = n * num1 + num0;
                den = n * den1 + den0;
                if (den > b)
                    break;
                u = 1.0 / (u - n);
                num0 = num1;
                num1 = num;
                den0 = den1;
                den1 = den;
            }
            return Fraction(num1, den1);
        },
        /* similar constants as Math.x */
        get E() { return get_const(0); },
        get LN10() { return get_const(1); },
//        get LN2() { return get_const(2); },
        get LOG2E() { return get_const(3); },
        get LOG10E() { return get_const(4); },
//        get PI() { return get_const(5); },
        get SQRT1_2() { return get_const(6); },
        get SQRT2() { return get_const(7); },
    });

    add_props(Float.prototype, {
        inverse() {
            return 1.0 / this;
        },
        norm2() {
            return this * this;
        },
        abs() {
            return Float.abs(this);
        },
        conj() {
            return this;
        },
        arg() {
            if (this >= 0)
                return 0;
            else
                return Float.PI;
        },
        exp() {
            return Float.exp(this);
        },
        log() {
            if (this < 0) {
                return Complex(this).log();
            } else {
                return Float.log(this);
            }
        },
    });
       
    /* Complex */
    
    Complex = function Complex(re, im)
    {
        var obj;
        if (new.target)
            throw TypeError("not a constructor");
        if (re instanceof Complex)
            return re;
        if (typeof im === "undefined") {
            im = 0;
        }
        obj = Object.create(Complex.prototype);
        obj.re = re;
        obj.im = im;
        return obj;
    }

        
    function complex_add(a, b) {
        a = Complex(a);
        b = Complex(b);
        return Complex.toComplex(a.re + b.re, a.im + b.im);
    }
    function complex_sub(a, b) {
        a = Complex(a);
        b = Complex(b);
        return Complex.toComplex(a.re - b.re, a.im - b.im);
    }
    function complex_mul(a, b) {
        a = Complex(a);
        b = Complex(b);
        return Complex.toComplex(a.re * b.re - a.im * b.im,
                                 a.re * b.im + a.im * b.re);
    }
    function complex_div(a, b) {
        a = Complex(a);
        b = Complex(b);
        return a * b.inverse();
    }
    function complex_eq(a, b) {
        a = Complex(a);
        b = Complex(b);
        return a.re == b.re && a.im == b.im;
    }
    
    operators_set(Complex.prototype,
        {
            "+": complex_add,
            "-": complex_sub,
            "*": complex_mul,
            "/": complex_div,
            "**": generic_pow,
            "==": complex_eq,
            "pos"(a) {
                return a;
            },
            "neg"(a) {
                return Complex(-a.re, -a.im);
            }
        },
        {
            left: [Number, BigInt, Float, Fraction],
            right: [Number, BigInt, Float, Fraction],
            "+": complex_add,
            "-": complex_sub,
            "*": complex_mul,
            "/": complex_div,
            "**": generic_pow,
            "==": complex_eq,
        });
    
    add_props(Complex, {
        /* simplify to real number when possible */
        toComplex(re, im) {
            if (algebraicMode && im == 0)
                return re;
            else
                return Complex(re, im);
        },
    });

    add_props(Complex.prototype, {
        inverse() {
            var c = this.norm2();
            return Complex(this.re / c, -this.im / c);
        },
        toString() {
            var v, s = "", a = this;
            if (a.re != 0)
                s += a.re.toString();
            if (a.im == 1) {
                if (s != "")
                    s += "+";
                s += "I";
            } else if (a.im == -1) {
                s += "-I";
            } else {
                v = a.im.toString();
                if (v[0] != "-" && s != "")
                    s += "+";
                s += v + "*I";
            }
            return s;
        },
        norm2() {
            return this.re * this.re + this.im * this.im;
        },
        abs() {
            return Float.sqrt(norm2(this));
        },
        conj() {
            return Complex(this.re, -this.im);
        },
        arg() {
            return Float.atan2(this.im, this.re);
        },
        exp() {
            var arg = this.im, r = this.re.exp();
            return Complex(r * cos(arg), r * sin(arg));
        },
        log() {
            return Complex(abs(this).log(), atan2(this.im, this.re));
        },
    });

    /* Mod */

    Mod = function Mod(a, m) {
        var obj, t;
        if (new.target)
            throw TypeError("not a constructor");
        obj = Object.create(Mod.prototype);
        if (Integer.isInteger(m)) {
            if (m <= 0)
                throw RangeError("the modulo cannot be <= 0");
            if (Integer.isInteger(a)) {
                a %= m;
            } else if (a instanceof Fraction) {
                return Mod(a.num, m) / a.den;
            } else {
                throw TypeError("invalid types");
            }
        } else {
            throw TypeError("invalid types");
        }
        obj.res = a;
        obj.mod = m;
        return obj;
    };
    
    function mod_add(a, b) {
        if (!(a instanceof Mod)) {
            return Mod(a + b.res, b.mod);
        } else if (!(b instanceof Mod)) {
            return Mod(a.res + b, a.mod);
        } else {
            if (a.mod != b.mod)
                throw TypeError("different modulo for binary operator");
            return Mod(a.res + b.res, a.mod);
        }
    }
    function mod_sub(a, b) {
        if (!(a instanceof Mod)) {
            return Mod(a - b.res, b.mod);
        } else if (!(b instanceof Mod)) {
            return Mod(a.res - b, a.mod);
        } else {
            if (a.mod != b.mod)
                throw TypeError("different modulo for binary operator");
            return Mod(a.res - b.res, a.mod);
        }
    }
    function mod_mul(a, b) {
        if (!(a instanceof Mod)) {
            return Mod(a * b.res, b.mod);
        } else if (!(b instanceof Mod)) {
            return Mod(a.res * b, a.mod);
        } else {
            if (a.mod != b.mod)
                throw TypeError("different modulo for binary operator");
            return Mod(a.res * b.res, a.mod);
        }
    }
    function mod_div(a, b) {
        if (!(b instanceof Mod))
            b = Mod(b, a.mod);
        return mod_mul(a, b.inverse());
    }
    function mod_eq(a, b) {
        return (a.mod == b.mod && a.res == b.res);
    }

    operators_set(Mod.prototype,
        {
            "+": mod_add,
            "-": mod_sub,
            "*": mod_mul,
            "/": mod_div,
            "**": generic_pow,
            "==": mod_eq,
            "pos"(a) {
                return a;
            },
            "neg"(a) {
                return Mod(-a.res, a.mod);
            }
        },
        {
            left: [Number, BigInt, Float, Fraction],
            right: [Number, BigInt, Float, Fraction],
            "+": mod_add,
            "-": mod_sub,
            "*": mod_mul,
            "/": mod_div,
            "**": generic_pow,
        });

    add_props(Mod.prototype, {
        inverse() {
            var a = this, m = a.mod;
            if (Integer.isInteger(m)) {
                return Mod(Integer.invmod(a.res, m), m);
            } else {
                throw TypeError("unsupported type");
            }
        },
        toString() {
            return "Mod(" + this.res + "," + this.mod + ")";
        },
    });

    /* Polynomial */

    function polynomial_is_scalar(a)
    {
        if (typeof a === "number" ||
            typeof a === "bigint" ||
            typeof a === "bigfloat")
            return true;
        if (a instanceof Fraction ||
            a instanceof Complex ||
            a instanceof Mod)
            return true;
        return false;
    }
    
    Polynomial = function Polynomial(a)
    {
        if (new.target)
            throw TypeError("not a constructor");
        if (a instanceof Polynomial) {
            return a;
        } else if (Array.isArray(a)) {
            if (a.length == 0)
                a = [ 0 ];
            Object.setPrototypeOf(a, Polynomial.prototype);
            return a.trim();
        } else if (polynomial_is_scalar(a)) {
            a = [a];
            Object.setPrototypeOf(a, Polynomial.prototype);
            return a;
        } else {
            throw TypeError("invalid type");
        }
    }

    function number_need_paren(c)
    {
        return !(Integer.isInteger(c) ||
                 Float.isFloat(c) ||
                 c instanceof Fraction ||
                 (c instanceof Complex && c.re == 0));
    }

    /* string for c*X^i */
    function monomial_toString(c, i)
    {
        var str1;
        if (i == 0) {
            str1 = c.toString();
        } else {
            if (c == 1) {
                str1 = "";
            } else if (c == -1) {
                str1 = "-";
            } else {
                if (number_need_paren(c)) {
                    str1 = "(" + c + ")";
                } else {
                    str1 = String(c);
                }
                str1 += "*";
            }
            str1 += "X";
            if (i != 1) {
                str1 += "^" + i;
            }
        }
        return str1;
    }

    /* find one complex root of 'p' starting from z at precision eps using
       at most max_it iterations. Return null if could not find root. */
    function poly_root_laguerre1(p, z, max_it)
    {
        var p1, p2, i, z0, z1, z2, d, t0, t1, d1, d2, e, el, zl;

        d = p.deg();
        if (d == 1) {
            /* monomial case */
            return -p[0] / p[1];
        }
        /* trivial zero */
        if (p[0] == 0)
            return 0.0;
        
        p1 = p.deriv();
        p2 = p1.deriv();
        el = 0.0;
        zl = 0.0;
        for(i = 0; i < max_it; i++) {
            z0 = p.apply(z);
            if (z0 == 0)
                return z; /* simple exit case */

            /* Ward stopping criteria */
            e = abs(z - zl);
//            print("e", i, e);
            if (i >= 2 && e >= el) {
                if (abs(zl) < 1e-4) {
                    if (e < 1e-7)
                        return zl;
                } else {
                    if (e < abs(zl) * 1e-3)
                        return zl;
                }
            }
            el = e;
            zl = z;
            
            z1 = p1.apply(z);
            z2 = p2.apply(z);
            t0 = (d - 1) * z1;
            t0 = t0 * t0;
            t1 = d * (d - 1) * z0 * z2;
            t0 = sqrt(t0 - t1);
            d1 = z1 + t0;
            d2 = z1 - t0;
            if (norm2(d2) > norm2(d1))
                d1 = d2;
            if (d1 == 0) 
                return null;
            z = z - d * z0 / d1;
        }
        return null;
    }

    function poly_roots(p)
    {
        var d, i, roots, j, z, eps;
        var start_points = [ 0.1, -1.4, 1.7 ];

        if (!(p instanceof Polynomial))
            throw TypeError("polynomial expected");
        d = p.deg();
        if (d <= 0)
            return [];
        eps = 2.0 ^ (-BigFloatEnv.prec);
        roots = [];
        for(i = 0; i < d; i++) {
            /* XXX: should select another start point if error */
            for(j = 0; j < 3; j++) {
                z = poly_root_laguerre1(p, start_points[j], 100);
                if (z !== null)
                    break;
            }
            if (j == 3)
                throw RangeError("error in root finding algorithm");
            roots[i] = z;
            p = Polynomial.divrem(p, X - z)[0];
        }
        return roots;
    }

    add_props(Polynomial.prototype, {
        trim() {
            var a = this, i;
            i = a.length;
            while (i > 1 && a[i - 1] == 0)
                i--;
            a.length = i;
            return a;
        },
        conj() {
            var r, i, n, a;
            a = this;
            n = a.length;
            r = [];
            for(i = 0; i < n; i++)
                r[i] = a[i].conj();
            return Polynomial(r);
        },
        inverse() {
            return RationalFunction(Polynomial([1]), this);
        },
        toString() {
            var i, str, str1, c, a = this;
            if (a.length == 1) {
                return a[0].toString();
            }
            str="";
            for(i = a.length - 1; i >= 0; i--) {
                c = a[i];
                if (c == 0 ||
                    (c instanceof Mod) && c.res == 0)
                    continue;
                str1 = monomial_toString(c, i);
                if (str1[0] != "-") {
                    if (str != "")
                        str += "+";
                }
                str += str1;
            }
            return str;
        },
        deg() {
            if (this.length == 1 && this[0] == 0)
                return -Infinity;
            else
                return this.length - 1;
        },
        apply(b) {
            var i, n, r, a = this;
            n = a.length - 1;
            r = a[n];
            while (n > 0) {
                n--;
                r = r * b + a[n];
            }
            return r;
        },
        deriv() {
            var a = this, n, r, i;
            n = a.length;
            if (n == 1) {
                return Polynomial(0);
            } else {
                r = [];
                for(i = 1; i < n; i++) {
                    r[i - 1] = i * a[i];
                }
                return Polynomial(r);
            }
        },
        integ() {
            var a = this, n, r, i;
            n = a.length;
            r = [0];
            for(i = 0; i < n; i++) {
                r[i + 1] = a[i] / (i + 1);
            }
            return Polynomial(r);
        },
        norm2() {
            var a = this, n, r, i;
            n = a.length;
            r = 0;
            for(i = 0; i < n; i++) {
                r += a[i].norm2();
            }
            return r;
        },
    });

    function polynomial_add(a, b) {
        var tmp, r, i, n1, n2;
        a = Polynomial(a);
        b = Polynomial(b);
        if (a.length < b.length) {
            tmp = a;
            a = b;
            b = tmp;
        }
        n1 = b.length;
        n2 = a.length;
        r = [];
        for(i = 0; i < n1; i++)
            r[i] = a[i] + b[i];
        for(i = n1; i < n2; i++)
            r[i] = a[i];
        return Polynomial(r);
    }
    function polynomial_sub(a, b) {
        return polynomial_add(a, -b);
    }
    function polynomial_mul(a, b) {
        var i, j, n1, n2, n, r;
        a = Polynomial(a);
        b = Polynomial(b);
        n1 = a.length;
        n2 = b.length;
        n = n1 + n2 - 1;
        r = [];
        for(i = 0; i < n; i++)
            r[i] = 0;
        for(i = 0; i < n1; i++) {
            for(j = 0; j < n2; j++) {
                r[i + j] += a[i] * b[j];
            }
        }
        return Polynomial(r);
    }
    function polynomial_div_scalar(a, b) {
        return a * (1 / b);
    }
    function polynomial_div(a, b)
    {
        return RationalFunction(Polynomial(a),
                                Polynomial(b));
    }
    function polynomial_mod(a, b) {
        return Polynomial.divrem(a, b)[1];
    }
    function polynomial_eq(a, b) {
        var n, i;
        n = a.length;
        if (n != b.length)
            return false;
        for(i = 0; i < n; i++) {
            if (a[i] != b[i])
                return false;
        }
        return true;
    }

    operators_set(Polynomial.prototype,
        {
            "+": polynomial_add,
            "-": polynomial_sub,
            "*": polynomial_mul,
            "/": polynomial_div,
            "**": generic_pow,
            "==": polynomial_eq,
            "pos"(a) {
                return a;
            },
            "neg"(a) {
                var r, i, n, a;
                n = a.length;
                r = [];
                for(i = 0; i < n; i++)
                r[i] = -a[i];
                return Polynomial(r);
            },
        },
        {
            left: [Number, BigInt, Float, Fraction, Complex, Mod],
            "+": polynomial_add,
            "-": polynomial_sub,
            "*": polynomial_mul,
            "/": polynomial_div,
            "**": generic_pow, /* XXX: only for integer */
        },
        {
            right: [Number, BigInt, Float, Fraction, Complex, Mod],
            "+": polynomial_add,
            "-": polynomial_sub,
            "*": polynomial_mul,
            "/": polynomial_div_scalar,
            "**": generic_pow, /* XXX: only for integer */
        });
    
    add_props(Polynomial, {
        divrem(a, b) {
            var n1, n2, i, j, q, r, n, c;
            if (b.deg() < 0)
                throw RangeError("division by zero");
            n1 = a.length;
            n2 = b.length;
            if (n1 < n2)
                return [Polynomial([0]), a];
            r = Array.prototype.dup.call(a);
            q = [];
            n2--;
            n = n1 - n2;
            for(i = 0; i < n; i++)
                q[i] = 0;
            for(i = n - 1; i >= 0; i--) {
                c = r[i + n2];
                if (c != 0) {
                    c = c / b[n2];
                    r[i + n2] = 0;
                    for(j = 0; j < n2; j++) {
                        r[i + j] -= b[j] * c;
                    }
                    q[i] = c;
                }
            }
            return [Polynomial(q), Polynomial(r)];
        },
        gcd(a, b) {
            var t;
            while (b.deg() >= 0) {
                t = Polynomial.divrem(a, b);
                a = b;
                b = t[1];
            }
            /* convert to monic form */
            return a / a[a.length - 1];
        },
        invmod(x, y) {
            var q, u, v, a, c, t;
            u = x;
            v = y;
            c = Polynomial([1]);
            a = Polynomial([0]);
            while (u.deg() >= 0) {
                t = Polynomial.divrem(v, u);
                q = t[0];
                v = u;
                u = t[1];
                t = c;
                c = a - q * c;
                a = t;
            }
            /* v = gcd(x, y) */
            if (v.deg() > 0)
                throw RangeError("not invertible");
            return Polynomial.divrem(a, y)[1];
        },
        roots(p) {
            return poly_roots(p);
        }
    });

    /* Polynomial Modulo Q */

    PolyMod = function PolyMod(a, m) {
        var obj, t;
        if (new.target)
            throw TypeError("not a constructor");
        obj = Object.create(PolyMod.prototype);
        if (m instanceof Polynomial) {
            if (m.deg() <= 0)
                throw RangeError("the modulo cannot have a degree <= 0");
            if (a instanceof RationalFunction) {
                return PolyMod(a.num, m) / a.den;
            } else {
                a = Polynomial(a);
                t = Polynomial.divrem(a, m);
                a = t[1];
            }
        } else {
            throw TypeError("invalid types");
        }
        obj.res = a;
        obj.mod = m;
        return obj;
    };

    function polymod_add(a, b) {
        if (!(a instanceof PolyMod)) {
            return PolyMod(a + b.res, b.mod);
        } else if (!(b instanceof PolyMod)) {
            return PolyMod(a.res + b, a.mod);
        } else {
            if (a.mod != b.mod)
                throw TypeError("different modulo for binary operator");
            return PolyMod(a.res + b.res, a.mod);
        }
    }
    function polymod_sub(a, b) {
        return polymod_add(a, -b);
    }
    function polymod_mul(a, b) {
        if (!(a instanceof PolyMod)) {
            return PolyMod(a * b.res, b.mod);
        } else if (!(b instanceof PolyMod)) {
            return PolyMod(a.res * b, a.mod);
        } else {
            if (a.mod != b.mod)
                    throw TypeError("different modulo for binary operator");
            return PolyMod(a.res * b.res, a.mod);
        }
    }
    function polymod_div(a, b) {
        if (!(b instanceof PolyMod))
            b = PolyMod(b, a.mod);
        return polymod_mul(a, b.inverse());
    }
    function polymod_eq(a, b) {
        return (a.mod == b.mod && a.res == b.res);
    }

    operators_set(PolyMod.prototype,
        {
            "+": polymod_add,
            "-": polymod_sub,
            "*": polymod_mul,
            "/": polymod_div,
            "**": generic_pow,
            "==": polymod_eq,
            "pos"(a) {
                return a;
            },
            "neg"(a) {
                return PolyMod(-a.res, a.mod);
            },
        },
        {
            left: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],
            right: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],
            "+": polymod_add,
            "-": polymod_sub,
            "*": polymod_mul,
            "/": polymod_div,
            "**": generic_pow, /* XXX: only for integer */
        });

    add_props(PolyMod.prototype, {
        inverse() {
            var a = this, m = a.mod;
            if (m instanceof Polynomial) {
                return PolyMod(Polynomial.invmod(a.res, m), m);
            } else {
                throw TypeError("unsupported type");
            }
        },
        toString() {
            return "PolyMod(" + this.res + "," + this.mod + ")";
        },
    });

    /* Rational function */
    
    RationalFunction = function RationalFunction(a, b)
    {
        var t, r, d, obj;
        if (new.target)
            throw TypeError("not a constructor");
        if (!(a instanceof Polynomial) ||
            !(b instanceof Polynomial))
            throw TypeError("polynomial expected");
        t = Polynomial.divrem(a, b);
        r = t[1];
        if (r.deg() < 0)
            return t[0]; /* no need for a fraction */
        d = Polynomial.gcd(b, r);
        if (d.deg() > 0) {
            a = Polynomial.divrem(a, d)[0];
            b = Polynomial.divrem(b, d)[0];
        }
        obj = Object.create(RationalFunction.prototype);
        obj.num = a;
        obj.den = b;
        return obj;
    }

    add_props(RationalFunction.prototype, {
        inverse() {
            return RationalFunction(this.den, this.num);
        },
        conj() {
            return RationalFunction(this.num.conj(), this.den.conj());
        },
        toString() {
            var str;
            if (this.num.deg() <= 0 &&
                !number_need_paren(this.num[0]))
                str = this.num.toString();
            else
                str = "(" + this.num.toString() + ")";
            str += "/(" + this.den.toString() + ")"
            return str;
        },
        apply(b) {
            return this.num.apply(b) / this.den.apply(b);
        },
        deriv() {
            var n = this.num, d = this.den;
            return RationalFunction(n.deriv() * d - n * d.deriv(), d * d);
        },
    });

    function ratfunc_add(a, b) {
        a = RationalFunction.toRationalFunction(a);
        b = RationalFunction.toRationalFunction(b);
        return RationalFunction(a.num * b.den + a.den * b.num, a.den * b.den);
    }
    function ratfunc_sub(a, b) {
        a = RationalFunction.toRationalFunction(a);
        b = RationalFunction.toRationalFunction(b);
        return RationalFunction(a.num * b.den - a.den * b.num, a.den * b.den);
    }
    function ratfunc_mul(a, b) {
        a = RationalFunction.toRationalFunction(a);
        b = RationalFunction.toRationalFunction(b);
        return RationalFunction(a.num * b.num, a.den * b.den);
    }
    function ratfunc_div(a, b) {
        a = RationalFunction.toRationalFunction(a);
        b = RationalFunction.toRationalFunction(b);
        return RationalFunction(a.num * b.den, a.den * b.num);
    }
    function ratfunc_eq(a, b) {
        a = RationalFunction.toRationalFunction(a);
        b = RationalFunction.toRationalFunction(b);
        /* we assume the fractions are normalized */
        return (a.num == b.num && a.den == b.den);
    }

    operators_set(RationalFunction.prototype,
        {
            "+": ratfunc_add,
            "-": ratfunc_sub,
            "*": ratfunc_mul,
            "/": ratfunc_div,
            "**": generic_pow,
            "==": ratfunc_eq,
            "pos"(a) {
                return a;
            },
            "neg"(a) {
                return RationalFunction(-this.num, this.den);
            },
        },
        {
            left: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],
            right: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],
            "+": ratfunc_add,
            "-": ratfunc_sub,
            "*": ratfunc_mul,
            "/": ratfunc_div,
            "**": generic_pow, /* should only be used with integers */
        });
    
    add_props(RationalFunction, {
        /* This function always return a RationalFunction object even
           if it could simplified to a polynomial, so it is not
           equivalent to RationalFunction(a) */
        toRationalFunction(a) {
            var obj;
            if (a instanceof RationalFunction) {
                return a;
            } else {
                obj = Object.create(RationalFunction.prototype);
                obj.num = Polynomial(a);
                obj.den = Polynomial(1);
                return obj;
            }
        },
    });
              
    /* Power series */

    /* 'a' is an array */
    function get_emin(a) {
        var i, n;
        n = a.length;
        for(i = 0; i < n; i++) {
            if (a[i] != 0)
                return i;
        }
        return n;
    };

    function series_is_scalar_or_polynomial(a)
    {
        return polynomial_is_scalar(a) ||
            (a instanceof Polynomial);
    }
    
    /* n is the maximum number of terms if 'a' is not a serie */
    Series = function Series(a, n) {
        var emin, r, i;
        
        if (a instanceof Series) {
            return a;
        } else if (series_is_scalar_or_polynomial(a)) {
            if (n <= 0) {
                /* XXX: should still use the polynomial degree */
                return Series.zero(0, 0);
            } else {
                a = Polynomial(a);
                emin = get_emin(a);
                r = Series.zero(n, emin);
                n = Math.min(a.length - emin, n);
                for(i = 0; i < n; i++)
                    r[i] = a[i + emin];
                return r;
            }
        } else if (a instanceof RationalFunction) {
            return Series(a.num, n) / a.den;
        } else {
            throw TypeError("invalid type");
        }
    };

    function series_add(v1, v2) {
        var tmp, d, emin, n, r, i, j, v2_emin, c1, c2;
        if (!(v1 instanceof Series)) {
            tmp = v1;
            v1 = v2;
            v2 = tmp;
        }
        d = v1.emin + v1.length;
        if (series_is_scalar_or_polynomial(v2)) {
            v2 = Polynomial(v2);
            if (d <= 0)
                return v1;
            v2_emin = 0;
        } else if (v2 instanceof RationalFunction) {
            /* compute the emin of the rational fonction */
            i = get_emin(v2.num) - get_emin(v2.den);
            if (d <= i)
                return v1;
            /* compute the serie with the required terms */
            v2 = Series(v2, d - i);
            v2_emin = v2.emin;
        } else {
            v2_emin = v2.emin;
            d = Math.min(d, v2_emin + v2.length);
        }
        emin = Math.min(v1.emin, v2_emin);
        n = d - emin;
        r = Series.zero(n, emin);
        /* XXX: slow */
        for(i = emin; i < d; i++) {
            j = i - v1.emin;
            if (j >= 0 && j < v1.length)
                c1 = v1[j];
            else
                c1 = 0;
            j = i - v2_emin;
            if (j >= 0 && j < v2.length)
                c2 = v2[j];
            else
                c2 = 0;
            r[i - emin] = c1 + c2;
        }
        return r.trim();
    }
    function series_sub(a, b) {
        return series_add(a, -b);
    }
    function series_mul(v1, v2) {
        var n, i, j, r, n, emin, n1, n2, k;
        if (!(v1 instanceof Series))
            v1 = Series(v1, v2.length);
        else if (!(v2 instanceof Series))
            v2 = Series(v2, v1.length);
        emin = v1.emin + v2.emin;
        n = Math.min(v1.length, v2.length);
        n1 = v1.length;
        n2 = v2.length;
        r = Series.zero(n, emin);
        for(i = 0; i < n1; i++) {
            k = Math.min(n2, n - i);
            for(j = 0; j < k; j++) {
                r[i + j] += v1[i] * v2[j];
            }
        }
        return r.trim();
    }
    function series_div(v1, v2) {
        if (!(v2 instanceof Series))
            v2 = Series(v2, v1.length);
        return series_mul(v1, v2.inverse());
    }
    function series_pow(a, b) {
        if (Integer.isInteger(b)) {
            return generic_pow(a, b);
        } else {
            if (!(a instanceof Series))
                a = Series(a, b.length);
            return exp(log(a) * b);
        }
    }
    function series_eq(a, b) {
        var n, i;
        if (a.emin != b.emin)
            return false;
        n = a.length;
        if (n != b.length)
            return false;
        for(i = 0; i < n; i++) {
            if (a[i] != b[i])
                return false;
        }
        return true;
    }

    operators_set(Series.prototype,
        {
            "+": series_add,
            "-": series_sub,
            "*": series_mul,
            "/": series_div,
            "**": series_pow,
            "==": series_eq,
            "pos"(a) {
                return a;
            },
            "neg"(a) {
                var obj, n, i;
                n = a.length;
                obj = Series.zero(a.length, a.emin);
                for(i = 0; i < n; i++) {
                    obj[i] = -a[i];
                }
                return obj;
            },
        },
        {
            left: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],
            right: [Number, BigInt, Float, Fraction, Complex, Mod, Polynomial],
            "+": series_add,
            "-": series_sub,
            "*": series_mul,
            "/": series_div,
            "**": series_pow,
        });

    add_props(Series.prototype, {
        conj() {
            var obj, n, i;
            n = this.length;
            obj = Series.zero(this.length, this.emin);
            for(i = 0; i < n; i++) {
                obj[i] = this[i].conj();
            }
            return obj;
        },
        inverse() {
            var r, n, i, j, sum, v1 = this;
            n = v1.length;
            if (n == 0)
                throw RangeError("division by zero");
            r = Series.zero(n, -v1.emin);
            r[0] = 1 / v1[0];
            for(i = 1; i < n; i++) {
                sum = 0;
                for(j = 1; j <= i; j++) {
                    sum += v1[j] * r[i - j];
                }
                r[i] = -sum * r[0];
            }
            return r;
        },
        /* remove leading zero terms */
        trim() {
            var i, j, n, r, v1 = this;
            n = v1.length;
            i = 0;
            while (i < n && v1[i] == 0)
                i++;
            if (i == 0)
                return v1;
            for(j = i; j < n; j++)
                v1[j - i] = v1[j];
            v1.length = n - i;
            v1.__proto__.emin += i;
            return v1;
        },
        toString() {
            var i, j, str, str1, c, a = this, emin, n;
            str="";
            emin = this.emin;
            n = this.length;
            for(j = 0; j < n; j++) {
                i = j + emin;
                c = a[j];
                if (c != 0) {
                    str1 = monomial_toString(c, i);
                    if (str1[0] != "-") {
                        if (str != "")
                            str += "+";
                    }
                    str += str1;
                }
            }
            if (str != "")
                str += "+";
            str += "O(" + monomial_toString(1, n + emin) + ")";
            return str;
        },
        apply(b) {
            var i, n, r, a = this;
            n = a.length;
            if (n == 0)
                return 0;
            r = a[--n];
            while (n > 0) {
                n--;
                r = r * b + a[n];
            }
            if (a.emin != 0)
                r *= b ^ a.emin;
            return r;
        },
        deriv() {
            var a = this, n = a.length, emin = a.emin, r, i, j;
            if (n == 0 && emin == 0) {
                return Series.zero(0, 0);
            } else {
                r = Series.zero(n, emin - 1);
                for(i = 0; i < n; i++) {
                    j = emin + i;
                    if (j == 0)
                        r[i] = 0;
                    else
                        r[i] = j * a[i];
                }
                return r.trim();
            }
        },
        integ() {
            var a = this, n = a.length, emin = a.emin, i, j, r;
            r = Series.zero(n, emin + 1);
            for(i = 0; i < n; i++) {
                j = emin + i;
                if (j == -1) {
                    if (a[i] != 0)
                        throw RangeError("cannot represent integ(1/X)");
                } else {
                    r[i] = a[i] / (j + 1);
                }
            }
            return r.trim();
        },
        exp() {
            var c, i, r, n, a = this;
            if (a.emin < 0)
                throw RangeError("negative exponent in exp");
            n = a.emin + a.length;
            if (a.emin > 0 || a[0] == 0) {
                c = 1;
            } else {
                c = global.exp(a[0]);
                a -= a[0];
            }
            r = Series.zero(n, 0);
            for(i = 0; i < n; i++) {
                r[i] = c / fact(i);
            }
            return r.apply(a);
        },
        log() {
            var a = this, r;
            if (a.emin != 0)
                throw RangeError("log argument must have a non zero constant term");
            r = integ(deriv(a) / a);
            /* add the constant term */
            r += global.log(a[0]);
            return r;
        },
    });

    add_props(Series, {
        /* new series of length n and first exponent emin */
        zero(n, emin) {
            var r, i, obj;

            r = [];
            for(i = 0; i < n; i++)
                r[i] = 0;
            /* we return an array and store emin in its prototype */
            obj = Object.create(Series.prototype);
            obj.emin = emin;
            Object.setPrototypeOf(r, obj);
            return r;
        },
        O(a) {
            function ErrorO() {
                return TypeError("invalid O() argument");
            }
            var n;
            if (series_is_scalar_or_polynomial(a)) {
                a = Polynomial(a);
                n = a.deg();
                if (n < 0)
                    throw ErrorO();
            } else if (a instanceof RationalFunction) {
                if (a.num.deg() != 0)
                    throw ErrorO();
                n = a.den.deg();
                if (n < 0)
                    throw ErrorO();
                n = -n;
            } else
                throw ErrorO();
            return Series.zero(0, n);
        },
    });
    
    /* Array (Matrix) */

    Matrix = function Matrix(h, w) {
        var i, j, r, rl;
        if (typeof w === "undefined")
            w = h;
        r = [];
        for(i = 0; i < h; i++) {
            rl = [];
            for(j = 0; j < w; j++)
                rl[j] = 0;
            r[i] = rl;
        }
        return r;
    };

    add_props(Matrix, {
        idn(n) {
            var r, i;
            r = Matrix(n, n);
            for(i = 0; i < n; i++)
                r[i][i] = 1;
            return r;
        },
        diag(a) {
            var r, i, n;
            n = a.length;
            r = Matrix(n, n);
            for(i = 0; i < n; i++)
                r[i][i] = a[i];
            return r;
        },
        hilbert(n) {
            var i, j, r;
            r = Matrix(n);
            for(i = 0; i < n; i++) {
                for(j = 0; j < n; j++) {
                    r[i][j] = 1 / (1 + i + j);
                }
            }
            return r;
        },
        trans(a) {
            var h, w, r, i, j;
            if (!Array.isArray(a))
                throw TypeError("matrix expected");
            h = a.length;
            if (!Array.isArray(a[0])) {
                w = 1;
                r = Matrix(w, h);
                for(i = 0; i < h; i++) {
                    r[0][i] = a[i];
                }
            } else {
                w = a[0].length;
                r = Matrix(w, h);
                for(i = 0; i < h; i++) {
                    for(j = 0; j < w; j++) {
                        r[j][i] = a[i][j];
                    }
                }
            }
            return r;
        },
        check_square(a) {
            var a, n;
            if (!Array.isArray(a))
                throw TypeError("array expected");
            n = a.length;
            if (!Array.isArray(a[0]) || n != a[0].length)
                throw TypeError("square matrix expected");
            return n;
        },
        trace(a) {
            var n, r, i;
            n = Matrix.check_square(a);
            r = a[0][0];
            for(i = 1; i < n; i++) {
                r += a[i][i];
            }
            return r;
        },
        charpoly(a) {
            var n, p, c, i, j, coef;
            n = Matrix.check_square(a);
            p = [];
            for(i = 0; i < n + 1; i++)
                p[i] = 0;
            p[n] = 1;
            c = Matrix.idn(n);
            for(i = 0; i < n; i++) {
                c = c * a;
                coef = -trace(c) / (i + 1);
                p[n - i - 1] = coef;
                for(j = 0; j < n; j++)
                    c[j][j] += coef;
            }
            return Polynomial(p);
        },
        eigenvals(a) {
            return Polynomial.roots(Matrix.charpoly(a));
        },
        det(a) {
            var n, i, j, k, s, src, v, c;
            
            n = Matrix.check_square(a);
            s = 1;
            src = a.dup();
            for(i=0;i<n;i++) {
                for(j = i; j < n; j++) {
                    if (src[j][i] != 0)
                        break;
                }
                if (j == n)
                    return 0;
                if (j != i) {
                    for(k = 0;k < n; k++) {
                        v = src[j][k];
                        src[j][k] = src[i][k];
                        src[i][k] = v;
                    }
                    s = -s;
                }
                c = src[i][i].inverse();
                for(j = i + 1; j < n; j++) {
                    v = c * src[j][i];
                    for(k = 0;k < n; k++) {
                        src[j][k] -= src[i][k] * v;
                    }
                }
            }
            c = s;
            for(i=0;i<n;i++)
                c *= src[i][i];
            return c;
        },
        inverse(a) {
            var n, dst, src, i, j, k, n2, r, c, v;
            n = Matrix.check_square(a);
            src = a.dup();
            dst = Matrix.idn(n);
            for(i=0;i<n;i++) {
                for(j = i; j < n; j++) {
                    if (src[j][i] != 0)
                        break;
                }
                if (j == n)
                    throw RangeError("matrix is not invertible");
                if (j != i) {
                    /* swap lines in src and dst */
                    v = src[j];
                    src[j] = src[i];
                    src[i] = v;
                    v = dst[j];
                    dst[j] = dst[i];
                    dst[i] = v;
                }

                c = src[i][i].inverse();
                for(k = 0; k < n; k++) {
                    src[i][k] *= c;
                    dst[i][k] *= c;
                }
                
                for(j = 0; j < n; j++) {
                    if (j != i) {
                        c = src[j][i];
                        for(k = i; k < n; k++) {
                            src[j][k] -= src[i][k] * c;
                        }
                        for(k = 0; k < n; k++) {
                            dst[j][k] -= dst[i][k] * c;
                        }
                    }
                }
            }
            return dst;
        },
        rank(a) {
            var src, i, j, k, w, h, l, c;
            
            if (!Array.isArray(a) ||
                !Array.isArray(a[0]))
                throw TypeError("matrix expected");
            h = a.length;
            w = a[0].length;
            src = a.dup();
            l = 0;
            for(i=0;i<w;i++) {
                for(j = l; j < h; j++) {
                    if (src[j][i] != 0)
                        break;
                }
                if (j == h)
                    continue;
                if (j != l) {
                    /* swap lines */
                    for(k = 0; k < w; k++) {
                        v = src[j][k];
                        src[j][k] = src[l][k];
                        src[l][k] = v;
                    }
                }
                
                c = src[l][i].inverse();
                for(k = 0; k < w; k++) {
                    src[l][k] *= c;
                }
                
                for(j = l + 1; j < h; j++) {
                    c = src[j][i];
                    for(k = i; k < w; k++) {
                        src[j][k] -= src[l][k] * c;
                    }
                }
                l++;
            }
            return l;
        },
        ker(a) {
            var src, i, j, k, w, h, l, m, r, im_cols, ker_dim, c;
            
            if (!Array.isArray(a) ||
                !Array.isArray(a[0]))
                throw TypeError("matrix expected");
            h = a.length;
            w = a[0].length;
            src = a.dup();
            im_cols = [];
            l = 0;
            for(i=0;i<w;i++) {
                im_cols[i] = false;
                for(j = l; j < h; j++) {
                    if (src[j][i] != 0)
                        break;
                }
                if (j == h)
                    continue;
                im_cols[i] = true;
                if (j != l) {
                    /* swap lines */
                    for(k = 0; k < w; k++) {
                        v = src[j][k];
                        src[j][k] = src[l][k];
                        src[l][k] = v;
                    }
                }
                
                c = src[l][i].inverse();
                for(k = 0; k < w; k++) {
                    src[l][k] *= c;
                }
                
                for(j = 0; j < h; j++) {
                    if (j != l) {
                        c = src[j][i];
                        for(k = i; k < w; k++) {
                            src[j][k] -= src[l][k] * c;
                        }
                    }
                }
                l++;
                //        log_str("m=" + cval_toString(v1) + "\n");
            }
            //    log_str("im cols="+im_cols+"\n");

            /* build the kernel vectors */
            ker_dim = w - l;
            r = Matrix(w, ker_dim);
            k = 0;
            for(i = 0; i < w; i++) {
                if (!im_cols[i]) {
                    /* select this column from the matrix */
                    l = 0;
                    m = 0;
                    for(j = 0; j < w; j++) {
                        if (im_cols[j]) {
                            r[j][k] = -src[m][i];
                            m++;
                        } else {
                            if (l == k) {
                                r[j][k] = 1;
                            } else {
                                r[j][k] = 0;
                            }
                            l++;
                        }
                    }
                    k++;
                }
            }
            return r;
        },
        dp(a, b) {
            var i, n, r;
            n = a.length;
            if (n != b.length)
                throw TypeError("incompatible array length");
            /* XXX: could do complex product */
            r = 0;
            for(i = 0; i < n; i++) {
                r += a[i] * b[i];
            }
            return r;
        },
        /* cross product */
        cp(v1, v2) {
            var r;
            if (v1.length != 3 || v2.length != 3)
                throw TypeError("vectors must have 3 elements");
            r = [];
            r[0] = v1[1] * v2[2] - v1[2] * v2[1];
            r[1] = v1[2] * v2[0] - v1[0] * v2[2];
            r[2] = v1[0] * v2[1] - v1[1] * v2[0];
            return r;
        },
    });

    function array_add(a, b) {
        var r, i, n;
        n = a.length;
        if (n != b.length)
            throw TypeError("incompatible array size");
        r = [];
        for(i = 0; i < n; i++)
            r[i] = a[i] + b[i];
        return r;
    }
    function array_sub(a, b) {
        var r, i, n;
        n = a.length;
        if (n != b.length)
            throw TypeError("incompatible array size");
        r = [];
        for(i = 0; i < n; i++)
            r[i] = a[i] - b[i];
        return r;
    }
    function array_scalar_mul(a, b) {
        var r, i, n;
        n = a.length;
        r = [];
        for(i = 0; i < n; i++)
            r[i] = a[i] * b;
        return r;
    }
    function array_mul(a, b) {
        var h, w, l, i, j, k, r, rl, sum, a_mat, b_mat;
        h = a.length;
        a_mat = Array.isArray(a[0]);
        if (a_mat) {
            l = a[0].length;
        } else {
            l = 1;
        }
        if (l != b.length)
            throw RangeError("incompatible matrix size");
        b_mat = Array.isArray(b[0]);
        if (b_mat)
            w = b[0].length;
        else
            w = 1;
        r = [];
        if (a_mat && b_mat) {
            for(i = 0; i < h; i++) {
                rl = [];
                for(j = 0; j < w; j++) {
                    sum = 0;
                    for(k = 0; k < l; k++) {
                        sum += a[i][k] * b[k][j];
                    }
                    rl[j] = sum;
                }
                r[i] = rl;
            }
        } else if (a_mat && !b_mat) {
            for(i = 0; i < h; i++) {
                sum = 0;
                for(k = 0; k < l; k++) {
                    sum += a[i][k] * b[k];
                }
                r[i] = sum;
            }
        } else if (!a_mat && b_mat) {
            for(i = 0; i < h; i++) {
                rl = [];
                for(j = 0; j < w; j++) {
                    rl[j] = a[i] * b[0][j];
                }
                r[i] = rl;
            }
        } else {
            for(i = 0; i < h; i++) {
                r[i] = a[i] * b[0];
            }
        }
        return r;
    }
    function array_div(a, b) {
        return array_mul(a, b.inverse());
    }
    function array_element_wise_inverse(a) {
        var r, i, n;
        n = a.length;
        r = [];
        for(i = 0; i < n; i++)
            r[i] = a[i].inverse();
        return r;
    }
    function array_eq(a, b) {
        var n, i;
        n = a.length;
        if (n != b.length)
            return false;
        for(i = 0; i < n; i++) {
            if (a[i] != b[i])
                return false;
        }
        return true;
    }

    operators_set(Array.prototype,
        {
            "+": array_add,
            "-": array_sub,
            "*": array_mul,
            "/": array_div,
            "==": array_eq,
            "pos"(a) {
                return a;
            },
            "neg"(a) {
                var i, n, r;
                n = a.length;
                r = [];
                for(i = 0; i < n; i++)
                    r[i] = -a[i];
                return r;
            }
        },
        {
            right: [Number, BigInt, Float, Fraction, Complex, Mod,
                    Polynomial, PolyMod, RationalFunction, Series],
            "*": array_scalar_mul,
            "/"(a, b) { return a * b.inverse(); },
            "**": generic_pow, /* XXX: only for integer */
        },
        {
            left: [Number, BigInt, Float, Fraction, Complex, Mod,
                   Polynomial, PolyMod, RationalFunction, Series],
            "*"(a, b) { return array_scalar_mul(b, a); },
            "/"(a, b) { return a * array_element_wise_inverse(b); },
        });

    add_props(Array.prototype, {
        conj() {
            var i, n, r;
            n = this.length;
            r = [];
            for(i = 0; i < n; i++)
                r[i] = this[i].conj();
            return r;
        },
        dup() {
            var r, i, n, el, a = this;
            r = [];
            n = a.length;
            for(i = 0; i < n; i++) {
                el = a[i];
                if (Array.isArray(el))
                    el = el.dup();
                r[i] = el;
            }
            return r;
        },
        inverse() {
            return Matrix.inverse(this);
        },
        norm2: Polynomial.prototype.norm2,
    });

})(this);

/* global definitions */
var I = Complex(0, 1);
var X = Polynomial([0, 1]);
var O = Series.O;

Object.defineProperty(this, "PI", { get: function () { return Float.PI } });

/* put frequently used functions in the global context */
var gcd = Integer.gcd;
var fact = Integer.fact;
var comb = Integer.comb;
var pmod = Integer.pmod;
var invmod = Integer.invmod;
var factor = Integer.factor;
var isprime = Integer.isPrime;
var nextprime = Integer.nextPrime;

function deriv(a)
{
    return a.deriv();
}

function integ(a)
{
    return a.integ();
}

function norm2(a)
{
    return a.norm2();
}

function abs(a)
{
    return a.abs();
}

function conj(a)
{
    return a.conj();
}

function arg(a)
{
    return a.arg();
}

function inverse(a)
{
    return a.inverse();
}

function trunc(a)
{
    if (Integer.isInteger(a)) {
        return a;
    } else if (a instanceof Fraction) {
        return Integer.tdiv(a.num, a.den);
    } else if (a instanceof Polynomial) {
        return a;
    } else if (a instanceof RationalFunction) {
        return Polynomial.divrem(a.num, a.den)[0];
    } else {
        return Float.ceil(a);
    }
}

function floor(a)
{
    if (Integer.isInteger(a)) {
        return a;
    } else if (a instanceof Fraction) {
        return Integer.fdiv(a.num, a.den);
    } else {
        return Float.floor(a);
    }
}

function ceil(a)
{
    if (Integer.isInteger(a)) {
        return a;
    } else if (a instanceof Fraction) {
        return Integer.cdiv(a.num, a.den);
    } else {
        return Float.ceil(a);
    }
}

function sqrt(a)
{
    var t, u, re, im;
    if (a instanceof Series) {
        return a ^ (1/2);
    } else if (a instanceof Complex) {
        t = abs(a);
        u = a.re;
        re = sqrt((t + u) / 2);
        im = sqrt((t - u) / 2);
        if (a.im < 0)
            im = -im;
        return Complex.toComplex(re, im);
    } else {
        a = Float(a);
        if (a < 0) {
            return Complex(0, Float.sqrt(-a));
        } else {
            return Float.sqrt(a);
        }
    }
}

function exp(a)
{
    return a.exp();
}

function log(a)
{
    return a.log();
}

function log2(a)
{
    return log(a) * Float.LOG2E;
}

function log10(a)
{
    return log(a) * Float.LOG10E;
}

function todb(a)
{
    return log10(a) * 10;
}

function fromdb(a)
{
    return 10 ^ (a / 10);
}

function sin(a)
{
    var t;
    if (a instanceof Complex || a instanceof Series) {
        t = exp(a * I);
        return (t - 1/t) / (2 * I);
    } else {
        return Float.sin(Float(a));
    }
}

function cos(a)
{
    var t;
    if (a instanceof Complex || a instanceof Series) {
        t = exp(a * I);
        return (t + 1/t) / 2;
    } else {
        return Float.cos(Float(a));
    }
}

function tan(a)
{
    if (a instanceof Complex || a instanceof Series) {
        return sin(a) / cos(a);
    } else {
        return Float.tan(Float(a));
    }
}

function asin(a)
{
    return Float.asin(Float(a));
}

function acos(a)
{
    return Float.acos(Float(a));
}

function atan(a)
{
    return Float.atan(Float(a));
}

function atan2(a, b)
{
    return Float.atan2(Float(a), Float(b));
}

function sinc(a)
{
    if (a == 0) {
        return 1;
    } else {
        a *= Float.PI;
        return sin(a) / a;
    }
}

function todeg(a)
{
    return a * 180 / Float.PI;
}

function fromdeg(a)
{
    return a * Float.PI / 180;
}

function sinh(a)
{
    var e = Float.exp(Float(a));
    return (e - 1/e) * 0.5;
}

function cosh(a)
{
    var e = Float.exp(Float(a));
    return (e + 1/e) * 0.5;
}

function tanh(a)
{
    var e = Float.exp(Float(a) * 2);
    return (e - 1) / (e + 1);
}

function asinh(a)
{
    var x = Float(a);
    return log(sqrt(x * x + 1) + x);
}

function acosh(a)
{
    var x = Float(a);
    return log(sqrt(x * x - 1) + x);
}

function atanh(a)
{
    var x = Float(a);
    return 0.5 * log((1 + x) / (1 - x));
}

function sigmoid(x)
{
    x = Float(x);
    return 1 / (1 + exp(-x));
}

function lerp(a, b, t)
{
    return a + (b - a) * t;
}

var idn = Matrix.idn;
var diag = Matrix.diag;
var trans = Matrix.trans;
var trace = Matrix.trace;
var charpoly = Matrix.charpoly;
var eigenvals = Matrix.eigenvals;
var det = Matrix.det;
var rank = Matrix.rank;
var ker = Matrix.ker;
var cp = Matrix.cp;
var dp = Matrix.dp;

var polroots = Polynomial.roots;
var bestappr = Float.bestappr;

'''
'''--- quickjs-atom.h ---
/*
 * QuickJS atom definitions
 * 
 * Copyright (c) 2017-2018 Fabrice Bellard
 * Copyright (c) 2017-2018 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifdef DEF

/* Note: first atoms are considered as keywords in the parser */
DEF(null, "null") /* must be first */
DEF(false, "false")
DEF(true, "true")
DEF(if, "if")
DEF(else, "else")
DEF(return, "return")
DEF(var, "var")
DEF(this, "this")
DEF(delete, "delete")
DEF(void, "void")
DEF(typeof, "typeof")
DEF(new, "new")
DEF(in, "in")
DEF(instanceof, "instanceof")
DEF(do, "do")
DEF(while, "while")
DEF(for, "for")
DEF(break, "break")
DEF(continue, "continue")
DEF(switch, "switch")
DEF(case, "case")
DEF(default, "default")
DEF(throw, "throw")
DEF(try, "try")
DEF(catch, "catch")
DEF(finally, "finally")
DEF(function, "function")
DEF(debugger, "debugger")
DEF(with, "with")
/* FutureReservedWord */
DEF(class, "class")
DEF(const, "const")
DEF(enum, "enum")
DEF(export, "export")
DEF(extends, "extends")
DEF(import, "import")
DEF(super, "super")
/* FutureReservedWords when parsing strict mode code */
DEF(implements, "implements")
DEF(interface, "interface")
DEF(let, "let")
DEF(package, "package")
DEF(private, "private")
DEF(protected, "protected")
DEF(public, "public")
DEF(static, "static")
DEF(yield, "yield")
DEF(await, "await")

/* empty string */
DEF(empty_string, "")
/* identifiers */
DEF(length, "length")
DEF(fileName, "fileName")
DEF(lineNumber, "lineNumber")
DEF(message, "message")
DEF(errors, "errors")
DEF(stack, "stack")
DEF(name, "name")
DEF(toString, "toString")
DEF(toLocaleString, "toLocaleString")
DEF(valueOf, "valueOf")
DEF(eval, "eval")
DEF(prototype, "prototype")
DEF(constructor, "constructor")
DEF(configurable, "configurable")
DEF(writable, "writable")
DEF(enumerable, "enumerable")
DEF(value, "value")
DEF(get, "get")
DEF(set, "set")
DEF(of, "of")
DEF(__proto__, "__proto__")
DEF(undefined, "undefined")
DEF(number, "number")
DEF(boolean, "boolean")
DEF(string, "string")
DEF(object, "object")
DEF(symbol, "symbol")
DEF(integer, "integer")
DEF(unknown, "unknown")
DEF(arguments, "arguments")
DEF(callee, "callee")
DEF(caller, "caller")
DEF(_eval_, "<eval>")
DEF(_ret_, "<ret>")
DEF(_var_, "<var>")
DEF(_arg_var_, "<arg_var>")
DEF(_with_, "<with>")
DEF(lastIndex, "lastIndex")
DEF(target, "target")
DEF(index, "index")
DEF(input, "input")
DEF(defineProperties, "defineProperties")
DEF(apply, "apply")
DEF(join, "join")
DEF(concat, "concat")
DEF(split, "split")
DEF(construct, "construct")
DEF(getPrototypeOf, "getPrototypeOf")
DEF(setPrototypeOf, "setPrototypeOf")
DEF(isExtensible, "isExtensible")
DEF(preventExtensions, "preventExtensions")
DEF(has, "has")
DEF(deleteProperty, "deleteProperty")
DEF(defineProperty, "defineProperty")
DEF(getOwnPropertyDescriptor, "getOwnPropertyDescriptor")
DEF(ownKeys, "ownKeys")
DEF(add, "add")
DEF(done, "done")
DEF(next, "next")
DEF(values, "values")
DEF(source, "source")
DEF(flags, "flags")
DEF(global, "global")
DEF(unicode, "unicode")
DEF(raw, "raw")
DEF(new_target, "new.target")
DEF(this_active_func, "this.active_func")
DEF(home_object, "<home_object>")
DEF(computed_field, "<computed_field>")
DEF(static_computed_field, "<static_computed_field>") /* must come after computed_fields */
DEF(class_fields_init, "<class_fields_init>")
DEF(brand, "<brand>")
DEF(hash_constructor, "#constructor")
DEF(as, "as")
DEF(from, "from")
DEF(meta, "meta")
DEF(_default_, "*default*")
DEF(_star_, "*")
DEF(Module, "Module")
DEF(then, "then")
DEF(resolve, "resolve")
DEF(reject, "reject")
DEF(promise, "promise")
DEF(proxy, "proxy")
DEF(revoke, "revoke")
DEF(async, "async")
DEF(exec, "exec")
DEF(groups, "groups")
DEF(status, "status")
DEF(reason, "reason")
DEF(globalThis, "globalThis")
#ifdef CONFIG_BIGNUM
DEF(bigint, "bigint")
DEF(bigfloat, "bigfloat")
DEF(bigdecimal, "bigdecimal")
DEF(roundingMode, "roundingMode")
DEF(maximumSignificantDigits, "maximumSignificantDigits")
DEF(maximumFractionDigits, "maximumFractionDigits")
#endif
#ifdef CONFIG_ATOMICS
DEF(not_equal, "not-equal")
DEF(timed_out, "timed-out")
DEF(ok, "ok")
#endif
DEF(toJSON, "toJSON")
/* class names */
DEF(Object, "Object")
DEF(Array, "Array")
DEF(Error, "Error")
DEF(Number, "Number")
DEF(String, "String")
DEF(Boolean, "Boolean")
DEF(Symbol, "Symbol")
DEF(Arguments, "Arguments")
DEF(Math, "Math")
DEF(JSON, "JSON")
DEF(Date, "Date")
DEF(Function, "Function")
DEF(GeneratorFunction, "GeneratorFunction")
DEF(ForInIterator, "ForInIterator")
DEF(RegExp, "RegExp")
DEF(ArrayBuffer, "ArrayBuffer")
DEF(SharedArrayBuffer, "SharedArrayBuffer")
/* must keep same order as class IDs for typed arrays */
DEF(Uint8ClampedArray, "Uint8ClampedArray") 
DEF(Int8Array, "Int8Array")
DEF(Uint8Array, "Uint8Array")
DEF(Int16Array, "Int16Array")
DEF(Uint16Array, "Uint16Array")
DEF(Int32Array, "Int32Array")
DEF(Uint32Array, "Uint32Array")
#ifdef CONFIG_BIGNUM
DEF(BigInt64Array, "BigInt64Array")
DEF(BigUint64Array, "BigUint64Array")
#endif
DEF(Float32Array, "Float32Array")
DEF(Float64Array, "Float64Array")
DEF(DataView, "DataView")
#ifdef CONFIG_BIGNUM
DEF(BigInt, "BigInt")
DEF(BigFloat, "BigFloat")
DEF(BigFloatEnv, "BigFloatEnv")
DEF(BigDecimal, "BigDecimal")
DEF(OperatorSet, "OperatorSet")
DEF(Operators, "Operators")
#endif
DEF(Map, "Map")
DEF(Set, "Set") /* Map + 1 */
DEF(WeakMap, "WeakMap") /* Map + 2 */
DEF(WeakSet, "WeakSet") /* Map + 3 */
DEF(Map_Iterator, "Map Iterator")
DEF(Set_Iterator, "Set Iterator")
DEF(Array_Iterator, "Array Iterator")
DEF(String_Iterator, "String Iterator")
DEF(RegExp_String_Iterator, "RegExp String Iterator")
DEF(Generator, "Generator")
DEF(Proxy, "Proxy")
DEF(Promise, "Promise")
DEF(PromiseResolveFunction, "PromiseResolveFunction")
DEF(PromiseRejectFunction, "PromiseRejectFunction")
DEF(AsyncFunction, "AsyncFunction")
DEF(AsyncFunctionResolve, "AsyncFunctionResolve")
DEF(AsyncFunctionReject, "AsyncFunctionReject")
DEF(AsyncGeneratorFunction, "AsyncGeneratorFunction")
DEF(AsyncGenerator, "AsyncGenerator")
DEF(EvalError, "EvalError")
DEF(RangeError, "RangeError")
DEF(ReferenceError, "ReferenceError")
DEF(SyntaxError, "SyntaxError")
DEF(TypeError, "TypeError")
DEF(URIError, "URIError")
DEF(InternalError, "InternalError")
/* private symbols */
DEF(Private_brand, "<brand>")
/* symbols */
DEF(Symbol_toPrimitive, "Symbol.toPrimitive")
DEF(Symbol_iterator, "Symbol.iterator")
DEF(Symbol_match, "Symbol.match")
DEF(Symbol_matchAll, "Symbol.matchAll")
DEF(Symbol_replace, "Symbol.replace")
DEF(Symbol_search, "Symbol.search")
DEF(Symbol_split, "Symbol.split")
DEF(Symbol_toStringTag, "Symbol.toStringTag")
DEF(Symbol_isConcatSpreadable, "Symbol.isConcatSpreadable")
DEF(Symbol_hasInstance, "Symbol.hasInstance")
DEF(Symbol_species, "Symbol.species")
DEF(Symbol_unscopables, "Symbol.unscopables")
DEF(Symbol_asyncIterator, "Symbol.asyncIterator")
#ifdef CONFIG_BIGNUM
DEF(Symbol_operatorSet, "Symbol.operatorSet")
#endif
    
#endif /* DEF */

'''
'''--- quickjs-libc.c ---
/*
 * QuickJS C library
 * 
 * Copyright (c) 2017-2021 Fabrice Bellard
 * Copyright (c) 2017-2021 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <inttypes.h>
#include <string.h>
#include <assert.h>
#include <unistd.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/time.h>
#include <time.h>
#include <signal.h>
#include <limits.h>
#include <sys/stat.h>
#include <dirent.h>
#if defined(_WIN32)
#include <windows.h>
#include <conio.h>
#include <utime.h>
#else
#include <dlfcn.h>
#include <termios.h>
#include <sys/ioctl.h>
#include <sys/wait.h>

#if defined(__APPLE__)
typedef sig_t sighandler_t;
#if !defined(environ)
#include <crt_externs.h>
#define environ (*_NSGetEnviron())
#endif
#endif /* __APPLE__ */

#endif

#if !defined(_WIN32)
/* enable the os.Worker API. IT relies on POSIX threads */
#define USE_WORKER
#endif

#ifdef USE_WORKER
#include <pthread.h>
#include <stdatomic.h>
#endif

#include "cutils.h"
#include "list.h"
#include "quickjs-libc.h"

/* TODO:
   - add socket calls
*/

typedef struct {
    struct list_head link;
    int fd;
    JSValue rw_func[2];
} JSOSRWHandler;

typedef struct {
    struct list_head link;
    int sig_num;
    JSValue func;
} JSOSSignalHandler;

typedef struct {
    struct list_head link;
    BOOL has_object;
    int64_t timeout;
    JSValue func;
} JSOSTimer;

typedef struct {
    struct list_head link;
    uint8_t *data;
    size_t data_len;
    /* list of SharedArrayBuffers, necessary to free the message */
    uint8_t **sab_tab;
    size_t sab_tab_len;
} JSWorkerMessage;

typedef struct {
    int ref_count;
#ifdef USE_WORKER
    pthread_mutex_t mutex;
#endif
    struct list_head msg_queue; /* list of JSWorkerMessage.link */
    int read_fd;
    int write_fd;
} JSWorkerMessagePipe;

typedef struct {
    struct list_head link;
    JSWorkerMessagePipe *recv_pipe;
    JSValue on_message_func;
} JSWorkerMessageHandler;

typedef struct JSThreadState {
    struct list_head os_rw_handlers; /* list of JSOSRWHandler.link */
    struct list_head os_signal_handlers; /* list JSOSSignalHandler.link */
    struct list_head os_timers; /* list of JSOSTimer.link */
    struct list_head port_list; /* list of JSWorkerMessageHandler.link */
    int eval_script_recurse; /* only used in the main thread */
    /* not used in the main thread */
    JSWorkerMessagePipe *recv_pipe, *send_pipe;
} JSThreadState;

static uint64_t os_pending_signals;
static int (*os_poll_func)(JSContext *ctx);

static void js_std_dbuf_init(JSContext *ctx, DynBuf *s)
{
    dbuf_init2(s, JS_GetRuntime(ctx), (DynBufReallocFunc *)js_realloc_rt);
}

static BOOL my_isdigit(int c)
{
    return (c >= '0' && c <= '9');
}

static JSValue js_printf_internal(JSContext *ctx,
                                  int argc, JSValueConst *argv, FILE *fp)
{
    char fmtbuf[32];
    uint8_t cbuf[UTF8_CHAR_LEN_MAX+1];
    JSValue res;
    DynBuf dbuf;
    const char *fmt_str;
    const uint8_t *fmt, *fmt_end;
    const uint8_t *p;
    char *q;
    int i, c, len, mod;
    size_t fmt_len;
    int32_t int32_arg;
    int64_t int64_arg;
    double double_arg;
    const char *string_arg;
    /* Use indirect call to dbuf_printf to prevent gcc warning */
    int (*dbuf_printf_fun)(DynBuf *s, const char *fmt, ...) = (void*)dbuf_printf;

    js_std_dbuf_init(ctx, &dbuf);

    if (argc > 0) {
        fmt_str = JS_ToCStringLen(ctx, &fmt_len, argv[0]);
        if (!fmt_str)
            goto fail;

        i = 1;
        fmt = (const uint8_t *)fmt_str;
        fmt_end = fmt + fmt_len;
        while (fmt < fmt_end) {
            for (p = fmt; fmt < fmt_end && *fmt != '%'; fmt++)
                continue;
            dbuf_put(&dbuf, p, fmt - p);
            if (fmt >= fmt_end)
                break;
            q = fmtbuf;
            *q++ = *fmt++;  /* copy '%' */
            
            /* flags */
            for(;;) {
                c = *fmt;
                if (c == '0' || c == '#' || c == '+' || c == '-' || c == ' ' ||
                    c == '\'') {
                    if (q >= fmtbuf + sizeof(fmtbuf) - 1)
                        goto invalid;
                    *q++ = c;
                    fmt++;
                } else {
                    break;
                }
            }
            /* width */
            if (*fmt == '*') {
                if (i >= argc)
                    goto missing;
                if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
                    goto fail;
                q += snprintf(q, fmtbuf + sizeof(fmtbuf) - q, "%d", int32_arg);
                fmt++;
            } else {
                while (my_isdigit(*fmt)) {
                    if (q >= fmtbuf + sizeof(fmtbuf) - 1)
                        goto invalid;
                    *q++ = *fmt++;
                }
            }
            if (*fmt == '.') {
                if (q >= fmtbuf + sizeof(fmtbuf) - 1)
                    goto invalid;
                *q++ = *fmt++;
                if (*fmt == '*') {
                    if (i >= argc)
                        goto missing;
                    if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
                        goto fail;
                    q += snprintf(q, fmtbuf + sizeof(fmtbuf) - q, "%d", int32_arg);
                    fmt++;
                } else {
                    while (my_isdigit(*fmt)) {
                        if (q >= fmtbuf + sizeof(fmtbuf) - 1)
                            goto invalid;
                        *q++ = *fmt++;
                    }
                }
            }

            /* we only support the "l" modifier for 64 bit numbers */
            mod = ' ';
            if (*fmt == 'l') {
                mod = *fmt++;
            }
            
            /* type */
            c = *fmt++;
            if (q >= fmtbuf + sizeof(fmtbuf) - 1)
                goto invalid;
            *q++ = c;
            *q = '\0';
            
            switch (c) {
            case 'c':
                if (i >= argc)
                    goto missing;
                if (JS_IsString(argv[i])) {
                    string_arg = JS_ToCString(ctx, argv[i++]);
                    if (!string_arg)
                        goto fail;
                    int32_arg = unicode_from_utf8((uint8_t *)string_arg, UTF8_CHAR_LEN_MAX, &p);
                    JS_FreeCString(ctx, string_arg);
                } else {
                    if (JS_ToInt32(ctx, &int32_arg, argv[i++]))
                        goto fail;
                }
                /* handle utf-8 encoding explicitly */
                if ((unsigned)int32_arg > 0x10FFFF)
                    int32_arg = 0xFFFD;
                /* ignore conversion flags, width and precision */
                len = unicode_to_utf8(cbuf, int32_arg);
                dbuf_put(&dbuf, cbuf, len);
                break;
                
            case 'd':
            case 'i':
            case 'o':
            case 'u':
            case 'x':
            case 'X':
                if (i >= argc)
                    goto missing;
                if (JS_ToInt64Ext(ctx, &int64_arg, argv[i++]))
                    goto fail;
                if (mod == 'l') {
                    /* 64 bit number */
#if defined(_WIN32)
                    if (q >= fmtbuf + sizeof(fmtbuf) - 3)
                        goto invalid;
                    q[2] = q[-1];
                    q[-1] = 'I';
                    q[0] = '6';
                    q[1] = '4';
                    q[3] = '\0';
                    dbuf_printf_fun(&dbuf, fmtbuf, (int64_t)int64_arg);
#else
                    if (q >= fmtbuf + sizeof(fmtbuf) - 2)
                        goto invalid;
                    q[1] = q[-1];
                    q[-1] = q[0] = 'l';
                    q[2] = '\0';
                    dbuf_printf_fun(&dbuf, fmtbuf, (long long)int64_arg);
#endif
                } else {
                    dbuf_printf_fun(&dbuf, fmtbuf, (int)int64_arg);
                }
                break;

            case 's':
                if (i >= argc)
                    goto missing;
                /* XXX: handle strings containing null characters */
                string_arg = JS_ToCString(ctx, argv[i++]);
                if (!string_arg)
                    goto fail;
                dbuf_printf_fun(&dbuf, fmtbuf, string_arg);
                JS_FreeCString(ctx, string_arg);
                break;
                
            case 'e':
            case 'f':
            case 'g':
            case 'a':
            case 'E':
            case 'F':
            case 'G':
            case 'A':
                if (i >= argc)
                    goto missing;
                if (JS_ToFloat64(ctx, &double_arg, argv[i++]))
                    goto fail;
                dbuf_printf_fun(&dbuf, fmtbuf, double_arg);
                break;
                
            case '%':
                dbuf_putc(&dbuf, '%');
                break;
                
            default:
                /* XXX: should support an extension mechanism */
            invalid:
                JS_ThrowTypeError(ctx, "invalid conversion specifier in format string");
                goto fail;
            missing:
                JS_ThrowReferenceError(ctx, "missing argument for conversion specifier");
                goto fail;
            }
        }
        JS_FreeCString(ctx, fmt_str);
    }
    if (dbuf.error) {
        res = JS_ThrowOutOfMemory(ctx);
    } else {
        if (fp) {
            len = fwrite(dbuf.buf, 1, dbuf.size, fp);
            res = JS_NewInt32(ctx, len);
        } else {
            res = JS_NewStringLen(ctx, (char *)dbuf.buf, dbuf.size);
        }
    }
    dbuf_free(&dbuf);
    return res;

fail:
    dbuf_free(&dbuf);
    return JS_EXCEPTION;
}

uint8_t *js_load_file(JSContext *ctx, size_t *pbuf_len, const char *filename)
{
    FILE *f;
    uint8_t *buf;
    size_t buf_len;
    long lret;
    
    f = fopen(filename, "rb");
    if (!f)
        return NULL;
    if (fseek(f, 0, SEEK_END) < 0)
        goto fail;
    lret = ftell(f);
    if (lret < 0)
        goto fail;
    /* XXX: on Linux, ftell() return LONG_MAX for directories */
    if (lret == LONG_MAX) {
        errno = EISDIR;
        goto fail;
    }
    buf_len = lret;
    if (fseek(f, 0, SEEK_SET) < 0)
        goto fail;
    if (ctx)
        buf = js_malloc(ctx, buf_len + 1);
    else
        buf = malloc(buf_len + 1);
    if (!buf)
        goto fail;
    if (fread(buf, 1, buf_len, f) != buf_len) {
        errno = EIO;
        if (ctx)
            js_free(ctx, buf);
        else
            free(buf);
    fail:
        fclose(f);
        return NULL;
    }
    buf[buf_len] = '\0';
    fclose(f);
    *pbuf_len = buf_len;
    return buf;
}

/* load and evaluate a file */
static JSValue js_loadScript(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
{
    uint8_t *buf;
    const char *filename;
    JSValue ret;
    size_t buf_len;
    
    filename = JS_ToCString(ctx, argv[0]);
    if (!filename)
        return JS_EXCEPTION;
    buf = js_load_file(ctx, &buf_len, filename);
    if (!buf) {
        JS_ThrowReferenceError(ctx, "could not load '%s'", filename);
        JS_FreeCString(ctx, filename);
        return JS_EXCEPTION;
    }
    ret = JS_Eval(ctx, (char *)buf, buf_len, filename,
                  JS_EVAL_TYPE_GLOBAL);
    js_free(ctx, buf);
    JS_FreeCString(ctx, filename);
    return ret;
}

/* load a file as a UTF-8 encoded string */
static JSValue js_std_loadFile(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv)
{
    uint8_t *buf;
    const char *filename;
    JSValue ret;
    size_t buf_len;
    
    filename = JS_ToCString(ctx, argv[0]);
    if (!filename)
        return JS_EXCEPTION;
    buf = js_load_file(ctx, &buf_len, filename);
    JS_FreeCString(ctx, filename);
    if (!buf)
        return JS_NULL;
    ret = JS_NewStringLen(ctx, (char *)buf, buf_len);
    js_free(ctx, buf);
    return ret;
}

typedef JSModuleDef *(JSInitModuleFunc)(JSContext *ctx,
                                        const char *module_name);

#if defined(_WIN32)
static JSModuleDef *js_module_loader_so(JSContext *ctx,
                                        const char *module_name)
{
    JS_ThrowReferenceError(ctx, "shared library modules are not supported yet");
    return NULL;
}
#else
static JSModuleDef *js_module_loader_so(JSContext *ctx,
                                        const char *module_name)
{
    JSModuleDef *m;
    void *hd;
    JSInitModuleFunc *init;
    char *filename;
    
    if (!strchr(module_name, '/')) {
        /* must add a '/' so that the DLL is not searched in the
           system library paths */
        filename = js_malloc(ctx, strlen(module_name) + 2 + 1);
        if (!filename)
            return NULL;
        strcpy(filename, "./");
        strcpy(filename + 2, module_name);
    } else {
        filename = (char *)module_name;
    }
    
    /* C module */
    hd = dlopen(filename, RTLD_NOW | RTLD_LOCAL);
    if (filename != module_name)
        js_free(ctx, filename);
    if (!hd) {
        JS_ThrowReferenceError(ctx, "could not load module filename '%s' as shared library",
                               module_name);
        goto fail;
    }

    init = dlsym(hd, "js_init_module");
    if (!init) {
        JS_ThrowReferenceError(ctx, "could not load module filename '%s': js_init_module not found",
                               module_name);
        goto fail;
    }

    m = init(ctx, module_name);
    if (!m) {
        JS_ThrowReferenceError(ctx, "could not load module filename '%s': initialization error",
                               module_name);
    fail:
        if (hd)
            dlclose(hd);
        return NULL;
    }
    return m;
}
#endif /* !_WIN32 */

int js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,
                              JS_BOOL use_realpath, JS_BOOL is_main)
{
    JSModuleDef *m;
    char buf[PATH_MAX + 16];
    JSValue meta_obj;
    JSAtom module_name_atom;
    const char *module_name;
    
    assert(JS_VALUE_GET_TAG(func_val) == JS_TAG_MODULE);
    m = JS_VALUE_GET_PTR(func_val);

    module_name_atom = JS_GetModuleName(ctx, m);
    module_name = JS_AtomToCString(ctx, module_name_atom);
    JS_FreeAtom(ctx, module_name_atom);
    if (!module_name)
        return -1;
    if (!strchr(module_name, ':')) {
        strcpy(buf, "file://");
#if !defined(_WIN32)
        /* realpath() cannot be used with modules compiled with qjsc
           because the corresponding module source code is not
           necessarily present */
        if (use_realpath) {
            char *res = realpath(module_name, buf + strlen(buf));
            if (!res) {
                JS_ThrowTypeError(ctx, "realpath failure");
                JS_FreeCString(ctx, module_name);
                return -1;
            }
        } else
#endif
        {
            pstrcat(buf, sizeof(buf), module_name);
        }
    } else {
        pstrcpy(buf, sizeof(buf), module_name);
    }
    JS_FreeCString(ctx, module_name);
    
    meta_obj = JS_GetImportMeta(ctx, m);
    if (JS_IsException(meta_obj))
        return -1;
    JS_DefinePropertyValueStr(ctx, meta_obj, "url",
                              JS_NewString(ctx, buf),
                              JS_PROP_C_W_E);
    JS_DefinePropertyValueStr(ctx, meta_obj, "main",
                              JS_NewBool(ctx, is_main),
                              JS_PROP_C_W_E);
    JS_FreeValue(ctx, meta_obj);
    return 0;
}

JSModuleDef *js_module_loader(JSContext *ctx,
                              const char *module_name, void *opaque)
{
    JSModuleDef *m;

    if (has_suffix(module_name, ".so")) {
        m = js_module_loader_so(ctx, module_name);
    } else {
        size_t buf_len;
        uint8_t *buf;
        JSValue func_val;
    
        buf = js_load_file(ctx, &buf_len, module_name);
        if (!buf) {
            JS_ThrowReferenceError(ctx, "could not load module filename '%s'",
                                   module_name);
            return NULL;
        }
        
        /* compile the module */
        func_val = JS_Eval(ctx, (char *)buf, buf_len, module_name,
                           JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);
        js_free(ctx, buf);
        if (JS_IsException(func_val))
            return NULL;
        /* XXX: could propagate the exception */
        js_module_set_import_meta(ctx, func_val, TRUE, FALSE);
        /* the module is already referenced, so we must free it */
        m = JS_VALUE_GET_PTR(func_val);
        JS_FreeValue(ctx, func_val);
    }
    return m;
}

static JSValue js_std_exit(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
{
    int status;
    if (JS_ToInt32(ctx, &status, argv[0]))
        status = -1;
    exit(status);
    return JS_UNDEFINED;
}

static JSValue js_std_getenv(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
{
    const char *name, *str;
    name = JS_ToCString(ctx, argv[0]);
    if (!name)
        return JS_EXCEPTION;
    str = getenv(name);
    JS_FreeCString(ctx, name);
    if (!str)
        return JS_UNDEFINED;
    else
        return JS_NewString(ctx, str);
}

#if defined(_WIN32)
static void setenv(const char *name, const char *value, int overwrite)
{
    char *str;
    size_t name_len, value_len;
    name_len = strlen(name);
    value_len = strlen(value);
    str = malloc(name_len + 1 + value_len + 1);
    memcpy(str, name, name_len);
    str[name_len] = '=';
    memcpy(str + name_len + 1, value, value_len);
    str[name_len + 1 + value_len] = '\0';
    _putenv(str);
    free(str);
}

static void unsetenv(const char *name)
{
    setenv(name, "", TRUE);
}
#endif /* _WIN32 */

static JSValue js_std_setenv(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
{
    const char *name, *value;
    name = JS_ToCString(ctx, argv[0]);
    if (!name)
        return JS_EXCEPTION;
    value = JS_ToCString(ctx, argv[1]);
    if (!value) {
        JS_FreeCString(ctx, name);
        return JS_EXCEPTION;
    }
    setenv(name, value, TRUE);
    JS_FreeCString(ctx, name);
    JS_FreeCString(ctx, value);
    return JS_UNDEFINED;
}

static JSValue js_std_unsetenv(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv)
{
    const char *name;
    name = JS_ToCString(ctx, argv[0]);
    if (!name)
        return JS_EXCEPTION;
    unsetenv(name);
    JS_FreeCString(ctx, name);
    return JS_UNDEFINED;
}

/* return an object containing the list of the available environment
   variables. */
static JSValue js_std_getenviron(JSContext *ctx, JSValueConst this_val,
                                 int argc, JSValueConst *argv)
{
    char **envp;
    const char *name, *p, *value;
    JSValue obj;
    uint32_t idx;
    size_t name_len;
    JSAtom atom;
    int ret;

    obj = JS_NewObject(ctx);
    if (JS_IsException(obj))
        return JS_EXCEPTION;
    envp = environ;
    for(idx = 0; envp[idx] != NULL; idx++) {
        name = envp[idx];
        p = strchr(name, '=');
        name_len = p - name;
        if (!p)
            continue;
        value = p + 1;
        atom = JS_NewAtomLen(ctx, name, name_len);
        if (atom == JS_ATOM_NULL)
            goto fail;
        ret = JS_DefinePropertyValue(ctx, obj, atom, JS_NewString(ctx, value),
                                     JS_PROP_C_W_E);
        JS_FreeAtom(ctx, atom);
        if (ret < 0)
            goto fail;
    }
    return obj;
 fail:
    JS_FreeValue(ctx, obj);
    return JS_EXCEPTION;
}

static JSValue js_std_gc(JSContext *ctx, JSValueConst this_val,
                         int argc, JSValueConst *argv)
{
    JS_RunGC(JS_GetRuntime(ctx));
    return JS_UNDEFINED;
}

static int interrupt_handler(JSRuntime *rt, void *opaque)
{
    return (os_pending_signals >> SIGINT) & 1;
}

static int get_bool_option(JSContext *ctx, BOOL *pbool,
                           JSValueConst obj,
                           const char *option)
{
    JSValue val;
    val = JS_GetPropertyStr(ctx, obj, option);
    if (JS_IsException(val))
        return -1;
    if (!JS_IsUndefined(val)) {
        *pbool = JS_ToBool(ctx, val);
    }
    JS_FreeValue(ctx, val);
    return 0;
}

static JSValue js_evalScript(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
{
    JSRuntime *rt = JS_GetRuntime(ctx);
    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
    const char *str;
    size_t len;
    JSValue ret;
    JSValueConst options_obj;
    BOOL backtrace_barrier = FALSE;
    int flags;
    
    if (argc >= 2) {
        options_obj = argv[1];
        if (get_bool_option(ctx, &backtrace_barrier, options_obj,
                            "backtrace_barrier"))
            return JS_EXCEPTION;
    }

    str = JS_ToCStringLen(ctx, &len, argv[0]);
    if (!str)
        return JS_EXCEPTION;
    if (!ts->recv_pipe && ++ts->eval_script_recurse == 1) {
        /* install the interrupt handler */
        JS_SetInterruptHandler(JS_GetRuntime(ctx), interrupt_handler, NULL);
    }
    flags = JS_EVAL_TYPE_GLOBAL; 
    if (backtrace_barrier)
        flags |= JS_EVAL_FLAG_BACKTRACE_BARRIER;
    ret = JS_Eval(ctx, str, len, "<evalScript>", flags);
    JS_FreeCString(ctx, str);
    if (!ts->recv_pipe && --ts->eval_script_recurse == 0) {
        /* remove the interrupt handler */
        JS_SetInterruptHandler(JS_GetRuntime(ctx), NULL, NULL);
        os_pending_signals &= ~((uint64_t)1 << SIGINT);
        /* convert the uncatchable "interrupted" error into a normal error
           so that it can be caught by the REPL */
        if (JS_IsException(ret))
            JS_ResetUncatchableError(ctx);
    }
    return ret;
}

static JSClassID js_std_file_class_id;

typedef struct {
    FILE *f;
    BOOL close_in_finalizer;
    BOOL is_popen;
} JSSTDFile;

static void js_std_file_finalizer(JSRuntime *rt, JSValue val)
{
    JSSTDFile *s = JS_GetOpaque(val, js_std_file_class_id);
    if (s) {
        if (s->f && s->close_in_finalizer) {
            if (s->is_popen)
                pclose(s->f);
            else
                fclose(s->f);
        }
        js_free_rt(rt, s);
    }
}

static ssize_t js_get_errno(ssize_t ret)
{
    if (ret == -1)
        ret = -errno;
    return ret;
}

static JSValue js_std_strerror(JSContext *ctx, JSValueConst this_val,
                                     int argc, JSValueConst *argv)
{
    int err;
    if (JS_ToInt32(ctx, &err, argv[0]))
        return JS_EXCEPTION;
    return JS_NewString(ctx, strerror(err));
}

static JSValue js_std_parseExtJSON(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv)
{
    JSValue obj;
    const char *str;
    size_t len;

    str = JS_ToCStringLen(ctx, &len, argv[0]);
    if (!str)
        return JS_EXCEPTION;
    obj = JS_ParseJSON2(ctx, str, len, "<input>", JS_PARSE_JSON_EXT);
    JS_FreeCString(ctx, str);
    return obj;
}

static JSValue js_new_std_file(JSContext *ctx, FILE *f,
                               BOOL close_in_finalizer,
                               BOOL is_popen)
{
    JSSTDFile *s;
    JSValue obj;
    obj = JS_NewObjectClass(ctx, js_std_file_class_id);
    if (JS_IsException(obj))
        return obj;
    s = js_mallocz(ctx, sizeof(*s));
    if (!s) {
        JS_FreeValue(ctx, obj);
        return JS_EXCEPTION;
    }
    s->close_in_finalizer = close_in_finalizer;
    s->is_popen = is_popen;
    s->f = f;
    JS_SetOpaque(obj, s);
    return obj;
}

static void js_set_error_object(JSContext *ctx, JSValue obj, int err)
{
    if (!JS_IsUndefined(obj)) {
        JS_SetPropertyStr(ctx, obj, "errno", JS_NewInt32(ctx, err));
    }
}

static JSValue js_std_open(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
{
    const char *filename, *mode = NULL;
    FILE *f;
    int err;
    
    filename = JS_ToCString(ctx, argv[0]);
    if (!filename)
        goto fail;
    mode = JS_ToCString(ctx, argv[1]);
    if (!mode)
        goto fail;
    if (mode[strspn(mode, "rwa+b")] != '\0') {
        JS_ThrowTypeError(ctx, "invalid file mode");
        goto fail;
    }

    f = fopen(filename, mode);
    if (!f)
        err = errno;
    else
        err = 0;
    if (argc >= 3)
        js_set_error_object(ctx, argv[2], err);
    JS_FreeCString(ctx, filename);
    JS_FreeCString(ctx, mode);
    if (!f)
        return JS_NULL;
    return js_new_std_file(ctx, f, TRUE, FALSE);
 fail:
    JS_FreeCString(ctx, filename);
    JS_FreeCString(ctx, mode);
    return JS_EXCEPTION;
}

static JSValue js_std_popen(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
{
    const char *filename, *mode = NULL;
    FILE *f;
    int err;
    
    filename = JS_ToCString(ctx, argv[0]);
    if (!filename)
        goto fail;
    mode = JS_ToCString(ctx, argv[1]);
    if (!mode)
        goto fail;
    if (mode[strspn(mode, "rw")] != '\0') {
        JS_ThrowTypeError(ctx, "invalid file mode");
        goto fail;
    }

    f = popen(filename, mode);
    if (!f)
        err = errno;
    else
        err = 0;
    if (argc >= 3)
        js_set_error_object(ctx, argv[2], err);
    JS_FreeCString(ctx, filename);
    JS_FreeCString(ctx, mode);
    if (!f)
        return JS_NULL;
    return js_new_std_file(ctx, f, TRUE, TRUE);
 fail:
    JS_FreeCString(ctx, filename);
    JS_FreeCString(ctx, mode);
    return JS_EXCEPTION;
}

static JSValue js_std_fdopen(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
{
    const char *mode;
    FILE *f;
    int fd, err;

    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    mode = JS_ToCString(ctx, argv[1]);
    if (!mode)
        goto fail;
    if (mode[strspn(mode, "rwa+")] != '\0') {
        JS_ThrowTypeError(ctx, "invalid file mode");
        goto fail;
    }

    f = fdopen(fd, mode);
    if (!f)
        err = errno;
    else
        err = 0;
    if (argc >= 3)
        js_set_error_object(ctx, argv[2], err);
    JS_FreeCString(ctx, mode);
    if (!f)
        return JS_NULL;
    return js_new_std_file(ctx, f, TRUE, FALSE);
 fail:
    JS_FreeCString(ctx, mode);
    return JS_EXCEPTION;
}

static JSValue js_std_tmpfile(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
{
    FILE *f;
    f = tmpfile();
    if (argc >= 1)
        js_set_error_object(ctx, argv[0], f ? 0 : errno);
    if (!f)
        return JS_NULL;
    return js_new_std_file(ctx, f, TRUE, FALSE);
}

static JSValue js_std_sprintf(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
{
    return js_printf_internal(ctx, argc, argv, NULL);
}

static JSValue js_std_printf(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
{
    return js_printf_internal(ctx, argc, argv, stdout);
}

static FILE *js_std_file_get(JSContext *ctx, JSValueConst obj)
{
    JSSTDFile *s = JS_GetOpaque2(ctx, obj, js_std_file_class_id);
    if (!s)
        return NULL;
    if (!s->f) {
        JS_ThrowTypeError(ctx, "invalid file handle");
        return NULL;
    }
    return s->f;
}

static JSValue js_std_file_puts(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv, int magic)
{
    FILE *f;
    int i;
    const char *str;
    size_t len;

    if (magic == 0) {
        f = stdout;
    } else {
        f = js_std_file_get(ctx, this_val);
        if (!f)
            return JS_EXCEPTION;
    }
    
    for(i = 0; i < argc; i++) {
        str = JS_ToCStringLen(ctx, &len, argv[i]);
        if (!str)
            return JS_EXCEPTION;
        fwrite(str, 1, len, f);
        JS_FreeCString(ctx, str);
    }
    return JS_UNDEFINED;
}

static JSValue js_std_file_close(JSContext *ctx, JSValueConst this_val,
                                 int argc, JSValueConst *argv)
{
    JSSTDFile *s = JS_GetOpaque2(ctx, this_val, js_std_file_class_id);
    int err;
    if (!s)
        return JS_EXCEPTION;
    if (!s->f)
        return JS_ThrowTypeError(ctx, "invalid file handle");
    if (s->is_popen)
        err = js_get_errno(pclose(s->f));
    else
        err = js_get_errno(fclose(s->f));
    s->f = NULL;
    return JS_NewInt32(ctx, err);
}

static JSValue js_std_file_printf(JSContext *ctx, JSValueConst this_val,
                                  int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    if (!f)
        return JS_EXCEPTION;
    return js_printf_internal(ctx, argc, argv, f);
}

static JSValue js_std_file_flush(JSContext *ctx, JSValueConst this_val,
                                 int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    if (!f)
        return JS_EXCEPTION;
    fflush(f);
    return JS_UNDEFINED;
}

static JSValue js_std_file_tell(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv, int is_bigint)
{
    FILE *f = js_std_file_get(ctx, this_val);
    int64_t pos;
    if (!f)
        return JS_EXCEPTION;
#if defined(__linux__)
    pos = ftello(f);
#else
    pos = ftell(f);
#endif
    if (is_bigint)
        return JS_NewBigInt64(ctx, pos);
    else
        return JS_NewInt64(ctx, pos);
}

static JSValue js_std_file_seek(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    int64_t pos;
    int whence, ret;
    if (!f)
        return JS_EXCEPTION;
    if (JS_ToInt64Ext(ctx, &pos, argv[0]))
        return JS_EXCEPTION;
    if (JS_ToInt32(ctx, &whence, argv[1]))
        return JS_EXCEPTION;
#if defined(__linux__)
    ret = fseeko(f, pos, whence);
#else
    ret = fseek(f, pos, whence);
#endif
    if (ret < 0)
        ret = -errno;
    return JS_NewInt32(ctx, ret);
}

static JSValue js_std_file_eof(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    if (!f)
        return JS_EXCEPTION;
    return JS_NewBool(ctx, feof(f));
}

static JSValue js_std_file_error(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    if (!f)
        return JS_EXCEPTION;
    return JS_NewBool(ctx, ferror(f));
}

static JSValue js_std_file_clearerr(JSContext *ctx, JSValueConst this_val,
                                    int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    if (!f)
        return JS_EXCEPTION;
    clearerr(f);
    return JS_UNDEFINED;
}

static JSValue js_std_file_fileno(JSContext *ctx, JSValueConst this_val,
                                  int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    if (!f)
        return JS_EXCEPTION;
    return JS_NewInt32(ctx, fileno(f));
}

static JSValue js_std_file_read_write(JSContext *ctx, JSValueConst this_val,
                                      int argc, JSValueConst *argv, int magic)
{
    FILE *f = js_std_file_get(ctx, this_val);
    uint64_t pos, len;
    size_t size, ret;
    uint8_t *buf;
    
    if (!f)
        return JS_EXCEPTION;
    if (JS_ToIndex(ctx, &pos, argv[1]))
        return JS_EXCEPTION;
    if (JS_ToIndex(ctx, &len, argv[2]))
        return JS_EXCEPTION;
    buf = JS_GetArrayBuffer(ctx, &size, argv[0]);
    if (!buf)
        return JS_EXCEPTION;
    if (pos + len > size)
        return JS_ThrowRangeError(ctx, "read/write array buffer overflow");
    if (magic)
        ret = fwrite(buf + pos, 1, len, f);
    else
        ret = fread(buf + pos, 1, len, f);
    return JS_NewInt64(ctx, ret);
}

/* XXX: could use less memory and go faster */
static JSValue js_std_file_getline(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    int c;
    DynBuf dbuf;
    JSValue obj;
    
    if (!f)
        return JS_EXCEPTION;

    js_std_dbuf_init(ctx, &dbuf);
    for(;;) {
        c = fgetc(f);
        if (c == EOF) {
            if (dbuf.size == 0) {
                /* EOF */
                dbuf_free(&dbuf);
                return JS_NULL;
            } else {
                break;
            }
        }
        if (c == '\n')
            break;
        if (dbuf_putc(&dbuf, c)) {
            dbuf_free(&dbuf);
            return JS_ThrowOutOfMemory(ctx);
        }
    }
    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);
    dbuf_free(&dbuf);
    return obj;
}

/* XXX: could use less memory and go faster */
static JSValue js_std_file_readAsString(JSContext *ctx, JSValueConst this_val,
                                        int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    int c;
    DynBuf dbuf;
    JSValue obj;
    uint64_t max_size64;
    size_t max_size;
    JSValueConst max_size_val;
    
    if (!f)
        return JS_EXCEPTION;

    if (argc >= 1)
        max_size_val = argv[0];
    else
        max_size_val = JS_UNDEFINED;
    max_size = (size_t)-1;
    if (!JS_IsUndefined(max_size_val)) {
        if (JS_ToIndex(ctx, &max_size64, max_size_val))
            return JS_EXCEPTION;
        if (max_size64 < max_size)
            max_size = max_size64;
    }

    js_std_dbuf_init(ctx, &dbuf);
    while (max_size != 0) {
        c = fgetc(f);
        if (c == EOF)
            break;
        if (dbuf_putc(&dbuf, c)) {
            dbuf_free(&dbuf);
            return JS_EXCEPTION;
        }
        max_size--;
    }
    obj = JS_NewStringLen(ctx, (const char *)dbuf.buf, dbuf.size);
    dbuf_free(&dbuf);
    return obj;
}

static JSValue js_std_file_getByte(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    if (!f)
        return JS_EXCEPTION;
    return JS_NewInt32(ctx, fgetc(f));
}

static JSValue js_std_file_putByte(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv)
{
    FILE *f = js_std_file_get(ctx, this_val);
    int c;
    if (!f)
        return JS_EXCEPTION;
    if (JS_ToInt32(ctx, &c, argv[0]))
        return JS_EXCEPTION;
    c = fputc(c, f);
    return JS_NewInt32(ctx, c);
}

/* urlGet */

#define URL_GET_PROGRAM "curl -s -i"
#define URL_GET_BUF_SIZE 4096

static int http_get_header_line(FILE *f, char *buf, size_t buf_size,
                                DynBuf *dbuf)
{
    int c;
    char *p;
    
    p = buf;
    for(;;) {
        c = fgetc(f);
        if (c < 0)
            return -1;
        if ((p - buf) < buf_size - 1)
            *p++ = c;
        if (dbuf)
            dbuf_putc(dbuf, c);
        if (c == '\n')
            break;
    }
    *p = '\0';
    return 0;
}

static int http_get_status(const char *buf)
{
    const char *p = buf;
    while (*p != ' ' && *p != '\0')
        p++;
    if (*p != ' ')
        return 0;
    while (*p == ' ')
        p++;
    return atoi(p);
}

static JSValue js_std_urlGet(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
{
    const char *url;
    DynBuf cmd_buf;
    DynBuf data_buf_s, *data_buf = &data_buf_s;
    DynBuf header_buf_s, *header_buf = &header_buf_s;
    char *buf; 
    size_t i, len;
    int c, status;
    JSValue response = JS_UNDEFINED, ret_obj;
    JSValueConst options_obj;
    FILE *f;
    BOOL binary_flag, full_flag;
    
    url = JS_ToCString(ctx, argv[0]);
    if (!url)
        return JS_EXCEPTION;
    
    binary_flag = FALSE;
    full_flag = FALSE;
    
    if (argc >= 2) {
        options_obj = argv[1];

        if (get_bool_option(ctx, &binary_flag, options_obj, "binary"))
            goto fail_obj;

        if (get_bool_option(ctx, &full_flag, options_obj, "full")) {
        fail_obj:
            JS_FreeCString(ctx, url);
            return JS_EXCEPTION;
        }
    }
    
    js_std_dbuf_init(ctx, &cmd_buf);
    dbuf_printf(&cmd_buf, "%s ''", URL_GET_PROGRAM);
    len = strlen(url);
    for(i = 0; i < len; i++) {
        c = url[i];
        if (c == '\'' || c == '\\')
            dbuf_putc(&cmd_buf, '\\');
        dbuf_putc(&cmd_buf, c);
    }
    JS_FreeCString(ctx, url);
    dbuf_putstr(&cmd_buf, "''");
    dbuf_putc(&cmd_buf, '\0');
    if (dbuf_error(&cmd_buf)) {
        dbuf_free(&cmd_buf);
        return JS_EXCEPTION;
    }
    //    printf("%s\n", (char *)cmd_buf.buf);
    f = popen((char *)cmd_buf.buf, "r");
    dbuf_free(&cmd_buf);
    if (!f) {
        return JS_ThrowTypeError(ctx, "could not start curl");
    }

    js_std_dbuf_init(ctx, data_buf);
    js_std_dbuf_init(ctx, header_buf);
    
    buf = js_malloc(ctx, URL_GET_BUF_SIZE);
    if (!buf)
        goto fail;

    /* get the HTTP status */
    if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, NULL) < 0) {
        status = 0;
        goto bad_header;
    }
    status = http_get_status(buf);
    if (!full_flag && !(status >= 200 && status <= 299)) {
        goto bad_header;
    }
    
    /* wait until there is an empty line */
    for(;;) {
        if (http_get_header_line(f, buf, URL_GET_BUF_SIZE, header_buf) < 0) {
        bad_header:
            response = JS_NULL;
            goto done;
        }
        if (!strcmp(buf, "\r\n"))
            break;
    }
    if (dbuf_error(header_buf))
        goto fail;
    header_buf->size -= 2; /* remove the trailing CRLF */

    /* download the data */
    for(;;) {
        len = fread(buf, 1, URL_GET_BUF_SIZE, f);
        if (len == 0)
            break;
        dbuf_put(data_buf, (uint8_t *)buf, len);
    }
    if (dbuf_error(data_buf))
        goto fail;
    if (binary_flag) {
        response = JS_NewArrayBufferCopy(ctx,
                                         data_buf->buf, data_buf->size);
    } else {
        response = JS_NewStringLen(ctx, (char *)data_buf->buf, data_buf->size);
    }
    if (JS_IsException(response))
        goto fail;
 done:
    js_free(ctx, buf);
    buf = NULL;
    pclose(f);
    f = NULL;
    dbuf_free(data_buf);
    data_buf = NULL;

    if (full_flag) {
        ret_obj = JS_NewObject(ctx);
        if (JS_IsException(ret_obj))
            goto fail;
        JS_DefinePropertyValueStr(ctx, ret_obj, "response",
                                  response,
                                  JS_PROP_C_W_E);
        if (!JS_IsNull(response)) {
            JS_DefinePropertyValueStr(ctx, ret_obj, "responseHeaders",
                                      JS_NewStringLen(ctx, (char *)header_buf->buf,
                                                      header_buf->size),
                                      JS_PROP_C_W_E);
            JS_DefinePropertyValueStr(ctx, ret_obj, "status",
                                      JS_NewInt32(ctx, status),
                                      JS_PROP_C_W_E);
        }
    } else {
        ret_obj = response;
    }
    dbuf_free(header_buf);
    return ret_obj;
 fail:
    if (f)
        pclose(f);
    js_free(ctx, buf);
    if (data_buf)
        dbuf_free(data_buf);
    if (header_buf)
        dbuf_free(header_buf);
    JS_FreeValue(ctx, response);
    return JS_EXCEPTION;
}

static JSClassDef js_std_file_class = {
    "FILE",
    .finalizer = js_std_file_finalizer,
}; 

static const JSCFunctionListEntry js_std_error_props[] = {
    /* various errno values */
#define DEF(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )
    DEF(EINVAL),
    DEF(EIO),
    DEF(EACCES),
    DEF(EEXIST),
    DEF(ENOSPC),
    DEF(ENOSYS),
    DEF(EBUSY),
    DEF(ENOENT),
    DEF(EPERM),
    DEF(EPIPE),
    DEF(EBADF),
#undef DEF
};

static const JSCFunctionListEntry js_std_funcs[] = {
    JS_CFUNC_DEF("exit", 1, js_std_exit ),
    JS_CFUNC_DEF("gc", 0, js_std_gc ),
    JS_CFUNC_DEF("evalScript", 1, js_evalScript ),
    JS_CFUNC_DEF("loadScript", 1, js_loadScript ),
    JS_CFUNC_DEF("getenv", 1, js_std_getenv ),
    JS_CFUNC_DEF("setenv", 1, js_std_setenv ),
    JS_CFUNC_DEF("unsetenv", 1, js_std_unsetenv ),
    JS_CFUNC_DEF("getenviron", 1, js_std_getenviron ),
    JS_CFUNC_DEF("urlGet", 1, js_std_urlGet ),
    JS_CFUNC_DEF("loadFile", 1, js_std_loadFile ),
    JS_CFUNC_DEF("strerror", 1, js_std_strerror ),
    JS_CFUNC_DEF("parseExtJSON", 1, js_std_parseExtJSON ),
    
    /* FILE I/O */
    JS_CFUNC_DEF("open", 2, js_std_open ),
    JS_CFUNC_DEF("popen", 2, js_std_popen ),
    JS_CFUNC_DEF("fdopen", 2, js_std_fdopen ),
    JS_CFUNC_DEF("tmpfile", 0, js_std_tmpfile ),
    JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 0 ),
    JS_CFUNC_DEF("printf", 1, js_std_printf ),
    JS_CFUNC_DEF("sprintf", 1, js_std_sprintf ),
    JS_PROP_INT32_DEF("SEEK_SET", SEEK_SET, JS_PROP_CONFIGURABLE ),
    JS_PROP_INT32_DEF("SEEK_CUR", SEEK_CUR, JS_PROP_CONFIGURABLE ),
    JS_PROP_INT32_DEF("SEEK_END", SEEK_END, JS_PROP_CONFIGURABLE ),
    JS_OBJECT_DEF("Error", js_std_error_props, countof(js_std_error_props), JS_PROP_CONFIGURABLE),
};
    
static const JSCFunctionListEntry js_std_file_proto_funcs[] = {
    JS_CFUNC_DEF("close", 0, js_std_file_close ),
    JS_CFUNC_MAGIC_DEF("puts", 1, js_std_file_puts, 1 ),
    JS_CFUNC_DEF("printf", 1, js_std_file_printf ),
    JS_CFUNC_DEF("flush", 0, js_std_file_flush ),
    JS_CFUNC_MAGIC_DEF("tell", 0, js_std_file_tell, 0 ),
    JS_CFUNC_MAGIC_DEF("tello", 0, js_std_file_tell, 1 ),
    JS_CFUNC_DEF("seek", 2, js_std_file_seek ),
    JS_CFUNC_DEF("eof", 0, js_std_file_eof ),
    JS_CFUNC_DEF("fileno", 0, js_std_file_fileno ),
    JS_CFUNC_DEF("error", 0, js_std_file_error ),
    JS_CFUNC_DEF("clearerr", 0, js_std_file_clearerr ),
    JS_CFUNC_MAGIC_DEF("read", 3, js_std_file_read_write, 0 ),
    JS_CFUNC_MAGIC_DEF("write", 3, js_std_file_read_write, 1 ),
    JS_CFUNC_DEF("getline", 0, js_std_file_getline ),
    JS_CFUNC_DEF("readAsString", 0, js_std_file_readAsString ),
    JS_CFUNC_DEF("getByte", 0, js_std_file_getByte ),
    JS_CFUNC_DEF("putByte", 1, js_std_file_putByte ),
    /* setvbuf, ...  */
};

static int js_std_init(JSContext *ctx, JSModuleDef *m)
{
    JSValue proto;
    
    /* FILE class */
    /* the class ID is created once */
    JS_NewClassID(&js_std_file_class_id);
    /* the class is created once per runtime */
    JS_NewClass(JS_GetRuntime(ctx), js_std_file_class_id, &js_std_file_class);
    proto = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(ctx, proto, js_std_file_proto_funcs,
                               countof(js_std_file_proto_funcs));
    JS_SetClassProto(ctx, js_std_file_class_id, proto);

    JS_SetModuleExportList(ctx, m, js_std_funcs,
                           countof(js_std_funcs));
    JS_SetModuleExport(ctx, m, "in", js_new_std_file(ctx, stdin, FALSE, FALSE));
    JS_SetModuleExport(ctx, m, "out", js_new_std_file(ctx, stdout, FALSE, FALSE));
    JS_SetModuleExport(ctx, m, "err", js_new_std_file(ctx, stderr, FALSE, FALSE));
    return 0;
}

JSModuleDef *js_init_module_std(JSContext *ctx, const char *module_name)
{
    JSModuleDef *m;
    m = JS_NewCModule(ctx, module_name, js_std_init);
    if (!m)
        return NULL;
    JS_AddModuleExportList(ctx, m, js_std_funcs, countof(js_std_funcs));
    JS_AddModuleExport(ctx, m, "in");
    JS_AddModuleExport(ctx, m, "out");
    JS_AddModuleExport(ctx, m, "err");
    return m;
}

/**********************************************************/
/* 'os' object */

static JSValue js_os_open(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
{
    const char *filename;
    int flags, mode, ret;

    filename = JS_ToCString(ctx, argv[0]);
    if (!filename)
        return JS_EXCEPTION;
    if (JS_ToInt32(ctx, &flags, argv[1]))
        goto fail;
    if (argc >= 3 && !JS_IsUndefined(argv[2])) {
        if (JS_ToInt32(ctx, &mode, argv[2])) {
        fail:
            JS_FreeCString(ctx, filename);
            return JS_EXCEPTION;
        }
    } else {
        mode = 0666;
    }
#if defined(_WIN32)
    /* force binary mode by default */
    if (!(flags & O_TEXT))
        flags |= O_BINARY;
#endif
    ret = js_get_errno(open(filename, flags, mode));
    JS_FreeCString(ctx, filename);
    return JS_NewInt32(ctx, ret);
}

static JSValue js_os_close(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
{
    int fd, ret;
    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    ret = js_get_errno(close(fd));
    return JS_NewInt32(ctx, ret);
}

static JSValue js_os_seek(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
{
    int fd, whence;
    int64_t pos, ret;
    BOOL is_bigint;
    
    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    is_bigint = JS_IsBigInt(ctx, argv[1]);
    if (JS_ToInt64Ext(ctx, &pos, argv[1]))
        return JS_EXCEPTION;
    if (JS_ToInt32(ctx, &whence, argv[2]))
        return JS_EXCEPTION;
    ret = lseek(fd, pos, whence);
    if (ret == -1)
        ret = -errno;
    if (is_bigint)
        return JS_NewBigInt64(ctx, ret);
    else
        return JS_NewInt64(ctx, ret);
}

static JSValue js_os_read_write(JSContext *ctx, JSValueConst this_val,
                                      int argc, JSValueConst *argv, int magic)
{
    int fd;
    uint64_t pos, len;
    size_t size;
    ssize_t ret;
    uint8_t *buf;
    
    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    if (JS_ToIndex(ctx, &pos, argv[2]))
        return JS_EXCEPTION;
    if (JS_ToIndex(ctx, &len, argv[3]))
        return JS_EXCEPTION;
    buf = JS_GetArrayBuffer(ctx, &size, argv[1]);
    if (!buf)
        return JS_EXCEPTION;
    if (pos + len > size)
        return JS_ThrowRangeError(ctx, "read/write array buffer overflow");
    if (magic)
        ret = js_get_errno(write(fd, buf + pos, len));
    else
        ret = js_get_errno(read(fd, buf + pos, len));
    return JS_NewInt64(ctx, ret);
}

static JSValue js_os_isatty(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
{
    int fd;
    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    return JS_NewBool(ctx, (isatty(fd) != 0));
}

#if defined(_WIN32)
static JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv)
{
    int fd;
    HANDLE handle;
    CONSOLE_SCREEN_BUFFER_INFO info;
    JSValue obj;

    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    handle = (HANDLE)_get_osfhandle(fd);
    
    if (!GetConsoleScreenBufferInfo(handle, &info))
        return JS_NULL;
    obj = JS_NewArray(ctx);
    if (JS_IsException(obj))
        return obj;
    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, info.dwSize.X), JS_PROP_C_W_E);
    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, info.dwSize.Y), JS_PROP_C_W_E);
    return obj;
}

/* Windows 10 built-in VT100 emulation */
#define __ENABLE_VIRTUAL_TERMINAL_PROCESSING 0x0004
#define __ENABLE_VIRTUAL_TERMINAL_INPUT 0x0200

static JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv)
{
    int fd;
    HANDLE handle;

    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    handle = (HANDLE)_get_osfhandle(fd);
    SetConsoleMode(handle, ENABLE_WINDOW_INPUT | __ENABLE_VIRTUAL_TERMINAL_INPUT);
    _setmode(fd, _O_BINARY);
    if (fd == 0) {
        handle = (HANDLE)_get_osfhandle(1); /* corresponding output */
        SetConsoleMode(handle, ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT | __ENABLE_VIRTUAL_TERMINAL_PROCESSING);
    }
    return JS_UNDEFINED;
}
#else
static JSValue js_os_ttyGetWinSize(JSContext *ctx, JSValueConst this_val,
                                   int argc, JSValueConst *argv)
{
    int fd;
    struct winsize ws;
    JSValue obj;
    
    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    if (ioctl(fd, TIOCGWINSZ, &ws) == 0 &&
        ws.ws_col >= 4 && ws.ws_row >= 4) {
        obj = JS_NewArray(ctx);
        if (JS_IsException(obj))
            return obj;
        JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, ws.ws_col), JS_PROP_C_W_E);
        JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, ws.ws_row), JS_PROP_C_W_E);
        return obj;
    } else {
        return JS_NULL;
    }
}

static struct termios oldtty;

static void term_exit(void)
{
    tcsetattr(0, TCSANOW, &oldtty);
}

/* XXX: should add a way to go back to normal mode */
static JSValue js_os_ttySetRaw(JSContext *ctx, JSValueConst this_val,
                               int argc, JSValueConst *argv)
{
    struct termios tty;
    int fd;
    
    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    
    memset(&tty, 0, sizeof(tty));
    tcgetattr(fd, &tty);
    oldtty = tty;

    tty.c_iflag &= ~(IGNBRK|BRKINT|PARMRK|ISTRIP
                          |INLCR|IGNCR|ICRNL|IXON);
    tty.c_oflag |= OPOST;
    tty.c_lflag &= ~(ECHO|ECHONL|ICANON|IEXTEN);
    tty.c_cflag &= ~(CSIZE|PARENB);
    tty.c_cflag |= CS8;
    tty.c_cc[VMIN] = 1;
    tty.c_cc[VTIME] = 0;

    tcsetattr(fd, TCSANOW, &tty);

    atexit(term_exit);
    return JS_UNDEFINED;
}

#endif /* !_WIN32 */

static JSValue js_os_remove(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
{
    const char *filename;
    int ret;
    
    filename = JS_ToCString(ctx, argv[0]);
    if (!filename)
        return JS_EXCEPTION;
#if defined(_WIN32)
    {
        struct stat st;
        if (stat(filename, &st) == 0 && S_ISDIR(st.st_mode)) {
            ret = rmdir(filename);
        } else {
            ret = unlink(filename);
        }
    }
#else
    ret = remove(filename);
#endif
    ret = js_get_errno(ret);
    JS_FreeCString(ctx, filename);
    return JS_NewInt32(ctx, ret);
}

static JSValue js_os_rename(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
{
    const char *oldpath, *newpath;
    int ret;
    
    oldpath = JS_ToCString(ctx, argv[0]);
    if (!oldpath)
        return JS_EXCEPTION;
    newpath = JS_ToCString(ctx, argv[1]);
    if (!newpath) {
        JS_FreeCString(ctx, oldpath);
        return JS_EXCEPTION;
    }
    ret = js_get_errno(rename(oldpath, newpath));
    JS_FreeCString(ctx, oldpath);
    JS_FreeCString(ctx, newpath);
    return JS_NewInt32(ctx, ret);
}

static BOOL is_main_thread(JSRuntime *rt)
{
    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
    return !ts->recv_pipe;
}

static JSOSRWHandler *find_rh(JSThreadState *ts, int fd)
{
    JSOSRWHandler *rh;
    struct list_head *el;

    list_for_each(el, &ts->os_rw_handlers) {
        rh = list_entry(el, JSOSRWHandler, link);
        if (rh->fd == fd)
            return rh;
    }
    return NULL;
}

static void free_rw_handler(JSRuntime *rt, JSOSRWHandler *rh)
{
    int i;
    list_del(&rh->link);
    for(i = 0; i < 2; i++) {
        JS_FreeValueRT(rt, rh->rw_func[i]);
    }
    js_free_rt(rt, rh);
}

static JSValue js_os_setReadHandler(JSContext *ctx, JSValueConst this_val,
                                    int argc, JSValueConst *argv, int magic)
{
    JSRuntime *rt = JS_GetRuntime(ctx);
    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
    JSOSRWHandler *rh;
    int fd;
    JSValueConst func;
    
    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    func = argv[1];
    if (JS_IsNull(func)) {
        rh = find_rh(ts, fd);
        if (rh) {
            JS_FreeValue(ctx, rh->rw_func[magic]);
            rh->rw_func[magic] = JS_NULL;
            if (JS_IsNull(rh->rw_func[0]) &&
                JS_IsNull(rh->rw_func[1])) {
                /* remove the entry */
                free_rw_handler(JS_GetRuntime(ctx), rh);
            }
        }
    } else {
        if (!JS_IsFunction(ctx, func))
            return JS_ThrowTypeError(ctx, "not a function");
        rh = find_rh(ts, fd);
        if (!rh) {
            rh = js_mallocz(ctx, sizeof(*rh));
            if (!rh)
                return JS_EXCEPTION;
            rh->fd = fd;
            rh->rw_func[0] = JS_NULL;
            rh->rw_func[1] = JS_NULL;
            list_add_tail(&rh->link, &ts->os_rw_handlers);
        }
        JS_FreeValue(ctx, rh->rw_func[magic]);
        rh->rw_func[magic] = JS_DupValue(ctx, func);
    }
    return JS_UNDEFINED;
}

static JSOSSignalHandler *find_sh(JSThreadState *ts, int sig_num)
{
    JSOSSignalHandler *sh;
    struct list_head *el;
    list_for_each(el, &ts->os_signal_handlers) {
        sh = list_entry(el, JSOSSignalHandler, link);
        if (sh->sig_num == sig_num)
            return sh;
    }
    return NULL;
}

static void free_sh(JSRuntime *rt, JSOSSignalHandler *sh)
{
    list_del(&sh->link);
    JS_FreeValueRT(rt, sh->func);
    js_free_rt(rt, sh);
}

static void os_signal_handler(int sig_num)
{
    os_pending_signals |= ((uint64_t)1 << sig_num);
}

#if defined(_WIN32)
typedef void (*sighandler_t)(int sig_num);
#endif

static JSValue js_os_signal(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
{
    JSRuntime *rt = JS_GetRuntime(ctx);
    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
    JSOSSignalHandler *sh;
    uint32_t sig_num;
    JSValueConst func;
    sighandler_t handler;

    if (!is_main_thread(rt))
        return JS_ThrowTypeError(ctx, "signal handler can only be set in the main thread");
    
    if (JS_ToUint32(ctx, &sig_num, argv[0]))
        return JS_EXCEPTION;
    if (sig_num >= 64)
        return JS_ThrowRangeError(ctx, "invalid signal number");
    func = argv[1];
    /* func = null: SIG_DFL, func = undefined, SIG_IGN */
    if (JS_IsNull(func) || JS_IsUndefined(func)) {
        sh = find_sh(ts, sig_num);
        if (sh) {
            free_sh(JS_GetRuntime(ctx), sh);
        }
        if (JS_IsNull(func))
            handler = SIG_DFL;
        else
            handler = SIG_IGN;
        signal(sig_num, handler);
    } else {
        if (!JS_IsFunction(ctx, func))
            return JS_ThrowTypeError(ctx, "not a function");
        sh = find_sh(ts, sig_num);
        if (!sh) {
            sh = js_mallocz(ctx, sizeof(*sh));
            if (!sh)
                return JS_EXCEPTION;
            sh->sig_num = sig_num;
            list_add_tail(&sh->link, &ts->os_signal_handlers);
        }
        JS_FreeValue(ctx, sh->func);
        sh->func = JS_DupValue(ctx, func);
        signal(sig_num, os_signal_handler);
    }
    return JS_UNDEFINED;
}

#if defined(__linux__) || defined(__APPLE__)
static int64_t get_time_ms(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);
}
#else
/* more portable, but does not work if the date is updated */
static int64_t get_time_ms(void)
{
    struct timeval tv;
    gettimeofday(&tv, NULL);
    return (int64_t)tv.tv_sec * 1000 + (tv.tv_usec / 1000);
}
#endif

static void unlink_timer(JSRuntime *rt, JSOSTimer *th)
{
    if (th->link.prev) {
        list_del(&th->link);
        th->link.prev = th->link.next = NULL;
    }
}

static void free_timer(JSRuntime *rt, JSOSTimer *th)
{
    JS_FreeValueRT(rt, th->func);
    js_free_rt(rt, th);
}

static JSClassID js_os_timer_class_id;

static void js_os_timer_finalizer(JSRuntime *rt, JSValue val)
{
    JSOSTimer *th = JS_GetOpaque(val, js_os_timer_class_id);
    if (th) {
        th->has_object = FALSE;
        if (!th->link.prev)
            free_timer(rt, th);
    }
}

static void js_os_timer_mark(JSRuntime *rt, JSValueConst val,
                             JS_MarkFunc *mark_func)
{
    JSOSTimer *th = JS_GetOpaque(val, js_os_timer_class_id);
    if (th) {
        JS_MarkValue(rt, th->func, mark_func);
    }
}

static JSValue js_os_setTimeout(JSContext *ctx, JSValueConst this_val,
                                int argc, JSValueConst *argv)
{
    JSRuntime *rt = JS_GetRuntime(ctx);
    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
    int64_t delay;
    JSValueConst func;
    JSOSTimer *th;
    JSValue obj;

    func = argv[0];
    if (!JS_IsFunction(ctx, func))
        return JS_ThrowTypeError(ctx, "not a function");
    if (JS_ToInt64(ctx, &delay, argv[1]))
        return JS_EXCEPTION;
    obj = JS_NewObjectClass(ctx, js_os_timer_class_id);
    if (JS_IsException(obj))
        return obj;
    th = js_mallocz(ctx, sizeof(*th));
    if (!th) {
        JS_FreeValue(ctx, obj);
        return JS_EXCEPTION;
    }
    th->has_object = TRUE;
    th->timeout = get_time_ms() + delay;
    th->func = JS_DupValue(ctx, func);
    list_add_tail(&th->link, &ts->os_timers);
    JS_SetOpaque(obj, th);
    return obj;
}

static JSValue js_os_clearTimeout(JSContext *ctx, JSValueConst this_val,
                                  int argc, JSValueConst *argv)
{
    JSOSTimer *th = JS_GetOpaque2(ctx, argv[0], js_os_timer_class_id);
    if (!th)
        return JS_EXCEPTION;
    unlink_timer(JS_GetRuntime(ctx), th);
    return JS_UNDEFINED;
}

static JSClassDef js_os_timer_class = {
    "OSTimer",
    .finalizer = js_os_timer_finalizer,
    .gc_mark = js_os_timer_mark,
}; 

static void call_handler(JSContext *ctx, JSValueConst func)
{
    JSValue ret, func1;
    /* 'func' might be destroyed when calling itself (if it frees the
       handler), so must take extra care */
    func1 = JS_DupValue(ctx, func);
    ret = JS_Call(ctx, func1, JS_UNDEFINED, 0, NULL);
    JS_FreeValue(ctx, func1);
    if (JS_IsException(ret))
        js_std_dump_error(ctx);
    JS_FreeValue(ctx, ret);
}

#if defined(_WIN32)

static int js_os_poll(JSContext *ctx)
{
    JSRuntime *rt = JS_GetRuntime(ctx);
    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
    int min_delay, console_fd;
    int64_t cur_time, delay;
    JSOSRWHandler *rh;
    struct list_head *el;
    
    /* XXX: handle signals if useful */

    if (list_empty(&ts->os_rw_handlers) && list_empty(&ts->os_timers))
        return -1; /* no more events */
    
    /* XXX: only timers and basic console input are supported */
    if (!list_empty(&ts->os_timers)) {
        cur_time = get_time_ms();
        min_delay = 10000;
        list_for_each(el, &ts->os_timers) {
            JSOSTimer *th = list_entry(el, JSOSTimer, link);
            delay = th->timeout - cur_time;
            if (delay <= 0) {
                JSValue func;
                /* the timer expired */
                func = th->func;
                th->func = JS_UNDEFINED;
                unlink_timer(rt, th);
                if (!th->has_object)
                    free_timer(rt, th);
                call_handler(ctx, func);
                JS_FreeValue(ctx, func);
                return 0;
            } else if (delay < min_delay) {
                min_delay = delay;
            }
        }
    } else {
        min_delay = -1;
    }

    console_fd = -1;
    list_for_each(el, &ts->os_rw_handlers) {
        rh = list_entry(el, JSOSRWHandler, link);
        if (rh->fd == 0 && !JS_IsNull(rh->rw_func[0])) {
            console_fd = rh->fd;
            break;
        }
    }

    if (console_fd >= 0) {
        DWORD ti, ret;
        HANDLE handle;
        if (min_delay == -1)
            ti = INFINITE;
        else
            ti = min_delay;
        handle = (HANDLE)_get_osfhandle(console_fd);
        ret = WaitForSingleObject(handle, ti);
        if (ret == WAIT_OBJECT_0) {
            list_for_each(el, &ts->os_rw_handlers) {
                rh = list_entry(el, JSOSRWHandler, link);
                if (rh->fd == console_fd && !JS_IsNull(rh->rw_func[0])) {
                    call_handler(ctx, rh->rw_func[0]);
                    /* must stop because the list may have been modified */
                    break;
                }
            }
        }
    } else {
        Sleep(min_delay);
    }
    return 0;
}
#else

#ifdef USE_WORKER

static void js_free_message(JSWorkerMessage *msg);

/* return 1 if a message was handled, 0 if no message */
static int handle_posted_message(JSRuntime *rt, JSContext *ctx,
                                 JSWorkerMessageHandler *port)
{
    JSWorkerMessagePipe *ps = port->recv_pipe;
    int ret;
    struct list_head *el;
    JSWorkerMessage *msg;
    JSValue obj, data_obj, func, retval;
    
    pthread_mutex_lock(&ps->mutex);
    if (!list_empty(&ps->msg_queue)) {
        el = ps->msg_queue.next;
        msg = list_entry(el, JSWorkerMessage, link);

        /* remove the message from the queue */
        list_del(&msg->link);

        if (list_empty(&ps->msg_queue)) {
            uint8_t buf[16];
            int ret;
            for(;;) {
                ret = read(ps->read_fd, buf, sizeof(buf));
                if (ret >= 0)
                    break;
                if (errno != EAGAIN && errno != EINTR)
                    break;
            }
        }

        pthread_mutex_unlock(&ps->mutex);

        data_obj = JS_ReadObject(ctx, msg->data, msg->data_len,
                                 JS_READ_OBJ_SAB | JS_READ_OBJ_REFERENCE);

        js_free_message(msg);
        
        if (JS_IsException(data_obj))
            goto fail;
        obj = JS_NewObject(ctx);
        if (JS_IsException(obj)) {
            JS_FreeValue(ctx, data_obj);
            goto fail;
        }
        JS_DefinePropertyValueStr(ctx, obj, "data", data_obj, JS_PROP_C_W_E);

        /* 'func' might be destroyed when calling itself (if it frees the
           handler), so must take extra care */
        func = JS_DupValue(ctx, port->on_message_func);
        retval = JS_Call(ctx, func, JS_UNDEFINED, 1, (JSValueConst *)&obj);
        JS_FreeValue(ctx, obj);
        JS_FreeValue(ctx, func);
        if (JS_IsException(retval)) {
        fail:
            js_std_dump_error(ctx);
        } else {
            JS_FreeValue(ctx, retval);
        }
        ret = 1;
    } else {
        pthread_mutex_unlock(&ps->mutex);
        ret = 0;
    }
    return ret;
}
#else
static int handle_posted_message(JSRuntime *rt, JSContext *ctx,
                                 JSWorkerMessageHandler *port)
{
    return 0;
}
#endif

static int js_os_poll(JSContext *ctx)
{
    JSRuntime *rt = JS_GetRuntime(ctx);
    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
    int ret, fd_max, min_delay;
    int64_t cur_time, delay;
    fd_set rfds, wfds;
    JSOSRWHandler *rh;
    struct list_head *el;
    struct timeval tv, *tvp;

    /* only check signals in the main thread */
    if (!ts->recv_pipe &&
        unlikely(os_pending_signals != 0)) {
        JSOSSignalHandler *sh;
        uint64_t mask;
        
        list_for_each(el, &ts->os_signal_handlers) {
            sh = list_entry(el, JSOSSignalHandler, link);
            mask = (uint64_t)1 << sh->sig_num;
            if (os_pending_signals & mask) {
                os_pending_signals &= ~mask;
                call_handler(ctx, sh->func);
                return 0;
            }
        }
    }

    if (list_empty(&ts->os_rw_handlers) && list_empty(&ts->os_timers) &&
        list_empty(&ts->port_list))
        return -1; /* no more events */
    
    if (!list_empty(&ts->os_timers)) {
        cur_time = get_time_ms();
        min_delay = 10000;
        list_for_each(el, &ts->os_timers) {
            JSOSTimer *th = list_entry(el, JSOSTimer, link);
            delay = th->timeout - cur_time;
            if (delay <= 0) {
                JSValue func;
                /* the timer expired */
                func = th->func;
                th->func = JS_UNDEFINED;
                unlink_timer(rt, th);
                if (!th->has_object)
                    free_timer(rt, th);
                call_handler(ctx, func);
                JS_FreeValue(ctx, func);
                return 0;
            } else if (delay < min_delay) {
                min_delay = delay;
            }
        }
        tv.tv_sec = min_delay / 1000;
        tv.tv_usec = (min_delay % 1000) * 1000;
        tvp = &tv;
    } else {
        tvp = NULL;
    }
    
    FD_ZERO(&rfds);
    FD_ZERO(&wfds);
    fd_max = -1;
    list_for_each(el, &ts->os_rw_handlers) {
        rh = list_entry(el, JSOSRWHandler, link);
        fd_max = max_int(fd_max, rh->fd);
        if (!JS_IsNull(rh->rw_func[0]))
            FD_SET(rh->fd, &rfds);
        if (!JS_IsNull(rh->rw_func[1]))
            FD_SET(rh->fd, &wfds);
    }

    list_for_each(el, &ts->port_list) {
        JSWorkerMessageHandler *port = list_entry(el, JSWorkerMessageHandler, link);
        if (!JS_IsNull(port->on_message_func)) {
            JSWorkerMessagePipe *ps = port->recv_pipe;
            fd_max = max_int(fd_max, ps->read_fd);
            FD_SET(ps->read_fd, &rfds);
        }
    }

    ret = select(fd_max + 1, &rfds, &wfds, NULL, tvp);
    if (ret > 0) {
        list_for_each(el, &ts->os_rw_handlers) {
            rh = list_entry(el, JSOSRWHandler, link);
            if (!JS_IsNull(rh->rw_func[0]) &&
                FD_ISSET(rh->fd, &rfds)) {
                call_handler(ctx, rh->rw_func[0]);
                /* must stop because the list may have been modified */
                goto done;
            }
            if (!JS_IsNull(rh->rw_func[1]) &&
                FD_ISSET(rh->fd, &wfds)) {
                call_handler(ctx, rh->rw_func[1]);
                /* must stop because the list may have been modified */
                goto done;
            }
        }

        list_for_each(el, &ts->port_list) {
            JSWorkerMessageHandler *port = list_entry(el, JSWorkerMessageHandler, link);
            if (!JS_IsNull(port->on_message_func)) {
                JSWorkerMessagePipe *ps = port->recv_pipe;
                if (FD_ISSET(ps->read_fd, &rfds)) {
                    if (handle_posted_message(rt, ctx, port))
                        goto done;
                }
            }
        }
    }
    done:
    return 0;
}
#endif /* !_WIN32 */

static JSValue make_obj_error(JSContext *ctx,
                              JSValue obj,
                              int err)
{
    JSValue arr;
    if (JS_IsException(obj))
        return obj;
    arr = JS_NewArray(ctx);
    if (JS_IsException(arr))
        return JS_EXCEPTION;
    JS_DefinePropertyValueUint32(ctx, arr, 0, obj,
                                 JS_PROP_C_W_E);
    JS_DefinePropertyValueUint32(ctx, arr, 1, JS_NewInt32(ctx, err),
                                 JS_PROP_C_W_E);
    return arr;
}

static JSValue make_string_error(JSContext *ctx,
                                 const char *buf,
                                 int err)
{
    return make_obj_error(ctx, JS_NewString(ctx, buf), err);
}

/* return [cwd, errorcode] */
static JSValue js_os_getcwd(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
{
    char buf[PATH_MAX];
    int err;
    
    if (!getcwd(buf, sizeof(buf))) {
        buf[0] = '\0';
        err = errno;
    } else {
        err = 0;
    }
    return make_string_error(ctx, buf, err);
}

static JSValue js_os_chdir(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
{
    const char *target;
    int err;

    target = JS_ToCString(ctx, argv[0]);
    if (!target)
        return JS_EXCEPTION;
    err = js_get_errno(chdir(target));
    JS_FreeCString(ctx, target);
    return JS_NewInt32(ctx, err);
}

static JSValue js_os_mkdir(JSContext *ctx, JSValueConst this_val,
                           int argc, JSValueConst *argv)
{
    int mode, ret;
    const char *path;
    
    if (argc >= 2) {
        if (JS_ToInt32(ctx, &mode, argv[1]))
            return JS_EXCEPTION;
    } else {
        mode = 0777;
    }
    path = JS_ToCString(ctx, argv[0]);
    if (!path)
        return JS_EXCEPTION;
#if defined(_WIN32)
    (void)mode;
    ret = js_get_errno(mkdir(path));
#else
    ret = js_get_errno(mkdir(path, mode));
#endif
    JS_FreeCString(ctx, path);
    return JS_NewInt32(ctx, ret);
}

/* return [array, errorcode] */
static JSValue js_os_readdir(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
{
    const char *path;
    DIR *f;
    struct dirent *d;
    JSValue obj;
    int err;
    uint32_t len;
    
    path = JS_ToCString(ctx, argv[0]);
    if (!path)
        return JS_EXCEPTION;
    obj = JS_NewArray(ctx);
    if (JS_IsException(obj)) {
        JS_FreeCString(ctx, path);
        return JS_EXCEPTION;
    }
    f = opendir(path);
    if (!f)
        err = errno;
    else
        err = 0;
    JS_FreeCString(ctx, path);
    if (!f)
        goto done;
    len = 0;
    for(;;) {
        errno = 0;
        d = readdir(f);
        if (!d) {
            err = errno;
            break;
        }
        JS_DefinePropertyValueUint32(ctx, obj, len++,
                                     JS_NewString(ctx, d->d_name),
                                     JS_PROP_C_W_E);
    }
    closedir(f);
 done:
    return make_obj_error(ctx, obj, err);
}

#if !defined(_WIN32)
static int64_t timespec_to_ms(const struct timespec *tv)
{
    return (int64_t)tv->tv_sec * 1000 + (tv->tv_nsec / 1000000);
}
#endif

/* return [obj, errcode] */
static JSValue js_os_stat(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv, int is_lstat)
{
    const char *path;
    int err, res;
    struct stat st;
    JSValue obj;

    path = JS_ToCString(ctx, argv[0]);
    if (!path)
        return JS_EXCEPTION;
#if defined(_WIN32)
    res = stat(path, &st);
#else
    if (is_lstat)
        res = lstat(path, &st);
    else
        res = stat(path, &st);
#endif
    JS_FreeCString(ctx, path);
    if (res < 0) {
        err = errno;
        obj = JS_NULL;
    } else {
        err = 0;
        obj = JS_NewObject(ctx);
        if (JS_IsException(obj))
            return JS_EXCEPTION;
        JS_DefinePropertyValueStr(ctx, obj, "dev",
                                  JS_NewInt64(ctx, st.st_dev),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "ino",
                                  JS_NewInt64(ctx, st.st_ino),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "mode",
                                  JS_NewInt32(ctx, st.st_mode),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "nlink",
                                  JS_NewInt64(ctx, st.st_nlink),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "uid",
                                  JS_NewInt64(ctx, st.st_uid),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "gid",
                                  JS_NewInt64(ctx, st.st_gid),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "rdev",
                                  JS_NewInt64(ctx, st.st_rdev),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "size",
                                  JS_NewInt64(ctx, st.st_size),
                                  JS_PROP_C_W_E);
#if !defined(_WIN32)
        JS_DefinePropertyValueStr(ctx, obj, "blocks",
                                  JS_NewInt64(ctx, st.st_blocks),
                                  JS_PROP_C_W_E);
#endif
#if defined(_WIN32)
        JS_DefinePropertyValueStr(ctx, obj, "atime",
                                  JS_NewInt64(ctx, (int64_t)st.st_atime * 1000),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "mtime",
                                  JS_NewInt64(ctx, (int64_t)st.st_mtime * 1000),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "ctime",
                                  JS_NewInt64(ctx, (int64_t)st.st_ctime * 1000),
                                  JS_PROP_C_W_E);
#elif defined(__APPLE__)
        JS_DefinePropertyValueStr(ctx, obj, "atime",
                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atimespec)),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "mtime",
                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtimespec)),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "ctime",
                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctimespec)),
                                  JS_PROP_C_W_E);
#else
        JS_DefinePropertyValueStr(ctx, obj, "atime",
                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_atim)),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "mtime",
                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_mtim)),
                                  JS_PROP_C_W_E);
        JS_DefinePropertyValueStr(ctx, obj, "ctime",
                                  JS_NewInt64(ctx, timespec_to_ms(&st.st_ctim)),
                                  JS_PROP_C_W_E);
#endif
    }
    return make_obj_error(ctx, obj, err);
}

#if !defined(_WIN32)
static void ms_to_timeval(struct timeval *tv, uint64_t v)
{
    tv->tv_sec = v / 1000;
    tv->tv_usec = (v % 1000) * 1000;
}
#endif

static JSValue js_os_utimes(JSContext *ctx, JSValueConst this_val,
                            int argc, JSValueConst *argv)
{
    const char *path;
    int64_t atime, mtime;
    int ret;
    
    if (JS_ToInt64(ctx, &atime, argv[1]))
        return JS_EXCEPTION;
    if (JS_ToInt64(ctx, &mtime, argv[2]))
        return JS_EXCEPTION;
    path = JS_ToCString(ctx, argv[0]);
    if (!path)
        return JS_EXCEPTION;
#if defined(_WIN32)
    {
        struct _utimbuf times;
        times.actime = atime / 1000;
        times.modtime = mtime / 1000;
        ret = js_get_errno(_utime(path, &times));
    }
#else
    {
        struct timeval times[2];
        ms_to_timeval(&times[0], atime);
        ms_to_timeval(&times[1], mtime);
        ret = js_get_errno(utimes(path, times));
    }
#endif
    JS_FreeCString(ctx, path);
    return JS_NewInt32(ctx, ret);
}

/* sleep(delay_ms) */
static JSValue js_os_sleep(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
{
    int64_t delay;
    int ret;
    
    if (JS_ToInt64(ctx, &delay, argv[0]))
        return JS_EXCEPTION;
    if (delay < 0)
        delay = 0;
#if defined(_WIN32)
    {
        if (delay > INT32_MAX)
            delay = INT32_MAX;
        Sleep(delay);
        ret = 0;
    }
#else
    {
        struct timespec ts;

        ts.tv_sec = delay / 1000;
        ts.tv_nsec = (delay % 1000) * 1000000;
        ret = js_get_errno(nanosleep(&ts, NULL));
    }
#endif
    return JS_NewInt32(ctx, ret);
}

#if defined(_WIN32)
static char *realpath(const char *path, char *buf)
{
    if (!_fullpath(buf, path, PATH_MAX)) {
        errno = ENOENT;
        return NULL;
    } else {
        return buf;
    }
}
#endif

/* return [path, errorcode] */
static JSValue js_os_realpath(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
{
    const char *path;
    char buf[PATH_MAX], *res;
    int err;

    path = JS_ToCString(ctx, argv[0]);
    if (!path)
        return JS_EXCEPTION;
    res = realpath(path, buf);
    JS_FreeCString(ctx, path);
    if (!res) {
        buf[0] = '\0';
        err = errno;
    } else {
        err = 0;
    }
    return make_string_error(ctx, buf, err);
}

#if !defined(_WIN32)
static JSValue js_os_symlink(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
{
    const char *target, *linkpath;
    int err;
    
    target = JS_ToCString(ctx, argv[0]);
    if (!target)
        return JS_EXCEPTION;
    linkpath = JS_ToCString(ctx, argv[1]);
    if (!linkpath) {
        JS_FreeCString(ctx, target);
        return JS_EXCEPTION;
    }
    err = js_get_errno(symlink(target, linkpath));
    JS_FreeCString(ctx, target);
    JS_FreeCString(ctx, linkpath);
    return JS_NewInt32(ctx, err);
}

/* return [path, errorcode] */
static JSValue js_os_readlink(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
{
    const char *path;
    char buf[PATH_MAX];
    int err;
    ssize_t res;
    
    path = JS_ToCString(ctx, argv[0]);
    if (!path)
        return JS_EXCEPTION;
    res = readlink(path, buf, sizeof(buf) - 1);
    if (res < 0) {
        buf[0] = '\0';
        err = errno;
    } else {
        buf[res] = '\0';
        err = 0;
    }
    JS_FreeCString(ctx, path);
    return make_string_error(ctx, buf, err);
}

static char **build_envp(JSContext *ctx, JSValueConst obj)
{
    uint32_t len, i;
    JSPropertyEnum *tab;
    char **envp, *pair;
    const char *key, *str;
    JSValue val;
    size_t key_len, str_len;
    
    if (JS_GetOwnPropertyNames(ctx, &tab, &len, obj,
                               JS_GPN_STRING_MASK | JS_GPN_ENUM_ONLY) < 0)
        return NULL;
    envp = js_mallocz(ctx, sizeof(envp[0]) * ((size_t)len + 1));
    if (!envp)
        goto fail;
    for(i = 0; i < len; i++) {
        val = JS_GetProperty(ctx, obj, tab[i].atom);
        if (JS_IsException(val))
            goto fail;
        str = JS_ToCString(ctx, val);
        JS_FreeValue(ctx, val);
        if (!str)
            goto fail;
        key = JS_AtomToCString(ctx, tab[i].atom);
        if (!key) {
            JS_FreeCString(ctx, str);
            goto fail;
        }
        key_len = strlen(key);
        str_len = strlen(str);
        pair = js_malloc(ctx, key_len + str_len + 2);
        if (!pair) {
            JS_FreeCString(ctx, key);
            JS_FreeCString(ctx, str);
            goto fail;
        }
        memcpy(pair, key, key_len);
        pair[key_len] = '=';
        memcpy(pair + key_len + 1, str, str_len);
        pair[key_len + 1 + str_len] = '\0';
        envp[i] = pair;
        JS_FreeCString(ctx, key);
        JS_FreeCString(ctx, str);
    }
 done:
    for(i = 0; i < len; i++)
        JS_FreeAtom(ctx, tab[i].atom);
    js_free(ctx, tab);
    return envp;
 fail:
    if (envp) {
        for(i = 0; i < len; i++)
            js_free(ctx, envp[i]);
        js_free(ctx, envp);
        envp = NULL;
    }
    goto done;
}

/* execvpe is not available on non GNU systems */
static int my_execvpe(const char *filename, char **argv, char **envp)
{
    char *path, *p, *p_next, *p1;
    char buf[PATH_MAX];
    size_t filename_len, path_len;
    BOOL eacces_error;
    
    filename_len = strlen(filename);
    if (filename_len == 0) {
        errno = ENOENT;
        return -1;
    }
    if (strchr(filename, '/'))
        return execve(filename, argv, envp);
    
    path = getenv("PATH");
    if (!path)
        path = (char *)"/bin:/usr/bin";
    eacces_error = FALSE;
    p = path;
    for(p = path; p != NULL; p = p_next) {
        p1 = strchr(p, ':');
        if (!p1) {
            p_next = NULL;
            path_len = strlen(p);
        } else {
            p_next = p1 + 1;
            path_len = p1 - p;
        }
        /* path too long */
        if ((path_len + 1 + filename_len + 1) > PATH_MAX)
            continue;
        memcpy(buf, p, path_len);
        buf[path_len] = '/';
        memcpy(buf + path_len + 1, filename, filename_len);
        buf[path_len + 1 + filename_len] = '\0';
        
        execve(buf, argv, envp);

        switch(errno) {
        case EACCES:
            eacces_error = TRUE;
            break;
        case ENOENT:
        case ENOTDIR:
            break;
        default:
            return -1;
        }
    }
    if (eacces_error)
        errno = EACCES;
    return -1;
}

/* exec(args[, options]) -> exitcode */
static JSValue js_os_exec(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
{
    JSValueConst options, args = argv[0];
    JSValue val, ret_val;
    const char **exec_argv, *file = NULL, *str, *cwd = NULL;
    char **envp = environ;
    uint32_t exec_argc, i;
    int ret, pid, status;
    BOOL block_flag = TRUE, use_path = TRUE;
    static const char *std_name[3] = { "stdin", "stdout", "stderr" };
    int std_fds[3];
    uint32_t uid = -1, gid = -1;
    
    val = JS_GetPropertyStr(ctx, args, "length");
    if (JS_IsException(val))
        return JS_EXCEPTION;
    ret = JS_ToUint32(ctx, &exec_argc, val);
    JS_FreeValue(ctx, val);
    if (ret)
        return JS_EXCEPTION;
    /* arbitrary limit to avoid overflow */
    if (exec_argc < 1 || exec_argc > 65535) {
        return JS_ThrowTypeError(ctx, "invalid number of arguments");
    }
    exec_argv = js_mallocz(ctx, sizeof(exec_argv[0]) * (exec_argc + 1));
    if (!exec_argv)
        return JS_EXCEPTION;
    for(i = 0; i < exec_argc; i++) {
        val = JS_GetPropertyUint32(ctx, args, i);
        if (JS_IsException(val))
            goto exception;
        str = JS_ToCString(ctx, val);
        JS_FreeValue(ctx, val);
        if (!str)
            goto exception;
        exec_argv[i] = str;
    }
    exec_argv[exec_argc] = NULL;

    for(i = 0; i < 3; i++)
        std_fds[i] = i;
    
    /* get the options, if any */
    if (argc >= 2) {
        options = argv[1];

        if (get_bool_option(ctx, &block_flag, options, "block"))
            goto exception;
        if (get_bool_option(ctx, &use_path, options, "usePath"))
            goto exception;
        
        val = JS_GetPropertyStr(ctx, options, "file");
        if (JS_IsException(val))
            goto exception;
        if (!JS_IsUndefined(val)) {
            file = JS_ToCString(ctx, val);
            JS_FreeValue(ctx, val);
            if (!file)
                goto exception;
        }

        val = JS_GetPropertyStr(ctx, options, "cwd");
        if (JS_IsException(val))
            goto exception;
        if (!JS_IsUndefined(val)) {
            cwd = JS_ToCString(ctx, val);
            JS_FreeValue(ctx, val);
            if (!cwd)
                goto exception;
        }

        /* stdin/stdout/stderr handles */
        for(i = 0; i < 3; i++) {
            val = JS_GetPropertyStr(ctx, options, std_name[i]);
            if (JS_IsException(val))
                goto exception;
            if (!JS_IsUndefined(val)) {
                int fd;
                ret = JS_ToInt32(ctx, &fd, val);
                JS_FreeValue(ctx, val);
                if (ret)
                    goto exception;
                std_fds[i] = fd;
            }
        }

        val = JS_GetPropertyStr(ctx, options, "env");
        if (JS_IsException(val))
            goto exception;
        if (!JS_IsUndefined(val)) {
            envp = build_envp(ctx, val);
            JS_FreeValue(ctx, val);
            if (!envp)
                goto exception;
        }
        
        val = JS_GetPropertyStr(ctx, options, "uid");
        if (JS_IsException(val))
            goto exception;
        if (!JS_IsUndefined(val)) {
            ret = JS_ToUint32(ctx, &uid, val);
            JS_FreeValue(ctx, val);
            if (ret)
                goto exception;
        }

        val = JS_GetPropertyStr(ctx, options, "gid");
        if (JS_IsException(val))
            goto exception;
        if (!JS_IsUndefined(val)) {
            ret = JS_ToUint32(ctx, &gid, val);
            JS_FreeValue(ctx, val);
            if (ret)
                goto exception;
        }
    }

    pid = fork();
    if (pid < 0) {
        JS_ThrowTypeError(ctx, "fork error");
        goto exception;
    }
    if (pid == 0) {
        /* child */
        int fd_max = sysconf(_SC_OPEN_MAX);

        /* remap the stdin/stdout/stderr handles if necessary */
        for(i = 0; i < 3; i++) {
            if (std_fds[i] != i) {
                if (dup2(std_fds[i], i) < 0)
                    _exit(127);
            }
        }

        for(i = 3; i < fd_max; i++)
            close(i);
        if (cwd) {
            if (chdir(cwd) < 0)
                _exit(127);
        }
        if (uid != -1) {
            if (setuid(uid) < 0)
                _exit(127);
        }
        if (gid != -1) {
            if (setgid(gid) < 0)
                _exit(127);
        }

        if (!file)
            file = exec_argv[0];
        if (use_path)
            ret = my_execvpe(file, (char **)exec_argv, envp);
        else
            ret = execve(file, (char **)exec_argv, envp);
        _exit(127);
    }
    /* parent */
    if (block_flag) {
        for(;;) {
            ret = waitpid(pid, &status, 0);
            if (ret == pid) {
                if (WIFEXITED(status)) {
                    ret = WEXITSTATUS(status);
                    break;
                } else if (WIFSIGNALED(status)) {
                    ret = -WTERMSIG(status);
                    break;
                }
            }
        }
    } else {
        ret = pid;
    }
    ret_val = JS_NewInt32(ctx, ret);
 done:
    JS_FreeCString(ctx, file);
    JS_FreeCString(ctx, cwd);
    for(i = 0; i < exec_argc; i++)
        JS_FreeCString(ctx, exec_argv[i]);
    js_free(ctx, exec_argv);
    if (envp != environ) {
        char **p;
        p = envp;
        while (*p != NULL) {
            js_free(ctx, *p);
            p++;
        }
        js_free(ctx, envp);
    }
    return ret_val;
 exception:
    ret_val = JS_EXCEPTION;
    goto done;
}

/* waitpid(pid, block) -> [pid, status] */
static JSValue js_os_waitpid(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
{
    int pid, status, options, ret;
    JSValue obj;
    
    if (JS_ToInt32(ctx, &pid, argv[0]))
        return JS_EXCEPTION;
    if (JS_ToInt32(ctx, &options, argv[1]))
        return JS_EXCEPTION;

    ret = waitpid(pid, &status, options);
    if (ret < 0) {
        ret = -errno;
        status = 0;
    }

    obj = JS_NewArray(ctx);
    if (JS_IsException(obj))
        return obj;
    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, ret),
                                 JS_PROP_C_W_E);
    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, status),
                                 JS_PROP_C_W_E);
    return obj;
}    

/* pipe() -> [read_fd, write_fd] or null if error */
static JSValue js_os_pipe(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
{
    int pipe_fds[2], ret;
    JSValue obj;
    
    ret = pipe(pipe_fds);
    if (ret < 0)
        return JS_NULL;
    obj = JS_NewArray(ctx);
    if (JS_IsException(obj))
        return obj;
    JS_DefinePropertyValueUint32(ctx, obj, 0, JS_NewInt32(ctx, pipe_fds[0]),
                                 JS_PROP_C_W_E);
    JS_DefinePropertyValueUint32(ctx, obj, 1, JS_NewInt32(ctx, pipe_fds[1]),
                                 JS_PROP_C_W_E);
    return obj;
}

/* kill(pid, sig) */
static JSValue js_os_kill(JSContext *ctx, JSValueConst this_val,
                          int argc, JSValueConst *argv)
{
    int pid, sig, ret;
    
    if (JS_ToInt32(ctx, &pid, argv[0]))
        return JS_EXCEPTION;
    if (JS_ToInt32(ctx, &sig, argv[1]))
        return JS_EXCEPTION;
    ret = js_get_errno(kill(pid, sig));
    return JS_NewInt32(ctx, ret);
}

/* dup(fd) */
static JSValue js_os_dup(JSContext *ctx, JSValueConst this_val,
                         int argc, JSValueConst *argv)
{
    int fd, ret;
    
    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    ret = js_get_errno(dup(fd));
    return JS_NewInt32(ctx, ret);
}

/* dup2(fd) */
static JSValue js_os_dup2(JSContext *ctx, JSValueConst this_val,
                         int argc, JSValueConst *argv)
{
    int fd, fd2, ret;
    
    if (JS_ToInt32(ctx, &fd, argv[0]))
        return JS_EXCEPTION;
    if (JS_ToInt32(ctx, &fd2, argv[1]))
        return JS_EXCEPTION;
    ret = js_get_errno(dup2(fd, fd2));
    return JS_NewInt32(ctx, ret);
}

#endif /* !_WIN32 */

#ifdef USE_WORKER

/* Worker */

typedef struct {
    JSWorkerMessagePipe *recv_pipe;
    JSWorkerMessagePipe *send_pipe;
    JSWorkerMessageHandler *msg_handler;
} JSWorkerData;

typedef struct {
    char *filename; /* module filename */
    char *basename; /* module base name */
    JSWorkerMessagePipe *recv_pipe, *send_pipe;
} WorkerFuncArgs;

typedef struct {
    int ref_count;
    uint64_t buf[0];
} JSSABHeader;

static JSClassID js_worker_class_id;
static JSContext *(*js_worker_new_context_func)(JSRuntime *rt);

static int atomic_add_int(int *ptr, int v)
{
    return atomic_fetch_add((_Atomic(uint32_t) *)ptr, v) + v;
}

/* shared array buffer allocator */
static void *js_sab_alloc(void *opaque, size_t size)
{
    JSSABHeader *sab;
    sab = malloc(sizeof(JSSABHeader) + size);
    if (!sab)
        return NULL;
    sab->ref_count = 1;
    return sab->buf;
}

static void js_sab_free(void *opaque, void *ptr)
{
    JSSABHeader *sab;
    int ref_count;
    sab = (JSSABHeader *)((uint8_t *)ptr - sizeof(JSSABHeader));
    ref_count = atomic_add_int(&sab->ref_count, -1);
    assert(ref_count >= 0);
    if (ref_count == 0) {
        free(sab);
    }
}

static void js_sab_dup(void *opaque, void *ptr)
{
    JSSABHeader *sab;
    sab = (JSSABHeader *)((uint8_t *)ptr - sizeof(JSSABHeader));
    atomic_add_int(&sab->ref_count, 1);
}

static JSWorkerMessagePipe *js_new_message_pipe(void)
{
    JSWorkerMessagePipe *ps;
    int pipe_fds[2];
    
    if (pipe(pipe_fds) < 0)
        return NULL;

    ps = malloc(sizeof(*ps));
    if (!ps) {
        close(pipe_fds[0]);
        close(pipe_fds[1]);
        return NULL;
    }
    ps->ref_count = 1;
    init_list_head(&ps->msg_queue);
    pthread_mutex_init(&ps->mutex, NULL);
    ps->read_fd = pipe_fds[0];
    ps->write_fd = pipe_fds[1];
    return ps;
}

static JSWorkerMessagePipe *js_dup_message_pipe(JSWorkerMessagePipe *ps)
{
    atomic_add_int(&ps->ref_count, 1);
    return ps;
}

static void js_free_message(JSWorkerMessage *msg)
{
    size_t i;
    /* free the SAB */
    for(i = 0; i < msg->sab_tab_len; i++) {
        js_sab_free(NULL, msg->sab_tab[i]);
    }
    free(msg->sab_tab);
    free(msg->data);
    free(msg);
}

static void js_free_message_pipe(JSWorkerMessagePipe *ps)
{
    struct list_head *el, *el1;
    JSWorkerMessage *msg;
    int ref_count;
    
    if (!ps)
        return;
    
    ref_count = atomic_add_int(&ps->ref_count, -1);
    assert(ref_count >= 0);
    if (ref_count == 0) {
        list_for_each_safe(el, el1, &ps->msg_queue) {
            msg = list_entry(el, JSWorkerMessage, link);
            js_free_message(msg);
        }
        pthread_mutex_destroy(&ps->mutex);
        close(ps->read_fd);
        close(ps->write_fd);
        free(ps);
    }
}

static void js_free_port(JSRuntime *rt, JSWorkerMessageHandler *port)
{
    if (port) {
        js_free_message_pipe(port->recv_pipe);
        JS_FreeValueRT(rt, port->on_message_func);
        list_del(&port->link);
        js_free_rt(rt, port);
    }
}

static void js_worker_finalizer(JSRuntime *rt, JSValue val)
{
    JSWorkerData *worker = JS_GetOpaque(val, js_worker_class_id);
    if (worker) {
        js_free_message_pipe(worker->recv_pipe);
        js_free_message_pipe(worker->send_pipe);
        js_free_port(rt, worker->msg_handler);
        js_free_rt(rt, worker);
    }
}

static JSClassDef js_worker_class = {
    "Worker",
    .finalizer = js_worker_finalizer,
}; 

static void *worker_func(void *opaque)
{
    WorkerFuncArgs *args = opaque;
    JSRuntime *rt;
    JSThreadState *ts;
    JSContext *ctx;
    
    rt = JS_NewRuntime();
    if (rt == NULL) {
        fprintf(stderr, "JS_NewRuntime failure");
        exit(1);
    }        
    js_std_init_handlers(rt);

    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader, NULL);

    /* set the pipe to communicate with the parent */
    ts = JS_GetRuntimeOpaque(rt);
    ts->recv_pipe = args->recv_pipe;
    ts->send_pipe = args->send_pipe;
    
    /* function pointer to avoid linking the whole JS_NewContext() if
       not needed */
    ctx = js_worker_new_context_func(rt);
    if (ctx == NULL) {
        fprintf(stderr, "JS_NewContext failure");
    }

    JS_SetCanBlock(rt, TRUE);

    js_std_add_helpers(ctx, -1, NULL);

    if (!JS_RunModule(ctx, args->basename, args->filename))
        js_std_dump_error(ctx);
    free(args->filename);
    free(args->basename);
    free(args);

    js_std_loop(ctx);

    JS_FreeContext(ctx);
    js_std_free_handlers(rt);
    JS_FreeRuntime(rt);
    return NULL;
}

static JSValue js_worker_ctor_internal(JSContext *ctx, JSValueConst new_target,
                                       JSWorkerMessagePipe *recv_pipe,
                                       JSWorkerMessagePipe *send_pipe)
{
    JSValue obj = JS_UNDEFINED, proto;
    JSWorkerData *s;
    
    /* create the object */
    if (JS_IsUndefined(new_target)) {
        proto = JS_GetClassProto(ctx, js_worker_class_id);
    } else {
        proto = JS_GetPropertyStr(ctx, new_target, "prototype");
        if (JS_IsException(proto))
            goto fail;
    }
    obj = JS_NewObjectProtoClass(ctx, proto, js_worker_class_id);
    JS_FreeValue(ctx, proto);
    if (JS_IsException(obj))
        goto fail;
    s = js_mallocz(ctx, sizeof(*s));
    if (!s)
        goto fail;
    s->recv_pipe = js_dup_message_pipe(recv_pipe);
    s->send_pipe = js_dup_message_pipe(send_pipe);

    JS_SetOpaque(obj, s);
    return obj;
 fail:
    JS_FreeValue(ctx, obj);
    return JS_EXCEPTION;
}

static JSValue js_worker_ctor(JSContext *ctx, JSValueConst new_target,
                              int argc, JSValueConst *argv)
{
    JSRuntime *rt = JS_GetRuntime(ctx);
    WorkerFuncArgs *args = NULL;
    pthread_t tid;
    pthread_attr_t attr;
    JSValue obj = JS_UNDEFINED;
    int ret;
    const char *filename = NULL, *basename;
    JSAtom basename_atom;
    
    /* XXX: in order to avoid problems with resource liberation, we
       don't support creating workers inside workers */
    if (!is_main_thread(rt))
        return JS_ThrowTypeError(ctx, "cannot create a worker inside a worker");

    /* base name, assuming the calling function is a normal JS
       function */
    basename_atom = JS_GetScriptOrModuleName(ctx, 1);
    if (basename_atom == JS_ATOM_NULL) {
        return JS_ThrowTypeError(ctx, "could not determine calling script or module name");
    }
    basename = JS_AtomToCString(ctx, basename_atom);
    JS_FreeAtom(ctx, basename_atom);
    if (!basename)
        goto fail;
    
    /* module name */
    filename = JS_ToCString(ctx, argv[0]);
    if (!filename)
        goto fail;

    args = malloc(sizeof(*args));
    if (!args)
        goto oom_fail;
    memset(args, 0, sizeof(*args));
    args->filename = strdup(filename);
    args->basename = strdup(basename);

    /* ports */
    args->recv_pipe = js_new_message_pipe();
    if (!args->recv_pipe)
        goto oom_fail;
    args->send_pipe = js_new_message_pipe();
    if (!args->send_pipe)
        goto oom_fail;

    obj = js_worker_ctor_internal(ctx, new_target,
                                  args->send_pipe, args->recv_pipe);
    if (JS_IsException(obj))
        goto fail;
    
    pthread_attr_init(&attr);
    /* no join at the end */
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
    ret = pthread_create(&tid, &attr, worker_func, args);
    pthread_attr_destroy(&attr);
    if (ret != 0) {
        JS_ThrowTypeError(ctx, "could not create worker");
        goto fail;
    }
    JS_FreeCString(ctx, basename);
    JS_FreeCString(ctx, filename);
    return obj;
 oom_fail:
    JS_ThrowOutOfMemory(ctx);
 fail:
    JS_FreeCString(ctx, basename);
    JS_FreeCString(ctx, filename);
    if (args) {
        free(args->filename);
        free(args->basename);
        js_free_message_pipe(args->recv_pipe);
        js_free_message_pipe(args->send_pipe);
        free(args);
    }
    JS_FreeValue(ctx, obj);
    return JS_EXCEPTION;
}

static JSValue js_worker_postMessage(JSContext *ctx, JSValueConst this_val,
                                     int argc, JSValueConst *argv)
{
    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);
    JSWorkerMessagePipe *ps;
    size_t data_len, sab_tab_len, i;
    uint8_t *data;
    JSWorkerMessage *msg;
    uint8_t **sab_tab;
    
    if (!worker)
        return JS_EXCEPTION;
    
    data = JS_WriteObject2(ctx, &data_len, argv[0],
                           JS_WRITE_OBJ_SAB | JS_WRITE_OBJ_REFERENCE,
                           &sab_tab, &sab_tab_len);
    if (!data)
        return JS_EXCEPTION;

    msg = malloc(sizeof(*msg));
    if (!msg)
        goto fail;
    msg->data = NULL;
    msg->sab_tab = NULL;

    /* must reallocate because the allocator may be different */
    msg->data = malloc(data_len);
    if (!msg->data)
        goto fail;
    memcpy(msg->data, data, data_len);
    msg->data_len = data_len;

    msg->sab_tab = malloc(sizeof(msg->sab_tab[0]) * sab_tab_len);
    if (!msg->sab_tab)
        goto fail;
    memcpy(msg->sab_tab, sab_tab, sizeof(msg->sab_tab[0]) * sab_tab_len);
    msg->sab_tab_len = sab_tab_len;

    js_free(ctx, data);
    js_free(ctx, sab_tab);
    
    /* increment the SAB reference counts */
    for(i = 0; i < msg->sab_tab_len; i++) {
        js_sab_dup(NULL, msg->sab_tab[i]);
    }

    ps = worker->send_pipe;
    pthread_mutex_lock(&ps->mutex);
    /* indicate that data is present */
    if (list_empty(&ps->msg_queue)) {
        uint8_t ch = '\0';
        int ret;
        for(;;) {
            ret = write(ps->write_fd, &ch, 1);
            if (ret == 1)
                break;
            if (ret < 0 && (errno != EAGAIN || errno != EINTR))
                break;
        }
    }
    list_add_tail(&msg->link, &ps->msg_queue);
    pthread_mutex_unlock(&ps->mutex);
    return JS_UNDEFINED;
 fail:
    if (msg) {
        free(msg->data);
        free(msg->sab_tab);
        free(msg);
    }
    js_free(ctx, data);
    js_free(ctx, sab_tab);
    return JS_EXCEPTION;
    
}

static JSValue js_worker_set_onmessage(JSContext *ctx, JSValueConst this_val,
                                   JSValueConst func)
{
    JSRuntime *rt = JS_GetRuntime(ctx);
    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);
    JSWorkerMessageHandler *port;
    
    if (!worker)
        return JS_EXCEPTION;

    port = worker->msg_handler;
    if (JS_IsNull(func)) {
        if (port) {
            js_free_port(rt, port);
            worker->msg_handler = NULL;
        }
    } else {
        if (!JS_IsFunction(ctx, func))
            return JS_ThrowTypeError(ctx, "not a function");
        if (!port) {
            port = js_mallocz(ctx, sizeof(*port));
            if (!port)
                return JS_EXCEPTION;
            port->recv_pipe = js_dup_message_pipe(worker->recv_pipe);
            port->on_message_func = JS_NULL;
            list_add_tail(&port->link, &ts->port_list);
            worker->msg_handler = port;
        }
        JS_FreeValue(ctx, port->on_message_func);
        port->on_message_func = JS_DupValue(ctx, func);
    }
    return JS_UNDEFINED;
}

static JSValue js_worker_get_onmessage(JSContext *ctx, JSValueConst this_val)
{
    JSWorkerData *worker = JS_GetOpaque2(ctx, this_val, js_worker_class_id);
    JSWorkerMessageHandler *port;
    if (!worker)
        return JS_EXCEPTION;
    port = worker->msg_handler;
    if (port) {
        return JS_DupValue(ctx, port->on_message_func);
    } else {
        return JS_NULL;
    }
}

static const JSCFunctionListEntry js_worker_proto_funcs[] = {
    JS_CFUNC_DEF("postMessage", 1, js_worker_postMessage ),
    JS_CGETSET_DEF("onmessage", js_worker_get_onmessage, js_worker_set_onmessage ),
};

#endif /* USE_WORKER */

void js_std_set_worker_new_context_func(JSContext *(*func)(JSRuntime *rt))
{
#ifdef USE_WORKER
    js_worker_new_context_func = func;
#endif
}

#if defined(_WIN32)
#define OS_PLATFORM "win32"
#elif defined(__APPLE__)
#define OS_PLATFORM "darwin"
#elif defined(EMSCRIPTEN)
#define OS_PLATFORM "js"
#else
#define OS_PLATFORM "linux"
#endif

#define OS_FLAG(x) JS_PROP_INT32_DEF(#x, x, JS_PROP_CONFIGURABLE )

static const JSCFunctionListEntry js_os_funcs[] = {
    JS_CFUNC_DEF("open", 2, js_os_open ),
    OS_FLAG(O_RDONLY),
    OS_FLAG(O_WRONLY),
    OS_FLAG(O_RDWR),
    OS_FLAG(O_APPEND),
    OS_FLAG(O_CREAT),
    OS_FLAG(O_EXCL),
    OS_FLAG(O_TRUNC),
#if defined(_WIN32)
    OS_FLAG(O_BINARY),
    OS_FLAG(O_TEXT),
#endif
    JS_CFUNC_DEF("close", 1, js_os_close ),
    JS_CFUNC_DEF("seek", 3, js_os_seek ),
    JS_CFUNC_MAGIC_DEF("read", 4, js_os_read_write, 0 ),
    JS_CFUNC_MAGIC_DEF("write", 4, js_os_read_write, 1 ),
    JS_CFUNC_DEF("isatty", 1, js_os_isatty ),
    JS_CFUNC_DEF("ttyGetWinSize", 1, js_os_ttyGetWinSize ),
    JS_CFUNC_DEF("ttySetRaw", 1, js_os_ttySetRaw ),
    JS_CFUNC_DEF("remove", 1, js_os_remove ),
    JS_CFUNC_DEF("rename", 2, js_os_rename ),
    JS_CFUNC_MAGIC_DEF("setReadHandler", 2, js_os_setReadHandler, 0 ),
    JS_CFUNC_MAGIC_DEF("setWriteHandler", 2, js_os_setReadHandler, 1 ),
    JS_CFUNC_DEF("signal", 2, js_os_signal ),
    OS_FLAG(SIGINT),
    OS_FLAG(SIGABRT),
    OS_FLAG(SIGFPE),
    OS_FLAG(SIGILL),
    OS_FLAG(SIGSEGV),
    OS_FLAG(SIGTERM),
#if !defined(_WIN32)
    OS_FLAG(SIGQUIT),
    OS_FLAG(SIGPIPE),
    OS_FLAG(SIGALRM),
    OS_FLAG(SIGUSR1),
    OS_FLAG(SIGUSR2),
    OS_FLAG(SIGCHLD),
    OS_FLAG(SIGCONT),
    OS_FLAG(SIGSTOP),
    OS_FLAG(SIGTSTP),
    OS_FLAG(SIGTTIN),
    OS_FLAG(SIGTTOU),
#endif
    JS_CFUNC_DEF("setTimeout", 2, js_os_setTimeout ),
    JS_CFUNC_DEF("clearTimeout", 1, js_os_clearTimeout ),
    JS_PROP_STRING_DEF("platform", OS_PLATFORM, 0 ),
    JS_CFUNC_DEF("getcwd", 0, js_os_getcwd ),
    JS_CFUNC_DEF("chdir", 0, js_os_chdir ),
    JS_CFUNC_DEF("mkdir", 1, js_os_mkdir ),
    JS_CFUNC_DEF("readdir", 1, js_os_readdir ),
    /* st_mode constants */
    OS_FLAG(S_IFMT),
    OS_FLAG(S_IFIFO),
    OS_FLAG(S_IFCHR),
    OS_FLAG(S_IFDIR),
    OS_FLAG(S_IFBLK),
    OS_FLAG(S_IFREG),
#if !defined(_WIN32)
    OS_FLAG(S_IFSOCK),
    OS_FLAG(S_IFLNK),
    OS_FLAG(S_ISGID),
    OS_FLAG(S_ISUID),
#endif
    JS_CFUNC_MAGIC_DEF("stat", 1, js_os_stat, 0 ),
    JS_CFUNC_DEF("utimes", 3, js_os_utimes ),
    JS_CFUNC_DEF("sleep", 1, js_os_sleep ),
    JS_CFUNC_DEF("realpath", 1, js_os_realpath ),
#if !defined(_WIN32)
    JS_CFUNC_MAGIC_DEF("lstat", 1, js_os_stat, 1 ),
    JS_CFUNC_DEF("symlink", 2, js_os_symlink ),
    JS_CFUNC_DEF("readlink", 1, js_os_readlink ),
    JS_CFUNC_DEF("exec", 1, js_os_exec ),
    JS_CFUNC_DEF("waitpid", 2, js_os_waitpid ),
    OS_FLAG(WNOHANG),
    JS_CFUNC_DEF("pipe", 0, js_os_pipe ),
    JS_CFUNC_DEF("kill", 2, js_os_kill ),
    JS_CFUNC_DEF("dup", 1, js_os_dup ),
    JS_CFUNC_DEF("dup2", 2, js_os_dup2 ),
#endif
};

static int js_os_init(JSContext *ctx, JSModuleDef *m)
{
    os_poll_func = js_os_poll;
    
    /* OSTimer class */
    JS_NewClassID(&js_os_timer_class_id);
    JS_NewClass(JS_GetRuntime(ctx), js_os_timer_class_id, &js_os_timer_class);

#ifdef USE_WORKER
    {
        JSRuntime *rt = JS_GetRuntime(ctx);
        JSThreadState *ts = JS_GetRuntimeOpaque(rt);
        JSValue proto, obj;
        /* Worker class */
        JS_NewClassID(&js_worker_class_id);
        JS_NewClass(JS_GetRuntime(ctx), js_worker_class_id, &js_worker_class);
        proto = JS_NewObject(ctx);
        JS_SetPropertyFunctionList(ctx, proto, js_worker_proto_funcs, countof(js_worker_proto_funcs));
        
        obj = JS_NewCFunction2(ctx, js_worker_ctor, "Worker", 1,
                               JS_CFUNC_constructor, 0);
        JS_SetConstructor(ctx, obj, proto);
        
        JS_SetClassProto(ctx, js_worker_class_id, proto);
        
        /* set 'Worker.parent' if necessary */
        if (ts->recv_pipe && ts->send_pipe) {
            JS_DefinePropertyValueStr(ctx, obj, "parent",
                                      js_worker_ctor_internal(ctx, JS_UNDEFINED, ts->recv_pipe, ts->send_pipe),
                                      JS_PROP_C_W_E);
        }
        
        JS_SetModuleExport(ctx, m, "Worker", obj);
    }
#endif /* USE_WORKER */

    return JS_SetModuleExportList(ctx, m, js_os_funcs,
                                  countof(js_os_funcs));
}

JSModuleDef *js_init_module_os(JSContext *ctx, const char *module_name)
{
    JSModuleDef *m;
    m = JS_NewCModule(ctx, module_name, js_os_init);
    if (!m)
        return NULL;
    JS_AddModuleExportList(ctx, m, js_os_funcs, countof(js_os_funcs));
#ifdef USE_WORKER
    JS_AddModuleExport(ctx, m, "Worker");
#endif
    return m;
}

/**********************************************************/

static JSValue js_print(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
{
    int i;
    const char *str;
    size_t len;

    for(i = 0; i < argc; i++) {
        if (i != 0)
            putchar(' ');
        str = JS_ToCStringLen(ctx, &len, argv[i]);
        if (!str)
            return JS_EXCEPTION;
        fwrite(str, 1, len, stdout);
        JS_FreeCString(ctx, str);
    }
    putchar('\n');
    return JS_UNDEFINED;
}

void js_std_add_helpers(JSContext *ctx, int argc, char **argv)
{
    JSValue global_obj, console, args;
    int i;

    /* XXX: should these global definitions be enumerable? */
    global_obj = JS_GetGlobalObject(ctx);

    console = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, console, "log",
                      JS_NewCFunction(ctx, js_print, "log", 1));
    JS_SetPropertyStr(ctx, global_obj, "console", console);

    /* same methods as the mozilla JS shell */
    if (argc >= 0) {
        args = JS_NewArray(ctx);
        for(i = 0; i < argc; i++) {
            JS_SetPropertyUint32(ctx, args, i, JS_NewString(ctx, argv[i]));
        }
        JS_SetPropertyStr(ctx, global_obj, "scriptArgs", args);
    }
    
    JS_SetPropertyStr(ctx, global_obj, "print",
                      JS_NewCFunction(ctx, js_print, "print", 1));
    JS_SetPropertyStr(ctx, global_obj, "__loadScript",
                      JS_NewCFunction(ctx, js_loadScript, "__loadScript", 1));
    
    JS_FreeValue(ctx, global_obj);
}

void js_std_init_handlers(JSRuntime *rt)
{
    JSThreadState *ts;

    ts = malloc(sizeof(*ts));
    if (!ts) {
        fprintf(stderr, "Could not allocate memory for the worker");
        exit(1);
    }
    memset(ts, 0, sizeof(*ts));
    init_list_head(&ts->os_rw_handlers);
    init_list_head(&ts->os_signal_handlers);
    init_list_head(&ts->os_timers);
    init_list_head(&ts->port_list);

    JS_SetRuntimeOpaque(rt, ts);

#ifdef USE_WORKER
    /* set the SharedArrayBuffer memory handlers */
    {
        JSSharedArrayBufferFunctions sf;
        memset(&sf, 0, sizeof(sf));
        sf.sab_alloc = js_sab_alloc;
        sf.sab_free = js_sab_free;
        sf.sab_dup = js_sab_dup;
        JS_SetSharedArrayBufferFunctions(rt, &sf);
    }
#endif
}

void js_std_free_handlers(JSRuntime *rt)
{
    JSThreadState *ts = JS_GetRuntimeOpaque(rt);
    struct list_head *el, *el1;

    list_for_each_safe(el, el1, &ts->os_rw_handlers) {
        JSOSRWHandler *rh = list_entry(el, JSOSRWHandler, link);
        free_rw_handler(rt, rh);
    }

    list_for_each_safe(el, el1, &ts->os_signal_handlers) {
        JSOSSignalHandler *sh = list_entry(el, JSOSSignalHandler, link);
        free_sh(rt, sh);
    }
    
    list_for_each_safe(el, el1, &ts->os_timers) {
        JSOSTimer *th = list_entry(el, JSOSTimer, link);
        unlink_timer(rt, th);
        if (!th->has_object)
            free_timer(rt, th);
    }

#ifdef USE_WORKER
    /* XXX: free port_list ? */
    js_free_message_pipe(ts->recv_pipe);
    js_free_message_pipe(ts->send_pipe);
#endif

    free(ts);
    JS_SetRuntimeOpaque(rt, NULL); /* fail safe */
}

static void js_dump_obj(JSContext *ctx, FILE *f, JSValueConst val)
{
    const char *str;
    
    str = JS_ToCString(ctx, val);
    if (str) {
        fprintf(f, "%s\n", str);
        JS_FreeCString(ctx, str);
    } else {
        fprintf(f, "[exception]\n");
    }
}

static void js_std_dump_error1(JSContext *ctx, JSValueConst exception_val)
{
    JSValue val;
    BOOL is_error;
    
    is_error = JS_IsError(ctx, exception_val);
    js_dump_obj(ctx, stderr, exception_val);
    if (is_error) {
        val = JS_GetPropertyStr(ctx, exception_val, "stack");
        if (!JS_IsUndefined(val)) {
            js_dump_obj(ctx, stderr, val);
        }
        JS_FreeValue(ctx, val);
    }
}

void js_std_dump_error(JSContext *ctx)
{
    JSValue exception_val;
    
    exception_val = JS_GetException(ctx);
    js_std_dump_error1(ctx, exception_val);
    JS_FreeValue(ctx, exception_val);
}

void js_std_promise_rejection_tracker(JSContext *ctx, JSValueConst promise,
                                      JSValueConst reason,
                                      BOOL is_handled, void *opaque)
{
    if (!is_handled) {
        fprintf(stderr, "Possibly unhandled promise rejection: ");
        js_std_dump_error1(ctx, reason);
    }
}

/* main loop which calls the user JS callbacks */
void js_std_loop(JSContext *ctx)
{
    JSContext *ctx1;
    int err;

    for(;;) {
        /* execute the pending jobs */
        for(;;) {
            err = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);
            if (err <= 0) {
                if (err < 0) {
                    js_std_dump_error(ctx1);
                }
                break;
            }
        }

        if (!os_poll_func || os_poll_func(ctx))
            break;
    }
}

void js_std_eval_binary(JSContext *ctx, const uint8_t *buf, size_t buf_len,
                        int load_only)
{
    JSValue obj, val;
    obj = JS_ReadObject(ctx, buf, buf_len, JS_READ_OBJ_BYTECODE);
    if (JS_IsException(obj))
        goto exception;
    if (load_only) {
        if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {
            js_module_set_import_meta(ctx, obj, FALSE, FALSE);
        }
    } else {
        if (JS_VALUE_GET_TAG(obj) == JS_TAG_MODULE) {
            if (JS_ResolveModule(ctx, obj) < 0) {
                JS_FreeValue(ctx, obj);
                goto exception;
            }
            js_module_set_import_meta(ctx, obj, FALSE, TRUE);
        }
        val = JS_EvalFunction(ctx, obj);
        if (JS_IsException(val)) {
        exception:
            js_std_dump_error(ctx);
            exit(1);
        }
        JS_FreeValue(ctx, val);
    }
}

'''
'''--- quickjs-libc.h ---
/*
 * QuickJS C library
 * 
 * Copyright (c) 2017-2018 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef QUICKJS_LIBC_H
#define QUICKJS_LIBC_H

#include <stdio.h>
#include <stdlib.h>

#include "quickjs.h"

#ifdef __cplusplus
extern "C" {
#endif

JSModuleDef *js_init_module_std(JSContext *ctx, const char *module_name);
JSModuleDef *js_init_module_os(JSContext *ctx, const char *module_name);
void js_std_add_helpers(JSContext *ctx, int argc, char **argv);
void js_std_loop(JSContext *ctx);
void js_std_init_handlers(JSRuntime *rt);
void js_std_free_handlers(JSRuntime *rt);
void js_std_dump_error(JSContext *ctx);
uint8_t *js_load_file(JSContext *ctx, size_t *pbuf_len, const char *filename);
int js_module_set_import_meta(JSContext *ctx, JSValueConst func_val,
                              JS_BOOL use_realpath, JS_BOOL is_main);
JSModuleDef *js_module_loader(JSContext *ctx,
                              const char *module_name, void *opaque);
void js_std_eval_binary(JSContext *ctx, const uint8_t *buf, size_t buf_len,
                        int flags);
void js_std_promise_rejection_tracker(JSContext *ctx, JSValueConst promise,
                                      JSValueConst reason,
                                      JS_BOOL is_handled, void *opaque);
void js_std_set_worker_new_context_func(JSContext *(*func)(JSRuntime *rt));
                                        
#ifdef __cplusplus
} /* extern "C" { */
#endif

#endif /* QUICKJS_LIBC_H */

'''
'''--- quickjs-opcode.h ---
/*
 * QuickJS opcode definitions
 * 
 * Copyright (c) 2017-2018 Fabrice Bellard
 * Copyright (c) 2017-2018 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#ifdef FMT
FMT(none)
FMT(none_int)
FMT(none_loc)
FMT(none_arg)
FMT(none_var_ref)
FMT(u8)
FMT(i8)
FMT(loc8)
FMT(const8)
FMT(label8)
FMT(u16)
FMT(i16)
FMT(label16)
FMT(npop)
FMT(npopx)
FMT(npop_u16)
FMT(loc)
FMT(arg)
FMT(var_ref)
FMT(u32)
FMT(i32)
FMT(const)
FMT(label)
FMT(atom)
FMT(atom_u8)
FMT(atom_u16)
FMT(atom_label_u8)
FMT(atom_label_u16)
FMT(label_u16)
#undef FMT
#endif /* FMT */

#ifdef DEF

#ifndef def
#define def(id, size, n_pop, n_push, f) DEF(id, size, n_pop, n_push, f)
#endif

DEF(invalid, 1, 0, 0, none) /* never emitted */

/* push values */
DEF(       push_i32, 5, 0, 1, i32)
DEF(     push_const, 5, 0, 1, const)
DEF(       fclosure, 5, 0, 1, const) /* must follow push_const */
DEF(push_atom_value, 5, 0, 1, atom)
DEF( private_symbol, 5, 0, 1, atom)
DEF(      undefined, 1, 0, 1, none)
DEF(           null, 1, 0, 1, none)
DEF(      push_this, 1, 0, 1, none) /* only used at the start of a function */
DEF(     push_false, 1, 0, 1, none)
DEF(      push_true, 1, 0, 1, none)
DEF(         object, 1, 0, 1, none)
DEF( special_object, 2, 0, 1, u8) /* only used at the start of a function */
DEF(           rest, 3, 0, 1, u16) /* only used at the start of a function */

DEF(           drop, 1, 1, 0, none) /* a -> */
DEF(            nip, 1, 2, 1, none) /* a b -> b */
DEF(           nip1, 1, 3, 2, none) /* a b c -> b c */
DEF(            dup, 1, 1, 2, none) /* a -> a a */
DEF(           dup1, 1, 2, 3, none) /* a b -> a a b */
DEF(           dup2, 1, 2, 4, none) /* a b -> a b a b */
DEF(           dup3, 1, 3, 6, none) /* a b c -> a b c a b c */
DEF(        insert2, 1, 2, 3, none) /* obj a -> a obj a (dup_x1) */
DEF(        insert3, 1, 3, 4, none) /* obj prop a -> a obj prop a (dup_x2) */
DEF(        insert4, 1, 4, 5, none) /* this obj prop a -> a this obj prop a */
DEF(          perm3, 1, 3, 3, none) /* obj a b -> a obj b */
DEF(          perm4, 1, 4, 4, none) /* obj prop a b -> a obj prop b */
DEF(          perm5, 1, 5, 5, none) /* this obj prop a b -> a this obj prop b */
DEF(           swap, 1, 2, 2, none) /* a b -> b a */
DEF(          swap2, 1, 4, 4, none) /* a b c d -> c d a b */
DEF(          rot3l, 1, 3, 3, none) /* x a b -> a b x */
DEF(          rot3r, 1, 3, 3, none) /* a b x -> x a b */
DEF(          rot4l, 1, 4, 4, none) /* x a b c -> a b c x */
DEF(          rot5l, 1, 5, 5, none) /* x a b c d -> a b c d x */

DEF(call_constructor, 3, 2, 1, npop) /* func new.target args -> ret. arguments are not counted in n_pop */
DEF(           call, 3, 1, 1, npop) /* arguments are not counted in n_pop */
DEF(      tail_call, 3, 1, 0, npop) /* arguments are not counted in n_pop */
DEF(    call_method, 3, 2, 1, npop) /* arguments are not counted in n_pop */
DEF(tail_call_method, 3, 2, 0, npop) /* arguments are not counted in n_pop */
DEF(     array_from, 3, 0, 1, npop) /* arguments are not counted in n_pop */
DEF(          apply, 3, 3, 1, u16)
DEF(         return, 1, 1, 0, none)
DEF(   return_undef, 1, 0, 0, none)
DEF(check_ctor_return, 1, 1, 2, none)
DEF(     check_ctor, 1, 0, 0, none)
DEF(    check_brand, 1, 2, 2, none) /* this_obj func -> this_obj func */
DEF(      add_brand, 1, 2, 0, none) /* this_obj home_obj -> */
DEF(   return_async, 1, 1, 0, none)
DEF(          throw, 1, 1, 0, none)
DEF(    throw_error, 6, 0, 0, atom_u8)
DEF(           eval, 5, 1, 1, npop_u16) /* func args... -> ret_val */
DEF(     apply_eval, 3, 2, 1, u16) /* func array -> ret_eval */
DEF(         regexp, 1, 2, 1, none) /* create a RegExp object from the pattern and a
                                       bytecode string */
DEF(      get_super, 1, 1, 1, none)
DEF(         import, 1, 1, 1, none) /* dynamic module import */

DEF(      check_var, 5, 0, 1, atom) /* check if a variable exists */
DEF(  get_var_undef, 5, 0, 1, atom) /* push undefined if the variable does not exist */
DEF(        get_var, 5, 0, 1, atom) /* throw an exception if the variable does not exist */
DEF(        put_var, 5, 1, 0, atom) /* must come after get_var */
DEF(   put_var_init, 5, 1, 0, atom) /* must come after put_var. Used to initialize a global lexical variable */
DEF( put_var_strict, 5, 2, 0, atom) /* for strict mode variable write */

DEF(  get_ref_value, 1, 2, 3, none)
DEF(  put_ref_value, 1, 3, 0, none)

DEF(     define_var, 6, 0, 0, atom_u8)
DEF(check_define_var, 6, 0, 0, atom_u8)
DEF(    define_func, 6, 1, 0, atom_u8)
DEF(      get_field, 5, 1, 1, atom)
DEF(     get_field2, 5, 1, 2, atom)
DEF(      put_field, 5, 2, 0, atom)
DEF( get_private_field, 1, 2, 1, none) /* obj prop -> value */
DEF( put_private_field, 1, 3, 0, none) /* obj value prop -> */
DEF(define_private_field, 1, 3, 1, none) /* obj prop value -> obj */
DEF(   get_array_el, 1, 2, 1, none)
DEF(  get_array_el2, 1, 2, 2, none) /* obj prop -> obj value */
DEF(   put_array_el, 1, 3, 0, none)
DEF(get_super_value, 1, 3, 1, none) /* this obj prop -> value */
DEF(put_super_value, 1, 4, 0, none) /* this obj prop value -> */
DEF(   define_field, 5, 2, 1, atom)
DEF(       set_name, 5, 1, 1, atom)
DEF(set_name_computed, 1, 2, 2, none)
DEF(      set_proto, 1, 2, 1, none)
DEF(set_home_object, 1, 2, 2, none)
DEF(define_array_el, 1, 3, 2, none)
DEF(         append, 1, 3, 2, none) /* append enumerated object, update length */
DEF(copy_data_properties, 2, 3, 3, u8)
DEF(  define_method, 6, 2, 1, atom_u8)
DEF(define_method_computed, 2, 3, 1, u8) /* must come after define_method */
DEF(   define_class, 6, 2, 2, atom_u8) /* parent ctor -> ctor proto */
DEF(   define_class_computed, 6, 3, 3, atom_u8) /* field_name parent ctor -> field_name ctor proto (class with computed name) */

DEF(        get_loc, 3, 0, 1, loc)
DEF(        put_loc, 3, 1, 0, loc) /* must come after get_loc */
DEF(        set_loc, 3, 1, 1, loc) /* must come after put_loc */
DEF(        get_arg, 3, 0, 1, arg)
DEF(        put_arg, 3, 1, 0, arg) /* must come after get_arg */
DEF(        set_arg, 3, 1, 1, arg) /* must come after put_arg */
DEF(    get_var_ref, 3, 0, 1, var_ref) 
DEF(    put_var_ref, 3, 1, 0, var_ref) /* must come after get_var_ref */
DEF(    set_var_ref, 3, 1, 1, var_ref) /* must come after put_var_ref */
DEF(set_loc_uninitialized, 3, 0, 0, loc)
DEF(  get_loc_check, 3, 0, 1, loc)
DEF(  put_loc_check, 3, 1, 0, loc) /* must come after get_loc_check */
DEF(  put_loc_check_init, 3, 1, 0, loc)
DEF(get_var_ref_check, 3, 0, 1, var_ref) 
DEF(put_var_ref_check, 3, 1, 0, var_ref) /* must come after get_var_ref_check */
DEF(put_var_ref_check_init, 3, 1, 0, var_ref)
DEF(      close_loc, 3, 0, 0, loc)
DEF(       if_false, 5, 1, 0, label)
DEF(        if_true, 5, 1, 0, label) /* must come after if_false */
DEF(           goto, 5, 0, 0, label) /* must come after if_true */
DEF(          catch, 5, 0, 1, label)
DEF(          gosub, 5, 0, 0, label) /* used to execute the finally block */
DEF(            ret, 1, 1, 0, none) /* used to return from the finally block */

DEF(      to_object, 1, 1, 1, none)
//DEF(      to_string, 1, 1, 1, none)
DEF(     to_propkey, 1, 1, 1, none)
DEF(    to_propkey2, 1, 2, 2, none)

DEF(   with_get_var, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
DEF(   with_put_var, 10, 2, 1, atom_label_u8)     /* must be in the same order as scope_xxx */
DEF(with_delete_var, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
DEF(  with_make_ref, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
DEF(   with_get_ref, 10, 1, 0, atom_label_u8)     /* must be in the same order as scope_xxx */
DEF(with_get_ref_undef, 10, 1, 0, atom_label_u8)

DEF(   make_loc_ref, 7, 0, 2, atom_u16)
DEF(   make_arg_ref, 7, 0, 2, atom_u16)
DEF(make_var_ref_ref, 7, 0, 2, atom_u16)
DEF(   make_var_ref, 5, 0, 2, atom)

DEF(   for_in_start, 1, 1, 1, none)
DEF(   for_of_start, 1, 1, 3, none)
DEF(for_await_of_start, 1, 1, 3, none)
DEF(    for_in_next, 1, 1, 3, none)
DEF(    for_of_next, 2, 3, 5, u8)
DEF(iterator_check_object, 1, 1, 1, none)
DEF(iterator_get_value_done, 1, 1, 2, none)
DEF( iterator_close, 1, 3, 0, none)
DEF(iterator_close_return, 1, 4, 4, none)
DEF(  iterator_next, 1, 4, 4, none)
DEF(  iterator_call, 2, 4, 5, u8)
DEF(  initial_yield, 1, 0, 0, none)
DEF(          yield, 1, 1, 2, none)
DEF(     yield_star, 1, 1, 2, none)
DEF(async_yield_star, 1, 1, 2, none)
DEF(          await, 1, 1, 1, none)

/* arithmetic/logic operations */
DEF(            neg, 1, 1, 1, none)
DEF(           plus, 1, 1, 1, none)
DEF(            dec, 1, 1, 1, none)
DEF(            inc, 1, 1, 1, none)
DEF(       post_dec, 1, 1, 2, none)
DEF(       post_inc, 1, 1, 2, none)
DEF(        dec_loc, 2, 0, 0, loc8)
DEF(        inc_loc, 2, 0, 0, loc8)
DEF(        add_loc, 2, 1, 0, loc8)
DEF(            not, 1, 1, 1, none)
DEF(           lnot, 1, 1, 1, none)
DEF(         typeof, 1, 1, 1, none)
DEF(         delete, 1, 2, 1, none)
DEF(     delete_var, 5, 0, 1, atom)

DEF(            mul, 1, 2, 1, none)
DEF(            div, 1, 2, 1, none)
DEF(            mod, 1, 2, 1, none)
DEF(            add, 1, 2, 1, none)
DEF(            sub, 1, 2, 1, none)
DEF(            pow, 1, 2, 1, none)
DEF(            shl, 1, 2, 1, none)
DEF(            sar, 1, 2, 1, none)
DEF(            shr, 1, 2, 1, none)
DEF(             lt, 1, 2, 1, none)
DEF(            lte, 1, 2, 1, none)
DEF(             gt, 1, 2, 1, none)
DEF(            gte, 1, 2, 1, none)
DEF(     instanceof, 1, 2, 1, none)
DEF(             in, 1, 2, 1, none)
DEF(             eq, 1, 2, 1, none)
DEF(            neq, 1, 2, 1, none)
DEF(      strict_eq, 1, 2, 1, none)
DEF(     strict_neq, 1, 2, 1, none)
DEF(            and, 1, 2, 1, none)
DEF(            xor, 1, 2, 1, none)
DEF(             or, 1, 2, 1, none)
DEF(is_undefined_or_null, 1, 1, 1, none)
#ifdef CONFIG_BIGNUM
DEF(      mul_pow10, 1, 2, 1, none)
DEF(       math_mod, 1, 2, 1, none)
#endif
/* must be the last non short and non temporary opcode */
DEF(            nop, 1, 0, 0, none) 

/* temporary opcodes: never emitted in the final bytecode */

def(    enter_scope, 3, 0, 0, u16)  /* emitted in phase 1, removed in phase 2 */
def(    leave_scope, 3, 0, 0, u16)  /* emitted in phase 1, removed in phase 2 */

def(          label, 5, 0, 0, label) /* emitted in phase 1, removed in phase 3 */

def(scope_get_var_undef, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
def(  scope_get_var, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
def(  scope_put_var, 7, 1, 0, atom_u16) /* emitted in phase 1, removed in phase 2 */
def(scope_delete_var, 7, 0, 1, atom_u16) /* emitted in phase 1, removed in phase 2 */
def( scope_make_ref, 11, 0, 2, atom_label_u16) /* emitted in phase 1, removed in phase 2 */
def(  scope_get_ref, 7, 0, 2, atom_u16) /* emitted in phase 1, removed in phase 2 */
def(scope_put_var_init, 7, 0, 2, atom_u16) /* emitted in phase 1, removed in phase 2 */
def(scope_get_private_field, 7, 1, 1, atom_u16) /* obj -> value, emitted in phase 1, removed in phase 2 */
def(scope_get_private_field2, 7, 1, 2, atom_u16) /* obj -> obj value, emitted in phase 1, removed in phase 2 */
def(scope_put_private_field, 7, 1, 1, atom_u16) /* obj value ->, emitted in phase 1, removed in phase 2 */

def( set_class_name, 5, 1, 1, u32) /* emitted in phase 1, removed in phase 2 */
    
def(       line_num, 5, 0, 0, u32) /* emitted in phase 1, removed in phase 3 */

#if SHORT_OPCODES
DEF(    push_minus1, 1, 0, 1, none_int)
DEF(         push_0, 1, 0, 1, none_int)
DEF(         push_1, 1, 0, 1, none_int)
DEF(         push_2, 1, 0, 1, none_int)
DEF(         push_3, 1, 0, 1, none_int)
DEF(         push_4, 1, 0, 1, none_int)
DEF(         push_5, 1, 0, 1, none_int)
DEF(         push_6, 1, 0, 1, none_int)
DEF(         push_7, 1, 0, 1, none_int)
DEF(        push_i8, 2, 0, 1, i8)
DEF(       push_i16, 3, 0, 1, i16)
DEF(    push_const8, 2, 0, 1, const8)
DEF(      fclosure8, 2, 0, 1, const8) /* must follow push_const8 */
DEF(push_empty_string, 1, 0, 1, none)

DEF(       get_loc8, 2, 0, 1, loc8)
DEF(       put_loc8, 2, 1, 0, loc8)
DEF(       set_loc8, 2, 1, 1, loc8)

DEF(       get_loc0, 1, 0, 1, none_loc)
DEF(       get_loc1, 1, 0, 1, none_loc)
DEF(       get_loc2, 1, 0, 1, none_loc)
DEF(       get_loc3, 1, 0, 1, none_loc)
DEF(       put_loc0, 1, 1, 0, none_loc)
DEF(       put_loc1, 1, 1, 0, none_loc)
DEF(       put_loc2, 1, 1, 0, none_loc)
DEF(       put_loc3, 1, 1, 0, none_loc)
DEF(       set_loc0, 1, 1, 1, none_loc)
DEF(       set_loc1, 1, 1, 1, none_loc)
DEF(       set_loc2, 1, 1, 1, none_loc)
DEF(       set_loc3, 1, 1, 1, none_loc)
DEF(       get_arg0, 1, 0, 1, none_arg)
DEF(       get_arg1, 1, 0, 1, none_arg)
DEF(       get_arg2, 1, 0, 1, none_arg)
DEF(       get_arg3, 1, 0, 1, none_arg)
DEF(       put_arg0, 1, 1, 0, none_arg)
DEF(       put_arg1, 1, 1, 0, none_arg)
DEF(       put_arg2, 1, 1, 0, none_arg)
DEF(       put_arg3, 1, 1, 0, none_arg)
DEF(       set_arg0, 1, 1, 1, none_arg)
DEF(       set_arg1, 1, 1, 1, none_arg)
DEF(       set_arg2, 1, 1, 1, none_arg)
DEF(       set_arg3, 1, 1, 1, none_arg)
DEF(   get_var_ref0, 1, 0, 1, none_var_ref)
DEF(   get_var_ref1, 1, 0, 1, none_var_ref)
DEF(   get_var_ref2, 1, 0, 1, none_var_ref)
DEF(   get_var_ref3, 1, 0, 1, none_var_ref)
DEF(   put_var_ref0, 1, 1, 0, none_var_ref)
DEF(   put_var_ref1, 1, 1, 0, none_var_ref)
DEF(   put_var_ref2, 1, 1, 0, none_var_ref)
DEF(   put_var_ref3, 1, 1, 0, none_var_ref)
DEF(   set_var_ref0, 1, 1, 1, none_var_ref)
DEF(   set_var_ref1, 1, 1, 1, none_var_ref)
DEF(   set_var_ref2, 1, 1, 1, none_var_ref)
DEF(   set_var_ref3, 1, 1, 1, none_var_ref)

DEF(     get_length, 1, 1, 1, none)

DEF(      if_false8, 2, 1, 0, label8)
DEF(       if_true8, 2, 1, 0, label8) /* must come after if_false8 */
DEF(          goto8, 2, 0, 0, label8) /* must come after if_true8 */
DEF(         goto16, 3, 0, 0, label16)

DEF(          call0, 1, 1, 1, npopx)
DEF(          call1, 1, 1, 1, npopx)
DEF(          call2, 1, 1, 1, npopx)
DEF(          call3, 1, 1, 1, npopx)

DEF(   is_undefined, 1, 1, 1, none)
DEF(        is_null, 1, 1, 1, none)
DEF(typeof_is_undefined, 1, 1, 1, none)
DEF( typeof_is_function, 1, 1, 1, none)
#endif

#undef DEF
#undef def
#endif  /* DEF */

'''
'''--- quickjs.h ---
/*
 * QuickJS Javascript Engine
 *
 * Copyright (c) 2017-2021 Fabrice Bellard
 * Copyright (c) 2017-2021 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#ifndef QUICKJS_H
#define QUICKJS_H

#include <stdio.h>
#include <stdint.h>

#ifdef __cplusplus
extern "C" {
#endif

#if defined(__GNUC__) || defined(__clang__)
#define js_likely(x)          __builtin_expect(!!(x), 1)
#define js_unlikely(x)        __builtin_expect(!!(x), 0)
#define js_force_inline       inline __attribute__((always_inline))
#define __js_printf_like(f, a)   __attribute__((format(printf, f, a)))
#else
#define js_likely(x)     (x)
#define js_unlikely(x)   (x)
#define js_force_inline  inline
#define __js_printf_like(a, b)
#endif

#define JS_BOOL int

typedef struct JSRuntime JSRuntime;
typedef struct JSContext JSContext;
typedef struct JSObject JSObject;
typedef struct JSClass JSClass;
typedef uint32_t JSClassID;
typedef uint32_t JSAtom;

#if INTPTR_MAX >= INT64_MAX
#define JS_PTR64
#define JS_PTR64_DEF(a) a
#else
#define JS_PTR64_DEF(a)
#endif

#ifndef JS_PTR64
#define JS_NAN_BOXING
#endif

enum {
    /* all tags with a reference count are negative */
    JS_TAG_FIRST       = -11, /* first negative tag */
    JS_TAG_BIG_DECIMAL = -11,
    JS_TAG_BIG_INT     = -10,
    JS_TAG_BIG_FLOAT   = -9,
    JS_TAG_SYMBOL      = -8,
    JS_TAG_STRING      = -7,
    JS_TAG_MODULE      = -3, /* used internally */
    JS_TAG_FUNCTION_BYTECODE = -2, /* used internally */
    JS_TAG_OBJECT      = -1,

    JS_TAG_INT         = 0,
    JS_TAG_BOOL        = 1,
    JS_TAG_NULL        = 2,
    JS_TAG_UNDEFINED   = 3,
    JS_TAG_UNINITIALIZED = 4,
    JS_TAG_CATCH_OFFSET = 5,
    JS_TAG_EXCEPTION   = 6,
    JS_TAG_FLOAT64     = 7,
    /* any larger tag is FLOAT64 if JS_NAN_BOXING */
};

typedef struct JSRefCountHeader {
    int ref_count;
} JSRefCountHeader;

#define JS_FLOAT64_NAN NAN

#ifdef CONFIG_CHECK_JSVALUE
/* JSValue consistency : it is not possible to run the code in this
   mode, but it is useful to detect simple reference counting
   errors. It would be interesting to modify a static C analyzer to
   handle specific annotations (clang has such annotations but only
   for objective C) */
typedef struct __JSValue *JSValue;
typedef const struct __JSValue *JSValueConst;

#define JS_VALUE_GET_TAG(v) (int)((uintptr_t)(v) & 0xf)
/* same as JS_VALUE_GET_TAG, but return JS_TAG_FLOAT64 with NaN boxing */
#define JS_VALUE_GET_NORM_TAG(v) JS_VALUE_GET_TAG(v)
#define JS_VALUE_GET_INT(v) (int)((intptr_t)(v) >> 4)
#define JS_VALUE_GET_BOOL(v) JS_VALUE_GET_INT(v)
#define JS_VALUE_GET_FLOAT64(v) (double)JS_VALUE_GET_INT(v)
#define JS_VALUE_GET_PTR(v) (void *)((intptr_t)(v) & ~0xf)

#define JS_MKVAL(tag, val) (JSValue)(intptr_t)(((val) << 4) | (tag))
#define JS_MKPTR(tag, p) (JSValue)((intptr_t)(p) | (tag))

#define JS_TAG_IS_FLOAT64(tag) ((unsigned)(tag) == JS_TAG_FLOAT64)

#define JS_NAN JS_MKVAL(JS_TAG_FLOAT64, 1)

static inline JSValue __JS_NewFloat64(JSContext *ctx, double d)
{
    return JS_MKVAL(JS_TAG_FLOAT64, (int)d);
}

static inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)
{
    return 0;
}
    
#elif defined(JS_NAN_BOXING)

typedef uint64_t JSValue;

#define JSValueConst JSValue

#define JS_VALUE_GET_TAG(v) (int)((v) >> 32)
#define JS_VALUE_GET_INT(v) (int)(v)
#define JS_VALUE_GET_BOOL(v) (int)(v)
#define JS_VALUE_GET_PTR(v) (void *)(intptr_t)(v)

#define JS_MKVAL(tag, val) (((uint64_t)(tag) << 32) | (uint32_t)(val))
#define JS_MKPTR(tag, ptr) (((uint64_t)(tag) << 32) | (uintptr_t)(ptr))

#define JS_FLOAT64_TAG_ADDEND (0x7ff80000 - JS_TAG_FIRST + 1) /* quiet NaN encoding */

static inline double JS_VALUE_GET_FLOAT64(JSValue v)
{
    union {
        JSValue v;
        double d;
    } u;
    u.v = v;
    u.v += (uint64_t)JS_FLOAT64_TAG_ADDEND << 32;
    return u.d;
}

#define JS_NAN (0x7ff8000000000000 - ((uint64_t)JS_FLOAT64_TAG_ADDEND << 32))

static inline JSValue __JS_NewFloat64(JSContext *ctx, double d)
{
    union {
        double d;
        uint64_t u64;
    } u;
    JSValue v;
    u.d = d;
    /* normalize NaN */
    if (js_unlikely((u.u64 & 0x7fffffffffffffff) > 0x7ff0000000000000))
        v = JS_NAN;
    else
        v = u.u64 - ((uint64_t)JS_FLOAT64_TAG_ADDEND << 32);
    return v;
}

#define JS_TAG_IS_FLOAT64(tag) ((unsigned)((tag) - JS_TAG_FIRST) >= (JS_TAG_FLOAT64 - JS_TAG_FIRST))

/* same as JS_VALUE_GET_TAG, but return JS_TAG_FLOAT64 with NaN boxing */
static inline int JS_VALUE_GET_NORM_TAG(JSValue v)
{
    uint32_t tag;
    tag = JS_VALUE_GET_TAG(v);
    if (JS_TAG_IS_FLOAT64(tag))
        return JS_TAG_FLOAT64;
    else
        return tag;
}

static inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)
{
    uint32_t tag;
    tag = JS_VALUE_GET_TAG(v);
    return tag == (JS_NAN >> 32);
}
    
#else /* !JS_NAN_BOXING */

typedef union JSValueUnion {
    int32_t int32;
    double float64;
    void *ptr;
} JSValueUnion;

typedef struct JSValue {
    JSValueUnion u;
    int64_t tag;
} JSValue;

#define JSValueConst JSValue

#define JS_VALUE_GET_TAG(v) ((int32_t)(v).tag)
/* same as JS_VALUE_GET_TAG, but return JS_TAG_FLOAT64 with NaN boxing */
#define JS_VALUE_GET_NORM_TAG(v) JS_VALUE_GET_TAG(v)
#define JS_VALUE_GET_INT(v) ((v).u.int32)
#define JS_VALUE_GET_BOOL(v) ((v).u.int32)
#define JS_VALUE_GET_FLOAT64(v) ((v).u.float64)
#define JS_VALUE_GET_PTR(v) ((v).u.ptr)

#define JS_MKVAL(tag, val) (JSValue){ (JSValueUnion){ .int32 = val }, tag }
#define JS_MKPTR(tag, p) (JSValue){ (JSValueUnion){ .ptr = p }, tag }

#define JS_TAG_IS_FLOAT64(tag) ((unsigned)(tag) == JS_TAG_FLOAT64)

#define JS_NAN (JSValue){ .u.float64 = JS_FLOAT64_NAN, JS_TAG_FLOAT64 }

static inline JSValue __JS_NewFloat64(JSContext *ctx, double d)
{
    JSValue v;
    v.tag = JS_TAG_FLOAT64;
    v.u.float64 = d;
    return v;
}

static inline JS_BOOL JS_VALUE_IS_NAN(JSValue v)
{
    union {
        double d;
        uint64_t u64;
    } u;
    if (v.tag != JS_TAG_FLOAT64)
        return 0;
    u.d = v.u.float64;
    return (u.u64 & 0x7fffffffffffffff) > 0x7ff0000000000000;
}

#endif /* !JS_NAN_BOXING */

#define JS_VALUE_IS_BOTH_INT(v1, v2) ((JS_VALUE_GET_TAG(v1) | JS_VALUE_GET_TAG(v2)) == 0)
#define JS_VALUE_IS_BOTH_FLOAT(v1, v2) (JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(v1)) && JS_TAG_IS_FLOAT64(JS_VALUE_GET_TAG(v2)))

#define JS_VALUE_GET_OBJ(v) ((JSObject *)JS_VALUE_GET_PTR(v))
#define JS_VALUE_GET_STRING(v) ((JSString *)JS_VALUE_GET_PTR(v))
#define JS_VALUE_HAS_REF_COUNT(v) ((unsigned)JS_VALUE_GET_TAG(v) >= (unsigned)JS_TAG_FIRST)

/* special values */
#define JS_NULL      JS_MKVAL(JS_TAG_NULL, 0)
#define JS_UNDEFINED JS_MKVAL(JS_TAG_UNDEFINED, 0)
#define JS_FALSE     JS_MKVAL(JS_TAG_BOOL, 0)
#define JS_TRUE      JS_MKVAL(JS_TAG_BOOL, 1)
#define JS_EXCEPTION JS_MKVAL(JS_TAG_EXCEPTION, 0)
#define JS_UNINITIALIZED JS_MKVAL(JS_TAG_UNINITIALIZED, 0)

/* flags for object properties */
#define JS_PROP_CONFIGURABLE  (1 << 0)
#define JS_PROP_WRITABLE      (1 << 1)
#define JS_PROP_ENUMERABLE    (1 << 2)
#define JS_PROP_C_W_E         (JS_PROP_CONFIGURABLE | JS_PROP_WRITABLE | JS_PROP_ENUMERABLE)
#define JS_PROP_LENGTH        (1 << 3) /* used internally in Arrays */
#define JS_PROP_TMASK         (3 << 4) /* mask for NORMAL, GETSET, VARREF, AUTOINIT */
#define JS_PROP_NORMAL         (0 << 4)
#define JS_PROP_GETSET         (1 << 4)
#define JS_PROP_VARREF         (2 << 4) /* used internally */
#define JS_PROP_AUTOINIT       (3 << 4) /* used internally */

/* flags for JS_DefineProperty */
#define JS_PROP_HAS_SHIFT        8
#define JS_PROP_HAS_CONFIGURABLE (1 << 8)
#define JS_PROP_HAS_WRITABLE     (1 << 9)
#define JS_PROP_HAS_ENUMERABLE   (1 << 10)
#define JS_PROP_HAS_GET          (1 << 11)
#define JS_PROP_HAS_SET          (1 << 12)
#define JS_PROP_HAS_VALUE        (1 << 13)

/* throw an exception if false would be returned
   (JS_DefineProperty/JS_SetProperty) */
#define JS_PROP_THROW            (1 << 14)
/* throw an exception if false would be returned in strict mode
   (JS_SetProperty) */
#define JS_PROP_THROW_STRICT     (1 << 15)

#define JS_PROP_NO_ADD           (1 << 16) /* internal use */
#define JS_PROP_NO_EXOTIC        (1 << 17) /* internal use */

#define JS_DEFAULT_STACK_SIZE (256 * 1024)

/* JS_Eval() flags */
#define JS_EVAL_TYPE_GLOBAL   (0 << 0) /* global code (default) */
#define JS_EVAL_TYPE_MODULE   (1 << 0) /* module code */
#define JS_EVAL_TYPE_DIRECT   (2 << 0) /* direct call (internal use) */
#define JS_EVAL_TYPE_INDIRECT (3 << 0) /* indirect call (internal use) */
#define JS_EVAL_TYPE_MASK     (3 << 0)

#define JS_EVAL_FLAG_STRICT   (1 << 3) /* force 'strict' mode */
#define JS_EVAL_FLAG_STRIP    (1 << 4) /* force 'strip' mode */
/* compile but do not run. The result is an object with a
   JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed
   with JS_EvalFunction(). */
#define JS_EVAL_FLAG_COMPILE_ONLY (1 << 5)
/* don't include the stack frames before this eval in the Error() backtraces */
#define JS_EVAL_FLAG_BACKTRACE_BARRIER (1 << 6)

typedef JSValue JSCFunction(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv);
typedef JSValue JSCFunctionMagic(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic);
typedef JSValue JSCFunctionData(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic, JSValue *func_data);

typedef struct JSMallocState {
    size_t malloc_count;
    size_t malloc_size;
    size_t malloc_limit;
    void *opaque; /* user opaque */
} JSMallocState;

typedef struct JSMallocFunctions {
    void *(*js_malloc)(JSMallocState *s, size_t size);
    void (*js_free)(JSMallocState *s, void *ptr);
    void *(*js_realloc)(JSMallocState *s, void *ptr, size_t size);
    size_t (*js_malloc_usable_size)(const void *ptr);
} JSMallocFunctions;

typedef struct JSGCObjectHeader JSGCObjectHeader;

JSRuntime *JS_NewRuntime(void);
/* info lifetime must exceed that of rt */
void JS_SetRuntimeInfo(JSRuntime *rt, const char *info);
void JS_SetMemoryLimit(JSRuntime *rt, size_t limit);
void JS_SetGCThreshold(JSRuntime *rt, size_t gc_threshold);
/* use 0 to disable maximum stack size check */
void JS_SetMaxStackSize(JSRuntime *rt, size_t stack_size);
/* should be called when changing thread to update the stack top value
   used to check stack overflow. */
void JS_UpdateStackTop(JSRuntime *rt);
JSRuntime *JS_NewRuntime2(const JSMallocFunctions *mf, void *opaque);
void JS_FreeRuntime(JSRuntime *rt);
void *JS_GetRuntimeOpaque(JSRuntime *rt);
void JS_SetRuntimeOpaque(JSRuntime *rt, void *opaque);
typedef void JS_MarkFunc(JSRuntime *rt, JSGCObjectHeader *gp);
void JS_MarkValue(JSRuntime *rt, JSValueConst val, JS_MarkFunc *mark_func);
void JS_RunGC(JSRuntime *rt);
JS_BOOL JS_IsLiveObject(JSRuntime *rt, JSValueConst obj);

JSContext *JS_NewContext(JSRuntime *rt);
void JS_FreeContext(JSContext *s);
JSContext *JS_DupContext(JSContext *ctx);
void *JS_GetContextOpaque(JSContext *ctx);
void JS_SetContextOpaque(JSContext *ctx, void *opaque);
JSRuntime *JS_GetRuntime(JSContext *ctx);
void JS_SetClassProto(JSContext *ctx, JSClassID class_id, JSValue obj);
JSValue JS_GetClassProto(JSContext *ctx, JSClassID class_id);

/* the following functions are used to select the intrinsic object to
   save memory */
JSContext *JS_NewContextRaw(JSRuntime *rt);
void JS_AddIntrinsicBaseObjects(JSContext *ctx);
void JS_AddIntrinsicDate(JSContext *ctx);
void JS_AddIntrinsicEval(JSContext *ctx);
void JS_AddIntrinsicStringNormalize(JSContext *ctx);
void JS_AddIntrinsicRegExpCompiler(JSContext *ctx);
void JS_AddIntrinsicRegExp(JSContext *ctx);
void JS_AddIntrinsicJSON(JSContext *ctx);
void JS_AddIntrinsicProxy(JSContext *ctx);
void JS_AddIntrinsicMapSet(JSContext *ctx);
void JS_AddIntrinsicTypedArrays(JSContext *ctx);
void JS_AddIntrinsicPromise(JSContext *ctx);
void JS_AddIntrinsicBigInt(JSContext *ctx);
void JS_AddIntrinsicBigFloat(JSContext *ctx);
void JS_AddIntrinsicBigDecimal(JSContext *ctx);
/* enable operator overloading */
void JS_AddIntrinsicOperators(JSContext *ctx);
/* enable "use math" */
void JS_EnableBignumExt(JSContext *ctx, JS_BOOL enable);

JSValue js_string_codePointRange(JSContext *ctx, JSValueConst this_val,
                                 int argc, JSValueConst *argv);

void *js_malloc_rt(JSRuntime *rt, size_t size);
void js_free_rt(JSRuntime *rt, void *ptr);
void *js_realloc_rt(JSRuntime *rt, void *ptr, size_t size);
size_t js_malloc_usable_size_rt(JSRuntime *rt, const void *ptr);
void *js_mallocz_rt(JSRuntime *rt, size_t size);

void *js_malloc(JSContext *ctx, size_t size);
void js_free(JSContext *ctx, void *ptr);
void *js_realloc(JSContext *ctx, void *ptr, size_t size);
size_t js_malloc_usable_size(JSContext *ctx, const void *ptr);
void *js_realloc2(JSContext *ctx, void *ptr, size_t size, size_t *pslack);
void *js_mallocz(JSContext *ctx, size_t size);
char *js_strdup(JSContext *ctx, const char *str);
char *js_strndup(JSContext *ctx, const char *s, size_t n);

typedef struct JSMemoryUsage {
    int64_t malloc_size, malloc_limit, memory_used_size;
    int64_t malloc_count;
    int64_t memory_used_count;
    int64_t atom_count, atom_size;
    int64_t str_count, str_size;
    int64_t obj_count, obj_size;
    int64_t prop_count, prop_size;
    int64_t shape_count, shape_size;
    int64_t js_func_count, js_func_size, js_func_code_size;
    int64_t js_func_pc2line_count, js_func_pc2line_size;
    int64_t c_func_count, array_count;
    int64_t fast_array_count, fast_array_elements;
    int64_t binary_object_count, binary_object_size;
} JSMemoryUsage;

void JS_ComputeMemoryUsage(JSRuntime *rt, JSMemoryUsage *s);
void JS_DumpMemoryUsage(FILE *fp, const JSMemoryUsage *s, JSRuntime *rt);

/* atom support */
#define JS_ATOM_NULL 0

JSAtom JS_NewAtomLen(JSContext *ctx, const char *str, size_t len);
JSAtom JS_NewAtom(JSContext *ctx, const char *str);
JSAtom JS_NewAtomUInt32(JSContext *ctx, uint32_t n);
JSAtom JS_DupAtom(JSContext *ctx, JSAtom v);
void JS_FreeAtom(JSContext *ctx, JSAtom v);
void JS_FreeAtomRT(JSRuntime *rt, JSAtom v);
JSValue JS_AtomToValue(JSContext *ctx, JSAtom atom);
JSValue JS_AtomToString(JSContext *ctx, JSAtom atom);
const char *JS_AtomToCString(JSContext *ctx, JSAtom atom);
JSAtom JS_ValueToAtom(JSContext *ctx, JSValueConst val);

/* object class support */

typedef struct JSPropertyEnum {
    JS_BOOL is_enumerable;
    JSAtom atom;
} JSPropertyEnum;

typedef struct JSPropertyDescriptor {
    int flags;
    JSValue value;
    JSValue getter;
    JSValue setter;
} JSPropertyDescriptor;

typedef struct JSClassExoticMethods {
    /* Return -1 if exception (can only happen in case of Proxy object),
       FALSE if the property does not exists, TRUE if it exists. If 1 is
       returned, the property descriptor 'desc' is filled if != NULL. */
    int (*get_own_property)(JSContext *ctx, JSPropertyDescriptor *desc,
                             JSValueConst obj, JSAtom prop);
    /* '*ptab' should hold the '*plen' property keys. Return 0 if OK,
       -1 if exception. The 'is_enumerable' field is ignored.
    */
    int (*get_own_property_names)(JSContext *ctx, JSPropertyEnum **ptab,
                                  uint32_t *plen,
                                  JSValueConst obj);
    /* return < 0 if exception, or TRUE/FALSE */
    int (*delete_property)(JSContext *ctx, JSValueConst obj, JSAtom prop);
    /* return < 0 if exception or TRUE/FALSE */
    int (*define_own_property)(JSContext *ctx, JSValueConst this_obj,
                               JSAtom prop, JSValueConst val,
                               JSValueConst getter, JSValueConst setter,
                               int flags);
    /* The following methods can be emulated with the previous ones,
       so they are usually not needed */
    /* return < 0 if exception or TRUE/FALSE */
    int (*has_property)(JSContext *ctx, JSValueConst obj, JSAtom atom);
    JSValue (*get_property)(JSContext *ctx, JSValueConst obj, JSAtom atom,
                            JSValueConst receiver);
    /* return < 0 if exception or TRUE/FALSE */
    int (*set_property)(JSContext *ctx, JSValueConst obj, JSAtom atom,
                        JSValueConst value, JSValueConst receiver, int flags);
} JSClassExoticMethods;

typedef void JSClassFinalizer(JSRuntime *rt, JSValue val);
typedef void JSClassGCMark(JSRuntime *rt, JSValueConst val,
                           JS_MarkFunc *mark_func);
#define JS_CALL_FLAG_CONSTRUCTOR (1 << 0)
typedef JSValue JSClassCall(JSContext *ctx, JSValueConst func_obj,
                            JSValueConst this_val, int argc, JSValueConst *argv,
                            int flags);

typedef struct JSClassDef {
    const char *class_name;
    JSClassFinalizer *finalizer;
    JSClassGCMark *gc_mark;
    /* if call != NULL, the object is a function. If (flags &
       JS_CALL_FLAG_CONSTRUCTOR) != 0, the function is called as a
       constructor. In this case, 'this_val' is new.target. A
       constructor call only happens if the object constructor bit is
       set (see JS_SetConstructorBit()). */
    JSClassCall *call;
    /* XXX: suppress this indirection ? It is here only to save memory
       because only a few classes need these methods */
    JSClassExoticMethods *exotic;
} JSClassDef;

JSClassID JS_NewClassID(JSClassID *pclass_id);
int JS_NewClass(JSRuntime *rt, JSClassID class_id, const JSClassDef *class_def);
int JS_IsRegisteredClass(JSRuntime *rt, JSClassID class_id);

/* value handling */

static js_force_inline JSValue JS_NewBool(JSContext *ctx, JS_BOOL val)
{
    return JS_MKVAL(JS_TAG_BOOL, (val != 0));
}

static js_force_inline JSValue JS_NewInt32(JSContext *ctx, int32_t val)
{
    return JS_MKVAL(JS_TAG_INT, val);
}

static js_force_inline JSValue JS_NewCatchOffset(JSContext *ctx, int32_t val)
{
    return JS_MKVAL(JS_TAG_CATCH_OFFSET, val);
}

static js_force_inline JSValue JS_NewInt64(JSContext *ctx, int64_t val)
{
    JSValue v;
    if (val == (int32_t)val) {
        v = JS_NewInt32(ctx, val);
    } else {
        v = __JS_NewFloat64(ctx, val);
    }
    return v;
}

static js_force_inline JSValue JS_NewUint32(JSContext *ctx, uint32_t val)
{
    JSValue v;
    if (val <= 0x7fffffff) {
        v = JS_NewInt32(ctx, val);
    } else {
        v = __JS_NewFloat64(ctx, val);
    }
    return v;
}

JSValue JS_NewBigInt64(JSContext *ctx, int64_t v);
JSValue JS_NewBigUint64(JSContext *ctx, uint64_t v);

static js_force_inline JSValue JS_NewFloat64(JSContext *ctx, double d)
{
    JSValue v;
    int32_t val;
    union {
        double d;
        uint64_t u;
    } u, t;
    u.d = d;
    val = (int32_t)d;
    t.d = val;
    /* -0 cannot be represented as integer, so we compare the bit
        representation */
    if (u.u == t.u) {
        v = JS_MKVAL(JS_TAG_INT, val);
    } else {
        v = __JS_NewFloat64(ctx, d);
    }
    return v;
}

static inline JS_BOOL JS_IsNumber(JSValueConst v)
{
    int tag = JS_VALUE_GET_TAG(v);
    return tag == JS_TAG_INT || JS_TAG_IS_FLOAT64(tag);
}

static inline JS_BOOL JS_IsBigInt(JSContext *ctx, JSValueConst v)
{
    int tag = JS_VALUE_GET_TAG(v);
    return tag == JS_TAG_BIG_INT;
}

static inline JS_BOOL JS_IsBigFloat(JSValueConst v)
{
    int tag = JS_VALUE_GET_TAG(v);
    return tag == JS_TAG_BIG_FLOAT;
}

static inline JS_BOOL JS_IsBigDecimal(JSValueConst v)
{
    int tag = JS_VALUE_GET_TAG(v);
    return tag == JS_TAG_BIG_DECIMAL;
}

static inline JS_BOOL JS_IsBool(JSValueConst v)
{
    return JS_VALUE_GET_TAG(v) == JS_TAG_BOOL;
}

static inline JS_BOOL JS_IsNull(JSValueConst v)
{
    return JS_VALUE_GET_TAG(v) == JS_TAG_NULL;
}

static inline JS_BOOL JS_IsUndefined(JSValueConst v)
{
    return JS_VALUE_GET_TAG(v) == JS_TAG_UNDEFINED;
}

static inline JS_BOOL JS_IsException(JSValueConst v)
{
    return js_unlikely(JS_VALUE_GET_TAG(v) == JS_TAG_EXCEPTION);
}

static inline JS_BOOL JS_IsUninitialized(JSValueConst v)
{
    return js_unlikely(JS_VALUE_GET_TAG(v) == JS_TAG_UNINITIALIZED);
}

static inline JS_BOOL JS_IsString(JSValueConst v)
{
    return JS_VALUE_GET_TAG(v) == JS_TAG_STRING;
}

static inline JS_BOOL JS_IsSymbol(JSValueConst v)
{
    return JS_VALUE_GET_TAG(v) == JS_TAG_SYMBOL;
}

static inline JS_BOOL JS_IsObject(JSValueConst v)
{
    return JS_VALUE_GET_TAG(v) == JS_TAG_OBJECT;
}

JSValue JS_Throw(JSContext *ctx, JSValue obj);
JSValue JS_GetException(JSContext *ctx);
JS_BOOL JS_IsError(JSContext *ctx, JSValueConst val);
void JS_ResetUncatchableError(JSContext *ctx);
JSValue JS_NewError(JSContext *ctx);
JSValue __js_printf_like(2, 3) JS_ThrowSyntaxError(JSContext *ctx, const char *fmt, ...);
JSValue __js_printf_like(2, 3) JS_ThrowTypeError(JSContext *ctx, const char *fmt, ...);
JSValue __js_printf_like(2, 3) JS_ThrowReferenceError(JSContext *ctx, const char *fmt, ...);
JSValue __js_printf_like(2, 3) JS_ThrowRangeError(JSContext *ctx, const char *fmt, ...);
JSValue __js_printf_like(2, 3) JS_ThrowInternalError(JSContext *ctx, const char *fmt, ...);
JSValue JS_ThrowOutOfMemory(JSContext *ctx);

void __JS_FreeValue(JSContext *ctx, JSValue v);
static inline void JS_FreeValue(JSContext *ctx, JSValue v)
{
    if (JS_VALUE_HAS_REF_COUNT(v)) {
        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
        if (--p->ref_count <= 0) {
            __JS_FreeValue(ctx, v);
        }
    }
}
void __JS_FreeValueRT(JSRuntime *rt, JSValue v);
static inline void JS_FreeValueRT(JSRuntime *rt, JSValue v)
{
    if (JS_VALUE_HAS_REF_COUNT(v)) {
        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
        if (--p->ref_count <= 0) {
            __JS_FreeValueRT(rt, v);
        }
    }
}

static inline JSValue JS_DupValue(JSContext *ctx, JSValueConst v)
{
    if (JS_VALUE_HAS_REF_COUNT(v)) {
        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
        p->ref_count++;
    }
    return (JSValue)v;
}

static inline JSValue JS_DupValueRT(JSRuntime *rt, JSValueConst v)
{
    if (JS_VALUE_HAS_REF_COUNT(v)) {
        JSRefCountHeader *p = (JSRefCountHeader *)JS_VALUE_GET_PTR(v);
        p->ref_count++;
    }
    return (JSValue)v;
}

int JS_ToBool(JSContext *ctx, JSValueConst val); /* return -1 for JS_EXCEPTION */
int JS_ToInt32(JSContext *ctx, int32_t *pres, JSValueConst val);
static inline int JS_ToUint32(JSContext *ctx, uint32_t *pres, JSValueConst val)
{
    return JS_ToInt32(ctx, (int32_t*)pres, val);
}
int JS_ToInt64(JSContext *ctx, int64_t *pres, JSValueConst val);
int JS_ToIndex(JSContext *ctx, uint64_t *plen, JSValueConst val);
int JS_ToFloat64(JSContext *ctx, double *pres, JSValueConst val);
/* return an exception if 'val' is a Number */
int JS_ToBigInt64(JSContext *ctx, int64_t *pres, JSValueConst val);
/* same as JS_ToInt64() but allow BigInt */
int JS_ToInt64Ext(JSContext *ctx, int64_t *pres, JSValueConst val);

JSValue JS_NewStringLen(JSContext *ctx, const char *str1, size_t len1);
JSValue JS_NewString(JSContext *ctx, const char *str);
JSValue JS_NewAtomString(JSContext *ctx, const char *str);
JSValue JS_ToString(JSContext *ctx, JSValueConst val);
JSValue JS_ToPropertyKey(JSContext *ctx, JSValueConst val);
const char *JS_ToCStringLen2(JSContext *ctx, size_t *plen, JSValueConst val1, JS_BOOL cesu8);
static inline const char *JS_ToCStringLen(JSContext *ctx, size_t *plen, JSValueConst val1)
{
    return JS_ToCStringLen2(ctx, plen, val1, 0);
}
static inline const char *JS_ToCString(JSContext *ctx, JSValueConst val1)
{
    return JS_ToCStringLen2(ctx, NULL, val1, 0);
}
void JS_FreeCString(JSContext *ctx, const char *ptr);

JSValue JS_NewObjectProtoClass(JSContext *ctx, JSValueConst proto, JSClassID class_id);
JSValue JS_NewObjectClass(JSContext *ctx, int class_id);
JSValue JS_NewObjectProto(JSContext *ctx, JSValueConst proto);
JSValue JS_NewObject(JSContext *ctx);

JS_BOOL JS_IsFunction(JSContext* ctx, JSValueConst val);
JS_BOOL JS_IsConstructor(JSContext* ctx, JSValueConst val);
JS_BOOL JS_SetConstructorBit(JSContext *ctx, JSValueConst func_obj, JS_BOOL val);

JSValue JS_NewArray(JSContext *ctx);
int JS_IsArray(JSContext *ctx, JSValueConst val);

JSValue JS_GetPropertyInternal(JSContext *ctx, JSValueConst obj,
                               JSAtom prop, JSValueConst receiver,
                               JS_BOOL throw_ref_error);
static js_force_inline JSValue JS_GetProperty(JSContext *ctx, JSValueConst this_obj,
                                              JSAtom prop)
{
    return JS_GetPropertyInternal(ctx, this_obj, prop, this_obj, 0);
}
JSValue JS_GetPropertyStr(JSContext *ctx, JSValueConst this_obj,
                          const char *prop);
JSValue JS_GetPropertyUint32(JSContext *ctx, JSValueConst this_obj,
                             uint32_t idx);

int JS_SetPropertyInternal(JSContext *ctx, JSValueConst this_obj,
                           JSAtom prop, JSValue val,
                           int flags);
static inline int JS_SetProperty(JSContext *ctx, JSValueConst this_obj,
                                 JSAtom prop, JSValue val)
{
    return JS_SetPropertyInternal(ctx, this_obj, prop, val, JS_PROP_THROW);
}
int JS_SetPropertyUint32(JSContext *ctx, JSValueConst this_obj,
                         uint32_t idx, JSValue val);
int JS_SetPropertyInt64(JSContext *ctx, JSValueConst this_obj,
                        int64_t idx, JSValue val);
int JS_SetPropertyStr(JSContext *ctx, JSValueConst this_obj,
                      const char *prop, JSValue val);
int JS_HasProperty(JSContext *ctx, JSValueConst this_obj, JSAtom prop);
int JS_IsExtensible(JSContext *ctx, JSValueConst obj);
int JS_PreventExtensions(JSContext *ctx, JSValueConst obj);
int JS_DeleteProperty(JSContext *ctx, JSValueConst obj, JSAtom prop, int flags);
int JS_SetPrototype(JSContext *ctx, JSValueConst obj, JSValueConst proto_val);
JSValue JS_GetPrototype(JSContext *ctx, JSValueConst val);

#define JS_GPN_STRING_MASK  (1 << 0)
#define JS_GPN_SYMBOL_MASK  (1 << 1)
#define JS_GPN_PRIVATE_MASK (1 << 2)
/* only include the enumerable properties */
#define JS_GPN_ENUM_ONLY    (1 << 4)
/* set theJSPropertyEnum.is_enumerable field */
#define JS_GPN_SET_ENUM     (1 << 5)

int JS_GetOwnPropertyNames(JSContext *ctx, JSPropertyEnum **ptab,
                           uint32_t *plen, JSValueConst obj, int flags);
int JS_GetOwnProperty(JSContext *ctx, JSPropertyDescriptor *desc,
                      JSValueConst obj, JSAtom prop);

JSValue JS_Call(JSContext *ctx, JSValueConst func_obj, JSValueConst this_obj,
                int argc, JSValueConst *argv);
JSValue JS_Invoke(JSContext *ctx, JSValueConst this_val, JSAtom atom,
                  int argc, JSValueConst *argv);
JSValue JS_CallConstructor(JSContext *ctx, JSValueConst func_obj,
                           int argc, JSValueConst *argv);
JSValue JS_CallConstructor2(JSContext *ctx, JSValueConst func_obj,
                            JSValueConst new_target,
                            int argc, JSValueConst *argv);
JS_BOOL JS_DetectModule(const char *input, size_t input_len);
/* 'input' must be zero terminated i.e. input[input_len] = '\0'. */
JSValue JS_Eval(JSContext *ctx, const char *input, size_t input_len,
                const char *filename, int eval_flags);
/* same as JS_Eval() but with an explicit 'this_obj' parameter */
JSValue JS_EvalThis(JSContext *ctx, JSValueConst this_obj,
                    const char *input, size_t input_len,
                    const char *filename, int eval_flags);
JSValue JS_GetGlobalObject(JSContext *ctx);
int JS_IsInstanceOf(JSContext *ctx, JSValueConst val, JSValueConst obj);
int JS_DefineProperty(JSContext *ctx, JSValueConst this_obj,
                      JSAtom prop, JSValueConst val,
                      JSValueConst getter, JSValueConst setter, int flags);
int JS_DefinePropertyValue(JSContext *ctx, JSValueConst this_obj,
                           JSAtom prop, JSValue val, int flags);
int JS_DefinePropertyValueUint32(JSContext *ctx, JSValueConst this_obj,
                                 uint32_t idx, JSValue val, int flags);
int JS_DefinePropertyValueStr(JSContext *ctx, JSValueConst this_obj,
                              const char *prop, JSValue val, int flags);
int JS_DefinePropertyGetSet(JSContext *ctx, JSValueConst this_obj,
                            JSAtom prop, JSValue getter, JSValue setter,
                            int flags);
void JS_SetOpaque(JSValue obj, void *opaque);
void *JS_GetOpaque(JSValueConst obj, JSClassID class_id);
void *JS_GetOpaque2(JSContext *ctx, JSValueConst obj, JSClassID class_id);

/* 'buf' must be zero terminated i.e. buf[buf_len] = '\0'. */
JSValue JS_ParseJSON(JSContext *ctx, const char *buf, size_t buf_len,
                     const char *filename);
#define JS_PARSE_JSON_EXT (1 << 0) /* allow extended JSON */
JSValue JS_ParseJSON2(JSContext *ctx, const char *buf, size_t buf_len,
                      const char *filename, int flags);
JSValue JS_JSONStringify(JSContext *ctx, JSValueConst obj,
                         JSValueConst replacer, JSValueConst space0);

typedef void JSFreeArrayBufferDataFunc(JSRuntime *rt, void *opaque, void *ptr);
JSValue JS_NewArrayBuffer(JSContext *ctx, uint8_t *buf, size_t len,
                          JSFreeArrayBufferDataFunc *free_func, void *opaque,
                          JS_BOOL is_shared);
JSValue JS_NewArrayBufferCopy(JSContext *ctx, const uint8_t *buf, size_t len);
void JS_DetachArrayBuffer(JSContext *ctx, JSValueConst obj);
uint8_t *JS_GetArrayBuffer(JSContext *ctx, size_t *psize, JSValueConst obj);
JSValue JS_GetTypedArrayBuffer(JSContext *ctx, JSValueConst obj,
                               size_t *pbyte_offset,
                               size_t *pbyte_length,
                               size_t *pbytes_per_element);
typedef struct {
    void *(*sab_alloc)(void *opaque, size_t size);
    void (*sab_free)(void *opaque, void *ptr);
    void (*sab_dup)(void *opaque, void *ptr);
    void *sab_opaque;
} JSSharedArrayBufferFunctions;
void JS_SetSharedArrayBufferFunctions(JSRuntime *rt,
                                      const JSSharedArrayBufferFunctions *sf);

JSValue JS_NewPromiseCapability(JSContext *ctx, JSValue *resolving_funcs);

/* is_handled = TRUE means that the rejection is handled */
typedef void JSHostPromiseRejectionTracker(JSContext *ctx, JSValueConst promise,
                                           JSValueConst reason,
                                           JS_BOOL is_handled, void *opaque);
void JS_SetHostPromiseRejectionTracker(JSRuntime *rt, JSHostPromiseRejectionTracker *cb, void *opaque);

/* return != 0 if the JS code needs to be interrupted */
typedef int JSInterruptHandler(JSRuntime *rt, void *opaque);
void JS_SetInterruptHandler(JSRuntime *rt, JSInterruptHandler *cb, void *opaque);
/* if can_block is TRUE, Atomics.wait() can be used */
void JS_SetCanBlock(JSRuntime *rt, JS_BOOL can_block);
/* set the [IsHTMLDDA] internal slot */
void JS_SetIsHTMLDDA(JSContext *ctx, JSValueConst obj);

typedef struct JSModuleDef JSModuleDef;

/* return the module specifier (allocated with js_malloc()) or NULL if
   exception */
typedef char *JSModuleNormalizeFunc(JSContext *ctx,
                                    const char *module_base_name,
                                    const char *module_name, void *opaque);
typedef JSModuleDef *JSModuleLoaderFunc(JSContext *ctx,
                                        const char *module_name, void *opaque);

/* module_normalize = NULL is allowed and invokes the default module
   filename normalizer */
void JS_SetModuleLoaderFunc(JSRuntime *rt,
                            JSModuleNormalizeFunc *module_normalize,
                            JSModuleLoaderFunc *module_loader, void *opaque);
/* return the import.meta object of a module */
JSValue JS_GetImportMeta(JSContext *ctx, JSModuleDef *m);
JSAtom JS_GetModuleName(JSContext *ctx, JSModuleDef *m);

/* JS Job support */

typedef JSValue JSJobFunc(JSContext *ctx, int argc, JSValueConst *argv);
int JS_EnqueueJob(JSContext *ctx, JSJobFunc *job_func, int argc, JSValueConst *argv);

JS_BOOL JS_IsJobPending(JSRuntime *rt);
int JS_ExecutePendingJob(JSRuntime *rt, JSContext **pctx);

/* Object Writer/Reader (currently only used to handle precompiled code) */
#define JS_WRITE_OBJ_BYTECODE  (1 << 0) /* allow function/module */
#define JS_WRITE_OBJ_BSWAP     (1 << 1) /* byte swapped output */
#define JS_WRITE_OBJ_SAB       (1 << 2) /* allow SharedArrayBuffer */
#define JS_WRITE_OBJ_REFERENCE (1 << 3) /* allow object references to
                                           encode arbitrary object
                                           graph */
uint8_t *JS_WriteObject(JSContext *ctx, size_t *psize, JSValueConst obj,
                        int flags);
uint8_t *JS_WriteObject2(JSContext *ctx, size_t *psize, JSValueConst obj,
                         int flags, uint8_t ***psab_tab, size_t *psab_tab_len);

#define JS_READ_OBJ_BYTECODE  (1 << 0) /* allow function/module */
#define JS_READ_OBJ_ROM_DATA  (1 << 1) /* avoid duplicating 'buf' data */
#define JS_READ_OBJ_SAB       (1 << 2) /* allow SharedArrayBuffer */
#define JS_READ_OBJ_REFERENCE (1 << 3) /* allow object references */
JSValue JS_ReadObject(JSContext *ctx, const uint8_t *buf, size_t buf_len,
                      int flags);
/* instantiate and evaluate a bytecode function. Only used when
   reading a script or module with JS_ReadObject() */
JSValue JS_EvalFunction(JSContext *ctx, JSValue fun_obj);
/* load the dependencies of the module 'obj'. Useful when JS_ReadObject()
   returns a module. */
int JS_ResolveModule(JSContext *ctx, JSValueConst obj);

/* only exported for os.Worker() */
JSAtom JS_GetScriptOrModuleName(JSContext *ctx, int n_stack_levels);
/* only exported for os.Worker() */
JSModuleDef *JS_RunModule(JSContext *ctx, const char *basename,
                          const char *filename);

/* C function definition */
typedef enum JSCFunctionEnum {  /* XXX: should rename for namespace isolation */
    JS_CFUNC_generic,
    JS_CFUNC_generic_magic,
    JS_CFUNC_constructor,
    JS_CFUNC_constructor_magic,
    JS_CFUNC_constructor_or_func,
    JS_CFUNC_constructor_or_func_magic,
    JS_CFUNC_f_f,
    JS_CFUNC_f_f_f,
    JS_CFUNC_getter,
    JS_CFUNC_setter,
    JS_CFUNC_getter_magic,
    JS_CFUNC_setter_magic,
    JS_CFUNC_iterator_next,
} JSCFunctionEnum;

typedef union JSCFunctionType {
    JSCFunction *generic;
    JSValue (*generic_magic)(JSContext *ctx, JSValueConst this_val, int argc, JSValueConst *argv, int magic);
    JSCFunction *constructor;
    JSValue (*constructor_magic)(JSContext *ctx, JSValueConst new_target, int argc, JSValueConst *argv, int magic);
    JSCFunction *constructor_or_func;
    double (*f_f)(double);
    double (*f_f_f)(double, double);
    JSValue (*getter)(JSContext *ctx, JSValueConst this_val);
    JSValue (*setter)(JSContext *ctx, JSValueConst this_val, JSValueConst val);
    JSValue (*getter_magic)(JSContext *ctx, JSValueConst this_val, int magic);
    JSValue (*setter_magic)(JSContext *ctx, JSValueConst this_val, JSValueConst val, int magic);
    JSValue (*iterator_next)(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv, int *pdone, int magic);
} JSCFunctionType;

JSValue JS_NewCFunction2(JSContext *ctx, JSCFunction *func,
                         const char *name,
                         int length, JSCFunctionEnum cproto, int magic);
JSValue JS_NewCFunctionData(JSContext *ctx, JSCFunctionData *func,
                            int length, int magic, int data_len,
                            JSValueConst *data);

static inline JSValue JS_NewCFunction(JSContext *ctx, JSCFunction *func, const char *name,
                                      int length)
{
    return JS_NewCFunction2(ctx, func, name, length, JS_CFUNC_generic, 0);
}

static inline JSValue JS_NewCFunctionMagic(JSContext *ctx, JSCFunctionMagic *func,
                                           const char *name,
                                           int length, JSCFunctionEnum cproto, int magic)
{
    return JS_NewCFunction2(ctx, (JSCFunction *)func, name, length, cproto, magic);
}
void JS_SetConstructor(JSContext *ctx, JSValueConst func_obj, 
                       JSValueConst proto);

/* C property definition */

typedef struct JSCFunctionListEntry {
    const char *name;
    uint8_t prop_flags;
    uint8_t def_type;
    int16_t magic;
    union {
        struct {
            uint8_t length; /* XXX: should move outside union */
            uint8_t cproto; /* XXX: should move outside union */
            JSCFunctionType cfunc;
        } func;
        struct {
            JSCFunctionType get;
            JSCFunctionType set;
        } getset;
        struct {
            const char *name;
            int base;
        } alias;
        struct {
            const struct JSCFunctionListEntry *tab;
            int len;
        } prop_list;
        const char *str;
        int32_t i32;
        int64_t i64;
        double f64;
    } u;
} JSCFunctionListEntry;

#define JS_DEF_CFUNC          0
#define JS_DEF_CGETSET        1
#define JS_DEF_CGETSET_MAGIC  2
#define JS_DEF_PROP_STRING    3
#define JS_DEF_PROP_INT32     4
#define JS_DEF_PROP_INT64     5
#define JS_DEF_PROP_DOUBLE    6
#define JS_DEF_PROP_UNDEFINED 7
#define JS_DEF_OBJECT         8
#define JS_DEF_ALIAS          9

/* Note: c++ does not like nested designators */
#define JS_CFUNC_DEF(name, length, func1) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, 0, .u = { .func = { length, JS_CFUNC_generic, { .generic = func1 } } } }
#define JS_CFUNC_MAGIC_DEF(name, length, func1, magic) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, magic, .u = { .func = { length, JS_CFUNC_generic_magic, { .generic_magic = func1 } } } }
#define JS_CFUNC_SPECIAL_DEF(name, length, cproto, func1) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, 0, .u = { .func = { length, JS_CFUNC_ ## cproto, { .cproto = func1 } } } }
#define JS_ITERATOR_NEXT_DEF(name, length, func1, magic) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_CFUNC, magic, .u = { .func = { length, JS_CFUNC_iterator_next, { .iterator_next = func1 } } } }
#define JS_CGETSET_DEF(name, fgetter, fsetter) { name, JS_PROP_CONFIGURABLE, JS_DEF_CGETSET, 0, .u = { .getset = { .get = { .getter = fgetter }, .set = { .setter = fsetter } } } }
#define JS_CGETSET_MAGIC_DEF(name, fgetter, fsetter, magic) { name, JS_PROP_CONFIGURABLE, JS_DEF_CGETSET_MAGIC, magic, .u = { .getset = { .get = { .getter_magic = fgetter }, .set = { .setter_magic = fsetter } } } }
#define JS_PROP_STRING_DEF(name, cstr, prop_flags) { name, prop_flags, JS_DEF_PROP_STRING, 0, .u = { .str = cstr } }
#define JS_PROP_INT32_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_INT32, 0, .u = { .i32 = val } }
#define JS_PROP_INT64_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_INT64, 0, .u = { .i64 = val } }
#define JS_PROP_DOUBLE_DEF(name, val, prop_flags) { name, prop_flags, JS_DEF_PROP_DOUBLE, 0, .u = { .f64 = val } }
#define JS_PROP_UNDEFINED_DEF(name, prop_flags) { name, prop_flags, JS_DEF_PROP_UNDEFINED, 0, .u = { .i32 = 0 } }
#define JS_OBJECT_DEF(name, tab, len, prop_flags) { name, prop_flags, JS_DEF_OBJECT, 0, .u = { .prop_list = { tab, len } } }
#define JS_ALIAS_DEF(name, from) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_ALIAS, 0, .u = { .alias = { from, -1 } } }
#define JS_ALIAS_BASE_DEF(name, from, base) { name, JS_PROP_WRITABLE | JS_PROP_CONFIGURABLE, JS_DEF_ALIAS, 0, .u = { .alias = { from, base } } }

void JS_SetPropertyFunctionList(JSContext *ctx, JSValueConst obj,
                                const JSCFunctionListEntry *tab,
                                int len);

/* C module definition */

typedef int JSModuleInitFunc(JSContext *ctx, JSModuleDef *m);

JSModuleDef *JS_NewCModule(JSContext *ctx, const char *name_str,
                           JSModuleInitFunc *func);
/* can only be called before the module is instantiated */
int JS_AddModuleExport(JSContext *ctx, JSModuleDef *m, const char *name_str);
int JS_AddModuleExportList(JSContext *ctx, JSModuleDef *m,
                           const JSCFunctionListEntry *tab, int len);
/* can only be called after the module is instantiated */
int JS_SetModuleExport(JSContext *ctx, JSModuleDef *m, const char *export_name,
                       JSValue val);
int JS_SetModuleExportList(JSContext *ctx, JSModuleDef *m,
                           const JSCFunctionListEntry *tab, int len);

#undef js_unlikely
#undef js_force_inline

#ifdef __cplusplus
} /* extern "C" { */
#endif

#endif /* QUICKJS_H */

'''
'''--- readme.txt ---
The main documentation is in doc/quickjs.pdf or doc/quickjs.html.

'''
'''--- release.sh ---
#!/bin/sh
# Release the QuickJS source code

set -e

version=`cat VERSION`

if [ "$1" = "-h" ] ; then
    echo "release.sh [release_list]"
    echo ""
    echo "release_list: extras binary win_binary quickjs"
    
    exit 1
fi

release_list="extras binary win_binary quickjs"

if [ "$1" != "" ] ; then
    release_list="$1"
fi

#################################################"
# extras

if echo $release_list | grep -w -q extras ; then

d="quickjs-${version}"
name="quickjs-extras-${version}"
outdir="/tmp/${d}"

rm -rf $outdir
mkdir -p $outdir $outdir/unicode $outdir/tests 

cp unicode/* $outdir/unicode
cp -a tests/bench-v8 $outdir/tests

( cd /tmp && tar Jcvf /tmp/${name}.tar.xz ${d} )

fi

#################################################"
# Windows binary release

if echo $release_list | grep -w -q win_binary ; then

# win64

dlldir=/usr/x86_64-w64-mingw32/sys-root/mingw/bin
cross_prefix="x86_64-w64-mingw32-"
d="quickjs-win-x86_64-${version}"
outdir="/tmp/${d}"

rm -rf $outdir
mkdir -p $outdir

make CONFIG_WIN32=y qjs.exe
cp qjs.exe $outdir
${cross_prefix}strip $outdir/qjs.exe
cp $dlldir/libwinpthread-1.dll $outdir

( cd /tmp/$d && rm -f ../${d}.zip && zip -r ../${d}.zip . )

make CONFIG_WIN32=y clean

# win32

dlldir=/usr/i686-w64-mingw32/sys-root/mingw/bin
cross_prefix="i686-w64-mingw32-"
d="quickjs-win-i686-${version}"
outdir="/tmp/${d}"

rm -rf $outdir
mkdir -p $outdir

make clean
make CONFIG_WIN32=y clean

make CONFIG_WIN32=y CONFIG_M32=y qjs.exe
cp qjs.exe $outdir
${cross_prefix}strip $outdir/qjs.exe
cp $dlldir/libwinpthread-1.dll $outdir

( cd /tmp/$d && rm -f ../${d}.zip && zip -r ../${d}.zip . )

fi
    
#################################################"
# Linux binary release

if echo $release_list | grep -w -q binary ; then

make clean
make CONFIG_WIN32=y clean
make -j4 qjs run-test262
make -j4 CONFIG_M32=y qjs32 run-test262-32
strip qjs run-test262 qjs32 run-test262-32

d="quickjs-linux-x86_64-${version}"
outdir="/tmp/${d}"

rm -rf $outdir
mkdir -p $outdir

cp qjs run-test262 $outdir

( cd /tmp/$d && rm -f ../${d}.zip && zip -r ../${d}.zip . )

d="quickjs-linux-i686-${version}"
outdir="/tmp/${d}"

rm -rf $outdir
mkdir -p $outdir

cp qjs32 $outdir/qjs
cp run-test262-32 $outdir/run-test262

( cd /tmp/$d && rm -f ../${d}.zip && zip -r ../${d}.zip . )

fi

#################################################"
# quickjs

if echo $release_list | grep -w -q quickjs ; then

make build_doc

d="quickjs-${version}"
outdir="/tmp/${d}"

rm -rf $outdir
mkdir -p $outdir $outdir/doc $outdir/tests $outdir/examples

cp Makefile VERSION TODO Changelog readme.txt LICENSE \
   release.sh unicode_download.sh \
   qjs.c qjsc.c qjscalc.js repl.js \
   quickjs.c quickjs.h quickjs-atom.h \
   quickjs-libc.c quickjs-libc.h quickjs-opcode.h \
   cutils.c cutils.h list.h \
   libregexp.c libregexp.h libregexp-opcode.h \
   libunicode.c libunicode.h libunicode-table.h \
   libbf.c libbf.h \
   unicode_gen.c unicode_gen_def.h \
   run-test262.c test262o.conf test262.conf \
   test262o_errors.txt test262_errors.txt \
   $outdir

cp tests/*.js tests/*.patch tests/bjson.c $outdir/tests

cp examples/*.js examples/*.c $outdir/examples

cp doc/quickjs.texi doc/quickjs.pdf doc/quickjs.html \
   doc/jsbignum.texi doc/jsbignum.html doc/jsbignum.pdf \
   $outdir/doc 

( cd /tmp && tar Jcvf /tmp/${d}.tar.xz ${d} )

fi

'''
'''--- repl.js ---
/*
 * QuickJS Read Eval Print Loop
 * 
 * Copyright (c) 2017-2020 Fabrice Bellard
 * Copyright (c) 2017-2020 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
"use strip";

import * as std from "std";
import * as os from "os";

(function(g) {
    /* add 'os' and 'std' bindings */
    g.os = os;
    g.std = std;
    
    /* close global objects */
    var Object = g.Object;
    var String = g.String;
    var Array = g.Array;
    var Date = g.Date;
    var Math = g.Math;
    var isFinite = g.isFinite;
    var parseFloat = g.parseFloat;

    /* XXX: use preprocessor ? */
    var config_numcalc = (typeof os.open === "undefined");
    var has_jscalc = (typeof Fraction === "function");
    var has_bignum = (typeof BigFloat === "function");
    
    var colors = {
        none:    "\x1b[0m",
        black:   "\x1b[30m",
        red:     "\x1b[31m",
        green:   "\x1b[32m",
        yellow:  "\x1b[33m",
        blue:    "\x1b[34m",
        magenta: "\x1b[35m",
        cyan:    "\x1b[36m",
        white:   "\x1b[37m",
        gray:    "\x1b[30;1m",
        grey:    "\x1b[30;1m",
        bright_red:     "\x1b[31;1m",
        bright_green:   "\x1b[32;1m",
        bright_yellow:  "\x1b[33;1m",
        bright_blue:    "\x1b[34;1m",
        bright_magenta: "\x1b[35;1m",
        bright_cyan:    "\x1b[36;1m",
        bright_white:   "\x1b[37;1m",
    };

    var styles;
    if (config_numcalc) {
        styles = {
            'default':    'black',
            'comment':    'white',
            'string':     'green',
            'regex':      'cyan',
            'number':     'green',
            'keyword':    'blue',
            'function':   'gray',
            'type':       'bright_magenta',
            'identifier': 'yellow',
            'error':      'bright_red',
            'result':     'black',
            'error_msg':  'bright_red',
        };
    } else {
        styles = {
            'default':    'bright_green',
            'comment':    'white',
            'string':     'bright_cyan',
            'regex':      'cyan',
            'number':     'green',
            'keyword':    'bright_white',
            'function':   'bright_yellow',
            'type':       'bright_magenta',
            'identifier': 'bright_green',
            'error':      'red',
            'result':     'bright_white',
            'error_msg':  'bright_red',
        };
    }

    var history = [];
    var clip_board = "";
    var prec;
    var expBits;
    var log2_10;
    
    var pstate = "";
    var prompt = "";
    var plen = 0;
    var ps1;
    if (config_numcalc)
        ps1 = "> ";
    else
        ps1 = "qjs > ";
    var ps2 = "  ... ";
    var utf8 = true;
    var show_time = false;
    var show_colors = true;
    var eval_time = 0;
    
    var mexpr = "";
    var level = 0;
    var cmd = "";
    var cursor_pos = 0;
    var last_cmd = "";
    var last_cursor_pos = 0;
    var history_index;
    var this_fun, last_fun;
    var quote_flag = false;

    var utf8_state = 0;
    var utf8_val = 0;

    var term_fd;
    var term_read_buf;
    var term_width;
    /* current X position of the cursor in the terminal */
    var term_cursor_x = 0; 
    
    function termInit() {
        var tab;
        term_fd = std.in.fileno();
        
        /* get the terminal size */
        term_width = 80;
        if (os.isatty(term_fd)) {
            if (os.ttyGetWinSize) {
                tab = os.ttyGetWinSize(term_fd);
                if (tab)
                    term_width = tab[0];
            }
            if (os.ttySetRaw) {
                /* set the TTY to raw mode */
                os.ttySetRaw(term_fd);
            }
        }

        /* install a Ctrl-C signal handler */
        os.signal(os.SIGINT, sigint_handler);

        /* install a handler to read stdin */
        term_read_buf = new Uint8Array(64);
        os.setReadHandler(term_fd, term_read_handler);
    }

    function sigint_handler() {
        /* send Ctrl-C to readline */
        handle_byte(3);
    }
    
    function term_read_handler() {
        var l, i;
        l = os.read(term_fd, term_read_buf.buffer, 0, term_read_buf.length);
        for(i = 0; i < l; i++)
            handle_byte(term_read_buf[i]);
    }
    
    function handle_byte(c) {
        if (!utf8) {
            handle_char(c);
        } else if (utf8_state !== 0 && (c >= 0x80 && c < 0xc0)) {
            utf8_val = (utf8_val << 6) | (c & 0x3F);
            utf8_state--;
            if (utf8_state === 0) {
                handle_char(utf8_val);
            }
        } else if (c >= 0xc0 && c < 0xf8) {
            utf8_state = 1 + (c >= 0xe0) + (c >= 0xf0);
            utf8_val = c & ((1 << (6 - utf8_state)) - 1);
        } else {
            utf8_state = 0;
            handle_char(c);
        }
    }
    
    function is_alpha(c) {
        return typeof c === "string" &&
            ((c >= 'A' && c <= 'Z') || (c >= 'a' && c <= 'z'));
    }
    
    function is_digit(c) {
        return typeof c === "string" && (c >= '0' && c <= '9');
    }

    function is_word(c) {
        return typeof c === "string" &&
            (is_alpha(c) || is_digit(c) || c == '_' || c == '$');
    }

    function ucs_length(str) {
        var len, c, i, str_len = str.length;
        len = 0;
        /* we never count the trailing surrogate to have the
         following property: ucs_length(str) =
         ucs_length(str.substring(0, a)) + ucs_length(str.substring(a,
         str.length)) for 0 <= a <= str.length */
        for(i = 0; i < str_len; i++) {
            c = str.charCodeAt(i);
            if (c < 0xdc00 || c >= 0xe000)
                len++;
        }
        return len;
    }

    function is_trailing_surrogate(c)  {
        var d;
        if (typeof c !== "string")
            return false;
        d = c.codePointAt(0); /* can be NaN if empty string */
        return d >= 0xdc00 && d < 0xe000;
    }
    
    function is_balanced(a, b) {
        switch (a + b) {
        case "()":
        case "[]":
        case "{}":
            return true;
        }
        return false;
    }

    function print_color_text(str, start, style_names) {
        var i, j;
        for (j = start; j < str.length;) {
            var style = style_names[i = j];
            while (++j < str.length && style_names[j] == style)
                continue;
            std.puts(colors[styles[style] || 'default']);
            std.puts(str.substring(i, j));
            std.puts(colors['none']);
        }
    }

    function print_csi(n, code) {
        std.puts("\x1b[" + ((n != 1) ? n : "") + code);
    }

    /* XXX: handle double-width characters */
    function move_cursor(delta) {
        var i, l;
        if (delta > 0) {
            while (delta != 0) {
                if (term_cursor_x == (term_width - 1)) {
                    std.puts("\n"); /* translated to CRLF */
                    term_cursor_x = 0;
                    delta--;
                } else {
                    l = Math.min(term_width - 1 - term_cursor_x, delta);
                    print_csi(l, "C"); /* right */
                    delta -= l; 
                    term_cursor_x += l;
                }
            }
        } else {
            delta = -delta;
            while (delta != 0) {
                if (term_cursor_x == 0) {
                    print_csi(1, "A"); /* up */
                    print_csi(term_width - 1, "C"); /* right */
                    delta--;
                    term_cursor_x = term_width - 1;
                } else {
                    l = Math.min(delta, term_cursor_x);
                    print_csi(l, "D"); /* left */
                    delta -= l;
                    term_cursor_x -= l;
                }
            }
        }
    }

    function update() {
        var i, cmd_len;
        /* cursor_pos is the position in 16 bit characters inside the
           UTF-16 string 'cmd' */
        if (cmd != last_cmd) {
            if (!show_colors && last_cmd.substring(0, last_cursor_pos) == cmd.substring(0, last_cursor_pos)) {
                /* optimize common case */
                std.puts(cmd.substring(last_cursor_pos));
            } else {
                /* goto the start of the line */
                move_cursor(-ucs_length(last_cmd.substring(0, last_cursor_pos)));
                if (show_colors) {
                    var str = mexpr ? mexpr + '\n' + cmd : cmd;
                    var start = str.length - cmd.length;
                    var colorstate = colorize_js(str);
                    print_color_text(str, start, colorstate[2]);
                } else {
                    std.puts(cmd);
                }
            }
            term_cursor_x = (term_cursor_x + ucs_length(cmd)) % term_width;
            if (term_cursor_x == 0) {
                /* show the cursor on the next line */
                std.puts(" \x08");
            }
            /* remove the trailing characters */
            std.puts("\x1b[J");
            last_cmd = cmd;
            last_cursor_pos = cmd.length;
        }
        if (cursor_pos > last_cursor_pos) {
            move_cursor(ucs_length(cmd.substring(last_cursor_pos, cursor_pos)));
        } else if (cursor_pos < last_cursor_pos) {
            move_cursor(-ucs_length(cmd.substring(cursor_pos, last_cursor_pos)));
        }
        last_cursor_pos = cursor_pos;
        std.out.flush();
    }

    /* editing commands */
    function insert(str) {
        if (str) {
            cmd = cmd.substring(0, cursor_pos) + str + cmd.substring(cursor_pos);
            cursor_pos += str.length;
        }
    }

    function quoted_insert() {
        quote_flag = true;
    }

    function abort() {
        cmd = "";
        cursor_pos = 0;
        return -2;
    }

    function alert() {
    }

    function beginning_of_line() {
        cursor_pos = 0;
    }

    function end_of_line() {
        cursor_pos = cmd.length;
    }

    function forward_char() {
        if (cursor_pos < cmd.length) {
            cursor_pos++;
            while (is_trailing_surrogate(cmd.charAt(cursor_pos)))
                cursor_pos++;
        }
    }

    function backward_char() {
        if (cursor_pos > 0) {
            cursor_pos--;
            while (is_trailing_surrogate(cmd.charAt(cursor_pos)))
                cursor_pos--;
        }
    }

    function skip_word_forward(pos) {
        while (pos < cmd.length && !is_word(cmd.charAt(pos)))
            pos++;
        while (pos < cmd.length && is_word(cmd.charAt(pos)))
            pos++;
        return pos;
    }

    function skip_word_backward(pos) {
        while (pos > 0 && !is_word(cmd.charAt(pos - 1)))
            pos--;
        while (pos > 0 && is_word(cmd.charAt(pos - 1)))
            pos--;
        return pos;
    }

    function forward_word() {
        cursor_pos = skip_word_forward(cursor_pos);
    }

    function backward_word() {
        cursor_pos = skip_word_backward(cursor_pos);
    }        

    function accept_line() {
        std.puts("\n");
        history_add(cmd);
        return -1;
    }

    function history_add(str) {
        if (str) {
            history.push(str);
        }
        history_index = history.length;
    }

    function previous_history() {
        if (history_index > 0) {
            if (history_index == history.length) {
                history.push(cmd);
            }
            history_index--;
            cmd = history[history_index];
            cursor_pos = cmd.length;
        }
    }

    function next_history() {
        if (history_index < history.length - 1) {
            history_index++;
            cmd = history[history_index];
            cursor_pos = cmd.length;
        }
    }

    function history_search(dir) {
        var pos = cursor_pos;
        for (var i = 1; i <= history.length; i++) {
            var index = (history.length + i * dir + history_index) % history.length;
            if (history[index].substring(0, pos) == cmd.substring(0, pos)) {
                history_index = index;
                cmd = history[index];
                return;
            }
        }
    }

    function history_search_backward() {
        return history_search(-1);
    }

    function history_search_forward() {
        return history_search(1);
    }

    function delete_char_dir(dir) {
        var start, end;

        start = cursor_pos;
        if (dir < 0) {
            start--;
            while (is_trailing_surrogate(cmd.charAt(start)))
                start--;
        }
        end = start + 1;
        while (is_trailing_surrogate(cmd.charAt(end)))
            end++;

        if (start >= 0 && start < cmd.length) {
            if (last_fun === kill_region) {
                kill_region(start, end, dir);
            } else {
                cmd = cmd.substring(0, start) + cmd.substring(end);
                cursor_pos = start;
            }
        }
    }

    function delete_char() {
        delete_char_dir(1);
    }

    function control_d() {
        if (cmd.length == 0) {
            std.puts("\n");
            return -3; /* exit read eval print loop */
        } else {
            delete_char_dir(1);
        }
    }

    function backward_delete_char() {
        delete_char_dir(-1);
    }

    function transpose_chars() {
        var pos = cursor_pos;
        if (cmd.length > 1 && pos > 0) {
            if (pos == cmd.length)
                pos--;
            cmd = cmd.substring(0, pos - 1) + cmd.substring(pos, pos + 1) +
                cmd.substring(pos - 1, pos) + cmd.substring(pos + 1);
            cursor_pos = pos + 1;
        }
    }

    function transpose_words() {
        var p1 = skip_word_backward(cursor_pos);
        var p2 = skip_word_forward(p1);
        var p4 = skip_word_forward(cursor_pos);
        var p3 = skip_word_backward(p4);

        if (p1 < p2 && p2 <= cursor_pos && cursor_pos <= p3 && p3 < p4) {
            cmd = cmd.substring(0, p1) + cmd.substring(p3, p4) +
            cmd.substring(p2, p3) + cmd.substring(p1, p2);
            cursor_pos = p4;
        }
    }

    function upcase_word() {
        var end = skip_word_forward(cursor_pos);
        cmd = cmd.substring(0, cursor_pos) +
            cmd.substring(cursor_pos, end).toUpperCase() +
            cmd.substring(end);
    }

    function downcase_word() {
        var end = skip_word_forward(cursor_pos);
        cmd = cmd.substring(0, cursor_pos) +
            cmd.substring(cursor_pos, end).toLowerCase() +
            cmd.substring(end);
    }

    function kill_region(start, end, dir) {
        var s = cmd.substring(start, end);
        if (last_fun !== kill_region)
            clip_board = s;
        else if (dir < 0)
            clip_board = s + clip_board;
        else
            clip_board = clip_board + s;

        cmd = cmd.substring(0, start) + cmd.substring(end);
        if (cursor_pos > end)
            cursor_pos -= end - start;
        else if (cursor_pos > start)
            cursor_pos = start;
        this_fun = kill_region;
    }

    function kill_line() {
        kill_region(cursor_pos, cmd.length, 1);
    }

    function backward_kill_line() {
        kill_region(0, cursor_pos, -1);
    }

    function kill_word() {
        kill_region(cursor_pos, skip_word_forward(cursor_pos), 1);
    }

    function backward_kill_word() {
        kill_region(skip_word_backward(cursor_pos), cursor_pos, -1);
    }

    function yank() {
        insert(clip_board);
    }

    function control_c() {
        if (last_fun === control_c) {
            std.puts("\n");
            std.exit(0);
        } else {
            std.puts("\n(Press Ctrl-C again to quit)\n");
            readline_print_prompt();
        }
    }
    
    function reset() {
        cmd = "";
        cursor_pos = 0;
    }

    function get_context_word(line, pos) {
        var s = "";
        while (pos > 0 && is_word(line[pos - 1])) {
            pos--;
            s = line[pos] + s;
        }
        return s;
    }
    function get_context_object(line, pos) {
        var obj, base, c;
        if (pos <= 0 || " ~!%^&*(-+={[|:;,<>?/".indexOf(line[pos - 1]) >= 0)
            return g;
        if (pos >= 2 && line[pos - 1] === ".") {
            pos--;
            obj = {};
            switch (c = line[pos - 1]) {
            case '\'':
            case '\"':
                return "a";
            case ']':
                return [];
            case '}':
                return {};
            case '/':
                return / /;
            default:
                if (is_word(c)) {
                    base = get_context_word(line, pos);
                    if (["true", "false", "null", "this"].includes(base) || !isNaN(+base))
                        return eval(base);
                    obj = get_context_object(line, pos - base.length);
                    if (obj === null || obj === void 0)
                        return obj;
                    if (obj === g && obj[base] === void 0)
                        return eval(base);
                    else
                        return obj[base];
                }
                return {};
            }
        }
        return void 0;
    }

    function get_completions(line, pos) {
        var s, obj, ctx_obj, r, i, j, paren;

        s = get_context_word(line, pos);
        ctx_obj = get_context_object(line, pos - s.length);
        r = [];
        /* enumerate properties from object and its prototype chain,
           add non-numeric regular properties with s as e prefix
         */
        for (i = 0, obj = ctx_obj; i < 10 && obj !== null && obj !== void 0; i++) {
            var props = Object.getOwnPropertyNames(obj);
            /* add non-numeric regular properties */
            for (j = 0; j < props.length; j++) {
                var prop = props[j];
                if (typeof prop == "string" && ""+(+prop) != prop && prop.startsWith(s))
                    r.push(prop);
            }
            obj = Object.getPrototypeOf(obj);
        }
        if (r.length > 1) {
            /* sort list with internal names last and remove duplicates */
            function symcmp(a, b) {
                if (a[0] != b[0]) {
                    if (a[0] == '_')
                        return 1;
                    if (b[0] == '_')
                        return -1;
                }
                if (a < b)
                    return -1;
                if (a > b)
                    return +1;
                return 0;
            }
            r.sort(symcmp);
            for(i = j = 1; i < r.length; i++) {
                if (r[i] != r[i - 1])
                    r[j++] = r[i];
            }
            r.length = j;
        }
        /* 'tab' = list of completions, 'pos' = cursor position inside
           the completions */
        return { tab: r, pos: s.length, ctx: ctx_obj };
    }

    function completion() {
        var tab, res, s, i, j, len, t, max_width, col, n_cols, row, n_rows;
        res = get_completions(cmd, cursor_pos);
        tab = res.tab;
        if (tab.length === 0)
            return;
        s = tab[0];
        len = s.length;
        /* add the chars which are identical in all the completions */
        for(i = 1; i < tab.length; i++) {
            t = tab[i];
            for(j = 0; j < len; j++) {
                if (t[j] !== s[j]) {
                    len = j;
                    break;
                }
            }
        }
        for(i = res.pos; i < len; i++) {
            insert(s[i]);
        }
        if (last_fun === completion && tab.length == 1) {
            /* append parentheses to function names */
            var m = res.ctx[tab[0]];
            if (typeof m == "function") {
                insert('(');
                if (m.length == 0)
                    insert(')');
            } else if (typeof m == "object") {
                insert('.');
            }
        }
        /* show the possible completions */
        if (last_fun === completion && tab.length >= 2) {
            max_width = 0;
            for(i = 0; i < tab.length; i++)
                max_width = Math.max(max_width, tab[i].length);
            max_width += 2;
            n_cols = Math.max(1, Math.floor((term_width + 1) / max_width));
            n_rows = Math.ceil(tab.length / n_cols);
            std.puts("\n");
            /* display the sorted list column-wise */
            for (row = 0; row < n_rows; row++) {
                for (col = 0; col < n_cols; col++) {
                    i = col * n_rows + row;
                    if (i >= tab.length)
                        break;
                    s = tab[i];
                    if (col != n_cols - 1)
                        s = s.padEnd(max_width);
                    std.puts(s);
                }
                std.puts("\n");
            }
            /* show a new prompt */
            readline_print_prompt();
        }
    }
    
    var commands = {        /* command table */
        "\x01":     beginning_of_line,      /* ^A - bol */
        "\x02":     backward_char,          /* ^B - backward-char */
        "\x03":     control_c,              /* ^C - abort */
        "\x04":     control_d,              /* ^D - delete-char or exit */
        "\x05":     end_of_line,            /* ^E - eol */
        "\x06":     forward_char,           /* ^F - forward-char */
        "\x07":     abort,                  /* ^G - bell */
        "\x08":     backward_delete_char,   /* ^H - backspace */
        "\x09":     completion,             /* ^I - history-search-backward */
        "\x0a":     accept_line,            /* ^J - newline */
        "\x0b":     kill_line,              /* ^K - delete to end of line */
        "\x0d":     accept_line,            /* ^M - enter */
        "\x0e":     next_history,           /* ^N - down */
        "\x10":     previous_history,       /* ^P - up */
        "\x11":     quoted_insert,          /* ^Q - quoted-insert */
        "\x12":     alert,                  /* ^R - reverse-search */
        "\x13":     alert,                  /* ^S - search */
        "\x14":     transpose_chars,        /* ^T - transpose */
        "\x18":     reset,                  /* ^X - cancel */
        "\x19":     yank,                   /* ^Y - yank */
        "\x1bOA":   previous_history,       /* ^[OA - up */
        "\x1bOB":   next_history,           /* ^[OB - down */
        "\x1bOC":   forward_char,           /* ^[OC - right */
        "\x1bOD":   backward_char,          /* ^[OD - left */
        "\x1bOF":   forward_word,           /* ^[OF - ctrl-right */
        "\x1bOH":   backward_word,          /* ^[OH - ctrl-left */
        "\x1b[1;5C": forward_word,          /* ^[[1;5C - ctrl-right */
        "\x1b[1;5D": backward_word,         /* ^[[1;5D - ctrl-left */
        "\x1b[1~":  beginning_of_line,      /* ^[[1~ - bol */
        "\x1b[3~":  delete_char,            /* ^[[3~ - delete */
        "\x1b[4~":  end_of_line,            /* ^[[4~ - eol */
        "\x1b[5~":  history_search_backward,/* ^[[5~ - page up */
        "\x1b[6~":  history_search_forward, /* ^[[5~ - page down */
        "\x1b[A":   previous_history,       /* ^[[A - up */
        "\x1b[B":   next_history,           /* ^[[B - down */
        "\x1b[C":   forward_char,           /* ^[[C - right */
        "\x1b[D":   backward_char,          /* ^[[D - left */
        "\x1b[F":   end_of_line,            /* ^[[F - end */
        "\x1b[H":   beginning_of_line,      /* ^[[H - home */
        "\x1b\x7f": backward_kill_word,     /* M-C-? - backward_kill_word */
        "\x1bb":    backward_word,          /* M-b - backward_word */
        "\x1bd":    kill_word,              /* M-d - kill_word */
        "\x1bf":    forward_word,           /* M-f - backward_word */
        "\x1bk":    backward_kill_line,     /* M-k - backward_kill_line */
        "\x1bl":    downcase_word,          /* M-l - downcase_word */
        "\x1bt":    transpose_words,        /* M-t - transpose_words */
        "\x1bu":    upcase_word,            /* M-u - upcase_word */
        "\x7f":     backward_delete_char,   /* ^? - delete */
    };

    function dupstr(str, count) {
        var res = "";
        while (count-- > 0)
            res += str;
        return res;
    }

    var readline_keys;
    var readline_state;
    var readline_cb;

    function readline_print_prompt()
    {
        std.puts(prompt);
        term_cursor_x = ucs_length(prompt) % term_width;
        last_cmd = "";
        last_cursor_pos = 0;
    }

    function readline_start(defstr, cb) {
        cmd = defstr || "";
        cursor_pos = cmd.length;
        history_index = history.length;
        readline_cb = cb;
        
        prompt = pstate;
    
        if (mexpr) {
            prompt += dupstr(" ", plen - prompt.length);
            prompt += ps2;
        } else {
            if (show_time) {
                var t = Math.round(eval_time) + " ";
                eval_time = 0;
                t = dupstr("0", 5 - t.length) + t;
                prompt += t.substring(0, t.length - 4) + "." + t.substring(t.length - 4);
            }
            plen = prompt.length;
            prompt += ps1;
        }
        readline_print_prompt();
        update();
        readline_state = 0;
    }

    function handle_char(c1) {
        var c;
        c = String.fromCodePoint(c1);
        switch(readline_state) {
        case 0:
            if (c == '\x1b') {  /* '^[' - ESC */
                readline_keys = c;
                readline_state = 1;
            } else {
                handle_key(c);
            }
            break;
        case 1: /* '^[ */
            readline_keys += c;
            if (c == '[') {
                readline_state = 2;
            } else if (c == 'O') {
                readline_state = 3;
            } else {
                handle_key(readline_keys);
                readline_state = 0;
            }
            break;
        case 2: /* '^[[' - CSI */
            readline_keys += c;
            if (!(c == ';' || (c >= '0' && c <= '9'))) {
                handle_key(readline_keys);
                readline_state = 0;
            }
            break;
        case 3: /* '^[O' - ESC2 */
            readline_keys += c;
            handle_key(readline_keys);
            readline_state = 0;
            break;
        }
    }

    function handle_key(keys) {
        var fun;

        if (quote_flag) {
            if (ucs_length(keys) === 1)
                insert(keys);
            quote_flag = false;
        } else if (fun = commands[keys]) {
            this_fun = fun;
            switch (fun(keys)) {
            case -1:
                readline_cb(cmd);
                return;
            case -2:
                readline_cb(null);
                return;
            case -3:
                /* uninstall a Ctrl-C signal handler */
                os.signal(os.SIGINT, null);
                /* uninstall the stdin read handler */
                os.setReadHandler(term_fd, null);
                return;
            }
            last_fun = this_fun;
        } else if (ucs_length(keys) === 1 && keys >= ' ') {
            insert(keys);
            last_fun = insert;
        } else {
            alert(); /* beep! */
        }
        
        cursor_pos = (cursor_pos < 0) ? 0 :
            (cursor_pos > cmd.length) ? cmd.length : cursor_pos;
        update();
    }

    var hex_mode = false;
    var eval_mode = "std";

    function number_to_string(a, radix) {
        var s;
        if (!isFinite(a)) {
            /* NaN, Infinite */
            return a.toString();
        } else {
            if (a == 0) {
                if (1 / a < 0)
                    s = "-0";
                else
                    s = "0";
            } else {
                if (radix == 16 && a === Math.floor(a)) {
                    var s;
                    if (a < 0) {
                        a = -a;
                        s = "-";
                    } else {
                        s = "";
                    }
                    s += "0x" + a.toString(16);
                } else {
                    s = a.toString();
                }
            }
            return s;
        }
    }

    function bigfloat_to_string(a, radix) {
        var s;
        if (!BigFloat.isFinite(a)) {
            /* NaN, Infinite */
            if (eval_mode !== "math") {
                return "BigFloat(" + a.toString() + ")";
            } else {
                return a.toString();
            }
        } else {
            if (a == 0) {
                if (1 / a < 0)
                    s = "-0";
                else
                    s = "0";
            } else {
                if (radix == 16) {
                    var s;
                    if (a < 0) {
                        a = -a;
                        s = "-";
                    } else {
                        s = "";
                    }
                    s += "0x" + a.toString(16);
                } else {
                    s = a.toString();
                }
            }
            if (typeof a === "bigfloat" && eval_mode !== "math") {
                s += "l";
            } else if (eval_mode !== "std" && s.indexOf(".") < 0 &&
                ((radix == 16 && s.indexOf("p") < 0) ||
                 (radix == 10 && s.indexOf("e") < 0))) {
                /* add a decimal point so that the floating point type
                   is visible */
                s += ".0";
            }
            return s;
        }
    }

    function bigint_to_string(a, radix) {
        var s;
        if (radix == 16) {
            var s;
            if (a < 0) {
                a = -a;
                s = "-";
            } else {
                s = "";
            }
            s += "0x" + a.toString(16);
        } else {
            s = a.toString();
        }
        if (eval_mode === "std")
            s += "n";
        return s;
    }
    
    function print(a) {
        var stack = [];

        function print_rec(a) {
            var n, i, keys, key, type, s;
            
            type = typeof(a);
            if (type === "object") {
                if (a === null) {
                    std.puts(a);
                } else if (stack.indexOf(a) >= 0) {
                    std.puts("[circular]");
                } else if (has_jscalc && (a instanceof Fraction ||
                                        a instanceof Complex ||
                                        a instanceof Mod ||
                                        a instanceof Polynomial ||
                                        a instanceof PolyMod ||
                                        a instanceof RationalFunction ||
                                        a instanceof Series)) {
                    std.puts(a.toString());
                } else {
                    stack.push(a);
                    if (Array.isArray(a)) {
                        n = a.length;
                        std.puts("[ ");
                        for(i = 0; i < n; i++) {
                            if (i !== 0)
                                std.puts(", ");
                            if (i in a) {
                                print_rec(a[i]);
                            } else {
                                std.puts("<empty>");
                            }
                            if (i > 20) {
                                std.puts("...");
                                break;
                            }
                        }
                        std.puts(" ]");
                    } else if (Object.__getClass(a) === "RegExp") {
                        std.puts(a.toString());
                    } else {
                        keys = Object.keys(a);
                        n = keys.length;
                        std.puts("{ ");
                        for(i = 0; i < n; i++) {
                            if (i !== 0)
                                std.puts(", ");
                            key = keys[i];
                            std.puts(key, ": ");
                            print_rec(a[key]);
                        }
                        std.puts(" }");
                    }
                    stack.pop(a);
                }
            } else if (type === "string") {
                s = a.__quote();
                if (s.length > 79)
                    s = s.substring(0, 75) + "...\"";
                std.puts(s);
            } else if (type === "number") {
                std.puts(number_to_string(a, hex_mode ? 16 : 10));
            } else if (type === "bigint") {
                std.puts(bigint_to_string(a, hex_mode ? 16 : 10));
            } else if (type === "bigfloat") {
                std.puts(bigfloat_to_string(a, hex_mode ? 16 : 10));
            } else if (type === "bigdecimal") {
                std.puts(a.toString() + "m");
            } else if (type === "symbol") {
                std.puts(String(a));
            } else if (type === "function") {
                std.puts("function " + a.name + "()");
            } else {
                std.puts(a);
            }
        }
        print_rec(a);
    }
    
    function extract_directive(a) {
        var pos;
        if (a[0] !== '\\')
            return "";
        for (pos = 1; pos < a.length; pos++) {
            if (!is_alpha(a[pos]))
                break;
        }
        return a.substring(1, pos);
    }

    /* return true if the string after cmd can be evaluted as JS */
    function handle_directive(cmd, expr) {
        var param, prec1, expBits1;
        
        if (cmd === "h" || cmd === "?" || cmd == "help") {
            help();
        } else if (cmd === "load") {
            var filename = expr.substring(cmd.length + 1).trim();
            if (filename.lastIndexOf(".") <= filename.lastIndexOf("/"))
                filename += ".js";
            std.loadScript(filename);
            return false;
        } else if (cmd === "x") {
            hex_mode = true;
        } else if (cmd === "d") {
            hex_mode = false;
        } else if (cmd === "t") {
            show_time = !show_time;
        } else if (has_bignum && cmd === "p") {
            param = expr.substring(cmd.length + 1).trim().split(" ");
            if (param.length === 1 && param[0] === "") {
                std.puts("BigFloat precision=" + prec + " bits (~" +
                          Math.floor(prec / log2_10) +
                          " digits), exponent size=" + expBits + " bits\n");
            } else if (param[0] === "f16") {
                prec = 11;
                expBits = 5;
            } else if (param[0] === "f32") {
                prec = 24;
                expBits = 8;
            } else if (param[0] === "f64") {
                prec = 53;
                expBits = 11;
            } else if (param[0] === "f128") {
                prec = 113;
                expBits = 15;
            } else {
                prec1 = parseInt(param[0]);
                if (param.length >= 2)
                    expBits1 = parseInt(param[1]);
                else
                    expBits1 = BigFloatEnv.expBitsMax;
                if (Number.isNaN(prec1) ||
                    prec1 < BigFloatEnv.precMin ||
                    prec1 > BigFloatEnv.precMax) {
                    std.puts("Invalid precision\n");
                    return false;
                }
                if (Number.isNaN(expBits1) ||
                    expBits1 < BigFloatEnv.expBitsMin ||
                    expBits1 > BigFloatEnv.expBitsMax) {
                    std.puts("Invalid exponent bits\n");
                    return false;
                }
                prec = prec1;
                expBits = expBits1;
            }
            return false;
        } else if (has_bignum && cmd === "digits") {
            param = expr.substring(cmd.length + 1).trim();
            prec1 = Math.ceil(parseFloat(param) * log2_10);
            if (prec1 < BigFloatEnv.precMin ||
                prec1 > BigFloatEnv.precMax) {
                std.puts("Invalid precision\n");
                return false;
            }
            prec = prec1;
            expBits = BigFloatEnv.expBitsMax;
            return false;
        } else if (has_bignum && cmd === "mode") {
            param = expr.substring(cmd.length + 1).trim();
            if (param === "") {
                std.puts("Running mode=" + eval_mode + "\n");
            } else if (param === "std" || param === "math") {
                eval_mode = param;
            } else {
                std.puts("Invalid mode\n");
            }
            return false;
        } else if (cmd === "clear") {
            std.puts("\x1b[H\x1b[J");
        } else if (cmd === "q") {
            std.exit(0);
        } else if (has_jscalc && cmd === "a") {
            algebraicMode = true;
        } else if (has_jscalc && cmd === "n") {
            algebraicMode = false;
        } else {
            std.puts("Unknown directive: " + cmd + "\n");
            return false;
        }
        return true;
    }

    if (config_numcalc) {
        /* called by the GUI */
        g.execCmd = function (cmd) {
            switch(cmd) {
            case "dec":
                hex_mode = false;
                break;
            case "hex":
                hex_mode = true;
                break;
            case "num":
                algebraicMode = false;
                break;
            case "alg":
                algebraicMode = true;
                break;
            }
        }
    }
    
    function help() {
        function sel(n) {
            return n ? "*": " ";
        }
        std.puts("\\h          this help\n" +
                 "\\x         " + sel(hex_mode) + "hexadecimal number display\n" +
                 "\\d         " + sel(!hex_mode) + "decimal number display\n" +
                 "\\t         " + sel(show_time) + "toggle timing display\n" +
                  "\\clear      clear the terminal\n");
        if (has_jscalc) {
            std.puts("\\a         " + sel(algebraicMode) + "algebraic mode\n" +
                     "\\n         " + sel(!algebraicMode) + "numeric mode\n");
        }
        if (has_bignum) {
            std.puts("\\p [m [e]]  set the BigFloat precision to 'm' bits\n" +
                     "\\digits n   set the BigFloat precision to 'ceil(n*log2(10))' bits\n");
            if (!has_jscalc) {
                std.puts("\\mode [std|math] change the running mode (current = " + eval_mode + ")\n");
            }
        }
        if (!config_numcalc) {
            std.puts("\\q          exit\n");
        }
    }

    function eval_and_print(expr) {
        var result;
        
        try {
            if (eval_mode === "math")
                expr = '"use math"; void 0;' + expr;
            var now = (new Date).getTime();
            /* eval as a script */
            result = std.evalScript(expr, { backtrace_barrier: true });
            eval_time = (new Date).getTime() - now;
            std.puts(colors[styles.result]);
            print(result);
            std.puts("\n");
            std.puts(colors.none);
            /* set the last result */
            g._ = result;
        } catch (error) {
            std.puts(colors[styles.error_msg]);
            if (error instanceof Error) {
                console.log(error);
                if (error.stack) {
                    std.puts(error.stack);
                }
            } else {
                std.puts("Throw: ");
                console.log(error);
            }
            std.puts(colors.none);
        }
    }

    function cmd_start() {
        if (!config_numcalc) {
            if (has_jscalc)
                std.puts('QJSCalc - Type "\\h" for help\n');
            else
                std.puts('QuickJS - Type "\\h" for help\n');
        }
        if (has_bignum) {
            log2_10 = Math.log(10) / Math.log(2);
            prec = 113;
            expBits = 15;
            if (has_jscalc) {
                eval_mode = "math";
                /* XXX: numeric mode should always be the default ? */
                g.algebraicMode = config_numcalc;
            }
        }

        cmd_readline_start();
    }

    function cmd_readline_start() {
        readline_start(dupstr("    ", level), readline_handle_cmd);
    }
    
    function readline_handle_cmd(expr) {
        handle_cmd(expr);
        cmd_readline_start();
    }

    function handle_cmd(expr) {
        var colorstate, cmd;
        
        if (expr === null) {
            expr = "";
            return;
        }
        if (expr === "?") {
            help();
            return;
        }
        cmd = extract_directive(expr);
        if (cmd.length > 0) {
            if (!handle_directive(cmd, expr))
                return;
            expr = expr.substring(cmd.length + 1);
        }
        if (expr === "")
            return;
        
        if (mexpr)
            expr = mexpr + '\n' + expr;
        colorstate = colorize_js(expr);
        pstate = colorstate[0];
        level = colorstate[1];
        if (pstate) {
            mexpr = expr;
            return;
        }
        mexpr = "";
        
        if (has_bignum) {
            BigFloatEnv.setPrec(eval_and_print.bind(null, expr),
                                prec, expBits);
        } else {
            eval_and_print(expr);
        }
        level = 0;
        
        /* run the garbage collector after each command */
        std.gc();
    }

    function colorize_js(str) {
        var i, c, start, n = str.length;
        var style, state = "", level = 0;
        var primary, can_regex = 1;
        var r = [];

        function push_state(c) { state += c; }
        function last_state(c) { return state.substring(state.length - 1); }
        function pop_state(c) {
            var c = last_state();
            state = state.substring(0, state.length - 1);
            return c;
        }

        function parse_block_comment() {
            style = 'comment';
            push_state('/');
            for (i++; i < n - 1; i++) {
                if (str[i] == '*' && str[i + 1] == '/') {
                    i += 2;
                    pop_state('/');
                    break;
                }
            }
        }

        function parse_line_comment() {
            style = 'comment';
            for (i++; i < n; i++) {
                if (str[i] == '\n') {
                    break;
                }
            }
        }

        function parse_string(delim) {
            style = 'string';
            push_state(delim);
            while (i < n) {
                c = str[i++];
                if (c == '\n') {
                    style = 'error';
                    continue;
                }
                if (c == '\\') {
                    if (i >= n)
                        break;
                    i++;
                } else
                if (c == delim) {
                    pop_state();
                    break;
                }
            }
        }

        function parse_regex() {
            style = 'regex';
            push_state('/');
            while (i < n) {
                c = str[i++];
                if (c == '\n') {
                    style = 'error';
                    continue;
                }
                if (c == '\\') {
                    if (i < n) {
                        i++;
                    }
                    continue;
                }
                if (last_state() == '[') {
                    if (c == ']') {
                        pop_state()
                    }
                    // ECMA 5: ignore '/' inside char classes
                    continue;
                }
                if (c == '[') {
                    push_state('[');
                    if (str[i] == '[' || str[i] == ']')
                        i++;
                    continue;
                }
                if (c == '/') {
                    pop_state();
                    while (i < n && is_word(str[i]))
                        i++;
                    break;
                }
            }
        }

        function parse_number() {
            style = 'number';
            while (i < n && (is_word(str[i]) || (str[i] == '.' && (i == n - 1 || str[i + 1] != '.')))) {
                i++;
            }
        }

        var js_keywords = "|" +
            "break|case|catch|continue|debugger|default|delete|do|" +
            "else|finally|for|function|if|in|instanceof|new|" +
            "return|switch|this|throw|try|typeof|while|with|" +
            "class|const|enum|import|export|extends|super|" +
            "implements|interface|let|package|private|protected|" +
            "public|static|yield|" +
            "undefined|null|true|false|Infinity|NaN|" +
            "eval|arguments|" +
            "await|";

        var js_no_regex = "|this|super|undefined|null|true|false|Infinity|NaN|arguments|";
        var js_types = "|void|var|";

        function parse_identifier() {
            can_regex = 1;

            while (i < n && is_word(str[i]))
                i++;

            var w = '|' + str.substring(start, i) + '|';

            if (js_keywords.indexOf(w) >= 0) {
                style = 'keyword';
                if (js_no_regex.indexOf(w) >= 0)
                    can_regex = 0;
                return;
            }

            var i1 = i;
            while (i1 < n && str[i1] == ' ')
                i1++;

            if (i1 < n && str[i1] == '(') {
                style = 'function';
                return;
            }

            if (js_types.indexOf(w) >= 0) {
                style = 'type';
                return;
            }

            style = 'identifier';
            can_regex = 0;
        }

        function set_style(from, to) {
            while (r.length < from)
                r.push('default');
            while (r.length < to)
                r.push(style);
        }

        for (i = 0; i < n;) {
            style = null;
            start = i;
            switch (c = str[i++]) {
            case ' ':
            case '\t':
            case '\r':
            case '\n':
                continue;
            case '+':
            case '-':
                if (i < n && str[i] == c) {
                    i++;
                    continue;
                }
                can_regex = 1;
                continue;
            case '/':
                if (i < n && str[i] == '*') { // block comment
                    parse_block_comment();
                    break;
                }
                if (i < n && str[i] == '/') { // line comment
                    parse_line_comment();
                    break;
                }
                if (can_regex) {
                    parse_regex();
                    can_regex = 0;
                    break;
                }
                can_regex = 1;
                continue;
            case '\'':
            case '\"':
            case '`':
                parse_string(c);
                can_regex = 0;
                break;
            case '(':
            case '[':
            case '{':
                can_regex = 1;
                level++;
                push_state(c);
                continue;
            case ')':
            case ']':
            case '}':
                can_regex = 0;
                if (level > 0 && is_balanced(last_state(), c)) {
                    level--;
                    pop_state();
                    continue;
                }
                style = 'error';
                break;
            default:
                if (is_digit(c)) {
                    parse_number();
                    can_regex = 0;
                    break;
                }
                if (is_word(c) || c == '$') {
                    parse_identifier();
                    break;
                }
                can_regex = 1;
                continue;
            }
            if (style)
                set_style(start, i);
        }
        set_style(n, n);
        return [ state, level, r ];
    }

    termInit();
    
    cmd_start();

})(globalThis);

'''
'''--- run-test262.c ---
/*
 * ECMA Test 262 Runner for QuickJS
 * 
 * Copyright (c) 2017-2021 Fabrice Bellard
 * Copyright (c) 2017-2021 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <inttypes.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <unistd.h>
#include <errno.h>
#include <time.h>
#include <dirent.h>
#include <ftw.h>

#include "cutils.h"
#include "list.h"
#include "quickjs-libc.h"

/* enable test262 thread support to test SharedArrayBuffer and Atomics */
#define CONFIG_AGENT

#define CMD_NAME "run-test262"

typedef struct namelist_t {
    char **array;
    int count;
    int size;
    unsigned int sorted : 1;
} namelist_t;

namelist_t test_list;
namelist_t exclude_list;
namelist_t exclude_dir_list;

FILE *outfile;
enum test_mode_t {
    TEST_DEFAULT_NOSTRICT, /* run tests as nostrict unless test is flagged as strictonly */
    TEST_DEFAULT_STRICT,   /* run tests as strict unless test is flagged as nostrict */
    TEST_NOSTRICT,         /* run tests as nostrict, skip strictonly tests */
    TEST_STRICT,           /* run tests as strict, skip nostrict tests */
    TEST_ALL,              /* run tests in both strict and nostrict, unless restricted by spec */
} test_mode = TEST_DEFAULT_NOSTRICT;
int skip_async;
int skip_module;
int new_style;
int dump_memory;
int stats_count;
JSMemoryUsage stats_all, stats_avg, stats_min, stats_max;
char *stats_min_filename;
char *stats_max_filename;
int verbose;
char *harness_dir;
char *harness_exclude;
char *harness_features;
char *harness_skip_features;
char *error_filename;
char *error_file;
FILE *error_out;
char *report_filename;
int update_errors;
int test_count, test_failed, test_index, test_skipped, test_excluded;
int new_errors, changed_errors, fixed_errors;
int async_done;

void warning(const char *, ...) __attribute__((__format__(__printf__, 1, 2)));
void fatal(int, const char *, ...) __attribute__((__format__(__printf__, 2, 3)));

void warning(const char *fmt, ...)
{
    va_list ap;

    fflush(stdout);
    fprintf(stderr, "%s: ", CMD_NAME);
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
    fputc('\n', stderr);
}

void fatal(int errcode, const char *fmt, ...)
{
    va_list ap;

    fflush(stdout);
    fprintf(stderr, "%s: ", CMD_NAME);
    va_start(ap, fmt);
    vfprintf(stderr, fmt, ap);
    va_end(ap);
    fputc('\n', stderr);

    exit(errcode);
}

void perror_exit(int errcode, const char *s)
{
    fflush(stdout);
    fprintf(stderr, "%s: ", CMD_NAME);
    perror(s);
    exit(errcode);
}

char *strdup_len(const char *str, int len)
{
    char *p = malloc(len + 1);
    memcpy(p, str, len);
    p[len] = '\0';
    return p;
}

static inline int str_equal(const char *a, const char *b) {
    return !strcmp(a, b);
}

char *str_append(char **pp, const char *sep, const char *str) {
    char *res, *p;
    size_t len = 0;
    p = *pp;
    if (p) {
        len = strlen(p) + strlen(sep);
    }
    res = malloc(len + strlen(str) + 1);
    if (p) {
        strcpy(res, p);
        strcat(res, sep);
    }
    strcpy(res + len, str);
    free(p);
    return *pp = res;
}

char *str_strip(char *p)
{
    size_t len = strlen(p);
    while (len > 0 && isspace((unsigned char)p[len - 1]))
        p[--len] = '\0';
    while (isspace((unsigned char)*p))
        p++;
    return p;
}

int has_prefix(const char *str, const char *prefix)
{
    return !strncmp(str, prefix, strlen(prefix));
}

char *skip_prefix(const char *str, const char *prefix)
{
    int i;
    for (i = 0;; i++) {
        if (prefix[i] == '\0') {  /* skip the prefix */
            str += i;
            break;
        }
        if (str[i] != prefix[i])
            break;
    }
    return (char *)str;
}

char *get_basename(const char *filename)
{
    char *p;

    p = strrchr(filename, '/');
    if (!p)
        return NULL;
    return strdup_len(filename, p - filename);
}

char *compose_path(const char *path, const char *name)
{
    int path_len, name_len;
    char *d, *q;

    if (!path || path[0] == '\0' || *name == '/') {
        d = strdup(name);
    } else {
        path_len = strlen(path);
        name_len = strlen(name);
        d = malloc(path_len + 1 + name_len + 1);
        if (d) {
            q = d;
            memcpy(q, path, path_len);
            q += path_len;
            if (path[path_len - 1] != '/')
                *q++ = '/';
            memcpy(q, name, name_len + 1);
        }
    }
    return d;
}

int namelist_cmp(const char *a, const char *b)
{
    /* compare strings in modified lexicographical order */
    for (;;) {
        int ca = (unsigned char)*a++;
        int cb = (unsigned char)*b++;
        if (isdigit(ca) && isdigit(cb)) {
            int na = ca - '0';
            int nb = cb - '0';
            while (isdigit(ca = (unsigned char)*a++))
                na = na * 10 + ca - '0';
            while (isdigit(cb = (unsigned char)*b++))
                nb = nb * 10 + cb - '0';
            if (na < nb)
                return -1;
            if (na > nb)
                return +1;
        }
        if (ca < cb)
            return -1;
        if (ca > cb)
            return +1;
        if (ca == '\0')
            return 0;
    }
}

int namelist_cmp_indirect(const void *a, const void *b)
{
    return namelist_cmp(*(const char **)a, *(const char **)b);
}

void namelist_sort(namelist_t *lp)
{
    int i, count;
    if (lp->count > 1) {
        qsort(lp->array, lp->count, sizeof(*lp->array), namelist_cmp_indirect);
        /* remove duplicates */
        for (count = i = 1; i < lp->count; i++) {
            if (namelist_cmp(lp->array[count - 1], lp->array[i]) == 0) {
                free(lp->array[i]);
            } else {
                lp->array[count++] = lp->array[i];
            }
        }
        lp->count = count;
    }
    lp->sorted = 1;
}

int namelist_find(namelist_t *lp, const char *name)
{
    int a, b, m, cmp;

    if (!lp->sorted) {
        namelist_sort(lp);
    }
    for (a = 0, b = lp->count; a < b;) {
        m = a + (b - a) / 2;
        cmp = namelist_cmp(lp->array[m], name);
        if (cmp < 0)
            a = m + 1;
        else if (cmp > 0)
            b = m;
        else
            return m;
    }
    return -1;
}

void namelist_add(namelist_t *lp, const char *base, const char *name)
{
    char *s;

    s = compose_path(base, name);
    if (!s)
        goto fail;
    if (lp->count == lp->size) {
        size_t newsize = lp->size + (lp->size >> 1) + 4;
        char **a = realloc(lp->array, sizeof(lp->array[0]) * newsize);
        if (!a)
            goto fail;
        lp->array = a;
        lp->size = newsize;
    }
    lp->array[lp->count] = s;
    lp->count++;
    return;
fail:
    fatal(1, "allocation failure\n");
}

void namelist_load(namelist_t *lp, const char *filename)
{
    char buf[1024];
    char *base_name;
    FILE *f;

    f = fopen(filename, "rb");
    if (!f) {
        perror_exit(1, filename);
    }
    base_name = get_basename(filename);

    while (fgets(buf, sizeof(buf), f) != NULL) {
        char *p = str_strip(buf);
        if (*p == '#' || *p == ';' || *p == '\0')
            continue;  /* line comment */
        
        namelist_add(lp, base_name, p);
    }
    free(base_name);
    fclose(f);
}

void namelist_add_from_error_file(namelist_t *lp, const char *file)
{
    const char *p, *p0;
    char *pp;

    for (p = file; (p = strstr(p, ".js:")) != NULL; p++) {
        for (p0 = p; p0 > file && p0[-1] != '\n'; p0--)
            continue;
        pp = strdup_len(p0, p + 3 - p0);
        namelist_add(lp, NULL, pp);
        free(pp);
    }
}

void namelist_free(namelist_t *lp)
{
    while (lp->count > 0) {
        free(lp->array[--lp->count]);
    }
    free(lp->array);
    lp->array = NULL;
    lp->size = 0;
}

static int add_test_file(const char *filename, const struct stat *ptr, int flag)
{
    namelist_t *lp = &test_list;
    if (has_suffix(filename, ".js") && !has_suffix(filename, "_FIXTURE.js"))
        namelist_add(lp, NULL, filename);
    return 0;
}

/* find js files from the directory tree and sort the list */
static void enumerate_tests(const char *path)
{
    namelist_t *lp = &test_list;
    int start = lp->count;
    ftw(path, add_test_file, 100);
    qsort(lp->array + start, lp->count - start, sizeof(*lp->array),
          namelist_cmp_indirect);
}

static JSValue js_print(JSContext *ctx, JSValueConst this_val,
                        int argc, JSValueConst *argv)
{
    int i;
    const char *str;

    if (outfile) {
        for (i = 0; i < argc; i++) {
            if (i != 0)
                fputc(' ', outfile);
            str = JS_ToCString(ctx, argv[i]);
            if (!str)
                return JS_EXCEPTION;
            if (!strcmp(str, "Test262:AsyncTestComplete")) {
                async_done++;
            } else if (strstart(str, "Test262:AsyncTestFailure", NULL)) {
                async_done = 2; /* force an error */
            }
            fputs(str, outfile);
            JS_FreeCString(ctx, str);
        }
        fputc('\n', outfile);
    }
    return JS_UNDEFINED;
}

static JSValue js_detachArrayBuffer(JSContext *ctx, JSValue this_val,
                                    int argc, JSValue *argv)
{
    JS_DetachArrayBuffer(ctx, argv[0]);
    return JS_UNDEFINED;
}

static JSValue js_evalScript(JSContext *ctx, JSValue this_val,
                             int argc, JSValue *argv)
{
    const char *str;
    size_t len;
    JSValue ret;
    str = JS_ToCStringLen(ctx, &len, argv[0]);
    if (!str)
        return JS_EXCEPTION;
    ret = JS_Eval(ctx, str, len, "<evalScript>", JS_EVAL_TYPE_GLOBAL);
    JS_FreeCString(ctx, str);
    return ret;
}

#ifdef CONFIG_AGENT

#include <pthread.h>

typedef struct {
    struct list_head link;
    pthread_t tid;
    char *script;
    JSValue broadcast_func;
    BOOL broadcast_pending;
    JSValue broadcast_sab; /* in the main context */
    uint8_t *broadcast_sab_buf;
    size_t broadcast_sab_size;
    int32_t broadcast_val;
} Test262Agent;

typedef struct {
    struct list_head link;
    char *str;
} AgentReport;

static JSValue add_helpers1(JSContext *ctx);
static void add_helpers(JSContext *ctx);

static pthread_mutex_t agent_mutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t agent_cond = PTHREAD_COND_INITIALIZER;
/* list of Test262Agent.link */
static struct list_head agent_list = LIST_HEAD_INIT(agent_list);

static pthread_mutex_t report_mutex = PTHREAD_MUTEX_INITIALIZER;
/* list of AgentReport.link */
static struct list_head report_list = LIST_HEAD_INIT(report_list);

static void *agent_start(void *arg)
{
    Test262Agent *agent = arg;
    JSRuntime *rt;
    JSContext *ctx;
    JSValue ret_val;
    int ret;
    
    rt = JS_NewRuntime();
    if (rt == NULL) {
        fatal(1, "JS_NewRuntime failure");
    }        
    ctx = JS_NewContext(rt);
    if (ctx == NULL) {
        JS_FreeRuntime(rt);
        fatal(1, "JS_NewContext failure");
    }
    JS_SetContextOpaque(ctx, agent);
    JS_SetRuntimeInfo(rt, "agent");
    JS_SetCanBlock(rt, TRUE);
    
    add_helpers(ctx);
    ret_val = JS_Eval(ctx, agent->script, strlen(agent->script),
                      "<evalScript>", JS_EVAL_TYPE_GLOBAL);
    free(agent->script);
    agent->script = NULL;
    if (JS_IsException(ret_val))
        js_std_dump_error(ctx);
    JS_FreeValue(ctx, ret_val);
    
    for(;;) {
        JSContext *ctx1;
        ret = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);
        if (ret < 0) {
            js_std_dump_error(ctx);
            break;
        } else if (ret == 0) {
            if (JS_IsUndefined(agent->broadcast_func)) {
                break;
            } else {
                JSValue args[2];
                
                pthread_mutex_lock(&agent_mutex);
                while (!agent->broadcast_pending) {
                    pthread_cond_wait(&agent_cond, &agent_mutex);
                }
                
                agent->broadcast_pending = FALSE;
                pthread_cond_signal(&agent_cond);

                pthread_mutex_unlock(&agent_mutex);

                args[0] = JS_NewArrayBuffer(ctx, agent->broadcast_sab_buf,
                                            agent->broadcast_sab_size,
                                            NULL, NULL, TRUE);
                args[1] = JS_NewInt32(ctx, agent->broadcast_val);
                ret_val = JS_Call(ctx, agent->broadcast_func, JS_UNDEFINED,
                                  2, (JSValueConst *)args);
                JS_FreeValue(ctx, args[0]);
                JS_FreeValue(ctx, args[1]);
                if (JS_IsException(ret_val))
                    js_std_dump_error(ctx);
                JS_FreeValue(ctx, ret_val);
                JS_FreeValue(ctx, agent->broadcast_func);
                agent->broadcast_func = JS_UNDEFINED;
            }
        }
    }
    JS_FreeValue(ctx, agent->broadcast_func);

    JS_FreeContext(ctx);
    JS_FreeRuntime(rt);
    return NULL;
}

static JSValue js_agent_start(JSContext *ctx, JSValue this_val,
                              int argc, JSValue *argv)
{
    const char *script;
    Test262Agent *agent;

    if (JS_GetContextOpaque(ctx) != NULL)
        return JS_ThrowTypeError(ctx, "cannot be called inside an agent");
    
    script = JS_ToCString(ctx, argv[0]);
    if (!script)
        return JS_EXCEPTION;
    agent = malloc(sizeof(*agent));
    memset(agent, 0, sizeof(*agent));
    agent->broadcast_func = JS_UNDEFINED;
    agent->broadcast_sab = JS_UNDEFINED;
    agent->script = strdup(script);
    JS_FreeCString(ctx, script);
    list_add_tail(&agent->link, &agent_list);
    pthread_create(&agent->tid, NULL, agent_start, agent);
    return JS_UNDEFINED;
}

static void js_agent_free(JSContext *ctx)
{
    struct list_head *el, *el1;
    Test262Agent *agent;
    
    list_for_each_safe(el, el1, &agent_list) {
        agent = list_entry(el, Test262Agent, link);
        pthread_join(agent->tid, NULL);
        JS_FreeValue(ctx, agent->broadcast_sab);
        list_del(&agent->link);
        free(agent);
    }
}
 
static JSValue js_agent_leaving(JSContext *ctx, JSValue this_val,
                                int argc, JSValue *argv)
{
    Test262Agent *agent = JS_GetContextOpaque(ctx);
    if (!agent)
        return JS_ThrowTypeError(ctx, "must be called inside an agent");
    /* nothing to do */
    return JS_UNDEFINED;
}

static BOOL is_broadcast_pending(void)
{
    struct list_head *el;
    Test262Agent *agent;
    list_for_each(el, &agent_list) {
        agent = list_entry(el, Test262Agent, link);
        if (agent->broadcast_pending)
            return TRUE;
    }
    return FALSE;
}

static JSValue js_agent_broadcast(JSContext *ctx, JSValue this_val,
                                  int argc, JSValue *argv)
{
    JSValueConst sab = argv[0];
    struct list_head *el;
    Test262Agent *agent;
    uint8_t *buf;
    size_t buf_size;
    int32_t val;
    
    if (JS_GetContextOpaque(ctx) != NULL)
        return JS_ThrowTypeError(ctx, "cannot be called inside an agent");
    
    buf = JS_GetArrayBuffer(ctx, &buf_size, sab);
    if (!buf)
        return JS_EXCEPTION;
    if (JS_ToInt32(ctx, &val, argv[1]))
        return JS_EXCEPTION;
    
    /* broadcast the values and wait until all agents have started
       calling their callbacks */
    pthread_mutex_lock(&agent_mutex);
    list_for_each(el, &agent_list) {
        agent = list_entry(el, Test262Agent, link);
        agent->broadcast_pending = TRUE;
        /* the shared array buffer is used by the thread, so increment
           its refcount */
        agent->broadcast_sab = JS_DupValue(ctx, sab);
        agent->broadcast_sab_buf = buf;
        agent->broadcast_sab_size = buf_size;
        agent->broadcast_val = val;
    }
    pthread_cond_broadcast(&agent_cond);

    while (is_broadcast_pending()) {
        pthread_cond_wait(&agent_cond, &agent_mutex);
    }
    pthread_mutex_unlock(&agent_mutex);
    return JS_UNDEFINED;
}

static JSValue js_agent_receiveBroadcast(JSContext *ctx, JSValue this_val,
                                         int argc, JSValue *argv)
{
    Test262Agent *agent = JS_GetContextOpaque(ctx);
    if (!agent)
        return JS_ThrowTypeError(ctx, "must be called inside an agent");
    if (!JS_IsFunction(ctx, argv[0]))
        return JS_ThrowTypeError(ctx, "expecting function");
    JS_FreeValue(ctx, agent->broadcast_func);
    agent->broadcast_func = JS_DupValue(ctx, argv[0]);
    return JS_UNDEFINED;
}

static JSValue js_agent_sleep(JSContext *ctx, JSValue this_val,
                              int argc, JSValue *argv)
{
    uint32_t duration;
    if (JS_ToUint32(ctx, &duration, argv[0]))
        return JS_EXCEPTION;
    usleep(duration * 1000);
    return JS_UNDEFINED;
}

static int64_t get_clock_ms(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (uint64_t)ts.tv_sec * 1000 + (ts.tv_nsec / 1000000);
}

static JSValue js_agent_monotonicNow(JSContext *ctx, JSValue this_val,
                                     int argc, JSValue *argv)
{
    return JS_NewInt64(ctx, get_clock_ms());
}

static JSValue js_agent_getReport(JSContext *ctx, JSValue this_val,
                                  int argc, JSValue *argv)
{
    AgentReport *rep;
    JSValue ret;

    pthread_mutex_lock(&report_mutex);
    if (list_empty(&report_list)) {
        rep = NULL;
    } else {
        rep = list_entry(report_list.next, AgentReport, link);
        list_del(&rep->link);
    }
    pthread_mutex_unlock(&report_mutex);
    if (rep) {
        ret = JS_NewString(ctx, rep->str);
        free(rep->str);
        free(rep);
    } else {
        ret = JS_NULL;
    }
    return ret;
}

static JSValue js_agent_report(JSContext *ctx, JSValue this_val,
                               int argc, JSValue *argv)
{
    const char *str;
    AgentReport *rep;

    str = JS_ToCString(ctx, argv[0]);
    if (!str)
        return JS_EXCEPTION;
    rep = malloc(sizeof(*rep));
    rep->str = strdup(str);
    JS_FreeCString(ctx, str);
    
    pthread_mutex_lock(&report_mutex);
    list_add_tail(&rep->link, &report_list);
    pthread_mutex_unlock(&report_mutex);
    return JS_UNDEFINED;
}

static const JSCFunctionListEntry js_agent_funcs[] = {
    /* only in main */
    JS_CFUNC_DEF("start", 1, js_agent_start ),
    JS_CFUNC_DEF("getReport", 0, js_agent_getReport ),
    JS_CFUNC_DEF("broadcast", 2, js_agent_broadcast ),
    /* only in agent */
    JS_CFUNC_DEF("report", 1, js_agent_report ),
    JS_CFUNC_DEF("leaving", 0, js_agent_leaving ),
    JS_CFUNC_DEF("receiveBroadcast", 1, js_agent_receiveBroadcast ),
    /* in both */
    JS_CFUNC_DEF("sleep", 1, js_agent_sleep ),
    JS_CFUNC_DEF("monotonicNow", 0, js_agent_monotonicNow ),
};
    
static JSValue js_new_agent(JSContext *ctx)
{
    JSValue agent;
    agent = JS_NewObject(ctx);
    JS_SetPropertyFunctionList(ctx, agent, js_agent_funcs,
                               countof(js_agent_funcs));
    return agent;
}
#endif

static JSValue js_createRealm(JSContext *ctx, JSValue this_val,
                              int argc, JSValue *argv)
{
    JSContext *ctx1;
    JSValue ret;
    
    ctx1 = JS_NewContext(JS_GetRuntime(ctx));
    if (!ctx1)
        return JS_ThrowOutOfMemory(ctx);
    ret = add_helpers1(ctx1);
    /* ctx1 has a refcount so it stays alive */
    JS_FreeContext(ctx1);
    return ret;
}

static JSValue js_IsHTMLDDA(JSContext *ctx, JSValue this_val,
                            int argc, JSValue *argv)
{
    return JS_NULL;
}

static JSValue add_helpers1(JSContext *ctx)
{
    JSValue global_obj;
    JSValue obj262, obj;
    
    global_obj = JS_GetGlobalObject(ctx);

    JS_SetPropertyStr(ctx, global_obj, "print",
                      JS_NewCFunction(ctx, js_print, "print", 1));

    /* $262 special object used by the tests */
    obj262 = JS_NewObject(ctx);
    JS_SetPropertyStr(ctx, obj262, "detachArrayBuffer",
                      JS_NewCFunction(ctx, js_detachArrayBuffer,
                                      "detachArrayBuffer", 1));
    JS_SetPropertyStr(ctx, obj262, "evalScript",
                      JS_NewCFunction(ctx, js_evalScript,
                                      "evalScript", 1));
    JS_SetPropertyStr(ctx, obj262, "codePointRange",
                      JS_NewCFunction(ctx, js_string_codePointRange,
                                      "codePointRange", 2));
#ifdef CONFIG_AGENT
    JS_SetPropertyStr(ctx, obj262, "agent", js_new_agent(ctx));
#endif

    JS_SetPropertyStr(ctx, obj262, "global",
                      JS_DupValue(ctx, global_obj));
    JS_SetPropertyStr(ctx, obj262, "createRealm",
                      JS_NewCFunction(ctx, js_createRealm,
                                      "createRealm", 0));
    obj = JS_NewCFunction(ctx, js_IsHTMLDDA, "IsHTMLDDA", 0);
    JS_SetIsHTMLDDA(ctx, obj);
    JS_SetPropertyStr(ctx, obj262, "IsHTMLDDA", obj);

    JS_SetPropertyStr(ctx, global_obj, "$262", JS_DupValue(ctx, obj262));
    
    JS_FreeValue(ctx, global_obj);
    return obj262;
}

static void add_helpers(JSContext *ctx)
{
    JS_FreeValue(ctx, add_helpers1(ctx));
}

static char *load_file(const char *filename, size_t *lenp)
{
    char *buf;
    size_t buf_len;
    buf = (char *)js_load_file(NULL, &buf_len, filename);
    if (!buf)
        perror_exit(1, filename);
    if (lenp)
        *lenp = buf_len;
    return buf;
}

static JSModuleDef *js_module_loader_test(JSContext *ctx,
                                          const char *module_name, void *opaque)
{
    size_t buf_len;
    uint8_t *buf;
    JSModuleDef *m;
    JSValue func_val;
    
    buf = js_load_file(ctx, &buf_len, module_name);
    if (!buf) {
        JS_ThrowReferenceError(ctx, "could not load module filename '%s'",
                               module_name);
        return NULL;
    }
    
    /* compile the module */
    func_val = JS_Eval(ctx, (char *)buf, buf_len, module_name,
                       JS_EVAL_TYPE_MODULE | JS_EVAL_FLAG_COMPILE_ONLY);
    js_free(ctx, buf);
    if (JS_IsException(func_val))
        return NULL;
    /* the module is already referenced, so we must free it */
    m = JS_VALUE_GET_PTR(func_val);
    JS_FreeValue(ctx, func_val);
    return m;
}

int is_line_sep(char c)
{
    return (c == '\0' || c == '\n' || c == '\r');
}

char *find_line(const char *str, const char *line)
{
    if (str) {
        const char *p;
        int len = strlen(line);
        for (p = str; (p = strstr(p, line)) != NULL; p += len + 1) {
            if ((p == str || is_line_sep(p[-1])) && is_line_sep(p[len]))
                return (char *)p;
        }
    }
    return NULL;
}

int is_word_sep(char c)
{
    return (c == '\0' || isspace((unsigned char)c) || c == ',');
}

char *find_word(const char *str, const char *word)
{
    const char *p;
    int len = strlen(word);
    if (str && len) {
        for (p = str; (p = strstr(p, word)) != NULL; p += len) {
            if ((p == str || is_word_sep(p[-1])) && is_word_sep(p[len]))
                return (char *)p;
        }
    }
    return NULL;
}

/* handle exclude directories */
void update_exclude_dirs(void)
{
    namelist_t *lp = &test_list;
    namelist_t *ep = &exclude_list;
    namelist_t *dp = &exclude_dir_list;
    char *name;
    int i, j, count;

    /* split directpries from exclude_list */
    for (count = i = 0; i < ep->count; i++) {
        name = ep->array[i];
        if (has_suffix(name, "/")) {
            namelist_add(dp, NULL, name);
            free(name);
        } else {
            ep->array[count++] = name;
        }
    }
    ep->count = count;

    namelist_sort(dp);

    /* filter out excluded directories */
    for (count = i = 0; i < lp->count; i++) {
        name = lp->array[i];
        for (j = 0; j < dp->count; j++) {
            if (has_prefix(name, dp->array[j])) {
                test_excluded++;
                free(name);
                name = NULL;
                break;
            }
        }
        if (name) {
            lp->array[count++] = name;
        }
    }
    lp->count = count;
}

void load_config(const char *filename)
{
    char buf[1024];
    FILE *f;
    char *base_name;
    enum {
        SECTION_NONE = 0,
        SECTION_CONFIG,
        SECTION_EXCLUDE,
        SECTION_FEATURES,
        SECTION_TESTS,
    } section = SECTION_NONE;
    int lineno = 0;

    f = fopen(filename, "rb");
    if (!f) {
        perror_exit(1, filename);
    }
    base_name = get_basename(filename);
    
    while (fgets(buf, sizeof(buf), f) != NULL) {
        char *p, *q;
        lineno++;
        p = str_strip(buf);
        if (*p == '#' || *p == ';' || *p == '\0')
            continue;  /* line comment */
        
        if (*p == "[]"[0]) {
            /* new section */
            p++;
            p[strcspn(p, "]")] = '\0';
            if (str_equal(p, "config"))
                section = SECTION_CONFIG;
            else if (str_equal(p, "exclude"))
                section = SECTION_EXCLUDE;
            else if (str_equal(p, "features"))
                section = SECTION_FEATURES;
            else if (str_equal(p, "tests"))
                section = SECTION_TESTS;
            else
                section = SECTION_NONE;
            continue;
        }
        q = strchr(p, '=');
        if (q) {
            /* setting: name=value */
            *q++ = '\0';
            q = str_strip(q);
        }
        switch (section) {
        case SECTION_CONFIG:
            if (!q) {
                printf("%s:%d: syntax error\n", filename, lineno);
                continue;
            }
            if (str_equal(p, "style")) {
                new_style = str_equal(q, "new");
                continue;
            }
            if (str_equal(p, "testdir")) {
                char *testdir = compose_path(base_name, q);
                enumerate_tests(testdir);
                free(testdir);
                continue;
            }
            if (str_equal(p, "harnessdir")) {
                harness_dir = compose_path(base_name, q);
                continue;
            }
            if (str_equal(p, "harnessexclude")) {
                str_append(&harness_exclude, " ", q);
                continue;
            }
            if (str_equal(p, "features")) {
                str_append(&harness_features, " ", q);
                continue;
            }
            if (str_equal(p, "skip-features")) {
                str_append(&harness_skip_features, " ", q);
                continue;
            }
            if (str_equal(p, "mode")) {
                if (str_equal(q, "default") || str_equal(q, "default-nostrict"))
                    test_mode = TEST_DEFAULT_NOSTRICT;
                else if (str_equal(q, "default-strict"))
                    test_mode = TEST_DEFAULT_STRICT;
                else if (str_equal(q, "nostrict"))
                    test_mode = TEST_NOSTRICT;
                else if (str_equal(q, "strict"))
                    test_mode = TEST_STRICT;
                else if (str_equal(q, "all") || str_equal(q, "both"))
                    test_mode = TEST_ALL;
                else 
                    fatal(2, "unknown test mode: %s", q);
                continue;
            }
            if (str_equal(p, "strict")) {
                if (str_equal(q, "skip") || str_equal(q, "no"))
                    test_mode = TEST_NOSTRICT;
                continue;
            }
            if (str_equal(p, "nostrict")) {
                if (str_equal(q, "skip") || str_equal(q, "no"))
                    test_mode = TEST_STRICT;
                continue;
            }
            if (str_equal(p, "async")) {
                skip_async = !str_equal(q, "yes");
                continue;
            }
            if (str_equal(p, "module")) {
                skip_module = !str_equal(q, "yes");
                continue;
            }
            if (str_equal(p, "verbose")) {
                verbose = str_equal(q, "yes");
                continue;
            }
            if (str_equal(p, "errorfile")) {
                error_filename = compose_path(base_name, q);
                continue;
            }
            if (str_equal(p, "excludefile")) {
                char *path = compose_path(base_name, q);
                namelist_load(&exclude_list, path);
                free(path);
                continue;
            }
            if (str_equal(p, "reportfile")) {
                report_filename = compose_path(base_name, q);
                continue;
            }
        case SECTION_EXCLUDE:
            namelist_add(&exclude_list, base_name, p);
            break;
        case SECTION_FEATURES:
            if (!q || str_equal(q, "yes"))
                str_append(&harness_features, " ", p);
            else
                str_append(&harness_skip_features, " ", p);
            break;
        case SECTION_TESTS:
            namelist_add(&test_list, base_name, p);
            break;
        default:
            /* ignore settings in other sections */
            break;
        }
    }
    fclose(f);
    free(base_name);
}

char *find_error(const char *filename, int *pline, int is_strict)
{
    if (error_file) {
        size_t len = strlen(filename);
        const char *p, *q, *r;
        int line;

        for (p = error_file; (p = strstr(p, filename)) != NULL; p += len) {
            if ((p == error_file || p[-1] == '\n' || p[-1] == '(') && p[len] == ':') {
                q = p + len;
                line = 1;
                if (*q == ':') {
                    line = strtol(q + 1, (char**)&q, 10);
                    if (*q == ':')
                        q++;
                }
                while (*q == ' ') {
                    q++;
                }
                /* check strict mode indicator */
                if (!strstart(q, "strict mode: ", &q) != !is_strict)
                    continue;
                r = q = skip_prefix(q, "unexpected error: ");
                r += strcspn(r, "\n");
                while (r[0] == '\n' && r[1] && strncmp(r + 1, filename, 8)) {
                    r++;
                    r += strcspn(r, "\n");
                }
                if (pline)
                    *pline = line;
                return strdup_len(q, r - q);
            }
        }
    }
    return NULL;
}

int skip_comments(const char *str, int line, int *pline)
{
    const char *p;
    int c;

    p = str;
    while ((c = (unsigned char)*p++) != '\0') {
        if (isspace(c)) {
            if (c == '\n')
                line++;
            continue;
        }
        if (c == '/' && *p == '/') {
            while (*++p && *p != '\n')
                continue;
            continue;
        }
        if (c == '/' && *p == '*') {
            for (p += 1; *p; p++) {
                if (*p == '\n') {
                    line++;
                    continue;
                }
                if (*p == '*' && p[1] == '/') {
                    p += 2;
                    break;
                }
            }
            continue;
        }
        break;
    }
    if (pline)
        *pline = line;

    return p - str;
}

int longest_match(const char *str, const char *find, int pos, int *ppos, int line, int *pline)
{
    int len, maxlen;

    maxlen = 0;
    
    if (*find) {
        const char *p;
        for (p = str + pos; *p; p++) {
            if (*p == *find) {
                for (len = 1; p[len] && p[len] == find[len]; len++)
                    continue;
                if (len > maxlen) {
                    maxlen = len;
                    if (ppos)
                        *ppos = p - str;
                    if (pline)
                        *pline = line;
                    if (!find[len])
                        break;
                }
            }
            if (*p == '\n')
                line++;
        }
    }
    return maxlen;
}

static int eval_buf(JSContext *ctx, const char *buf, size_t buf_len,
                    const char *filename, int is_test, int is_negative,
                    const char *error_type, FILE *outfile, int eval_flags,
                    int is_async)
{
    JSValue res_val, exception_val;
    int ret, error_line, pos, pos_line;
    BOOL is_error, has_error_line;
    const char *error_name;
    
    pos = skip_comments(buf, 1, &pos_line);
    error_line = pos_line;
    has_error_line = FALSE;
    exception_val = JS_UNDEFINED;
    error_name = NULL;

    async_done = 0; /* counter of "Test262:AsyncTestComplete" messages */

    res_val = JS_Eval(ctx, buf, buf_len, filename, eval_flags);

    if (is_async && !JS_IsException(res_val)) {
        JS_FreeValue(ctx, res_val);
        for(;;) {
            JSContext *ctx1;
            ret = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);
            if (ret < 0) {
                res_val = JS_EXCEPTION;
                break;
            } else if (ret == 0) {
                /* test if the test called $DONE() once */
                if (async_done != 1) {
                    res_val = JS_ThrowTypeError(ctx, "$DONE() not called");
                } else {
                    res_val = JS_UNDEFINED;
                }
                break;
            }
        }
    }

    if (JS_IsException(res_val)) {
        exception_val = JS_GetException(ctx);
        is_error = JS_IsError(ctx, exception_val);
        /* XXX: should get the filename and line number */
        if (outfile) {
            if (!is_error)
                fprintf(outfile, "%sThrow: ", (eval_flags & JS_EVAL_FLAG_STRICT) ?
                        "strict mode: " : "");
            js_print(ctx, JS_NULL, 1, &exception_val);
        }
        if (is_error) {
            JSValue name, stack;
            const char *stack_str;
        
            name = JS_GetPropertyStr(ctx, exception_val, "name");
            error_name = JS_ToCString(ctx, name);
            stack = JS_GetPropertyStr(ctx, exception_val, "stack");
            if (!JS_IsUndefined(stack)) {
                stack_str = JS_ToCString(ctx, stack);
                if (stack_str) {
                    const char *p;
                    int len;
                    
                    if (outfile)
                        fprintf(outfile, "%s", stack_str);
                    
                    len = strlen(filename);
                    p = strstr(stack_str, filename);
                    if (p != NULL && p[len] == ':') {
                        error_line = atoi(p + len + 1);
                        has_error_line = TRUE;
                    }
                    JS_FreeCString(ctx, stack_str);
                }
            }
            JS_FreeValue(ctx, stack);
            JS_FreeValue(ctx, name);
        }
        if (is_negative) {
            ret = 0;
            if (error_type) {
                char *error_class;
                const char *msg;
            
                msg = JS_ToCString(ctx, exception_val);
                error_class = strdup_len(msg, strcspn(msg, ":"));
                if (!str_equal(error_class, error_type))
                    ret = -1;
                free(error_class);
                JS_FreeCString(ctx, msg);
            }
        } else {
            ret = -1;
        }
    } else {
        if (is_negative)
            ret = -1;
        else
            ret = 0;
    }

    if (verbose && is_test) {
        JSValue msg_val = JS_UNDEFINED;
        const char *msg = NULL;
        int s_line;
        char *s = find_error(filename, &s_line, eval_flags & JS_EVAL_FLAG_STRICT);
        const char *strict_mode = (eval_flags & JS_EVAL_FLAG_STRICT) ? "strict mode: " : "";

        if (!JS_IsUndefined(exception_val)) {
            msg_val = JS_ToString(ctx, exception_val);
            msg = JS_ToCString(ctx, msg_val);
        }
        if (is_negative) {  // expect error
            if (ret == 0) {
                if (msg && s &&
                    (str_equal(s, "expected error") ||
                     strstart(s, "unexpected error type:", NULL) ||
                     str_equal(s, msg))) {     // did not have error yet
                    if (!has_error_line) {
                        longest_match(buf, msg, pos, &pos, pos_line, &error_line);
                    }
                    printf("%s:%d: %sOK, now has error %s\n",
                           filename, error_line, strict_mode, msg);
                    fixed_errors++;
                }
            } else {
                if (!s) {   // not yet reported
                    if (msg) {
                        fprintf(error_out, "%s:%d: %sunexpected error type: %s\n",
                                filename, error_line, strict_mode, msg);
                    } else {
                        fprintf(error_out, "%s:%d: %sexpected error\n",
                                filename, error_line, strict_mode);
                    }
                    new_errors++;
                }
            }
        } else {            // should not have error
            if (msg) {
                if (!s || !str_equal(s, msg)) {
                    if (!has_error_line) {
                        char *p = skip_prefix(msg, "Test262 Error: ");
                        if (strstr(p, "Test case returned non-true value!")) {
                            longest_match(buf, "runTestCase", pos, &pos, pos_line, &error_line);
                        } else {
                            longest_match(buf, p, pos, &pos, pos_line, &error_line);
                        }
                    }
                    fprintf(error_out, "%s:%d: %s%s%s\n", filename, error_line, strict_mode,
                            error_file ? "unexpected error: " : "", msg);

                    if (s && (!str_equal(s, msg) || error_line != s_line)) {
                        printf("%s:%d: %sprevious error: %s\n", filename, s_line, strict_mode, s);
                        changed_errors++;
                    } else {
                        new_errors++;
                    }
                }
            } else {
                if (s) {
                    printf("%s:%d: %sOK, fixed error: %s\n", filename, s_line, strict_mode, s);
                    fixed_errors++;
                }
            }
        }
        JS_FreeValue(ctx, msg_val);
        JS_FreeCString(ctx, msg);
        free(s);
    }
    JS_FreeCString(ctx, error_name);
    JS_FreeValue(ctx, exception_val);
    JS_FreeValue(ctx, res_val);
    return ret;
}

static int eval_file(JSContext *ctx, const char *base, const char *p,
                     int eval_flags)
{
    char *buf;
    size_t buf_len;
    char *filename = compose_path(base, p);

    buf = load_file(filename, &buf_len);
    if (!buf) {
        warning("cannot load %s", filename);
        goto fail;
    }
    if (eval_buf(ctx, buf, buf_len, filename, FALSE, FALSE, NULL, stderr,
                 eval_flags, FALSE)) {
        warning("error evaluating %s", filename);
        goto fail;
    }
    free(buf);
    free(filename);
    return 0;

fail:
    free(buf);
    free(filename);
    return 1;
}

char *extract_desc(const char *buf, char style)
{
    const char *p, *desc_start;
    char *desc;
    int len;
    
    p = buf;
    while (*p != '\0') {
        if (p[0] == '/' && p[1] == '*' && p[2] == style && p[3] != '/') {
            p += 3;
            desc_start = p;
            while (*p != '\0' && (p[0] != '*' || p[1] != '/'))
                p++;
            if (*p == '\0') {
                warning("Expecting end of desc comment");
                return NULL;
            }
            len = p - desc_start;
            desc = malloc(len + 1);
            memcpy(desc, desc_start, len);
            desc[len] = '\0';
            return desc;
        } else {
            p++;
        }
    }
    return NULL;
}

static char *find_tag(char *desc, const char *tag, int *state)
{
    char *p;
    p = strstr(desc, tag);
    if (p) {
        p += strlen(tag);
        *state = 0;
    }
    return p;
}

static char *get_option(char **pp, int *state)
{
    char *p, *p0, *option = NULL;
    if (*pp) {
        for (p = *pp;; p++) {
            switch (*p) {
            case '[':
                *state += 1;
                continue;
            case ']':
                *state -= 1;
                if (*state > 0)
                    continue;
                p = NULL;
                break;
            case ' ':
            case '\t':
            case '\r':
            case ',':
            case '-':
                continue;
            case '\n':
                if (*state > 0 || p[1] == ' ')
                    continue;
                p = NULL;
                break;
            case '\0':
                p = NULL;
                break;
            default:
                p0 = p;
                p += strcspn(p0, " \t\r\n,]");
                option = strdup_len(p0, p - p0);
                break;
            }
            break;
        }
        *pp = p;
    }
    return option;
}

void update_stats(JSRuntime *rt, const char *filename) {
    JSMemoryUsage stats;
    JS_ComputeMemoryUsage(rt, &stats);
    if (stats_count++ == 0) {
        stats_avg = stats_all = stats_min = stats_max = stats;
        stats_min_filename = strdup(filename);
        stats_max_filename = strdup(filename);
    } else {
        if (stats_max.malloc_size < stats.malloc_size) {
            stats_max = stats;
            free(stats_max_filename);
            stats_max_filename = strdup(filename);
        }
        if (stats_min.malloc_size > stats.malloc_size) {
            stats_min = stats;
            free(stats_min_filename);
            stats_min_filename = strdup(filename);
        }

#define update(f)  stats_avg.f = (stats_all.f += stats.f) / stats_count
        update(malloc_count);
        update(malloc_size);
        update(memory_used_count);
        update(memory_used_size);
        update(atom_count);
        update(atom_size);
        update(str_count);
        update(str_size);
        update(obj_count);
        update(obj_size);
        update(prop_count);
        update(prop_size);
        update(shape_count);
        update(shape_size);
        update(js_func_count);
        update(js_func_size);
        update(js_func_code_size);
        update(js_func_pc2line_count);
        update(js_func_pc2line_size);
        update(c_func_count);
        update(array_count);
        update(fast_array_count);
        update(fast_array_elements);
    }
#undef update
}

int run_test_buf(const char *filename, char *harness, namelist_t *ip,
                 char *buf, size_t buf_len, const char* error_type,
                 int eval_flags, BOOL is_negative, BOOL is_async,
                 BOOL can_block)
{
    JSRuntime *rt;
    JSContext *ctx;
    int i, ret;
        
    rt = JS_NewRuntime();
    if (rt == NULL) {
        fatal(1, "JS_NewRuntime failure");
    }        
    ctx = JS_NewContext(rt);
    if (ctx == NULL) {
        JS_FreeRuntime(rt);
        fatal(1, "JS_NewContext failure");
    }
    JS_SetRuntimeInfo(rt, filename);

    JS_SetCanBlock(rt, can_block);
    
    /* loader for ES6 modules */
    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader_test, NULL);
        
    add_helpers(ctx);

    for (i = 0; i < ip->count; i++) {
        if (eval_file(ctx, harness, ip->array[i],
                      JS_EVAL_TYPE_GLOBAL | JS_EVAL_FLAG_STRIP)) {
            fatal(1, "error including %s for %s", ip->array[i], filename);
        }
    }

    ret = eval_buf(ctx, buf, buf_len, filename, TRUE, is_negative,
                   error_type, outfile, eval_flags, is_async);
    ret = (ret != 0);
        
    if (dump_memory) {
        update_stats(rt, filename);
    }
#ifdef CONFIG_AGENT
    js_agent_free(ctx);
#endif
    JS_FreeContext(ctx);
    JS_FreeRuntime(rt);

    test_count++;
    if (ret) {
        test_failed++;
        if (outfile) {
            /* do not output a failure number to minimize diff */
            fprintf(outfile, "  FAILED\n");
        }
    }
    return ret;
}

int run_test(const char *filename, int index)
{
    char harnessbuf[1024];
    char *harness;
    char *buf;
    size_t buf_len;
    char *desc, *p;
    char *error_type;
    int ret, eval_flags, use_strict, use_nostrict;
    BOOL is_negative, is_nostrict, is_onlystrict, is_async, is_module, skip;
    BOOL can_block;
    namelist_t include_list = { 0 }, *ip = &include_list;
    
    is_nostrict = is_onlystrict = is_negative = is_async = is_module = skip = FALSE;
    can_block = TRUE;
    error_type = NULL;
    buf = load_file(filename, &buf_len);

    harness = harness_dir;

    if (new_style) {
        if (!harness) {
            p = strstr(filename, "test/");
            if (p) {
                snprintf(harnessbuf, sizeof(harnessbuf), "%.*s%s",
                         (int)(p - filename), filename, "harness");
            }
            harness = harnessbuf;
        }
        namelist_add(ip, NULL, "sta.js");
        namelist_add(ip, NULL, "assert.js");
        /* extract the YAML frontmatter */
        desc = extract_desc(buf, '-');
        if (desc) {
            char *ifile, *option;
            int state;
            p = find_tag(desc, "includes:", &state);
            if (p) {
                while ((ifile = get_option(&p, &state)) != NULL) {
                    // skip unsupported harness files
                    if (find_word(harness_exclude, ifile)) {
                        skip |= 1;
                    } else {
                        namelist_add(ip, NULL, ifile);
                    }
                    free(ifile);
                }
            }
            p = find_tag(desc, "flags:", &state);
            if (p) {
                while ((option = get_option(&p, &state)) != NULL) {
                    if (str_equal(option, "noStrict") ||
                        str_equal(option, "raw")) {
                        is_nostrict = TRUE;
                        skip |= (test_mode == TEST_STRICT);
                    }
                    else if (str_equal(option, "onlyStrict")) {
                        is_onlystrict = TRUE;
                        skip |= (test_mode == TEST_NOSTRICT);
                    }
                    else if (str_equal(option, "async")) {
                        is_async = TRUE;
                        skip |= skip_async;
                    }
                    else if (str_equal(option, "module")) {
                        is_module = TRUE;
                        skip |= skip_module;
                    }
                    else if (str_equal(option, "CanBlockIsFalse")) {
                        can_block = FALSE;
                    }
                    free(option);
                }
            }
            p = find_tag(desc, "negative:", &state);
            if (p) {
                /* XXX: should extract the phase */
                char *q = find_tag(p, "type:", &state);
                if (q) {
                    while (isspace(*q))
                        q++;
                    error_type = strdup_len(q, strcspn(q, " \n"));
                }
                is_negative = TRUE;
            }
            p = find_tag(desc, "features:", &state);
            if (p) {
                while ((option = get_option(&p, &state)) != NULL) {
                    if (find_word(harness_features, option)) {
                        /* feature is enabled */
                    } else if (find_word(harness_skip_features, option)) {
                        /* skip disabled feature */
                        skip |= 1;
                    } else {
                        /* feature is not listed: skip and warn */
                        printf("%s:%d: unknown feature: %s\n", filename, 1, option);
                        skip |= 1;
                    }
                    free(option);
                }
            }
            free(desc);
        }
        if (is_async)
            namelist_add(ip, NULL, "doneprintHandle.js");
    } else {
        char *ifile;

        if (!harness) {
            p = strstr(filename, "test/");
            if (p) {
                snprintf(harnessbuf, sizeof(harnessbuf), "%.*s%s",
                         (int)(p - filename), filename, "test/harness");
            }
            harness = harnessbuf;
        }

        namelist_add(ip, NULL, "sta.js");

        /* include extra harness files */
        for (p = buf; (p = strstr(p, "$INCLUDE(\"")) != NULL; p++) {
            p += 10;
            ifile = strdup_len(p, strcspn(p, "\""));
            // skip unsupported harness files
            if (find_word(harness_exclude, ifile)) {
                skip |= 1;
            } else {
                namelist_add(ip, NULL, ifile);
            }
            free(ifile);
        }

        /* locate the old style configuration comment */
        desc = extract_desc(buf, '*');
        if (desc) {
            if (strstr(desc, "@noStrict")) {
                is_nostrict = TRUE;
                skip |= (test_mode == TEST_STRICT);
            }
            if (strstr(desc, "@onlyStrict")) {
                is_onlystrict = TRUE;
                skip |= (test_mode == TEST_NOSTRICT);
            }
            if (strstr(desc, "@negative")) {
                /* XXX: should extract the regex to check error type */
                is_negative = TRUE;
            }
            free(desc);
        }
    }

    if (outfile && index >= 0) {
        fprintf(outfile, "%d: %s%s%s%s%s%s%s\n", index, filename,
                is_nostrict ? "  @noStrict" : "",
                is_onlystrict ? "  @onlyStrict" : "",
                is_async ? "  async" : "",
                is_module ? "  module" : "",
                is_negative ? "  @negative" : "",
                skip ? "  SKIPPED" : "");
        fflush(outfile);
    }

    use_strict = use_nostrict = 0;
    /* XXX: should remove 'test_mode' or simplify it just to force
       strict or non strict mode for single file tests */
    switch (test_mode) {
    case TEST_DEFAULT_NOSTRICT:
        if (is_onlystrict)
            use_strict = 1;
        else
            use_nostrict = 1;
        break;
    case TEST_DEFAULT_STRICT:
        if (is_nostrict)
            use_nostrict = 1;
        else
            use_strict = 1;
        break;
    case TEST_NOSTRICT:
        if (!is_onlystrict)
            use_nostrict = 1;
        break;
    case TEST_STRICT:
        if (!is_nostrict)
            use_strict = 1;
        break;
    case TEST_ALL:
        if (is_module) {
            use_nostrict = 1;
        } else {
            if (!is_nostrict)
                use_strict = 1;
            if (!is_onlystrict)
                use_nostrict = 1;
        }
        break;
    }

    if (skip || use_strict + use_nostrict == 0) {
        test_skipped++;
        ret = -2;
    } else {
        clock_t clocks;

        if (is_module) {
            eval_flags = JS_EVAL_TYPE_MODULE;
        } else {
            eval_flags = JS_EVAL_TYPE_GLOBAL;
        }
        clocks = clock();
        ret = 0;
        if (use_nostrict) {
            ret = run_test_buf(filename, harness, ip, buf, buf_len,
                               error_type, eval_flags, is_negative, is_async,
                               can_block);
        }
        if (use_strict) {
            ret |= run_test_buf(filename, harness, ip, buf, buf_len,
                                error_type, eval_flags | JS_EVAL_FLAG_STRICT,
                                is_negative, is_async, can_block);
        }
        clocks = clock() - clocks;
        if (outfile && index >= 0 && clocks >= CLOCKS_PER_SEC / 10) {
            /* output timings for tests that take more than 100 ms */
            fprintf(outfile, " time: %d ms\n", (int)(clocks * 1000LL / CLOCKS_PER_SEC));
        }
    }
    namelist_free(&include_list);
    free(error_type);
    free(buf);

    return ret;
}

/* run a test when called by test262-harness+eshost */
int run_test262_harness_test(const char *filename, BOOL is_module)
{
    JSRuntime *rt;
    JSContext *ctx;
    char *buf;
    size_t buf_len;
    int eval_flags, ret_code, ret;
    JSValue res_val;
    BOOL can_block;
    
    outfile = stdout; /* for js_print */

    rt = JS_NewRuntime();
    if (rt == NULL) {
        fatal(1, "JS_NewRuntime failure");
    }        
    ctx = JS_NewContext(rt);
    if (ctx == NULL) {
        JS_FreeRuntime(rt);
        fatal(1, "JS_NewContext failure");
    }
    JS_SetRuntimeInfo(rt, filename);

    can_block = TRUE;
    JS_SetCanBlock(rt, can_block);
    
    /* loader for ES6 modules */
    JS_SetModuleLoaderFunc(rt, NULL, js_module_loader_test, NULL);
        
    add_helpers(ctx);

    buf = load_file(filename, &buf_len);

    if (is_module) {
      eval_flags = JS_EVAL_TYPE_MODULE;
    } else {
      eval_flags = JS_EVAL_TYPE_GLOBAL;
    }
    res_val = JS_Eval(ctx, buf, buf_len, filename, eval_flags);
    ret_code = 0;
    if (JS_IsException(res_val)) {
       js_std_dump_error(ctx);
       ret_code = 1;
    } else {
        JS_FreeValue(ctx, res_val);
        for(;;) {
            JSContext *ctx1;
            ret = JS_ExecutePendingJob(JS_GetRuntime(ctx), &ctx1);
            if (ret < 0) {
	      js_std_dump_error(ctx1);
	      ret_code = 1;
            } else if (ret == 0) {
	      break;
            }
        }
    }
    free(buf);
#ifdef CONFIG_AGENT
    js_agent_free(ctx);
#endif
    JS_FreeContext(ctx);
    JS_FreeRuntime(rt);
    return ret_code;
}

clock_t last_clock;

void show_progress(int force) {
    clock_t t = clock();
    if (force || !last_clock || (t - last_clock) > CLOCKS_PER_SEC / 20) {
        last_clock = t;
        /* output progress indicator: erase end of line and return to col 0 */
        fprintf(stderr, "%d/%d/%d\033[K\r",
                test_failed, test_count, test_skipped);
        fflush(stderr);
    }
}

static int slow_test_threshold;

void run_test_dir_list(namelist_t *lp, int start_index, int stop_index)
{
    int i;

    namelist_sort(lp);
    for (i = 0; i < lp->count; i++) {
        const char *p = lp->array[i];
        if (namelist_find(&exclude_list, p) >= 0) {
            test_excluded++;
        } else if (test_index < start_index) {
            test_skipped++;
        } else if (stop_index >= 0 && test_index > stop_index) {
            test_skipped++;
        } else {
            int ti;
            if (slow_test_threshold != 0) {
                ti = get_clock_ms();
            } else {
                ti = 0;
            }
            run_test(p, test_index);
            if (slow_test_threshold != 0) {
                ti = get_clock_ms() - ti;
                if (ti >= slow_test_threshold)
                    fprintf(stderr, "\n%s (%d ms)\n", p, ti);
            }
            show_progress(FALSE);
        }
        test_index++;
    }
    show_progress(TRUE);
}

void help(void)
{
    printf("run-test262 version " CONFIG_VERSION "\n"
           "usage: run-test262 [options] {-f file ... | [dir_list] [index range]}\n"
           "-h             help\n"
           "-a             run tests in strict and nostrict modes\n"
           "-m             print memory usage summary\n"
           "-n             use new style harness\n"
           "-N             run test prepared by test262-harness+eshost\n"
           "-s             run tests in strict mode, skip @nostrict tests\n"
           "-E             only run tests from the error file\n"
           "-u             update error file\n"
           "-v             verbose: output error messages\n"
           "-T duration    display tests taking more than 'duration' ms\n"
           "-c file        read configuration from 'file'\n"
           "-d dir         run all test files in directory tree 'dir'\n"
           "-e file        load the known errors from 'file'\n"
           "-f file        execute single test from 'file'\n"
           "-r file        set the report file name (default=none)\n"
           "-x file        exclude tests listed in 'file'\n");
    exit(1);
}

char *get_opt_arg(const char *option, char *arg)
{
    if (!arg) {
        fatal(2, "missing argument for option %s", option);
    }
    return arg;
}

int main(int argc, char **argv)
{
    int optind, start_index, stop_index;
    BOOL is_dir_list;
    BOOL only_check_errors = FALSE;
    const char *filename;
    BOOL is_test262_harness = FALSE;
    BOOL is_module = FALSE;

#if !defined(_WIN32)
    /* Date tests assume California local time */
    setenv("TZ", "America/Los_Angeles", 1);
#endif

    /* cannot use getopt because we want to pass the command line to
       the script */
    optind = 1;
    is_dir_list = TRUE;
    while (optind < argc) {
        char *arg = argv[optind];
        if (*arg != '-')
            break;
        optind++;
        if (str_equal(arg, "-h")) {
            help();
        } else if (str_equal(arg, "-m")) {
            dump_memory++;
        } else if (str_equal(arg, "-n")) {
            new_style++;
        } else if (str_equal(arg, "-s")) {
            test_mode = TEST_STRICT;
        } else if (str_equal(arg, "-a")) {
            test_mode = TEST_ALL;
        } else if (str_equal(arg, "-u")) {
            update_errors++;
        } else if (str_equal(arg, "-v")) {
            verbose++;
        } else if (str_equal(arg, "-c")) {
            load_config(get_opt_arg(arg, argv[optind++]));
        } else if (str_equal(arg, "-d")) {
            enumerate_tests(get_opt_arg(arg, argv[optind++]));
        } else if (str_equal(arg, "-e")) {
            error_filename = get_opt_arg(arg, argv[optind++]);
        } else if (str_equal(arg, "-x")) {
            namelist_load(&exclude_list, get_opt_arg(arg, argv[optind++]));
        } else if (str_equal(arg, "-f")) {
            is_dir_list = FALSE;
        } else if (str_equal(arg, "-r")) {
            report_filename = get_opt_arg(arg, argv[optind++]);
        } else if (str_equal(arg, "-E")) {
            only_check_errors = TRUE;
        } else if (str_equal(arg, "-T")) {
            slow_test_threshold = atoi(get_opt_arg(arg, argv[optind++]));
        } else if (str_equal(arg, "-N")) {
            is_test262_harness = TRUE;
        } else if (str_equal(arg, "--module")) {
            is_module = TRUE;
        } else {
            fatal(1, "unknown option: %s", arg);
            break;
        }
    }
    
    if (optind >= argc && !test_list.count)
        help();

    if (is_test262_harness) {
        return run_test262_harness_test(argv[optind], is_module);
    }
			       
    error_out = stdout;
    if (error_filename) {
        error_file = load_file(error_filename, NULL);
        if (only_check_errors && error_file) {
            namelist_free(&test_list);
            namelist_add_from_error_file(&test_list, error_file);
        }
        if (update_errors) {
            free(error_file);
            error_file = NULL;
            error_out = fopen(error_filename, "w");
            if (!error_out) {
                perror_exit(1, error_filename);
            }
        }
    }

    update_exclude_dirs();

    if (is_dir_list) {
        if (optind < argc && !isdigit(argv[optind][0])) {
            filename = argv[optind++];
            namelist_load(&test_list, filename);
        }
        start_index = 0;
        stop_index = -1;
        if (optind < argc) {
            start_index = atoi(argv[optind++]);
            if (optind < argc) {
                stop_index = atoi(argv[optind++]);
            }
        }
        if (!report_filename || str_equal(report_filename, "none")) {
            outfile = NULL;
        } else if (str_equal(report_filename, "-")) {
            outfile = stdout;
        } else {
            outfile = fopen(report_filename, "wb");
            if (!outfile) {
                perror_exit(1, report_filename);
            }
        }
        run_test_dir_list(&test_list, start_index, stop_index);

        if (outfile && outfile != stdout) {
            fclose(outfile);
            outfile = NULL;
        }
    } else {
        outfile = stdout;
        while (optind < argc) {
            run_test(argv[optind++], -1);
        }
    }

    if (dump_memory) {
        if (dump_memory > 1 && stats_count > 1) {
            printf("\nMininum memory statistics for %s:\n\n", stats_min_filename);
            JS_DumpMemoryUsage(stdout, &stats_min, NULL);
            printf("\nMaximum memory statistics for %s:\n\n", stats_max_filename);
            JS_DumpMemoryUsage(stdout, &stats_max, NULL);
        }
        printf("\nAverage memory statistics for %d tests:\n\n", stats_count);
        JS_DumpMemoryUsage(stdout, &stats_avg, NULL);
        printf("\n");
    }

    if (is_dir_list) {
        fprintf(stderr, "Result: %d/%d error%s",
                test_failed, test_count, test_count != 1 ? "s" : "");
        if (test_excluded)
            fprintf(stderr, ", %d excluded", test_excluded);
        if (test_skipped)
            fprintf(stderr, ", %d skipped", test_skipped);
        if (error_file) {
            if (new_errors)
                fprintf(stderr, ", %d new", new_errors);
            if (changed_errors)
                fprintf(stderr, ", %d changed", changed_errors);
            if (fixed_errors)
                fprintf(stderr, ", %d fixed", fixed_errors);
        }
        fprintf(stderr, "\n");
    }

    if (error_out && error_out != stdout) {
        fclose(error_out);
        error_out = NULL;
    }

    namelist_free(&test_list);
    namelist_free(&exclude_list);
    namelist_free(&exclude_dir_list);
    free(harness_dir);
    free(harness_features);
    free(harness_exclude);
    free(error_file);

    return 0;
}

'''
'''--- showcase/audioworkletprocessor.js ---
export function AudioWorkletModuleFunc() {
    const SAMPLE_FRAMES = 128;

    class AssemblyScriptMidiSynthAudioWorkletProcessor extends AudioWorkletProcessor {

        constructor() {
            super();
            this.processorActive = true;
            this.playMidiSequence = true;
            this.currentFrame = 0;
            this.sequenceIndex = 0;

            this.port.onmessage = async (msg) => {
                if (msg.data.wasm) {
                    this.wasmInstancePromise = WebAssembly.instantiate(msg.data.wasm, {
                        environment: { SAMPLERATE: msg.data.samplerate },
                        env: {
                            abort: () => console.log('webassembly synth abort, should not happen')
                        }
                    });

                    const wasmInstance = (await this.wasmInstancePromise).instance.exports;
                    this.wasmInstance = wasmInstance;
                    this.port.postMessage({ wasmloaded: true });
                }

                if (msg.data.sequencedata) {
                    this.allNotesOff();
                    this.sequence = msg.data.sequencedata;
                    this.currentFrame = 0;
                    this.sequenceIndex = 0;
                }

                if (msg.data.currentTime) {
                    this.port.postMessage({
                        currentTime: this.wasmInstance.currentTimeMillis.value,
                        activeVoicesStatusSnapshot: new Uint8Array(this.wasmInstance.memory.buffer,
                            this.wasmInstance.getActiveVoicesStatusSnapshot(),
                            32*3).slice(0)
                    });
                }
            };
            this.port.start();
        }

        getCurrentTime() {
            return (this.currentFrame / sampleRate) * 1000;
        }

        allNotesOff() {
            if (this.wasmInstance) {
                this.wasmInstance.allNotesOff();
                for (let ch = 0; ch < 16; ch++) {
                    this.wasmInstance.shortmessage(
                        0xb0 + ch, 64, 0  // reset sustain pedal
                    );
                }
            }
        }

        process(inputs, outputs, parameters) {
            const output = outputs[0];

            if (this.wasmInstance) {
                let currentTime = this.getCurrentTime();

                if (this.sequence) {
                    while (this.sequenceIndex < this.sequence.length &&
                        this.sequence[this.sequenceIndex] && // sometimes this is undefined for yet unkown reasons
                        this.sequence[this.sequenceIndex].time < currentTime) {

                        const message = this.sequence[this.sequenceIndex].message;
                        this.wasmInstance.shortmessage(message[0], message[1], message[2]);
                        this.sequenceIndex++;
                    }
                    this.currentFrame += 128;
                    if (this.sequenceIndex >= this.sequence.length) {
                        this.currentFrame = 0;
                        this.sequenceIndex = 0;
                    }                    
                }
            }
            this.wasmInstance.fillSampleBuffer();
            output[0].set(new Float32Array(this.wasmInstance.memory.buffer,
                this.wasmInstance.samplebuffer,
                SAMPLE_FRAMES));
            output[1].set(new Float32Array(this.wasmInstance.memory.buffer,
                this.wasmInstance.samplebuffer + (SAMPLE_FRAMES * 4),
                SAMPLE_FRAMES));

            return this.processorActive;
        }
    }

    registerProcessor('asc-midisynth-audio-worklet-processor', AssemblyScriptMidiSynthAudioWorkletProcessor);
}

const functionSource = AudioWorkletModuleFunc.toString();
const functionSourceUnwrapped = functionSource.substring(functionSource.indexOf('{') + 1, functionSource.lastIndexOf('}'));
export const AudioWorkletProcessorUrl = URL.createObjectURL(new Blob([functionSourceUnwrapped], { type: 'text/javascript' }));
'''
'''--- showcase/closeprotocol.component.html ---
<style>
    #container {
        margin: auto;
        margin-top: 20px;
        max-width: 1024px;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100%;
    }

    button {
        font-size: 30px;
        border: none;
        padding: 10px;
    }

    #imagediv img {
        max-width: 100%;
    }
</style>
<div id="container">
    <div id="infotext"></div>
    <div id="imagediv"></div>
    <button id="enterbutton">New game</button>
</div>
'''
'''--- showcase/closeprotocol.component.js ---
import 'https://cdn.jsdelivr.net/npm/near-api-js@0.44.2/dist/near-api-js.min.js';
import { getSynthWasm } from './synth.js';
import { AudioWorkletProcessorUrl } from './audioworkletprocessor.js';

let audioworkletnode;
const contractAccount = 'apsolomo.testnet';

const nearconfig = {
    nodeUrl: 'https://rpc.testnet.near.org',
    archiveNodeUrl: 'https://archival-rpc.testnet.near.org',
    walletUrl: 'https://wallet.testnet.near.org',
    helperUrl: 'https://helper.testnet.near.org',
    networkId: 'testnet',
    contractName: 'dev-1650702826986-24017505724534',
    deps: {
        keyStore: null
    }
};

const walletConnection = new Promise(async resolve => {
    nearconfig.deps.keyStore = new nearApi.keyStores.BrowserLocalStorageKeyStore();
    const near = await nearApi.connect(nearconfig);
    const wc = new nearApi.WalletConnection(near);
    resolve(wc);
});

async function checkSignedin() {
    const wc = await walletConnection;
    const acc = wc.account();
    if (!(await acc.connection.signer.getPublicKey(acc.accountId, acc.connection.networkId))) {
        wc.signOut();
    }

    if (!wc.isSignedIn()) {
        await wc.requestSignIn(
            nearconfig.contractName,
            'js-on-near'
        );
    }
    return wc;
}

async function callJSContract(methodName, args = '', deposit = undefined) {
    const wc = await checkSignedin();
    const input = Buffer.concat([Buffer.from(contractAccount), Buffer.from([0]), Buffer.from(methodName), Buffer.from([0]), Buffer.from(JSON.stringify(args))]);
    const result = await wc.account().functionCall(nearconfig.contractName, 'call_js_contract', input, undefined, deposit ? nearApi.utils.format.parseNearAmount(deposit) : undefined);
    return result.status.SuccessValue ? atob(result.status.SuccessValue) : ''
}

async function viewJSContract(methodName, args = '') {
    const wc = await checkSignedin();
    const input = Buffer.concat([Buffer.from(contractAccount), Buffer.from([0]), Buffer.from(methodName), Buffer.from([0]), Buffer.from(JSON.stringify(args))]);
    const result = await wc._near.connection.provider.query({
        request_type: "call_function",
        account_id: nearconfig.contractName,
        method_name: 'view_js_contract',
        args_base64: btoa(input),
        finality: "optimistic"
    });
    const resultvalue = result.result.map(c => String.fromCharCode(c)).join('');
    return resultvalue;
}

let musicPlaying = false;
async function playMusic() {
    if (musicPlaying) {
        return;
    }
    musicPlaying = true;
    const audioctx = new AudioContext();
    audioctx.resume();

    const wasmsynth = await getSynthWasm();

    await audioctx.audioWorklet.addModule(AudioWorkletProcessorUrl);
    audioworkletnode = new AudioWorkletNode(audioctx, 'asc-midisynth-audio-worklet-processor', {
        outputChannelCount: [2]
    });
    audioworkletnode.port.start();

    audioworkletnode.port.postMessage({
        samplerate: audioctx.sampleRate,
        wasm: wasmsynth
    });
    
    audioworkletnode.connect(audioctx.destination);
}

customElements.define('close-protocol', class CloseProtocolComponent extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.init();
    }

    async init() {
        this.shadowRoot.innerHTML = await fetch(new URL('closeprotocol.component.html', import.meta.url)).then(r => r.text());
        this.enterbutton = this.shadowRoot.getElementById('enterbutton');
        this.imagediv = this.shadowRoot.getElementById('imagediv');

        this.enterbutton.addEventListener('click', async () => {
            this.enterbutton.style.display = 'none';

            this.setInfoText('Creating new game');
            await callJSContract('newgame', '', '0.1');
            await this.updateGameState();
        });
        this.imagediv.addEventListener('click', async (e) => {
            const x = Math.floor(e.offsetX * 3 / this.imagediv.clientWidth);
            const y = Math.floor(e.offsetY * 3 / this.imagediv.clientHeight);
            this.setInfoText('Trying to find key');
            await callJSContract('try_find_key', { x, y });
            await this.updateGameState();
        });
        
        await checkSignedin();
        await this.updateGameState();
    }

    setInfoText(txt = '') {
        this.shadowRoot.querySelector('#infotext').innerHTML = txt;
    }

    async updateGameState() {
        this.walletConnection = await checkSignedin();
        const gamestatejson = await viewJSContract('view_game_state',
            { "account_id": this.walletConnection.account().accountId }
        );
        if (gamestatejson) {
            const gamestate = JSON.parse(gamestatejson);
            const currentStep = gamestate.reduce((prev, curr, ndx) => curr.keyFound ? ndx + 1 : prev, 0);
            const gameStateObj = gamestate[currentStep];
            const imageElement = new Image();
            imageElement.src = gameStateObj.image;

            console.log(imageElement.src);
            this.imagediv.replaceChildren(imageElement);
            this.enterbutton.style.display = 'block';
            this.setInfoText(`Click on the image and try to find the next key. You have made ${gameStateObj.attempts} attempts.`);

            audioworkletnode.port.postMessage({
                sequencedata: gamestate.filter(m => m.music).map(m => m.music.eventlistuncompressed).flat().sort((a,b) => a.time - b.time)
            });
        }
    }
});

window.enterCloseProtocol = () => {
    playMusic();
    document.body.innerHTML = '<close-protocol></close-protocol>';
}
'''
'''--- showcase/closeprotocol.html ---
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            margin: 0;
            background-color: black;
            font-family: monospace;
            font-size: 30px;
            color: white;
        }
        #container {
            margin: auto;
            margin-top: 20px;
            max-width: 1024px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
        }

        button {
            font-size: 30px;
            border: none;
            padding: 10px;
        }
    </style>
</head>

<body>
    <div id="container">        
        <button onclick="enterCloseProtocol();">Enter</button>
    </div>
</body>
<script type="module" src="closeprotocol.component.js"></script>
</html>
'''
'''--- showcase/contract.js ---
const imageUrls = ['https://fictionspawnsite.files.wordpress.com/2022/05/bus-close-protocol.jpg',
  'https://fictionspawnsite.files.wordpress.com/2022/04/another-cabin-save.jpg?w=2048',
  'https://fictionspawnsite.files.wordpress.com/2022/05/swamp-sketch.jpg',
  'https://fictionspawnsite.files.wordpress.com/2022/05/bus-inside.jpg?w=2048',
  'https://fictionspawnsite.files.wordpress.com/2022/05/bus-steering-wheel-sketch.jpg?w=2048',
  'https://fictionspawnsite.files.wordpress.com/2022/05/bunker-entrance-closed.jpg?w=2048',
  'https://fictionspawnsite.files.wordpress.com/2022/05/bunker-entrance.jpg?w=2048',
  'https://fictionspawnsite.files.wordpress.com/2022/05/hut-inside.jpg?w=2048',
  'https://fictionspawnsite.files.wordpress.com/2022/05/open-box-close.jpg?w=1578',
  'https://fictionspawnsite.files.wordpress.com/2022/05/open-box-rope.jpg?w=2048',
  'https://fictionspawnsite.files.wordpress.com/2022/05/dead-man-close-sketch.jpg?w=2048'
];

const midiparts = [{ "eventlistuncompressed": [{ "time": 6906, "message": [150, 81, 53] }, { "time": 6993, "message": [134, 81, 0] }, { "time": 7020, "message": [150, 84, 78] }, { "time": 7146, "message": [150, 86, 68] }, { "time": 7160, "message": [134, 84, 0] }, { "time": 7313, "message": [150, 88, 74] }, { "time": 7319, "message": [134, 86, 0] }, { "time": 7613, "message": [134, 88, 0] }, { "time": 7720, "message": [150, 88, 54] }, { "time": 7746, "message": [150, 89, 68] }, { "time": 7747, "message": [134, 88, 0] }, { "time": 7913, "message": [134, 89, 0] }, { "time": 8066, "message": [150, 91, 39] }, { "time": 8093, "message": [134, 91, 0] }, { "time": 8100, "message": [150, 89, 54] }, { "time": 8146, "message": [150, 91, 23] }, { "time": 8180, "message": [134, 89, 0] }, { "time": 9060, "message": [150, 89, 39] }, { "time": 9066, "message": [134, 91, 0] }, { "time": 9153, "message": [134, 89, 0] }, { "time": 9160, "message": [150, 91, 92] }, { "time": 9227, "message": [134, 91, 0] }, { "time": 9246, "message": [150, 89, 75] }, { "time": 9333, "message": [150, 88, 74] }, { "time": 9333, "message": [134, 89, 0] }, { "time": 9800, "message": [134, 88, 0] }, { "time": 16333, "message": [150, 81, 62] }, { "time": 16413, "message": [134, 81, 0] }, { "time": 16446, "message": [150, 84, 78] }, { "time": 16539, "message": [134, 84, 0] }, { "time": 16546, "message": [150, 86, 64] }, { "time": 16859, "message": [134, 86, 0] }, { "time": 16933, "message": [150, 88, 44] }, { "time": 17133, "message": [134, 88, 0] }, { "time": 17333, "message": [150, 89, 49] }, { "time": 17593, "message": [134, 89, 0] }, { "time": 17653, "message": [150, 91, 72] }, { "time": 17813, "message": [134, 91, 0] }, { "time": 18000, "message": [150, 91, 70] }, { "time": 18020, "message": [150, 92, 73] }, { "time": 18073, "message": [134, 91, 0] }, { "time": 18073, "message": [134, 92, 0] }, { "time": 18086, "message": [150, 93, 83] }, { "time": 18986, "message": [134, 93, 0] }, { "time": 19006, "message": [150, 91, 67] }, { "time": 19079, "message": [134, 91, 0] }, { "time": 19086, "message": [150, 93, 75] }, { "time": 19153, "message": [134, 93, 0] }, { "time": 19173, "message": [150, 91, 87] }, { "time": 19273, "message": [134, 91, 0] }, { "time": 19280, "message": [150, 89, 65] }, { "time": 19953, "message": [134, 89, 0] }, { "time": 20006, "message": [150, 84, 83] }, { "time": 20673, "message": [134, 84, 0] }], "startTimes": [0], "channel": 6 }, { "eventlistuncompressed": [{ "time": 0, "message": [144, 81, 93] }, { "time": 0, "message": [144, 22, 88] }, { "time": 1666, "message": [144, 93, 79] }, { "time": 2606, "message": [128, 93, 0] }, { "time": 2666, "message": [144, 86, 82] }, { "time": 4333, "message": [144, 88, 83] }, { "time": 4413, "message": [128, 86, 0] }, { "time": 4753, "message": [128, 81, 0] }, { "time": 5333, "message": [144, 81, 83] }, { "time": 5446, "message": [128, 88, 0] }, { "time": 7000, "message": [144, 93, 79] }, { "time": 7953, "message": [128, 93, 0] }, { "time": 8000, "message": [144, 86, 83] }, { "time": 9666, "message": [144, 88, 83] }, { "time": 9760, "message": [128, 86, 0] }, { "time": 9800, "message": [128, 81, 0] }, { "time": 10593, "message": [128, 22, 0] }, { "time": 10666, "message": [144, 81, 84] }, { "time": 10666, "message": [144, 29, 67] }, { "time": 10673, "message": [128, 88, 0] }, { "time": 12333, "message": [144, 93, 79] }, { "time": 13320, "message": [128, 93, 0] }, { "time": 13333, "message": [144, 86, 83] }, { "time": 15000, "message": [144, 88, 72] }, { "time": 15086, "message": [128, 86, 0] }, { "time": 15906, "message": [128, 81, 0] }, { "time": 16000, "message": [144, 81, 87] }, { "time": 16047, "message": [128, 88, 0] }, { "time": 17666, "message": [144, 93, 75] }, { "time": 18599, "message": [128, 93, 0] }, { "time": 18666, "message": [144, 86, 79] }, { "time": 20333, "message": [144, 88, 82] }, { "time": 20419, "message": [128, 86, 0] }, { "time": 21253, "message": [128, 88, 0] }, { "time": 21293, "message": [128, 29, 0] }, { "time": 21293, "message": [128, 81, 0] }], "startTimes": [0], "channel": 0 }, { "eventlistuncompressed": [{ "time": 20, "message": [145, 60, 67] }, { "time": 33, "message": [145, 53, 64] }, { "time": 46, "message": [145, 34, 51] }, { "time": 10660, "message": [129, 53, 0] }, { "time": 10680, "message": [145, 64, 54] }, { "time": 10686, "message": [145, 26, 65] }, { "time": 10686, "message": [129, 34, 0] }, { "time": 10693, "message": [145, 57, 78] }, { "time": 10700, "message": [129, 60, 0] }, { "time": 18653, "message": [145, 67, 47] }, { "time": 18666, "message": [145, 60, 67] }, { "time": 18667, "message": [129, 64, 0] }, { "time": 18680, "message": [145, 29, 57] }, { "time": 18686, "message": [129, 26, 0] }, { "time": 18773, "message": [129, 57, 0] }, { "time": 21293, "message": [129, 60, 0] }, { "time": 21293, "message": [129, 29, 0] }, { "time": 21300, "message": [129, 67, 0] }], "startTimes": [0], "channel": 1 }, { "eventlistuncompressed": [{ "time": 0, "message": [146, 67, 70] }, { "time": 0, "message": [146, 73, 100] }, { "time": 7, "message": [130, 67, 0] }, { "time": 67, "message": [130, 73, 0] }, { "time": 1000, "message": [146, 73, 50] }, { "time": 1133, "message": [130, 73, 0] }, { "time": 1333, "message": [146, 73, 100] }, { "time": 1466, "message": [130, 73, 0] }, { "time": 1666, "message": [146, 67, 100] }, { "time": 2000, "message": [146, 73, 80] }, { "time": 2067, "message": [130, 73, 0] }, { "time": 2333, "message": [130, 67, 0] }], "startTimes": [0, 2666, 5333, 8000, 10666, 13333, 16000, 18666], "channel": 2 }];

function signerAccountId() {
  env.signer_account_id(0)
  return env.read_register(0)
}

function argsJSON() {
  env.jsvm_args(0);
  const input = env.read_register(0);
  return JSON.parse(input);
}

function readGameState(account_id) {
  env.jsvm_storage_read(account_id, 1);

  const gamestatejson = env.read_register(1);
  if (gamestatejson) {
    return JSON.parse(gamestatejson);
  } else {
    return null;
  }
}
function writeGameState(game_state) {
  const gameStateString = JSON.stringify(game_state);
  env.jsvm_storage_write(signerAccountId(),
    gameStateString.padEnd(2048),
  0);
}

export function newgame() {
  const gamestate = imageUrls.map((val, ndx) => ({
    x: Math.floor(Math.random() * 3),
    y: Math.floor(Math.random() * 3),
    attempts: 0,
    keyFound: false
  }));
  writeGameState(gamestate);
}

export function view_game_state() {
  const args = argsJSON();
  const gamestate = readGameState(args.account_id);
  if (gamestate) {
    env.jsvm_value_return(JSON.stringify(gamestate.map((step, ndx, arr) => ({
      attempts: step.attempts,
      keyFound: step.keyFound,
      image: (step.keyFound || ndx == 0 || arr[ndx - 1].keyFound) ? imageUrls[ndx] : null,
      music: (step.keyFound || ndx == 0 || arr[ndx - 1].keyFound) ? midiparts[ndx] : null,
    }))));
  }
}

/*
* example args: {"x": 1, "y": 1, "currentStep": 1}
*/
export function try_find_key() {
  const args = argsJSON();

  const gamestate = readGameState(signerAccountId());
  const stateobj = gamestate.find(stateobj => !stateobj.keyFound);

  if (!stateobj.keyFound) {
    stateobj.attempts++;

    if (stateobj.x == args.x && stateobj.y == args.y) {
      stateobj.keyFound = true;
    }
  }
  writeGameState(gamestate);
}

'''
'''--- showcase/synth.js ---
export async function getSynthWasm() {
    const img = new Image();
    img.crossOrigin = 'Anonymous';
    img.src = synthwasm;
    await img.decode();
    const canv = document.createElement('canvas');
    canv.width = img.width;
    canv.height = img.height;

    const ctx = canv.getContext('2d');
    // Draw image to canvas
    ctx.drawImage(img, 0, 0);
    // Retrieve RGBA data
    let data = ctx.getImageData(0, 0, img.width, img.height).data;
    // Only return R channel (identical to G and B channels)
    data = data.filter((_, idx) => { return idx % 4 === 0 });
    // Extract byte count from first 4 bytes (32-bit, unsigned, little endian)
    const length = data[0] + (data[1] << 8) + (data[2] << 16) + (data[3] << 24);
    console.log(data.slice(0, 20))
    return data.slice(4, length + 4);
}

// oxipng --ng  synth.wasm.png

const synthwasm = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAABlCAMAAACV4s0JAAAAAXNSR0IArs4c6QAAAv1QTFRF/////v7+/f39/Pz8+/v7+vr6+fn5+Pj49/f39vb29fX19PT08/Pz8vLy8fHx8PDw7+/v7u7u7e3t7Ozs6+vr6urq6enp6Ojo5+fn5ubm5eXl5OTk4+Pj4uLi4eHh4ODg39/f3t7e3d3d3Nzc29vb2tra2dnZ2NjY19fX1tbW1dXV1NTU09PT0dHR0NDQz8/Pzs7Ozc3NzMzMy8vLysrKycnJyMjIx8fHxsbGxcXFxMTEw8PDwsLCwcHBwMDAv7+/vr6+vb29vLy8u7u7urq6ubm5uLi4t7e3tra2tbW1tLS0s7OzsrKysbGxsLCwr6+vrq6ura2trKysq6urqqqqqampqKiop6enpqampaWlpKSko6OjoqKioaGhoKCgn5+fnp6enZ2dnJycm5ubmpqamZmZmJiYl5eXlpaWlZWVlJSUk5OTkpKSkZGRkJCQj4+Pjo6OjY2NjIyMi4uLioqKiYmJiIiIh4eHhoaGhYWFhISEg4ODgoKCgYGBgICAf39/fn5+fX19fHx8e3t7enp6eXl5eHh4d3d3dnZ2dXV1dHR0c3NzcnJycXFxcHBwb29vbm5ubW1tbGxsa2trampqaWlpaGhoZ2dnZmZmZWVlZGRkY2NjYmJiYWFhYGBgX19fXl5eXV1dXFxcW1tbWlpaWVlZWFhYV1dXVlZWVVVVVFRUU1NTUlJSUVFRUFBQT09PTk5OTU1NTExMS0tLSkpKSUlJSEhIR0dHRkZGRUVFREREQ0NDQkJCQUFBQEBAPz8/Pj4+PT09PDw8Ozs7Ojo6OTk5ODg4Nzc3NjY2NTU1NDQ0MzMzMjIyMTExMDAwLy8vLi4uLS0tLCwsKysrKioqKSkpKCgoJycnJiYmJSUlJCQkIyMjIiIiISEhICAgHx8fHh4eHR0dHBwcGxsbGhoaGRkZGBgYFxcXFhYWFRUVFBQUExMTEhISEREREBAQDw8PDg4ODQ0NDAwMCwsLCgoKCQkJCAgIBwcHBgYGBQUFBAQEAwMDAgICAQEBAAAAe/4hNQAALu9JREFUeNrNfA2YXEWV6NUou7r7Hs/1razP3cV9oOvT1TVxYdWFBIkIayK6yI8/w+gioHO7HTSuiBntZqJimGQgZCaYARIBV5Cg/CZhMj3VPUx+JkREA8MQu29XwkxIYEhqMn1nuu+tW3W+951TdW935wfR537fG0j3qVN/p6pOnTrn1Kl25t4GAOtW3KIBQH9dH1ivsp2wXmWz9KGz6zV+AAKdunO9zsL6KIu5Oqs71wOWQnyU7aRqy0y1zvWq06CpjTCb7cR82dnZ2UlpC0T2K4udgu5cL7OmRpTtzIKa0H7fquVrVt686pa+VV0z97OHH3hky8/Zhi1RJ0QL9Xma/pSuQAQgIxnVwlCGYagCHQAI0BBNy9koigAgAPoIIFKmmo5keAScKdPGYSUhqlSiEA6BVFFN1dTLUkolAf8pFSo1Gb4EkVJSzaroxZpSs9NBFWZm9MzM7KyeqtWkDvRsLYiqM1WozoRhNahWg2o4EwThEagc9P2aH/pBLQpqVX9WSn0TVMJIgw4W6r2dOof0+VnNGj+W6QGwf4jQR+cfr9Dv+eG82oKN3TTCtbP1jFi7ZvXq+9fdctPqvsEb167tWwnX6coKSt9B6WjSX7d69UM3d/WteHDtWviWrqy49eaVXbf0rVix7kd98A39/I/6utjtXWuW9/3s5jW39624v2td140r7l+17qYVt97cBUu0XNHX1wNf08/ftHrdD7Ys71vVtYKtuq3/6H7b9eHbb1y5sm9V14Y1t/Q9vGb16jUror0vr+jrenjNbWseWLey6/7bb+277cbVffBVHdzSd8vNzsofKKiqj+nZwxqY9v2NP/vJbT+6tbene2XXzGsv0OfpWeDA9U4FfgzJBKomUCWBhP9JrYMsB/Zmx3GiR2UefIVJ0etFbE6CK0XlsBQx2espHrGXe9lN3Uz2eEGvFxXAk0x0sSlEerVHZZ5LHvFaD3OcqJdlMsu6mVju1bjktY0TeWCwWeZ5zQLg+z6PihEPeSCAK2w18hkIzSMGQvGIaxHxiIOQXDlM9PrPap3luqyiPFcyz8HTTPeWgWsG2wCb0D1lVdG+b0e5PTpgoR2q4q/WOsueZoEIPc1hpxrDeoJqC02fihsOF1VKSl7nIFFrSGyPONccPoZIDkx1YU2ux1SVgQixyaRbSCDp70MCqqwmQg9MPzPcAj4Hv4ijA+Y4jgM09dS0B2wGKXY4iIDruJHZEzQyDRzYZM+YEkwt9/cDBzHF9cPUnGaqi0MvV8gln5BRlFXLous5nOsptnd5WXNFnde6PcXe8YXPvT56WOa5YplMZl60SeZzAJnClM9hoSe5bKGPcsjlwHfvrLzWcd6+oMVO0MmFVh4ODG4L//b++z5baGnlIZctXA6seeBNpw6mThpqGXhu39Qp35r/swWtLa0XTPmmjzm1B3FNOaSmkBEVO/0Ln3uT3IS4hRwWDjgdZ55xy1M/fluh5YuexJ4eeF35pELL5VwO3H7H/nUfF78Yarm86HN5cUVjkwdvZFfrHi9ihe6LyjUeseBGFnWxTLXXi56NquXqwIHdAxteVz5pK4eFnzFjj7qRErnyIi/g0bMR8Np1vDo4H3it89ql1/PaIP+ZvJ5XEei8DkuIwVNNZsirgxwhnwfXD/Jrl3nBoLrOq53XUvQZ8GBw6FpeGyxcu+wyT/VwxfWEX9Ylvyy5ZrpbdnLJaVJDM7PhwOLXrfqmOPzdQsvADy/6wIb77vvQAqe1pZVLHvKwpYWHA5f1b13yrbkfHGoZ6Pqrf/qbk2CUZjPkf8y18T1YgtzLdC9T3RP+Zcg00e/DNBwMxyDVXsDDljKOQPLgOAM04wt40NLCg+OMz/l92OX/hVuqx3LL7CtyS81wS/U6PovcUiVuqRpumUWggVuqxC2zgxwhn9cMt9SQW6qWW2rILdVjucVpYpc/2iqHr4L5Xg3vJdyCrPJWrapZ3ckEq4rQq5GkrZGkrZGkrYkjImIZIabLYZTnmmUEng4h1+KIEMRyZY2ynNd4SHV9oR1eY5kLtZgWikFZM1UOojwPxRQPHpJ5BuXIJqONlJRRngdM38jlRpkXRzzF5eLc6VNnzHd5sLjNq4rDYoYrXhWHhM+1B9Qpr42pKgeuhOASMZLIiHjQW44IDJjuKgeGOP+qSKnOKIs7IsQdIXkY74iQve/vP9omkVFDw7OP2h0Rsqvf9iGTIyn3X/96wVcwSZJ8yg+NTM+6U3hKUuk34nnscOAhS3/anRM9KrMcclsv/ljBxaIFDlenLw2ZRpq7enwvWpyDlb8quClP82hx7mvnLHjC9VSqDKEh5szoUdnJwfSUKaSn/LL2cUPhf64HHHIv/fyJhW7umotHh9JuygPqJ88h1cZViuu0qVcGHslOHjEHNmKDhm7EMgdwRxl8PUXg5olyFJcNOfghj9h3spttA5mKaeCtgMqIwZuUg0kquzFuIVOxLQCuEnOglx3sOodw/pDW2GLHSS1DrgdfK2vkz5RnhswhZca5du3avJtbu7Y/n3YtD1/KdPeEX8Hc06fOKKTFS375eIfpmAIPtpjTmopzGFVyifD9STr3RxUd0AhI4ftXR2o2iySNKShL/JLlgOmyjvJcYuMbJXFsTznk2lNM30gsHTHAjIjpbgfVnK6VZcVDUyyiQsiMTPOgi2kUGGFXt6dMa5JrcbAc4TeXXImDyNZc8UggzyfbzO6nyBISmf0U2mRo9lNAtOgbeWBaDnnQ6ylxsIw6HmWoXnGwXDW0416CMVXxZvGrSn2/wGf57KgCb4ZXRxW4mJAISjclZvgsnzGJBA9uWvh45IoXeI3XRpUD1EBazJi0pKKmEJanXGyLkiY3JWjT9tpNG/GwtxwaELdy1KAz7ki05R1K+K+PtO6kPYkSkoC7JnDSuaJNh1vi+wMpT96JMjnkkY/skne5aisrlY//w3nuOSJBq0j6OBkHuKIWMoV0m2cAJBlzEl2OSomJBmSVYMckxiuRz5V4qRxxJV4sK1sBM+e7OEQeptu8yHTiybZ685kCj1JcttlODEalPDskzJmIiZRttlfekDteUX+cruM5OF7XS07Ut3ZeRedxw1GbJ5u6VykeNY88avPiaeYy6VGM1zliMrGa6vbEAf9qrXUWTaYtMs/G2bQIyyQFjtXKDTARA9UYGI+BfWycHUEtP66r47o6rlu3THLgmMoWtS8GOFIm9nLwx4E2XiyrUMyQwOodVeD/d63CrOpkkvnYJZ7MbE51TAHTPd7x7I8pEXrKmB9cCWC6DFHeVOEklzRJM3ZylVMbSnjlkFLCKwdMsIoIPbTpygK4+db2W9nviEdIgCoBD3J/Lp8oiOcRUz0GI1lUAu6EDagKoRKMlW2cDnOgTa79syMls7qTyhR1CS4pqhLk5s57ZMi9ZD9b8mIxYpmMZJEIi3LgZ+ed9YD6T54vovQDlsnoTTJfkjQdvaXwgh0KSuHAhkNfefSd+uRCSzFs6IsJFqJpRvoOkL4DpO/gZ8Q4GoieZlwEtFjETFSGx2VKyBN5kiybB/HzzwbbLinWSjUxW6zS56yoOMUZ8XKxYpaiVBlTIKaYugWFP5Co5tCz2IxPTOZgfnbA5cDC1YvFi25ZUgUO4iDHk4pStg0OPYhFpk2GRLukVPEUlfD04rayZIAdI/GotCnbnDjQOOtK7D9hsRj0Ih6hzJaumOEES4Qbuxel4rQoFY8028dOI4NOGpOe7OO9plTdgcGBHW7IP6GVLRsKxZv81gRan0C3+TvsMX8rfqxOzgEopF3xrM2yCsaoWp0yBVwxmjSxOoFu8KuGBWJ9wQqHTIHrlBj3FyitjLbAYTdktOykzJCDM6puwPN1VC3zPSV+Yza5BbChX9ttb4BqnFWJgWqcVYkBEWdNxoCIsyZj4ECcNR4DB+Ks8RjgcVYxBnicVYyBsTjr6RgYi7OejoGn4qxdMfBUnLWLa8dAO+K84RjYERcaRiCZ6mX+DO3IbZCpL3CXfwf6UybZgVgU/g7RayUvBzEbly0cU7YQly1gWfLJLOJ6kVuCtkuSo6R+qIwnEE+gYgKNJdDTCfSUv19rJ8ske6FOd0yT/zcRjum7mh0kSXRataTEE2IXCaQkgTJn4axNoOj5XJyIODB3xiZQ6r02ztnJgf11nLOXA5sXJ0Y4sM/6NrGDA/tanNjOgf1lnNjGgf1DnNjKgV1UsYlhDqzNJnaqXRzYKUkK23tvksKSF0lMOeLxnQol9L9QElMDHNh5UZzazIG9L0k9woG9W8WpB9DzmaQ2cGB/q+PUPRzYnySpu+NT+tkYGI2BsRh42gI71E0x6pcxsDsGfsVBPEmJfB6rimdMTgGrUwIFNpYXT3HIsfV9BarzVFIvU8BmEeF/SinlZMNOtDs127scLehMRm5aKUnb7NpiHHYLyJprm0JVf+9y6zEhctqmfPYjVJ8w9Yh7blmHpg3rWZmKk1F/YpbiWcq+/oZPq15PWw/In3/zPSdFvecYFRbdPGQkpts8siIjHrnlgGt2cDnaf1z1LvZk7vTnNjzhoqJmShdcHrpemDqXZdZ3n+PVUjxMoZ2LJnfuTW/56pCbu/ji0ULaRd9Qbs8Xbxhycy+/f95Q2nXSaTftAa+lc+/8S/kxN42jWf93Q26a12JA5jL8yiE37b9OymiZzKrrdSfX3yAyf4yTRdBPzNS4U3YvFwjxVSyWyZq5d+6esLmZBT+x7lAObTHO1Ijrw08Sh+mxGOzpbvQY372ScPOziDvXq7K9y70QM9p/0m3sL0uN6/ncb7+b7e0q1zgsQUVTn1sOuFONfQ3VeK2yCLymZpI8sPlmYft5uHIi5FWZ5VWLkVkGBuQB27t8IuRh3ESolnFY+BFvZnDun85Z9NbUpX9e6Bzc9a0yGmmzg7uu61zgqcThdDmvw62f9xRXLeUo8ZhzvRAtHh618GjgSfbJSy+76oxCy8D/+Kd3Pnjffe8utPJo4MvjsHXtr88ptAw8dVPuB1/PnYVYHrW0tLa0DrzmO8/0PfZSLd/CZ89rbYm7Pfma+c7t07A/7jib0NCeXzsN+7HLL3rR5cZRptCEG/jq995ZO2fB+wstAxvPmqNyv3lroZXLgTd86i3DX1zcUWgZ6Ns/Z94bei8qtHKFLq+B2zbv2Hdmf7HQMvCFS7es++bJ92EOV0hWfbwf4dGFg7uuW7bAv+Bc37e+HnT74oyil2jlOf5O4FDSdj1TudOnNuVdu7ZaHOZaHEqhEkRlTDrtCt9/k9ZRYmVwJmIrg2W02COAO7GSmdHityjIRUUYvwhnuT2pTQVRQJg0yVbWJvLW6uAs961/Wff4Mbn7WJW9JEJPxqaIjM9DaWQV48AlSf+MEs+JEa4blSm0MjzJXhYhehNJyw0Fejc0+eSMThJxQAt6TMFhBUKgER671uL7km0gEyhMoCCBRAI5h/1HIJ6gQ+xQMkGxBp6jzwH63MKBZWNNmz77URkE8Visjvsr8fA8wMZPPAd4zstYJ5CxTiCZFDspiWKhBG6brYi6HCX9OBlRskrumAku/S3Axtl+EXIQm8vAqmziWG0EydvJITfzrtIw4agpTDrDYhNZfc8h5RW29/hXQ4kR6h+Euo5pZVe6TcycWDXmx6jG26NqAgl/I3ZcZMX4Zo3HN2v167OHksTJBfFg3WLV4lFkIQ7iOdJdJgENLczNuZfEFmusrY3739RQ3wslu9ROfa3RsoSSPSp/0XapeMAudtluiiarOwZ4DPwc+zG+BPT/bhJkR0uyQqPYwET2H+d1qp72L8A9yp5ingjLmgn2WzSYrb2r4gVQuT977Ybh3Nq1bx0y6zd33jxcOXQE0aLOnTfv8dz3Jj81FOdEZG/v4JpVxcNiO01qWWyLJ28D17mbD3Vsy13jnHXj4zmAMweNAnE/uRP1mCqiQWcN9CIH8ejRZvEuYJyVDeN5YFr73uRvhgxvISQ2IdeJ+5DBxH2o5xk1mq4YiZPEvYmbgeterrYB+AdO4Cr136zB2ifM0d0eju+eBifZfHiM1Jda/zTeyJ4O/dOKazbTPx1VJF7TOLqbzYdNdDZqc22ApqUTGzQ/NSKGQE8Zv6wSn9AWyaDZ6emjD81IQ64W5QBeM9h2rLxEb9fvKrQPr5GMfRQXYb6/Hud3T/P80tSuXbu2kLvyqqvs/LJkX7eyHGQODOR+/rHrC+J+ErNNeTCR5OFa/FQr3HnPOiitWCQeFju45CQ28lf0cyXupzsQOaa4vRUhmEfECxY8iG3nxSONclj6d5imnyFRFFDLOjfzrs9vJSbLQX68H6FCnd14A7txy24WxC5uYuKRZvabQbn3axGKst+JvY2x3zT2Ju5Eps/dfCjamrvmrDc+Tr7W3JuWZY/Tp3P8TvNX9B/V6ZgqMuNj2ZyLd7T2B1CCcbYbN27u4Pnv3WGWiT7mzptnlkmJH4u99DnClVlSrvEA4RrPj3gMvzruGDq25a686oUhIin3w3Oyr37enmInHMJXBpIhOIk84vHS/ZIIkXbpiASSMQCtg+Ysf7UktB6zdP8rgrp7u9nNXSU3d4gRRIyzMXJrHjOlj5gp1bnPfGlgOHcNCrArr3qhIO4We4+HNEfEZg/YWebIPouO7CnsYZR6mHGQNXFUZpDJ5tLiLmxT3NXQyBC1MZQ08fTvINJuXMA9+9OYyGOQ9fY/bIj8sCWSAzsbxHoC/iUGPhQD/0wAK7KnGqnI52NS8nk7jnU0jnXYjzkB7kg6PANEv8Pp24ypyJ48/pjmxbNyO7V2+/FaGybqh4mp+028yRPWqVluPGityxb35ZbkdLQ+2hzAi8kGqx+WY0Ym7myQidHWZgIfT2RivPOHcddsaZaJx8lzrFAcQLEychype7weOrbF4nVzzu5LUqaeB3vbmQP4j7PwrjOPgj4HcFrO9c/X2McO24dGXnn8OH0wzrY3eYOb9JM1f4h+0kQymLMhVlQcaZejLtog9+zd1yywLqu9XPsfIcq3nohy29xOVmTDr4JycadVo8tCvjLZlsVekf6Y/AbGyc2dt2QBXnFY8k8Q0YSBVl9W2pFZE5mC7gbd7Unm6H5Ji1js2kSXvW0UQKK7PM0y7Zd/+QcPk+FvE48tcuP4kswN3XhpKrPNsR4hVkbFnc12/ajHkz1dvrm8ZWm6bdUsc+b7ag/KrIVs7wDGtUC4npBrH+8d6a6+x8YXxDXzr1QTr+jxKqfa9SNP9WA4CFc0lExG9nDJnINdK1EKc9mznEsGGyd4tPIcfxRKAfuLK676mlzNzjsVeq1ToBiUgsXiFpqcNmOXJht1l/8hrRTeE+1gQyRK7D7i+Vh9jcVjU5BcIkvY7E509xo99DlUW2Nwax0ctvaHuDkWPni4qVsW00W0cSFbs3EMze7FPCLvVd5Fm36JKybF6tiLvAoznC2uWM3p8llZgzJAlrnJyJ1CIhUsBx5XKsy86/PD9rRGjeMeJ1uXOyRyrAZ0xRZDvBE7G43heDbe8BxlgzRsod99F8jBvwHY02w+JMQetUnriqNYQYr5CiTAUOwQbXhsxsV2sCoel8e1KNE7O45nUkiWBfhfC3SULU2VNRtj+8iMqZL+oKwNotgMa58RgyYIs0FxUHXFQdUVh1NRrVR168OCSVajTsEo5KY0xUAcZDX2NhCLtU3N4GQkqdOBjZmUZsBm2MkzYpAqaqzosBGb2VRRm4pPmpRinD0nQjbL2n1bWTX1qkzxD5pkGdhTbJcIWcAu9MWgp0UfKXd9pNzRfK6tm2XAMHQV24yozVHTZNRET2Q6ONsmJQOm2PtiYiRVfEec2VRTmpqTJhUyYJqdHFcMxUGH1dg+m0kVn6wn6lMXMM62iZBp1l6xdQPq9H22m4DqfrAhdTrqBHY6xtjjlqPKZKHiN1qoU+zCCk7QmOJ11YAY8XmjuB6NBFazk1Wj7k0PlKgPuda0eFUGLGTvi8muUj07LEw4M4zXU/UhzxpuievNUr1f2bym/mZNvQ9g0n+h+TKd9B7ZuxvAX6J1iJdHHwZ7Q47nAlAwM/rkFF384mdkNougZkwoTWTD05KoM8znIJbjFTx0c9nFo148gVitFyOFWEZ3T0Mcu8I1i+L4OMVDEXHlX47U4K7ucrwA75kx6tXTEhXzoFzlNS/iun8aPRx4MxrleRVjiryQrD6uPWkICbncDRRQXcXTqYqdhLY0Yrwqj3q55tVeU4wMabz55oocQLWdaN/jFx5PwU40vNErVOHaPwQNwQgmEPm3J4pVaAqt+rXxbZ0Zz7TGqEg7u4BwaZyD+P6YqvSiU1Sh31RnWcgU+yDK3hvwZJH7UQ6z90QM1W/WPi1uED8UP0ApxD6gDTJzOEEq9naLPPVQgozYPLDIyQQp2T9b5PyXYmRxnNWYYmcc3Tumv2c71QmsmErgiEUJLFnE/nLSJkIWsXc/axMBk2z+kEkUnz/K5eJYzQi9Z5PAj3EH+sL6YYiXsdTORgRFrpulQMcJkz2kjSBXh9yqarJXaN/fSgF2VFVkcWVGlXDxs4ofFTdtImvoetIipZsWGc2Vv0fbSDiRNWE8ifOtYIroJVyl/UWRjuwdOIbTUShdGq3DYeqoy/WU+K4RvmkMCaR7cKeOIn+zuQH/rk5TJJy9B8ekzRXNuZPNuQeac8ebc3lzbrE5d6w59+nm3Keac3c15+5ozh22SZqsPI/Ed7QZ8ABXCBN+s8E7lPFIQ8YDDRU2NODvacDfHeM1EjCq1ruc1vQ2N20mH0bVTS7G3mmTsd41BW0BGRfw/Vvs6h7AZdeuBSvEBnhRR0lhucQmqX1wUzYpDbukkE6qh+oS18hSVJCUGIUhvP5PlcrqTqMz4j5QGx2KUCS2URhoghyAQUYUMkShRFyLpfX/2fxZroTn4uQ36I/Sv2ZWBVnZGeVLh0jVKaGY/qmnjWjSYpGW2ZKIn39g6LK5YUBhSpW0qdTokkRpj7JUqBLFOveQ6iOMh7LBQVk6xHRP8RDFVWFAa6IulV6iyJ8XOXrqjTP06J4c6/38uG4O8yTNjWG0dWmKpibEGE3JJc5/iNwdiU5cYgMbibGaUwFpkUz3ehpL+QZhdZ/VDb6gkFV7UIRrts84dXcZp+4249N9rn864po93j8tKyG1UhlVUA4sJMs16+INjZJpImMphQGtPBBtOl0OMDrchJUc5DVC1ZLROhiqTdYCA9tMz2KRxwvpWgO6GKOpqQoPzNArvCZ89DrHBAU8HFVjWAq/qjHJRl6JFl2eNb2ZRIC326NqzFA8i7e8BVd8XqfFWpPztCE8aMjZYPqdxfts05ClJODVGIMu69JMacYuFlLgEWUCt6XJwUcUiHFwI6L32hbcH49lP3qrLYyW0ONu2U5tPChCiqW6bOc3QDiI5yUmS+AGSRiHNjBRgoTX+YV2ssX7CEyWA8os10oHPW0Ei7QxvdqIkRqyFjUQuOVa6UBjMR64R5dEcsT1Dfu29ELpgOhwdOngqJIlpCBdDkr7bTOIBcRCuqGlIC380n7iQvxC8qoiS4qqW66WZhN4tlTlVVoCPKZKs3yWZp0S07RY4tu6HJSO8BqfRTg3d16lgOPYzwMDi5nSfmSw0oy4ngP1SkcudbxDZWTpoLi+dEBcX9ovrucRU6iiAZN2+/ujWmVPKJHwvsNICgfLmrO+yvVuCOkG5OSoQVrK+GLAXM2Kgx5eS+bwcqDK4CGZRXUwNBc2/SEDX+ZLL9PLu+LLFFwe0Y3YtZrLKb/hCqF0qCTEVD9Kpym/dIgUXlXvUiVdogiizrL9pjNhOnuYOiPMYYN50HYveMQlhbFHQqGI7C0eKr1MijTRhHe70vh5HMsP2Ll9H3KiMXOFnZFmMKYqj4RM+6+Gnomyarw4UUffTRkJbOLj0O8UGTgSdDrGEiTH9WLybAy7XuimjVfDCtpjakieFEGubzgukoVRdmGUI67FB07+ERNeOEAn5hb/rdpc9k51E1+drLs9YO26396xwWPddDxE4iCqAuKb2gPjKONK/Kv2Q1MOr9PbdX83mSf9K+MqZTh2rVXDakd1hjJrAJ4S97L5YJRXxfI9uwHYfHgwuc7DwhjWG/JIfEL75tEWbXbl+/j2g12Inr6EZIWWm+/7We1EuFFEfIRoFq0ugzkkjzqWS4dxcnaDFPcgyPA2czeENqUoFYh7QkpCUigBFYGN94ulw2iVoVMyiQQ22nPMiGQRRjQ9GO1jbcLIvJ5IFNPlnjI2Iat1d9FMkA1oTUMVm4ZouuFk9npmc2GwNgfuRCzq9SJU3TVX/XFOiDNHs+d/izx9yzicX9wb5UvPx2Zq6XmuxffLgLYVruT3y6q0l7o4v09mDVg9f63ZlVyV9nrySxjy1RAUJJPUqYXL105cTFV6xNd1SKbb13XTdexZZrJoxTdai8OGURt/lTKzpxpmTx09e8qj7ajM7EViuUPPjsikbpy36Nh5izZP0zPiXmMLh8kCGEDGQCiWi2/gW6KIZhgtaE8JbWbzOq3oZW3DRKr6VNpJu336eLNa2tfa93vO5DX1GcTexXW6tLe0r7W41y9C6Xm0iT1wuMKZM5HmXJUwUteayhR/zCKxk671x9Qkk/3+ZTq53CMcvlyJVOQbtZt0dkijx3JUCfJIrre+6gwGvALTYiepHfXiMmWLkxr/YxNshwo9FldYXDcWr6TqrQP8OPGEU3EpdqJfd1QJa0ESPdbATJFNKNPmSQcGVnPl/9YhYfdMVL3Y2gc3l61ItsHSnaJN+9uVXoblqGRDaFureAiNnWci0VqvH5mq6Olb7X9VK9WpiHN5ORKr6O2CcDXZGsLVrlvWxvhAS8M4sA0FVfEVY25Zk3SpTtPhASZ6Q9pDqsglijXRps2lQfwo0WwVY3WLL+s4jnqp9u9PpmaSw5hjbC/dbGmJBvss7SmXZj2xzBKbTXLM2seV/7ZIRVlJMaeRvUOg02/vcnyNwz588v9ZQm8aVfNrx8jGotKR/GV8+PhovKT0wpGr5IEjcg89yuo59nEjV+bl46YJTy/2IJfppueN+HgVcu/904MjridTHqS4TJVlaIi42j5CdugdQ574zkbdBS6Fq4qn/nGbm7v12upH0q59NFTjgZsiDb7GAzyV52O9wE21UTDrFsO+PHB5mEpROGfAZcrlEiNX6Y1u1ohZmWp4HZCia5z4Pgoy59xlLFTzdCBlHjBRa9LeccQPM/H4M68ayfMHm7lmOzaurHeBRAOHtJlRlEguqR/9EyYud8rnjtmf+P5S92BTZqJMHJjkkE5xzSY3T6R56Ppf0ErTM8Vz4/BSfQ5yKXvPOYv/hN6N0pXTN+Wj0r6OU22GjDC+poA8alRpcaW2AcEpH2n/k//4xp9RAzbTM+/gsICNN5YPYq6ZDSqwpKEEijgOV/s/ULpTZ81mdIn/x92yFqu4tvvKGPfxDsM95dBG4g2qJ/ptkk3VeGVk3kRcpcv6mA2m/Z/YFxmTwtXGTMKnGcEiXK2TWZt9kCau0FxZWsZtwvi40NiORVaa3oYCbTH0mXxL//7jetXDcl5pXPZtxlKdO+NrX9/u/tdS8uoIuWf7x4dd/y060lnZidqJmXMsuosm85noQDnAJN8fXxYaL4GV3K35lvjRSOfCFg6OeVvSubAVPePmEVTtwkFnquMygQYhhl4zdcv5yTHbeoFrfG+kCIyhCtlzbAHZ+FidDo8DydFRgoWfbxW1oxc+4sptWHtJSd9/MnGIfkXHk0wCXKeTybIHXcVy468h9+mLRwv4scA+3eb0UDufb0sZObPgrgl7ODt3TpA3OPbzxg4wowSA2ElPm/6Q94t+OlIRnYBIZSI1JG7ot0n7Sw13m+Mg946pMwpcXz3lc8r/UxLRsuknI1i2HIYcvlEGyjh1TrQJH9iyTGb+SQRaaZcpmEGSdGC6HL9mT8Wv2tv8kKqdnJGbZKfDlC0y3xaZX7BSti1kUTm0TybafJ8iS5MnDMpELHOV++1Fyx53c9NvPDyUdnOXXHzxUNol/GOH3vERN3f1Pz1yTtpNu/Q8m37uBrjCX6hojJIK45fAuR23/8UQV7k1Ixf9KsUhlSpDReL8bCpwlbu17P0yxkZ+7s6rv4fYj09NJlhl5xLLtiRY7ZtYzKv9tykdZZseGzjIPXSi4Akev+7gID6jyXjft5ypbjzeJdu7HB+Zy2Qpt8iYfrUFN3P/yi100it06ykW9U8riqac8im23XzNn/J99FTHrURbpvEJqH16kM+97QMv5rFcARvq9qIJqmuOlGjCMMWcWv+EeZWv8FF+zDb4mkGatk6B3kdXYsMmB5N4mYy/Q2HPJ7y10G3fEJ9xtF9uiFzjqv4qG4/eJZZ6DrnffGThInO6G5DwqSkf6In3AvpZAEOR//da16ifDNfm/XcJ2jyV8iJxuBzGh5knxeFywCNxCOdVHMKXHOQxsxxoZEHgponlTJ4y6iyvuWnUc9x0uWo1ZxIC6AcwihxWC221iq0mqJrCarza5gWosCgHC4VcuinEKZQ8X6WXw4oH4jJDftuSEk6XK/b5a0lz5voK8aD1YZAifPkFeHk/psYT0ZDAPsriZyLB1fm3Wes+DoJuDsxoCA73365UhMeNFmuMZs29gJzK1zJ6CDuQTuJqcR59HuCx8zmN3xX7DeKz5pvCtSWFLaYbwtIqhNf4fP5kG7nblI3XPJG4lMTrAR7dLfMY9d0W542qyZQnKRDVter54jYyOlVdX1eJvo4nX2gmiRJeEIvTIJ6z5hNxDMnHb3rOrM3va/BmEm0RfHXwqcfWFdyF4hJNgR9XDdXJPNAWv2s3jz14JLjvf0LT4TKqDjhc3218Objudl5MXKqJcabl4uyuCQTyV/TfuehcpruY6mGvcZwfPjzhqaOnTdO0JfNkljCmVtI3VxjZMqaqxFo8Shnax1R8lvixBflzcwR+Tvv/jWhG7+k8fCVDSkhMOpUSfxDpTp0jaKqtjv69yVXHG5M4OmEsqnis6ebBiqMHzV/doO9IBj0C1s32Hzr+kYK/3WIimc/X8T5rxkxivT12p3IlPt2gi0X2h0Osf9LvoHeD0f9n7wYhOcVJzJlDN0ysI9RpPLwTDZvfA6L91vgeMJ1Gu+fgjclbw8jYhWk0zSDNI2Mzph0M3TDbQdR3w3hDDOIfuBtkI7PIxt2QMIS5D29kCN//K/opCTR+4zuzcv80JEHVe8wFWqGfa7azHwP8RhDc0b8S4a0IjxH6aQSf7F9J+FFMPEX43QgOIX5a0jMLx9zF7Y8PbeShtOE3ZE6MNzO/hDHenMRcW3DcgFNNtXmCOWAhfHRVL+O/DPEg91tm/U//lFcY/R9r/CtXToc0BzRumgBlJoBelhB5Ket8pEGmtHX3x0M1iKmk7NRRtXhTiQO2xG4IttRL+pfMKtmJg331/8XTwvb3HHluStAf4IcWNTEjqhUhfDErhIhkKEQgxLQ6IvzYWjJGwwFxtUbDTRlzFBOOW9aVw37dqjI2LIZFunGlCxormYSuHNv2BToukSanUWwNv2aw7UTl68XM7WNjH805unLklRsAyAw1F6P4TdvmAbzdJgs2bLZgQycxYcPEhDXXmtYyDY1lSheX4ktafPmoPkrH7YM39nGCLkRDFxUq0NTdZNzdtM9B/Dvxkf2yne/99v8cIhWP01oRZOaDwJShLi3uqNTqlegUbVgdh5YnqBewkvZ3t2pW4YuN3PFFyx3HNkf9xSv3hcY6X7B1Qhxfa+P4PvOlga22zphYZXaXq+k+Ov69H6NNjMfAAXG5jtu93AazkMVNd+1kvFFQrFtnUc+RZIRTCfrVmIYSmBVvdlreRUaxR3YbccVLFCdHeKpdAlK6HnPTl+CPn3ab32NAstwmTo1H1eQFsvoH/VqLhz6hSuiDn7iR6hNmEuahWWMLCuso/3jupUpDaTsVmswDJMkx3cUzoO2QjcmBKf/SKjkC/yvlVKOuw/UirsTF8XWpSVQaS+lFYo354bQD9he5vr/F5XpRbu3azxREvi3WkU6UWZlqbMw5pjXO3KOaAMLQ1j8uEbkP8Qz+NFUOMltNbzPv+nwzKfSu5ARFaJOfeHSvN+WvvOqdcfnKK5R/8y8+NkRvVNbmXPFpXfFfsW0oCCdPr8FccZGuzMSF/01PHQeM1dEfBd8fwKdnOfEpq45eddIPEgwJnKPU108O5CDzjwMN6msdQwKjsXwpds/L3C9/uQK9Mw2aL5e5tWuvqyNJdDT3duGV/cjcgp0NPWgxfj+HG+/MgXS9+/f9e72Ic3QZ0ga8qKFR1K558i4h/umjaEw9Fce+I4x0LOKwGH3qdHKlxRq8oq8HuEf2zfUisYae6KTalhjDX9w8ddx1KpofYrI/VLbAKmQNsFlIksrikyhGXj/gigvr3Js+Ue6YVXLHt+QcemH3fONAufjc0cs+iWT9wlLTnB2L7c9p/zJUqk8gFbyeI4cgoD8dREEQBoEMFK6+uNqccFcc7+uL5usLtptX64v+HT78UqKFsl86/Ulgw6fq4/q09r+jtcqKIpsP7EWKdZ9PL+CLU4yL3xYFOxXEnuJh+hWE4mRpsvhSaZJlZG/xRVEpHhSV4gExVHxBVIr7TYT+rBgsTtAPitnQOyhNNL3HFjeKZcYnknfy6Dgu7vP9xZVngGWqPn/2pYGHVnWc1DL/f+9643vvfW4Oa88NX9V2x+nrPrTw7z59+y9eA+yiqq+fBnZu1Z8Uxv/N8CfE8DkVbhf87R8qcErVfwl/bB4L5SWAgx+YkMCWzPp6HNgVs76oUBuZQvKPXTRL9T82W6/fKs0/LBwBO81UP2XWn30eAKr4e/3A5hjstTN1rAJ2xYyvh4FdOuP/Fn/Xfx8A3AiroA9ugJugD26HLuiD24DDKrgRVsNqYKfNmNYb2omAzTHYa/06VgK7wifspQ3YENi5BntmAzYA5pxm0Kc0oGvA5hjstZU6tgrsioppuAE7C+xcgz2zATsD7DSDPaUB6wObU/HVmzWwJdP+u6L34Njbd2+Zq9pHfgXtW7dC+9CTl+kL89lyZgQVBpjMDMHV6sI8QPvWJ4BKDW2fyGyF6cwIPJEZgi9HF+az0D7yJLRvHYb2oZ3nqcwIHMlshXJmCJZoqjqyFdrzO6F9eBs1/had2Q2fiChrz8POA9RXHmqZYXjgwnz2Mt0+UoD24Ty053fdRa0Nw3QmD7+5MA/vV+0jA9A+zLDF7swI1cLac5QhZMB2NfRaTbl5GMsMw5mGkOEnoH37ALSz/Fws3pvZA6cpamA7tQ7tuwuQYTBXtW9l0D6yE9qHhnsyWyHIjMBEZggmLsxn55r5MHOBw57IjMD1ma1QywzBewwZW3NmToZ2LlV2tn6dGYKP1+djeBja8zQfTvaJzAhRidSehpMz3Z57ENpH7v22zuRgZ2YEUqbinoG5qv2JJ80ghodoEBcfwazMHhjLPAHTme0AmWFgbxa+Pg3YHOG/X3+A3vGV7z87cMfunVw6BpNLy5B1x3xwn7l3YukYpPXSZ6BVu7sf/VLojt1fXrob/iFynxsoLx2D4aXPwSZ3z4/PCtzyxmDpHuhbWoatbvHeVr20CJ/S7p47rwzd4oYjS/fASXJpESbd8v1frS0tw73u2J3gPvNw99Ix8JY+Ax/V7u4Nbrh0N9TcsY2fVUvHYMx9bvM/K2fpc1Bz9zx4mu+WN08v3QM7l5bhdrf40Fuwiz53z7pvqKV7YNAtbrhILS0Cm3fI13OAnXbI/xv9dgB4Q5DatbOnYxfUUiM/z3aMwPt1auTOs3XHCEyktv8027EdMdvv7e7YDulKate2TR27YCw1cu9VWORfdWrktn9EaDq1/Z4bOrbDu3VqZAOkhh+aq1K7tkFq+0NjHSNQ6xiGj+qOXQAd22FuNbVr+K6OXTCZGrm7FSv/m06NPHqaTm3fAh0jsER3bIezdGr7g99G6Ezb4sYbOkZgsmMYztapXcOQ2l6YN92xy4Fcx3b4iyg19NOdqcJjPR0FWKQ7hmAiNfzgvR3DwOZN+vpuYKdN+g8+Qu8Khm+bq9KD+76tvzMIZ+r08G36O8PQiPrO8FGlzjgBil30ErV97kv+xsf+aG07v9/f/wXsk0VfhQ1nmgAAAABJRU5ErkJggg==';

'''
'''--- test262_errors.txt ---
test262/test/built-ins/Function/internals/Construct/derived-this-uninitialized-realm.js:20: Test262Error: Expected a ReferenceError but got a ReferenceError
test262/test/built-ins/Function/internals/Construct/derived-this-uninitialized-realm.js:20: strict mode: Test262Error: Expected a ReferenceError but got a ReferenceError
test262/test/built-ins/RegExp/named-groups/non-unicode-property-names-valid.js:46: SyntaxError: invalid group name
test262/test/built-ins/RegExp/named-groups/non-unicode-property-names-valid.js:46: strict mode: SyntaxError: invalid group name
test262/test/built-ins/TypedArrayConstructors/internals/DefineOwnProperty/BigInt/detached-buffer.js:46: Test262Error:  (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/DefineOwnProperty/BigInt/detached-buffer.js:46: strict mode: Test262Error:  (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/DefineOwnProperty/detached-buffer.js:47: Test262Error:  (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/DefineOwnProperty/detached-buffer.js:47: strict mode: Test262Error:  (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/detached-buffer-realm.js:37: strict mode: TypeError: out-of-bound numeric index (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/detached-buffer.js:34: TypeError: cannot convert bigint to number (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/detached-buffer.js:32: strict mode: TypeError: out-of-bound numeric index (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/key-is-minus-zero.js:20: Test262Error: Reflect.set("new TA([42n])", "-0", 1n) must return true Expected SameValue(«false», «true») to be true (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/key-is-minus-zero.js:20: strict mode: Test262Error: Reflect.set("new TA([42n])", "-0", 1n) must return true Expected SameValue(«false», «true») to be true (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/key-is-not-integer.js:21: Test262Error: Reflect.set("new TA([42n])", "1.1", 1n) must return true Expected SameValue(«false», «true») to be true (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/key-is-not-integer.js:21: strict mode: Test262Error: Reflect.set("new TA([42n])", "1.1", 1n) must return true Expected SameValue(«false», «true») to be true (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/key-is-out-of-bounds.js:27: Test262Error: Reflect.set("new TA([42n])", "-1", 1n) must return false Expected SameValue(«false», «true») to be true (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/key-is-out-of-bounds.js:27: strict mode: Test262Error: Reflect.set("new TA([42n])", "-1", 1n) must return false Expected SameValue(«false», «true») to be true (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/tonumber-value-detached-buffer.js:24: Test262Error: Expected SameValue(«false», «true») to be true (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/BigInt/tonumber-value-detached-buffer.js:24: strict mode: Test262Error: Expected SameValue(«false», «true») to be true (Testing with BigInt64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/detached-buffer-realm.js:37: strict mode: TypeError: out-of-bound numeric index (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/detached-buffer.js:32: strict mode: TypeError: out-of-bound numeric index (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/key-is-minus-zero.js:22: Test262Error: Reflect.set(sample, "-0", 1) must return true Expected SameValue(«false», «true») to be true (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/key-is-minus-zero.js:22: strict mode: Test262Error: Reflect.set(sample, "-0", 1) must return true Expected SameValue(«false», «true») to be true (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/key-is-not-integer.js:22: Test262Error: Reflect.set(sample, "1.1", 1) must return true Expected SameValue(«false», «true») to be true (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/key-is-not-integer.js:22: strict mode: Test262Error: Reflect.set(sample, "1.1", 1) must return true Expected SameValue(«false», «true») to be true (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/key-is-out-of-bounds.js:22: Test262Error: Reflect.set(sample, "-1", 1) must return true Expected SameValue(«false», «true») to be true (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/key-is-out-of-bounds.js:22: strict mode: Test262Error: Reflect.set(sample, "-1", 1) must return true Expected SameValue(«false», «true») to be true (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/tonumber-value-detached-buffer.js:39: Test262Error: Expected SameValue(«false», «true») to be true (Testing with Float64Array.)
test262/test/built-ins/TypedArrayConstructors/internals/Set/tonumber-value-detached-buffer.js:39: strict mode: Test262Error: Expected SameValue(«false», «true») to be true (Testing with Float64Array.)
test262/test/language/expressions/dynamic-import/usage-from-eval.js:26: TypeError: $DONE() not called
test262/test/language/expressions/dynamic-import/usage-from-eval.js:26: strict mode: TypeError: $DONE() not called
test262/test/language/expressions/optional-chaining/optional-call-preserves-this.js:21: TypeError: cannot read property 'c' of undefined
test262/test/language/expressions/optional-chaining/optional-call-preserves-this.js:15: strict mode: TypeError: cannot read property '_b' of undefined
test262/test/language/statements/for-of/head-lhs-async-invalid.js:14: unexpected error type: Test262: This statement should not be evaluated.
test262/test/language/statements/for-of/head-lhs-async-invalid.js:14: strict mode: unexpected error type: Test262: This statement should not be evaluated.

'''
'''--- test262o_errors.txt ---

'''
'''--- tests/bjson.c ---
/*
 * QuickJS: binary JSON module (test only)
 * 
 * Copyright (c) 2017-2019 Fabrice Bellard
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include "../quickjs-libc.h"
#include "../cutils.h"

static JSValue js_bjson_read(JSContext *ctx, JSValueConst this_val,
                             int argc, JSValueConst *argv)
{
    uint8_t *buf;
    uint64_t pos, len;
    JSValue obj;
    size_t size;
    int flags;
    
    if (JS_ToIndex(ctx, &pos, argv[1]))
        return JS_EXCEPTION;
    if (JS_ToIndex(ctx, &len, argv[2]))
        return JS_EXCEPTION;
    buf = JS_GetArrayBuffer(ctx, &size, argv[0]);
    if (!buf)
        return JS_EXCEPTION;
    if (pos + len > size)
        return JS_ThrowRangeError(ctx, "array buffer overflow");
    flags = 0;
    if (JS_ToBool(ctx, argv[3]))
        flags |= JS_READ_OBJ_REFERENCE;
    obj = JS_ReadObject(ctx, buf + pos, len, flags);
    return obj;
}

static JSValue js_bjson_write(JSContext *ctx, JSValueConst this_val,
                              int argc, JSValueConst *argv)
{
    size_t len;
    uint8_t *buf;
    JSValue array;
    int flags;
    
    flags = 0;
    if (JS_ToBool(ctx, argv[1]))
        flags |= JS_WRITE_OBJ_REFERENCE;
    buf = JS_WriteObject(ctx, &len, argv[0], flags);
    if (!buf)
        return JS_EXCEPTION;
    array = JS_NewArrayBufferCopy(ctx, buf, len);
    js_free(ctx, buf);
    return array;
}

static const JSCFunctionListEntry js_bjson_funcs[] = {
    JS_CFUNC_DEF("read", 4, js_bjson_read ),
    JS_CFUNC_DEF("write", 2, js_bjson_write ),
};

static int js_bjson_init(JSContext *ctx, JSModuleDef *m)
{
    return JS_SetModuleExportList(ctx, m, js_bjson_funcs,
                                  countof(js_bjson_funcs));
}

#ifdef JS_SHARED_LIBRARY
#define JS_INIT_MODULE js_init_module
#else
#define JS_INIT_MODULE js_init_module_bjson
#endif

JSModuleDef *JS_INIT_MODULE(JSContext *ctx, const char *module_name)
{
    JSModuleDef *m;
    m = JS_NewCModule(ctx, module_name, js_bjson_init);
    if (!m)
        return NULL;
    JS_AddModuleExportList(ctx, m, js_bjson_funcs, countof(js_bjson_funcs));
    return m;
}

'''
'''--- tests/microbench.js ---
/*
 * Javascript Micro benchmark
 *
 * Copyright (c) 2017-2019 Fabrice Bellard
 * Copyright (c) 2017-2019 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
import * as std from "std";

function pad(str, n) {
    str += "";
    while (str.length < n)
        str += " ";
    return str;
}

function pad_left(str, n) {
    str += "";
    while (str.length < n)
        str = " " + str;
    return str;
}

function pad_center(str, n) {
    str += "";
    while (str.length < n) {
        if ((n - str.length) & 1)
            str = str + " ";
        else
            str = " " + str;
    }
    return str;
}

function toPrec(n, prec) {
    var i, s;
    for (i = 0; i < prec; i++)
        n *= 10;
    s = "" + Math.round(n);
    for (i = s.length - prec; i <= 0; i++)
        s = "0" + s;
    if (prec > 0)
        s = s.substring(0, i) + "." + s.substring(i);
    return s;
}
                
var ref_data;
var log_data;

var heads  = [ "TEST", "N", "TIME (ns)", "REF (ns)", "SCORE (%)" ];
var widths = [    22,   10,          9,     9,       9 ];
var precs  = [     0,   0,           2,     2,       2 ];
var total  = [     0,   0,           0,     0,       0 ];
var total_score = 0;
var total_scale = 0;

if (typeof console == "undefined") {
    var console = { log: print };
}

function log_line() {
    var i, n, s, a;
    s = "";
    for (i = 0, n = arguments.length; i < n; i++) {
        if (i > 0)
            s += " ";
        a = arguments[i];
        if (typeof a == "number") {
            total[i] += a;
            a = toPrec(a, precs[i]);
            s += pad_left(a, widths[i]);
        } else {
            s += pad_left(a, widths[i]);
        }
    }
    console.log(s);
}

var clocks_per_sec = 1000000;
var max_iterations = 100;
var clock_threshold = 2000;  /* favoring short measuring spans */
var min_n_argument = 1;
var get_clock;

if (typeof globalThis.__date_clock != "function") {
    console.log("using fallback millisecond clock");
    clocks_per_sec = 1000;
    max_iterations = 10;
    clock_threshold = 100;
    get_clock = Date.now;
} else {
    get_clock = globalThis.__date_clock;
}

function log_one(text, n, ti) {
    var ref;

    if (ref_data)
        ref = ref_data[text];
    else
        ref = null;

    ti = Math.round(ti * 100) / 100;
    log_data[text] = ti;
    if (typeof ref === "number") {
        log_line(text, n, ti, ref, ti * 100 / ref);
        total_score += ti * 100 / ref;
        total_scale += 100;
    } else {
        log_line(text, n, ti);
        total_score += 100;
        total_scale += 100;
    }
}

function bench(f, text)
{
    var i, j, n, t, t1, ti, nb_its, ref, ti_n, ti_n1, min_ti;

    nb_its = n = 1;
    if (f.bench) {
        ti_n = f(text);
    } else {
        ti_n = 1000000000;
        min_ti = clock_threshold / 10;
        for(i = 0; i < 30; i++) {
            ti = 1000000000;
            for (j = 0; j < max_iterations; j++) {
                t = get_clock();
                while ((t1 = get_clock()) == t)
                    continue;
                nb_its = f(n);
                if (nb_its < 0)
                    return; // test failure
                t1 = get_clock() - t1;
                if (ti > t1)
                    ti = t1;
            }
            if (ti >= min_ti) {
                ti_n1 = ti / nb_its;
                if (ti_n > ti_n1)
                    ti_n = ti_n1;
            }
            if (ti >= clock_threshold && n >= min_n_argument)
                break;

            n = n * [ 2, 2.5, 2 ][i % 3];
        }
        // to use only the best timing from the last loop, uncomment below
        //ti_n = ti / nb_its;
    }
    /* nano seconds per iteration */
    log_one(text, n, ti_n * 1e9 / clocks_per_sec);
}

var global_res; /* to be sure the code is not optimized */

function empty_loop(n) {
    var j;
    for(j = 0; j < n; j++) {
    }
    return n;
}

function date_now(n) {
    var j;
    for(j = 0; j < n; j++) {
        Date.now();
    }
    return n;
}

function prop_read(n)
{
    var obj, sum, j;
    obj = {a: 1, b: 2, c:3, d:4 };
    sum = 0;
    for(j = 0; j < n; j++) {
        sum += obj.a;
        sum += obj.b;
        sum += obj.c;
        sum += obj.d;
    }
    global_res = sum;
    return n * 4;
}

function prop_write(n)
{
    var obj, j;
    obj = {a: 1, b: 2, c:3, d:4 };
    for(j = 0; j < n; j++) {
        obj.a = j;
        obj.b = j;
        obj.c = j;
        obj.d = j;
    }
    return n * 4;
}

function prop_create(n)
{
    var obj, j;
    for(j = 0; j < n; j++) {
        obj = new Object();
        obj.a = 1;
        obj.b = 2;
        obj.c = 3;
        obj.d = 4;
    }
    return n * 4;
}

function prop_delete(n)
{
    var obj, j;
    obj = {};
    for(j = 0; j < n; j++) {
        obj[j] = 1;
    }
    for(j = 0; j < n; j++) {
        delete obj[j];
    }
    return n;
}

function array_read(n)
{
    var tab, len, sum, i, j;
    tab = [];
    len = 10;
    for(i = 0; i < len; i++)
        tab[i] = i;
    sum = 0;
    for(j = 0; j < n; j++) {
        sum += tab[0];
        sum += tab[1];
        sum += tab[2];
        sum += tab[3];
        sum += tab[4];
        sum += tab[5];
        sum += tab[6];
        sum += tab[7];
        sum += tab[8];
        sum += tab[9];
    }
    global_res = sum;
    return len * n;
}

function array_write(n)
{
    var tab, len, i, j;
    tab = [];
    len = 10;
    for(i = 0; i < len; i++)
        tab[i] = i;
    for(j = 0; j < n; j++) {
        tab[0] = j;
        tab[1] = j;
        tab[2] = j;
        tab[3] = j;
        tab[4] = j;
        tab[5] = j;
        tab[6] = j;
        tab[7] = j;
        tab[8] = j;
        tab[9] = j;
    }
    return len * n;
}

function array_prop_create(n)
{
    var tab, i, j, len;
    len = 1000;
    for(j = 0; j < n; j++) {
        tab = [];
        for(i = 0; i < len; i++)
            tab[i] = i;
    }
    return len * n;
}

function array_length_decr(n)
{
    var tab, i, j, len;
    len = 1000;
    tab = [];
    for(i = 0; i < len; i++)
        tab[i] = i;
    for(j = 0; j < n; j++) {
        for(i = len - 1; i >= 0; i--)
            tab.length = i;
    }
    return len * n;
}

function array_hole_length_decr(n)
{
    var tab, i, j, len;
    len = 1000;
    tab = [];
    for(i = 0; i < len; i++) {
        if (i != 3)
            tab[i] = i;
    }
    for(j = 0; j < n; j++) {
        for(i = len - 1; i >= 0; i--)
            tab.length = i;
    }
    return len * n;
}

function array_push(n)
{
    var tab, i, j, len;
    len = 500;
    for(j = 0; j < n; j++) {
        tab = [];
        for(i = 0; i < len; i++)
            tab.push(i);
    }
    return len * n;
}

function array_pop(n)
{
    var tab, i, j, len, sum;
    len = 500;
    for(j = 0; j < n; j++) {
        tab = [];
        for(i = 0; i < len; i++)
            tab[i] = i;
        sum = 0;
        for(i = 0; i < len; i++)
            sum += tab.pop();
        global_res = sum;
    }
    return len * n;
}

function typed_array_read(n)
{
    var tab, len, sum, i, j;
    len = 10;
    tab = new Int32Array(len);
    for(i = 0; i < len; i++)
        tab[i] = i;
    sum = 0;
    for(j = 0; j < n; j++) {
        sum += tab[0];
        sum += tab[1];
        sum += tab[2];
        sum += tab[3];
        sum += tab[4];
        sum += tab[5];
        sum += tab[6];
        sum += tab[7];
        sum += tab[8];
        sum += tab[9];
    }
    global_res = sum;
    return len * n;
}

function typed_array_write(n)
{
    var tab, len, i, j;
    len = 10;
    tab = new Int32Array(len);
    for(i = 0; i < len; i++)
        tab[i] = i;
    for(j = 0; j < n; j++) {
        tab[0] = j;
        tab[1] = j;
        tab[2] = j;
        tab[3] = j;
        tab[4] = j;
        tab[5] = j;
        tab[6] = j;
        tab[7] = j;
        tab[8] = j;
        tab[9] = j;
    }
    return len * n;
}

var global_var0;

function global_read(n)
{
    var sum, j;
    global_var0 = 0;
    sum = 0;
    for(j = 0; j < n; j++) {
        sum += global_var0;
        sum += global_var0;
        sum += global_var0;
        sum += global_var0;
    }
    global_res = sum;
    return n * 4;
}

var global_write =
    (1, eval)(`(function global_write(n)
           {
               var j;
               for(j = 0; j < n; j++) {
                   global_var0 = j;
                   global_var0 = j;
                   global_var0 = j;
                   global_var0 = j;
               }
               return n * 4;
           })`);

function global_write_strict(n)
{
    var j;
    for(j = 0; j < n; j++) {
        global_var0 = j;
        global_var0 = j;
        global_var0 = j;
        global_var0 = j;
    }
    return n * 4;
}

function local_destruct(n)
{
    var j, v1, v2, v3, v4;
    var array = [ 1, 2, 3, 4, 5];
    var o = { a:1, b:2, c:3, d:4 };
    var a, b, c, d;
    for(j = 0; j < n; j++) {
        [ v1, v2,, v3, ...v4] = array;
        ({ a, b, c, d } = o);
        ({ a: a, b: b, c: c, d: d } = o);
    }
    return n * 12;
}

var global_v1, global_v2, global_v3, global_v4;
var global_a, global_b, global_c, global_d;

var global_destruct =
    (1, eval)(`(function global_destruct(n)
           {
               var j, v1, v2, v3, v4;
               var array = [ 1, 2, 3, 4, 5 ];
               var o = { a:1, b:2, c:3, d:4 };
               var a, b, c, d;
               for(j = 0; j < n; j++) {
                   [ global_v1, global_v2,, global_v3, ...global_v4] = array;
                   ({ a: global_a, b: global_b, c: global_c, d: global_d } = o);
               }
               return n * 8;
          })`);

function global_destruct_strict(n)
{
    var j, v1, v2, v3, v4;
    var array = [ 1, 2, 3, 4, 5 ];
    var o = { a:1, b:2, c:3, d:4 };
    var a, b, c, d;
    for(j = 0; j < n; j++) {
        [ global_v1, global_v2,, global_v3, ...global_v4] = array;
        ({ a: global_a, b: global_b, c: global_c, d: global_d } = o);
    }
    return n * 8;
}

function func_call(n)
{
    function f(a)
    {
        return 1;
    }

    var j, sum;
    sum = 0;
    for(j = 0; j < n; j++) {
        sum += f(j);
        sum += f(j);
        sum += f(j);
        sum += f(j);
    }
    global_res = sum;
    return n * 4;
}

function closure_var(n)
{
    function f(a)
    {
        sum++;
    }

    var j, sum;
    sum = 0;
    for(j = 0; j < n; j++) {
        f(j);
        f(j);
        f(j);
        f(j);
    }
    global_res = sum;
    return n * 4;
}

function int_arith(n)
{
    var i, j, sum;
    global_res = 0;
    for(j = 0; j < n; j++) {
        sum = 0;
        for(i = 0; i < 1000; i++) {
            sum += i * i;
        }
        global_res += sum;
    }
    return n * 1000;
}

function float_arith(n)
{
    var i, j, sum, a, incr, a0;
    global_res = 0;
    a0 = 0.1;
    incr = 1.1;
    for(j = 0; j < n; j++) {
        sum = 0;
        a = a0;
        for(i = 0; i < 1000; i++) {
            sum += a * a;
            a += incr;
        }
        global_res += sum;
    }
    return n * 1000;
}

function bigfloat_arith(n)
{
    var i, j, sum, a, incr, a0;
    global_res = 0;
    a0 = BigFloat("0.1");
    incr = BigFloat("1.1");
    for(j = 0; j < n; j++) {
        sum = 0;
        a = a0;
        for(i = 0; i < 1000; i++) {
            sum += a * a;
            a += incr;
        }
        global_res += sum;
    }
    return n * 1000;
}

function float256_arith(n)
{
    return BigFloatEnv.setPrec(bigfloat_arith.bind(null, n), 237, 19);
}

function bigint_arith(n, bits)
{
    var i, j, sum, a, incr, a0, sum0;
    sum0 = global_res = BigInt(0);
    a0 = BigInt(1) << BigInt(Math.floor((bits - 10) * 0.5));
    incr = BigInt(1);
    for(j = 0; j < n; j++) {
        sum = sum0;
        a = a0;
        for(i = 0; i < 1000; i++) {
            sum += a * a;
            a += incr;
        }
        global_res += sum;
    }
    return n * 1000;
}

function bigint64_arith(n)
{
    return bigint_arith(n, 64);
}

function bigint256_arith(n)
{
    return bigint_arith(n, 256);
}

function set_collection_add(n)
{
    var s, i, j, len = 100;
    s = new Set();
    for(j = 0; j < n; j++) {
        for(i = 0; i < len; i++) {
            s.add(String(i), i);
        }
        for(i = 0; i < len; i++) {
            if (!s.has(String(i)))
                throw Error("bug in Set");
        }
    }
    return n * len;
}

function array_for(n)
{
    var r, i, j, sum;
    r = [];
    for(i = 0; i < 100; i++)
        r[i] = i;
    for(j = 0; j < n; j++) {
        sum = 0;
        for(i = 0; i < 100; i++) {
            sum += r[i];
        }
        global_res = sum;
    }
    return n * 100;
}

function array_for_in(n)
{
    var r, i, j, sum;
    r = [];
    for(i = 0; i < 100; i++)
        r[i] = i;
    for(j = 0; j < n; j++) {
        sum = 0;
        for(i in r) {
            sum += r[i];
        }
        global_res = sum;
    }
    return n * 100;
}

function array_for_of(n)
{
    var r, i, j, sum;
    r = [];
    for(i = 0; i < 100; i++)
        r[i] = i;
    for(j = 0; j < n; j++) {
        sum = 0;
        for(i of r) {
            sum += i;
        }
        global_res = sum;
    }
    return n * 100;
}

function math_min(n)
{
    var i, j, r;
    r = 0;
    for(j = 0; j < n; j++) {
        for(i = 0; i < 1000; i++)
            r = Math.min(i, 500);
        global_res = r;
    }
    return n * 1000;
}

/* incremental string contruction as local var */
function string_build1(n)
{
    var i, j, r;
    r = "";
    for(j = 0; j < n; j++) {
        for(i = 0; i < 100; i++)
            r += "x";
        global_res = r;
    }
    return n * 100;
}

/* incremental string contruction as arg */
function string_build2(n, r)
{
    var i, j;
    r = "";
    for(j = 0; j < n; j++) {
        for(i = 0; i < 100; i++)
            r += "x";
        global_res = r;
    }
    return n * 100;
}

/* incremental string contruction by prepending */
function string_build3(n, r)
{
    var i, j;
    r = "";
    for(j = 0; j < n; j++) {
        for(i = 0; i < 100; i++)
            r = "x" + r;
        global_res = r;
    }
    return n * 100;
}

/* incremental string contruction with multiple reference */
function string_build4(n)
{
    var i, j, r, s;
    r = "";
    for(j = 0; j < n; j++) {
        for(i = 0; i < 100; i++) {
            s = r;
            r += "x";
        }
        global_res = r;
    }
    return n * 100;
}

/* sort bench */

function sort_bench(text) {
    function random(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[(Math.random() * n) >> 0];
    }
    function random8(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[(Math.random() * 256) >> 0];
    }
    function random1(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[(Math.random() * 2) >> 0];
    }
    function hill(arr, n, def) {
        var mid = n >> 1;
        for (var i = 0; i < mid; i++)
            arr[i] = def[i];
        for (var i = mid; i < n; i++)
            arr[i] = def[n - i];
    }
    function comb(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[(i & 1) * i];
    }
    function crisscross(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[(i & 1) ? n - i : i];
    }
    function zero(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[0];
    }
    function increasing(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[i];
    }
    function decreasing(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[n - 1 - i];
    }
    function alternate(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[i ^ 1];
    }
    function jigsaw(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[i % (n >> 4)];
    }
    function incbutone(arr, n, def) {
        for (var i = 0; i < n; i++)
            arr[i] = def[i];
        if (n > 0)
            arr[n >> 2] = def[n];
    }
    function incbutfirst(arr, n, def) {
        if (n > 0)
            arr[0] = def[n];
        for (var i = 1; i < n; i++)
            arr[i] = def[i];
    }
    function incbutlast(arr, n, def) {
        for (var i = 0; i < n - 1; i++)
            arr[i] = def[i + 1];
        if (n > 0)
            arr[n - 1] = def[0];
    }

    var sort_cases = [ random, random8, random1, jigsaw, hill, comb,
                      crisscross, zero, increasing, decreasing, alternate,
                      incbutone, incbutlast, incbutfirst ];

    var n = sort_bench.array_size || 10000;
    var array_type = sort_bench.array_type || Array;
    var def, arr;
    var i, j, x, y;
    var total = 0;

    var save_total_score = total_score;
    var save_total_scale = total_scale;

    // initialize default sorted array (n + 1 elements)
    def = new array_type(n + 1);
    if (array_type == Array) {
        for (i = 0; i <= n; i++) {
            def[i] = i + "";
        }
    } else {
        for (i = 0; i <= n; i++) {
            def[i] = i;
        }
    }
    def.sort();
    for (var f of sort_cases) {
        var ti = 0, tx = 0;
        for (j = 0; j < 100; j++) {
            arr = new array_type(n);
            f(arr, n, def);
            var t1 = get_clock();
            arr.sort();
            t1 = get_clock() - t1;
            tx += t1;
            if (!ti || ti > t1)
                ti = t1;
            if (tx >= clocks_per_sec)
                break;
        }
        total += ti;

        i = 0;
        x = arr[0];
        if (x !== void 0) {
            for (i = 1; i < n; i++) {
                y = arr[i];
                if (y === void 0)
                    break;
                if (x > y)
                    break;
                x = y;
            }
        }
        while (i < n && arr[i] === void 0)
            i++;
        if (i < n) {
            console.log("sort_bench: out of order error for " + f.name +
                        " at offset " + (i - 1) +
                        ": " + arr[i - 1] + " > " + arr[i]);
        }
        if (sort_bench.verbose)
            log_one("sort_" + f.name, n, ti, n * 100);
    }
    total_score = save_total_score;
    total_scale = save_total_scale;
    return total / n / 1000;
}
sort_bench.bench = true;
sort_bench.verbose = false;

function int_to_string(n)
{
    var s, r, j;
    r = 0;
    for(j = 0; j < n; j++) {
        s = (j + 1).toString();
    }
    return n;
}

function float_to_string(n)
{
    var s, r, j;
    r = 0;
    for(j = 0; j < n; j++) {
        s = (j + 0.1).toString();
    }
    return n;
}

function string_to_int(n)
{
    var s, r, j;
    r = 0;
    s = "12345";
    r = 0;
    for(j = 0; j < n; j++) {
        r += (s | 0);
    }
    global_res = r;
    return n;
}

function string_to_float(n)
{
    var s, r, j;
    r = 0;
    s = "12345.6";
    r = 0;
    for(j = 0; j < n; j++) {
        r -= s;
    }
    global_res = r;
    return n;
}

function load_result(filename)
{
    var f, str, res;
    if (typeof std === "undefined")
        return null;
    f = std.open(filename, "r");
    if (!f)
        return null;
    str = f.readAsString();
    res = JSON.parse(str);
    f.close();
    return res;
}

function save_result(filename, obj)
{
    var f;
    if (typeof std === "undefined")
        return;
    f = std.open(filename, "w");
    f.puts(JSON.stringify(obj, null, 2));
    f.puts("\n");
    f.close();
}

function main(argc, argv, g)
{
    var test_list = [
        empty_loop,
        date_now,
        prop_read,
        prop_write,
        prop_create,
        prop_delete,
        array_read,
        array_write,
        array_prop_create,
        array_length_decr,
        array_hole_length_decr,
        array_push,
        array_pop,
        typed_array_read,
        typed_array_write,
        global_read,
        global_write,
        global_write_strict,
        local_destruct,
        global_destruct,
        global_destruct_strict,
        func_call,
        closure_var,
        int_arith,
        float_arith,
        set_collection_add,
        array_for,
        array_for_in,
        array_for_of,
        math_min,
        string_build1,
        string_build2,
        //string_build3,
        //string_build4,
        sort_bench,
        int_to_string,
        float_to_string,
        string_to_int,
        string_to_float,
    ];
    var tests = [];
    var i, j, n, f, name;
    
    if (typeof BigInt == "function") {
        /* BigInt test */
        test_list.push(bigint64_arith);
        test_list.push(bigint256_arith);
    }
    if (typeof BigFloat == "function") {
        /* BigFloat test */
        test_list.push(float256_arith);
    }
    
    for (i = 1; i < argc;) {
        name = argv[i++];
        if (name == "-a") {
            sort_bench.verbose = true;
            continue;
        }
        if (name == "-t") {
            name = argv[i++];
            sort_bench.array_type = g[name];
            if (typeof sort_bench.array_type != "function") {
                console.log("unknown array type: " + name);
                return 1;
            }
            continue;
        }
        if (name == "-n") {
            sort_bench.array_size = +argv[i++];
            continue;
        }
        for (j = 0; j < test_list.length; j++) {
            f = test_list[j];
            if (name === f.name) {
                tests.push(f);
                break;
            }
        }
        if (j == test_list.length) {
            console.log("unknown benchmark: " + name);
            return 1;
        }
    }
    if (tests.length == 0)
        tests = test_list;

    ref_data = load_result("microbench.txt");
    log_data = {};
    log_line.apply(null, heads);
    n = 0;

    for(i = 0; i < tests.length; i++) {
        f = tests[i];
        bench(f, f.name, ref_data, log_data);
        if (ref_data && ref_data[f.name])
            n++;
    }
    if (ref_data)
        log_line("total", "", total[2], total[3], total_score * 100 / total_scale);
    else
        log_line("total", "", total[2]);
        
    if (tests == test_list)
        save_result("microbench-new.txt", log_data);
}

if (!scriptArgs)
    scriptArgs = [];
main(scriptArgs.length, scriptArgs, this);

'''
'''--- tests/test_bignum.js ---
"use strict";

function assert(actual, expected, message) {
    if (arguments.length == 1)
        expected = true;

    if (actual === expected)
        return;

    if (actual !== null && expected !== null
    &&  typeof actual == 'object' && typeof expected == 'object'
    &&  actual.toString() === expected.toString())
        return;

    throw Error("assertion failed: got |" + actual + "|" +
                ", expected |" + expected + "|" +
                (message ? " (" + message + ")" : ""));
}

function assertThrows(err, func)
{
    var ex;
    ex = false;
    try {
        func();
    } catch(e) {
        ex = true;
        assert(e instanceof err);
    }
    assert(ex, true, "exception expected");
}

// load more elaborate version of assert if available
try { __loadScript("test_assert.js"); } catch(e) {}

/*----------------*/

function bigint_pow(a, n)
{
    var r, i;
    r = 1n;
    for(i = 0n; i < n; i++)
        r *= a;
    return r;
}

/* a must be < b */
function test_less(a, b)
{
    assert(a < b);
    assert(!(b < a));
    assert(a <= b);
    assert(!(b <= a));
    assert(b > a);
    assert(!(a > b));
    assert(b >= a);
    assert(!(a >= b));
    assert(a != b);
    assert(!(a == b));
}

/* a must be numerically equal to b */
function test_eq(a, b)
{
    assert(a == b);
    assert(b == a);
    assert(!(a != b));
    assert(!(b != a));
    assert(a <= b);
    assert(b <= a);
    assert(!(a < b));
    assert(a >= b);
    assert(b >= a);
    assert(!(a > b));
}

function test_bigint1()
{
    var a, r;

    test_less(2n, 3n);
    test_eq(3n, 3n);

    test_less(2, 3n);
    test_eq(3, 3n);

    test_less(2.1, 3n);
    test_eq(Math.sqrt(4), 2n);

    a = bigint_pow(3n, 100n);
    assert((a - 1n) != a);
    assert(a == 515377520732011331036461129765621272702107522001n);
    assert(a == 0x5a4653ca673768565b41f775d6947d55cf3813d1n);

    r = 1n << 31n;
    assert(r, 2147483648n, "1 << 31n === 2147483648n");
    
    r = 1n << 32n;
    assert(r, 4294967296n, "1 << 32n === 4294967296n");
}

function test_bigint2()
{
    assert(BigInt(""), 0n);
    assert(BigInt("  123"), 123n);
    assert(BigInt("  123   "), 123n);
    assertThrows(SyntaxError, () => { BigInt("+") } );
    assertThrows(SyntaxError, () => { BigInt("-") } );
    assertThrows(SyntaxError, () => { BigInt("\x00a") } );
    assertThrows(SyntaxError, () => { BigInt("  123  r") } );
}

function test_divrem(div1, a, b, q)
{
    var div, divrem, t;
    div = BigInt[div1];
    divrem = BigInt[div1 + "rem"];
    assert(div(a, b) == q);
    t = divrem(a, b);
    assert(t[0] == q);
    assert(a == b * q + t[1]);
}

function test_idiv1(div, a, b, r)
{
    test_divrem(div, a, b, r[0]);
    test_divrem(div, -a, b, r[1]);
    test_divrem(div, a, -b, r[2]);
    test_divrem(div, -a, -b, r[3]);
}

/* QuickJS BigInt extensions */
function test_bigint_ext()
{
    var r;
    assert(BigInt.floorLog2(0n) === -1n);
    assert(BigInt.floorLog2(7n) === 2n);

    assert(BigInt.sqrt(0xffffffc000000000000000n) === 17592185913343n);
    r = BigInt.sqrtrem(0xffffffc000000000000000n);
    assert(r[0] === 17592185913343n);
    assert(r[1] === 35167191957503n);

    test_idiv1("tdiv", 3n, 2n, [1n, -1n, -1n, 1n]);
    test_idiv1("fdiv", 3n, 2n, [1n, -2n, -2n, 1n]);
    test_idiv1("cdiv", 3n, 2n, [2n, -1n, -1n, 2n]);
    test_idiv1("ediv", 3n, 2n, [1n, -2n, -1n, 2n]);
}

function test_bigfloat()
{
    var e, a, b, sqrt2;
    
    assert(typeof 1n === "bigint");
    assert(typeof 1l === "bigfloat");
    assert(1 == 1.0l);
    assert(1 !== 1.0l);

    test_less(2l, 3l);
    test_eq(3l, 3l);

    test_less(2, 3l);
    test_eq(3, 3l);

    test_less(2.1, 3l);
    test_eq(Math.sqrt(9), 3l);
    
    test_less(2n, 3l);
    test_eq(3n, 3l);

    e = new BigFloatEnv(128);
    assert(e.prec == 128);
    a = BigFloat.sqrt(2l, e);
    assert(a === BigFloat.parseFloat("0x1.6a09e667f3bcc908b2fb1366ea957d3e", 0, e));
    assert(e.inexact === true);
    assert(BigFloat.fpRound(a) == 0x1.6a09e667f3bcc908b2fb1366ea95l);
    
    b = BigFloatEnv.setPrec(BigFloat.sqrt.bind(null, 2), 128);
    assert(a === b);

    assert(BigFloat.isNaN(BigFloat(NaN)));
    assert(BigFloat.isFinite(1l));
    assert(!BigFloat.isFinite(1l/0l));

    assert(BigFloat.abs(-3l) === 3l);
    assert(BigFloat.sign(-3l) === -1l);

    assert(BigFloat.exp(0.2l) === 1.2214027581601698339210719946396742l);
    assert(BigFloat.log(3l) === 1.0986122886681096913952452369225256l);
    assert(BigFloat.pow(2.1l, 1.6l) === 3.277561666451861947162828744873745l);
    
    assert(BigFloat.sin(-1l) === -0.841470984807896506652502321630299l);
    assert(BigFloat.cos(1l) === 0.5403023058681397174009366074429766l);
    assert(BigFloat.tan(0.1l) === 0.10033467208545054505808004578111154l);

    assert(BigFloat.asin(0.3l) === 0.30469265401539750797200296122752915l);
    assert(BigFloat.acos(0.4l) === 1.1592794807274085998465837940224159l);
    assert(BigFloat.atan(0.7l) === 0.610725964389208616543758876490236l);
    assert(BigFloat.atan2(7.1l, -5.1l) === 2.1937053809751415549388104628759813l);

    assert(BigFloat.floor(2.5l) === 2l);
    assert(BigFloat.ceil(2.5l) === 3l);
    assert(BigFloat.trunc(-2.5l) === -2l);
    assert(BigFloat.round(2.5l) === 3l);

    assert(BigFloat.fmod(3l,2l) === 1l);
    assert(BigFloat.remainder(3l,2l) === -1l);

    /* string conversion */
    assert((1234.125l).toString(), "1234.125");
    assert((1234.125l).toFixed(2), "1234.13");
    assert((1234.125l).toFixed(2, "down"), "1234.12");
    assert((1234.125l).toExponential(), "1.234125e+3");
    assert((1234.125l).toExponential(5), "1.23413e+3");
    assert((1234.125l).toExponential(5, BigFloatEnv.RNDZ), "1.23412e+3");
    assert((1234.125l).toPrecision(6), "1234.13");
    assert((1234.125l).toPrecision(6, BigFloatEnv.RNDZ), "1234.12");

    /* string conversion with binary base */
    assert((0x123.438l).toString(16), "123.438");
    assert((0x323.438l).toString(16), "323.438");
    assert((0x723.438l).toString(16), "723.438");
    assert((0xf23.438l).toString(16), "f23.438");
    assert((0x123.438l).toFixed(2, BigFloatEnv.RNDNA, 16), "123.44");
    assert((0x323.438l).toFixed(2, BigFloatEnv.RNDNA, 16), "323.44");
    assert((0x723.438l).toFixed(2, BigFloatEnv.RNDNA, 16), "723.44");
    assert((0xf23.438l).toFixed(2, BigFloatEnv.RNDNA, 16), "f23.44");
    assert((0x0.0000438l).toFixed(6, BigFloatEnv.RNDNA, 16), "0.000044");
    assert((0x1230000000l).toFixed(1, BigFloatEnv.RNDNA, 16), "1230000000.0");
    assert((0x123.438l).toPrecision(5, BigFloatEnv.RNDNA, 16), "123.44");
    assert((0x123.438l).toPrecision(5, BigFloatEnv.RNDZ, 16), "123.43");
    assert((0x323.438l).toPrecision(5, BigFloatEnv.RNDNA, 16), "323.44");
    assert((0x723.438l).toPrecision(5, BigFloatEnv.RNDNA, 16), "723.44");
    assert((-0xf23.438l).toPrecision(5, BigFloatEnv.RNDD, 16), "-f23.44");
    assert((0x123.438l).toExponential(4, BigFloatEnv.RNDNA, 16), "1.2344p+8");
}

function test_bigdecimal()
{
    assert(1m === 1m);
    assert(1m !== 2m);
    test_less(1m, 2m);
    test_eq(2m, 2m);
    
    test_less(1, 2m);
    test_eq(2, 2m);

    test_less(1.1, 2m);
    test_eq(Math.sqrt(4), 2m);
    
    test_less(2n, 3m);
    test_eq(3n, 3m);
    
    assert(BigDecimal("1234.1") === 1234.1m);
    assert(BigDecimal("    1234.1") === 1234.1m);
    assert(BigDecimal("    1234.1  ") === 1234.1m);

    assert(BigDecimal(0.1) === 0.1m);
    assert(BigDecimal(123) === 123m);
    assert(BigDecimal(true) === 1m);

    assert(123m + 1m === 124m);
    assert(123m - 1m === 122m);

    assert(3.2m * 3m === 9.6m);
    assert(10m / 2m === 5m);
    assertThrows(RangeError, () => { 10m / 3m } );

    assert(10m % 3m === 1m);
    assert(-10m % 3m === -1m);

    assert(1234.5m ** 3m === 1881365963.625m);
    assertThrows(RangeError, () => { 2m ** 3.1m } );
    assertThrows(RangeError, () => { 2m ** -3m } );
    
    assert(BigDecimal.sqrt(2m,
                       { roundingMode: "half-even",
                         maximumSignificantDigits: 4 }) === 1.414m);
    assert(BigDecimal.sqrt(101m,
                       { roundingMode: "half-even",
                         maximumFractionDigits: 3 }) === 10.050m);
    assert(BigDecimal.sqrt(0.002m,
                       { roundingMode: "half-even",
                         maximumFractionDigits: 3 }) === 0.045m);
    
    assert(BigDecimal.round(3.14159m,
                       { roundingMode: "half-even",
                         maximumFractionDigits: 3 }) === 3.142m);

    assert(BigDecimal.add(3.14159m, 0.31212m,
                          { roundingMode: "half-even",
                            maximumFractionDigits: 2 }) === 3.45m);
    assert(BigDecimal.sub(3.14159m, 0.31212m,
                          { roundingMode: "down",
                            maximumFractionDigits: 2 }) === 2.82m);
    assert(BigDecimal.mul(3.14159m, 0.31212m,
                          { roundingMode: "half-even",
                            maximumFractionDigits: 3 }) === 0.981m);
    assert(BigDecimal.mod(3.14159m, 0.31211m,
                          { roundingMode: "half-even",
                            maximumFractionDigits: 4 }) === 0.0205m);
    assert(BigDecimal.div(20m, 3m,
                       { roundingMode: "half-even",
                         maximumSignificantDigits: 3 }) === 6.67m);
    assert(BigDecimal.div(20m, 3m,
                       { roundingMode: "half-even",
                         maximumFractionDigits: 50 }) ===
           6.66666666666666666666666666666666666666666666666667m);

    /* string conversion */
    assert((1234.125m).toString(), "1234.125");
    assert((1234.125m).toFixed(2), "1234.13");
    assert((1234.125m).toFixed(2, "down"), "1234.12");
    assert((1234.125m).toExponential(), "1.234125e+3");
    assert((1234.125m).toExponential(5), "1.23413e+3");
    assert((1234.125m).toExponential(5, "down"), "1.23412e+3");
    assert((1234.125m).toPrecision(6), "1234.13");
    assert((1234.125m).toPrecision(6, "down"), "1234.12");
    assert((-1234.125m).toPrecision(6, "floor"), "-1234.13");
}

test_bigint1();
test_bigint2();
test_bigint_ext();
test_bigfloat();
test_bigdecimal();

'''
'''--- tests/test_bjson.js ---
import * as bjson from "./bjson.so";

function assert(actual, expected, message) {
    if (arguments.length == 1)
        expected = true;

    if (actual === expected)
        return;

    if (actual !== null && expected !== null
    &&  typeof actual == 'object' && typeof expected == 'object'
    &&  actual.toString() === expected.toString())
        return;

    throw Error("assertion failed: got |" + actual + "|" +
                ", expected |" + expected + "|" +
                (message ? " (" + message + ")" : ""));
}

function toHex(a)
{
    var i, s = "", tab, v;
    tab = new Uint8Array(a);
    for(i = 0; i < tab.length; i++) {
        v = tab[i].toString(16);
        if (v.length < 2)
            v = "0" + v;
        if (i !== 0)
            s += " ";
        s += v;
    }
    return s;
}

function isArrayLike(a)
{
    return Array.isArray(a) || 
        (a instanceof Uint8ClampedArray) ||
        (a instanceof Uint8Array) ||
        (a instanceof Uint16Array) ||
        (a instanceof Uint32Array) ||
        (a instanceof Int8Array) ||
        (a instanceof Int16Array) ||
        (a instanceof Int32Array) ||
        (a instanceof Float32Array) ||
        (a instanceof Float64Array);
}

function toStr(a)
{
    var s, i, props, prop;

    switch(typeof(a)) {
    case "object":
        if (a === null)
            return "null";
        if (a instanceof Date) {
            s = "Date(" + toStr(a.valueOf()) + ")";
        } else if (a instanceof Number) {
            s = "Number(" + toStr(a.valueOf()) + ")";
        } else if (a instanceof String) {
            s = "String(" + toStr(a.valueOf()) + ")";
        } else if (a instanceof Boolean) {
            s = "Boolean(" + toStr(a.valueOf()) + ")";
        } else if (isArrayLike(a)) {
            s = "[";
            for(i = 0; i < a.length; i++) {
                if (i != 0)
                    s += ",";
                s += toStr(a[i]);
            }
            s += "]";
        } else {
            props = Object.keys(a);
            s = "{";
            for(i = 0; i < props.length; i++) {
                if (i != 0)
                    s += ",";
                prop = props[i];
                s += prop + ":" + toStr(a[prop]);
            }
            s += "}";
        }
        return s;
    case "undefined":
        return "undefined";
    case "string":
        return a.__quote();
    case "number":
    case "bigfloat":
        if (a == 0 && 1 / a < 0)
            return "-0";
        else
            return a.toString();
        break;
    default:
        return a.toString();
    }
}

function bjson_test(a)
{
    var buf, r, a_str, r_str;
    a_str = toStr(a);
    buf = bjson.write(a);
    if (0) {
        print(a_str, "->", toHex(buf));
    }
    r = bjson.read(buf, 0, buf.byteLength);
    r_str = toStr(r);
    if (a_str != r_str) {
        print(a_str);
        print(r_str);
        assert(false);
    }
}

/* test multiple references to an object including circular
   references */
function bjson_test_reference()
{
    var array, buf, i, n, array_buffer;
    n = 16;
    array = [];
    for(i = 0; i < n; i++)
        array[i] = {};
    array_buffer = new ArrayBuffer(n);
    for(i = 0; i < n; i++) {
        array[i].next = array[(i + 1) % n];
        array[i].idx = i;
        array[i].typed_array = new Uint8Array(array_buffer, i, 1);
    }
    buf = bjson.write(array, true);

    array = bjson.read(buf, 0, buf.byteLength, true);

    /* check the result */
    for(i = 0; i < n; i++) {
        assert(array[i].next, array[(i + 1) % n]);
        assert(array[i].idx, i);
        assert(array[i].typed_array.buffer, array_buffer);
        assert(array[i].typed_array.length, 1);
        assert(array[i].typed_array.byteOffset, i);
    }
}

function bjson_test_all()
{
    var obj;
    
    bjson_test({x:1, y:2, if:3});
    bjson_test([1, 2, 3]);
    bjson_test([1.0, "aa", true, false, undefined, null, NaN, -Infinity, -0.0]);
    if (typeof BigInt !== "undefined") {
        bjson_test([BigInt("1"), -BigInt("0x123456789"),
               BigInt("0x123456789abcdef123456789abcdef")]);
    }
    if (typeof BigFloat !== "undefined") {
        BigFloatEnv.setPrec(function () {
            bjson_test([BigFloat("0.1"), BigFloat("-1e30"), BigFloat("0"),
                   BigFloat("-0"), BigFloat("Infinity"), BigFloat("-Infinity"),
                   0.0 / BigFloat("0"), BigFloat.MAX_VALUE,
                   BigFloat.MIN_VALUE]);
        }, 113, 15);
    }
    if (typeof BigDecimal !== "undefined") {
        bjson_test([BigDecimal("0"),
                    BigDecimal("0.8"), BigDecimal("123321312321321e100"),
                    BigDecimal("-1233213123213214332333223332e100"),
                    BigDecimal("1.233e-1000")]);
    }

    bjson_test([new Date(1234), new String("abc"), new Number(-12.1), new Boolean(true)]);

    bjson_test(new Int32Array([123123, 222111, -32222]));
    bjson_test(new Float64Array([123123, 222111.5]));
    
    /* tested with a circular reference */
    obj = {};
    obj.x = obj;
    try {
        bjson.write(obj);
        assert(false);
    } catch(e) {
        assert(e instanceof TypeError);
    }

    bjson_test_reference();
}

bjson_test_all();

'''
'''--- tests/test_builtin.js ---
"use strict";

function assert(actual, expected, message) {
    if (arguments.length == 1)
        expected = true;

    if (actual === expected)
        return;

    if (actual !== null && expected !== null
    &&  typeof actual == 'object' && typeof expected == 'object'
    &&  actual.toString() === expected.toString())
        return;

    throw Error("assertion failed: got |" + actual + "|" +
                ", expected |" + expected + "|" +
                (message ? " (" + message + ")" : ""));
}

function assert_throws(expected_error, func)
{
    var err = false;
    try {
        func();
    } catch(e) {
        err = true;
        if (!(e instanceof expected_error)) {
            throw Error("unexpected exception type");
        }
    }
    if (!err) {
        throw Error("expected exception");
    }
}

// load more elaborate version of assert if available
try { __loadScript("test_assert.js"); } catch(e) {}

/*----------------*/

function my_func(a, b)
{
    return a + b;
}

function test_function()
{
    function f(a, b) {
        var i, tab = [];
        tab.push(this);
        for(i = 0; i < arguments.length; i++)
            tab.push(arguments[i]);
        return tab;
    }
    function constructor1(a) {
        this.x = a;
    }

    var r, g;
    
    r = my_func.call(null, 1, 2);
    assert(r, 3, "call");

    r = my_func.apply(null, [1, 2]);
    assert(r, 3, "apply");

    r = (function () { return 1; }).apply(null, undefined);
    assert(r, 1);

    assert_throws(TypeError, (function() {
        Reflect.apply((function () { return 1; }), null, undefined);
    }));
    
    r = new Function("a", "b", "return a + b;");
    assert(r(2,3), 5, "function");
    
    g = f.bind(1, 2);
    assert(g.length, 1);
    assert(g.name, "bound f");
    assert(g(3), [1,2,3]);

    g = constructor1.bind(null, 1);
    r = new g();
    assert(r.x, 1);
}

function test()
{
    var r, a, b, c, err;

    r = Error("hello");
    assert(r.message, "hello", "Error");

    a = new Object();
    a.x = 1;
    assert(a.x, 1, "Object");

    assert(Object.getPrototypeOf(a), Object.prototype, "getPrototypeOf");
    Object.defineProperty(a, "y", { value: 3, writable: true, configurable: true, enumerable: true });
    assert(a.y, 3, "defineProperty");

    Object.defineProperty(a, "z", { get: function () { return 4; }, set: function(val) { this.z_val = val; }, configurable: true, enumerable: true });
    assert(a.z, 4, "get");
    a.z = 5;
    assert(a.z_val, 5, "set");
    
    a = { get z() { return 4; }, set z(val) { this.z_val = val; } };
    assert(a.z, 4, "get");
    a.z = 5;
    assert(a.z_val, 5, "set");

    b = Object.create(a);
    assert(Object.getPrototypeOf(b), a, "create");
    c = {u:2};
    /* XXX: refcount bug in 'b' instead of 'a' */
    Object.setPrototypeOf(a, c);
    assert(Object.getPrototypeOf(a), c, "setPrototypeOf");

    a = {};
    assert(a.toString(), "[object Object]", "toString");

    a = {x:1};
    assert(Object.isExtensible(a), true, "extensible");
    Object.preventExtensions(a);

    err = false;
    try {
        a.y = 2;
    } catch(e) {
        err = true;
    }
    assert(Object.isExtensible(a), false, "extensible");
    assert(typeof a.y, "undefined", "extensible");
    assert(err, true, "extensible");
}

function test_enum()
{
    var a, tab;
    a = {x:1,
         "18014398509481984": 1,
         "9007199254740992": 1,
         "9007199254740991": 1,
         "4294967296": 1,
         "4294967295": 1,
         y:1,
         "4294967294": 1,
         "1": 2};
    tab = Object.keys(a);
//    console.log("tab=" + tab.toString());
    assert(tab, ["1","4294967294","x","18014398509481984","9007199254740992","9007199254740991","4294967296","4294967295","y"], "keys");
}

function test_array()
{
    var a, err;

    a = [1, 2, 3];
    assert(a.length, 3, "array");
    assert(a[2], 3, "array1");

    a = new Array(10);
    assert(a.length, 10, "array2");

    a = new Array(1, 2);
    assert(a.length === 2 && a[0] === 1 && a[1] === 2, true, "array3");

    a = [1, 2, 3];
    a.length = 2;
    assert(a.length === 2 && a[0] === 1 && a[1] === 2, true, "array4");

    a = [];
    a[1] = 10;
    a[4] = 3;
    assert(a.length, 5);

    a = [1,2];
    a.length = 5;
    a[4] = 1;
    a.length = 4;
    assert(a[4] !== 1, true, "array5");

    a = [1,2];
    a.push(3,4);
    assert(a.join(), "1,2,3,4", "join");

    a = [1,2,3,4,5];
    Object.defineProperty(a, "3", { configurable: false });
    err = false;
    try {
        a.length = 2;
    } catch(e) {
        err = true;
    }
    assert(err && a.toString() === "1,2,3,4");
}

function test_string()
{
    var a;
    a = String("abc");
    assert(a.length, 3, "string");
    assert(a[1], "b", "string");
    assert(a.charCodeAt(1), 0x62, "string");
    assert(String.fromCharCode(65), "A", "string");
    assert(String.fromCharCode.apply(null, [65, 66, 67]), "ABC", "string");
    assert(a.charAt(1), "b");
    assert(a.charAt(-1), "");
    assert(a.charAt(3), "");
    
    a = "abcd";
    assert(a.substring(1, 3), "bc", "substring");
    a = String.fromCharCode(0x20ac);
    assert(a.charCodeAt(0), 0x20ac, "unicode");
    assert(a, "€", "unicode");
    assert(a, "\u20ac", "unicode");
    assert(a, "\u{20ac}", "unicode");
    assert("a", "\x61", "unicode");
        
    a = "\u{10ffff}";
    assert(a.length, 2, "unicode");
    assert(a, "\u{dbff}\u{dfff}", "unicode");
    assert(a.codePointAt(0), 0x10ffff);
    assert(String.fromCodePoint(0x10ffff), a);

    assert("a".concat("b", "c"), "abc");

    assert("abcabc".indexOf("cab"), 2);
    assert("abcabc".indexOf("cab2"), -1);
    assert("abc".indexOf("c"), 2);

    assert("aaa".indexOf("a"), 0);
    assert("aaa".indexOf("a", NaN), 0);
    assert("aaa".indexOf("a", -Infinity), 0);
    assert("aaa".indexOf("a", -1), 0);
    assert("aaa".indexOf("a", -0), 0);
    assert("aaa".indexOf("a", 0), 0);
    assert("aaa".indexOf("a", 1), 1);
    assert("aaa".indexOf("a", 2), 2);
    assert("aaa".indexOf("a", 3), -1);
    assert("aaa".indexOf("a", 4), -1);
    assert("aaa".indexOf("a", Infinity), -1);

    assert("aaa".indexOf(""), 0);
    assert("aaa".indexOf("", NaN), 0);
    assert("aaa".indexOf("", -Infinity), 0);
    assert("aaa".indexOf("", -1), 0);
    assert("aaa".indexOf("", -0), 0);
    assert("aaa".indexOf("", 0), 0);
    assert("aaa".indexOf("", 1), 1);
    assert("aaa".indexOf("", 2), 2);
    assert("aaa".indexOf("", 3), 3);
    assert("aaa".indexOf("", 4), 3);
    assert("aaa".indexOf("", Infinity), 3);

    assert("aaa".lastIndexOf("a"), 2);
    assert("aaa".lastIndexOf("a", NaN), 2);
    assert("aaa".lastIndexOf("a", -Infinity), 0);
    assert("aaa".lastIndexOf("a", -1), 0);
    assert("aaa".lastIndexOf("a", -0), 0);
    assert("aaa".lastIndexOf("a", 0), 0);
    assert("aaa".lastIndexOf("a", 1), 1);
    assert("aaa".lastIndexOf("a", 2), 2);
    assert("aaa".lastIndexOf("a", 3), 2);
    assert("aaa".lastIndexOf("a", 4), 2);
    assert("aaa".lastIndexOf("a", Infinity), 2);

    assert("aaa".lastIndexOf(""), 3);
    assert("aaa".lastIndexOf("", NaN), 3);
    assert("aaa".lastIndexOf("", -Infinity), 0);
    assert("aaa".lastIndexOf("", -1), 0);
    assert("aaa".lastIndexOf("", -0), 0);
    assert("aaa".lastIndexOf("", 0), 0);
    assert("aaa".lastIndexOf("", 1), 1);
    assert("aaa".lastIndexOf("", 2), 2);
    assert("aaa".lastIndexOf("", 3), 3);
    assert("aaa".lastIndexOf("", 4), 3);
    assert("aaa".lastIndexOf("", Infinity), 3);

    assert("a,b,c".split(","), ["a","b","c"]);
    assert(",b,c".split(","), ["","b","c"]);
    assert("a,b,".split(","), ["a","b",""]);

    assert("aaaa".split(), [ "aaaa" ]);
    assert("aaaa".split(undefined, 0), [ ]);
    assert("aaaa".split(""), [ "a", "a", "a", "a" ]);
    assert("aaaa".split("", 0), [ ]);
    assert("aaaa".split("", 1), [ "a" ]);
    assert("aaaa".split("", 2), [ "a", "a" ]);
    assert("aaaa".split("a"), [ "", "", "", "", "" ]);
    assert("aaaa".split("a", 2), [ "", "" ]);
    assert("aaaa".split("aa"), [ "", "", "" ]);
    assert("aaaa".split("aa", 0), [ ]);
    assert("aaaa".split("aa", 1), [ "" ]);
    assert("aaaa".split("aa", 2), [ "", "" ]);
    assert("aaaa".split("aaa"), [ "", "a" ]);
    assert("aaaa".split("aaaa"), [ "", "" ]);
    assert("aaaa".split("aaaaa"), [ "aaaa" ]);
    assert("aaaa".split("aaaaa", 0), [  ]);
    assert("aaaa".split("aaaaa", 1), [ "aaaa" ]);

    assert(eval('"\0"'), "\0");

    assert("abc".padStart(Infinity, ""), "abc");
}

function test_math()
{
    var a;
    a = 1.4;
    assert(Math.floor(a), 1);
    assert(Math.ceil(a), 2);
    assert(Math.imul(0x12345678, 123), -1088058456);
    assert(Math.fround(0.1), 0.10000000149011612);
    assert(Math.hypot() == 0);
    assert(Math.hypot(-2) == 2);
    assert(Math.hypot(3, 4) == 5);
    assert(Math.abs(Math.hypot(3, 4, 5) - 7.0710678118654755) <= 1e-15);
}

function test_number()
{
    assert(parseInt("123"), 123);
    assert(parseInt("  123r"), 123);
    assert(parseInt("0x123"), 0x123);
    assert(parseInt("0o123"), 0);
    assert(+"  123   ", 123);
    assert(+"0b111", 7);
    assert(+"0o123", 83);
    assert(parseFloat("0x1234"), 0);
    assert(parseFloat("Infinity"), Infinity);
    assert(parseFloat("-Infinity"), -Infinity);
    assert(parseFloat("123.2"), 123.2);
    assert(parseFloat("123.2e3"), 123200);
    assert(Number.isNaN(Number("+")));
    assert(Number.isNaN(Number("-")));
    assert(Number.isNaN(Number("\x00a")));

    assert((25).toExponential(0), "3e+1");
    assert((-25).toExponential(0), "-3e+1");
    assert((2.5).toPrecision(1), "3");
    assert((-2.5).toPrecision(1), "-3");
    assert((1.125).toFixed(2), "1.13");
    assert((-1.125).toFixed(2), "-1.13");
}

function test_eval2()
{
    var g_call_count = 0;
    /* force non strict mode for f1 and f2 */
    var f1 = new Function("eval", "eval(1, 2)");
    var f2 = new Function("eval", "eval(...[1, 2])");
    function g(a, b) {
        assert(a, 1);
        assert(b, 2);
        g_call_count++;
    }
    f1(g);
    f2(g);
    assert(g_call_count, 2);
}

function test_eval()
{
    function f(b) {
        var x = 1;
        return eval(b);
    }
    var r, a;

    r = eval("1+1;");
    assert(r, 2, "eval");

    r = eval("var my_var=2; my_var;");
    assert(r, 2, "eval");
    assert(typeof my_var, "undefined");

    assert(eval("if (1) 2; else 3;"), 2);
    assert(eval("if (0) 2; else 3;"), 3);

    assert(f.call(1, "this"), 1);
    
    a = 2;
    assert(eval("a"), 2);

    eval("a = 3");
    assert(a, 3);

    assert(f("arguments.length", 1), 2);
    assert(f("arguments[1]", 1), 1);

    a = 4;
    assert(f("a"), 4);
    f("a=3");
    assert(a, 3);

    test_eval2();
}

function test_typed_array()
{
    var buffer, a, i, str;

    a = new Uint8Array(4);
    assert(a.length, 4);
    for(i = 0; i < a.length; i++)
        a[i] = i;
    assert(a.join(","), "0,1,2,3");
    a[0] = -1;
    assert(a[0], 255);

    a = new Int8Array(3);
    a[0] = 255;
    assert(a[0], -1);

    a = new Int32Array(3);
    a[0] = Math.pow(2, 32) - 1;
    assert(a[0], -1);
    assert(a.BYTES_PER_ELEMENT, 4);

    a = new Uint8ClampedArray(4);
    a[0] = -100;
    a[1] = 1.5;
    a[2] = 0.5;
    a[3] = 1233.5;
    assert(a.toString(), "0,2,0,255");
    
    buffer = new ArrayBuffer(16);
    assert(buffer.byteLength, 16);
    a = new Uint32Array(buffer, 12, 1);
    assert(a.length, 1);
    a[0] = -1;

    a = new Uint16Array(buffer, 2);
    a[0] = -1;

    a = new Float32Array(buffer, 8, 1);
    a[0] = 1;
    
    a = new Uint8Array(buffer);

    str = a.toString();
    /* test little and big endian cases */
    if (str !== "0,0,255,255,0,0,0,0,0,0,128,63,255,255,255,255" &&
        str !== "0,0,255,255,0,0,0,0,63,128,0,0,255,255,255,255") {
        assert(false);
    }

    assert(a.buffer, buffer);

    a = new Uint8Array([1, 2, 3, 4]);
    assert(a.toString(), "1,2,3,4");
    a.set([10, 11], 2);
    assert(a.toString(), "1,2,10,11");
}

function test_json()
{
    var a, s;
    s = '{"x":1,"y":true,"z":null,"a":[1,2,3],"s":"str"}';
    a = JSON.parse(s);
    assert(a.x, 1);
    assert(a.y, true);
    assert(a.z, null);
    assert(JSON.stringify(a), s);

    /* indentation test */
    assert(JSON.stringify([[{x:1,y:{},z:[]},2,3]],undefined,1),
`[
 [
  {
   "x": 1,
   "y": {},
   "z": []
  },
  2,
  3
 ]
]`);
}

function test_date()
{
    var d = new Date(1506098258091), a, s;
    assert(d.toISOString(), "2017-09-22T16:37:38.091Z");
    d.setUTCHours(18, 10, 11);
    assert(d.toISOString(), "2017-09-22T18:10:11.091Z");
    a = Date.parse(d.toISOString());
    assert((new Date(a)).toISOString(), d.toISOString());
    s = new Date("2020-01-01T01:01:01.1Z").toISOString();
    assert(s ==  "2020-01-01T01:01:01.100Z");
    s = new Date("2020-01-01T01:01:01.12Z").toISOString();
    assert(s ==  "2020-01-01T01:01:01.120Z");
    s = new Date("2020-01-01T01:01:01.123Z").toISOString();
    assert(s ==  "2020-01-01T01:01:01.123Z");
    s = new Date("2020-01-01T01:01:01.1234Z").toISOString();
    assert(s ==  "2020-01-01T01:01:01.123Z");
    s = new Date("2020-01-01T01:01:01.12345Z").toISOString();
    assert(s ==  "2020-01-01T01:01:01.123Z");
    s = new Date("2020-01-01T01:01:01.1235Z").toISOString();
    assert(s ==  "2020-01-01T01:01:01.124Z");
    s = new Date("2020-01-01T01:01:01.9999Z").toISOString();
    assert(s ==  "2020-01-01T01:01:02.000Z");
}

function test_regexp()
{
    var a, str;
    str = "abbbbbc";
    a = /(b+)c/.exec(str);
    assert(a[0], "bbbbbc");
    assert(a[1], "bbbbb");
    assert(a.index, 1);
    assert(a.input, str);
    a = /(b+)c/.test(str);
    assert(a, true);
    assert(/\x61/.exec("a")[0], "a");
    assert(/\u0061/.exec("a")[0], "a");
    assert(/\ca/.exec("\x01")[0], "\x01");
    assert(/\\a/.exec("\\a")[0], "\\a");
    assert(/\c0/.exec("\\c0")[0], "\\c0");

    a = /(\.(?=com|org)|\/)/.exec("ah.com");
    assert(a.index === 2 && a[0] === ".");

    a = /(\.(?!com|org)|\/)/.exec("ah.com");
    assert(a, null);
    
    a = /(?=(a+))/.exec("baaabac");
    assert(a.index === 1 && a[0] === "" && a[1] === "aaa");

    a = /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac");
    assert(a, ["zaacbbbcac","z","ac","a",,"c"]);

    a = eval("/\0a/");
    assert(a.toString(), "/\0a/");
    assert(a.exec("\0a")[0], "\0a");

    assert(/{1a}/.toString(), "/{1a}/");
    a = /a{1+/.exec("a{11");
    assert(a, ["a{11"] );
}

function test_symbol()
{
    var a, b, obj, c;
    a = Symbol("abc");
    obj = {};
    obj[a] = 2;
    assert(obj[a], 2);
    assert(typeof obj["abc"], "undefined");
    assert(String(a), "Symbol(abc)");
    b = Symbol("abc");
    assert(a == a);
    assert(a === a);
    assert(a != b);
    assert(a !== b);

    b = Symbol.for("abc");
    c = Symbol.for("abc");
    assert(b === c);
    assert(b !== a);

    assert(Symbol.keyFor(b), "abc");
    assert(Symbol.keyFor(a), undefined);

    a = Symbol("aaa");
    assert(a.valueOf(), a);
    assert(a.toString(), "Symbol(aaa)");

    b = Object(a);
    assert(b.valueOf(), a);
    assert(b.toString(), "Symbol(aaa)");
}

function test_map()
{
    var a, i, n, tab, o, v;
    n = 1000;
    a = new Map();
    tab = [];
    for(i = 0; i < n; i++) {
        v = { };
        o = { id: i };
        tab[i] = [o, v];
        a.set(o, v);
    }

    assert(a.size, n);
    for(i = 0; i < n; i++) {
        assert(a.get(tab[i][0]), tab[i][1]);
    }

    i = 0;
    a.forEach(function (v, o) { 
        assert(o, tab[i++][0]);
        assert(a.has(o));
        assert(a.delete(o));
        assert(!a.has(o));
    });

    assert(a.size, 0);
}

function test_weak_map()
{
    var a, i, n, tab, o, v, n2;
    a = new WeakMap();
    n = 10;
    tab = [];
    for(i = 0; i < n; i++) {
        v = { };
        o = { id: i };
        tab[i] = [o, v];
        a.set(o, v);
    }
    o = null;
    
    n2 = n >> 1;
    for(i = 0; i < n2; i++) {
        a.delete(tab[i][0]);
    }
    for(i = n2; i < n; i++) {
        tab[i][0] = null; /* should remove the object from the WeakMap too */
    }
    /* the WeakMap should be empty here */
}

function test_generator()
{
    function *f() {
        var ret;
        yield 1;
        ret = yield 2;
        assert(ret, "next_arg");
        return 3;
    }
    function *f2() {
        yield 1;
        yield 2;
        return "ret_val";
    }
    function *f1() {
        var ret = yield *f2();
        assert(ret, "ret_val");
        return 3;
    }
    var g, v;
    g = f();
    v = g.next();
    assert(v.value === 1 && v.done === false);
    v = g.next();
    assert(v.value === 2 && v.done === false);
    v = g.next("next_arg");
    assert(v.value === 3 && v.done === true);
    v = g.next();
    assert(v.value === undefined && v.done === true);

    g = f1();
    v = g.next();
    assert(v.value === 1 && v.done === false);
    v = g.next();
    assert(v.value === 2 && v.done === false);
    v = g.next();
    assert(v.value === 3 && v.done === true);
    v = g.next();
    assert(v.value === undefined && v.done === true);
}

test();
test_function();
test_enum();
test_array();
test_string();
test_math();
test_number();
test_eval();
test_typed_array();
test_json();
test_date();
test_regexp();
test_symbol();
test_map();
test_weak_map();
test_generator();

'''
'''--- tests/test_closure.js ---
function assert(actual, expected, message) {
    if (arguments.length == 1)
        expected = true;

    if (actual === expected)
        return;

    if (actual !== null && expected !== null
    &&  typeof actual == 'object' && typeof expected == 'object'
    &&  actual.toString() === expected.toString())
        return;

    throw Error("assertion failed: got |" + actual + "|" +
                ", expected |" + expected + "|" +
                (message ? " (" + message + ")" : ""));
}

// load more elaborate version of assert if available
try { __loadScript("test_assert.js"); } catch(e) {}

/*----------------*/

var log_str = "";

function log(str)
{
    log_str += str + ",";
}

function f(a, b, c)
{
    var x = 10;
    log("a="+a);
    function g(d) {
        function h() {
            log("d=" + d);
            log("x=" + x);
        }
        log("b=" + b);
        log("c=" + c);
        h();
    }
    g(4);
    return g;
}

var g1 = f(1, 2, 3);
g1(5);

assert(log_str, "a=1,b=2,c=3,d=4,x=10,b=2,c=3,d=5,x=10,", "closure1");

function test_closure1()
{
    function f2()
    {
        var val = 1;
        
        function set(a) {
            val = a;
        }
        function get(a) {
            return val;
        }
        return { "set": set, "get": get };
    }
    
    var obj = f2();
    obj.set(10);
    var r;
    r = obj.get();
    assert(r, 10, "closure2");
}

function test_closure2()
{
    var expr_func = function myfunc1(n) {
        function myfunc2(n) {
            return myfunc1(n - 1);
        }
        if (n == 0)
            return 0;
        else
            return myfunc2(n);
    };
    var r;
    r = expr_func(1);
    assert(r, 0, "expr_func");
}

function test_closure3()
{
    function fib(n)
    {
        if (n <= 0)
            return 0;
        else if (n == 1)
            return 1;
        else
            return fib(n - 1) + fib(n - 2);
    }

    var fib_func = function fib1(n)
    {
        if (n <= 0)
            return 0;
        else if (n == 1)
            return 1;
        else
            return fib1(n - 1) + fib1(n - 2);
    };

    assert(fib(6), 8, "fib");
    assert(fib_func(6), 8, "fib_func");
}

function test_arrow_function()
{
    "use strict";

    function f1() {
        return (() => arguments)();
    }
    function f2() {
        return (() => this)();
    }
    function f3() {
        return (() => eval("this"))();
    }
    function f4() {
        return (() => eval("new.target"))();
    }
    var a;

    a = f1(1, 2);
    assert(a.length, 2);
    assert(a[0] === 1 && a[1] === 2);

    assert(f2.call("this_val") === "this_val");
    assert(f3.call("this_val") === "this_val");
    assert(new f4() === f4);

    var o1 = { f() { return this; } };
    var o2 = { f() {
        return (() => eval("super.f()"))();
    } };
    o2.__proto__ = o1;

    assert(o2.f() === o2);
}

function test_with()
{
    var o1 = { x: "o1", y: "o1" };
    var x = "local";
    eval('var z="var_obj";');
    assert(z === "var_obj");
    with (o1) {
        assert(x === "o1");
        assert(eval("x") === "o1");
        var f = function () {
            o2 = { x: "o2" };
            with (o2) {
                assert(x === "o2");
                assert(y === "o1");
                assert(z === "var_obj");
                assert(eval("x") === "o2");
                assert(eval("y") === "o1");
                assert(eval("z") === "var_obj");
                assert(eval('eval("x")') === "o2");
            }
        };
        f();
    }
}

function test_eval_closure()
{
    var tab;

    tab = [];
    for(let i = 0; i < 3; i++) {
        eval("tab.push(function g1() { return i; })");
    }
    for(let i = 0; i < 3; i++) {
        assert(tab[i]() === i);
    }

    tab = [];
    for(let i = 0; i < 3; i++) {
        let f = function f() {
            eval("tab.push(function g2() { return i; })");
        };
        f();
    }
    for(let i = 0; i < 3; i++) {
        assert(tab[i]() === i);
    }
}

function test_eval_const()
{
    const a = 1;
    var success = false;
    var f = function () {
        eval("a = 1");
    };
    try {
        f();
    } catch(e) {
        success = (e instanceof TypeError);
    }
    assert(success);
}

test_closure1();
test_closure2();
test_closure3();
test_arrow_function();
test_with();
test_eval_closure();
test_eval_const();

'''
'''--- tests/test_language.js ---
function assert(actual, expected, message) {
    if (arguments.length == 1)
        expected = true;

    if (actual === expected)
        return;

    if (actual !== null && expected !== null
    &&  typeof actual == 'object' && typeof expected == 'object'
    &&  actual.toString() === expected.toString())
        return;

    throw Error("assertion failed: got |" + actual + "|" +
                ", expected |" + expected + "|" +
                (message ? " (" + message + ")" : ""));
}

function assert_throws(expected_error, func)
{
    var err = false;
    try {
        func();
    } catch(e) {
        err = true;
        if (!(e instanceof expected_error)) {
            throw Error("unexpected exception type");
        }
    }
    if (!err) {
        throw Error("expected exception");
    }
}

// load more elaborate version of assert if available
try { __loadScript("test_assert.js"); } catch(e) {}

/*----------------*/

function test_op1()
{
    var r, a;
    r = 1 + 2;
    assert(r, 3, "1 + 2 === 3");

    r = 1 - 2;
    assert(r, -1, "1 - 2 === -1");

    r = -1;
    assert(r, -1, "-1 === -1");

    r = +2;
    assert(r, 2, "+2 === 2");

    r = 2 * 3;
    assert(r, 6, "2 * 3 === 6");

    r = 4 / 2;
    assert(r, 2, "4 / 2 === 2");

    r = 4 % 3;
    assert(r, 1, "4 % 3 === 3");

    r = 4 << 2;
    assert(r, 16, "4 << 2 === 16");

    r = 1 << 0;
    assert(r, 1, "1 << 0 === 1");

    r = 1 << 31;
    assert(r, -2147483648, "1 << 31 === -2147483648");
    
    r = 1 << 32;
    assert(r, 1, "1 << 32 === 1");
    
    r = (1 << 31) < 0;
    assert(r, true, "(1 << 31) < 0 === true");

    r = -4 >> 1;
    assert(r, -2, "-4 >> 1 === -2");

    r = -4 >>> 1;
    assert(r, 0x7ffffffe, "-4 >>> 1 === 0x7ffffffe");

    r = 1 & 1;
    assert(r, 1, "1 & 1 === 1");

    r = 0 | 1;
    assert(r, 1, "0 | 1 === 1");

    r = 1 ^ 1;
    assert(r, 0, "1 ^ 1 === 0");

    r = ~1;
    assert(r, -2, "~1 === -2");

    r = !1;
    assert(r, false, "!1 === false");

    assert((1 < 2), true, "(1 < 2) === true");

    assert((2 > 1), true, "(2 > 1) === true");

    assert(('b' > 'a'), true, "('b' > 'a') === true");

    assert(2 ** 8, 256, "2 ** 8 === 256");
}

function test_cvt()
{
    assert((NaN | 0) === 0);
    assert((Infinity | 0) === 0);
    assert(((-Infinity) | 0) === 0);
    assert(("12345" | 0) === 12345);
    assert(("0x12345" | 0) === 0x12345);
    assert(((4294967296 * 3 - 4) | 0) === -4);
    
    assert(("12345" >>> 0) === 12345);
    assert(("0x12345" >>> 0) === 0x12345);
    assert((NaN >>> 0) === 0);
    assert((Infinity >>> 0) === 0);
    assert(((-Infinity) >>> 0) === 0);
    assert(((4294967296 * 3 - 4) >>> 0) === (4294967296 - 4));
}

function test_eq()
{
    assert(null == undefined);
    assert(undefined == null);
    assert(true == 1);
    assert(0 == false);
    assert("" == 0);
    assert("123" == 123);
    assert("122" != 123);
    assert((new Number(1)) == 1);
    assert(2 == (new Number(2)));
    assert((new String("abc")) == "abc");
    assert({} != "abc");
}

function test_inc_dec()
{
    var a, r;
    
    a = 1;
    r = a++;
    assert(r === 1 && a === 2, true, "++");

    a = 1;
    r = ++a;
    assert(r === 2 && a === 2, true, "++");

    a = 1;
    r = a--;
    assert(r === 1 && a === 0, true, "--");

    a = 1;
    r = --a;
    assert(r === 0 && a === 0, true, "--");

    a = {x:true};
    a.x++;
    assert(a.x, 2, "++");

    a = {x:true};
    a.x--;
    assert(a.x, 0, "--");

    a = [true];
    a[0]++;
    assert(a[0], 2, "++");
    
    a = {x:true};
    r = a.x++;
    assert(r === 1 && a.x === 2, true, "++");
    
    a = {x:true};
    r = a.x--;
    assert(r === 1 && a.x === 0, true, "--");
    
    a = [true];
    r = a[0]++;
    assert(r === 1 && a[0] === 2, true, "++");
    
    a = [true];
    r = a[0]--;
    assert(r === 1 && a[0] === 0, true, "--");
}

function F(x)
{
    this.x = x;
}

function test_op2()
{
    var a, b;
    a = new Object;
    a.x = 1;
    assert(a.x, 1, "new");
    b = new F(2);
    assert(b.x, 2, "new");

    a = {x : 2};
    assert(("x" in a), true, "in");
    assert(("y" in a), false, "in");

    a = {};
    assert((a instanceof Object), true, "instanceof");
    assert((a instanceof String), false, "instanceof");

    assert((typeof 1), "number", "typeof");
    assert((typeof Object), "function", "typeof");
    assert((typeof null), "object", "typeof");
    assert((typeof unknown_var), "undefined", "typeof");
    
    a = {x: 1, if: 2, async: 3};
    assert(a.if === 2);
    assert(a.async === 3);
}

function test_delete()
{
    var a, err;

    a = {x: 1, y: 1};
    assert((delete a.x), true, "delete");
    assert(("x" in a), false, "delete");
    
    /* the following are not tested by test262 */
    assert(delete "abc"[100], true);

    err = false;
    try {
        delete null.a;
    } catch(e) {
        err = (e instanceof TypeError);
    }
    assert(err, true, "delete");

    err = false;
    try {
        a = { f() { delete super.a; } };
        a.f();
    } catch(e) {
        err = (e instanceof ReferenceError);
    }
    assert(err, true, "delete");
}

function test_prototype()
{
    var f = function f() { };
    assert(f.prototype.constructor, f, "prototype");

    var g = function g() { };
    /* QuickJS bug */
    Object.defineProperty(g, "prototype", { writable: false });
    assert(g.prototype.constructor, g, "prototype");
}

function test_arguments()
{
    function f2() {
        assert(arguments.length, 2, "arguments");
        assert(arguments[0], 1, "arguments");
        assert(arguments[1], 3, "arguments");
    }
    f2(1, 3);
}

function test_class()
{
    var o;
    class C {
        constructor() {
            this.x = 10;
        }
        f() {
            return 1;
        }
        static F() {
            return -1;
        }
        get y() {
            return 12;
        }
    };
    class D extends C {
        constructor() {
            super();
            this.z = 20;
        }
        g() {
            return 2;
        }
        static G() {
            return -2;
        }
        h() {
            return super.f();
        }
        static H() {
            return super["F"]();
        }
    }

    assert(C.F() === -1);
    assert(Object.getOwnPropertyDescriptor(C.prototype, "y").get.name === "get y");

    o = new C();
    assert(o.f() === 1);
    assert(o.x === 10);
    
    assert(D.F() === -1);
    assert(D.G() === -2);
    assert(D.H() === -1);

    o = new D();
    assert(o.f() === 1);
    assert(o.g() === 2);
    assert(o.x === 10);
    assert(o.z === 20);
    assert(o.h() === 1);

    /* test class name scope */
    var E1 = class E { static F() { return E; } };
    assert(E1 === E1.F());
};

function test_template()
{
    var a, b;
    b = 123;
    a = `abc${b}d`;
    assert(a, "abc123d");

    a = String.raw `abc${b}d`;
    assert(a, "abc123d");

    a = "aaa";
    b = "bbb";
    assert(`aaa${a, b}ccc`, "aaabbbccc");
}

function test_template_skip()
{
    var a = "Bar";
    var { b = `${a + `a${a}` }baz` } = {};
    assert(b, "BaraBarbaz");
}

function test_object_literal()
{
    var x = 0, get = 1, set = 2; async = 3;
    a = { get: 2, set: 3, async: 4 };
    assert(JSON.stringify(a), '{"get":2,"set":3,"async":4}');

    a = { x, get, set, async };
    assert(JSON.stringify(a), '{"x":0,"get":1,"set":2,"async":3}');
}

function test_regexp_skip()
{
    var a, b;
    [a, b = /abc\(/] = [1];
    assert(a === 1);
    
    [a, b =/abc\(/] = [2];
    assert(a === 2);
}

function test_labels()
{
    do x: { break x; } while(0);
    if (1)
        x: { break x; }
    else
        x: { break x; }
    with ({}) x: { break x; };
    while (0) x: { break x; };
}

function test_destructuring()
{
    function * g () { return 0; };
    var [x] = g();
    assert(x, void 0);
}

function test_spread()
{
    var x;
    x = [1, 2, ...[3, 4]];
    assert(x.toString(), "1,2,3,4");

    x = [ ...[ , ] ];
    assert(Object.getOwnPropertyNames(x).toString(), "0,length");
}

function test_function_length()
{
    assert( ((a, b = 1, c) => {}).length, 1);
    assert( (([a,b]) => {}).length, 1);
    assert( (({a,b}) => {}).length, 1);
    assert( ((c, [a,b] = 1, d) => {}).length, 1);
}

function test_argument_scope()
{
    var f;
    var c = "global";
    
    f = function(a = eval("var arguments")) {};
    assert_throws(SyntaxError, f);

    f = function(a = eval("1"), b = arguments[0]) { return b; };
    assert(f(12), 12);

    f = function(a, b = arguments[0]) { return b; };
    assert(f(12), 12);

    f = function(a, b = () => arguments) { return b; };
    assert(f(12)()[0], 12);

    f = function(a = eval("1"), b = () => arguments) { return b; };
    assert(f(12)()[0], 12);

    (function() {
        "use strict";
        f = function(a = this) { return a; };
        assert(f.call(123), 123);

        f = function f(a = f) { return a; };
        assert(f(), f);

        f = function f(a = eval("f")) { return a; };
        assert(f(), f);
    })();

    f = (a = eval("var c = 1"), probe = () => c) => {
        var c = 2;
        assert(c, 2);
        assert(probe(), 1);
    }
    f();

    f = (a = eval("var arguments = 1"), probe = () => arguments) => {
        var arguments = 2;
        assert(arguments, 2);
        assert(probe(), 1);
    }
    f();

    f = function f(a = eval("var c = 1"), b = c, probe = () => c) {
        assert(b, 1);
        assert(c, 1);
        assert(probe(), 1)
    }
    f();

    assert(c, "global");
    f = function f(a, b = c, probe = () => c) {
        eval("var c = 1");
        assert(c, 1);
        assert(b, "global");
        assert(probe(), "global")
    }
    f();
    assert(c, "global");

    f = function f(a = eval("var c = 1"), probe = (d = eval("c")) => d) {
        assert(probe(), 1)
    }
    f();
}

function test_function_expr_name()
{
    var f;

    /* non strict mode test : assignment to the function name silently
       fails */
    
    f = function myfunc() {
        myfunc = 1;
        return myfunc;
    };
    assert(f(), f);

    f = function myfunc() {
        myfunc = 1;
        (() => {
            myfunc = 1;
        })();
        return myfunc;
    };
    assert(f(), f);

    f = function myfunc() {
        eval("myfunc = 1");
        return myfunc;
    };
    assert(f(), f);
    
    /* strict mode test : assignment to the function name raises a
       TypeError exception */

    f = function myfunc() {
        "use strict";
        myfunc = 1;
    };
    assert_throws(TypeError, f);

    f = function myfunc() {
        "use strict";
        (() => {
            myfunc = 1;
        })();
    };
    assert_throws(TypeError, f);

    f = function myfunc() {
        "use strict";
        eval("myfunc = 1");
    };
    assert_throws(TypeError, f);
}

test_op1();
test_cvt();
test_eq();
test_inc_dec();
test_op2();
test_delete();
test_prototype();
test_arguments();
test_class();
test_template();
test_template_skip();
test_object_literal();
test_regexp_skip();
test_labels();
test_destructuring();
test_spread();
test_function_length();
test_argument_scope();
test_function_expr_name();

'''
'''--- tests/test_loop.js ---
function assert(actual, expected, message) {
    if (arguments.length == 1)
        expected = true;

    if (actual === expected)
        return;

    if (actual !== null && expected !== null
    &&  typeof actual == 'object' && typeof expected == 'object'
    &&  actual.toString() === expected.toString())
        return;

    throw Error("assertion failed: got |" + actual + "|" +
                ", expected |" + expected + "|" +
                (message ? " (" + message + ")" : ""));
}

// load more elaborate version of assert if available
try { __loadScript("test_assert.js"); } catch(e) {}

/*----------------*/

function test_while()
{
    var i, c;
    i = 0;
    c = 0;
    while (i < 3) {
        c++;
        i++;
    }
    assert(c === 3);
}

function test_while_break()
{
    var i, c;
    i = 0;
    c = 0;
    while (i < 3) {
        c++;
        if (i == 1)
            break;
        i++;
    }
    assert(c === 2 && i === 1);
}

function test_do_while()
{
    var i, c;
    i = 0;
    c = 0;
    do {
        c++;
        i++;
    } while (i < 3);
    assert(c === 3 && i === 3);
}

function test_for()
{
    var i, c;
    c = 0;
    for(i = 0; i < 3; i++) {
        c++;
    }
    assert(c === 3 && i === 3);

    c = 0;
    for(var j = 0; j < 3; j++) {
        c++;
    }
    assert(c === 3 && j === 3);
}

function test_for_in()
{
    var i, tab, a, b;

    tab = [];
    for(i in {x:1, y: 2}) {
        tab.push(i);
    }
    assert(tab.toString(), "x,y", "for_in");

    /* prototype chain test */
    a = {x:2, y: 2, "1": 3};
    b = {"4" : 3 };
    Object.setPrototypeOf(a, b);
    tab = [];
    for(i in a) {
        tab.push(i);
    }
    assert(tab.toString(), "1,x,y,4", "for_in");

    /* non enumerable properties hide enumerables ones in the
       prototype chain */
    a = {y: 2, "1": 3};
    Object.defineProperty(a, "x", { value: 1 });
    b = {"x" : 3 };
    Object.setPrototypeOf(a, b);
    tab = [];
    for(i in a) {
        tab.push(i);
    }
    assert(tab.toString(), "1,y", "for_in");

    /* array optimization */
    a = [];
    for(i = 0; i < 10; i++)
        a.push(i);
    tab = [];
    for(i in a) {
        tab.push(i);
    }
    assert(tab.toString(), "0,1,2,3,4,5,6,7,8,9", "for_in");

    /* iterate with a field */
    a={x:0};
    tab = [];
    for(a.x in {x:1, y: 2}) {
        tab.push(a.x);
    }
    assert(tab.toString(), "x,y", "for_in");

    /* iterate with a variable field */
    a=[0];
    tab = [];
    for(a[0] in {x:1, y: 2}) {
        tab.push(a[0]);
    }
    assert(tab.toString(), "x,y", "for_in");

    /* variable definition in the for in */
    tab = [];
    for(var j in {x:1, y: 2}) {
        tab.push(j);
    }
    assert(tab.toString(), "x,y", "for_in");

    /* variable assigment in the for in */
    tab = [];
    for(var k = 2 in {x:1, y: 2}) {
        tab.push(k);
    }
    assert(tab.toString(), "x,y", "for_in");
}

function test_for_in2()
{
    var i;
    tab = [];
    for(i in {x:1, y: 2, z:3}) {
        if (i === "y")
            continue;
        tab.push(i);
    }
    assert(tab.toString() == "x,z");

    tab = [];
    for(i in {x:1, y: 2, z:3}) {
        if (i === "z")
            break;
        tab.push(i);
    }
    assert(tab.toString() == "x,y");
}

function test_for_break()
{
    var i, c;
    c = 0;
    L1: for(i = 0; i < 3; i++) {
        c++;
        if (i == 0)
            continue;
        while (1) {
            break L1;
        }
    }
    assert(c === 2 && i === 1);
}

function test_switch1()
{
    var i, a, s;
    s = "";
    for(i = 0; i < 3; i++) {
        a = "?";
        switch(i) {
        case 0:
            a = "a";
            break;
        case 1:
            a = "b";
            break;
        default:
            a = "c";
            break;
        }
        s += a;
    }
    assert(s === "abc" && i === 3);
}

function test_switch2()
{
    var i, a, s;
    s = "";
    for(i = 0; i < 4; i++) {
        a = "?";
        switch(i) {
        case 0:
            a = "a";
            break;
        case 1:
            a = "b";
            break;
        case 2:
            continue;
        default:
            a = "" + i;
            break;
        }
        s += a;
    }
    assert(s === "ab3" && i === 4);
}

function test_try_catch1()
{
    try {
        throw "hello";
    } catch (e) {
        assert(e, "hello", "catch");
        return;
    }
    assert(false, "catch");
}

function test_try_catch2()
{
    var a;
    try {
        a = 1;
    } catch (e) {
        a = 2;
    }
    assert(a, 1, "catch");
}

function test_try_catch3()
{
    var s;
    s = "";
    try {
        s += "t";
    } catch (e) {
        s += "c";
    } finally {
        s += "f";
    }
    assert(s, "tf", "catch");
}

function test_try_catch4()
{
    var s;
    s = "";
    try {
        s += "t";
        throw "c";
    } catch (e) {
        s += e;
    } finally {
        s += "f";
    }
    assert(s, "tcf", "catch");
}

function test_try_catch5()
{
    var s;
    s = "";
    for(;;) {
        try {
            s += "t";
            break;
            s += "b";
        } finally {
            s += "f";
        }
    }
    assert(s, "tf", "catch");
}

function test_try_catch6()
{
    function f() {
        try {
            s += 't';
            return 1;
        } finally {
            s += "f";
        }
    }
    var s = "";
    assert(f() === 1);
    assert(s, "tf", "catch6");
}

function test_try_catch7()
{
    var s;
    s = "";

    try {
        try {
            s += "t";
            throw "a";
        } finally {
            s += "f";
        }
    } catch(e) {
        s += e;
    } finally {
        s += "g";
    }
    assert(s, "tfag", "catch");
}

function test_try_catch8()
{
    var i, s;
    
    s = "";
    for(var i in {x:1, y:2}) {
        try {
            s += i;
            throw "a";
        } catch (e) {
            s += e;
        } finally {
            s += "f";
        }
    }
    assert(s === "xafyaf");
}

test_while();
test_while_break();
test_do_while();
test_for();
test_for_break();
test_switch1();
test_switch2();
test_for_in();
test_for_in2();

test_try_catch1();
test_try_catch2();
test_try_catch3();
test_try_catch4();
test_try_catch5();
test_try_catch6();
test_try_catch7();
test_try_catch8();

'''
'''--- tests/test_op_overloading.js ---
"use strict";

function assert(actual, expected, message) {
    if (arguments.length == 1)
        expected = true;

    if (actual === expected)
        return;

    if (actual !== null && expected !== null
    &&  typeof actual == 'object' && typeof expected == 'object'
    &&  actual.toString() === expected.toString())
        return;

    throw Error("assertion failed: got |" + actual + "|" +
                ", expected |" + expected + "|" +
                (message ? " (" + message + ")" : ""));
}

/* operators overloading with Operators.create() */
function test_operators_create() {
    class Vec2
    {
        constructor(x, y) {
            this.x = x;
            this.y = y;
        }
        static mul_scalar(p1, a) {
            var r = new Vec2();
            r.x = p1.x * a;
            r.y = p1.y * a;
            return r;
        }
        toString() {
            return "Vec2(" + this.x + "," + this.y + ")";
        }
    }
    
    Vec2.prototype[Symbol.operatorSet] = Operators.create(
    {
        "+"(p1, p2) {
            var r = new Vec2();
            r.x = p1.x + p2.x;
            r.y = p1.y + p2.y;
            return r;
        },
        "-"(p1, p2) {
            var r = new Vec2();
            r.x = p1.x - p2.x;
            r.y = p1.y - p2.y;
            return r;
        },
        "=="(a, b) {
            return a.x == b.x && a.y == b.y;
        },
        "<"(a, b) {
            var r;
            /* lexicographic order */
            if (a.x == b.x)
                r = (a.y < b.y);
            else
                r = (a.x < b.x);
            return r;
        },
        "++"(a) {
            var r = new Vec2();
            r.x = a.x + 1;
            r.y = a.y + 1;
            return r;
        }
    },
    {
        left: Number,
        "*"(a, b) {
            return Vec2.mul_scalar(b, a);
        }
    },
    {
        right: Number,
        "*"(a, b) {
            return Vec2.mul_scalar(a, b);
        }
    });

    var a = new Vec2(1, 2);
    var b = new Vec2(3, 4);
    var r;

    r = a * 2 + 3 * b;
    assert(r.x === 11 && r.y === 16);
    assert(a == a, true);
    assert(a == b, false);
    assert(a != a, false);
    assert(a < b, true);
    assert(a <= b, true);
    assert(b < a, false);
    assert(b <= a, false);
    assert(a <= a, true);
    assert(a >= a, true);
    a++;
    assert(a.x === 2 && a.y === 3);
    r = ++a;
    assert(a.x === 3 && a.y === 4);
    assert(r === a);
}

/* operators overloading thru inheritance */
function test_operators()
{
    var Vec2;

    function mul_scalar(p1, a) {
        var r = new Vec2();
        r.x = p1.x * a;
        r.y = p1.y * a;
        return r;
    }

    var vec2_ops = Operators({
        "+"(p1, p2) {
            var r = new Vec2();
            r.x = p1.x + p2.x;
            r.y = p1.y + p2.y;
            return r;
        },
        "-"(p1, p2) {
            var r = new Vec2();
            r.x = p1.x - p2.x;
            r.y = p1.y - p2.y;
            return r;
        },
        "=="(a, b) {
            return a.x == b.x && a.y == b.y;
        },
        "<"(a, b) {
            var r;
            /* lexicographic order */
            if (a.x == b.x)
                r = (a.y < b.y);
            else
                r = (a.x < b.x);
            return r;
        },
        "++"(a) {
            var r = new Vec2();
            r.x = a.x + 1;
            r.y = a.y + 1;
            return r;
        }
    },
    {
        left: Number,
        "*"(a, b) {
            return mul_scalar(b, a);
        }
    },
    {
        right: Number,
        "*"(a, b) {
            return mul_scalar(a, b);
        }
    });

    Vec2 = class Vec2 extends vec2_ops
    {
        constructor(x, y) {
            super();
            this.x = x;
            this.y = y;
        }
        toString() {
            return "Vec2(" + this.x + "," + this.y + ")";
        }
    }
    
    var a = new Vec2(1, 2);
    var b = new Vec2(3, 4);
    var r;

    r = a * 2 + 3 * b;
    assert(r.x === 11 && r.y === 16);
    assert(a == a, true);
    assert(a == b, false);
    assert(a != a, false);
    assert(a < b, true);
    assert(a <= b, true);
    assert(b < a, false);
    assert(b <= a, false);
    assert(a <= a, true);
    assert(a >= a, true);
    a++;
    assert(a.x === 2 && a.y === 3);
    r = ++a;
    assert(a.x === 3 && a.y === 4);
    assert(r === a);
}

function test_default_op()
{
    assert(Object(1) + 2, 3);
    assert(Object(1) + true, 2);
    assert(-Object(1), -1);
}

test_operators_create();
test_operators();
test_default_op();

'''
'''--- tests/test_qjscalc.js ---
"use math";
"use strict";

function assert(actual, expected, message) {
    if (arguments.length == 1)
        expected = true;

    if (actual === expected)
        return;

    if (actual !== null && expected !== null
    &&  typeof actual == 'object' && typeof expected == 'object'
    &&  actual.toString() === expected.toString())
        return;

    throw Error("assertion failed: got |" + actual + "|" +
                ", expected |" + expected + "|" +
                (message ? " (" + message + ")" : ""));
}

function assertThrows(err, func)
{
    var ex;
    ex = false;
    try {
        func();
    } catch(e) {
        ex = true;
        assert(e instanceof err);
    }
    assert(ex, true, "exception expected");
}

// load more elaborate version of assert if available
try { __loadScript("test_assert.js"); } catch(e) {}

/*----------------*/

function pow(a, n)
{
    var r, i;
    r = 1;
    for(i = 0; i < n; i++)
        r *= a;
    return r;
}

function test_integer()
{
    var a, r;
    a = pow(3, 100);
    assert((a - 1) != a);
    assert(a == 515377520732011331036461129765621272702107522001);
    assert(a == 0x5a4653ca673768565b41f775d6947d55cf3813d1);
    assert(Integer.isInteger(1) === true);
    assert(Integer.isInteger(1.0) === false);

    assert(Integer.floorLog2(0) === -1);
    assert(Integer.floorLog2(7) === 2);

    r = 1 << 31;
    assert(r, 2147483648, "1 << 31 === 2147483648");
    
    r = 1 << 32;
    assert(r, 4294967296, "1 << 32 === 4294967296");
    
    r = (1 << 31) < 0;
    assert(r, false, "(1 << 31) < 0 === false");

    assert(typeof 1 === "number");
    assert(typeof 9007199254740991 === "number");
    assert(typeof 9007199254740992 === "bigint");
}

function test_float()
{
    assert(typeof 1.0 === "bigfloat");
    assert(1 == 1.0);
    assert(1 !== 1.0);
}

/* jscalc tests */

function test_modulo()
{
    var i, p, a, b;

    /* Euclidian modulo operator */
    assert((-3) % 2 == 1);
    assert(3 % (-2) == 1);

    p = 101;
    for(i = 1; i < p; i++) {
        a = Integer.invmod(i, p);
        assert(a >= 0 && a < p);
        assert((i * a) % p == 1);
    }

    assert(Integer.isPrime(2^107-1));
    assert(!Integer.isPrime((2^107-1) * (2^89-1)));
    a = Integer.factor((2^89-1)*2^3*11*13^2*1009);
    assert(a == [ 2,2,2,11,13,13,1009,618970019642690137449562111 ]);
}

function test_fraction()
{
    assert((1/3 + 1).toString(), "4/3")
    assert((2/3)^30, 1073741824/205891132094649);
    assert(1/3 < 2/3);
    assert(1/3 < 1);
    assert(1/3 == 1.0/3);
    assert(1.0/3 < 2/3);
}

function test_mod()
{
    var a, b, p;
    
    a = Mod(3, 101);
    b = Mod(-1, 101);
    assert((a + b) == Mod(2, 101));
    assert(a ^ 100 == Mod(1, 101));

    p = 2 ^ 607 - 1; /* mersenne prime */
    a = Mod(3, p) ^ (p - 1);
    assert(a == Mod(1, p));
}

function test_polynomial()
{
    var a, b, q, r, t, i;
    a = (1 + X) ^ 4;
    assert(a == X^4+4*X^3+6*X^2+4*X+1);
    
    r = (1 + X);
    q = (1+X+X^2);
    b = (1 - X^2);
    a = q * b + r;
    t = Polynomial.divrem(a, b);
    assert(t[0] == q);
    assert(t[1] == r);

    a = 1 + 2*X + 3*X^2;
    assert(a.apply(0.1) == 1.23);

    a = 1-2*X^2+2*X^3;
    assert(deriv(a) == (6*X^2-4*X));
    assert(deriv(integ(a)) == a);

    a = (X-1)*(X-2)*(X-3)*(X-4)*(X-0.1);
    r = polroots(a);
    for(i = 0; i < r.length; i++) {
        b = abs(a.apply(r[i]));
        assert(b <= 1e-13);
    }
}

function test_poly_mod()
{
    var a, p;

    /* modulo using polynomials */
    p = X^2 + X + 1;
    a = PolyMod(3+X, p) ^ 10;
    assert(a == PolyMod(-3725*X-18357, p));

    a = PolyMod(1/X, 1+X^2);
    assert(a == PolyMod(-X, X^2+1));
}

function test_rfunc()
{
    var a;
    a = (X+1)/((X+1)*(X-1));
    assert(a == 1/(X-1));
    a = (X + 2) / (X - 2);
    assert(a.apply(1/3) == -7/5);

    assert(deriv((X^2-X+1)/(X-1)) == (X^2-2*X)/(X^2-2*X+1));
}

function test_series()
{
    var a, b;
    a = 1+X+O(X^5);
    b = a.inverse();
    assert(b == 1-X+X^2-X^3+X^4+O(X^5));
    assert(deriv(b) == -1+2*X-3*X^2+4*X^3+O(X^4));
    assert(deriv(integ(b)) == b);

    a = Series(1/(1-X), 5);
    assert(a == 1+X+X^2+X^3+X^4+O(X^5));
    b = a.apply(0.1);
    assert(b == 1.1111);

    assert(exp(3*X^2+O(X^10)) == 1+3*X^2+9/2*X^4+9/2*X^6+27/8*X^8+O(X^10));
    assert(sin(X+O(X^6)) == X-1/6*X^3+1/120*X^5+O(X^6));
    assert(cos(X+O(X^6)) == 1-1/2*X^2+1/24*X^4+O(X^6));
    assert(tan(X+O(X^8)) == X+1/3*X^3+2/15*X^5+17/315*X^7+O(X^8));
        assert((1+X+O(X^6))^(2+X) == 1+2*X+2*X^2+3/2*X^3+5/6*X^4+5/12*X^5+O(X^6));
}

function test_matrix()
{
    var a, b, r;
    a = [[1, 2],[3, 4]];
    b = [3, 4];
    r = a * b;
    assert(r == [11, 25]);
    r = (a^-1) * 2;
    assert(r == [[-4, 2],[3, -1]]);

    assert(norm2([1,2,3]) == 14);

    assert(diag([1,2,3]) == [ [ 1, 0, 0 ], [ 0, 2, 0 ], [ 0, 0, 3 ] ]);
    assert(trans(a) == [ [ 1, 3 ], [ 2, 4 ] ]);
    assert(trans([1,2,3]) == [[1,2,3]]);
    assert(trace(a) == 5);

    assert(charpoly(Matrix.hilbert(4)) == X^4-176/105*X^3+3341/12600*X^2-41/23625*X+1/6048000);
    assert(det(Matrix.hilbert(4)) == 1/6048000);

    a = [[1,2,1],[-2,-3,1],[3,5,0]];
    assert(rank(a) == 2);
    assert(ker(a) == [ [ 5 ], [ -3 ], [ 1 ] ]);

    assert(dp([1, 2, 3], [3, -4, -7]) === -26);
    assert(cp([1, 2, 3], [3, -4, -7]) == [ -2, 16, -10 ]);
}

function assert_eq(a, ref)
{
    assert(abs(a / ref - 1.0) <= 1e-15);
}

function test_trig()
{
    assert_eq(sin(1/2), 0.479425538604203);
    assert_eq(sin(2+3*I), 9.154499146911428-4.168906959966565*I);
    assert_eq(cos(2+3*I), -4.189625690968807-9.109227893755337*I);
    assert_eq((2+0.5*I)^(1.1-0.5*I), 2.494363021357619-0.23076804554558092*I);
    assert_eq(sqrt(2*I), 1 + I);
}

test_integer();
test_float();

test_modulo();
test_fraction();
test_mod();
test_polynomial();
test_poly_mod();
test_rfunc();
test_series();
test_matrix();
test_trig();

'''
'''--- tests/test_std.js ---
import * as std from "std";
import * as os from "os";

function assert(actual, expected, message) {
    if (arguments.length == 1)
        expected = true;

    if (actual === expected)
        return;

    if (actual !== null && expected !== null
    &&  typeof actual == 'object' && typeof expected == 'object'
    &&  actual.toString() === expected.toString())
        return;

    throw Error("assertion failed: got |" + actual + "|" +
                ", expected |" + expected + "|" +
                (message ? " (" + message + ")" : ""));
}

// load more elaborate version of assert if available
try { std.loadScript("test_assert.js"); } catch(e) {}

/*----------------*/

function test_printf()
{
    assert(std.sprintf("a=%d s=%s", 123, "abc"), "a=123 s=abc");
    assert(std.sprintf("%010d", 123), "0000000123");
    assert(std.sprintf("%x", -2), "fffffffe");
    assert(std.sprintf("%lx", -2), "fffffffffffffffe");
    assert(std.sprintf("%10.1f", 2.1), "       2.1");
    assert(std.sprintf("%*.*f", 10, 2, -2.13), "     -2.13");
    assert(std.sprintf("%#lx", 0x7fffffffffffffffn), "0x7fffffffffffffff");
}

function test_file1()
{
    var f, len, str, size, buf, ret, i, str1;

    f = std.tmpfile();
    str = "hello world\n";
    f.puts(str);

    f.seek(0, std.SEEK_SET);
    str1 = f.readAsString();
    assert(str1 === str);
    
    f.seek(0, std.SEEK_END);
    size = f.tell();
    assert(size === str.length);

    f.seek(0, std.SEEK_SET);

    buf = new Uint8Array(size);
    ret = f.read(buf.buffer, 0, size);
    assert(ret === size);
    for(i = 0; i < size; i++)
        assert(buf[i] === str.charCodeAt(i));

    f.close();
}

function test_file2()
{
    var f, str, i, size;
    f = std.tmpfile();
    str = "hello world\n";
    size = str.length;
    for(i = 0; i < size; i++)
        f.putByte(str.charCodeAt(i));
    f.seek(0, std.SEEK_SET);
    for(i = 0; i < size; i++) {
        assert(str.charCodeAt(i) === f.getByte());
    }
    assert(f.getByte() === -1);
    f.close();
}

function test_getline()
{
    var f, line, line_count, lines, i;
    
    lines = ["hello world", "line 1", "line 2" ];
    f = std.tmpfile();
    for(i = 0; i < lines.length; i++) {
        f.puts(lines[i], "\n");
    }

    f.seek(0, std.SEEK_SET);
    assert(!f.eof());
    line_count = 0;
    for(;;) {
        line = f.getline();
        if (line === null)
            break;
        assert(line == lines[line_count]);
        line_count++;
    }
    assert(f.eof());
    assert(line_count === lines.length);

    f.close();
}
 
function test_popen()
{
    var str, f, fname = "tmp_file.txt";
    var content = "hello world";

    f = std.open(fname, "w");
    f.puts(content);
    f.close();

    /* test loadFile */
    assert(std.loadFile(fname), content);
    
    /* execute the 'cat' shell command */
    f = std.popen("cat " + fname, "r");
    str = f.readAsString();
    f.close();

    assert(str, content);

    os.remove(fname);
}

function test_ext_json()
{
    var expected, input, obj;
    expected = '{"x":false,"y":true,"z2":null,"a":[1,8,160],"s":"str"}';
    input = `{ "x":false, /*comments are allowed */
               "y":true,  // also a comment
               z2:null, // unquoted property names
               "a":[+1,0o10,0xa0,], // plus prefix, octal, hexadecimal
               "s":"str",} // trailing comma in objects and arrays
            `;
    obj = std.parseExtJSON(input);
    assert(JSON.stringify(obj), expected);
}

function test_os()
{
    var fd, fpath, fname, fdir, buf, buf2, i, files, err, fdate, st, link_path;

    assert(os.isatty(0));

    fdir = "test_tmp_dir";
    fname = "tmp_file.txt";
    fpath = fdir + "/" + fname;
    link_path = fdir + "/test_link";
    
    os.remove(link_path);
    os.remove(fpath);
    os.remove(fdir);

    err = os.mkdir(fdir, 0o755);
    assert(err === 0);
    
    fd = os.open(fpath, os.O_RDWR | os.O_CREAT | os.O_TRUNC);
    assert(fd >= 0);
    
    buf = new Uint8Array(10);
    for(i = 0; i < buf.length; i++)
        buf[i] = i;
    assert(os.write(fd, buf.buffer, 0, buf.length) === buf.length);

    assert(os.seek(fd, 0, std.SEEK_SET) === 0);
    buf2 = new Uint8Array(buf.length);
    assert(os.read(fd, buf2.buffer, 0, buf2.length) === buf2.length);
    
    for(i = 0; i < buf.length; i++)
        assert(buf[i] == buf2[i]);
    
    if (typeof BigInt !== "undefined") {
        assert(os.seek(fd, BigInt(6), std.SEEK_SET), BigInt(6));
        assert(os.read(fd, buf2.buffer, 0, 1) === 1);
        assert(buf[6] == buf2[0]);
    }
    
    assert(os.close(fd) === 0);

    [files, err] = os.readdir(fdir);
    assert(err, 0);
    assert(files.indexOf(fname) >= 0);

    fdate = 10000;

    err = os.utimes(fpath, fdate, fdate);
    assert(err, 0);
    
    [st, err] = os.stat(fpath);
    assert(err, 0);
    assert(st.mode & os.S_IFMT, os.S_IFREG);
    assert(st.mtime, fdate);

    err = os.symlink(fname, link_path);
    assert(err === 0);
    
    [st, err] = os.lstat(link_path);
    assert(err, 0);
    assert(st.mode & os.S_IFMT, os.S_IFLNK);

    [buf, err] = os.readlink(link_path);
    assert(err, 0);
    assert(buf, fname);
    
    assert(os.remove(link_path) === 0);

    [buf, err] = os.getcwd();
    assert(err, 0);

    [buf2, err] = os.realpath(".");
    assert(err, 0);

    assert(buf, buf2);
    
    assert(os.remove(fpath) === 0);

    fd = os.open(fpath, os.O_RDONLY);
    assert(fd < 0);

    assert(os.remove(fdir) === 0);
}

function test_os_exec()
{
    var ret, fds, pid, f, status;

    ret = os.exec(["true"]);
    assert(ret, 0);

    ret = os.exec(["/bin/sh", "-c", "exit 1"], { usePath: false });
    assert(ret, 1);
    
    fds = os.pipe();
    pid = os.exec(["sh", "-c", "echo $FOO"], {
        stdout: fds[1],
        block: false,
        env: { FOO: "hello" },
    } );
    assert(pid >= 0);
    os.close(fds[1]); /* close the write end (as it is only in the child)  */
    f = std.fdopen(fds[0], "r");
    assert(f.getline(), "hello");
    assert(f.getline(), null);
    f.close();
    [ret, status] = os.waitpid(pid, 0);
    assert(ret, pid);
    assert(status & 0x7f, 0); /* exited */
    assert(status >> 8, 0); /* exit code */

    pid = os.exec(["cat"], { block: false } );
    assert(pid >= 0);
    os.kill(pid, os.SIGQUIT);
    [ret, status] = os.waitpid(pid, 0);
    assert(ret, pid);
    assert(status & 0x7f, os.SIGQUIT);
}

function test_timer()
{
    var th, i;

    /* just test that a timer can be inserted and removed */
    th = [];
    for(i = 0; i < 3; i++)
        th[i] = os.setTimeout(function () { }, 1000);
    for(i = 0; i < 3; i++)
        os.clearTimeout(th[i]);
}

test_printf();
test_file1();
test_file2();
test_getline();
test_popen();
test_os();
test_os_exec();
test_timer();
test_ext_json();

'''
'''--- tests/test_worker.js ---
/* os.Worker API test */
import * as std from "std";
import * as os from "os";

function assert(actual, expected, message) {
    if (arguments.length == 1)
        expected = true;

    if (actual === expected)
        return;

    if (actual !== null && expected !== null
    &&  typeof actual == 'object' && typeof expected == 'object'
    &&  actual.toString() === expected.toString())
        return;

    throw Error("assertion failed: got |" + actual + "|" +
                ", expected |" + expected + "|" +
                (message ? " (" + message + ")" : ""));
}

var worker;

function test_worker()
{
    var counter;

    worker = new os.Worker("./test_worker_module.js");

    counter = 0;
    worker.onmessage = function (e) {
        var ev = e.data;
//        print("recv", JSON.stringify(ev));
        switch(ev.type) {
        case "num":
            assert(ev.num, counter);
            counter++;
            if (counter == 10) {
                /* test SharedArrayBuffer modification */
                let sab = new SharedArrayBuffer(10);
                let buf = new Uint8Array(sab);
                worker.postMessage({ type: "sab", buf: buf });
            }
            break;
        case "sab_done":
            {
                let buf = ev.buf;
                /* check that the SharedArrayBuffer was modified */
                assert(buf[2], 10);
                worker.postMessage({ type: "abort" });
            }
            break;
        case "done":
            /* terminate */
            worker.onmessage = null;
            break;
        }
    };
}

test_worker();

'''
'''--- tests/test_worker_module.js ---
/* Worker code for test_worker.js */
import * as std from "std";
import * as os from "os";

var parent = os.Worker.parent;

function handle_msg(e) {
    var ev = e.data;
    //          print("child_recv", JSON.stringify(ev));
    switch(ev.type) {
    case "abort":
        parent.postMessage({ type: "done" });
        break;
    case "sab":
        /* modify the SharedArrayBuffer */
        ev.buf[2] = 10;
        parent.postMessage({ type: "sab_done", buf: ev.buf });
        break;
    }
}

function worker_main() {
    var i;
    
    parent.onmessage = handle_msg;
    for(i = 0; i < 10; i++) {
        parent.postMessage({ type: "num", num: i }); 
    }
}

worker_main();

'''
'''--- unicode_download.sh ---
#!/bin/sh
set -e

url="ftp://ftp.unicode.org/Public/14.0.0/ucd"
emoji_url="${url}/emoji/emoji-data.txt"

files="CaseFolding.txt DerivedNormalizationProps.txt PropList.txt \
SpecialCasing.txt CompositionExclusions.txt ScriptExtensions.txt \
UnicodeData.txt DerivedCoreProperties.txt NormalizationTest.txt Scripts.txt \
PropertyValueAliases.txt"

mkdir -p unicode

for f in $files; do
    g="${url}/${f}"
    wget $g -O unicode/$f
done
    
wget $emoji_url -O unicode/emoji-data.txt

'''
'''--- unicode_gen.c ---
/*
 * Generation of Unicode tables
 * 
 * Copyright (c) 2017-2018 Fabrice Bellard
 * Copyright (c) 2017-2018 Charlie Gordon
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <inttypes.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include <time.h>

#include "cutils.h"

/* define it to be able to test unicode.c */
//#define USE_TEST
/* profile tests */
//#define PROFILE

//#define DUMP_CASE_CONV_TABLE
//#define DUMP_TABLE_SIZE
//#define DUMP_CC_TABLE
//#define DUMP_DECOMP_TABLE

/* Ideas:
   - Generalize run length encoding + index for all tables
   - remove redundant tables for ID_start, ID_continue, Case_Ignorable, Cased

   Case conversion:
   - use a single entry for consecutive U/LF runs
   - allow EXT runs of length > 1

   Decomposition:
   - Greek lower case (+1f10/1f10) ?
   - allow holes in B runs
   - suppress more upper / lower case redundancy
*/

#ifdef USE_TEST
#include "libunicode.c"
#endif

#define CHARCODE_MAX 0x10ffff
#define CC_LEN_MAX 3

void *mallocz(size_t size)
{
    void *ptr;
    ptr = malloc(size);
    memset(ptr, 0, size);
    return ptr;
}

const char *get_field(const char *p, int n)
{
    int i;
    for(i = 0; i < n; i++) {
        while (*p != ';' && *p != '\0')
            p++;
        if (*p == '\0')
            return NULL;
        p++;
    }
    return p;
}

const char *get_field_buf(char *buf, size_t buf_size, const char *p, int n)
{
    char *q;
    p = get_field(p, n);
    q = buf;
    while (*p != ';' && *p != '\0') {
        if ((q - buf) < buf_size - 1)
            *q++ = *p;
        p++;
    }
    *q = '\0';
    return buf;
}

void add_char(int **pbuf, int *psize, int *plen, int c)
{
    int len, size, *buf;
    buf = *pbuf;
    size = *psize;
    len = *plen;
    if (len >= size) {
        size = *psize;
        size = max_int(len + 1, size * 3 / 2);
        buf = realloc(buf, sizeof(buf[0]) * size);
        *pbuf = buf;
        *psize = size;
    }
    buf[len++] = c;
    *plen = len;
}

int *get_field_str(int *plen, const char *str, int n)
{
    const char *p;
    int *buf, len, size;
    p = get_field(str, n);
    if (!p) {
        *plen = 0;
        return NULL;
    }
    len = 0;
    size = 0;
    buf = NULL;
    for(;;) {
        while (isspace(*p))
            p++;
        if (!isxdigit(*p))
            break;
        add_char(&buf, &size, &len, strtoul(p, (char **)&p, 16));
    }
    *plen = len;
    return buf;
}

char *get_line(char *buf, int buf_size, FILE *f)
{
    int len;
    if (!fgets(buf, buf_size, f))
        return NULL;
    len = strlen(buf);
    if (len > 0 && buf[len - 1] == '\n')
        buf[len - 1] = '\0';
    return buf;
}

#define UNICODE_GENERAL_CATEGORY

typedef enum {
#define DEF(id, str) GCAT_ ## id,
#include "unicode_gen_def.h"
#undef DEF
    GCAT_COUNT,
} UnicodeGCEnum1;

static const char *unicode_gc_name[] = {
#define DEF(id, str) #id,
#include "unicode_gen_def.h"
#undef DEF
};

static const char *unicode_gc_short_name[] = {
#define DEF(id, str) str,
#include "unicode_gen_def.h"
#undef DEF
};

#undef UNICODE_GENERAL_CATEGORY

#define UNICODE_SCRIPT

typedef enum {
#define DEF(id, str) SCRIPT_ ## id,
#include "unicode_gen_def.h"
#undef DEF
    SCRIPT_COUNT,
} UnicodeScriptEnum1;

static const char *unicode_script_name[] = {
#define DEF(id, str) #id,
#include "unicode_gen_def.h"
#undef DEF
};

const char *unicode_script_short_name[] = {
#define DEF(id, str) str,
#include "unicode_gen_def.h"
#undef DEF
};

#undef UNICODE_SCRIPT

#define UNICODE_PROP_LIST

typedef enum {
#define DEF(id, str) PROP_ ## id,
#include "unicode_gen_def.h"
#undef DEF
    PROP_COUNT,
} UnicodePropEnum1;

static const char *unicode_prop_name[] = {
#define DEF(id, str) #id,
#include "unicode_gen_def.h"
#undef DEF
};

static const char *unicode_prop_short_name[] = {
#define DEF(id, str) str,
#include "unicode_gen_def.h"
#undef DEF
};

#undef UNICODE_SPROP_LIST

typedef struct {
    /* case conv */
    uint8_t u_len;
    uint8_t l_len;
    int u_data[CC_LEN_MAX];
    int l_data[CC_LEN_MAX];
    int f_code;

    uint8_t combining_class;
    uint8_t is_compat:1;
    uint8_t is_excluded:1;
    uint8_t general_category;
    uint8_t script;
    uint8_t script_ext_len;
    uint8_t *script_ext;
    uint32_t prop_bitmap_tab[3];
    /* decomposition */
    int decomp_len;
    int *decomp_data;
} CCInfo;

CCInfo *unicode_db;

int find_name(const char **tab, int tab_len, const char *name)
{
    int i, len, name_len;
    const char *p, *r;

    name_len = strlen(name);
    for(i = 0; i < tab_len; i++) {
        p = tab[i];
        for(;;) {
            r = strchr(p, ',');
            if (!r)
                len = strlen(p);
            else
                len = r - p;
            if (len == name_len && memcmp(p, name, len) == 0)
                return i;
            if (!r)
                break;
            p = r + 1;
        }
    }
    return -1;
}

static int get_prop(uint32_t c, int prop_idx)
{
    return (unicode_db[c].prop_bitmap_tab[prop_idx >> 5] >> (prop_idx & 0x1f)) & 1;
}

static void set_prop(uint32_t c, int prop_idx, int val)
{
    uint32_t mask;
    mask = 1U << (prop_idx & 0x1f);
    if (val)
        unicode_db[c].prop_bitmap_tab[prop_idx >> 5] |= mask;
    else
        unicode_db[c].prop_bitmap_tab[prop_idx >> 5]  &= ~mask;
}

void parse_unicode_data(const char *filename)
{
    FILE *f;
    char line[1024];
    char buf1[256];
    const char *p;
    int code, lc, uc, last_code;
    CCInfo *ci, *tab = unicode_db;
    
    f = fopen(filename, "rb");
    if (!f) {
        perror(filename);
        exit(1);
    }

    last_code = 0;
    for(;;) {
        if (!get_line(line, sizeof(line), f))
            break;
        p = line;
        while (isspace(*p))
            p++;
        if (*p == '#')
            continue;

        p = get_field(line, 0);
        if (!p)
            continue;
        code = strtoul(p, NULL, 16);
        lc = 0;
        uc = 0;
        
        p = get_field(line, 12);
        if (p && *p != ';') {
            uc = strtoul(p, NULL, 16);
        }

        p = get_field(line, 13);
        if (p && *p != ';') {
            lc = strtoul(p, NULL, 16);
        }
        ci = &tab[code];
        if (uc > 0 || lc > 0) {
            assert(code <= CHARCODE_MAX);
            if (uc > 0) {
                assert(ci->u_len == 0);
                ci->u_len = 1;
                ci->u_data[0] = uc;
            }
            if (lc > 0) {
                assert(ci->l_len == 0);
                ci->l_len = 1;
                ci->l_data[0] = lc;
            }
        }

        {
            int i;
            get_field_buf(buf1, sizeof(buf1), line, 2);
            i = find_name(unicode_gc_name, countof(unicode_gc_name), buf1);
            if (i < 0) {
                fprintf(stderr, "General category '%s' not found\n",
                        buf1);
                exit(1);
            }
            ci->general_category = i;
        }
        
        p = get_field(line, 3);
        if (p && *p != ';' && *p != '\0') {
            int cc;
            cc = strtoul(p, NULL, 0);
            if (cc != 0) {
                assert(code <= CHARCODE_MAX);
                ci->combining_class = cc;
                //                printf("%05x: %d\n", code, ci->combining_class);
            }
        }

        p = get_field(line, 5);
        if (p && *p != ';' && *p != '\0') {
            int size;
            assert(code <= CHARCODE_MAX);
            ci->is_compat = 0;
            if (*p == '<') {
                while (*p != '\0' && *p != '>')
                    p++;
                if (*p == '>')
                    p++;
                ci->is_compat = 1;
            }
            size = 0;
            for(;;) {
                while (isspace(*p))
                    p++;
                if (!isxdigit(*p))
                    break;
                add_char(&ci->decomp_data, &size, &ci->decomp_len, strtoul(p, (char **)&p, 16));
            }
#if 0
            {
                int i;
                static int count, d_count;

                printf("%05x: %c", code, ci->is_compat ? 'C': ' ');
                for(i = 0; i < ci->decomp_len; i++)
                    printf(" %05x", ci->decomp_data[i]);
                printf("\n");
                count++;
                d_count += ci->decomp_len;
                //                printf("%d %d\n", count, d_count);
            }
#endif
        }

        p = get_field(line, 9);
        if (p && *p == 'Y') {
            set_prop(code, PROP_Bidi_Mirrored, 1);
        }
        
        /* handle ranges */
        get_field_buf(buf1, sizeof(buf1), line, 1);
        if (strstr(buf1, " Last>")) {
            int i;
            //            printf("range: 0x%x-%0x\n", last_code, code);
            assert(ci->decomp_len == 0);
            assert(ci->script_ext_len == 0);
            for(i = last_code + 1; i < code; i++) {
                unicode_db[i] = *ci;
            }
        }
        last_code = code;
    }
        
    fclose(f);
}

void parse_special_casing(CCInfo *tab, const char *filename)
{
    FILE *f;
    char line[1024];
    const char *p;
    int code;
    CCInfo *ci;
    
    f = fopen(filename, "rb");
    if (!f) {
        perror(filename);
        exit(1);
    }

    for(;;) {
        if (!get_line(line, sizeof(line), f))
            break;
        p = line;
        while (isspace(*p))
            p++;
        if (*p == '#')
            continue;

        p = get_field(line, 0);
        if (!p)
            continue;
        code = strtoul(p, NULL, 16);
        assert(code <= CHARCODE_MAX);
        ci = &tab[code];

        p = get_field(line, 4);
        if (p) {
            /* locale dependent casing */
            while (isspace(*p))
                p++;
            if (*p != '#' && *p != '\0')
                continue;
        }
            
        
        p = get_field(line, 1);
        if (p && *p != ';') {
            ci->l_len = 0;
            for(;;) {
                while (isspace(*p))
                    p++;
                if (*p == ';')
                    break;
                assert(ci->l_len < CC_LEN_MAX);
                ci->l_data[ci->l_len++] = strtoul(p, (char **)&p, 16);
            }

            if (ci->l_len == 1 && ci->l_data[0] == code)
                ci->l_len = 0;
        }

        p = get_field(line, 3);
        if (p && *p != ';') {
            ci->u_len = 0;
            for(;;) {
                while (isspace(*p))
                    p++;
                if (*p == ';')
                    break;
                assert(ci->u_len < CC_LEN_MAX);
                ci->u_data[ci->u_len++] = strtoul(p, (char **)&p, 16);
            }

            if (ci->u_len == 1 && ci->u_data[0] == code)
                ci->u_len = 0;
        }
    }
        
    fclose(f);
}

void parse_case_folding(CCInfo *tab, const char *filename)
{
    FILE *f;
    char line[1024];
    const char *p;
    int code;
    CCInfo *ci;
    
    f = fopen(filename, "rb");
    if (!f) {
        perror(filename);
        exit(1);
    }

    for(;;) {
        if (!get_line(line, sizeof(line), f))
            break;
        p = line;
        while (isspace(*p))
            p++;
        if (*p == '#')
            continue;

        p = get_field(line, 0);
        if (!p)
            continue;
        code = strtoul(p, NULL, 16);
        assert(code <= CHARCODE_MAX);
        ci = &tab[code];

        p = get_field(line, 1);
        if (!p)
            continue;
        /* locale dependent casing */
        while (isspace(*p))
            p++;
        if (*p != 'C' && *p != 'S')
            continue;
        
        p = get_field(line, 2);
        assert(p != 0);
        assert(ci->f_code == 0);
        ci->f_code = strtoul(p, NULL, 16);
        assert(ci->f_code != 0 && ci->f_code != code);
    }
        
    fclose(f);
}

void parse_composition_exclusions(const char *filename)
{
    FILE *f;
    char line[4096], *p;
    uint32_t c0;
    
    f = fopen(filename, "rb");
    if (!f) {
        perror(filename);
        exit(1);
    }

    for(;;) {
        if (!get_line(line, sizeof(line), f))
            break;
        p = line;
        while (isspace(*p))
            p++;
        if (*p == '#' || *p == '@' || *p == '\0')
            continue;
        c0 = strtoul(p, (char **)&p, 16);
        assert(c0 > 0 && c0 <= CHARCODE_MAX);
        unicode_db[c0].is_excluded = TRUE;
    }
    fclose(f);
}

void parse_derived_core_properties(const char *filename)
{
    FILE *f;
    char line[4096], *p, buf[256], *q;
    uint32_t c0, c1, c;
    int i;
    
    f = fopen(filename, "rb");
    if (!f) {
        perror(filename);
        exit(1);
    }

    for(;;) {
        if (!get_line(line, sizeof(line), f))
            break;
        p = line;
        while (isspace(*p))
            p++;
        if (*p == '#' || *p == '@' || *p == '\0')
            continue;
        c0 = strtoul(p, (char **)&p, 16);
        if (*p == '.' && p[1] == '.') {
            p += 2;
            c1 = strtoul(p, (char **)&p, 16);
        } else {
            c1 = c0;
        }
        assert(c1 <= CHARCODE_MAX);
        p += strspn(p, " \t");
        if (*p == ';') {
            p++;
            p += strspn(p, " \t");
            q = buf;
            while (*p != '\0' && *p != ' ' && *p != '#' && *p != '\t') {
                if ((q - buf) < sizeof(buf) - 1)
                    *q++ = *p;
                p++;
            }
            *q = '\0';
            i = find_name(unicode_prop_name,
                          countof(unicode_prop_name), buf);
            if (i < 0) {
                if (!strcmp(buf, "Grapheme_Link"))
                    goto next;
                fprintf(stderr, "Property not found: %s\n", buf);
                exit(1);
            }
            for(c = c0; c <= c1; c++) {
                set_prop(c, i, 1);
            }
next: ;
        }
    }
    fclose(f);
}

void parse_derived_norm_properties(const char *filename)
{
    FILE *f;
    char line[4096], *p, buf[256], *q;
    uint32_t c0, c1, c;
    
    f = fopen(filename, "rb");
    if (!f) {
        perror(filename);
        exit(1);
    }

    for(;;) {
        if (!get_line(line, sizeof(line), f))
            break;
        p = line;
        while (isspace(*p))
            p++;
        if (*p == '#' || *p == '@' || *p == '\0')
            continue;
        c0 = strtoul(p, (char **)&p, 16);
        if (*p == '.' && p[1] == '.') {
            p += 2;
            c1 = strtoul(p, (char **)&p, 16);
        } else {
            c1 = c0;
        }
        assert(c1 <= CHARCODE_MAX);
        p += strspn(p, " \t");
        if (*p == ';') {
            p++;
            p += strspn(p, " \t");
            q = buf;
            while (*p != '\0' && *p != ' ' && *p != '#' && *p != '\t') {
                if ((q - buf) < sizeof(buf) - 1)
                    *q++ = *p;
                p++;
            }
            *q = '\0';
            if (!strcmp(buf, "Changes_When_NFKC_Casefolded")) {
                for(c = c0; c <= c1; c++) {
                    set_prop(c, PROP_Changes_When_NFKC_Casefolded, 1);
                }
            }
        }
    }
    fclose(f);
}

void parse_prop_list(const char *filename)
{
    FILE *f;
    char line[4096], *p, buf[256], *q;
    uint32_t c0, c1, c;
    int i;
    
    f = fopen(filename, "rb");
    if (!f) {
        perror(filename);
        exit(1);
    }

    for(;;) {
        if (!get_line(line, sizeof(line), f))
            break;
        p = line;
        while (isspace(*p))
            p++;
        if (*p == '#' || *p == '@' || *p == '\0')
            continue;
        c0 = strtoul(p, (char **)&p, 16);
        if (*p == '.' && p[1] == '.') {
            p += 2;
            c1 = strtoul(p, (char **)&p, 16);
        } else {
            c1 = c0;
        }
        assert(c1 <= CHARCODE_MAX);
        p += strspn(p, " \t");
        if (*p == ';') {
            p++;
            p += strspn(p, " \t");
            q = buf;
            while (*p != '\0' && *p != ' ' && *p != '#' && *p != '\t') {
                if ((q - buf) < sizeof(buf) - 1)
                    *q++ = *p;
                p++;
            }
            *q = '\0';
            i = find_name(unicode_prop_name,
                          countof(unicode_prop_name), buf);
            if (i < 0) {
                fprintf(stderr, "Property not found: %s\n", buf);
                exit(1);
            }
            for(c = c0; c <= c1; c++) {
                set_prop(c, i, 1);
            }
        }
    }
    fclose(f);
}

void parse_scripts(const char *filename)
{
    FILE *f;
    char line[4096], *p, buf[256], *q;
    uint32_t c0, c1, c;
    int i;
    
    f = fopen(filename, "rb");
    if (!f) {
        perror(filename);
        exit(1);
    }

    for(;;) {
        if (!get_line(line, sizeof(line), f))
            break;
        p = line;
        while (isspace(*p))
            p++;
        if (*p == '#' || *p == '@' || *p == '\0')
            continue;
        c0 = strtoul(p, (char **)&p, 16);
        if (*p == '.' && p[1] == '.') {
            p += 2;
            c1 = strtoul(p, (char **)&p, 16);
        } else {
            c1 = c0;
        }
        assert(c1 <= CHARCODE_MAX);
        p += strspn(p, " \t");
        if (*p == ';') {
            p++;
            p += strspn(p, " \t");
            q = buf;
            while (*p != '\0' && *p != ' ' && *p != '#' && *p != '\t') {
                if ((q - buf) < sizeof(buf) - 1)
                    *q++ = *p;
                p++;
            }
            *q = '\0';
            i = find_name(unicode_script_name,
                          countof(unicode_script_name), buf);
            if (i < 0) {
                fprintf(stderr, "Unknown script: '%s'\n", buf);
                exit(1);
            }
            for(c = c0; c <= c1; c++)
                unicode_db[c].script = i;
        }
    }
    fclose(f);
}

void parse_script_extensions(const char *filename)
{
    FILE *f;
    char line[4096], *p, buf[256], *q;
    uint32_t c0, c1, c;
    int i;
    uint8_t script_ext[255];
    int script_ext_len;
    
    f = fopen(filename, "rb");
    if (!f) {
        perror(filename);
        exit(1);
    }

    for(;;) {
        if (!get_line(line, sizeof(line), f))
            break;
        p = line;
        while (isspace(*p))
            p++;
        if (*p == '#' || *p == '@' || *p == '\0')
            continue;
        c0 = strtoul(p, (char **)&p, 16);
        if (*p == '.' && p[1] == '.') {
            p += 2;
            c1 = strtoul(p, (char **)&p, 16);
        } else {
            c1 = c0;
        }
        assert(c1 <= CHARCODE_MAX);
        p += strspn(p, " \t");
        script_ext_len = 0;
        if (*p == ';') {
            p++;
            for(;;) {
                p += strspn(p, " \t");
                q = buf;
                while (*p != '\0' && *p != ' ' && *p != '#' && *p != '\t') {
                    if ((q - buf) < sizeof(buf) - 1)
                        *q++ = *p;
                    p++;
                }
                *q = '\0';
                if (buf[0] == '\0')
                    break;
                i = find_name(unicode_script_short_name,
                              countof(unicode_script_short_name), buf);
                if (i < 0) {
                    fprintf(stderr, "Script not found: %s\n", buf);
                    exit(1);
                }
                assert(script_ext_len < sizeof(script_ext));
                script_ext[script_ext_len++] = i;
            }
            for(c = c0; c <= c1; c++) {
                CCInfo *ci = &unicode_db[c];
                ci->script_ext_len = script_ext_len;
                ci->script_ext = malloc(sizeof(ci->script_ext[0]) * script_ext_len);
                for(i = 0; i < script_ext_len; i++)
                    ci->script_ext[i] = script_ext[i];
            }
        }
    }
    fclose(f);
}

void dump_cc_info(CCInfo *ci, int i)
{
    int j;
    printf("%05x:", i);
    if (ci->u_len != 0) {
        printf(" U:");
        for(j = 0; j < ci->u_len; j++)
            printf(" %05x", ci->u_data[j]);
    }
    if (ci->l_len != 0) {
        printf(" L:");
        for(j = 0; j < ci->l_len; j++)
            printf(" %05x", ci->l_data[j]);
    }
    if (ci->f_code != 0) {
        printf(" F: %05x", ci->f_code);
    }
    printf("\n");
}

void dump_data(CCInfo *tab)
{
    int i;
    CCInfo *ci;
    for(i = 0; i <= CHARCODE_MAX; i++) {
        ci = &tab[i];
        if (ci->u_len != 0 || ci->l_len != 0 || ci->f_code != 0) {
            dump_cc_info(ci, i);
        }
    }
}

BOOL is_complicated_case(const CCInfo *ci)
{
    return (ci->u_len > 1 || ci->l_len > 1 ||
            (ci->u_len > 0 && ci->l_len > 0) ||
            (ci->f_code != 0) != ci->l_len ||
            (ci->f_code != 0 && ci->l_data[0] != ci->f_code));
}

#ifndef USE_TEST
enum {
    RUN_TYPE_U,
    RUN_TYPE_L,
    RUN_TYPE_UF,
    RUN_TYPE_LF,
    RUN_TYPE_UL,
    RUN_TYPE_LSU,
    RUN_TYPE_U2L_399_EXT2,
    RUN_TYPE_UF_D20,
    RUN_TYPE_UF_D1_EXT,
    RUN_TYPE_U_EXT,
    RUN_TYPE_LF_EXT,
    RUN_TYPE_U_EXT2,
    RUN_TYPE_L_EXT2,
    RUN_TYPE_U_EXT3,
};
#endif

const char *run_type_str[] = {
    "U",
    "L",
    "UF",
    "LF",
    "UL",
    "LSU",
    "U2L_399_EXT2",
    "UF_D20",
    "UF_D1_EXT",
    "U_EXT",
    "LF_EXT",
    "U_EXT2",
    "L_EXT2",
    "U_EXT3",
};

typedef struct {
    int code;
    int len;
    int type;
    int data;
    int ext_len;
    int ext_data[3];
    int data_index; /* 'data' coming from the table */
} TableEntry;

/* code (17), len (7), type (4) */

void find_run_type(TableEntry *te, CCInfo *tab, int code)
{
    int is_lower, len;
    CCInfo *ci, *ci1, *ci2;

    ci = &tab[code];
    ci1 = &tab[code + 1];
    ci2 = &tab[code + 2];
    te->code = code;
    
    if (ci->l_len == 1 && ci->l_data[0] == code + 2 &&
        ci->f_code == ci->l_data[0] &&
        ci->u_len == 0 &&

        ci1->l_len == 1 && ci1->l_data[0] == code + 2 &&
        ci1->f_code == ci1->l_data[0] &&
        ci1->u_len == 1 && ci1->u_data[0] == code &&

        ci2->l_len == 0 &&
        ci2->f_code == 0 &&
        ci2->u_len == 1 && ci2->u_data[0] == code) {
        te->len = 3;
        te->data = 0;
        te->type = RUN_TYPE_LSU;
        return;
    }

    if (is_complicated_case(ci)) {
        len = 1;
        while (code + len <= CHARCODE_MAX) {
            ci1 = &tab[code + len];
            if (ci1->u_len != 1 ||
                ci1->u_data[0] != ci->u_data[0] + len ||
                ci1->l_len != 0 ||
                ci1->f_code != ci1->u_data[0])
                break;
            len++;
        }
        if (len > 1) {
            te->len = len;
            te->type = RUN_TYPE_UF;
            te->data = ci->u_data[0];
            return;
        }

        if (ci->u_len == 2 && ci->u_data[1] == 0x399 &&
            ci->f_code == 0 && ci->l_len == 0) {
            len = 1;
            while (code + len <= CHARCODE_MAX) {
                ci1 = &tab[code + len];
                if (!(ci1->u_len == 2 &&
                    ci1->u_data[1] == 0x399 &&
                      ci1->u_data[0] == ci->u_data[0] + len &&
                      ci1->f_code == 0 &&
                      ci1->l_len == 0))
                    break;
                len++;
            }
            te->len = len;
            te->type = RUN_TYPE_U_EXT2;
            te->ext_data[0] = ci->u_data[0];
            te->ext_data[1] = ci->u_data[1];
            te->ext_len = 2;
            return;
        }

        if (ci->u_len == 2 && ci->u_data[1] == 0x399 &&
            ci->l_len == 1 && ci->f_code == ci->l_data[0]) {
            len = 1;
            while (code + len <= CHARCODE_MAX) {
                ci1 = &tab[code + len];
                if (!(ci1->u_len == 2 &&
                      ci1->u_data[1] == 0x399 &&
                      ci1->u_data[0] == ci->u_data[0] + len &&
                      ci1->l_len == 1 &&
                      ci1->l_data[0] == ci->l_data[0] + len &&
                      ci1->f_code == ci1->l_data[0]))
                    break;
                len++;
            }
            te->len = len;
            te->type = RUN_TYPE_U2L_399_EXT2;
            te->ext_data[0] = ci->u_data[0];
            te->ext_data[1] = ci->l_data[0];
            te->ext_len = 2;
            return;
        }

        if (ci->l_len == 1 && ci->u_len == 0 && ci->f_code == 0) {
            len = 1;
            while (code + len <= CHARCODE_MAX) {
                ci1 = &tab[code + len];
                if (!(ci1->l_len == 1 &&
                      ci1->l_data[0] == ci->l_data[0] + len &&
                      ci1->u_len == 0 && ci1->f_code == 0))
                    break;
                len++;
            }
            te->len = len;
            te->type = RUN_TYPE_L;
            te->data = ci->l_data[0];
            return;
        }

        if (ci->l_len == 0 &&
            ci->u_len == 1 &&
            ci->u_data[0] < 0x1000 &&
            ci->f_code == ci->u_data[0] + 0x20) {
            te->len = 1;
            te->type = RUN_TYPE_UF_D20;
            te->data = ci->u_data[0];
        } else if (ci->l_len == 0 &&
            ci->u_len == 1 &&
            ci->f_code == ci->u_data[0] + 1) {
            te->len = 1;
            te->type = RUN_TYPE_UF_D1_EXT;
            te->ext_data[0] = ci->u_data[0];
            te->ext_len = 1;
        } else if (ci->l_len == 2 && ci->u_len == 0 && ci->f_code == 0) {
            te->len = 1;
            te->type = RUN_TYPE_L_EXT2;
            te->ext_data[0] = ci->l_data[0];
            te->ext_data[1] = ci->l_data[1];
            te->ext_len = 2;
        } else if (ci->u_len == 2 && ci->l_len == 0 && ci->f_code == 0) {
            te->len = 1;
            te->type = RUN_TYPE_U_EXT2;
            te->ext_data[0] = ci->u_data[0];
            te->ext_data[1] = ci->u_data[1];
            te->ext_len = 2;
        } else if (ci->u_len == 3 && ci->l_len == 0 && ci->f_code == 0) {
            te->len = 1;
            te->type = RUN_TYPE_U_EXT3;
            te->ext_data[0] = ci->u_data[0];
            te->ext_data[1] = ci->u_data[1];
            te->ext_data[2] = ci->u_data[2];
            te->ext_len = 3;
        } else {
            printf("unsupported encoding case:\n");
            dump_cc_info(ci, code);
            abort();
        }
    } else {
        /* look for a run of identical conversions */
        len = 0;
        for(;;) {
            if (code >= CHARCODE_MAX || len >= 126)
                break;
            ci = &tab[code + len];
            ci1 = &tab[code + len + 1];
            if (is_complicated_case(ci) || is_complicated_case(ci1)) {
                break;
            }
            if (ci->l_len != 1 || ci->l_data[0] != code + len + 1)
                break;
            if (ci1->u_len != 1 || ci1->u_data[0] != code + len)
                break;
            len += 2;
        }
        if (len > 0) {
            te->len = len;
            te->type = RUN_TYPE_UL;
            te->data = 0;
            return;
        }
        
        ci = &tab[code];
        is_lower = ci->l_len > 0;
        len = 1;
        while (code + len <= CHARCODE_MAX) {
            ci1 = &tab[code + len];
            if (is_complicated_case(ci1))
                break;
            if (is_lower) {
                if (ci1->l_len != 1 ||
                    ci1->l_data[0] != ci->l_data[0] + len)
                    break;
            } else {
                if (ci1->u_len != 1 ||
                    ci1->u_data[0] != ci->u_data[0] + len)
                    break;
            }
            len++;
        }
        te->len = len;
        if (is_lower) {
            te->type = RUN_TYPE_LF;
            te->data = ci->l_data[0];
        } else {
            te->type = RUN_TYPE_U;
            te->data = ci->u_data[0];
        }
    }
}

TableEntry conv_table[1000];
int conv_table_len;
int ext_data[1000];
int ext_data_len;

void dump_case_conv_table1(void)
{
    int i, j;
    const TableEntry *te;

    for(i = 0; i < conv_table_len; i++) {
        te = &conv_table[i];
        printf("%05x %02x %-10s %05x",
               te->code, te->len, run_type_str[te->type], te->data);
        for(j = 0; j < te->ext_len; j++) {
            printf(" %05x", te->ext_data[j]);
        }
        printf("\n");
    }
    printf("table_len=%d ext_len=%d\n", conv_table_len, ext_data_len);
}

int find_data_index(const TableEntry *conv_table, int len, int data)
{
    int i;
    const TableEntry *te;
    for(i = 0; i < len; i++) {
        te = &conv_table[i];
        if (te->code == data)
            return i;
    }
    return -1;
}

int find_ext_data_index(int data)
{
    int i;
    for(i = 0; i < ext_data_len; i++) {
        if (ext_data[i] == data)
            return i;
    }
    assert(ext_data_len < countof(ext_data));
    ext_data[ext_data_len++] = data;
    return ext_data_len - 1;
}

void build_conv_table(CCInfo *tab)
{
    int code, i, j;
    CCInfo *ci;
    TableEntry *te;
                          
    te = conv_table;
    for(code = 0; code <= CHARCODE_MAX; code++) {
        ci = &tab[code];
        if (ci->u_len == 0 && ci->l_len == 0 && ci->f_code == 0)
            continue;
        assert(te - conv_table < countof(conv_table));
        find_run_type(te, tab, code);
#if 0
        if (te->type == RUN_TYPE_TODO) {
            printf("TODO: ");
            dump_cc_info(ci, code);
        }
#endif
        assert(te->len <= 127);
        code += te->len - 1;
        te++;
    }
    conv_table_len = te - conv_table;

    /* find the data index */
    for(i = 0; i < conv_table_len; i++) {
        int data_index;
        te = &conv_table[i];
        
        switch(te->type) {
        case RUN_TYPE_U:
        case RUN_TYPE_L:
        case RUN_TYPE_UF:
        case RUN_TYPE_LF:
            data_index = find_data_index(conv_table, conv_table_len, te->data);
            if (data_index < 0) {
                switch(te->type) {
                case RUN_TYPE_U:
                    te->type = RUN_TYPE_U_EXT;
                    te->ext_len = 1;
                    te->ext_data[0] = te->data;
                    break;
                case RUN_TYPE_LF:
                    te->type = RUN_TYPE_LF_EXT;
                    te->ext_len = 1;
                    te->ext_data[0] = te->data;
                    break;
                default:
                    printf("%05x: index not found\n", te->code);
                    exit(1);
                }
            } else {
                te->data_index = data_index;
            }
            break;
        case RUN_TYPE_UF_D20:
            te->data_index = te->data;
            break;
        }
    }

    /* find the data index for ext_data */
    for(i = 0; i < conv_table_len; i++) {
        te = &conv_table[i];
        if (te->type == RUN_TYPE_U_EXT3) {
            int p, v;
            v = 0;
            for(j = 0; j < 3; j++) {
                p = find_ext_data_index(te->ext_data[j]);
                assert(p < 16);
                v = (v << 4) | p;
            }
            te->data_index = v;
        }
    }

    for(i = 0; i < conv_table_len; i++) {
        te = &conv_table[i];
        if (te->type == RUN_TYPE_L_EXT2 ||
            te->type == RUN_TYPE_U_EXT2 ||
            te->type == RUN_TYPE_U2L_399_EXT2) {
            int p, v;
            v = 0;
            for(j = 0; j < 2; j++) {
                p = find_ext_data_index(te->ext_data[j]);
                assert(p < 64);
                v = (v << 6) | p;
            }
            te->data_index = v;
        }
    }

    for(i = 0; i < conv_table_len; i++) {
        te = &conv_table[i];
        if (te->type == RUN_TYPE_UF_D1_EXT ||
            te->type == RUN_TYPE_U_EXT ||
            te->type == RUN_TYPE_LF_EXT) {
            te->data_index = find_ext_data_index(te->ext_data[0]);
        }
    }
#ifdef DUMP_CASE_CONV_TABLE
    dump_case_conv_table1();
#endif
}

void dump_case_conv_table(FILE *f)
{
    int i;
    uint32_t v;
    const TableEntry *te;

    fprintf(f, "static const uint32_t case_conv_table1[%u] = {", conv_table_len);
    for(i = 0; i < conv_table_len; i++) {
        if (i % 4 == 0)
            fprintf(f, "\n   ");
        te = &conv_table[i];
        v = te->code << (32 - 17);
        v |= te->len << (32 - 17 - 7);
        v |= te->type << (32 - 17 - 7 - 4);
        v |= te->data_index >> 8;
        fprintf(f, " 0x%08x,", v);
    }
    fprintf(f, "\n};\n\n");

    fprintf(f, "static const uint8_t case_conv_table2[%u] = {", conv_table_len);
    for(i = 0; i < conv_table_len; i++) {
        if (i % 8 == 0)
            fprintf(f, "\n   ");
        te = &conv_table[i];
        fprintf(f, " 0x%02x,", te->data_index & 0xff);
    }
    fprintf(f, "\n};\n\n");

    fprintf(f, "static const uint16_t case_conv_ext[%u] = {", ext_data_len);
    for(i = 0; i < ext_data_len; i++) {
        if (i % 8 == 0)
            fprintf(f, "\n   ");
        fprintf(f, " 0x%04x,", ext_data[i]);
    }
    fprintf(f, "\n};\n\n");
}

int tabcmp(const int *tab1, const int *tab2, int n)
{
    int i;
    for(i = 0; i < n; i++) {
        if (tab1[i] != tab2[i])
            return -1;
    }
    return 0;
}

void dump_str(const char *str, const int *buf, int len)
{
    int i;
    printf("%s=", str);
    for(i = 0; i < len; i++)
        printf(" %05x", buf[i]);
    printf("\n");
}

void compute_internal_props(void)
{
    int i;
    BOOL has_ul;

    for(i = 0; i <= CHARCODE_MAX; i++) {
        CCInfo *ci = &unicode_db[i];
        has_ul = (ci->u_len != 0 || ci->l_len != 0 || ci->f_code != 0);
        if (has_ul) {
            assert(get_prop(i, PROP_Cased));
        } else {
            set_prop(i, PROP_Cased1, get_prop(i, PROP_Cased));
        }
        set_prop(i, PROP_ID_Continue1,
                 get_prop(i, PROP_ID_Continue) & (get_prop(i, PROP_ID_Start) ^ 1));
        set_prop(i, PROP_XID_Start1,
                 get_prop(i, PROP_ID_Start) ^ get_prop(i, PROP_XID_Start));
        set_prop(i, PROP_XID_Continue1,
                 get_prop(i, PROP_ID_Continue) ^ get_prop(i, PROP_XID_Continue));
        set_prop(i, PROP_Changes_When_Titlecased1,
                 get_prop(i, PROP_Changes_When_Titlecased) ^ (ci->u_len != 0));
        set_prop(i, PROP_Changes_When_Casefolded1,
                 get_prop(i, PROP_Changes_When_Casefolded) ^ (ci->f_code != 0));
        /* XXX: reduce table size (438 bytes) */
        set_prop(i, PROP_Changes_When_NFKC_Casefolded1,
                 get_prop(i, PROP_Changes_When_NFKC_Casefolded) ^ (ci->f_code != 0));
#if 0
        /* TEST */
#define M(x) (1U << GCAT_ ## x)
        {
            int b;
            b = ((M(Mn) | M(Cf) | M(Lm) | M(Sk)) >>
                 unicode_db[i].general_category) & 1;
            set_prop(i, PROP_Cased1,
                     get_prop(i, PROP_Case_Ignorable) ^ b);
        }
#undef M
#endif
    }
}

void dump_byte_table(FILE *f, const char *cname, const uint8_t *tab, int len)
{
    int i;
    fprintf(f, "static const uint8_t %s[%d] = {", cname, len);
    for(i = 0; i < len; i++) {
        if (i % 8 == 0)
            fprintf(f, "\n   ");
        fprintf(f, " 0x%02x,", tab[i]);
    }
    fprintf(f, "\n};\n\n");
}

#define PROP_BLOCK_LEN 32

void build_prop_table(FILE *f, int prop_index, BOOL add_index)
{
    int i, j, n, v, offset, code;
    DynBuf dbuf_s, *dbuf = &dbuf_s;
    DynBuf dbuf1_s, *dbuf1 = &dbuf1_s;
    DynBuf dbuf2_s, *dbuf2 = &dbuf2_s;
    const uint32_t *buf;
    int buf_len, block_end_pos, bit;
    char cname[128];
    
    dbuf_init(dbuf1);

    for(i = 0; i <= CHARCODE_MAX;) {
        v = get_prop(i, prop_index);
        j = i + 1;
        while (j <= CHARCODE_MAX && get_prop(j, prop_index) == v) {
            j++;
        }
        n = j - i;
        if (j == (CHARCODE_MAX + 1) && v == 0)
            break; /* no need to encode last zero run */
        //printf("%05x: %d %d\n", i, n, v);
        dbuf_put_u32(dbuf1, n - 1);
        i += n;
    }
    
    dbuf_init(dbuf);
    dbuf_init(dbuf2);
    buf = (uint32_t *)dbuf1->buf;
    buf_len = dbuf1->size / sizeof(buf[0]);
    
    /* the first value is assumed to be 0 */
    assert(get_prop(0, prop_index) == 0);
    
    block_end_pos = PROP_BLOCK_LEN;
    i = 0;
    code = 0;
    bit = 0;
    while (i < buf_len) {
        if (add_index && dbuf->size >= block_end_pos && bit == 0) {
            offset = (dbuf->size - block_end_pos);
            /* XXX: offset could be larger in case of runs of small
               lengths. Could add code to change the encoding to
               prevent it at the expense of one byte loss */
            assert(offset <= 7);
            v = code | (offset << 21);
            dbuf_putc(dbuf2, v);
            dbuf_putc(dbuf2, v >> 8);
            dbuf_putc(dbuf2, v >> 16);
            block_end_pos += PROP_BLOCK_LEN;
        }

        v = buf[i];
        code += v + 1;
        bit ^= 1;
        if (v < 8 && (i + 1) < buf_len && buf[i + 1] < 8) {
            code += buf[i + 1] + 1;
            bit ^= 1;
            dbuf_putc(dbuf, (v << 3) | buf[i + 1]);
            i += 2;
        } else if (v < 128) {
            dbuf_putc(dbuf, 0x80 + v);
            i++;
        } else if (v < (1 << 13)) {
            dbuf_putc(dbuf, 0x40 + (v >> 8));
            dbuf_putc(dbuf, v);
            i++;
        } else {
            assert(v < (1 << 21));
            dbuf_putc(dbuf, 0x60 + (v >> 16));
            dbuf_putc(dbuf, v >> 8);
            dbuf_putc(dbuf, v);
            i++;
        }
    }

    if (add_index) {
        /* last index entry */
        v = code;
        dbuf_putc(dbuf2, v);
        dbuf_putc(dbuf2, v >> 8);
        dbuf_putc(dbuf2, v >> 16);
    }

#ifdef DUMP_TABLE_SIZE
    printf("prop %s: length=%d bytes\n", unicode_prop_name[prop_index],
           (int)(dbuf->size + dbuf2->size));
#endif
    snprintf(cname, sizeof(cname), "unicode_prop_%s_table", unicode_prop_name[prop_index]);
    dump_byte_table(f, cname, dbuf->buf, dbuf->size);
    if (add_index) {
        snprintf(cname, sizeof(cname), "unicode_prop_%s_index", unicode_prop_name[prop_index]);
        dump_byte_table(f, cname, dbuf2->buf, dbuf2->size);
    }
    
    dbuf_free(dbuf);
    dbuf_free(dbuf1);
    dbuf_free(dbuf2);
}

void build_flags_tables(FILE *f)
{
    build_prop_table(f, PROP_Cased1, TRUE);
    build_prop_table(f, PROP_Case_Ignorable, TRUE);
    build_prop_table(f, PROP_ID_Start, TRUE);
    build_prop_table(f, PROP_ID_Continue1, TRUE);
}

void dump_name_table(FILE *f, const char *cname, const char **tab_name, int len,
                     const char **tab_short_name)
{
    int i, w, maxw;

    maxw = 0;
    for(i = 0; i < len; i++) {
        w = strlen(tab_name[i]);
        if (tab_short_name[i][0] != '\0') {
            w += 1 + strlen(tab_short_name[i]);
        }
        if (maxw < w)
            maxw = w;
    }

    /* generate a sequence of strings terminated by an empty string */
    fprintf(f, "static const char %s[] =\n", cname);
    for(i = 0; i < len; i++) {
        fprintf(f, "    \"");
        w = fprintf(f, "%s", tab_name[i]);
        if (tab_short_name[i][0] != '\0') {
            w += fprintf(f, ",%s", tab_short_name[i]);
        }
        fprintf(f, "\"%*s\"\\0\"\n", 1 + maxw - w, "");
    }
    fprintf(f, ";\n\n");
}

void build_general_category_table(FILE *f)
{
    int i, v, j, n, n1;
    DynBuf dbuf_s, *dbuf = &dbuf_s;
    int cw_count, cw_len_count[4], cw_start;

    fprintf(f, "typedef enum {\n");
    for(i = 0; i < GCAT_COUNT; i++)
        fprintf(f, "    UNICODE_GC_%s,\n", unicode_gc_name[i]);
    fprintf(f, "    UNICODE_GC_COUNT,\n");
    fprintf(f, "} UnicodeGCEnum;\n\n");

    dump_name_table(f, "unicode_gc_name_table",
                    unicode_gc_name, GCAT_COUNT,
                    unicode_gc_short_name);

    dbuf_init(dbuf);
    cw_count = 0;
    for(i = 0; i < 4; i++)
        cw_len_count[i] = 0;
    for(i = 0; i <= CHARCODE_MAX;) {
        v = unicode_db[i].general_category;
        j = i + 1;
        while (j <= CHARCODE_MAX && unicode_db[j].general_category == v)
            j++;
        n = j - i;
        /* compress Lu/Ll runs */
        if (v == GCAT_Lu) {
            n1 = 1;
            while ((i + n1) <= CHARCODE_MAX && unicode_db[i + n1].general_category == (v + (n1 & 1))) {
                n1++;
            }
            if (n1 > n) {
                v = 31;
                n = n1;
            }
        }
        //        printf("%05x %05x %d\n", i, n, v);
        cw_count++;
        n--;
        cw_start = dbuf->size;
        if (n < 7) {
            dbuf_putc(dbuf, (n << 5) | v);
        } else if (n < 7 + 128) {
            n1 = n - 7;
            assert(n1 < 128);
            dbuf_putc(dbuf, (0xf << 5) | v);
            dbuf_putc(dbuf, n1);
        } else if (n < 7 + 128 + (1 << 14)) {
            n1 = n - (7 + 128);
            assert(n1 < (1 << 14));
            dbuf_putc(dbuf, (0xf << 5) | v);
            dbuf_putc(dbuf, (n1 >> 8) + 128);
            dbuf_putc(dbuf, n1);
        } else {
            n1 = n - (7 + 128 + (1 << 14));
            assert(n1 < (1 << 22));
            dbuf_putc(dbuf, (0xf << 5) | v);
            dbuf_putc(dbuf, (n1 >> 16) + 128 + 64);
            dbuf_putc(dbuf, n1 >> 8);
            dbuf_putc(dbuf, n1);
        }
        cw_len_count[dbuf->size - cw_start - 1]++;
        i += n + 1;
    }
#ifdef DUMP_TABLE_SIZE
    printf("general category: %d entries [",
           cw_count);
    for(i = 0; i < 4; i++)
        printf(" %d", cw_len_count[i]);
    printf(" ], length=%d bytes\n", (int)dbuf->size);
#endif
    
    dump_byte_table(f, "unicode_gc_table", dbuf->buf, dbuf->size);

    dbuf_free(dbuf);
}

void build_script_table(FILE *f)
{
    int i, v, j, n, n1, type;
    DynBuf dbuf_s, *dbuf = &dbuf_s;
    int cw_count, cw_len_count[4], cw_start;

    fprintf(f, "typedef enum {\n");
    for(i = 0; i < SCRIPT_COUNT; i++)
        fprintf(f, "    UNICODE_SCRIPT_%s,\n", unicode_script_name[i]);
    fprintf(f, "    UNICODE_SCRIPT_COUNT,\n");
    fprintf(f, "} UnicodeScriptEnum;\n\n");

    i = 1;
    dump_name_table(f, "unicode_script_name_table",
                    unicode_script_name + i, SCRIPT_COUNT - i,
                    unicode_script_short_name + i);

    dbuf_init(dbuf);
    cw_count = 0;
    for(i = 0; i < 4; i++)
        cw_len_count[i] = 0;
    for(i = 0; i <= CHARCODE_MAX;) {
        v = unicode_db[i].script;
        j = i + 1;
        while (j <= CHARCODE_MAX && unicode_db[j].script == v)
            j++;
        n = j - i;
        if (v == 0 && j == (CHARCODE_MAX + 1))
            break;
        //        printf("%05x %05x %d\n", i, n, v);
        cw_count++;
        n--;
        cw_start = dbuf->size;
        if (v == 0)
            type = 0;
        else
            type = 1;
        if (n < 96) {
            dbuf_putc(dbuf, n | (type << 7));
        } else if (n < 96 + (1 << 12)) {
            n1 = n - 96;
            assert(n1 < (1 << 12));
            dbuf_putc(dbuf, ((n1 >> 8) + 96) | (type << 7));
            dbuf_putc(dbuf, n1);
        } else {
            n1 = n - (96 + (1 << 12));
            assert(n1 < (1 << 20));
            dbuf_putc(dbuf, ((n1 >> 16) + 112) | (type << 7));
            dbuf_putc(dbuf, n1 >> 8);
            dbuf_putc(dbuf, n1);
        }
        if (type != 0)
            dbuf_putc(dbuf, v);

        cw_len_count[dbuf->size - cw_start - 1]++;
        i += n + 1;
    }
#if defined(DUMP_TABLE_SIZE)
    printf("script: %d entries [",
           cw_count);
    for(i = 0; i < 4; i++)
        printf(" %d", cw_len_count[i]);
    printf(" ], length=%d bytes\n", (int)dbuf->size);
#endif
    
    dump_byte_table(f, "unicode_script_table", dbuf->buf, dbuf->size);

    dbuf_free(dbuf);
}

void build_script_ext_table(FILE *f)
{
    int i, j, n, n1, script_ext_len;
    DynBuf dbuf_s, *dbuf = &dbuf_s;
    int cw_count;

    dbuf_init(dbuf);
    cw_count = 0;
    for(i = 0; i <= CHARCODE_MAX;) {
        script_ext_len = unicode_db[i].script_ext_len;
        j = i + 1;
        while (j <= CHARCODE_MAX &&
               unicode_db[j].script_ext_len == script_ext_len &&
               !memcmp(unicode_db[j].script_ext, unicode_db[i].script_ext,
                       script_ext_len)) {
            j++;
        }
        n = j - i;
        cw_count++;
        n--;
        if (n < 128) {
            dbuf_putc(dbuf, n);
        } else if (n < 128 + (1 << 14)) {
            n1 = n - 128;
            assert(n1 < (1 << 14));
            dbuf_putc(dbuf, (n1 >> 8) + 128);
            dbuf_putc(dbuf, n1);
        } else {
            n1 = n - (128 + (1 << 14));
            assert(n1 < (1 << 22));
            dbuf_putc(dbuf, (n1 >> 16) + 128 + 64);
            dbuf_putc(dbuf, n1 >> 8);
            dbuf_putc(dbuf, n1);
        }
        dbuf_putc(dbuf, script_ext_len);
        for(j = 0; j < script_ext_len; j++)
            dbuf_putc(dbuf, unicode_db[i].script_ext[j]);
        i += n + 1;
    }
#ifdef DUMP_TABLE_SIZE
    printf("script_ext: %d entries",
           cw_count);
    printf(", length=%d bytes\n", (int)dbuf->size);
#endif
    
    dump_byte_table(f, "unicode_script_ext_table", dbuf->buf, dbuf->size);

    dbuf_free(dbuf);
}

/* the following properties are synthetized so no table is necessary */
#define PROP_TABLE_COUNT PROP_ASCII

void build_prop_list_table(FILE *f)
{
    int i;
    
    for(i = 0; i < PROP_TABLE_COUNT; i++) {
        if (i == PROP_ID_Start ||
            i == PROP_Case_Ignorable ||
            i == PROP_ID_Continue1) {
            /* already generated */
        } else {
            build_prop_table(f, i, FALSE);
        }
    }
    
    fprintf(f, "typedef enum {\n");
    for(i = 0; i < PROP_COUNT; i++)
        fprintf(f, "    UNICODE_PROP_%s,\n", unicode_prop_name[i]);
    fprintf(f, "    UNICODE_PROP_COUNT,\n");
    fprintf(f, "} UnicodePropertyEnum;\n\n");

    i = PROP_ASCII_Hex_Digit;
    dump_name_table(f, "unicode_prop_name_table",
                    unicode_prop_name + i, PROP_XID_Start - i + 1,
                    unicode_prop_short_name + i);

    fprintf(f, "static const uint8_t * const unicode_prop_table[] = {\n");
    for(i = 0; i < PROP_TABLE_COUNT; i++) {
        fprintf(f, "    unicode_prop_%s_table,\n", unicode_prop_name[i]);
    }
    fprintf(f, "};\n\n");

    fprintf(f, "static const uint16_t unicode_prop_len_table[] = {\n");
    for(i = 0; i < PROP_TABLE_COUNT; i++) {
        fprintf(f, "    countof(unicode_prop_%s_table),\n", unicode_prop_name[i]);
    }
    fprintf(f, "};\n\n");
}

#ifdef USE_TEST
int check_conv(uint32_t *res, uint32_t c, int conv_type)
{
    return lre_case_conv(res, c, conv_type);
}

void check_case_conv(void)
{
    CCInfo *tab = unicode_db;
    uint32_t res[3];
    int l, error;
    CCInfo ci_s, *ci1, *ci = &ci_s;
    int code;
    
    for(code = 0; code <= CHARCODE_MAX; code++) {
        ci1 = &tab[code];
        *ci = *ci1;
        if (ci->l_len == 0) {
            ci->l_len = 1;
            ci->l_data[0] = code;
        }
        if (ci->u_len == 0) {
            ci->u_len = 1;
            ci->u_data[0] = code;
        }
        if (ci->f_code == 0)
            ci->f_code = code;

        error = 0;
        l = check_conv(res, code, 0);
        if (l != ci->u_len || tabcmp((int *)res, ci->u_data, l)) {
            printf("ERROR: L\n");
            error++;
        }
        l = check_conv(res, code, 1);
        if (l != ci->l_len || tabcmp((int *)res, ci->l_data, l)) {
            printf("ERROR: U\n");
            error++;
        }
        l = check_conv(res, code, 2);
        if (l != 1 || res[0] != ci->f_code) {
            printf("ERROR: F\n");
            error++;
        }
        if (error) {
            dump_cc_info(ci, code);
            exit(1);
        }
    }
}

#ifdef PROFILE
static int64_t get_time_ns(void)
{
    struct timespec ts;
    clock_gettime(CLOCK_MONOTONIC, &ts);
    return (int64_t)ts.tv_sec * 1000000000 + ts.tv_nsec;
}
#endif

void check_flags(void)
{
    int c;
    BOOL flag_ref, flag;
    for(c = 0; c <= CHARCODE_MAX; c++) {
        flag_ref = get_prop(c, PROP_Cased);
        flag = lre_is_cased(c);
        if (flag != flag_ref) {
            printf("ERROR: c=%05x cased=%d ref=%d\n",
                   c, flag, flag_ref);
            exit(1);
        }

        flag_ref = get_prop(c, PROP_Case_Ignorable);
        flag = lre_is_case_ignorable(c);
        if (flag != flag_ref) {
            printf("ERROR: c=%05x case_ignorable=%d ref=%d\n",
                   c, flag, flag_ref);
            exit(1);
        }

        flag_ref = get_prop(c, PROP_ID_Start);
        flag = lre_is_id_start(c);
        if (flag != flag_ref) {
            printf("ERROR: c=%05x id_start=%d ref=%d\n",
                   c, flag, flag_ref);
            exit(1);
        }

        flag_ref = get_prop(c, PROP_ID_Continue);
        flag = lre_is_id_continue(c);
        if (flag != flag_ref) {
            printf("ERROR: c=%05x id_cont=%d ref=%d\n",
                   c, flag, flag_ref);
            exit(1);
        }
    }
#ifdef PROFILE
    {
        int64_t ti, count;
        ti = get_time_ns();
        count = 0;
        for(c = 0x20; c <= 0xffff; c++) {
            flag_ref = get_prop(c, PROP_ID_Start);
            flag = lre_is_id_start(c);
            assert(flag == flag_ref);
            count++;
        }
        ti = get_time_ns() - ti;
        printf("flags time=%0.1f ns/char\n",
               (double)ti / count);
    }
#endif
}

#endif

#define CC_BLOCK_LEN 32

void build_cc_table(FILE *f)
{
    int i, cc, n, cc_table_len, type, n1;
    DynBuf dbuf_s, *dbuf = &dbuf_s;
    DynBuf dbuf1_s, *dbuf1 = &dbuf1_s;
    int cw_len_tab[3], cw_start, block_end_pos;
    uint32_t v;
    
    dbuf_init(dbuf);
    dbuf_init(dbuf1);
    cc_table_len = 0;
    for(i = 0; i < countof(cw_len_tab); i++)
        cw_len_tab[i] = 0;
    block_end_pos = CC_BLOCK_LEN;
    for(i = 0; i <= CHARCODE_MAX;) {
        cc = unicode_db[i].combining_class;
        assert(cc <= 255);
        /* check increasing values */
        n = 1;
        while ((i + n) <= CHARCODE_MAX &&
               unicode_db[i + n].combining_class == (cc + n))
            n++;
        if (n >= 2) {
            type = 1;
        } else {
            type = 0;
            n = 1;
            while ((i + n) <= CHARCODE_MAX &&
                   unicode_db[i + n].combining_class == cc)
                n++;
        }
        /* no need to encode the last run */
        if (cc == 0 && (i + n - 1) == CHARCODE_MAX)
            break;
#ifdef DUMP_CC_TABLE
        printf("%05x %6d %d %d\n", i, n, type, cc);
#endif
        if (type == 0) {
            if (cc == 0)
                type = 2;
            else if (cc == 230)
                type = 3;
        }
        n1 = n - 1;

        /* add an entry to the index if necessary */
        if (dbuf->size >= block_end_pos) {
            v = i | ((dbuf->size - block_end_pos) << 21);
            dbuf_putc(dbuf1, v);
            dbuf_putc(dbuf1, v >> 8);
            dbuf_putc(dbuf1, v >> 16);
            block_end_pos += CC_BLOCK_LEN;
        }
        cw_start = dbuf->size;
        if (n1 < 48) {
            dbuf_putc(dbuf, n1 | (type << 6));
        } else if (n1 < 48 + (1 << 11)) {
            n1 -= 48;
            dbuf_putc(dbuf, ((n1 >> 8) + 48) | (type << 6));
            dbuf_putc(dbuf, n1);
        } else {
            n1 -= 48 + (1 << 11);
            assert(n1 < (1 << 20));
            dbuf_putc(dbuf, ((n1 >> 16) + 56) | (type << 6));
            dbuf_putc(dbuf, n1 >> 8);
            dbuf_putc(dbuf, n1);
        }
        cw_len_tab[dbuf->size - cw_start - 1]++;
        if (type == 0 || type == 1)
            dbuf_putc(dbuf, cc);
        cc_table_len++;
        i += n;
    }

    /* last index entry */
    v = i;
    dbuf_putc(dbuf1, v);
    dbuf_putc(dbuf1, v >> 8);
    dbuf_putc(dbuf1, v >> 16);
    
    dump_byte_table(f, "unicode_cc_table", dbuf->buf, dbuf->size);
    dump_byte_table(f, "unicode_cc_index", dbuf1->buf, dbuf1->size);

#if defined(DUMP_CC_TABLE) || defined(DUMP_TABLE_SIZE)
    printf("CC table: size=%d (%d entries) [",
           (int)(dbuf->size + dbuf1->size),
           cc_table_len);
    for(i = 0; i < countof(cw_len_tab); i++)
        printf(" %d", cw_len_tab[i]);
    printf(" ]\n");
#endif
    dbuf_free(dbuf);
    dbuf_free(dbuf1);
}

/* maximum length of decomposition: 18 chars (1), then 8 */
#ifndef USE_TEST
typedef enum {
    DECOMP_TYPE_C1, /* 16 bit char */
    DECOMP_TYPE_L1, /* 16 bit char table */
    DECOMP_TYPE_L2,
    DECOMP_TYPE_L3,
    DECOMP_TYPE_L4,
    DECOMP_TYPE_L5, /* XXX: not used */
    DECOMP_TYPE_L6, /* XXX: could remove */
    DECOMP_TYPE_L7, /* XXX: could remove */
    DECOMP_TYPE_LL1, /* 18 bit char table */
    DECOMP_TYPE_LL2,
    DECOMP_TYPE_S1, /* 8 bit char table */
    DECOMP_TYPE_S2,
    DECOMP_TYPE_S3,
    DECOMP_TYPE_S4,
    DECOMP_TYPE_S5,
    DECOMP_TYPE_I1, /* increment 16 bit char value */
    DECOMP_TYPE_I2_0,
    DECOMP_TYPE_I2_1,
    DECOMP_TYPE_I3_1,
    DECOMP_TYPE_I3_2,
    DECOMP_TYPE_I4_1,
    DECOMP_TYPE_I4_2,
    DECOMP_TYPE_B1, /* 16 bit base + 8 bit offset */
    DECOMP_TYPE_B2,
    DECOMP_TYPE_B3,
    DECOMP_TYPE_B4,
    DECOMP_TYPE_B5,
    DECOMP_TYPE_B6,
    DECOMP_TYPE_B7,
    DECOMP_TYPE_B8,
    DECOMP_TYPE_B18,
    DECOMP_TYPE_LS2,
    DECOMP_TYPE_PAT3,
    DECOMP_TYPE_S2_UL,
    DECOMP_TYPE_LS2_UL,
} DecompTypeEnum;
#endif

const char *decomp_type_str[] = {
    "C1",
    "L1",
    "L2",
    "L3",
    "L4",
    "L5",
    "L6",
    "L7",
    "LL1",
    "LL2",
    "S1",
    "S2",
    "S3",
    "S4",
    "S5",
    "I1",
    "I2_0",
    "I2_1",
    "I3_1",
    "I3_2",
    "I4_1",
    "I4_2",
    "B1",
    "B2",
    "B3",
    "B4",
    "B5",
    "B6",
    "B7",
    "B8",
    "B18",
    "LS2",
    "PAT3",
    "S2_UL",
    "LS2_UL",
};

const int decomp_incr_tab[4][4] = {
    { DECOMP_TYPE_I1, 0, -1 },
    { DECOMP_TYPE_I2_0, 0, 1, -1 },
    { DECOMP_TYPE_I3_1, 1, 2, -1 },
    { DECOMP_TYPE_I4_1, 1, 2, -1 },
};

/*
  entry size:
  type   bits
  code   18 
  len    7
  compat 1
  type   5
  index  16
  total  47
*/

typedef struct {
    int code;
    uint8_t len;
    uint8_t type;
    uint8_t c_len;
    uint16_t c_min;
    uint16_t data_index;
    int cost; /* size in bytes from this entry to the end */
} DecompEntry;

int get_decomp_run_size(const DecompEntry *de)
{
    int s;
    s = 6;
    if (de->type <= DECOMP_TYPE_C1) {
        /* nothing more */
    } else if (de->type <= DECOMP_TYPE_L7) {
        s += de->len * de->c_len * 2;
    } else if (de->type <= DECOMP_TYPE_LL2) {
        /* 18 bits per char */
        s += (de->len * de->c_len * 18 + 7) / 8;
    } else if (de->type <= DECOMP_TYPE_S5) {
        s += de->len * de->c_len;
    } else if (de->type <= DECOMP_TYPE_I4_2) {
        s += de->c_len * 2;
    } else if (de->type <= DECOMP_TYPE_B18) {
        s += 2 + de->len * de->c_len;
    } else if (de->type <= DECOMP_TYPE_LS2) {
        s += de->len * 3;
    } else if (de->type <= DECOMP_TYPE_PAT3) {
        s += 4 + de->len * 2;
    } else if (de->type <= DECOMP_TYPE_S2_UL) {
        s += de->len;
    } else if (de->type <= DECOMP_TYPE_LS2_UL) {
        s += (de->len / 2) * 3;
    } else {
        abort();
    }
    return s;
}

static const uint16_t unicode_short_table[2] = { 0x2044, 0x2215 };

/* return -1 if not found */
int get_short_code(int c)
{
    int i;
    if (c < 0x80) {
        return c;
    } else if (c >= 0x300 && c < 0x350) {
        return c - 0x300 + 0x80;
    } else {
        for(i = 0; i < countof(unicode_short_table); i++) {
            if (c == unicode_short_table[i])
                return i + 0x80 + 0x50;
        }
        return -1;
    }
}

static BOOL is_short(int code)
{
    return get_short_code(code) >= 0;
}

static BOOL is_short_tab(const int *tab, int len)
{
    int i;
    for(i = 0; i < len; i++) {
        if (!is_short(tab[i]))
            return FALSE;
    }
    return TRUE;
}

static BOOL is_16bit(const int *tab, int len)
{
    int i;
    for(i = 0; i < len; i++) {
        if (tab[i] > 0xffff)
            return FALSE;
    }
    return TRUE;
}

static uint32_t to_lower_simple(uint32_t c)
{
    /* Latin1 and Cyrillic */
    if (c < 0x100 || (c >= 0x410 && c <= 0x42f))
        c += 0x20;
    else
        c++;
    return c;
}

/* select best encoding with dynamic programming */
void find_decomp_run(DecompEntry *tab_de, int i)
{
    DecompEntry de_s, *de = &de_s;
    CCInfo *ci, *ci1, *ci2;
    int l, j, n, len_max;
    
    ci = &unicode_db[i];
    l = ci->decomp_len;
    if (l == 0) {
        tab_de[i].cost = tab_de[i + 1].cost;
        return;
    }

    /* the offset for the compose table has only 6 bits, so we must
       limit if it can be used by the compose table */
    if (!ci->is_compat && !ci->is_excluded && l == 2)
        len_max = 64; 
    else
        len_max = 127;
    
    tab_de[i].cost = 0x7fffffff;
    
    if (!is_16bit(ci->decomp_data, l)) {
        assert(l <= 2);

        n = 1;
        for(;;) {
            de->code = i;
            de->len = n;
            de->type = DECOMP_TYPE_LL1 + l - 1;
            de->c_len = l;
            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;
            if (de->cost < tab_de[i].cost) {
                tab_de[i] = *de;
            }
            if (!((i + n) <= CHARCODE_MAX && n < len_max))
                break;
            ci1 = &unicode_db[i + n];
            /* Note: we accept a hole */
            if (!(ci1->decomp_len == 0 ||
                  (ci1->decomp_len == l &&
                   ci1->is_compat == ci->is_compat)))
                break;
            n++;
        }
        return;
    }

    if (l <= 7) {
        n = 1;
        for(;;) {
            de->code = i;
            de->len = n;
            if (l == 1 && n == 1) {
                de->type = DECOMP_TYPE_C1;
            } else {
                assert(l <= 8);
                de->type = DECOMP_TYPE_L1 + l - 1;
            }
            de->c_len = l;
            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;
            if (de->cost < tab_de[i].cost) {
                tab_de[i] = *de;
            }
            
            if (!((i + n) <= CHARCODE_MAX && n < len_max))
                break;
            ci1 = &unicode_db[i + n];
            /* Note: we accept a hole */
            if (!(ci1->decomp_len == 0 ||
                  (ci1->decomp_len == l &&
                   ci1->is_compat == ci->is_compat &&
                   is_16bit(ci1->decomp_data, l))))
                break;
            n++;
        }
    }
    
    if (l <= 8 || l == 18) {
        int c_min, c_max, c;
        c_min = c_max = -1;
        n = 1;
        for(;;) {
            ci1 = &unicode_db[i + n - 1];
            for(j = 0; j < l; j++) {
                c = ci1->decomp_data[j];
                if (c == 0x20) {
                    /* we accept space for Arabic */
                } else if (c_min == -1) {
                    c_min = c_max = c;
                } else {
                    c_min = min_int(c_min, c);
                    c_max = max_int(c_max, c);
                }
            }
            if ((c_max - c_min) > 254)
                break;
            de->code = i;
            de->len = n;
            if (l == 18)
                de->type = DECOMP_TYPE_B18;
            else
                de->type = DECOMP_TYPE_B1 + l - 1;
            de->c_len = l;
            de->c_min = c_min;
            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;
            if (de->cost < tab_de[i].cost) {
                tab_de[i] = *de;
            }
            if (!((i + n) <= CHARCODE_MAX && n < len_max))
                break;
            ci1 = &unicode_db[i + n];
            if (!(ci1->decomp_len == l &&
                  ci1->is_compat == ci->is_compat))
                break;
            n++;
        }
    }

    /* find an ascii run */
    if (l <= 5 && is_short_tab(ci->decomp_data, l)) {
        n = 1;
        for(;;) {
            de->code = i;
            de->len = n;
            de->type = DECOMP_TYPE_S1 + l - 1;
            de->c_len = l;
            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;
            if (de->cost < tab_de[i].cost) {
                tab_de[i] = *de;
            }

            if (!((i + n) <= CHARCODE_MAX && n < len_max))
                break;
            ci1 = &unicode_db[i + n];
            /* Note: we accept a hole */
            if (!(ci1->decomp_len == 0 ||
                  (ci1->decomp_len == l &&
                   ci1->is_compat == ci->is_compat &&
                   is_short_tab(ci1->decomp_data, l))))
                break;
            n++;
        }
    }

    /* check if a single char is increasing */
    if (l <= 4) {
        int idx1, idx;
        
        for(idx1 = 1; (idx = decomp_incr_tab[l - 1][idx1]) >= 0; idx1++) {
            n = 1;
            for(;;) {
                de->code = i;
                de->len = n;
                de->type = decomp_incr_tab[l - 1][0] + idx1 - 1;
                de->c_len = l;
                de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;
                if (de->cost < tab_de[i].cost) {
                    tab_de[i] = *de;
                }

                if (!((i + n) <= CHARCODE_MAX && n < len_max))
                    break;
                ci1 = &unicode_db[i + n];
                if (!(ci1->decomp_len == l &&
                      ci1->is_compat == ci->is_compat))
                    goto next1;
                for(j = 0; j < l; j++) {
                    if (j == idx) {
                        if (ci1->decomp_data[j] != ci->decomp_data[j] + n)
                            goto next1;
                    } else {
                        if (ci1->decomp_data[j] != ci->decomp_data[j])
                            goto next1;
                    }
                }
                n++;
            }
        next1: ;
        }
    }

    if (l == 3) {
        n = 1;
        for(;;) {
            de->code = i;
            de->len = n;
            de->type = DECOMP_TYPE_PAT3;
            de->c_len = l;
            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;
            if (de->cost < tab_de[i].cost) {
                tab_de[i] = *de;
            }
            if (!((i + n) <= CHARCODE_MAX && n < len_max))
                break;
            ci1 = &unicode_db[i + n];
            if (!(ci1->decomp_len == l &&
                  ci1->is_compat == ci->is_compat &&
                  ci1->decomp_data[1] <= 0xffff &&
                  ci1->decomp_data[0] == ci->decomp_data[0] &&
                  ci1->decomp_data[l - 1] == ci->decomp_data[l - 1]))
                break;
            n++;
        }
    }

    if (l == 2 && is_short(ci->decomp_data[1])) {
        n = 1;
        for(;;) {
            de->code = i;
            de->len = n;
            de->type = DECOMP_TYPE_LS2;
            de->c_len = l;
            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;
            if (de->cost < tab_de[i].cost) {
                tab_de[i] = *de;
            }
            if (!((i + n) <= CHARCODE_MAX && n < len_max))
                break;
            ci1 = &unicode_db[i + n];
            if (!(ci1->decomp_len == 0 ||
                  (ci1->decomp_len == l &&
                   ci1->is_compat == ci->is_compat &&
                   ci1->decomp_data[0] <= 0xffff &&
                   is_short(ci1->decomp_data[1]))))
                break;
            n++;
        }
    }

    if (l == 2) {
        BOOL is_16bit;
        
        n = 0;
        is_16bit = FALSE;
        for(;;) {
            if (!((i + n + 1) <= CHARCODE_MAX && n + 2 <= len_max))
                break;
            ci1 = &unicode_db[i + n];
            if (!(ci1->decomp_len == l &&
                  ci1->is_compat == ci->is_compat &&
                  is_short(ci1->decomp_data[1])))
                break;
            if (!is_16bit && !is_short(ci1->decomp_data[0]))
                is_16bit = TRUE;
            ci2 = &unicode_db[i + n + 1];
            if (!(ci2->decomp_len == l &&
                  ci2->is_compat == ci->is_compat &&
                  ci2->decomp_data[0] == to_lower_simple(ci1->decomp_data[0])  &&
                  ci2->decomp_data[1] == ci1->decomp_data[1]))
                break;
            n += 2;
            de->code = i;
            de->len = n;
            de->type = DECOMP_TYPE_S2_UL + is_16bit;
            de->c_len = l;
            de->cost = get_decomp_run_size(de) + tab_de[i + n].cost;
            if (de->cost < tab_de[i].cost) {
                tab_de[i] = *de;
            }
        }
    }
}

void put16(uint8_t *data_buf, int *pidx, uint16_t c)
{
    int idx;
    idx = *pidx;
    data_buf[idx++] = c;
    data_buf[idx++] = c >> 8;
    *pidx = idx;
}

void add_decomp_data(uint8_t *data_buf, int *pidx, DecompEntry *de)
{
    int i, j, idx, c;
    CCInfo *ci;
    
    idx = *pidx;
    de->data_index = idx;
    if (de->type <= DECOMP_TYPE_C1) {
        ci = &unicode_db[de->code];
        assert(ci->decomp_len == 1);
        de->data_index = ci->decomp_data[0];
    } else if (de->type <= DECOMP_TYPE_L7) {
        for(i = 0; i < de->len; i++) {
            ci = &unicode_db[de->code + i];
            for(j = 0; j < de->c_len; j++) {
                if (ci->decomp_len == 0)
                    c = 0;
                else
                    c = ci->decomp_data[j];
                put16(data_buf, &idx,  c);
            }
        }
    } else if (de->type <= DECOMP_TYPE_LL2) {
        int n, p, k;
        n = (de->len * de->c_len * 18 + 7) / 8;
        p = de->len * de->c_len * 2;
        memset(data_buf + idx, 0, n);
        k = 0;
        for(i = 0; i < de->len; i++) {
            ci = &unicode_db[de->code + i];
            for(j = 0; j < de->c_len; j++) {
                if (ci->decomp_len == 0)
                    c = 0;
                else
                    c = ci->decomp_data[j];
                data_buf[idx + k * 2] = c;
                data_buf[idx + k * 2 + 1] = c >> 8;
                data_buf[idx + p + (k / 4)] |= (c >> 16) << ((k % 4) * 2);
                k++;
            }
        }
        idx += n;
    } else if (de->type <= DECOMP_TYPE_S5) {
        for(i = 0; i < de->len; i++) {
            ci = &unicode_db[de->code + i];
            for(j = 0; j < de->c_len; j++) {
                if (ci->decomp_len == 0)
                    c = 0;
                else
                    c = ci->decomp_data[j];
                c = get_short_code(c);
                assert(c >= 0);
                data_buf[idx++] = c;
            }
        }
    } else if (de->type <= DECOMP_TYPE_I4_2) {
        ci = &unicode_db[de->code];
        assert(ci->decomp_len == de->c_len);
        for(j = 0; j < de->c_len; j++)
            put16(data_buf, &idx, ci->decomp_data[j]);
    } else if (de->type <= DECOMP_TYPE_B18) {
        c = de->c_min;
        data_buf[idx++] = c;
        data_buf[idx++] = c >> 8;
        for(i = 0; i < de->len; i++) {
            ci = &unicode_db[de->code + i];
            for(j = 0; j < de->c_len; j++) {
                assert(ci->decomp_len == de->c_len);
                c = ci->decomp_data[j];
                if (c == 0x20) {
                    c = 0xff;
                } else {
                    c -= de->c_min;
                    assert((uint32_t)c <= 254);
                }
                data_buf[idx++] = c;
            }
        }
    } else if (de->type <= DECOMP_TYPE_LS2) {
        assert(de->c_len == 2);
        for(i = 0; i < de->len; i++) {
            ci = &unicode_db[de->code + i];
            if (ci->decomp_len == 0)
                c = 0;
            else
                c = ci->decomp_data[0];
            put16(data_buf, &idx,  c);

            if (ci->decomp_len == 0)
                c = 0;
            else
                c = ci->decomp_data[1];
            c = get_short_code(c);
            assert(c >= 0);
            data_buf[idx++] = c;
        }
    } else if (de->type <= DECOMP_TYPE_PAT3) {
        ci = &unicode_db[de->code];
        assert(ci->decomp_len == 3);
        put16(data_buf, &idx,  ci->decomp_data[0]);
        put16(data_buf, &idx,  ci->decomp_data[2]);
        for(i = 0; i < de->len; i++) {
            ci = &unicode_db[de->code + i];
            assert(ci->decomp_len == 3);
            put16(data_buf, &idx,  ci->decomp_data[1]);
        }
    } else if (de->type <= DECOMP_TYPE_S2_UL) {
        for(i = 0; i < de->len; i += 2) {
            ci = &unicode_db[de->code + i];
            c = ci->decomp_data[0];
            c = get_short_code(c);
            assert(c >= 0);
            data_buf[idx++] = c;
            c = ci->decomp_data[1];
            c = get_short_code(c);
            assert(c >= 0);
            data_buf[idx++] = c;
        }
    } else if (de->type <= DECOMP_TYPE_LS2_UL) {
        for(i = 0; i < de->len; i += 2) {
            ci = &unicode_db[de->code + i];
            c = ci->decomp_data[0];
            put16(data_buf, &idx,  c);
            c = ci->decomp_data[1];
            c = get_short_code(c);
            assert(c >= 0);
            data_buf[idx++] = c;
        }
    } else {
        abort();
    }
    *pidx = idx;
}

#if 0
void dump_large_char(void)
{
    int i, j;
    for(i = 0; i <= CHARCODE_MAX; i++) {
        CCInfo *ci = &unicode_db[i];
        for(j = 0; j < ci->decomp_len; j++) {
            if (ci->decomp_data[j] > 0xffff)
                printf("%05x\n", ci->decomp_data[j]);
        }
    }
}
#endif

void build_compose_table(FILE *f, const DecompEntry *tab_de);

void build_decompose_table(FILE *f)
{
    int i, array_len, code_max, data_len, count;
    DecompEntry *tab_de, de_s, *de = &de_s;
    uint8_t *data_buf;
    
    code_max = CHARCODE_MAX;
    
    tab_de = mallocz((code_max + 2) * sizeof(*tab_de));

    for(i = code_max; i >= 0; i--) {
        find_decomp_run(tab_de, i);
    }

    /* build the data buffer */
    data_buf = malloc(100000);
    data_len = 0;
    array_len = 0;
    for(i = 0; i <= code_max; i++) {
        de = &tab_de[i];
        if (de->len != 0) {
            add_decomp_data(data_buf, &data_len, de);
            i += de->len - 1;
            array_len++;
        }
    }

#ifdef DUMP_DECOMP_TABLE
    /* dump */
    {
        int size, size1;
        
        printf("START LEN   TYPE  L C SIZE\n");
        size = 0;
        for(i = 0; i <= code_max; i++) {
            de = &tab_de[i];
            if (de->len != 0) {
                size1 = get_decomp_run_size(de);
                printf("%05x %3d %6s %2d %1d %4d\n", i, de->len,
                       decomp_type_str[de->type], de->c_len,
                       unicode_db[i].is_compat, size1);
                i += de->len - 1;
                size += size1;
            }
        }
        
        printf("array_len=%d estimated size=%d bytes actual=%d bytes\n",
               array_len, size, array_len * 6 + data_len);
    }
#endif

    fprintf(f, "static const uint32_t unicode_decomp_table1[%u] = {",
            array_len);
    count = 0;
    for(i = 0; i <= code_max; i++) {
        de = &tab_de[i];
        if (de->len != 0) {
            uint32_t v;
            if (count++ % 4 == 0)
                fprintf(f, "\n   ");
            v = (de->code << (32 - 18)) |
                (de->len << (32 - 18 - 7)) |
                (de->type << (32 - 18 - 7 - 6)) |
                unicode_db[de->code].is_compat;
            fprintf(f, " 0x%08x,", v);
            i += de->len - 1;
        }
    }
    fprintf(f, "\n};\n\n");

    fprintf(f, "static const uint16_t unicode_decomp_table2[%u] = {",
            array_len);
    count = 0;
    for(i = 0; i <= code_max; i++) {
        de = &tab_de[i];
        if (de->len != 0) {
            if (count++ % 8 == 0)
                fprintf(f, "\n   ");
            fprintf(f, " 0x%04x,", de->data_index);
            i += de->len - 1;
        }
    }
    fprintf(f, "\n};\n\n");
    
    fprintf(f, "static const uint8_t unicode_decomp_data[%u] = {",
            data_len);
    for(i = 0; i < data_len; i++) {
        if (i % 8 == 0)
            fprintf(f, "\n   ");
        fprintf(f, " 0x%02x,", data_buf[i]);
    }
    fprintf(f, "\n};\n\n");

    build_compose_table(f, tab_de);

    free(data_buf);
    
    free(tab_de);
}

typedef struct {
    uint32_t c[2];
    uint32_t p;
} ComposeEntry;

#define COMPOSE_LEN_MAX 10000

static int ce_cmp(const void *p1, const void *p2)
{
    const ComposeEntry *ce1 = p1;
    const ComposeEntry *ce2 = p2;
    int i;

    for(i = 0; i < 2; i++) {
        if (ce1->c[i] < ce2->c[i])
            return -1;
        else if (ce1->c[i] > ce2->c[i])
            return 1;
    }
    return 0;
}

static int get_decomp_pos(const DecompEntry *tab_de, int c)
{
    int i, v, k;
    const DecompEntry *de;
    
    k = 0;
    for(i = 0; i <= CHARCODE_MAX; i++) {
        de = &tab_de[i];
        if (de->len != 0) {
            if (c >= de->code && c < de->code + de->len) {
                v = c - de->code;
                assert(v < 64);
                v |= k << 6;
                assert(v < 65536);
                return v;
            }
            i += de->len - 1;
            k++;
        }
    }
    return -1;
}

void build_compose_table(FILE *f, const DecompEntry *tab_de)
{
    int i, v, tab_ce_len;
    ComposeEntry *ce, *tab_ce;
    
    tab_ce = malloc(sizeof(*tab_ce) * COMPOSE_LEN_MAX);
    tab_ce_len = 0;
    for(i = 0; i <= CHARCODE_MAX; i++) {
        CCInfo *ci = &unicode_db[i];
        if (ci->decomp_len == 2 && !ci->is_compat &&
            !ci->is_excluded) {
            assert(tab_ce_len < COMPOSE_LEN_MAX); 
            ce = &tab_ce[tab_ce_len++];
            ce->c[0] = ci->decomp_data[0];
            ce->c[1] = ci->decomp_data[1];
            ce->p = i;
        }
    }
    qsort(tab_ce, tab_ce_len, sizeof(*tab_ce), ce_cmp);

#if 0
    {
        printf("tab_ce_len=%d\n", tab_ce_len);
        for(i = 0; i < tab_ce_len; i++) {
            ce = &tab_ce[i];
            printf("%05x %05x %05x\n", ce->c[0], ce->c[1], ce->p);
        }
    }
#endif
    
    fprintf(f, "static const uint16_t unicode_comp_table[%u] = {",
            tab_ce_len);
    for(i = 0; i < tab_ce_len; i++) {
        if (i % 8 == 0)
            fprintf(f, "\n   ");
        v = get_decomp_pos(tab_de, tab_ce[i].p);
        if (v < 0) {
            printf("ERROR: entry for c=%04x not found\n",
                   tab_ce[i].p);
            exit(1);
        }
        fprintf(f, " 0x%04x,", v);
    }
    fprintf(f, "\n};\n\n");
    
    free(tab_ce);
}

#ifdef USE_TEST
void check_decompose_table(void)
{
    int c;
    CCInfo *ci;
    int res[UNICODE_DECOMP_LEN_MAX], *ref;
    int len, ref_len, is_compat;

    for(is_compat = 0; is_compat <= 1; is_compat++) {
        for(c = 0; c < CHARCODE_MAX; c++) {
            ci = &unicode_db[c];
            ref_len = ci->decomp_len;
            ref = ci->decomp_data;
            if (!is_compat && ci->is_compat) {
                ref_len = 0;
            }
            len = unicode_decomp_char((uint32_t *)res, c, is_compat);
            if (len != ref_len ||
                tabcmp(res, ref, ref_len) != 0) {
                printf("ERROR c=%05x compat=%d\n", c, is_compat);
                dump_str("res", res, len);
                dump_str("ref", ref, ref_len);
                exit(1);
            }
        }
    }
}

void check_compose_table(void)
{
    int i, p;
    /* XXX: we don't test all the cases */

    for(i = 0; i <= CHARCODE_MAX; i++) {
        CCInfo *ci = &unicode_db[i];
        if (ci->decomp_len == 2 && !ci->is_compat &&
            !ci->is_excluded) {
            p = unicode_compose_pair(ci->decomp_data[0], ci->decomp_data[1]);
            if (p != i) {
                printf("ERROR compose: c=%05x %05x -> %05x ref=%05x\n",
                       ci->decomp_data[0], ci->decomp_data[1], p, i);
                exit(1);
            }
        }
    }
    

}

#endif

#ifdef USE_TEST

void check_str(const char *msg, int num, const int *in_buf, int in_len,
               const int *buf1, int len1,
               const int *buf2, int len2)
{
    if (len1 != len2 || tabcmp(buf1, buf2, len1) != 0) {
        printf("%d: ERROR %s:\n", num, msg);
        dump_str(" in", in_buf, in_len);
        dump_str("res", buf1, len1);
        dump_str("ref", buf2, len2);
        exit(1);
    }
}

void check_cc_table(void)
{
    int cc, cc_ref, c;

    for(c = 0; c <= CHARCODE_MAX; c++) {
        cc_ref = unicode_db[c].combining_class;
        cc = unicode_get_cc(c);
        if (cc != cc_ref) {
            printf("ERROR: c=%04x cc=%d cc_ref=%d\n",
                   c, cc, cc_ref);
            exit(1);
        }
    }
#ifdef PROFILE
    {
        int64_t ti, count;
    
        ti = get_time_ns();
        count = 0;
        /* only do it on meaningful chars */
        for(c = 0x20; c <= 0xffff; c++) {
            cc_ref = unicode_db[c].combining_class;
            cc = unicode_get_cc(c);
            count++;
        }
        ti = get_time_ns() - ti;
        printf("cc time=%0.1f ns/char\n",
               (double)ti / count);
    }
#endif
}

void normalization_test(const char *filename)
{
    FILE *f;
    char line[4096], *p;
    int *in_str, *nfc_str, *nfd_str, *nfkc_str, *nfkd_str;
    int in_len, nfc_len, nfd_len, nfkc_len, nfkd_len;
    int *buf, buf_len, pos;
    
    f = fopen(filename, "rb");
    if (!f) {
        perror(filename);
        exit(1);
    }
    pos = 0;
    for(;;) {
        if (!get_line(line, sizeof(line), f))
            break;
        pos++;
        p = line;
        while (isspace(*p))
            p++;
        if (*p == '#' || *p == '@')
            continue;
        in_str = get_field_str(&in_len, p, 0);
        nfc_str = get_field_str(&nfc_len, p, 1);
        nfd_str = get_field_str(&nfd_len, p, 2);
        nfkc_str = get_field_str(&nfkc_len, p, 3);
        nfkd_str = get_field_str(&nfkd_len, p, 4);

        //        dump_str("in", in_str, in_len);

        buf_len = unicode_normalize((uint32_t **)&buf, (uint32_t *)in_str, in_len, UNICODE_NFD, NULL, NULL);
        check_str("nfd", pos, in_str, in_len, buf, buf_len, nfd_str, nfd_len);
        free(buf);

        buf_len = unicode_normalize((uint32_t **)&buf, (uint32_t *)in_str, in_len, UNICODE_NFKD, NULL, NULL);
        check_str("nfkd", pos, in_str, in_len, buf, buf_len, nfkd_str, nfkd_len);
        free(buf);
        
        buf_len = unicode_normalize((uint32_t **)&buf, (uint32_t *)in_str, in_len, UNICODE_NFC, NULL, NULL);
        check_str("nfc", pos, in_str, in_len, buf, buf_len, nfc_str, nfc_len);
        free(buf);

        buf_len = unicode_normalize((uint32_t **)&buf, (uint32_t *)in_str, in_len, UNICODE_NFKC, NULL, NULL);
        check_str("nfkc", pos, in_str, in_len, buf, buf_len, nfkc_str, nfkc_len);
        free(buf);

        free(in_str);
        free(nfc_str);
        free(nfd_str);
        free(nfkc_str);
        free(nfkd_str);
    }
    fclose(f);
}
#endif

int main(int argc, char **argv)
{
    const char *unicode_db_path, *outfilename;
    char filename[1024];
    
    if (argc < 2) {
        printf("usage: %s unicode_db_path [output_file]\n"
               "\n"
               "If no output_file is given, a self test is done using the current unicode library\n",
               argv[0]);
        exit(1);
    }
    unicode_db_path = argv[1];
    outfilename = NULL;
    if (argc >= 3)
        outfilename = argv[2];

    unicode_db = mallocz(sizeof(unicode_db[0]) * (CHARCODE_MAX + 1));

    snprintf(filename, sizeof(filename), "%s/UnicodeData.txt", unicode_db_path);

    parse_unicode_data(filename);

    snprintf(filename, sizeof(filename), "%s/SpecialCasing.txt", unicode_db_path);
    parse_special_casing(unicode_db, filename);
    
    snprintf(filename, sizeof(filename), "%s/CaseFolding.txt", unicode_db_path);
    parse_case_folding(unicode_db, filename);

    snprintf(filename, sizeof(filename), "%s/CompositionExclusions.txt", unicode_db_path);
    parse_composition_exclusions(filename);
    
    snprintf(filename, sizeof(filename), "%s/DerivedCoreProperties.txt", unicode_db_path);
    parse_derived_core_properties(filename);

    snprintf(filename, sizeof(filename), "%s/DerivedNormalizationProps.txt", unicode_db_path);
    parse_derived_norm_properties(filename);

    snprintf(filename, sizeof(filename), "%s/PropList.txt", unicode_db_path);
    parse_prop_list(filename);

    snprintf(filename, sizeof(filename), "%s/Scripts.txt", unicode_db_path);
    parse_scripts(filename);

    snprintf(filename, sizeof(filename), "%s/ScriptExtensions.txt",
             unicode_db_path);
    parse_script_extensions(filename);
                        
    snprintf(filename, sizeof(filename), "%s/emoji-data.txt",
             unicode_db_path);
    parse_prop_list(filename);

    //    dump_data(unicode_db);

    build_conv_table(unicode_db);
    
    //    dump_table();

    if (!outfilename) {
#ifdef USE_TEST
        check_case_conv();
        check_flags();
        check_decompose_table();
        check_compose_table();
        check_cc_table();
        snprintf(filename, sizeof(filename), "%s/NormalizationTest.txt", unicode_db_path);
        normalization_test(filename);
#else
        fprintf(stderr, "Tests are not compiled\n");
        exit(1);
#endif
    } else
    {
        FILE *fo = fopen(outfilename, "wb");
        
        if (!fo) {
            perror(outfilename);
            exit(1);
        }
        fprintf(fo,
                "/* Compressed unicode tables */\n"
                "/* Automatically generated file - do not edit */\n"
                "\n"
                "#include <stdint.h>\n"
                "\n");
        dump_case_conv_table(fo);
        compute_internal_props();
        build_flags_tables(fo);
        fprintf(fo, "#ifdef CONFIG_ALL_UNICODE\n\n");
        build_cc_table(fo);
        build_decompose_table(fo);
        build_general_category_table(fo);
        build_script_table(fo);
        build_script_ext_table(fo);
        build_prop_list_table(fo);
        fprintf(fo, "#endif /* CONFIG_ALL_UNICODE */\n");
        fclose(fo);
    }
    return 0;
}

'''
'''--- unicode_gen_def.h ---
#ifdef UNICODE_GENERAL_CATEGORY
DEF(Cn, "Unassigned") /* must be zero */
DEF(Lu, "Uppercase_Letter")
DEF(Ll, "Lowercase_Letter")
DEF(Lt, "Titlecase_Letter")
DEF(Lm, "Modifier_Letter")
DEF(Lo, "Other_Letter")
DEF(Mn, "Nonspacing_Mark")
DEF(Mc, "Spacing_Mark")
DEF(Me, "Enclosing_Mark")
DEF(Nd, "Decimal_Number,digit")
DEF(Nl, "Letter_Number")
DEF(No, "Other_Number")
DEF(Sm, "Math_Symbol")
DEF(Sc, "Currency_Symbol")
DEF(Sk, "Modifier_Symbol")
DEF(So, "Other_Symbol")
DEF(Pc, "Connector_Punctuation")
DEF(Pd, "Dash_Punctuation")
DEF(Ps, "Open_Punctuation")
DEF(Pe, "Close_Punctuation")
DEF(Pi, "Initial_Punctuation")
DEF(Pf, "Final_Punctuation")
DEF(Po, "Other_Punctuation")
DEF(Zs, "Space_Separator")
DEF(Zl, "Line_Separator")
DEF(Zp, "Paragraph_Separator")
DEF(Cc, "Control,cntrl")
DEF(Cf, "Format")
DEF(Cs, "Surrogate")
DEF(Co, "Private_Use")
/* synthetic properties */
DEF(LC, "Cased_Letter")
DEF(L, "Letter")
DEF(M, "Mark,Combining_Mark")
DEF(N, "Number")
DEF(S, "Symbol")
DEF(P, "Punctuation,punct")
DEF(Z, "Separator")
DEF(C, "Other")
#endif

#ifdef UNICODE_SCRIPT
/* scripts aliases names in PropertyValueAliases.txt */
DEF(Unknown, "Zzzz")
DEF(Adlam, "Adlm")
DEF(Ahom, "Ahom")
DEF(Anatolian_Hieroglyphs, "Hluw")
DEF(Arabic, "Arab")
DEF(Armenian, "Armn")
DEF(Avestan, "Avst")
DEF(Balinese, "Bali")
DEF(Bamum, "Bamu")
DEF(Bassa_Vah, "Bass")
DEF(Batak, "Batk")
DEF(Bengali, "Beng")
DEF(Bhaiksuki, "Bhks")
DEF(Bopomofo, "Bopo")
DEF(Brahmi, "Brah")
DEF(Braille, "Brai")
DEF(Buginese, "Bugi")
DEF(Buhid, "Buhd")
DEF(Canadian_Aboriginal, "Cans")
DEF(Carian, "Cari")
DEF(Caucasian_Albanian, "Aghb")
DEF(Chakma, "Cakm")
DEF(Cham, "Cham")
DEF(Cherokee, "Cher")
DEF(Chorasmian, "Chrs")
DEF(Common, "Zyyy")
DEF(Coptic, "Copt,Qaac")
DEF(Cuneiform, "Xsux")
DEF(Cypriot, "Cprt")
DEF(Cyrillic, "Cyrl")
DEF(Cypro_Minoan, "Cpmn")
DEF(Deseret, "Dsrt")
DEF(Devanagari, "Deva")
DEF(Dives_Akuru, "Diak")
DEF(Dogra, "Dogr")
DEF(Duployan, "Dupl")
DEF(Egyptian_Hieroglyphs, "Egyp")
DEF(Elbasan, "Elba")
DEF(Elymaic, "Elym")
DEF(Ethiopic, "Ethi")
DEF(Georgian, "Geor")
DEF(Glagolitic, "Glag")
DEF(Gothic, "Goth")
DEF(Grantha, "Gran")
DEF(Greek, "Grek")
DEF(Gujarati, "Gujr")
DEF(Gunjala_Gondi, "Gong")
DEF(Gurmukhi, "Guru")
DEF(Han, "Hani")
DEF(Hangul, "Hang")
DEF(Hanifi_Rohingya, "Rohg")
DEF(Hanunoo, "Hano")
DEF(Hatran, "Hatr")
DEF(Hebrew, "Hebr")
DEF(Hiragana, "Hira")
DEF(Imperial_Aramaic, "Armi")
DEF(Inherited, "Zinh,Qaai")
DEF(Inscriptional_Pahlavi, "Phli")
DEF(Inscriptional_Parthian, "Prti")
DEF(Javanese, "Java")
DEF(Kaithi, "Kthi")
DEF(Kannada, "Knda")
DEF(Katakana, "Kana")
DEF(Kayah_Li, "Kali")
DEF(Kharoshthi, "Khar")
DEF(Khmer, "Khmr")
DEF(Khojki, "Khoj")
DEF(Khitan_Small_Script, "Kits")
DEF(Khudawadi, "Sind")
DEF(Lao, "Laoo")
DEF(Latin, "Latn")
DEF(Lepcha, "Lepc")
DEF(Limbu, "Limb")
DEF(Linear_A, "Lina")
DEF(Linear_B, "Linb")
DEF(Lisu, "Lisu")
DEF(Lycian, "Lyci")
DEF(Lydian, "Lydi")
DEF(Makasar, "Maka")
DEF(Mahajani, "Mahj")
DEF(Malayalam, "Mlym")
DEF(Mandaic, "Mand")
DEF(Manichaean, "Mani")
DEF(Marchen, "Marc")
DEF(Masaram_Gondi, "Gonm")
DEF(Medefaidrin, "Medf")
DEF(Meetei_Mayek, "Mtei")
DEF(Mende_Kikakui, "Mend")
DEF(Meroitic_Cursive, "Merc")
DEF(Meroitic_Hieroglyphs, "Mero")
DEF(Miao, "Plrd")
DEF(Modi, "Modi")
DEF(Mongolian, "Mong")
DEF(Mro, "Mroo")
DEF(Multani, "Mult")
DEF(Myanmar, "Mymr")
DEF(Nabataean, "Nbat")
DEF(Nandinagari, "Nand")
DEF(New_Tai_Lue, "Talu")
DEF(Newa, "Newa")
DEF(Nko, "Nkoo")
DEF(Nushu, "Nshu")
DEF(Nyiakeng_Puachue_Hmong, "Hmnp")
DEF(Ogham, "Ogam")
DEF(Ol_Chiki, "Olck")
DEF(Old_Hungarian, "Hung")
DEF(Old_Italic, "Ital")
DEF(Old_North_Arabian, "Narb")
DEF(Old_Permic, "Perm")
DEF(Old_Persian, "Xpeo")
DEF(Old_Sogdian, "Sogo")
DEF(Old_South_Arabian, "Sarb")
DEF(Old_Turkic, "Orkh")
DEF(Old_Uyghur, "Ougr")
DEF(Oriya, "Orya")
DEF(Osage, "Osge")
DEF(Osmanya, "Osma")
DEF(Pahawh_Hmong, "Hmng")
DEF(Palmyrene, "Palm")
DEF(Pau_Cin_Hau, "Pauc")
DEF(Phags_Pa, "Phag")
DEF(Phoenician, "Phnx")
DEF(Psalter_Pahlavi, "Phlp")
DEF(Rejang, "Rjng")
DEF(Runic, "Runr")
DEF(Samaritan, "Samr")
DEF(Saurashtra, "Saur")
DEF(Sharada, "Shrd")
DEF(Shavian, "Shaw")
DEF(Siddham, "Sidd")
DEF(SignWriting, "Sgnw")
DEF(Sinhala, "Sinh")
DEF(Sogdian, "Sogd")
DEF(Sora_Sompeng, "Sora")
DEF(Soyombo, "Soyo")
DEF(Sundanese, "Sund")
DEF(Syloti_Nagri, "Sylo")
DEF(Syriac, "Syrc")
DEF(Tagalog, "Tglg")
DEF(Tagbanwa, "Tagb")
DEF(Tai_Le, "Tale")
DEF(Tai_Tham, "Lana")
DEF(Tai_Viet, "Tavt")
DEF(Takri, "Takr")
DEF(Tamil, "Taml")
DEF(Tangut, "Tang")
DEF(Telugu, "Telu")
DEF(Thaana, "Thaa")
DEF(Thai, "Thai")
DEF(Tibetan, "Tibt")
DEF(Tifinagh, "Tfng")
DEF(Tirhuta, "Tirh")
DEF(Tangsa, "Tnsa")
DEF(Toto, "Toto")
DEF(Ugaritic, "Ugar")
DEF(Vai, "Vaii")
DEF(Vithkuqi, "Vith")
DEF(Wancho, "Wcho")
DEF(Warang_Citi, "Wara")
DEF(Yezidi, "Yezi")
DEF(Yi, "Yiii")
DEF(Zanabazar_Square, "Zanb")
#endif

#ifdef UNICODE_PROP_LIST
/* Prop list not exported to regexp */
DEF(Hyphen, "")
DEF(Other_Math, "")
DEF(Other_Alphabetic, "")
DEF(Other_Lowercase, "")
DEF(Other_Uppercase, "")
DEF(Other_Grapheme_Extend, "")
DEF(Other_Default_Ignorable_Code_Point, "")
DEF(Other_ID_Start, "")
DEF(Other_ID_Continue, "")
DEF(Prepended_Concatenation_Mark, "")
/* additional computed properties for smaller tables */
DEF(ID_Continue1, "")
DEF(XID_Start1, "")
DEF(XID_Continue1, "")
DEF(Changes_When_Titlecased1, "")
DEF(Changes_When_Casefolded1, "")
DEF(Changes_When_NFKC_Casefolded1, "")

/* Prop list exported to JS */
DEF(ASCII_Hex_Digit, "AHex")
DEF(Bidi_Control, "Bidi_C")
DEF(Dash, "")
DEF(Deprecated, "Dep")
DEF(Diacritic, "Dia")
DEF(Extender, "Ext")
DEF(Hex_Digit, "Hex")
DEF(IDS_Binary_Operator, "IDSB")
DEF(IDS_Trinary_Operator, "IDST")
DEF(Ideographic, "Ideo")
DEF(Join_Control, "Join_C")
DEF(Logical_Order_Exception, "LOE")
DEF(Noncharacter_Code_Point, "NChar")
DEF(Pattern_Syntax, "Pat_Syn")
DEF(Pattern_White_Space, "Pat_WS")
DEF(Quotation_Mark, "QMark")
DEF(Radical, "")
DEF(Regional_Indicator, "RI")
DEF(Sentence_Terminal, "STerm")
DEF(Soft_Dotted, "SD")
DEF(Terminal_Punctuation, "Term")
DEF(Unified_Ideograph, "UIdeo")
DEF(Variation_Selector, "VS")
DEF(White_Space, "space")
DEF(Bidi_Mirrored, "Bidi_M")
DEF(Emoji, "")
DEF(Emoji_Component, "EComp")
DEF(Emoji_Modifier, "EMod")
DEF(Emoji_Modifier_Base, "EBase")
DEF(Emoji_Presentation, "EPres")
DEF(Extended_Pictographic, "ExtPict")
DEF(Default_Ignorable_Code_Point, "DI")
DEF(ID_Start, "IDS")
DEF(Case_Ignorable, "CI")

/* other binary properties */
DEF(ASCII,"")
DEF(Alphabetic, "Alpha")
DEF(Any, "")
DEF(Assigned,"")
DEF(Cased, "")
DEF(Changes_When_Casefolded, "CWCF")
DEF(Changes_When_Casemapped, "CWCM")
DEF(Changes_When_Lowercased, "CWL")
DEF(Changes_When_NFKC_Casefolded, "CWKCF")
DEF(Changes_When_Titlecased, "CWT")
DEF(Changes_When_Uppercased, "CWU")
DEF(Grapheme_Base, "Gr_Base")
DEF(Grapheme_Extend, "Gr_Ext")
DEF(ID_Continue, "IDC")
DEF(Lowercase, "Lower")
DEF(Math, "")
DEF(Uppercase, "Upper")
DEF(XID_Continue, "XIDC")
DEF(XID_Start, "XIDS")

/* internal tables with index */
DEF(Cased1, "")

#endif

'''
'''--- wasmlib/build.sh ---
(cd .. && make libquickjs.a)
emcc -I../ libjseval.c -c
emar rcs libjseval.a libjseval.o
emcc -g -s STANDALONE_WASM --no-entry wasmlib.c libjseval.a ../libquickjs.a -o jseval.wasm
wasm-opt -Oz jseval.wasm -o jseval.wasm
cp jseval.wasm ../web/compiler/
'''
'''--- wasmlib/libjseval.c ---
#include "./quickjs.h"
#include <string.h>

JSValue global_obj;
JSRuntime *rt = NULL;
JSContext *ctx;

static JSValue js_print(JSContext *ctx, JSValueConst this_val,
                        int argc, JSValueConst *argv)
{
    int i;
    const char *str;
    size_t len;

    for (i = 0; i < argc; i++)
    {
        if (i != 0)
            putchar(' ');
        str = JS_ToCStringLen(ctx, &len, argv[i]);
        if (!str)
            return JS_EXCEPTION;
        fwrite(str, 1, len, stdout);
        JS_FreeCString(ctx, str);
    }
    putchar('\n');
    return JS_UNDEFINED;
}

void create_runtime() {
    if (rt != NULL) {
        return;
    }
    rt = JS_NewRuntime();
    ctx = JS_NewContextRaw(rt);
    JS_AddIntrinsicEval(ctx);
    JS_AddIntrinsicBaseObjects(ctx);
    JS_AddIntrinsicDate(ctx);
    JS_AddIntrinsicStringNormalize(ctx);
    JS_AddIntrinsicRegExp(ctx);
    JS_AddIntrinsicJSON(ctx);
    JS_AddIntrinsicProxy(ctx);
    JS_AddIntrinsicMapSet(ctx);
    JS_AddIntrinsicTypedArrays(ctx);
    JS_AddIntrinsicBigInt(ctx);

    global_obj = JS_GetGlobalObject(ctx);
    JS_SetPropertyStr(ctx, global_obj, "print",
                      JS_NewCFunction(ctx, js_print, "print", 1));
}

int js_eval(const char *filename, const char *source, int module)
{
    create_runtime();

    int len = strlen(source);

    JSValue val = JS_Eval(ctx,
                          source,
                          len,
                          filename,
                          (module == 1 ? JS_EVAL_TYPE_MODULE : JS_EVAL_TYPE_GLOBAL));

    if (JS_IsException(val) || JS_IsError(ctx, val))
    {
        printf("%s\n", JS_ToCString(ctx, JS_GetException(ctx)));
    }
    return JS_VALUE_GET_INT(val);
}

uint8_t *js_compile_to_bytecode(const char *filename, const char *source, size_t *out_buf_len, int module)
{
    create_runtime();

    int len = strlen(source);

    JSValue obj = JS_Eval(ctx,
                          source,
                          len,
                          filename,
                          JS_EVAL_FLAG_COMPILE_ONLY | (module == 1 ? JS_EVAL_TYPE_MODULE : JS_EVAL_TYPE_GLOBAL));

    if (JS_IsException(obj))
    {
        printf("%s\n", JS_ToCString(ctx, JS_GetException(ctx)));
    }
    return JS_WriteObject(ctx, out_buf_len, obj, JS_WRITE_OBJ_BYTECODE);
}

int js_eval_bytecode(const uint8_t *buf, size_t buf_len)
{
    create_runtime();

    JSValue obj, val;
    obj = JS_ReadObject(ctx, buf, buf_len, JS_READ_OBJ_BYTECODE);
    val = JS_EvalFunction(ctx, obj);
    if (JS_IsException(val))
    {
        printf("%s\n", JS_ToCString(ctx, JS_GetException(ctx)));
    }
    return JS_VALUE_GET_INT(val);
}

'''
'''--- wasmlib/wasmlib.c ---
#include <emscripten.h>

extern int js_eval(char * filename, char *source, int module);
extern int js_eval_bytecode(const char *buf, unsigned long buf_len);
extern unsigned long js_compile_to_bytecode(char * filename, char *source, unsigned long *buf_len, int module);

int EMSCRIPTEN_KEEPALIVE eval_js_source(char *filename, char *source, int module)
{
    return js_eval(filename, source, module);
}

unsigned long EMSCRIPTEN_KEEPALIVE compile_to_bytecode(char *filename, char *source, unsigned long *buf_len, int module)
{
    return js_compile_to_bytecode(filename, source, buf_len, module);
}

int EMSCRIPTEN_KEEPALIVE eval_js_bytecode(const char *buf, unsigned long buf_len)
{
    return js_eval_bytecode(buf, buf_len);
}

'''
'''--- web/app.component.css ---
div.container {
    max-width: 1024px;
    padding: 20px;
    margin: auto;
}

mwc-drawer[open] top-app-bar {
    /* Default width of drawer is 256px. See CSS Custom Properties below */
    --mdc-top-app-bar-width: calc(100% - var(--mdc-drawer-width, 256px));
}
'''
'''--- web/app.component.html ---
<mwc-drawer hasHeader type="modal">
    <span slot="title">NEAR JS</span>
    <span slot="subtitle" id="loggedinuserspan"></span>
    <div class="drawer-content">
      <mwc-list activatable id="leftmenu">
        <mwc-list-item id="code-menuitem" selected activated onclick="goToPage('code')">Code</mwc-list-item>
        <mwc-list-item id="callcontract-menuitem" onclick="goToPage('callcontract')">Call contract</mwc-list-item>
        <template id="logout-menuitem-template">
            <mwc-list-item id="logout-menuitem" graphic="avatar" icon="logout">
                <span>Logout</span>
                <mwc-icon slot="graphic">logout</mwc-icon>
            </mwc-list-item>
        </template>
        <template id="login-menuitem-template">
            <mwc-list-item id="login-menuitem" graphic="avatar" icon="login">
                <span>Login</span>
                <mwc-icon slot="graphic">login</mwc-icon>
            </mwc-list-item>
        </template>
      </mwc-list>
    </div>
    <div slot="appContent">
        <mwc-top-app-bar>
            <mwc-icon-button icon="menu" slot="navigationIcon" id="toggleDrawerButton"></mwc-icon-button>
            <div slot="title"></div>
            
            <div class="container" id="mainContainer">
                <h1>Javascript smart contracts on NEAR</h1>
                <p>
                    <a href="https://github.com/near/near-sdk-js" target="_blank">near-sdk-js</a> makes it possible to deploy Javascript smart contracts on <a href="https://near.org" target="_blank">NEAR protocol</a>.
                    This web application let you write, simulate, deploy and call your javascript smart contracts in the web browser.                    
                </p>
                <p>
                    Note: Currently you can only create low-level ( <a href="https://github.com/near/near-sdk-js/tree/master/examples/low-level" target="_blank">see examples here</a> ) contracts from here.
                </p>
                <p>Open the menu to edit code for your Javascript contract, deploy, or call it on-chain.</p>
            </div>
        </mwc-top-app-bar>
    </div>
</mwc-drawer>
'''
'''--- web/app.component.js ---
import '@material/mwc-top-app-bar';
import '@material/mwc-icon-button';
import '@material/mwc-button';
import '@material/mwc-dialog';
import '@material/mwc-drawer';
import '@material/mwc-list';
import '@material/mwc-textfield';
import '@material/mwc-select';
import '@material/mwc-snackbar';
import './code-editor/code-page.component.js';
import './callcontract/callcontract-page.component.js';

import { setAppComponent, toggleIndeterminateProgress } from './common/progressindicator.js';
import { getNearConfig, createWalletConnection, checkSignedin, logout, clearWalletConnection } from './near/near.js';

HTMLElement.prototype.attachStyleSheet = function (url) {
    const linkElement = document.createElement('link');
    linkElement.rel = 'stylesheet';
    linkElement.href = url;
    this.shadowRoot.appendChild(linkElement);
};

class AppComponent extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.loadHTML();
    }

    async loadHTML() {
        this.shadowRoot.innerHTML = await fetch(new URL('app.component.html', import.meta.url)).then(r => r.text());
        this.attachStyleSheet(new URL('app.component.css', import.meta.url));
        setAppComponent(this);
        toggleIndeterminateProgress(true);
        const drawer = this.shadowRoot.querySelector('mwc-drawer');
        this.shadowRoot.querySelector('#toggleDrawerButton').addEventListener('click', () => {
            drawer.open = !drawer.open;
        });
        const widthmatcher = window.matchMedia("(max-width: 700px)");
        widthmatcher.addEventListener('change', e => {
            if (e.matches) {
                drawer.type = 'modal';
            } else {
                drawer.type = 'dismissible';
                drawer.open = true;
            }
        });
        if (!widthmatcher.matches) {
            drawer.type = 'dismissible';
            drawer.open = true;
        }
        const mainContainer = this.shadowRoot.querySelector('#mainContainer')
        window.goToPage = (page) => {
            const pageElement = document.createElement(`${page}-page`);
            mainContainer.replaceChildren(pageElement);
            if (widthmatcher.matches) {
                drawer.open = false;
            }
        }

        const accountId = (await createWalletConnection()).account().accountId;
        const loggedInUserSpan = this.shadowRoot.getElementById('loggedinuserspan');
        const logoutMenuItemTemplate = this.shadowRoot.getElementById('logout-menuitem-template');
        const loginMenuItemTemplate = this.shadowRoot.getElementById('login-menuitem-template');
        const leftmenu = this.shadowRoot.getElementById('leftmenu');

        const showNotLoggedIn = () => {
            loggedInUserSpan.innerHTML = '';
            const loginMenuItem = leftmenu.appendChild(loginMenuItemTemplate.content.firstElementChild.cloneNode(true));
            loginMenuItem.addEventListener('click', () => checkSignedin());
        };
        if (accountId) {
            loggedInUserSpan.innerHTML =
                `${accountId ?? ''} @ ${getNearConfig().contractName}`;
            logoutMenuItemTemplate.content.cloneNode(true)
            const logoutMenuItem = leftmenu.appendChild(logoutMenuItemTemplate.content.firstElementChild.cloneNode(true));
            logoutMenuItem.addEventListener('click', async () => {
                logoutMenuItem.remove();                
                showNotLoggedIn();
                await logout();
            });
        } else {
            showNotLoggedIn();
        }
        if (location.search.indexOf('transactionHashes=') > 0) {
            goToPage('callcontract');
            this.shadowRoot.getElementById('callcontract-menuitem').selected = true;
        }
        toggleIndeterminateProgress(false);
    }
}

customElements.define('app-root', AppComponent);
'''
'''--- web/app.component.spec.js ---
import './app.component.js';
import { clearWalletConnection } from './near/near.js';

describe('app-component', () => {
    it('should show the logout button if logged in', async () => {
        localStorage.setItem('undefined_wallet_auth_key', '{"accountId":"psalomo.testnet","allKeys":["ed25519:eNRiyM1MhKyM3bof1XvAEoLfP75YgY8D3EbKfa1yMxb"]}');
        localStorage.setItem('near-api-js:keystore:psalomo.testnet:testnet', 'ed25519:QVuKCUH8AHt6WqxFnsjbaR8pSdjJBXAsnwfB83C5dgsmCMEP6EAmfULWm6bXWNQXCecGcsv2ATBeJKjJjFdEooG');
        clearWalletConnection();
        const appRootElement = document.createElement('app-root');
        document.documentElement.appendChild(appRootElement);

        const logoutMenuItem = await new Promise(resolve => {
            const observer = new MutationObserver((mutationsList, observer) => {
                const logoutMenuItemElement = appRootElement.shadowRoot.querySelector('#logout-menuitem');
                if (logoutMenuItemElement) {
                    observer.disconnect();
                    resolve(logoutMenuItemElement);
                }
            });
            observer.observe(appRootElement.shadowRoot, {
                childList: true,
                subtree: true,
                attributes: true
            });
        });
        expect(logoutMenuItem).not.to.be.undefined;
        expect(appRootElement.shadowRoot.querySelector('#login-menuitem')).to.be.null;
        document.documentElement.removeChild(appRootElement);
    });
    it('should display the login button if not logged in', async () => {
        localStorage.removeItem('undefined_wallet_auth_key');
        clearWalletConnection();
        const appRootElement = document.createElement('app-root');
        document.documentElement.appendChild(appRootElement);
        const loginMenuItem = await new Promise(resolve => {
            const observer = new MutationObserver((mutationsList, observer) => {
                const loginMenuItemElement = appRootElement.shadowRoot.querySelector('#login-menuitem');
                if (loginMenuItemElement) {
                    observer.disconnect();
                    resolve(loginMenuItemElement);
                }
            });
            observer.observe(appRootElement.shadowRoot, {
                childList: true,
                subtree: true,
                attributes: true
            });
        });
        expect(loginMenuItem).not.to.be.undefined;
        expect(appRootElement.shadowRoot.querySelector('#logout-menuitem')).to.be.null;
        document.documentElement.removeChild(appRootElement);
    });
    it('should logout if clicking logout button', async () => {
        localStorage.setItem('undefined_wallet_auth_key', '{"accountId":"psalomo.testnet","allKeys":["ed25519:eNRiyM1MhKyM3bof1XvAEoLfP75YgY8D3EbKfa1yMxb"]}');
        localStorage.setItem('near-api-js:keystore:psalomo.testnet:testnet', 'ed25519:QVuKCUH8AHt6WqxFnsjbaR8pSdjJBXAsnwfB83C5dgsmCMEP6EAmfULWm6bXWNQXCecGcsv2ATBeJKjJjFdEooG');
        clearWalletConnection();
        const appRootElement = document.createElement('app-root');
        document.documentElement.appendChild(appRootElement);

        const logoutMenuItem = await new Promise(resolve => {
            const observer = new MutationObserver((mutationsList, observer) => {
                const logoutMenuItemElement = appRootElement.shadowRoot.querySelector('#logout-menuitem');
                if (logoutMenuItemElement) {
                    observer.disconnect();
                    resolve(logoutMenuItemElement);
                }
            });
            observer.observe(appRootElement.shadowRoot, {
                childList: true,
                subtree: true,
                attributes: true
            });
        });
        expect(logoutMenuItem).not.to.be.undefined;

        logoutMenuItem.click();
        await new Promise(resolve => {
            const observer = new MutationObserver((mutationsList, observer) => {
                if (appRootElement.shadowRoot.querySelector('#logout-menuitem')==null) {
                    observer.disconnect();
                    resolve();
                }
            });
            observer.observe(appRootElement.shadowRoot, {
                childList: true,
                subtree: true,
                attributes: true
            });
        });
        while(localStorage.getItem('undefined_wallet_auth_key')) {
            await new Promise(r => setTimeout(r, 0));
        }
        expect(localStorage.getItem('undefined_wallet_auth_key')).to.be.null;
        expect(appRootElement.shadowRoot.querySelector('#logout-menuitem')).to.be.null;
        expect(appRootElement.shadowRoot.querySelector('#login-menuitem')).not.to.be.null;        
        
        document.documentElement.removeChild(appRootElement);
    });
});
'''
'''--- web/callcontract/callcontract-page.component.css ---
.outputarea {
    background-color: #eef;
    width: 100%;
    padding: 10px;
}

'''
'''--- web/callcontract/callcontract-page.component.html ---
<h3>Call contract on-chain</h3>
<p>
    <mwc-textfield label="Contract name" id="contractnameinput"></mwc-textfield>
    <mwc-textfield label="Method name" id="methodnameinput"></mwc-textfield>
    <mwc-textfield label="arguments (JSON)" id="argsinput"></mwc-textfield>
    <mwc-textfield id="depositinput" label="attached deposit" type="number"></mwc-textfield>
</p>
<p>
    <mwc-button raised id="callcontractbutton">Call contract</mwc-button>
</p>
<h3>Contract output</h3>
<p>

<div class="outputarea">
    <pre style="white-space: pre-wrap;"><code id="contractoutput">

                    </code></pre>
</div>
</p>
'''
'''--- web/callcontract/callcontract-page.component.js ---
import { callJSContract, getNearConfig, createWalletConnection } from '../near/near.js';
import { toggleIndeterminateProgress } from '../common/progressindicator.js';

class CallContractPageComponent extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({mode: 'open'});        
        this.loadHTML();
    }

    async loadHTML() {
        this.shadowRoot.innerHTML = await fetch(new URL('callcontract-page.component.html', import.meta.url)).then(r => r.text());
        this.attachStyleSheet(new URL('callcontract-page.component.css', import.meta.url));
        const callcontractbutton = this.shadowRoot.getElementById('callcontractbutton');
        const contractnameinput = this.shadowRoot.getElementById('contractnameinput');

        const methodnameinput = this.shadowRoot.getElementById('methodnameinput');
        const argsinput = this.shadowRoot.getElementById('argsinput');
        const contractOutputArea = this.shadowRoot.querySelector('#contractoutput');
        callcontractbutton.addEventListener('click', async () => {
            toggleIndeterminateProgress(true);
            try {
                const result = await callJSContract(contractnameinput.value, methodnameinput.value, argsinput.value, this.shadowRoot.querySelector('#depositinput').value);
                contractOutputArea.textContent = `
${result.receipts_outcome.map(r => r.outcome.logs.join('\n')).join('\n')}
${result.status.SuccessValue ? atob(result.status.SuccessValue) : ''}`;
            } catch(e) {
                contractOutputArea.textContent = e.message;
            }
            toggleIndeterminateProgress(false);
        });

        const accountId = (await createWalletConnection()).account().accountId;
        contractnameinput.value = accountId;
        const transactionIdMatch = location.search.match(/transactionHashes=([a-zA-Z0-9]+)/);
        if (transactionIdMatch) {
            const txhash = transactionIdMatch[1];
            const result = (await fetch(getNearConfig().nodeUrl, {
                    method: 'POST',
                    headers: {
                        'content-type': 'application/json'
                    },
                    body: JSON.stringify({
                        "jsonrpc": "2.0",
                        "id": "dontcare",
                        "method": "EXPERIMENTAL_tx_status",
                        "params": [txhash, accountId]
                    })
                }).then(r => r.json())).result;

                contractOutputArea.innerHTML = `${result.receipts_outcome.map(r => r.outcome.logs.join('\n')).join('\n')}\n
${result.status.SuccessValue ? atob(result.status.SuccessValue) : ''}`;
        }
        
    }
}

customElements.define('callcontract-page', CallContractPageComponent)
'''
'''--- web/code-editor/code-editor.component.js ---
import { EditorState, EditorView, basicSetup } from '@codemirror/basic-setup';
import { javascript } from '@codemirror/lang-javascript';
import { indentWithTab } from "@codemirror/commands"
import { keymap } from "@codemirror/view";

const extensions = [basicSetup,
    keymap.of([indentWithTab]),
    javascript()];

class CodeEditor extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.shadowRoot.innerHTML = `
        <style>
            .cm-editor { height: 250px }
        </style>
        <div id="editor"></div>`;
        let state = EditorState.create({
            extensions: extensions
        });
        this.editorView = new EditorView({
            state,
            parent: this.shadowRoot.getElementById('editor')
        });
    }

    set value(val) {
        let state = EditorState.create({
            doc: this.editorView.state.toText(val),
            extensions: extensions
        });
        this.editorView.setState(state);
    }

    get value() {
        return this.editorView.state.doc.toString();
    }
}

customElements.define('code-editor', CodeEditor)
'''
'''--- web/code-editor/code-page.component.css ---
.outputarea {
    background-color: #eef;
    width: 100%;
    padding: 10px;
}

.outputarea pre {
    overflow: auto;
}
'''
'''--- web/code-editor/code-page.component.html ---
<p>
  <code-editor id="sourcecodeeditor"></code-editor>
</p>

<p>
  <mwc-button raised id="savebutton" icon="save">Save</mwc-button>
  <mwc-button raised id="deploybutton">Deploy</mwc-button>
</p>

<h3>Simulation</h3>
<p>
  <mwc-select id="methodselect" label="method"></mwc-select>
  <mwc-textfield id="argumentsinput" label="arguments (JSON)"></mwc-textfield>
  <mwc-textfield id="depositinput" label="attached deposit" type="number"></mwc-textfield>
  <mwc-textfield id="signeraccountidinput" label="signer account id"></mwc-textfield>
</p>
<h4>Storage</h4>
<template id="storageitemtemplate">
  <div>
    <mwc-textfield class="storagekeyinput" label="key"></mwc-textfield>
    <mwc-textfield class="storagevalueinput" label="value"></mwc-textfield>
    <mwc-icon-button icon="delete" slot="navigationIcon" class="deletestorageitembutton"></mwc-icon-button>
  </div>
</template>
<div id="storageitems">

</div>
<mwc-button id="addstorageitembutton" icon="add">Add storage item</mwc-button>
<p>
  <mwc-button raised id="simulatebutton" icon="play_arrow">Run</mwc-button>
<p>

<div class="outputarea">
  <pre>
      <code id="simulationoutput">

      </code>
    </pre>
</div>

<mwc-dialog id="deploy-contract-dialog" heading="Deploy contract?">
  <div>This will overwrite the existing contract.</div>
  <mwc-button slot="primaryAction" dialogAction="deploy">
    Deploy
  </mwc-button>
  <mwc-button slot="secondaryAction" dialogAction="cancel">
    Cancel
  </mwc-button>
</mwc-dialog>

<mwc-dialog id="error-deploying-contract-dialog" heading="Error deploying contract">
  <div id="errormessage"></div>
  <mwc-button slot="primaryAction" dialogAction="dismiss">
    Close
  </mwc-button>
</mwc-dialog>

<mwc-snackbar id="compileErrorSnackbar" labelText="Compile error. See simulation output">
  <mwc-icon-button icon="close" slot="dismiss"></mwc-icon-button>
</mwc-snackbar>

<mwc-snackbar id="selectMethodSnackbar" labelText="Select method for running">
  <mwc-icon-button icon="close" slot="dismiss"></mwc-icon-button>
</mwc-snackbar>

<mwc-snackbar id="successDeploySnackbar" labelText="Successfully deployed contract">
  <mwc-icon-button icon="close" slot="dismiss"></mwc-icon-button>
</mwc-snackbar>
'''
'''--- web/code-editor/code-page.component.js ---
import './code-editor.component.js';
import { deployJScontract, getSuggestedDepositForContract } from '../near/near.js';
import { createQuickJS } from '../compiler/quickjs.js'
import { toggleIndeterminateProgress } from '../common/progressindicator.js';
import { createQuickJSWithNearEnv } from '../compiler/nearenv.js';

class CodePageComponent extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({ mode: 'open' });
        this.loadHTML();
    }

    async loadHTML() {
        this.shadowRoot.innerHTML = await fetch(new URL('code-page.component.html', import.meta.url)).then(r => r.text());
        this.attachStyleSheet(new URL('code-page.component.css', import.meta.url));

        const sourcecodeeditor = this.shadowRoot.getElementById('sourcecodeeditor');
        this.sourcecodeeditor = sourcecodeeditor;
        const lastSavedSourceCode = localStorage.getItem('lastSavedSourceCode');
        sourcecodeeditor.value = lastSavedSourceCode ? lastSavedSourceCode : `export function hello() {
            env.log("Hello Near");
        }`;

        const savebutton = this.shadowRoot.getElementById('savebutton');
        savebutton.addEventListener('click', () => this.save());
        const deploybutton = this.shadowRoot.getElementById('deploybutton');

        deploybutton.addEventListener('click', async () => {
            const deployContractDialog = this.shadowRoot.getElementById('deploy-contract-dialog');
            deployContractDialog.setAttribute('open', 'true');
            if (await new Promise(resolve => {
                deployContractDialog.querySelectorAll('mwc-button').forEach(b => b.addEventListener('click', (e) => {
                    resolve(e.target.getAttribute('dialogaction'));
                }))
            }) == 'deploy') {
                toggleIndeterminateProgress(true);
                await this.save();
                const bytecode = (await createQuickJS()).compileToByteCode(sourcecodeeditor.value, 'contract');
                const deployContract = async (deposit = undefined) => {
                    try {
                        console.log('deploy contract with deposit', deposit);
                        await deployJScontract(bytecode, deposit);
                        toggleIndeterminateProgress(false);
                        this.shadowRoot.querySelector('#successDeploySnackbar').show();
                    } catch(e) {
                        console.error(e);
                        if (e.message.indexOf('insufficient deposit for storage')>=0) {
                            await deployContract(getSuggestedDepositForContract(bytecode.length));
                        } else {
                            const errorDeployContractDialog = this.shadowRoot.getElementById('error-deploying-contract-dialog');                            
                            errorDeployContractDialog.querySelector('#errormessage').textContent = e.message;
                            errorDeployContractDialog.setAttribute('open', 'true');
                            toggleIndeterminateProgress(false);
                        }
                    }
                };
                await deployContract();
            }
        });

        const addstorageitembutton = this.shadowRoot.getElementById('addstorageitembutton');
        const storageitemsdiv = this.shadowRoot.getElementById('storageitems');
        const addStorageItem = (key = '', val = '') => {
            const storageitemtemplate = this.shadowRoot.getElementById('storageitemtemplate');
            storageitemsdiv.appendChild(storageitemtemplate.content.cloneNode(true));
            const storageitem = storageitemsdiv.lastElementChild;
            storageitem.querySelector('.deletestorageitembutton').addEventListener('click', () => storageitem.remove());
            storageitem.querySelector('.storagekeyinput').value = key;
            storageitem.querySelector('.storagevalueinput').value = val;
        };
        addstorageitembutton.addEventListener('click', () => {
            addStorageItem();
        });

        const getStorageObj = () => [ ...storageitemsdiv.children ].reduce((p, c) => {
            p[c.querySelector('.storagekeyinput').value] = c.querySelector('.storagevalueinput').value;
            return p;
        }, {}); 

        const simulatebutton = this.shadowRoot.getElementById('simulatebutton');
        this.simulationOutputArea = this.shadowRoot.querySelector('#simulationoutput');
        simulatebutton.addEventListener('click', async () => {
            const deposit = this.shadowRoot.querySelector('#depositinput').value;
            const quickjs = await createQuickJSWithNearEnv(
                    this.shadowRoot.querySelector('#argumentsinput').value,
                    deposit ? nearApi.utils.format.parseNearAmount(deposit) : undefined,
                    getStorageObj(),
                    this.shadowRoot.querySelector('#signeraccountidinput').value
                );
            const bytecode = quickjs.compileToByteCode(sourcecodeeditor.value, 'contractmodule');
            quickjs.evalByteCode(bytecode);
            quickjs.stdoutlines = [];
            quickjs.stdoutlines = [];
            const selectedMethod = this.shadowRoot.querySelector('#methodselect').value;
            if (selectedMethod) {
                const runcontractsource = `import { ${selectedMethod} } from 'contractmodule';
    ${selectedMethod}();
    `;
                quickjs.evalSource(runcontractsource, 'runcontract');
                this.simulationOutputArea.textContent = quickjs.stdoutlines.join('\n');
                quickjs.stdoutlines = [];
                quickjs.evalSource('env.print_storage()', 'printstorage');
                const storageAfterRun = JSON.parse(quickjs.stdoutlines[0]);
                storageitemsdiv.replaceChildren([]);
                for (const key in storageAfterRun) {
                    addStorageItem(key, storageAfterRun[key]);
                }
            } else {
                this.shadowRoot.querySelector('#selectMethodSnackbar').show();
            }
        });
    }

    async save() {
        const source = this.sourcecodeeditor.value;
        localStorage.setItem('lastSavedSourceCode', source);
        const methodselect = this.shadowRoot.querySelector('#methodselect');
        const quickjs = await createQuickJS();
        try {
            quickjs.evalSource(source, 'contractmodule');
            quickjs.evalSource(`import * as contract from 'contractmodule';
            print('method names:', Object.keys(contract));`, 'main');
            const methodnames = quickjs.stdoutlines.find(l => l.indexOf('method names:') == 0).substring('method names: '.length).split(',');
            methodselect.querySelectorAll('mwc-list-item').forEach(li => li.remove());
            methodnames.forEach(methodname => {
                const option = document.createElement('mwc-list-item');
                option.innerHTML = methodname;
                option.value = methodname;
                methodselect.appendChild(option);
            });
            this.simulationOutputArea.innerHTML = '';
        } catch (e) {
            this.simulationOutputArea.innerHTML = quickjs.stdoutlines.join('\n');
            const compileErrorSnackbar = this.shadowRoot.querySelector('#compileErrorSnackbar');
            compileErrorSnackbar.show();
        }
    }
}

customElements.define('code-page', CodePageComponent)
'''
'''--- web/common/progressindicator.js ---
import '@material/mwc-linear-progress';

let appComponent;

export function setAppComponent(c) {
    appComponent = c.shadowRoot;
}

export function toggleIndeterminateProgress(state) {
    const alreadyExists = appComponent.querySelector('mwc-linear-progress');
    if (!alreadyExists && state) {
        const progressElement = document.createElement('mwc-linear-progress');
        progressElement.setAttribute('indeterminate','true');
        const mainContainer = appComponent.querySelector('#mainContainer');
        mainContainer.parentNode.insertBefore(progressElement, mainContainer);
    } else if (alreadyExists && !state) {
        appComponent.querySelector('mwc-linear-progress').remove();
    }
}
'''
'''--- web/compiler/compile.spec.js ---
import { createQuickJS } from './quickjs.js';

describe('compiler', () => {
    it('should compile and evaluate js source', async () => {
        const quickjs = await createQuickJS();
        expect(quickjs.evalSource(`(function () {return 11+34+55+"test".length})()`)).to.equal(11 + 34 + 55 + "test".length);
    });
    it('should evaluate quickjs bytecode', async () => {
        const quickjs = await createQuickJS();
        console.log('eval bytecode', quickjs.evalByteCode([0x02, 0x02, 0x08, 0x74, 0x65, 0x73, 0x74, 0x1a,
            0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x5f, 0x6e, 0x65,
            0x61, 0x72, 0x2e, 0x6a, 0x73, 0x0e, 0x00, 0x06,
            0x00, 0xa0, 0x01, 0x00, 0x01, 0x00, 0x02, 0x00,
            0x00, 0x0a, 0x01, 0xa2, 0x01, 0x00, 0x00, 0x00,
            0x04, 0xde, 0x00, 0x00, 0x00, 0xe9, 0xb9, 0x9d,
            0xcd, 0x28, 0xbe, 0x03, 0x01, 0x00]));
    });
    it('should compile and evaluate quickjs bytecode', async () => {
        const quickjs = await createQuickJS();
        let bytecode = quickjs.compileToByteCode(`(function () {return 11+34+44+"test".length})()`);
        expect(quickjs.evalByteCode(bytecode)).to.equal(11 + 34 + 44 + "test".length);
    });
    it('should handle JSON.parse', async () => {
        const quickjs = await createQuickJS();
        expect(quickjs.evalSource(`JSON.parse('1')`)).to.equal(1);
        expect(quickjs.evalByteCode([0x02, 0x02, 0x0a, 0x70, 0x61, 0x72, 0x73, 0x65,
            0x1a, 0x68, 0x65, 0x6c, 0x6c, 0x6f, 0x5f, 0x6e,
            0x65, 0x61, 0x72, 0x2e, 0x6a, 0x73, 0x0e, 0x00,
            0x06, 0x00, 0xa0, 0x01, 0x00, 0x01, 0x00, 0x03,
            0x00, 0x01, 0x11, 0x01, 0xa2, 0x01, 0x00, 0x00,
            0x00, 0x38, 0x9b, 0x00, 0x00, 0x00, 0x42, 0xde,
            0x00, 0x00, 0x00, 0xbf, 0x00, 0x24, 0x01, 0x00,
            0xcd, 0x28, 0xbe, 0x03, 0x01, 0x00, 0x07, 0x02,
            0x31])).to.equal(1);
    });
    it('should handle JSON.parse in bytecode', async () => {
        const quickjs = await createQuickJS();
        expect(quickjs.evalByteCode(await quickjs.compileToByteCode(`JSON.parse('{"a": 222}').a+3`))).to.equal(JSON.parse('{"a": 222}').a + 3);
    });
    it('should be able to import modules', async () => {
        const quickjs = await createQuickJS();
        quickjs.evalSource(`
        export function hello() {
            return 'hello from module';
        }
        `, 'module1.js');
        quickjs.evalSource(`
        import { hello } from 'module1.js';

        print(hello());        

        `, 'main.js');
        expect(quickjs.stdoutlines).to.include('hello from module');
    });
    it('should be able to import module from bytecode', async () => {
        const quickjs1 = await createQuickJS();
        const bytecode = quickjs1.compileToByteCode(`
        export function hello() {
            return 'hello from module';
        }
        `, 'module2.js');

        const quickjs2 = await createQuickJS();
        quickjs2.evalByteCode(bytecode);
        quickjs2.evalSource(`
        import { hello } from 'module2.js';

        print(hello());        

        `, 'main.js');
        expect(quickjs2.stdoutlines).to.include('hello from module');
    });
});

'''
'''--- web/compiler/nearenv.js ---
import { createQuickJS } from "./quickjs.js";

function createNearEnv(args = '', attached_deposit, storage = {}, signer_account_id) {
    const registers = {};

    return {
        "read_register": (register) => registers[register],
        "register_len": () => null,
        "write_register": () => null,
        "signer_account_id": (register) => registers[register] = signer_account_id,
        "signer_account_pk": () => null,
        "predecessor_account_id": () => null,
        "block_index": () => null,
        "block_timestamp": () => null,
        "epoch_height": () => null,
        "attached_deposit": () => attached_deposit,
        "prepaid_gas": () => null,
        "used_gas": () => null,
        "random_seed": () => null,
        "sha256": () => null,
        "keccak256": () => null,
        "keccak512": () => null,
        "ripemd160": () => null,
        "ecrecover": () => null,
        "panic": () => null,
        "panic_utf8": () => null,
        "log": (msg) => print(msg),
        "log_utf8": () => null,
        "log_utf16": () => null,
        "promise_create": () => null,
        "promise_then": () => null,
        "promise_and": () => null,
        "promise_batch_create": () => null,
        "promise_batch_then": () => null,
        "promise_results_count": () => null,
        "promise_result": () => null,
        "promise_return": () => null,
        "storage_read": () => null,
        "storage_has_key": () => null,
        "validator_stake": () => null,
        "validator_total_stake": () => null,

        // APIs that unique to JSVM
        "jsvm_account_id": () => null,
        "jsvm_js_contract_name": () => null,
        "jsvm_method_name": () => null,
        "jsvm_args": (register) => registers[register] = args,
        "jsvm_storage_write": (key, value, register_id) => storage[key] = value,
        "jsvm_storage_read": (key, register_id) => {
            if (storage[key] != undefined) {
                registers[register_id] = storage[key]
                return 1;
            } else {
                return 0;
            }
        },
        "jsvm_storage_has_key": (key) => storage[key] != undefined,
        "jsvm_storage_remove": (key) => delete storage[key],
        "jsvm_value_return": (val) => print(`return value: ${val}`),
        "jsvm_call": () => null,
        "print_storage": () => print(JSON.stringify(storage))
    }
};

export function getNearEnvSource() {
    return createNearEnv.toString();
}

export async function createQuickJSWithNearEnv(args, attached_deposit = '0', storage = {}, signer_account_id) {
    const argsBase64 = btoa(args);
    const quickjs = await createQuickJS();
    await quickjs.evalSource(await fetch('https://cdn.jsdelivr.net/npm/js-base64@3.7.2/base64.mjs').then(r => r.text()), 'js-base64');
    await quickjs.evalSource(`
    import { decode } from 'js-base64';
    globalThis.env = (${getNearEnvSource()})(decode('${argsBase64}'),BigInt('${attached_deposit}'), ${JSON.stringify(storage)}, '${signer_account_id}')
`, 'env');
    return quickjs;
}

'''
'''--- web/compiler/nearenv.spec.js ---
import { createQuickJS } from "./quickjs.js";
import { createQuickJSWithNearEnv, getNearEnvSource } from "./nearenv.js";

describe('nearenv', () => {
    it('should simulate logging through env', async () => {
        const quickjs = await createQuickJS();
        const source = `        
            const env = (${getNearEnvSource()})();
            env.log('hello from env.log');
        `;
        quickjs.evalSource(source);
        expect(quickjs.stdoutlines).to.include('hello from env.log');
    });
    it('should be able to call an exported function from module with logging through env (compile & bytecode)', async () => {
        const quickjs = await createQuickJS();
        const source = `        
const env = (${getNearEnvSource()})();

export function hello() {
    env.log("Hello Near 555!");
}
hello();
        `;
        const bytecode = quickjs.compileToByteCode(source, true);
        quickjs.evalByteCode(bytecode);
        expect(quickjs.stdoutlines).to.include('Hello Near 555!');
    });
    it('should be able to call an exported function from module with logging through env (eval source)', async () => {
        const quickjs = await createQuickJS();
        const contractbytecode = quickjs.compileToByteCode(`export function hello() {
            env.log("Hello Near 666 abcdefghijk!");
        }`, 'contractmodule');
        quickjs.evalSource(`globalThis.env = (${getNearEnvSource()})()`, 'env');
        quickjs.evalByteCode(contractbytecode);

        quickjs.evalSource(
            `import { hello } from 'contractmodule';
hello();
`, 'main');
        expect(quickjs.stdoutlines).to.include('Hello Near 666 abcdefghijk!');
    });
    it('should receive arguments', async () => {
        const quickjs = await createQuickJSWithNearEnv('args will be here');
        const contractbytecode = quickjs.compileToByteCode(`export function hello() {
            env.jsvm_args(0)
            let input = env.read_register(0);
            env.log('input: '+input);
        }`, 'contractmodule');
        quickjs.evalByteCode(contractbytecode);
        quickjs.evalSource(
            `import { hello } from 'contractmodule';
            hello();
`, 'main');
        expect(quickjs.stdoutlines).to.include('input: args will be here');
    });
    it('should return values', async () => {
        const quickjs = await createQuickJSWithNearEnv('args will be here');
        const contractbytecode = quickjs.compileToByteCode(`export function hello() {
            env.jsvm_value_return('the returned value');
        }`, 'contractmodule');
        quickjs.evalByteCode(contractbytecode);
        quickjs.evalSource(
            `import { hello } from 'contractmodule';
            hello();
`, 'main');
        expect(quickjs.stdoutlines).to.include('return value: the returned value');
    });
    it('should handle attached deposit', async () => {
        const deposit = BigInt('2155166771112341412341241566111112341451');
        const quickjs = await createQuickJSWithNearEnv('some args', deposit.toString());
        const contractbytecode = quickjs.compileToByteCode(`export function hello() {
            env.log('deposit is '+env.attached_deposit().toString())
        }`, 'contractmodule');
        quickjs.evalByteCode(contractbytecode);
        quickjs.evalSource(
            `import { hello } from 'contractmodule';
            hello();
`, 'main');
        expect(quickjs.stdoutlines).to.include('deposit is '+deposit.toString());
    });
    it('should simulate storage', async () => {
        const quickjs = await createQuickJSWithNearEnv('some args',undefined,{
            'abc': 'def',
            'xxx': 'yyy'
        });
        const contractbytecode = quickjs.compileToByteCode(`
export function teststorage() {
    env.jsvm_storage_write("testkey","testvalue");
    env.jsvm_storage_read("testkey",0);
    let val = env.read_register(0);
    env.log('the value is '+val);

    env.jsvm_storage_read("abc",0);
    val = env.read_register(0);
    env.log('the value of abc is '+val);

    env.jsvm_storage_read("xxx",0);
    val = env.read_register(0);
    env.log('the value of xxx is '+val);
}
`, 'contractmodule');
        quickjs.evalByteCode(contractbytecode);
        quickjs.evalSource(
            `import { teststorage } from 'contractmodule';
            teststorage();
`, 'main');
        expect(quickjs.stdoutlines).to.include('the value is testvalue');
        expect(quickjs.stdoutlines).to.include('the value of abc is def');
        expect(quickjs.stdoutlines).to.include('the value of xxx is yyy');
    });
});
'''
'''--- web/compiler/quickjs.js ---
import { Wasi } from './wasi.js';

class QuickJS {
    constructor() {
        this.wasmInstancePromise = (async () => {
            this.wasi = new Wasi({
                "LANG": "en_GB.UTF-8",
                "TERM": "xterm"
            });
            this.stdoutlines = [];
            this.stderrlines = [];
            this.wasi.stdout = (...data) => {
                this.stdoutlines.push(data.join(' '));
                console.log(...data);
            };
            this.wasi.stderr = (...data) => {
                this.stderrlines.push(data.join(' '));
                console.error(...data);
            }
            const wasm = await fetch(new URL('jseval.wasm', import.meta.url)).then(r => r.arrayBuffer());
            const mod = (await WebAssembly.instantiate(wasm, {
                "wasi_snapshot_preview1": this.wasi
            })).instance;
            this.wasi.init(mod);
            this.wasmInstance = mod.exports;
            return mod.exports;
        })();
    }

    allocateString(str) {
        const instance = this.wasmInstance;
        const straddr = instance.malloc(str.length + 1);
        const buf = new Uint8Array(instance.memory.buffer,
            straddr,
            str.length + 1);
        for (let n = 0; n < str.length; n++) {
            buf[n] = str.charCodeAt(n);
        }
        buf[str.length] = 0;
        return straddr;
    }

    evalSource(src, modulefilename='<evalsource>') {
        const instance = this.wasmInstance;
        
        return instance.eval_js_source(this.allocateString(modulefilename), this.allocateString(src), modulefilename!='<evalsource>');
    }

    evalByteCode(bytecode) {
        const instance = this.wasmInstance;
        const bytecodebufaddr = instance.malloc(bytecode.length);
        const bytecodebuf = new Uint8Array(instance.memory.buffer,
            bytecodebufaddr,
            bytecode.length);
        for (let n = 0; n < bytecode.length; n++) {
            bytecodebuf[n] = bytecode[n];
        }

        return instance.eval_js_bytecode(bytecodebufaddr, bytecodebuf.length);
    }

    compileToByteCode(src, modulefilename='<evalsource>') {
        const instance = this.wasmInstance;
        const compiledbytecodebuflenptr = instance.malloc(4);
        const compiledbytecodeaddr = instance.compile_to_bytecode(this.allocateString(modulefilename),
                this.allocateString(src), compiledbytecodebuflenptr, modulefilename!='<evalsource>');

        const compiledbytecodebuflen = new Uint32Array(instance.memory.buffer, compiledbytecodebuflenptr, 4)[0];
        console.log('len', compiledbytecodebuflen);

        return new Uint8Array(instance.memory.buffer, compiledbytecodeaddr, compiledbytecodebuflen);
    }
}

export async function createQuickJS() {
    const quickjs = new QuickJS();
    await quickjs.wasmInstancePromise;
    return quickjs;
}
'''
'''--- web/compiler/wasi.js ---
class WasiMemoryManager {
  constructor(memory, malloc, free) {
    this.memory = memory
    this.malloc = malloc
    this.free = free
  }

  // Convert a pointer from the wasm module to JavaScript string.
  convertToString(ptr, length) {
    try {
      // The pointer is a multi byte character array encoded with utf-8.
      const array = new Uint8Array(this.memory.buffer, ptr, length)
      const decoder = new TextDecoder()
      const string = decoder.decode(array)
      return string
    } finally {
      // Free the memory
      this.free(ptr)
    }
  }

  // Convert a JavaScript string to a pointer to multi byte character array
  convertFromString(string) {
    // Encode the string in utf-8.
    const encoder = new TextEncoder()
    const bytes = encoder.encode(string)
    // Copy the string into memory allocated in the WebAssembly
    const ptr = this.malloc(bytes.byteLength)
    const buffer = new Uint8Array(this.memory.buffer, ptr, bytes.byteLength + 1)
    buffer.set(bytes)
    return buffer
  }
}

const WASI_ESUCCESS = 0
const WASI_ERRNO_BADF = 8

const WASI_FILETYPE_UNKNOWN = 0
const WASI_FILETYPE_BLOCK_DEVICE = 1
const WASI_FILETYPE_CHARACTER_DEVICE = 2
const WASI_FILETYPE_DIRECTORY = 3
const WASI_FILETYPE_REGULAR_FILE = 4
const WASI_FILETYPE_SOCKET_DGRAM = 5
const WASI_FILETYPE_SOCKET_STREAM = 6
const WASI_FILETYPE_SYMBOLIC_LINK = 7

const WASI_FDFLAGS_APPEND = 1
const WASI_FDFLAGS_DSYNC = 2
const WASI_FDFLAGS_NONBLOCK = 4
const WASI_FDFLAGS_RSYNC = 8
const WASI_FDFLAGS_SYNC = 16

const WASI_RIGHTS_FD_DATASYNC = 1n
const WASI_RIGHTS_FD_READ = 2n
const WASI_RIGHTS_FD_SEEK = 4n
const WASI_RIGHTS_FD_FDSTAT_SET_FLAGS = 8n
const WASI_RIGHTS_FD_SYNC = 16n
const WASI_RIGHTS_FD_TELL = 32n
const WASI_RIGHTS_FD_WRITE = 64n
const WASI_RIGHTS_FD_ADVISE = 128n
const WASI_RIGHTS_FD_ALLOCATE = 256n
const WASI_RIGHTS_PATH_CREATE_DIRECTORY = 512n
const WASI_RIGHTS_PATH_CREATE_FILE = 1024n
const WASI_RIGHTS_PATH_LINK_SOURCE = 2048n
const WASI_RIGHTS_PATH_LINK_TARGET = 4096n
const WASI_RIGHTS_PATH_OPEN = 8192n
const WASI_RIGHTS_FD_READDIR = 16384n
const WASI_RIGHTS_PATH_READLINK = 32768n
const WASI_RIGHTS_PATH_RENAME_SOURCE = 65536n
const WASI_RIGHTS_PATH_RENAME_TARGET = 131072n
const WASI_RIGHTS_PATH_FILESTAT_GET = 262144n
const WASI_RIGHTS_PATH_FILESTAT_SET_SIZE = 524288n
const WASI_RIGHTS_PATH_FILESTAT_SET_TIMES = 1048576n
const WASI_RIGHTS_FD_FILESTAT_GET = 2097152n
const WASI_RIGHTS_FD_FILESTAT_SET_SIZE = 4194304n
const WASI_RIGHTS_FD_FILESTAT_SET_TIMES = 8388608n
const WASI_RIGHTS_PATH_SYMLINK = 16777216n
const WASI_RIGHTS_PATH_REMOVE_DIRECTORY = 33554432n
const WASI_RIGHTS_PATH_UNLINK_FILE = 67108864n
const WASI_RIGHTS_POLL_FD_READWRITE = 134217728n
const WASI_RIGHTS_SOCK_SHUTDOWN = 268435456n

const STDOUT = 1
const STDERR = 2

function drainWriter(write, prev, current) {
  let text = prev + current
  while (text.includes('\n')) {
    const [line, rest] = text.split('\n', 2)
    write(line)
    text = rest
  }
  return text
}

// An implementation of WASI which supports the minimum
// required to use multi byte characters.
export class Wasi {
  constructor(env) {
    this.env = env
    this.instance = null
    this.wasiMemoryManager = null
    this.stdoutText = ''
    this.stderrText = ''
    this.stdout = console.log
    this.stderr = console.error
  }

  // Initialise the instance from the WebAssembly.
  init = (instance) => {
    this.instance = instance
    this.wasiMemoryManager = new WasiMemoryManager(
      instance.exports.memory,
      instance.exports.malloc,
      instance.exports.free
    )
  }

  // Get the environment variables.
  environ_get = (environ, environBuf) => {
    const encoder = new TextEncoder()
    const view = new DataView(this.wasiMemoryManager.memory.buffer)

    Object.entries(this.env).map(
      ([key, value]) => `${key}=${value}`
    ).forEach(envVar => {
      view.setUint32(environ, environBuf, true)
      environ += 4

      const bytes = encoder.encode(envVar)
      const buf = new Uint8Array(this.wasiMemoryManager.memory.buffer, environBuf, bytes.length + 1)
      environBuf += buf.byteLength
    });
    return WASI_ESUCCESS;
  }

  // Get the size required to store the environment variables.
  environ_sizes_get = (environCount, environBufSize) => {
    const encoder = new TextEncoder()
    const view = new DataView(this.wasiMemoryManager.memory.buffer)

    const envVars = Object.entries(this.env).map(
      ([key, value]) => `${key}=${value}`
    )
    const size = envVars.reduce(
      (acc, envVar) => acc + encoder.encode(envVar).byteLength + 1,
      0
    )
    view.setUint32(environCount, envVars.length, true)
    view.setUint32(environBufSize, size, true)

    return WASI_ESUCCESS
  }

  // This gets called on exit to stop the running program.
  // We don't have anything to stop!
  proc_exit = rval => {
    return WASI_ESUCCESS
  }

  fd_close = fd => {
    return WASI_ESUCCESS
  }

  fd_seek = (fd, offset_low, offset_high, whence, newOffset) => {
    return WASI_ESUCCESS
  }

  fd_write = (fd, iovs, iovsLen, nwritten) => {
    if (!(fd === 1 | fd === 2)) {
      return WASI_ERRNO_BADF
    }

    const view = new DataView(this.wasiMemoryManager.memory.buffer)

    const buffers = Array.from({ length: iovsLen }, (_, i) => {
      const ptr = iovs + i * 8;
      const buf = view.getUint32(ptr, true);
      const bufLen = view.getUint32(ptr + 4, true);
      return new Uint8Array(this.wasiMemoryManager.memory.buffer, buf, bufLen);
    })

    const textDecoder = new TextDecoder()

    let written = 0;
    let text = ''
    buffers.forEach(buf => {
      text += textDecoder.decode(buf)
      written += buf.byteLength
    });
    view.setUint32(nwritten, written, true);

    if (fd === STDOUT) {
      this.stdoutText = drainWriter(this.stdout, this.stdoutText, text)
    } else if (fd == STDERR) {
      this.stderrText = drainWriter(this.stderr, this.stderrText, text)
    }

    return WASI_ESUCCESS;
  }

  random_get = () => {
    return 0;
  };

  fd_fdstat_get = (fd, stat) => {
    if (!(fd === 1 | fd === 2)) {
      return WASI_ERRNO_BADF
    }

    const view = new DataView(this.wasiMemoryManager.memory.buffer)
    view.setUint8(stat + 0, WASI_FILETYPE_CHARACTER_DEVICE);
    view.setUint32(stat + 2, WASI_FDFLAGS_APPEND, true);
    view.setBigUint64(stat + 8, WASI_RIGHTS_FD_WRITE, true);
    view.setBigUint64(stat + 16, WASI_RIGHTS_FD_WRITE, true);
    return WASI_ESUCCESS;
  }
  clock_time_get = (a) => {
    console.log('clock get time',a);
  }
}
'''
'''--- web/importmap.js ---

const importmapscriptelement = document.createElement('script');
importmapscriptelement.type = 'importmap';
importmapscriptelement.textContent = JSON.stringify({
  "imports": {
    "@codemirror/basic-setup": "https://ga.jspm.io/npm:@codemirror/basic-setup@0.20.0/dist/index.js",
    "@codemirror/commands": "https://ga.jspm.io/npm:@codemirror/commands@0.20.0/dist/index.js",
    "@codemirror/lang-javascript": "https://ga.jspm.io/npm:@codemirror/lang-javascript@0.20.0/dist/index.js",
    "@codemirror/state": "https://ga.jspm.io/npm:@codemirror/state@0.20.0/dist/index.js",
    "@codemirror/view": "https://ga.jspm.io/npm:@codemirror/view@0.20.6/dist/index.js",
    "@material/mwc-button": "https://ga.jspm.io/npm:@material/mwc-button@0.26.1/mwc-button.js",
    "@material/mwc-dialog": "https://ga.jspm.io/npm:@material/mwc-dialog@0.26.1/mwc-dialog.js",
    "@material/mwc-drawer": "https://ga.jspm.io/npm:@material/mwc-drawer@0.26.1/mwc-drawer.js",
    "@material/mwc-icon-button": "https://ga.jspm.io/npm:@material/mwc-icon-button@0.26.1/mwc-icon-button.js",
    "@material/mwc-linear-progress": "https://ga.jspm.io/npm:@material/mwc-linear-progress@0.26.1/mwc-linear-progress.js",
    "@material/mwc-list": "https://ga.jspm.io/npm:@material/mwc-list@0.26.1/mwc-list.js",
    "@material/mwc-list/mwc-list-item": "https://ga.jspm.io/npm:@material/mwc-list@0.26.1/mwc-list-item.js",
    "@material/mwc-select": "https://ga.jspm.io/npm:@material/mwc-select@0.26.1/mwc-select.js",
    "@material/mwc-snackbar": "https://ga.jspm.io/npm:@material/mwc-snackbar@0.26.1/mwc-snackbar.js",
    "@material/mwc-textfield": "https://ga.jspm.io/npm:@material/mwc-textfield@0.26.1/mwc-textfield.js",
    "@material/mwc-top-app-bar": "https://ga.jspm.io/npm:@material/mwc-top-app-bar@0.26.1/mwc-top-app-bar.js"
  },
  "scopes": {
    "https://ga.jspm.io/": {
      "@codemirror/autocomplete": "https://ga.jspm.io/npm:@codemirror/autocomplete@0.20.1/dist/index.js",
      "@codemirror/language": "https://ga.jspm.io/npm:@codemirror/language@0.20.2/dist/index.js",
      "@codemirror/lint": "https://ga.jspm.io/npm:@codemirror/lint@0.20.2/dist/index.js",
      "@codemirror/search": "https://ga.jspm.io/npm:@codemirror/search@0.20.1/dist/index.js",
      "@lezer/common": "https://ga.jspm.io/npm:@lezer/common@0.16.0/dist/index.js",
      "@lezer/highlight": "https://ga.jspm.io/npm:@lezer/highlight@0.16.0/dist/index.js",
      "@lezer/javascript": "https://ga.jspm.io/npm:@lezer/javascript@0.16.0/dist/index.es.js",
      "@lezer/lr": "https://ga.jspm.io/npm:@lezer/lr@0.16.3/dist/index.js",
      "@lit/reactive-element": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/reactive-element.js",
      "@lit/reactive-element/decorators/custom-element.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/custom-element.js",
      "@lit/reactive-element/decorators/event-options.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/event-options.js",
      "@lit/reactive-element/decorators/property.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/property.js",
      "@lit/reactive-element/decorators/query-all.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/query-all.js",
      "@lit/reactive-element/decorators/query-assigned-elements.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/query-assigned-elements.js",
      "@lit/reactive-element/decorators/query-assigned-nodes.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/query-assigned-nodes.js",
      "@lit/reactive-element/decorators/query-async.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/query-async.js",
      "@lit/reactive-element/decorators/query.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/query.js",
      "@lit/reactive-element/decorators/state.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/state.js",
      "@material/animation/animationframe": "https://ga.jspm.io/npm:@material/animation@14.0.0-canary.53b3cad2f.0/animationframe.js",
      "@material/base/foundation": "https://ga.jspm.io/npm:@material/base@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/base/foundation.js": "https://ga.jspm.io/npm:@material/base@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/dialog/constants.js": "https://ga.jspm.io/npm:@material/dialog@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/dialog/foundation.js": "https://ga.jspm.io/npm:@material/dialog@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/dom/events.js": "https://ga.jspm.io/npm:@material/dom@14.0.0-canary.53b3cad2f.0/events.js",
      "@material/dom/keyboard": "https://ga.jspm.io/npm:@material/dom@14.0.0-canary.53b3cad2f.0/keyboard.js",
      "@material/dom/keyboard.js": "https://ga.jspm.io/npm:@material/dom@14.0.0-canary.53b3cad2f.0/keyboard.js",
      "@material/dom/ponyfill.js": "https://ga.jspm.io/npm:@material/dom@14.0.0-canary.53b3cad2f.0/ponyfill.js",
      "@material/drawer/constants.js": "https://ga.jspm.io/npm:@material/drawer@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/drawer/dismissible/foundation.js": "https://ga.jspm.io/npm:@material/drawer@14.0.0-canary.53b3cad2f.0/dismissible/foundation.js",
      "@material/drawer/modal/foundation.js": "https://ga.jspm.io/npm:@material/drawer@14.0.0-canary.53b3cad2f.0/modal/foundation.js",
      "@material/floating-label/foundation.js": "https://ga.jspm.io/npm:@material/floating-label@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/line-ripple/foundation.js": "https://ga.jspm.io/npm:@material/line-ripple@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/list/constants": "https://ga.jspm.io/npm:@material/list@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/list/constants.js": "https://ga.jspm.io/npm:@material/list@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/list/typeahead.js": "https://ga.jspm.io/npm:@material/list@14.0.0-canary.53b3cad2f.0/typeahead.js",
      "@material/menu-surface/constants": "https://ga.jspm.io/npm:@material/menu-surface@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/menu-surface/constants.js": "https://ga.jspm.io/npm:@material/menu-surface@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/menu-surface/foundation": "https://ga.jspm.io/npm:@material/menu-surface@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/menu-surface/foundation.js": "https://ga.jspm.io/npm:@material/menu-surface@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/menu/constants.js": "https://ga.jspm.io/npm:@material/menu@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/menu/foundation.js": "https://ga.jspm.io/npm:@material/menu@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/mwc-base/aria-property.js": "https://ga.jspm.io/npm:@material/mwc-base@0.26.1/aria-property.js",
      "@material/mwc-base/base-element.js": "https://ga.jspm.io/npm:@material/mwc-base@0.26.1/base-element.js",
      "@material/mwc-base/form-element.js": "https://ga.jspm.io/npm:@material/mwc-base@0.26.1/form-element.js",
      "@material/mwc-base/observer.js": "https://ga.jspm.io/npm:@material/mwc-base@0.26.1/observer.js",
      "@material/mwc-base/utils.js": "https://ga.jspm.io/npm:@material/mwc-base@0.26.1/utils.js",
      "@material/mwc-floating-label/mwc-floating-label-directive.js": "https://ga.jspm.io/npm:@material/mwc-floating-label@0.26.1/mwc-floating-label-directive.js",
      "@material/mwc-icon/mwc-icon.js": "https://ga.jspm.io/npm:@material/mwc-icon@0.26.1/mwc-icon.js",
      "@material/mwc-line-ripple/mwc-line-ripple-directive.js": "https://ga.jspm.io/npm:@material/mwc-line-ripple@0.26.1/mwc-line-ripple-directive.js",
      "@material/mwc-list/mwc-list-foundation.js": "https://ga.jspm.io/npm:@material/mwc-list@0.26.1/mwc-list-foundation.js",
      "@material/mwc-list/mwc-list.js": "https://ga.jspm.io/npm:@material/mwc-list@0.26.1/mwc-list.js",
      "@material/mwc-menu/mwc-menu.js": "https://ga.jspm.io/npm:@material/mwc-menu@0.26.1/mwc-menu.js",
      "@material/mwc-notched-outline/mwc-notched-outline.js": "https://ga.jspm.io/npm:@material/mwc-notched-outline@0.26.1/mwc-notched-outline.js",
      "@material/mwc-ripple/mwc-ripple.js": "https://ga.jspm.io/npm:@material/mwc-ripple@0.26.1/mwc-ripple.js",
      "@material/mwc-ripple/ripple-handlers.js": "https://ga.jspm.io/npm:@material/mwc-ripple@0.26.1/ripple-handlers.js",
      "@material/notched-outline/foundation.js": "https://ga.jspm.io/npm:@material/notched-outline@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/ripple/foundation.js": "https://ga.jspm.io/npm:@material/ripple@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/select/foundation.js": "https://ga.jspm.io/npm:@material/select@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/snackbar/foundation.js": "https://ga.jspm.io/npm:@material/snackbar@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/textfield/foundation.js": "https://ga.jspm.io/npm:@material/textfield@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/top-app-bar/constants.js": "https://ga.jspm.io/npm:@material/top-app-bar@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/top-app-bar/standard/foundation.js": "https://ga.jspm.io/npm:@material/top-app-bar@14.0.0-canary.53b3cad2f.0/standard/foundation.js",
      "blocking-elements": "https://ga.jspm.io/npm:blocking-elements@0.1.1/dist/blocking-elements.js",
      "crelt": "https://ga.jspm.io/npm:crelt@1.0.5/index.es.js",
      "lit": "https://ga.jspm.io/npm:lit@2.2.4/index.js",
      "lit-element/lit-element.js": "https://ga.jspm.io/npm:lit-element@3.2.0/lit-element.js",
      "lit-html": "https://ga.jspm.io/npm:lit-html@2.2.4/lit-html.js",
      "lit-html/async-directive.js": "https://ga.jspm.io/npm:lit-html@2.2.4/async-directive.js",
      "lit-html/directive.js": "https://ga.jspm.io/npm:lit-html@2.2.4/directive.js",
      "lit-html/directives/class-map.js": "https://ga.jspm.io/npm:lit-html@2.2.4/directives/class-map.js",
      "lit-html/directives/if-defined.js": "https://ga.jspm.io/npm:lit-html@2.2.4/directives/if-defined.js",
      "lit-html/directives/live.js": "https://ga.jspm.io/npm:lit-html@2.2.4/directives/live.js",
      "lit-html/directives/style-map.js": "https://ga.jspm.io/npm:lit-html@2.2.4/directives/style-map.js",
      "lit/async-directive.js": "https://ga.jspm.io/npm:lit@2.2.4/async-directive.js",
      "lit/decorators.js": "https://ga.jspm.io/npm:lit@2.2.4/decorators.js",
      "lit/directive.js": "https://ga.jspm.io/npm:lit@2.2.4/directive.js",
      "lit/directives/class-map.js": "https://ga.jspm.io/npm:lit@2.2.4/directives/class-map.js",
      "lit/directives/if-defined.js": "https://ga.jspm.io/npm:lit@2.2.4/directives/if-defined.js",
      "lit/directives/live.js": "https://ga.jspm.io/npm:lit@2.2.4/directives/live.js",
      "lit/directives/style-map.js": "https://ga.jspm.io/npm:lit@2.2.4/directives/style-map.js",
      "style-mod": "https://ga.jspm.io/npm:style-mod@4.0.0/src/style-mod.js",
      "tslib": "https://ga.jspm.io/npm:tslib@2.4.0/tslib.es6.js",
      "w3c-keyname": "https://ga.jspm.io/npm:w3c-keyname@2.2.4/index.es.js",
      "wicg-inert": "https://ga.jspm.io/npm:wicg-inert@3.1.1/dist/inert.js"
    }
  }
});
document.currentScript.after(importmapscriptelement);

'''
'''--- web/importmapgenerator.js ---
import { Generator } from '@jspm/generator';
import { readFileSync, writeFileSync } from 'fs';

const generator = new Generator({
  mapUrl: import.meta.url,
  defaultProvider: 'jspm', // this is the default defaultProvider
  // Always ensure to define your target environment to get a working map
  // it is advisable to pass the "module" condition as supported by Webpack
  env: ['production', 'browser', 'module'],
});

const packages = ['@material/mwc-list/mwc-list-item'
  ,...Object.keys(JSON.parse(readFileSync('./package.json')).dependencies)];

// Install a new package into the import map
for(const p of packages) {
  await generator.install(p);
}

const importMapJson = JSON.stringify(generator.getMap(), null, 2);
let indexHtml = readFileSync('index.html').toString();
indexHtml = indexHtml.replace(/\<script type=\"importmap\"\>[^<]+\<\/script\>/,
            `<script type="importmap">${importMapJson}</script>`)
writeFileSync('index.html', indexHtml);
writeFileSync('importmap.js', `
const importmapscriptelement = document.createElement('script');
importmapscriptelement.type = 'importmap';
importmapscriptelement.textContent = JSON.stringify(${importMapJson});
document.currentScript.after(importmapscriptelement);
`);

'''
'''--- web/index.html ---
<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Material+Icons&display=block" rel="stylesheet">
        <style>
            body {
                margin: 0;
                font-family: Roboto, sans-serif;
            }
        </style>
    </head>
    <body>
        <app-root></app-root>
    </body>
    <script type="importmap">{
  "imports": {
    "@codemirror/basic-setup": "https://ga.jspm.io/npm:@codemirror/basic-setup@0.20.0/dist/index.js",
    "@codemirror/commands": "https://ga.jspm.io/npm:@codemirror/commands@0.20.0/dist/index.js",
    "@codemirror/lang-javascript": "https://ga.jspm.io/npm:@codemirror/lang-javascript@0.20.0/dist/index.js",
    "@codemirror/state": "https://ga.jspm.io/npm:@codemirror/state@0.20.0/dist/index.js",
    "@codemirror/view": "https://ga.jspm.io/npm:@codemirror/view@0.20.6/dist/index.js",
    "@material/mwc-button": "https://ga.jspm.io/npm:@material/mwc-button@0.26.1/mwc-button.js",
    "@material/mwc-dialog": "https://ga.jspm.io/npm:@material/mwc-dialog@0.26.1/mwc-dialog.js",
    "@material/mwc-drawer": "https://ga.jspm.io/npm:@material/mwc-drawer@0.26.1/mwc-drawer.js",
    "@material/mwc-icon-button": "https://ga.jspm.io/npm:@material/mwc-icon-button@0.26.1/mwc-icon-button.js",
    "@material/mwc-linear-progress": "https://ga.jspm.io/npm:@material/mwc-linear-progress@0.26.1/mwc-linear-progress.js",
    "@material/mwc-list": "https://ga.jspm.io/npm:@material/mwc-list@0.26.1/mwc-list.js",
    "@material/mwc-list/mwc-list-item": "https://ga.jspm.io/npm:@material/mwc-list@0.26.1/mwc-list-item.js",
    "@material/mwc-select": "https://ga.jspm.io/npm:@material/mwc-select@0.26.1/mwc-select.js",
    "@material/mwc-snackbar": "https://ga.jspm.io/npm:@material/mwc-snackbar@0.26.1/mwc-snackbar.js",
    "@material/mwc-textfield": "https://ga.jspm.io/npm:@material/mwc-textfield@0.26.1/mwc-textfield.js",
    "@material/mwc-top-app-bar": "https://ga.jspm.io/npm:@material/mwc-top-app-bar@0.26.1/mwc-top-app-bar.js"
  },
  "scopes": {
    "https://ga.jspm.io/": {
      "@codemirror/autocomplete": "https://ga.jspm.io/npm:@codemirror/autocomplete@0.20.1/dist/index.js",
      "@codemirror/language": "https://ga.jspm.io/npm:@codemirror/language@0.20.2/dist/index.js",
      "@codemirror/lint": "https://ga.jspm.io/npm:@codemirror/lint@0.20.2/dist/index.js",
      "@codemirror/search": "https://ga.jspm.io/npm:@codemirror/search@0.20.1/dist/index.js",
      "@lezer/common": "https://ga.jspm.io/npm:@lezer/common@0.16.0/dist/index.js",
      "@lezer/highlight": "https://ga.jspm.io/npm:@lezer/highlight@0.16.0/dist/index.js",
      "@lezer/javascript": "https://ga.jspm.io/npm:@lezer/javascript@0.16.0/dist/index.es.js",
      "@lezer/lr": "https://ga.jspm.io/npm:@lezer/lr@0.16.3/dist/index.js",
      "@lit/reactive-element": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/reactive-element.js",
      "@lit/reactive-element/decorators/custom-element.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/custom-element.js",
      "@lit/reactive-element/decorators/event-options.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/event-options.js",
      "@lit/reactive-element/decorators/property.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/property.js",
      "@lit/reactive-element/decorators/query-all.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/query-all.js",
      "@lit/reactive-element/decorators/query-assigned-elements.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/query-assigned-elements.js",
      "@lit/reactive-element/decorators/query-assigned-nodes.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/query-assigned-nodes.js",
      "@lit/reactive-element/decorators/query-async.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/query-async.js",
      "@lit/reactive-element/decorators/query.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/query.js",
      "@lit/reactive-element/decorators/state.js": "https://ga.jspm.io/npm:@lit/reactive-element@1.3.2/decorators/state.js",
      "@material/animation/animationframe": "https://ga.jspm.io/npm:@material/animation@14.0.0-canary.53b3cad2f.0/animationframe.js",
      "@material/base/foundation": "https://ga.jspm.io/npm:@material/base@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/base/foundation.js": "https://ga.jspm.io/npm:@material/base@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/dialog/constants.js": "https://ga.jspm.io/npm:@material/dialog@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/dialog/foundation.js": "https://ga.jspm.io/npm:@material/dialog@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/dom/events.js": "https://ga.jspm.io/npm:@material/dom@14.0.0-canary.53b3cad2f.0/events.js",
      "@material/dom/keyboard": "https://ga.jspm.io/npm:@material/dom@14.0.0-canary.53b3cad2f.0/keyboard.js",
      "@material/dom/keyboard.js": "https://ga.jspm.io/npm:@material/dom@14.0.0-canary.53b3cad2f.0/keyboard.js",
      "@material/dom/ponyfill.js": "https://ga.jspm.io/npm:@material/dom@14.0.0-canary.53b3cad2f.0/ponyfill.js",
      "@material/drawer/constants.js": "https://ga.jspm.io/npm:@material/drawer@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/drawer/dismissible/foundation.js": "https://ga.jspm.io/npm:@material/drawer@14.0.0-canary.53b3cad2f.0/dismissible/foundation.js",
      "@material/drawer/modal/foundation.js": "https://ga.jspm.io/npm:@material/drawer@14.0.0-canary.53b3cad2f.0/modal/foundation.js",
      "@material/floating-label/foundation.js": "https://ga.jspm.io/npm:@material/floating-label@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/line-ripple/foundation.js": "https://ga.jspm.io/npm:@material/line-ripple@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/list/constants": "https://ga.jspm.io/npm:@material/list@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/list/constants.js": "https://ga.jspm.io/npm:@material/list@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/list/typeahead.js": "https://ga.jspm.io/npm:@material/list@14.0.0-canary.53b3cad2f.0/typeahead.js",
      "@material/menu-surface/constants": "https://ga.jspm.io/npm:@material/menu-surface@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/menu-surface/constants.js": "https://ga.jspm.io/npm:@material/menu-surface@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/menu-surface/foundation": "https://ga.jspm.io/npm:@material/menu-surface@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/menu-surface/foundation.js": "https://ga.jspm.io/npm:@material/menu-surface@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/menu/constants.js": "https://ga.jspm.io/npm:@material/menu@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/menu/foundation.js": "https://ga.jspm.io/npm:@material/menu@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/mwc-base/aria-property.js": "https://ga.jspm.io/npm:@material/mwc-base@0.26.1/aria-property.js",
      "@material/mwc-base/base-element.js": "https://ga.jspm.io/npm:@material/mwc-base@0.26.1/base-element.js",
      "@material/mwc-base/form-element.js": "https://ga.jspm.io/npm:@material/mwc-base@0.26.1/form-element.js",
      "@material/mwc-base/observer.js": "https://ga.jspm.io/npm:@material/mwc-base@0.26.1/observer.js",
      "@material/mwc-base/utils.js": "https://ga.jspm.io/npm:@material/mwc-base@0.26.1/utils.js",
      "@material/mwc-floating-label/mwc-floating-label-directive.js": "https://ga.jspm.io/npm:@material/mwc-floating-label@0.26.1/mwc-floating-label-directive.js",
      "@material/mwc-icon/mwc-icon.js": "https://ga.jspm.io/npm:@material/mwc-icon@0.26.1/mwc-icon.js",
      "@material/mwc-line-ripple/mwc-line-ripple-directive.js": "https://ga.jspm.io/npm:@material/mwc-line-ripple@0.26.1/mwc-line-ripple-directive.js",
      "@material/mwc-list/mwc-list-foundation.js": "https://ga.jspm.io/npm:@material/mwc-list@0.26.1/mwc-list-foundation.js",
      "@material/mwc-list/mwc-list.js": "https://ga.jspm.io/npm:@material/mwc-list@0.26.1/mwc-list.js",
      "@material/mwc-menu/mwc-menu.js": "https://ga.jspm.io/npm:@material/mwc-menu@0.26.1/mwc-menu.js",
      "@material/mwc-notched-outline/mwc-notched-outline.js": "https://ga.jspm.io/npm:@material/mwc-notched-outline@0.26.1/mwc-notched-outline.js",
      "@material/mwc-ripple/mwc-ripple.js": "https://ga.jspm.io/npm:@material/mwc-ripple@0.26.1/mwc-ripple.js",
      "@material/mwc-ripple/ripple-handlers.js": "https://ga.jspm.io/npm:@material/mwc-ripple@0.26.1/ripple-handlers.js",
      "@material/notched-outline/foundation.js": "https://ga.jspm.io/npm:@material/notched-outline@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/ripple/foundation.js": "https://ga.jspm.io/npm:@material/ripple@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/select/foundation.js": "https://ga.jspm.io/npm:@material/select@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/snackbar/foundation.js": "https://ga.jspm.io/npm:@material/snackbar@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/textfield/foundation.js": "https://ga.jspm.io/npm:@material/textfield@14.0.0-canary.53b3cad2f.0/foundation.js",
      "@material/top-app-bar/constants.js": "https://ga.jspm.io/npm:@material/top-app-bar@14.0.0-canary.53b3cad2f.0/constants.js",
      "@material/top-app-bar/standard/foundation.js": "https://ga.jspm.io/npm:@material/top-app-bar@14.0.0-canary.53b3cad2f.0/standard/foundation.js",
      "blocking-elements": "https://ga.jspm.io/npm:blocking-elements@0.1.1/dist/blocking-elements.js",
      "crelt": "https://ga.jspm.io/npm:crelt@1.0.5/index.es.js",
      "lit": "https://ga.jspm.io/npm:lit@2.2.4/index.js",
      "lit-element/lit-element.js": "https://ga.jspm.io/npm:lit-element@3.2.0/lit-element.js",
      "lit-html": "https://ga.jspm.io/npm:lit-html@2.2.4/lit-html.js",
      "lit-html/async-directive.js": "https://ga.jspm.io/npm:lit-html@2.2.4/async-directive.js",
      "lit-html/directive.js": "https://ga.jspm.io/npm:lit-html@2.2.4/directive.js",
      "lit-html/directives/class-map.js": "https://ga.jspm.io/npm:lit-html@2.2.4/directives/class-map.js",
      "lit-html/directives/if-defined.js": "https://ga.jspm.io/npm:lit-html@2.2.4/directives/if-defined.js",
      "lit-html/directives/live.js": "https://ga.jspm.io/npm:lit-html@2.2.4/directives/live.js",
      "lit-html/directives/style-map.js": "https://ga.jspm.io/npm:lit-html@2.2.4/directives/style-map.js",
      "lit/async-directive.js": "https://ga.jspm.io/npm:lit@2.2.4/async-directive.js",
      "lit/decorators.js": "https://ga.jspm.io/npm:lit@2.2.4/decorators.js",
      "lit/directive.js": "https://ga.jspm.io/npm:lit@2.2.4/directive.js",
      "lit/directives/class-map.js": "https://ga.jspm.io/npm:lit@2.2.4/directives/class-map.js",
      "lit/directives/if-defined.js": "https://ga.jspm.io/npm:lit@2.2.4/directives/if-defined.js",
      "lit/directives/live.js": "https://ga.jspm.io/npm:lit@2.2.4/directives/live.js",
      "lit/directives/style-map.js": "https://ga.jspm.io/npm:lit@2.2.4/directives/style-map.js",
      "style-mod": "https://ga.jspm.io/npm:style-mod@4.0.0/src/style-mod.js",
      "tslib": "https://ga.jspm.io/npm:tslib@2.4.0/tslib.es6.js",
      "w3c-keyname": "https://ga.jspm.io/npm:w3c-keyname@2.2.4/index.es.js",
      "wicg-inert": "https://ga.jspm.io/npm:wicg-inert@3.1.1/dist/inert.js"
    }
  }
}</script>
    <script type="module" src="app.component.js"></script>
</html>

'''
'''--- web/near/near.component.html ---
<mwc-dialog id="login-dialog" heading="Login to Javascript VM contract">
    <h4>Select Javascript VM contract to log into</h4>
    <mwc-select id="contractselect" label="contract">
        
    </mwc-select>
    <h4>or enter the name of any JSVM contract</h4>
    <mwc-textfield id="contractinput"></mwc-textfield>
    <mwc-button slot="primaryAction" dialogAction="login">
        Login
    </mwc-button>
    <mwc-button slot="secondaryAction" dialogAction="cancel">
        Cancel
    </mwc-button>
</mwc-dialog>
'''
'''--- web/near/near.component.js ---
class NearComponents extends HTMLElement {
    constructor() {
        super();
        this.attachShadow({mode: 'open'});
        this.readyPromise = this.loadHTML();
    }

    async loadHTML() {
        this.shadowRoot.innerHTML = await fetch(new URL('near.component.html', import.meta.url)).then(r => r.text());
    }

    async showLoginDialog(targetContractNames) {
        await this.readyPromise;
        const contractselect = this.shadowRoot.getElementById('contractselect');
        targetContractNames.forEach(contractname => {
            const option = document.createElement('mwc-list-item');
            option.innerHTML = contractname;
            option.value = contractname;
            contractselect.appendChild(option);
        });
        const loginDialog = this.shadowRoot.getElementById('login-dialog');
        loginDialog.setAttribute('open', 'true');

        if (await new Promise(resolve => {
            loginDialog.querySelectorAll('mwc-button').forEach(b => b.addEventListener('click', (e) => {
                resolve(e.target.getAttribute('dialogaction'));
            }))
        }) == 'login') {
            return loginDialog.querySelector('#contractinput').value || loginDialog.querySelector('#contractselect').value;
        } else {
            return null;
        }
    }
}
customElements.define('near-dialogs', NearComponents);

export async function showLoginDialog(targetContractNames) {
    const dialogElement = document.createElement('near-dialogs');
    document.querySelector('app-root').shadowRoot.appendChild(dialogElement);
    const ret = await dialogElement.showLoginDialog(targetContractNames);    
    dialogElement.remove();
    return ret;
}
'''
'''--- web/near/near.js ---
import 'https://cdn.jsdelivr.net/npm/near-api-js@0.44.2/dist/near-api-js.min.js';
import { showLoginDialog } from './near.component.js';

const LOGGED_IN_CONTRACT_NAME = 'loggedincontractname';
const contracts = ['dev-1650702826986-24017505724534', 'jsvm.testnet'];
const nearconfig = {
    nodeUrl: 'https://rpc.testnet.near.org',
    archiveNodeUrl: 'https://archival-rpc.testnet.near.org',
    walletUrl: 'https://wallet.testnet.near.org',
    helperUrl: 'https://helper.testnet.near.org',
    networkId: 'testnet',
    deps: {
        keyStore: null
    }
};
let walletConnection;

function b64DecodeUnicode(str) {
    return decodeURIComponent(atob(str).split('').map(function (c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
}

export function getNearConfig() {
    return nearconfig;
}

export async function byteArrayToBase64(data) {
    return await new Promise(r => {
        const fr = new FileReader();
        fr.onload = () => r(fr.result.split('base64,')[1]);
        fr.readAsDataURL(new Blob([data]));
    });
}

export function createWalletConnection() {
    if (walletConnection) {
        return walletConnection;
    }
    walletConnection = new Promise(async resolve => {
        nearconfig.deps.keyStore = new nearApi.keyStores.BrowserLocalStorageKeyStore();
        nearconfig.contractName = localStorage.getItem(LOGGED_IN_CONTRACT_NAME);
        const near = await nearApi.connect(nearconfig);
        const wc = new nearApi.WalletConnection(near);
        resolve(wc);
    });
    return walletConnection;
}

export function clearWalletConnection() {
    walletConnection = null;
}

export async function checkSignedin() {
    const wc = await createWalletConnection();
    const acc = wc.account();

    if (!(await acc.connection.signer.getPublicKey(acc.accountId, acc.connection.networkId))
        || !nearconfig.contractName
    ) {
        wc.signOut();
    }

    if (!wc.isSignedIn()) {
        const contractname = await showLoginDialog(contracts);
        if (contractname) {
            localStorage.setItem(LOGGED_IN_CONTRACT_NAME, contractname);
            await wc.requestSignIn(
                contractname,
                'near-javascript'
            );
        } else {
            return null;
        }
    }
    return wc;
}

export function getSuggestedDepositForContract(contractbytelength) {
    return nearApi.utils.format.parseNearAmount(`${contractbytelength / 1000}`);
}

export async function deployJScontract(contractbytes, deposit = undefined) {
    const wc = await createWalletConnection();
    if (await checkSignedin()) {
        await wc.account().functionCall(nearconfig.contractName, 'deploy_js_contract', contractbytes, null, deposit);
    }
}

export async function callJSContract(contractAccount, methodName, args, deposit) {
    const wc = await checkSignedin();
    if (wc) {
        let input = Buffer.concat([Buffer.from(contractAccount), Buffer.from([0]), Buffer.from(methodName), Buffer.from([0]), Buffer.from(args)]);
        return await wc.account().functionCall(nearconfig.contractName, 'call_js_contract', input, null, deposit ? nearApi.utils.format.parseNearAmount(deposit) : undefined);
    }
}

export async function logout() {
    const wc = await checkSignedin();
    await wc.signOut();
    console.log('logged out');
    clearWalletConnection();
}

'''
'''--- web/near/near.spec.js ---
import { checkSignedin, clearWalletConnection, createWalletConnection, getNearConfig } from "./near.js";

describe('near', () => {
    beforeEach(() => {
        const appRootElement = document.createElement('app-root');
        document.documentElement.appendChild(appRootElement);
    });
    afterEach(() => {
        document.querySelector('app-root').remove();
    });
    
    it('should sign out if loggedincontractname is not in localstorage', async () => {
        clearWalletConnection();
        localStorage.setItem('undefined_wallet_auth_key', '{"accountId":"psalomo.testnet","allKeys":["ed25519:eNRiyM1MhKyM3bof1XvAEoLfP75YgY8D3EbKfa1yMxb"]}');
        localStorage.setItem('near-api-js:keystore:psalomo.testnet:testnet', 'ed25519:QVuKCUH8AHt6WqxFnsjbaR8pSdjJBXAsnwfB83C5dgsmCMEP6EAmfULWm6bXWNQXCecGcsv2ATBeJKjJjFdEooG');
        localStorage.removeItem('loggedincontractname');

        const wc = await createWalletConnection();
        console.log(getNearConfig().contractName);

        console.log(wc.account().accountId);
        if (!wc._signOut) {
            wc._signOut = wc.signOut;
        }
        let signedOut = false;
        wc.signOut = () => {
            signedOut = true;
            wc._signOut();
        }

        const appRootElement = document.querySelector('app-root');

        let dialogObservedPromise = new Promise(resolve => {
            const observer = new MutationObserver((mutationsList, observer) => {
                const neardialog = appRootElement.shadowRoot.querySelector('near-dialogs');
                if (neardialog) {
                    observer.disconnect();
                    resolve(neardialog);
                }
            });
            observer.observe(appRootElement.shadowRoot, {
                childList: true,
                subtree: true,
                attributes: true
            });
        });

        checkSignedin();

        const neardialog = await dialogObservedPromise;

        expect(signedOut).to.eq(true);
        const loginButton = await new Promise(resolve => {
            const observer = new MutationObserver((mutationsList, observer) => {
                const loginButton = neardialog.shadowRoot.querySelector('mwc-button[dialogAction="login"]');
                if (loginButton) {
                    observer.disconnect();
                    resolve(loginButton);
                }
            });
            observer.observe(neardialog.shadowRoot, {
                childList: true,
                subtree: true,
                attributes: true
            });
        });
        expect(loginButton).to.not.be.undefined;
        clearWalletConnection();
    });

    it('should not sign out if loggedincontractname is in localstorage', async () => {
        localStorage.setItem('undefined_wallet_auth_key', '{"accountId":"psalomo.testnet","allKeys":["ed25519:eNRiyM1MhKyM3bof1XvAEoLfP75YgY8D3EbKfa1yMxb"]}');
        localStorage.setItem('near-api-js:keystore:psalomo.testnet:testnet', 'ed25519:QVuKCUH8AHt6WqxFnsjbaR8pSdjJBXAsnwfB83C5dgsmCMEP6EAmfULWm6bXWNQXCecGcsv2ATBeJKjJjFdEooG');
        localStorage.setItem('loggedincontractname', 'jsvm.testnet');

        const wc = await createWalletConnection();

        console.log(wc.account().accountId);
        if (!wc._signOut) {
            wc._signOut = wc.signOut;
        }
        let signedOut = false;
        wc.signOut = () => {
            signedOut = true;
            console.log('signout');
            wc._signOut();
        }

        expect((await checkSignedin()).isSignedIn()).to.be.true;
        expect(signedOut).to.not.be.true;
        clearWalletConnection();
    });
});
'''
'''--- web/package-lock.json ---
{
    "name": "web",
    "lockfileVersion": 2,
    "requires": true,
    "packages": {
        "": {
            "dependencies": {
                "@codemirror/basic-setup": "",
                "@codemirror/lang-javascript": "",
                "@codemirror/state": "",
                "@material/mwc-button": "",
                "@material/mwc-dialog": "",
                "@material/mwc-drawer": "",
                "@material/mwc-icon-button": "",
                "@material/mwc-linear-progress": "",
                "@material/mwc-list": "",
                "@material/mwc-select": "",
                "@material/mwc-snackbar": "",
                "@material/mwc-textfield": "",
                "@material/mwc-top-app-bar": ""
            },
            "devDependencies": {
                "@jspm/generator": "^1.0.0-beta.30",
                "@web/rollup-plugin-html": "^1.10.3",
                "@web/rollup-plugin-import-meta-assets": "^1.0.7",
                "chai": "^4.3.6",
                "http-server": "^14.1.0",
                "karma": "^6.3.19",
                "karma-chai": "^0.1.0",
                "karma-chrome-launcher": "^3.1.1",
                "karma-mocha": "^2.0.1",
                "mocha": "^9.2.2",
                "rollup": "^2.70.2",
                "rollup-plugin-terser": "^7.0.2"
            }
        },
        "node_modules/@ampproject/remapping": {
            "version": "2.1.2",
            "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.1.2.tgz",
            "integrity": "sha512-hoyByceqwKirw7w3Z7gnIIZC3Wx3J484Y3L/cMpXFbr7d9ZQj2mODrirNzcJa+SM3UlpWXYvKV4RlRpFXlWgXg==",
            "dev": true,
            "license": "Apache-2.0",
            "dependencies": {
                "@jridgewell/trace-mapping": "^0.3.0"
            },
            "engines": {
                "node": ">=6.0.0"
            }
        },
        "node_modules/@babel/code-frame": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.16.7.tgz",
            "integrity": "sha512-iAXqUn8IIeBTNd72xsFlgaXHkMBMt6y4HJp1tIaK465CWLT/fG1aqB7ykr95gHHmlBdGbFeWWfyB4NJJ0nmeIg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/highlight": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/compat-data": {
            "version": "7.17.7",
            "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.17.7.tgz",
            "integrity": "sha512-p8pdE6j0a29TNGebNm7NzYZWB3xVZJBZ7XGs42uAKzQo8VQ3F0By/cQCtUEABwIqw5zo6WA4NbmxsfzADzMKnQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/core": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.17.9.tgz",
            "integrity": "sha512-5ug+SfZCpDAkVp9SFIZAzlW18rlzsOcJGaetCjkySnrXXDUw9AR8cDUm1iByTmdWM6yxX6/zycaV76w3YTF2gw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@ampproject/remapping": "^2.1.0",
                "@babel/code-frame": "^7.16.7",
                "@babel/generator": "^7.17.9",
                "@babel/helper-compilation-targets": "^7.17.7",
                "@babel/helper-module-transforms": "^7.17.7",
                "@babel/helpers": "^7.17.9",
                "@babel/parser": "^7.17.9",
                "@babel/template": "^7.16.7",
                "@babel/traverse": "^7.17.9",
                "@babel/types": "^7.17.0",
                "convert-source-map": "^1.7.0",
                "debug": "^4.1.0",
                "gensync": "^1.0.0-beta.2",
                "json5": "^2.2.1",
                "semver": "^6.3.0"
            },
            "engines": {
                "node": ">=6.9.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/babel"
            }
        },
        "node_modules/@babel/generator": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.17.9.tgz",
            "integrity": "sha512-rAdDousTwxbIxbz5I7GEQ3lUip+xVCXooZNbsydCWs3xA7ZsYOv+CFRdzGxRX78BmQHu9B1Eso59AOZQOJDEdQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.17.0",
                "jsesc": "^2.5.1",
                "source-map": "^0.5.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/generator/node_modules/source-map": {
            "version": "0.5.7",
            "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
            "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w=",
            "dev": true,
            "license": "BSD-3-Clause",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/@babel/helper-annotate-as-pure": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-annotate-as-pure/-/helper-annotate-as-pure-7.16.7.tgz",
            "integrity": "sha512-s6t2w/IPQVTAET1HitoowRGXooX8mCgtuP5195wD/QJPV6wYjpujCGF7JuMODVX2ZAJOf1GT6DT9MHEZvLOFSw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-compilation-targets": {
            "version": "7.17.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.17.7.tgz",
            "integrity": "sha512-UFzlz2jjd8kroj0hmCFV5zr+tQPi1dpC2cRsDV/3IEW8bJfCPrPpmcSN6ZS8RqIq4LXcmpipCQFPddyFA5Yc7w==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/compat-data": "^7.17.7",
                "@babel/helper-validator-option": "^7.16.7",
                "browserslist": "^4.17.5",
                "semver": "^6.3.0"
            },
            "engines": {
                "node": ">=6.9.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0"
            }
        },
        "node_modules/@babel/helper-create-class-features-plugin": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/helper-create-class-features-plugin/-/helper-create-class-features-plugin-7.17.9.tgz",
            "integrity": "sha512-kUjip3gruz6AJKOq5i3nC6CoCEEF/oHH3cp6tOZhB+IyyyPyW0g1Gfsxn3mkk6S08pIA2y8GQh609v9G/5sHVQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-annotate-as-pure": "^7.16.7",
                "@babel/helper-environment-visitor": "^7.16.7",
                "@babel/helper-function-name": "^7.17.9",
                "@babel/helper-member-expression-to-functions": "^7.17.7",
                "@babel/helper-optimise-call-expression": "^7.16.7",
                "@babel/helper-replace-supers": "^7.16.7",
                "@babel/helper-split-export-declaration": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0"
            }
        },
        "node_modules/@babel/helper-environment-visitor": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-environment-visitor/-/helper-environment-visitor-7.16.7.tgz",
            "integrity": "sha512-SLLb0AAn6PkUeAfKJCCOl9e1R53pQlGAfc4y4XuMRZfqeMYLE0dM1LMhqbGAlGQY0lfw5/ohoYWAe9V1yibRag==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-function-name": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/helper-function-name/-/helper-function-name-7.17.9.tgz",
            "integrity": "sha512-7cRisGlVtiVqZ0MW0/yFB4atgpGLWEHUVYnb448hZK4x+vih0YO5UoS11XIYtZYqHd0dIPMdUSv8q5K4LdMnIg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/template": "^7.16.7",
                "@babel/types": "^7.17.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-hoist-variables": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-hoist-variables/-/helper-hoist-variables-7.16.7.tgz",
            "integrity": "sha512-m04d/0Op34H5v7pbZw6pSKP7weA6lsMvfiIAMeIvkY/R4xQtBSMFEigu9QTZ2qB/9l22vsxtM8a+Q8CzD255fg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-member-expression-to-functions": {
            "version": "7.17.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-member-expression-to-functions/-/helper-member-expression-to-functions-7.17.7.tgz",
            "integrity": "sha512-thxXgnQ8qQ11W2wVUObIqDL4p148VMxkt5T/qpN5k2fboRyzFGFmKsTGViquyM5QHKUy48OZoca8kw4ajaDPyw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.17.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-module-imports": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.16.7.tgz",
            "integrity": "sha512-LVtS6TqjJHFc+nYeITRo6VLXve70xmq7wPhWTqDJusJEgGmkAACWwMiTNrvfoQo6hEhFwAIixNkvB0jPXDL8Wg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-module-transforms": {
            "version": "7.17.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.17.7.tgz",
            "integrity": "sha512-VmZD99F3gNTYB7fJRDTi+u6l/zxY0BE6OIxPSU7a50s6ZUQkHwSDmV92FfM+oCG0pZRVojGYhkR8I0OGeCVREw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-environment-visitor": "^7.16.7",
                "@babel/helper-module-imports": "^7.16.7",
                "@babel/helper-simple-access": "^7.17.7",
                "@babel/helper-split-export-declaration": "^7.16.7",
                "@babel/helper-validator-identifier": "^7.16.7",
                "@babel/template": "^7.16.7",
                "@babel/traverse": "^7.17.3",
                "@babel/types": "^7.17.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-optimise-call-expression": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-optimise-call-expression/-/helper-optimise-call-expression-7.16.7.tgz",
            "integrity": "sha512-EtgBhg7rd/JcnpZFXpBy0ze1YRfdm7BnBX4uKMBd3ixa3RGAE002JZB66FJyNH7g0F38U05pXmA5P8cBh7z+1w==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-plugin-utils": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.16.7.tgz",
            "integrity": "sha512-Qg3Nk7ZxpgMrsox6HreY1ZNKdBq7K72tDSliA6dCl5f007jR4ne8iD5UzuNnCJH2xBf2BEEVGr+/OL6Gdp7RxA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-replace-supers": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-replace-supers/-/helper-replace-supers-7.16.7.tgz",
            "integrity": "sha512-y9vsWilTNaVnVh6xiJfABzsNpgDPKev9HnAgz6Gb1p6UUwf9NepdlsV7VXGCftJM+jqD5f7JIEubcpLjZj5dBw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-environment-visitor": "^7.16.7",
                "@babel/helper-member-expression-to-functions": "^7.16.7",
                "@babel/helper-optimise-call-expression": "^7.16.7",
                "@babel/traverse": "^7.16.7",
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-simple-access": {
            "version": "7.17.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-simple-access/-/helper-simple-access-7.17.7.tgz",
            "integrity": "sha512-txyMCGroZ96i+Pxr3Je3lzEJjqwaRC9buMUgtomcrLe5Nd0+fk1h0LLA+ixUF5OW7AhHuQ7Es1WcQJZmZsz2XA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.17.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-split-export-declaration": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-split-export-declaration/-/helper-split-export-declaration-7.16.7.tgz",
            "integrity": "sha512-xbWoy/PFoxSWazIToT9Sif+jJTlrMcndIsaOKvTA6u7QEo7ilkRZpjew18/W3c7nm8fXdUDXh02VXTbZ0pGDNw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-validator-identifier": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.16.7.tgz",
            "integrity": "sha512-hsEnFemeiW4D08A5gUAZxLBTXpZ39P+a+DGDsHw1yxqyQ/jzFEnxf5uTEGp+3bzAbNOxU1paTgYS4ECU/IgfDw==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helper-validator-option": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.16.7.tgz",
            "integrity": "sha512-TRtenOuRUVo9oIQGPC5G9DgK4743cdxvtOw0weQNpZXaS16SCBi5MNjZF8vba3ETURjZpTbVn7Vvcf2eAwFozQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/helpers": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.17.9.tgz",
            "integrity": "sha512-cPCt915ShDWUEzEp3+UNRktO2n6v49l5RSnG9M5pS24hA+2FAc5si+Pn1i4VVbQQ+jh+bIZhPFQOJOzbrOYY1Q==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/template": "^7.16.7",
                "@babel/traverse": "^7.17.9",
                "@babel/types": "^7.17.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/highlight": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.17.9.tgz",
            "integrity": "sha512-J9PfEKCbFIv2X5bjTMiZu6Vf341N05QIY+d6FvVKynkG1S7G0j3I0QoRtWIrXhZ+/Nlb5Q0MzqL7TokEJ5BNHg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-validator-identifier": "^7.16.7",
                "chalk": "^2.0.0",
                "js-tokens": "^4.0.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/highlight/node_modules/ansi-styles": {
            "version": "3.2.1",
            "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
            "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "color-convert": "^1.9.0"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/@babel/highlight/node_modules/chalk": {
            "version": "2.4.2",
            "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
            "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ansi-styles": "^3.2.1",
                "escape-string-regexp": "^1.0.5",
                "supports-color": "^5.3.0"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/@babel/highlight/node_modules/color-convert": {
            "version": "1.9.3",
            "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
            "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "color-name": "1.1.3"
            }
        },
        "node_modules/@babel/highlight/node_modules/color-name": {
            "version": "1.1.3",
            "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
            "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@babel/highlight/node_modules/escape-string-regexp": {
            "version": "1.0.5",
            "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
            "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.8.0"
            }
        },
        "node_modules/@babel/highlight/node_modules/has-flag": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
            "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/@babel/highlight/node_modules/supports-color": {
            "version": "5.5.0",
            "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
            "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "has-flag": "^3.0.0"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/@babel/parser": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.17.9.tgz",
            "integrity": "sha512-vqUSBLP8dQHFPdPi9bc5GK9vRkYHJ49fsZdtoJ8EQ8ibpwk5rPKfvNIwChB0KVXcIjcepEBBd2VHC5r9Gy8ueg==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "parser": "bin/babel-parser.js"
            },
            "engines": {
                "node": ">=6.0.0"
            }
        },
        "node_modules/@babel/plugin-syntax-typescript": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-typescript/-/plugin-syntax-typescript-7.16.7.tgz",
            "integrity": "sha512-YhUIJHHGkqPgEcMYkPCKTyGUdoGKWtopIycQyjJH8OjvRgOYsXsaKehLVPScKJWAULPxMa4N1vCe6szREFlZ7A==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/plugin-transform-typescript": {
            "version": "7.16.8",
            "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typescript/-/plugin-transform-typescript-7.16.8.tgz",
            "integrity": "sha512-bHdQ9k7YpBDO2d0NVfkj51DpQcvwIzIusJ7mEUaMlbZq3Kt/U47j24inXZHQ5MDiYpCs+oZiwnXyKedE8+q7AQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-create-class-features-plugin": "^7.16.7",
                "@babel/helper-plugin-utils": "^7.16.7",
                "@babel/plugin-syntax-typescript": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/preset-typescript": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/preset-typescript/-/preset-typescript-7.16.7.tgz",
            "integrity": "sha512-WbVEmgXdIyvzB77AQjGBEyYPZx+8tTsO50XtfozQrkW8QB2rLJpH2lgx0TRw5EJrBxOZQ+wCcyPVQvS8tjEHpQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-plugin-utils": "^7.16.7",
                "@babel/helper-validator-option": "^7.16.7",
                "@babel/plugin-transform-typescript": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            },
            "peerDependencies": {
                "@babel/core": "^7.0.0-0"
            }
        },
        "node_modules/@babel/template": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.16.7.tgz",
            "integrity": "sha512-I8j/x8kHUrbYRTUxXrrMbfCa7jxkE7tZre39x3kjr9hvI82cK1FfqLygotcWN5kdPGWcLdWMHpSBavse5tWw3w==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/code-frame": "^7.16.7",
                "@babel/parser": "^7.16.7",
                "@babel/types": "^7.16.7"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/traverse": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.17.9.tgz",
            "integrity": "sha512-PQO8sDIJ8SIwipTPiR71kJQCKQYB5NGImbOviK8K+kg5xkNSYXLBupuX9QhatFowrsvo9Hj8WgArg3W7ijNAQw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/code-frame": "^7.16.7",
                "@babel/generator": "^7.17.9",
                "@babel/helper-environment-visitor": "^7.16.7",
                "@babel/helper-function-name": "^7.17.9",
                "@babel/helper-hoist-variables": "^7.16.7",
                "@babel/helper-split-export-declaration": "^7.16.7",
                "@babel/parser": "^7.17.9",
                "@babel/types": "^7.17.0",
                "debug": "^4.1.0",
                "globals": "^11.1.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@babel/types": {
            "version": "7.17.0",
            "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.17.0.tgz",
            "integrity": "sha512-TmKSNO4D5rzhL5bjWFcVHHLETzfQ/AmbKpKPOSjlP0WoHZ6L911fgoOKY4Alp/emzG4cHJdyN49zpgkbXFEHHw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/helper-validator-identifier": "^7.16.7",
                "to-fast-properties": "^2.0.0"
            },
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/@codemirror/autocomplete": {
            "version": "0.20.1",
            "resolved": "https://registry.npmjs.org/@codemirror/autocomplete/-/autocomplete-0.20.1.tgz",
            "integrity": "sha512-rWDAkE1Qn9O4LsV8tAm/KlzzqdQLaIxqDOLhVYja3rKQIWebD3dixIzg9BAKpjt+0dIaDwtIp3yinD9MefgbQQ==",
            "dependencies": {
                "@codemirror/language": "^0.20.0",
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0",
                "@lezer/common": "^0.16.0"
            }
        },
        "node_modules/@codemirror/basic-setup": {
            "version": "0.20.0",
            "resolved": "https://registry.npmjs.org/@codemirror/basic-setup/-/basic-setup-0.20.0.tgz",
            "integrity": "sha512-W/ERKMLErWkrVLyP5I8Yh8PXl4r+WFNkdYVSzkXYPQv2RMPSkWpr2BgggiSJ8AHF/q3GuApncDD8I4BZz65fyg==",
            "dependencies": {
                "@codemirror/autocomplete": "^0.20.0",
                "@codemirror/commands": "^0.20.0",
                "@codemirror/language": "^0.20.0",
                "@codemirror/lint": "^0.20.0",
                "@codemirror/search": "^0.20.0",
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0"
            }
        },
        "node_modules/@codemirror/commands": {
            "version": "0.20.0",
            "resolved": "https://registry.npmjs.org/@codemirror/commands/-/commands-0.20.0.tgz",
            "integrity": "sha512-v9L5NNVA+A9R6zaFvaTbxs30kc69F6BkOoiEbeFw4m4I0exmDEKBILN6mK+GksJtvTzGBxvhAPlVFTdQW8GB7Q==",
            "dependencies": {
                "@codemirror/language": "^0.20.0",
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0",
                "@lezer/common": "^0.16.0"
            }
        },
        "node_modules/@codemirror/lang-javascript": {
            "version": "0.20.0",
            "resolved": "https://registry.npmjs.org/@codemirror/lang-javascript/-/lang-javascript-0.20.0.tgz",
            "integrity": "sha512-Wawq5+o1DlWtsqAyaa9NkiSXNT7geFcfdUael0hIQdM7P23gkQaD+xgZcyQP6QvPxVAdnY4VIWHFzFAqBti+WQ==",
            "dependencies": {
                "@codemirror/autocomplete": "^0.20.0",
                "@codemirror/language": "^0.20.0",
                "@codemirror/lint": "^0.20.0",
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0",
                "@lezer/javascript": "^0.16.0"
            }
        },
        "node_modules/@codemirror/language": {
            "version": "0.20.2",
            "resolved": "https://registry.npmjs.org/@codemirror/language/-/language-0.20.2.tgz",
            "integrity": "sha512-WB3Bnuusw0xhVvhBocieYKwJm04SOk5bPoOEYksVHKHcGHFOaYaw+eZVxR4gIqMMcGzOIUil0FsCmFk8yrhHpw==",
            "dependencies": {
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0",
                "@lezer/common": "^0.16.0",
                "@lezer/highlight": "^0.16.0",
                "@lezer/lr": "^0.16.0",
                "style-mod": "^4.0.0"
            }
        },
        "node_modules/@codemirror/lint": {
            "version": "0.20.2",
            "resolved": "https://registry.npmjs.org/@codemirror/lint/-/lint-0.20.2.tgz",
            "integrity": "sha512-xEH3wlzoFLEhPEeMVRNoQIhoTCMEtXhVxemGh3FYjLfl/CL3B2Wz+CU7ooP5SKhN1le7JqUNSfiTArFP+IzFuw==",
            "dependencies": {
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.2",
                "crelt": "^1.0.5"
            }
        },
        "node_modules/@codemirror/search": {
            "version": "0.20.1",
            "resolved": "https://registry.npmjs.org/@codemirror/search/-/search-0.20.1.tgz",
            "integrity": "sha512-ROe6gRboQU5E4z6GAkNa2kxhXqsGNbeLEisbvzbOeB7nuDYXUZ70vGIgmqPu0tB+1M3F9yWk6W8k2vrFpJaD4Q==",
            "dependencies": {
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0",
                "crelt": "^1.0.5"
            }
        },
        "node_modules/@codemirror/state": {
            "version": "0.20.0",
            "resolved": "https://registry.npmjs.org/@codemirror/state/-/state-0.20.0.tgz",
            "integrity": "sha512-R3XrAWCS5Xm9lx+4pDET4EUPEg+8bDfAa5zoOFIhx+VChsfew9Vy33dAjCXS5ES4Q8UecW4WM4UudmUFpZ+86A=="
        },
        "node_modules/@codemirror/view": {
            "version": "0.20.6",
            "resolved": "https://registry.npmjs.org/@codemirror/view/-/view-0.20.6.tgz",
            "integrity": "sha512-k/Enz4HMcST5Waom2r8y8VtiJfgnU5+Y/pNVO45eIhsRH+0LYtAMgJqqqspWVv1apOuMzmlttw6keaPvkloakg==",
            "dependencies": {
                "@codemirror/state": "^0.20.0",
                "style-mod": "^4.0.0",
                "w3c-keyname": "^2.2.4"
            }
        },
        "node_modules/@colors/colors": {
            "version": "1.5.0",
            "resolved": "https://registry.npmjs.org/@colors/colors/-/colors-1.5.0.tgz",
            "integrity": "sha512-ooWCrlZP11i8GImSjTHYHLkvFDP48nS4+204nGb1RiX/WXYHmJA2III9/e2DWVabCESdW7hBAEzHRqUn9OUVvQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.1.90"
            }
        },
        "node_modules/@gar/promisify": {
            "version": "1.1.3",
            "resolved": "https://registry.npmjs.org/@gar/promisify/-/promisify-1.1.3.tgz",
            "integrity": "sha512-k2Ty1JcVojjJFwrg/ThKi2ujJ7XNLYaFGNB/bWT9wGR+oSMJHMa5w+CUq6p/pVrKeNNgA7pCqEcjSnHVoqJQFw==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@improbable-eng/grpc-web": {
            "version": "0.14.1",
            "resolved": "https://registry.npmjs.org/@improbable-eng/grpc-web/-/grpc-web-0.14.1.tgz",
            "integrity": "sha512-XaIYuunepPxoiGVLLHmlnVminUGzBTnXr8Wv7khzmLWbNw4TCwJKX09GSMJlKhu/TRk6gms0ySFxewaETSBqgw==",
            "dev": true,
            "license": "Apache-2.0",
            "dependencies": {
                "browser-headers": "^0.4.1"
            },
            "peerDependencies": {
                "google-protobuf": "^3.14.0"
            }
        },
        "node_modules/@ipld/dag-cbor": {
            "version": "7.0.1",
            "resolved": "https://registry.npmjs.org/@ipld/dag-cbor/-/dag-cbor-7.0.1.tgz",
            "integrity": "sha512-XqG8VEzHjQDC/Qcy5Gyf1kvAav5VuAugc6c7VtdaRLI+3d8lJrUP3F76GYJNNXuEnRZ58cCBnNNglkIGTdg1+A==",
            "dev": true,
            "license": "(Apache-2.0 AND MIT)",
            "dependencies": {
                "cborg": "^1.6.0",
                "multiformats": "^9.5.4"
            }
        },
        "node_modules/@ipld/dag-json": {
            "version": "8.0.9",
            "resolved": "https://registry.npmjs.org/@ipld/dag-json/-/dag-json-8.0.9.tgz",
            "integrity": "sha512-NNKHmgHxc2zOEaB8qOUpAb2UK1vcEE/rBeh018Da/RzXE7N8GwiTJLRZ3Fe/G4fsiis67G0sagRz/YNQcANRsQ==",
            "dev": true,
            "license": "(Apache-2.0 AND MIT)",
            "dependencies": {
                "cborg": "^1.5.4",
                "multiformats": "^9.5.4"
            }
        },
        "node_modules/@ipld/dag-pb": {
            "version": "2.1.16",
            "resolved": "https://registry.npmjs.org/@ipld/dag-pb/-/dag-pb-2.1.16.tgz",
            "integrity": "sha512-5+A87ZsKZ2yEEjtW6LIzTgDJcm6O24d0lmXlubwtMblI5ZB+aTw7PH6kjc8fM6pbnNtVg4Y+c+WZ3zCxdesIBg==",
            "dev": true,
            "license": "(Apache-2.0 AND MIT)",
            "dependencies": {
                "multiformats": "^9.5.4"
            }
        },
        "node_modules/@jridgewell/resolve-uri": {
            "version": "3.0.6",
            "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.0.6.tgz",
            "integrity": "sha512-R7xHtBSNm+9SyvpJkdQl+qrM3Hm2fea3Ef197M3mUug+v+yR+Rhfbs7PBtcBUVnIWJ4JcAdjvij+c8hXS9p5aw==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.0.0"
            }
        },
        "node_modules/@jridgewell/sourcemap-codec": {
            "version": "1.4.11",
            "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.4.11.tgz",
            "integrity": "sha512-Fg32GrJo61m+VqYSdRSjRXMjQ06j8YIYfcTqndLYVAaHmroZHLJZCydsWBOTDqXS2v+mjxohBWEMfg97GXmYQg==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@jridgewell/trace-mapping": {
            "version": "0.3.9",
            "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
            "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@jridgewell/resolve-uri": "^3.0.3",
                "@jridgewell/sourcemap-codec": "^1.4.10"
            }
        },
        "node_modules/@jspm/core": {
            "version": "2.0.0-beta.24",
            "resolved": "https://registry.npmjs.org/@jspm/core/-/core-2.0.0-beta.24.tgz",
            "integrity": "sha512-a4Bo/80Z6CoJNor5ldgs6002utmmbttP4JYd/FJ0Ob2fVdf6O6ha5SORBCqrnDnBvMc1TlrHY7dCfat5+H0a6A==",
            "dev": true
        },
        "node_modules/@jspm/generator": {
            "version": "1.0.0-beta.30",
            "resolved": "https://registry.npmjs.org/@jspm/generator/-/generator-1.0.0-beta.30.tgz",
            "integrity": "sha512-cXl1UqKVo8k+tJPrUAHNy6imgzo1+fYY82uOOq7MOHR/TJ8B0KY8m5xxh14KlW3CONEpkpqcHngX/Sk39VH5VQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/core": "^7.15.8",
                "@babel/preset-typescript": "^7.15.0",
                "@jspm/core": "^2.0.0-beta.8",
                "@jspm/import-map": "^0.3.1",
                "es-module-lexer": "^0.10.4",
                "ipfs-client": "^0.7.1",
                "make-fetch-happen": "^8.0.3",
                "sver": "^1.8.3",
                "typescript": "^4.3.5"
            }
        },
        "node_modules/@jspm/import-map": {
            "version": "0.3.3",
            "resolved": "https://registry.npmjs.org/@jspm/import-map/-/import-map-0.3.3.tgz",
            "integrity": "sha512-hD9CIedeViPfUHEs8mmjzAhr/WXR+tsjfC+Evq6GAJMB3wxlW4amUNGgpwRNqfSvd2izA+ekxW9X5FFAJJKJEQ==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@lezer/common": {
            "version": "0.16.0",
            "resolved": "https://registry.npmjs.org/@lezer/common/-/common-0.16.0.tgz",
            "integrity": "sha512-H6sPCku+asKWYaNjwfQ1Uvcay9UP1Pdzu4qpy8GtRZ0cKT2AAGnj9MQGiRtY18MDntvhYRJxNGv7FNWOSV/e8A=="
        },
        "node_modules/@lezer/highlight": {
            "version": "0.16.0",
            "resolved": "https://registry.npmjs.org/@lezer/highlight/-/highlight-0.16.0.tgz",
            "integrity": "sha512-iE5f4flHlJ1g1clOStvXNLbORJoiW4Kytso6ubfYzHnaNo/eo5SKhxs4wv/rtvwZQeZrK3we8S9SyA7OGOoRKQ==",
            "dependencies": {
                "@lezer/common": "^0.16.0"
            }
        },
        "node_modules/@lezer/javascript": {
            "version": "0.16.0",
            "resolved": "https://registry.npmjs.org/@lezer/javascript/-/javascript-0.16.0.tgz",
            "integrity": "sha512-kDcwX3QMFKVd7VJwlYTeTNtcj3/gXQEDa7cQzXXsFMvTGV/RTDq0r8agTpZu0zBc1RUZkVILusd1Cluz3STRqw==",
            "dependencies": {
                "@lezer/highlight": "^0.16.0",
                "@lezer/lr": "^0.16.0"
            }
        },
        "node_modules/@lezer/lr": {
            "version": "0.16.3",
            "resolved": "https://registry.npmjs.org/@lezer/lr/-/lr-0.16.3.tgz",
            "integrity": "sha512-pau7um4eAw94BEuuShUIeQDTf3k4Wt6oIUOYxMmkZgDHdqtIcxWND4LRxi8nI9KuT4I1bXQv67BCapkxt7Ywqw==",
            "dependencies": {
                "@lezer/common": "^0.16.0"
            }
        },
        "node_modules/@lit/reactive-element": {
            "version": "1.3.2",
            "resolved": "https://registry.npmjs.org/@lit/reactive-element/-/reactive-element-1.3.2.tgz",
            "integrity": "sha512-A2e18XzPMrIh35nhIdE4uoqRzoIpEU5vZYuQN4S3Ee1zkGdYC27DP12pewbw/RLgPHzaE4kx/YqxMzebOpm0dA=="
        },
        "node_modules/@material/animation": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/animation/-/animation-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-GBuR4VmcTQW1D0lPXEosf5Giho72LLbyGIydWGtaEUtLJoive/D9kFkwTN4Fsyt9Kkl7hbhs35vrNe6QkAH4/Q==",
            "dependencies": {
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/base": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/base/-/base-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-UJKbXwZtkrA3sfQDmj8Zbw1Q3Tqtl6KdfVFws95Yf7TCUgTFzbZI/FSx1w7dVugQPOEnIBuZnzqZam/MtHkx4w==",
            "dependencies": {
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/button": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/button/-/button-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-IPBAByKpQjrWNVmAWx5VCTCLnOw4ymbLsbHmBkLiDgcLPs1EtwYnKKIwQ+/t3bV02OShUdMiyboL8V/C0gMS1A==",
            "dependencies": {
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/focus-ring": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/tokens": "14.0.0-canary.53b3cad2f.0",
                "@material/touch-target": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/density": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/density/-/density-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-Eh/vZ3vVyqtpylg5Ci33qlgtToS4H1/ppd450Ib3tcdISIoodgijYY0w4XsRvrnZgbI/h/1STFdLxdzS0UNuFw==",
            "dependencies": {
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/dialog": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/dialog/-/dialog-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-yiG2nlVKTW0Ro3CF8Z/MVpTwSyG/8Kio3AaTUbeQdbjt5r692s4x5Yhd8m1IjEQKUeulY4CndvIbCUwZ8/G2PA==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/button": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/icon-button": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/tokens": "14.0.0-canary.53b3cad2f.0",
                "@material/touch-target": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/dom": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/dom/-/dom-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-aR+rfncF6oi2ivdOlKSJI4UXwNzWV5rXM88MLDoSJF1D7lXxhAKhge+tMUBodWGV/q0+FnXLuVAa0WYTrKjo+A==",
            "dependencies": {
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/drawer": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/drawer/-/drawer-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-MXzRGq7NoONgbHa+AhAu4HvOUA9V37nSsY4g4Alita08UqRAvvFFr4K1CF9GI2K9pLCpyQv1UbN0Lw5b78HrVQ==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/list": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/elevation": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/elevation/-/elevation-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-3h+EkR588RMZ5TSNQ4UeXD1FOBnL3ABQix0DQIGwtNJCqSMoPndT/oJEFvwQbTkZNDbFIKN9p1Q7/KuFPVY8Pw==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/feature-targeting": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/feature-targeting/-/feature-targeting-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-fn7Af3PRyARtNeYqtjxXmE3Y/dCpnpQVWWys57MqiGR/nvc6qpgOfJ6rOdcu/MrOysOE/oebTUDmDnTmwpe9Hw==",
            "dependencies": {
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/floating-label": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/floating-label/-/floating-label-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-gHZUTTVKnP+Zjz4l9IT/G89NPmypn5FlTGLWKKqXbuQphr37rsKFR3Y80SJxULRyMDnAdKSxuZwiXLFKQz9KlA==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/focus-ring": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/focus-ring/-/focus-ring-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-exPX5VrjQimipBwgcFDGRiEE783sOBgpkFui59A6i6iGvS2UrLHlYY2E65fyyyQnD1f/rv4Po1OOnCesE1kulg==",
            "dependencies": {
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0"
            }
        },
        "node_modules/@material/icon-button": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/icon-button/-/icon-button-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-BFdj3CP0JXHC/F2bDmpmzWhum4fkzIDgCCavvnpE/KcCbr0AaoSULRde+LtqvbdLIYW20cXhvjinIOlRhSOshA==",
            "dependencies": {
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/focus-ring": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/touch-target": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/line-ripple": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/line-ripple/-/line-ripple-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-k8f8uuDwnSqZZ98CzbYtQVtxlp1ryUup9nd2uobo3kiqQNlQfXdGkVjuCXcla0OPiKFizNn7dS6Kl/j6L09XUA==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/linear-progress": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/linear-progress/-/linear-progress-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-QqkDBcqX7TMt3zQn51LgS7K0y13rJ4ppMQL1f2uYBhDOov8nqndlaXw456KYE9RhU39JrLzVQlaAbU3eecVb/Q==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/progress-indicator": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/list": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/list/-/list-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-mkMpltSKAYLBtFnTTCk/mQIDzwxF/VLh1gh59ehOtmRXt7FvTz83RoAa4tqe53hpVrbX4HoLDBu+vILhq/wkjw==",
            "dependencies": {
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/menu": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/menu/-/menu-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-MmYKVrMIqOtP3TN4vdrrnQrS8P81+tMaA6bKiT9V79R1U6+mKsBYTzaLtLbzyem5vF8O0q7bSwyPwhWPtJr75Q==",
            "dependencies": {
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/list": "14.0.0-canary.53b3cad2f.0",
                "@material/menu-surface": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/menu-surface": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/menu-surface/-/menu-surface-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-IQWb/n15FpLnn+kHp0EqzLE+UoWSPumq3eze2QifiowvGb37bNFR9oSe7CaOzPMrHdkrZ5SBWnDU41wPZN5kOg==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/mwc-base": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-base/-/mwc-base-0.26.1.tgz",
            "integrity": "sha512-YcVvWwSoDwQAxjvYevhZgtyXIIPuMeTnw9MtEj+Hv7NJizT88hoTsPmKpwM+X58cIY2SPo0y/tHfgmblWntibQ==",
            "dependencies": {
                "@material/base": "=14.0.0-canary.53b3cad2f.0",
                "@material/dom": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-button": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-button/-/mwc-button-0.26.1.tgz",
            "integrity": "sha512-ptgAmg50k+71M6ynfv6QeNaBnX7X/EAnhOjxZqhDHrKwZcFuuQyFJJ6r4ypjc21eCSPS7o6xRqJyI4PPpf3xkA==",
            "dependencies": {
                "@material/mwc-icon": "^0.26.1",
                "@material/mwc-ripple": "^0.26.1",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-checkbox": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-checkbox/-/mwc-checkbox-0.26.1.tgz",
            "integrity": "sha512-2euxVZ0zksAQ/JVkOznUOGJKfbxq+m3ijRTh44b8fQyERBobm5QtWXbhXxV9YCesqFQSbj5M3qDw6Nm5MRKluw==",
            "dependencies": {
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-ripple": "^0.26.1",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-dialog": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-dialog/-/mwc-dialog-0.26.1.tgz",
            "integrity": "sha512-QI9OkD0ZXZRyxA9I3ZbRjn4iRdDh/u+ZtcfZtIhKKgm3S0pkHAxndNlygq8DHQgwCO5HxMcmEot7voAdDtpfoQ==",
            "dependencies": {
                "@material/dialog": "=14.0.0-canary.53b3cad2f.0",
                "@material/dom": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-button": "^0.26.1",
                "blocking-elements": "^0.1.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1",
                "wicg-inert": "^3.0.0"
            }
        },
        "node_modules/@material/mwc-drawer": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-drawer/-/mwc-drawer-0.26.1.tgz",
            "integrity": "sha512-KzyfokeKN9WGEepcou9kkMLnGc6H78GARpmLbqm0o5oQbDbJLlD/x7ENSgCU+HpRpmCo8eEkU87YHBhJI0yQbA==",
            "dependencies": {
                "@material/drawer": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "blocking-elements": "^0.1.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1",
                "wicg-inert": "^3.0.0"
            }
        },
        "node_modules/@material/mwc-floating-label": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-floating-label/-/mwc-floating-label-0.26.1.tgz",
            "integrity": "sha512-iPKOWAgypL+UNZWa0jNE2P/929QEbHqrxr7BFNKpSvO/t6pX7672g1gOny7+8Dnnt+a4kVlYjWTMAw9qjOkLlg==",
            "dependencies": {
                "@material/floating-label": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-icon": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-icon/-/mwc-icon-0.26.1.tgz",
            "integrity": "sha512-RPcVPn+5p6hA2HjX/0wkeHQuxkJKgXMg47ffw+vhIw28qM8mprSv13hpUgrghb0f7xBvuPhf/kLb37V4xkRfwg==",
            "dependencies": {
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-icon-button": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-icon-button/-/mwc-icon-button-0.26.1.tgz",
            "integrity": "sha512-pa3zFSH1wV7j8dH1i5NfKL0mKqQsan+SiD+lkW39Al4NeCrNoWN9wJY0mSiwrlbVnxOub8r2kWINCpTHBoluJg==",
            "dependencies": {
                "@material/mwc-ripple": "^0.26.1",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-line-ripple": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-line-ripple/-/mwc-line-ripple-0.26.1.tgz",
            "integrity": "sha512-pTWYurvptGGZI5OP3SXJPNQrsri+1tM8CUGTuTLaLVTSIyvMcUiTzfNPCyTmkjndoCsbrPYjPzY8f/wiU4mZrA==",
            "dependencies": {
                "@material/line-ripple": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-linear-progress": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-linear-progress/-/mwc-linear-progress-0.26.1.tgz",
            "integrity": "sha512-UNPrRCb6y+m5FU8NDOLl7+41RXygeQKvHUKXU6R2UMN8NSOiq/FUAEYZZBM3SHCMeaRwltY5uWhBy5dojoPjIw==",
            "dependencies": {
                "@material/linear-progress": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/theme": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-list": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-list/-/mwc-list-0.26.1.tgz",
            "integrity": "sha512-1jYG0/VCJhUjjJQSDvjvMiTryOtKk5TEzpkTO/kguhdN9j6vk0XU/p/LhnyxV0+fQei754AO3Tos5Dv0FvEUOQ==",
            "dependencies": {
                "@material/base": "=14.0.0-canary.53b3cad2f.0",
                "@material/dom": "=14.0.0-canary.53b3cad2f.0",
                "@material/list": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-checkbox": "^0.26.1",
                "@material/mwc-radio": "^0.26.1",
                "@material/mwc-ripple": "^0.26.1",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-menu": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-menu/-/mwc-menu-0.26.1.tgz",
            "integrity": "sha512-zdLalm1vabFU2+ml53B7N88OoJo+yygXGra94GluCPLCRBV6Oswdou7b8cqEyVEJ6McbeiegKwO0j8k3mEd4zw==",
            "dependencies": {
                "@material/menu": "=14.0.0-canary.53b3cad2f.0",
                "@material/menu-surface": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-list": "^0.26.1",
                "@material/shape": "=14.0.0-canary.53b3cad2f.0",
                "@material/theme": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-notched-outline": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-notched-outline/-/mwc-notched-outline-0.26.1.tgz",
            "integrity": "sha512-3vsbnNk9dzyATANoL+nv7nwGvvzgb4tQcMbjP023qmpkelV/Ci2jP8nV+UDDepJcZ6KjRJo1eUAroznp4T/rKA==",
            "dependencies": {
                "@material/mwc-base": "^0.26.1",
                "@material/notched-outline": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-radio": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-radio/-/mwc-radio-0.26.1.tgz",
            "integrity": "sha512-KWEcwVKbZS0wIfxOk8AqFNZocnP2f3JjnO/m2y6RWBUUrSgIlxavfz3J5MiwDC0JjYI1jUmheivcKrlZRNxnSA==",
            "dependencies": {
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-ripple": "^0.26.1",
                "@material/radio": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-ripple": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-ripple/-/mwc-ripple-0.26.1.tgz",
            "integrity": "sha512-hBeC2S7TSYLmHetXbtu52/EZFzvAqrQk5skIV0aUZeZvywTJWRVoc5OavDjsJYuKxDnSECMnkIt8+l8WC48chg==",
            "dependencies": {
                "@material/dom": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/ripple": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-select": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-select/-/mwc-select-0.26.1.tgz",
            "integrity": "sha512-glqhi0HeNtm7LgVNW/Vxk2QLm76mjkY0Sw5CFkcedMcjqkoj3fiuTtcMkoQlb4/MeCqgFZyO0xxCOOz9LSNF4A==",
            "dependencies": {
                "@material/dom": "=14.0.0-canary.53b3cad2f.0",
                "@material/floating-label": "=14.0.0-canary.53b3cad2f.0",
                "@material/line-ripple": "=14.0.0-canary.53b3cad2f.0",
                "@material/list": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-floating-label": "^0.26.1",
                "@material/mwc-icon": "^0.26.1",
                "@material/mwc-line-ripple": "^0.26.1",
                "@material/mwc-list": "^0.26.1",
                "@material/mwc-menu": "^0.26.1",
                "@material/mwc-notched-outline": "^0.26.1",
                "@material/select": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-snackbar": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-snackbar/-/mwc-snackbar-0.26.1.tgz",
            "integrity": "sha512-933enXy1hxO769muJ2D2q8FtT7cnrlpOvpVZ2a6j2hapZi55o26Qvlna+PxjUYPM695n+7dR6R5+4zOzbYP03Q==",
            "dependencies": {
                "@material/mwc-base": "^0.26.1",
                "@material/snackbar": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-textfield": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-textfield/-/mwc-textfield-0.26.1.tgz",
            "integrity": "sha512-Kdb31R2PROUOM7hpyjb+pY4WIOu6BQSEQKeVy4hnLqwvhe14nTvnn9I7Fkkz4t9SNWPh3G+DQsAx9vhPuCgUyQ==",
            "dependencies": {
                "@material/floating-label": "=14.0.0-canary.53b3cad2f.0",
                "@material/line-ripple": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-floating-label": "^0.26.1",
                "@material/mwc-line-ripple": "^0.26.1",
                "@material/mwc-notched-outline": "^0.26.1",
                "@material/textfield": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/mwc-top-app-bar": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-top-app-bar/-/mwc-top-app-bar-0.26.1.tgz",
            "integrity": "sha512-zAASmr8Dqf+4RyFGbaF4JvU5AYQn0yfeRuOcXlzcpUQlLgJqYp6plMLdPjVa+Ek3LBQGItQrGoDSX3y2mmkncw==",
            "dependencies": {
                "@material/mwc-base": "^0.26.1",
                "@material/top-app-bar": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "node_modules/@material/notched-outline": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/notched-outline/-/notched-outline-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-3ByiPOC/wWQmFKfgJS98kb5/6v92n7uIfJ6v6sryKJlJCJn39qfpGcCM5RpRIws1RET1s1zBJT2JDwYeu/hM5A==",
            "dependencies": {
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/floating-label": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/progress-indicator": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/progress-indicator/-/progress-indicator-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-vW0oZK70QOpAarip95ueCQ/I3kBClcWjxsc0F0QjkqT76DOVXpjnZ4XoRRyq9eMpwLqlKLTecrsSNpmqwwF1Dg==",
            "dependencies": {
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/radio": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/radio/-/radio-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-V/AgWEOuHFoh9d4Gq1rqBZnKSGtMLQNh23Bwrv0c1FhPqFvUpwt9jR3SVwhJk5gvQQWGy9p3iiGc9QCJ+0+P8Q==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/focus-ring": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/touch-target": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/ripple": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/ripple/-/ripple-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-6g2G62vd8DsMuIUSXlRrzb98qkZ4o8ZREknNwNP2zaLQEOkJ//4j9HaqDt98/3LIjUTY9UIVFTQENiMmlwKHYQ==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/rtl": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/rtl/-/rtl-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-f08LT0HSa0WYU+4Jz/tbm1TQ9Fcf2k+H6dPPYv0J1sZmX6hMgCEmNiUdUFLQFvszoXx2XrRi1/hIFjbz2e69Yg==",
            "dependencies": {
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/select": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/select/-/select-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-fAiTaHZ1PIEmCUbufS+IZvsWO0hDxtbU8rOsbmSu1oupAboP7jSgOVgcCGdT9KY5WacrniIIMO6jZjhnvrC0Lg==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/floating-label": "14.0.0-canary.53b3cad2f.0",
                "@material/line-ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/list": "14.0.0-canary.53b3cad2f.0",
                "@material/menu": "14.0.0-canary.53b3cad2f.0",
                "@material/menu-surface": "14.0.0-canary.53b3cad2f.0",
                "@material/notched-outline": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/tokens": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/shape": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/shape/-/shape-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-RyjInLCNe+nI/ulKea0ZLHphXQDiDqYazS25SRn18g8Hoa5qGNaY5oOBncDXUYn3jm5oI5kFc9oif//kulkbjg==",
            "dependencies": {
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/snackbar": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/snackbar/-/snackbar-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-E/i+o7Q8Jp4UW7UBTslqlFeSxgyU7XE86CoYuq2g+ySSWTt8b16ug8EJTQvuk4DRdDO3tjQN1sN0R77Av6txSw==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/button": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/icon-button": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/textfield": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/textfield/-/textfield-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-Pla9Tr94Is18o97E/mqHKdkR24rPES9atGm3BlXrNzyr5tu6+h++RBbxy7V6IExcfl0MX+v9Gyqz7sPZzFtwMA==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/floating-label": "14.0.0-canary.53b3cad2f.0",
                "@material/line-ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/notched-outline": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/tokens": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/theme": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/theme/-/theme-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-S06XAevDCDWMe+GgsEpITMS07imUidzadNaTbJsqssFajBLr53QWVZsG84BpjXKXoYvyEJvb0hX5U0lq6ip9UQ==",
            "dependencies": {
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/tokens": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/tokens/-/tokens-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-myHFB7vac8zErA3qgkqmV+kpE+i9JEwc/6Yf0MOumDSpylJGw28QikpNC6eAVBK2EmPQTaFn20mqUxyud8dGqw==",
            "dependencies": {
                "@material/elevation": "14.0.0-canary.53b3cad2f.0"
            }
        },
        "node_modules/@material/top-app-bar": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/top-app-bar/-/top-app-bar-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-9vPLLxUbNrWNCPGHoIeIUtyXWQUNh+yQwnkTYVkVAVEb1CsWb2D+/NefytfvyFtXWBFQLybAeG5RH0ZqdcgQBQ==",
            "dependencies": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/touch-target": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/touch-target/-/touch-target-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-d83e5vbqoLyL542yOTTp4TLVltddWiqbI/j1w/D9ipE30YKfe2EDN+CNJc32Zufh5IUfK41DsZdrN8fI9cL99A==",
            "dependencies": {
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@material/typography": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/typography/-/typography-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-9J0k2fq7uyHsRzRqJDJLGmg3YzRpfRPtFDVeUH/xBcYoqpZE7wYw5Mb7s/l8eP626EtR7HhXhSPjvRTLA6NIJg==",
            "dependencies": {
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "node_modules/@npmcli/fs": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/@npmcli/fs/-/fs-1.1.1.tgz",
            "integrity": "sha512-8KG5RD0GVP4ydEzRn/I4BNDuxDtqVbOdm8675T49OIG/NGhaK0pjPX7ZcDlvKYbA+ulvVK3ztfcF4uBdOxuJbQ==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "@gar/promisify": "^1.0.1",
                "semver": "^7.3.5"
            }
        },
        "node_modules/@npmcli/fs/node_modules/semver": {
            "version": "7.3.7",
            "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.7.tgz",
            "integrity": "sha512-QlYTucUYOews+WeEujDoEGziz4K6c47V/Bd+LjSSYcA94p+DmINdf7ncaUinThfvZyu13lN9OY1XDxt8C0Tw0g==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "lru-cache": "^6.0.0"
            },
            "bin": {
                "semver": "bin/semver.js"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/@npmcli/move-file": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@npmcli/move-file/-/move-file-1.1.2.tgz",
            "integrity": "sha512-1SUf/Cg2GzGDyaf15aR9St9TWlb+XvbZXWpDx8YKs7MLzMH/BCeopv+y9vzrzgkfykCGuWOlSu3mZhj2+FQcrg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "mkdirp": "^1.0.4",
                "rimraf": "^3.0.2"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/@protobufjs/aspromise": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@protobufjs/aspromise/-/aspromise-1.1.2.tgz",
            "integrity": "sha1-m4sMxmPWaafY9vXQiToU00jzD78=",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/@protobufjs/base64": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@protobufjs/base64/-/base64-1.1.2.tgz",
            "integrity": "sha512-AZkcAA5vnN/v4PDqKyMR5lx7hZttPDgClv83E//FMNhR2TMcLUhfRUBHCmSl0oi9zMgDDqRUJkSxO3wm85+XLg==",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/@protobufjs/codegen": {
            "version": "2.0.4",
            "resolved": "https://registry.npmjs.org/@protobufjs/codegen/-/codegen-2.0.4.tgz",
            "integrity": "sha512-YyFaikqM5sH0ziFZCN3xDC7zeGaB/d0IUb9CATugHWbd1FRFwWwt4ld4OYMPWu5a3Xe01mGAULCdqhMlPl29Jg==",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/@protobufjs/eventemitter": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@protobufjs/eventemitter/-/eventemitter-1.1.0.tgz",
            "integrity": "sha1-NVy8mLr61ZePntCV85diHx0Ga3A=",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/@protobufjs/fetch": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@protobufjs/fetch/-/fetch-1.1.0.tgz",
            "integrity": "sha1-upn7WYYUr2VwDBYZ/wbUVLDYTEU=",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "@protobufjs/aspromise": "^1.1.1",
                "@protobufjs/inquire": "^1.1.0"
            }
        },
        "node_modules/@protobufjs/float": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/@protobufjs/float/-/float-1.0.2.tgz",
            "integrity": "sha1-Xp4avctz/Ap8uLKR33jIy9l7h9E=",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/@protobufjs/inquire": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@protobufjs/inquire/-/inquire-1.1.0.tgz",
            "integrity": "sha1-/yAOPnzyQp4tyvwRQIKOjMY48Ik=",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/@protobufjs/path": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@protobufjs/path/-/path-1.1.2.tgz",
            "integrity": "sha1-bMKyDFya1q0NzP0hynZz2Nf79o0=",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/@protobufjs/pool": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@protobufjs/pool/-/pool-1.1.0.tgz",
            "integrity": "sha1-Cf0V8tbTq/qbZbw2ZQbWrXhG/1Q=",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/@protobufjs/utf8": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@protobufjs/utf8/-/utf8-1.1.0.tgz",
            "integrity": "sha1-p3c2C1s5oaLlEG+OhY8v0tBgxXA=",
            "dev": true,
            "license": "BSD-3-Clause"
        },
        "node_modules/@rollup/pluginutils": {
            "version": "4.2.1",
            "resolved": "https://registry.npmjs.org/@rollup/pluginutils/-/pluginutils-4.2.1.tgz",
            "integrity": "sha512-iKnFXr7NkdZAIHiIWE+BX5ULi/ucVFYWD6TbAV+rZctiRTY2PL6tsIKhoIOaoskiWAkgu+VsbXgUVDNLHf+InQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "estree-walker": "^2.0.1",
                "picomatch": "^2.2.2"
            },
            "engines": {
                "node": ">= 8.0.0"
            }
        },
        "node_modules/@socket.io/base64-arraybuffer": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/@socket.io/base64-arraybuffer/-/base64-arraybuffer-1.0.2.tgz",
            "integrity": "sha512-dOlCBKnDw4iShaIsH/bxujKTM18+2TOAsYz+KSc11Am38H4q5Xw8Bbz97ZYdrVNM+um3p7w86Bvvmcn9q+5+eQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.6.0"
            }
        },
        "node_modules/@tootallnate/once": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@tootallnate/once/-/once-1.1.2.tgz",
            "integrity": "sha512-RbzJvlNzmRq5c3O09UipeuXno4tA1FE6ikOjxZK0tuxVv3412l64l5t1W5pj4+rJq9vpkm/kwiR07aZXnsKPxw==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 6"
            }
        },
        "node_modules/@types/component-emitter": {
            "version": "1.2.11",
            "resolved": "https://registry.npmjs.org/@types/component-emitter/-/component-emitter-1.2.11.tgz",
            "integrity": "sha512-SRXjM+tfsSlA9VuG8hGO2nft2p8zjXCK1VcC6N4NXbBbYbSia9kzCChYQajIjzIqOOOuh5Ock6MmV2oux4jDZQ==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/cookie": {
            "version": "0.4.1",
            "resolved": "https://registry.npmjs.org/@types/cookie/-/cookie-0.4.1.tgz",
            "integrity": "sha512-XW/Aa8APYr6jSVVA1y/DEIZX0/GMKLEVekNG727R8cs56ahETkRAy/3DR7+fJyh7oUgGwNQaRfXCun0+KbWY7Q==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/cors": {
            "version": "2.8.12",
            "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.12.tgz",
            "integrity": "sha512-vt+kDhq/M2ayberEtJcIN/hxXy1Pk+59g2FV/ZQceeaTyCtCucjL2Q7FXlFjtWn4n15KCr1NE2lNNFhp0lEThw==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/long": {
            "version": "4.0.1",
            "resolved": "https://registry.npmjs.org/@types/long/-/long-4.0.1.tgz",
            "integrity": "sha512-5tXH6Bx/kNGd3MgffdmP4dy2Z+G4eaXw0SE81Tq3BNadtnMR5/ySMzX4SLEzHJzSmPNn4HIdpQsBvXMUykr58w==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/minimatch": {
            "version": "3.0.5",
            "resolved": "https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.5.tgz",
            "integrity": "sha512-Klz949h02Gz2uZCMGwDUSDS1YBlTdDDgbWHi+81l29tQALUtvz4rAYi5uoVhE5Lagoq6DeqAUlbrHvW/mXDgdQ==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/node": {
            "version": "17.0.25",
            "resolved": "https://registry.npmjs.org/@types/node/-/node-17.0.25.tgz",
            "integrity": "sha512-wANk6fBrUwdpY4isjWrKTufkrXdu1D2YHCot2fD/DfWxF5sMrVSA+KN7ydckvaTCh0HiqX9IVl0L5/ZoXg5M7w==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/parse5": {
            "version": "6.0.3",
            "resolved": "https://registry.npmjs.org/@types/parse5/-/parse5-6.0.3.tgz",
            "integrity": "sha512-SuT16Q1K51EAVPz1K29DJ/sXjhSQ0zjvsypYJ6tlwVsRV9jwW5Adq2ch8Dq8kDBCkYnELS7N7VNCSB5nC56t/g==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/@types/trusted-types": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/@types/trusted-types/-/trusted-types-2.0.2.tgz",
            "integrity": "sha512-F5DIZ36YVLE+PN+Zwws4kJogq47hNgX3Nx6WyDJ3kcplxyke3XIzB8uK5n/Lpm1HBsbGzd6nmGehL8cPekP+Tg=="
        },
        "node_modules/@ungap/promise-all-settled": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@ungap/promise-all-settled/-/promise-all-settled-1.1.2.tgz",
            "integrity": "sha512-sL/cEvJWAnClXw0wHk85/2L0G6Sj8UB0Ctc1TEMbKSsmpRosqhwj9gWgFRZSrBr2f9tiXISwNhCPmlfqUqyb9Q==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/@web/parse5-utils": {
            "version": "1.3.0",
            "resolved": "https://registry.npmjs.org/@web/parse5-utils/-/parse5-utils-1.3.0.tgz",
            "integrity": "sha512-Pgkx3ECc8EgXSlS5EyrgzSOoUbM6P8OKS471HLAyvOBcP1NCBn0to4RN/OaKASGq8qa3j+lPX9H14uA5AHEnQg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/parse5": "^6.0.1",
                "parse5": "^6.0.1"
            },
            "engines": {
                "node": ">=10.0.0"
            }
        },
        "node_modules/@web/rollup-plugin-html": {
            "version": "1.10.3",
            "resolved": "https://registry.npmjs.org/@web/rollup-plugin-html/-/rollup-plugin-html-1.10.3.tgz",
            "integrity": "sha512-2RMIeKxpGtrcXiqPTgMVq5neGa5xa69MfNK860BHVMEO2N/MrHFuQNr1eNLsspcq2DL/xnymwC3w5hgjtlgxag==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@web/parse5-utils": "^1.3.0",
                "glob": "^7.1.6",
                "html-minifier-terser": "^6.0.0",
                "parse5": "^6.0.1"
            },
            "engines": {
                "node": ">=12.0.0"
            }
        },
        "node_modules/@web/rollup-plugin-import-meta-assets": {
            "version": "1.0.7",
            "resolved": "https://registry.npmjs.org/@web/rollup-plugin-import-meta-assets/-/rollup-plugin-import-meta-assets-1.0.7.tgz",
            "integrity": "sha512-ft44CqITUkNd8stwNb4ZOvrZ8DlPifM821jplksmxRGetg5Lx684oFrpfQJ7mfkU/Sa7B3dI1mHTX0DE52eBwg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@rollup/pluginutils": "^4.1.0",
                "estree-walker": "^2.0.2",
                "magic-string": "^0.25.7"
            },
            "engines": {
                "node": ">=10.0.0"
            }
        },
        "node_modules/accepts": {
            "version": "1.3.8",
            "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
            "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "mime-types": "~2.1.34",
                "negotiator": "0.6.3"
            },
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/acorn": {
            "version": "8.7.0",
            "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.7.0.tgz",
            "integrity": "sha512-V/LGr1APy+PXIwKebEWrkZPwoeoF+w1jiOBUmuxuiUIaOHtob8Qc9BTrYo7VuI5fR8tqsy+buA2WFooR5olqvQ==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "acorn": "bin/acorn"
            },
            "engines": {
                "node": ">=0.4.0"
            }
        },
        "node_modules/agent-base": {
            "version": "6.0.2",
            "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-6.0.2.tgz",
            "integrity": "sha512-RZNwNclF7+MS/8bDg70amg32dyeZGZxiDuQmZxKLAlQjr3jGyLx+4Kkk58UO7D2QdgFIQCovuSuZESne6RG6XQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "debug": "4"
            },
            "engines": {
                "node": ">= 6.0.0"
            }
        },
        "node_modules/agentkeepalive": {
            "version": "4.2.1",
            "resolved": "https://registry.npmjs.org/agentkeepalive/-/agentkeepalive-4.2.1.tgz",
            "integrity": "sha512-Zn4cw2NEqd+9fiSVWMscnjyQ1a8Yfoc5oBajLeo5w+YBHgDUcEBY2hS4YpTz6iN5f/2zQiktcuM6tS8x1p9dpA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "debug": "^4.1.0",
                "depd": "^1.1.2",
                "humanize-ms": "^1.2.1"
            },
            "engines": {
                "node": ">= 8.0.0"
            }
        },
        "node_modules/agentkeepalive/node_modules/depd": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
            "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/aggregate-error": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/aggregate-error/-/aggregate-error-3.1.0.tgz",
            "integrity": "sha512-4I7Td01quW/RpocfNayFdFVk1qSuoh0E7JrbRJ16nH01HhKFQ88INq9Sd+nd72zqRySlr9BmDA8xlEJ6vJMrYA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "clean-stack": "^2.0.0",
                "indent-string": "^4.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/ansi-colors": {
            "version": "4.1.1",
            "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz",
            "integrity": "sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/ansi-regex": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
            "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/ansi-styles": {
            "version": "4.3.0",
            "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
            "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "color-convert": "^2.0.1"
            },
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/chalk/ansi-styles?sponsor=1"
            }
        },
        "node_modules/any-signal": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/any-signal/-/any-signal-3.0.1.tgz",
            "integrity": "sha512-xgZgJtKEa9YmDqXodIgl7Fl1C8yNXr8w6gXjqK3LW4GcEiYT+6AQfJSE/8SPsEpLLmcvbv8YU+qet94UewHxqg==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/anymatch": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.2.tgz",
            "integrity": "sha512-P43ePfOAIupkguHUycrc4qJ9kz8ZiuOUijaETwX7THt0Y/GNK7v0aa8rY816xWjZ7rJdA5XdMcpVFTKMq+RvWg==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "normalize-path": "^3.0.0",
                "picomatch": "^2.0.4"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/argparse": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
            "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
            "dev": true,
            "license": "Python-2.0"
        },
        "node_modules/assertion-error": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz",
            "integrity": "sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": "*"
            }
        },
        "node_modules/async": {
            "version": "2.6.4",
            "resolved": "https://registry.npmjs.org/async/-/async-2.6.4.tgz",
            "integrity": "sha512-mzo5dfJYwAn29PeiJ0zvwTo04zj8HDJj0Mn8TD7sno7q12prdbnasKJHhkm2c1LgrhlJ0teaea8860oxi51mGA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "lodash": "^4.17.14"
            }
        },
        "node_modules/balanced-match": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
            "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/base64-js": {
            "version": "1.5.1",
            "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
            "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
            "dev": true,
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT"
        },
        "node_modules/base64id": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/base64id/-/base64id-2.0.0.tgz",
            "integrity": "sha512-lGe34o6EHj9y3Kts9R4ZYs/Gr+6N7MCaMlIFA3F1R2O5/m7K06AxfSeO5530PEERE6/WyEg3lsuyw4GHlPZHog==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": "^4.5.0 || >= 5.9"
            }
        },
        "node_modules/basic-auth": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/basic-auth/-/basic-auth-2.0.1.tgz",
            "integrity": "sha512-NF+epuEdnUYVlGuhaxbbq+dvJttwLnGY+YixlXlME5KpQ5W3CnXA5cVTneY3SPbPDRkcjMbifrwmFYcClgOZeg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "safe-buffer": "5.1.2"
            },
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/binary-extensions": {
            "version": "2.2.0",
            "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz",
            "integrity": "sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/blob-to-it": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/blob-to-it/-/blob-to-it-1.0.4.tgz",
            "integrity": "sha512-iCmk0W4NdbrWgRRuxOriU8aM5ijeVLI61Zulsmg/lUHNr7pYjoj+U77opLefNagevtrrbMt3JQ5Qip7ar178kA==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "browser-readablestream-to-it": "^1.0.3"
            }
        },
        "node_modules/blocking-elements": {
            "version": "0.1.1",
            "resolved": "https://registry.npmjs.org/blocking-elements/-/blocking-elements-0.1.1.tgz",
            "integrity": "sha512-/SLWbEzMoVIMZACCyhD/4Ya2M1PWP1qMKuiymowPcI+PdWDARqeARBjhj73kbUBCxEmTZCUu5TAqxtwUO9C1Ig=="
        },
        "node_modules/body-parser": {
            "version": "1.20.0",
            "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.0.tgz",
            "integrity": "sha512-DfJ+q6EPcGKZD1QWUjSpqp+Q7bDQTsQIF4zfUAtZ6qk+H/3/QRhg9CEp39ss+/T2vw0+HaidC0ecJj/DRLIaKg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "bytes": "3.1.2",
                "content-type": "~1.0.4",
                "debug": "2.6.9",
                "depd": "2.0.0",
                "destroy": "1.2.0",
                "http-errors": "2.0.0",
                "iconv-lite": "0.4.24",
                "on-finished": "2.4.1",
                "qs": "6.10.3",
                "raw-body": "2.5.1",
                "type-is": "~1.6.18",
                "unpipe": "1.0.0"
            },
            "engines": {
                "node": ">= 0.8",
                "npm": "1.2.8000 || >= 1.4.16"
            }
        },
        "node_modules/body-parser/node_modules/debug": {
            "version": "2.6.9",
            "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
            "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ms": "2.0.0"
            }
        },
        "node_modules/body-parser/node_modules/ms": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
            "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/brace-expansion": {
            "version": "1.1.11",
            "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
            "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "balanced-match": "^1.0.0",
                "concat-map": "0.0.1"
            }
        },
        "node_modules/braces": {
            "version": "3.0.2",
            "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
            "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "fill-range": "^7.0.1"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/browser-headers": {
            "version": "0.4.1",
            "resolved": "https://registry.npmjs.org/browser-headers/-/browser-headers-0.4.1.tgz",
            "integrity": "sha512-CA9hsySZVo9371qEHjHZtYxV2cFtVj5Wj/ZHi8ooEsrtm4vOnl9Y9HmyYWk9q+05d7K3rdoAE0j3MVEFVvtQtg==",
            "dev": true,
            "license": "Apache-2.0"
        },
        "node_modules/browser-readablestream-to-it": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/browser-readablestream-to-it/-/browser-readablestream-to-it-1.0.3.tgz",
            "integrity": "sha512-+12sHB+Br8HIh6VAMVEG5r3UXCyESIgDW7kzk3BjIXa43DVqVwL7GC5TW3jeh+72dtcH99pPVpw0X8i0jt+/kw==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/browser-stdout": {
            "version": "1.3.1",
            "resolved": "https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz",
            "integrity": "sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/browserslist": {
            "version": "4.20.3",
            "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.20.3.tgz",
            "integrity": "sha512-NBhymBQl1zM0Y5dQT/O+xiLP9/rzOIQdKM/eMJBAq7yBgaB6krIYLGejrwVYnSHZdqjscB1SPuAjHwxjvN6Wdg==",
            "dev": true,
            "funding": [
                {
                    "type": "opencollective",
                    "url": "https://opencollective.com/browserslist"
                },
                {
                    "type": "tidelift",
                    "url": "https://tidelift.com/funding/github/npm/browserslist"
                }
            ],
            "license": "MIT",
            "dependencies": {
                "caniuse-lite": "^1.0.30001332",
                "electron-to-chromium": "^1.4.118",
                "escalade": "^3.1.1",
                "node-releases": "^2.0.3",
                "picocolors": "^1.0.0"
            },
            "bin": {
                "browserslist": "cli.js"
            },
            "engines": {
                "node": "^6 || ^7 || ^8 || ^9 || ^10 || ^11 || ^12 || >=13.7"
            }
        },
        "node_modules/buffer": {
            "version": "6.0.3",
            "resolved": "https://registry.npmjs.org/buffer/-/buffer-6.0.3.tgz",
            "integrity": "sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==",
            "dev": true,
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT",
            "dependencies": {
                "base64-js": "^1.3.1",
                "ieee754": "^1.2.1"
            }
        },
        "node_modules/buffer-from": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
            "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/bytes": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
            "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/cacache": {
            "version": "15.3.0",
            "resolved": "https://registry.npmjs.org/cacache/-/cacache-15.3.0.tgz",
            "integrity": "sha512-VVdYzXEn+cnbXpFgWs5hTT7OScegHVmLhJIR8Ufqk3iFD6A6j5iSX1KuBTfNEv4tdJWE2PzA6IVFtcLC7fN9wQ==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "@npmcli/fs": "^1.0.0",
                "@npmcli/move-file": "^1.0.1",
                "chownr": "^2.0.0",
                "fs-minipass": "^2.0.0",
                "glob": "^7.1.4",
                "infer-owner": "^1.0.4",
                "lru-cache": "^6.0.0",
                "minipass": "^3.1.1",
                "minipass-collect": "^1.0.2",
                "minipass-flush": "^1.0.5",
                "minipass-pipeline": "^1.2.2",
                "mkdirp": "^1.0.3",
                "p-map": "^4.0.0",
                "promise-inflight": "^1.0.1",
                "rimraf": "^3.0.2",
                "ssri": "^8.0.1",
                "tar": "^6.0.2",
                "unique-filename": "^1.1.1"
            },
            "engines": {
                "node": ">= 10"
            }
        },
        "node_modules/call-bind": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.2.tgz",
            "integrity": "sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "function-bind": "^1.1.1",
                "get-intrinsic": "^1.0.2"
            },
            "funding": {
                "url": "https://github.com/sponsors/ljharb"
            }
        },
        "node_modules/camel-case": {
            "version": "4.1.2",
            "resolved": "https://registry.npmjs.org/camel-case/-/camel-case-4.1.2.tgz",
            "integrity": "sha512-gxGWBrTT1JuMx6R+o5PTXMmUnhnVzLQ9SNutD4YqKtI6ap897t3tKECYla6gCWEkplXnlNybEkZg9GEGxKFCgw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "pascal-case": "^3.1.2",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/camelcase": {
            "version": "6.3.0",
            "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-6.3.0.tgz",
            "integrity": "sha512-Gmy6FhYlCY7uOElZUSbxo2UCDH8owEk996gkbrpsgGtrJLM3J7jGxl9Ic7Qwwj4ivOE5AWZWRMecDdF7hqGjFA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/caniuse-lite": {
            "version": "1.0.30001332",
            "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001332.tgz",
            "integrity": "sha512-10T30NYOEQtN6C11YGg411yebhvpnC6Z102+B95eAsN0oB6KUs01ivE8u+G6FMIRtIrVlYXhL+LUwQ3/hXwDWw==",
            "dev": true,
            "funding": [
                {
                    "type": "opencollective",
                    "url": "https://opencollective.com/browserslist"
                },
                {
                    "type": "tidelift",
                    "url": "https://tidelift.com/funding/github/npm/caniuse-lite"
                }
            ],
            "license": "CC-BY-4.0"
        },
        "node_modules/capital-case": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/capital-case/-/capital-case-1.0.4.tgz",
            "integrity": "sha512-ds37W8CytHgwnhGGTi88pcPyR15qoNkOpYwmMMfnWqqWgESapLqvDx6huFjQ5vqWSn2Z06173XNA7LtMOeUh1A==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3",
                "upper-case-first": "^2.0.2"
            }
        },
        "node_modules/cborg": {
            "version": "1.9.1",
            "resolved": "https://registry.npmjs.org/cborg/-/cborg-1.9.1.tgz",
            "integrity": "sha512-6xKRdJ89ncwEXJGx9rFMRBNp72UqgYSGt2a88rqsvCLda4OuhRlh3xD2nu+ufrw6h9l94K0cnvyD4WEGpKtRtw==",
            "dev": true,
            "license": "Apache-2.0",
            "bin": {
                "cborg": "cli.js"
            }
        },
        "node_modules/chai": {
            "version": "4.3.6",
            "resolved": "https://registry.npmjs.org/chai/-/chai-4.3.6.tgz",
            "integrity": "sha512-bbcp3YfHCUzMOvKqsztczerVgBKSsEijCySNlHHbX3VG1nskvqjz5Rfso1gGwD6w6oOV3eI60pKuMOV5MV7p3Q==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "assertion-error": "^1.1.0",
                "check-error": "^1.0.2",
                "deep-eql": "^3.0.1",
                "get-func-name": "^2.0.0",
                "loupe": "^2.3.1",
                "pathval": "^1.1.1",
                "type-detect": "^4.0.5"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/chalk": {
            "version": "4.1.2",
            "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
            "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ansi-styles": "^4.1.0",
                "supports-color": "^7.1.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/chalk/chalk?sponsor=1"
            }
        },
        "node_modules/change-case": {
            "version": "4.1.2",
            "resolved": "https://registry.npmjs.org/change-case/-/change-case-4.1.2.tgz",
            "integrity": "sha512-bSxY2ws9OtviILG1EiY5K7NNxkqg/JnRnFxLtKQ96JaviiIxi7djMrSd0ECT9AC+lttClmYwKw53BWpOMblo7A==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "camel-case": "^4.1.2",
                "capital-case": "^1.0.4",
                "constant-case": "^3.0.4",
                "dot-case": "^3.0.4",
                "header-case": "^2.0.4",
                "no-case": "^3.0.4",
                "param-case": "^3.0.4",
                "pascal-case": "^3.1.2",
                "path-case": "^3.0.4",
                "sentence-case": "^3.0.4",
                "snake-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/check-error": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/check-error/-/check-error-1.0.2.tgz",
            "integrity": "sha1-V00xLt2Iu13YkS6Sht1sCu1KrII=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": "*"
            }
        },
        "node_modules/chokidar": {
            "version": "3.5.3",
            "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.5.3.tgz",
            "integrity": "sha512-Dr3sfKRP6oTcjf2JmUmFJfeVMvXBdegxB0iVQ5eb2V10uFJUCAS8OByZdVAyVb8xXNz3GjjTgj9kLWsZTqE6kw==",
            "dev": true,
            "funding": [
                {
                    "type": "individual",
                    "url": "https://paulmillr.com/funding/"
                }
            ],
            "license": "MIT",
            "dependencies": {
                "anymatch": "~3.1.2",
                "braces": "~3.0.2",
                "glob-parent": "~5.1.2",
                "is-binary-path": "~2.1.0",
                "is-glob": "~4.0.1",
                "normalize-path": "~3.0.0",
                "readdirp": "~3.6.0"
            },
            "engines": {
                "node": ">= 8.10.0"
            },
            "optionalDependencies": {
                "fsevents": "~2.3.2"
            }
        },
        "node_modules/chownr": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/chownr/-/chownr-2.0.0.tgz",
            "integrity": "sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==",
            "dev": true,
            "license": "ISC",
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/clean-css": {
            "version": "5.3.0",
            "resolved": "https://registry.npmjs.org/clean-css/-/clean-css-5.3.0.tgz",
            "integrity": "sha512-YYuuxv4H/iNb1Z/5IbMRoxgrzjWGhOEFfd+groZ5dMCVkpENiMZmwspdrzBo9286JjM1gZJPAyL7ZIdzuvu2AQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "source-map": "~0.6.0"
            },
            "engines": {
                "node": ">= 10.0"
            }
        },
        "node_modules/clean-stack": {
            "version": "2.2.0",
            "resolved": "https://registry.npmjs.org/clean-stack/-/clean-stack-2.2.0.tgz",
            "integrity": "sha512-4diC9HaTE+KRAMWhDhrGOECgWZxoevMc5TlkObMqNSsVU62PYzXZ/SMTjzyGAFF1YusgxGcSWTEXBhp0CPwQ1A==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/cliui": {
            "version": "7.0.4",
            "resolved": "https://registry.npmjs.org/cliui/-/cliui-7.0.4.tgz",
            "integrity": "sha512-OcRE68cOsVMXp1Yvonl/fzkQOyjLSu/8bhPDfQt0e0/Eb283TKP20Fs2MqoPsr9SwA595rRCA+QMzYc9nBP+JQ==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "string-width": "^4.2.0",
                "strip-ansi": "^6.0.0",
                "wrap-ansi": "^7.0.0"
            }
        },
        "node_modules/color-convert": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
            "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "color-name": "~1.1.4"
            },
            "engines": {
                "node": ">=7.0.0"
            }
        },
        "node_modules/color-name": {
            "version": "1.1.4",
            "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
            "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/commander": {
            "version": "2.20.3",
            "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
            "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/component-emitter": {
            "version": "1.3.0",
            "resolved": "https://registry.npmjs.org/component-emitter/-/component-emitter-1.3.0.tgz",
            "integrity": "sha512-Rd3se6QB+sO1TwqZjscQrurpEPIfO0/yYnSin6Q/rD3mOutHvUrCAhJub3r90uNb+SESBuE0QYoB90YdfatsRg==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/concat-map": {
            "version": "0.0.1",
            "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
            "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/connect": {
            "version": "3.7.0",
            "resolved": "https://registry.npmjs.org/connect/-/connect-3.7.0.tgz",
            "integrity": "sha512-ZqRXc+tZukToSNmh5C2iWMSoV3X1YUcPbqEM4DkEG5tNQXrQUZCNVGGv3IuicnkMtPfGf3Xtp8WCXs295iQ1pQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "debug": "2.6.9",
                "finalhandler": "1.1.2",
                "parseurl": "~1.3.3",
                "utils-merge": "1.0.1"
            },
            "engines": {
                "node": ">= 0.10.0"
            }
        },
        "node_modules/connect/node_modules/debug": {
            "version": "2.6.9",
            "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
            "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ms": "2.0.0"
            }
        },
        "node_modules/connect/node_modules/ms": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
            "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/constant-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/constant-case/-/constant-case-3.0.4.tgz",
            "integrity": "sha512-I2hSBi7Vvs7BEuJDr5dDHfzb/Ruj3FyvFyh7KLilAjNQw3Be+xgqUBA2W6scVEcL0hL1dwPRtIqEPVUCKkSsyQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3",
                "upper-case": "^2.0.2"
            }
        },
        "node_modules/content-type": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.4.tgz",
            "integrity": "sha512-hIP3EEPs8tB9AT1L+NUqtwOAps4mk2Zob89MWXMHjHWg9milF/j4osnnQLXBCBFBk/tvIG/tUc9mOUJiPBhPXA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/convert-source-map": {
            "version": "1.8.0",
            "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.8.0.tgz",
            "integrity": "sha512-+OQdjP49zViI/6i7nIJpA8rAl4sV/JdPfU9nZs3VqOwGIgizICvuN2ru6fMd+4llL0tar18UYJXfZ/TWtmhUjA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "safe-buffer": "~5.1.1"
            }
        },
        "node_modules/cookie": {
            "version": "0.4.2",
            "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.4.2.tgz",
            "integrity": "sha512-aSWTXFzaKWkvHO1Ny/s+ePFpvKsPnjc551iI41v3ny/ow6tBG5Vd+FuqGNhh1LxOmVzOlGUriIlOaokOvhaStA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/cors": {
            "version": "2.8.5",
            "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
            "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "object-assign": "^4",
                "vary": "^1"
            },
            "engines": {
                "node": ">= 0.10"
            }
        },
        "node_modules/corser": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/corser/-/corser-2.0.1.tgz",
            "integrity": "sha1-jtolLsqrWEDc2XXOuQ2TcMgZ/4c=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.4.0"
            }
        },
        "node_modules/crelt": {
            "version": "1.0.5",
            "resolved": "https://registry.npmjs.org/crelt/-/crelt-1.0.5.tgz",
            "integrity": "sha512-+BO9wPPi+DWTDcNYhr/W90myha8ptzftZT+LwcmUbbok0rcP/fequmFYCw8NMoH7pkAZQzU78b3kYrlua5a9eA=="
        },
        "node_modules/custom-event": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/custom-event/-/custom-event-1.0.1.tgz",
            "integrity": "sha1-XQKkaFCt8bSjF5RqOSj8y1v9BCU=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/dag-jose": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/dag-jose/-/dag-jose-1.0.0.tgz",
            "integrity": "sha512-U0b/YsIPBp6YZNTFrVjwLZAlY3qGRxZTIEcM/CcQmrVrCWq9MWQq9pheXVSPLIhF4SNwzp2SikPva4/BIrJY+g==",
            "dev": true,
            "license": "(Apache-2.0 OR MIT)",
            "dependencies": {
                "@ipld/dag-cbor": "^6.0.3",
                "multiformats": "^9.0.2"
            }
        },
        "node_modules/dag-jose/node_modules/@ipld/dag-cbor": {
            "version": "6.0.15",
            "resolved": "https://registry.npmjs.org/@ipld/dag-cbor/-/dag-cbor-6.0.15.tgz",
            "integrity": "sha512-Vm3VTSTwlmGV92a3C5aeY+r2A18zbH2amehNhsX8PBa3muXICaWrN8Uri85A5hLH7D7ElhE8PdjxD6kNqUmTZA==",
            "dev": true,
            "license": "(Apache-2.0 AND MIT)",
            "dependencies": {
                "cborg": "^1.5.4",
                "multiformats": "^9.5.4"
            }
        },
        "node_modules/date-format": {
            "version": "4.0.9",
            "resolved": "https://registry.npmjs.org/date-format/-/date-format-4.0.9.tgz",
            "integrity": "sha512-+8J+BOUpSrlKLQLeF8xJJVTxS8QfRSuJgwxSVvslzgO3E6khbI0F5mMEPf5mTYhCCm4h99knYP6H3W9n3BQFrg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4.0"
            }
        },
        "node_modules/debug": {
            "version": "4.3.4",
            "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.4.tgz",
            "integrity": "sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ms": "2.1.2"
            },
            "engines": {
                "node": ">=6.0"
            },
            "peerDependenciesMeta": {
                "supports-color": {
                    "optional": true
                }
            }
        },
        "node_modules/debug/node_modules/ms": {
            "version": "2.1.2",
            "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
            "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/decamelize": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/decamelize/-/decamelize-4.0.0.tgz",
            "integrity": "sha512-9iE1PgSik9HeIIw2JO94IidnE3eBoQrFJ3w7sFuzSX4DpmZ3v5sZpUiV5Swcf6mQEF+Y0ru8Neo+p+nyh2J+hQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/deep-eql": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-3.0.1.tgz",
            "integrity": "sha512-+QeIQyN5ZuO+3Uk5DYh6/1eKO0m0YmJFGNmFHGACpf1ClL1nmlV/p4gNgbl2pJGxgXb4faqo6UE+M5ACEMyVcw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "type-detect": "^4.0.0"
            },
            "engines": {
                "node": ">=0.12"
            }
        },
        "node_modules/depd": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
            "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/destroy": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
            "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.8",
                "npm": "1.2.8000 || >= 1.4.16"
            }
        },
        "node_modules/di": {
            "version": "0.0.1",
            "resolved": "https://registry.npmjs.org/di/-/di-0.0.1.tgz",
            "integrity": "sha1-gGZJMmzqp8qjMG112YXqJ0i6kTw=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/diff": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/diff/-/diff-5.0.0.tgz",
            "integrity": "sha512-/VTCrvm5Z0JGty/BWHljh+BAiw3IK+2j87NGMu8Nwc/f48WoDAC395uomO9ZD117ZOBaHmkX1oyLvkVM/aIT3w==",
            "dev": true,
            "license": "BSD-3-Clause",
            "engines": {
                "node": ">=0.3.1"
            }
        },
        "node_modules/dns-over-http-resolver": {
            "version": "1.2.3",
            "resolved": "https://registry.npmjs.org/dns-over-http-resolver/-/dns-over-http-resolver-1.2.3.tgz",
            "integrity": "sha512-miDiVSI6KSNbi4SVifzO/reD8rMnxgrlnkrlkugOLQpWQTe2qMdHsZp5DmfKjxNE+/T3VAAYLQUZMv9SMr6+AA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "debug": "^4.3.1",
                "native-fetch": "^3.0.0",
                "receptacle": "^1.3.2"
            }
        },
        "node_modules/dom-serialize": {
            "version": "2.2.1",
            "resolved": "https://registry.npmjs.org/dom-serialize/-/dom-serialize-2.2.1.tgz",
            "integrity": "sha1-ViromZ9Evl6jB29UGdzVnrQ6yVs=",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "custom-event": "~1.0.0",
                "ent": "~2.2.0",
                "extend": "^3.0.0",
                "void-elements": "^2.0.0"
            }
        },
        "node_modules/dot-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/dot-case/-/dot-case-3.0.4.tgz",
            "integrity": "sha512-Kv5nKlh6yRrdrGvxeJ2e5y2eRUpkUosIW4A2AS38zwSz27zu7ufDwQPi5Jhs3XAlGNetl3bmnGhQsMtkKJnj3w==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/ee-first": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
            "integrity": "sha1-WQxhFWsK4vTwJVcyoViyZrxWsh0=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/electron-fetch": {
            "version": "1.7.4",
            "resolved": "https://registry.npmjs.org/electron-fetch/-/electron-fetch-1.7.4.tgz",
            "integrity": "sha512-+fBLXEy4CJWQ5bz8dyaeSG1hD6JJ15kBZyj3eh24pIVrd3hLM47H/umffrdQfS6GZ0falF0g9JT9f3Rs6AVUhw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "encoding": "^0.1.13"
            },
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/electron-to-chromium": {
            "version": "1.4.119",
            "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.4.119.tgz",
            "integrity": "sha512-HPEmKy+d0xK8oCfEHc5t6wDsSAi1WmE3Ld08QrBjAPxaAzfuKP66VJ77lcTqxTt7GJmSE279s75mhW64Xh+4kw==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/emoji-regex": {
            "version": "8.0.0",
            "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
            "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/encodeurl": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
            "integrity": "sha1-rT/0yG7C0CkyL1oCw6mmBslbP1k=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/encoding": {
            "version": "0.1.13",
            "resolved": "https://registry.npmjs.org/encoding/-/encoding-0.1.13.tgz",
            "integrity": "sha512-ETBauow1T35Y/WZMkio9jiM0Z5xjHHmJ4XmjZOq1l/dXz3lr2sRn87nJy20RupqSh1F2m3HHPSp8ShIPQJrJ3A==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "iconv-lite": "^0.6.2"
            }
        },
        "node_modules/encoding/node_modules/iconv-lite": {
            "version": "0.6.3",
            "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
            "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "safer-buffer": ">= 2.1.2 < 3.0.0"
            },
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/engine.io": {
            "version": "6.2.0",
            "resolved": "https://registry.npmjs.org/engine.io/-/engine.io-6.2.0.tgz",
            "integrity": "sha512-4KzwW3F3bk+KlzSOY57fj/Jx6LyRQ1nbcyIadehl+AnXjKT7gDO0ORdRi/84ixvMKTym6ZKuxvbzN62HDDU1Lg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/cookie": "^0.4.1",
                "@types/cors": "^2.8.12",
                "@types/node": ">=10.0.0",
                "accepts": "~1.3.4",
                "base64id": "2.0.0",
                "cookie": "~0.4.1",
                "cors": "~2.8.5",
                "debug": "~4.3.1",
                "engine.io-parser": "~5.0.3",
                "ws": "~8.2.3"
            },
            "engines": {
                "node": ">=10.0.0"
            }
        },
        "node_modules/engine.io-parser": {
            "version": "5.0.3",
            "resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-5.0.3.tgz",
            "integrity": "sha512-BtQxwF27XUNnSafQLvDi0dQ8s3i6VgzSoQMJacpIcGNrlUdfHSKbgm3jmjCVvQluGzqwujQMPAoMai3oYSTurg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@socket.io/base64-arraybuffer": "~1.0.2"
            },
            "engines": {
                "node": ">=10.0.0"
            }
        },
        "node_modules/engine.io/node_modules/@types/node": {
            "version": "17.0.29",
            "resolved": "https://registry.npmjs.org/@types/node/-/node-17.0.29.tgz",
            "integrity": "sha512-tx5jMmMFwx7wBwq/V7OohKDVb/JwJU5qCVkeLMh1//xycAJ/ESuw9aJ9SEtlCZDYi2pBfe4JkisSoAtbOsBNAA==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/engine.io/node_modules/ws": {
            "version": "8.2.3",
            "resolved": "https://registry.npmjs.org/ws/-/ws-8.2.3.tgz",
            "integrity": "sha512-wBuoj1BDpC6ZQ1B7DWQBYVLphPWkm8i9Y0/3YdHjHKHiohOJ1ws+3OccDWtH+PoC9DZD5WOTrJvNbWvjS6JWaA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10.0.0"
            },
            "peerDependencies": {
                "bufferutil": "^4.0.1",
                "utf-8-validate": "^5.0.2"
            },
            "peerDependenciesMeta": {
                "bufferutil": {
                    "optional": true
                },
                "utf-8-validate": {
                    "optional": true
                }
            }
        },
        "node_modules/ent": {
            "version": "2.2.0",
            "resolved": "https://registry.npmjs.org/ent/-/ent-2.2.0.tgz",
            "integrity": "sha1-6WQhkyWiHQX0RGai9obtbOX13R0=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/err-code": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/err-code/-/err-code-3.0.1.tgz",
            "integrity": "sha512-GiaH0KJUewYok+eeY05IIgjtAe4Yltygk9Wqp1V5yVWLdhf0hYZchRjNIT9bb0mSwRcIusT3cx7PJUf3zEIfUA==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/es-module-lexer": {
            "version": "0.10.5",
            "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-0.10.5.tgz",
            "integrity": "sha512-+7IwY/kiGAacQfY+YBhKMvEmyAJnw5grTUgjG85Pe7vcUI/6b7pZjZG8nQ7+48YhzEAEqrEgD2dCz/JIK+AYvw==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/escalade": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.1.1.tgz",
            "integrity": "sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/escape-html": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
            "integrity": "sha1-Aljq5NPQwJdN4cFpGI7wBR0dGYg=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/escape-string-regexp": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
            "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/estree-walker": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-2.0.2.tgz",
            "integrity": "sha512-Rfkk/Mp/DL7JVje3u18FxFujQlTNR2q6QfMSMB7AvCBx91NGj/ba3kCfza0f6dVDbw7YlRf/nDrn7pQrCCyQ/w==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/eventemitter3": {
            "version": "4.0.7",
            "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.7.tgz",
            "integrity": "sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/extend": {
            "version": "3.0.2",
            "resolved": "https://registry.npmjs.org/extend/-/extend-3.0.2.tgz",
            "integrity": "sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/fast-fifo": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/fast-fifo/-/fast-fifo-1.1.0.tgz",
            "integrity": "sha512-Kl29QoNbNvn4nhDsLYjyIAaIqaJB6rBx5p3sL9VjaefJ+eMFBWVZiaoguaoZfzEKr5RhAti0UgM8703akGPJ6g==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/fill-range": {
            "version": "7.0.1",
            "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
            "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "to-regex-range": "^5.0.1"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/finalhandler": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.1.2.tgz",
            "integrity": "sha512-aAWcW57uxVNrQZqFXjITpW3sIUQmHGG3qSb9mUah9MgMC4NeWhNOlNjXEYq3HjRAvL6arUviZGGJsBg6z0zsWA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "debug": "2.6.9",
                "encodeurl": "~1.0.2",
                "escape-html": "~1.0.3",
                "on-finished": "~2.3.0",
                "parseurl": "~1.3.3",
                "statuses": "~1.5.0",
                "unpipe": "~1.0.0"
            },
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/finalhandler/node_modules/debug": {
            "version": "2.6.9",
            "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
            "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ms": "2.0.0"
            }
        },
        "node_modules/finalhandler/node_modules/ms": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
            "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/finalhandler/node_modules/on-finished": {
            "version": "2.3.0",
            "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.3.0.tgz",
            "integrity": "sha1-IPEzZIGwg811M3mSoWlxqi2QaUc=",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ee-first": "1.1.1"
            },
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/finalhandler/node_modules/statuses": {
            "version": "1.5.0",
            "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
            "integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/find-up": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
            "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "locate-path": "^6.0.0",
                "path-exists": "^4.0.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/flat": {
            "version": "5.0.2",
            "resolved": "https://registry.npmjs.org/flat/-/flat-5.0.2.tgz",
            "integrity": "sha512-b6suED+5/3rTpUBdG1gupIl8MPFCAMA0QXwmljLhvCUKcUvdE4gWky9zpuGCcXHOsz4J9wPGNWq6OKpmIzz3hQ==",
            "dev": true,
            "license": "BSD-3-Clause",
            "bin": {
                "flat": "cli.js"
            }
        },
        "node_modules/flatted": {
            "version": "3.2.5",
            "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.2.5.tgz",
            "integrity": "sha512-WIWGi2L3DyTUvUrwRKgGi9TwxQMUEqPOPQBVi71R96jZXJdFskXEmf54BoZaS1kknGODoIGASGEzBUYdyMCBJg==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/follow-redirects": {
            "version": "1.14.9",
            "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.14.9.tgz",
            "integrity": "sha512-MQDfihBQYMcyy5dhRDJUHcw7lb2Pv/TuE6xP1vyraLukNDHKbDxDNaOE3NbCAdKQApno+GPRyo1YAp89yCjK4w==",
            "dev": true,
            "funding": [
                {
                    "type": "individual",
                    "url": "https://github.com/sponsors/RubenVerborgh"
                }
            ],
            "license": "MIT",
            "engines": {
                "node": ">=4.0"
            },
            "peerDependenciesMeta": {
                "debug": {
                    "optional": true
                }
            }
        },
        "node_modules/fs-extra": {
            "version": "10.1.0",
            "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-10.1.0.tgz",
            "integrity": "sha512-oRXApq54ETRj4eMiFzGnHWGy+zo5raudjuxN0b8H7s/RU2oW0Wvsx9O0ACRN/kRq9E8Vu/ReskGB5o3ji+FzHQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "graceful-fs": "^4.2.0",
                "jsonfile": "^6.0.1",
                "universalify": "^2.0.0"
            },
            "engines": {
                "node": ">=12"
            }
        },
        "node_modules/fs-minipass": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/fs-minipass/-/fs-minipass-2.1.0.tgz",
            "integrity": "sha512-V/JgOLFCS+R6Vcq0slCuaeWEdNC3ouDlJMNIsacH2VtALiu9mV4LPrHc5cDl8k5aw6J8jwgWWpiTo5RYhmIzvg==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "minipass": "^3.0.0"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/fs.realpath": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
            "integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8=",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/fsevents": {
            "version": "2.3.2",
            "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
            "integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
            "dev": true,
            "license": "MIT",
            "optional": true,
            "os": [
                "darwin"
            ],
            "engines": {
                "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
            }
        },
        "node_modules/function-bind": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
            "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/gensync": {
            "version": "1.0.0-beta.2",
            "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
            "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=6.9.0"
            }
        },
        "node_modules/get-caller-file": {
            "version": "2.0.5",
            "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
            "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
            "dev": true,
            "license": "ISC",
            "engines": {
                "node": "6.* || 8.* || >= 10.*"
            }
        },
        "node_modules/get-func-name": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/get-func-name/-/get-func-name-2.0.0.tgz",
            "integrity": "sha1-6td0q+5y4gQJQzoGY2YCPdaIekE=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": "*"
            }
        },
        "node_modules/get-intrinsic": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.1.1.tgz",
            "integrity": "sha512-kWZrnVM42QCiEA2Ig1bG8zjoIMOgxWwYCEeNdwY6Tv/cOSeGpcoX4pXHfKUxNKVoArnrEr2e9srnAxxGIraS9Q==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "function-bind": "^1.1.1",
                "has": "^1.0.3",
                "has-symbols": "^1.0.1"
            },
            "funding": {
                "url": "https://github.com/sponsors/ljharb"
            }
        },
        "node_modules/get-iterator": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/get-iterator/-/get-iterator-1.0.2.tgz",
            "integrity": "sha512-v+dm9bNVfOYsY1OrhaCrmyOcYoSeVvbt+hHZ0Au+T+p1y+0Uyj9aMaGIeUTT6xdpRbWzDeYKvfOslPhggQMcsg==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/glob": {
            "version": "7.2.0",
            "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.0.tgz",
            "integrity": "sha512-lmLf6gtyrPq8tTjSmrO94wBeQbFR3HbLHbuyD69wuyQkImp2hWqMGB47OX65FBkPffO641IP9jWa1z4ivqG26Q==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "fs.realpath": "^1.0.0",
                "inflight": "^1.0.4",
                "inherits": "2",
                "minimatch": "^3.0.4",
                "once": "^1.3.0",
                "path-is-absolute": "^1.0.0"
            },
            "engines": {
                "node": "*"
            },
            "funding": {
                "url": "https://github.com/sponsors/isaacs"
            }
        },
        "node_modules/glob-parent": {
            "version": "5.1.2",
            "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
            "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "is-glob": "^4.0.1"
            },
            "engines": {
                "node": ">= 6"
            }
        },
        "node_modules/globals": {
            "version": "11.12.0",
            "resolved": "https://registry.npmjs.org/globals/-/globals-11.12.0.tgz",
            "integrity": "sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/graceful-fs": {
            "version": "4.2.10",
            "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.10.tgz",
            "integrity": "sha512-9ByhssR2fPVsNZj478qUUbKfmL0+t5BDVyjShtyZZLiK7ZDAArFFfopyOTj0M05wE2tJPisA4iTnnXl2YoPvOA==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/growl": {
            "version": "1.10.5",
            "resolved": "https://registry.npmjs.org/growl/-/growl-1.10.5.tgz",
            "integrity": "sha512-qBr4OuELkhPenW6goKVXiv47US3clb3/IbuWF9KNKEijAy9oeHxU9IgzjvJhHkUzhaj7rOUD7+YGWqUjLp5oSA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4.x"
            }
        },
        "node_modules/has": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
            "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "function-bind": "^1.1.1"
            },
            "engines": {
                "node": ">= 0.4.0"
            }
        },
        "node_modules/has-flag": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
            "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/has-symbols": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
            "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.4"
            },
            "funding": {
                "url": "https://github.com/sponsors/ljharb"
            }
        },
        "node_modules/he": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/he/-/he-1.2.0.tgz",
            "integrity": "sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "he": "bin/he"
            }
        },
        "node_modules/header-case": {
            "version": "2.0.4",
            "resolved": "https://registry.npmjs.org/header-case/-/header-case-2.0.4.tgz",
            "integrity": "sha512-H/vuk5TEEVZwrR0lp2zed9OCo1uAILMlx0JEMgC26rzyJJ3N1v6XkwHHXJQdR2doSjcGPM6OKPYoJgf0plJ11Q==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "capital-case": "^1.0.4",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/html-encoding-sniffer": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/html-encoding-sniffer/-/html-encoding-sniffer-3.0.0.tgz",
            "integrity": "sha512-oWv4T4yJ52iKrufjnyZPkrN0CH3QnrUqdB6In1g5Fe1mia8GmF36gnfNySxoZtxD5+NmYw1EElVXiBk93UeskA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "whatwg-encoding": "^2.0.0"
            },
            "engines": {
                "node": ">=12"
            }
        },
        "node_modules/html-minifier-terser": {
            "version": "6.1.0",
            "resolved": "https://registry.npmjs.org/html-minifier-terser/-/html-minifier-terser-6.1.0.tgz",
            "integrity": "sha512-YXxSlJBZTP7RS3tWnQw74ooKa6L9b9i9QYXY21eUEvhZ3u9XLfv6OnFsQq6RxkhHygsaUMvYsZRV5rU/OVNZxw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "camel-case": "^4.1.2",
                "clean-css": "^5.2.2",
                "commander": "^8.3.0",
                "he": "^1.2.0",
                "param-case": "^3.0.4",
                "relateurl": "^0.2.7",
                "terser": "^5.10.0"
            },
            "bin": {
                "html-minifier-terser": "cli.js"
            },
            "engines": {
                "node": ">=12"
            }
        },
        "node_modules/html-minifier-terser/node_modules/commander": {
            "version": "8.3.0",
            "resolved": "https://registry.npmjs.org/commander/-/commander-8.3.0.tgz",
            "integrity": "sha512-OkTL9umf+He2DZkUq8f8J9of7yL6RJKI24dVITBmNfZBmri9zYZQrKkuXiKhyfPSu8tUhnVBB1iKXevvnlR4Ww==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 12"
            }
        },
        "node_modules/http-cache-semantics": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/http-cache-semantics/-/http-cache-semantics-4.1.0.tgz",
            "integrity": "sha512-carPklcUh7ROWRK7Cv27RPtdhYhUsela/ue5/jKzjegVvXDqM2ILE9Q2BGn9JZJh1g87cp56su/FgQSzcWS8cQ==",
            "dev": true,
            "license": "BSD-2-Clause"
        },
        "node_modules/http-errors": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
            "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "depd": "2.0.0",
                "inherits": "2.0.4",
                "setprototypeof": "1.2.0",
                "statuses": "2.0.1",
                "toidentifier": "1.0.1"
            },
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/http-proxy": {
            "version": "1.18.1",
            "resolved": "https://registry.npmjs.org/http-proxy/-/http-proxy-1.18.1.tgz",
            "integrity": "sha512-7mz/721AbnJwIVbnaSv1Cz3Am0ZLT/UBwkC92VlxhXv/k/BBQfM2fXElQNC27BVGr0uwUpplYPQM9LnaBMR5NQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "eventemitter3": "^4.0.0",
                "follow-redirects": "^1.0.0",
                "requires-port": "^1.0.0"
            },
            "engines": {
                "node": ">=8.0.0"
            }
        },
        "node_modules/http-proxy-agent": {
            "version": "4.0.1",
            "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-4.0.1.tgz",
            "integrity": "sha512-k0zdNgqWTGA6aeIRVpvfVob4fL52dTfaehylg0Y4UvSySvOq/Y+BOyPrgpUrA7HylqvU8vIZGsRuXmspskV0Tg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@tootallnate/once": "1",
                "agent-base": "6",
                "debug": "4"
            },
            "engines": {
                "node": ">= 6"
            }
        },
        "node_modules/http-server": {
            "version": "14.1.0",
            "resolved": "https://registry.npmjs.org/http-server/-/http-server-14.1.0.tgz",
            "integrity": "sha512-5lYsIcZtf6pdR8tCtzAHTWrAveo4liUlJdWc7YafwK/maPgYHs+VNP6KpCClmUnSorJrARVMXqtT055zBv11Yg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "basic-auth": "^2.0.1",
                "chalk": "^4.1.2",
                "corser": "^2.0.1",
                "he": "^1.2.0",
                "html-encoding-sniffer": "^3.0.0",
                "http-proxy": "^1.18.1",
                "mime": "^1.6.0",
                "minimist": "^1.2.5",
                "opener": "^1.5.1",
                "portfinder": "^1.0.28",
                "secure-compare": "3.0.1",
                "union": "~0.5.0",
                "url-join": "^4.0.1"
            },
            "bin": {
                "http-server": "bin/http-server"
            },
            "engines": {
                "node": ">=12"
            }
        },
        "node_modules/https-proxy-agent": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-5.0.1.tgz",
            "integrity": "sha512-dFcAjpTQFgoLMzC2VwU+C/CbS7uRL0lWmxDITmqm7C+7F0Odmj6s9l6alZc6AELXhrnggM2CeWSXHGOdX2YtwA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "agent-base": "6",
                "debug": "4"
            },
            "engines": {
                "node": ">= 6"
            }
        },
        "node_modules/humanize-ms": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/humanize-ms/-/humanize-ms-1.2.1.tgz",
            "integrity": "sha1-xG4xWaKT9riW2ikxbYtv6Lt5u+0=",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ms": "^2.0.0"
            }
        },
        "node_modules/iconv-lite": {
            "version": "0.4.24",
            "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
            "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "safer-buffer": ">= 2.1.2 < 3"
            },
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/ieee754": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
            "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
            "dev": true,
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "BSD-3-Clause"
        },
        "node_modules/imurmurhash": {
            "version": "0.1.4",
            "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
            "integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.8.19"
            }
        },
        "node_modules/indent-string": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/indent-string/-/indent-string-4.0.0.tgz",
            "integrity": "sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/infer-owner": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/infer-owner/-/infer-owner-1.0.4.tgz",
            "integrity": "sha512-IClj+Xz94+d7irH5qRyfJonOdfTzuDaifE6ZPWfx0N0+/ATZCbuTPq2prFl526urkQd90WyUKIh1DfBQ2hMz9A==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/inflight": {
            "version": "1.0.6",
            "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
            "integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "once": "^1.3.0",
                "wrappy": "1"
            }
        },
        "node_modules/inherits": {
            "version": "2.0.4",
            "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
            "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/interface-datastore": {
            "version": "6.1.0",
            "resolved": "https://registry.npmjs.org/interface-datastore/-/interface-datastore-6.1.0.tgz",
            "integrity": "sha512-oNHdsrWBsI/kDwUtEgt+aaZtQFKtQYN0TGZzc3SGiIA6m+plZ6malhmsygtbmDpfpIsNNC7ce9Gyaj+Tki+gVw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "interface-store": "^2.0.1",
                "nanoid": "^3.0.2",
                "uint8arrays": "^3.0.0"
            }
        },
        "node_modules/interface-store": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/interface-store/-/interface-store-2.0.2.tgz",
            "integrity": "sha512-rScRlhDcz6k199EkHqT8NpM87ebN89ICOzILoBHgaG36/WX50N32BnU/kpZgCGPLhARRAWUUX5/cyaIjt7Kipg==",
            "dev": true,
            "license": "(Apache-2.0 OR MIT)"
        },
        "node_modules/ip": {
            "version": "1.1.5",
            "resolved": "https://registry.npmjs.org/ip/-/ip-1.1.5.tgz",
            "integrity": "sha1-vd7XARQpCCjAoDnnLvJfWq7ENUo=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/ip-regex": {
            "version": "4.3.0",
            "resolved": "https://registry.npmjs.org/ip-regex/-/ip-regex-4.3.0.tgz",
            "integrity": "sha512-B9ZWJxHHOHUhUjCPrMpLD4xEq35bUTClHM1S6CBU5ixQnkZmwipwgc96vAd7AAGM9TGHvJR+Uss+/Ak6UphK+Q==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/ipfs-client": {
            "version": "0.7.8",
            "resolved": "https://registry.npmjs.org/ipfs-client/-/ipfs-client-0.7.8.tgz",
            "integrity": "sha512-Rwpq8ZWtE5+yiTV2ICr5PljI0IPr3nmhIJeOtq2+UP+QElOcRz4egQEEBzo9EiIyvHBMU+v5LVW4OMQWYVImIQ==",
            "dev": true,
            "license": "(Apache-2.0 OR MIT)",
            "dependencies": {
                "ipfs-grpc-client": "^0.9.3",
                "ipfs-http-client": "^56.0.2",
                "merge-options": "^3.0.4"
            }
        },
        "node_modules/ipfs-core-types": {
            "version": "0.10.2",
            "resolved": "https://registry.npmjs.org/ipfs-core-types/-/ipfs-core-types-0.10.2.tgz",
            "integrity": "sha512-IyPCAiiPiZ4qmmBFgh+wSS3aAQya5Ck+9lDYjBCw1+hK3SC3RzEP49CWqQMKQYbMnaa9pY1GsnGJkLC0TiE2vA==",
            "dev": true,
            "license": "(Apache-2.0 OR MIT)",
            "dependencies": {
                "@ipld/dag-pb": "^2.1.3",
                "interface-datastore": "^6.0.2",
                "ipfs-unixfs": "^6.0.3",
                "multiaddr": "^10.0.0",
                "multiformats": "^9.5.1"
            }
        },
        "node_modules/ipfs-core-utils": {
            "version": "0.14.2",
            "resolved": "https://registry.npmjs.org/ipfs-core-utils/-/ipfs-core-utils-0.14.2.tgz",
            "integrity": "sha512-wgyg4QRSokSIxnhU1qTJQoEz/gzf6WHB4zBKTfMrQuiF55943aF06v3x2tZ4l+Hcgr2yEa7COSapcfCFKFsuoA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "any-signal": "^3.0.0",
                "blob-to-it": "^1.0.1",
                "browser-readablestream-to-it": "^1.0.1",
                "debug": "^4.1.1",
                "err-code": "^3.0.1",
                "ipfs-core-types": "^0.10.2",
                "ipfs-unixfs": "^6.0.3",
                "ipfs-utils": "^9.0.2",
                "it-all": "^1.0.4",
                "it-map": "^1.0.4",
                "it-peekable": "^1.0.2",
                "it-to-stream": "^1.0.0",
                "merge-options": "^3.0.4",
                "multiaddr": "^10.0.0",
                "multiaddr-to-uri": "^8.0.0",
                "multiformats": "^9.5.1",
                "nanoid": "^3.1.23",
                "parse-duration": "^1.0.0",
                "timeout-abort-controller": "^3.0.0",
                "uint8arrays": "^3.0.0"
            }
        },
        "node_modules/ipfs-grpc-client": {
            "version": "0.9.3",
            "resolved": "https://registry.npmjs.org/ipfs-grpc-client/-/ipfs-grpc-client-0.9.3.tgz",
            "integrity": "sha512-lje6KJOnak8boVzjLwMkSRAS6qrYfh6FoTfxVekK90yRXTjUvBXnLOixk4LD35aSANZKD4YfBiTi97TjrroxGA==",
            "dev": true,
            "license": "(Apache-2.0 OR MIT)",
            "dependencies": {
                "@improbable-eng/grpc-web": "^0.14.0",
                "change-case": "^4.1.1",
                "debug": "^4.1.1",
                "err-code": "^3.0.1",
                "ipfs-core-types": "^0.10.2",
                "ipfs-core-utils": "^0.14.2",
                "ipfs-grpc-protocol": "^0.5.5",
                "ipfs-unixfs": "^6.0.3",
                "it-first": "^1.0.4",
                "it-pushable": "^1.4.2",
                "multiaddr": "^10.0.0",
                "multiformats": "^9.5.1",
                "p-defer": "^3.0.0",
                "protobufjs": "^6.10.2",
                "wherearewe": "^1.0.0",
                "ws": "^7.3.1"
            }
        },
        "node_modules/ipfs-grpc-protocol": {
            "version": "0.5.5",
            "resolved": "https://registry.npmjs.org/ipfs-grpc-protocol/-/ipfs-grpc-protocol-0.5.5.tgz",
            "integrity": "sha512-zoJ+xwcYwzJ03GWJdz3e2k1NqJMfI9+M/VyPImhqPowVmTZ0+f9JGR+M8MetJAHMeQILLCTXmIMsiFzAFObZJg==",
            "dev": true,
            "license": "(Apache-2.0 OR MIT)"
        },
        "node_modules/ipfs-http-client": {
            "version": "56.0.2",
            "resolved": "https://registry.npmjs.org/ipfs-http-client/-/ipfs-http-client-56.0.2.tgz",
            "integrity": "sha512-IeIJJo6CDNCnTFz2hTSzzBDX34/jJmlyxk65NJAS+kgvel9aPRYaSestymDJWvOZj4/bBtiJ8X2CsRQoaVyIBg==",
            "dev": true,
            "license": "(Apache-2.0 OR MIT)",
            "dependencies": {
                "@ipld/dag-cbor": "^7.0.0",
                "@ipld/dag-json": "^8.0.1",
                "@ipld/dag-pb": "^2.1.3",
                "any-signal": "^3.0.0",
                "dag-jose": "^1.0.0",
                "debug": "^4.1.1",
                "err-code": "^3.0.1",
                "ipfs-core-types": "^0.10.2",
                "ipfs-core-utils": "^0.14.2",
                "ipfs-utils": "^9.0.2",
                "it-first": "^1.0.6",
                "it-last": "^1.0.4",
                "merge-options": "^3.0.4",
                "multiaddr": "^10.0.0",
                "multiformats": "^9.5.1",
                "parse-duration": "^1.0.0",
                "stream-to-it": "^0.2.2",
                "uint8arrays": "^3.0.0"
            },
            "engines": {
                "node": ">=15.0.0",
                "npm": ">=3.0.0"
            }
        },
        "node_modules/ipfs-unixfs": {
            "version": "6.0.6",
            "resolved": "https://registry.npmjs.org/ipfs-unixfs/-/ipfs-unixfs-6.0.6.tgz",
            "integrity": "sha512-gTkjYKXuHnqIf6EFfS+ESaYEl3I3aaQQ0UX8MhpNzreMLEuMnuqpoI/uLLllTZa31WRplKixabbpRTSmTYRNwA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "err-code": "^3.0.1",
                "protobufjs": "^6.10.2"
            },
            "engines": {
                "node": ">=14.0.0",
                "npm": ">=6.0.0"
            }
        },
        "node_modules/ipfs-utils": {
            "version": "9.0.6",
            "resolved": "https://registry.npmjs.org/ipfs-utils/-/ipfs-utils-9.0.6.tgz",
            "integrity": "sha512-/WfdwOIiJVb3uqfKRQ9Eo+vCEKsDgp7h4Pdc37MRwAiFciZ7xKAkEqsfXubV0VQi8x5jWTifeHn8WEPBLL451w==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "any-signal": "^3.0.0",
                "buffer": "^6.0.1",
                "electron-fetch": "^1.7.2",
                "err-code": "^3.0.1",
                "is-electron": "^2.2.0",
                "iso-url": "^1.1.5",
                "it-glob": "^1.0.1",
                "it-to-stream": "^1.0.0",
                "merge-options": "^3.0.4",
                "nanoid": "^3.1.20",
                "native-fetch": "^3.0.0",
                "node-fetch": "https://registry.npmjs.org/@achingbrain/node-fetch/-/node-fetch-2.6.7.tgz",
                "react-native-fetch-api": "^2.0.0",
                "stream-to-it": "^0.2.2"
            }
        },
        "node_modules/is-binary-path": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
            "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "binary-extensions": "^2.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/is-electron": {
            "version": "2.2.1",
            "resolved": "https://registry.npmjs.org/is-electron/-/is-electron-2.2.1.tgz",
            "integrity": "sha512-r8EEQQsqT+Gn0aXFx7lTFygYQhILLCB+wn0WCDL5LZRINeLH/Rvw1j2oKodELLXYNImQ3CRlVsY8wW4cGOsyuw==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/is-extglob": {
            "version": "2.1.1",
            "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
            "integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/is-fullwidth-code-point": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
            "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/is-glob": {
            "version": "4.0.3",
            "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
            "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "is-extglob": "^2.1.1"
            },
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/is-ip": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/is-ip/-/is-ip-3.1.0.tgz",
            "integrity": "sha512-35vd5necO7IitFPjd/YBeqwWnyDWbuLH9ZXQdMfDA8TEo7pv5X8yfrvVO3xbJbLUlERCMvf6X0hTUamQxCYJ9Q==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ip-regex": "^4.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/is-lambda": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/is-lambda/-/is-lambda-1.0.1.tgz",
            "integrity": "sha1-PZh3iZ5qU+/AFgUEzeFfgubwYdU=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/is-number": {
            "version": "7.0.0",
            "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
            "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.12.0"
            }
        },
        "node_modules/is-plain-obj": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/is-plain-obj/-/is-plain-obj-2.1.0.tgz",
            "integrity": "sha512-YWnfyRwxL/+SsrWYfOpUtz5b3YD+nyfkHvjbcanzk8zgyO4ASD67uVMRt8k5bM4lLMDnXfriRhOpemw+NfT1eA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/is-unicode-supported": {
            "version": "0.1.0",
            "resolved": "https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz",
            "integrity": "sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/isbinaryfile": {
            "version": "4.0.10",
            "resolved": "https://registry.npmjs.org/isbinaryfile/-/isbinaryfile-4.0.10.tgz",
            "integrity": "sha512-iHrqe5shvBUcFbmZq9zOQHBoeOhZJu6RQGrDpBgenUm/Am+F3JM2MgQj+rK3Z601fzrL5gLZWtAPH2OBaSVcyw==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 8.0.0"
            },
            "funding": {
                "url": "https://github.com/sponsors/gjtorikian/"
            }
        },
        "node_modules/isexe": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
            "integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/iso-url": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/iso-url/-/iso-url-1.2.1.tgz",
            "integrity": "sha512-9JPDgCN4B7QPkLtYAAOrEuAWvP9rWvR5offAr0/SeF046wIkglqH3VXgYYP6NcsKslH80UIVgmPqNe3j7tG2ng==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=12"
            }
        },
        "node_modules/it-all": {
            "version": "1.0.6",
            "resolved": "https://registry.npmjs.org/it-all/-/it-all-1.0.6.tgz",
            "integrity": "sha512-3cmCc6Heqe3uWi3CVM/k51fa/XbMFpQVzFoDsV0IZNHSQDyAXl3c4MjHkFX5kF3922OGj7Myv1nSEUgRtcuM1A==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/it-first": {
            "version": "1.0.7",
            "resolved": "https://registry.npmjs.org/it-first/-/it-first-1.0.7.tgz",
            "integrity": "sha512-nvJKZoBpZD/6Rtde6FXqwDqDZGF1sCADmr2Zoc0hZsIvnE449gRFnGctxDf09Bzc/FWnHXAdaHVIetY6lrE0/g==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/it-glob": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/it-glob/-/it-glob-1.0.2.tgz",
            "integrity": "sha512-Ch2Dzhw4URfB9L/0ZHyY+uqOnKvBNeS/SMcRiPmJfpHiM0TsUZn+GkpcZxAoF3dJVdPm/PuIk3A4wlV7SUo23Q==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "@types/minimatch": "^3.0.4",
                "minimatch": "^3.0.4"
            }
        },
        "node_modules/it-last": {
            "version": "1.0.6",
            "resolved": "https://registry.npmjs.org/it-last/-/it-last-1.0.6.tgz",
            "integrity": "sha512-aFGeibeiX/lM4bX3JY0OkVCFkAw8+n9lkukkLNivbJRvNz8lI3YXv5xcqhFUV2lDJiraEK3OXRDbGuevnnR67Q==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/it-map": {
            "version": "1.0.6",
            "resolved": "https://registry.npmjs.org/it-map/-/it-map-1.0.6.tgz",
            "integrity": "sha512-XT4/RM6UHIFG9IobGlQPFQUrlEKkU4eBUFG3qhWhfAdh1JfF2x11ShCrKCdmZ0OiZppPfoLuzcfA4cey6q3UAQ==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/it-peekable": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/it-peekable/-/it-peekable-1.0.3.tgz",
            "integrity": "sha512-5+8zemFS+wSfIkSZyf0Zh5kNN+iGyccN02914BY4w/Dj+uoFEoPSvj5vaWn8pNZJNSxzjW0zHRxC3LUb2KWJTQ==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/it-pushable": {
            "version": "1.4.2",
            "resolved": "https://registry.npmjs.org/it-pushable/-/it-pushable-1.4.2.tgz",
            "integrity": "sha512-vVPu0CGRsTI8eCfhMknA7KIBqqGFolbRx+1mbQ6XuZ7YCz995Qj7L4XUviwClFunisDq96FdxzF5FnAbw15afg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "fast-fifo": "^1.0.0"
            }
        },
        "node_modules/it-to-stream": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/it-to-stream/-/it-to-stream-1.0.0.tgz",
            "integrity": "sha512-pLULMZMAB/+vbdvbZtebC0nWBTbG581lk6w8P7DfIIIKUfa8FbY7Oi0FxZcFPbxvISs7A9E+cMpLDBc1XhpAOA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "buffer": "^6.0.3",
                "fast-fifo": "^1.0.0",
                "get-iterator": "^1.0.2",
                "p-defer": "^3.0.0",
                "p-fifo": "^1.0.0",
                "readable-stream": "^3.6.0"
            }
        },
        "node_modules/jest-worker": {
            "version": "26.6.2",
            "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-26.6.2.tgz",
            "integrity": "sha512-KWYVV1c4i+jbMpaBC+U++4Va0cp8OisU185o73T1vo99hqi7w8tSJfUXYswwqqrjzwxa6KpRK54WhPvwf5w6PQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/node": "*",
                "merge-stream": "^2.0.0",
                "supports-color": "^7.0.0"
            },
            "engines": {
                "node": ">= 10.13.0"
            }
        },
        "node_modules/js-tokens": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
            "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/js-yaml": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
            "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "argparse": "^2.0.1"
            },
            "bin": {
                "js-yaml": "bin/js-yaml.js"
            }
        },
        "node_modules/jsesc": {
            "version": "2.5.2",
            "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-2.5.2.tgz",
            "integrity": "sha512-OYu7XEzjkCQ3C5Ps3QIZsQfNpqoJyZZA99wd9aWd05NCtC5pWOkShK2mkL6HXQR6/Cy2lbNdPlZBpuQHXE63gA==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "jsesc": "bin/jsesc"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/json5": {
            "version": "2.2.1",
            "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.1.tgz",
            "integrity": "sha512-1hqLFMSrGHRHxav9q9gNjJ5EXznIxGVO09xQRrwplcS8qs28pZ8s8hupZAmqDwZUmVZ2Qb2jnyPOWcDH8m8dlA==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "json5": "lib/cli.js"
            },
            "engines": {
                "node": ">=6"
            }
        },
        "node_modules/jsonfile": {
            "version": "6.1.0",
            "resolved": "https://registry.npmjs.org/jsonfile/-/jsonfile-6.1.0.tgz",
            "integrity": "sha512-5dgndWOriYSm5cnYaJNhalLNDKOqFwyDB/rr1E9ZsGciGvKPs8R2xYGCacuf3z6K1YKDz182fd+fY3cn3pMqXQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "universalify": "^2.0.0"
            },
            "optionalDependencies": {
                "graceful-fs": "^4.1.6"
            }
        },
        "node_modules/karma": {
            "version": "6.3.19",
            "resolved": "https://registry.npmjs.org/karma/-/karma-6.3.19.tgz",
            "integrity": "sha512-NDhWckzES/Y9xMiddyU1RzaKL76/scCsu8Mp0vR0Z3lQRvC3p72+Ab4ppoxs36S9tyPNX5V48yvaV++RNEBPZw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@colors/colors": "1.5.0",
                "body-parser": "^1.19.0",
                "braces": "^3.0.2",
                "chokidar": "^3.5.1",
                "connect": "^3.7.0",
                "di": "^0.0.1",
                "dom-serialize": "^2.2.1",
                "glob": "^7.1.7",
                "graceful-fs": "^4.2.6",
                "http-proxy": "^1.18.1",
                "isbinaryfile": "^4.0.8",
                "lodash": "^4.17.21",
                "log4js": "^6.4.1",
                "mime": "^2.5.2",
                "minimatch": "^3.0.4",
                "mkdirp": "^0.5.5",
                "qjobs": "^1.2.0",
                "range-parser": "^1.2.1",
                "rimraf": "^3.0.2",
                "socket.io": "^4.4.1",
                "source-map": "^0.6.1",
                "tmp": "^0.2.1",
                "ua-parser-js": "^0.7.30",
                "yargs": "^16.1.1"
            },
            "bin": {
                "karma": "bin/karma"
            },
            "engines": {
                "node": ">= 10"
            }
        },
        "node_modules/karma-chai": {
            "version": "0.1.0",
            "resolved": "https://registry.npmjs.org/karma-chai/-/karma-chai-0.1.0.tgz",
            "integrity": "sha1-vuWtQEAFF4Ea40u5RfdikJEIt5o=",
            "dev": true,
            "license": "MIT",
            "peerDependencies": {
                "chai": "*",
                "karma": ">=0.10.9"
            }
        },
        "node_modules/karma-chrome-launcher": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/karma-chrome-launcher/-/karma-chrome-launcher-3.1.1.tgz",
            "integrity": "sha512-hsIglcq1vtboGPAN+DGCISCFOxW+ZVnIqhDQcCMqqCp+4dmJ0Qpq5QAjkbA0X2L9Mi6OBkHi2Srrbmm7pUKkzQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "which": "^1.2.1"
            }
        },
        "node_modules/karma-chrome-launcher/node_modules/which": {
            "version": "1.3.1",
            "resolved": "https://registry.npmjs.org/which/-/which-1.3.1.tgz",
            "integrity": "sha512-HxJdYWq1MTIQbJ3nw0cqssHoTNU267KlrDuGZ1WYlxDStUtKUhOaJmh112/TZmHxxUfuJqPXSOm7tDyas0OSIQ==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "isexe": "^2.0.0"
            },
            "bin": {
                "which": "bin/which"
            }
        },
        "node_modules/karma-mocha": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/karma-mocha/-/karma-mocha-2.0.1.tgz",
            "integrity": "sha512-Tzd5HBjm8his2OA4bouAsATYEpZrp9vC7z5E5j4C5Of5Rrs1jY67RAwXNcVmd/Bnk1wgvQRou0zGVLey44G4tQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "minimist": "^1.2.3"
            }
        },
        "node_modules/karma/node_modules/mime": {
            "version": "2.6.0",
            "resolved": "https://registry.npmjs.org/mime/-/mime-2.6.0.tgz",
            "integrity": "sha512-USPkMeET31rOMiarsBNIHZKLGgvKc/LrjofAnBlOttf5ajRvqiRA8QsenbcooctK6d6Ts6aqZXBA+XbkKthiQg==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "mime": "cli.js"
            },
            "engines": {
                "node": ">=4.0.0"
            }
        },
        "node_modules/karma/node_modules/mkdirp": {
            "version": "0.5.6",
            "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
            "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "minimist": "^1.2.6"
            },
            "bin": {
                "mkdirp": "bin/cmd.js"
            }
        },
        "node_modules/lit": {
            "version": "2.2.4",
            "resolved": "https://registry.npmjs.org/lit/-/lit-2.2.4.tgz",
            "integrity": "sha512-O7t+uizo1/Br0y+5RaWRzPkd4MsoL4XY2eq7n2wrESyCCjeagq4ERZKsyKX40jbmsz4bAAs7/0qNRX11TuXzoA==",
            "dependencies": {
                "@lit/reactive-element": "^1.3.0",
                "lit-element": "^3.2.0",
                "lit-html": "^2.2.0"
            }
        },
        "node_modules/lit-element": {
            "version": "3.2.0",
            "resolved": "https://registry.npmjs.org/lit-element/-/lit-element-3.2.0.tgz",
            "integrity": "sha512-HbE7yt2SnUtg5DCrWt028oaU4D5F4k/1cntAFHTkzY8ZIa8N0Wmu92PxSxucsQSOXlODFrICkQ5x/tEshKi13g==",
            "dependencies": {
                "@lit/reactive-element": "^1.3.0",
                "lit-html": "^2.2.0"
            }
        },
        "node_modules/lit-html": {
            "version": "2.2.4",
            "resolved": "https://registry.npmjs.org/lit-html/-/lit-html-2.2.4.tgz",
            "integrity": "sha512-IPY0V0z/QWcTduxb6DlP46Un8n6tG+mHSAijGcPozfXTjVkvFLN4/irPzthtq/eC8RU+7CUqh6h4KB7tnRPJfg==",
            "dependencies": {
                "@types/trusted-types": "^2.0.2"
            }
        },
        "node_modules/locate-path": {
            "version": "6.0.0",
            "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
            "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "p-locate": "^5.0.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/lodash": {
            "version": "4.17.21",
            "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
            "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/log-symbols": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz",
            "integrity": "sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "chalk": "^4.1.0",
                "is-unicode-supported": "^0.1.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/log4js": {
            "version": "6.4.6",
            "resolved": "https://registry.npmjs.org/log4js/-/log4js-6.4.6.tgz",
            "integrity": "sha512-1XMtRBZszmVZqPAOOWczH+Q94AI42mtNWjvjA5RduKTSWjEc56uOBbyM1CJnfN4Ym0wSd8cQ43zOojlSHgRDAw==",
            "dev": true,
            "license": "Apache-2.0",
            "dependencies": {
                "date-format": "^4.0.9",
                "debug": "^4.3.4",
                "flatted": "^3.2.5",
                "rfdc": "^1.3.0",
                "streamroller": "^3.0.8"
            },
            "engines": {
                "node": ">=8.0"
            }
        },
        "node_modules/long": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/long/-/long-4.0.0.tgz",
            "integrity": "sha512-XsP+KhQif4bjX1kbuSiySJFNAehNxgLb6hPRGJ9QsUr8ajHkuXGdrHmFUTUUXhDwVX2R5bY4JNZEwbUiMhV+MA==",
            "dev": true,
            "license": "Apache-2.0"
        },
        "node_modules/loupe": {
            "version": "2.3.4",
            "resolved": "https://registry.npmjs.org/loupe/-/loupe-2.3.4.tgz",
            "integrity": "sha512-OvKfgCC2Ndby6aSTREl5aCCPTNIzlDfQZvZxNUrBrihDhL3xcrYegTblhmEiCrg2kKQz4XsFIaemE5BF4ybSaQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "get-func-name": "^2.0.0"
            }
        },
        "node_modules/lower-case": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/lower-case/-/lower-case-2.0.2.tgz",
            "integrity": "sha512-7fm3l3NAF9WfN6W3JOmf5drwpVqX78JtoGJ3A6W0a6ZnldM41w2fV5D490psKFTpMds8TJse/eHLFFsNHHjHgg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "tslib": "^2.0.3"
            }
        },
        "node_modules/lru-cache": {
            "version": "6.0.0",
            "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
            "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "yallist": "^4.0.0"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/magic-string": {
            "version": "0.25.9",
            "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.25.9.tgz",
            "integrity": "sha512-RmF0AsMzgt25qzqqLc1+MbHmhdx0ojF2Fvs4XnOqz2ZOBXzzkEwc/dJQZCYHAn7v1jbVOjAZfK8msRn4BxO4VQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "sourcemap-codec": "^1.4.8"
            }
        },
        "node_modules/make-fetch-happen": {
            "version": "8.0.14",
            "resolved": "https://registry.npmjs.org/make-fetch-happen/-/make-fetch-happen-8.0.14.tgz",
            "integrity": "sha512-EsS89h6l4vbfJEtBZnENTOFk8mCRpY5ru36Xe5bcX1KYIli2mkSHqoFsp5O1wMDvTJJzxe/4THpCTtygjeeGWQ==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "agentkeepalive": "^4.1.3",
                "cacache": "^15.0.5",
                "http-cache-semantics": "^4.1.0",
                "http-proxy-agent": "^4.0.1",
                "https-proxy-agent": "^5.0.0",
                "is-lambda": "^1.0.1",
                "lru-cache": "^6.0.0",
                "minipass": "^3.1.3",
                "minipass-collect": "^1.0.2",
                "minipass-fetch": "^1.3.2",
                "minipass-flush": "^1.0.5",
                "minipass-pipeline": "^1.2.4",
                "promise-retry": "^2.0.1",
                "socks-proxy-agent": "^5.0.0",
                "ssri": "^8.0.0"
            },
            "engines": {
                "node": ">= 10"
            }
        },
        "node_modules/media-typer": {
            "version": "0.3.0",
            "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
            "integrity": "sha1-hxDXrwqmJvj/+hzgAWhUUmMlV0g=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/merge-options": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/merge-options/-/merge-options-3.0.4.tgz",
            "integrity": "sha512-2Sug1+knBjkaMsMgf1ctR1Ujx+Ayku4EdJN4Z+C2+JzoeF7A3OZ9KM2GY0CpQS51NR61LTurMJrRKPhSs3ZRTQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "is-plain-obj": "^2.1.0"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/merge-stream": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
            "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/mime": {
            "version": "1.6.0",
            "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
            "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "mime": "cli.js"
            },
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/mime-db": {
            "version": "1.52.0",
            "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
            "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/mime-types": {
            "version": "2.1.35",
            "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
            "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "mime-db": "1.52.0"
            },
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/minimatch": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
            "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "brace-expansion": "^1.1.7"
            },
            "engines": {
                "node": "*"
            }
        },
        "node_modules/minimist": {
            "version": "1.2.6",
            "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.6.tgz",
            "integrity": "sha512-Jsjnk4bw3YJqYzbdyBiNsPWHPfO++UGG749Cxs6peCu5Xg4nrena6OVxOYxrQTqww0Jmwt+Ref8rggumkTLz9Q==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/minipass": {
            "version": "3.1.6",
            "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.1.6.tgz",
            "integrity": "sha512-rty5kpw9/z8SX9dmxblFA6edItUmwJgMeYDZRrwlIVN27i8gysGbznJwUggw2V/FVqFSDdWy040ZPS811DYAqQ==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "yallist": "^4.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/minipass-collect": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/minipass-collect/-/minipass-collect-1.0.2.tgz",
            "integrity": "sha512-6T6lH0H8OG9kITm/Jm6tdooIbogG9e0tLgpY6mphXSm/A9u8Nq1ryBG+Qspiub9LjWlBPsPS3tWQ/Botq4FdxA==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "minipass": "^3.0.0"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/minipass-fetch": {
            "version": "1.4.1",
            "resolved": "https://registry.npmjs.org/minipass-fetch/-/minipass-fetch-1.4.1.tgz",
            "integrity": "sha512-CGH1eblLq26Y15+Azk7ey4xh0J/XfJfrCox5LDJiKqI2Q2iwOLOKrlmIaODiSQS8d18jalF6y2K2ePUm0CmShw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "minipass": "^3.1.0",
                "minipass-sized": "^1.0.3",
                "minizlib": "^2.0.0"
            },
            "engines": {
                "node": ">=8"
            },
            "optionalDependencies": {
                "encoding": "^0.1.12"
            }
        },
        "node_modules/minipass-flush": {
            "version": "1.0.5",
            "resolved": "https://registry.npmjs.org/minipass-flush/-/minipass-flush-1.0.5.tgz",
            "integrity": "sha512-JmQSYYpPUqX5Jyn1mXaRwOda1uQ8HP5KAT/oDSLCzt1BYRhQU0/hDtsB1ufZfEEzMZ9aAVmsBw8+FWsIXlClWw==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "minipass": "^3.0.0"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/minipass-pipeline": {
            "version": "1.2.4",
            "resolved": "https://registry.npmjs.org/minipass-pipeline/-/minipass-pipeline-1.2.4.tgz",
            "integrity": "sha512-xuIq7cIOt09RPRJ19gdi4b+RiNvDFYe5JH+ggNvBqGqpQXcru3PcRmOZuHBKWK1Txf9+cQ+HMVN4d6z46LZP7A==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "minipass": "^3.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/minipass-sized": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/minipass-sized/-/minipass-sized-1.0.3.tgz",
            "integrity": "sha512-MbkQQ2CTiBMlA2Dm/5cY+9SWFEN8pzzOXi6rlM5Xxq0Yqbda5ZQy9sU75a673FE9ZK0Zsbr6Y5iP6u9nktfg2g==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "minipass": "^3.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/minizlib": {
            "version": "2.1.2",
            "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-2.1.2.tgz",
            "integrity": "sha512-bAxsR8BVfj60DWXHE3u30oHzfl4G7khkSuPW+qvpd7jFRHm7dLxOjUk1EHACJ/hxLY8phGJ0YhYHZo7jil7Qdg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "minipass": "^3.0.0",
                "yallist": "^4.0.0"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/mkdirp": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
            "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "mkdirp": "bin/cmd.js"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/mocha": {
            "version": "9.2.2",
            "resolved": "https://registry.npmjs.org/mocha/-/mocha-9.2.2.tgz",
            "integrity": "sha512-L6XC3EdwT6YrIk0yXpavvLkn8h+EU+Y5UcCHKECyMbdUIxyMuZj4bX4U9e1nvnvUUvQVsV2VHQr5zLdcUkhW/g==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@ungap/promise-all-settled": "1.1.2",
                "ansi-colors": "4.1.1",
                "browser-stdout": "1.3.1",
                "chokidar": "3.5.3",
                "debug": "4.3.3",
                "diff": "5.0.0",
                "escape-string-regexp": "4.0.0",
                "find-up": "5.0.0",
                "glob": "7.2.0",
                "growl": "1.10.5",
                "he": "1.2.0",
                "js-yaml": "4.1.0",
                "log-symbols": "4.1.0",
                "minimatch": "4.2.1",
                "ms": "2.1.3",
                "nanoid": "3.3.1",
                "serialize-javascript": "6.0.0",
                "strip-json-comments": "3.1.1",
                "supports-color": "8.1.1",
                "which": "2.0.2",
                "workerpool": "6.2.0",
                "yargs": "16.2.0",
                "yargs-parser": "20.2.4",
                "yargs-unparser": "2.0.0"
            },
            "bin": {
                "_mocha": "bin/_mocha",
                "mocha": "bin/mocha"
            },
            "engines": {
                "node": ">= 12.0.0"
            },
            "funding": {
                "type": "opencollective",
                "url": "https://opencollective.com/mochajs"
            }
        },
        "node_modules/mocha/node_modules/debug": {
            "version": "4.3.3",
            "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.3.tgz",
            "integrity": "sha512-/zxw5+vh1Tfv+4Qn7a5nsbcJKPaSvCDhojn6FEl9vupwK2VCSDtEiEtqr8DFtzYFOdz63LBkxec7DYuc2jon6Q==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ms": "2.1.2"
            },
            "engines": {
                "node": ">=6.0"
            },
            "peerDependenciesMeta": {
                "supports-color": {
                    "optional": true
                }
            }
        },
        "node_modules/mocha/node_modules/debug/node_modules/ms": {
            "version": "2.1.2",
            "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
            "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/mocha/node_modules/minimatch": {
            "version": "4.2.1",
            "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-4.2.1.tgz",
            "integrity": "sha512-9Uq1ChtSZO+Mxa/CL1eGizn2vRn3MlLgzhT0Iz8zaY8NdvxvB0d5QdPFmCKf7JKA9Lerx5vRrnwO03jsSfGG9g==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "brace-expansion": "^1.1.7"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/mocha/node_modules/nanoid": {
            "version": "3.3.1",
            "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.1.tgz",
            "integrity": "sha512-n6Vs/3KGyxPQd6uO0eH4Bv0ojGSUvuLlIHtC3Y0kEO23YRge8H9x1GCzLn28YX0H66pMkxuaeESFq4tKISKwdw==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "nanoid": "bin/nanoid.cjs"
            },
            "engines": {
                "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
            }
        },
        "node_modules/mocha/node_modules/supports-color": {
            "version": "8.1.1",
            "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
            "integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "has-flag": "^4.0.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/chalk/supports-color?sponsor=1"
            }
        },
        "node_modules/ms": {
            "version": "2.1.3",
            "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
            "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/multiaddr": {
            "version": "10.0.1",
            "resolved": "https://registry.npmjs.org/multiaddr/-/multiaddr-10.0.1.tgz",
            "integrity": "sha512-G5upNcGzEGuTHkzxezPrrD6CaIHR9uo+7MwqhNVcXTs33IInon4y7nMiGxl2CY5hG7chvYQUQhz5V52/Qe3cbg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "dns-over-http-resolver": "^1.2.3",
                "err-code": "^3.0.1",
                "is-ip": "^3.1.0",
                "multiformats": "^9.4.5",
                "uint8arrays": "^3.0.0",
                "varint": "^6.0.0"
            }
        },
        "node_modules/multiaddr-to-uri": {
            "version": "8.0.0",
            "resolved": "https://registry.npmjs.org/multiaddr-to-uri/-/multiaddr-to-uri-8.0.0.tgz",
            "integrity": "sha512-dq4p/vsOOUdVEd1J1gl+R2GFrXJQH8yjLtz4hodqdVbieg39LvBOdMQRdQnfbg5LSM/q1BYNVf5CBbwZFFqBgA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "multiaddr": "^10.0.0"
            }
        },
        "node_modules/multiformats": {
            "version": "9.6.4",
            "resolved": "https://registry.npmjs.org/multiformats/-/multiformats-9.6.4.tgz",
            "integrity": "sha512-fCCB6XMrr6CqJiHNjfFNGT0v//dxOBMrOMqUIzpPc/mmITweLEyhvMpY9bF+jZ9z3vaMAau5E8B68DW77QMXkg==",
            "dev": true,
            "license": "(Apache-2.0 AND MIT)"
        },
        "node_modules/nanoid": {
            "version": "3.3.3",
            "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.3.tgz",
            "integrity": "sha512-p1sjXuopFs0xg+fPASzQ28agW1oHD7xDsd9Xkf3T15H3c/cifrFHVwrh74PdoklAPi+i7MdRsE47vm2r6JoB+w==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "nanoid": "bin/nanoid.cjs"
            },
            "engines": {
                "node": "^10 || ^12 || ^13.7 || ^14 || >=15.0.1"
            }
        },
        "node_modules/native-fetch": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/native-fetch/-/native-fetch-3.0.0.tgz",
            "integrity": "sha512-G3Z7vx0IFb/FQ4JxvtqGABsOTIqRWvgQz6e+erkB+JJD6LrszQtMozEHI4EkmgZQvnGHrpLVzUWk7t4sJCIkVw==",
            "dev": true,
            "license": "MIT",
            "peerDependencies": {
                "node-fetch": "*"
            }
        },
        "node_modules/negotiator": {
            "version": "0.6.3",
            "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
            "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/no-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/no-case/-/no-case-3.0.4.tgz",
            "integrity": "sha512-fgAN3jGAh+RoxUGZHTSOLJIqUc2wmoBwGR4tbpNAKmmovFoWq0OdRkb0VkldReO2a2iBT/OEulG9XSUc10r3zg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "lower-case": "^2.0.2",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/node-fetch": {
            "name": "@achingbrain/node-fetch",
            "version": "2.6.7",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": "4.x || >=6.0.0"
            }
        },
        "node_modules/node-releases": {
            "version": "2.0.3",
            "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.3.tgz",
            "integrity": "sha512-maHFz6OLqYxz+VQyCAtA3PTX4UP/53pa05fyDNc9CwjvJ0yEh6+xBwKsgCxMNhS8taUKBFYxfuiaD9U/55iFaw==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/normalize-path": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
            "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/object-assign": {
            "version": "4.1.1",
            "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
            "integrity": "sha1-IQmtx5ZYh8/AXLvUQsrIv7s2CGM=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/object-inspect": {
            "version": "1.12.0",
            "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.12.0.tgz",
            "integrity": "sha512-Ho2z80bVIvJloH+YzRmpZVQe87+qASmBUKZDWgx9cu+KDrX2ZDH/3tMy+gXbZETVGs2M8YdxObOh7XAtim9Y0g==",
            "dev": true,
            "license": "MIT",
            "funding": {
                "url": "https://github.com/sponsors/ljharb"
            }
        },
        "node_modules/on-finished": {
            "version": "2.4.1",
            "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
            "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ee-first": "1.1.1"
            },
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/once": {
            "version": "1.4.0",
            "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
            "integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "wrappy": "1"
            }
        },
        "node_modules/opener": {
            "version": "1.5.2",
            "resolved": "https://registry.npmjs.org/opener/-/opener-1.5.2.tgz",
            "integrity": "sha512-ur5UIdyw5Y7yEj9wLzhqXiy6GZ3Mwx0yGI+5sMn2r0N0v3cKJvUmFH5yPP+WXh9e0xfyzyJX95D8l088DNFj7A==",
            "dev": true,
            "license": "(WTFPL OR MIT)",
            "bin": {
                "opener": "bin/opener-bin.js"
            }
        },
        "node_modules/p-defer": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/p-defer/-/p-defer-3.0.0.tgz",
            "integrity": "sha512-ugZxsxmtTln604yeYd29EGrNhazN2lywetzpKhfmQjW/VJmhpDmWbiX+h0zL8V91R0UXkhb3KtPmyq9PZw3aYw==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/p-fifo": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/p-fifo/-/p-fifo-1.0.0.tgz",
            "integrity": "sha512-IjoCxXW48tqdtDFz6fqo5q1UfFVjjVZe8TC1QRflvNUJtNfCUhxOUw6MOVZhDPjqhSzc26xKdugsO17gmzd5+A==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "fast-fifo": "^1.0.0",
                "p-defer": "^3.0.0"
            }
        },
        "node_modules/p-limit": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
            "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "yocto-queue": "^0.1.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/p-locate": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
            "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "p-limit": "^3.0.2"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/p-map": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/p-map/-/p-map-4.0.0.tgz",
            "integrity": "sha512-/bjOqmgETBYB5BoEeGVea8dmvHb2m9GLy1E9W43yeyfP6QQCZGFNa+XRceJEuDB6zqr+gKpIAmlLebMpykw/MQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "aggregate-error": "^3.0.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/param-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/param-case/-/param-case-3.0.4.tgz",
            "integrity": "sha512-RXlj7zCYokReqWpOPH9oYivUzLYZ5vAPIfEmCTNViosC78F8F0H9y7T7gG2M39ymgutxF5gcFEsyZQSph9Bp3A==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "dot-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/parse-duration": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/parse-duration/-/parse-duration-1.0.2.tgz",
            "integrity": "sha512-Dg27N6mfok+ow1a2rj/nRjtCfaKrHUZV2SJpEn/s8GaVUSlf4GGRCRP1c13Hj+wfPKVMrFDqLMLITkYKgKxyyg==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/parse5": {
            "version": "6.0.1",
            "resolved": "https://registry.npmjs.org/parse5/-/parse5-6.0.1.tgz",
            "integrity": "sha512-Ofn/CTFzRGTTxwpNEs9PP93gXShHcTq255nzRYSKe8AkVpZY7e1fpmTfOyoIvjP5HG7Z2ZM7VS9PPhQGW2pOpw==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/parseurl": {
            "version": "1.3.3",
            "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
            "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/pascal-case": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/pascal-case/-/pascal-case-3.1.2.tgz",
            "integrity": "sha512-uWlGT3YSnK9x3BQJaOdcZwrnV6hPpd8jFH1/ucpiLRPh/2zCVJKS19E4GvYHvaCcACn3foXZ0cLB9Wrx1KGe5g==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/path-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/path-case/-/path-case-3.0.4.tgz",
            "integrity": "sha512-qO4qCFjXqVTrcbPt/hQfhTQ+VhFsqNKOPtytgNKkKxSoEp3XPUQ8ObFuePylOIok5gjn69ry8XiULxCwot3Wfg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "dot-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/path-exists": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
            "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/path-is-absolute": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
            "integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/pathval": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/pathval/-/pathval-1.1.1.tgz",
            "integrity": "sha512-Dp6zGqpTdETdR63lehJYPeIOqpiNBNtc7BpWSLrOje7UaIsE5aY92r/AunQA7rsXvet3lrJ3JnZX29UPTKXyKQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": "*"
            }
        },
        "node_modules/picocolors": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.0.0.tgz",
            "integrity": "sha512-1fygroTLlHu66zi26VoTDv8yRgm0Fccecssto+MhsZ0D/DGW2sm8E8AjW7NU5VVTRt5GxbeZ5qBuJr+HyLYkjQ==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/picomatch": {
            "version": "2.3.1",
            "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
            "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8.6"
            },
            "funding": {
                "url": "https://github.com/sponsors/jonschlinkert"
            }
        },
        "node_modules/portfinder": {
            "version": "1.0.28",
            "resolved": "https://registry.npmjs.org/portfinder/-/portfinder-1.0.28.tgz",
            "integrity": "sha512-Se+2isanIcEqf2XMHjyUKskczxbPH7dQnlMjXX6+dybayyHvAf/TCgyMRlzf/B6QDhAEFOGes0pzRo3by4AbMA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "async": "^2.6.2",
                "debug": "^3.1.1",
                "mkdirp": "^0.5.5"
            },
            "engines": {
                "node": ">= 0.12.0"
            }
        },
        "node_modules/portfinder/node_modules/debug": {
            "version": "3.2.7",
            "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
            "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ms": "^2.1.1"
            }
        },
        "node_modules/portfinder/node_modules/mkdirp": {
            "version": "0.5.6",
            "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
            "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "minimist": "^1.2.6"
            },
            "bin": {
                "mkdirp": "bin/cmd.js"
            }
        },
        "node_modules/promise-inflight": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/promise-inflight/-/promise-inflight-1.0.1.tgz",
            "integrity": "sha1-mEcocL8igTL8vdhoEputEsPAKeM=",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/promise-retry": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/promise-retry/-/promise-retry-2.0.1.tgz",
            "integrity": "sha512-y+WKFlBR8BGXnsNlIHFGPZmyDf3DFMoLhaflAnyZgV6rG6xu+JwesTo2Q9R6XwYmtmwAFCkAk3e35jEdoeh/3g==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "err-code": "^2.0.2",
                "retry": "^0.12.0"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/promise-retry/node_modules/err-code": {
            "version": "2.0.3",
            "resolved": "https://registry.npmjs.org/err-code/-/err-code-2.0.3.tgz",
            "integrity": "sha512-2bmlRpNKBxT/CRmPOlyISQpNj+qSeYvcym/uT0Jx2bMOlKLtSy1ZmLuVxSEKKyor/N5yhvp/ZiG1oE3DEYMSFA==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/protobufjs": {
            "version": "6.11.2",
            "resolved": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.11.2.tgz",
            "integrity": "sha512-4BQJoPooKJl2G9j3XftkIXjoC9C0Av2NOrWmbLWT1vH32GcSUHjM0Arra6UfTsVyfMAuFzaLucXn1sadxJydAw==",
            "dev": true,
            "hasInstallScript": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "@protobufjs/aspromise": "^1.1.2",
                "@protobufjs/base64": "^1.1.2",
                "@protobufjs/codegen": "^2.0.4",
                "@protobufjs/eventemitter": "^1.1.0",
                "@protobufjs/fetch": "^1.1.0",
                "@protobufjs/float": "^1.0.2",
                "@protobufjs/inquire": "^1.1.0",
                "@protobufjs/path": "^1.1.2",
                "@protobufjs/pool": "^1.1.0",
                "@protobufjs/utf8": "^1.1.0",
                "@types/long": "^4.0.1",
                "@types/node": ">=13.7.0",
                "long": "^4.0.0"
            },
            "bin": {
                "pbjs": "bin/pbjs",
                "pbts": "bin/pbts"
            }
        },
        "node_modules/protobufjs/node_modules/@types/node": {
            "version": "17.0.27",
            "resolved": "https://registry.npmjs.org/@types/node/-/node-17.0.27.tgz",
            "integrity": "sha512-4/Ke7bbWOasuT3kceBZFGakP1dYN2XFd8v2l9bqF2LNWrmeU07JLpp56aEeG6+Q3olqO5TvXpW0yaiYnZJ5CXg==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/qjobs": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/qjobs/-/qjobs-1.2.0.tgz",
            "integrity": "sha512-8YOJEHtxpySA3fFDyCRxA+UUV+fA+rTWnuWvylOK/NCjhY+b4ocCtmu8TtsWb+mYeU+GCHf/S66KZF/AsteKHg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.9"
            }
        },
        "node_modules/qs": {
            "version": "6.10.3",
            "resolved": "https://registry.npmjs.org/qs/-/qs-6.10.3.tgz",
            "integrity": "sha512-wr7M2E0OFRfIfJZjKGieI8lBKb7fRCH4Fv5KNPEs7gJ8jadvotdsS08PzOKR7opXhZ/Xkjtt3WF9g38drmyRqQ==",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "side-channel": "^1.0.4"
            },
            "engines": {
                "node": ">=0.6"
            },
            "funding": {
                "url": "https://github.com/sponsors/ljharb"
            }
        },
        "node_modules/randombytes": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
            "integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "safe-buffer": "^5.1.0"
            }
        },
        "node_modules/randombytes/node_modules/safe-buffer": {
            "version": "5.2.1",
            "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
            "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
            "dev": true,
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT"
        },
        "node_modules/range-parser": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
            "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/raw-body": {
            "version": "2.5.1",
            "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.1.tgz",
            "integrity": "sha512-qqJBtEyVgS0ZmPGdCFPWJ3FreoqvG4MVQln/kCgF7Olq95IbOp0/BWyMwbdtn4VTvkM8Y7khCQ2Xgk/tcrCXig==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "bytes": "3.1.2",
                "http-errors": "2.0.0",
                "iconv-lite": "0.4.24",
                "unpipe": "1.0.0"
            },
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/react-native-fetch-api": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/react-native-fetch-api/-/react-native-fetch-api-2.0.0.tgz",
            "integrity": "sha512-GOA8tc1EVYLnHvma/TU9VTgLOyralO7eATRuCDchQveXW9Fr9vXygyq9iwqmM7YRZ8qRJfEt9xOS7OYMdJvRFw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "p-defer": "^3.0.0"
            }
        },
        "node_modules/readable-stream": {
            "version": "3.6.0",
            "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.0.tgz",
            "integrity": "sha512-BViHy7LKeTz4oNnkcLJ+lVSL6vpiFeX6/d3oSH8zCW7UxP2onchk+vTGB143xuFjHS3deTgkKoXXymXqymiIdA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "inherits": "^2.0.3",
                "string_decoder": "^1.1.1",
                "util-deprecate": "^1.0.1"
            },
            "engines": {
                "node": ">= 6"
            }
        },
        "node_modules/readdirp": {
            "version": "3.6.0",
            "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
            "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "picomatch": "^2.2.1"
            },
            "engines": {
                "node": ">=8.10.0"
            }
        },
        "node_modules/receptacle": {
            "version": "1.3.2",
            "resolved": "https://registry.npmjs.org/receptacle/-/receptacle-1.3.2.tgz",
            "integrity": "sha512-HrsFvqZZheusncQRiEE7GatOAETrARKV/lnfYicIm8lbvp/JQOdADOfhjBd2DajvoszEyxSM6RlAAIZgEoeu/A==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ms": "^2.1.1"
            }
        },
        "node_modules/relateurl": {
            "version": "0.2.7",
            "resolved": "https://registry.npmjs.org/relateurl/-/relateurl-0.2.7.tgz",
            "integrity": "sha1-VNvzd+UUQKypCkzSdGANP/LYiKk=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.10"
            }
        },
        "node_modules/require-directory": {
            "version": "2.1.1",
            "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
            "integrity": "sha1-jGStX9MNqxyXbiNE/+f3kqam30I=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/requires-port": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/requires-port/-/requires-port-1.0.0.tgz",
            "integrity": "sha1-kl0mAdOaxIXgkc8NpcbmlNw9yv8=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/retimer": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/retimer/-/retimer-3.0.0.tgz",
            "integrity": "sha512-WKE0j11Pa0ZJI5YIk0nflGI7SQsfl2ljihVy7ogh7DeQSeYAUi0ubZ/yEueGtDfUPk6GH5LRw1hBdLq4IwUBWA==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/retry": {
            "version": "0.12.0",
            "resolved": "https://registry.npmjs.org/retry/-/retry-0.12.0.tgz",
            "integrity": "sha1-G0KmJmoh8HQh0bC1S33BZ7AcATs=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 4"
            }
        },
        "node_modules/rfdc": {
            "version": "1.3.0",
            "resolved": "https://registry.npmjs.org/rfdc/-/rfdc-1.3.0.tgz",
            "integrity": "sha512-V2hovdzFbOi77/WajaSMXk2OLm+xNIeQdMMuB7icj7bk6zi2F8GGAxigcnDFpJHbNyNcgyJDiP+8nOrY5cZGrA==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/rimraf": {
            "version": "3.0.2",
            "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
            "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "glob": "^7.1.3"
            },
            "bin": {
                "rimraf": "bin.js"
            },
            "funding": {
                "url": "https://github.com/sponsors/isaacs"
            }
        },
        "node_modules/rollup": {
            "version": "2.70.2",
            "resolved": "https://registry.npmjs.org/rollup/-/rollup-2.70.2.tgz",
            "integrity": "sha512-EitogNZnfku65I1DD5Mxe8JYRUCy0hkK5X84IlDtUs+O6JRMpRciXTzyCUuX11b5L5pvjH+OmFXiQ3XjabcXgg==",
            "dev": true,
            "license": "MIT",
            "bin": {
                "rollup": "dist/bin/rollup"
            },
            "engines": {
                "node": ">=10.0.0"
            },
            "optionalDependencies": {
                "fsevents": "~2.3.2"
            }
        },
        "node_modules/rollup-plugin-terser": {
            "version": "7.0.2",
            "resolved": "https://registry.npmjs.org/rollup-plugin-terser/-/rollup-plugin-terser-7.0.2.tgz",
            "integrity": "sha512-w3iIaU4OxcF52UUXiZNsNeuXIMDvFrr+ZXK6bFZ0Q60qyVfq4uLptoS4bbq3paG3x216eQllFZX7zt6TIImguQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@babel/code-frame": "^7.10.4",
                "jest-worker": "^26.2.1",
                "serialize-javascript": "^4.0.0",
                "terser": "^5.0.0"
            },
            "peerDependencies": {
                "rollup": "^2.0.0"
            }
        },
        "node_modules/rollup-plugin-terser/node_modules/serialize-javascript": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-4.0.0.tgz",
            "integrity": "sha512-GaNA54380uFefWghODBWEGisLZFj00nS5ACs6yHa9nLqlLpVLO8ChDGeKRjZnV4Nh4n0Qi7nhYZD/9fCPzEqkw==",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "randombytes": "^2.1.0"
            }
        },
        "node_modules/safe-buffer": {
            "version": "5.1.2",
            "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
            "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/safer-buffer": {
            "version": "2.1.2",
            "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
            "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/secure-compare": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/secure-compare/-/secure-compare-3.0.1.tgz",
            "integrity": "sha1-8aAymzCLIh+uN7mXTz1XjQypmeM=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/semver": {
            "version": "6.3.0",
            "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
            "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
            "dev": true,
            "license": "ISC",
            "bin": {
                "semver": "bin/semver.js"
            }
        },
        "node_modules/sentence-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/sentence-case/-/sentence-case-3.0.4.tgz",
            "integrity": "sha512-8LS0JInaQMCRoQ7YUytAo/xUu5W2XnQxV2HI/6uM6U7CITS1RqPElr30V6uIqyMKM9lJGRVFy5/4CuzcixNYSg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3",
                "upper-case-first": "^2.0.2"
            }
        },
        "node_modules/serialize-javascript": {
            "version": "6.0.0",
            "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.0.tgz",
            "integrity": "sha512-Qr3TosvguFt8ePWqsvRfrKyQXIiW+nGbYpy8XK24NQHE83caxWt+mIymTT19DGFbNWNLfEwsrkSmN64lVWB9ag==",
            "dev": true,
            "license": "BSD-3-Clause",
            "dependencies": {
                "randombytes": "^2.1.0"
            }
        },
        "node_modules/setprototypeof": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
            "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/side-channel": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.0.4.tgz",
            "integrity": "sha512-q5XPytqFEIKHkGdiMIrY10mvLRvnQh42/+GoBlFW3b2LXLE2xxJpZFdm94we0BaoV3RwJyGqg5wS7epxTv0Zvw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "call-bind": "^1.0.0",
                "get-intrinsic": "^1.0.2",
                "object-inspect": "^1.9.0"
            },
            "funding": {
                "url": "https://github.com/sponsors/ljharb"
            }
        },
        "node_modules/smart-buffer": {
            "version": "4.2.0",
            "resolved": "https://registry.npmjs.org/smart-buffer/-/smart-buffer-4.2.0.tgz",
            "integrity": "sha512-94hK0Hh8rPqQl2xXc3HsaBoOXKV20MToPkcXvwbISWLEs+64sBq5kFgn2kJDHb1Pry9yrP0dxrCI9RRci7RXKg==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 6.0.0",
                "npm": ">= 3.0.0"
            }
        },
        "node_modules/snake-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/snake-case/-/snake-case-3.0.4.tgz",
            "integrity": "sha512-LAOh4z89bGQvl9pFfNF8V146i7o7/CqFPbqzYgP+yYzDIDeS9HaNFtXABamRW+AQzEVODcvE79ljJ+8a9YSdMg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "dot-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "node_modules/socket.io": {
            "version": "4.5.0",
            "resolved": "https://registry.npmjs.org/socket.io/-/socket.io-4.5.0.tgz",
            "integrity": "sha512-slTYqU2jCgMjXwresG8grhUi/cC6GjzmcfqArzaH3BN/9I/42eZk9yamNvZJdBfTubkjEdKAKs12NEztId+bUA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "accepts": "~1.3.4",
                "base64id": "~2.0.0",
                "debug": "~4.3.2",
                "engine.io": "~6.2.0",
                "socket.io-adapter": "~2.4.0",
                "socket.io-parser": "~4.0.4"
            },
            "engines": {
                "node": ">=10.0.0"
            }
        },
        "node_modules/socket.io-adapter": {
            "version": "2.4.0",
            "resolved": "https://registry.npmjs.org/socket.io-adapter/-/socket.io-adapter-2.4.0.tgz",
            "integrity": "sha512-W4N+o69rkMEGVuk2D/cvca3uYsvGlMwsySWV447y99gUPghxq42BxqLNMndb+a1mm/5/7NeXVQS7RLa2XyXvYg==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/socket.io-parser": {
            "version": "4.0.4",
            "resolved": "https://registry.npmjs.org/socket.io-parser/-/socket.io-parser-4.0.4.tgz",
            "integrity": "sha512-t+b0SS+IxG7Rxzda2EVvyBZbvFPBCjJoyHuE0P//7OAsN23GItzDRdWa6ALxZI/8R5ygK7jAR6t028/z+7295g==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "@types/component-emitter": "^1.2.10",
                "component-emitter": "~1.3.0",
                "debug": "~4.3.1"
            },
            "engines": {
                "node": ">=10.0.0"
            }
        },
        "node_modules/socks": {
            "version": "2.6.2",
            "resolved": "https://registry.npmjs.org/socks/-/socks-2.6.2.tgz",
            "integrity": "sha512-zDZhHhZRY9PxRruRMR7kMhnf3I8hDs4S3f9RecfnGxvcBHQcKcIH/oUcEWffsfl1XxdYlA7nnlGbbTvPz9D8gA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ip": "^1.1.5",
                "smart-buffer": "^4.2.0"
            },
            "engines": {
                "node": ">= 10.13.0",
                "npm": ">= 3.0.0"
            }
        },
        "node_modules/socks-proxy-agent": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/socks-proxy-agent/-/socks-proxy-agent-5.0.1.tgz",
            "integrity": "sha512-vZdmnjb9a2Tz6WEQVIurybSwElwPxMZaIc7PzqbJTrezcKNznv6giT7J7tZDZ1BojVaa1jvO/UiUdhDVB0ACoQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "agent-base": "^6.0.2",
                "debug": "4",
                "socks": "^2.3.3"
            },
            "engines": {
                "node": ">= 6"
            }
        },
        "node_modules/source-map": {
            "version": "0.6.1",
            "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
            "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
            "dev": true,
            "license": "BSD-3-Clause",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/source-map-support": {
            "version": "0.5.21",
            "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.21.tgz",
            "integrity": "sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "buffer-from": "^1.0.0",
                "source-map": "^0.6.0"
            }
        },
        "node_modules/sourcemap-codec": {
            "version": "1.4.8",
            "resolved": "https://registry.npmjs.org/sourcemap-codec/-/sourcemap-codec-1.4.8.tgz",
            "integrity": "sha512-9NykojV5Uih4lgo5So5dtw+f0JgJX30KCNI8gwhz2J9A15wD0Ml6tjHKwf6fTSa6fAdVBdZeNOs9eJ71qCk8vA==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/ssri": {
            "version": "8.0.1",
            "resolved": "https://registry.npmjs.org/ssri/-/ssri-8.0.1.tgz",
            "integrity": "sha512-97qShzy1AiyxvPNIkLWoGua7xoQzzPjQ0HAH4B0rWKo7SZ6USuPcrUiAFrws0UH8RrbWmgq3LMTObhPIHbbBeQ==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "minipass": "^3.1.1"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/statuses": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
            "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/stream-to-it": {
            "version": "0.2.4",
            "resolved": "https://registry.npmjs.org/stream-to-it/-/stream-to-it-0.2.4.tgz",
            "integrity": "sha512-4vEbkSs83OahpmBybNJXlJd7d6/RxzkkSdT3I0mnGt79Xd2Kk+e1JqbvAvsQfCeKj3aKb0QIWkyK3/n0j506vQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "get-iterator": "^1.0.2"
            }
        },
        "node_modules/streamroller": {
            "version": "3.0.8",
            "resolved": "https://registry.npmjs.org/streamroller/-/streamroller-3.0.8.tgz",
            "integrity": "sha512-VI+ni3czbFZrd1MrlybxykWZ8sMDCMtTU7YJyhgb9M5X6d1DDxLdJr+gSnmRpXPMnIWxWKMaAE8K0WumBp3lDg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "date-format": "^4.0.9",
                "debug": "^4.3.4",
                "fs-extra": "^10.1.0"
            },
            "engines": {
                "node": ">=8.0"
            }
        },
        "node_modules/string_decoder": {
            "version": "1.3.0",
            "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
            "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "safe-buffer": "~5.2.0"
            }
        },
        "node_modules/string_decoder/node_modules/safe-buffer": {
            "version": "5.2.1",
            "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
            "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
            "dev": true,
            "funding": [
                {
                    "type": "github",
                    "url": "https://github.com/sponsors/feross"
                },
                {
                    "type": "patreon",
                    "url": "https://www.patreon.com/feross"
                },
                {
                    "type": "consulting",
                    "url": "https://feross.org/support"
                }
            ],
            "license": "MIT"
        },
        "node_modules/string-width": {
            "version": "4.2.3",
            "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
            "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "emoji-regex": "^8.0.0",
                "is-fullwidth-code-point": "^3.0.0",
                "strip-ansi": "^6.0.1"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/strip-ansi": {
            "version": "6.0.1",
            "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
            "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ansi-regex": "^5.0.1"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/strip-json-comments": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
            "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        },
        "node_modules/style-mod": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/style-mod/-/style-mod-4.0.0.tgz",
            "integrity": "sha512-OPhtyEjyyN9x3nhPsu76f52yUGXiZcgvsrFVtvTkyGRQJ0XK+GPc6ov1z+lRpbeabka+MYEQxOYRnt5nF30aMw=="
        },
        "node_modules/supports-color": {
            "version": "7.2.0",
            "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
            "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "has-flag": "^4.0.0"
            },
            "engines": {
                "node": ">=8"
            }
        },
        "node_modules/sver": {
            "version": "1.8.3",
            "resolved": "https://registry.npmjs.org/sver/-/sver-1.8.3.tgz",
            "integrity": "sha512-Qn39MggkkPw3d1BACWNV+Njwt9L0znk8oNW8NlJv4lWTEseMzbjHzunnPJDnt/5mfLHV5kt5JkMTqPbMVrg2CA==",
            "dev": true,
            "license": "MIT",
            "optionalDependencies": {
                "semver": "^6.3.0"
            }
        },
        "node_modules/tar": {
            "version": "6.1.11",
            "resolved": "https://registry.npmjs.org/tar/-/tar-6.1.11.tgz",
            "integrity": "sha512-an/KZQzQUkZCkuoAA64hM92X0Urb6VpRhAFllDzz44U2mcD5scmT3zBc4VgVpkugF580+DQn8eAFSyoQt0tznA==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "chownr": "^2.0.0",
                "fs-minipass": "^2.0.0",
                "minipass": "^3.0.0",
                "minizlib": "^2.1.1",
                "mkdirp": "^1.0.3",
                "yallist": "^4.0.0"
            },
            "engines": {
                "node": ">= 10"
            }
        },
        "node_modules/terser": {
            "version": "5.12.1",
            "resolved": "https://registry.npmjs.org/terser/-/terser-5.12.1.tgz",
            "integrity": "sha512-NXbs+7nisos5E+yXwAD+y7zrcTkMqb0dEJxIGtSKPdCBzopf7ni4odPul2aechpV7EXNvOudYOX2bb5tln1jbQ==",
            "dev": true,
            "license": "BSD-2-Clause",
            "dependencies": {
                "acorn": "^8.5.0",
                "commander": "^2.20.0",
                "source-map": "~0.7.2",
                "source-map-support": "~0.5.20"
            },
            "bin": {
                "terser": "bin/terser"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/terser/node_modules/source-map": {
            "version": "0.7.3",
            "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.7.3.tgz",
            "integrity": "sha512-CkCj6giN3S+n9qrYiBTX5gystlENnRW5jZeNLHpe6aue+SrHcG5VYwujhW9s4dY31mEGsxBDrHR6oI69fTXsaQ==",
            "dev": true,
            "license": "BSD-3-Clause",
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/timeout-abort-controller": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/timeout-abort-controller/-/timeout-abort-controller-3.0.0.tgz",
            "integrity": "sha512-O3e+2B8BKrQxU2YRyEjC/2yFdb33slI22WRdUaDx6rvysfi9anloNZyR2q0l6LnePo5qH7gSM7uZtvvwZbc2yA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "retimer": "^3.0.0"
            }
        },
        "node_modules/tmp": {
            "version": "0.2.1",
            "resolved": "https://registry.npmjs.org/tmp/-/tmp-0.2.1.tgz",
            "integrity": "sha512-76SUhtfqR2Ijn+xllcI5P1oyannHNHByD80W1q447gU3mp9G9PSpGdWmjUOHRDPiHYacIk66W7ubDTuPF3BEtQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "rimraf": "^3.0.0"
            },
            "engines": {
                "node": ">=8.17.0"
            }
        },
        "node_modules/to-fast-properties": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/to-fast-properties/-/to-fast-properties-2.0.0.tgz",
            "integrity": "sha1-3F5pjL0HkmW8c+A3doGk5Og/YW4=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/to-regex-range": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
            "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "is-number": "^7.0.0"
            },
            "engines": {
                "node": ">=8.0"
            }
        },
        "node_modules/toidentifier": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
            "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.6"
            }
        },
        "node_modules/tslib": {
            "version": "2.4.0",
            "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.4.0.tgz",
            "integrity": "sha512-d6xOpEDfsi2CZVlPQzGeux8XMwLT9hssAsaPYExaQMuYskwb+x1x7J371tWlbBdWHroy99KnVB6qIkUbs5X3UQ==",
            "license": "0BSD"
        },
        "node_modules/type-detect": {
            "version": "4.0.8",
            "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-4.0.8.tgz",
            "integrity": "sha512-0fr/mIH1dlO+x7TlcMy+bIDqKPsw/70tVyeHW787goQjhmqaZe10uwLujubK9q9Lg6Fiho1KUKDYz0Z7k7g5/g==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=4"
            }
        },
        "node_modules/type-is": {
            "version": "1.6.18",
            "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
            "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "media-typer": "0.3.0",
                "mime-types": "~2.1.24"
            },
            "engines": {
                "node": ">= 0.6"
            }
        },
        "node_modules/typescript": {
            "version": "4.6.3",
            "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.6.3.tgz",
            "integrity": "sha512-yNIatDa5iaofVozS/uQJEl3JRWLKKGJKh6Yaiv0GLGSuhpFJe7P3SbHZ8/yjAHRQwKRoA6YZqlfjXWmVzoVSMw==",
            "dev": true,
            "license": "Apache-2.0",
            "bin": {
                "tsc": "bin/tsc",
                "tsserver": "bin/tsserver"
            },
            "engines": {
                "node": ">=4.2.0"
            }
        },
        "node_modules/ua-parser-js": {
            "version": "0.7.31",
            "resolved": "https://registry.npmjs.org/ua-parser-js/-/ua-parser-js-0.7.31.tgz",
            "integrity": "sha512-qLK/Xe9E2uzmYI3qLeOmI0tEOt+TBBQyUIAh4aAgU05FVYzeZrKUdkAZfBNVGRaHVgV0TDkdEngJSw/SyQchkQ==",
            "dev": true,
            "funding": [
                {
                    "type": "opencollective",
                    "url": "https://opencollective.com/ua-parser-js"
                },
                {
                    "type": "paypal",
                    "url": "https://paypal.me/faisalman"
                }
            ],
            "license": "MIT",
            "engines": {
                "node": "*"
            }
        },
        "node_modules/uint8arrays": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/uint8arrays/-/uint8arrays-3.0.0.tgz",
            "integrity": "sha512-HRCx0q6O9Bfbp+HHSfQQKD7wU70+lydKVt4EghkdOvlK/NlrF90z+eXV34mUd48rNvVJXwkrMSPpCATkct8fJA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "multiformats": "^9.4.2"
            }
        },
        "node_modules/union": {
            "version": "0.5.0",
            "resolved": "https://registry.npmjs.org/union/-/union-0.5.0.tgz",
            "integrity": "sha512-N6uOhuW6zO95P3Mel2I2zMsbsanvvtgn6jVqJv4vbVcz/JN0OkL9suomjQGmWtxJQXOCqUJvquc1sMeNz/IwlA==",
            "dev": true,
            "dependencies": {
                "qs": "^6.4.0"
            },
            "engines": {
                "node": ">= 0.8.0"
            }
        },
        "node_modules/unique-filename": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/unique-filename/-/unique-filename-1.1.1.tgz",
            "integrity": "sha512-Vmp0jIp2ln35UTXuryvjzkjGdRyf9b2lTXuSYUiPmzRcl3FDtYqAwOnTJkAngD9SWhnoJzDbTKwaOrZ+STtxNQ==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "unique-slug": "^2.0.0"
            }
        },
        "node_modules/unique-slug": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/unique-slug/-/unique-slug-2.0.2.tgz",
            "integrity": "sha512-zoWr9ObaxALD3DOPfjPSqxt4fnZiWblxHIgeWqW8x7UqDzEtHEQLzji2cuJYQFCU6KmoJikOYAZlrTHHebjx2w==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "imurmurhash": "^0.1.4"
            }
        },
        "node_modules/universalify": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/universalify/-/universalify-2.0.0.tgz",
            "integrity": "sha512-hAZsKq7Yy11Zu1DE0OzWjw7nnLZmJZYTDZZyEFHZdUhV8FkH5MCfoU1XMaxXovpyW5nq5scPqq0ZDP9Zyl04oQ==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 10.0.0"
            }
        },
        "node_modules/unpipe": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
            "integrity": "sha1-sr9O6FFKrmFltIF4KdIbLvSZBOw=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/upper-case": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/upper-case/-/upper-case-2.0.2.tgz",
            "integrity": "sha512-KgdgDGJt2TpuwBUIjgG6lzw2GWFRCW9Qkfkiv0DxqHHLYJHmtmdUIKcZd8rHgFSjopVTlw6ggzCm1b8MFQwikg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "tslib": "^2.0.3"
            }
        },
        "node_modules/upper-case-first": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/upper-case-first/-/upper-case-first-2.0.2.tgz",
            "integrity": "sha512-514ppYHBaKwfJRK/pNC6c/OxfGa0obSnAl106u97Ed0I625Nin96KAjttZF6ZL3e1XLtphxnqrOi9iWgm+u+bg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "tslib": "^2.0.3"
            }
        },
        "node_modules/url-join": {
            "version": "4.0.1",
            "resolved": "https://registry.npmjs.org/url-join/-/url-join-4.0.1.tgz",
            "integrity": "sha512-jk1+QP6ZJqyOiuEI9AEWQfju/nB2Pw466kbA0LEZljHwKeMgd9WrAEgEGxjPDD2+TNbbb37rTyhEfrCXfuKXnA==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/util-deprecate": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
            "integrity": "sha1-RQ1Nyfpw3nMnYvvS1KKJgUGaDM8=",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/utils-merge": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
            "integrity": "sha1-n5VxD1CiZ5R7LMwSR0HBAoQn5xM=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.4.0"
            }
        },
        "node_modules/varint": {
            "version": "6.0.0",
            "resolved": "https://registry.npmjs.org/varint/-/varint-6.0.0.tgz",
            "integrity": "sha512-cXEIW6cfr15lFv563k4GuVuW/fiwjknytD37jIOLSdSWuOI6WnO/oKwmP2FQTU2l01LP8/M5TSAJpzUaGe3uWg==",
            "dev": true,
            "license": "MIT"
        },
        "node_modules/vary": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
            "integrity": "sha1-IpnwLG3tMNSllhsLn3RSShj2NPw=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">= 0.8"
            }
        },
        "node_modules/void-elements": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/void-elements/-/void-elements-2.0.1.tgz",
            "integrity": "sha1-wGavtYK7HLQSjWDqkjkulNXp2+w=",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/w3c-keyname": {
            "version": "2.2.4",
            "resolved": "https://registry.npmjs.org/w3c-keyname/-/w3c-keyname-2.2.4.tgz",
            "integrity": "sha512-tOhfEwEzFLJzf6d1ZPkYfGj+FWhIpBux9ppoP3rlclw3Z0BZv3N7b7030Z1kYth+6rDuAsXUFr+d0VE6Ed1ikw=="
        },
        "node_modules/whatwg-encoding": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/whatwg-encoding/-/whatwg-encoding-2.0.0.tgz",
            "integrity": "sha512-p41ogyeMUrw3jWclHWTQg1k05DSVXPLcVxRTYsXUk+ZooOCZLcoYgPZ/HL/D/N+uQPOtcp1me1WhBEaX02mhWg==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "iconv-lite": "0.6.3"
            },
            "engines": {
                "node": ">=12"
            }
        },
        "node_modules/whatwg-encoding/node_modules/iconv-lite": {
            "version": "0.6.3",
            "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
            "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "safer-buffer": ">= 2.1.2 < 3.0.0"
            },
            "engines": {
                "node": ">=0.10.0"
            }
        },
        "node_modules/wherearewe": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/wherearewe/-/wherearewe-1.0.2.tgz",
            "integrity": "sha512-HyLZ7n1Yox+w1qWaFEgP/sMs5D7ka2UXmoVNaY0XzbEHLGljo4ScBchYm6cWRYNO33tmFX3Mgg4BiZkDOjihyw==",
            "dev": true,
            "license": "Apache-2.0 OR MIT",
            "dependencies": {
                "is-electron": "^2.2.0"
            },
            "engines": {
                "node": ">=16.0.0",
                "npm": ">=7.0.0"
            }
        },
        "node_modules/which": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
            "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
            "dev": true,
            "license": "ISC",
            "dependencies": {
                "isexe": "^2.0.0"
            },
            "bin": {
                "node-which": "bin/node-which"
            },
            "engines": {
                "node": ">= 8"
            }
        },
        "node_modules/wicg-inert": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/wicg-inert/-/wicg-inert-3.1.1.tgz",
            "integrity": "sha512-PhBaNh8ur9Xm4Ggy4umelwNIP6pPP1bv3EaWaKqfb/QNme2rdLjm7wIInvV4WhxVHhzA4Spgw9qNSqWtB/ca2A=="
        },
        "node_modules/workerpool": {
            "version": "6.2.0",
            "resolved": "https://registry.npmjs.org/workerpool/-/workerpool-6.2.0.tgz",
            "integrity": "sha512-Rsk5qQHJ9eowMH28Jwhe8HEbmdYDX4lwoMWshiCXugjtHqMD9ZbiqSDLxcsfdqsETPzVUtX5s1Z5kStiIM6l4A==",
            "dev": true,
            "license": "Apache-2.0"
        },
        "node_modules/wrap-ansi": {
            "version": "7.0.0",
            "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
            "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "ansi-styles": "^4.0.0",
                "string-width": "^4.1.0",
                "strip-ansi": "^6.0.0"
            },
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/chalk/wrap-ansi?sponsor=1"
            }
        },
        "node_modules/wrappy": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
            "integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/ws": {
            "version": "7.5.7",
            "resolved": "https://registry.npmjs.org/ws/-/ws-7.5.7.tgz",
            "integrity": "sha512-KMvVuFzpKBuiIXW3E4u3mySRO2/mCHSyZDJQM5NQ9Q9KHWHWh0NHgfbRMLLrceUK5qAL4ytALJbpRMjixFZh8A==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=8.3.0"
            },
            "peerDependencies": {
                "bufferutil": "^4.0.1",
                "utf-8-validate": "^5.0.2"
            },
            "peerDependenciesMeta": {
                "bufferutil": {
                    "optional": true
                },
                "utf-8-validate": {
                    "optional": true
                }
            }
        },
        "node_modules/y18n": {
            "version": "5.0.8",
            "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
            "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
            "dev": true,
            "license": "ISC",
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/yallist": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
            "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
            "dev": true,
            "license": "ISC"
        },
        "node_modules/yargs": {
            "version": "16.2.0",
            "resolved": "https://registry.npmjs.org/yargs/-/yargs-16.2.0.tgz",
            "integrity": "sha512-D1mvvtDG0L5ft/jGWkLpG1+m0eQxOfaBvTNELraWj22wSVUMWxZUvYgJYcKh6jGGIkJFhH4IZPQhR4TKpc8mBw==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "cliui": "^7.0.2",
                "escalade": "^3.1.1",
                "get-caller-file": "^2.0.5",
                "require-directory": "^2.1.1",
                "string-width": "^4.2.0",
                "y18n": "^5.0.5",
                "yargs-parser": "^20.2.2"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/yargs-parser": {
            "version": "20.2.4",
            "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-20.2.4.tgz",
            "integrity": "sha512-WOkpgNhPTlE73h4VFAFsOnomJVaovO8VqLDzy5saChRBFQFBoMYirowyW+Q9HB4HFF4Z7VZTiG3iSzJJA29yRA==",
            "dev": true,
            "license": "ISC",
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/yargs-unparser": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-2.0.0.tgz",
            "integrity": "sha512-7pRTIA9Qc1caZ0bZ6RYRGbHJthJWuakf+WmHK0rVeLkNrrGhfoabBNdue6kdINI6r4if7ocq9aD/n7xwKOdzOA==",
            "dev": true,
            "license": "MIT",
            "dependencies": {
                "camelcase": "^6.0.0",
                "decamelize": "^4.0.0",
                "flat": "^5.0.2",
                "is-plain-obj": "^2.1.0"
            },
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/yargs/node_modules/yargs-parser": {
            "version": "20.2.9",
            "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-20.2.9.tgz",
            "integrity": "sha512-y11nGElTIV+CT3Zv9t7VKl+Q3hTQoT9a1Qzezhhl6Rp21gJ/IVTW7Z3y9EWXhuUBC2Shnf+DX0antecpAwSP8w==",
            "dev": true,
            "license": "ISC",
            "engines": {
                "node": ">=10"
            }
        },
        "node_modules/yocto-queue": {
            "version": "0.1.0",
            "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
            "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
            "dev": true,
            "license": "MIT",
            "engines": {
                "node": ">=10"
            },
            "funding": {
                "url": "https://github.com/sponsors/sindresorhus"
            }
        }
    },
    "dependencies": {
        "@ampproject/remapping": {
            "version": "2.1.2",
            "resolved": "https://registry.npmjs.org/@ampproject/remapping/-/remapping-2.1.2.tgz",
            "integrity": "sha512-hoyByceqwKirw7w3Z7gnIIZC3Wx3J484Y3L/cMpXFbr7d9ZQj2mODrirNzcJa+SM3UlpWXYvKV4RlRpFXlWgXg==",
            "dev": true,
            "requires": {
                "@jridgewell/trace-mapping": "^0.3.0"
            }
        },
        "@babel/code-frame": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/code-frame/-/code-frame-7.16.7.tgz",
            "integrity": "sha512-iAXqUn8IIeBTNd72xsFlgaXHkMBMt6y4HJp1tIaK465CWLT/fG1aqB7ykr95gHHmlBdGbFeWWfyB4NJJ0nmeIg==",
            "dev": true,
            "requires": {
                "@babel/highlight": "^7.16.7"
            }
        },
        "@babel/compat-data": {
            "version": "7.17.7",
            "resolved": "https://registry.npmjs.org/@babel/compat-data/-/compat-data-7.17.7.tgz",
            "integrity": "sha512-p8pdE6j0a29TNGebNm7NzYZWB3xVZJBZ7XGs42uAKzQo8VQ3F0By/cQCtUEABwIqw5zo6WA4NbmxsfzADzMKnQ==",
            "dev": true
        },
        "@babel/core": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/core/-/core-7.17.9.tgz",
            "integrity": "sha512-5ug+SfZCpDAkVp9SFIZAzlW18rlzsOcJGaetCjkySnrXXDUw9AR8cDUm1iByTmdWM6yxX6/zycaV76w3YTF2gw==",
            "dev": true,
            "requires": {
                "@ampproject/remapping": "^2.1.0",
                "@babel/code-frame": "^7.16.7",
                "@babel/generator": "^7.17.9",
                "@babel/helper-compilation-targets": "^7.17.7",
                "@babel/helper-module-transforms": "^7.17.7",
                "@babel/helpers": "^7.17.9",
                "@babel/parser": "^7.17.9",
                "@babel/template": "^7.16.7",
                "@babel/traverse": "^7.17.9",
                "@babel/types": "^7.17.0",
                "convert-source-map": "^1.7.0",
                "debug": "^4.1.0",
                "gensync": "^1.0.0-beta.2",
                "json5": "^2.2.1",
                "semver": "^6.3.0"
            }
        },
        "@babel/generator": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/generator/-/generator-7.17.9.tgz",
            "integrity": "sha512-rAdDousTwxbIxbz5I7GEQ3lUip+xVCXooZNbsydCWs3xA7ZsYOv+CFRdzGxRX78BmQHu9B1Eso59AOZQOJDEdQ==",
            "dev": true,
            "requires": {
                "@babel/types": "^7.17.0",
                "jsesc": "^2.5.1",
                "source-map": "^0.5.0"
            },
            "dependencies": {
                "source-map": {
                    "version": "0.5.7",
                    "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.5.7.tgz",
                    "integrity": "sha1-igOdLRAh0i0eoUyA2OpGi6LvP8w=",
                    "dev": true
                }
            }
        },
        "@babel/helper-annotate-as-pure": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-annotate-as-pure/-/helper-annotate-as-pure-7.16.7.tgz",
            "integrity": "sha512-s6t2w/IPQVTAET1HitoowRGXooX8mCgtuP5195wD/QJPV6wYjpujCGF7JuMODVX2ZAJOf1GT6DT9MHEZvLOFSw==",
            "dev": true,
            "requires": {
                "@babel/types": "^7.16.7"
            }
        },
        "@babel/helper-compilation-targets": {
            "version": "7.17.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-compilation-targets/-/helper-compilation-targets-7.17.7.tgz",
            "integrity": "sha512-UFzlz2jjd8kroj0hmCFV5zr+tQPi1dpC2cRsDV/3IEW8bJfCPrPpmcSN6ZS8RqIq4LXcmpipCQFPddyFA5Yc7w==",
            "dev": true,
            "requires": {
                "@babel/compat-data": "^7.17.7",
                "@babel/helper-validator-option": "^7.16.7",
                "browserslist": "^4.17.5",
                "semver": "^6.3.0"
            }
        },
        "@babel/helper-create-class-features-plugin": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/helper-create-class-features-plugin/-/helper-create-class-features-plugin-7.17.9.tgz",
            "integrity": "sha512-kUjip3gruz6AJKOq5i3nC6CoCEEF/oHH3cp6tOZhB+IyyyPyW0g1Gfsxn3mkk6S08pIA2y8GQh609v9G/5sHVQ==",
            "dev": true,
            "requires": {
                "@babel/helper-annotate-as-pure": "^7.16.7",
                "@babel/helper-environment-visitor": "^7.16.7",
                "@babel/helper-function-name": "^7.17.9",
                "@babel/helper-member-expression-to-functions": "^7.17.7",
                "@babel/helper-optimise-call-expression": "^7.16.7",
                "@babel/helper-replace-supers": "^7.16.7",
                "@babel/helper-split-export-declaration": "^7.16.7"
            }
        },
        "@babel/helper-environment-visitor": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-environment-visitor/-/helper-environment-visitor-7.16.7.tgz",
            "integrity": "sha512-SLLb0AAn6PkUeAfKJCCOl9e1R53pQlGAfc4y4XuMRZfqeMYLE0dM1LMhqbGAlGQY0lfw5/ohoYWAe9V1yibRag==",
            "dev": true,
            "requires": {
                "@babel/types": "^7.16.7"
            }
        },
        "@babel/helper-function-name": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/helper-function-name/-/helper-function-name-7.17.9.tgz",
            "integrity": "sha512-7cRisGlVtiVqZ0MW0/yFB4atgpGLWEHUVYnb448hZK4x+vih0YO5UoS11XIYtZYqHd0dIPMdUSv8q5K4LdMnIg==",
            "dev": true,
            "requires": {
                "@babel/template": "^7.16.7",
                "@babel/types": "^7.17.0"
            }
        },
        "@babel/helper-hoist-variables": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-hoist-variables/-/helper-hoist-variables-7.16.7.tgz",
            "integrity": "sha512-m04d/0Op34H5v7pbZw6pSKP7weA6lsMvfiIAMeIvkY/R4xQtBSMFEigu9QTZ2qB/9l22vsxtM8a+Q8CzD255fg==",
            "dev": true,
            "requires": {
                "@babel/types": "^7.16.7"
            }
        },
        "@babel/helper-member-expression-to-functions": {
            "version": "7.17.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-member-expression-to-functions/-/helper-member-expression-to-functions-7.17.7.tgz",
            "integrity": "sha512-thxXgnQ8qQ11W2wVUObIqDL4p148VMxkt5T/qpN5k2fboRyzFGFmKsTGViquyM5QHKUy48OZoca8kw4ajaDPyw==",
            "dev": true,
            "requires": {
                "@babel/types": "^7.17.0"
            }
        },
        "@babel/helper-module-imports": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-module-imports/-/helper-module-imports-7.16.7.tgz",
            "integrity": "sha512-LVtS6TqjJHFc+nYeITRo6VLXve70xmq7wPhWTqDJusJEgGmkAACWwMiTNrvfoQo6hEhFwAIixNkvB0jPXDL8Wg==",
            "dev": true,
            "requires": {
                "@babel/types": "^7.16.7"
            }
        },
        "@babel/helper-module-transforms": {
            "version": "7.17.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-module-transforms/-/helper-module-transforms-7.17.7.tgz",
            "integrity": "sha512-VmZD99F3gNTYB7fJRDTi+u6l/zxY0BE6OIxPSU7a50s6ZUQkHwSDmV92FfM+oCG0pZRVojGYhkR8I0OGeCVREw==",
            "dev": true,
            "requires": {
                "@babel/helper-environment-visitor": "^7.16.7",
                "@babel/helper-module-imports": "^7.16.7",
                "@babel/helper-simple-access": "^7.17.7",
                "@babel/helper-split-export-declaration": "^7.16.7",
                "@babel/helper-validator-identifier": "^7.16.7",
                "@babel/template": "^7.16.7",
                "@babel/traverse": "^7.17.3",
                "@babel/types": "^7.17.0"
            }
        },
        "@babel/helper-optimise-call-expression": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-optimise-call-expression/-/helper-optimise-call-expression-7.16.7.tgz",
            "integrity": "sha512-EtgBhg7rd/JcnpZFXpBy0ze1YRfdm7BnBX4uKMBd3ixa3RGAE002JZB66FJyNH7g0F38U05pXmA5P8cBh7z+1w==",
            "dev": true,
            "requires": {
                "@babel/types": "^7.16.7"
            }
        },
        "@babel/helper-plugin-utils": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-plugin-utils/-/helper-plugin-utils-7.16.7.tgz",
            "integrity": "sha512-Qg3Nk7ZxpgMrsox6HreY1ZNKdBq7K72tDSliA6dCl5f007jR4ne8iD5UzuNnCJH2xBf2BEEVGr+/OL6Gdp7RxA==",
            "dev": true
        },
        "@babel/helper-replace-supers": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-replace-supers/-/helper-replace-supers-7.16.7.tgz",
            "integrity": "sha512-y9vsWilTNaVnVh6xiJfABzsNpgDPKev9HnAgz6Gb1p6UUwf9NepdlsV7VXGCftJM+jqD5f7JIEubcpLjZj5dBw==",
            "dev": true,
            "requires": {
                "@babel/helper-environment-visitor": "^7.16.7",
                "@babel/helper-member-expression-to-functions": "^7.16.7",
                "@babel/helper-optimise-call-expression": "^7.16.7",
                "@babel/traverse": "^7.16.7",
                "@babel/types": "^7.16.7"
            }
        },
        "@babel/helper-simple-access": {
            "version": "7.17.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-simple-access/-/helper-simple-access-7.17.7.tgz",
            "integrity": "sha512-txyMCGroZ96i+Pxr3Je3lzEJjqwaRC9buMUgtomcrLe5Nd0+fk1h0LLA+ixUF5OW7AhHuQ7Es1WcQJZmZsz2XA==",
            "dev": true,
            "requires": {
                "@babel/types": "^7.17.0"
            }
        },
        "@babel/helper-split-export-declaration": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-split-export-declaration/-/helper-split-export-declaration-7.16.7.tgz",
            "integrity": "sha512-xbWoy/PFoxSWazIToT9Sif+jJTlrMcndIsaOKvTA6u7QEo7ilkRZpjew18/W3c7nm8fXdUDXh02VXTbZ0pGDNw==",
            "dev": true,
            "requires": {
                "@babel/types": "^7.16.7"
            }
        },
        "@babel/helper-validator-identifier": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-validator-identifier/-/helper-validator-identifier-7.16.7.tgz",
            "integrity": "sha512-hsEnFemeiW4D08A5gUAZxLBTXpZ39P+a+DGDsHw1yxqyQ/jzFEnxf5uTEGp+3bzAbNOxU1paTgYS4ECU/IgfDw==",
            "dev": true
        },
        "@babel/helper-validator-option": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/helper-validator-option/-/helper-validator-option-7.16.7.tgz",
            "integrity": "sha512-TRtenOuRUVo9oIQGPC5G9DgK4743cdxvtOw0weQNpZXaS16SCBi5MNjZF8vba3ETURjZpTbVn7Vvcf2eAwFozQ==",
            "dev": true
        },
        "@babel/helpers": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/helpers/-/helpers-7.17.9.tgz",
            "integrity": "sha512-cPCt915ShDWUEzEp3+UNRktO2n6v49l5RSnG9M5pS24hA+2FAc5si+Pn1i4VVbQQ+jh+bIZhPFQOJOzbrOYY1Q==",
            "dev": true,
            "requires": {
                "@babel/template": "^7.16.7",
                "@babel/traverse": "^7.17.9",
                "@babel/types": "^7.17.0"
            }
        },
        "@babel/highlight": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/highlight/-/highlight-7.17.9.tgz",
            "integrity": "sha512-J9PfEKCbFIv2X5bjTMiZu6Vf341N05QIY+d6FvVKynkG1S7G0j3I0QoRtWIrXhZ+/Nlb5Q0MzqL7TokEJ5BNHg==",
            "dev": true,
            "requires": {
                "@babel/helper-validator-identifier": "^7.16.7",
                "chalk": "^2.0.0",
                "js-tokens": "^4.0.0"
            },
            "dependencies": {
                "ansi-styles": {
                    "version": "3.2.1",
                    "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-3.2.1.tgz",
                    "integrity": "sha512-VT0ZI6kZRdTh8YyJw3SMbYm/u+NqfsAxEpWO0Pf9sq8/e94WxxOpPKx9FR1FlyCtOVDNOQ+8ntlqFxiRc+r5qA==",
                    "dev": true,
                    "requires": {
                        "color-convert": "^1.9.0"
                    }
                },
                "chalk": {
                    "version": "2.4.2",
                    "resolved": "https://registry.npmjs.org/chalk/-/chalk-2.4.2.tgz",
                    "integrity": "sha512-Mti+f9lpJNcwF4tWV8/OrTTtF1gZi+f8FqlyAdouralcFWFQWF2+NgCHShjkCb+IFBLq9buZwE1xckQU4peSuQ==",
                    "dev": true,
                    "requires": {
                        "ansi-styles": "^3.2.1",
                        "escape-string-regexp": "^1.0.5",
                        "supports-color": "^5.3.0"
                    }
                },
                "color-convert": {
                    "version": "1.9.3",
                    "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-1.9.3.tgz",
                    "integrity": "sha512-QfAUtd+vFdAtFQcC8CCyYt1fYWxSqAiK2cSD6zDB8N3cpsEBAvRxp9zOGg6G/SHHJYAT88/az/IuDGALsNVbGg==",
                    "dev": true,
                    "requires": {
                        "color-name": "1.1.3"
                    }
                },
                "color-name": {
                    "version": "1.1.3",
                    "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.3.tgz",
                    "integrity": "sha1-p9BVi9icQveV3UIyj3QIMcpTvCU=",
                    "dev": true
                },
                "escape-string-regexp": {
                    "version": "1.0.5",
                    "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-1.0.5.tgz",
                    "integrity": "sha1-G2HAViGQqN/2rjuyzwIAyhMLhtQ=",
                    "dev": true
                },
                "has-flag": {
                    "version": "3.0.0",
                    "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-3.0.0.tgz",
                    "integrity": "sha1-tdRU3CGZriJWmfNGfloH87lVuv0=",
                    "dev": true
                },
                "supports-color": {
                    "version": "5.5.0",
                    "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-5.5.0.tgz",
                    "integrity": "sha512-QjVjwdXIt408MIiAqCX4oUKsgU2EqAGzs2Ppkm4aQYbjm+ZEWEcW4SfFNTr4uMNZma0ey4f5lgLrkB0aX0QMow==",
                    "dev": true,
                    "requires": {
                        "has-flag": "^3.0.0"
                    }
                }
            }
        },
        "@babel/parser": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/parser/-/parser-7.17.9.tgz",
            "integrity": "sha512-vqUSBLP8dQHFPdPi9bc5GK9vRkYHJ49fsZdtoJ8EQ8ibpwk5rPKfvNIwChB0KVXcIjcepEBBd2VHC5r9Gy8ueg==",
            "dev": true
        },
        "@babel/plugin-syntax-typescript": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/plugin-syntax-typescript/-/plugin-syntax-typescript-7.16.7.tgz",
            "integrity": "sha512-YhUIJHHGkqPgEcMYkPCKTyGUdoGKWtopIycQyjJH8OjvRgOYsXsaKehLVPScKJWAULPxMa4N1vCe6szREFlZ7A==",
            "dev": true,
            "requires": {
                "@babel/helper-plugin-utils": "^7.16.7"
            }
        },
        "@babel/plugin-transform-typescript": {
            "version": "7.16.8",
            "resolved": "https://registry.npmjs.org/@babel/plugin-transform-typescript/-/plugin-transform-typescript-7.16.8.tgz",
            "integrity": "sha512-bHdQ9k7YpBDO2d0NVfkj51DpQcvwIzIusJ7mEUaMlbZq3Kt/U47j24inXZHQ5MDiYpCs+oZiwnXyKedE8+q7AQ==",
            "dev": true,
            "requires": {
                "@babel/helper-create-class-features-plugin": "^7.16.7",
                "@babel/helper-plugin-utils": "^7.16.7",
                "@babel/plugin-syntax-typescript": "^7.16.7"
            }
        },
        "@babel/preset-typescript": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/preset-typescript/-/preset-typescript-7.16.7.tgz",
            "integrity": "sha512-WbVEmgXdIyvzB77AQjGBEyYPZx+8tTsO50XtfozQrkW8QB2rLJpH2lgx0TRw5EJrBxOZQ+wCcyPVQvS8tjEHpQ==",
            "dev": true,
            "requires": {
                "@babel/helper-plugin-utils": "^7.16.7",
                "@babel/helper-validator-option": "^7.16.7",
                "@babel/plugin-transform-typescript": "^7.16.7"
            }
        },
        "@babel/template": {
            "version": "7.16.7",
            "resolved": "https://registry.npmjs.org/@babel/template/-/template-7.16.7.tgz",
            "integrity": "sha512-I8j/x8kHUrbYRTUxXrrMbfCa7jxkE7tZre39x3kjr9hvI82cK1FfqLygotcWN5kdPGWcLdWMHpSBavse5tWw3w==",
            "dev": true,
            "requires": {
                "@babel/code-frame": "^7.16.7",
                "@babel/parser": "^7.16.7",
                "@babel/types": "^7.16.7"
            }
        },
        "@babel/traverse": {
            "version": "7.17.9",
            "resolved": "https://registry.npmjs.org/@babel/traverse/-/traverse-7.17.9.tgz",
            "integrity": "sha512-PQO8sDIJ8SIwipTPiR71kJQCKQYB5NGImbOviK8K+kg5xkNSYXLBupuX9QhatFowrsvo9Hj8WgArg3W7ijNAQw==",
            "dev": true,
            "requires": {
                "@babel/code-frame": "^7.16.7",
                "@babel/generator": "^7.17.9",
                "@babel/helper-environment-visitor": "^7.16.7",
                "@babel/helper-function-name": "^7.17.9",
                "@babel/helper-hoist-variables": "^7.16.7",
                "@babel/helper-split-export-declaration": "^7.16.7",
                "@babel/parser": "^7.17.9",
                "@babel/types": "^7.17.0",
                "debug": "^4.1.0",
                "globals": "^11.1.0"
            }
        },
        "@babel/types": {
            "version": "7.17.0",
            "resolved": "https://registry.npmjs.org/@babel/types/-/types-7.17.0.tgz",
            "integrity": "sha512-TmKSNO4D5rzhL5bjWFcVHHLETzfQ/AmbKpKPOSjlP0WoHZ6L911fgoOKY4Alp/emzG4cHJdyN49zpgkbXFEHHw==",
            "dev": true,
            "requires": {
                "@babel/helper-validator-identifier": "^7.16.7",
                "to-fast-properties": "^2.0.0"
            }
        },
        "@codemirror/autocomplete": {
            "version": "0.20.1",
            "resolved": "https://registry.npmjs.org/@codemirror/autocomplete/-/autocomplete-0.20.1.tgz",
            "integrity": "sha512-rWDAkE1Qn9O4LsV8tAm/KlzzqdQLaIxqDOLhVYja3rKQIWebD3dixIzg9BAKpjt+0dIaDwtIp3yinD9MefgbQQ==",
            "requires": {
                "@codemirror/language": "^0.20.0",
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0",
                "@lezer/common": "^0.16.0"
            }
        },
        "@codemirror/basic-setup": {
            "version": "0.20.0",
            "resolved": "https://registry.npmjs.org/@codemirror/basic-setup/-/basic-setup-0.20.0.tgz",
            "integrity": "sha512-W/ERKMLErWkrVLyP5I8Yh8PXl4r+WFNkdYVSzkXYPQv2RMPSkWpr2BgggiSJ8AHF/q3GuApncDD8I4BZz65fyg==",
            "requires": {
                "@codemirror/autocomplete": "^0.20.0",
                "@codemirror/commands": "^0.20.0",
                "@codemirror/language": "^0.20.0",
                "@codemirror/lint": "^0.20.0",
                "@codemirror/search": "^0.20.0",
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0"
            }
        },
        "@codemirror/commands": {
            "version": "0.20.0",
            "resolved": "https://registry.npmjs.org/@codemirror/commands/-/commands-0.20.0.tgz",
            "integrity": "sha512-v9L5NNVA+A9R6zaFvaTbxs30kc69F6BkOoiEbeFw4m4I0exmDEKBILN6mK+GksJtvTzGBxvhAPlVFTdQW8GB7Q==",
            "requires": {
                "@codemirror/language": "^0.20.0",
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0",
                "@lezer/common": "^0.16.0"
            }
        },
        "@codemirror/lang-javascript": {
            "version": "0.20.0",
            "resolved": "https://registry.npmjs.org/@codemirror/lang-javascript/-/lang-javascript-0.20.0.tgz",
            "integrity": "sha512-Wawq5+o1DlWtsqAyaa9NkiSXNT7geFcfdUael0hIQdM7P23gkQaD+xgZcyQP6QvPxVAdnY4VIWHFzFAqBti+WQ==",
            "requires": {
                "@codemirror/autocomplete": "^0.20.0",
                "@codemirror/language": "^0.20.0",
                "@codemirror/lint": "^0.20.0",
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0",
                "@lezer/javascript": "^0.16.0"
            }
        },
        "@codemirror/language": {
            "version": "0.20.2",
            "resolved": "https://registry.npmjs.org/@codemirror/language/-/language-0.20.2.tgz",
            "integrity": "sha512-WB3Bnuusw0xhVvhBocieYKwJm04SOk5bPoOEYksVHKHcGHFOaYaw+eZVxR4gIqMMcGzOIUil0FsCmFk8yrhHpw==",
            "requires": {
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0",
                "@lezer/common": "^0.16.0",
                "@lezer/highlight": "^0.16.0",
                "@lezer/lr": "^0.16.0",
                "style-mod": "^4.0.0"
            }
        },
        "@codemirror/lint": {
            "version": "0.20.2",
            "resolved": "https://registry.npmjs.org/@codemirror/lint/-/lint-0.20.2.tgz",
            "integrity": "sha512-xEH3wlzoFLEhPEeMVRNoQIhoTCMEtXhVxemGh3FYjLfl/CL3B2Wz+CU7ooP5SKhN1le7JqUNSfiTArFP+IzFuw==",
            "requires": {
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.2",
                "crelt": "^1.0.5"
            }
        },
        "@codemirror/search": {
            "version": "0.20.1",
            "resolved": "https://registry.npmjs.org/@codemirror/search/-/search-0.20.1.tgz",
            "integrity": "sha512-ROe6gRboQU5E4z6GAkNa2kxhXqsGNbeLEisbvzbOeB7nuDYXUZ70vGIgmqPu0tB+1M3F9yWk6W8k2vrFpJaD4Q==",
            "requires": {
                "@codemirror/state": "^0.20.0",
                "@codemirror/view": "^0.20.0",
                "crelt": "^1.0.5"
            }
        },
        "@codemirror/state": {
            "version": "0.20.0",
            "resolved": "https://registry.npmjs.org/@codemirror/state/-/state-0.20.0.tgz",
            "integrity": "sha512-R3XrAWCS5Xm9lx+4pDET4EUPEg+8bDfAa5zoOFIhx+VChsfew9Vy33dAjCXS5ES4Q8UecW4WM4UudmUFpZ+86A=="
        },
        "@codemirror/view": {
            "version": "0.20.6",
            "resolved": "https://registry.npmjs.org/@codemirror/view/-/view-0.20.6.tgz",
            "integrity": "sha512-k/Enz4HMcST5Waom2r8y8VtiJfgnU5+Y/pNVO45eIhsRH+0LYtAMgJqqqspWVv1apOuMzmlttw6keaPvkloakg==",
            "requires": {
                "@codemirror/state": "^0.20.0",
                "style-mod": "^4.0.0",
                "w3c-keyname": "^2.2.4"
            }
        },
        "@colors/colors": {
            "version": "1.5.0",
            "resolved": "https://registry.npmjs.org/@colors/colors/-/colors-1.5.0.tgz",
            "integrity": "sha512-ooWCrlZP11i8GImSjTHYHLkvFDP48nS4+204nGb1RiX/WXYHmJA2III9/e2DWVabCESdW7hBAEzHRqUn9OUVvQ==",
            "dev": true
        },
        "@gar/promisify": {
            "version": "1.1.3",
            "resolved": "https://registry.npmjs.org/@gar/promisify/-/promisify-1.1.3.tgz",
            "integrity": "sha512-k2Ty1JcVojjJFwrg/ThKi2ujJ7XNLYaFGNB/bWT9wGR+oSMJHMa5w+CUq6p/pVrKeNNgA7pCqEcjSnHVoqJQFw==",
            "dev": true
        },
        "@improbable-eng/grpc-web": {
            "version": "0.14.1",
            "resolved": "https://registry.npmjs.org/@improbable-eng/grpc-web/-/grpc-web-0.14.1.tgz",
            "integrity": "sha512-XaIYuunepPxoiGVLLHmlnVminUGzBTnXr8Wv7khzmLWbNw4TCwJKX09GSMJlKhu/TRk6gms0ySFxewaETSBqgw==",
            "dev": true,
            "requires": {
                "browser-headers": "^0.4.1"
            }
        },
        "@ipld/dag-cbor": {
            "version": "7.0.1",
            "resolved": "https://registry.npmjs.org/@ipld/dag-cbor/-/dag-cbor-7.0.1.tgz",
            "integrity": "sha512-XqG8VEzHjQDC/Qcy5Gyf1kvAav5VuAugc6c7VtdaRLI+3d8lJrUP3F76GYJNNXuEnRZ58cCBnNNglkIGTdg1+A==",
            "dev": true,
            "requires": {
                "cborg": "^1.6.0",
                "multiformats": "^9.5.4"
            }
        },
        "@ipld/dag-json": {
            "version": "8.0.9",
            "resolved": "https://registry.npmjs.org/@ipld/dag-json/-/dag-json-8.0.9.tgz",
            "integrity": "sha512-NNKHmgHxc2zOEaB8qOUpAb2UK1vcEE/rBeh018Da/RzXE7N8GwiTJLRZ3Fe/G4fsiis67G0sagRz/YNQcANRsQ==",
            "dev": true,
            "requires": {
                "cborg": "^1.5.4",
                "multiformats": "^9.5.4"
            }
        },
        "@ipld/dag-pb": {
            "version": "2.1.16",
            "resolved": "https://registry.npmjs.org/@ipld/dag-pb/-/dag-pb-2.1.16.tgz",
            "integrity": "sha512-5+A87ZsKZ2yEEjtW6LIzTgDJcm6O24d0lmXlubwtMblI5ZB+aTw7PH6kjc8fM6pbnNtVg4Y+c+WZ3zCxdesIBg==",
            "dev": true,
            "requires": {
                "multiformats": "^9.5.4"
            }
        },
        "@jridgewell/resolve-uri": {
            "version": "3.0.6",
            "resolved": "https://registry.npmjs.org/@jridgewell/resolve-uri/-/resolve-uri-3.0.6.tgz",
            "integrity": "sha512-R7xHtBSNm+9SyvpJkdQl+qrM3Hm2fea3Ef197M3mUug+v+yR+Rhfbs7PBtcBUVnIWJ4JcAdjvij+c8hXS9p5aw==",
            "dev": true
        },
        "@jridgewell/sourcemap-codec": {
            "version": "1.4.11",
            "resolved": "https://registry.npmjs.org/@jridgewell/sourcemap-codec/-/sourcemap-codec-1.4.11.tgz",
            "integrity": "sha512-Fg32GrJo61m+VqYSdRSjRXMjQ06j8YIYfcTqndLYVAaHmroZHLJZCydsWBOTDqXS2v+mjxohBWEMfg97GXmYQg==",
            "dev": true
        },
        "@jridgewell/trace-mapping": {
            "version": "0.3.9",
            "resolved": "https://registry.npmjs.org/@jridgewell/trace-mapping/-/trace-mapping-0.3.9.tgz",
            "integrity": "sha512-3Belt6tdc8bPgAtbcmdtNJlirVoTmEb5e2gC94PnkwEW9jI6CAHUeoG85tjWP5WquqfavoMtMwiG4P926ZKKuQ==",
            "dev": true,
            "requires": {
                "@jridgewell/resolve-uri": "^3.0.3",
                "@jridgewell/sourcemap-codec": "^1.4.10"
            }
        },
        "@jspm/core": {
            "version": "2.0.0-beta.24",
            "resolved": "https://registry.npmjs.org/@jspm/core/-/core-2.0.0-beta.24.tgz",
            "integrity": "sha512-a4Bo/80Z6CoJNor5ldgs6002utmmbttP4JYd/FJ0Ob2fVdf6O6ha5SORBCqrnDnBvMc1TlrHY7dCfat5+H0a6A==",
            "dev": true
        },
        "@jspm/generator": {
            "version": "1.0.0-beta.30",
            "resolved": "https://registry.npmjs.org/@jspm/generator/-/generator-1.0.0-beta.30.tgz",
            "integrity": "sha512-cXl1UqKVo8k+tJPrUAHNy6imgzo1+fYY82uOOq7MOHR/TJ8B0KY8m5xxh14KlW3CONEpkpqcHngX/Sk39VH5VQ==",
            "dev": true,
            "requires": {
                "@babel/core": "^7.15.8",
                "@babel/preset-typescript": "^7.15.0",
                "@jspm/core": "^2.0.0-beta.8",
                "@jspm/import-map": "^0.3.1",
                "es-module-lexer": "^0.10.4",
                "ipfs-client": "^0.7.1",
                "make-fetch-happen": "^8.0.3",
                "sver": "^1.8.3",
                "typescript": "^4.3.5"
            }
        },
        "@jspm/import-map": {
            "version": "0.3.3",
            "resolved": "https://registry.npmjs.org/@jspm/import-map/-/import-map-0.3.3.tgz",
            "integrity": "sha512-hD9CIedeViPfUHEs8mmjzAhr/WXR+tsjfC+Evq6GAJMB3wxlW4amUNGgpwRNqfSvd2izA+ekxW9X5FFAJJKJEQ==",
            "dev": true
        },
        "@lezer/common": {
            "version": "0.16.0",
            "resolved": "https://registry.npmjs.org/@lezer/common/-/common-0.16.0.tgz",
            "integrity": "sha512-H6sPCku+asKWYaNjwfQ1Uvcay9UP1Pdzu4qpy8GtRZ0cKT2AAGnj9MQGiRtY18MDntvhYRJxNGv7FNWOSV/e8A=="
        },
        "@lezer/highlight": {
            "version": "0.16.0",
            "resolved": "https://registry.npmjs.org/@lezer/highlight/-/highlight-0.16.0.tgz",
            "integrity": "sha512-iE5f4flHlJ1g1clOStvXNLbORJoiW4Kytso6ubfYzHnaNo/eo5SKhxs4wv/rtvwZQeZrK3we8S9SyA7OGOoRKQ==",
            "requires": {
                "@lezer/common": "^0.16.0"
            }
        },
        "@lezer/javascript": {
            "version": "0.16.0",
            "resolved": "https://registry.npmjs.org/@lezer/javascript/-/javascript-0.16.0.tgz",
            "integrity": "sha512-kDcwX3QMFKVd7VJwlYTeTNtcj3/gXQEDa7cQzXXsFMvTGV/RTDq0r8agTpZu0zBc1RUZkVILusd1Cluz3STRqw==",
            "requires": {
                "@lezer/highlight": "^0.16.0",
                "@lezer/lr": "^0.16.0"
            }
        },
        "@lezer/lr": {
            "version": "0.16.3",
            "resolved": "https://registry.npmjs.org/@lezer/lr/-/lr-0.16.3.tgz",
            "integrity": "sha512-pau7um4eAw94BEuuShUIeQDTf3k4Wt6oIUOYxMmkZgDHdqtIcxWND4LRxi8nI9KuT4I1bXQv67BCapkxt7Ywqw==",
            "requires": {
                "@lezer/common": "^0.16.0"
            }
        },
        "@lit/reactive-element": {
            "version": "1.3.2",
            "resolved": "https://registry.npmjs.org/@lit/reactive-element/-/reactive-element-1.3.2.tgz",
            "integrity": "sha512-A2e18XzPMrIh35nhIdE4uoqRzoIpEU5vZYuQN4S3Ee1zkGdYC27DP12pewbw/RLgPHzaE4kx/YqxMzebOpm0dA=="
        },
        "@material/animation": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/animation/-/animation-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-GBuR4VmcTQW1D0lPXEosf5Giho72LLbyGIydWGtaEUtLJoive/D9kFkwTN4Fsyt9Kkl7hbhs35vrNe6QkAH4/Q==",
            "requires": {
                "tslib": "^2.1.0"
            }
        },
        "@material/base": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/base/-/base-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-UJKbXwZtkrA3sfQDmj8Zbw1Q3Tqtl6KdfVFws95Yf7TCUgTFzbZI/FSx1w7dVugQPOEnIBuZnzqZam/MtHkx4w==",
            "requires": {
                "tslib": "^2.1.0"
            }
        },
        "@material/button": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/button/-/button-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-IPBAByKpQjrWNVmAWx5VCTCLnOw4ymbLsbHmBkLiDgcLPs1EtwYnKKIwQ+/t3bV02OShUdMiyboL8V/C0gMS1A==",
            "requires": {
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/focus-ring": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/tokens": "14.0.0-canary.53b3cad2f.0",
                "@material/touch-target": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/density": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/density/-/density-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-Eh/vZ3vVyqtpylg5Ci33qlgtToS4H1/ppd450Ib3tcdISIoodgijYY0w4XsRvrnZgbI/h/1STFdLxdzS0UNuFw==",
            "requires": {
                "tslib": "^2.1.0"
            }
        },
        "@material/dialog": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/dialog/-/dialog-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-yiG2nlVKTW0Ro3CF8Z/MVpTwSyG/8Kio3AaTUbeQdbjt5r692s4x5Yhd8m1IjEQKUeulY4CndvIbCUwZ8/G2PA==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/button": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/icon-button": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/tokens": "14.0.0-canary.53b3cad2f.0",
                "@material/touch-target": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/dom": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/dom/-/dom-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-aR+rfncF6oi2ivdOlKSJI4UXwNzWV5rXM88MLDoSJF1D7lXxhAKhge+tMUBodWGV/q0+FnXLuVAa0WYTrKjo+A==",
            "requires": {
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/drawer": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/drawer/-/drawer-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-MXzRGq7NoONgbHa+AhAu4HvOUA9V37nSsY4g4Alita08UqRAvvFFr4K1CF9GI2K9pLCpyQv1UbN0Lw5b78HrVQ==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/list": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/elevation": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/elevation/-/elevation-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-3h+EkR588RMZ5TSNQ4UeXD1FOBnL3ABQix0DQIGwtNJCqSMoPndT/oJEFvwQbTkZNDbFIKN9p1Q7/KuFPVY8Pw==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/feature-targeting": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/feature-targeting/-/feature-targeting-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-fn7Af3PRyARtNeYqtjxXmE3Y/dCpnpQVWWys57MqiGR/nvc6qpgOfJ6rOdcu/MrOysOE/oebTUDmDnTmwpe9Hw==",
            "requires": {
                "tslib": "^2.1.0"
            }
        },
        "@material/floating-label": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/floating-label/-/floating-label-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-gHZUTTVKnP+Zjz4l9IT/G89NPmypn5FlTGLWKKqXbuQphr37rsKFR3Y80SJxULRyMDnAdKSxuZwiXLFKQz9KlA==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/focus-ring": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/focus-ring/-/focus-ring-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-exPX5VrjQimipBwgcFDGRiEE783sOBgpkFui59A6i6iGvS2UrLHlYY2E65fyyyQnD1f/rv4Po1OOnCesE1kulg==",
            "requires": {
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0"
            }
        },
        "@material/icon-button": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/icon-button/-/icon-button-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-BFdj3CP0JXHC/F2bDmpmzWhum4fkzIDgCCavvnpE/KcCbr0AaoSULRde+LtqvbdLIYW20cXhvjinIOlRhSOshA==",
            "requires": {
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/focus-ring": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/touch-target": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/line-ripple": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/line-ripple/-/line-ripple-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-k8f8uuDwnSqZZ98CzbYtQVtxlp1ryUup9nd2uobo3kiqQNlQfXdGkVjuCXcla0OPiKFizNn7dS6Kl/j6L09XUA==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/linear-progress": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/linear-progress/-/linear-progress-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-QqkDBcqX7TMt3zQn51LgS7K0y13rJ4ppMQL1f2uYBhDOov8nqndlaXw456KYE9RhU39JrLzVQlaAbU3eecVb/Q==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/progress-indicator": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/list": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/list/-/list-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-mkMpltSKAYLBtFnTTCk/mQIDzwxF/VLh1gh59ehOtmRXt7FvTz83RoAa4tqe53hpVrbX4HoLDBu+vILhq/wkjw==",
            "requires": {
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/menu": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/menu/-/menu-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-MmYKVrMIqOtP3TN4vdrrnQrS8P81+tMaA6bKiT9V79R1U6+mKsBYTzaLtLbzyem5vF8O0q7bSwyPwhWPtJr75Q==",
            "requires": {
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/list": "14.0.0-canary.53b3cad2f.0",
                "@material/menu-surface": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/menu-surface": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/menu-surface/-/menu-surface-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-IQWb/n15FpLnn+kHp0EqzLE+UoWSPumq3eze2QifiowvGb37bNFR9oSe7CaOzPMrHdkrZ5SBWnDU41wPZN5kOg==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/mwc-base": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-base/-/mwc-base-0.26.1.tgz",
            "integrity": "sha512-YcVvWwSoDwQAxjvYevhZgtyXIIPuMeTnw9MtEj+Hv7NJizT88hoTsPmKpwM+X58cIY2SPo0y/tHfgmblWntibQ==",
            "requires": {
                "@material/base": "=14.0.0-canary.53b3cad2f.0",
                "@material/dom": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-button": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-button/-/mwc-button-0.26.1.tgz",
            "integrity": "sha512-ptgAmg50k+71M6ynfv6QeNaBnX7X/EAnhOjxZqhDHrKwZcFuuQyFJJ6r4ypjc21eCSPS7o6xRqJyI4PPpf3xkA==",
            "requires": {
                "@material/mwc-icon": "^0.26.1",
                "@material/mwc-ripple": "^0.26.1",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-checkbox": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-checkbox/-/mwc-checkbox-0.26.1.tgz",
            "integrity": "sha512-2euxVZ0zksAQ/JVkOznUOGJKfbxq+m3ijRTh44b8fQyERBobm5QtWXbhXxV9YCesqFQSbj5M3qDw6Nm5MRKluw==",
            "requires": {
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-ripple": "^0.26.1",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-dialog": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-dialog/-/mwc-dialog-0.26.1.tgz",
            "integrity": "sha512-QI9OkD0ZXZRyxA9I3ZbRjn4iRdDh/u+ZtcfZtIhKKgm3S0pkHAxndNlygq8DHQgwCO5HxMcmEot7voAdDtpfoQ==",
            "requires": {
                "@material/dialog": "=14.0.0-canary.53b3cad2f.0",
                "@material/dom": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-button": "^0.26.1",
                "blocking-elements": "^0.1.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1",
                "wicg-inert": "^3.0.0"
            }
        },
        "@material/mwc-drawer": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-drawer/-/mwc-drawer-0.26.1.tgz",
            "integrity": "sha512-KzyfokeKN9WGEepcou9kkMLnGc6H78GARpmLbqm0o5oQbDbJLlD/x7ENSgCU+HpRpmCo8eEkU87YHBhJI0yQbA==",
            "requires": {
                "@material/drawer": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "blocking-elements": "^0.1.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1",
                "wicg-inert": "^3.0.0"
            }
        },
        "@material/mwc-floating-label": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-floating-label/-/mwc-floating-label-0.26.1.tgz",
            "integrity": "sha512-iPKOWAgypL+UNZWa0jNE2P/929QEbHqrxr7BFNKpSvO/t6pX7672g1gOny7+8Dnnt+a4kVlYjWTMAw9qjOkLlg==",
            "requires": {
                "@material/floating-label": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-icon": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-icon/-/mwc-icon-0.26.1.tgz",
            "integrity": "sha512-RPcVPn+5p6hA2HjX/0wkeHQuxkJKgXMg47ffw+vhIw28qM8mprSv13hpUgrghb0f7xBvuPhf/kLb37V4xkRfwg==",
            "requires": {
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-icon-button": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-icon-button/-/mwc-icon-button-0.26.1.tgz",
            "integrity": "sha512-pa3zFSH1wV7j8dH1i5NfKL0mKqQsan+SiD+lkW39Al4NeCrNoWN9wJY0mSiwrlbVnxOub8r2kWINCpTHBoluJg==",
            "requires": {
                "@material/mwc-ripple": "^0.26.1",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-line-ripple": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-line-ripple/-/mwc-line-ripple-0.26.1.tgz",
            "integrity": "sha512-pTWYurvptGGZI5OP3SXJPNQrsri+1tM8CUGTuTLaLVTSIyvMcUiTzfNPCyTmkjndoCsbrPYjPzY8f/wiU4mZrA==",
            "requires": {
                "@material/line-ripple": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-linear-progress": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-linear-progress/-/mwc-linear-progress-0.26.1.tgz",
            "integrity": "sha512-UNPrRCb6y+m5FU8NDOLl7+41RXygeQKvHUKXU6R2UMN8NSOiq/FUAEYZZBM3SHCMeaRwltY5uWhBy5dojoPjIw==",
            "requires": {
                "@material/linear-progress": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/theme": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-list": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-list/-/mwc-list-0.26.1.tgz",
            "integrity": "sha512-1jYG0/VCJhUjjJQSDvjvMiTryOtKk5TEzpkTO/kguhdN9j6vk0XU/p/LhnyxV0+fQei754AO3Tos5Dv0FvEUOQ==",
            "requires": {
                "@material/base": "=14.0.0-canary.53b3cad2f.0",
                "@material/dom": "=14.0.0-canary.53b3cad2f.0",
                "@material/list": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-checkbox": "^0.26.1",
                "@material/mwc-radio": "^0.26.1",
                "@material/mwc-ripple": "^0.26.1",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-menu": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-menu/-/mwc-menu-0.26.1.tgz",
            "integrity": "sha512-zdLalm1vabFU2+ml53B7N88OoJo+yygXGra94GluCPLCRBV6Oswdou7b8cqEyVEJ6McbeiegKwO0j8k3mEd4zw==",
            "requires": {
                "@material/menu": "=14.0.0-canary.53b3cad2f.0",
                "@material/menu-surface": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-list": "^0.26.1",
                "@material/shape": "=14.0.0-canary.53b3cad2f.0",
                "@material/theme": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-notched-outline": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-notched-outline/-/mwc-notched-outline-0.26.1.tgz",
            "integrity": "sha512-3vsbnNk9dzyATANoL+nv7nwGvvzgb4tQcMbjP023qmpkelV/Ci2jP8nV+UDDepJcZ6KjRJo1eUAroznp4T/rKA==",
            "requires": {
                "@material/mwc-base": "^0.26.1",
                "@material/notched-outline": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-radio": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-radio/-/mwc-radio-0.26.1.tgz",
            "integrity": "sha512-KWEcwVKbZS0wIfxOk8AqFNZocnP2f3JjnO/m2y6RWBUUrSgIlxavfz3J5MiwDC0JjYI1jUmheivcKrlZRNxnSA==",
            "requires": {
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-ripple": "^0.26.1",
                "@material/radio": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-ripple": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-ripple/-/mwc-ripple-0.26.1.tgz",
            "integrity": "sha512-hBeC2S7TSYLmHetXbtu52/EZFzvAqrQk5skIV0aUZeZvywTJWRVoc5OavDjsJYuKxDnSECMnkIt8+l8WC48chg==",
            "requires": {
                "@material/dom": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/ripple": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-select": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-select/-/mwc-select-0.26.1.tgz",
            "integrity": "sha512-glqhi0HeNtm7LgVNW/Vxk2QLm76mjkY0Sw5CFkcedMcjqkoj3fiuTtcMkoQlb4/MeCqgFZyO0xxCOOz9LSNF4A==",
            "requires": {
                "@material/dom": "=14.0.0-canary.53b3cad2f.0",
                "@material/floating-label": "=14.0.0-canary.53b3cad2f.0",
                "@material/line-ripple": "=14.0.0-canary.53b3cad2f.0",
                "@material/list": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-floating-label": "^0.26.1",
                "@material/mwc-icon": "^0.26.1",
                "@material/mwc-line-ripple": "^0.26.1",
                "@material/mwc-list": "^0.26.1",
                "@material/mwc-menu": "^0.26.1",
                "@material/mwc-notched-outline": "^0.26.1",
                "@material/select": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-snackbar": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-snackbar/-/mwc-snackbar-0.26.1.tgz",
            "integrity": "sha512-933enXy1hxO769muJ2D2q8FtT7cnrlpOvpVZ2a6j2hapZi55o26Qvlna+PxjUYPM695n+7dR6R5+4zOzbYP03Q==",
            "requires": {
                "@material/mwc-base": "^0.26.1",
                "@material/snackbar": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-textfield": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-textfield/-/mwc-textfield-0.26.1.tgz",
            "integrity": "sha512-Kdb31R2PROUOM7hpyjb+pY4WIOu6BQSEQKeVy4hnLqwvhe14nTvnn9I7Fkkz4t9SNWPh3G+DQsAx9vhPuCgUyQ==",
            "requires": {
                "@material/floating-label": "=14.0.0-canary.53b3cad2f.0",
                "@material/line-ripple": "=14.0.0-canary.53b3cad2f.0",
                "@material/mwc-base": "^0.26.1",
                "@material/mwc-floating-label": "^0.26.1",
                "@material/mwc-line-ripple": "^0.26.1",
                "@material/mwc-notched-outline": "^0.26.1",
                "@material/textfield": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/mwc-top-app-bar": {
            "version": "0.26.1",
            "resolved": "https://registry.npmjs.org/@material/mwc-top-app-bar/-/mwc-top-app-bar-0.26.1.tgz",
            "integrity": "sha512-zAASmr8Dqf+4RyFGbaF4JvU5AYQn0yfeRuOcXlzcpUQlLgJqYp6plMLdPjVa+Ek3LBQGItQrGoDSX3y2mmkncw==",
            "requires": {
                "@material/mwc-base": "^0.26.1",
                "@material/top-app-bar": "=14.0.0-canary.53b3cad2f.0",
                "lit": "^2.0.0",
                "tslib": "^2.0.1"
            }
        },
        "@material/notched-outline": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/notched-outline/-/notched-outline-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-3ByiPOC/wWQmFKfgJS98kb5/6v92n7uIfJ6v6sryKJlJCJn39qfpGcCM5RpRIws1RET1s1zBJT2JDwYeu/hM5A==",
            "requires": {
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/floating-label": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/progress-indicator": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/progress-indicator/-/progress-indicator-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-vW0oZK70QOpAarip95ueCQ/I3kBClcWjxsc0F0QjkqT76DOVXpjnZ4XoRRyq9eMpwLqlKLTecrsSNpmqwwF1Dg==",
            "requires": {
                "tslib": "^2.1.0"
            }
        },
        "@material/radio": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/radio/-/radio-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-V/AgWEOuHFoh9d4Gq1rqBZnKSGtMLQNh23Bwrv0c1FhPqFvUpwt9jR3SVwhJk5gvQQWGy9p3iiGc9QCJ+0+P8Q==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/focus-ring": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/touch-target": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/ripple": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/ripple/-/ripple-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-6g2G62vd8DsMuIUSXlRrzb98qkZ4o8ZREknNwNP2zaLQEOkJ//4j9HaqDt98/3LIjUTY9UIVFTQENiMmlwKHYQ==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/rtl": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/rtl/-/rtl-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-f08LT0HSa0WYU+4Jz/tbm1TQ9Fcf2k+H6dPPYv0J1sZmX6hMgCEmNiUdUFLQFvszoXx2XrRi1/hIFjbz2e69Yg==",
            "requires": {
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/select": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/select/-/select-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-fAiTaHZ1PIEmCUbufS+IZvsWO0hDxtbU8rOsbmSu1oupAboP7jSgOVgcCGdT9KY5WacrniIIMO6jZjhnvrC0Lg==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/floating-label": "14.0.0-canary.53b3cad2f.0",
                "@material/line-ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/list": "14.0.0-canary.53b3cad2f.0",
                "@material/menu": "14.0.0-canary.53b3cad2f.0",
                "@material/menu-surface": "14.0.0-canary.53b3cad2f.0",
                "@material/notched-outline": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/tokens": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/shape": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/shape/-/shape-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-RyjInLCNe+nI/ulKea0ZLHphXQDiDqYazS25SRn18g8Hoa5qGNaY5oOBncDXUYn3jm5oI5kFc9oif//kulkbjg==",
            "requires": {
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/snackbar": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/snackbar/-/snackbar-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-E/i+o7Q8Jp4UW7UBTslqlFeSxgyU7XE86CoYuq2g+ySSWTt8b16ug8EJTQvuk4DRdDO3tjQN1sN0R77Av6txSw==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/button": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/icon-button": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/textfield": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/textfield/-/textfield-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-Pla9Tr94Is18o97E/mqHKdkR24rPES9atGm3BlXrNzyr5tu6+h++RBbxy7V6IExcfl0MX+v9Gyqz7sPZzFtwMA==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/density": "14.0.0-canary.53b3cad2f.0",
                "@material/dom": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/floating-label": "14.0.0-canary.53b3cad2f.0",
                "@material/line-ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/notched-outline": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/tokens": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/theme": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/theme/-/theme-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-S06XAevDCDWMe+GgsEpITMS07imUidzadNaTbJsqssFajBLr53QWVZsG84BpjXKXoYvyEJvb0hX5U0lq6ip9UQ==",
            "requires": {
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/tokens": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/tokens/-/tokens-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-myHFB7vac8zErA3qgkqmV+kpE+i9JEwc/6Yf0MOumDSpylJGw28QikpNC6eAVBK2EmPQTaFn20mqUxyud8dGqw==",
            "requires": {
                "@material/elevation": "14.0.0-canary.53b3cad2f.0"
            }
        },
        "@material/top-app-bar": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/top-app-bar/-/top-app-bar-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-9vPLLxUbNrWNCPGHoIeIUtyXWQUNh+yQwnkTYVkVAVEb1CsWb2D+/NefytfvyFtXWBFQLybAeG5RH0ZqdcgQBQ==",
            "requires": {
                "@material/animation": "14.0.0-canary.53b3cad2f.0",
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/elevation": "14.0.0-canary.53b3cad2f.0",
                "@material/ripple": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "@material/shape": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "@material/typography": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/touch-target": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/touch-target/-/touch-target-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-d83e5vbqoLyL542yOTTp4TLVltddWiqbI/j1w/D9ipE30YKfe2EDN+CNJc32Zufh5IUfK41DsZdrN8fI9cL99A==",
            "requires": {
                "@material/base": "14.0.0-canary.53b3cad2f.0",
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/rtl": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@material/typography": {
            "version": "14.0.0-canary.53b3cad2f.0",
            "resolved": "https://registry.npmjs.org/@material/typography/-/typography-14.0.0-canary.53b3cad2f.0.tgz",
            "integrity": "sha512-9J0k2fq7uyHsRzRqJDJLGmg3YzRpfRPtFDVeUH/xBcYoqpZE7wYw5Mb7s/l8eP626EtR7HhXhSPjvRTLA6NIJg==",
            "requires": {
                "@material/feature-targeting": "14.0.0-canary.53b3cad2f.0",
                "@material/theme": "14.0.0-canary.53b3cad2f.0",
                "tslib": "^2.1.0"
            }
        },
        "@npmcli/fs": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/@npmcli/fs/-/fs-1.1.1.tgz",
            "integrity": "sha512-8KG5RD0GVP4ydEzRn/I4BNDuxDtqVbOdm8675T49OIG/NGhaK0pjPX7ZcDlvKYbA+ulvVK3ztfcF4uBdOxuJbQ==",
            "dev": true,
            "requires": {
                "@gar/promisify": "^1.0.1",
                "semver": "^7.3.5"
            },
            "dependencies": {
                "semver": {
                    "version": "7.3.7",
                    "resolved": "https://registry.npmjs.org/semver/-/semver-7.3.7.tgz",
                    "integrity": "sha512-QlYTucUYOews+WeEujDoEGziz4K6c47V/Bd+LjSSYcA94p+DmINdf7ncaUinThfvZyu13lN9OY1XDxt8C0Tw0g==",
                    "dev": true,
                    "requires": {
                        "lru-cache": "^6.0.0"
                    }
                }
            }
        },
        "@npmcli/move-file": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@npmcli/move-file/-/move-file-1.1.2.tgz",
            "integrity": "sha512-1SUf/Cg2GzGDyaf15aR9St9TWlb+XvbZXWpDx8YKs7MLzMH/BCeopv+y9vzrzgkfykCGuWOlSu3mZhj2+FQcrg==",
            "dev": true,
            "requires": {
                "mkdirp": "^1.0.4",
                "rimraf": "^3.0.2"
            }
        },
        "@protobufjs/aspromise": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@protobufjs/aspromise/-/aspromise-1.1.2.tgz",
            "integrity": "sha1-m4sMxmPWaafY9vXQiToU00jzD78=",
            "dev": true
        },
        "@protobufjs/base64": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@protobufjs/base64/-/base64-1.1.2.tgz",
            "integrity": "sha512-AZkcAA5vnN/v4PDqKyMR5lx7hZttPDgClv83E//FMNhR2TMcLUhfRUBHCmSl0oi9zMgDDqRUJkSxO3wm85+XLg==",
            "dev": true
        },
        "@protobufjs/codegen": {
            "version": "2.0.4",
            "resolved": "https://registry.npmjs.org/@protobufjs/codegen/-/codegen-2.0.4.tgz",
            "integrity": "sha512-YyFaikqM5sH0ziFZCN3xDC7zeGaB/d0IUb9CATugHWbd1FRFwWwt4ld4OYMPWu5a3Xe01mGAULCdqhMlPl29Jg==",
            "dev": true
        },
        "@protobufjs/eventemitter": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@protobufjs/eventemitter/-/eventemitter-1.1.0.tgz",
            "integrity": "sha1-NVy8mLr61ZePntCV85diHx0Ga3A=",
            "dev": true
        },
        "@protobufjs/fetch": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@protobufjs/fetch/-/fetch-1.1.0.tgz",
            "integrity": "sha1-upn7WYYUr2VwDBYZ/wbUVLDYTEU=",
            "dev": true,
            "requires": {
                "@protobufjs/aspromise": "^1.1.1",
                "@protobufjs/inquire": "^1.1.0"
            }
        },
        "@protobufjs/float": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/@protobufjs/float/-/float-1.0.2.tgz",
            "integrity": "sha1-Xp4avctz/Ap8uLKR33jIy9l7h9E=",
            "dev": true
        },
        "@protobufjs/inquire": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@protobufjs/inquire/-/inquire-1.1.0.tgz",
            "integrity": "sha1-/yAOPnzyQp4tyvwRQIKOjMY48Ik=",
            "dev": true
        },
        "@protobufjs/path": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@protobufjs/path/-/path-1.1.2.tgz",
            "integrity": "sha1-bMKyDFya1q0NzP0hynZz2Nf79o0=",
            "dev": true
        },
        "@protobufjs/pool": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@protobufjs/pool/-/pool-1.1.0.tgz",
            "integrity": "sha1-Cf0V8tbTq/qbZbw2ZQbWrXhG/1Q=",
            "dev": true
        },
        "@protobufjs/utf8": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/@protobufjs/utf8/-/utf8-1.1.0.tgz",
            "integrity": "sha1-p3c2C1s5oaLlEG+OhY8v0tBgxXA=",
            "dev": true
        },
        "@rollup/pluginutils": {
            "version": "4.2.1",
            "resolved": "https://registry.npmjs.org/@rollup/pluginutils/-/pluginutils-4.2.1.tgz",
            "integrity": "sha512-iKnFXr7NkdZAIHiIWE+BX5ULi/ucVFYWD6TbAV+rZctiRTY2PL6tsIKhoIOaoskiWAkgu+VsbXgUVDNLHf+InQ==",
            "dev": true,
            "requires": {
                "estree-walker": "^2.0.1",
                "picomatch": "^2.2.2"
            }
        },
        "@socket.io/base64-arraybuffer": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/@socket.io/base64-arraybuffer/-/base64-arraybuffer-1.0.2.tgz",
            "integrity": "sha512-dOlCBKnDw4iShaIsH/bxujKTM18+2TOAsYz+KSc11Am38H4q5Xw8Bbz97ZYdrVNM+um3p7w86Bvvmcn9q+5+eQ==",
            "dev": true
        },
        "@tootallnate/once": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@tootallnate/once/-/once-1.1.2.tgz",
            "integrity": "sha512-RbzJvlNzmRq5c3O09UipeuXno4tA1FE6ikOjxZK0tuxVv3412l64l5t1W5pj4+rJq9vpkm/kwiR07aZXnsKPxw==",
            "dev": true
        },
        "@types/component-emitter": {
            "version": "1.2.11",
            "resolved": "https://registry.npmjs.org/@types/component-emitter/-/component-emitter-1.2.11.tgz",
            "integrity": "sha512-SRXjM+tfsSlA9VuG8hGO2nft2p8zjXCK1VcC6N4NXbBbYbSia9kzCChYQajIjzIqOOOuh5Ock6MmV2oux4jDZQ==",
            "dev": true
        },
        "@types/cookie": {
            "version": "0.4.1",
            "resolved": "https://registry.npmjs.org/@types/cookie/-/cookie-0.4.1.tgz",
            "integrity": "sha512-XW/Aa8APYr6jSVVA1y/DEIZX0/GMKLEVekNG727R8cs56ahETkRAy/3DR7+fJyh7oUgGwNQaRfXCun0+KbWY7Q==",
            "dev": true
        },
        "@types/cors": {
            "version": "2.8.12",
            "resolved": "https://registry.npmjs.org/@types/cors/-/cors-2.8.12.tgz",
            "integrity": "sha512-vt+kDhq/M2ayberEtJcIN/hxXy1Pk+59g2FV/ZQceeaTyCtCucjL2Q7FXlFjtWn4n15KCr1NE2lNNFhp0lEThw==",
            "dev": true
        },
        "@types/long": {
            "version": "4.0.1",
            "resolved": "https://registry.npmjs.org/@types/long/-/long-4.0.1.tgz",
            "integrity": "sha512-5tXH6Bx/kNGd3MgffdmP4dy2Z+G4eaXw0SE81Tq3BNadtnMR5/ySMzX4SLEzHJzSmPNn4HIdpQsBvXMUykr58w==",
            "dev": true
        },
        "@types/minimatch": {
            "version": "3.0.5",
            "resolved": "https://registry.npmjs.org/@types/minimatch/-/minimatch-3.0.5.tgz",
            "integrity": "sha512-Klz949h02Gz2uZCMGwDUSDS1YBlTdDDgbWHi+81l29tQALUtvz4rAYi5uoVhE5Lagoq6DeqAUlbrHvW/mXDgdQ==",
            "dev": true
        },
        "@types/node": {
            "version": "17.0.25",
            "resolved": "https://registry.npmjs.org/@types/node/-/node-17.0.25.tgz",
            "integrity": "sha512-wANk6fBrUwdpY4isjWrKTufkrXdu1D2YHCot2fD/DfWxF5sMrVSA+KN7ydckvaTCh0HiqX9IVl0L5/ZoXg5M7w==",
            "dev": true
        },
        "@types/parse5": {
            "version": "6.0.3",
            "resolved": "https://registry.npmjs.org/@types/parse5/-/parse5-6.0.3.tgz",
            "integrity": "sha512-SuT16Q1K51EAVPz1K29DJ/sXjhSQ0zjvsypYJ6tlwVsRV9jwW5Adq2ch8Dq8kDBCkYnELS7N7VNCSB5nC56t/g==",
            "dev": true
        },
        "@types/trusted-types": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/@types/trusted-types/-/trusted-types-2.0.2.tgz",
            "integrity": "sha512-F5DIZ36YVLE+PN+Zwws4kJogq47hNgX3Nx6WyDJ3kcplxyke3XIzB8uK5n/Lpm1HBsbGzd6nmGehL8cPekP+Tg=="
        },
        "@ungap/promise-all-settled": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/@ungap/promise-all-settled/-/promise-all-settled-1.1.2.tgz",
            "integrity": "sha512-sL/cEvJWAnClXw0wHk85/2L0G6Sj8UB0Ctc1TEMbKSsmpRosqhwj9gWgFRZSrBr2f9tiXISwNhCPmlfqUqyb9Q==",
            "dev": true
        },
        "@web/parse5-utils": {
            "version": "1.3.0",
            "resolved": "https://registry.npmjs.org/@web/parse5-utils/-/parse5-utils-1.3.0.tgz",
            "integrity": "sha512-Pgkx3ECc8EgXSlS5EyrgzSOoUbM6P8OKS471HLAyvOBcP1NCBn0to4RN/OaKASGq8qa3j+lPX9H14uA5AHEnQg==",
            "dev": true,
            "requires": {
                "@types/parse5": "^6.0.1",
                "parse5": "^6.0.1"
            }
        },
        "@web/rollup-plugin-html": {
            "version": "1.10.3",
            "resolved": "https://registry.npmjs.org/@web/rollup-plugin-html/-/rollup-plugin-html-1.10.3.tgz",
            "integrity": "sha512-2RMIeKxpGtrcXiqPTgMVq5neGa5xa69MfNK860BHVMEO2N/MrHFuQNr1eNLsspcq2DL/xnymwC3w5hgjtlgxag==",
            "dev": true,
            "requires": {
                "@web/parse5-utils": "^1.3.0",
                "glob": "^7.1.6",
                "html-minifier-terser": "^6.0.0",
                "parse5": "^6.0.1"
            }
        },
        "@web/rollup-plugin-import-meta-assets": {
            "version": "1.0.7",
            "resolved": "https://registry.npmjs.org/@web/rollup-plugin-import-meta-assets/-/rollup-plugin-import-meta-assets-1.0.7.tgz",
            "integrity": "sha512-ft44CqITUkNd8stwNb4ZOvrZ8DlPifM821jplksmxRGetg5Lx684oFrpfQJ7mfkU/Sa7B3dI1mHTX0DE52eBwg==",
            "dev": true,
            "requires": {
                "@rollup/pluginutils": "^4.1.0",
                "estree-walker": "^2.0.2",
                "magic-string": "^0.25.7"
            }
        },
        "accepts": {
            "version": "1.3.8",
            "resolved": "https://registry.npmjs.org/accepts/-/accepts-1.3.8.tgz",
            "integrity": "sha512-PYAthTa2m2VKxuvSD3DPC/Gy+U+sOA1LAuT8mkmRuvw+NACSaeXEQ+NHcVF7rONl6qcaxV3Uuemwawk+7+SJLw==",
            "dev": true,
            "requires": {
                "mime-types": "~2.1.34",
                "negotiator": "0.6.3"
            }
        },
        "acorn": {
            "version": "8.7.0",
            "resolved": "https://registry.npmjs.org/acorn/-/acorn-8.7.0.tgz",
            "integrity": "sha512-V/LGr1APy+PXIwKebEWrkZPwoeoF+w1jiOBUmuxuiUIaOHtob8Qc9BTrYo7VuI5fR8tqsy+buA2WFooR5olqvQ==",
            "dev": true
        },
        "agent-base": {
            "version": "6.0.2",
            "resolved": "https://registry.npmjs.org/agent-base/-/agent-base-6.0.2.tgz",
            "integrity": "sha512-RZNwNclF7+MS/8bDg70amg32dyeZGZxiDuQmZxKLAlQjr3jGyLx+4Kkk58UO7D2QdgFIQCovuSuZESne6RG6XQ==",
            "dev": true,
            "requires": {
                "debug": "4"
            }
        },
        "agentkeepalive": {
            "version": "4.2.1",
            "resolved": "https://registry.npmjs.org/agentkeepalive/-/agentkeepalive-4.2.1.tgz",
            "integrity": "sha512-Zn4cw2NEqd+9fiSVWMscnjyQ1a8Yfoc5oBajLeo5w+YBHgDUcEBY2hS4YpTz6iN5f/2zQiktcuM6tS8x1p9dpA==",
            "dev": true,
            "requires": {
                "debug": "^4.1.0",
                "depd": "^1.1.2",
                "humanize-ms": "^1.2.1"
            },
            "dependencies": {
                "depd": {
                    "version": "1.1.2",
                    "resolved": "https://registry.npmjs.org/depd/-/depd-1.1.2.tgz",
                    "integrity": "sha1-m81S4UwJd2PnSbJ0xDRu0uVgtak=",
                    "dev": true
                }
            }
        },
        "aggregate-error": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/aggregate-error/-/aggregate-error-3.1.0.tgz",
            "integrity": "sha512-4I7Td01quW/RpocfNayFdFVk1qSuoh0E7JrbRJ16nH01HhKFQ88INq9Sd+nd72zqRySlr9BmDA8xlEJ6vJMrYA==",
            "dev": true,
            "requires": {
                "clean-stack": "^2.0.0",
                "indent-string": "^4.0.0"
            }
        },
        "ansi-colors": {
            "version": "4.1.1",
            "resolved": "https://registry.npmjs.org/ansi-colors/-/ansi-colors-4.1.1.tgz",
            "integrity": "sha512-JoX0apGbHaUJBNl6yF+p6JAFYZ666/hhCGKN5t9QFjbJQKUU/g8MNbFDbvfrgKXvI1QpZplPOnwIo99lX/AAmA==",
            "dev": true
        },
        "ansi-regex": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/ansi-regex/-/ansi-regex-5.0.1.tgz",
            "integrity": "sha512-quJQXlTSUGL2LH9SUXo8VwsY4soanhgo6LNSm84E1LBcE8s3O0wpdiRzyR9z/ZZJMlMWv37qOOb9pdJlMUEKFQ==",
            "dev": true
        },
        "ansi-styles": {
            "version": "4.3.0",
            "resolved": "https://registry.npmjs.org/ansi-styles/-/ansi-styles-4.3.0.tgz",
            "integrity": "sha512-zbB9rCJAT1rbjiVDb2hqKFHNYLxgtk8NURxZ3IZwD3F6NtxbXZQCnnSi1Lkx+IDohdPlFp222wVALIheZJQSEg==",
            "dev": true,
            "requires": {
                "color-convert": "^2.0.1"
            }
        },
        "any-signal": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/any-signal/-/any-signal-3.0.1.tgz",
            "integrity": "sha512-xgZgJtKEa9YmDqXodIgl7Fl1C8yNXr8w6gXjqK3LW4GcEiYT+6AQfJSE/8SPsEpLLmcvbv8YU+qet94UewHxqg==",
            "dev": true
        },
        "anymatch": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/anymatch/-/anymatch-3.1.2.tgz",
            "integrity": "sha512-P43ePfOAIupkguHUycrc4qJ9kz8ZiuOUijaETwX7THt0Y/GNK7v0aa8rY816xWjZ7rJdA5XdMcpVFTKMq+RvWg==",
            "dev": true,
            "requires": {
                "normalize-path": "^3.0.0",
                "picomatch": "^2.0.4"
            }
        },
        "argparse": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/argparse/-/argparse-2.0.1.tgz",
            "integrity": "sha512-8+9WqebbFzpX9OR+Wa6O29asIogeRMzcGtAINdpMHHyAg10f05aSFVBbcEqGf/PXw1EjAZ+q2/bEBg3DvurK3Q==",
            "dev": true
        },
        "assertion-error": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/assertion-error/-/assertion-error-1.1.0.tgz",
            "integrity": "sha512-jgsaNduz+ndvGyFt3uSuWqvy4lCnIJiovtouQN5JZHOKCS2QuhEdbcQHFhVksz2N2U9hXJo8odG7ETyWlEeuDw==",
            "dev": true
        },
        "async": {
            "version": "2.6.4",
            "resolved": "https://registry.npmjs.org/async/-/async-2.6.4.tgz",
            "integrity": "sha512-mzo5dfJYwAn29PeiJ0zvwTo04zj8HDJj0Mn8TD7sno7q12prdbnasKJHhkm2c1LgrhlJ0teaea8860oxi51mGA==",
            "dev": true,
            "requires": {
                "lodash": "^4.17.14"
            }
        },
        "balanced-match": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/balanced-match/-/balanced-match-1.0.2.tgz",
            "integrity": "sha512-3oSeUO0TMV67hN1AmbXsK4yaqU7tjiHlbxRDZOpH0KW9+CeX4bRAaX0Anxt0tx2MrpRpWwQaPwIlISEJhYU5Pw==",
            "dev": true
        },
        "base64-js": {
            "version": "1.5.1",
            "resolved": "https://registry.npmjs.org/base64-js/-/base64-js-1.5.1.tgz",
            "integrity": "sha512-AKpaYlHn8t4SVbOHCy+b5+KKgvR4vrsD8vbvrbiQJps7fKDTkjkDry6ji0rUJjC0kzbNePLwzxq8iypo41qeWA==",
            "dev": true
        },
        "base64id": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/base64id/-/base64id-2.0.0.tgz",
            "integrity": "sha512-lGe34o6EHj9y3Kts9R4ZYs/Gr+6N7MCaMlIFA3F1R2O5/m7K06AxfSeO5530PEERE6/WyEg3lsuyw4GHlPZHog==",
            "dev": true
        },
        "basic-auth": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/basic-auth/-/basic-auth-2.0.1.tgz",
            "integrity": "sha512-NF+epuEdnUYVlGuhaxbbq+dvJttwLnGY+YixlXlME5KpQ5W3CnXA5cVTneY3SPbPDRkcjMbifrwmFYcClgOZeg==",
            "dev": true,
            "requires": {
                "safe-buffer": "5.1.2"
            }
        },
        "binary-extensions": {
            "version": "2.2.0",
            "resolved": "https://registry.npmjs.org/binary-extensions/-/binary-extensions-2.2.0.tgz",
            "integrity": "sha512-jDctJ/IVQbZoJykoeHbhXpOlNBqGNcwXJKJog42E5HDPUwQTSdjCHdihjj0DlnheQ7blbT6dHOafNAiS8ooQKA==",
            "dev": true
        },
        "blob-to-it": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/blob-to-it/-/blob-to-it-1.0.4.tgz",
            "integrity": "sha512-iCmk0W4NdbrWgRRuxOriU8aM5ijeVLI61Zulsmg/lUHNr7pYjoj+U77opLefNagevtrrbMt3JQ5Qip7ar178kA==",
            "dev": true,
            "requires": {
                "browser-readablestream-to-it": "^1.0.3"
            }
        },
        "blocking-elements": {
            "version": "0.1.1",
            "resolved": "https://registry.npmjs.org/blocking-elements/-/blocking-elements-0.1.1.tgz",
            "integrity": "sha512-/SLWbEzMoVIMZACCyhD/4Ya2M1PWP1qMKuiymowPcI+PdWDARqeARBjhj73kbUBCxEmTZCUu5TAqxtwUO9C1Ig=="
        },
        "body-parser": {
            "version": "1.20.0",
            "resolved": "https://registry.npmjs.org/body-parser/-/body-parser-1.20.0.tgz",
            "integrity": "sha512-DfJ+q6EPcGKZD1QWUjSpqp+Q7bDQTsQIF4zfUAtZ6qk+H/3/QRhg9CEp39ss+/T2vw0+HaidC0ecJj/DRLIaKg==",
            "dev": true,
            "requires": {
                "bytes": "3.1.2",
                "content-type": "~1.0.4",
                "debug": "2.6.9",
                "depd": "2.0.0",
                "destroy": "1.2.0",
                "http-errors": "2.0.0",
                "iconv-lite": "0.4.24",
                "on-finished": "2.4.1",
                "qs": "6.10.3",
                "raw-body": "2.5.1",
                "type-is": "~1.6.18",
                "unpipe": "1.0.0"
            },
            "dependencies": {
                "debug": {
                    "version": "2.6.9",
                    "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
                    "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
                    "dev": true,
                    "requires": {
                        "ms": "2.0.0"
                    }
                },
                "ms": {
                    "version": "2.0.0",
                    "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
                    "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
                    "dev": true
                }
            }
        },
        "brace-expansion": {
            "version": "1.1.11",
            "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.11.tgz",
            "integrity": "sha512-iCuPHDFgrHX7H2vEI/5xpz07zSHB00TpugqhmYtVmMO6518mCuRMoOYFldEBl0g187ufozdaHgWKcYFb61qGiA==",
            "dev": true,
            "requires": {
                "balanced-match": "^1.0.0",
                "concat-map": "0.0.1"
            }
        },
        "braces": {
            "version": "3.0.2",
            "resolved": "https://registry.npmjs.org/braces/-/braces-3.0.2.tgz",
            "integrity": "sha512-b8um+L1RzM3WDSzvhm6gIz1yfTbBt6YTlcEKAvsmqCZZFw46z626lVj9j1yEPW33H5H+lBQpZMP1k8l+78Ha0A==",
            "dev": true,
            "requires": {
                "fill-range": "^7.0.1"
            }
        },
        "browser-headers": {
            "version": "0.4.1",
            "resolved": "https://registry.npmjs.org/browser-headers/-/browser-headers-0.4.1.tgz",
            "integrity": "sha512-CA9hsySZVo9371qEHjHZtYxV2cFtVj5Wj/ZHi8ooEsrtm4vOnl9Y9HmyYWk9q+05d7K3rdoAE0j3MVEFVvtQtg==",
            "dev": true
        },
        "browser-readablestream-to-it": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/browser-readablestream-to-it/-/browser-readablestream-to-it-1.0.3.tgz",
            "integrity": "sha512-+12sHB+Br8HIh6VAMVEG5r3UXCyESIgDW7kzk3BjIXa43DVqVwL7GC5TW3jeh+72dtcH99pPVpw0X8i0jt+/kw==",
            "dev": true
        },
        "browser-stdout": {
            "version": "1.3.1",
            "resolved": "https://registry.npmjs.org/browser-stdout/-/browser-stdout-1.3.1.tgz",
            "integrity": "sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==",
            "dev": true
        },
        "browserslist": {
            "version": "4.20.3",
            "resolved": "https://registry.npmjs.org/browserslist/-/browserslist-4.20.3.tgz",
            "integrity": "sha512-NBhymBQl1zM0Y5dQT/O+xiLP9/rzOIQdKM/eMJBAq7yBgaB6krIYLGejrwVYnSHZdqjscB1SPuAjHwxjvN6Wdg==",
            "dev": true,
            "requires": {
                "caniuse-lite": "^1.0.30001332",
                "electron-to-chromium": "^1.4.118",
                "escalade": "^3.1.1",
                "node-releases": "^2.0.3",
                "picocolors": "^1.0.0"
            }
        },
        "buffer": {
            "version": "6.0.3",
            "resolved": "https://registry.npmjs.org/buffer/-/buffer-6.0.3.tgz",
            "integrity": "sha512-FTiCpNxtwiZZHEZbcbTIcZjERVICn9yq/pDFkTl95/AxzD1naBctN7YO68riM/gLSDY7sdrMby8hofADYuuqOA==",
            "dev": true,
            "requires": {
                "base64-js": "^1.3.1",
                "ieee754": "^1.2.1"
            }
        },
        "buffer-from": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/buffer-from/-/buffer-from-1.1.2.tgz",
            "integrity": "sha512-E+XQCRwSbaaiChtv6k6Dwgc+bx+Bs6vuKJHHl5kox/BaKbhiXzqQOwK4cO22yElGp2OCmjwVhT3HmxgyPGnJfQ==",
            "dev": true
        },
        "bytes": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/bytes/-/bytes-3.1.2.tgz",
            "integrity": "sha512-/Nf7TyzTx6S3yRJObOAV7956r8cr2+Oj8AC5dt8wSP3BQAoeX58NoHyCU8P8zGkNXStjTSi6fzO6F0pBdcYbEg==",
            "dev": true
        },
        "cacache": {
            "version": "15.3.0",
            "resolved": "https://registry.npmjs.org/cacache/-/cacache-15.3.0.tgz",
            "integrity": "sha512-VVdYzXEn+cnbXpFgWs5hTT7OScegHVmLhJIR8Ufqk3iFD6A6j5iSX1KuBTfNEv4tdJWE2PzA6IVFtcLC7fN9wQ==",
            "dev": true,
            "requires": {
                "@npmcli/fs": "^1.0.0",
                "@npmcli/move-file": "^1.0.1",
                "chownr": "^2.0.0",
                "fs-minipass": "^2.0.0",
                "glob": "^7.1.4",
                "infer-owner": "^1.0.4",
                "lru-cache": "^6.0.0",
                "minipass": "^3.1.1",
                "minipass-collect": "^1.0.2",
                "minipass-flush": "^1.0.5",
                "minipass-pipeline": "^1.2.2",
                "mkdirp": "^1.0.3",
                "p-map": "^4.0.0",
                "promise-inflight": "^1.0.1",
                "rimraf": "^3.0.2",
                "ssri": "^8.0.1",
                "tar": "^6.0.2",
                "unique-filename": "^1.1.1"
            }
        },
        "call-bind": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/call-bind/-/call-bind-1.0.2.tgz",
            "integrity": "sha512-7O+FbCihrB5WGbFYesctwmTKae6rOiIzmz1icreWJ+0aA7LJfuqhEso2T9ncpcFtzMQtzXf2QGGueWJGTYsqrA==",
            "dev": true,
            "requires": {
                "function-bind": "^1.1.1",
                "get-intrinsic": "^1.0.2"
            }
        },
        "camel-case": {
            "version": "4.1.2",
            "resolved": "https://registry.npmjs.org/camel-case/-/camel-case-4.1.2.tgz",
            "integrity": "sha512-gxGWBrTT1JuMx6R+o5PTXMmUnhnVzLQ9SNutD4YqKtI6ap897t3tKECYla6gCWEkplXnlNybEkZg9GEGxKFCgw==",
            "dev": true,
            "requires": {
                "pascal-case": "^3.1.2",
                "tslib": "^2.0.3"
            }
        },
        "camelcase": {
            "version": "6.3.0",
            "resolved": "https://registry.npmjs.org/camelcase/-/camelcase-6.3.0.tgz",
            "integrity": "sha512-Gmy6FhYlCY7uOElZUSbxo2UCDH8owEk996gkbrpsgGtrJLM3J7jGxl9Ic7Qwwj4ivOE5AWZWRMecDdF7hqGjFA==",
            "dev": true
        },
        "caniuse-lite": {
            "version": "1.0.30001332",
            "resolved": "https://registry.npmjs.org/caniuse-lite/-/caniuse-lite-1.0.30001332.tgz",
            "integrity": "sha512-10T30NYOEQtN6C11YGg411yebhvpnC6Z102+B95eAsN0oB6KUs01ivE8u+G6FMIRtIrVlYXhL+LUwQ3/hXwDWw==",
            "dev": true
        },
        "capital-case": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/capital-case/-/capital-case-1.0.4.tgz",
            "integrity": "sha512-ds37W8CytHgwnhGGTi88pcPyR15qoNkOpYwmMMfnWqqWgESapLqvDx6huFjQ5vqWSn2Z06173XNA7LtMOeUh1A==",
            "dev": true,
            "requires": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3",
                "upper-case-first": "^2.0.2"
            }
        },
        "cborg": {
            "version": "1.9.1",
            "resolved": "https://registry.npmjs.org/cborg/-/cborg-1.9.1.tgz",
            "integrity": "sha512-6xKRdJ89ncwEXJGx9rFMRBNp72UqgYSGt2a88rqsvCLda4OuhRlh3xD2nu+ufrw6h9l94K0cnvyD4WEGpKtRtw==",
            "dev": true
        },
        "chai": {
            "version": "4.3.6",
            "resolved": "https://registry.npmjs.org/chai/-/chai-4.3.6.tgz",
            "integrity": "sha512-bbcp3YfHCUzMOvKqsztczerVgBKSsEijCySNlHHbX3VG1nskvqjz5Rfso1gGwD6w6oOV3eI60pKuMOV5MV7p3Q==",
            "dev": true,
            "requires": {
                "assertion-error": "^1.1.0",
                "check-error": "^1.0.2",
                "deep-eql": "^3.0.1",
                "get-func-name": "^2.0.0",
                "loupe": "^2.3.1",
                "pathval": "^1.1.1",
                "type-detect": "^4.0.5"
            }
        },
        "chalk": {
            "version": "4.1.2",
            "resolved": "https://registry.npmjs.org/chalk/-/chalk-4.1.2.tgz",
            "integrity": "sha512-oKnbhFyRIXpUuez8iBMmyEa4nbj4IOQyuhc/wy9kY7/WVPcwIO9VA668Pu8RkO7+0G76SLROeyw9CpQ061i4mA==",
            "dev": true,
            "requires": {
                "ansi-styles": "^4.1.0",
                "supports-color": "^7.1.0"
            }
        },
        "change-case": {
            "version": "4.1.2",
            "resolved": "https://registry.npmjs.org/change-case/-/change-case-4.1.2.tgz",
            "integrity": "sha512-bSxY2ws9OtviILG1EiY5K7NNxkqg/JnRnFxLtKQ96JaviiIxi7djMrSd0ECT9AC+lttClmYwKw53BWpOMblo7A==",
            "dev": true,
            "requires": {
                "camel-case": "^4.1.2",
                "capital-case": "^1.0.4",
                "constant-case": "^3.0.4",
                "dot-case": "^3.0.4",
                "header-case": "^2.0.4",
                "no-case": "^3.0.4",
                "param-case": "^3.0.4",
                "pascal-case": "^3.1.2",
                "path-case": "^3.0.4",
                "sentence-case": "^3.0.4",
                "snake-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "check-error": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/check-error/-/check-error-1.0.2.tgz",
            "integrity": "sha1-V00xLt2Iu13YkS6Sht1sCu1KrII=",
            "dev": true
        },
        "chokidar": {
            "version": "3.5.3",
            "resolved": "https://registry.npmjs.org/chokidar/-/chokidar-3.5.3.tgz",
            "integrity": "sha512-Dr3sfKRP6oTcjf2JmUmFJfeVMvXBdegxB0iVQ5eb2V10uFJUCAS8OByZdVAyVb8xXNz3GjjTgj9kLWsZTqE6kw==",
            "dev": true,
            "requires": {
                "anymatch": "~3.1.2",
                "braces": "~3.0.2",
                "fsevents": "~2.3.2",
                "glob-parent": "~5.1.2",
                "is-binary-path": "~2.1.0",
                "is-glob": "~4.0.1",
                "normalize-path": "~3.0.0",
                "readdirp": "~3.6.0"
            }
        },
        "chownr": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/chownr/-/chownr-2.0.0.tgz",
            "integrity": "sha512-bIomtDF5KGpdogkLd9VspvFzk9KfpyyGlS8YFVZl7TGPBHL5snIOnxeshwVgPteQ9b4Eydl+pVbIyE1DcvCWgQ==",
            "dev": true
        },
        "clean-css": {
            "version": "5.3.0",
            "resolved": "https://registry.npmjs.org/clean-css/-/clean-css-5.3.0.tgz",
            "integrity": "sha512-YYuuxv4H/iNb1Z/5IbMRoxgrzjWGhOEFfd+groZ5dMCVkpENiMZmwspdrzBo9286JjM1gZJPAyL7ZIdzuvu2AQ==",
            "dev": true,
            "requires": {
                "source-map": "~0.6.0"
            }
        },
        "clean-stack": {
            "version": "2.2.0",
            "resolved": "https://registry.npmjs.org/clean-stack/-/clean-stack-2.2.0.tgz",
            "integrity": "sha512-4diC9HaTE+KRAMWhDhrGOECgWZxoevMc5TlkObMqNSsVU62PYzXZ/SMTjzyGAFF1YusgxGcSWTEXBhp0CPwQ1A==",
            "dev": true
        },
        "cliui": {
            "version": "7.0.4",
            "resolved": "https://registry.npmjs.org/cliui/-/cliui-7.0.4.tgz",
            "integrity": "sha512-OcRE68cOsVMXp1Yvonl/fzkQOyjLSu/8bhPDfQt0e0/Eb283TKP20Fs2MqoPsr9SwA595rRCA+QMzYc9nBP+JQ==",
            "dev": true,
            "requires": {
                "string-width": "^4.2.0",
                "strip-ansi": "^6.0.0",
                "wrap-ansi": "^7.0.0"
            }
        },
        "color-convert": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/color-convert/-/color-convert-2.0.1.tgz",
            "integrity": "sha512-RRECPsj7iu/xb5oKYcsFHSppFNnsj/52OVTRKb4zP5onXwVF3zVmmToNcOfGC+CRDpfK/U584fMg38ZHCaElKQ==",
            "dev": true,
            "requires": {
                "color-name": "~1.1.4"
            }
        },
        "color-name": {
            "version": "1.1.4",
            "resolved": "https://registry.npmjs.org/color-name/-/color-name-1.1.4.tgz",
            "integrity": "sha512-dOy+3AuW3a2wNbZHIuMZpTcgjGuLU/uBL/ubcZF9OXbDo8ff4O8yVp5Bf0efS8uEoYo5q4Fx7dY9OgQGXgAsQA==",
            "dev": true
        },
        "commander": {
            "version": "2.20.3",
            "resolved": "https://registry.npmjs.org/commander/-/commander-2.20.3.tgz",
            "integrity": "sha512-GpVkmM8vF2vQUkj2LvZmD35JxeJOLCwJ9cUkugyk2nuhbv3+mJvpLYYt+0+USMxE+oj+ey/lJEnhZw75x/OMcQ==",
            "dev": true
        },
        "component-emitter": {
            "version": "1.3.0",
            "resolved": "https://registry.npmjs.org/component-emitter/-/component-emitter-1.3.0.tgz",
            "integrity": "sha512-Rd3se6QB+sO1TwqZjscQrurpEPIfO0/yYnSin6Q/rD3mOutHvUrCAhJub3r90uNb+SESBuE0QYoB90YdfatsRg==",
            "dev": true
        },
        "concat-map": {
            "version": "0.0.1",
            "resolved": "https://registry.npmjs.org/concat-map/-/concat-map-0.0.1.tgz",
            "integrity": "sha1-2Klr13/Wjfd5OnMDajug1UBdR3s=",
            "dev": true
        },
        "connect": {
            "version": "3.7.0",
            "resolved": "https://registry.npmjs.org/connect/-/connect-3.7.0.tgz",
            "integrity": "sha512-ZqRXc+tZukToSNmh5C2iWMSoV3X1YUcPbqEM4DkEG5tNQXrQUZCNVGGv3IuicnkMtPfGf3Xtp8WCXs295iQ1pQ==",
            "dev": true,
            "requires": {
                "debug": "2.6.9",
                "finalhandler": "1.1.2",
                "parseurl": "~1.3.3",
                "utils-merge": "1.0.1"
            },
            "dependencies": {
                "debug": {
                    "version": "2.6.9",
                    "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
                    "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
                    "dev": true,
                    "requires": {
                        "ms": "2.0.0"
                    }
                },
                "ms": {
                    "version": "2.0.0",
                    "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
                    "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
                    "dev": true
                }
            }
        },
        "constant-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/constant-case/-/constant-case-3.0.4.tgz",
            "integrity": "sha512-I2hSBi7Vvs7BEuJDr5dDHfzb/Ruj3FyvFyh7KLilAjNQw3Be+xgqUBA2W6scVEcL0hL1dwPRtIqEPVUCKkSsyQ==",
            "dev": true,
            "requires": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3",
                "upper-case": "^2.0.2"
            }
        },
        "content-type": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/content-type/-/content-type-1.0.4.tgz",
            "integrity": "sha512-hIP3EEPs8tB9AT1L+NUqtwOAps4mk2Zob89MWXMHjHWg9milF/j4osnnQLXBCBFBk/tvIG/tUc9mOUJiPBhPXA==",
            "dev": true
        },
        "convert-source-map": {
            "version": "1.8.0",
            "resolved": "https://registry.npmjs.org/convert-source-map/-/convert-source-map-1.8.0.tgz",
            "integrity": "sha512-+OQdjP49zViI/6i7nIJpA8rAl4sV/JdPfU9nZs3VqOwGIgizICvuN2ru6fMd+4llL0tar18UYJXfZ/TWtmhUjA==",
            "dev": true,
            "requires": {
                "safe-buffer": "~5.1.1"
            }
        },
        "cookie": {
            "version": "0.4.2",
            "resolved": "https://registry.npmjs.org/cookie/-/cookie-0.4.2.tgz",
            "integrity": "sha512-aSWTXFzaKWkvHO1Ny/s+ePFpvKsPnjc551iI41v3ny/ow6tBG5Vd+FuqGNhh1LxOmVzOlGUriIlOaokOvhaStA==",
            "dev": true
        },
        "cors": {
            "version": "2.8.5",
            "resolved": "https://registry.npmjs.org/cors/-/cors-2.8.5.tgz",
            "integrity": "sha512-KIHbLJqu73RGr/hnbrO9uBeixNGuvSQjul/jdFvS/KFSIH1hWVd1ng7zOHx+YrEfInLG7q4n6GHQ9cDtxv/P6g==",
            "dev": true,
            "requires": {
                "object-assign": "^4",
                "vary": "^1"
            }
        },
        "corser": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/corser/-/corser-2.0.1.tgz",
            "integrity": "sha1-jtolLsqrWEDc2XXOuQ2TcMgZ/4c=",
            "dev": true
        },
        "crelt": {
            "version": "1.0.5",
            "resolved": "https://registry.npmjs.org/crelt/-/crelt-1.0.5.tgz",
            "integrity": "sha512-+BO9wPPi+DWTDcNYhr/W90myha8ptzftZT+LwcmUbbok0rcP/fequmFYCw8NMoH7pkAZQzU78b3kYrlua5a9eA=="
        },
        "custom-event": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/custom-event/-/custom-event-1.0.1.tgz",
            "integrity": "sha1-XQKkaFCt8bSjF5RqOSj8y1v9BCU=",
            "dev": true
        },
        "dag-jose": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/dag-jose/-/dag-jose-1.0.0.tgz",
            "integrity": "sha512-U0b/YsIPBp6YZNTFrVjwLZAlY3qGRxZTIEcM/CcQmrVrCWq9MWQq9pheXVSPLIhF4SNwzp2SikPva4/BIrJY+g==",
            "dev": true,
            "requires": {
                "@ipld/dag-cbor": "^6.0.3",
                "multiformats": "^9.0.2"
            },
            "dependencies": {
                "@ipld/dag-cbor": {
                    "version": "6.0.15",
                    "resolved": "https://registry.npmjs.org/@ipld/dag-cbor/-/dag-cbor-6.0.15.tgz",
                    "integrity": "sha512-Vm3VTSTwlmGV92a3C5aeY+r2A18zbH2amehNhsX8PBa3muXICaWrN8Uri85A5hLH7D7ElhE8PdjxD6kNqUmTZA==",
                    "dev": true,
                    "requires": {
                        "cborg": "^1.5.4",
                        "multiformats": "^9.5.4"
                    }
                }
            }
        },
        "date-format": {
            "version": "4.0.9",
            "resolved": "https://registry.npmjs.org/date-format/-/date-format-4.0.9.tgz",
            "integrity": "sha512-+8J+BOUpSrlKLQLeF8xJJVTxS8QfRSuJgwxSVvslzgO3E6khbI0F5mMEPf5mTYhCCm4h99knYP6H3W9n3BQFrg==",
            "dev": true
        },
        "debug": {
            "version": "4.3.4",
            "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.4.tgz",
            "integrity": "sha512-PRWFHuSU3eDtQJPvnNY7Jcket1j0t5OuOsFzPPzsekD52Zl8qUfFIPEiswXqIvHWGVHOgX+7G/vCNNhehwxfkQ==",
            "dev": true,
            "requires": {
                "ms": "2.1.2"
            },
            "dependencies": {
                "ms": {
                    "version": "2.1.2",
                    "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
                    "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
                    "dev": true
                }
            }
        },
        "decamelize": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/decamelize/-/decamelize-4.0.0.tgz",
            "integrity": "sha512-9iE1PgSik9HeIIw2JO94IidnE3eBoQrFJ3w7sFuzSX4DpmZ3v5sZpUiV5Swcf6mQEF+Y0ru8Neo+p+nyh2J+hQ==",
            "dev": true
        },
        "deep-eql": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/deep-eql/-/deep-eql-3.0.1.tgz",
            "integrity": "sha512-+QeIQyN5ZuO+3Uk5DYh6/1eKO0m0YmJFGNmFHGACpf1ClL1nmlV/p4gNgbl2pJGxgXb4faqo6UE+M5ACEMyVcw==",
            "dev": true,
            "requires": {
                "type-detect": "^4.0.0"
            }
        },
        "depd": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/depd/-/depd-2.0.0.tgz",
            "integrity": "sha512-g7nH6P6dyDioJogAAGprGpCtVImJhpPk/roCzdb3fIh61/s/nPsfR6onyMwkCAR/OlC3yBC0lESvUoQEAssIrw==",
            "dev": true
        },
        "destroy": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/destroy/-/destroy-1.2.0.tgz",
            "integrity": "sha512-2sJGJTaXIIaR1w4iJSNoN0hnMY7Gpc/n8D4qSCJw8QqFWXf7cuAgnEHxBpweaVcPevC2l3KpjYCx3NypQQgaJg==",
            "dev": true
        },
        "di": {
            "version": "0.0.1",
            "resolved": "https://registry.npmjs.org/di/-/di-0.0.1.tgz",
            "integrity": "sha1-gGZJMmzqp8qjMG112YXqJ0i6kTw=",
            "dev": true
        },
        "diff": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/diff/-/diff-5.0.0.tgz",
            "integrity": "sha512-/VTCrvm5Z0JGty/BWHljh+BAiw3IK+2j87NGMu8Nwc/f48WoDAC395uomO9ZD117ZOBaHmkX1oyLvkVM/aIT3w==",
            "dev": true
        },
        "dns-over-http-resolver": {
            "version": "1.2.3",
            "resolved": "https://registry.npmjs.org/dns-over-http-resolver/-/dns-over-http-resolver-1.2.3.tgz",
            "integrity": "sha512-miDiVSI6KSNbi4SVifzO/reD8rMnxgrlnkrlkugOLQpWQTe2qMdHsZp5DmfKjxNE+/T3VAAYLQUZMv9SMr6+AA==",
            "dev": true,
            "requires": {
                "debug": "^4.3.1",
                "native-fetch": "^3.0.0",
                "receptacle": "^1.3.2"
            }
        },
        "dom-serialize": {
            "version": "2.2.1",
            "resolved": "https://registry.npmjs.org/dom-serialize/-/dom-serialize-2.2.1.tgz",
            "integrity": "sha1-ViromZ9Evl6jB29UGdzVnrQ6yVs=",
            "dev": true,
            "requires": {
                "custom-event": "~1.0.0",
                "ent": "~2.2.0",
                "extend": "^3.0.0",
                "void-elements": "^2.0.0"
            }
        },
        "dot-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/dot-case/-/dot-case-3.0.4.tgz",
            "integrity": "sha512-Kv5nKlh6yRrdrGvxeJ2e5y2eRUpkUosIW4A2AS38zwSz27zu7ufDwQPi5Jhs3XAlGNetl3bmnGhQsMtkKJnj3w==",
            "dev": true,
            "requires": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "ee-first": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/ee-first/-/ee-first-1.1.1.tgz",
            "integrity": "sha1-WQxhFWsK4vTwJVcyoViyZrxWsh0=",
            "dev": true
        },
        "electron-fetch": {
            "version": "1.7.4",
            "resolved": "https://registry.npmjs.org/electron-fetch/-/electron-fetch-1.7.4.tgz",
            "integrity": "sha512-+fBLXEy4CJWQ5bz8dyaeSG1hD6JJ15kBZyj3eh24pIVrd3hLM47H/umffrdQfS6GZ0falF0g9JT9f3Rs6AVUhw==",
            "dev": true,
            "requires": {
                "encoding": "^0.1.13"
            }
        },
        "electron-to-chromium": {
            "version": "1.4.119",
            "resolved": "https://registry.npmjs.org/electron-to-chromium/-/electron-to-chromium-1.4.119.tgz",
            "integrity": "sha512-HPEmKy+d0xK8oCfEHc5t6wDsSAi1WmE3Ld08QrBjAPxaAzfuKP66VJ77lcTqxTt7GJmSE279s75mhW64Xh+4kw==",
            "dev": true
        },
        "emoji-regex": {
            "version": "8.0.0",
            "resolved": "https://registry.npmjs.org/emoji-regex/-/emoji-regex-8.0.0.tgz",
            "integrity": "sha512-MSjYzcWNOA0ewAHpz0MxpYFvwg6yjy1NG3xteoqz644VCo/RPgnr1/GGt+ic3iJTzQ8Eu3TdM14SawnVUmGE6A==",
            "dev": true
        },
        "encodeurl": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/encodeurl/-/encodeurl-1.0.2.tgz",
            "integrity": "sha1-rT/0yG7C0CkyL1oCw6mmBslbP1k=",
            "dev": true
        },
        "encoding": {
            "version": "0.1.13",
            "resolved": "https://registry.npmjs.org/encoding/-/encoding-0.1.13.tgz",
            "integrity": "sha512-ETBauow1T35Y/WZMkio9jiM0Z5xjHHmJ4XmjZOq1l/dXz3lr2sRn87nJy20RupqSh1F2m3HHPSp8ShIPQJrJ3A==",
            "dev": true,
            "requires": {
                "iconv-lite": "^0.6.2"
            },
            "dependencies": {
                "iconv-lite": {
                    "version": "0.6.3",
                    "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
                    "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
                    "dev": true,
                    "requires": {
                        "safer-buffer": ">= 2.1.2 < 3.0.0"
                    }
                }
            }
        },
        "engine.io": {
            "version": "6.2.0",
            "resolved": "https://registry.npmjs.org/engine.io/-/engine.io-6.2.0.tgz",
            "integrity": "sha512-4KzwW3F3bk+KlzSOY57fj/Jx6LyRQ1nbcyIadehl+AnXjKT7gDO0ORdRi/84ixvMKTym6ZKuxvbzN62HDDU1Lg==",
            "dev": true,
            "requires": {
                "@types/cookie": "^0.4.1",
                "@types/cors": "^2.8.12",
                "@types/node": ">=10.0.0",
                "accepts": "~1.3.4",
                "base64id": "2.0.0",
                "cookie": "~0.4.1",
                "cors": "~2.8.5",
                "debug": "~4.3.1",
                "engine.io-parser": "~5.0.3",
                "ws": "~8.2.3"
            },
            "dependencies": {
                "@types/node": {
                    "version": "17.0.29",
                    "resolved": "https://registry.npmjs.org/@types/node/-/node-17.0.29.tgz",
                    "integrity": "sha512-tx5jMmMFwx7wBwq/V7OohKDVb/JwJU5qCVkeLMh1//xycAJ/ESuw9aJ9SEtlCZDYi2pBfe4JkisSoAtbOsBNAA==",
                    "dev": true
                },
                "ws": {
                    "version": "8.2.3",
                    "resolved": "https://registry.npmjs.org/ws/-/ws-8.2.3.tgz",
                    "integrity": "sha512-wBuoj1BDpC6ZQ1B7DWQBYVLphPWkm8i9Y0/3YdHjHKHiohOJ1ws+3OccDWtH+PoC9DZD5WOTrJvNbWvjS6JWaA==",
                    "dev": true,
                    "requires": {}
                }
            }
        },
        "engine.io-parser": {
            "version": "5.0.3",
            "resolved": "https://registry.npmjs.org/engine.io-parser/-/engine.io-parser-5.0.3.tgz",
            "integrity": "sha512-BtQxwF27XUNnSafQLvDi0dQ8s3i6VgzSoQMJacpIcGNrlUdfHSKbgm3jmjCVvQluGzqwujQMPAoMai3oYSTurg==",
            "dev": true,
            "requires": {
                "@socket.io/base64-arraybuffer": "~1.0.2"
            }
        },
        "ent": {
            "version": "2.2.0",
            "resolved": "https://registry.npmjs.org/ent/-/ent-2.2.0.tgz",
            "integrity": "sha1-6WQhkyWiHQX0RGai9obtbOX13R0=",
            "dev": true
        },
        "err-code": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/err-code/-/err-code-3.0.1.tgz",
            "integrity": "sha512-GiaH0KJUewYok+eeY05IIgjtAe4Yltygk9Wqp1V5yVWLdhf0hYZchRjNIT9bb0mSwRcIusT3cx7PJUf3zEIfUA==",
            "dev": true
        },
        "es-module-lexer": {
            "version": "0.10.5",
            "resolved": "https://registry.npmjs.org/es-module-lexer/-/es-module-lexer-0.10.5.tgz",
            "integrity": "sha512-+7IwY/kiGAacQfY+YBhKMvEmyAJnw5grTUgjG85Pe7vcUI/6b7pZjZG8nQ7+48YhzEAEqrEgD2dCz/JIK+AYvw==",
            "dev": true
        },
        "escalade": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/escalade/-/escalade-3.1.1.tgz",
            "integrity": "sha512-k0er2gUkLf8O0zKJiAhmkTnJlTvINGv7ygDNPbeIsX/TJjGJZHuh9B2UxbsaEkmlEo9MfhrSzmhIlhRlI2GXnw==",
            "dev": true
        },
        "escape-html": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/escape-html/-/escape-html-1.0.3.tgz",
            "integrity": "sha1-Aljq5NPQwJdN4cFpGI7wBR0dGYg=",
            "dev": true
        },
        "escape-string-regexp": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/escape-string-regexp/-/escape-string-regexp-4.0.0.tgz",
            "integrity": "sha512-TtpcNJ3XAzx3Gq8sWRzJaVajRs0uVxA2YAkdb1jm2YkPz4G6egUFAyA3n5vtEIZefPk5Wa4UXbKuS5fKkJWdgA==",
            "dev": true
        },
        "estree-walker": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/estree-walker/-/estree-walker-2.0.2.tgz",
            "integrity": "sha512-Rfkk/Mp/DL7JVje3u18FxFujQlTNR2q6QfMSMB7AvCBx91NGj/ba3kCfza0f6dVDbw7YlRf/nDrn7pQrCCyQ/w==",
            "dev": true
        },
        "eventemitter3": {
            "version": "4.0.7",
            "resolved": "https://registry.npmjs.org/eventemitter3/-/eventemitter3-4.0.7.tgz",
            "integrity": "sha512-8guHBZCwKnFhYdHr2ysuRWErTwhoN2X8XELRlrRwpmfeY2jjuUN4taQMsULKUVo1K4DvZl+0pgfyoysHxvmvEw==",
            "dev": true
        },
        "extend": {
            "version": "3.0.2",
            "resolved": "https://registry.npmjs.org/extend/-/extend-3.0.2.tgz",
            "integrity": "sha512-fjquC59cD7CyW6urNXK0FBufkZcoiGG80wTuPujX590cB5Ttln20E2UB4S/WARVqhXffZl2LNgS+gQdPIIim/g==",
            "dev": true
        },
        "fast-fifo": {
            "version": "1.1.0",
            "resolved": "https://registry.npmjs.org/fast-fifo/-/fast-fifo-1.1.0.tgz",
            "integrity": "sha512-Kl29QoNbNvn4nhDsLYjyIAaIqaJB6rBx5p3sL9VjaefJ+eMFBWVZiaoguaoZfzEKr5RhAti0UgM8703akGPJ6g==",
            "dev": true
        },
        "fill-range": {
            "version": "7.0.1",
            "resolved": "https://registry.npmjs.org/fill-range/-/fill-range-7.0.1.tgz",
            "integrity": "sha512-qOo9F+dMUmC2Lcb4BbVvnKJxTPjCm+RRpe4gDuGrzkL7mEVl/djYSu2OdQ2Pa302N4oqkSg9ir6jaLWJ2USVpQ==",
            "dev": true,
            "requires": {
                "to-regex-range": "^5.0.1"
            }
        },
        "finalhandler": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/finalhandler/-/finalhandler-1.1.2.tgz",
            "integrity": "sha512-aAWcW57uxVNrQZqFXjITpW3sIUQmHGG3qSb9mUah9MgMC4NeWhNOlNjXEYq3HjRAvL6arUviZGGJsBg6z0zsWA==",
            "dev": true,
            "requires": {
                "debug": "2.6.9",
                "encodeurl": "~1.0.2",
                "escape-html": "~1.0.3",
                "on-finished": "~2.3.0",
                "parseurl": "~1.3.3",
                "statuses": "~1.5.0",
                "unpipe": "~1.0.0"
            },
            "dependencies": {
                "debug": {
                    "version": "2.6.9",
                    "resolved": "https://registry.npmjs.org/debug/-/debug-2.6.9.tgz",
                    "integrity": "sha512-bC7ElrdJaJnPbAP+1EotYvqZsb3ecl5wi6Bfi6BJTUcNowp6cvspg0jXznRTKDjm/E7AdgFBVeAPVMNcKGsHMA==",
                    "dev": true,
                    "requires": {
                        "ms": "2.0.0"
                    }
                },
                "ms": {
                    "version": "2.0.0",
                    "resolved": "https://registry.npmjs.org/ms/-/ms-2.0.0.tgz",
                    "integrity": "sha1-VgiurfwAvmwpAd9fmGF4jeDVl8g=",
                    "dev": true
                },
                "on-finished": {
                    "version": "2.3.0",
                    "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.3.0.tgz",
                    "integrity": "sha1-IPEzZIGwg811M3mSoWlxqi2QaUc=",
                    "dev": true,
                    "requires": {
                        "ee-first": "1.1.1"
                    }
                },
                "statuses": {
                    "version": "1.5.0",
                    "resolved": "https://registry.npmjs.org/statuses/-/statuses-1.5.0.tgz",
                    "integrity": "sha1-Fhx9rBd2Wf2YEfQ3cfqZOBR4Yow=",
                    "dev": true
                }
            }
        },
        "find-up": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/find-up/-/find-up-5.0.0.tgz",
            "integrity": "sha512-78/PXT1wlLLDgTzDs7sjq9hzz0vXD+zn+7wypEe4fXQxCmdmqfGsEPQxmiCSQI3ajFV91bVSsvNtrJRiW6nGng==",
            "dev": true,
            "requires": {
                "locate-path": "^6.0.0",
                "path-exists": "^4.0.0"
            }
        },
        "flat": {
            "version": "5.0.2",
            "resolved": "https://registry.npmjs.org/flat/-/flat-5.0.2.tgz",
            "integrity": "sha512-b6suED+5/3rTpUBdG1gupIl8MPFCAMA0QXwmljLhvCUKcUvdE4gWky9zpuGCcXHOsz4J9wPGNWq6OKpmIzz3hQ==",
            "dev": true
        },
        "flatted": {
            "version": "3.2.5",
            "resolved": "https://registry.npmjs.org/flatted/-/flatted-3.2.5.tgz",
            "integrity": "sha512-WIWGi2L3DyTUvUrwRKgGi9TwxQMUEqPOPQBVi71R96jZXJdFskXEmf54BoZaS1kknGODoIGASGEzBUYdyMCBJg==",
            "dev": true
        },
        "follow-redirects": {
            "version": "1.14.9",
            "resolved": "https://registry.npmjs.org/follow-redirects/-/follow-redirects-1.14.9.tgz",
            "integrity": "sha512-MQDfihBQYMcyy5dhRDJUHcw7lb2Pv/TuE6xP1vyraLukNDHKbDxDNaOE3NbCAdKQApno+GPRyo1YAp89yCjK4w==",
            "dev": true
        },
        "fs-extra": {
            "version": "10.1.0",
            "resolved": "https://registry.npmjs.org/fs-extra/-/fs-extra-10.1.0.tgz",
            "integrity": "sha512-oRXApq54ETRj4eMiFzGnHWGy+zo5raudjuxN0b8H7s/RU2oW0Wvsx9O0ACRN/kRq9E8Vu/ReskGB5o3ji+FzHQ==",
            "dev": true,
            "requires": {
                "graceful-fs": "^4.2.0",
                "jsonfile": "^6.0.1",
                "universalify": "^2.0.0"
            }
        },
        "fs-minipass": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/fs-minipass/-/fs-minipass-2.1.0.tgz",
            "integrity": "sha512-V/JgOLFCS+R6Vcq0slCuaeWEdNC3ouDlJMNIsacH2VtALiu9mV4LPrHc5cDl8k5aw6J8jwgWWpiTo5RYhmIzvg==",
            "dev": true,
            "requires": {
                "minipass": "^3.0.0"
            }
        },
        "fs.realpath": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/fs.realpath/-/fs.realpath-1.0.0.tgz",
            "integrity": "sha1-FQStJSMVjKpA20onh8sBQRmU6k8=",
            "dev": true
        },
        "fsevents": {
            "version": "2.3.2",
            "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
            "integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
            "dev": true,
            "optional": true
        },
        "function-bind": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/function-bind/-/function-bind-1.1.1.tgz",
            "integrity": "sha512-yIovAzMX49sF8Yl58fSCWJ5svSLuaibPxXQJFLmBObTuCr0Mf1KiPopGM9NiFjiYBCbfaa2Fh6breQ6ANVTI0A==",
            "dev": true
        },
        "gensync": {
            "version": "1.0.0-beta.2",
            "resolved": "https://registry.npmjs.org/gensync/-/gensync-1.0.0-beta.2.tgz",
            "integrity": "sha512-3hN7NaskYvMDLQY55gnW3NQ+mesEAepTqlg+VEbj7zzqEMBVNhzcGYYeqFo/TlYz6eQiFcp1HcsCZO+nGgS8zg==",
            "dev": true
        },
        "get-caller-file": {
            "version": "2.0.5",
            "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
            "integrity": "sha512-DyFP3BM/3YHTQOCUL/w0OZHR0lpKeGrxotcHWcqNEdnltqFwXVfhEBQ94eIo34AfQpo0rGki4cyIiftY06h2Fg==",
            "dev": true
        },
        "get-func-name": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/get-func-name/-/get-func-name-2.0.0.tgz",
            "integrity": "sha1-6td0q+5y4gQJQzoGY2YCPdaIekE=",
            "dev": true
        },
        "get-intrinsic": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/get-intrinsic/-/get-intrinsic-1.1.1.tgz",
            "integrity": "sha512-kWZrnVM42QCiEA2Ig1bG8zjoIMOgxWwYCEeNdwY6Tv/cOSeGpcoX4pXHfKUxNKVoArnrEr2e9srnAxxGIraS9Q==",
            "dev": true,
            "requires": {
                "function-bind": "^1.1.1",
                "has": "^1.0.3",
                "has-symbols": "^1.0.1"
            }
        },
        "get-iterator": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/get-iterator/-/get-iterator-1.0.2.tgz",
            "integrity": "sha512-v+dm9bNVfOYsY1OrhaCrmyOcYoSeVvbt+hHZ0Au+T+p1y+0Uyj9aMaGIeUTT6xdpRbWzDeYKvfOslPhggQMcsg==",
            "dev": true
        },
        "glob": {
            "version": "7.2.0",
            "resolved": "https://registry.npmjs.org/glob/-/glob-7.2.0.tgz",
            "integrity": "sha512-lmLf6gtyrPq8tTjSmrO94wBeQbFR3HbLHbuyD69wuyQkImp2hWqMGB47OX65FBkPffO641IP9jWa1z4ivqG26Q==",
            "dev": true,
            "requires": {
                "fs.realpath": "^1.0.0",
                "inflight": "^1.0.4",
                "inherits": "2",
                "minimatch": "^3.0.4",
                "once": "^1.3.0",
                "path-is-absolute": "^1.0.0"
            }
        },
        "glob-parent": {
            "version": "5.1.2",
            "resolved": "https://registry.npmjs.org/glob-parent/-/glob-parent-5.1.2.tgz",
            "integrity": "sha512-AOIgSQCepiJYwP3ARnGx+5VnTu2HBYdzbGP45eLw1vr3zB3vZLeyed1sC9hnbcOc9/SrMyM5RPQrkGz4aS9Zow==",
            "dev": true,
            "requires": {
                "is-glob": "^4.0.1"
            }
        },
        "globals": {
            "version": "11.12.0",
            "resolved": "https://registry.npmjs.org/globals/-/globals-11.12.0.tgz",
            "integrity": "sha512-WOBp/EEGUiIsJSp7wcv/y6MO+lV9UoncWqxuFfm8eBwzWNgyfBd6Gz+IeKQ9jCmyhoH99g15M3T+QaVHFjizVA==",
            "dev": true
        },
        "graceful-fs": {
            "version": "4.2.10",
            "resolved": "https://registry.npmjs.org/graceful-fs/-/graceful-fs-4.2.10.tgz",
            "integrity": "sha512-9ByhssR2fPVsNZj478qUUbKfmL0+t5BDVyjShtyZZLiK7ZDAArFFfopyOTj0M05wE2tJPisA4iTnnXl2YoPvOA==",
            "dev": true
        },
        "growl": {
            "version": "1.10.5",
            "resolved": "https://registry.npmjs.org/growl/-/growl-1.10.5.tgz",
            "integrity": "sha512-qBr4OuELkhPenW6goKVXiv47US3clb3/IbuWF9KNKEijAy9oeHxU9IgzjvJhHkUzhaj7rOUD7+YGWqUjLp5oSA==",
            "dev": true
        },
        "has": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/has/-/has-1.0.3.tgz",
            "integrity": "sha512-f2dvO0VU6Oej7RkWJGrehjbzMAjFp5/VKPp5tTpWIV4JHHZK1/BxbFRtf/siA2SWTe09caDmVtYYzWEIbBS4zw==",
            "dev": true,
            "requires": {
                "function-bind": "^1.1.1"
            }
        },
        "has-flag": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/has-flag/-/has-flag-4.0.0.tgz",
            "integrity": "sha512-EykJT/Q1KjTWctppgIAgfSO0tKVuZUjhgMr17kqTumMl6Afv3EISleU7qZUzoXDFTAHTDC4NOoG/ZxU3EvlMPQ==",
            "dev": true
        },
        "has-symbols": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/has-symbols/-/has-symbols-1.0.3.tgz",
            "integrity": "sha512-l3LCuF6MgDNwTDKkdYGEihYjt5pRPbEg46rtlmnSPlUbgmB8LOIrKJbYYFBSbnPaJexMKtiPO8hmeRjRz2Td+A==",
            "dev": true
        },
        "he": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/he/-/he-1.2.0.tgz",
            "integrity": "sha512-F/1DnUGPopORZi0ni+CvrCgHQ5FyEAHRLSApuYWMmrbSwoN2Mn/7k+Gl38gJnR7yyDZk6WLXwiGod1JOWNDKGw==",
            "dev": true
        },
        "header-case": {
            "version": "2.0.4",
            "resolved": "https://registry.npmjs.org/header-case/-/header-case-2.0.4.tgz",
            "integrity": "sha512-H/vuk5TEEVZwrR0lp2zed9OCo1uAILMlx0JEMgC26rzyJJ3N1v6XkwHHXJQdR2doSjcGPM6OKPYoJgf0plJ11Q==",
            "dev": true,
            "requires": {
                "capital-case": "^1.0.4",
                "tslib": "^2.0.3"
            }
        },
        "html-encoding-sniffer": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/html-encoding-sniffer/-/html-encoding-sniffer-3.0.0.tgz",
            "integrity": "sha512-oWv4T4yJ52iKrufjnyZPkrN0CH3QnrUqdB6In1g5Fe1mia8GmF36gnfNySxoZtxD5+NmYw1EElVXiBk93UeskA==",
            "dev": true,
            "requires": {
                "whatwg-encoding": "^2.0.0"
            }
        },
        "html-minifier-terser": {
            "version": "6.1.0",
            "resolved": "https://registry.npmjs.org/html-minifier-terser/-/html-minifier-terser-6.1.0.tgz",
            "integrity": "sha512-YXxSlJBZTP7RS3tWnQw74ooKa6L9b9i9QYXY21eUEvhZ3u9XLfv6OnFsQq6RxkhHygsaUMvYsZRV5rU/OVNZxw==",
            "dev": true,
            "requires": {
                "camel-case": "^4.1.2",
                "clean-css": "^5.2.2",
                "commander": "^8.3.0",
                "he": "^1.2.0",
                "param-case": "^3.0.4",
                "relateurl": "^0.2.7",
                "terser": "^5.10.0"
            },
            "dependencies": {
                "commander": {
                    "version": "8.3.0",
                    "resolved": "https://registry.npmjs.org/commander/-/commander-8.3.0.tgz",
                    "integrity": "sha512-OkTL9umf+He2DZkUq8f8J9of7yL6RJKI24dVITBmNfZBmri9zYZQrKkuXiKhyfPSu8tUhnVBB1iKXevvnlR4Ww==",
                    "dev": true
                }
            }
        },
        "http-cache-semantics": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/http-cache-semantics/-/http-cache-semantics-4.1.0.tgz",
            "integrity": "sha512-carPklcUh7ROWRK7Cv27RPtdhYhUsela/ue5/jKzjegVvXDqM2ILE9Q2BGn9JZJh1g87cp56su/FgQSzcWS8cQ==",
            "dev": true
        },
        "http-errors": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/http-errors/-/http-errors-2.0.0.tgz",
            "integrity": "sha512-FtwrG/euBzaEjYeRqOgly7G0qviiXoJWnvEH2Z1plBdXgbyjv34pHTSb9zoeHMyDy33+DWy5Wt9Wo+TURtOYSQ==",
            "dev": true,
            "requires": {
                "depd": "2.0.0",
                "inherits": "2.0.4",
                "setprototypeof": "1.2.0",
                "statuses": "2.0.1",
                "toidentifier": "1.0.1"
            }
        },
        "http-proxy": {
            "version": "1.18.1",
            "resolved": "https://registry.npmjs.org/http-proxy/-/http-proxy-1.18.1.tgz",
            "integrity": "sha512-7mz/721AbnJwIVbnaSv1Cz3Am0ZLT/UBwkC92VlxhXv/k/BBQfM2fXElQNC27BVGr0uwUpplYPQM9LnaBMR5NQ==",
            "dev": true,
            "requires": {
                "eventemitter3": "^4.0.0",
                "follow-redirects": "^1.0.0",
                "requires-port": "^1.0.0"
            }
        },
        "http-proxy-agent": {
            "version": "4.0.1",
            "resolved": "https://registry.npmjs.org/http-proxy-agent/-/http-proxy-agent-4.0.1.tgz",
            "integrity": "sha512-k0zdNgqWTGA6aeIRVpvfVob4fL52dTfaehylg0Y4UvSySvOq/Y+BOyPrgpUrA7HylqvU8vIZGsRuXmspskV0Tg==",
            "dev": true,
            "requires": {
                "@tootallnate/once": "1",
                "agent-base": "6",
                "debug": "4"
            }
        },
        "http-server": {
            "version": "14.1.0",
            "resolved": "https://registry.npmjs.org/http-server/-/http-server-14.1.0.tgz",
            "integrity": "sha512-5lYsIcZtf6pdR8tCtzAHTWrAveo4liUlJdWc7YafwK/maPgYHs+VNP6KpCClmUnSorJrARVMXqtT055zBv11Yg==",
            "dev": true,
            "requires": {
                "basic-auth": "^2.0.1",
                "chalk": "^4.1.2",
                "corser": "^2.0.1",
                "he": "^1.2.0",
                "html-encoding-sniffer": "^3.0.0",
                "http-proxy": "^1.18.1",
                "mime": "^1.6.0",
                "minimist": "^1.2.5",
                "opener": "^1.5.1",
                "portfinder": "^1.0.28",
                "secure-compare": "3.0.1",
                "union": "~0.5.0",
                "url-join": "^4.0.1"
            }
        },
        "https-proxy-agent": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/https-proxy-agent/-/https-proxy-agent-5.0.1.tgz",
            "integrity": "sha512-dFcAjpTQFgoLMzC2VwU+C/CbS7uRL0lWmxDITmqm7C+7F0Odmj6s9l6alZc6AELXhrnggM2CeWSXHGOdX2YtwA==",
            "dev": true,
            "requires": {
                "agent-base": "6",
                "debug": "4"
            }
        },
        "humanize-ms": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/humanize-ms/-/humanize-ms-1.2.1.tgz",
            "integrity": "sha1-xG4xWaKT9riW2ikxbYtv6Lt5u+0=",
            "dev": true,
            "requires": {
                "ms": "^2.0.0"
            }
        },
        "iconv-lite": {
            "version": "0.4.24",
            "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.4.24.tgz",
            "integrity": "sha512-v3MXnZAcvnywkTUEZomIActle7RXXeedOR31wwl7VlyoXO4Qi9arvSenNQWne1TcRwhCL1HwLI21bEqdpj8/rA==",
            "dev": true,
            "requires": {
                "safer-buffer": ">= 2.1.2 < 3"
            }
        },
        "ieee754": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/ieee754/-/ieee754-1.2.1.tgz",
            "integrity": "sha512-dcyqhDvX1C46lXZcVqCpK+FtMRQVdIMN6/Df5js2zouUsqG7I6sFxitIC+7KYK29KdXOLHdu9zL4sFnoVQnqaA==",
            "dev": true
        },
        "imurmurhash": {
            "version": "0.1.4",
            "resolved": "https://registry.npmjs.org/imurmurhash/-/imurmurhash-0.1.4.tgz",
            "integrity": "sha1-khi5srkoojixPcT7a21XbyMUU+o=",
            "dev": true
        },
        "indent-string": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/indent-string/-/indent-string-4.0.0.tgz",
            "integrity": "sha512-EdDDZu4A2OyIK7Lr/2zG+w5jmbuk1DVBnEwREQvBzspBJkCEbRa8GxU1lghYcaGJCnRWibjDXlq779X1/y5xwg==",
            "dev": true
        },
        "infer-owner": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/infer-owner/-/infer-owner-1.0.4.tgz",
            "integrity": "sha512-IClj+Xz94+d7irH5qRyfJonOdfTzuDaifE6ZPWfx0N0+/ATZCbuTPq2prFl526urkQd90WyUKIh1DfBQ2hMz9A==",
            "dev": true
        },
        "inflight": {
            "version": "1.0.6",
            "resolved": "https://registry.npmjs.org/inflight/-/inflight-1.0.6.tgz",
            "integrity": "sha1-Sb1jMdfQLQwJvJEKEHW6gWW1bfk=",
            "dev": true,
            "requires": {
                "once": "^1.3.0",
                "wrappy": "1"
            }
        },
        "inherits": {
            "version": "2.0.4",
            "resolved": "https://registry.npmjs.org/inherits/-/inherits-2.0.4.tgz",
            "integrity": "sha512-k/vGaX4/Yla3WzyMCvTQOXYeIHvqOKtnqBduzTHpzpQZzAskKMhZ2K+EnBiSM9zGSoIFeMpXKxa4dYeZIQqewQ==",
            "dev": true
        },
        "interface-datastore": {
            "version": "6.1.0",
            "resolved": "https://registry.npmjs.org/interface-datastore/-/interface-datastore-6.1.0.tgz",
            "integrity": "sha512-oNHdsrWBsI/kDwUtEgt+aaZtQFKtQYN0TGZzc3SGiIA6m+plZ6malhmsygtbmDpfpIsNNC7ce9Gyaj+Tki+gVw==",
            "dev": true,
            "requires": {
                "interface-store": "^2.0.1",
                "nanoid": "^3.0.2",
                "uint8arrays": "^3.0.0"
            }
        },
        "interface-store": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/interface-store/-/interface-store-2.0.2.tgz",
            "integrity": "sha512-rScRlhDcz6k199EkHqT8NpM87ebN89ICOzILoBHgaG36/WX50N32BnU/kpZgCGPLhARRAWUUX5/cyaIjt7Kipg==",
            "dev": true
        },
        "ip": {
            "version": "1.1.5",
            "resolved": "https://registry.npmjs.org/ip/-/ip-1.1.5.tgz",
            "integrity": "sha1-vd7XARQpCCjAoDnnLvJfWq7ENUo=",
            "dev": true
        },
        "ip-regex": {
            "version": "4.3.0",
            "resolved": "https://registry.npmjs.org/ip-regex/-/ip-regex-4.3.0.tgz",
            "integrity": "sha512-B9ZWJxHHOHUhUjCPrMpLD4xEq35bUTClHM1S6CBU5ixQnkZmwipwgc96vAd7AAGM9TGHvJR+Uss+/Ak6UphK+Q==",
            "dev": true
        },
        "ipfs-client": {
            "version": "0.7.8",
            "resolved": "https://registry.npmjs.org/ipfs-client/-/ipfs-client-0.7.8.tgz",
            "integrity": "sha512-Rwpq8ZWtE5+yiTV2ICr5PljI0IPr3nmhIJeOtq2+UP+QElOcRz4egQEEBzo9EiIyvHBMU+v5LVW4OMQWYVImIQ==",
            "dev": true,
            "requires": {
                "ipfs-grpc-client": "^0.9.3",
                "ipfs-http-client": "^56.0.2",
                "merge-options": "^3.0.4"
            }
        },
        "ipfs-core-types": {
            "version": "0.10.2",
            "resolved": "https://registry.npmjs.org/ipfs-core-types/-/ipfs-core-types-0.10.2.tgz",
            "integrity": "sha512-IyPCAiiPiZ4qmmBFgh+wSS3aAQya5Ck+9lDYjBCw1+hK3SC3RzEP49CWqQMKQYbMnaa9pY1GsnGJkLC0TiE2vA==",
            "dev": true,
            "requires": {
                "@ipld/dag-pb": "^2.1.3",
                "interface-datastore": "^6.0.2",
                "ipfs-unixfs": "^6.0.3",
                "multiaddr": "^10.0.0",
                "multiformats": "^9.5.1"
            }
        },
        "ipfs-core-utils": {
            "version": "0.14.2",
            "resolved": "https://registry.npmjs.org/ipfs-core-utils/-/ipfs-core-utils-0.14.2.tgz",
            "integrity": "sha512-wgyg4QRSokSIxnhU1qTJQoEz/gzf6WHB4zBKTfMrQuiF55943aF06v3x2tZ4l+Hcgr2yEa7COSapcfCFKFsuoA==",
            "dev": true,
            "requires": {
                "any-signal": "^3.0.0",
                "blob-to-it": "^1.0.1",
                "browser-readablestream-to-it": "^1.0.1",
                "debug": "^4.1.1",
                "err-code": "^3.0.1",
                "ipfs-core-types": "^0.10.2",
                "ipfs-unixfs": "^6.0.3",
                "ipfs-utils": "^9.0.2",
                "it-all": "^1.0.4",
                "it-map": "^1.0.4",
                "it-peekable": "^1.0.2",
                "it-to-stream": "^1.0.0",
                "merge-options": "^3.0.4",
                "multiaddr": "^10.0.0",
                "multiaddr-to-uri": "^8.0.0",
                "multiformats": "^9.5.1",
                "nanoid": "^3.1.23",
                "parse-duration": "^1.0.0",
                "timeout-abort-controller": "^3.0.0",
                "uint8arrays": "^3.0.0"
            }
        },
        "ipfs-grpc-client": {
            "version": "0.9.3",
            "resolved": "https://registry.npmjs.org/ipfs-grpc-client/-/ipfs-grpc-client-0.9.3.tgz",
            "integrity": "sha512-lje6KJOnak8boVzjLwMkSRAS6qrYfh6FoTfxVekK90yRXTjUvBXnLOixk4LD35aSANZKD4YfBiTi97TjrroxGA==",
            "dev": true,
            "requires": {
                "@improbable-eng/grpc-web": "^0.14.0",
                "change-case": "^4.1.1",
                "debug": "^4.1.1",
                "err-code": "^3.0.1",
                "ipfs-core-types": "^0.10.2",
                "ipfs-core-utils": "^0.14.2",
                "ipfs-grpc-protocol": "^0.5.5",
                "ipfs-unixfs": "^6.0.3",
                "it-first": "^1.0.4",
                "it-pushable": "^1.4.2",
                "multiaddr": "^10.0.0",
                "multiformats": "^9.5.1",
                "p-defer": "^3.0.0",
                "protobufjs": "^6.10.2",
                "wherearewe": "^1.0.0",
                "ws": "^7.3.1"
            }
        },
        "ipfs-grpc-protocol": {
            "version": "0.5.5",
            "resolved": "https://registry.npmjs.org/ipfs-grpc-protocol/-/ipfs-grpc-protocol-0.5.5.tgz",
            "integrity": "sha512-zoJ+xwcYwzJ03GWJdz3e2k1NqJMfI9+M/VyPImhqPowVmTZ0+f9JGR+M8MetJAHMeQILLCTXmIMsiFzAFObZJg==",
            "dev": true
        },
        "ipfs-http-client": {
            "version": "56.0.2",
            "resolved": "https://registry.npmjs.org/ipfs-http-client/-/ipfs-http-client-56.0.2.tgz",
            "integrity": "sha512-IeIJJo6CDNCnTFz2hTSzzBDX34/jJmlyxk65NJAS+kgvel9aPRYaSestymDJWvOZj4/bBtiJ8X2CsRQoaVyIBg==",
            "dev": true,
            "requires": {
                "@ipld/dag-cbor": "^7.0.0",
                "@ipld/dag-json": "^8.0.1",
                "@ipld/dag-pb": "^2.1.3",
                "any-signal": "^3.0.0",
                "dag-jose": "^1.0.0",
                "debug": "^4.1.1",
                "err-code": "^3.0.1",
                "ipfs-core-types": "^0.10.2",
                "ipfs-core-utils": "^0.14.2",
                "ipfs-utils": "^9.0.2",
                "it-first": "^1.0.6",
                "it-last": "^1.0.4",
                "merge-options": "^3.0.4",
                "multiaddr": "^10.0.0",
                "multiformats": "^9.5.1",
                "parse-duration": "^1.0.0",
                "stream-to-it": "^0.2.2",
                "uint8arrays": "^3.0.0"
            }
        },
        "ipfs-unixfs": {
            "version": "6.0.6",
            "resolved": "https://registry.npmjs.org/ipfs-unixfs/-/ipfs-unixfs-6.0.6.tgz",
            "integrity": "sha512-gTkjYKXuHnqIf6EFfS+ESaYEl3I3aaQQ0UX8MhpNzreMLEuMnuqpoI/uLLllTZa31WRplKixabbpRTSmTYRNwA==",
            "dev": true,
            "requires": {
                "err-code": "^3.0.1",
                "protobufjs": "^6.10.2"
            }
        },
        "ipfs-utils": {
            "version": "9.0.6",
            "resolved": "https://registry.npmjs.org/ipfs-utils/-/ipfs-utils-9.0.6.tgz",
            "integrity": "sha512-/WfdwOIiJVb3uqfKRQ9Eo+vCEKsDgp7h4Pdc37MRwAiFciZ7xKAkEqsfXubV0VQi8x5jWTifeHn8WEPBLL451w==",
            "dev": true,
            "requires": {
                "any-signal": "^3.0.0",
                "buffer": "^6.0.1",
                "electron-fetch": "^1.7.2",
                "err-code": "^3.0.1",
                "is-electron": "^2.2.0",
                "iso-url": "^1.1.5",
                "it-glob": "^1.0.1",
                "it-to-stream": "^1.0.0",
                "merge-options": "^3.0.4",
                "nanoid": "^3.1.20",
                "native-fetch": "^3.0.0",
                "node-fetch": "https://registry.npmjs.org/@achingbrain/node-fetch/-/node-fetch-2.6.7.tgz",
                "react-native-fetch-api": "^2.0.0",
                "stream-to-it": "^0.2.2"
            }
        },
        "is-binary-path": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/is-binary-path/-/is-binary-path-2.1.0.tgz",
            "integrity": "sha512-ZMERYes6pDydyuGidse7OsHxtbI7WVeUEozgR/g7rd0xUimYNlvZRE/K2MgZTjWy725IfelLeVcEM97mmtRGXw==",
            "dev": true,
            "requires": {
                "binary-extensions": "^2.0.0"
            }
        },
        "is-electron": {
            "version": "2.2.1",
            "resolved": "https://registry.npmjs.org/is-electron/-/is-electron-2.2.1.tgz",
            "integrity": "sha512-r8EEQQsqT+Gn0aXFx7lTFygYQhILLCB+wn0WCDL5LZRINeLH/Rvw1j2oKodELLXYNImQ3CRlVsY8wW4cGOsyuw==",
            "dev": true
        },
        "is-extglob": {
            "version": "2.1.1",
            "resolved": "https://registry.npmjs.org/is-extglob/-/is-extglob-2.1.1.tgz",
            "integrity": "sha1-qIwCU1eR8C7TfHahueqXc8gz+MI=",
            "dev": true
        },
        "is-fullwidth-code-point": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/is-fullwidth-code-point/-/is-fullwidth-code-point-3.0.0.tgz",
            "integrity": "sha512-zymm5+u+sCsSWyD9qNaejV3DFvhCKclKdizYaJUuHA83RLjb7nSuGnddCHGv0hk+KY7BMAlsWeK4Ueg6EV6XQg==",
            "dev": true
        },
        "is-glob": {
            "version": "4.0.3",
            "resolved": "https://registry.npmjs.org/is-glob/-/is-glob-4.0.3.tgz",
            "integrity": "sha512-xelSayHH36ZgE7ZWhli7pW34hNbNl8Ojv5KVmkJD4hBdD3th8Tfk9vYasLM+mXWOZhFkgZfxhLSnrwRr4elSSg==",
            "dev": true,
            "requires": {
                "is-extglob": "^2.1.1"
            }
        },
        "is-ip": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/is-ip/-/is-ip-3.1.0.tgz",
            "integrity": "sha512-35vd5necO7IitFPjd/YBeqwWnyDWbuLH9ZXQdMfDA8TEo7pv5X8yfrvVO3xbJbLUlERCMvf6X0hTUamQxCYJ9Q==",
            "dev": true,
            "requires": {
                "ip-regex": "^4.0.0"
            }
        },
        "is-lambda": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/is-lambda/-/is-lambda-1.0.1.tgz",
            "integrity": "sha1-PZh3iZ5qU+/AFgUEzeFfgubwYdU=",
            "dev": true
        },
        "is-number": {
            "version": "7.0.0",
            "resolved": "https://registry.npmjs.org/is-number/-/is-number-7.0.0.tgz",
            "integrity": "sha512-41Cifkg6e8TylSpdtTpeLVMqvSBEVzTttHvERD741+pnZ8ANv0004MRL43QKPDlK9cGvNp6NZWZUBlbGXYxxng==",
            "dev": true
        },
        "is-plain-obj": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/is-plain-obj/-/is-plain-obj-2.1.0.tgz",
            "integrity": "sha512-YWnfyRwxL/+SsrWYfOpUtz5b3YD+nyfkHvjbcanzk8zgyO4ASD67uVMRt8k5bM4lLMDnXfriRhOpemw+NfT1eA==",
            "dev": true
        },
        "is-unicode-supported": {
            "version": "0.1.0",
            "resolved": "https://registry.npmjs.org/is-unicode-supported/-/is-unicode-supported-0.1.0.tgz",
            "integrity": "sha512-knxG2q4UC3u8stRGyAVJCOdxFmv5DZiRcdlIaAQXAbSfJya+OhopNotLQrstBhququ4ZpuKbDc/8S6mgXgPFPw==",
            "dev": true
        },
        "isbinaryfile": {
            "version": "4.0.10",
            "resolved": "https://registry.npmjs.org/isbinaryfile/-/isbinaryfile-4.0.10.tgz",
            "integrity": "sha512-iHrqe5shvBUcFbmZq9zOQHBoeOhZJu6RQGrDpBgenUm/Am+F3JM2MgQj+rK3Z601fzrL5gLZWtAPH2OBaSVcyw==",
            "dev": true
        },
        "isexe": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/isexe/-/isexe-2.0.0.tgz",
            "integrity": "sha1-6PvzdNxVb/iUehDcsFctYz8s+hA=",
            "dev": true
        },
        "iso-url": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/iso-url/-/iso-url-1.2.1.tgz",
            "integrity": "sha512-9JPDgCN4B7QPkLtYAAOrEuAWvP9rWvR5offAr0/SeF046wIkglqH3VXgYYP6NcsKslH80UIVgmPqNe3j7tG2ng==",
            "dev": true
        },
        "it-all": {
            "version": "1.0.6",
            "resolved": "https://registry.npmjs.org/it-all/-/it-all-1.0.6.tgz",
            "integrity": "sha512-3cmCc6Heqe3uWi3CVM/k51fa/XbMFpQVzFoDsV0IZNHSQDyAXl3c4MjHkFX5kF3922OGj7Myv1nSEUgRtcuM1A==",
            "dev": true
        },
        "it-first": {
            "version": "1.0.7",
            "resolved": "https://registry.npmjs.org/it-first/-/it-first-1.0.7.tgz",
            "integrity": "sha512-nvJKZoBpZD/6Rtde6FXqwDqDZGF1sCADmr2Zoc0hZsIvnE449gRFnGctxDf09Bzc/FWnHXAdaHVIetY6lrE0/g==",
            "dev": true
        },
        "it-glob": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/it-glob/-/it-glob-1.0.2.tgz",
            "integrity": "sha512-Ch2Dzhw4URfB9L/0ZHyY+uqOnKvBNeS/SMcRiPmJfpHiM0TsUZn+GkpcZxAoF3dJVdPm/PuIk3A4wlV7SUo23Q==",
            "dev": true,
            "requires": {
                "@types/minimatch": "^3.0.4",
                "minimatch": "^3.0.4"
            }
        },
        "it-last": {
            "version": "1.0.6",
            "resolved": "https://registry.npmjs.org/it-last/-/it-last-1.0.6.tgz",
            "integrity": "sha512-aFGeibeiX/lM4bX3JY0OkVCFkAw8+n9lkukkLNivbJRvNz8lI3YXv5xcqhFUV2lDJiraEK3OXRDbGuevnnR67Q==",
            "dev": true
        },
        "it-map": {
            "version": "1.0.6",
            "resolved": "https://registry.npmjs.org/it-map/-/it-map-1.0.6.tgz",
            "integrity": "sha512-XT4/RM6UHIFG9IobGlQPFQUrlEKkU4eBUFG3qhWhfAdh1JfF2x11ShCrKCdmZ0OiZppPfoLuzcfA4cey6q3UAQ==",
            "dev": true
        },
        "it-peekable": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/it-peekable/-/it-peekable-1.0.3.tgz",
            "integrity": "sha512-5+8zemFS+wSfIkSZyf0Zh5kNN+iGyccN02914BY4w/Dj+uoFEoPSvj5vaWn8pNZJNSxzjW0zHRxC3LUb2KWJTQ==",
            "dev": true
        },
        "it-pushable": {
            "version": "1.4.2",
            "resolved": "https://registry.npmjs.org/it-pushable/-/it-pushable-1.4.2.tgz",
            "integrity": "sha512-vVPu0CGRsTI8eCfhMknA7KIBqqGFolbRx+1mbQ6XuZ7YCz995Qj7L4XUviwClFunisDq96FdxzF5FnAbw15afg==",
            "dev": true,
            "requires": {
                "fast-fifo": "^1.0.0"
            }
        },
        "it-to-stream": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/it-to-stream/-/it-to-stream-1.0.0.tgz",
            "integrity": "sha512-pLULMZMAB/+vbdvbZtebC0nWBTbG581lk6w8P7DfIIIKUfa8FbY7Oi0FxZcFPbxvISs7A9E+cMpLDBc1XhpAOA==",
            "dev": true,
            "requires": {
                "buffer": "^6.0.3",
                "fast-fifo": "^1.0.0",
                "get-iterator": "^1.0.2",
                "p-defer": "^3.0.0",
                "p-fifo": "^1.0.0",
                "readable-stream": "^3.6.0"
            }
        },
        "jest-worker": {
            "version": "26.6.2",
            "resolved": "https://registry.npmjs.org/jest-worker/-/jest-worker-26.6.2.tgz",
            "integrity": "sha512-KWYVV1c4i+jbMpaBC+U++4Va0cp8OisU185o73T1vo99hqi7w8tSJfUXYswwqqrjzwxa6KpRK54WhPvwf5w6PQ==",
            "dev": true,
            "requires": {
                "@types/node": "*",
                "merge-stream": "^2.0.0",
                "supports-color": "^7.0.0"
            }
        },
        "js-tokens": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/js-tokens/-/js-tokens-4.0.0.tgz",
            "integrity": "sha512-RdJUflcE3cUzKiMqQgsCu06FPu9UdIJO0beYbPhHN4k6apgJtifcoCtT9bcxOpYBtpD2kCM6Sbzg4CausW/PKQ==",
            "dev": true
        },
        "js-yaml": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/js-yaml/-/js-yaml-4.1.0.tgz",
            "integrity": "sha512-wpxZs9NoxZaJESJGIZTyDEaYpl0FKSA+FB9aJiyemKhMwkxQg63h4T1KJgUGHpTqPDNRcmmYLugrRjJlBtWvRA==",
            "dev": true,
            "requires": {
                "argparse": "^2.0.1"
            }
        },
        "jsesc": {
            "version": "2.5.2",
            "resolved": "https://registry.npmjs.org/jsesc/-/jsesc-2.5.2.tgz",
            "integrity": "sha512-OYu7XEzjkCQ3C5Ps3QIZsQfNpqoJyZZA99wd9aWd05NCtC5pWOkShK2mkL6HXQR6/Cy2lbNdPlZBpuQHXE63gA==",
            "dev": true
        },
        "json5": {
            "version": "2.2.1",
            "resolved": "https://registry.npmjs.org/json5/-/json5-2.2.1.tgz",
            "integrity": "sha512-1hqLFMSrGHRHxav9q9gNjJ5EXznIxGVO09xQRrwplcS8qs28pZ8s8hupZAmqDwZUmVZ2Qb2jnyPOWcDH8m8dlA==",
            "dev": true
        },
        "jsonfile": {
            "version": "6.1.0",
            "resolved": "https://registry.npmjs.org/jsonfile/-/jsonfile-6.1.0.tgz",
            "integrity": "sha512-5dgndWOriYSm5cnYaJNhalLNDKOqFwyDB/rr1E9ZsGciGvKPs8R2xYGCacuf3z6K1YKDz182fd+fY3cn3pMqXQ==",
            "dev": true,
            "requires": {
                "graceful-fs": "^4.1.6",
                "universalify": "^2.0.0"
            }
        },
        "karma": {
            "version": "6.3.19",
            "resolved": "https://registry.npmjs.org/karma/-/karma-6.3.19.tgz",
            "integrity": "sha512-NDhWckzES/Y9xMiddyU1RzaKL76/scCsu8Mp0vR0Z3lQRvC3p72+Ab4ppoxs36S9tyPNX5V48yvaV++RNEBPZw==",
            "dev": true,
            "requires": {
                "@colors/colors": "1.5.0",
                "body-parser": "^1.19.0",
                "braces": "^3.0.2",
                "chokidar": "^3.5.1",
                "connect": "^3.7.0",
                "di": "^0.0.1",
                "dom-serialize": "^2.2.1",
                "glob": "^7.1.7",
                "graceful-fs": "^4.2.6",
                "http-proxy": "^1.18.1",
                "isbinaryfile": "^4.0.8",
                "lodash": "^4.17.21",
                "log4js": "^6.4.1",
                "mime": "^2.5.2",
                "minimatch": "^3.0.4",
                "mkdirp": "^0.5.5",
                "qjobs": "^1.2.0",
                "range-parser": "^1.2.1",
                "rimraf": "^3.0.2",
                "socket.io": "^4.4.1",
                "source-map": "^0.6.1",
                "tmp": "^0.2.1",
                "ua-parser-js": "^0.7.30",
                "yargs": "^16.1.1"
            },
            "dependencies": {
                "mime": {
                    "version": "2.6.0",
                    "resolved": "https://registry.npmjs.org/mime/-/mime-2.6.0.tgz",
                    "integrity": "sha512-USPkMeET31rOMiarsBNIHZKLGgvKc/LrjofAnBlOttf5ajRvqiRA8QsenbcooctK6d6Ts6aqZXBA+XbkKthiQg==",
                    "dev": true
                },
                "mkdirp": {
                    "version": "0.5.6",
                    "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
                    "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
                    "dev": true,
                    "requires": {
                        "minimist": "^1.2.6"
                    }
                }
            }
        },
        "karma-chai": {
            "version": "0.1.0",
            "resolved": "https://registry.npmjs.org/karma-chai/-/karma-chai-0.1.0.tgz",
            "integrity": "sha1-vuWtQEAFF4Ea40u5RfdikJEIt5o=",
            "dev": true,
            "requires": {}
        },
        "karma-chrome-launcher": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/karma-chrome-launcher/-/karma-chrome-launcher-3.1.1.tgz",
            "integrity": "sha512-hsIglcq1vtboGPAN+DGCISCFOxW+ZVnIqhDQcCMqqCp+4dmJ0Qpq5QAjkbA0X2L9Mi6OBkHi2Srrbmm7pUKkzQ==",
            "dev": true,
            "requires": {
                "which": "^1.2.1"
            },
            "dependencies": {
                "which": {
                    "version": "1.3.1",
                    "resolved": "https://registry.npmjs.org/which/-/which-1.3.1.tgz",
                    "integrity": "sha512-HxJdYWq1MTIQbJ3nw0cqssHoTNU267KlrDuGZ1WYlxDStUtKUhOaJmh112/TZmHxxUfuJqPXSOm7tDyas0OSIQ==",
                    "dev": true,
                    "requires": {
                        "isexe": "^2.0.0"
                    }
                }
            }
        },
        "karma-mocha": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/karma-mocha/-/karma-mocha-2.0.1.tgz",
            "integrity": "sha512-Tzd5HBjm8his2OA4bouAsATYEpZrp9vC7z5E5j4C5Of5Rrs1jY67RAwXNcVmd/Bnk1wgvQRou0zGVLey44G4tQ==",
            "dev": true,
            "requires": {
                "minimist": "^1.2.3"
            }
        },
        "lit": {
            "version": "2.2.4",
            "resolved": "https://registry.npmjs.org/lit/-/lit-2.2.4.tgz",
            "integrity": "sha512-O7t+uizo1/Br0y+5RaWRzPkd4MsoL4XY2eq7n2wrESyCCjeagq4ERZKsyKX40jbmsz4bAAs7/0qNRX11TuXzoA==",
            "requires": {
                "@lit/reactive-element": "^1.3.0",
                "lit-element": "^3.2.0",
                "lit-html": "^2.2.0"
            }
        },
        "lit-element": {
            "version": "3.2.0",
            "resolved": "https://registry.npmjs.org/lit-element/-/lit-element-3.2.0.tgz",
            "integrity": "sha512-HbE7yt2SnUtg5DCrWt028oaU4D5F4k/1cntAFHTkzY8ZIa8N0Wmu92PxSxucsQSOXlODFrICkQ5x/tEshKi13g==",
            "requires": {
                "@lit/reactive-element": "^1.3.0",
                "lit-html": "^2.2.0"
            }
        },
        "lit-html": {
            "version": "2.2.4",
            "resolved": "https://registry.npmjs.org/lit-html/-/lit-html-2.2.4.tgz",
            "integrity": "sha512-IPY0V0z/QWcTduxb6DlP46Un8n6tG+mHSAijGcPozfXTjVkvFLN4/irPzthtq/eC8RU+7CUqh6h4KB7tnRPJfg==",
            "requires": {
                "@types/trusted-types": "^2.0.2"
            }
        },
        "locate-path": {
            "version": "6.0.0",
            "resolved": "https://registry.npmjs.org/locate-path/-/locate-path-6.0.0.tgz",
            "integrity": "sha512-iPZK6eYjbxRu3uB4/WZ3EsEIMJFMqAoopl3R+zuq0UjcAm/MO6KCweDgPfP3elTztoKP3KtnVHxTn2NHBSDVUw==",
            "dev": true,
            "requires": {
                "p-locate": "^5.0.0"
            }
        },
        "lodash": {
            "version": "4.17.21",
            "resolved": "https://registry.npmjs.org/lodash/-/lodash-4.17.21.tgz",
            "integrity": "sha512-v2kDEe57lecTulaDIuNTPy3Ry4gLGJ6Z1O3vE1krgXZNrsQ+LFTGHVxVjcXPs17LhbZVGedAJv8XZ1tvj5FvSg==",
            "dev": true
        },
        "log-symbols": {
            "version": "4.1.0",
            "resolved": "https://registry.npmjs.org/log-symbols/-/log-symbols-4.1.0.tgz",
            "integrity": "sha512-8XPvpAA8uyhfteu8pIvQxpJZ7SYYdpUivZpGy6sFsBuKRY/7rQGavedeB8aK+Zkyq6upMFVL/9AW6vOYzfRyLg==",
            "dev": true,
            "requires": {
                "chalk": "^4.1.0",
                "is-unicode-supported": "^0.1.0"
            }
        },
        "log4js": {
            "version": "6.4.6",
            "resolved": "https://registry.npmjs.org/log4js/-/log4js-6.4.6.tgz",
            "integrity": "sha512-1XMtRBZszmVZqPAOOWczH+Q94AI42mtNWjvjA5RduKTSWjEc56uOBbyM1CJnfN4Ym0wSd8cQ43zOojlSHgRDAw==",
            "dev": true,
            "requires": {
                "date-format": "^4.0.9",
                "debug": "^4.3.4",
                "flatted": "^3.2.5",
                "rfdc": "^1.3.0",
                "streamroller": "^3.0.8"
            }
        },
        "long": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/long/-/long-4.0.0.tgz",
            "integrity": "sha512-XsP+KhQif4bjX1kbuSiySJFNAehNxgLb6hPRGJ9QsUr8ajHkuXGdrHmFUTUUXhDwVX2R5bY4JNZEwbUiMhV+MA==",
            "dev": true
        },
        "loupe": {
            "version": "2.3.4",
            "resolved": "https://registry.npmjs.org/loupe/-/loupe-2.3.4.tgz",
            "integrity": "sha512-OvKfgCC2Ndby6aSTREl5aCCPTNIzlDfQZvZxNUrBrihDhL3xcrYegTblhmEiCrg2kKQz4XsFIaemE5BF4ybSaQ==",
            "dev": true,
            "requires": {
                "get-func-name": "^2.0.0"
            }
        },
        "lower-case": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/lower-case/-/lower-case-2.0.2.tgz",
            "integrity": "sha512-7fm3l3NAF9WfN6W3JOmf5drwpVqX78JtoGJ3A6W0a6ZnldM41w2fV5D490psKFTpMds8TJse/eHLFFsNHHjHgg==",
            "dev": true,
            "requires": {
                "tslib": "^2.0.3"
            }
        },
        "lru-cache": {
            "version": "6.0.0",
            "resolved": "https://registry.npmjs.org/lru-cache/-/lru-cache-6.0.0.tgz",
            "integrity": "sha512-Jo6dJ04CmSjuznwJSS3pUeWmd/H0ffTlkXXgwZi+eq1UCmqQwCh+eLsYOYCwY991i2Fah4h1BEMCx4qThGbsiA==",
            "dev": true,
            "requires": {
                "yallist": "^4.0.0"
            }
        },
        "magic-string": {
            "version": "0.25.9",
            "resolved": "https://registry.npmjs.org/magic-string/-/magic-string-0.25.9.tgz",
            "integrity": "sha512-RmF0AsMzgt25qzqqLc1+MbHmhdx0ojF2Fvs4XnOqz2ZOBXzzkEwc/dJQZCYHAn7v1jbVOjAZfK8msRn4BxO4VQ==",
            "dev": true,
            "requires": {
                "sourcemap-codec": "^1.4.8"
            }
        },
        "make-fetch-happen": {
            "version": "8.0.14",
            "resolved": "https://registry.npmjs.org/make-fetch-happen/-/make-fetch-happen-8.0.14.tgz",
            "integrity": "sha512-EsS89h6l4vbfJEtBZnENTOFk8mCRpY5ru36Xe5bcX1KYIli2mkSHqoFsp5O1wMDvTJJzxe/4THpCTtygjeeGWQ==",
            "dev": true,
            "requires": {
                "agentkeepalive": "^4.1.3",
                "cacache": "^15.0.5",
                "http-cache-semantics": "^4.1.0",
                "http-proxy-agent": "^4.0.1",
                "https-proxy-agent": "^5.0.0",
                "is-lambda": "^1.0.1",
                "lru-cache": "^6.0.0",
                "minipass": "^3.1.3",
                "minipass-collect": "^1.0.2",
                "minipass-fetch": "^1.3.2",
                "minipass-flush": "^1.0.5",
                "minipass-pipeline": "^1.2.4",
                "promise-retry": "^2.0.1",
                "socks-proxy-agent": "^5.0.0",
                "ssri": "^8.0.0"
            }
        },
        "media-typer": {
            "version": "0.3.0",
            "resolved": "https://registry.npmjs.org/media-typer/-/media-typer-0.3.0.tgz",
            "integrity": "sha1-hxDXrwqmJvj/+hzgAWhUUmMlV0g=",
            "dev": true
        },
        "merge-options": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/merge-options/-/merge-options-3.0.4.tgz",
            "integrity": "sha512-2Sug1+knBjkaMsMgf1ctR1Ujx+Ayku4EdJN4Z+C2+JzoeF7A3OZ9KM2GY0CpQS51NR61LTurMJrRKPhSs3ZRTQ==",
            "dev": true,
            "requires": {
                "is-plain-obj": "^2.1.0"
            }
        },
        "merge-stream": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/merge-stream/-/merge-stream-2.0.0.tgz",
            "integrity": "sha512-abv/qOcuPfk3URPfDzmZU1LKmuw8kT+0nIHvKrKgFrwifol/doWcdA4ZqsWQ8ENrFKkd67Mfpo/LovbIUsbt3w==",
            "dev": true
        },
        "mime": {
            "version": "1.6.0",
            "resolved": "https://registry.npmjs.org/mime/-/mime-1.6.0.tgz",
            "integrity": "sha512-x0Vn8spI+wuJ1O6S7gnbaQg8Pxh4NNHb7KSINmEWKiPE4RKOplvijn+NkmYmmRgP68mc70j2EbeTFRsrswaQeg==",
            "dev": true
        },
        "mime-db": {
            "version": "1.52.0",
            "resolved": "https://registry.npmjs.org/mime-db/-/mime-db-1.52.0.tgz",
            "integrity": "sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==",
            "dev": true
        },
        "mime-types": {
            "version": "2.1.35",
            "resolved": "https://registry.npmjs.org/mime-types/-/mime-types-2.1.35.tgz",
            "integrity": "sha512-ZDY+bPm5zTTF+YpCrAU9nK0UgICYPT0QtT1NZWFv4s++TNkcgVaT0g6+4R2uI4MjQjzysHB1zxuWL50hzaeXiw==",
            "dev": true,
            "requires": {
                "mime-db": "1.52.0"
            }
        },
        "minimatch": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
            "integrity": "sha512-J7p63hRiAjw1NDEww1W7i37+ByIrOWO5XQQAzZ3VOcL0PNybwpfmV/N05zFAzwQ9USyEcX6t3UO+K5aqBQOIHw==",
            "dev": true,
            "requires": {
                "brace-expansion": "^1.1.7"
            }
        },
        "minimist": {
            "version": "1.2.6",
            "resolved": "https://registry.npmjs.org/minimist/-/minimist-1.2.6.tgz",
            "integrity": "sha512-Jsjnk4bw3YJqYzbdyBiNsPWHPfO++UGG749Cxs6peCu5Xg4nrena6OVxOYxrQTqww0Jmwt+Ref8rggumkTLz9Q==",
            "dev": true
        },
        "minipass": {
            "version": "3.1.6",
            "resolved": "https://registry.npmjs.org/minipass/-/minipass-3.1.6.tgz",
            "integrity": "sha512-rty5kpw9/z8SX9dmxblFA6edItUmwJgMeYDZRrwlIVN27i8gysGbznJwUggw2V/FVqFSDdWy040ZPS811DYAqQ==",
            "dev": true,
            "requires": {
                "yallist": "^4.0.0"
            }
        },
        "minipass-collect": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/minipass-collect/-/minipass-collect-1.0.2.tgz",
            "integrity": "sha512-6T6lH0H8OG9kITm/Jm6tdooIbogG9e0tLgpY6mphXSm/A9u8Nq1ryBG+Qspiub9LjWlBPsPS3tWQ/Botq4FdxA==",
            "dev": true,
            "requires": {
                "minipass": "^3.0.0"
            }
        },
        "minipass-fetch": {
            "version": "1.4.1",
            "resolved": "https://registry.npmjs.org/minipass-fetch/-/minipass-fetch-1.4.1.tgz",
            "integrity": "sha512-CGH1eblLq26Y15+Azk7ey4xh0J/XfJfrCox5LDJiKqI2Q2iwOLOKrlmIaODiSQS8d18jalF6y2K2ePUm0CmShw==",
            "dev": true,
            "requires": {
                "encoding": "^0.1.12",
                "minipass": "^3.1.0",
                "minipass-sized": "^1.0.3",
                "minizlib": "^2.0.0"
            }
        },
        "minipass-flush": {
            "version": "1.0.5",
            "resolved": "https://registry.npmjs.org/minipass-flush/-/minipass-flush-1.0.5.tgz",
            "integrity": "sha512-JmQSYYpPUqX5Jyn1mXaRwOda1uQ8HP5KAT/oDSLCzt1BYRhQU0/hDtsB1ufZfEEzMZ9aAVmsBw8+FWsIXlClWw==",
            "dev": true,
            "requires": {
                "minipass": "^3.0.0"
            }
        },
        "minipass-pipeline": {
            "version": "1.2.4",
            "resolved": "https://registry.npmjs.org/minipass-pipeline/-/minipass-pipeline-1.2.4.tgz",
            "integrity": "sha512-xuIq7cIOt09RPRJ19gdi4b+RiNvDFYe5JH+ggNvBqGqpQXcru3PcRmOZuHBKWK1Txf9+cQ+HMVN4d6z46LZP7A==",
            "dev": true,
            "requires": {
                "minipass": "^3.0.0"
            }
        },
        "minipass-sized": {
            "version": "1.0.3",
            "resolved": "https://registry.npmjs.org/minipass-sized/-/minipass-sized-1.0.3.tgz",
            "integrity": "sha512-MbkQQ2CTiBMlA2Dm/5cY+9SWFEN8pzzOXi6rlM5Xxq0Yqbda5ZQy9sU75a673FE9ZK0Zsbr6Y5iP6u9nktfg2g==",
            "dev": true,
            "requires": {
                "minipass": "^3.0.0"
            }
        },
        "minizlib": {
            "version": "2.1.2",
            "resolved": "https://registry.npmjs.org/minizlib/-/minizlib-2.1.2.tgz",
            "integrity": "sha512-bAxsR8BVfj60DWXHE3u30oHzfl4G7khkSuPW+qvpd7jFRHm7dLxOjUk1EHACJ/hxLY8phGJ0YhYHZo7jil7Qdg==",
            "dev": true,
            "requires": {
                "minipass": "^3.0.0",
                "yallist": "^4.0.0"
            }
        },
        "mkdirp": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-1.0.4.tgz",
            "integrity": "sha512-vVqVZQyf3WLx2Shd0qJ9xuvqgAyKPLAiqITEtqW0oIUjzo3PePDd6fW9iFz30ef7Ysp/oiWqbhszeGWW2T6Gzw==",
            "dev": true
        },
        "mocha": {
            "version": "9.2.2",
            "resolved": "https://registry.npmjs.org/mocha/-/mocha-9.2.2.tgz",
            "integrity": "sha512-L6XC3EdwT6YrIk0yXpavvLkn8h+EU+Y5UcCHKECyMbdUIxyMuZj4bX4U9e1nvnvUUvQVsV2VHQr5zLdcUkhW/g==",
            "dev": true,
            "requires": {
                "@ungap/promise-all-settled": "1.1.2",
                "ansi-colors": "4.1.1",
                "browser-stdout": "1.3.1",
                "chokidar": "3.5.3",
                "debug": "4.3.3",
                "diff": "5.0.0",
                "escape-string-regexp": "4.0.0",
                "find-up": "5.0.0",
                "glob": "7.2.0",
                "growl": "1.10.5",
                "he": "1.2.0",
                "js-yaml": "4.1.0",
                "log-symbols": "4.1.0",
                "minimatch": "4.2.1",
                "ms": "2.1.3",
                "nanoid": "3.3.1",
                "serialize-javascript": "6.0.0",
                "strip-json-comments": "3.1.1",
                "supports-color": "8.1.1",
                "which": "2.0.2",
                "workerpool": "6.2.0",
                "yargs": "16.2.0",
                "yargs-parser": "20.2.4",
                "yargs-unparser": "2.0.0"
            },
            "dependencies": {
                "debug": {
                    "version": "4.3.3",
                    "resolved": "https://registry.npmjs.org/debug/-/debug-4.3.3.tgz",
                    "integrity": "sha512-/zxw5+vh1Tfv+4Qn7a5nsbcJKPaSvCDhojn6FEl9vupwK2VCSDtEiEtqr8DFtzYFOdz63LBkxec7DYuc2jon6Q==",
                    "dev": true,
                    "requires": {
                        "ms": "2.1.2"
                    },
                    "dependencies": {
                        "ms": {
                            "version": "2.1.2",
                            "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.2.tgz",
                            "integrity": "sha512-sGkPx+VjMtmA6MX27oA4FBFELFCZZ4S4XqeGOXCv68tT+jb3vk/RyaKWP0PTKyWtmLSM0b+adUTEvbs1PEaH2w==",
                            "dev": true
                        }
                    }
                },
                "minimatch": {
                    "version": "4.2.1",
                    "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-4.2.1.tgz",
                    "integrity": "sha512-9Uq1ChtSZO+Mxa/CL1eGizn2vRn3MlLgzhT0Iz8zaY8NdvxvB0d5QdPFmCKf7JKA9Lerx5vRrnwO03jsSfGG9g==",
                    "dev": true,
                    "requires": {
                        "brace-expansion": "^1.1.7"
                    }
                },
                "nanoid": {
                    "version": "3.3.1",
                    "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.1.tgz",
                    "integrity": "sha512-n6Vs/3KGyxPQd6uO0eH4Bv0ojGSUvuLlIHtC3Y0kEO23YRge8H9x1GCzLn28YX0H66pMkxuaeESFq4tKISKwdw==",
                    "dev": true
                },
                "supports-color": {
                    "version": "8.1.1",
                    "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-8.1.1.tgz",
                    "integrity": "sha512-MpUEN2OodtUzxvKQl72cUF7RQ5EiHsGvSsVG0ia9c5RbWGL2CI4C7EpPS8UTBIplnlzZiNuV56w+FuNxy3ty2Q==",
                    "dev": true,
                    "requires": {
                        "has-flag": "^4.0.0"
                    }
                }
            }
        },
        "ms": {
            "version": "2.1.3",
            "resolved": "https://registry.npmjs.org/ms/-/ms-2.1.3.tgz",
            "integrity": "sha512-6FlzubTLZG3J2a/NVCAleEhjzq5oxgHyaCU9yYXvcLsvoVaHJq/s5xXI6/XXP6tz7R9xAOtHnSO/tXtF3WRTlA==",
            "dev": true
        },
        "multiaddr": {
            "version": "10.0.1",
            "resolved": "https://registry.npmjs.org/multiaddr/-/multiaddr-10.0.1.tgz",
            "integrity": "sha512-G5upNcGzEGuTHkzxezPrrD6CaIHR9uo+7MwqhNVcXTs33IInon4y7nMiGxl2CY5hG7chvYQUQhz5V52/Qe3cbg==",
            "dev": true,
            "requires": {
                "dns-over-http-resolver": "^1.2.3",
                "err-code": "^3.0.1",
                "is-ip": "^3.1.0",
                "multiformats": "^9.4.5",
                "uint8arrays": "^3.0.0",
                "varint": "^6.0.0"
            }
        },
        "multiaddr-to-uri": {
            "version": "8.0.0",
            "resolved": "https://registry.npmjs.org/multiaddr-to-uri/-/multiaddr-to-uri-8.0.0.tgz",
            "integrity": "sha512-dq4p/vsOOUdVEd1J1gl+R2GFrXJQH8yjLtz4hodqdVbieg39LvBOdMQRdQnfbg5LSM/q1BYNVf5CBbwZFFqBgA==",
            "dev": true,
            "requires": {
                "multiaddr": "^10.0.0"
            }
        },
        "multiformats": {
            "version": "9.6.4",
            "resolved": "https://registry.npmjs.org/multiformats/-/multiformats-9.6.4.tgz",
            "integrity": "sha512-fCCB6XMrr6CqJiHNjfFNGT0v//dxOBMrOMqUIzpPc/mmITweLEyhvMpY9bF+jZ9z3vaMAau5E8B68DW77QMXkg==",
            "dev": true
        },
        "nanoid": {
            "version": "3.3.3",
            "resolved": "https://registry.npmjs.org/nanoid/-/nanoid-3.3.3.tgz",
            "integrity": "sha512-p1sjXuopFs0xg+fPASzQ28agW1oHD7xDsd9Xkf3T15H3c/cifrFHVwrh74PdoklAPi+i7MdRsE47vm2r6JoB+w==",
            "dev": true
        },
        "native-fetch": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/native-fetch/-/native-fetch-3.0.0.tgz",
            "integrity": "sha512-G3Z7vx0IFb/FQ4JxvtqGABsOTIqRWvgQz6e+erkB+JJD6LrszQtMozEHI4EkmgZQvnGHrpLVzUWk7t4sJCIkVw==",
            "dev": true,
            "requires": {}
        },
        "negotiator": {
            "version": "0.6.3",
            "resolved": "https://registry.npmjs.org/negotiator/-/negotiator-0.6.3.tgz",
            "integrity": "sha512-+EUsqGPLsM+j/zdChZjsnX51g4XrHFOIXwfnCVPGlQk/k5giakcKsuxCObBRu6DSm9opw/O6slWbJdghQM4bBg==",
            "dev": true
        },
        "no-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/no-case/-/no-case-3.0.4.tgz",
            "integrity": "sha512-fgAN3jGAh+RoxUGZHTSOLJIqUc2wmoBwGR4tbpNAKmmovFoWq0OdRkb0VkldReO2a2iBT/OEulG9XSUc10r3zg==",
            "dev": true,
            "requires": {
                "lower-case": "^2.0.2",
                "tslib": "^2.0.3"
            }
        },
        "node-fetch": {
            "version": "npm:@achingbrain/node-fetch@2.6.7",
            "dev": true
        },
        "node-releases": {
            "version": "2.0.3",
            "resolved": "https://registry.npmjs.org/node-releases/-/node-releases-2.0.3.tgz",
            "integrity": "sha512-maHFz6OLqYxz+VQyCAtA3PTX4UP/53pa05fyDNc9CwjvJ0yEh6+xBwKsgCxMNhS8taUKBFYxfuiaD9U/55iFaw==",
            "dev": true
        },
        "normalize-path": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/normalize-path/-/normalize-path-3.0.0.tgz",
            "integrity": "sha512-6eZs5Ls3WtCisHWp9S2GUy8dqkpGi4BVSz3GaqiE6ezub0512ESztXUwUB6C6IKbQkY2Pnb/mD4WYojCRwcwLA==",
            "dev": true
        },
        "object-assign": {
            "version": "4.1.1",
            "resolved": "https://registry.npmjs.org/object-assign/-/object-assign-4.1.1.tgz",
            "integrity": "sha1-IQmtx5ZYh8/AXLvUQsrIv7s2CGM=",
            "dev": true
        },
        "object-inspect": {
            "version": "1.12.0",
            "resolved": "https://registry.npmjs.org/object-inspect/-/object-inspect-1.12.0.tgz",
            "integrity": "sha512-Ho2z80bVIvJloH+YzRmpZVQe87+qASmBUKZDWgx9cu+KDrX2ZDH/3tMy+gXbZETVGs2M8YdxObOh7XAtim9Y0g==",
            "dev": true
        },
        "on-finished": {
            "version": "2.4.1",
            "resolved": "https://registry.npmjs.org/on-finished/-/on-finished-2.4.1.tgz",
            "integrity": "sha512-oVlzkg3ENAhCk2zdv7IJwd/QUD4z2RxRwpkcGY8psCVcCYZNq4wYnVWALHM+brtuJjePWiYF/ClmuDr8Ch5+kg==",
            "dev": true,
            "requires": {
                "ee-first": "1.1.1"
            }
        },
        "once": {
            "version": "1.4.0",
            "resolved": "https://registry.npmjs.org/once/-/once-1.4.0.tgz",
            "integrity": "sha1-WDsap3WWHUsROsF9nFC6753Xa9E=",
            "dev": true,
            "requires": {
                "wrappy": "1"
            }
        },
        "opener": {
            "version": "1.5.2",
            "resolved": "https://registry.npmjs.org/opener/-/opener-1.5.2.tgz",
            "integrity": "sha512-ur5UIdyw5Y7yEj9wLzhqXiy6GZ3Mwx0yGI+5sMn2r0N0v3cKJvUmFH5yPP+WXh9e0xfyzyJX95D8l088DNFj7A==",
            "dev": true
        },
        "p-defer": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/p-defer/-/p-defer-3.0.0.tgz",
            "integrity": "sha512-ugZxsxmtTln604yeYd29EGrNhazN2lywetzpKhfmQjW/VJmhpDmWbiX+h0zL8V91R0UXkhb3KtPmyq9PZw3aYw==",
            "dev": true
        },
        "p-fifo": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/p-fifo/-/p-fifo-1.0.0.tgz",
            "integrity": "sha512-IjoCxXW48tqdtDFz6fqo5q1UfFVjjVZe8TC1QRflvNUJtNfCUhxOUw6MOVZhDPjqhSzc26xKdugsO17gmzd5+A==",
            "dev": true,
            "requires": {
                "fast-fifo": "^1.0.0",
                "p-defer": "^3.0.0"
            }
        },
        "p-limit": {
            "version": "3.1.0",
            "resolved": "https://registry.npmjs.org/p-limit/-/p-limit-3.1.0.tgz",
            "integrity": "sha512-TYOanM3wGwNGsZN2cVTYPArw454xnXj5qmWF1bEoAc4+cU/ol7GVh7odevjp1FNHduHc3KZMcFduxU5Xc6uJRQ==",
            "dev": true,
            "requires": {
                "yocto-queue": "^0.1.0"
            }
        },
        "p-locate": {
            "version": "5.0.0",
            "resolved": "https://registry.npmjs.org/p-locate/-/p-locate-5.0.0.tgz",
            "integrity": "sha512-LaNjtRWUBY++zB5nE/NwcaoMylSPk+S+ZHNB1TzdbMJMny6dynpAGt7X/tl/QYq3TIeE6nxHppbo2LGymrG5Pw==",
            "dev": true,
            "requires": {
                "p-limit": "^3.0.2"
            }
        },
        "p-map": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/p-map/-/p-map-4.0.0.tgz",
            "integrity": "sha512-/bjOqmgETBYB5BoEeGVea8dmvHb2m9GLy1E9W43yeyfP6QQCZGFNa+XRceJEuDB6zqr+gKpIAmlLebMpykw/MQ==",
            "dev": true,
            "requires": {
                "aggregate-error": "^3.0.0"
            }
        },
        "param-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/param-case/-/param-case-3.0.4.tgz",
            "integrity": "sha512-RXlj7zCYokReqWpOPH9oYivUzLYZ5vAPIfEmCTNViosC78F8F0H9y7T7gG2M39ymgutxF5gcFEsyZQSph9Bp3A==",
            "dev": true,
            "requires": {
                "dot-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "parse-duration": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/parse-duration/-/parse-duration-1.0.2.tgz",
            "integrity": "sha512-Dg27N6mfok+ow1a2rj/nRjtCfaKrHUZV2SJpEn/s8GaVUSlf4GGRCRP1c13Hj+wfPKVMrFDqLMLITkYKgKxyyg==",
            "dev": true
        },
        "parse5": {
            "version": "6.0.1",
            "resolved": "https://registry.npmjs.org/parse5/-/parse5-6.0.1.tgz",
            "integrity": "sha512-Ofn/CTFzRGTTxwpNEs9PP93gXShHcTq255nzRYSKe8AkVpZY7e1fpmTfOyoIvjP5HG7Z2ZM7VS9PPhQGW2pOpw==",
            "dev": true
        },
        "parseurl": {
            "version": "1.3.3",
            "resolved": "https://registry.npmjs.org/parseurl/-/parseurl-1.3.3.tgz",
            "integrity": "sha512-CiyeOxFT/JZyN5m0z9PfXw4SCBJ6Sygz1Dpl0wqjlhDEGGBP1GnsUVEL0p63hoG1fcj3fHynXi9NYO4nWOL+qQ==",
            "dev": true
        },
        "pascal-case": {
            "version": "3.1.2",
            "resolved": "https://registry.npmjs.org/pascal-case/-/pascal-case-3.1.2.tgz",
            "integrity": "sha512-uWlGT3YSnK9x3BQJaOdcZwrnV6hPpd8jFH1/ucpiLRPh/2zCVJKS19E4GvYHvaCcACn3foXZ0cLB9Wrx1KGe5g==",
            "dev": true,
            "requires": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "path-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/path-case/-/path-case-3.0.4.tgz",
            "integrity": "sha512-qO4qCFjXqVTrcbPt/hQfhTQ+VhFsqNKOPtytgNKkKxSoEp3XPUQ8ObFuePylOIok5gjn69ry8XiULxCwot3Wfg==",
            "dev": true,
            "requires": {
                "dot-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "path-exists": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/path-exists/-/path-exists-4.0.0.tgz",
            "integrity": "sha512-ak9Qy5Q7jYb2Wwcey5Fpvg2KoAc/ZIhLSLOSBmRmygPsGwkVVt0fZa0qrtMz+m6tJTAHfZQ8FnmB4MG4LWy7/w==",
            "dev": true
        },
        "path-is-absolute": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/path-is-absolute/-/path-is-absolute-1.0.1.tgz",
            "integrity": "sha1-F0uSaHNVNP+8es5r9TpanhtcX18=",
            "dev": true
        },
        "pathval": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/pathval/-/pathval-1.1.1.tgz",
            "integrity": "sha512-Dp6zGqpTdETdR63lehJYPeIOqpiNBNtc7BpWSLrOje7UaIsE5aY92r/AunQA7rsXvet3lrJ3JnZX29UPTKXyKQ==",
            "dev": true
        },
        "picocolors": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/picocolors/-/picocolors-1.0.0.tgz",
            "integrity": "sha512-1fygroTLlHu66zi26VoTDv8yRgm0Fccecssto+MhsZ0D/DGW2sm8E8AjW7NU5VVTRt5GxbeZ5qBuJr+HyLYkjQ==",
            "dev": true
        },
        "picomatch": {
            "version": "2.3.1",
            "resolved": "https://registry.npmjs.org/picomatch/-/picomatch-2.3.1.tgz",
            "integrity": "sha512-JU3teHTNjmE2VCGFzuY8EXzCDVwEqB2a8fsIvwaStHhAWJEeVd1o1QD80CU6+ZdEXXSLbSsuLwJjkCBWqRQUVA==",
            "dev": true
        },
        "portfinder": {
            "version": "1.0.28",
            "resolved": "https://registry.npmjs.org/portfinder/-/portfinder-1.0.28.tgz",
            "integrity": "sha512-Se+2isanIcEqf2XMHjyUKskczxbPH7dQnlMjXX6+dybayyHvAf/TCgyMRlzf/B6QDhAEFOGes0pzRo3by4AbMA==",
            "dev": true,
            "requires": {
                "async": "^2.6.2",
                "debug": "^3.1.1",
                "mkdirp": "^0.5.5"
            },
            "dependencies": {
                "debug": {
                    "version": "3.2.7",
                    "resolved": "https://registry.npmjs.org/debug/-/debug-3.2.7.tgz",
                    "integrity": "sha512-CFjzYYAi4ThfiQvizrFQevTTXHtnCqWfe7x1AhgEscTz6ZbLbfoLRLPugTQyBth6f8ZERVUSyWHFD/7Wu4t1XQ==",
                    "dev": true,
                    "requires": {
                        "ms": "^2.1.1"
                    }
                },
                "mkdirp": {
                    "version": "0.5.6",
                    "resolved": "https://registry.npmjs.org/mkdirp/-/mkdirp-0.5.6.tgz",
                    "integrity": "sha512-FP+p8RB8OWpF3YZBCrP5gtADmtXApB5AMLn+vdyA+PyxCjrCs00mjyUozssO33cwDeT3wNGdLxJ5M//YqtHAJw==",
                    "dev": true,
                    "requires": {
                        "minimist": "^1.2.6"
                    }
                }
            }
        },
        "promise-inflight": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/promise-inflight/-/promise-inflight-1.0.1.tgz",
            "integrity": "sha1-mEcocL8igTL8vdhoEputEsPAKeM=",
            "dev": true
        },
        "promise-retry": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/promise-retry/-/promise-retry-2.0.1.tgz",
            "integrity": "sha512-y+WKFlBR8BGXnsNlIHFGPZmyDf3DFMoLhaflAnyZgV6rG6xu+JwesTo2Q9R6XwYmtmwAFCkAk3e35jEdoeh/3g==",
            "dev": true,
            "requires": {
                "err-code": "^2.0.2",
                "retry": "^0.12.0"
            },
            "dependencies": {
                "err-code": {
                    "version": "2.0.3",
                    "resolved": "https://registry.npmjs.org/err-code/-/err-code-2.0.3.tgz",
                    "integrity": "sha512-2bmlRpNKBxT/CRmPOlyISQpNj+qSeYvcym/uT0Jx2bMOlKLtSy1ZmLuVxSEKKyor/N5yhvp/ZiG1oE3DEYMSFA==",
                    "dev": true
                }
            }
        },
        "protobufjs": {
            "version": "6.11.2",
            "resolved": "https://registry.npmjs.org/protobufjs/-/protobufjs-6.11.2.tgz",
            "integrity": "sha512-4BQJoPooKJl2G9j3XftkIXjoC9C0Av2NOrWmbLWT1vH32GcSUHjM0Arra6UfTsVyfMAuFzaLucXn1sadxJydAw==",
            "dev": true,
            "requires": {
                "@protobufjs/aspromise": "^1.1.2",
                "@protobufjs/base64": "^1.1.2",
                "@protobufjs/codegen": "^2.0.4",
                "@protobufjs/eventemitter": "^1.1.0",
                "@protobufjs/fetch": "^1.1.0",
                "@protobufjs/float": "^1.0.2",
                "@protobufjs/inquire": "^1.1.0",
                "@protobufjs/path": "^1.1.2",
                "@protobufjs/pool": "^1.1.0",
                "@protobufjs/utf8": "^1.1.0",
                "@types/long": "^4.0.1",
                "@types/node": ">=13.7.0",
                "long": "^4.0.0"
            },
            "dependencies": {
                "@types/node": {
                    "version": "17.0.27",
                    "resolved": "https://registry.npmjs.org/@types/node/-/node-17.0.27.tgz",
                    "integrity": "sha512-4/Ke7bbWOasuT3kceBZFGakP1dYN2XFd8v2l9bqF2LNWrmeU07JLpp56aEeG6+Q3olqO5TvXpW0yaiYnZJ5CXg==",
                    "dev": true
                }
            }
        },
        "qjobs": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/qjobs/-/qjobs-1.2.0.tgz",
            "integrity": "sha512-8YOJEHtxpySA3fFDyCRxA+UUV+fA+rTWnuWvylOK/NCjhY+b4ocCtmu8TtsWb+mYeU+GCHf/S66KZF/AsteKHg==",
            "dev": true
        },
        "qs": {
            "version": "6.10.3",
            "resolved": "https://registry.npmjs.org/qs/-/qs-6.10.3.tgz",
            "integrity": "sha512-wr7M2E0OFRfIfJZjKGieI8lBKb7fRCH4Fv5KNPEs7gJ8jadvotdsS08PzOKR7opXhZ/Xkjtt3WF9g38drmyRqQ==",
            "dev": true,
            "requires": {
                "side-channel": "^1.0.4"
            }
        },
        "randombytes": {
            "version": "2.1.0",
            "resolved": "https://registry.npmjs.org/randombytes/-/randombytes-2.1.0.tgz",
            "integrity": "sha512-vYl3iOX+4CKUWuxGi9Ukhie6fsqXqS9FE2Zaic4tNFD2N2QQaXOMFbuKK4QmDHC0JO6B1Zp41J0LpT0oR68amQ==",
            "dev": true,
            "requires": {
                "safe-buffer": "^5.1.0"
            },
            "dependencies": {
                "safe-buffer": {
                    "version": "5.2.1",
                    "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
                    "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
                    "dev": true
                }
            }
        },
        "range-parser": {
            "version": "1.2.1",
            "resolved": "https://registry.npmjs.org/range-parser/-/range-parser-1.2.1.tgz",
            "integrity": "sha512-Hrgsx+orqoygnmhFbKaHE6c296J+HTAQXoxEF6gNupROmmGJRoyzfG3ccAveqCBrwr/2yxQ5BVd/GTl5agOwSg==",
            "dev": true
        },
        "raw-body": {
            "version": "2.5.1",
            "resolved": "https://registry.npmjs.org/raw-body/-/raw-body-2.5.1.tgz",
            "integrity": "sha512-qqJBtEyVgS0ZmPGdCFPWJ3FreoqvG4MVQln/kCgF7Olq95IbOp0/BWyMwbdtn4VTvkM8Y7khCQ2Xgk/tcrCXig==",
            "dev": true,
            "requires": {
                "bytes": "3.1.2",
                "http-errors": "2.0.0",
                "iconv-lite": "0.4.24",
                "unpipe": "1.0.0"
            }
        },
        "react-native-fetch-api": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/react-native-fetch-api/-/react-native-fetch-api-2.0.0.tgz",
            "integrity": "sha512-GOA8tc1EVYLnHvma/TU9VTgLOyralO7eATRuCDchQveXW9Fr9vXygyq9iwqmM7YRZ8qRJfEt9xOS7OYMdJvRFw==",
            "dev": true,
            "requires": {
                "p-defer": "^3.0.0"
            }
        },
        "readable-stream": {
            "version": "3.6.0",
            "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.0.tgz",
            "integrity": "sha512-BViHy7LKeTz4oNnkcLJ+lVSL6vpiFeX6/d3oSH8zCW7UxP2onchk+vTGB143xuFjHS3deTgkKoXXymXqymiIdA==",
            "dev": true,
            "requires": {
                "inherits": "^2.0.3",
                "string_decoder": "^1.1.1",
                "util-deprecate": "^1.0.1"
            }
        },
        "readdirp": {
            "version": "3.6.0",
            "resolved": "https://registry.npmjs.org/readdirp/-/readdirp-3.6.0.tgz",
            "integrity": "sha512-hOS089on8RduqdbhvQ5Z37A0ESjsqz6qnRcffsMU3495FuTdqSm+7bhJ29JvIOsBDEEnan5DPu9t3To9VRlMzA==",
            "dev": true,
            "requires": {
                "picomatch": "^2.2.1"
            }
        },
        "receptacle": {
            "version": "1.3.2",
            "resolved": "https://registry.npmjs.org/receptacle/-/receptacle-1.3.2.tgz",
            "integrity": "sha512-HrsFvqZZheusncQRiEE7GatOAETrARKV/lnfYicIm8lbvp/JQOdADOfhjBd2DajvoszEyxSM6RlAAIZgEoeu/A==",
            "dev": true,
            "requires": {
                "ms": "^2.1.1"
            }
        },
        "relateurl": {
            "version": "0.2.7",
            "resolved": "https://registry.npmjs.org/relateurl/-/relateurl-0.2.7.tgz",
            "integrity": "sha1-VNvzd+UUQKypCkzSdGANP/LYiKk=",
            "dev": true
        },
        "require-directory": {
            "version": "2.1.1",
            "resolved": "https://registry.npmjs.org/require-directory/-/require-directory-2.1.1.tgz",
            "integrity": "sha1-jGStX9MNqxyXbiNE/+f3kqam30I=",
            "dev": true
        },
        "requires-port": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/requires-port/-/requires-port-1.0.0.tgz",
            "integrity": "sha1-kl0mAdOaxIXgkc8NpcbmlNw9yv8=",
            "dev": true
        },
        "retimer": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/retimer/-/retimer-3.0.0.tgz",
            "integrity": "sha512-WKE0j11Pa0ZJI5YIk0nflGI7SQsfl2ljihVy7ogh7DeQSeYAUi0ubZ/yEueGtDfUPk6GH5LRw1hBdLq4IwUBWA==",
            "dev": true
        },
        "retry": {
            "version": "0.12.0",
            "resolved": "https://registry.npmjs.org/retry/-/retry-0.12.0.tgz",
            "integrity": "sha1-G0KmJmoh8HQh0bC1S33BZ7AcATs=",
            "dev": true
        },
        "rfdc": {
            "version": "1.3.0",
            "resolved": "https://registry.npmjs.org/rfdc/-/rfdc-1.3.0.tgz",
            "integrity": "sha512-V2hovdzFbOi77/WajaSMXk2OLm+xNIeQdMMuB7icj7bk6zi2F8GGAxigcnDFpJHbNyNcgyJDiP+8nOrY5cZGrA==",
            "dev": true
        },
        "rimraf": {
            "version": "3.0.2",
            "resolved": "https://registry.npmjs.org/rimraf/-/rimraf-3.0.2.tgz",
            "integrity": "sha512-JZkJMZkAGFFPP2YqXZXPbMlMBgsxzE8ILs4lMIX/2o0L9UBw9O/Y3o6wFw/i9YLapcUJWwqbi3kdxIPdC62TIA==",
            "dev": true,
            "requires": {
                "glob": "^7.1.3"
            }
        },
        "rollup": {
            "version": "2.70.2",
            "resolved": "https://registry.npmjs.org/rollup/-/rollup-2.70.2.tgz",
            "integrity": "sha512-EitogNZnfku65I1DD5Mxe8JYRUCy0hkK5X84IlDtUs+O6JRMpRciXTzyCUuX11b5L5pvjH+OmFXiQ3XjabcXgg==",
            "dev": true,
            "requires": {
                "fsevents": "~2.3.2"
            }
        },
        "rollup-plugin-terser": {
            "version": "7.0.2",
            "resolved": "https://registry.npmjs.org/rollup-plugin-terser/-/rollup-plugin-terser-7.0.2.tgz",
            "integrity": "sha512-w3iIaU4OxcF52UUXiZNsNeuXIMDvFrr+ZXK6bFZ0Q60qyVfq4uLptoS4bbq3paG3x216eQllFZX7zt6TIImguQ==",
            "dev": true,
            "requires": {
                "@babel/code-frame": "^7.10.4",
                "jest-worker": "^26.2.1",
                "serialize-javascript": "^4.0.0",
                "terser": "^5.0.0"
            },
            "dependencies": {
                "serialize-javascript": {
                    "version": "4.0.0",
                    "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-4.0.0.tgz",
                    "integrity": "sha512-GaNA54380uFefWghODBWEGisLZFj00nS5ACs6yHa9nLqlLpVLO8ChDGeKRjZnV4Nh4n0Qi7nhYZD/9fCPzEqkw==",
                    "dev": true,
                    "requires": {
                        "randombytes": "^2.1.0"
                    }
                }
            }
        },
        "safe-buffer": {
            "version": "5.1.2",
            "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.1.2.tgz",
            "integrity": "sha512-Gd2UZBJDkXlY7GbJxfsE8/nvKkUEU1G38c1siN6QP6a9PT9MmHB8GnpscSmMJSoF8LOIrt8ud/wPtojys4G6+g==",
            "dev": true
        },
        "safer-buffer": {
            "version": "2.1.2",
            "resolved": "https://registry.npmjs.org/safer-buffer/-/safer-buffer-2.1.2.tgz",
            "integrity": "sha512-YZo3K82SD7Riyi0E1EQPojLz7kpepnSQI9IyPbHHg1XXXevb5dJI7tpyN2ADxGcQbHG7vcyRHk0cbwqcQriUtg==",
            "dev": true
        },
        "secure-compare": {
            "version": "3.0.1",
            "resolved": "https://registry.npmjs.org/secure-compare/-/secure-compare-3.0.1.tgz",
            "integrity": "sha1-8aAymzCLIh+uN7mXTz1XjQypmeM=",
            "dev": true
        },
        "semver": {
            "version": "6.3.0",
            "resolved": "https://registry.npmjs.org/semver/-/semver-6.3.0.tgz",
            "integrity": "sha512-b39TBaTSfV6yBrapU89p5fKekE2m/NwnDocOVruQFS1/veMgdzuPcnOM34M6CwxW8jH/lxEa5rBoDeUwu5HHTw==",
            "dev": true
        },
        "sentence-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/sentence-case/-/sentence-case-3.0.4.tgz",
            "integrity": "sha512-8LS0JInaQMCRoQ7YUytAo/xUu5W2XnQxV2HI/6uM6U7CITS1RqPElr30V6uIqyMKM9lJGRVFy5/4CuzcixNYSg==",
            "dev": true,
            "requires": {
                "no-case": "^3.0.4",
                "tslib": "^2.0.3",
                "upper-case-first": "^2.0.2"
            }
        },
        "serialize-javascript": {
            "version": "6.0.0",
            "resolved": "https://registry.npmjs.org/serialize-javascript/-/serialize-javascript-6.0.0.tgz",
            "integrity": "sha512-Qr3TosvguFt8ePWqsvRfrKyQXIiW+nGbYpy8XK24NQHE83caxWt+mIymTT19DGFbNWNLfEwsrkSmN64lVWB9ag==",
            "dev": true,
            "requires": {
                "randombytes": "^2.1.0"
            }
        },
        "setprototypeof": {
            "version": "1.2.0",
            "resolved": "https://registry.npmjs.org/setprototypeof/-/setprototypeof-1.2.0.tgz",
            "integrity": "sha512-E5LDX7Wrp85Kil5bhZv46j8jOeboKq5JMmYM3gVGdGH8xFpPWXUMsNrlODCrkoxMEeNi/XZIwuRvY4XNwYMJpw==",
            "dev": true
        },
        "side-channel": {
            "version": "1.0.4",
            "resolved": "https://registry.npmjs.org/side-channel/-/side-channel-1.0.4.tgz",
            "integrity": "sha512-q5XPytqFEIKHkGdiMIrY10mvLRvnQh42/+GoBlFW3b2LXLE2xxJpZFdm94we0BaoV3RwJyGqg5wS7epxTv0Zvw==",
            "dev": true,
            "requires": {
                "call-bind": "^1.0.0",
                "get-intrinsic": "^1.0.2",
                "object-inspect": "^1.9.0"
            }
        },
        "smart-buffer": {
            "version": "4.2.0",
            "resolved": "https://registry.npmjs.org/smart-buffer/-/smart-buffer-4.2.0.tgz",
            "integrity": "sha512-94hK0Hh8rPqQl2xXc3HsaBoOXKV20MToPkcXvwbISWLEs+64sBq5kFgn2kJDHb1Pry9yrP0dxrCI9RRci7RXKg==",
            "dev": true
        },
        "snake-case": {
            "version": "3.0.4",
            "resolved": "https://registry.npmjs.org/snake-case/-/snake-case-3.0.4.tgz",
            "integrity": "sha512-LAOh4z89bGQvl9pFfNF8V146i7o7/CqFPbqzYgP+yYzDIDeS9HaNFtXABamRW+AQzEVODcvE79ljJ+8a9YSdMg==",
            "dev": true,
            "requires": {
                "dot-case": "^3.0.4",
                "tslib": "^2.0.3"
            }
        },
        "socket.io": {
            "version": "4.5.0",
            "resolved": "https://registry.npmjs.org/socket.io/-/socket.io-4.5.0.tgz",
            "integrity": "sha512-slTYqU2jCgMjXwresG8grhUi/cC6GjzmcfqArzaH3BN/9I/42eZk9yamNvZJdBfTubkjEdKAKs12NEztId+bUA==",
            "dev": true,
            "requires": {
                "accepts": "~1.3.4",
                "base64id": "~2.0.0",
                "debug": "~4.3.2",
                "engine.io": "~6.2.0",
                "socket.io-adapter": "~2.4.0",
                "socket.io-parser": "~4.0.4"
            }
        },
        "socket.io-adapter": {
            "version": "2.4.0",
            "resolved": "https://registry.npmjs.org/socket.io-adapter/-/socket.io-adapter-2.4.0.tgz",
            "integrity": "sha512-W4N+o69rkMEGVuk2D/cvca3uYsvGlMwsySWV447y99gUPghxq42BxqLNMndb+a1mm/5/7NeXVQS7RLa2XyXvYg==",
            "dev": true
        },
        "socket.io-parser": {
            "version": "4.0.4",
            "resolved": "https://registry.npmjs.org/socket.io-parser/-/socket.io-parser-4.0.4.tgz",
            "integrity": "sha512-t+b0SS+IxG7Rxzda2EVvyBZbvFPBCjJoyHuE0P//7OAsN23GItzDRdWa6ALxZI/8R5ygK7jAR6t028/z+7295g==",
            "dev": true,
            "requires": {
                "@types/component-emitter": "^1.2.10",
                "component-emitter": "~1.3.0",
                "debug": "~4.3.1"
            }
        },
        "socks": {
            "version": "2.6.2",
            "resolved": "https://registry.npmjs.org/socks/-/socks-2.6.2.tgz",
            "integrity": "sha512-zDZhHhZRY9PxRruRMR7kMhnf3I8hDs4S3f9RecfnGxvcBHQcKcIH/oUcEWffsfl1XxdYlA7nnlGbbTvPz9D8gA==",
            "dev": true,
            "requires": {
                "ip": "^1.1.5",
                "smart-buffer": "^4.2.0"
            }
        },
        "socks-proxy-agent": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/socks-proxy-agent/-/socks-proxy-agent-5.0.1.tgz",
            "integrity": "sha512-vZdmnjb9a2Tz6WEQVIurybSwElwPxMZaIc7PzqbJTrezcKNznv6giT7J7tZDZ1BojVaa1jvO/UiUdhDVB0ACoQ==",
            "dev": true,
            "requires": {
                "agent-base": "^6.0.2",
                "debug": "4",
                "socks": "^2.3.3"
            }
        },
        "source-map": {
            "version": "0.6.1",
            "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.6.1.tgz",
            "integrity": "sha512-UjgapumWlbMhkBgzT7Ykc5YXUT46F0iKu8SGXq0bcwP5dz/h0Plj6enJqjz1Zbq2l5WaqYnrVbwWOWMyF3F47g==",
            "dev": true
        },
        "source-map-support": {
            "version": "0.5.21",
            "resolved": "https://registry.npmjs.org/source-map-support/-/source-map-support-0.5.21.tgz",
            "integrity": "sha512-uBHU3L3czsIyYXKX88fdrGovxdSCoTGDRZ6SYXtSRxLZUzHg5P/66Ht6uoUlHu9EZod+inXhKo3qQgwXUT/y1w==",
            "dev": true,
            "requires": {
                "buffer-from": "^1.0.0",
                "source-map": "^0.6.0"
            }
        },
        "sourcemap-codec": {
            "version": "1.4.8",
            "resolved": "https://registry.npmjs.org/sourcemap-codec/-/sourcemap-codec-1.4.8.tgz",
            "integrity": "sha512-9NykojV5Uih4lgo5So5dtw+f0JgJX30KCNI8gwhz2J9A15wD0Ml6tjHKwf6fTSa6fAdVBdZeNOs9eJ71qCk8vA==",
            "dev": true
        },
        "ssri": {
            "version": "8.0.1",
            "resolved": "https://registry.npmjs.org/ssri/-/ssri-8.0.1.tgz",
            "integrity": "sha512-97qShzy1AiyxvPNIkLWoGua7xoQzzPjQ0HAH4B0rWKo7SZ6USuPcrUiAFrws0UH8RrbWmgq3LMTObhPIHbbBeQ==",
            "dev": true,
            "requires": {
                "minipass": "^3.1.1"
            }
        },
        "statuses": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/statuses/-/statuses-2.0.1.tgz",
            "integrity": "sha512-RwNA9Z/7PrK06rYLIzFMlaF+l73iwpzsqRIFgbMLbTcLD6cOao82TaWefPXQvB2fOC4AjuYSEndS7N/mTCbkdQ==",
            "dev": true
        },
        "stream-to-it": {
            "version": "0.2.4",
            "resolved": "https://registry.npmjs.org/stream-to-it/-/stream-to-it-0.2.4.tgz",
            "integrity": "sha512-4vEbkSs83OahpmBybNJXlJd7d6/RxzkkSdT3I0mnGt79Xd2Kk+e1JqbvAvsQfCeKj3aKb0QIWkyK3/n0j506vQ==",
            "dev": true,
            "requires": {
                "get-iterator": "^1.0.2"
            }
        },
        "streamroller": {
            "version": "3.0.8",
            "resolved": "https://registry.npmjs.org/streamroller/-/streamroller-3.0.8.tgz",
            "integrity": "sha512-VI+ni3czbFZrd1MrlybxykWZ8sMDCMtTU7YJyhgb9M5X6d1DDxLdJr+gSnmRpXPMnIWxWKMaAE8K0WumBp3lDg==",
            "dev": true,
            "requires": {
                "date-format": "^4.0.9",
                "debug": "^4.3.4",
                "fs-extra": "^10.1.0"
            }
        },
        "string_decoder": {
            "version": "1.3.0",
            "resolved": "https://registry.npmjs.org/string_decoder/-/string_decoder-1.3.0.tgz",
            "integrity": "sha512-hkRX8U1WjJFd8LsDJ2yQ/wWWxaopEsABU1XfkM8A+j0+85JAGppt16cr1Whg6KIbb4okU6Mql6BOj+uup/wKeA==",
            "dev": true,
            "requires": {
                "safe-buffer": "~5.2.0"
            },
            "dependencies": {
                "safe-buffer": {
                    "version": "5.2.1",
                    "resolved": "https://registry.npmjs.org/safe-buffer/-/safe-buffer-5.2.1.tgz",
                    "integrity": "sha512-rp3So07KcdmmKbGvgaNxQSJr7bGVSVk5S9Eq1F+ppbRo70+YeaDxkw5Dd8NPN+GD6bjnYm2VuPuCXmpuYvmCXQ==",
                    "dev": true
                }
            }
        },
        "string-width": {
            "version": "4.2.3",
            "resolved": "https://registry.npmjs.org/string-width/-/string-width-4.2.3.tgz",
            "integrity": "sha512-wKyQRQpjJ0sIp62ErSZdGsjMJWsap5oRNihHhu6G7JVO/9jIB6UyevL+tXuOqrng8j/cxKTWyWUwvSTriiZz/g==",
            "dev": true,
            "requires": {
                "emoji-regex": "^8.0.0",
                "is-fullwidth-code-point": "^3.0.0",
                "strip-ansi": "^6.0.1"
            }
        },
        "strip-ansi": {
            "version": "6.0.1",
            "resolved": "https://registry.npmjs.org/strip-ansi/-/strip-ansi-6.0.1.tgz",
            "integrity": "sha512-Y38VPSHcqkFrCpFnQ9vuSXmquuv5oXOKpGeT6aGrr3o3Gc9AlVa6JBfUSOCnbxGGZF+/0ooI7KrPuUSztUdU5A==",
            "dev": true,
            "requires": {
                "ansi-regex": "^5.0.1"
            }
        },
        "strip-json-comments": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/strip-json-comments/-/strip-json-comments-3.1.1.tgz",
            "integrity": "sha512-6fPc+R4ihwqP6N/aIv2f1gMH8lOVtWQHoqC4yK6oSDVVocumAsfCqjkXnqiYMhmMwS/mEHLp7Vehlt3ql6lEig==",
            "dev": true
        },
        "style-mod": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/style-mod/-/style-mod-4.0.0.tgz",
            "integrity": "sha512-OPhtyEjyyN9x3nhPsu76f52yUGXiZcgvsrFVtvTkyGRQJ0XK+GPc6ov1z+lRpbeabka+MYEQxOYRnt5nF30aMw=="
        },
        "supports-color": {
            "version": "7.2.0",
            "resolved": "https://registry.npmjs.org/supports-color/-/supports-color-7.2.0.tgz",
            "integrity": "sha512-qpCAvRl9stuOHveKsn7HncJRvv501qIacKzQlO/+Lwxc9+0q2wLyv4Dfvt80/DPn2pqOBsJdDiogXGR9+OvwRw==",
            "dev": true,
            "requires": {
                "has-flag": "^4.0.0"
            }
        },
        "sver": {
            "version": "1.8.3",
            "resolved": "https://registry.npmjs.org/sver/-/sver-1.8.3.tgz",
            "integrity": "sha512-Qn39MggkkPw3d1BACWNV+Njwt9L0znk8oNW8NlJv4lWTEseMzbjHzunnPJDnt/5mfLHV5kt5JkMTqPbMVrg2CA==",
            "dev": true,
            "requires": {
                "semver": "^6.3.0"
            }
        },
        "tar": {
            "version": "6.1.11",
            "resolved": "https://registry.npmjs.org/tar/-/tar-6.1.11.tgz",
            "integrity": "sha512-an/KZQzQUkZCkuoAA64hM92X0Urb6VpRhAFllDzz44U2mcD5scmT3zBc4VgVpkugF580+DQn8eAFSyoQt0tznA==",
            "dev": true,
            "requires": {
                "chownr": "^2.0.0",
                "fs-minipass": "^2.0.0",
                "minipass": "^3.0.0",
                "minizlib": "^2.1.1",
                "mkdirp": "^1.0.3",
                "yallist": "^4.0.0"
            }
        },
        "terser": {
            "version": "5.12.1",
            "resolved": "https://registry.npmjs.org/terser/-/terser-5.12.1.tgz",
            "integrity": "sha512-NXbs+7nisos5E+yXwAD+y7zrcTkMqb0dEJxIGtSKPdCBzopf7ni4odPul2aechpV7EXNvOudYOX2bb5tln1jbQ==",
            "dev": true,
            "requires": {
                "acorn": "^8.5.0",
                "commander": "^2.20.0",
                "source-map": "~0.7.2",
                "source-map-support": "~0.5.20"
            },
            "dependencies": {
                "source-map": {
                    "version": "0.7.3",
                    "resolved": "https://registry.npmjs.org/source-map/-/source-map-0.7.3.tgz",
                    "integrity": "sha512-CkCj6giN3S+n9qrYiBTX5gystlENnRW5jZeNLHpe6aue+SrHcG5VYwujhW9s4dY31mEGsxBDrHR6oI69fTXsaQ==",
                    "dev": true
                }
            }
        },
        "timeout-abort-controller": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/timeout-abort-controller/-/timeout-abort-controller-3.0.0.tgz",
            "integrity": "sha512-O3e+2B8BKrQxU2YRyEjC/2yFdb33slI22WRdUaDx6rvysfi9anloNZyR2q0l6LnePo5qH7gSM7uZtvvwZbc2yA==",
            "dev": true,
            "requires": {
                "retimer": "^3.0.0"
            }
        },
        "tmp": {
            "version": "0.2.1",
            "resolved": "https://registry.npmjs.org/tmp/-/tmp-0.2.1.tgz",
            "integrity": "sha512-76SUhtfqR2Ijn+xllcI5P1oyannHNHByD80W1q447gU3mp9G9PSpGdWmjUOHRDPiHYacIk66W7ubDTuPF3BEtQ==",
            "dev": true,
            "requires": {
                "rimraf": "^3.0.0"
            }
        },
        "to-fast-properties": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/to-fast-properties/-/to-fast-properties-2.0.0.tgz",
            "integrity": "sha1-3F5pjL0HkmW8c+A3doGk5Og/YW4=",
            "dev": true
        },
        "to-regex-range": {
            "version": "5.0.1",
            "resolved": "https://registry.npmjs.org/to-regex-range/-/to-regex-range-5.0.1.tgz",
            "integrity": "sha512-65P7iz6X5yEr1cwcgvQxbbIw7Uk3gOy5dIdtZ4rDveLqhrdJP+Li/Hx6tyK0NEb+2GCyneCMJiGqrADCSNk8sQ==",
            "dev": true,
            "requires": {
                "is-number": "^7.0.0"
            }
        },
        "toidentifier": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/toidentifier/-/toidentifier-1.0.1.tgz",
            "integrity": "sha512-o5sSPKEkg/DIQNmH43V0/uerLrpzVedkUh8tGNvaeXpfpuwjKenlSox/2O/BTlZUtEe+JG7s5YhEz608PlAHRA==",
            "dev": true
        },
        "tslib": {
            "version": "2.4.0",
            "resolved": "https://registry.npmjs.org/tslib/-/tslib-2.4.0.tgz",
            "integrity": "sha512-d6xOpEDfsi2CZVlPQzGeux8XMwLT9hssAsaPYExaQMuYskwb+x1x7J371tWlbBdWHroy99KnVB6qIkUbs5X3UQ=="
        },
        "type-detect": {
            "version": "4.0.8",
            "resolved": "https://registry.npmjs.org/type-detect/-/type-detect-4.0.8.tgz",
            "integrity": "sha512-0fr/mIH1dlO+x7TlcMy+bIDqKPsw/70tVyeHW787goQjhmqaZe10uwLujubK9q9Lg6Fiho1KUKDYz0Z7k7g5/g==",
            "dev": true
        },
        "type-is": {
            "version": "1.6.18",
            "resolved": "https://registry.npmjs.org/type-is/-/type-is-1.6.18.tgz",
            "integrity": "sha512-TkRKr9sUTxEH8MdfuCSP7VizJyzRNMjj2J2do2Jr3Kym598JVdEksuzPQCnlFPW4ky9Q+iA+ma9BGm06XQBy8g==",
            "dev": true,
            "requires": {
                "media-typer": "0.3.0",
                "mime-types": "~2.1.24"
            }
        },
        "typescript": {
            "version": "4.6.3",
            "resolved": "https://registry.npmjs.org/typescript/-/typescript-4.6.3.tgz",
            "integrity": "sha512-yNIatDa5iaofVozS/uQJEl3JRWLKKGJKh6Yaiv0GLGSuhpFJe7P3SbHZ8/yjAHRQwKRoA6YZqlfjXWmVzoVSMw==",
            "dev": true
        },
        "ua-parser-js": {
            "version": "0.7.31",
            "resolved": "https://registry.npmjs.org/ua-parser-js/-/ua-parser-js-0.7.31.tgz",
            "integrity": "sha512-qLK/Xe9E2uzmYI3qLeOmI0tEOt+TBBQyUIAh4aAgU05FVYzeZrKUdkAZfBNVGRaHVgV0TDkdEngJSw/SyQchkQ==",
            "dev": true
        },
        "uint8arrays": {
            "version": "3.0.0",
            "resolved": "https://registry.npmjs.org/uint8arrays/-/uint8arrays-3.0.0.tgz",
            "integrity": "sha512-HRCx0q6O9Bfbp+HHSfQQKD7wU70+lydKVt4EghkdOvlK/NlrF90z+eXV34mUd48rNvVJXwkrMSPpCATkct8fJA==",
            "dev": true,
            "requires": {
                "multiformats": "^9.4.2"
            }
        },
        "union": {
            "version": "0.5.0",
            "resolved": "https://registry.npmjs.org/union/-/union-0.5.0.tgz",
            "integrity": "sha512-N6uOhuW6zO95P3Mel2I2zMsbsanvvtgn6jVqJv4vbVcz/JN0OkL9suomjQGmWtxJQXOCqUJvquc1sMeNz/IwlA==",
            "dev": true,
            "requires": {
                "qs": "^6.4.0"
            }
        },
        "unique-filename": {
            "version": "1.1.1",
            "resolved": "https://registry.npmjs.org/unique-filename/-/unique-filename-1.1.1.tgz",
            "integrity": "sha512-Vmp0jIp2ln35UTXuryvjzkjGdRyf9b2lTXuSYUiPmzRcl3FDtYqAwOnTJkAngD9SWhnoJzDbTKwaOrZ+STtxNQ==",
            "dev": true,
            "requires": {
                "unique-slug": "^2.0.0"
            }
        },
        "unique-slug": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/unique-slug/-/unique-slug-2.0.2.tgz",
            "integrity": "sha512-zoWr9ObaxALD3DOPfjPSqxt4fnZiWblxHIgeWqW8x7UqDzEtHEQLzji2cuJYQFCU6KmoJikOYAZlrTHHebjx2w==",
            "dev": true,
            "requires": {
                "imurmurhash": "^0.1.4"
            }
        },
        "universalify": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/universalify/-/universalify-2.0.0.tgz",
            "integrity": "sha512-hAZsKq7Yy11Zu1DE0OzWjw7nnLZmJZYTDZZyEFHZdUhV8FkH5MCfoU1XMaxXovpyW5nq5scPqq0ZDP9Zyl04oQ==",
            "dev": true
        },
        "unpipe": {
            "version": "1.0.0",
            "resolved": "https://registry.npmjs.org/unpipe/-/unpipe-1.0.0.tgz",
            "integrity": "sha1-sr9O6FFKrmFltIF4KdIbLvSZBOw=",
            "dev": true
        },
        "upper-case": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/upper-case/-/upper-case-2.0.2.tgz",
            "integrity": "sha512-KgdgDGJt2TpuwBUIjgG6lzw2GWFRCW9Qkfkiv0DxqHHLYJHmtmdUIKcZd8rHgFSjopVTlw6ggzCm1b8MFQwikg==",
            "dev": true,
            "requires": {
                "tslib": "^2.0.3"
            }
        },
        "upper-case-first": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/upper-case-first/-/upper-case-first-2.0.2.tgz",
            "integrity": "sha512-514ppYHBaKwfJRK/pNC6c/OxfGa0obSnAl106u97Ed0I625Nin96KAjttZF6ZL3e1XLtphxnqrOi9iWgm+u+bg==",
            "dev": true,
            "requires": {
                "tslib": "^2.0.3"
            }
        },
        "url-join": {
            "version": "4.0.1",
            "resolved": "https://registry.npmjs.org/url-join/-/url-join-4.0.1.tgz",
            "integrity": "sha512-jk1+QP6ZJqyOiuEI9AEWQfju/nB2Pw466kbA0LEZljHwKeMgd9WrAEgEGxjPDD2+TNbbb37rTyhEfrCXfuKXnA==",
            "dev": true
        },
        "util-deprecate": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/util-deprecate/-/util-deprecate-1.0.2.tgz",
            "integrity": "sha1-RQ1Nyfpw3nMnYvvS1KKJgUGaDM8=",
            "dev": true
        },
        "utils-merge": {
            "version": "1.0.1",
            "resolved": "https://registry.npmjs.org/utils-merge/-/utils-merge-1.0.1.tgz",
            "integrity": "sha1-n5VxD1CiZ5R7LMwSR0HBAoQn5xM=",
            "dev": true
        },
        "varint": {
            "version": "6.0.0",
            "resolved": "https://registry.npmjs.org/varint/-/varint-6.0.0.tgz",
            "integrity": "sha512-cXEIW6cfr15lFv563k4GuVuW/fiwjknytD37jIOLSdSWuOI6WnO/oKwmP2FQTU2l01LP8/M5TSAJpzUaGe3uWg==",
            "dev": true
        },
        "vary": {
            "version": "1.1.2",
            "resolved": "https://registry.npmjs.org/vary/-/vary-1.1.2.tgz",
            "integrity": "sha1-IpnwLG3tMNSllhsLn3RSShj2NPw=",
            "dev": true
        },
        "void-elements": {
            "version": "2.0.1",
            "resolved": "https://registry.npmjs.org/void-elements/-/void-elements-2.0.1.tgz",
            "integrity": "sha1-wGavtYK7HLQSjWDqkjkulNXp2+w=",
            "dev": true
        },
        "w3c-keyname": {
            "version": "2.2.4",
            "resolved": "https://registry.npmjs.org/w3c-keyname/-/w3c-keyname-2.2.4.tgz",
            "integrity": "sha512-tOhfEwEzFLJzf6d1ZPkYfGj+FWhIpBux9ppoP3rlclw3Z0BZv3N7b7030Z1kYth+6rDuAsXUFr+d0VE6Ed1ikw=="
        },
        "whatwg-encoding": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/whatwg-encoding/-/whatwg-encoding-2.0.0.tgz",
            "integrity": "sha512-p41ogyeMUrw3jWclHWTQg1k05DSVXPLcVxRTYsXUk+ZooOCZLcoYgPZ/HL/D/N+uQPOtcp1me1WhBEaX02mhWg==",
            "dev": true,
            "requires": {
                "iconv-lite": "0.6.3"
            },
            "dependencies": {
                "iconv-lite": {
                    "version": "0.6.3",
                    "resolved": "https://registry.npmjs.org/iconv-lite/-/iconv-lite-0.6.3.tgz",
                    "integrity": "sha512-4fCk79wshMdzMp2rH06qWrJE4iolqLhCUH+OiuIgU++RB0+94NlDL81atO7GX55uUKueo0txHNtvEyI6D7WdMw==",
                    "dev": true,
                    "requires": {
                        "safer-buffer": ">= 2.1.2 < 3.0.0"
                    }
                }
            }
        },
        "wherearewe": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/wherearewe/-/wherearewe-1.0.2.tgz",
            "integrity": "sha512-HyLZ7n1Yox+w1qWaFEgP/sMs5D7ka2UXmoVNaY0XzbEHLGljo4ScBchYm6cWRYNO33tmFX3Mgg4BiZkDOjihyw==",
            "dev": true,
            "requires": {
                "is-electron": "^2.2.0"
            }
        },
        "which": {
            "version": "2.0.2",
            "resolved": "https://registry.npmjs.org/which/-/which-2.0.2.tgz",
            "integrity": "sha512-BLI3Tl1TW3Pvl70l3yq3Y64i+awpwXqsGBYWkkqMtnbXgrMD+yj7rhW0kuEDxzJaYXGjEW5ogapKNMEKNMjibA==",
            "dev": true,
            "requires": {
                "isexe": "^2.0.0"
            }
        },
        "wicg-inert": {
            "version": "3.1.1",
            "resolved": "https://registry.npmjs.org/wicg-inert/-/wicg-inert-3.1.1.tgz",
            "integrity": "sha512-PhBaNh8ur9Xm4Ggy4umelwNIP6pPP1bv3EaWaKqfb/QNme2rdLjm7wIInvV4WhxVHhzA4Spgw9qNSqWtB/ca2A=="
        },
        "workerpool": {
            "version": "6.2.0",
            "resolved": "https://registry.npmjs.org/workerpool/-/workerpool-6.2.0.tgz",
            "integrity": "sha512-Rsk5qQHJ9eowMH28Jwhe8HEbmdYDX4lwoMWshiCXugjtHqMD9ZbiqSDLxcsfdqsETPzVUtX5s1Z5kStiIM6l4A==",
            "dev": true
        },
        "wrap-ansi": {
            "version": "7.0.0",
            "resolved": "https://registry.npmjs.org/wrap-ansi/-/wrap-ansi-7.0.0.tgz",
            "integrity": "sha512-YVGIj2kamLSTxw6NsZjoBxfSwsn0ycdesmc4p+Q21c5zPuZ1pl+NfxVdxPtdHvmNVOQ6XSYG4AUtyt/Fi7D16Q==",
            "dev": true,
            "requires": {
                "ansi-styles": "^4.0.0",
                "string-width": "^4.1.0",
                "strip-ansi": "^6.0.0"
            }
        },
        "wrappy": {
            "version": "1.0.2",
            "resolved": "https://registry.npmjs.org/wrappy/-/wrappy-1.0.2.tgz",
            "integrity": "sha1-tSQ9jz7BqjXxNkYFvA0QNuMKtp8=",
            "dev": true
        },
        "ws": {
            "version": "7.5.7",
            "resolved": "https://registry.npmjs.org/ws/-/ws-7.5.7.tgz",
            "integrity": "sha512-KMvVuFzpKBuiIXW3E4u3mySRO2/mCHSyZDJQM5NQ9Q9KHWHWh0NHgfbRMLLrceUK5qAL4ytALJbpRMjixFZh8A==",
            "dev": true,
            "requires": {}
        },
        "y18n": {
            "version": "5.0.8",
            "resolved": "https://registry.npmjs.org/y18n/-/y18n-5.0.8.tgz",
            "integrity": "sha512-0pfFzegeDWJHJIAmTLRP2DwHjdF5s7jo9tuztdQxAhINCdvS+3nGINqPd00AphqJR/0LhANUS6/+7SCb98YOfA==",
            "dev": true
        },
        "yallist": {
            "version": "4.0.0",
            "resolved": "https://registry.npmjs.org/yallist/-/yallist-4.0.0.tgz",
            "integrity": "sha512-3wdGidZyq5PB084XLES5TpOSRA3wjXAlIWMhum2kRcv/41Sn2emQ0dycQW4uZXLejwKvg6EsvbdlVL+FYEct7A==",
            "dev": true
        },
        "yargs": {
            "version": "16.2.0",
            "resolved": "https://registry.npmjs.org/yargs/-/yargs-16.2.0.tgz",
            "integrity": "sha512-D1mvvtDG0L5ft/jGWkLpG1+m0eQxOfaBvTNELraWj22wSVUMWxZUvYgJYcKh6jGGIkJFhH4IZPQhR4TKpc8mBw==",
            "dev": true,
            "requires": {
                "cliui": "^7.0.2",
                "escalade": "^3.1.1",
                "get-caller-file": "^2.0.5",
                "require-directory": "^2.1.1",
                "string-width": "^4.2.0",
                "y18n": "^5.0.5",
                "yargs-parser": "^20.2.2"
            },
            "dependencies": {
                "yargs-parser": {
                    "version": "20.2.9",
                    "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-20.2.9.tgz",
                    "integrity": "sha512-y11nGElTIV+CT3Zv9t7VKl+Q3hTQoT9a1Qzezhhl6Rp21gJ/IVTW7Z3y9EWXhuUBC2Shnf+DX0antecpAwSP8w==",
                    "dev": true
                }
            }
        },
        "yargs-parser": {
            "version": "20.2.4",
            "resolved": "https://registry.npmjs.org/yargs-parser/-/yargs-parser-20.2.4.tgz",
            "integrity": "sha512-WOkpgNhPTlE73h4VFAFsOnomJVaovO8VqLDzy5saChRBFQFBoMYirowyW+Q9HB4HFF4Z7VZTiG3iSzJJA29yRA==",
            "dev": true
        },
        "yargs-unparser": {
            "version": "2.0.0",
            "resolved": "https://registry.npmjs.org/yargs-unparser/-/yargs-unparser-2.0.0.tgz",
            "integrity": "sha512-7pRTIA9Qc1caZ0bZ6RYRGbHJthJWuakf+WmHK0rVeLkNrrGhfoabBNdue6kdINI6r4if7ocq9aD/n7xwKOdzOA==",
            "dev": true,
            "requires": {
                "camelcase": "^6.0.0",
                "decamelize": "^4.0.0",
                "flat": "^5.0.2",
                "is-plain-obj": "^2.1.0"
            }
        },
        "yocto-queue": {
            "version": "0.1.0",
            "resolved": "https://registry.npmjs.org/yocto-queue/-/yocto-queue-0.1.0.tgz",
            "integrity": "sha512-rVksvsnNCdJ/ohGc6xgPwyN8eheCxsiLM8mxuE/t/mOVqJewPuO1miLpTHQiRgTKCLexL4MeAFVagts7HmNZ2Q==",
            "dev": true
        }
    }
}

'''
'''--- web/package.json ---
{
    "type": "module",
    "scripts": {
        "start": "http-server -p 8082 .",
        "start-dist": "http-server -p 8082 ../dist",
        "importmap": "node importmapgenerator.js",
        "dist": "rollup -c rollup.config.js",
        "test": "karma start --single-run --browsers ChromeHeadless karma.conf.cjs",
        "test:watch": "karma start --browsers Chrome karma.conf.cjs"
    },
    "dependencies": {
        "@codemirror/basic-setup": "^0.20.0",
        "@codemirror/commands": "^0.20.0",
        "@codemirror/lang-javascript": "^0.20.0",
        "@codemirror/state": "^0.20.0",
        "@codemirror/view": "^0.20.0",
        "@material/mwc-button": "",
        "@material/mwc-dialog": "",
        "@material/mwc-drawer": "",
        "@material/mwc-icon-button": "",
        "@material/mwc-linear-progress": "",
        "@material/mwc-list": "",
        "@material/mwc-select": "",
        "@material/mwc-snackbar": "",
        "@material/mwc-textfield": "",
        "@material/mwc-top-app-bar": ""
    },
    "devDependencies": {
        "@jspm/generator": "^1.0.0-beta.31",
        "@rollup/plugin-node-resolve": "^13.3.0",
        "@web/rollup-plugin-html": "^1.10.3",
        "@web/rollup-plugin-import-meta-assets": "^1.0.7",
        "chai": "^4.3.6",
        "http-server": "^14.1.0",
        "karma": "^6.3.19",
        "karma-chai": "^0.1.0",
        "karma-chrome-launcher": "^3.1.1",
        "karma-mocha": "^2.0.1",
        "mocha": "^9.2.2",
        "rollup": "^2.70.2",
        "rollup-plugin-terser": "^7.0.2"
    }
}

'''
'''--- web/rollup.config.js ---
import html from '@web/rollup-plugin-html';
import { terser } from 'rollup-plugin-terser';
import { importMetaAssets } from '@web/rollup-plugin-import-meta-assets';
import { readFileSync, rmdirSync, existsSync } from 'fs';
import { nodeResolve } from '@rollup/plugin-node-resolve';

const outdir = '../dist';
if (existsSync(outdir)) {
    rmdirSync(outdir, { recursive: true });
}

export default {
    input: './index.html',
    output: { dir: outdir, entryFileNames: "app.[hash].js" },
    plugins: [nodeResolve(), (() => ({
        transform(code, id) {
            let urlMatch;
            do {
                urlMatch = code.match(/(new URL\([^),]+\,\s*import.meta.url\s*\))/);
                
                if (urlMatch) {
                    const urlWithAbsolutePath = urlMatch[1].replace('import.meta.url', `'file://${id}'`);
                    const func = new Function('return ' + urlWithAbsolutePath);
                    const resolvedUrl = func();
                    const pathname = resolvedUrl.pathname;
                    if (pathname.endsWith('.html')) {
                        const datauri = `data:text/html;base64,${readFileSync(pathname).toString('base64')}`;
                        code = code.replace(urlMatch[0], `new URL('${datauri}')`);
                    } else if (pathname.endsWith('.css')) {
                        const datauri = `data:text/css;base64,${readFileSync(pathname).toString('base64')}`;
                        code = code.replace(urlMatch[0], `new URL('${datauri}')`);
                    } else if (pathname.endsWith('.wasm')) {
                        const datauri = `data:application/wasm;base64,${readFileSync(pathname).toString('base64')}`;
                        code = code.replace(urlMatch[0], `new URL('${datauri}')`);
                    } else if (pathname.endsWith('.js')) {
                        code = code.replace(urlMatch[0], `URL.createObjectURL(new Blob([
                            (() => {
                                function jsFunc() {${readFileSync(pathname).toString()}}
                                const jsFuncSource = jsFunc.toString();
                                return jsFuncSource.substring( jsFuncSource.indexOf('{') + 1,  jsFuncSource.lastIndexOf('}'));
                            })()
                        ],
                            { type: 'text/javascript' }))`);
                    }
                }
            } while(urlMatch);
            return {
                code: code
            }
        }
    }))(), importMetaAssets(), html({ include: '**/*.html', minify: true,
    transformHtml: (html) => {        
        return html.replace(/<script type=\"importmap\">[^<]+<\/script>/g, "");        
    } }), terser()],
};
'''