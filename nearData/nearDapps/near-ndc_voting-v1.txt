*GitHub Repository "near-ndc/voting-v1"*

'''--- .clippy.toml ---
msrv = "1.61"

too-many-arguments-threshold = 9

'''
'''--- .github/workflows/lint.yml ---
name: Lint

on:
  pull_request:
    branches: [master, main]
  merge_group:

concurrency:
  group: ci-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

jobs:
  markdown-lint:
    name: markdown-lint
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      # lint only changed files
      - uses: tj-actions/changed-files@v35
        id: changed-files
        with:
          files: "**/*.md"
          separator: ","
      - uses: DavidAnson/markdownlint-cli2-action@v9
        if: steps.changed-files.outputs.any_changed == 'true'
        with:
          globs: ${{ steps.changed-files.outputs.all_changed_files }}
          separator: ","

  markdown-link-check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@master
      - uses: gaurav-nelson/github-action-markdown-link-check@v1
        with:
          use-quiet-mode: "yes"

'''
'''--- .github/workflows/rust.yml ---
name: Rust

on:
  pull_request:
    branches: [master, main]
  merge_group:
  push:
    branches: ["master"]

concurrency:
  group: ci-${{ github.ref }}-${{ github.workflow }}
  cancel-in-progress: true

env:
  CARGO_TERM_COLOR: always

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - uses: technote-space/get-diff-action@v6.1.2
        with:
          PATTERNS: |
            **/**.rs
            Cargo.lock
      - name: Install latest nightly
        if: env.GIT_DIFF
        uses: actions-rs/toolchain@v1
        with:
          toolchain: 1.75.0
          override: true
          components: rustfmt, clippy

      - name: Install wasm32 toolchain
        if: env.GIT_DIFF
        run: rustup target add wasm32-unknown-unknown
      - name: stub registry.wasm file
        run: mkdir res && touch res/registry.wasm
      - name: Build
        if: env.GIT_DIFF
        run: make build
      - name: Clippy
        if: env.GIT_DIFF
        run: make lint
      - name: Run tests
        if: env.GIT_DIFF
        # TODO: switch to all tests once we find efficient way how to link registry contract
        run: make test-unit

'''
'''--- .markdownlint.json ---
{
    "default": true,
    "MD001": false,
    "MD013": false,
    "MD024": { "siblings_only": true },
    "MD025": false,
    "MD033": false,
    "MD034": false,
    "whitespace": false
}

'''
'''--- Cargo.toml ---
[workspace]
resolver = "1"
members = [
    "voting_body",
    "elections",
    "nominations",
    "integrations",
    "common",
    "congress",
]

[workspace.package]
edition = "2021"
license = "Mozilla Public License Version 2.0"
repository = "https://github.com/near-ndc/i-am-human"
authors = [
    "NDC GWG (https://near.social/#/mob.near/widget/ProfilePage?accountId=govworkinggroup.near)",
]

[profile.release]
codegen-units = 1
# "s" = optimize for binary size ("z" would additionally turn off loop vectorization)
# 3  all optimiations
opt-level = "s"
# link time optimization
lto = true
panic = "abort"
overflow-checks = true
debug = false
debug-assertions = false
rpath = false

[workspace.dependencies]
near-sdk = "^4.1.1"
uint = { version = "^0.9.5", default-features = false }
serde_json = "^1.0"
thiserror = "1.0"
itertools = "^0.11"

# workspace doesn't have dev-dependencies field, so we have to put the dependencies here
# https://doc.rust-lang.org/cargo/reference/workspaces.html
tokio = { version = "1.28.0", features = ["full"] }
near-workspaces = "0.8.0"
near-primitives = "0.17.0"
near-units = "0.2.0"
anyhow = "1.0"

'''
'''--- README.md ---
# NDC v1 Smart Contracts

In NDC v1, there will be only two mechanisms to vote: simple proposal voting and elections. Both are based on stake weight.

- Details about the Framework: [near-ndc/gov](https://github.com/near-ndc/gov).

This repository provides smart contracts for NDC v1 Voting Body.

## Proposal types

| Proposal                                     | Voting Entity | Contract    |
| :------------------------------------------- | :------------ | :---------- |
| Elect house representatives                  | Voting Body   | elections   |
| Constitution ratification                    | Voting Body   | voting body |
| Dissolve a house and call for new elections  | Voting Body   | voting body |
| Setup Package                                | Voting Body   | voting body |
| Budget ratification                          | Voting Body   | voting body |
| Veto HoM Recurrent and Big Funding Proposals | Voting Body   | voting body |
| Budget                                       | HoM           | congress    |
| Transfer Funds                               | HoM           | congress    |
| Funding proposal                             | HoM           | congress    |
| Veto any HoM proposal                        | CoA           | congress    |
| Reinstate representative                     | TC / CoA      | congress    |
| Investigate                                  | TC            | congress    |
| Remove representative                        | TC            | congress    |

In NDC v1, Voting Body can't make proposal for budget management. They can only veto budget proposals.

### General voting rules

- user can only vote for active proposals
- user can not overwrite his vote

### Elections

Elections for NDC v1 Houses.

ğŸ‘‰ [**Voting Process**](https://github.com/near-ndc/gov/blob/main/framework-v1/elections-voting.md)

### Voting Body

Voting Body is set of human verified NEAR accounts constituting NDC.

Voting mechanisms as well as Powers, Checks and Balances of the Voting Body is described in the [NDC Gov v1 Framework](https://github.com/near-ndc/gov/blob/main/framework-v1/gov-framework.md).

- Propose and approve HoM **setup package**: a request to deploy funds from the [Community Treasury](https://github.com/near-ndc/gov/blob/main/framework-v1/community-treasury.md) to HoM DAO.
- **Voting Body Veto** is a special proposal to veto other proposal made by a house. When a HoM or CoA proposal will pass it must not be executed immediately. There must be an challenge period, where a Voting Body or the TC can stop the proposal execution by successfully submitting a Veto proposal.

'''
'''--- common/Cargo.toml ---
[package]
name = "common"
version = "1.0.0"
authors = { workspace = true }
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

'''
'''--- common/README.md ---
# Set of common functions and structures

- event handling

'''
'''--- common/src/errors.rs ---
use near_sdk::{env::panic_str, FunctionError};

#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum HookError {
    NotAuthorized,
    NoMember,
    ProposalFinalized,
    CooldownOver,
}

impl FunctionError for HookError {
    fn panic(&self) -> ! {
        match self {
            HookError::NotAuthorized => panic_str("not authorized"),
            HookError::NoMember => panic_str("member not found"),
            HookError::ProposalFinalized => panic_str("proposal finalized"),
            HookError::CooldownOver => panic_str("cooldown period is over"),
        }
    }
}

'''
'''--- common/src/events.rs ---
use near_sdk::env;
use near_sdk::serde::Serialize;

/// Helper struct to create Standard NEAR Event JSON.
/// Arguments:
/// * `standard`: name of standard e.g. nep171
/// * `version`: e.g. 1.0.0
/// * `event`: associate event data
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct NearEvent<T: Serialize> {
    pub standard: &'static str,
    pub version: &'static str,

    // `flatten` to not have "event": {<EventVariant>} in the JSON, just have the contents of {<EventVariant>}.
    #[serde(flatten)]
    pub event: T,
}

impl<T: Serialize> NearEvent<T> {
    pub fn to_json_event_string(&self) -> String {
        let s = serde_json::to_string(&self)
            .ok()
            .unwrap_or_else(|| env::abort());
        format!("EVENT_JSON:{}", s)
    }

    pub fn emit(self) {
        env::log_str(&self.to_json_event_string());
    }
}

/// Helper struct to be used in `NearEvent.event` to construct NEAR Event compatible payload
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct EventPayload<T: Serialize> {
    /// event name
    pub event: &'static str,
    /// event payload
    pub data: T,
}

impl<T: Serialize> EventPayload<T> {
    pub fn emit(self, standard: &'static str, version: &'static str) {
        NearEvent {
            standard,
            version,
            event: self,
        }
        .emit()
    }
}

#[cfg(test)]
mod tests {
    use near_sdk::{test_utils, AccountId};

    use super::*;

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice.near".to_string())
    }

    #[test]
    fn emit_event_payload() {
        let expected = r#"EVENT_JSON:{"standard":"nepXYZ","version":"1.0.1","event":"mint","data":["alice.near",[821,10,44]]}"#;
        let tokens = vec![821, 10, 44];
        let event = EventPayload {
            event: "mint",
            data: (alice(), tokens),
        };
        event.emit("nepXYZ", "1.0.1");
        assert_eq!(vec![expected], test_utils::get_logs());
    }
}

'''
'''--- common/src/lib.rs ---
pub mod errors;
mod events;

pub use events::*;
use near_sdk::{env, AccountId, Balance, Promise};

/// checks if there was enough storage deposit provided, and returns the excess of the deposit
/// back to the user.
/// * `storage_extra`: extra storage which should be credited for future operations.
pub fn finalize_storage_check(
    storage_start: u64,
    storage_extra: u64,
    user: AccountId,
) -> Result<Balance, String> {
    let storage_deposit = env::attached_deposit();
    let required_deposit =
        (env::storage_usage() - storage_start + storage_extra) as u128 * env::storage_byte_cost();
    if storage_deposit < required_deposit {
        return Err(format!(
            "not enough NEAR storage deposit, required: {}",
            required_deposit
        ));
    }
    let diff = storage_deposit - required_deposit;
    if diff > 0 {
        Promise::new(user).transfer(diff);
    }
    Ok(required_deposit)
}

'''
'''--- congress/CHANGELOG.md ---
<!-- markdownlint-disable MD013 -->
<!-- markdownlint-disable MD024 -->

<!--
Changelogs are for humans, not machines.
There should be an entry for every single version.
The same types of changes should be grouped.
The latest version comes first.
The release date of each version is displayed.

Usage:

Change log entries are to be added to the Unreleased section. Example entry:

* [#<PR-number>](https://github.com/umee-network/umee/pull/<PR-number>) <description>

-->

# CHANGELOG

## Unreleased

### Breaking changes

### Features

### Bug Fixes

## v1.2.0 (2023-12-28)

### Features

- `all_hook_permissions` query to return all hook permissions.

### Improvements

- Remove temporal `add_tc_dismiss_perm` and gas adjustments in the `execute` method related to the wrong Gas settings in the TC proposals (and missing checks mentioned in the v1.1.2 release).

## v1.1.2 (2023-12-28)

### Improvements

- `create_proposal` has additional checks for the function call actions. We observed that too much gas was set in the actions, prohibiting correct contract execution (not enough gas to do self execution).
- Temporal gas adjustment to allow TC execution of dismiss proposals (related to the point above).

### Bug Fixes

- Added Dismiss hook permission to dismiss members of TC by TC (`congress-tc-v1.ndc-gwg.near`).

## v1.1.1 (2023-12-16)

### Features

- Added `add_fun_call_perm` call, that can only be run by the contract authority.

### Bug Fixes

- Updating Transparency Commission mainnet instance to add `FunctionCall` permission.

## v1.1.0 (2023-11-20)

### Features

- `members_len` view method.

### Breaking changes

- added `members_len` field to smart contract.
- renamed `voting_duration` and `min_voting_duration` to `vote_duration` and `min_vote_duration` in the Config and initialization (`new`). Motivation is to make it consistent with the Voting Body Config.

## v1.0.0 (2023-11-01)

### Features

- Store vote timestamps.
- Added `min_voting_duration`. With non zero `min_voting_duration`, a proposal is in progress until:
  - all votes were cast
  - OR voting_duration passed
  - OR `min_voting_duration` passed and the tally can be finalized (proposal reached min amount of approval votes or have enough abstain + reject votes to block the approval).
- Extended `ConfigOutput` to include all contract parameters.

### Breaking changes

- `proposal.votes` map type has changed. The values are `VoteRecord` (vote and the timestamp) instead of `Vote`.
- `execute` method return type changed: from `Result<PromiseOrValue<()>, ExecError>` to `Result<PromiseOrValue<Result<(), ExecRespErr>>, ExecError>`. Note the inner result. If the result is `Ok(PromiseOrValue::Value(Err(..)))` then the transaction will pass (state change will be properly recorded), but the proposal fails to execute due to error reported through `ExecRespError`.

### Bug Fixes

- Proposal status calculation in when querying proposals.
- Proposal: handle budget overflow, when there are two competing proposals.

## v0.2.0 (2023-10-24)

### Features

- Added abstain vote type.
- new `is_member(&self, account: AccountId) -> bool` query function.

### Bug Fixes

- Proposal iterator to handle edge case for the limit parameter.

## v0.1.0 (2023-10-13)

'''
'''--- congress/Cargo.toml ---
[package]
name = "congress"
version = "1.2.0"
authors = { workspace = true }
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
# rlib is needed for integration tests
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true
itertools.workspace = true

common = { path = "../common" }

[dev-dependencies]
anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-primitives.workspace = true
near-units.workspace = true
integrations = { path = "../integrations" }

'''
'''--- congress/README.md ---
# Congress

- [Diagrams](https://miro.com/app/board/uXjVMqJRr_U=/)
- [Framework Specification](https://near-ndc.notion.site/NDC-V1-Framework-V3-1-Updated-1af84fe7cc204087be70ea7ffee4d23f?pvs=4)

## Creating a Proposal

Each Congress house specifies which proposal kinds are allowed to be created. It is a subset of:

- `FunctionCall`: if approved, proposal execution will create a cross contract call.
- `Text`: text based proposal, no automated action is performed.
- `FundingRequest(Balance)`: request to fund a specific project. Balance is the amount of Near provided as funding. If Balance is bigger or equal than `big_funding_threshold` then it is eligible for `VetoBigOrReccurentFundingReq`. Proposal execution will fail if the total budget spend (including the one from the proposal) goes above the `contract.budget_cap`.
  NOTE: The contract doesn't track the monthly budget limit. That should be tracked off-chain.
- `RecurrentFundingRequest(Balance)`: funding request that will renew every month until the end of the terms. The balance parameter is the size of the single month spending for this funding request. The proposal is eligible for
  `VetoBigOrReccurentFundingReq`. Proposal execution will fail if the total budget spend (including the one from the proposal multiplied by the amount of remaining months) goes above the `contract.budget_cap`.
- `DismissAndBan(member, house)`: requests I Am Human registry to ban the member account (set `GovBan` flag in the IAH registry) and calls the dismiss hook on the house.

Each proposal comes with a description, which should provide motivation and a background.

### Cheat sheet

Below we present how to make a proposal for every possible Congress motion:

#### Veto

Veto is created by a separate account or DAO that has a permission to call the `veto_hook`. `VetoAll` permission allows to veto any proposal, while `VetoBigOrReccurentFundingReq` only allows to veto recurrent funding proposals or funding proposals above `big_funding_threshold`.
In NDC Gov v1 the following entities have permission to veto HoM proposals:

- `voting-body-v1.ndc-gwg.near`: `VetoBigOrReccurentFundingReq`
- `congress-coa-v1.ndc-gwg.near`: `VetoAl`

To create a veto within the congress houses, use the `create_proposal` function:

```json
near call congress-coa-v1.ndc-gwg.near create proposal '{
  "kind": {
    "FunctionCall": {
      "receiver_id": "congress-hom-v1.ndc-gwg.near",
      "actions": [
        {
          "method_name": "veto_hook",
          "args": {"id": "proposal_id to be vetoed"},
          "deposit": "100000000000000000000000",
          "gas": "300000000000000"
        }
      ]
    }
  },
  "description": "Your description"
}' --accountId your_account.near
```

See also the `Voting Body` documentation.

#### Dismiss

To initiate a dismiss, the executing house must have `Dismiss` permission. In NDC Gov v1, the authority to dismiss any member of the `HoM` and `CoA` rests with the `TC` (Transparency Commision).

To propose a dismiss proposal, call the `create_proposal` function:

```json
near call congress-coa-v1.ndc-gwg.near create proposal '{
  "kind": {
    "FunctionCall": {
      "receiver_id": "congress-hom-v1.ndc-gwg.near",
      "actions": [
        {
          "method_name": "dismiss_hook",
          "args": {"member": "member_to_dismiss.near"},
          "deposit": "100000000000000000000000",
          "gas": "300000000000000"
        }
      ]
    }
  },
  "description": "Your description"
}' --accountId your_account.near
```

#### Dismiss and Ban

To initiate a dismiss and ban action, the executing house must have `DismissAndBan` permission. In NDC Gov v1, the authority to dismiss any member of the `HoM` and `CoA` rests with the `TC` (Transparency Commision).

To propose a dismiss and ban proposal, call the `create_proposal` function:

```json
near call congress-tc-v1.ndc-gwg.near create proposal '{
  "kind": {
    "DismissAndBan": {
      "member": "member_to_dismiss_and_ban.near",
      "house": "congress-hom-v1.ndc-gwg.near",
    },
  },
  "description": "Your description"
}' --accountId your_account.near
```

## Proposal Lifecycle

When a proposal is created it will have `InProgress` status and the `submission_time` will be set.

```mermaid
---
title: Possible Proposal Status Flows
---
flowchart TB
    Create_Proposal --> InProgress
    InProgress --> Approved
    InProgress --> Rejected
    InProgress --> Vetoed
    Approved --> Executed
    Approved --> Failed
    Approved --> Vetoed
    Failed -- re-execute --> Executed
```

### Voting

Any member can vote for any `InProgress` proposal. Members can't overwrite their votes. Proposal is in progress until:

- all votes were cast
- OR `vote_duration` passed
- OR `min_vote_duration` passed and the tally can be finalized (proposal reached min amount of approval votes or have enough abstain + reject votes to block the approval).

Example CLI command to vote for a proposal:

``` shell
# vote must be one of: "Approve", "Reject", "Abstain"
near call HOUSE vote '{"id": PROP_ID, "vote": "Approve"}' --accountId YOU
```

### Vetoing

Any proposal can be vetoed (even an in progress one) until the cooldown is over.
A DAO `A` can veto a proposal `P` of house `H` if:

- `P` cooldown is not over (is in progress, approved or rejected).
- `H` gives veto permission to `A`: `contract.hook_auth[A]` contains `VetoAll` or `VetoBigOrReccurentFundingReq`. The latter will only allow `A` to veto big funding proposals or recurrent funding proposals.

### Execution

Anyone (not only a house member) can execute a proposal when a proposal that is:

- min vote duration passed;
- cooldown is over;
- proposal is _approved_ or _failed_.

A proposal is **approved** when:

- is not in progress;
- AND got enough #approved votes (`>= contract.threshold`).

Proposal reaches _failed_ status when it was approved, but the execution failed. In that can be re-executed again.

If proposal execution breaks an invariant check (eg: crossing the budget cap), then the transaction will succeed and a composed error will be returned: the `Ok(Err(ExecRespErr::**))` of `Result<PromiseOrValue<Result<(), ExecRespErr>>, ExecError>` type.

Example CLI command to execute a proposal:

``` shell
near call HOUSE execute '{"id": PROP_ID}' --gas 300000000000000 --accountId YOU
```

## Queries

- `get_proposals`: Query all proposals

  - `near view $CTR get_proposals '{"from_index": 0, "limit": 10}'`

- `get_proposal`: Query a specific proposal

  - `near view $CTR get_proposal '{"id": 1}'`

- `number_of_proposals`: Query a specific proposal

  - `near view $CTR number_of_proposals ''`

- `is_dissolved`: Check if contract is dissolved

  - `near view $CTR is_dissolved ''`

- `get_members`: Query all members with permissions

  - `near view $CTR get_members ''`

- `member_permissions`: Returns permissions for a specific member

  - `near view $CTR member_permissions '{"member": "user.testnet"}'`

- `hook_permissions`: Returns permissions for a specific member
  - `near view $CTR hook_permissions '{"user": "user.testnet"}'`

'''
'''--- congress/src/constants.rs ---
use near_sdk::{Balance, Gas, ONE_NEAR};

pub const MILI_NEAR: Balance = ONE_NEAR / 1_000;

/// Gas reserved for final failure callback which panics if one of the callback fails.
pub const FAILURE_CALLBACK_GAS: Gas = Gas(3 * Gas::ONE_TERA.0);
pub const EXECUTE_CALLBACK_GAS: Gas = Gas(4 * Gas::ONE_TERA.0);

pub const EXEC_CTR_CALL_GAS: Gas = Gas(8 * Gas::ONE_TERA.0);
pub const EXEC_SELF_GAS: Gas = Gas(20 * Gas::ONE_TERA.0);
pub const MAX_EXEC_FUN_CALL_GAS: Gas =
    Gas(300 * Gas::ONE_TERA.0 - EXEC_SELF_GAS.0 - EXECUTE_CALLBACK_GAS.0);

// 64bytes(accountID) + 1byte (prefix) + 4bytes(proposal_id) + vote(byte) = 72B -> add 20% margin = < 90B
pub const VOTE_STORAGE: u64 = 90;

'''
'''--- congress/src/errors.rs ---
use near_sdk::env::panic_str;
use near_sdk::serde::Serialize;
use near_sdk::FunctionError;

#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum VoteError {
    NotAuthorized,
    DoubleVote,
    NotInProgress,
    NotActive,
    NoSelfVote,
}

impl FunctionError for VoteError {
    fn panic(&self) -> ! {
        match self {
            VoteError::NotAuthorized => panic_str("not authorized"),
            VoteError::DoubleVote => panic_str("user already voted"),
            VoteError::NotInProgress => panic_str("proposal not in progress"),
            VoteError::NotActive => panic_str("voting time is over"),
            VoteError::NoSelfVote => panic_str("not allowed to vote on proposal against them"),
        }
    }
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum ExecError {
    ExecTime,
    NotApproved,
    AlreadyExecuted,
    MinVoteDuration,
}

impl FunctionError for ExecError {
    fn panic(&self) -> ! {
        match self {
            ExecError::ExecTime => panic_str("can only be executed after cooldown"),
            ExecError::NotApproved => {
                panic_str("can execute only approved or re-execute failed proposals")
            }
            ExecError::AlreadyExecuted => panic_str("proposal was already executed"),
            ExecError::MinVoteDuration => panic_str("proposal still in min voting duration"),
        }
    }
}

#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum CreatePropError {
    BudgetOverflow,
    NotAuthorized,
    KindNotAllowed,
    Storage(String),
    Gas(String),
}

impl FunctionError for CreatePropError {
    fn panic(&self) -> ! {
        match self {
            CreatePropError::BudgetOverflow => panic_str("budget cap overflow"),
            CreatePropError::NotAuthorized => panic_str("not authorized"),
            CreatePropError::KindNotAllowed => panic_str("proposal kind not allowed"),
            CreatePropError::Storage(reason) => panic_str(reason),
            CreatePropError::Gas(reason) => panic_str(reason),
        }
    }
}

'''
'''--- congress/src/events.rs ---
use near_sdk::{serde::Serialize, AccountId};
use serde_json::json;

use crate::{proposal::PropKind, ExecError};

use common::{EventPayload, NearEvent};

fn emit_event<T: Serialize>(event: EventPayload<T>) {
    NearEvent {
        standard: "ndc-congress",
        version: "1.0.0",
        event,
    }
    .emit();
}

pub(crate) fn emit_prop_created(prop_id: u32, kind: &PropKind) {
    emit_event(EventPayload {
        event: "new-proposal",
        data: json!({ "prop_id": prop_id, "kind": kind.to_name() }),
    });
}

pub(crate) fn emit_vote(prop_id: u32) {
    emit_event(EventPayload {
        event: "vote",
        data: json!({ "prop_id": prop_id }),
    });
}

pub(crate) fn emit_vote_execute_fail(prop_id: u32, err: ExecError) {
    emit_event(EventPayload {
        event: "vote-execute",
        data: json!({ "prop_id": prop_id, "status": "failed", "reason": err }),
    });
}

pub(crate) fn emit_executed(prop_id: u32) {
    emit_event(EventPayload {
        event: "execute",
        data: json!({ "prop_id": prop_id }),
    });
}

pub(crate) fn emit_veto(prop_id: u32) {
    emit_event(EventPayload {
        event: "veto",
        data: json!({ "prop_id": prop_id }),
    });
}

pub(crate) fn emit_dissolve() {
    emit_event(EventPayload {
        event: "dissolve",
        data: "",
    });
}

pub(crate) fn emit_dismiss(member: &AccountId) {
    emit_event(EventPayload {
        event: "dismiss",
        data: json!({ "member": member }),
    });
}

'''
'''--- congress/src/ext.rs ---
use near_sdk::ext_contract;
use near_sdk::json_types::U128;

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_execute(&mut self, prop_id: u32, budget: U128);
    fn on_ban_dismiss(&mut self, prop_id: u32);
}

'''
'''--- congress/src/lib.rs ---
use std::cmp::min;
use std::collections::HashMap;

use common::errors::HookError;
use common::finalize_storage_check;
use events::*;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::{
    env, near_bindgen, require, AccountId, Balance, Gas, PanicOnDefault, Promise, PromiseError,
    PromiseOrValue, PromiseResult,
};
use serde_json::json;

mod constants;
mod errors;
mod events;
mod ext;
mod migrate;
pub mod proposal;
mod storage;
pub mod view;

pub use crate::constants::*;
pub use crate::errors::*;
pub use crate::ext::*;
pub use crate::proposal::*;
use crate::storage::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// address of the community fund, where the excess of NEAR will be sent on dissolve and cleanup.
    pub community_fund: AccountId,
    /// I Am Human registry
    pub registry: AccountId,

    pub dissolved: bool,
    pub prop_counter: u32,
    pub proposals: LookupMap<u32, Proposal>,

    /// Map of accounts authorized create proposals and vote for proposals
    // We can use single object rather than LookupMap because the maximum amount of members
    // is 17 (for HoM: 15 + 2)
    pub members: LazyOption<(Vec<AccountId>, Vec<PropPerm>)>,
    /// length of members
    pub members_len: u8,
    /// minimum amount of members to approve the proposal
    pub threshold: u8,

    /// Map of accounts authorized to call hooks.
    pub hook_auth: LazyOption<HashMap<AccountId, Vec<HookPerm>>>,

    /// all times below are in miliseconds
    pub start_time: u64,
    pub end_time: u64,
    pub cooldown: u64,
    pub vote_duration: u64,
    pub min_vote_duration: u64,

    pub budget_spent: Balance,
    pub budget_cap: Balance,
    /// size (in yocto NEAR) of the big funding request
    pub big_funding_threshold: Balance,
}

#[near_bindgen]
impl Contract {
    #[init]
    /// * hook_auth : map of accounts authorized to call hooks
    pub fn new(
        community_fund: AccountId,
        start_time: u64,
        end_time: u64,
        cooldown: u64,
        vote_duration: u64,
        min_vote_duration: u64,
        #[allow(unused_mut)] mut members: Vec<AccountId>,
        member_perms: Vec<PropPerm>,
        hook_auth: HashMap<AccountId, Vec<HookPerm>>,
        budget_cap: U128,
        big_funding_threshold: U128,
        registry: AccountId,
    ) -> Self {
        // we can support up to 255 with the limitation of the proposal type, but setting 100
        // here because this is more than enough for what we need to test for Congress.
        let members_len = members.len() as u8;
        near_sdk::require!(members_len <= 100, "max amount of members is 100");
        let threshold = (members_len / 2) + 1;
        members.sort();
        Self {
            community_fund,
            dissolved: false,
            prop_counter: 0,
            proposals: LookupMap::new(StorageKey::Proposals),
            members: LazyOption::new(StorageKey::Members, Some(&(members, member_perms))),
            members_len,
            threshold,
            hook_auth: LazyOption::new(StorageKey::HookAuth, Some(&hook_auth)),
            start_time,
            end_time,
            cooldown,
            vote_duration,
            min_vote_duration,
            budget_spent: 0,
            budget_cap: budget_cap.0,
            big_funding_threshold: big_funding_threshold.0,
            registry,
        }
    }

    /*
     * Queries are in view.rs
     */

    /**********
     * TRANSACTIONS
     **********/

    /// Creates a new proposal. `start` and `end` is Unix Time in milliseconds.
    /// Returns the new proposal ID.
    /// Caller is required to attach enough deposit to cover the proposal storage as well as all
    /// possible votes (2*self.threshold - 1).
    /// NOTE: storage is paid from the account state
    #[payable]
    #[handle_result]
    pub fn create_proposal(
        &mut self,
        kind: PropKind,
        description: String,
    ) -> Result<u32, CreatePropError> {
        self.assert_active();
        let storage_start = env::storage_usage();
        let user = env::predecessor_account_id();
        let (members, perms) = self.members.get().unwrap();
        if members.binary_search(&user).is_err() {
            return Err(CreatePropError::NotAuthorized);
        }
        if !perms.contains(&kind.required_perm()) {
            return Err(CreatePropError::KindNotAllowed);
        }

        let now = env::block_timestamp_ms();
        let mut new_budget = 0;
        match &kind {
            PropKind::FundingRequest(b) => {
                new_budget = self.budget_spent + b.0;
            }
            PropKind::RecurrentFundingRequest(b) => {
                new_budget = self.budget_spent + b.0 * (self.remaining_months(now) as u128);
            }
            PropKind::FunctionCall { actions, .. } => {
                let mut sum_gas = 0;
                for a in actions {
                    if a.gas.0 < EXEC_CTR_CALL_GAS.0 || a.gas.0 > MAX_EXEC_FUN_CALL_GAS.0 {
                        return Err(CreatePropError::Gas(
                            "action gas must be between 8tgas and 280tgas".to_owned(),
                        ));
                    }
                    sum_gas += a.gas.0;
                }
                if sum_gas > MAX_EXEC_FUN_CALL_GAS.0 {
                    return Err(CreatePropError::Gas(
                        "sum of action gas can't exceed 276tgas".to_owned(),
                    ));
                }
            }
            _ => (),
        };
        if new_budget > self.budget_cap {
            return Err(CreatePropError::BudgetOverflow);
        }

        self.prop_counter += 1;
        emit_prop_created(self.prop_counter, &kind);
        self.proposals.insert(
            &self.prop_counter,
            &Proposal {
                proposer: user.clone(),
                description,
                kind,
                status: ProposalStatus::InProgress,
                approve: 0,
                reject: 0,
                abstain: 0,
                votes: HashMap::new(),
                submission_time: now,
                approved_at: None,
            },
        );

        // max amount of votes is threshold + threshold-1.
        let extra_storage = VOTE_STORAGE * (2 * self.threshold - 1) as u64;
        if let Err(reason) = finalize_storage_check(storage_start, extra_storage, user) {
            return Err(CreatePropError::Storage(reason));
        }

        Ok(self.prop_counter)
    }

    #[handle_result]
    pub fn vote(&mut self, id: u32, vote: Vote) -> Result<(), VoteError> {
        self.assert_active();
        let user = env::predecessor_account_id();
        let (members, _) = self.members.get().unwrap();
        if members.binary_search(&user).is_err() {
            return Err(VoteError::NotAuthorized);
        }
        let mut prop = self.assert_proposal(id);

        self.assert_member_not_involved(&prop, &user)?;

        if !matches!(prop.status, ProposalStatus::InProgress) {
            return Err(VoteError::NotInProgress);
        }
        let now = env::block_timestamp_ms();
        if now > prop.submission_time + self.vote_duration {
            return Err(VoteError::NotActive);
        }

        prop.add_vote(user, vote, self.threshold)?;
        prop.finalize_status(
            members.len(),
            self.threshold,
            self.min_vote_duration,
            self.vote_duration,
        );

        self.proposals.insert(&id, &prop);
        emit_vote(id);

        // automatic execution
        if matches!(prop.status, ProposalStatus::Approved) && self.cooldown == 0 {
            // We ignore a failure of self.execute here to assure that the vote is counted.
            let res = self.execute(id);
            if res.is_err() {
                emit_vote_execute_fail(id, res.err().unwrap());
            }
        }

        Ok(())
    }

    /// Allows anyone to execute proposal.
    /// If `contract.cooldown` is set, then a proposal can be only executed after the cooldown:
    /// (submission_time + vote_duration + cooldown).
    #[handle_result]
    pub fn execute(
        &mut self,
        id: u32,
    ) -> Result<PromiseOrValue<Result<(), ExecRespErr>>, ExecError> {
        self.assert_active();
        let mut prop = self.assert_proposal(id);
        if matches!(prop.status, ProposalStatus::Executed) {
            // More fine-grained errors
            return Err(ExecError::AlreadyExecuted);
        }
        // check if we can finalize the proposal status due to having enough votes during min_vote_duration
        if matches!(prop.status, ProposalStatus::InProgress) {
            let (members, _) = self.members.get().unwrap();
            if !prop.finalize_status(
                members.len(),
                self.threshold,
                self.min_vote_duration,
                self.vote_duration,
            ) {
                return Err(ExecError::MinVoteDuration);
            }
        }
        if !matches!(
            prop.status,
            // if the previous proposal execution failed, we should be able to re-execute it
            ProposalStatus::Approved | ProposalStatus::Failed
        ) {
            return Err(ExecError::NotApproved);
        }

        let now = env::block_timestamp_ms();
        if self.cooldown > 0 && now <= prop.approved_at.unwrap() + self.cooldown {
            return Err(ExecError::ExecTime);
        }

        prop.status = ProposalStatus::Executed;
        let mut result = PromiseOrValue::Value(Ok(()));
        let mut budget = 0;
        match &prop.kind {
            PropKind::FunctionCall {
                receiver_id,
                actions,
            } => {
                let mut promise = Promise::new(receiver_id.clone());
                for action in actions {
                    promise = promise.function_call(
                        action.method_name.clone(),
                        action.args.clone().into(),
                        action.deposit.0,
                        Gas(action.gas.0),
                    );
                }
                result = promise.into();
            }
            PropKind::FundingRequest(b) => budget = b.0,
            PropKind::RecurrentFundingRequest(b) => {
                budget = b.0 * self.remaining_months(now) as u128
            }
            PropKind::Text => (),
            PropKind::DismissAndBan { member, house } => {
                self.proposals.insert(&id, &prop);

                let ban_promise = Promise::new(self.registry.clone()).function_call(
                    "admin_flag_accounts".to_owned(),
                    json!({ "flag": "GovBan".to_owned(),
                        "accounts": vec![member],
                        "memo": "".to_owned()
                    })
                        .to_string()
                        .as_bytes()
                        .to_vec(),
                    0,
                    EXEC_CTR_CALL_GAS,
                );

                let dismiss_promise = Promise::new(house.clone()).function_call(
                    "dismiss_hook".to_owned(),
                    json!({ "member": member }).to_string().as_bytes().to_vec(),
                    0,
                    EXEC_CTR_CALL_GAS,
                );

                return Ok(PromiseOrValue::Promise(
                    ban_promise.and(dismiss_promise).then(
                        ext_self::ext(env::current_account_id())
                            .with_static_gas(EXECUTE_CALLBACK_GAS)
                            .on_ban_dismiss(id),
                    ),
                ));
            }
        };
        if budget != 0 {
            self.budget_spent += budget;
            if self.budget_spent > self.budget_cap {
                prop.status = ProposalStatus::Rejected;
                self.proposals.insert(&id, &prop);
                return Ok(PromiseOrValue::Value(Err(ExecRespErr::BudgetOverflow)));
            }
        }
        self.proposals.insert(&id, &prop);

        let result = match result {
            PromiseOrValue::Promise(promise) => promise
                .then(
                    ext_self::ext(env::current_account_id())
                        .with_static_gas(EXECUTE_CALLBACK_GAS)
                        .on_execute(id, budget.into()),
                )
                .into(),
            _ => {
                emit_executed(id);
                result
            }
        };
        Ok(result)
    }

    /// Veto proposal hook
    /// * `id`: proposal id
    #[handle_result]
    pub fn veto_hook(&mut self, id: u32) -> Result<(), HookError> {
        self.assert_active();
        let mut proposal = self.assert_proposal(id);
        let is_big_or_recurrent = match proposal.kind {
            PropKind::FundingRequest(b) => b.0 >= self.big_funding_threshold,
            PropKind::RecurrentFundingRequest(_) => true,
            _ => false,
        };
        let caller = env::predecessor_account_id();
        if is_big_or_recurrent {
            self.assert_hook_perm(
                &caller,
                &[HookPerm::VetoBigOrReccurentFundingReq, HookPerm::VetoAll],
            )?;
        } else {
            self.assert_hook_perm(&caller, &[HookPerm::VetoAll])?;
        }

        match proposal.status {
            ProposalStatus::InProgress => {
                proposal.status = ProposalStatus::Vetoed;
            }
            ProposalStatus::Approved => {
                let cooldown = min(
                    proposal.submission_time + self.vote_duration,
                    proposal.approved_at.unwrap(),
                ) + self.cooldown;
                if cooldown < env::block_timestamp_ms() {
                    return Err(HookError::CooldownOver);
                }
                proposal.status = ProposalStatus::Vetoed;
            }
            _ => {
                return Err(HookError::ProposalFinalized);
            }
        }
        emit_veto(id);
        self.proposals.insert(&id, &proposal);
        Ok(())
    }

    /// Dissolve and finalize the DAO. Will send the excess account funds back to the community
    /// fund. If the term is over can be called by anyone.
    #[handle_result]
    pub fn dissolve_hook(&mut self) -> Result<(), HookError> {
        // only check permission if the DAO term is not over.
        if env::block_timestamp_ms() <= self.end_time {
            self.assert_hook_perm(&env::predecessor_account_id(), &[HookPerm::Dissolve])?;
        }
        self.dissolve_and_cleanup();
        Ok(())
    }

    #[handle_result]
    pub fn dismiss_hook(&mut self, member: AccountId) -> Result<(), HookError> {
        self.assert_active();
        self.assert_hook_perm(&env::predecessor_account_id(), &[HookPerm::Dismiss])?;
        let (mut members, perms) = self.members.get().unwrap();
        let idx = members.binary_search(&member);
        if idx.is_err() {
            // We need to return OK to allow to call this function multiple times to execute proposal which may compose other actions
            return Ok(());
        }
        members.remove(idx.unwrap());

        emit_dismiss(&member);

        // Update threshold and members_len
        self.members_len = members.len() as u8;
        self.threshold = (self.members_len / 2) + 1;

        // If DAO doesn't have required threshold, then we dissolve.
        if members.len() < 2 {
            self.dissolve_and_cleanup();
        }

        self.members.set(&(members, perms));
        Ok(())
    }

    /*****************
     * INTERNAL
     ****************/

    /// Returns Ok if the user has at least one of the `require_any` permissions.
    /// Otherwise returns Err.
    fn assert_hook_perm(
        &self,
        user: &AccountId,
        require_any: &[HookPerm],
    ) -> Result<(), HookError> {
        let auth_hook = self.hook_auth.get().unwrap();
        let perms = auth_hook.get(user);
        if perms.is_none() {
            return Err(HookError::NotAuthorized);
        }
        let perms = perms.unwrap();
        for r in require_any {
            if perms.contains(r) {
                return Ok(());
            }
        }
        Err(HookError::NotAuthorized)
    }

    fn assert_proposal(&self, id: u32) -> Proposal {
        self.proposals.get(&id).expect("proposal does not exist")
    }

    fn assert_member_not_involved(
        &self,
        prop: &Proposal,
        user: &AccountId,
    ) -> Result<(), VoteError> {
        match &prop.kind {
            PropKind::DismissAndBan { member, house: _ } => {
                if member == user {
                    return Err(VoteError::NoSelfVote);
                }
            }
            PropKind::FunctionCall {
                receiver_id: _,
                actions,
            } => {
                for action in actions {
                    if &action.method_name == "dismiss_hook" {
                        let encoded =
                            Base64VecU8(json!({ "member": user }).to_string().as_bytes().to_vec());
                        if encoded == action.args {
                            return Err(VoteError::NoSelfVote);
                        }
                    }
                }
            }
            _ => (),
        }
        Ok(())
    }

    fn assert_active(&self) {
        near_sdk::require!(!self.dissolved, "dao is dissolved");
        near_sdk::require!(
            env::block_timestamp_ms() <= self.end_time,
            "dao term is over, call dissolve_hook!"
        );
    }

    fn dissolve_and_cleanup(&mut self) {
        self.dissolved = true;
        emit_dissolve();
        // we leave 10B extra storage
        let required_deposit = (env::storage_usage() + 10) as u128 * env::storage_byte_cost();
        let diff = env::account_balance() - required_deposit;
        if diff > 0 {
            Promise::new(self.community_fund.clone()).transfer(diff);
        }
    }

    fn remaining_months(&self, now: u64) -> u64 {
        if self.end_time <= now {
            return 0;
        }
        // TODO: make correct calculation.
        // Need to check if recurrent budget can start immediately or from the next month.
        (self.end_time - now) / 30 / 24 / 3600 / 1000
    }

    #[private]
    pub fn on_execute(&mut self, prop_id: u32, budget: U128) {
        assert_eq!(
            env::promise_results_count(),
            1,
            "ERR_UNEXPECTED_CALLBACK_PROMISES"
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_) => {}
            PromiseResult::Failed => {
                let mut prop = self.assert_proposal(prop_id);
                self.budget_spent -= budget.0;
                prop.status = ProposalStatus::Failed;
                self.proposals.insert(&prop_id, &prop);
                emit_executed(prop_id);
            }
        };
    }

    #[private]
    pub fn on_ban_dismiss(
        &mut self,
        #[callback_result] ban_result: Result<(), PromiseError>,
        #[callback_result] dismiss_result: Result<(), PromiseError>,
        prop_id: u32,
    ) {
        if ban_result.is_err() || dismiss_result.is_err() {
            let mut prop = self.assert_proposal(prop_id);
            prop.status = ProposalStatus::Failed;
            self.proposals.insert(&prop_id, &prop);
            emit_executed(prop_id);
        }
    }

    /// Every house should be able to make a fun call proposals
    pub fn add_fun_call_perm(&mut self) {
        require!(env::predecessor_account_id() == env::current_account_id());
        let mut m = self.members.get().unwrap();
        if m.1.contains(&PropPerm::FunctionCall) {
            m.1.push(PropPerm::FunctionCall);
            self.members.set(&m);
        }
    }

    // Manually update the threshold and members_len
    pub fn update_threshold(&mut self) {
        require!(env::predecessor_account_id() == env::current_account_id());
        let (members, _) = self.members.get().unwrap();
        self.members_len = members.len() as u8;
        self.threshold = (self.members_len / 2) + 1;
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod unit_tests {
    use near_sdk::{
        test_utils::{get_logs, VMContextBuilder},
        testing_env, VMContext,
    };

    use crate::{view::MembersOutput, *};
    use near_sdk::json_types::{U128, U64};

    /// 1ms in nano seconds
    const MSECOND: u64 = 1_000_000;

    // In milliseconds
    const START: u64 = 60 * 5 * 1000;
    const TERM: u64 = 60 * 15 * 1000;
    const VOTE_DURATION: u64 = 60 * 5 * 1000;
    const MIN_VOTE_DURATION: u64 = 30 * 5 * 1000;
    const COOLDOWN: u64 = 40 * 5 * 1000;

    fn acc(idx: u8) -> AccountId {
        AccountId::new_unchecked(format!("user-{}.near", idx))
    }

    fn community_fund() -> AccountId {
        AccountId::new_unchecked("community-fund.near".to_string())
    }

    fn voting_body() -> AccountId {
        AccountId::new_unchecked("voting-body.near".to_string())
    }

    fn coa() -> AccountId {
        AccountId::new_unchecked("coa.near".to_string())
    }

    fn registry() -> AccountId {
        AccountId::new_unchecked("registry.near".to_string())
    }

    fn setup_ctr(attach_deposit: u128) -> (VMContext, Contract, u32) {
        let mut context = VMContextBuilder::new().build();
        let end_time = START + TERM;
        let mut hook_perms = HashMap::new();
        hook_perms.insert(coa(), vec![HookPerm::VetoAll]);
        hook_perms.insert(
            voting_body(),
            vec![
                HookPerm::Dismiss,
                HookPerm::Dissolve,
                HookPerm::VetoBigOrReccurentFundingReq,
            ],
        );

        let mut contract = Contract::new(
            community_fund(),
            START,
            end_time,
            COOLDOWN,
            VOTE_DURATION,
            MIN_VOTE_DURATION,
            vec![acc(1), acc(2), acc(3), acc(4)],
            vec![
                PropPerm::Text,
                PropPerm::RecurrentFundingRequest,
                PropPerm::FundingRequest,
                PropPerm::FunctionCall,
                PropPerm::DismissAndBan,
            ],
            hook_perms,
            U128(10000),
            U128(1000),
            registry(),
        );
        context.block_timestamp = START * MSECOND;
        context.predecessor_account_id = acc(1);
        context.attached_deposit = attach_deposit * MILI_NEAR;
        testing_env!(context.clone());

        let id = contract
            .create_proposal(PropKind::Text, "Proposal unit test 1".to_string())
            .unwrap();
        (context, contract, id)
    }

    fn vote(mut ctx: VMContext, mut ctr: Contract, accounts: Vec<AccountId>, id: u32) -> Contract {
        for account in accounts {
            ctx.predecessor_account_id = account;
            testing_env!(ctx.clone());
            assert_eq!(ctr.vote(id, Vote::Approve), Ok(()));
        }
        ctr
    }

    fn assert_hook_not_auth(res: Result<(), HookError>) {
        assert!(
            matches!(res, Err(HookError::NotAuthorized)),
            "got: {:?}",
            res
        );
    }

    fn assert_create_prop_not_allowed(res: Result<u32, CreatePropError>) {
        assert!(
            matches!(res, Err(CreatePropError::KindNotAllowed)),
            "got: {:?}",
            res
        );
    }

    fn assert_exec_ok(res: Result<PromiseOrValue<Result<(), ExecRespErr>>, ExecError>) {
        match res {
            Ok(_) => (),
            Err(err) => panic!("expecting Ok, got {:?}", err),
        };
    }

    #[test]
    fn basic_flow() {
        let (mut ctx, mut ctr, id) = setup_ctr(100);
        let mut prop = ctr.get_proposal(id);
        assert!(prop.is_some());
        assert_eq!(prop.unwrap().proposal.status, ProposalStatus::InProgress);

        assert_eq!(ctr.number_of_proposals(), 1);

        // check `get_proposals` query
        let res = ctr.get_proposals(0, 10, Some(false));
        assert_eq!(res, vec![ctr.get_proposal(id).unwrap()]);

        let id2 = ctr
            .create_proposal(PropKind::Text, "Proposal unit test 2".to_string())
            .unwrap();

        let id3 = ctr
            .create_proposal(PropKind::Text, "Proposal unit test 3".to_string())
            .unwrap();

        // reverse query
        let res = ctr.get_proposals(10, 10, Some(true));
        assert_eq!(
            res,
            vec![
                ctr.get_proposal(id3).unwrap(),
                ctr.get_proposal(id2).unwrap(),
                ctr.get_proposal(id).unwrap()
            ]
        );

        let res = ctr.get_proposals(3, 1, Some(true));
        assert_eq!(res, vec![ctr.get_proposal(id3).unwrap(),]);

        ctx.block_timestamp = (START + MIN_VOTE_DURATION + 10) * MSECOND;
        testing_env!(ctx.clone());
        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id);

        prop = ctr.get_proposal(id);
        assert!(prop.is_some());
        assert_eq!(prop.unwrap().proposal.status, ProposalStatus::Approved);

        ctx.predecessor_account_id = acc(4);
        testing_env!(ctx.clone());
        assert_eq!(ctr.vote(id, Vote::Approve), Err(VoteError::NotInProgress));

        ctx.block_timestamp = START * MSECOND;
        testing_env!(ctx.clone());
        let id = ctr
            .create_proposal(PropKind::Text, "proposal".to_owned())
            .unwrap();
        assert_eq!(ctr.vote(id, Vote::Approve), Ok(()));
        assert_eq!(ctr.vote(id, Vote::Reject), Err(VoteError::DoubleVote));
        assert_eq!(ctr.vote(id, Vote::Approve), Err(VoteError::DoubleVote));

        ctx.block_timestamp = (ctr.start_time + ctr.vote_duration + 1) * MSECOND;
        testing_env!(ctx.clone());
        assert_eq!(ctr.vote(id, Vote::Approve), Err(VoteError::NotActive));

        ctx.predecessor_account_id = acc(5);
        testing_env!(ctx.clone());
        assert_eq!(ctr.vote(id, Vote::Approve), Err(VoteError::NotAuthorized));

        ctx.predecessor_account_id = acc(2);
        ctx.block_timestamp = START * MSECOND;
        testing_env!(ctx.clone());

        // set cooldown=0 and min_vote_duration=0 and test for immediate execution
        ctr.cooldown = 0;
        ctr.min_vote_duration = 0;
        let id = ctr
            .create_proposal(PropKind::Text, "Proposal unit test 2".to_string())
            .unwrap();
        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id);
        let prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Executed);

        // create proposal, set timestamp past voting period, status should be rejected
        let id = ctr
            .create_proposal(PropKind::Text, "Proposal unit test query 3".to_string())
            .unwrap();
        let prop = ctr.get_proposal(id).unwrap();
        ctx.block_timestamp = (prop.proposal.submission_time + ctr.vote_duration + 1) * MSECOND;
        testing_env!(ctx);

        let prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Rejected);
    }

    #[test]
    #[should_panic(expected = "proposal does not exist")]
    fn proposal_does_not_exist() {
        let (_, mut ctr, _) = setup_ctr(100);
        ctr.vote(10, Vote::Approve).unwrap();
    }

    #[test]
    fn proposal_create_prop_permissions() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);
        let (members, _) = ctr.members.get().unwrap();
        ctr.members.set(&(members, vec![PropPerm::FundingRequest]));

        ctr.create_proposal(PropKind::FundingRequest(U128(10)), "".to_string())
            .unwrap();

        // creating other proposal kinds should fail
        assert_create_prop_not_allowed(
            ctr.create_proposal(PropKind::RecurrentFundingRequest(U128(10)), "".to_string()),
        );
        assert_create_prop_not_allowed(ctr.create_proposal(PropKind::Text, "".to_string()));
        assert_create_prop_not_allowed(ctr.create_proposal(
            PropKind::FunctionCall {
                receiver_id: acc(10),
                actions: vec![],
            },
            "".to_string(),
        ));

        ctx.attached_deposit = 1;
        testing_env!(ctx.clone());
        assert!(matches!(
            ctr.create_proposal(PropKind::FundingRequest(U128(1)), "".to_string()),
            Err(CreatePropError::Storage(_))
        ));

        ctx.predecessor_account_id = acc(6);
        ctx.attached_deposit = 10 * MILI_NEAR;
        testing_env!(ctx.clone());
        assert_eq!(
            ctr.create_proposal(PropKind::Text, "".to_string()),
            Err(CreatePropError::NotAuthorized)
        );

        // set remaining months to 2
        let (members, _) = ctr.members.get().unwrap();
        ctr.members
            .set(&(members, vec![PropPerm::RecurrentFundingRequest]));
        ctr.end_time = ctr.start_time + START * 12 * 24 * 61;
        ctx.predecessor_account_id = acc(2);
        testing_env!(ctx);
        assert_eq!(
            ctr.create_proposal(
                PropKind::RecurrentFundingRequest(U128((ctr.budget_cap / 2) + 1)),
                "".to_string(),
            ),
            Err(CreatePropError::BudgetOverflow)
        );
    }

    #[test]
    fn proposal_execution_text() {
        let (mut ctx, mut ctr, id) = setup_ctr(100);
        match ctr.execute(id) {
            Ok(_) => panic!("expected NotApproved, got: OK"),
            Err(err) => assert_eq!(err, ExecError::MinVoteDuration),
        }
        ctx.block_timestamp = (START + MIN_VOTE_DURATION + 10) * MSECOND;
        testing_env!(ctx.clone());
        match ctr.execute(id) {
            Ok(_) => panic!("expected NotApproved, got: OK"),
            Err(err) => assert_eq!(err, ExecError::NotApproved),
        }
        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id);

        let mut prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Approved);

        match ctr.execute(id) {
            Err(err) => assert_eq!(err, ExecError::ExecTime),
            Ok(_) => panic!("expected ExecTime, got: OK"),
        }

        ctx.block_timestamp = (ctr.start_time + ctr.cooldown + ctr.vote_duration + 1) * MSECOND;
        testing_env!(ctx);
        assert_exec_ok(ctr.execute(id));

        prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Executed);

        //
        // check double execution
        match ctr.execute(id) {
            Ok(_) => panic!("expecting Err"),
            Err(err) => assert_eq!(err, ExecError::AlreadyExecuted),
        };
    }

    #[test]
    fn proposal_execution_funding_req() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);

        let id = ctr
            .create_proposal(
                PropKind::FundingRequest(U128(1000u128)),
                "Funding req".to_owned(),
            )
            .unwrap();

        ctx.block_timestamp = (START + MIN_VOTE_DURATION + 10) * MSECOND;
        testing_env!(ctx.clone());
        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id);

        ctx.block_timestamp = (ctr.start_time + ctr.cooldown + ctr.vote_duration + 1) * MSECOND;
        testing_env!(ctx);

        assert_eq!(ctr.budget_spent, 0);
        assert_exec_ok(ctr.execute(id));
        assert_eq!(ctr.budget_spent, 1000);

        let res = ctr.create_proposal(
            PropKind::FundingRequest(U128(10000u128)),
            "Funding req".to_owned(),
        );
        match res {
            Err(CreatePropError::BudgetOverflow) => (),
            x => panic!("expected BudgetOverflow, got: {:?}", x),
        }
    }

    #[test]
    fn proposal_execution_rec_funding_req() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);

        let id = ctr
            .create_proposal(
                PropKind::RecurrentFundingRequest(U128(10u128)),
                "Rec Funding req".to_owned(),
            )
            .unwrap();

        ctx.block_timestamp = (START + MIN_VOTE_DURATION + 10) * MSECOND;
        testing_env!(ctx.clone());
        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id);

        // update to more than two months
        ctr.end_time = ctr.start_time + START * 12 * 24 * 61;
        ctx.block_timestamp = (ctr.start_time + ctr.cooldown + ctr.vote_duration + 1) * MSECOND;
        testing_env!(ctx);

        // proposal isn't executed so budget spent is 0
        assert_eq!(ctr.budget_spent, 0);
        assert_exec_ok(ctr.execute(id));

        // budget spent * remaining months
        assert_eq!(ctr.budget_spent, 20);
    }

    #[test]
    fn proposal_execution_budget_overflow() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);
        ctr.min_vote_duration = 0;

        // create and approve a funding requst that will fill up the budget.
        let id1 = ctr
            .create_proposal(
                PropKind::FundingRequest((ctr.budget_cap).into()),
                "Funding req".to_owned(),
            )
            .unwrap();
        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id1);

        // create a second proposal, that will go over the budget if proposal id1 is executed
        let time_diff = 10;
        ctx.block_timestamp += time_diff * MSECOND;
        testing_env!(ctx.clone());
        let id2 = ctr
            .create_proposal(
                PropKind::FundingRequest(10.into()),
                "Funding req".to_owned(),
            )
            .unwrap();
        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id2);
        let p2 = ctr.get_proposal(id2).unwrap();
        assert_eq!(p2.proposal.status, ProposalStatus::Approved);

        // execute the first proposal - it should work.
        ctx.block_timestamp += (VOTE_DURATION + COOLDOWN) * MSECOND;
        testing_env!(ctx.clone());
        assert_exec_ok(ctr.execute(id1));

        // execution of the second proposal should work, but the proposal should be rejected
        ctx.block_timestamp += (time_diff + 1) * MSECOND;
        testing_env!(ctx.clone());
        match ctr.execute(id2) {
            Ok(PromiseOrValue::Value(resp)) => assert_eq!(resp, Err(ExecRespErr::BudgetOverflow)),
            Ok(PromiseOrValue::Promise(_)) => {
                panic!("expecting Ok ExecRespErr::BudgetOverflow, got Ok Promise");
            }
            Err(err) => panic!(
                "expecting Ok ExecRespErr::BudgetOverflow, got: Err: {:?}",
                err
            ),
        }
    }

    #[test]
    #[should_panic(expected = "dao term is over, call dissolve_hook!")]
    fn dao_dissolve_time() {
        let (mut ctx, mut ctr, id) = setup_ctr(100);
        ctx.block_timestamp = (ctr.end_time + 1) * MSECOND;
        testing_env!(ctx);

        ctr.vote(id, Vote::Approve).unwrap();
    }

    #[test]
    fn veto_hook() {
        let (mut ctx, mut ctr, id) = setup_ctr(100);
        ctr.get_proposal(id).unwrap();
        match ctr.veto_hook(id) {
            Err(HookError::NotAuthorized) => (),
            x => panic!("expected NotAuthorized, got: {:?}", x),
        }

        ctx.predecessor_account_id = coa();
        testing_env!(ctx.clone());

        // Veto during voting phase(before cooldown)
        ctr.veto_hook(id).unwrap();
        let expected = r#"EVENT_JSON:{"standard":"ndc-congress","version":"1.0.0","event":"veto","data":{"prop_id":1}}"#;
        assert_eq!(vec![expected], get_logs());

        let mut prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Vetoed);

        ctx.predecessor_account_id = acc(1);
        testing_env!(ctx.clone());

        // Veto during cooldown
        let id = ctr
            .create_proposal(PropKind::Text, "Proposal unit test 2".to_string())
            .unwrap();

        // Set timestamp close to voting end duration
        ctx.block_timestamp = (prop.proposal.submission_time + ctr.vote_duration - 1) * MSECOND;
        testing_env!(ctx.clone());

        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id);
        prop = ctr.get_proposal(id).unwrap();

        // Set timestamp to during cooldown, after voting phase
        ctx.block_timestamp = (prop.proposal.submission_time + ctr.vote_duration + 1) * MSECOND;
        ctx.predecessor_account_id = coa();
        testing_env!(ctx.clone());

        ctr.veto_hook(id).unwrap();
        // veto vetoed prop
        assert_eq!(ctr.veto_hook(id), Err(HookError::ProposalFinalized));

        ctx.block_timestamp = START * MSECOND;
        ctx.predecessor_account_id = acc(1);
        testing_env!(ctx.clone());
        let id = ctr
            .create_proposal(PropKind::Text, "Proposal unit test 2".to_string())
            .unwrap();

        ctx.block_timestamp = (START + MIN_VOTE_DURATION + 10) * MSECOND;
        testing_env!(ctx.clone());
        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id);

        prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Approved);

        // Set timestamp to after cooldown
        ctx.block_timestamp =
            (prop.proposal.submission_time + ctr.vote_duration + ctr.cooldown + 1) * MSECOND;
        ctx.predecessor_account_id = coa();
        testing_env!(ctx);

        // Can execute past cooldown but not veto proposal
        assert_eq!(ctr.veto_hook(id), Err(HookError::CooldownOver));
        assert_exec_ok(ctr.execute(id));

        // Cannot veto executed or failed proposal
        assert_eq!(ctr.veto_hook(id), Err(HookError::ProposalFinalized));

        let mut prop = ctr.proposals.get(&id).unwrap();
        prop.status = ProposalStatus::Failed;
        ctr.proposals.insert(&id, &prop);
        assert_eq!(ctr.veto_hook(id), Err(HookError::ProposalFinalized));
    }

    fn create_all_props(ctr: &mut Contract) -> (u32, u32, u32, u32, u32) {
        let prop_text = ctr
            .create_proposal(PropKind::Text, "text proposal".to_string())
            .unwrap();
        let prop_fc = ctr
            .create_proposal(
                PropKind::FunctionCall {
                    receiver_id: acc(10),
                    actions: vec![],
                },
                "function call proposal".to_string(),
            )
            .unwrap();

        let prop_big = ctr
            .create_proposal(
                PropKind::FundingRequest(U128(1100)),
                "big funding request".to_string(),
            )
            .unwrap();
        let prop_small = ctr
            .create_proposal(
                PropKind::FundingRequest(U128(200)),
                "small funding request".to_string(),
            )
            .unwrap();
        let prop_rec = ctr
            .create_proposal(
                PropKind::RecurrentFundingRequest(U128(200)),
                "recurrent funding request".to_string(),
            )
            .unwrap();

        (prop_text, prop_fc, prop_big, prop_small, prop_rec)
    }

    #[test]
    fn veto_hook_big_funding_request() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);

        // CoA should be able to veto everything
        let (p_text, p_fc, p_big, p_small, p_rec) = create_all_props(&mut ctr);
        ctx.predecessor_account_id = coa();
        testing_env!(ctx.clone());
        ctr.veto_hook(p_text).unwrap();
        ctr.veto_hook(p_fc).unwrap();
        ctr.veto_hook(p_big).unwrap();
        ctr.veto_hook(p_small).unwrap();
        ctr.veto_hook(p_rec).unwrap();

        // Voting Body should only be able to veto big funding req. or recurrent one.
        ctx.predecessor_account_id = acc(1);
        testing_env!(ctx.clone());
        let (p_text, p_fc, p_big, p_small, p_rec) = create_all_props(&mut ctr);
        ctx.predecessor_account_id = voting_body();
        testing_env!(ctx);
        ctr.veto_hook(p_big).unwrap();
        ctr.veto_hook(p_rec).unwrap();
        assert_hook_not_auth(ctr.veto_hook(p_text));
        assert_hook_not_auth(ctr.veto_hook(p_fc));
        assert_hook_not_auth(ctr.veto_hook(p_small));
    }

    #[test]
    #[should_panic(expected = "dao is dissolved")]
    fn dissolve_hook() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);

        match ctr.dissolve_hook() {
            Err(HookError::NotAuthorized) => (),
            x => panic!("expected NotAuthorized, got: {:?}", x),
        }

        ctx.predecessor_account_id = voting_body();
        testing_env!(ctx);

        ctr.dissolve_hook().unwrap();
        let expected = r#"EVENT_JSON:{"standard":"ndc-congress","version":"1.0.0","event":"dissolve","data":""}"#;
        assert_eq!(vec![expected], get_logs());
        assert!(ctr.dissolved);

        ctr.create_proposal(
            PropKind::FundingRequest(U128(10000u128)),
            "Funding req".to_owned(),
        )
        .unwrap();
    }

    #[test]
    fn dismiss_hook() {
        let (mut ctx, mut ctr, id) = setup_ctr(100);

        assert_eq!(ctr.dismiss_hook(acc(2)), Err(HookError::NotAuthorized));

        ctx.predecessor_account_id = voting_body();
        testing_env!(ctx.clone());
        assert_eq!(ctr.dismiss_hook(acc(10)), Ok(()));
        ctr.dismiss_hook(acc(2)).unwrap();

        let expected = r#"EVENT_JSON:{"standard":"ndc-congress","version":"1.0.0","event":"dismiss","data":{"member":"user-2.near"}}"#;
        assert_eq!(vec![expected], get_logs());
        assert_eq!(ctr.member_permissions(acc(2)), vec![]);

        // Proposal should not pass with only 2 votes
        let mut prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::InProgress);
        ctr = vote(ctx.clone(), ctr, [acc(1), acc(3)].to_vec(), id);

        prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::InProgress);

        ctx.predecessor_account_id = voting_body();
        testing_env!(ctx);

        // Remove more members to check threshold update
        ctr.dismiss_hook(acc(1)).unwrap();
        let (members, _) = ctr.members.get().unwrap();
        assert_eq!(members.len(), 2);
        assert_eq!(ctr.threshold, 2);
    }

    #[test]
    fn dismiss_hook_threshold_update() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);

        // Initial checks to confirm setup is correct
        assert_eq!(ctr.members_len, 4, "Initial members length should be 4");
        assert_eq!(ctr.threshold, 3, "Initial threshold should be 3");

        // Simulate calling dismiss_hook as the voting body to remove a member
        ctx.predecessor_account_id = voting_body();
        testing_env!(ctx);
        ctr.dismiss_hook(acc(2)).unwrap();

        // Check if member was successfully removed
        let (members, _) = ctr.members.get().unwrap();
        assert!(!members.contains(&acc(2)), "Member 2 should have been removed");

        // Check if members count and threshold are updated correctly
        assert_eq!(ctr.members_len, 3, "Members length should be updated to 3");
        assert_eq!(ctr.threshold, 2, "Threshold should be updated to 2");

        assert!(!ctr.dissolved);
        // Remove more members to check dissolve
        for member in &[acc(1), acc(3)] {
            ctr.dismiss_hook(member.clone()).unwrap();
        }
        assert!(ctr.dissolved);
    }

    #[test]
    fn dismiss_order() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);
        ctx.predecessor_account_id = voting_body();
        testing_env!(ctx);

        let (mut members, permissions) = ctr.members.get().unwrap();
        members.push(acc(5));
        members.push(acc(6));
        ctr.members.set(&(members, permissions.clone()));

        // remove from middle
        ctr.dismiss_hook(acc(2)).unwrap();

        // should be sorted list
        assert_eq!(
            ctr.get_members(),
            MembersOutput {
                members: vec![acc(1), acc(3), acc(4), acc(5), acc(6)],
                permissions: permissions.clone()
            }
        );

        // Remove more members
        ctr.dismiss_hook(acc(1)).unwrap();
        assert_eq!(
            ctr.get_members(),
            MembersOutput {
                members: vec![acc(3), acc(4), acc(5), acc(6)],
                permissions
            }
        );
    }

    #[test]
    fn tc_dismiss_ban() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);
        let motion_rem_ban = ctr
            .create_proposal(
                PropKind::DismissAndBan {
                    member: acc(1),
                    house: coa(),
                },
                "Motion to remove member and ban".to_string(),
            )
            .unwrap();

        ctx.block_timestamp = (START + MIN_VOTE_DURATION + 10) * MSECOND;
        ctr = vote(
            ctx.clone(),
            ctr,
            [acc(4), acc(2), acc(3)].to_vec(),
            motion_rem_ban,
        );
        let mut prop = ctr.get_proposal(motion_rem_ban).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Approved);

        // Set timestamp to after cooldown
        ctx.block_timestamp =
            (prop.proposal.submission_time + ctr.vote_duration + ctr.cooldown + 1) * MSECOND;
        testing_env!(ctx);
        assert_exec_ok(ctr.execute(motion_rem_ban));

        prop = ctr.get_proposal(motion_rem_ban).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Executed);

        // callback
        ctr.on_ban_dismiss(Ok(()), Ok(()), motion_rem_ban);
        prop = ctr.get_proposal(motion_rem_ban).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Executed);

        ctr.on_ban_dismiss(Result::Err(PromiseError::Failed), Ok(()), motion_rem_ban);
        prop = ctr.get_proposal(motion_rem_ban).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Failed);

        ctr.on_ban_dismiss(Ok(()), Result::Err(PromiseError::Failed), motion_rem_ban);
        prop = ctr.get_proposal(motion_rem_ban).unwrap();
        assert_eq!(prop.proposal.status, ProposalStatus::Failed);
    }

    #[test]
    fn dismiss_ban_vote_against() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);
        let prop = ctr
            .create_proposal(
                PropKind::DismissAndBan {
                    member: acc(1),
                    house: coa(),
                },
                "Motion to remove member and ban".to_string(),
            )
            .unwrap();

        ctx.predecessor_account_id = acc(1);
        testing_env!(ctx.clone());
        match ctr.vote(prop, Vote::Approve) {
            Err(VoteError::NoSelfVote) => (),
            x => panic!("expected NotAllowedAgainst, got: {:?}", x),
        }
    }

    #[test]
    fn dismiss_vote_against() {
        let (mut ctx, mut ctr, _) = setup_ctr(100);
        let prop = ctr
            .create_proposal(
                PropKind::FunctionCall {
                    receiver_id: coa(),
                    actions: [ActionCall {
                        method_name: "dismiss_hook".to_string(),
                        args: Base64VecU8(
                            json!({ "member": acc(2) }).to_string().as_bytes().to_vec(),
                        ),
                        deposit: U128(0),
                        gas: U64(EXEC_CTR_CALL_GAS.0),
                    }]
                    .to_vec(),
                },
                "Proposal to remove member".to_string(),
            )
            .unwrap();

        ctx.predecessor_account_id = acc(2);
        testing_env!(ctx.clone());
        assert_eq!(ctr.vote(prop, Vote::Approve), Err(VoteError::NoSelfVote));
    }

    #[test]
    fn abstain_vote() {
        let (_, mut ctr, id) = setup_ctr(100);
        ctr.vote(id, Vote::Abstain).unwrap();
        let prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.abstain, 1);
    }

    #[test]
    fn is_member() {
        let (_, ctr, _) = setup_ctr(100);
        assert!(ctr.is_member(acc(2)));
        assert!(!ctr.is_member(acc(10)))
    }

    #[test]
    fn vote_timestamp() {
        let (mut ctx, mut ctr, id) = setup_ctr(100);

        ctx.predecessor_account_id = acc(1);
        ctx.block_timestamp = START * MSECOND;
        testing_env!(ctx.clone());
        ctr.vote(id, Vote::Approve).unwrap();
        let prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.votes.get(&acc(1)).unwrap().timestamp, START);

        ctx.predecessor_account_id = acc(2);
        ctx.block_timestamp = (START + 100) * MSECOND;
        testing_env!(ctx.clone());
        ctr.vote(id, Vote::Approve).unwrap();
        let prop = ctr.get_proposal(id).unwrap();
        assert_eq!(
            prop.proposal.votes.get(&acc(2)).unwrap().timestamp,
            START + 100
        );
    }

    #[test]
    fn min_vote_duration_execute() {
        let (mut ctx, mut ctr, id) = setup_ctr(100);
        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id);
        let p = ctr.get_proposal(id).unwrap();
        assert_eq!(p.proposal.status, ProposalStatus::InProgress);

        // should not be able to exeucte a proposal while in min_vote_duration
        ctx.block_timestamp = (START + MIN_VOTE_DURATION - 10) * MSECOND;
        let p = ctr.get_proposal(id).unwrap();
        assert_eq!(p.proposal.status, ProposalStatus::InProgress);
        testing_env!(ctx.clone());
        match ctr.execute(id) {
            Ok(_) => panic!("expecting Err"),
            Err(err) => assert_eq!(err, ExecError::MinVoteDuration),
        };

        ctx.block_timestamp = (START + MIN_VOTE_DURATION + 10) * MSECOND;
        testing_env!(ctx.clone());
        // proposal status should be reported correctly, however we need to wait for cooldow
        // to execute
        let p = ctr.get_proposal(id).unwrap();
        assert_eq!(p.proposal.status, ProposalStatus::Approved);
        match ctr.execute(id) {
            Ok(_) => panic!("expecting Err"),
            Err(err) => assert_eq!(err, ExecError::ExecTime),
        };

        // cooldown starts when the proposal is "virtually approved" -> that is when it received
        // enough approve votes. In this test case, the propoosal was virtually approved
        // at START, so we should be able to execute proposal right after the cooldown.
        ctx.block_timestamp = (START + COOLDOWN + 1) * MSECOND;
        testing_env!(ctx.clone());
        let p = ctr.get_proposal(id).unwrap();
        assert_eq!(p.proposal.status, ProposalStatus::Approved);
        assert_exec_ok(ctr.execute(id))
    }

    #[test]
    fn all_votes_casted() {
        let (ctx, mut ctr, id) = setup_ctr(100);
        let mut prop = ctr.get_proposal(id);
        assert_eq!(prop.unwrap().proposal.status, ProposalStatus::InProgress);

        ctr = vote(ctx.clone(), ctr, [acc(1), acc(2), acc(3)].to_vec(), id);

        prop = ctr.get_proposal(id);
        assert_eq!(prop.unwrap().proposal.status, ProposalStatus::InProgress);
        ctr = vote(ctx.clone(), ctr, [acc(4)].to_vec(), id);

        prop = ctr.get_proposal(id);
        assert_eq!(prop.unwrap().proposal.status, ProposalStatus::Approved);
    }

    #[test]
    fn members_len() {
        let (_, ctr, _) = setup_ctr(100);
        assert_eq!(ctr.members_len(), 4);
    }
}

'''
'''--- congress/src/migrate.rs ---
use crate::*;
#[derive(BorshDeserialize, BorshSerialize)]
pub struct OldState {
    pub community_fund: AccountId,
    pub registry: AccountId,
    pub dissolved: bool,
    pub prop_counter: u32,
    pub proposals: LookupMap<u32, Proposal>,
    pub members: LazyOption<(Vec<AccountId>, Vec<PropPerm>)>,
    pub threshold: u8,
    pub hook_auth: LazyOption<HashMap<AccountId, Vec<HookPerm>>>,
    pub start_time: u64,
    pub end_time: u64,
    pub cooldown: u64,
    pub voting_duration: u64,
    pub min_voting_duration: u64,
    pub budget_spent: Balance,
    pub budget_cap: Balance,
    pub big_funding_threshold: Balance,
}

#[near_bindgen]
impl Contract {
    #[private]
    #[init(ignore_state)]
    /* pub  */
    pub fn migrate() -> Self {
        let old_state: OldState = env::state_read().expect("failed");
        // new field in the smart contract :
        // + members_len: u8,
        // new field field in proposal

        let members_len = old_state.members.get().unwrap().0.len() as u8;

        Self {
            community_fund: old_state.community_fund,
            registry: old_state.registry,
            dissolved: old_state.dissolved,
            prop_counter: old_state.prop_counter,
            proposals: old_state.proposals,
            members: old_state.members,
            members_len,
            threshold: old_state.threshold,
            hook_auth: old_state.hook_auth,
            start_time: old_state.start_time,
            end_time: old_state.end_time,
            cooldown: old_state.cooldown,
            vote_duration: old_state.voting_duration,
            min_vote_duration: old_state.min_voting_duration,
            budget_spent: old_state.budget_spent,
            budget_cap: old_state.budget_cap,
            big_funding_threshold: old_state.big_funding_threshold,
        }
    }
}

'''
'''--- congress/src/proposal.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base64VecU8, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId};

use std::collections::HashMap;

use crate::VoteError;

/// Proposal that are sent to this DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[cfg_attr(any(test, not(target_arch = "wasm32")), derive(Deserialize))]
pub struct Proposal {
    /// Original proposer.
    pub proposer: AccountId,
    /// Description of this proposal.
    pub description: String,
    /// Kind of proposal with relevant information.
    pub kind: PropKind,
    /// Current status of the proposal.
    pub status: ProposalStatus,
    /// Sum of approval votes. Note: contract assumes that max amount of members is 255
    pub approve: u8,
    /// Sum of rejection votes. Note: contract assumes that max amount of members is 255
    pub reject: u8,
    /// Sum of abstain votes. Note: contract assumes that max amount of members is 255.
    /// Abstain votes express that someone participates in the voting, but doesn't approve nor reject the proposal.
    /// Abstain votes don't count into the final tally.
    pub abstain: u8,
    /// Map of who voted and how.
    pub votes: HashMap<AccountId, VoteRecord>,
    /// Submission time (for voting period).
    pub submission_time: u64,
    /// Unix time in miliseconds when the proposal reached approval threshold. `None` if it is not approved.
    pub approved_at: Option<u64>,
}

impl Proposal {
    pub fn add_vote(
        &mut self,
        user: AccountId,
        vote: Vote,
        threshold: u8,
    ) -> Result<(), VoteError> {
        if self.votes.contains_key(&user) {
            return Err(VoteError::DoubleVote);
        }
        match vote {
            Vote::Approve => {
                self.approve += 1;
                if self.approve >= threshold {
                    self.approved_at = Some(env::block_timestamp_ms());
                }
            }
            Vote::Reject => {
                self.reject += 1;
            }
            Vote::Abstain => {
                self.abstain += 1;
            }
        }
        self.votes.insert(
            user,
            VoteRecord {
                timestamp: env::block_timestamp_ms(),
                vote,
            },
        );

        Ok(())
    }

    /// Returns true if it's past min voting duration
    pub fn finalize_status(
        &mut self,
        members_num: usize,
        threshold: u8,
        min_vote_duration: u64,
        vote_duration: u64,
    ) -> bool {
        if !matches!(self.status, ProposalStatus::InProgress) {
            return true;
        }
        let past_min_vote_duration = self.past_min_vote_duration(min_vote_duration);
        let all_voted = self.votes.len() == members_num;
        if past_min_vote_duration || all_voted {
            if self.approve >= threshold {
                self.status = ProposalStatus::Approved;
            } else if self.reject + self.abstain > members_num as u8 - threshold
                || env::block_timestamp_ms() > self.submission_time + vote_duration
            {
                self.status = ProposalStatus::Rejected;
            }
        }
        past_min_vote_duration
    }

    pub fn past_min_vote_duration(&self, min_vote_duration: u64) -> bool {
        if min_vote_duration == 0 {
            return true;
        }
        self.submission_time + min_vote_duration < env::block_timestamp_ms()
    }
}

/// Kinds of proposals, doing different action.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub enum PropKind {
    /// Calls `receiver_id` with list of method names in a single promise.
    /// Allows this contract to execute any arbitrary set of actions in other contracts.
    FunctionCall {
        receiver_id: AccountId,
        actions: Vec<ActionCall>,
    },
    /// a default, text based proposal.
    /// Note: NewBudget, UpdateBudge are modelled using Text.
    // NOTE: In Sputnik, this variant kind is called `Vote`
    Text,
    /// Single funding request.
    FundingRequest(U128),
    /// Funding request that will renew every month until the end of the terms. The balance
    /// parameter is the size of the single month spending for this funding request.
    RecurrentFundingRequest(U128),
    // TODO: support self upgrade.
    // /// Upgrade this contract with given hash from blob store.
    // UpgradeSelf { hash: Base58CryptoHash },
    // A proposal to remove the member from their role and ban them from future participation.
    DismissAndBan {
        member: AccountId,
        house: AccountId,
    },
}

impl PropKind {
    pub fn required_perm(&self) -> PropPerm {
        match self {
            PropKind::FunctionCall { .. } => PropPerm::FunctionCall,
            PropKind::Text { .. } => PropPerm::Text,
            PropKind::FundingRequest { .. } => PropPerm::FundingRequest,
            PropKind::RecurrentFundingRequest { .. } => PropPerm::RecurrentFundingRequest,
            PropKind::DismissAndBan { .. } => PropPerm::DismissAndBan,
        }
    }

    /// name of the kind
    pub fn to_name(&self) -> String {
        match self {
            PropKind::FunctionCall { .. } => "function-call".to_string(),
            PropKind::Text { .. } => "text".to_string(),
            PropKind::FundingRequest { .. } => "funding-request".to_string(),
            PropKind::RecurrentFundingRequest { .. } => "recurrent-funding-request".to_string(),
            PropKind::DismissAndBan { .. } => "remove-and-ban".to_string(),
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[cfg_attr(any(test, not(target_arch = "wasm32")), derive(Deserialize))]
pub enum ProposalStatus {
    InProgress,
    Approved,
    Rejected,
    Executed,
    /// If proposal has failed when executing. Allowed to re-finalize again to either expire or approved.
    Failed,
    // note: In Astra++ we have also: Removed nor Moved
    Vetoed,
}

/// Votes recorded in the proposal.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub enum Vote {
    Approve = 0x0,
    Reject = 0x1,
    Abstain = 0x2,
    // note: we don't have Remove
}

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
#[cfg_attr(any(test, not(target_arch = "wasm32")), derive(Deserialize))]
pub struct VoteRecord {
    pub timestamp: u64, // unix time of when this vote was submitted
    pub vote: Vote,
}

/// Function call arguments.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Clone))]
pub struct ActionCall {
    pub method_name: String,
    pub args: Base64VecU8,
    pub deposit: U128,
    pub gas: U64,
}

/// Permissions for creating proposals. See PropposalKind for more information.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq)]
#[cfg_attr(test, derive(Debug, Clone))]
#[serde(crate = "near_sdk::serde")]
pub enum PropPerm {
    FunctionCall,
    Text,
    FundingRequest,
    RecurrentFundingRequest,
    DismissAndBan,
}

/// Permissions for calling hooks
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Clone))]
#[serde(crate = "near_sdk::serde")]
pub enum HookPerm {
    /// Allows to veto any proposal kind
    VetoAll,
    /// Allows to veto only big funding requests or recurrent funding requests
    VetoBigOrReccurentFundingReq,
    Dismiss,
    Dissolve,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Clone, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub enum ExecRespErr {
    BudgetOverflow,
}

'''
'''--- congress/src/storage.rs ---
use near_sdk::borsh::{self, BorshSerialize};
use near_sdk::BorshStorageKey;

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Proposals,
    Members,
    HookAuth,
}

'''
'''--- congress/src/view.rs ---
use std::cmp::{max, min};

use itertools::Either;
#[allow(unused_imports)]
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;

/// This is format of output via JSON for the proposal.
#[derive(Serialize)]
#[cfg_attr(test, derive(Debug, PartialEq))]
#[cfg_attr(any(test, not(target_arch = "wasm32")), derive(Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalOutput {
    /// Id of the proposal.
    pub id: u32,
    #[serde(flatten)]
    pub proposal: Proposal,
}

/// This is format of output via JSON for the config.
#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ConfigOutput {
    pub threshold: u8,
    pub start_time: u64,
    pub end_time: u64,
    pub cooldown: u64,
    pub vote_duration: u64,
    pub budget_spent: U128,
    pub budget_cap: U128,
    pub big_funding_threshold: U128,
    pub min_vote_duration: u64,
}

#[derive(Serialize)]
#[cfg_attr(test, derive(Debug, PartialEq))]
#[cfg_attr(any(test, not(target_arch = "wasm32")), derive(Deserialize))]
#[serde(crate = "near_sdk::serde")]
pub struct MembersOutput {
    /// Id of the proposal.
    pub members: Vec<AccountId>,
    pub permissions: Vec<PropPerm>,
}

#[near_bindgen]
impl Contract {
    /**********
     * QUERIES
     **********/

    /// Returns all proposals
    /// Get proposals in paginated view.
    pub fn get_proposals(
        &self,
        from_index: u32,
        limit: u32,
        reverse: Option<bool>,
    ) -> Vec<ProposalOutput> {
        let iter = if reverse.unwrap_or(false) {
            let end = if from_index == 0 {
                self.prop_counter
            } else {
                min(from_index, self.prop_counter)
            };
            let start = if end <= limit { 1 } else { end - (limit - 1) };
            Either::Left((start..=end).rev())
        } else {
            let from_index = max(from_index, 1);
            Either::Right(from_index..=min(self.prop_counter, from_index + limit - 1))
        };

        let (members, _) = self.members.get().unwrap();
        let ml = members.len();

        iter.filter_map(|id| {
            self.proposals.get(&id).map(|mut proposal| {
                proposal.finalize_status(
                    ml,
                    self.threshold,
                    self.min_vote_duration,
                    self.vote_duration,
                );
                ProposalOutput { id, proposal }
            })
        })
        .collect()
    }

    /// Get specific proposal.
    pub fn get_proposal(&self, id: u32) -> Option<ProposalOutput> {
        let (members, _) = self.members.get().unwrap();
        let ml = members.len();
        self.proposals.get(&id).map(|mut proposal| {
            proposal.finalize_status(
                ml,
                self.threshold,
                self.min_vote_duration,
                self.vote_duration,
            );
            ProposalOutput { id, proposal }
        })
    }

    pub fn number_of_proposals(&self) -> u32 {
        self.prop_counter
    }

    pub fn is_dissolved(&self) -> bool {
        self.dissolved
    }

    pub fn members_len(&self) -> u8 {
        self.members_len
    }

    /// Returns all members with permissions
    pub fn get_members(&self) -> MembersOutput {
        let (members, permissions) = self.members.get().unwrap();
        MembersOutput {
            members,
            permissions,
        }
    }

    /// Returns all members with permissions
    pub fn is_member(&self, account: AccountId) -> bool {
        let (members, _) = self.members.get().unwrap();
        members.contains(&account)
    }

    /// Returns permissions of a given member.
    /// Returns empty vector (`[]`) if not a member.
    pub fn member_permissions(&self, member: AccountId) -> Vec<PropPerm> {
        let (members, perms) = self.members.get().unwrap();
        if members.binary_search(&member).is_ok() {
            return perms;
        }
        vec![]
    }

    /// Returns hook permissions for given account
    /// Returns empty vector `[]` if not a hook.
    pub fn hook_permissions(&self, user: AccountId) -> Vec<HookPerm> {
        let mut hooks = self.hook_auth.get().unwrap();
        hooks.remove(&user).unwrap_or(vec![])
    }

    /// Returns all hook permissions
    pub fn all_hook_permissions(&self) -> HashMap<AccountId, Vec<HookPerm>> {
        self.hook_auth.get().unwrap()
    }

    pub fn config(&self) -> ConfigOutput {
        ConfigOutput {
            threshold: self.threshold,
            start_time: self.start_time,
            end_time: self.end_time,
            cooldown: self.cooldown,
            vote_duration: self.vote_duration,
            budget_spent: U128(self.budget_spent),
            budget_cap: U128(self.budget_cap),
            big_funding_threshold: U128(self.big_funding_threshold),
            min_vote_duration: self.min_vote_duration,
        }
    }
}

'''
'''--- congress/tests/integration.rs ---
use std::collections::HashMap;

use congress::view::{MembersOutput, ProposalOutput};
use congress::{ActionCall, HookPerm, PropKind, PropPerm, ProposalStatus, Vote};

use integrations::{instantiate_congress, setup_registry};
use near_sdk::base64::{decode, encode};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::Deserialize;
use near_sdk::AccountId as NearAccountId;
use near_units::parse_near;
use near_workspaces::{Account, AccountId, Contract, DevNetwork, Worker};
use serde_json::json;

/// 1s in ms
const MSECOND: u64 = 1_000_000;

#[derive(Deserialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum AccountFlag {
    /// Account is "blacklisted" when it was marked as a scam or suspectible to be a mnipulated account or not a human.
    Blacklisted,
    /// Manually verified account.
    Verified,
    /// Account misbehaved and should be refused to have a significant governance role. However
    /// it will be able to vote as a Voting Body member.
    GovBan,
}

pub struct InitStruct {
    pub hom_contract: Contract,
    pub coa_contract: Contract,
    pub tc_contract: Contract,
    pub registry_contract: Contract,
    pub alice: Account,
    pub bob: Account,
    pub john: Account,
    pub admin: Account,
    pub proposal_id: u32,
}

async fn vote(users: Vec<Account>, dao: &Contract, proposal_id: u32) -> anyhow::Result<()> {
    for user in users.into_iter() {
        let res = user
            .call(dao.id(), "vote")
            .args_json(json!({"id": proposal_id, "vote": Vote::Approve,}))
            .max_gas()
            .transact()
            .await?;
        assert!(res.is_success(), "{:?}", res);
    }
    Ok(())
}

async fn init(worker: &Worker<impl DevNetwork>) -> anyhow::Result<InitStruct> {
    // deploy contracts
    let mut hom_contract = worker
        .dev_deploy(include_bytes!("../../res/congress.wasm"))
        .await?;
    let mut coa_contract = worker
        .dev_deploy(include_bytes!("../../res/congress.wasm"))
        .await?;
    let mut tc_contract = worker
        .dev_deploy(include_bytes!("../../res/congress.wasm"))
        .await?;

    let admin = worker.dev_create_account().await?;
    let community_fund = worker.dev_create_account().await?;
    let iah_issuer = worker.dev_create_account().await?;
    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;
    let john = worker.dev_create_account().await?;

    let registry_contract = setup_registry(
        worker,
        admin.clone(),
        tc_contract.as_account().clone(),
        iah_issuer.clone(),
        vec![tc_contract.id().clone()],
    )
    .await?;

    // get current block time
    let block = worker.view_block().await?;
    let now = block.timestamp() / MSECOND; // timestamp in milliseconds

    // initialize TC
    tc_contract = instantiate_congress(
        tc_contract,
        now,
        vec![alice.id(), bob.id(), john.id()],
        vec![
            PropPerm::Text,
            PropPerm::FunctionCall,
            PropPerm::DismissAndBan,
        ],
        HashMap::new(),
        community_fund.clone(),
        registry_contract.id(),
        0,
    )
    .await?;

    let mut coa_hook = HashMap::new();
    coa_hook.insert(
        tc_contract.id().clone(),
        vec![HookPerm::Dismiss, HookPerm::Dissolve],
    );
    // initialize CoA
    coa_contract = instantiate_congress(
        coa_contract,
        now,
        vec![alice.id(), bob.id(), john.id()],
        vec![PropPerm::Text, PropPerm::FunctionCall],
        coa_hook,
        community_fund.clone(),
        registry_contract.id(),
        0,
    )
    .await?;

    let mut hom_hook = HashMap::new();
    hom_hook.insert(
        tc_contract.id().clone(),
        vec![HookPerm::Dismiss, HookPerm::Dissolve],
    );
    hom_hook.insert(coa_contract.id().clone(), vec![HookPerm::VetoAll]);
    // initialize HoM
    hom_contract = instantiate_congress(
        hom_contract,
        now,
        vec![alice.id(), bob.id(), john.id()],
        vec![
            PropPerm::Text,
            PropPerm::FunctionCall,
            PropPerm::FundingRequest,
            PropPerm::RecurrentFundingRequest,
        ],
        hom_hook,
        community_fund.clone(),
        registry_contract.id(),
        10 * 1000,
    )
    .await?;

    // create a proposal
    let res2 = alice
        .call(hom_contract.id(), "create_proposal")
        .args_json(json!({
            "kind": PropKind::Text, "description": "Text proposal 1",
        }))
        .max_gas()
        .deposit(parse_near!("0.01 N"))
        .transact();
    let proposal_id: u32 = res2.await?.json()?;

    Ok(InitStruct {
        hom_contract: hom_contract.to_owned(),
        coa_contract: coa_contract.to_owned(),
        tc_contract: tc_contract.to_owned(),
        alice,
        bob,
        john,
        admin,
        proposal_id,
        registry_contract,
    })
}

#[tokio::test]
async fn full_prop_flow() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    // fast forward to the voting period
    worker.fast_forward(10).await?;

    vote(
        vec![setup.alice, setup.john],
        &setup.hom_contract,
        setup.proposal_id,
    )
    .await?;

    // fast forward to after cooldown
    worker.fast_forward(100).await?;

    let res = setup
        .bob
        .call(setup.hom_contract.id(), "execute")
        .args_json(json!({"id": setup.proposal_id,}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    worker.fast_forward(100).await?;
    // fast forward after end time is over
    let res = setup
        .bob
        .call(setup.hom_contract.id(), "execute")
        .args_json(json!({"id": setup.proposal_id,}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "{:?}", res);

    Ok(())
}

#[tokio::test]
async fn vote_by_non_member() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    // fast forward to the voting period
    worker.fast_forward(10).await?;

    let res = setup
        .admin
        .call(setup.hom_contract.id(), "vote")
        .args_json(json!({"id": setup.proposal_id, "vote": Vote::Approve,}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "{:?}", res);

    Ok(())
}

// Interhouse

#[tokio::test]
async fn tc_dismiss_coa() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let encoded = encode(json!({"member": setup.alice.id()}).to_string());

    let res2 = setup
        .alice
        .call(setup.tc_contract.id(), "create_proposal")
        .args_json(json!({
            "kind": PropKind::FunctionCall { receiver_id: to_near_account(setup.coa_contract.id()), actions: [ActionCall {
                method_name: "dismiss_hook".to_string(),
                args: decode(encoded).unwrap().into(),
                deposit: U128(0),
                gas: U64(10_000_000_000_000),
            }].to_vec() }, "description": "Veto proposal 1",
        }))
        .max_gas()
        .deposit(parse_near!("0.01 N"))
        .transact();
    let proposal_id: u32 = res2.await?.json()?;

    vote(
        vec![setup.john.clone(), setup.bob.clone()],
        &setup.tc_contract,
        proposal_id,
    )
    .await?;

    // after removal less members
    let members = setup
        .alice
        .call(setup.coa_contract.id(), "get_members")
        .view()
        .await?
        .json::<MembersOutput>()?;

    let mut expected = vec![
        to_near_account(setup.bob.id()),
        to_near_account(setup.john.id()),
    ];
    expected.sort();
    assert_eq!(members.members, expected);

    Ok(())
}

#[tokio::test]
async fn coa_veto_hom() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let encoded = encode(json!({"id": setup.proposal_id}).to_string());

    let res2 = setup
        .alice
        .call(setup.coa_contract.id(), "create_proposal")
        .args_json(json!({
            "kind": PropKind::FunctionCall { receiver_id: to_near_account(setup.hom_contract.id()), actions: [ActionCall {
                method_name: "veto_hook".to_string(),
                args: decode(encoded).unwrap().into(),
                deposit: U128(0),
                gas: U64(10_000_000_000_000),
            }].to_vec() }, "description": "Veto proposal 1",
        }))
        .max_gas()
        .deposit(parse_near!("0.01 N"))
        .transact();
    let proposal_id: u32 = res2.await?.json()?;

    vote(
        vec![setup.john.clone(), setup.bob.clone()],
        &setup.coa_contract,
        proposal_id,
    )
    .await?;

    // after execution proposal should be in Vetoed
    let members = setup
        .alice
        .call(setup.hom_contract.id(), "get_proposal")
        .args_json(json!({"id": setup.proposal_id}))
        .view()
        .await?
        .json::<Option<ProposalOutput>>()?;
    assert_eq!(members.unwrap().proposal.status, ProposalStatus::Vetoed);

    Ok(())
}

#[tokio::test]
async fn tc_ban_and_dismiss() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let res2 = setup
        .bob
        .call(setup.tc_contract.id(), "create_proposal")
        .args_json(json!({
            "kind": PropKind::DismissAndBan { member: to_near_account(setup.alice.id()), house:  to_near_account(setup.coa_contract.id())
            },
            "description": "Dismiss and ban alice".to_string()
        }))
        .max_gas()
        .deposit(parse_near!("0.01 N"))
        .transact();
    let proposal_id: u32 = res2.await?.json()?;

    let res = setup
        .bob
        .call(setup.tc_contract.id(), "vote")
        .args_json(json!({"id": proposal_id, "vote": Vote::Approve,}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let res = setup
        .john
        .call(setup.tc_contract.id(), "vote")
        .args_json(json!({"id": proposal_id, "vote": Vote::Approve,}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    // after removal less members
    let members = setup
        .alice
        .call(setup.coa_contract.id(), "get_members")
        .view()
        .await?
        .json::<MembersOutput>()?;

    let mut expected = vec![
        to_near_account(setup.bob.id()),
        to_near_account(setup.john.id()),
    ];
    expected.sort();
    assert_eq!(members.members, expected);

    // verify
    // admin flag
    let res = setup
        .alice
        .call(setup.registry_contract.id(), "account_flagged")
        .args_json(json!({"account": to_near_account(setup.alice.id())}))
        .view()
        .await?
        .json::<Option<AccountFlag>>()?;

    assert_eq!(res, Some(AccountFlag::GovBan));

    Ok(())
}

#[tokio::test]
async fn tc_ban_and_dismiss_fail_cases() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let res2 = setup
        .bob
        .call(setup.tc_contract.id(), "create_proposal")
        .args_json(json!({
            "kind": PropKind::DismissAndBan { member: to_near_account(setup.alice.id()), house:  to_near_account(setup.coa_contract.id())
            },
            "description": "Dismiss and ban alice".to_string()
        }))
        .max_gas()
        .deposit(parse_near!("0.01 N"))
        .transact();
    let proposal_id: u32 = res2.await?.json()?;

    // remove tc as flagger
    let res = setup
        .admin
        .call(
            setup.registry_contract.id(),
            "admin_set_authorized_flaggers",
        )
        .args_json(json!({
        "authorized_flaggers": [],
        }))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    vote(
        vec![setup.john.clone(), setup.bob.clone()],
        &setup.tc_contract,
        proposal_id,
    )
    .await?;

    // after removal less members
    let members = setup
        .alice
        .call(setup.coa_contract.id(), "get_members")
        .view()
        .await?
        .json::<MembersOutput>()?;

    let mut expected = vec![
        to_near_account(setup.bob.id()),
        to_near_account(setup.john.id()),
    ];
    expected.sort();
    assert_eq!(members.members, expected);

    // verify
    // admin flag
    let res = setup
        .alice
        .call(setup.registry_contract.id(), "account_flagged")
        .args_json(json!({"account": to_near_account(setup.alice.id())}))
        .view()
        .await?
        .json::<Option<AccountFlag>>()?;

    assert_eq!(res, None);

    let proposal = setup
        .alice
        .call(setup.tc_contract.id(), "get_proposal")
        .args_json(json!({ "id": proposal_id }))
        .view()
        .await?
        .json::<Option<ProposalOutput>>()?;
    assert_eq!(proposal.unwrap().proposal.status, ProposalStatus::Failed);

    // execute after adding flagger again
    // remove tc as flagger
    let res = setup
        .admin
        .call(
            setup.registry_contract.id(),
            "admin_set_authorized_flaggers",
        )
        .args_json(json!({
        "authorized_flaggers": [setup.tc_contract.id()],
        }))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    let res = setup
        .bob
        .call(setup.tc_contract.id(), "execute")
        .args_json(json!({"id": proposal_id,}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    // no dismiss(already succeeded)
    let members = setup
        .alice
        .call(setup.coa_contract.id(), "get_members")
        .view()
        .await?
        .json::<MembersOutput>()?;

    let mut expected = vec![
        to_near_account(setup.bob.id()),
        to_near_account(setup.john.id()),
    ];
    expected.sort();
    assert_eq!(members.members, expected);

    // verify
    // admin flag
    let res = setup
        .alice
        .call(setup.registry_contract.id(), "account_flagged")
        .args_json(json!({"account": to_near_account(setup.alice.id())}))
        .view()
        .await?
        .json::<Option<AccountFlag>>()?;

    assert_eq!(res, Some(AccountFlag::GovBan));

    let proposal = setup
        .alice
        .call(setup.tc_contract.id(), "get_proposal")
        .args_json(json!({ "id": proposal_id }))
        .view()
        .await?
        .json::<Option<ProposalOutput>>()?;
    assert_eq!(proposal.unwrap().proposal.status, ProposalStatus::Executed);

    Ok(())
}

#[ignore]
#[tokio::test]
async fn migration_mainnet() -> anyhow::Result<()> {
    let worker_sandbox = near_workspaces::sandbox().await?;
    let worker_mainnet = near_workspaces::mainnet().await?;
    let congress_hom_id: AccountId = "congress-hom-v1.ndc-gwg.near".parse()?;
    let congress = worker_sandbox
        .import_contract(&congress_hom_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .with_data()
        .transact()
        .await?;

    // query the pre-migrated contract
    let num_of_proposals: u64 = congress
        .call("number_of_proposals")
        .max_gas()
        .transact()
        .await?
        .json()?;

    let members: MembersOutput = congress
        .call("get_members")
        .max_gas()
        .transact()
        .await?
        .json()?;

    // deploy the new contract
    let new_congress = congress
        .as_account()
        .deploy(include_bytes!("../../res/congress.wasm"))
        .await?
        .into_result()?;

    // call the migrate method
    let res = new_congress.call("migrate").max_gas().transact().await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let res: u64 = new_congress
        .call("number_of_proposals")
        .max_gas()
        .transact()
        .await?
        .json()?;
    assert_eq!(res, num_of_proposals);

    let prop: Option<ProposalOutput> = new_congress
        .call("get_proposal")
        .args_json(json!({"id": 1}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    let members_len: u8 = new_congress
        .call("members_len")
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(members.members.len() as u8, members_len);

    print!("{:?}", prop.unwrap().proposal);

    Ok(())
}

fn to_near_account(acc: &AccountId) -> NearAccountId {
    NearAccountId::new_unchecked(acc.to_string())
}

'''
'''--- elections/CHANGELOG.md ---
<!-- markdownlint-disable MD013 -->
<!-- markdownlint-disable MD024 -->

<!--
Changelogs are for humans, not machines.
There should be an entry for every single version.
The same types of changes should be grouped.
The latest version comes first.
The release date of each version is displayed.

Usage:

Change log entries are to be added to the Unreleased section. Example entry:

* [#<PR-number>](https://github.com/umee-network/umee/pull/<PR-number>) <description>

-->

# CHANGELOG

## Unreleased

## v1.1.0 (2023-10-21)

### Features

- New field in the smart contract `class_metadata`.
- New method `admin_set_class_metadata`.
- New view `class_metadata`.
- `admin_mint_sbt` method.

## v1.0.6 (2023-10-16)

- increase gas set to I Voted SBT mint call in the `unbond` method.

## v1.0.5 (2023-10-06)

- `winners_by_proposal`: added optional boolean argument: `ongoing`. When set to true, it will return ongoing results, rather than an empty list.

## v1.0.4 (2023-10-06)

### Breaking changes

- Updated `admin_revoke_vote` to accept list of SBTs rather a single SBT.

## v1.0.3 (2023-10-05)

- Updated `revoke_vote` and `admin_revoke_vote` to not slash bonds.
- Added `disqualify_candidates`.

## v1.0.2 (2023-10-02)

- `winners_by_proposal(prop_id)` should return empty list if the elections didn't finish.

## v1.0.1 (2023-09-28)

- Added `admin_set_finish_time` method.
- Added `finish_time` query.

### Bug Fixes

### Features

New methods:

- `admin_set_finish_time(time)`: allows the contract authority to overwrite the existing finish time (extending the cooldown).
- `finish_time()`: query the finish time (time when the cooldown is over and unbonding is possible).

## v1.0.0 (2023-09-06)

### Features

New methods:

- `bond_by_sbt` query to check if a holder of given SBT bonded.

### Breaking Changes

- `winners_by_house` renamed to ``winners_by_proposal`

### Bug Fixes

- fix the calculated amount of bonded tokens in `bond` method.
- fix the amount of winners returned in the `winners_by_house` method.

## v1.0.0-beta1 (2023-08-29)

### Features

- `I VOTED` sbt will be minted to the user in while unbonding if voted for all the proposals.

#### New call methods

- `bond` - method to allow users to bond and re-bond (increase their bond). Bonding is required to vote. [docs](https://github.com/near-ndc/gov/blob/main/framework-v1/elections-voting.md)
- `unbond` - method to allow users to unbond the previously bonded amount. It is allowed only after the cooldown period. [docs](https://github.com/near-ndc/gov/blob/main/framework-v1/elections-voting.md)
- `accept_fair_voting_policy` - method to allow users to accept the fair voting policy. It is required to vote. [docs](https://github.com/near-ndc/gov/blob/main/framework-v1/elections-voting.md).

##### New query methods

- `proposal_status` - returns weather a proposal is active, at cooldown or finished.
- `accepted_policy` - returns a blake32 policy hash of the most recent accepted policy by the user.
- `user_votes` - returns all the users votes for all the proposals
- `has_voted_on_all_proposals` - returns true if user has voted on all proposals, otherwise false
- `policy` - returns the required policy
- `winners_by_house` - returns a list of winners of the proposal

### Breaking Changes

- The user needs to both accept the voting policy and bond before being allowed to vote.
- User doesn't need to make storage deposit to cover voting. Bond is used to cover that.

### Bug Fixes

'''
'''--- elections/Cargo.toml ---
[package]
name = "elections"
version = "1.1.0"
authors = { workspace = true }
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
# rlib is needed for integration tests
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

common = { path = "../common" }
sbt = { git = "https://github.com/near-ndc/i-am-human.git" }

[dev-dependencies]
anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-primitives.workspace = true
near-units.workspace = true
integrations = { path = "../integrations" }

'''
'''--- elections/README.md ---
# Elections Smart Contract

## Deployments

|   environment   |                           address |
| :-------------: | --------------------------------: |
|  mainnet prod   |          `elections.ndc-gwg.near` |
| mainnet testing | `elections-v1-1.gwg-testing.near` |
|     testnet     |        `elections-v1.gwg.testnet` |

## Requirements

- Only I Am Human verified accounts can vote.
- Each account can vote at most one time. Votes are not revocable, and can't be changed.
- Contract has a fair voting `policy` attribute. Each user, before voting, has to firstly accept the policy by making a transaction matching the contract policy.
- Only the authority (set during contract initialization) can create proposals. Each proposal specifies:

  - `typ`: must be HouseType variant
  - `start`: voting start time as UNIX time (in miliseconds)
  - `end`: voting start time as UNIX time (in miliseconds)
  - `cooldown`: cooldown duration when votes from blacklisted accounts can be revoked by an authority (in miliseconds)
  - `ref_link`: string (can't be empty) - a link to external resource with more details (eg near social post). Max length is 120 characters.
  - `quorum`: minimum amount of legit accounts to vote to legitimize the elections.
  - `seats`: max number of candidates to elect, also max number of credits each user has when casting a vote.
  - `min_candidate_support`: minimum amount of votes a candidate needs to receive to be considered a winner.

## Flow

- GWG deploys the elections smart contract and sets authority for creating new proposals.
- GWG authority creates new proposals before the election starts, with eligible candidates based on the `nominations` result. All proposals are created before the elections start.
  - NOTE: we may consider querying the candidates directly from the nominations contract.
- Once the proposals are created and the elections start (`now >= proposal.start`), all human verified near accounts can vote according to the NDC Elections [v1 Framework](../README.md#elections).
- Anyone can query the proposal and the ongoing result at any time.
- Voting is active until the `proposal.end` time.
- Vote revocation is active until the `proposal.end` + `cooldown` time.

## Bonding

- [SPEC](https://github.com/near-ndc/gov/blob/main/framework-v1/elections-voting.md#bonding)
- Each verified voter must bond 3N to cast their vote. Each Non-verified voter must bond 300N to cast their vote.
- Bond can be deposited using `bond` function that must be used via is_human_call.

  ```rust
  near call REGISTRY is_human_call '{"ctr": "elections.near", "function": "bond", "payload": "{}"}' --accountId YOU.near --deposit 3
  ```

- One bond is enough to cast votes for all proposals.
- `finish_time`: max(`finish_time`, `end` + `cooldown`) of all the proposals.
- User can unbond after the `finish_time`. All tokens minus storage fees will be returned.
- Bonded tokens can be slashed by executing `vote_revoke`. 100% of bonded tokens will be slashed and will be tracked in `total_slashed` variable.
- `unbond`: To unbond deposit, unbond function needs to be called via IAH `registry.is_human_call`.

  ```rust
  near call REGISTRY is_human_call '{"ctr": "elections.near", "function": "unbond", "payload": "{}"}' --accountId YOU.near
  ```

  The `unbond` will also mint I VOTED SBT for [eligible voters](https://github.com/near-ndc/gov/blob/main/framework-v1/elections-voting.md#i-voted-sbt).

## Voting

User who made sufficient bond and accepted Fair Voting Policy can call `vote` function to vote for an active proposal.
User can vote at most once for each proposal, votes can not be updated. [Full specification](https://github.com/near-ndc/gov/blob/main/framework-v1/elections-voting.md)

### Setup Package

Setup Package proposal is a proposal with `seats=1` (at most one option can be selected) and `candidates = ["yes", "no", "abstain"]`.

Voting for setup package uses the same API as voting for candidates. The vote must be list of exactly one element: `["yes"]` or `["no"]` or `["abstain"]`.

## Usage

Below we show few CLI snippets:

```shell
CTR=elections-v1.gwg.testnet
REGISTRY=registry-1.i-am-human.testnet

# create proposal
# note: start time, end time and cooldown must be in milliseconds

near call $CTR create_proposal '{"start": 1686221747000, "end": 1686653747000, "cooldown": 604800000  "ref_link": "example.com", "quorum": 10, "candidates": ["candidate1.testnet", "candidate2.testnet", "candidate3.testnet", "candidate4.testnet"], "typ": "HouseOfMerit", "seats": 3, "min_candidate_support": 5}' --accountId $CTR

# fetch all proposal
near view $CTR proposals ''

# query proposal by ID
near view $CTR proposals '{"prop_id": 2}'

# accept fair voting policy
near call $CTR accept_fair_voting_policy '{"policy": "f1c09f8686fe7d0d798517111a66675da0012d8ad1693a47e0e2a7d3ae1c69d4"}' --deposit 0.001 --accountId me.testnet

# query the accepted policy by user. Returns the latest policy user accepted or `None` if user did not accept any policy
near call $CTR accepted_policy '{"user": "alice.testnet"}' --accountId me.testnet

# bonding - see a section above how to bond and unbond

# query if a IAH holder bonded (by IAH SBT)
near view $CTR has_voted_on_all_proposals '{"sbt": 123}'

# vote
near call $CTR vote '{"prop_id": 1, "vote": ["candidate1.testnet", "candidate3.testnet"]}' --gas 70000000000000 --deposit 0.0005 --accountId me.testnet

# revoke vote (authority only)
near call $CTR admin_revoke_vote '{"prop_id": 1, "token_id": 1}'

# revoke vote (anyone can call this method)
near call $CTR revoke_vote '{"prop_id": 1, "user": "alice.testnet"}'

# check if a user voted for all proposals (note user votes with SBTs, so it may happen that
# we should query by TokenID instead)
near view $CTR has_voted_on_all_proposals '{"user": "alice.testnet"}'

# query winners by a proposal
# NOTE: the function doesn't return "ongoing" winners, it only returns a valid response once
# the proposal finished (voting ended and is past the cooldown).
near view $CTR winners_by_proposal '{"prop_id": 1}'
```

## Deployed Contracts

### Mainnet

Coming Soon

- mainnet testing: `elections-v1.gwg-testing.near` - [deployment tx](https://explorer.mainnet.near.org/transactions/k8CYckfdqrubJovPTX8UreZkdxgwxkxjaFTv955aJbS)
  registry: `registry-v1.gwg-testing.near`

### Testnet

- `elections-v1.gwg.testnet` - [deployment tx](https://explorer.testnet.near.org/transactions/6mQVLLsrEkBithTf1ys36SHCUAhDK9gVDEyCrgV1VWoR).
  registry: `registry-1.i-am-human.testnet`

'''
'''--- elections/helper.sh ---
#!/usr/bin/env sh

CTR=voting-v1.ndc-gwg.testnet
GWG=ndc-gwg.testnet

# create empty proposal
near call $CTR creat_proposal '{"start": '$(($(date +%s) + 40))'}' --accountId $GWG

near view $CTR get_proposal '{"proposal": 1}'

'''
'''--- elections/src/constants.rs ---
use near_sdk::{Balance, Gas, ONE_NEAR};

pub const MILI_NEAR: Balance = ONE_NEAR / 1_000;

// 64bytes(accountID) + 1byte (prefix) + 32bytes (hash bytes) = 97B < 100B=1 miliNEAR
pub const ACCEPT_POLICY_COST: Balance = MILI_NEAR;
pub const ACCEPT_POLICY_GAS: Gas = Gas(70 * Gas::ONE_TERA.0);

pub const BOND_AMOUNT: Balance = 3 * ONE_NEAR;
pub const GRAY_BOND_AMOUNT: Balance = 300 * ONE_NEAR;
pub const MINT_COST: Balance = 10 * MILI_NEAR; // 0.01 NEAR

pub const MINT_GAS: Gas = Gas(15 * Gas::ONE_TERA.0);
pub const VOTE_GAS: Gas = Gas(110 * Gas::ONE_TERA.0);
pub const VOTE_GAS_CALLBACK: Gas = Gas(10 * Gas::ONE_TERA.0);
pub const REVOKE_VOTE_GAS_CALLBACK: Gas = Gas(5 * Gas::ONE_TERA.0);

pub const MIN_REF_LINK_LEN: usize = 6;
pub const MAX_REF_LINK_LEN: usize = 120;

/// Gas reserved for final failure callback which panics if one of the callback fails.
pub const FAILURE_CALLBACK_GAS: Gas = Gas(3 * Gas::ONE_TERA.0);

pub const I_VOTED_SBT_CLASS: u64 = 1;
pub const SBT_HOM: u64 = 2;
pub const SBT_COA: u64 = 3;
pub const SBT_TC: u64 = 4;

'''
'''--- elections/src/errors.rs ---
use near_sdk::env::panic_str;
use near_sdk::FunctionError;

use crate::TokenId;

/// Contract errors
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum VoteError {
    WrongIssuer,
    NoSBTs,
    DuplicateCandidate,
    DoubleVote(TokenId),
    MinBond(u128, u128),
    Blacklisted,
    NoBond,
}

impl FunctionError for VoteError {
    fn panic(&self) -> ! {
        match self {
            VoteError::WrongIssuer => {
                panic_str("expected human SBTs proof from the human issuer only")
            }
            VoteError::NoSBTs => panic_str(
                "voter is not a verified human, expected IAH SBTs proof from the IAH issuer only",
            ),
            VoteError::DuplicateCandidate => panic_str("double vote for the same candidate"),
            VoteError::DoubleVote(sbt) => {
                panic_str(&format!("user already voted with sbt={}", sbt))
            }
            VoteError::MinBond(req, amt) => {
                panic_str(&format!("required bond amount={}, deposited={}", req, amt))
            }
            VoteError::Blacklisted => panic_str("user is blacklisted"),
            VoteError::NoBond => panic_str("Voter didn't bond"),
        }
    }
}

/// Contract errors
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum RevokeVoteError {
    NotActive,
    NotVoted,
    NotBlacklisted,
}

impl FunctionError for RevokeVoteError {
    fn panic(&self) -> ! {
        match self {
            RevokeVoteError::NotActive => {
                panic_str("can only revoke votes between proposal start and (end time + cooldown)")
            }
            RevokeVoteError::NotVoted => panic_str(
                "voter did not vote on this proposal or the vote has been already revoked",
            ),
            RevokeVoteError::NotBlacklisted => panic_str("can not revoke a not blacklisted voter"),
        }
    }
}

'''
'''--- elections/src/events.rs ---
use near_sdk::{serde::Serialize, Balance};
use serde_json::json;

use common::{EventPayload, NearEvent};

fn emit_event<T: Serialize>(event: EventPayload<T>) {
    NearEvent {
        standard: "ndc-elections",
        version: "1.0.0",
        event,
    }
    .emit();
}

pub(crate) fn emit_bond(amount: Balance) {
    emit_event(EventPayload {
        event: "bond",
        data: json!({ "amount": amount.to_string() }),
    });
}

pub(crate) fn emit_vote(prop_id: u32) {
    emit_event(EventPayload {
        event: "vote",
        data: json!({ "prop_id": prop_id }),
    });
}

pub(crate) fn emit_revoke_vote(prop_id: u32) {
    emit_event(EventPayload {
        event: "revoke_vote",
        data: json!({ "prop_id": prop_id }),
    })
}

#[cfg(test)]
mod unit_tests {
    use near_sdk::{test_utils, AccountId};

    use super::*;

    fn _acc(idx: u8) -> AccountId {
        AccountId::new_unchecked(format!("user-{}.near", idx))
    }

    #[test]
    fn log_vote() {
        let expected1 = r#"EVENT_JSON:{"standard":"ndc-elections","version":"1.0.0","event":"vote","data":{"prop_id":21}}"#;
        let expected2 = r#"EVENT_JSON:{"standard":"ndc-elections","version":"1.0.0","event":"revoke_vote","data":{"prop_id":22}}"#;
        emit_vote(21);
        assert_eq!(vec![expected1], test_utils::get_logs());
        emit_revoke_vote(22);
        assert_eq!(vec![expected1, expected2], test_utils::get_logs());
    }
}

'''
'''--- elections/src/ext.rs ---
use near_sdk::serde::Deserialize;
use near_sdk::{ext_contract, AccountId};

// imports needed for conditional derive (required for tests)
#[allow(unused_imports)]
use near_sdk::serde::Serialize;

use crate::storage::AccountFlag;
use crate::{RevokeVoteError, Vote, VoteError};

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_vote_verified(
        &mut self,
        prop_id: u32,
        voter: AccountId,
        vote: Vote,
    ) -> Result<(), VoteError>;
    fn on_revoke_verified(&mut self, prop_id: u32, user: AccountId) -> Result<(), RevokeVoteError>;
}

#[ext_contract(ext_sbtreg)]
pub trait ExtSbtRegistry {
    fn is_human(&self, account: AccountId) -> HumanSBTs;
    fn account_flagged(&self, account: AccountId) -> Option<AccountFlag>;

    fn sbt_mint(&mut self, token_spec: Vec<(AccountId, Vec<TokenMetadata>)>) -> Vec<TokenId>;
}

// TODO: use SBT crate once it is published

pub type TokenId = u64;
pub type HumanSBTs = Vec<(AccountId, Vec<TokenId>)>;

/// token data for sbt_tokens_by_owner response
#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OwnedToken {
    pub token: u64,
    pub metadata: TokenMetadata,
}

/// TokenMetadata defines attributes for each SBT token.

#[derive(Deserialize, Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub class: u64,
    pub issued_at: Option<u64>,
    pub expires_at: Option<u64>,
    pub reference: Option<String>,
    pub reference_hash: Option<String>,
}

'''
'''--- elections/src/lib.rs ---
use std::cmp::max;
use std::collections::HashSet;

use events::{emit_bond, emit_revoke_vote, emit_vote};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{
    env, near_bindgen, require, AccountId, Gas, PanicOnDefault, Promise, PromiseOrValue,
};
use sbt::{ClassId, ClassMetadata};

mod constants;
mod errors;
mod events;
mod ext;
mod migrate;
pub mod proposal;
pub mod storage;
mod view;

pub use crate::constants::*;
pub use crate::errors::*;
pub use crate::ext::*;
pub use crate::proposal::*;
pub use crate::storage::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub pause: bool,
    pub prop_counter: u32,
    pub proposals: LookupMap<u32, Proposal>,

    /// blake2s-256 hash of the Fair Voting Policy text.
    pub policy: [u8; 32],
    pub accepted_policy: LookupMap<AccountId, [u8; 32]>,
    /// we assume that each account has at most one IAH token.
    pub bonded_amounts: LookupMap<TokenId, u128>,
    /// total amount of near slashed due to violating the fair voting policy
    pub total_slashed: u128,
    /// Finish time is end + cooldown. This used in the `unbond` function: user can unbond only after this time.
    /// Unix timestamp (in milliseconds)
    pub finish_time: u64,

    /// address which can pause the contract and make a new proposal. Should be a multisig / DAO;
    pub authority: AccountId,
    pub sbt_registry: AccountId,

    /// list of disqualified candidates
    pub disqualified_candidates: LazyOption<HashSet<AccountId>>,

    /// class metadata for I-Voted SBT
    pub class_metadata: LookupMap<ClassId, ClassMetadata>,
}

#[near_bindgen]
impl Contract {
    #[init]
    /// * `policy` is a blake2s-256 hex-encoded hash of the Fair Voting Policy text.
    pub fn new(
        authority: AccountId,
        sbt_registry: AccountId,
        policy: String,
        finish_time: u64,
    ) -> Self {
        let policy = assert_hash_hex_string(&policy);

        Self {
            pause: false,
            authority,
            sbt_registry,
            proposals: LookupMap::new(StorageKey::Proposals),
            accepted_policy: LookupMap::new(StorageKey::AcceptedPolicy),
            bonded_amounts: LookupMap::new(StorageKey::BondedAmount),
            total_slashed: 0,
            prop_counter: 0,
            policy,
            finish_time,
            disqualified_candidates: LazyOption::new(StorageKey::DisqualifiedCandidates, None),
            class_metadata: LookupMap::new(StorageKey::ClassMetadata),
        }
    }

    /*
     * Queries are in view.rs
     */

    /**********
     * TRANSACTIONS
     **********/

    /// Creates a new empty proposal. `start` and `end`are timestamps in milliseconds.
    /// Returns the new proposal ID.
    /// NOTE: storage is paid from the account state
    pub fn create_proposal(
        &mut self,
        typ: ProposalType,
        start: u64,
        end: u64,
        cooldown: u64,
        ref_link: String,
        quorum: u32,
        seats: u16,
        #[allow(unused_mut)] mut candidates: Vec<AccountId>,
        min_candidate_support: u64,
    ) -> u32 {
        self.assert_admin();
        let candidates_len = candidates.len();
        require!(
            env::block_timestamp_ms() < start,
            "proposal start must be in the future"
        );
        require!(start < end, "proposal start must be before end");
        require!(
            0 < seats && seats <= candidates_len as u16,
            "require 0 < seats <= candidates.length"
        );
        require!(
            MIN_REF_LINK_LEN <= ref_link.len() && ref_link.len() <= MAX_REF_LINK_LEN,
            format!(
                "ref_link length must be between {} and {} bytes",
                MIN_REF_LINK_LEN, MAX_REF_LINK_LEN
            )
        );

        if typ == ProposalType::SetupPackage {
            validate_setup_package(seats, &candidates);
        }

        candidates.sort();
        let mut c1 = &candidates[0];
        for c in candidates.iter().skip(1) {
            require!(c1 != c, "duplicated candidates");
            c1 = c;
        }

        self.prop_counter += 1;
        let p = Proposal {
            typ,
            start,
            end,
            cooldown,
            quorum,
            ref_link,
            seats,
            candidates,
            result: vec![0; candidates_len],
            voters: LookupMap::new(StorageKey::ProposalVoters(self.prop_counter)),
            voters_num: 0,
            min_candidate_support,
            user_sbt: LookupMap::new(StorageKey::UserSBT(self.prop_counter)),
        };

        self.finish_time = max(self.finish_time, end + cooldown);
        self.proposals.insert(&self.prop_counter, &p);
        self.prop_counter
    }

    /// Transaction to record the predecessor account accepting the Fair Voting Policy.
    /// * `policy` is a blake2s-256 hex-encoded hash (must be 64 bytes) of the Fair Voting Policy text.
    #[payable]
    pub fn accept_fair_voting_policy(&mut self, policy: String) {
        require!(
            env::attached_deposit() >= ACCEPT_POLICY_COST,
            format!(
                "requires {} yocto deposit for storage fees",
                ACCEPT_POLICY_COST
            )
        );
        let policy = assert_hash_hex_string(&policy);
        self.accepted_policy
            .insert(&env::predecessor_account_id(), &policy);
    }

    /// Election vote using a seat-selection mechanism.
    /// For the `SetupPackage` proposal, vote must be an empty list.
    // NOTE: we don't need to take storage deposit because user is required to bond at least
    // 3N, that will way more than what's needed to vote for few proposals.
    pub fn vote(&mut self, prop_id: u32, vote: Vote) -> Promise {
        let user = env::predecessor_account_id();
        let p = self._proposal(prop_id);
        p.assert_active();
        require!(
            env::prepaid_gas() >= VOTE_GAS,
            format!("not enough gas, min: {:?}", VOTE_GAS)
        );
        require!(
            self.policy == self.accepted_policy.get(&user).unwrap_or_default(),
            "user didn't accept the voting policy, or the accepted voting policy doesn't match the required one"
        );

        validate_vote(p.typ, &vote, p.seats, &p.candidates);
        // call SBT registry to verify SBT
        let sbt_promise = ext_sbtreg::ext(self.sbt_registry.clone()).is_human(user.clone());
        let acc_flag = ext_sbtreg::ext(self.sbt_registry.clone()).account_flagged(user.clone());

        sbt_promise.and(acc_flag).then(
            ext_self::ext(env::current_account_id())
                .with_static_gas(VOTE_GAS_CALLBACK)
                .on_vote_verified(prop_id, user, vote),
        )
    }

    /// Allows user to bond before voting. The method needs to be called through registry.is_human_call
    /// Panics if the caller is not registry
    /// Emits bond event
    #[payable]
    pub fn bond(
        &mut self,
        caller: AccountId,
        iah_proof: HumanSBTs,
        #[allow(unused_variables)] payload: serde_json::Value, // required by is_human_call
    ) -> PromiseOrValue<U128> {
        let deposit = env::attached_deposit();
        if env::predecessor_account_id() != self.sbt_registry {
            return PromiseOrValue::Promise(
                Promise::new(caller)
                    .transfer(deposit)
                    .then(Self::fail("can only be called by registry")),
            );
        }

        let (ok, token_id) = Self::is_human_issuer(&iah_proof);
        if !ok {
            return PromiseOrValue::Promise(
                Promise::new(caller)
                    .transfer(deposit)
                    .then(Self::fail("not a human")),
            );
        }

        emit_bond(deposit);
        let amount = self.bonded_amounts.get(&token_id).unwrap_or(0);
        self.bonded_amounts.insert(&token_id, &(deposit + amount));
        PromiseOrValue::Value(U128(deposit))
    }

    /// Allows user to unbond after the elections is over.
    /// Can only be called using registry.is_human_call
    /// Panics if the `predecessor_account_id` is not registry
    /// Panics if called before the elections is over
    /// Panics if user didn't bond
    #[payable]
    #[allow(unused_variables)] // `payload` is not used but it needs to be payload so that is_human_call works
    pub fn unbond(
        &mut self,
        caller: AccountId,
        iah_proof: HumanSBTs,
        payload: serde_json::Value,
    ) -> Promise {
        if env::predecessor_account_id() != self.sbt_registry {
            return Self::fail("can only be called by registry");
        }

        let (ok, token_id) = Self::is_human_issuer(&iah_proof);
        if !ok {
            return Self::fail("not a human");
        }
        if env::block_timestamp_ms() <= self.finish_time {
            return Self::fail("cannot unbond: election is still in progress");
        }

        let mut voted_for_all = true;

        // cleanup votes, policy data from caller
        for i in 1..=self.prop_counter {
            let proposal = self.proposals.get(&i);
            if let Some(mut prop) = proposal {
                prop.user_sbt.remove(&caller);
                if prop.voters.remove(&token_id).is_none() {
                    voted_for_all = false;
                }
            }
        }
        self.accepted_policy.remove(&caller);

        let mut unbond_amount = self
            .bonded_amounts
            .remove(&token_id)
            .expect("voter didn't bond");

        // call to registry to mint `I Voted` SBT
        if voted_for_all {
            unbond_amount -= MINT_COST;
            // No need to "chain" NEAR transfer.
            Promise::new(caller.clone()).transfer(unbond_amount);
            ext_sbtreg::ext(self.sbt_registry.clone())
                .with_static_gas(MINT_GAS)
                .with_attached_deposit(MINT_COST)
                .sbt_mint(vec![(
                    caller,
                    vec![TokenMetadata {
                        class: I_VOTED_SBT_CLASS,
                        issued_at: Some(env::block_timestamp_ms()),
                        expires_at: None,
                        reference: None,
                        reference_hash: None,
                    }],
                )])
        } else {
            env::log_str("Didn't vote for all proposals. Skipping I Voted SBT mint.");
            Promise::new(caller.clone()).transfer(unbond_amount)
        }
    }

    /// Method for the authority to revoke any votes
    /// Panics if the proposal doesn't exists or the it's called before the proposal starts or after proposal `end+cooldown`.
    #[handle_result]
    pub fn admin_revoke_vote(
        &mut self,
        prop_id: u32,
        token_ids: Vec<TokenId>,
    ) -> Result<(), RevokeVoteError> {
        // check if the caller is the authority allowed to revoke votes
        self.assert_admin();
        // EIC decided that votes won't be slashed.
        // self.slash_bond(token_id);

        if env::block_timestamp_ms() > self.finish_time {
            return Err(RevokeVoteError::NotActive);
        }

        let mut p = self._proposal(prop_id);
        for t in token_ids {
            p.revoke_votes(t)?;
        }
        self.proposals.insert(&prop_id, &p);
        emit_revoke_vote(prop_id);
        Ok(())
    }

    /// Method to revoke votes from blacklisted accounts.
    /// The method makes a call to the registry to verify the user is blacklisted.
    /// Panics if:
    /// - the proposal doesn't exists
    /// - it's called before the proposal starts or after proposal `end+cooldown`
    /// - the user is not blacklisted
    pub fn revoke_vote(&mut self, prop_id: u32, user: AccountId) -> Promise {
        // call SBT registry to verify user is blacklisted
        ext_sbtreg::ext(self.sbt_registry.clone())
            .account_flagged(user.clone())
            .then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(REVOKE_VOTE_GAS_CALLBACK)
                    .on_revoke_verified(prop_id, user),
            )
    }

    /// Allows admin to overwrite the existing finish time by extending the cooldown.
    /// Must be a Unix Time in miliseconds.
    pub fn admin_set_finish_time(&mut self, finish_time: u64) {
        self.assert_admin();
        require!(
            self.finish_time < finish_time,
            "new finish time must be after the existing one"
        );
        self.finish_time = finish_time;
    }

    /// Allows admin to disqualify candidates.
    pub fn admin_disqualify_candidates(&mut self, candidates: Vec<AccountId>) {
        self.assert_admin();
        let mut to_disqualify: HashSet<AccountId> = HashSet::new();
        for c in candidates.iter() {
            to_disqualify.insert(c.clone());
        }
        self.disqualified_candidates.set(&to_disqualify);
    }

    /// Allows admin to mint SBT to the given list of accounts.
    pub fn admin_mint_sbt(&mut self, recipients: Vec<AccountId>, class: ClassId) {
        self.assert_admin();
        let now = env::block_timestamp_ms();
        let len = recipients.len();
        let token_spec = recipients
            .into_iter()
            .map(|r| {
                (
                    r,
                    vec![TokenMetadata {
                        class,
                        issued_at: Some(now),
                        expires_at: None,
                        reference: None,
                        reference_hash: None,
                    }],
                )
            })
            .collect();

        ext_sbtreg::ext(self.sbt_registry.clone())
            .with_static_gas(Gas(10 * len as u64 * Gas::ONE_TERA.0))
            .with_attached_deposit(9 * len as u128 * MILI_NEAR)
            .sbt_mint(token_spec);
    }

    /// returns true if the class was already set and the metadata was ovewritten.
    pub fn admin_set_class_metadata(&mut self, id: ClassId, class_metadata: ClassMetadata) -> bool {
        self.assert_admin();
        self.class_metadata.insert(&id, &class_metadata).is_some()
    }

    /*****************
     * PRIVATE
     ****************/

    #[private]
    #[handle_result]
    pub fn on_vote_verified(
        &mut self,
        #[callback_unwrap] iah_proof: HumanSBTs,
        #[callback_unwrap] account_flag: Option<AccountFlag>,
        prop_id: u32,
        voter: AccountId,
        vote: Vote,
    ) -> Result<(), VoteError> {
        let (ok, token_id) = Self::is_human_issuer(&iah_proof);
        if !ok {
            return Err(VoteError::NoSBTs);
        }

        let required_bond = match account_flag {
            Some(AccountFlag::Blacklisted) => return Err(VoteError::Blacklisted),
            Some(AccountFlag::Verified) => BOND_AMOUNT,
            None => GRAY_BOND_AMOUNT,
        };

        if let Some(bond) = self.bonded_amounts.get(&token_id) {
            if bond < required_bond {
                return Err(VoteError::MinBond(required_bond, bond));
            }
        } else {
            return Err(VoteError::NoBond);
        }

        let mut p = self._proposal(prop_id);
        p.vote_on_verified(&iah_proof[0].1, voter, vote)?;
        self.proposals.insert(&prop_id, &p);
        emit_vote(prop_id);
        Ok(())
    }

    #[private]
    pub fn on_failure(&mut self, error: String) {
        env::panic_str(&error)
    }

    #[private]
    #[handle_result]
    pub fn on_revoke_verified(
        &mut self,
        #[callback_unwrap] flag: AccountFlag,
        prop_id: u32,
        user: AccountId,
    ) -> Result<(), RevokeVoteError> {
        if flag != AccountFlag::Blacklisted {
            return Err(RevokeVoteError::NotBlacklisted);
        }
        let mut p = self._proposal(prop_id);
        let token_id = p.user_sbt.get(&user).ok_or(RevokeVoteError::NotVoted)?;

        p.revoke_votes(token_id)?;
        self.proposals.insert(&prop_id, &p);
        emit_revoke_vote(prop_id);
        Ok(())
    }

    /*****************
     * INTERNAL
     ****************/

    // fn slash_bond(&mut self, token_id: TokenId) {
    //     let bond_amount = self.bonded_amounts.remove(&token_id);
    //     if let Some(value) = bond_amount {
    //         self.total_slashed += value;
    //     }
    // }

    fn fail(reason: &str) -> Promise {
        Self::ext(env::current_account_id())
            .with_static_gas(FAILURE_CALLBACK_GAS)
            .on_failure(reason.to_string())
    }

    #[inline]
    fn is_human_issuer(iah_proof: &HumanSBTs) -> (bool, TokenId) {
        // in current version we support only one proof of personhood issuer: Fractal, so here
        // we simplify by requiring that the result contains tokens only from one issuer.
        if iah_proof.is_empty() || !(iah_proof.len() == 1 && iah_proof[0].1.len() == 1) {
            (false, 0)
        } else {
            (true, *iah_proof[0].1.first().unwrap())
        }
    }

    #[inline]
    fn assert_admin(&self) {
        require!(
            self.authority == env::predecessor_account_id(),
            "not an admin"
        );
    }
}

fn validate_setup_package(seats: u16, cs: &Vec<AccountId>) {
    // Users can vote to at most one option
    require!(seats == 1, "SetupPackage seats must equal 1");
    require!(
        cs.len() == 3
            && cs[0].as_str() == "yes"
            && cs[1].as_str() == "no"
            && cs[2].as_str() == "abstain",
        "SetupPackage candidates must be ['yes', 'no', 'abstain']"
    );
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod unit_tests {
    use std::ops::Mul;

    use near_sdk::{
        test_utils::{self, VMContextBuilder},
        testing_env, Gas, VMContext,
    };
    use serde_json::Value;

    use crate::*;

    /// 1ms in nano seconds
    const MSECOND: u64 = 1_000_000;
    const START: u64 = 10;

    fn setup_package_candidates() -> Vec<AccountId> {
        vec![
            AccountId::try_from("yes".to_string()).unwrap(),
            AccountId::try_from("no".to_string()).unwrap(),
            AccountId::try_from("abstain".to_string()).unwrap(),
        ]
    }

    const ALICE_SBT: u64 = 1;

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice.near".to_string())
    }

    fn bob() -> AccountId {
        AccountId::new_unchecked("bob.near".to_string())
    }

    fn charlie() -> AccountId {
        AccountId::new_unchecked("elon.near".to_string())
    }

    fn candidate(idx: u32) -> AccountId {
        AccountId::new_unchecked(format!("candidate{}.near", idx))
    }

    fn admin() -> AccountId {
        AccountId::new_unchecked("admin.near".to_string())
    }

    fn sbt_registry() -> AccountId {
        AccountId::new_unchecked("sbt_registry.near".to_string())
    }

    fn human_issuer() -> AccountId {
        AccountId::new_unchecked("h_isser.near".to_string())
    }

    fn policy1() -> String {
        "f1c09f8686fe7d0d798517111a66675da0012d8ad1693a47e0e2a7d3ae1c69d4".to_owned()
    }

    fn policy2() -> String {
        "21c09f8686fe7d0d798517111a66675da0012d8ad1693a47e0e2a7d3ae1c69d4".to_owned()
    }

    fn bond_amount_call(ctx: &mut VMContext, ctr: &mut Contract, user: AccountId, token_id: u64) {
        let temp_attached = ctx.attached_deposit;
        let temp_caller = ctx.predecessor_account_id.clone();
        ctx.attached_deposit = BOND_AMOUNT;
        ctx.predecessor_account_id = sbt_registry();
        testing_env!(ctx.clone());

        ctr.bond(user, mk_human_sbt(token_id), Value::String("".to_string()));

        ctx.predecessor_account_id = temp_caller;
        ctx.attached_deposit = temp_attached;
        testing_env!(ctx.clone());
    }

    // candiate    | votes
    // -------------------
    // candiate(1) | 5
    // candiate(2) | 10
    // candiate(3) | 15
    // candiate(4) | 10
    // candiate(5) | 5
    // candiate(6) | 11
    fn mock_proposal_and_votes(
        ctx: &mut VMContext,
        ctr: &mut Contract,
        seats: u16,
        min_candidate_support: u64,
    ) -> u32 {
        let mut candidates = Vec::new();
        for idx in 0..100 {
            candidates.push(candidate(idx));
        }

        ctx.block_timestamp = (START) * MSECOND;
        testing_env!(ctx.clone());

        let prop_id = ctr.create_proposal(
            crate::ProposalType::HouseOfMerit,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            10,
            seats,
            candidates,
            min_candidate_support,
        );
        ctx.block_timestamp = (START + 2) * MSECOND;
        testing_env!(ctx.clone());

        let vote1 = vec![candidate(6), candidate(1), candidate(2), candidate(3)];
        let vote2 = vec![candidate(6), candidate(2), candidate(3), candidate(4)];
        let vote3 = vec![candidate(6), candidate(3), candidate(4), candidate(5)];
        let vote4 = vec![candidate(3), candidate(4), candidate(5)];

        for i in 1..=15u32 {
            let current_vote = if i < 6 {
                &vote1
            } else if i < 11 {
                &vote2
            } else if i == 11 {
                &vote3
            } else {
                &vote4
            };

            bond_amount_call(ctx, ctr, candidate(i), i as u64);

            let res = ctr.on_vote_verified(
                mk_human_sbt(i as u64),
                Some(AccountFlag::Verified),
                prop_id,
                candidate(i),
                current_vote.to_vec(),
            );
            assert!(res.is_ok(), "expected OK, got: {:?}", res);
        }
        prop_id
    }

    fn mk_proposal(ctr: &mut Contract) -> u32 {
        ctr.create_proposal(
            crate::ProposalType::HouseOfMerit,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            2,
            2,
            vec![candidate(1), candidate(2), candidate(3)],
            2,
        )
    }

    fn mk_proposal_setup_package(ctr: &mut Contract) -> u32 {
        ctr.create_proposal(
            crate::ProposalType::SetupPackage,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            2,
            1,
            setup_package_candidates(),
            2,
        )
    }

    fn mk_human_sbt(sbt: TokenId) -> HumanSBTs {
        vec![(human_issuer(), vec![sbt])]
    }

    fn mk_human_sbts(sbt: Vec<TokenId>) -> HumanSBTs {
        vec![(human_issuer(), sbt)]
    }

    fn mk_nohuman_sbt(sbt: TokenId) -> HumanSBTs {
        vec![(human_issuer(), vec![sbt]), (admin(), vec![sbt])]
    }

    fn class_metadata(name: String) -> ClassMetadata {
        ClassMetadata {
            name,
            symbol: None,
            icon: None,
            reference: None,
            reference_hash: None,
        }
    }

    fn alice_voting_context(ctx: &mut VMContext, ctr: &mut Contract) {
        ctx.predecessor_account_id = alice();
        ctx.attached_deposit = ACCEPT_POLICY_COST;
        testing_env!(ctx.clone());
        ctr.accept_fair_voting_policy(policy1());

        bond_amount_call(ctx, ctr, alice(), ALICE_SBT);

        ctx.attached_deposit = 0;
        ctx.block_timestamp = (START + 2) * MSECOND;
        ctx.prepaid_gas = VOTE_GAS;
        testing_env!(ctx.clone());
    }

    fn setup(predecessor: &AccountId) -> (VMContext, Contract) {
        let mut ctx = VMContextBuilder::new()
            .predecessor_account_id(admin())
            .block_timestamp(START * MSECOND)
            .is_view(false)
            .build();
        testing_env!(ctx.clone());
        let ctr = Contract::new(admin(), sbt_registry(), policy1(), START + 100);
        ctx.predecessor_account_id = predecessor.clone();
        testing_env!(ctx.clone());
        (ctx, ctr)
    }

    #[test]
    fn assert_admin() {
        let (_, ctr) = setup(&admin());
        ctr.assert_admin();
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn assert_admin_fail() {
        let (_, ctr) = setup(&alice());
        ctr.assert_admin();
    }

    #[test]
    #[should_panic(expected = "proposal start must be in the future")]
    fn create_proposal_wrong_start_time() {
        let (_, mut ctr) = setup(&admin());
        ctr.create_proposal(
            crate::ProposalType::HouseOfMerit,
            START - 1,
            START + 100,
            100,
            String::from("ref_link.io"),
            2,
            2,
            vec![candidate(1)],
            2,
        );
    }

    #[test]
    #[should_panic(expected = "proposal start must be before end")]
    fn create_proposal_end_before_start() {
        let (_, mut ctr) = setup(&admin());

        ctr.create_proposal(
            crate::ProposalType::HouseOfMerit,
            START + 10,
            START,
            100,
            String::from("ref_link.io"),
            2,
            2,
            vec![candidate(1)],
            2,
        );
    }

    #[test]
    #[should_panic(expected = "ref_link length must be between 6 and 120 bytes")]
    fn create_proposal_wrong_ref_link_length() {
        let (_, mut ctr) = setup(&admin());

        ctr.create_proposal(
            crate::ProposalType::HouseOfMerit,
            START + 1,
            START + 10,
            100,
            String::from("short"),
            2,
            1,
            vec![candidate(1)],
            2,
        );
    }

    #[test]
    #[should_panic(expected = "duplicated candidates")]
    fn create_proposal_duplicated_candidates() {
        let (_, mut ctr) = setup(&admin());

        ctr.create_proposal(
            crate::ProposalType::HouseOfMerit,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            2,
            2,
            vec![candidate(1), candidate(1)],
            2,
        );
    }

    #[test]
    #[should_panic(expected = "require 0 < seats <= candidates.length")]
    fn create_proposal_zero_seats() {
        let (_, mut ctr) = setup(&admin());
        ctr.create_proposal(
            crate::ProposalType::HouseOfMerit,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            2,
            0,
            vec![candidate(1), candidate(1)],
            1,
        );
    }

    #[test]
    #[should_panic(expected = "require 0 < seats <= candidates.length")]
    fn create_proposal_not_enough_candidates() {
        let (_, mut ctr) = setup(&admin());
        ctr.create_proposal(
            crate::ProposalType::HouseOfMerit,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            2,
            3,
            vec![candidate(1), candidate(1)],
            1,
        );
    }

    #[test]
    #[should_panic(expected = "SetupPackage seats must equal 1")]
    fn create_proposal_setup_package_wrong_seats() {
        let (_, mut ctr) = setup(&admin());
        ctr.create_proposal(
            crate::ProposalType::SetupPackage,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            2,
            2,
            setup_package_candidates(),
            2,
        );
    }

    #[test]
    #[should_panic(expected = "SetupPackage candidates must be ['yes', 'no', 'abstain']")]
    fn create_proposal_setup_package_wrong_candidates() {
        let (_, mut ctr) = setup(&admin());
        ctr.create_proposal(
            crate::ProposalType::SetupPackage,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            2,
            1,
            setup_package_candidates()[..=1].to_vec(),
            2,
        );
    }

    #[test]
    #[should_panic(expected = "SetupPackage candidates must be ['yes', 'no', 'abstain']")]
    fn create_proposal_setup_package_wrong_candidates2() {
        let (_, mut ctr) = setup(&admin());
        ctr.create_proposal(
            crate::ProposalType::SetupPackage,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            2,
            1,
            vec![candidate(1), candidate(2), candidate(3)],
            2,
        );
    }

    #[test]
    #[should_panic(expected = "SetupPackage candidates must be ['yes', 'no', 'abstain']")]
    fn create_proposal_setup_package_wrong_candidates3() {
        let (_, mut ctr) = setup(&admin());
        let mut cs = setup_package_candidates();
        cs.push("no2".to_string().try_into().unwrap());
        ctr.create_proposal(
            crate::ProposalType::SetupPackage,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            2,
            1,
            cs,
            2,
        );
    }

    #[test]
    #[should_panic(expected = "SetupPackage candidates must be ['yes', 'no', 'abstain']")]
    fn create_proposal_setup_package_wrong_candidates_order() {
        let (_, mut ctr) = setup(&admin());
        let mut cs = setup_package_candidates();
        let c = cs[0].clone();
        cs[0] = cs[1].clone();
        cs[1] = c;
        ctr.create_proposal(
            crate::ProposalType::SetupPackage,
            START + 1,
            START + 10,
            100,
            String::from("ref_link.io"),
            2,
            1,
            cs,
            2,
        );
    }

    #[test]
    fn create_proposal() {
        let (_, mut ctr) = setup(&admin());

        assert_eq!(ctr.prop_counter, 0);
        let prop_id = mk_proposal(&mut ctr);
        assert_eq!(ctr.prop_counter, 1);
        assert!(ctr.proposals.contains_key(&prop_id));

        let prop_id = mk_proposal(&mut ctr);
        assert_eq!(prop_id, 2);
        assert_eq!(ctr.prop_counter, 2);
        assert!(ctr.proposals.contains_key(&prop_id));

        let prop_id = mk_proposal_setup_package(&mut ctr);
        assert_eq!(prop_id, 3);
        assert_eq!(ctr.prop_counter, 3);
        assert!(ctr.proposals.contains_key(&prop_id));

        let proposals = ctr.proposals();
        assert_eq!(proposals.len(), 3);
        assert_eq!(proposals[0].id, 1);
        assert_eq!(proposals[1].id, 2);
        assert_eq!(proposals[2].id, 3);
    }

    #[test]
    fn vote_on_verified() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        let prop_sp = mk_proposal_setup_package(&mut ctr);
        let vote = vec![candidate(1)];
        ctx.block_timestamp = (START + 2) * MSECOND;
        ctx.attached_deposit = BOND_AMOUNT;
        ctx.predecessor_account_id = sbt_registry();
        testing_env!(ctx.clone());
        ctr.bond(alice(), mk_human_sbt(1), Value::String("".to_string()));
        assert_eq!(
            test_utils::get_logs(),
            vec![
                r#"EVENT_JSON:{"standard":"ndc-elections","version":"1.0.0","event":"bond","data":{"amount":"3000000000000000000000000"}}"#
            ]
        );

        // check initial state
        let p = ctr._proposal(prop_id);
        assert_eq!(p.voters_num, 0, "voters num should be zero");
        assert_eq!(p.result, vec![0, 0, 0],);

        // successful vote
        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vote.clone(),
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        let p = ctr._proposal(prop_id);
        assert!(p.voters.contains_key(&1));
        assert_eq!(p.voters_num, 1, "voters num should increment");
        assert_eq!(p.result, vec![1, 0, 0], "vote should be counted");
        assert!(p.user_sbt.contains_key(&alice()));

        // attempt double vote
        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vote.clone(),
        ) {
            Err(VoteError::DoubleVote(1)) => (),
            x => panic!("expected DoubleVote(1), got: {:?}", x),
        };
        assert_eq!(p.voters_num, 1, "voters num should not increment");
        assert_eq!(p.result, vec![1, 0, 0], "vote result should not change");

        //set sbt=4 and attempt double vote
        ctr._proposal(prop_id).voters.insert(&4, &vec![1]);
        ctr.bond(alice(), mk_human_sbt(4), Value::String("".to_string()));
        match ctr.on_vote_verified(
            mk_human_sbt(4),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vote.clone(),
        ) {
            Err(VoteError::DoubleVote(4)) => (),
            x => panic!("expected DoubleVote(4), got: {:?}", x),
        };
        assert_eq!(p.result, vec![1, 0, 0], "vote result should not change");

        // attempt to double vote with few tokens
        match ctr.on_vote_verified(
            mk_human_sbts(vec![4]),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vote.clone(),
        ) {
            Err(VoteError::DoubleVote(4)) => (),
            x => panic!("expected DoubleVote(4), got: {:?}", x),
        };
        assert_eq!(p.result, vec![1, 0, 0], "vote result should not change");

        // not a human
        match ctr.on_vote_verified(
            mk_nohuman_sbt(3),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vote.clone(),
        ) {
            Err(VoteError::NoSBTs) => (),
            x => panic!("expected WrongIssuer, got: {:?}", x),
        };
        match ctr.on_vote_verified(
            vec![],
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vote.clone(),
        ) {
            Err(VoteError::NoSBTs) => (),
            x => panic!("expected WrongIssuer, got: {:?}", x),
        };
        match ctr.on_vote_verified(
            vec![(human_issuer(), vec![])],
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vote,
        ) {
            Err(VoteError::NoSBTs) => (),
            x => panic!("expected NoSBTs, got: {:?}", x),
        };
        assert_eq!(p.voters_num, 1, "voters num should not increment");
        assert_eq!(p.result, vec![1, 0, 0], "vote result should not change");

        //
        // Create more successful votes

        // bob, tokenID=20: successful vote with single selection
        ctr.bond(bob(), mk_human_sbt(20), Value::String("".to_string()));
        ctr.bond(charlie(), mk_human_sbt(22), Value::String("".to_string()));
        ctx.predecessor_account_id = alice();
        testing_env!(ctx.clone());

        match ctr.on_vote_verified(
            mk_human_sbt(20),
            Some(AccountFlag::Verified),
            prop_id,
            bob(),
            vec![candidate(3)],
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        let p = ctr._proposal(prop_id);
        assert!(p.voters.contains_key(&20), "token id should be recorded");
        assert_eq!(p.voters_num, 2, "voters num should  increment");
        assert_eq!(p.result, vec![1, 0, 1], "vote should be counted");
        assert!(
            p.user_sbt.contains_key(&bob()),
            "user and its sbt should be recorded"
        );

        // charlie, tokenID=22: vote with 2 selections
        ctx.predecessor_account_id = bob();
        testing_env!(ctx);

        // candidates are put in non alphabetical order.
        match ctr.on_vote_verified(
            mk_human_sbt(22),
            Some(AccountFlag::Verified),
            prop_id,
            charlie(),
            vec![candidate(3), candidate(2)],
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        let p = ctr._proposal(prop_id);
        assert!(p.voters.contains_key(&22), "token id should be recorded");
        assert_eq!(p.voters_num, 3, "voters num should  increment");
        assert_eq!(p.result, vec![1, 1, 2], "vote should be counted");
        assert!(
            p.user_sbt.contains_key(&charlie()),
            "user and its sbt should be recorded"
        );

        // SetupPackage vote, again with charlie
        match ctr.on_vote_verified(
            mk_human_sbt(22),
            Some(AccountFlag::Verified),
            prop_sp,
            charlie(),
            setup_package_candidates()[1..=1].to_vec(),
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        let p = ctr._proposal(prop_sp);
        assert!(p.voters.contains_key(&22), "token id should be recorded");
        assert_eq!(p.voters_num, 1, "voters num should  increment");
        assert_eq!(p.result, vec![0, 1, 0], "vote should be counted");
    }

    #[test]
    #[should_panic(expected = "requires 1000000000000000000000 yocto deposit for storage fees")]
    fn accepted_policy_deposit() {
        let (mut ctx, mut ctr) = setup(&admin());

        ctx.attached_deposit = ACCEPT_POLICY_COST / 2;
        testing_env!(ctx);

        ctr.accept_fair_voting_policy(policy1());
    }

    #[test]
    fn accepted_policy_deposit_ok() {
        let (mut ctx, mut ctr) = setup(&admin());

        let mut res = ctr.accepted_policy(admin());
        assert!(res.is_none());

        ctx.attached_deposit = ACCEPT_POLICY_COST;
        testing_env!(ctx);
        ctr.accept_fair_voting_policy(policy1());
        // should be able to accept more then once
        ctr.accept_fair_voting_policy(policy1());

        res = ctr.accepted_policy(admin());
        assert!(res.is_some());
        assert_eq!(res.unwrap(), policy1());
    }

    #[test]
    #[should_panic(expected = "can only vote between proposal start and end time")]
    fn vote_wrong_time() {
        let (_, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        let vote: Vote = vec![candidate(1)];
        ctr.vote(prop_id, vote);
    }

    #[test]
    #[should_panic(expected = "not enough gas, min: Gas(110000000000000)")]
    fn vote_wrong_gas() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        ctx.block_timestamp = (START + 2) * MSECOND;
        ctx.prepaid_gas = Gas(10 * Gas::ONE_TERA.0);
        testing_env!(ctx);

        ctr.vote(prop_id, vec![candidate(1)]);
    }

    #[test]
    #[should_panic(
        expected = "user didn't accept the voting policy, or the accepted voting policy doesn't match the required one"
    )]
    fn vote_not_accepted_policy() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        ctx.block_timestamp = (START + 2) * MSECOND;
        ctx.prepaid_gas = VOTE_GAS;
        testing_env!(ctx);

        ctr.vote(prop_id, vec![candidate(1)]);
    }

    #[test]
    #[should_panic(
        expected = "user didn't accept the voting policy, or the accepted voting policy doesn't match the required one"
    )]
    fn vote_wrong_accepted_policy() {
        let (mut ctx, mut ctr) = setup(&admin());

        ctx.attached_deposit = ACCEPT_POLICY_COST;
        testing_env!(ctx.clone());
        ctr.accept_fair_voting_policy(policy2());

        let prop_id = mk_proposal(&mut ctr);
        ctx.attached_deposit = 0;
        ctx.block_timestamp = (START + 2) * MSECOND;
        ctx.prepaid_gas = VOTE_GAS;
        testing_env!(ctx);

        ctr.vote(prop_id, vec![candidate(1)]);
    }

    #[test]
    fn proposal_status_query() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        let mut res = ctr.proposal_status(prop_id);
        assert_eq!(res, Some(ProposalStatus::NOT_STARTED));

        ctx.block_timestamp = (START + 2) * MSECOND;
        testing_env!(ctx.clone());

        res = ctr.proposal_status(prop_id);
        assert_eq!(res, Some(ProposalStatus::ONGOING));

        ctx.block_timestamp = (START + 11) * MSECOND;
        testing_env!(ctx.clone());

        res = ctr.proposal_status(prop_id);
        assert_eq!(res, Some(ProposalStatus::COOLDOWN));

        ctx.block_timestamp = (START + 111) * MSECOND;
        testing_env!(ctx.clone());

        res = ctr.proposal_status(prop_id);
        assert_eq!(res, Some(ProposalStatus::ENDED));

        // change the finish time
        ctr.admin_set_finish_time(START + 200);
        res = ctr.proposal_status(prop_id);
        assert_eq!(res, Some(ProposalStatus::COOLDOWN));

        ctx.block_timestamp = (START + 201) * MSECOND;
        testing_env!(ctx);

        res = ctr.proposal_status(prop_id);
        assert_eq!(res, Some(ProposalStatus::ENDED));
    }

    #[test]
    #[should_panic(expected = "double vote for the same option")]
    fn vote_double_vote_same_candidate() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        alice_voting_context(&mut ctx, &mut ctr);
        ctr.vote(prop_id, vec![candidate(1), candidate(1)]);
    }

    #[test]
    #[should_panic(expected = "vote for unknown option")]
    fn vote_unknown_candidate() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        alice_voting_context(&mut ctx, &mut ctr);
        ctr.vote(prop_id, vec![bob()]);
    }

    #[test]
    #[should_panic(expected = "max vote is 2 seats")]
    fn vote_too_many_selections() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        alice_voting_context(&mut ctx, &mut ctr);
        ctr.vote(prop_id, vec![candidate(1), candidate(2), candidate(3)]);
    }

    #[test]
    fn vote_empty_vote() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        alice_voting_context(&mut ctx, &mut ctr);
        // should not panic
        ctr.vote(prop_id, vec![]);
        // note: we can only check vote result and state change through an integration test.
    }

    #[test]
    #[should_panic(expected = "setup package vote must be non empty")]
    fn vote_empty_vote_setup_package() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal_setup_package(&mut ctr);
        alice_voting_context(&mut ctx, &mut ctr);
        ctr.vote(prop_id, vec![]);
    }

    #[test]
    #[should_panic(expected = "vote for unknown option")]
    fn vote_wrong_setup_package_vote() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal_setup_package(&mut ctr);
        alice_voting_context(&mut ctx, &mut ctr);
        ctr.vote(prop_id, vec![candidate(1)]);
    }

    #[test]
    fn vote_valid() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_sp = mk_proposal_setup_package(&mut ctr);
        let prop_hom1 = mk_proposal(&mut ctr);
        let prop_hom2 = mk_proposal(&mut ctr);
        alice_voting_context(&mut ctx, &mut ctr);

        ctr.vote(prop_sp, setup_package_candidates()[0..=0].to_vec());
        ctr.vote(prop_hom1, vec![]);
        // need to setup new context, otherwise we have a gas error
        alice_voting_context(&mut ctx, &mut ctr);
        ctr.vote(prop_hom2, vec![candidate(2), candidate(1)]);
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn admin_revoke_vote_not_admin() {
        let (_, mut ctr) = setup(&alice());
        let prop_id = mk_proposal(&mut ctr);
        let res = ctr.admin_revoke_vote(prop_id, vec![1]);
        // this will never be checked since the method is panicing not returning an error
        assert!(res.is_err());
    }

    #[test]
    fn admin_revoke_vote_no_votes() {
        let (mut ctx, mut ctr) = setup(&admin());
        let prop_id = mk_proposal(&mut ctr);
        ctx.block_timestamp = (START + 100) * MSECOND;
        testing_env!(ctx);
        match ctr.admin_revoke_vote(prop_id, vec![1]) {
            Err(RevokeVoteError::NotVoted) => (),
            x => panic!("expected NotVoted, got: {:?}", x),
        }
        assert!(test_utils::get_logs().is_empty());
    }

    #[test]
    #[should_panic(expected = "proposal not found")]
    fn admin_revoke_vote_no_proposal() {
        let (_, mut ctr) = setup(&admin());
        let prop_id = 2;
        match ctr.admin_revoke_vote(prop_id, vec![1]) {
            x => panic!("{:?}", x),
        }
    }

    #[test]
    fn user_votes() {
        let (mut ctx, mut ctr) = setup(&admin());
        let prop_id_1 = mk_proposal(&mut ctr);
        mk_proposal(&mut ctr);
        let prop_id_3 = mk_proposal(&mut ctr);
        ctx.block_timestamp = (START + 2) * MSECOND;
        ctx.attached_deposit = BOND_AMOUNT;
        ctx.predecessor_account_id = sbt_registry();
        testing_env!(ctx);
        ctr.bond(admin(), mk_human_sbt(1), Value::String("".to_string()));

        // vote on proposal 1
        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id_1,
            alice(),
            vec![candidate(3), candidate(2)],
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        let res = ctr.user_votes(alice());
        assert_eq!(res, vec![Some(vec![2, 1]), None, None]);

        // vote on proposal 3
        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id_3,
            alice(),
            vec![candidate(2)],
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        let res = ctr.user_votes(alice());
        assert_eq!(res, vec![Some(vec![2, 1]), None, Some(vec![1])]);

        assert_eq!(ctr.user_votes(bob()), vec![None, None, None]); // bob did not vote yet
    }

    #[test]
    fn user_sbt_map_prefix() {
        let (mut ctx, mut ctr) = setup(&admin());
        let prop_id_1 = mk_proposal(&mut ctr);
        let prop_id_2 = mk_proposal(&mut ctr);

        ctx.block_timestamp = (START + 2) * MSECOND;
        ctx.attached_deposit = BOND_AMOUNT;
        ctx.predecessor_account_id = sbt_registry();
        testing_env!(ctx);
        ctr.bond(alice(), mk_human_sbt(1), Value::String("".to_string()));

        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id_1,
            alice(),
            vec![candidate(3), candidate(2)],
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        let p1 = ctr._proposal(prop_id_1);
        assert!(p1.user_sbt.get(&alice()).is_some());

        let p2 = ctr._proposal(prop_id_2);
        assert!(p2.user_sbt.get(&alice()).is_none());
    }

    #[test]
    fn admin_revoke_vote() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        let vote = vec![candidate(1)];
        ctx.block_timestamp = (START + 2) * MSECOND;
        bond_amount_call(&mut ctx, &mut ctr, alice(), 1);

        // successful vote
        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vote,
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        let p = ctr._proposal(1);
        assert_eq!(p.voters_num, 1);
        assert_eq!(p.result, vec![1, 0, 0]);

        // Before revoke bond should be present
        assert_eq!(ctr.bonded_amounts.get(&1), Some(BOND_AMOUNT));

        // revoke vote
        match ctr.admin_revoke_vote(prop_id, vec![1]) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        }

        // Bond amount should not be slashed
        assert_eq!(ctr.bonded_amounts.get(&1), Some(BOND_AMOUNT));
        assert_eq!(ctr.total_slashed, 0);

        let p = ctr._proposal(1);
        assert_eq!(p.voters_num, 0, "vote should be revoked");
        assert_eq!(p.result, vec![0, 0, 0], "vote should be revoked");

        let expected_event = r#"EVENT_JSON:{"standard":"ndc-elections","version":"1.0.0","event":"revoke_vote","data":{"prop_id":1}}"#;
        assert!(test_utils::get_logs().len() == 2);
        assert_eq!(test_utils::get_logs()[1], expected_event);
    }

    #[test]
    fn has_voted_on_all_proposals() {
        let (mut ctx, mut ctr) = setup(&admin());
        let prop1 = mk_proposal(&mut ctr);
        let prop2 = mk_proposal(&mut ctr);
        let prop3 = mk_proposal(&mut ctr);
        let prop4 = mk_proposal(&mut ctr);
        ctx.block_timestamp = (START + 2) * MSECOND;
        ctx.attached_deposit = BOND_AMOUNT;
        ctx.predecessor_account_id = sbt_registry();
        testing_env!(ctx);
        ctr.bond(admin(), mk_human_sbt(1), Value::String("".to_string()));

        // first vote (voting not yet completed)
        let mut prop_id = prop1;
        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vec![candidate(3), candidate(2)],
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        assert!(!ctr.has_voted_on_all_proposals(alice()));

        // second vote (voting not yet completed)
        prop_id = prop2;
        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vec![candidate(3), candidate(2)],
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        assert!(!ctr.has_voted_on_all_proposals(alice()));

        // third vote (voting not yet completed)
        prop_id = prop3;
        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vec![candidate(3), candidate(2)],
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        assert!(!ctr.has_voted_on_all_proposals(alice()));

        // fourth vote (voting completed)
        prop_id = prop4;
        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vec![candidate(3), candidate(2)],
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        assert!(ctr.has_voted_on_all_proposals(alice()));
    }

    #[test]
    fn bond_amount() {
        let (mut ctx, mut ctr) = setup(&alice());

        ctx.predecessor_account_id = sbt_registry();
        ctx.attached_deposit = BOND_AMOUNT;
        testing_env!(ctx);

        ctr.bond(alice(), mk_human_sbt(2), Value::String("".to_string()));
        assert_eq!(ctr.bonded_amounts.get(&2), Some(BOND_AMOUNT));
    }

    #[test]
    #[should_panic(expected = "Err(NoBond)")]
    fn vote_without_bond_amount() {
        let (mut ctx, mut ctr) = setup(&admin());
        let prop_id_1 = mk_proposal(&mut ctr);
        ctx.block_timestamp = (START + 2) * MSECOND;
        testing_env!(ctx);

        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id_1,
            alice(),
            vec![candidate(3), candidate(2)],
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
    }

    #[test]
    fn vote_unbond_full_flow() -> Result<(), VoteError> {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop1 = mk_proposal(&mut ctr);
        let prop_sp = mk_proposal_setup_package(&mut ctr);
        let vote_sp = setup_package_candidates()[0..=0].to_vec(); // abstain
        let vote1 = vec![candidate(3), candidate(1)];

        alice_voting_context(&mut ctx, &mut ctr);
        assert_eq!(ctr.bonded_amounts.get(&1), Some(BOND_AMOUNT));

        // cast a vote and call on_vote_verified callbacks.
        ctr.vote(prop_sp, vote_sp.clone());
        ctr.vote(prop1, vote1.clone());
        let iah_proof = vec![(alice(), vec![ALICE_SBT])];
        let flag = Some(AccountFlag::Verified);
        ctr.on_vote_verified(iah_proof.clone(), flag.clone(), prop1, alice(), vote1)?;
        ctr.on_vote_verified(iah_proof, flag, prop_sp, alice(), vote_sp)?;

        ctx.block_timestamp = ctr.finish_time * 1000000000; // in nano
        ctx.predecessor_account_id = sbt_registry();
        testing_env!(ctx.clone());

        assert_eq!(
            ctr.user_votes(alice()),
            vec![Some(vec![2, 0]), Some(vec![2])] // votes are alphabetically, yes==2
        );

        ctr.unbond(alice(), mk_human_sbt(1), Value::String("".to_string()));
        // Verify cleanup
        assert_eq!(ctr.bonded_amounts.get(&1), None);
        assert_eq!(ctr.user_votes(alice()), vec![None, None]);

        Ok(())
    }

    #[test]
    fn revoke_vote() {
        let (mut ctx, mut ctr) = setup(&admin());

        let prop_id = mk_proposal(&mut ctr);
        let vote = vec![candidate(1)];
        ctx.block_timestamp = (START + 2) * MSECOND;
        testing_env!(ctx.clone());

        bond_amount_call(&mut ctx, &mut ctr, admin(), 1);

        // successful vote
        match ctr.on_vote_verified(
            mk_human_sbt(1),
            Some(AccountFlag::Verified),
            prop_id,
            alice(),
            vote,
        ) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        };
        let p = ctr._proposal(1);
        assert_eq!(p.voters_num, 1);
        assert_eq!(p.result, vec![1, 0, 0]);

        // change predecessor non-admin account
        ctx.predecessor_account_id = bob();
        testing_env!(ctx.clone());

        // revoke vote (not blacklisted)
        match ctr.on_revoke_verified(AccountFlag::Verified, prop_id, alice()) {
            Err(RevokeVoteError::NotBlacklisted) => (),
            x => panic!("expected NotBlacklisted, got: {:?}", x),
        }

        // revoke vote
        match ctr.on_revoke_verified(AccountFlag::Blacklisted, prop_id, alice()) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        }
        let p = ctr._proposal(1);
        assert_eq!(p.voters_num, 0, "vote should be revoked");
        assert_eq!(p.result, vec![0, 0, 0], "vote should be revoked");

        let expected_event = r#"EVENT_JSON:{"standard":"ndc-elections","version":"1.0.0","event":"revoke_vote","data":{"prop_id":1}}"#;
        assert!(test_utils::get_logs().len() == 1);
        assert_eq!(test_utils::get_logs()[0], expected_event);
    }

    #[test]
    fn revoke_vote_no_votes() {
        let (mut ctx, mut ctr) = setup(&admin());
        let prop_id = mk_proposal(&mut ctr);
        ctx.block_timestamp = (START + 100) * MSECOND;
        ctx.predecessor_account_id = bob();
        testing_env!(ctx);
        match ctr.on_revoke_verified(AccountFlag::Blacklisted, prop_id, alice()) {
            Err(RevokeVoteError::NotVoted) => (),
            x => panic!("expected NotVoted, got: {:?}", x),
        }
        assert!(test_utils::get_logs().is_empty());
    }

    #[test]
    #[should_panic(expected = "proposal not found")]
    fn revoke_vote_no_proposal() {
        let (_, mut ctr) = setup(&bob());
        let prop_id = 2;
        match ctr.on_revoke_verified(AccountFlag::Blacklisted, prop_id, alice()) {
            x => panic!("{:?}", x),
        }
    }

    #[test]
    fn winners_by_proposal() {
        let (mut ctx, mut ctr) = setup(&admin());

        // more seats than candidates
        let prop_id = mock_proposal_and_votes(&mut ctx, &mut ctr, 8, 6);

        // elections not over yet
        assert_eq!(ctr.winners_by_proposal(prop_id, None), vec![]);

        // voting over but cooldown not yet
        ctx.block_timestamp = (START + 11) * MSECOND;
        testing_env!(ctx.clone());
        assert_eq!(ctr.winners_by_proposal(prop_id, None), vec![]);

        // cooldown over but not past `finish_time`
        ctr.admin_set_finish_time(START + 200);
        ctx.block_timestamp = (START + 150) * MSECOND;
        testing_env!(ctx.clone());
        assert_eq!(ctr.winners_by_proposal(prop_id, None), vec![]);

        // the method should return only the candiadtes that reach min_candidate support
        // thats why we have only 4 winners rather than 5
        ctx.block_timestamp = (START + 201) * MSECOND; // past cooldown
        testing_env!(ctx.clone());
        assert_eq!(
            ctr.winners_by_proposal(prop_id, None),
            vec![candidate(3), candidate(6), candidate(2), candidate(4)]
        );
    }

    #[test]
    fn winners_by_proposal_tie() {
        let (mut ctx, mut ctr) = setup(&admin());
        // all candidates
        let prop_id1 = mock_proposal_and_votes(&mut ctx, &mut ctr, 6, 0);
        // top two, no tie
        let prop_id2 = mock_proposal_and_votes(&mut ctx, &mut ctr, 2, 0);
        // top 4, all seats have min support
        let prop_id3 = mock_proposal_and_votes(&mut ctx, &mut ctr, 4, 10);
        // top 4, candidate 5&6 are in tie at the end, so both will be rejected and last seat is not taken.
        let prop_id4 = mock_proposal_and_votes(&mut ctx, &mut ctr, 5, 0);

        ctx.block_timestamp = (START + 111) * MSECOND; // past cooldown
        testing_env!(ctx.clone());
        let all = vec![
            candidate(3),
            candidate(6),
            candidate(2),
            candidate(4),
            candidate(1),
            candidate(5),
        ];
        assert_eq!(ctr.winners_by_proposal(prop_id1, None), all);
        assert_eq!(ctr.winners_by_proposal(prop_id2, None), all[0..2]);
        assert_eq!(ctr.winners_by_proposal(prop_id3, None), all[0..4]);
        assert_eq!(ctr.winners_by_proposal(prop_id4, None), all[0..4]);
    }

    #[test]
    fn double_bond() {
        let (mut ctx, mut ctr) = setup(&alice());

        ctx.predecessor_account_id = sbt_registry();
        ctx.attached_deposit = BOND_AMOUNT;
        testing_env!(ctx);

        ctr.bond(alice(), mk_human_sbt(2), Value::String("".to_string()));
        ctr.bond(alice(), mk_human_sbt(2), Value::String("".to_string()));

        assert_eq!(ctr.bonded_amounts.get(&2).unwrap(), 2 * BOND_AMOUNT);
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn admin_disqualify_candidates_not_admin() {
        let (_, mut ctr) = setup(&alice());
        ctr.admin_disqualify_candidates(vec![candidate(1), candidate(2)])
    }

    #[test]
    fn admin_disqualify_candidates() {
        let (_, mut ctr) = setup(&admin());
        let disqualified_candidates = vec![candidate(1), candidate(2)];
        ctr.admin_disqualify_candidates(disqualified_candidates.clone());
        let res = ctr.disqualified_candidates();
        assert_eq!(res.len(), 2);
        assert!(res.contains(&disqualified_candidates[0]));
        assert!(res.contains(&disqualified_candidates[1]));
    }

    #[test]
    fn winners_by_proposal_disqualified_candidates() {
        let (mut ctx, mut ctr) = setup(&admin());

        // more seats than candidates
        let prop_id = mock_proposal_and_votes(&mut ctx, &mut ctr, 5, 0);

        // disqualify candidate(3)
        ctr.admin_disqualify_candidates(vec![candidate(3), candidate(2)]);

        // the method should return only the candiadtes that reach min_candidate support
        // and are not disqualifed
        ctx.block_timestamp = (START + 201) * MSECOND; // past cooldown
        ctx.prepaid_gas = Gas::ONE_TERA.mul(10);
        testing_env!(ctx.clone());
        assert_eq!(
            ctr.winners_by_proposal(prop_id, None),
            vec![candidate(6), candidate(4), candidate(1), candidate(5)]
        );
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn admin_mint_sbt_not_admin() {
        let (_, mut ctr) = setup(&alice());
        ctr.admin_mint_sbt(vec![candidate(1), candidate(2)], I_VOTED_SBT_CLASS);
    }

    #[test]
    fn admin_set_class_metadata() {
        let (_, mut ctr) = setup(&admin());
        ctr.admin_set_class_metadata(1, class_metadata("test2".to_string()));
        let res = ctr.class_metadata.get(&1);
        assert_eq!(res.unwrap(), class_metadata("test2".to_string()));
    }

    #[test]
    #[should_panic(expected = "not an admin")]
    fn admin_set_class_metadata_not_admin() {
        let (_, mut ctr) = setup(&alice());
        ctr.admin_set_class_metadata(1, class_metadata("test2".to_string()));
    }
}

'''
'''--- elections/src/migrate.rs ---
use crate::*;

#[derive(BorshDeserialize, PanicOnDefault)]
pub struct OldState {
    pub pause: bool,
    pub prop_counter: u32,
    pub proposals: LookupMap<u32, Proposal>,
    pub policy: [u8; 32],
    pub accepted_policy: LookupMap<AccountId, [u8; 32]>,
    pub bonded_amounts: LookupMap<TokenId, u128>,
    pub total_slashed: u128,
    pub finish_time: u64,
    pub authority: AccountId,
    pub sbt_registry: AccountId,
    pub disqualified_candidates: LazyOption<HashSet<AccountId>>,
}

#[near_bindgen]
impl Contract {
    #[private]
    #[init(ignore_state)]
    /* pub  */
    pub fn migrate() -> Self {
        let old_state: OldState = env::state_read().expect("failed");
        // new field in the smart contract :
        // + class_metadata: ClassMetadata,

        Self {
            pause: old_state.pause,
            prop_counter: old_state.prop_counter,
            proposals: old_state.proposals,
            policy: old_state.policy,
            accepted_policy: old_state.accepted_policy,
            bonded_amounts: old_state.bonded_amounts,
            total_slashed: old_state.total_slashed,
            finish_time: old_state.finish_time,
            authority: old_state.authority,
            sbt_registry: old_state.sbt_registry,
            disqualified_candidates: old_state.disqualified_candidates,
            class_metadata: LookupMap::new(StorageKey::ClassMetadata),
        }
    }
}

'''
'''--- elections/src/proposal.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, require, AccountId};
use std::collections::HashSet;
use uint::hex;

pub use crate::constants::*;
use crate::{RevokeVoteError, TokenId, VoteError};

#[derive(Serialize, Deserialize, BorshDeserialize, BorshSerialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(test, derive(Debug))]
pub enum ProposalType {
    HouseOfMerit,
    CouncilOfAdvisors,
    TransparencyCommission,
    SetupPackage,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(test, derive(Debug, PartialEq))]
pub enum ProposalStatus {
    #[allow(non_camel_case_types)]
    NOT_STARTED,
    ONGOING,
    COOLDOWN,
    ENDED,
}

#[derive(BorshDeserialize, BorshSerialize)]
#[cfg_attr(test, derive(Debug))]
pub struct Proposal {
    pub typ: ProposalType,
    pub ref_link: String,
    /// start of voting as Unix timestamp (in milliseconds)
    pub start: u64,
    /// end of voting as Unix timestamp (in milliseconds)
    pub end: u64,
    /// duration of cooldown after the proposal ends. During this time votes cannot be submitted and
    /// the malicious votes can be revoked by authorities (in milliseconds).
    pub cooldown: u64,
    /// min amount of voters to legitimize the voting.
    pub quorum: u32,
    /// max amount of seats a voter can allocate candidates for. (The number of `seats` equals the number of vote credits)
    pub seats: u16,
    /// list of valid candidates. Must be ordered.
    pub candidates: Vec<AccountId>,
    /// running result (ongoing sum of votes per candidate), in the same order as `candidates`.
    /// result[i] = sum of votes for candidates[i]
    pub result: Vec<u64>,
    /// map of voter SBT -> candidates they voted for (token IDs used for voting -> candidates index)
    pub voters: LookupMap<TokenId, Vec<usize>>,
    pub voters_num: u32,
    /// min amount of votes for a candidate to be considered a "winner".
    pub min_candidate_support: u64,
    /// Map of user -> sbt they voted with
    pub user_sbt: LookupMap<AccountId, TokenId>,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(test, derive(Debug, PartialEq))]
#[cfg_attr(not(target_arch = "wasm32"), derive(Deserialize))]
pub struct ProposalView {
    pub id: u32,
    pub typ: ProposalType,
    pub ref_link: String,
    /// start of voting as Unix timestamp (in milliseconds)
    pub start: u64,
    /// end of voting as Unix timestamp (in milliseconds)
    pub end: u64,
    /// cooldown period after voting ends (in milliseconds)
    pub cooldown: u64,
    /// min amount of voters to legitimize the voting.
    pub quorum: u32,
    pub voters_num: u32,
    /// max amount of credits each voter has
    pub seats: u16,
    /// list of candidates with sum of votes.
    pub result: Vec<(AccountId, u64)>,
}

impl Proposal {
    pub fn to_view(self, id: u32) -> ProposalView {
        let mut result: Vec<(AccountId, u64)> = Vec::with_capacity(self.candidates.len());
        for i in 0..self.candidates.len() {
            let c = self.candidates[i].clone();
            let r = self.result[i];
            result.push((c, r));
        }
        ProposalView {
            id,
            typ: self.typ,
            ref_link: self.ref_link,
            start: self.start,
            end: self.end,
            cooldown: self.cooldown,
            quorum: self.quorum,
            voters_num: self.voters_num,
            seats: self.seats,
            result,
        }
    }

    pub fn assert_active(&self) {
        let now = env::block_timestamp_ms();
        require!(
            self.start <= now && now <= self.end,
            format!("can only vote between proposal start and end time")
        )
    }

    pub fn is_active_or_cooldown(&self) -> bool {
        let now = env::block_timestamp_ms();
        if self.start <= now && now <= (self.end + self.cooldown) {
            return true;
        }
        false
    }

    #[inline]
    pub fn is_past_cooldown(&self) -> bool {
        env::block_timestamp_ms() > self.end + self.cooldown
    }

    /// once vote proof has been verified, we call this function to register a vote.
    pub fn vote_on_verified(
        &mut self,
        sbts: &Vec<TokenId>,
        voter: AccountId,
        vote: Vote,
    ) -> Result<(), VoteError> {
        self.assert_active();
        let mut indexes = Vec::new();
        self.voters_num += 1;
        for candidate in vote {
            let idx = self.candidates.binary_search(&candidate).unwrap();
            self.result[idx] += 1;
            indexes.push(idx);
        }
        // TODO: this logic needs to be updated once we use more tokens per user to vote
        // now we require that sbts length is 1 (it's checked in the contract.on_vote_verified)
        for t in sbts {
            if self.voters.insert(t, &indexes).is_some() {
                return Err(VoteError::DoubleVote(*t));
            }
            self.user_sbt.insert(&voter, t);
        }
        Ok(())
    }

    pub fn revoke_votes(&mut self, token_id: TokenId) -> Result<(), RevokeVoteError> {
        // if !self.is_active_or_cooldown() {
        //     return Err(RevokeVoteError::NotActive);
        // }
        let vote = self
            .voters
            .get(&token_id)
            .ok_or(RevokeVoteError::NotVoted)?;
        for candidate in vote {
            self.result[candidate] -= 1;
        }
        self.voters_num -= 1;
        self.voters.remove(&token_id);
        Ok(())
    }

    /// returns proposal status
    /// now: time in miliseconds
    pub fn status(&self, now: u64, finish_time: u64) -> ProposalStatus {
        if now < self.start {
            ProposalStatus::NOT_STARTED
        } else if now <= self.end {
            return ProposalStatus::ONGOING;
        } else if now <= self.cooldown + self.end || now < finish_time {
            return ProposalStatus::COOLDOWN;
        } else {
            return ProposalStatus::ENDED;
        }
    }
}

pub type Vote = Vec<AccountId>;

/// * valid_candidates must be a sorted slice.
pub fn validate_vote(
    typ: ProposalType,
    vs: &Vote,
    max_credits: u16,
    valid_candidates: &[AccountId],
) {
    if typ == ProposalType::SetupPackage {
        require!(!vs.is_empty(), "setup package vote must be non empty");
    }
    require!(
        vs.len() <= max_credits as usize,
        format!("max vote is {} seats", max_credits)
    );
    let mut vote_for = HashSet::new();
    for candidate in vs {
        require!(
            vote_for.insert(candidate),
            "double vote for the same option"
        );
        require!(
            valid_candidates.binary_search(candidate).is_ok(),
            "vote for unknown option"
        );
    }
}

/// Decodes hex string into bytes. Panics if `s` is not a 64byte hex string.
pub fn assert_hash_hex_string(s: &str) -> [u8; 32] {
    require!(s.len() == 64, "policy must be a 64byte hex string");
    let mut a: [u8; 32] = [0u8; 32];
    hex::decode_to_slice(s, &mut a).expect("policy must be a proper hex string");
    a
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod unit_tests {
    use super::*;
    use crate::{storage::StorageKey, ProposalType, ProposalView};

    fn mk_account(i: u16) -> AccountId {
        AccountId::new_unchecked(format!("acc{}", i))
    }

    #[test]
    fn test_assert_hash_hex_string() {
        let h = "f1c09f8686fe7d0d798517111a66675da0012d8ad1693a47e0e2a7d3ae1c69d4";
        let b1 = assert_hash_hex_string(h);
        let b2 = hex::decode(h).unwrap();
        assert_eq!(b1.to_vec(), b2);
    }

    #[test]
    #[should_panic(expected = "policy must be a 64byte hex string")]
    fn test_assert_hash_hex_string_not_64bytes() {
        let h = "f1c09f8";
        assert_hash_hex_string(h);
    }

    #[test]
    fn to_proposal_view() {
        let p = Proposal {
            typ: ProposalType::CouncilOfAdvisors,
            ref_link: "near.social/abc".to_owned(),
            start: 10,
            end: 111222,
            cooldown: 1000,
            quorum: 551,
            seats: 2,
            candidates: vec![mk_account(2), mk_account(1), mk_account(3), mk_account(4)],
            result: vec![10000, 5, 321, 121],
            voters: LookupMap::new(StorageKey::ProposalVoters(1)),
            voters_num: 10,
            min_candidate_support: 2,
            user_sbt: LookupMap::new(StorageKey::UserSBT(1)),
        };
        assert_eq!(
            ProposalView {
                id: 12,
                typ: ProposalType::CouncilOfAdvisors,
                ref_link: p.ref_link.clone(),
                start: p.start,
                end: p.end,
                cooldown: p.cooldown,
                quorum: p.quorum,
                seats: p.seats,
                voters_num: p.voters_num,
                result: vec![
                    (mk_account(2), 10000),
                    (mk_account(1), 5),
                    (mk_account(3), 321),
                    (mk_account(4), 121)
                ],
            },
            p.to_view(12)
        )
    }

    #[test]
    fn revoke_votes() {
        let mut p = Proposal {
            typ: ProposalType::CouncilOfAdvisors,
            ref_link: "near.social/abc".to_owned(),
            start: 0,
            end: 100,
            cooldown: 10,
            quorum: 551,
            seats: 2,
            candidates: vec![mk_account(1), mk_account(2)],
            result: vec![3, 1],
            voters: LookupMap::new(StorageKey::ProposalVoters(1)),
            voters_num: 3,
            min_candidate_support: 2,
            user_sbt: LookupMap::new(StorageKey::UserSBT(1)),
        };
        p.voters.insert(&1, &vec![0, 1]);
        p.voters.insert(&2, &vec![0]);
        p.voters.insert(&3, &vec![0]);

        match p.revoke_votes(1) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        }
        assert_eq!(p.result, vec![2, 0]);
        match p.revoke_votes(2) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        }
        assert_eq!(p.result, vec![1, 0]);
        match p.revoke_votes(3) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        }
        assert_eq!(p.result, vec![0, 0]);
    }

    #[test]
    fn revoke_revoked_votes() {
        let mut p = Proposal {
            typ: ProposalType::CouncilOfAdvisors,
            ref_link: "near.social/abc".to_owned(),
            start: 0,
            end: 100,
            cooldown: 10,
            quorum: 551,
            seats: 2,
            candidates: vec![mk_account(1), mk_account(2)],
            result: vec![1, 1],
            voters: LookupMap::new(StorageKey::ProposalVoters(1)),
            voters_num: 1,
            min_candidate_support: 2,
            user_sbt: LookupMap::new(StorageKey::UserSBT(1)),
        };
        p.voters.insert(&1, &vec![0, 1]);

        match p.revoke_votes(1) {
            Ok(_) => (),
            x => panic!("expected OK, got: {:?}", x),
        }
        assert_eq!(p.result, vec![0, 0]);
        match p.revoke_votes(1) {
            Err(RevokeVoteError::NotVoted) => (),
            x => panic!("expected NotVoted, got: {:?}", x),
        }
    }

    #[test]
    fn revoke_non_exising_votes() {
        let mut p = Proposal {
            typ: ProposalType::CouncilOfAdvisors,
            ref_link: "near.social/abc".to_owned(),
            start: 0,
            end: 100,
            cooldown: 10,
            quorum: 551,
            seats: 2,
            candidates: vec![mk_account(1), mk_account(2)],
            result: vec![1, 1],
            voters: LookupMap::new(StorageKey::ProposalVoters(1)),
            voters_num: 1,
            min_candidate_support: 2,
            user_sbt: LookupMap::new(StorageKey::UserSBT(1)),
        };
        p.voters.insert(&1, &vec![0, 1]);

        match p.revoke_votes(2) {
            Err(RevokeVoteError::NotVoted) => (),
            x => panic!("expected NotVoted, got: {:?}", x),
        }
    }
}

'''
'''--- elections/src/storage.rs ---
use near_sdk::borsh::{self, BorshSerialize};
use near_sdk::serde::Deserialize;
use near_sdk::BorshStorageKey;

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Proposals,
    ProposalVoters(u32),
    AcceptedPolicy,
    BondedAmount,
    UserSBT(u32),
    DisqualifiedCandidates,
    ClassMetadata,
}

#[derive(PartialEq, Deserialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone))]
pub enum AccountFlag {
    /// Account is "blacklisted" when it was marked as a scam or breaking the IAH rules.
    Blacklisted,
    Verified,
}

'''
'''--- elections/src/view.rs ---
use near_sdk::{env, near_bindgen, AccountId, Balance};
use sbt::{ClassId, ClassMetadata};
use uint::hex;

use crate::{proposal::*, TokenId};
use crate::{Contract, ContractExt};

#[near_bindgen]
impl Contract {
    pub(crate) fn _proposal(&self, prop_id: u32) -> Proposal {
        self.proposals.get(&prop_id).expect("proposal not found")
    }

    /**********
     * QUERIES
     **********/

    pub fn finish_time(&self) -> u64 {
        self.finish_time
    }

    pub fn proposals(&self) -> Vec<ProposalView> {
        let mut proposals = Vec::with_capacity(self.prop_counter as usize);
        for i in 1..=self.prop_counter {
            proposals.push(self.proposals.get(&i).unwrap().to_view(i));
        }
        proposals
    }

    pub fn proposal(&self, prop_id: u32) -> ProposalView {
        self._proposal(prop_id).to_view(prop_id)
    }

    /// Returns the proposal status
    pub fn proposal_status(&self, prop_id: u32) -> Option<ProposalStatus> {
        let now = env::block_timestamp_ms();
        self.proposals
            .get(&prop_id)
            .map(|p| p.status(now, self.finish_time))
    }

    /// Returns the policy if user has accepted it otherwise returns None
    pub fn accepted_policy(&self, user: AccountId) -> Option<String> {
        self.accepted_policy.get(&user).map(hex::encode)
    }

    /// Returns all the users votes for all the proposals. If user has not voted yet a vector with None values will be returned.
    /// Eg. if we have 3 porposals and user only voted on first one then the return value will look like [Some([1,2]), None, None]
    /// NOTE: the response may not be consistent with the registry. If user will do a soul_transfer, then technically votes should be associated
    /// with other user. Here we return votes from the original account that voted for the given user.
    pub fn user_votes(&self, user: AccountId) -> Vec<Option<Vec<usize>>> {
        let mut to_return = Vec::new();

        for p in 1..=self.prop_counter {
            if let Some(proposal) = self.proposals.get(&p) {
                if let Some(user_vote_key) = proposal.user_sbt.get(&user) {
                    let user_vote = proposal.voters.get(&user_vote_key);
                    to_return.push(user_vote);
                } else {
                    to_return.push(None);
                }
            }
        }
        to_return
    }

    /// Returns bond amount by SBT TokenID.
    pub fn bond_by_sbt(&self, sbt: TokenId) -> Balance {
        self.bonded_amounts.get(&sbt).unwrap_or(0)
    }

    /// Returns true if user has voted on all proposals, otherwise false.
    pub fn has_voted_on_all_proposals(&self, user: AccountId) -> bool {
        self.user_votes(user).iter().all(|vote| vote.is_some())
    }

    /// Returns the required policy
    pub fn policy(&self) -> String {
        hex::encode(self.policy)
    }

    /// Returns a list of winners of the proposal if the elections is over and the quorum has been reached, otherwise returns empty list.
    /// A candidate is considered the winner only if he reached the `min_candidate_support`
    /// and is not listed as disqualified.
    /// If the number of returned winners is smaller than the number of seats it means some of the candidates
    /// did not reach the required minimum support.
    /// If there is a tie break at the tail and it exceeds the number of seats, the accounts
    /// in tie at the tail are not considered winners.
    pub fn winners_by_proposal(&self, prop_id: u32, ongoing: Option<bool>) -> Vec<AccountId> {
        let proposal = self._proposal(prop_id);

        if !(proposal.is_past_cooldown()
            && env::block_timestamp_ms() > self.finish_time
            && proposal.voters_num >= proposal.quorum)
            && !ongoing.unwrap_or(false)
        {
            return Vec::new();
        }

        // Filter and sort the candidates in one step
        let disqualified = self.disqualified_candidates.get().unwrap_or_default();
        let mut indexed_results: Vec<(usize, u64)> = proposal
            .result
            .iter()
            .enumerate()
            .filter(|(idx, _)| !disqualified.contains(&proposal.candidates[*idx]))
            .map(|(idx, &votes)| (idx, votes))
            .collect();

        indexed_results.sort_by_key(|&(_, value)| std::cmp::Reverse(value));

        let mut winners = Vec::new();
        let last_out_idx = proposal.seats as usize;
        let last_out_votes = indexed_results
            .get(last_out_idx)
            .map(|&(_, votes)| votes)
            .unwrap_or(indexed_results[0].1 + 1);

        for (idx, votes) in indexed_results.into_iter().take(last_out_idx) {
            // Filter out tie in the tail if it could exceed the seats
            if proposal.min_candidate_support <= votes && last_out_votes < votes {
                let candidate = proposal.candidates.get(idx).unwrap();
                winners.push(candidate.clone());
            }
        }

        winners
    }

    /// Returns the list of disqualified candidates
    pub fn disqualified_candidates(&self) -> Vec<AccountId> {
        self.disqualified_candidates
            .get()
            .unwrap_or_default()
            .into_iter()
            .collect()
    }

    pub fn class_metadata(&self, id: ClassId) -> Option<ClassMetadata> {
        self.class_metadata.get(&id)
    }
}

'''
'''--- elections/tests/iah.rs ---
use integrations::setup_registry;
use near_units::parse_near;
use near_workspaces::{Account, AccountId, Contract, DevNetwork, Worker};
use sbt::ClassMetadata;
use serde_json::json;

/// 1ms in nano seconds
//extern crate elections;
use elections::{
    proposal::ProposalType, OwnedToken, ProposalView, TokenMetadata, ACCEPT_POLICY_COST,
    BOND_AMOUNT, MILI_NEAR, MINT_COST,
};

/// 1ms in seconds
const MSECOND: u64 = 1_000_000;

pub struct InitStruct {
    pub ndc_elections_contract: Contract,
    pub registry_contract: Contract,
    pub alice: Account,
    pub bob: Account,
    pub john: Account,
    pub auth_flagger: Account,
    pub admin: Account,
    pub proposal_id: u32,
}

async fn init(worker: &Worker<impl DevNetwork>) -> anyhow::Result<InitStruct> {
    // deploy contracts
    let ndc_elections_contract = worker.dev_deploy(include_bytes!("../../res/elections.wasm"));
    let ndc_elections_contract = ndc_elections_contract.await?;

    let admin = worker.dev_create_account().await?;
    let auth_flagger = worker.dev_create_account().await?;
    let iah_issuer = worker.dev_create_account().await?;
    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;
    let john = worker.dev_create_account().await?;

    let registry_contract = setup_registry(
        worker,
        admin.clone(),
        auth_flagger.clone(),
        iah_issuer.clone(),
        vec![ndc_elections_contract.id().clone()],
    )
    .await?;

    // initialize contracts
    let res1 = ndc_elections_contract
        .call("new")
        .args_json(json!({
            "authority": admin.id(),
            "sbt_registry": registry_contract.id(),
            "policy": policy1(),
            "finish_time": 1,
            "class_metadata": ClassMetadata { name: "I Voted SBT".to_string(), symbol: None, icon: None, reference: None, reference_hash: None},
        }))
        .max_gas()
        .transact();

    assert!(res1.await?.is_success());

    // get current block time
    let block = worker.view_block().await?;
    let now = block.timestamp() / MSECOND; // timestamp in seconds
    let start_time = now + 20 * 1000; // below we are executing 5 transactions, first has 3 receipts, so the proposal is roughtly now + 20seconds
    let expires_at: u64 = now + 100 * 1_000;
    let proposal_expires_at: u64 = expires_at + 25 * 1000;

    // mint IAH sbt to alice and john
    let token_metadata = TokenMetadata {
        class: 1,
        issued_at: Some(0),
        expires_at: Some(proposal_expires_at * 20),
        reference: None,
        reference_hash: None,
    };

    let token_metadata_short_expire_at = TokenMetadata {
        class: 1,
        issued_at: Some(0),
        expires_at: Some(now + 9000),
        reference: None,
        reference_hash: None,
    };

    // mint IAH sbt to bob
    let token_metadata_bob = TokenMetadata {
        class: 1,
        issued_at: Some(0),
        expires_at: Some(expires_at),
        reference: None,
        reference_hash: None,
    };

    let token_spec = vec![
        (alice.id(), vec![token_metadata]),
        (bob.id(), vec![token_metadata_bob]),
        (john.id(), vec![token_metadata_short_expire_at]),
    ];

    let res1 = iah_issuer
        .call(registry_contract.id(), "sbt_mint")
        .args_json(json!({ "token_spec": token_spec }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?;

    // create a proposal
    let res2 = admin
        .call(ndc_elections_contract.id(), "create_proposal")
        .args_json(json!({
            "typ": ProposalType::HouseOfMerit, "start": start_time,
            "end": proposal_expires_at, "cooldown": 1, "ref_link": "test.io", "quorum": 10,
            "credits": 5, "seats": 1, "candidates": [john.id(), alice.id()],
            "min_candidate_support": 2,
        }))
        .max_gas()
        .transact();

    accept_policy_and_bond(
        registry_contract.clone(),
        ndc_elections_contract.clone(),
        john.clone(),
        policy1(),
    )
    .await?;
    accept_policy_and_bond(
        registry_contract.clone(),
        ndc_elections_contract.clone(),
        alice.clone(),
        policy1(),
    )
    .await?;

    let res3 = auth_flagger
        .call(registry_contract.id(), "admin_flag_accounts")
        .args_json(
            json!({ "flag": "Verified", "accounts": [john.id(), alice.id(), bob.id()], "memo": ""}),
        )
        .max_gas()
        .transact()
        .await?;
    assert!(res3.is_success(), "{:?}", res3);

    assert!(res1.is_success(), "{:?}", res1);
    let proposal_id: u32 = res2.await?.json()?;

    Ok(InitStruct {
        ndc_elections_contract: ndc_elections_contract.to_owned(),
        registry_contract: registry_contract.to_owned(),
        alice,
        bob,
        john,
        auth_flagger,
        admin,
        proposal_id,
    })
}

#[tokio::test]
async fn vote_by_human() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    // fast forward to the voting period
    worker.fast_forward(10).await?;

    let res = setup
        .alice
        .call(setup.ndc_elections_contract.id(), "vote")
        .args_json(json!({"prop_id": setup.proposal_id, "vote": [setup.john.id()],}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    Ok(())
}

#[tokio::test]
async fn vote_by_non_human() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let non_human = worker.dev_create_account().await?;
    // fast forward to the voting period
    worker.fast_forward(12).await?;

    let res = non_human
        .call(setup.ndc_elections_contract.id(), "vote")
        .args_json(json!({"prop_id": setup.proposal_id, "vote": [setup.john.id()],}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "resp should be a failure {:?}", res);
    let res_str = format!("{:?}", res);
    assert!(
        res_str.contains("user didn't accept the voting policy"),
        "{}",
        res_str
    );

    Ok(())
}

#[tokio::test]
async fn vote_expired_iah_token() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    // fast forward to the voting period
    worker.fast_forward(70).await?;

    let res = setup
        .john
        .call(setup.ndc_elections_contract.id(), "vote")
        .args_json(json!({"prop_id": setup.proposal_id, "vote": [setup.alice.id()],}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "resp should be a failure {:?}", res);
    let failures = format!("{:?}", res.receipt_failures());
    assert!(
        failures.contains("voter is not a verified human"),
        "{}",
        failures
    );

    Ok(())
}

#[tokio::test]
async fn vote_without_accepting_policy() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;
    let zen_acc = worker.dev_create_account().await?;
    // fast forward to the voting period
    worker.fast_forward(10).await?;

    let res = zen_acc
        .call(setup.ndc_elections_contract.id(), "vote")
        .args_json(json!({"prop_id": setup.proposal_id, "vote": [setup.john.id()],}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "resp should be a failure {:?}", res);
    let failures = format!("{:?}", res.receipt_failures());
    assert!(
        failures.contains("user didn't accept the voting policy, or the accepted voting policy doesn't match the required one"),
        "{}",
        failures
    );

    Ok(())
}

#[tokio::test]
async fn vote_without_deposit_bond() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let res = setup
        .bob
        .call(
            setup.ndc_elections_contract.id(),
            "accept_fair_voting_policy",
        )
        .args_json(json!({
            "policy": policy1(),
        }))
        .deposit(ACCEPT_POLICY_COST)
        .max_gas()
        .transact()
        .await?;

    assert!(res.is_success(), "{:?}", res);

    // fast forward to the voting period
    worker.fast_forward(10).await?;

    let res = setup
        .bob
        .call(setup.ndc_elections_contract.id(), "vote")
        .args_json(json!({"prop_id": setup.proposal_id, "vote": [setup.john.id()],}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "resp should be a failure {:?}", res);
    let failures = format!("{:?}", res.receipt_failures());
    assert!(failures.contains("Voter didn't bond"), "{}", failures);

    Ok(())
}

#[tokio::test]
async fn unbond_amount_before_election_end() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    // fast forward to the voting period
    worker.fast_forward(12).await?;

    let res = setup
        .alice
        .call(setup.ndc_elections_contract.id(), "vote")
        .args_json(json!({"prop_id": setup.proposal_id, "vote": [setup.john.id()],}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let res1 = setup.alice
        .call(setup.registry_contract.id(), "is_human_call")
        .args_json(
            json!({"ctr": setup.ndc_elections_contract.id(), "function": "unbond", "payload": "{}"}),
        )
        .max_gas()
        .transact()
        .await?;
    assert!(res1.is_failure(), "resp should be a failure {:?}", res1);
    let failures = format!("{:?}", res1.receipt_failures());
    assert!(
        failures.contains("cannot unbond: election is still in progress"),
        "{}",
        failures
    );
    Ok(())
}

#[tokio::test]
async fn unbond_amount() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    // fast forward to the voting period
    worker.fast_forward(12).await?;

    let res = setup
        .alice
        .call(setup.ndc_elections_contract.id(), "vote")
        .args_json(json!({"prop_id": setup.proposal_id, "vote": [setup.john.id()],}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let balance_before = setup.alice.view_account().await?;
    // fast forward to the end of voting + cooldown period
    worker.fast_forward(200).await?;

    let res1 = setup.alice
        .call(setup.registry_contract.id(), "is_human_call")
        .args_json(
            json!({"ctr": setup.ndc_elections_contract.id(), "function": "unbond", "payload": "{}"}),
        )
        .max_gas()
        .transact()
        .await?;
    assert!(res1.is_success(), "{:?}", res1);

    let balance_after = setup.alice.view_account().await?;
    /*
    Make sure you get back your NEAR - Tx fees - Storage
    There is only one proposal, so all storage fees should be returned minus Tx fees and SBT Mint storage
    */
    assert_received_tokens(balance_after.balance, balance_before.balance);

    // verify voter has i_voted sbt
    let sbt = verify_i_voted_sbt_tokens_by_owner(
        setup.registry_contract.id(),
        setup.ndc_elections_contract.id(),
        setup.alice,
    )
    .await?;
    assert!(sbt);

    Ok(())
}

#[tokio::test]
async fn sbt_mint_no_vote() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let block = worker.view_block().await?;
    let now = block.timestamp() / MSECOND; // timestamp in seconds
                                           // create second proposal
    let prop2 = setup
        .admin
        .call(setup.ndc_elections_contract.id(), "create_proposal")
        .args_json(json!({
            "typ": ProposalType::CouncilOfAdvisors, "start": now + 20 * 1000,
            "end": now + 25 * 1000, "cooldown": 1, "ref_link": "test.io", "quorum": 10,
            "credits": 5, "seats": 1, "candidates": [setup.john.id(), setup.alice.id()],
            "min_candidate_support": 2,
        }))
        .max_gas()
        .transact()
        .await?;
    assert!(prop2.is_success(), "{:?}", prop2);

    // fast forward to the voting period
    worker.fast_forward(12).await?;

    // Vote only on one proposal
    let res = setup
        .alice
        .call(setup.ndc_elections_contract.id(), "vote")
        .args_json(json!({"prop_id": setup.proposal_id, "vote": [setup.john.id()],}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let balance_before = setup.alice.view_account().await?;
    // fast forward to the end of voting + cooldown period
    worker.fast_forward(200).await?;

    let res1 = setup.alice
        .call(setup.registry_contract.id(), "is_human_call")
        .args_json(
            json!({"ctr": setup.ndc_elections_contract.id(), "function": "unbond", "payload": "{}"}),
        )
        .max_gas()
        .transact()
        .await?;
    assert!(res1.is_success(), "{:?}", res1);

    let balance_after = setup.alice.view_account().await?;
    /*
    Make sure you get back your NEAR - Tx fees - Storage
    There is only one proposal, so all storage fees should be returned minus Tx fees and SBT Mint storage
    even if sbt is not minted
    */
    assert_received_tokens(balance_after.balance, balance_before.balance);

    let sbt = verify_i_voted_sbt_tokens_by_owner(
        setup.registry_contract.id(),
        setup.ndc_elections_contract.id(),
        setup.alice,
    )
    .await?;
    assert!(!sbt);

    Ok(())
}

#[tokio::test]
async fn admin_mint_voted_sbt() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let res = setup
        .admin
        .call(setup.ndc_elections_contract.id(), "admin_mint_sbt")
        .args_json(json!({"recipient": setup.alice.id()}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let sbt = verify_i_voted_sbt_tokens_by_owner(
        setup.registry_contract.id(),
        setup.ndc_elections_contract.id(),
        setup.alice,
    )
    .await?;
    assert!(sbt);

    Ok(())
}

#[tokio::test]
async fn state_change() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    // fast forward to the voting period
    worker.fast_forward(10).await?;

    let proposal = setup
        .alice
        .call(setup.ndc_elections_contract.id(), "proposal")
        .args_json(json!({ "prop_id": setup.proposal_id }))
        .view()
        .await?
        .json::<ProposalView>()?;
    assert_eq!(proposal.voters_num, 0);

    let res = setup
        .alice
        .call(setup.ndc_elections_contract.id(), "vote")
        .args_json(json!({"prop_id": setup.proposal_id, "vote": [setup.john.id()],}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let proposal = setup
        .alice
        .call(setup.ndc_elections_contract.id(), "proposal")
        .args_json(json!({ "prop_id": setup.proposal_id }))
        .view()
        .await?
        .json::<ProposalView>()?;
    assert_eq!(proposal.voters_num, 1);
    assert_eq!(proposal.result[0].1, 0); // votes for alice
    assert_eq!(proposal.result[1].1, 1); // votes for john

    Ok(())
}

#[tokio::test]
async fn revoke_vote() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    // fast forward to the voting period
    worker.fast_forward(10).await?;

    // alice votes
    let res = setup
        .alice
        .call(setup.ndc_elections_contract.id(), "vote")
        .args_json(json!({"prop_id": setup.proposal_id, "vote": [setup.john.id()],}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // try to revoke the vote (alice is not blacklisted)
    let res = setup
        .john
        .call(setup.ndc_elections_contract.id(), "revoke_vote")
        .args_json(json!({"prop_id": setup.proposal_id, "user": setup.alice.id()}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_failure(), "{:?}", res.receipt_outcomes());

    // flag alice as blacklisted
    let res = setup
        .auth_flagger
        .call(setup.registry_contract.id(), "admin_flag_accounts")
        .args_json(json!({"flag": "Blacklisted", "accounts": [setup.alice.id()], "memo": "test"}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // try to revoke the vote again (alice is now blacklisted)
    let res = setup
        .john
        .call(setup.ndc_elections_contract.id(), "revoke_vote")
        .args_json(json!({"prop_id": setup.proposal_id, "user": setup.alice.id()}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    Ok(())
}

#[tokio::test]
async fn migration_mainnet() -> anyhow::Result<()> {
    let worker_sandbox = near_workspaces::sandbox().await?;
    let worker_mainnet = near_workspaces::mainnet().await?;
    let elections_id: AccountId = "elections.ndc-gwg.near".parse()?;
    let elections = worker_sandbox
        .import_contract(&elections_id, &worker_mainnet)
        .initial_balance(parse_near!("10000000 N"))
        .transact()
        .await?;

    let admin = worker_sandbox.dev_create_account().await?;
    let registry = worker_sandbox.dev_create_account().await?;

    // init the contract
    let res = elections
        .call("new")
        .args_json(json!({
            "authority": admin.id(),
            "sbt_registry": registry.id(),
            "policy": policy1(),
            "finish_time": 1,
        }))
        .max_gas()
        .transact()
        .await?;

    assert!(res.is_success(), "{:?}", res.receipt_failures());

    // deploy the new contract
    let res = elections
        .as_account()
        .deploy(include_bytes!("../../res/elections.wasm"))
        .await?;
    assert!(res.is_success());

    let new_elections = res.into_result()?;
    let class_metadata = ClassMetadata {
        name: "I Voted SBT".to_string(),
        symbol: None,
        icon: None,
        reference: None,
        reference_hash: None,
    };

    // call the migrate method
    let res = new_elections
        .call("migrate")
        .args_json(json!({ "class_metadata": class_metadata }))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res.receipt_failures());

    let res: ClassMetadata = new_elections
        .call("class_metadata")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(res, class_metadata);

    Ok(())
}

async fn accept_policy_and_bond(
    registry: Contract,
    election: Contract,
    user: Account,
    policy: String,
) -> anyhow::Result<()> {
    let call_from = user.clone();
    let res = call_from
        .call(election.id(), "accept_fair_voting_policy")
        .args_json(json!({
            "policy": policy,
        }))
        .deposit(ACCEPT_POLICY_COST)
        .max_gas()
        .transact()
        .await?;

    assert!(res.is_success(), "{:?}", res);

    let call_from2 = user.clone();
    let res1 = call_from2
        .call(registry.id(), "is_human_call")
        .args_json(json!({"ctr": election.id(), "function": "bond", "payload": "{}"}))
        .deposit(BOND_AMOUNT)
        .max_gas()
        .transact()
        .await?;
    assert!(res1.is_success(), "{:?}", res1);
    Ok(())
}

async fn verify_i_voted_sbt_tokens_by_owner(
    iah_registry: &AccountId,
    issuer: &AccountId,
    owner: Account,
) -> anyhow::Result<bool> {
    let res = owner
        .view(iah_registry, "sbt_tokens_by_owner")
        .args_json(json!({
          "account": owner.id(),
          "issuer": issuer,
        }))
        .await?
        .json::<Vec<(AccountId, Vec<OwnedToken>)>>()?;

    if res.is_empty() || res[0].0.clone() != issuer.clone() || res[0].1.is_empty() {
        Ok(false)
    } else {
        Ok(true)
    }
}

fn assert_received_tokens(balance_after: u128, balance_before: u128) {
    let balance_diff = balance_after - balance_before;
    let tx_fees = 3 * MILI_NEAR;
    let min_diff = BOND_AMOUNT - MINT_COST - tx_fees;
    assert!(
        balance_diff > min_diff,
        "diff: {}, min_diff: {}",
        balance_diff,
        min_diff
    );
}

fn policy1() -> String {
    "f1c09f8686fe7d0d798517111a66675da0012d8ad1693a47e0e2a7d3ae1c69d4".to_owned()
}

'''
'''--- integrations/Cargo.toml ---
[package]
name = "integrations"
version = "1.0.0"
authors = { workspace = true }
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
# rlib is needed for integration tests
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true
congress = { path = "../congress" }

anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-primitives.workspace = true
near-units.workspace = true

'''
'''--- integrations/src/lib.rs ---
use std::collections::HashMap;

use congress::{HookPerm, PropPerm};
use near_units::parse_near;
use near_workspaces::{Account, AccountId, Contract, DevNetwork, Worker};
use serde_json::json;

pub async fn setup_registry(
    worker: &Worker<impl DevNetwork>,
    authority: Account,
    auth_flagger: Account,
    iah_issuer: Account,
    issuers: Vec<AccountId>,
) -> anyhow::Result<Contract> {
    let registry_contract = worker
        .dev_deploy(include_bytes!("../../res/registry.wasm"))
        .await?;

    let res = registry_contract
        .call("new")
        .args_json(json!({"authority": authority.id(),
          "iah_issuer": iah_issuer.id(), "iah_classes": [1],
          "authorized_flaggers": vec![auth_flagger.id()],
          "community_verified_set": vec![(iah_issuer.id(), vec![1])]
        }))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // if any issuers passed add them to the registry
    for issuer in issuers {
        let res = authority
            .call(registry_contract.id(), "admin_add_sbt_issuer")
            .args_json(json!({ "issuer": issuer }))
            .max_gas()
            .transact()
            .await?;
        assert!(res.is_success());
    }

    Ok(registry_contract)
}

pub async fn instantiate_congress(
    congress_contract: Contract,
    now: u64,
    members: Vec<&AccountId>,
    member_perms: Vec<PropPerm>,
    hook_auth: HashMap<AccountId, Vec<HookPerm>>,
    community_fund: Account,
    registry: &AccountId,
    cooldown: u64,
) -> anyhow::Result<Contract> {
    let start_time = now + 20 * 1000;
    let end_time: u64 = now + 100 * 1000;
    let vote_duration = 20 * 1000;
    let min_vote_duration = 0;
    // initialize contract
    let res = congress_contract
        .call("new")
        .args_json(json!({
            "community_fund": community_fund.id(),
            "start_time": start_time,
            "end_time": end_time,
            "cooldown": cooldown,
            "vote_duration": vote_duration,
            "min_vote_duration": min_vote_duration,
            "members": members,
            "member_perms": member_perms,
            "hook_auth": hook_auth,
            "budget_cap": parse_near!("1 N").to_string(),
            "big_funding_threshold": parse_near!("0.3 N").to_string(),
            "registry": registry
        }))
        .max_gas()
        .transact()
        .await?;

    assert!(res.is_success(), "{:?}", res);

    Ok(congress_contract)
}

'''
'''--- nominations/Cargo.toml ---
[package]
name = "ndc-nominations"
version = "1.0.0"
authors = { workspace = true }
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
# rlib is needed for integration tests
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true

[dev-dependencies]
anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-primitives.workspace = true
near-units.workspace = true
integrations = { path = "../integrations" }

'''
'''--- nominations/README.md ---
# Nominations

Smart contract for nominations.
[Specification](https://near-ndc.notion.site/Nominations-b4281e30ac4e44cfbd894f0e2443bc88?pvs=4)

Smart contract is primally used for NDC v1 Elections, but can be used also for other use cases (eg Kudos).

## Transactions

- `self_nominate(house: HouseType, comment: String,link: Option<String>)` - allows OG members to submit a nomination.
- `self_revoke()` - enables candidates to revoke their nomination.
- `upvote(candidate: AccountId)` - enables IAH token holders to upvote existing nominations.
- `remove_upvote(candiate: AccountId)` - removes the upvote from the caller for the specified candidate.
- `comment(candidate: AccountId, comment: String)` - enables IAH token holders to comment on existing nominations

## Queries

- `nominations(&self, house: HouseType) -> Vec<(AccountId, u32)>` - returns all the nominations for the given house with the numbers of upvotes received eg. `[("candidate1.near", 16), ("candidate2.near", 5), ...]`.

Comment and upvote queries should be go through an indexer.

## Deployed Contracts

### Mainnet Production

**nominations.ndc-gwg.near** @ nominations/v1.0.0

```yaml
sbt_registry: registry.i-am-human.near,
og_sbt: ["community.i-am-human.near", 1],
start_time: 1689778800000,
end_time: 1694995199000
```

### Mainnet Testing

**nominations-v1.gwg-testing.near** @ nominations/v1.0.0

```yaml
sbt_registry: registry-v1.gwg-testing.near,
iah_issuer: fractal.i-am-human.near,
og_sbt: [fractal.i-am-human.near, 2],
start_time: 1687792608708,
end_time: 1787792508708
```

### Testnet

- **nominations-v1**: `nominations-v1.gwg.testnet`, initialized with values:

  ```yaml
  sbt_registry: registry-unstable.i-am-human.testnet,
  iah_issuer: i-am-human-staging.testnet,
  og_class: 1,
  og_issuer: community-v1.i-am-human.testnet,
  start_time: 0,
  end_time: 1844674407370955300`
  ```

'''
'''--- nominations/helper.sh ---
#!/usr/bin/env sh

CTR=elections-v1.ndc-gwg.testnet
GWG=ndc-gwg.testnet

'''
'''--- nominations/src/constants.rs ---
use near_sdk::{Balance, Gas};

pub const MICRO_NEAR: Balance = 1_000_000_000_000_000_000; // 1e19 yoctoNEAR
pub const MILI_NEAR: Balance = 1_000 * MICRO_NEAR;

/// 1s in nano seconds.
pub const SECOND: u64 = 1_000_000_000;
/// 1ms in nano seconds.
pub const MSECOND: u64 = 1_000_000;

pub const GAS_NOMINATE: Gas = Gas(20 * Gas::ONE_TERA.0);
pub const GAS_UPVOTE: Gas = Gas(20 * Gas::ONE_TERA.0);
pub const GAS_COMMENT: Gas = Gas(20 * Gas::ONE_TERA.0);

/// nomination: (accountID, HouseType) -> (25 bytes  + 24 bytes) = 49 bytes < 100 bytes
pub const NOMINATE_COST: Balance = MILI_NEAR;

/// upvote: (accountID, Account) -> (25 bytes  + 25 bytes) = 50 bytes
/// upvotes_per_candidate: (accountID, u32) -> (25 bytes + 4 bytes) = 29 bytes
/// sum = 50 + 29 = 79 bytes < 100 bytes
pub const UPVOTE_COST: Balance = MILI_NEAR;

pub const MAX_CAMPAIGN_LEN: usize = 200;

'''
'''--- nominations/src/ext.rs ---
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{ext_contract, AccountId};

/// sbt_tokens_by owner interface for cross-contract calls
#[ext_contract(ext_sbtreg)]
pub trait ExtSbtRegistry {
    fn sbt_tokens_by_owner(
        &self,
        account: AccountId,
        issuer: Option<AccountId>,
        from_class: Option<u64>,
        limit: Option<u32>,
        with_expired: Option<bool>,
    ) -> Vec<(AccountId, Vec<OwnedToken>)>;

    fn is_human(&self, account: AccountId) -> Vec<(AccountId, Vec<TokenId>)>;
}

// TODO: use SBT crate once it is published

/// token data for sbt_tokens_by_owner response
#[derive(Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OwnedToken {
    pub token: u64,
    pub metadata: TokenMetadata,
}

/// TokenMetadata defines attributes for each SBT token.
#[derive(Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub class: u64,
    pub issued_at: Option<u64>,
    pub expires_at: Option<u64>,
    pub reference: Option<String>,
    pub reference_hash: Option<String>,
}

pub type TokenId = u64;

'''
'''--- nominations/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap, UnorderedMap};
use near_sdk::env::panic_str;
use near_sdk::{env, near_bindgen, require, AccountId, PanicOnDefault, Promise};

mod constants;
pub mod storage;

pub use crate::constants::*;
use crate::storage::*;

pub mod ext;
pub use crate::ext::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// registry address
    pub sbt_registry: AccountId,
    /// OG token (issuer, class_id)
    pub og_sbt: (AccountId, u64),
    /// map of nominations
    pub nominations: UnorderedMap<AccountId, Nomination>,
    /// map (candidate, upvoter) -> timestamp_ms
    pub upvotes: LookupMap<(AccountId, AccountId), u64>,
    /// list of admins
    pub admins: LazyOption<Vec<AccountId>>,
    /// nomination period start time in ms
    pub start_time: u64,
    /// nomination period end time in ms
    pub end_time: u64,
    /// next comment id
    pub next_comment_id: u64,
}

#[near_bindgen]
impl Contract {
    /// start_time and end_time must be a valid unix time in millisecond.
    #[init]
    pub fn new(
        sbt_registry: AccountId,
        og_sbt: (AccountId, u64),
        admins: Vec<AccountId>,
        start_time: u64,
        end_time: u64,
    ) -> Self {
        require!(start_time < end_time, "start must be before end time");
        Self {
            sbt_registry,
            og_sbt,
            start_time,
            end_time,
            nominations: UnorderedMap::new(StorageKey::Nominations),
            upvotes: LookupMap::new(StorageKey::Upvotes),
            admins: LazyOption::new(StorageKey::Admins, Some(&admins)),
            next_comment_id: 0,
        }
    }

    /**********
     * QUERIES
     **********/

    /// Returns list of pairs:
    /// (self-nominated account, sum of upvotes) for a given house.
    pub fn nominations(&self, house: HouseType) -> Vec<(AccountId, u32)> {
        let mut results: Vec<(AccountId, u32)> = Vec::new();
        for n in self.nominations.iter() {
            if n.1.house == house {
                results.push((n.0, n.1.upvotes));
            }
        }
        results
    }

    /// Returns nominations start time and end time as a pair of unix timestamp in miliseconds.
    pub fn active_time(&self) -> (u64, u64) {
        (self.start_time, self.end_time)
    }

    /**********
     * TRANSACTIONS
     **********/

    /// Nominate method allows to submit self-nominatios by OG members
    /// + checks if the caller is a OG member
    /// + checks if the nomination has been already submitted
    /// + checks if the user has nominated themselves to a different house before
    /// + checks if the nomination period is active
    #[payable]
    pub fn self_nominate(
        &mut self,
        house: HouseType,
        #[allow(unused_variables)] comment: String,
        #[allow(unused_variables)] link: Option<String>,
    ) -> Promise {
        self.assert_active();
        let nominee = env::predecessor_account_id();

        require!(
            self.nominations.get(&nominee).is_none(),
            "user has already an active self-nomination",
        );
        require!(
            env::prepaid_gas() >= GAS_NOMINATE,
            format!("not enough gas, min: {:?}", GAS_NOMINATE)
        );
        require!(
            env::attached_deposit() >= NOMINATE_COST,
            format!("not enough deposit, min: {:?}", NOMINATE_COST)
        );

        // Call SBT registry to verif OG SBT and cast the nomination in callback based on the return from sbt_tokens_by_owner
        ext_sbtreg::ext(self.sbt_registry.clone())
            .sbt_tokens_by_owner(
                nominee.clone(),
                Some(self.og_sbt.0.clone()),
                Some(self.og_sbt.1),
                Some(1),
                Some(false),
            )
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_NOMINATE)
                    .on_nominate_verified(nominee, house),
            )
    }

    /// Upvote method allows users to upvote a specific candidante
    /// + checks if the caller is a verified human
    /// + checks if there is a nomination for the given candidate
    /// + checks if the nomination period is active
    #[payable]
    pub fn upvote(&mut self, candidate: AccountId) -> Promise {
        self.assert_active();
        let upvoter = env::predecessor_account_id();

        require!(upvoter != candidate, "cannot upvote your own nomination");
        require!(
            self.nominations.get(&candidate).is_some(),
            "nomination not found",
        );
        require!(
            env::prepaid_gas() >= GAS_UPVOTE,
            format!("not enough gas, min: {:?}", GAS_UPVOTE)
        );
        require!(
            env::attached_deposit() >= UPVOTE_COST,
            format!("not enough deposit, min: {:?}", UPVOTE_COST)
        );

        // Call SBT registry to verify IAH and cast the upvote in callback
        ext_sbtreg::ext(self.sbt_registry.clone())
            .is_human(upvoter.clone())
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_UPVOTE)
                    .on_upvote_verified(candidate, upvoter),
            )
    }

    /// Comment enables users to comment on a existing nomination
    /// + checks if the caller is a verified human
    /// + checks if there is a nomination for the given candidate
    /// + checks if the nomination period is active
    pub fn comment(
        &mut self,
        candidate: AccountId,
        #[allow(unused_variables)] comment: String,
    ) -> Promise {
        self.assert_active();
        let commenter = env::predecessor_account_id();
        require!(
            self.nominations.get(&candidate).is_some(),
            "nomination not found",
        );
        require!(
            env::prepaid_gas() >= GAS_COMMENT,
            format!("not enough gas, min: {:?}", GAS_COMMENT)
        );

        // call SBT registry to verify IAH
        ext_sbtreg::ext(self.sbt_registry.clone())
            .is_human(commenter)
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_NOMINATE)
                    .on_comment_verified(),
            )
    }

    /// Instruments in the indexer to remove a comment.
    /// Caller must be an author of the comment (must be checked by the indexer).
    pub fn remove_comment(&mut self, comment: u64) {
        self.assert_active();
        require!(comment < self.next_comment_id, "invalid comment ID");
        // we don't record commetns, so additional authorization must happen in the indexer.
    }

    /// Revokes callers nominatnion
    /// + checks if the nomination period is active
    /// + checks if the user has a nomination to revoke
    pub fn self_revoke(&mut self) {
        self.assert_active();
        let nominee = env::predecessor_account_id();

        require!(
            self.nominations.get(&nominee).is_some(),
            "user is not nominated, cannot revoke",
        );

        self.nominations.remove(&nominee);
    }

    /// Removes the upvote
    /// + checks if the nomination period is active
    /// + checks if the caller upvoted the `candidate` before
    pub fn remove_upvote(&mut self, candidate: AccountId) {
        self.assert_active();
        let caller = env::predecessor_account_id();
        let mut n = self
            .nominations
            .get(&candidate)
            .expect("not a valid candidate");

        match self.upvotes.remove(&(candidate.clone(), caller)) {
            None => panic_str("upvote doesn't exist"),
            Some(t) => require!(n.timestamp <= t, "upvote not valid, candidate revoked"),
        }
        n.upvotes -= 1;
        self.nominations.insert(&candidate, &n);
    }

    /*****************
     * ADMIN
     ****************/

    /// Admin: set new end_time, must be in miliseconds.
    pub fn update_end_time(&mut self, end_time: u64) {
        require!(
            self.admins
                .get()
                .unwrap()
                .contains(&env::predecessor_account_id()),
            "not authorized"
        );
        self.end_time = end_time;
    }

    /*****************
     * PRIVATE
     ****************/

    /// Callback for upvote
    /// + checks if the upvoter is a verified human
    /// + checks if the caller has already upvoted the candidate
    /// if both of the checks passed registers the upvote otherwise panics
    #[private]
    pub fn on_upvote_verified(
        &mut self,
        #[callback_unwrap] tokens: Vec<(AccountId, Vec<TokenId>)>,
        candidate: AccountId,
        upvoter: AccountId,
    ) {
        require!(
            !tokens.is_empty(),
            "not a verified human member, or the tokens are expired"
        );
        let mut n = self
            .nominations
            .get(&candidate)
            .expect("not a valid candidate");
        n.upvotes += 1;
        self.nominations.insert(&candidate, &n);
        if let Some(t) = self
            .upvotes
            .insert(&(candidate, upvoter), &env::block_timestamp_ms())
        {
            require!(t < n.timestamp, "nomination already upvoted");
        }
    }

    /// Callback for comment. Returns comment ID (used to track comment removal).
    /// + checks if the commenter is a verified human otherwise panics
    #[private]
    pub fn on_comment_verified(
        &mut self,
        #[callback_unwrap] tokens: Vec<(AccountId, Vec<TokenId>)>,
    ) -> u64 {
        require!(
            !tokens.is_empty(),
            "not a verified human member, or the tokens are expired"
        );
        let id = self.next_comment_id;
        self.next_comment_id += 1;
        id
        // we don't record comment - they are handled by the indexer.
    }

    /// Callback for self_nominate
    /// + checks if the caller is a OG token holder
    /// + checks if user has already submitted a nomination
    /// If checks pass registers the nomination otherwise panics
    #[private]
    pub fn on_nominate_verified(
        &mut self,
        #[callback_unwrap] sbts: Vec<(AccountId, Vec<OwnedToken>)>,
        nominee: AccountId,
        house_type: HouseType,
    ) {
        require!(
            !sbts.is_empty() && sbts[0].1[0].metadata.class == self.og_sbt.1,
            "not a verified OG member, or the token is expired",
        );

        let n = Nomination {
            house: house_type,
            timestamp: env::block_timestamp_ms(),
            upvotes: 0,
        };
        require!(
            self.nominations.insert(&nominee, &n).is_none(),
            "user has already nominated themselves",
        );
    }

    fn assert_active(&self) {
        let current_timestamp = env::block_timestamp_ms();
        require!(
            self.start_time < current_timestamp && current_timestamp <= self.end_time,
            "nominations are not active"
        );
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use std::ops::Sub;

    use near_sdk::{test_utils::VMContextBuilder, testing_env, AccountId, Gas, VMContext};

    use super::*;

    // time in seconds
    const START: u64 = 1700000000;
    const END: u64 = 1800000000;
    const SEC_TO_MS: u64 = 1_000;
    const OG_CLASS_ID: u64 = 2;

    fn alice() -> AccountId {
        AccountId::new_unchecked("alice.near".to_string())
    }

    fn bob() -> AccountId {
        AccountId::new_unchecked("bob.near".to_string())
    }

    fn candidate(idx: u32) -> AccountId {
        AccountId::new_unchecked(format!("candidate{}.near", idx))
    }

    fn admin() -> AccountId {
        AccountId::new_unchecked("admin.near".to_string())
    }

    fn sbt_registry() -> AccountId {
        AccountId::new_unchecked("sbt_registry.near".to_string())
    }

    fn og_token_issuer() -> AccountId {
        AccountId::new_unchecked("og.near".to_string())
    }

    fn mk_nomination(house: HouseType, timestamp: u64) -> Nomination {
        Nomination {
            house,
            timestamp: timestamp * SEC_TO_MS,
            upvotes: 0,
        }
    }

    /// creates and inserts default nomination
    fn insert_nomination(ctr: &mut Contract, candidate: AccountId, house: Option<HouseType>) {
        let house = house.unwrap_or(HouseType::CouncilOfAdvisors);
        ctr.nominations
            .insert(&candidate, &mk_nomination(house, START));
    }

    /// inserts a upvote for a specified candidate
    fn insert_upvote(ctr: &mut Contract, upvoter: AccountId, candidate: AccountId) {
        ctr.upvotes
            .insert(&(candidate.clone(), upvoter), &((START + 10) * SEC_TO_MS));
        let mut nomination = ctr
            .nominations
            .get(&candidate)
            .expect("Nomination not found");
        nomination.upvotes += 1;
        ctr.nominations.insert(&candidate, &nomination);
    }

    fn setup(predecessor: &AccountId) -> (VMContext, Contract) {
        let mut ctx = VMContextBuilder::new()
            .predecessor_account_id(admin())
            // .attached_deposit(deposit_dec.into())
            .block_timestamp((START - 1) * SECOND)
            .is_view(false)
            .build();
        testing_env!(ctx.clone());
        let ctr = Contract::new(
            sbt_registry(),
            (og_token_issuer(), OG_CLASS_ID),
            vec![admin()],
            START * SEC_TO_MS,
            END * SEC_TO_MS,
        );
        ctx.block_timestamp = (START + 1) * SECOND;
        ctx.predecessor_account_id = predecessor.clone();
        testing_env!(ctx.clone());
        (ctx, ctr)
    }

    #[test]
    fn assert_active() {
        let (_, ctr) = setup(&admin());
        ctr.assert_active();
        let at = ctr.active_time();
        assert_eq!(at, (START * SEC_TO_MS, END * SEC_TO_MS));
    }

    #[test]
    #[should_panic(expected = "nominations are not active")]
    fn assert_active_too_early() {
        let (mut ctx, ctr) = setup(&alice());
        ctx.block_timestamp = (START - 5) * SECOND;
        testing_env!(ctx);
        ctr.assert_active();
    }

    #[test]
    #[should_panic(expected = "nominations are not active")]
    fn assert_active_too_late() {
        let (mut ctx, ctr) = setup(&alice());
        ctx.block_timestamp = (END + 5) * SECOND;
        testing_env!(ctx);
        ctr.assert_active();
    }

    #[test]
    #[should_panic(expected = "user has already an active self-nomination")]
    fn self_nominate_already_nominated() {
        let (_, mut ctr) = setup(&alice());
        insert_nomination(&mut ctr, alice(), None);
        ctr.self_nominate(HouseType::HouseOfMerit, String::from("test"), None);
    }

    #[test]
    #[should_panic(expected = "not enough gas, min: Gas(20000000000000)")]
    fn self_nominate_wrong_gas() {
        let (mut ctx, mut ctr) = setup(&alice());
        ctx.prepaid_gas = GAS_NOMINATE.sub(Gas(10));
        testing_env!(ctx);
        ctr.self_nominate(HouseType::HouseOfMerit, String::from("test"), None);
    }

    #[test]
    #[should_panic(expected = "not enough deposit, min: 1000000000000000000000")]
    fn self_nominate_wrong_deposit() {
        let (_, mut ctr) = setup(&alice());
        ctr.self_nominate(HouseType::HouseOfMerit, String::from("test"), None);
    }

    #[test]
    #[should_panic(expected = "nominations are not active")]
    fn self_nominate_not_active() {
        let (mut ctx, mut ctr) = setup(&alice());
        ctx.block_timestamp = (START - 5) * SECOND;
        testing_env!(ctx);
        ctr.self_nominate(HouseType::HouseOfMerit, String::from("test"), None);
    }

    #[test]
    fn self_nominate() {
        let (mut ctx, mut ctr) = setup(&alice());
        ctx.attached_deposit = NOMINATE_COST;
        testing_env!(ctx);
        ctr.self_nominate(HouseType::HouseOfMerit, String::from("test"), None);
    }

    #[test]
    #[should_panic(expected = "cannot upvote your own nomination")]
    fn upvote_self_upvote() {
        let (_, mut ctr) = setup(&alice());
        insert_nomination(&mut ctr, alice(), None);
        ctr.upvote(alice());
    }

    #[test]
    #[should_panic(expected = "nomination not found")]
    fn upvote_nomination_not_found() {
        let (_, mut ctr) = setup(&bob());
        ctr.upvote(alice());
    }

    #[test]
    #[should_panic(expected = "nomination not found")]
    fn upvote_after_revoke() {
        let (mut ctx, mut ctr) = setup(&alice());
        insert_nomination(&mut ctr, alice(), None);
        ctr.self_revoke();

        ctx.predecessor_account_id = bob();
        testing_env!(ctx);
        ctr.upvote(alice());
    }

    #[test]
    #[should_panic(expected = "not enough gas, min: Gas(20000000000000)")]
    fn upvote_wrong_gas() {
        let (mut ctx, mut ctr) = setup(&bob());
        insert_nomination(&mut ctr, alice(), None);
        ctx.prepaid_gas = GAS_UPVOTE.sub(Gas(10));
        testing_env!(ctx);
        ctr.upvote(alice());
    }

    #[test]
    #[should_panic(expected = "not enough deposit, min: 1000000000000000000000")]
    fn upvote_wrong_deposit() {
        let (_, mut ctr) = setup(&bob());
        insert_nomination(&mut ctr, alice(), None);
        ctr.upvote(alice());
    }

    #[test]
    fn upvote() {
        let (mut ctx, mut ctr) = setup(&bob());
        ctx.attached_deposit = UPVOTE_COST;
        testing_env!(ctx);

        insert_nomination(&mut ctr, alice(), None);
        ctr.upvote(alice());
    }

    #[test]
    #[should_panic(expected = "nomination not found")]
    fn comment_nomination_not_found() {
        let (_, mut ctr) = setup(&bob());
        ctr.comment(alice(), String::from("test"));
    }

    #[test]
    #[should_panic(expected = "not enough gas, min: Gas(20000000000000)")]
    fn comment_wrong_gas() {
        let (mut ctx, mut ctr) = setup(&bob());
        ctx.prepaid_gas = GAS_COMMENT.sub(Gas(10));
        testing_env!(ctx);
        insert_nomination(&mut ctr, alice(), None);
        ctr.comment(alice(), String::from("test"));
    }

    #[test]
    fn comment() {
        let (_, mut ctr) = setup(&bob());
        insert_nomination(&mut ctr, alice(), None);
        ctr.comment(alice(), String::from("test"));
    }

    #[test]
    #[should_panic(expected = "user is not nominated, cannot revoke")]
    fn self_revoke_nomination_not_found() {
        let (_, mut ctr) = setup(&alice());
        ctr.self_revoke();
    }

    #[test]
    fn self_revoke() {
        let (mut ctx, mut ctr) = setup(&bob());
        insert_nomination(&mut ctr, alice(), None);
        assert!(ctr.nominations.len() == 1);
        ctx.predecessor_account_id = alice();
        testing_env!(ctx);
        ctr.self_revoke();
        assert!(ctr.nominations.is_empty());
    }

    #[test]
    #[should_panic(expected = "upvote doesn't exist")]
    fn remove_upvote_no_upvote() {
        let (_, mut ctr) = setup(&bob());
        insert_nomination(&mut ctr, alice(), None);
        ctr.remove_upvote(alice());
    }

    #[test]
    fn remove_upvote() {
        let (_, mut ctr) = setup(&bob());

        // add a nomination and upvote it
        insert_nomination(&mut ctr, candidate(1), None);
        insert_upvote(&mut ctr, bob(), candidate(1));
        assert!(ctr.nominations.len() == 1);
        assert!(ctr.nominations.get(&candidate(1)).unwrap().upvotes == 1);
        assert!(ctr.upvotes.contains_key(&(candidate(1), bob())));

        // remove the upvote
        ctr.remove_upvote(candidate(1));

        // check all the values are updated correctly
        assert!(ctr.nominations.len() == 1);
        assert!(ctr.nominations.get(&candidate(1)).unwrap().upvotes == 0);
        assert!(!ctr.upvotes.contains_key(&(candidate(1), bob())));
    }

    #[test]
    fn nominations() {
        let (_, mut ctr) = setup(&bob());
        let upvotes_candidate_1 = 3;
        let upvotes_candidate_2 = 1;
        let upvotes_candidate_3 = 0;

        // add 3 nominations
        insert_nomination(&mut ctr, candidate(1), Some(HouseType::CouncilOfAdvisors));
        insert_nomination(&mut ctr, candidate(2), Some(HouseType::CouncilOfAdvisors));
        insert_nomination(&mut ctr, candidate(3), Some(HouseType::HouseOfMerit));
        // upvote candidate
        insert_upvote(&mut ctr, candidate(2), candidate(1));
        insert_upvote(&mut ctr, candidate(3), candidate(1));
        insert_upvote(&mut ctr, candidate(4), candidate(1));
        insert_upvote(&mut ctr, candidate(4), candidate(2));

        // query nominations for CouncilOfAdvisord
        let counsil_of_advisors = ctr.nominations(HouseType::CouncilOfAdvisors);
        assert!(counsil_of_advisors.len() == 2);
        assert!(counsil_of_advisors[0].0 == candidate(1));
        assert!(counsil_of_advisors[0].1 == upvotes_candidate_1);
        assert!(counsil_of_advisors[1].0 == candidate(2));
        assert!(counsil_of_advisors[1].1 == upvotes_candidate_2);

        // query nominations for HouseOfMerit
        let counsil_of_advisors = ctr.nominations(HouseType::HouseOfMerit);
        assert!(counsil_of_advisors.len() == 1);
        assert!(counsil_of_advisors[0].0 == candidate(3));
        assert!(counsil_of_advisors[0].1 == upvotes_candidate_3);
    }

    #[test]
    #[should_panic(expected = "invalid comment ID")]
    fn remove_comment_wrong_comment_id() {
        let (_, mut ctr) = setup(&bob());
        ctr.remove_comment(1);
    }

    #[test]
    fn remove_comment() {
        let (_, mut ctr) = setup(&bob());
        ctr.next_comment_id += 1;
        ctr.remove_comment(0);
        // we cannot check the removal of the comment (this is handled by the indexer).
    }
}

'''
'''--- nominations/src/storage.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::BorshStorageKey;

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    Nominations,
    Upvotes,
    Admins,
}

/// nomination struct
#[derive(BorshDeserialize, BorshSerialize)]
pub struct Nomination {
    pub house: HouseType,
    /// timestamp in ms
    pub timestamp: u64,
    /// sum of received upvotes
    pub upvotes: u32,
}

/// house type struct
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(test, derive(Debug))]
pub enum HouseType {
    HouseOfMerit,
    CouncilOfAdvisors,
    TransparencyCommission,
}

'''
'''--- nominations/tests/workspaces.rs ---
use integrations::setup_registry;
use ndc_nominations::{storage::HouseType, TokenMetadata, MSECOND};
use near_units::parse_near;
use near_workspaces::{Account, Contract, DevNetwork, Worker};
use serde_json::json;

// multiplayer from sec to millisecond
const SEC_TO_MS: u64 = 1_000;

async fn init(
    worker: &Worker<impl DevNetwork>,
) -> anyhow::Result<(Contract, Account, Account, Account, Account)> {
    // deploy contracts
    let ndc_nominations_contract = worker
        .dev_deploy(include_bytes!("../../res/ndc_nominations.wasm"))
        .await?;

    let admin = worker.dev_create_account().await?;
    let auth_flagger = worker.dev_create_account().await?;
    let iah_issuer = worker.dev_create_account().await?;
    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;
    let john = worker.dev_create_account().await?;
    let elon = worker.dev_create_account().await?;

    // get current block time
    let block_info = worker.view_block().await?;
    let current_timestamp_ms = block_info.timestamp() / MSECOND;
    let end_time = current_timestamp_ms + (60 * SEC_TO_MS);

    let registry_contract = setup_registry(
        worker,
        admin.clone(),
        auth_flagger,
        iah_issuer.clone(),
        vec![],
    )
    .await?;

    // initialize contracts
    let res  = ndc_nominations_contract
        .call("new")
        .args_json(json!({"sbt_registry": registry_contract.id(),"og_sbt": (iah_issuer.id(),2), "admins": [admin.id()], "start_time": 0, "end_time": end_time}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    // mint IAH and OG sbt to alice
    let alice_tokens = vec![
        TokenMetadata {
            class: 1,
            issued_at: Some(0),
            expires_at: None,
            reference: None,
            reference_hash: None,
        },
        TokenMetadata {
            class: 2,
            issued_at: Some(0),
            expires_at: None,
            reference: None,
            reference_hash: None,
        },
    ];

    // mint only IAH to bob
    let bob_tokens = vec![TokenMetadata {
        class: 1,
        issued_at: Some(0),
        expires_at: Some(end_time),
        reference: None,
        reference_hash: None,
    }];

    // mint only OG to john
    let john_tokens = vec![TokenMetadata {
        class: 2,
        issued_at: Some(0),
        expires_at: Some(end_time),
        reference: None,
        reference_hash: None,
    }];

    // mint expired OG and expired IAH to elon
    let elon_tokens = vec![
        TokenMetadata {
            class: 2,
            issued_at: Some(0),
            expires_at: Some(10),
            reference: None,
            reference_hash: None,
        },
        TokenMetadata {
            class: 1,
            issued_at: Some(0),
            expires_at: Some(10),
            reference: None,
            reference_hash: None,
        },
    ];

    let token_spec = vec![
        (alice.id(), alice_tokens),
        (bob.id(), bob_tokens),
        (john.id(), john_tokens),
        (elon.id(), elon_tokens),
    ];

    let res = iah_issuer
        .call(registry_contract.id(), "sbt_mint")
        .args_json(json!({ "token_spec": token_spec }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    Ok((ndc_nominations_contract, alice, bob, john, elon))
}

#[tokio::test]
async fn self_nominate() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, alice, _, _, _) = init(&worker).await?;

    // self nominate
    let res = alice
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    println!("Passed âœ… self_nominate");
    Ok(())
}

#[tokio::test]
async fn self_nominate_only_og() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, _, _, john, _) = init(&worker).await?;

    // self nominate
    let res = john
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    Ok(())
}

#[tokio::test]
async fn self_nominate_only_iah_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, _, bob, _, _) = init(&worker).await?;

    // self nominate
    let res = bob
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await;
    assert!(format!("{:?}", res).contains("not a verified OG member, or the token is expired"));

    println!("Passed âœ… self_nominate_only_iah_fail");
    Ok(())
}

#[tokio::test]
async fn self_nominate_expired_token_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, _, _, _, elon) = init(&worker).await?;

    // self nominate
    let res = elon
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await;
    assert!(format!("{:?}", res).contains("not a verified OG member, or the token is expired"));

    println!("Passed âœ… self_nominate_expired_token_fail");
    Ok(())
}

#[tokio::test]
async fn upvote() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, alice, bob, john, _) = init(&worker).await?;

    // self nominate
    let res = john
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // upvote johns nomination
    let res = bob
        .call(ndc_elections_contract.id(), "upvote")
        .args_json(json!({"candidate": john.id(),}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    let res: Vec<(String, u32)> = ndc_elections_contract
        .view("nominations")
        .args_json(json!({ "house": HouseType::HouseOfMerit }))
        .await?
        .json()?;
    assert_eq!(res, vec![(john.id().as_str().to_owned(), 1)]);

    // another upvote
    let res = alice
        .call(ndc_elections_contract.id(), "upvote")
        .args_json(json!({"candidate": john.id(),}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    let res: Vec<(String, u32)> = ndc_elections_contract
        .view("nominations")
        .args_json(json!({ "house": HouseType::HouseOfMerit }))
        .await?
        .json()?;
    assert_eq!(res, vec![(john.id().as_str().to_owned(), 2)]);

    println!("Passed âœ… upvote");
    Ok(())
}

#[tokio::test]
async fn double_upvote_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, _, bob, john, _) = init(&worker).await?;

    // self nominate
    let res = john
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // upvote johns nomination
    let res = bob
        .call(ndc_elections_contract.id(), "upvote")
        .args_json(json!({"candidate": john.id(),}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // double upvote
    let res = bob
        .call(ndc_elections_contract.id(), "upvote")
        .args_json(json!({"candidate": john.id(),}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await;
    assert!(format!("{:?}", res).contains("nomination already upvoted"));

    println!("Passed âœ… double_upvote_fail");
    Ok(())
}

#[tokio::test]
async fn upvote_by_non_human_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, alice, _, john, _) = init(&worker).await?;

    // self nominate
    let res = alice
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // john not iah upvotes alice nomination
    let res = john
        .call(ndc_elections_contract.id(), "upvote")
        .args_json(json!({"candidate": alice.id(),}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await;
    assert!(format!("{:?}", res).contains("not a verified human member, or the tokens are expired"));

    println!("Passed âœ… upvote_by_non_human");
    Ok(())
}

#[tokio::test]
async fn upvote_expired_iah_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, alice, _, _, elon) = init(&worker).await?;

    // self nominate
    let res = alice
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // john not iah upvotes alice nomination
    let res = elon
        .call(ndc_elections_contract.id(), "upvote")
        .args_json(json!({"candidate": alice.id(),}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await;
    assert!(format!("{:?}", res).contains("not a verified human member, or the tokens are expired"));

    println!("Passed âœ… upvote_by_non_human");
    Ok(())
}

#[tokio::test]
async fn comment() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, _, bob, john, _) = init(&worker).await?;

    // self nominate
    let res = john
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // upvote johns nomination
    let res = bob
        .call(ndc_elections_contract.id(), "comment")
        .args_json(json!({"candidate": john.id(), "comment": "solid candidate",}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    println!("Passed âœ… comment ");
    Ok(())
}

#[tokio::test]
async fn comment_by_non_human_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, alice, _, john, _) = init(&worker).await?;

    // self nominate
    let res = alice
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // john not iah upvotes alice nomination
    let res = john
        .call(ndc_elections_contract.id(), "comment")
        .args_json(json!({"candidate": alice.id(),"comment": "solid candidate"}))
        .max_gas()
        .transact()
        .await;
    assert!(format!("{:?}", res).contains("not a verified human member, or the tokens are expired"));

    println!("Passed âœ… comment_by_non_human");
    Ok(())
}

#[tokio::test]
async fn comment_expired_iah_fail() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, alice, _, _, elon) = init(&worker).await?;

    // self nominate
    let res = alice
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // john not iah upvotes alice nomination
    let res = elon
        .call(ndc_elections_contract.id(), "comment")
        .args_json(json!({"candidate": alice.id(),"comment": "solid candidate"}))
        .max_gas()
        .transact()
        .await;
    assert!(format!("{:?}", res).contains("not a verified human member, or the tokens are expired"));

    println!("Passed âœ… comment_expired_iah_fail");
    Ok(())
}

#[tokio::test]
async fn flow1() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, _, bob, john, _) = init(&worker).await?;

    // self nominate
    let res = john
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // upvote johns nomination
    let res = bob
        .call(ndc_elections_contract.id(), "upvote")
        .args_json(json!({"candidate": john.id(),}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // self revoke
    let res = john
        .call(ndc_elections_contract.id(), "self_revoke")
        .args_json(json!({}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // self nominate to a different house
    let res = john
     .call(ndc_elections_contract.id(), "self_nominate")
     .args_json(json!({"house": HouseType::CouncilOfAdvisors, "comment": "solid nomination", "link": "external_link.io"}))
     .max_gas()
     .deposit(parse_near!("1 N"))
     .transact()
     .await?;
    assert!(res.is_success());

    // upvote johns new nomination
    let res = bob
        .call(ndc_elections_contract.id(), "upvote")
        .args_json(json!({"candidate": john.id(),}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    println!("Passed âœ… flow1");
    Ok(())
}

#[tokio::test]
async fn remove_upvote_upvote_again() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let (ndc_elections_contract, _, bob, john, _) = init(&worker).await?;

    // self nominate
    let res = john
        .call(ndc_elections_contract.id(), "self_nominate")
        .args_json(json!({"house": HouseType::HouseOfMerit, "comment": "solid nomination", "link": "external_link.io"}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // upvote johns nomination
    let res = bob
        .call(ndc_elections_contract.id(), "upvote")
        .args_json(json!({"candidate": john.id(),}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    // remove upvote
    let res = bob
        .call(ndc_elections_contract.id(), "remove_upvote")
        .args_json(json!({"candidate": john.id(),}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    // upvote again

    // upvote johns nomination
    let res = bob
        .call(ndc_elections_contract.id(), "upvote")
        .args_json(json!({"candidate": john.id(),}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
    assert!(res.is_success());

    println!("Passed âœ… remove_upvote_upvote_again");
    Ok(())
}

'''
'''--- rust-toolchain.toml ---
[toolchain]
channel = "1.75.0"
components = ["rustfmt"]
targets = ["wasm32-unknown-unknown"]

'''
'''--- voting_body/CHANGELOG.md ---
<!-- markdownlint-disable MD013 -->
<!-- markdownlint-disable MD024 -->

<!--
Changelogs are for humans, not machines.
There should be an entry for every single version.
The same types of changes should be grouped.
The latest version comes first.
The release date of each version is displayed.

Usage:

Change log entries are to be added to the Unreleased section. Example entry:

* [#<PR-number>](https://github.com/umee-network/umee/pull/<PR-number>) <description>

-->

# CHANGELOG

## Unreleased

### Features

### Breaking changes

### Bug Fixes

## v1.1.0 (2023-11-14)

### Features

- New proposal type: `TextSuper` - used for text proposals that require Near Supermajority Consent.

### Bug Fixes

- `PropKind::ApproveBudget` requires simple Near Consent (not Near Supermajority Consent as it was done before).

## v1.0.1 (2023-11-08)

### Breaking changes

- Rename and change `REMOVE_REWARD = 1N` to `SLASH_REWARD = 0.9N`

## v1.0.0 (2023-11-07)

'''
'''--- voting_body/Cargo.toml ---
[package]
name = "voting_body"
version = "1.1.0"
authors = { workspace = true }
edition = { workspace = true }
repository = { workspace = true }
license = { workspace = true }

[lib]
# rlib is needed for integration tests
crate-type = ["cdylib", "rlib"]

[dependencies]
uint.workspace = true
near-sdk.workspace = true
serde_json.workspace = true
itertools.workspace = true

common = { path = "../common" }
congress = { path = "../congress" }

[dev-dependencies]
anyhow.workspace = true
tokio.workspace = true
near-workspaces.workspace = true
near-primitives.workspace = true
near-units.workspace = true
integrations = { path = "../integrations" }

'''
'''--- voting_body/README.md ---
# Voting Body

- [Diagrams](https://miro.com/app/board/uXjVMqJRr_U=/)
- [Framework Specification](https://www.notion.so/NDC-V1-Framework-V3-2-Updated-1af84fe7cc204087be70ea7ffee4d23f)

Voting Body is governance structure of all non-blacklisted human participants in the NEAR Ecosystem. There are no requirements for being a member of the voting body beyond completing â€˜I am Humanâ€™ and not being on the blacklist.

Deployed Contracts

- mainnet: `voting-body-v1.ndc-gwg.near`
- testnet: `voting-body-v1.gwg.testnet`, IAH registry: `registry-unstable-v2.i-am-human.testnet`

## Contract Parameters

- `quorum`: a minimum amount of members that need to vote to approve a proposal.
- `pre_vote_support`: minimum amount of support, a proposal has to receive in order to move it to the active queue, where users can vote to approve a proposal.
- `pre_vote_duration`: max amount of time, users can express support to move a proposal to the active queue, before it will be removed.
- `pre_vote_bond`: amount of N required to add a proposal to the pre-vote queue.
- `active_queue_bond`: amount of N required to move a proposal directly to the active queue.
- `vote_duration`: max amount of time a proposal can be active in the active queue. If a proposal didn't get enough approvals by that time, it will be removed and bond returned.

You can query the parameters with:

```shell
near view VOTING_BODY config ''
```

## Creating proposals

Every human can create a proposal. The proposals are organized in 2 queues (pre-vote queue and active queue) in order to filter out spam proposals.
When creating a proposal, the submitter must stake a bond. If `pre-vote bond` is attached, then the proposal goes to the pre-vote queue. If `active_queue_bond` is attached then the proposal goes directly to active queue (_fast track_ - no need for getting a pre-vote support, but the proposer takes a responsibility of being slashed if the proposal is marked as spam).

Proposal can only be created by an IAH verified account. We use `is_human_call` method. Example call:

```shell
near call IAH_REGISTRY is_human_call \
  '{"ctr": "VB.near", "function": "create_proposal", "payload": "{\"kind\": {\"Veto\": {\"dao\": \"hom.near\", \"prop_id\": 12}}, \"description\": \"this proposal is against the budget objectives\"}"}' \
  --accountId YOU \
  --depositYocto $pre_vote_bond

# Creating a text proposal with with a active_queue_bond (making it automatically advancing to the active queue)
near call IAH_REGISTRY  is_human_call \
  '{"ctr": "VB.near", "function": "create_proposal", "payload": "{\"kind\": \"Text\", \"description\": \"lets go\"}"}' \
  --accountId YOU --deposit $active_queue_bond
```

### Pre-vote queue

Proposals in this queue are not active. VB members can't vote for proposals in the pre-vote queue and UI doesn't display them by default. Instead, members can send a _pre_vote_support_ transaction. There are 3 ways to move a proposal to the active queue:

- get `pre_vote_support` support transactions from VB members;
- top up with more NEAR to reach `active_queue_bond`;
- get a support by one of the Congress members using `support_proposal_by_congress` method.

Note: originally only a congress support was required to move a proposal to the active queue. However, that creates a strong subjectivity and censorship (example: VB wants to dismiss a house - obviously house may not be happy and not "support" such a proposal).

Voting Body Support can only be made by an IAH verified account. We use `is_human_call_lock` method, which will lock the caller for soul transfers, to avoid double support. Example call:

```shell
lock_duration=pre_vote_duration+1
near call IAH_REGISTRY is_human_call_lock \
  '{"ctr": "VB.near", "function": "support_proposal", "payload": "1", "lock_duration": '$lock_duration', "with_proof": false}' \
  --accountId YOU
```

### Active queue

Proposals in this queue are eligible for voting and displayed by the default in the UI. Proposals from the active queue are not removed unless they are marked as spam (more about it in the voting section). They are preserved and anyone can query them, even when a proposal was rejected.

When a proposal is moved from the pre-vote queue to the active queue, the set of accounts that supported the proposal is cleared - it's not needed any more. We can save the space and proposal load time.

```mermaid
---
title: Proposal Queues
---
flowchart TB
    PVQ[pre-vote queue]
    AVQ[active queue]
    Trash(Proposal burned)

    Proposal-- stake \npre-vote bond -->PVQ
    Proposal-- stake \nactive queue bond-->AVQ
    PVQ-- top up bond -->AVQ
    PVQ-- receive \n#pre-vote support -->AVQ
    PVQ-- get a support from a \nCongress member -->AVQ
    PVQ-- timeout -->Trash
```

### Proposal Types

There are several types of proposals with specific functionalities and limitations:

1. **Dismiss Proposal**

   - Arguments: `dao`: `AccountId`, `member`: `AccountId`
   - Description: This proposal calls the `Dismiss` hook in the provided DAO when executed, resulting in the removal of the specified member.

2. **Dissolve Proposal**

   - Arguments: `dao`: `AccountId`
   - Description: Executing this proposal triggers the `Dissolve` hook in the provided DAO, dissolving the DAO itself.

3. **Veto Proposal**

   - Arguments: `dao`: `AccountId`, `prop_id`: `u32`
   - Description: When executed, this proposal invokes the `Veto` hook in the provided DAO and vetoes the proposal identified by the specified `prop_id`.

4. **Approve Budget Proposal**

   - Arguments: `dao`: `AccountId`, `prop_id`: `u32`
   - Description: This type of proposal serves as an approval mechanism for budget proposals without making any method calls.

5. **Text Proposal**

   - Description: A text proposal for general purposes, without specific arguments. It doesn't involve any method calls.

6. **TextSuper Proposal**

   - Description: same as `Text` proposal, but requires Near Supermajority Consent to approve.

7. **FunctionCall Proposal**

   - Arguments: `receiver_id`: `AccountId`, `actions`: `Vec<ActionCall>`
   - Description: This proposal enables you to call the `receiver_id` with a list of method names in a single promise. It allows your contract to execute various actions in other contracts, excluding congress contracts. Attempting to create a proposal that calls any congress DAOs will result in an error, preventing the proposal from being created.

8. **UpdateBonds**

   - Arguments: `pre_vote_bond: U128`, `active_queue_bond: U128`
   - Description: allows VB to update contract configuration.

9. **UpdateVoteDuration**

   - Arguments: `pre_vote_duration: u64`, `vote_duration: u64`
   - Description: allows VB to update contract configuration.

## Proposal Lifecycle

```mermaid
---
title: Possible Proposal Status Flows
---
flowchart TB
    Trash([Trash])
    PreVote --> InProgress
    InProgress --> Approved
    InProgress --> Rejected
    InProgress --> Spam
    Approved --> Executed
    Executed -- tx fail --> Failed
    Failed -- re-execute --> Executed

    PreVote -- slashed --> Trash
    Spam -- slashed --> Trash
```

When proposal is created, but the creator doesn't deposit `active_queue_bond` immediately, then the status of a proposal is `PreVote`.
A proposal that doesn't advance to the active queue by the `pre_vote_duration` is eligible for slashing. In such case, any account can call `slash_prevote_proposal(id)` method: the proposal will be removed, `SLASH_REWARD` will be transferred (as in incentive) to the caller and the remainder bond will be sent to the community fund.

Proposal, that is moved to the active queue has status `InProgress` and keeps that status until the voting period is over (`proposal.start_time + vote_duration`). During that time all Members can vote for the proposal.

Once the voting period is over, a proposal will have `Approved`, `Rejected` or `Spam` status, based on the voting result.
During this time, anyone can call `execute(id)`. Note these statuses are only visible when we query a proposal and: a) voting is over b) and was not executed. Executing a proposal will set the `proposal.executed_at` property to the current time in milliseconds and will have the following effects:

- Approved: bonds are returned. If a proposal involves a function call, then the call is scheduled. If the call fails, the proposal will have status `Failed` and anyone will be able to re-execute it again.
- Rejected: bonds are removed, and proposal won't be able to be re-executed.
- Spam: executor will receive a `SLASH_REWARD`, and the proposal will be slashed: removed, and the remaining bond (including the top-up) send to the community fund.

## Voting

Any VB member can vote on any _in progress_ proposal in the active queue. Voter can change his/her vote multiple times. Vote options:

- approve
- reject
- spam: strong conviction that the proposal is spam, should be removed and a deposit slashed.

A proposal voting is in progress when `now <= proposal.start_time + vote_duration`, where `proposal.start_time` is a time when the proposal is added to the active queue.

Syntax: #vote_type denotes number of votes of the specified type, eg: #approve means number of approve votes.

A proposal is **approved** when:

- voting time is over;
- AND consent is reached (quorum + threshold).

A proposal is marked as **spam** when:

- voting time is over;
- `#spam > #reject`;
- AND `#reject + #spam >= (1-threshold) * (#approve + #reject + #spam)`.

Spam proposals are removed, and the bond is slashed (sent to the community treasury).

A proposal is **rejected** if voting time is over (proposal is not in progress anymore), and it was not approved nor marked as spam.

Voting Body intentionally doesn't support optimistic execution, that is approving or rejecting a proposal once sufficient amount of votes are cast. We want to give a chance to every member vote and express their opinion providing more clear outcome of the voting.

Vote can only be made by an IAH verified account. We use `is_human_call_lock` method, which will lock the caller for soul transfers, to avoid double vote. Example call:

```shell
lock_duration=vote_duration+1  # minimum value is the time in milliseconds remaining to the voting end + 1.
near call IAH_REGISTRY is_human_call_lock \
  '{"ctr": "VB.near", "function": "vote", "payload": "{\"prop_id\": 3, \"vote\": \"Approve\"}", "lock_duration": '$lock_duration', "with_proof": false}' \
  --accountId YOU \
  --deposit 0.01 # used for vote storage, reminder will be returned.

near call VOTING_BODY get_vote \
  '{"id": 3, "voter": "YOU"}'
```

### Quorums and Thresholds

**Quorum** assures that enough of the VB members voted.
**Majority Threshold** assures that enough VB members approved a proposal. It is a fractional value. Proposal is approved when: `#approve > threshold * (#approve + #reject + #spam)`. It is either a simple majority or a super majority.

- **Near Consent:** quorum=(7% of the voting body) + **simple majority**=50%.
- **Near Supermajority Consent**: quorum=(12% of the voting body) + **super majority**=60%.

### Events

This smart contract emits several events to notify external systems or components about specific actions or state changes. Here's a breakdown of the events and the functions emitting them:

#### `proposal-create`

- **Description:** Emitted when a proposal is created.
- **Payload:**
  - `prop_id`: The ID of the created proposal.
  - `kind`: The kind of proposal.
  - `active`: Set to true if the proposal was added to an active queue directly.

Functions that invoke `emit_prop_created`: `create_proposal`.

#### `proposal-activate`

- **Description:** Emitted when a proposal is moved from pre-vote to the active queue.
- **Payload:**
  - `prop_id`: The ID of the activated proposal.

Functions that invoke `emit_prop_active`: `top_up_proposal`, `support_proposal`, `support_proposal_by_congress`.

#### `proposal-prevote-slash`

- **Description:** Emitted when a pre-vote proposal is removed and slashed for not getting enough support.
- **Payload:**
  - `prop_id`: The ID of the slashed pre-vote proposal.
  - `bond`: The bond amount being slashed (in `U128` format).

List of functions that invoke `emit_prevote_prop_slashed`: `top_up_proposal`, `slash_prevote_proposal`, `support_proposal`, `support_proposal_by_congress`.

#### `proposal-slash`

- **Description:** Emitted when a proposal is slashed.
- **Payload:**
  - `prop_id`: The ID of the slashed proposal.
  - `bond`: The bond amount being slashed (in `U128` format).

List of functions that invoke `emit_prop_slashed`: `execute`.

#### `vote`

- **Description:** Emitted when a vote is cast for a proposal.
- **Payload:**
  - `prop_id`: The ID of the proposal being voted on.

List of functions that invoke `emit_vote`: `vote`.

#### `execute`

- **Description:** Emitted when a proposal is executed.
- **Payload:**
  - `prop_id`: The ID of the executed proposal.

List of functions that invoke `emit_executed`: `on_execute`.

## Cheat Sheet

### Creating a Budget Approval proposal

1. HoM must create a Budget Proposal and approve it.

2. CoA must not veto it.

3. Once cooldown is over (cooldown starts once the proposal is internally approved), and it was not vetoed, then it's finalized.

4. Any human can can now create a VB Text proposal, referencing original HoM Budget proposal, example:

   ```shell
   near call IAH_REGISTRY is_human_call \
   '{"ctr": "VB.near", "function": "create_proposal", "payload": "{\"kind\": {\"ApproveBudget\": {\"dao\": \"HOM.near\", \"prop_id\": 12}}, \"description\": \"ADDITIONAL INFORMATION\"}"}' \
   --accountId YOU \
   --depositYocto $pre_vote_bond
   ```

5. Now we need to advance the proposal to the active queue. The easiest way is to ask any Congress member (HoM or other house) to support it. Below, `prop_id` must be the id of the proposal created above, `dao` must be the house address and the caller is member of (eg: `congress-hom-v1.ndc-gwg.near`).

   ```shell
   near call VB support_proposal_by_congress \
     '{"prop_id": 5, `dao`: "HOM"}' \
     --accountId YOU
   ```

6. Share the proposal ID with others and ask the VB to vote.

### Slashing a proposal

Any proposal with _Spam_ status or _PreVote_ and being overdue (see [Proposal Lifecycle](#proposal-lifecycle) section) is slasheable. Any account can trigger a slash, and in exchange he will receive the [`SLASH_REWARD`](https://github.com/near-ndc/voting-v1/blob/master/voting_body/src/constants.rs#L5).

Slashing pre vote proposal:

```shell
near call VB slash_prevote_proposal '{"id": 5}' \
  --accountId YOU
```

Slashing proposal in the active queue is as simple as executing it:

```shell
near call VB execute '{"id": 5}' \
  --accountId YOU
```

'''
'''--- voting_body/src/constants.rs ---
use near_sdk::{Balance, Gas, ONE_NEAR};

pub const MILI_NEAR: Balance = ONE_NEAR / 1_000;
/// 0.9N
pub const SLASH_REWARD: Balance = 900 * MILI_NEAR;

/// Gas reserved for final failure callback which panics if one of the callback fails.
pub const FAILURE_CALLBACK_GAS: Gas = Gas(3 * Gas::ONE_TERA.0);
pub const EXECUTE_CALLBACK_GAS: Gas = Gas(4 * Gas::ONE_TERA.0);

pub const EXECUTE_GAS: Gas = Gas(8 * Gas::ONE_TERA.0);

// 64bytes(accountID) + 1byte (prefix) + 4bytes(proposal_id) + vote(byte) = 72B -> add 20% margin = < 90B
pub const VOTE_STORAGE: u64 = 90;

/// max voting duration to prevent common mistake with time unit. 90 days in milliseconds
pub const MAX_DURATION: u64 = 7776000000;
/// min voting duration to prevent common mistake with time unit. 1 day in milliseconds
pub const MIN_DURATION: u64 = 86400000;

'''
'''--- voting_body/src/errors.rs ---
use near_sdk::env::panic_str;
use near_sdk::serde::Serialize;
use near_sdk::FunctionError;

#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum VoteError {
    PropNotFound,
    NotAuthorized,
    NotInProgress,
    Timeout,
    LockedUntil,
    Storage(String),
    NotIAHreg,
}

impl FunctionError for VoteError {
    fn panic(&self) -> ! {
        match self {
            VoteError::PropNotFound => panic_str("proposal doesn't exist"),
            VoteError::NotAuthorized => panic_str("not authorized"),
            VoteError::NotInProgress => panic_str("proposal not in progress"),
            VoteError::Timeout => panic_str("voting time is over"),
            VoteError::LockedUntil => {
                panic_str("account must be locked in iah_registry longer than the voting end")
            }
            VoteError::Storage(reason) => panic_str(reason),
            VoteError::NotIAHreg => panic_str("must be called by iah_registry"),
        }
    }
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum ExecError {
    PropNotFound,
    AlreadyFinalized,
    InProgress,
}

impl FunctionError for ExecError {
    fn panic(&self) -> ! {
        match self {
            ExecError::PropNotFound => panic_str("proposal doesn't exist"),
            ExecError::AlreadyFinalized => panic_str("proposal is already successfully finalized"),
            ExecError::InProgress => panic_str("proposal is still in progress"),
        }
    }
}

#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum CreatePropError {
    NotAuthorized,
    Storage(String),
    MinBond,
    NotIAHreg,
    BadRequest(String),
}

impl FunctionError for CreatePropError {
    fn panic(&self) -> ! {
        match self {
            CreatePropError::NotAuthorized => panic_str("not authorized"),
            CreatePropError::Storage(reason) => panic_str(reason),
            CreatePropError::MinBond => panic_str("min pre_vote_bond is required"),
            CreatePropError::BadRequest(reason) => panic_str(reason),
            CreatePropError::NotIAHreg => panic_str("must be called by iah_registry"),
        }
    }
}

#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
pub enum PrevoteError {
    NotFound,
    MinBond,
    NotOverdue,
    DoubleSupport,
    NotCongress,
    NotCongressMember,
    LockedUntil,
    NotIAHreg,
}

impl FunctionError for PrevoteError {
    fn panic(&self) -> ! {
        match self {
            PrevoteError::NotFound => panic_str("proposal not found"),
            PrevoteError::MinBond => panic_str("min active_queue_bond is required"),
            PrevoteError::NotOverdue => panic_str("proposal is not overdue"),
            PrevoteError::DoubleSupport => panic_str("already supported the proposal"),
            PrevoteError::NotCongress => panic_str("dao is not part of the congress"),
            PrevoteError::NotCongressMember => panic_str("user is not part of the congress dao"),
            PrevoteError::LockedUntil => {
                panic_str("account must be locked in iah_registry longer than the prevote end")
            }
            PrevoteError::NotIAHreg => panic_str("must be called by iah_registry"),
        }
    }
}

'''
'''--- voting_body/src/events.rs ---
use near_sdk::{json_types::U128, serde::Serialize, Balance};
use serde_json::json;

use crate::proposal::PropKind;

use common::{EventPayload, NearEvent};

fn emit_event<T: Serialize>(event: EventPayload<T>) {
    NearEvent {
        standard: "ndc-congress",
        version: "1.0.0",
        event,
    }
    .emit();
}

/// * `active`: set to true if the prosal was added to an active queue directly.
pub(crate) fn emit_prop_created(prop_id: u32, kind: &PropKind, active: bool) {
    emit_event(EventPayload {
        event: "proposal-create",
        data: json!({ "prop_id": prop_id, "kind": kind.to_name(),  "active": active}),
    });
}

/// Emitted when moving proposal from pre-vote to active queue.
pub(crate) fn emit_prop_active(prop_id: u32) {
    emit_event(EventPayload {
        event: "proposal-activate",
        data: json!({ "prop_id": prop_id}),
    });
}

/// Emitted when removing prevote prop and slashing it for not getting enough support.
pub(crate) fn emit_prevote_prop_slashed(prop_id: u32, bond: Balance) {
    emit_event(EventPayload {
        event: "proposal-prevote-slash",
        data: json!({ "prop_id": prop_id, "bond": U128(bond)}),
    });
}

pub(crate) fn emit_prop_slashed(prop_id: u32, bond: Balance) {
    emit_event(EventPayload {
        event: "proposal-slash",
        data: json!({ "prop_id": prop_id, "bond": U128(bond)}),
    });
}

pub(crate) fn emit_vote(prop_id: u32) {
    emit_event(EventPayload {
        event: "vote",
        data: json!({ "prop_id": prop_id }),
    });
}

pub(crate) fn emit_executed(prop_id: u32) {
    emit_event(EventPayload {
        event: "execute",
        data: json!({ "prop_id": prop_id }),
    });
}

/// spam event is emitted when a proposal is marked as spam, removed and bond is slashed.
pub(crate) fn emit_spam(prop_id: u32) {
    emit_event(EventPayload {
        event: "spam",
        data: json!({ "prop_id": prop_id }),
    });
}

'''
'''--- voting_body/src/ext.rs ---
use common::errors::HookError;
use near_sdk::ext_contract;
use near_sdk::AccountId;

#[ext_contract(ext_self)]
pub trait ExtSelf {
    fn on_execute(&mut self, prop_id: u32);
    fn on_support_by_congress(&mut self, prop_id: u32);
}

#[ext_contract(ext_congress)]
pub trait ExtCongress {
    fn veto_hook(&mut self, id: u32) -> Result<(), HookError>;
    fn dissolve_hook(&mut self) -> Result<(), HookError>;
    fn dismiss_hook(&mut self, member: AccountId) -> Result<(), HookError>;
    fn is_member(&self, account: AccountId) -> bool;
}

'''
'''--- voting_body/src/impls.rs ---
use super::*;

impl Contract {
    /**********
     * TRANSACTIONS
     **********/

    /// Creates a new proposal.
    /// Returns the new proposal ID.
    /// Caller is required to attach enough deposit to cover the proposal storage as well as all
    /// possible votes.
    /// NOTE: storage is paid from the bond.
    /// Panics when the FunctionCall is trying to call any of the congress contracts.
    pub fn create_proposal_impl(
        &mut self,
        caller: AccountId,
        payload: CreatePropPayload,
    ) -> Result<u32, CreatePropError> {
        let storage_start = env::storage_usage();
        let now = env::block_timestamp_ms();
        let bond = env::attached_deposit();

        if bond < self.pre_vote_bond {
            return Err(CreatePropError::MinBond);
        }

        // validate proposals
        match &payload.kind {
            PropKind::FunctionCall { receiver_id, .. } => {
                let accounts = self.accounts.get().unwrap();
                if *receiver_id == accounts.congress_coa
                    || *receiver_id == accounts.congress_hom
                    || *receiver_id == accounts.congress_tc
                {
                    return Err(CreatePropError::BadRequest(
                    "receiver_id can't be a congress house, use a specific proposal to interact with the congress".to_string(),
                ));
                }
            }
            PropKind::UpdateVoteDuration {
                pre_vote_duration,
                vote_duration,
            } => {
                if *pre_vote_duration < MIN_DURATION
                    || *vote_duration < MIN_DURATION
                    || *pre_vote_duration > MAX_DURATION
                    || *vote_duration > MAX_DURATION
                {
                    return Err(CreatePropError::BadRequest(
                    "receiver_id can't be a congress house, use a specific proposal to interact with the congress".to_string(),
                ));
                }
            }
            _ => (),
        }

        // TODO: check if proposal is created by a congress member. If yes, move it to active
        // immediately.
        let active = bond >= self.active_queue_bond;
        self.prop_counter += 1;
        emit_prop_created(self.prop_counter, &payload.kind, active);
        let mut prop = Proposal {
            proposer: caller.clone(),
            bond,
            additional_bond: None,
            description: payload.description,
            kind: payload.kind,
            status: if active {
                ProposalStatus::InProgress
            } else {
                ProposalStatus::PreVote
            },
            approve: 0,
            reject: 0,
            abstain: 0,
            spam: 0,
            support: 0,
            supported: HashSet::new(),
            start: now,
            executed_at: None,
            proposal_storage: 0,
        };
        if active {
            self.proposals.insert(&self.prop_counter, &prop);
        } else {
            self.pre_vote_proposals.insert(&self.prop_counter, &prop);
        }

        prop.proposal_storage = match finalize_storage_check(storage_start, 0, caller) {
            Err(reason) => return Err(CreatePropError::Storage(reason)),
            Ok(required) => required,
        };
        if active {
            self.proposals.insert(&self.prop_counter, &prop);
        } else {
            self.pre_vote_proposals.insert(&self.prop_counter, &prop);
        }

        Ok(self.prop_counter)
    }

    /// Supports proposal in the pre-vote queue.
    /// Returns false if the proposal can't be supported because it is overdue.
    /// `lock_duration: self.pre_vote_duration + 1`.
    /// `payload` must be a pre-vote proposal ID.
    pub fn support_proposal_impl(
        &mut self,
        caller: AccountId,
        locked_until: u64,
        payload: u32,
    ) -> Result<bool, PrevoteError> {
        let prop_id = payload;
        let mut p = self.assert_pre_vote_prop(prop_id)?;
        let now = env::block_timestamp_ms();
        if now - p.start > self.pre_vote_duration {
            self.slash_prop(prop_id, p.bond);
            self.pre_vote_proposals.remove(&prop_id);
            return Ok(false);
        }
        if locked_until <= p.start + self.pre_vote_duration {
            return Err(PrevoteError::LockedUntil);
        }

        p.add_support(caller)?;
        if p.support >= self.pre_vote_support {
            self.pre_vote_proposals.remove(&prop_id);
            self.insert_prop_to_active(prop_id, &mut p);
        } else {
            self.pre_vote_proposals.insert(&prop_id, &p);
        }
        Ok(true)
    }

    pub fn vote_impl(
        &mut self,
        caller: AccountId,
        locked_until: u64,
        payload: VotePayload,
    ) -> Result<(), VoteError> {
        let storage_start = env::storage_usage();
        let mut prop = self
            .proposals
            .get(&payload.prop_id)
            .ok_or(VoteError::PropNotFound)?;
        if !matches!(prop.status, ProposalStatus::InProgress) {
            return Err(VoteError::NotInProgress);
        }
        if !prop.is_active(self.vote_duration) {
            return Err(VoteError::Timeout);
        }
        if locked_until <= prop.start + self.vote_duration {
            return Err(VoteError::LockedUntil);
        }

        self.add_vote(payload.prop_id, caller.clone(), payload.vote, &mut prop);
        // NOTE: we can't quickly set a status to a finalized one because we don't know the total number of
        // voters

        self.proposals.insert(&payload.prop_id, &prop);
        emit_vote(payload.prop_id);

        if let Err(reason) = finalize_storage_check(storage_start, 0, caller) {
            return Err(VoteError::Storage(reason));
        }
        Ok(())
    }
}

'''
'''--- voting_body/src/lib.rs ---
use std::collections::HashSet;

use common::finalize_storage_check;
use events::*;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LazyOption, LookupMap},
    env::{self, panic_str},
    json_types::U128,
    near_bindgen, require,
    store::LookupSet,
    AccountId, Balance, FunctionError, Gas, PanicOnDefault, Promise, PromiseOrValue, PromiseResult,
};
use types::{CreatePropPayload, ExecResponse, SBTs, VotePayload};

mod constants;
mod errors;
mod events;
mod ext;
mod impls;
pub mod migrate;
pub mod proposal;
mod storage;
pub mod types;
pub mod view;

pub use crate::constants::*;
pub use crate::errors::*;
pub use crate::ext::*;
pub use crate::proposal::*;
use crate::storage::*;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    pub prop_counter: u32,
    /// Set of proposals in the pre-vote queue.
    pub pre_vote_proposals: LookupMap<u32, Proposal>,
    /// Set of active proposals.
    pub proposals: LookupMap<u32, Proposal>,
    /// map (prop_id, voter) -> VoteRecord
    pub votes: LookupMap<(u32, AccountId), VoteRecord>,

    /// Near amount required to create a proposal. Will be slashed if the proposal is marked as
    /// spam.
    pub pre_vote_bond: Balance,
    pub active_queue_bond: Balance,
    /// amount of users that need to support a proposal to move it to the active queue;
    pub pre_vote_support: u32,

    /// minimum amount of members to approve the proposal
    /// u32 can hold a number up to 4.2 B. That is enough for many future iterations.
    pub simple_consent: Consent,
    pub super_consent: Consent,

    /// all times below are in milliseconds
    pub pre_vote_duration: u64,
    pub vote_duration: u64,
    pub accounts: LazyOption<Accounts>,

    /// Workaround for removing people from iom registry blacklist
    /// As we don't have a way to remove people from the blacklist, we can add them to the whitelist
    /// and allow them to vote directly.
    pub iom_whitelist: LookupSet<AccountId>,
}

#[near_bindgen]
impl Contract {
    #[init]
    /// All duration arguments are in milliseconds.
    /// * hook_auth : map of accounts authorized to call hooks.
    pub fn new(
        pre_vote_duration: u64,
        vote_duration: u64,
        pre_vote_support: u32,
        pre_vote_bond: U128,
        active_queue_bond: U128,
        accounts: Accounts,
        simple_consent: Consent,
        super_consent: Consent,
    ) -> Self {
        require!(
            simple_consent.verify() && super_consent.verify(),
            "threshold must be a percentage (0-100%)"
        );
        Self {
            prop_counter: 0,
            pre_vote_proposals: LookupMap::new(StorageKey::PreVoteProposals),
            proposals: LookupMap::new(StorageKey::Proposals),
            votes: LookupMap::new(StorageKey::Votes),
            pre_vote_duration,
            vote_duration,
            pre_vote_bond: pre_vote_bond.0,
            active_queue_bond: active_queue_bond.0,
            pre_vote_support,
            accounts: LazyOption::new(StorageKey::Accounts, Some(&accounts)),
            simple_consent,
            super_consent,
            iom_whitelist: LookupSet::new(StorageKey::IomWhitelist),
        }
    }

    /*
     * Queries are in view.rs
     */

    /**********
     * TRANSACTIONS
     **********/

    #[payable]
    pub fn create_proposal_whitelist(&mut self, payload: CreatePropPayload) -> u32 {
        let caller = env::predecessor_account_id();
        self.assert_whitelist(&caller);

        match self.create_proposal_impl(caller, payload) {
            Ok(id) => id,
            Err(error) => error.panic(),
        }
    }

    /// Must be called via `iah_registry.is_human_call`.
    #[payable]
    #[handle_result]
    pub fn create_proposal(
        &mut self,
        caller: AccountId,
        #[allow(unused_variables)] iah_proof: SBTs,
        payload: CreatePropPayload,
    ) -> Result<u32, CreatePropError> {
        if env::predecessor_account_id() != self.accounts.get().unwrap().iah_registry {
            return Err(CreatePropError::NotIAHreg);
        }

        self.create_proposal_impl(caller, payload)
    }

    /// Removes overdue pre-vote proposal and slashes the proposer.
    /// User who calls the function to receives REMOVE_REWARD.
    /// Fails if proposal is not overdue or not in pre-vote queue.
    #[handle_result]
    pub fn slash_prevote_proposal(&mut self, id: u32) -> Result<(), PrevoteError> {
        let p = self.remove_pre_vote_prop(id)?;
        if env::block_timestamp_ms() - p.start <= self.pre_vote_duration {
            return Err(PrevoteError::NotOverdue);
        }
        Promise::new(env::predecessor_account_id()).transfer(SLASH_REWARD);
        self.slash_prop(id, p.bond - SLASH_REWARD);
        // NOTE: we don't need to check p.additional_bond: if it is set then the prop wouldn't
        // be in the pre-vote queue.

        Ok(())
    }

    #[payable]
    #[handle_result]
    /// Allows to add more bond to a proposal to move it to the active queue. Anyone can top up.
    /// Returns true if the transaction succeeded, or false if the proposal is outdated and
    /// can't be top up any more.
    /// Emits:
    /// * proposal-prevote-slashed: when the prevote proposal is overdue and didn't get enough
    ///   support on time.
    /// * proposal-active: when a proposal was successfully updated.
    /// Excess of attached bond is sent back to the caller.
    /// Returns error when proposal is not in the pre-vote queue or not enough bond was attached.
    pub fn top_up_proposal(&mut self, id: u32) -> Result<bool, PrevoteError> {
        let user = env::predecessor_account_id();
        let mut bond = env::attached_deposit();
        let mut p = self.remove_pre_vote_prop(id)?;

        if env::block_timestamp_ms() - p.start > self.pre_vote_duration {
            // Transfer attached N, slash bond & keep the proposal removed.
            // Note: user wanted to advance the proposal, rather than slash it, so reward is not
            // distributed.
            Promise::new(user.clone()).transfer(bond);
            self.slash_prop(id, p.bond);
            return Ok(false);
        }

        let required_bond = self.active_queue_bond - p.bond;
        if bond < required_bond {
            return Err(PrevoteError::MinBond);
        }
        let diff = bond - required_bond;
        if diff > 0 {
            Promise::new(user.clone()).transfer(diff);
            bond -= diff;
        }
        p.additional_bond = Some((user, bond));
        self.insert_prop_to_active(id, &mut p);
        Ok(true)
    }

    pub fn support_proposal_whitelist(&mut self, payload: u32) -> bool {
        let caller = env::predecessor_account_id();
        self.assert_whitelist(&caller);

        match self.support_proposal_impl(
            caller,
            // Lock is required to prevent double voting by moving sbt to another account.
            // It is not required for the whitelist version, as only whitelisted accounts can call
            env::block_timestamp_ms() + MAX_DURATION + 1,
            payload,
        ) {
            Ok(supported) => supported,
            Err(err) => err.panic(),
        }
    }

    /// Supports proposal in the pre-vote queue.
    /// Returns false if the proposal can't be supported because it is overdue.
    /// Must be called via `iah_registry.is_human_call_lock` with
    /// `lock_duration: self.pre_vote_duration + 1`.
    /// `payload` must be a pre-vote proposal ID.
    #[handle_result]
    pub fn support_proposal(
        &mut self,
        caller: AccountId,
        locked_until: u64,
        #[allow(unused_variables)] iah_proof: Option<SBTs>,
        payload: u32,
    ) -> Result<bool, PrevoteError> {
        if env::predecessor_account_id() != self.accounts.get().unwrap().iah_registry {
            return Err(PrevoteError::NotIAHreg);
        }
        self.support_proposal_impl(caller, locked_until, payload)
    }

    /// Congressional support for a pre-vote proposal to move it to the active queue.
    /// Returns false if the proposal can't be supported because it is overdue.
    #[handle_result]
    pub fn support_proposal_by_congress(
        &mut self,
        prop_id: u32,
        dao: AccountId,
    ) -> Result<Promise, PrevoteError> {
        let a = self.accounts.get().unwrap();
        if !(a.congress_coa == dao || a.congress_hom == dao || a.congress_tc == dao) {
            return Err(PrevoteError::NotCongress);
        }

        Ok(ext_congress::ext(dao)
            .is_member(env::predecessor_account_id())
            .then(ext_self::ext(env::current_account_id()).on_support_by_congress(prop_id)))
    }

    /// Returns false if the proposal can't be supported because it is overdue.
    #[private]
    #[handle_result]
    pub fn on_support_by_congress(
        &mut self,
        #[callback_result] is_member: Result<bool, near_sdk::PromiseError>,
        prop_id: u32,
    ) -> Result<bool, PrevoteError> {
        if !is_member.unwrap_or(false) {
            return Err(PrevoteError::NotCongressMember);
        }

        let mut p = self.remove_pre_vote_prop(prop_id)?;
        if env::block_timestamp_ms() - p.start > self.pre_vote_duration {
            self.slash_prop(prop_id, p.bond);
            return Ok(false);
        }
        self.insert_prop_to_active(prop_id, &mut p);
        Ok(true)
    }

    pub fn vote_whitelist(&mut self, payload: VotePayload) {
        let caller = env::predecessor_account_id();
        self.assert_whitelist(&caller);

        match self.vote_impl(
            caller,
            env::block_timestamp_ms() + MAX_DURATION + 1,
            payload,
        ) {
            Ok(_) => (),
            Err(err) => err.panic(),
        }
    }

    /// Must be called via `iah_registry.is_human_call_lock` with
    /// `lock_duration: self.vote_duration + 1`.
    #[payable]
    #[handle_result]
    pub fn vote(
        &mut self,
        caller: AccountId,
        locked_until: u64,
        #[allow(unused_variables)] iah_proof: Option<SBTs>,
        payload: VotePayload,
    ) -> Result<(), VoteError> {
        if env::predecessor_account_id() != self.accounts.get().unwrap().iah_registry {
            return Err(VoteError::NotIAHreg);
        }

        self.vote_impl(caller, locked_until, payload)
    }

    /// Allows anyone to execute or slash the proposal.
    /// If proposal is slasheable, the user who executes gets REMOVE_REWARD.
    #[handle_result]
    pub fn execute(&mut self, id: u32) -> Result<PromiseOrValue<ExecResponse>, ExecError> {
        let mut prop = self.proposals.get(&id).ok_or(ExecError::PropNotFound)?;
        // quick return, can only execute if the status was not switched yet, or it
        // failed (previous attempt to execute failed).
        if !matches!(
            prop.status,
            ProposalStatus::InProgress | ProposalStatus::Failed
        ) {
            return Err(ExecError::AlreadyFinalized);
        }

        prop.recompute_status(self.vote_duration, self.prop_consent(&prop));
        match prop.status {
            ProposalStatus::PreVote => panic_str("pre-vote proposal can't be in the active queue"),
            ProposalStatus::InProgress => return Err(ExecError::InProgress),
            ProposalStatus::Executed => return Ok(PromiseOrValue::Value(ExecResponse::Executed)),
            ProposalStatus::Rejected => {
                self.proposals.insert(&id, &prop);
                return Ok(PromiseOrValue::Value(ExecResponse::Rejected));
            }
            ProposalStatus::Spam => {
                emit_spam(id);
                emit_prop_slashed(id, prop.bond); // needs to be called before we zero prop.bond
                prop.slash_bond(self.accounts.get().unwrap().community_treasury);
                self.proposals.remove(&id);
                return Ok(PromiseOrValue::Value(ExecResponse::Slashed));
            }
            ProposalStatus::Approved | ProposalStatus::Failed => (), // execute below
        };

        prop.refund_bond();
        prop.status = ProposalStatus::Executed;
        prop.executed_at = Some(env::block_timestamp_ms());
        let mut out = PromiseOrValue::Value(ExecResponse::Executed);
        match &prop.kind {
            PropKind::Dismiss { dao, member } => {
                out = ext_congress::ext(dao.clone())
                    .dismiss_hook(member.clone())
                    .into();
            }
            PropKind::Dissolve { dao } => {
                out = ext_congress::ext(dao.clone()).dissolve_hook().into();
            }
            PropKind::Veto { dao, prop_id } => {
                out = ext_congress::ext(dao.clone()).veto_hook(*prop_id).into();
            }
            PropKind::Text | PropKind::TextSuper | PropKind::ApproveBudget { .. } => (),
            PropKind::FunctionCall {
                receiver_id,
                actions,
            } => {
                let mut promise = Promise::new(receiver_id.clone());
                for action in actions {
                    promise = promise.function_call(
                        action.method_name.clone(),
                        action.args.clone().into(),
                        action.deposit.0,
                        Gas(action.gas.0),
                    );
                }
                out = promise.into();
            }
            PropKind::UpdateBonds {
                pre_vote_bond,
                active_queue_bond,
            } => {
                self.pre_vote_bond = pre_vote_bond.0;
                self.active_queue_bond = active_queue_bond.0;
            }
            PropKind::UpdateVoteDuration {
                pre_vote_duration,
                vote_duration,
            } => {
                self.pre_vote_duration = *pre_vote_duration;
                self.vote_duration = *vote_duration;
            }
        };

        self.proposals.insert(&id, &prop);

        let out = match out {
            PromiseOrValue::Promise(promise) => promise
                .then(
                    ext_self::ext(env::current_account_id())
                        .with_static_gas(EXECUTE_CALLBACK_GAS)
                        .on_execute(id),
                )
                .into(),
            _ => {
                emit_executed(id);
                out
            }
        };
        Ok(out)
    }

    /*****************
     * ADMIN
     ****************/

    /// Allows admin to udpate the consent based on the latest amount of humans verified accounts.
    pub fn admin_update_consent(&mut self, simple_consent: Consent, super_consent: Consent) {
        self.assert_admin();
        self.simple_consent = simple_consent;
        self.super_consent = super_consent;
    }

    /// Allows admin to add a user to the whitelist.
    pub fn admin_add_to_whitelist(&mut self, user: AccountId) {
        self.assert_admin();
        self.iom_whitelist.insert(user);
    }

    /// Allows admin to remove a user from the whitelist.
    pub fn admin_remove_from_whitelist(&mut self, user: AccountId) {
        self.assert_admin();
        self.iom_whitelist.remove(&user);
    }

    // /// udpate voting time for e2e tests purposes
    // /// TODO: remove
    // pub fn admin_update_durations(&mut self, pre_vote_duration: u64, vote_duration: u64) {
    //     self.assert_admin();
    //     require!(
    //         env::current_account_id().as_ref().contains("test"),
    //         "can only be run in test contracts"
    //     );

    //     self.pre_vote_duration = pre_vote_duration;
    //     self.vote_duration = vote_duration;
    // }

    /*****************
     * CALLBACKS
     ****************/

    #[private]
    pub fn on_execute(&mut self, prop_id: u32) {
        assert_eq!(
            env::promise_results_count(),
            1,
            "ERR_UNEXPECTED_CALLBACK_PROMISES"
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(_) => (),
            PromiseResult::Failed => {
                let mut prop = self.proposals.get(&prop_id).expect("proposal not found");
                prop.status = ProposalStatus::Failed;
                prop.executed_at = None;
                self.proposals.insert(&prop_id, &prop);
                emit_executed(prop_id);
            }
        };
    }

    /*****************
     * INTERNAL
     ****************/

    fn assert_admin(&self) {
        require!(
            env::predecessor_account_id() == self.accounts.get().unwrap().admin,
            "not authorized"
        );
    }

    fn assert_whitelist(&self, account_id: &AccountId) {
        require!(self.iom_whitelist.contains(account_id), "not whitelisted");
    }

    fn remove_pre_vote_prop(&mut self, id: u32) -> Result<Proposal, PrevoteError> {
        self.pre_vote_proposals
            .remove(&id)
            .ok_or(PrevoteError::NotFound)
    }

    fn assert_pre_vote_prop(&mut self, id: u32) -> Result<Proposal, PrevoteError> {
        self.pre_vote_proposals
            .get(&id)
            .ok_or(PrevoteError::NotFound)
    }

    fn insert_prop_to_active(&mut self, prop_id: u32, p: &mut Proposal) {
        p.supported.clear();
        p.status = ProposalStatus::InProgress;
        p.start = env::block_timestamp_ms();
        self.proposals.insert(&prop_id, p);
        emit_prop_active(prop_id);
    }

    fn slash_prop(&mut self, prop_id: u32, amount: Balance) {
        let treasury = self.accounts.get().unwrap().community_treasury;
        Promise::new(treasury).transfer(amount);
        emit_prevote_prop_slashed(prop_id, amount);
    }

    fn prop_consent(&self, prop: &Proposal) -> Consent {
        match prop.kind.required_consent() {
            ConsentKind::Simple => self.simple_consent.clone(),
            ConsentKind::Super => self.super_consent.clone(),
        }
    }

    fn add_vote(&mut self, prop_id: u32, user: AccountId, vote: Vote, prop: &mut Proposal) {
        match vote {
            Vote::Abstain => prop.abstain += 1,
            Vote::Approve => prop.approve += 1,
            Vote::Reject => prop.reject += 1,
            Vote::Spam => prop.spam += 1,
        };
        // allow to overwrite existing votes
        let v = VoteRecord {
            timestamp: env::block_timestamp_ms(),
            vote,
        };
        if let Some(old_vote) = self.votes.insert(&(prop_id, user), &v) {
            match old_vote.vote {
                Vote::Approve => prop.approve -= 1,
                Vote::Reject => prop.reject -= 1,
                Vote::Abstain => prop.abstain -= 1,
                Vote::Spam => prop.spam -= 1,
            }
        }
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod unit_tests {
    use near_sdk::{test_utils::VMContextBuilder, testing_env, AccountId, VMContext, ONE_NEAR};

    use crate::{view::ConfigOutput, *};

    /// 1ms in nano seconds
    const MSECOND: u64 = 1_000_000;

    const START: u64 = 60 * 5 * 1000 * MSECOND;
    // In milliseconds
    const VOTE_DURATION: u64 = 60 * 5 * 1000;
    const PRE_VOTE_DURATION: u64 = 60 * 10 * 1000;
    const PRE_BOND: u128 = ONE_NEAR * 3;
    const BOND: u128 = ONE_NEAR * 500;
    const PRE_VOTE_SUPPORT: u32 = 10;
    const VOTE_DEPOSIT: u128 = ONE_NEAR / 1000;

    fn acc(idx: u8) -> AccountId {
        AccountId::new_unchecked(format!("user-{}.near", idx))
    }

    fn hom() -> AccountId {
        AccountId::new_unchecked("hom.near".to_string())
    }

    fn coa() -> AccountId {
        AccountId::new_unchecked("coa.near".to_string())
    }

    fn tc() -> AccountId {
        AccountId::new_unchecked("tc.near".to_string())
    }

    fn iah_registry() -> AccountId {
        AccountId::new_unchecked("registry.near".to_string())
    }

    fn treasury() -> AccountId {
        AccountId::new_unchecked("treasury.near".to_string())
    }

    fn admin() -> AccountId {
        AccountId::new_unchecked("admin.near".to_string())
    }

    fn vote_payload(prop_id: u32, vote: Vote) -> VotePayload {
        VotePayload { prop_id, vote }
    }

    fn vote_record(timestamp_ns: u64, vote: Vote) -> VoteRecord {
        VoteRecord {
            timestamp: timestamp_ns / MSECOND,
            vote,
        }
    }

    fn create_prop_payload(kind: PropKind, description: String) -> CreatePropPayload {
        CreatePropPayload { kind, description }
    }

    fn iah_proof() -> SBTs {
        vec![(iah_registry(), vec![1, 4])]
    }

    /// creates a test contract with proposal
    fn setup_ctr(attach_deposit: u128) -> (VMContext, Contract, u32) {
        let mut context = VMContextBuilder::new().build();
        let mut contract = Contract::new(
            PRE_VOTE_DURATION,
            VOTE_DURATION,
            PRE_VOTE_SUPPORT,
            U128(PRE_BOND),
            U128(BOND),
            Accounts {
                iah_registry: iah_registry(),
                community_treasury: treasury(),
                congress_hom: hom(),
                congress_coa: coa(),
                congress_tc: tc(),
                admin: admin(),
            },
            Consent {
                quorum: 3,
                threshold: 50,
            },
            Consent {
                quorum: 5,
                threshold: 60,
            },
        );
        context.block_timestamp = START;
        context.predecessor_account_id = iah_registry();
        context.attached_deposit = attach_deposit;
        context.account_balance = ONE_NEAR * 2000;
        testing_env!(context.clone());

        let id = contract
            .create_proposal(
                acc(1),
                iah_proof(),
                create_prop_payload(PropKind::Text, "Proposal unit test 1".to_string()),
            )
            .unwrap();

        context.attached_deposit = 0;
        testing_env!(context.clone());

        (context, contract, id)
    }

    fn min_vote_lock(ctx: &VMContext) -> u64 {
        ctx.block_timestamp / MSECOND + VOTE_DURATION + 1
    }

    fn min_prevote_lock(ctx: &VMContext) -> u64 {
        ctx.block_timestamp / MSECOND + PRE_VOTE_DURATION + 1
    }

    fn vote(mut ctx: VMContext, ctr: &mut Contract, accs: Vec<AccountId>, id: u32, vote: Vote) {
        for a in accs {
            ctx.predecessor_account_id = iah_registry();
            ctx.attached_deposit = VOTE_DEPOSIT;
            testing_env!(ctx.clone());
            let locked_until = min_vote_lock(&ctx);
            let res = ctr.vote(
                a.clone(),
                locked_until,
                None,
                vote_payload(id, vote.clone()),
            );
            assert_eq!(
                res,
                Ok(()),
                "\nacc {} _____ prop: {:?}",
                a,
                ctr.proposals.get(&id).unwrap(),
            );
        }
    }

    fn insert_vote(ctr: &mut Contract, prop_id: u32, voter: AccountId, timestamp_ns: u64, v: Vote) {
        ctr.votes
            .insert(&(prop_id, voter), &vote_record(timestamp_ns, v));
    }

    fn vote_and_fast_forward_status_check(
        ctx: &mut VMContext,
        ctr: &mut Contract,
        accs: Vec<AccountId>,
        id: u32,
        v: Vote,
        expected_status: ProposalStatus,
    ) {
        vote(ctx.clone(), ctr, accs, id, v);
        ctx.block_timestamp += (ctr.vote_duration + 1) * MSECOND;
        testing_env!(ctx.clone());
        let prop = ctr.get_proposal(id).unwrap();
        assert_eq!(prop.proposal.status, expected_status);
    }

    fn create_proposal(mut ctx: VMContext, ctr: &mut Contract, bond: Balance) -> u32 {
        ctx.predecessor_account_id = iah_registry();
        ctx.attached_deposit = bond;
        testing_env!(ctx.clone());
        ctr.create_proposal(
            acc(1),
            iah_proof(),
            create_prop_payload(PropKind::Text, "Proposal unit test".to_string()),
        )
        .unwrap()
    }

    fn create_proposal_with_status(
        mut ctx: VMContext,
        ctr: &mut Contract,
        status: ProposalStatus,
    ) -> u32 {
        ctx.predecessor_account_id = iah_registry();
        ctx.attached_deposit = BOND;
        testing_env!(ctx.clone());
        let id = ctr
            .create_proposal(
                acc(1),
                iah_proof(),
                create_prop_payload(PropKind::Text, "Proposal unit test".to_string()),
            )
            .unwrap();
        let mut prop = ctr.proposals.get(&id).unwrap();
        prop.status = status;
        ctr.proposals.insert(&id, &prop);
        id
    }

    #[test]
    fn basic_flows() {
        let (mut ctx, mut ctr, id) = setup_ctr(PRE_BOND);
        let mut prop1 = ctr.get_proposal(id).unwrap();
        assert_eq!(prop1.proposal.status, ProposalStatus::PreVote);
        assert_eq!(ctr.number_of_proposals(), 1);
        assert_eq!(
            ctr.get_proposals(0, 10, None),
            vec![],
            "should only return active proposals"
        );

        //
        // move proposal to an active queue and vote
        ctx.attached_deposit = BOND;
        ctx.block_timestamp += MSECOND;
        ctx.predecessor_account_id = acc(2);
        testing_env!(ctx.clone());
        assert_eq!(Ok(true), ctr.top_up_proposal(id));
        // update the prop1 to the expected vaules
        prop1.proposal.status = ProposalStatus::InProgress;
        prop1.proposal.start = (START + MSECOND) / MSECOND;
        prop1.proposal.additional_bond = Some((acc(2), BOND - PRE_BOND));
        assert_eq!(ctr.get_proposals(0, 10, None), vec![prop1.clone()]);

        //
        // Try vote with less storage
        ctx.predecessor_account_id = iah_registry();
        ctx.attached_deposit = 0;
        testing_env!(ctx.clone());
        let locked = min_vote_lock(&ctx);
        match ctr.vote(acc(2), locked, None, vote_payload(id, Vote::Approve)) {
            Err(VoteError::Storage(_)) => (),
            x => panic!("expected Storage, got: {:?}", x),
        }

        //
        // Successful vote
        vote(
            ctx.clone(),
            &mut ctr,
            vec![acc(1), acc(2), acc(3)],
            id,
            Vote::Approve,
        );

        //
        // Proposal already got enough votes, but the voting time is not over yet. So, we can
        // still vote, but we can't execute.
        ctx.block_timestamp += VOTE_DURATION / 2 * MSECOND;
        ctx.attached_deposit = ONE_NEAR / 10;
        testing_env!(ctx.clone());
        prop1 = ctr.get_proposal(id).unwrap();
        assert_eq!(prop1.proposal.status, ProposalStatus::InProgress);
        let locked = min_vote_lock(&ctx);
        assert_eq!(
            ctr.vote(acc(5), locked, None, vote_payload(id, Vote::Spam)),
            Ok(())
        );
        prop1.proposal.spam += 1;
        insert_vote(&mut ctr, id, acc(5), ctx.block_timestamp, Vote::Spam);
        assert!(matches!(ctr.execute(id), Err(ExecError::InProgress)));

        //
        // Create a new proposal, not enough bond
        //
        let resp = ctr.create_proposal(
            acc(1),
            iah_proof(),
            create_prop_payload(PropKind::Text, "proposal".to_owned()),
        );
        assert_eq!(resp, Err(CreatePropError::MinBond));

        //
        // Create a new proposal with bond to active queue and check double vote and expire
        // Check all votes
        //
        ctx.account_balance = ONE_NEAR * 1000;
        let id = create_proposal(ctx.clone(), &mut ctr, BOND);
        let mut prop2 = ctr.get_proposal(id).unwrap();
        assert_eq!(
            ctr.vote(acc(3), locked, None, vote_payload(id, Vote::Approve)),
            Ok(())
        );
        vote(
            ctx.clone(),
            &mut ctr,
            vec![acc(1), acc(2)],
            id,
            Vote::Reject,
        );

        prop2.proposal.approve = 1;
        prop2.proposal.reject = 2;
        insert_vote(&mut ctr, id, acc(3), ctx.block_timestamp, Vote::Approve);
        insert_vote(&mut ctr, id, acc(1), ctx.block_timestamp, Vote::Reject);
        insert_vote(&mut ctr, id, acc(2), ctx.block_timestamp, Vote::Reject);

        assert_eq!(ctr.get_proposals(0, 1, None), vec![prop1.clone()]);
        assert_eq!(
            ctr.get_proposals(0, 10, None),
            vec![prop1.clone(), prop2.clone()]
        );
        assert_eq!(
            ctr.get_proposals(1, 10, None),
            vec![prop1.clone(), prop2.clone()]
        );
        assert_eq!(ctr.get_proposals(2, 10, None), vec![prop2.clone()]);
        assert_eq!(ctr.get_proposals(3, 10, None), vec![]);

        //
        // create proposal, cast votes, but not enough to approve.
        // set timestamp past voting period, status should be rejected
        //
        let id = create_proposal(ctx.clone(), &mut ctr, BOND);
        vote_and_fast_forward_status_check(
            &mut ctx,
            &mut ctr,
            vec![acc(1), acc(2)],
            id,
            Vote::Approve,
            ProposalStatus::Rejected,
        );

        //
        // enough approve votes, but more reject votes.
        let id = create_proposal(ctx.clone(), &mut ctr, BOND);
        vote(
            ctx.clone(),
            &mut ctr,
            vec![acc(1), acc(2), acc(3)],
            id,
            Vote::Approve,
        );
        vote_and_fast_forward_status_check(
            &mut ctx,
            &mut ctr,
            vec![acc(10), acc(11), acc(12)],
            id,
            Vote::Reject,
            ProposalStatus::Rejected,
        );

        //
        // enough approve votes, but same amount of reject + spam votes.
        let id = create_proposal(ctx.clone(), &mut ctr, BOND);
        vote(
            ctx.clone(),
            &mut ctr,
            vec![acc(1), acc(2), acc(3)],
            id,
            Vote::Approve,
        );
        vote(ctx.clone(), &mut ctr, vec![acc(4)], id, Vote::Spam);
        vote_and_fast_forward_status_check(
            &mut ctx,
            &mut ctr,
            vec![acc(10), acc(11)],
            id,
            Vote::Reject,
            ProposalStatus::Rejected,
        );

        //
        // enough approve votes, but more reject + spam votes.
        let id = create_proposal(ctx.clone(), &mut ctr, BOND);
        vote(
            ctx.clone(),
            &mut ctr,
            vec![acc(1), acc(2), acc(3)],
            id,
            Vote::Approve,
        );
        vote(ctx.clone(), &mut ctr, vec![acc(4)], id, Vote::Reject);
        vote_and_fast_forward_status_check(
            &mut ctx,
            &mut ctr,
            vec![acc(10), acc(11)],
            id,
            Vote::Spam,
            ProposalStatus::Spam,
        );
    }

    #[test]
    fn proposal_overdue() {
        let (mut ctx, mut ctr, id) = setup_ctr(BOND);
        ctx.block_timestamp = START + (ctr.vote_duration + 1) * MSECOND;
        testing_env!(ctx.clone());
        let locked = min_vote_lock(&ctx);
        assert_eq!(
            ctr.vote(acc(1), locked, None, vote_payload(id, Vote::Approve)),
            Err(VoteError::Timeout)
        );
    }

    #[test]
    fn vote_not_found() {
        let (ctx, mut ctr, id) = setup_ctr(PRE_BOND);
        // proposal is in pre-vote queue, so should not be found in the active queue
        let locked = min_vote_lock(&ctx);
        match ctr.vote(acc(1), locked, None, vote_payload(id, Vote::Approve)) {
            Err(err) => assert_eq!(err, VoteError::PropNotFound),
            Ok(_) => panic!("expect PropNotFound, got: Ok"),
        }

        match ctr.vote(acc(1), locked, None, vote_payload(999, Vote::Approve)) {
            Err(err) => assert_eq!(err, VoteError::PropNotFound),
            Ok(_) => panic!("expect PropNotFound, got: Ok"),
        }
    }

    #[test]
    fn execute_not_active() {
        let (_, mut ctr, id) = setup_ctr(PRE_BOND);
        match ctr.execute(id) {
            Err(ExecError::PropNotFound) => (),
            Err(err) => panic!("expect PropNotFound, got: {:?}", err),
            Ok(_) => panic!("expect PropNotFound, got: Ok"),
        }
    }

    #[test]
    fn execution_text() {
        let (mut ctx, mut ctr, id) = setup_ctr(BOND);
        match ctr.execute(id) {
            Ok(_) => panic!("expected InProgress, got: OK"),
            Err(err) => assert_eq!(err, ExecError::InProgress),
        }
        vote(
            ctx.clone(),
            &mut ctr,
            vec![acc(1), acc(2), acc(3)],
            id,
            Vote::Approve,
        );

        ctx.block_timestamp = START + ctr.vote_duration / 2 * MSECOND;
        testing_env!(ctx.clone());
        let mut p = ctr.get_proposal(id).unwrap();
        assert_eq!(p.proposal.status, ProposalStatus::InProgress);
        match ctr.execute(id) {
            Ok(_) => panic!("expected InProgress, got: OK"),
            Err(err) => assert_eq!(err, ExecError::InProgress),
        }

        // fast forward to voting overtime
        ctx.block_timestamp = START + (ctr.vote_duration + 1) * MSECOND;
        testing_env!(ctx.clone());
        assert!(matches!(
            ctr.execute(id),
            Ok(PromiseOrValue::Value(ExecResponse::Executed))
        ));
        p = ctr.get_proposal(id).unwrap();
        assert_eq!(p.proposal.status, ProposalStatus::Executed);
        assert_eq!(p.proposal.executed_at, Some(ctx.block_timestamp / MSECOND));

        //
        // check spam transaction
        let id = create_proposal_with_status(ctx.clone(), &mut ctr, ProposalStatus::Spam);
        assert!(matches!(ctr.execute(id), Err(ExecError::AlreadyFinalized)));

        //
        // check spam transaction, part2
        let id = create_proposal_with_status(ctx.clone(), &mut ctr, ProposalStatus::InProgress);
        vote(
            ctx.clone(),
            &mut ctr,
            vec![acc(1), acc(2), acc(3)],
            id,
            Vote::Spam,
        );

        ctx.block_timestamp += (ctr.vote_duration + 1) * MSECOND * 10;
        testing_env!(ctx.clone());
        match ctr.execute(id) {
            Ok(PromiseOrValue::Value(ExecResponse::Slashed)) => (),
            Ok(_) => panic!("expected Ok(ExecResponse:Slashed)"),
            Err(err) => panic!("expected Ok(ExecResponse:Slashed), got: Err {:?}", err),
        }

        assert_eq!(ctr.get_proposal(id), None);
        // second execute should return AlreadySlashed
        match ctr.execute(id) {
            Ok(_) => panic!("expected Err(ExecError::PropNotFound)"),
            Err(err) => assert_eq!(err, ExecError::PropNotFound),
        }
    }

    #[test]
    fn execution_update_bonds() {
        let (mut ctx, mut ctr, _) = setup_ctr(PRE_BOND);
        ctx.attached_deposit = BOND;
        testing_env!(ctx.clone());
        let id = ctr
            .create_proposal(
                acc(1),
                iah_proof(),
                CreatePropPayload {
                    kind: PropKind::UpdateBonds {
                        pre_vote_bond: (PRE_BOND * 2).into(),
                        active_queue_bond: (BOND * 5).into(),
                    },
                    description: "updating bonds".to_owned(),
                },
            )
            .unwrap();
        vote(
            ctx.clone(),
            &mut ctr,
            vec![acc(1), acc(2), acc(3)],
            id,
            Vote::Approve,
        );

        ctx.predecessor_account_id = acc(10);
        ctx.block_timestamp += ctr.vote_duration * 10 * MSECOND;
        testing_env!(ctx.clone());

        match ctr.execute(id) {
            Ok(_) => (),
            Err(err) => panic!("expected OK, got: {:?}", err),
        }
        let p = ctr.get_proposal(id).unwrap();
        assert_eq!(p.proposal.status, ProposalStatus::Executed);
        assert_eq!(p.proposal.executed_at, Some(ctx.block_timestamp / MSECOND));
        assert_eq!(ctr.pre_vote_bond, PRE_BOND * 2);
        assert_eq!(ctr.active_queue_bond, BOND * 5);
    }

    #[test]
    fn execution_update_vote_duration() {
        let (mut ctx, mut ctr, _) = setup_ctr(PRE_BOND);
        ctx.attached_deposit = BOND;
        testing_env!(ctx.clone());
        let id = ctr
            .create_proposal(
                acc(1),
                iah_proof(),
                CreatePropPayload {
                    kind: PropKind::UpdateVoteDuration {
                        pre_vote_duration: MIN_DURATION,
                        vote_duration: MAX_DURATION,
                    },
                    description: "updating voting duration".to_owned(),
                },
            )
            .unwrap();
        vote(
            ctx.clone(),
            &mut ctr,
            vec![acc(1), acc(2), acc(3)],
            id,
            Vote::Approve,
        );

        ctx.predecessor_account_id = acc(10);
        ctx.block_timestamp += ctr.vote_duration * 10 * MSECOND;
        testing_env!(ctx.clone());

        match ctr.execute(id) {
            Ok(_) => (),
            Err(err) => panic!("expected OK, got: {:?}", err),
        }
        let p = ctr.get_proposal(id).unwrap();
        assert_eq!(p.proposal.status, ProposalStatus::Executed);
        assert_eq!(p.proposal.executed_at, Some(ctx.block_timestamp / MSECOND));
        assert_eq!(ctr.pre_vote_duration, MIN_DURATION);
        assert_eq!(ctr.vote_duration, MAX_DURATION);
    }

    #[test]
    fn refund_bond_test() {
        let (mut ctx, mut ctr, id) = setup_ctr(BOND);
        vote(
            ctx.clone(),
            &mut ctr,
            vec![acc(1), acc(2), acc(3)],
            id,
            Vote::Approve,
        );
        ctx.block_timestamp = START + (ctr.vote_duration + 1) * MSECOND;
        testing_env!(ctx.clone());

        ctr.execute(id).unwrap();
        let mut p = ctr.get_proposal(id).unwrap();
        assert_eq!(p.proposal.status, ProposalStatus::Executed);

        // try to get refund again
        assert!(!p.proposal.refund_bond());

        // Get refund for proposal with no status update
        ctx.attached_deposit = BOND;
        testing_env!(ctx.clone());
        let id2 = ctr
            .create_proposal(
                acc(1),
                iah_proof(),
                create_prop_payload(PropKind::Text, "Proposal unit test".to_string()),
            )
            .unwrap();
        p = ctr.get_proposal(id2).unwrap();

        // Set time after voting period
        ctx.block_timestamp = (p.proposal.start + ctr.vote_duration + 1) * MSECOND;
        testing_env!(ctx);

        // Call refund
        assert!(p.proposal.refund_bond());
    }

    #[test]
    fn config_query() {
        let (_, ctr, _) = setup_ctr(PRE_BOND);
        let expected = ConfigOutput {
            prop_counter: 1,
            pre_vote_bond: U128(PRE_BOND),
            active_queue_bond: U128(BOND),
            pre_vote_support: 10,
            simple_consent: Consent {
                quorum: 3,
                threshold: 50,
            },
            super_consent: Consent {
                quorum: 5,
                threshold: 60,
            },
            pre_vote_duration: PRE_VOTE_DURATION,
            vote_duration: VOTE_DURATION,
            accounts: Accounts {
                iah_registry: iah_registry(),
                community_treasury: treasury(),
                congress_hom: hom(),
                congress_coa: coa(),
                congress_tc: tc(),
                admin: admin(),
            },
        };
        assert_eq!(ctr.config(), expected);
    }

    #[test]
    fn overwrite_votes() {
        let (mut ctx, mut ctr, id) = setup_ctr(BOND);
        let mut p = ctr.get_proposal(id).unwrap();
        assert_eq!(p.proposal.status, ProposalStatus::InProgress);

        ctx.attached_deposit = VOTE_DEPOSIT;
        testing_env!(ctx.clone());
        let locked = min_vote_lock(&ctx);
        assert_eq!(
            ctr.vote(acc(1), locked, None, vote_payload(id, Vote::Approve)),
            Ok(())
        );
        p.proposal.approve = 1;
        insert_vote(&mut ctr, id, acc(1), ctx.block_timestamp, Vote::Approve);
        assert_eq!(ctr.get_proposal(id).unwrap(), p);

        assert_eq!(
            ctr.vote(acc(1), locked, None, vote_payload(id, Vote::Abstain)),
            Ok(())
        );
        p.proposal.approve = 0;
        p.proposal.abstain = 1;
        insert_vote(&mut ctr, id, acc(1), ctx.block_timestamp, Vote::Abstain);
        assert_eq!(ctr.get_proposal(id).unwrap(), p);

        assert_eq!(
            ctr.vote(acc(1), locked, None, vote_payload(id, Vote::Reject)),
            Ok(())
        );
        p.proposal.abstain = 0;
        p.proposal.reject = 1;
        insert_vote(&mut ctr, id, acc(1), ctx.block_timestamp, Vote::Reject);
        assert_eq!(ctr.get_proposal(id).unwrap(), p);

        assert_eq!(
            ctr.vote(acc(1), locked, None, vote_payload(id, Vote::Spam)),
            Ok(())
        );
        p.proposal.reject = 0;
        p.proposal.spam = 1;
        insert_vote(&mut ctr, id, acc(1), ctx.block_timestamp, Vote::Spam);
        assert_eq!(ctr.get_proposal(id).unwrap(), p);
    }

    #[test]
    fn get_proposals() {
        let (ctx, mut ctr, id1) = setup_ctr(BOND);
        let id2 = create_proposal(ctx.clone(), &mut ctr, BOND);
        let id3 = create_proposal(ctx.clone(), &mut ctr, BOND);
        let prop1 = ctr.get_proposal(id1).unwrap();
        let prop2 = ctr.get_proposal(id2).unwrap();
        let prop3 = ctr.get_proposal(id3).unwrap();
        assert_eq!(ctr.number_of_proposals(), 3);
        // non reversed
        assert_eq!(ctr.get_proposals(1, 1, None), vec![prop1.clone()]);
        assert_eq!(
            ctr.get_proposals(0, 10, None),
            vec![prop1.clone(), prop2.clone(), prop3.clone()]
        );
        // non reversed with litmit
        assert_eq!(
            ctr.get_proposals(0, 2, None),
            vec![prop1.clone(), prop2.clone()]
        );
        assert_eq!(
            ctr.get_proposals(0, 2, Some(false)),
            vec![prop1.clone(), prop2.clone()]
        );
        assert_eq!(
            ctr.get_proposals(1, 2, Some(false)),
            vec![prop1.clone(), prop2.clone()]
        );
        // reversed, limit bigger than amount of proposals -> return all
        assert_eq!(
            ctr.get_proposals(3, 10, Some(true)),
            vec![prop3.clone(), prop2.clone(), prop1.clone()]
        );
        // reversed with limit and over the "last proposal"
        assert_eq!(
            ctr.get_proposals(5, 2, Some(true)),
            vec![prop3.clone(), prop2.clone()]
        );

        // few more edge cases
        assert_eq!(ctr.get_proposals(1, 0, None), vec![], "limit=0");
        assert_eq!(
            ctr.get_proposals(0, 1, None),
            vec![prop1.clone()],
            "0 = start from the last proposal (rev=false)"
        );
        assert_eq!(
            ctr.get_proposals(0, 1, Some(true)),
            vec![prop3.clone()],
            "0 = start from the last proposal (rev=true)"
        );
        assert_eq!(ctr.get_proposals(2, 1, None), vec![prop2.clone()],);
        assert_eq!(ctr.get_proposals(2, 1, Some(true)), vec![prop2.clone()],);
    }

    #[test]
    fn support_proposal() {
        let (mut ctx, mut ctr, id) = setup_ctr(PRE_BOND);

        // make one less support then what is necessary to test that the proposal is still in prevote
        let locked = min_prevote_lock(&ctx);
        for i in 1..PRE_VOTE_SUPPORT {
            assert_eq!(
                ctr.support_proposal(acc(i as u8), locked, None, id),
                Ok(true)
            );
        }

        assert_eq!(
            ctr.support_proposal(acc(1), locked, None, id),
            Err(PrevoteError::DoubleSupport)
        );

        let p = ctr.assert_pre_vote_prop(id).unwrap();
        assert_eq!(p.status, ProposalStatus::PreVote);
        assert_eq!(p.support, PRE_VOTE_SUPPORT - 1);
        for i in 1..PRE_VOTE_SUPPORT {
            assert!(p.supported.contains(&acc(i as u8)))
        }

        // add the missing support and assert that the proposal was moved to active
        ctx.block_timestamp = START + 2 * MSECOND;
        testing_env!(ctx.clone());
        let locked = min_prevote_lock(&ctx);
        assert_eq!(
            ctr.support_proposal(acc(PRE_VOTE_SUPPORT as u8), locked, None, id),
            Ok(true)
        );

        // should be removed from prevote queue
        assert_eq!(ctr.assert_pre_vote_prop(id), Err(PrevoteError::NotFound));
        let p = ctr.proposals.get(&id).unwrap();
        assert_eq!(p.status, ProposalStatus::InProgress);
        assert_eq!(p.support, PRE_VOTE_SUPPORT);
        assert_eq!(p.start, ctx.block_timestamp / MSECOND);
        assert!(p.supported.is_empty());

        // can't support proposal which was already moved
        assert_eq!(
            ctr.support_proposal(acc(1), locked, None, id),
            Err(PrevoteError::NotFound)
        );

        //
        // Should not be able to support an overdue proposal
        //
        let id = create_proposal(ctx.clone(), &mut ctr, PRE_BOND);
        ctx.block_timestamp += (PRE_VOTE_DURATION + 1) * MSECOND;
        testing_env!(ctx.clone());
        let locked = min_prevote_lock(&ctx);
        assert_eq!(ctr.support_proposal(acc(1), locked, None, id), Ok(false));
        assert_eq!(ctr.get_proposal(id), None);
    }

    #[test]
    fn update_consent() {
        let (mut ctx, mut ctr, _) = setup_ctr(BOND);
        ctx.predecessor_account_id = admin();
        testing_env!(ctx.clone());

        let c1 = Consent {
            quorum: 11,
            threshold: 1,
        };
        let c2 = Consent {
            quorum: 12,
            threshold: 2,
        };
        ctr.admin_update_consent(c1, c2);
        assert_eq!(c1, ctr.simple_consent);
        assert_eq!(c2, ctr.super_consent);
    }

    #[test]
    fn update_white_list() {
        let (mut ctx, mut ctr, _) = setup_ctr(BOND);
        ctx.predecessor_account_id = admin();
        testing_env!(ctx.clone());

        assert_eq!(ctr.is_iom_whitelisted(&acc(1)), false);
        ctr.admin_add_to_whitelist(acc(1));
        assert_eq!(ctr.is_iom_whitelisted(&acc(1)), true);
        ctr.admin_remove_from_whitelist(acc(1));
        assert_eq!(ctr.is_iom_whitelisted(&acc(1)), false);
    }

    #[test]
    fn whitelisted_can_vote() {
        let (mut ctx, mut ctr, id) = setup_ctr(BOND);
        ctx.predecessor_account_id = admin();
        testing_env!(ctx.clone());
        ctr.admin_add_to_whitelist(acc(1));
        ctx.predecessor_account_id = acc(1);
        ctx.attached_deposit = VOTE_DEPOSIT;
        testing_env!(ctx.clone());
        ctr.vote_whitelist(vote_payload(id, Vote::Approve));
    }

    #[test]
    fn not_called_by_iah_registry() {
        let (mut ctx, mut ctr, id) = setup_ctr(BOND);
        let locked = min_vote_lock(&ctx);
        ctx.predecessor_account_id = acc(1);
        testing_env!(ctx);
        assert_eq!(
            ctr.vote(acc(1), locked, None, vote_payload(id, Vote::Approve)),
            Err(VoteError::NotIAHreg)
        );

        let resp = ctr.create_proposal(
            acc(1),
            iah_proof(),
            create_prop_payload(PropKind::Text, "Proposal unit test".to_string()),
        );
        assert_eq!(resp, Err(CreatePropError::NotIAHreg));

        let resp = ctr.support_proposal(acc(1), locked, None, id);
        assert_eq!(resp, Err(PrevoteError::NotIAHreg));
    }

    #[test]
    fn iah_lock_not_enough() {
        let (ctx, mut ctr, id) = setup_ctr(BOND);
        let locked = min_vote_lock(&ctx) - 1;
        assert_eq!(
            ctr.vote(acc(1), locked, None, vote_payload(id, Vote::Approve)),
            Err(VoteError::LockedUntil)
        );

        let locked = min_prevote_lock(&ctx) - 1;
        let id2 = create_proposal(ctx, &mut ctr, PRE_BOND);
        let resp = ctr.support_proposal(acc(1), locked, None, id2);
        assert_eq!(resp, Err(PrevoteError::LockedUntil));
    }

    #[test]
    fn support_proposal_by_congress() {
        let (_, mut ctr, id) = setup_ctr(PRE_BOND);

        match ctr.support_proposal_by_congress(id, iah_registry()) {
            Err(PrevoteError::NotCongress) => (),
            _ => panic!("expected error: provided DAO must be one of the congress houses"),
        };
        assert!(
            ctr.support_proposal_by_congress(id, tc()).is_ok(),
            "must accept valid dao parameter"
        );
    }

    #[test]
    fn on_support_by_congress() {
        let (mut ctx, mut ctr, id) = setup_ctr(PRE_BOND);

        assert_eq!(
            ctr.on_support_by_congress(Ok(false), id),
            Err(PrevoteError::NotCongressMember)
        );
        assert_eq!(
            ctr.on_support_by_congress(Err(near_sdk::PromiseError::Failed), id),
            Err(PrevoteError::NotCongressMember)
        );
        assert!(
            ctr.pre_vote_proposals.contains_key(&id),
            "should not be moved"
        );

        //
        // outdated proposal should be removed
        ctx.block_timestamp += (ctr.pre_vote_duration + 1) * MSECOND;
        testing_env!(ctx.clone());
        assert_eq!(ctr.on_support_by_congress(Ok(true), id), Ok(false));
        assert_eq!(ctr.get_proposal(id), None);

        //
        // check that proposal was moved
        let id = create_proposal(ctx.clone(), &mut ctr, PRE_BOND);
        ctx.block_timestamp += MSECOND;
        testing_env!(ctx.clone());
        let mut prop = ctr.get_proposal(id).unwrap();

        assert_eq!(ctr.on_support_by_congress(Ok(true), id), Ok(true));
        assert_eq!(ctr.assert_pre_vote_prop(id), Err(PrevoteError::NotFound));
        // modify prop to expected values and see if it equals the stored one
        prop.proposal.status = ProposalStatus::InProgress;
        prop.proposal.start += 1; // start is in milliseconds
        assert_eq!(ctr.get_proposal(id).unwrap(), prop);
    }

    #[test]
    fn create_proposal_function_call_to_congress() {
        let (mut ctx, mut ctr, _) = setup_ctr(BOND);
        ctx.predecessor_account_id = iah_registry();
        ctx.attached_deposit = BOND;
        testing_env!(ctx.clone());
        match ctr.create_proposal(
            acc(1),
            iah_proof(),
            create_prop_payload(
                PropKind::FunctionCall {
                    receiver_id: hom(),
                    actions: vec![],
                },
                "Proposal unit test".to_string(),
            ),
        ) {
            Ok(_) => panic!("expected Err(CreatePropError::FunctionCall)"),
            Err(err) => assert_eq!(
                err,
                CreatePropError::BadRequest("receiver_id can't be a congress house, use a specific proposal to interact with the congress".to_string())
            ),
        }
    }

    #[test]
    fn get_pre_vote_proposals() {
        let (ctx, mut ctr, _) = setup_ctr(BOND);
        create_proposal(ctx.clone(), &mut ctr, PRE_BOND);
        create_proposal(ctx.clone(), &mut ctr, PRE_BOND);
        let active_proposals = ctr.get_proposals(0, 10, None);
        assert_eq!(active_proposals.len(), 1);
        let pre_vote_proposals = ctr.get_pre_vote_proposals(0, 10, None);
        assert_eq!(pre_vote_proposals.len(), 2);
    }

    #[test]
    fn vote_map() {
        let (ctx, mut ctr, id1) = setup_ctr(BOND);
        let id2 = create_proposal(ctx.clone(), &mut ctr, BOND);
        let locked = min_vote_lock(&ctx);

        assert_eq!(
            ctr.vote(acc(1), locked, None, vote_payload(id1, Vote::Approve)),
            Ok(())
        );
        assert_eq!(
            ctr.vote(acc(1), locked, None, vote_payload(id2, Vote::Reject)),
            Ok(())
        );
        assert_eq!(
            ctr.vote(acc(2), locked, None, vote_payload(id2, Vote::Spam)),
            Ok(())
        );

        let now = ctx.block_timestamp;
        let get = |prop_id, acc| ctr.votes.get(&(prop_id, acc)).unwrap();
        assert_eq!(get(id1, acc(1)), vote_record(now, Vote::Approve));
        assert_eq!(get(id2, acc(1)), vote_record(now, Vote::Reject));
        assert_eq!(get(id2, acc(2)), vote_record(now, Vote::Spam));
    }

    #[test]
    fn check_serialization() {
        assert_eq!(
            serde_json::to_string(&PropKind::Text {}).unwrap(),
            "\"Text\"".to_string()
        );

        let k = PropKind::Dismiss {
            dao: coa(),
            member: acc(1),
        };
        assert_eq!(
            serde_json::to_string(&k).unwrap(),
            "{\"Dismiss\":{\"dao\":\"coa.near\",\"member\":\"user-1.near\"}}".to_string()
        );

        let k = PropKind::Veto {
            dao: hom(),
            prop_id: 12,
        };
        assert_eq!(
            serde_json::to_string(&k).unwrap(),
            "{\"Veto\":{\"dao\":\"hom.near\",\"prop_id\":12}}".to_string()
        );
    }
}

'''
'''--- voting_body/src/migrate.rs ---
use crate::*;

#[derive(BorshDeserialize, BorshSerialize)]
pub struct OldState {
    pub prop_counter: u32,
    /// Set of proposals in the pre-vote queue.
    pub pre_vote_proposals: LookupMap<u32, Proposal>,
    /// Set of active proposals.
    pub proposals: LookupMap<u32, Proposal>,
    /// map (prop_id, voter) -> VoteRecord
    pub votes: LookupMap<(u32, AccountId), VoteRecord>,

    /// Near amount required to create a proposal. Will be slashed if the proposal is marked as
    /// spam.
    pub pre_vote_bond: Balance,
    pub active_queue_bond: Balance,
    /// amount of users that need to support a proposal to move it to the active queue;
    pub pre_vote_support: u32,

    /// minimum amount of members to approve the proposal
    /// u32 can hold a number up to 4.2 B. That is enough for many future iterations.
    pub simple_consent: Consent,
    pub super_consent: Consent,

    /// all times below are in milliseconds
    pub pre_vote_duration: u64,
    pub vote_duration: u64,
    pub accounts: LazyOption<Accounts>,
}

#[near_bindgen]
impl Contract {
    #[private]
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let old_state: OldState = env::state_read().expect("Old state doesn't exist");
        Self {
            prop_counter: old_state.prop_counter,
            pre_vote_proposals: old_state.pre_vote_proposals,
            proposals: old_state.proposals,
            votes: old_state.votes,
            pre_vote_bond: old_state.pre_vote_bond,
            active_queue_bond: old_state.active_queue_bond,
            pre_vote_support: old_state.pre_vote_support,
            simple_consent: old_state.simple_consent,
            super_consent: old_state.super_consent,
            pre_vote_duration: old_state.pre_vote_duration,
            vote_duration: old_state.vote_duration,
            accounts: old_state.accounts,
            iom_whitelist: LookupSet::new(StorageKey::IomWhitelist),
        }
    }
}

'''
'''--- voting_body/src/proposal.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{Base64VecU8, U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{env, AccountId, Balance, Promise};

use std::collections::HashSet;

use crate::{PrevoteError, SLASH_REWARD};

/// Consent sets the conditions for vote to pass. It specifies a quorum (minimum amount of
/// accounts that have to vote and the approval threshold (% of #approve votes) for a proposal
/// to pass.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Copy))]
pub struct Consent {
    pub quorum: u32,
    /// percentage value
    pub threshold: u8,
}

impl Consent {
    pub fn verify(&self) -> bool {
        self.threshold <= 100
    }
}

#[derive(BorshSerialize, BorshDeserialize)]
pub enum ConsentKind {
    Simple,
    Super,
}

/// Proposals that are sent to this DAO.
#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(
    all(test, not(target_arch = "wasm32")),
    derive(Debug, PartialEq, Clone)
)]
pub struct Proposal {
    /// Original proposer.
    pub proposer: AccountId,
    /// original bond, used to cover the storage for all votes
    pub bond: Balance,
    pub(crate) additional_bond: Option<(AccountId, Balance)>,
    /// Description of this proposal.
    pub description: String,
    /// Kind of proposal with relevant information.
    pub kind: PropKind,
    /// Current status of the proposal.
    pub status: ProposalStatus,
    pub approve: u32,
    pub reject: u32,
    pub spam: u32,
    pub abstain: u32,
    pub support: u32,
    pub supported: HashSet<AccountId>,
    /// start time (for voting period).
    pub start: u64,
    /// Unix time in milliseconds when the proposal was executed. `None` if it is not approved
    /// or execution failed.
    pub executed_at: Option<u64>,
    /// Proposal storage cost (excluding vote)
    pub(crate) proposal_storage: u128,
}

impl Proposal {
    pub fn add_support(&mut self, user: AccountId) -> Result<(), PrevoteError> {
        if self.supported.contains(&user) {
            return Err(PrevoteError::DoubleSupport);
        }
        self.support += 1;
        self.supported.insert(user);
        Ok(())
    }

    pub fn is_active(&self, vote_duration: u64) -> bool {
        env::block_timestamp_ms() <= self.start + vote_duration
    }

    pub fn recompute_status(&mut self, vote_duration: u64, consent: Consent) {
        // still in progress or already finalzied
        if self.is_active(vote_duration) || self.status != ProposalStatus::InProgress {
            return;
        }
        let total_no = self.reject + self.spam;
        let qualified = self.approve + total_no;

        // check if we have quorum
        if qualified + self.abstain < consent.quorum {
            self.status = ProposalStatus::Rejected;
            return;
        }

        if self.approve > qualified * consent.threshold as u32 / 100 {
            self.status = ProposalStatus::Approved;
        } else if self.spam > self.reject
            && total_no >= qualified * (100 - consent.threshold) as u32 / 100
        {
            self.status = ProposalStatus::Spam;
        } else {
            self.status = ProposalStatus::Rejected;
        }
    }

    /// Refund after voting period is over
    pub fn refund_bond(&mut self) -> bool {
        if self.bond == 0 {
            return false;
        }

        // Vote storage is already paid by voters. We only keep storage for proposal.
        let refund = self.bond - self.proposal_storage;
        Promise::new(self.proposer.clone()).transfer(refund);
        if let Some((account, amount)) = &self.additional_bond {
            Promise::new(account.clone()).transfer(*amount);
        }
        self.bond = 0;
        self.additional_bond = None;
        true
    }

    /// returns false if there is nothing to slash.
    pub fn slash_bond(&mut self, treasury: AccountId) -> bool {
        if self.bond == 0 {
            return false;
        }
        let mut bond = self.bond - self.proposal_storage;
        if let Some((_, amount)) = self.additional_bond {
            bond += amount;
        }
        let reward = if bond >= SLASH_REWARD {
            Promise::new(treasury).transfer(bond - SLASH_REWARD);
            SLASH_REWARD
        } else {
            bond
        };
        Promise::new(env::predecessor_account_id()).transfer(reward);
        self.bond = 0;
        self.additional_bond = None;
        true
    }
}

/// Kinds of proposals, doing different action.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Clone, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub enum PropKind {
    Dismiss {
        dao: AccountId,
        member: AccountId,
    },
    Dissolve {
        dao: AccountId,
    },
    Veto {
        dao: AccountId,
        prop_id: u32,
    },
    ApproveBudget {
        dao: AccountId,
        prop_id: u32,
    },
    /// A default, text based proposal.
    /// NewBudget, UpdateBudget are modelled using Text.
    // NOTE: In Sputnik, this variant kind is called `Vote`
    Text,
    /// Same as the `Text` proposal, but requires the Super Consent to approve.
    TextSuper,
    /// Calls `receiver_id` with list of method names in a single promise.
    /// Allows this contract to execute any arbitrary set of actions in other contracts
    /// except for congress contracts.
    FunctionCall {
        receiver_id: AccountId,
        actions: Vec<ActionCall>,
    },
    UpdateBonds {
        pre_vote_bond: U128,
        active_queue_bond: U128,
    },
    UpdateVoteDuration {
        pre_vote_duration: u64,
        vote_duration: u64,
    },
}

impl PropKind {
    /// name of the kind
    pub fn to_name(&self) -> String {
        match self {
            PropKind::Dismiss { .. } => "dismiss".to_string(),
            PropKind::Dissolve { .. } => "dissolve".to_string(),
            PropKind::Veto { .. } => "veto".to_string(),
            PropKind::ApproveBudget { .. } => "approve-budget".to_string(),
            PropKind::Text => "text".to_string(),
            PropKind::TextSuper => "text super consent".to_string(),
            PropKind::FunctionCall { .. } => "function call".to_string(),
            PropKind::UpdateBonds { .. } => "config: update bonds".to_string(),
            PropKind::UpdateVoteDuration { .. } => "config: update voting duration".to_string(),
        }
    }

    pub fn required_consent(&self) -> ConsentKind {
        match self {
            Self::Dismiss { .. }
            | Self::Veto { .. }
            | Self::ApproveBudget { .. }
            | Self::Text
            | Self::FunctionCall { .. }
            | Self::UpdateBonds { .. }
            | Self::UpdateVoteDuration { .. } => ConsentKind::Simple,
            Self::Dissolve { .. } | Self::TextSuper => ConsentKind::Super,
        }
    }
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Clone))]
pub enum ProposalStatus {
    PreVote,
    InProgress,
    Approved,
    Rejected,
    /// Spam is a tempral status when set when the proposal reached spam threshold and will be
    /// removed.
    Spam,
    Executed,
    /// If proposal has failed when executing. Allowed to re-finalize again to either expire or
    /// approved.
    Failed,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq))]
pub struct VoteRecord {
    pub timestamp: u64, // unix time of when this vote was submitted
    pub vote: Vote,
}

/// Votes recorded in the proposal.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Clone, Debug, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub enum Vote {
    Approve = 0x0,
    Reject = 0x1,
    /// Spam vote indicates that the proposal creates a spam, must be removed and the bond
    /// slashed.
    Spam = 0x2,
    Abstain = 0x3,
    // note: we don't have Remove, we use Spam.
}

/// Function call arguments.
#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Clone, PartialEq))]
#[serde(crate = "near_sdk::serde")]
pub struct ActionCall {
    pub method_name: String,
    pub args: Base64VecU8,
    pub deposit: U128,
    pub gas: U64,
}

'''
'''--- voting_body/src/storage.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{AccountId, BorshStorageKey};

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize, BorshStorageKey)]
pub enum StorageKey {
    PreVoteProposals,
    Proposals,
    Accounts,
    Votes,
    IomWhitelist,
}

/// External account required for the Voting Body.
#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, PartialEq, Clone))]
pub struct Accounts {
    pub iah_registry: AccountId,
    pub community_treasury: AccountId,
    pub congress_hom: AccountId,
    pub congress_coa: AccountId,
    pub congress_tc: AccountId,
    pub admin: AccountId,
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod unit_tests2 {
    use near_sdk::IntoStorageKey;

    use crate::storage::StorageKey;

    #[test]
    fn check_storage() {
        assert_eq!(StorageKey::PreVoteProposals.into_storage_key(), vec![0]);
        assert_eq!(StorageKey::Accounts.into_storage_key(), vec![2]);
        assert_eq!(StorageKey::Votes.into_storage_key(), vec![3]);
    }
}

'''
'''--- voting_body/src/types.rs ---
use crate::{PropKind, Vote};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;

#[derive(Deserialize, Serialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct VotePayload {
    pub prop_id: u32,
    pub vote: Vote,
}

#[derive(Serialize, Deserialize)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Clone))]
#[serde(crate = "near_sdk::serde")]
pub struct CreatePropPayload {
    pub kind: PropKind,
    pub description: String,
}

pub type SBTs = Vec<(AccountId, Vec<u64>)>;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug, Clone, PartialEq))]
pub enum ExecResponse {
    Slashed,
    Rejected,
    Executed,
}

'''
'''--- voting_body/src/view.rs ---
use std::cmp::{max, min};

use itertools::Either;
use near_sdk::serde::Serialize;

use crate::*;

/// This is format of output via JSON for the proposal.
#[derive(Serialize)]
#[cfg_attr(
    all(test, not(target_arch = "wasm32")),
    derive(Debug, PartialEq, Clone)
)]
#[serde(crate = "near_sdk::serde")]
pub struct ProposalOutput {
    /// Id of the proposal.
    pub id: u32,
    #[serde(flatten)]
    pub proposal: Proposal,
}

/// This is format of output via JSON for the config.
#[derive(Serialize)]
#[cfg_attr(test, derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct ConfigOutput {
    pub prop_counter: u32,
    pub pre_vote_bond: U128,
    pub active_queue_bond: U128,
    pub pre_vote_support: u32,
    pub simple_consent: Consent,
    pub super_consent: Consent,
    pub vote_duration: u64,
    pub pre_vote_duration: u64,
    pub accounts: Accounts,
}

#[near_bindgen]
impl Contract {
    /**********
     * QUERIES
     **********/

    /// Returns all proposals from the active queue, which were not marked as a spam. This
    /// includes proposals that are in progress, rejected, approved or failed.
    /// If `from_index == 0` then it will start from the first element (or the last one if
    /// reverse is set to true).
    pub fn get_proposals(
        &self,
        from_index: u32,
        limit: u32,
        reverse: Option<bool>,
    ) -> Vec<ProposalOutput> {
        self._get_proposals(from_index, limit, reverse, false)
    }

    fn _get_proposals(
        &self,
        from_index: u32,
        limit: u32,
        reverse: Option<bool>,
        pre_vote: bool,
    ) -> Vec<ProposalOutput> {
        let iter = if reverse.unwrap_or(false) {
            let end = if from_index == 0 {
                self.prop_counter
            } else {
                min(from_index, self.prop_counter)
            };
            let start = if end <= limit { 1 } else { end - (limit - 1) };
            Either::Left((start..=end).rev())
        } else {
            let from_index = max(from_index, 1);
            Either::Right(from_index..=min(self.prop_counter, from_index + limit - 1))
        };

        let proposals = if pre_vote {
            &self.pre_vote_proposals
        } else {
            &self.proposals
        };

        iter.filter_map(|id| {
            proposals.get(&id).map(|mut proposal| {
                proposal.recompute_status(self.vote_duration, self.prop_consent(&proposal));
                ProposalOutput { id, proposal }
            })
        })
        .collect()
    }

    /// Get specific proposal.
    pub fn get_proposal(&self, id: u32) -> Option<ProposalOutput> {
        let mut p = self.proposals.get(&id);
        if p.is_none() {
            p = self.pre_vote_proposals.get(&id);
        }
        p.map(|mut proposal| {
            proposal.recompute_status(self.vote_duration, self.prop_consent(&proposal));
            ProposalOutput { id, proposal }
        })
    }

    /// * `id`: proposal id
    /// * `voter`: account address.
    /// Returns none if voter didn't vote for the given proposal id.
    pub fn get_vote(&self, id: u32, voter: AccountId) -> Option<VoteRecord> {
        self.votes.get(&(id, voter))
    }

    pub fn number_of_proposals(&self) -> u32 {
        self.prop_counter
    }

    pub fn config(&self) -> ConfigOutput {
        ConfigOutput {
            prop_counter: self.prop_counter,
            pre_vote_bond: U128(self.pre_vote_bond),
            active_queue_bond: U128(self.active_queue_bond),
            pre_vote_support: self.pre_vote_support,
            simple_consent: self.simple_consent.clone(),
            super_consent: self.super_consent.clone(),
            pre_vote_duration: self.pre_vote_duration,
            vote_duration: self.vote_duration,
            accounts: self.accounts.get().unwrap(),
        }
    }

    // Returns proposals from the pre-vote queue
    pub fn get_pre_vote_proposals(
        &self,
        from_index: u32,
        limit: u32,
        reverse: Option<bool>,
    ) -> Vec<ProposalOutput> {
        self._get_proposals(from_index, limit, reverse, true)
    }

    pub fn is_iom_whitelisted(&self, account_id: &AccountId) -> bool {
        self.iom_whitelist.contains(&account_id)
    }
}

'''
'''--- voting_body/tests/integration.rs ---
use congress::view::ProposalOutput;
use congress::{HookPerm, PropKind, PropPerm, ProposalStatus};
use integrations::{instantiate_congress, setup_registry};
use near_sdk::serde::Deserialize;
use near_sdk::serde::Serialize;
use near_units::parse_near;
use near_workspaces::{Account, Contract, DevNetwork, Worker};
use serde_json::json;
use std::collections::HashMap;
use voting_body::types::{CreatePropPayload, VotePayload};
use voting_body::{Consent, Vote};
/// 1s in ms
const MSECOND: u64 = 1_000_000;

#[derive(Deserialize, Serialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct TokenMetadata {
    pub class: u64,
    pub issued_at: Option<u64>,
    pub expires_at: Option<u64>,
    pub reference: Option<String>,
    pub reference_hash: Option<String>,
}

struct Suite {
    pub hom_contract: Contract,
    pub vb_contract: Contract,
    pub registry_contract: Contract,
    pub alice: Account,
    pub proposal_id: u32,
    pub vb_members: Vec<Account>,
}
impl Suite {
    pub async fn vote(&self, payload: &VotePayload) -> anyhow::Result<()> {
        for user in &self.vb_members {
            let res = user.call(self.registry_contract.id(), "is_human_call_lock")
        .args_json(json!({"ctr": self.vb_contract.id(), "function": "vote", "payload": serde_json::to_string(payload).unwrap(), "lock_duration": 1800000, "with_proof": false}))
        .max_gas()
        .deposit(parse_near!("1 N"))
        .transact()
        .await?;
            assert!(res.is_success(), "{:?}", res);
        }
        Ok(())
    }
}

async fn init(worker: &Worker<impl DevNetwork>) -> anyhow::Result<Suite> {
    // deploy contracts
    let mut hom_contract = worker
        .dev_deploy(include_bytes!("../../res/congress.wasm"))
        .await?;
    let vb_contract = worker
        .dev_deploy(include_bytes!("../../res/voting_body.wasm"))
        .await?;

    let admin = worker.dev_create_account().await?;
    let community_fund = worker.dev_create_account().await?;
    let iah_issuer = worker.dev_create_account().await?;
    let alice = worker.dev_create_account().await?;
    let bob = worker.dev_create_account().await?;
    let john = worker.dev_create_account().await?;
    let flagger = worker.dev_create_account().await?;
    let vb_member1 = worker.dev_create_account().await?;
    let vb_member2 = worker.dev_create_account().await?;
    let vb_member3 = worker.dev_create_account().await?;
    let vb_member4 = worker.dev_create_account().await?;

    let registry_contract = setup_registry(
        worker,
        admin.clone(),
        flagger.clone(),
        iah_issuer.clone(),
        vec![],
    )
    .await?;

    // get current block time
    let block = worker.view_block().await?;
    let now = block.timestamp() / MSECOND; // timestamp in milliseconds

    let mut hom_hook = HashMap::new();
    hom_hook.insert(
        vb_contract.id().clone(),
        vec![HookPerm::Dismiss, HookPerm::Dissolve, HookPerm::VetoAll],
    );
    // initialize HoM
    hom_contract = instantiate_congress(
        hom_contract,
        now,
        vec![alice.id(), bob.id(), john.id()],
        vec![
            PropPerm::Text,
            PropPerm::FunctionCall,
            PropPerm::FundingRequest,
            PropPerm::RecurrentFundingRequest,
        ],
        hom_hook,
        community_fund.clone(),
        registry_contract.id(),
        10 * 1000,
    )
    .await?;

    // create a proposal
    let res2 = alice
        .call(hom_contract.id(), "create_proposal")
        .args_json(json!({
            "kind": PropKind::Text, "description": "Text proposal 1",
        }))
        .max_gas()
        .deposit(parse_near!("0.01 N"))
        .transact();
    let proposal_id: u32 = res2.await?.json()?;

    let simple_conset = Consent {
        quorum: 2,
        threshold: 2,
    };
    let super_consent = Consent {
        quorum: 3,
        threshold: 2,
    };

    // init voting body
    let res = vb_contract
        .call("new")
        .args_json(json!({"pre_vote_duration": 1800000,
          "vote_duration": 11000, "pre_vote_support": 3,
          "pre_vote_bond": "50000",
          "active_queue_bond": "150000", "accounts": {
            "congress_hom": hom_contract.id(),
            "congress_coa": hom_contract.id(),
            "congress_tc": hom_contract.id(),
            "iah_registry": registry_contract.id(),
            "community_treasury": community_fund.id(),
            "admin": admin.id()
          }, "simple_consent":simple_conset, "super_consent": super_consent
        }))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    // mint iah tokens
    let iah = vec![TokenMetadata {
        class: 1,
        issued_at: Some(0),
        expires_at: None,
        reference: None,
        reference_hash: None,
    }];

    let token_spec = vec![
        (vb_member1.id(), iah.clone()),
        (vb_member2.id(), iah.clone()),
        (vb_member3.id(), iah.clone()),
        (vb_member4.id(), iah),
    ];

    let res = iah_issuer
        .call(registry_contract.id(), "sbt_mint")
        .args_json(json!({ "token_spec": token_spec }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success());

    Ok(Suite {
        hom_contract: hom_contract.to_owned(),
        vb_contract: vb_contract.to_owned(),
        alice,
        proposal_id,
        registry_contract,
        vb_members: vec![vb_member1, vb_member2, vb_member3, vb_member4],
    })
}

#[tokio::test]
async fn veto() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let proposal: Option<ProposalOutput> = setup
        .hom_contract
        .call("get_proposal")
        .args_json(json!({"id": setup.proposal_id}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(
        ProposalStatus::InProgress,
        proposal.unwrap().proposal.status
    );

    let create_prop_payload = CreatePropPayload {
        kind: voting_body::PropKind::Veto {
            dao: near_sdk::AccountId::new_unchecked(setup.hom_contract.id().to_string()),
            prop_id: 1,
        },
        description: "veto".to_string(),
    };

    // create veto proposal
    let res = setup.vb_members[0].call(setup.registry_contract.id(), "is_human_call")
    .args_json(json!({"ctr": setup.vb_contract.id(), "function": "create_proposal", "payload": serde_json::to_string(&create_prop_payload).unwrap()}))
    .max_gas()
    .deposit(parse_near!("2 N"))
    .transact()
    .await?;
    assert!(res.is_success(), "{:?}", res);

    let vote_payload = VotePayload {
        prop_id: 1,
        vote: Vote::Approve,
    };
    setup.vote(&vote_payload).await?;

    worker.fast_forward(10).await?;

    let res = setup
        .alice
        .call(setup.vb_contract.id(), "execute")
        .args_json(json!({"id": 1}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let proposal: Option<ProposalOutput> = setup
        .hom_contract
        .call("get_proposal")
        .args_json(json!({"id": 1}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(ProposalStatus::Vetoed, proposal.unwrap().proposal.status);

    Ok(())
}

#[tokio::test]
async fn dismiss() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let is_member: bool = setup
        .hom_contract
        .call("is_member")
        .args_json(json!({"account": setup.alice.id()}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(true, is_member);

    let create_prop_payload = CreatePropPayload {
        kind: voting_body::PropKind::Dismiss {
            dao: near_sdk::AccountId::new_unchecked(setup.hom_contract.id().to_string()),
            member: near_sdk::AccountId::new_unchecked(setup.alice.id().to_string()),
        },
        description: "dismiss".to_string(),
    };

    // create dismiss proposal
    let res = setup.vb_members[0].call(setup.registry_contract.id(), "is_human_call")
    .args_json(json!({"ctr": setup.vb_contract.id(), "function": "create_proposal", "payload": serde_json::to_string(&create_prop_payload).unwrap()}))
    .max_gas()
    .deposit(parse_near!("1 N"))
    .transact()
    .await?;
    assert!(res.is_success(), "{:?}", res);

    let vote_payload = VotePayload {
        prop_id: 1,
        vote: Vote::Approve,
    };
    setup.vote(&vote_payload).await?;

    worker.fast_forward(10).await?;

    let res = setup
        .alice
        .call(setup.vb_contract.id(), "execute")
        .args_json(json!({"id": 1}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let is_member: bool = setup
        .hom_contract
        .call("is_member")
        .args_json(json!({"account": setup.alice.id()}))
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(false, is_member);

    Ok(())
}

#[tokio::test]
async fn dissolve() -> anyhow::Result<()> {
    let worker = near_workspaces::sandbox().await?;
    let setup = init(&worker).await?;

    let is_dissolved: bool = setup.hom_contract.view("is_dissolved").await?.json()?;

    assert_eq!(false, is_dissolved);

    let create_prop_payload = CreatePropPayload {
        kind: voting_body::PropKind::Dissolve {
            dao: near_sdk::AccountId::new_unchecked(setup.hom_contract.id().to_string()),
        },
        description: "dissolve".to_string(),
    };

    // create dismiss proposal
    let res = setup.vb_members[0].call(setup.registry_contract.id(), "is_human_call")
    .args_json(json!({"ctr": setup.vb_contract.id(), "function": "create_proposal", "payload": serde_json::to_string(&create_prop_payload).unwrap()}))
    .max_gas()
    .deposit(parse_near!("2 N"))
    .transact()
    .await?;
    assert!(res.is_success(), "{:?}", res);

    let vote_payload = VotePayload {
        prop_id: 1,
        vote: Vote::Approve,
    };
    setup.vote(&vote_payload).await?;

    worker.fast_forward(10).await?;

    let res = setup
        .alice
        .call(setup.vb_contract.id(), "execute")
        .args_json(json!({"id": 1}))
        .max_gas()
        .transact()
        .await?;
    assert!(res.is_success(), "{:?}", res);

    let is_dissolved: bool = setup.hom_contract.view("is_dissolved").await?.json()?;

    assert_eq!(true, is_dissolved);

    Ok(())
}

'''