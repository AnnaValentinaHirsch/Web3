*GitHub Repository "nsejim/NEAR-ow3t"*

'''--- README.md ---
# OW3-T (Open Web 3 Tree)
## Introduction

OW3-T is a smart contrat that aims to support real-life contexts where stakeholders (humans, smart things, ..) aggregate a certain value in a trustless tree hierarchy. The current version of the smart contract considers "value" that can be represented by a numerical outcome. 

This smart contract is deployed on the NEAR TestNet with accountId or contractName "ow3t.nsejim.tesnet". 

Click [here](https://explorer.testnet.near.org/accounts/ow3t.nsejim.testnet) to explore OW3T transactions 
## Examples of real-life use cases
### 1. Large-scale service/product delivery 

Think about operational scenarios that require/involve a large scale of participants with delegation responsibility (outsourcing) organised in a tree hierarchy. The following are some examples that require large number of human resources to complete a service or deliver a product
- Periodically export 10,000 tons of coffee from East Africa to Europe
- Deploy and maintain billion of air quality sensors evenly deployed in all parts of the world.

### 2. Data aggregation in geo-distributed computer systems

There are more and more AI scenarios where centralizing collected data in the cloud in order to do AI analytics is not possible because data collectors are either either constrained by privacy-concerns or bandwidth connectivity. Therefore, data collectors carry out AI analytics locally and only share either the AI model updates (federated learning) or AI inference results. The AI results need to be bottom-up aggregated to create combined value. 

- [Secure verifiable aggregation for blockchain-based federated averaging](https://www.sciencedirect.com/science/article/pii/S2667295221000362)
## Installation

1. clone this repo
2. run `yarn` (or `npm install`)
3. run `yarn build` (or `npm run build`)

The contract source code is in `src/tree`
## Test Commands

**Compile assemblyscript source to WebAssembly**

```sh
yarn build                    # asb --target debug
yarn build:release            # asb
```

**Unit tests**

```sh
yarn test:unit                # asp --verbose --nologo -f unit.spec
```

**Integration script tests**

[Here](scripts/README.md) you find a README explaining how to use different integration scripts for the following tasks:

- Deploy the OW3T contract
- Create a tree
- Register nodes
- Update outcome achievements of each node
- Generating a report for a given node.
## UI Wireframes

**Homepage**

![homepage](wireframes/homepage.png)

<br/>

**Create tree**

![create-tree](wireframes/create-tree.png)
<br/>

**Tree page**

![tree-page](wireframes/tree-page.png)
<br/>

**Node page**

![node-page](wireframes/node-page.png)

<br/>

## File Structure

<img src="wireframes/code-structure.png" width="300">

## Future Works

### Smart contract clients

- Frontend Proof of Concept Development
### Scaling the smart contract (Support Cross-contract calls)

Update the smart contract to:
- Deploy a new contract for each tree. This will enable the tree's owner to be responsible of the storage staking of the tree data 
- Enable to have different type of contracts for different tree's nodes.

## Key Contributors

- [Jimmy NSENGA - @nsejim](https://github.com/nsejim)

'''
'''--- as-pect.config.js ---
module.exports = require("near-sdk-as/imports");
module.exports.include.push("**/*.unit.spec.ts");

'''
'''--- asconfig.json ---
{
  "workspaces": [
    "src/tree"
  ]
}

'''
'''--- package.json ---
{
  "name": "ow3t",
  "version": "1.0.0",
  "description": "A smart contrat to manage trustless transactions in a tree hiearchy",
  "scripts": {
    "dev": "watch -d -n 1 'clear && yarn test'",
    "test:unit": "yarn asp -f unit.spec",
    "clean": "rm -rf ./build && rm -rf ./neardev",
    "build": "asb --target debug",
    "build:release": "asb",
    "asp": "asp --verbose --nologo"
  },
  "keywords": [],
  "author": "jimmy.nsenga@gmail.com",
  "license": "ISC",
  "devDependencies": {
    "near-sdk-as": "^3.1.0"
  }
}

'''
'''--- scripts/1.dev-deploy.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 1: Build the contract (may take a few seconds)"
echo ---------------------------------------------------------
echo

yarn build

echo
echo
echo ---------------------------------------------------------
echo "Step 2: Deploy the contract"
echo
echo ---------------------------------------------------------
echo

near dev-deploy ./build/debug/tree.wasm

echo
echo
echo ---------------------------------------------------------
echo "Step 3: Prepare your environment for next steps"
echo
echo "(a) find the contract (account) name in the message above"
echo "    it will look like this: [ Account id: dev-###-### ]"
echo
echo "(b) set an environment variable using this account name"
echo "    see example below (this may not work on Windows)"
echo
echo ---------------------------------------------------------
echo 'export CONTRACT=<dev-123-456>'
echo ---------------------------------------------------------
echo

exit 0

'''
'''--- scripts/2.build-tree.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"
[ -z "$TREEOWNER" ] && echo "Missing \$TREEOWNER environment variable" && exit 1
[ -z "$TREEOWNER" ] || echo "Found it! \$TREEOWNER is set to [ $TREEOWNER ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: create a tree"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

[ -z "$1" ] && echo "Missing first argument as tree name. Should be a string" && exit 1
[ -z "$2" ] && echo "Missing second argument as tree outcome. SHould be a number" && exit 1

echo \$1 is [ $1 ] 
echo \$2 is [ $2 ]

near call $CONTRACT "createTree"  '{"name": "'"$1"'", "outcome": '$2'}' --accountId $TREEOWNER

'''
'''--- scripts/3.list-trees.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: list trees"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

near view $CONTRACT "getTrees" 

'''
'''--- scripts/4.register-node.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: create a tree"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

[ -z "$1" ] && echo "Missing 1st argument as senderId. Should be a string" && exit 1
[ -z "$2" ] && echo "Missing 2nd argument as treeId. Should be a string. Run list trees to get existing Ids" && exit 1
[ -z "$3" ] && echo "Missing 3rd argument as node accountId. Should be a string" && exit 1
[ -z "$4" ] && echo "Missing 4th argument as node assigned outcome. Should be a number" && exit 1
[ -z "$5" ] && echo "Missing 5th argument as node description. Should be a string" && exit 1

echo \$1 is [ $1 ] 
echo \$2 is [ $2 ]
echo \$3 is [ $3 ] 
echo \$4 is [ $4 ]
echo \$5 is [ $5 ] 

near call $CONTRACT "registerNode" '{"treeId": "'"$2"'", "newNodeAccountId": "'"$3"'", "assignedOutcome": '$4', "description": "'"$5"'" }' --accountId $1

'''
'''--- scripts/5.update-completed-outcome.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: create a tree"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

[ -z "$1" ] && echo "Missing 1st argument as senderId. Should be a string" && exit 1
[ -z "$2" ] && echo "Missing 2nd argument as treeId. Should be a string. Run list trees to get existing Ids" && exit 1
[ -z "$3" ] && echo "Missing 3rd argument as completed outcome. Should be a number" && exit 1

echo \$1 is [ $1 ] 
echo \$2 is [ $2 ]
echo \$3 is [ $3 ] 

near call $CONTRACT "updateCompletedOutcome" '{"treeId": "'"$2"'", "outcome": '$3' }' --accountId $1
'''
'''--- scripts/6.get-report.sh ---
#!/usr/bin/env bash

# exit on first error after this point to avoid redeploying with successful build
set -e

echo
echo ---------------------------------------------------------
echo "Step 0: Check for environment variables"
echo ---------------------------------------------------------
echo

[ -z "$CONTRACT" ] && echo "Missing \$CONTRACT environment variable" && exit 1
[ -z "$CONTRACT" ] || echo "Found it! \$CONTRACT is set to [ $CONTRACT ]"

echo
echo
echo ---------------------------------------------------------
echo "Step 1: list trees"
echo
echo "(run this script again to see changes made by this file)"
echo ---------------------------------------------------------
echo

[ -z "$1" ] && echo "Missing 1st argument as treeId. Should be a string. Run list trees to get existing Ids" && exit 1
[ -z "$2" ] && echo "Missing 2nd argument as node accountId. Should be a string" && exit 1

near view $CONTRACT "getReport"  '{"treeId": "'"$1"'", "accountId": "'"$2"'"}'

'''
'''--- scripts/README.md ---
# Introduction

Below is an example of a typical workflow to create a tree, register nodes, update outcome achievements of each node and generating a report for a given node

# Step-by-step process

The following process can be explored at [https://explorer.testnet.near.org/accounts/dev-1645171287689-40057017143222](https://explorer.testnet.near.org/accounts/dev-1645171287689-40057017143222)

## Deploy dev contract
./scripts/1.dev-deploy.sh 
## Create a tree
./scripts/2.build-tree.sh "Hello Tree" 100 

## List trees
./scripts/3.list-trees.sh  

```
[
  {
    ownerAccountId: 'nsejim.testnet',
    id: 'TREE-3707919279',
    name: 'Hello Tree',
    objective: '',
    outcome: 100
  }
]
```
## Register child nodes

### node 1
./scripts/4.register-node.sh "nsejim.testnet" 'TREE-3707919279'  "node1.nsejim.testnet"  30  "node1"

### node 2
./scripts/4.register-node.sh "nsejim.testnet" 'TREE-3707919279'  "node2.nsejim.testnet"  50  "node2"

## Each node update its completed outcome

./scripts/5.update-completed-outcome.sh "nsejim.testnet"  "TREE-3707919279" 5  <br/>
./scripts/5.update-completed-outcome.sh "node2.nsejim.testnet"  "TREE-3707919279" 20 <br/>
./scripts/5.update-completed-outcome.sh "node1.nsejim.testnet"  "TREE-3707919279" 10  <br/>

## Get report

./scripts/6.get-report.sh "TREE-3707919279"  "nsejim.testnet"
```
{
  node: {
    accountId: 'nsejim.testnet',
    assignedOutcome: 100,
    completedOutcome: 35,
    openOutcome: 10,
    depth: 0
  },
  children: [
    {
      accountId: 'node1.nsejim.testnet',
      assignedOutcome: 30,
      completedOutcome: 10,
      openOutcome: 20,
      depth: 1
    },
    {
      accountId: 'node2.nsejim.testnet',
      assignedOutcome: 50,
      completedOutcome: 20,
      openOutcome: 30,
      depth: 1
    },
    {
      accountId: 'node3.nsejim.testnet',
      assignedOutcome: 5,
      completedOutcome: 0,
      openOutcome: 5,
      depth: 1
    }
  ]
}
```
'''
'''--- src/as-pect.d.ts ---
/// <reference types="@as-pect/assembly/types/as-pect" />
'''
'''--- src/as_types.d.ts ---
/// <reference types="near-sdk-as/assembly/as_types" />
'''
'''--- src/tree/__tests__/index.unit.spec.ts ---

import { Context, VMContext } from 'near-sdk-as';
import { createTree, registerNode, getTodoOutcomeToDelegate, updateCompletedOutcome, getReport } from '../assembly/index';
import { nodes, trees, edges } from '../assembly/storage';

describe('Tree', () => {

    beforeEach(() => {
        VMContext.setSigner_account_id("nsejim.testnet");
    })

    describe('createTree method', () => {
        it('should Tree list be increased by 1 after creating a new Tree', () => {
            // Act
            const treeId = createTree("Export Coffee", 1000);
            
            // Assert
            expect(trees.length).toBe(1);
            expect(trees[0].id).toStrictEqual(treeId);
        })
    })

    describe('registerNode method', () => {
        itThrows("should fail when registering a node in an non-existant Tree", () => {
            registerNode("1", "toto.testnet", "Rwanda Country Manager", 200);
        })

        it('should register the creator of an Tree as a node and assign the quantity correctly', () => {
            // Act
            const treeId = createTree("Export Coffee", 1000);
    
            // Assert
            const orgNodesMap  = nodes.getSome(treeId);
            expect(orgNodesMap.has(Context.sender)).toBe(true);
            expect(orgNodesMap.get(Context.sender).assignedOutcome).toBe(1000);
        })

        it('should correctly initiate the relationship of the Tree creator', () => {
            // Act
            const treeId = createTree("Export Coffee", 1000);
    
            // Assert
            const orgRelationship = edges.getSome(treeId);
            expect(orgRelationship.get(Context.sender).parentAccountId).toBe(Context.sender);
            expect(orgRelationship.get(Context.sender).childAccountIds.length).toBe(0);  
        })

        it('should register the node as a child of the owner', () => {
            // Arrange
            const treeId = createTree("Export Coffee", 1000);
            
            // Act
            registerNode(treeId, "toto.testnet", "Rwanda Country Manager", 200);
            
            // Assert
            const orgNodesMap  = nodes.getSome(treeId);
            expect(orgNodesMap.has(Context.sender)).toBe(true);
            expect(orgNodesMap.has("toto.testnet")).toBe(true);
            const orgRelationship = edges.getSome(treeId);
            expect(orgRelationship.get(Context.sender).childAccountIds.length).toBe(1);
            expect(orgRelationship.get("toto.testnet").parentAccountId).toBe(Context.sender);
            expect(getTodoOutcomeToDelegate(treeId, Context.sender)).toBe(800);  
        })

        it('should each node have the correct depth', () => {
            // Arrange
            const treeId = createTree("Export Coffee", 1000);
            
            // Act
            registerNode(treeId, "toto.testnet", "Rwanda", 200);
            VMContext.setSigner_account_id("toto.testnet");
            registerNode(treeId, "alice.testnet", "RDC", 100);
            VMContext.setSigner_account_id("alice.testnet");
            registerNode(treeId, "bob.testnet", "Burundi", 50);

            // Assert
            const treeNodesMap = nodes.getSome(treeId);
            expect(treeNodesMap.get("nsejim.testnet").depth).toBe(0);
            expect(treeNodesMap.get("toto.testnet").depth).toBe(1);
            expect(treeNodesMap.get("alice.testnet").depth).toBe(2);
            expect(treeNodesMap.get("bob.testnet").depth).toBe(3);
        })

        itThrows('should fail when trying to allocate more than allowed', () => {
            const treeId = createTree("Export Coffee", 1000);
            registerNode(treeId, "toto.testnet", "Rwanda Country Manager", 2000);
        })

    })

    describe('updateCompletedOutcome method', () => {
        it('should correctly update the node counter', () => {
            // Arrange
            const treeId = createTree("Export Coffee", 1000);
            registerNode(treeId, "toto.testnet", "Rwanda", 200);
            registerNode(treeId, "alice.testnet", "RDC", 500);
            registerNode(treeId, "bob.testnet", "Burundi", 300);
            
            // Act
            VMContext.setSigner_account_id("alice.testnet");
            updateCompletedOutcome(treeId, 400);
            
            // Assert
            const openQuantity = getTodoOutcomeToDelegate(treeId, Context.sender);
            expect(openQuantity).toBe(100);
        })
    })

    describe('getReport method', () => {
        it('should correctly generate the complete report of a node', () => {
            // Arrange
            const treeId = createTree("Export Coffee", 1000);
            registerNode(treeId, "toto.testnet", "Rwanda", 200);
            registerNode(treeId, "alice.testnet", "RDC", 500);
            registerNode(treeId, "bob.testnet", "Burundi", 200);
            
            // Act
            updateCompletedOutcome(treeId, 80);
            VMContext.setSigner_account_id("alice.testnet");
            updateCompletedOutcome(treeId, 200);
            registerNode(treeId, "claude.testnet", "RDC", 100);
            VMContext.setSigner_account_id("claude.testnet");
            updateCompletedOutcome(treeId, 20);
            
            // Assert
            expect(getReport(treeId, "nsejim.testnet").children.length).toBe(3);
            expect(getReport(treeId, "alice.testnet").children.length).toBe(1);
            expect(getReport(treeId, "nsejim.testnet").node.completedOutcome).toBe(300);
            expect(getReport(treeId, "alice.testnet").node.completedOutcome).toBe(220);
        })
    })

})
'''
'''--- src/tree/asconfig.json ---
{
    "extends": "near-sdk-as/asconfig.json"
}
'''
'''--- src/tree/assembly/index.ts ---

import { AccountId, Node, Tree, TreeId, Edge, NodeReport, NodeCompleteReport } from './model';
import { context, logging } from 'near-sdk-as';
import { nodes, trees, edges } from './storage';
import { generateUniqueId } from '../../utils';

/**
 * A public method to create a tree with the provided information input
 *
 * @method
 * @param {string} name - the name of the tree
 * @param {i32} outcome - the numerical value representing the total targeted outcome
 * @param {string} [objective=''] - optional specific objective around the tree setup
 * @returns {string} - the id of the newly created tree
 */
export function createTree(name: string, outcome: i32, objective: string = ''): string {
  assert(outcome > 0, "Outcome quantity should be greater than 0");
  const treeId = generateUniqueId("TREE", _existingTreeIds());
  const newTree = new Tree(treeId, name, objective, outcome);
  trees.push(newTree);
  nodes.set(newTree.id, new Map<AccountId, Node>());
  edges.set(newTree.id, new Map<AccountId, Edge>());

  registerNode(newTree.id, context.sender, objective , outcome); // register root node
  logging.log(`Tree ${name} has been successfully created`)
  return newTree.id;
}

/**
 * A public method to register a node in a given tree with provided information
 * 
 * @param {TreeId} treeId - The id of the tree
 * @param {AccountId} newNodeAccountId - The NEAR accountId linked to the new node
 * @param {string} description - The description/specific objective of the node
 * @param {i32} assignedOutcome - The expected outcome
 */
export function registerNode(treeId: TreeId, newNodeAccountId: AccountId, description: string, assignedOutcome: i32): void{  
  assert(_findTreeIndex(treeId) > -1, "Tree not found!");
  assert(nodes.contains(treeId), "Tree nodes map not initiated!");
  assert(edges.contains(treeId), "Tree edges map not initiated!");

  const treeNodesMap = nodes.getSome(treeId);
  assert(!treeNodesMap.has(newNodeAccountId), "A node accountId can be registered only once !")

  if (context.sender != newNodeAccountId) {  // We don't have to make the below validation when creating the root node
    const todoOutcome = getTodoOutcomeToDelegate(treeId, context.sender);
    assert(assignedOutcome <= todoOutcome, "Cannot delegate more than " + todoOutcome.toString() + "allowed!")
  }

  const treeEdges = edges.getSome(treeId);
  treeEdges.set(newNodeAccountId, new Edge(context.sender, []))

  const parentEdge = treeEdges.get(context.sender);
  let depth = 0;
  if (context.sender != newNodeAccountId) { // Only register child if parent is different from child
    parentEdge.childAccountIds.push(newNodeAccountId);
    treeEdges.set(context.sender, parentEdge);
    depth = treeNodesMap.get(context.sender).depth + 1;
  } 
  edges.set(treeId, treeEdges);

  treeNodesMap.set(newNodeAccountId, new Node(description, assignedOutcome, depth))
  nodes.set(treeId, treeNodesMap);
  
  logging.log(`Node ${newNodeAccountId} has been successfully registered in tree with ${treeId}`)
}

/**
 * A public method to update completed outcome for the node related to the sender
 * 
 * @param {string} treeId - The id of the tree
 * @param {i32} outcome - The newly generated outcome
 */
export function updateCompletedOutcome(treeId: string, outcome: i32): void {
  assert(_findTreeIndex(treeId) > -1, "Tree not found!");
  const treeNodesMap = nodes.getSome(treeId);
  assert(treeNodesMap.has(context.sender), "The requested node has not been found !")

  const senderNode = treeNodesMap.get(context.sender);
  const todoOutcome = getTodoOutcomeToDelegate(treeId, context.sender);
  senderNode.updateCompletedOutcome(outcome, todoOutcome);
  treeNodesMap.set(context.sender, senderNode)
  nodes.set(treeId, treeNodesMap);

  logging.log(`Node ${context.sender} has been successfully updated its completed outcome`)
}

/**
 * A public method to get list of trees
 * 
 * @param {boolean} [affiliatedOnly=true] - A boolean to return either all trees or only affiliated trees 
 * @returns {Tree[]} - The list of trees
 */
export function getTrees(accountId: string = '', affiliatedOnly: boolean = true): Tree[] {
  let treeList: Tree[] = [];
  for (let index = 0; index < trees.length; index++) {
    const tree = trees[index];
    if (affiliatedOnly && accountId && nodes.getSome(tree.id).has(accountId)) {
      treeList.push(tree);
    } else {
      treeList.push(tree);
    }
  }
  return treeList;
}

/**
 * A public method to get the todo outcome

 * @param {TreeId} treeId - The id of the tree
 * @param {AccountId} accountId - The accountId related to a given node
 * @returns {i32}
 */
export function getTodoOutcomeToDelegate(treeId: TreeId, accountId: AccountId): i32 {
  assert(_findTreeIndex(treeId) > -1, "Tree not found!");
  let todoOutcome = nodes.getSome(treeId).get(accountId).assignedOutcome;
  for (let index = 0; index < edges.getSome(treeId).get(accountId).childAccountIds.length; index++) {
    const childAccountId = edges.getSome(treeId).get(accountId).childAccountIds[index];
    todoOutcome -= nodes.getSome(treeId).get(childAccountId).assignedOutcome
  }

  const treeNodesMap = nodes.getSome(treeId);
  const accountIdNode = treeNodesMap.get(accountId);
  todoOutcome -= accountIdNode.completedOutcome;
  return todoOutcome;
}

/**
 * A public method to get the report of a given node referenced by accountId

 * @param {string} treeId - The id of the tree
 * @param {string} accountId - The accountId related to a given node
 * @returns {NodeCompleteReport} - The complete report for a node
 */
 export function getReport(treeId: string, accountId: string): NodeCompleteReport {
  let nodeCompleteReport: NodeCompleteReport;
  assert(_findTreeIndex(treeId) > -1, "Tree not found!");
  const treeEdges = edges.getSome(treeId);
  assert(treeEdges.has(accountId), "The accountId is not found in the tree with ID = !" + treeId);
  const nodeEdges =  treeEdges.get(accountId);
  
  const childStates:  NodeReport[] = []
  
  let childrenCompletedOutcome = 0;
  for (let index = 0; index < nodeEdges.childAccountIds.length; index++) {
    const childAccountId = nodeEdges.childAccountIds[index];
    const childCompletedOutcome = _collectChildCompletedOutcome(treeId, childAccountId, 0)
    childStates.push(new NodeReport(
      childAccountId,
      nodes.getSome(treeId).get(childAccountId).assignedOutcome,
      childCompletedOutcome,
      getTodoOutcomeToDelegate(treeId, childAccountId),
      nodes.getSome(treeId).get(childAccountId).depth
    ))
    childrenCompletedOutcome += childCompletedOutcome
  }

  nodeCompleteReport = new NodeCompleteReport(
    new NodeReport(
      accountId,
      nodes.getSome(treeId).get(accountId).assignedOutcome,
      nodes.getSome(treeId).get(accountId).completedOutcome + childrenCompletedOutcome,
      getTodoOutcomeToDelegate(treeId, accountId),
      nodes.getSome(treeId).get(accountId).depth
    ), 
    childStates
  ); 

  return nodeCompleteReport
}

/**
 * A private method to recursively collect the outcome of all descendents of a given node
 *
 * @param {string} treeId - the id of the tree
 * @param {string} accountId - the accountId referencing a node within the tree 
 * @param {i32} totalOutcome - the total aggregated outcome
 * @returns {i32} - the outcome
 */
function _collectChildCompletedOutcome(treeId: string, accountId: string, totalOutcome: i32): i32 {
  assert(_findTreeIndex(treeId) > -1, "Tree not found!");
  const treeNodesMap = nodes.getSome(treeId);
  totalOutcome += treeNodesMap.get(accountId).completedOutcome;
  
  const treeEdges = edges.getSome(treeId);
  const nodeEdges =  treeEdges.get(accountId);

  for (let index = 0; index < nodeEdges.childAccountIds.length; index++) {
    const childAccountId = nodeEdges.childAccountIds[index];
    totalOutcome = _collectChildCompletedOutcome(treeId, childAccountId, totalOutcome)
  }

  return totalOutcome;
}

/**
 * A private method to find the index of a given tree in the list of trees
 * 
 *
 * @param {string} treeId - The id of the tree
 * @returns {i32} - The index with the tree list
 */
function _findTreeIndex(treeId: string): i32 {
  let i = 0;
  while ((i < trees.length) && (trees[i].id != treeId)) {
    i +=1;
  }
  return i < trees.length ? i : -1;
}

/**
 * A private method to find existing tree ids
 * @private
 * @returns {string[]} - List of existing ids
 */
function _existingTreeIds(): string[] {
  let ids: string[] = []
  for (let index = 0; index < trees.length; index++) {
      const Tree = trees[index];
      ids.push(Tree.id);
  }
  return ids;
}
'''
'''--- src/tree/assembly/model.ts ---
import { Context } from 'near-sdk-as';

/**
 * NEAR AccountId
 *
 * @typedef {AccountId}
 */
export type AccountId = string;

/**
 * TreeId - Unique identifier
 *
 * @typedef {TreeId}
 */
export type TreeId = string;

/**
 * Class representing a tree
 * @class Tree
 */
@nearBindgen
export class Tree {
    
    /**
     * @property {AccountId}  ownerAccountId - The NEAR accountId of the tree's owner.
     * @public
     */
    ownerAccountId: AccountId; 

    /**
     * Creates an instance of Tree.
     * @constructor
     * @param {string} id - a unique identifier of a tree
     * @param {string} name - the name of a tree
     * @param {string} objective - the objective of a tree
     * @param {u32} outcome - the maximum value of the global outcome to be produced
     */
    constructor(
        public id: string,
        public name: string,
        public objective: string,
        public outcome: u32
    ) {
        this.ownerAccountId = Context.sender;
    }
}

/**
 * Class representing a node within a tree
 * @class Node
 */
@nearBindgen
export class Node {

    /**
     * @member {u32} completedOutcome - outcome already completed by a specific node
     */
    completedOutcome: u32 = 0;

    /**
     * Creates an instance of Node.
     *
     * @constructor
     * @param {string} description
     * @param {u32} assignedOutcome
     * @param {u32} depth
     */
    constructor(
       public description: string,
       public assignedOutcome: u32,
       public depth: u32   // The number of edges from the root to the node
    ) {

    }

    updateCompletedOutcome(outcome: u32, todoOutcome: u32): void {
        assert(outcome <= todoOutcome, "You cannot report more than " + todoOutcome.toString() + "!")
        this.completedOutcome += outcome;
    }
}

/**
 * Class representing edge (relationship) between nodes
 * @class Edge
 */
@nearBindgen
export class Edge {
    /**
     * Creates an edge instance.
     *
     * @constructor
     * @param {AccountId} parentAccountId - The NEAR accountId of the node parent for a given node
     * @param {AccountId[]} childAccountIds - The list of NEAR accounIds of child nodes for a given node
     */
    constructor(
        public parentAccountId: AccountId,
        public childAccountIds: AccountId[]
    ) {

    }

} 

/**
 * Class representing the report of a single node
 * @class NodeReport
 */
 @nearBindgen
export class NodeReport {
    /**
     * Creates an instance of NodeReport.
     * 
     * @constructor
     * @param {AccountId} accountId - The NEAR accountId of a node
     * @param {i32} assignedOutcome - The assigned outcome of a node
     * @param {i32} completedOutcome - The completed outcome of a node
     * @param {i32} openOutcome - The open outcome of a node
     * @param {i32} depth - The distance from root node
     */
    constructor(
        public accountId: AccountId,
        public assignedOutcome: i32,
        public completedOutcome: i32,
        public openOutcome: i32,
        public depth: i32,
    ){}
}

/**
 * Class representing the complete report of a node
 * @class NodeCompleteReport
 */
@nearBindgen
export class NodeCompleteReport {
    /**
     * Creates an instance of NodeCompleteReport.
     * 
     * @constructor
     * @param {NodeReport} node - Specific report of a node
     * @param {NodeReport[]} children - Reports of child nodes
     */
    constructor (
        public node: NodeReport, 
        public children: NodeReport[]
    ) {}
}

'''
'''--- src/tree/assembly/storage.ts ---

import { PersistentVector } from 'near-sdk-as';
import { PersistentMap } from 'near-sdk-as';
import { AccountId, Node, Tree, TreeId, Edge } from './model';

/**
 * State to store the list of trees
 * @constant
 * @type {PersistentVector<Tree>}
 */
export const trees = new PersistentVector<Tree>("trees");

/**
 * State to store the map of nodes
 * @constant
 * @type {PersistentMap<TreeId, Map<AccountId, Node>>}
 */
export const nodes = new PersistentMap<TreeId, Map<AccountId, Node>>("nodes");

/**
 * State to store the map of edges (relationships)
 * @constant
 * @type {PersistentMap<TreeId, Map<AccountId, Edge>>}
 */
export const edges = new PersistentMap<TreeId, Map<AccountId, Edge>>("edges");

'''
'''--- src/tsconfig.json ---
{
  "extends": "../node_modules/assemblyscript/std/assembly.json",
  "include": ["./**/*.ts"]
}

'''
'''--- src/utils.ts ---
import { RNG } from "near-sdk-as";

/**
 * Generate a uniqueId with the provided prefix
 * @export
 * @param {string} prefix - The prefix to append the unique identifier
 * @param {string[]} ids - The list of existing Ids
 * @returns {string} - The new unique Id
 */
export function generateUniqueId(prefix: string, ids: string[]): string {
    const roll = new RNG<u32>(1, u32.MAX_VALUE);
    const id =  `${prefix}-${roll.next().toString()}`;
    if (ids.includes(id)) {
        return generateUniqueId(prefix, ids);
    }
    return id;
}
'''