*GitHub Repository "frol/near-devgov-badges"*

'''--- Cargo.toml ---
[package]
name = "near-devgov-badges"
version = "0.1.0"
edition = "2021"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = { version = "4.1.1", features = ["abi", "unstable"] }
near-contract-standards = "4.1.1"
schemars = "0.8"

[dev-dependencies]
near-workspaces = { version = "0.7", features = ["unstable"] }
tokio = "1"

[lib]
crate-type = ["cdylib"]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
# Opt into extra safety checks on arithmetic operations https://stackoverflow.com/a/64136471/249801
overflow-checks = true

'''
'''--- README.md ---
NEAR DevGov Badges
==================

[NEAR DevGov](https://neardevgov.org) Badges are designed to provide recognition incentives to the community contributors.

Currently, this repo hold the smart-contract implementation of [NEAR DevGov] Badges that is mainly going to be used on [GigsBoard on near.social](http://devgovgigs.near.social/).

This contract implementation strictly complies with NFT standard (NEP-171, NEP-177, NEP-181, and NEP-256), though `nft_transfer` and `nft_transfer_call` function calls always return an error if one would call them since Badges are non-transferrable by their nature.

## How to Deploy?

Here are the shell commands using [`near-cli-rs`](https://near.cli.rs) to deploy it on mainnet:

```sh
OWNER_ACCOUNT_ID=frol.near
CONTRACT_ACCOUNT_ID=devgov-badges.frol.near
CONTRACT_FILE_PATH=./target/near/near_devgov_badges.wasm

cargo near build --release

near-cli-rs account create-account fund-myself "$CONTRACT_ACCOUNT_ID" '5 NEAR' autogenerate-new-keypair save-to-keychain sign-as "$OWNER_ACCOUNT_ID"

near-cli-rs contract deploy "$CONTRACT_ACCOUNT_ID" \
  use-file "$CONTRACT_FILE_PATH" \
  with-init-call new_default_meta '{"moderators": ["frol.near"]}' --prepaid-gas '100 TeraGas' --attached-deposit '0 NEAR'
```

In order to re-deploy with a clean state, remove the account and deploy again:

```sh
near-cli-rs account delete-account "$CONTRACT_ACCOUNT_ID" beneficiary "$OWNER_ACCOUNT_ID"
```

## How to Mint a New Badge?

Given that the same badge can be rewarded to several users, it makes sense to deduplicate them and only create once and reward later (see next section to learn how to reward the badge to someone).

```sh
near-cli-rs contract call-function as-transaction "$CONTRACT_ACCOUNT_ID" \
  mint_badge json-args '{ "badge_id": "first_badge", "badge_metadata": { "title": "First Badge", "media": "bafybeibxixo6ntc7v7nwvatqbvbi3iug5wmlfillwq4lyjae2vg6rb7iim/1.gif", "description": "This is a test DevGov badge" } }' \
  prepaid-gas '100 TeraGas' \
  attached-deposit '1 yoctoNEAR'
```

## How to Reward (mint NFT)?

The Badges that are rewarded to accounts are fully-compliant with NFT standard (NEP-171, NEP-177, NEP-181, and NEP-256), so rewarded users will see their rewards across the ecosystem (including Wallets, NEAR Social, GigsBoard).

```sh
near-cli-rs contract call-function as-transaction "$CONTRACT_ACCOUNT_ID" \
  reward json-args '{"badge_id": "first_badge", "receiver_account_id": "frol.near"}' \
  prepaid-gas '100 TeraGas' \
  attached-deposit '1 yoctoNEAR'
```

'''
'''--- src/lib.rs ---
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NFT_METADATA_SPEC,
};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::{near_bindgen, AccountId, BorshStorageKey, PanicOnDefault};

pub mod nft_interfaces;
pub mod types;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
/// This contract powers [NEAR DevGov](https://neardevgov.org) Badges which gives recognition
/// incentives to the community contributors.
///
/// This contract implementation strictly complies with NFT standard (NEP-171, NEP-177, NEP-181,
/// and NEP-256), though `nft_transfer` and `nft_transfer_call` function calls always return an
/// error if one would call them as Badges are non-transferrable by their nature.
pub struct Contract {
    /// Currently, only a predefined list of moderators can mint new badges and reward them to
    /// accounts. Most probably, we will use DAO as the moderator account to ensure
    /// decentralization and scale DevGov badges.
    moderators: Vec<AccountId>,
    /// Standard NFT metadata, nothing more than that.
    metadata: LazyOption<NFTContractMetadata>,
    /// Unique badges that can be rewarded (at which point NFT is minted)
    badges: near_sdk::store::UnorderedMap<crate::types::BadgeId, crate::types::BadgeMetadata>,
    /// NOTE: It is assumed that a single account will have under a hundred badges, so it is better
    /// to fetch the whole list with a single storage read rather than storing each owned badge id
    /// separately.
    badges_by_owner: near_sdk::store::LookupMap<AccountId, Vec<crate::types::BadgeId>>,
    /// NOTE: nft_tokens with pagination implementation requires efficient way to iterate over all
    /// the minted NFTs, so we need to keep track of them.
    rewarded_badges: near_sdk::store::UnorderedSet<crate::types::TokenId>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    Metadata,
    Badges,
    BadgesByOwner,
    RewardedBadges,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(moderators: Vec<AccountId>) -> Self {
        Self::new(
            moderators,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "NEAR Developer Governance Badges".to_string(),
                symbol: "NEAR DevGov".to_string(),
                icon: None,
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(moderators: Vec<AccountId>, metadata: NFTContractMetadata) -> Self {
        metadata.assert_valid();
        Self {
            moderators,
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
            badges: near_sdk::store::UnorderedMap::new(StorageKey::Badges),
            badges_by_owner: near_sdk::store::LookupMap::new(StorageKey::BadgesByOwner),
            rewarded_badges: near_sdk::store::UnorderedSet::new(StorageKey::RewardedBadges),
        }
    }

    #[payable]
    pub fn mint_badge(
        &mut self,
        badge_id: crate::types::BadgeId,
        badge_metadata: crate::types::BadgeMetadata,
    ) {
        near_sdk::assert_one_yocto();
        assert!(
            self.moderators
                .contains(&near_sdk::env::predecessor_account_id()),
            "Unauthorized"
        );
        let mut badge_metadata = badge_metadata;
        badge_metadata.copies = Some(0);
        if self.badges.insert(badge_id, badge_metadata).is_some() {
            near_sdk::env::panic_str("Badge with such ID already exists");
        }
    }

    pub fn get_badge(&self, badge_id: crate::types::BadgeId) -> Option<crate::types::Badge> {
        self.badges
            .get(&badge_id)
            .map(|badge_metadata| crate::types::Badge {
                badge_id,
                badge_metadata: badge_metadata.clone(),
            })
    }

    pub fn get_badges(
        &self,
        from_index: Option<near_sdk::json_types::U128>,
        limit: Option<u64>,
    ) -> Vec<crate::types::Badge> {
        let from_index = from_index.map(|v| v.0.try_into().unwrap()).unwrap_or(0);
        near_sdk::require!(
            usize::try_from(self.badges.len()).unwrap() >= from_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v.try_into().unwrap()).unwrap_or(usize::MAX);
        near_sdk::require!(limit != 0, "Cannot provide limit of 0.");
        self.badges
            .iter()
            .skip(from_index)
            .take(limit)
            .map(|(badge_id, badge_metadata)| crate::types::Badge {
                badge_id: badge_id.clone(),
                badge_metadata: badge_metadata.clone(),
            })
            .collect()
    }

    #[payable]
    pub fn reward(
        &mut self,
        badge_id: crate::types::BadgeId,
        receiver_account_id: AccountId,
        memo: Option<String>,
    ) {
        near_sdk::assert_one_yocto();
        assert!(
            self.moderators
                .contains(&near_sdk::env::predecessor_account_id()),
            "Unauthorized"
        );
        let badge = self
            .badges
            .get_mut(&badge_id)
            .expect("There is no badge with the given ID");
        badge.copies = Some(badge.copies.unwrap_or(0) + 1);

        let token_id = crate::types::get_token_id(&badge_id, &receiver_account_id);
        if self.rewarded_badges.contains(&token_id) {
            near_sdk::env::panic_str("Badge has already been rewarded to this user previously");
        }
        self.rewarded_badges.insert(token_id.clone());
        self.badges_by_owner
            .entry(receiver_account_id.clone())
            .or_default()
            .push(badge_id.clone());

        near_contract_standards::non_fungible_token::events::NftMint {
            owner_id: &receiver_account_id,
            token_ids: &[&token_id],
            memo: memo.as_deref(),
        }
        .emit();
    }
}

'''
'''--- src/nft_interfaces.rs ---
use near_contract_standards::non_fungible_token::core::{
    NonFungibleTokenCore, NonFungibleTokenResolver,
};
use near_contract_standards::non_fungible_token::enumeration::NonFungibleTokenEnumeration;
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider
};
use near_sdk::{near_bindgen, AccountId, PromiseOrValue};

use crate::{Contract, ContractExt};
use crate::types::{Token, TokenId};

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    #[allow(unused_variables)]
    #[payable]
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        near_sdk::env::panic_str("NFT transfers is not allowed for NEAR DevGov badges");
    }

    #[allow(unused_variables)]
    #[payable]
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        near_sdk::env::panic_str("NFT transfers is not allowed for NEAR DevGov badges");
    }

    fn nft_token(&self, token_id: TokenId) -> Option<Token> {
        let (badge_id, owner_account_id) = crate::types::parse_token_id(&token_id).unwrap();
        if !self
            .rewarded_badges
            .contains(&crate::types::get_token_id(&badge_id, &owner_account_id))
        {
            return None;
        }
        let badge = self.badges.get(&badge_id)?;
        Some(Token {
            token_id,
            owner_id: owner_account_id,
            metadata: Some(badge.clone()),
            approved_account_ids: None,
        })
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    #[allow(unused_variables)]
    #[private]
    fn nft_resolve_transfer(
        &mut self,
        previous_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<std::collections::HashMap<AccountId, u64>>,
    ) -> bool {
        near_sdk::env::panic_str("NFT transfers is not allowed for NEAR DevGov badges");
    }
}

#[near_bindgen]
impl NonFungibleTokenEnumeration for Contract {
    fn nft_total_supply(&self) -> near_sdk::json_types::U128 {
        u128::from(self.rewarded_badges.len()).into()
    }

    fn nft_tokens(
        &self,
        from_index: Option<near_sdk::json_types::U128>,
        limit: Option<u64>,
    ) -> Vec<Token> {
        let from_index: usize = from_index.map(|v| v.0.try_into().unwrap()).unwrap_or(0);
        near_sdk::require!(
            usize::try_from(self.rewarded_badges.len()).unwrap() >= from_index,
            "Out of bounds, please use a smaller from_index."
        );
        let limit = limit.map(|v| v.try_into().unwrap()).unwrap_or(usize::MAX);
        near_sdk::require!(limit != 0, "Cannot provide limit of 0.");

        self.rewarded_badges
            .iter()
            .skip(from_index)
            .take(limit)
            .map(|token_id| {
                let (badge_id, owner_account_id) = crate::types::parse_token_id(token_id)
                    .expect("invalid contract storage state: token_id cannot be parsed");
                let badge = self
                    .badges
                    .get(&badge_id)
                    .expect("invalid contract storage state: missing badge");
                Token {
                    token_id: token_id.clone(),
                    owner_id: owner_account_id,
                    metadata: Some(badge.clone()),
                    approved_account_ids: None,
                }
            })
            .collect()
    }

    fn nft_supply_for_owner(&self, account_id: AccountId) -> near_sdk::json_types::U128 {
        u128::try_from(
            self.badges_by_owner
                .get(&account_id)
                .map(|badge_ids| badge_ids.len())
                .unwrap_or(0),
        )
        .unwrap()
        .into()
    }

    fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<near_sdk::json_types::U128>,
        limit: Option<u64>,
    ) -> Vec<Token> {
        let from_index = from_index.map(|v| v.0.try_into().unwrap()).unwrap_or(0);
        let limit = limit.map(|v| v.try_into().unwrap()).unwrap_or(usize::MAX);
        near_sdk::require!(limit != 0, "Cannot provide limit of 0.");

        let Some(owned_badges) = self.badges_by_owner.get(&account_id) else { return vec![]; };
        owned_badges
            .iter()
            .skip(from_index)
            .take(limit)
            .map(|badge_id| {
                let badge = self
                    .badges
                    .get(badge_id)
                    .expect("invalid contract storage state: missing badge");
                Token {
                    token_id: crate::types::get_token_id(badge_id, &account_id),
                    owner_id: account_id.clone(),
                    metadata: Some(badge.clone()),
                    approved_account_ids: None,
                }
            })
            .collect()
    }
}

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- src/types.rs ---
pub use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::AccountId;

pub type BadgeId = String;
pub type BadgeMetadata = near_contract_standards::non_fungible_token::metadata::TokenMetadata;

#[derive(Debug, near_sdk::serde::Serialize, schemars::JsonSchema)]
#[serde(crate = "near_sdk::serde")]
pub struct Badge {
    pub badge_id: BadgeId,
    pub badge_metadata: BadgeMetadata,
}

pub fn get_token_id(badge_id: &BadgeId, owner_account_id: &AccountId) -> TokenId {
    format!("{badge_id}:{owner_account_id}")
}

pub fn parse_token_id(token_id: &TokenId) -> Result<(BadgeId, AccountId), ParseTokenIdError> {
    let (badge_id, account_id) = token_id
        .split_once(':')
        .ok_or(ParseTokenIdError::NoSeparator)?;
    Ok((BadgeId::from(badge_id), account_id.parse()?))
}

#[derive(Debug)]
pub enum ParseTokenIdError {
    NoSeparator,
    InvalidAccountId,
}

impl From<near_sdk::ParseAccountIdError> for ParseTokenIdError {
    fn from(_err: near_sdk::ParseAccountIdError) -> Self {
        Self::InvalidAccountId
    }
}

'''
'''--- tests/happy_path.rs ---
use near_sdk::serde_json::{self, json};

#[tokio::test]
async fn test_contract() -> Result<(), Box<dyn std::error::Error>> {
    dbg!("Compiling the contract...");
    let wasm = near_workspaces::compile_project(".").await?;

    let worker = near_workspaces::sandbox().await?;

    dbg!("Deploying the contract...");
    let contract = worker.dev_deploy(&wasm).await?;

    dbg!("Creating moderator account...");
    let moderator_account = worker.dev_create_account().await?;

    dbg!("Initializing the badges contract...");
    contract
        .call("new_default_meta")
        .args_json(json!({
            "moderators": [moderator_account.id()],
        }))
        .transact()
        .await?
        .into_result()?;

    dbg!("Preparing contributors' accounts...");
    let devgov_contributor_account_1 = worker.dev_create_account().await?;
    let devgov_contributor_account_2 = worker.dev_create_account().await?;

    dbg!("Ensuring that badges list is empty before we start (sanity check)...");
    let badges: serde_json::Value = contract
        .call("get_badges")
        .args_json(json!({}))
        .view()
        .await?
        .json()?;
    assert_eq!(badges, json!([]));

    dbg!("Minting a new badge (not awarded to anyone yet)...");
    moderator_account
        .call(contract.id(), "mint_badge")
        .args_json(json!({
            "badge_id": "first_badge",
            "badge_metadata": {
                "title": "First Badge",
            }
        }))
        .deposit(1)
        .transact()
        .await?
        .into_result()?;

    dbg!("Ensuring that the badge is recorded and available via the getter method...");
    let badges: serde_json::Value = contract
        .call("get_badges")
        .args_json(json!({}))
        .view()
        .await?
        .json()?;
    assert_eq!(
        badges,
        json!([
            {
                "badge_id": "first_badge",
                "badge_metadata": {
                    "title": "First Badge",
                    "copies": 0,
                    "description": null,
                    "expires_at": null,
                    "extra": null,
                    "issued_at": null,
                    "media": null,
                    "media_hash": null,
                    "reference": null,
                    "reference_hash": null,
                    "starts_at": null,
                    "updated_at": null
                }
            }
        ])
    );

    dbg!("Rewardning devgov_contributor_1 with the first_badge...");
    let reward_result = moderator_account
        .call(contract.id(), "reward")
        .args_json(json!({
            "badge_id": "first_badge",
            "receiver_account_id": devgov_contributor_account_1.id(),
        }))
        .deposit(1)
        .transact()
        .await?
        .into_result()?;
    assert_eq!(
        reward_result.logs()[0],
        format!(
            r#"EVENT_JSON:{{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{{"owner_id":"{owner_id}","token_ids":["first_badge:{owner_id}"]}}]}}"#,
            owner_id = devgov_contributor_account_1.id()
        )
    );

    dbg!("Checking that the rewarded token is in the list of all NFTs...");
    let all_nft_tokens: serde_json::Value = contract
        .call("nft_tokens")
        .args_json(json!({}))
        .view()
        .await?
        .json()?;
    assert_eq!(
        all_nft_tokens,
        json!([
            {
                "token_id": format!("first_badge:{}", devgov_contributor_account_1.id()),
                "owner_id": devgov_contributor_account_1.id(),
                "metadata": {
                    "title": "First Badge",
                    "copies": 1,
                    "description": null,
                    "expires_at": null,
                    "extra": null,
                    "issued_at": null,
                    "media": null,
                    "media_hash": null,
                    "reference": null,
                    "reference_hash": null,
                    "starts_at": null,
                    "updated_at": null
                },
                "approved_account_ids": null,
            }
        ])
    );

    dbg!("Checking that the rewarded token is fetchable by token_id...");
    let devgov_contributor_account_1_tokens: serde_json::Value = contract
        .call("nft_token")
        .args_json(json!({"token_id": format!("first_badge:{}", devgov_contributor_account_1.id())}))
        .view()
        .await?
        .json()?;
    assert_eq!(
        devgov_contributor_account_1_tokens,
        json!({
            "token_id": format!("first_badge:{}", devgov_contributor_account_1.id()),
            "owner_id": devgov_contributor_account_1.id(),
            "metadata": {
                "title": "First Badge",
                "copies": 1,
                "description": null,
                "expires_at": null,
                "extra": null,
                "issued_at": null,
                "media": null,
                "media_hash": null,
                "reference": null,
                "reference_hash": null,
                "starts_at": null,
                "updated_at": null
            },
            "approved_account_ids": null,
        })
    );

    dbg!("Checking that the rewarded token is in the list of owned NFTs for the devgov_contributor_1...");
    let devgov_contributor_account_1_tokens: serde_json::Value = contract
        .call("nft_tokens_for_owner")
        .args_json(json!({"account_id": devgov_contributor_account_1.id()}))
        .view()
        .await?
        .json()?;
    assert_eq!(
        devgov_contributor_account_1_tokens,
        json!([
            {
                "token_id": format!("first_badge:{}", devgov_contributor_account_1.id()),
                "owner_id": devgov_contributor_account_1.id(),
                "metadata": {
                    "title": "First Badge",
                    "copies": 1,
                    "description": null,
                    "expires_at": null,
                    "extra": null,
                    "issued_at": null,
                    "media": null,
                    "media_hash": null,
                    "reference": null,
                    "reference_hash": null,
                    "starts_at": null,
                    "updated_at": null
                },
                "approved_account_ids": null,
            }
        ])
    );

    dbg!("Ensuring that the devgov_contributor_2 does not have any badges yet...");
    let devgov_contributor_account_2_tokens: serde_json::Value = contract
        .call("nft_tokens_for_owner")
        .args_json(json!({"account_id": devgov_contributor_account_2.id()}))
        .view()
        .await?
        .json()?;
    assert_eq!(devgov_contributor_account_2_tokens, json!([]));

    Ok(())
}

'''