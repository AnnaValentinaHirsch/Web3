*GitHub Repository "NiFTyRent/nft-rental"*

'''--- .github/workflows/ci.yml ---
name: Continuous integration

on: [pull_request, push]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - run: yarn run deps-install
      - run: yarn run test

'''
'''--- .gitpod.yml ---
tasks:
  - init: npm dev
    command: npm run dev
ports:
  - port: 1234
    onOpen: open-browser

'''
'''--- README.md ---
# NiftyRent

## Quick Start

If you haven't installed dependencies during setup:

    yarn deps-install

To deploy the rental dev contract on testnet

    yarn deploy

Initilise the rental dev contract

    export OWNER=<your test account id>
    export RENTAL_CONTRACT=`cat contract/neardev/dev-account`
    near call $RENTAL_CONTRACT new "{\"owner_id\": \"$OWNER\"}" --accountId $OWNER

Deploy the marketplace dev contract on testnet

    yarn deploy:marketplace

Initilise the marketplace dev contract

    export MARKETPLACE_CONTRACT=`cat marketplace/neardev/dev-account`
    near call $MARKETPLACE_CONTRACT new "{\"owner_id\": \"$OWNER\", \"treasury_id\": \"$OWNER\", \"rental_contract_id\": \"$RENTAL_CONTRACT\"}" --accountId $OWNER

Add and register allowed FTs for both contracts

    near repl -s ./scripts/set_allowed_fts.js --accountId $OWNER

Add allowed NFT contracts for the marketplace contract

    near call $MARKETPLACE_CONTRACT add_allowed_nft_contract_ids '{"nft_contract_ids": ["niftyrpg.mintspace2.testnet"]}' --accountId $OWNER
    // You can add more testing NFT contracts

To start dev server

    yarn start

## Allowed FT contract addresses

For now, the contract only allow a limited number of FTs as the rent payment currency options.

To check the current list:

    near call $CONTRACT_NAME get_allowed_ft_contract_addrs "" --accountId $ACCOUNT_ID

To set the list (for the testnet for example):

UPDATE: there is script automates the following: `./scripts/set_allowed_fts.js`

    near call $CONTRACT_NAME set_allowed_ft_contract_addrs '{"addrs": ["wrap.testnet", "usdc.fakes.testnet"]}' --accountId $ACCOUNT_ID

Bear in mind that you need to make sure:

1. `$ACCOUNT_ID` is the owner of the contract. (Only owner can change the list.)
2. the contract itself have been registered in the FT contract for the storage deposit. For example, you can: `near call usdc.fakes.testnet storage_deposit "{\"account_id\": \"$CONTRACT_NAME\", \"registration_only\": true}" --accountId $ACCOUNT_ID --amount 0.1`

Once updated, the UI should automatically pick up the new list of allowed FTs.

'''
'''--- contract/Cargo.toml ---
[package]
name = "nft_rental"
version = "1.0.0"
authors = ["Libo <liboooshen@gmail.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-contract-standards = "4.1.1"
near-sdk = "4.0.0"
# near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }
# near-crypto = "0.14.0"
# getrandom = { version = "0.2", features = ["js"] }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- contract/README.md ---
Welcome to NiFTyRent!
=================================

The [smart contract] written in [Rust] for [NiFTyRent].

Quick Start
===========

Before you compile this code, you will need to install Rust with [correct target]

Please also refer to ~/README.md for setup.

Exploring The Code
==================

1. The main smart contract code lives in `src/lib.rs`.
2. Tests: You can run unit tests with the `yarn test:unit`.

  [smart contract]: https://docs.near.org/develop/welcome
  [Rust]: https://www.rust-lang.org/
  [NiFTyRent]: https://testnet.niftyrent.xyz/
  [correct target]: https://docs.near.org/develop/prerequisites#rust-and-wasm

'''
'''--- contract/src/externals.rs ---
use crate::*;

/// Interface of this contract
// TODO(libo): explicitly implement this trait.
#[ext_contract(ext_self)]
trait ExtSelf {
    fn activate_lease(&mut self, lease_id: LeaseId) -> PromiseOrValue<U128>;
    fn resolve_claim_back(&mut self, lease_id: LeaseId) -> Promise;
}

/// NFT interface, for cross-contract calls
/// For details, refer to NEP-171
#[ext_contract(ext_nft)]
pub trait Nft {
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        approval_id: Option<u64>,
        memo: Option<String>,
    );

    /// Payout Support
    /// See https://nomicon.io/Standards/Tokens/NonFungibleToken/Payout
    fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: String,
        approval_id: Option<u64>,
        memo: Option<String>,
        balance: U128,
        max_len_payout: Option<u32>,
    );
}

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
}

'''
'''--- contract/src/lib.rs ---
use std::collections::HashMap;

use near_contract_standards::non_fungible_token::events::NftBurn;
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{Base64VecU8, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{bs58, ext_contract, require, serde_json::json, CryptoHash, PromiseOrValue};
use near_sdk::{env, near_bindgen, AccountId, BorshStorageKey, Gas, PanicOnDefault, Promise};

mod externals;
mod nft;
mod utils;
use crate::externals::*;

// Copied from Paras market contract. Will need to be fine-tuned.
// https://github.com/ParasHQ/paras-marketplace-contract/blob/2dcb9e8b3bc8b9d4135d0f96f0255cd53116a6b4/paras-marketplace-contract/src/lib.rs#L17
pub const TGAS: u64 = 1_000_000_000_000;
pub const XCC_GAS: Gas = Gas(5 * TGAS); // cross contract gas
pub const GAS_FOR_NFT_TRANSFER: Gas = Gas(5 * TGAS);
pub const BASE_GAS: Gas = Gas(5 * TGAS);
pub const GAS_FOR_ROYALTIES: Gas = BASE_GAS;
pub const GAS_FOR_RESOLVE_CLAIM_BACK: Gas = Gas(BASE_GAS.0 * 10u64);
// the tolerance of lease price minus the sum of payout
// Set it to 1 to avoid linter error
pub const PAYOUT_DIFF_TORLANCE_YACTO: u128 = 1;
pub const MAX_LEN_PAYOUT: u32 = 50;

pub type LeaseId = String;
pub type ListingId = String; // marketplace listing_id
pub type PayoutHashMap = HashMap<AccountId, U128>;

/// A mapping of NEAR accounts to the amount each should be paid out, in
/// the event of a token-sale. The payout mapping MUST be shorter than the
/// maximum length specified by the financial contract obtaining this
/// payout data. Any mapping of length 10 or less MUST be accepted by
/// financial contracts, so 10 is a safe upper limit.
/// See more: https://nomicon.io/Standards/Tokens/NonFungibleToken/Payout#reference-implementation
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: PayoutHashMap,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub enum LeaseState {
    PendingOnRent,
    Active,
}
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct LeaseJson {
    nft_contract_id: AccountId,
    nft_token_id: TokenId,
    lender_id: AccountId,
    borrower_id: AccountId,
    ft_contract_addr: AccountId,
    price: U128,
    start_ts_nano: u64,
    end_ts_nano: u64,
    nft_payout: Payout,
}

/// Struct for keeping track of the lease conditions
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct LeaseCondition {
    pub contract_addr: AccountId,    // NFT contract
    pub token_id: TokenId,           // NFT token
    pub lender_id: AccountId,        // Owner of the NFT
    pub borrower_id: AccountId,      // Borrower of the NFT
    pub ft_contract_addr: AccountId, // the account id for the ft contract
    pub start_ts_nano: u64, // The timestamp in nano to start the lease, i.e. the current user will be the borrower
    pub end_ts_nano: u64, // The timestamp in nano to end the lease, i.e. the lender can claim back the NFT
    pub price: U128,      // Proposed lease price
    pub payout: Option<Payout>, // Payout info (e.g. for Royalty split)
    pub state: LeaseState, // Current lease state
}

#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct ContractV1 {
    owner: AccountId,
    lease_map: UnorderedMap<LeaseId, LeaseCondition>,
    lease_ids_by_lender: LookupMap<AccountId, UnorderedSet<LeaseId>>,
    lease_ids_by_borrower: LookupMap<AccountId, UnorderedSet<LeaseId>>,
    lease_id_by_contract_addr_and_token_id: LookupMap<(AccountId, TokenId), LeaseId>,
    active_lease_ids: UnorderedSet<LeaseId>, // This also records all existing LEASE token ids
    active_lease_ids_by_lender: LookupMap<AccountId, UnorderedSet<LeaseId>>,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    owner: AccountId,
    lease_map: UnorderedMap<LeaseId, LeaseCondition>,
    lease_ids_by_lender: LookupMap<AccountId, UnorderedSet<LeaseId>>,
    lease_ids_by_borrower: LookupMap<AccountId, UnorderedSet<LeaseId>>,
    lease_id_by_contract_addr_and_token_id: LookupMap<(AccountId, TokenId), LeaseId>, // <(NFT_contract, token_id), lease_id>

    active_lease_ids: UnorderedSet<LeaseId>, // This also records all existing LEASE token ids
    active_lease_ids_by_lender: LookupMap<AccountId, UnorderedSet<LeaseId>>,

    // Allowlist of the contract addresses of the FT for the rent payment currency.
    // It's ok to load all allowed FT addresses into memory at once, since it's won't be long.
    allowed_ft_contract_addrs: Vec<AccountId>,
}

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    LendingsKey,
    LeaseIdsByLender,
    LeasesIdsByLenderInner { account_id_hash: CryptoHash },
    LeaseIdsByBorrower,
    LeaseIdsByBorrowerInner { account_id_hash: CryptoHash },
    LeaseIdByContractAddrAndTokenId,
    ActiveLeaseIdsByOwner,
    ActiveLeaseIdsByOwnerInner { account_id_hash: CryptoHash },
    ActiveLeaseIds,
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct RentAcceptanceJson {
    nft_contract_id: AccountId,
    nft_token_id: TokenId,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            owner: owner_id,
            lease_map: UnorderedMap::new(StorageKey::LendingsKey),
            lease_ids_by_lender: LookupMap::new(StorageKey::LeaseIdsByLender),
            lease_ids_by_borrower: LookupMap::new(StorageKey::LeaseIdsByBorrower),
            lease_id_by_contract_addr_and_token_id: LookupMap::new(
                StorageKey::LeaseIdByContractAddrAndTokenId,
            ),
            active_lease_ids_by_lender: LookupMap::new(StorageKey::ActiveLeaseIdsByOwner),
            active_lease_ids: UnorderedSet::new(StorageKey::ActiveLeaseIds),
            allowed_ft_contract_addrs: Vec::new(),
        }
    }

    /// A temporary method to completely reset the contract state.
    /// It's the last resort to recover when the contract state got corrupted.
    /// Inspired by: https://gist.github.com/ilyar/19bdc04d1aa09ae0fc84eb4297df1a1d
    #[private]
    #[init(ignore_state)]
    pub fn clean(owner_id: AccountId, keys: Vec<Base64VecU8>) -> Self {
        for key in keys.iter() {
            env::storage_remove(&key.0);
        }
        Self::new(owner_id)
    }

    /// Note: This migration function will clear all existing leases.
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let prev: ContractV1 = env::state_read().expect("ERR_NOT_INITIALIZED");
        assert_eq!(
            env::predecessor_account_id(),
            prev.owner,
            "Only the owner can invoke the migration"
        );

        Self::new(prev.owner)
    }

    fn activate_lease(&mut self, lease_id: LeaseId) {
        let lease_condition: LeaseCondition = self.lease_map.get(&lease_id).unwrap();
        let new_lease_condition = LeaseCondition {
            state: LeaseState::Active,
            ..lease_condition
        };
        self.lease_map.insert(&lease_id, &new_lease_condition);

        env::log_str(
            &json!({
                "type": "[INFO] NiFTyRent Rental: A lease has been activated",
                "params": {
                    "lease_id": lease_id.clone(),
                    "lease_state": new_lease_condition.state,
                    "nft_contract": new_lease_condition.contract_addr.clone(),
                    "nft_token_id": new_lease_condition.token_id.clone(),
                }
            })
            .to_string(),
        );

        self.nft_mint(lease_id, new_lease_condition.lender_id.clone());
    }

    #[payable]
    pub fn claim_back(&mut self, lease_id: LeaseId) {
        // Function to allow a user to claim back the NFT and rent after a lease expired.

        let lease_condition: LeaseCondition = self.lease_map.get(&lease_id).unwrap();

        // 1. check expire time
        assert!(
            lease_condition.end_ts_nano < env::block_timestamp(),
            "Lease has not expired yet!"
        );
        // 2. check state == active
        assert_eq!(
            lease_condition.state,
            LeaseState::Active,
            "Queried Lease is not active!"
        );

        // 3. only the current lease lender or service contract owner can claim back from expried lease
        assert!(
            (lease_condition.lender_id == env::predecessor_account_id())
                || (self.owner == env::predecessor_account_id()),
            "Only original lender or service owner can claim back!"
        );

        // 4. transfer nft to owner
        ext_nft::ext(lease_condition.contract_addr.clone())
            .with_static_gas(Gas(5 * TGAS))
            .with_attached_deposit(1)
            .nft_transfer(
                lease_condition.lender_id.clone(),
                lease_condition.token_id.clone(),
                None,
                None,
            )
            // 5. Pay the rent to lender and royalty to relevant parties. Finally remove the lease.
            .then(
                ext_self::ext(env::current_account_id())
                    .with_attached_deposit(0)
                    .with_static_gas(GAS_FOR_RESOLVE_CLAIM_BACK)
                    .resolve_claim_back(lease_id),
            );
    }

    #[private]
    pub fn resolve_claim_back(&mut self, lease_id: LeaseId) {
        // TODO: avoid re-fetch lease condition
        let lease_condition: LeaseCondition = self.lease_map.get(&lease_id).unwrap();

        match lease_condition.payout {
            Some(payout) => {
                for (receiver_id, amount) in payout.payout {
                    self.internal_transfer_ft(
                        lease_condition.ft_contract_addr.clone(),
                        receiver_id,
                        amount,
                    );
                }
            }
            None => {
                self.internal_transfer_ft(
                    lease_condition.ft_contract_addr.clone(),
                    lease_condition.lender_id,
                    U128::from(lease_condition.price),
                );
            }
        }

        self.internal_remove_lease(&lease_id);
    }

    // private function to transfer FT to receiver_id
    fn internal_transfer_ft(
        &self,
        ft_contract_addr: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> Promise {
        ext_ft_core::ext(ft_contract_addr)
            .with_static_gas(Gas(10 * TGAS))
            .with_attached_deposit(1)
            .ft_transfer(receiver_id, amount, None)
            .as_return()
    }

    pub fn leases_by_owner(&self, account_id: AccountId) -> Vec<(String, LeaseCondition)> {
        let mut results: Vec<(String, LeaseCondition)> = vec![];

        let lease_ids = self
            .lease_ids_by_lender
            .get(&account_id)
            .unwrap_or(UnorderedSet::new(b"s"));
        for id in lease_ids.iter() {
            let lease_condition = self.lease_map.get(&id).unwrap();
            results.push((id, lease_condition));
        }

        return results;
    }

    pub fn leases_by_borrower(&self, account_id: AccountId) -> Vec<(String, LeaseCondition)> {
        let mut results: Vec<(String, LeaseCondition)> = vec![];

        let lease_ids = self
            .lease_ids_by_borrower
            .get(&account_id)
            .unwrap_or(UnorderedSet::new(b"s"));
        for id in lease_ids.iter() {
            let lease_condition = self.lease_map.get(&id).unwrap();
            results.push((id, lease_condition))
        }
        return results;
    }

    pub fn lease_by_contract_and_token(
        &self,
        contract_id: AccountId,
        token_id: TokenId,
    ) -> Option<(String, LeaseCondition)> {
        let lease_id = self
            .lease_id_by_contract_addr_and_token_id
            .get(&(contract_id, token_id));

        if lease_id.is_none() {
            return None;
        } else {
            let lease_condition = self.lease_map.get(&lease_id.clone().unwrap()).unwrap();
            return Some((lease_id.unwrap(), lease_condition));
        }
    }

    pub fn active_leases_by_lender(&self, account_id: AccountId) -> Vec<(String, LeaseCondition)> {
        let mut results = vec![];

        let active_lease_ids = self
            .active_lease_ids_by_lender
            .get(&account_id)
            .unwrap_or(UnorderedSet::new(b"s"));
        for id in active_lease_ids.iter() {
            let lease_condition = self.lease_map.get(&id).unwrap();
            results.push((id, lease_condition));
        }
        return results;
    }

    #[private]
    pub fn get_lease_by_contract_and_token(
        &self,
        contract_id: AccountId,
        token_id: TokenId,
    ) -> Option<LeaseCondition> {
        let lease_id = self
            .lease_id_by_contract_addr_and_token_id
            .get(&(contract_id, token_id));

        if lease_id.is_none() {
            return None;
        } else {
            return Some(self.lease_map.get(&lease_id.unwrap()).unwrap());
        }
    }

    pub fn get_borrower_by_contract_and_token(
        &self,
        contract_id: AccountId,
        token_id: TokenId,
    ) -> Option<AccountId> {
        // return the current borrower of the NFTs
        // Only active lease has valid borrower

        let lease_condition_option = self.get_lease_by_contract_and_token(contract_id, token_id);
        if lease_condition_option.is_none() {
            return None;
        }

        let lease_condition = lease_condition_option.unwrap();

        if lease_condition.state == LeaseState::Active {
            // only active lease has valid borrower
            return Some(lease_condition.borrower_id);
        } else {
            return None;
        }
    }

    pub fn get_current_user_by_contract_and_token(
        &self,
        contract_id: AccountId,
        token_id: TokenId,
    ) -> Option<AccountId> {
        // return the current user of the NFTs
        // The current user of an active lease is the borrower, otherwise it is the lender

        let lease_condition_option = self.get_lease_by_contract_and_token(contract_id, token_id);

        assert!(
            !lease_condition_option.is_none(),
            "Cannot find a lease of this contract and token!"
        );

        let lease_condition = lease_condition_option.unwrap();
        if lease_condition.state == LeaseState::Active
            && lease_condition.start_ts_nano < env::block_timestamp()
            && lease_condition.end_ts_nano > env::block_timestamp()
        {
            return Some(lease_condition.borrower_id);
        } else {
            return Some(lease_condition.lender_id);
        }
    }

    pub fn set_allowed_ft_contract_addrs(&mut self, addrs: Vec<AccountId>) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner,
            "Only the owner can set allowed FT contracts"
        );

        self.allowed_ft_contract_addrs = addrs
    }

    pub fn get_allowed_ft_contract_addrs(&self) -> Vec<AccountId> {
        self.allowed_ft_contract_addrs.clone()
    }

    pub fn proxy_func_calls(&self, contract_id: AccountId, method_name: String, args: String) {
        // proxy function to open accessible functions calls in a NFT contract during lease
        let promise = Promise::new(contract_id.clone());

        // TODO: allow the lend to define white list of method names.
        // unreachable methods in leased NFT contract
        assert_ne!(
            "nft_transfer", &method_name,
            "Calling method is not accessiable!"
        );
        assert_ne!(
            "nft_approve", &method_name,
            "Calling method is not accessiable!"
        );

        promise.function_call(
            method_name.clone(),
            args.into(),
            env::attached_deposit(),
            Gas(5 * TGAS),
        );
    }

    // internal function to create a lease based on given info
    fn create_lease_with_payout(
        &mut self,
        nft_contract_id: AccountId,
        nft_token_id: TokenId,
        owner_id: AccountId,
        borrower_id: AccountId,
        ft_contract_addr: AccountId,
        start_ts_nano: u64,
        end_ts_nano: u64,
        price: U128,
        nft_payout: Payout,
    ) {
        // build lease condition from the parsed json
        let lease_condition: LeaseCondition = LeaseCondition {
            contract_addr: nft_contract_id,
            token_id: nft_token_id,
            lender_id: owner_id.clone(),
            borrower_id: borrower_id,
            ft_contract_addr: ft_contract_addr,
            price: price,
            start_ts_nano: start_ts_nano,
            end_ts_nano: end_ts_nano,
            payout: Some(nft_payout),
            state: LeaseState::PendingOnRent,
        };

        let seed = near_sdk::env::random_seed();
        let lease_id = bs58::encode(seed)
            .with_alphabet(bs58::Alphabet::BITCOIN)
            .into_string();

        self.internal_insert_lease(&lease_id, &lease_condition);
    }

    // helper method to remove records of a lease
    fn internal_remove_lease(&mut self, lease_id: &LeaseId) {
        // check if a lease condition exist
        let lease_condition = self
            .lease_map
            .get(&lease_id)
            .expect("Input lease_id does not exist");

        // remove lease map record
        self.lease_map.remove(&lease_id);

        // remove from index by_lender
        let mut lease_set = self
            .lease_ids_by_lender
            .get(&lease_condition.lender_id)
            .unwrap();
        lease_set.remove(&lease_id);

        if lease_set.is_empty() {
            self.lease_ids_by_lender.remove(&lease_condition.lender_id);
        } else {
            self.lease_ids_by_lender
                .insert(&lease_condition.lender_id, &lease_set);
        }

        // remove from index by_borrower
        let mut lease_set = self
            .lease_ids_by_borrower
            .get(&lease_condition.borrower_id)
            .unwrap();
        lease_set.remove(&lease_id);

        if lease_set.is_empty() {
            self.lease_ids_by_borrower
                .remove(&lease_condition.borrower_id);
        } else {
            self.lease_ids_by_borrower
                .insert(&lease_condition.borrower_id, &lease_set);
        }

        // remove from index by_contract_addr_and_token_id
        self.lease_id_by_contract_addr_and_token_id
            .remove(&(lease_condition.contract_addr, lease_condition.token_id));

        // Clean up NFT related fields
        // update active leases set
        self.active_lease_ids.remove(&lease_id);

        // update active_lease_ids_by_lender
        let mut active_lease_id_set = self
            .active_lease_ids_by_lender
            .get(&lease_condition.lender_id);

        if let Some(active_lease_id_set) = active_lease_id_set.as_mut() {
            active_lease_id_set.remove(&lease_id);

            if active_lease_id_set.is_empty() {
                self.active_lease_ids_by_lender
                    .remove(&lease_condition.lender_id);
            } else {
                self.active_lease_ids_by_lender
                    .insert(&lease_condition.lender_id, &active_lease_id_set);
            }
        }

        // Event Log to capture token burning as per the Events standard
        let token_id = self.lease_id_to_lease_token_id(&lease_id);
        NftBurn {
            owner_id: &lease_condition.lender_id,
            token_ids: &[&token_id],
            authorized_id: None,
            memo: None,
        }
        .emit()
    }

    // helper method to insert a new lease and update all indices
    fn internal_insert_lease(&mut self, lease_id: &LeaseId, lease_condition: &LeaseCondition) {
        // insert into lease map
        self.lease_map.insert(&lease_id, &lease_condition);

        //update index for leases by lender. If there are none, create a new empty set
        let mut lease_ids_set = self
            .lease_ids_by_lender
            .get(&lease_condition.lender_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::LeasesIdsByLenderInner {
                        // get a new unique prefix for the collection by hashing owner
                        account_id_hash: utils::hash_account_id(&lease_condition.lender_id),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        lease_ids_set.insert(&lease_id);
        self.lease_ids_by_lender
            .insert(&lease_condition.lender_id, &lease_ids_set);

        // update index for leases by borrower. If there are none, create a new empty set
        let mut lease_ids_set = self
            .lease_ids_by_borrower
            .get(&lease_condition.borrower_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::LeaseIdsByBorrowerInner {
                        // get a new unique prefix for the collection by hashing owner
                        account_id_hash: utils::hash_account_id(&lease_condition.borrower_id),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        lease_ids_set.insert(&lease_id);
        self.lease_ids_by_borrower
            .insert(&lease_condition.borrower_id, &lease_ids_set);

        // update index for lease_id_by_contract_addr_and_token_id
        self.lease_id_by_contract_addr_and_token_id.insert(
            &(
                lease_condition.contract_addr.clone(),
                lease_condition.token_id.clone(),
            ),
            &lease_id,
        );

        // log lease insertion
        env::log_str(
            &json!({
                "type": "[INFO] NiFTyRent Rental: A new lease has been inserted.",
                "params": {
                    "lease_id": lease_id.clone(),
                    "nft_contract_id": lease_condition.contract_addr.clone(),
                    "nft_token_id": lease_condition.token_id.clone(),
                    "lender": lease_condition.lender_id.clone(),
                    "borrower": lease_condition.borrower_id.clone(),
                    "lease_state": lease_condition.state,
                }
            })
            .to_string(),
        );
    }

    /// This function updates only the lender info in an active lease
    /// All affecting indices will be updated
    fn internal_update_active_lease_lender(
        &mut self,
        old_lender: &AccountId,
        new_lender: &AccountId,
        lease_id: &LeaseId,
    ) {
        // 1. Check if the active lease exist
        assert_eq!(
            self.active_lease_ids.contains(lease_id),
            true,
            "Only active lease can update lender!"
        );

        // 2. Ensure the given active lease belongs to the old owner
        let mut active_lease_ids_set = self
            .active_lease_ids_by_lender
            .get(old_lender)
            .expect("Active Lease is not owned by the old lender!");

        // 3. Remove the active lease from the old lender
        // update index for active lease ids
        active_lease_ids_set.remove(lease_id);
        if active_lease_ids_set.is_empty() {
            self.active_lease_ids_by_lender.remove(old_lender);
        } else {
            self.active_lease_ids_by_lender
                .insert(old_lender, &active_lease_ids_set);
        }
        // Update the index for lease ids by lender for old lender
        let mut lease_ids_set = self.lease_ids_by_lender.get(old_lender).unwrap();
        lease_ids_set.remove(lease_id);
        if lease_ids_set.is_empty() {
            self.lease_ids_by_lender.remove(old_lender);
        } else {
            self.lease_ids_by_lender.insert(old_lender, &lease_ids_set);
        }

        // 4. Add the active lease to the new lender
        // update the index for active lease ids
        let mut active_lease_ids_set = self
            .active_lease_ids_by_lender
            .get(new_lender)
            .unwrap_or_else(|| {
                // if the new lender doesn't have any active lease, create a new record
                UnorderedSet::new(
                    StorageKey::ActiveLeaseIdsByOwnerInner {
                        account_id_hash: utils::hash_account_id(new_lender),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        active_lease_ids_set.insert(lease_id);
        self.active_lease_ids_by_lender
            .insert(new_lender, &active_lease_ids_set);
        // Udpate the index for lease ids by lender for new lender
        let mut lease_ids_set = self.lease_ids_by_lender.get(new_lender).unwrap_or_else(|| {
            // if the receiver doesn;t have any lease, create a new record
            UnorderedSet::new(
                StorageKey::LeasesIdsByLenderInner {
                    account_id_hash: utils::hash_account_id(new_lender),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        lease_ids_set.insert(lease_id);
        self.lease_ids_by_lender.insert(new_lender, &lease_ids_set);

        // 5. Update the lease map index accordingly
        let mut lease_condition = self.lease_map.get(lease_id).unwrap();
        lease_condition.lender_id = new_lender.clone();
        self.lease_map.insert(&lease_id, &lease_condition); // insert data back to persis the value
    }
}

/**
 * Trait that will handle the receival of the leasing NFT.
 * When the Marketplace calls nft_transfer_call on NFT contract, the NFT contract
 * will invoke this function.
*/
trait NonFungibleTokenTransferReceiver {
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool>;
}

#[near_bindgen]
impl NonFungibleTokenTransferReceiver for Contract {
    /**
     * 1. Check NFT transfer is successful
     * 2. Create proxy payouts if not supported
     * 3. Create a lease
     */
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> PromiseOrValue<bool> {
        // Enforce cross contract call
        let nft_contract_id = env::predecessor_account_id();
        assert_ne!(
            env::current_account_id(),
            nft_contract_id,
            "nft_on_transfer should only be called via XCC."
        );

        let lease_json: LeaseJson =
            near_sdk::serde_json::from_str(&msg).expect("Invalid lease json!");

        // Enforce the leasing token is the same as the transferring token
        assert_eq!(nft_contract_id, lease_json.nft_contract_id);
        assert_eq!(token_id, lease_json.nft_token_id);

        // log nft transfer
        env::log_str(
            &json!({
                "type": "[DEBUG] NiFTyRent Rental: Creating a lease for the received NFT.",
                "params": {
                    "nft_contract_id": nft_contract_id.clone(),
                    "nft_token_id": token_id.clone(),
                    "nft_payout": lease_json.nft_payout.clone(),
                }
            })
            .to_string(),
        );

        // Create a lease using recieved lease info
        self.create_lease_with_payout(
            lease_json.nft_contract_id,
            lease_json.nft_token_id,
            lease_json.lender_id, // use lender here, as the token owner has been updated to Rental contract
            lease_json.borrower_id,
            lease_json.ft_contract_addr,
            lease_json.start_ts_nano,
            lease_json.end_ts_nano,
            lease_json.price,
            lease_json.nft_payout.clone(),
        );

        // at this stage, lease creation has succedded
        // return false to indicate that don't revert the nft transfer
        return PromiseOrValue::Value(false);
    }
}

/*
    The trait for receiving rent transfer from marketplace.
    Depending on the FT contract implementation, it may need the users to register to deposit.
    So far we do not check if all partis have registered thier account on the FT contract,
        - Lender: he should make sure he has registered otherwise he will not receive the payment
        - Borrower: he cannot accept the lease if he does not register
        - Royalty payments: if any accounts in the royalty didn't register, they will not receive the payout. That
                             part of payment will be kept in this smart contract
*/
#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> U128;
}

/**
 * This method receives borrower's rent transferred by markeplace. It also trigers a lease activation
 * 1. Marketplace(Sender) calls `ft_transfer_call` on FT contract.
 * 2. FT contract transfers `amount` tokens from marketplace to core rental contract (reciever).
 * 3. FT contract calls `ft_on_transfer` on core rental contract.
 * 4. Rental contract updates lease state accordingly. Rent condition checks have been performed on marketplace side.
 * 5. Rental contract returns Promise accordingly.
 */
#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    #[payable]
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> U128 {
        // update the lease state to from PendingOnRent to active

        // Enforce cross contract call
        let ft_contract_id = env::predecessor_account_id();
        assert_ne!(
            env::current_account_id(),
            ft_contract_id,
            "ft_on_transfer should only be called via XCC."
        );

        // Extract recived message
        let rent_acceptance_json: RentAcceptanceJson =
            near_sdk::serde_json::from_str(&msg).expect("Not valid listing id data!");

        // Find the targeting lease
        let lease_condition = self
            .get_lease_by_contract_and_token(
                rent_acceptance_json.nft_contract_id.clone(),
                rent_acceptance_json.nft_token_id.clone(),
            )
            .expect("The targeting lease does not exist!");

        // Enforce the ft contract matches
        assert_eq!(
            ft_contract_id, lease_condition.ft_contract_addr,
            "Wrong FT contract address!"
        );

        // Enforce the rent amount matches
        assert_eq!(
            amount.0, lease_condition.price.0,
            "Transferred amount doesn't match the asked rent!"
        );

        // Update the lease state accordingly
        assert_eq!(
            lease_condition.state,
            LeaseState::PendingOnRent,
            "This lease is not pending on rent!"
        );

        let lease_id = self
            .lease_id_by_contract_addr_and_token_id
            .get(&(
                rent_acceptance_json.nft_contract_id,
                rent_acceptance_json.nft_token_id,
            ))
            .expect("The targeting lease id does not exist!");

        self.activate_lease(lease_id);

        // Specify the unused amount as required by NEP-141
        let unused_ammount: U128 = U128::from(0);
        return unused_ammount;
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    /*
    Unit test cases and helper functions

    Test naming format for better readability:
    - test_{function_name} _{succeeds_or_fails} _{condition}
    - When more than one test cases are needed for one function,
    follow the code order of testing failing conditions first and success condition last
    */
    use super::*;
    use near_sdk::serde_json::json;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, PromiseResult, RuntimeFeesConfig, VMConfig};

    #[test]
    fn test_new() {
        let contract = Contract::new(accounts(1).into());
        assert_eq!(accounts(1), contract.owner);
        assert!(UnorderedMap::is_empty(&contract.lease_map));
    }

    // TODO(syu): borrower check is done on marketside. Maybe update to check target lease exist, or remove this
    fn test_lending_accept_wrong_borrower() {
        let mut contract = Contract::new(accounts(1).into());
        let lease_condition = create_lease_condition_default();
        let lease_id = "test_key".to_string();

        contract.lease_map.insert(&lease_id, &lease_condition);
        let wrong_borrower: AccountId = accounts(4).into();

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(lease_condition.ft_contract_addr.clone())
            .build());

        contract.ft_on_transfer(
            wrong_borrower.clone(),
            U128::from(lease_condition.price),
            json!({ "lease_id": lease_id }).to_string(),
        );
    }

    #[test]
    #[should_panic(expected = "Wrong FT contract address!")]
    fn test_lending_accept_fail_wrong_ft_addr() {
        let mut contract = Contract::new(accounts(1).into());
        let lease_condition = create_lease_condition_default();
        let lease_id = "test_lease_id".to_string();
        let wrong_ft_addr = accounts(0);
        contract.lease_map.insert(&lease_id, &lease_condition);
        // needed for finding the target lease_condition at ft_on_transfer
        contract.lease_id_by_contract_addr_and_token_id.insert(
            &(
                lease_condition.contract_addr.clone(),
                lease_condition.token_id.clone(),
            ),
            &lease_id,
        );

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(wrong_ft_addr.into())
            .build());

        let msg_rent_transfer_json = json!({
            "nft_contract_id": lease_condition.contract_addr.clone().to_string(),
            "nft_token_id": lease_condition.token_id.clone().to_string(),
        })
        .to_string();

        contract.ft_on_transfer(
            lease_condition.borrower_id.clone(),
            U128::from(lease_condition.price),
            msg_rent_transfer_json,
        );
    }

    #[test]
    #[should_panic(expected = "Transferred amount doesn't match the asked rent!")]
    fn test_lending_accept_fail_wrong_rent() {
        let mut contract = Contract::new(accounts(1).into());
        let lease_condition = create_lease_condition_default();
        let lease_id = "test_lease_id".to_string();
        contract.lease_map.insert(&lease_id, &lease_condition);
        // needed for finding the target lease_condition at ft_on_transfer
        contract.lease_id_by_contract_addr_and_token_id.insert(
            &(
                lease_condition.contract_addr.clone(),
                lease_condition.token_id.clone(),
            ),
            &lease_id,
        );

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(lease_condition.ft_contract_addr.clone())
            .build());

        let msg_rent_transfer_json = json!({
            "nft_contract_id": lease_condition.contract_addr.clone().to_string(),
            "nft_token_id": lease_condition.token_id.clone().to_string(),
        })
        .to_string();

        contract.ft_on_transfer(
            lease_condition.borrower_id.clone(),
            U128::from(lease_condition.price.0 - 1),
            msg_rent_transfer_json,
        );
    }

    #[test]
    #[should_panic(expected = "This lease is not pending on rent!")]
    fn test_lending_accept_fail_wrong_lease_state() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::Active;
        let lease_id = "test_lease_id".to_string();
        contract.lease_map.insert(&lease_id, &lease_condition);
        // needed for finding the target lease_condition at ft_on_transfer
        contract.lease_id_by_contract_addr_and_token_id.insert(
            &(
                lease_condition.contract_addr.clone(),
                lease_condition.token_id.clone(),
            ),
            &lease_id,
        );

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(lease_condition.ft_contract_addr.clone())
            .build());

        let msg_rent_transfer_json = json!({
            "nft_contract_id": lease_condition.contract_addr.clone().to_string(),
            "nft_token_id": lease_condition.token_id.clone().to_string(),
        })
        .to_string();

        contract.ft_on_transfer(
            lease_condition.borrower_id.clone(),
            U128::from(lease_condition.price),
            msg_rent_transfer_json,
        );
    }

    #[test]
    fn test_lending_accept_success() {
        let mut contract = Contract::new(accounts(1).into());
        let lease_condition = create_lease_condition_default();
        let lease_id = "test_lease_id".to_string();
        contract.lease_map.insert(&lease_id, &lease_condition);
        // needed for finding the target lease_condition at ft_on_transfer
        contract.lease_id_by_contract_addr_and_token_id.insert(
            &(
                lease_condition.contract_addr.clone(),
                lease_condition.token_id.clone(),
            ),
            &lease_id,
        );

        testing_env!(VMContextBuilder::new()
            .predecessor_account_id(lease_condition.ft_contract_addr.clone())
            .build());

        let msg_rent_transfer_json = json!({
            "nft_contract_id": lease_condition.contract_addr.clone().to_string(),
            "nft_token_id": lease_condition.token_id.clone().to_string(),
        })
        .to_string();

        contract.ft_on_transfer(
            lease_condition.borrower_id.clone(),
            U128::from(lease_condition.price),
            msg_rent_transfer_json,
        );

        // Nothing can be checked, except the fact the call doesn't panic.
    }

    #[test]
    fn test_activate_lease_with_payout_success() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();
        let key = "test_key".to_string();
        let payout = Payout {
            payout: HashMap::from([
                (accounts(2).into(), U128::from(1)),
                (accounts(3).into(), U128::from(4)),
            ]),
        };

        lease_condition.payout = Some(payout.clone());

        contract.lease_map.insert(&key, &lease_condition);
        testing_env!(
            VMContextBuilder::new()
                .current_account_id(accounts(0))
                .predecessor_account_id(lease_condition.borrower_id.clone())
                .build(),
            VMConfig::test(),
            RuntimeFeesConfig::test(),
            HashMap::default(),
            vec![PromiseResult::Successful(Vec::new())],
        );

        contract.activate_lease(key.clone());

        let lease_condition_result = contract.lease_map.get(&key).unwrap();
        assert_eq!(lease_condition_result.payout, Some(payout));
        assert_eq!(lease_condition_result.state, LeaseState::Active);
    }

    #[test]
    fn test_activate_lease_without_payout_success() {
        let mut contract = Contract::new(accounts(1).into());
        let lease_condition = create_lease_condition_default();
        let key = "test_key".to_string();

        contract.lease_map.insert(&key, &lease_condition);
        testing_env!(
            VMContextBuilder::new()
                .current_account_id(accounts(0))
                .predecessor_account_id(lease_condition.borrower_id.clone())
                .build(),
            VMConfig::test(),
            RuntimeFeesConfig::test(),
            HashMap::default(),
            vec![PromiseResult::Successful(Vec::new())],
        );

        contract.activate_lease(key.clone());

        let lease_condition_result = contract.lease_map.get(&key).unwrap();
        assert_eq!(lease_condition_result.payout, None);
        assert_eq!(lease_condition_result.state, LeaseState::Active);
    }

    #[test]
    #[should_panic]
    fn test_activate_lease_promise_panic() {
        let mut contract = Contract::new(accounts(1).into());
        let lease_condition = create_lease_condition_default();
        let key = "test_key".to_string();
        contract.lease_map.insert(&key, &lease_condition);

        testing_env!(
            VMContextBuilder::new()
                .current_account_id(accounts(0))
                .predecessor_account_id(lease_condition.borrower_id.clone())
                .build(),
            VMConfig::test(),
            RuntimeFeesConfig::test(),
            HashMap::default(),
            vec![PromiseResult::Failed],
        );

        contract.activate_lease(key.clone());

        let lease_condition_result = contract.lease_map.get(&key).unwrap();
        assert_eq!(lease_condition_result.payout, None);
        assert_eq!(lease_condition_result.state, LeaseState::PendingOnRent);
    }

    #[test]
    #[should_panic(expected = "Lease has not expired yet!")]
    fn test_claim_back_not_expired_yet() {
        let mut contract = Contract::new(accounts(1).into());

        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::Active;
        lease_condition.end_ts_nano = 1000;

        let key = "test_key".to_string();
        contract.lease_map.insert(&key, &lease_condition);

        testing_env!(VMContextBuilder::new()
            .current_account_id(accounts(0))
            .predecessor_account_id(lease_condition.lender_id.clone())
            .block_timestamp(lease_condition.end_ts_nano - 1)
            .build());

        contract.claim_back(key);
    }

    #[test]
    #[should_panic(expected = "Only original lender or service owner can claim back!")]
    fn test_claim_back_wrong_lender() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::Active;
        let key = "test_key".to_string();

        contract.lease_map.insert(&key, &lease_condition);

        testing_env!(VMContextBuilder::new()
            .current_account_id(accounts(0))
            .predecessor_account_id(accounts(5).into()) // non-owner, non-lender
            .block_timestamp(lease_condition.end_ts_nano + 1)
            .build());

        contract.claim_back(key);
    }

    #[test]
    #[should_panic(expected = "Queried Lease is not active!")]
    fn test_claim_back_inactive_lease() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::PendingOnRent;
        let key = "test_key".to_string();

        contract.lease_map.insert(&key, &lease_condition);

        testing_env!(VMContextBuilder::new()
            .current_account_id(accounts(0))
            .predecessor_account_id(lease_condition.lender_id.clone())
            .block_timestamp(lease_condition.end_ts_nano + 1)
            .build());

        contract.claim_back(key);
    }

    #[test]
    #[should_panic]
    fn test_claim_back_non_exsisting_lease_id() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::Active;
        let key = "test_key".to_string();
        contract.lease_map.insert(&key, &lease_condition);

        testing_env!(VMContextBuilder::new()
            .current_account_id(accounts(0))
            .predecessor_account_id(lease_condition.lender_id.clone())
            .block_timestamp(lease_condition.end_ts_nano + 1)
            .build());

        let non_existing_key = "dummy_key".to_string();
        contract.claim_back(non_existing_key);
    }

    #[test]
    fn test_claim_back_success() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::Active;
        lease_condition.price = U128::from(20);
        let key = "test_key".to_string();
        contract.internal_insert_lease(&key, &lease_condition);

        testing_env!(VMContextBuilder::new()
            .current_account_id(accounts(0))
            .predecessor_account_id(lease_condition.lender_id.clone())
            .block_timestamp(lease_condition.end_ts_nano + 1)
            .build());

        contract.claim_back(key);

        // Nothing can be checked, except the fact the call doesn't panic.
    }

    #[test]
    fn test_get_borrower_by_contract_and_token_success_no_matching_borrower() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();

        let expected_contract_address: AccountId = accounts(4).into();
        let expected_token_id = "test_token".to_string();
        let expected_borrower_id: AccountId = accounts(3).into();

        lease_condition.state = LeaseState::Active;
        lease_condition.contract_addr = expected_contract_address.clone();
        lease_condition.token_id = expected_token_id.clone();
        lease_condition.borrower_id = expected_borrower_id.clone();

        let key = "test_key".to_string();
        contract.internal_insert_lease(&key, &lease_condition);

        let test_contract_id: AccountId = accounts(5).into();
        let test_token_id = "dummy_token".to_string();

        let result_borrower = contract.get_borrower_by_contract_and_token(
            test_contract_id.clone(),
            expected_token_id.clone(),
        );
        assert!(result_borrower.is_none());

        let result_borrower = contract.get_borrower_by_contract_and_token(
            expected_contract_address.clone(),
            test_token_id.clone(),
        );
        assert!(result_borrower.is_none());
    }

    #[test]
    fn test_get_borrower_by_contract_and_token_success_lease_is_inactive() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();

        let expected_contract_address: AccountId = accounts(4).into();
        let expected_token_id = "test_token".to_string();
        let expected_borrower_id: AccountId = accounts(3).into();

        lease_condition.state = LeaseState::PendingOnRent;
        lease_condition.contract_addr = expected_contract_address.clone();
        lease_condition.token_id = expected_token_id.clone();
        lease_condition.borrower_id = expected_borrower_id.clone();

        let key = "test_key".to_string();
        contract.internal_insert_lease(&key, &lease_condition);

        let result_borrower = contract
            .get_borrower_by_contract_and_token(expected_contract_address, expected_token_id);
        assert!(result_borrower.is_none());
    }

    #[test]
    fn test_get_current_user_by_contract_and_token_success_found_matching_borrower() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();

        let expected_contract_address: AccountId = accounts(4).into();
        let expected_token_id = "test_token".to_string();
        let expected_borrower_id: AccountId = accounts(3).into();

        lease_condition.state = LeaseState::Active;
        lease_condition.contract_addr = expected_contract_address.clone();
        lease_condition.token_id = expected_token_id.clone();
        lease_condition.borrower_id = expected_borrower_id.clone();

        let key = "test_key".to_string();
        contract.internal_insert_lease(&key, &lease_condition);

        testing_env!(VMContextBuilder::new()
            .current_account_id(accounts(0))
            .block_timestamp(10)
            .build());

        let result_owner = contract
            .get_current_user_by_contract_and_token(expected_contract_address, expected_token_id)
            .unwrap();
        assert!(result_owner == expected_borrower_id);
    }

    #[test]
    fn test_get_current_user_by_contract_and_token_success_lease_is_inactive() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();

        let expected_contract_address: AccountId = accounts(4).into();
        let expected_token_id = "test_token".to_string();
        let expected_lender_id: AccountId = accounts(2).into();
        let expected_borrower_id: AccountId = accounts(3).into();

        lease_condition.state = LeaseState::PendingOnRent;
        lease_condition.contract_addr = expected_contract_address.clone();
        lease_condition.token_id = expected_token_id.clone();
        lease_condition.lender_id = expected_lender_id.clone();
        lease_condition.borrower_id = expected_borrower_id.clone();

        let key = "test_key".to_string();
        contract.internal_insert_lease(&key, &lease_condition);

        let result_owner = contract
            .get_current_user_by_contract_and_token(expected_contract_address, expected_token_id)
            .unwrap();
        assert!(result_owner == expected_lender_id);
    }

    #[test]
    fn test_get_current_user_by_contract_and_token_success_after_lease_expires() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();

        let expected_contract_address: AccountId = accounts(4).into();
        let expected_token_id = "test_token".to_string();
        let expected_borrower_id: AccountId = accounts(3).into();
        let expected_lender_id: AccountId = accounts(2).into();

        lease_condition.state = LeaseState::Active;
        lease_condition.contract_addr = expected_contract_address.clone();
        lease_condition.token_id = expected_token_id.clone();
        lease_condition.lender_id = expected_lender_id.clone();
        lease_condition.borrower_id = expected_borrower_id.clone();

        let key = "test_key".to_string();
        contract.internal_insert_lease(&key, &lease_condition);

        testing_env!(VMContextBuilder::new()
            .current_account_id(accounts(0))
            .block_timestamp(1000)
            .build());

        let result_owner = contract
            .get_current_user_by_contract_and_token(expected_contract_address, expected_token_id)
            .unwrap();
        assert!(result_owner == expected_lender_id);
    }

    #[test]
    fn test_get_current_user_by_contract_and_token_success_lease_not_start() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();

        let expected_contract_address: AccountId = accounts(4).into();
        let expected_token_id = "test_token".to_string();
        let expected_lender_id: AccountId = accounts(2).into();
        let expected_borrower_id: AccountId = accounts(3).into();

        lease_condition.state = LeaseState::PendingOnRent;
        lease_condition.contract_addr = expected_contract_address.clone();
        lease_condition.token_id = expected_token_id.clone();
        lease_condition.lender_id = expected_lender_id.clone();
        lease_condition.borrower_id = expected_borrower_id.clone();
        // 2333/01/01 00:00
        lease_condition.start_ts_nano = 11455171200000000000;

        let key = "test_key".to_string();
        contract.internal_insert_lease(&key, &lease_condition);

        let result_owner = contract
            .get_current_user_by_contract_and_token(expected_contract_address, expected_token_id)
            .unwrap();
        assert!(result_owner == expected_lender_id);
    }

    #[test]
    fn test_get_borrower_by_contract_and_token_success_found_matching_borrower() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();

        let expected_contract_address: AccountId = accounts(4).into();
        let expected_token_id = "test_token".to_string();
        let expected_borrower_id: AccountId = accounts(3).into();

        lease_condition.state = LeaseState::Active;
        lease_condition.contract_addr = expected_contract_address.clone();
        lease_condition.token_id = expected_token_id.clone();
        lease_condition.borrower_id = expected_borrower_id.clone();

        let key = "test_key".to_string();
        contract.internal_insert_lease(&key, &lease_condition);

        let result_borrower = contract
            .get_borrower_by_contract_and_token(expected_contract_address, expected_token_id)
            .unwrap();
        assert!(result_borrower == expected_borrower_id);
    }

    /// Creat two leases using the same lender
    /// Before the leases got actived, active_leases_by_lender() should return 0 leases
    /// After both leases got actived, active_leases_by_lender() should return 2 leases
    #[test]
    fn test_active_leases_by_lender_succeeds() {
        let mut contract = Contract::new(accounts(0).into());
        let expected_lender_id: AccountId = accounts(2).into();

        let mut lease_condition_1 = create_lease_condition_default();
        lease_condition_1.token_id = "test_token_1".to_string();
        lease_condition_1.lender_id = expected_lender_id.clone();
        let key_1 = "test_key_1".to_string();
        contract.internal_insert_lease(&key_1, &lease_condition_1);

        let mut lease_condition_2 = create_lease_condition_default();
        lease_condition_2.token_id = "test_token_2".to_string();
        lease_condition_2.lender_id = expected_lender_id.clone();
        let key_2 = "test_key_2".to_string();
        contract.internal_insert_lease(&key_2, &lease_condition_2);

        // check before the leases got activated
        let active_leases = contract.active_leases_by_lender(expected_lender_id.clone());
        assert_eq!(active_leases.len(), 0);

        // activate the 1st lease
        testing_env!(
            VMContextBuilder::new()
                .current_account_id(accounts(0))
                .build(),
            VMConfig::test(),
            RuntimeFeesConfig::test(),
            HashMap::default(),
            vec![PromiseResult::Successful(Vec::new())],
        );
        contract.activate_lease(key_1.clone());

        // activate the 2nd lease
        testing_env!(
            VMContextBuilder::new()
                .current_account_id(accounts(0))
                .build(),
            VMConfig::test(),
            RuntimeFeesConfig::test(),
            HashMap::default(),
            vec![PromiseResult::Successful(Vec::new())],
        );
        contract.activate_lease(key_2.clone());

        // test after the leases got activated
        let active_leases = contract.active_leases_by_lender(expected_lender_id.clone());
        assert_eq!(active_leases.len(), 2);
    }

    #[test]
    fn test_leases_by_borrower_success() {
        let mut contract = Contract::new(accounts(1).into());
        let expected_borrower_id: AccountId = accounts(3).into();

        let mut lease_condition_1 = create_lease_condition_default();
        lease_condition_1.state = LeaseState::Active;
        lease_condition_1.token_id = "test_token_1".to_string();
        lease_condition_1.borrower_id = expected_borrower_id.clone();

        let key_1 = "test_key_1".to_string();
        contract.internal_insert_lease(&key_1, &lease_condition_1);

        let mut lease_condition_2 = create_lease_condition_default();
        lease_condition_2.state = LeaseState::Active;
        lease_condition_2.token_id = "test_token_2".to_string();
        lease_condition_2.borrower_id = expected_borrower_id.clone();

        let key_2 = "test_key_2".to_string();
        contract.internal_insert_lease(&key_2, &lease_condition_2);

        testing_env!(VMContextBuilder::new()
            .current_account_id(accounts(0))
            .predecessor_account_id(lease_condition_1.lender_id.clone())
            .block_timestamp(lease_condition_1.end_ts_nano + 1)
            .build());

        let result = contract.leases_by_borrower(expected_borrower_id.clone());
        assert_eq!(result.len(), 2);
    }

    #[test]
    fn test_leases_by_owner_success() {
        let mut contract = Contract::new(accounts(1).into());
        let expected_owner_id: AccountId = accounts(2).into();

        let mut lease_condition_1 = create_lease_condition_default();
        lease_condition_1.state = LeaseState::Active;
        lease_condition_1.token_id = "test_token_1".to_string();
        lease_condition_1.lender_id = expected_owner_id.clone();

        let key_1 = "test_key_1".to_string();
        contract.internal_insert_lease(&key_1, &lease_condition_1);

        let mut lease_condition_2 = create_lease_condition_default();
        lease_condition_2.state = LeaseState::Active;
        lease_condition_2.token_id = "test_token_2".to_string();
        lease_condition_2.lender_id = expected_owner_id.clone();

        let key_2 = "test_key_2".to_string();
        contract.internal_insert_lease(&key_2, &lease_condition_2);

        let mut builder = VMContextBuilder::new();
        testing_env!(builder
            .current_account_id(accounts(0))
            .predecessor_account_id(lease_condition_1.lender_id.clone())
            .block_timestamp(lease_condition_1.end_ts_nano + 1)
            .build());

        let result = contract.leases_by_owner(expected_owner_id.clone());
        assert_eq!(result.len(), 2);
    }

    #[test]
    fn test_internal_insert_lease_success() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::Active;
        lease_condition.price = U128::from(20);
        lease_condition.contract_addr = accounts(4).into();
        lease_condition.token_id = "test_token".to_string();
        let key = "test_key".to_string();

        assert!(contract.lease_map.is_empty());
        assert!(!contract
            .lease_ids_by_borrower
            .contains_key(&lease_condition.borrower_id));
        assert!(!contract
            .lease_ids_by_lender
            .contains_key(&lease_condition.lender_id));
        assert!(!contract
            .lease_id_by_contract_addr_and_token_id
            .contains_key(&(
                lease_condition.contract_addr.clone(),
                lease_condition.token_id.clone()
            )));

        contract.internal_insert_lease(&key, &lease_condition);

        assert!(contract.lease_map.len() == 1);
        assert!(contract
            .lease_ids_by_borrower
            .contains_key(&lease_condition.borrower_id));
        assert!(contract
            .lease_ids_by_lender
            .contains_key(&lease_condition.lender_id));
        assert!(contract
            .lease_id_by_contract_addr_and_token_id
            .contains_key(&(
                lease_condition.contract_addr.clone(),
                lease_condition.token_id.clone()
            )));
    }

    #[test]
    fn test_internal_remove_lease_success_only_one_lease() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::Active;
        lease_condition.price = U128::from(20);
        lease_condition.contract_addr = accounts(4).into();
        lease_condition.token_id = "test_token".to_string();
        let key = "test_key".to_string();

        contract.internal_insert_lease(&key, &lease_condition);

        assert!(contract.lease_map.len() == 1);
        assert!(contract
            .lease_ids_by_borrower
            .contains_key(&lease_condition.borrower_id));
        assert!(contract
            .lease_ids_by_lender
            .contains_key(&lease_condition.lender_id));
        assert!(contract
            .lease_id_by_contract_addr_and_token_id
            .contains_key(&(
                lease_condition.contract_addr.clone(),
                lease_condition.token_id.clone()
            )));

        contract.internal_remove_lease(&key);

        assert!(contract.lease_map.is_empty());
        assert!(!contract
            .lease_ids_by_borrower
            .contains_key(&lease_condition.borrower_id));
        assert!(!contract
            .lease_ids_by_lender
            .contains_key(&lease_condition.lender_id));
        assert!(!contract
            .lease_id_by_contract_addr_and_token_id
            .contains_key(&(
                lease_condition.contract_addr.clone(),
                lease_condition.token_id.clone()
            )));
    }

    #[test]
    fn test_internal_remove_lease_success_different_owners() {
        let mut contract = Contract::new(accounts(1).into());
        let owner_1: AccountId = accounts(2).into();
        let owner_2: AccountId = accounts(4).into();

        let mut lease_condition_1 = create_lease_condition_default();
        lease_condition_1.state = LeaseState::Active;
        lease_condition_1.token_id = "test_token_1".to_string();
        lease_condition_1.lender_id = owner_1.clone();

        let key_1 = "test_key_1".to_string();
        contract.internal_insert_lease(&key_1, &lease_condition_1);

        let mut lease_condition_2 = create_lease_condition_default();
        lease_condition_2.state = LeaseState::Active;
        lease_condition_2.token_id = "test_token_2".to_string();
        lease_condition_2.lender_id = owner_2.clone();

        let key_2 = "test_key_2".to_string();
        contract.internal_insert_lease(&key_2, &lease_condition_2);

        assert!(contract.lease_map.len() == 2);
        assert!(contract.lease_ids_by_lender.contains_key(&owner_1));
        assert!(contract.lease_ids_by_lender.contains_key(&owner_2));

        contract.internal_remove_lease(&key_1);

        assert!(contract.lease_map.len() == 1);
        assert!(!contract.lease_ids_by_lender.contains_key(&owner_1));
        assert!(contract.lease_ids_by_lender.contains_key(&owner_2));
    }

    #[test]
    fn test_internal_remove_lease_success_different_borrowers() {
        let mut contract = Contract::new(accounts(1).into());
        let borrower_1: AccountId = accounts(3).into();
        let borrower_2: AccountId = accounts(4).into();

        let mut lease_condition_1 = create_lease_condition_default();
        lease_condition_1.state = LeaseState::Active;
        lease_condition_1.token_id = "test_token_1".to_string();
        lease_condition_1.borrower_id = borrower_1.clone();

        let key_1 = "test_key_1".to_string();
        contract.internal_insert_lease(&key_1, &lease_condition_1);

        let mut lease_condition_2 = create_lease_condition_default();
        lease_condition_2.state = LeaseState::Active;
        lease_condition_2.token_id = "test_token_2".to_string();
        lease_condition_2.borrower_id = borrower_2.clone();

        let key_2 = "test_key_2".to_string();
        contract.internal_insert_lease(&key_2, &lease_condition_2);

        assert!(contract.lease_map.len() == 2);
        assert!(contract.lease_ids_by_borrower.contains_key(&borrower_1));
        assert!(contract.lease_ids_by_borrower.contains_key(&borrower_2));

        contract.internal_remove_lease(&key_1);

        assert!(contract.lease_map.len() == 1);
        assert!(!contract.lease_ids_by_borrower.contains_key(&borrower_1));
        assert!(contract.lease_ids_by_borrower.contains_key(&borrower_2));
    }

    /// 1. Initially, Alice owns an active lease
    /// 2. Alice transfers the lease to Bob
    /// 3. Check Success:
    ///    - Lease record for Alice is emptied
    ///    - Lease record for Bob is updated
    #[test]
    fn test_internal_update_active_lease_lender_succeeds() {
        let mut contract = Contract::new(accounts(0).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.lender_id = accounts(0).into(); //Alice

        let lease_key = "test_key".to_string();
        contract.internal_insert_lease(&lease_key, &lease_condition);

        // update active lease records for Alice
        lease_condition.state = LeaseState::Active;
        contract.nft_mint(lease_key.clone(), lease_condition.lender_id.clone());

        contract.internal_update_active_lease_lender(
            &lease_condition.lender_id, // Alice
            &accounts(1).into(),        // Bob
            &lease_key,
        );

        assert_eq!(1, contract.active_lease_ids.len());
        assert!(!contract
            .active_lease_ids_by_lender
            .contains_key(&accounts(0).into()));
        assert!(!contract
            .lease_ids_by_lender
            .contains_key(&accounts(0).into()));
        assert!(contract
            .active_lease_ids_by_lender
            .contains_key(&accounts(1).into()));
        assert!(contract
            .lease_ids_by_lender
            .contains_key(&accounts(1).into()));
        assert_eq!(
            contract.lease_map.get(&lease_key).unwrap().lender_id,
            accounts(1).into()
        );
    }

    /// 1. Initially, Alice owns an active lease
    /// 2. Charlie tries to transfer Alice's lease to Bob
    /// 3. Panic, due to unmatching lenders
    #[test]
    #[should_panic(expected = "Active Lease is not owned by the old lender!")]
    fn test_internal_update_active_lease_lender_fails_unmatched_old_lender() {
        let mut contract = Contract::new(accounts(0).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.lender_id = accounts(1).into(); //Alice

        let lease_key = "test_key".to_string();
        contract.internal_insert_lease(&lease_key, &lease_condition);

        // update active lease records
        lease_condition.state = LeaseState::Active;
        contract.active_lease_ids.insert(&lease_key);
        let mut active_lease_ids_set: UnorderedSet<String> = UnorderedSet::new(
            StorageKey::ActiveLeaseIdsByOwnerInner {
                account_id_hash: utils::hash_account_id(&lease_condition.lender_id),
            }
            .try_to_vec()
            .unwrap(),
        );
        active_lease_ids_set.insert(&lease_key);

        contract.internal_update_active_lease_lender(
            &accounts(3).into(), // Charlie
            &accounts(2).into(), // Bob
            &lease_key,
        );
    }

    #[test]
    #[should_panic(expected = "Only active lease can update lender!")]
    fn test_internal_update_active_lease_lender_fails_not_an_active_lease() {
        let mut contract = Contract::new(accounts(0).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::PendingOnRent;

        let lease_key = "test_key".to_string();
        contract.internal_insert_lease(&lease_key, &lease_condition);

        contract.internal_update_active_lease_lender(
            &lease_condition.lender_id, // Alice
            &accounts(2).into(),        // Bob
            &lease_key,
        );
    }

    #[test]
    #[should_panic(expected = "Only the owner can set allowed FT contracts")]
    fn test_update_allowed_contract_addrs_fail_when_called_by_nonowner() {
        let mut contract = Contract::new(accounts(1).into());
        assert!(contract.get_allowed_ft_contract_addrs().is_empty());

        contract.set_allowed_ft_contract_addrs(vec![accounts(2)]);
    }

    #[test]
    fn test_update_allowed_contract_addrs_success() {
        let mut contract = Contract::new(accounts(1).into());
        assert!(contract.get_allowed_ft_contract_addrs().is_empty());

        testing_env!(VMContextBuilder::new()
            .current_account_id(accounts(0))
            .predecessor_account_id(accounts(1))
            .build());
        contract.set_allowed_ft_contract_addrs(vec![accounts(2), accounts(3)]);
        assert_eq!(
            contract.get_allowed_ft_contract_addrs(),
            vec![accounts(2), accounts(3)]
        );
        contract.set_allowed_ft_contract_addrs(vec![accounts(4)]);
        assert_eq!(contract.get_allowed_ft_contract_addrs(), vec![accounts(4)]);
    }

    // Helper function to return a lease condition using default seting
    pub(crate) fn create_lease_condition_default() -> LeaseCondition {
        let token_id: TokenId = "test_token".to_string();
        let lender: AccountId = accounts(2).into();
        let borrower: AccountId = accounts(3).into();
        let nft_address: AccountId = accounts(4).into();
        let ft_contract_addr: AccountId = accounts(5).into();
        let start_ts_nano = 1;
        let end_ts_nano = 1000;
        let price = U128::from(5);

        create_lease_condition(
            nft_address,
            token_id.clone(),
            lender.clone(),
            borrower.clone(),
            ft_contract_addr.clone(),
            start_ts_nano.clone(),
            end_ts_nano.clone(),
            price,
            None,
            LeaseState::PendingOnRent,
        )
    }

    // helper method to generate a dummy AccountId using input name
    pub(crate) fn create_a_dummy_account_id(account_name: &str) -> AccountId {
        AccountId::new_unchecked(account_name.to_string())
    }

    // Helper function create a lease condition based on input
    fn create_lease_condition(
        contract_addr: AccountId,
        token_id: TokenId,
        lender_id: AccountId,
        borrower_id: AccountId,
        ft_contract_addr: AccountId,
        start_ts_nano: u64,
        end_ts_nano: u64,
        price: U128,
        payout: Option<Payout>,
        state: LeaseState,
    ) -> LeaseCondition {
        LeaseCondition {
            contract_addr,
            token_id,
            lender_id,
            borrower_id,
            ft_contract_addr,
            start_ts_nano,
            end_ts_nano,
            price,
            payout,
            state,
        }
    }
}

'''
'''--- contract/src/nft/core.rs ---
use crate::*;

pub use near_contract_standards::non_fungible_token::core::NonFungibleTokenCore;
use near_contract_standards::non_fungible_token::events::NftTransfer;
use near_contract_standards::non_fungible_token::{metadata::TokenMetadata, Token};

use near_sdk::{assert_one_yocto, PromiseOrValue, PromiseResult};

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_NFT_ON_TRANSFER: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);
const DATA_IMAGE_SVG: &str = include_str!("data_image_svg.txt");

#[ext_contract(ext_nft_receiver)]
trait NonFungibleTokenReceiver {
    /// Method on the receiver contract that is called via XCC when nft_transfer_call is called
    /// Returns `true` if the token should be returned back to the sender.
    fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> Promise;
}

#[ext_contract(ext_self)]
trait NonFungibleTokenResolver {
    /// This method resolves the promise returned from the XCC to the receiver contract,
    /// as part of the nft_transfer_call method
    fn nft_resolve_transfer(
        &mut self,
        owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        approved_account_ids: Option<HashMap<AccountId, u64>>, // logging trasnfer event - deault to None
        memo: Option<String>,                                  // memo for logging transfer event
    ) -> bool;
}

#[near_bindgen]
impl NonFungibleTokenCore for Contract {
    #[payable]
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        // TODO(libo): remove this suppressor after we implemented approval.
        #[allow(unused_variables)] approval_id: Option<u64>,
        memo: Option<String>,
    ) {
        // Security assurance, on full access
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        self.internal_transfer(&sender_id, &receiver_id, &token_id, memo);
    }

    #[payable]
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        // TODO(libo): remove this suppressor after we implemented approval.
        #[allow(unused_variables)] approval_id: Option<u64>,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<bool> {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let previous_token =
            self.internal_transfer(&sender_id, &receiver_id, &token_id, memo.clone());

        ext_nft_receiver::ext(receiver_id.clone())
            .with_static_gas(GAS_FOR_NFT_ON_TRANSFER)
            .nft_on_transfer(
                sender_id,
                previous_token.owner_id.clone(),
                token_id.clone(),
                msg,
            )
            .then(
                ext_self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    .nft_resolve_transfer(
                        previous_token.owner_id,
                        receiver_id,
                        token_id,
                        None,
                        memo,
                    ),
            )
            .into()
    }

    /// Returns the token info with a given token_id. Info are assembled on the fly
    fn nft_token(&self, token_id: TokenId) -> Option<Token> {
        let active_lease_id_for_token = self.lease_token_id_to_lease_id(&token_id);

        if self.active_lease_ids.contains(&active_lease_id_for_token) {
            // Get the lease condition to assemble token info and token metadata
            let lease_condition = self.lease_map.get(&active_lease_id_for_token).unwrap();

            // Generate token metadata on the fly. Hard coded for now
            let token_metadata = TokenMetadata{
                title: Some(format!("NiFTyRent Lease Ownership Token: {}", &active_lease_id_for_token)), 
                description: Some(
                    format!("
                    This is a token representing the ownership of the NFT under the NiFTyRent lease: {lease_id}\n
                    Leasing NFT's contract: {contract_id}\n
                    Leasing NFT's token id: {leased_token_id}\n", 
                    lease_id=&active_lease_id_for_token,
                    contract_id=&lease_condition.contract_addr,
                    leased_token_id=&lease_condition.token_id,
                )),
                media: Some(DATA_IMAGE_SVG.to_string()),
                media_hash: None,
                copies: None,
                issued_at: None,
                expires_at: None,
                starts_at: None,
                updated_at: None,
                extra: None,
                reference: None,
                reference_hash: None,
            };

            // Return the token object with assembled info
            Some(Token {
                token_id,
                owner_id: lease_condition.lender_id,
                metadata: Some(token_metadata),
                approved_account_ids: None, // TODO(syu): Add support for Approval
            })
        } else {
            // If there wasn't any token_id in tokens_by_id, return None
            None
        }
    }
}

#[near_bindgen]
impl NonFungibleTokenResolver for Contract {
    /// Resolves XCC result from receiver's nft_on_transfer
    /// Returns true if the token was successfully transferred to the receiver_id
    fn nft_resolve_transfer(
        &mut self,
        previouse_owner_id: AccountId,
        receiver_id: AccountId,
        token_id: TokenId,
        // TODO: remove this suppressor after implementing approval.
        #[allow(unused_variables)] approved_account_ids: Option<HashMap<AccountId, u64>>, // logging trasnfer event - deault to None
        memo: Option<String>, // memo for logging transfer event
    ) -> bool {
        // Check whether the token should be returned to previous owner
        let should_revert = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            PromiseResult::Successful(value) => {
                if let Ok(true_or_false) = near_sdk::serde_json::from_slice::<bool>(&value) {
                    true_or_false
                } else {
                    true
                }
            }
            PromiseResult::Failed => true,
        };

        // If the XCC indicated no revert, return early
        if !should_revert {
            return true;
        }

        // Otherwise, try to revert this transfer and return the token to the previous owner
        if let Some(lease_condition) = self.lease_map.get(&token_id) {
            // Check that the receiver didn't transfer the token away or burned it
            if lease_condition.lender_id != receiver_id {
                // The token is no longer owned by the receiver. Can't return it
                return true;
            }
        } else {
            // No token_id record. The token doesn't exist any more, or got burned
            return true;
        }

        self.internal_update_active_lease_lender(&receiver_id, &previouse_owner_id, &token_id);

        // Log transfer event as per the Events standard
        NftTransfer {
            old_owner_id: &receiver_id,
            new_owner_id: &previouse_owner_id,
            token_ids: &[&token_id],
            authorized_id: None,
            memo: memo.as_deref(),
        }
        .emit();

        return false;
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    /*
    Unit test cases and helper functions
    Test naming format for better readability:
    - test_{function_name} _{succeeds_or_fails} _{condition}
    - When more than one test cases are needed for one function,
    follow the code order of testing failing conditions first and success condition last
    */

    use crate::tests::*;
    use crate::{Contract, LeaseState};

    use near_contract_standards::non_fungible_token::core::NonFungibleTokenCore;
    use near_contract_standards::non_fungible_token::TokenId;

    use near_sdk::test_utils::{self, accounts, VMContextBuilder};
    use near_sdk::testing_env;

    #[test]
    fn test_nft_token_succeeds_non_existing_token_id() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::Active;

        let key = "test_key".to_string();
        contract.lease_map.insert(&key, &lease_condition);
        contract.active_lease_ids.insert(&key);

        let non_existing_token_id: TokenId = "dummy_token_id".to_string();
        let a_token = contract.nft_token(non_existing_token_id.clone());

        assert!(a_token.is_none())
    }

    #[test]
    fn test_nft_token_succeeds_existing_token_id() {
        let mut contract = Contract::new(accounts(1).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.state = LeaseState::Active;

        let lease_id = "test_lease_id".to_string();
        contract.lease_map.insert(&lease_id, &lease_condition);
        contract.active_lease_ids.insert(&lease_id);

        let lease_nft_token_id = contract.lease_id_to_lease_token_id(&lease_id);
        let a_token = contract.nft_token(lease_nft_token_id.clone());

        assert!(a_token.is_some());
        assert_eq!(lease_nft_token_id, a_token.as_ref().unwrap().token_id);
        assert_eq!(
            lease_condition.lender_id.clone(),
            a_token.as_ref().unwrap().owner_id
        );
        assert!(a_token.as_ref().unwrap().metadata.is_some());
        assert!(a_token
            .as_ref()
            .unwrap()
            .metadata
            .as_ref()
            .unwrap()
            .title
            .is_some());
        assert!(a_token
            .as_ref()
            .unwrap()
            .metadata
            .as_ref()
            .unwrap()
            .description
            .is_some());
    }

    #[test]
    fn test_event_transfer_log_for_nft_transfer_succeeds() {
        let mut contract = Contract::new(accounts(0).into());
        let mut lease_condition = create_lease_condition_default();
        lease_condition.lender_id = create_a_dummy_account_id("alice");

        let lease_key = "test_key".to_string();
        contract.internal_insert_lease(&lease_key, &lease_condition);
        lease_condition.state = LeaseState::Active;

        contract.nft_mint(lease_key.clone(), lease_condition.lender_id.clone());
        testing_env!(VMContextBuilder::new()
            .current_account_id(accounts(0))
            .predecessor_account_id(lease_condition.lender_id.clone())
            .attached_deposit(1)
            .build());

        // transfer the nft
        let token_id = contract.lease_id_to_lease_token_id(&lease_key);
        contract.nft_transfer(
            create_a_dummy_account_id("bob"),
            token_id.clone(),
            None,
            None,
        );

        // Check transfer logs
        let transfer_log = &test_utils::get_logs()[0]; // the index can be different when other logs added
        let transfer_log_expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_transfer","data":[{"old_owner_id":"alice","new_owner_id":"bob","token_ids":["test_key_lender"]}]}"#;
        assert_eq!(transfer_log, transfer_log_expected);
    }
}

'''
'''--- contract/src/nft/data_image_svg.txt ---
data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22598%22%20height%3D%22598%22%20fill%3D%22none%22%3E%3Cg%20clip-path%3D%22url%28%23a%29%22%3E%3Cpath%20fill%3D%22%23fff%22%20d%3D%22M0%200h598v598H0z%22%2F%3E%3Cpath%20fill%3D%22%23343434%22%20d%3D%22m-199%2073%201%205-1%205%201%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205%201%205-1%205h-10v-10h-6l-1-5%201-5h-4l-1-6%201-5h-5l-1-5%201-5h-5v41h-11V62h13l1%205-1%206h4l1%205-1%205h4v10h5l1%205-1%205h5V62h10l1%205-1%206Zm26%200V62h10l1%205-1%206h-10Zm21%2051v10h-31l-1-5%201-5h10V93h-8V83h18l1%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205h11Zm51-31v10h-21l1%205-1%206%201%205-1%205%201%205-1%205h-10V62h31v11h-21l1%205-1%205%201%205-1%205h21Zm57-26-1%206h-15v61h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5h-16V62h41l1%205ZM7%2088l-1%205H3v10h-4v11h-3l1%205-1%205h-4l1%205-1%205h-2v10h-5v10h-16v-10h11l-1-5%201-5-1-5%201-5h-6v-10h-2l-1-6%201-5h-4V93h-4V83h10l1%205-1%205h4l1%205-1%205h4l1%205-1%206%201%205-1%205h4l-1-5%201-5h3l-1-6%201-5h3V93h4V83H6l1%205Zm51%2036v10H47v-10h-3l-1-5%201-5h-4l-1-6%201-5H27v31H17l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5h36v11h5v10h-3l1%205-1%205h-8l1%205-1%205h3l1%205-1%206h4v10h4ZM45%2093l-1-5%201-5-1-5%201-5H27v20h18Zm64%205v16H82l1%205-1%205h22v10H78v-10h-6l-1-5%201-5h-4l-1-6%201-5h4l-1-5%201-5h6V83h26v10h5v5Zm-10%205-1-5%201-5H82l1%205-1%205h17Zm30-15-1%205h5l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10V83h9l1%205Zm31%2015%201%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17V83h21v10h6l1%205-1%205Zm46%2021%201%205-1%205h-20l-1-5%201-5h-5l-1-5%201-5-1-6%201-5-1-5%201-5h-11V83h11l-1-5%201-5-1-6%201-5h10v21h15l1%205-1%205h-15v31h15Zm108%200v10h-36V62h10l1%205-1%206%201%205-1%205%201%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205h26Zm52-26-1%205%201%205-1%206h-27l1%205-1%205h22l1%205-1%205h-26v-10h-6v-10h-4v-11h4V93h6V83h26l1%205-1%205h5l1%205Zm-11%205-1-5%201-5h-17l1%205-1%205h17Zm61%2021%201%205-1%205h-10v-10h-5v-10h-15v10h15l1%205-1%205h-20l-1-5%201-5h-6v-10h6l-1-6%201-5h20V93h-18V83h23l1%205-1%205h5l1%205-1%205%201%205-1%206%201%205-1%205h5Zm50-5-1%205h-5l1%205-1%205h-28l-1-5%201-5h23l-1-5%201-5h-21v-11h-5V93h5V83h29v10h-23v10h20l1%205-1%206h5l1%205Zm53-21v16h-27l1%205-1%205h22v10h-26v-10h-6l-1-5%201-5h-4l-1-6%201-5h4l-1-5%201-5h6V83h26v10h5v5Zm-10%205-1-5%201-5h-17l1%205-1%205h17Zm112-10%201%205-1%205%201%205-1%206h-3v10h-7l1%205-1%205h-20l-1-5%201-5h-7v-10h-4V83h4V73h7l-1-6%201-5h20l1%205-1%206h7v10h3l1%205-1%205Zm-10%2021V83h-4V73h-12v10h-4v31h4v10h12v-10h4Zm62-26v15h-4v21h-3l1%205-1%205h-7l-1-5%201-5h-3v-10h-8l1%205-1%205h-2v10h-8v-10h-2l-1-5%201-5-1-6%201-5h-4l-1-5%201-5-1-5%201-5h10v31h4l-1-6%201-5h2V83h8l1%205-1%205%201%205-1%205h3v11h3V83h11v5Zm19%200v5h5l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5h9v5Zm32%2015v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17V83h21v10h6v10Zm52-5-1%205%201%205-1%206h-27l1%205-1%205h22l1%205-1%205h-26v-10h-6v-10h-4v-11h4V93h6V83h26l1%205-1%205h5l1%205Zm-11%205-1-5%201-5h-17l1%205-1%205h17Zm61-10%201%205-1%205h-10V93h-9l1%205-1%205h-4l1%205-1%206%201%205-1%205h8l1%205-1%205h-26v-10h8V93h-8V83h13l1%205-1%205h5V83h20v10h3Zm50%2026-1%205h-5l1%205-1%205h-28l-1-5%201-5h23l-1-5%201-5h-21v-11h-5V93h5V83h29v10h-23v10h20l1%205-1%206h5l1%205Zm23-31-1%205h4l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5h10l1%205-1%206%201%205-1%205%201%205Zm30%2015v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17V83h21v10h6v10Zm26-30-1-6%201-5h10v11h-10Zm20%2051%201%205-1%205h-31v-10h11l-1-5%201-5-1-6%201-5-1-5%201-5h-8l-1-5%201-5h18v41h10Zm57-16-1%206h-5l1%205-1%205h-5l1%205-1%205h-20v20h-11V83h11v10h5v10h-5v21h15v-10h5v-11h-5V93h-10l-1-5%201-5h15l1%205-1%205h5l1%205-1%205h5l1%205ZM58%20207l1%205-1%205%201%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205%201%205-1%205H48v-10h-6l-1-5%201-5h-4l-1-6%201-5h-5l-1-5%201-5h-5v41H17v-72h13l1%205-1%206h4l1%205-1%205h4v10h5l1%205-1%205h5v-41h10l1%205-1%206Zm26%200v-11h10l1%205-1%206H84Zm21%2051v10H74l-1-5%201-5h10v-31h-8v-10h18l1%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205h11Zm51-31v10h-21l1%205-1%206%201%205-1%205%201%205-1%205h-10v-72h31v11h-21l1%205-1%205%201%205-1%205h21Zm57-26-1%206h-15v61h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5h-16v-11h41l1%205Zm51%2021-1%205h-3v10h-4v11h-3l1%205-1%205h-4l1%205-1%205h-2v10h-5v10h-16v-10h11l-1-5%201-5-1-5%201-5h-6v-10h-2l-1-6%201-5h-4v-10h-4v-10h10l1%205-1%205h4l1%205-1%205h4l1%205-1%206%201%205-1%205h4l-1-5%201-5h3l-1-6%201-5h3v-10h4v-10h10l1%205Zm51%2036v10h-11v-10h-3l-1-5%201-5h-4l-1-6%201-5h-13v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5h36v11h5v10h-3l1%205-1%205h-8l1%205-1%205h3l1%205-1%206h4v10h4Zm-13-31-1-5%201-5-1-5%201-5h-18v20h18Zm64%205v16h-27l1%205-1%205h22v10h-26v-10h-6l-1-5%201-5h-4l-1-6%201-5h4l-1-5%201-5h6v-10h26v10h5v5Zm-10%205-1-5%201-5h-17l1%205-1%205h17Zm30-15-1%205h5l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10v-51h9l1%205Zm31%2015%201%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6l1%205-1%205Zm46%2021%201%205-1%205h-20l-1-5%201-5h-5l-1-5%201-5-1-6%201-5-1-5%201-5h-11v-10h11l-1-5%201-5-1-6%201-5h10v21h15l1%205-1%205h-15v31h15Zm108%200v10h-36v-72h10l1%205-1%206%201%205-1%205%201%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205h26Zm52-26-1%205%201%205-1%206h-27l1%205-1%205h22l1%205-1%205h-26v-10h-6v-10h-4v-11h4v-10h6v-10h26l1%205-1%205h5l1%205Zm-11%205-1-5%201-5h-17l1%205-1%205h17Zm61%2021%201%205-1%205h-10v-10h-5v-10h-15v10h15l1%205-1%205h-20l-1-5%201-5h-6v-10h6l-1-6%201-5h20v-10h-18v-10h23l1%205-1%205h5l1%205-1%205%201%205-1%206%201%205-1%205h5Zm50-5-1%205h-5l1%205-1%205h-28l-1-5%201-5h23l-1-5%201-5h-21v-11h-5v-10h5v-10h29v10h-23v10h20l1%205-1%206h5l1%205Zm53-21v16h-27l1%205-1%205h22v10h-26v-10h-6l-1-5%201-5h-4l-1-6%201-5h4l-1-5%201-5h6v-10h26v10h5v5Zm-10%205-1-5%201-5h-17l1%205-1%205h17Zm112-10%201%205-1%205%201%205-1%206h-3v10h-7l1%205-1%205h-20l-1-5%201-5h-7v-10h-4v-31h4v-10h7l-1-6%201-5h20l1%205-1%206h7v10h3l1%205-1%205Zm-10%2021v-31h-4v-10h-12v10h-4v31h4v10h12v-10h4Zm62-26v15h-4v21h-3l1%205-1%205h-7l-1-5%201-5h-3v-10h-8l1%205-1%205h-2v10h-8v-10h-2l-1-5%201-5-1-6%201-5h-4l-1-5%201-5-1-5%201-5h10v31h4l-1-6%201-5h2v-20h8l1%205-1%205%201%205-1%205h3v11h3v-31h11v5Zm19%200v5h5l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5h9v5Zm32%2015v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6v10Zm52-5-1%205%201%205-1%206h-27l1%205-1%205h22l1%205-1%205h-26v-10h-6v-10h-4v-11h4v-10h6v-10h26l1%205-1%205h5l1%205Zm-11%205-1-5%201-5h-17l1%205-1%205h17Zm61-10%201%205-1%205h-10v-10h-9l1%205-1%205h-4l1%205-1%206%201%205-1%205h8l1%205-1%205h-25l-1-5%201-5h7v-31h-7l-1-5%201-5h12l1%205-1%205h5v-10h20v10h3Zm50%2026-1%205h-5l1%205-1%205h-28l-1-5%201-5h23l-1-5%201-5h-21v-11h-5v-10h5v-10h29v10h-23v10h20l1%205-1%206h5l1%205Zm23-31-1%205h4l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5h10l1%205-1%206%201%205-1%205%201%205Zm30%2015v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6v10Zm26-30-1-6%201-5h10v11h-10Zm20%2051%201%205-1%205h-31v-10h11l-1-5%201-5-1-6%201-5-1-5%201-5h-8l-1-5%201-5h18v41h10Zm57-16-1%206h-5l1%205-1%205h-5l1%205-1%205h-20v20h-10l-1-5%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5h10v10h5v10h-5v21h15v-10h5v-11h-5v-10h-10l-1-5%201-5h15l1%205-1%205h5l1%205-1%205h5l1%205ZM391%20345l1%205-1%205%201%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205%201%205-1%205h-10v-10h-6l-1-5%201-5h-4l-1-6%201-5h-5l-1-5%201-5h-5v41h-11v-72h13l1%205-1%206h4l1%205-1%205h4v10h5l1%205-1%205h5v-41h10l1%205-1%206Zm26%200v-11h10l1%205-1%206h-10Zm21%2051v10h-31l-1-5%201-5h10v-31h-8v-10h18l1%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205h11Zm51-31v10h-21l1%205-1%206%201%205-1%205%201%205-1%205h-10v-72h31v11h-21l1%205-1%205%201%205-1%205h21Zm57-26-1%206h-15v61h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5h-16v-11h41l1%205Zm51%2021-1%205h-3v10h-4v11h-3l1%205-1%205h-4l1%205-1%205h-2v10h-5v10h-16v-10h11l-1-5%201-5-1-5%201-5h-6v-10h-2l-1-6%201-5h-4v-10h-4v-10h10l1%205-1%205h4l1%205-1%205h4l1%205-1%206%201%205-1%205h4l-1-5%201-5h3l-1-6%201-5h3v-10h4v-10h10l1%205Zm51%2036v10h-11v-10h-3l-1-5%201-5h-4l-1-6%201-5h-13v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5h36v11h5v10h-3l1%205-1%205h-8l1%205-1%205h3l1%205-1%206h4v10h4Zm-13-31-1-5%201-5-1-5%201-5h-18v20h18Zm64%205v16h-27l1%205-1%205h22v10h-26v-10h-6l-1-5%201-5h-4l-1-6%201-5h4l-1-5%201-5h6v-10h26v10h5v5Zm-10%205-1-5%201-5h-17l1%205-1%205h17Zm30-15-1%205h5l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10v-51h9l1%205Zm31%2015%201%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6l1%205-1%205Zm46%2021%201%205-1%205h-20l-1-5%201-5h-5l-1-5%201-5-1-6%201-5-1-5%201-5h-11v-10h11l-1-5%201-5-1-6%201-5h10v21h15l1%205-1%205h-15v31h15Zm108%200v10h-36v-72h10l1%205-1%206%201%205-1%205%201%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205h26Zm52-26-1%205%201%205-1%206h-27l1%205-1%205h22l1%205-1%205h-26v-10h-6v-10h-4v-11h4v-10h6v-10h26l1%205-1%205h5l1%205Zm-11%205-1-5%201-5h-17l1%205-1%205h17Zm61%2021%201%205-1%205h-10v-10h-5v-10h-15v10h15l1%205-1%205h-20l-1-5%201-5h-6v-10h6l-1-6%201-5h20v-10h-18v-10h23l1%205-1%205h5l1%205-1%205%201%205-1%206%201%205-1%205h5Zm50-5-1%205h-5l1%205-1%205h-28l-1-5%201-5h23l-1-5%201-5h-21v-11h-5v-10h5v-10h29v10h-23v10h20l1%205-1%206h5l1%205Zm53-21v16h-27l1%205-1%205h22v10h-26v-10h-6l-1-5%201-5h-4l-1-6%201-5h4l-1-5%201-5h6v-10h26v10h5v5Zm-10%205-1-5%201-5h-17l1%205-1%205h17Zm112-10%201%205-1%205%201%205-1%206h-3v10h-7l1%205-1%205h-20l-1-5%201-5h-7v-10h-3l-1-6%201-5-1-5%201-5-1-5%201-5h3v-10h7l-1-6%201-5h20l1%205-1%206h7v10h3l1%205-1%205Zm-10%2021v-31h-4v-10h-12v10h-4v31h4v10h12v-10h4Zm62-26v15h-4v21h-3l1%205-1%205h-7l-1-5%201-5h-3v-10h-8l1%205-1%205h-2v10h-8v-10h-2l-1-5%201-5-1-6%201-5h-4l-1-5%201-5-1-5%201-5h10l1%205-1%205%201%205-1%205%201%205-1%206h4l-1-6%201-5h2v-20h8l1%205-1%205%201%205-1%205h3v11h3v-31h11v5Zm19%200v5h5l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5h9v5Zm32%2015v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6v10Zm52-5-1%205%201%205-1%206h-27l1%205-1%205h22l1%205-1%205h-26v-10h-6v-10h-4v-11h4v-10h6v-10h26l1%205-1%205h5l1%205Zm-11%205-1-5%201-5h-17l1%205-1%205h17Zm61-10%201%205-1%205h-10v-10h-9l1%205-1%205h-4l1%205-1%206%201%205-1%205h8l1%205-1%205h-25l-1-5%201-5h7v-31h-7l-1-5%201-5h12l1%205-1%205h5v-10h20v10h3Zm50%2026-1%205h-5l1%205-1%205h-28l-1-5%201-5h23l-1-5%201-5h-21v-11h-5v-10h5v-10h29v10h-23v10h20l1%205-1%206h5l1%205Zm23-31-1%205h4l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5h10l1%205-1%206%201%205-1%205%201%205Zm30%2015v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6v10Zm26-30-1-6%201-5h10v11h-10Zm20%2051%201%205-1%205h-31v-10h11l-1-5%201-5-1-6%201-5-1-5%201-5h-8l-1-5%201-5h18v41h10Zm57-16-1%206h-5l1%205-1%205h-5l1%205-1%205h-20v20h-10l-1-5%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5h10v10h5v10h-5v21h15v-10h5v-11h-5v-10h-10l-1-5%201-5h15l1%205-1%205h5l1%205-1%205h5l1%205ZM-542%20479l1%205-1%205%201%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205%201%205-1%205h-10v-10h-6l-1-5%201-5h-4l-1-6%201-5h-5l-1-5%201-5h-5v41h-11v-72h13l1%205-1%206h4l1%205-1%205h4v10h5l1%205-1%205h5v-41h10l1%205-1%206Zm26%200v-11h10l1%205-1%206h-10Zm21%2051v10h-31l-1-5%201-5h10v-31h-8v-10h18l1%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205h11Zm51-31v10h-21l1%205-1%206%201%205-1%205%201%205-1%205h-10v-72h31v11h-21l1%205-1%205%201%205-1%205h21Zm57-26-1%206h-15v61h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5h-16v-11h41l1%205Zm51%2021-1%205h-3v10h-4v11h-3l1%205-1%205h-4l1%205-1%205h-2v10h-5v10h-16v-10h11l-1-5%201-5-1-5%201-5h-6v-10h-2l-1-6%201-5h-4v-10h-4v-10h10l1%205-1%205h4l1%205-1%205h4l1%205-1%206%201%205-1%205h4l-1-5%201-5h3l-1-6%201-5h3v-10h4v-10h10l1%205Zm51%2036v10h-11v-10h-3l-1-5%201-5h-4l-1-6%201-5h-13v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5h36v11h5v10h-3l1%205-1%205h-8l1%205-1%205h3l1%205-1%206h4v10h4Zm-13-31-1-5%201-5-1-5%201-5h-18v20h18Zm64%205v16h-27l1%205-1%205h22v10h-26v-10h-6l-1-5%201-5h-4l-1-6%201-5h4l-1-5%201-5h6v-10h26v10h5v5Zm-10%205-1-5%201-5h-17l1%205-1%205h17Zm30-15-1%205h5l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10v-51h9l1%205Zm31%2015%201%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6l1%205-1%205Zm46%2021%201%205-1%205h-20l-1-5%201-5h-5l-1-5%201-5-1-6%201-5-1-5%201-5h-11v-10h11l-1-5%201-5-1-6%201-5h10v21h15l1%205-1%205h-15v31h15Zm108%200v10h-36v-72h10l1%205-1%206%201%205-1%205%201%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205h26Zm52-26-1%205%201%205-1%206H-5l1%205-1%205h22l1%205-1%205H-9v-10h-6v-10h-4v-11h4v-10h6v-10h26l1%205-1%205h5l1%205Zm-11%205-1-5%201-5H-5l1%205-1%205h17Zm61%2021%201%205-1%205H63v-10h-5v-10H43v10h15l1%205-1%205H38l-1-5%201-5h-6v-10h6l-1-6%201-5h20v-10H40v-10h23l1%205-1%205h5l1%205-1%205%201%205-1%206%201%205-1%205h5Zm50-5-1%205h-5l1%205-1%205H89l-1-5%201-5h23l-1-5%201-5H91v-11h-5v-10h5v-10h29v10H97v10h20l1%205-1%206h5l1%205Zm53-21v16h-27l1%205-1%205h22v10h-26v-10h-6l-1-5%201-5h-4l-1-6%201-5h4l-1-5%201-5h6v-10h26v10h5v5Zm-10%205-1-5%201-5h-17l1%205-1%205h17Zm112-10%201%205-1%205%201%205-1%206h-3v10h-7l1%205-1%205h-20l-1-5%201-5h-7v-10h-4v-31h4v-10h7l-1-6%201-5h20l1%205-1%206h7v10h3l1%205-1%205Zm-10%2021v-31h-4v-10h-12v10h-4v31h4v10h12v-10h4Zm62-26v15h-4v21h-3l1%205-1%205h-7l-1-5%201-5h-3v-10h-8l1%205-1%205h-2v10h-8v-10h-2l-1-5%201-5-1-6%201-5h-4l-1-5%201-5-1-5%201-5h10v31h4l-1-6%201-5h2v-20h8l1%205-1%205%201%205-1%205h3v11h3v-31h11v5Zm19%200v5h5l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5h9v5Zm32%2015v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6v10Zm52-5-1%205%201%205-1%206h-27l1%205-1%205h22l1%205-1%205h-26v-10h-6v-10h-4v-11h4v-10h6v-10h26l1%205-1%205h5l1%205Zm-11%205-1-5%201-5h-17l1%205-1%205h17Zm61-10%201%205-1%205h-10v-10h-9l1%205-1%205h-4l1%205-1%206%201%205-1%205h8l1%205-1%205h-26v-10h8v-31h-8v-10h13l1%205-1%205h5v-10h20v10h3Zm50%2026-1%205h-5l1%205-1%205h-28l-1-5%201-5h23l-1-5%201-5h-21v-11h-5v-10h5v-10h29v10h-23v10h20l1%205-1%206h5l1%205Zm23-31-1%205h4l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5h10l1%205-1%206%201%205-1%205%201%205Zm30%2015v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6v10Zm26-30-1-6%201-5h10v11h-10Zm20%2051%201%205-1%205h-31v-10h11l-1-5%201-5-1-6%201-5-1-5%201-5h-8l-1-5%201-5h18v41h10Zm57-16-1%206h-5l1%205-1%205h-5l1%205-1%205h-20v20h-11v-71h11v10h5v10h-5v21h15v-10h5v-11h-5v-10h-10l-1-5%201-5h15l1%205-1%205h5l1%205-1%205h5l1%205ZM-920%20345l1%205-1%205%201%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205%201%205-1%205h-10v-10h-6l-1-5%201-5h-4l-1-6%201-5h-5l-1-5%201-5h-5v41h-11v-72h13l1%205-1%206h4l1%205-1%205h4v10h5l1%205-1%205h5v-41h10l1%205-1%206Zm26%200v-11h10l1%205-1%206h-10Zm21%2051v10h-31l-1-5%201-5h10v-31h-8v-10h18l1%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205h11Zm51-31v10h-21l1%205-1%206%201%205-1%205%201%205-1%205h-10v-72h31v11h-21l1%205-1%205%201%205-1%205h21Zm57-26-1%206h-15v61h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5h-16v-11h41l1%205Zm51%2021-1%205h-3v10h-4v11h-3l1%205-1%205h-4l1%205-1%205h-2v10h-5v10h-16v-10h11l-1-5%201-5-1-5%201-5h-6v-10h-2l-1-6%201-5h-4v-10h-4v-10h10l1%205-1%205h4l1%205-1%205h4l1%205-1%206%201%205-1%205h4l-1-5%201-5h3l-1-6%201-5h3v-10h4v-10h10l1%205Zm51%2036v10h-11v-10h-3l-1-5%201-5h-4l-1-6%201-5h-13v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5h36v11h5v10h-3l1%205-1%205h-8l1%205-1%205h3l1%205-1%206h4v10h4Zm-13-31-1-5%201-5-1-5%201-5h-18v20h18Zm64%205v16h-27l1%205-1%205h22v10h-26v-10h-6l-1-5%201-5h-4l-1-6%201-5h4l-1-5%201-5h6v-10h26v10h5v5Zm-10%205-1-5%201-5h-17l1%205-1%205h17Zm30-15-1%205h5l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10v-51h9l1%205Zm31%2015%201%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6l1%205-1%205Zm46%2021%201%205-1%205h-20l-1-5%201-5h-5l-1-5%201-5-1-6%201-5-1-5%201-5h-11v-10h11l-1-5%201-5-1-6%201-5h10v21h15l1%205-1%205h-15v31h15Zm108%200v10h-36v-72h10l1%205-1%206%201%205-1%205%201%205-1%205%201%205-1%205%201%205-1%206%201%205-1%205h26Zm52-26-1%205%201%205-1%206h-27l1%205-1%205h22l1%205-1%205h-26v-10h-6v-10h-4v-11h4v-10h6v-10h26l1%205-1%205h5l1%205Zm-11%205-1-5%201-5h-17l1%205-1%205h17Zm61%2021%201%205-1%205h-10v-10h-5v-10h-15v10h15l1%205-1%205h-20l-1-5%201-5h-6v-10h6l-1-6%201-5h20v-10h-18v-10h23l1%205-1%205h5l1%205-1%205%201%205-1%206%201%205-1%205h5Zm50-5-1%205h-5l1%205-1%205h-28l-1-5%201-5h23l-1-5%201-5h-21v-11h-5v-10h5v-10h29v10h-23v10h20l1%205-1%206h5l1%205Zm53-21v16h-27l1%205-1%205h22v10h-26v-10h-6l-1-5%201-5h-4l-1-6%201-5h4l-1-5%201-5h6v-10h26v10h5v5Zm-10%205-1-5%201-5h-17l1%205-1%205h17Zm112-10%201%205-1%205%201%205-1%206h-3v10h-7l1%205-1%205h-20l-1-5%201-5h-7v-10h-4v-31h4v-10h7l-1-6%201-5h20l1%205-1%206h7v10h3l1%205-1%205Zm-10%2021v-31h-4v-10h-12v10h-4v31h4v10h12v-10h4Zm62-26v15h-4v21h-3l1%205-1%205h-7l-1-5%201-5h-3v-10h-8l1%205-1%205h-2v10h-8v-10h-2l-1-5%201-5-1-6%201-5h-4l-1-5%201-5-1-5%201-5h10v31h4l-1-6%201-5h2v-20h8l1%205-1%205%201%205-1%205h3v11h3v-31h11v5Zm19%200v5h5l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5h9v5Zm32%2015v31H-7l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6v10Zm52-5-1%205%201%205-1%206H27l1%205-1%205h22l1%205-1%205H23v-10h-6v-10h-4v-11h4v-10h6v-10h26l1%205-1%205h5l1%205Zm-11%205-1-5%201-5H27l1%205-1%205h17Zm61-10%201%205-1%205H95v-10h-9l1%205-1%205h-4l1%205-1%206%201%205-1%205h8l1%205-1%205H64v-10h8v-31h-8v-10h13l1%205-1%205h5v-10h20v10h3Zm50%2026-1%205h-5l1%205-1%205h-28l-1-5%201-5h23l-1-5%201-5h-21v-11h-5v-10h5v-10h29v10h-23v10h20l1%205-1%206h5l1%205Zm23-31-1%205h4l1%205-1%205h-4l1%205-1%206%201%205-1%205%201%205-1%205h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5-1-5%201-5-1-5%201-5-1-6%201-5h10l1%205-1%206%201%205-1%205%201%205Zm30%2015v31h-10l-1-5%201-5-1-5%201-5-1-6%201-5-1-5%201-5h-17v-10h21v10h6v10Zm26-30-1-6%201-5h10v11h-10Zm20%2051%201%205-1%205h-31v-10h11l-1-5%201-5-1-6%201-5-1-5%201-5h-8l-1-5%201-5h18v41h10Zm57-16-1%206h-5l1%205-1%205h-5l1%205-1%205h-20v20h-11v-71h11v10h5v10h-5v21h15v-10h5v-11h-5v-10h-10l-1-5%201-5h15l1%205-1%205h5l1%205-1%205h5l1%205Z%22%2F%3E%3C%2Fg%3E%3Cdefs%3E%3CclipPath%20id%3D%22a%22%3E%3Cpath%20fill%3D%22%23fff%22%20d%3D%22M0%200h598v598H0z%22%2F%3E%3C%2FclipPath%3E%3C%2Fdefs%3E%3C%2Fsvg%3E

'''
'''--- contract/src/nft/enumeration.rs ---
use crate::{nft::core::NonFungibleTokenCore, *};
use near_contract_standards::non_fungible_token::{
    enumeration::NonFungibleTokenEnumeration, Token,
};
use near_sdk::json_types::U128;

#[near_bindgen]
impl NonFungibleTokenEnumeration for Contract {
    /// Returns the total supply of non-fungible tokens as a string representing an
    /// Unsigned 128-bit integer to avoid JSON number limit of 2^53.
    fn nft_total_supply(&self) -> U128 {
        U128(self.active_lease_ids.len() as u128)
    }

    /// Get a list of all tokens.
    /// Returns an array of Token objects, for Pagination.
    fn nft_tokens(
        &self,
        from_index: Option<U128>, // default: "0"
        limit: Option<u64>,       // default: unlimited (could fail due to gas limit)
    ) -> Vec<Token> {
        // Get starting index, default to 0
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        require!(
            (self.active_lease_ids.len() as u128) >= start_index,
            "Out of bounds, please use a smaller from_index."
        );

        // Sainity check on limit
        let limit = limit.map(|v| v as usize).unwrap_or(usize::MAX);

        self.active_lease_ids
            .iter()
            .skip(start_index as usize)
            .take(limit)
            .map(|active_lease_id| {
                self.nft_token(self.lease_id_to_lease_token_id(&active_lease_id))
                    .unwrap()
            })
            .collect()
    }

    /// Get total NFT supply for a given account
    fn nft_supply_for_owner(&self, account_id: AccountId) -> U128 {
        let active_lease_ids_set = self.active_lease_ids_by_lender.get(&account_id);

        if let Some(active_lease_ids) = active_lease_ids_set {
            U128(active_lease_ids.len() as u128)
        } else {
            U128(0)
        }
    }

    /// Get list of all tokens owned by a given account
    fn nft_tokens_for_owner(
        &self,
        account_id: AccountId,
        from_index: Option<U128>, // default: "0"
        limit: Option<u64>,       // 10
    ) -> Vec<Token> {
        let active_lease_ids_per_owner_set = self.active_lease_ids_by_lender.get(&account_id);

        // If there is some set of active lease ids, process that ids set
        let active_lease_ids =
            if let Some(active_lease_ids_per_owner_set) = active_lease_ids_per_owner_set {
                active_lease_ids_per_owner_set
            } else {
                // If there is no active leases for the user, return an empty vector.
                return vec![];
            };

        // Get starting index, default to 0
        let start_index: u128 = from_index.map(From::from).unwrap_or_default();
        require!(
            (active_lease_ids.len() as u128) >= start_index,
            "Out of bounds. Please use a smaller from_index."
        );

        // Iterate through the keys vector
        active_lease_ids
            .iter()
            .skip(start_index as usize)
            .take(limit.unwrap_or(10) as usize)
            .map(|active_lease_id| {
                self.nft_token(self.lease_id_to_lease_token_id(&active_lease_id))
                    .unwrap()
            })
            .collect()
    }
}

'''
'''--- contract/src/nft/internal.rs ---
use crate::*;
use near_contract_standards::non_fungible_token::events::{NftMint, NftTransfer};
use near_contract_standards::non_fungible_token::Token;

/// This file includes NFT related features but not required in the Nomicon Standards

// #[near_bindgen]
impl Contract {
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        token_id: &TokenId,
        memo: Option<String>,
    ) -> Token {
        // Check if the lease exist
        let lease_id = self.lease_token_id_to_lease_id(token_id);
        let lease_condition = self
            .lease_map
            .get(&lease_id)
            .expect("No matching lease for the given LEASE token id!");
        let owner_id = lease_condition.lender_id.clone();
        assert_eq!(&owner_id, sender_id, "Only current lender can transfer!");
        assert_ne!(
            &owner_id, receiver_id,
            "Current lender can not be the receiver!"
        );

        // Transfer lease from sender to receiver
        self.internal_update_active_lease_lender(sender_id, receiver_id, &lease_id);

        // Log transfer event as per the Events standard
        NftTransfer {
            old_owner_id: sender_id,
            new_owner_id: receiver_id,
            token_ids: &[token_id],
            authorized_id: None,
            memo: memo.as_deref(),
        }
        .emit();

        // Return the new token info, when internal transfer succeeded
        Token {
            token_id: token_id.clone(),
            owner_id: receiver_id.clone(),
            metadata: None,
            approved_account_ids: None,
        }
    }

    /// Update NFT related fields. It will be called once lease become active.
    /// In essence, this function updates indices that tracks active lease.
    /// This function is visible only within the current contract
    pub(crate) fn nft_mint(&mut self, lease_id: LeaseId, receiver_id: AccountId) {
        // Update the record for active_leases
        let mut active_lease_ids_set = self
            .active_lease_ids_by_lender
            .get(&receiver_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::ActiveLeaseIdsByOwnerInner {
                        // get a new unique prefix for the collection by hashing owner
                        account_id_hash: utils::hash_account_id(&receiver_id),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });

        active_lease_ids_set.insert(&lease_id);
        self.active_lease_ids_by_lender
            .insert(&receiver_id, &active_lease_ids_set);

        // Record active leases/Lease Tokens
        self.active_lease_ids.insert(&lease_id);

        // Log mint event as per the Events standard
        let token_id = self.lease_id_to_lease_token_id(&lease_id);
        NftMint {
            owner_id: &receiver_id,
            token_ids: &[&token_id],
            memo: None,
        }
        .emit();
    }

    pub(crate) fn lease_token_id_to_lease_id(&self, token_id: &TokenId) -> LeaseId {
        let splits: Vec<&str> = token_id.split("_lender").collect();
        splits[0].to_string()
    }

    pub(crate) fn lease_id_to_lease_token_id(&self, lease_id: &LeaseId) -> TokenId {
        let suffix: &str = "_lender";
        format!("{}{}", lease_id, suffix)
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    /*
    Unit test cases and helper functions

    Test naming format for better readability:
    - test_{function_name} _{succeeds_or_fails} _{condition}
    - When more than one test cases are needed for one function,
    follow the code order of testing failing conditions first and success condition last
    */

    use crate::tests::*;
    use crate::{Contract, LeaseId, LeaseState};

    use near_contract_standards::non_fungible_token::TokenId;
    use near_sdk::test_utils::{self, accounts};

    #[test]
    fn test_lease_id_to_lease_token_id_succeeds() {
        let lease_id: LeaseId = "8Vin66zVuhiB6tb9Zn9P6vRJpjQMEUMum1EkKESxJnK".to_string();
        let lease_token_id_expected: TokenId =
            "8Vin66zVuhiB6tb9Zn9P6vRJpjQMEUMum1EkKESxJnK_lender".to_string();

        let contract = Contract::new(accounts(1).into());
        let lease_token_id_real: TokenId = contract.lease_id_to_lease_token_id(&lease_id);

        assert_eq!(lease_token_id_expected, lease_token_id_real);
    }

    #[test]
    fn test_lease_token_id_to_lease_id_succeeds() {
        let lease_token_id: TokenId =
            "8Vin66zVuhiB6tb9Zn9P6vRJpjQMEUMum1EkKESxJnK_lender".to_string();
        let lease_id_expected: LeaseId = "8Vin66zVuhiB6tb9Zn9P6vRJpjQMEUMum1EkKESxJnK".to_string();

        let contract = Contract::new(accounts(1).into());
        let lease_id_real: LeaseId = contract.lease_token_id_to_lease_id(&lease_token_id);

        assert_eq!(lease_id_expected, lease_id_real);
    }

    /// check the indices got updated correctly
    /// - active_lease_ids got updated
    /// - active_lease_ids_by_lender has new record
    #[test]
    fn test_nft_mint_succeeds() {
        let mut contract = Contract::new(accounts(0).into());
        let mut lease_condition = create_lease_condition_default();

        let lease_key = "test_key".to_string();
        contract.internal_insert_lease(&lease_key, &lease_condition);
        lease_condition.state = LeaseState::Active;

        // Before calling nft mint, no records for the active lease
        assert!(!contract.active_lease_ids.contains(&lease_key));
        assert!(!contract
            .active_lease_ids_by_lender
            .contains_key(&lease_condition.lender_id));

        contract.nft_mint(lease_key.clone(), lease_condition.lender_id.clone());

        // After calling nft_mint(), active lease records should be updated
        assert!(contract.active_lease_ids.contains(&lease_key));
        assert!(contract
            .active_lease_ids_by_lender
            .contains_key(&lease_condition.lender_id));
        assert_eq!(
            contract.lease_map.get(&lease_key).unwrap().lender_id,
            lease_condition.lender_id
        );
        assert!(contract
            .active_lease_ids_by_lender
            .get(&lease_condition.lender_id)
            .unwrap()
            .contains(&lease_key));
    }

    #[test]
    fn test_event_mint_log_succeeds() {
        let mut contract = Contract::new(accounts(0).into());
        let lease_key = "test_key".to_string();

        contract.nft_mint(lease_key.clone(), create_a_dummy_account_id("alice"));

        // Check logs output correctly
        let mint_log = &test_utils::get_logs()[0];
        let mint_log_expected = r#"EVENT_JSON:{"standard":"nep171","version":"1.0.0","event":"nft_mint","data":[{"owner_id":"alice","token_ids":["test_key_lender"]}]}"#;
        assert_eq!(mint_log, mint_log_expected);
    }
}

'''
'''--- contract/src/nft/metadata.rs ---
use crate::*;
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, NFT_METADATA_SPEC,
};

// TODO(libo): Consider minifying it before launch to mainnet.
const DATA_IMAGE_SVG: &str = include_str!("data_image_svg.txt");

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    // Contract metatdata will be hardcoded for now
    fn nft_metadata(&self) -> NFTContractMetadata {
        NFTContractMetadata {
            spec: NFT_METADATA_SPEC.to_string(),
            name: "NiFTyRent Lease Ownership Token".to_string(),
            symbol: "LEASE".to_string(),
            icon: Some(DATA_IMAGE_SVG.to_string()),
            base_uri: None,
            reference: None,
            reference_hash: None,
        }
    }
}

'''
'''--- contract/src/nft/mod.rs ---
pub mod core;
pub mod enumeration;
pub mod internal;
pub mod metadata;

'''
'''--- contract/src/utils.rs ---
use near_sdk::{env, AccountId, CryptoHash};

pub fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

'''
'''--- demo_nft_contract/Cargo.toml ---
[package]
name = "tamagotchi"
version = "1.0.0"
authors = ["Libo <liboooshen@gmail.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- demo_nft_contract/README.md ---
# Tamagotchi

'''
'''--- demo_nft_contract/src/lib.rs ---
use std::collections::HashMap;

use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

const MESSAGE: &str = r#"
 ________________________________________
/ You have Egyptian flu: you're going to \
\ be a mummy.                            /
 ----------------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
"#;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

pub type PayoutHashMap = HashMap<AccountId, U128>;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: PayoutHashMap,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract owned by `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId) -> Self {
        Self::new(
            owner_id,
            NFTContractMetadata {
                spec: NFT_METADATA_SPEC.to_string(),
                name: "Tamagotchi".to_string(),
                symbol: "TAMA".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                base_uri: None,
                reference: None,
                reference_hash: None,
            },
        )
    }

    #[init]
    pub fn new(owner_id: AccountId, metadata: NFTContractMetadata) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(&metadata)),
        }
    }

    pub fn pat(&self, token_id: TokenId) -> String {
        let owner = self.tokens.owner_by_id.get(&token_id).unwrap();

        assert_eq!(env::predecessor_account_id(), owner);

        MESSAGE.to_string()
    }

    /// Mint a new token with ID=`token_id` belonging to `receiver_id`.
    ///
    /// Since this example implements metadata, it also requires per-token metadata to be provided
    /// in this call. `self.tokens.mint` will also require it to be Some, since
    /// `StorageKey::TokenMetadata` was provided at initialization.
    ///
    /// `self.tokens.mint` will enforce `predecessor_account_id` to equal the `owner_id` given in
    /// initialization call to `new`.
    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens
            .mint(token_id, receiver_id, Some(token_metadata))
    }

    pub fn nft_payout(&self, token_id: TokenId, balance: U128, _max_len_payout: Option<u32>) -> Payout {
        let treasury_split = balance.0 / 20;
        let owner_split = balance.0 - treasury_split;
        let owner = self.tokens.owner_by_id.get(&token_id).unwrap();
        Payout {
            payout: HashMap::from([
                (env::current_account_id(), U128::from(treasury_split)),
                (owner, U128::from(owner_split)),
            ]),
        }
    }

    #[payable]
    pub fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: String,
        approval_id: u64,
        balance: near_sdk::json_types::U128,
        max_len_payout: u32,
    ) -> Payout {
        let payout = self.nft_payout(token_id.clone(), balance, Some(max_len_payout));
        self.nft_transfer(receiver_id, token_id.clone(), Some(approval_id), None);
        payout
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use std::collections::HashMap;

    use super::*;

    const MINT_STORAGE_COST: u128 = 5870000000000000000000;

    fn get_context(predecessor_account_id: AccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    fn sample_token_metadata() -> TokenMetadata {
        TokenMetadata {
            title: Some("Olympus Mons".into()),
            description: Some("The tallest mountain in the charted solar system".into()),
            media: None,
            media_hash: None,
            copies: Some(1u64),
            issued_at: None,
            expires_at: None,
            starts_at: None,
            updated_at: None,
            extra: None,
            reference: None,
            reference_hash: None,
        }
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.nft_token("1".to_string()), None);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_mint() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());

        let token_id = "0".to_string();
        let token = contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());
        assert_eq!(token.token_id, token_id);
        assert_eq!(token.owner_id.to_string(), accounts(0).to_string());
        assert_eq!(token.metadata.unwrap(), sample_token_metadata());
        assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_transfer(accounts(1), token_id.clone(), None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        if let Some(token) = contract.nft_token(token_id.clone()) {
            assert_eq!(token.token_id, token_id);
            assert_eq!(token.owner_id.to_string(), accounts(1).to_string());
            assert_eq!(token.metadata.unwrap(), sample_token_metadata());
            assert_eq!(token.approved_account_ids.unwrap(), HashMap::new());
        } else {
            panic!("token not correctly created, or not found by nft_token");
        }
    }

    #[test]
    fn test_approve() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }

    #[test]
    fn test_revoke() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke(token_id.clone(), accounts(1));
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), None));
    }

    #[test]
    fn test_revoke_all() {
        let mut context = get_context(accounts(0));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(0).into());

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(MINT_STORAGE_COST)
            .predecessor_account_id(accounts(0))
            .build());
        let token_id = "0".to_string();
        contract.nft_mint(token_id.clone(), accounts(0), sample_token_metadata());

        // alice approves bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(150000000000000000000)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_approve(token_id.clone(), accounts(1), None);

        // alice revokes bob
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(0))
            .build());
        contract.nft_revoke_all(token_id.clone());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert!(!contract.nft_is_approved(token_id.clone(), accounts(1), Some(1)));
    }
}

'''
'''--- demo_nft_frontend/index.html ---
<!DOCTYPE html>
<html lang="en" class="h-full bg-gray-100">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/src/main.css" />
    <title>NEAR Tamagotchi</title>
  </head>
  <body class="h-full">
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <script src="./src/index.jsx" type="module"></script>
  </body>
</html>

'''
'''--- demo_nft_frontend/package.json ---
{
  "name": "nft-demo",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "env-cmd -f ../demo_nft_contract/neardev/dev-account.env vite",
    "build": "CONTRACT_NAME=nft-rental.near vite build && yarn netlify_redirects",
    "build_testnet": "CONTRACT_NAME=tamagotchi-nft.testnet vite build -m testnet && yarn netlify_redirects",
    "build_mainnet": "CONTRACT_NAME=nft-rental.near vite build -m mainnet && yarn netlify_redirects",
    "netlify_redirects": "echo \"/* /index.html 200\" > dist/_redirects"
  },
  "devDependencies": {
    "@babel/core": "^7.18.2",
    "@babel/preset-env": "^7.18.2",
    "@babel/preset-react": "^7.17.12",
    "@types/node": "^18.6.2",
    "@vitejs/plugin-react": "^2.0.1",
    "autoprefixer": "^10.4.8",
    "ava": "^4.2.0",
    "env-cmd": "^10.1.0",
    "nodemon": "^2.0.16",
    "postcss": "^8.4.16",
    "process": "^0.11.10",
    "react-test-renderer": "^18.1.0",
    "tailwindcss": "^3.1.8",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2",
    "vite": "^3.0.9"
  },
  "dependencies": {
    "@apollo/client": "^3.6.9",
    "@niftyrent/sdk": "^0.0.8",
    "@tailwindcss/forms": "^0.5.3",
    "graphql": "^16.6.0",
    "near-api-js": "^1.1.0",
    "react": "^18.1.0",
    "react-dom": "^18.1.0",
    "react-router-dom": "6",
    "regenerator-runtime": "^0.13.9"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- demo_nft_frontend/src/NftContract.js ---
const { connect, Contract, keyStores, WalletConnection } = window.nearApi;
import { nearConfig } from "./near-api";

// Initialize contract & set global variables
export async function initContract(contractName) {
  return await new Contract(window.walletConnection.account(), contractName, {
    viewMethods: ["nft_tokens_for_owner", "nft_token"],
    changeMethods: ["nft_approve"],
  });
}

export async function nftTokensForOwner(contract, accountId) {
  if (accountId == "") return [];
  let tokens = await contract.nft_tokens_for_owner({
    account_id: window.accountId,
  });
  return tokens;
}

export async function getToken(contract, tokenId) {
  if (tokenId == "") return null;
  let token = await contract.nft_token({
    token_id: tokenId,
  });
  return token;
}

'''
'''--- demo_nft_frontend/src/RentalContract.js ---
const { Contract } = window.nearApi;

// Initialize contract & set global variables
export async function initContract(contractName) {
  return await new Contract(window.walletConnection.account(), contractName, {
    viewMethods: ["get_borrower_by_contract_and_token"],
    changeMethods: [],
  });
}

export async function getBorrower(contract, nftContractId, tokenId) {
  let res = await contract.get_borrower_by_contract_and_token({
    contract_id: nftContractId,
    token_id: tokenId,
  });
  return res;
}

'''
'''--- demo_nft_frontend/src/Utils.js ---
export function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}

'''
'''--- demo_nft_frontend/src/main.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

'''
'''--- demo_nft_frontend/tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{html,js,jsx,ts,tsx}", "./index.html"],
  theme: {
    extend: {},
  },
  plugins: [require("@tailwindcss/forms")],
};

'''
'''--- demo_nft_frontend/vite.config.js ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  loader: { ".js": "jsx" },
  // To read contract name
  envPrefix: "CONTRACT_",
});

'''
'''--- docs/NFT Rental Standard Draft.md ---
(WIP) NEAR NFT Rental Standard Proposal

## Rental Proxy

A rental proxy is a smart contrac serves as a middle agent to coordinate the NFT renting activities.

There may exist multiple rental proxies on the market, and the NFT utility providers has the ability (if they want) to choose which rental proxies are supported for their services. For example, they can ignore the rental proxies who don't pay the royalty split properly.

During the period of renting, the NFT will be kept in the custody of the rental proxy contract. Rental proxies should provide mechanisms for depositing and claiming back the NFTs.

A rental proxy needs to implement the following interface:

```rust
/// Returns the current legit borrower info
fn get_borrower(contract_addr: AccountId, token_id: TokenId) -> AccountId
```

## Look Up Flow

1. A view-only request send to the NFT contract's to look up the token owner. This will return the account of the rental proxy contract which is in use.
2. If the returned address is regocnised as a rental proxy in the allowlist, then send another view-only request to it, invoking the `get_borrower` function. This will return the current borrower, i.e. the current legit user of the NFT.

## Benefits

### Decoupled NFT core logic and the rental logic

The core logic of an NFT shouldn't change frequenly, if ever. Because it's about the permenent ownership. It need to be very rigid to gain the trust.

However, the rental logic can be and should be innovated to suit people's needs. And there should be allowed to have more than one rental offers for a same NFT, so that people could the best fit for their needs.

### Backward compatibility 

This approach requires no change to the NFT contracts. So it will support every NFT on the market automatically.

### Provides the utility provider enough control

NFT utility providers have the choice to block certain bad player among all rental proxies, for example the one who don't respect the agreed rental royalty split, or abues the rental system.

'''
'''--- frontend/assets/logo.svg ---
<svg width="448" height="93" viewBox="0 0 448 93" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M42.455 10.56C42.7963 11.9253 42.967 13.632 42.967 15.68C42.967 17.6427 42.7963 19.3493 42.455 20.8C42.7963 22.1653 42.967 23.872 42.967 25.92C42.967 27.8827 42.7963 29.5893 42.455 31.04C42.7963 32.4053 42.967 34.112 42.967 36.16C42.967 38.1227 42.7963 39.8293 42.455 41.28C42.7963 42.6453 42.967 44.352 42.967 46.4C42.967 48.3627 42.7963 50.0693 42.455 51.52C42.7963 52.8853 42.967 54.592 42.967 56.64C42.967 58.6027 42.7963 60.3093 42.455 61.76C42.7963 63.1253 42.967 64.832 42.967 66.88C42.967 68.8427 42.7963 70.5493 42.455 72H32.215C31.8737 70.5493 31.703 68.8427 31.703 66.88C31.703 64.832 31.8737 63.1253 32.215 61.76H25.815C25.4737 60.3093 25.303 58.6027 25.303 56.64C25.303 54.592 25.4737 52.8853 25.815 51.52H21.975C21.6337 50.0693 21.463 48.3627 21.463 46.4C21.463 44.352 21.6337 42.6453 21.975 41.28H16.855C16.5137 39.8293 16.343 38.1227 16.343 36.16C16.343 34.112 16.5137 32.4053 16.855 31.04H11.735C12.0763 32.4053 12.247 34.112 12.247 36.16C12.247 38.1227 12.0763 39.8293 11.735 41.28C12.0763 42.6453 12.247 44.352 12.247 46.4C12.247 48.3627 12.0763 50.0693 11.735 51.52C12.0763 52.8853 12.247 54.592 12.247 56.64C12.247 58.6027 12.0763 60.3093 11.735 61.76C12.0763 63.1253 12.247 64.832 12.247 66.88C12.247 68.8427 12.0763 70.5493 11.735 72H1.495C1.15367 70.5493 0.983 68.8427 0.983 66.88C0.983 64.832 1.15367 63.1253 1.495 61.76C1.15367 60.3093 0.983 58.6027 0.983 56.64C0.983 54.592 1.15367 52.8853 1.495 51.52C1.15367 50.0693 0.983 48.3627 0.983 46.4C0.983 44.352 1.15367 42.6453 1.495 41.28C1.15367 39.8293 0.983 38.1227 0.983 36.16C0.983 34.112 1.15367 32.4053 1.495 31.04C1.15367 29.5893 0.983 27.8827 0.983 25.92C0.983 23.872 1.15367 22.1653 1.495 20.8C1.15367 19.3493 0.983 17.6427 0.983 15.68C0.983 13.632 1.15367 11.9253 1.495 10.56C1.15367 9.10933 0.983 7.40266 0.983 5.43999C0.983 3.392 1.15367 1.68533 1.495 0.32H14.295C14.6363 1.68533 14.807 3.392 14.807 5.43999C14.807 7.40266 14.6363 9.10933 14.295 10.56H18.135C18.4763 11.9253 18.647 13.632 18.647 15.68C18.647 17.6427 18.4763 19.3493 18.135 20.8H21.975C22.3163 22.1653 22.487 23.872 22.487 25.92C22.487 27.8827 22.3163 29.5893 21.975 31.04H27.095C27.4363 32.4053 27.607 34.112 27.607 36.16C27.607 38.1227 27.4363 39.8293 27.095 41.28H32.215C31.8737 39.8293 31.703 38.1227 31.703 36.16C31.703 34.112 31.8737 32.4053 32.215 31.04C31.8737 29.5893 31.703 27.8827 31.703 25.92C31.703 23.872 31.8737 22.1653 32.215 20.8C31.8737 19.3493 31.703 17.6427 31.703 15.68C31.703 13.632 31.8737 11.9253 32.215 10.56C31.8737 9.10933 31.703 7.40266 31.703 5.43999C31.703 3.392 31.8737 1.68533 32.215 0.32H42.455C42.7963 1.68533 42.967 3.392 42.967 5.43999C42.967 7.40266 42.7963 9.10933 42.455 10.56ZM68.105 10.56C67.7637 9.10933 67.593 7.40266 67.593 5.43999C67.593 3.392 67.7637 1.68533 68.105 0.32H78.345C78.6863 1.68533 78.857 3.392 78.857 5.43999C78.857 7.40266 78.6863 9.10933 78.345 10.56H68.105ZM88.585 61.76C88.9263 63.1253 89.097 64.832 89.097 66.88C89.097 68.8427 88.9263 70.5493 88.585 72H57.865C57.5237 70.5493 57.353 68.8427 57.353 66.88C57.353 64.832 57.5237 63.1253 57.865 61.76H68.105C67.7637 60.3093 67.593 58.6027 67.593 56.64C67.593 54.592 67.7637 52.8853 68.105 51.52C67.7637 50.0693 67.593 48.3627 67.593 46.4C67.593 44.352 67.7637 42.6453 68.105 41.28C67.7637 39.8293 67.593 38.1227 67.593 36.16C67.593 34.112 67.7637 32.4053 68.105 31.04H60.425C60.0837 29.5893 59.913 27.8827 59.913 25.92C59.913 23.872 60.0837 22.1653 60.425 20.8H78.345C78.6863 22.1653 78.857 23.872 78.857 25.92C78.857 27.8827 78.6863 29.5893 78.345 31.04C78.6863 32.4053 78.857 34.112 78.857 36.16C78.857 38.1227 78.6863 39.8293 78.345 41.28C78.6863 42.6453 78.857 44.352 78.857 46.4C78.857 48.3627 78.6863 50.0693 78.345 51.52C78.6863 52.8853 78.857 54.592 78.857 56.64C78.857 58.6027 78.6863 60.3093 78.345 61.76H88.585ZM139.835 31.04C140.176 32.4053 140.347 34.112 140.347 36.16C140.347 38.1227 140.176 39.8293 139.835 41.28H119.355C119.696 42.6453 119.867 44.352 119.867 46.4C119.867 48.3627 119.696 50.0693 119.355 51.52C119.696 52.8853 119.867 54.592 119.867 56.64C119.867 58.6027 119.696 60.3093 119.355 61.76C119.696 63.1253 119.867 64.832 119.867 66.88C119.867 68.8427 119.696 70.5493 119.355 72H109.115C108.774 70.5493 108.603 68.8427 108.603 66.88C108.603 64.832 108.774 63.1253 109.115 61.76C108.774 60.3093 108.603 58.6027 108.603 56.64C108.603 54.592 108.774 52.8853 109.115 51.52C108.774 50.0693 108.603 48.3627 108.603 46.4C108.603 44.352 108.774 42.6453 109.115 41.28C108.774 39.8293 108.603 38.1227 108.603 36.16C108.603 34.112 108.774 32.4053 109.115 31.04C108.774 29.5893 108.603 27.8827 108.603 25.92C108.603 23.872 108.774 22.1653 109.115 20.8C108.774 19.3493 108.603 17.6427 108.603 15.68C108.603 13.632 108.774 11.9253 109.115 10.56C108.774 9.10933 108.603 7.40266 108.603 5.43999C108.603 3.392 108.774 1.68533 109.115 0.32H139.835C140.176 1.68533 140.347 3.392 140.347 5.43999C140.347 7.40266 140.176 9.10933 139.835 10.56H119.355C119.696 11.9253 119.867 13.632 119.867 15.68C119.867 17.6427 119.696 19.3493 119.355 20.8C119.696 22.1653 119.867 23.872 119.867 25.92C119.867 27.8827 119.696 29.5893 119.355 31.04H139.835ZM196.717 5.43999C196.717 7.40266 196.546 9.10933 196.205 10.56H180.845C181.186 11.9253 181.357 13.632 181.357 15.68C181.357 17.6427 181.186 19.3493 180.845 20.8C181.186 22.1653 181.357 23.872 181.357 25.92C181.357 27.8827 181.186 29.5893 180.845 31.04C181.186 32.4053 181.357 34.112 181.357 36.16C181.357 38.1227 181.186 39.8293 180.845 41.28C181.186 42.6453 181.357 44.352 181.357 46.4C181.357 48.3627 181.186 50.0693 180.845 51.52C181.186 52.8853 181.357 54.592 181.357 56.64C181.357 58.6027 181.186 60.3093 180.845 61.76C181.186 63.1253 181.357 64.832 181.357 66.88C181.357 68.8427 181.186 70.5493 180.845 72H170.605C170.264 70.5493 170.093 68.8427 170.093 66.88C170.093 64.832 170.264 63.1253 170.605 61.76C170.264 60.3093 170.093 58.6027 170.093 56.64C170.093 54.592 170.264 52.8853 170.605 51.52C170.264 50.0693 170.093 48.3627 170.093 46.4C170.093 44.352 170.264 42.6453 170.605 41.28C170.264 39.8293 170.093 38.1227 170.093 36.16C170.093 34.112 170.264 32.4053 170.605 31.04C170.264 29.5893 170.093 27.8827 170.093 25.92C170.093 23.872 170.264 22.1653 170.605 20.8C170.264 19.3493 170.093 17.6427 170.093 15.68C170.093 13.632 170.264 11.9253 170.605 10.56H155.245C154.904 9.10933 154.733 7.40266 154.733 5.43999C154.733 3.392 154.904 1.68533 155.245 0.32H196.205C196.546 1.68533 196.717 3.392 196.717 5.43999ZM247.967 25.92C247.967 27.8827 247.796 29.5893 247.455 31.04H243.615C243.956 32.4053 244.127 34.112 244.127 36.16C244.127 38.1227 243.956 39.8293 243.615 41.28H239.775C240.116 42.6453 240.287 44.352 240.287 46.4C240.287 48.3627 240.116 50.0693 239.775 51.52H237.215C237.556 52.8853 237.727 54.592 237.727 56.64C237.727 58.6027 237.556 60.3093 237.215 61.76H233.375C233.716 63.1253 233.887 64.832 233.887 66.88C233.887 68.8427 233.716 70.5493 233.375 72H230.815C231.156 73.3653 231.327 75.072 231.327 77.12C231.327 79.0827 231.156 80.7893 230.815 82.24H225.695C226.036 83.6053 226.207 85.312 226.207 87.36C226.207 89.3227 226.036 91.0293 225.695 92.48H210.335C209.994 91.0293 209.823 89.3227 209.823 87.36C209.823 85.312 209.994 83.6053 210.335 82.24H220.575C220.234 80.7893 220.063 79.0827 220.063 77.12C220.063 75.072 220.234 73.3653 220.575 72C220.234 70.5493 220.063 68.8427 220.063 66.88C220.063 64.832 220.234 63.1253 220.575 61.76H215.455C215.114 60.3093 214.943 58.6027 214.943 56.64C214.943 54.592 215.114 52.8853 215.455 51.52H212.895C212.554 50.0693 212.383 48.3627 212.383 46.4C212.383 44.352 212.554 42.6453 212.895 41.28H209.055C208.714 39.8293 208.543 38.1227 208.543 36.16C208.543 34.112 208.714 32.4053 209.055 31.04H205.215C204.874 29.5893 204.703 27.8827 204.703 25.92C204.703 23.872 204.874 22.1653 205.215 20.8H215.455C215.796 22.1653 215.967 23.872 215.967 25.92C215.967 27.8827 215.796 29.5893 215.455 31.04H219.295C219.636 32.4053 219.807 34.112 219.807 36.16C219.807 38.1227 219.636 39.8293 219.295 41.28H223.135C223.476 42.6453 223.647 44.352 223.647 46.4C223.647 48.3627 223.476 50.0693 223.135 51.52C223.476 52.8853 223.647 54.592 223.647 56.64C223.647 58.6027 223.476 60.3093 223.135 61.76H226.975C226.634 60.3093 226.463 58.6027 226.463 56.64C226.463 54.592 226.634 52.8853 226.975 51.52H229.535C229.194 50.0693 229.023 48.3627 229.023 46.4C229.023 44.352 229.194 42.6453 229.535 41.28H233.375C233.034 39.8293 232.863 38.1227 232.863 36.16C232.863 34.112 233.034 32.4053 233.375 31.04H237.215C236.874 29.5893 236.703 27.8827 236.703 25.92C236.703 23.872 236.874 22.1653 237.215 20.8H247.455C247.796 22.1653 247.967 23.872 247.967 25.92ZM298.705 61.76C299.046 63.1253 299.217 64.832 299.217 66.88C299.217 68.8427 299.046 70.5493 298.705 72H288.465C288.124 70.5493 287.953 68.8427 287.953 66.88C287.953 64.832 288.124 63.1253 288.465 61.76H284.625C284.284 60.3093 284.113 58.6027 284.113 56.64C284.113 54.592 284.284 52.8853 284.625 51.52H280.785C280.444 50.0693 280.273 48.3627 280.273 46.4C280.273 44.352 280.444 42.6453 280.785 41.28H267.985C268.326 42.6453 268.497 44.352 268.497 46.4C268.497 48.3627 268.326 50.0693 267.985 51.52C268.326 52.8853 268.497 54.592 268.497 56.64C268.497 58.6027 268.326 60.3093 267.985 61.76C268.326 63.1253 268.497 64.832 268.497 66.88C268.497 68.8427 268.326 70.5493 267.985 72H257.745C257.404 70.5493 257.233 68.8427 257.233 66.88C257.233 64.832 257.404 63.1253 257.745 61.76C257.404 60.3093 257.233 58.6027 257.233 56.64C257.233 54.592 257.404 52.8853 257.745 51.52C257.404 50.0693 257.233 48.3627 257.233 46.4C257.233 44.352 257.404 42.6453 257.745 41.28C257.404 39.8293 257.233 38.1227 257.233 36.16C257.233 34.112 257.404 32.4053 257.745 31.04C257.404 29.5893 257.233 27.8827 257.233 25.92C257.233 23.872 257.404 22.1653 257.745 20.8C257.404 19.3493 257.233 17.6427 257.233 15.68C257.233 13.632 257.404 11.9253 257.745 10.56C257.404 9.10933 257.233 7.40266 257.233 5.43999C257.233 3.392 257.404 1.68533 257.745 0.32H293.585C293.926 1.68533 294.097 3.392 294.097 5.43999C294.097 7.40266 293.926 9.10933 293.585 10.56H298.705C299.046 11.9253 299.217 13.632 299.217 15.68C299.217 17.6427 299.046 19.3493 298.705 20.8H296.145C296.486 22.1653 296.657 23.872 296.657 25.92C296.657 27.8827 296.486 29.5893 296.145 31.04H288.465C288.806 32.4053 288.977 34.112 288.977 36.16C288.977 38.1227 288.806 39.8293 288.465 41.28H291.025C291.366 42.6453 291.537 44.352 291.537 46.4C291.537 48.3627 291.366 50.0693 291.025 51.52H294.865C295.206 52.8853 295.377 54.592 295.377 56.64C295.377 58.6027 295.206 60.3093 294.865 61.76H298.705ZM285.905 31.04C285.564 29.5893 285.393 27.8827 285.393 25.92C285.393 23.872 285.564 22.1653 285.905 20.8C285.564 19.3493 285.393 17.6427 285.393 15.68C285.393 13.632 285.564 11.9253 285.905 10.56H267.985C268.326 11.9253 268.497 13.632 268.497 15.68C268.497 17.6427 268.326 19.3493 267.985 20.8C268.326 22.1653 268.497 23.872 268.497 25.92C268.497 27.8827 268.326 29.5893 267.985 31.04H285.905ZM350.467 36.16C350.467 38.1227 350.296 39.8293 349.955 41.28C350.296 42.6453 350.467 44.352 350.467 46.4C350.467 48.3627 350.296 50.0693 349.955 51.52H323.075C323.416 52.8853 323.587 54.592 323.587 56.64C323.587 58.6027 323.416 60.3093 323.075 61.76H344.835C345.176 63.1253 345.347 64.832 345.347 66.88C345.347 68.8427 345.176 70.5493 344.835 72H319.235C318.894 70.5493 318.723 68.8427 318.723 66.88C318.723 64.832 318.894 63.1253 319.235 61.76H312.835C312.494 60.3093 312.323 58.6027 312.323 56.64C312.323 54.592 312.494 52.8853 312.835 51.52H308.995C308.654 50.0693 308.483 48.3627 308.483 46.4C308.483 44.352 308.654 42.6453 308.995 41.28H312.835C312.494 39.8293 312.323 38.1227 312.323 36.16C312.323 34.112 312.494 32.4053 312.835 31.04H319.235C318.894 29.5893 318.723 27.8827 318.723 25.92C318.723 23.872 318.894 22.1653 319.235 20.8H344.835C345.176 22.1653 345.347 23.872 345.347 25.92C345.347 27.8827 345.176 29.5893 344.835 31.04H349.955C350.296 32.4053 350.467 34.112 350.467 36.16ZM339.715 41.28C339.374 39.8293 339.203 38.1227 339.203 36.16C339.203 34.112 339.374 32.4053 339.715 31.04H323.075C323.416 32.4053 323.587 34.112 323.587 36.16C323.587 38.1227 323.416 39.8293 323.075 41.28H339.715ZM369.717 25.92C369.717 27.8827 369.546 29.5893 369.205 31.04H374.325C374.666 32.4053 374.837 34.112 374.837 36.16C374.837 38.1227 374.666 39.8293 374.325 41.28H370.485C370.826 42.6453 370.997 44.352 370.997 46.4C370.997 48.3627 370.826 50.0693 370.485 51.52C370.826 52.8853 370.997 54.592 370.997 56.64C370.997 58.6027 370.826 60.3093 370.485 61.76C370.826 63.1253 370.997 64.832 370.997 66.88C370.997 68.8427 370.826 70.5493 370.485 72H360.245C359.904 70.5493 359.733 68.8427 359.733 66.88C359.733 64.832 359.904 63.1253 360.245 61.76C359.904 60.3093 359.733 58.6027 359.733 56.64C359.733 54.592 359.904 52.8853 360.245 51.52C359.904 50.0693 359.733 48.3627 359.733 46.4C359.733 44.352 359.904 42.6453 360.245 41.28C359.904 39.8293 359.733 38.1227 359.733 36.16C359.733 34.112 359.904 32.4053 360.245 31.04C359.904 29.5893 359.733 27.8827 359.733 25.92C359.733 23.872 359.904 22.1653 360.245 20.8H369.205C369.546 22.1653 369.717 23.872 369.717 25.92ZM401.205 41.28C401.546 42.6453 401.717 44.352 401.717 46.4C401.717 48.3627 401.546 50.0693 401.205 51.52C401.546 52.8853 401.717 54.592 401.717 56.64C401.717 58.6027 401.546 60.3093 401.205 61.76C401.546 63.1253 401.717 64.832 401.717 66.88C401.717 68.8427 401.546 70.5493 401.205 72H390.965C390.624 70.5493 390.453 68.8427 390.453 66.88C390.453 64.832 390.624 63.1253 390.965 61.76C390.624 60.3093 390.453 58.6027 390.453 56.64C390.453 54.592 390.624 52.8853 390.965 51.52C390.624 50.0693 390.453 48.3627 390.453 46.4C390.453 44.352 390.624 42.6453 390.965 41.28C390.624 39.8293 390.453 38.1227 390.453 36.16C390.453 34.112 390.624 32.4053 390.965 31.04H374.325C373.984 29.5893 373.813 27.8827 373.813 25.92C373.813 23.872 373.984 22.1653 374.325 20.8H394.805C395.146 22.1653 395.317 23.872 395.317 25.92C395.317 27.8827 395.146 29.5893 394.805 31.04H401.205C401.546 32.4053 401.717 34.112 401.717 36.16C401.717 38.1227 401.546 39.8293 401.205 41.28ZM447.335 61.76C447.676 63.1253 447.847 64.832 447.847 66.88C447.847 68.8427 447.676 70.5493 447.335 72H426.855C426.514 70.5493 426.343 68.8427 426.343 66.88C426.343 64.832 426.514 63.1253 426.855 61.76H421.735C421.394 60.3093 421.223 58.6027 421.223 56.64C421.223 54.592 421.394 52.8853 421.735 51.52C421.394 50.0693 421.223 48.3627 421.223 46.4C421.223 44.352 421.394 42.6453 421.735 41.28C421.394 39.8293 421.223 38.1227 421.223 36.16C421.223 34.112 421.394 32.4053 421.735 31.04H411.495C411.154 29.5893 410.983 27.8827 410.983 25.92C410.983 23.872 411.154 22.1653 411.495 20.8H421.735C421.394 19.3493 421.223 17.6427 421.223 15.68C421.223 13.632 421.394 11.9253 421.735 10.56C421.394 9.10933 421.223 7.40266 421.223 5.43999C421.223 3.392 421.394 1.68533 421.735 0.32H431.975C432.316 1.68533 432.487 3.392 432.487 5.43999C432.487 7.40266 432.316 9.10933 431.975 10.56C432.316 11.9253 432.487 13.632 432.487 15.68C432.487 17.6427 432.316 19.3493 431.975 20.8H447.335C447.676 22.1653 447.847 23.872 447.847 25.92C447.847 27.8827 447.676 29.5893 447.335 31.04H431.975C432.316 32.4053 432.487 34.112 432.487 36.16C432.487 38.1227 432.316 39.8293 431.975 41.28C432.316 42.6453 432.487 44.352 432.487 46.4C432.487 48.3627 432.316 50.0693 431.975 51.52C432.316 52.8853 432.487 54.592 432.487 56.64C432.487 58.6027 432.316 60.3093 431.975 61.76H447.335Z" fill="white"/>
</svg>

'''
'''--- frontend/index.html ---
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content=
  "width=device-width, initial-scale=1">
  <link rel="stylesheet" href="/src/main.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com"
  crossorigin="">
  <link href=
  "https://fonts.googleapis.com/css2?family=Share+Tech+Mono&amp;display=swap"
  rel="stylesheet">
  <title>NiFTyRent</title>
</head>
<body class="h-full bg-zinc-200 text-zinc-800">
  <noscript>You need to enable JavaScript to run this
  app.</noscript>
  <div id="root"></div>
  <script src="./src/Index.jsx" type="module"></script>
</body>
</html>

'''
'''--- frontend/package.json ---
{
  "name": "nft-rental",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "start": "env-cmd -f ../marketplace/neardev/dev-account.env vite",
    "build": "CONTRACT_NAME=niftyrent.testnet vite build -m testnet && yarn netlify_redirects",
    "build_testnet": "CONTRACT_NAME=niftyrent.testnet vite build -m testnet && yarn netlify_redirects",
    "build_mainnet": "CONTRACT_NAME=nft-rental.near vite build -m mainnet && yarn netlify_redirects",
    "netlify_redirects": "echo \"/* /index.html 200\" > dist/_redirects"
  },
  "devDependencies": {
    "@babel/core": "^7.18.2",
    "@babel/preset-env": "^7.18.2",
    "@babel/preset-react": "^7.17.12",
    "@types/node": "^18.6.2",
    "@vitejs/plugin-react": "^2.0.1",
    "autoprefixer": "^10.4.8",
    "ava": "^4.2.0",
    "env-cmd": "^10.1.0",
    "nodemon": "^2.0.16",
    "postcss": "^8.4.16",
    "process": "^0.11.10",
    "react-test-renderer": "^18.1.0",
    "tailwindcss": "^3.1.8",
    "ts-node": "^10.8.0",
    "typescript": "^4.7.2",
    "vite": "^3.0.9"
  },
  "dependencies": {
    "@apollo/client": "^3.6.9",
    "@tailwindcss/forms": "^0.5.3",
    "graphql": "^16.6.0",
    "near-api-js": "^0.44.2",
    "react": "^18.1.0",
    "react-dom": "^18.1.0",
    "react-router-dom": "6",
    "regenerator-runtime": "^0.13.9"
  },
  "resolutions": {
    "@babel/preset-env": "7.13.8"
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  }
}

'''
'''--- frontend/src/FtContract.js ---

const { Contract } = window.nearApi;

export async function initFtContract(contractName) {
  return await new Contract(window.walletConnection.account(), contractName, {
    viewMethods: ["ft_metadata", "ft_balance_of"],
    changeMethods: ["ft_transfer_call"],
  });
}

export function toNormalisedAmount(contractId, amount) {
  const metadata = window.CURRENCY_OPTIONS.find((m) => m.address === contractId);
  if (metadata == null) { return `ERROR unrecognised FT ${contractId}`}
  const decimals = metadata.decimals;

  const scale = BigInt(10) ** BigInt(decimals - 3);
  const normalised = BigInt(Math.round(amount * 1000)) * scale;
  return normalised.toString();
}

export function fromNormalisedAmount(contractId, amount) {
  const metadata = window.CURRENCY_OPTIONS.find((m) => m.address === contractId);
  if (metadata == null) { return `ERROR unrecognised FT ${contractId}`}
  const decimals = metadata.decimals;

  const scale = BigInt(10) ** BigInt(decimals - 3);
  const normalised = BigInt(amount) / scale;
  return Number(normalised) / 1000;
}

export function ftSymbol(contractId) {
  const metadata = window.CURRENCY_OPTIONS.find((m) => m.address === contractId);
  return metadata.symbol;
}

'''
'''--- frontend/src/NftContract.js ---
const { Contract } = window.nearApi;
import { nearConfig } from "./near-api";
import { initFtContract, toNormalisedAmount } from "./FtContract"

export async function initContract(contractName) {
  return await new Contract(window.walletConnection.account(), contractName, {
    viewMethods: ["nft_tokens_for_owner", "nft_token", "nft_payout"],
    changeMethods: ["nft_approve"],
  });
}

export async function nftTokensForOwner(contract, accountId) {
  if (accountId == "") return [];
  let tokens = await contract.nft_tokens_for_owner({
    account_id: window.accountId,
  });
  return tokens;
}

export async function getToken(contract, tokenId) {
  if (tokenId == "") return null;
  let token = await contract.nft_token({
    token_id: tokenId,
  });
  return token;
}

export async function getPayout(contract, tokenId, balance) {
  try {
    let payouts = await contract.nft_payout({
      token_id: tokenId,
      balance: balance,
      max_len_payout: 50
    });
    return (await payouts).payout;
  } catch (e) {
    // TODO(libo): improve the error handling, only match the error due to unimplemented nft_payout method.
    return []
  }
}

export async function newListing(
  contract,
  tokenId,
  startTsNano,
  endTsNano,
  ftAddress,
  price,
) {
  if (tokenId == "") return;
  const priceNormalised = toNormalisedAmount(ftAddress, price);
  // TODO(libo): Revist the message
  const message = JSON.stringify({
    ft_contract_id: ftAddress,
    price: priceNormalised,
    lease_start_ts_nano: startTsNano.toString(),
    lease_end_ts_nano: endTsNano.toString(),
  });
  return await contract.nft_approve({
    args: {
      token_id: tokenId,
      account_id: nearConfig.contractName,
      msg: message,
    },
    gas: "300000000000000",
    amount: "900000000000000000000",
  });
}

'''
'''--- frontend/src/Utils.js ---
export function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}

export const MS_TO_NS_SCALE = 1000000;

// return human readable duration string
export function durationString(durationNs) {
  const durationMs = durationNs / MS_TO_NS_SCALE;
  const durationS = durationMs / 1000;
  const durationM = durationS / 60;
  const durationH = durationM / 60;
  const durationD = durationH / 24;
  const durationY = durationD / 365;

  if (durationY >= 2) {
    return `${Math.round(durationY)} years`;
  } else if (durationY >= 1) {
    return `1 year`;
  } else if (durationD >= 2) {
    return `${Math.round(durationD)} days`;
  } else if (durationD >= 1) {
    return `1 day`;
  } else if (durationH >= 2) {
    return `${Math.round(durationH)} hours`;
  } else if (durationH >= 1) {
    return `1 hour`;
  } else if (durationM >= 2) {
    return `${Math.round(durationM)} minutes`;
  } else if (durationM >= 1) {
    return `1 minute`;
  } else if (durationS >= 2) {
    return `${Math.round(durationS)} seconds`;
  } else if (durationS >= 1) {
    return `1 second`;
  }
}

// return human readable date time string
export function dateTimeString(tsNs) {
  const tsMs = tsNs / MS_TO_NS_SCALE;
  const date = new Date(tsMs);
  return date.toLocaleString();
}

// TODO(libo): revisit it before launch.
const SHOP_NAME_BY_CONTRACT_ID = {
  "dev-1661810963414-16661057092973": "Lucky Mooncake",
  "niftyrpg.mintspace2.testnet": "Nifty RPG",
}
export  function contractIdToName(nftContractId) {
  return SHOP_NAME_BY_CONTRACT_ID[nftContractId] || nftContractId
}

const SHOP_DESCRIPTION_BY_CONTRACT_ID = {
  "dev-1661810963414-16661057092973": "A collection of mooncakes bringing luck to you.",
  "niftyrpg.mintspace2.testnet": "A demo RPG game utilizing NFTs. You can buy and rent NFTs, and equip them in the game. https://nifty-rpg.netlify.app/",
}
export  function contractIdToDescription(nftContractId) {
  return SHOP_DESCRIPTION_BY_CONTRACT_ID[nftContractId] || "";
}

export function mintbaseStoreUrl(nftContractId) {
  // If the contract id ends with ".near" then return the mainnet url
  if (nftContractId.endsWith(".near")) {
    return `https://mintbase.xyz/contract/${nftContractId}`
  } else {
    return `https://testnet.mintbase.xyz/contract/${nftContractId}`
  }
}
'''
'''--- frontend/src/main.css ---
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer components {
    .elevated {
        transform: translate(-0.25rem,-0.25rem);
        box-shadow: 0.25rem 0.25rem #000;
    }

    .btn {
        @apply rounded-md border border-zinc-800 px-6 py-3 text-base font-medium text-zinc-800 hover:elevated focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2
    }
    .primary-btn {
        @apply btn bg-indigo-600 text-zinc-100
    }

    .btn-dark {
        @apply rounded-md border border-zinc-100 px-6 py-3 text-base font-medium text-zinc-100 hover:bg-zinc-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2
    }
    .primary-btn-dark {
        @apply btn bg-zinc-100 text-zinc-900 hover:bg-zinc-50
    }

    .input {
        @apply block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm

    }
    .input-error {
        @apply border-red-500 focus:border-red-500 focus:ring-red-500
    }
}

'''
'''--- frontend/src/near-api.js ---
import "near-api-js/dist/near-api-js.min.js";
const { connect, Contract, keyStores, WalletConnection } = window.nearApi;
import { getConfig } from "./near-config";
import { initFtContract } from "./FtContract";

export const nearConfig = getConfig(import.meta.env.MODE || "development");

export function signOutNearWallet() {
  window.walletConnection.signOut();
  // reload page
  window.location.replace(window.location.origin + window.location.pathname);
}

export function signInWithNearWallet() {
  // Allow the current app to make calls to the specified contract on the
  // user's behalf.
  // This works by creating a new access key for the user's account and storing
  // the private key in localStorage.
  window.walletConnection.requestSignIn(nearConfig.contractName);
}

// Initialize contract & set global variables
export async function initContract() {
  // Initialize connection to the NEAR testnet
  const near = await connect(
    Object.assign(
      { deps: { keyStore: new keyStores.BrowserLocalStorageKeyStore() } },
      nearConfig
    )
  );

  // Initializing Wallet based Account. It can work with NEAR testnet wallet that
  // is hosted at https://wallet.testnet.near.org
  window.walletConnection = new WalletConnection(near);

  // Getting the Account ID. If still unauthorized, it's just empty string
  window.accountId = window.walletConnection.getAccountId();

  // Initializing our contract APIs by contract name and configuration
  window.contract = await new Contract(
    window.walletConnection.account(),
    nearConfig.contractName,
    {
      viewMethods: [
        "list_listings_by_nft_contract_id",
        "list_allowed_nft_contract_ids",
        "list_allowed_ft_contract_ids",
        "get_listing_by_id",
        "get_rental_contract_id"
      ],
      changeMethods: [],
    }
  );

  // Initializing the rental contract.
  window.rentalContractId = await getRentalContractId();
  window.rentalContract = await new Contract(
    window.walletConnection.account(),
    window.rentalContractId,
    {
      viewMethods: ["leases_by_borrower", "leases_by_owner", "lease_by_contract_and_token"],
      changeMethods: ["claim_back"],
    });
}

export async function getRentalContractId() {
  return await window.contract.get_rental_contract_id();
}

export async function getAllowedFTs() {
  const ftAddrs = await window.contract.list_allowed_ft_contract_ids({});
  const fts = await Promise.all(ftAddrs.map(async addr => {
    const contract = await initFtContract(addr);
    const ftMetadata = await contract.ft_metadata({});
    return { address: addr, ...ftMetadata };
  }));
  return fts;
}

export async function acceptLease(leaseId, rent) {
  let response = await window.contract.lending_accept({
    args: {
      lease_id: leaseId,
    },
    gas: "300000000000000",
    amount: (BigInt(rent) + BigInt(1e18)).toString(),
  });
  return response;
}

export async function listingsByNftContractId(nftContractId) {
  const listings = await window.contract.list_listings_by_nft_contract_id({
    nft_contract_id: nftContractId,
  });
  return listings;
}

export async function listAllowedNftContractIds(nftContractId) {
  return await window.contract.list_allowed_nft_contract_ids({})
}

export async function listingByContractIdAndTokenId(nftContractId, tokenId) {
  const listing = await window.contract.get_listing_by_id({
    listing_id: [nftContractId, tokenId],
  });
  return listing;
}

export async function myLendings() {
  return await window.rentalContract.leases_by_owner({
    account_id: window.accountId,
  });
}

export async function myBorrowings() {
  return await window.rentalContract.leases_by_borrower({
    account_id: window.accountId,
  });
}

export async function leaseByContractIdAndTokenId(nftContractId, tokenId) {
  return await window.rentalContract.lease_by_contract_and_token({
    contract_id: nftContractId,
    token_id: tokenId,
  });
}

export async function claimBack(leaseId) {
  let response = await window.rentalContract.claim_back({
    args: {
      lease_id: leaseId,
    },
    gas: "300000000000000",
    amount: 1,
  });
  return response;
}
'''
'''--- frontend/src/near-config.js ---
const CONTRACT_NAME = import.meta.env.CONTRACT_NAME;

export function getConfig(env) {
  switch (env) {
    case "production":
    case "mainnet":
      return {
        networkId: "mainnet",
        nodeUrl: "https://rpc.mainnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.near.org",
        helperUrl: "https://helper.mainnet.near.org",
        explorerUrl: "https://explorer.mainnet.near.org",
      };
    case "development":
    case "testnet":
      return {
        networkId: "testnet",
        nodeUrl: "https://rpc.testnet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.testnet.near.org",
        helperUrl: "https://helper.testnet.near.org",
        explorerUrl: "https://explorer.testnet.near.org",
      };
    case "betanet":
      return {
        networkId: "betanet",
        nodeUrl: "https://rpc.betanet.near.org",
        contractName: CONTRACT_NAME,
        walletUrl: "https://wallet.betanet.near.org",
        helperUrl: "https://helper.betanet.near.org",
        explorerUrl: "https://explorer.betanet.near.org",
      };
    case "local":
      return {
        networkId: "local",
        nodeUrl: "http://localhost:3030",
        keyPath: `${process.env.HOME}/.near/validator_key.json`,
        walletUrl: "http://localhost:4000/wallet",
        contractName: CONTRACT_NAME,
      };
    case "test":
    case "ci":
      return {
        networkId: "shared-test",
        nodeUrl: "https://rpc.ci-testnet.near.org",
        contractName: CONTRACT_NAME,
        masterAccount: "test.near",
      };
    case "ci-betanet":
      return {
        networkId: "shared-test-staging",
        nodeUrl: "https://rpc.ci-betanet.near.org",
        contractName: CONTRACT_NAME,
        masterAccount: "test.near",
      };
    default:
      throw Error(
        `Unconfigured environment '${env}'. Can be configured in src/config.js.`
      );
  }
}

'''
'''--- frontend/tailwind.config.js ---
/** @type {import('tailwindcss').Config} */
module.exports = {
  content: ["./src/**/*.{html,js,jsx,ts,tsx}", "./index.html"],
  theme: {
    fontFamily: {
      "sans": ['"Share Tech Mono"', 'monospace'],
      "body": ['"Share Tech Mono"', 'monospace'],
    },
    extend: {
      colors: {
        // accent: "#D26666",
      }
    },
  },
  plugins: [require("@tailwindcss/forms")],
};

'''
'''--- frontend/vite.config.js ---
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
  loader: { ".js": "jsx" },
  // To read contract name
  envPrefix: "CONTRACT_",
});

'''
'''--- integration-tests/Cargo.toml ---
[workspace]
members = ["stubs/*"]
default-members = ["stubs/*", "."]

[package]
name = "integration-tests"
version = "1.0.0"
publish = false
edition = "2018"

[dev-dependencies]
anyhow = "1.0"
borsh = "0.9"
maplit = "1.0"
near-units = "0.2.0"
nft_rental = { path = "../contract"}
niftyrent_marketplace = { path = "../marketplace"}
# arbitrary_precision enabled for u128 types that workspaces requires for Balance types
serde_json = { version = "1.0", features = ["arbitrary_precision"] }
tokio = { version = "1.18.1", features = ["full"] }
tracing = "0.1"
tracing-subscriber = { version = "0.3.11", features = ["env-filter"] }
workspaces = "0.7.0"
pkg-config = "0.3.1"
near-contract-standards = "4.1.1"
near-sdk = "4.0.0"

'''
'''--- integration-tests/README.md ---

# Introduction
Both unit tests and integrations tests are included for the project.
## Prerequisite
Follow ../README.md to set up the environment

# Unit Test
Unit Tests are located in the contract file ./contract/src/lib.rs, inside the tests module.

## How to run unit tests
- move to project root directory. e.g. ./nft-rental
- `yarn test:unit`

# Integration Test
Integration test are based in a different directory ./integration-tests
## How to run test
- move to the ./nft-rental/integration-tests
- Run `yarn test:integration`

## Test plan

- `test_claim_back_with_payout_success`: the lender, Alice, lends the testing NFT token to the borrower, Bob. This test will verify the ownership of the token is transferred back to Alice after being claimed back. The test will also verify the payout splits are made correctly as defined in the token.
- `test_claim_back_without_payout_success`: similar to `test_claim_back_with_payout_success` but with an NFT which doesn't support payout. In this case all the rent should go to Alice.
- `test_accept_leases_already_lent`: This test verifies that the call will pass for the first time when lender accepts the lease but should faile if borrowers accepts the same lease for multiple times.
- `test_accept_lease_fails_already_transferred`: This test verifies that the call should fail if the token has been transferred before the borrowers accepts the lease.

The following integration tests have been added for Lease Ownership NFT
- `test_lender_receives_a_lease_nft_after_lease_activation`: lender can receive a lease nft token with correct token information after the leaes got activated.
- `test_lease_nft_can_be_transferred_to_other_account`: owner of the lease nft token can transfer the token to other account. The underlying lease's lender info will also be udpated correctly.
- `test_claim_back_without_payout_using_lease_nft`: owner of the lease nft token can claim back the renting nft successfully & rent should be paid in full to original lender.
- `test_claim_back_with_payout_using_lease_nft`: owner of the lease nft token can claim back the renting nft successfully & rent should be paid correctly to all payout accounds.

Inline comment and test output have also been added. Please refer the code.

'''
'''--- integration-tests/stubs/ft/Cargo.toml ---
[package]
name = "test_ft"
version = "1.0.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- integration-tests/stubs/ft/src/lib.rs ---
/*
This contract was copied from https://github.com/near-examples/FT/blob/master/ft/src/lib.rs
*/
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(owner_id: AccountId, total_supply: U128) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let metadata = FungibleTokenMetadata {
            spec: FT_METADATA_SPEC.to_string(),
            name: "Example NEAR fungible token".to_string(),
            symbol: "EXAMPLE".to_string(),
            icon: None,
            reference: None,
            reference_hash: None,
            decimals: 24,
        };
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(&owner_id);
        this.token.internal_deposit(&owner_id, total_supply.into());
        near_contract_standards::fungible_token::events::FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial tokens supply is minted"),
        }
        .emit();
        this
    }

    pub fn unsafe_register_and_deposit(&mut self, account_id: AccountId, balance: Balance) {
        self.token.internal_register_account(&account_id.clone());
        self.token.internal_deposit(&account_id.clone(), balance);
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- integration-tests/stubs/nft_with_payout/Cargo.toml ---
[package]
name = "test_nft_with_payout"
version = "1.0.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- integration-tests/stubs/nft_with_payout/src/lib.rs ---
use std::collections::HashMap;

use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::U128;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

pub type PayoutHashMap = HashMap<AccountId, U128>;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: PayoutHashMap,
}

/// A minilism NFT contract with payout (NEP-199) support for testing purpose.
#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, None),
        }
    }

    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens
            .mint(token_id, receiver_id, Some(token_metadata))
    }

    pub fn nft_payout(
        &self,
        token_id: TokenId,
        balance: U128,
        _max_len_payout: Option<u32>,
    ) -> Payout {
        let treasury_split = balance.0 / 20;
        let owner_split = balance.0 - treasury_split;
        let owner = self.tokens.owner_by_id.get(&token_id).unwrap();
        Payout {
            payout: HashMap::from([
                (env::current_account_id(), U128::from(treasury_split)),
                (owner, U128::from(owner_split)),
            ]),
        }
    }

    #[payable]
    pub fn nft_transfer_payout(
        &mut self,
        receiver_id: AccountId,
        token_id: String,
        approval_id: u64,
        balance: near_sdk::json_types::U128,
        max_len_payout: u32,
    ) -> Payout {
        let payout = self.nft_payout(token_id.clone(), balance, Some(max_len_payout));
        self.nft_transfer(receiver_id, token_id.clone(), Some(approval_id), None);
        payout
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- integration-tests/stubs/nft_without_payout/Cargo.toml ---
[package]
name = "test_nft_without_payout"
version = "1.0.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- integration-tests/stubs/nft_without_payout/src/lib.rs ---
use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::{
    env, near_bindgen, AccountId, BorshStorageKey, PanicOnDefault, Promise, PromiseOrValue,
};

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

#[derive(BorshSerialize, BorshStorageKey)]
enum StorageKey {
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

/// A minilism NFT contract without payout (NEP-199) support for testing purpose.
#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Self {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, None),
        }
    }

    #[payable]
    pub fn nft_mint(
        &mut self,
        token_id: TokenId,
        receiver_id: AccountId,
        token_metadata: TokenMetadata,
    ) -> Token {
        self.tokens
            .mint(token_id, receiver_id, Some(token_metadata))
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_approval!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- integration-tests/tests/gas_usage.rs ---
use near_units::parse_near;
use nft_rental::{LeaseCondition, LeaseState};
use serde_json::json;
use workspaces::{network::Sandbox, Account, Contract, Worker};

struct Context {
    lender: Account,
    borrower: Account,
    contract: Contract,
    nft_contract: Contract,
    worker: Worker<Sandbox>,
}

const CONTRACT_CODE: &[u8] =
    include_bytes!("../../contract/target/wasm32-unknown-unknown/release/nft_rental.wasm");
const NFT_CODE: &[u8] =
    include_bytes!("../target/wasm32-unknown-unknown/release/test_nft_with_payout.wasm");

async fn init() -> anyhow::Result<Context> {
    let worker = workspaces::sandbox().await?;
    let contract = worker.dev_deploy(CONTRACT_CODE).await?;
    let nft_contract = worker.dev_deploy(NFT_CODE).await?;

    // create accounts
    let account = worker.dev_create_account().await?;
    let alice = account
        .create_subaccount("alice")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;
    let bob = account
        .create_subaccount("bob")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    account
        .call(contract.id(), "new")
        .args_json(json!({ "owner_id": account.id() }))
        .transact()
        .await?
        .into_result()?;
    account
        .call(nft_contract.id(), "new")
        .args_json(json!({ "owner_id": alice.id() }))
        .transact()
        .await?
        .into_result()?;

    Ok(Context {
        lender: alice,
        borrower: bob,
        contract,
        nft_contract,
        worker,
    })
}

async fn prepare_lease(context: &Context, token_id: String) -> anyhow::Result<()> {
    let lender = &context.lender;
    let borrower = &context.borrower;
    let contract = &context.contract;
    let nft_contract = &context.nft_contract;

    let expiration_ts_nano = 1000;
    lender
        .call( nft_contract.id(), "nft_mint")
        .args_json(
            json!({ "token_id": token_id, "receiver_id": lender.id(), "token_metadata": {"title": "Test"}}),
        )
        .deposit(parse_near!("0.1 N"))
        .transact()
        .await?.into_result()?;
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": token_id,
            "account_id": contract.id(),
            "msg": json!({"contract_addr": nft_contract.id(),
                          "token_id": token_id,
                          "borrower": borrower.id(),
                          "expiration": expiration_ts_nano,
                          "amount_near": "1"
            }).to_string()
        }))
        .deposit(parse_near!("1 N"))
        .transact()
        .await?
        .into_result()?;

    let leases: Vec<(String, LeaseCondition)> = contract
        .call("leases_by_owner")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;

    let lease_id = &leases[0].0;
    borrower
        .call(contract.id(), "lending_accept")
        .args_json(json!({
            "lease_id": lease_id,
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    Ok(())
}

#[tokio::test]
async fn get_borrower() -> anyhow::Result<()> {
    let context = init().await?;
    let borrower = context.borrower.clone();
    let contract = context.contract.clone();
    let nft_contract = context.nft_contract.clone();

    println!("Prepare 20 leases ...");
    tokio::join!(
        prepare_lease(&context, "0".to_string()),
        prepare_lease(&context, "1".to_string()),
        prepare_lease(&context, "2".to_string()),
        prepare_lease(&context, "3".to_string()),
        prepare_lease(&context, "4".to_string()),
        prepare_lease(&context, "5".to_string()),
        prepare_lease(&context, "6".to_string()),
        prepare_lease(&context, "7".to_string()),
        prepare_lease(&context, "8".to_string()),
        prepare_lease(&context, "9".to_string()),
        prepare_lease(&context, "10".to_string()),
        prepare_lease(&context, "11".to_string()),
        prepare_lease(&context, "12".to_string()),
        prepare_lease(&context, "13".to_string()),
        prepare_lease(&context, "14".to_string()),
        prepare_lease(&context, "15".to_string()),
        prepare_lease(&context, "16".to_string()),
        prepare_lease(&context, "17".to_string()),
        prepare_lease(&context, "18".to_string()),
        prepare_lease(&context, "19".to_string()),
    );

    println!("Querying the borrower");
    let res = borrower
        .call(contract.id(), "get_borrower")
        .args_json(json!({
            "contract_id": nft_contract.id(),
            "token_id": "10",
        }))
        .transact()
        .await?;

    println!(
        "    ⛽Total burnt gas: {} TGas",
        res.total_gas_burnt as f64 / 1e12
    );

    Ok(())
}

'''
'''--- integration-tests/tests/integration.rs ---
use crate::utils::assert_aprox_eq;
use anyhow::Ok;
use near_contract_standards::non_fungible_token::{
    metadata::NFTContractMetadata, metadata::NFT_METADATA_SPEC, Token,
};
use near_sdk::json_types::U128;
use near_sdk::{log, AccountId};
use near_units::parse_near;
use nft_rental::{LeaseCondition, LeaseState};
use niftyrent_marketplace::Listing;
use serde_json::json;
use workspaces::{network::Sandbox, Account, Contract, Worker};

mod utils;

const ONE_BLOCK_IN_NANO: u64 = 2000000000;

struct Context {
    worker: Worker<Sandbox>,
    rental_contract: Contract,
    rental_contract_owner: Account,
    marketplace_contract: Contract,
    markeplace_owner: Account,
    nft_contract: Contract,
    ft_contract: Contract,
    lender: Account,
    borrower: Account,
    lease_nft_receiver: Account,
}

const CONTRACT_CODE: &[u8] =
    include_bytes!("../../contract/target/wasm32-unknown-unknown/release/nft_rental.wasm");
const MARKETPLACE_CONTRACT_CODE: &[u8] = include_bytes!(
    "../../marketplace/target/wasm32-unknown-unknown/release/niftyrent_marketplace.wasm"
);
const NFT_PAYOUT_CODE: &[u8] =
    include_bytes!("../target/wasm32-unknown-unknown/release/test_nft_with_payout.wasm");
const NFT_NO_PAYOUT_CODE: &[u8] =
    include_bytes!("../target/wasm32-unknown-unknown/release/test_nft_without_payout.wasm");
const FT_CODE: &[u8] = include_bytes!("../target/wasm32-unknown-unknown/release/test_ft.wasm");

// TODO(syu): init is used by all tests, making run time too long. Consider simplify init for some tests.
async fn init(nft_code: &[u8]) -> anyhow::Result<Context> {
    log!("Initialising Test ...");

    let worker = workspaces::sandbox().await?;
    let rental_contract = worker.dev_deploy(CONTRACT_CODE).await?;
    let marketplace_contract = worker.dev_deploy(MARKETPLACE_CONTRACT_CODE).await?;
    let nft_contract = worker.dev_deploy(nft_code).await?;
    let ft_contract = worker.dev_deploy(FT_CODE).await?;

    // create accounts
    let account = worker.dev_create_account().await?;

    let alice = account
        .create_subaccount("alice")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .into_result()?;

    let bob = account
        .create_subaccount("bob")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .into_result()?;

    let charlie = account
        .create_subaccount("charlie")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .into_result()?;

    let marketplace_owner = account
        .create_subaccount("marketplace_owner")
        .initial_balance(parse_near!("10 N"))
        .transact()
        .await?
        .into_result()?;

    let treasury = account
        .create_subaccount("treasury")
        .initial_balance(parse_near!("1 N"))
        .transact()
        .await?
        .into_result()?;

    // initialise contracts
    account
        .call(rental_contract.id(), "new")
        .args_json(json!({ "owner_id": account.id() }))
        .transact()
        .await?
        .into_result()?;

    account
        .call(marketplace_contract.id(), "new")
        .args_json(json!({
           "owner_id": marketplace_owner.id(),
           "treasury_id": treasury.id(),
           "rental_contract_id": rental_contract.id(),
        }))
        .transact()
        .await?
        .into_result()?;

    account
        .call(nft_contract.id(), "new")
        .args_json(json!({ "owner_id": account.id() }))
        .transact()
        .await?
        .into_result()?;

    account
        .call(ft_contract.id(), "new")
        .args_json(json!({ "owner_id": ft_contract.id(), "total_supply": "10000000000" }))
        .transact()
        .await?
        .into_result()?;

    // mint nfts for renting
    account
        .call(nft_contract.id(), "nft_mint")
        .args_json(
            json!({ "token_id": "test", "receiver_id": alice.id(), "token_metadata": {"title": "Test"}}),
        )
        .deposit(parse_near!("0.1 N"))
        .transact()
        .await?
        .into_result()?;

    // register accounts for ft_contract and deposit
    account
        .call(ft_contract.id(), "unsafe_register_and_deposit")
        .args_json(json!({ "account_id": account.id(), "balance": 100000000}))
        .transact()
        .await?
        .into_result()?;

    account
        .call(ft_contract.id(), "unsafe_register_and_deposit")
        .args_json(json!({ "account_id": rental_contract.id(), "balance": 100000000}))
        .transact()
        .await?
        .into_result()?;

    account
        .call(ft_contract.id(), "unsafe_register_and_deposit")
        .args_json(json!({ "account_id": alice.id(), "balance": 10000000}))
        .transact()
        .await?
        .into_result()?;

    account
        .call(ft_contract.id(), "unsafe_register_and_deposit")
        .args_json(json!({ "account_id": bob.id(), "balance": 10000000}))
        .transact()
        .await?
        .into_result()?;

    account
        .call(ft_contract.id(), "unsafe_register_and_deposit")
        .args_json(json!({ "account_id": charlie.id(), "balance": 10000000}))
        .transact()
        .await?
        .into_result()?;

    account
        .call(ft_contract.id(), "unsafe_register_and_deposit")
        .args_json(json!({ "account_id": nft_contract.id(), "balance": 10000000}))
        .transact()
        .await?
        .into_result()?;

    account
        .call(ft_contract.id(), "unsafe_register_and_deposit")
        .args_json(json!({ "account_id": marketplace_owner.id(), "balance": 10000000}))
        .transact()
        .await?
        .into_result()?;

    account
        .call(ft_contract.id(), "unsafe_register_and_deposit")
        .args_json(json!({ "account_id": marketplace_contract.id(), "balance": 10000000}))
        .transact()
        .await?
        .into_result()?;

    // marketplace config - add allowed nft contracts
    log!("Adding allowed NFT contracts for marketplace...");
    let allowed_nft_contracts_ids_expected = vec![nft_contract.id().as_str()];

    let result = marketplace_owner
        .call(marketplace_contract.id(), "add_allowed_nft_contract_ids")
        .args_json(json!({
            "nft_contract_ids": allowed_nft_contracts_ids_expected,
        }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(result.is_success());

    // view the allowed nft contracts in marketpalce
    let allowed_nft_contracts_real: Vec<AccountId> = marketplace_owner
        .call(marketplace_contract.id(), "list_allowed_nft_contract_ids")
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(allowed_nft_contracts_real.len(), 1);
    assert_eq!(
        allowed_nft_contracts_ids_expected[0],
        allowed_nft_contracts_real[0].as_str()
    );
    log!("      ✅ Confirmed allowed NFT contracts for marketplace");

    // marketplace config - add allowed ft contracts
    log!("Adding allowed FT contracts for marketplace...");
    let allowed_ft_contracts_ids_expected = vec![ft_contract.id().as_str()];

    let result = marketplace_owner
        .call(marketplace_contract.id(), "add_allowed_ft_contract_ids")
        .args_json(json!({
            "ft_contract_ids": allowed_ft_contracts_ids_expected,
        }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?;
    assert!(result.is_success());

    // view the allowed ft contracts
    let allowed_ft_contracts_real: Vec<AccountId> = marketplace_owner
        .call(marketplace_contract.id(), "list_allowed_ft_contract_ids")
        .max_gas()
        .transact()
        .await?
        .json()?;

    assert_eq!(allowed_ft_contracts_real.len(), 1);
    assert_eq!(
        allowed_ft_contracts_ids_expected[0],
        allowed_ft_contracts_real[0].as_str()
    );
    log!("      ✅ Confirmed allowed FT contracts for marketplace");

    Ok(Context {
        worker: worker,
        rental_contract: rental_contract,
        rental_contract_owner: account,
        marketplace_contract: marketplace_contract,
        nft_contract: nft_contract,
        ft_contract: ft_contract,
        lender: alice,
        borrower: bob,
        lease_nft_receiver: charlie,
        markeplace_owner: marketplace_owner,
    })
}

// TODO(syu): adjust test to fit marktplace version
// Alice creates a lease to Bob.
// Bob can accept the lease for the first time
// but he should fail if he attempts to accept it for multipe times
async fn test_accept_leases_already_lent() -> anyhow::Result<()> {
    let context = init(NFT_PAYOUT_CODE).await?;
    let lender = context.lender;
    let borrower = context.borrower;
    let contract = context.rental_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;
    let worker = context.worker;
    let token_id = "test";
    // 2023/01/01 00:00:00
    let start_ts_nano: u64 = 1672531200000000000;
    let latest_block = worker.view_block().await?;
    let expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;

    println!("Creating lease ...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": token_id,
            "account_id": contract.id(),
            "msg": json!({"contract_addr": nft_contract.id(),
                          "token_id": token_id,
                          "borrower_id": borrower.id(),
                          "ft_contract_addr": ft_contract.id(),
                          "start_ts_nano": start_ts_nano,
                          "end_ts_nano": expiration_ts_nano,
                          "price": "1000"
            }).to_string()
        }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ Lease created and pending on Bob's acceptence");

    // Confirming the created lease ...
    let leases: Vec<(String, LeaseCondition)> = contract
        .call("leases_by_owner")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;

    let lease_id = &leases[0].0;
    borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": contract.id(),
            "amount": "1000",
            "memo": "",
            "msg": json!({
                "lease_id": lease_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let borrower_balance_after_first_accept: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": borrower.id(),
        }))
        .await?
        .json()?;
    assert_eq!(borrower_balance_after_first_accept.0, 10000000 - 1000);

    let leases_updated: Vec<(String, LeaseCondition)> = contract
        .call("leases_by_owner")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(leases_updated[0].1.state, LeaseState::Active);
    println!("      ✅ Lease accepted by Bob");

    // Bob tries to accept the lease again.
    // The transaction will be aborted and the amount will be returned to borrower
    // TODO[Libo, Haichen]: check what is the expected return if the promise chain throws an exception
    borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": contract.id(),
            "amount": "1000",
            "memo": "",
            "msg": json!({
                "lease_id": lease_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let borrower_balance_after_second_accept: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": borrower.id(),
        }))
        .await?
        .json()?;
    assert_eq!(borrower_balance_after_second_accept.0, 10000000 - 1000);

    println!("      ✅ Lease cannot be accepted by Bob again.");
    Ok(())
}

// TODO(syu): adjust test to fit marktplace version
async fn test_accept_lease_fails_already_transferred() -> anyhow::Result<()> {
    let context = init(NFT_PAYOUT_CODE).await?;
    let lender = context.lender;
    let borrower = context.borrower;

    let worker = workspaces::sandbox().await?;
    let account = worker.dev_create_account().await?;
    let new_owner = account
        .create_subaccount("charles")
        .initial_balance(parse_near!("30 N"))
        .transact()
        .await?
        .into_result()?;

    let contract = context.rental_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;
    let worker = context.worker;
    let token_id = "test";
    // 2023/01/01 00:00:00
    let start_ts_nano: u64 = 1672531200000000000;
    let latest_block = worker.view_block().await?;
    let expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;

    println!("Creating lease ...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": token_id,
            "account_id": contract.id(),
            "msg": json!({"contract_addr": nft_contract.id(),
                          "token_id": token_id,
                          "borrower_id": borrower.id(),
                          "ft_contract_addr": ft_contract.id(),
                          "start_ts_nano": start_ts_nano,
                          "end_ts_nano": expiration_ts_nano,
                          "price": "1000"
            }).to_string()
        }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ Lease created and pending on Bob's acceptence");

    // lender Alice transfers the NFT to another user Charlse
    lender
        .call(nft_contract.id(), "nft_transfer")
        .args_json(json!({
            "receiver_id": new_owner.id(),
            "token_id": token_id,
            "approval_id": null,
            "memo": null,
        }))
        .deposit(1)
        .transact()
        .await?
        .into_result()?;

    // Verify the ownership of the token has been updated
    let token: Token = nft_contract
        .view("nft_token")
        .args_json(json!({
            "token_id": token_id,
        }))
        .await?
        .json()?;
    assert_eq!(token.owner_id.to_string(), new_owner.id().to_string());
    println!("      ✅ Lease token has been transferred from lender Alice to Charles");

    // Confirming the created lease ...
    let leases: Vec<(String, LeaseCondition)> = contract
        .call("leases_by_owner")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;

    let lease_id = &leases[0].0;
    borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": contract.id(),
            "amount": "1000",
            "memo": "",
            "msg": json!({
                "lease_id": lease_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let borrower_balance_after_accept: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": borrower.id(),
        }))
        .await?
        .json()?;

    assert_eq!(borrower_balance_after_accept.0, 10000000);
    println!("      ✅ Lease cannot be accepted by Bob. The transaction will be aborted and Bos's balance will not change.");

    let updated_leases: Vec<(String, LeaseCondition)> = contract
        .call("leases_by_owner")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(updated_leases[0].1.state, LeaseState::PendingOnRent);
    println!("      ✅ Lease cannot be accepted by Bob, the state of the lease is still pending");
    Ok(())
}

// TODO(syu): adjust test to fit marktplace version
async fn test_lender_receives_a_lease_nft_after_lease_activation() -> anyhow::Result<()> {
    let context = init(NFT_NO_PAYOUT_CODE).await?;
    let lender = context.lender;
    let borrower = context.borrower;
    let contract = context.rental_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;
    let worker = context.worker;
    let token_id = "test"; // leasing nft. This should match the info at nft initialisation
    let price = 10000;
    // 2023/01/01 00:00:00
    let start_ts_nano: u64 = 1672531200000000000;
    let latest_block = worker.view_block().await?;
    let expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;

    println!("Creating lease ...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": token_id,
            "account_id": contract.id(),
            "msg": json!({"contract_addr": nft_contract.id(),
                          "token_id": token_id,
                          "borrower_id": borrower.id(),
                          "ft_contract_addr": ft_contract.id(),
                          "start_ts_nano": start_ts_nano,
                          "end_ts_nano": expiration_ts_nano,
                          "price": price.to_string(),
            }).to_string()
        }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let leases: Vec<(String, LeaseCondition)> = contract
        .call("leases_by_owner")
        .args_json(json!({"account_id": lender.id().clone()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(leases.len(), 1);
    let lease = &leases[0].1;
    assert_eq!(lease.state, LeaseState::PendingOnRent);
    println!("      ✅ Lease created");

    println!("Accepting the created lease ...");
    let lease_id = &leases[0].0;
    borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": contract.id().clone(),
            "amount": price.to_string(),
            "memo": "",
            "msg": json!({
                "lease_id": lease_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ Lease acceptance confirmed");

    let active_leases: Vec<(String, LeaseCondition)> = contract
        .call("active_leases_by_lender")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(active_leases.len(), 1);
    assert_eq!(active_leases[0].1.state, LeaseState::Active);
    println!("      ✅ Lease activation confirmed");

    println!("Confirming LEASE NFT contract metatdata ...");
    let nft_contract_metadata: NFTContractMetadata = lender
        .call(contract.id(), "nft_metadata")
        .transact()
        .await?
        .json()?;

    assert_to_string_eq!(NFT_METADATA_SPEC, nft_contract_metadata.spec);
    assert_to_string_eq!(
        "NiFTyRent Lease Ownership Token",
        nft_contract_metadata.name
    );
    assert_to_string_eq!("LEASE", nft_contract_metadata.symbol);
    println!("      ✅ LEASE NFT contract metadata confirmed");

    println!("Confirming LEASE NFT enumeration ...");
    let nft_total_supply: U128 = lender
        .call(contract.id(), "nft_total_supply")
        .transact()
        .await?
        .json()?;
    assert_eq!(1, nft_total_supply.0);
    println!("      ✅ LEASE NFT total supply confirmed");

    let nft_total_supply_for_lender: U128 = lender
        .call(contract.id(), "nft_supply_for_owner")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(1, nft_total_supply_for_lender.0);
    println!("      ✅ LEASE NFT total supply for lender confirmed");

    let lease_token_id_expected = format!("{}{}", lease_id, "_lender");
    let lease_nft_token: Option<Token> = lender
        .call(contract.id(), "nft_token")
        .args_json(json!({"token_id": lease_token_id_expected.clone()}))
        .transact()
        .await?
        .json()?;

    assert_eq!(
        lease_token_id_expected,
        lease_nft_token.as_ref().unwrap().token_id
    );
    assert_to_string_eq!(lender.id(), lease_nft_token.as_ref().unwrap().owner_id);

    let token_metadata = lease_nft_token.as_ref().unwrap().metadata.as_ref();
    assert!(token_metadata.is_some());
    assert_to_string_eq!(
        format!(
            "NiFTyRent Lease Ownership Token: {}",
            &lease_token_id_expected
        ),
        token_metadata.unwrap().title.as_ref().unwrap()
    );
    println!("      ✅ LEASE NFT nft_token info confirmed");

    let lease_nft_tokens_for_borrower: Vec<Token> = borrower
        .call(contract.id(), "nft_tokens_for_owner")
        .args_json(json!({"account_id": borrower.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(lease_nft_tokens_for_borrower.len(), 0);

    let lease_nft_tokens_for_lender: Vec<Token> = lender
        .call(contract.id(), "nft_tokens_for_owner")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(lease_nft_tokens_for_lender.len(), 1);

    let a_lease_nft_token = &lease_nft_tokens_for_lender[0];
    assert_to_string_eq!(lender.id(), a_lease_nft_token.owner_id);
    assert_eq!(lease_token_id_expected, a_lease_nft_token.token_id);
    println!("      ✅ LEASE NFT nft_tokens_for_owner confirmed");

    let lease_nft_tokens: Vec<Token> = lender
        .call(contract.id(), "nft_tokens")
        .args_json(json!({}))
        .transact()
        .await?
        .json()?;
    assert_eq!(lease_nft_tokens.len(), 1);
    assert_eq!(lease_token_id_expected, lease_nft_tokens[0].token_id);
    println!("      ✅ LEASE NFT all nft_tokens confirmed");

    println!("      ✅ LEASE NFT token mint confirmed");
    Ok(())
}

// TODO(syu): adjust test to fit marktplace version
async fn test_lease_nft_can_be_transferred_to_other_account() -> anyhow::Result<()> {
    let context = init(NFT_NO_PAYOUT_CODE).await?;

    let lender = context.lender;
    let borrower = context.borrower;
    let lease_nft_receiver = context.lease_nft_receiver;

    let contract = context.rental_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;
    // 2023/01/01 00:00:00
    let start_ts_nano: u64 = 1672531200000000000;
    let worker = context.worker;
    let token_id = "test"; // leasing nft. This should match the info at nft initialisation
    let price = 10000;
    let latest_block = worker.view_block().await?;
    let expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;

    println!("Creating lease ...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": token_id,
            "account_id": contract.id(),
            "msg": json!({"contract_addr": nft_contract.id(),
                          "token_id": token_id,
                          "borrower_id": borrower.id(),
                          "ft_contract_addr": ft_contract.id(),
                          "start_ts_nano": start_ts_nano,
                          "end_ts_nano": expiration_ts_nano,
                          "price": price.to_string(),
            }).to_string()
        }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    println!("Accepting the created lease ...");
    let leases: Vec<(String, LeaseCondition)> = contract
        .call("leases_by_owner")
        .args_json(json!({"account_id": lender.id().clone()}))
        .transact()
        .await?
        .json()?;
    let lease_id = &leases[0].0;
    borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": contract.id().clone(),
            "amount": price.to_string(),
            "memo": "",
            "msg": json!({
                "lease_id": lease_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ Lease accepted");

    // before transfer, lease is owned by the original lender
    let active_leases: Vec<(String, LeaseCondition)> = contract
        .call("active_leases_by_lender")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(active_leases.len(), 1);
    assert_eq!(active_leases[0].1.state, LeaseState::Active);
    println!("      ✅ Lease activation confirmed");

    // before transfer, lease nft is owned by the original lender
    let lease_nft_tokens_for_lender: Vec<Token> = lender
        .call(contract.id(), "nft_tokens_for_owner")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(1, lease_nft_tokens_for_lender.len());

    let lease_token_id = format!("{}{}", lease_id, "_lender");
    let lease_nft_token: Option<Token> = lender
        .call(contract.id(), "nft_token")
        .args_json(json!({"token_id": lease_token_id.clone()}))
        .transact()
        .await?
        .json()?;
    assert_to_string_eq!(lender.id(), lease_nft_token.as_ref().unwrap().owner_id);
    println!("      ✅ LEASE NFT token got minted to the lender");

    println!("Lender Transfering the LEASE NFT to a new user ...");
    lender
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "receiver_id": lease_nft_receiver.id(),
            "token_id": lease_token_id.clone(),
        }))
        .deposit(1) //require deposit of exact 1 yocto near
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ LEASE NFT transferred");

    println!("Confirming the LEASE NFT transfer ...");
    // after transfer, the lease is owned by the new lender
    let active_leases_by_new_lender: Vec<(String, LeaseCondition)> = contract
        .call("active_leases_by_lender")
        .args_json(json!({"account_id": lease_nft_receiver.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(active_leases_by_new_lender.len(), 1);

    let active_leases_by_old_lender: Vec<(String, LeaseCondition)> = contract
        .call("active_leases_by_lender")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(active_leases_by_old_lender.len(), 0);

    // after transfer, lease nft is owned by the new lender
    let lease_nft_token: Option<Token> = lender
        .call(contract.id(), "nft_token")
        .args_json(json!({"token_id": lease_token_id.clone()}))
        .transact()
        .await?
        .json()?;
    assert_to_string_eq!(
        lease_nft_receiver.id(),
        lease_nft_token.as_ref().unwrap().owner_id
    );

    let lease_nft_tokens_for_new_lender: Vec<Token> = lender
        .call(contract.id(), "nft_tokens_for_owner")
        .args_json(json!({"account_id": lease_nft_receiver.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(1, lease_nft_tokens_for_new_lender.len());

    let lease_nft_tokens_for_old_lender: Vec<Token> = lender
        .call(contract.id(), "nft_tokens_for_owner")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(0, lease_nft_tokens_for_old_lender.len());

    println!("      ✅ LEASE NFT transfer confirmed");

    Ok(())
}

// TODO(syu): adjust test to fit marktplace version
async fn test_claim_back_without_payout_using_lease_nft() -> anyhow::Result<()> {
    let context = init(NFT_NO_PAYOUT_CODE).await?;

    let lender = context.lender;
    let borrower = context.borrower;
    let lease_nft_receiver = context.lease_nft_receiver;

    let contract = context.rental_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;

    let worker = context.worker;
    let token_id = "test"; // leasing nft. This should match the info at nft initialisation
    let price = 10000;
    // 2023/01/01 00:00:00
    let start_ts_nano: u64 = 1672531200000000000;
    let latest_block = worker.view_block().await?;
    let expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;

    println!("Creating lease ...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": token_id,
            "account_id": contract.id(),
            "msg": json!({"contract_addr": nft_contract.id(),
                          "token_id": token_id,
                          "borrower_id": borrower.id(),
                          "ft_contract_addr": ft_contract.id(),
                          "start_ts_nano": start_ts_nano,
                          "end_ts_nano": expiration_ts_nano,
                          "price": price.to_string(),
            }).to_string()
        }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ Lease created");

    println!("Accepting the created lease ...");
    let leases: Vec<(String, LeaseCondition)> = contract
        .call("leases_by_owner")
        .args_json(json!({"account_id": lender.id().clone()}))
        .transact()
        .await?
        .json()?;

    let lease_id = &leases[0].0;
    borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": contract.id().clone(),
            "amount": price.to_string(),
            "memo": "",
            "msg": json!({
                "lease_id": lease_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ Lease accepted");

    println!("Lender Transfering the LEASE NFT to a new user ...");
    let lease_token_id = format!("{}{}", lease_id, "_lender");
    lender
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "receiver_id": lease_nft_receiver.id(),
            "token_id": lease_token_id.clone(),
        }))
        .deposit(1) //require deposit of exact 1 yocto near
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ LEASE NFT transferred");

    // Fast foward to after expiration
    worker.fast_forward(12).await?;

    println!("Claiming back the NFT...");
    let balance_before_claim_back_original_lender: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": lender.id(),
        }))
        .await?
        .json()?;

    lease_nft_receiver
        .call(contract.id(), "claim_back")
        .args_json(json!({
            "lease_id": lease_id,
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let balance_after_claim_back_original_lender: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": lender.id(),
        }))
        .await?
        .json()?;

    // All fund goes to the original lender.
    assert_aprox_eq(
        balance_after_claim_back_original_lender.0 - balance_before_claim_back_original_lender.0,
        price,
    );
    println!("      ✅ Rent payout is correct");

    // NFT is sent to the lease_nft_receiver
    let tokens_for_lease_nft_receiver: Vec<Token> = nft_contract
        .call("nft_tokens_for_owner")
        .args_json(json!({"account_id": lease_nft_receiver.id().to_string()}))
        .transact()
        .await?
        .json()?;

    let nft_token = &tokens_for_lease_nft_receiver[0];
    assert_eq!(nft_token.token_id, token_id);
    println!("      ✅ NFT claimed back correctly");

    Ok(())
}

// TODO(syu): adjust test to fit marktplace version
async fn test_claim_back_with_payout_using_lease_nft() -> anyhow::Result<()> {
    let context = init(NFT_PAYOUT_CODE).await?;

    let lender = context.lender;
    let borrower = context.borrower;
    let lease_nft_receiver = context.lease_nft_receiver;

    let contract = context.rental_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;
    // 2023/01/01 00:00:00
    let start_ts_nano: u64 = 1672531200000000000;
    let worker = context.worker;
    let token_id = "test"; // leasing nft. This should match the info at nft initialisation
    let price = 10000;
    let latest_block = worker.view_block().await?;
    let expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;

    println!("Creating lease ...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": token_id,
            "account_id": contract.id(),
            "msg": json!({"contract_addr": nft_contract.id(),
                          "token_id": token_id,
                          "borrower_id": borrower.id(),
                          "ft_contract_addr": ft_contract.id(),
                          "start_ts_nano": start_ts_nano,
                          "end_ts_nano": expiration_ts_nano,
                          "price": price.to_string(),
            }).to_string()
        }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ Lease created");

    println!("Accepting the created lease ...");
    let leases: Vec<(String, LeaseCondition)> = contract
        .call("leases_by_owner")
        .args_json(json!({"account_id": lender.id().clone()}))
        .transact()
        .await?
        .json()?;

    let lease_id = &leases[0].0;
    borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": contract.id().clone(),
            "amount": price.to_string(),
            "memo": "",
            "msg": json!({
                "lease_id": lease_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ Lease accepted");

    println!("Lender Transfering the LEASE NFT to a new user ...");
    let lease_token_id = format!("{}{}", lease_id, "_lender");
    lender
        .call(contract.id(), "nft_transfer")
        .args_json(json!({
            "receiver_id": lease_nft_receiver.id(),
            "token_id": lease_token_id.clone(),
        }))
        .deposit(1) //require deposit of exact 1 yocto near
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ LEASE NFT transferred");

    // Fast foward to after expiration
    worker.fast_forward(12).await?;

    println!("Claiming back the NFT...");
    let balance_before_claim_back_original_lender: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": lender.id(),
        }))
        .await?
        .json()?;

    let balance_before_claim_back_nft_contract: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": nft_contract.id(),
        }))
        .await?
        .json()?;

    lease_nft_receiver
        .call(contract.id(), "claim_back")
        .args_json(json!({
            "lease_id": lease_id,
        }))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let balance_after_claim_back_original_lender: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": lender.id(),
        }))
        .await?
        .json()?;

    let balance_after_claim_back_nft_contract: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": nft_contract.id(),
        }))
        .await?
        .json()?;

    // Based on the demo NFT royalty logic:
    // - the NFT contract keeps 5% of the rent.
    // - the lender receives the rest 95% of the rent.
    assert_aprox_eq(
        balance_after_claim_back_original_lender.0 - balance_before_claim_back_original_lender.0,
        price / 20 * 19,
    );
    assert_aprox_eq(
        balance_after_claim_back_nft_contract.0 - balance_before_claim_back_nft_contract.0,
        price / 20,
    );
    println!("      ✅ Rent payouts are correct");

    // NFT is sent to the lease_nft_receiver
    let tokens_for_lease_nft_receiver: Vec<Token> = nft_contract
        .call("nft_tokens_for_owner")
        .args_json(json!({"account_id": lease_nft_receiver.id().to_string()}))
        .transact()
        .await?
        .json()?;

    let nft_token = &tokens_for_lease_nft_receiver[0];
    assert_eq!(nft_token.token_id, token_id);
    println!("      ✅ NFT claimed back correctly");

    Ok(())
}

// TODO(syu): adjust test to fit marktplace version
async fn test_create_a_lease_to_start_in_the_future() -> anyhow::Result<()> {
    let context = init(NFT_PAYOUT_CODE).await?;
    let lender = context.lender;
    let borrower = context.borrower;
    let contract = context.rental_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;
    let worker = context.worker;
    let token_id = "test";
    let price = 10000;
    let latest_block = worker.view_block().await?;
    let start_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;
    let expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 100;

    println!("Creating lease ...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": token_id,
            "account_id": contract.id(),
            "msg": json!({"contract_addr": nft_contract.id(),
                          "token_id": token_id,
                          "borrower_id": borrower.id(),
                          "ft_contract_addr": ft_contract.id(),
                          "start_ts_nano": start_ts_nano,
                          "end_ts_nano": expiration_ts_nano,
                          "price": price.to_string(),
            }).to_string()
        }))
        .deposit(parse_near!("1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;
    println!("      ✅ Lease created");

    println!("Confirming the created lease ...");
    let leases: Vec<(String, LeaseCondition)> = contract
        .call("leases_by_owner")
        .args_json(json!({"account_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(leases.len(), 1);

    println!("      ✅ Lease creation confirmed");

    println!("Accepting the created lease ...");
    let lease_id = &leases[0].0;
    borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": contract.id(),
            "amount": price.to_string(),
            "memo": "",
            "msg": json!({
                "lease_id": lease_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    println!("      ✅ Lease accepted");

    println!("Confirm the lease is activated ...");
    let borrower_id_result: String = borrower
        .call(contract.id(), "get_borrower_by_contract_and_token")
        .args_json(json!({
            "contract_id": nft_contract.id(),
            "token_id": token_id,
        }))
        .transact()
        .await?
        .json()?;

    assert_eq!(borrower.id().to_string(), borrower_id_result);
    println!("      ✅ Lease activation accepted");

    let user_id_before_start: String = borrower
        .call(contract.id(), "get_current_user_by_contract_and_token")
        .args_json(json!({
            "contract_id": nft_contract.id(),
            "token_id": token_id,
        }))
        .transact()
        .await?
        .json()?;

    assert_eq!(lender.id().to_string(), user_id_before_start);
    println!("      ✅ The current user of this token is still the lender");

    worker.fast_forward(20).await?;
    let user_id_after_start: String = borrower
        .call(contract.id(), "get_current_user_by_contract_and_token")
        .args_json(json!({
            "contract_id": nft_contract.id(),
            "token_id": token_id,
        }))
        .transact()
        .await?
        .json()?;

    assert_eq!(borrower.id().to_string(), user_id_after_start);
    println!("      ✅ The current user of this token is borrower");

    worker.fast_forward(120).await?;
    let user_id_after_end: String = borrower
        .call(contract.id(), "get_current_user_by_contract_and_token")
        .args_json(json!({
            "contract_id": nft_contract.id(),
            "token_id": token_id,
        }))
        .transact()
        .await?
        .json()?;

    assert_eq!(lender.id().to_string(), user_id_after_end);
    println!("      ✅ The current user of this token is borrower");

    Ok(())
}

// ========= Marketplace Tests =========
#[tokio::test]
async fn test_lender_creates_a_listing_in_marketplace_succeeds() -> anyhow::Result<()> {
    let context = init(NFT_PAYOUT_CODE).await?;
    let worker = context.worker;
    let marketplace_contract = context.marketplace_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;
    let lender = context.lender;

    let nft_token_id = "test";
    let price: u128 = 10000;
    let latest_block = worker.view_block().await?;
    let lease_start_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;
    let lease_expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 100;

    log!("Creating a listing on marketplace...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": nft_token_id,
            "account_id": marketplace_contract.id(),
            "msg": json!({
                "ft_contract_id": ft_contract.id(),
                "price": price.to_string(),
                "lease_start_ts_nano": lease_start_ts_nano.to_string(),
                "lease_end_ts_nano": lease_expiration_ts_nano.to_string(),
            }).to_string()
        }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    log!("      Confirming the created listing ...");
    let listings: Vec<Listing> = marketplace_contract
        .call("list_listings_by_owner_id")
        .args_json(json!({"owner_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(listings.len(), 1);

    let new_listing = &listings[0];
    assert_eq!(new_listing.owner_id.as_str(), lender.id().as_str());
    assert_eq!(
        new_listing.nft_contract_id.as_str(),
        nft_contract.id().as_str()
    );
    assert_eq!(new_listing.nft_token_id, nft_token_id);
    assert_eq!(
        new_listing.ft_contract_id.as_str(),
        ft_contract.id().as_str()
    );
    assert_eq!(new_listing.price.0, price);
    assert_eq!(new_listing.lease_start_ts_nano, lease_start_ts_nano);
    assert_eq!(new_listing.lease_end_ts_nano, lease_expiration_ts_nano);
    log!("      ✅ Confirmed the created listing");

    Ok(())
}

#[tokio::test]
async fn test_borrower_accepts_a_lease_succeeds() -> anyhow::Result<()> {
    let context = init(NFT_PAYOUT_CODE).await?;
    let worker = context.worker;
    let rental_contract = context.rental_contract;
    let rental_contract_owner = context.rental_contract_owner;
    let marketplace_contract = context.marketplace_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;
    let lender = context.lender;
    let borrower = context.borrower;
    let marketplace_owner = context.markeplace_owner;

    let nft_token_id = "test";
    let price: u128 = 10000;
    let latest_block = worker.view_block().await?;
    let lease_start_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;
    let lease_expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 100;

    log!("Creating a listing on marketplace...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": nft_token_id,
            "account_id": marketplace_contract.id(),
            "msg": json!({
                "ft_contract_id": ft_contract.id(),
                "price": price.to_string(),
                "lease_start_ts_nano": lease_start_ts_nano.to_string(),
                "lease_end_ts_nano": lease_expiration_ts_nano.to_string(),
            }).to_string()
        }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    log!("      Confirming the created listing ...");
    let listings: Vec<Listing> = marketplace_contract
        .call("list_listings_by_owner_id")
        .args_json(json!({"owner_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(listings.len(), 1);

    let new_listing: &Listing = &listings[0];
    assert_eq!(new_listing.owner_id.as_str(), lender.id().as_str());
    assert_eq!(
        new_listing.nft_contract_id.as_str(),
        nft_contract.id().as_str()
    );
    assert_eq!(new_listing.nft_token_id, nft_token_id);
    assert!(new_listing.payout.payout.len() > 0);
    log!("      ✅ Confirmed the created listing");

    // Some useful info for debugging. Keep this block for future test reference
    log!("*** DEBUG INFO ***");
    log!("* Lender: {}", lender.id());
    log!("* Borrower: {}", borrower.id());
    log!("* NFT Contract id: {}", nft_contract.id());
    log!("* FT Contract id: {}", ft_contract.id());
    log!("* Rental contract id: {}", rental_contract.id());
    log!("* Marketplace contract id: {}", marketplace_contract.id());
    log!("* Rental contract owner id: {}", rental_contract_owner.id());
    log!(
        "* Marketplace contract owner id: {}",
        marketplace_owner.id()
    );
    let balance_before_accepting_lease_lender: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": lender.id(),
        }))
        .await?
        .json()?;
    let balance_before_accepting_lease_borrower: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": borrower.id(),
        }))
        .await?
        .json()?;

    let balance_before_accepting_lease_marketplace_contract: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": marketplace_contract.id(),
        }))
        .await?
        .json()?;
    let balance_before_accepting_lease_rental_contract: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": rental_contract.id(),
        }))
        .await?
        .json()?;
    log!(
        "* FT balance before lease acceptance - lender: {}",
        balance_before_accepting_lease_lender.0
    );
    log!(
        "* FT balance before lease acceptance - borrower: {}",
        balance_before_accepting_lease_borrower.0
    );
    log!(
        "* FT balance before lease acceptance - marketplace contract: {}",
        balance_before_accepting_lease_marketplace_contract.0
    );
    log!(
        "* FT balance before lease acceptance - rental contract: {}",
        balance_before_accepting_lease_rental_contract.0
    );
    log!("*** END ***");

    log!("Borrower accepting the created listing...");
    let listing_id: (String, String) = (
        nft_contract.id().clone().to_string(),
        nft_token_id.clone().to_string(),
    );

    let result = borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": marketplace_contract.id(),
            "amount": price.to_string(),
            "memo": "",
            "msg": json!({
                "listing_id": listing_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?;

    // Next line is used for debugging Execution history. Keep for reference
    // log!(
    //     "\n>[DEBUG] ft_transfer_call outcomes: {:?}",
    //     result.outcomes()
    // );
    assert!(result.is_success());

    log!("      Confirming the activated listing has been removed from marketplace ...");
    let listings: Vec<Listing> = marketplace_contract
        .call("list_listings_by_owner_id")
        .args_json(json!({"owner_id": lender.id()}))
        .transact()
        .await?
        .json()?;

    assert_eq!(listings.len(), 0);
    log!("      ✅ The activated listing has been removed from marketplace");

    log!("      Confirming the nft is transferred ...");
    let token: Token = nft_contract
        .view("nft_token")
        .args_json(json!({
            "token_id": nft_token_id,
        }))
        .await?
        .json()?;

    assert_eq!(token.owner_id.to_string(), rental_contract.id().to_string());
    log!("      ✅ Lease nft has been transferred from lender to rental contract");

    log!("     Confirming the rent is paid ...");
    let balance_after_accepting_lease_lender: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": lender.id(),
        }))
        .await?
        .json()?;
    let balance_after_accepting_lease_borrower: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": borrower.id(),
        }))
        .await?
        .json()?;

    let balance_after_accepting_lease_marketplace_contract: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": marketplace_contract.id(),
        }))
        .await?
        .json()?;
    let balance_after_accepting_lease_rental_contract: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": rental_contract.id(),
        }))
        .await?
        .json()?;

    log!("*** DEBUG INFO ***");
    log!(
        "* FT balance after lease acceptance - lender: {}",
        balance_after_accepting_lease_lender.0
    );
    log!(
        "* FT balance after lease acceptance - borrower: {}",
        balance_after_accepting_lease_borrower.0
    );
    log!(
        "* FT balance after lease acceptance - marketplace contract: {}",
        balance_after_accepting_lease_marketplace_contract.0
    );
    log!(
        "* FT balance after lease acceptance - rental contract: {}",
        balance_after_accepting_lease_rental_contract.0
    );
    log!("*** END ***");
    assert_eq!(
        price,
        balance_before_accepting_lease_borrower.0 - balance_after_accepting_lease_borrower.0
    );
    assert_eq!(
        price,
        balance_after_accepting_lease_rental_contract.0
            - balance_before_accepting_lease_rental_contract.0
    );
    log!("      ✅ Lease rent has been received by rental contract from borrower");

    log!("      Confirming the lease is activated by Rental contract...");
    let leases: Vec<(String, LeaseCondition)> = rental_contract
        .call("leases_by_borrower")
        .args_json(json!({
            "account_id": borrower.id().clone(),
        }))
        .transact()
        .await?
        .json()?;
    assert_eq!(leases.len(), 1);

    let lease = &leases[0].1;
    assert_eq!(lease.contract_addr.as_str(), nft_contract.id().as_str());
    assert_eq!(lease.token_id, nft_token_id);
    assert_eq!(lease.lender_id.as_str(), lender.id().as_str());
    assert_eq!(lease.borrower_id.as_str(), borrower.id().as_str());
    assert_eq!(lease.price.0, price);
    assert_eq!(lease.state, LeaseState::Active);
    log!("      ✅ Confirmed Lease activation on Rental contract");

    Ok(())
}

#[tokio::test]
async fn test_owner_claims_back_with_payout_succeeds() -> anyhow::Result<()> {
    let context = init(NFT_PAYOUT_CODE).await?;
    let worker = context.worker;
    let rental_contract = context.rental_contract;
    let marketplace_contract = context.marketplace_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;
    let lender = context.lender;
    let borrower = context.borrower;

    let nft_token_id = "test";
    let price: u128 = 10000;
    let latest_block = worker.view_block().await?;
    let lease_start_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;
    let lease_expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 15;

    log!("Creating a listing on marketplace...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": nft_token_id,
            "account_id": marketplace_contract.id(),
            "msg": json!({
                "ft_contract_id": ft_contract.id(),
                "price": price.to_string(),
                "lease_start_ts_nano": lease_start_ts_nano.to_string(),
                "lease_end_ts_nano": lease_expiration_ts_nano.to_string(),
            }).to_string()
        }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let listings: Vec<Listing> = marketplace_contract
        .call("list_listings_by_owner_id")
        .args_json(json!({"owner_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(listings.len(), 1);
    log!("      ✅ Confirmed the created listing");

    log!("Borrower accepting the created listing...");
    let listing_id: (String, String) = (
        nft_contract.id().clone().to_string(),
        nft_token_id.clone().to_string(),
    );

    let result = borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": marketplace_contract.id(),
            "amount": price.to_string(),
            "memo": "",
            "msg": json!({
                "listing_id": listing_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?;
    assert!(result.is_success());

    let leases: Vec<(String, LeaseCondition)> = rental_contract
        .call("leases_by_borrower")
        .args_json(json!({
            "account_id": borrower.id().clone(),
        }))
        .transact()
        .await?
        .json()?;
    let lease_id = &leases[0].0;
    let lease = &leases[0].1;

    assert_eq!(leases.len(), 1);
    assert_eq!(lease.state, LeaseState::Active);
    log!("      ✅ Confirmed Lease activation on Rental contract");

    log!("Fast forword to post Lease expiration.");
    worker.fast_forward(20).await?;

    println!("Claiming back the NFT...");
    let balance_before_claim_back_lender: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": lender.id(),
        }))
        .await?
        .json()?;

    let balance_before_claim_back_nft_contract: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": nft_contract.id(),
        }))
        .await?
        .json()?;

    let result = lender
        .call(rental_contract.id(), "claim_back")
        .args_json(json!({
            "lease_id": lease_id,
        }))
        .max_gas()
        .transact()
        .await?;
    assert!(result.is_success());

    let balance_after_claim_back_lender: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": lender.id(),
        }))
        .await?
        .json()?;

    let balance_after_claim_back_nft_contract: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": nft_contract.id(),
        }))
        .await?
        .json()?;

    // This is based on the demo NFT royalty logic: the NFT contract always keep 5% for itself.
    // So the lender get the rest 95% of the rent.
    assert_aprox_eq(
        balance_after_claim_back_lender.0 - balance_before_claim_back_lender.0,
        price / 20 * 19,
    );
    assert_aprox_eq(
        balance_after_claim_back_nft_contract.0 - balance_before_claim_back_nft_contract.0,
        price / 20,
    );
    log!("      ✅ Royalty splits are correct");

    let owned_tokens: Vec<Token> = nft_contract
        .call("nft_tokens_for_owner")
        .args_json(json!({"account_id": lender.id().to_string()}))
        .transact()
        .await?
        .json()?;

    let nft_token = &owned_tokens[0];
    assert_eq!(nft_token.token_id, nft_token_id);
    log!("      ✅ NFT claimed back by owner");

    Ok(())
}

#[tokio::test]
async fn test_owner_claims_back_without_payout_succeeds() -> anyhow::Result<()> {
    let context = init(NFT_NO_PAYOUT_CODE).await?;
    let worker = context.worker;
    let rental_contract = context.rental_contract;
    let marketplace_contract = context.marketplace_contract;
    let nft_contract = context.nft_contract;
    let ft_contract = context.ft_contract;
    let lender = context.lender;
    let borrower = context.borrower;

    let nft_token_id = "test";
    let price: u128 = 10000;
    let latest_block = worker.view_block().await?;
    let lease_start_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 10;
    let lease_expiration_ts_nano = latest_block.timestamp() + ONE_BLOCK_IN_NANO * 15;

    log!("Creating a listing on marketplace...");
    lender
        .call(nft_contract.id(), "nft_approve")
        .args_json(json!({
            "token_id": nft_token_id,
            "account_id": marketplace_contract.id(),
            "msg": json!({
                "ft_contract_id": ft_contract.id(),
                "price": price.to_string(),
                "lease_start_ts_nano": lease_start_ts_nano.to_string(),
                "lease_end_ts_nano": lease_expiration_ts_nano.to_string(),
            }).to_string()
        }))
        .deposit(parse_near!("0.1 N"))
        .max_gas()
        .transact()
        .await?
        .into_result()?;

    let listings: Vec<Listing> = marketplace_contract
        .call("list_listings_by_owner_id")
        .args_json(json!({"owner_id": lender.id()}))
        .transact()
        .await?
        .json()?;
    assert_eq!(listings.len(), 1);
    log!("      ✅ Confirmed the created listing");

    log!("Borrower accepting the created listing...");
    let listing_id: (String, String) = (
        nft_contract.id().clone().to_string(),
        nft_token_id.clone().to_string(),
    );

    let result = borrower
        .call(ft_contract.id(), "ft_transfer_call")
        .args_json(json!({
            "receiver_id": marketplace_contract.id(),
            "amount": price.to_string(),
            "memo": "",
            "msg": json!({
                "listing_id": listing_id,
            }).to_string()
        }))
        .deposit(1)
        .max_gas()
        .transact()
        .await?;
    assert!(result.is_success());

    let leases: Vec<(String, LeaseCondition)> = rental_contract
        .call("leases_by_borrower")
        .args_json(json!({
            "account_id": borrower.id().clone(),
        }))
        .transact()
        .await?
        .json()?;

    let lease_id = &leases[0].0;
    let lease = &leases[0].1;

    assert_eq!(leases.len(), 1);
    assert_eq!(lease.state, LeaseState::Active);
    log!("      ✅ Confirmed Lease activation on Rental contract");

    log!("Fast forword to post Lease expiration.");
    worker.fast_forward(20).await?;

    println!("Claiming back the NFT...");
    let balance_before_claim_back_lender: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": lender.id(),
        }))
        .await?
        .json()?;

    let result = lender
        .call(rental_contract.id(), "claim_back")
        .args_json(json!({
            "lease_id": lease_id,
        }))
        .max_gas()
        .transact()
        .await?;
    assert!(result.is_success());

    let balance_after_claim_back_lender: U128 = ft_contract
        .view("ft_balance_of")
        .args_json(json!({
            "account_id": lender.id(),
        }))
        .await?
        .json()?;

    // All rent goes to the lender when no payout split.
    assert_aprox_eq(
        balance_after_claim_back_lender.0 - balance_before_claim_back_lender.0,
        price,
    );

    log!("      ✅ Rent splits are correct");

    let owned_tokens: Vec<Token> = nft_contract
        .call("nft_tokens_for_owner")
        .args_json(json!({"account_id": lender.id().to_string()}))
        .transact()
        .await?
        .json()?;

    let nft_token = &owned_tokens[0];
    assert_eq!(nft_token.token_id, nft_token_id);
    log!("      ✅ NFT claimed back by owner");

    Ok(())
}

'''
'''--- integration-tests/tests/utils.rs ---
/// Helper function in test to check if two large number are close enough (<0.5%).
pub fn assert_aprox_eq(a: u128, b: u128) {
    assert!(a.abs_diff(b) < (a + b) / 200)
}

/// Assert the equality between two structs which need to be converted into string.
/// It's useful when the structs are hard to compare directly due to their type difference.
#[macro_export]
macro_rules! assert_to_string_eq {
    ($left:expr, $right:expr) => {
        assert_eq!($left.to_string(), $right.to_string());
    };
}

'''
'''--- marketplace/Cargo.toml ---
[package]
name = "niftyrent_marketplace"
version = "1.0.0"
authors = ["NiFTyRent Team"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-contract-standards = "4.1.1"
near-sdk = "4.0.0"
# near-contract-standards = "4.0.0"
uint = { version = "0.9.3", default-features = false }
# near-crypto = "0.14.0"
# getrandom = { version = "0.2", features = ["js"] }

[profile.release]
codegen-units = 1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
members = []

'''
'''--- marketplace/README.md ---
NiFTyRent Marketplace contract
=================================

A marketplace for users to lend and rent utility NFT assets.

The actual rental logic is delegated to the core rental contract, for sake of responsibility separation.

``` mermaid
sequenceDiagram
    actor Lender
    actor Borrower
    participant Marketplace
    participant Core
    participant Game
    Lender ->> Marketplace: Create lease offer
    Borrower ->> Marketplace: Take lease offer (by tranfer the rent)
    Marketplace->>Core: Transfer NFT, transfer rent, and create an active lease
    Lender ->> Core: View my lendings
    Borrower ->> Core: view my borowings
    Game ->> Core: Check current user
    Lender ->> Core: Claim back the NFT and rent
```

'''
'''--- marketplace/src/externals.rs ---
use crate::*;
use near_sdk::{PromiseOrValue, Promise};

/// NFT contract interface for XCC
#[ext_contract(ext_nft)]
pub trait NonFungibleToken {
    fn nft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        token_id: TokenId,
        msg: String,
        approval_id: Option<u64>,
        memo: Option<String>,
    );

    fn nft_payout(self, token_id: String, balance: U128, max_len_payout: Option<u32>) -> Payout;
}

/// FT contract interface for XCC
#[ext_contract(ext_ft)]
pub trait FungibleToken {
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    );
}

/// Interface of this marketplace contract, for XCC by the contract itself.
#[ext_contract(ext_self)]
trait ExtSelf {
    fn transfer_rent_after_nft_transfer(
        &mut self,
        ft_contract_id: AccountId,
        amount: U128,
        memo: Option<String>,
        listing_id: ListingId,
    ) -> PromiseOrValue<U128>;

    fn create_listing_with_payout(
        &mut self,
        owner_id: AccountId,
        approval_id: u64,
        nft_contract_id: AccountId,
        nft_token_id: TokenId,
        ft_contract_id: AccountId,
        price: U128,
        lease_start_ts_nano: u64,
        lease_end_ts_nano: u64,
    ) -> Promise;
}

'''
'''--- marketplace/src/ft_callbacks.rs ---
use near_sdk::PromiseOrValue;

use crate::externals::*;
use crate::*;

/// Message to be passed in by borrower. The listing_id is available in the dApp's front end
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ListingAcceptanceJson {
    listing_id: ListingId,
}

/// The trait for receiving rent payment and trigering listing acceptance.
pub trait FungibleTokenReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

/**
 * This method will triger the acceptance of a listing.
 * 1. Borrower(Sender) calls `ft_transfer_call` on FT contract.
 * 2. FT contract transfers `amount` tokens from Borrower to Marketplace(reciever).
 * 3. FT contract calls `ft_on_transfer` on Marketplace contract.
 * 4.1 Marketplace contract makes XCC (nft_transfer_call) to transfer the leasing NFT to Core contract.
 * 4.2 Marketplace contract makes XCC (ft_transfer) to transfer rent to Core contract.
 * 5. Marketplace contract resolves the promise returned from Core and returns Promise accordingly.
*/
#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    // TODO(syu): check if ft transfer can be reverted back to borrower, if transaction failed.
    /// Function that initiates the transaction of activating a listed lease.
    #[payable]
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128> {
        // Enforce cross contract call
        let ft_contract_id = env::predecessor_account_id();
        assert_ne!(
            ft_contract_id,
            env::current_account_id(),
            "ft_on_transfer should only be called via XCC"
        );

        // Get the target listing ID
        let listing_acceptance_json: ListingAcceptanceJson =
            near_sdk::serde_json::from_str(&msg).expect("Invalid lease listing");

        let listing: Listing = self
            .listing_by_id
            .get(&listing_acceptance_json.listing_id)
            .unwrap();

        assert_eq!(
            ft_contract_id.clone(),
            listing.ft_contract_id,
            "Wrong FT contract id!"
        );
        assert_eq!(
            amount.0, listing.price.0,
            "Transferred amount doesn't match the asked rent!"
        );

        // Transfer both the to be rented NFT and the rent payment (FT) to the rental contract.
        // The Core rental contract will activate the lease.
        // When Core returns successfully, remove the listing in marketplace
        // 1. Marketplace transfers the NFT to Core contract
        //    1.1 Core contract will create the lease
        // 2. Marketplace transfers rent to Core contract
        // 3. Marketplace reolves the result from the above two steps and returns accordingly

        // msg to be passed in nft_transfer_call for a lease creation
        let msg_lease_json = json!({
            "nft_contract_id": listing.nft_contract_id.clone(),
            "nft_token_id": listing.nft_token_id.clone(),
            "lender_id": listing.owner_id.clone(),
            "borrower_id": sender_id.clone(),
            "ft_contract_addr": listing.ft_contract_id.clone(),
            "price": listing.price.clone(),
            "start_ts_nano": listing.lease_start_ts_nano.clone(),
            "end_ts_nano": listing.lease_end_ts_nano.clone(),
            "nft_payout":listing.payout.clone(),
        })
        .to_string();

        // log nft transfer
        env::log_str(
            &json!({
                "type": "[INFO] NiFTyRent Marketplace: transfer leasing nft.",
                "params": {
                    "nft_contract_id": listing.nft_contract_id.clone(),
                    "nft_token_id": listing.nft_token_id.clone(),
                    "lender": listing.owner_id.clone(),
                    "borrower": sender_id.clone(),
                    "nft_payout": listing.payout.clone(),
                }
            })
            .to_string(),
        );

        // Transfer the leasing nft to Core contract
        ext_nft::ext(listing.nft_contract_id.clone())
            .with_static_gas(Gas(10 * TGAS))
            .with_attached_deposit(1)
            .nft_transfer_call(
                self.rental_contract_id.clone(),   // receiver_id
                listing.nft_token_id.clone(),      // nft_token_id
                msg_lease_json,                    // msg
                Some(listing.approval_id.clone()), // approval_id
                None,                              // memo
            )
            .then(
                // Trasnfer the rent to Core contract, after resolving the returned promise
                // listing will also be removed when both transfers succeeded
                ext_self::ext(env::current_account_id())
                    .with_static_gas(Gas(10 * TGAS))
                    .transfer_rent_after_nft_transfer(
                        listing.ft_contract_id.clone(), // ft_contract_id
                        listing.price.clone(),          // amount
                        None,                           // memo
                        listing_acceptance_json.listing_id,
                    ),
            )
            .as_return()
            .into()
    }
}

'''
'''--- marketplace/src/lib.rs ---
use near_contract_standards::non_fungible_token::TokenId;
use near_sdk::{
    assert_one_yocto,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::{LookupMap, UnorderedMap, UnorderedSet},
    env::{self},
    ext_contract, is_promise_success,
    json_types::{U128, U64},
    near_bindgen, promise_result_as_success, require,
    serde::{Deserialize, Serialize},
    serde_json,
    serde_json::json,
    AccountId, BorshStorageKey, CryptoHash, Gas, PanicOnDefault, PromiseResult,
};
use std::collections::HashMap;

mod externals;
mod ft_callbacks;
mod nft_callbacks;
use crate::externals::*;

pub const TGAS: u64 = 1_000_000_000_000;
pub const BASE_GAS: Gas = Gas(5 * TGAS);
pub const GAS_FOR_ROYALTIES: Gas = BASE_GAS;
// the tolerance of lease price minus the sum of payout
// Set it to 1 to avoid linter error
pub const PAYOUT_DIFF_TORLANCE_YACTO: u128 = 1;

// In the current design, one nft token can only have one active lease, even at different rental periods.
// (NFT Contract, NFT Token ID).
type ListingId = (AccountId, TokenId);

// type used for storing nft token's payout
pub type PayoutHashMap = HashMap<AccountId, U128>;
/// A mapping of NEAR accounts to the amount each should be paid out, in
/// the event of a token-sale. The payout mapping MUST be shorter than the
/// maximum length specified by the financial contract obtaining this
/// payout data. Any mapping of length 10 or less MUST be accepted by
/// financial contracts, so 10 is a safe upper limit.
/// See more: https://nomicon.io/Standards/Tokens/NonFungibleToken/Payout#reference-implementation
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq, Clone, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: PayoutHashMap,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Listing {
    /// The NFT owner
    pub owner_id: AccountId,
    /// The approval id for transfering the NFT into rental contract's custody
    pub approval_id: u64,
    pub nft_contract_id: AccountId,
    pub nft_token_id: TokenId,
    pub ft_contract_id: AccountId,
    pub price: U128,
    pub lease_start_ts_nano: u64,
    pub lease_end_ts_nano: u64,
    /// Lease token's payout info
    pub payout: Payout,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// The admin account
    pub owner_id: AccountId,
    /// The account to receive the marketplace fee. (Currently no fees are collected yet.)
    pub treasury_id: AccountId,
    /// The rental proxy contract (i.e. the core contract) id this marketplace use.
    pub rental_contract_id: AccountId,
    pub listing_by_id: UnorderedMap<ListingId, Listing>,
    /// Whitelist of FT contracts for rent payment.
    pub allowed_ft_contract_ids: UnorderedSet<AccountId>,
    // TODO(libo): Shops?
    pub allowed_nft_contract_ids: UnorderedSet<AccountId>,

    /// Indices of listing for quick lookup.
    pub listing_ids_by_owner_id: LookupMap<AccountId, UnorderedSet<ListingId>>,
    pub listing_ids_by_nft_contract_id: LookupMap<AccountId, UnorderedSet<ListingId>>,
}

#[derive(BorshStorageKey, BorshSerialize)]
enum StorageKey {
    Listings,
    FTTokenIds,
    NFTContractIds,
    ListingsByOwnerId,
    ListingsByOwnerIdInner { account_id_hash: CryptoHash },
    ListingsByNftContractId,
    ListingsByNftContractIdInner { account_id_hash: CryptoHash },
}

#[near_bindgen]
impl Contract {
    // ------------------ Initialization -----------------
    #[init]
    pub fn new(owner_id: AccountId, treasury_id: AccountId, rental_contract_id: AccountId) -> Self {
        Self {
            owner_id: owner_id.into(),
            treasury_id: treasury_id.into(),
            rental_contract_id,
            listing_by_id: UnorderedMap::new(StorageKey::Listings),
            allowed_ft_contract_ids: UnorderedSet::new(StorageKey::FTTokenIds),
            allowed_nft_contract_ids: UnorderedSet::new(StorageKey::NFTContractIds),
            listing_ids_by_owner_id: LookupMap::new(StorageKey::ListingsByOwnerId),
            listing_ids_by_nft_contract_id: LookupMap::new(StorageKey::ListingsByNftContractId),
        }
    }

    // ------------------ Admin Functions -----------------

    /// Set the treasury account to keep accured fees in marketplace
    pub fn set_treasury(&mut self, treasury_id: AccountId) {
        assert_one_yocto();
        self.assert_owner();
        self.treasury_id = treasury_id;
    }

    #[payable]
    pub fn add_allowed_nft_contract_ids(&mut self, nft_contract_ids: Vec<AccountId>) {
        self.assert_owner();
        insert_accounts(nft_contract_ids, &mut self.allowed_nft_contract_ids);
    }

    #[payable]
    pub fn remove_allowed_nft_contract_ids(&mut self, nft_contract_ids: Vec<AccountId>) {
        self.assert_owner();
        remove_accounts(nft_contract_ids, &mut self.allowed_nft_contract_ids);
    }

    #[payable]
    pub fn add_allowed_ft_contract_ids(&mut self, ft_contract_ids: Vec<AccountId>) {
        self.assert_owner();
        insert_accounts(ft_contract_ids, &mut self.allowed_ft_contract_ids);
    }

    // ------------------ View Functions -----------------
    /// List all NFT contract that are allowed to be listed in the market.
    pub fn list_allowed_nft_contract_ids(&self) -> Vec<AccountId> {
        return self.allowed_nft_contract_ids.to_vec();
    }
    /// List all FT contract that are allowed to be used for payment.
    pub fn list_allowed_ft_contract_ids(&self) -> Vec<AccountId> {
        return self.allowed_ft_contract_ids.to_vec();
    }

    // TODO(syu): check if the reuturn should be a vector of <(listing_id, listing)>, instead of just listing
    pub fn list_listings_by_owner_id(&self, owner_id: AccountId) -> Vec<Listing> {
        return self
            .listing_ids_by_owner_id
            .get(&owner_id)
            .unwrap_or(UnorderedSet::new(StorageKey::Listings))
            .iter()
            .map(|list_id| self.listing_by_id.get(&list_id).unwrap())
            .collect::<Vec<_>>();
    }

    pub fn list_listings_by_nft_contract_id(&self, nft_contract_id: AccountId) -> Vec<Listing> {
        return self
            .listing_ids_by_nft_contract_id
            .get(&nft_contract_id)
            .unwrap_or(UnorderedSet::new(StorageKey::Listings))
            .iter()
            .map(|list_id| self.listing_by_id.get(&list_id).unwrap())
            .collect::<Vec<_>>();
    }

    pub fn get_listing_by_id(&self, listing_id: ListingId) -> Listing {
        return self
            .listing_by_id
            .get(&listing_id)
            .expect("Listing not found");
    }

    pub fn get_rental_contract_id(&self) -> AccountId {
        return self.rental_contract_id.clone();
    }

    // ------------------ XCC RPCs -----------------
    /**
     * This method will handle the transfer of rent to Core rental contract,
     * depending on the leasing nft transfer result.
     * Rent will only be transfered to Core, if leasing nft has been transferred correctly.
     * Otherwise, no rent transfer.
     * This XCC can only be called by this contract itself. Thus made private.
     */
    #[private]
    pub fn transfer_rent_after_nft_transfer(
        &mut self,
        ft_contract_id: AccountId,
        amount: U128,
        memo: Option<String>,
        listing_id: ListingId,
    ) -> U128 {
        // previoux XCC should be successful
        require!(
            is_promise_success(),
            "NFT transfer failed. Abort rent transfer!"
        );

        // previoux XCC, nft_transfer_call, should not result in reverting the transfer
        // expected status: SuccessValue(`true`)
        if let PromiseResult::Successful(value) = env::promise_result(0) {
            if let Ok(token_transfered) = near_sdk::serde_json::from_slice::<bool>(&value) {
                require!(
                    token_transfered, // true to
                    "NFT transfer wasn't successful. Abort rent transfer!"
                );
            }
        }

        // Trasnfer the rent to Core contract.
        // msg to be passed in ft_transfer_call. Used for specifying the targeting lease.
        let listing = self
            .listing_by_id
            .get(&listing_id)
            .expect("Listing Id for rent transfer does not exist!");
        let msg_rent_transfer_json = json!({
            "nft_contract_id":listing.nft_contract_id.clone(),
            "nft_token_id": listing.nft_token_id.clone(),
        })
        .to_string();

        // log rent transfer
        env::log_str(
            &json!({
                "type": "[INFO] NiFTyRent Marketplace: transfer rent",
                "params": {
                    "nft_contract_id": listing.nft_contract_id.clone(),
                    "nft_token_id": listing.nft_token_id.clone(),
                    "ft_contract": listing.ft_contract_id.clone(),
                    "price": listing.price.clone(),
                }
            })
            .to_string(),
        );

        // The result of this XCC should be properly handled.
        ext_ft::ext(ft_contract_id.clone())
            .with_attached_deposit(1)
            .with_static_gas(Gas(3 * TGAS))
            .ft_transfer_call(
                self.rental_contract_id.clone(), // receiver_id
                amount,                          // amount
                memo,                            // memo
                msg_rent_transfer_json,
            );

        // remove the listing when both nft transfer and rent transfer succeeded
        self.internal_remove_listing(listing_id.clone());

        // refund set to 0
        let refund_ammount: U128 = U128::from(0);
        return refund_ammount;
    }

    #[private]
    pub fn create_listing_with_payout(
        &mut self,
        owner_id: AccountId,
        approval_id: u64,
        nft_contract_id: AccountId,
        nft_token_id: TokenId,
        ft_contract_id: AccountId,
        price: U128,
        lease_start_ts_nano: u64,
        lease_end_ts_nano: u64,
    ) {
        // log the request to create a listing
        env::log_str(
            &json!({
                "type": "[DEBUG] NiFTyRent Marketplace: Create a listing for the leasing NFT.",
                "params": {
                    "nft_contract_id": nft_contract_id.clone(),
                    "nft_token_id": nft_token_id.clone(),
                    "lender": owner_id.clone(),
                }
            })
            .to_string(),
        );

        let optional_payout;
        if is_promise_success() {
            // If NFT has implemented the `nft_payout` interface
            // then process the result and verify if sum of payout is close enough to the original price
            optional_payout = promise_result_as_success().map(|value| {
                let payout = serde_json::from_slice::<Payout>(&value).unwrap();
                let payout_diff: u128 = price
                    .0
                    .checked_sub(
                        payout
                            .payout
                            .values()
                            .map(|v| v.0)
                            .into_iter()
                            .sum::<u128>(),
                    )
                    .unwrap();
                assert!(
                    payout_diff <= PAYOUT_DIFF_TORLANCE_YACTO,
                    "The difference between the listing price and the sum of payout is too large."
                );
                payout
            });
        } else {
            // If leased nft didn't provide payouts, we add a proxy payout record making original lender own all the rent.
            // This will make claiming back using LEASE NFT easier.
            optional_payout = Some(Payout {
                payout: HashMap::from([(owner_id.clone(), U128::from(price.clone()))]),
            });
        }

        // build the listing
        let new_listing: Listing = Listing {
            owner_id: owner_id,
            approval_id: approval_id,
            nft_contract_id: nft_contract_id.clone(),
            nft_token_id: nft_token_id.clone(),
            ft_contract_id: ft_contract_id,
            price: price,
            lease_start_ts_nano: lease_start_ts_nano,
            lease_end_ts_nano: lease_end_ts_nano,
            payout: optional_payout.unwrap(),
        };

        self.internal_insert_listing(&new_listing);
    }
    // ------------------ Internal Helpers -----------------

    fn internal_insert_listing(&mut self, listing_info: &Listing) {
        // create listing_id based on listing info
        let listing_id = (
            listing_info.nft_contract_id.clone(),
            listing_info.nft_token_id.clone(),
        );

        self.listing_by_id.insert(&listing_id, &listing_info);

        // Update the index: listing_ids_by_owner_id
        let mut listing_ids_set = self
            .listing_ids_by_owner_id
            .get(&listing_info.owner_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::ListingsByOwnerIdInner {
                    account_id_hash: hash_account_id(&listing_info.owner_id),
                })
            });
        listing_ids_set.insert(&listing_id);
        self.listing_ids_by_owner_id
            .insert(&listing_info.owner_id, &listing_ids_set);

        // Update the index: listing_ids_by_NFT_contract_id
        let mut listing_ids_set = self
            .listing_ids_by_nft_contract_id
            .get(&listing_info.nft_contract_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::ListingsByNftContractIdInner {
                    account_id_hash: hash_account_id(&listing_info.nft_contract_id),
                })
            });
        listing_ids_set.insert(&listing_id);
        self.listing_ids_by_nft_contract_id
            .insert(&listing_info.nft_contract_id, &listing_ids_set);

        // TODO(steven): remove this logging or find out why it breaks when running on testnet.
        // env::log_str(
        //     &json!({
        //         "type": "insert_listing",
        //         "params": {
        //             "owner_id": owner_id,
        //             "approval_id": approval_id,
        //             "nft_contract_id": nft_contract_id,
        //             "nft_token_id": nft_token_id,
        //             "ft_contract_id": ft_contract_id,
        //             "price": price,
        //             "lease_start_ts_nano": lease_start_ts_nano,
        //             "lease_end_ts_nano": lease_end_ts_nano,
        //         }
        //     })
        //     .to_string(),
        // );
    }

    fn internal_remove_listing(&mut self, listing_id: ListingId) {
        // check if the target listing exist
        let listing = self
            .listing_by_id
            .get(&listing_id)
            .expect("Input listing_id does not exist");

        // remove the record in listing_by_id index
        self.listing_by_id.remove(&listing_id);

        // remove from index: listing_ids_by_owner_id
        let mut listing_id_set = self.listing_ids_by_owner_id.get(&listing.owner_id).unwrap();
        listing_id_set.remove(&listing_id);

        if listing_id_set.is_empty() {
            self.listing_ids_by_owner_id.remove(&listing.owner_id);
        } else {
            self.listing_ids_by_owner_id
                .insert(&listing.owner_id, &listing_id_set);
        }

        // remove from index: listing_ids_by_NFT_contract_id
        let mut listing_id_set = self
            .listing_ids_by_nft_contract_id
            .get(&listing.nft_contract_id)
            .unwrap();
        listing_id_set.remove(&listing_id);

        if listing_id_set.is_empty() {
            self.listing_ids_by_nft_contract_id
                .remove(&listing.nft_contract_id);
        } else {
            self.listing_ids_by_nft_contract_id
                .insert(&listing.nft_contract_id, &listing_id_set);
        }

        // log the listing removal
        env::log_str(
            &json!({
                "type": "[INFO] NiFTyRent Marketplace: remove listing",
                "params": {
                    "listing_id": &listing_id,
                    "owner_id": listing.owner_id,
                    "nft_contract_id": listing.nft_contract_id,
                    "nft_token_id": listing.nft_token_id,
                }
            })
            .to_string(),
        );
    }

    fn assert_owner(&self) {
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "This function can only be called by the owner!"
        )
    }
}

/// Helper function to add some account ids to a given set.
fn insert_accounts(accounts: Vec<AccountId>, set: &mut UnorderedSet<AccountId>) {
    accounts.iter().for_each(|id| {
        set.insert(id);
    });
}

/// Helper function to remove some account ids to a given set.
fn remove_accounts(accounts: Vec<AccountId>, set: &mut UnorderedSet<AccountId>) {
    accounts.iter().for_each(|id| {
        set.remove(id);
    });
}

fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    let mut hash = CryptoHash::default();
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    /*
    Unit test cases and helper functions

    Test naming format for better readability:
    - test_{function_name} _{succeeds_or_fails} _{condition}
    - When more than one test cases are needed for one function,
    follow the code order of testing failing conditions first and success condition last
    */
    use super::*;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::{testing_env, PromiseResult, RuntimeFeesConfig, VMConfig};

    #[test]
    fn test_new() {
        let owner_id: AccountId = accounts(1).into();
        let treasury_id: AccountId = accounts(2).into();
        let rental_contract_id: AccountId = accounts(3).into();

        let contract = Contract::new(owner_id, treasury_id, rental_contract_id);
        assert_eq!(accounts(1), contract.owner_id);
        assert_eq!(accounts(2), contract.treasury_id);
        assert_eq!(accounts(3), contract.rental_contract_id);

        assert_eq!(0, contract.list_allowed_ft_contract_ids().len());
        assert_eq!(0, contract.list_allowed_nft_contract_ids().len());
    }

    #[test]
    fn test_list_allowed_ft_contract_ids_succeed() {
        let owner_id: AccountId = accounts(1).into();
        let treasury_id: AccountId = accounts(2).into();
        let rental_contract_id: AccountId = accounts(3).into();

        let mut contract = Contract::new(owner_id, treasury_id, rental_contract_id);
        let ft_contract_id: AccountId = accounts(4).into();
        contract
            .allowed_ft_contract_ids
            .insert(&ft_contract_id.clone());
        assert_eq!(ft_contract_id, contract.list_allowed_ft_contract_ids()[0]);
    }

    #[test]
    fn test_list_allowed_nft_contract_ids_succeed() {
        let owner_id: AccountId = accounts(1).into();
        let treasury_id: AccountId = accounts(2).into();
        let rental_contract_id: AccountId = accounts(3).into();

        let mut contract = Contract::new(owner_id, treasury_id, rental_contract_id);
        let nft_contract_id: AccountId = accounts(4).into();
        contract
            .allowed_nft_contract_ids
            .insert(&nft_contract_id.clone());
        assert_eq!(nft_contract_id, contract.list_allowed_nft_contract_ids()[0]);
    }

    #[test]
    fn test_list_listings_by_owner_id_succeed() {
        let owner_id: AccountId = accounts(1).into();
        let treasury_id: AccountId = accounts(2).into();
        let rental_contract_id: AccountId = accounts(3).into();

        let mut contract = Contract::new(owner_id.clone(), treasury_id, rental_contract_id);

        let listing_owner_id: AccountId = accounts(5).into();
        let approval_id: u64 = 1;
        let nft_contract_id: AccountId = accounts(2).into();
        let nft_token_id: TokenId = "test_token".to_string();
        let ft_contract_id: AccountId = accounts(3).into();
        let price: U128 = U128(100);
        // Monday, March 27, 2023 2:32:10 AM
        let lease_start_ts_nano: u64 = 1679884330000000000;
        // Tuesday, March 28, 2023 2:32:10 AM
        let lease_end_ts_nano: u64 = 1679970730000000000;

        // build the listing
        let new_listing: Listing = Listing {
            owner_id: listing_owner_id.clone(),
            approval_id: approval_id.clone(),
            nft_contract_id: nft_contract_id.clone(),
            nft_token_id: nft_token_id.clone(),
            ft_contract_id: ft_contract_id.clone(),
            price: price.clone(),
            lease_start_ts_nano: lease_start_ts_nano.clone(),
            lease_end_ts_nano: lease_end_ts_nano.clone(),
            payout: Payout {
                payout: HashMap::new(),
            },
        };

        contract.internal_insert_listing(&new_listing);

        let res = contract.list_listings_by_owner_id(listing_owner_id.clone());
        assert_eq!(1, res.len());
        assert_eq!(listing_owner_id, res[0].owner_id);
    }

    #[test]
    fn test_list_listings_by_owner_id_id_not_found() {
        let owner_id: AccountId = accounts(1).into();
        let treasury_id: AccountId = accounts(2).into();
        let rental_contract_id: AccountId = accounts(3).into();

        let mut contract = Contract::new(owner_id.clone(), treasury_id, rental_contract_id);

        let listing_owner_id: AccountId = accounts(5).into();
        let approval_id: u64 = 1;
        let nft_contract_id: AccountId = accounts(2).into();
        let nft_token_id: TokenId = "test_token".to_string();
        let ft_contract_id: AccountId = accounts(3).into();
        let price: U128 = U128(100);
        // Monday, March 27, 2023 2:32:10 AM
        let lease_start_ts_nano: u64 = 1679884330000000000;
        // Tuesday, March 28, 2023 2:32:10 AM
        let lease_end_ts_nano: u64 = 1679970730000000000;

        // build the listing
        let new_listing: Listing = Listing {
            owner_id: listing_owner_id.clone(),
            approval_id: approval_id.clone(),
            nft_contract_id: nft_contract_id.clone(),
            nft_token_id: nft_token_id.clone(),
            ft_contract_id: ft_contract_id.clone(),
            price: price.clone(),
            lease_start_ts_nano: lease_start_ts_nano.clone(),
            lease_end_ts_nano: lease_end_ts_nano.clone(),
            payout: Payout {
                payout: HashMap::new(),
            },  // dummy payout field for testing
        };

        contract.internal_insert_listing(&new_listing);

        let res = contract.list_listings_by_owner_id(accounts(1).into());
        assert_eq!(0, res.len());
    }

    #[test]
    fn test_list_listings_by_nft_contract_id_succeed() {
        let owner_id: AccountId = accounts(1).into();
        let treasury_id: AccountId = accounts(2).into();
        let rental_contract_id: AccountId = accounts(3).into();

        let mut contract = Contract::new(owner_id.clone(), treasury_id, rental_contract_id);

        let listing_owner_id: AccountId = accounts(5).into();
        let approval_id: u64 = 1;
        let nft_contract_id: AccountId = accounts(2).into();
        let nft_token_id: TokenId = "test_token".to_string();
        let ft_contract_id: AccountId = accounts(3).into();
        let price: U128 = U128(100);
        // Monday, March 27, 2023 2:32:10 AM
        let lease_start_ts_nano: u64 = 1679884330000000000;
        // Tuesday, March 28, 2023 2:32:10 AM
        let lease_end_ts_nano: u64 = 1679970730000000000;

        // build the listing
        let new_listing: Listing = Listing {
            owner_id: listing_owner_id.clone(),
            approval_id: approval_id.clone(),
            nft_contract_id: nft_contract_id.clone(),
            nft_token_id: nft_token_id.clone(),
            ft_contract_id: ft_contract_id.clone(),
            price: price.clone(),
            lease_start_ts_nano: lease_start_ts_nano.clone(),
            lease_end_ts_nano: lease_end_ts_nano.clone(),
            payout: Payout {
                payout: HashMap::new(),
            },   // dummy payout field for testing
        };

        contract.internal_insert_listing(&new_listing);

        let res = contract.list_listings_by_nft_contract_id(nft_contract_id.clone());
        assert_eq!(1, res.len());
        assert_eq!(nft_contract_id, res[0].nft_contract_id);
    }

    #[test]
    fn test_list_listings_by_nft_contract_id_id_not_found() {
        let owner_id: AccountId = accounts(1).into();
        let treasury_id: AccountId = accounts(2).into();
        let rental_contract_id: AccountId = accounts(3).into();

        let mut contract = Contract::new(owner_id.clone(), treasury_id, rental_contract_id);

        let listing_owner_id: AccountId = accounts(5).into();
        let approval_id: u64 = 1;
        let nft_contract_id: AccountId = accounts(2).into();
        let nft_token_id: TokenId = "test_token".to_string();
        let ft_contract_id: AccountId = accounts(3).into();
        let price: U128 = U128(100);
        // Monday, March 27, 2023 2:32:10 AM
        let lease_start_ts_nano: u64 = 1679884330000000000;
        // Tuesday, March 28, 2023 2:32:10 AM
        let lease_end_ts_nano: u64 = 1679970730000000000;

        // build the listing
        let new_listing: Listing = Listing {
            owner_id: listing_owner_id.clone(),
            approval_id: approval_id.clone(),
            nft_contract_id: nft_contract_id.clone(),
            nft_token_id: nft_token_id.clone(),
            ft_contract_id: ft_contract_id.clone(),
            price: price.clone(),
            lease_start_ts_nano: lease_start_ts_nano.clone(),
            lease_end_ts_nano: lease_end_ts_nano.clone(),
            payout: Payout {
                payout: HashMap::new(),
            },   // dummy payout field for testing
        };

        contract.internal_insert_listing(&new_listing);

        let res = contract.list_listings_by_nft_contract_id(accounts(3).into());
        assert_eq!(0, res.len());
    }

    #[test]
    fn test_create_listing_with_payout_succeeds_when_nft_payout_xcc_succeeded() {
        let marketplace_owner_id: AccountId = create_a_dummy_account_id("marketplace_owner");
        let treasury_id: AccountId = create_a_dummy_account_id("treasury_owner");
        let rental_contract_id: AccountId = create_a_dummy_account_id("rental_contract_owner");

        let mut contract = Contract::new(
            marketplace_owner_id.clone(),
            treasury_id,
            rental_contract_id,
        );

        let nft_contract_id: AccountId = create_a_dummy_account_id("nft_contract");
        let nft_token_id: TokenId = "test_token".to_string();
        let nft_token_owner_id: AccountId = create_a_dummy_account_id("nft_token_owner");
        let ft_contract_id: AccountId = create_a_dummy_account_id("ft_contract_id");
        let price: U128 = U128::from(5);

        let payout_expected = Payout {
            payout: HashMap::from([
                (accounts(2).into(), U128::from(1)),
                (accounts(3).into(), U128::from(4)),
            ]),
        };

        testing_env!(
            VMContextBuilder::new()
                .current_account_id(accounts(0))
                .predecessor_account_id(nft_token_owner_id.clone())
                .build(),
            VMConfig::test(),
            RuntimeFeesConfig::test(),
            HashMap::default(),
            vec![PromiseResult::Successful(
                serde_json::to_vec(&payout_expected).unwrap()
            )],
        );

        contract.create_listing_with_payout(
            nft_token_owner_id.clone(),
            1, // dummy approval id
            nft_contract_id.clone(),
            nft_token_id.clone(),
            ft_contract_id.clone(),
            price,
            0,
            1000,
        );

        assert!(!contract.listing_by_id.is_empty());
        assert!(!contract
            .list_listings_by_nft_contract_id(nft_contract_id.clone())
            .is_empty());

        let listing_info = &contract.list_listings_by_owner_id(nft_token_owner_id.clone())[0];
        assert_eq!(nft_contract_id, listing_info.nft_contract_id);
        assert_eq!(nft_token_id, listing_info.nft_token_id);
        assert_eq!(nft_token_owner_id, listing_info.owner_id);
        assert_eq!(payout_expected, listing_info.payout);
        assert_eq!(5, listing_info.price.0);
        assert_eq!(1000, listing_info.lease_end_ts_nano);
    }

    #[test]
    fn test_create_listing_with_payout_succeeds_when_nft_payout_xcc_failed() {
        // When nft_payout xcc failed, we should still produce a internal payout record,
        // allocating to the original lender the whole price.

        let marketplace_owner_id: AccountId = create_a_dummy_account_id("marketplace_owner");
        let treasury_id: AccountId = create_a_dummy_account_id("treasury_owner");
        let rental_contract_id: AccountId = create_a_dummy_account_id("rental_contract_owner");

        let mut contract = Contract::new(
            marketplace_owner_id.clone(),
            treasury_id,
            rental_contract_id,
        );

        let nft_contract_id: AccountId = create_a_dummy_account_id("nft_contract");
        let nft_token_id: TokenId = "test_token".to_string();
        let nft_token_owner_id: AccountId = create_a_dummy_account_id("nft_token_owner");
        let ft_contract_id: AccountId = create_a_dummy_account_id("ft_contract_id");
        let price: U128 = U128::from(5);

        testing_env!(
            VMContextBuilder::new()
                .current_account_id(accounts(0))
                .predecessor_account_id(nft_token_owner_id.clone())
                .build(),
            VMConfig::test(),
            RuntimeFeesConfig::test(),
            HashMap::default(),
            vec![PromiseResult::Failed],
        );

        contract.create_listing_with_payout(
            nft_token_owner_id.clone(),
            1, // dummy approval id
            nft_contract_id.clone(),
            nft_token_id.clone(),
            ft_contract_id.clone(),
            price,
            0,
            1000,
        );

        assert!(!contract.listing_by_id.is_empty());
        assert!(!contract
            .list_listings_by_nft_contract_id(nft_contract_id.clone())
            .is_empty());

        let payout_expected = Payout {
            payout: HashMap::from([(nft_token_owner_id.clone().into(), U128::from(price.clone()))]),
        };
        let listing_info = &contract.list_listings_by_owner_id(nft_token_owner_id.clone())[0];

        assert_eq!(1, listing_info.payout.payout.keys().len());
        assert_eq!(payout_expected, listing_info.payout);
    }

    #[test]
    #[should_panic(
        expected = "The difference between the listing price and the sum of payout is too large."
    )]
    fn test_create_listing_with_payout_failed_invalid_payout() {
        let marketplace_owner_id: AccountId = create_a_dummy_account_id("marketplace_owner");
        let treasury_id: AccountId = create_a_dummy_account_id("treasury_owner");
        let rental_contract_id: AccountId = create_a_dummy_account_id("rental_contract_owner");

        let mut contract = Contract::new(
            marketplace_owner_id.clone(),
            treasury_id,
            rental_contract_id,
        );

        let nft_contract_id: AccountId = create_a_dummy_account_id("nft_contract");
        let nft_token_id: TokenId = "test_token".to_string();
        let nft_token_owner_id: AccountId = create_a_dummy_account_id("nft_token_owner");
        let ft_contract_id: AccountId = create_a_dummy_account_id("ft_contract_id");
        let price: U128 = U128::from(5);

        // payout is hard coded and its add up differs from asking price
        let payout_returned = Payout {
            payout: HashMap::from([
                (nft_token_owner_id.clone(), U128::from(1)),
                (accounts(3).into(), U128::from(2)),
            ]),
        };

        testing_env!(
            VMContextBuilder::new()
                .current_account_id(accounts(0))
                .predecessor_account_id(nft_token_owner_id.clone())
                .build(),
            VMConfig::test(),
            RuntimeFeesConfig::test(),
            HashMap::default(),
            vec![PromiseResult::Successful(
                serde_json::to_vec(&payout_returned).unwrap()
            )],
        );

        contract.create_listing_with_payout(
            nft_token_owner_id.clone(),
            1, // dummy approval id
            nft_contract_id.clone(),
            nft_token_id.clone(),
            ft_contract_id.clone(),
            price,
            0,
            1000,
        );
    }

    // Helper function to generate a dummy AccountId using input name
    pub(crate) fn create_a_dummy_account_id(account_name: &str) -> AccountId {
        AccountId::new_unchecked(account_name.to_string())
    }

    // ===== Unit Test =====
    // TODO: test_add_allowed_ft_contract_ids_succeeds
    // TODO: test_add_allowed_nft_contract_ids_succeeds
    // TODO: test_add_allowed_ft_contract_ids_fails_wrong_caller
    // TODO: test_add_allowed_nft_contract_ids_fails_wrong_caller
    // TODO: test_remove_allowed_ft_contract_ids
    // TODO: test_remove_allowed_nft_contract_ids
}

'''
'''--- marketplace/src/nft_callbacks.rs ---
use crate::*;
/// approval callbacks from NFT Contracts

pub const MAX_LEN_PAYOUT: u32 = 50;
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct ListingJson {
    ft_contract_id: AccountId,
    price: U128,
    lease_start_ts_nano: U64,
    lease_end_ts_nano: U64,
}

/**
 * Trait to be used as the call back from NFT contract for listing creation.
 * When a lender trys to create a listing, she calls nft_approve attaching a msg of required info.
 * NFT contract will fire a XCC to this marketplace to invoke this function.
 * This will triger creating a listing.
*/
trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {
    /// Function to initiate new listing creation.
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) {
        // enforce cross contract call
        let nft_contract_id = env::predecessor_account_id();
        assert_ne!(
            env::current_account_id(),
            nft_contract_id,
            "nft_on_approve should only be called via XCC"
        );

        // enforce owner_id is the signer
        let signer_id = env::signer_account_id();
        assert_eq!(owner_id, signer_id, "owner_id should be signer_id");

        // enforce nft contract is allowed
        require!(
            self.allowed_nft_contract_ids.contains(&nft_contract_id),
            "nft_contract_id is not allowed!"
        );

        // enfore the token is not listed more than once
        require!(
            self.listing_by_id
                .get(&(nft_contract_id.clone(), token_id.clone()))
                .is_none(),
            "One nft token cannot be listed more than once!!"
        );

        // extract listing details
        let listing_json: ListingJson =
            near_sdk::serde_json::from_str(&msg).expect("Invalid Listing Json!");

        // enforce ft contract is allowed
        require!(
            self.allowed_ft_contract_ids
                .contains(&listing_json.ft_contract_id),
            "ft_contract_id is not allowed!"
        );

        // query the payouts field of the leasing token & create a listing accordingly
        ext_nft::ext(nft_contract_id.clone())
        .nft_payout(
            token_id.clone(), 
            U128::from(listing_json.price.0),  // price
            Some(MAX_LEN_PAYOUT),            // max_len_payout
        ).then(
            ext_self::ext(env::current_account_id())
            .with_static_gas(GAS_FOR_ROYALTIES)
            .create_listing_with_payout(
                owner_id, 
                approval_id, 
                nft_contract_id, 
                token_id, 
                listing_json.ft_contract_id, 
                listing_json.price, 
                listing_json.lease_start_ts_nano.0,
                listing_json.lease_end_ts_nano.0,
            ),
        ).as_return();
        
    }
}

'''
'''--- package.json ---
{
  "name": "nft-rental",
  "version": "1.0.0",
  "license": "(MIT AND Apache-2.0)",
  "scripts": {
    "lint": "cd contract && cargo fmt && cargo clippy",
    "start": "cd frontend && yarn start",

    "deploy": "yarn build:contract && cd contract && near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/nft_rental.wasm",
    "deploy_testnet": "yarn build:contract && cd contract && near deploy --wasmFile ./target/wasm32-unknown-unknown/release/nft_rental.wasm --accountId nft-rental.testnet",
    "deploy_mainnet": "yarn build:contract && cd contract && NEAR_ENV=mainnet near deploy --wasmFile ./target/wasm32-unknown-unknown/release/nft_rental.wasm --accountId nft-rental.near",
    "deploy:marketplace": "yarn build:marketplace && cd marketplace && near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/niftyrent_marketplace.wasm",
    "deploy_testnet:marketplace": "yarn build:marketplace && cd marketplace && near deploy --wasmFile ./target/wasm32-unknown-unknown/release/niftyrent_marketplace.wasm --accountId niftyrent.testnet",
    "deploy:demo_nft": "yarn build:demo_nft && cd demo_nft_contract && near dev-deploy --wasmFile ./target/wasm32-unknown-unknown/release/tamagotchi.wasm",
    "deploy_testnet:demo_nft": "yarn build:demo_nft && cd demo_nft_contract && near deploy --wasmFile ./target/wasm32-unknown-unknown/release/tamagotchi.wasm --accountId tamagotchi-nft.testnet",

    "preview": "cd frontend && yarn vite preview",
    "preview:demo": "cd demo_nft_frontend && yarn vite preview",

    "build": "yarn build:contract && yarn build:web && yarn build:marketplace",
    "build:web": "cd frontend && yarn build",
    "build_testnet:web": "cd frontend && yarn build_testnet",
    "build_mainnet:web": "cd frontend && yarn build_mainnet",
    "build:contract": "cd contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
    "build:marketplace": "cd marketplace && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
    "build:demo_nft": "cd demo_nft_contract && rustup target add wasm32-unknown-unknown && cargo build --all --target wasm32-unknown-unknown --release",
    "build_testnet:demo_web": "cd demo_nft_frontend && yarn build_testnet",

    "test": "yarn test:unit && yarn test:integration && yarn test:marketplace_unit",
    "test:unit": "cd contract && cargo test",
    "test:marketplace_unit": "cd marketplace && cargo test",
    "test:integration": "yarn build:contract && yarn build:marketplace && cd integration-tests && cargo build --all --target wasm32-unknown-unknown --release && cargo test --test integration -- --nocapture",
    "test:gas": "yarn build:contract && yarn build:demo_nft && cd integration-tests && cargo test --test gas_usage -- --nocapture",
    "deps-install": "yarn install && cd frontend && yarn install && cd ..",
    "deps-install:demo_web": "yarn install && cd demo_nft_frontend && yarn install && cd .."
  },
  "devDependencies": {
    "near-api-js": "^1.0.0",
    "near-cli": "^3.3.0"
  },
  "dependencies": {
    "@headlessui/react": "^1.7.0",
    "@heroicons/react": "^2.0.10"
  }
}

'''
'''--- scripts/set_allowed_fts.js ---
// This is a script to set the allowed FT contracts for a deployed testnet rental and marketplace contracts.
//
// expose RENTAL_CONTRACT=dev-123....
// expose MARKETPLACE_CONTRACT=dev-123....
// expose OWNER=someone.testnet
// Usage: near repl -s ./scripts/set_allowed_fts.js --accountId $OWNER

const FT_ADDRS = [
  "wrap.testnet",
  "usdt.fakes.testnet",
  "usdc.fakes.testnet",
]

module.exports.main = async function main({ account, near, nearAPI, argv }) {
  async function register_ft_deposit(ftAddrs, accountId) {
    const contract = new nearAPI.Contract(
      account,
      ftAddrs,
      {
        viewMethods: [],
        changeMethods: ["storage_deposit"],
      });

    await contract.storage_deposit({
      args: { account_id: accountId, registration_only: true },
      amount: "100000000000000000000000"
    }) // 0.1 NEAR
  }

  const rental_contract = new nearAPI.Contract(
    account,
    process.env.RENTAL_CONTRACT,
    {
      viewMethods: ["get_allowed_ft_contract_addrs"],
      changeMethods: ["set_allowed_ft_contract_addrs"],
    });
  const marketplace_contract = new nearAPI.Contract(
    account,
    process.env.MARKETPLACE_CONTRACT,
    {
      viewMethods: ["list_allowed_ft_contract_ids"],
      changeMethods: ["add_allowed_ft_contract_ids"]
    });

  console.log("Rental contract FTs before change:", await rental_contract.get_allowed_ft_contract_addrs());
  await Promise.all(FT_ADDRS.map(addr => { register_ft_deposit(addr, process.env.RENTAL_CONTRACT) }))
  await rental_contract.set_allowed_ft_contract_addrs({ args: { addrs: FT_ADDRS } });
  console.log("Rental contract FTs after change:", await rental_contract.get_allowed_ft_contract_addrs());

  console.log("Marketplace contract FTs before change:", await marketplace_contract.list_allowed_ft_contract_ids());
  await Promise.all(FT_ADDRS.map(addr => { register_ft_deposit(addr, process.env.MARKETPLACE_CONTRACT) }))
  await marketplace_contract.add_allowed_ft_contract_ids({ args: { ft_contract_ids: FT_ADDRS } });
  console.log("Marketplace contract FTs after change:", await marketplace_contract.list_allowed_ft_contract_ids());
};

'''
'''--- scripts/test_util.txt ---
// create a new nft
near call nft.examples.testnet nft_mint '{"token_id": "lease_test", "receiver_id": "crypto_ty.testnet", "metadata": { "title": "GO TEAM", "description": "The Team Goes", "media": "https://bafybeidl4hjbpdr6u6xvlrizwxbrfcyqurzvcnn5xoilmcqbxfbdwrmp5m.ipfs.dweb.link/", "copies": 1}}' --accountId $NEARID --deposit 0.1

// test cross func call: approve a nft listing -- success
near call nft.examples.testnet nft_approve '{
    "token_id": "lease_test",
    "account_id": "dev-1663069114497-11129042426062",
    "msg": "{\"contract_addr\": \"nft.examples.testnet\", \"token_id\": \"lease_test\", \"borrower\": \"ty_dev.testnet\", \"expiration\": 3600, \"amount_near\": "1"}"
  }' --accountId crypto_ty.testnet --depositYocto 440000000000000000000

// call function: borrower to accept the lease
near call dev-1663069114497-11129042426062 lending_accept '{
  "lease_id": "2GeKqFXYHqEw8qT1Lj7Yfx42jwdbaZVfHp2uZBDsCB4V"
  }' --accountId ty_dev.testnet --depositYocto 1

// call contract function: to check full list of active leases by owner -- success
near call dev-1663069114497-11129042426062 leases_by_owner '{"account_id": "crypto_ty.testnet"}' --accountId crypto_ty.testnet

// call contract function: to check full list of active leases by borrower -- success 
near call dev-1663069114497-11129042426062 leases_by_borrower '{"account_id": "ty_dev.testnet"}' --accountId crypto_ty.testnet

// call contract function: to check all an active lease's borrower -- success
near call dev-1663069114497-11129042426062 get_borrower '{
  "contract_id": "nft.examples.testnet",
  "token_id": "lease_test"
  }' --accountId crypto_ty.testnet

// test: contract function - test proxy method call - reject
near call dev-1663069114497-11129042426062 proxy_func_calls '{"contract_id": "nft.examples.testnet","method_name": "nft_transfer", "args": ""}' --accountId crypto_ty.testnet
// test: contract function - test proxy method call - pass
near call dev-1663069114497-11129042426062 proxy_func_calls '{"contract_id": "nft.examples.testnet","method_name": "nft_88", "args": ""}' --accountId crypto_ty.testnet

//call claim function
near call dev-1663069114497-11129042426062 claim_back '{
  "lease_id": "2GeKqFXYHqEw8qT1Lj7Yfx42jwdbaZVfHp2uZBDsCB4V"
  }' --accountId crypto_ty.testnet

// initialise a contract
near call dev-1663069114497-11129042426062 new '{"owner_id": "crypto_ty.testnet"}' --accountId crypto_ty.testnet

// 
yarn deploy

'''
'''--- scripts/view_state_keys.js ---
// List all state keys of a given contract on testnet.
//
// Useful for clear the contract state completely when it's needed.
//
// See more: https://gist.github.com/ilyar/19bdc04d1aa09ae0fc84eb4297df1a1d
// Example use:
//
// expose CONTRACT_NAME=dev-123....
// expose OWNER_ID=someone.testnet
// near call $CONTRACT_NAME clean --base64 "$(node scripts/view_state_keys.js | base64)" --accountId $CONTRACT_NAME --gas 300000000000000

const nearAPI = require('near-api-js')
const { connect, keyStores } = nearAPI
const keyStore = new keyStores.UnencryptedFileSystemKeyStore(__dirname);
const config = {
  keyStore,
  networkId: 'testnet',
  nodeUrl: 'https://rpc.testnet.near.org',
  walletUrl: 'https://wallet.testnet.near.org',
  helperUrl: 'https://helper.testnet.near.org',
  explorerUrl: 'https://explorer.testnet.near.org',
}

async function main () {
  const near = await connect(config)
  const response = await near.connection.provider.query({
    request_type: 'view_state',
    finality: 'final',
    account_id: process.env.CONTRACT_NAME,
    prefix_base64: '',
  })
  console.log(JSON.stringify({
    // TODO add calc size of data for limit burning 200TGas for one call on contract
    keys: response.values.map(it => it.key),
    owner_id: process.env.OWNER_ID
  }))
}

main().catch(reason => {
  console.error(reason)
})

'''