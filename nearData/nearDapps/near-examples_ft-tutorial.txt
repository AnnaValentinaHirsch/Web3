*GitHub Repository "near-examples/ft-tutorial"*

'''--- 1.skeleton/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = "1"
serde_json = "1"
'''
'''--- 1.skeleton/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ../out/contract.wasm
'''
'''--- 1.skeleton/src/ft_core.rs ---
use near_sdk::{Gas, ext_contract, PromiseOrValue, assert_one_yocto, PromiseResult};

use crate::*;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        /*
            FILL THIS IN
        */
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn ft_total_supply(&self) -> U128 {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    // Finalize an `ft_transfer_call` chain of cross-contract calls.
    //
    // The `ft_transfer_call` process:
    //
    // 1. Sender calls `ft_transfer_call` on FT contract
    // 2. FT contract transfers `amount` tokens from sender to receiver
    // 3. FT contract calls `ft_on_transfer` on receiver contract
    // 4+. [receiver contract may make other cross-contract calls]
    // N. FT contract resolves promise chain with `ft_resolve_transfer`, and may
    //    refund sender some or all of original `amount`
    //
    // Requirements:
    // * Contract MUST forbid calls to this function by any account except self
    // * If promise chain failed, contract MUST revert token transfer
    // * If promise chain resolves with a non-zero amount given as a string,
    //   contract MUST return this amount of tokens to `sender_id`
    //
    // Arguments:
    // * `sender_id`: the sender of `ft_transfer_call`
    // * `receiver_id`: the `receiver_id` argument given to `ft_transfer_call`
    // * `amount`: the `amount` argument given to `ft_transfer_call`
    //
    // Returns a string representing a string version of an unsigned 128-bit
    // integer of how many total tokens were spent by sender_id. Example: if sender
    // calls `ft_transfer_call({ "amount": "100" })`, but `receiver_id` only uses
    // 80, `ft_on_transfer` will resolve with `"20"`, and `ft_resolve_transfer`
    // will return `"80"`.
    #[private]
    pub fn ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}

'''
'''--- 1.skeleton/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, StorageUsage};

pub mod ft_core;
pub mod metadata;
pub mod storage;

use crate::metadata::*;

/// The image URL for the default icon
const DATA_IMAGE_SVG_GT_ICON: &str = "data:image/jpeg;base64,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";

/// The specific version of the standard we're using
pub const FT_METADATA_SPEC: &str = "ft-1.0.0";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /*
        FILL THIS IN
    */
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    Metadata
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}
'''
'''--- 1.skeleton/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen};

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    /*
        FILL THIS IN
    */
}

pub trait FungibleTokenMetadataProvider {
    // View call for returning the contract metadata
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}

'''
'''--- 1.skeleton/src/storage.rs ---
use near_sdk::json_types::U128;
use near_sdk::{env, log, AccountId, Balance, Promise};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;

// The structure that will be returned for the methods:
// * `storage_deposit`
// * `storage_withdraw`
// * `storage_balance_of`
// The `total` and `available` values are string representations of unsigned
// 128-bit integers showing the balance of a specific account in yoctoⓃ.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// The below structure will be returned for the method `storage_balance_bounds`.
// Both `min` and `max` are string representations of unsigned 128-bit integers.
//
// `min` is the amount of tokens required to start using this contract at all
// (eg to register with the contract). If a new contract user attaches `min`
// NEAR to a `storage_deposit` call, subsequent calls to `storage_balance_of`
// for this user must show their `total` equal to `min` and `available=0` .
//
// A contract may implement `max` equal to `min` if it only charges for initial
// registration, and does not adjust per-user storage over time. A contract
// which implements `max` must refund deposits that would increase a user's
// storage balance beyond this amount.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    /************************************/
    /* CHANGE METHODS on fungible token */
    /************************************/
    // Payable method that receives an attached deposit of Ⓝ for a given account.
    //
    // If `account_id` is omitted, the deposit MUST go toward predecessor account.
    // If provided, deposit MUST go toward this account. If invalid, contract MUST
    // panic.
    //
    // If `registration_only=true`, contract MUST refund above the minimum balance
    // if the account wasn't registered and refund full deposit if already
    // registered.
    //
    // The `storage_balance_of.total` + `attached_deposit` in excess of
    // `storage_balance_bounds.max` must be refunded to predecessor account.
    //
    // Returns the StorageBalance structure showing updated balances.
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /****************/
    /* VIEW METHODS */
    /****************/
    // Returns minimum and maximum allowed balance amounts to interact with this
    // contract. See StorageBalanceBounds.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    // Returns the StorageBalance structure of the valid `account_id`
    // provided. Must panic if `account_id` is invalid.
    //
    // If `account_id` is not registered, must return `null`.
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance>;
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[allow(unused_variables)]
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}

'''
'''--- 2.define-a-token/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = "1"
serde_json = "1"
'''
'''--- 2.define-a-token/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ../out/contract.wasm
'''
'''--- 2.define-a-token/src/ft_core.rs ---
use near_sdk::{Gas, ext_contract, PromiseOrValue, assert_one_yocto, PromiseResult};

use crate::*;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        /*
            FILL THIS IN
        */
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn ft_total_supply(&self) -> U128 {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    // Finalize an `ft_transfer_call` chain of cross-contract calls.
    //
    // The `ft_transfer_call` process:
    //
    // 1. Sender calls `ft_transfer_call` on FT contract
    // 2. FT contract transfers `amount` tokens from sender to receiver
    // 3. FT contract calls `ft_on_transfer` on receiver contract
    // 4+. [receiver contract may make other cross-contract calls]
    // N. FT contract resolves promise chain with `ft_resolve_transfer`, and may
    //    refund sender some or all of original `amount`
    //
    // Requirements:
    // * Contract MUST forbid calls to this function by any account except self
    // * If promise chain failed, contract MUST revert token transfer
    // * If promise chain resolves with a non-zero amount given as a string,
    //   contract MUST return this amount of tokens to `sender_id`
    //
    // Arguments:
    // * `sender_id`: the sender of `ft_transfer_call`
    // * `receiver_id`: the `receiver_id` argument given to `ft_transfer_call`
    // * `amount`: the `amount` argument given to `ft_transfer_call`
    //
    // Returns a string representing a string version of an unsigned 128-bit
    // integer of how many total tokens were spent by sender_id. Example: if sender
    // calls `ft_transfer_call({ "amount": "100" })`, but `receiver_id` only uses
    // 80, `ft_on_transfer` will resolve with `"20"`, and `ft_resolve_transfer`
    // will return `"80"`.
    #[private]
    pub fn ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}

'''
'''--- 2.define-a-token/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, StorageUsage};

pub mod ft_core;
pub mod metadata;
pub mod storage;

use crate::metadata::*;

/// The image URL for the default icon
const DATA_IMAGE_SVG_GT_ICON: &str = "data:image/jpeg;base64,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";

/// The specific version of the standard we're using
pub const FT_METADATA_SPEC: &str = "ft-1.0.0";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Metadata for the contract itself
    pub metadata: LazyOption<FungibleTokenMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    Metadata
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        // Calls the other function "new: with some default metadata and the owner_id & total supply passed in 
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Team Token FT Tutorial".to_string(),
                symbol: "gtNEAR".to_string(),
                icon: Some(DATA_IMAGE_SVG_GT_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        // Create a variable of type Self with all the fields initialized. 
        let mut this = Self {
            metadata: LazyOption::new(
                StorageKey::Metadata.try_to_vec().unwrap(),
                Some(&metadata),
            )
        };

        // Return the Contract object
        this
    }
}
'''
'''--- 2.define-a-token/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen};

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub spec: String, // Should be ft-1.0.0 to indicate that a Fungible Token contract adheres to the current versions of this Metadata and the Fungible Token Core specs. This will allow consumers of the Fungible Token to know if they support the features of a given contract.
    pub name: String, // The human-readable name of the token.
    pub symbol: String, // The abbreviation, like wETH or AMPL.
    pub icon: Option<String>, // Icon of the fungible token.
    pub reference: Option<String>, // A link to a valid JSON file containing various keys offering supplementary details on the token 
    pub reference_hash: Option<Base64VecU8>, // The base64-encoded sha256 hash of the JSON file contained in the reference field. This is to guard against off-chain tampering.
    pub decimals: u8, // used in frontends to show the proper significant digits of a token. This concept is explained well in this OpenZeppelin post. https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals
}

pub trait FungibleTokenMetadataProvider {
    // View call for returning the contract metadata
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- 2.define-a-token/src/storage.rs ---
use near_sdk::json_types::U128;
use near_sdk::{env, log, AccountId, Balance, Promise};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;

// The structure that will be returned for the methods:
// * `storage_deposit`
// * `storage_withdraw`
// * `storage_balance_of`
// The `total` and `available` values are string representations of unsigned
// 128-bit integers showing the balance of a specific account in yoctoⓃ.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// The below structure will be returned for the method `storage_balance_bounds`.
// Both `min` and `max` are string representations of unsigned 128-bit integers.
//
// `min` is the amount of tokens required to start using this contract at all
// (eg to register with the contract). If a new contract user attaches `min`
// NEAR to a `storage_deposit` call, subsequent calls to `storage_balance_of`
// for this user must show their `total` equal to `min` and `available=0` .
//
// A contract may implement `max` equal to `min` if it only charges for initial
// registration, and does not adjust per-user storage over time. A contract
// which implements `max` must refund deposits that would increase a user's
// storage balance beyond this amount.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    /************************************/
    /* CHANGE METHODS on fungible token */
    /************************************/
    // Payable method that receives an attached deposit of Ⓝ for a given account.
    //
    // If `account_id` is omitted, the deposit MUST go toward predecessor account.
    // If provided, deposit MUST go toward this account. If invalid, contract MUST
    // panic.
    //
    // If `registration_only=true`, contract MUST refund above the minimum balance
    // if the account wasn't registered and refund full deposit if already
    // registered.
    //
    // The `storage_balance_of.total` + `attached_deposit` in excess of
    // `storage_balance_bounds.max` must be refunded to predecessor account.
    //
    // Returns the StorageBalance structure showing updated balances.
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /****************/
    /* VIEW METHODS */
    /****************/
    // Returns minimum and maximum allowed balance amounts to interact with this
    // contract. See StorageBalanceBounds.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    // Returns the StorageBalance structure of the valid `account_id`
    // provided. Must panic if `account_id` is invalid.
    //
    // If `account_id` is not registered, must return `null`.
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance>;
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[allow(unused_variables)]
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}

'''
'''--- 3.initial-supply/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = "1"
serde_json = "1"
'''
'''--- 3.initial-supply/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ../out/contract.wasm
'''
'''--- 3.initial-supply/src/events.rs ---
//! Standard for nep141 (Fungible Token) events.
//!
//! These events will be picked up by the NEAR indexer.
//!
//! <https://github.com/near/NEPs/blob/master/specs/Standards/FungibleToken/Event.md>
//!
//! This is an extension of the events format (nep-297):
//! <https://github.com/near/NEPs/blob/master/specs/Standards/EventsFormat.md>
//!
//! The three events in this standard are [`FtMint`], [`FtTransfer`], and [`FtBurn`].
//!
//! These events can be logged by calling `.emit()` on them if a single event, or calling
//! [`FtMint::emit_many`], [`FtTransfer::emit_many`],
//! or [`FtBurn::emit_many`] respectively.

use near_sdk::json_types::U128;
use near_sdk::AccountId;
use near_sdk::serde::Serialize;

use near_sdk::env;

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]
pub(crate) enum NearEvent<'a> {
    Nep141(Nep141Event<'a>),
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self).ok().unwrap_or_else(|| env::abort())
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub(crate) fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string());
    }
}

/// Data to log for an FT mint event. To log this event, call [`.emit()`](FtMint::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtMint<'a> {
    pub owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtMint<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT mint event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtMint`] represents the data of each mint.
    pub fn emit_many(data: &[FtMint<'_>]) {
        new_141_v1(Nep141EventKind::FtMint(data)).emit()
    }
}

/// Data to log for an FT transfer event. To log this event,
/// call [`.emit()`](FtTransfer::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtTransfer<'a> {
    pub old_owner_id: &'a AccountId,
    pub new_owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtTransfer<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT transfer event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtTransfer`] represents the data of each transfer.
    pub fn emit_many(data: &[FtTransfer<'_>]) {
        new_141_v1(Nep141EventKind::FtTransfer(data)).emit()
    }
}

#[derive(Serialize, Debug)]
pub(crate) struct Nep141Event<'a> {
    version: &'static str,
    #[serde(flatten)]
    event_kind: Nep141EventKind<'a>,
}

#[derive(Serialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
enum Nep141EventKind<'a> {
    FtMint(&'a [FtMint<'a>]),
    FtTransfer(&'a [FtTransfer<'a>]),
}

fn new_141<'a>(version: &'static str, event_kind: Nep141EventKind<'a>) -> NearEvent<'a> {
    NearEvent::Nep141(Nep141Event { version, event_kind })
}

fn new_141_v1(event_kind: Nep141EventKind) -> NearEvent {
    new_141("1.0.0", event_kind)
}
'''
'''--- 3.initial-supply/src/ft_core.rs ---
use near_sdk::{Gas, ext_contract, PromiseOrValue, assert_one_yocto, PromiseResult};

use crate::*;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        /*
            FILL THIS IN
        */
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn ft_total_supply(&self) -> U128 {
        // Return the total supply casted to a U128
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        // Return the balance of the account casted to a U128
        self.accounts.get(&account_id).unwrap_or(0).into()
    }
}

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    // Finalize an `ft_transfer_call` chain of cross-contract calls.
    //
    // The `ft_transfer_call` process:
    //
    // 1. Sender calls `ft_transfer_call` on FT contract
    // 2. FT contract transfers `amount` tokens from sender to receiver
    // 3. FT contract calls `ft_on_transfer` on receiver contract
    // 4+. [receiver contract may make other cross-contract calls]
    // N. FT contract resolves promise chain with `ft_resolve_transfer`, and may
    //    refund sender some or all of original `amount`
    //
    // Requirements:
    // * Contract MUST forbid calls to this function by any account except self
    // * If promise chain failed, contract MUST revert token transfer
    // * If promise chain resolves with a non-zero amount given as a string,
    //   contract MUST return this amount of tokens to `sender_id`
    //
    // Arguments:
    // * `sender_id`: the sender of `ft_transfer_call`
    // * `receiver_id`: the `receiver_id` argument given to `ft_transfer_call`
    // * `amount`: the `amount` argument given to `ft_transfer_call`
    //
    // Returns a string representing a string version of an unsigned 128-bit
    // integer of how many total tokens were spent by sender_id. Example: if sender
    // calls `ft_transfer_call({ "amount": "100" })`, but `receiver_id` only uses
    // 80, `ft_on_transfer` will resolve with `"20"`, and `ft_resolve_transfer`
    // will return `"80"`.
    #[private]
    pub fn ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}

'''
'''--- 3.initial-supply/src/internal.rs ---
use near_sdk::{require};

use crate::*;

impl Contract {
    /// Internal method for depositing some amount of FTs into an account. 
    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account.
        let balance = self.accounts.get(&account_id).unwrap_or(0);
        
        // Add the amount to the balance and insert the new balance into the accounts map
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("Balance overflow");
        }
    }
}
'''
'''--- 3.initial-supply/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, StorageUsage};

pub mod ft_core;
pub mod events;
pub mod metadata;
pub mod storage;
pub mod internal;

use crate::metadata::*;
use crate::events::*;

/// The image URL for the default icon
const DATA_IMAGE_SVG_GT_ICON: &str = "data:image/jpeg;base64,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";

/// The specific version of the standard we're using
pub const FT_METADATA_SPEC: &str = "ft-1.0.0";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Keep track of each account's balances
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of all tokens.
    pub total_supply: Balance,

    /// Metadata for the contract itself
    pub metadata: LazyOption<FungibleTokenMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    Metadata
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        // Calls the other function "new: with some default metadata and the owner_id & total supply passed in 
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Team Token FT Tutorial".to_string(),
                symbol: "gtNEAR".to_string(),
                icon: Some(DATA_IMAGE_SVG_GT_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        // Create a variable of type Self with all the fields initialized. 
        let mut this = Self {
            // Set the total supply
            total_supply: total_supply.0,
            // Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            accounts: LookupMap::new(StorageKey::Accounts.try_to_vec().unwrap()),
            metadata: LazyOption::new(
                StorageKey::Metadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        };

        // Set the owner's balance to the total supply.
        this.internal_deposit(&owner_id, total_supply.into());

        // Emit an event showing that the FTs were minted
        FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial token supply is minted"),
        }
        .emit();

        // Return the Contract object
        this
    }
}
'''
'''--- 3.initial-supply/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen};

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub spec: String, // Should be ft-1.0.0 to indicate that a Fungible Token contract adheres to the current versions of this Metadata and the Fungible Token Core specs. This will allow consumers of the Fungible Token to know if they support the features of a given contract.
    pub name: String, // The human-readable name of the token.
    pub symbol: String, // The abbreviation, like wETH or AMPL.
    pub icon: Option<String>, // Icon of the fungible token.
    pub reference: Option<String>, // A link to a valid JSON file containing various keys offering supplementary details on the token 
    pub reference_hash: Option<Base64VecU8>, // The base64-encoded sha256 hash of the JSON file contained in the reference field. This is to guard against off-chain tampering.
    pub decimals: u8, // used in frontends to show the proper significant digits of a token. This concept is explained well in this OpenZeppelin post. https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals
}

pub trait FungibleTokenMetadataProvider {
    // View call for returning the contract metadata
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- 3.initial-supply/src/storage.rs ---
use near_sdk::json_types::U128;
use near_sdk::{env, log, AccountId, Balance, Promise};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;

// The structure that will be returned for the methods:
// * `storage_deposit`
// * `storage_withdraw`
// * `storage_balance_of`
// The `total` and `available` values are string representations of unsigned
// 128-bit integers showing the balance of a specific account in yoctoⓃ.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// The below structure will be returned for the method `storage_balance_bounds`.
// Both `min` and `max` are string representations of unsigned 128-bit integers.
//
// `min` is the amount of tokens required to start using this contract at all
// (eg to register with the contract). If a new contract user attaches `min`
// NEAR to a `storage_deposit` call, subsequent calls to `storage_balance_of`
// for this user must show their `total` equal to `min` and `available=0` .
//
// A contract may implement `max` equal to `min` if it only charges for initial
// registration, and does not adjust per-user storage over time. A contract
// which implements `max` must refund deposits that would increase a user's
// storage balance beyond this amount.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    /************************************/
    /* CHANGE METHODS on fungible token */
    /************************************/
    // Payable method that receives an attached deposit of Ⓝ for a given account.
    //
    // If `account_id` is omitted, the deposit MUST go toward predecessor account.
    // If provided, deposit MUST go toward this account. If invalid, contract MUST
    // panic.
    //
    // If `registration_only=true`, contract MUST refund above the minimum balance
    // if the account wasn't registered and refund full deposit if already
    // registered.
    //
    // The `storage_balance_of.total` + `attached_deposit` in excess of
    // `storage_balance_bounds.max` must be refunded to predecessor account.
    //
    // Returns the StorageBalance structure showing updated balances.
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /****************/
    /* VIEW METHODS */
    /****************/
    // Returns minimum and maximum allowed balance amounts to interact with this
    // contract. See StorageBalanceBounds.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    // Returns the StorageBalance structure of the valid `account_id`
    // provided. Must panic if `account_id` is invalid.
    //
    // If `account_id` is not registered, must return `null`.
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance>;
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[allow(unused_variables)]
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}

'''
'''--- 4.storage/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = "1"
serde_json = "1"
'''
'''--- 4.storage/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ../out/contract.wasm
'''
'''--- 4.storage/src/events.rs ---
//! Standard for nep141 (Fungible Token) events.
//!
//! These events will be picked up by the NEAR indexer.
//!
//! <https://github.com/near/NEPs/blob/master/specs/Standards/FungibleToken/Event.md>
//!
//! This is an extension of the events format (nep-297):
//! <https://github.com/near/NEPs/blob/master/specs/Standards/EventsFormat.md>
//!
//! The three events in this standard are [`FtMint`], [`FtTransfer`], and [`FtBurn`].
//!
//! These events can be logged by calling `.emit()` on them if a single event, or calling
//! [`FtMint::emit_many`], [`FtTransfer::emit_many`],
//! or [`FtBurn::emit_many`] respectively.

use near_sdk::json_types::U128;
use near_sdk::AccountId;
use near_sdk::serde::Serialize;

use near_sdk::env;

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]
pub(crate) enum NearEvent<'a> {
    Nep141(Nep141Event<'a>),
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self).ok().unwrap_or_else(|| env::abort())
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub(crate) fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string());
    }
}

/// Data to log for an FT mint event. To log this event, call [`.emit()`](FtMint::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtMint<'a> {
    pub owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtMint<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT mint event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtMint`] represents the data of each mint.
    pub fn emit_many(data: &[FtMint<'_>]) {
        new_141_v1(Nep141EventKind::FtMint(data)).emit()
    }
}

/// Data to log for an FT transfer event. To log this event,
/// call [`.emit()`](FtTransfer::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtTransfer<'a> {
    pub old_owner_id: &'a AccountId,
    pub new_owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtTransfer<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT transfer event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtTransfer`] represents the data of each transfer.
    pub fn emit_many(data: &[FtTransfer<'_>]) {
        new_141_v1(Nep141EventKind::FtTransfer(data)).emit()
    }
}

#[derive(Serialize, Debug)]
pub(crate) struct Nep141Event<'a> {
    version: &'static str,
    #[serde(flatten)]
    event_kind: Nep141EventKind<'a>,
}

#[derive(Serialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
enum Nep141EventKind<'a> {
    FtMint(&'a [FtMint<'a>]),
    FtTransfer(&'a [FtTransfer<'a>]),
}

fn new_141<'a>(version: &'static str, event_kind: Nep141EventKind<'a>) -> NearEvent<'a> {
    NearEvent::Nep141(Nep141Event { version, event_kind })
}

fn new_141_v1(event_kind: Nep141EventKind) -> NearEvent {
    new_141("1.0.0", event_kind)
}
'''
'''--- 4.storage/src/ft_core.rs ---
use near_sdk::{Gas, ext_contract, PromiseOrValue, assert_one_yocto, PromiseResult};

use crate::*;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        /*
            FILL THIS IN
        */
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }

    fn ft_total_supply(&self) -> U128 {
        // Return the total supply casted to a U128
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        // Return the balance of the account casted to a U128
        self.accounts.get(&account_id).unwrap_or(0).into()
    }
}

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    // Finalize an `ft_transfer_call` chain of cross-contract calls.
    //
    // The `ft_transfer_call` process:
    //
    // 1. Sender calls `ft_transfer_call` on FT contract
    // 2. FT contract transfers `amount` tokens from sender to receiver
    // 3. FT contract calls `ft_on_transfer` on receiver contract
    // 4+. [receiver contract may make other cross-contract calls]
    // N. FT contract resolves promise chain with `ft_resolve_transfer`, and may
    //    refund sender some or all of original `amount`
    //
    // Requirements:
    // * Contract MUST forbid calls to this function by any account except self
    // * If promise chain failed, contract MUST revert token transfer
    // * If promise chain resolves with a non-zero amount given as a string,
    //   contract MUST return this amount of tokens to `sender_id`
    //
    // Arguments:
    // * `sender_id`: the sender of `ft_transfer_call`
    // * `receiver_id`: the `receiver_id` argument given to `ft_transfer_call`
    // * `amount`: the `amount` argument given to `ft_transfer_call`
    //
    // Returns a string representing a string version of an unsigned 128-bit
    // integer of how many total tokens were spent by sender_id. Example: if sender
    // calls `ft_transfer_call({ "amount": "100" })`, but `receiver_id` only uses
    // 80, `ft_on_transfer` will resolve with `"20"`, and `ft_resolve_transfer`
    // will return `"80"`.
    #[private]
    pub fn ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        /*
            FILL THIS IN
        */
        todo!(); //remove once code is filled in.
    }
}

'''
'''--- 4.storage/src/internal.rs ---
use near_sdk::{require};

use crate::*;

impl Contract {
    /// Internal method for force getting the balance of an account. If the account doesn't have a balance, panic with a custom message.
    pub(crate) fn internal_unwrap_balance_of(&self, account_id: &AccountId) -> Balance {
        match self.accounts.get(account_id) {
            Some(balance) => balance,
            None => {
                env::panic_str(format!("The account {} is not registered", &account_id).as_str())
            }
        }
    }

    /// Internal method for depositing some amount of FTs into an account. 
    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If they're not registered, panic.
        let balance = self.internal_unwrap_balance_of(account_id);
        
        // Add the amount to the balance and insert the new balance into the accounts map
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("Balance overflow");
        }
    }

    /// Internal method for registering an account with the contract.
    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId) {
        if self.accounts.insert(account_id, &0).is_some() {
            env::panic_str("The account is already registered");
        }
    }

    /// Internal method for measuring how many bytes it takes to insert the longest possible account ID into our map
    /// This will insert the account, measure the storage, and remove the account. It is called in the initialization function.
    pub(crate) fn measure_bytes_for_longest_account_id(&mut self) {
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = AccountId::new_unchecked("a".repeat(64));
        self.accounts.insert(&tmp_account_id, &0u128);
        self.bytes_for_longest_account_id = env::storage_usage() - initial_storage_usage;
        self.accounts.remove(&tmp_account_id);
    }
}
'''
'''--- 4.storage/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, StorageUsage};

pub mod ft_core;
pub mod events;
pub mod metadata;
pub mod storage;
pub mod internal;

use crate::metadata::*;
use crate::events::*;

/// The image URL for the default icon
const DATA_IMAGE_SVG_GT_ICON: &str = "data:image/jpeg;base64,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";

/// The specific version of the standard we're using
pub const FT_METADATA_SPEC: &str = "ft-1.0.0";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Keep track of each account's balances
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of all tokens.
    pub total_supply: Balance,

    /// The bytes for the largest possible account ID that can be registered on the contract 
    pub bytes_for_longest_account_id: StorageUsage,

    /// Metadata for the contract itself
    pub metadata: LazyOption<FungibleTokenMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    Metadata
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        // Calls the other function "new: with some default metadata and the owner_id & total supply passed in 
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Team Token FT Tutorial".to_string(),
                symbol: "gtNEAR".to_string(),
                icon: Some(DATA_IMAGE_SVG_GT_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        // Create a variable of type Self with all the fields initialized. 
        let mut this = Self {
            // Set the total supply
            total_supply: total_supply.0,
            // Set the bytes for the longest account ID to 0 temporarily until it's calculated later
            bytes_for_longest_account_id: 0,
            // Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            accounts: LookupMap::new(StorageKey::Accounts.try_to_vec().unwrap()),
            metadata: LazyOption::new(
                StorageKey::Metadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        };

        // Measure the bytes for the longest account ID and store it in the contract.
        this.measure_bytes_for_longest_account_id();

        // Register the owner's account and set their balance to the total supply.
        this.internal_register_account(&owner_id);
        this.internal_deposit(&owner_id, total_supply.into());
        
        // Emit an event showing that the FTs were minted
        FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial token supply is minted"),
        }
        .emit();

        // Return the Contract object
        this
    }
}
'''
'''--- 4.storage/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen};

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub spec: String, // Should be ft-1.0.0 to indicate that a Fungible Token contract adheres to the current versions of this Metadata and the Fungible Token Core specs. This will allow consumers of the Fungible Token to know if they support the features of a given contract.
    pub name: String, // The human-readable name of the token.
    pub symbol: String, // The abbreviation, like wETH or AMPL.
    pub icon: Option<String>, // Icon of the fungible token.
    pub reference: Option<String>, // A link to a valid JSON file containing various keys offering supplementary details on the token 
    pub reference_hash: Option<Base64VecU8>, // The base64-encoded sha256 hash of the JSON file contained in the reference field. This is to guard against off-chain tampering.
    pub decimals: u8, // used in frontends to show the proper significant digits of a token. This concept is explained well in this OpenZeppelin post. https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals
}

pub trait FungibleTokenMetadataProvider {
    // View call for returning the contract metadata
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- 4.storage/src/storage.rs ---
use near_sdk::json_types::U128;
use near_sdk::{env, log, AccountId, Balance, Promise};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;

// The structure that will be returned for the methods:
// * `storage_deposit`
// * `storage_withdraw`
// * `storage_balance_of`
// The `total` and `available` values are string representations of unsigned
// 128-bit integers showing the balance of a specific account in yoctoⓃ.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// The below structure will be returned for the method `storage_balance_bounds`.
// Both `min` and `max` are string representations of unsigned 128-bit integers.
//
// `min` is the amount of tokens required to start using this contract at all
// (eg to register with the contract). If a new contract user attaches `min`
// NEAR to a `storage_deposit` call, subsequent calls to `storage_balance_of`
// for this user must show their `total` equal to `min` and `available=0` .
//
// A contract may implement `max` equal to `min` if it only charges for initial
// registration, and does not adjust per-user storage over time. A contract
// which implements `max` must refund deposits that would increase a user's
// storage balance beyond this amount.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    /************************************/
    /* CHANGE METHODS on fungible token */
    /************************************/
    // Payable method that receives an attached deposit of Ⓝ for a given account.
    //
    // If `account_id` is omitted, the deposit MUST go toward predecessor account.
    // If provided, deposit MUST go toward this account. If invalid, contract MUST
    // panic.
    //
    // If `registration_only=true`, contract MUST refund above the minimum balance
    // if the account wasn't registered and refund full deposit if already
    // registered.
    //
    // The `storage_balance_of.total` + `attached_deposit` in excess of
    // `storage_balance_bounds.max` must be refunded to predecessor account.
    //
    // Returns the StorageBalance structure showing updated balances.
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /****************/
    /* VIEW METHODS */
    /****************/
    // Returns minimum and maximum allowed balance amounts to interact with this
    // contract. See StorageBalanceBounds.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    // Returns the StorageBalance structure of the valid `account_id`
    // provided. Must panic if `account_id` is invalid.
    //
    // If `account_id` is not registered, must return `null`.
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance>;
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[allow(unused_variables)]
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        // Get the amount of $NEAR to deposit
        let amount: Balance = env::attached_deposit();
        // If an account was specified, use that. Otherwise, use the predecessor account.
        let account_id = account_id.unwrap_or_else(env::predecessor_account_id);
        
        // If the account is already registered, refund the deposit.
        if self.accounts.contains_key(&account_id) {
            log!("The account is already registered, refunding the deposit");
            if amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } 
        // Register the account and refund any excess $NEAR
        } else {
            // Get the minimum required storage and ensure the deposit is at least that amount
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic_str("The attached deposit is less than the minimum storage balance");
            }

            // Register the account
            self.internal_register_account(&account_id);
            // Perform a refund
            let refund = amount - min_balance;
            if refund > 0 {
                Promise::new(env::predecessor_account_id()).transfer(refund);
            }
        }

        // Return the storage balance of the account
        StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        // Calculate the required storage balance by taking the bytes for the longest account ID and multiplying by the current byte cost
        let required_storage_balance =
            Balance::from(self.bytes_for_longest_account_id) * env::storage_byte_cost();
        
        // Storage balance bounds will have min == max == required_storage_balance
        StorageBalanceBounds {
            min: required_storage_balance.into(),
            max: Some(required_storage_balance.into()),
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        // Get the storage balance of the account. Available will always be 0 since you can't overpay for storage.
        if self.accounts.contains_key(&account_id) {
            Some(StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() })
        } else {
            None
        }
    }
}

'''
'''--- 5.transfers/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = "1"
serde_json = "1"
'''
'''--- 5.transfers/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ../out/contract.wasm
'''
'''--- 5.transfers/src/events.rs ---
//! Standard for nep141 (Fungible Token) events.
//!
//! These events will be picked up by the NEAR indexer.
//!
//! <https://github.com/near/NEPs/blob/master/specs/Standards/FungibleToken/Event.md>
//!
//! This is an extension of the events format (nep-297):
//! <https://github.com/near/NEPs/blob/master/specs/Standards/EventsFormat.md>
//!
//! The three events in this standard are [`FtMint`], [`FtTransfer`], and [`FtBurn`].
//!
//! These events can be logged by calling `.emit()` on them if a single event, or calling
//! [`FtMint::emit_many`], [`FtTransfer::emit_many`],
//! or [`FtBurn::emit_many`] respectively.

use near_sdk::json_types::U128;
use near_sdk::AccountId;
use near_sdk::serde::Serialize;

use near_sdk::env;

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]
pub(crate) enum NearEvent<'a> {
    Nep141(Nep141Event<'a>),
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self).ok().unwrap_or_else(|| env::abort())
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub(crate) fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string());
    }
}

/// Data to log for an FT mint event. To log this event, call [`.emit()`](FtMint::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtMint<'a> {
    pub owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtMint<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT mint event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtMint`] represents the data of each mint.
    pub fn emit_many(data: &[FtMint<'_>]) {
        new_141_v1(Nep141EventKind::FtMint(data)).emit()
    }
}

/// Data to log for an FT transfer event. To log this event,
/// call [`.emit()`](FtTransfer::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtTransfer<'a> {
    pub old_owner_id: &'a AccountId,
    pub new_owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtTransfer<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT transfer event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtTransfer`] represents the data of each transfer.
    pub fn emit_many(data: &[FtTransfer<'_>]) {
        new_141_v1(Nep141EventKind::FtTransfer(data)).emit()
    }
}

#[derive(Serialize, Debug)]
pub(crate) struct Nep141Event<'a> {
    version: &'static str,
    #[serde(flatten)]
    event_kind: Nep141EventKind<'a>,
}

#[derive(Serialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
enum Nep141EventKind<'a> {
    FtMint(&'a [FtMint<'a>]),
    FtTransfer(&'a [FtTransfer<'a>]),
}

fn new_141<'a>(version: &'static str, event_kind: Nep141EventKind<'a>) -> NearEvent<'a> {
    NearEvent::Nep141(Nep141Event { version, event_kind })
}

fn new_141_v1(event_kind: Nep141EventKind) -> NearEvent {
    new_141("1.0.0", event_kind)
}
'''
'''--- 5.transfers/src/ft_core.rs ---
use near_sdk::{Gas, ext_contract, PromiseOrValue, assert_one_yocto, PromiseResult};

use crate::*;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        // Assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be required to sign with a FAK.
        assert_one_yocto();
        // The sender is the user who called the method
        let sender_id = env::predecessor_account_id();
        // How many tokens the user wants to withdraw
        let amount: Balance = amount.into();
        // Transfer the tokens
        self.internal_transfer(&sender_id, &receiver_id, amount, memo);
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        // Assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be required to sign with a FAK.
        assert_one_yocto();
        // The sender is the user who called the method
        let sender_id = env::predecessor_account_id();
        // How many tokens the sender wants to transfer
        let amount: Balance = amount.into();
        // Transfer the tokens
        self.internal_transfer(&sender_id, &receiver_id, amount, memo);

        // Initiating receiver's call and the callback
        // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for ft transfer call.
        ext_ft_receiver::ext(receiver_id.clone())
            .with_static_gas(GAS_FOR_FT_TRANSFER_CALL)
            .ft_on_transfer(sender_id.clone(), amount.into(), msg)
            // We then resolve the promise and call ft_resolve_transfer on our own contract
            // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for resolve transfer
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    .ft_resolve_transfer(&sender_id, receiver_id, amount.into()),
            )
            .into()
    }

    fn ft_total_supply(&self) -> U128 {
        // Return the total supply casted to a U128
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        // Return the balance of the account casted to a U128
        self.accounts.get(&account_id).unwrap_or(0).into()
    }
}

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    // Finalize an `ft_transfer_call` chain of cross-contract calls.
    //
    // The `ft_transfer_call` process:
    //
    // 1. Sender calls `ft_transfer_call` on FT contract
    // 2. FT contract transfers `amount` tokens from sender to receiver
    // 3. FT contract calls `ft_on_transfer` on receiver contract
    // 4+. [receiver contract may make other cross-contract calls]
    // N. FT contract resolves promise chain with `ft_resolve_transfer`, and may
    //    refund sender some or all of original `amount`
    //
    // Requirements:
    // * Contract MUST forbid calls to this function by any account except self
    // * If promise chain failed, contract MUST revert token transfer
    // * If promise chain resolves with a non-zero amount given as a string,
    //   contract MUST return this amount of tokens to `sender_id`
    //
    // Arguments:
    // * `sender_id`: the sender of `ft_transfer_call`
    // * `receiver_id`: the `receiver_id` argument given to `ft_transfer_call`
    // * `amount`: the `amount` argument given to `ft_transfer_call`
    //
    // Returns a string representing a string version of an unsigned 128-bit
    // integer of how many total tokens were spent by sender_id. Example: if sender
    // calls `ft_transfer_call({ "amount": "100" })`, but `receiver_id` only uses
    // 80, `ft_on_transfer` will resolve with `"20"`, and `ft_resolve_transfer`
    // will return `"80"`.
    #[private]
    pub fn ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            // If the promise was successful, get the return value and cast it to a U128.
            PromiseResult::Successful(value) => {
                // If we can properly parse the value, the unused amount is equal to whatever is smaller - the unused amount or the original amount (to prevent malicious contracts)
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                // If we can't properly parse the value, the original amount is returned.
                } else {
                    amount
                }
            }
            // If the promise wasn't successful, return the original amount.
            PromiseResult::Failed => amount,
        };

        // If there is some unused amount, we should refund the sender
        if unused_amount > 0 {
            // Get the receiver's balance. We can only refund the sender if the receiver has enough balance.
            let receiver_balance = self.accounts.get(&receiver_id).unwrap_or(0);
            if receiver_balance > 0 {
                // The amount to refund is the smaller of the unused amount and the receiver's balance as we can only refund up to what the receiver currently has.
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                
                // Refund the sender for the unused amount.
                self.internal_transfer(&receiver_id, &sender_id, refund_amount, Some("Refund".to_string()));
                
                // Return what was actually used (the amount sent - refund)
                let used_amount = amount
                    .checked_sub(refund_amount)
                    .unwrap_or_else(|| env::panic_str("Total supply overflow"));
                return used_amount.into();
            }
        }

        // If the unused amount is 0, return the original amount.
        amount.into()
    }
}

'''
'''--- 5.transfers/src/internal.rs ---
use near_sdk::{require};

use crate::*;

impl Contract {
    /// Internal method for force getting the balance of an account. If the account doesn't have a balance, panic with a custom message.
    pub(crate) fn internal_unwrap_balance_of(&self, account_id: &AccountId) -> Balance {
        match self.accounts.get(account_id) {
            Some(balance) => balance,
            None => {
                env::panic_str(format!("The account {} is not registered", &account_id).as_str())
            }
        }
    }

    /// Internal method for depositing some amount of FTs into an account. 
    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If they're not registered, panic.
        let balance = self.internal_unwrap_balance_of(account_id);
        
        // Add the amount to the balance and insert the new balance into the accounts map
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("Balance overflow");
        }
    }

    /// Internal method for withdrawing some amount of FTs from an account. 
    pub(crate) fn internal_withdraw(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If they're not registered, panic.
        let balance = self.internal_unwrap_balance_of(account_id);
        
        // Decrease the amount from the balance and insert the new balance into the accounts map
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("The account doesn't have enough balance");
        }
    }

    /// Internal method for performing a transfer of FTs from one account to another.
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: Option<String>,
    ) {
        // Ensure the sender can't transfer to themselves
        require!(sender_id != receiver_id, "Sender and receiver should be different");
        // Ensure the sender can't transfer 0 tokens
        require!(amount > 0, "The amount should be a positive number");
        
        // Withdraw from the sender and deposit into the receiver
        self.internal_withdraw(sender_id, amount);
        self.internal_deposit(receiver_id, amount);
        
        // Emit a Transfer event
        FtTransfer {
            old_owner_id: sender_id,
            new_owner_id: receiver_id,
            amount: &U128(amount),
            memo: memo.as_deref(),
        }
        .emit();
    }

    /// Internal method for registering an account with the contract.
    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId) {
        if self.accounts.insert(account_id, &0).is_some() {
            env::panic_str("The account is already registered");
        }
    }

    /// Internal method for measuring how many bytes it takes to insert the longest possible account ID into our map
    /// This will insert the account, measure the storage, and remove the account. It is called in the initialization function.
    pub(crate) fn measure_bytes_for_longest_account_id(&mut self) {
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = AccountId::new_unchecked("a".repeat(64));
        self.accounts.insert(&tmp_account_id, &0u128);
        self.bytes_for_longest_account_id = env::storage_usage() - initial_storage_usage;
        self.accounts.remove(&tmp_account_id);
    }
}
'''
'''--- 5.transfers/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, StorageUsage};

pub mod ft_core;
pub mod events;
pub mod metadata;
pub mod storage;
pub mod internal;

use crate::metadata::*;
use crate::events::*;

/// The image URL for the default icon
const DATA_IMAGE_SVG_GT_ICON: &str = "data:image/jpeg;base64,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";

/// The specific version of the standard we're using
pub const FT_METADATA_SPEC: &str = "ft-1.0.0";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Keep track of each account's balances
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of all tokens.
    pub total_supply: Balance,

    /// The bytes for the largest possible account ID that can be registered on the contract 
    pub bytes_for_longest_account_id: StorageUsage,

    /// Metadata for the contract itself
    pub metadata: LazyOption<FungibleTokenMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    Metadata
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        // Calls the other function "new: with some default metadata and the owner_id & total supply passed in 
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Team Token FT Tutorial".to_string(),
                symbol: "gtNEAR".to_string(),
                icon: Some(DATA_IMAGE_SVG_GT_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        // Create a variable of type Self with all the fields initialized. 
        let mut this = Self {
            // Set the total supply
            total_supply: total_supply.0,
            // Set the bytes for the longest account ID to 0 temporarily until it's calculated later
            bytes_for_longest_account_id: 0,
            // Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            accounts: LookupMap::new(StorageKey::Accounts.try_to_vec().unwrap()),
            metadata: LazyOption::new(
                StorageKey::Metadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        };

        // Measure the bytes for the longest account ID and store it in the contract.
        this.measure_bytes_for_longest_account_id();

        // Register the owner's account and set their balance to the total supply.
        this.internal_register_account(&owner_id);
        this.internal_deposit(&owner_id, total_supply.into());
        
        // Emit an event showing that the FTs were minted
        FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial token supply is minted"),
        }
        .emit();

        // Return the Contract object
        this
    }
}
'''
'''--- 5.transfers/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen};

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub spec: String, // Should be ft-1.0.0 to indicate that a Fungible Token contract adheres to the current versions of this Metadata and the Fungible Token Core specs. This will allow consumers of the Fungible Token to know if they support the features of a given contract.
    pub name: String, // The human-readable name of the token.
    pub symbol: String, // The abbreviation, like wETH or AMPL.
    pub icon: Option<String>, // Icon of the fungible token.
    pub reference: Option<String>, // A link to a valid JSON file containing various keys offering supplementary details on the token 
    pub reference_hash: Option<Base64VecU8>, // The base64-encoded sha256 hash of the JSON file contained in the reference field. This is to guard against off-chain tampering.
    pub decimals: u8, // used in frontends to show the proper significant digits of a token. This concept is explained well in this OpenZeppelin post. https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals
}

pub trait FungibleTokenMetadataProvider {
    // View call for returning the contract metadata
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- 5.transfers/src/storage.rs ---
use near_sdk::json_types::U128;
use near_sdk::{env, log, AccountId, Balance, Promise};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;

// The structure that will be returned for the methods:
// * `storage_deposit`
// * `storage_withdraw`
// * `storage_balance_of`
// The `total` and `available` values are string representations of unsigned
// 128-bit integers showing the balance of a specific account in yoctoⓃ.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// The below structure will be returned for the method `storage_balance_bounds`.
// Both `min` and `max` are string representations of unsigned 128-bit integers.
//
// `min` is the amount of tokens required to start using this contract at all
// (eg to register with the contract). If a new contract user attaches `min`
// NEAR to a `storage_deposit` call, subsequent calls to `storage_balance_of`
// for this user must show their `total` equal to `min` and `available=0` .
//
// A contract may implement `max` equal to `min` if it only charges for initial
// registration, and does not adjust per-user storage over time. A contract
// which implements `max` must refund deposits that would increase a user's
// storage balance beyond this amount.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    /************************************/
    /* CHANGE METHODS on fungible token */
    /************************************/
    // Payable method that receives an attached deposit of Ⓝ for a given account.
    //
    // If `account_id` is omitted, the deposit MUST go toward predecessor account.
    // If provided, deposit MUST go toward this account. If invalid, contract MUST
    // panic.
    //
    // If `registration_only=true`, contract MUST refund above the minimum balance
    // if the account wasn't registered and refund full deposit if already
    // registered.
    //
    // The `storage_balance_of.total` + `attached_deposit` in excess of
    // `storage_balance_bounds.max` must be refunded to predecessor account.
    //
    // Returns the StorageBalance structure showing updated balances.
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /****************/
    /* VIEW METHODS */
    /****************/
    // Returns minimum and maximum allowed balance amounts to interact with this
    // contract. See StorageBalanceBounds.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    // Returns the StorageBalance structure of the valid `account_id`
    // provided. Must panic if `account_id` is invalid.
    //
    // If `account_id` is not registered, must return `null`.
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance>;
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[allow(unused_variables)]
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        // Get the amount of $NEAR to deposit
        let amount: Balance = env::attached_deposit();
        // If an account was specified, use that. Otherwise, use the predecessor account.
        let account_id = account_id.unwrap_or_else(env::predecessor_account_id);
        
        // If the account is already registered, refund the deposit.
        if self.accounts.contains_key(&account_id) {
            log!("The account is already registered, refunding the deposit");
            if amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } 
        // Register the account and refund any excess $NEAR
        } else {
            // Get the minimum required storage and ensure the deposit is at least that amount
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic_str("The attached deposit is less than the minimum storage balance");
            }

            // Register the account
            self.internal_register_account(&account_id);
            // Perform a refund
            let refund = amount - min_balance;
            if refund > 0 {
                Promise::new(env::predecessor_account_id()).transfer(refund);
            }
        }

        // Return the storage balance of the account
        StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        // Calculate the required storage balance by taking the bytes for the longest account ID and multiplying by the current byte cost
        let required_storage_balance =
            Balance::from(self.bytes_for_longest_account_id) * env::storage_byte_cost();
        
        // Storage balance bounds will have min == max == required_storage_balance
        StorageBalanceBounds {
            min: required_storage_balance.into(),
            max: Some(required_storage_balance.into()),
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        // Get the storage balance of the account. Available will always be 0 since you can't overpay for storage.
        if self.accounts.contains_key(&account_id) {
            Some(StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() })
        } else {
            None
        }
    }
}

'''
'''--- finished-contract/Cargo.toml ---
[package]
name = "fungible-token"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"
serde = "1"
serde_json = "1"
'''
'''--- finished-contract/build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ../out/contract.wasm
'''
'''--- finished-contract/src/events.rs ---
//! Standard for nep141 (Fungible Token) events.
//!
//! These events will be picked up by the NEAR indexer.
//!
//! <https://github.com/near/NEPs/blob/master/specs/Standards/FungibleToken/Event.md>
//!
//! This is an extension of the events format (nep-297):
//! <https://github.com/near/NEPs/blob/master/specs/Standards/EventsFormat.md>
//!
//! The three events in this standard are [`FtMint`], [`FtTransfer`], and [`FtBurn`].
//!
//! These events can be logged by calling `.emit()` on them if a single event, or calling
//! [`FtMint::emit_many`], [`FtTransfer::emit_many`],
//! or [`FtBurn::emit_many`] respectively.

use near_sdk::json_types::U128;
use near_sdk::AccountId;
use near_sdk::serde::Serialize;

use near_sdk::env;

#[derive(Serialize, Debug)]
#[serde(tag = "standard")]
#[must_use = "don't forget to `.emit()` this event"]
#[serde(rename_all = "snake_case")]
pub(crate) enum NearEvent<'a> {
    Nep141(Nep141Event<'a>),
}

impl<'a> NearEvent<'a> {
    fn to_json_string(&self) -> String {
        // Events cannot fail to serialize so fine to panic on error
        #[allow(clippy::redundant_closure)]
        serde_json::to_string(self).ok().unwrap_or_else(|| env::abort())
    }

    fn to_json_event_string(&self) -> String {
        format!("EVENT_JSON:{}", self.to_json_string())
    }

    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub(crate) fn emit(self) {
        near_sdk::env::log_str(&self.to_json_event_string());
    }
}

/// Data to log for an FT mint event. To log this event, call [`.emit()`](FtMint::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtMint<'a> {
    pub owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtMint<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT mint event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtMint`] represents the data of each mint.
    pub fn emit_many(data: &[FtMint<'_>]) {
        new_141_v1(Nep141EventKind::FtMint(data)).emit()
    }
}

/// Data to log for an FT transfer event. To log this event,
/// call [`.emit()`](FtTransfer::emit).
#[must_use]
#[derive(Serialize, Debug, Clone)]
pub struct FtTransfer<'a> {
    pub old_owner_id: &'a AccountId,
    pub new_owner_id: &'a AccountId,
    pub amount: &'a U128,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub memo: Option<&'a str>,
}

impl FtTransfer<'_> {
    /// Logs the event to the host. This is required to ensure that the event is triggered
    /// and to consume the event.
    pub fn emit(self) {
        Self::emit_many(&[self])
    }

    /// Emits an FT transfer event, through [`env::log_str`](near_sdk::env::log_str),
    /// where each [`FtTransfer`] represents the data of each transfer.
    pub fn emit_many(data: &[FtTransfer<'_>]) {
        new_141_v1(Nep141EventKind::FtTransfer(data)).emit()
    }
}

#[derive(Serialize, Debug)]
pub(crate) struct Nep141Event<'a> {
    version: &'static str,
    #[serde(flatten)]
    event_kind: Nep141EventKind<'a>,
}

#[derive(Serialize, Debug)]
#[serde(tag = "event", content = "data")]
#[serde(rename_all = "snake_case")]
#[allow(clippy::enum_variant_names)]
enum Nep141EventKind<'a> {
    FtMint(&'a [FtMint<'a>]),
    FtTransfer(&'a [FtTransfer<'a>]),
}

fn new_141<'a>(version: &'static str, event_kind: Nep141EventKind<'a>) -> NearEvent<'a> {
    NearEvent::Nep141(Nep141Event { version, event_kind })
}

fn new_141_v1(event_kind: Nep141EventKind) -> NearEvent {
    new_141("1.0.0", event_kind)
}
'''
'''--- finished-contract/src/ft_core.rs ---
use near_sdk::{Gas, ext_contract, PromiseOrValue, assert_one_yocto, PromiseResult};

use crate::*;

const GAS_FOR_RESOLVE_TRANSFER: Gas = Gas(5_000_000_000_000);
const GAS_FOR_FT_TRANSFER_CALL: Gas = Gas(25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER.0);

#[ext_contract(ext_ft_core)]
pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128>;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: AccountId) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for Contract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>) {
        // Assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be required to sign with a FAK.
        assert_one_yocto();
        // The sender is the user who called the method
        let sender_id = env::predecessor_account_id();
        // How many tokens the user wants to withdraw
        let amount: Balance = amount.into();
        // Transfer the tokens
        self.internal_transfer(&sender_id, &receiver_id, amount, memo);
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: AccountId,
        amount: U128,
        memo: Option<String>,
        msg: String,
    ) -> PromiseOrValue<U128> {
        // Assert that the user attached exactly 1 yoctoNEAR. This is for security and so that the user will be required to sign with a FAK.
        assert_one_yocto();
        // The sender is the user who called the method
        let sender_id = env::predecessor_account_id();
        // How many tokens the sender wants to transfer
        let amount: Balance = amount.into();
        // Transfer the tokens
        self.internal_transfer(&sender_id, &receiver_id, amount, memo);

        // Initiating receiver's call and the callback
        // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for ft transfer call.
        ext_ft_receiver::ext(receiver_id.clone())
            .with_static_gas(GAS_FOR_FT_TRANSFER_CALL)
            .ft_on_transfer(sender_id.clone(), amount.into(), msg)
            // We then resolve the promise and call ft_resolve_transfer on our own contract
            // Defaulting GAS weight to 1, no attached deposit, and static GAS equal to the GAS for resolve transfer
            .then(
                Self::ext(env::current_account_id())
                    .with_static_gas(GAS_FOR_RESOLVE_TRANSFER)
                    .ft_resolve_transfer(&sender_id, receiver_id, amount.into()),
            )
            .into()
    }

    fn ft_total_supply(&self) -> U128 {
        // Return the total supply casted to a U128
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: AccountId) -> U128 {
        // Return the balance of the account casted to a U128
        self.accounts.get(&account_id).unwrap_or(0).into()
    }
}

#[ext_contract(ext_ft_receiver)]
pub trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String,
    ) -> PromiseOrValue<U128>;
}

#[near_bindgen]
impl Contract {
    // Finalize an `ft_transfer_call` chain of cross-contract calls.
    //
    // The `ft_transfer_call` process:
    //
    // 1. Sender calls `ft_transfer_call` on FT contract
    // 2. FT contract transfers `amount` tokens from sender to receiver
    // 3. FT contract calls `ft_on_transfer` on receiver contract
    // 4+. [receiver contract may make other cross-contract calls]
    // N. FT contract resolves promise chain with `ft_resolve_transfer`, and may
    //    refund sender some or all of original `amount`
    //
    // Requirements:
    // * Contract MUST forbid calls to this function by any account except self
    // * If promise chain failed, contract MUST revert token transfer
    // * If promise chain resolves with a non-zero amount given as a string,
    //   contract MUST return this amount of tokens to `sender_id`
    //
    // Arguments:
    // * `sender_id`: the sender of `ft_transfer_call`
    // * `receiver_id`: the `receiver_id` argument given to `ft_transfer_call`
    // * `amount`: the `amount` argument given to `ft_transfer_call`
    //
    // Returns a string representing a string version of an unsigned 128-bit
    // integer of how many total tokens were spent by sender_id. Example: if sender
    // calls `ft_transfer_call({ "amount": "100" })`, but `receiver_id` only uses
    // 80, `ft_on_transfer` will resolve with `"20"`, and `ft_resolve_transfer`
    // will return `"80"`.
    #[private]
    pub fn ft_resolve_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            // If the promise was successful, get the return value and cast it to a U128.
            PromiseResult::Successful(value) => {
                // If we can properly parse the value, the unused amount is equal to whatever is smaller - the unused amount or the original amount (to prevent malicious contracts)
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                // If we can't properly parse the value, the original amount is returned.
                } else {
                    amount
                }
            }
            // If the promise wasn't successful, return the original amount.
            PromiseResult::Failed => amount,
        };

        // If there is some unused amount, we should refund the sender
        if unused_amount > 0 {
            // Get the receiver's balance. We can only refund the sender if the receiver has enough balance.
            let receiver_balance = self.accounts.get(&receiver_id).unwrap_or(0);
            if receiver_balance > 0 {
                // The amount to refund is the smaller of the unused amount and the receiver's balance as we can only refund up to what the receiver currently has.
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                
                // Refund the sender for the unused amount.
                self.internal_transfer(&receiver_id, &sender_id, refund_amount, Some("Refund".to_string()));
                
                // Return what was actually used (the amount sent - refund)
                let used_amount = amount
                    .checked_sub(refund_amount)
                    .unwrap_or_else(|| env::panic_str("Total supply overflow"));
                return used_amount.into();
            }
        }

        // If the unused amount is 0, return the original amount.
        amount.into()
    }
}

'''
'''--- finished-contract/src/internal.rs ---
use near_sdk::{require};

use crate::*;

impl Contract {
    /// Internal method for force getting the balance of an account. If the account doesn't have a balance, panic with a custom message.
    pub(crate) fn internal_unwrap_balance_of(&self, account_id: &AccountId) -> Balance {
        match self.accounts.get(account_id) {
            Some(balance) => balance,
            None => {
                env::panic_str(format!("The account {} is not registered", &account_id).as_str())
            }
        }
    }

    /// Internal method for depositing some amount of FTs into an account. 
    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If they're not registered, panic.
        let balance = self.internal_unwrap_balance_of(account_id);
        
        // Add the amount to the balance and insert the new balance into the accounts map
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("Balance overflow");
        }
    }

    /// Internal method for withdrawing some amount of FTs from an account. 
    pub(crate) fn internal_withdraw(&mut self, account_id: &AccountId, amount: Balance) {
        // Get the current balance of the account. If they're not registered, panic.
        let balance = self.internal_unwrap_balance_of(account_id);
        
        // Decrease the amount from the balance and insert the new balance into the accounts map
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.accounts.insert(account_id, &new_balance);
        } else {
            env::panic_str("The account doesn't have enough balance");
        }
    }

    /// Internal method for performing a transfer of FTs from one account to another.
    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: Option<String>,
    ) {
        // Ensure the sender can't transfer to themselves
        require!(sender_id != receiver_id, "Sender and receiver should be different");
        // Ensure the sender can't transfer 0 tokens
        require!(amount > 0, "The amount should be a positive number");
        
        // Withdraw from the sender and deposit into the receiver
        self.internal_withdraw(sender_id, amount);
        self.internal_deposit(receiver_id, amount);
        
        // Emit a Transfer event
        FtTransfer {
            old_owner_id: sender_id,
            new_owner_id: receiver_id,
            amount: &U128(amount),
            memo: memo.as_deref(),
        }
        .emit();
    }

    /// Internal method for registering an account with the contract.
    pub(crate) fn internal_register_account(&mut self, account_id: &AccountId) {
        if self.accounts.insert(account_id, &0).is_some() {
            env::panic_str("The account is already registered");
        }
    }

    /// Internal method for measuring how many bytes it takes to insert the longest possible account ID into our map
    /// This will insert the account, measure the storage, and remove the account. It is called in the initialization function.
    pub(crate) fn measure_bytes_for_longest_account_id(&mut self) {
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = AccountId::new_unchecked("a".repeat(64));
        self.accounts.insert(&tmp_account_id, &0u128);
        self.bytes_for_longest_account_id = env::storage_usage() - initial_storage_usage;
        self.accounts.remove(&tmp_account_id);
    }
}
'''
'''--- finished-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, LookupMap};
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, PanicOnDefault, StorageUsage};

pub mod ft_core;
pub mod events;
pub mod metadata;
pub mod storage;
pub mod internal;

use crate::metadata::*;
use crate::events::*;

/// The image URL for the default icon
const DATA_IMAGE_SVG_GT_ICON: &str = "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/2wCEABwcHBwcHDAcHDBEMDAwRFxEREREXHRcXFxcXHSMdHR0dHR0jIyMjIyMjIyoqKioqKjExMTExNzc3Nzc3Nzc3NwBIiQkODQ4YDQ0YOacgJzm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5ubm5v/CABEIAUsB8gMBIgACEQEDEQH/xAAaAAEBAQEBAQEAAAAAAAAAAAAAAQIDBAUG/9oACAEBAAAAAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQoAAAAIUAQAoTNzHTcgAAEoQKBAAFTnnrtnXRyACAABGhAAAOeeuunTWr53KAAAIsE2AEKgGNXXTpenfj58cgAQBKSmgAACVrGuu726Z4cuMCABKEpNgAAC76+Z13rvvn5ZzyCEKlJQGgALQCejyZ16+WfV18eJAEBAEo0BbCgDN6eaX6HDl6u/lxIEIAiBLGxY0AATo4S/Q1z308vXzYASAJEqDoBQACb7eSX2bnS8XnyBIBIQEdgAAAvo8eL6O/Ptq8vNAZBEghKjtQUiglDv5Ma7dbvXDGAiERECAdFVQoAHThi9fRno8hEEiEEAF0soUJRQ1iXt3uc+YhEiIAAHQAVLBYG2c9PRq8PMEkJZQAA6ipZSUiovPPXDfTt28XESTLUIpALFdxRFixZUXhntTt36eDjoSYtJCoAZ09AKIsssqMc2u3XPTtv53K0kiwypADOnoBUBZZM5zldb9W51fN7YkRmkQM0APQFsBUxztZkq69Tvw4bZlmc1JcrIAB6c6ttYK048bOhiyw68+vHruY1JJckJAAPTNVrV5S1vn5prPSyQ9XLi5+rE10wY7c4lyiZpYB6JutavGatvlxbL057w36O3z+d9GdSxnPVzsSX1eXkqwDtOtbt4TdPEvXM7c2ue+vq+fjr6OFWa5zpcZWTfu8nmliwHWdpnd6+adbnHmrqx2zjrnPp7+Hl29Xmpbnn1sxLHT1+LnElgOk7Sdo4usnLjuOnPtvdk138PLfRKtcemmJWevbySWSQG3bV6Seedda8eNJrPXp2XWe/i8+tpba471c50nXp5AmZBe021UxN2ebOtZ9/1vL8zvb6vF39k4fJ1Zq1x1uaxTp3xnz25mcxbsKFuOeXSfufn/R/OeH6uPDrr97p8L5P2uXyO31+Xx/rc/V4PofHGvZ0vh5CTnLdABcZS9f23571fK+v39n5/zX6/q/IfpOvt/NfVx9X8n+m8P0vm/T/P/Njp7ZL4JbLMYnZKoHCF6/tfl9Pj/a4/Q+N4+X2/V+O/W9u3wPL9P635j9D8n7XxPu/A+bma9XWY8+ahOE7pVA4SXW/23wfu/A+lx+h8bwPs+r8X+w4ef5/2H0/zH6H5P2vifd+B83PPp6tXfm52SacM5pKRaLc/uPF7vge7fs+D5+f2vV+L/V31fA+x5vr/AJf9F8j7XxPu/n/mZ5du3ezhCZ1rE5yVQOU336Xr9Dz+Pn9jl8btn19fk+v6nP4f0PVv5P0/F7vB9D5/n15fTvvvPCiWr5SoNLz6+mznz93o+XmYskuvVjyVszjGtbrjN99Yb16POF+aNNa755T0fRz5+Ens9Xz8cVyq+nfga0Yzhvr0xKbl1r2eIV8yu+d9efTjyn0vX5OOT1evx+flblV9N8V1TGM67X0eeddYsXfs8cK//8QAFwEBAQEBAAAAAAAAAAAAAAAAAAECA//aAAgBAhAAAADAAAAAFgAAAAFgoIpAFAIoAZS2gAIFSiSS6oCBYACXJopAFgADJaACoAEXKaoChchAFyaBQCAAlytKACJSUCTRQKSsiVKVmNFAsUygNJSSyqAUyixoi51AFlsUyBSE1CWUmhSQFJE0JQlUICmpmXckoiTRSApoc+koMzJS6gSmhz6SgzJFGgEmpUsoqGSVdwlwsztZFKhDOl//xAAXAQEBAQEAAAAAAAAAAAAAAAAAAQID/9oACAEDEAAAANAAAAAAAAAAAAAWAAIogspqpkIFEoALq2YgAAAFrVmIAACgLOkucywAFJRGrNkwQATQAK1ZiAANAANXOSLADQAWLrOSVKgNAFVZpjIlQDQDWkDWpOUEWCga1dSRdLHAJYKlG7akatS8szWZULKLpdSTV0ubnkuRCg1bw3uZxves2JNMkig6RxHbjvAOs1ZDOdA6JxL146yDvlRGIK6Jk3rGLuIsmguMUs6RbdRx101Oa5lXOrj/xAA8EAACAgEBBQQIBAUEAgMAAAAAAQIRAyEEBRASMRMgQVEiMDIzNEBxcmGBscEUFSNCUFJTodFDkWKA4f/aAAgBAQABPwD/AOi9ll/5puhTVjlb04piaZy2OLj/AJZuhsSsSOU5Ds2KDRG71G09GU185ZfzEnbErZVCEhLgkchOLTseqGvl7+da1Ix8eCFxiUqJwtMa0K0+Sv8AwUo+Il6PBEUMRFCY2NDH3n/jW9KFFLFb68E0RaE7ItIi0fQl0JSfQsfX/B18gmTdRGxkZakFaJ6MjKV6EMj8TqZFUiyvU0UUUUUV8rRXrXd0iulmV6UUzVdSJjXoGSLshFqRya2hIy+1oRher0Gqdd6ivVUUV69fIf3JkVzToy9SihLUxP0aJRTOSiK4TrtBxSjZL5K/kK+QfQwv0kZorrxi0nqQmktSTtWiMrI0NnJbcmQdwaJdfU33771l8b+Zi6kjJ0ofBK2R6UyKVUinFkX4jdiVqifLjVIbv1tl92/8B4k9V+Q0WhNITQpUcykQ6DO1km6Jycnb9ZfyNnMcxZZZZZZfr5PQZQkR6kUvElGtUReg3p3bL4ssvjZZfzdlllllllllllid6FajVCIVZSHqjoTdQL71l8LLL/xcOo3qSdoTEyMtBM6md1USyy2Wyyyyyyyyyyyyyyyyyyyyyyyy/WL1KH3JtroQnLmJO+CExNkdRGd3P1F/JWWWWX8o+LZJ2xaOxFWOLEiERLhkdyZfqF8mvlUPhaRKV9OMXRF2VY0RI8JP+q0iUWmLuP1t/PcyQ5N9C2PU6dyLoxyUtBxo6EOhknyRZC+e2PUcSuL+dr1K4yn4IcmJ3wa4NC7kZNO0Rz37SJTizHOLVWZpczpCpPXjLQjqteDSorxGLu0V8g+CRRRRRy92iikTklouFCdPjVo6dRrxQnfUorhZGHNG2xS5ZF3qZLshNNU+vCStEPIY+hB+BKPiL5Z91cPAfcXDJKlXmPrwRLQi7QxPwJITGvFEX5kMcX1MuLkf4DR2kkqR1ZFUiSOTTQUmtJcFoyR4EfaOo1XqWX6xsXXuLg+gxcVwySuZLqRHoNWjH5DHoLVDQmUupFk1z42vFH4DIK5cJasXFdSXQXQS1ESVruvhV6GPBGa66mSDhJxfgMXq5dRMXGOvDwJuiPFEnUWzxsYirXCOkhjIsaHoJ6EeiZB6EvaYzBHmdLxMuKWJq/EfXuLrwWloQuEuvdRFamLQ2jXKyvWSF1EOSRzmOT1Of0jmVE3ZERaRzGV+jXci7GjxFqhniJ2hoWglWNMh0JdWSMMuV8y8DNneWlVUPrwXBcGjo6E+Eu6iBBmR802+5XqWLqIcbFAhEcNRw0JaERDVigZetcEMToeqGR6EEndnJHyORHJE7JEuvKvAxdKJqpMkYx8VwXGXUXTi1xaERRfLFsY+FFFeoYuouCQtCxsn1IiL4SdtvuUJ+BIj0MXi+Cd9Dll1oUXV0KPpakI0zJCXM3RJNdSHTvLjPqR6cZdxCMsax2u7RQ0V3aGkcq4WWcxZY42KNcZOoj4IobUVbNj3Zl2tLLlfJjfTzYtzbElTUm/OzPuVJOWyzafk+hi5oSliyKpx6o04avQi1CNMc7baNh3dHa9nWeeSabb6M/kuL/dyf+0fyPA//JP/AINo3Phw4J5Y5JNxV+BB3BN9xC4z6i6CPHguKE9Uc6qnqiWKM/Z0Hs0+q1GmnTFwooaGuK4Wyy2Wy2WWWzmOY5jmJytcGhMTHDtMkMf+qSRFKKUY6JaI23bZbLkxQjFNZHT4b3xqG04syXtaMx4821ZXi2fSusvIjuTFX9XLNv8ADT/sybnnj9LZcrvykdtOV4cq5ckeqFj9F/Q2LeMdj2dYcmOTab6GzbRHacSzQTSfmZcixY5ZH0irNo3vhzYJ44wlclSNlwZ9rfZYdEurfgQ3Hir+pkk3+Gn/AGZtyzgnLZsjb8pf9iclJ48iqUeqNnwZ9sm4YdEusmR3Hir+pkm3+Ghl3K4py2bI78pE5zhGUJrlnHRmPc0skIz7Z+kk+n/6Zdz5oOKxZHJydPSkkLceLl9LJLm810P5Ztaz/wAOn6PXn/A/keHl95Lm8/Ay4cuy53gy6+Kfmu5FWyEElZQp8pnX9Rvz7lFDVjjRXGmUUUUUUUUUUUPjQjD8Vh+9frw31JQy4JPom3/yj+dbF/8AL/0bz2/DtcYLDdxd6o3RiWPY1KtZttm8M+TZ9lllxupJr9SD5oKT8Ub4xqGbFnjo5eiyMzJNckvozdPwMPz/AFNs+FyfaypQwRl5o3TiWPYovxnqzeOfJs+zPJjdO0iLuKb8Ub7x9nnhmiq5k0/yN1Y1j2KDXWWrNv2rLs+fBDG9Jy14b6hybUpL++Js/uMf2r9Dem1Zdlwxli0blRF3FPzRvLasuzLF2Trmlr9Bao3yl22GXjqu5jrm1PAcvISb6kscMi/EkuV15dyuDQ4jdF9+iiiiih9e4jF8Vh+9frw2zDjz7Zgx5VzRalofyzYf9pf8m99k2fZ4Y3hjytt2bt+BxfT9zfHwMvqv1MXu4/RG+emH7jkXgTg1F+VG6fgYfn+ptnwuT7WSleCK8kbu+CxfabRs+PacfZZbq70/ASpJLwN+q44kvNmy702nHCOzYsSm4qvGz+F2jbMmPNtaWPs3ajHV/nw377/H9v7mz+4x/av0N++4h937EPYj9Eb76YPuf7C6I3z73B+Y+CIunoRbfUTSJSQnJv0SV8zvr330GUX3LL4WWWWPhXGjD8Vh+9frw3tKUdo2dxbTt9PquG/fd4/qzdvwOL6fub4+Bl9V+pi93H6I310w/ccxKb5H9Gbp+Bh+f6m2fC5PtYvdfkbu+Cxfab3lKGxtwbT5l0MG7u1wwyvPkTkk+pvTZP4VY2sk5237Ts3Tghi2SM0vSnq2bw2qeB4sWPR5JJN/hfDfvv8AH9v7mz+4x/av0N++4h937EPYj9Eb7/8AB9z/AGI9Eb695h/PgyPWxMjJUWct9SLUGZmnktdx8EPoS4c7O0O0O0Oc7Q7Q5ztDnO0FO9BlmjEkUzmePJDL/pkmJqSUo6p6m17G9qyYp81dm7fDfvu8X1ZunIp7FBL+20byw5M+ySx4lcrWn5kFywin4JG98nNnw4V1XpMqLJxXI2vJm6fgYfn+ptfwuT7WRV46XkbqyrJsUF4x0ZvPDkz7I4YlzStOjZ4PHghjl1jFJm/cilPHhXWKbf5m7tdixV/pN47Nmz5sE8atRlr+GvDf3vsf2/ubP7jH9q/Q377iH3fsQ9iP0Rvvpg+5/sR6I317zD+Yn4GT2SEvARjq9RMbYk2TVTfcZQuDhZ2Z2J2J2LOxZ2LOxOxOxOxOxOxOyrUfCKb0RHH5ihFEoRlFpmybxy7GuyzLnxro11RLfWzV/TjKUvKjFvXPDm7fDKVu1XgvI27bltvJGONx5Xeps205thm5Y1zQl1iR33srXpxlF+VWZd946a2eDk/N6IUsk8jzZXc5HaeZPLcWl4o2Pekdl2eOGWOUmr1Rm3xDLiljWKS5k0Yk0kmbPk2jZMjyYFzRfWJHfez9MsZRa8Kszb7x01s8HKXm+hJzySlkyu5S6mwby/g49hmi3C9GvAz76g0o7NGTdq2/I/nkP9mRvDant2SM4QceVVqY98wx44weKT5Ukbw3gttxxhHHKPK71I78xqKXZS0Xmbft62zs+WDjyO9Rb8xpV2Ujbds/jZ43GDjy31F7SMlctITp2J2hOiLtWWhzolLmlfdoXc7ZnbHbHbHbHbHbHbMWVs7RnaM7RjjbshictERxKC0FHzHSHPwLIP0Uy7hRNVNoSJvShd6PUxaTTNsjy5W/Piu4yQiyyI148JQ8hScRTZGTo5n3F5GSKeJNf2v1NFHKzkZ2chY/MjBJEqG0cyIRc2orxFFQVIlJRVslksci+GJ3FEfZaMy9M6IkxcH3I+0I2upJNeHfZLjFNlHLpY+HZpiwxYoKL0K4oj7SIq8cl3/HguokqINuzG23qT06FvmS4SHw2Ra/kTMjdj7mHoR6Gb2iQxD7q6iM/u/z77Hwjq+K1VD4LoR6njwfGHtGPoyXV97/xAAgEQADAAMAAgIDAAAAAAAAAAAAAREQIEAwUAISITFg/9oACAECAQE/AP66l9ChdkxBd9EX0C716Bda1XVMv0MJ3XD8N534WLhei7Gj6jR8cMhCCRCaXmW7w8LRYhCEITK3W7w9kXH52uPsL5UTLilKUpSlGIhMra6PLFqxfrwXRaf/xAAjEQACAgICAgIDAQAAAAAAAAAAARARAiAxQBITITADIkFg/9oACAEDAQE/AP8AWpFFDXdUsfcTix99IY12lKnJ91Q3163UZdtFQoyXZoqaKirQ8WiutQiipuE/4OGhqumhC5GPTEoU5K1pX3KEMYpYtHGSlD+1S5sQxaMRkrXRUN/FlmOVMeaFkmZFmGVcnsPNJWe1GWaPYexSitKmiipqcuNFOX83xX6woejiyyyyy5y40U5b/j4Mvhy9H9NlnieJ4iwoo9ZlyLGx4pnrPWeB4CVGRZZcJ7Vohwhi0z5MJY4cVL4MdP/Z";

/// The specific version of the standard we're using
pub const FT_METADATA_SPEC: &str = "ft-1.0.0";

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    /// Keep track of each account's balances
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of all tokens.
    pub total_supply: Balance,

    /// The bytes for the largest possible account ID that can be registered on the contract 
    pub bytes_for_longest_account_id: StorageUsage,

    /// Metadata for the contract itself
    pub metadata: LazyOption<FungibleTokenMetadata>,
}

/// Helper structure for keys of the persistent collections.
#[derive(BorshSerialize)]
pub enum StorageKey {
    Accounts,
    Metadata
}

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: AccountId, total_supply: U128) -> Self {
        // Calls the other function "new: with some default metadata and the owner_id & total supply passed in 
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "Team Token FT Tutorial".to_string(),
                symbol: "gtNEAR".to_string(),
                icon: Some(DATA_IMAGE_SVG_GT_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 24,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: AccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        // Create a variable of type Self with all the fields initialized. 
        let mut this = Self {
            // Set the total supply
            total_supply: total_supply.0,
            // Set the bytes for the longest account ID to 0 temporarily until it's calculated later
            bytes_for_longest_account_id: 0,
            // Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            accounts: LookupMap::new(StorageKey::Accounts.try_to_vec().unwrap()),
            metadata: LazyOption::new(
                StorageKey::Metadata.try_to_vec().unwrap(),
                Some(&metadata),
            ),
        };

        // Measure the bytes for the longest account ID and store it in the contract.
        this.measure_bytes_for_longest_account_id();

        // Register the owner's account and set their balance to the total supply.
        this.internal_register_account(&owner_id);
        this.internal_deposit(&owner_id, total_supply.into());
        
        // Emit an event showing that the FTs were minted
        FtMint {
            owner_id: &owner_id,
            amount: &total_supply,
            memo: Some("Initial token supply is minted"),
        }
        .emit();

        // Return the Contract object
        this
    }
}
'''
'''--- finished-contract/src/metadata.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::Base64VecU8;
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen};

use crate::*;

#[derive(BorshDeserialize, BorshSerialize, Clone, Deserialize, Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    pub spec: String, // Should be ft-1.0.0 to indicate that a Fungible Token contract adheres to the current versions of this Metadata and the Fungible Token Core specs. This will allow consumers of the Fungible Token to know if they support the features of a given contract.
    pub name: String, // The human-readable name of the token.
    pub symbol: String, // The abbreviation, like wETH or AMPL.
    pub icon: Option<String>, // Icon of the fungible token.
    pub reference: Option<String>, // A link to a valid JSON file containing various keys offering supplementary details on the token 
    pub reference_hash: Option<Base64VecU8>, // The base64-encoded sha256 hash of the JSON file contained in the reference field. This is to guard against off-chain tampering.
    pub decimals: u8, // used in frontends to show the proper significant digits of a token. This concept is explained well in this OpenZeppelin post. https://docs.openzeppelin.com/contracts/3.x/erc20#a-note-on-decimals
}

pub trait FungibleTokenMetadataProvider {
    // View call for returning the contract metadata
    fn ft_metadata(&self) -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

'''
'''--- finished-contract/src/storage.rs ---
use near_sdk::json_types::U128;
use near_sdk::{env, log, AccountId, Balance, Promise};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};

use crate::*;

// The structure that will be returned for the methods:
// * `storage_deposit`
// * `storage_withdraw`
// * `storage_balance_of`
// The `total` and `available` values are string representations of unsigned
// 128-bit integers showing the balance of a specific account in yoctoⓃ.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    pub total: U128,
    pub available: U128,
}

// The below structure will be returned for the method `storage_balance_bounds`.
// Both `min` and `max` are string representations of unsigned 128-bit integers.
//
// `min` is the amount of tokens required to start using this contract at all
// (eg to register with the contract). If a new contract user attaches `min`
// NEAR to a `storage_deposit` call, subsequent calls to `storage_balance_of`
// for this user must show their `total` equal to `min` and `available=0` .
//
// A contract may implement `max` equal to `min` if it only charges for initial
// registration, and does not adjust per-user storage over time. A contract
// which implements `max` must refund deposits that would increase a user's
// storage balance beyond this amount.
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    pub min: U128,
    pub max: Option<U128>,
}

pub trait StorageManagement {
    /************************************/
    /* CHANGE METHODS on fungible token */
    /************************************/
    // Payable method that receives an attached deposit of Ⓝ for a given account.
    //
    // If `account_id` is omitted, the deposit MUST go toward predecessor account.
    // If provided, deposit MUST go toward this account. If invalid, contract MUST
    // panic.
    //
    // If `registration_only=true`, contract MUST refund above the minimum balance
    // if the account wasn't registered and refund full deposit if already
    // registered.
    //
    // The `storage_balance_of.total` + `attached_deposit` in excess of
    // `storage_balance_bounds.max` must be refunded to predecessor account.
    //
    // Returns the StorageBalance structure showing updated balances.
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance;

    /****************/
    /* VIEW METHODS */
    /****************/
    // Returns minimum and maximum allowed balance amounts to interact with this
    // contract. See StorageBalanceBounds.
    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    // Returns the StorageBalance structure of the valid `account_id`
    // provided. Must panic if `account_id` is invalid.
    //
    // If `account_id` is not registered, must return `null`.
    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance>;
}

#[near_bindgen]
impl StorageManagement for Contract {
    #[allow(unused_variables)]
    #[payable]
    fn storage_deposit(
        &mut self,
        account_id: Option<AccountId>,
        registration_only: Option<bool>,
    ) -> StorageBalance {
        // Get the amount of $NEAR to deposit
        let amount: Balance = env::attached_deposit();
        // If an account was specified, use that. Otherwise, use the predecessor account.
        let account_id = account_id.unwrap_or_else(env::predecessor_account_id);
        
        // If the account is already registered, refund the deposit.
        if self.accounts.contains_key(&account_id) {
            log!("The account is already registered, refunding the deposit");
            if amount > 0 {
                Promise::new(env::predecessor_account_id()).transfer(amount);
            } 
        // Register the account and refund any excess $NEAR
        } else {
            // Get the minimum required storage and ensure the deposit is at least that amount
            let min_balance = self.storage_balance_bounds().min.0;
            if amount < min_balance {
                env::panic_str("The attached deposit is less than the minimum storage balance");
            }

            // Register the account
            self.internal_register_account(&account_id);
            // Perform a refund
            let refund = amount - min_balance;
            if refund > 0 {
                Promise::new(env::predecessor_account_id()).transfer(refund);
            }
        }

        // Return the storage balance of the account
        StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        // Calculate the required storage balance by taking the bytes for the longest account ID and multiplying by the current byte cost
        let required_storage_balance =
            Balance::from(self.bytes_for_longest_account_id) * env::storage_byte_cost();
        
        // Storage balance bounds will have min == max == required_storage_balance
        StorageBalanceBounds {
            min: required_storage_balance.into(),
            max: Some(required_storage_balance.into()),
        }
    }

    fn storage_balance_of(&self, account_id: AccountId) -> Option<StorageBalance> {
        // Get the storage balance of the account. Available will always be 0 since you can't overpay for storage.
        if self.accounts.contains_key(&account_id) {
            Some(StorageBalance { total: self.storage_balance_bounds().min, available: 0.into() })
        } else {
            None
        }
    }
}

'''
'''--- market-contract/Cargo.toml ---
[package]
name = "nft_simple"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "4.0.0"

[profile.release]
codegen-units=1
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- market-contract/README.md ---
# TBD

'''
'''--- market-contract/build.sh ---
#!/bin/bash
set -e && RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release && mkdir -p ../out && cp target/wasm32-unknown-unknown/release/*.wasm ../out/market.wasm
'''
'''--- market-contract/src/external.rs ---
use crate::*;

/// external contract calls

//initiate a cross contract call to the nft contract. This will transfer the token to the buyer
#[ext_contract(ext_nft_contract)]
trait ExtNftContract {
    fn nft_transfer(
        &mut self,
        receiver_id: AccountId, // purchaser (person to transfer the NFT to)
        token_id: TokenId, // token ID to transfer
        approval_id: Option<u64>, // market contract's approval ID in order to transfer the token on behalf of the owner
        memo: Option<String>, //memo (to include some context)
    );
}

//initiate a cross contract call to the nft contract. This will transfer the token to the buyer and return
//a payout object used for the market to distribute funds to the appropriate accounts.
#[ext_contract(ext_ft_contract)]
trait ExtFtContract {
    fn ft_transfer(
        &mut self,
        receiver_id: AccountId, 
        amount: U128, 
        memo: Option<String>
    );
}
'''
'''--- market-contract/src/ft_balances.rs ---
use near_sdk::{require, PromiseResult};

use crate::*;

/// transfer callbacks from FT Contracts

/*
    trait that will be used as the callback from the FT contract. When ft_transfer_call is
    called, it will fire a cross contract call to this marketplace and this is the function
    that is invoked. 
*/
trait FungibleTokenReceiver {
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128
    ) -> U128;

    fn ft_withdraw(
        &mut self,
        amount: U128
    );

    fn resolve_refund(
        &mut self,
        caller: AccountId,
        amount: U128
    ) -> U128;

    fn ft_deposits_of(
        &self,
        account_id: AccountId
    ) -> U128;
}

//implementation of the trait
#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    /// This is how users will fund their FT balances in the contract
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128
    ) -> U128 {
        // get the contract ID which is the predecessor
        let ft_contract_id = env::predecessor_account_id();
        // Ensure only the specified FT can be used
        require!(
            ft_contract_id == self.ft_id,
            "FT contract ID does not match"
        );
        
        //get the signer which is the person who initiated the transaction
        let signer_id = env::signer_account_id();

        //make sure that the signer isn't the predecessor. This is so that we're sure
        //this was called via a cross-contract call
        assert_ne!(
            ft_contract_id,
            signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        //make sure the owner ID is the signer. 
        assert_eq!(
            sender_id,
            signer_id,
            "owner_id should be signer_id"
        );

        // Add the amount to the user's current balance
        let mut cur_bal = self.ft_deposits.get(&signer_id).unwrap_or(0);
        cur_bal += amount.0;
        self.ft_deposits.insert(&signer_id, &cur_bal);

        // We don't return any FTs to the sender because we're storing all of them in their balance
        U128(0)
    }

    #[payable]
    fn ft_withdraw(
            &mut self,
            amount: U128
    ) {
        //make sure the user attaches exactly 1 yoctoNEAR for security purposes.
        //this will redirect them to the NEAR wallet (or requires a full access key). 
        assert_one_yocto();

        // Get the caller and ensure they have enough balance
        let caller = env::predecessor_account_id();
        let cur_bal = self.ft_deposits.get(&caller).unwrap_or(0);
        require!(
            cur_bal >= amount.0,
            "Insufficient balance"
        );

        // Subtract the amount from the caller's balance
        let new_bal = cur_bal - amount.0;
        self.ft_deposits.insert(&caller, &new_bal);

        // Perform the cross contract call to transfer the FTs to the caller. If anything goes wrong
        // We increment their balance back when we resolve the promise
        ext_ft_contract::ext(self.ft_id.clone())
            // Attach 1 yoctoNEAR with static GAS equal to the GAS for nft transfer. Also attach an unused GAS weight of 1 by default.
            .with_attached_deposit(1)
            .ft_transfer(
                caller.clone(), //caller to refund the FTs to
                amount, //amount to transfer
                Some("Withdrawing from Marketplace".to_string()), //memo (to include some context)
            )
        .then(
            // No attached deposit with static GAS equal to the GAS for resolving the purchase. Also attach an unused GAS weight of 1 by default.
            Self::ext(env::current_account_id())
            .with_static_gas(GAS_FOR_RESOLVE_REFUND)
            .resolve_refund(
                caller, //caller to refund the FTs to
                amount, //amount to transfer
            )
        );
    }

    #[private]
    fn resolve_refund(
        &mut self,
        caller: AccountId,
        amount: U128
    ) -> U128 {
        let amount: Balance = amount.into();

        // Get the amount to revert the caller's balance with
        let revert_amount = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            // If the promise was successful, get the return value and cast it to a U128.
            PromiseResult::Successful(_) => {
                0
            }
            // If the promise wasn't successful, return the original amount.
            PromiseResult::Failed => amount,
        };

        if revert_amount > 0 {
            // Get the caller's current balance
            let cur_bal = self.ft_deposits.get(&caller).unwrap_or(0);
            // Add the amount to the caller's balance
            let new_bal = cur_bal + revert_amount;
            self.ft_deposits.insert(&caller, &new_bal);
        }

        U128(revert_amount)
    }

    /// Get the amount of FTs the user has deposited into the contract
    fn ft_deposits_of(
        &self,
        account_id: AccountId
    ) -> U128 {
        self.ft_deposits.get(&account_id).unwrap_or(0).into()
    }
}
'''
'''--- market-contract/src/internal.rs ---
use crate::*;

//used to generate a unique prefix in our storage collections (this is to avoid data collisions)
pub(crate) fn hash_account_id(account_id: &AccountId) -> CryptoHash {
    //get the default hash
    let mut hash = CryptoHash::default();
    //we hash the account ID and return it
    hash.copy_from_slice(&env::sha256(account_id.as_bytes()));
    hash
}

impl Contract {
    //internal method for removing a sale from the market. This returns the previously removed sale object
    pub(crate) fn internal_remove_sale(
        &mut self,
        nft_contract_id: AccountId,
        token_id: TokenId,
    ) -> Sale {
        //get the unique sale ID (contract + DELIMITER + token ID)
        let contract_and_token_id = format!("{}{}{}", &nft_contract_id, DELIMETER, token_id);
        //get the sale object by removing the unique sale ID. If there was no sale, panic
        let sale = self.sales.remove(&contract_and_token_id).expect("No sale");

        //get the set of sales for the sale's owner. If there's no sale, panic. 
        let mut by_owner_id = self.by_owner_id.get(&sale.owner_id).expect("No sale by_owner_id");
        //remove the unique sale ID from the set of sales
        by_owner_id.remove(&contract_and_token_id);
        
        //if the set of sales is now empty after removing the unique sale ID, we simply remove that owner from the map
        if by_owner_id.is_empty() {
            self.by_owner_id.remove(&sale.owner_id);
        //if the set of sales is not empty after removing, we insert the set back into the map for the owner
        } else {
            self.by_owner_id.insert(&sale.owner_id, &by_owner_id);
        }

        //get the set of token IDs for sale for the nft contract ID. If there's no sale, panic. 
        let mut by_nft_contract_id = self
            .by_nft_contract_id
            .get(&nft_contract_id)
            .expect("No sale by nft_contract_id");
        
        //remove the token ID from the set 
        by_nft_contract_id.remove(&token_id);
        
        //if the set is now empty after removing the token ID, we remove that nft contract ID from the map
        if by_nft_contract_id.is_empty() {
            self.by_nft_contract_id.remove(&nft_contract_id);
        //if the set is not empty after removing, we insert the set back into the map for the nft contract ID
        } else {
            self.by_nft_contract_id
                .insert(&nft_contract_id, &by_nft_contract_id);
        }

        //return the sale object
        sale
    }
}

'''
'''--- market-contract/src/lib.rs ---
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::json_types::{U128, U64};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{
    assert_one_yocto, env, ext_contract, near_bindgen, AccountId, Balance, Gas, PanicOnDefault,
    Promise, CryptoHash, BorshStorageKey,
};
use std::collections::HashMap;

use crate::external::*;
use crate::internal::*;
use crate::sale::*;
use near_sdk::env::STORAGE_PRICE_PER_BYTE;

mod external;
mod internal;
mod ft_balances;
mod nft_callbacks;
mod sale;
mod sale_views;

//GAS constants to attach to calls
const GAS_FOR_RESOLVE_PURCHASE: Gas = Gas(115_000_000_000_000);
const GAS_FOR_RESOLVE_REFUND: Gas = Gas(30_000_000_000_000);
const GAS_FOR_NFT_TRANSFER: Gas = Gas(15_000_000_000_000);

//the minimum storage to have a sale on the contract.
const STORAGE_PER_SALE: u128 = 1000 * STORAGE_PRICE_PER_BYTE;

//every sale will have a unique ID which is `CONTRACT + DELIMITER + TOKEN_ID`
static DELIMETER: &str = ".";

//Creating custom types to use within the contract. This makes things more readable. 
pub type SalePriceInFTs = U128;
pub type TokenId = String;
pub type FungibleTokenId = AccountId;
pub type ContractAndTokenId = String;
//defines the payout type we'll be parsing from the NFT contract as a part of the royalty standard.
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
} 

//main contract struct to store all the information
#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    //keep track of the owner of the contract
    pub owner_id: AccountId,

    //which fungible token can be used to purchase NFTs
    pub ft_id: AccountId,
    
    /*
        to keep track of the sales, we map the ContractAndTokenId to a Sale. 
        the ContractAndTokenId is the unique identifier for every sale. It is made
        up of the `contract ID + DELIMITER + token ID`
    */
    pub sales: UnorderedMap<ContractAndTokenId, Sale>,
    
    //keep track of all the Sale IDs for every account ID
    pub by_owner_id: LookupMap<AccountId, UnorderedSet<ContractAndTokenId>>,

    //keep track of all the token IDs for sale for a given contract
    pub by_nft_contract_id: LookupMap<AccountId, UnorderedSet<TokenId>>,

    //keep track of the storage that accounts have payed
    pub storage_deposits: LookupMap<AccountId, Balance>,

    //keep track of how many FTs each account has deposited in order to purchase NFTs with
    pub ft_deposits: LookupMap<AccountId, Balance>,
}

/// Helper structure to for keys of the persistent collections.
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKey {
    Sales,
    ByOwnerId,
    ByOwnerIdInner { account_id_hash: CryptoHash },
    ByNFTContractId,
    ByNFTContractIdInner { account_id_hash: CryptoHash },
    ByNFTTokenType,
    ByNFTTokenTypeInner { token_type_hash: CryptoHash },
    FTTokenIds,
    StorageDeposits,
    FTDeposits,
}

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        this initializes the contract with default data and the owner ID
        that's passed in
    */
    #[init]
    pub fn new(owner_id: AccountId, ft_id: AccountId) -> Self {
        let this = Self {
            //set the owner_id field equal to the passed in owner_id. 
            owner_id,

            //set the FT ID equal to the passed in ft_id.
            ft_id,

            //Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            sales: UnorderedMap::new(StorageKey::Sales),
            by_owner_id: LookupMap::new(StorageKey::ByOwnerId),
            by_nft_contract_id: LookupMap::new(StorageKey::ByNFTContractId),
            storage_deposits: LookupMap::new(StorageKey::StorageDeposits),
            ft_deposits: LookupMap::new(StorageKey::FTDeposits),
        };

        //return the Contract object
        this
    }

    //Allows users to deposit storage. This is to cover the cost of storing sale objects on the contract
    //Optional account ID is to users can pay for storage for other people.
    #[payable]
    pub fn storage_deposit(&mut self, account_id: Option<AccountId>) {
        //get the account ID to pay for storage for
        let storage_account_id = account_id 
            //convert the valid account ID into an account ID
            .map(|a| a.into())
            //if we didn't specify an account ID, we simply use the caller of the function
            .unwrap_or_else(env::predecessor_account_id);

        //get the deposit value which is how much the user wants to add to their storage
        let deposit = env::attached_deposit();

        //make sure the deposit is greater than or equal to the minimum storage for a sale
        assert!(
            deposit >= STORAGE_PER_SALE,
            "Requires minimum deposit of {}",
            STORAGE_PER_SALE
        );

        //get the balance of the account (if the account isn't in the map we default to a balance of 0)
        let mut balance: u128 = self.storage_deposits.get(&storage_account_id).unwrap_or(0);
        //add the deposit to their balance
        balance += deposit;
        //insert the balance back into the map for that account ID
        self.storage_deposits.insert(&storage_account_id, &balance);
    }

    //Allows users to withdraw any excess storage that they're not using. Say Bob pays 0.01N for 1 sale
    //Alice then buys Bob's token. This means bob has paid 0.01N for a sale that's no longer on the marketplace
    //Bob could then withdraw this 0.01N back into his account. 
    #[payable]
    pub fn storage_withdraw(&mut self) {
        //make sure the user attaches exactly 1 yoctoNEAR for security purposes.
        //this will redirect them to the NEAR wallet (or requires a full access key). 
        assert_one_yocto();

        //the account to withdraw storage to is always the function caller
        let owner_id = env::predecessor_account_id();
        //get the amount that the user has by removing them from the map. If they're not in the map, default to 0
        let mut amount = self.storage_deposits.remove(&owner_id).unwrap_or(0);
        
        //how many sales is that user taking up currently. This returns a set
        let sales = self.by_owner_id.get(&owner_id);
        //get the length of that set. 
        let len = sales.map(|s| s.len()).unwrap_or_default();
        //how much NEAR is being used up for all the current sales on the account 
        let diff = u128::from(len) * STORAGE_PER_SALE;

        //the excess to withdraw is the total storage paid - storage being used up.
        amount -= diff;

        //if that excess to withdraw is > 0, we transfer the amount to the user.
        if amount > 0 {
            Promise::new(owner_id.clone()).transfer(amount);
        }
        //we need to add back the storage being used up into the map if it's greater than 0.
        //this is so that if the user had 500 sales on the market, we insert that value here so
        //if those sales get taken down, the user can then go and withdraw 500 sales worth of storage.
        if diff > 0 {
            self.storage_deposits.insert(&owner_id, &diff);
        }
    }

    /// views
    //return the minimum storage for 1 sale
    pub fn storage_minimum_balance(&self) -> U128 {
        U128(STORAGE_PER_SALE)
    }

    //return how much storage an account has paid for
    pub fn storage_balance_of(&self, account_id: AccountId) -> U128 {
        U128(self.storage_deposits.get(&account_id).unwrap_or(0))
    }
}
'''
'''--- market-contract/src/nft_callbacks.rs ---
use crate::*;

/// approval callbacks from NFT Contracts

//struct for keeping track of the sale conditions for a Sale
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct SaleArgs {
    pub sale_conditions: SalePriceInFTs,
}

/*
    trait that will be used as the callback from the NFT contract. When nft_approve is
    called, it will fire a cross contract call to this marketplace and this is the function
    that is invoked. 
*/
trait NonFungibleTokenApprovalsReceiver {
    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    );
}

//implementation of the trait
#[near_bindgen]
impl NonFungibleTokenApprovalsReceiver for Contract {
    /// where we add the sale because we know nft owner can only call nft_approve

    fn nft_on_approve(
        &mut self,
        token_id: TokenId,
        owner_id: AccountId,
        approval_id: u64,
        msg: String,
    ) {
        // get the contract ID which is the predecessor
        let nft_contract_id = env::predecessor_account_id();
        //get the signer which is the person who initiated the transaction
        let signer_id = env::signer_account_id();

        //make sure that the signer isn't the predecessor. This is so that we're sure
        //this was called via a cross-contract call
        assert_ne!(
            nft_contract_id,
            signer_id,
            "nft_on_approve should only be called via cross-contract call"
        );
        //make sure the owner ID is the signer. 
        assert_eq!(
            owner_id,
            signer_id,
            "owner_id should be signer_id"
        );

        //we need to enforce that the user has enough storage for 1 EXTRA sale.  

        //get the storage for a sale. dot 0 converts from U128 to u128
        let storage_amount = self.storage_minimum_balance().0;
        //get the total storage paid by the owner
        let owner_paid_storage = self.storage_deposits.get(&signer_id).unwrap_or(0);
        //get the storage required which is simply the storage for the number of sales they have + 1 
        let signer_storage_required = (self.get_supply_by_owner_id(signer_id).0 + 1) as u128 * storage_amount;
        
        //make sure that the total paid is >= the required storage
        assert!(
            owner_paid_storage >= signer_storage_required,
            "Insufficient storage paid: {}, for {} sales at {} rate of per sale",
            owner_paid_storage, signer_storage_required / STORAGE_PER_SALE, STORAGE_PER_SALE
        );

        //if all these checks pass we can create the sale conditions object.
        let SaleArgs { sale_conditions } =
            //the sale conditions come from the msg field. The market assumes that the user passed
            //in a proper msg. If they didn't, it panics. 
            near_sdk::serde_json::from_str(&msg).expect("Not valid SaleArgs");

        //create the unique sale ID which is the contract + DELIMITER + token ID
        let contract_and_token_id = format!("{}{}{}", nft_contract_id, DELIMETER, token_id);
        
        //insert the key value pair into the sales map. Key is the unique ID. value is the sale object
        self.sales.insert(
            &contract_and_token_id,
            &Sale {
                owner_id: owner_id.clone(), //owner of the sale / token
                approval_id, //approval ID for that token that was given to the market
                nft_contract_id: nft_contract_id.to_string(), //NFT contract the token was minted on
                token_id: token_id.clone(), //the actual token ID
                sale_conditions, //the sale conditions 
           },
        );

        //Extra functionality that populates collections necessary for the view calls 

        //get the sales by owner ID for the given owner. If there are none, we create a new empty set
        let mut by_owner_id = self.by_owner_id.get(&owner_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKey::ByOwnerIdInner {
                    //we get a new unique prefix for the collection by hashing the owner
                    account_id_hash: hash_account_id(&owner_id),
                }
                .try_to_vec()
                .unwrap(),
            )
        });
        
        //insert the unique sale ID into the set
        by_owner_id.insert(&contract_and_token_id);
        //insert that set back into the collection for the owner
        self.by_owner_id.insert(&owner_id, &by_owner_id);

        //get the token IDs for the given nft contract ID. If there are none, we create a new empty set
        let mut by_nft_contract_id = self
            .by_nft_contract_id
            .get(&nft_contract_id)
            .unwrap_or_else(|| {
                UnorderedSet::new(
                    StorageKey::ByNFTContractIdInner {
                        //we get a new unique prefix for the collection by hashing the owner
                        account_id_hash: hash_account_id(&nft_contract_id),
                    }
                    .try_to_vec()
                    .unwrap(),
                )
            });
        
        //insert the token ID into the set
        by_nft_contract_id.insert(&token_id);
        //insert the set back into the collection for the given nft contract ID
        self.by_nft_contract_id
            .insert(&nft_contract_id, &by_nft_contract_id);
    }
}

'''
'''--- market-contract/src/sale.rs ---
use crate::*;
use near_sdk::{PromiseResult};

//struct that holds important information about each sale on the market
#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Sale {
    //owner of the sale
    pub owner_id: AccountId,
    //market contract's approval ID to transfer the token on behalf of the owner
    pub approval_id: u64,
    //nft contract where the token was minted
    pub nft_contract_id: String,
    //actual token ID for sale
    pub token_id: String,
    //sale price in fungible tokens that the token is listed for
    pub sale_conditions: SalePriceInFTs,
}

#[near_bindgen]
impl Contract {
    
    //removes a sale from the market. 
    #[payable]
    pub fn remove_sale(&mut self, nft_contract_id: AccountId, token_id: String) {
        //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
        assert_one_yocto();
        //get the sale object as the return value from removing the sale internally
        let sale = self.internal_remove_sale(nft_contract_id.into(), token_id);
        //get the predecessor of the call and make sure they're the owner of the sale
        let owner_id = env::predecessor_account_id();
        //if this fails, the remove sale will revert
        assert_eq!(owner_id, sale.owner_id, "Must be sale owner");
    }

    //updates the price for a sale on the market
    #[payable]
    pub fn update_price(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        price: U128,
    ) {
        //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
        assert_one_yocto();
        
        //create the unique sale ID from the nft contract and token
        let contract_id: AccountId = nft_contract_id.into();
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        
        //get the sale object from the unique sale ID. If there is no token, panic. 
        let mut sale = self.sales.get(&contract_and_token_id).expect("No sale");

        //assert that the caller of the function is the sale owner
        assert_eq!(
            env::predecessor_account_id(),
            sale.owner_id,
            "Must be sale owner"
        );
        
        //set the sale conditions equal to the passed in price
        sale.sale_conditions = price;
        //insert the sale back into the map for the unique sale ID
        self.sales.insert(&contract_and_token_id, &sale);
    }

    /// Place an offer on a specific sale. 
    /// The sale will go through as long as you have enough FTs in your balance to cover the amount and the amount is greater than or equal to the sale price
    #[payable]
    pub fn offer(&mut self, nft_contract_id: AccountId, token_id: String, amount: U128) {
        //assert that the user has attached exactly 1 yoctoNEAR (for security reasons)
        assert_one_yocto();

        //convert the nft_contract_id from a AccountId to an AccountId
        let contract_id: AccountId = nft_contract_id.into();
        //get the unique sale ID (contract + DELIMITER + token ID)
        let contract_and_token_id = format!("{}{}{}", contract_id, DELIMETER, token_id);
        
        //get the sale object from the unique sale ID. If the sale doesn't exist, panic.
        let sale = self.sales.get(&contract_and_token_id).expect("No sale");
        
        //get the buyer ID which is the person who called the function and make sure they're not the owner of the sale
        let buyer_id = env::predecessor_account_id();
        assert_ne!(sale.owner_id, buyer_id, "Cannot bid on your own sale.");
        
        //get the u128 price of the token (dot 0 converts from U128 to u128)
        let price = sale.sale_conditions.0;

        //make sure the amount offering is greater than or equal to the price of the token
        assert!(amount.0 >= price, "Offer amount must be greater than or eqaul to the price: {:?}", price);

        // get the amount of FTs the buyer has in their balance
        let cur_bal = self.ft_deposits.get(&buyer_id).unwrap();
        //make sure the buyer has enough FTs to cover the amount they're offering
        assert!(cur_bal >= amount.0, "Not enough FTs in balance to cover offer: {:?}", amount);
        // if the buyer has enough FTs, subtract the amount from their balance
        self.ft_deposits.insert(&buyer_id, &(cur_bal - amount.0));

        //process the purchase (which will remove the sale from the market and perform the transfer)
        self.process_purchase(
            contract_id,
            token_id,
            amount,
            buyer_id,
        );
    }

    //private function used when a sale is purchased. 
    //this will remove the sale, transfer and get the payout from the nft contract, and then distribute royalties
    #[private]
    pub fn process_purchase(
        &mut self,
        nft_contract_id: AccountId,
        token_id: String,
        amount: U128,
        buyer_id: AccountId,
    ) -> Promise {
        //get the sale object by removing the sale
        let sale = self.internal_remove_sale(nft_contract_id.clone(), token_id.clone());

        //initiate a cross contract call to the nft contract. This will transfer the token to the buyer
        ext_nft_contract::ext(nft_contract_id)
            // Attach 1 yoctoNEAR with static GAS equal to the GAS for nft transfer. Also attach an unused GAS weight of 1 by default.
            .with_attached_deposit(1)
            .with_static_gas(GAS_FOR_NFT_TRANSFER)
            .nft_transfer(
                buyer_id.clone(), //purchaser (person to transfer the NFT to)
                token_id, //token ID to transfer
                Some(sale.approval_id), //market contract's approval ID in order to transfer the token on behalf of the owner
                Some("payout from market".to_string()) //memo (to include some context)
            )
        //after the transfer payout has been initiated, we resolve the promise by calling our own resolve_purchase function. 
        //resolve purchase will send the FTs to the owner of the sale if everything went well.
        .then(
            // No attached deposit with static GAS equal to the GAS for resolving the purchase. Also attach an unused GAS weight of 1 by default.
            Self::ext(env::current_account_id())
            .with_static_gas(GAS_FOR_RESOLVE_PURCHASE)
            .resolve_purchase(
                sale.owner_id, //the seller of the token
                buyer_id, //the buyer and price are passed in incase something goes wrong and we need to refund the buyer
                amount,
            )
        )
    }

    /*
        private method used to resolve the promise when calling nft_transfer_payout. This will
        transfer the tokens to the owner of the sale if the transfer was successful. If not, the buyer will be refunded.
        IMPORTANT - the seller MUST be registered on the FT contract before this function is called or else they will NOT
        receive their FTs
    */
    #[private]
    pub fn resolve_purchase(
        &mut self,
        seller_id: AccountId,
        buyer_id: AccountId,
        price: U128,
    ) -> U128 {
        let amount: Balance = price.into();

        // Get the amount to revert the caller's balance with
        let transfer_amount = match env::promise_result(0) {
            PromiseResult::NotReady => env::abort(),
            // If the promise was successful, we'll transfer all the FTs
            PromiseResult::Successful(_) => {
                amount
            }
            // If the promise wasn't successful, we won't transfer any FTs and instead refund the buyer
            PromiseResult::Failed => 0,
        };

        // If the promise was successful, we'll transfer all the FTs
        if transfer_amount > 0 {
            // Perform the cross contract call to transfer the FTs to the seller
            ext_ft_contract::ext(self.ft_id.clone())
                // Attach 1 yoctoNEAR with static GAS equal to the GAS for nft transfer. Also attach an unused GAS weight of 1 by default.
                .with_attached_deposit(1)
                .ft_transfer(
                    seller_id, //seller to transfer the FTs to
                    U128(transfer_amount), //amount to transfer
                    Some("Sale from marketplace".to_string()), //memo (to include some context)
                );
            return U128(transfer_amount);
        // If the promise was not successful, we won't transfer any FTs and instead refund the buyer
        } else {
            // Get the buyer's current balance and increment it
            let cur_bal = self.ft_deposits.get(&buyer_id).unwrap();
            self.ft_deposits.insert(&buyer_id, &(cur_bal + amount));
            return U128(0);
        }
    }
}

//this is the cross contract call that we call on our own contract. 
/*
    private method used to resolve the promise when calling nft_transfer_payout. This will take the payout object and 
    check to see if it's authentic and there's no problems. If everything is fine, it will pay the accounts. If there's a problem,
    it will refund the buyer for the price. 
*/
#[ext_contract(ext_self)]
trait ExtSelf {
    fn resolve_purchase(
        &mut self,
        buyer_id: AccountId,
        price: U128,
    ) -> Promise;
}

'''
'''--- market-contract/src/sale_views.rs ---
use crate::*;

#[near_bindgen]
impl Contract {
    /// views
    
    //returns the number of sales the marketplace has up (as a string)
    pub fn get_supply_sales(
        &self,
    ) -> U64 {
        //returns the sales object length wrapped as a U64
        U64(self.sales.len())
    }
    
    //returns the number of sales for a given account (result is a string)
    pub fn get_supply_by_owner_id(
        &self,
        account_id: AccountId,
    ) -> U64 {
        //get the set of sales for the given owner Id
        let by_owner_id = self.by_owner_id.get(&account_id);
        
        //if there as some set, we return the length but if there wasn't a set, we return 0
        if let Some(by_owner_id) = by_owner_id {
            U64(by_owner_id.len())
        } else {
            U64(0)
        }
    }

    //returns paginated sale objects for a given account. (result is a vector of sales)
    pub fn get_sales_by_owner_id(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Sale> {
        //get the set of token IDs for sale for the given account ID
        let by_owner_id = self.by_owner_id.get(&account_id);
        //if there was some set, we set the sales variable equal to that set. If there wasn't, sales is set to an empty vector
        let sales = if let Some(by_owner_id) = by_owner_id {
            by_owner_id
        } else {
            return vec![];
        };
        
        //we'll convert the UnorderedSet into a vector of strings
        let keys = sales.as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));
        
        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize) 
            //we'll map the token IDs which are strings into Sale objects
            .map(|token_id| self.sales.get(&token_id).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get the number of sales for an nft contract. (returns a string)
    pub fn get_supply_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
    ) -> U64 {
        //get the set of tokens for associated with the given nft contract
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        
        //if there was some set, return it's length. Otherwise return 0
        if let Some(by_nft_contract_id) = by_nft_contract_id {
            U64(by_nft_contract_id.len())
        } else {
            U64(0)
        }
    }

    //returns paginated sale objects associated with a given nft contract. (result is a vector of sales)
    pub fn get_sales_by_nft_contract_id(
        &self,
        nft_contract_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Sale> {
        //get the set of token IDs for sale for the given contract ID
        let by_nft_contract_id = self.by_nft_contract_id.get(&nft_contract_id);
        
        //if there was some set, we set the sales variable equal to that set. If there wasn't, sales is set to an empty vector
        let sales = if let Some(by_nft_contract_id) = by_nft_contract_id {
            by_nft_contract_id
        } else {
            return vec![];
        };

        //we'll convert the UnorderedSet into a vector of strings
        let keys = sales.as_vector();

        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));
        
        //iterate through the keys vector
        keys.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize) 
            //we'll map the token IDs which are strings into Sale objects by passing in the unique sale ID (contract + DELIMITER + token ID)
            .map(|token_id| self.sales.get(&format!("{}{}{}", nft_contract_id, DELIMETER, token_id)).unwrap())
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    //get a sale information for a given unique sale ID (contract + DELIMITER + token ID)
    pub fn get_sale(&self, nft_contract_token: ContractAndTokenId) -> Option<Sale> {
        //try and get the sale object for the given unique sale ID. Will return an option since
        //we're not guaranteed that the unique sale ID passed in will be valid.
        self.sales.get(&nft_contract_token)
    }
}

'''
'''--- package.json ---
{
    "name": "ft-tutorial",
    "version": "1.0.0",
    "description": "Zero to Hero FT Tutorial",
    "author": "Ben Kurrek",
    "license": "ISC",
    "scripts": {
        "build": "cd finished-contract && ./build.sh && cd .."
    }
}

'''