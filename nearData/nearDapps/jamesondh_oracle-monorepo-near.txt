*GitHub Repository "jamesondh/oracle-monorepo-near"*

'''--- Cargo.toml ---
[workspace]
members = [
  "oracle",
  "token",
  "request-interface"
]

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true
'''
'''--- build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release

if [ ! -d ./res ]; then
    mkdir ./res
fi

cp ./target/wasm32-unknown-unknown/release/oracle.wasm ./res
cp ./target/wasm32-unknown-unknown/release/request_interface.wasm ./res
cp ./target/wasm32-unknown-unknown/release/token.wasm ./res

'''
'''--- deployment/README.md ---
## Setup Bash variables

Change to your account (set up through [near-cli](https://docs.near.org/docs/tools/near-cli)):

```bash
ACCOUNT=account.testnet
ORACLE=oracle.account.testnet
REQUESTOR=requestor.account.testnet
```

## Deployment

The default parameters of `deploy_oracle.sh` are listed inside the script; change them with shell arguments, e.g. `--validityBond 1`. Testnet is used unless specified otherwise. Example deployment using the shell variables at the top:

```bash
bash deployment/deploy_oracle.sh --accountId $ORACLE --gov $ACCOUNT

bash deployment/deploy_requestor.sh --accountId $REQUESTOR --oracle $ORACLE
```

## Reset account

Example resetting (deleting then creating) the oracle account:

```bash
bash deployment/reset_account.sh --master $ACCOUNT --account $ORACLE
```

'''
'''--- deployment/deploy_oracle.sh ---
#!/bin/bash

# default params
network=${network:-testnet}
accountId=${accountId:-oracle.account.testnet}
gov=${gov:-flux-dev}
finalArbitrator=${finalArbitrator:-flux-dev}
stakeToken=${stakeToken:-v2.wnear.flux-dev}
paymentToken=${paymentToken:-v2.wnear.flux-dev}
validityBond=${validityBond:-1000000000000000000000000}
maxOutcomes=${maxOutcomes:-8}
defaultChallengeWindowDuration=${defaultChallengeWindowDuration:-120000000000}
minInitialChallengeWindowDuration=${minInitialChallengeWindowDuration:-120000000000}
finalArbitratorInvokeAmount=${finalArbitratorInvokeAmount:-100000000000000000000000000}
# resolutionFeePercentage=${resolutionFeePercentage:-5000}
fluxMarketCap=${fluxMarketCap:-10000000000000}
totalValueStaked=${totalValueStaked:-1000}
resolutionFeePercentage=${totalValueStaked:-1000}

while [ $# -gt 0 ]; do

   if [[ $1 == *"--"* ]]; then
        param="${1/--/}"
        declare $param="$2"
        # echo $1 $2 // Optional to see the parameter:value result
   fi

  shift
done

NEAR_ENV=$network near deploy --accountId $accountId --wasmFile ./res/oracle.wasm --initFunction new --initArgs '{ "config": { "gov": "'$gov'", "final_arbitrator": "'$finalArbitrator'", "stake_token": "'$stakeToken'", "payment_token": "'$paymentToken'", "validity_bond": "'$validityBond'", "max_outcomes": '$maxOutcomes', "default_challenge_window_duration": "'$defaultChallengeWindowDuration'", "min_initial_challenge_window_duration": "'$minInitialChallengeWindowDuration'", "final_arbitrator_invoke_amount": "'$finalArbitratorInvokeAmount'", "resolution_fee_percentage": '$resolutionFeePercentage', "fee": {"flux_market_cap": "'$fluxMarketCap'", "total_value_staked":"'$totalValueStaked'", "resolution_fee_percentage": '$resolutionFeePercentage' } } }'

'''
'''--- deployment/deploy_requestor.sh ---
#!/bin/bash

# default params
network=${network:-testnet}
accountId=${accountId:-oracle.account.testnet}
oracle=${oracle:-flux-dev}
stakeToken=${stakeToken:-v2.wnear.flux-dev}

while [ $# -gt 0 ]; do

   if [[ $1 == *"--"* ]]; then
        param="${1/--/}"
        declare $param="$2"
        # echo $1 $2 // Optional to see the parameter:value result
   fi

  shift
done

NEAR_ENV=$network near deploy --accountId $accountId --wasmFile ./res/request_interface.wasm --initFunction new --initArgs '{"oracle": "'$oracle'", "stake_token": "'$stakeToken'"}'

'''
'''--- deployment/reset_account.sh ---
#!/bin/bash

# default params
network=${network:-testnet}
account=${accountId:-flux-dev}
master=${master:-flux-dev}
initialBalance=${initialBalance:-5}

while [ $# -gt 0 ]; do

   if [[ $1 == *"--"* ]]; then
        param="${1/--/}"
        declare $param="$2"
        # echo $1 $2 // Optional to see the parameter:value result
   fi

  shift
done

NEAR_ENV=$network near delete $account $master
NEAR_ENV=$network near create-account $account --masterAccount $master --initialBalance $initialBalance

'''
'''--- oracle/Cargo.toml ---
[package]
name = "oracle"
version = "0.1.0"
authors = ["jasperdg <jasperdegooijer@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { git = "https://github.com/near/near-sdk-rs.git", rev="249dacdcd3fd34bc00f0895a275f33f05cd910c1" }
uint = { version = "0.9.0", default-features = false }
serde = "1.0.118"

[dev-dependencies]
near-sdk-sim = { git = "https://github.com/near/near-sdk-rs.git", rev="249dacdcd3fd34bc00f0895a275f33f05cd910c1" }
token = { path = "./../token" }
request-interface = { path = "./../request-interface" }
'''
'''--- oracle/scripts/build.sh ---
#!/bin/bash
set -e
cd ../
bash build.sh
'''
'''--- oracle/scripts/flags.sh ---
#!/bin/bash

if [ -z "$KEEP_NAMES" ]; then
  export RUSTFLAGS='-C link-arg=-s'
else
  export RUSTFLAGS=''
fi
'''
'''--- oracle/scripts/test.sh ---
bash ./scripts/build.sh
cargo test -p oracle $1 -- --nocapture
'''
'''--- oracle/src/callback_args.rs ---
use crate::*;
use crate::data_request::DataRequestDataType;
use near_sdk::serde::{ Serialize, Deserialize };
use types::*;

const MAX_SOURCES: u8 = 8;
const MAX_TAGS: u8 = 8;
const MIN_OUTCOMES: u8 = 2;
const MIN_PERIOD_MULTIPLIER: u64 = 3;

#[derive(Serialize, Deserialize)]
pub struct NewDataRequestArgs {
    pub sources: Vec<data_request::Source>,
    pub tags: Option<Vec<String>>,
    pub description: Option<String>,
    pub outcomes: Option<Vec<String>>,
    pub challenge_period: WrappedTimestamp,
    pub data_type: DataRequestDataType,
    pub creator: AccountId,
}

impl Contract {
    pub fn dr_validate(&self, data_request: &NewDataRequestArgs) {
        let config = self.get_config();
        let challenge_period: u64 = data_request.challenge_period.into();
        let default_challenge_window_duration: u64 = config.default_challenge_window_duration.into();
        let min_initial_challenge_window_duration: u64 = config.min_initial_challenge_window_duration.into();
        
        assert!((data_request.description.is_none() && data_request.sources.len() as u8 != 0) || data_request.description.is_some(), "Description should be filled when no sources are given");
        assert!(data_request.sources.len() as u8 <= MAX_SOURCES, "Too many sources provided, max sources is: {}", MAX_SOURCES);
        assert!(challenge_period >= u64::from(min_initial_challenge_window_duration), "Challenge shorter than minimum challenge period of {}", min_initial_challenge_window_duration);
        assert!(challenge_period <= default_challenge_window_duration * MIN_PERIOD_MULTIPLIER, "Challenge period exceeds maximum challenge period of {}", default_challenge_window_duration * MIN_PERIOD_MULTIPLIER);
        assert!(
            data_request.tags.is_none() ||
            data_request.tags.as_ref().unwrap().len() as u8 <= MAX_TAGS,
            "Too many tags provided, max tags is: {}",
            MAX_TAGS
        );
        assert!(
            data_request.outcomes.is_none() ||
            data_request.outcomes.as_ref().unwrap().len() as u8 <= config.max_outcomes &&
            data_request.outcomes.as_ref().unwrap().len() as u8 >= MIN_OUTCOMES,
            "Invalid outcome list either exceeds min of: {} or max of {}",
            MIN_OUTCOMES,
            config.max_outcomes
        );
    }
}

#[derive(Serialize, Deserialize)]
pub struct StakeDataRequestArgs {
    pub id: U64,
    pub outcome: Outcome
}

#[derive(Serialize, Deserialize)]
pub struct ChallengeDataRequestArgs {
    pub id: U64,
    pub answer: Outcome
}
'''
'''--- oracle/src/data_request.rs ---
use crate::*;

use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize };
use near_sdk::json_types::{U64, U128};
use near_sdk::serde::{ Deserialize, Serialize };
use near_sdk::{ env, Balance, AccountId, PromiseOrValue, Promise, ext_contract };
use near_sdk::collections::{ Vector };

use crate::resolution_window::*;
use crate::types::*;
use crate::helpers::multiply_stake;
use crate::logger;
use crate::fungible_token::{ fungible_token_transfer };

pub const PERCENTAGE_DIVISOR: u16 = 10_000;
pub const FINALIZATION_GAS: u64 = 250_000_000_000_000;

#[ext_contract]
trait ExtSelf {
    fn dr_proceed_finalization(request_id: U64, sender: AccountId);
}

#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Clone)]
pub struct Source {
    pub end_point: String, // pro.coinbase.com/USD/ETH
    pub source_path: String // data.price.usdeth
}

#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Debug, PartialEq, Clone)]
pub enum DataRequestDataType {
    Number(U128),
    String,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct DataRequest {
    pub id: u64,
    pub description: Option<String>,
    pub sources: Vec<Source>,
    pub outcomes: Option<Vec<String>>,
    pub requestor: Requestor, // Requestor contract
    pub creator: AccountId, // Account to return the validity bond to
    pub finalized_outcome: Option<Outcome>,
    pub resolution_windows: Vector<ResolutionWindow>,
    pub global_config_id: u64, // Config id
    pub request_config: DataRequestConfig, // Config enforced by global parameters
    pub initial_challenge_period: Duration, // challenge period for first resolution
    pub final_arbitrator_triggered: bool,
    pub tags: Option<Vec<String>>,
    pub data_type: DataRequestDataType,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct DataRequestConfig {
    default_challenge_window_duration: Duration,
    final_arbitrator_invoke_amount: Balance,
    final_arbitrator: AccountId,
    validity_bond: Balance,
    pub paid_fee: Balance,
    pub stake_multiplier: Option<u16>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub struct DataRequestSummary {
    pub id: u64,
    pub description: Option<String>,
    pub sources: Vec<Source>,
    pub outcomes: Option<Vec<String>>,
    pub requestor: Requestor,
    pub request_config: DataRequestConfigSummary,
    pub creator: AccountId,
    pub finalized_outcome: Option<Outcome>,
    pub resolution_windows: Vec<ResolutionWindowSummary>,
    pub global_config_id: U64,
    pub initial_challenge_period: U64,
    pub final_arbitrator_triggered: bool,
    pub tags: Option<Vec<String>>,
    pub data_type: DataRequestDataType,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub struct DataRequestConfigSummary {
    pub validity_bond: WrappedBalance,
    pub paid_fee: WrappedBalance,
    pub stake_multiplier: Option<u16>,
}

trait DataRequestChange {
    fn new(requestor: Requestor, id: u64, global_config_id: u64, global_config: &oracle_config::OracleConfig, paid_fee: Balance, request_data: NewDataRequestArgs) -> Self;
    fn stake(&mut self, sender: AccountId, outcome: Outcome, amount: Balance) -> Balance;
    fn unstake(&mut self, sender: AccountId, round: u16, outcome: Outcome, amount: Balance) -> Balance;
    fn finalize(&mut self);
    fn invoke_final_arbitrator(&mut self, bond_size: Balance) -> bool;
    fn finalize_final_arbitrator(&mut self, outcome: Outcome);
    fn claim(&mut self, account_id: String) -> ClaimRes;
    fn return_validity_bond(&self, token: AccountId) -> PromiseOrValue<bool>;
}

impl DataRequestChange for DataRequest {
    fn new(
        requestor: Requestor,
        id: u64,
        global_config_id: u64,
        config: &oracle_config::OracleConfig,
        paid_fee: Balance, 
        request_data: NewDataRequestArgs
    ) -> Self {
        let resolution_windows = Vector::new(format!("rw{}", id).as_bytes().to_vec());

        
        Self {
            id,
            sources: request_data.sources,
            outcomes: request_data.outcomes,
            requestor: requestor.clone(),
            finalized_outcome: None,
            resolution_windows,
            global_config_id,
            request_config: DataRequestConfig {
                default_challenge_window_duration: config.default_challenge_window_duration.into(),
                final_arbitrator_invoke_amount: config.final_arbitrator_invoke_amount.into(),
                final_arbitrator: config.final_arbitrator.to_string(),
                validity_bond: config.validity_bond.into(),
                stake_multiplier: requestor.stake_multiplier,
                paid_fee
            },
            initial_challenge_period: request_data.challenge_period.into(),
            final_arbitrator_triggered: false,
            description: request_data.description,
            tags: request_data.tags,
            data_type: request_data.data_type,
            creator: request_data.creator,
        }
    }

    // @returns amount of tokens that didn't get staked
    fn stake(&mut self,
        sender: AccountId,
        outcome: Outcome,
        amount: Balance
    ) -> Balance {
        let mut window = self.resolution_windows
            .iter()
            .last()
            .unwrap_or_else( || {
                ResolutionWindow::new(self.id, 0, self.calc_resolution_bond(), self.initial_challenge_period, env::block_timestamp())
            });
        
        let unspent = window.stake(sender, outcome, amount);

        // If first window push it to vec, else replace updated window struct
        if self.resolution_windows.len() == 0 {
            self.resolution_windows.push(&window);
        } else {
            self.resolution_windows.replace(
                self.resolution_windows.len() - 1, // Last window
                &window
            );
        }

        // Check if this stake is bonded for the current window and if the final arbitrator should be invoked.
        // If the final arbitrator is invoked other stake won't come through.
        if window.bonded_outcome.is_some() && !self.invoke_final_arbitrator(window.bond_size) {
            self.resolution_windows.push(
                &ResolutionWindow::new(
                    self.id,
                    self.resolution_windows.len() as u16,
                    window.bond_size,
                    self.request_config.default_challenge_window_duration,
                    env::block_timestamp()
                )
            );
        }
        
        unspent
    }

    // @returns amount of tokens that didn't get staked
    fn unstake(&mut self, sender: AccountId, round: u16, outcome: Outcome, amount: Balance) -> Balance {        
        let mut window = self.resolution_windows
            .get(round as u64)
            .expect("ERR_NO_RESOLUTION_WINDOW");

        window.unstake(sender, outcome, amount)
    }

    fn finalize(&mut self) {
        self.finalized_outcome = self.get_final_outcome();
    }

    // @returns wether final arbitrator was triggered
    fn invoke_final_arbitrator(&mut self, bond_size: Balance) -> bool {
        let should_invoke = bond_size >= self.request_config.final_arbitrator_invoke_amount;
        if should_invoke { self.final_arbitrator_triggered = true }
        self.final_arbitrator_triggered
    }

    fn finalize_final_arbitrator(&mut self, outcome: Outcome) {
        self.finalized_outcome = Some(outcome);
    }

    fn claim(&mut self, account_id: String) -> ClaimRes {
        // Metrics for calculating payout
        let mut total_correct_staked = 0;
        let mut total_incorrect_staked = 0;
        let mut user_correct_stake = 0;

        // For any round after the resolution round handle generically
        for round in 0..self.resolution_windows.len() {
            let mut window = self.resolution_windows.get(round).unwrap();
            let stake_state: WindowStakeResult = window.claim_for(account_id.to_string(), self.finalized_outcome.as_ref().unwrap());
            match stake_state {
                WindowStakeResult::Correct(correctly_staked) => {
                    total_correct_staked += correctly_staked.bonded_stake;
                    user_correct_stake += correctly_staked.user_stake;
                },
                WindowStakeResult::Incorrect(incorrectly_staked) => {
                    total_incorrect_staked += incorrectly_staked
                },
                WindowStakeResult::NoResult => ()
            }

            self.resolution_windows.replace(round as u64, &window);
        };

        let stake_profit = match total_correct_staked {
            0 => 0,
            _ => helpers::calc_product(user_correct_stake, total_incorrect_staked, total_correct_staked)
        };

        let fee_profit = match total_correct_staked {
            0 => 0,
            _ => helpers::calc_product(user_correct_stake, self.request_config.paid_fee, total_correct_staked)
        };

        logger::log_claim(&account_id, self.id, total_correct_staked, total_incorrect_staked, user_correct_stake, stake_profit, fee_profit);

        ClaimRes {
            payment_token_payout: fee_profit,
            stake_token_payout: user_correct_stake + stake_profit
        }
    }

    // @notice Return what's left of validity_bond to requestor
    fn return_validity_bond(&self, token: AccountId) -> PromiseOrValue<bool> {
        match self.finalized_outcome.as_ref().unwrap() {
            Outcome::Answer(_) => {
                PromiseOrValue::Promise(fungible_token_transfer(token, self.creator.clone(), self.request_config.validity_bond))
            },
            Outcome::Invalid => PromiseOrValue::Value(false)

        }
    }
}

trait DataRequestView {
    fn assert_valid_outcome(&self, outcome: &Outcome);
    fn assert_valid_outcome_type(&self, outcome: &Outcome);
    fn assert_can_stake_on_outcome(&self, outcome: &Outcome);
    fn assert_not_finalized(&self);
    fn assert_finalized(&self);
    fn assert_can_finalize(&self);
    fn assert_final_arbitrator(&self);
    fn assert_final_arbitrator_invoked(&self);
    fn assert_final_arbitrator_not_invoked(&self);
    fn get_final_outcome(&self) -> Option<Outcome>;
    fn calc_resolution_bond(&self) -> Balance;
    fn summarize_dr(&self) -> DataRequestSummary;
}

impl DataRequestView for DataRequest {
    fn assert_valid_outcome(&self, outcome: &Outcome) {
        match &self.outcomes {
            Some(outcomes) => match outcome {
                Outcome::Answer(outcome) => {
                    // Only strings can be staked when an array of outcomes are set
                    match outcome {
                        AnswerType::String(string_answer) => assert!(outcomes.contains(&string_answer), "Incompatible outcome"),
                        _ => panic!("ERR_OUTCOME_NOT_STRING"),
                    };

                }
                Outcome::Invalid => ()
            },
            None => ()
        }
    }

    fn assert_valid_outcome_type(&self, outcome: &Outcome) {
        match outcome {
            Outcome::Answer(answer) => {
                match answer {
                    AnswerType::String(_) => assert_eq!(self.data_type, DataRequestDataType::String, "ERR_WRONG_OUTCOME_TYPE"),
                    AnswerType::Number(ans_num) => {
                        match self.data_type {
                            DataRequestDataType::Number(dr_multiplier) => assert_eq!(dr_multiplier, ans_num.multiplier, "ERR_WRONG_MULTIPLIER"),
                            _ => panic!("ERR_WRONG_OUTCOME_TYPE"),
                        }
                    }
                }
            }
            _ => ()
        }
    }

    fn assert_can_stake_on_outcome(&self, outcome: &Outcome) {
        if self.resolution_windows.len() > 1 {
            let last_window = self.resolution_windows.get(self.resolution_windows.len() - 2).unwrap();
            assert_ne!(&last_window.bonded_outcome.unwrap(), outcome, "Outcome is incompatible for this round");
        }
    }

    fn assert_not_finalized(&self) {
        assert!(self.finalized_outcome.is_none(), "Can't stake in finalized DataRequest");
    }

    fn assert_finalized(&self) {
        assert!(self.finalized_outcome.is_some(), "DataRequest is not finalized");
    }

    fn assert_can_finalize(&self) {
        let window = self.resolution_windows.get(self.resolution_windows.len() - 1).unwrap();
        assert!(!self.final_arbitrator_triggered, "Can only be finalized by final arbitrator: {}", self.request_config.final_arbitrator);
        assert!(env::block_timestamp() >= window.end_time, "Error can only be finalized after final dispute round has timed out");
        self.assert_not_finalized();
    }

    fn assert_final_arbitrator(&self) {
        assert_eq!(
            self.request_config.final_arbitrator,
            env::predecessor_account_id(),
            "sender is not the final arbitrator of this `DataRequest`, the final arbitrator is: {}",
            self.request_config.final_arbitrator
        );
    }

    fn assert_final_arbitrator_invoked(&self) {
        assert!(
            self.final_arbitrator_triggered,
            "Final arbitrator can not finalize `DataRequest` with id: {}",
            self.id
        );
    }

    fn assert_final_arbitrator_not_invoked(&self) {
        assert!(
            !self.final_arbitrator_triggered,
            "Final arbitrator is invoked for `DataRequest` with id: {}",
            self.id
        );
    }

    fn get_final_outcome(&self) -> Option<Outcome> {
        assert!(self.resolution_windows.iter().count() >= 2, "No bonded outcome found or final arbitrator triggered after first round");
        let last_bonded_window_i = self.resolution_windows.len() - 2; // Last window after end_time never has a bonded outcome
        let last_bonded_window = self.resolution_windows.get(last_bonded_window_i).unwrap();
        last_bonded_window.bonded_outcome
    }

    /**
     * @notice Calculates the size of the resolution bond. If the accumulated fee is smaller than the validity bond, we payout the validity bond to validators, thus they have to stake double in order to be
     * eligible for the reward, in the case that the fee is greater than the validity bond validators need to have a cumulative stake of double the fee amount
     * @returns The size of the initial `resolution_bond` denominated in `stake_token`
     */
    fn calc_resolution_bond(&self) -> Balance {
        let base_bond = if self.request_config.paid_fee >= self.request_config.validity_bond {
            self.request_config.paid_fee 
        } else {
            self.request_config.validity_bond
        };

        env::log(format!("base bond: {:?} multiplier: {:?}", base_bond, self.request_config.stake_multiplier).as_bytes());
        
        multiply_stake(base_bond, self.request_config.stake_multiplier)
    }

    /**
     * @notice Transforms a data request struct into another struct with Serde serialization
     */
    fn summarize_dr(&self) -> DataRequestSummary {
        // format resolution windows inside this data request
        let mut resolution_windows = Vec::new();
        for i in self.resolution_windows.iter() {
            let rw = ResolutionWindowSummary {
                round: i.round,
                start_time: U64(i.start_time),
                end_time: U64(i.end_time),
                bond_size: U128(i.bond_size),
                bonded_outcome: i.bonded_outcome,
            };
            resolution_windows.push(rw);
        }

        // format data request
        DataRequestSummary {
            id: self.id,
            description: self.description.clone(),
            sources: self.sources.clone(),
            outcomes: self.outcomes.clone(),
            requestor: self.requestor.clone(),
            creator: self.creator.clone(),
            finalized_outcome: self.finalized_outcome.clone(),
            resolution_windows: resolution_windows,
            global_config_id: U64(self.global_config_id),
            initial_challenge_period: U64(self.initial_challenge_period),
            final_arbitrator_triggered: self.final_arbitrator_triggered,
            tags: self.tags.clone(),
            data_type: self.data_type.clone(),
            request_config: DataRequestConfigSummary {
                validity_bond: U128(self.request_config.validity_bond),
                paid_fee: U128(self.request_config.paid_fee),
                stake_multiplier: self.request_config.stake_multiplier,
            }
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn dr_exists(&self, id: U64) -> bool {
        self.data_requests.get(id.into()).is_some()
    }

    // Merge config and payload
    pub fn dr_new(&mut self, sender: AccountId, amount: Balance, payload: NewDataRequestArgs) -> Balance {
        let config = self.get_config();
        let validity_bond: u128 = config.validity_bond.into();
        self.assert_whitelisted(sender.to_string());
        self.assert_sender(&config.payment_token);
        self.dr_validate(&payload);
        assert!(
            amount >= validity_bond,
            "Validity bond of {} not reached, received only {}",
            validity_bond,
            amount
        );

        let paid_fee = amount - validity_bond;
        
        let requestor = self.whitelist.whitelist_get_expect(&sender);
        let dr = DataRequest::new(
            requestor,
            self.data_requests.len() as u64, // dr_id
            self.configs.len() - 1, // dr's config id
            &config,
            paid_fee,
            payload
        );

        logger::log_new_data_request(&dr);

        self.data_requests.push(&dr);

        0
    }

    #[payable]
    pub fn dr_stake(&mut self, sender: AccountId, amount: Balance, payload: StakeDataRequestArgs) -> PromiseOrValue<WrappedBalance> {
        let mut dr = self.dr_get_expect(payload.id.into());
        let config = self.configs.get(dr.global_config_id).unwrap();
        self.assert_sender(&config.stake_token);
        dr.assert_final_arbitrator_not_invoked();
        dr.assert_can_stake_on_outcome(&payload.outcome);
        dr.assert_valid_outcome(&payload.outcome);
        dr.assert_valid_outcome_type(&payload.outcome);
        dr.assert_not_finalized();

        let unspent_stake = dr.stake(sender, payload.outcome, amount);
        logger::log_update_data_request(&dr);
        self.data_requests.replace(payload.id.into(), &dr);

        PromiseOrValue::Value(U128(unspent_stake))
    }

    #[payable]
    pub fn dr_unstake(&mut self, request_id: U64, resolution_round: u16, outcome: Outcome, amount: U128) {
        let initial_storage = env::storage_usage();

        let mut dr = self.dr_get_expect(request_id.into());
        let unstaked = dr.unstake(env::predecessor_account_id(), resolution_round, outcome, amount.into());
        let config = self.configs.get(dr.global_config_id).unwrap();

        helpers::refund_storage(initial_storage, env::predecessor_account_id());
        logger::log_update_data_request(&dr);

        fungible_token_transfer(config.stake_token, env::predecessor_account_id(), unstaked);
    }

    /**
     * @returns amount of tokens claimed
     */
    #[payable]
    pub fn dr_claim(&mut self, account_id: String, request_id: U64) -> Promise {
        let initial_storage = env::storage_usage();

        let mut dr = self.dr_get_expect(request_id.into());
        dr.assert_finalized();
        let stake_payout = dr.claim(account_id.to_string());
        let config = self.configs.get(dr.global_config_id).unwrap();

        logger::log_update_data_request(&dr);
        helpers::refund_storage(initial_storage, env::predecessor_account_id());

        // transfer owed stake tokens
        let prev_prom = if stake_payout.stake_token_payout > 0 {
            Some(fungible_token_transfer(config.stake_token, account_id.to_string(), stake_payout.stake_token_payout))
        } else {
            None
        };
        
        if stake_payout.payment_token_payout > 0 {
            // distribute fee + bond
            match prev_prom {
                Some(p) => p.then(fungible_token_transfer(config.payment_token, account_id, stake_payout.payment_token_payout)),
                None => fungible_token_transfer(config.payment_token, account_id, stake_payout.payment_token_payout)
            }
        } else {
            match prev_prom {
                Some(p) => p,
                None => panic!("can't claim 0")
            }
        }
    }

    pub fn dr_finalize(&mut self, request_id: U64) {
        let mut dr = self.dr_get_expect(request_id.into());
        dr.assert_can_finalize();
        let final_outcome = dr.get_final_outcome();
        
        dr.requestor.set_outcome(request_id, final_outcome.unwrap(), dr.tags.clone(), false);

        let config = self.configs.get(dr.global_config_id).unwrap();

        dr.finalize();
        dr.return_validity_bond(config.payment_token);

        self.data_requests.replace(request_id.into(), &dr);

        logger::log_update_data_request(&dr);
    }

    #[payable]
    pub fn dr_final_arbitrator_finalize(&mut self, request_id: U64, outcome: Outcome) -> PromiseOrValue<bool> {
        let initial_storage = env::storage_usage();

        let mut dr = self.dr_get_expect(request_id);
        dr.assert_not_finalized();
        dr.assert_final_arbitrator();
        dr.assert_valid_outcome(&outcome);
        dr.assert_final_arbitrator_invoked();
        dr.finalize_final_arbitrator(outcome.clone());

        let config = self.configs.get(dr.global_config_id).unwrap();
        dr.requestor.set_outcome(request_id, outcome, dr.tags.clone(), true);
        self.data_requests.replace(request_id.into(), &dr);

        logger::log_update_data_request(&dr);
        helpers::refund_storage(initial_storage, env::predecessor_account_id());

        dr.return_validity_bond(config.payment_token)
    }

    fn dr_get_expect(&self, id: U64) -> DataRequest {
        self.data_requests.get(id.into()).expect("ERR_DATA_REQUEST_NOT_FOUND")
    }

    pub fn get_request_by_id(&self, id: U64) -> Option<DataRequestSummary> {
        let dr = self.data_requests.get(id.into());
        match dr {
            None => None,
            Some(d) => Some(d.summarize_dr())
        }
    }

    pub fn get_latest_request(&self) -> Option<DataRequestSummary> {
        if self.data_requests.len() < 1 {
            return None;
        }
        let dr = self.data_requests.get(self.data_requests.len() - 1);
        match dr {
            None => None,
            Some(d) => Some(d.summarize_dr())
        }
    }

    pub fn get_outcome(&self, dr_id: U64) -> Outcome {
        self.data_requests
        .get(dr_id.into()).expect("Data request with does not exist")
        .finalized_outcome.expect("Data request is not yet finalized")
    }

    pub fn get_requests(&self, from_index: U64, limit: U64) -> Vec<DataRequestSummary> {
        let i: u64 = from_index.into();
        (i..std::cmp::min(i + u64::from(limit), self.data_requests.len()))
            .map(|index| self.data_requests.get(index).unwrap().summarize_dr())
            .collect()
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod mock_token_basic_tests {
    use near_sdk::{ MockedBlockchain };
    use near_sdk::{ testing_env, VMContext };
    use crate::requestor_handler::{Requestor};
    use crate::data_request::AnswerType;
    use super::*;
    use fee_config::FeeConfig;

    fn alice() -> AccountId {
        "alice.near".to_string()
    }

    fn bob() -> AccountId {
        "bob.near".to_string()
    }

    fn carol() -> AccountId {
        "carol.near".to_string()
    }

    fn dave() -> AccountId {
        "dave.near".to_string()
    }

    fn token() -> AccountId {
        "token.near".to_string()
    }

    fn gov() -> AccountId {
        "gov.near".to_string()
    }

    fn sum_claim_res(claim_res: ClaimRes) -> u128 {
        claim_res.payment_token_payout + claim_res.stake_token_payout
    }

    fn registry_entry(account: AccountId) -> Requestor {
        Requestor {
            interface_name: account.clone(),
            account_id: account.clone(),
            stake_multiplier: None,
            code_base_url: None
        }
    }

    fn finalize(contract: &mut Contract, dr_id: u64) -> &mut Contract {
        let mut dr = contract.dr_get_expect(U64(dr_id));
        dr.finalize();
        contract.data_requests.replace(0, &dr);
        contract
    }

    fn config() -> oracle_config::OracleConfig {
        oracle_config::OracleConfig {
            gov: gov(),
            final_arbitrator: alice(),
            payment_token: token(),
            stake_token: token(),
            validity_bond: U128(100),
            max_outcomes: 8,
            default_challenge_window_duration: U64(1000),
            min_initial_challenge_window_duration: U64(1000),
            final_arbitrator_invoke_amount: U128(250),
            fee: FeeConfig {
                flux_market_cap: U128(50000),
                total_value_staked: U128(10000),
                resolution_fee_percentage: 10_000,
            }
        }
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        VMContext {
            current_account_id: token(),
            signer_account_id: bob(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 10000 * 10u128.pow(24),
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 1000 * 10u128.pow(24),
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    #[should_panic(expected = "Invalid outcome list either exceeds min of: 2 or max of 8")]
    fn dr_new_single_outcome() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        contract.dr_new(bob(), 100, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: Some(vec!["a".to_string()].to_vec()),
            challenge_period: U64(1500),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
    }

    #[test]
    #[should_panic(expected = "Err predecessor is not whitelisted")]
    fn dr_new_non_whitelisted() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        contract.dr_new(alice(), 100, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: None,
            challenge_period: U64(0),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
    }

    #[test]
    #[should_panic(expected = "This function can only be called by token.near")]
    fn dr_new_non_payment_token() {
        testing_env!(get_context(alice()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        contract.dr_new(bob(), 100, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: None,
            challenge_period: U64(0),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
    }

    #[test]
    #[should_panic(expected = "Too many sources provided, max sources is: 8")]
    fn dr_new_arg_source_exceed() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        let x1 = data_request::Source {end_point: "1".to_string(), source_path: "1".to_string()};
        let x2 = data_request::Source {end_point: "2".to_string(), source_path: "2".to_string()};
        let x3 = data_request::Source {end_point: "3".to_string(), source_path: "3".to_string()};
        let x4 = data_request::Source {end_point: "4".to_string(), source_path: "4".to_string()};
        let x5 = data_request::Source {end_point: "5".to_string(), source_path: "5".to_string()};
        let x6 = data_request::Source {end_point: "6".to_string(), source_path: "6".to_string()};
        let x7 = data_request::Source {end_point: "7".to_string(), source_path: "7".to_string()};
        let x8 = data_request::Source {end_point: "8".to_string(), source_path: "8".to_string()};
        let x9 = data_request::Source {end_point: "9".to_string(), source_path: "9".to_string()};
        contract.dr_new(bob(), 100, NewDataRequestArgs{
            sources: vec![x1,x2,x3,x4,x5,x6,x7,x8,x9],
            outcomes: None,
            challenge_period: U64(1000),
            description: None,
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
    }

    #[test]
    #[should_panic(expected = "Invalid outcome list either exceeds min of: 2 or max of 8")]
    fn dr_new_arg_outcome_exceed() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        contract.dr_new(bob(), 100, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: Some(vec![
                "1".to_string(),
                "2".to_string(),
                "3".to_string(),
                "4".to_string(),
                "5".to_string(),
                "6".to_string(),
                "7".to_string(),
                "8".to_string(),
                "9".to_string()
            ]),
            challenge_period: U64(1000),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
    }

    #[test]
    #[should_panic(expected = "Description should be filled when no sources are given")]
    fn dr_description_required_no_sources() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        contract.dr_new(bob(), 100, NewDataRequestArgs{
            sources: vec![],
            outcomes: None,
            challenge_period: U64(1000),
            description: None,
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
    }

    #[test]
    #[should_panic(expected = "Challenge shorter than minimum challenge period")]
    fn dr_new_arg_challenge_period_below_min() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        contract.dr_new(bob(), 100, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: None,
            challenge_period: U64(999),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
    }

    #[test]
    #[should_panic(expected = "Challenge period exceeds maximum challenge period")]
    fn dr_new_arg_challenge_period_exceed() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        contract.dr_new(bob(), 100, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: None,
            challenge_period: U64(3001),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
    }

    #[test]
    #[should_panic(expected = "Validity bond of 100 not reached, received only 90")]
    fn dr_new_not_enough_amount() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        contract.dr_new(bob(), 90, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: None,
            challenge_period: U64(1500),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
    }

    #[test]
    fn dr_new_success() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        let amount : Balance = contract.dr_new(bob(), 100, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: None,
            challenge_period: U64(1500),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
        assert_eq!(amount, 0);
    }

    fn dr_new(contract : &mut Contract) {
        contract.dr_new(bob(), 100, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: Some(vec!["a".to_string(), "b".to_string()].to_vec()),
            challenge_period: U64(1500),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
    }

    #[test]
    #[should_panic(expected = "This function can only be called by token.near")]
    fn dr_stake_non_stake_token() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        testing_env!(get_context(alice()));
        contract.dr_stake(alice(),100,  StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("42".to_string()))
        });
    }

    #[test]
    #[should_panic(expected = "ERR_DATA_REQUEST_NOT_FOUND")]
    fn dr_stake_not_existing() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        contract.dr_stake(alice(),100,  StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("42".to_string()))
        });
    }

    #[test]
    #[should_panic(expected = "Incompatible outcome")]
    fn dr_stake_incompatible_answer() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        contract.dr_stake(alice(),100,  StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("42".to_string()))
        });
    }

    #[test]
    #[should_panic(expected = "Can't stake in finalized DataRequest")]
    fn dr_stake_finalized_market() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });

        let mut ct : VMContext = get_context(token());
        ct.block_timestamp = 1501;
        testing_env!(ct);

        let contract = finalize(&mut contract, 0);
        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });
    }

    #[test]
    #[should_panic(expected = "Invalid outcome list either exceeds min of: 2 or max of 8")]
    fn dr_invalid_outcome_list() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        contract.dr_new(bob(), 100, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: Some(vec!["a".to_string()].to_vec()),
            challenge_period: U64(1500),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
    }

    #[test]
    fn dr_stake_success_partial() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        let _b = contract.dr_stake(alice(), 5, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        // assert_eq!(b, 0, "Invalid balance");

        let request : DataRequest = contract.data_requests.get(0).unwrap();
        assert_eq!(request.resolution_windows.len(), 1);

        let round0 : ResolutionWindow = request.resolution_windows.get(0).unwrap();
        assert_eq!(round0.round, 0);
        assert_eq!(round0.end_time, 1500);
        assert_eq!(round0.bond_size, 200);
    }

    #[test]
    fn dr_stake_success_full_at_t0() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        let _b = contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        // assert_eq!(b, 0, "Invalid balance");

        let request : DataRequest = contract.data_requests.get(0).unwrap();
        assert_eq!(request.resolution_windows.len(), 2);

        let round0 : ResolutionWindow = request.resolution_windows.get(0).unwrap();
        assert_eq!(round0.round, 0);
        assert_eq!(round0.end_time, 1500);
        assert_eq!(round0.bond_size, 200);

        let round1 : ResolutionWindow = request.resolution_windows.get(1).unwrap();
        assert_eq!(round1.round, 1);
        assert_eq!(round1.end_time, 1000);
        assert_eq!(round1.bond_size, 400);
    }

    #[test]
    fn dr_stake_success_overstake_at_t600() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        let mut ct : VMContext = get_context(token());
        ct.block_timestamp = 600;
        testing_env!(ct);

        let _b = contract.dr_stake(alice(), 300, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        // assert_eq!(b, 100, "Invalid balance");

        let request : DataRequest = contract.data_requests.get(0).unwrap();
        assert_eq!(request.resolution_windows.len(), 2);

        let round0 : ResolutionWindow = request.resolution_windows.get(0).unwrap();
        assert_eq!(round0.round, 0);
        assert_eq!(round0.end_time, 2100);
        assert_eq!(round0.bond_size, 200);

        let round1 : ResolutionWindow = request.resolution_windows.get(1).unwrap();
        assert_eq!(round1.round, 1);
        assert_eq!(round1.end_time, 1600);
        assert_eq!(round1.bond_size, 400);
    }

    #[test]
    #[should_panic(expected = "Can only be finalized by final arbitrator")]
    fn dr_finalize_final_arb() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut c: oracle_config::OracleConfig = config();
        c.final_arbitrator_invoke_amount = U128(150);
        let mut contract = Contract::new(whitelist, c);
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });

        contract.dr_finalize(U64(0));
    }

    #[test]
    #[should_panic(expected = "No bonded outcome found")]
    fn dr_finalize_no_resolutions() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        finalize(&mut contract, 0);
    }

    #[test]
    #[should_panic(expected = "Error can only be finalized after final dispute round has timed out")]
    fn dr_finalize_active_challenge() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });

        contract.dr_finalize(U64(0));
    }

    #[test]
    fn dr_finalize_success() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });

        let mut ct : VMContext = get_context(token());
        ct.block_timestamp = 1501;
        testing_env!(ct);

        let contract = finalize(&mut contract, 0);

        let request : DataRequest = contract.data_requests.get(0).unwrap();
        assert_eq!(request.resolution_windows.len(), 2);
        assert_eq!(request.finalized_outcome.unwrap(), data_request::Outcome::Answer(AnswerType::String("a".to_string())));
    }

    #[test]
    #[should_panic(expected = "Outcome is incompatible for this round")]
    fn dr_stake_same_outcome() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        contract.dr_stake(alice(), 300, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });

        contract.dr_stake(alice(), 500, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
    }

    fn dr_finalize(contract: &mut Contract, outcome: Outcome) {
        contract.dr_stake(alice(), 2000, StakeDataRequestArgs{
            id: U64(0),
            outcome: outcome
        });

        let mut ct : VMContext = get_context(token());
        ct.block_timestamp = 1501;
        testing_env!(ct);

        finalize(contract, 0);
    }

    #[test]
    #[should_panic(expected = "ERR_DATA_REQUEST_NOT_FOUND")]
    fn dr_unstake_invalid_id() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        contract.dr_unstake(U64(0), 0, data_request::Outcome::Answer(AnswerType::String("a".to_string())), U128(0));
    }

    #[test]
    #[should_panic(expected = "Cannot withdraw from bonded outcome")]
    fn dr_unstake_bonded_outcome() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        contract.dr_unstake(U64(0), 0, data_request::Outcome::Answer(AnswerType::String("a".to_string())), U128(0));
    }

    #[test]
    #[should_panic(expected = "token.near has less staked on this outcome (0) than unstake amount")]
    fn dr_unstake_bonded_outcome_c() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        contract.dr_unstake(U64(0), 0, data_request::Outcome::Answer(AnswerType::String("c".to_string())), U128(1));
    }

    #[test]
    #[should_panic(expected = "alice.near has less staked on this outcome (10) than unstake amount")]
    fn dr_unstake_too_much() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        contract.dr_stake(alice(), 10, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });

        testing_env!(get_context(alice()));
        contract.dr_unstake(U64(0), 0, data_request::Outcome::Answer(AnswerType::String("b".to_string())), U128(11));
    }

    #[test]
    fn dr_unstake_success() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        let outcome = data_request::Outcome::Answer(AnswerType::String("b".to_string()));
        contract.dr_stake(alice(), 10, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });

        testing_env!(get_context(alice()));

        // verify initial storage
        assert_eq!(contract.
            data_requests.get(0).unwrap().
            resolution_windows.get(0).unwrap().
            user_to_outcome_to_stake.get(&alice()).unwrap().get(&outcome).unwrap(), 10);
        assert_eq!(contract.
            data_requests.get(0).unwrap().
            resolution_windows.get(0).unwrap().
            outcome_to_stake.get(&outcome).unwrap(), 10);

        contract.dr_unstake(U64(0), 0, data_request::Outcome::Answer(AnswerType::String("b".to_string())), U128(1));

        // verify storage after unstake
        assert_eq!(contract.
            data_requests.get(0).unwrap().
            resolution_windows.get(0).unwrap().
            user_to_outcome_to_stake.get(&alice()).unwrap().get(&outcome).unwrap(), 9);
        assert_eq!(contract.
            data_requests.get(0).unwrap().
            resolution_windows.get(0).unwrap().
            outcome_to_stake.get(&outcome).unwrap(), 9);
    }

    #[test]
    #[should_panic(expected = "ERR_DATA_REQUEST_NOT_FOUND")]
    fn dr_claim_invalid_id() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        contract.dr_claim(alice(), U64(0));
    }

    #[test]
    fn dr_claim_success() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        contract.dr_claim(alice(), U64(0));
    }

    #[test]
    fn d_claim_single() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        // validity bond
        assert_eq!(sum_claim_res(d.claim(alice())), 200);
    }

    #[test]
    fn d_claim_same_twice() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        // validity bond
        assert_eq!(sum_claim_res(d.claim(alice())), 200);
        assert_eq!(sum_claim_res(d.claim(alice())), 0);
    }

    #[test]
    fn d_validity_bond() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut config = config();
        config.validity_bond = U128(2);
        let mut contract = Contract::new(whitelist, config);
        dr_new(&mut contract);
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        // fees (100% of TVL)
        assert_eq!(sum_claim_res(d.claim(alice())), 294);
    }

    #[test]
    fn d_claim_double() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        contract.dr_stake(bob(), 100, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        // validity bond
        assert_eq!(sum_claim_res(d.claim(alice())), 100);
        assert_eq!(sum_claim_res(d.claim(bob())), 100);
    }

    #[test]
    fn d_claim_2rounds_single() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut config = config();
        config.final_arbitrator_invoke_amount = U128(1000);
        let mut contract = Contract::new(whitelist, config);
        dr_new(&mut contract);

        contract.dr_stake(bob(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("b".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        // validity bond + round 0 stake
        assert_eq!(sum_claim_res(d.claim(alice())), 600);
        assert_eq!(sum_claim_res(d.claim(bob())), 0);
    }

    #[test]
    fn d_claim_2rounds_double() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut config = config();
        config.final_arbitrator_invoke_amount = U128(1000);
        let mut contract = Contract::new(whitelist, config);
        dr_new(&mut contract);

        contract.dr_stake(bob(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        contract.dr_stake(carol(), 100, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("b".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        // validity bond + round 0 stake
        assert_eq!(sum_claim_res(d.claim(alice())), 450);
        assert_eq!(sum_claim_res(d.claim(bob())), 0);
        assert_eq!(sum_claim_res(d.claim(carol())), 150);
    }

    #[test]
    fn d_claim_3rounds_single() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut config = config();
        config.final_arbitrator_invoke_amount = U128(1000);
        let mut contract = Contract::new(whitelist, config);
        dr_new(&mut contract);

        contract.dr_stake(bob(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        contract.dr_stake(carol(), 400, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        // round 1 stake
        assert_eq!(sum_claim_res(d.claim(alice())), 1120);
        // validity bond
        assert_eq!(sum_claim_res(d.claim(bob())), 280);
        assert_eq!(sum_claim_res(d.claim(carol())), 0);
    }

    #[test]
    fn d_claim_3rounds_double_round0() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut config = config();
        config.final_arbitrator_invoke_amount = U128(1000);
        let mut contract = Contract::new(whitelist, config);
        dr_new(&mut contract);

        contract.dr_stake(bob(), 100, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        contract.dr_stake(dave(), 100, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        contract.dr_stake(carol(), 400, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        // round 1 stake
        assert_eq!(sum_claim_res(d.claim(alice())), 1120);
        // 50% of validity bond
        assert_eq!(sum_claim_res(d.claim(bob())), 140);
        assert_eq!(sum_claim_res(d.claim(carol())), 0);
        // 50% of validity bond
        assert_eq!(sum_claim_res(d.claim(dave())), 140);
    }

    #[test]
    fn d_claim_3rounds_double_round2() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut config = config();
        config.final_arbitrator_invoke_amount = U128(1000);
        let mut contract = Contract::new(whitelist, config);
        dr_new(&mut contract);

        contract.dr_stake(bob(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        contract.dr_stake(carol(), 400, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });
        contract.dr_stake(dave(), 300, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        dr_finalize(&mut contract, data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        // 5/8 of round 1 stake
        assert_eq!(sum_claim_res(d.claim(alice())), 700);
        // validity bond
        assert_eq!(sum_claim_res(d.claim(bob())), 280);
        assert_eq!(sum_claim_res(d.claim(carol())), 0);
        // 3/8 of round 1 stake
        assert_eq!(sum_claim_res(d.claim(dave())), 420);
    }

    #[test]
    fn d_claim_final_arb() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        // needed for final arb function
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        // This round exceeds final arb limit, will be used as signal
        contract.dr_stake(bob(), 400, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });

        testing_env!(get_context(alice()));
        contract.dr_final_arbitrator_finalize(U64(0), data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        assert_eq!(sum_claim_res(d.claim(alice())), 600);
        assert_eq!(sum_claim_res(d.claim(bob())), 0);
    }

    #[test]
    fn d_claim_final_arb_extra_round() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut config = config();
        config.final_arbitrator_invoke_amount = U128(600);
        let mut contract = Contract::new(whitelist, config);
        // needed for final arb function
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        contract.dr_stake(bob(), 400, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });
        // This round exceeds final arb limit, will be used as signal
        contract.dr_stake(carol(), 800, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });

        testing_env!(get_context(alice()));
        contract.dr_final_arbitrator_finalize(U64(0), data_request::Outcome::Answer(AnswerType::String("a".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        // validity bond
        assert_eq!(sum_claim_res(d.claim(alice())), 280);
        assert_eq!(sum_claim_res(d.claim(bob())), 0);
        // round 1 funds
        assert_eq!(sum_claim_res(d.claim(carol())), 1120);
    }

    #[test]
    fn d_claim_final_arb_extra_round2() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut config = config();
        config.final_arbitrator_invoke_amount = U128(600);
        let mut contract = Contract::new(whitelist, config);
        // needed for final arb function
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        contract.dr_stake(bob(), 400, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });
        // This round exceeds final arb limit, will be used as signal
        contract.dr_stake(carol(), 800, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });

        testing_env!(get_context(alice()));
        contract.dr_final_arbitrator_finalize(U64(0), data_request::Outcome::Answer(AnswerType::String("b".to_string())));

        let mut d = contract.data_requests.get(0).unwrap();
        assert_eq!(sum_claim_res(d.claim(alice())), 0);
        // validity bond (100), round0 (200), round2 (800)
        assert_eq!(sum_claim_res(d.claim(bob())), 1400);
        assert_eq!(sum_claim_res(d.claim(carol())), 0);
    }

    #[test]
    #[should_panic(expected = "Final arbitrator is invoked for `DataRequest` with id: 0")]
    fn dr_final_arb_invoked() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let config = config();
        let mut contract = Contract::new(whitelist, config);
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        contract.dr_stake(bob(), 400, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });
        contract.dr_stake(carol(), 400, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
    }

    #[test]
    #[should_panic(expected = "Incompatible outcome")]
    fn dr_final_arb_invalid_outcome() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let config = config();
        let mut contract = Contract::new(whitelist, config);
        // needed for final arb function
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });

        testing_env!(get_context(alice()));
        contract.dr_final_arbitrator_finalize(U64(0), data_request::Outcome::Answer(AnswerType::String("c".to_string())));
    }

    #[test]
    #[should_panic(expected = "assertion failed: `(left == right)`\n  left: `\"alice.near\"`,\n right: `\"bob.near\"`: sender is not the final arbitrator of this `DataRequest`, the final arbitrator is: alice.near")]
    fn dr_final_arb_non_arb() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let config = config();
        let mut contract = Contract::new(whitelist, config);
        // needed for final arb function
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });

        testing_env!(get_context(bob()));
        contract.dr_final_arbitrator_finalize(U64(0), data_request::Outcome::Answer(AnswerType::String("b".to_string())));
    }

    #[test]
    #[should_panic(expected = "Can't stake in finalized DataRequest")]
    fn dr_final_arb_twice() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let config = config();
        let mut contract = Contract::new(whitelist, config);
        // needed for final arb function
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        // This round exceeds final arb limit, will be used as signal
        contract.dr_stake(bob(), 400, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });

        testing_env!(get_context(alice()));
        contract.dr_final_arbitrator_finalize(U64(0), data_request::Outcome::Answer(AnswerType::String("b".to_string())));
        contract.dr_final_arbitrator_finalize(U64(0), data_request::Outcome::Answer(AnswerType::String("a".to_string())));
    }

    #[test]
    fn dr_final_arb_execute() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let config = config();
        let mut contract = Contract::new(whitelist, config);
        // needed for final arb function
        dr_new(&mut contract);

        contract.dr_stake(alice(), 200, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("a".to_string()))
        });
        // This round exceeds final arb limit, will be used as signal
        contract.dr_stake(bob(), 400, StakeDataRequestArgs{
            id: U64(0),
            outcome: data_request::Outcome::Answer(AnswerType::String("b".to_string()))
        });

        testing_env!(get_context(alice()));
        contract.dr_final_arbitrator_finalize(U64(0), data_request::Outcome::Answer(AnswerType::String("b".to_string())));

        let request : DataRequest = contract.data_requests.get(0).unwrap();
        assert_eq!(request.resolution_windows.len(), 2);
        assert_eq!(request.finalized_outcome.unwrap(), data_request::Outcome::Answer(AnswerType::String("b".to_string())));
    }

    #[test]
    fn dr_tvl_increases() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);

        let outcome = data_request::Outcome::Answer(AnswerType::String("b".to_string()));
        contract.dr_stake(alice(), 10, StakeDataRequestArgs{
            id: U64(0),
            outcome
        });
    }

    #[test]
    fn dr_fixed_fee() {
        testing_env!(get_context(token()));
        let bob_requestor = Requestor {
            interface_name: bob(),
            account_id: bob(),
            stake_multiplier: None,
            code_base_url: None,
        };
        let fixed_fee = 20; 
        let whitelist = Some(vec![bob_requestor, registry_entry(carol())]);
        let mut config = config();
        let validity_bond = 2;
        config.validity_bond = U128(validity_bond);
        let mut contract = Contract::new(whitelist, config);
        contract.dr_new(bob(), fixed_fee + validity_bond, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: Some(vec!["a".to_string(), "b".to_string()].to_vec()),
            challenge_period: U64(1500),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });
        dr_finalize(&mut contract, data_request::Outcome::Answer(
            data_request::AnswerType::String("a".to_string())
        ));

        let mut d = contract.data_requests.get(0).unwrap();

        assert_eq!(sum_claim_res(d.claim(alice())), 60);
    }

    #[test]
    fn dr_get_methods() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        dr_new(&mut contract);
        dr_new(&mut contract);
        dr_new(&mut contract);
        
        assert_eq!(contract.get_latest_request().unwrap().id, 2);
        assert_eq!(contract.get_request_by_id(U64(1)).unwrap().id, 1);

        assert_eq!(contract.get_requests(U64(0), U64(1))[0].id, 0);
        assert_eq!(contract.get_requests(U64(1), U64(1)).len(), 1);
        assert_eq!(contract.get_requests(U64(1), U64(2)).len(), 2);
        assert_eq!(contract.get_requests(U64(0), U64(3)).len(), 3);
    }
}

'''
'''--- oracle/src/fee_config.rs ---
use crate::*;
use near_sdk::serde::{ Deserialize, Serialize };

const MAX_RESOLUTION_FEE_PERCENTAGE: u32 = 5000; // 5% in 1e5

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
pub struct FeeConfig {
    // total market cap of FLUX/stake_token denominated in payment_token
    pub flux_market_cap: U128,
    // total value staked (TVS) of all request interfaces; denominated in payment_token
    pub total_value_staked: U128,
    // global percentage of TVS to pay out to resolutors; denominated in 1e5 so 1 = 0.001%, 100000 = 100%
    pub resolution_fee_percentage: u32,
}

#[near_bindgen]
impl Contract {
    // @notice sets FLUX market cap, TVS, and fee percentage by updating current oracle config
    // replaces the `fee` field inside oracle config with updated FeeConfig 
    pub fn update_fee_config(
        &mut self,
        new_fee_config: FeeConfig,
    ) {
        self.assert_gov();

        let initial_storage = env::storage_usage();

        assert!(
            u128::from(new_fee_config.total_value_staked) < u128::from(new_fee_config.flux_market_cap),
            "TVS must be lower than market cap"
        );
        assert!(
            new_fee_config.resolution_fee_percentage <= MAX_RESOLUTION_FEE_PERCENTAGE,
            "Exceeds max resolution fee percentage"
        );

        // get current config and replace fee field
        let mut updated_config = self.get_config();
        updated_config.fee = new_fee_config.clone();
        self.configs.replace(self.configs.len() - 1, &updated_config);

        logger::log_oracle_config(&updated_config, self.configs.len() - 1);
        helpers::refund_storage(initial_storage, env::predecessor_account_id());
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod mock_token_basic_tests {
    use near_sdk::{ MockedBlockchain };
    use near_sdk::{ testing_env, VMContext };
    use near_sdk::json_types::U128;
    use super::*;

    fn alice() -> AccountId {
        "alice.near".to_string()
    }
    
    fn bob() -> AccountId {
        "bob.near".to_string()
    }

    fn token() -> AccountId {
        "token.near".to_string()
    }
 
    fn gov() -> AccountId {
        "gov.near".to_string()
    }

    fn config(gov: AccountId) -> oracle_config::OracleConfig {
        oracle_config::OracleConfig {
            gov,
            final_arbitrator: alice(),
            payment_token: token(),
            stake_token: token(),
            validity_bond: U128(0),
            max_outcomes: 8,
            default_challenge_window_duration: U64(1000),
            min_initial_challenge_window_duration: U64(1000),
            final_arbitrator_invoke_amount: U128(25_000_000_000_000_000_000_000_000_000_000),
            fee: FeeConfig {
                flux_market_cap: U128(50000),
                total_value_staked: U128(10000),
                resolution_fee_percentage: 5000, // 5%
            }
        }
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        VMContext {
            current_account_id: token(),
            signer_account_id: bob(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1000 * 10u128.pow(24),
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 15600000000000000000000,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    fn g_update_fee() {
        testing_env!(get_context(gov()));
        let mut contract = Contract::new(None, config(gov()));
        let new_fee_config = FeeConfig {
            flux_market_cap: U128(1234),
            total_value_staked: U128(123),
            resolution_fee_percentage: 999, // .999%
        };
        contract.update_fee_config(new_fee_config);
    }
    
    #[test]
    #[should_panic(expected = "This method is only callable by the governance contract gov.near")]
    fn g_update_fee_invalid() {
        testing_env!(get_context(gov()));
        let mut contract = Contract::new(None, config(gov()));
        testing_env!(get_context(bob()));
        let new_fee_config = FeeConfig {
            flux_market_cap: U128(1234),
            total_value_staked: U128(123),
            resolution_fee_percentage: 999, // .999%
        };
        contract.update_fee_config(new_fee_config);
    }
}
'''
'''--- oracle/src/fungible_token.rs ---
use near_sdk::{
    AccountId,
    Gas,
    Promise,
    json_types::{
        U128,
    },
    ext_contract,
};

#[ext_contract]
pub trait FungibleToken {
    fn ft_transfer(&mut self, receiver_id: AccountId, amount: U128, memo: Option<String>);
    fn ft_balance_of(&self, account_id: AccountId);
}

const GAS_BASE_TRANSFER: Gas = 5_000_000_000_000;

pub fn fungible_token_transfer(token_account_id: AccountId, receiver_id: AccountId, value: u128) -> Promise {
    fungible_token::ft_transfer(
        receiver_id,
        U128(value),
        None,

        // NEAR params
        &token_account_id,
        1,
        GAS_BASE_TRANSFER
    )
}

'''
'''--- oracle/src/fungible_token_receiver.rs ---
use crate::*;

use near_sdk::serde::{ Serialize, Deserialize };
use near_sdk::serde_json;
use near_sdk::PromiseOrValue;

#[derive(Serialize, Deserialize)]
pub enum Payload {
    NewDataRequest(NewDataRequestArgs),
    StakeDataRequest(StakeDataRequestArgs)
}

pub trait FungibleTokenReceiver {
    // @returns amount of unused tokens
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> PromiseOrValue<WrappedBalance>;
}

#[near_bindgen]
impl FungibleTokenReceiver for Contract {
    // @returns amount of unused tokens
    fn ft_on_transfer(
        &mut self,
        sender_id: AccountId,
        amount: U128,
        msg: String
    ) -> PromiseOrValue<WrappedBalance> {
        let initial_storage_usage = env::storage_usage();
        let account = self.get_storage_account(&sender_id);

        let payload: Payload =  serde_json::from_str(&msg).expect("Failed to parse the payload, invalid `msg` format");
        let unspent = match payload {
            Payload::NewDataRequest(payload) => self.ft_dr_new_callback(sender_id.clone(), amount.into(), payload).into(),
            Payload::StakeDataRequest(payload) => self.dr_stake(sender_id.clone(), amount.into(), payload),
        };

        self.use_storage(&sender_id, initial_storage_usage, account.available);

        unspent
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod mock_token_basic_tests {
    use super::*;
    use std::convert::TryInto;
    use near_sdk::json_types::ValidAccountId;
    use near_sdk::{ MockedBlockchain };
    use near_sdk::{ testing_env, VMContext };
    use crate::storage_manager::StorageManager;

    use fee_config::FeeConfig;

    fn alice() -> AccountId {
        "alice.near".to_string()
    }

    fn bob() -> AccountId {
        "bob.near".to_string()
    }

    fn carol() -> AccountId {
        "carol.near".to_string()
    }

    fn token() -> AccountId {
        "token.near".to_string()
    }

    fn gov() -> AccountId {
        "gov.near".to_string()
    }

    fn to_valid(account: AccountId) -> ValidAccountId {
        account.try_into().expect("invalid account")
    }

    fn registry_entry(account: AccountId) -> Requestor {
        Requestor {
            interface_name: account.clone(),
            account_id: account.clone(),
            stake_multiplier: None,
            code_base_url: None
        }
    }

    fn config() -> oracle_config::OracleConfig {
        oracle_config::OracleConfig {
            gov: gov(),
            final_arbitrator: alice(),
            payment_token: token(),
            stake_token: token(),
            validity_bond: U128(0),
            max_outcomes: 8,
            default_challenge_window_duration: U64(1000),
            min_initial_challenge_window_duration: U64(1000),
            final_arbitrator_invoke_amount: U128(250),
            fee: FeeConfig {
                flux_market_cap: U128(50000),
                total_value_staked: U128(10000),
                resolution_fee_percentage: 5000, // 5%
            }
        }
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        VMContext {
            current_account_id: token(),
            signer_account_id: bob(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1000 * 10u128.pow(24),
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 1000 * 10u128.pow(24),
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    #[should_panic(expected = "alice.near has 0 deposited, 4770000000000000000000 is required for this transaction")]
    fn transfer_storage_no_funds() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        contract.dr_new(bob(), 5, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: Some(vec!["a".to_string(), "b".to_string()].to_vec()),
            challenge_period: U64(1500),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });

        let msg = serde_json::json!({
            "StakeDataRequest": {
                "id": "0",
                "outcome": Outcome::Answer(AnswerType::String("a".to_string()))
            }
        });
        contract.ft_on_transfer(alice(), U128(100), msg.to_string());
    }

    #[test]
    fn transfer_storage_funds() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        contract.dr_new(bob(), 5, NewDataRequestArgs{
            sources: Vec::new(),
            outcomes: Some(vec!["a".to_string(), "b".to_string()].to_vec()),
            challenge_period: U64(1500),
            description: Some("a".to_string()),
            tags: None,
            data_type: data_request::DataRequestDataType::String,
            creator: bob(),
        });

        let storage_start = 10u128.pow(24);

        let mut c : VMContext = get_context(alice());
        c.attached_deposit = storage_start;
        testing_env!(c);
        contract.storage_deposit(Some(to_valid(alice())));

        testing_env!(get_context(token()));
        let msg = serde_json::json!({
            "StakeDataRequest": {
                "id": "0",
                "outcome": Outcome::Answer(AnswerType::String("a".to_string()))
            }
        });
        contract.ft_on_transfer(alice(), U128(100), msg.to_string());

        let account = contract.accounts.get(&alice());
        assert!(account.unwrap().available < storage_start);
    }
}

'''
'''--- oracle/src/helpers.rs ---
use uint::construct_uint;
use near_sdk::{
    env,
    StorageUsage,
    AccountId, 
    Balance,
    Promise
};

const STORAGE_PRICE_PER_BYTE: Balance = 100_000_000_000_000_000_000;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct u256(4);
}

/*** operators that does not take decimals into account ***/
pub fn calc_product(a: u128, b: u128, divisor: u128) -> u128 {
    let a_u256 = u256::from(a);
    let b_u256 = u256::from(b);
    let divisor_u256 = u256::from(divisor);

    (a_u256 * b_u256 / divisor_u256).as_u128()
}

pub fn refund_storage(initial_storage: StorageUsage, sender_id: AccountId) {
    let current_storage = env::storage_usage();
    let attached_deposit = env::attached_deposit();
    let refund_amount = if current_storage > initial_storage {
        let required_deposit =
            Balance::from(current_storage - initial_storage) * STORAGE_PRICE_PER_BYTE;
        assert!(
            required_deposit <= attached_deposit,
            "The required attached deposit is {}, but the given attached deposit is is {}",
            required_deposit,
            attached_deposit,
        );
        attached_deposit - required_deposit
    } else {
        attached_deposit
            + Balance::from(initial_storage - current_storage) * STORAGE_PRICE_PER_BYTE
    };
    if refund_amount > 0 {
        Promise::new(sender_id).transfer(refund_amount);
    }
}

pub fn ns_to_ms(ns_timestamp: u64) -> u64 {
    ns_timestamp / 1_000_000
}

pub fn multiply_stake(stake: u128, multiplier: Option<u16>) -> u128 {
    match multiplier {
        Some(m) => {
            let base = 10_000_u128;
            stake * m as u128 / base
        },
        None => stake
    }
}
'''
'''--- oracle/src/lib.rs ---
#![allow(clippy::too_many_arguments)]

use near_sdk::{ AccountId, Balance, env, near_bindgen };
use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize };
use near_sdk::collections::{ Vector, LookupMap };
use near_sdk::json_types::{ U64, U128 };

near_sdk::setup_alloc!();

pub mod types;
mod resolution_window;
pub mod data_request;
mod requestor_handler;
mod fungible_token_receiver;
pub mod callback_args;
pub mod whitelist;
pub mod oracle_config;
mod storage_manager;
mod helpers;
mod logger;
mod upgrade;
pub mod fee_config;

/// Mocks
mod fungible_token;

pub use callback_args::*;

use types::*;
pub use data_request::{ DataRequest, Source };
use storage_manager::AccountStorageBalance;
pub use requestor_handler::Requestor;

#[near_bindgen]
#[derive(BorshSerialize, BorshDeserialize )]
pub struct Contract {
    pub whitelist: whitelist::Whitelist,
    pub configs: Vector<oracle_config::OracleConfig>,
    pub data_requests: Vector<DataRequest>,
    pub accounts: LookupMap<AccountId, AccountStorageBalance>, // storage map
}

impl Default for Contract {
    fn default() -> Self {
        env::panic(b"Contract should be initialized before usage")
    }
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(
        initial_whitelist: Option<Vec<Requestor>>,
        config: oracle_config::OracleConfig,
    ) -> Self {
        let mut configs = Vector::new(b"c".to_vec());
        configs.push(&config);
        logger::log_oracle_config(&config, 0);

        Self {
            whitelist: whitelist::Whitelist::new(initial_whitelist),
            configs,
            data_requests: Vector::new(b"dr".to_vec()),
            accounts: LookupMap::new(b"a".to_vec()),
        }
    }
}

impl Contract {
    pub fn assert_gov(&self) {
        let config = self.configs.iter().last().unwrap();
        assert_eq!(
            config.gov,
            env::predecessor_account_id(),
            "This method is only callable by the governance contract {}",
            config.gov
        );
    }
}

'''
'''--- oracle/src/logger.rs ---
use near_sdk::{
    env,
    AccountId,
    Balance,
	json_types::{
        U64,
        U128,
    },
    serde_json::json,
};

use crate::{
    types::*,
    data_request::DataRequest,
    resolution_window::ResolutionWindow,
    requestor_handler::Requestor,
    oracle_config::{
        OracleConfig
    },
    helpers::{
        ns_to_ms,
    }
};

pub fn log_new_data_request(request: &DataRequest) {
    env::log(
        json!({
            "type": "data_requests",
            "action": "update",
            "cap_id": format!("dr_{}", request.id),
            "params": {
                "id": U64(request.id),
                "sources": request.sources,
                "description": request.description,
                "outcomes": request.outcomes,
                "requestor": request.requestor,
                "requestor_account_id": request.requestor.account_id,
                "finalized_outcome": request.finalized_outcome,
                "initial_challenge_period": U64(request.initial_challenge_period),
                "final_arbitrator_triggered": request.final_arbitrator_triggered,
                "paid_fee": U128(request.request_config.paid_fee),
                "stake_multiplier": request.request_config.stake_multiplier,
                "global_config_id": U64(request.global_config_id),
                "tags": request.tags,
                "date": U64(ns_to_ms(env::block_timestamp())),
                "block_height": U64(env::block_index()),
                "data_type": request.data_type,
                "creator": request.creator,
            }
        })
        .to_string()
        .as_bytes()
    );
}

pub fn log_update_data_request(request: &DataRequest) {
    env::log(
        json!({
            "type": "data_requests",
            "action": "update",
            "cap_id": format!("dr_{}", request.id),
            "params": {
                "id": U64(request.id),
                "sources": request.sources,
                "outcomes": request.outcomes,
                "requestor": request.requestor,
                "finalized_outcome": request.finalized_outcome,
                "initial_challenge_period": U64(request.initial_challenge_period),
                "final_arbitrator_triggered": request.final_arbitrator_triggered,
            }
        })
        .to_string()
        .as_bytes()
    );
}

pub fn log_oracle_config(config: &OracleConfig, id: u64) {
    env::log(
        json!({
            "type": "oracle_configs",
            "action": "update",
            "cap_id": format!("oc_{}", id),
            "params": {
                "id": U64(id),
                "gov": config.gov,
                "final_arbitrator": config.final_arbitrator,
                "stake_token": config.stake_token,
                "payment_token": config.payment_token,
                "validity_bond": config.validity_bond,
                "max_outcomes": config.max_outcomes,
                "default_challenge_window_duration": config.default_challenge_window_duration,
                "min_initial_challenge_window_duration": config.min_initial_challenge_window_duration,
                "final_arbitrator_invoke_amount": config.final_arbitrator_invoke_amount,
                
                "fee": {
                    "flux_market_cap": config.fee.flux_market_cap,
                    "total_value_staked": config.fee.total_value_staked,
                    "resolution_fee_percentage": config.fee.resolution_fee_percentage,
                },

                "date": U64(ns_to_ms(env::block_timestamp())),
                "block_height": U64(env::block_index()),
            }
        })
        .to_string()
        .as_bytes()
    );
}

pub fn log_resolution_window(window: &ResolutionWindow) {
    env::log(
        json!({
            "type": "resolution_windows",
            "action": "update",
            "cap_id": format!("rw_{}_{}", window.dr_id, window.round),
            "params": {
                "id": format!("rw_{}_{}", window.dr_id, window.round),
                "dr_id": U64(window.dr_id),
                "round": window.round,
                "start_time": U64(window.start_time),
                "end_time": U64(window.end_time),
                "bond_size": U128(window.bond_size),
                "bonded_outcome": window.bonded_outcome,

                "date": U64(ns_to_ms(env::block_timestamp())),
                "block_height": U64(env::block_index()),
            }
        })
        .to_string()
        .as_bytes()
    );
}

fn outcome_to_id(outcome: &Outcome) -> String {
    // We append ans_ infront of an answer to avoid malicous fake invalids
    // that would overwrite a real invalid outcome
    match outcome {
        Outcome::Answer(answer) =>  match answer {
            AnswerType::String(str_ans) => format!("ans_str_{}", str_ans),
            AnswerType::Number(num_ans) => format!("ans_num_{}_{}_{}", num_ans.value.0, num_ans.multiplier.0, num_ans.negative),
        },
        Outcome::Invalid => "invalid".to_string()
    }
}

pub fn log_outcome_to_stake(data_request_id: u64, round: u16, outcome: &Outcome, total_stake: Balance) {
    let outcome_id = outcome_to_id(outcome);
    
    env::log(
        json!({
            "type": "outcome_stakes",
            "action": "update",
            "cap_id": format!("ots_{}_{}_{}", data_request_id, round, outcome_id),
            "params": {
                "id": format!("ots_{}_{}_{}", data_request_id, round, outcome_id),
                "data_request_id": U64(data_request_id),
                "round": round,
                "outcome": outcome,
                "total_stake": U128(total_stake),
            }
        })
        .to_string()
        .as_bytes()
    );
}

pub fn log_user_stake(data_request_id: u64, round: u16, account_id: &AccountId, outcome: &Outcome, total_stake: Balance) {
    let outcome_id = outcome_to_id(outcome);
    
    env::log(
        json!({
            "type": "user_stakes",
            "action": "update",
            "cap_id": format!("us_{}_{}_{}_{}", data_request_id, round, outcome_id, account_id),
            "params": {
                "id": format!("us_{}_{}_{}_{}", data_request_id, round, outcome_id, account_id),
                "data_request_id": U64(data_request_id),
                "round": round,
                "outcome": outcome,
                "account_id": account_id,
                "total_stake": U128(total_stake),
            }
        })
        .to_string()
        .as_bytes()
    );
}

pub fn log_claim(
    account_id: &AccountId, 
    data_request_id: u64, 
    total_correct_bonded_staked: u128, 
    total_incorrect_staked: u128, 
    user_correct_stake: u128, 
    stake_profit: u128,
    fee_profit: u128,
) {
    env::log(
        json!({
            "type": "data_requests",
            "action": "update",
            "cap_id": format!("dr_{}", data_request_id),
            "params": {
                "id": U64(data_request_id),
                "total_correct_bonded_staked": U128(total_correct_bonded_staked),
                "total_incorrect_staked": U128(total_incorrect_staked),
            }
        })
        .to_string()
        .as_bytes()
    );

    env::log(
        json!({
            "type": "claims",
            "action": "update",
            "cap_id": format!("c_{}_{}", account_id, data_request_id),
            "params": {
                "id": format!("c_{}_{}", account_id, data_request_id),
                "account_id": account_id,
                "data_request_id": U64(data_request_id),
                "total_correct_bonded_staked": U128(total_correct_bonded_staked),
                "total_incorrect_staked": U128(total_incorrect_staked),
                "user_correct_stake": U128(user_correct_stake),
                "payout": U128(stake_profit),
                "fee_profit": U128(fee_profit),
                "date": U64(ns_to_ms(env::block_timestamp())),
                "block_height": U64(env::block_index()),
            }
        })
        .to_string()
        .as_bytes()
    );
}

pub fn log_whitelist(requestor: &Requestor, active: bool) {
    env::log(
        json!({
            "type": "whitelist",
            "action": "update",
            "cap_id": format!("wl_{}", requestor.account_id),
            "params": {
                "id": format!("wl_{}", requestor.account_id),
                "interface_name": requestor.interface_name,
                "account_id": requestor.account_id,
                "stake_multiplier": requestor.stake_multiplier,
                "code_base_url": requestor.code_base_url,
                "active": active,
                "date": U64(ns_to_ms(env::block_timestamp())),
                "block_height": U64(env::block_index()),
            }
        })
        .to_string()
        .as_bytes()
    );
}

#[derive(serde::Serialize)]
pub enum TransactionType {
    Stake,
    Unstake,
}

pub fn log_transaction(
    tx_type: TransactionType, 
    account_id: &AccountId, 
    data_request_id: u64, 
    round: Option<u16>, 
    input: u128, 
    output: u128,
    extra_info: Option<String>,
) {
    env::log(
        json!({
            "type": "transactions",
            "params": {
                "account_id": account_id,
                "input": U128(input),
                "output": U128(output),
                "data_request_id": U64(data_request_id),
                "round": round,
                "date": U64(ns_to_ms(env::block_timestamp())),
                "block_height": U64(env::block_index()),
                "extra_info": extra_info,
                "type": tx_type,
            }
        })
        .to_string()
        .as_bytes()
    );
}

pub fn log_stake_transaction(
    account_id: &AccountId, 
    window: &ResolutionWindow, 
    amount_in: Balance, 
    amount_out: Balance,
    outcome: &Outcome
) {
    log_transaction(
        TransactionType::Stake, 
        account_id, 
        window.dr_id,
        Some(window.round), 
        amount_in,
        amount_out, 
        Some(outcome_to_id(outcome))
    );
}

pub fn log_unstake_transaction(
    account_id: &AccountId, 
    window: &ResolutionWindow, 
    amount_out: Balance,
    outcome: &Outcome
) {
    log_transaction(
        TransactionType::Unstake, 
        account_id, 
        window.dr_id, 
        Some(window.round), 
        0,
        amount_out, 
        Some(outcome_to_id(outcome))
    );
}

'''
'''--- oracle/src/oracle_config.rs ---
use crate::*;
use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize };
use near_sdk::serde::{ Serialize, Deserialize };
use near_sdk::{ AccountId };
use fee_config::FeeConfig;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
#[serde(crate = "near_sdk::serde")]
pub struct OracleConfig {
    pub gov: AccountId,
    pub final_arbitrator: AccountId, // Invoked to have last say in `DataRequest`, this happens when the `challenge_bond` for a `DataRequest` is >= than `final_arbitrator_invoke_amount` / 100 % of the total supply
    pub stake_token: AccountId,
    pub payment_token: AccountId,
    pub validity_bond: U128,
    pub max_outcomes: u8,
    pub default_challenge_window_duration: WrappedTimestamp,
    pub min_initial_challenge_window_duration: WrappedTimestamp,
    pub final_arbitrator_invoke_amount: U128, // Amount of tokens that, when bonded in a single `ResolutionWindow`, should trigger the final arbitrator
    pub fee: FeeConfig,
}

#[near_bindgen]
impl Contract {
    pub fn get_config(&self) -> OracleConfig {
        self.configs.iter().last().unwrap()
    }

    #[payable]
    pub fn set_config(&mut self, new_config: OracleConfig) {
        self.assert_gov();
                
        let initial_storage = env::storage_usage();

        self.configs.push(&new_config);

        logger::log_oracle_config(&new_config, self.configs.len() - 1);
        helpers::refund_storage(initial_storage, env::predecessor_account_id());
    }
}

impl Contract {
    pub fn assert_sender(&self, expected_sender: &AccountId) {
        assert_eq!(&env::predecessor_account_id(), expected_sender, "This function can only be called by {}", expected_sender);
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod mock_token_basic_tests {
    use near_sdk::{ MockedBlockchain };
    use near_sdk::{ testing_env, VMContext };
    use fee_config::FeeConfig;
    use super::*;
    
    fn alice() -> AccountId {
        "alice.near".to_string()
    }
    
    fn bob() -> AccountId {
        "bob.near".to_string()
    }

    fn token() -> AccountId {
        "token.near".to_string()
    }
 
    fn gov() -> AccountId {
        "gov.near".to_string()
    }

    fn config(gov: AccountId) -> oracle_config::OracleConfig {
        oracle_config::OracleConfig {
            gov,
            final_arbitrator: alice(),
            payment_token: token(),
            stake_token: token(),
            validity_bond: U128(0),
            max_outcomes: 8,
            default_challenge_window_duration: U64(1000),
            min_initial_challenge_window_duration: U64(1000),
            final_arbitrator_invoke_amount: U128(25_000_000_000_000_000_000_000_000_000_000),
            fee: FeeConfig {
                flux_market_cap: U128(50000),
                total_value_staked: U128(10000),
                resolution_fee_percentage: 5000, // 5%
            }
        }
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        VMContext {
            current_account_id: token(),
            signer_account_id: bob(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1000 * 10u128.pow(24),
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 19000000000000000000000,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    fn set_config_from_gov() {
        testing_env!(get_context(gov()));
        let mut contract = Contract::new(None, config(gov()));
        contract.set_config(config(alice()));
        assert_eq!(contract.get_config().gov, alice());
    }

    #[test]
    #[should_panic(expected = "This method is only callable by the governance contract gov.near")]
    fn fail_set_config_from_user() {
        testing_env!(get_context(alice()));
        let mut contract = Contract::new(None, config(gov()));
        contract.set_config(config(alice()));
    }
}
'''
'''--- oracle/src/requestor_handler.rs ---
use crate::*;
use near_sdk::{PromiseOrValue, ext_contract, Gas, Promise};
use near_sdk::serde::{Serialize, Deserialize};

const GAS_BASE_SET_OUTCOME: Gas = 250_000_000_000_000;

#[ext_contract]
pub trait RequestorContractExtern {
    fn set_outcome(request_id: U64, requestor: AccountId, outcome: Outcome, tags: Option<Vec<String>>, final_arbitrator_triggered: bool);
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone)]
pub struct Requestor {
    pub interface_name: String,
    pub account_id: AccountId, // Change to account_id
    pub stake_multiplier: Option<u16>, 
    pub code_base_url: Option<String>
}

#[ext_contract(ext_self)]
trait SelfExt {
    fn proceed_dr_new(&mut self, sender: AccountId, amount: Balance, payload: NewDataRequestArgs);
}

impl Requestor {
    pub fn new_no_whitelist(account_id: &AccountId) -> Self {
        Self {
            interface_name: "".to_string(),
            account_id: account_id.to_string(),
            stake_multiplier: None,
            code_base_url: None
        }
    }
    pub fn set_outcome(
        &self,
        request_id: U64,
        outcome: Outcome,
        tags: Option<Vec<String>>,
        final_arbitrator_triggered: bool
    ) -> Promise {
        requestor_contract_extern::set_outcome(
            request_id,
            self.account_id.to_string(),
            outcome,
            tags,
            final_arbitrator_triggered,

            // NEAR params
            &self.account_id,
            1, 
            GAS_BASE_SET_OUTCOME / 10,
        )
    }
}

#[near_bindgen]
impl Contract {

    /**
     * @notice called in ft_on_transfer to chain together fetching of TVL and data request creation
     */
    #[private]
    pub fn ft_dr_new_callback(
        &mut self,
        sender: AccountId,
        amount: Balance,
        payload: NewDataRequestArgs
    ) -> PromiseOrValue<WrappedBalance> {
        PromiseOrValue::Value(U128(self.dr_new(sender.clone(), amount.into(), payload)))
    }
}

'''
'''--- oracle/src/resolution_window.rs ---
use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize };
use near_sdk::serde::{ Deserialize, Serialize };
use near_sdk::{ Balance, AccountId };
use near_sdk::collections::{ LookupMap };

use crate::types::*;
use crate::logger;

pub enum WindowStakeResult {
    Incorrect(Balance), // Round bonded outcome was correct
    Correct(CorrectStake), // Round bonded outcome was incorrect
    NoResult // Last / non-bonded window
}

pub struct CorrectStake {
    pub bonded_stake: Balance,
    pub user_stake: Balance,
}

#[derive(BorshSerialize, BorshDeserialize)]
pub struct ResolutionWindow {
    pub dr_id: u64,
    pub round: u16,
    pub start_time: Timestamp,
    pub end_time: Timestamp,
    pub bond_size: Balance,
    pub outcome_to_stake: LookupMap<Outcome, Balance>,
    pub user_to_outcome_to_stake: LookupMap<AccountId, LookupMap<Outcome, Balance>>,
    pub bonded_outcome: Option<Outcome>,
}

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize)]
pub struct ResolutionWindowSummary {
    pub round: u16,
    pub start_time: WrappedTimestamp, 
    pub end_time: WrappedTimestamp,
    pub bond_size: WrappedBalance,
    pub bonded_outcome: Option<Outcome>
}

impl ResolutionWindow {
    pub fn new(dr_id: u64, round: u16, prev_bond: Balance, challenge_period: u64, start_time: u64) -> Self {
        let new_resolution_window = Self {
            dr_id,
            round,
            start_time,
            end_time: start_time + challenge_period,
            bond_size: prev_bond * 2,
            outcome_to_stake: LookupMap::new(format!("ots{}:{}", dr_id, round).as_bytes().to_vec()),
            user_to_outcome_to_stake: LookupMap::new(format!("utots{}:{}", dr_id, round).as_bytes().to_vec()),
            bonded_outcome: None
        };

        logger::log_resolution_window(&new_resolution_window);
        return new_resolution_window;
    }

    // @returns amount to refund users because it was not staked
    pub fn stake(&mut self, sender: AccountId, outcome: Outcome, amount: Balance) -> Balance {
        let stake_on_outcome = self.outcome_to_stake.get(&outcome).unwrap_or(0);
        let mut user_to_outcomes = self.user_to_outcome_to_stake
            .get(&sender)
            .unwrap_or(LookupMap::new(format!("utots:{}:{}:{}", self.dr_id, self.round, sender).as_bytes().to_vec()));
        let user_stake_on_outcome = user_to_outcomes.get(&outcome).unwrap_or(0);

        let stake_open = self.bond_size - stake_on_outcome;
        let unspent = if amount > stake_open {
            amount - stake_open
        } else {
            0
        };

        let staked = amount - unspent;

        let new_stake_on_outcome = stake_on_outcome + staked;
        self.outcome_to_stake.insert(&outcome, &new_stake_on_outcome);
        logger::log_outcome_to_stake(self.dr_id, self.round, &outcome, new_stake_on_outcome);

        let new_user_stake_on_outcome = user_stake_on_outcome + staked;
        user_to_outcomes.insert(&outcome, &new_user_stake_on_outcome);
        self.user_to_outcome_to_stake.insert(&sender, &user_to_outcomes);

        logger::log_user_stake(self.dr_id, self.round, &sender, &outcome, new_user_stake_on_outcome);
        logger::log_stake_transaction(&sender, &self, amount, unspent, &outcome);

        // If this stake fills the bond set final outcome which will trigger a new resolution_window to be created
        if new_stake_on_outcome == self.bond_size {
            self.bonded_outcome = Some(outcome);
            logger::log_resolution_window(&self);
        }

        unspent
    }

    // @returns amount to refund users because it was not staked
    pub fn unstake(&mut self, sender: AccountId, outcome: Outcome, amount: Balance) -> Balance {
        assert!(self.bonded_outcome.is_none() || self.bonded_outcome.as_ref().unwrap() != &outcome, "Cannot withdraw from bonded outcome");
        let mut user_to_outcomes = self.user_to_outcome_to_stake
            .get(&sender)
            .unwrap_or(LookupMap::new(format!("utots:{}:{}:{}", self.dr_id, self.round, sender).as_bytes().to_vec()));
        let user_stake_on_outcome = user_to_outcomes.get(&outcome).unwrap_or(0);
        assert!(user_stake_on_outcome >= amount, "{} has less staked on this outcome ({}) than unstake amount", sender, user_stake_on_outcome);

        let stake_on_outcome = self.outcome_to_stake.get(&outcome).unwrap_or(0);

        let new_stake_on_outcome = stake_on_outcome - amount;
        self.outcome_to_stake.insert(&outcome, &new_stake_on_outcome);
        logger::log_outcome_to_stake(self.dr_id, self.round, &outcome, new_stake_on_outcome);

        let new_user_stake_on_outcome = user_stake_on_outcome - amount;
        user_to_outcomes.insert(&outcome, &new_user_stake_on_outcome);
        self.user_to_outcome_to_stake.insert(&sender, &user_to_outcomes);
        logger::log_user_stake(self.dr_id, self.round, &sender, &outcome, new_user_stake_on_outcome);
        logger::log_unstake_transaction(&sender, &self, amount, &outcome);

        amount
    }

    pub fn claim_for(&mut self, account_id: AccountId, final_outcome: &Outcome) -> WindowStakeResult {
        // Check if there is a bonded outcome, if there is none it means it can be ignored in payout calc since it can only be the final unsuccessful window
        match &self.bonded_outcome {
            Some(bonded_outcome) => {
                // If the bonded outcome for this window is equal to the finalized outcome the user's stake in this window and the total amount staked should be returned (which == `self.bond_size`)
                if bonded_outcome == final_outcome {
                    WindowStakeResult::Correct(CorrectStake {
                        bonded_stake: self.bond_size,
                        // Get the users stake in this outcome for this window
                        user_stake:  match &mut self.user_to_outcome_to_stake.get(&account_id) {
                            Some(outcome_to_stake) => {
                                outcome_to_stake.remove(&bonded_outcome).unwrap_or(0)
                            },
                            None => 0
                        }
                    })
                // Else if the bonded outcome for this window is not equal to the finalized outcome the user's stake in this window only the total amount that was staked on the incorrect outcome should be returned
                } else {
                    WindowStakeResult::Incorrect(self.bond_size)
                }
            },
            None => WindowStakeResult::NoResult // Return `NoResult` for non-bonded window
        }
    }
}
'''
'''--- oracle/src/storage_manager.rs ---
use super::*;
use near_sdk::{Promise};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::Serialize;

/// Price per 1 byte of storage from mainnet config after `0.18` release and protocol version `42`.
/// It's 10 times lower than the genesis price.
pub const STORAGE_PRICE_PER_BYTE: Balance = 10_000_000_000_000_000_000;

pub const STORAGE_MINIMUM_BALANCE: Balance = 10_000_000_000_000_000_000_000;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalance {
    total: U128,
    available: U128,
}

#[derive(BorshDeserialize, BorshSerialize)]
pub struct AccountStorageBalance {
    pub total: u128,
    pub available: u128,
}

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceBounds {
    min: U128,
    max: Option<U128>,
}

pub trait StorageManager {
    fn storage_deposit(&mut self, account_id: Option<ValidAccountId>) -> StorageBalance;

    fn storage_withdraw(&mut self, amount: U128) -> StorageBalance;

    fn storage_balance_bounds(&self) -> StorageBalanceBounds;

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance>;
}

fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR"
    )
}

#[near_bindgen]
impl StorageManager for Contract {

    #[payable]
    fn storage_deposit(&mut self, account_id: Option<ValidAccountId>) -> StorageBalance {
        let amount = env::attached_deposit();
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        
        let mut account = self.get_storage_account(&account_id);

        account.available += amount;
        account.total += amount;

        self.accounts.insert(&account_id, &account);

        StorageBalance {
            total: U128(account.total),
            available: U128(account.available),
        }
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: U128) -> StorageBalance {
        assert_one_yocto();
        let amount: Balance = amount.into();
        let account_id = env::predecessor_account_id();
        let mut account = self.get_storage_account(&account_id);

        account.available -= amount;
        account.total -= amount;

        self.accounts.insert(&account_id, &account);

        Promise::new(account_id).transfer(amount);

        StorageBalance {
            total: U128(account.total),
            available: U128(account.available),
        }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: U128(STORAGE_MINIMUM_BALANCE),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        self.accounts
            .get(account_id.as_ref())
            .map(|account| StorageBalance {
                total: U128(account.total),
                available: U128(account.available),
            })
    }
}

impl Contract {
    pub fn get_storage_account(&self, account_id: &AccountId) -> AccountStorageBalance {
        self.accounts.get(account_id)
            .unwrap_or(AccountStorageBalance { total: 0, available: 0 })
    }

    pub fn use_storage(&mut self, sender_id: &AccountId, initial_storage_usage: u64, initial_available_balance: u128) {
        if env::storage_usage() >= initial_storage_usage {
            // used more storage, deduct from balance
            let difference : u128 = u128::from(env::storage_usage() - initial_storage_usage);
            let mut account = self.get_storage_account(sender_id);
            let cost = difference * STORAGE_PRICE_PER_BYTE;
            assert!(cost <= initial_available_balance, "{} has {} deposited, {} is required for this transaction", sender_id, initial_available_balance, cost);
            account.available = initial_available_balance - difference * STORAGE_PRICE_PER_BYTE;

            self.accounts.insert(sender_id, &account);
        } else {
            // freed up storage, add to balance
            let difference : u128 = u128::from(initial_storage_usage - env::storage_usage());
            let mut account = self.get_storage_account(sender_id);
            account.available = initial_available_balance + difference * STORAGE_PRICE_PER_BYTE;

            self.accounts.insert(sender_id, &account);
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod mock_token_basic_tests {
    use super::*;
    use std::convert::TryInto;
    use near_sdk::{ MockedBlockchain };
    use near_sdk::{ testing_env, VMContext };
    use fee_config::FeeConfig;

    fn alice() -> AccountId {
        "alice.near".to_string()
    }

    fn bob() -> AccountId {
        "bob.near".to_string()
    }

    fn carol() -> AccountId {
        "carol.near".to_string()
    }

    fn token() -> AccountId {
        "token.near".to_string()
    }

    fn _target() -> AccountId {
        "target.near".to_string()
    }

    fn gov() -> AccountId {
        "gov.near".to_string()
    }

    fn to_valid(account: AccountId) -> ValidAccountId {
        account.try_into().expect("invalid account")
    }

    fn registry_entry(account: AccountId) -> Requestor {
        Requestor {
            interface_name: account.clone(),
            account_id: account.clone(),
            stake_multiplier: None,
            code_base_url: None
        }
    }

    fn config() -> oracle_config::OracleConfig {
        oracle_config::OracleConfig {
            gov: gov(),
            final_arbitrator: alice(),
            payment_token: token(),
            stake_token: token(),
            validity_bond: U128(100),
            max_outcomes: 8,
            default_challenge_window_duration: U64(1000),
            min_initial_challenge_window_duration: U64(1000),
            final_arbitrator_invoke_amount: U128(250),
            fee: FeeConfig {
                flux_market_cap: U128(50000),
                total_value_staked: U128(10000),
                resolution_fee_percentage: 5000, // 5%
            }
        }
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        VMContext {
            current_account_id: token(),
            signer_account_id: bob(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1000 * 10u128.pow(24),
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 1000 * 10u128.pow(24),
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    fn storage_manager_deposit() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        let account = contract.get_storage_account(&alice());
        assert_eq!(account.available, 0);

        let amount = 10u128.pow(24);

        //deposit
        let mut c : VMContext = get_context(alice());
        c.attached_deposit = amount;
        testing_env!(c);
        contract.storage_deposit(Some(to_valid(alice())));

        let account = contract.get_storage_account(&alice());
        assert_eq!(account.available, amount);

        //deposit again
        let mut c : VMContext = get_context(alice());
        c.attached_deposit = amount;
        testing_env!(c);
        contract.storage_deposit(Some(to_valid(alice())));

        let account = contract.get_storage_account(&alice());
        assert_eq!(account.available, amount*2);
    }

    #[test]
    fn storage_manager_withdraw() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        let account = contract.get_storage_account(&alice());
        assert_eq!(account.available, 0);

        let amount = 10u128.pow(24);

        //deposit
        let mut c : VMContext = get_context(alice());
        c.attached_deposit = amount;
        testing_env!(c);
        contract.storage_deposit(Some(to_valid(alice())));

        // withdraw
        let mut c : VMContext = get_context(alice());
        c.attached_deposit = 1;
        testing_env!(c);

        contract.storage_withdraw(U128(amount/2));
        let account = contract.get_storage_account(&alice());
        assert_eq!(account.available, amount/2);
    }

    #[test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    fn storage_manager_withdraw_too_much() {
        testing_env!(get_context(token()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        let account = contract.get_storage_account(&alice());
        assert_eq!(account.available, 0);

        let amount = 10u128.pow(24);

        //deposit
        let mut c : VMContext = get_context(alice());
        c.attached_deposit = amount;
        testing_env!(c);
        contract.storage_deposit(Some(to_valid(alice())));

        // withdraw
        let mut c : VMContext = get_context(alice());
        c.attached_deposit = 1;
        testing_env!(c);

        contract.storage_withdraw(U128(amount*2));
    }
}

'''
'''--- oracle/src/target_contract_handler.rs ---
// use crate::*;
// use near_sdk::json_types::{ U64 };
// use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize };
// use near_sdk::serde::{ Deserialize, Serialize };
// use near_sdk::{ AccountId, Gas, ext_contract, Promise };
// use types::Outcome;

#[ext_contract]
pub trait TargetContractExtern {
    fn set_outcome(request_id: U64, requestor: AccountId, outcome: Outcome, tags: Option<Vec<String>>, final_arbitrator_triggered: bool);
}

// #[derive(BorshDeserialize, BorshSerialize, Deserialize, Serialize)]
// pub struct TargetContract(pub AccountId);

const GAS_BASE_SET_OUTCOME: Gas = 250_000_000_000_000;

// impl TargetContract {
    pub fn set_outcome(
        &self,
        request_id: U64,
        requestor: AccountId,
        outcome: Outcome,
        tags: Option<Vec<String>>,
        final_arbitrator_triggered: bool
    ) -> Promise {
        target_contract_extern::set_outcome(
            request_id,
            requestor,
            outcome,
            tags,
            final_arbitrator_triggered,

            // NEAR params
            &self.0,
            1, 
            GAS_BASE_SET_OUTCOME / 10,
        )
    }
// }

'''
'''--- oracle/src/types.rs ---
use near_sdk::json_types::{U64, U128};
use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize };
use near_sdk::serde::{ Deserialize, Serialize };

/// Raw type for timestamp in nanoseconds
pub type Timestamp = u64;
pub type WrappedTimestamp = U64;
pub type Duration = u64;
pub type WrappedBalance = U128;

pub struct ClaimRes {
    pub payment_token_payout: u128,
    pub stake_token_payout: u128
}

#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Debug, PartialEq, Clone)]
pub struct AnswerNumberType {
    pub value: U128,
    pub multiplier: U128,
    pub negative: bool,
}

#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Debug, PartialEq, Clone)]
pub enum AnswerType {
    Number(AnswerNumberType),
    String(String)
}

#[derive(BorshSerialize, BorshDeserialize, Deserialize, Serialize, Debug, PartialEq, Clone)]
pub enum Outcome {
    Answer(AnswerType),
    Invalid
}

'''
'''--- oracle/src/upgrade.rs ---
use crate::*;
use near_sdk::{ init };

#[cfg(target_arch = "wasm32")]
mod upgrade {
    use near_sdk::env::BLOCKCHAIN_INTERFACE;
    use near_sdk::Gas;

    use super::*;

    const BLOCKCHAIN_INTERFACE_NOT_SET_ERR: &str = "Blockchain interface not set.";

    /// Gas for calling migration call.
    pub const GAS_FOR_MIGRATE_CALL: Gas = 5_000_000_000_000;

    /// Self upgrade and call migrate, optimizes gas by not loading into memory the code.
    /// Takes as input non serialized set of bytes of the code.
    #[no_mangle]
    pub extern "C" fn upgrade() {
        env::setup_panic_hook();
        env::set_blockchain_interface(Box::new(near_blockchain::NearBlockchain {}));
        let contract: Contract = env::state_read().expect("ERR_CONTRACT_IS_NOT_INITIALIZED");
        contract.assert_gov();
        let current_id = env::current_account_id().into_bytes();
        let method_name = "migrate".as_bytes().to_vec();

        unsafe {
            BLOCKCHAIN_INTERFACE.with(|b| {
                // Load input into register 0.
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .input(0);
                let promise_id = b
                    .borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_create(current_id.len() as _, current_id.as_ptr() as _);
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_deploy_contract(promise_id, u64::MAX as _, 0);
                let attached_gas = env::prepaid_gas() - env::used_gas() - GAS_FOR_MIGRATE_CALL;
                b.borrow()
                    .as_ref()
                    .expect(BLOCKCHAIN_INTERFACE_NOT_SET_ERR)
                    .promise_batch_action_function_call(
                        promise_id,
                        method_name.len() as _,
                        method_name.as_ptr() as _,
                        0 as _,
                        0 as _,
                        0 as _,
                        attached_gas,
                    );
            });
        }
    }
}

impl Contract {
    #[init(ignore_state)]
    pub fn migrate() -> Self {
        let contract: Contract = env::state_read().expect("ERR_NOT_INITIALIZED");
        contract
    }
}

'''
'''--- oracle/src/whitelist.rs ---
use crate::*;

use near_sdk::borsh::{ self, BorshDeserialize, BorshSerialize };
use near_sdk::AccountId;
use near_sdk::collections::LookupMap;
   
#[derive(BorshSerialize, BorshDeserialize)]
pub struct Whitelist(Option<LookupMap<AccountId, Requestor>>); // maps requestor account id to requestors config

impl Whitelist {
    pub fn new(initial_whitelist: Option<Vec<Requestor>>) -> Self {
        let mut whitelist: LookupMap<AccountId, Requestor> = LookupMap::new(b"wlr".to_vec());

        match initial_whitelist {
            Some(initial_whitelist) => {
                // insert registry entry into whitelist
                for requestor in initial_whitelist {
                    whitelist.insert(&requestor.account_id, &requestor);
                    logger::log_whitelist(&requestor, true);
                }
                Self(Some(whitelist))
            }, 
            None => Self(None)
        }
    }

    pub fn contains(&self, requestor: AccountId) -> bool {
        match self.0.as_ref().expect("No whitelist initiated").get(&requestor) {
            None => false,
            _ => true
        }
    }

    pub fn get_stake_multiplier(&self, requestor: &AccountId) -> Option<u16> {
        match &self.0 {
            Some(whitelist) => {
                whitelist.get(requestor).expect("not whitelisted").stake_multiplier
            },
            None => None
        }
    }

    pub fn whitelist_get_expect(&self, requestor: &AccountId) -> Requestor {
        match &self.0 {
            Some(whitelist) => {
                whitelist.get(requestor).expect("requestor not whitelisted")
            }, 
            None => Requestor::new_no_whitelist(requestor)
        }
    }
}

trait WhitelistHandler {
    fn add_to_whitelist(&mut self, new_requestor: Requestor);
    fn remove_from_whitelist(&mut self, requestor: Requestor);
    fn whitelist_contains(&self, requestor: AccountId) -> bool;
}

#[near_bindgen]
impl WhitelistHandler for Contract {
    
    #[payable]
    fn add_to_whitelist(&mut self, new_requestor: Requestor) {
        self.assert_gov();

        match new_requestor.stake_multiplier {
            Some(m) => assert!(m > 0, "stake multiplier can't be 0"),
            _ => ()
        };

        let initial_storage = env::storage_usage();

        match &mut self.whitelist.0 {
            Some(whitelist) => {
                whitelist.insert(&new_requestor.account_id, &new_requestor);
            }, 
            None => {
                let mut whitelist: LookupMap<AccountId, Requestor> = LookupMap::new(b"wlr".to_vec());
                whitelist.insert(&new_requestor.account_id, &new_requestor);
                self.whitelist = Whitelist(Some(whitelist));
            }
        };
      
        logger::log_whitelist(&new_requestor, true);
        helpers::refund_storage(initial_storage, env::predecessor_account_id());
    }

    #[payable]
    fn remove_from_whitelist(&mut self, requestor: Requestor) {
        self.assert_gov();

        let initial_storage = env::storage_usage();

        helpers::refund_storage(initial_storage, env::predecessor_account_id());
        logger::log_whitelist(&requestor, false);

        match &mut self.whitelist.0 {
            Some(whitelist) => {
                whitelist.remove(&requestor.account_id);
            }, 
            None => {
                panic!("Uninitiated whitelist")
            }
        };
    }

    fn whitelist_contains(&self, requestor: AccountId) -> bool {
        self.whitelist.contains(requestor)
    }
}

impl Contract {

    pub fn assert_whitelisted(&self, requestor: AccountId) {
        match self.whitelist.0 {
            Some(_) => {
                assert!(self.whitelist_contains(requestor), "Err predecessor is not whitelisted");
            }, 
            None => ()
        }
    }
}

#[cfg(not(target_arch = "wasm32"))]
#[cfg(test)]
mod mock_token_basic_tests {
    use near_sdk::{ MockedBlockchain };
    use near_sdk::{ testing_env, VMContext };
    use fee_config::FeeConfig;
    use super::*;

    fn alice() -> AccountId {
        "alice.near".to_string()
    }

    fn bob() -> AccountId {
        "bob.near".to_string()
    }

    fn carol() -> AccountId {
        "carol.near".to_string()
    }

    fn token() -> AccountId {
        "token.near".to_string()
    }

    fn gov() -> AccountId {
        "gov.near".to_string()
    }

    fn registry_entry(account: AccountId) -> Requestor {
        Requestor {
            interface_name: account.clone(),
            account_id: account.clone(),
            stake_multiplier: None,
            code_base_url: None
        }
    }

    fn config() -> oracle_config::OracleConfig {
        oracle_config::OracleConfig {
            gov: gov(),
            final_arbitrator: alice(),
            payment_token: token(),
            stake_token: token(),
            validity_bond: U128(0),
            max_outcomes: 8,
            default_challenge_window_duration: U64(1000),
            min_initial_challenge_window_duration: U64(1000),
            final_arbitrator_invoke_amount: U128(25_000_000_000_000_000_000_000_000_000_000),
            fee: FeeConfig {
                flux_market_cap: U128(50000),
                total_value_staked: U128(10000),
                resolution_fee_percentage: 5000, // 5%
            }
        }
    }

    fn get_context(predecessor_account_id: AccountId) -> VMContext {
        VMContext {
            current_account_id: token(),
            signer_account_id: bob(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 1000 * 10u128.pow(24),
            account_locked_balance: 0,
            storage_usage: 10u64.pow(6),
            attached_deposit: 1000 * 10u128.pow(24),
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 0,
        }
    }

    #[test]
    fn setting_initial_whitelist() {
        testing_env!(get_context(carol()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let contract = Contract::new(whitelist, config());
        let alice_is_whitelisted = contract.whitelist_contains(alice());
        let bob_is_whitelisted = contract.whitelist_contains(bob());
        let carol_is_whitelisted = contract.whitelist_contains(carol());
        assert!(!alice_is_whitelisted);
        assert!(bob_is_whitelisted);
        assert!(carol_is_whitelisted);
    }

    #[test]
    fn whitelist_add_remove() {
        testing_env!(get_context(gov()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());

        assert!(!contract.whitelist_contains(alice()));
        contract.add_to_whitelist(registry_entry(alice()));
        assert!(contract.whitelist_contains(alice()));
        contract.remove_from_whitelist(registry_entry(alice()));
        assert!(!contract.whitelist_contains(alice()));
    }

    #[test]
    fn whitelist_assert_passes_when_empty() {
        testing_env!(get_context(gov()));
        let whitelist = None;
        let contract = Contract::new(whitelist, config());
        contract.assert_whitelisted(alice());
    }

    #[test]
    #[should_panic(expected = "This method is only callable by the governance contract gov.near")]
    fn only_gov_can_add() {
        testing_env!(get_context(alice()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        contract.add_to_whitelist(registry_entry(alice()));
    }

    #[test]
    #[should_panic(expected = "This method is only callable by the governance contract gov.near")]
    fn only_gov_can_remove() {
        testing_env!(get_context(alice()));
        let whitelist = Some(vec![registry_entry(bob()), registry_entry(carol())]);
        let mut contract = Contract::new(whitelist, config());
        contract.remove_from_whitelist(registry_entry(alice()));
    }
}

'''
'''--- oracle/tests/it/dr_basic_tests.rs ---
use crate::utils::*;

#[test]
fn dr_new_test() {
    let init_res = TestUtils::init(None);
    let new_res = init_res.alice.dr_new(0, None);
    println!("dr {:?}", new_res);
    let dr_exist = init_res.alice.dr_exists(0);
    assert!(dr_exist, "something went wrong during dr creation");
}
'''
'''--- oracle/tests/it/dr_resolution_tests.rs ---
use crate::utils::*;
use oracle::data_request::PERCENTAGE_DIVISOR;

#[test]
fn dr_claim_flow() {
    let stake_amount = to_yocto("250"); 
    let stake_cost = 200;
    let validity_bond = 100;
    let fee = 5;

    let init_res = TestUtils::init(None);
    let init_balance_alice = init_res.alice.get_token_balance(None);

    let _res = init_res.alice.dr_new(fee, None);
    let post_new_balance_oracle = init_res.alice.get_token_balance(Some(ORACLE_CONTRACT_ID.to_string()));
    assert_eq!(post_new_balance_oracle, validity_bond + fee);

    let dr_exist = init_res.alice.dr_exists(0);
    assert!(dr_exist, "something went wrong during dr creation");
    let outcome = Outcome::Answer(
        AnswerType::String("test".to_string())
    );
    let _res = init_res.alice.stake(0, outcome, stake_amount);
    println!("response {:?}", _res);

    let _post_stake_balance_oracle = init_res.alice.get_token_balance(Some(ORACLE_CONTRACT_ID.to_string()));
    let post_stake_balance_alice = init_res.alice.get_token_balance(None);
    assert_eq!(post_stake_balance_alice, init_balance_alice - stake_cost - validity_bond - fee);
    
    init_res.bob.ft_transfer(&REQUESTOR_CONTRACT_ID, 1_000_000);
    init_res.alice.finalize(0);
    // init_res.alice.claim(0);
    
    // let post_claim_balance_alice = init_res.alice.get_token_balance(None);
    // assert_eq!(post_claim_balance_alice, init_balance_alice);
}

#[test]
fn dr_fixed_fee_flow() {
    let custom_fee_amount = 100;
    let stake_amount = to_yocto("250");
    let dr_cost = 1 + custom_fee_amount;

    let init_res = TestUtils::init(Some(TestSetupArgs {
        stake_multiplier: None,
        validity_bond: 1,
        final_arbitrator_invoke_amount: 2500
    }));

    let init_balance_alice = init_res.alice.get_token_balance(None);

    let _res = init_res.alice.dr_new(custom_fee_amount, Some(1));
    let _post_new_balance_oracle = init_res.alice.get_token_balance(Some(ORACLE_CONTRACT_ID.to_string()));
    
    let dr_exist = init_res.alice.dr_exists(0);
    assert!(dr_exist, "something went wrong during dr creation");
    let outcome = Outcome::Answer(
        AnswerType::String("test".to_string())
    );
    let _res = init_res.alice.stake(0, outcome, stake_amount);

    println!("res {:?}", _res);

    let _post_stake_balance_oracle = init_res.alice.get_token_balance(Some(ORACLE_CONTRACT_ID.to_string()));
    let post_stake_balance_alice = init_res.alice.get_token_balance(None);
    assert_eq!(post_stake_balance_alice, init_balance_alice - dr_cost - custom_fee_amount*2);
    
    init_res.bob.ft_transfer(&REQUESTOR_CONTRACT_ID, 100_000);

    init_res.alice.finalize(0);
    init_res.alice.claim(0);
    
    let post_claim_balance_alice = init_res.alice.get_token_balance(None);
    assert_eq!(post_claim_balance_alice, init_balance_alice);
}

#[test]
fn dr_multiplier_flow() {
    let stake_cost = 200;
    let multiplier_amount = 10500_u16; // 105%
    let stake_amount = to_yocto("250");
    let dr_cost = 101;
    let init_res = TestUtils::init(Some(TestSetupArgs {
        stake_multiplier: Some(multiplier_amount),
        validity_bond: 1,
        final_arbitrator_invoke_amount: 2500
    }));
        let init_balance_alice = init_res.alice.get_token_balance(None);

    let _res = init_res.alice.dr_new(100, Some(1));
    let _post_new_balance_oracle = init_res.alice.get_token_balance(Some(ORACLE_CONTRACT_ID.to_string()));
    
    let dr_exist = init_res.alice.dr_exists(0);
    assert!(dr_exist, "something went wrong during dr creation");
    let outcome = Outcome::Answer(
        AnswerType::String("test".to_string())
    );
    let _res = init_res.alice.stake(0, outcome, stake_amount);

    let _post_stake_balance_oracle = init_res.alice.get_token_balance(Some(ORACLE_CONTRACT_ID.to_string()));
    let post_stake_balance_alice = init_res.alice.get_token_balance(None);
    let weighted_stake_cost = u128::from(stake_cost as u64 * multiplier_amount as u64 / PERCENTAGE_DIVISOR as u64);
    assert_eq!(post_stake_balance_alice, init_balance_alice - dr_cost - weighted_stake_cost);
    
    init_res.bob.ft_transfer(&REQUESTOR_CONTRACT_ID, 100_000);

    init_res.alice.finalize(0);
    init_res.alice.claim(0);
    
    let post_claim_balance_alice = init_res.alice.get_token_balance(None);
    assert_eq!(post_claim_balance_alice, init_balance_alice);
}

'''
'''--- oracle/tests/it/dr_scenario_tests.rs ---
use crate::utils::*;

// Scenario: Bob stakes correctly and Carol takes turns (incorrectly) disputing
// until the final arbitrator is invoked and Alice must finalize
#[test]
fn dr_scenario_1() {
    // configure test options and create data request
    let validity_bond = 1;
    let init_res = TestUtils::init(Some(TestSetupArgs {
        stake_multiplier: None,
        validity_bond,
        final_arbitrator_invoke_amount: 2500
    }));
    let init_balance_alice = init_res.alice.get_token_balance(None);
    let init_balance_bob = init_res.bob.get_token_balance(None);
    let init_balance_carol = init_res.carol.get_token_balance(None);
    println!("Request interface before data request creation: {}", init_res.alice.get_token_balance(Some(REQUESTOR_CONTRACT_ID.to_string())));
    let _new_dr_res = init_res.alice.dr_new(0, Some(validity_bond));
    let dr_exist = init_res.alice.dr_exists(0);
    assert!(dr_exist, "something went wrong during dr creation");
    
    println!("Request interface before staking: {}", init_res.alice.get_token_balance(Some(REQUESTOR_CONTRACT_ID.to_string())));
    // println!("Bob balance before staking:   {}", init_balance_bob); // same for carol
    
    for i in 0..12 {
        let bond_size = calc_bond_size(validity_bond, i, None); // stake 2, 4, 16, 32, ...
        // even numbers => Bob stakes on correct outcome
        // odd numbers => Carol stakes on incorrect outcome
        match i % 2 == 0 {
            true => {
                println!("Round {}, bond size: {}, staking correctly with Bob", i, bond_size);
                let pre_stake_balance_bob = init_res.bob.get_token_balance(None);
                let outcome_to_stake = Outcome::Answer(AnswerType::String("test".to_string()));
                let _res = init_res.bob.stake(0, outcome_to_stake, bond_size);
                let post_stake_balance_bob = init_res.bob.get_token_balance(None);
                // make sure no refund (bond size is exactly met)
                assert_eq!(post_stake_balance_bob, pre_stake_balance_bob - bond_size);
            },
            false => {
                println!("Round {}, bond size: {}, staking incorrectly with Carol", i, bond_size);
                let pre_stake_balance_carol = init_res.carol.get_token_balance(None);
                let outcome_to_stake = Outcome::Answer(AnswerType::String("test_wrong".to_string()));
                let _res = init_res.carol.stake(0, outcome_to_stake, bond_size);
                let post_stake_balance_carol = init_res.carol.get_token_balance(None);
                // make sure no refund (bond size is exactly met)
                assert_eq!(post_stake_balance_carol, pre_stake_balance_carol - bond_size);
            }
        };
        // println!("Request interface balance after stake: {}", init_res.alice.get_token_balance(Some(REQUESTOR_CONTRACT_ID.to_string())));
    }
    
    // since final arbitrator is invoked, any stakes after this point will be fully refunded
    
    // get balances before finalization and claim and amount spent on staking
    let pre_claim_balance_bob = init_res.bob.get_token_balance(None);
    let pre_claim_balance_carol = init_res.carol.get_token_balance(None);
    let pre_claim_difference_bob = init_balance_bob - pre_claim_balance_bob;
    let pre_claim_difference_carol = init_balance_carol - pre_claim_balance_carol;
    println!("Bob pre-claim balance:    {}", pre_claim_balance_bob);
    println!("Carol pre-claim balance:  {}", pre_claim_balance_carol);
    println!("Bob has spent {} altogether on staking", pre_claim_difference_bob);
    println!("Carol has spent {} altogether on staking", pre_claim_difference_carol);
    
    // // finalize
    println!("Request interface balance before claim: {}", init_res.alice.get_token_balance(Some(REQUESTOR_CONTRACT_ID.to_string())));
    let correct_outcome = Outcome::Answer(AnswerType::String("test".to_string()));
    init_res.alice.dr_final_arbitrator_finalize(0, correct_outcome);
    let post_outcome = init_res.alice.get_outcome(0);
    println!("Outcome after finalize: {:?}", post_outcome);

    // claim
    let _claim_res = init_res.bob.claim(0);
    
    // get balances and differences from after staking/before claiming and before staking
    let post_balance_alice = init_res.alice.get_token_balance(None);
    let post_balance_bob = init_res.bob.get_token_balance(None);
    let post_balance_carol = init_res.carol.get_token_balance(None);
    let post_stake_difference_bob = post_balance_bob - pre_claim_balance_bob;
    let post_stake_difference_carol = post_balance_carol - pre_claim_balance_carol;
    let post_total_difference_bob = post_balance_bob - init_balance_bob;
    let post_total_difference_carol = init_balance_carol - post_balance_carol;
    let post_total_difference_alice = init_balance_alice - post_balance_alice;
    
    println!("Alice final balance:             {}", post_balance_alice);
    println!("Bob final balance:               {}", post_balance_bob);
    println!("Carol final balance:             {}", post_balance_carol);
    println!("Request interface final balance: {}", init_res.alice.get_token_balance(Some(REQUESTOR_CONTRACT_ID.to_string())));
    
    println!("Bob gained {} from claim for a total profit of {}", post_stake_difference_bob, post_total_difference_bob);
    println!("Carol gained {} from claim for a total loss of {}", post_stake_difference_carol, post_total_difference_carol);
    println!("Alice lost {} altogether from validity bond", post_total_difference_alice);
    
}

// Scenario: Bob, Carol, and Jasper work together fill each resolution window
// (1/4 Bob, 1/4 Carol, 1/2 Jasper) while Peter escalates with a wrong staked
// outcome
#[test]
fn dr_scenario_2() {
    // configure test options and create data request
    let validity_bond = 2;
    let init_res = TestUtils::init(Some(TestSetupArgs {
        stake_multiplier: None,
        validity_bond,
        final_arbitrator_invoke_amount: 2500
    }));
    let init_balance_alice = init_res.alice.get_token_balance(None);
    let init_balance_bob = init_res.bob.get_token_balance(None);
    let init_balance_carol = init_res.carol.get_token_balance(None);
    let init_balance_jasper = init_res.jasper.get_token_balance(None);
    let init_balance_peter = init_res.peter.get_token_balance(None);
    let _new_dr_res = init_res.alice.dr_new(0, Some(2));
    let dr_exist = init_res.alice.dr_exists(0);
    assert!(dr_exist, "something went wrong during dr creation");
    
    // println!("Bob balance before staking:    {}", init_balance_bob); // same for carol, ...
    
    for i in 0..7 {
        let bond_size = calc_bond_size(validity_bond, i, None); // stake 4, 16, 32, ...
        // even numbers => Bob, Carol, Jasper stake on correct outcome
        // odd numbers => Peter stakes on incorrect outcome
        match i % 2 == 0 {
            true => {
                let quarter_of_bond = bond_size / 4;
                println!(
                    "Round {}, bond size: {}, staking correctly with Bob({}), Carol({}), Jasper({})",
                    i,
                    bond_size,
                    quarter_of_bond,
                    quarter_of_bond,
                    (quarter_of_bond*2)
                );
                let outcome_to_stake = Outcome::Answer(AnswerType::String("test".to_string()));
                let _res = init_res.bob.stake(0, outcome_to_stake.clone(), quarter_of_bond);
                let _res = init_res.carol.stake(0, outcome_to_stake.clone(), quarter_of_bond);
                let _res = init_res.jasper.stake(0, outcome_to_stake, quarter_of_bond*2);
            },
            false => {
                println!("Round {}, bond size: {}, staking incorrectly with Peter", i, bond_size);
                let outcome_to_stake = Outcome::Answer(AnswerType::String("test_wrong".to_string()));
                let _res = init_res.peter.stake(0, outcome_to_stake, bond_size);
            }
        };
    }
    
    // get balances before finalization and claim and amount spent on staking 
    let pre_claim_balance_bob = init_res.bob.get_token_balance(None);
    let pre_claim_balance_carol = init_res.carol.get_token_balance(None);
    let pre_claim_balance_jasper = init_res.jasper.get_token_balance(None);
    let pre_claim_balance_peter = init_res.peter.get_token_balance(None);
    let pre_claim_difference_bob = init_balance_bob - pre_claim_balance_bob;
    let pre_claim_difference_carol = init_balance_carol - pre_claim_balance_carol;
    let pre_claim_difference_jasper = init_balance_jasper - pre_claim_balance_jasper;
    let pre_claim_difference_peter = init_balance_peter - pre_claim_balance_peter;
    println!("Bob pre-claim balance:     {}", pre_claim_balance_bob);
    println!("Carol pre-claim balance:   {}", pre_claim_balance_carol);
    println!("Jasper pre-claim balance:  {}", pre_claim_balance_jasper);
    println!("Peter pre-claim balance:   {}", pre_claim_balance_peter);
    println!("Bob has spent {} altogether on staking", pre_claim_difference_bob);
    println!("Carol has spent {} altogether on staking", pre_claim_difference_carol);
    println!("Jasper has spent {} altogether on staking", pre_claim_difference_jasper);
    println!("Peter has spent {} altogether on staking", pre_claim_difference_peter);
    
    init_res.treasurer.ft_transfer(&REQUESTOR_CONTRACT_ID, 100_000);
    init_res.alice.finalize(0);
    let post_outcome = init_res.alice.get_outcome(0);
    println!("Outcome on target after finalize: {:?}", post_outcome);

    // claim
    init_res.bob.claim(0);
    init_res.carol.claim(0);
    init_res.jasper.claim(0);
    // init_res.peter.claim(0);
    
    // get balances and differences from after staking/before claiming and before staking
    let post_balance_alice = init_res.alice.get_token_balance(None);
    let post_balance_bob = init_res.bob.get_token_balance(None);
    let post_balance_carol = init_res.carol.get_token_balance(None);
    let post_balance_jasper = init_res.jasper.get_token_balance(None);
    let post_balance_peter = init_res.peter.get_token_balance(None);
    let post_stake_difference_bob = post_balance_bob - pre_claim_balance_bob;
    let post_stake_difference_carol = post_balance_carol - pre_claim_balance_carol;
    let post_stake_difference_jasper = post_balance_jasper - pre_claim_balance_jasper;
    let post_stake_difference_peter = pre_claim_balance_peter - post_balance_peter;
    let post_total_difference_bob = post_balance_bob - init_balance_bob;
    let post_total_difference_carol = post_balance_carol - init_balance_carol;
    let post_total_difference_jasper = post_balance_jasper - init_balance_jasper;
    let post_total_difference_peter = init_balance_peter - post_balance_peter;
    let post_total_difference_alice = init_balance_alice - post_balance_alice;

    println!("Alice final balance:  {}", post_balance_alice);
    println!("Bob final balance:    {}", post_balance_bob);
    println!("Carol final balance:  {}", post_balance_carol);
    println!("Jasper final balance: {}", post_balance_jasper);
    println!("Peter final balance:  {}", post_balance_peter);

    println!("Bob gained {} from claim for a total profit of {}", post_stake_difference_bob, post_total_difference_bob);
    println!("Carol gained {} from claim for a total profit of {}", post_stake_difference_carol, post_total_difference_carol);
    println!("Jasper gained {} from claim for a total profit of {}", post_stake_difference_jasper, post_total_difference_jasper);
    println!("Peter gained {} from claim for a total profit of {}", post_stake_difference_peter, post_total_difference_peter);
    println!("Alice lost {} altogether", post_total_difference_alice);

    
}

// Scenario: Peter, Illia, and Vitalik work together to fill each resolution
// window with the incorrect outcome while Bob, Carol, and Jasper escalate with
// the correct staked outcome, all with proportional amounts staked
#[test]
fn dr_scenario_3() {
    // configure test options and create data request
    let validity_bond = 3;
    let init_res = TestUtils::init(Some(TestSetupArgs {
        stake_multiplier: None,
        validity_bond,
        final_arbitrator_invoke_amount: 2500
    }));
    let init_balance_alice = init_res.alice.get_token_balance(None);
    let init_balance_bob = init_res.bob.get_token_balance(None);
    let init_balance_carol = init_res.carol.get_token_balance(None);
    let init_balance_jasper = init_res.jasper.get_token_balance(None);
    let init_balance_peter = init_res.peter.get_token_balance(None);
    let init_balance_illia = init_res.peter.get_token_balance(None);
    let init_balance_vitalik = init_res.peter.get_token_balance(None);
    let _new_dr_res = init_res.alice.dr_new(0, Some(3));
    let dr_exist = init_res.alice.dr_exists(0);
    assert!(dr_exist, "something went wrong during dr creation");
    
    // println!("Bob balance before staking:    {}", init_balance_bob); // same for carol, ...
    
    for i in 0..8 {
        let bond_size = calc_bond_size(validity_bond, i, None); // stake 3, 6, 27, ...
        let third_of_bond = bond_size / 3;
        // even numbers => Peter, Illia, Vitalik stake on incorrect outcome
        // odd numbers => Bob, Carol, Jasper stake on correct outcome
        match i % 2 == 0 {
            true => {
                println!(
                    "Round {}, bond size: {}, staking incorrectly with Peter({}), Illia({}), Vitalik({})",
                    i,
                    bond_size,
                    third_of_bond,
                    third_of_bond,
                    third_of_bond
                );
                let outcome_to_stake = Outcome::Answer(AnswerType::String("test_wrong".to_string()));
                let _res = init_res.peter.stake(0, outcome_to_stake.clone(), third_of_bond);
                let _res = init_res.illia.stake(0, outcome_to_stake.clone(), third_of_bond);
                let _res = init_res.vitalik.stake(0, outcome_to_stake.clone(), third_of_bond);
            },
            false => {
                println!(
                    "Round {}, bond size: {}, staking correctly with Bob({}), Carol({}), Jasper({})",
                    i,
                    bond_size,
                    third_of_bond,
                    third_of_bond,
                    third_of_bond,
                );
                let outcome_to_stake = Outcome::Answer(AnswerType::String("test".to_string()));
                let _res = init_res.bob.stake(0, outcome_to_stake.clone(), third_of_bond);
                let _res = init_res.carol.stake(0, outcome_to_stake.clone(), third_of_bond);
                let _res = init_res.jasper.stake(0, outcome_to_stake.clone(), third_of_bond);
            }
        };
    }
    
    // get balances before finalization and claim and amount spent on staking
    let pre_claim_balance_bob = init_res.bob.get_token_balance(None);
    let pre_claim_balance_carol = init_res.carol.get_token_balance(None);
    let pre_claim_balance_jasper = init_res.jasper.get_token_balance(None);
    let pre_claim_balance_peter = init_res.peter.get_token_balance(None);
    let pre_claim_balance_illia = init_res.illia.get_token_balance(None);
    let pre_claim_balance_vitalik = init_res.vitalik.get_token_balance(None);
    let pre_claim_difference_bob = init_balance_bob - pre_claim_balance_bob;
    let pre_claim_difference_carol = init_balance_carol - pre_claim_balance_carol;
    let pre_claim_difference_jasper = init_balance_jasper - pre_claim_balance_jasper;
    let pre_claim_difference_peter = init_balance_peter - pre_claim_balance_peter;
    let pre_claim_difference_illia = init_balance_illia - pre_claim_balance_illia;
    let pre_claim_difference_vitalik = init_balance_vitalik - pre_claim_balance_vitalik;
    println!("Bob pre-claim balance:     {}", pre_claim_balance_bob);
    println!("Carol pre-claim balance:   {}", pre_claim_balance_carol);
    println!("Jasper pre-claim balance:  {}", pre_claim_balance_jasper);
    println!("Peter pre-claim balance:   {}", pre_claim_balance_peter);
    println!("Illia pre-claim balance:   {}", pre_claim_balance_illia);
    println!("Vitalik pre-claim balance: {}", pre_claim_balance_vitalik);
    println!("Bob has spent {} altogether on staking", pre_claim_difference_bob);
    println!("Carol has spent {} altogether on staking", pre_claim_difference_carol);
    println!("Jasper has spent {} altogether on staking", pre_claim_difference_jasper);
    println!("Peter has spent {} altogether on staking", pre_claim_difference_peter);
    println!("Illia has spent {} altogether on staking", pre_claim_difference_illia);
    println!("Vitalik has spent {} altogether on staking", pre_claim_difference_vitalik);
    
    init_res.treasurer.ft_transfer(&REQUESTOR_CONTRACT_ID, 100_000);
    init_res.alice.finalize(0);
    init_res.bob.claim(0);
    init_res.carol.claim(0);
    init_res.jasper.claim(0);
    // init_res.peter.claim(0);
    // init_res.illia.claim(0);
    // init_res.vitalik.claim(0);
    
    // get balances and differences from after staking/before claiming and before staking
    let post_balance_alice = init_res.alice.get_token_balance(None);
    let post_balance_bob = init_res.bob.get_token_balance(None);
    let post_balance_carol = init_res.carol.get_token_balance(None);
    let post_balance_jasper = init_res.jasper.get_token_balance(None);
    let post_balance_peter = init_res.peter.get_token_balance(None);
    let post_balance_illia = init_res.illia.get_token_balance(None);
    let post_balance_vitalik = init_res.vitalik.get_token_balance(None);
    let post_stake_difference_bob = post_balance_bob - pre_claim_balance_bob;
    let post_stake_difference_carol = post_balance_carol - pre_claim_balance_carol;
    let post_stake_difference_jasper = post_balance_jasper - pre_claim_balance_jasper;
    let post_stake_difference_peter = pre_claim_balance_peter - post_balance_peter;
    let post_stake_difference_illia = pre_claim_balance_illia - post_balance_illia;
    let post_stake_difference_vitalik = pre_claim_balance_vitalik - post_balance_vitalik;
    let post_total_difference_bob = post_balance_bob - init_balance_bob;
    let post_total_difference_carol = post_balance_carol - init_balance_carol;
    let post_total_difference_jasper = post_balance_jasper - init_balance_jasper;
    let post_total_difference_peter = init_balance_peter - post_balance_peter;
    let post_total_difference_illia = init_balance_illia - post_balance_illia;
    let post_total_difference_vitalik = init_balance_vitalik - post_balance_vitalik;
    let post_total_difference_alice = init_balance_alice - post_balance_alice;

    println!("Alice final balance:   {}", post_balance_alice);
    println!("Bob final balance:     {}", post_balance_bob);
    println!("Carol final balance:   {}", post_balance_carol);
    println!("Jasper final balance:  {}", post_balance_jasper);
    println!("Illia final balance:   {}", post_balance_illia);
    println!("Vitalik final balance: {}", post_balance_vitalik);
    println!("Peter final balance:   {}", post_balance_peter);

    println!("Bob gained {} from claim for a total profit of {}", post_stake_difference_bob, post_total_difference_bob);
    println!("Carol gained {} from claim for a total profit of {}", post_stake_difference_carol, post_total_difference_carol);
    println!("Jasper gained {} from claim for a total profit of {}", post_stake_difference_jasper, post_total_difference_jasper);
    println!("Peter gained {} from claim for a total loss of {}", post_stake_difference_peter, post_total_difference_peter);
    println!("Illia gained {} from claim for a total loss of {}", post_stake_difference_illia, post_total_difference_illia);
    println!("Vitalik gained {} from claim for a total loss of {}", post_stake_difference_vitalik, post_total_difference_vitalik);
    println!("Alice lost {} altogether", post_total_difference_alice);
    
}

// Scenario: Bob stakes correctly and Carol takes turns escalating with
// incorrect outcome (similar to scenario 1) with a bond multiplier of 105%
#[test]
fn dr_scenario_multiplier() {
    // configure test options and create data request
    let validity_bond = 1;
    let multiplier = 10500; // 105%
    let init_res = TestUtils::init(Some(TestSetupArgs {
        stake_multiplier: None,
        validity_bond,
        final_arbitrator_invoke_amount: 2500
    }));
    let init_balance_alice = init_res.alice.get_token_balance(None);
    let init_balance_bob = init_res.bob.get_token_balance(None);
    let init_balance_carol = init_res.carol.get_token_balance(None);
    let _new_dr_res = init_res.alice.dr_new(0, Some(1));
    let dr_exist = init_res.alice.dr_exists(0);
    assert!(dr_exist, "something went wrong during dr creation");
    
    // println!("Bob balance before staking:   {}", init_balance_bob); // same for carol
    
    for i in 0..7 {
        let bond_size = calc_bond_size(validity_bond, i, Some(multiplier)); // stake 2, 4, 16, 33, ...
        // even numbers => Bob stakes on correct outcome
        // odd numbers => Carol stakes on incorrect outcome
        match i % 2 == 0 {
            true => {
                println!("Round {}, bond size: {}, staking correctly with Bob", i, bond_size);
                let outcome_to_stake = Outcome::Answer(AnswerType::String("test".to_string()));
                let _res = init_res.bob.stake(0, outcome_to_stake, bond_size);
            },
            false => {
                println!("Round {}, bond size: {}, staking incorrectly with Carol", i, bond_size);
                let outcome_to_stake = Outcome::Answer(AnswerType::String("test_wrong".to_string()));
                let _res = init_res.carol.stake(0, outcome_to_stake, bond_size);
            }
        };
    }
    
    // get balances before finalization and claim and amount spent on staking
    let pre_claim_balance_bob = init_res.bob.get_token_balance(None);
    let pre_claim_balance_carol = init_res.carol.get_token_balance(None);
    let pre_claim_difference_bob = init_balance_bob - pre_claim_balance_bob;
    let pre_claim_difference_carol = init_balance_carol - pre_claim_balance_carol;
    println!("Bob pre-claim balance:    {}", pre_claim_balance_bob);
    println!("Carol pre-claim balance:  {}", pre_claim_balance_carol);
    println!("Bob has spent {} altogether on staking", pre_claim_difference_bob);
    println!("Carol has spent {} altogether on staking", pre_claim_difference_carol);
    
    init_res.treasurer.ft_transfer(&REQUESTOR_CONTRACT_ID, 100_000);
    init_res.alice.finalize(0);
    init_res.bob.claim(0);
    // init_res.carol.claim(0);
    
    // get balances and differences from after staking/before claiming and before staking
    let post_balance_alice = init_res.alice.get_token_balance(None);
    let post_balance_bob = init_res.bob.get_token_balance(None);
    let post_balance_carol = init_res.carol.get_token_balance(None);
    let post_stake_difference_bob = post_balance_bob - pre_claim_balance_bob;
    let post_stake_difference_carol = post_balance_carol - pre_claim_balance_carol;
    let post_total_difference_bob = post_balance_bob - init_balance_bob;
    let post_total_difference_carol = init_balance_carol - post_balance_carol;
    let post_total_difference_alice = init_balance_alice - post_balance_alice;

    println!("Alice final balance:  {}", post_balance_alice);
    println!("Bob final balance:    {}", post_balance_bob);
    println!("Carol final balance:  {}", post_balance_carol);

    println!("Bob gained {} from claim for a total profit of {}", post_stake_difference_bob, post_total_difference_bob);
    println!("Carol gained {} from claim for a total loss of {}", post_stake_difference_carol, post_total_difference_carol);
    println!("Alice lost {} altogether from validity bond", post_total_difference_alice);
    
}

// Scenario: Bob stakes correctly and Carol takes turns escalating with
// incorrect outcome (similar to scenario 1) with a fixed fee
#[test]
fn dr_scenario_fixed_fee() {
    // configure test options and create data request
    let validity_bond = 2;
    let init_res = TestUtils::init(Some(TestSetupArgs {
        stake_multiplier: None,
        validity_bond,
        final_arbitrator_invoke_amount: 2500
    }));
    let init_balance_alice = init_res.alice.get_token_balance(None);
    let init_balance_bob = init_res.bob.get_token_balance(None);
    let init_balance_carol = init_res.carol.get_token_balance(None);
    let _new_dr_res = init_res.alice.dr_new(100, Some(2));
    let dr_exist = init_res.alice.dr_exists(0);
    assert!(dr_exist, "something went wrong during dr creation");
    
    // println!("Bob balance before staking:   {}", init_balance_bob); // same for carol

    // send some funds to oracle so that is it able to pay out the fixed fee
    init_res.alice.ft_transfer(ORACLE_CONTRACT_ID, 9999);

    println!("Request interface before staking: {}", init_res.alice.get_token_balance(Some(REQUESTOR_CONTRACT_ID.to_string())));
    
    for i in 0..7 {
        let bond_size = calc_bond_size(validity_bond, i, None); // stake 2, 4, 16, 33, ...
        // even numbers => Bob stakes on correct outcome
        // odd numbers => Carol stakes on incorrect outcome
        match i % 2 == 0 {
            true => {
                println!("Round {}, bond size: {}, staking correctly with Bob", i, bond_size);
                let outcome_to_stake = Outcome::Answer(AnswerType::String("test".to_string()));
                let _res = init_res.bob.stake(0, outcome_to_stake, bond_size);
            },
            false => {
                println!("Round {}, bond size: {}, staking incorrectly with Carol", i, bond_size);
                let outcome_to_stake = Outcome::Answer(AnswerType::String("test_wrong".to_string()));
                let _res = init_res.carol.stake(0, outcome_to_stake, bond_size);
            }
        };
    }

    println!("Request interface after staking: {}", init_res.alice.get_token_balance(Some(REQUESTOR_CONTRACT_ID.to_string())));
    
    // get balances before finalization and claim and amount spent on staking
    let pre_claim_balance_bob = init_res.bob.get_token_balance(None);
    let pre_claim_balance_carol = init_res.carol.get_token_balance(None);
    let pre_claim_difference_bob = init_balance_bob - pre_claim_balance_bob;
    let pre_claim_difference_carol = init_balance_carol - pre_claim_balance_carol;
    println!("Bob pre-claim balance:    {}", pre_claim_balance_bob);
    println!("Carol pre-claim balance:  {}", pre_claim_balance_carol);
    println!("Bob has spent {} altogether on staking", pre_claim_difference_bob);
    println!("Carol has spent {} altogether on staking", pre_claim_difference_carol);
    
    init_res.treasurer.ft_transfer(&REQUESTOR_CONTRACT_ID, 100_000);
    init_res.alice.finalize(0);
    init_res.bob.claim(0);
    // init_res.carol.claim(0);
    
    // get balances and differences from after staking/before claiming and before staking
    let post_balance_alice = init_res.alice.get_token_balance(None);
    let post_balance_bob = init_res.bob.get_token_balance(None);
    let post_balance_carol = init_res.carol.get_token_balance(None);
    let post_stake_difference_bob = post_balance_bob - pre_claim_balance_bob;
    let post_stake_difference_carol = post_balance_carol - pre_claim_balance_carol;
    let post_total_difference_bob = post_balance_bob - init_balance_bob;
    let post_total_difference_carol = init_balance_carol - post_balance_carol;
    let post_total_difference_alice = init_balance_alice - post_balance_alice;

    println!("Alice final balance:             {}", post_balance_alice);
    println!("Bob final balance:               {}", post_balance_bob);
    println!("Carol final balance:             {}", post_balance_carol);
    println!("Request interface final balance: {}", init_res.alice.get_token_balance(Some(REQUESTOR_CONTRACT_ID.to_string())));

    println!("Bob gained {} from claim for a total profit of {}", post_stake_difference_bob, post_total_difference_bob);
    println!("Carol gained {} from claim for a total loss of {}", post_stake_difference_carol, post_total_difference_carol);
    println!("Alice lost {} altogether", post_total_difference_alice);
    
}
'''
'''--- oracle/tests/it/init.rs ---
use crate::utils::*;

#[test]
fn test_initiation() {
    let _init_res = TestUtils::init(None);
}

#[test]
fn test_balances() {
    let init_res = TestUtils::init(None);
    let balance = init_res.alice.get_token_balance(None);
    assert_eq!(balance, init_balance() / 2);
}

'''
'''--- oracle/tests/it/main.rs ---
#[path = "utils/lib.rs"]
mod utils;

mod init;
mod dr_resolution_tests;
mod dr_basic_tests;
mod dr_scenario_tests;
'''
'''--- oracle/tests/it/utils/account_utils.rs ---
use crate::utils::*;
use oracle::data_request::DataRequestDataType;
use oracle::types::*;
pub fn init_balance() -> u128 {
    to_yocto("100000")
}

pub struct TestAccount {
    pub account: UserAccount
}

impl TestAccount {
    pub fn new(
        master_account: Option<&UserAccount>, 
        account_id: Option<&str>
    ) -> Self {
        match master_account {
            Some(master_account) => {
                let account = master_account.create_user(account_id.expect("expected account id").to_string(), init_balance());
                storage_deposit(TOKEN_CONTRACT_ID, &master_account, SAFE_STORAGE_AMOUNT, Some(account.account_id())); 
                storage_deposit(ORACLE_CONTRACT_ID, &master_account, 46800000000000000000000, Some(account.account_id())); 
                storage_deposit(ORACLE_CONTRACT_ID, &master_account, 46800000000000000000000, Some(REQUESTOR_CONTRACT_ID.to_string())); 
                near_deposit(&account, init_balance() / 2);
                Self {
                    account
                }
            },
            None => Self { account: init_simulator(None) }
        }
    }

    /*** Getters ***/
    pub fn get_token_balance(&self, account_id: Option<String>) -> u128 {
        let account_id = match account_id {
            Some(account_id) => account_id,
            None => self.account.account_id()
        };

        let res: U128 = self.account.view(
            TOKEN_CONTRACT_ID.to_string(),
            "ft_balance_of",
            json!({
                "account_id": account_id
            }).to_string().as_bytes()
        ).unwrap_json();

        res.into()
    }

    pub fn dr_exists(&self, id: u64) -> bool {
        self.account.view(
            ORACLE_CONTRACT_ID.to_string(),
            "dr_exists",
            json!({
                "id": U64(id)
            }).to_string().as_bytes()
        ).unwrap_json()
    }

    pub fn get_outcome(&self, id: u64) -> Option<Outcome> {
        self.account.call(
            REQUESTOR_CONTRACT_ID.to_string(),
            "get_outcome",
            json!({
                "request_id": U64(id)
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            0
        ).unwrap_json()
    }
    
    /*** Setters ***/
    pub fn dr_new(
        &self,
        fee: u128,
        custom_validity_bond: Option<u128>
    ) -> ExecutionResult {

        // Transfer validity bond to to the request interface contract, this way it has balance to pay for the DataRequest creation
        let transfer_res = self.account.call(
            TOKEN_CONTRACT_ID.to_string(), 
            "ft_transfer", 
            json!({
                "receiver_id": REQUESTOR_CONTRACT_ID,
                "amount": U128(custom_validity_bond.unwrap_or(VALIDITY_BOND) + fee),
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            1
        );
        assert!(transfer_res.is_ok(), "ft_transfer_call failed with res: {:?}", transfer_res);
        
        let dr_new_res = self.account.call(
            REQUESTOR_CONTRACT_ID.to_string(), 
            "create_data_request", 
            json!({
                "amount": U128(custom_validity_bond.unwrap_or(VALIDITY_BOND) + fee),
                "payload": NewDataRequestArgs {
                    sources: vec![],
                    tags: None,
                    description: Some("test description".to_string()),
                    outcomes: None,
                    challenge_period: U64(1000),
                    data_type: DataRequestDataType::String,
                    creator: self.account.account_id(),
                }
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            0
        );

        assert!(dr_new_res.is_ok(), "ft_transfer_call failed with res: {:?}", dr_new_res);
        dr_new_res
    }

    pub fn stake(
        &self,
        dr_id: u64, 
        outcome: Outcome,
        amount: u128
    ) -> ExecutionResult {
        let msg = json!({
            "StakeDataRequest": {
                "outcome": outcome,
                "id": U64(dr_id)
            }
        }).to_string();
        let res = self.ft_transfer_call(ORACLE_CONTRACT_ID, amount, msg);
        res.assert_success();
        res
    }

    pub fn finalize(
        &self,
        dr_id: u64
    ) -> ExecutionResult {
        let res = self.account.call(
            ORACLE_CONTRACT_ID.to_string(), 
            "dr_finalize", 
            json!({
                "request_id": U64(dr_id)
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            0
        );

        res.assert_success();
        res
    }

    pub fn dr_final_arbitrator_finalize(
        &self,
        dr_id: u64,
        outcome: Outcome
    ) -> ExecutionResult {
        let res = self.account.call(
            ORACLE_CONTRACT_ID.to_string(), 
            "dr_final_arbitrator_finalize", 
            json!({
                "request_id": U64(dr_id),
                "outcome": outcome
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            1600000000000000000000
        );

        res.assert_success();
        res
    }

    pub fn claim(
        &self,
        dr_id: u64
    ) -> ExecutionResult {
        let res = self.account.call(
            ORACLE_CONTRACT_ID.to_string(), 
            "dr_claim", 
            json!({
                "account_id": self.account.account_id(),
                "request_id": U64(dr_id)
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            1000000000000000000000
        );

        res.assert_success();
        res
    }

    fn ft_transfer_call(
        &self,
        receiver: &str,
        amount: u128,
        msg: String
    ) -> ExecutionResult {        
        let res = self.account.call(
            TOKEN_CONTRACT_ID.to_string(), 
            "ft_transfer_call", 
            json!({
                "receiver_id": receiver,
                "amount": U128(amount),
                "msg": msg,
                "memo": "".to_string()
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            1
        );

        assert!(res.is_ok(), "ft_transfer_call failed with res: {:?}", res);
        res
    }

    pub fn ft_transfer(
        &self,
        receiver: &str,
        amount: u128
    ) -> ExecutionResult {        
        let res = self.account.call(
            TOKEN_CONTRACT_ID.to_string(), 
            "ft_transfer", 
            json!({
                "receiver_id": receiver,
                "amount": U128(amount),
            }).to_string().as_bytes(),
            DEFAULT_GAS,
            1
        );

        assert!(res.is_ok(), "ft_transfer failed with res: {:?}", res);
        res
    }

}

'''
'''--- oracle/tests/it/utils/deposit.rs ---
use crate::utils::*;

pub fn storage_deposit(
    receiver: &str, 
    sender: &UserAccount, 
    deposit: u128, 
    to_register: Option<AccountId>
) {
    let res = sender.call(
        receiver.to_string(),
        "storage_deposit",
        json!({
            "account_id": to_register
        }).to_string().as_bytes(),
        DEFAULT_GAS,
        deposit
    );

    assert!(res.is_ok(), "storage deposit failed with res: {:?}", res);
}

pub fn near_deposit(sender: &UserAccount, deposit: u128) {
    let res = sender.call(
        TOKEN_CONTRACT_ID.to_string(),
        "near_deposit",
        json!({}).to_string().as_bytes(),
        DEFAULT_GAS,
        deposit
    );
    assert!(res.is_ok(), "wnear deposit failed with res: {:?}", res);
}
'''
'''--- oracle/tests/it/utils/lib.rs ---
#![allow(clippy::needless_pass_by_value)]
use near_sdk::{
    AccountId,
    json_types::{
        U64,
        U128,
        // ValidAccountId
    },
    serde_json::json,
    // serde_json
};

pub use near_sdk_sim::{
    ExecutionResult,
    deploy, 
    init_simulator, 
    to_yocto, 
    ContractAccount, 
    UserAccount, 
    DEFAULT_GAS
};
mod account_utils;
mod oracle_utils;
mod token_utils;
mod request_interface_utils;
mod deposit;

// pub use account_utils::*;
extern crate oracle;
pub use oracle::*;
pub use types::*;
pub use account_utils::*;
use deposit::*;
use request_interface;
use token;
use oracle::data_request::PERCENTAGE_DIVISOR;
use uint::construct_uint;

construct_uint! {
    /// 256-bit unsigned integer.
    pub struct u256(4);
}

type OracleContract = oracle::ContractContract;
type RequestInterfaceContract = request_interface::RequestorContractContract;
type TokenContract = token::TokenContractContract;

pub const TOKEN_CONTRACT_ID: &str = "token";
pub const ORACLE_CONTRACT_ID: &str = "oracle";
pub const REQUESTOR_CONTRACT_ID: &str = "requestor";
pub const SAFE_STORAGE_AMOUNT: u128 = 1250000000000000000000;
pub const VALIDITY_BOND: u128 = 100;

pub fn calc_product(a: u128, b: u128, divisor: u128) -> u128 {
    let a_u256 = u256::from(a);
    let b_u256 = u256::from(b);
    let divisor_u256 = u256::from(divisor);

    (a_u256 * b_u256 / divisor_u256).as_u128()
}

pub fn calc_bond_size(validity_bond: u128, round: u32, multiplier: Option<u16>) -> u128 {
    calc_product(validity_bond * 2u128.pow(round+1), multiplier.unwrap_or(10000).into(), PERCENTAGE_DIVISOR.into())
}

// Load in contract bytes
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    ORACLE_WASM_BYTES => "../res/oracle.wasm",
    REQUEST_INTERFACE_WASM_BYTES => "../res/request_interface.wasm",
    TOKEN_WASM_BYTES => "../res/token.wasm"
}

pub struct TestUtils {
    pub master_account: TestAccount,
    pub oracle_contract: ContractAccount<OracleContract>,
    pub token_contract: ContractAccount<TokenContract>,
    pub request_interface_contract: ContractAccount<RequestInterfaceContract>,
    pub alice: account_utils::TestAccount,
    pub bob: account_utils::TestAccount,
    pub carol: account_utils::TestAccount,
    pub jasper: account_utils::TestAccount,
    pub peter: account_utils::TestAccount,
    pub illia: account_utils::TestAccount,
    pub vitalik: account_utils::TestAccount,
    pub treasurer: account_utils::TestAccount,
}

pub struct TestSetupArgs {
    pub stake_multiplier: Option<u16>,
    pub validity_bond: u128,
    pub final_arbitrator_invoke_amount: u128
}

impl TestUtils {
    pub fn init(
        test_setup_args: Option<TestSetupArgs>
    ) -> Self {
        let args = test_setup_args.unwrap_or(
            TestSetupArgs {
                stake_multiplier: None,
                validity_bond: VALIDITY_BOND,
                final_arbitrator_invoke_amount: 2500
            }
        );

        let master_account = TestAccount::new(None, None);
        let token_init_res = token_utils::TokenUtils::new(&master_account); // Init token
        let oracle_init_res = oracle_utils::OracleUtils::new(&master_account, args.validity_bond, args.final_arbitrator_invoke_amount, args.stake_multiplier);  // Init oracle
        let request_interface_init_res = request_interface_utils::RequestInterfaceUtils::new(&master_account);

        Self {
            alice: TestAccount::new(Some(&master_account.account), Some("alice")),
            bob: TestAccount::new(Some(&master_account.account), Some("bob")),
            carol: TestAccount::new(Some(&master_account.account), Some("carol")),
            jasper: TestAccount::new(Some(&master_account.account), Some("jasper")),
            peter: TestAccount::new(Some(&master_account.account), Some("peter")),
            illia: TestAccount::new(Some(&master_account.account), Some("illia")),
            vitalik: TestAccount::new(Some(&master_account.account), Some("vitalik")),
            treasurer: TestAccount::new(Some(&master_account.account), Some("treasurer")),
            master_account: master_account,
            request_interface_contract: request_interface_init_res.contract,
            oracle_contract: oracle_init_res.contract,
            token_contract: token_init_res.contract
        }
    }
}

'''
'''--- oracle/tests/it/utils/oracle_utils.rs ---
use crate::utils::*;
use oracle::oracle_config::OracleConfig;
use oracle::{Requestor};
use oracle::fee_config::FeeConfig;

pub struct OracleUtils {
    pub contract: ContractAccount<OracleContract>
}

fn new_registry_entry(contract_id: String, stake_multiplier: Option<u16>) -> Requestor {
    Requestor {
        code_base_url: None,
        account_id: contract_id,
        interface_name: "test".to_string(),
        stake_multiplier
    }
}

impl OracleUtils {
    pub fn new(
        master_account: &TestAccount,
        validity_bond: u128,
        final_arbitrator_invoke_amount: u128,
        stake_multiplier: Option<u16>
    ) -> Self {        
        let config = OracleConfig {
            gov: "alice".to_string(),
            final_arbitrator: "alice".to_string(),
            payment_token: TOKEN_CONTRACT_ID.to_string(),
            stake_token: TOKEN_CONTRACT_ID.to_string(),
            validity_bond: U128(validity_bond),
            max_outcomes: 8,
            default_challenge_window_duration: U64(1000),
            min_initial_challenge_window_duration: U64(1000),
            final_arbitrator_invoke_amount: U128(final_arbitrator_invoke_amount),
            fee: FeeConfig {
                flux_market_cap: U128(50000),
                total_value_staked: U128(10000),
                resolution_fee_percentage: 5000, // 5%
            }
        };
        
        // deploy token
        let contract = deploy!(
            // Contract Proxy
            contract: OracleContract,
            // Contract account id
            contract_id: ORACLE_CONTRACT_ID,
            // Bytes of contract
            bytes: &ORACLE_WASM_BYTES,
            // User deploying the contract,
            signer_account: master_account.account,
            deposit: to_yocto("1000"),
            // init method
            init_method: new(
                Some(vec![
                        new_registry_entry(REQUESTOR_CONTRACT_ID.to_string(), stake_multiplier), 
                        new_registry_entry(REQUESTOR_CONTRACT_ID.to_string(), stake_multiplier)
                    ]
                ), 
                config
            )
        );

        storage_deposit(TOKEN_CONTRACT_ID, &master_account.account, SAFE_STORAGE_AMOUNT, Some(ORACLE_CONTRACT_ID.to_string()));

        Self {
            contract
        }
    }
}
'''
'''--- oracle/tests/it/utils/request_interface_utils.rs ---
use crate::utils::*;
pub struct RequestInterfaceUtils {
    pub contract: ContractAccount<RequestInterfaceContract>
}

impl RequestInterfaceUtils {
    pub fn new(master_account: &TestAccount) -> Self {
        // deploy token
        let contract = deploy!(
            // Contract Proxy
            contract: RequestInterfaceContract,
            // Contract account id
            contract_id: REQUESTOR_CONTRACT_ID,
            // Bytes of contract
            bytes: &REQUEST_INTERFACE_WASM_BYTES,
            // User deploying the contract,
            signer_account: master_account.account,
            deposit: to_yocto("1000"),
            // init method
            init_method: new(
                ORACLE_CONTRACT_ID.to_string(),
                TOKEN_CONTRACT_ID.to_string(),
                None
            )
        );
        
        storage_deposit(TOKEN_CONTRACT_ID, &master_account.account, SAFE_STORAGE_AMOUNT, Some(REQUESTOR_CONTRACT_ID.to_string()));
        storage_deposit(ORACLE_CONTRACT_ID, &master_account.account, 5140000000000000000000, Some(REQUESTOR_CONTRACT_ID.to_string()));

        Self {
            contract
        }
    }
}
'''
'''--- oracle/tests/it/utils/token_utils.rs ---
use crate::utils::*;
pub struct TokenUtils {
    pub contract: ContractAccount<TokenContract>
}

impl TokenUtils {
    pub fn new(master_account: &TestAccount) -> Self {
        // deploy token
        let contract = deploy!(
            // Contract Proxy
            contract: TokenContract,
            // Contract account id
            contract_id: TOKEN_CONTRACT_ID,
            // Bytes of contract
            bytes: &TOKEN_WASM_BYTES,
            // User deploying the contract,
            signer_account: master_account.account,
            deposit: to_yocto("1000"),
            // init method
            init_method: new()
        );

        Self {
            contract
        }
    }
}
'''
'''--- token/Cargo.toml ---
[package]
name = "token"
version = "0.1.0"
authors = ["Near Inc <hello@nearprotocol.com>", "Vincent <vincent@decentralisedengineeringltd.co.uk>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = { git = "https://github.com/near/near-sdk-rs.git", rev="249dacdcd3fd34bc00f0895a275f33f05cd910c1" }

[dev-dependencies]
near-sdk-sim = { git = "https://github.com/near/near-sdk-rs.git", rev="249dacdcd3fd34bc00f0895a275f33f05cd910c1" }
'''
'''--- token/README.md ---
# TBD

'''
'''--- token/scripts/build.sh ---
#!/bin/bash
set -e
RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cp ../target/wasm32-unknown-unknown/release/token.wasm ../res
cp ../res/token.wasm ../flux/tests/wasm
'''
'''--- token/src/fungible_token_core.rs ---
use crate::*;
use near_sdk::json_types::ValidAccountId;
use near_sdk::{ext_contract, Gas, PromiseResult};

const GAS_FOR_RESOLVE_TRANSFER: Gas = 5_000_000_000_000;
const GAS_FOR_FT_TRANSFER_CALL: Gas = 25_000_000_000_000 + GAS_FOR_RESOLVE_TRANSFER;

const NO_DEPOSIT: Balance = 0;

pub trait FungibleTokenCore {
    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id`.
    /// Both accounts must be registered with the contract for transfer to succeed. (See [NEP-145](https://github.com/near/NEPs/discussions/145))
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit.
    /// Exactly 1 yoctoNEAR must be attached.
    /// See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in decimal string representation.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: U128, memo: Option<String>);

    /// Transfers positive `amount` of tokens from the `env::predecessor_account_id` to `receiver_id` account. Then
    /// calls `ft_on_transfer` method on `receiver_id` contract and attaches a callback to resolve this transfer.
    /// `ft_on_transfer` method must return the amount of tokens unused by the receiver contract, the remaining tokens
    /// must be refunded to the `predecessor_account_id` at the resolve transfer callback.
    ///
    /// Token contract must pass all the remaining unused gas to the `ft_on_transfer` call.
    ///
    /// Malicious or invalid behavior by the receiver's contract:
    /// - If the receiver contract promise fails or returns invalid value, the full transfer amount must be refunded.
    /// - If the receiver contract overspent the tokens, and the `receiver_id` balance is lower than the required refund
    /// amount, the remaining balance must be refunded. See [the Security section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Both accounts must be registered with the contract for transfer to succeed. (See #145)
    /// This method must to be able to accept attached deposits, and must not panic on attached deposit. Exactly 1 yoctoNEAR must be attached. See [the Security
    /// section](https://github.com/near/NEPs/issues/141#user-content-security) of the standard.
    ///
    /// Arguments:
    /// - `receiver_id` - the account ID of the receiver contract. This contract will be called.
    /// - `amount` - the amount of tokens to transfer. Must be a positive number in a decimal string representation.
    /// - `msg` - a string message that will be passed to `ft_on_transfer` contract call.
    /// - `memo` - an optional string field in a free form to associate a memo with this transfer.
    ///
    /// Returns a promise which will result in the amount of tokens withdrawn from sender's account.
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        msg: String,
        memo: Option<String>,
    ) -> Promise;

    /// Returns the total supply of the token in a decimal string representation.
    fn ft_total_supply(&self) -> U128;

    /// Returns the balance of the account. If the account doesn't exist must returns `"0"`.
    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128;
}

#[ext_contract(ext_fungible_token_receiver)]
trait FungibleTokenReceiver {
    /// Called by fungible token contract after `ft_transfer_call` was initiated by
    /// `sender_id` of the given `amount` with the transfer message given in `msg` field.
    /// The `amount` of tokens were already transferred to this contract account and ready to be used.
    ///
    /// The method must return the amount of tokens that are *not* used/accepted by this contract from the transferred
    /// amount. Examples:
    /// - The transferred amount was `500`, the contract completely takes it and must return `0`.
    /// - The transferred amount was `500`, but this transfer call only needs `450` for the action passed in the `msg`
    ///   field, then the method must return `50`.
    /// - The transferred amount was `500`, but the action in `msg` field has expired and the transfer must be
    ///   cancelled. The method must return `500` or panic.
    ///
    /// Arguments:
    /// - `sender_id` - the account ID that initiated the transfer.
    /// - `amount` - the amount of tokens that were transferred to this account in a decimal string representation.
    /// - `msg` - a string message that was passed with this transfer call.
    ///
    /// Returns the amount of unused tokens that should be returned to sender, in a decimal string representation.
    fn ft_on_transfer(&mut self, sender_id: AccountId, amount: U128, msg: String) -> Promise;
}

#[ext_contract(ext_self)]
trait FungibleTokenResolver {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

trait FungibleTokenResolver {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128;
}

#[near_bindgen]
impl FungibleTokenCore for TokenContract {
    #[payable]
    fn ft_transfer(&mut self, receiver_id: ValidAccountId, amount: U128, memo: Option<String>) {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let amount = amount.into();
        self.internal_transfer(&sender_id, receiver_id.as_ref(), amount, memo);
    }

    #[payable]
    fn ft_transfer_call(
        &mut self,
        receiver_id: ValidAccountId,
        amount: U128,
        msg: String,
        memo: Option<String>,
    ) -> Promise {
        assert_one_yocto();
        let sender_id = env::predecessor_account_id();
        let amount = amount.into();
        self.internal_transfer(&sender_id, receiver_id.as_ref(), amount, memo);
        // Initiating receiver's call and the callback
        ext_fungible_token_receiver::ft_on_transfer(
            sender_id.clone(),
            amount.into(),
            msg,
            receiver_id.as_ref(),
            NO_DEPOSIT,
            env::prepaid_gas() - GAS_FOR_FT_TRANSFER_CALL,
        )
        .then(ext_self::ft_resolve_transfer(
            sender_id,
            receiver_id.into(),
            amount.into(),
            &env::current_account_id(),
            NO_DEPOSIT,
            GAS_FOR_RESOLVE_TRANSFER,
        ))
    }

    fn ft_total_supply(&self) -> U128 {
        self.total_supply.into()
    }

    fn ft_balance_of(&self, account_id: ValidAccountId) -> U128 {
        self.accounts.get(account_id.as_ref()).unwrap_or(0).into()
    }
}

#[near_bindgen]
impl FungibleTokenResolver for TokenContract {
    fn ft_resolve_transfer(
        &mut self,
        sender_id: AccountId,
        receiver_id: AccountId,
        amount: U128,
    ) -> U128 {
        assert_self();
        let amount: Balance = amount.into();

        // Get the unused amount from the `ft_on_transfer` call result.    
        let unused_amount = match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Successful(value) => {
                if let Ok(unused_amount) = near_sdk::serde_json::from_slice::<U128>(&value) {
                    std::cmp::min(amount, unused_amount.0)
                } else {
                    amount
                }
            }
            PromiseResult::Failed => amount,
        };

        if unused_amount > 0 {
            let receiver_balance = self.accounts.get(&receiver_id).unwrap_or(0);
            if receiver_balance > 0 {
                let refund_amount = std::cmp::min(receiver_balance, unused_amount);
                self.accounts
                    .insert(&receiver_id, &(receiver_balance - refund_amount));

                if let Some(sender_balance) = self.accounts.get(&sender_id) {
                    self.accounts
                        .insert(&sender_id, &(sender_balance + refund_amount));
                    env::log(
                        format!(
                            "Refund {} from {} to {}",
                            refund_amount, receiver_id, sender_id
                        )
                        .as_bytes(),
                    );
                    return (amount - refund_amount).into();
                } else {
                    // Sender's account was deleted, so we need to burn tokens.
                    self.total_supply -= refund_amount;
                    env::log(b"The account of the sender was deleted");
                    env::log(format!("Burn {}", refund_amount).as_bytes());
                }
            }
        }
        amount.into()
    }
}

'''
'''--- token/src/fungible_token_metadata.rs ---
use super::*;
use near_sdk::serde::Serialize;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct FungibleTokenMetadata {
    version: String,
    name: String,
    symbol: String,
    reference: String,
    decimals: u8,
}

pub trait FungibleTokenMetadataProvider {
    fn ft_metadata() -> FungibleTokenMetadata;
}

#[near_bindgen]
impl FungibleTokenMetadataProvider for TokenContract {
    fn ft_metadata() -> FungibleTokenMetadata {
        FungibleTokenMetadata {
            version: String::from("0.1.0"),
            name: String::from("Wrapped NEAR fungible token"),
            symbol: String::from("wNEAR"),
            reference: String::from(
                "https://github.com/near/core-contracts/tree/master/w-near-141",
            ),
            decimals: 24,
        }
    }
}

'''
'''--- token/src/internal.rs ---
use crate::*;

pub(crate) fn assert_one_yocto() {
    assert_eq!(
        env::attached_deposit(),
        1,
        "Requires attached deposit of exactly 1 yoctoNEAR"
    )
}

pub(crate) fn assert_self() {
    assert_eq!(
        env::predecessor_account_id(),
        env::current_account_id(),
        "Method is private"
    );
}

impl TokenContract {
    pub(crate) fn internal_deposit(&mut self, account_id: &AccountId, amount: Balance) {
        let balance = self
            .accounts
            .get(&account_id)
            .expect(format!("The account: {} is not registered", account_id).as_str());
        if let Some(new_balance) = balance.checked_add(amount) {
            self.accounts.insert(&account_id, &new_balance);
        } else {
            env::panic(b"Balance overflow");
        }
    }

    pub(crate) fn internal_withdraw(&mut self, account_id: &AccountId, amount: Balance) {
        let balance = self
            .accounts
            .get(&account_id)
            .expect("The account is not registered");
        if let Some(new_balance) = balance.checked_sub(amount) {
            self.accounts.insert(&account_id, &new_balance);
        } else {
            env::panic(format!("The account: {} doesn't have enough balance", env::predecessor_account_id()).to_string().as_bytes());
        }
    }

    pub(crate) fn internal_transfer(
        &mut self,
        sender_id: &AccountId,
        receiver_id: &AccountId,
        amount: Balance,
        memo: Option<String>,
    ) {
        assert_ne!(
            sender_id, receiver_id,
            "Sender and receiver should be different"
        );
        self.internal_withdraw(sender_id, amount);
        self.internal_deposit(receiver_id, amount);
        env::log(format!("Transfer {} from {} to {}", amount, sender_id, receiver_id).as_bytes());
        if let Some(memo) = memo {
            env::log(format!("Memo: {}", memo).as_bytes());
        }
    }
}

'''
'''--- token/src/lib.rs ---
/**
* wNear NEP-141 Token contract
*
* The aim of the contract is to enable the wrapping of the native NEAR token into a NEP-141 compatible token.
* It supports methods `near_deposit` and `near_withdraw` that wraps and unwraps NEAR tokens.
* They are effectively mint and burn underlying wNEAR tokens.
*
* lib.rs is the main entry point.
* fungible_token_core.rs implements NEP-146 standard
* storage_manager.rs implements NEP-145 standard for allocating storage per account
* fungible_token_metadata.rs implements NEP-148 standard for providing token-specific metadata.
* w_near.rs contains interfaces for depositing and withdrawing
* internal.rs contains internal methods for fungible token.
*/
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LookupMap;
use near_sdk::json_types::U128;
use near_sdk::{env, near_bindgen, AccountId, Balance, Promise, StorageUsage};

pub use crate::fungible_token_core::*;
pub use crate::fungible_token_metadata::*;
use crate::internal::*;
pub use crate::storage_manager::*;
pub use crate::w_near::*;

mod fungible_token_core;
mod fungible_token_metadata;
mod internal;
mod storage_manager;
mod w_near;

#[global_allocator]
static ALLOC: near_sdk::wee_alloc::WeeAlloc<'_> = near_sdk::wee_alloc::WeeAlloc::INIT;

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize)]
pub struct TokenContract {
    /// AccountID -> Account balance.
    pub accounts: LookupMap<AccountId, Balance>,

    /// Total supply of the all token.
    pub total_supply: Balance,

    /// The storage size in bytes for one account.
    pub account_storage_usage: StorageUsage,
}

impl Default for TokenContract {
    fn default() -> Self {
        env::panic(b"TokenContract is not initialized");
    }
}

#[near_bindgen]
impl TokenContract {
    #[init]
    pub fn new() -> Self {
        assert!(!env::state_exists(), "Already initialized");
        let mut this = Self {
            accounts: LookupMap::new(b"a".to_vec()),
            total_supply: 0,
            account_storage_usage: 0,
        };
        let initial_storage_usage = env::storage_usage();
        let tmp_account_id = unsafe { String::from_utf8_unchecked(vec![b'a'; 64]) };
        this.accounts.insert(&tmp_account_id, &0u128);
        this.account_storage_usage = env::storage_usage() - initial_storage_usage;
        this.accounts.remove(&tmp_account_id);
        this
    }
}

'''
'''--- token/src/storage_manager.rs ---
use super::*;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::Serialize;

/// Price per 1 byte of storage from mainnet config after `0.18` release and protocol version `42`.
/// It's 10 times lower than the genesis price.
const STORAGE_PRICE_PER_BYTE: Balance = 10_000_000_000_000_000_000;

#[derive(Serialize)]
#[serde(crate = "near_sdk::serde")]
pub struct AccountStorageBalance {
    total: U128,
    available: U128,
}

pub trait StorageManager {
    fn storage_deposit(&mut self, account_id: Option<ValidAccountId>) -> AccountStorageBalance;

    fn storage_withdraw(&mut self, amount: U128) -> AccountStorageBalance;

    fn storage_minimum_balance(&self) -> U128;

    fn storage_balance_of(&self, account_id: ValidAccountId) -> AccountStorageBalance;
}

#[near_bindgen]
impl StorageManager for TokenContract {
    #[payable]
    fn storage_deposit(&mut self, account_id: Option<ValidAccountId>) -> AccountStorageBalance {
        let amount = env::attached_deposit();
        assert_eq!(
            amount,
            self.storage_minimum_balance().0,
            "Requires attached deposit of the exact storage minimum balance"
        );
        let account_id = account_id
            .map(|a| a.into())
            .unwrap_or_else(|| env::predecessor_account_id());
        if self.accounts.insert(&account_id, &0).is_some() {
            env::panic(b"The account is already registered");
        }
        AccountStorageBalance {
            total: amount.into(),
            available: amount.into(),
        }
    }

    #[payable]
    fn storage_withdraw(&mut self, amount: U128) -> AccountStorageBalance {
        assert_one_yocto();
        let amount: Balance = amount.into();
        assert_eq!(
            amount,
            self.storage_minimum_balance().0,
            "The withdrawal amount should be the exact storage minimum balance"
        );
        let account_id = env::predecessor_account_id();
        if let Some(balance) = self.accounts.remove(&account_id) {
            if balance > 0 {
                env::panic(b"The account has positive token balance");
            } else {
                Promise::new(account_id).transfer(amount + 1);
                AccountStorageBalance {
                    total: 0.into(),
                    available: 0.into(),
                }
            }
        } else {
            env::panic(b"The account is not registered");
        }
    }

    fn storage_minimum_balance(&self) -> U128 {
        (Balance::from(self.account_storage_usage) * STORAGE_PRICE_PER_BYTE).into()
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> AccountStorageBalance {
        if let Some(balance) = self.accounts.get(account_id.as_ref()) {
            AccountStorageBalance {
                total: self.storage_minimum_balance(),
                available: if balance > 0 {
                    0.into()
                } else {
                    self.storage_minimum_balance()
                },
            }
        } else {
            AccountStorageBalance {
                total: 0.into(),
                available: 0.into(),
            }
        }
    }
}

'''
'''--- token/src/w_near.rs ---
use crate::*;

#[near_bindgen]
impl TokenContract {
    /// Deposit NEAR to mint wNEAR tokens to the predecessor account in this contract.
    /// Requirements:
    /// * The predecessor account should be registered.
    /// * Requires positive attached deposit.
    #[payable]
    pub fn near_deposit(&mut self) {
        let amount = env::attached_deposit();
        assert!(amount > 0, "Requires positive attached deposit");
        let account_id = env::predecessor_account_id();
        self.internal_deposit(&account_id, amount);
        self.total_supply += amount;
        env::log(format!("Deposit {} NEAR to {}", amount, account_id).as_bytes());
    }

    /// Withdraws wNEAR and send NEAR back to the predecessor account.
    /// Requirements:
    /// * The predecessor account should be registered.
    /// * `amount` must be a positive integer.
    /// * The predecessor account should have at least the `amount` of wNEAR tokens.
    /// * Requires attached deposit of exactly 1 yoctoNEAR.
    #[payable]
    pub fn near_withdraw(&mut self, amount: U128) -> Promise {
        assert_one_yocto();
        let account_id = env::predecessor_account_id();
        let amount = amount.into();
        self.internal_withdraw(&account_id, amount);
        self.total_supply -= amount;
        env::log(format!("Withdraw {} NEAR from {}", amount, account_id).as_bytes());
        // Transferring NEAR and refunding 1 yoctoNEAR.
        Promise::new(account_id).transfer(amount + 1)
    }
}

'''