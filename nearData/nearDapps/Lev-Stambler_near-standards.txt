*GitHub Repository "Lev-Stambler/near-standards"*

'''--- .github/workflows/test.yml ---
name: CI
on: push
jobs:
  test:
    runs-on: ubuntu-latest
    env:
      RUST_BACKTRACE: 1
    steps:
      - name: Checkout Code
        uses: actions/checkout@v2

      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable-2020-10-08
          target: wasm32-unknown-unknown

      - name: Add wasm32 target
        run: rustup target add wasm32-unknown-unknown

      - name: Check that build works
        run: ./build.sh
        # TODO: check that files in `res` are unchanged

      - name: Test
        uses: actions-rs/cargo@v1
        with:
          command: test

'''
'''--- .gitpod.yml ---
image:
  file: .gitpod.Dockerfile
# List the start up tasks. You can start them in parallel in multiple terminals. See https://www.gitpod.io/docs/config-start-tasks/
tasks:
  - before: echo "nvm use default" >> ~/.bashrc && npm install -g near-cli --no-optional && nvm use default
    init: yarn
    command: clear && echo Hey! Check out examples of how to build a NEP-21 Fungible Token in Rust.

'''
'''--- Cargo.toml ---
[package]
name = "fungible-token-wrapper"
version = "0.0.1"
authors = ["Near Inc <hello@near.org>"]
edition = "2018"

[dev-dependencies]
near-sdk = "3.1.0"
near-sdk-sim = "3.1.1"
near-contract-standards = "3.1.0"

# remember to include a line for each contract
dummy = { path = "./dummy" }
ft = { path = "./ft" }

[profile.release]
codegen-units = 1
# Tell `rustc` to optimize for small code size.
opt-level = "z"
lto = true
debug = false
panic = "abort"
overflow-checks = true

[workspace]
# remember to include a member for each contract
members = [
  "near-account",
  "dummy",
  "near-internal-balances-plugin"
]

'''
'''--- README-Windows.md ---
Fungible Token (FT)
===================

Example implementation of a [Fungible Token] contract which uses [near-contract-standards] and [simulation] tests. This is a contract-only example.

**Note**: this README is specific to Windows and this example. For development on OS X or Linux, please see [README.md](README.md).

  [Fungible Token]: https://nomicon.io/Standards/Tokens/FungibleTokenCore.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

Prerequisites
=============

If you're using Gitpod, you can skip this step.

1. Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs#pre-requisites)
2. Ensure `near-cli` is installed by running `near --version`. If not installed, install with: `npm install --global near-cli`

## Building

To build run in CMD:
```bash
build.bat
```

Using this contract
===================

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions on [NEAR Wallet](https://wallet.near.org/).

Switch to `mainnet`. You can skip this step to use `testnet` as a default network.

    set NEAR_ENV=mainnet

In the project root, log in to your newly created account  with `near-cli` by following the instructions after this command:

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name you just logged in with, including the `.near`:

    set ID=MY_ACCOUNT_NAME

You can tell if the environment variable is set correctly if your command line prints the account name after this command:

    echo %ID%

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/fungible_token.wasm --accountId %ID%

FT contract should be initialized before usage. You can read more about metadata at ['nomicon.io'](https://nomicon.io/Standards/FungibleToken/Metadata.html#reference-level-explanation). Modify the parameters and create a token:

    near call %ID% new "{\"owner_id\": \""%ID%"\", \"total_supply\": \"1000000000000000\", \"metadata\": { \"spec\": \"ft-1.0.0\", \"name\": \"Example Token Name\", \"symbol\": \"EXLT\", \"decimals\": 8 }}" --accountId %ID%

Get metadata:

    near view %ID% ft_metadata

Transfer Example
---------------

Let's set up an account to transfer some tokens to. These account will be a sub-account of the NEAR account you logged in with.

    near create-account bob.%ID% --masterAccount %ID% --initialBalance 1

Add storage deposit for Bob's account:

    near call %ID% storage_deposit '' --accountId bob.%ID% --amount 0.00125

Check balance of Bob's account, it should be `0` for now:

    near view %ID% ft_balance_of "{\"account_id\": \""bob.%ID%"\"}"

Transfer tokens to Bob from the contract that minted these fungible tokens, exactly 1 yoctoNEAR of deposit should be attached:

    near call %ID% ft_transfer "{\"receiver_id\": \""bob.%ID%"\", \"amount\": \"19\"}" --accountId %ID% --amount 0.000000000000000000000001

Check the balance of Bob again with the command from before and it will now return `19`.

## Testing

As with many Rust libraries and contracts, there are tests in the main fungible token implementation at `ft/src/lib.rs`.

Additionally, this project has [simulation] tests in `tests/sim`. Simulation tests allow testing cross-contract calls, which is crucial to ensuring that the `ft_transfer_call` function works properly. These simulation tests are the reason this project has the file structure it does. Note that the root project has a `Cargo.toml` which sets it up as a workspace. `ft` and `test-contract-defi` are both small & focused contract projects, the latter only existing for simulation tests. The root project imports `near-sdk-sim` and tests interaction between these contracts.

You can run all these tests with one command:

```bash
cargo test
```

If you want to run only simulation tests, you can use `cargo test simulate`, since all the simulation tests include "simulate" in their names.

## Notes

 - The maximum balance value is limited by U128 (`2**128 - 1`).
 - JSON calls should pass U128 as a base-10 string. E.g. "100".
 - This does not include escrow functionality, as `ft_transfer_call` provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

## No AssemblyScript?

[near-contract-standards] is currently Rust-only. We strongly suggest using this library to create your own Fungible Token contract to ensure it works as expected.

Someday NEAR core or community contributors may provide a similar library for AssemblyScript, at which point this example will be updated to include both a Rust and AssemblyScript version.

## Contributing

When making changes to the files in `ft` or `test-contract-defi`, remember to use `./build.sh` to compile all contracts and copy the output to the `res` folder. If you forget this, **the simulation tests will not use the latest versions**.

'''
'''--- README.md ---
Fungible Token (FT)
===================

Example implementation of a [Fungible Token] contract which uses [near-contract-standards] and [simulation] tests. This is a contract-only example.

  [Fungible Token]: https://nomicon.io/Standards/FungibleToken/Core.html
  [near-contract-standards]: https://github.com/near/near-sdk-rs/tree/master/near-contract-standards
  [simulation]: https://github.com/near/near-sdk-rs/tree/master/near-sdk-sim

Prerequisites
=============

If you're using Gitpod, you can skip this step.

1. Make sure Rust is installed per the prerequisites in [`near-sdk-rs`](https://github.com/near/near-sdk-rs#pre-requisites)
2. Ensure `near-cli` is installed by running `near --version`. If not installed, install with: `npm install -g near-cli`

## Building

To build run:
```bash
./build.sh
```

Using this contract
===================

### Quickest deploy

You can build and deploy this smart contract to a development account. [Dev Accounts](https://docs.near.org/docs/concepts/account#dev-accounts) are auto-generated accounts to assist in developing and testing smart contracts. Please see the [Standard deploy](#standard-deploy) section for creating a more personalized account to deploy to.

```bash
near dev-deploy --wasmFile res/fungible_token.wasm --helperUrl https://near-contract-helper.onrender.com
```

Behind the scenes, this is creating an account and deploying a contract to it. On the console, notice a message like:

>Done deploying to dev-1234567890123

In this instance, the account is `dev-1234567890123`. A file has been created containing a key pair to
the account, located at `neardev/dev-account`. To make the next few steps easier, we're going to set an
environment variable containing this development account id and use that when copy/pasting commands.
Run this command to the environment variable:

```bash
source neardev/dev-account.env
```

You can tell if the environment variable is set correctly if your command line prints the account name after this command:
```bash
echo $CONTRACT_NAME
```

The next command will initialize the contract using the `new` method:

```bash
near call $CONTRACT_NAME new '{"owner_id": "'$CONTRACT_NAME'", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Example Token Name", "symbol": "EXLT", "decimals": 8 }}' --accountId $CONTRACT_NAME
```

To get the fungible token metadata:

```bash
near view $CONTRACT_NAME ft_metadata
```

### Standard deploy

This smart contract will get deployed to your NEAR account. For this example, please create a new NEAR account. Because NEAR allows the ability to upgrade contracts on the same account, initialization functions must be cleared. If you'd like to run this example on a NEAR account that has had prior contracts deployed, please use the `near-cli` command `near delete`, and then recreate it in Wallet. To create (or recreate) an account, please follow the directions on [NEAR Wallet](https://wallet.near.org/).

Switch to `mainnet`. You can skip this step to use `testnet` as a default network.

    export NEAR_ENV=mainnet

In the project root, log in to your newly created account  with `near-cli` by following the instructions after this command:

    near login

To make this tutorial easier to copy/paste, we're going to set an environment variable for your account id. In the below command, replace `MY_ACCOUNT_NAME` with the account name you just logged in with, including the `.near`:

    ID=MY_ACCOUNT_NAME

You can tell if the environment variable is set correctly if your command line prints the account name after this command:

    echo $ID

Now we can deploy the compiled contract in this example to your account:

    near deploy --wasmFile res/fungible_token.wasm --accountId $ID

FT contract should be initialized before usage. You can read more about metadata at ['nomicon.io'](https://nomicon.io/Standards/FungibleToken/Metadata.html#reference-level-explanation). Modify the parameters and create a token:

    near call $ID new '{"owner_id": "'$ID'", "total_supply": "1000000000000000", "metadata": { "spec": "ft-1.0.0", "name": "Example Token Name", "symbol": "EXLT", "decimals": 8 }}' --accountId $ID

Get metadata:

    near view $ID ft_metadata

Transfer Example
---------------

Let's set up an account to transfer some tokens to. These account will be a sub-account of the NEAR account you logged in with.

    near create-account bob.$ID --masterAccount $ID --initialBalance 1

Add storage deposit for Bob's account:

    near call $ID storage_deposit '' --accountId bob.$ID --amount 0.00125

Check balance of Bob's account, it should be `0` for now:

    near view $ID ft_balance_of '{"account_id": "'bob.$ID'"}'

Transfer tokens to Bob from the contract that minted these fungible tokens, exactly 1 yoctoNEAR of deposit should be attached:

    near call $ID ft_transfer '{"receiver_id": "'bob.$ID'", "amount": "19"}' --accountId $ID --amount 0.000000000000000000000001

Check the balance of Bob again with the command from before and it will now return `19`.

## Testing

As with many Rust libraries and contracts, there are tests in the main fungible token implementation at `ft/src/lib.rs`.

Additionally, this project has [simulation] tests in `tests/sim`. Simulation tests allow testing cross-contract calls, which is crucial to ensuring that the `ft_transfer_call` function works properly. These simulation tests are the reason this project has the file structure it does. Note that the root project has a `Cargo.toml` which sets it up as a workspace. `ft` and `test-contract-defi` are both small & focused contract projects, the latter only existing for simulation tests. The root project imports `near-sdk-sim` and tests interaction between these contracts.

You can run all these tests with one command:

```bash
cargo test
```

If you want to run only simulation tests, you can use `cargo test simulate`, since all the simulation tests include "simulate" in their names.

## Notes

 - The maximum balance value is limited by U128 (`2**128 - 1`).
 - JSON calls should pass U128 as a base-10 string. E.g. "100".
 - This does not include escrow functionality, as `ft_transfer_call` provides a superior approach. An escrow system can, of course, be added as a separate contract or additional functionality within this contract.

## No AssemblyScript?

[near-contract-standards] is currently Rust-only. We strongly suggest using this library to create your own Fungible Token contract to ensure it works as expected.

Someday NEAR core or community contributors may provide a similar library for AssemblyScript, at which point this example will be updated to include both a Rust and AssemblyScript version.

## Contributing

When making changes to the files in `ft` or `test-contract-defi`, remember to use `./build.sh` to compile all contracts and copy the output to the `res` folder. If you forget this, **the simulation tests will not use the latest versions**.

Note that if the `rust-toolchain` file in this repository changes, please make sure to update the `.gitpod.Dockerfile` to explicitly specify using that as default as well.

'''
'''--- build.bat ---
@echo off

title FT build
cargo build --all --target wasm32-unknown-unknown --release
xcopy %CD%\target\wasm32-unknown-unknown\release\*.wasm %CD%\res /Y
pause
'''
'''--- build.sh ---
#!/bin/bash
set -e
cd "`dirname $0`"
cargo build --all --target wasm32-unknown-unknown --release
cp target/wasm32-unknown-unknown/release/*.wasm ./res/

'''
'''--- dummy/Cargo.toml ---
[package]
name = "dummy"
version = "1.0.0"
authors = ["Lev Stambler"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-account = { path = "../near-account" }
near-internal-balances-plugin = { path = "../near-internal-balances-plugin" }
near-contract-standards = "3.1.0"

'''
'''--- dummy/src/lib.rs ---
use near_account::{AccountDeposits, Accounts, NearAccounts, NewInfo};
use near_internal_balances_plugin::impl_near_balance_plugin;

use near_contract_standards::storage_management::StorageManagement;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::{LazyOption, UnorderedMap};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{
    assert_one_yocto, env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue,
};

near_sdk::setup_alloc!();

#[derive(BorshDeserialize, BorshSerialize)]
pub struct AccountInfo {
    pub message: String,
    pub internal_balance: UnorderedMap<AccountId, Balance>,
}

impl NewInfo for AccountInfo {
    fn default_from_account_id(account_id: AccountId) -> Self {
        Self {
            message: "".to_string(),
            internal_balance: UnorderedMap::new(format!("{}-bal", account_id).as_bytes()),
        }
    }
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault, NearAccounts)]
pub struct Contract {
    pub accounts: Accounts<AccountInfo>,
}

impl_near_balance_plugin!(Contract, accounts, AccountInfo, internal_balance);

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new() -> Self {
        Contract { accounts: Accounts::new() }
    }

    #[payable]
    pub fn write_message(&mut self, set_own_message: String) {
        assert_one_yocto();
        let caller = env::predecessor_account_id();
        let account = &mut self.accounts.get_account_checked(&caller);
        account.info.message = set_own_message;
        self.accounts.insert_account_check_storage(&caller, account);
    }

    pub fn get_message(&self, account_id: ValidAccountId) -> String {
        let account = self.accounts.get_account(&account_id.into());
        account.map(|a| a.info.message).unwrap_or("".to_string())
    }
}

'''
'''--- ft/Cargo.toml ---
[package]
name = "ft"
version = "1.0.0"
authors = ["Near Inc <hello@nearprotocol.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.1"

'''
'''--- ft/src/lib.rs ---
/*!
Fungible Token implementation with JSON serialization.
NOTES:
  - The maximum balance value is limited by U128 (2**128 - 1).
  - JSON calls should pass U128 as a base-10 string. E.g. "100".
  - The contract optimizes the inner trie structure by hashing account IDs. It will prevent some
    abuse of deep tries. Shouldn't be an issue, once NEAR clients implement full hashing of keys.
  - The contract tracks the change in storage before and after the call. If the storage increases,
    the contract requires the caller of the contract to attach enough deposit to the function call
    to cover the storage cost.
    This is done to prevent a denial of service attack on the contract by taking all available storage.
    If the storage decreases, the contract will issue a refund for the cost of the released storage.
    The unused tokens from the attached deposit are also refunded, so it's safe to
    attach more deposit than required.
  - To prevent the deployed contract from being modified or deleted, it should not have any access
    keys on its account.
*/
use near_contract_standards::fungible_token::metadata::{
    FungibleTokenMetadata, FungibleTokenMetadataProvider, FT_METADATA_SPEC,
};
use near_contract_standards::fungible_token::FungibleToken;
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::collections::LazyOption;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::{env, log, near_bindgen, AccountId, Balance, PanicOnDefault, PromiseOrValue};

near_sdk::setup_alloc!();

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    token: FungibleToken,
    metadata: LazyOption<FungibleTokenMetadata>,
}

const DATA_IMAGE_SVG_NEAR_ICON: &str = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 288 288'%3E%3Cg id='l' data-name='l'%3E%3Cpath d='M187.58,79.81l-30.1,44.69a3.2,3.2,0,0,0,4.75,4.2L191.86,103a1.2,1.2,0,0,1,2,.91v80.46a1.2,1.2,0,0,1-2.12.77L102.18,77.93A15.35,15.35,0,0,0,90.47,72.5H87.34A15.34,15.34,0,0,0,72,87.84V201.16A15.34,15.34,0,0,0,87.34,216.5h0a15.35,15.35,0,0,0,13.08-7.31l30.1-44.69a3.2,3.2,0,0,0-4.75-4.2L96.14,186a1.2,1.2,0,0,1-2-.91V104.61a1.2,1.2,0,0,1,2.12-.77l89.55,107.23a15.35,15.35,0,0,0,11.71,5.43h3.13A15.34,15.34,0,0,0,216,201.16V87.84A15.34,15.34,0,0,0,200.66,72.5h0A15.35,15.35,0,0,0,187.58,79.81Z'/%3E%3C/g%3E%3C/svg%3E";

#[near_bindgen]
impl Contract {
    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// default metadata (for example purposes only).
    #[init]
    pub fn new_default_meta(owner_id: ValidAccountId, total_supply: U128) -> Self {
        Self::new(
            owner_id,
            total_supply,
            FungibleTokenMetadata {
                spec: FT_METADATA_SPEC.to_string(),
                name: "LEV's funtime Fungible Token".to_string(),
                symbol: "LEV".to_string(),
                icon: Some(DATA_IMAGE_SVG_NEAR_ICON.to_string()),
                reference: None,
                reference_hash: None,
                decimals: 8,
            },
        )
    }

    /// Initializes the contract with the given total supply owned by the given `owner_id` with
    /// the given fungible token metadata.
    #[init]
    pub fn new(
        owner_id: ValidAccountId,
        total_supply: U128,
        metadata: FungibleTokenMetadata,
    ) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        metadata.assert_valid();
        let mut this = Self {
            token: FungibleToken::new(b"a".to_vec()),
            metadata: LazyOption::new(b"m".to_vec(), Some(&metadata)),
        };
        this.token.internal_register_account(owner_id.as_ref());
        this.token.internal_deposit(owner_id.as_ref(), total_supply.into());
        this
    }

    fn on_account_closed(&mut self, account_id: AccountId, balance: Balance) {
        log!("Closed @{} with {}", account_id, balance);
    }

    fn on_tokens_burned(&mut self, account_id: AccountId, amount: Balance) {
        log!("Account @{} burned {}", account_id, amount);
    }
}

near_contract_standards::impl_fungible_token_core!(Contract, token, on_tokens_burned);
near_contract_standards::impl_fungible_token_storage!(Contract, token, on_account_closed);

#[near_bindgen]
impl FungibleTokenMetadataProvider for Contract {
    fn ft_metadata(&self) -> FungibleTokenMetadata {
        self.metadata.get().unwrap()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, Balance};

    use super::*;

    const TOTAL_SUPPLY: Balance = 1_000_000_000_000_000;

    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id);
        builder
    }

    #[test]
    fn test_new() {
        let mut context = get_context(accounts(1));
        testing_env!(context.build());
        let contract = Contract::new_default_meta(accounts(1).into(), TOTAL_SUPPLY.into());
        testing_env!(context.is_view(true).build());
        assert_eq!(contract.ft_total_supply().0, TOTAL_SUPPLY);
        assert_eq!(contract.ft_balance_of(accounts(1)).0, TOTAL_SUPPLY);
    }

    #[test]
    #[should_panic(expected = "The contract is not initialized")]
    fn test_default() {
        let context = get_context(accounts(1));
        testing_env!(context.build());
        let _contract = Contract::default();
    }

    #[test]
    fn test_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let mut contract = Contract::new_default_meta(accounts(2).into(), TOTAL_SUPPLY.into());
        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(contract.storage_balance_bounds().min.into())
            .predecessor_account_id(accounts(1))
            .build());
        // Paying for account registration, aka storage deposit
        contract.storage_deposit(None, None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .attached_deposit(1)
            .predecessor_account_id(accounts(2))
            .build());
        let transfer_amount = TOTAL_SUPPLY / 3;
        contract.ft_transfer(accounts(1), transfer_amount.into(), None);

        testing_env!(context
            .storage_usage(env::storage_usage())
            .account_balance(env::account_balance())
            .is_view(true)
            .attached_deposit(0)
            .build());
        assert_eq!(contract.ft_balance_of(accounts(2)).0, (TOTAL_SUPPLY - transfer_amount));
        assert_eq!(contract.ft_balance_of(accounts(1)).0, transfer_amount);
    }
}

'''
'''--- near-account/Cargo.toml ---
[package]
name = "near-account"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-account-internal = {path = "./near-account-internal"}
near-account-mac = {path = "./near-account-mac"}

[lib]
crate-type = ["cdylib", "rlib"]

'''
'''--- near-account/near-account-internal/Cargo.toml ---
[package]
name = "near-account-internal"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-contract-standards = "3.1.0"
near-sdk = "3.1.0"

[lib]
crate-type = ["cdylib", "rlib"]

'''
'''--- near-account/near-account-internal/src/account.rs ---
use near_contract_standards::storage_management::StorageBalance;
use near_sdk::{
    borsh::{self, BorshDeserialize, BorshSerialize},
    env,
    json_types::U128,
    AccountId, Balance, Promise, StorageUsage,
};

use crate::{Accounts, NewInfo};

pub trait AccountInfoTrait: BorshSerialize + BorshDeserialize + NewInfo {}

/// Account information and storage cost.
#[derive(BorshSerialize, BorshDeserialize, Default, Debug)]
pub struct Account<Info: AccountInfoTrait> {
    /// Native NEAR amount sent to the contract
    pub near_amount: Balance,
    pub near_used_for_storage: Balance,
    pub info: Info,
}

impl<Info: AccountInfoTrait> NewInfo for Account<Info> {
    fn default_from_account_id(account_id: AccountId) -> Self {
        Self {
            near_amount: 0,
            near_used_for_storage: 0,
            info: Info::default_from_account_id(account_id),
        }
    }
}

pub trait AccountDeposits<Info: AccountInfoTrait> {
    /// Check that storage is paid for and call the closure function
    fn check_storage<F, T: Sized>(&mut self, accounts: &mut Accounts<Info>, closure: F) -> T
    where
        F: FnOnce(&mut Accounts<Info>, &mut Self) -> T;

    fn get_available_near(&self) -> Balance;

    fn storage_balance(&self) -> StorageBalance;

    fn near_deposit(&mut self) -> StorageBalance;

    fn near_balance(&self) -> Option<StorageBalance>;

    fn near_withdraw(&mut self, account_id: AccountId, amount: Option<u128>) -> StorageBalance;
}

impl<Info: AccountInfoTrait> AccountDeposits<Info> for Account<Info> {
    fn check_storage<F, T: Sized>(&mut self, accounts: &mut Accounts<Info>, closure: F) -> T
    where
        F: FnOnce(&mut Accounts<Info>, &mut Self) -> T,
    {
        let storage_start = env::storage_usage();

        let ret = closure(accounts, self);

        let storage_end = env::storage_usage();

        if storage_end == storage_start {
            ret
        } else if storage_end > storage_start {
            let storage_cost = (storage_end - storage_start) as u128 * env::storage_byte_cost();
            let free_near = self.get_available_near();
            if free_near < storage_cost {
                panic!("Not enough Near to cover the transaction");
            }
            self.near_used_for_storage += storage_cost;
            ret
        } else {
            let storage_refund = (storage_start - storage_end) as u128 * env::storage_byte_cost();
            self.near_used_for_storage =
                self.near_used_for_storage.checked_sub(storage_refund).unwrap_or(0);
            ret
        }
    }

    fn storage_balance(&self) -> StorageBalance {
        StorageBalance {
            total: U128::from(self.near_amount),
            available: U128::from(self.get_available_near()),
        }
    }

    fn get_available_near(&self) -> Balance {
        let free_near = self.near_amount - self.near_used_for_storage;
        free_near
    }

    fn near_deposit(&mut self) -> StorageBalance {
        let amount = env::attached_deposit();
        self.near_amount += amount;
        self.near_balance().unwrap()
    }

    fn near_withdraw(&mut self, receiver_id: AccountId, amount: Option<u128>) -> StorageBalance {
        let free = self.get_available_near();
        let withdraw_amount = if amount.is_some() {
            let amount = amount.unwrap();
            if free < amount {
                panic!("Cannot withdraw more than {} near", free);
            }
            amount
        } else {
            free
        };
        self.near_amount -= withdraw_amount;
        Promise::new(receiver_id).transfer(withdraw_amount);
        self.near_balance().unwrap()
    }

    fn near_balance(&self) -> Option<StorageBalance> {
        Some(StorageBalance {
            total: U128::from(self.near_used_for_storage),
            available: U128::from(self.get_available_near()),
        })
    }
}

'''
'''--- near-account/near-account-internal/src/lib.rs ---
use near_contract_standards::storage_management::{
    StorageBalance, StorageBalanceBounds, StorageManagement,
};
use near_sdk::{
    assert_one_yocto,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::UnorderedMap,
    env::{self},
    json_types::{ValidAccountId, U128},
    log, AccountId, Balance, Promise,
};

pub use account::Account;
pub use account::{AccountDeposits, AccountInfoTrait};

mod account;

pub trait NewInfo {
    fn default_from_account_id(account_id: AccountId) -> Self;
}

/// Account information and storage cost.
#[derive(BorshSerialize, BorshDeserialize)]
pub struct Accounts<AccountInfoUsed: AccountInfoTrait> {
    pub accounts: UnorderedMap<AccountId, Account<AccountInfoUsed>>,
    pub default_min_storage_bal: u128,
}

impl<Info: AccountInfoTrait> Accounts<Info> {
    /// Get an account and panic if the account is not registered
    pub fn get_account_checked(&self, account_id: &AccountId) -> Account<Info> {
        let account = self.accounts.get(account_id);
        if account.is_none() {
            panic!("Account {} is unregistered", account_id);
        }
        account.unwrap()
    }

    pub fn check_storage<F, T: Sized>(
        &mut self,
        account: &mut Account<Info>,
        account_id: &AccountId,
        closure: F,
    ) -> T
    where
        F: FnOnce(&mut Accounts<Info>, &mut Account<Info>) -> T,
    {
        let ret = account.check_storage(self, closure);
        self.accounts.insert(&account_id, &account);
        ret
    }

    pub fn remove_account_unchecked(
        &mut self,
        account_id: &AccountId,
    ) -> Option<Account<Info>> {
        self.accounts.remove(account_id)
    }

    pub fn insert_account_unchecked(
        &mut self,
        account_id: &AccountId,
        account: &Account<Info>,
    ) -> Option<Account<Info>> {
        self.accounts.insert(account_id, account)
    }

    pub fn insert_account_check_storage(
        &mut self,
        account_id: &AccountId,
        account: &mut Account<Info>,
    ) -> Option<Account<Info>> {
        self.check_storage(account, account_id, |accounts, account| {
            accounts.accounts.insert(account_id, account)
        })
    }

    pub fn get_account(&self, account_id: &AccountId) -> Option<Account<Info>> {
        self.accounts.get(account_id)
    }
}

impl<Info: AccountInfoTrait> Accounts<Info> {
    pub fn new() -> Self {
        let mut ret = Accounts::<Info> {
            accounts: UnorderedMap::new(b"accounts-map".to_vec()),
            default_min_storage_bal: 0,
        };
        ret.default_min_storage_bal = ret.get_storage_cost(None, true);
        ret
    }
}

impl<Info: AccountInfoTrait> Accounts<Info> {
    /// Get the cost of storage
    /// * `unregister` - if set to false then the get_storage_cost will also register the default account with the account id
    pub(crate) fn get_storage_cost(
        &mut self,
        account_id: Option<AccountId>,
        unregister: bool,
    ) -> u128 {
        let storage_prior = env::storage_usage();
        let account_id = account_id.unwrap_or("a".repeat(64));
        let default_account = Account::default_from_account_id(account_id.clone());
        self.accounts.insert(&account_id, &default_account);

        // Get the storage cost
        let storage_cost =
            (env::storage_usage() - storage_prior) as u128 * env::storage_byte_cost();
        if unregister {
            self.accounts.remove(&account_id);
        }
        storage_cost
    }
}

/// storage handlers
impl<Info: AccountInfoTrait> StorageManagement for Accounts<Info> {
    fn storage_unregister(&mut self, force: Option<bool>) -> bool {
        if force.unwrap_or(false) == false {
            log!("Can only unregister if force is true");
            false
        } else {
            // TODO: make macro for this (sep lib)
            assert_eq!(env::attached_deposit(), 1, "Expected 1 Near");
            let account_id = env::predecessor_account_id();
            let lookup = self.accounts.remove(&account_id);
            if lookup.is_none() {
                panic!("Cannot unregister a non-existant account");
            } else {
                log!("Deleting account {}", account_id);
                let account = lookup.unwrap();
                Promise::new(env::predecessor_account_id()).transfer(account.near_amount);
            }
            true
        }
    }

    fn storage_withdraw(&mut self, amount: Option<U128>) -> StorageBalance {
        assert_one_yocto();
        let predecessor_account_id = env::predecessor_account_id();
        if let Some(mut account) = self.accounts.get(&predecessor_account_id) {
            let amount = match amount {
                Some(amount) => {
                    if amount.0 > account.get_available_near() {
                        panic!("The amount is greater than the available storage balance");
                    } else {
                        amount.0
                    }
                }
                _ => account.get_available_near(),
            };

            account.near_amount -= amount;
            self.accounts.insert(&predecessor_account_id, &account);
            Promise::new(env::predecessor_account_id()).transfer(amount);
            account.storage_balance()
        } else {
            env::panic(
                format!("The account {} is not registered", &predecessor_account_id).as_bytes(),
            );
        }
    }

    fn storage_balance_bounds(&self) -> StorageBalanceBounds {
        StorageBalanceBounds {
            min: self.default_min_storage_bal.into(),
            max: None,
        }
    }

    fn storage_balance_of(&self, account_id: ValidAccountId) -> Option<StorageBalance> {
        if let Some(account) = self.accounts.get(&account_id.into()) {
            Some(account.storage_balance())
        } else {
            None
        }
    }

    fn storage_deposit(
        &mut self,
        account_id: Option<ValidAccountId>,
        registration_only: Option<bool>,
    ) -> near_contract_standards::storage_management::StorageBalance {
        let registration_only = registration_only.unwrap_or(false);
        let account_id: AccountId = account_id
            .map(|a| a.into())
            .unwrap_or(env::predecessor_account_id());
        let amount_attached = env::attached_deposit();
        let registered = self.accounts.get(&account_id);

        if registered.is_some() && registration_only {
            log!("Account already registered");
            Promise::new(env::predecessor_account_id()).transfer(amount_attached);
            let account = registered.unwrap();
            account.storage_balance()
        } else if registered.is_some() {
            let mut account = registered.unwrap();
            account.near_amount += amount_attached;
            self.accounts.insert(&account_id, &account);
            account.storage_balance()
        } else {
            // NOTE: get_storage also registers the account id here
            let storage_cost = self.get_storage_cost(Some(account_id.clone()), false);
            let min_storage_cost = self.storage_balance_bounds().min.0;
            if amount_attached < storage_cost || amount_attached < min_storage_cost {
                self.accounts.remove(&account_id);
                Promise::new(env::predecessor_account_id()).transfer(amount_attached);
                StorageBalance {
                    available: 0.into(),
                    total: 0.into(),
                }
            } else if registration_only {
                let amount_refund = storage_cost - amount_attached;
                let mut account = self.accounts.get(&account_id).unwrap();
                account.near_amount = storage_cost;
                account.near_used_for_storage = storage_cost;
                self.accounts.insert(&account_id, &account);

                if amount_refund != 0 {
                    Promise::new(env::predecessor_account_id()).transfer(amount_refund);
                }
                account.storage_balance()
            } else {
                let mut account = self.accounts.get(&account_id).unwrap();
                account.near_amount = amount_attached;
                account.near_used_for_storage = storage_cost;
                self.accounts.insert(&account_id, &account);

                account.storage_balance()
            }
        }
    }
}

'''
'''--- near-account/near-account-mac/Cargo.toml ---
[package]
name = "near-account-mac"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-sdk = "3.1.0"
quote = "^1.0"
syn = "^1"

[lib]
proc-macro = true
'''
'''--- near-account/near-account-mac/src/lib.rs ---
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, ItemStruct};

#[proc_macro_derive(NearAccounts)]
pub fn near_accounts(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let input_struct = input.clone();

    let struct_: syn::DataStruct = match input.data {
        syn::Data::Struct(data) => data,
        _ => panic!("Usage of #[Derive(NearAccounts)] on a non-struct type"),
    };

    let (impl_generics, ty_generics, where_clause) = input_struct.generics.split_for_impl();
    let struct_name = &input_struct.ident;

    let stream = quote! {

        #[near_sdk::near_bindgen]
        impl #struct_name #ty_generics #where_clause {

            #[payable]
            pub fn accounts_storage_deposit(
                &mut self,
                account_id: Option<near_sdk::json_types::ValidAccountId>,
                registration_only: Option<bool>,
            ) -> near_contract_standards::storage_management::StorageBalance {
                self.accounts.storage_deposit(account_id, registration_only)
            }

            #[payable]
            pub fn accounts_storage_withdraw(&mut self, amount: Option<near_sdk::json_types::U128>) -> near_contract_standards::storage_management::StorageBalance {
                self.accounts.storage_withdraw(amount)
            }

            #[payable]
            pub fn accounts_storage_unregister(&mut self, force: Option<bool>) -> bool {
                self.accounts.storage_unregister(force)
            }

            pub fn accounts_storage_balance_bounds(&self) -> near_contract_standards::storage_management::StorageBalanceBounds {
                self.accounts.storage_balance_bounds()
            }

            pub fn accounts_storage_balance_of(&self, account_id: near_sdk::json_types::ValidAccountId) -> Option<near_contract_standards::storage_management::StorageBalance> {
                self.accounts.storage_balance_of(account_id)
            }
        }
    };
    TokenStream::from(stream)
}

'''
'''--- near-account/src/lib.rs ---
pub use near_account_internal::*;
pub use near_account_mac::*;

'''
'''--- near-internal-balances-plugin/Cargo.toml ---
[package]
name = "near-internal-balances-plugin"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-internal-balances-plugin-internal = {path = "./near-internal-balances-plugin-internal"}

[lib]
crate-type = ["cdylib", "rlib"]

'''
'''--- near-internal-balances-plugin/near-internal-balances-plugin-internal/Cargo.toml ---
[package]
name = "near-internal-balances-plugin-internal"
version = "0.1.0"
edition = "2018"

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
near-contract-standards = "3.1.0"
near-sdk = "3.1.0"
near-account = { path = "../../near-account" }

[lib]
crate-type = ["cdylib", "rlib"]

'''
'''--- near-internal-balances-plugin/near-internal-balances-plugin-internal/src/core_impl.rs ---
use near_account::{Account, AccountInfoTrait as DefaultAccountInfo, Accounts, NewInfo};
use near_sdk::{
    assert_one_yocto,
    borsh::{BorshDeserialize, BorshSerialize},
    env,
    json_types::U128,
    log,
    serde_json::{self, json},
    AccountId, Balance, Gas,
};

use crate::{BalanceInfo, OnTransferOpts};

pub trait AccountInfoTrait: DefaultAccountInfo + BalanceInfo {}

const RESOLVE_FT_NAME: &str = "resolve_internal_ft_transfer_call";
const FT_TRANSFER_CALL_METHOD_NAME: &str = "ft_transfer_call";
const FT_TRANSFER_METHOD_NAME: &str = "ft_transfer";

const GAS_BUFFER: Gas = 5_000_000_000_000;
const GAS_FOR_INTERNAL_RESOLVE: Gas = 5_000_000_000_000;
const GAS_FOR_ON_TRANSFER_NEP141: Gas = 5_000_000_000_000;
const GAS_FOR_FT_RESOLVE_TRANSFER_NEP141: Gas = 5_000_000_000_000;
const GAS_FOR_FT_TRANSFER_CALL_NEP141: Gas = GAS_FOR_FT_RESOLVE_TRANSFER_NEP141
    + GAS_FOR_ON_TRANSFER_NEP141
    + 25_000_000_000_000
    + GAS_BUFFER;

pub fn ft_on_transfer<Info: AccountInfoTrait>(
    accounts: &mut Accounts<Info>,
    sender_id: AccountId,
    amount: String,
    msg: String,
) -> String {
    let opts: OnTransferOpts = if (&msg).len() == 0 {
        OnTransferOpts {
            sender_id: sender_id.clone().into(),
        }
    } else {
        serde_json::from_str(&msg)
            .unwrap_or_else(|e| panic!("Failed to deserialize transfer opts: {}", e))
    };
    let token_id = env::predecessor_account_id();
    let amount = amount.parse::<u128>().unwrap();
    increase_balance(accounts, &opts.sender_id, &token_id, amount);

    "0".to_string()
}

pub fn get_ft_balance<Info: AccountInfoTrait>(account: &Account<Info>, token_id: &AccountId) -> u128 {
    account.info.get_balance(token_id)
}

/// Get the cost of adding 1 balance to a user's account
pub fn get_storage_cost_for_one_balance<Info: AccountInfoTrait>(
    accounts: &mut Accounts<Info>,
) -> Balance {
    let account_id = "a".repeat(64);
    let token_id = "b".repeat(64);
    accounts.insert_account_unchecked(
        &account_id,
        &Account::default_from_account_id(account_id.clone()),
    );

    let storage_usage_init_with_account = env::storage_usage();

    let mut account = accounts.get_account(&account_id).unwrap();
    account.info.set_balance(&token_id, 0);
    accounts.insert_account_unchecked(&account_id, &account);

    let storage_usage = env::storage_usage();

    // Remove the inserted account
    accounts.remove_account_unchecked(&account_id);

    return (storage_usage - storage_usage_init_with_account) as u128 * env::storage_byte_cost();
}

pub fn balance_transfer<Info: AccountInfoTrait>(
    accounts: &mut Accounts<Info>,
    recipient: &AccountId,
    token_id: &AccountId,
    amount: u128,
    msg: Option<String>,
) {
    assert_one_yocto();
    let caller = env::predecessor_account_id();
    if let Some(msg) = msg {
        log!("Balance transfer message: {}", msg);
    }
    subtract_balance(accounts, &caller, token_id, amount);
    increase_balance(accounts, &recipient, token_id, amount);
}

pub fn withdraw_to<Info: AccountInfoTrait>(
    accounts: &mut Accounts<Info>,
    amount: u128,
    token_id: AccountId,
    recipient: Option<AccountId>,
    msg: Option<String>,
) {
    assert_one_yocto();
    let caller = env::predecessor_account_id();

    // TODO: in sep function
    assert_eq!(
        env::attached_deposit(),
        1,
        "Expected an attached deposit of 1"
    );

    let recipient = recipient.unwrap_or(caller.clone());

    let prom = internal_ft_transfer(accounts, &caller, &token_id, recipient, amount, msg, None);
    env::promise_return(prom);
}

fn internal_ft_transfer<Info: AccountInfoTrait>(
    accounts: &mut Accounts<Info>,
    sender: &AccountId,
    token_id: &AccountId,
    recipient: AccountId,
    amount: u128,
    msg: Option<String>,
    prior_promise: Option<u64>,
) -> u64 {
    let data = get_transfer_data(recipient, U128::from(amount), sender.clone(), msg);

    // TODO: update
    subtract_balance(accounts, sender, token_id, amount);

    let ft_transfer_prom = match prior_promise {
        None => {
            let prom = env::promise_batch_create(token_id);
            env::promise_batch_action_function_call(
                prom,
                FT_TRANSFER_METHOD_NAME.as_bytes(),
                &data,
                1,
                GAS_FOR_FT_TRANSFER_CALL_NEP141,
            );
            prom
        }
        Some(prior_prom) => env::promise_then(
            prior_prom,
            token_id.to_string(),
            FT_TRANSFER_METHOD_NAME.as_bytes(),
            &data,
            1,
            GAS_FOR_FT_TRANSFER_CALL_NEP141,
        ),
    };
    let internal_resolve_args =
        get_internal_resolve_data(&sender, token_id, U128::from(amount), false).unwrap();
    env::promise_then(
        ft_transfer_prom,
        env::current_account_id(),
        RESOLVE_FT_NAME.as_bytes(),
        internal_resolve_args.to_string().as_bytes(),
        0,
        GAS_FOR_INTERNAL_RESOLVE,
    )
}

// TODO: integrate
fn internal_ft_transfer_call<Info: AccountInfoTrait>(
    accounts: &mut Accounts<Info>,
    token_id: &AccountId,
    recipient: AccountId,
    amount: U128,
    sender: AccountId,
    prior_promise: Option<u64>,
) -> u64 {
    _internal_ft_transfer_call(
        accounts,
        token_id,
        recipient,
        amount,
        sender,
        prior_promise,
        None,
        1,
    )
}

/// Do an internal transfer and subtract the internal balance for {@param sender}
///
/// If there is a custom message, use that for the ft transfer. If not, use the default On Transfer Message
fn _internal_ft_transfer_call<Info: AccountInfoTrait>(
    accounts: &mut Accounts<Info>,
    token_id: &AccountId,
    recipient: AccountId,
    amount: U128,
    sender: AccountId,
    prior_promise: Option<u64>,
    custom_message: Option<String>,
    amount_near: Balance,
) -> u64 {
    let data = get_transfer_call_data(recipient, amount.clone(), sender.clone(), custom_message);

    let amount_parsed = amount.0;

    subtract_balance(accounts, &sender, token_id, amount_parsed);

    let ft_transfer_prom = match prior_promise {
        None => {
            let prom_batch = env::promise_batch_create(token_id);
            env::promise_batch_action_function_call(
                prom_batch,
                FT_TRANSFER_CALL_METHOD_NAME.as_bytes(),
                &data,
                amount_near,
                GAS_FOR_FT_TRANSFER_CALL_NEP141,
            );
            prom_batch
        }
        Some(prior_prom) => env::promise_then(
            prior_prom,
            token_id.to_string(),
            FT_TRANSFER_CALL_METHOD_NAME.as_bytes(),
            &data,
            amount_near,
            GAS_FOR_FT_TRANSFER_CALL_NEP141,
        ),
    };
    let internal_resolve_args =
        get_internal_resolve_data(&sender, &token_id, amount, true).unwrap();
    env::promise_then(
        ft_transfer_prom,
        env::current_account_id(),
        RESOLVE_FT_NAME.as_bytes(),
        internal_resolve_args.to_string().as_bytes(),
        0,
        GAS_FOR_INTERNAL_RESOLVE,
    )
}

/// Resolve the ft transfer by updating the amount used in the balances
/// `is_ft_call` - If false, assume that an ft_transfer occurred
/// @returns the amount used
pub fn resolve_internal_ft_transfer_call<Info: AccountInfoTrait>(
    accounts: &mut Accounts<Info>,
    account_id: &AccountId,
    token_id: AccountId,
    amount: U128,
    is_ft_call: bool,
) -> U128 {
    let amount: u128 = amount.into();
    if amount == 0 {
        return U128(0);
    }

    // let account = accounts.get_account_checked(account_id);
    match near_sdk::utils::promise_result_as_success() {
        None => {
            log!("The FT transfer call failed, redepositing funds");
            increase_balance(accounts, account_id, &token_id, amount);
            U128(0)
        }
        Some(data) => {
            let amount_used = if is_ft_call {
                let amount_used_str: String = serde_json::from_slice(data.as_slice())
                    .unwrap_or_else(|e| {
                        panic!("Failed to deserialize ft_transfer_call result {}", e)
                    });
                amount_used_str
                    .parse::<u128>()
                    .unwrap_or_else(|e| panic!("Failed to parse result with {}", e))
            } else {
                amount
            };
            // TODO: err handling?
            let amount_unused = amount - amount_used;
            log!("Amount unused {}", amount_unused);
            if amount_unused > 0 {
                increase_balance(accounts, account_id, &token_id, amount_unused);
            }
            U128(amount_used)
        }
    }
}

pub fn increase_balance<Info: AccountInfoTrait>(
    accounts: &mut Accounts<Info>,
    account_id: &AccountId,
    token_id: &AccountId,
    amount: u128,
) {
    let mut account = accounts.get_account_checked(account_id);
    let current_balance = get_ft_balance(&account, token_id);

    log!(
        "Adding {} from {} for token {} with current balance {}",
        amount,
        account_id,
        token_id,
        current_balance
    );

    let updated = current_balance + amount;
    account.info.set_balance(token_id, updated);
    accounts.insert_account_check_storage(account_id, &mut account);
}

pub fn subtract_balance<Info: AccountInfoTrait>(
    accounts: &mut Accounts<Info>,
    account_id: &AccountId,
    token_id: &AccountId,
    amount: u128,
) {
    let mut account = accounts.get_account_checked(account_id);
    let current_balance = get_ft_balance(&account, token_id);

    if current_balance < amount {
        panic!("The callee did not deposit sufficient funds. Current balance: {}, requested amount {}, token {}", current_balance, amount, token_id);
    }

    log!(
        "Subtracting {} from {} for token {} with current balance {}",
        amount,
        account_id,
        token_id,
        current_balance
    );

    let updated = current_balance - amount;
    account.info.set_balance(token_id, updated);
    accounts.insert_account_check_storage(account_id, &mut account);
}

/********** Helper functions **************/
fn get_internal_resolve_data(
    sender: &AccountId,
    token_id: &AccountId,
    amount: U128,
    is_ft_call: bool,
) -> Result<String, serde_json::error::Error> {
    let internal_resolve_args = json!({"account_id": sender, "token_id": token_id, "amount": amount, "is_ft_call": is_ft_call});
    Ok(internal_resolve_args.to_string())
}

fn get_transfer_data(
    recipient: AccountId,
    amount: U128,
    sender: AccountId,
    custom_message: Option<String>,
) -> Vec<u8> {
    if let Some(msg) = custom_message {
        json!({"receiver_id": recipient, "amount": amount, "msg": msg})
            .to_string()
            .into_bytes()
    } else {
        json!({"receiver_id": recipient, "amount": amount})
            .to_string()
            .into_bytes()
    }
}

fn get_transfer_call_data(
    recipient: String,
    amount: U128,
    sender: String,
    custom_message: Option<String>,
) -> Vec<u8> {
    if let Some(msg) = custom_message {
        json!({ "receiver_id": recipient, "amount": amount, "msg": msg})
            .to_string()
            .into_bytes()
    } else {
        let on_transfer_opts = OnTransferOpts { sender_id: sender };
        // TODO: unwrapping ok?
        json!({ "receiver_id": recipient, "amount": amount, "msg": serde_json::to_string(&on_transfer_opts).unwrap() })
					.to_string()
					.into_bytes()
    }
}

#[cfg(all(test, not(target_arch = "wasm32")))]
mod tests {
    const INIT_ACCOUNT_BAL: u128 = 10_000;

    use std::convert::TryFrom;

    use super::*;
    use near_account::NewInfo;
    use near_contract_standards::storage_management::StorageManagement;
    use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
    use near_sdk::collections::UnorderedMap;
    use near_sdk::json_types::ValidAccountId;
    use near_sdk::test_utils::{accounts, VMContextBuilder};
    use near_sdk::testing_env;
    use near_sdk::MockedBlockchain;

    #[derive(BorshSerialize, BorshDeserialize)]
    struct Info {
        pub internal_balance: UnorderedMap<AccountId, Balance>,
    }
    impl NewInfo for Info {
        fn default_from_account_id(account_id: AccountId) -> Self {
            Self {
                internal_balance: UnorderedMap::new((format!("{}-bals-i", &account_id)).as_bytes()),
            }
        }
    }

    impl BalanceInfo for Info {
        fn get_balance(&self, token_id: &AccountId) -> Balance {
            // TODO: allow for custom balance field
            self.internal_balance.get(token_id).unwrap_or(0)
        }

        fn set_balance(&mut self, token_id: &AccountId, balance: Balance) {
            self.internal_balance.insert(token_id, &balance);
        }
    }

    fn get_near_accounts(
        mut context: VMContextBuilder,
    ) -> (
        AccountId,
        AccountId,
        Accounts<Info>,
        Account<Info>,
        VMContextBuilder,
    ) {
        let mut near_accounts = Accounts::<Info>::new();
        let account: AccountId = accounts(0).into();
        let tok: AccountId = accounts(2).into();
        let min = near_accounts.storage_balance_bounds().min.0;
        testing_env!(context.attached_deposit(min * 10).build());
        near_accounts.storage_deposit(
            Some(ValidAccountId::try_from(account.clone()).unwrap()),
            None,
        );
        testing_env!(context.attached_deposit(1).build());
        let near_account = near_accounts.get_account_checked(&account);

        (account, tok, near_accounts, near_account, context)
    }

    // mock the context for testing, notice "signer_account_id" that was accessed above from env::
    fn get_context(predecessor_account_id: ValidAccountId) -> VMContextBuilder {
        let mut builder = VMContextBuilder::new();
        builder
            .current_account_id(accounts(0))
            .signer_account_id(predecessor_account_id.clone())
            .predecessor_account_id(predecessor_account_id)
            .account_balance(INIT_ACCOUNT_BAL);
        builder
    }

    // TODO: register token's with deposits...
    // TODO: should panic type

    #[test]
    #[should_panic]
    fn test_ft_not_enough_balance() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        testing_env!(context.attached_deposit(1).build());
        let (account, tok, mut near_accounts, near_account, context) = get_near_accounts(context);
        withdraw_to(&mut near_accounts, 1_000, tok, None, None);
    }

    #[test]
    fn test_ft_adding_balances_and_then_subtracting() {}

    #[test]
    fn test_ft_subtracting_balances() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let (account, tok, mut near_accounts, near_account, context) = get_near_accounts(context);

        ft_on_transfer(
            &mut near_accounts,
            account.clone(),
            1000.to_string(),
            "".to_string(),
        );
        let near_account = near_accounts.get_account_checked(&account);
        let bal = get_ft_balance(&near_account, &tok);
        assert_eq!(bal, 1_000);

        subtract_balance(&mut near_accounts, &account, &tok, 100);
        let near_account = near_accounts.get_account_checked(&account);
        let bal = get_ft_balance(&near_account, &tok);
        assert_eq!(bal, 900);

        subtract_balance(&mut near_accounts, &account, &tok, 100);
        let near_account = near_accounts.get_account_checked(&account);
        let bal = get_ft_balance(&near_account, &tok);
        assert_eq!(bal, 800);
    }

    #[test]
    fn test_on_transfer() {
        let mut context = get_context(accounts(2));
        testing_env!(context.build());
        let (account, tok, mut near_accounts, near_account, context) = get_near_accounts(context);

        let bal = get_ft_balance(&near_account, &tok);
        assert_eq!(bal, 0);

        let amount_unused = ft_on_transfer(
            &mut near_accounts,
            account.clone(),
            1000.to_string(),
            "".to_string(),
        );
        assert_eq!(amount_unused, "0");

        let near_account = near_accounts.get_account_checked(&account);
        let bal = get_ft_balance(&near_account, &tok);
        assert_eq!(bal, 1_000);

        let amount_unused = ft_on_transfer(
            &mut near_accounts,
            accounts(1).into(),
            100.to_string(),
            serde_json::to_string(&OnTransferOpts {
                sender_id: account.clone(),
            })
            .unwrap(),
        );

        assert_eq!(amount_unused, "0");
        let near_account = near_accounts.get_account_checked(&account);
        let bal = get_ft_balance(&near_account, &tok);
        assert_eq!(bal, 1_100);
    }
}

'''
'''--- near-internal-balances-plugin/near-internal-balances-plugin-internal/src/lib.rs ---
use near_account::Accounts;
use near_sdk::{
    assert_one_yocto,
    borsh::{self, BorshDeserialize, BorshSerialize},
    collections::UnorderedMap,
    env::{self},
    json_types::{ValidAccountId, U128},
    log,
    serde::{Deserialize, Serialize},
    AccountId, Balance, Promise,
};

pub mod core_impl;
mod macros;
pub use macros::*;

pub trait NearFTInternalBalance:
    SudoInternalBalanceFungibleToken + InternalBalanceFungibleTokenHandlers
{
}

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct OnTransferOpts {
    // The account to log the transfer to
    pub sender_id: AccountId,
}

pub trait BalanceInfo {
    fn get_balance(&self, token_id: &AccountId) -> Balance;
    fn set_balance(&mut self, token_id: &AccountId, balance: Balance);
}

pub trait SudoInternalBalanceFungibleToken {
    /// Do a checked subtraction of an account balance
    fn subtract_balance(&mut self, account_id: &AccountId, token_id: &AccountId, amount: Balance);
    /// Do a checked addition to an account balance
    fn increase_balance(&mut self, account_id: &AccountId, token_id: &AccountId, amount: Balance);
    /// Same as get_ft_balance but without the serializable types
    fn get_ft_balance_internal(&self, account_id: &AccountId, token_id: &AccountId) -> Balance;
    /// Get the storage cost for one balance account
    fn get_storage_cost_for_one_balance(&mut self) -> Balance;
    /// Same as balance transfer but internal types
    fn balance_transfer_internal(
        &mut self,
        recipient: AccountId,
        token_id: AccountId,
        amount: u128,
        message: Option<String>,
    );
}

pub trait InternalBalanceFungibleTokenHandlers {
    fn ft_on_transfer(&mut self, sender_id: String, amount: String, msg: String) -> String;
    fn get_ft_balance(&self, account_id: ValidAccountId, token_id: ValidAccountId) -> U128;
    fn resolve_internal_ft_transfer_call(
        &mut self,
        account_id: ValidAccountId,
        token_id: ValidAccountId,
        amount: U128,
        is_ft_call: bool,
    ) -> U128;
    fn withdraw_to(
        &mut self,
        amount: U128,
        token_id: ValidAccountId,
        recipient: Option<ValidAccountId>,
        msg: Option<String>,
    );

    fn balance_transfer(
        &mut self,
        recipient: ValidAccountId,
        token_id: ValidAccountId,
        amount: U128,
        message: Option<String>,
    );
}

'''
'''--- near-internal-balances-plugin/near-internal-balances-plugin-internal/src/macros.rs ---
#[macro_export]
macro_rules! impl_near_balance_plugin {
    ($contract_struct: ident, $accounts: ident, $info_struct: ident, $balance_map: ident) => {
        use $crate::{
            BalanceInfo, InternalBalanceFungibleTokenHandlers, NearFTInternalBalance,
            SudoInternalBalanceFungibleToken,
        };

        impl $crate::BalanceInfo for $info_struct {
            fn get_balance(&self, token_id: &AccountId) -> Balance {
                self.$balance_map.get(token_id).unwrap_or(0)
            }

            fn set_balance(&mut self, token_id: &AccountId, balance: Balance) {
                self.$balance_map.insert(token_id, &balance);
            }
        }

        impl $crate::core_impl::AccountInfoTrait for $info_struct {
        }

        impl SudoInternalBalanceFungibleToken for $contract_struct {
            fn subtract_balance(
                &mut self,
                account_id: &AccountId,
                token_id: &AccountId,
                amount: Balance,
            ) {
                $crate::core_impl::subtract_balance(
                    &mut self.$accounts,
                    account_id,
                    token_id,
                    amount,
                )
            }

            fn get_storage_cost_for_one_balance(&mut self) -> Balance {
                $crate::core_impl::get_storage_cost_for_one_balance(&mut self.$accounts)
            }

            fn increase_balance(
                &mut self,
                account_id: &AccountId,
                token_id: &AccountId,
                amount: Balance,
            ) {
                $crate::core_impl::increase_balance(
                    &mut self.$accounts,
                    account_id,
                    token_id,
                    amount,
                )
            }

            fn get_ft_balance_internal(
                &self,
                account_id: &AccountId,
                token_id: &AccountId,
            ) -> Balance {
                self.$accounts
                    .get_account(&account_id)
                    .map(|a| $crate::core_impl::get_ft_balance(&a, &token_id))
                    .unwrap_or(0)
            }

            fn balance_transfer_internal(
                &mut self,
                recipient: AccountId,
                token_id: AccountId,
                amount: u128,
                message: Option<String>,
            ) {
                $crate::core_impl::balance_transfer(
                    &mut self.$accounts,
                    &recipient,
                    &token_id,
                    amount,
                    message,
                )
            }
        }

        #[near_bindgen]
        impl InternalBalanceFungibleTokenHandlers for $contract_struct {
            fn ft_on_transfer(&mut self, sender_id: String, amount: String, msg: String) -> String {
                $crate::core_impl::ft_on_transfer(&mut self.$accounts, sender_id, amount, msg)
            }

            fn get_ft_balance(&self, account_id: ValidAccountId, token_id: ValidAccountId) -> U128 {
                let bal = self
                    .$accounts
                    .get_account(&account_id.into())
                    .map(|a| $crate::core_impl::get_ft_balance(&a, &token_id.into()))
                    .unwrap_or(0);
                U128::from(bal)
            }

            /// A private contract function which resolves the ft transfer by updating the amount used in the balances
            /// @returns the amount used
            #[private]
            fn resolve_internal_ft_transfer_call(
                &mut self,
                account_id: ValidAccountId,
                token_id: ValidAccountId,
                amount: U128,
                is_ft_call: bool,
            ) -> U128 {
                $crate::core_impl::resolve_internal_ft_transfer_call(
                    &mut self.$accounts,
                    &account_id.into(),
                    token_id.into(),
                    amount,
                    is_ft_call,
                )
            }

            #[payable]
            fn balance_transfer(
                &mut self,
                recipient: ValidAccountId,
                token_id: ValidAccountId,
                amount: U128,
                message: Option<String>,
            ) {
                self.balance_transfer_internal(
                    recipient.into(),
                    token_id.into(),
                    amount.into(),
                    message,
                )
            }

            #[payable]
            fn withdraw_to(
                &mut self,
                amount: U128,
                token_id: ValidAccountId,
                recipient: Option<ValidAccountId>,
                msg: Option<String>,
            ) {
                $crate::core_impl::withdraw_to(
                    &mut self.$accounts,
                    amount.into(),
                    token_id.into(),
                    recipient.map(|r| r.into()),
                    msg,
                )
            }
        }
        impl NearFTInternalBalance for $contract_struct {}
    };
}

'''
'''--- near-internal-balances-plugin/src/lib.rs ---
pub use near_internal_balances_plugin_internal::*;

'''
'''--- rustfmt.toml ---
use_small_heuristics = "Max"

'''
'''--- tests/sim/main.rs ---
mod utils;
mod with_macros;

'''
'''--- tests/sim/utils.rs ---
use dummy::ContractContract as DummyContract;
use ft::ContractContract as FTContract;
use near_sdk::json_types::U128;
use near_sdk::serde_json::json;
use near_sdk_sim::{
    deploy, init_simulator, to_yocto, ContractAccount, UserAccount, DEFAULT_GAS, STORAGE_AMOUNT,
};

// Load in contract bytes at runtime
near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    DUMMY_BYTES => "res/dummy.wasm",
    FT_BYTES => "res/ft.wasm",
}

const DUMMY_ID: &str = "dummy";
const FT_ID: &str = "ft";

// Register the given `user` with FT contract
pub fn register_user(user: &near_sdk_sim::UserAccount) {
    user.call(
        DUMMY_ID.to_string(),
        "accounts_storage_deposit",
        &json!({}).to_string().into_bytes(),
        near_sdk_sim::DEFAULT_GAS / 2,
        near_sdk::env::storage_byte_cost() * 1_000,
    );
    user.call(
        FT_ID.to_string(),
        "storage_deposit",
        &json!({
            "account_id": user.valid_account_id()
        })
        .to_string()
        .into_bytes(),
        near_sdk_sim::DEFAULT_GAS / 2,
        near_sdk::env::storage_byte_cost() * 125, // attached deposit
    )
    .assert_success();
}

pub fn init_with_macros(
    ft_total_supply: u128,
) -> (UserAccount, ContractAccount<DummyContract>, ContractAccount<FTContract>, UserAccount) {
    let root = init_simulator(None);
    // uses default values for deposit and gas
    let dummy = deploy!(
        // Contract Proxy
        contract: DummyContract,
        // Contract account id
        contract_id: DUMMY_ID,
        // Bytes of contract
        bytes: &DUMMY_BYTES,
        // User deploying the contract,
        signer_account: root,
        // init method
        init_method: new()
    );

    let ft = deploy!(
        // Contract Proxy
        contract: FTContract,
        // Contract account id
        contract_id: FT_ID,
        // Bytes of contract
        bytes: &FT_BYTES,
        // User deploying the contract,
        signer_account: root,
        // init method
        init_method: new_default_meta(root.valid_account_id(), ft_total_supply.into())
    );

    let alice = root.create_user("alice".to_string(), to_yocto("100"));
    register_user(&alice);
    register_user(&root);

    root.call(
        FT_ID.to_string(),
        "storage_deposit",
        &json!({
            "account_id": dummy.valid_account_id()
        })
        .to_string()
        .into_bytes(),
        near_sdk_sim::DEFAULT_GAS / 2,
        near_sdk::env::storage_byte_cost() * 125, // attached deposit
    )
    .assert_success();

    (root, dummy, ft, alice)
}

'''
'''--- tests/sim/with_macros.rs ---
use std::convert::TryFrom;

use near_contract_standards::storage_management::{StorageBalance, StorageBalanceBounds};
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{self, Deserialize, Serialize};
use near_sdk::serde_json::json;
use near_sdk_sim::{call, to_yocto, transaction::ExecutionStatus, view, DEFAULT_GAS};

use crate::utils::{init_with_macros as init, register_user};

#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct StorageBalanceTmp {
    pub total: U128,
    pub available: U128,
}

const DEFAULT_TOTAL_SUPPLY: u128 = 1_000_000_000_000;

#[test]
fn simulate_simple_storage_test() {
    let (_, dummy, ft, alice) = init(DEFAULT_TOTAL_SUPPLY);
    let storage_bal: StorageBalanceTmp =
        view!(dummy.accounts_storage_balance_of(alice.valid_account_id())).unwrap_json();
    let init_free = storage_bal.available.0;

    call!(alice, dummy.write_message("AAAAA".to_string()), deposit = 1).assert_success();

    let storage_bal: StorageBalanceTmp =
        view!(dummy.accounts_storage_balance_of(alice.valid_account_id())).unwrap_json();
    let post_free = storage_bal.available.0;

    let message: String = view!(dummy.get_message(alice.valid_account_id())).unwrap_json();
    assert_eq!("AAAAA", message);

    assert_eq!(init_free, post_free + 5 * near_sdk::env::storage_byte_cost());

    call!(alice, dummy.write_message("".to_string()), deposit = 1).assert_success();

    let storage_bal: StorageBalanceTmp =
        view!(dummy.accounts_storage_balance_of(alice.valid_account_id())).unwrap_json();
    let final_free = storage_bal.available.0;
    assert_eq!(init_free, final_free);
}

#[test]
fn simulate_simple_internal_balances_test() {
    let (root, dummy, ft, alice) = init(DEFAULT_TOTAL_SUPPLY);
    let amount_transfer = 1_000;

    let ft_bal_root: U128 = view!(ft.ft_balance_of(root.valid_account_id())).unwrap_json();

    call!(
        root,
        ft.ft_transfer_call(dummy.valid_account_id(), amount_transfer.into(), None, "".to_string()),
        deposit = 1
    )
    .assert_success();

    let ft_bal_root_internal: U128 =
        view!(dummy.get_ft_balance(root.valid_account_id(), ft.valid_account_id())).unwrap_json();
    let ft_bal_root_post_transfer: U128 =
        view!(ft.ft_balance_of(root.valid_account_id())).unwrap_json();

    assert_eq!(ft_bal_root.0 - ft_bal_root_post_transfer.0, amount_transfer);
    assert_eq!(ft_bal_root_internal.0, amount_transfer);

    // Withdraw back into the callee's account
    call!(
        root,
        dummy.withdraw_to(amount_transfer.into(), ft.valid_account_id(), None, None),
        deposit = 1
    )
    .assert_success();

    let ft_bal_root_post_withdraw: U128 =
        view!(ft.ft_balance_of(root.valid_account_id())).unwrap_json();
    assert_eq!(ft_bal_root.0, ft_bal_root_post_withdraw.0);
}
// TODO: sim specificdeposit to
#[test]
fn simulate_simple_internal_balances_test_with_sender_id() {
    let (root, dummy, ft, alice) = init(DEFAULT_TOTAL_SUPPLY);
    let amount_transfer = 1_000;

    let ft_bal_root: U128 = view!(ft.ft_balance_of(root.valid_account_id())).unwrap_json();

    call!(
        root,
        ft.ft_transfer_call(
            dummy.valid_account_id(),
            amount_transfer.into(),
            None,
            json!({"sender_id": alice.account_id()}).to_string()
        ),
        deposit = 1
    )
    .assert_success();

    let ft_bal_alice_internal: U128 =
        view!(dummy.get_ft_balance(alice.valid_account_id(), ft.valid_account_id())).unwrap_json();
    let ft_bal_root_post_transfer: U128 =
        view!(ft.ft_balance_of(root.valid_account_id())).unwrap_json();

    assert_eq!(ft_bal_root.0 - ft_bal_root_post_transfer.0, amount_transfer);
    assert_eq!(ft_bal_alice_internal.0, amount_transfer);

    // Withdraw back into the callee's account
    call!(
        alice,
        dummy.withdraw_to(amount_transfer.into(), ft.valid_account_id(), None, None),
        deposit = 1
    )
    .assert_success();

    let ft_bal_alice_post_withdraw: U128 =
        view!(ft.ft_balance_of(alice.valid_account_id())).unwrap_json();
    assert_eq!(amount_transfer, ft_bal_alice_post_withdraw.0);

    let ft_bal_alice_internal: U128 =
        view!(dummy.get_ft_balance(alice.valid_account_id(), ft.valid_account_id())).unwrap_json();
    assert_eq!(ft_bal_alice_internal.0, 0);
}
// TODO: sim specificdeposit to

'''