*GitHub Repository "nft-never-sleep/nft-ns-chain"*

'''--- README.md ---

'''
'''--- contracts/Cargo.toml ---
[workspace]
members = [
    "./nns",
    "./test-nft",
]

[profile.release]
codegen-units = 1
# s = optimize for binary size ("z" would additionally turn off loop vectorization)
opt-level = "z"
# link time optimization
lto = true
debug = false
panic = "abort"
overflow-checks = true

'''
'''--- contracts/README.md ---
# nft_never_sleep

### NFT Standard Interface (NEP-171/177/181)
Some structures are defined in [NEP-177](https://nomicon.io/Standards/NonFungibleToken/Metadata.html)
```rust
/// approved_account_ids not used in this contract
pub struct Token {
    pub token_id: TokenId,
    pub owner_id: AccountId,
    pub metadata: Option<TokenMetadata>,
    pub approved_account_ids: Option<HashMap<AccountId, u64>>,
}
```

#### nft_transfer
```rust
/// 1 yoctoNEAR needed
fn nft_transfer(
    &mut self,
    receiver_id: ValidAccountId,
    token_id: TokenId,
    approval_id: Option<u64>,
    memo: Option<String>,
);
```

#### nft_transfer_call
```rust
/// 1 yoctoNEAR needed
fn nft_transfer_call(
    &mut self,
    receiver_id: ValidAccountId,
    token_id: TokenId,
    approval_id: Option<u64>,
    memo: Option<String>,
    msg: String,
) -> PromiseOrValue<bool>;
```

#### nft_metadata
``rust
fn nft_metadata(&self) -> NFTContractMetadata;
```

#### nft_token
```rust
fn nft_token(self, token_id: TokenId) -> Option<Token>;
```

#### nft_total_supply
```rust
fn nft_total_supply(self) -> U128;
```

#### nft_tokens
```rust
fn nft_tokens(&self, from_index: Option<U128>, limit: Option<u64>) -> Vec<Token>;
```

#### nft_supply_for_owner
```rust
fn nft_supply_for_owner(self, account_id: ValidAccountId) -> U128;
```

#### nft_tokens_for_owner
```rust
fn nft_tokens_for_owner(
    &self,
    account_id: ValidAccountId,
    from_index: Option<U128>,
    limit: Option<u64>,
) -> Vec<Token>;
```

### Custom Interface

```rust
pub enum BidState {
    InProgress,
    // nft owner accept the bid
    Approved,
    // nft owner explicit reject the bid
    Rejected,
    Expired,
    // nft borrower execute the lease
    Consumed,
}
pub struct Bid {
    // global NFT id
    pub src_nft_id: String,
    // nft owner, verified on chain
    pub origin_owner: String,
    // start timestamp of the lease
    pub start_at: u32,
    // duration in seconds of the lease
    pub lasts: u32,
    // total fee of the lease
    pub amount: Balance,
    // extra negotiation info
    pub msg: String,
    // bid creator, that is the borrower
    pub bid_from: AccountId,
    pub bid_state: BidState,
    // bid creation time, used to tell expiration
    pub create_at: Timestamp,
}
```
#### offer_bid
borrower call this to request a lease, and deposit a fixed amount of NEAR as bid endorsement: 
```rust
/// nft_id: the nft want to lease
/// bid_info: lease details, the bid_state set to None
/// return bid id
#[payable]
pub fn offer_bid(&mut self, nft_id: String, bid_info: BidInfo) -> u64;
```

#### take_offer
owner call this to respond a lease request:
```rust
/// bid_id: id of the bid
/// opinion: true means approve, false means reject
/// need 1 yocto NEAR for secure reason
#[payable]
pub fn take_offer(&mut self, bid_id: u64, opinion: bool) -> Promise
```

#### claim_nft
borrower call this to claim lease NFT on an approved bid.
borrower should deposit more than amount in approved bid, remaining would be refunded.
```rust
/// bid_id: id of the bid
#[payable]
pub fn claim_nft(&mut self, bid_id: u64) -> Token;
```

#### get_bid

```rust
/// return None or BidInfo
pub fn get_bid(bid_id: u64) -> Option<BidInfo>;
```

#### list_bids_by_sender
```rust
/// sender_id, bider account ID
/// return HashMap <bid_id, BidInfo>
pub fn list_bids_by_sender(sender_id: ValidAccountId) -> HashMap<u64, BidInfo>;
```

#### list_bids_by_nft
```rust
/// src_nft_id, the one in BidInfo
/// return HashMap <bid_id, BidInfo>
pub fn list_bids_by_nft(src_nft_id: String) -> HashMap<u64, BidInfo>;
```
'''
'''--- contracts/introduction.md ---
# NFT-NS 合约介绍
## 合约职责
* 为租借双方提供报价和协商的无需信任的渠道
* 无需信任的租借流程
## 合约特点
* 最简化租借流程  
    租借双方三步完成租借过程：
    * offer_bid borrower发起报价请求;
    * take_offer nft owner响应报价;
    * claim_nft borrower执行租约;

* NFT统一ID  
    通过[contract_id]:[Token_ID]的模式，统一标记near生态上的所有NFT；
* 全生命周期Bid报价设计  
    ```rust
    pub enum BidState {
        InProgress,
        // nft owner accept the bid
        Approved,
        // nft owner explicit reject the bid
        Rejected,
        Expired,
        // nft borrower execute the lease
        Consumed,
    }
    pub struct Bid {
        // global NFT id
        pub src_nft_id: String,
        // nft owner, verified on chain
        pub origin_owner: String,
        // start timestamp of the lease
        pub start_at: u32,
        // duration in seconds of the lease
        pub lasts: u32,
        // total fee of the lease
        pub amount: Balance,
        // extra negotiation info
        pub msg: String,
        // bid creator, that is the borrower
        pub bid_from: AccountId,
        pub bid_state: BidState,
        // bid creation time, used to tell expiration
        pub create_at: Timestamp,
    }
    ```
    * 报价有过期机制，NFT所有者无需主动拒绝不合适的报价；
    * 报价有保证金机制，创建报价时需支付1Near的押金（可通过合约所有者，一般是DAO，进行修改），防止flood bid attack;
    * 得益于near的NFT标准NEP171/177，以及优异的cross contract call设计，nft的owner由链上负责验证;
    * 租期时间颗粒度细化到秒级;

* 原子化的租借过程  
    当一份租借bid被nft owner接受后，borrower通过一个合约调用完成全部租借动作，包括：铸造借品NFT，支付租借费给nft owner，退还报价押金。

    其中在owner调用`take_offer`合约接口响应`bid`的时候，合约通过`cross contract call`获取nft的链上真实owner进行验证，保证调用者为nft所有者:
    ```rust
    ext_contract::nft_token(
        token_id.to_string(),
        &token_contract.to_string(),
        0,
        GAS_FOR_VIEW,
    )
    .then(ext_self::on_nft_token_callback(
        caller_id.clone(),
        bid_id,
        opinion,
        &env::current_account_id(),
        0,
        GAS_FOR_RESOLVE,
    ))
    ```

    ```rust
    #[private]
    pub fn on_nft_token_callback(&mut self, caller: AccountId, bid_id: u64, opinion: bool) {
        ...
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => {}
            PromiseResult::Successful(value) => {
                let parsed_result = near_sdk::serde_json::from_slice::<Token>(&value);
                if parsed_result.is_ok() {
                    let nft_owner = parsed_result.ok().and_then(|token| Some(token.owner_id)).unwrap();
                    env::log(
                        format!(
                            "Checking result --> nft owner: {}, caller: {}",
                            nft_owner.clone(), caller.clone(),
                        )
                        .as_bytes(),
                    );
                    assert_eq!(nft_owner, caller, "Err: only owner of the NFT can take offer");
                    self.internal_take_offer(&caller, bid_id, opinion);
                }
            }
        }
    }
    ```

* 借品NFT  
    * 通过在metadata的description字段填入NFT统一ID，建立起借品与原件之间的链上关系;
    * 在metadata的title字段填入NFT Never Sleep，标识此为借品NFT;
    * 通过metadata的issue_at, start_at, expire_at字段描述借品的时间范围;

'''
'''--- contracts/nns/Cargo.toml ---
[package]
name = "nns"
version = "1.0.0"
authors = ["Marco <sun.dsk1@gmail.com>"]
edition = "2018"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"

[dev-dependencies]
near-sdk-sim = "3.1.0"
test-nft = { path = "../test-nft" }

'''
'''--- contracts/nns/build.sh ---
#!/bin/bash
set -e
rustup target add wasm32-unknown-unknown
RUSTFLAGS='-C link-arg=-s' cargo build --target wasm32-unknown-unknown --release
cd ..
cp target/wasm32-unknown-unknown/release/nns.wasm ./res/nns.wasm
cd -

'''
'''--- contracts/nns/src/bid.rs ---

use crate::*;
use crate::utils::*;

#[derive(BorshSerialize, BorshDeserialize, Serialize, Deserialize, Clone, Debug, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum BidState {
    InProgress,
    Approved,
    Rejected,
    Expired,
    Consumed,
}

#[derive(BorshSerialize, BorshDeserialize, Clone)]
pub struct Bid {
    pub src_nft_id: String,
    pub origin_owner: String,
    pub start_at: u32,
    pub lasts: u32,
    pub amount: Balance,
    pub msg: String,
    pub bid_from: AccountId,
    pub bid_state: BidState,
    pub create_at: Timestamp,
}

impl From<&BidInfo> for Bid {
    fn from(bid: &BidInfo) -> Self {
        Self {
            src_nft_id: bid.src_nft_id.clone(),
            origin_owner: "".to_string(),
            start_at: bid.start_at,
            lasts: bid.lasts,
            amount: bid.amount.into(),
            msg: bid.msg.clone(),
            bid_from: bid.bid_from.clone(),
            bid_state: BidState::InProgress,
            create_at: env::block_timestamp(),
        }
    }
}

impl Bid {
    pub fn cur_state(&self, expire_sec: u32) -> BidState {
        match self.bid_state {
            BidState::InProgress => {
                if self.create_at + sec_to_nano(expire_sec) < env::block_timestamp() {
                    BidState::Expired
                } else {
                    BidState::InProgress
                }
            }
            _ => { self.bid_state.clone() }
        }
    }

    pub fn accept_bid(&mut self, opinion: bool, expire_sec: u32) {
        self.bid_state = self.cur_state(expire_sec);
        match self.bid_state {
            BidState::InProgress => {
                if opinion {
                    self.bid_state = BidState::Approved;
                } else {
                    self.bid_state = BidState::Rejected;
                }
            }
            _ => {}
        }
    }
}

impl Contract {
    pub(crate) fn internal_add_bid(&mut self, bid_info: &BidInfo) -> u64 {
        let bid: Bid = bid_info.into();
        let id = self.bids.len() as u64;
        self.bids.push(&bid);
        id
    }

    pub(crate) fn internal_take_offer(&mut self, owner_id: &AccountId, bid_id: u64, opinion: bool) {
        let mut bid = self.bids.get(bid_id).expect("ERR_NO_BID");
        bid.accept_bid(opinion, self.bid_expire_sec);
        bid.origin_owner = owner_id.clone();
        self.bids.replace(bid_id, &bid);
    }
}

'''
'''--- contracts/nns/src/borrower.rs ---
use std::convert::TryInto;

use crate::*;
use crate::utils::*;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Borrower {
    pub bids: Vec<u64>,
}

impl Borrower {
    pub fn new() -> Self {
        Borrower {
            bids: vec![],
        }
    }
}

impl Contract {
    pub fn internal_get_borrower(&self, account_id: &AccountId) -> Option<Borrower> {
        self.borrowers
            .get(account_id)
    }

    pub(crate) fn internal_save_borrower(&mut self, account_id: &AccountId, borrower: &Borrower) {
        self.borrowers.insert(account_id, borrower);
    }
}

#[near_bindgen]
impl Contract {
    /// borrower deposit 1 near as endorsement to create a new bid
    /// nft owner implies in nft_id
    /// bid valid period is global config
    #[payable]
    pub fn offer_bid(&mut self, bid_info: BidInfo) -> u64 {
        assert_eq!(env::attached_deposit(), ONE_NEAR, "");
        let sender_id = env::predecessor_account_id();
        let nft_id = bid_info.src_nft_id.clone();

        let id = self.internal_add_bid(&bid_info);

        let mut borrower = self.internal_get_borrower(&sender_id)
            .unwrap_or_else(|| Borrower::new());
        borrower.bids.push(id);
        self.internal_save_borrower(&sender_id, &borrower);

        let mut subject = self.internal_get_subject(&nft_id)
            .unwrap_or_else(|| Subject::new());
        subject.bids.push(id);
        self.internal_save_subject(&nft_id, &subject);

        id
    }

    /// nft borrower call this and  deposit bid amount of near
    /// trigger process:
    ///   mint_nft: mint new nns nft belong to borrower with correct metadata.
    #[payable]
    pub fn claim_nft(&mut self, bid_id: u64) -> Token {

        let sender_id = env::predecessor_account_id();

        let mut bid = self.bids.get(bid_id).expect("ERR_NO_BID");
        
        // check bid is valid to mint nft
        assert_eq!(bid.bid_state, BidState::Approved, "ERR_INVALID_BID");
        let amount = env::attached_deposit();
        assert!(amount >= bid.amount, "ERR_INSURFFICIENT_AMOUNT");
        bid.bid_state = BidState::Consumed;
        self.bids.replace(bid_id, &bid);

        let token_id = format!("{}", self.token_num);
        
        let metadata = Some(TokenMetadata {
            title: Some("NFT NEVER SLEEP".to_string()),          // ex. "Arch Nemesis: Mail Carrier" or "Parcel #5055"
            description: Some(bid.src_nft_id.clone()),    // free-form description
            media: None, // URL to associated media, preferably to decentralized, content-addressed storage
            media_hash: None, // Base64-encoded sha256 hash of content referenced by the `media` field. Required if `media` is included.
            copies: None, // number of copies of this set of metadata in existence when token was minted.
            issued_at: Some(env::block_timestamp().to_string()), // ISO 8601 datetime when token was issued or minted
            expires_at: Some(sec_to_nano(bid.start_at + bid.lasts).to_string()), // ISO 8601 datetime when token expires
            starts_at: Some(sec_to_nano(bid.start_at).to_string()), // ISO 8601 datetime when token starts being valid
            updated_at: None, // ISO 8601 datetime when token was last updated
            extra: None, // anything extra the NFT wants to store on-chain. Can be stringified JSON.
            reference: None, // URL to an off-chain JSON file with more info.
            reference_hash: None, // Base64-encoded sha256 hash of JSON from reference field. Required if `reference` is included.
        });

        self.token_num += 1;
        
        let token = self.internal_mint(token_id, sender_id.clone().try_into().unwrap(), metadata);

        // send near to owner and remain back to caller
        Promise::new(bid.origin_owner).transfer(bid.amount);
        // at least refund 1 near bid endorsement fee
        let refund = ONE_NEAR + amount - bid.amount;
        Promise::new(sender_id).transfer(refund);

        token
    }

}

'''
'''--- contracts/nns/src/lib.rs ---
/*!
* NFT Never Sleep contract
*
*/
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::collections::{LookupMap, LazyOption, Vector, UnorderedSet};
use near_sdk::{assert_one_yocto, env, near_bindgen, AccountId, Balance, BorshStorageKey, 
    ext_contract, PanicOnDefault, Promise, PromiseResult, PromiseOrValue, Timestamp, CryptoHash};

use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};

use crate::borrower::Borrower;
use crate::nft_owner::Subject;
pub use crate::bid::{Bid, BidState};
pub use crate::view::BidInfo;
use crate::utils::DATA_IMAGE_SVG_PARAS_ICON;

mod utils;
mod bid;
mod nft_owner;
mod borrower;
mod view;

near_sdk::setup_alloc!();

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    TokensPerOwner { account_hash: Vec<u8> },
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,

    Bids,
    Borrowers,
    Subjects,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    owner_id: AccountId,
    
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
    token_num: u32,

    bids: Vector<Bid>,
    bid_expire_sec: u32,
    borrowers: LookupMap<AccountId, Borrower>,
    subjects: LookupMap<String, Subject>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: ValidAccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Contract {
            owner_id: owner_id.clone().into(),

            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(
                &NFTContractMetadata {
                    spec: NFT_METADATA_SPEC.to_string(),
                    name: "Nft Never Sleep".to_string(),
                    symbol: "nns".to_string(),
                    icon: Some(DATA_IMAGE_SVG_PARAS_ICON.to_string()),
                    base_uri: None,
                    reference: None,
                    reference_hash: None,
                })),

            token_num: 0,
            bids: Vector::new(StorageKey::Bids),
            bid_expire_sec: 3600 * 24 * 7,
            borrowers: LookupMap::new(StorageKey::Borrowers),
            subjects: LookupMap::new(StorageKey::Subjects),
        }
    }
}

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

impl Contract {
    pub fn internal_mint(&mut self, 
        token_id: TokenId,
        token_owner_id: ValidAccountId,
        token_metadata: Option<TokenMetadata>,
    ) -> Token {
        if self.tokens.token_metadata_by_id.is_some() && token_metadata.is_none() {
            env::panic(b"Must provide metadata");
        }
        if self.tokens.owner_by_id.get(&token_id).is_some() {
            env::panic(b"token_id must be unique");
        }

        let owner_id: AccountId = token_owner_id.into();

        // Core behavior: every token must have an owner
        self.tokens.owner_by_id.insert(&token_id, &owner_id);

        // Metadata extension: Save metadata, keep variable around to return later.
        // Note that check above already panicked if metadata extension in use but no metadata
        // provided to call.
        self.tokens.token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &token_metadata.as_ref().unwrap()));

        // Enumeration extension: Record tokens_per_owner for use with enumeration view methods.
        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&owner_id).unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::TokensPerOwner {
                    account_hash: env::sha256(owner_id.as_bytes()),
                })
            });
            token_ids.insert(&token_id);
            tokens_per_owner.insert(&owner_id, &token_ids);
        }

        Token { token_id, owner_id, metadata: token_metadata, approved_account_ids: None }
    }
}

'''
'''--- contracts/nns/src/nft_owner.rs ---
use crate::*;
use crate::utils::*;

#[derive(BorshSerialize, BorshDeserialize)]
pub struct Subject {
    pub bids: Vec<u64>,
}

impl Subject {
    pub fn new() -> Self {
        Subject {
            bids: vec![],
        }
    }
}

impl Contract {
    pub fn internal_get_subject(&self, nft_id: &String) -> Option<Subject> {
        self.subjects
            .get(nft_id)
    }

    pub(crate) fn internal_save_subject(&mut self, nft_id: &String, subject: &Subject) {
        self.subjects.insert(nft_id, subject);
    }
}

#[ext_contract(ext_contract)]
trait ExtContract {
    fn nft_token(&mut self, token_id: TokenId);
}

#[ext_contract(ext_self)]
trait ExtSelf {
    fn on_nft_token_callback(&mut self, caller: AccountId, bid_id: u64, opinion: bool);
}

#[near_bindgen]
impl Contract {
    /// nft owner call this to add finalized state into bid
    #[payable]
    pub fn take_offer(&mut self, bid_id: u64, opinion: bool) -> Promise {
        assert_one_yocto();

        let caller_id = env::predecessor_account_id();

        let bid = self.bids.get(bid_id).expect("ERR_NO_BID");

        let (token_contract, token_id) = {
            let pos = bid.src_nft_id.find(":").unwrap_or(bid.src_nft_id.len());
            let (token_contract, remains) = bid.src_nft_id.split_at(pos);
            let (_, token_id) = remains.split_at(1);
            (token_contract, token_id)
        };

        env::log(
            format!(
                "Checking token {} on {}",
                token_id.to_string(), token_contract.to_string(),
            )
            .as_bytes(),
        );

        ext_contract::nft_token(
            token_id.to_string(),
            &token_contract.to_string(),
            0,
            GAS_FOR_VIEW,
        )
        .then(ext_self::on_nft_token_callback(
            caller_id.clone(),
            bid_id,
            opinion,
            &env::current_account_id(),
            0,
            GAS_FOR_RESOLVE,
        ))
    }

    #[private]
    pub fn on_nft_token_callback(&mut self, caller: AccountId, bid_id: u64, opinion: bool) {
        assert_eq!(
            env::promise_results_count(),
            1,
            "Err: expected 1 promise result from nft_token"
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => {}
            PromiseResult::Successful(value) => {
                let parsed_result = near_sdk::serde_json::from_slice::<Token>(&value);
                if parsed_result.is_ok() {
                    let nft_owner = parsed_result.ok().and_then(|token| Some(token.owner_id)).unwrap();
                    env::log(
                        format!(
                            "Checking result --> nft owner: {}, caller: {}",
                            nft_owner.clone(), caller.clone(),
                        )
                        .as_bytes(),
                    );
                    assert_eq!(nft_owner, caller, "Err: only owner of the NFT can take offer");
                    self.internal_take_offer(&caller, bid_id, opinion);
                }
            }
        }
    }
}

'''
'''--- contracts/nns/src/utils.rs ---

use near_sdk::{Balance, Gas, Timestamp};

pub const GAS_FOR_VIEW: Gas = 5_000_000_000_000;
pub const GAS_FOR_RESOLVE: Gas = 20_000_000_000_000;
pub const ONE_NEAR: Balance = 1_000_000_000_000_000_000_000_000;

pub const DATA_IMAGE_SVG_PARAS_ICON: &str = "data:image/svg+xml,%3Csvg width='1080' height='1080' viewBox='0 0 1080 1080' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Crect width='1080' height='1080' rx='10' fill='%230000BA'/%3E%3Cpath fill-rule='evenodd' clip-rule='evenodd' d='M335.238 896.881L240 184L642.381 255.288C659.486 259.781 675.323 263.392 689.906 266.718C744.744 279.224 781.843 287.684 801.905 323.725C827.302 369.032 840 424.795 840 491.014C840 557.55 827.302 613.471 801.905 658.779C776.508 704.087 723.333 726.74 642.381 726.74H468.095L501.429 896.881H335.238ZM387.619 331.329L604.777 369.407C614.008 371.807 622.555 373.736 630.426 375.513C660.02 382.193 680.042 386.712 690.869 405.963C704.575 430.164 711.428 459.95 711.428 495.321C711.428 530.861 704.575 560.731 690.869 584.932C677.163 609.133 648.466 621.234 604.777 621.234H505.578L445.798 616.481L387.619 331.329Z' fill='white'/%3E%3C/svg%3E";

// pub fn nano_to_sec(nano: Timestamp) -> u32 {
//     (nano / 1_000_000_000) as u32
// }

pub fn sec_to_nano(sec: u32) -> Timestamp {
    sec as Timestamp * 1_000_000_000
}

'''
'''--- contracts/nns/src/view.rs ---
//! View functions for the contract.

use std::collections::HashMap;

use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::{near_bindgen, AccountId};
use crate::*;

#[derive(Serialize, Deserialize, Clone)]
#[cfg_attr(not(target_arch = "wasm32"), derive(PartialEq, Debug))]
#[serde(crate = "near_sdk::serde")]
pub struct BidInfo {
    pub src_nft_id: String,
    pub orgin_owner: String,
    pub start_at: u32,
    pub lasts: u32,
    pub amount: U128,
    pub msg: String,
    pub bid_from: AccountId,
    pub bid_state: Option<BidState>,
}

impl From<&Bid> for BidInfo {
    fn from(bid: &Bid) -> Self {
        Self {
            src_nft_id: bid.src_nft_id.clone(),
            orgin_owner: bid.origin_owner.clone(),
            start_at: bid.start_at,
            lasts: bid.lasts,
            amount: bid.amount.into(),
            msg: bid.msg.clone(),
            bid_from: bid.bid_from.clone(),
            bid_state: Some(bid.bid_state.clone()),
        }
    }
}

#[near_bindgen]
impl Contract {
    pub fn get_bid(&self, bid_id: u64) -> Option<BidInfo> {
        if let Some(bid) = self.bids.get(bid_id) {
            Some((&bid).into())
        } else {
            None
        }
    }

    pub fn list_bids_by_sender(&self, sender_id: ValidAccountId) -> HashMap<u64, BidInfo> {
        self.internal_get_borrower(sender_id.as_ref())
        .unwrap_or(Borrower::new())
        .bids
        .iter()
        .map(|bid_id| (*bid_id, self.get_bid(*bid_id).unwrap()))
        .collect()
    }

    pub fn list_bids_by_nft(&self, nft_id: String) -> HashMap<u64, BidInfo> {
        self.internal_get_subject(&nft_id)
        .unwrap_or(Subject::new())
        .bids
        .iter()
        .map(|bid_id| (*bid_id, self.get_bid(*bid_id).unwrap()))
        .collect()
    }
}
'''
'''--- contracts/nns/tests/common/init.rs ---
use near_sdk_sim::{call, deploy, init_simulator, to_yocto, ContractAccount, UserAccount};
use test_nft::ContractContract as TestNft;
use nns::ContractContract as Nns;

near_sdk_sim::lazy_static_include::lazy_static_include_bytes! {
    TESTNFT_WASM_BYTES => "../res/test_nft.wasm",
    NNS_WASM_BYTES => "../res/nns.wasm",
}

pub fn init_env() -> (UserAccount, UserAccount, UserAccount, ContractAccount<TestNft>, ContractAccount<Nns>){
    let root = init_simulator(None);

    let owner = root.create_user("owner".to_string(), to_yocto("100"));
    let user = root.create_user("user".to_string(), to_yocto("100"));

    let nft_contract = deploy!(
        contract: TestNft,
        contract_id: "test_nft",
        bytes: &TESTNFT_WASM_BYTES,
        signer_account: root
    );
    call!(root, nft_contract.new(owner.valid_account_id())).assert_success();

    let nns_contract = deploy!(
        contract: Nns,
        contract_id: "nns",
        bytes: &NNS_WASM_BYTES,
        signer_account: root
    );
    call!(root, nns_contract.new(owner.valid_account_id())).assert_success();
    
    (root, owner, user, nft_contract, nns_contract)
}

'''
'''--- contracts/nns/tests/common/mod.rs ---
pub mod init;
pub mod utils;
'''
'''--- contracts/nns/tests/common/utils.rs ---
use std::collections::HashMap;
use near_sdk::json_types::{ValidAccountId, U128};
use near_sdk::serde_json::{Value, from_value};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::AccountId;
use near_sdk_sim::{
    view, ContractAccount, ExecutionResult,
};
use near_contract_standards::non_fungible_token::{Token, TokenId};
use nns::{ContractContract as Nns, BidInfo};
use test_nft::ContractContract as TestNft;

pub fn get_error_count(r: &ExecutionResult) -> u32 {
    r.promise_errors().len() as u32
}

pub fn get_error_status(r: &ExecutionResult) -> String {
    format!("{:?}", r.promise_errors()[0].as_ref().unwrap().status())
}

//*****************************
// View functions
//*****************************

pub fn testnft_tokens_for_owner(
    nft: &ContractAccount<TestNft>, 
    account_id: ValidAccountId
) -> Vec<Token> {
    view!(nft.nft_tokens_for_owner(account_id, None, None)).unwrap_json::<Vec<Token>>()
}

pub fn testnft_token(
    nft: &ContractAccount<TestNft>, 
    token_id: String
) -> Option<Token> {
    view!(nft.nft_token(token_id)).unwrap_json::<Option<Token>>()
}

pub fn nns_tokens_for_owner(
    nns: &ContractAccount<Nns>, 
    account_id: ValidAccountId
) -> Vec<Token> {
    view!(nns.nft_tokens_for_owner(account_id, None, None)).unwrap_json::<Vec<Token>>()
}

pub fn nns_token(
    nns: &ContractAccount<Nns>, 
    token_id: String
) -> Option<Token> {
    view!(nns.nft_token(token_id)).unwrap_json::<Option<Token>>()
}

pub fn nns_list_bids_by_sender(
    nns: &ContractAccount<Nns>, 
    account_id: ValidAccountId
) -> HashMap<u64, BidInfo> {
    view!(nns.list_bids_by_sender(account_id)).unwrap_json::<HashMap<u64, BidInfo>>()
}

pub fn nns_list_bids_by_nft(
    nns: &ContractAccount<Nns>, 
    nft_id: String
) -> HashMap<u64, BidInfo> {
    view!(nns.list_bids_by_nft(nft_id)).unwrap_json::<HashMap<u64, BidInfo>>()
}

pub fn nns_get_bid(
    nns: &ContractAccount<Nns>, 
    bid_id: u64
) -> Option<BidInfo> {
    view!(nns.get_bid(bid_id)).unwrap_json::<Option<BidInfo>>()
}

'''
'''--- contracts/nns/tests/test_bid.rs ---
use near_sdk_sim::{call, view, to_yocto};
use near_sdk::json_types::U128;
use near_contract_standards::non_fungible_token::metadata::TokenMetadata;

use nns::{BidInfo, BidState};

mod common;
use crate::common::{
    init::*,
    utils::*,
};

#[test]
fn test_bid() {
    let (root, owner, user, testnft_contract, nns_contract) = 
        init_env();
    
    let out_come = call!(
        owner,
        testnft_contract.mint_nft("fake_nft_1".to_string(), user.valid_account_id(), Some(TokenMetadata {
            title: Some("fake_nft_1".to_string()),          
            description: Some("Fake NFT #01".to_string()),  
            media: None, 
            media_hash: None, 
            copies: None, 
            issued_at: None, 
            expires_at: None, 
            starts_at: None, 
            updated_at: None, 
            extra: None, 
            reference: None, 
            reference_hash: None, 
        })),
        deposit = 0
    );
    // println!("{:#?}", out_come.promise_results());
    out_come.assert_success();

    let out_come = call!(
        owner,
        testnft_contract.mint_nft("fake_nft_2".to_string(), user.valid_account_id(), Some(TokenMetadata {
            title: Some("fake_nft_2".to_string()),          
            description: Some("Fake NFT #02".to_string()),  
            media: None, 
            media_hash: None, 
            copies: None, 
            issued_at: None, 
            expires_at: None, 
            starts_at: None, 
            updated_at: None, 
            extra: None, 
            reference: None, 
            reference_hash: None, 
        })),
        deposit = 0
    );
    out_come.assert_success();

    let nfts = testnft_tokens_for_owner(&testnft_contract, user.valid_account_id());
    // println!("{:#?}", nfts);
    println!("count: {}", nfts.len());

    let nft = testnft_token(&testnft_contract, "fake_nft_1".to_string());
    // println!("nft: {:#?}", nft);

    let user1 = root.create_user("user1".to_string(), to_yocto("100"));

    let out_come = call!(
        user1,
        nns_contract.offer_bid(BidInfo {
            src_nft_id: "test_nft:fake_nft_1".to_string(),
            orgin_owner: "".to_string(),
            start_at: 100,
            lasts: 60,
            amount: U128(to_yocto("5")),
            msg: "".to_string(),
            bid_from: user1.account_id(),
            bid_state: None,
        }),
        deposit = to_yocto("1")
    );
    // println!("{:#?}", out_come.promise_results());
    out_come.assert_success();

    let bids = nns_list_bids_by_sender(&nns_contract, user1.valid_account_id());
    assert_eq!(bids.get(&0).unwrap().bid_from, "user1".to_string());
    let bids = nns_list_bids_by_nft(&nns_contract, "test_nft:fake_nft_1".to_string());
    assert_eq!(bids.get(&0).unwrap().src_nft_id, "test_nft:fake_nft_1".to_string());

    let out_come = call!(
        user,
        nns_contract.take_offer(0, true),
        deposit = 1
    );
    // println!("{:#?}", out_come.promise_results());
    out_come.assert_success();

    let bid = nns_get_bid(&nns_contract, 0).unwrap();
    assert_eq!(bid.bid_state, Some(BidState::Approved));

    let out_come = call!(
        user1,
        nns_contract.claim_nft(0),
        deposit = to_yocto("6")
    );
    // println!("{:#?}", out_come.promise_results());
    out_come.assert_success();

    let bid = nns_get_bid(&nns_contract, 0).unwrap();
    assert_eq!(bid.bid_state, Some(BidState::Consumed));
    let nft = nns_token(&nns_contract, "0".to_string());
    assert_eq!(nft.unwrap().owner_id, "user1".to_string());

    let nfts = nns_tokens_for_owner(&nns_contract, user1.valid_account_id());
    println!("{:#?}", nfts);
    println!("count: {}", nfts.len());
}

'''
'''--- contracts/test-nft/Cargo.toml ---
[package]
name = "test-nft"
version = "1.0.0"
authors = ["Marco <sun.dsk1@gmail.com>"]
edition = "2018"
publish = false

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
near-sdk = "3.1.0"
near-contract-standards = "3.1.0"
'''
'''--- contracts/test-nft/build.sh ---
#!/bin/bash
set -e

RUSTFLAGS='-C link-arg=-s' cargo +stable build --target wasm32-unknown-unknown --release
cd ..
cp target/wasm32-unknown-unknown/release/test_nft.wasm res/
cd -

'''
'''--- contracts/test-nft/src/lib.rs ---
/*!
* Test NFT contract
*
*/
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::json_types::{ValidAccountId};
use near_sdk::collections::{LazyOption, UnorderedSet};
use near_sdk::{env, near_bindgen, AccountId, BorshStorageKey, 
    PanicOnDefault, PromiseOrValue, CryptoHash};

use near_contract_standards::non_fungible_token::metadata::{
    NFTContractMetadata, NonFungibleTokenMetadataProvider, TokenMetadata, NFT_METADATA_SPEC,
};
use near_contract_standards::non_fungible_token::NonFungibleToken;
use near_contract_standards::non_fungible_token::{Token, TokenId};

near_sdk::setup_alloc!();

#[derive(BorshStorageKey, BorshSerialize)]
pub(crate) enum StorageKey {
    TokensPerOwner { account_hash: Vec<u8> },
    TokenPerOwnerInner { account_id_hash: CryptoHash },
    NonFungibleToken,
    Metadata,
    TokenMetadata,
    Enumeration,
    Approval,
}

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]
pub struct Contract {
    tokens: NonFungibleToken,
    metadata: LazyOption<NFTContractMetadata>,
}

#[near_bindgen]
impl Contract {
    #[init]
    pub fn new(owner_id: ValidAccountId) -> Self {
        assert!(!env::state_exists(), "Already initialized");
        Contract {
            tokens: NonFungibleToken::new(
                StorageKey::NonFungibleToken,
                owner_id,
                Some(StorageKey::TokenMetadata),
                Some(StorageKey::Enumeration),
                Some(StorageKey::Approval),
            ),
            metadata: LazyOption::new(StorageKey::Metadata, Some(
                &NFTContractMetadata {
                    spec: NFT_METADATA_SPEC.to_string(),
                    name: "Test Nft".to_string(),
                    symbol: "tn".to_string(),
                    icon: None,
                    base_uri: None,
                    reference: None,
                    reference_hash: None,
                })),
        }
    }

    pub fn mint_nft(&mut self, 
        token_id: TokenId,
        token_owner_id: ValidAccountId,
        token_metadata: Option<TokenMetadata>,
    ) -> Token {

        if self.tokens.token_metadata_by_id.is_some() && token_metadata.is_none() {
            env::panic(b"Must provide metadata");
        }
        if self.tokens.owner_by_id.get(&token_id).is_some() {
            env::panic(b"token_id must be unique");
        }

        let owner_id: AccountId = token_owner_id.into();

        // Core behavior: every token must have an owner
        self.tokens.owner_by_id.insert(&token_id, &owner_id);

        // Metadata extension: Save metadata, keep variable around to return later.
        // Note that check above already panicked if metadata extension in use but no metadata
        // provided to call.
        self.tokens.token_metadata_by_id
            .as_mut()
            .and_then(|by_id| by_id.insert(&token_id, &token_metadata.as_ref().unwrap()));

        // Enumeration extension: Record tokens_per_owner for use with enumeration view methods.
        if let Some(tokens_per_owner) = &mut self.tokens.tokens_per_owner {
            let mut token_ids = tokens_per_owner.get(&owner_id).unwrap_or_else(|| {
                UnorderedSet::new(StorageKey::TokensPerOwner {
                    account_hash: env::sha256(owner_id.as_bytes()),
                })
            });
            token_ids.insert(&token_id);
            tokens_per_owner.insert(&owner_id, &token_ids);
        }

        Token { token_id, owner_id, metadata: token_metadata, approved_account_ids: None }
    }
}

#[near_bindgen]
impl NonFungibleTokenMetadataProvider for Contract {
    fn nft_metadata(&self) -> NFTContractMetadata {
        self.metadata.get().unwrap()
    }
}

near_contract_standards::impl_non_fungible_token_core!(Contract, tokens);
near_contract_standards::impl_non_fungible_token_enumeration!(Contract, tokens);

'''