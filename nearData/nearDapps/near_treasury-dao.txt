*GitHub Repository "near/treasury-dao"*

'''--- .github/ISSUE_TEMPLATE/BOUNTY.yml ---
name: "Simple Bounty"
description: "Use this template to create a HEROES Simple Bounty via Github bot"
title: "Bounty: "
labels: ["bounty"]
assignees: heroes-bot-test
body:
  - type: markdown
    attributes:
      value: |
        Hi! Let's set up your bounty! Please don't change the template - @heroes-bot-test won't be able to help you.

  - type: dropdown
    id: type
    attributes:
      label: What talent are you looking for?
      options:
        - Marketing
        - Development
        - Design
        - Other
        - Content
        - Research
        - Audit

  - type: textarea
    id: description
    attributes:
      label: What you need to be done?

  - type: dropdown
    id: tags
    attributes:
      label: Tags
      description: Add tags that match the topic of the work
      multiple: true
      options:
        - API
        - Blockchain
        - Community
        - CSS
        - DAO
        - dApp
        - DeFi
        - Design
        - Documentation
        - HTML
        - Javascript
        - NFT
        - React
        - Rust
        - Smart contract
        - Typescript
        - UI/UX
        - web3
        - Translation
        - Illustration
        - Branding
        - Copywriting
        - Blogging
        - Editing
        - Video Creation
        - Social Media
        - Graphic Design
        - Transcription
        - Product Design
        - Artificial Intelligence
        - Quality Assurance
        - Risk Assessment
        - Security Audit
        - Bug Bounty
        - Code Review
        - Blockchain Security
        - Smart Contract Testing
        - Penetration Testing
        - Vulnerability Assessment
        - BOS
        - News
        - Hackathon
        - NEARCON2023
        - NEARWEEK

  - type: input
    id: deadline
    attributes:
      label: Deadline
      description: "Set a deadline for your bounty. Please enter the date in format: DD.MM.YYYY"
      placeholder: "19.05.2027"

  - type: dropdown
    id: currencyType
    attributes:
      label: Currency
      description: What is the currency you want to pay?
      options:
        - USDC.e
        - USDT.e
        - DAI
        - wNEAR
        - USDt
        - XP
        - marmaj
        - NEKO
        - JUMP
        - USDC
        - NEARVIDIA
      default: 0
    validations:
      required: true

  - type: input
    id: currencyAmount
    attributes:
      label: Amount
      description: How much it will be cost?

  - type: markdown
    attributes:
      value: "## Advanced settings"

  - type: checkboxes
    id: kyc
    attributes:
      label: KYC
      description: "Use HEROES' KYC Verification, only applicants who passed HEROES' KYC can apply and work on this bounty!"
      options:
        - label: Use KYC Verification

  - type: markdown
    attributes:
      value: |
        ### This cannot be changed once the bounty is live!

'''
'''--- README.md ---
# Treasury DAO

This is the place for all the forming documents of Treasury DAO, scripts and tools.

## Constitution

TODO

## Code of Conduct

TODO

## Staking snapshot

Staking snapshot is the code that snapshots the amount staked and delegated by all the users.
The amounts in the snapshot are used as a weight for user votes in the voting contract.
On chain only merkle root of the snapshot is stored, off-chain path is computed when the vote is cast and provided to the contract.

The snapshot format is `account_id,amount`, sorted by `account_id` to ensure predictability.

Lockup contracts are resolved to the owner. All delegations across mulitple pools are sumed.

## Voting contract

Voting contract that is used to self nominate as candidate and voting.

Next set of APIs are present:
 - `set_snapshot(hash: CryptoHash)` -- can be only called once a quarter by `owner_id`.
 - `self_nominate(gov_forum_link: String)` -- can be used by individual who wants to be candidate into members. Can be called at any point. The critical piece is the link to the governance forum that will link their discussion identity and other info. This requires a small deposit to cover storage of this information.
 - `vote(candidate_id: AccountId, vote_amount: Balance, total_amount: Balance, proof: MerkleProof)` -- given account delegates part of their "weight" `vote_amount` to given candidate. `total_amount` and `proof` are required to validate this user in the snapshot.

Next view functions are available:
 - `get_owner() -> AccountId` -- account that can be set `owner_id`
 - `get_snapshot_hash() -> CryptoHash` -- returns hash of the snapshot. Can be used to verify that snapshot is correct.
 - `get_user_votes(account_id: AccountId) -> [(AccountId, Balance)]` -- returns votes of the given user. The available for voting weight is balance of this user minus all already casted votes.
 - `get_candidate_count() -> u32` -- number of candidates.
 - `get_candidates(from_index: u32, limit: u32) -> [Candidate]` -- list of candidates from given interval with their votes.
 - `get_candidate(account_id: AccountId) -> Candidate` -- total number of votes casted for given candidate.

Where `Candidate { account_id: AccountId, votes: Balance, gov_forum_link: String}`.

User full balance is retrievable from the snapshot. Frontends and CLI tools must have this snapshot available to retrieve the balance and to compute merkle proof for voting.

> Note, that current voting contract requires manual intervention to set snapshots of the stake due to limitations of lockup/staking contracts pair.
> This problem will be addressed over time, which will allow to transition to vote without extra snapshotting.

## Voting UI

User interface to submit self nomination and vote.

'''
'''--- scripts/snapshot_stake.js ---
const nearAPI = require('near-api-js');
const path = require("path");
const homedir = require("os").homedir();
const BN = require('bn.js');

const credentialsPath = path.join(homedir, ".near-credentials");
const keyStore = new nearAPI.keyStores.UnencryptedFileSystemKeyStore(credentialsPath);

const config = {
  keyStore,
  networkId: "mainnet",
  nodeUrl: "https://rpc.mainnet.near.org",
};

async function resolve_account_id(account, account_id) {
    if (account_id.endsWith('.lockup.near')) {
        return account.viewFunction(account_id, 'get_owner_account_id');
    }
    return account_id;
}

async function writeFile(json, outFile, fields) {
     const Json2csvParser = require('json2csv').Parser;
     const json2csvParser = new Json2csvParser({ fields });
     const csv = json2csvParser.parse(json);
     await require('fs').promises.writeFile(outFile, csv);
}

(async () => {
    const near = await nearAPI.connect(config);
    
    const validators = await near.connection.provider.sendJsonRpc('validators', [null]);
    const accounts = new Map();
    for (let j = 0; j < validators.current_validators.length; ++j) {
        const validatorId = validators.current_validators[j].account_id;
        const validator = await near.account(validatorId);
        const numAccounts = await validator.viewFunction(validatorId, 'get_number_of_accounts');
        console.log(`${j}/${validators.current_validators.length} Fetching ${validatorId}, total ${numAccounts}`);
        for (let i = 0; i < numAccounts; i += 10) {
            const delegates = await validator.viewFunction(validatorId, 'get_accounts', { from_index: i, limit: 10 });
            for (let k = 0; k < delegates.length; ++k) {
                const account_id = await resolve_account_id(validator, delegates[k].account_id);
                const prevValue = accounts.get(account_id) || new BN('0');
                accounts.set(account_id, prevValue.add(new BN(delegates[k].staked_balance)));
            }
        }
        break;
    }

    await writeFile(Array.from(accounts).map(([key, value]) => ({account_id: key, amount: value.toString()})), 'output.csv', ['account_id', 'amount']);
})().catch(e => { console.error(e); process.exit(1); });

'''