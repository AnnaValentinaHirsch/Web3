*GitHub Repository "EV3RETH/ev3reth-website-v2"*

'''--- .eslintrc.json ---
{
  "extends": "next/core-web-vitals"
}

'''
'''--- README.md ---
#EV3RETH
Machine Learning Artist and Composer

TODO:
- full screen video
- autoslide show instead of videos on home page displays
- for mobile video, indicator when play has been clicked but video is loading
- optimize image sizes in AWS
- add snackbar notifications with notistack
- impliment Art Evolved ideas
'''
'''--- components/ev3-particles.js ---
import canvasSketch from 'canvas-sketch';
import random from 'canvas-sketch-util/random';
import math from 'canvas-sketch-util/math';
import interpolate from 'color-interpolate';

const settings = {
  dimensions: [2048, 1024],
  animate: true,
  fps: 12,
  playbackRate: "fixed"
};

const seed = random.getRandomSeed()
console.log("🚀 ~ file: ev3-particles.js:36 ~ seed", seed)
random.setSeed(seed)

const particles = [];
const largeNum = 9999
const cursor = { x: largeNum, y: largeNum, pressure: 1 }
const frequency = 0.001;
const amplitude = 0.35;

let elCanvas;
let imgA, imgB, bgImg, mx, my;

const cols = 80;
const rows = 40;
const numCells = cols * rows
const particleStart = 6
const particleRadius = 16

const hPad = 0.7
const wPad = hPad

const sketch = ({ width, height, canvas, context }) => {
  let x, y, particle, radius;
  // grid
  const gw = Math.ceil(width * wPad)
  const gh = Math.ceil(height * hPad)
  //cell
  const cw = gw / cols;
  const ch = gh / rows;
  //margin
  mx = (width - gw) * 0.5;
  my = (height - gh) * 0.5;

  elCanvas = canvas;
  canvas.addEventListener('pointerdown', onMouseDown)

  //Images
  const bgCanvas = document.createElement('canvas')
  const bgContext = bgCanvas.getContext('2d')
  bgCanvas.width = width;
  bgCanvas.height = height;
  bgContext.globalAlpha = 0.5
  bgContext.drawImage(bgImg, 0, 0, width / 2, height)
  bgContext.drawImage(bgImg, width / 2, 0, width / 2, height)

  const imgAWidth = Math.ceil(imgA.width * wPad)
  const imgAHeight = Math.ceil(imgA.height * hPad)
  const imgACanvas = document.createElement('canvas')
  const imgAContext = imgACanvas.getContext('2d')
  imgACanvas.width = imgAWidth
  imgACanvas.height = imgAHeight
  imgAContext.drawImage(imgA, 0, 0, imgAWidth, imgAHeight)
  const imgAData = imgAContext.getImageData(0, 0, imgAWidth, imgAHeight).data

  const imgBWidth = Math.ceil(imgB.width * wPad)
  const imgBHeight = Math.ceil(imgB.height * hPad)
  const imgBCanvas = document.createElement('canvas')
  const imgBContext = imgBCanvas.getContext('2d')
  imgBCanvas.width = imgBWidth
  imgBCanvas.height = imgBHeight
  imgBContext.drawImage(imgB, 0, 0, imgBWidth, imgBHeight)
  const imgBData = imgBContext.getImageData(0, 0, imgBWidth, imgBHeight).data

  //Particles
  for (let i = 0; i < numCells; i++) {
    let ix, iy, idx, r,g,b,a;
    x = (i % cols) * cw;
    y = Math.floor(i / cols) * ch;

    ix = Math.floor((x / width) * imgA.width) 
    iy = Math.floor((y / height) * imgA.height) 
    idx = (iy * imgAWidth + ix) * 4;

    r = imgAData[idx]
    g = imgAData[idx + 1]
    b = imgAData[idx + 2]
    a = imgAData[idx + 3]
    const colA = `rgba(${ r }, ${ g }, ${ b }, ${ a})`
    radius = math.mapRange(r, 0, 255, particleStart, particleRadius)

    // const offset = i / (numCells);
    // const newRadius = radius - offset
    // radius = newRadius > 0 ? newRadius : radius  

    ix = Math.floor((x / width) * imgB.width)
    iy = Math.floor((y / height) * imgB.height)
    idx = (iy * (imgBWidth) + ix) * 4;

    r = imgBData[idx]
    g = imgBData[idx + 1]
    b = imgBData[idx + 2]
    a = imgBData[idx + 3]
    const colB = `rgba(${ r }, ${ g }, ${ b }, ${a})`

    // const colB = "#" + random.pick(Object.values(myColors.Gainsboro))

    const colMap = interpolate([colA, colB])

    particle = new Particle({ x, y, radius, colMap })
    particles.push(particle)
  }

  
  return ({ context, width, height, frame,  }) => {
    context.globalCompositeOperation = "source-over"
    context.fillStyle = '#222121';
    context.fillRect(0, 0, width, height);

    context.save()
    context.translate(mx, my)
    context.translate(cw / 2, ch / 2)
    particles.sort((a, b) => a.scale - b.scale)
    particles.forEach((particle, index) => {
      const change = frame
      const n = random.noise2D(particle.ix + change, particle.iy + change, frequency, amplitude);

      particle.update(n)
      particle.draw(context, index)
    })
    context.restore()
    
    context.globalCompositeOperation = "multiply"
    context.drawImage(bgCanvas, 0, 0)
  };
};

const onMouseDown = (e) => {
  e.preventDefault()
  e.stopPropagation()
  window.addEventListener('pointermove', onMouseMove);
  window.addEventListener('pointerup', onMouseUp)
  onMouseMove(e)
}
const onMouseMove = (e) => {
  e.preventDefault()
  e.stopPropagation()
  const x = (e.offsetX / elCanvas.offsetWidth) * elCanvas.width - mx;
  const y = (e.offsetY / elCanvas.offsetHeight) * elCanvas.height - my;

  if (e.pointerType === "touch") {
    cursor.pressure = e.pressure + 1
  }
  cursor.x = x
  cursor.y = y
}
const onMouseUp = () => {
  window.removeEventListener('pointermove', onMouseMove);
  window.removeEventListener('pointerup', onMouseUp)
  
  cursor.x = largeNum;
  cursor.y = largeNum;
  cursor.pressure = 1;
}

const loadImage = async (url) => {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img)
    img.onerror = () => reject();
    img.src = url;
  })
}
const drawComplex = ({ context, radius = 100, sides = 3, color }) => {
  const slice = Math.PI * 2 / sides;
  context.beginPath();
  context.moveTo(0, -radius);

  for (let i = 1; i < sides; i++) {
    const theta = i * slice - Math.PI * 0.5;
    let px = Math.cos(theta) * radius
    let py = Math.sin(theta) * radius

    if (i % 2 !== 0) {
      const offset = -0.6
      px *= offset
      py *= offset
    }
    
    context.lineTo(px, py)

  }
  context.closePath()
}
const drawPolygon = ({ context, radius = 100, sides = 3, color }) => {

  const slice = Math.PI * 2 / sides;
  context.beginPath();
  context.moveTo(0, -radius);

  for (let i = 1; i < sides; i++) {
    const theta = i * slice - Math.PI * 0.5;
    let px = Math.cos(theta) * radius
    let py = Math.sin(theta) * radius

    const n = random.noise2D(px, py, 0.5, 20 );

    px += n;
    py += n;

    context.lineTo(px, py)
  }
  context.closePath()
}

const drawCircle = ({ context, radius }) => {
  context.beginPath()
  context.arc(0, 0, radius, 0, Math.PI * 2)
  context.closePath()
} 

const drawPetal = ({ context, radius = 100, sides = 4, color }) => {
  let lastX, lastY;

  const slice = Math.PI * 2 / sides;
  const points = [{ x: 0, y: -radius }]

  for (let i = 1; i < sides; i++) {
    const theta = i * slice - Math.PI * 0.5;
    let px = Math.cos(theta) * radius
    let py = Math.sin(theta) * radius
    const n = random.noise2D(px, py, 1, 10);
    px += n;
    py += n;
    points.push({ x: px, y: py })
  }
  context.beginPath();
  const start = points[0]
  context.moveTo(start.x, start.y);

  for (let c = 0; c < points.length - 1; c++) {
    const curr = points[c];
    const next = points[c + 1];
    const midx = curr.x + (next.x - curr.x) * 0.5;
    const midy = curr.y + (next.y - curr.y) * 0.5;

    context.quadraticCurveTo(curr.x, curr.y, midx, midy)

    lastX = midx
    lastY = midy
  }
  const last = points[points.length - 1]
  const midx = last.x + (start.x - last.x) * 0.5;
  const midy = last.y + (start.y - last.y) * 0.5;

  context.quadraticCurveTo(last.x, last.y, midx, midy)
  context.closePath()
}

export const start = async (canvas) => {
  imgA = await loadImage("images/ev3-plain.png")
  imgB = await loadImage("images/bg-particles.png")
  bgImg = await loadImage("images/white-paper-texture.jpg")
  const settingsCanvas = {
    ...settings,
    canvas
  }
  canvasSketch(sketch, settingsCanvas);
}
// start()

class Particle {
  constructor({ x, y, radius = 10, colMap }) {
    //position
    this.x = x;
    this.y = y;

    //acceleration
    this.ax = 0;
    this.ay = 0;

    //velocity
    this.vx = 0;
    this.vy = 0;

    //initial position
    this.ix = x;
    this.iy = y;

    this.radius = radius;
    this.scale = 1;
    this.colMap = colMap
    this.color = colMap(0)

    this.initSides = random.range(3, 4);
    this.sides = this.initSides
    this.initRotation = 45
    this.rotation = this.initRotation

    this.minDist = random.range(100, 200);
    this.pushFactor = random.range(0.01, 0.02);
    this.pullFactor = random.range(0.0022, 0.0066);
    this.dampFactor = random.range(0.9, 0.95);
  }

  update(noise) {
    let dx, dy, dd, distDelta;
    let idxColor;

    //pull force
    dx = this.ix - this.x;
    dy = this.iy - this.y
    dd = Math.sqrt(dx * dx + dy * dy)

    this.ax = dx * this.pullFactor;
    this.ay = dy * this.pullFactor;

    this.scale = math.mapRange(dd, 0, 200, 1, 3)

    this.color = this.colMap(math.mapRange(dd, 0, 200, 0, 1, true))
    this.rotation = math.mapRange(dd, 0, 200, this.initRotation, this.initRotation + 270)
    
    
    //push force
    dx = this.x - cursor.x;
    dy = this.y - cursor.y;
    dd = Math.sqrt(dx * dx + dy * dy) * cursor.pressure
  
    distDelta = this.minDist - dd;

    if (dd < this.minDist) {
      this.ax += (dx / dd) * distDelta * this.pushFactor;
      this.ay += (dy / dd) * distDelta * this.pushFactor;
    }

    this.vx += this.ax;
    this.vy += this.ay;

    this.vx *= this.dampFactor;
    this.vy *= this.dampFactor;

    this.x += this.vx;
    this.y += this.vy;

    this.x += noise;
    this.y += noise / 2;
  }

  draw(context, index) {
    context.save();

    context.translate(this.x, this.y);
    context.rotate(math.degToRad(this.rotation))
    context.fillStyle = this.color

    const scaledRadius = this.radius * this.scale
    if (this.radius > (particleStart + particleRadius) / 2 || this.scale > 2.5) {
      context.shadowColor = "black"
      context.shadowOffsetX = -scaledRadius * 0.1;
      context.shadowOffsetY = scaledRadius * 0.1;
    }
  
    const option = {
      context,
      radius: scaledRadius,
      sides: this.sides,
      color: this.color
    }

    // drawRoundedPolygon(option)
    drawPetal(option)
    // drawComplex(option)
    // drawPolygon(option)
    // drawCircle(option)

    context.fill()
    context.restore()
  }
}

'''
'''--- next-env.d.ts ---
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

'''
'''--- next.config.js ---
/** @type {import('next').NextConfig} */

const nextConfig = {
  reactStrictMode: true,
  images: {
    domains: ["res.cloudinary.com", "ev3reth.s3.us-west-2.amazonaws.com", "ipfs.fleek.co", "gateway.ipfs.io"]
  },
  webpack(config) {
    config.module.rules.push({
      test: /\.svg$/,
      use: ["@svgr/webpack"]
    });

    return config;
  }
}

module.exports = nextConfig

'''
'''--- package.json ---
{
  "name": "ev3reth-website",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@emotion/react": "^11.10.0",
    "@emotion/styled": "^11.10.0",
    "@mui/icons-material": "^5.8.4",
    "@mui/material": "^5.9.3",
    "@svgr/webpack": "^6.3.1",
    "canvas-sketch": "^0.7.6",
    "canvas-sketch-util": "^1.10.0",
    "color-interpolate": "^1.0.5",
    "near-api-js": "^0.45.1",
    "next": "12.2.4",
    "next-images": "^1.8.4",
    "react": "18.2.0",
    "react-dom": "18.2.0",
    "react-player": "^2.11.0",
    "swiper": "^8.3.2"
  },
  "devDependencies": {
    "@types/node": "18.6.4",
    "@types/react": "18.0.15",
    "eslint": "8.21.0",
    "eslint-config-next": "12.2.4",
    "typescript": "4.7.4"
  }
}

'''
'''--- pages/api/hello.ts ---
// Next.js API route support: https://nextjs.org/docs/api-routes/introduction
import type { NextApiRequest, NextApiResponse } from 'next'

type Data = {
  name: string
}

export default function handler(
  req: NextApiRequest,
  res: NextApiResponse<Data>
) {
  res.status(200).json({ name: 'John Doe' })
}

'''
'''--- public/curve.svg ---
<svg id="eXG2ySV0chP1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1600 150" shape-rendering="geometricPrecision" text-rendering="geometricPrecision"><path d="M-1.214312,6.402817c0-6.837986,0,0,0-6.837986c273.010224,0,1010.741914,0,1600.706868,0c0,6.837986-.706868,6.837986-.140483,6.837986C1449.012816,6.402817,1499.344887,150,1302.036029,150s-305.254433-138.563309-703.609379-138.563309c-239.448437,0-365.549138,28.490494-447.928113,28.490494s-98.736008-33.524368-151.712849-33.524368Z" transform="translate(1.214312 0.435169)" stroke-width="3.072"/></svg>
'''
'''--- public/curve3.svg ---
<svg id="e9qh7uLeVsT1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 1600 150" shape-rendering="geometricPrecision" text-rendering="geometricPrecision"><path d="M-1.214312,6.402817c0-6.837986,0,0,0-6.837986c273.010224,0,1010.741914,0,1600.706868,0c0,6.837986-.706868,6.837986-.140483,6.837986-151.895481,0-150.228879,143.162014-297.316044,143.597183s-305.254433-138.563309-703.609379-138.563309c-224.621233,0-187.059941,48.681929-298.036485,48.681929s-170.733145-53.715803-301.604477-53.715803Z" transform="translate(1.214312 0.435169)" stroke-width="3.072"/></svg>
'''
'''--- styles/Home.module.css ---

'''
'''--- styles/globals.css ---
html,
body {
  padding: 0;
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,
    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
}

a {
  color: inherit;
}
button a {
  text-decoration: none;
}

* {
  box-sizing: border-box;
}

'''
'''--- styles/theme.ts ---
import { createTheme, responsiveFontSizes, SxProps, Theme, alpha } from "@mui/material/styles";

let theme = createTheme({
  palette: {
    primary: {
      main: '#212121',
      light: "#272727"
    },
    secondary: {
      main: '#84738c',
    },
    error: {
      main: '#e57373',
    },
    warning: {
      main: '#ffb74d',
    },
    info: {
      main: '#64b5f6',
    },
    success: {
      main: '#81c784',
    },
    background: {
      default: '#f5f5f5',
    },
  },
  typography: {
    fontFamily: 'Quicksand',
  },
});

theme = responsiveFontSizes(theme);

export default theme;

export const blackBgSx: SxProps<Theme> = {
  backgroundColor: alpha(theme.palette.primary.main, 1),
  typography: {
    color: theme.palette.background.paper,
  }
}

export const whiteBgSx: SxProps<Theme> = {
  typography: {
    textShadow: "1px 2px 3px rgba(0,0,0,0.3)"
  }
}

export const maxDisplayWidth = 1536;

export const getGradientTextStyle = (gradient: string) => ({
  background: gradient,
  backgroundClip: 'text',
  textFillColor: 'transparent',
  WebkitBackgroundClip: 'text',
  WebkitTextFillColor: 'transparent',
  WebkitBoxDecorationBreak: 'clone',
  MozBackgroundClip: 'text',
  MozTextFillColor: 'transparent',
  MozBoxDecorationBreak: 'clone',
})

'''
'''--- tsconfig.json ---
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}

'''
'''--- utils/contentMapping.ts ---
import { Content, truncateOwnerId } from "../hooks/useContract"

type ContentMap = { [key: number]: Content }
export const t3rraIds = [12,11,10,9,8,7,6,5,4,3,2,1]//[1,2,3,4,5,6,7,8,9,10,11,12]
export const snxev3Ids = Array.from(Array(30).keys())
const CONTENT: {[key: string]: ContentMap} = {
  "mint.snxev3.near": snxev3Ids.reduce((acc: ContentMap, id) => {
    acc[id] = {
      type: "image",
      normal: `https://ev3reth.s3.us-west-2.amazonaws.com/SNxEV3-images/SNxEV3-${id}.png`,
      hiRes: `https://ev3reth.s3.us-west-2.amazonaws.com/SNxEV3-upres-images/SNxEV3-${id}-4k.png`,
    }
    return acc
  }, {}),
  "ev3.neartopia.near": t3rraIds.reduce((acc: ContentMap, id) => {
    acc[id] = {
      type: "image", // id < 27 ? "image" : "video",
      normal: `https://ev3reth.s3.us-west-2.amazonaws.com/T3RRA/T3RRA-${id}.png`,
    }
    return acc
  }, {}),
  "tune-out-by-ev3rethnear": {
    253374: {
      type: "video",
      normal: "https://ev3reth.s3.us-west-2.amazonaws.com/Tune-Out/CH1+-+The+Endless.mp4"
    },
    253392: {
      type: "video",
      normal: "https://ev3reth.s3.us-west-2.amazonaws.com/Tune-Out/CH2+-+The+Expanse.mp4"
    },
    253401: {
      type: "video",
      normal: "https://ev3reth.s3.us-west-2.amazonaws.com/Tune-Out/CH3+-+The+Serene.mp4"
    },
    253415: {
      type: "video",
      normal: "https://ev3reth.s3.us-west-2.amazonaws.com/Tune-Out/CH4+-+The+Disturbed.mp4"
    },
    253421: {
      type: "video",
      normal: "https://ev3reth.s3.us-west-2.amazonaws.com/Tune-Out/CH5+-+The+Traveler.mp4"
    },
    253461: {
      type: "video",
      normal: "https://ev3reth.s3.us-west-2.amazonaws.com/Tune-Out/CH6+-+The+Mystic.mp4"
    }
  }
}

export default CONTENT

export type OwnerItem = { [key: number]: string }
export type OwnerMap = { [key: string]: OwnerItem }
export const OWNERS: OwnerMap = {
  "mint.snxev3.near": snxev3Ids.reduce((acc: OwnerItem, id) => {
    acc[id] = "";
    return acc
  }, {}),
  "ev3.neartopia.near": t3rraIds.reduce((acc: OwnerItem, id) => {
    acc[id] = ""
    return acc
  }, {}),
  "tune-out-by-ev3rethnear": {
    253374: "",
    253392: "",
    253401: "",
    253415: "",
    253421: "",
    253461: ""
  }
}

export const getOwnerText = (owners: OwnerMap, contractMappingId?: string, tokenId?: number, prefix = " ❖ ", suffix = "") => {
  const owner = (contractMappingId && tokenId !== undefined) ? owners[contractMappingId][tokenId] : null
  return  owner ? `${prefix}${truncateOwnerId(owner)}${suffix}` : ""
}
'''
'''--- utils/links.ts ---
export const DISCORD_LINK = "https://discord.gg/CwvgaWdfwM"
export const TWITTER_LINK = "https://twitter.com/EV3RETH"
export const EVE_GENESIS_SECONDARY_LINK = "https://exchange.art/series/T3RRA/nfts"//"https://paras.id/collection/ev3.neartopia.near"
export const SNXEV3_SECONDARY_LINK = "https://paras.id/collection/mint.snxev3.near"
export const MEDIUM_MODEL_IS_ART_PART1_LINK = "https://medium.com/@EV3RETH/the-model-is-the-art-pondering-the-new-paradigm-of-generative-art-d474897655bd"
export const MEDIUM_MODEL_IS_ART_PART2_LINK = "https://medium.com/@EV3RETH/the-model-is-the-art-the-making-of-ev3-genesis-141c454a3eda"
export const TUNE_OUT_ARTICLE_LINK = "https://paras.id/publication/tune-out-621670f9b1808d092e26027f"
export const TUNE_OUT_SECONDARY_LINK = "https://paras.id/collection/tune-out-by-ev3rethnear"
export const MAIN_TITLE_LINK = "https://ev3reth.s3.us-west-2.amazonaws.com/misc/EV3RETH-black.png"
// export const SMALL_LOGO_LINK = "https://ev3reth.s3.us-west-2.amazonaws.com/misc/logo-100.png"
export const SMALL_LOGO_LINK = "/symbol-100.png"
export const PARAS_COLLECTIONS = "https://paras.id/ev3reth.near/collections"
export const T3RRA_MARKET_LINK = "https://exchange.art/series/T3RRA/nfts"
export const T3RRA_ABOUT_LINK = "https://exchange.art/series/T3RRA/about"
export const PRELUDES_MARKET_LINK = "https://exchange.art/series/edit/H7AXAFMYmoCub3gg2IbJ/live"
'''